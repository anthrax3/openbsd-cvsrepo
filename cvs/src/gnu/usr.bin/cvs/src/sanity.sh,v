head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.18.0.62
	OPENBSD_6_0_BASE:1.1.1.18
	OPENBSD_5_9:1.1.1.18.0.58
	OPENBSD_5_9_BASE:1.1.1.18
	OPENBSD_5_8:1.1.1.18.0.60
	OPENBSD_5_8_BASE:1.1.1.18
	OPENBSD_5_7:1.1.1.18.0.52
	OPENBSD_5_7_BASE:1.1.1.18
	OPENBSD_5_6:1.1.1.18.0.56
	OPENBSD_5_6_BASE:1.1.1.18
	OPENBSD_5_5:1.1.1.18.0.54
	OPENBSD_5_5_BASE:1.1.1.18
	OPENBSD_5_4:1.1.1.18.0.50
	OPENBSD_5_4_BASE:1.1.1.18
	OPENBSD_5_3:1.1.1.18.0.48
	OPENBSD_5_3_BASE:1.1.1.18
	OPENBSD_5_2:1.1.1.18.0.46
	OPENBSD_5_2_BASE:1.1.1.18
	OPENBSD_5_1_BASE:1.1.1.18
	OPENBSD_5_1:1.1.1.18.0.44
	OPENBSD_5_0:1.1.1.18.0.42
	OPENBSD_5_0_BASE:1.1.1.18
	OPENBSD_4_9:1.1.1.18.0.40
	OPENBSD_4_9_BASE:1.1.1.18
	OPENBSD_4_8:1.1.1.18.0.38
	OPENBSD_4_8_BASE:1.1.1.18
	OPENBSD_4_7:1.1.1.18.0.34
	OPENBSD_4_7_BASE:1.1.1.18
	OPENBSD_4_6:1.1.1.18.0.36
	OPENBSD_4_6_BASE:1.1.1.18
	OPENBSD_4_5:1.1.1.18.0.32
	OPENBSD_4_5_BASE:1.1.1.18
	OPENBSD_4_4:1.1.1.18.0.30
	OPENBSD_4_4_BASE:1.1.1.18
	OPENBSD_4_3:1.1.1.18.0.28
	OPENBSD_4_3_BASE:1.1.1.18
	OPENBSD_4_2:1.1.1.18.0.26
	OPENBSD_4_2_BASE:1.1.1.18
	OPENBSD_4_1:1.1.1.18.0.24
	OPENBSD_4_1_BASE:1.1.1.18
	OPENBSD_4_0:1.1.1.18.0.22
	OPENBSD_4_0_BASE:1.1.1.18
	OPENBSD_3_9:1.1.1.18.0.20
	OPENBSD_3_9_BASE:1.1.1.18
	OPENBSD_3_8:1.1.1.18.0.18
	OPENBSD_3_8_BASE:1.1.1.18
	OPENBSD_3_7:1.1.1.18.0.16
	OPENBSD_3_7_BASE:1.1.1.18
	OPENBSD_3_6:1.1.1.18.0.14
	OPENBSD_3_6_BASE:1.1.1.18
	OPENBSD_3_5:1.1.1.18.0.12
	OPENBSD_3_5_BASE:1.1.1.18
	OPENBSD_3_4:1.1.1.18.0.10
	OPENBSD_3_4_BASE:1.1.1.18
	OPENBSD_3_3:1.1.1.18.0.8
	OPENBSD_3_3_BASE:1.1.1.18
	OPENBSD_3_2:1.1.1.18.0.6
	OPENBSD_3_2_BASE:1.1.1.18
	OPENBSD_3_1:1.1.1.18.0.4
	OPENBSD_3_1_BASE:1.1.1.18
	OPENBSD_3_0:1.1.1.18.0.2
	OPENBSD_3_0_BASE:1.1.1.18
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.1.1.17.0.2
	OPENBSD_2_9_BASE:1.1.1.17
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.1.1.16.0.6
	OPENBSD_2_8_BASE:1.1.1.16
	OPENBSD_2_7:1.1.1.16.0.4
	OPENBSD_2_7_BASE:1.1.1.16
	OPENBSD_2_6:1.1.1.16.0.2
	OPENBSD_2_6_BASE:1.1.1.16
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.1.1.15.0.2
	OPENBSD_2_5_BASE:1.1.1.15
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.1.1.14.0.2
	OPENBSD_2_4_BASE:1.1.1.14
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.1.1.12.0.2
	OPENBSD_2_3_BASE:1.1.1.12
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.1.1.10.0.2
	OPENBSD_2_2_BASE:1.1.1.10
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.1.1.9.0.2
	OPENBSD_2_1_BASE:1.1.1.9
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.45;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.26;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.03;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.12;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.06;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.47;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.37.59;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.26.34;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.28.25;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.20.49;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.06.58.06;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.03.53.20;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.52.30;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.32.15;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.06.17;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.18.57.34;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.45.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/bin/sh
# a quick sanity test for cvs.
#
# Copyright (C) 1992, 1993 Cygnus Support
#
# Original Author: K. Richard Pixley

# usage: sanity.sh [-r] @@var{cvs-to-test}
# -r means to test remote instead of local cvs.

# See TODO list at end of file.

TESTDIR=/tmp/cvs-sanity

# "debugger"
#set -x

echo This test should produce no other output than this line, and "Ok."

# clean any old remnants
rm -rf ${TESTDIR}

if test x"$1" = x"-r"; then
  shift
  remote=yes
else
  remote=no
fi

testcvs=$1; shift

# Remaining arguments are the names of tests to run.
if test x"$*" = x; then
  tests="basic0 basic1 basic2 basic3 rtags death import new conflicts modules mflag errmsg1"
else
  tests="$*"
fi

# fixme: try things (what things? checkins?) without -m.
# Some of these tests are written to expect -Q.  But testing with
# -Q is kind of bogus, it is not the way users actually use CVS (usually).
# So new tests probably should invoke ${testcvs} directly, rather than ${CVS}.
CVS="${testcvs} -Q"

LOGFILE=`pwd`/check.log
if test -f check.log; then mv check.log check.plog; fi

mkdir ${TESTDIR}
cd ${TESTDIR}

# so far so good.  Let's try something harder.

# this should die
if ${CVS} -d `pwd`/cvsroot co cvs-sanity 2>> ${LOGFILE} ; then
  echo "FAIL: test 1" | tee -a ${LOGFILE}; exit 1
else
  echo "PASS: test 1" >>${LOGFILE}
fi

# this should still die
mkdir cvsroot
if ${CVS} -d `pwd`/cvsroot co cvs-sanity 2>> ${LOGFILE} ; then
  echo "FAIL: test 2" | tee -a ${LOGFILE}; exit 1
else
  echo "PASS: test 2" >>${LOGFILE}
fi

# this should still die
mkdir cvsroot/CVSROOT
if ${CVS} -d `pwd`/cvsroot co cvs-sanity 2>> ${LOGFILE} ; then
  echo "FAIL: test 3" | tee -a ${LOGFILE}; exit 1
else
  echo "PASS: test 3" >>${LOGFILE}
fi

# This one should work, although it should spit a warning.
mkdir tmp ; cd tmp
${CVS} -d `pwd`/../cvsroot co CVSROOT 2>> ${LOGFILE}
cd .. ; rm -rf tmp

# This one should succeed.  No warnings.
echo 'CVSROOT		-i mkmodules CVSROOT' > cvsroot/CVSROOT/modules
mkdir tmp ; cd tmp
if ${CVS} -d `pwd`/../cvsroot co CVSROOT ; then
  echo "PASS: test 4" >>${LOGFILE}
else
  echo "FAIL: test 4" | tee -a ${LOGFILE}; exit 1
fi

cd .. ; rm -rf tmp

# Try setting CVSROOT so we don't have to worry about it anymore.  (now that
# we've tested -d cvsroot.)
CVSROOT_FILENAME=`pwd`/cvsroot
CVSROOT=${CVSROOT_FILENAME} ; export CVSROOT
if test "x$remote" = xyes; then
  CVSROOT=`hostname`:${CVSROOT_FILENAME} ; export CVSROOT
  # Use rsh so we can test it without having to muck with inetd or anything 
  # like that.  Also needed to get CVS_SERVER to work.
  CVS_CLIENT_PORT=-1; export CVS_CLIENT_PORT
  CVS_SERVER=${testcvs}; export CVS_SERVER
fi

mkdir tmp ; cd tmp
if ${CVS} -d `pwd`/../cvsroot co CVSROOT ; then
  echo "PASS: test 5" >>${LOGFILE}
else
  echo "FAIL: test 5" | tee -a ${LOGFILE}; exit 1
fi

cd .. ; rm -rf tmp

# start keeping history
touch ${CVSROOT_FILENAME}/CVSROOT/history

### The big loop
for what in $tests; do
	case $what in
	basic0) # Now, let's build something.
#		mkdir first-dir
		# this doesn't yet work, though I think maybe it should.  xoxorich.
#		if ${CVS} add first-dir ; then
#			true
#		else
#			echo cvs does not yet add top level directories cleanly.
			mkdir ${CVSROOT_FILENAME}/first-dir
#		fi
#		rm -rf first-dir

		# check out an empty directory
		if ${CVS} co first-dir ; then
		  echo "PASS: test 6" >>${LOGFILE}
		else
		  echo "FAIL: test 6" | tee -a ${LOGFILE}; exit 1
		fi

		# update the empty directory
		if ${CVS} update first-dir ; then
		  echo "PASS: test 7" >>${LOGFILE}
		else
		  echo "FAIL: test 7" | tee -a ${LOGFILE}; exit 1
		fi

		# diff -u the empty directory
		if ${CVS} diff -u first-dir ; then
		  echo "PASS: test 8" >>${LOGFILE}
		else
		  echo "FAIL: test 8" | tee -a ${LOGFILE}; exit 1
		fi

		# diff -c the empty directory
		if ${CVS} diff -c first-dir ; then
		  echo "PASS: test 9" >>${LOGFILE}
		else
		  echo "FAIL: test 9" | tee -a ${LOGFILE}; exit 1
		fi

		# log the empty directory
		if ${CVS} log first-dir ; then
		  echo "PASS: test 10" >>${LOGFILE}
		else
		  echo "FAIL: test 10" | tee -a ${LOGFILE}; exit 1
		fi

		# status the empty directory
		if ${CVS} status first-dir ; then
		  echo "PASS: test 11" >>${LOGFILE}
		else
		  echo "FAIL: test 11" | tee -a ${LOGFILE}; exit 1
		fi

		# tag the empty directory
		if ${CVS} tag first first-dir  ; then
		  echo "PASS: test 12" >>${LOGFILE}
		else
		  echo "FAIL: test 12" | tee -a ${LOGFILE}; exit 1
		fi

		# rtag the empty directory
		if ${CVS} rtag empty first-dir  ; then
		  echo "PASS: test 13" >>${LOGFILE}
		else
		  echo "FAIL: test 13" | tee -a ${LOGFILE}; exit 1
		fi
		;;

	basic1) # first dive - add a files, first singly, then in a group.
		rm -rf ${CVSROOT_FILENAME}/first-dir
		rm -rf first-dir
		mkdir ${CVSROOT_FILENAME}/first-dir
		# check out an empty directory
		if ${CVS} co first-dir  ; then
		  echo "PASS: test 13a" >>${LOGFILE}
		else
		  echo "FAIL: test 13a" | tee -a ${LOGFILE}; exit 1
		fi

		cd first-dir
		files=first-file
		for i in a b ; do
			for j in ${files} ; do
				echo $j > $j
			done

			for do in add rm ; do
				for j in ${do} "commit -m test" ; do
					# ${do}
					if ${CVS} $j ${files}  >> ${LOGFILE} 2>&1; then
					  echo "PASS: test 14-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 14-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

					# update it.
					if [ "${do}" = "rm" -a "$j" != "commit -m test" ] || ${CVS} update ${files} ; then
					  echo "PASS: test 15-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 15-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

					# update all.
					if ${CVS} update  ; then
					  echo "PASS: test 16-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 16-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

					# status all.
					if ${CVS} status  >> ${LOGFILE}; then
					  echo "PASS: test 17-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 17-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

		# fixme: this one doesn't work yet for added files.
					# log all.
					if ${CVS} log  >> ${LOGFILE}; then
					  echo "PASS: test 18-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 18-${do}-$j" | tee -a ${LOGFILE}
					fi

					if test "x${do}-$j" = "xadd-add" || test "x${do}-$j" = "xrm-rm" ; then
					  true
					else
					  # diff -c all
					  if ${CVS} diff -c  >> ${LOGFILE} || [ $? = 1 ] ; then
					    echo "PASS: test 19-${do}-$j" >>${LOGFILE}
					  else
					    echo "FAIL: test 19-${do}-$j" | tee -a ${LOGFILE}
					  fi

					  # diff -u all
					  if ${CVS} diff -u  >> ${LOGFILE} || [ $? = 1 ] ; then
					    echo "PASS: test 20-${do}-$j" >>${LOGFILE}
					  else
					    echo "FAIL: test 20-${do}-$j" | tee -a ${LOGFILE}
					  fi
					fi

					cd ..
					# update all.
					if ${CVS} update  ; then
					  echo "PASS: test 21-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 21-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

					# log all.
		# fixme: doesn't work right for added files.
					if ${CVS} log first-dir  >> ${LOGFILE}; then
					  echo "PASS: test 22-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 22-${do}-$j" | tee -a ${LOGFILE}
					fi

					# status all.
					if ${CVS} status first-dir  >> ${LOGFILE}; then
					  echo "PASS: test 23-${do}-$j" >>${LOGFILE}
					else
					  echo "FAIL: test 23-${do}-$j" | tee -a ${LOGFILE}; exit 1
					fi

					# update all.
					if ${CVS} update first-dir  ; then
						true
					else
						echo '***' failed test 24-${do}-$j. ; exit 1
					fi

					if test "x${do}-$j" = "xadd-add" || test "x${do}-$j" = "xrm-rm" ; then
					  true
					else
					  # diff all
					  if ${CVS} diff -u  >> ${LOGFILE} || [ $? = 1 ] ; then
					    true
					  else
					    echo '***' failed test 25-${do}-$j. # FIXME; exit 1
					  fi

					  # diff all
					  if ${CVS} diff -u first-dir  >> ${LOGFILE} || [ $? = 1 ] ; then
					    true
					  else
					    echo '***' failed test 26-${do}-$j. # FIXME; exit 1
					  fi
					fi

					# update all.
					if ${CVS} co first-dir  ; then
						true
					else
						echo '***' failed test 27-${do}-$j. ; exit 1
					fi

					cd first-dir
				done # j
				rm -f ${files}
			done # do

			files="file2 file3 file4 file5"
		done
		if ${CVS} tag first-dive  ; then
			true
		else
			echo '***' failed test 28. ; exit 1
		fi
		cd ..
		;;

	basic2) # second dive - add bunch o' files in bunch o' added directories
		for i in first-dir dir1 dir2 dir3 dir4 ; do
			if [ ! -d $i ] ; then
				mkdir $i
				if ${CVS} add $i  >> ${LOGFILE}; then
					true
				else
					echo '***' failed test 29-$i. ; exit 1
				fi
			fi

			cd $i

			for j in file6 file7 file8 file9 file10 file11 file12 file13; do
				echo $j > $j
			done

			if ${CVS} add file6 file7 file8 file9 file10 file11 file12 file13  2>> ${LOGFILE}; then
				true
			else
				echo '***' failed test 30-$i-$j. ; exit 1
			fi
		done
		cd ../../../../..
		if ${CVS} update first-dir  ; then
			true
		else
			echo '***' failed test 31. ; exit 1
		fi

		# fixme: doesn't work right for added files.
		if ${CVS} log first-dir  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 32. # ; exit 1
		fi

		if ${CVS} status first-dir  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 33. ; exit 1
		fi

#		if ${CVS} diff -u first-dir   >> ${LOGFILE} || [ $? = 1 ] ; then
#			true
#		else
#			echo '***' failed test 34. # ; exit 1
#		fi

		if ${CVS} ci -m "second dive" first-dir  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 35. ; exit 1
		fi

		if ${CVS} tag second-dive first-dir  ; then
			true
		else
			echo '***' failed test 36. ; exit 1
		fi
		;;

	basic3) # third dive - in bunch o' directories, add bunch o' files, delete some, change some.
		for i in first-dir dir1 dir2 dir3 dir4 ; do
			cd $i

			# modify some files
			for j in file6 file8 file10 file12 ; do
				echo $j >> $j
			done

			# delete some files
			rm file7 file9 file11 file13

			if ${CVS} rm file7 file9 file11 file13  2>> ${LOGFILE}; then
				true
			else
				echo '***' failed test 37-$i. ; exit 1
			fi

			# and add some new ones
			for j in file14 file15 file16 file17 ; do
				echo $j > $j
			done

			if ${CVS} add file14 file15 file16 file17  2>> ${LOGFILE}; then
				true
			else
				echo '***' failed test 38-$i. ; exit 1
			fi
		done
		cd ../../../../..
		if ${CVS} update first-dir  ; then
			true
		else
			echo '***' failed test 39. ; exit 1
		fi

		# fixme: doesn't work right for added files
		if ${CVS} log first-dir  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 40. # ; exit 1
		fi

		if ${CVS} status first-dir  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 41. ; exit 1
		fi

#		if ${CVS} diff -u first-dir  >> ${LOGFILE} || [ $? = 1 ] ; then
#			true
#		else
#			echo '***' failed test 42. # ; exit 1
#		fi

		if ${CVS} ci -m "third dive" first-dir  >>${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 43. ; exit 1
		fi

		if ${CVS} tag third-dive first-dir  ; then
			true
		else
			echo '***' failed test 44. ; exit 1
		fi

		# Hmm...  fixme.
#		if ${CVS} release first-dir  ; then
#			true
#		else
#			echo '***' failed test 45. # ; exit 1
#		fi

		# end of third dive
		rm -rf first-dir
		;;

	rtags) # now try some rtags
		# rtag HEADS
		if ${CVS} rtag rtagged-by-head first-dir  ; then
			true
		else
			echo '***' failed test 46. ; exit 1
		fi

		# tag by tag
		if ${CVS} rtag -r rtagged-by-head rtagged-by-tag first-dir  ; then
			true
		else
			echo '***' failed test 47. ; exit 1
		fi

		# tag by revision
		if ${CVS} rtag -r1.1 rtagged-by-revision first-dir  ; then
			true
		else
			echo '***' failed test 48. ; exit 1
		fi

		# rdiff by revision
		if ${CVS} rdiff -r1.1 -rrtagged-by-head first-dir  >> ${LOGFILE} || [ $? = 1 ] ; then
			true
		else
			echo '***' failed test 49. ; exit 1
		fi

		# now export by rtagged-by-head and rtagged-by-tag and compare.
		rm -rf first-dir
		if ${CVS} export -r rtagged-by-head first-dir  ; then
			true
		else
			echo '***' failed test 50. ; exit 1
		fi

		mv first-dir 1dir
		if ${CVS} export -r rtagged-by-tag first-dir  ; then
			true
		else
			echo '***' failed test 51. ; exit 1
		fi

		if diff -c -r 1dir first-dir ; then
			true
		else
			echo '***' failed test 52. ; exit 1
		fi
		rm -rf 1dir first-dir

		# For some reason, this command has stopped working and hence much of this sequence is currently off.
		# export by revision vs checkout by rtagged-by-revision and compare.
#		if ${CVS} export -r1.1 first-dir  ; then
#			true
#		else
#			echo '***' failed test 53. # ; exit 1
#		fi
		# note sidestep below
		#mv first-dir 1dir

		if ${CVS} co -rrtagged-by-revision first-dir  ; then
			true
		else
			echo '***' failed test 54. ; exit 1
		fi
		# fixme: this is here temporarily to sidestep test 53.
		ln -s first-dir 1dir

		# directory copies are done in an oblique way in order to avoid a bug in sun's tmp filesystem.
		mkdir first-dir.cpy ; (cd first-dir ; tar cf - * | (cd ../first-dir.cpy ; tar xf -))

		if diff --exclude=CVS -c -r 1dir first-dir ; then
			true
		else
			echo '***' failed test 55. ; exit 1
		fi

		# interrupt, while we've got a clean 1.1 here, let's import it into another tree.
		cd 1dir
		if ${CVS} import -m "first-import" second-dir first-immigration immigration1 immigration1_0  ; then
			true
		else
			echo '***' failed test 56. ; exit 1
		fi
		cd ..

		if ${CVS} export -r HEAD second-dir  ; then
			true
		else
			echo '***' failed test 57. ; exit 1
		fi

		if diff --exclude=CVS -c -r first-dir second-dir ; then
			true
		else
			echo '***' failed test 58. ; exit 1
		fi

		rm -rf 1dir first-dir
		mkdir first-dir
		(cd first-dir.cpy ; tar cf - * | (cd ../first-dir ; tar xf -))

		# update the top, cancelling sticky tags, retag, update other copy, compare.
		cd first-dir
		if ${CVS} update -A -l *file*  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 59. ; exit 1
		fi

		# If we don't delete the tag first, cvs won't retag it.
		# This would appear to be a feature.
		if ${CVS} tag -l -d rtagged-by-revision  ; then
			true
		else
			echo '***' failed test 60a. ; exit 1
		fi
		if ${CVS} tag -l rtagged-by-revision  ; then
			true
		else
			echo '***' failed test 60b. ; exit 1
		fi

		cd .. ; mv first-dir 1dir
		mv first-dir.cpy first-dir ; cd first-dir
		if ${CVS} diff -u  >> ${LOGFILE} || [ $? = 1 ] ; then
			true
		else
			echo '***' failed test 61. ; exit 1
		fi

		if ${CVS} update  ; then
			true
		else
			echo '***' failed test 62. ; exit 1
		fi

		cd ..

# Haven't investigated why this is failing.
#		if diff --exclude=CVS -c -r 1dir first-dir ; then
#			true
#		else
#			echo '***' failed test 63. # ; exit 1
#		fi
		rm -rf 1dir first-dir

		if ${CVS} his -e -a  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 64. ; exit 1
		fi
		;;

	death) # next dive.  test death support.
		rm -rf ${CVSROOT_FILENAME}/first-dir
		mkdir  ${CVSROOT_FILENAME}/first-dir
		if ${CVS} co first-dir  ; then
			true
		else
			echo '***' failed test 65 ; exit 1
		fi

		cd first-dir

		# add a file.
		touch file1
		if ${CVS} add file1  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 66 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 67 ; exit 1
		fi

		# remove
		rm file1
		if ${CVS} rm file1  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 68 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >>${LOGFILE} ; then
			true
		else
			echo '***' failed test 69 ; exit 1
		fi

		# add again and create second file
		touch file1 file2
		if ${CVS} add file1 file2  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 70 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 71 ; exit 1
		fi

		# log
		if ${CVS} log file1  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 72 ; exit 1
		fi


		# branch1
		if ${CVS} tag -b branch1  ; then
			true
		else
			echo '***' failed test 73 ; exit 1
		fi

		# and move to the branch.
		if ${CVS} update -r branch1  ; then
			true
		else
			echo '***' failed test 74 ; exit 1
		fi

		# add a file in the branch
		echo line1 from branch1 >> file3
		if ${CVS} add file3  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 75 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 76 ; exit 1
		fi

		# remove
		rm file3
		if ${CVS} rm file3  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 77 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >>${LOGFILE} ; then
			true
		else
			echo '***' failed test 78 ; exit 1
		fi

		# add again
		echo line1 from branch1 >> file3
		if ${CVS} add file3  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 79 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 80 ; exit 1
		fi

		# change the first file
		echo line2 from branch1 >> file1

		# commit
		if ${CVS} ci -m test  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 81 ; exit 1
		fi

		# remove the second
		rm file2
		if ${CVS} rm file2  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 82 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >>${LOGFILE}; then
			true
		else
			echo '***' failed test 83 ; exit 1
		fi

		# back to the trunk.
		if ${CVS} update -A  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 84 ; exit 1
		fi

		if [ -f file3 ] ; then
			echo '***' failed test 85 ; exit 1
		else
			true
		fi

		# join
		if ${CVS} update -j branch1  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 86 ; exit 1
		fi

		if [ -f file3 ] ; then
			true
		else
			echo '***' failed test 87 ; exit 1
		fi

		# update
		if ${CVS} update  ; then
			true
		else
			echo '***' failed test 88 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >>${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 89 ; exit 1
		fi

		# remove first file.
		rm file1
		if ${CVS} rm file1  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 90 ; exit 1
		fi

		# commit
		if ${CVS} ci -m test  >>${LOGFILE}; then
			true
		else
			echo '***' failed test 91 ; exit 1
		fi

		if [ -f file1 ] ; then
			echo '***' failed test 92 ; exit 1
		else
			true
		fi

		# back to branch1
		if ${CVS} update -r branch1  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 93 ; exit 1
		fi

		if [ -f file1 ] ; then
			true
		else
			echo '***' failed test 94 ; exit 1
		fi

		# and join
		if ${CVS} update -j HEAD  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 95 ; exit 1
		fi

		cd .. ; rm -rf first-dir ${CVSROOT_FILENAME}/first-dir
		;;

	import) # test death after import
		# import
		mkdir import-dir ; cd import-dir

		for i in 1 2 3 4 ; do
			echo imported file"$i" > imported-file"$i"
		done

		if ${CVS} import -m first-import first-dir vendor-branch junk-1_0  ; then
			true
		else
			echo '***' failed test 96 ; exit 1
		fi
		cd ..

		# co
		if ${CVS} co first-dir  ; then
			true
		else
			echo '***' failed test 97 ; exit 1
		fi

		cd first-dir
		for i in 1 2 3 4 ; do
			if [ -f imported-file"$i" ] ; then
				true
			else
				echo '***' failed test 98-$i ; exit 1
			fi
		done

		# remove
		rm imported-file1
		if ${CVS} rm imported-file1  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 99 ; exit 1
		fi

		# change
		# this sleep is significant.  Otherwise, on some machines, things happen so
		# fast that the file mod times do not differ.
		sleep 1
		echo local-change >> imported-file2

		# commit
		if ${CVS} ci -m local-changes  >> ${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 100 ; exit 1
		fi

		# log
		if ${CVS} log imported-file1 | grep '1.1.1.2 (dead)'  ; then
			echo '***' failed test 101 ; exit 1
		else
			true
		fi

		# update into the vendor branch.
		if ${CVS} update -rvendor-branch  ; then
			true
		else
			echo '***' failed test 102 ; exit 1
		fi

		# remove file4 on the vendor branch
		rm imported-file4

		if ${CVS} rm imported-file4  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 103 ; exit 1
		fi

		# commit
		if ${CVS} ci -m vendor-removed imported-file4 >>${LOGFILE}; then
			true
		else
			echo '***' failed test 104 ; exit 1
		fi

		# update to main line
		if ${CVS} update -A  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 105 ; exit 1
		fi

		# second import - file4 deliberately unchanged
		cd ../import-dir
		for i in 1 2 3 ; do
			echo rev 2 of file $i >> imported-file"$i"
		done

		if ${CVS} import -m second-import first-dir vendor-branch junk-2_0  ; then
			true
		else
			echo '***' failed test 106 ; exit 1
		fi
		cd ..

		# co
		if ${CVS} co first-dir  ; then
			true
		else
			echo '***' failed test 107 ; exit 1
		fi

		cd first-dir

		if [ -f imported-file1 ] ; then
			echo '***' failed test 108 ; exit 1
		else
			true
		fi

		for i in 2 3 ; do
			if [ -f imported-file"$i" ] ; then
				true
			else
				echo '***' failed test 109-$i ; exit 1
			fi
		done

		# check vendor branch for file4
		if ${CVS} update -rvendor-branch  ; then
			true
		else
			echo '***' failed test 110 ; exit 1
		fi

		if [ -f imported-file4 ] ; then
			true
		else
			echo '***' failed test 111 ; exit 1
		fi

		# update to main line
		if ${CVS} update -A  2>> ${LOGFILE}; then
			true
		else
			echo '***' failed test 112 ; exit 1
		fi

		cd ..

		if ${CVS} co -jjunk-1_0 -jjunk-2_0 first-dir  >>${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 113 ; exit 1
		fi

		cd first-dir

		if [ -f imported-file1 ] ; then
			echo '***' failed test 114 ; exit 1
		else
			true
		fi

		for i in 2 3 ; do
			if [ -f imported-file"$i" ] ; then
				true
			else
				echo '***' failed test 115-$i ; exit 1
			fi
		done

		if cat imported-file2 | grep '===='  >> ${LOGFILE}; then
			true
		else
			echo '***' failed test 116 ; exit 1
		fi
		cd .. ; rm -rf first-dir ${CVSROOT_FILENAME}/first-dir
		;;

	new) # look for stray "no longer pertinent" messages.
		rm -rf first-dir ${CVSROOT_FILENAME}/first-dir
		mkdir ${CVSROOT_FILENAME}/first-dir

		if ${CVS} co first-dir  ; then
			true
		else
			echo '***' failed test 117 ; exit 1
		fi

		cd first-dir
		touch a

		if ${CVS} add a  2>>${LOGFILE}; then
			true
		else
			echo '***' failed test 118 ; exit 1
		fi

		if ${CVS} ci -m added  >>${LOGFILE} 2>&1; then
			true
		else
			echo '***' failed test 119 ; exit 1
		fi

		rm a

		if ${CVS} rm a  2>>${LOGFILE}; then
			true
		else
			echo '***' failed test 120 ; exit 1
		fi

		if ${CVS} ci -m removed >>${LOGFILE} ; then
			true
		else
			echo '***' failed test 121 ; exit 1
		fi

		if ${CVS} update -A  2>&1 | grep longer ; then
			echo '***' failed test 122 ; exit 1
		else
			true
		fi

		if ${CVS} update -rHEAD 2>&1 | grep longer ; then
			echo '***' failed test 123 ; exit 1
		else
			true
		fi

		cd .. ; rm -rf first-dir ; rm -rf ${CVSROOT_FILENAME}/first-dir
		;;

	conflicts)
		rm -rf first-dir ${CVSROOT_FILENAME}/first-dir
		mkdir ${CVSROOT_FILENAME}/first-dir

		mkdir 1
		cd 1

		if ${CVS} co first-dir ; then
			echo 'PASS: test 124' >>${LOGFILE}
		else
			echo 'FAIL: test 124' | tee -a ${LOGFILE}
		fi

		cd first-dir
		touch a

		if ${CVS} add a 2>>${LOGFILE} ; then
			echo 'PASS: test 125' >>${LOGFILE}
		else
			echo 'FAIL: test 125' | tee -a ${LOGFILE}
		fi

		if ${CVS} ci -m added >>${LOGFILE} 2>&1; then
			echo 'PASS: test 126' >>${LOGFILE}
		else
			echo 'FAIL: test 126' | tee -a ${LOGFILE}
		fi

		cd ../..
		mkdir 2
		cd 2

		if ${CVS} co first-dir ; then
			echo 'PASS: test 127' >>${LOGFILE}
		else
			echo 'FAIL: test 127' | tee -a ${LOGFILE}
		fi
		cd first-dir
		if test -f a; then
			echo 'PASS: test 127a' >>${LOGFILE}
		else
			echo 'FAIL: test 127a' | tee -a ${LOGFILE}
		fi

		cd ../../1/first-dir
		echo add a line >>a
		if ${CVS} ci -m changed >>${LOGFILE} 2>&1; then
			echo 'PASS: test 128' >>${LOGFILE}
		else
			echo 'FAIL: test 128' | tee -a ${LOGFILE}
		fi

		cd ../../2/first-dir
		echo add a conflicting line >>a
		if ${CVS} ci -m changed >>${LOGFILE} 2>&1; then
			echo 'FAIL: test 129' | tee -a ${LOGFILE}
		else
			# Should be printing `out of date check failed'.
			echo 'PASS: test 129' >>${LOGFILE}
		fi

		if ${CVS} update 2>>${LOGFILE}; then
			# We should get a conflict, but that doesn't affect
			# exit status
			echo 'PASS: test 130' >>${LOGFILE}
		else
			echo 'FAIL: test 130' | tee -a ${LOGFILE}
		fi

		# Try to check in the file with the conflict markers in it.
		if ${CVS} ci -m try 2>>${LOGFILE}; then
			echo 'FAIL: test 131' | tee -a ${LOGFILE}
		else
			# Should tell us to resolve conflict first
			echo 'PASS: test 131' >>${LOGFILE}
		fi

		echo lame attempt at resolving it >>a
		# Try to check in the file with the conflict markers in it.
		if ${CVS} ci -m try >>${LOGFILE} 2>&1; then
			echo 'FAIL: test 132' | tee -a ${LOGFILE}
		else
			# Should tell us to resolve conflict first
			echo 'PASS: test 132' >>${LOGFILE}
		fi

		echo resolve conflict >a
		if ${CVS} ci -m resolved >>${LOGFILE} 2>&1; then
			echo 'PASS: test 133' >>${LOGFILE}
		else
			echo 'FAIL: test 133' | tee -a ${LOGFILE}
		fi

		# Now test that we can add a file in one working directory
		# and have an update in another get it.
		cd ../../1/first-dir
		echo abc >abc
		if ${testcvs} add abc >>${LOGFILE} 2>&1; then
			echo 'PASS: test 134' >>${LOGFILE}
		else
			echo 'FAIL: test 134' | tee -a ${LOGFILE}
		fi
		if ${testcvs} ci -m 'add abc' abc >>${LOGFILE} 2>&1; then
			echo 'PASS: test 135' >>${LOGFILE}
		else
			echo 'FAIL: test 135' | tee -a ${LOGFILE}
		fi
		cd ../../2
		if ${testcvs} -q update >>${LOGFILE}; then
			echo 'PASS: test 136' >>${LOGFILE}
		else
			echo 'FAIL: test 136' | tee -a ${LOGFILE}
		fi
		if test -f first-dir/abc; then
			echo 'PASS: test 137' >>${LOGFILE}
		else
			echo 'FAIL: test 137' | tee -a ${LOGFILE}
		fi

		# Now test something similar, but in which the parent directory
		# (not the directory in question) has the Entries.Static flag
		# set.
		cd ../1/first-dir
		mkdir subdir
		if ${testcvs} add subdir >>${LOGFILE}; then
			echo 'PASS: test 138' >>${LOGFILE}
		else
			echo 'FAIL: test 138' | tee -a ${LOGFILE}
		fi
		cd ../..
		mkdir 3
		cd 3
		if ${testcvs} -q co first-dir/abc first-dir/subdir \
		    >>${LOGFILE}; then
		  echo 'PASS: test 139' >>${LOGFILE}
		else
		  echo 'FAIL: test 139' | tee -a ${LOGFILE}
		fi
		cd ../1/first-dir/subdir
		echo sss >sss
		if ${testcvs} add sss >>${LOGFILE} 2>&1; then
		  echo 'PASS: test 140' >>${LOGFILE}
		else
		  echo 'FAIL: test 140' | tee -a ${LOGFILE}
		fi
		if ${testcvs} ci -m adding sss >>${LOGFILE} 2>&1; then
		  echo 'PASS: test 140' >>${LOGFILE}
		else
		  echo 'FAIL: test 140' | tee -a ${LOGFILE}
		fi
		cd ../../../3/first-dir
		if ${testcvs} -q update >>${LOGFILE}; then
		  echo 'PASS: test 141' >>${LOGFILE}
		else
		  echo 'FAIL: test 141' | tee -a ${LOGFILE}
		fi
		if test -f subdir/sss; then
		  echo 'PASS: test 142' >>${LOGFILE}
		else
		  echo 'FAIL: test 142' | tee -a ${LOGFILE}
		fi

		cd ../.. 
		rm -rf 1 2 3 ; rm -rf ${CVSROOT_FILENAME}/first-dir
		;;
	modules)
	  # The following line stolen from cvsinit.sh.  FIXME: create our
	  # repository via cvsinit.sh; that way we test it too.
	  (cd ${CVSROOT_FILENAME}/CVSROOT; ci -q -u -t/dev/null \
	    -m'initial checkin of modules' modules)

	  rm -rf first-dir ${CVSROOT_FILENAME}/first-dir
	  mkdir ${CVSROOT_FILENAME}/first-dir

	  mkdir 1
	  cd 1

	  if ${testcvs} -q co first-dir; then
	    echo 'PASS: test 143' >>${LOGFILE}
	  else
	    echo 'FAIL: test 143' | tee -a ${LOGFILE}
	  fi

	  cd first-dir
	  mkdir subdir
	  ${testcvs} add subdir >>${LOGFILE}
	  cd subdir

	  touch a

	  if ${testcvs} add a 2>>${LOGFILE} ; then
	    echo 'PASS: test 144' >>${LOGFILE}
	  else
	    echo 'FAIL: test 144' | tee -a ${LOGFILE}
	  fi

	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 145' >>${LOGFILE}
	  else
	    echo 'FAIL: test 145' | tee -a ${LOGFILE}
	  fi

	  cd ..
	  if ${testcvs} -q co CVSROOT >>${LOGFILE}; then
	    echo 'PASS: test 146' >>${LOGFILE}
	  else
	    echo 'FAIL: test 146' | tee -a ${LOGFILE}
	  fi

	  # Here we test that CVS can deal with CVSROOT (whose repository
	  # is at top level) in the same directory as subdir (whose repository
	  # is a subdirectory of first-dir).  TODO: Might want to check that
	  # files can actually get updated in this state.
	  if ${testcvs} -q update; then
	    echo 'PASS: test 147' >>${LOGFILE}
	  else
	    echo 'FAIL: test 147' | tee -a ${LOGFILE}
	  fi

	  echo realmodule first-dir/subdir a >>CVSROOT/modules
	  echo aliasmodule -a first-dir/subdir/a >>CVSROOT/modules
	  if ${testcvs} ci -m 'add modules' CVSROOT/modules \
	      >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 148' >>${LOGFILE}
	  else
	    echo 'FAIL: test 148' | tee -a ${LOGFILE}
	  fi
	  cd ..
	  if ${testcvs} co realmodule >>${LOGFILE}; then
	    echo 'PASS: test 149' >>${LOGFILE}
	  else
	    echo 'FAIL: test 149' | tee -a ${LOGFILE}
	  fi
	  if test -d realmodule && test -f realmodule/a; then
	    echo 'PASS: test 150' >>${LOGFILE}
	  else
	    echo 'FAIL: test 150' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} co aliasmodule >>${LOGFILE}; then
	    echo 'PASS: test 151' >>${LOGFILE}
	  else
	    echo 'FAIL: test 151' | tee -a ${LOGFILE}
	  fi
	  if test -d aliasmodule; then
	    echo 'FAIL: test 152' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 152' >>${LOGFILE}
	  fi
	  echo abc >>first-dir/subdir/a
	  if (${testcvs} -q co aliasmodule | tee test153.tmp) \
	      >>${LOGFILE}; then
	    echo 'PASS: test 153' >>${LOGFILE}
	  else
	    echo 'FAIL: test 153' | tee -a ${LOGFILE}
	  fi
	  echo 'M first-dir/subdir/a' >ans153.tmp
	  if cmp test153.tmp ans153.tmp; then
	    echo 'PASS: test 154' >>${LOGFILE}
	  else
	    echo 'FAIL: test 154' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} -q co realmodule; then
	    echo 'PASS: test 155' >>${LOGFILE}
	  else
	    echo 'FAIL: test 155' | tee -a ${LOGFILE}
	  fi
	  cd ..
	  rm -rf 1 ; rm -rf ${CVSROOT_FILENAME}/first-dir
	  ;;
	mflag)
	  for message in '' ' ' '	
           ' '    	  	test' ; do
	    # Set up
	    mkdir a-dir; cd a-dir
	    # Test handling of -m during import
	    echo testa >>test
	    if ${testcvs} import -m "$message" a-dir A A1 >>${LOGFILE} 2>&1;then
	      echo 'PASS: test 156' >>${LOGFILE}
	    else
	      echo 'FAIL: test 156' | tee -a ${LOGFILE}
	    fi
	    # Must import twice since the first time uses inline code that
	    # avoids RCS call.
	    echo testb >>test
	    if ${testcvs} import -m "$message" a-dir A A2 >>${LOGFILE} 2>&1;then
	      echo 'PASS: test 157' >>${LOGFILE}
	    else
	      echo 'FAIL: test 157' | tee -a ${LOGFILE}
	    fi
	    # Test handling of -m during ci
	    cd ..; rm -rf a-dir;
	    if ${testcvs} co a-dir >>${LOGFILE} 2>&1; then
	      echo 'PASS: test 158' >>${LOGFILE}
	    else
	      echo 'FAIL: test 158' | tee -a ${LOGFILE}
	    fi
	    cd a-dir
	    echo testc >>test
	    if ${testcvs} ci -m "$message" >>${LOGFILE} 2>&1; then
	      echo 'PASS: test 159' >>${LOGFILE}
	    else
	      echo 'FAIL: test 159' | tee -a ${LOGFILE}
	    fi
	    # Test handling of -m during rm/ci
	    rm test;
	    if ${testcvs} rm test >>${LOGFILE} 2>&1; then
	      echo 'PASS: test 160' >>${LOGFILE}
	    else
	      echo 'FAIL: test 160' | tee -a ${LOGFILE}
	    fi
	    if ${testcvs} ci -m "$message" >>${LOGFILE} 2>&1; then
	      echo 'PASS: test 161' >>${LOGFILE}
	    else
	      echo 'FAIL: test 161' | tee -a ${LOGFILE}
	    fi
	    # Clean up
	    cd ..; rm -rf a-dir ${CVSROOT_FILENAME}/a-dir
	  done
	  ;;
	errmsg1)
	  mkdir ${CVSROOT_FILENAME}/1dir
	  mkdir 1
	  cd 1
	  if ${testcvs} -q co 1dir; then
	    echo 'PASS: test 162' >>${LOGFILE}
	  else
	    echo 'FAIL: test 162' | tee -a ${LOGFILE}
	  fi
	  cd 1dir
	  touch foo
	  if ${testcvs} add foo 2>>${LOGFILE}; then
	    echo 'PASS: test 163' >>${LOGFILE}
	  else
	    echo 'FAIL: test 163' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 164' >>${LOGFILE}
	  else
	    echo 'FAIL: test 164' | tee -a ${LOGFILE}
	  fi
	  cd ../..
	  mkdir 2
	  cd 2
	  if ${testcvs} -q co 1dir >>${LOGFILE}; then
	    echo 'PASS: test 165' >>${LOGFILE}
	  else
	    echo 'FAIL: test 165' | tee -a ${LOGFILE}
	  fi
	  chmod a-w 1dir
	  cd ../1/1dir
	  rm foo; 
	  if ${testcvs} rm foo >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 166' >>${LOGFILE}
	  else
	    echo 'FAIL: test 166' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} ci -m removed >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 167' >>${LOGFILE}
	  else
	    echo 'FAIL: test 167' | tee -a ${LOGFILE}
	  fi
	  cd ../../2/1dir
	  ${testcvs} -q update 2>../tst167.err
	  cat <<EOF >../tst167.ans
cvs server: warning: foo is not (any longer) pertinent
cvs update: unable to remove ./foo: Permission denied
EOF
	  if cmp ../tst167.ans ../tst167.err >/dev/null ||
	  ( echo 'cvs [update aborted]: cannot rename file foo to CVS/,,foo: Permission denied' | cmp - ../tst167.err >/dev/null )
	  then
	    echo 'PASS: test 168' >>${LOGFILE}
	  else
	    echo 'FAIL: test 168' | tee -a ${LOGFILE}
	  fi

	  cd ..
	  chmod u+w 1dir
	  cd ..
	  rm -rf 1 2 ${CVSROOT_FILENAME}/1dir
	  ;;

	*) echo $what is not the name of a test -- ignored ;;
	esac
done

echo Ok.

# TODO:
# * Test `cvs admin'.
# * Test `cvs update -d foo' (where foo does not exist).
# * Test `cvs update foo bar' (where foo and bar are both from the same
#   repository).  Suppose one is a branch--make sure that both directories
#   get updated with the respective correct thing.
# * Zero length files (check in, check out).
# * `cvs update ../foo'.  Also ../../foo ./../foo foo/../../bar /foo/bar
#   foo/.././../bar foo/../bar etc.
# * Test all flags in modules file.
#   Test that ciprog gets run both on checkin in that directory, or a
#     higher-level checkin which recurses into it.
# * Test that $ followed by "Header" followed by $ gets expanded on checkin.
# * Test operations on a directory that contains other directories but has 
#   no files of its own.
# * -t global option
# * cvs rm followed by cvs add or vice versa (with no checkin in between).
# * cvs rm twice (should be a nice error message).
# * -P option to checkout--(a) refrains from checking out new empty dirs,
#   (b) prunes empty dirs already there.
# * Test that cvs -d `hostname`:/tmp/cvs-sanity/non/existent co foo
#   gives an appropriate error (e.g. 
#     Cannot access /tmp/cvs-sanity/non-existent/CVSROOT
#     No such file or directory).
# End of TODO list.

# Remove the test directory, but first change out of it.
cd /tmp
rm -rf ${TESTDIR}

# end of sanity.sh
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d1 2
a2 5
#! /bin/sh
:
#	sanity.sh -- a growing sanity test for cvs.
#
#ident	"$CVSid$"
d8 1
a8 1
# usage: sanity.sh [-r] @@var{cvs-to-test} @@var{tests-to-run}
a9 2
# @@var{tests-to-run} are the names of the tests to run; if omitted run all
# tests.
a12 3
# required to make this script work properly.
unset CVSREAD

d18 4
a21 1
echo 'This test should produce no other output than this line, and a final "OK".'
d24 2
a25 2
	shift
	remote=yes
d27 1
a27 1
	remote=no
d30 1
a30 10
# Use full path for CVS executable, so that CVS_SERVER gets set properly
# for remote.
case $1 in
/*)
	testcvs=$1
	;;
*)
	testcvs=`pwd`/$1
	;;
esac
d32 6
a37 5
shift

# Use full path for mkmodules, so that the right one will be invoked
#
testmkmodules=`pwd`/mkmodules
d39 1
a39 2
# FIXME: try things (what things? checkins?) without -m.
#
d43 1
a43 3
# and then they've obviously got to do something with the output....
#
CVS="${testcvs} -Q -f"
d46 1
a47 165
# Save the previous log in case the person running the tests decides
# they want to look at it.  The extension ".plog" is chosen for consistency
# with dejagnu.
if test -f check.log; then
	mv check.log check.plog
fi

# That we should have to do this is total bogosity, but GNU expr
# version 1.9.4 uses the emacs definition of "$" instead of the unix
# (e.g. SunOS 4.1.3 expr) one.  IMHO, this is a GNU expr bug, but I
# don't have a copy of POSIX.2 handy to check.
ENDANCHOR="$"
if expr 'abc
def' : 'abc$' >/dev/null; then
  ENDANCHOR='\'\'
fi

# Work around another GNU expr (version 1.10) bug/incompatibility.
# "." doesn't appear to match a newline (it does with SunOS 4.1.3 expr).
# Note that the workaround is not a complete equivalent of .* because
# the first parenthesized expression in the regexp must match something
# in order for expr to return a successful exit status.
DOTSTAR='.*'
if expr 'abc
def' : "a${DOTSTAR}f" >/dev/null; then
  : good, it works
else
  DOTSTAR='\(.\|
\)*'
fi

# Cause NextStep 3.3 users to lose in a more graceful fashion.
if expr 'abc
def' : 'abc
def' >/dev/null; then
  : good, it works
else
  echo 'Running these tests requires an "expr" program that can handle'
  echo 'multi-line patterns.  Make sure that such an expr (GNU, or many but'
  echo 'not all vendor-supplied versions) is in your path.'
  exit 1
fi

pass ()
{
  echo "PASS: $1" >>${LOGFILE}
}

fail ()
{
  echo "FAIL: $1" | tee -a ${LOGFILE}
  # This way the tester can go and see what remnants were left
  exit 1
}

# Usage:
#  dotest TESTNAME COMMAND OUTPUT [OUTPUT2]
# TESTNAME is the name used in the log to identify the test.
# COMMAND is the command to run; for the test to pass, it exits with 
# exitstatus zero.
# OUTPUT is a regexp which is compared against the output (stdout and
# stderr combined) from the test.  It is anchored to the start and end
# of the output, so should start or end with ".*" if that is what is desired.
# Trailing newlines are stripped from the command's actual output before
# matching against OUTPUT.
# If OUTPUT2 is specified and the output matches it, then it is also
# a pass (partial workaround for the fact that some versions of expr
# lack \|).
dotest ()
{
  if $2 >${TESTDIR}/dotest.tmp 2>&1; then
    : so far so good
  else
    status=$?
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    echo "exit status was $status" >>${LOGFILE}
    fail "$1"
  fi
  # expr can't distinguish between "zero characters matched" and "no match",
  # so special-case it.
  if test -z "$3"; then
    if test -s ${TESTDIR}/dotest.tmp; then
      echo "** expected: " >>${LOGFILE}
      echo "$3" >>${LOGFILE}
      echo "** got: " >>${LOGFILE}
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      fail "$1"
    else
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      pass "$1"
    fi
  else
    if expr "`cat ${TESTDIR}/dotest.tmp`" : \
	"$3"${ENDANCHOR} >/dev/null; then
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      pass "$1"
    else
      if test x"$4" != x; then
	if expr "`cat ${TESTDIR}/dotest.tmp`" : \
	    "$4"${ENDANCHOR} >/dev/null; then
	  cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
	  pass "$1"
	else
	  echo "** expected: " >>${LOGFILE}
	  echo "$3" >>${LOGFILE}
	  echo "** or: " >>${LOGFILE}
	  echo "$4" >>${LOGFILE}
	  echo "** got: " >>${LOGFILE}
	  cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
	  fail "$1"
	fi
      else
	echo "** expected: " >>${LOGFILE}
	echo "$3" >>${LOGFILE}
	echo "** got: " >>${LOGFILE}
	cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
	fail "$1"
      fi
    fi
  fi
}

# Like dotest except exitstatus should be nonzero.  Probably their
# implementations could be unified (if I were a good enough sh script
# writer to get the quoting right).
dotest_fail ()
{
  if $2 >${TESTDIR}/dotest.tmp 2>&1; then
    status=$?
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    echo "exit status was $status" >>${LOGFILE}
    fail "$1"
  else
    : so far so good
  fi
  # expr can't distinguish between "zero characters matched" and "no match",
  # so special-case it.
  if test -z "$3"; then
    if test -s ${TESTDIR}/dotest.tmp; then
      echo "** expected: " >>${LOGFILE}
      echo "$3" >>${LOGFILE}
      echo "** got: " >>${LOGFILE}
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      fail "$1"
    else
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      pass "$1"
    fi
  else
    if expr "`cat ${TESTDIR}/dotest.tmp`" : \
	${STARTANCHOR}"$3"${ENDANCHOR} >/dev/null; then
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      pass "$1"
    else
      echo "** expected: " >>${LOGFILE}
      echo "$3" >>${LOGFILE}
      echo "** got: " >>${LOGFILE}
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      fail "$1"
    fi
  fi
}

# clean any old remnants
rm -rf ${TESTDIR}
d51 1
a51 13
# Remaining arguments are the names of tests to run.
#
# FIXME: not all combinations are possible; rtags depends on files set
# up by basic2, for example.  This should be changed.  The goal is
# that tests can be run in manageably-sized chunks, so that one can
# quickly get a result from a cvs or testsuite change, and to
# facilitate understanding the tests.

if test x"$*" = x; then
	tests="basica basic0 basic1 basic2 rtags death import new conflicts modules mflag errmsg1 devcom ignore binfiles"
else
	tests="$*"
fi
d55 1
a55 2
	echo "FAIL: test 1" | tee -a ${LOGFILE}
	exit 1
d57 1
a57 1
	echo "PASS: test 1" >>${LOGFILE}
d63 1
a63 2
	echo "FAIL: test 2" | tee -a ${LOGFILE}
	exit 1
d65 1
a65 1
	echo "PASS: test 2" >>${LOGFILE}
d71 1
a71 2
	echo "FAIL: test 3" | tee -a ${LOGFILE}
	exit 1
d73 1
a73 1
	echo "PASS: test 3" >>${LOGFILE}
a80 7
# set up a minimal modules file...
echo "CVSROOT		-i ${testmkmodules} CVSROOT" > cvsroot/CVSROOT/modules
# The following line stolen from cvsinit.sh.  FIXME: create our
# repository via cvsinit.sh; that way we test it too.
(cd cvsroot/CVSROOT; ci -q -u -t/dev/null \
  -m'initial checkin of modules' modules)

d82 1
d85 1
a85 1
	echo "PASS: test 4" >>${LOGFILE}
d87 1
a87 2
	echo "FAIL: test 4" | tee -a ${LOGFILE}
	exit 1
d90 1
a90 54
if echo "yes" | ${CVS} -d `pwd`/../cvsroot release -d CVSROOT ; then
	echo "PASS: test 4.5" >>${LOGFILE}
else
	echo "FAIL: test 4.5" | tee -a ${LOGFILE}
	exit 1
fi
# this had better be empty
cd ..; rmdir tmp
dotest_fail 4.75 "test -d tmp" ''

# a simple function to compare directory contents
#
# BTW, I don't care any more -- if you don't have a /bin/sh that handles
# shell functions, well get one.
#
# Returns: ISDIFF := true|false
#
directory_cmp ()
{
	OLDPWD=`pwd`
	DIR_1=$1
	DIR_2=$2
	ISDIFF=false

	cd $DIR_1
	find . -print | fgrep -v /CVS | sort > /tmp/dc$$d1

	# go back where we were to avoid symlink hell...
	cd $OLDPWD
	cd $DIR_2
	find . -print | fgrep -v /CVS | sort > /tmp/dc$$d2

	if diff /tmp/dc$$d1 /tmp/dc$$d2 >/dev/null 2>&1
	then
		:
	else
		ISDIFF=true
		return
	fi
	cd $OLDPWD
	while read a
	do
		if [ -f $DIR_1/"$a" ] ; then
			cmp -s $DIR_1/"$a" $DIR_2/"$a"
			if [ $? -ne 0 ] ; then
				ISDIFF=true
			fi
		fi
	done < /tmp/dc$$d1
### FIXME:
###	rm -f /tmp/dc$$*
}

# so much for the setup.  Let's try something harder.
d94 2
a95 2
CVSROOT_DIRNAME=${TESTDIR}/cvsroot
CVSROOT=${CVSROOT_DIRNAME} ; export CVSROOT
d97 12
a108 5
	CVSROOT=`hostname`:${CVSROOT_DIRNAME} ; export CVSROOT
	# Use rsh so we can test it without having to muck with inetd or anything 
	# like that.  Also needed to get CVS_SERVER to work.
	CVS_CLIENT_PORT=-1; export CVS_CLIENT_PORT
	CVS_SERVER=${testcvs}; export CVS_SERVER
d111 2
d114 1
a114 1
touch ${CVSROOT_DIRNAME}/CVSROOT/history
a118 44
	basica)
	  # Similar in spirit to some of the basic0, basic1, and basic2
	  # tests, but hopefully a lot faster.  Also tests operating on
	  # files two directories down *without* operating on the parent dirs.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest basica-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  mkdir sdir
	  dotest basica-2 "${testcvs} add sdir" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir added to the repository'
	  cd sdir
	  mkdir ssdir
	  dotest basica-3 "${testcvs} add ssdir" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir added to the repository'
	  cd ssdir
	  echo ssfile >ssfile
	  dotest basica-4 "${testcvs} add ssfile" \
'cvs [a-z]*: scheduling file `ssfile'\'' for addition
cvs [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  cd ../..
	  dotest basica-5 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v
done
Checking in sdir/ssdir/ssfile;
/tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
initial revision: 1.1
done'
	  dotest basica-6 "${testcvs} -q update" ''
	  echo "ssfile line 2" >>sdir/ssdir/ssfile
	  dotest basica-7 "${testcvs} -q ci -m modify-it" \
'Checking in sdir/ssdir/ssfile;
/tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 1.2; previous revision: 1.1
done'
	  dotest_fail basica-nonexist "${testcvs} -q ci nonexist" \
'cvs [a-z]*: nothing known about `nonexist'\''
cvs \[[a-z]* aborted\]: correct above errors first!'
	  dotest basica-8 "${testcvs} -q update" ''
	  cd ..

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r first-dir
	  ;;

d126 1
a126 1
			mkdir ${CVSROOT_DIRNAME}/first-dir
d132 1
a132 5
		  if [ -r first-dir/CVS/Entries ] ; then
		    echo "PASS: test 6" >>${LOGFILE}
		  else
		    echo "FAIL: test 6" | tee -a ${LOGFILE}; exit 1
		  fi
d188 1
a188 1
		rm -rf ${CVSROOT_DIRNAME}/first-dir
d190 1
a190 1
		mkdir ${CVSROOT_DIRNAME}/first-dir
d235 1
a235 1
		# FIXME: this one doesn't work yet for added files.
d270 1
a270 1
		# FIXME: doesn't work right for added files.
d286 1
a286 1
					  echo "PASS: test 24-${do}-$j" >>${LOGFILE}
d288 1
a288 1
					  echo "FAIL: test 24-${do}-$j" | tee -a ${LOGFILE} ; exit 1
d292 1
a292 1
					  echo "PASS: test 25-${do}-$j" >>${LOGFILE}
d296 1
a296 1
					    echo "PASS: test 25-${do}-$j" >>${LOGFILE}
d298 1
a298 2
					    echo "FAIL: test 25-${do}-$j" | tee -a ${LOGFILE}
					    # FIXME; exit 1
d303 1
a303 1
					    echo "PASS: test 26-${do}-$j" >>${LOGFILE}
d305 1
a305 2
					    echo "FAIL: test 26-${do}-$j" | tee -a ${LOGFILE}
					    # FIXME; exit 1
d311 1
a311 1
					  echo "PASS: test 27-${do}-$j" >>${LOGFILE}
d313 1
a313 1
					  echo "FAIL: test 27-${do}-$j" | tee -a ${LOGFILE} ; exit 1
d324 1
a324 1
		  echo "PASS: test 28" >>${LOGFILE}
d326 1
a326 1
		  echo "FAIL: test 28" | tee -a ${LOGFILE} ; exit 1
a328 2
		rm -rf ${CVSROOT_DIRNAME}/first-dir
		rm -rf first-dir
d331 1
a331 5
	basic2)
		# second dive - add bunch o' files in bunch o' added
		#  directories
		mkdir ${CVSROOT_DIRNAME}/first-dir
		dotest basic2-1 "${testcvs} -q co first-dir" ''
d336 1
a336 1
				  echo "PASS: test 29-$i" >>${LOGFILE}
d338 1
a338 1
				  echo "FAIL: test 29-$i" | tee -a ${LOGFILE} ; exit 1
d349 1
a349 1
				echo "PASS: test 30-$i-$j" >>${LOGFILE}
d351 1
a351 1
				echo "FAIL: test 30-$i-$j" | tee -a ${LOGFILE} ; exit 1
d356 1
a356 1
			echo "PASS: test 31" >>${LOGFILE}
d358 1
a358 1
			echo "FAIL: test 31" | tee -a ${LOGFILE} ; exit 1
d363 1
a363 1
			echo "PASS: test 32" >>${LOGFILE}
d365 1
a365 1
			echo "FAIL: test 32" | tee -a ${LOGFILE} # ; exit 1
d369 1
a369 1
			echo "PASS: test 33" >>${LOGFILE}
d371 1
a371 1
			echo "FAIL: test 33" | tee -a ${LOGFILE} ; exit 1
d375 1
a375 1
#			echo "PASS: test 34" >>${LOGFILE}
d377 1
a377 1
#			echo "FAIL: test 34" | tee -a ${LOGFILE} # ; exit 1
d381 1
a381 1
			echo "PASS: test 35" >>${LOGFILE}
d383 1
a383 1
			echo "FAIL: test 35" | tee -a ${LOGFILE} ; exit 1
d387 1
a387 1
			echo "PASS: test 36" >>${LOGFILE}
d389 1
a389 1
			echo "FAIL: test 36" | tee -a ${LOGFILE} ; exit 1
d391 1
d393 1
a393 3
		# third dive - in bunch o' directories, add bunch o' files,
		# delete some, change some.

d406 1
a406 1
				echo "PASS: test 37-$i" >>${LOGFILE}
d408 1
a408 1
				echo "FAIL: test 37-$i" | tee -a ${LOGFILE} ; exit 1
d417 1
a417 1
				echo "PASS: test 38-$i" >>${LOGFILE}
d419 1
a419 1
				echo "FAIL: test 38-$i" | tee -a ${LOGFILE} ; exit 1
d424 1
a424 1
			echo "PASS: test 39" >>${LOGFILE}
d426 1
a426 1
			echo "FAIL: test 39" | tee -a ${LOGFILE} ; exit 1
d431 1
a431 1
			echo "PASS: test 40" >>${LOGFILE}
d433 1
a433 1
			echo "FAIL: test 40" | tee -a ${LOGFILE} # ; exit 1
d437 1
a437 1
			echo "PASS: test 41" >>${LOGFILE}
d439 1
a439 1
			echo "FAIL: test 41" | tee -a ${LOGFILE} ; exit 1
d443 1
a443 1
#			echo "PASS: test 42" >>${LOGFILE}
d445 1
a445 1
#			echo "FAIL: test 42" | tee -a ${LOGFILE} # ; exit 1
d449 1
a449 1
			echo "PASS: test 43" >>${LOGFILE}
d451 1
a451 1
			echo "FAIL: test 43" | tee -a ${LOGFILE} ; exit 1
a452 1
		dotest 43.5 "${testcvs} -q update first-dir" ''
d455 1
a455 1
			echo "PASS: test 44" >>${LOGFILE}
d457 1
a457 1
			echo "FAIL: test 44" | tee -a ${LOGFILE} ; exit 1
d460 6
a465 5
		if echo "yes" | ${CVS} release -d first-dir  ; then
			echo "PASS: test 45" >>${LOGFILE}
		else
			echo "FAIL: test 45" | tee -a ${LOGFILE} ; exit 1
		fi
d468 1
a468 6
		if [ -d first-dir ] ; then
			echo "FAIL: test 45.5" | tee -a ${LOGFILE} ; exit 1
		else
			echo "PASS: test 45.5" >>${LOGFILE}
		fi

d474 1
a474 1
			echo "PASS: test 46" >>${LOGFILE}
d476 1
a476 1
			echo "FAIL: test 46" | tee -a ${LOGFILE} ; exit 1
d481 1
a481 1
			echo "PASS: test 47" >>${LOGFILE}
d483 1
a483 1
			echo "FAIL: test 47" | tee -a ${LOGFILE} ; exit 1
d488 1
a488 1
			echo "PASS: test 48" >>${LOGFILE}
d490 1
a490 1
			echo "FAIL: test 48" | tee -a ${LOGFILE} ; exit 1
d495 1
a495 1
			echo "PASS: test 49" >>${LOGFILE}
d497 1
a497 1
			echo "FAIL: test 49" | tee -a ${LOGFILE} ; exit 1
d503 1
a503 1
			echo "PASS: test 50" >>${LOGFILE}
d505 1
a505 1
			echo "FAIL: test 50" | tee -a ${LOGFILE} ; exit 1
d510 1
a510 1
			echo "PASS: test 51" >>${LOGFILE}
d512 1
a512 1
			echo "FAIL: test 51" | tee -a ${LOGFILE} ; exit 1
d515 2
a516 4
		directory_cmp 1dir first-dir

		if $ISDIFF ; then
			echo "FAIL: test 52" | tee -a ${LOGFILE} ; exit 1
d518 1
a518 1
			echo "PASS: test 52" >>${LOGFILE}
d522 9
a530 6
		# checkout by revision vs export by rtagged-by-revision and compare.
		if ${CVS} export -rrtagged-by-revision -d export-dir first-dir  ; then
			echo "PASS: test 53" >>${LOGFILE}
		else
			echo "FAIL: test 53" | tee -a ${LOGFILE} ; exit 1
		fi
d532 2
a533 2
		if ${CVS} co -r1.1 first-dir  ; then
			echo "PASS: test 54" >>${LOGFILE}
d535 1
a535 1
			echo "FAIL: test 54" | tee -a ${LOGFILE} ; exit 1
d537 2
d543 2
a544 4
		directory_cmp first-dir export-dir

		if $ISDIFF ; then 
			echo "FAIL: test 55" | tee -a ${LOGFILE} ; exit 1
d546 1
a546 1
			echo "PASS: test 55" >>${LOGFILE}
d550 1
a550 1
		cd export-dir
d552 1
a552 1
			echo "PASS: test 56" >>${LOGFILE}
d554 1
a554 1
			echo "FAIL: test 56" | tee -a ${LOGFILE} ; exit 1
d559 1
a559 1
			echo "PASS: test 57" >>${LOGFILE}
d561 1
a561 1
			echo "FAIL: test 57" | tee -a ${LOGFILE} ; exit 1
d564 2
a565 4
		directory_cmp first-dir second-dir

		if $ISDIFF ; then
			echo "FAIL: test 58" | tee -a ${LOGFILE} ; exit 1
d567 1
a567 1
			echo "PASS: test 58" >>${LOGFILE}
d570 1
a570 2
		rm -rf second-dir
		rm -rf export-dir first-dir
d577 1
a577 1
			echo "PASS: test 59" >>${LOGFILE}
d579 1
a579 1
			echo "FAIL: test 59" | tee -a ${LOGFILE} ; exit 1
d585 1
a585 1
			echo "PASS: test 60a" >>${LOGFILE}
d587 1
a587 1
			echo "FAIL: test 60a" | tee -a ${LOGFILE} ; exit 1
d590 1
a590 1
			echo "PASS: test 60b" >>${LOGFILE}
d592 1
a592 1
			echo "FAIL: test 60b" | tee -a ${LOGFILE} ; exit 1
d595 2
a596 5
		cd ..
		mv first-dir 1dir
		mv first-dir.cpy first-dir
		cd first-dir

d598 1
a598 1
			echo "PASS: test 61" >>${LOGFILE}
d600 1
a600 1
			echo "FAIL: test 61" | tee -a ${LOGFILE} ; exit 1
d604 1
a604 1
			echo "PASS: test 62" >>${LOGFILE}
d606 1
a606 1
			echo "FAIL: test 62" | tee -a ${LOGFILE} ; exit 1
d611 3
a613 6
		#### FIXME: is this expected to work???  Need to investigate
		#### and fix or remove the test.
#		directory_cmp 1dir first-dir
#
#		if $ISDIFF ; then
#			echo "FAIL: test 63" | tee -a ${LOGFILE} # ; exit 1
d615 1
a615 1
#			echo "PASS: test 63" >>${LOGFILE}
d620 1
a620 1
			echo "PASS: test 64" >>${LOGFILE}
d622 1
a622 1
			echo "FAIL: test 64" | tee -a ${LOGFILE} ; exit 1
a623 2
		rm -rf ${CVSROOT_DIRNAME}/first-dir
		rm -rf ${CVSROOT_DIRNAME}/second-dir
d627 2
a628 1
		mkdir  ${CVSROOT_DIRNAME}/first-dir
d630 1
a630 1
			echo "PASS: test 65" >>${LOGFILE}
d632 1
a632 1
			echo "FAIL: test 65" | tee -a ${LOGFILE} ; exit 1
a636 30
		# Create a directory with only dead files, to make sure CVS
		# doesn't get confused by it.
		mkdir subdir
		dotest 65a0 "${testcvs} add subdir" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/subdir added to the repository'
		cd subdir
		echo file in subdir >sfile
		dotest 65a1 "${testcvs} add sfile" \
'cvs [a-z]*: scheduling file `sfile'\'' for addition
cvs [a-z]*: use '\''cvs commit'\'' to add this file permanently'
		dotest 65a2 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/subdir/sfile,v
done
Checking in sfile;
/tmp/cvs-sanity/cvsroot/first-dir/subdir/sfile,v  <--  sfile
initial revision: 1.1
done'
		rm sfile
		dotest 65a3 "${testcvs} rm sfile" \
'cvs [a-z]*: scheduling `sfile'\'' for removal
cvs [a-z]*: use '\''cvs commit'\'' to remove this file permanently'
		dotest 65a4 "${testcvs} -q ci -m remove-it" \
'Removing sfile;
/tmp/cvs-sanity/cvsroot/first-dir/subdir/sfile,v  <--  sfile
new revision: delete; previous revision: 1.1
done'
		cd ..
		dotest 65a5 "${testcvs} -q update -P" ''
		dotest_fail 65a6 "test -d subdir" ''

d640 1
a640 1
			echo "PASS: test 66" >>${LOGFILE}
d642 1
a642 1
			echo "FAIL: test 66" | tee -a ${LOGFILE} ; exit 1
d647 1
a647 1
			echo "PASS: test 67" >>${LOGFILE}
d649 1
a649 1
			echo "FAIL: test 67" | tee -a ${LOGFILE} ; exit 1
d655 1
a655 1
			echo "PASS: test 68" >>${LOGFILE}
d657 1
a657 1
			echo "FAIL: test 68" | tee -a ${LOGFILE} ; exit 1
d662 1
a662 1
			echo "PASS: test 69" >>${LOGFILE}
d664 1
a664 1
			echo "FAIL: test 69" | tee -a ${LOGFILE} ; exit 1
d670 1
a670 1
			echo "PASS: test 70" >>${LOGFILE}
d672 1
a672 1
			echo "FAIL: test 70" | tee -a ${LOGFILE} ; exit 1
d677 1
a677 1
			echo "PASS: test 71" >>${LOGFILE}
d679 1
a679 1
			echo "FAIL: test 71" | tee -a ${LOGFILE} ; exit 1
d684 1
a684 1
			echo "PASS: test 72" >>${LOGFILE}
d686 1
a686 1
			echo "FAIL: test 72" | tee -a ${LOGFILE} ; exit 1
a688 21
		# file4 will be dead at the time of branching and stay dead.
		echo file4 > file4
		dotest death-file4-add "${testcvs} add file4" \
'cvs [a-z]*: scheduling file `file4'\'' for addition
cvs [a-z]*: use '\''cvs commit'\'' to add this file permanently'
		dotest death-file4-ciadd "${testcvs} -q ci -m add file4" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
initial revision: 1.1
done'
		rm file4
		dotest death-file4-rm "${testcvs} remove file4" \
'cvs [a-z]*: scheduling `file4'\'' for removal
cvs [a-z]*: use '\''cvs commit'\'' to remove this file permanently'
		dotest death-file4-cirm "${testcvs} -q ci -m remove file4" \
'Removing file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: delete; previous revision: 1.1
done'
d692 1
a692 1
			echo "PASS: test 73" >>${LOGFILE}
d694 1
a694 1
			echo "FAIL: test 73" | tee -a ${LOGFILE} ; exit 1
d699 1
a699 1
			echo "PASS: test 74" >>${LOGFILE}
d701 1
a701 1
			echo "FAIL: test 74" | tee -a ${LOGFILE} ; exit 1
a703 2
		dotest_fail death-file4-3 "test -f file4" ''

d707 1
a707 1
			echo "PASS: test 75" >>${LOGFILE}
d709 1
a709 1
			echo "FAIL: test 75" | tee -a ${LOGFILE} ; exit 1
d714 1
a714 1
			echo "PASS: test 76" >>${LOGFILE}
d716 1
a716 1
			echo "FAIL: test 76" | tee -a ${LOGFILE} ; exit 1
d722 1
a722 1
			echo "PASS: test 77" >>${LOGFILE}
d724 1
a724 1
			echo "FAIL: test 77" | tee -a ${LOGFILE} ; exit 1
d729 1
a729 1
			echo "PASS: test 78" >>${LOGFILE}
d731 1
a731 1
			echo "FAIL: test 78" | tee -a ${LOGFILE} ; exit 1
d737 1
a737 1
			echo "PASS: test 79" >>${LOGFILE}
d739 1
a739 1
			echo "FAIL: test 79" | tee -a ${LOGFILE} ; exit 1
d744 1
a744 1
			echo "PASS: test 80" >>${LOGFILE}
d746 1
a746 1
			echo "FAIL: test 80" | tee -a ${LOGFILE} ; exit 1
d754 1
a754 1
			echo "PASS: test 81" >>${LOGFILE}
d756 1
a756 1
			echo "FAIL: test 81" | tee -a ${LOGFILE} ; exit 1
d762 1
a762 1
			echo "PASS: test 82" >>${LOGFILE}
d764 1
a764 1
			echo "FAIL: test 82" | tee -a ${LOGFILE} ; exit 1
d769 1
a769 1
			echo "PASS: test 83" >>${LOGFILE}
d771 1
a771 1
			echo "FAIL: test 83" | tee -a ${LOGFILE} ; exit 1
d776 1
a776 1
			echo "PASS: test 84" >>${LOGFILE}
d778 1
a778 1
			echo "FAIL: test 84" | tee -a ${LOGFILE} ; exit 1
a780 2
		dotest_fail death-file4-4 "test -f file4" ''

d782 1
a782 1
			echo "FAIL: test 85" | tee -a ${LOGFILE} ; exit 1
d784 1
a784 1
			echo "PASS: test 85" >>${LOGFILE}
d789 1
a789 1
			echo "PASS: test 86" >>${LOGFILE}
d791 1
a791 1
			echo "FAIL: test 86" | tee -a ${LOGFILE} ; exit 1
a793 2
		dotest_fail death-file4-5 "test -f file4" ''

d795 1
a795 8
			echo "PASS: test 87" >>${LOGFILE}
		else
			echo "FAIL: test 87" | tee -a ${LOGFILE} ; exit 1
		fi

		# Make sure that we joined the correct change to file1
		if echo line2 from branch1 | cmp - file1 >/dev/null; then
			echo 'PASS: test 87a' >>${LOGFILE}
d797 1
a797 2
			echo 'FAIL: test 87a' | tee -a ${LOGFILE}
			exit 1
d802 1
a802 1
			echo "PASS: test 88" >>${LOGFILE}
d804 1
a804 1
			echo "FAIL: test 88" | tee -a ${LOGFILE} ; exit 1
d809 1
a809 1
			echo "PASS: test 89" >>${LOGFILE}
d811 1
a811 1
			echo "FAIL: test 89" | tee -a ${LOGFILE} ; exit 1
d817 1
a817 1
			echo "PASS: test 90" >>${LOGFILE}
d819 1
a819 1
			echo "FAIL: test 90" | tee -a ${LOGFILE} ; exit 1
d824 1
a824 1
			echo "PASS: test 91" >>${LOGFILE}
d826 1
a826 1
			echo "FAIL: test 91" | tee -a ${LOGFILE} ; exit 1
d830 1
a830 1
			echo "FAIL: test 92" | tee -a ${LOGFILE} ; exit 1
d832 1
a832 16
			echo "PASS: test 92" >>${LOGFILE}
		fi

		# typo; try to get to the branch and fail
		dotest_fail 92.1a "${testcvs} update -r brnach1" \
		  'cvs \[[a-z]* aborted\]: no such tag brnach1'
		# Make sure we are still on the trunk
		if test -f file1 ; then
			echo "FAIL: 92.1b" | tee -a ${LOGFILE} ; exit 1
		else
			echo "PASS: 92.1b" >>${LOGFILE}
		fi
		if test -f file2 ; then
			echo "PASS: 92.1c" >>${LOGFILE}
		else
			echo "FAIL: 92.1c" | tee -a ${LOGFILE} ; exit 1
d837 1
a837 1
			echo "PASS: test 93" >>${LOGFILE}
d839 1
a839 1
			echo "FAIL: test 93" | tee -a ${LOGFILE} ; exit 1
a841 2
		dotest_fail death-file4-6 "test -f file4" ''

d843 1
a843 1
			echo "PASS: test 94" >>${LOGFILE}
d845 1
a845 1
			echo "FAIL: test 94" | tee -a ${LOGFILE} ; exit 1
d850 1
a850 1
			echo "PASS: test 95" >>${LOGFILE}
d852 1
a852 1
			echo "FAIL: test 95" | tee -a ${LOGFILE} ; exit 1
d855 1
a855 3
		dotest_fail death-file4-7 "test -f file4" ''

		cd .. ; rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
a865 8
		# This directory should be on the default ignore list,
		# so it shouldn't get imported.
		mkdir RCS
		echo ignore.me >RCS/ignore.me

		echo 'import should not expand $''Id$' >>imported-file2
		cp imported-file2 ../imported-file2-orig.tmp

d867 1
a867 7
			echo "PASS: test 96" >>${LOGFILE}
		else
			echo "FAIL: test 96" | tee -a ${LOGFILE} ; exit 1
		fi

		if cmp ../imported-file2-orig.tmp imported-file2; then
		  pass 96.5
d869 1
a869 1
		  fail 96.5
d875 1
a875 1
			echo "PASS: test 97" >>${LOGFILE}
d877 1
a877 1
			echo "FAIL: test 97" | tee -a ${LOGFILE} ; exit 1
d883 1
a883 1
				echo "PASS: test 98-$i" >>${LOGFILE}
d885 1
a885 1
				echo "FAIL: test 98-$i" | tee -a ${LOGFILE} ; exit 1
a887 5
		if test -d RCS; then
		  echo "FAIL: test 98.5" | tee -a ${LOGFILE} ; exit 1
		else
		  echo "PASS: test 98.5" >>${LOGFILE}
		fi
d892 1
a892 1
			echo "PASS: test 99" >>${LOGFILE}
d894 1
a894 1
			echo "FAIL: test 99" | tee -a ${LOGFILE} ; exit 1
d905 1
a905 1
			echo "PASS: test 100" >>${LOGFILE}
d907 1
a907 1
			echo "FAIL: test 100" | tee -a ${LOGFILE} ; exit 1
d912 1
a912 1
			echo "FAIL: test 101" | tee -a ${LOGFILE} ; exit 1
d914 1
a914 1
			echo "PASS: test 101" >>${LOGFILE}
d919 1
a919 1
			echo "PASS: test 102" >>${LOGFILE}
d921 1
a921 1
			echo "FAIL: test 102" | tee -a ${LOGFILE} ; exit 1
d928 1
a928 1
			echo "PASS: test 103" >>${LOGFILE}
d930 1
a930 1
			echo "FAIL: test 103" | tee -a ${LOGFILE} ; exit 1
d935 1
a935 1
			echo "PASS: test 104" >>${LOGFILE}
d937 1
a937 1
			echo "FAIL: test 104" | tee -a ${LOGFILE} ; exit 1
d942 1
a942 1
			echo "PASS: test 105" >>${LOGFILE}
d944 1
a944 1
			echo "FAIL: test 105" | tee -a ${LOGFILE} ; exit 1
a951 1
		cp imported-file2 ../imported-file2-orig.tmp
d954 1
a954 1
			echo "PASS: test 106" >>${LOGFILE}
d956 1
a956 6
			echo "FAIL: test 106" | tee -a ${LOGFILE} ; exit 1
		fi
		if cmp ../imported-file2-orig.tmp imported-file2; then
		  pass 106.5
		else
		  fail 106.5
d962 1
a962 1
			echo "PASS: test 107" >>${LOGFILE}
d964 1
a964 1
			echo "FAIL: test 107" | tee -a ${LOGFILE} ; exit 1
d970 1
a970 1
			echo "FAIL: test 108" | tee -a ${LOGFILE} ; exit 1
d972 1
a972 1
			echo "PASS: test 108" >>${LOGFILE}
d977 1
a977 1
				echo "PASS: test 109-$i" >>${LOGFILE}
d979 1
a979 1
				echo "FAIL: test 109-$i" | tee -a ${LOGFILE} ; exit 1
d985 1
a985 1
			echo "PASS: test 110" >>${LOGFILE}
d987 1
a987 1
			echo "FAIL: test 110" | tee -a ${LOGFILE} ; exit 1
d991 1
a991 1
			echo "PASS: test 111" >>${LOGFILE}
d993 1
a993 1
			echo "FAIL: test 111" | tee -a ${LOGFILE} ; exit 1
d998 1
a998 1
			echo "PASS: test 112" >>${LOGFILE}
d1000 1
a1000 1
			echo "FAIL: test 112" | tee -a ${LOGFILE} ; exit 1
d1006 1
a1006 1
			echo "PASS: test 113" >>${LOGFILE}
d1008 1
a1008 1
			echo "FAIL: test 113" | tee -a ${LOGFILE} ; exit 1
d1014 1
a1014 1
			echo "FAIL: test 114" | tee -a ${LOGFILE} ; exit 1
d1016 1
a1016 1
			echo "PASS: test 114" >>${LOGFILE}
d1021 1
a1021 1
				echo "PASS: test 115-$i" >>${LOGFILE}
d1023 1
a1023 1
				echo "FAIL: test 115-$i" | tee -a ${LOGFILE} ; exit 1
d1028 1
a1028 1
			echo "PASS: test 116" >>${LOGFILE}
d1030 1
a1030 1
			echo "FAIL: test 116" | tee -a ${LOGFILE} ; exit 1
d1032 1
a1032 2
		cd .. ; rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
		rm -rf import-dir
d1036 2
a1037 1
		mkdir ${CVSROOT_DIRNAME}/first-dir
d1040 1
a1040 1
			echo "PASS: test 117" >>${LOGFILE}
d1042 1
a1042 1
			echo "FAIL: test 117" | tee -a ${LOGFILE} ; exit 1
d1049 1
a1049 1
			echo "PASS: test 118" >>${LOGFILE}
d1051 1
a1051 1
			echo "FAIL: test 118" | tee -a ${LOGFILE} ; exit 1
d1055 1
a1055 1
			echo "PASS: test 119" >>${LOGFILE}
d1057 1
a1057 1
			echo "FAIL: test 119" | tee -a ${LOGFILE} ; exit 1
d1063 1
a1063 1
			echo "PASS: test 120" >>${LOGFILE}
d1065 1
a1065 1
			echo "FAIL: test 120" | tee -a ${LOGFILE} ; exit 1
d1069 1
a1069 1
			echo "PASS: test 121" >>${LOGFILE}
d1071 1
a1071 1
			echo "FAIL: test 121" | tee -a ${LOGFILE} ; exit 1
d1075 1
a1075 1
			echo "FAIL: test 122" | tee -a ${LOGFILE} ; exit 1
d1077 1
a1077 1
			echo "PASS: test 122" >>${LOGFILE}
d1081 1
a1081 1
			echo "FAIL: test 123" | tee -a ${LOGFILE} ; exit 1
d1083 1
a1083 1
			echo "PASS: test 123" >>${LOGFILE}
d1086 1
a1086 1
		cd .. ; rm -rf first-dir ; rm -rf ${CVSROOT_DIRNAME}/first-dir
d1090 2
a1091 2
		rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
		mkdir ${CVSROOT_DIRNAME}/first-dir
d1252 1
a1252 1
		rm -rf 1 2 3 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
d1255 7
a1261 2
	  rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
	  mkdir ${CVSROOT_DIRNAME}/first-dir
a1269 1
	    exit 1
d1277 1
a1277 1
	  touch a b
d1279 1
a1279 1
	  if ${testcvs} add a b 2>>${LOGFILE} ; then
a1282 1
	    exit 1
a1288 1
	    exit 1
a1295 1
	    exit 1
a1305 1
	    exit 1
a1308 2
	  echo dirmodule first-dir/subdir >>CVSROOT/modules
	  echo namedmodule -d nameddir first-dir/subdir >>CVSROOT/modules
a1314 1
	    exit 1
a1316 2

	  # Test that real modules check out to realmodule/a, not subdir/a.
d1318 1
a1318 1
	    echo 'PASS: test 149a1' >>${LOGFILE}
d1320 1
a1320 2
	    echo 'FAIL: test 149a1' | tee -a ${LOGFILE}
	    exit 1
d1323 1
a1323 1
	    echo 'PASS: test 149a2' >>${LOGFILE}
d1325 1
a1325 2
	    echo 'FAIL: test 149a2' | tee -a ${LOGFILE}
	    exit 1
a1326 87
	  if test -f realmodule/b; then
	    echo 'FAIL: test 149a3' | tee -a ${LOGFILE}
	    exit 1
	  else
	    echo 'PASS: test 149a3' >>${LOGFILE}
	  fi
	  if ${testcvs} -q co realmodule; then
	    echo 'PASS: test 149a4' >>${LOGFILE}
	  else
	    echo 'FAIL: test 149a4' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  if echo "yes" | ${testcvs} release -d realmodule >>${LOGFILE} ; then
	    echo 'PASS: test 149a5' >>${LOGFILE}
	  else
	    echo 'FAIL: test 149a5' | tee -a ${LOGFILE}
	    exit 1
	  fi

	  # Now test the ability to check out a single file from a directory
	  if ${testcvs} co dirmodule/a >>${LOGFILE}; then
	    echo 'PASS: test 150c' >>${LOGFILE}
	  else
	    echo 'FAIL: test 150c' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  if test -d dirmodule && test -f dirmodule/a; then
	    echo 'PASS: test 150d' >>${LOGFILE}
	  else
	    echo 'FAIL: test 150d' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  if test -f dirmodule/b; then
	    echo 'FAIL: test 150e' | tee -a ${LOGFILE}
	    exit 1
	  else
	    echo 'PASS: test 150e' >>${LOGFILE}
	  fi
	  if echo "yes" | ${testcvs} release -d dirmodule >>${LOGFILE} ; then
	    echo 'PASS: test 150f' >>${LOGFILE}
	  else
	    echo 'FAIL: test 150f' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  # Now test the ability to correctly reject a non-existent filename.
	  # For maximum studliness we would check that an error message is
	  # being output.
	  if ${testcvs} co dirmodule/nonexist >>${LOGFILE} 2>&1; then
	    # We accept a zero exit status because it is what CVS does
	    # (Dec 95).  Probably the exit status should be nonzero,
	    # however.
	    echo 'PASS: test 150g1' >>${LOGFILE}
	  else
	    echo 'PASS: test 150g1' >>${LOGFILE}
	  fi
	  # We tolerate the creation of the dirmodule directory, since that
	  # is what CVS does, not because we view that as preferable to not
	  # creating it.
	  if test -f dirmodule/a || test -f dirmodule/b; then
	    echo 'FAIL: test 150g2' | tee -a ${LOGFILE}
	    exit 1
	  else
	    echo 'PASS: test 150g2' >>${LOGFILE}
	  fi
	  rm -rf dirmodule

	  # Now test that a module using -d checks out to the specified
	  # directory.
	  dotest 150h1 "${testcvs} -q co namedmodule" 'U nameddir/a
U nameddir/b'
	  if test -f nameddir/a && test -f nameddir/b; then
	    pass 150h2
	  else
	    fail 150h2
	  fi
	  echo add line >>nameddir/a
	  dotest 150h3 "${testcvs} -q co namedmodule" 'M nameddir/a'
	  rm nameddir/a
	  dotest 150h4 "${testcvs} -q co namedmodule" 'U nameddir/a'
	  if echo "yes" | ${testcvs} release -d nameddir >>${LOGFILE} ; then
	    pass 150h99
	  else
	    fail 150h99
	  fi

	  # Now test that alias modules check out to subdir/a, not
	  # aliasmodule/a.
a1330 1
	    exit 1
a1333 1
	    exit 1
a1342 1
	    exit 1
d1349 5
a1353 1
	    exit 1
d1356 1
a1356 1
	  rm -rf 1 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
a1368 1
	      exit 1
a1376 1
	      exit 1
a1383 1
	      exit 1
a1390 1
	      exit 1
a1397 1
	      exit 1
a1402 1
	      exit 1
d1405 1
a1405 1
	    cd ..; rm -rf a-dir ${CVSROOT_DIRNAME}/a-dir
d1409 1
a1409 1
	  mkdir ${CVSROOT_DIRNAME}/1dir
a1415 1
	    exit 1
a1422 1
	    exit 1
a1427 1
	    exit 1
a1435 1
	    exit 1
a1443 1
	    exit 1
a1448 1
	    exit 1
a1451 1
	  CVSBASE=`basename $testcvs`	# Get basename of CVS executable.
d1453 2
a1454 2
$CVSBASE server: warning: foo is not (any longer) pertinent
$CVSBASE update: unable to remove ./foo: Permission denied
d1457 1
a1457 1
	  ( echo "$CVSBASE [update aborted]: cannot rename file foo to CVS/,,foo: Permission denied" | cmp - ../tst167.err >/dev/null )
a1461 1
	    exit 1
d1467 1
a1467 258
	  rm -rf 1 2 ${CVSROOT_DIRNAME}/1dir
	  ;;

	devcom)
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  if ${testcvs} -q co first-dir >>${LOGFILE} ; then
	    echo 'PASS: test 169' >>${LOGFILE}
	  else
	    echo 'FAIL: test 169' | tee -a ${LOGFILE}
	    exit 1
	  fi

	  cd first-dir
	  echo abb >abb
	  if ${testcvs} add abb 2>>${LOGFILE}; then
	    echo 'PASS: test 170' >>${LOGFILE}
	  else
	    echo 'FAIL: test 170' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 171' >>${LOGFILE}
	  else
	    echo 'FAIL: test 171' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  if ${testcvs} watch on; then
	    echo 'PASS: test 172' >>${LOGFILE}
	  else
	    echo 'FAIL: test 172' | tee -a ${LOGFILE}
	  fi
	  echo abc >abc
	  if ${testcvs} add abc 2>>${LOGFILE}; then
	    echo 'PASS: test 173' >>${LOGFILE}
	  else
	    echo 'FAIL: test 173' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 174' >>${LOGFILE}
	  else
	    echo 'FAIL: test 174' | tee -a ${LOGFILE}
	  fi

	  cd ../..
	  mkdir 2
	  cd 2

	  if ${testcvs} -q co first-dir >>${LOGFILE}; then
	    echo 'PASS: test 175' >>${LOGFILE}
	  else
	    echo 'FAIL: test 175' | tee -a ${LOGFILE}
	  fi
	  cd first-dir
	  if test -w abb; then
	    echo 'FAIL: test 176' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 176' >>${LOGFILE}
	  fi
	  if test -w abc; then
	    echo 'FAIL: test 177' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 177' >>${LOGFILE}
	  fi

	  if ${testcvs} editors >../ans178.tmp; then
	    echo 'PASS: test 178' >>${LOGFILE}
	  else
	    echo 'FAIL: test 178' | tee -a ${LOGFILE}
	  fi
	  cat ../ans178.tmp >>${LOGFILE}
	  if test -s ../ans178.tmp; then
	    echo 'FAIL: test 178a' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 178a' >>${LOGFILE}
	  fi

	  if ${testcvs} edit abb; then
	    echo 'PASS: test 179' >>${LOGFILE}
	  else
	    echo 'FAIL: test 179' | tee -a ${LOGFILE}
	    exit 1
	  fi

	  if ${testcvs} editors >../ans180.tmp; then
	    echo 'PASS: test 180' >>${LOGFILE}
	  else
	    echo 'FAIL: test 180' | tee -a ${LOGFILE}
	    exit 1
	  fi
	  cat ../ans180.tmp >>${LOGFILE}
	  if test -s ../ans180.tmp; then
	    echo 'PASS: test 181' >>${LOGFILE}
	  else
	    echo 'FAIL: test 181' | tee -a ${LOGFILE}
	  fi

	  echo aaaa >>abb
	  if ${testcvs} ci -m modify abb >>${LOGFILE} 2>&1; then
	    echo 'PASS: test 182' >>${LOGFILE}
	  else
	    echo 'FAIL: test 182' | tee -a ${LOGFILE}
	  fi
	  # Unedit of a file not being edited should be a noop.
	  dotest 182.5 "${testcvs} unedit abb" ''

	  if ${testcvs} editors >../ans183.tmp; then
	    echo 'PASS: test 183' >>${LOGFILE}
	  else
	    echo 'FAIL: test 183' | tee -a ${LOGFILE}
	  fi
	  cat ../ans183.tmp >>${LOGFILE}
	  if test -s ../ans183.tmp; then
	    echo 'FAIL: test 184' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 184' >>${LOGFILE}
	  fi

	  if test -w abb; then
	    echo 'FAIL: test 185' | tee -a ${LOGFILE}
	  else
	    echo 'PASS: test 185' >>${LOGFILE}
	  fi

	  if ${testcvs} edit abc; then
	    echo 'PASS: test 186a1' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a1' | tee -a ${LOGFILE}
	  fi
	  # Unedit of an unmodified file.
	  if ${testcvs} unedit abc; then
	    echo 'PASS: test 186a2' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a2' | tee -a ${LOGFILE}
	  fi
	  if ${testcvs} edit abc; then
	    echo 'PASS: test 186a3' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a3' | tee -a ${LOGFILE}
	  fi
	  echo changedabc >abc
	  # Try to unedit a modified file; cvs should ask for confirmation
	  if (echo no | ${testcvs} unedit abc) >>${LOGFILE}; then
	    echo 'PASS: test 186a4' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a4' | tee -a ${LOGFILE}
	  fi
	  if echo changedabc | cmp - abc; then
	    echo 'PASS: test 186a5' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a5' | tee -a ${LOGFILE}
	  fi
	  # OK, now confirm the unedit
	  if (echo yes | ${testcvs} unedit abc) >>${LOGFILE}; then
	    echo 'PASS: test 186a6' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a6' | tee -a ${LOGFILE}
	  fi
	  if echo abc | cmp - abc; then
	    echo 'PASS: test 186a7' >>${LOGFILE}
	  else
	    echo 'FAIL: test 186a7' | tee -a ${LOGFILE}
	  fi

	  cd ../..
	  rm -rf 1 2 ${CVSROOT_DIRNAME}/first-dir
	  ;;

	ignore)
	  mkdir home
	  HOME=${TESTDIR}/home; export HOME
	  dotest 187a1 "${testcvs} -q co CVSROOT" 'U CVSROOT/modules'
	  cd CVSROOT
	  echo rootig.c >cvsignore
	  dotest 187a2 "${testcvs} add cvsignore" 'cvs [a-z]*: scheduling file `cvsignore'"'"' for addition
cvs [a-z]*: use '"'"'cvs commit'"'"' to add this file permanently'

	  # As of Jan 96, local CVS prints "Examining ." and remote doesn't.
	  # Accept either.
	  dotest 187a3 " ${testcvs} ci -m added" \
"${DOTSTAR}"'CS file: /tmp/cvs-sanity/cvsroot/CVSROOT/cvsignore,v
done
Checking in cvsignore;
/tmp/cvs-sanity/cvsroot/CVSROOT/cvsignore,v  <--  cvsignore
initial revision: 1.1
done
cvs [a-z]*: Executing '"'"''"'"'.*mkmodules'"'"' '"'"'/tmp/cvs-sanity/cvsroot/CVSROOT'"'"''"'"''

	  cd ..
	  if echo "yes" | ${testcvs} release -d CVSROOT >>${LOGFILE} ; then
	    echo 'PASS: test 187a4' >>${LOGFILE}
	  else
	    echo 'FAIL: test 187a4' | tee -a ${LOGFILE}
	    exit 1
	  fi

	  # CVS looks at the home dir from getpwuid, not HOME (is that correct
	  # behavior?), so this is hard to test and we won't try.
	  # echo foobar.c >${HOME}/.cvsignore
	  CVSIGNORE=envig.c; export CVSIGNORE
	  mkdir dir-to-import
	  cd dir-to-import
	  touch foobar.c bar.c rootig.c defig.o envig.c optig.c
	  # We really should allow the files to be listed in any order.
	  # But we (kludgily) just list the orders which have been observed.
	  dotest 188a "${testcvs} import -m m -I optig.c first-dir tag1 tag2" \
	    'N first-dir/foobar.c
N first-dir/bar.c
I first-dir/rootig.c
I first-dir/defig.o
I first-dir/envig.c
I first-dir/optig.c

No conflicts created by this import' 'I first-dir/defig.o
I first-dir/envig.c
I first-dir/optig.c
N first-dir/foobar.c
N first-dir/bar.c
I first-dir/rootig.c

No conflicts created by this import'
	  dotest 188b "${testcvs} import -m m -I ! second-dir tag3 tag4" \
	    'N second-dir/foobar.c
N second-dir/bar.c
N second-dir/rootig.c
N second-dir/defig.o
N second-dir/envig.c
N second-dir/optig.c

No conflicts created by this import'
	  cd ..
	  rm -rf dir-to-import

	  dotest 189a "${testcvs} -q co second-dir" \
'U second-dir/bar.c
U second-dir/defig.o
U second-dir/envig.c
U second-dir/foobar.c
U second-dir/optig.c
U second-dir/rootig.c'
	  rm -rf second-dir
	  dotest 189b "${testcvs} -q co first-dir" 'U first-dir/bar.c
U first-dir/foobar.c'
	  cd first-dir
	  touch rootig.c defig.o envig.c optig.c notig.c
	  dotest 189c "${testcvs} -q update -I optig.c" '\? notig.c'
	  # The fact that CVS requires us to specify -I CVS here strikes me
	  # as a bug.
	  dotest 189d "${testcvs} -q update -I ! -I CVS" '\? rootig.c
\? defig.o
\? envig.c
\? optig.c
\? notig.c'
	  cd ..
	  rm -rf first-dir

	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${CVSROOT_DIRNAME}/second-dir
d1470 1
a1470 42
	binfiles)
	  # Test cvs's ability to handle binary files.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest binfiles-1 "${testcvs} -q co first-dir" ''
	  awk 'BEGIN { printf "%c%c%c%c%c%c", 2, 10, 137, 0, 13, 10 }' \
	    </dev/null >binfile.dat
	  cat binfile.dat binfile.dat >binfile2.dat
	  cd first-dir
	  cp ../binfile.dat binfile
	  dotest binfiles-2 "${testcvs} add -kb binfile" \
'cvs [a-z]*: scheduling file `binfile'\'' for addition
cvs [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest binfiles-3 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/binfile,v
done
Checking in binfile;
/tmp/cvs-sanity/cvsroot/first-dir/binfile,v  <--  binfile
initial revision: 1.1
done'
	  cd ../..
	  mkdir 2; cd 2
	  dotest binfiles-4 "${testcvs} -q co first-dir" 'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-5 "cmp ../../1/binfile.dat binfile" ''
	  cp ../../1/binfile2.dat binfile
	  dotest binfiles-6 "${testcvs} -q ci -m modify-it" \
'Checking in binfile;
/tmp/cvs-sanity/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1.2; previous revision: 1.1
done'
	  cd ../../1/first-dir
	  dotest binfiles-7 "${testcvs} -q update" '[UP] binfile'
	  dotest binfiles-8 "cmp ../binfile2.dat binfile" ''

	  cd ../..
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1 2
	  ;;
	*)
	   echo $what is not the name of a test -- ignored
	   ;;
d1474 1
a1474 1
echo "OK, all tests completed."
d1482 1
a1499 5
# * Test "cvs watch add", "cvs watch remove", "cvs watchers", that
#   notify script gets called where appropriate.
# * Test "cvs unedit" and that it really reverts a change.
# * Test that remote edit and/or unedit works when disconnected from
#   server (e.g. set CVS_SERVER to "foobar").
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d3 3
a5 1
#	sanity.sh -- a growing testsuite for cvs.
d48 3
a50 5
# Regexp to match what CVS will call itself in output that it prints.
# FIXME: we don't properly quote this--if the name contains . we'll
# just spuriously match a few things; if the name contains other regexp
# special characters we are probably in big trouble.
PROG=`basename ${testcvs}`
d59 1
a59 1
CVS="${testcvs} -Q"
d72 2
a73 3
# (e.g. SunOS 4.1.3 expr) one.  Rumor has it this will be fixed in the
# next release of GNU expr after 1.12 (but we still have to cater to the old
# ones for some time because they are in many linux distributions).
a84 3
# Rumor has it this will be fixed in the
# next release of GNU expr after 1.12 (but we still have to cater to the old
# ones for some time because they are in many linux distributions).
a93 14
# Work around yet another GNU expr (version 1.10) bug/incompatibility.
# "+" is a special character, yet for unix expr (e.g. SunOS 4.1.3)
# it is not.  I doubt that POSIX allows us to use \+ and assume it means
# (non-special) +, so here is another workaround
# Rumor has it this will be fixed in the
# next release of GNU expr after 1.12 (but we still have to cater to the old
# ones for some time because they are in many linux distributions).
PLUS='+'
if expr 'a +b' : "a ${PLUS}b" >/dev/null; then
  : good, it works
else
  PLUS='\+'
fi

a230 4
# Avoid picking up any stray .cvsrc, etc., from the user running the tests
mkdir home
HOME=${TESTDIR}/home; export HOME

d233 5
a237 4
# The testsuite is broken up into (hopefully manageably-sized)
# independently runnable tests, so that one can quickly get a result
# from a cvs or testsuite change, and to facilitate understanding the
# tests.
d240 1
a240 1
	tests="basica basic1 deep basic2 death branches import new conflicts modules mflag errmsg1 devcom ignore binfiles info"
d277 1
a277 3
# (now that mkmodules is gone, this doesn't test -i the way it
# used to.  In fact, it looks like a noop to me).
echo "CVSROOT		CVSROOT" > cvsroot/CVSROOT/modules
d366 1
a366 1
	  # Similar in spirit to some of the basic1, and basic2
a368 8

	  # Using mkdir in the repository is used throughout these
	  # tests to create a top-level directory.  I think instead it
	  # should be:
	  #   cvs co -l .
	  #   mkdir first-dir
	  #   cvs add first-dir
	  # but currently that works only for local CVS, not remote.
a371 7

	  # Test a few operations, to ensure they gracefully do
	  # nothing in an empty directory.
	  dotest basica-1a0 "${testcvs} -q update" ''
	  dotest basica-1a1 "${testcvs} -q diff -c" ''
	  dotest basica-1a2 "${testcvs} -q status" ''

d382 2
a383 2
"${PROG}"' [a-z]*: scheduling file `ssfile'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
d400 2
a401 2
"${PROG}"' [a-z]*: nothing known about `nonexist'\''
'"${PROG}"' \[[a-z]* aborted\]: correct above errors first!'
d409 72
d482 2
a628 74
	deep)
	  # Test the ability to operate on directories nested rather deeply.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest deep-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  for i in dir1 dir2 dir3 dir4 dir5 dir6 dir7 dir8; do
	    mkdir $i
	    dotest deep-2-$i "${testcvs} add $i" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/dir1[/dir0-9]* added to the repository'
	    cd $i
	    echo file1 >file1
	    dotest deep-3-$i "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  done
	  cd ../../../../../../../../..
	  dotest deep-4 "${testcvs} -q ci -m add-them first-dir" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/file1,v
done
Checking in first-dir/dir1/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/file1,v
done
Checking in first-dir/dir1/dir2/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/file1,v
done
Checking in first-dir/dir1/dir2/dir3/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/file1,v
done
Checking in first-dir/dir1/dir2/dir3/dir4/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v
done
Checking in first-dir/dir1/dir2/dir3/dir4/dir5/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v
done
Checking in first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v
done
Checking in first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v
done
Checking in first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
initial revision: 1.1
done'

	  if echo "yes" | ${testcvs} release -d first-dir >>${LOGFILE}; then
	    pass deep-5
	  else
	    fail deep-5
	  fi
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d630 2
a631 6
		# Test rtag, import, history, various miscellaneous operations

		# First empty the history file
		rm ${CVSROOT_DIRNAME}/CVSROOT/history
		touch ${CVSROOT_DIRNAME}/CVSROOT/history

d634 1
a634 1
		for i in first-dir dir1 dir2 ; do
d646 1
a646 1
			for j in file6 file7; do
d650 1
a650 1
			if ${CVS} add file6 file7  2>> ${LOGFILE}; then
d656 1
a656 1
		cd ../../..
d697 1
a697 1
		for i in first-dir dir1 dir2 ; do
d700 4
a703 2
			# modify a file
			echo file6 >>file6
d705 2
a706 2
			# delete a file
			rm file7
d708 1
a708 1
			if ${CVS} rm file7  2>> ${LOGFILE}; then
d714 4
a717 2
			# and add a new file
			echo file14 >file14
d719 1
a719 1
			if ${CVS} add file14  2>> ${LOGFILE}; then
d725 1
a725 1
		cd ../../..
d777 1
a777 1
		# now try some rtags
d779 1
d858 5
a862 15
		dotest 56 "${testcvs} import -m first-import second-dir first-immigration immigration1 immigration1_0" \
'N second-dir/file14
N second-dir/file6
N second-dir/file7
'"${PROG}"' [a-z]*: Importing /tmp/cvs-sanity/cvsroot/second-dir/dir1
N second-dir/dir1/file14
N second-dir/dir1/file6
N second-dir/dir1/file7
'"${PROG}"' [a-z]*: Importing /tmp/cvs-sanity/cvsroot/second-dir/dir1/dir2
N second-dir/dir1/dir2/file14
N second-dir/dir1/dir2/file6
N second-dir/dir1/dir2/file7

No conflicts created by this import'

d935 5
a939 51
		# Test the cvs history command.

		# The reason that there are two patterns rather than using
		# \(/tmp/cvs-sanity\|<remote>\) is that we are trying to
		# make this portable.  Perhaps at some point we should
		# ditch that notion and require GNU expr (or dejagnu or....)
		# since it seems to be so painful.

		# why are there two lines at the end of the local output
		# which don't exist in the remote output?  would seem to be
		# a CVS bug.
		dotest basic2-64 "${testcvs} his -e -a" \
'O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir           =first-dir= /tmp/cvs-sanity/\*
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir           == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir           == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir/dir1      == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir/dir1      == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir/dir1/dir2 == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir/dir1/dir2 == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir           == /tmp/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir           == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir/dir1      == /tmp/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir/dir1      == /tmp/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir/dir1/dir2 == /tmp/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir/dir1/dir2 == /tmp/cvs-sanity
F [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]*                     =first-dir= /tmp/cvs-sanity/\*
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-revision:1.1\]
O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* \[1.1\] first-dir           =first-dir= /tmp/cvs-sanity/\*
U [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir           == /tmp/cvs-sanity/first-dir
U [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file7     first-dir           == /tmp/cvs-sanity/first-dir' \
'O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir           =first-dir= <remote>/\*
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file6     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file7     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir           == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir/dir1      == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.1 file14    first-dir/dir1/dir2 == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* 1.2 file6     first-dir/dir1/dir2 == <remote>
F [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]*                     =first-dir= <remote>/\*
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* first-dir \[rtagged-by-revision:1.1\]
O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z@@][a-z@@]* \[1.1\] first-dir           =first-dir= <remote>/\*'

d962 2
a963 2
"${PROG}"' [a-z]*: scheduling file `sfile'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
d973 2
a974 2
"${PROG}"' [a-z]*: scheduling `sfile'\'' for removal
'"${PROG}"' [a-z]*: use '\'"${PROG}"' commit'\'' to remove this file permanently'
d1014 2
a1015 11
		dotest_fail 69a0 "test -f file1" ''
		# get the old contents of file1 back
		if ${testcvs} update -p -r 1.1 file1 >file1 2>>${LOGFILE}; then
		  pass 69a1
		else
		  fail 69a1
		fi
		dotest 69a2 "cat file1" ''

		# create second file
		touch file2
d1039 2
a1040 2
"${PROG}"' [a-z]*: scheduling file `file4'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
d1050 2
a1051 2
"${PROG}"' [a-z]*: scheduling `file4'\'' for removal
'"${PROG}"' [a-z]*: use '\'"${PROG}"' commit'\'' to remove this file permanently'
d1219 1
a1219 1
		  "${PROG}"' \[[a-z]* aborted\]: no such tag brnach1'
a1257 88
	branches)
	  # More branch tests, including branches off of branches
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest branches-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 1:ancest >file1
	  echo 2:ancest >file2
	  echo 3:ancest >file3
	  dotest branches-2 "${testcvs} add file1 file2 file3" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file3'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'
	  dotest branches-3 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file3,v
done
Checking in file3;
/tmp/cvs-sanity/cvsroot/first-dir/file3,v  <--  file3
initial revision: 1.1
done'
	  dotest branches-4 "${testcvs} tag -b br1" "${PROG}"' [a-z]*: Tagging \.
T file1
T file2
T file3'
	  dotest branches-5 "${testcvs} update -r br1" \
"${PROG}"' [a-z]*: Updating \.'
	  echo 1:br1 >file1
	  echo 2:br1 >file2
	  dotest branches-6 "${testcvs} -q ci -m modify" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1.1.2.1; previous revision: 1.1
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
new revision: 1.1.2.1; previous revision: 1.1
done'
	  dotest branches-7 "${testcvs} -q tag -b brbr" 'T file1
T file2
T file3'
	  dotest branches-8 "${testcvs} -q update -r brbr" ''
	  echo 1:brbr >file1
	  dotest branches-9 "${testcvs} -q ci -m modify" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1.1.2.1.2.1; previous revision: 1.1.2.1
done'
	  dotest branches-10 "cat file1 file2 file3" '1:brbr
2:br1
3:ancest'
	  dotest branches-11 "${testcvs} -q update -r br1" 'U file1' 'P file1'
	  dotest branches-12 "cat file1 file2 file3" '1:br1
2:br1
3:ancest'
	  dotest branches-13 "${testcvs} -q update -A" '. file1
. file2'
	  dotest branches-14 "cat file1 file2 file3" '1:ancest
2:ancest
3:ancest'
	  dotest branches-15 \
	    "${testcvs} update -j 1.1.2.1 -j 1.1.2.1.2.1 file1" \
	    'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
retrieving revision 1.1.2.1
retrieving revision 1.1.2.1.2.1
Merging differences between 1.1.2.1 and 1.1.2.1.2.1 into file1
rcsmerge: warning: conflicts during merge'
	  dotest branches-16 "cat file1" '<<<<<<< file1
1:ancest
=======
1:brbr
>>>>>>> 1.1.2.1.2.1'
	  cd ..

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r first-dir
	  ;;
d1561 6
a1566 8
		mkdir dir1
		dotest conflicts-127b "${testcvs} add dir1" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/dir1 added to the repository'
		dotest conflicts-128 "${testcvs} -q ci -m changed" \
'Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
new revision: 1.2; previous revision: 1.1
done'
d1569 14
a1582 24
		dotest_fail conflicts-129 "${testcvs} -q ci -m changed" \
"${PROG}"' [a-z]*: Up-to-date check failed for `a'\''
'"${PROG}"' \[[a-z]* aborted\]: correct above errors first!'
		mkdir dir1
		mkdir sdir
		dotest conflicts-130 "${testcvs} -q update" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/a,v
retrieving revision 1.1
retrieving revision 1.2
Merging differences between 1.1 and 1.2 into a
rcsmerge: warning: conflicts during merge
'"${PROG}"' [a-z]*: conflicts found in a
C a
\? dir1
\? sdir' \
'\? dir1
\? sdir
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/a,v
retrieving revision 1.1
retrieving revision 1.2
Merging differences between 1.1 and 1.2 into a
rcsmerge: warning: conflicts during merge
'"${PROG}"' [a-z]*: conflicts found in a
C a'
d1623 10
a1632 9
		dotest conflicts-136 "${testcvs} -q update" \
'[UP] first-dir/abc
\? first-dir/dir1
\? first-dir/sdir' \
'\? first-dir/dir1
\? first-dir/sdir
[UP] first-dir/abc'
		dotest conflicts-137 'test -f first-dir/abc' ''
		rmdir first-dir/dir1 first-dir/sdir
a1980 1

a1981 1
	  # FIXME: should be using dotest and PROG.
a2027 1
	  dotest_fail 171a0 "${testcvs} watch" "Usage${DOTSTAR}"
a2164 9
	  dotest devcom-a0 "${testcvs} watchers" ''
	  dotest devcom-a1 "${testcvs} watch add" ''
	  dotest devcom-a2 "${testcvs} watchers" \
'abb	[a-z0-9]*	edit	unedit	commit
abc	[a-z0-9]*	edit	unedit	commit'
	  dotest devcom-a3 "${testcvs} watch remove -a unedit abb" ''
	  dotest devcom-a4 "${testcvs} watchers abb" \
'abb	[a-z0-9]*	edit	commit'

d2170 2
d2175 2
a2176 2
	  dotest 187a2 "${testcvs} add cvsignore" "${PROG}"' [a-z]*: scheduling file `cvsignore'"'"' for addition
'"${PROG}"' [a-z]*: use '"'"'cvs commit'"'"' to add this file permanently'
d2187 1
a2187 1
'"${PROG}"' [a-z]*: Rebuilding administrative file database'
d2271 2
a2272 2
"${PROG}"' [a-z]*: scheduling file `binfile'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
a2298 60
	info)
	  # Test CVS's ability to handle *info files.
	  dotest info-1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  echo "ALL echo x\${=MYENV}\${=OTHER}y\${=ZEE}=\$USER=\$CVSROOT= >>$TESTDIR/testlog" > loginfo
	  dotest info-2 "${testcvs} add loginfo" \
"${PROG}"' [a-z]*: scheduling file `loginfo'"'"' for addition
'"${PROG}"' [a-z]*: use '"'"'cvs commit'"'"' to add this file permanently'
	  dotest info-3 "${testcvs} -q ci -m new-loginfo" \
'RCS file: /tmp/cvs-sanity/cvsroot/CVSROOT/loginfo,v
done
Checking in loginfo;
/tmp/cvs-sanity/cvsroot/CVSROOT/loginfo,v  <--  loginfo
initial revision: 1.1
done
'"${PROG}"' [a-z]*: Rebuilding administrative file database'
	  cd ..
	  if echo "yes" | ${testcvs} release -d CVSROOT >>${LOGFILE} ; then
	    pass info-4
	  else
	    fail info-4
	  fi

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest info-5 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  touch file1
	  dotest info-6 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  echo "cvs -s OTHER=not-this -s MYENV=env-" >>$HOME/.cvsrc
	  dotest info-6a "${testcvs} -q -s OTHER=value ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1.1
done
'"${PROG}"' [a-z]*: loginfo:1: no such user variable ${=ZEE}'
	  echo line1 >>file1
	  dotest info-7 "${testcvs} -q -s OTHER=value -s ZEE=z ci -m mod-it" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1.2; previous revision: 1.1
done'
	  cd ..
	  if echo "yes" | ${testcvs} release -d first-dir >>${LOGFILE} ; then
	    pass info-8
	  else
	    fail info-8
	  fi
	  dotest info-9 "cat $TESTDIR/testlog" 'xenv-valueyz=[a-z@@][a-z@@]*=/tmp/cvs-sanity/cvsroot='

	  # I think this might be doable with cvs remove, or at least
	  # checking in a version with only comments, but I'm too lazy
	  # at the moment.  Blow it away.
	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/loginfo*

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d2330 3
a2332 3
# * Test ability to send notifications in response to watches.  (currently
#   hard to test because CVS doesn't send notifications if username is the
#   same).
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a32 12
# The --keep option will eventually cause all the tests to leave around the
# contents of the /tmp directory; right now only some implement it.  Not
# useful if you are running more than one test.
# FIXME: need some real option parsing so this doesn't depend on the order
# in which they are specified.
if test x"$1" = x"--keep"; then
  shift
  keep=yes
else
  keep=no
fi

a111 8
# Likewise, for ?
QUESTION='?'
if expr 'a?b' : "a${QUESTION}b" >/dev/null; then
  : good, it works
else
  QUESTION='\?'
fi

a123 11
# Warn SunOS, SysVr3.2, etc., users that they may be partially losing
if expr 'a
b' : 'a
c' >/dev/null; then
  echo 'Warning: you are using a version of expr which does not correctly'
  echo 'match multi-line patterns.  Some tests may spuriously pass.'
  echo 'You may wish to make sure GNU expr is in your path.'
else
  : good, it works
fi

d136 14
a149 3
# See dotest and dotest_fail for explanation (this is the parts
# of the implementation common to the two).
dotest_internal ()
d151 8
d203 3
a205 27
# Usage:
#  dotest TESTNAME COMMAND OUTPUT [OUTPUT2]
# TESTNAME is the name used in the log to identify the test.
# COMMAND is the command to run; for the test to pass, it exits with 
# exitstatus zero.
# OUTPUT is a regexp which is compared against the output (stdout and
# stderr combined) from the test.  It is anchored to the start and end
# of the output, so should start or end with ".*" if that is what is desired.
# Trailing newlines are stripped from the command's actual output before
# matching against OUTPUT.
# If OUTPUT2 is specified and the output matches it, then it is also
# a pass (partial workaround for the fact that some versions of expr
# lack \|).
dotest ()
{
  if $2 >${TESTDIR}/dotest.tmp 2>&1; then
    : so far so good
  else
    status=$?
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    echo "exit status was $status" >>${LOGFILE}
    fail "$1"
  fi
  dotest_internal "$@@"
}

# Like dotest except exitstatus should be nonzero.
d216 13
a228 10
  dotest_internal "$@@"
}

# Like dotest except second argument is the required exitstatus.
dotest_status ()
{
  $3 >${TESTDIR}/dotest.tmp 2>&1
  status=$?
  if test "$status" = "$2"; then
    : so far so good
d230 11
a240 3
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    echo "exit status was $status; expected $2" >>${LOGFILE}
    fail "$1"
a241 1
  dotest_internal "$1" "$3" "$4" "$5"
a418 11

	  # Trying to commit it without a "cvs add" should be an error.
	  # The "use `cvs add' to create an entry" message is the one
	  # that I consider to be more correct, but local cvs prints the
	  # "nothing known" message and noone has gotten around to fixing it.
	  dotest_fail basica-notadded "${testcvs} -q ci ssfile" \
"${PROG} [a-z]*: use "'`cvs add'\'' to create an entry for ssfile
'"${PROG}"' \[[a-z]* aborted\]: correct above errors first!' \
"${PROG}"' [a-z]*: nothing known about `ssfile'\''
'"${PROG}"' \[[a-z]* aborted\]: correct above errors first!'

a421 3
	  dotest_fail basica-4a "${testcvs} tag tag0 ssfile" \
"${PROG} [a-z]*: nothing known about ssfile
${PROG} "'\[[a-z]* aborted\]: correct the above errors first!'
a429 7
	  dotest_fail basica-5a \
	    "${testcvs} -q tag BASE sdir/ssdir/ssfile" \
"${PROG} [a-z]*: Attempt to add reserved tag name BASE
${PROG} \[[a-z]* aborted\]: failed to set tag BASE to revision 1.1 in /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v"
	  dotest basica-5b "${testcvs} -q tag NOT_RESERVED" \
'T sdir/ssdir/ssfile'

a431 13
	  dotest_status basica-6.2 1 "${testcvs} -q diff -c" \
'Index: sdir/ssdir/ssfile
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v
retrieving revision 1\.1
diff -c -r1\.1 ssfile
\*\*\* ssfile	[0-9/]* [0-9:]*	1\.1
--- ssfile	[0-9/]* [0-9:]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
--- 1,2 ----
  ssfile
'"${PLUS} ssfile line 2"
a440 11
	  dotest_fail basica-9 \
	    "${testcvs} -q -d /tmp/cvs-sanity/nonexist update" \
"${PROG}: .*/tmp/cvs-sanity/cvsroot value for CVS Root found in CVS/Root
${PROG}"': does not match command line -d /tmp/cvs-sanity/nonexist setting
'"${PROG}"': you may wish to try the cvs command again without the -d option '

	  dotest basica-10 "${testcvs} annotate" \
'Annotations for sdir/ssdir/ssfile
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1.1          .[a-z@@][a-z@@ ]* [0-9a-zA-Z-]*.: ssfile
1.2          .[a-z@@][a-z@@ ]* [0-9a-zA-Z-]*.: ssfile line 2'
d501 18
d549 20
d957 5
a961 1
		dotest 61 "${testcvs} -q diff -u" ''
d1368 1
a1368 2
	  echo 4:trunk-1 >file4
	  dotest branches-2 "${testcvs} add file1 file2 file3 file4" \
a1371 1
'"${PROG}"' [a-z]*: scheduling file `file4'\'' for addition
a1390 12
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
initial revision: 1.1
done'
	  echo 4:trunk-2 >file4
	  dotest branches-3.2 "${testcvs} -q ci -m trunk-before-branch" \
'Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1.2; previous revision: 1.1
d1395 1
a1395 2
T file3
T file4'
a1399 1
	  echo 4:br1 >file4
a1407 4
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1.2.2.1; previous revision: 1.2
d1411 1
a1411 2
T file3
T file4'
a1413 1
	  echo 4:brbr >file4
a1417 4
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1.2.2.1.2.1; previous revision: 1.2.2.1
d1419 1
a1419 1
	  dotest branches-10 "cat file1 file2 file3 file4" '1:brbr
d1421 3
a1423 6
3:ancest
4:brbr'
	  dotest branches-11 "${testcvs} -q update -r br1" \
'[UP] file1
[UP] file4'
	  dotest branches-12 "cat file1 file2 file3 file4" '1:br1
d1425 4
a1428 12
3:ancest
4:br1'
	  echo 4:br1-2 >file4
	  dotest branches-12.2 "${testcvs} -q ci -m change-on-br1" \
'Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1.2.2.2; previous revision: 1.2.2.1
done'
	  dotest branches-13 "${testcvs} -q update -A" '[UP] file1
[UP] file2
[UP] file4'
	  dotest branches-14 "cat file1 file2 file3 file4" '1:ancest
d1430 1
a1430 80
3:ancest
4:trunk-2'
	  echo 4:trunk-3 >file4
	  dotest branches-14.2 \
	    "${testcvs} -q ci -m trunk-change-after-branch" \
'Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1.3; previous revision: 1.2
done'
	  dotest branches-14.3 "${testcvs} log file4" \
'
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
Working file: file4
head: 1\.3
branch:
locks: strict
access list:
symbolic names:
	brbr: 1\.2\.2\.1\.0\.2
	br1: 1\.2\.0\.2
keyword substitution: kv
total revisions: 6;	selected revisions: 6
description:
----------------------------
revision 1\.3
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
trunk-change-after-branch
----------------------------
revision 1\.2
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
branches:  1\.2\.2;
trunk-before-branch
----------------------------
revision 1\.1
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;
add-it
----------------------------
revision 1\.2\.2\.2
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
change-on-br1
----------------------------
revision 1\.2\.2\.1
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
branches:  1\.2\.2\.1\.2;
modify
----------------------------
revision 1\.2\.2\.1\.2\.1
date: [0-9/: ]*;  author: [a-z@@][a-z@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
modify
============================================================================='
	  dotest_status branches-14.4 1 \
	    "${testcvs} diff -c -r 1.1 -r 1.3 file4" \
'Index: file4
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
retrieving revision 1\.1
retrieving revision 1\.3
diff -c -r1\.1 -r1\.3
\*\*\* file4	[0-9/]* [0-9:]*	1\.1
--- file4	[0-9/]* [0-9:]*	1\.3
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
! 4:trunk-1
--- 1 ----
! 4:trunk-3'
	  dotest_status branches-14.5 1 \
	    "${testcvs} diff -c -r 1.1 -r 1.2.2.1 file4" \
'Index: file4
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
retrieving revision 1\.1
retrieving revision 1\.2\.2\.1
diff -c -r1\.1 -r1\.2\.2\.1
\*\*\* file4	[0-9/]* [0-9:]*	1\.1
--- file4	[0-9/]* [0-9:]*	1\.2\.2\.1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
! 4:trunk-1
--- 1 ----
! 4:br1'
a1444 5
	  if test "$keep" = yes; then
	    echo Keeping /tmp/cvs-sanity and exiting due to --keep
	    exit 0
	  fi

d1774 4
a1777 4
'"${QUESTION}"' dir1
'"${QUESTION}"' sdir' \
''"${QUESTION}"' dir1
'"${QUESTION}"' sdir
d1827 4
a1830 4
'"${QUESTION}"' first-dir/dir1
'"${QUESTION}"' first-dir/sdir' \
''"${QUESTION}"' first-dir/dir1
'"${QUESTION}"' first-dir/sdir
a1899 3
	  mkdir ssdir
	  ${testcvs} add ssdir >>${LOGFILE}

a1938 6
	  echo aliasnested -a first-dir/subdir/ssdir >>CVSROOT/modules

	  # Options must come before arguments.  It is possible this should
	  # be relaxed at some point (though the result would be bizarre for
	  # -a); for now test the current behavior.
	  echo bogusalias first-dir/subdir/a -a >>CVSROOT/modules
a1946 15
	  dotest 148a0 "${testcvs} co -c" 'CVSROOT      CVSROOT
aliasmodule  -a first-dir/subdir/a
aliasnested  -a first-dir/subdir/ssdir
bogusalias   first-dir/subdir/a -a
dirmodule    first-dir/subdir
namedmodule  -d nameddir first-dir/subdir
realmodule   first-dir/subdir a'
	  # I don't know why aliasmodule isn't printed (I would have thought
	  # that it gets printed without the -a; although I'm not sure that
	  # printing expansions without options is useful).
	  dotest 148a1 "${testcvs} co -s" 'CVSROOT      NONE        CVSROOT
bogusalias   NONE        first-dir/subdir/a -a
dirmodule    NONE        first-dir/subdir
namedmodule  NONE        first-dir/subdir
realmodule   NONE        first-dir/subdir a'
a2074 1

d2076 1
a2076 15
	  rm -rf 1

	  mkdir 2
	  cd 2
	  dotest modules-155a0 "${testcvs} co aliasnested" \
"${PROG} [a-z]*: Updating first-dir/subdir/ssdir"
	  dotest modules-155a1 "test -d first-dir" ''
	  dotest modules-155a2 "test -d first-dir/subdir" ''
	  dotest modules-155a3 "test -d first-dir/subdir/ssdir" ''
	  # Test that nothing extraneous got created.
	  dotest modules-155a4 "ls -1" "first-dir"
	  cd ..
	  rm -rf 2

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d2457 1
a2457 1
	  dotest 189c "${testcvs} -q update -I optig.c" "${QUESTION} notig.c"
d2460 5
a2464 5
	  dotest 189d "${testcvs} -q update -I ! -I CVS" "${QUESTION} rootig.c
${QUESTION} defig.o
${QUESTION} envig.c
${QUESTION} optig.c
${QUESTION} notig.c"
a2495 12
	  # Testing that sticky options is -kb is the closest thing we have
	  # to testing that binary files work right on non-unix machines
	  # (until there is automated testing for such machines, of course).
	  dotest binfiles-5.5 "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
a2505 56
	  # The bugs which these test for are apparently not fixed for remote.
	  if test "$remote" = no; then
	    dotest binfiles-9 "${testcvs} -q update -A" ''
	    dotest binfiles-10 "${testcvs} -q update -kk" '[UP] binfile'
	    dotest binfiles-11 "${testcvs} -q update" ''
	    dotest binfiles-12 "${testcvs} -q update -A" '[UP] binfile'
	    dotest binfiles-13 "${testcvs} -q update -A" ''
	  fi

	  cd ../../2/first-dir
	  echo 'this file is $''RCSfile$' >binfile
	  dotest binfiles-14a "${testcvs} -q ci -m modify-it" \
'Checking in binfile;
/tmp/cvs-sanity/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1.3; previous revision: 1.2
done'
	  dotest binfiles-14b "cat binfile" 'this file is $''RCSfile$'
	  # See binfiles-5.5 for discussion of -kb.
	  dotest binfiles-14c "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.3.*
   Repository revision:	1\.3	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  dotest binfiles-14d "${testcvs} admin -kv binfile" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/binfile,v
done'
	  # cvs admin doesn't change the checked-out file or its sticky
	  # kopts.  There probably should be a way which does (but
	  # what if the file is modified?  And do we try to version
	  # control the kopt setting?)
	  dotest binfiles-14e "cat binfile" 'this file is $''RCSfile$'
	  dotest binfiles-14f "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.3.*
   Repository revision:	1\.3	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  dotest binfiles-14g "${testcvs} -q update -A" '[UP] binfile'
	  dotest binfiles-14h "cat binfile" 'this file is binfile,v'
	  dotest binfiles-14i "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.3.*
   Repository revision:	1\.3	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kv'

d2514 1
a2514 1
	  echo "ALL sh -c \"echo x\${=MYENV}\${=OTHER}y\${=ZEE}=\$USER=\$CVSROOT= >>$TESTDIR/testlog; cat >/dev/null\"" > loginfo
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a19 4
# This will show up in cvs history output where it prints the working
# directory.  It should *not* appear in any cvs output referring to the
# repository; cvs should use the name of the repository as specified.
TMPPWD=`cd /tmp; /bin/pwd`
a28 6
	# If we're going to do remote testing, make sure 'rsh' works first.
        host="`hostname`"
	if test "x`${CVS_RSH-rsh} $host 'echo hi'`" != "xhi"; then
	    echo "ERROR: cannot test remote CVS, because \`rsh $host' fails." >&2
	    exit 1
	fi
a81 61
GEXPRLOCS="`echo $PATH | sed 's/:/ /g'` /usr/local/bin /usr/contrib/bin /usr/gnu/bin /local/bin /local/gnu/bin /gun/bin"

EXPR=expr

# Cause NextStep 3.3 users to lose in a more graceful fashion.
if $EXPR 'abc
def' : 'abc
def' >/dev/null; then
  : good, it works
else
  for path in $GEXPRLOCS ; do
    if test -x $path/gexpr ; then
      if test "X`$path/gexpr --version`" != "X--version" ; then
        EXPR=$path/gexpr
        break
      fi
    fi
    if test -x $path/expr ; then
      if test "X`$path/expr --version`" != "X--version" ; then
        EXPR=$path/expr
        break
      fi
    fi
  done
  if test -z "$EXPR" ; then
    echo 'Running these tests requires an "expr" program that can handle'
    echo 'multi-line patterns.  Make sure that such an expr (GNU, or many but'
    echo 'not all vendor-supplied versions) is in your path.'
    exit 1
  fi
fi

# Warn SunOS, SysVr3.2, etc., users that they may be partially losing
# if we can't find a GNU expr to ease their troubles...
if $EXPR 'a
b' : 'a
c' >/dev/null; then
  for path in $GEXPRLOCS ; do
    if test -x $path/gexpr ; then
      if test "X`$path/gexpr --version`" != "X--version" ; then
        EXPR=$path/gexpr
        break
      fi
    fi
    if test -x $path/expr ; then
      if test "X`$path/expr --version`" != "X--version" ; then
        EXPR=$path/expr
        break
      fi
    fi
  done
  if test -z "$EXPR" ; then
    echo 'Warning: you are using a version of expr which does not correctly'
    echo 'match multi-line patterns.  Some tests may spuriously pass.'
    echo 'You may wish to make sure GNU expr is in your path.'
    EXPR=expr
  fi
else
  : good, it works
fi

d83 1
a83 1
# version 1.9.4-1.12 uses the emacs definition of "$" instead of the unix
d88 1
a88 1
if $EXPR 'abc
d93 1
a93 1
# Work around another GNU expr (version 1.10-1.12) bug/incompatibility.
d102 1
a102 1
if $EXPR 'abc
d118 1
a118 1
if $EXPR 'a +b' : "a ${PLUS}b" >/dev/null; then
d126 1
a126 1
if $EXPR 'a?b' : "a${QUESTION}b" >/dev/null; then
d132 23
a176 2
      echo "$3" > ${TESTDIR}/dotest.exp
      rm -f ${TESTDIR}/dotest.ex2
d181 1
d185 1
a185 1
    if $EXPR "`cat ${TESTDIR}/dotest.tmp`" : \
d187 1
d191 1
a191 1
	if $EXPR "`cat ${TESTDIR}/dotest.tmp`" : \
a192 9
	  pass "$1"
	else
	  echo "** expected: " >>${LOGFILE}
	  echo "$3" >>${LOGFILE}
	  echo "$3" > ${TESTDIR}/dotest.ex1
	  echo "** or: " >>${LOGFILE}
	  echo "$4" >>${LOGFILE}
	  echo "$4" > ${TESTDIR}/dotest.ex2
	  echo "** got: " >>${LOGFILE}
a193 74
	  fail "$1"
	fi
      else
	echo "** expected: " >>${LOGFILE}
	echo "$3" >>${LOGFILE}
	echo "$3" > ${TESTDIR}/dotest.exp
	echo "** got: " >>${LOGFILE}
	cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
	fail "$1"
      fi
    fi
  fi
}

dotest_all_in_one ()
{
  if $EXPR "`cat ${TESTDIR}/dotest.tmp`" : \
         "`cat ${TESTDIR}/dotest.exp`" >/dev/null; then
    return 0
  fi
  return 1
}

# WARNING: this won't work with REs that match newlines....
#
dotest_line_by_line ()
{
  line=1
  while [ $line -le `wc -l ${TESTDIR}/dotest.tmp` ] ; do
    echo "$line matched \c" >>$LOGFILE
    if $EXPR "`sed -n ${line}p ${TESTDIR}/dotest.tmp`" : \
       "`sed -n ${line}p ${TESTDIR}/dotest.exp`" >/dev/null; then
      :
    else
      echo "**** expected line: " >>${LOGFILE}
      sed -n ${line}p ${TESTDIR}/dotest.exp >>${LOGFILE}
      echo "**** got line: " >>${LOGFILE}
      sed -n ${line}p ${TESTDIR}/dotest.tmp >>${LOGFILE}
      unset line
      return 1
    fi
    line=`expr $line + 1`
  done
  unset line
  return 0
}

# If you are having trouble telling which line of a multi-line
# expression is not being matched, replace calls to dotest_internal()
# with calls to this function:
#
dotest_internal_debug ()
{
  if test -z "$3"; then
    if test -s ${TESTDIR}/dotest.tmp; then
      echo "** expected: " >>${LOGFILE}
      echo "$3" >>${LOGFILE}
      echo "$3" > ${TESTDIR}/dotest.exp
      rm -f ${TESTDIR}/dotest.ex2
      echo "** got: " >>${LOGFILE}
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      fail "$1"
    else
      pass "$1"
    fi
  else
    echo "$3" > ${TESTDIR}/dotest.exp
    if dotest_line_by_line "$1" "$2"; then
      pass "$1"
    else
      if test x"$4" != x; then
	mv ${TESTDIR}/dotest.exp ${TESTDIR}/dotest.ex1
	echo "$4" > ${TESTDIR}/dotest.exp
	if dotest_line_by_line "$1" "$2"; then
a195 1
	  mv ${TESTDIR}/dotest.exp ${TESTDIR}/dotest.ex2
d218 1
a218 1
# COMMAND is the command to run; for the test to pass, it exits with
a229 1
  rm -f ${TESTDIR}/dotest.ex? 2>&1
a240 24
# Like dotest except only 2 args and result must exactly match stdin
dotest_lit ()
{
  rm -f ${TESTDIR}/dotest.ex? 2>&1
  if $2 >${TESTDIR}/dotest.tmp 2>&1; then
    : so far so good
  else
    status=$?
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    echo "exit status was $status" >>${LOGFILE}
    fail "$1"
  fi
  cat >${TESTDIR}/dotest.exp
  if cmp ${TESTDIR}/dotest.exp ${TESTDIR}/dotest.tmp >/dev/null 2>&1; then
    pass "$1"
  else
    echo "** expected: " >>${LOGFILE}
    cat ${TESTDIR}/dotest.exp >>${LOGFILE}
    echo "** got: " >>${LOGFILE}
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    fail "$1"
  fi
}

a243 1
  rm -f ${TESTDIR}/dotest.ex? 2>&1
d287 1
a287 7
	# This doesn't yet include log2, because the bug it tests for
	# is not yet fixed, and/or we might want to wait until after 1.9.
	#
	# We also omit rdiff for now, because we have put off
	# committing the changes that make it work until after the 1.9
	# release.
	tests="basica basicb basic1 deep basic2 death death2 branches multibranch import join new newb conflicts conflicts2 modules mflag errmsg1 devcom ignore binfiles binwrap info serverpatch log"
d353 4
a356 2
# Returns: {nothing}
# Side Effects: ISDIFF := true|false
d383 1
a383 1
		if test -f $DIR_1/"$a" ; then
d385 1
a385 1
			if test $? -ne 0 ; then
d390 2
a391 1
	rm -f /tmp/dc$$*
d401 4
a404 4
	# Use rsh so we can test it without having to muck with inetd
	# or anything like that.  Also needed to get CVS_SERVER to
	# work.
	CVSROOT=:ext:`hostname`:${CVSROOT_DIRNAME} ; export CVSROOT
a436 8
	  # Remote CVS gives the "cannot open CVS/Entries" error, which is
	  # clearly a bug, but not a simple one to fix.
	  dotest basica-1a10 "${testcvs} -n add sdir" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir added to the repository' \
"${PROG} add: cannot open CVS/Entries for reading: No such file or directory
Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir added to the repository"
	  dotest_fail basica-1a11 \
	    "test -d ${CVSROOT_DIRNAME}/first-dir/sdir" ''
d468 1
a468 1
initial revision: 1\.1
d473 1
a473 1
${PROG} \[[a-z]* aborted\]: failed to set tag BASE to revision 1\.1 in /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v"
a491 13
	  dotest_status basica-6.3 1 "${testcvs} -q diff -c -rBASE" \
'Index: sdir/ssdir/ssfile
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v
retrieving revision 1\.1
diff -c -r1\.1 ssfile
\*\*\* ssfile	[0-9/]* [0-9:]*	1\.1
--- ssfile	[0-9/]* [0-9:]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
--- 1,2 ----
  ssfile
'"${PLUS} ssfile line 2"
d495 1
a495 1
new revision: 1\.2; previous revision: 1\.1
a500 6

	  # The .* here will normally be "No such file or directory",
	  # but if memory serves some systems (AIX?) have a different message.
:	  dotest_fail basica-9 \
	    "${testcvs} -q -d /tmp/cvs-sanity/nonexist update" \
"${PROG}: cannot access cvs root /tmp/cvs-sanity/nonexist: .*"
d503 3
a505 1
"${PROG} \[[a-z]* aborted\]: /tmp/cvs-sanity/nonexist/CVSROOT: .*"
d510 2
a511 2
1\.1          .[a-z0-9@@][a-z0-9@@ ]* [0-9a-zA-Z-]*.: ssfile
1\.2          .[a-z0-9@@][a-z0-9@@ ]* [0-9a-zA-Z-]*.: ssfile line 2'
a517 91
	basicb)
	  # More basic tests, including non-branch tags and co -d.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest basicb-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  mkdir sdir1 sdir2
	  dotest basicb-2 "${testcvs} add sdir1 sdir2" \
'Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir1 added to the repository
Directory /tmp/cvs-sanity/cvsroot/first-dir/sdir2 added to the repository'
	  cd sdir1
	  echo sfile1 starts >sfile1
	  dotest basicb-2a10 "${testcvs} -n add sfile1" \
"${PROG} [a-z]*: scheduling file .sfile1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest basicb-2a11 "${testcvs} status sfile1" \
"${PROG} [a-z]*: use .cvs add' to create an entry for sfile1
===================================================================
File: sfile1           	Status: Unknown

   Working revision:	No entry for sfile1
   Repository revision:	No revision control file"
	  dotest basicb-3 "${testcvs} add sfile1" \
"${PROG} [a-z]*: scheduling file .sfile1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest basicb-3a1 "${testcvs} status sfile1" \
"===================================================================
File: sfile1           	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  cd ../sdir2
	  echo sfile2 starts >sfile2
	  dotest basicb-4 "${testcvs} add sfile2" \
"${PROG} [a-z]*: scheduling file .sfile2. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  cd ..
	  dotest basicb-5 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir1/sfile1,v
done
Checking in sdir1/sfile1;
/tmp/cvs-sanity/cvsroot/first-dir/sdir1/sfile1,v  <--  sfile1
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir2/sfile2,v
done
Checking in sdir2/sfile2;
/tmp/cvs-sanity/cvsroot/first-dir/sdir2/sfile2,v  <--  sfile2
initial revision: 1\.1
done'
	  echo sfile1 develops >sdir1/sfile1
	  dotest basicb-6 "${testcvs} -q ci -m modify" \
'Checking in sdir1/sfile1;
/tmp/cvs-sanity/cvsroot/first-dir/sdir1/sfile1,v  <--  sfile1
new revision: 1\.2; previous revision: 1\.1
done'
	  dotest basicb-7 "${testcvs} -q tag release-1" 'T sdir1/sfile1
T sdir2/sfile2'
	  echo not in time for release-1 >sdir2/sfile2
	  dotest basicb-8 "${testcvs} -q ci -m modify-2" \
'Checking in sdir2/sfile2;
/tmp/cvs-sanity/cvsroot/first-dir/sdir2/sfile2,v  <--  sfile2
new revision: 1\.2; previous revision: 1\.1
done'
	  cd ..

	  # Test that we recurse into the correct directory when checking
	  # for existing files, even if co -d is in use.
	  touch first-dir/extra
	  dotest basicb-cod-1 "${testcvs} -q co -d first-dir1 first-dir" \
'U first-dir1/sdir1/sfile1
U first-dir1/sdir2/sfile2'
	  rm -rf first-dir1

	  rm -rf first-dir
	  dotest basicb-9 \
"${testcvs} -q co -d newdir -r release-1 first-dir/sdir1 first-dir/sdir2" \
'U newdir/sdir1/sfile1
U newdir/sdir2/sfile2'
	  dotest basicb-10 "cat newdir/sdir1/sfile1 newdir/sdir2/sfile2" \
"sfile1 develops
sfile2 starts"

	  rm -rf newdir

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d544 1
a544 1
					if test "${do}" = "rm" -a "$j" != "commit -m test" || ${CVS} update ${files} ; then
d642 2
a643 2
	  dotest_lit deep-4 "${testcvs} -q ci -m add-them first-dir" <<'HERE'
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/dir1/file1,v
a689 11
done
HERE

	  cd first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8
	  rm file1
	  dotest deep-4a0 "${testcvs} rm file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest deep-4a1 "${testcvs} -q ci -m rm-it" 'Removing file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
a690 5
	  cd ../../..
	  dotest deep-4a2 "${testcvs} -q update -P dir6/dir7" ''
	  # Should be using "test -e" if that is portable enough.
	  dotest_fail deep-4a3 "test -d dir6/dir7/dir8" ''
	  cd ../../../../../..
a702 5
		# NOTE: this section has reached the size and
		# complexity where it is getting to be a good idea to
		# add new tests to a new section rather than
		# continuing to piggyback them onto the tests here.

a706 2
### XXX maybe should use 'cvs imprt -b1 -m new-module first-dir F F1' in an
### empty directory to do this instead of hacking directly into $CVSROOT
d710 1
a710 1
			if test ! -d $i ; then
d751 1
a751 2
# XXX why is this commented out???
#		if ${CVS} diff -u first-dir   >> ${LOGFILE} || test $? = 1 ; then
d803 1
a803 1
		# FIXME: doesn't work right for added files
d816 1
a816 2
# XXX why is this commented out?
#		if ${CVS} diff -u first-dir  >> ${LOGFILE} || test $? = 1 ; then
d842 1
a842 1
		if test -d first-dir ; then
d872 1
a872 1
		if ${CVS} rdiff -r1.1 -rrtagged-by-head first-dir  >> ${LOGFILE} || test $? = 1 ; then
d920 1
a920 1
		if $ISDIFF ; then
d926 1
a926 2
		# interrupt, while we've got a clean 1.1 here, let's import it
		# into a couple of other modules.
d942 1
a959 1

d1023 38
a1060 38
'O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir           =first-dir= '"${TMPPWD}"'/cvs-sanity/\*
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir           == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir           == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1      == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1      == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1/dir2 == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1/dir2 == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir           == '"${TMPPWD}"'/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1      == '"${TMPPWD}"'/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1      == '"${TMPPWD}"'/cvs-sanity
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1/dir2 == '"${TMPPWD}"'/cvs-sanity
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1/dir2 == '"${TMPPWD}"'/cvs-sanity
F [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]*                     =first-dir= '"${TMPPWD}"'/cvs-sanity/\*
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* \[1\.1\] first-dir           =first-dir= '"${TMPPWD}"'/cvs-sanity/\*
U [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == '"${TMPPWD}"'/cvs-sanity/first-dir
U [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file7     first-dir           == '"${TMPPWD}"'/cvs-sanity/first-dir' \
'O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir           =first-dir= <remote>/\*
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir           == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1      == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1/dir2 == <remote>
M [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1/dir2 == <remote>
F [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]*                     =first-dir= <remote>/\*
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* '"${PLUS}"'0000 [a-z0-9@@][a-z0-9@@]* \[1\.1\] first-dir           =first-dir= <remote>/\*'
d1066 1
a1066 139
	rdiff)
		# Test rdiff
		# XXX for now this is just the most essential test...
		cd ${TESTDIR}

		mkdir testimport
		cd testimport
		echo '$''Id$' > foo
		echo '$''Name$' >> foo
		echo '$''Id$' > bar
		echo '$''Name$' >> bar
		dotest rdiff-1 \
		  "${testcvs} import -I ! -m test-import-with-keyword trdiff TRDIFF T1" \
'N trdiff/foo
N trdiff/bar

No conflicts created by this import'
		dotest rdiff-2 \
		  "${testcvs} co -ko trdiff" \
'cvs [a-z]*: Updating trdiff
U trdiff/bar
U trdiff/foo'
		cd trdiff
		echo something >> foo
		dotest rdiff-3 \
		  "${testcvs} ci -m added-something foo" \
'Checking in foo;
/tmp/cvs-sanity/cvsroot/trdiff/foo,v  <--  foo
new revision: 1\.2; previous revision: 1\.1
done'
		echo '#ident	"@@(#)trdiff:$''Name$:$''Id$"' > new
		echo "new file" >> new
		dotest rdiff-4 \
		  "${testcvs} add -m new-file-description new" \
"cvs [a-z]*: scheduling file \`new' for addition
cvs [a-z]*: use 'cvs commit' to add this file permanently"
		dotest rdiff-5 \
		  "${testcvs} commit -m added-new-file new" \
'RCS file: /tmp/cvs-sanity/cvsroot/trdiff/new,v
done
Checking in new;
/tmp/cvs-sanity/cvsroot/trdiff/new,v  <--  new
initial revision: 1\.1
done'
		dotest rdiff-6 \
		  "${testcvs} tag local-v0" \
'cvs [a-z]*: Tagging .
T bar
T foo
T new'
		dotest rdiff-7 \
		  "${testcvs} status -v foo" \
'===================================================================
File: foo              	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	/tmp/cvs-sanity/cvsroot/trdiff/foo,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-ko

   Existing Tags:
	local-v0                 	(revision: 1\.2)
	T1                       	(revision: 1\.1\.1\.1)
	TRDIFF                   	(branch: 1\.1\.1)'

		cd ..
		rm -rf trdiff

		dotest rdiff-8 \
		  "${testcvs} rdiff -r T1 -r local-v0 trdiff" \
'cvs [a-z]*: Diffing trdiff
Index: trdiff/foo
diff -c trdiff/foo:1\.1\.1\.1 trdiff/foo:1\.2
\*\*\* trdiff/foo:1\.1\.1\.1	.*
--- trdiff/foo	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,2 \*\*\*\*
! \$''Id\$
! \$''Name\$
--- 1,3 ----
! \$''Id: foo,v 1\.2 [0-9/]* [0-9:]* [a-zA-Z0-9][a-zA-Z0-9]* Exp \$
! \$''Name: local-v0 \$
! something
Index: trdiff/new
diff -c /dev/null trdiff/new:1\.1
\*\*\* /dev/null	.*
--- trdiff/new	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1,2 ----
'"${PLUS}"' #ident	"@@(#)trdiff:\$''Name: local-v0 \$:\$''Id: new,v 1\.1 [0-9/]* [0-9:]* [a-zA-Z0-9][a-zA-Z0-9]* Exp \$"
'"${PLUS}"' new file'

		# This appears to be broken client/server
		if test "x$remote" = xno; then
		dotest rdiff-9 \
		  "${testcvs} rdiff -Ko -kv -r T1 -r local-v0 trdiff" \
'cvs [a-z]*: Diffing trdiff
Index: trdiff/foo
diff -c trdiff/foo:1\.1\.1\.1 trdiff/foo:1\.2
\*\*\* trdiff/foo:1\.1\.1\.1	.*
--- trdiff/foo	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,2 \*\*\*\*
! \$''Id\$
! \$''Name\$
--- 1,3 ----
! foo,v 1\.2 .* Exp
! local-v0
! something
Index: trdiff/new
diff -c /dev/null trdiff/new:1\.1
\*\*\* /dev/null	.*
--- trdiff/new	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1,2 ----
'"${PLUS}"' #ident	"@@(#)trdiff:local-v0:new,v 1\.1 .* Exp"
'"${PLUS}"' new file'
		fi # end tests we are skipping for client/server

# FIXME: will this work here?
#		if test "$keep" = yes; then
#		  echo Keeping /tmp/cvs-sanity and exiting due to --keep
#		  exit 0
#		fi

		rm -rf ${CVSROOT_DIRNAME}/trdiff
		;;

	death)
		# next dive.  test death support.

		# NOTE: this section has reached the size and
		# complexity where it is getting to be a good idea to
		# add new death support tests to a new section rather
		# than continuing to piggyback them onto the tests here.

d1091 1
a1091 1
initial revision: 1\.1
d1100 1
a1100 1
new revision: delete; previous revision: 1\.1
d1177 1
a1177 1
initial revision: 1\.1
d1186 1
a1186 1
new revision: delete; previous revision: 1\.1
a1188 4
		# Tag the branchpoint.
		dotest death-72a "${testcvs} -q tag bp_branch1" 'T file1
T file2'

a1219 25
		# Remote CVS outputs nothing for 76a0 and 76a1; until
		# this bug is fixed just skip those tests for remote.
		if test "x$remote" = xno; then
		  dotest death-76a0 \
"${testcvs} -q rdiff -r bp_branch1 -r branch1 first-dir" \
"Index: first-dir/file3
diff -c /dev/null first-dir/file3:1\.1\.2\.1
\*\*\* /dev/null	.*
--- first-dir/file3	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} line1 from branch1"
		  dotest death-76a1 \
"${testcvs} -q rdiff -r branch1 -r bp_branch1 first-dir" \
'Index: first-dir/file3
diff -c first-dir/file3:1\.1\.2\.1 first-dir/file3:removed
\*\*\* first-dir/file3:1\.1\.2\.1	.*
--- first-dir/file3	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- line1 from branch1
--- 0 ----'
		fi

d1284 1
a1284 1
		if test -f file3 ; then
d1291 5
a1295 7
		dotest 86 "${testcvs} -q update -j branch1" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
retrieving revision 1\.3
retrieving revision 1\.3\.2\.1
Merging differences between 1\.3 and 1\.3\.2\.1 into file1
'"${PROG}"' [a-z]*: scheduling file2 for removal
U file3'
d1299 1
a1299 1
		if test -f file3 ; then
d1321 5
a1325 21
		dotest 89 "${testcvs} -q ci -m test" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done
Removing file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
new revision: delete; previous revision: 1\.1
done
Checking in file3;
/tmp/cvs-sanity/cvsroot/first-dir/file3,v  <--  file3
new revision: 1\.2; previous revision: 1\.1
done'
		cd ..
		mkdir 2
		cd 2
		dotest 89a "${testcvs} -q co first-dir" 'U first-dir/file1
U first-dir/file3'
		cd ..
		rm -rf 2
		cd first-dir
d1342 1
a1342 1
		if test -f file1 ; then
d1357 1
a1357 1
		if test -f file3 ; then
d1372 1
a1372 1
		if test -f file1 ; then
d1379 5
a1383 3
		dotest 95 "${testcvs} -q update -j HEAD" \
"${PROG}"' [a-z]*: file file1 has been modified, but has been removed in revision HEAD
'"${PROG}"' [a-z]*: file file3 exists, but has been added in revision HEAD'
a1386 7
		# file2 should not have been recreated.  It was
		# deleted on the branch, and has not been modified on
		# the trunk.  That means that there have been no
		# changes between the greatest common ancestor (the
		# trunk version) and HEAD.
		dotest_fail death-file2-1 "test -f file2" ''

d1389 2
a1390 3

	death2)
	  # More tests of death support.
d1392 1
a1392 2
	  dotest death2-1 "${testcvs} -q co first-dir" ''

d1394 5
a1398 4

	  # Add a file on the trunk.
	  echo "first revision" > file1
	  dotest death2-2 "${testcvs} add file1" \
d1400 5
a1404 3
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'

	  dotest death2-3 "${testcvs} -q commit -m add" \
d1409 3
a1411 256
initial revision: 1\.1
done'

	  # Make a branch and a non-branch tag.
	  dotest death2-4 "${testcvs} -q tag -b branch" 'T file1'
	  dotest death2-5 "${testcvs} -q tag tag" 'T file1'

	  # Switch over to the branch.
	  dotest death2-6 "${testcvs} -q update -r branch" ''

	  # Delete the file on the branch.
	  rm file1
	  dotest death2-7 "${testcvs} rm file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest death2-8 "${testcvs} -q ci -m removed" \
'Removing file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1\.2
done'

	  # Test diff of a dead file.
	  dotest_fail death2-diff-1 \
"${testcvs} -q diff -r1.1 -rbranch -c file1" \
"${PROG} [a-z]*: file1 was removed, no comparison available"

	  dotest_fail death2-diff-2 \
"${testcvs} -q diff -r1.1 -rbranch -N -c file1" \
"Index: file1
===================================================================
RCS file: file1
diff -N file1
\*\*\* [a-zA-Z0-9/.]*[ 	][	]*[a-zA-Z0-9: ]*
--- /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- first revision
--- 0 ----"

	  dotest_fail death2-diff-3 "${testcvs} -q diff -rtag -c ." \
"${PROG} [a-z]*: file1 no longer exists, no comparison available"

	  dotest_fail death2-diff-4 "${testcvs} -q diff -rtag -N -c ." \
"Index: file1
===================================================================
RCS file: file1
diff -N file1
\*\*\* [a-zA-Z0-9/.]*[ 	][	]*[a-zA-Z0-9: ]*
--- /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- first revision
--- 0 ----"

	  # Test rdiff of a dead file.
	  dotest death2-rdiff-1 \
"${testcvs} -q rtag -rbranch rdiff-tag first-dir" ''

	  dotest death2-rdiff-2 "${testcvs} -q rdiff -rtag -rbranch first-dir" \
"Index: first-dir/file1
diff -c first-dir/file1:1\.1 first-dir/file1:removed
\*\*\* first-dir/file1:1\.1[ 	][	]*[a-zA-Z0-9: ]*
--- first-dir/file1[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- first revision
--- 0 ----"

	  # Readd the file to the branch.
	  echo "second revision" > file1
	  dotest death2-9 "${testcvs} add file1" \
"${PROG}"' [a-z]*: file `file1'\'' will be added on branch `branch'\'' from version 1\.1\.2\.1
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest death2-10 "${testcvs} -q commit -m add" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.2; previous revision: 1\.1\.2\.1
done'

	  # Back to the trunk.
	  dotest death2-11 "${testcvs} -q update -A" 'U file1' 'P file1'

	  # Add another file on the trunk.
	  echo "first revision" > file2
	  dotest death2-12 "${testcvs} add file2" \
"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest death2-13 "${testcvs} -q commit -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done'

	  # Back to the branch.
	  # The ``no longer in the repository'' message doesn't really
	  # look right to me, but that's what CVS currently prints for
	  # this case.
	  dotest death2-14 "${testcvs} -q update -r branch" \
"U file1
${PROG} [a-z]*: file2 is no longer in the repository" \
"P file1
${PROG} [a-z]*: file2 is no longer in the repository"

	  # Add a file on the branch with the same name.
	  echo "branch revision" > file2
	  dotest death2-15 "${testcvs} add file2" \
"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition on branch `branch'\''
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest death2-16 "${testcvs} -q commit -m add" \
'Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done'

	  # Add a new file on the branch.
	  echo "first revision" > file3
	  dotest death2-17 "${testcvs} add file3" \
"${PROG}"' [a-z]*: scheduling file `file3'\'' for addition on branch `branch'\''
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest death2-18 "${testcvs} -q commit -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/Attic/file3,v
done
Checking in file3;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file3,v  <--  file3
new revision: 1\.1\.2\.1; previous revision: 1\.1
done'

	  # Test diff of a nonexistent tag
	  dotest_fail death2-diff-5 "${testcvs} -q diff -rtag -c file3" \
"${PROG} [a-z]*: tag tag is not in file file3"

	  dotest_fail death2-diff-6 "${testcvs} -q diff -rtag -N -c file3" \
"Index: file3
===================================================================
RCS file: file3
diff -N file3
\*\*\* /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
--- [a-zA-Z0-9/.]*[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} first revision"

	  dotest_fail death2-diff-7 "${testcvs} -q diff -rtag -c ." \
"Index: file1
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.2
diff -c -r1\.1 -r1\.1\.2\.2
\*\*\* file1[ 	][ 	]*[a-zA-Z0-9:./ 	]*
--- file1[ 	][ 	]*[a-zA-Z0-9:./ 	]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
! first revision
--- 1 ----
! second revision
${PROG} [a-z]*: tag tag is not in file file2
${PROG} [a-z]*: tag tag is not in file file3"

	  dotest_fail death2-diff-8 "${testcvs} -q diff -rtag -c -N ." \
"Index: file1
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.2
diff -c -r1\.1 -r1\.1\.2\.2
\*\*\* file1[ 	][ 	]*[a-zA-Z0-9:./ 	]*
--- file1[ 	][ 	]*[a-zA-Z0-9:./ 	]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
! first revision
--- 1 ----
! second revision
Index: file2
===================================================================
RCS file: file2
diff -N file2
\*\*\* /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
--- [a-zA-Z0-9/.]*[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} branch revision
Index: file3
===================================================================
RCS file: file3
diff -N file3
\*\*\* /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
--- [a-zA-Z0-9/.]*[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} first revision"

	  # Switch to the nonbranch tag.
	  dotest death2-19 "${testcvs} -q update -r tag" \
"U file1
${PROG} [a-z]*: file2 is no longer in the repository
${PROG} [a-z]*: file3 is no longer in the repository" \
"P file1
${PROG} [a-z]*: file2 is no longer in the repository
${PROG} [a-z]*: file3 is no longer in the repository"

	  dotest_fail death2-20 "test -f file2"

	  # Make sure we can't add a file on this nonbranch tag.
	  # FIXME: Right now CVS will let you add a file on a
	  # nonbranch tag, so this test is commented out.
	  # echo "bad revision" > file2
	  # dotest death2-21 "${testcvs} add file2" "some error message"

	  # Make sure diff only reports appropriate files.
	  dotest_fail death2-diff-9 "${testcvs} -q diff -r rdiff-tag" \
"${PROG} [a-z]*: file1 is a new entry, no comparison available"

	  dotest_fail death2-diff-10 "${testcvs} -q diff -r rdiff-tag -c -N" \
"Index: file1
===================================================================
RCS file: file1
diff -N file1
\*\*\* /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
--- [a-zA-Z0-9/.]*[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} first revision"

	  cd .. ; rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
	  ;;

	branches)
	  # More branch tests, including branches off of branches
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest branches-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 1:ancest >file1
	  echo 2:ancest >file2
	  echo 3:ancest >file3
	  echo 4:trunk-1 >file4
	  dotest branches-2 "${testcvs} add file1 file2 file3 file4" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file3'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file4'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'
	  dotest_lit branches-3 "${testcvs} -q ci -m add-it" <<'HERE'
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
d1428 1
a1428 2
done
HERE
d1433 1
a1433 1
new revision: 1\.2; previous revision: 1\.1
d1448 1
a1448 1
new revision: 1\.1\.2\.1; previous revision: 1\.1
d1452 1
a1452 1
new revision: 1\.1\.2\.1; previous revision: 1\.1
d1456 1
a1456 1
new revision: 1\.2\.2\.1; previous revision: 1\.2
d1468 1
a1468 1
new revision: 1\.1\.2\.1\.2\.1; previous revision: 1\.1\.2\.1
d1472 1
a1472 1
new revision: 1\.2\.2\.1\.2\.1; previous revision: 1\.2\.2\.1
d1489 1
a1489 1
new revision: 1\.2\.2\.2; previous revision: 1\.2\.2\.1
d1503 1
a1503 1
new revision: 1\.3; previous revision: 1\.2
d1521 1
a1521 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
d1525 1
a1525 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
d1530 1
a1530 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;
d1534 1
a1534 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
d1538 1
a1538 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
d1543 1
a1543 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: '"${PLUS}"'1 -1
d1579 3
a1581 3
retrieving revision 1\.1\.2\.1
retrieving revision 1\.1\.2\.1\.2\.1
Merging differences between 1\.1\.2\.1 and 1\.1\.2\.1\.2\.1 into file1
d1587 1
a1587 84
[>]>>>>>> 1\.1\.2\.1\.2\.1'
	  cd ..

	  if test "$keep" = yes; then
	    echo Keeping /tmp/cvs-sanity and exiting due to --keep
	    exit 0
	  fi

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r first-dir
	  ;;

	multibranch)
	  # Test the ability to have several branchpoints coming off the
	  # same revision.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest multibranch-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 1:trunk-1 >file1
	  dotest multibranch-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest_lit multibranch-3 "${testcvs} -q ci -m add-it" <<'HERE'
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1.1
done
HERE
	  dotest multibranch-4 "${testcvs} tag -b br1" \
"${PROG} [a-z]*: Tagging \.
T file1"
	  dotest multibranch-5 "${testcvs} tag -b br2" \
"${PROG} [a-z]*: Tagging \.
T file1"
	  dotest multibranch-6 "${testcvs} -q update -r br1" ''
	  echo on-br1 >file1
	  dotest multibranch-7 "${testcvs} -q ci -m modify-on-br1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done'
	  dotest multibranch-8 "${testcvs} -q update -r br2" '[UP] file1'
	  echo br2 adds a line >>file1
	  dotest multibranch-9 "${testcvs} -q ci -m modify-on-br2" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done'
	  dotest multibranch-10 "${testcvs} -q update -r br1" '[UP] file1'
	  dotest multibranch-11 "cat file1" 'on-br1'
	  dotest multibranch-12 "${testcvs} -q update -r br2" '[UP] file1'
	  dotest multibranch-13 "cat file1" '1:trunk-1
br2 adds a line'

	  dotest multibranch-14 "${testcvs} log file1" \
"
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	br2: 1\.1\.0\.4
	br1: 1\.1\.0\.2
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: [0-9a-zA-Z-]*;  state: Exp;
branches:  1\.1\.2;  1\.1\.4;
add-it
----------------------------
revision 1\.1\.4\.1
date: [0-9/]* [0-9:]*;  author: [0-9a-zA-Z-]*;  state: Exp;  lines: ${PLUS}1 -0
modify-on-br2
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: [0-9a-zA-Z-]*;  state: Exp;  lines: ${PLUS}1 -1
modify-on-br1
============================================================================="
d1637 1
a1637 1
			if test -f imported-file"$i" ; then
d1658 3
d1735 1
a1735 1
		if test -f imported-file1 ; then
d1742 1
a1742 1
			if test -f imported-file"$i" ; then
d1756 1
a1756 1
		if test -f imported-file4 ; then
d1771 5
a1775 8
		dotest import-113 \
"${testcvs} -q co -jjunk-1_0 -jjunk-2_0 first-dir" \
"${PROG}"' [a-z]*: file first-dir/imported-file1 is present in revision junk-2_0
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/imported-file2,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.2
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.2 into imported-file2
rcsmerge: warning: conflicts during merge'
d1779 1
a1779 1
		if test -f imported-file1 ; then
d1786 1
a1786 1
			if test -f imported-file"$i" ; then
d1793 5
a1797 10
		dotest import-116 'cat imported-file2' \
'imported file2
[<]<<<<<< imported-file2
import should not expand \$''Id: imported-file2,v 1\.2 [0-9/]* [0-9:]* [a-z0-9@@][a-z0-9@@]* Exp \$
local-change
[=]======
import should not expand \$''Id: imported-file2,v 1\.1\.1\.2 [0-9/]* [0-9:]* [a-z0-9@@][a-z0-9@@]* Exp \$
rev 2 of file 2
[>]>>>>>> 1\.1\.1\.2'

a1801 340
	join)
	  # Test doing joins which involve adding and removing files.

	  # We check merging changes from T1 to T2 into the main line.
	  # Here are the interesting cases I can think of:
	  #   1) File added between T1 and T2, not on main line.
	  #      File should be marked for addition.
	  #   2) File added between T1 and T2, also added on main line.
	  #      Conflict.
	  #   3) File removed between T1 and T2, unchanged on main line.
	  #      File should be marked for removal.
	  #   4) File removed between T1 and T2, modified on main line.
	  #      If mod checked in, file should be marked for removal.
	  #	 If mod still in working directory, conflict.
	  #   5) File removed between T1 and T2, was never on main line.
	  #      Nothing should happen.
	  #   6) File removed between T1 and T2, also removed on main line.
	  #      Nothing should happen.
	  #   7) File added on main line, not added between T1 and T2.
	  #      Nothing should happen.
	  #   8) File removed on main line, not modified between T1 and T2.
	  #      Nothing should happen.

	  # We also check merging changes from a branch into the main
	  # line.  Here are the interesting cases:
	  #   1) File added on branch, not on main line.
	  #      File should be marked for addition.
	  #   2) File added on branch, also added on main line.
	  #      Conflict.
	  #   3) File removed on branch, unchanged on main line.
	  #      File should be marked for removal.
	  #   4) File removed on branch, modified on main line.
	  #      Conflict.
	  #   5) File removed on branch, was never on main line.
	  #      Nothing should happen.
	  #   6) File removed on branch, also removed on main line.
	  #      Nothing should happen.
	  #   7) File added on main line, not added on branch.
	  #      Nothing should happen.
	  #   8) File removed on main line, not modified on branch.
	  #      Nothing should happen.

	  # In the tests below, fileN represents case N in the above
	  # lists.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest join-1 "${testcvs} -q co first-dir" ''

	  cd first-dir

	  # Add two files.
	  echo 'first revision of file3' > file3
	  echo 'first revision of file4' > file4
	  echo 'first revision of file6' > file6
	  echo 'first revision of file8' > file8
	  dotest join-2 "${testcvs} add file3 file4 file6 file8" \
"${PROG}"' [a-z]*: scheduling file `file3'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file4'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file6'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file8'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'

	  dotest join-3 "${testcvs} -q commit -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file3,v
done
Checking in file3;
/tmp/cvs-sanity/cvsroot/first-dir/file3,v  <--  file3
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file4,v
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file6,v
done
Checking in file6;
/tmp/cvs-sanity/cvsroot/first-dir/file6,v  <--  file6
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file8,v
done
Checking in file8;
/tmp/cvs-sanity/cvsroot/first-dir/file8,v  <--  file8
initial revision: 1\.1
done'

	  # Make a branch.
	  dotest join-4 "${testcvs} -q tag -b branch ." \
'T file3
T file4
T file6
T file8'

	  # Add file2 and file7, modify file4, and remove file6 and file8.
	  echo 'first revision of file2' > file2
	  echo 'second revision of file4' > file4
	  echo 'first revision of file7' > file7
	  rm file6 file8
	  dotest join-5 "${testcvs} add file2 file7" \
"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file7'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'
	  dotest join-6 "${testcvs} rm file6 file8" \
"${PROG}"' [a-z]*: scheduling `file6'\'' for removal
'"${PROG}"' [a-z]*: scheduling `file8'\'' for removal
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to remove these files permanently'
	  dotest join-7 "${testcvs} -q ci -mx ." \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1\.2; previous revision: 1\.1
done
Removing file6;
/tmp/cvs-sanity/cvsroot/first-dir/file6,v  <--  file6
new revision: delete; previous revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file7,v
done
Checking in file7;
/tmp/cvs-sanity/cvsroot/first-dir/file7,v  <--  file7
initial revision: 1\.1
done
Removing file8;
/tmp/cvs-sanity/cvsroot/first-dir/file8,v  <--  file8
new revision: delete; previous revision: 1\.1
done'

	  # Check out the branch.
	  cd ../..
	  mkdir 2
	  cd 2
	  dotest join-8 "${testcvs} -q co -r branch first-dir" \
'U first-dir/file3
U first-dir/file4
U first-dir/file6
U first-dir/file8'

	  cd first-dir

	  # Modify the files on the branch, so that T1 is not an
	  # ancestor of the main line, and add file5
	  echo 'first branch revision of file3' > file3
	  echo 'first branch revision of file4' > file4
	  echo 'first branch revision of file6' > file6
	  echo 'first branch revision of file5' > file5
	  dotest join-9 "${testcvs} add file5" \
"${PROG}"' [a-z]*: scheduling file `file5'\'' for addition on branch `branch'\''
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest join-10 "${testcvs} -q ci -mx ." \
'Checking in file3;
/tmp/cvs-sanity/cvsroot/first-dir/file3,v  <--  file3
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/Attic/file5,v
done
Checking in file5;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file5,v  <--  file5
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in file6;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file6,v  <--  file6
new revision: 1\.1\.2\.1; previous revision: 1\.1
done'

	  # Tag the current revisions on the branch.
	  dotest join-11 "${testcvs} -q tag T1 ." \
'T file3
T file4
T file5
T file6
T file8'

	  # Add file1 and file2, and remove the other files.
	  echo 'first branch revision of file1' > file1
	  echo 'first branch revision of file2' > file2
	  rm file3 file4 file5 file6
	  dotest join-12 "${testcvs} add file1 file2" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition on branch `branch'\''
'"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition on branch `branch'\''
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'
	  dotest join-13 "${testcvs} rm file3 file4 file5 file6" \
"${PROG}"' [a-z]*: scheduling `file3'\'' for removal
'"${PROG}"' [a-z]*: scheduling `file4'\'' for removal
'"${PROG}"' [a-z]*: scheduling `file5'\'' for removal
'"${PROG}"' [a-z]*: scheduling `file6'\'' for removal
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to remove these files permanently'
	  dotest join-14 "${testcvs} -q ci -mx ." \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Removing file3;
/tmp/cvs-sanity/cvsroot/first-dir/file3,v  <--  file3
new revision: delete; previous revision: 1\.1\.2\.1
done
Removing file4;
/tmp/cvs-sanity/cvsroot/first-dir/file4,v  <--  file4
new revision: delete; previous revision: 1\.1\.2\.1
done
Removing file5;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file5,v  <--  file5
new revision: delete; previous revision: 1\.1\.2\.1
done
Removing file6;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/file6,v  <--  file6
new revision: delete; previous revision: 1\.1\.2\.1
done'

	  # Tag the current revisions on the branch.
	  dotest join-15 "${testcvs} -q tag T2 ." \
'T file1
T file2
T file8'

	  # Do a checkout with a merge.
	  cd ../..
	  mkdir 3
	  cd 3
	  dotest join-16 "${testcvs} -q co -jT1 -jT2 first-dir" \
'U first-dir/file1
U first-dir/file2
'"${PROG}"' [a-z]*: file first-dir/file2 exists, but has been added in revision T2
U first-dir/file3
'"${PROG}"' [a-z]*: scheduling first-dir/file3 for removal
U first-dir/file4
'"${PROG}"' [a-z]*: scheduling first-dir/file4 for removal
U first-dir/file7'

	  # Verify that the right changes have been scheduled.
	  cd first-dir
	  dotest join-17 "${testcvs} -q update" \
'A file1
R file3
R file4'

	  # Modify file4 locally, and do an update with a merge.
	  cd ../../1/first-dir
	  echo 'third revision of file4' > file4
	  dotest join-18 "${testcvs} -q update -jT1 -jT2 ." \
'U file1
'"${PROG}"' [a-z]*: file file2 exists, but has been added in revision T2
'"${PROG}"' [a-z]*: scheduling file3 for removal
M file4
'"${PROG}"' [a-z]*: file file4 is locally modified, but has been removed in revision T2'

	  # Verify that the right changes have been scheduled.
	  dotest join-19 "${testcvs} -q update" \
'A file1
R file3
M file4'

	  # Do a checkout with a merge from a single revision.

	  # FIXME: CVS currently gets this wrong.  file2 has been
	  # added on both the branch and the main line, and so should
	  # be regarded as a conflict.  However, given the way that
	  # CVS sets up the RCS file, there is no way to distinguish
	  # this case from the case of file2 having existed before the
	  # branch was made.  This could be fixed by reserving
	  # a revision somewhere, perhaps 1.1, as an always dead
	  # revision which can be used as the source for files added
	  # on branches.
	  cd ../../3
	  rm -rf first-dir
	  dotest join-20 "${testcvs} -q co -jbranch first-dir" \
'U first-dir/file1
U first-dir/file2
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file2
U first-dir/file3
'"${PROG}"' [a-z]*: scheduling first-dir/file3 for removal
U first-dir/file4
'"${PROG}"' [a-z]*: file first-dir/file4 has been modified, but has been removed in revision branch
U first-dir/file7'

	  # Verify that the right changes have been scheduled.
	  # The M file2 line is a bug; see above join-20.
	  cd first-dir
	  dotest join-21 "${testcvs} -q update" \
'A file1
M file2
R file3'

	  # Checkout the main line again.
	  cd ../../1
	  rm -rf first-dir
	  dotest join-22 "${testcvs} -q co first-dir" \
'U first-dir/file2
U first-dir/file3
U first-dir/file4
U first-dir/file7'

	  # Modify file4 locally, and do an update with a merge from a
	  # single revision.
	  # The file2 handling is a bug; see above join-20.
	  cd first-dir
	  echo 'third revision of file4' > file4
	  dotest join-23 "${testcvs} -q update -jbranch ." \
'U file1
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file2
'"${PROG}"' [a-z]*: scheduling file3 for removal
M file4
'"${PROG}"' [a-z]*: file file4 is locally modified, but has been removed in revision branch'

	  # Verify that the right changes have been scheduled.
	  # The M file2 line is a bug; see above join-20
	  dotest join-24 "${testcvs} -q update" \
'A file1
M file2
R file3
M file4'

	  cd ../..
	  rm -rf 1 2 3 ${CVSROOT_DIRNAME}/first-dir
	  ;;

a1854 85
	newb)
	  # Test removing a file on a branch and then checking it out.

	  # We call this "newb" only because it, like the "new" tests,
	  # has something to do with "no longer pertinent" messages.
	  # Not necessarily the most brilliant nomenclature.

	  # Create file 'a'.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest newb-123a "${testcvs} -q co first-dir" ''
	  cd first-dir
	  touch a
	  dotest newb-123b "${testcvs} add a" \
"${PROG} [a-z]*: scheduling file .a. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest newb-123c "${testcvs} -q ci -m added" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/a,v
done
Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
initial revision: 1\.1
done'

	  # Make a branch.
	  dotest newb-123d "${testcvs} -q tag -b branch" "T a"

	  # Check out the branch.
	  cd ..
	  rm -rf first-dir
	  mkdir 1
	  cd 1
	  dotest newb-123e "${testcvs} -q co -r branch first-dir" \
"U first-dir/a"

	  # Remove 'a' on another copy of the branch.
	  cd ..
	  mkdir 2
	  cd 2
	  dotest newb-123f "${testcvs} -q co -r branch first-dir" \
"U first-dir/a"
	  cd first-dir
	  rm a
	  dotest newb-123g "${testcvs} rm a" \
"${PROG} [a-z]*: scheduling .a. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest newb-123h "${testcvs} -q ci -m removed" \
'Removing a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
new revision: delete; previous revision: 1\.1\.2
done'

	  # Check out the file on the branch.  This should report
	  # that the file is not pertinent, but it should not
	  # say anything else.
	  cd ..
	  rm -rf first-dir
	  dotest newb-123i "${testcvs} -q co -r branch first-dir/a" \
"${PROG} [a-z]*: warning: first-dir/a is not (any longer) pertinent"

	  # Update the other copy, and make sure that a is removed.
	  cd ../1/first-dir
	  # "Needs Patch" is a rather strange output here.  Something like
	  # "Removed in Repository" would make more sense.
	  dotest newb-123j0 "${testcvs} status a" \
"===================================================================
File: a                	Status: Needs Patch

   Working revision:	1\.1.*
   Repository revision:	1\.1\.2\.1	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		branch (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest newb-123j "${testcvs} -q update" \
"${PROG} [a-z]*: warning: a is not (any longer) pertinent"

	  if test -f a; then
	    fail newb-123k
	  else
	    pass newb-123k
	  fi

	  cd ../..
	  rm -rf 1 2 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d1856 1
d1862 5
a1866 1
		dotest conflicts-124 "${testcvs} -q co first-dir" ''
d1871 11
a1881 10
		dotest conflicts-125 "${testcvs} add a" \
"${PROG} [a-z]*: scheduling file .a. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
		dotest conflicts-126 "${testcvs} -q ci -m added" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/a,v
done
Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
initial revision: 1\.1
done'
a1886 12
		# TODO-maybe: we could also check this (also in an empty
		# directory) after the file has nonempty contents.
		#
		# The need for TMPPWD here is a (minor) CVS bug; the
		# output should use the name of the repository as specified.
		dotest conflicts-126.5 "${testcvs} co -p first-dir" \
"${PROG} [a-z]*"': Updating first-dir
===================================================================
Checking out first-dir/a
RCS:  '"${TMPPWD}"'/cvs-sanity/cvsroot/first-dir/a,v
VERS: 1\.1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*'
d1907 1
a1907 1
new revision: 1\.2; previous revision: 1\.1
d1918 3
a1920 3
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into a
d1929 3
a1931 3
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into a
a1934 1
		rmdir dir1 sdir
a1974 1
		mkdir first-dir/dir1 first-dir/sdir
d2027 2
a2028 1
		cd ../..
a2030 121

	conflicts2)
	  # More conflicts tests; separate from conflicts to keep each
	  # test a manageable size.
	  mkdir ${CVSROOT_DIRNAME}/first-dir

	  mkdir 1
	  cd 1

	  dotest conflicts2-142a1 "${testcvs} -q co first-dir" ''

	  cd first-dir
	  touch a abc

	  dotest conflicts2-142a2 "${testcvs} add a abc" \
"${PROG} [a-z]*: scheduling file .a. for addition
${PROG} [a-z]*: scheduling file .abc. for addition
${PROG} [a-z]*: use .cvs commit. to add these files permanently"
	  dotest conflicts2-142a3 "${testcvs} -q ci -m added" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/a,v
done
Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/abc,v
done
Checking in abc;
/tmp/cvs-sanity/cvsroot/first-dir/abc,v  <--  abc
initial revision: 1\.1
done'

	  cd ../..
	  mkdir 2
	  cd 2

	  dotest conflicts2-142a4 "${testcvs} -q co first-dir" 'U first-dir/a
U first-dir/abc'
	  cd ..

	  # Now test that if one person modifies and commits a
	  # file and a second person removes it, it is a
	  # conflict
	  cd 1/first-dir
	  echo modify a >>a
	  dotest conflicts2-142b2 "${testcvs} -q ci -m modify-a" \
'Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
new revision: 1\.2; previous revision: 1\.1
done'
	  cd ../../2/first-dir
	  rm a
	  dotest conflicts2-142b3 "${testcvs} rm a" \
"${PROG} [a-z]*: scheduling .a. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest_fail conflicts2-142b4 "${testcvs} -q update" \
"${PROG} [a-z]*: conflict: removed a was modified by second party
C a"
	  # Resolve the conflict by deciding not to remove the file
	  # after all.
	  dotest conflicts2-142b5 "${testcvs} add a" "U a
${PROG} [a-z]*: a, version 1\.1, resurrected"
	  dotest conflicts2-142b6 "${testcvs} -q update" ''
	  cd ../..

	  # Now test that if one person removes a file and
	  # commits it, and a second person removes it, is it
	  # not a conflict.
	  cd 1/first-dir
	  rm abc
	  dotest conflicts2-142c0 "${testcvs} rm abc" \
"${PROG} [a-z]*: scheduling .abc. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest conflicts2-142c1 "${testcvs} -q ci -m remove-abc" \
'Removing abc;
/tmp/cvs-sanity/cvsroot/first-dir/abc,v  <--  abc
new revision: delete; previous revision: 1\.1
done'
	  cd ../../2/first-dir
	  rm abc
	  dotest conflicts2-142c2 "${testcvs} rm abc" \
"${PROG} [a-z]*: scheduling .abc. for removal
${PROG} [a-z]*: use .cvs commit. to remove this file permanently"
	  dotest conflicts2-142c3 "${testcvs} update" \
"${PROG} [a-z]*: Updating \."
	  cd ../..

	  # conflicts2-142d*: test that if one party adds a file, and another
	  # party has a file of the same name, cvs notices
	  cd 1/first-dir
	  touch aa.c
	  dotest conflicts2-142d0 "${testcvs} add aa.c" \
"${PROG} [a-z]*: scheduling file .aa\.c. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest conflicts2-142d1 "${testcvs} -q ci -m added" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/aa.c,v
done
Checking in aa.c;
/tmp/cvs-sanity/cvsroot/first-dir/aa.c,v  <--  aa.c
initial revision: 1\.1
done'
	  cd ../../2/first-dir
	  echo "don't you dare obliterate this text" >aa.c
	  # Doing this test separately for remote and local is a fair
	  # bit of a kludge, but the exit status differs.  I'm not sure
	  # which exit status is the more appropriate one.
	  if test "$remote" = yes; then
	    dotest conflicts2-142d2 "${testcvs} -q update" \
"${QUESTION} aa\.c
U aa\.c
${PROG} update: move away \./aa\.c; it is in the way"
	  else
	    dotest_fail conflicts2-142d2 "${testcvs} -q update" \
"${PROG} [a-z]*: move away aa\.c; it is in the way
C aa\.c"
	  fi
	  cd ../..

	  rm -rf 1 2 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a2092 2
	  echo topfiles -a first-dir/file1 first-dir/file2 >>CVSROOT/modules
	  echo world -a . >>CVSROOT/modules
d2112 1
a2112 3
realmodule   first-dir/subdir a
topfiles     -a first-dir/file1 first-dir/file2
world        -a .'
d2261 1
a2261 1
	  dotest modules-155a4 "ls" "first-dir"
a2264 49
	  # Test checking out everything.
	  mkdir 1
	  cd 1
	  dotest modules-155b "${testcvs} -q co world" \
"U CVSROOT/modules
U first-dir/subdir/a
U first-dir/subdir/b"
	  cd ..
	  rm -rf 1

	  # Test checking out a module which lists at least two
	  # specific files twice.  At one time, this failed over
	  # remote CVS.
	  mkdir 1
	  cd 1
	  dotest modules-155c1 "${testcvs} -q co first-dir" \
"U first-dir/subdir/a
U first-dir/subdir/b"

	  cd first-dir
	  echo 'first revision' > file1
	  echo 'first revision' > file2
	  dotest modules-155c2 "${testcvs} add file1 file2" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add these files permanently'
	  dotest modules-155c3 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file2,v
done
Checking in file2;
/tmp/cvs-sanity/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done'

	  cd ..
	  rm -rf first-dir
	  dotest modules-155c4 "${testcvs} -q co topfiles" \
"U first-dir/file1
U first-dir/file2"
	  dotest modules-155c5 "${testcvs} -q co topfiles" ""
	  cd ..
	  rm -rf 1

d2358 1
a2358 1
	  rm foo;
a2566 5
	  # Check tagging and checking out while we have a CVS
	  # directory in the repository.
	  dotest devcom-t0 "${testcvs} -q tag tag" \
'T abb
T abc'
d2568 1
a2568 14
	  mkdir 3
	  cd 3
	  dotest devcom-t1 "${testcvs} -q co -rtag first-dir/abb" \
'U first-dir/abb'

	  # Now remove all the file attributes
	  cd ../2/first-dir
	  dotest devcom-b0 "${testcvs} watch off" ''
	  dotest devcom-b1 "${testcvs} watch remove" ''
	  # Test that CVS 1.6 and earlier can handle the repository.
	  dotest_fail devcom-b2 "test -d ${CVSROOT_DIRNAME}/first-dir/CVS"

	  cd ../..
	  rm -rf 1 2 3 ${CVSROOT_DIRNAME}/first-dir
d2585 1
a2585 1
initial revision: 1\.1
d2641 1
a2653 21

	  # Now test that commands other than update also print "? notig.c"
	  # where appropriate.  Only test this for remote, because local
	  # CVS only prints it on update.
	  rm optig.c
	  if test "x$remote" = xyes; then
	    dotest 189e "${testcvs} -q diff" "${QUESTION} notig.c"

	    # Force the server to be contacted.  Ugh.  Having CVS
	    # contact the server for the sole purpose of checking
	    # the CVSROOT/cvsignore file does not seem like such a
	    # good idea, so I imagine this will continue to be
	    # necessary.  Oh well, at least we test CVS's ablity to
	    # handle a file with a modified timestamp but unmodified
	    # contents.
	    touch bar.c

	    dotest 189f "${testcvs} -q ci -m commit-it" "${QUESTION} notig.c"
	  fi

	  # now test .cvsignore files
d2655 1
a2655 27
	  echo notig.c >first-dir/.cvsignore
	  echo foobar.c >second-dir/.cvsignore
	  touch first-dir/notig.c second-dir/notig.c second-dir/foobar.c
	  dotest 190 "${testcvs} -qn update" \
"${QUESTION} first-dir/.cvsignore
${QUESTION} second-dir/.cvsignore
${QUESTION} second-dir/notig.c" \
"${QUESTION} first-dir/.cvsignore
${QUESTION} second-dir/notig.c
${QUESTION} second-dir/.cvsignore"
	  dotest 191 "${testcvs} -qn update -I!" \
"${QUESTION} first-dir/CVS
${QUESTION} first-dir/rootig.c
${QUESTION} first-dir/defig.o
${QUESTION} first-dir/envig.c
${QUESTION} first-dir/.cvsignore
${QUESTION} second-dir/CVS
${QUESTION} second-dir/.cvsignore
${QUESTION} second-dir/notig.c" \
"${QUESTION} first-dir/CVS
${QUESTION} first-dir/rootig.c
${QUESTION} first-dir/defig.o
${QUESTION} first-dir/envig.c
${QUESTION} first-dir/.cvsignore
${QUESTION} second-dir/CVS
${QUESTION} second-dir/notig.c
${QUESTION} second-dir/.cvsignore"
a2656 1
	  rm -rf first-dir second-dir
d2678 1
a2678 1
initial revision: 1\.1
a2696 22

	  # Test whether the default options from the RCS file are
	  # also used when operating on files instead of whole
	  # directories
          cd ../..
	  mkdir 3; cd 3
	  dotest binfiles-5.5b0 "${testcvs} -q co first-dir/binfile" \
'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-5.5b1 "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  cd ../..
	  rm -rf 3
	  cd 2/first-dir

d2701 1
a2701 1
new revision: 1\.2; previous revision: 1\.1
a2706 27
	  # Now test handling of conflicts with binary files.
	  cp ../binfile.dat binfile
	  dotest binfiles-con0 "${testcvs} -q ci -m modify-it" \
'Checking in binfile;
/tmp/cvs-sanity/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.3; previous revision: 1\.2
done'
	  cd ../../2/first-dir
	  echo 'edits in dir 2' >binfile
	  dotest binfiles-con1 "${testcvs} -q update" \
'U binfile
cvs [a-z]*: binary file needs merge
cvs [a-z]*: revision 1\.3 from repository is now in binfile
cvs [a-z]*: file from working directory is now in \.#binfile\.1\.2
C binfile'
	  dotest binfiles-con2 "cmp binfile ../../1/binfile.dat" ''
	  dotest binfiles-con3 "cat .#binfile.1.2" 'edits in dir 2'

	  cp ../../1/binfile2.dat binfile
	  dotest binfiles-con4 "${testcvs} -q ci -m resolve-it" \
'Checking in binfile;
/tmp/cvs-sanity/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.4; previous revision: 1\.3
done'
	  cd ../../1/first-dir
	  dotest binfiles-con5 "${testcvs} -q update" '[UP] binfile'

d2716 1
a2716 21
	  cd ../..
	  rm -rf 1

	  mkdir 3
	  cd 3
	  dotest binfiles-13a0 "${testcvs} -q co -r HEAD first-dir" \
'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-13a1 "${testcvs} status binfile" \
'===================================================================
File: binfile          	Status: Up-to-date

   Working revision:	1\.4.*
   Repository revision:	1\.4	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
   Sticky Tag:		HEAD (revision: 1\.4)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  cd ../..
	  rm -rf 3

	  cd 2/first-dir
d2721 1
a2721 1
new revision: 1\.5; previous revision: 1\.4
d2729 2
a2730 2
   Working revision:	1\.5.*
   Repository revision:	1\.5	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
d2746 2
a2747 2
   Working revision:	1\.5.*
   Repository revision:	1\.5	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
d2757 2
a2758 2
   Working revision:	1\.5.*
   Repository revision:	1\.5	/tmp/cvs-sanity/cvsroot/first-dir/binfile,v
a2762 24
	  # Do sticky options work when used with 'cvs update'?
	  echo "Not a binary file." > nibfile
	  dotest binfiles-sticky1 "${testcvs} -q add nibfile" \
	    'cvs [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest binfiles-sticky2 "${testcvs} -q ci -m add-it nibfile" \
	    'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/nibfile,v
done
Checking in nibfile;
/tmp/cvs-sanity/cvsroot/first-dir/nibfile,v  <--  nibfile
initial revision: 1\.1
done'
	  dotest binfiles-sticky3 "${testcvs} -q update -kb nibfile" \
	    '[UP] nibfile'
	  dotest binfiles-sticky4 "${testcvs} -q status nibfile" \
'===================================================================
File: nibfile          	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	/tmp/cvs-sanity/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  # Eventually we should test that -A removes the -kb here...

d2765 1
a2765 40
	  rm -r 2
	  ;;

	binwrap)
	  # Test the ability to specify binary-ness based on file name.
	  # We could also be testing the ability to use the other
	  # ways to specify a wrapper (CVSROOT/cvswrappers, etc.).

	  mkdir dir-to-import
	  cd dir-to-import
	  touch foo.c foo.exe
	  if ${testcvs} import -m message -I ! -W "*.exe -k 'b'" \
	      first-dir tag1 tag2 >>${LOGFILE}; then
	    pass binwrap-1
	  else
	    fail binwrap-1
	  fi
	  cd ..
	  rm -rf dir-to-import
	  dotest binwrap-2 "${testcvs} -q co first-dir" 'U first-dir/foo.c
U first-dir/foo.exe'
	  dotest binwrap-3 "${testcvs} -q status first-dir" \
'===================================================================
File: foo\.c            	Status: Up-to-date

   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	/tmp/cvs-sanity/cvsroot/first-dir/foo\.c,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: foo\.exe          	Status: Up-to-date

   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	/tmp/cvs-sanity/cvsroot/first-dir/foo\.exe,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb'
	  rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
a2766 1

d2780 1
a2780 1
initial revision: 1\.1
d2803 1
a2803 1
initial revision: 1\.1
d2810 1
a2810 1
new revision: 1\.2; previous revision: 1\.1
d2818 1
a2818 1
	  dotest info-9 "cat $TESTDIR/testlog" 'xenv-valueyz=[a-z0-9@@][a-z0-9@@]*=/tmp/cvs-sanity/cvsroot='
a2826 284

	serverpatch)
	  # Test remote CVS handling of unpatchable files.  This isn't
	  # much of a test for local CVS.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest serverpatch-1 "${testcvs} -q co first-dir" ''

	  cd first-dir

	  # Add a file with an RCS keyword.
	  echo '$''Name$' > file1
	  echo '1' >> file1
	  dotest serverpatch-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'

	  dotest serverpatch-3 "${testcvs} -q commit -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done'

	  # Tag the file.
	  dotest serverpatch-4 "${testcvs} -q tag tag file1" 'T file1'

	  # Check out a tagged copy of the file.
	  cd ../..
	  mkdir 2
	  cd 2
	  dotest serverpatch-5 "${testcvs} -q co -r tag first-dir" \
'U first-dir/file1'

	  # Remove the tag.  This will leave the tag string in the
	  # expansion of the Name keyword.
	  dotest serverpatch-6 "${testcvs} -q update -A" ''

	  # Modify and check in the first copy.
	  cd ../1/first-dir
	  echo '2' >> file1
	  dotest serverpatch-7 "${testcvs} -q ci -mx file1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done'

	  # Now update the second copy.  When using remote CVS, the
	  # patch will fail, forcing the file to be refetched.
	  cd ../../2/first-dir
	  dotest serverpatch-8 "${testcvs} -q update" \
'U file1' \
'P file1
'"${PROG}"' [a-z]*: checksum failure after patch to ./file1; will refetch
'"${PROG}"' [a-z]*: refetching unpatchable files
U file1'

	  cd ../..
	  rm -rf 1 2 ${CVSROOT_DIRNAME}/first-dir
	  ;;

	log)
	  # Test selecting revisions with cvs log.

	  # Check in a file with a few revisions and branches.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest log-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 'first revision' > file1
	  dotest log-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'

	  dotest log-3 "${testcvs} -q commit -m 1" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done'

	  echo 'second revision' > file1
	  dotest log-4 "${testcvs} -q ci -m2 file1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done'

	  dotest log-5 "${testcvs} -q tag -b branch file1" 'T file1'

	  echo 'third revision' > file1
	  dotest log-6 "${testcvs} -q ci -m3 file1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done'

	  dotest log-7 "${testcvs} -q update -r branch" '[UP] file1'

	  echo 'first branch revision' > file1
	  dotest log-8 "${testcvs} -q ci -m1b file1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done'

	  dotest log-9 "${testcvs} -q tag tag file1" 'T file1'

	  echo 'second branch revision' > file1
	  dotest log-10 "${testcvs} -q ci -m2b file1" \
'Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.2; previous revision: 1\.2\.2\.1
done'

	  # Set up a bunch of shell variables to make the later tests
	  # easier to describe.=
	  log_header='
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
branch:
locks: strict
access list:'
	  log_tags='symbolic names:
	tag: 1\.2\.2\.1
	branch: 1\.2\.0\.2'
	  log_header2='keyword substitution: kv'
	  log_dash='----------------------------
revision'
	  log_date='date: [0-9/]* [0-9:]*;  author: [a-zA-Z0-9@@]*;  state: Exp;'
	  log_lines="  lines: ${PLUS}1 -1"
	  log_rev1="${log_dash} 1\.1
${log_date}
1"
	  log_rev2="${log_dash} 1\.2
${log_date}${log_lines}
branches:  1\.2\.2;
2"
	  log_rev3="${log_dash} 1\.3
${log_date}${log_lines}
3"
	  log_rev1b="${log_dash} 1\.2\.2\.1
${log_date}${log_lines}
1b"
	  log_rev2b="${log_dash} 1\.2\.2\.2
${log_date}${log_lines}
2b"
	  log_trailer='============================================================================='

	  # Now, finally, test the log output.

	  dotest log-11 "${testcvs} log file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-12 "${testcvs} log -N file1" \
"${log_header}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-13 "${testcvs} log -b file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 3
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-14 "${testcvs} log -r file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  dotest log-15 "${testcvs} log -r1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2}
${log_trailer}"

	  dotest log-16 "${testcvs} log -r1.2.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  # This test would fail with the old invocation of rlog, but it
	  # works with the builtin log support.
	  dotest log-17 "${testcvs} log -rbranch file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-18 "${testcvs} log -r1.2.2. file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  # This test would fail with the old invocation of rlog, but it
	  # works with the builtin log support.
	  dotest log-19 "${testcvs} log -rbranch. file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  dotest log-20 "${testcvs} log -r1.2: file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev3}
${log_rev2}
${log_trailer}"

	  dotest log-21 "${testcvs} log -r:1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-22 "${testcvs} log -r1.1:1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  cd ..
	  rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir
	  ;;

a2835 1
# * use "test" not "[" and see if all test's support `-z'
d2847 1
a2847 1
# * Test operations on a directory that contains other directories but has
d2855 1
a2855 1
#   gives an appropriate error (e.g.
a2862 1
# * Test things to do with the CVS/* files, esp. CVS/Root....
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a15 9
# You can't run CVS as root; print a nice error message here instead
# of somewhere later, after making a mess.
case "`whoami`" in
  "root" )
    echo "sanity.sh: test suite does not work correctly when run as root" >&2
    exit 1
  ;;
esac

d445 7
a451 1
	tests="basica basicb basic1 deep basic2 rdiff death death2 branches multibranch import join new newb conflicts conflicts2 modules modules2 mflag errmsg1 devcom devcom2 ignore binfiles binwrap info serverpatch log log2 crerepos rcs"
d456 59
d555 4
a558 1
# Set up CVSROOT (the crerepos tests will test operating without CVSROOT set).
d569 2
a570 1
dotest 1 "${testcvs} init" ''
d580 8
a587 13
	  # Tests basica-0a and basica-0b provide the equivalent of the:
	  #    mkdir ${CVSROOT_DIRNAME}/first-dir
	  # used by many of the tests.  It is "more official" in the sense
	  # that is does everything through CVS; the reason most of the
	  # tests don't use it is mostly historical.
	  mkdir 1; cd 1
	  dotest basica-0a "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest basica-0b "${testcvs} add first-dir" \
"Directory /tmp/cvs-sanity/cvsroot/\./first-dir added to the repository"
	  cd ..
	  rm -rf 1

a707 1
	  dotest basicb-1a "test -d CVS" ''
a785 1
	  dotest basicb-9a "test -d CVS" ''
a796 1
		mkdir 1; cd 1
a898 8
		cd ..

		if test "$keep" = yes; then
		  echo Keeping /tmp/cvs-sanity and exiting due to --keep
		  exit 0
		fi

		rm -rf 1
d900 1
d974 1
a974 1
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d983 1
a983 31

	  # Test that if we remove the working directory, CVS does not
	  # recreate it.  (I realize that this behavior is what the
	  # users expect, but in the longer run we might want to
	  # re-think it.  The corresponding behavior for a file is that
	  # CVS *will* recreate it, and we might want to make it so
	  # that "cvs release -d" is the way to delete the directory
	  # and have it stay gone -kingdon, Oct1996).
	  rm -rf dir6
	  dotest deep-4b1 "${testcvs} -q update" ''
	  dotest deep-4b2 "${testcvs} -q update -d -P" \
'U dir6/file1
U dir6/dir7/file1'

	  # Test what happens if one uses -P when there are files removed
	  # but not committed.
	  cd dir6/dir7
	  dotest deep-rm1 "${testcvs} rm -f file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  cd ..
	  dotest deep-rm2 "${testcvs} -q update -d -P" 'R dir7/file1'
	  dotest deep-rm3 "test -d dir7" ''
	  dotest deep-rm4 "${testcvs} -q ci -m rm-it" 'Removing dir7/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done'
	  dotest deep-rm5 "${testcvs} -q update -d -P" ''
	  dotest_fail deep-rm6 "test -d dir7" ''

	  cd ../../../../../../..
d1325 1
a1325 1
		dotest basic2-64 "${testcvs} his -x TOFWUCGMAR -a" \
d1388 1
a1388 1
"${PROG} [a-z]*: Updating trdiff
d1390 1
a1390 1
U trdiff/foo"
d1403 2
a1404 2
"${PROG} [a-z]*: scheduling file \`new' for addition
${PROG} [a-z]*: use 'cvs commit' to add this file permanently"
d1415 1
a1415 1
"${PROG} [a-z]*: Tagging .
d1418 1
a1418 1
T new"
d1440 1
a1440 1
"${PROG}"' [a-z]*: Diffing trdiff
d1447 2
a1448 2
! \$''Id: foo,v 1\.1\.1\.1 [0-9/]* [0-9:]* [a-zA-Z0-9][a-zA-Z0-9]* Exp \$
! \$''Name: T1 \$
d1463 28
a1496 2
		cd ..
		rm -rf testimport
d1915 1
a1915 18
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"

	  # Test diff of the removed file before it is committed.
	  dotest_fail death2-diff-1 "${testcvs} -q diff file1" \
"${PROG} [a-z]*: file1 was removed, no comparison available"

	  dotest_fail death2-diff-2 "${testcvs} -q diff -N -c file1" \
"Index: file1
===================================================================
RCS file: file1
diff -N file1
\*\*\* [-a-zA-Z0-9/.%_]*[ 	][	]*[a-zA-Z0-9: ]*
--- /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- first revision
--- 0 ----"

d1923 1
a1923 1
	  dotest_fail death2-diff-3 \
d1927 1
a1927 1
	  dotest_fail death2-diff-4 \
d1933 1
a1933 1
\*\*\* [-a-zA-Z0-9/.%_]*[ 	][	]*[a-zA-Z0-9: ]*
d1940 1
a1940 1
	  dotest_fail death2-diff-5 "${testcvs} -q diff -rtag -c ." \
d1943 1
a1943 1
	  dotest_fail death2-diff-6 "${testcvs} -q diff -rtag -N -c ." \
d1948 1
a1948 1
\*\*\* [-a-zA-Z0-9/.%]*[ 	][	]*[a-zA-Z0-9: ]*
a1973 17

	  # Test diff of the added file before it is committed.
	  dotest_fail death2-diff-7 "${testcvs} -q diff file1" \
"${PROG} [a-z]*: file1 is a new entry, no comparison available"

	  dotest_fail death2-diff-8 "${testcvs} -q diff -N -c file1" \
"Index: file1
===================================================================
RCS file: file1
diff -N file1
\*\*\* /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
--- [-a-zA-Z0-9/.%_]*[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 0 \*\*\*\*
--- 1 ----
${PLUS} second revision"

d2031 1
a2031 1
	  dotest_fail death2-diff-9 "${testcvs} -q diff -rtag -c file3" \
d2034 1
a2034 1
	  dotest_fail death2-diff-10 "${testcvs} -q diff -rtag -N -c file3" \
d2040 1
a2040 1
--- [-a-zA-Z0-9/.%_]*[ 	][ 	]*[a-zA-Z0-9: ]*
d2046 1
a2046 1
	  dotest_fail death2-diff-11 "${testcvs} -q diff -rtag -c ." \
d2063 1
a2063 1
	  dotest_fail death2-diff-12 "${testcvs} -q diff -rtag -c -N ." \
d2082 1
a2082 1
--- [-a-zA-Z0-9/.%_]*[ 	][ 	]*[a-zA-Z0-9: ]*
d2092 1
a2092 1
--- [-a-zA-Z0-9/.%_]*[ 	][ 	]*[a-zA-Z0-9: ]*
d2116 1
a2116 1
	  dotest_fail death2-diff-13 "${testcvs} -q diff -r rdiff-tag" \
d2119 1
a2119 1
	  dotest_fail death2-diff-14 "${testcvs} -q diff -r rdiff-tag -c -N" \
d2125 1
a2125 1
--- [-a-zA-Z0-9/.%_]*[ 	][ 	]*[a-zA-Z0-9: ]*
d2745 1
a2745 1
'"${PROG}"' [a-z]*: use '\'"${PROG} commit"\'' to remove these files permanently'
d2834 1
a2834 1
'"${PROG}"' [a-z]*: use '\'"${PROG} commit"\'' to remove these files permanently'
d3073 1
a3073 1
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d3140 3
d3174 1
a3174 22
		cd ../..

		# Similar to conflicts-126.5, but now the file has nonempty
		# contents.
		mkdir 3
		cd 3
		# The need for TMPPWD here is a (minor) CVS bug; the
		# output should use the name of the repository as specified.
		dotest conflicts-128.5 "${testcvs} co -p -l first-dir" \
"${PROG} [a-z]*"': Updating first-dir
===================================================================
Checking out first-dir/a
RCS:  '"${TMPPWD}"'/cvs-sanity/cvsroot/first-dir/a,v
VERS: 1\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
add a line'
		cd ..
		rmdir 3

		# Now go over the to the other working directory and
		# start testing conflicts
		cd 2/first-dir
d3202 7
a3208 3
		dotest_fail conflicts-131 "${testcvs} -q ci -m try" \
"${PROG} [a-z]*: file .a. had a conflict and has not been modified
${PROG} \[[a-z]* aborted\]: correct above errors first!"
d3212 6
a3217 3
		dotest_fail conflicts-132 "${testcvs} -q ci -m try" \
"${PROG} [a-z]*: file .a. still contains conflict indicators
${PROG} \[[a-z]* aborted\]: correct above errors first!"
d3220 5
a3224 5
		dotest conflicts-133 "${testcvs} -q ci -m resolved" \
"Checking in a;
/tmp/cvs-sanity/cvsroot/first-dir/a,v  <--  a
new revision: 1\.3; previous revision: 1\.2
done"
d3242 1
a3242 1
		dotest conflicts-136 "${testcvs} -q update first-dir" \
d3351 1
a3351 1
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d3369 1
a3369 1
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d3379 1
a3379 1
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d3419 1
a3419 1
	  # Tests of various ways to define and use modules.
d3475 1
a3475 1
	  echo realmodule first-dir/subdir a >CVSROOT/modules
d3495 2
a3496 1
	  dotest 148a0 "${testcvs} co -c" 'aliasmodule  -a first-dir/subdir/a
d3507 2
a3508 2
	  dotest 148a1 "${testcvs} co -s" \
'bogusalias   NONE        first-dir/subdir/a -a
d3652 1
a3652 3
	  dotest modules-155a4 "ls" "first-dir" \
"CVS
first-dir"
d3660 1
a3660 1
"U CVSROOT/${DOTSTAR}
a3706 68

	modules2)
	  # More tests of modules, in particular the & feature.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir ${CVSROOT_DIRNAME}/second-dir

	  mkdir 1
	  cd 1

	  dotest modules2-1 "${testcvs} -q co CVSROOT/modules" \
'U CVSROOT/modules'
	  cd CVSROOT
	  echo 'ampermodule &first-dir &second-dir' > modules
	  # Depending on whether the user also ran the modules test
	  # we will be checking in revision 1.2 or 1.3.
	  dotest modules2-2 "${testcvs} -q ci -m add-modules" \
"Checking in modules;
/tmp/cvs-sanity/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"

	  cd ..

	  dotest modules2-3 "${testcvs} -q co ampermodule" ''
	  dotest modules2-4 "test -d ampermodule/first-dir" ''
	  dotest modules2-5 "test -d ampermodule/second-dir" ''

	  # Test ability of cvs release to handle multiple arguments
	  cd ampermodule
	  if ${testcvs} release -d first-dir second-dir <<EOF >>${LOGFILE}
yes
yes
EOF
	  then
	    pass modules2-6
	  else
	    fail modules2-6
	  fi
	  dotest_fail modules2-7 "test -d first-dir" ''
	  dotest_fail modules2-8 "test -d second-dir" ''

	  cd ..

	  # Test that CVS gives an error if one combines -a with
	  # other options.
	  cd CVSROOT
	  echo 'aliasopt -a -d onedir first-dir' >modules
	  dotest modules2-a0 "${testcvs} -q ci -m add-modules" \
"Checking in modules;
/tmp/cvs-sanity/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  dotest_fail modules2-a1 "${testcvs} -q co aliasopt" \
"${PROG} [a-z]*: -a cannot be specified in the modules file along with other options" \
"${PROG} [a-z]*: -a cannot be specified in the modules file along with other options
${PROG} \[[a-z]* aborted\]: cannot expand modules"

	  # Clean up.
	  rm -rf CVSROOT
	  cd ..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -rf ${CVSROOT_DIRNAME}/second-dir
	  ;;

a3998 5

	  # FIXME: This probably should be an error message instead
	  # of silently succeeding and printing nothing.
	  dotest devcom-a-nonexist "${testcvs} watchers nonexist" ''

a4014 7

	  # Test commented out because the bug it tests for is not fixed
	  # The error is:
	  # cvs watchers: cannot open CVS/Entries for reading: No such file or directory
	  # cvs: ../../work/ccvs/src/fileattr.c:75: fileattr_read: Assertion `fileattr_stored_repos != ((void *)0)' failed.
:	  dotest devcom-t-nonexist "${testcvs} watchers nonexist" fixme

a4016 2
	  cd ..
	  rm -rf 3
d4019 1
a4019 1
	  cd 2/first-dir
a4024 2
	  # Now test watching just some, not all, files.
	  dotest devcom-some0 "${testcvs} watch on abc" ''
a4025 13
	  mkdir 3
	  cd 3
	  dotest devcom-some1 "${testcvs} -q co first-dir" 'U first-dir/abb
U first-dir/abc'
	  dotest devcom-some2 "test -w first-dir/abb" ''
	  dotest_fail devcom-some3 "test -w first-dir/abc" ''
	  cd ..

	  if test "$keep" = yes; then
	    echo Keeping /tmp/cvs-sanity and exiting due to --keep
	    exit 0
	  fi

a4028 51
	devcom2)
	  # More watch tests, most notably setting watches on
	  # files in various different states.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest devcom2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir

	  # This should probably be an error; setting a watch on a totally
	  # unknown file is more likely to be a typo than intentional.
	  # But that isn't the currently implemented behavior.
	  dotest devcom2-2 "${testcvs} watch on w1" ''

	  touch w1 w2 w3 nw1
	  dotest devcom2-3 "${testcvs} add w1 w2 w3 nw1" "${DOTSTAR}"
	  # Letting the user set the watch here probably can be considered
	  # a feature--although it leads to a few potentially strange
	  # consequences like one user can set the watch and another actually
	  # adds the file.
	  dotest devcom2-4 "${testcvs} watch on w2" ''
	  dotest devcom2-5 "${testcvs} -q ci -m add-them" "${DOTSTAR}"

	  # Note that this test differs in a subtle way from devcom-some0;
	  # in devcom-some0 the watch is creating a new fileattr file, and
	  # here we are modifying an existing one.
	  dotest devcom2-6 "${testcvs} watch on w3" ''

	  # Now test that all the watches got set on the correct files
	  # FIXME: CVS should have a way to report whether watches are
	  # set, I think.  The "check it out and see if it read-only" is
	  # sort of OK, but is complicated by CVSREAD and doesn't help
	  # if the file is added and not yet committed or some such.
	  # Probably "cvs status" should report "watch: on" if watch is on
	  # (and nothing if watch is off, so existing behavior is preserved).
	  cd ../..
	  mkdir 2
	  cd 2
	  dotest devcom2-7 "${testcvs} -q co first-dir" 'U first-dir/nw1
U first-dir/w1
U first-dir/w2
U first-dir/w3'
	  dotest devcom2-8 "test -w first-dir/nw1" ''
	  dotest_fail devcom2-9 "test -w first-dir/w1" ''
	  dotest_fail devcom2-10 "test -w first-dir/w2" ''
	  dotest_fail devcom2-11 "test -w first-dir/w3" ''
	  cd ..

	  rm -rf 1 2 ${CVSROOT_DIRNAME}/first-dir
	  ;;

d4030 1
a4030 1
	  dotest 187a1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
a4091 2
	  mkdir 1
	  cd 1
d4143 3
a4145 2
	  dotest 191 "${testcvs} -qn update -I! -I CVS" \
"${QUESTION} first-dir/rootig.c
d4149 1
d4152 2
a4153 1
"${QUESTION} first-dir/rootig.c
d4157 1
d4161 1
a4161 26
	  if echo yes | ${testcvs} release -d first-dir \
	    >${TESTDIR}/ignore.tmp; then
	    pass ignore-192
	  else
	    fail ignore-192
	  fi
	  dotest ignore-193 "cat ${TESTDIR}/ignore.tmp" \
"${QUESTION} \.cvsignore
You have \[0\] altered files in this repository.
Are you sure you want to release (and delete) directory .first-dir': "

	  echo add a line >>second-dir/foobar.c
	  rm second-dir/notig.c second-dir/.cvsignore
	  if echo yes | ${testcvs} release -d second-dir \
	    >${TESTDIR}/ignore.tmp; then
	    pass ignore-194
	  else
	    fail ignore-194
	  fi
	  dotest ignore-195 "cat ${TESTDIR}/ignore.tmp" \
"M foobar.c
You have \[1\] altered files in this repository.
Are you sure you want to release (and delete) directory .second-dir': "
	  cd ..
	  rm -rf 1
	  rm ${TESTDIR}/ignore.tmp
d4244 5
a4248 5
"U binfile
${PROG} [a-z]*: binary file needs merge
${PROG} [a-z]*: revision 1\.3 from repository is now in binfile
${PROG} [a-z]*: file from working directory is now in \.#binfile\.1\.2
C binfile"
d4340 1
a4340 1
"${PROG} [a-z]*: use "\''cvs commit'\'' to add this file permanently'
d4410 1
a4410 11
          # The following cases test the format string substitution
          echo "ALL echo %{sVv} >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %{v} >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %s >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %{V}AX >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %sux >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo

	  # Might be nice to move this to crerepos tests; it should
	  # work to create a loginfo file if you didn't create one
	  # with "cvs init".
	  : dotest info-2 "${testcvs} add loginfo" \
a4412 1

d4414 3
a4416 1
'Checking in loginfo;
d4418 1
a4418 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d4422 5
d4451 5
a4456 19
          dotest info-10 "cat $TESTDIR/testlog2" 'first-dir file1,NONE,1.1
first-dir 1.1
first-dir file1
first-dir NONEAX
first-dir file1ux
first-dir file1,1.1,1.2
first-dir 1.2
first-dir file1
first-dir 1.1AX
first-dir file1ux'

	  cd CVSROOT
	  echo '# do nothing' >loginfo
	  dotest info-11 "${testcvs} -q -s ZEE=garbage ci -m nuke-loginfo" \
"Checking in loginfo;
/tmp/cvs-sanity/cvsroot/CVSROOT/loginfo,v  <--  loginfo
new revision: 1\.[0-9]; previous revision: 1\.[0-9]
done
${PROG} [a-z]*: Rebuilding administrative file database"
d4458 4
a4461 18
	  # Now test verifymsg
	  cat >${TESTDIR}/vscript <<EOF
#!/bin/sh
if head -1 < \$1 | grep '^BugId:[ ]*[0-9][0-9]*$' > /dev/null; then
    exit 0
else
    echo "No BugId found."
    exit 1
fi
EOF
	  chmod +x ${TESTDIR}/vscript
	  echo "^first-dir ${TESTDIR}/vscript" >>verifymsg
	  dotest info-v1 "${testcvs} -q ci -m add-verification" \
"Checking in verifymsg;
/tmp/cvs-sanity/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
a4462 47
	  cd ../first-dir
	  echo line2 >>file1
	  dotest_fail info-v2 "${testcvs} -q ci -m bogus" \
"No BugId found\.
${PROG} \[[a-z]* aborted\]: Message verification failed"

	  cat >${TESTDIR}/comment.tmp <<EOF
BugId: 42
and many more lines after it
EOF
	  dotest info-v3 "${testcvs} -q ci -F ${TESTDIR}/comment.tmp" \
"Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  cd ..
	  mkdir another-dir
	  cd another-dir
	  touch file2
	  dotest_fail info-v4 \
	    "${testcvs} import -m bogus first-dir/another x y" \
"No BugId found\.
${PROG} \[[a-z]* aborted\]: Message verification failed"
	  rm file2
	  cd ..
	  rmdir another-dir

	  cd CVSROOT
	  echo '# do nothing' >verifymsg
	  dotest info-cleanup-verifymsg "${testcvs} -q ci -m nuke-verifymsg" \
"Checking in verifymsg;
/tmp/cvs-sanity/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
new revision: 1\.[0-9]; previous revision: 1\.[0-9]
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..

	  if echo "yes" | ${testcvs} release -d CVSROOT >>${LOGFILE} ; then
	    pass info-cleanup
	  else
	    fail info-cleanup
	  fi
	  if echo "yes" | ${testcvs} release -d first-dir >>${LOGFILE} ; then
	    pass info-cleanup-2
	  else
	    fail info-cleanup-2
	  fi
a4529 5
	  # See also log2 tests for more tests.
	  # See also rcs tests, for -d option to log.
	  # See also branches-14.3 for logging with a branch off of a branch.
	  # See also multibranch-14 for logging with several branches off the
	  #   same branchpoint.
a4748 274
	log2)
	  # More "cvs log" tests, for example the file description.

	  # Setting the file description doesn't yet work client/server, so 
	  # skip these tests for remote.
	  if test "x$remote" = xno; then

	  # Check in a file
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest log2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 'first revision' > file1
	  dotest log2-2 "${testcvs} add -m file1-is-for-testing file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest log2-3 "${testcvs} -q commit -m 1" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done'
	  dotest log2-4 "${testcvs} log -N file1" '
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
file1-is-for-testing
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: [a-zA-Z0-9@@]*;  state: Exp;
1
============================================================================='

	  cd ..
	  rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir

	  fi # end of tests skipped for remote

	  ;;
	crerepos)
	  # Various tests relating to creating repositories, operating
	  # on repositories created with old versions of CVS, etc.

	  # At the moment local only but that should be changed.
	  if test "x$remote" = "xno"; then

	    # First, if the repository doesn't exist at all...
	    dotest_fail crerepos-1 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} \[[a-z]* aborted\]: /tmp/cvs-sanity/crerepos/CVSROOT: .*"
	    mkdir crerepos

	    # The repository exists but CVSROOT doesn't.
	    dotest_fail crerepos-2 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} \[[a-z]* aborted\]: /tmp/cvs-sanity/crerepos/CVSROOT: .*"
	    mkdir crerepos/CVSROOT

	    # Checkout of nonexistent module
	    dotest_fail crerepos-3 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} [a-z]*: cannot find module .cvs-sanity. - ignored"

	    # Now test that CVS works correctly without a modules file
	    # or any of that other stuff.  In particular, it *must*
	    # function if administrative files added to CVS recently (since
	    # CVS 1.3) do not exist, because the repository might have
	    # been created with an old version of CVS.
	    mkdir tmp; cd tmp
	    dotest crerepos-4 \
"${testcvs} -q -d ${TESTDIR}/crerepos co CVSROOT" \
''
	    if echo yes | \
${testcvs} -d ${TESTDIR}/crerepos release -d CVSROOT >>${LOGFILE}; then
	      pass crerepos-5
	    else
	      fail crerepos-5
	    fi
	    rm -rf CVS
	    cd ..

	    # The directory tmp should be empty
	    dotest crerepos-6 "rmdir tmp" ''

	    # CVS better not create a history file--if the administrator 
	    # doesn't need it and wants to save on disk space, they just
	    # delete it.
	    dotest_fail crerepos-7 \
"test -f ${TESTDIR}/crerepos/CVSROOT/history" ''

	  fi # end of tests to be skipped for remote
	  ;;

	rcs)
	  # Test ability to import an RCS file.  Note that this format
	  # is fixed--files written by RCS5, and other software which
	  # implements this format, will be out there "forever" and
	  # CVS must always be able to import such files.

	  # TODO: would be nice to have a corresponding test for exporting
	  # RCS files.  Rather than try to write a rigorous check for whether
	  # the file CVS exports is legal, we could just write a simpler test
	  # for what CVS actually exports, and revise the check as needed.

	  mkdir ${CVSROOT_DIRNAME}/first-dir

	  # Currently the way to import an RCS file is to copy it
	  # directly into the repository.
	  # This file was written by RCS 5.7, and then the dates were
	  # hacked so that we test year 2000 stuff.  Note also that
	  # "author" names are just strings, as far as importing
	  # RCS files is concerned--they need not correspond to user
	  # IDs on any particular system.
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head	1.3;
access;
symbols;
locks; strict;
comment	@@# @@;


1.3
date	2000.11.24.15.58.37;	author kingdon;	state Exp;
branches;
next	1.2;

1.2
date	96.11.24.15.57.41;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	96.11.24.15.56.05;	author kingdon;	state Exp;
branches;
next	;


desc
@@file1 is for testing CVS
@@


1.3
log
@@delete second line; modify twelfth line
@@
text
@@This is the first line
This is the third line
This is the fourth line
This is the fifth line
This is the sixth line
This is the seventh line
This is the eighth line
This is the ninth line
This is the tenth line
This is the eleventh line
This is the twelfth line (and what a line it is)
This is the thirteenth line
@@


1.2
log
@@add more lines
@@
text
@@a1 1
This is the second line
d11 1
a11 1
This is the twelfth line
@@


1.1
log
@@add file1
@@
text
@@d2 12
@@
EOF
	  dotest rcs-1 "${testcvs} -q co first-dir" 'U first-dir/file1'
	  cd first-dir
	  dotest rcs-2 "${testcvs} -q log" "
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
file1 is for testing CVS
----------------------------
revision 1\.3
date: 2000/11/24 15:58:37;  author: kingdon;  state: Exp;  lines: ${PLUS}1 -2
delete second line; modify twelfth line
----------------------------
revision 1\.2
date: 1996/11/24 15:57:41;  author: kingdon;  state: Exp;  lines: ${PLUS}12 -0
add more lines
----------------------------
revision 1\.1
date: 1996/11/24 15:56:05;  author: kingdon;  state: Exp;
add file1
============================================================================="

	  # Note that the dates here are chosen so that (a) we test
	  # at least one date after 2000, (b) we will notice if the
	  # month and day are getting mixed up with each other.
	  # TODO: also test that year isn't getting mixed up with month
	  # or day, for example 01-02-03.

	  # ISO8601 format.  There are many, many, other variations
	  # specified by ISO8601 which we should be testing too.
	  dotest rcs-3 "${testcvs} -q log -d 1996-12-11<" "
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 3;	selected revisions: 1
description:
file1 is for testing CVS
----------------------------
revision 1\.3
date: 2000/11/24 15:58:37;  author: kingdon;  state: Exp;  lines: ${PLUS}1 -2
delete second line; modify twelfth line
============================================================================="

	  # RFC822 format (as amended by RFC1123).
	  if ${testcvs} -q log -d '<3 Apr 2000 00:00' >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-4 "cat ${TESTDIR}/rcs4.tmp" "
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 3;	selected revisions: 2
description:
file1 is for testing CVS
----------------------------
revision 1\.2
date: 1996/11/24 15:57:41;  author: kingdon;  state: Exp;  lines: ${PLUS}12 -0
add more lines
----------------------------
revision 1\.1
date: 1996/11/24 15:56:05;  author: kingdon;  state: Exp;
add file1
============================================================================="
	  else
	    fail rcs-4
	  fi

	  rm -rf first-dir ${CVSROOT_DIRNAME}/first-dir ${TESTDIR}/rcs4.tmp
	  ;;

d4761 3
a4763 4
# * Test `cvs update foo bar' (where foo and bar are both from the
#   same directory in the repository).  Suppose one is a branch--make
#   sure that both directories get updated with the respective correct
#   thing.
d4769 1
a4769 1
# * More tests of keyword expansion.
a4780 1
#   (like basica-9, but for remote).
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d44 1
a44 1
	if test "x`${CVS_RSH-rsh} $host -n 'echo hi'`" != "xhi"; then
a82 5
# Regexp to match an author name.  I'm not really sure what characters
# should be here.  a-zA-Z obviously.  People complained when 0-9 were
# not allowed in usernames.  Other than that I'm not sure.
username="[a-zA-Z0-9][a-zA-Z0-9]*"

d454 1
a454 1
	tests="basica basicb basic1 deep basic2 rdiff death death2 branches multibranch import join new newb conflicts conflicts2 modules modules2 modules3 mflag errmsg1 devcom devcom2 devcom3 ignore binfiles binwrap info serverpatch log log2 crerepos rcs big modes"
d529 1
a529 1
"Directory /tmp/cvs-sanity/cvsroot/first-dir added to the repository"
a628 16
	  # Test the -f option to ci
	  cd sdir/ssdir
	  dotest basica-8a "${testcvs} -q ci -f -m force-it" \
'Checking in ssfile;
/tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 1\.3; previous revision: 1\.2
done'
	  cd ../..
	  dotest basica-8b "${testcvs} -q diff -r1.2 -r1.3" \
'Index: sdir/ssdir/ssfile
===================================================================
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v
retrieving revision 1\.2
retrieving revision 1\.3
diff -r1\.2 -r1\.3'

d641 2
a642 2
1\.1          .'"${username}"' *[0-9a-zA-Z-]*.: ssfile
1\.2          .'"${username}"' *[0-9a-zA-Z-]*.: ssfile line 2'
d651 1
a651 24
	  mkdir 1; cd 1
	  dotest basicb-0a "${testcvs} -q co -l ." ''
	  touch topfile
	  dotest basicb-0b "${testcvs} add topfile" \
"${PROG} [a-z]*: scheduling file .topfile. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest basicb-0c "${testcvs} -q ci -m add-it topfile" \
'RCS file: /tmp/cvs-sanity/cvsroot/./topfile,v
done
Checking in topfile;
/tmp/cvs-sanity/cvsroot/./topfile,v  <--  topfile
initial revision: 1\.1
done'
	  cd ..
	  rm -rf 1
	  mkdir 2; cd 2
	  dotest basicb-0d "${testcvs} -q co -l ." "U topfile"
	  mkdir first-dir
	  dotest basicb-0e "${testcvs} add first-dir" \
"Directory /tmp/cvs-sanity/cvsroot/first-dir added to the repository"
	  cd ..
	  rm -rf 2

:	  mkdir ${CVSROOT_DIRNAME}/first-dir
a716 4
	  # See if CVS can correctly notice when an invalid numeric
	  # revision is specified.
	  # Commented out until we get around to fixing CVS
:	  dotest basicb-8a0 "${testcvs} diff -r 1.5 -r 1.7 sfile2" 'error msg'
a739 1
	  rm -f ${CVSROOT_DIRNAME}/topfile,v
d968 1
a968 21
	  # Test rm -f -R.
	  cd ../..
	  dotest deep-rm7 "${testcvs} rm -f -R dir5" \
"${PROG} [a-z]*: Removing dir5
${PROG} [a-z]*: scheduling .dir5/file1. for removal
${PROG} [a-z]*: Removing dir5/dir6
${PROG} [a-z]*: scheduling .dir5/dir6/file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove these files permanently"
	  dotest deep-rm8 "${testcvs} -q ci -m rm-it" \
'Removing dir5/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done
Removing dir5/dir6/file1;
/tmp/cvs-sanity/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done'
	  dotest deep-rm9 "${testcvs} -q update -d -P" ''
	  dotest_fail deep-rm10 "test -d dir5"

	  cd ../../../../..
d1432 1
a1432 1
! \$''Id: foo,v 1\.1\.1\.1 [0-9/]* [0-9:]* '"${username}"' Exp \$
d1435 1
a1435 1
! \$''Id: foo,v 1\.2 [0-9/]* [0-9:]* '"${username}"' Exp \$
d1445 1
a1445 1
'"${PLUS}"' #ident	"@@(#)trdiff:\$''Name: local-v0 \$:\$''Id: new,v 1\.1 [0-9/]* [0-9:]* '"${username}"' Exp \$"
d1624 4
a1627 1
		dotest death-76a0 \
d1637 1
a1637 1
		dotest death-76a1 \
d1647 1
d2398 1
a2398 1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
d2403 1
a2403 1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
d2407 1
a2407 1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
d2426 1
a2426 1
			echo imported file"$i" > imported-f"$i"
d2434 2
a2435 2
		echo 'import should not expand $''Id$' >>imported-f2
		cp imported-f2 ../imported-f2-orig.tmp
d2443 1
a2443 1
		if cmp ../imported-f2-orig.tmp imported-f2; then
d2459 1
a2459 1
			if test -f imported-f"$i" ; then
d2472 2
a2473 2
		rm imported-f1
		if ${CVS} rm imported-f1  2>> ${LOGFILE}; then
d2480 1
a2480 1
		echo local-change >> imported-f2
d2490 1
a2490 1
		if ${CVS} log imported-f1 | grep '1.1.1.2 (dead)'  ; then
d2504 1
a2504 1
		rm imported-f4
d2506 1
a2506 1
		if ${CVS} rm imported-f4  2>> ${LOGFILE}; then
d2513 1
a2513 1
		if ${CVS} ci -m vendor-removed imported-f4 >>${LOGFILE}; then
d2529 1
a2529 1
			echo rev 2 of file $i >> imported-f"$i"
d2531 1
a2531 1
		cp imported-f2 ../imported-f2-orig.tmp
d2538 1
a2538 1
		if cmp ../imported-f2-orig.tmp imported-f2; then
d2554 1
a2554 1
		if test -f imported-f1 ; then
d2561 1
a2561 1
			if test -f imported-f"$i" ; then
d2575 1
a2575 1
		if test -f imported-f4 ; then
d2592 2
a2593 2
"${PROG}"' [a-z]*: file first-dir/imported-f1 is present in revision junk-2_0
RCS file: /tmp/cvs-sanity/cvsroot/first-dir/imported-f2,v
d2596 1
a2596 1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.2 into imported-f2
d2601 1
a2601 1
		if test -f imported-f1 ; then
d2608 1
a2608 1
			if test -f imported-f"$i" ; then
d2615 1
a2615 1
		dotest import-116 'cat imported-f2' \
d2617 2
a2618 2
[<]<<<<<< imported-f2
import should not expand \$''Id: imported-f2,v 1\.2 [0-9/]* [0-9:]* [a-z0-9@@][a-z0-9@@]* Exp \$
d2621 1
a2621 1
import should not expand \$''Id: imported-f2,v 1\.1\.1\.2 [0-9/]* [0-9:]* [a-z0-9@@][a-z0-9@@]* Exp \$
a3191 9
		dotest conflicts-status-0 "${testcvs} status a" \
"===================================================================
File: a                	Status: Needs Merge

   Working revision:	1\.1.*
   Repository revision:	1\.2	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
a3212 9
		dotest conflicts-status-1 "${testcvs} status a" \
"===================================================================
File: a                	Status: File had conflicts on merge

   Working revision:	1\.2.*
   Repository revision:	1\.2	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
a3218 9
		dotest conflicts-status-2 "${testcvs} status a" \
"===================================================================
File: a                	Status: File had conflicts on merge

   Working revision:	1\.2.*
   Repository revision:	1\.2	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
a3223 9
		dotest conflicts-status-3 "${testcvs} status a" \
"===================================================================
File: a                	Status: File had conflicts on merge

   Working revision:	1\.2.*
   Repository revision:	1\.2	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
a3228 9
		dotest conflicts-status-4 "${testcvs} status a" \
"===================================================================
File: a                	Status: Up-to-date

   Working revision:	1\.3.*
   Repository revision:	1\.3	/tmp/cvs-sanity/cvsroot/first-dir/a,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
a3779 50
	modules3)
	  # More tests of modules, in particular what happens if several
	  # modules point to the same file.

	  # First just set up a directory first-dir and a file file1 in it.
	  mkdir 1; cd 1

	  dotest modules3-0 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest modules3-1 "${testcvs} add first-dir" \
"Directory /tmp/cvs-sanity/cvsroot/first-dir added to the repository"

	  cd first-dir
	  echo file1 >file1
	  dotest modules3-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use '\''cvs commit'\'' to add this file permanently'
	  dotest modules3-3 "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done'
	  cd ..

	  dotest modules3-4 "${testcvs} -q co CVSROOT/modules" \
'U CVSROOT/modules'
	  cd CVSROOT
	  cat >modules <<EOF
mod1 -a first-dir/file1
bigmod -a mod1 first-dir/file1
EOF
	  dotest modules3-5 "${testcvs} -q ci -m add-modules" \
"Checking in modules;
/tmp/cvs-sanity/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..

	  dotest modules3-6 "${testcvs} -q co bigmod" ''
	  rm -rf first-dir
	  dotest modules3-7 "${testcvs} -q co bigmod" 'U first-dir/file1'
	  cd ..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a4181 55
	devcom3)
	  # More watch tests, most notably handling of features designed
	  # for future expansion.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest devcom3-1 "${testcvs} -q co first-dir" ''
	  cd first-dir

	  touch w1 w2
	  dotest devcom3-2 "${testcvs} add w1 w2" "${DOTSTAR}"
	  dotest devcom3-3 "${testcvs} watch on w1 w2" ''
	  dotest devcom3-4 "${testcvs} -q ci -m add-them" "${DOTSTAR}"

	  # OK, since we are about to delve into CVS's internals, make
	  # sure that we seem to be correct about how they work.
	  dotest devcom3-5 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw1	_watched=
Fw2	_watched="
	  # Now write a few more lines, just as if we were a newer version
	  # of CVS implementing some new feature.
	  cat <<EOF >>${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
Enew	line	here
G@@#$^!@@#=&
EOF
	  # Now get CVS to write to the fileattr file....
	  dotest devcom3-6 "${testcvs} watch off w1" ''
	  # ...and make sure that it hasn't clobbered our new lines.
	  # Note that writing these lines in another order would be OK
	  # too.
	  dotest devcom3-7 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw2	_watched=
G@@#..!@@#=&
Enew	line	here"

	  # See what CVS does when a file name is duplicated.  The
	  # behavior of all versions of CVS since file attributes were
	  # implemented is that it nukes the duplications.  This seems
	  # reasonable enough, although it means it isn't clear how
	  # useful duplicates would be for purposes of future
	  # expansion.  But in the interests of keeping behaviors
	  # predictable, might as well test for it, I guess.
	  echo 'Fw2	duplicate=' >>${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
	  dotest devcom3-8 "${testcvs} watch on w1" ''
	  dotest devcom3-9 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw2	_watched=
Fw1	_watched=
Enew	line	here
G@@#..!@@#=&"

	  cd ../..

	  rm -rf 1 ${CVSROOT_DIRNAME}/first-dir
	  ;;

a4549 6

	  # While we're here, test for rejection of duplicate tag names.
	  dotest_fail binwrap-0 \
	    "${testcvs} import -m msg -I ! first-dir dup dup" \
"${PROG} \[[a-z]* aborted\]: tag .dup. was specified more than once"

d4857 1
a4857 1
	  log_date="date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;"
d5044 1
a5044 1
date: [0-9/]* [0-9:]*;  author: '"${username}"';  state: Exp;
d5058 1
a5058 3
	  # Because this test is all about -d options and such, it
	  # at least to some extent needs to be different for remote vs.
	  # local.
d5095 1
d5099 5
a5103 15
	  else
	    # For remote, just create the repository.  We don't yet do
	    # the various other tests above for remote but that should be
	    # changed.
	    mkdir crerepos
	    mkdir crerepos/CVSROOT
	  fi

	  if test "x$remote" = "xno"; then
	    # Test that CVS rejects a relative path in CVSROOT.
	    mkdir 1; cd 1
	    dotest_fail crerepos-6a "${testcvs} -q -d ../crerepos get ." \
"${PROG} \[[a-z]* aborted\]: CVSROOT ../crerepos must be an absolute pathname"
	    cd ..
	    rm -rf 1
a5104 20
	    mkdir 1; cd 1
	    dotest_fail crerepos-6b "${testcvs} -d crerepos init" \
"${PROG} \[[a-z]* aborted\]: CVSROOT crerepos must be an absolute pathname"
	    cd ..
	    rm -rf 1
	  else # remote
	    # Test that CVS rejects a relative path in CVSROOT.
	    mkdir 1; cd 1
	    dotest_fail crerepos-6a \
"${testcvs} -q -d :ext:`hostname`:../crerepos get ." \
"Root ../crerepos must be an absolute pathname"
	    cd ..
	    rm -rf 1

	    mkdir 1; cd 1
	    dotest_fail crerepos-6b \
"${testcvs} -d :ext:`hostname`:crerepos init" \
"Root crerepos must be an absolute pathname"
	    cd ..
	    rm -rf 1
a5105 7

	  # CVS better not create a history file--if the administrator 
	  # doesn't need it and wants to save on disk space, they just
	  # delete it.
	  dotest_fail crerepos-7 \
"test -f ${TESTDIR}/crerepos/CVSROOT/history" ''

a5280 165
	  ;;

	big)

	  # Test ability to operate on big files.  Intention is to
	  # test various realloc'ing code in RCS_deltas, rcsgetkey,
	  # etc.  "big" is currently defined to be 1000 lines (64000
	  # bytes), which in terms of files that users will use is not
	  # large, merely average, but my reasoning is that this
	  # should be big enough to make sure realloc'ing is going on
	  # and that raising it a lot would start to stress resources
	  # on machines which run the tests, without any significant
	  # benefit.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest big-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  for i in 0 1 2 3 4 5 6 7 8 9; do
	    for j in 0 1 2 3 4 5 6 7 8 9; do
	      for k in 0 1 2 3 4 5 6 7 8 9; do
		echo \
"This is line ($i,$j,$k) which goes into the file file1 for testing" >>file1
	      done
	    done
	  done
	  dotest big-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest big-3 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/file1,v
done
Checking in file1;
/tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done'
	  cd ..
	  rm -rf first-dir
	  dotest big-4 "${testcvs} -q get first-dir" "U first-dir/file1"

	  if test "$keep" = yes; then
	    echo Keeping /tmp/cvs-sanity and exiting due to --keep
	    exit 0
	  fi

	  rm -rf first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	modes)
	  # Test repository permissions (CVSUMASK and so on).
	  # Although the tests in this section "cheat" by testing
	  # repository permissions, which are sort of not a user-visible
	  # sort of thing, the modes do have user-visible consequences,
	  # such as whether a second user can check out the files.  But
	  # it would be awkward to test the consequences, so we don't.

	  export -n CVSUMASK # if unset, defaults to 002
	  umask 077
	  mkdir 1; cd 1
	  dotest modes-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest modes-2 "${testcvs} add first-dir" \
"Directory /tmp/cvs-sanity/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  dotest modes-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest modes-4 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/aa,v
done
Checking in aa;
/tmp/cvs-sanity/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done'
	  dotest modes-5 "ls -l /tmp/cvs-sanity/cvsroot/first-dir/aa,v" \
"-r--r--r-- .*"

	  # Test for whether we can set the execute bit.
	  chmod +x aa
	  echo change it >>aa
	  dotest modes-6 "${testcvs} -q ci -m set-execute-bit" \
'Checking in aa;
/tmp/cvs-sanity/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done'
	  # If CVS let us update the execute bit, it would be set here.
	  # But it doesn't, and as far as I know that is longstanding
	  # CVS behavior.
	  dotest modes-7 "ls -l /tmp/cvs-sanity/cvsroot/first-dir/aa,v" \
"-r--r--r-- .*"

	  # OK, now manually change the modes and see what happens.
	  chmod g=r,o= /tmp/cvs-sanity/cvsroot/first-dir/aa,v
	  echo second line >>aa
	  dotest modes-7a "${testcvs} -q ci -m set-execute-bit" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest modes-7b "ls -l /tmp/cvs-sanity/cvsroot/first-dir/aa,v" \
"-r--r----- .*"

	  CVSUMASK=007
	  export CVSUMASK
	  touch ab
	  # Might as well test the execute bit too.
	  chmod +x ab
	  dotest modes-8 "${testcvs} add ab" \
"${PROG} [a-z]*: scheduling file .ab. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest modes-9 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/ab,v
done
Checking in ab;
/tmp/cvs-sanity/cvsroot/first-dir/ab,v  <--  ab
initial revision: 1\.1
done'
	  if test "x$remote" = xyes; then
	    # The problem here is that the CVSUMASK environment variable
	    # needs to be set on the server (e.g. .bashrc).  This is, of
	    # course, bogus, but that is the way it is currently.
	    dotest modes-10 "ls -l /tmp/cvs-sanity/cvsroot/first-dir/ab,v" \
"-r-xr-x---.*" "-r-xr-xr-x.*"
	  else
	    dotest modes-10 "ls -l /tmp/cvs-sanity/cvsroot/first-dir/ab,v" \
"-r-xr-x---.*"
	  fi

	  # OK, now add a file on a branch.  Check that the mode gets
	  # set the same way (it is a different code path in CVS).
	  dotest modes-11 "${testcvs} -q tag -b br" 'T aa
T ab'
	  dotest modes-12 "${testcvs} -q update -r br" ''
	  touch ac
	  dotest modes-13 "${testcvs} add ac" \
"${PROG} [a-z]*: scheduling file .ac. for addition on branch .br.
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  # Not sure it really makes sense to refer to a "previous revision"
	  # when we are just now adding the file; as far as I know
	  # that is longstanding CVS behavior, for what it's worth.
	  dotest modes-14 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/first-dir/Attic/ac,v
done
Checking in ac;
/tmp/cvs-sanity/cvsroot/first-dir/Attic/ac,v  <--  ac
new revision: 1\.1\.2\.1; previous revision: 1\.1
done'
	  if test "x$remote" = xyes; then
	    # The problem here is that the CVSUMASK environment variable
	    # needs to be set on the server (e.g. .bashrc).  This is, of
	    # course, bogus, but that is the way it is currently.
	    dotest modes-15 \
"ls -l /tmp/cvs-sanity/cvsroot/first-dir/Attic/ac,v" \
"-r--r--r--.*"
	  else
	    dotest modes-15 \
"ls -l /tmp/cvs-sanity/cvsroot/first-dir/Attic/ac,v" \
"-r--r-----.*"
	  fi

	  cd ../..
	  rm -rf 1 ${TESTDIR}/first-dir
	  # Perhaps should restore the umask and CVSUMASK.  But the other
	  # tests "should" not care about them...
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a87 4
# Regexp to match the name of a temporary file (from cvs_temp_name).
# This appears in certain diff output.
tempname="[-a-zA-Z0-9/.%_]*"

a450 5
# Make sure this variable is not defined to anything that would
# change the format of rcs dates.  Otherwise people using e.g.,
# RCSINIT=-zLT get lots of spurious failures.
RCSINIT=; export RCSINIT

a732 3
	  dotest basicb-4a "${testcvs} -q ci CVS" \
"${PROG} [a-z]*: warning: directory CVS specified in argument
${PROG} [a-z]*: but CVS uses CVS for its own purposes; skipping CVS directory"
d1950 1
a1950 1
\*\*\* ${tempname}[ 	][	]*[a-zA-Z0-9: ]*
d1974 1
a1974 1
\*\*\* ${tempname}[ 	][	]*[a-zA-Z0-9: ]*
d1989 1
a1989 1
\*\*\* ${tempname}[ 	][	]*[a-zA-Z0-9: ]*
d2026 1
a2026 1
--- ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
d2098 1
a2098 1
--- ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
d2140 1
a2140 1
--- ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
d2150 1
a2150 1
--- ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
d2183 1
a2183 1
--- ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
d5596 1
a5596 5
	  # Solaris /bin/sh doesn't support export -n.  I'm not sure
	  # what we can do about this, other than hope that whoever
	  # is running the tests doesn't have CVSUMASK set.
	  #export -n CVSUMASK # if unset, defaults to 002

@


1.1.1.9
log
@Latest release from Cyclic Software
@
text
@a253 2
      # See below about writing this to the logfile.
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
a258 11
	  # Why, I hear you ask, do we write this to the logfile
	  # even when the test passes?  The reason is that the test
	  # may give us the regexp which we were supposed to match,
	  # but sometimes it may be useful to look at the exact
	  # text which was output.  For example, suppose one wants
	  # to grep for a particular warning, and make _sure_ that
	  # CVS never hits it (even in cases where the tests might
	  # match it with .*).  Or suppose one wants to see the exact
	  # date format output in a certain case (where the test will
	  # surely use a somewhat non-specific pattern).
	  cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
a468 1
	tests="${tests} sticky keyword"
a644 1
	  dotest basica-8a0 "${testcvs} -q ci -m not-modified ssfile" ''
a649 12
	  dotest basica-8a1 "${testcvs} -q ci -m bump-it -r 2.0" \
'Checking in ssfile;
/tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 2\.0; previous revision: 1\.3
done'
	  # -f should not be necessary, but it should be harmless.
	  # Also test the "-r 3" (rather than "-r 3.0") usage.
	  dotest basica-8a2 "${testcvs} -q ci -m bump-it -f -r 3" \
'Checking in ssfile;
/tmp/cvs-sanity/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 3\.1; previous revision: 2\.0
done'
a706 6
	  # See comment at modules3-7f for more on this behavior.
	  dotest basicb-1b "cat CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir" "${TESTDIR}/cvsroot/\."
	  dotest basicb-1c "cat first-dir/CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir"

a792 5
	  # See comment at modules3-7f for more on this behavior.
	  dotest basicb-9b "cat CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir" "${TESTDIR}/cvsroot/\."
	  dotest basicb-9c "cat newdir/CVS/Repository" \
"${TESTDIR}/cvsroot/CVSROOT/Emptydir"
a798 65
	  # Hmm, this might be a case for CVSNULLREPOS, but CVS doesn't
	  # seem to deal with it...
	  if false; then
	  dotest basicb-11 "${testcvs} -q co -d sub1/sub2 first-dir" \
"U sub1/sub2/sdir1/sfile1
U sub1/sub2/sdir2/sfile2"
	  cd sub1
	  dotest basicb-12 "${testcvs} -q update" ''
	  touch xx
	  dotest basicb-13 "${testcvs} add xx" fixme
	  cd ..
	  rm -r sub1
	  # to test: sub1/sub2/sub3
	  fi # end of tests commented out.

	  # Create a second directory.
	  mkdir 1
	  cd 1
	  dotest basicb-14 "${testcvs} -q co -l ." 'U topfile'
	  mkdir second-dir
	  dotest basicb-15 "${testcvs} add second-dir" \
"Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
	  cd second-dir
	  touch aa
	  dotest basicb-16 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest basicb-17 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/second-dir/aa,v
done
Checking in aa;
/tmp/cvs-sanity/cvsroot/second-dir/aa,v  <--  aa
initial revision: 1\.1
done'
	  cd ../..
	  rm -rf 1
	  # Now here is the kicker: note that the semantics of -d
	  # are fundamentally different if we specify two or more directories 
	  # rather than one!  I consider this to be seriously bogus,
	  # but for the moment I am just trying to figure out what
	  # CVS's current behaviors are.
	  dotest basicb-18 "${testcvs} -q co -d test2 first-dir second-dir" \
"U test2/first-dir/sdir1/sfile1
U test2/first-dir/sdir2/sfile2
U test2/second-dir/aa"
	  cd test2
	  touch emptyfile
	  # The fact that CVS lets us add a file here is a CVS bug, right?
	  # I can just make this an error message (on the add and/or the
	  # commit) without getting flamed, right?
	  # Right?
	  # Right?
	  dotest basicb-19 "${testcvs} add emptyfile" \
"${PROG} [a-z]*: scheduling file .emptyfile. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest basicb-20 "${testcvs} -q ci -m add" \
'RCS file: /tmp/cvs-sanity/cvsroot/CVSROOT/Emptydir/emptyfile,v
done
Checking in emptyfile;
/tmp/cvs-sanity/cvsroot/CVSROOT/Emptydir/emptyfile,v  <--  emptyfile
initial revision: 1\.1
done'
	  cd ..
	  rm -rf test2

a799 1
	  rm -rf ${CVSROOT_DIRNAME}/second-dir
d2179 6
a3933 4
namednest -d src/sub/dir first-dir
nestdeeper -d src/sub1/sub2/sub3/dir first-dir
nestshallow -d src/dir second-dir/suba/subb
path/in/modules &mod1
a3946 1
	  rm -r 1
a3947 85
	  mkdir 1; cd 1
	  mkdir suba
	  mkdir suba/subb
	  # This fails to work remote (it doesn't notice the directories,
	  # I suppose because they contain no files).  Bummer, especially
	  # considering this is a documented technique and everything.
	  dotest modules3-7a \
"${testcvs} import -m add-dirs second-dir tag1 tag2" \
"${PROG} [a-z]*: Importing /tmp/cvs-sanity/cvsroot/second-dir/suba
${PROG} [a-z]*: Importing /tmp/cvs-sanity/cvsroot/second-dir/suba/subb

No conflicts created by this import" "
No conflicts created by this import"
	  cd ..; rm -r 1
	  mkdir 1; cd 1
	  dotest modules3-7b "${testcvs} co second-dir" \
"${PROG} [a-z]*: Updating second-dir
${PROG} [a-z]*: Updating second-dir/suba
${PROG} [a-z]*: Updating second-dir/suba/subb" \
"${PROG} server: Updating second-dir"

	  if test "x$remote" = xyes; then
	    cd second-dir
	    mkdir suba
	    dotest modules3-7-workaround1 "${testcvs} add suba" \
"Directory ${TESTDIR}/cvsroot/second-dir/suba added to the repository"
	    cd suba
	    mkdir subb
	    dotest modules3-7-workaround2 "${testcvs} add subb" \
"Directory ${TESTDIR}/cvsroot/second-dir/suba/subb added to the repository"
	    cd ../..
	  fi

	  cd second-dir/suba/subb
	  touch fileb
	  dotest modules3-7c "${testcvs} add fileb" \
"${PROG} [a-z]*: scheduling file .fileb. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest modules3-7d "${testcvs} -q ci -m add-it" \
'RCS file: /tmp/cvs-sanity/cvsroot/second-dir/suba/subb/fileb,v
done
Checking in fileb;
/tmp/cvs-sanity/cvsroot/second-dir/suba/subb/fileb,v  <--  fileb
initial revision: 1\.1
done'
	  cd ../../..
	  cd ..; rm -r 1

	  mkdir 1; cd 1
	  dotest modules3-7e "${testcvs} -q co nestshallow" \
"U src/dir/fileb"

	  # Using ${TESTDIR}/cvsroot/second-dir/suba instead of
	  # ${TESTDIR}/cvsroot/second-dir seems wrong, it seems like the
	  # 30 Dec 1996 change to build_dirs_and_chdir simply failed
	  # to consider what to put in CVS/Repository.
	  # Remote does "${TESTDIR}/cvsroot/\." which seems equally wrong,
	  # if in a different way, but variety is the spice of life,
	  # eh?
	  dotest modules3-7f "cat CVS/Repository" \
"${TESTDIR}/cvsroot/second-dir/suba" "${TESTDIR}/cvsroot/\."

	  dotest modules3-7g "cat src/CVS/Repository" \
"${TESTDIR}/cvsroot/second-dir/suba"
	  dotest modules3-7h "cat src/dir/CVS/Repository" \
"${TESTDIR}/cvsroot/second-dir/suba/subb"
	  cd ..; rm -r 1

	  mkdir 1
	  cd 1
	  dotest modules3-8 "${testcvs} -q co namednest" \
'U src/sub/dir/file1'
	  dotest modules3-9 "test -f src/sub/dir/file1" ''
	  cd ..
	  rm -r 1

	  # Try the same thing, but with the directories nested even
	  # deeper (deeply enough so they are nested more deeply than
	  # the number of directories from / to ${TESTDIR}).
	  mkdir 1
	  cd 1
	  dotest modules3-10 "${testcvs} -q co nestdeeper" \
'U src/sub1/sub2/sub3/dir/file1'
	  dotest modules3-11 "test -f src/sub1/sub2/sub3/dir/file1" ''
	  cd ..
a3948 32

	  # This one is almost too twisted for words.  The pathname output
	  # in the message from "co" doesn't include the "path/in/modules",
	  # but those directories do get created (with no CVSADM except
	  # in "modules" which has a CVSNULLREPOS).
	  # I'm not sure anyone is relying on this nonsense or whether we
	  # need to keep doing it, but it is what CVS currently does...
	  # Skip it for remote; the remote code has the good sense to
	  # not deal with it (on the minus side it gives
	  # "internal error: repository string too short." instead of a
	  # real error).
	  # I kind of suspect that it would be OK to just make it a fatal
	  # error to have '/' in a module name.
	  if test "x$remote" = xno; then
	  mkdir 1; cd 1
	  dotest modules3-12 "${testcvs} -q co path/in/modules" \
"U first-dir/file1"
	  dotest modules3-13 "test -f path/in/modules/first-dir/file1" ''
	  cd ..; rm -r 1

	  # Now here is where it gets seriously bogus.
	  mkdir 1; cd 1
	  dotest modules3-14 \
"${testcvs} -q rtag tag1 path/in/modules" ''
	  # CVS creates this even though rtag should *never* affect
	  # the directory current when it is called!
	  dotest modules3-15 "test -d path/in/modules" ''
	  # Just for trivia's sake, rdiff is not similarly vulnerable
	  # because it passes 0 for run_module_prog to do_module.
	  cd ..; rm -r 1
	  fi # end of tests skipped for remote

a3949 1
	  rm -rf ${CVSROOT_DIRNAME}/second-dir
d5718 1
a5718 1
	  rm -rf 1 ${CVSROOT_DIRNAME}/first-dir
a5720 282
	  ;;

	sticky)
	  # More tests of sticky tags, particularly non-branch sticky tags.
	  mkdir 1; cd 1
	  dotest sticky-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest sticky-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  touch file1
	  dotest sticky-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest sticky-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest sticky-5 "${testcvs} -q tag tag1" "T file1"
	  echo add a line >>file1
	  dotest sticky-6 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest sticky-7 "${testcvs} -q update -r tag1" "[UP] file1"
	  dotest sticky-8 "cat file1" ''
	  dotest sticky-9 "${testcvs} -q update" ''
	  dotest sticky-10 "cat file1" ''
	  touch file2
	  dotest_fail sticky-11 "${testcvs} add file2" \
"${PROG} [a-z]*: cannot add file on non-branch tag tag1"
	  dotest sticky-12 "${testcvs} -q update -A" "[UP] file1
${QUESTION} file2" "${QUESTION} file2
[UP] file1"
	  dotest sticky-13 "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"

	  cd ../..
	  rm -rf 1 ${CVSROOT_DIRNAME}/first-dir
	  ;;

	keyword)
	  # Test keyword expansion.
	  mkdir 1; cd 1
	  dotest keyword-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest keyword-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir

	  echo '$''Author$' > file1
	  echo '$''Date$' >> file1
	  echo '$''Header$' >> file1
	  echo '$''Id$' >> file1
	  echo '$''Locker$' >> file1
	  echo '$''Name$' >> file1
	  echo '$''RCSfile$' >> file1
	  echo '$''Revision$' >> file1
	  echo '$''Source$' >> file1
	  echo '$''State$' >> file1
	  echo '$''Nonkey$' >> file1
	  # Omit the trailing dollar sign
	  echo '$''Date' >> file1
	  # Put two keywords on one line
	  echo '$''State$' '$''State$' >> file1
	  # Use a header for Log
	  echo 'xx $''Log$' >> file1

	  dotest keyword-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest keyword-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest keyword-5 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Locker:  "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"

	  # Use cvs admin to lock the RCS file in order to check -kkvl
	  # vs. -kkv.  CVS does not normally lock RCS files, but some
	  # people use cvs admin to enforce reserved checkouts.
	  dotest keyword-6 "${testcvs} admin -l file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 locked
done"

	  dotest keyword-7 "${testcvs} update -kkv file1" "U file1"
	  dotest keyword-8 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Locker:  "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"

	  dotest keyword-9 "${testcvs} update -kkvl file1" "U file1"
	  dotest keyword-10 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp ${username} "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp ${username} "'\$'"
"'\$'"Locker: ${username} "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"

	  dotest keyword-11 "${testcvs} update -kk file1" "U file1"
	  dotest keyword-12 "cat file1" \
'\$'"Author"'\$'"
"'\$'"Date"'\$'"
"'\$'"Header"'\$'"
"'\$'"Id"'\$'"
"'\$'"Locker"'\$'"
"'\$'"Name"'\$'"
"'\$'"RCSfile"'\$'"
"'\$'"Revision"'\$'"
"'\$'"Source"'\$'"
"'\$'"State"'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State"'\$'" "'\$'"State"'\$'"
xx "'\$'"Log"'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"

	  dotest keyword-13 "${testcvs} update -kv file1" "U file1"
	  dotest keyword-14 "cat file1" \
"${username}
[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]
${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp
file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp


file1,v
1\.1
${TESTDIR}/cvsroot/first-dir/file1,v
Exp
"'\$'"Nonkey"'\$'"
"'\$'"Date
Exp Exp
xx file1,v
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"

	  dotest keyword-15 "${testcvs} update -ko file1" "U file1"
	  dotest keyword-16 "cat file1" \
'\$'"Author"'\$'"
"'\$'"Date"'\$'"
"'\$'"Header"'\$'"
"'\$'"Id"'\$'"
"'\$'"Locker"'\$'"
"'\$'"Name"'\$'"
"'\$'"RCSfile"'\$'"
"'\$'"Revision"'\$'"
"'\$'"Source"'\$'"
"'\$'"State"'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State"'\$'" "'\$'"State"'\$'"
xx "'\$'"Log"'\$'

	  # Test the Name keyword.  First go back to normal expansion.

	  # FIXME: When using remote, update -A does not revert the
	  # keyword expansion mode.  We work around that bug here.
	  # This workaround should be removed when the bug is fixed.
	  if test "x$remote" = "xyes"; then
	    cd ..
	    rm -rf first-dir
	    dotest keyword-17 "${testcvs} -q co first-dir" "U first-dir/file1"
	    cd first-dir
	  else
	    dotest keyword-17 "${testcvs} update -A file1" "U file1"
	  fi

	  echo '$''Name$' > file1
	  dotest keyword-18 "${testcvs} ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest keyword-19 "${testcvs} -q tag tag1" "T file1"
	  echo "change" >> file1
	  dotest keyword-20 "${testcvs} -q ci -m mod2 file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest keyword-21 "${testcvs} -q update -r tag1" "[UP] file1"

	  # FIXME: This test fails when remote.  The second expect
	  # string below should be removed when this is fixed.
	  dotest keyword-22 "cat file1" '\$'"Name: tag1 "'\$' \
'\$'"Name:  "'\$'

	  dotest keyword-23 "${testcvs} update -A file1" "[UP] file1"

	  # Test the Log keyword.
	  echo 'xx $''Log$' > file1
	  cat >${TESTDIR}/comment.tmp <<EOF
First log line
Second log line
EOF
	  dotest keyword-24 "${testcvs} ci -F ${TESTDIR}/comment.tmp file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done"
	  rm -f ${TESTDIR}/comment.tmp
	  dotest keyword-25 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"

	  echo "change" >> file1
	  dotest keyword-26 "${testcvs} ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.5; previous revision: 1\.4
done"
	  dotest keyword-27 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.5  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"

	  cd ../..
	  rm -rf 1 ${CVSROOT_DIRNAME}/first-dir
@


1.1.1.10
log
@Latest version from Cyclic Software
@
text
@d28 5
a32 1
TESTDIR=${TESTDIR:-/tmp/cvs-sanity}
a462 4
# This will show up in cvs history output where it prints the working
# directory.  It should *not* appear in any cvs output referring to the
# repository; cvs should use the name of the repository as specified.
TMPPWD=`/bin/pwd`
d481 2
a482 6
	tests="basica basicb basic1 deep basic2 rdiff death death2 branches"
	tests="${tests} multibranch import join new newb conflicts conflicts2"
	tests="${tests} modules modules2 modules3 mflag errmsg1 devcom devcom2"
	tests="${tests} devcom3 ignore binfiles binfiles2 binwrap mwrap info"
	tests="${tests} serverpatch log log2 crerepos rcs big modes stamps"
	tests="${tests} sticky keyword toplevel"
d557 1
a557 1
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
d559 1
a559 1
	  rm -r 1
d574 1
a574 1
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository" \
d576 1
a576 1
Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"
d580 1
a580 1
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"
d584 1
a584 1
"Directory ${TESTDIR}/cvsroot/first-dir/sdir/ssdir added to the repository"
d606 1
a606 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
d609 1
a609 1
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d611 1
a611 1
done"
d615 1
a615 1
${PROG} \[[a-z]* aborted\]: failed to set tag BASE to revision 1\.1 in ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v"
d622 1
a622 1
"Index: sdir/ssdir/ssfile
d624 1
a624 1
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
d633 1
a633 1
${PLUS} ssfile line 2"
d635 1
a635 1
"Index: sdir/ssdir/ssfile
d637 1
a637 1
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
d646 1
a646 1
${PLUS} ssfile line 2"
d648 2
a649 2
"Checking in sdir/ssdir/ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d651 1
a651 1
done"
d661 2
a662 2
"Checking in ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d664 1
a664 1
done"
d666 2
a667 2
"Checking in ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d669 1
a669 1
done"
d673 2
a674 2
"Checking in ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d676 1
a676 1
done"
d679 1
a679 1
"Index: sdir/ssdir/ssfile
d681 1
a681 1
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
d684 1
a684 1
diff -r1\.2 -r1\.3"
d689 2
a690 2
	    "${testcvs} -q -d ${TESTDIR}/nonexist update" \
"${PROG}: cannot access cvs root ${TESTDIR}/nonexist: .*"
d692 2
a693 2
	    "${testcvs} -q -d ${TESTDIR}/nonexist update" \
"${PROG} \[[a-z]* aborted\]: ${TESTDIR}/nonexist/CVSROOT: .*"
d715 1
a715 1
"RCS file: ${TESTDIR}/cvsroot/\./topfile,v
d718 1
a718 1
${TESTDIR}/cvsroot/\./topfile,v  <--  topfile
d720 1
a720 1
done"
d722 1
a722 1
	  rm -r 1
d727 1
a727 1
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
d729 1
a729 1
	  rm -r 2
d743 2
a744 2
"Directory ${TESTDIR}/cvsroot/first-dir/sdir1 added to the repository
Directory ${TESTDIR}/cvsroot/first-dir/sdir2 added to the repository"
d780 1
a780 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir1/sfile1,v
d783 1
a783 1
${TESTDIR}/cvsroot/first-dir/sdir1/sfile1,v  <--  sfile1
d786 1
a786 1
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir2/sfile2,v
d789 1
a789 1
${TESTDIR}/cvsroot/first-dir/sdir2/sfile2,v  <--  sfile2
d791 1
a791 1
done"
d794 2
a795 2
"Checking in sdir1/sfile1;
${TESTDIR}/cvsroot/first-dir/sdir1/sfile1,v  <--  sfile1
d797 1
a797 1
done"
d802 2
a803 2
"Checking in sdir2/sfile2;
${TESTDIR}/cvsroot/first-dir/sdir2/sfile2,v  <--  sfile2
d805 1
a805 1
done"
d818 1
a818 1
	  rm -r first-dir1
d820 1
a820 1
	  rm -r first-dir
d835 1
a835 1
	  rm -r newdir
d865 1
a865 1
"RCS file: ${TESTDIR}/cvsroot/second-dir/aa,v
d868 1
a868 1
${TESTDIR}/cvsroot/second-dir/aa,v  <--  aa
d870 1
a870 1
done"
d872 1
a872 1
	  rm -r 1
d893 1
a893 1
"RCS file: ${TESTDIR}/cvsroot/CVSROOT/Emptydir/emptyfile,v
d896 1
a896 1
${TESTDIR}/cvsroot/CVSROOT/Emptydir/emptyfile,v  <--  emptyfile
d898 1
a898 12
done"
	  cd ..

	  mkdir 1; cd 1
	  # "cvs admin" tests are scattered around a bit.  Here we test
	  # ability to reject an unrecognized option.  The "keyword"
	  # test has a test of "cvs admin -l" and the "binfiles" test
	  # has a test of "cvs admin -k".  Note that -H is an illegal
	  # option.  It probably should be an error message.  But 
	  # currently it is one error message for each file operated on,
	  # which in this case is zero files.
	  dotest basicb-21 "${testcvs} -q admin -H" ""
d900 1
a900 8
	  rmdir 1

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  rm -r test2
a903 1
	  rm -rf ${CVSROOT_DIRNAME}/CVSROOT/Emptydir
d907 9
a915 6
	basic1)
	  # first dive - add a files, first singly, then in a group.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  # check out an empty directory
	  dotest basic1-1 "${testcvs} -q co first-dir" ''
d917 6
a922 26
	  cd first-dir
	  echo file2 >file2
	  echo file3 >file3
	  echo file4 >file4
	  echo file5 >file5

	  dotest basic1-14-add-add "${testcvs} add file2 file3 file4 file5" \
"${PROG} [a-z]*: scheduling file \`file2' for addition
${PROG} [a-z]*: scheduling file \`file3' for addition
${PROG} [a-z]*: scheduling file \`file4' for addition
${PROG} [a-z]*: scheduling file \`file5' for addition
${PROG} [a-z]*: use 'cvs commit' to add these files permanently"
	  dotest basic1-15-add-add \
"${testcvs} -q update file2 file3 file4 file5" \
"A file2
A file3
A file4
A file5"
	  dotest basic1-16-add-add "${testcvs} -q update" \
"A file2
A file3
A file4
A file5"
	  dotest basic1-17-add-add "${testcvs} -q status" \
"===================================================================
File: file2            	Status: Locally Added
d924 79
a1002 5
   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)
d1004 9
a1012 2
===================================================================
File: file3            	Status: Locally Added
d1014 4
a1017 5
   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)
d1019 3
a1021 325
===================================================================
File: file4            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file5            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest basic1-18-add-add "${testcvs} -q log" \
"${PROG} [a-z]*: file2 has been added, but not committed
${PROG} [a-z]*: file3 has been added, but not committed
${PROG} [a-z]*: file4 has been added, but not committed
${PROG} [a-z]*: file5 has been added, but not committed"
	  cd ..
	  dotest basic1-21-add-add "${testcvs} -q update" \
"A first-dir/file2
A first-dir/file3
A first-dir/file4
A first-dir/file5"
	  # FIXCVS?  Shouldn't this read first-dir/file2 instead of file2?
	  dotest basic1-22-add-add "${testcvs} log first-dir" \
"${PROG} [a-z]*: Logging first-dir
${PROG} [a-z]*: file2 has been added, but not committed
${PROG} [a-z]*: file3 has been added, but not committed
${PROG} [a-z]*: file4 has been added, but not committed
${PROG} [a-z]*: file5 has been added, but not committed"
	  dotest basic1-23-add-add "${testcvs} status first-dir" \
"${PROG} [a-z]*: Examining first-dir
===================================================================
File: file2            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file4            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file5            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest basic1-24-add-add "${testcvs} update first-dir" \
"${PROG} [a-z]*: Updating first-dir
A first-dir/file2
A first-dir/file3
A first-dir/file4
A first-dir/file5"
	  dotest basic1-27-add-add "${testcvs} co first-dir" \
"${PROG} [a-z]*: Updating first-dir
A first-dir/file2
A first-dir/file3
A first-dir/file4
A first-dir/file5"
	  cd first-dir
	  dotest basic1-14-add-ci \
"${testcvs} commit -m test file2 file3 file4 file5" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file3,v
done
Checking in file3;
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
done
Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file5,v
done
Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
initial revision: 1\.1
done"
	  dotest basic1-15-add-ci \
"${testcvs} -q update file2 file3 file4 file5" ''
	  dotest basic1-16-add-ci "${testcvs} -q update" ''
	  dotest basic1-17-add-ci "${testcvs} -q status" \
"===================================================================
File: file2            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file3,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file4            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file4,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file5            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file5,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  # The "log" tests and friends probably already test the output 
	  # from log quite adequately.
	  # Note: using dotest fails here.  It seems to be related
	  # to the output being sufficiently large (Red Hat 4.1).
	  # dotest basic1-18-add-ci "${testcvs} log" "${DOTSTAR}"
	  if ${testcvs} -q log >>${LOGFILE}; then
	    pass basic1-18-add-ci
	  else
	    pass basic1-18-add-ci
	  fi
	  cd ..
	  dotest basic1-21-add-ci "${testcvs} -q update" ''
	  # See test basic1-18-add-ci for explanation of non-use of dotest.
	  if ${testcvs} -q log first-dir >>${LOGFILE}; then
	    pass basic1-22-add-ci
	  else
	    pass basic1-22-add-ci
	  fi
	  # At least for the moment I am going to consider 17-add-ci
	  # an adequate test of the output here.
	  # See test basic1-18-add-ci for explanation of non-use of dotest.
	  if ${testcvs} -q status first-dir >>${LOGFILE}; then
	    pass basic1-23-add-ci
	  else
	    pass basic1-23-add-ci
	  fi
	  dotest basic1-24-add-ci "${testcvs} -q update first-dir" ''
	  dotest basic1-27-add-ci "${testcvs} -q co first-dir" ''

	  cd first-dir
	  rm file2 file3 file4 file5
	  dotest basic1-14-rm-rm "${testcvs} rm file2 file3 file4 file5" \
"${PROG} [a-z]*: scheduling .file2. for removal
${PROG} [a-z]*: scheduling .file3. for removal
${PROG} [a-z]*: scheduling .file4. for removal
${PROG} [a-z]*: scheduling .file5. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove these files permanently"
	  # 15-rm-rm was commented out.  Why?
	  dotest basic1-15-rm-rm \
"${testcvs} -q update file2 file3 file4 file5" \
"R file2
R file3
R file4
R file5"
	  dotest basic1-16-rm-rm "${testcvs} -q update" \
"R file2
R file3
R file4
R file5"
	  dotest basic1-17-rm-rm "${testcvs} -q status" \
"===================================================================
File: no file file2		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file3		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file3,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file4		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file4,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file5		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file5,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  # Would be nice to test that real logs appear (with dead state
	  # and all), either here or someplace like log2 tests.
	  if ${testcvs} -q log >>${LOGFILE}; then
	    pass basic1-18-rm-rm
	  else
	    fail basic1-18-rm-rm
	  fi
	  cd ..
	  dotest basic1-21-rm-rm "${testcvs} -q update" \
"R first-dir/file2
R first-dir/file3
R first-dir/file4
R first-dir/file5"
	  if ${testcvs} -q log first-dir >>${LOGFILE}; then
	    pass basic1-22-rm-rm
	  else
	    fail basic1-22-rm-rm
	  fi
	  if ${testcvs} -q status first-dir >>${LOGFILE}; then
	    pass basic1-23-rm-rm
	  else
	    fail basic1-23-rm-rm
	  fi
	  dotest basic1-24-rm-rm "${testcvs} -q update first-dir" \
"R first-dir/file2
R first-dir/file3
R first-dir/file4
R first-dir/file5"
	  dotest basic1-27-rm-rm "${testcvs} -q co first-dir" \
"R first-dir/file2
R first-dir/file3
R first-dir/file4
R first-dir/file5"
	  cd first-dir
	  dotest basic1-14-rm-ci "${testcvs} -q commit -m test" \
"Removing file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: delete; previous revision: 1\.1
done
Removing file3;
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
new revision: delete; previous revision: 1\.1
done
Removing file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
new revision: delete; previous revision: 1\.1
done
Removing file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
new revision: delete; previous revision: 1\.1
done"
	  dotest basic1-15-rm-ci \
"${testcvs} -q update file2 file3 file4 file5" ''
	  dotest basic1-16-rm-ci "${testcvs} -q update" ''
	  dotest basic1-17-rm-ci "${testcvs} -q status" ''
	  # Would be nice to test that real logs appear (with dead state
	  # and all), either here or someplace like log2 tests.
	  if ${testcvs} -q log >>${LOGFILE}; then
	    pass basic1-18-rm-ci
	  else
	    fail basic1-18-rm-ci
	  fi
	  cd ..
	  dotest basic1-21-rm-ci "${testcvs} -q update" ''
	  if ${testcvs} -q log first-dir >>${LOGFILE}; then
	    pass basic1-22-rm-ci
	  else
	    fail basic1-22-rm-ci
	  fi
	  if ${testcvs} -q status first-dir >>${LOGFILE}; then
	    pass basic1-23-rm-ci
	  else
	    fail basic1-23-rm-ci
	  fi
	  dotest basic1-24-rm-ci "${testcvs} -q update first-dir" ''
	  dotest basic1-27-rm-ci "${testcvs} -q co first-dir" ''
	  cd first-dir
	  # All the files are removed, so nothing gets tagged.
	  dotest basic1-28 "${testcvs} -q tag first-dive" ''
	  cd ..
	  cd ..

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d1031 1
a1031 1
"Directory ${TESTDIR}/cvsroot/first-dir/dir1[/dir0-9]* added to the repository"
d1039 2
a1040 2
	  dotest_lit deep-4 "${testcvs} -q ci -m add-them first-dir" <<HERE
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/file1,v
d1043 1
a1043 1
${TESTDIR}/cvsroot/first-dir/dir1/file1,v  <--  file1
d1046 1
a1046 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/file1,v
d1049 1
a1049 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/file1,v  <--  file1
d1052 1
a1052 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/file1,v
d1055 1
a1055 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/file1,v  <--  file1
d1058 1
a1058 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/file1,v
d1061 1
a1061 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/file1,v  <--  file1
d1064 1
a1064 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v
d1067 1
a1067 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
d1070 1
a1070 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v
d1073 1
a1073 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
d1076 1
a1076 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v
d1079 1
a1079 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
d1082 1
a1082 1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v
d1085 1
a1085 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
d1095 2
a1096 2
	  dotest deep-4a1 "${testcvs} -q ci -m rm-it" "Removing file1;
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
d1098 1
a1098 1
done"
d1111 1
a1111 1
	  rm -r dir6
d1126 2
a1127 2
	  dotest deep-rm4 "${testcvs} -q ci -m rm-it" "Removing dir7/file1;
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
d1129 1
a1129 1
done"
d1142 2
a1143 2
"Removing dir5/file1;
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
d1147 1
a1147 1
${TESTDIR}/cvsroot/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
d1149 1
a1149 1
done"
d1351 1
d1372 1
a1372 1
		rm -r 1dir first-dir
d1388 1
a1388 1
		mkdir first-dir.cpy ; (cd first-dir ; tar cf - . | (cd ../first-dir.cpy ; tar xf -))
d1402 1
a1402 1
"N second-dir/file14
d1405 1
a1405 1
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/dir1
d1409 1
a1409 1
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/dir1/dir2
d1414 1
a1414 1
No conflicts created by this import"
d1431 1
a1431 1
		rm -r second-dir
d1433 1
a1433 1
		rm -r export-dir first-dir
d1435 1
a1435 1
		(cd first-dir.cpy ; tar cf - . | (cd ../first-dir ; tar xf -))
d1482 1
a1482 1
		rm -r 1dir first-dir
d1487 1
a1487 1
		# \(${TESTDIR}\|<remote>\) is that we are trying to
d1496 38
a1533 38
"O [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir           =first-dir= ${TMPPWD}/\*
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir           == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1      == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1/dir2 == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1/dir2 == ${TMPPWD}
F [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]*                     =first-dir= ${TMPPWD}/\*
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* \[1\.1\] first-dir           =first-dir= ${TMPPWD}/\*
U [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == ${TMPPWD}/first-dir
U [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file7     first-dir           == ${TMPPWD}/first-dir" \
"O [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir           =first-dir= <remote>/\*
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file6     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file7     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir           == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1      == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.1 file14    first-dir/dir1/dir2 == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* 1\.2 file6     first-dir/dir1/dir2 == <remote>
F [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]*                     =first-dir= <remote>/\*
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* ${PLUS}0000 [a-z0-9@@][a-z0-9@@]* \[1\.1\] first-dir           =first-dir= <remote>/\*"
d1565 2
a1566 2
"Checking in foo;
${TESTDIR}/cvsroot/trdiff/foo,v  <--  foo
d1568 1
a1568 1
done"
d1577 1
a1577 1
"RCS file: ${TESTDIR}/cvsroot/trdiff/new,v
d1580 1
a1580 1
${TESTDIR}/cvsroot/trdiff/new,v  <--  new
d1582 1
a1582 1
done"
d1591 1
a1591 1
"===================================================================
d1595 1
a1595 1
   Repository revision:	1\.2	${TESTDIR}/cvsroot/trdiff/foo,v
d1603 1
a1603 1
	TRDIFF                   	(branch: 1\.1\.1)"
d1606 1
a1606 1
		rm -r trdiff
d1635 1
a1635 1
#		  echo Keeping ${TESTDIR} and exiting due to --keep
d1640 1
a1640 1
		rm -r testimport
d1665 1
a1665 1
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"
d1672 1
a1672 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/sfile,v
d1675 1
a1675 1
${TESTDIR}/cvsroot/first-dir/subdir/sfile,v  <--  sfile
d1677 1
a1677 1
done"
d1683 2
a1684 2
"Removing sfile;
${TESTDIR}/cvsroot/first-dir/subdir/sfile,v  <--  sfile
d1686 1
a1686 1
done"
d1758 1
a1758 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d1761 1
a1761 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d1763 1
a1763 1
done"
d1769 2
a1770 2
"Removing file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d1772 1
a1772 1
done"
d1902 1
a1902 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d1906 2
a1907 2
${PROG} [a-z]*: scheduling file2 for removal
U file3"
d1934 2
a1935 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d1939 1
a1939 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d1943 1
a1943 1
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
d1945 1
a1945 1
done"
d1952 1
a1952 1
		rm -r 2
d2037 1
a2037 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2040 1
a2040 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2042 1
a2042 1
done"
d2074 2
a2075 2
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2077 1
a2077 1
done"
d2149 2
a2150 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2152 1
a2152 1
done"
d2163 1
a2163 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d2166 1
a2166 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d2168 1
a2168 1
done"
d2186 2
a2187 2
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d2189 1
a2189 1
done"
d2197 1
a2197 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file3,v
d2200 1
a2200 1
${TESTDIR}/cvsroot/first-dir/Attic/file3,v  <--  file3
d2202 1
a2202 1
done"
d2223 1
a2223 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2240 1
a2240 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2317 2
a2318 2
	  dotest_lit branches-3 "${testcvs} -q ci -m add-it" <<HERE
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2321 1
a2321 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2324 1
a2324 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d2327 1
a2327 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d2330 1
a2330 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file3,v
d2333 1
a2333 1
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
d2336 1
a2336 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d2339 1
a2339 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2345 2
a2346 2
"Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2348 1
a2348 1
done"
d2360 2
a2361 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2365 1
a2365 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d2369 1
a2369 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2371 1
a2371 1
done"
d2380 2
a2381 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2385 1
a2385 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2387 1
a2387 1
done"
d2401 2
a2402 2
"Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2404 1
a2404 1
done"
d2415 2
a2416 2
"Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2418 1
a2418 1
done"
d2420 2
a2421 2
"
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d2435 1
a2435 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: ${PLUS}1 -1
d2439 1
a2439 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: ${PLUS}1 -1
d2448 1
a2448 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: ${PLUS}1 -1
d2452 1
a2452 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: ${PLUS}1 -1
d2457 1
a2457 1
date: [0-9/: ]*;  author: [a-z0-9@@][a-z0-9@@]*;  state: Exp;  lines: ${PLUS}1 -1
d2459 1
a2459 1
============================================================================="
d2462 1
a2462 1
"Index: file4
d2464 1
a2464 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d2474 1
a2474 1
! 4:trunk-3"
d2477 1
a2477 1
"Index: file4
d2479 1
a2479 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d2489 1
a2489 1
! 4:br1"
d2492 1
a2492 1
	    "RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2496 1
a2496 1
rcsmerge: warning: conflicts during merge"
d2505 1
a2505 1
	    echo Keeping ${TESTDIR} and exiting due to --keep
d2523 2
a2524 2
	  dotest_lit multibranch-3 "${testcvs} -q ci -m add-it" <<HERE
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2527 1
a2527 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2540 2
a2541 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2543 1
a2543 1
done"
d2547 2
a2548 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d2550 1
a2550 1
done"
d2559 1
a2559 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d2588 1
a2588 1
	    echo Keeping ${TESTDIR} and exiting due to --keep
d2767 2
a2768 2
"${PROG} [a-z]*: file first-dir/imported-f1 is present in revision junk-2_0
RCS file: ${TESTDIR}/cvsroot/first-dir/imported-f2,v
d2772 1
a2772 1
rcsmerge: warning: conflicts during merge"
d2800 2
a2801 4
		cd ..
		rm -r first-dir
		rm -rf ${CVSROOT_DIRNAME}/first-dir
		rm -r import-dir
a2805 1
	  # See also binfile2, which does similar things with binary files.
d2869 1
a2869 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file3,v
d2872 1
a2872 1
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
d2875 1
a2875 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
d2878 1
a2878 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2881 1
a2881 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file6,v
d2884 1
a2884 1
${TESTDIR}/cvsroot/first-dir/file6,v  <--  file6
d2887 1
a2887 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file8,v
d2890 1
a2890 1
${TESTDIR}/cvsroot/first-dir/file8,v  <--  file8
d2892 1
a2892 1
done"
d2915 1
a2915 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d2918 1
a2918 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d2922 1
a2922 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2926 1
a2926 1
${TESTDIR}/cvsroot/first-dir/file6,v  <--  file6
d2929 1
a2929 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file7,v
d2932 1
a2932 1
${TESTDIR}/cvsroot/first-dir/file7,v  <--  file7
d2936 1
a2936 1
${TESTDIR}/cvsroot/first-dir/file8,v  <--  file8
d2938 1
a2938 1
done"
d2962 2
a2963 2
"Checking in file3;
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
d2967 1
a2967 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d2970 1
a2970 1
RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file5,v
d2973 1
a2973 1
${TESTDIR}/cvsroot/first-dir/Attic/file5,v  <--  file5
d2977 1
a2977 1
${TESTDIR}/cvsroot/first-dir/Attic/file6,v  <--  file6
d2979 1
a2979 1
done"
d3004 1
a3004 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file1,v
d3007 1
a3007 1
${TESTDIR}/cvsroot/first-dir/Attic/file1,v  <--  file1
d3011 1
a3011 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d3015 1
a3015 1
${TESTDIR}/cvsroot/first-dir/file3,v  <--  file3
d3019 1
a3019 1
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
d3023 1
a3023 1
${TESTDIR}/cvsroot/first-dir/Attic/file5,v  <--  file5
d3027 1
a3027 1
${TESTDIR}/cvsroot/first-dir/Attic/file6,v  <--  file6
d3029 1
a3029 1
done"
d3086 1
a3086 1
	  rm -r first-dir
d3088 1
a3088 1
"U first-dir/file1
d3090 1
a3090 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d3095 1
a3095 1
${PROG} [a-z]*: scheduling first-dir/file3 for removal
d3097 2
a3098 2
${PROG} [a-z]*: file first-dir/file4 has been modified, but has been removed in revision branch
U first-dir/file7"
d3110 1
a3110 1
	  rm -r first-dir
d3123 2
a3124 2
"U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d3128 1
a3128 1
${PROG} [a-z]*: scheduling file3 for removal
d3130 1
a3130 1
${PROG} [a-z]*: file file4 is locally modified, but has been removed in revision branch"
d3141 1
a3141 2
	  rm -r 1 2 3
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d3194 1
a3194 3
		cd ..
		rm -r first-dir
		rm -rf ${CVSROOT_DIRNAME}/first-dir
d3213 1
a3213 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
d3216 1
a3216 1
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3218 1
a3218 1
done"
d3225 1
a3225 1
	  rm -r first-dir
d3243 2
a3244 2
"Removing a;
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3246 1
a3246 1
done"
d3252 1
a3252 1
	  rm -r first-dir
a3259 2
	  # The "Need Checkout" output is what CVS does if configured
	  # --disable-server.
d3262 1
a3262 1
File: a                	Status: Needs \(Patch\|Checkout\)
d3265 1
a3265 1
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/a,v
d3279 1
a3279 2
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d3297 1
a3297 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
d3300 1
a3300 1
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3302 1
a3302 1
done"
d3311 1
a3311 1
"${PROG} [a-z]*: Updating first-dir
d3314 1
a3314 1
RCS:  ${TMPPWD}/cvsroot/first-dir/a,v
d3316 1
a3316 1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*"
d3333 1
a3333 1
"Directory ${TESTDIR}/cvsroot/first-dir/dir1 added to the repository"
d3335 2
a3336 2
"Checking in a;
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3338 1
a3338 1
done"
d3348 1
a3348 1
"${PROG} [a-z]*: Updating first-dir
d3351 1
a3351 1
RCS:  ${TMPPWD}/cvsroot/first-dir/a,v
d3354 1
a3354 1
add a line"
d3372 1
a3372 1
   Repository revision:	1\.2	${TESTDIR}/cvsroot/first-dir/a,v
d3377 1
a3377 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
d3382 1
a3382 1
${PROG} [a-z]*: conflicts found in a
d3384 5
a3388 5
${QUESTION} dir1
${QUESTION} sdir" \
"${QUESTION} dir1
${QUESTION} sdir
RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
d3393 2
a3394 2
${PROG} [a-z]*: conflicts found in a
C a"
d3402 1
a3402 1
   Repository revision:	1\.2	${TESTDIR}/cvsroot/first-dir/a,v
d3417 1
a3417 1
   Repository revision:	1\.2	${TESTDIR}/cvsroot/first-dir/a,v
d3431 1
a3431 1
   Repository revision:	1\.2	${TESTDIR}/cvsroot/first-dir/a,v
d3437 1
a3437 1
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3445 1
a3445 1
   Repository revision:	1\.3	${TESTDIR}/cvsroot/first-dir/a,v
d3519 1
a3519 1
		rm -r 1 2 3 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
d3540 1
a3540 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
d3543 1
a3543 1
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3546 1
a3546 1
RCS file: ${TESTDIR}/cvsroot/first-dir/abc,v
d3549 1
a3549 1
${TESTDIR}/cvsroot/first-dir/abc,v  <--  abc
d3551 1
a3551 1
done"
d3567 2
a3568 2
"Checking in a;
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
d3570 1
a3570 1
done"
d3595 2
a3596 2
"Removing abc;
${TESTDIR}/cvsroot/first-dir/abc,v  <--  abc
d3598 1
a3598 1
done"
d3616 1
a3616 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa.c,v
d3619 1
a3619 1
${TESTDIR}/cvsroot/first-dir/aa.c,v  <--  aa.c
d3621 1
a3621 1
done"
d3639 1
a3639 1
	  rm -r 1 2 ; rm -rf ${CVSROOT_DIRNAME}/first-dir
d3813 1
a3813 1
	  rm -r dirmodule
d3865 1
a3865 1
	  rm -r 1
d3879 1
a3879 1
	  rm -r 2
d3889 1
a3889 1
	  rm -r 1
d3908 1
a3908 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d3911 1
a3911 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d3914 1
a3914 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
d3917 1
a3917 1
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d3919 1
a3919 1
done"
d3922 1
a3922 1
	  rm -r first-dir
d3928 1
a3928 1
	  rm -r 1
d3949 1
a3949 1
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
d3982 1
a3982 1
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
d3993 1
a3993 1
	  rm -r CVSROOT
d3995 1
a3995 1
	  rm -r 1
d4010 1
a4010 1
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
d4018 1
a4018 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d4021 1
a4021 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d4023 1
a4023 1
done"
d4039 1
a4039 1
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
d4046 1
a4046 1
	  rm -r first-dir
d4059 2
a4060 2
"${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/suba
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/suba/subb
d4090 1
a4090 1
"RCS file: ${TESTDIR}/cvsroot/second-dir/suba/subb/fileb,v
d4093 1
a4093 1
${TESTDIR}/cvsroot/second-dir/suba/subb/fileb,v  <--  fileb
d4095 1
a4095 1
done"
a4134 9

	  # While we are doing things like twisted uses of '/' (e.g.
	  # modules3-12), try this one.
	  if test "x$remote" = xyes; then
	    dotest_fail modules3-11b \
"${testcvs} -q update ${TESTDIR}/1/src/sub1/sub2/sub3/dir/file1" \
"${PROG} .server aborted.: absolute pathname .${TESTDIR}/1/src/sub1/sub2/sub3/dir/file1. illegal for server"
	  fi # end of remote-only tests

d4196 1
a4196 1
	    cd ..; rm -r a-dir
d4226 1
a4226 3
	    cd ..
	    rm -r a-dir
	    rm -rf ${CVSROOT_DIRNAME}/a-dir
d4298 1
a4298 2
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/1dir
a4495 1
	  # Since first-dir/abb is readonly, use -f.
d4517 1
a4517 1
	    echo Keeping ${TESTDIR} and exiting due to --keep
d4521 1
a4521 3
	  # Use -f because of the readonly files.
	  rm -rf 1 2 3
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d4572 1
a4572 3
	  # Use -f because of the readonly files.
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d4627 1
a4627 3
	  # Use -f because of the readonly files.
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d4640 1
a4640 1
"${DOTSTAR}CS file: ${TESTDIR}/cvsroot/CVSROOT/cvsignore,v
d4643 1
a4643 1
${TESTDIR}/cvsroot/CVSROOT/cvsignore,v  <--  cvsignore
d4646 1
a4646 1
${PROG} [a-z]*: Rebuilding administrative file database"
d4691 1
a4691 1
	  rm -r dir-to-import
d4784 1
a4784 1
	  rm -r 1
d4803 1
a4803 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
d4806 1
a4806 1
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d4808 1
a4808 1
done"
d4818 1
a4818 1
"===================================================================
d4822 1
a4822 1
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/binfile,v
d4825 1
a4825 1
   Sticky Options:	-kb"
d4836 1
a4836 1
"===================================================================
d4840 1
a4840 1
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/binfile,v
d4843 1
a4843 1
   Sticky Options:	-kb"
d4845 1
a4845 1
	  rm -r 3
d4850 2
a4851 2
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d4853 1
a4853 1
done"
d4861 2
a4862 2
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d4864 1
a4864 1
done"
d4878 2
a4879 2
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d4881 1
a4881 1
done"
d4895 1
a4895 1
	  rm -r 1
d4903 1
a4903 1
"===================================================================
d4907 1
a4907 1
   Repository revision:	1\.4	${TESTDIR}/cvsroot/first-dir/binfile,v
d4910 1
a4910 1
   Sticky Options:	-kb"
d4912 1
a4912 1
	  rm -r 3
d4917 2
a4918 2
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d4920 1
a4920 1
done"
d4924 1
a4924 1
"===================================================================
d4928 1
a4928 1
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
d4931 1
a4931 1
   Sticky Options:	-kb"
d4933 2
a4934 2
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
done"
d4941 1
a4941 1
"===================================================================
d4945 1
a4945 1
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
d4948 1
a4948 1
   Sticky Options:	-kb"
d4952 1
a4952 1
"===================================================================
d4956 1
a4956 1
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
d4959 1
a4959 1
   Sticky Options:	-kv"
d4966 1
a4966 1
	    "RCS file: ${TESTDIR}/cvsroot/first-dir/nibfile,v
d4969 1
a4969 1
${TESTDIR}/cvsroot/first-dir/nibfile,v  <--  nibfile
d4971 1
a4971 1
done"
d4975 1
a4975 1
"===================================================================
d4979 1
a4979 1
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
d4982 1
a4982 1
   Sticky Options:	-kb"
a4989 52
	binfiles2)
	  # Test cvs's ability to handle binary files, particularly branching
	  # and joining.  The key thing we are worrying about is that CVS
	  # doesn't print "cannot merge binary files" or some such, in 
	  # situations where no merging is required.
	  # See also "join" which does this with non-binary files.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest binfiles2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  # FIXCVS: unless a branch has at least one file on it,
	  # tag_check_valid won't know it exists.  So creating a
	  # file here is a workaround.
	  touch dummy
	  dotest binfiles2-1a "${testcvs} add dummy" \
"${PROG} [a-z]*: scheduling file .dummy. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest binfiles2-1b "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/dummy,v
done
Checking in dummy;
${TESTDIR}/cvsroot/first-dir/dummy,v  <--  dummy
initial revision: 1\.1
done"
	  dotest binfiles2-2 "${testcvs} -q tag -b br" 'T dummy'
	  dotest binfiles2-3 "${testcvs} -q update -r br" ''
	  awk 'BEGIN { printf "%c%c%c%c%c%c", 2, 10, 137, 0, 13, 10 }' \
	    </dev/null >../binfile
	  cp ../binfile binfile.dat
	  dotest binfiles2-4 "${testcvs} add -kb binfile.dat" \
"${PROG} [a-z]*: scheduling file .binfile\.dat. for addition on branch .br.
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest binfiles2-5 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/binfile\.dat,v
done
Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/Attic/binfile\.dat,v  <--  binfile\.dat
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest binfiles2-6 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: binfile\.dat is not (any longer) pertinent"
	  dotest_fail binfiles2-7 "test -f binfile.dat" ''
	  dotest binfiles2-8 "${testcvs} -q update -j br" "U binfile.dat"
	  dotest binfiles2-9 "cmp ../binfile binfile.dat"
	  cd ..
	  cd ..

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1
	  ;;

d5011 1
a5011 1
	  rm -r dir-to-import
d5015 1
a5015 1
"===================================================================
d5019 1
a5019 1
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.c,v
d5028 1
a5028 1
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.exe,v
d5031 2
a5032 70
   Sticky Options:	-kb"
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	mwrap)
	  # Tests relating to the -m wrappers options.  -k tests are in
	  # binwrap and -t/-f tests haven't been written yet.
	  dotest mwrap-c1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  echo "* -m 'COPY'" >>cvswrappers
	  dotest mwrap-c2 "${testcvs} -q ci -m wrapper-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  mkdir m1; cd m1
	  dotest mwrap-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest mwrap-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  dotest mwrap-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest mwrap-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done"
	  cd ../..
	  mkdir m2; cd m2
	  dotest mwrap-5 "${testcvs} -q co first-dir" "U first-dir/aa"
	  cd first-dir
	  echo "changed in m2" >aa
	  dotest mwrap-6 "${testcvs} -q ci -m m2-mod" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../..
	  cd m1/first-dir
	  echo "changed in m1" >aa
	  dotest_fail mwrap-7 "${testcvs} -nq update" "C aa"
	  dotest_fail mwrap-8 "${testcvs} -q update" \
"${PROG} [a-z]*: A -m .COPY. wrapper is specified
${PROG} [a-z]*: but file aa needs merge
${PROG} \[[a-z]* aborted\]: You probably want to avoid -m .COPY. wrappers"
	  # Under the old, dangerous behavior, this would have been
	  # "changed in m2" -- that is, the changes in the working directory
	  # would have been clobbered (!).
	  dotest mwrap-9 "cat aa" "changed in m1"
	  cd ../..
	  cd CVSROOT
	  echo '# comment out' >cvswrappers
	  dotest mwrap-ce "${testcvs} -q ci -m wrapper-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  rm -r CVSROOT
	  rm -r m1 m2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d5055 2
a5056 2
"Checking in loginfo;
${TESTDIR}/cvsroot/CVSROOT/loginfo,v  <--  loginfo
d5059 1
a5059 1
${PROG} [a-z]*: Rebuilding administrative file database"
d5071 1
a5071 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5074 1
a5074 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5077 1
a5077 1
${PROG} [a-z]*: loginfo:1: no such user variable \${=ZEE}"
d5080 2
a5081 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5083 1
a5083 1
done"
d5085 1
a5085 1
	  dotest info-9 "cat $TESTDIR/testlog" "xenv-valueyz=[a-z0-9@@][a-z0-9@@]*=${TESTDIR}/cvsroot="
d5101 1
a5101 1
${TESTDIR}/cvsroot/CVSROOT/loginfo,v  <--  loginfo
d5120 1
a5120 1
${TESTDIR}/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
d5137 1
a5137 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5156 1
a5156 1
${TESTDIR}/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
d5193 1
a5193 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5196 1
a5196 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5198 1
a5198 1
done"
d5218 2
a5219 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5221 1
a5221 1
done"
d5234 1
a5234 2
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d5255 1
a5255 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5258 1
a5258 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5260 1
a5260 1
done"
d5264 2
a5265 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5267 1
a5267 1
done"
d5273 2
a5274 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5276 1
a5276 1
done"
d5282 2
a5283 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5285 1
a5285 1
done"
d5291 2
a5292 2
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5294 1
a5294 1
done"
d5298 2
a5299 2
	  log_header="
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5304 1
a5304 1
access list:"
d5460 1
a5460 2
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d5479 1
a5479 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5482 1
a5482 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5484 3
a5486 3
done"
	  dotest log2-4 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5498 1
a5498 1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
d5500 1
a5500 1
============================================================================="
d5503 1
a5503 2
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d5520 1
a5520 1
"${PROG} \[[a-z]* aborted\]: ${TESTDIR}/crerepos/CVSROOT: .*"
d5526 1
a5526 1
"${PROG} \[[a-z]* aborted\]: ${TESTDIR}/crerepos/CVSROOT: .*"
d5549 1
a5549 1
	    rm -r CVS
d5568 1
a5568 1
	    rm -r 1
d5574 1
a5574 1
	    rm -r 1
d5582 1
a5582 1
	    rm -r 1
d5589 1
a5589 1
	    rm -r 1
d5693 1
a5693 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5727 1
a5727 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5748 1
a5748 1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
a5770 1
	  cd ..
d5772 1
a5772 2
	  rm -r first-dir ${TESTDIR}/rcs4.tmp
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d5802 1
a5802 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d5805 1
a5805 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d5807 1
a5807 1
done"
d5809 1
a5809 1
	  rm -r first-dir
d5813 1
a5813 1
	    echo Keeping ${TESTDIR} and exiting due to --keep
d5817 1
a5817 1
	  rm -r first-dir
d5839 1
a5839 1
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
d5846 1
a5846 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
d5849 1
a5849 1
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
d5851 2
a5852 2
done"
	  dotest modes-5 "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
d5859 2
a5860 2
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
d5862 1
a5862 1
done"
d5866 1
a5866 1
	  dotest modes-7 "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
d5870 1
a5870 1
	  chmod g=r,o= ${TESTDIR}/cvsroot/first-dir/aa,v
d5877 1
a5877 1
	  dotest modes-7b "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
d5889 1
a5889 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/ab,v
d5892 1
a5892 1
${TESTDIR}/cvsroot/first-dir/ab,v  <--  ab
d5894 1
a5894 1
done"
d5899 1
a5899 1
	    dotest modes-10 "ls -l ${TESTDIR}/cvsroot/first-dir/ab,v" \
d5902 1
a5902 1
	    dotest modes-10 "ls -l ${TESTDIR}/cvsroot/first-dir/ab,v" \
d5919 1
a5919 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/ac,v
d5922 1
a5922 1
${TESTDIR}/cvsroot/first-dir/Attic/ac,v  <--  ac
d5924 1
a5924 1
done"
d5930 1
a5930 1
"ls -l ${TESTDIR}/cvsroot/first-dir/Attic/ac,v" \
d5934 1
a5934 1
"ls -l ${TESTDIR}/cvsroot/first-dir/Attic/ac,v" \
d5939 1
a5939 2
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
a5943 140
	stamps)
	  # Test timestamps.
	  mkdir 1; cd 1
	  dotest stamps-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest stamps-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  echo '$''Id$' >kw
	  ls -l aa >${TESTDIR}/1/stamp.aa.touch
	  ls -l kw >${TESTDIR}/1/stamp.kw.touch
	  # "sleep 1" would suffice if we could assume ls --full-time, but
	  # that is as far as I know unique to GNU ls.  Is there some POSIX.2
	  # way to get the timestamp of a file, including the seconds?
	  sleep 60
	  dotest stamps-3 "${testcvs} add aa kw" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: scheduling file .kw. for addition
${PROG} [a-z]*: use .cvs commit. to add these files permanently"
	  ls -l aa >${TESTDIR}/1/stamp.aa.add
	  ls -l kw >${TESTDIR}/1/stamp.kw.add
	  # "cvs add" should not muck with the timestamp.
	  dotest stamps-4aa \
"cmp ${TESTDIR}/1/stamp.aa.touch ${TESTDIR}/1/stamp.aa.add" ''
	  dotest stamps-4kw \
"cmp ${TESTDIR}/1/stamp.kw.touch ${TESTDIR}/1/stamp.kw.add" ''
	  sleep 60
	  dotest stamps-5 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/kw,v
done
Checking in kw;
${TESTDIR}/cvsroot/first-dir/kw,v  <--  kw
initial revision: 1\.1
done"
	  ls -l aa >${TESTDIR}/1/stamp.aa.ci
	  ls -l kw >${TESTDIR}/1/stamp.kw.ci
	  # If there are no keywords, "cvs ci" leaves the timestamp alone
	  # If there are, it sets the timestamp to the date of the commit.
	  # I'm not sure how logical this is, but it is intentional.
	  # If we wanted to get fancy we would make sure the time as
	  # reported in "cvs log kw" matched stamp.kw.ci.  But that would
	  # be a lot of work.
	  dotest stamps-6aa \
	    "cmp ${TESTDIR}/1/stamp.aa.add ${TESTDIR}/1/stamp.aa.ci" ''
	  if cmp ${TESTDIR}/1/stamp.kw.add ${TESTDIR}/1/stamp.kw.ci >/dev/null
	  then
	    fail stamps-6kw
	  else
	    pass stamps-6kw
	  fi
	  cd ../..
	  sleep 60
	  mkdir 2
	  cd 2
	  dotest stamps-7 "${testcvs} -q get first-dir" "U first-dir/aa
U first-dir/kw"
	  cd first-dir
	  ls -l aa >${TESTDIR}/1/stamp.aa.get
	  ls -l kw >${TESTDIR}/1/stamp.kw.get
	  # On checkout, CVS should set the timestamp to the date that the
	  # file was committed.  Could check that the time as reported in
	  # "cvs log aa" matches stamp.aa.get, but that would be a lot of
	  # work.
	  if cmp ${TESTDIR}/1/stamp.aa.ci ${TESTDIR}/1/stamp.aa.get >/dev/null
	  then
	    fail stamps-8aa
	  else
	    pass stamps-8aa
	  fi
	  dotest stamps-8kw \
	    "cmp ${TESTDIR}/1/stamp.kw.ci ${TESTDIR}/1/stamp.kw.get" ''

	  # Now we want to see what "cvs update" does.
	  sleep 60
	  echo add a line >>aa
	  echo add a line >>kw
	  dotest stamps-9 "${testcvs} -q ci -m change-them" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done
Checking in kw;
${TESTDIR}/cvsroot/first-dir/kw,v  <--  kw
new revision: 1\.2; previous revision: 1\.1
done"
	  ls -l aa >${TESTDIR}/1/stamp.aa.ci2
	  ls -l kw >${TESTDIR}/1/stamp.kw.ci2
	  cd ../..
	  cd 1/first-dir
	  sleep 60
	  dotest stamps-10 "${testcvs} -q update" '[UP] aa
[UP] kw'
	  # this doesn't serve any function other than being able to
	  # look at it manually, as we have no machinery for dates being
	  # newer or older than other dates.
	  date >${TESTDIR}/1/stamp.debug.update
	  ls -l aa >${TESTDIR}/1/stamp.aa.update
	  ls -l kw >${TESTDIR}/1/stamp.kw.update
	  # stamp.aa.update and stamp.kw.update should both be approximately
	  # the same as stamp.debug.update.  Perhaps we could be testing
	  # this in a more fancy fashion by "touch stamp.before" before
	  # stamps-10, "touch stamp.after" after, and then using ls -t
	  # to check them.  But for now we just make sure that the *.update
	  # stamps differ from the *.ci2 ones.
	  # As for the rationale, this is so that if one updates and gets
	  # a new revision, then "make" will be sure to regard those files
	  # as newer than .o files which may be sitting around.
	  if cmp ${TESTDIR}/1/stamp.aa.update ${TESTDIR}/1/stamp.aa.ci2 \
	     >/dev/null
	  then
	    fail stamps-11aa
	  else
	    pass stamps-11aa
	  fi
	  if cmp ${TESTDIR}/1/stamp.kw.update ${TESTDIR}/1/stamp.kw.ci2 \
	     >/dev/null
	  then
	    fail stamps-11kw
	  else
	    pass stamps-11kw
	  fi

	  cd ../..

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d5986 1
a5986 2
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d6157 1
a6157 1
	    rm -r first-dir
d6223 1
a6223 73
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	toplevel)
	  # test the feature that cvs creates a CVS subdir also for
	  # the toplevel directory

	  # Some test, somewhere, is creating Emptydir.  That test
	  # should, perhaps, clean up for itself, but I don't know which
	  # one it is.
	  rm -rf ${CVSROOT_DIRNAME}/CVSROOT/Emptydir

	  mkdir 1; cd 1
	  dotest toplevel-1 "${testcvs} -q co -l ." ''
	  mkdir top-dir
	  dotest toplevel-2 "${testcvs} add top-dir" \
"Directory ${TESTDIR}/cvsroot/top-dir added to the repository"
	  cd top-dir

	  touch file1
	  dotest toplevel-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  dotest toplevel-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/top-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/top-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  cd ../..
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel-5 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"

	  dotest toplevel-6 "${testcvs} update top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  dotest toplevel-7 "${testcvs} update"  \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating top-dir"

	  dotest toplevel-8 "${testcvs} update -d top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  # FIXME: This test fails in cvs starting from 1.9.2 because
	  # it updates "file1" in "1".  Test modules3-7f also finds
	  # (and tolerates) this bug.  The second expect string below
	  # should be removed when this is fixed.  The first expect
	  # string is the behavior of remote CVS.  There is some sentiment
	  # that
	  #   "${PROG} [a-z]*: Updating \.
          #   ${PROG} [a-z]*: Updating top-dir"
	  # is correct but it isn't clear why that would be correct instead
	  # of the remote CVS behavior.
	  #
	  # The DOTSTAR matches of a bunch of lines like
	  # "U CVSROOT/checkoutlist".  Trying to match them more precisely
	  # seemed to cause trouble.  For example CVSROOT/cvsignore will
	  # be present or absent depending on whether we ran the "ignore"
	  # test or not.
	  dotest toplevel-9 "${testcvs} update -d" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating CVSROOT
${DOTSTAR}
${PROG} [a-z]*: Updating top-dir" \
"${PROG} [a-z]*: Updating \.
U file1
${PROG} [a-z]*: Updating top-dir"

	  cd ..
	  rm -r 1
d6236 1
d6255 1
a6255 1
# * Test that cvs -d `hostname`:${TESTDIR}/non/existent co foo
d6257 1
a6257 1
#     Cannot access ${TESTDIR}/non-existent/CVSROOT
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d5 1
a5 13
# The copyright notice said: "Copyright (C) 1992, 1993 Cygnus Support"
# I'm not adding new copyright notices for new years as our recent 
# practice has been to include copying terms without copyright notices.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
d18 6
a23 12
# Commented out because:
# (1) whoami is not portable.  If memory serves the POSIX way is "id -un".
#     ("logname" or "who am i" are similar but different--they have more to
#      do with who logged in on your tty than your uid).
# (2) This definition of "root" doesn't quite match CVS's (which is based
#     on uid 0, not username "root").
#case "`whoami`" in
#  "root" )
#    echo "sanity.sh: test suite does not work correctly when run as root" >&2
#    exit 1
#  ;;
#esac
a27 16
# The default value of /tmp/cvs-sanity for TESTDIR is dubious,
# because it loses if two people/scripts try to run the tests
# at the same time.  Some possible solutions:
# 1.  Use /tmp/cvs-test$$.  One disadvantage is that the old
#     cvs-test* directories would pile up, because they wouldn't
#     necessarily get removed.
# 2.  Have everyone/everything running the testsuite set
#     TESTDIR to some appropriate directory.
# 3.  Have the default value of TESTDIR be some variation of
#     `pwd`/cvs-sanity.  The biggest problem here is that we have
#     been fairly careful to test that CVS prints in messages the
#     actual pathnames that we pass to it, rather than a different
#     pathname for the same directory, as may come out of `pwd`.
#     So this would be lost if everything was `pwd`-based.  I suppose
#     if we wanted to get baroque we could start making symlinks
#     to ensure the two are different.
d82 1
a82 1
username="[-a-zA-Z0-9][-a-zA-Z0-9]*"
a87 10
# On cygwin32, we may not have /bin/sh.
if [ -r /bin/sh ]; then
  TESTSHELL="/bin/sh"
else
  TESTSHELL=`type -p sh 2>/dev/null`
  if [ ! -r "$TESTSHELL" ]; then
    TESTSHELL="/bin/sh"
  fi
fi

a454 16
# Like dotest except output is sorted.
dotest_sort ()
{
  rm -f ${TESTDIR}/dotest.ex? 2>&1
  if $2 >${TESTDIR}/dotest.tmp1 2>&1; then
    : so far so good
  else
    status=$?
    cat ${TESTDIR}/dotest.tmp1 >>${LOGFILE}
    echo "exit status was $status" >>${LOGFILE}
    fail "$1"
  fi
  sort < ${TESTDIR}/dotest.tmp1 > ${TESTDIR}/dotest.tmp
  dotest_internal "$@@"
}

d462 1
a462 11
#
# Note that using pwd here rather than /bin/pwd will make it even less
# likely that we test whether CVS is distinguishing between TMPPWD
# and TESTDIR.  However, there is no guarantee that will test it anyway.
# If we really care, we should do something along the lines of:
#   cd /tmp/cvs-sanity  # In reality, overridable with environment variable?
#   mkdir realdir
#   ln -s realdir testdir
#   TESTDIR=/tmp/cvs-sanity/testdir
#   TMPPWD=/tmp/cvs-sanity/realdir
TMPPWD=`pwd`
d481 6
a486 14
	tests="basica basicb basicc basic1 deep basic2"
	tests="${tests} rdiff death death2 branches"
	tests="${tests} rcslib multibranch import importb join join2 join3"
	tests="${tests} new newb conflicts conflicts2 conflicts3"
	tests="${tests} modules modules2 modules3 modules4"
	tests="${tests} mflag editor errmsg1 errmsg2"
	tests="${tests} devcom devcom2 devcom3 watch4"
	tests="${tests} ignore binfiles binfiles2 mcopy binwrap binwrap2"
	tests="${tests} binwrap3 mwrap info config"
	tests="${tests} serverpatch log log2 ann crerepos rcs big modes stamps"
	tests="${tests} sticky keyword keywordlog"
	tests="${tests} toplevel head tagdate multibranch2"
	tests="${tests} admin reserved"
	tests="${tests} cvsadm diffmerge1 diffmerge2"
d597 2
a598 2
"${PROG} [a-z]*: use .${PROG} add. to create an entry for ssfile
${PROG}"' \[[a-z]* aborted\]: correct above errors first!' \
d604 1
a604 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
a703 62

	  # As long as we have a file with a few revisions, test
	  # a few "cvs admin -o" invocations.
	  cd sdir/ssdir
	  dotest_fail basica-o1 "${testcvs} admin -o 1.2::1.2" \
"${PROG} [a-z]*: while processing more than one file:
${PROG} \[[a-z]* aborted\]: attempt to specify a numeric revision"
	  dotest basica-o2 "${testcvs} admin -o 1.2::1.2 ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
done"
	  dotest basica-o2a "${testcvs} admin -o 1.1::NOT_RESERVED ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
done"
	  dotest_fail basica-o2b "${testcvs} admin -o 1.1::NOT_EXIST ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v: Revision NOT_EXIST doesn't exist.
${PROG} [a-z]*: cannot modify RCS file for .ssfile."
	  dotest basica-o3 "${testcvs} admin -o 1.2::1.3 ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
done"
	  dotest basica-o4 "${testcvs} admin -o 3.1:: ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
done"
	  dotest basica-o5 "${testcvs} admin -o ::1.1 ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
done"
	  dotest basica-o5a "${testcvs} -n admin -o 1.2::3.1 ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
deleting revision 2\.0
deleting revision 1\.3
done"
	  dotest basica-o6 "${testcvs} admin -o 1.2::3.1 ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
deleting revision 2\.0
deleting revision 1\.3
done"
	  dotest basica-o7 "${testcvs} log -N ssfile" "
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
Working file: ssfile
head: 3\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 3\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}0 -0
bump-it
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
modify-it
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add-it
============================================================================="
	  dotest basica-o8 "${testcvs} -q update -p -r 1.1 ssfile" "ssfile"
	  cd ../..

d717 1
a717 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d719 1
a719 1
"RCS file: ${TESTDIR}/cvsroot/topfile,v
d722 1
a722 1
${TESTDIR}/cvsroot/topfile,v  <--  topfile
a728 7
	  # Now test the ability to run checkout on an existing working
	  # directory without having it lose its mind.  I don't know
	  # whether this is tested elsewhere in sanity.sh.  A more elaborate
	  # test might also have modified files, make sure it works if
	  # the modules file was modified to add new directories to the
	  # module, and such.
	  dotest basicb-0d0 "${testcvs} -q co -l ." ""
d738 1
a738 5

	  # In 1b and 1c, the first string matches if we're using absolute
	  # paths, while the second matches if RELATIVE_REPOS is defined
	  # (we're using relative paths).

d740 1
a740 2
"${TESTDIR}/cvsroot/\." \
"\."
d742 1
a742 2
"${TESTDIR}/cvsroot/first-dir" \
"first-dir"
d745 3
a747 6
	  # Note that the name Emptydir is chosen to test that CVS just
	  # treats it like any other directory name.  It should be
	  # special only when it is directly in $CVSROOT/CVSROOT.
	  mkdir Emptydir sdir2
	  dotest basicb-2 "${testcvs} add Emptydir sdir2" \
"Directory ${TESTDIR}/cvsroot/first-dir/Emptydir added to the repository
d749 1
a749 1
	  cd Emptydir
d753 1
a753 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d755 1
a755 1
"${PROG} [a-z]*: use .${PROG} add. to create an entry for sfile1
d763 1
a763 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d778 1
a778 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d784 1
a784 1
"RCS file: ${TESTDIR}/cvsroot/first-dir/Emptydir/sfile1,v
d786 2
a787 2
Checking in Emptydir/sfile1;
${TESTDIR}/cvsroot/first-dir/Emptydir/sfile1,v  <--  sfile1
d796 1
a796 1
	  echo sfile1 develops >Emptydir/sfile1
d798 2
a799 2
"Checking in Emptydir/sfile1;
${TESTDIR}/cvsroot/first-dir/Emptydir/sfile1,v  <--  sfile1
d802 1
a802 1
	  dotest basicb-7 "${testcvs} -q tag release-1" 'T Emptydir/sfile1
d820 1
a820 1
'U first-dir1/Emptydir/sfile1
a824 10

	  # FIXME? basicb-9 used to check things out like this:
	  #   U newdir/Emptydir/sfile1
	  #   U newdir/sdir2/sfile2
	  # but that's difficult to do.  The whole "shorten" thing
	  # is pretty bogus, because it will break on things
	  # like "cvs co foo/bar baz/quux".  Unless there's some
	  # pretty detailed expansion and analysis of the command-line
	  # arguments, we shouldn't do "shorten" stuff at all.

d826 3
a828 3
"${testcvs} -q co -d newdir -r release-1 first-dir/Emptydir first-dir/sdir2" \
'U newdir/first-dir/Emptydir/sfile1
U newdir/first-dir/sdir2/sfile2'
d830 1
a830 5

	  # In 9b through 9f, the first string matches if we're using
          # absolute paths, while the second matches if RELATIVE_REPOS
	  # is defined (we're using relative paths).

d832 1
a832 2
"${TESTDIR}/cvsroot/\." \
"\."
d834 2
a835 13
"${TESTDIR}/cvsroot/\." \
"\."
	  dotest basicb-9d "cat newdir/first-dir/CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir" \
"first-dir"
	  dotest basicb-9e "cat newdir/first-dir/Emptydir/CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir/Emptydir" \
"first-dir/Emptydir"
	  dotest basicb-9f "cat newdir/first-dir/sdir2/CVS/Repository" \
"${TESTDIR}/cvsroot/first-dir/sdir2" \
"first-dir/sdir2"

	  dotest basicb-10 "cat newdir/first-dir/Emptydir/sfile1 newdir/first-dir/sdir2/sfile2" \
d845 1
a845 1
"U sub1/sub2/Emptydir/sfile1
d867 1
a867 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d877 10
a886 7

	  # Let's see if we can add something to Emptydir.
	  dotest basicb-18 "${testcvs} -q co -d t2/t3 first-dir second-dir" \
"U t2/t3/first-dir/Emptydir/sfile1
U t2/t3/first-dir/sdir2/sfile2
U t2/t3/second-dir/aa"
	  cd t2
d895 1
a895 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a903 1
	  rm -r t2
d906 8
a913 10
	  # Note that -H is an illegal option.
	  # I suspect that the choice between "illegal" and "invalid"
	  # depends on the user's environment variables, the phase
	  # of the moon (weirdness with optind), and who knows what else.
	  # I've been seeing "illegal"...
	  dotest_fail basicb-21 "${testcvs} -q admin -H" \
"admin: illegal option -- H
${PROG} \[admin aborted\]: specify ${PROG} -H admin for usage information" \
"admin: invalid option -- H
${PROG} \[admin aborted\]: specify ${PROG} -H admin for usage information"
a916 12
	  # OK, while we have an Emptydir around, test a few obscure
	  # things about it.
	  mkdir edir; cd edir
	  dotest basicb-edir-1 "${testcvs} -q co -l CVSROOT" \
"U CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  dotest_fail basicb-edir-2 "test -d Emptydir" ''
	  # This tests the code in find_dirs which skips Emptydir.
	  dotest basicb-edir-3 "${testcvs} -q -n update -d -P" ''
	  cd ../..
	  rm -r edir

d922 2
a929 30
	basicc)
	  # More tests of basic/miscellaneous functionality.
	  mkdir 1; cd 1
	  dotest_fail basicc-1 "${testcvs} diff" \
"${PROG} [a-z]*: in directory \.:
${PROG} \[[a-z]* aborted\]: there is no version here; run .${PROG} checkout. first"
	  dotest basicc-2 "${testcvs} -q co -l ." ''
	  mkdir first-dir second-dir
	  dotest basicc-3 "${testcvs} add first-dir second-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
	  # Old versions of CVS often didn't create this top-level CVS
	  # directory in the first place.  I think that maybe the only
	  # way to get avoid it currently is to let CVS create it, and
	  # then blow it away.  But that is perfectly legal; people who
	  # are used to the old behavior especially may be interested.
	  rm -r CVS
	  dotest basicc-4 "echo *" "first-dir second-dir"
	  dotest basicc-5 "${testcvs} update" \
"${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: Updating second-dir" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: Updating second-dir"

	  cd ..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d948 1
a948 1
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d1318 1
a1318 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
a1393 2
	  dotest deep-4b0a "${testcvs} -q diff" ''
	  dotest deep-4b0b "${testcvs} -q ci" ''
d1465 1
a1465 1
				    pass 29-$i
d1467 1
a1467 1
				    fail 29-$i
d1478 1
a1478 1
			    pass 30-$i-$j
d1480 1
a1480 1
			    fail 30-$i-$j
d1485 1
a1485 1
		    pass 31
d1487 1
a1487 1
		    fail 31
d1492 1
a1492 1
		    pass 32
d1494 1
a1494 1
		    fail 32
d1498 1
a1498 1
		    pass 33
d1500 1
a1500 1
		    fail 33
d1505 1
a1505 1
#		    pass 34
d1507 1
a1507 1
#		    fail 34
d1511 1
a1511 1
		    pass 35
d1513 1
a1513 1
		    fail 35
d1517 1
a1517 1
		    pass 36
d1519 1
a1519 1
		    fail 36
d1535 1
a1535 1
			    pass 37-$i
d1537 1
a1537 1
			    fail 37-$i
d1544 1
a1544 1
			    pass 38-$i
d1546 1
a1546 1
			    fail 38-$i
d1551 1
a1551 1
		    pass 39
d1553 1
a1553 1
		    fail 39
d1558 1
a1558 1
		    pass 40
d1560 1
a1560 1
		    fail 40
d1564 1
a1564 1
		    pass 41
d1566 1
a1566 1
		    fail 41
d1571 1
a1571 1
#		    pass 42
d1573 1
a1573 1
#		    fail 42
d1577 1
a1577 1
		    pass 43
d1579 1
a1579 1
		    fail 43
d1584 1
a1584 1
		    pass 44
d1586 1
a1586 1
		    fail 44
d1590 1
a1590 1
		    pass 45
d1592 1
a1592 1
		    fail 45
d1597 1
a1597 1
		    fail 45.5
d1599 1
a1599 1
		    pass 45.5
d1606 1
a1606 1
		    pass 46
d1608 1
a1608 1
		    fail 46
d1613 1
a1613 1
		    pass 47
d1615 1
a1615 1
		    fail 47
d1620 1
a1620 1
		    pass 48
d1622 1
a1622 1
		    fail 48
d1627 1
a1627 1
		    pass 49
d1629 1
a1629 1
		    fail 49
d1634 1
a1634 1
		    pass 50
d1636 1
a1636 1
		    fail 50
d1641 1
a1641 1
		    pass 51
d1643 1
a1643 1
		    fail 51
d1649 1
a1649 1
		    fail 52
d1651 1
a1651 1
		    pass 52
d1657 1
a1657 1
		    pass 53
d1659 1
a1659 1
		    fail 53
d1663 1
a1663 1
		    pass 54
d1665 1
a1665 1
		    fail 54
d1674 1
a1674 1
		    fail 55
d1676 1
a1676 1
		    pass 55
d1699 1
a1699 1
		    pass 57
d1701 1
a1701 1
		    fail 57
d1707 1
a1707 1
		    fail 58
d1709 1
a1709 1
		    pass 58
d1721 1
a1721 1
		    pass 59
d1723 1
a1723 1
		    fail 59
d1729 1
a1729 1
		    pass 60a
d1731 1
a1731 1
		    fail 60a
d1734 1
a1734 1
		    pass 60b
d1736 1
a1736 1
		    fail 60b
d1747 1
a1747 1
		    pass 62
d1749 1
a1749 1
		    fail 62
d1759 1
a1759 1
#		    fail 63
d1761 1
a1761 1
#		    pass 63
d1777 38
a1814 38
"O [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir           =first-dir= ${TMPPWD}/\*
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir           == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1      == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1      == ${TMPPWD}
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1/dir2 == ${TMPPWD}
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1/dir2 == ${TMPPWD}
F [0-9/]* [0-9:]* ${PLUS}0000 ${username}                     =first-dir= ${TMPPWD}/\*
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= ${TMPPWD}/\*
U [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TMPPWD}/first-dir
U [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir           == ${TMPPWD}/first-dir" \
"O [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir           =first-dir= <remote>/\*
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1/dir2 == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir           == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1      == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1      == <remote>
A [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1/dir2 == <remote>
M [0-9/]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1/dir2 == <remote>
F [0-9/]* [0-9:]* ${PLUS}0000 ${username}                     =first-dir= <remote>/\*
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-head:A\]
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9/]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-revision:1\.1\]
O [0-9/]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= <remote>/\*"
d1831 1
a1831 1
		dotest_sort rdiff-1 \
d1833 2
a1834 1
'
a1835 2
N trdiff/bar
N trdiff/foo
d1855 1
a1855 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d1935 1
a1935 1
		    pass 65
d1937 1
a1937 1
		    fail 65
d1951 1
a1951 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d1962 1
a1962 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove this file permanently'
d1975 1
a1975 1
		    pass 66
d1977 1
a1977 1
		    fail 66
d1982 1
a1982 1
		    pass 67
d1984 1
a1984 1
		    fail 67
d1990 1
a1990 1
		    pass 68
d1992 1
a1992 1
		    fail 68
d1997 1
a1997 1
		    pass 69
d1999 1
a1999 1
		    fail 69
d2014 1
a2014 1
		    pass 70
d2016 1
a2016 1
		    fail 70
d2021 1
a2021 1
		    pass 71
d2023 1
a2023 1
		    fail 71
d2028 1
a2028 1
		    pass 72
d2030 1
a2030 1
		    fail 72
d2037 1
a2037 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d2048 1
a2048 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove this file permanently'
d2061 1
a2061 1
		    pass 73
d2063 1
a2063 1
		    fail 73
d2068 1
a2068 1
		    pass 74
d2070 1
a2070 1
		    fail 74
d2078 1
a2078 1
		    pass 75
d2080 1
a2080 1
		    fail 75
d2085 1
a2085 1
		    pass 76
d2087 1
a2087 1
		    fail 76
d2114 1
a2114 1
		    pass 77
d2116 1
a2116 1
		    fail 77
d2121 1
a2121 1
		    pass 78
d2123 1
a2123 1
		    fail 78
d2129 1
a2129 1
		    pass 79
d2131 1
a2131 1
		    fail 79
d2136 1
a2136 1
		    pass 80
d2138 1
a2138 1
		    fail 80
d2146 1
a2146 1
		    pass 81
d2148 1
a2148 1
		    fail 81
d2154 1
a2154 1
		    pass 82
d2156 1
a2156 1
		    fail 82
d2161 1
a2161 1
		    pass 83
d2163 1
a2163 1
		    fail 83
d2168 1
a2168 1
		    pass 84
d2170 1
a2170 1
		    fail 84
d2176 1
a2176 1
		    fail 85
d2178 1
a2178 1
		    pass 85
d2193 1
a2193 1
		    pass 87
d2195 1
a2195 1
		    fail 87
d2200 1
a2200 1
		    pass 87a
d2202 2
a2203 1
		    fail 87a
d2208 1
a2208 1
		    pass 88
d2210 1
a2210 1
		    fail 88
d2239 1
a2239 1
		    pass 90
d2241 1
a2241 1
		    fail 90
d2246 1
a2246 1
		    pass 91
d2248 1
a2248 1
		    fail 91
d2252 1
a2252 1
		    fail 92
d2254 1
a2254 1
		    pass 92
d2262 1
a2262 1
		    fail 92.1b
d2264 1
a2264 1
		    pass 92.1b
d2267 1
a2267 1
		    pass 92.1c
d2269 1
a2269 1
		    fail 92.1c
d2274 1
a2274 1
		    pass 93
d2276 1
a2276 1
		    fail 93
d2282 1
a2282 1
		    pass 94
d2284 1
a2284 1
		    fail 94
d2315 1
a2315 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
a2341 3
	  # If the DIFF that CVS is using (options.h) is Sun diff, this
	  # test is said to fail (I think the /dev/null is the part
	  # that differs), along with a number of the other similar tests.
d2411 1
a2411 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d2442 1
a2442 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d2465 1
a2465 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d2476 1
a2476 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d2597 1
a2597 2
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
	  dotest branches-2a "${testcvs} -n -q ci -m dont-commit" ""
a2629 7
	  # The "cvs log file4" in test branches-14.3 will test that we
	  # didn't really add the tag.
	  dotest branches-3.3 "${testcvs} -qn tag dont-tag" \
"T file1
T file2
T file3
T file4"
d2716 1
a2716 1
date: [0-9/: ]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
d2720 1
a2720 1
date: [0-9/: ]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
d2725 1
a2725 1
date: [0-9/: ]*;  author: ${username};  state: Exp;
d2729 1
a2729 1
date: [0-9/: ]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
d2733 1
a2733 1
date: [0-9/: ]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
d2738 1
a2738 1
date: [0-9/: ]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
a2782 226

	  dotest branches-o1 "${testcvs} -q admin -o ::brbr" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file3,v
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
done"
	  cd ..

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r first-dir
	  ;;

	rcslib)
	  # Test librarification of RCS.
	  # First: test whether `cvs diff' handles $Name expansion
	  # correctly.	We diff two revisions with their symbolic tags;
	  # neither tag should be expanded in the output.  Also diff
	  # one revision with the working copy.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest rcsdiff-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo "I am the first foo, and my name is $""Name$." > foo.c
	  dotest rcsdiff-2 "${testcvs} add -m new-file foo.c" \
"${PROG} [a-z]*: scheduling file .foo\.c. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest rcsdiff-3 "${testcvs} commit -m rev1 foo.c" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/foo\.c,v
done
Checking in foo\.c;
${TESTDIR}/cvsroot/first-dir/foo.c,v  <--  foo\.c
initial revision: 1\.1
done"
	  dotest rcsdiff-4 "${testcvs} tag first foo.c" "T foo\.c"
	  dotest rcsdiff-5 "${testcvs} update -p -r first foo.c" \
"===================================================================
Checking out foo\.c
RCS:  ${TESTDIR}/cvsroot/first-dir/foo\.c,v
VERS: 1\.1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
I am the first foo, and my name is \$""Name: first \$\."

	  echo "I am the second foo, and my name is $""Name$." > foo.c
	  dotest rcsdiff-6 "${testcvs} commit -m rev2 foo.c" \
"Checking in foo\.c;
${TESTDIR}/cvsroot/first-dir/foo\.c,v  <--  foo\.c
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest rcsdiff-7 "${testcvs} tag second foo.c" "T foo\.c"
	  dotest rcsdiff-8 "${testcvs} update -p -r second foo.c" \
"===================================================================
Checking out foo\.c
RCS:  ${TESTDIR}/cvsroot/first-dir/foo\.c,v
VERS: 1\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
I am the second foo, and my name is \$""Name: second \$\."

	dotest_fail rcsdiff-9 "${testcvs} diff -r first -r second" \
"${PROG} [a-z]*: Diffing \.
Index: foo\.c
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/foo\.c,v
retrieving revision 1\.1
retrieving revision 1\.2
diff -r1\.1 -r1\.2
1c1
< I am the first foo, and my name is \$""Name:  \$\.
---
> I am the second foo, and my name is \$""Name:  \$\."

	  echo "I am the once and future foo, and my name is $""Name$." > foo.c
	  dotest_fail rcsdiff-10 "${testcvs} diff -r first" \
"${PROG} [a-z]*: Diffing \.
Index: foo\.c
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/foo\.c,v
retrieving revision 1\.1
diff -r1\.1 foo\.c
1c1
< I am the first foo, and my name is \$""Name:  \$\.
---
> I am the once and future foo, and my name is \$""Name\$\."

	  # Test handling of libdiff options.  diff gets quite enough
	  # of a workout elsewhere in sanity.sh, so we assume that it's
	  # mostly working properly if it passes all the other tests.
	  # The main one we want to try is regex handling, since we are
	  # using CVS's regex matcher and not diff's.

	  cat >rgx.c <<EOF
test_regex (whiz, bang)
{
foo;
bar;
baz;
grumble;
}
EOF

	  dotest rcslib-diffrgx-1 "${testcvs} -q add -m '' rgx.c" \
"${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest rcslib-diffrgx-2 "${testcvs} -q ci -m '' rgx.c" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/rgx\.c,v
done
Checking in rgx\.c;
${TESTDIR}/cvsroot/first-dir/rgx\.c,v  <--  rgx\.c
initial revision: 1\.1
done"
	  cat >rgx.c <<EOF
test_regex (whiz, bang)
{
foo;
bar;
baz;
mumble;
}
EOF
	  # Use dotest_fail because exit status from `cvs diff' must be 1.
	  dotest_fail rcslib-diffrgx-3 "${testcvs} diff -c -F.*( rgx.c" \
"Index: rgx\.c
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/rgx\.c,v
retrieving revision 1\.1
diff -c -F\.\*( -r1\.1 rgx\.c
\*\*\* rgx\.c	[0-9/]* [0-9:]*	1\.1
--- rgx\.c	[0-9/]* [0-9:]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* test_regex (whiz, bang)
\*\*\* 3,7 \*\*\*\*
  foo;
  bar;
  baz;
! grumble;
  }
--- 3,7 ----
  foo;
  bar;
  baz;
! mumble;
  }"

	  # Tests of rcsmerge/diff3.  Merge operations get a good general
	  # workout elsewhere; we want to make sure that options are still
	  # handled properly.  Try merging two branches with -kv, to test
	  # both -j and -k switches.

	  cd ..

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r first-dir

	  mkdir 1; cd 1
	  dotest rcslib-merge-1 "${testcvs} -q co -l ." ""
	  mkdir first-dir
	  dotest rcslib-merge-2 "${testcvs} -q add first-dir" \
"Directory ${TESTDIR}/cvsroot.*/first-dir added to the repository"
	  cd ..; rm -r 1

	  dotest rcslib-merge-3 "${testcvs} -q co first-dir" ""
	  cd first-dir

	  echo '$''Revision$' > file1
	  echo '2' >> file1
	  echo '3' >> file1
	  dotest rcslib-merge-4 "${testcvs} -q add file1" \
"${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest rcslib-merge-5 "${testcvs} -q commit -m '' file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  sed -e 's/2/two/' file1 > f; mv f file1
	  dotest rcslib-merge-6 "${testcvs} -q commit -m '' file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest rcslib-merge-7 "${testcvs} -q tag -b -r 1.1 patch1" "T file1"
	  dotest rcslib-merge-8 "${testcvs} -q update -r patch1" "[UP] file1"
	  dotest rcslib-merge-9 "${testcvs} -q status" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		patch1 (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest rcslib-merge-10 "cat file1" \
'$''Revision: 1\.1 $
2
3'
	  sed -e 's/3/three/' file1 > f; mv f file1
	  dotest rcslib-merge-11 "${testcvs} -q commit -m '' file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest rcslib-merge-12 "${testcvs} -q update -kv -j1.2" \
"U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into file1
rcsmerge: warning: conflicts during merge"
	  dotest rcslib-merge-13 "cat file1" \
"<<<<<<< file1
1\.1\.2\.1
2
three
[=]======
1\.2
two
3
[>]>>>>>> 1\.2"

d2803 1
a2803 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
a2877 13
		# Tests of "cvs import":
		# basic2
		# rdiff  -- imports with keywords
		# import  -- more tests of imports with keywords
		# importb  -- -b option.
		# modules3
		# mflag -- various -m messages
		# ignore  -- import and cvsignore
		# binwrap -- import and -k wrappers
		# info -- imports which are rejected by verifymsg
		# head -- intended to test vendor branches and HEAD,
		#   although it doesn't really do it yet.

d2894 1
a2894 1
		    pass 96
d2896 1
a2896 1
		    fail 96
d2908 1
a2908 1
		    pass 97
d2910 1
a2910 1
		    fail 97
d2916 1
a2916 1
			    pass 98-$i
d2918 1
a2918 1
			    fail 98-$i
d2922 1
a2922 1
		    fail 98.5
d2924 1
a2924 1
		    pass 98.5
d2930 1
a2930 1
		    pass 99
d2932 1
a2932 1
		    fail 99
d2940 1
a2940 1
		    pass 100
d2942 1
a2942 1
		    fail 100
d2947 1
a2947 1
		    fail 101
d2949 1
a2949 1
		    pass 101
d2954 1
a2954 1
		    pass 102
d2956 1
a2956 1
		    fail 102
d2963 1
a2963 1
		    pass 103
d2965 1
a2965 1
		    fail 103
d2970 1
a2970 1
		    pass 104
d2972 1
a2972 1
		    fail 104
d2977 1
a2977 1
		    pass 105
d2979 1
a2979 1
		    fail 105
d2990 1
a2990 1
		    pass 106
d2992 1
a2992 1
		    fail 106
d3003 1
a3003 1
		    pass 107
d3005 1
a3005 1
		    fail 107
d3011 1
a3011 1
		    fail 108
d3013 1
a3013 1
		    pass 108
d3018 1
a3018 1
			    pass 109-$i
d3020 1
a3020 1
			    fail 109-$i
d3026 1
a3026 1
		    pass 110
d3028 1
a3028 1
		    fail 110
d3032 1
a3032 1
		    pass 111
d3034 1
a3034 1
		    fail 111
d3039 1
a3039 1
		    pass 112
d3041 1
a3041 1
		    fail 112
d3058 1
a3058 1
		    fail 114
d3060 1
a3060 1
		    pass 114
d3065 1
a3065 1
			    pass 115-$i
d3067 1
a3067 1
			    fail 115-$i
d3074 1
a3074 1
import should not expand \$''Id: imported-f2,v 1\.2 [0-9/]* [0-9:]* '"${username}"' Exp \$
d3077 1
a3077 1
import should not expand \$''Id: imported-f2,v 1\.1\.1\.2 [0-9/]* [0-9:]* '"${username}"' Exp \$
a3086 96
	importb)
	  # More cvs import tests, especially -b option.

	  # OK, first we get some sources from the NetMunger project, and
	  # import them into the 1.1.1 vendor branch.
	  mkdir imp-dir
	  cd imp-dir
	  echo 'OpenMunger sources' >file1
	  echo 'OpenMunger sources' >file2
	  dotest importb-1 \
"${testcvs} import -m add first-dir openmunger openmunger-1_0" \
"N first-dir/file1
N first-dir/file2

No conflicts created by this import"
	  cd ..
	  rm -r imp-dir

	  # Now we put the sources we get from FreeMunger into 1.1.3
	  mkdir imp-dir
	  cd imp-dir
	  echo 'FreeMunger sources' >file1
	  echo 'FreeMunger sources' >file2
	  # Not completely sure how the conflict detection is supposed to
	  # be working here (haven't really thought about it).
	  dotest importb-2 \
"${testcvs} import -m add -b 1.1.3 first-dir freemunger freemunger-1_0" \
"C first-dir/file1
C first-dir/file2

2 conflicts created by this import.
Use the following command to help the merge:

	${PROG} checkout -jfreemunger:yesterday -jfreemunger first-dir"
	  cd ..
	  rm -r imp-dir

	  # Now a test of main branch import (into second-dir, not first-dir).
	  mkdir imp-dir
	  cd imp-dir
	  echo 'my own stuff' >mine1.c
	  echo 'my own stuff' >mine2.c
	  dotest_fail importb-3 \
"${testcvs} import -m add -b 1 second-dir dummy really_dumb_y" \
"${PROG} \[[a-z]* aborted\]: Only branches with two dots are supported: 1"
	  : when we implement main-branch import, should be \
"N second-dir/mine1\.c
N second-dir/mine2\.c

No conflicts created by this import"
	  cd ..
	  rm -r imp-dir

	  mkdir 1
	  cd 1
	  # when we implement main branch import, will want to 
	  # add "second-dir" here.
	  dotest importb-4 "${testcvs} -q co first-dir" \
"U first-dir/file1
U first-dir/file2"
	  cd first-dir
	  dotest importb-5 "${testcvs} -q log file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch: 1\.1\.1
locks: strict
access list:
symbolic names:
	freemunger-1_0: 1\.1\.3\.1
	freemunger: 1\.1\.3
	openmunger-1_0: 1\.1\.1\.1
	openmunger: 1\.1\.1
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.1;  1\.1\.3;
Initial revision
----------------------------
revision 1\.1\.3\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
add
----------------------------
revision 1\.1\.1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}0 -0
add
============================================================================="

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${CVSROOT_DIRNAME}/second-dir
	  ;;

a3088 4
	  #   Variety of scenarios (see list below), in the context of:
	  #     * merge changes from T1 to T2 into the main line
	  #     * merge changes from branch 'branch' into the main line
	  #     * merge changes from branch 'branch' into branch 'br2'.
a3089 19
	  # See also join2, which tests joining (and update -A) on only
	  # a single file, rather than a directory.
	  # See also join3, which tests some cases involving the greatest
	  # common ancestor.  Here is a list of tests according to branch
	  # topology:
	  #
	  # --->bp---->trunk          too many to mention
	  #     \----->branch
	  #
	  #     /----->branch1
	  # --->bp---->trunk          multibranch, multibranch2
	  #     \----->branch2
	  #
	  # --->bp1----->bp2---->trunk   join3
	  #     \->br1   \->br2
	  #
	  # --->bp1----->trunk
	  #     \----bp2---->branch                branches
	  #          \------>branch-of-branch
d3150 1
a3150 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
d3193 1
a3193 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
d3197 1
a3197 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove these files permanently'
d3244 1
a3244 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d3280 1
a3280 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
d3286 1
a3286 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove these files permanently'
a3423 36
	  cd ..

	  # Checkout the main line again and make a new branch which we
	  # merge to.
	  rm -r first-dir
	  dotest join-25 "${testcvs} -q co first-dir" \
'U first-dir/file2
U first-dir/file3
U first-dir/file4
U first-dir/file7'
	  cd first-dir
	  dotest join-26 "${testcvs} -q tag -b br2" \
"T file2
T file3
T file4
T file7"
	  dotest join-27 "${testcvs} -q update -r br2" ""
	  # The handling of file8 here looks fishy to me.  I don't see
	  # why it should be different from the case where we merge to
	  # the trunk (e.g. join-23).
	  dotest join-28 "${testcvs} -q update -j branch" \
"U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
retrieving revision 1.1
retrieving revision 1.1.2.1
Merging differences between 1.1 and 1.1.2.1 into file2
${PROG} [a-z]*: scheduling file3 for removal
${PROG} [a-z]*: file file4 has been modified, but has been removed in revision branch
U file8"
	  # Verify that the right changes have been scheduled.
	  dotest join-29 "${testcvs} -q update" \
"A file1
M file2
R file3
A file8"

a3424 1

d3429 2
a3430 2
	join2)
	  # More joining tests.
d3432 5
a3436 37
	  # First the usual setup; create a directory first-dir, a file
	  # first-dir/file1, and a branch br1.
	  mkdir 1; cd 1
	  dotest join2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest join2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  echo 'initial contents of file1' >file1
	  dotest join2-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest join2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest join2-5 "${testcvs} -q tag -b br1" "T file1"
	  dotest join2-6 "${testcvs} -q update -r br1" ""
	  echo 'modify on branch' >>file1
	  touch bradd
	  dotest join2-6a "${testcvs} add bradd" \
"${PROG} [a-z]*: scheduling file .bradd. for addition on branch .br1.
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest join2-7 "${testcvs} -q ci -m modify" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/bradd,v
done
Checking in bradd;
${TESTDIR}/cvsroot/first-dir/Attic/bradd,v  <--  bradd
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
d3438 1
a3438 196
	  # Here is the unusual/pathological part.  We switch back to
	  # the trunk *for file1 only*, not for the whole directory.
	  dotest join2-8 "${testcvs} -q update -A file1" '[UP] file1'
	  dotest join2-9 "${testcvs} -q status file1" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest join2-10 "cat CVS/Tag" "Tbr1"

	  dotest join2-11 "${testcvs} -q update -j br1 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file1"
	  dotest join2-12 "cat file1" "initial contents of file1
modify on branch"
	  # We should have no sticky tag on file1
	  dotest join2-13 "${testcvs} -q status file1" \
"===================================================================
File: file1            	Status: Locally Modified

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest join2-14 "cat CVS/Tag" "Tbr1"
	  # And the checkin should go to the trunk
	  dotest join2-15 "${testcvs} -q ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"

	  # OK, the above is all well and good and has worked for some
	  # time.  Now try the case where the file had been added on
	  # the branch.
	  dotest join2-16 "${testcvs} -q update -r br1" "[UP] file1"
	  # The workaround is to update the whole directory.
	  # The non-circumvented version won't work.  The reason is that
	  # update removes the entry from CVS/Entries, so of course we get
	  # the tag from CVS/Tag and not Entries.  I suppose maybe
	  # we could invent some new format in Entries which would handle
	  # this, but doing so, and handling it properly throughout
	  # CVS, would be a lot of work and I'm not sure this case justifies
	  # it.
	  dotest join2-17-circumvent "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: bradd is not (any longer) pertinent
[UP] file1"
:	  dotest join2-17 "${testcvs} -q update -A bradd" \
"${PROG} [a-z]*: warning: bradd is not (any longer) pertinent"
	  dotest join2-18 "${testcvs} -q update -j br1 bradd" "U bradd"
	  dotest join2-19 "${testcvs} -q status bradd" \
"===================================================================
File: bradd            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/Attic/bradd,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest join2-20 "${testcvs} -q ci -m modify bradd" \
"Checking in bradd;
${TESTDIR}/cvsroot/first-dir/bradd,v  <--  bradd
new revision: 1\.2; previous revision: 1\.1
done"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	join3)
	  # See "join" for a list of other joining/branching tests.
	  # First the usual setup; create a directory first-dir, a file
	  # first-dir/file1, and a branch br1.
	  mkdir 1; cd 1
	  dotest join3-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest join3-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo 'initial contents of file1' >file1
	  dotest join3-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest join3-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest join3-5 "${testcvs} -q tag -b br1" "T file1"
	  dotest join3-6 "${testcvs} -q update -r br1" ""
	  echo 'br1:line1' >>file1
	  dotest join3-7 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  # Now back to the trunk for:
	  # another revision and another branch for file1.
	  # add file2, which will exist on trunk and br2 but not br1.
	  dotest join3-8 "${testcvs} -q update -A" "[UP] file1"
	  echo 'trunk:line1' > file2
	  dotest join3-8a "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  echo 'trunk:line1' >>file1
	  dotest join3-9 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest join3-10 "${testcvs} -q tag -b br2" "T file1
T file2"

	  # Before we actually have any revision on br2, let's try a join
	  dotest join3-11 "${testcvs} -q update -r br1" "[UP] file1
${PROG} [a-z]*: file2 is no longer in the repository"
	  dotest join3-12 "${testcvs} -q update -j br2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into file1
rcsmerge: warning: conflicts during merge
U file2"
	  dotest join3-13 "cat file1" \
"initial contents of file1
[<]<<<<<< file1
br1:line1
[=]======
trunk:line1
[>]>>>>>> 1\.2"
	  rm file1

	  # OK, we'll try the same thing with a revision on br2.
	  dotest join3-14 "${testcvs} -q update -r br2 file1" \
"${PROG} [a-z]*: warning: file1 was lost
U file1" "U file1"
	  echo 'br2:line1' >>file1
	  dotest join3-15 "${testcvs} -q ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"

	  # OK, now we can join br2 to br1
	  dotest join3-16 "${testcvs} -q update -r br1 file1" "[UP] file1"
	  # It may seem odd, to merge a higher branch into a lower
	  # branch, but in fact CVS defines the ancestor as 1.1
	  # and so it merges both the 1.1->1.2 and 1.2->1.2.2.1 changes.
	  # This seems like a reasonably plausible behavior.
	  dotest join3-17 "${testcvs} -q update -j br2 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.2\.2\.1
Merging differences between 1\.1 and 1\.2\.2\.1 into file1
rcsmerge: warning: conflicts during merge"
	  dotest join3-18 "cat file1" \
"initial contents of file1
[<]<<<<<< file1
br1:line1
[=]======
trunk:line1
br2:line1
[>]>>>>>> 1\.2\.2\.1"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	new) # look for stray "no longer pertinent" messages.
		mkdir ${CVSROOT_DIRNAME}/first-dir

		if ${CVS} co first-dir  ; then
		    pass 117
		else
		    fail 117
		fi

		cd first-dir
d3442 1
a3442 1
		    pass 118
d3444 1
a3444 1
		    fail 118
d3448 1
a3448 1
		    pass 119
d3450 1
a3450 1
		    fail 119
d3456 1
a3456 1
		    pass 120
d3458 1
a3458 1
		    fail 120
d3462 1
a3462 1
		    pass 121
d3464 1
a3464 1
		    fail 121
d3468 1
a3468 1
		    fail 122
d3470 1
a3470 1
		    pass 122
d3474 1
a3474 1
		    fail 123
d3476 1
a3476 1
		    pass 123
d3498 1
a3498 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d3551 1
a3551 9
File: a                	Status: Needs Patch

   Working revision:	1\.1.*
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/a,v
   Sticky Tag:		branch (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)" \
"===================================================================
File: a                	Status: Needs Checkout
d3585 1
a3585 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d3608 1
a3608 1
		    pass 127
d3610 1
a3610 1
		    fail 127
d3614 1
a3614 1
		    pass 127a
d3616 1
a3616 1
		    fail 127a
d3711 3
a3713 6
		dotest conflicts-132 "${testcvs} -q ci -m try" \
"${PROG} [a-z]*: warning: file .a. seems to still contain conflict indicators
Checking in a;
${TESTDIR}/cvsroot/first-dir/a,v  <--  a
new revision: 1\.3; previous revision: 1\.2
done"
a3714 2
		# OK, the user saw the warning (good user), and now
		# resolves it for real.
d3718 1
a3718 1
File: a                	Status: Locally Modified
d3720 2
a3721 2
   Working revision:	1\.3.*
   Repository revision:	1\.3	${TESTDIR}/cvsroot/first-dir/a,v
d3728 1
a3728 1
new revision: 1\.4; previous revision: 1\.3
d3734 2
a3735 2
   Working revision:	1\.4.*
   Repository revision:	1\.4	${TESTDIR}/cvsroot/first-dir/a,v
d3745 1
a3745 1
		    pass 134
d3747 1
a3747 1
		    fail 134
d3750 1
a3750 1
		    pass 135
d3752 1
a3752 1
		    fail 135
d3772 1
a3772 1
		    pass 138
d3774 1
a3774 1
		    fail 138
d3781 1
a3781 1
		    pass 139
d3783 1
a3783 1
		    fail 139
d3788 1
a3788 1
		    pass 140
d3790 1
a3790 1
		    fail 140
d3793 1
a3793 1
		    pass 140
d3795 1
a3795 1
		    fail 140
d3799 1
a3799 1
		    pass 141
d3801 1
a3801 1
		    fail 141
d3804 1
a3804 1
		    pass 142
d3806 1
a3806 1
		    fail 142
d3828 1
a3828 1
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d3902 1
a3902 2
	  echo 'contents unchanged' >same.c
	  dotest conflicts2-142d0 "${testcvs} add aa.c same.c" \
d3904 1
a3904 2
${PROG} [a-z]*: scheduling file .same\.c. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d3906 1
a3906 7
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa\.c,v
done
Checking in aa\.c;
${TESTDIR}/cvsroot/first-dir/aa\.c,v  <--  aa\.c
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/same\.c,v
d3908 2
a3909 2
Checking in same\.c;
${TESTDIR}/cvsroot/first-dir/same\.c,v  <--  same\.c
d3914 3
a3916 8
	  echo 'contents unchanged' >same.c
	  # Note the discrepancy between local and remote in the handling
	  # of same.c.  I kind
	  # of suspect that the local CVS behavior is the more useful one
	  # although I do sort of wonder whether we should make people run
	  # cvs add just to get them in that habit (also, trying to implement
	  # the local CVS behavior for remote without the cvs add seems 
	  # pretty difficult).
d3918 1
a3918 1
	    dotest_fail conflicts2-142d2 "${testcvs} -q update" \
d3920 2
a3921 5
${QUESTION} same\.c
${PROG} update: move away \./aa\.c; it is in the way
C aa\.c
${PROG} update: move away \./same\.c; it is in the way
C same\.c"
d3925 1
a3925 2
C aa\.c
U same\.c"
a3926 36
	  dotest conflicts2-142d3 "${testcvs} -q status aa.c" \
"${PROG} [a-z]*: move away aa\.c; it is in the way
===================================================================
File: aa\.c             	Status: Unresolved Conflict

   Working revision:	No entry for aa\.c
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/aa\.c,v"

	  # Could also be testing the case in which the cvs add happened
	  # before the commit by the other user.
	  # This message seems somewhat bogus.  I mean, parallel development
	  # means that we get to work in parallel if we choose, right?  And
	  # then at commit time it would be a conflict.
	  dotest_fail conflicts2-142d4 "${testcvs} -q add aa.c" \
"${PROG} [a-z]*: aa.c added independently by second party"

	  # The user might want to see just what the conflict is.
	  # Don't bother, diff seems to kind of lose its mind, with or
	  # without -N.  This is a CVS bug(s).
	  #dotest conflicts2-142d5 "${testcvs} -q diff -r HEAD -N aa.c" fixme

	  # Now: "how can the user resolve this conflict", I hear you cry.
	  # Well, one way is to forget about the file in the working
	  # directory.
	  # Since it didn't let us do the add in conflicts2-142d4, there
	  # is no need to run cvs rm here.
	  #dotest conflicts2-142d6 "${testcvs} -q rm -f aa.c" fixme
	  dotest conflicts2-142d6 "rm aa.c" ''
	  dotest conflicts2-142d7 "${testcvs} -q update aa.c" "U aa\.c"
	  dotest conflicts2-142d8 "cat aa.c" ''

	  # The other way is to use the version from the working directory
	  # instead of the version from the repository.  Unfortunately,
	  # there doesn't seem to be any particularly clear way to do
	  # this (?).

a3931 116
	conflicts3)
	  # More tests of conflicts and/or multiple working directories
	  # in general.

	  mkdir 1; cd 1
	  dotest conflicts3-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest conflicts3-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd ..
	  mkdir 2; cd 2
	  dotest conflicts3-3 "${testcvs} -q co -l first-dir" ''
	  cd ../1/first-dir
	  touch file1 file2
	  dotest conflicts3-4 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest conflicts3-5 "${testcvs} -q ci -m add-them" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  cd ../../2/first-dir
	  # Check that -n doesn't make CVS lose its mind as it creates
	  # (or rather, doesn't) a new file.
	  dotest conflicts3-6 "${testcvs} -nq update" \
"U file1
U file2"
	  dotest_fail conflicts3-7 "test -f file1" ''
	  dotest conflicts3-8 "${testcvs} -q update" \
"U file1
U file2"
	  dotest conflicts3-9 "test -f file2" ''

	  # OK, now remove two files at once
	  dotest conflicts3-10 "${testcvs} rm -f file1 file2" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: scheduling .file2. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove these files permanently"
	  dotest conflicts3-11 "${testcvs} -q ci -m remove-them" \
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done
Removing file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: delete; previous revision: 1\.1
done"
	  cd ../../1/first-dir
	  dotest conflicts3-12 "${testcvs} -n -q update" \
"${PROG} [a-z]*: warning: file1 is not (any longer) pertinent
${PROG} [a-z]*: warning: file2 is not (any longer) pertinent"
	  dotest conflicts3-13 "${testcvs} -q update" \
"${PROG} [a-z]*: warning: file1 is not (any longer) pertinent
${PROG} [a-z]*: warning: file2 is not (any longer) pertinent"

	  # OK, now add a directory to both working directories
	  # and see that CVS doesn't lose its mind.
	  mkdir sdir
	  dotest conficts3-14 "${testcvs} add sdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"
	  cd ../../2/first-dir

	  # Create a CVS directory without the proper administrative
	  # files in it.  This can happen for example if you hit ^C
	  # in the middle of a checkout.
	  mkdir sdir
	  mkdir sdir/CVS
	  # OK, in the local case CVS sees that the directory exists
	  # in the repository and recurses into it.  In the remote case
	  # CVS can't see the repository and has no way of knowing
	  # that sdir is even a directory (stat'ing everything would be
	  # too slow).  The remote behavior makes more sense to me (but
	  # would this affect other cases?).
	  if test "$remote" = yes; then
	    dotest conflicts3-15 "${testcvs} -q update" \
"${QUESTION} sdir"
	  else
	    dotest conflicts3-15 "${testcvs} -q update" \
"${QUESTION} sdir
${PROG} [a-z]*: ignoring sdir (CVS/Repository missing)"
	    touch sdir/CVS/Repository
	    dotest conflicts3-16 "${testcvs} -q update" \
"${QUESTION} sdir
${PROG} [a-z]*: ignoring sdir (CVS/Entries missing)"
	  fi
	  rm -r sdir

	  # OK, now the same thing, but the directory doesn't exist
	  # in the repository.
	  mkdir newdir
	  mkdir newdir/CVS
	  dotest conflicts3-17 "${testcvs} -q update" "${QUESTION} newdir"
	  echo "D/newdir////" >> CVS/Entries
	  dotest conflicts3-18 "${testcvs} -q update" \
"${PROG} [a-z]*: ignoring newdir (CVS/Repository missing)"
	  touch newdir/CVS/Repository
	  dotest conflicts3-19 "${testcvs} -q update" \
"${PROG} [a-z]*: ignoring newdir (CVS/Entries missing)"
	  rm -r newdir

	  cd ../..

	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a3933 85

	  ############################################################
	  # These tests are to make sure that administrative files get
	  # rebuilt, regardless of how and where files are checked
	  # out.
	  ############################################################
	  # Check out the whole repository
	  mkdir 1; cd 1
	  dotest modules-1 "${testcvs} -q co ." 'U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg'
	  echo "# made a change" >>CVSROOT/modules
	  dotest modules-1d "${testcvs} -q ci -m add-modules" \
"Checking in CVSROOT/modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  rm -rf 1

	  ############################################################
	  # Check out CVSROOT
	  mkdir 1; cd 1
	  dotest modules-2 "${testcvs} -q co CVSROOT" 'U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg'
	  echo "# made a change" >>CVSROOT/modules
	  dotest modules-2d "${testcvs} -q ci -m add-modules" \
"Checking in CVSROOT/modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  rm -rf 1

	  ############################################################
	  # Check out CVSROOT in some other directory
	  mkdir ${CVSROOT_DIRNAME}/somedir
	  mkdir 1; cd 1
	  dotest modules-3 "${testcvs} -q co somedir" ''
	  cd somedir
	  dotest modules-3d "${testcvs} -q co CVSROOT" 'U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg'
	  echo "# made a change" >>CVSROOT/modules
	  dotest modules-3g "${testcvs} -q ci -m add-modules" \
"Checking in CVSROOT/modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/somedir
	  ############################################################
	  # end rebuild tests
	  ############################################################


d3940 1
a3940 1
	      pass 143
d3942 2
a3943 1
	      fail 143
d3957 1
a3957 1
	      pass 144
d3959 2
a3960 1
	      fail 144
d3964 1
a3964 1
	      pass 145
d3966 2
a3967 1
	      fail 145
d3972 1
a3972 1
	      pass 146
d3974 2
a3975 1
	      fail 146
d3983 1
a3983 1
	      pass 147
d3985 2
a3986 1
	      fail 147
a3995 1
	  echo statusmod -s Mungeable >>CVSROOT/modules
d4003 1
a4003 1
	      pass 148
d4005 2
a4006 1
	      fail 148
a4008 4
	  # The "statusmod" module contains an error; trying to use it
	  # will produce "modules file missing directory" I think.
	  # However, that shouldn't affect the ability of "cvs co -c" or
	  # "cvs co -s" to do something reasonable with it.
a4014 1
statusmod    -s Mungeable
d4016 4
a4019 4
world        -a \.'
	  # There is code in modules.c:save_d which explicitly skips
	  # modules defined with -a, which is why aliasmodule is not
	  # listed.
d4021 1
a4021 2
'statusmod    Mungeable  
bogusalias   NONE        first-dir/subdir/a -a
d4028 1
a4028 1
	      pass 149a1
d4030 2
a4031 1
	      fail 149a1
d4034 1
a4034 1
	      pass 149a2
d4036 2
a4037 1
	      fail 149a2
d4040 2
a4041 1
	      fail 149a3
d4043 1
a4043 1
	      pass 149a3
d4046 1
a4046 1
	      pass 149a4
d4048 2
a4049 1
	      fail 149a4
d4052 1
a4052 1
	      pass 149a5
d4054 2
a4055 1
	      fail 149a5
a4057 5
	  dotest_fail 149b1 "${testcvs} co realmodule/a" \
"${PROG}"' [a-z]*: module `realmodule/a'\'' is a request for a file in a module which is not a directory' \
"${PROG}"' [a-z]*: module `realmodule/a'\'' is a request for a file in a module which is not a directory
'"${PROG}"' \[[a-z]* aborted\]: cannot expand modules'

d4060 1
a4060 1
	      pass 150c
d4062 2
a4063 1
	      fail 150c
d4066 1
a4066 1
	      pass 150d
d4068 2
a4069 1
	      fail 150d
d4072 2
a4073 1
	      fail 150e
d4075 1
a4075 1
	      pass 150e
d4078 1
a4078 1
	      pass 150f
d4080 2
a4081 1
	      fail 150f
d4090 1
a4090 1
	      pass 150g1
d4092 1
a4092 1
	      pass 150g1
d4098 2
a4099 1
	      fail 150g2
d4101 1
a4101 1
	      pass 150g2
d4127 1
a4127 1
	      pass 151
d4129 2
a4130 1
	      fail 151
d4133 2
a4134 1
	      fail 152
d4136 1
a4136 1
	      pass 152
d4141 1
a4141 1
	      pass 153
d4143 2
a4144 1
	      fail 153
d4148 1
a4148 1
	      pass 154
d4150 2
a4151 1
	      fail 154
d4196 1
a4196 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
a4216 16

	  # Make sure the right thing happens if we remove a file.
	  cd first-dir
	  dotest modules-155c6 "${testcvs} -q rm -f file1" \
"${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest modules-155c7 "${testcvs} -q ci -m remove-it" \
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done"
	  cd ..
	  rm -r first-dir
	  dotest modules-155c8 "${testcvs} -q co topfiles" \
"${PROG} [a-z]*: warning: first-dir/file1 is not (any longer) pertinent
U first-dir/file2"

d4225 2
a4226 22
	  mkdir 1; cd 1
	  dotest modules2-setup-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir second-dir third-dir
	  dotest modules2-setup-2 \
"${testcvs} add first-dir second-dir third-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository
Directory ${TESTDIR}/cvsroot/third-dir added to the repository"
	  cd third-dir
	  touch file3
	  dotest modules2-setup-3 "${testcvs} add file3" \
"${PROG} [a-z]*: scheduling file .file3. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest modules2-setup-4 "${testcvs} -q ci -m add file3" \
"RCS file: ${TESTDIR}/cvsroot/third-dir/file3,v
done
Checking in file3;
${TESTDIR}/cvsroot/third-dir/file3,v  <--  file3
initial revision: 1\.1
done"
	  cd ../..
	  rm -r 1
a4234 1
	  echo 'combmodule third-dir file3 &first-dir' >> modules
d4266 12
a4277 102
	  # Now we create another directory named first-dir and make
	  # sure that CVS doesn't get them mixed up.
	  mkdir first-dir
	  # Note that this message should say "Updating ampermodule/first-dir"
	  # I suspect.  This is a long-standing behavior/bug....
	  dotest modules2-9 "${testcvs} co ampermodule" \
"${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: Updating second-dir"
	  touch ampermodule/first-dir/amper1
	  dotest modules2-10 "${testcvs} add ampermodule/first-dir/amper1" \
"${PROG} [a-z]*: scheduling file .ampermodule/first-dir/amper1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  # As with the "Updating xxx" message, the "U first-dir/amper1"
	  # message (instead of "U ampermodule/first-dir/amper1") is
	  # rather fishy.
	  dotest modules2-12 "${testcvs} co ampermodule" \
"${PROG} [a-z]*: Updating first-dir
A first-dir/amper1
${PROG} [a-z]*: Updating second-dir"

	  if test "$remote" = no; then
	    dotest modules2-13 "${testcvs} -q ci -m add-it ampermodule" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/amper1,v
done
Checking in ampermodule/first-dir/amper1;
${TESTDIR}/cvsroot/first-dir/amper1,v  <--  amper1
initial revision: 1\.1
done"
	  else
	    # Trying this as above led to a "protocol error" message.
	    # Work around this bug.
	    cd ampermodule
	    dotest modules2-13 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/amper1,v
done
Checking in first-dir/amper1;
${TESTDIR}/cvsroot/first-dir/amper1,v  <--  amper1
initial revision: 1\.1
done"
	    cd ..
	  fi

	  # Now test the "combmodule" module (combining regular modules
	  # and ampersand modules in the same module definition).
	  cd ..
	  rm -r 1
	  mkdir 1; cd 1
	  dotest modules2-14 "${testcvs} co combmodule" \
"U combmodule/file3
${PROG} [a-z]*: Updating first-dir
U first-dir/amper1"
	  dotest modules2-15 "test -f combmodule/file3" ""
	  dotest modules2-16 "test -f combmodule/first-dir/amper1" ""
	  cd combmodule
	  rm -r first-dir
	  # Might be possible to have a more graceful error message,
	  # but at least for now there is no way to tell CVS that
	  # some files/subdirectories come from one repository directory,
	  # and others from another.
	  if test "$remote" = no; then
	    dotest_fail modules2-17 "${testcvs} update -d" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating first-dir
${PROG} \[[a-z]* aborted\]: cannot open directory ${TESTDIR}/cvsroot/third-dir/first-dir: No such file or directory"
	    # Clean up the droppings left by the previous command.
	    # This should definitely not be necessary (I think).
	    rm -r first-dir
	  else
	    # This seems like a pretty sensible behavior to me, in the
	    # sense that first-dir doesn't "really" exist within
	    # third-dir, so CVS just acts as if there is nothing there
	    # to do.
	    dotest modules2-17 "${testcvs} update -d" \
"${PROG} server: Updating \."
	  fi

	  cd ..
	  dotest modules2-18 "${testcvs} -q co combmodule" \
"U first-dir/amper1"
	  dotest modules2-19 "test -f combmodule/first-dir/amper1" ""
	  cd ..
	  rm -r 1

	  # Test that CVS gives an error if one combines -a with
	  # other options.
	  # Probably would be better to break this out into a separate
	  # test.  Although it is short, it shares no files/state with
	  # the rest of the modules2 tests.
	  mkdir 1; cd 1
	  dotest modules2-a0.5 "${testcvs} -q co CVSROOT/modules" \
'U CVSROOT/modules'
	  cd CVSROOT
	  echo 'aliasopt -a -d onedir first-dir' >modules
	  dotest modules2-a0 "${testcvs} -q ci -m add-modules" \
"Checking in modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  dotest_fail modules2-a1 "${testcvs} -q co aliasopt" \
a4287 1
	  rm -rf ${CVSROOT_DIRNAME}/third-dir
d4306 1
a4306 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d4316 2
a4317 2
	  dotest modules3-4 "${testcvs} -q update -d CVSROOT" \
"U CVSROOT${DOTSTAR}"
a4325 1
another/path/test -d another/path/test first-dir
d4378 1
a4378 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d4389 20
d4445 4
a4448 5
	  # "internal error: repository string too short." (CVS 1.9) or
	  # "warning: server is not creating directories one at a time" (now)
	  # instead of a real error).
	  # I'm tempted to just make it a fatal error to have '/' in a
	  # module name.  But see comments at modules3-16.
a4467 10
	  # Some people seem to want this to work.  I still suspect there
	  # are dark corners in slashes in module names.  This probably wants
	  # more thought before we start hacking on CVS (one way or the other)
	  # or documenting this.
	  mkdir 2; cd 2
	  dotest modules3-16 "${testcvs} -q co another/path/test" \
"U another/path/test/file1"
	  dotest modules3-17 "cat another/path/test/file1" 'file1'
	  cd ..; rm -r 2

a4471 100
	modules4)
	  # Some tests using the modules file with aliases that
	  # exclude particular directories.

	  mkdir 1; cd 1

	  dotest modules4-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest modules4-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"

	  cd first-dir
          mkdir subdir
          dotest modules4-3 "${testcvs} add subdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"

	  echo file1 > file1
	  dotest modules4-4 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'

	  echo file2 > subdir/file2
	  dotest modules4-5 "${testcvs} add subdir/file2" \
"${PROG}"' [a-z]*: scheduling file `subdir/file2'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'

	  dotest modules4-6 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/file2,v
done
Checking in subdir/file2;
${TESTDIR}/cvsroot/first-dir/subdir/file2,v  <--  file2
initial revision: 1\.1
done"

	  cd ..

	  dotest modules4-7 "${testcvs} -q update -d CVSROOT" \
"U CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  cat >modules <<EOF
all -a first-dir
some -a !first-dir/subdir first-dir
EOF
	  dotest modules4-8 "${testcvs} -q ci -m add-modules" \
"Checking in modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..

	  cd ..
	  mkdir 2; cd 2

	  dotest modules4-9 "${testcvs} -q co all" \
"U first-dir/file1
U first-dir/subdir/file2"
	  rm -r first-dir

	  dotest modules4-10 "${testcvs} -q co some" "U first-dir/file1"
	  dotest_fail modules4-11 "test -d first-dir/subdir" ''
	  rm -r first-dir

	  cd ..
	  rm -r 2

	  dotest modules4-12 "${testcvs} rtag tag some" \
"${PROG} [a-z]*: Tagging first-dir
${PROG} [a-z]*: Ignoring first-dir/subdir"

	  cd 1/first-dir/subdir
	  dotest modules4-13 "${testcvs} log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add-it
============================================================================="

	  cd ../../..
	  rm -r 1

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d4480 1
a4480 1
	        pass 156
d4482 2
a4483 1
		fail 156
d4489 1
a4489 1
		pass 157
d4491 2
a4492 1
		fail 157
d4497 1
a4497 1
		pass 158
d4499 2
a4500 1
		fail 158
d4505 1
a4505 1
		pass 159
d4507 2
a4508 1
		fail 159
d4513 1
a4513 1
		pass 160
d4515 2
a4516 1
		fail 160
d4519 1
a4519 1
		pass 161
d4521 2
a4522 1
		fail 161
a4529 182

	editor)
	  # More tests of log messages, in this case the ability to
	  # run an external editor.
	  # TODO:
	  #   * also test $EDITOR, $CVSEDITOR, &c.
	  #   * test what happens if up-to-date check fails.

	  # Our "editor" puts "x" at the start of each line, so we
	  # can see the "CVS:" lines.
	  cat >${TESTDIR}/editme <<EOF
#!${TESTSHELL}
sleep 1
sed <\$1 -e 's/^/x&/g' >${TESTDIR}/edit.new
mv ${TESTDIR}/edit.new \$1
exit 0
EOF
	  chmod +x ${TESTDIR}/editme

	  mkdir 1; cd 1
	  dotest editor-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest editor-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch file1 file2
	  dotest editor-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest editor-4 "${testcvs} -e ${TESTDIR}/editme -q ci" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest editor-5 "${testcvs} -q tag -b br" "T file1
T file2"
	  dotest editor-6 "${testcvs} -q update -r br" ''
	  echo modify >>file1
	  dotest editor-7 "${testcvs} -e ${TESTDIR}/editme -q ci" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  # OK, now we want to make sure "ci -r" puts in the branch
	  # where appropriate.  Note that we can check in on the branch
	  # without being on the branch, because there is not a revision
	  # already on the branch.  If there were a revision on the branch,
	  # CVS would correctly give an up-to-date check failed.
	  dotest editor-8 "${testcvs} -q update -A" "U file1"
	  echo add a line >>file2
	  dotest editor-9 "${testcvs} -q -e ${TESTDIR}/editme ci -rbr file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  dotest editor-log-file1 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file1
xCVS: ----------------------------------------------------------------------
============================================================================="

	  # The only difference between the two expect strings is the
	  # presence or absence of "Committing in ." for 1.1.2.1.
	  dotest editor-log-file2 "${testcvs} log -N file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file2
xCVS: ----------------------------------------------------------------------
=============================================================================" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file2
xCVS: ----------------------------------------------------------------------
============================================================================="
	  cd ../..
	  rm -r 1
	  rm ${TESTDIR}/editme
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d4535 1
a4535 1
	      pass 162
d4537 2
a4538 1
	      fail 162
d4543 1
a4543 1
	      pass 163
d4545 2
a4546 1
	      fail 163
d4549 1
a4549 1
	      pass 164
d4551 2
a4552 1
	      fail 164
d4558 1
a4558 1
	      pass 165
d4560 2
a4561 1
	      fail 165
d4567 1
a4567 1
	      pass 166
d4569 2
a4570 1
	      fail 166
d4573 1
a4573 1
	      pass 167
d4575 2
a4576 1
	      fail 167
d4580 1
a4580 1
	  # FIXME: should be using dotest.
d4582 1
a4582 1
	  cat ../tst167.err >>${LOGFILE}
d4584 2
a4585 2
${PROG} server: warning: foo is not (any longer) pertinent
${PROG} update: unable to remove ./foo: Permission denied
d4588 1
a4588 1
	  ( echo "${PROG} [update aborted]: cannot rename file foo to CVS/,,foo: Permission denied" | cmp - ../tst167.err >/dev/null )
d4590 1
a4590 1
	      pass 168
d4592 2
a4593 1
	      fail 168
a4602 122
	errmsg2)
	  # More tests of various miscellaneous error handling,
	  # and cvs add behavior in general.
	  # See also test basicb-4a, concerning "cvs ci CVS".
	  # Too many tests to mention test the simple cases of
	  # adding files and directories.
	  # Test basicb-2a10 tests cvs -n add.

	  # First the usual setup; create a directory first-dir.
	  mkdir 1; cd 1
	  dotest errmsg2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest errmsg2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  dotest_fail errmsg2-3 "${testcvs} add CVS" \
"${PROG} [a-z]*: cannot add special file .CVS.; skipping"
	  touch file1
	  # For the most part add returns a failure exitstatus if
	  # there are any errors, even if the remaining files are
	  # processed without incident.  The "cannot add
	  # special file" message fits this pattern, at
	  # least currently.
	  dotest_fail errmsg2-4 "${testcvs} add CVS file1" \
"${PROG} [a-z]*: cannot add special file .CVS.; skipping
${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # I'm not sure these tests completely convey the various strange
	  # behaviors that CVS had before it specially checked for "." and
	  # "..".  Suffice it to say that these are unlikely to work right
	  # without a special case.
	  dotest_fail errmsg2-5 "${testcvs} add ." \
"${PROG} [a-z]*: cannot add special file .\..; skipping"
	  dotest_fail errmsg2-6 "${testcvs} add .." \
"${PROG} [a-z]*: cannot add special file .\.\..; skipping"
	  # Make sure that none of the error messages left droppings
	  # which interfere with normal operation.
	  dotest errmsg2-7 "${testcvs} -q ci -m add-file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  mkdir sdir
	  cd ..
	  dotest errmsg2-8 "${testcvs} add first-dir/sdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"

	  cd first-dir

	  touch file10
	  mkdir sdir10
	  dotest errmsg2-10 "${testcvs} add file10 sdir10" \
"${PROG} [a-z]*: scheduling file .file10. for addition
Directory ${TESTDIR}/cvsroot/first-dir/sdir10 added to the repository
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest errmsg2-11 "${testcvs} -q ci -m add-file10" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file10,v
done
Checking in file10;
${TESTDIR}/cvsroot/first-dir/file10,v  <--  file10
initial revision: 1\.1
done"
	  # Try to see that there are no droppings left by
	  # any of the previous tests.
	  dotest errmsg2-12 "${testcvs} -q update" ""

	  # Now test adding files with '/' in the name, both one level
	  # down and more than one level down.
	  cd ..
	  mkdir first-dir/sdir10/ssdir
	  dotest errmsg2-13 "${testcvs} add first-dir/sdir10/ssdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir10/ssdir added to the repository"

	  touch first-dir/sdir10/ssdir/ssfile
	  dotest errmsg2-14 \
	    "${testcvs} add first-dir/sdir10/ssdir/ssfile" \
"${PROG} [a-z]*: scheduling file .first-dir/sdir10/ssdir/ssfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  touch first-dir/file15
	  dotest errmsg2-15 "${testcvs} add first-dir/file15" \
"${PROG} [a-z]*: scheduling file .first-dir/file15. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  # Now the case where we try to give it a directory which is not
	  # under CVS control.
	  mkdir bogus-dir
	  touch bogus-dir/file16
	  # The first message, from local CVS, is nice.  The second one
	  # is not nice; would be good to fix remote CVS to give a clearer
	  # message (e.g. the one from local CVS).  But at least it is an
	  # error message.
	  dotest_fail errmsg2-16 "${testcvs} add bogus-dir/file16" \
"${PROG} [a-z]*: in directory bogus-dir:
${PROG} \[[a-z]* aborted\]: there is no version here; do .${PROG} checkout. first" \
"${PROG} [a-z]*: cannot open CVS/Entries for reading: No such file or directory
${PROG} \[add aborted\]: no repository"
	  rm -r bogus-dir

	  # One error condition we don't test for is trying to add a file
	  # or directory which already is there.

	  dotest errmsg2-17 "${testcvs} -q ci -m checkin" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file15,v
done
Checking in first-dir/file15;
${TESTDIR}/cvsroot/first-dir/file15,v  <--  file15
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir10/ssdir/ssfile,v
done
Checking in first-dir/sdir10/ssdir/ssfile;
${TESTDIR}/cvsroot/first-dir/sdir10/ssdir/ssfile,v  <--  ssfile
initial revision: 1\.1
done"

	  cd ..
	  rm -r 1
	  rm -rf ${TESTDIR}/cvsroot/first-dir
	  ;;

d4608 1
a4608 1
	      pass 169
d4610 2
a4611 1
	      fail 169
d4617 1
a4617 1
	      pass 170
d4619 2
a4620 1
	      fail 170
d4623 1
a4623 1
	      pass 171
d4625 2
a4626 1
	      fail 171
d4630 1
a4630 1
	      pass 172
d4632 1
a4632 1
	      fail 172
d4636 1
a4636 1
	      pass 173
d4638 1
a4638 1
	      fail 173
d4641 1
a4641 1
	      pass 174
d4643 1
a4643 1
	      fail 174
d4651 1
a4651 1
	      pass 175
d4653 1
a4653 1
	      fail 175
d4657 1
a4657 1
	      fail 176
d4659 1
a4659 1
	      pass 176
d4662 1
a4662 1
	      fail 177
d4664 1
a4664 1
	      pass 177
d4668 1
a4668 1
	      pass 178
d4670 1
a4670 1
	      fail 178
d4674 1
a4674 1
	      fail 178a
d4676 1
a4676 1
	      pass 178a
d4680 1
a4680 1
	      pass 179
d4682 2
a4683 1
	      fail 179
d4687 1
a4687 1
	      pass 180
d4689 2
a4690 1
	      fail 180
d4694 1
a4694 1
	      pass 181
d4696 1
a4696 1
	      fail 181
d4701 1
a4701 1
	      pass 182
d4703 1
a4703 1
	      fail 182
d4709 1
a4709 1
	      pass 183
d4711 1
a4711 1
	      fail 183
d4715 1
a4715 1
	      fail 184
d4717 1
a4717 1
	      pass 184
d4721 1
a4721 1
	      fail 185
d4723 1
a4723 1
	      pass 185
d4727 1
a4727 1
	      pass 186a1
d4729 1
a4729 1
	      fail 186a1
d4733 1
a4733 1
	      pass 186a2
d4735 1
a4735 1
	      fail 186a2
d4738 1
a4738 1
	      pass 186a3
d4740 1
a4740 1
	      fail 186a3
d4745 1
a4745 1
	      pass 186a4
d4747 1
a4747 1
	      fail 186a4
d4750 1
a4750 1
	      pass 186a5
d4752 1
a4752 1
	      fail 186a5
d4756 1
a4756 1
	      pass 186a6
d4758 1
a4758 1
	      fail 186a6
d4761 1
a4761 1
	      pass 186a7
d4763 1
a4763 1
	      fail 186a7
d4774 2
a4775 2
"abb	${username}	edit	unedit	commit
abc	${username}	edit	unedit	commit"
d4778 1
a4778 1
"abb	${username}	edit	commit"
a4800 23
	  # Test checking out the directory rather than the file.
	  mkdir 3
	  cd 3
	  dotest devcom-t2 "${testcvs} -q co -rtag first-dir" \
'U first-dir/abb
U first-dir/abc'
	  cd ..
	  # Since the files are readonly, use -f.
	  rm -rf 3

	  # Now do it again, after removing the val-tags file created
	  # by devcom-t1 to force CVS to search the repository
	  # containing CVS directories.
	  rm ${CVSROOT_DIRNAME}/CVSROOT/val-tags
	  mkdir 3
	  cd 3
	  dotest devcom-t3 "${testcvs} -q co -rtag first-dir" \
'U first-dir/abb
U first-dir/abc'
	  cd ..
	  # Since the files are readonly, use -f.
	  rm -rf 3

a4874 20

	  cd first-dir
	  # OK, now we want to try files in various states with cvs edit.
	  dotest devcom2-12 "${testcvs} edit w4" \
"${PROG} edit: no such file w4; ignored"
	  # Try the same thing with a per-directory watch set.
	  dotest devcom2-13 "${testcvs} watch on" ''
	  dotest devcom2-14 "${testcvs} edit w5" \
"${PROG} edit: no such file w5; ignored"
	  dotest devcom2-15 "${testcvs} editors" ''
	  dotest devcom2-16 "${testcvs} editors w4" ''
	  # Make sure there are no droppings lying around
	  dotest devcom2-17 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw1	_watched=
Fw2	_watched=
Fw3	_watched=
Fnw1	_watched=
D	_watched="
	  cd ..

d4939 7
a4945 103
	watch4)
	  # More watch tests, including adding directories.
	  mkdir 1; cd 1
	  dotest watch4-0a "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest watch4-0b "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"

	  cd first-dir
	  dotest watch4-1 "${testcvs} watch on" ''
	  # This is just like the 173 test
	  touch file1
	  dotest watch4-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest watch4-3 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  # Now test the analogous behavior for directories.
	  mkdir subdir
	  dotest watch4-4 "${testcvs} add subdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"
	  cd subdir
	  touch sfile
	  dotest watch4-5 "${testcvs} add sfile" \
"${PROG} [a-z]*: scheduling file .sfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest watch4-6 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/sfile,v
done
Checking in sfile;
${TESTDIR}/cvsroot/first-dir/subdir/sfile,v  <--  sfile
initial revision: 1\.1
done"
	  cd ../../..
	  mkdir 2; cd 2
	  dotest watch4-7 "${testcvs} -q co first-dir" "U first-dir/file1
U first-dir/subdir/sfile"
	  dotest_fail watch4-8 "test -w first-dir/file1" ''
	  dotest_fail watch4-9 "test -w first-dir/subdir/sfile" ''
	  cd first-dir
	  dotest watch4-10 "${testcvs} edit file1" ''
	  echo 'edited in 2' >file1
	  cd ../..

	  cd 1/first-dir
	  dotest watch4-11 "${testcvs} edit file1" ''
	  echo 'edited in 1' >file1
	  dotest watch4-12 "${testcvs} -q ci -m edit-in-1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../..
	  cd 2/first-dir
	  dotest watch4-13 "${testcvs} -q update" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into file1
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in file1
C file1"
	  if (echo yes | ${testcvs} unedit file1) >>${LOGFILE}; then
	    pass watch4-14
	  else
	    fail watch4-15
	  fi
	  # This could plausibly be defined to either go back to the revision
	  # which was cvs edit'd (the status quo), or back to revision 1.2
	  # (that is, the merge could update CVS/Base/file1).  We pick the
	  # former because it is easier to implement, not because we have
	  # thought much about which is better.
	  dotest watch4-16 "cat file1" ''
	  # Make sure CVS really thinks we are at 1.1.
	  dotest watch4-17 "${testcvs} -q update" "U file1"
	  dotest watch4-18 "cat file1" "edited in 1"
	  cd ../..

	  # As a sanity check, make sure we are in the right place.
	  dotest watch4-cleanup-1 "test -d 1" ''
	  dotest watch4-cleanup-1 "test -d 2" ''
	  # Specify -f because of the readonly files.
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	ignore)
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

	  dotest 187a1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
	  cd CVSROOT
	  echo rootig.c >cvsignore
	  dotest 187a2 "${testcvs} add cvsignore" "${PROG}"' [a-z]*: scheduling file `cvsignore'"'"' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'

d4949 1
a4949 2
"${PROG} [a-z]*: Examining \.
RCS file: ${TESTDIR}/cvsroot/CVSROOT/cvsignore,v
d4959 1
a4959 1
	      pass 187a4
d4961 2
a4962 1
	      fail 187a4
d4972 9
a4980 4
	  # We use sort because we can't predict the order in which
	  # the files will be listed.
	  dotest_sort 188a "${testcvs} import -m m -I optig.c first-dir tag1 tag2" \
'
d4982 1
a4982 1
I first-dir/defig.o
d4985 2
d4988 1
a4988 2
N first-dir/bar.c
N first-dir/foobar.c
d4990 2
a4991 3
	  dotest_sort 188b "${testcvs} import -m m -I ! second-dir tag3 tag4" \
'

d4993 1
a4995 1
N second-dir/foobar.c
d4997 1
a4997 1
N second-dir/rootig.c
d5018 2
a5019 2
	  dotest_sort 189d "${testcvs} -q update -I ! -I CVS" \
"${QUESTION} defig.o
a5020 1
${QUESTION} notig.c
d5022 1
a5022 1
${QUESTION} rootig.c"
d5048 1
a5048 1
	  dotest_sort 190 "${testcvs} -qn update" \
d5051 1
a5051 2
${QUESTION} second-dir/notig.c"
	  dotest_sort 191 "${testcvs} -qn update -I! -I CVS" \
d5053 4
d5059 1
a5059 1
${QUESTION} first-dir/rootig.c
d5061 7
a5067 1
${QUESTION} second-dir/notig.c"
a5093 2
	  cd ..
	  rm -r wnt
d5110 1
a5110 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d5178 1
a5178 1
${PROG} [a-z]*: nonmergeable file needs merge
d5194 8
a5201 5
	  dotest binfiles-9 "${testcvs} -q update -A" ''
	  dotest binfiles-10 "${testcvs} -q update -kk" '[UP] binfile'
	  dotest binfiles-11 "${testcvs} -q update" ''
	  dotest binfiles-12 "${testcvs} -q update -A" '[UP] binfile'
	  dotest binfiles-13 "${testcvs} -q update -A" ''
d5273 1
a5273 1
"${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d5292 1
a5292 47

	  # Now test that -A can clear the sticky option.
	  dotest binfiles-sticky5 "${testcvs} -q update -A nibfile" \
"[UP] nibfile"
	  dotest binfiles-sticky6 "${testcvs} -q status nibfile" \
"===================================================================
File: nibfile          	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest binfiles-15 "${testcvs} -q admin -kb nibfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/nibfile,v
done"
	  dotest binfiles-16 "${testcvs} -q update nibfile" "[UP] nibfile"
	  dotest binfiles-17 "${testcvs} -q status nibfile" \
"===================================================================
File: nibfile          	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"

	  dotest binfiles-o1 "${testcvs} admin -o1.3:: binfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
deleting revision 1\.5
deleting revision 1\.4
done"
	  dotest binfiles-o2 "${testcvs} admin -o::1.3 binfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
deleting revision 1\.2
deleting revision 1\.1
done"
	  dotest binfiles-o3 "${testcvs} -q log -h -N binfile" "
RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
Working file: binfile
head: 1\.3
branch:
locks: strict
access list:
keyword substitution: v
total revisions: 1
============================================================================="
a5304 12
	  #
	  # Cases (we are merging from the branch to the trunk):
	  # binfile.dat) File added on branch, not on trunk.
	  #      File should be marked for addition.
	  # brmod) File modified on branch, not on trunk.
	  #      File should be copied over to trunk (no merging is needed).
	  # brmod-trmod) File modified on branch, also on trunk.
	  #      This is a conflict.  Present the user with both files and
	  #      let them figure it out.
	  # brmod-wdmod) File modified on branch, not modified in the trunk
	  #      repository, but modified in the (trunk) working directory.
	  #      This is also a conflict.
a5309 10

	  # The most important thing here is that binfile, binfile2, &c
	  # each be distinct from each other.  We also make sure to include
	  # a few likely end-of-line patterns to make sure nothing is
	  # being munged as if in text mode.
	  awk 'BEGIN { printf "%c%c%c%c%c%c", 2, 10, 137, 0, 13, 10 }' \
	    </dev/null >../binfile
	  cat ../binfile ../binfile >../binfile2
	  cat ../binfile2 ../binfile >../binfile3

d5311 8
a5318 25
	  # tag_check_valid won't know it exists.  So if brmod didn't
	  # exist, we would have to invent it.
	  cp ../binfile brmod
	  cp ../binfile brmod-trmod
	  cp ../binfile brmod-wdmod
	  dotest binfiles2-1a \
"${testcvs} add -kb brmod brmod-trmod brmod-wdmod" \
"${PROG} [a-z]*: scheduling file .brmod. for addition
${PROG} [a-z]*: scheduling file .brmod-trmod. for addition
${PROG} [a-z]*: scheduling file .brmod-wdmod. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest binfiles2-1b "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod,v
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v
d5320 2
a5321 2
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d5324 1
a5324 3
	  dotest binfiles2-2 "${testcvs} -q tag -b br" 'T brmod
T brmod-trmod
T brmod-wdmod'
d5326 2
d5331 2
a5332 5
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  cp ../binfile2 brmod
	  cp ../binfile2 brmod-trmod
	  cp ../binfile2 brmod-wdmod
	  dotest binfiles2-5 "${testcvs} -q ci -m br-changes" \
a5337 12
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
d5340 1
a5340 4
"${PROG} [a-z]*: warning: binfile\.dat is not (any longer) pertinent
[UP] brmod
[UP] brmod-trmod
[UP] brmod-wdmod"
d5342 1
a5342 22
	  dotest binfiles2-7-brmod "cmp ../binfile brmod"
	  cp ../binfile3 brmod-trmod
	  dotest binfiles2-7a "${testcvs} -q ci -m tr-modify" \
"Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.2; previous revision: 1\.1
done"
	  cp ../binfile3 brmod-wdmod

	  dotest binfiles2-8 "${testcvs} -q update -j br" \
"U binfile\.dat
U brmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-trmod
${PROG} [a-z]*: file from working directory is now in .#brmod-trmod.1.2
C brmod-trmod
M brmod-wdmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-wdmod
${PROG} [a-z]*: file from working directory is now in .#brmod-wdmod.1.1
C brmod-wdmod"

a5343 205
	  dotest binfiles2-9-brmod "cmp ../binfile2 brmod"
	  dotest binfiles2-9-brmod-trmod "cmp ../binfile2 brmod-trmod"
	  dotest binfiles2-9-brmod-trmod "cmp ../binfile2 brmod-wdmod"
	  dotest binfiles2-9a-brmod-trmod "cmp ../binfile3 .#brmod-trmod.1.2"
	  dotest binfiles2-9a-brmod-wdmod "cmp ../binfile3 .#brmod-wdmod.1.1"

	  # Test that everything was properly scheduled.
	  dotest binfiles2-10 "${testcvs} -q ci -m checkin" \
"Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/binfile\.dat,v  <--  binfile\.dat
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.3; previous revision: 1\.2
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.2; previous revision: 1\.1
done"

	  dotest_fail binfiles2-o1 "${testcvs} -q admin -o :1.2 brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.2
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v: can't remove branch point 1\.1
${PROG} [a-z]*: cannot modify RCS file for .brmod-trmod."
	  dotest binfiles2-o2 "${testcvs} -q admin -o 1.1.2.1: brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.1\.2\.1
done"
	  dotest binfiles2-o3 "${testcvs} -q admin -o :1.2 brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.2
deleting revision 1\.1
done"
	  dotest binfiles2-o4 "${testcvs} -q log -N brmod-trmod" "
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
Working file: brmod-trmod
head: 1\.3
branch:
locks: strict
access list:
keyword substitution: b
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
checkin
============================================================================="
	  cd ..
	  cd ..

	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1
	  ;;

	mcopy)
	  # See comment at "mwrap" test for list of other wrappers tests.
	  # Test cvs's ability to handle nonmergeable files specified with
	  # -m 'COPY' in wrappers.  Similar to the binfiles2 test,
	  # which tests the same thing for binary files
	  # (which are non-mergeable in the same sense).
	  #
	  # Cases (we are merging from the branch to the trunk):
	  # brmod) File modified on branch, not on trunk.
	  #      File should be copied over to trunk (no merging is needed).
	  # brmod-trmod) File modified on branch, also on trunk.
	  #      This is a conflict.  Present the user with both files and
	  #      let them figure it out.
	  # brmod-wdmod) File modified on branch, not modified in the trunk
	  #      repository, but modified in the (trunk) working directory.
	  #      This is also a conflict.

	  # For the moment, remote CVS can't pass wrappers from CVSWRAPPERS
	  # (see wrap_send).  So skip these tests for remote.
	  if test "x$remote" = xno; then

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest mcopy-1 "${testcvs} -q co first-dir" ''
	  cd first-dir

	  # FIXCVS: unless a branch has at least one file on it,
	  # tag_check_valid won't know it exists.  So if brmod didn't
	  # exist, we would have to invent it.
	  echo 'brmod initial contents' >brmod
	  echo 'brmod-trmod initial contents' >brmod-trmod
	  echo 'brmod-wdmod initial contents' >brmod-wdmod
	  echo "* -m 'COPY'" >.cvswrappers
	  dotest mcopy-1a \
"${testcvs} add .cvswrappers brmod brmod-trmod brmod-wdmod" \
"${PROG} [a-z]*: scheduling file .\.cvswrappers. for addition
${PROG} [a-z]*: scheduling file .brmod. for addition
${PROG} [a-z]*: scheduling file .brmod-trmod. for addition
${PROG} [a-z]*: scheduling file .brmod-wdmod. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest mcopy-1b "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/\.cvswrappers,v
done
Checking in \.cvswrappers;
${TESTDIR}/cvsroot/first-dir/\.cvswrappers,v  <--  \.cvswrappers
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod,v
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
initial revision: 1\.1
done"

	  # NOTE: .cvswrappers files are broken (see comment in
	  # src/wrapper.c).  So doing everything via the environment
	  # variable is a workaround.  Better would be to test them
	  # both.
	  CVSWRAPPERS="* -m 'COPY'"
	  export CVSWRAPPERS
	  dotest mcopy-2 "${testcvs} -q tag -b br" 'T \.cvswrappers
T brmod
T brmod-trmod
T brmod-wdmod'
	  dotest mcopy-3 "${testcvs} -q update -r br" ''
	  echo 'modify brmod on br' >brmod
	  echo 'modify brmod-trmod on br' >brmod-trmod
	  echo 'modify brmod-wdmod on br' >brmod-wdmod
	  dotest mcopy-5 "${testcvs} -q ci -m br-changes" \
"Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest mcopy-6 "${testcvs} -q update -A" \
"[UP] brmod
[UP] brmod-trmod
[UP] brmod-wdmod"
	  dotest mcopy-7 "cat brmod brmod-trmod brmod-wdmod" \
"brmod initial contents
brmod-trmod initial contents
brmod-wdmod initial contents"

	  echo 'modify brmod-trmod again on trunk' >brmod-trmod
	  dotest mcopy-7a "${testcvs} -q ci -m tr-modify" \
"Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.2; previous revision: 1\.1
done"
	  echo 'modify brmod-wdmod in working dir' >brmod-wdmod

	  dotest mcopy-8 "${testcvs} -q update -j br" \
"U brmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-trmod
${PROG} [a-z]*: file from working directory is now in .#brmod-trmod.1.2
C brmod-trmod
M brmod-wdmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-wdmod
${PROG} [a-z]*: file from working directory is now in .#brmod-wdmod.1.1
C brmod-wdmod"

	  dotest mcopy-9 "cat brmod brmod-trmod brmod-wdmod" \
"modify brmod on br
modify brmod-trmod on br
modify brmod-wdmod on br"
	  dotest mcopy-9a "cat .#brmod-trmod.1.2 .#brmod-wdmod.1.1" \
"modify brmod-trmod again on trunk
modify brmod-wdmod in working dir"

	  # Test that everything was properly scheduled.
	  dotest mcopy-10 "${testcvs} -q ci -m checkin" \
"Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.3; previous revision: 1\.2
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.2; previous revision: 1\.1
done"
a5348 4
	  unset CVSWRAPPERS

	  fi # end of tests to be skipped for remote

d5353 2
a5354 1
	  # See "mwrap" for a list of other wrappers tests.
d5397 4
a5400 144
	binwrap2)
	  # Test the ability to specify binary-ness based on file name.
	  # See "mwrap" for a list of other wrappers tests.

	  mkdir dir-to-import
	  cd dir-to-import
	  touch foo.c foo.exe

	  # Specify that all files are binary except *.c.
	  # The order seems to matter, with the earlier rules taking
	  # precedence.  I'm not sure whether that is good or not,
	  # but it is the current behavior.
	  if ${testcvs} import -m message -I ! \
	      -W "*.c -k 'o'" -W "* -k 'b'" \
	      first-dir tag1 tag2 >>${LOGFILE}; then
	    pass binwrap2-1
	  else
	    fail binwrap2-1
	  fi
	  cd ..
	  rm -r dir-to-import
	  dotest binwrap2-2 "${testcvs} -q co first-dir" 'U first-dir/foo.c
U first-dir/foo.exe'
	  dotest binwrap2-3 "${testcvs} -q status first-dir" \
"===================================================================
File: foo\.c            	Status: Up-to-date

   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.c,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-ko

===================================================================
File: foo\.exe          	Status: Up-to-date

   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.exe,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

        binwrap3)
          # Test communication of file-specified -k wrappers between
          # client and server, in `import':
          #
          #   1. Set up a directory tree, populate it with files.
          #   2. Give each directory a different .cvswrappers file. 
          #   3. Give the server its own .cvswrappers file.
          #   4. Import the whole tree, see if the right files got set
          #      to binary.
          #
          # The tree has a top ("0th") level, and two subdirs, sub1/
          # and sub2/; sub2/ contains directory subsub/.  Every
          # directory has a .cvswrappers file as well as regular
          # files.
          #
          # In the file names, "foo-b.*" should end up binary, and
          # "foo-t.*" should end up text.  Don't worry about the two
          # letter extensions; they're just there to help me keep
          # things straight.
          #
          # Here's the directory tree:
          #
          # ./
          #    .cvswrappers
          #    foo-b.c0
          #    foo-b.sb
          #    foo-t.c1
          #    foo-t.st
          #
          #    sub1/             sub2/
          #      .cvswrappers      .cvswrappers
          #      foo-b.c1          foo-b.sb
          #      foo-b.sb          foo-b.st
          #      foo-t.c0          foo-t.c0
          #      foo-t.st          foo-t.c1
          #                        foo-t.c2
          #                        foo-t.c3
          #
          #                        subsub/
          #                          .cvswrappers
          #                          foo-b.c3
          #                          foo-b.sb
          #                          foo-t.c0
          #                          foo-t.c1
          #                          foo-t.c2
          #                          foo-t.st

          binwrap3_line1="This is a test file "
          binwrap3_line2="containing little of use "
          binwrap3_line3="except this non-haiku"

          binwrap3_text="${binwrap3_line1}${binwrap3_line2}${binwrap3_line3}"

          cd ${TESTDIR}

	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

          mkdir binwrap3 # the 0th dir
          mkdir binwrap3/sub1
          mkdir binwrap3/sub2
          mkdir binwrap3/sub2/subsub
          
          echo "*.c0 -k 'b'" > binwrap3/.cvswrappers
          echo "whatever -k 'b'" >> binwrap3/.cvswrappers
          echo ${binwrap3_text} > binwrap3/foo-b.c0
          echo ${binwrap3_text} > binwrap3/foo-b.sb
          echo ${binwrap3_text} > binwrap3/foo-t.c1
          echo ${binwrap3_text} > binwrap3/foo-t.st

          echo "*.c1 -k 'b'" > binwrap3/sub1/.cvswrappers
          echo "whatever -k 'b'" >> binwrap3/sub1/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub1/foo-b.c1
          echo ${binwrap3_text} > binwrap3/sub1/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub1/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub1/foo-t.st

          echo "*.st -k 'b'" > binwrap3/sub2/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub2/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub2/foo-b.st
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c1
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c2
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c3

          echo "*.c3 -k 'b'" > binwrap3/sub2/subsub/.cvswrappers
          echo "foo -k 'b'" >> binwrap3/sub2/subsub/.cvswrappers
          echo "c0* -k 'b'" >> binwrap3/sub2/subsub/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-b.c3
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c1
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c2
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.st

          # Now set up CVSROOT/cvswrappers, the easy way:
	  dotest binwrap3-1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
d5402 2
a5403 5
          # This destroys anything currently in cvswrappers, but
	  # presumably other tests will take care of it themselves if
	  # they use cvswrappers:
	  echo "foo*.sb  -k 'b'" > cvswrappers
	  dotest binwrap3-2 "${testcvs} -q ci -m cvswrappers-mod" \
d5409 13
a5421 31
          cd ..

          # Avoid environmental interference
          CVSWRAPPERS_SAVED=${CVSWRAPPERS}
          unset CVSWRAPPERS

          # Do the import
          cd binwrap3
	  # Not importing .cvswrappers tests whether the client is really
	  # letting the server know "honestly" whether the file is binary,
	  # rather than just letting the server see the .cvswrappers file.
          dotest binwrap3-2a \
"${testcvs} import -m . -I .cvswrappers binwrap3 tag1 tag2" \
"[NI] ${DOTSTAR}"

	  # OK, now test "cvs add".
          cd ..
	  rm -r binwrap3
          dotest binwrap3-2b "${testcvs} co binwrap3" "${DOTSTAR}"
          cd binwrap3
	  cd sub2
	  echo "*.newbin -k 'b'" > .cvswrappers
	  echo .cvswrappers >.cvsignore
	  echo .cvsignore >>.cvsignore
	  touch file1.newbin file1.txt
	  dotest binwrap3-2c "${testcvs} add file1.newbin file1.txt" \
"${PROG} [a-z]*: scheduling file .file1\.newbin. for addition
${PROG} [a-z]*: scheduling file .file1\.txt. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest binwrap3-2d "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/binwrap3/sub2/file1\.newbin,v
d5423 2
a5424 8
Checking in file1\.newbin;
${TESTDIR}/cvsroot/binwrap3/sub2/file1\.newbin,v  <--  file1\.newbin
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/binwrap3/sub2/file1\.txt,v
done
Checking in file1\.txt;
${TESTDIR}/cvsroot/binwrap3/sub2/file1\.txt,v  <--  file1\.txt
d5427 26
a5452 161
	  cd ..

          # Now check out the module and see which files are binary.
          cd ..
	  rm -r binwrap3
          dotest binwrap3-3 "${testcvs} co binwrap3" "${DOTSTAR}"
          cd binwrap3

          # Running "cvs status" and matching output is too
          # error-prone, too likely to falsely fail.  Instead, we'll
          # just grep the Entries lines:

          dotest binwrap3-top1 "grep foo-b.c0 ./CVS/Entries" \
                 "/foo-b.c0/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-top2 "grep foo-b.sb ./CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-top3 "grep foo-t.c1 ./CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-top4 "grep foo-t.st ./CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub1-1 "grep foo-b.c1 sub1/CVS/Entries" \
                 "/foo-b.c1/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-sub1-2 "grep foo-b.sb sub1/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-sub1-3 "grep foo-t.c0 sub1/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub1-4 "grep foo-t.st sub1/CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub2-1 "grep foo-b.sb sub2/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-sub2-2 "grep foo-b.st sub2/CVS/Entries" \
                 "/foo-b.st/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-sub2-3 "grep foo-t.c0 sub2/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub2-4 "grep foo-t.c1 sub2/CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub2-5 "grep foo-t.c2 sub2/CVS/Entries" \
                 "/foo-t.c2/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-sub2-6 "grep foo-t.c3 sub2/CVS/Entries" \
                 "/foo-t.c3/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-subsub1 "grep foo-b.c3 sub2/subsub/CVS/Entries" \
                 "/foo-b.c3/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-subsub2 "grep foo-b.sb sub2/subsub/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"

          dotest binwrap3-subsub3 "grep foo-t.c0 sub2/subsub/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-subsub4 "grep foo-t.c1 sub2/subsub/CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-subsub5 "grep foo-t.c2 sub2/subsub/CVS/Entries" \
                 "/foo-t.c2/1.1.1.1/[A-Za-z0-9 	:]*//"

          dotest binwrap3-subsub6 "grep foo-t.st sub2/subsub/CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"

	  dotest binwrap3-sub2-add1 "grep file1.newbin sub2/CVS/Entries" \
	    "/file1.newbin/1.1/[A-Za-z0-9 	:]*/-kb/"
	  dotest binwrap3-sub2-add2 "grep file1.txt sub2/CVS/Entries" \
	    "/file1.txt/1.1/[A-Za-z0-9 	:]*//"

          # Restore and clean up
          cd ..
	  rm -r binwrap3 CVSROOT
	  cd ..
	  rm -r wnt
	  rm -rf ${CVSROOT_DIRNAME}/binwrap3
          CVSWRAPPERS=${CVSWRAPPERS_SAVED}
          ;; 

	mwrap)
	  # Tests of various wrappers features:
	  # -m 'COPY' and cvs update: mwrap
	  # -m 'COPY' and joining: mcopy
	  # -k: binwrap, binwrap2
	  # -t/-f: hasn't been written yet.
	  # 
	  # Tests of different ways of specifying wrappers:
	  # CVSROOT/cvswrappers: mwrap
	  # -W: binwrap, binwrap2
	  # .cvswrappers in working directory, local: mcopy
	  # CVSROOT/cvswrappers, .cvswrappers remote: binwrap3
	  # CVSWRAPPERS environment variable: mcopy

	  # This test is similar to binfiles-con1; -m 'COPY' specifies
	  # non-mergeableness the same way that -kb does.

	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

	  dotest mwrap-c1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  echo "* -m 'COPY'" >>cvswrappers
	  dotest mwrap-c2 "${testcvs} -q ci -m wrapper-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  mkdir m1; cd m1
	  dotest mwrap-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest mwrap-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  dotest mwrap-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest mwrap-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done"
	  cd ../..
	  mkdir m2; cd m2
	  dotest mwrap-5 "${testcvs} -q co first-dir" "U first-dir/aa"
	  cd first-dir
	  echo "changed in m2" >aa
	  dotest mwrap-6 "${testcvs} -q ci -m m2-mod" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../..
	  cd m1/first-dir
	  echo "changed in m1" >aa
	  dotest_fail mwrap-7 "${testcvs} -nq update" "C aa"
	  dotest mwrap-8 "${testcvs} -q update" \
"U aa
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.2 from repository is now in aa
${PROG} [a-z]*: file from working directory is now in \.#aa\.1\.1
C aa"
	  dotest mwrap-9 "cat aa" "changed in m2"
	  dotest mwrap-10 "cat .#aa.1.1" "changed in m1"
	  cd ../..
	  cd CVSROOT
	  echo '# comment out' >cvswrappers
	  dotest mwrap-ce "${testcvs} -q ci -m wrapper-mod" \
a5460 2
	  cd ..
	  rm -r wnt
d5465 1
a5465 14
	  # Administrative file tests.
	  # Here is a list of where each administrative file is tested:
	  # loginfo: info
	  # modules: modules, modules2, modules3
	  # cvsignore: ignore
	  # verifymsg: info
	  # cvswrappers: mwrap
	  # config: config

	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

d5481 1
a5481 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d5497 1
a5497 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d5514 1
a5514 1
	  dotest info-9 "cat $TESTDIR/testlog" "xenv-valueyz=${username}=${TESTDIR}/cvsroot="
d5537 1
a5537 1
#!${TESTSHELL}
a5600 2
	  cd ..
	  rm -r wnt
a5603 42
	config)
	  # Tests of the CVSROOT/config file.  See the comment at the
	  # "info" tests for a full list of administrative file tests.

	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

	  dotest config-1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
	  cd CVSROOT
	  echo 'bogus line' >config
	  dotest config-3 "${testcvs} -q ci -m change-to-bogus-line" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  echo 'BogusOption=yes' >config
	  dotest config-4 "${testcvs} -q ci -m change-to-bogus-opt" \
"${PROG} [a-z]*: syntax error in ${TESTDIR}/cvsroot/CVSROOT/config: line 'bogus line' is missing '='
Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.3; previous revision: 1\.2
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  echo '# No config is a good config' > config
	  dotest config-5 "${testcvs} -q ci -m change-to-comment" \
"${PROG} [a-z]*: ${TESTDIR}/cvsroot/CVSROOT/config: unrecognized keyword 'BogusOption'
Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.4; previous revision: 1\.3
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  dotest config-6 "${testcvs} -q update" ''

	  cd ..
	  rm -r CVSROOT
	  cd ..
	  rm -r wnt
	  ;;

a5606 2
	  # We test this with some keyword expansion games, but the situation
	  # also arises if the user modifies the file while CVS is running.
d5619 1
a5619 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d5670 1
a5673 5
	  # Tests of each option to cvs log:
	  #   -h: admin-19a-log
	  #   -N: log, log2, admin-19a-log
	  #   -b, -r: log
	  #   -d: rcs
d5682 1
a5682 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d5684 1
a5684 8
	  # While we're at it, check multi-line comments, input from file,
	  # and trailing whitespace trimming
	  echo 'line 1     '	 >${TESTDIR}/comment.tmp
	  echo '     '		>>${TESTDIR}/comment.tmp
	  echo 'line 2	'	>>${TESTDIR}/comment.tmp
	  echo '	'	>>${TESTDIR}/comment.tmp
	  echo '  	  '	>>${TESTDIR}/comment.tmp
	  dotest log-3 "${testcvs} -q commit -F ${TESTDIR}/comment.tmp" \
a5690 1
	  rm -f ${TESTDIR}/comment.tmp
d5745 1
a5745 3
line 1

line 2"
a5888 23
	  dotest log-o0 "${testcvs} admin -o 1.2.2.2:: file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log-o1 "${testcvs} admin -o ::1.2.2.1 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log-o2 "${testcvs} admin -o 1.2.2.1:: file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.2\.2\.2
done"
	  dotest log-o3 "${testcvs} log file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 4;	selected revisions: 4
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev1b}
${log_trailer}"
	  dotest log-o4 "${testcvs} -q update -p -r 1.2.2.1 file1" \
"first branch revision"
d5897 4
d5908 1
a5908 1
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
a5915 4
	  # Setting the file description with add -m doesn't yet work
	  # client/server, so skip log2-4 for remote.
	  if test "x$remote" = xno; then

a5932 78
	  fi # end of tests skipped for remote

	  dotest log2-5 "${testcvs} admin -t-change-description file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log2-6 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
change-description
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
============================================================================="

	  # I believe that in Real Life (TM), this is broken for remote.
	  # That is, the filename in question must be the filename of a
	  # file on the server.  It only happens to work here because the
	  # client machine and the server machine are one and the same.
	  echo 'longer description' >${TESTDIR}/descrip
	  echo 'with two lines' >>${TESTDIR}/descrip
	  dotest log2-7 "${testcvs} admin -t${TESTDIR}/descrip file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log2-8 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
longer description
with two lines
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
============================================================================="

	  # Reading the description from stdin is broken for remote.
	  # See comments in cvs.texinfo for a few more notes on this.
	  if test "x$remote" = xno; then

	    if echo change from stdin | ${testcvs} admin -t -q file1
	    then
	      pass log2-9
	    else
	      fail log2-9
	    fi
	    dotest log2-10 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
change from stdin
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
============================================================================="

	  fi # end of tests skipped for remote

a5933 1
	  rm ${TESTDIR}/descrip
d5937 1
a5937 109
	  ;;

	ann)
	  # Tests of "cvs annotate".  See also basica-10.
	  mkdir 1; cd 1
	  dotest ann-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest ann-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  cat >file1 <<EOF
this
is
the
ancestral
file
EOF
	  dotest ann-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest ann-4 "${testcvs} -q ci -m add file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  cat >file1 <<EOF
this
is
a
file

with
a
blank
line
EOF
	  dotest ann-5 "${testcvs} -q ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest ann-6 "${testcvs} -q tag -b br" "T file1"
	  cat >file1 <<EOF
this
is
a
trunk file

with
a
blank
line
EOF
	  dotest ann-7 "${testcvs} -q ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest ann-8 "${testcvs} -q update -r br" "[UP] file1"
	  cat >file1 <<EOF
this
is
a
file

with
a
blank
line
and some
branched content
EOF
	  dotest ann-9 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"
	  # Note that this annotates the trunk despite the presence
	  # of a sticky tag in the current directory.  This is
	  # fairly bogus, but it is the longstanding behavior for
	  # whatever that is worth.
	  dotest ann-10 "${testcvs} ann" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.3          (${username} *[0-9a-zA-Z-]*): trunk file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line"
	  dotest ann-11 "${testcvs} ann -r br" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.1          (${username} *[0-9a-zA-Z-]*): file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): and some
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): branched content"
a5938 3
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
a5939 1

a5985 2
	    CREREPOS_ROOT=${TESTDIR}/crerepos

a5991 3

	    CREREPOS_ROOT=:ext:`hostname`:${TESTDIR}/crerepos

a6029 76
	  # Now test mixing repositories.  This kind of thing tends to
	  # happen accidentally when people work with several repositories.
	  mkdir 1; cd 1
	  dotest crerepos-8 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest crerepos-9 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch file1
	  dotest crerepos-10 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest crerepos-11 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  cd ../..
	  rm -r 1

	  mkdir 1; cd 1
	  dotest crerepos-12 "${testcvs} -d ${CREREPOS_ROOT} -q co -l ." ''
	  mkdir crerepos-dir
	  dotest crerepos-13 "${testcvs} add crerepos-dir" \
"Directory ${TESTDIR}/crerepos/crerepos-dir added to the repository"
	  cd crerepos-dir
	  touch cfile
	  dotest crerepos-14 "${testcvs} add cfile" \
"${PROG} [a-z]*: scheduling file .cfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest crerepos-15 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/crerepos/crerepos-dir/cfile,v
done
Checking in cfile;
${TESTDIR}/crerepos/crerepos-dir/cfile,v  <--  cfile
initial revision: 1\.1
done"
	  cd ../..
	  rm -r 1

	  mkdir 1; cd 1
	  dotest crerepos-16 "${testcvs} co first-dir" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/file1"
	  dotest crerepos-17 "${testcvs} -d ${CREREPOS_ROOT} co crerepos-dir" \
"${PROG} [a-z]*: Updating crerepos-dir
U crerepos-dir/cfile"

	  if test x`cat CVS/Repository` = x.; then
	    # RELATIVE_REPOS
	    # Fatal error so that we don't go traipsing through the
	    # directories which happen to have the same names from the
	    # wrong repository.
	    dotest_fail crerepos-18 "${testcvs} -q update" \
"${PROG} \[[a-z]* aborted\]: cannot open directory ${TESTDIR}/cvsroot/crerepos-dir: .*" ''
	  else
	    if test "$remote" = no; then
	      # The lack of an error doesn't mean CVS is really
	      # working (things are getting logged to the wrong
	      # history file and such).
	      dotest crerepos-18 "${testcvs} -q update" ''
	    else
	      # Fatal error so that we don't go traipsing through the
	      # directories which happen to have the same names from the
	      # wrong repository.
	      dotest_fail crerepos-18 "${testcvs} -q update" \
"protocol error: directory .${TESTDIR}/crerepos/crerepos-dir. not within root .${TESTDIR}/cvsroot."
	    fi
	  fi

	  cd ..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${TESTDIR}/crerepos
d6038 4
a6041 1
	  # See tests admin-13, admin-25 and rcs-8a for exporting RCS files.
a6046 1
	  #
a6051 9
	  #
	  # I also tried writing a file with the RCS supplied with
	  # HPUX A.09.05.  According to "man rcsintro" this is
	  # "Revision Number: 3.0; Release Date: 83/05/11".  There
	  # were a few minor differences like whitespace but at least
	  # in simple cases like this everything else seemed the same
	  # as the file written by RCS 5.7 (so I won't try to make it
	  # a separate test case).

d6203 1
d6205 3
a6207 37
	  # OK, here is another one.  This one was written by hand based on
	  # doc/RCSFILES and friends.
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file2,v
head			 	1.5                 ;
     branch        1.2.6;
access ;
symbols;
locks;
testofanewphrase @@without newphrase we'd have trouble extending @@@@ all@@ ;
1.5 date 71.01.01.01.00.00; author joe; state bogus; branches; next 1.4;
1.4 date 71.01.01.00.00.05; author joe; state bogus; branches; next 1.3;
1.3 date 70.12.31.15.00.05; author joe; state bogus; branches; next 1.2;
1.2 date 70.12.31.12.15.05; author me; state bogus; branches 1.2.6.1; next 1.1;
1.1 date 70.12.31.11.00.05; author joe; state bogus; branches; next; newph;
1.2.6.1 date 71.01.01.08.00.05; author joe; state Exp; branches; next;
desc @@@@
1.5 log @@@@ newphrase1; newphrase2 42; text @@head revision@@
1.4 log @@@@ text @@d1 1
a1 1
new year revision@@
1.3 log @@@@ text @@d1 1
a1 1
old year revision@@
1.2 log @@@@ text @@d1 1
a1 1
mid revision@@ 1.1

log           @@@@ text @@d1 1
a1 1
start revision@@
1.2.6.1 log @@@@ text @@d1 1
a1 1
branch revision@@
EOF
	  # First test the default branch.
	  dotest rcs-5 "${testcvs} -q update file2" "U file2"
	  dotest rcs-6 "cat file2" "branch revision"
d6209 1
a6209 18
	  # Now get rid of the default branch, it will get in the way.
	  dotest rcs-7 "${testcvs} admin -b file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  # But we do want to make sure that "cvs admin" leaves the newphrases
	  # in the file.
	  # The extra whitespace regexps are for the RCS library, which does
	  # not preserve whitespace in the dogmatic manner of RCS 5.7. -twp
	  dotest rcs-8 \
"grep testofanewphrase ${CVSROOT_DIRNAME}/first-dir/file2,v" \
"testofanewphrase[	 ][ 	]*@@without newphrase we'd have trouble extending @@@@ all@@[	 ]*;"
	  # The easiest way to test for newphrases in deltas and deltatexts
	  # is to just look at the whole file, I guess.
	  dotest rcs-8a "cat ${CVSROOT_DIRNAME}/first-dir/file2,v" \
"head	1\.5;
access;
symbols;
locks;
d6211 1
a6211 188
testofanewphrase	@@without newphrase we'd have trouble extending @@@@ all@@;

1\.5
date	71\.01\.01\.01\.00\.00;	author joe;	state bogus;
branches;
next	1\.4;

1\.4
date	71\.01\.01\.00\.00\.05;	author joe;	state bogus;
branches;
next	1\.3;

1\.3
date	70\.12\.31\.15\.00\.05;	author joe;	state bogus;
branches;
next	1\.2;

1\.2
date	70\.12\.31\.12\.15\.05;	author me;	state bogus;
branches
	1\.2\.6\.1;
next	1\.1;

1\.1
date	70\.12\.31\.11\.00\.05;	author joe;	state bogus;
branches;
next	;
newph	;

1\.2\.6\.1
date	71\.01\.01\.08\.00\.05;	author joe;	state Exp;
branches;
next	;


desc
@@@@


1\.5
log
@@@@
newphrase1	;
newphrase2	42;
text
@@head revision@@


1\.4
log
@@@@
text
@@d1 1
a1 1
new year revision@@


1\.3
log
@@@@
text
@@d1 1
a1 1
old year revision@@


1\.2
log
@@@@
text
@@d1 1
a1 1
mid revision@@


1\.1
log
@@@@
text
@@d1 1
a1 1
start revision@@


1\.2\.6\.1
log
@@@@
text
@@d1 1
a1 1
branch revision@@"

	  # For remote, the "update -p -D" usage seems not to work.
	  # I'm not sure what is going on.
	  if test "x$remote" = "xno"; then

	  if ${testcvs} -q update -p -D '1970-12-31 11:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-9 "cat ${TESTDIR}/rcs4.tmp" "start revision"
	  else
	    fail rcs-9
	  fi

	  if ${testcvs} -q update -p -D '1970-12-31 12:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-10 "cat ${TESTDIR}/rcs4.tmp" "mid revision"
	  else
	    fail rcs-10
	  fi

	  if ${testcvs} -q update -p -D '1971-01-01 00:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-11 "cat ${TESTDIR}/rcs4.tmp" "new year revision"
	  else
	    fail rcs-11
	  fi

	  # Same test as rcs-10, but with am/pm.
	  if ${testcvs} -q update -p -D 'December 31, 1970 12:30pm UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-12 "cat ${TESTDIR}/rcs4.tmp" "mid revision"
	  else
	    fail rcs-12
	  fi

	  # Same test as rcs-11, but with am/pm.
	  if ${testcvs} -q update -p -D 'January 1, 1971 12:30am UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-13 "cat ${TESTDIR}/rcs4.tmp" "new year revision"
	  else
	    fail rcs-13
	  fi

	  fi # end of tests skipped for remote

	  # OK, now make sure cvs log doesn't have any trouble with the
	  # newphrases and such.
	  dotest rcs-14 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.5
branch:
locks:
access list:
symbolic names:
keyword substitution: kv
total revisions: 6;	selected revisions: 6
description:
----------------------------
revision 1\.5
date: 1971/01/01 01:00:00;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.4
date: 1971/01/01 00:00:05;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.3
date: 1970/12/31 15:00:05;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.2
date: 1970/12/31 12:15:05;  author: me;  state: bogus;  lines: ${PLUS}1 -1
branches:  1\.2\.6;
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.1
date: 1970/12/31 11:00:05;  author: joe;  state: bogus;
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.2\.6\.1
date: 1971/01/01 08:00:05;  author: joe;  state: Exp;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
============================================================================="
	  cd ..

	  rm -r first-dir ${TESTDIR}/rcs4.tmp
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	big)

	  # Test ability to operate on big files.  Intention is to
d6234 1
a6234 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6243 1
a6243 2
	  mkdir 2
	  cd 2
a6244 12
	  cd ../first-dir
	  echo "add a line to the end" >>file1
	  dotest big-5 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../2/first-dir
	  # The idea here is particularly to test the Rcs-diff response
	  # and the reallocing thereof, for remote.
	  dotest big-6 "${testcvs} -q update" "[UP] file1"
	  cd ../..
d6251 1
a6251 1
	  rm -r first-dir 2
d6278 1
a6278 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6321 1
a6321 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6348 1
a6348 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6398 1
a6398 1
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
a6520 3
	  # See many tests (e.g. multibranch) for ordinary sticky tag
	  # operations such as adding files on branches.
	  # See "head" test for interaction between stick tags and HEAD.
d6531 1
a6531 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6558 1
a6558 48
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest sticky-14 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"

	  # Now back to tag1
	  dotest sticky-15 "${testcvs} -q update -r tag1" "[UP] file1
${PROG} [a-z]*: file2 is no longer in the repository"

	  rm file1
	  dotest sticky-16 "${testcvs} rm file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  # Hmm, this command seems to silently remove the tag from
	  # the file.  This appears to be intentional.
	  # The silently part especially strikes me as odd, though.
	  dotest sticky-17 "${testcvs} -q ci -m remove-it" ""
	  dotest sticky-18 "${testcvs} -q update -A" "U file1
U file2"
	  dotest sticky-19 "${testcvs} -q update -r tag1" \
"${PROG} [a-z]*: file1 is no longer in the repository
${PROG} [a-z]*: file2 is no longer in the repository"
	  dotest sticky-20 "${testcvs} -q update -A" "U file1
U file2"

	  # Now try with a numeric revision.
	  dotest sticky-21 "${testcvs} -q update -r 1.1 file1" "U file1"
	  rm file1
	  dotest sticky-22 "${testcvs} rm file1" \
"${PROG} [a-z]*: cannot remove file .file1. which has a numeric sticky tag of .1\.1."
	  # The old behavior was that remove allowed this and then commit
	  # gave an error, which was somewhat hard to clear.  I mean, you
	  # could get into a long elaborate discussion of this being a
	  # conflict and two ways to resolve it, but I don't really see
	  # why CVS should have a concept of conflict that arises, not from
	  # parallel development, but from CVS's own sticky tags.

	  # I'm kind of surprised that the "file1 was lost" doesn't crop
	  # up elsewhere in the testsuite.  It is a long-standing
	  # discrepency between local and remote CVS and should probably
	  # be cleaned up at some point.
	  dotest sticky-23 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: file1 was lost
U file1" "U file1"
a6566 8
	  # Various other tests relate to our ability to correctly
	  # set the keyword expansion mode.
	  # "binfiles" tests "cvs admin -k".
	  # "binfiles" and "binfiles2" test "cvs add -k".
	  # "rdiff" tests "cvs co -k".
	  # "binfiles" (and this test) test "cvs update -k".
	  # "binwrap" tests setting the mode from wrappers.
	  # I don't think any test is testing "cvs import -k".
d6594 1
a6594 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d6728 11
a6738 1
	  dotest keyword-17 "${testcvs} update -A file1" "U file1"
a6761 6
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	keywordlog)
a6762 29
	  mkdir 1; cd 1
	  dotest keywordlog-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest keywordlog-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo change >file1
	  dotest keywordlog-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  # Note that we wanted to try "ci -r 1.3 -m add file1" and CVS
	  # seemed to get all confused, thinking it was adding on a branch
	  # or something.  FIXME?  Do something about this?  Document it
	  # in BUGS or someplace?

	  dotest keywordlog-4 "${testcvs} -q ci -m add file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  cd ../..
	  mkdir 2; cd 2
	  dotest keywordlog-4a "${testcvs} -q co first-dir" "U first-dir/file1"
	  cd ../1/first-dir

d6768 1
a6768 1
	  dotest keywordlog-5 "${testcvs} ci -F ${TESTDIR}/comment.tmp file1" \
d6771 1
a6771 1
new revision: 1\.2; previous revision: 1\.1
d6774 1
a6774 11
	  dotest keywordlog-6 "${testcvs} -q tag -b br" "T file1"
	  dotest keywordlog-7 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"

	  cd ../../2/first-dir
	  dotest keywordlog-8 "${testcvs} -q update" "[UP] file1"
	  dotest keywordlog-9 "cat file1" \
d6776 1
a6776 1
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
a6779 1
	  cd ../../1/first-dir
d6782 1
a6782 1
	  dotest keywordlog-10 "${testcvs} ci -m modify file1" \
d6785 1
a6785 1
new revision: 1\.3; previous revision: 1\.2
d6787 1
a6787 14
	  dotest keywordlog-11 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"

	  cd ../../2/first-dir
	  dotest keywordlog-12 "${testcvs} -q update" "[UP] file1"
	  dotest keywordlog-13 "cat file1" \
d6789 1
a6789 1
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
d6792 1
a6792 1
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
a6797 30
	  cd ../../1/first-dir
	  dotest keywordlog-14 "${testcvs} -q update -r br" "[UP] file1"
	  echo br-change >>file1
	  dotest keywordlog-15 "${testcvs} -q ci -m br-modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"
	  dotest keywordlog-16 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
	  cd ../../2/first-dir
	  dotest keywordlog-17 "${testcvs} -q update -r br" "[UP] file1"
	  dotest keywordlog-18 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
d6799 1
a6799 28
	  dotest keywordlog-19 "${testcvs} -q co -p -r br first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
	  dotest keywordlog-20 "${testcvs} -q co -p first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"
	  dotest keywordlog-21 "${testcvs} -q co -p -r 1.2 first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"

	  rm -r 1 2
d6814 3
a6816 4
	  mkdir top-dir second-dir
	  dotest toplevel-2 "${testcvs} add top-dir second-dir" \
"Directory ${TESTDIR}/cvsroot/top-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
d6822 1
a6822 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a6829 14
	  cd ..

	  cd second-dir
	  touch file2
	  dotest toplevel-3s "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest toplevel-4s "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/second-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/second-dir/file2,v  <--  file2
initial revision: 1\.1
done"
d6845 6
a6850 1
	  # There is some sentiment that
d6854 1
a6854 1
	  # of the remote CVS behavior (which also updates CVSROOT).
d6865 3
a6870 23
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel-10 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"
	  # This tests more or less the same thing, in a particularly
	  # "real life" example.
	  dotest toplevel-11 "${testcvs} -q update -d second-dir" \
"U second-dir/file2"

	  # Now remove the CVS directory (people may do this manually,
	  # especially if they formed their habits with CVS
	  # 1.9 and older, which didn't create it.  Or perhaps the working
	  # directory itself was created with 1.9 or older).
	  rm -r CVS
	  # Now set the permissions so we can't recreate it.
	  chmod -w ../1
	  # Now see whether CVS has trouble because it can't create CVS.
	  dotest toplevel-12 "${testcvs} co top-dir" \
"${PROG} [a-z]*: warning: cannot make directory ./CVS: Permission denied
${PROG} [a-z]*: Updating top-dir"
	  chmod +w ../1

	  cd ..
a6871 3368
	  rm -rf ${CVSROOT_DIRNAME}/top-dir
	  ;;

	head)
	  # Testing handling of the HEAD special tag.
	  # There are many cases involving added and removed files
	  # which we don't yet try to deal with.
	  # TODO: We also could be paying much closer attention to
	  # "head of the trunk" versus "head of the default branch".
	  # That is what "cvs import" is doing here (but I didn't really
	  # fully follow through on writing the tests for that case).
	  mkdir imp-dir
	  cd imp-dir
	  echo 'imported contents' >file1
	  # It may seem like we don't do much with file2, but do note that
	  # the "cvs diff" invocations do also diff file2 (and come up empty).
	  echo 'imported contents' >file2
	  dotest head-1 "${testcvs} import -m add first-dir tag1 tag2" \
"N first-dir/file1
N first-dir/file2

No conflicts created by this import"
	  cd ..
	  rm -r imp-dir
	  mkdir 1
	  cd 1
	  dotest head-2 "${testcvs} -q co first-dir" \
"U first-dir/file1
U first-dir/file2"
	  cd first-dir
	  echo 'add a line on trunk' >> file1
	  dotest head-3 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest head-4 "${testcvs} -q tag trunktag" "T file1
T file2"
	  echo 'add a line on trunk after trunktag' >> file1
	  dotest head-5 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest head-6 "${testcvs} -q tag -b br1" "T file1
T file2"
	  dotest head-7 "${testcvs} -q update -r br1" ""
	  echo 'modify on branch' >>file1
	  dotest head-8 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3\.2\.1; previous revision: 1\.3
done"
	  dotest head-9 "${testcvs} -q tag brtag" "T file1
T file2"
	  echo 'modify on branch after brtag' >>file1
	  dotest head-10 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3\.2\.2; previous revision: 1\.3\.2\.1
done"
	  # With no sticky tags, HEAD is the head of the trunk.
	  dotest head-trunk-setup "${testcvs} -q update -A" "[UP] file1"
	  dotest head-trunk-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # and diff thinks so too.  Case (a) from the comment in
	  # cvs.texinfo (Common options).
	  dotest_fail head-trunk-diff "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.3
retrieving revision 1\.3\.2\.2
diff -c -r1\.3 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.3
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,3 \*\*\*\*
--- 1,5 ----
  imported contents
  add a line on trunk
  add a line on trunk after trunktag
${PLUS} modify on branch
${PLUS} modify on branch after brtag"

	  # With a branch sticky tag, HEAD is the head of the trunk.
	  dotest head-br1-setup "${testcvs} -q update -r br1" "[UP] file1"
	  dotest head-br1-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # But diff thinks that HEAD is "br1".  Case (b) from cvs.texinfo.
	  # Probably people are relying on it.
	  dotest head-br1-diff "${testcvs} -q diff -c -r HEAD -r br1" ""

	  # With a nonbranch sticky tag on a branch,
	  # HEAD is the head of the trunk
	  dotest head-brtag-setup "${testcvs} -q update -r brtag" "[UP] file1"
	  dotest head-brtag-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # But diff thinks that HEAD is "brtag".  Case (c) from
	  # cvs.texinfo (the "strange, maybe accidental" case).
	  dotest_fail head-brtag-diff "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.3\.2\.1
retrieving revision 1\.3\.2\.2
diff -c -r1\.3\.2\.1 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.3\.2\.1
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 2,4 \*\*\*\*
--- 2,5 ----
  add a line on trunk
  add a line on trunk after trunktag
  modify on branch
${PLUS} modify on branch after brtag"

	  # With a nonbranch sticky tag on the trunk, HEAD is the head
	  # of the trunk, I think.
	  dotest head-trunktag-setup "${testcvs} -q update -r trunktag" \
"[UP] file1"
	  dotest head-trunktag-check "cat file1" "imported contents
add a line on trunk"
	  dotest head-trunktag-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # Like head-brtag-diff, HEAD is the sticky tag.  Similarly
	  # questionable.
	  dotest_fail head-trunktag-diff \
	    "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.2
retrieving revision 1\.3\.2\.2
diff -c -r1\.2 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.2
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,2 \*\*\*\*
--- 1,5 ----
  imported contents
  add a line on trunk
${PLUS} add a line on trunk after trunktag
${PLUS} modify on branch
${PLUS} modify on branch after brtag"

	  # Also might test what happens if we setup with update -r
	  # HEAD.  In general, if sticky tags matter, does the
	  # behavior of "update -r <foo>" (without -p) depend on the
	  # sticky tags before or after the update?

	  # Note that we are testing both the case where this deletes
	  # a revision (file1) and the case where it does not (file2)
	  dotest_fail head-o0a "${testcvs} admin -o ::br1" \
"${PROG} [a-z]*: Administrating \.
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: cannot remove revision 1\.3\.2\.1 because it has tags
${PROG} [a-z]*: cannot modify RCS file for .file1.
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  dotest head-o0b "${testcvs} tag -d brtag" \
"${PROG} [a-z]*: Untagging \.
D file1
D file2"
	  dotest head-o1 "${testcvs} admin -o ::br1" \
"${PROG} [a-z]*: Administrating \.
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.3\.2\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	tagdate)
	  # Test combining -r and -D.
	  mkdir 1; cd 1
	  dotest tagdate-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest tagdate-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  echo trunk-1 >file1
	  dotest tagdate-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest tagdate-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest tagdate-5 "${testcvs} -q tag -b br1" "T file1"
	  dotest tagdate-6 "${testcvs} -q tag -b br2" "T file1"
	  echo trunk-2 >file1
	  dotest tagdate-7 "${testcvs} -q ci -m modify-on-trunk" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  # We are testing -r -D where br1 is a (magic) branch without
	  # any revisions.  First the case where br2 doesn't have any
	  # revisions either:
	  dotest tagdate-8 "${testcvs} -q update -p -r br1 -D now" "trunk-1"
	  dotest tagdate-9 "${testcvs} -q update -r br2" "[UP] file1"
	  echo br2-1 >file1
	  dotest tagdate-10 "${testcvs} -q ci -m modify-on-br2" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done"
	  # Then the case where br2 does have revisions:
	  dotest tagdate-11 "${testcvs} -q update -p -r br1 -D now" "trunk-1"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	multibranch2)
	  # Commit the first delta on branch A when there is an older
	  # branch, B, that already has a delta.  A and B come from the
	  # same branch point.  Then verify that branches A and B are
	  # in the right order.
	  mkdir 1; cd 1
	  dotest multibranch2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest multibranch2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  echo trunk-1 >file1
	  echo trunk-1 >file2
	  dotest multibranch2-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest multibranch2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest multibranch2-5 "${testcvs} -q tag -b A" "T file1
T file2"
	  dotest multibranch2-6 "${testcvs} -q tag -b B" "T file1
T file2"

	  dotest multibranch2-7 "${testcvs} -q update -r B" ''
	  echo branch-B >file1
	  echo branch-B >file2
	  dotest multibranch2-8 "${testcvs} -q ci -m modify-on-B" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.4\.1; previous revision: 1\.1
done"

	  dotest multibranch2-9 "${testcvs} -q update -r A" '[UP] file1
[UP] file2'
	  echo branch-A >file1
	  # When using cvs-1.9.20, this commit gets a failed assertion in rcs.c.
	  dotest multibranch2-10 "${testcvs} -q ci -m modify-on-A" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  dotest multibranch2-11 "${testcvs} -q log file1" \
"
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	B: 1\.1\.0\.4
	A: 1\.1\.0\.2
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;
branches:  1\.1\.2;  1\.1\.4;
add
----------------------------
revision 1\.1\.4\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;  lines: ${PLUS}1 -1
modify-on-B
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;  lines: ${PLUS}1 -1
modify-on-A
============================================================================="

	  # This one is more concise.
	  dotest multibranch2-12 "${testcvs} -q log -r1.1 file1" \
"
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	B: 1\.1\.0\.4
	A: 1\.1\.0\.2
keyword substitution: kv
total revisions: 3;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;
branches:  1\.1\.2;  1\.1\.4;
add
============================================================================="

	  # OK, try very much the same thing except we run update -j to
	  # bring the changes from B to A.  Probably tests many of the
	  # same code paths but might as well keep it separate, I guess.

	  dotest multibranch2-13 "${testcvs} -q update -r B" "[UP] file1
[UP] file2"
	  dotest multibranch2-14 "${testcvs} -q update -r A -j B file2" \
"[UP] file2
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
retrieving revision 1.1
retrieving revision 1.1.4.1
Merging differences between 1.1 and 1.1.4.1 into file2"
	  dotest multibranch2-15 "${testcvs} -q ci -m commit-on-A file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;


	admin)
	  # More "cvs admin" tests.
	  # The basicb-21 test tests rejecting an illegal option.
	  # For -l and -u, see "reserved" and "keyword" tests.
	  # "binfiles" test has a test of "cvs admin -k".
	  # "log2" test has tests of -t and -q options to cvs admin.
	  # "rcs" tests -b option also.
	  # For -o, see:
	  #   admin-22-o1 through admin-23 (various cases not involving ::)
	  #   binfiles2-o* (:rev, rev on trunk; rev:, deleting entire branch)
	  #   basica-o1 through basica-o3 (basic :: usage)
	  #   head-o1 (::branch, where this deletes a revision or is noop)
	  #   branches-o1 (::branch, similar, with different branch topology)
	  #   log-o1 (1.3.2.1::)
	  #   binfiles-o1 (1.3:: and ::1.3)
	  #   Also could be testing:
	  #     1.3.2.6::1.3.2.8
	  #     1.3.2.6::1.3.2
	  #     1.3.2.1::1.3.2.6
	  #     1.3::1.3.2.6 (error?  or synonym for ::1.3.2.6?)

	  mkdir 1; cd 1
	  dotest admin-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest admin-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir

	  dotest_fail admin-3 "${testcvs} -q admin -i file1" \
"${PROG} admin: the -i option to admin is not supported
${PROG} admin: run add or import to create an RCS file
${PROG} \[admin aborted\]: specify ${PROG} -H admin for usage information"
	  dotest_fail admin-4 "${testcvs} -q log file1" \
"${PROG} [a-z]*: nothing known about file1"

	  # Set up some files, file2 a plain one and file1 with a revision
	  # on a branch.
	  touch file1 file2
	  dotest admin-5 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest admin-6 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest admin-7 "${testcvs} -q tag -b br" "T file1
T file2"
	  dotest admin-8 "${testcvs} -q update -r br" ""
	  echo 'add a line on the branch' >> file1
	  dotest admin-9 "${testcvs} -q ci -m modify-on-branch" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest admin-10 "${testcvs} -q update -A" "U file1"

	  # Try to recurse with a numeric revision arg.
	  # If we wanted to comprehensive about this, we would also test
	  # this for -l, -u, and all the different -o syntaxes.
	  dotest_fail admin-10a "${testcvs} -q admin -b1.1.2" \
"${PROG} [a-z]*: while processing more than one file:
${PROG} \[[a-z]* aborted\]: attempt to specify a numeric revision"
	  dotest_fail admin-10b "${testcvs} -q admin -m1.1:bogus file1 file2" \
"${PROG} [a-z]*: while processing more than one file:
${PROG} \[[a-z]* aborted\]: attempt to specify a numeric revision"

	  # Note that -s option applies to the new default branch, not
	  # the old one.
	  # Also note that the implementation of -a via "rcs" requires
	  # no space between -a and the argument.  However, we expect
	  # to change that once CVS parses options.
	  dotest admin-11 "${testcvs} -q admin -afoo,bar -abaz \
-b1.1.2 -cxx -U -sfoo file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"

	  dotest admin-12 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch: 1\.1\.2
locks:
access list:
	foo
	bar
	baz
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="

	  # "cvs log" doesn't print the comment leader.  RCS 5.7 will print
	  # the comment leader only if one specifies "-V4" to rlog.  So it
	  # seems like the only way to test it is by looking at the RCS file
	  # directly.  This also serves as a test of exporting RCS files
	  # (analogous to the import tests in "rcs").
	  # Rather than try to write a rigorous check for whether the
	  # file CVS exports is legal, we just write a simpler
	  # test for what CVS actually exports, and figure we can revise
	  # the check as needed (within the confines of the RCS5 format as
	  # documented in RCSFILES).
	  dotest admin-13 "cat ${CVSROOT_DIRNAME}/first-dir/file1,v" \
"head	1\.1;
branch	1\.1\.2;
access
	foo
	bar
	baz;
symbols
	br:1\.1\.0\.2;
locks;
comment	@@xx@@;


1\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches
	1\.1\.2\.1;
next	;

1\.1\.2\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
branches;
next	;


desc
@@@@


1\.1
log
@@add
@@
text
@@@@


1\.1\.2\.1
log
@@modify-on-branch
@@
text
@@a0 1
add a line on the branch
@@"
	  dotest admin-14 "${testcvs} -q admin -aauth3 -aauth2,foo \
-soneone:1.1 -m1.1:changed-log-message -ntagone: file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  dotest admin-15 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
	auth3
	auth2
	foo
symbolic names:
	tagone: 1\.1
	br: 1\.1\.0\.2
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: oneone;
changed-log-message
============================================================================="

	  dotest admin-16 "${testcvs} -q admin \
-A${CVSROOT_DIRNAME}/first-dir/file2,v -b -L -Nbr:1.1 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-17 "${testcvs} -q log file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	bar
	baz
	auth3
	auth2
symbolic names:
	br: 1\.1
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="

	  dotest_fail admin-18 "${testcvs} -q admin -nbr:1.1.2 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file1,v: symbolic name br already bound to 1\.1
${PROG} [a-z]*: cannot modify RCS file for .file1."
	  dotest admin-19 "${testcvs} -q admin -ebaz -ebar,auth3 -nbr file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-20 "${testcvs} -q log file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	auth2
symbolic names:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1.1.2.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="

	  # OK, this is starting to get ridiculous, in terms of
	  # testing a feature (access lists) which doesn't do anything
	  # useful, but what about nonexistent files and
	  # relative pathnames in admin -A?
	  dotest_fail admin-19a-nonexist \
"${testcvs} -q admin -A${TESTDIR}/foo/bar file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: Couldn't open rcs file .${TESTDIR}/foo/bar.: No such file or directory
${PROG} \[[a-z]* aborted\]: cannot continue"

	  # In the remote case, we are cd'd off into the temp directory
	  # and so these tests give "No such file or directory" errors.
	  if test "x$remote" = xno; then

	  dotest admin-19a-admin "${testcvs} -q admin -A../../cvsroot/first-dir/file2,v file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-19a-log "${testcvs} -q log -h -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	auth2
	auth3
keyword substitution: kv
total revisions: 2
============================================================================="
	  # Put the access list back, to avoid special cases later.
	  dotest admin-19a-fix "${testcvs} -q admin -eauth3 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  fi # end of tests skipped for remote

	  # Add another revision to file2, so we can delete one.
	  echo 'add a line' >> file2
	  dotest admin-21 "${testcvs} -q ci -m modify file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest admin-22 "${testcvs} -q admin -o1.1 file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
deleting revision 1\.1
done"
	  # Test admin -o.  More variants that we could be testing:
	  # * REV: [on branch]
	  # * REV1:REV2 [deleting whole branch]
	  # * high branch numbers (e.g. 1.2.2.3.2.3)
	  # ... and probably others.  See RCS_delete_revs for ideas.

	  echo first rev > aaa
	  dotest admin-22-o1 "${testcvs} add aaa" \
"${PROG} [a-z]*: scheduling file .aaa. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest admin-22-o2 "${testcvs} -q ci -m first aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
done
Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
initial revision: 1\.1
done"
	  echo second rev >> aaa
	  dotest admin-22-o3 "${testcvs} -q ci -m second aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.2; previous revision: 1\.1
done"
	  echo third rev >> aaa
	  dotest admin-22-o4 "${testcvs} -q ci -m third aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3; previous revision: 1\.2
done"
	  echo fourth rev >> aaa
	  dotest admin-22-o5 "${testcvs} -q ci -m fourth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.4; previous revision: 1\.3
done"
	  echo fifth rev >>aaa
	  dotest admin-22-o6 "${testcvs} -q ci -m fifth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.5; previous revision: 1\.4
done"
	  echo sixth rev >> aaa
	  dotest admin-22-o7 "${testcvs} -q ci -m sixth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.6; previous revision: 1\.5
done"
	  dotest admin-22-o8 "${testcvs} admin -l1.6 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
1\.6 locked
done"
	  dotest admin-22-o9 "${testcvs} log -r1.6 aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.6
branch:
locks: strict
	${username}: 1\.6
access list:
symbolic names:
keyword substitution: kv
total revisions: 6;	selected revisions: 1
description:
----------------------------
revision 1\.6	locked by: ${username};
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
sixth
============================================================================="
	  dotest_fail admin-22-o10 "${testcvs} admin -o1.5: aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/aaa,v: can't remove locked revision 1\.6
${PROG} [a-z]*: cannot modify RCS file for .aaa."
	  dotest admin-22-o11 "${testcvs} admin -u aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
1\.6 unlocked
done"
	  dotest admin-22-o12 "${testcvs} admin -o1.5: aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.6
deleting revision 1\.5
done"
	  dotest admin-22-o13 "${testcvs} log aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4;	selected revisions: 4
description:
----------------------------
revision 1\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
fourth
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
third
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
second
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
first
============================================================================="

	  dotest admin-22-o14 "${testcvs} tag -b -r1.3 br1 aaa" "T aaa"
	  dotest admin-22-o15 "${testcvs} update -rbr1 aaa" "U aaa"
	  echo new branch rev >> aaa
	  dotest admin-22-o16 "${testcvs} ci -m new-branch aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.1; previous revision: 1\.3
done"
	  dotest_fail admin-22-o17 "${testcvs} admin -o1.2:1.4 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.4
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/aaa,v: can't remove branch point 1\.3
${PROG} [a-z]*: cannot modify RCS file for .aaa."
	  dotest admin-22-o18 "${testcvs} update -p -r1.4 aaa" \
"===================================================================
Checking out aaa
RCS:  ${TESTDIR}/cvsroot/first-dir/aaa,v
VERS: 1\.4
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
first rev
second rev
third rev
fourth rev"
	  echo second branch rev >> aaa
	  dotest admin-22-o19 "${testcvs} ci -m branch-two aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.2; previous revision: 1\.3\.2\.1
done"
	  echo third branch rev >> aaa
	  dotest admin-22-o20 "${testcvs} ci -m branch-three aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.3; previous revision: 1\.3\.2\.2
done"
	  echo fourth branch rev >> aaa
	  dotest admin-22-o21 "${testcvs} ci -m branch-four aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.4; previous revision: 1\.3\.2\.3
done"
	  dotest admin-22-o22 "${testcvs} admin -o:1.3.2.3 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.3\.2\.1
deleting revision 1\.3\.2\.2
deleting revision 1\.3\.2\.3
done"
	  dotest admin-22-o23 "${testcvs} log aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.4
branch:
locks: strict
access list:
symbolic names:
	br1: 1\.3\.0\.2
keyword substitution: kv
total revisions: 5;	selected revisions: 5
description:
----------------------------
revision 1\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
fourth
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
branches:  1\.3\.2;
third
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
second
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
first
----------------------------
revision 1\.3\.2\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}4 -0
branch-four
============================================================================="

	  dotest admin-22-o24 "${testcvs} -q update -p -r 1.3.2.4 aaa" \
"first rev
second rev
third rev
new branch rev
second branch rev
third branch rev
fourth branch rev"

	  # The bit here about how there is a "tagone" tag pointing to
	  # a nonexistent revision is documented by rcs.  I dunno, I
	  # wonder whether the "cvs admin -o" should give a warning in
	  # this case.
	  dotest admin-23 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.2
branch:
locks: strict
access list:
	auth3
	auth2
	foo
symbolic names:
	tagone: 1\.1
	br: 1\.1\.0\.2
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
modify
============================================================================="

	  dotest admin-25 "cat ${CVSROOT_DIRNAME}/first-dir/file1,v" \
"head	1\.1;
access
	foo
	auth2;
symbols;
locks; strict;
comment	@@xx@@;


1\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches
	1\.1\.2\.1;
next	;

1\.1\.2\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
branches;
next	;


desc
@@@@


1\.1
log
@@add
@@
text
@@@@


1\.1\.2\.1
log
@@modify-on-branch
@@
text
@@a0 1
add a line on the branch
@@"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	reserved)
	  # Tests of reserved checkouts.  Eventually this will test
	  # rcslock.pl (or equivalent) and all kinds of stuff.  Right
	  # now it just does some very basic checks on cvs admin -u
	  # and cvs admin -l.
	  # Also should test locking on a branch (and making sure that
	  # locks from one branch don't get mixed up with those from
	  # another.  Both the case where one of the branches is the
	  # main branch, and in which neither one is).
	  # See also test keyword, which tests that keywords and -kkvl
	  # do the right thing in the presence of locks.

	  # The usual setup, directory first-dir containing file file1.
	  mkdir 1; cd 1
	  dotest reserved-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest reserved-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  touch file1
	  dotest reserved-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest reserved-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  dotest reserved-5 "${testcvs} -q admin -l file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 locked
done"
	  dotest reserved-6 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
	${username}: 1\.1
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1	locked by: ${username};
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add
============================================================================="

	  # Note that this just tests the owner of the lock giving
	  # it up.  It doesn't test breaking a lock.
	  dotest reserved-7 "${testcvs} -q admin -u file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 unlocked
done"

	  dotest reserved-8 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add
============================================================================="

	  # rcslock.pl tests.  Of course, the point isn't to test
	  # rcslock.pl from the distribution but equivalent
	  # functionality (for example, many sites may have an old
	  # rcslock.pl).  The functionality of this hook falls
	  # short of the real rcslock.pl though.
	  # Note that we can use rlog or look at the RCS file directly,
	  # but we can't use "cvs log" because "cvs commit" has a lock.

	  cat >${TESTDIR}/lockme <<EOF
#!${TESTSHELL}
line=\`grep <\$1/\$2,v 'locks ${username}:1\.[0-9];'\`
if test -z "\$line"; then
  # It isn't locked
  exit 0
else
  user=\`echo \$line | sed -e 's/locks \\(${username}\\):[0-9.]*;.*/\\1/'\`
  version=\`echo \$line | sed -e 's/locks ${username}:\\([0-9.]*\\);.*/\\1/'\`
  echo "\$user has file a-lock locked for version  \$version"
  exit 1
fi
EOF
	  chmod +x ${TESTDIR}/lockme

	  echo stuff > a-lock
	  dotest reserved-9 "${testcvs} add a-lock" \
"${PROG} [a-z]*: scheduling file .a-lock. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest reserved-10 "${testcvs} -q ci -m new a-lock" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a-lock,v
done
Checking in a-lock;
${TESTDIR}/cvsroot/first-dir/a-lock,v  <--  a-lock
initial revision: 1\.1
done"
	  # FIXME: the contents of CVSROOT fluctuate a lot
	  # here. Maybe the expect pattern should just
	  # confirm that commitinfo is one of the files checked out,
	  # but for now we just check that CVS exited with success.
	  cd ..
	  if ${testcvs} -q co CVSROOT >>${LOGFILE} ; then
	    pass reserved-11
	  else
	    fail reserved-11
	  fi
	  cd CVSROOT
	  echo "DEFAULT ${TESTDIR}/lockme" >>commitinfo
	  dotest reserved-12 "${testcvs} -q ci -m rcslock commitinfo" \
"Checking in commitinfo;
${TESTDIR}/cvsroot/CVSROOT/commitinfo,v  <--  commitinfo
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..; cd first-dir

	  # Simulate (approximately) what a-lock would look like
	  # if someone else had locked revision 1.1.
	  sed -e 's/locks; strict;/locks fred:1.1; strict;/' ${TESTDIR}/cvsroot/first-dir/a-lock,v > a-lock,v
	  chmod 644 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  dotest reserved-13 "mv a-lock,v ${TESTDIR}/cvsroot/first-dir/a-lock,v"
	  chmod 444 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  echo more stuff >> a-lock
	  dotest_fail reserved-13b "${testcvs} ci -m '' a-lock" \
"fred has file a-lock locked for version  1\.1
${PROG} [a-z]*: Pre-commit check failed
${PROG} \[[a-z]* aborted\]: correct above errors first!"

	  dotest reserved-14 "${testcvs} admin -u1.1 a-lock" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a-lock,v
1\.1 unlocked
done"
	  dotest reserved-15 "${testcvs} -q ci -m success a-lock" \
"Checking in a-lock;
${TESTDIR}/cvsroot/first-dir/a-lock,v  <--  a-lock
new revision: 1\.2; previous revision: 1\.1
done"

	  # undo commitinfo changes
	  cd ../CVSROOT
	  echo '# vanilla commitinfo' >commitinfo
	  dotest reserved-16 "${testcvs} -q ci -m back commitinfo" \
"Checking in commitinfo;
${TESTDIR}/cvsroot/CVSROOT/commitinfo,v  <--  commitinfo
new revision: 1\.3; previous revision: 1\.2
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..; rm -r CVSROOT; cd first-dir

	  cd ../..
	  rm -r 1
	  rm ${TESTDIR}/lockme
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	cvsadm)
	  # These test check the content of CVS' administrative
	  # files as they are checked out in various configurations.
	  # (As a side note, I'm not using the "-q" flag in any of
	  # this code, which should provide some extra checking for
          # those messages which don't seem to be checked thoroughly
	  # anywhere else.)  To do a thorough test, we need to make
	  # a bunch of modules in various configurations.
	  #
	  # <1mod> is a directory at the top level of cvsroot
	  #    ``foo bar''
	  # <2mod> is a directory at the second level of cvsroot
	  #    ``foo bar/baz''
	  # <1d1mod> is a directory at the top level which is
	  #   checked out into another directory
	  #     ``foo -d bar baz''
	  # <1d2mod> is a directory at the second level which is
	  #   checked out into another directory
	  #     ``foo -d bar baz/quux''
	  # <2d1mod> is a directory at the top level which is
	  #   checked out into a directory that is two deep
	  #     ``foo -d bar/baz quux''
	  # <2d2mod> is a directory at the second level which is
	  #   checked out into a directory that is two deep
	  #     ``foo -d bar/baz quux''
	  #
	  # The tests do each of these types separately and in twos.
	  # We also repeat each test -d flag for 1-deep and 2-deep
	  # directories.
	  #
	  # Each test should check the output for the Repository
	  # file, since that is the one which varies depending on 
	  # the directory and how it was checked out.
	  #
	  # Yes, this is verbose, but at least it's very thorough.

	  # convenience variables
	  REP=${CVSROOT}

	  # First, check out the modules file and edit it.
	  mkdir 1; cd 1
	  dotest cvsadm-1 "${testcvs} co CVSROOT/modules" \
"U CVSROOT/modules"

	  # Try to determine whether RELATIVE_REPOS is defined
	  # so that we can make the following a lot less
	  # verbose.

	  echo "${CVSROOT_DIRNAME}/." > ${TESTDIR}/dotest.abs
	  echo "." > ${TESTDIR}/dotest.rel
	  if cmp ${TESTDIR}/dotest.abs CVS/Repository >/dev/null 2>&1; then
	    AREP="${CVSROOT_DIRNAME}/"
	  elif cmp ${TESTDIR}/dotest.rel CVS/Repository >/dev/null 2>&1; then
	    AREP=""
	  else
	    fail "Cannot figure out if RELATIVE_REPOS is defined."
	  fi

	  # Test CVS/Root once.  Since there is only one part of
	  # the code which writes CVS/Root files (Create_Admin),
	  # there is no point in testing this every time.
	  dotest cvsadm-1a "cat CVS/Root" ${REP}
	  dotest cvsadm-1b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1c "cat CVSROOT/CVS/Root" ${REP}
	  dotest cvsadm-1d "cat CVSROOT/CVS/Repository" \
"${AREP}CVSROOT"
          # All of the defined module names begin with a number.
	  # All of the top-level directory names begin with "dir".
	  # All of the subdirectory names begin with "sub".
	  # All of the top-level modules begin with "mod".
	  echo "# Module defs for cvsadm tests" > CVSROOT/modules
	  echo "1mod mod1" >> CVSROOT/modules
	  echo "1mod-2 mod1-2" >> CVSROOT/modules
	  echo "2mod mod2/sub2" >> CVSROOT/modules
	  echo "2mod-2 mod2-2/sub2-2" >> CVSROOT/modules
	  echo "1d1mod -d dir1d1 mod1" >> CVSROOT/modules
	  echo "1d1mod-2 -d dir1d1-2 mod1-2" >> CVSROOT/modules
	  echo "1d2mod -d dir1d2 mod2/sub2" >> CVSROOT/modules
	  echo "1d2mod-2 -d dir1d2-2 mod2-2/sub2-2" >> CVSROOT/modules
	  echo "2d1mod -d dir2d1/sub2d1 mod1" >> CVSROOT/modules
	  echo "2d1mod-2 -d dir2d1-2/sub2d1-2 mod1-2" >> CVSROOT/modules
	  echo "2d2mod -d dir2d2/sub2d2 mod2/sub2" >> CVSROOT/modules
	  echo "2d2mod-2 -d dir2d2-2/sub2d2-2 mod2-2/sub2-2" >> CVSROOT/modules
	  dotest cvsadm-1e "${testcvs} ci -m add-modules" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining CVSROOT
Checking in CVSROOT/modules;
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  rm -rf CVS CVSROOT;

	  # Create the various modules
	  mkdir ${CVSROOT_DIRNAME}/mod1
	  mkdir ${CVSROOT_DIRNAME}/mod1-2
	  mkdir ${CVSROOT_DIRNAME}/mod2
	  mkdir ${CVSROOT_DIRNAME}/mod2/sub2
	  mkdir ${CVSROOT_DIRNAME}/mod2-2
	  mkdir ${CVSROOT_DIRNAME}/mod2-2/sub2-2
	  dotest cvsadm-2 "${testcvs} co mod1 mod1-2 mod2 mod2-2" \
"${PROG} [a-z]*: Updating mod1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod2
${PROG} [a-z]*: Updating mod2/sub2
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/sub2-2"

	  # Populate the directories for the halibut
	  echo "file1" > mod1/file1
	  echo "file1-2" > mod1-2/file1-2
	  echo "file2" > mod2/sub2/file2
	  echo "file2-2" > mod2-2/sub2-2/file2-2
	  dotest cvsadm-2a "${testcvs} add mod1/file1 mod1-2/file1-2 mod2/sub2/file2 mod2-2/sub2-2/file2-2" \
"${PROG} [a-z]*: scheduling file .mod1/file1. for addition
${PROG} [a-z]*: scheduling file .mod1-2/file1-2. for addition
${PROG} [a-z]*: scheduling file .mod2/sub2/file2. for addition
${PROG} [a-z]*: scheduling file .mod2-2/sub2-2/file2-2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"

	  dotest cvsadm-2b "${testcvs} ci -m yup mod1 mod1-2 mod2 mod2-2" \
"${PROG} [a-z]*: Examining mod1
${PROG} [a-z]*: Examining mod1-2
${PROG} [a-z]*: Examining mod2
${PROG} [a-z]*: Examining mod2/sub2
${PROG} [a-z]*: Examining mod2-2
${PROG} [a-z]*: Examining mod2-2/sub2-2
RCS file: ${CVSROOT_DIRNAME}/mod1/file1,v
done
Checking in mod1/file1;
${CVSROOT_DIRNAME}/mod1/file1,v  <--  file1
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod1-2/file1-2,v
done
Checking in mod1-2/file1-2;
${CVSROOT_DIRNAME}/mod1-2/file1-2,v  <--  file1-2
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod2/sub2/file2,v
done
Checking in mod2/sub2/file2;
${CVSROOT_DIRNAME}/mod2/sub2/file2,v  <--  file2
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod2-2/sub2-2/file2-2,v
done
Checking in mod2-2/sub2-2/file2-2;
${CVSROOT_DIRNAME}/mod2-2/sub2-2/file2-2,v  <--  file2-2
initial revision: 1.1
done"
	  # Finished creating the modules -- clean up.
	  rm -rf CVS mod1 mod1-2 mod2 mod2-2
	  # Done.

	  ##################################################
	  ## Start the dizzying array of possibilities.
	  ## Begin with each module type separately.
	  ##################################################
	  
	  # Pattern -- after each checkout, first check the top-level
	  # CVS directory.  Then, check the directories in numerical
	  # order.

	  dotest cvsadm-3 "${testcvs} co 1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1"
	  dotest cvsadm-3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-3d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod

	  dotest cvsadm-4 "${testcvs} co 2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  dotest cvsadm-4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-4d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod

	  dotest cvsadm-5 "${testcvs} co 1d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  dotest cvsadm-5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-5d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1

	  dotest cvsadm-6 "${testcvs} co 1d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  dotest cvsadm-6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-6d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2

	  dotest cvsadm-7 "${testcvs} co 2d1mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  dotest cvsadm-7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-7d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-7f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir2d1

	  dotest cvsadm-8 "${testcvs} co 2d2mod" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  dotest cvsadm-8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-8d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-8f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d2

	  ##################################################
	  ## You are in a shell script of twisted little
	  ## module combination statements, all alike.
	  ##################################################

	  ### 1mod
	  
	  dotest cvsadm-9 "${testcvs} co 1mod 1mod-2" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating 1mod-2
U 1mod-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-9b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-9d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1mod copy
	  dotest cvsadm-9f "cat 1mod-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS 1mod 1mod-2

	  # 1mod 2mod redmod bluemod
	  dotest cvsadm-10 "${testcvs} co 1mod 2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  # the usual for the top level
	  dotest cvsadm-10b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-10d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2dmod
	  dotest cvsadm-10f "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod 2mod

	  dotest cvsadm-11 "${testcvs} co 1mod 1d1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  # the usual for the top level
	  dotest cvsadm-11b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-11d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod
	  dotest cvsadm-11f "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod dir1d1

	  dotest cvsadm-12 "${testcvs} co 1mod 1d2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-12b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-12d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-12f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod dir1d2

	  dotest cvsadm-13 "${testcvs} co 1mod 2d1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-13b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-13d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-13f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-13h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod dir2d1

	  dotest cvsadm-14 "${testcvs} co 1mod 2d2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-14b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-14d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-14f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-14h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod dir2d2


	  ### 2mod
	  
	  dotest cvsadm-15 "${testcvs} co 2mod 2mod-2" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating 2mod-2
U 2mod-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-15b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-15d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2mod copy
	  dotest cvsadm-15f "cat 2mod-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS 2mod 2mod-2


	  dotest cvsadm-16 "${testcvs} co 2mod 1d1mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  # the usual for the top level
	  dotest cvsadm-16b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-16d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d1mod
	  dotest cvsadm-16f "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 2mod dir1d1

	  dotest cvsadm-17 "${testcvs} co 2mod 1d2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-17b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-17d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod
	  dotest cvsadm-17f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod dir1d2

	  dotest cvsadm-18 "${testcvs} co 2mod 2d1mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-18b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-18d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-18f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-18h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 2mod dir2d1

	  dotest cvsadm-19 "${testcvs} co 2mod 2d2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-19b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-19d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-19f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-19h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod dir2d2


	  ### 1d1mod

	  dotest cvsadm-20 "${testcvs} co 1d1mod 1d1mod-2" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir1d1-2
U dir1d1-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-20b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-20d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod copy
	  dotest cvsadm-20f "cat dir1d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir1d1 dir1d1-2

	  dotest cvsadm-21 "${testcvs} co 1d1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-21b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-21d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-21f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d1 dir1d2

	  dotest cvsadm-22 "${testcvs} co 1d1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-22b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-22d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-22f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-22h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1 dir2d1

	  dotest cvsadm-23 "${testcvs} co 1d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-23b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-23d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-23f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-23h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d1 dir2d2


	  ### 1d2mod

	  dotest cvsadm-24 "${testcvs} co 1d2mod 1d2mod-2" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir1d2-2
U dir1d2-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-24b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-24d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod copy
	  dotest cvsadm-24f "cat dir1d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir1d2 dir1d2-2

	  dotest cvsadm-25 "${testcvs} co 1d2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-25b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-25d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-25f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-25h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d2 dir2d1

	  dotest cvsadm-26 "${testcvs} co 1d2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-26b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-26d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-26f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-26h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2 dir2d2


	  # 2d1mod

	  dotest cvsadm-27 "${testcvs} co 2d1mod 2d1mod-2" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir2d1-2/sub2d1-2
U dir2d1-2/sub2d1-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-27b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-27d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-27f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-27h "cat dir2d1-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-27j "cat dir2d1-2/sub2d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir2d1 dir2d1-2

	  dotest cvsadm-28 "${testcvs} co 2d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-28b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-28d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-28f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-28h "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-28j "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d1 dir2d2

	  
	  # 2d2mod

	  dotest cvsadm-29 "${testcvs} co 2d2mod 2d2mod-2" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2
${PROG} [a-z]*: Updating dir2d2-2/sub2d2-2
U dir2d2-2/sub2d2-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-29b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d2mod
	  dotest cvsadm-29d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-29f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-29h "cat dir2d2-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-29j "cat dir2d2-2/sub2d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir2d2 dir2d2-2

	  ##################################################
	  ## And now, all of that again using the "-d" flag
	  ## on the command line.
	  ##################################################

	  dotest cvsadm-1d3 "${testcvs} co -d dir 1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d3d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d4 "${testcvs} co -d dir 2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d4d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d5 "${testcvs} co -d dir 1d1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d5d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d6 "${testcvs} co -d dir 1d2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d6d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d7 "${testcvs} co -d dir 2d1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d7d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d8 "${testcvs} co -d dir 2d2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d8d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  ##################################################
	  ## Los Combonaciones
	  ##################################################

	  ### 1mod

	  dotest cvsadm-1d9 "${testcvs} co -d dir 1mod 1mod-2" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/1mod-2
U dir/1mod-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-1d9b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d9d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d9f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1mod copy
	  dotest cvsadm-1d9h "cat dir/1mod-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir

	  # 1mod 2mod redmod bluemod
	  dotest cvsadm-1d10 "${testcvs} co -d dir 1mod 2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2"
	  dotest cvsadm-1d10b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d10d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d10f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2dmod
	  dotest cvsadm-1d10h "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d11 "${testcvs} co -d dir 1mod 1d1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-1d11b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d11d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d11f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod
	  dotest cvsadm-1d11h "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d12 "${testcvs} co -d dir 1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d12b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d12d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d12f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-1d12h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d13 "${testcvs} co -d dir 1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d13b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d13d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d13f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d13h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d13j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d14 "${testcvs} co -d dir 1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d14b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d14d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d14f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d14h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d14j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir


	  ### 2mod

	  dotest cvsadm-1d15 "${testcvs} co -d dir 2mod 2mod-2" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/2mod-2
U dir/2mod-2/file2-2"
	  dotest cvsadm-1d15b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d15d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d15f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2mod copy
	  dotest cvsadm-1d15h "cat dir/2mod-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir

	  dotest cvsadm-1d16 "${testcvs} co -d dir 2mod 1d1mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-1d16b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d16d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d16f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d1mod
	  dotest cvsadm-1d16h "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d17 "${testcvs} co -d dir 2mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d17b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d17d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d17f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod
	  dotest cvsadm-1d17h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d18 "${testcvs} co -d dir 2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d18b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d18d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d18f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-1d18h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d18j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d19 "${testcvs} co -d dir 2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d19b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d19d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d19f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d19h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d19j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir


	  ### 1d1mod

	  dotest cvsadm-1d20 "${testcvs} co -d dir 1d1mod 1d1mod-2" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir1d1-2
U dir/dir1d1-2/file1-2"
	  dotest cvsadm-1d20b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d20d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d20f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod copy
	  dotest cvsadm-1d20h "cat dir/dir1d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir

	  dotest cvsadm-1d21 "${testcvs} co -d dir 1d1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d21b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d21d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d21f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-1d21h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-1d22 "${testcvs} co -d dir 1d1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d22b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d22d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d22f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d22h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d22j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d23 "${testcvs} co -d dir 1d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d23b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d23d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d23f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d23h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d23j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir


	  ### 1d2mod

	  dotest cvsadm-1d24 "${testcvs} co -d dir 1d2mod 1d2mod-2" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir1d2-2
U dir/dir1d2-2/file2-2"
	  dotest cvsadm-1d24b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d24d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d24f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod copy
	  dotest cvsadm-1d24h "cat dir/dir1d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir

	  dotest cvsadm-1d25 "${testcvs} co -d dir 1d2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d25b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d25d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d25f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-1d25h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d25j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-1d26 "${testcvs} co -d dir 1d2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d26b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d26d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d26f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d26h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d26j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir


	  # 2d1mod

	  dotest cvsadm-1d27 "${testcvs} co -d dir 2d1mod 2d1mod-2" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir/dir2d1-2/sub2d1-2
U dir/dir2d1-2/sub2d1-2/file1-2"
	  dotest cvsadm-1d27b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d27d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-1d27f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d27h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d27j "cat dir/dir2d1-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d27l "cat dir/dir2d1-2/sub2d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir

	  dotest cvsadm-1d28 "${testcvs} co -d dir 2d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d28b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d28d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-1d28f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d28h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d28j "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d28l "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  
	  # 2d2mod

	  dotest cvsadm-1d29 "${testcvs} co -d dir 2d2mod 2d2mod-2" \
"${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2
${PROG} [a-z]*: Updating dir/dir2d2-2/sub2d2-2
U dir/dir2d2-2/sub2d2-2/file2-2"
	  dotest cvsadm-1d29b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d29d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d2mod
	  dotest cvsadm-1d29f "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d29h "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d29j "cat dir/dir2d2-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d29l "cat dir/dir2d2-2/sub2d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir

	  ##################################################
	  ## And now, some of that again using the "-d" flag
	  ## on the command line, but use a longer path.
	  ##################################################

	  dotest cvsadm-2d3 "${testcvs} co -d dir/dir2 1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d3d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d3f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-2d4 "${testcvs} co -d dir/dir2 2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d4d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d4f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-2d5 "${testcvs} co -d dir/dir2 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d5d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d5f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-2d6 "${testcvs} co -d dir/dir2 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d6d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d6f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-2d7 "${testcvs} co -d dir/dir2 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d7d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d7f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-2d8 "${testcvs} co -d dir/dir2 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d8d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d8f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  ##################################################
	  ## And now, a few of those tests revisited to
	  ## test the behavior of the -N flag.
	  ##################################################

	  dotest cvsadm-N3 "${testcvs} co -N 1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1"
	  dotest cvsadm-N3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N3d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod

	  dotest cvsadm-N4 "${testcvs} co -N 2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  dotest cvsadm-N4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N4d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod

	  dotest cvsadm-N5 "${testcvs} co -N 1d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  dotest cvsadm-N5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N5d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1

	  dotest cvsadm-N6 "${testcvs} co -N 1d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  dotest cvsadm-N6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N6d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2

	  dotest cvsadm-N7 "${testcvs} co -N 2d1mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  dotest cvsadm-N7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N7d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N7f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir2d1

	  dotest cvsadm-N8 "${testcvs} co -N 2d2mod" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  dotest cvsadm-N8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N8d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N8f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d2

	  ## the ones in one-deep directories

	  dotest cvsadm-N1d3 "${testcvs} co -N -d dir 1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1"
	  dotest cvsadm-N1d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d3d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d3f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N1d4 "${testcvs} co -N -d dir 2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2"
	  dotest cvsadm-N1d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d4d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d4f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-N1d5 "${testcvs} co -N -d dir 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-N1d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d5d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d5d "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N1d6 "${testcvs} co -N -d dir 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-N1d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d6d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d6f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-N1d7 "${testcvs} co -N -d dir 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-N1d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d7d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d7f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N1d7h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N1d8 "${testcvs} co -N -d dir 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-N1d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d8d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d8d "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N1d8d "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  ## the ones in two-deep directories

	  dotest cvsadm-N2d3 "${testcvs} co -N -d dir/dir2 1mod" \
"${PROG} [a-z]*: Updating dir/dir2/1mod
U dir/dir2/1mod/file1"
	  dotest cvsadm-N2d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d3d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d3f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d3h "cat dir/dir2/1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N2d4 "${testcvs} co -N -d dir/dir2 2mod" \
"${PROG} [a-z]*: Updating dir/dir2/2mod
U dir/dir2/2mod/file2"
	  dotest cvsadm-N2d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d4d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d4f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d4h "cat dir/dir2/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-N2d5 "${testcvs} co -N -d dir/dir2 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir1d1
U dir/dir2/dir1d1/file1"
	  dotest cvsadm-N2d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d5d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d5f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d5h "cat dir/dir2/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N2d6 "${testcvs} co -N -d dir/dir2 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir1d2
U dir/dir2/dir1d2/file2"
	  dotest cvsadm-N2d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d6d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d6f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d6h "cat dir/dir2/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  dotest cvsadm-N2d7 "${testcvs} co -N -d dir/dir2 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir2d1/sub2d1
U dir/dir2/dir2d1/sub2d1/file1"
	  dotest cvsadm-N2d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d7d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d7f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d7f "cat dir/dir2/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d7h "cat dir/dir2/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir

	  dotest cvsadm-N2d8 "${testcvs} co -N -d dir/dir2 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir2d2/sub2d2
U dir/dir2/dir2d2/sub2d2/file2"
	  dotest cvsadm-N2d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d8d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d8f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d8h "cat dir/dir2/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d8j "cat dir/dir2/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir

	  ##################################################
	  ## That's enough of that, thank you very much.
	  ##################################################

	  # remove our junk
	  cd ..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/1mod
	  rm -rf ${CVSROOT_DIRNAME}/1mod-2
	  rm -rf ${CVSROOT_DIRNAME}/2mod
	  rm -rf ${CVSROOT_DIRNAME}/2mod-2
	  ;;

        diffmerge1)
	  # Make sure CVS can merge correctly in circumstances where it
	  # used to mess up (due to a bug which existed in diffutils 2.7
	  # and 2.6, but not 2.5, and which has been fixed in CVS's diff
	  # lib by Paul Eggert, bless his bitty heart).

	  # This first test involves two working copies, "mine" and
	  # "yours", checked out from the same repository at the same
	  # time.  In yours, you remove some text from the end of the
	  # file and check it in; meanwhile, "me" has commented out some
	  # lines earlier in the file, and I go to check it in right
	  # after you checked yours in.  CVS naturally tells me the file
	  # is not up-to-date, so I run cvs update, but it updates
	  # incorrectly, leaving in the lines of text you just deleted.
	  # Bad!  I'm in too much of a hurry to actually look at the
	  # file, so I check it in and go home, and so your changes have
	  # been lost.  Later you discover this, and you suspect me of
	  # deliberately sabotaging your work, so you let all the air
	  # out of my tires.  Only after a series of expensive lawsuits
	  # and countersuits do we discover it this was all CVS's
	  # fault.
	  #
	  # Luckily, this problem has been fixed now, as our test will
	  # handily confirm, no doubt:

	  # First make a repository containing the original text:

	  # We should be here anyway, but cd to it just in case:
	  cd ${TESTDIR}

	  mkdir diffmerge1
	  cd diffmerge1

	  # The text of the file is inlined here because `echo' loses
	  # newlines, and I don't know how portable the -e flag is.
	  # 
	  # This is the file we both start out with:
	  echo "// Button.java

package random.application;

import random.util.star;

public class Button
{
  /star Instantiates a Button with origin (0, 0) and zero width and height.
   star You must call an initializer method to properly initialize the Button.
   star/
  public Button ()
  {
    super ();

    _titleColor = Color.black;
    _disabledTitleColor = Color.gray;
    _titleFont = Font.defaultFont ();
  }

  /star Convenience constructor for instantiating a Button with
   star bounds x, y, width, and height.  Equivalent to
   star     foo = new Button ();
   star     foo.init (x, y, width, height);
   star/
  public Button (int x, int y, int width, int height)
  {
    this ();
    init (x, y, width, height);
  }
}" > the_file

	  dotest diffmerge1_import \
	    "${testcvs} import -m import diffmerge1 tag1 tag2" \
	    "${DOTSTAR}No conflicts created by this import"
	  cd ..
	  rm -rf diffmerge1

	  # Check out two working copies, one for "you" and one for "me"
	  ${testcvs} checkout diffmerge1 >/dev/null 2>&1
	  mv diffmerge1 diffmerge1_yours
	  ${testcvs} checkout diffmerge1 >/dev/null 2>&1
	  mv diffmerge1 diffmerge1_mine

	  # In your working copy, you'll remove the Button() method, and
	  # then check in your change before I check in mine:
	  cd diffmerge1_yours
	  echo "// Button.java

package random.application;

import random.util.star;

public class Button
{
  /star Instantiates a Button with origin (0, 0) and zero width and height.
   star You must call an initializer method to properly initialize the Button.
   star/
  public Button ()
  {
    super ();

    _titleColor = Color.black;
    _disabledTitleColor = Color.gray;
    _titleFont = Font.defaultFont ();
  }
}" > the_file
	  dotest diffmerge1_yours \
	    "${testcvs} ci -m yours" \
	    "${DOTSTAR}hecking in ${DOTSTAR}"

	  # My working copy still has the Button() method, but I
	  # comment out some code at the top of the class.  Then I
	  # update, after both my modifications and your checkin:
	  cd ../diffmerge1_mine
	  echo "// Button.java

package random.application;

import random.util.star;

public class Button
{
  /star Instantiates a Button with origin (0, 0) and zero width and height.
   star You must call an initializer method to properly initialize the Button.
   star/
  public Button ()
  {
    super ();

    // _titleColor = Color.black;
    // _disabledTitleColor = Color.gray;
    // _titleFont = Font.defaultFont ();
  }

  /star Convenience constructor for instantiating a Button with
   star bounds x, y, width, and height.  Equivalent to
   star     foo = new Button ();
   star     foo.init (x, y, width, height);
   star/
  public Button (int x, int y, int width, int height)
  {
    this ();
    init (x, y, width, height);
  }
}" > the_file
	  dotest diffmerge1_mine \
	    "${testcvs} update" \
	    "${DOTSTAR}erging${DOTSTAR}"

	  # So if your changes didn't make it into my working copy, or
	  # in any case if the file does not look like the final text as
	  # quoted below, then the test flunks:
	  echo "// Button.java

package random.application;

import random.util.star;

public class Button
{
  /star Instantiates a Button with origin (0, 0) and zero width and height.
   star You must call an initializer method to properly initialize the Button.
   star/
  public Button ()
  {
    super ();

    // _titleColor = Color.black;
    // _disabledTitleColor = Color.gray;
    // _titleFont = Font.defaultFont ();
  }
}" > comp_me
	  dotest diffmerge1_cmp "cmp the_file comp_me" ''

	  # Clean up after ourselves:
	  cd ..
	  rm -rf diffmerge1_yours diffmerge1_mine ${CVSROOT_DIRNAME}/diffmerge1

	  ;;

        diffmerge2)

	  # FIXME: This test should be rewritten to be much more concise.
	  # It currently weighs in at something like 600 lines, but the
	  # same thing could probably be tested in more like 50-100 lines.
	  mkdir diffmerge2

	  # This tests for another diffmerge bug reported by Martin
	  # Tomes; actually, his bug was probably caused by an initial
	  # fix for the bug in test diffmerge1, and likely wasn't ever
	  # a problem in CVS as long as one was using a normal
	  # distribution of diff or a version of CVS that has the diff
	  # lib in it. 
	  #
	  # Nevertheless, once burned twice cautious, so we test for his
	  # bug here.
	  #
	  # Here is his report, more or less verbatim:
	  # ------------------------------------------
	  #
	  # Put the attached file (sgrid.h,v) into your repository
	  # somewhere, check out the module and do this:
	  #
	  # cvs update -j Review_Phase_2_Enhancements sgrid.h
	  # cvs diff -r Review_V1p3 sgrid.h
	  #
	  # As there have been no changes made on the trunk there
	  # should be no differences, however this is output:
	  #
	  # % cvs diff -r Review_V1p3 sgrid.h
	  # Index: sgrid.h
	  # ===================================================================
	  # RCS file: /usr/local/repository/play/fred/sgrid.h,v
	  # retrieving revision 1.1.2.1
	  # diff -r1.1.2.1 sgrid.h
	  # 178a179,184
	  # > /*--------------------------------------------------------------
	  # > INLINE FUNCTION    :    HORIZONTALLINES
	  # > NOTES              :    Description at the end of the file
	  # > ----------------------------------------------------------------*/
	  # >         uint16 horizontalLines( void );
	  # >
	  #
	  # I did a cvs diff -c -r 1.1 -r 1.1.2.1 sgrid.h and patched those
	  # differences to sgrid.h version 1.1 and got the correct result
	  # so it looks like the built in patch is faulty.
	  # -------------------------------------------------------------------
	  #
	  # This is the RCS file, sgrid.h,v, that he sent:

	  echo "head	1.1;
access;
symbols
	Review_V1p3:1.1.2.1
	Review_V1p3C:1.1.2.1
	Review_1p3A:1.1.2.1
	Review_V1p3A:1.1.2.1
	Review_Phase_2_Enhancements:1.1.0.2
	Review_V1p2:1.1
	Review_V1p2B:1.1
	Review_V1p2A:1.1
	Review_V1p1:1.1
	Review_1p1:1.1;
locks; strict;
comment	@@ * @@;


1.1
date	97.04.02.11.20.05;	author colinl;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	97.06.09.10.00.07;	author colinl;	state Exp;
branches;
next	;


desc
@@@@


1.1
log
@@Project:     DEV1175
DCN:
Tested By:   Colin Law
Reviewed By:
Reason for Change: Initial Revision of all files

Design Change Details:

Implications:
@@
text
@@/* \$""Header:   L:/gpanels/dis/sgrid.h_v   1.1.1.0   24 Jan 1996 14:59:20   PAULT  \$ */
/*
 * \$""Log:   L:/gpanels/dis/sgrid.h_v  \$
 * 
 *    Rev 1.1.1.0   24 Jan 1996 14:59:20   PAULT
 * Branched
 * 
 *    Rev 1.1   24 Jan 1996 12:09:52   PAULT
 * Consolidated 4100 code merged to trunk
 * 
 *    Rev 1.0.2.0   01 Jun 1995 14:18:58   DAVEH
 * Branched
 * 
 *    Rev 1.0   19 Apr 1995 16:32:48   COLINL
 * Initial revision.
*/
/*****************************************************************************
FILE        :   SGRID.H
VERSION     :   2.1
AUTHOR      :   Dave Hartley
SYSTEM      :   Borland C++
DESCRIPTION :   The declaration of the scrolling grid class
                  
*****************************************************************************/
#if !defined(__SGRID_H)
#define __SGRID_H

#if !defined(__SCROLL_H)
#include <scroll.h>
#endif

#if !defined(__GKI_H)
#include \"gki.h\"
#endif

#if defined PRINTING_SUPPORT
class Printer;
#endif

/*****************************************************************************
CLASS      :    ScrollingGrid   
DESCRIPTION:    This class inherits from a grid and a scrollable, and
                can therefore use all the PUBLIC services provided by these
                classes. A description of these can be found in
                GRID.H and SCROLL.H.
                A scrolling grid is a set of horizontal and vertical lines
                that scroll and continually update to provide a complete grid

*****************************************************************************/

class ScrollingGrid : public Scrollable
{
    public:
#if defined _WINDOWS
/*---------------------------------------------------------------------------
FUNCTION    :   CONSTRUCTOR
DESCRIPTION :   sets up the details of the grid, ready for painting
ARGUMENTS   :   name  : sgColour
                        - the colour of the grid
                        sgLineType
                        - the syle of line
                        sgHorizontalTotal
                        - the total number of horizontal grid lines
                        verticalSpacingMin
                        - the min distance between the vertical grid lines
                          on the scrolling axis
                        currentTimestamp
                        - timestamp value now
                        ticksPerSecond
                        - number of timestamp ticks per second
                        ticksPerPixel
                        - number of timestamp ticks per pixel required
                      
RETURN      :   None
NOTES       :   
---------------------------------------------------------------------------*/
        ScrollingGrid( GkiColour sgColour, GkiLineType sgLineType, 
            uint16 sgHorizontalTotal, 
            uint16 verticalSpacingMin, uint32 currentTimestamp, 
            uint16 ticksPerSecond, uint32 ticksPerPixel );
#else
/*---------------------------------------------------------------------------
FUNCTION    :   CONSTRUCTOR
DESCRIPTION :   sets up the details of the grid, ready for painting
ARGUMENTS   :   name  : sgColour
                        - the colour of the grid
                        sgLineType
                        - the syle of line
                        sgHorizontalTotal ( THE MAX NUMBER OF LINES IS 100 )
                        - the total number of horizontal grid lines
                        sgVerticalSpacing
                        - the distance between the vertical grid lines
                        on the scrolling axis
                      
RETURN      :   None
NOTES       :   If the caller does not get the total grid lines value, synced
                with the overall size of the viewport, the spacing between
                grid lines will not be consistent.

---------------------------------------------------------------------------*/
        ScrollingGrid( GkiColour sgColour, GkiLineType sgLineType
                     , uint16 sgHorizontalTotal, uint16 sgVerticalSpacing );
#endif
/*---------------------------------------------------------------------------
FUNCTION    :   DESTRUCTOR
DESCRIPTION :   tidies it all up
ARGUMENTS   :   name  :      
                      
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        ~ScrollingGrid( void );

/*---------------------------------------------------------------------------
FUNCTION    :   ATTACH
DESCRIPTION :   This service overloads the base class service, as it does
                additional work at the time of attachment.

ARGUMENTS   :   name  : tDrawingArea
                        - the scrolled viewport to attach this trend to
                      
RETURN      :   None
NOTES       :
---------------------------------------------------------------------------*/
        void attach( SViewport *tDrawingArea );

#if defined _WINDOWS
/*---------------------------------------------------------------------------
FUNCTION    :   calculateVerticalSpacing
DESCRIPTION :   determines optimum spacing along time axis
ARGUMENTS   :   
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void calculateVerticalSpacing();

/*---------------------------------------------------------------------------
FUNCTION    :   gridSpacingTicks
DESCRIPTION :   Provides the grid spacing in the time axis in ticks
ARGUMENTS   :   
RETURN      :   Number of ticks
NOTES       : 
---------------------------------------------------------------------------*/
        uint32 gridSpacingTicks();

#endif

/*---------------------------------------------------------------------------
INLINE FUNCTION    :    HORIZONTALLINES
NOTES              :    Description at the end of the file
---------------------------------------------------------------------------*/
        uint16 horizontalLines( void );

#if defined _WINDOWS
// In Windows the OnDraw() function replaces paint()
/*---------------------------------------------------------------------------
FUNCTION    :   ScrollingGrid OnDraw   
DESCRIPTION :   Paints the given area of the grid.
                Pure virtual
ARGUMENTS   :   pDC     pointer to the device context to use for display
                        Note that the device context operates in the coords
                        of the window owning the viewport
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        virtual void OnDraw( CDC *pDC );

#else   // not Windows            

/*---------------------------------------------------------------------------
FUNCTION    :   PAINT
DESCRIPTION :   This extends the standard grid paint method to paint the
                viewport relative to its current position. 
                
ARGUMENTS   :   name  :      
                      
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void paint( void );
#endif

/*---------------------------------------------------------------------------
FUNCTION    :   P A I N T   T E X T   M A R K E R S 
DESCRIPTION :   this service allow the text markers to be painted seperatley
                from the grid lines

ARGUMENTS   :   name : 
                                                                          
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void paintTextMarkers();

#if defined PRINTING_SUPPORT
/*---------------------------------------------------------------------------
FUNCTION    :   P R I N T 
DESCRIPTION :   This print service prints a grid marker ( being either a
                timestamp or a date, IF there is one at the plot position
                given

ARGUMENTS   :   name :
                        displayPosition
                        - Where in the log to look to see if there is an
                          entry to print

                        - printerPtr
                          the printer to print to
                                                                          
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void print( uint16 currentPrintPos, Printer *printerPtr );
#endif

/*---------------------------------------------------------------------------
FUNCTION    :   S E T  D R I V E  D I R E C T I O N
DESCRIPTION :   Sets direction for update and scrolling forwards or backwards
ARGUMENTS   :   direction  - required direction
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void setDriveDirection( ScrollDirection direction );

/*---------------------------------------------------------------------------
FUNCTION    :   S E T U P 
DESCRIPTION :   service that will setup the grid prior to a paint

ARGUMENTS   :   name :
                        - newTimestamp
                            

                        - newTimeBase
                        the number of ticks that represent a plot point on
                        the trendgraph. 
                                                                          
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void setup( uint32 newTimestamp, uint32 newTimeBase );

#if defined PRINTING_SUPPORT
/*---------------------------------------------------------------------------
FUNCTION    :   S E T U P   F O R   P R I N T   
DESCRIPTION :   This service iis to be called prior to printing. It allows
                the grid to prepare its markers ready for the print
                commands

ARGUMENTS   :   name : 
                                                                          
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void setupForPrint();
#endif

/*---------------------------------------------------------------------------
FUNCTION    :   UPDATE
DESCRIPTION :   When this service is called it will calculate what needs to
                be painted and fill in the display again.

ARGUMENTS   :   name  :     timeStamp
                            - the reference time of this update.
                      
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void update( uint32 timeStamp );

/*---------------------------------------------------------------------------
FUNCTION    :   U P D A T E   B U F F E R
DESCRIPTION :   When a display update is not required, use this method. It
                updates the internal data ready for a call to paint that
                will then show the grid in the right position

ARGUMENTS   :   name  :      
                      
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void updateBuffer( void );

    private:

/*---------------------------------------------------------------------------
FUNCTION    :   M A K E   G R I D   M A R K E R 
DESCRIPTION :   service that perpares a string for display. The string will
                either be a short date, or short time. this is determined
                by the current setting of the dateMarker flag

ARGUMENTS   :   name :  timestampVal
                        - the value to convert
                        
                        storePtr
                        - the place to put the string

RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void makeGridMarker( uint32 timestampVal, char *storePtr );
            
/*---------------------------------------------------------------------------
FUNCTION    :   P A I N T   G R I D   M A R K E R 
DESCRIPTION :   given a position will put the string on the display

ARGUMENTS   :   name :
                        yPos
                        - were it goes on the Y-axis

                        gridMarkerPtr
                        - what it is
                                                                          
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
        void paintGridMarker( uint16 yPos, char *gridMarkerPtr );

#if defined _WINDOWS
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTHORIZONTALLINES
DESCRIPTION :   responsible for painting the grids horizontal lines 
ARGUMENTS   :   pRectToDraw     pointer to rectangle that needs refreshing.
                                in viewport coords
                pDC             pointer to device context to use
                      
RETURN      : None
NOTES       :
---------------------------------------------------------------------------*/
        void paintHorizontalLines(RectCoords* pRectToDraw, CDC* pDC );
#else
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTHORIZONTALLINES
DESCRIPTION :   responsible for painting the grids horizontal lines 
ARGUMENTS   : name: xStart
                    - the starting X co-ordinate for the horizontal line
                    xEnd
                    - the ending X co-ordinate for the horizontal line
                      
RETURN      : None
NOTES       : Remember lines are drawn from origin. The origin in a
              horizontal viewport will be the top.    
---------------------------------------------------------------------------*/
        void paintHorizontalLines( uint16 xStart, uint16 xEnd );
#endif

#if defined _WINDOWS
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTVERTICALLINES
DESCRIPTION :   responsible for painting the grids vertical lines 
ARGUMENTS   :   pRectToDraw     pointer to rectangle that needs refreshing.
                                in viewport coords
                offset          offset from rhs that rightmost line would be 
                                drawn if rectangle included whole viewport
                pDC             pointer to device context to use
RETURN      : None
NOTES       : 
---------------------------------------------------------------------------*/
        void paintVerticalLines( RectCoords* pRectToDraw, uint16 offset,
            CDC* pDC );
#else
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTVERTICALLINES
DESCRIPTION :   responsible for painting the grids vertical lines 
ARGUMENTS   : name  :   yStart
                        - the starting Y co-ordinate for the vertical line
                        yEnd
                        - the ending Y co-ordinate for the vertical line
                        offset
                        - a starting point offset that determines at what X
                        position the first line will be drawn

                      
RETURN      : None
NOTES       : 
---------------------------------------------------------------------------*/
        void paintVerticalLines( uint16 yStart, uint16 yEnd, uint16 offset );
#endif

#if defined _WINDOWS
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTVERTICALLINE
DESCRIPTION :   paints one line at the position specified, and length
ARGUMENTS   :   name  : yStart
                        - the starting point on the y axis for the line
                        yEnd
                        - the end point on the y axis for the line
                        xPosition
                        - The horizontal offset from the start of the viewport
                pDC             pointer to device context to use
                      
RETURN      :   None
NOTES       :   There is not an equivalent horizontal method as yet. This
                is a seperate method because the service is useful to a
                derivation of this class
---------------------------------------------------------------------------*/
        void paintVerticalLine( uint16 yStart, uint16 yEnd
                              , uint16 xPosition, CDC *pDC );
#else
/*---------------------------------------------------------------------------
FUNCTION    :   PAINTVERTICALLINE
DESCRIPTION :   paints one line at the position specified, and length
ARGUMENTS   :   name  : yStart
                        - the starting point on the y axis for the line
                        yEnd
                        - the end point on the y axis for the line
                        xPosition
                        - The horizontal offset from the start of the viewport
                      
RETURN      :   None
NOTES       :   There is not an equivalent horizontal method as yet. This
                is a seperate method because the service is useful to a
                derivation of this class
---------------------------------------------------------------------------*/
        void paintVerticalLine( uint16 yStart, uint16 yEnd
                              , uint16 xPosition );
#endif

/*---------------------------------------------------------------------------
INLINE FUNCTION    :    VERTICALSPACING
NOTES              :    Description at the end of the file
---------------------------------------------------------------------------*/
        uint16 verticalSpacing( void );


        // Position in viewport that we are now writing to if going forwards
        // Note that if this is greater than viewport length then we have
        // just scrolled and value must be adjusted before use.
        sint16 forwardsOutputPosition;
        
        // Position in viewport that we are now writing to if going backwards
        // Note that if this is less than zero then we have
        // just scrolled and value must be adjusted before use.
        sint16 backwardsOutputPosition;

        // position in grid cycle of forwards output position.
        // if zero then it is time to output a grid line
        sint16 forwardsIntervalCount;

        // position in grid cycle of forwards output position.
        // if zero then it is time to output a grid line
        sint16 backwardsIntervalCount;
        
        uint32  lastUpdateTimestamp;
        uint32  timeBase;       // ticks per pixel
        uint16  currentOutputPosition;
        uint16  gridTimestampSpacing;
        uint16  intervalCount;
        uint16  horizontalTotal;
        uint16  vSpacing;
#if defined PRINTING_SUPPORT
        uint16  numberOfGridMarkersPrinted;
#endif
        bool    firstTime;       // indicates first time through
        bool    dateMarker;

        GkiLineType lineType;
        GkiColour   gridColour;

    #if defined _WINDOWS
        uint16 ticksPerSec;     // number of time ticks per second
        uint16 vSpacingMin;     // minimum pixels per division along time axis 
        CPen *pPen;             // the pen to use for drawing in windows
    #endif

};


/*****************************************************************************
                        I N L I N E   F U N C T I O N S   
*****************************************************************************/

/*---------------------------------------------------------------------------
FUNCTION    :   HORIZONTALLINES
DESCRIPTION :   supplies the number of horizontal lines in the grid
ARGUMENTS   :   name  :      
                      
RETURN      :   
NOTES       : 
---------------------------------------------------------------------------*/
inline uint16 ScrollingGrid::horizontalLines( void )
{
    return( horizontalTotal );
}
/*---------------------------------------------------------------------------
FUNCTION    :   VERTICALSPACING
DESCRIPTION :   returns the distance between adjacent vertical lines
ARGUMENTS   :   name  :      
                      
RETURN      :   None
NOTES       : 
---------------------------------------------------------------------------*/
inline uint16 ScrollingGrid::verticalSpacing( void )
{
    return( vSpacing );
}

#endif
@@


1.1.2.1
log
@@DEV1194:DS4    Provision of major and minor grid lines
@@
text
@@d1 1
a1 1
/* \$""Header: /usr/local/repository/cmnsrc/review/src/sgrid.h,v 1.1 1997/04/02 11:20:05 colinl Exp \$ */
d3 1
a3 12
 * \$""Log: sgrid.h,v \$
 * Revision 1.1  1997/04/02 11:20:05  colinl
 * Project:     DEV1175
 * DCN:
 * Tested By:   Colin Law
 * Reviewed By:
 * Reason for Change: Initial Revision of all files
 *
 * Design Change Details:
 *
 * Implications:
 *
d58 6
a63 5
ARGUMENTS   :   name  : majorColour         colour for major grid lines
                        minorColour         colour for minor grid lines
                        sgLineType          line type for minor grid lines
                        yMajorGridLines     number of major y lines on grid
                        yMinorGridLines     number of major y lines on grid
d77 2
a78 3
        ScrollingGrid( GkiColour majorColour, GkiColour minorColour, 
            GkiLineType sgLineType, 
            uint16 yMajorGridLines, uint16 yMinorGridLines,
a137 17
FUNCTION    :   DrawHorizontalGridLines

DESCRIPTION :   Draws major or minor grid lines
ARGUMENTS   :   pDC         device context
                pPen        pen to use
                numLines    total lines required
                yLow, yHigh, xLow, xHigh   rectangle to draw in
                yMax        max y value
RETURN      :   None
NOTES       :   
---------------------------------------------------------------------------*/
        void DrawHorizontalGridLines( CDC* pDC, CPen* pPen, 
            uint16 numLines,
            uint16 yLow, uint16 yHigh, uint16 xLow, uint16 xHigh, 
            uint16 yMax );

/*---------------------------------------------------------------------------
d148 6
d448 1
a448 2
        uint16  m_yMajorGridLines;
        uint16  m_yMinorGridLines;
d456 2
a457 3
        GkiLineType lineType;    // line type for minor grid lines
        GkiColour   m_majorColour;
        GkiColour   m_minorColour;
d462 1
a462 2
        CPen *pMajorPen;        // pen to use for drawing major grid lines
        CPen *pMinorPen;        // pen to use for drawing minor grid lines
d472 12
@@" > diffmerge2/sgrid.h,v

	  # We have to put the RCS file in the repository by hand for
	  # this test:
	  mkdir ${CVSROOT_DIRNAME}/diffmerge2
	  cp diffmerge2/sgrid.h,v ${CVSROOT_DIRNAME}/diffmerge2/sgrid.h,v
	  rm -rf diffmerge2
	  dotest diffmerge2_co \
	    "${testcvs} co diffmerge2" "${DOTSTAR}U ${DOTSTAR}"
	  cd diffmerge2
	  dotest diffmerge2_update \
	    "${testcvs} update -j Review_Phase_2_Enhancements sgrid.h" \
	    "${DOTSTAR}erging ${DOTSTAR}"
	  # This is the one that counts -- there should be no output:
	  dotest diffmerge2_diff \
	    "${testcvs} diff -r Review_V1p3 sgrid.h" ''

d6894 1
d6912 1
a6912 2
# * Test the contents of adm files other than Root and Repository.
#   Entries seems the next most important thing.
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a550 1
	# Basic/miscellaneous functionality
d552 1
a552 2
	# Branching, tagging, removing, adding, multiple directories
	tests="${tests} rdiff death death2 branches branches2"
a554 1
	# Checking out various places (modules, checkout -d, &c)
a555 2
	tests="${tests} cvsadm abspath toplevel"
	# Log messages, error messages.
a556 1
	# Watches, binary files, history browsing, &c.
a560 1
	# More tag and branch tests, keywords.
d562 1
a562 2
	tests="${tests} head tagdate multibranch2"
	# "cvs admin", reserved checkouts.
d564 1
a564 2
	# Nuts and bolts of diffing/merging (diff library, &c)
	tests="${tests} diffmerge1 diffmerge2"
d1906 9
a1914 3
		dotest_sort 56 "${testcvs} import -m first-import second-dir first-immigration immigration1 immigration1_0" \
"

d1918 2
a1919 9
N second-dir/dir1/file14
N second-dir/dir1/file6
N second-dir/dir1/file7
N second-dir/file14
N second-dir/file6
N second-dir/file7
No conflicts created by this import
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/dir1
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/second-dir/dir1/dir2"
d2535 1
a2535 1
	  # Add two files on the trunk.
d2537 1
a2537 2
	  echo "file4 first revision" > file4
	  dotest death2-2 "${testcvs} add file1 file4" \
d2539 1
a2539 2
'"${PROG}"' [a-z]*: scheduling file `file4'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add these files permanently'
a2546 6
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file4,v
done
Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
initial revision: 1\.1
d2550 2
a2551 6
	  dotest death2-4 "${testcvs} -q tag -b branch" \
'T file1
T file4'
	  dotest death2-5 "${testcvs} -q tag tag" \
'T file1
T file4'
a2661 10
	  # Delete file4 from the branch
	  dotest death2-10a "${testcvs} rm -f file4" \
"${PROG} [a-z]*: scheduling .file4. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest death2-10b "${testcvs} -q ci -m removed" \
"Removing file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
new revision: delete; previous revision: 1\.1\.2
done"

d2663 1
a2663 3
	  dotest death2-11 "${testcvs} -q update -A" \
"[UP] file1
U file4"
a2677 8
	  # Modify file4 on the trunk.
	  echo "new file4 revision" > file4
	  dotest death2-13a "${testcvs} -q commit -m mod" \
"Checking in file4;
${TESTDIR}/cvsroot/first-dir/file4,v  <--  file4
new revision: 1\.2; previous revision: 1\.1
done"

d2683 4
a2686 3
"[UP] file1
${PROG} [a-z]*: file2 is no longer in the repository
${PROG} [a-z]*: warning: file4 is not (any longer) pertinent"
d2743 1
a2743 2
${PROG} [a-z]*: tag tag is not in file file3
${PROG} [a-z]*: file4 no longer exists, no comparison available"
d2778 1
a2778 11
${PLUS} first revision
Index: file4
===================================================================
RCS file: file4
diff -N file4
\*\*\* ${tempname}[ 	][ 	]*[a-zA-Z0-9: ]*
--- /dev/null[ 	][ 	]*[a-zA-Z0-9: ]*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- file4 first revision
--- 0 ----"
d2782 4
a2785 1
"[UP] file1
d2787 1
a2787 2
${PROG} [a-z]*: file3 is no longer in the repository
U file4"
a3038 266
	branches2)
	  # More branch tests.
	  # Test that when updating a new subdirectory in a directory
	  # which was checked out on a branch, the new subdirectory is
	  # created on the appropriate branch.  Test this when joining
	  # as well.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir trunk; cd trunk

	  # Create a file.
	  dotest branches2-1 "${testcvs} -q co first-dir"
	  cd first-dir
	  echo "file1 first revision" > file1
	  dotest branches2-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest branches2-3 "${testcvs} commit -m add file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  # Tag the file.
	  dotest branches2-4 "${testcvs} -q tag tag1" 'T file1'

	  # Make two branches.
	  dotest branches2-5 "${testcvs} -q rtag -b -r tag1 b1 first-dir" ''
	  dotest branches2-6 "${testcvs} -q rtag -b -r tag1 b2 first-dir" ''

	  # Create some files and a subdirectory on branch b1.
	  cd ../..
	  mkdir b1; cd b1
	  dotest branches2-7 "${testcvs} -q co -r b1 first-dir" \
"U first-dir/file1"
	  cd first-dir
	  echo "file2 first revision" > file2
	  dotest branches2-8 "${testcvs} add file2" \
"${PROG}"' [a-z]*: scheduling file `file2'\'' for addition on branch `b1'\''
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  mkdir dir1
	  dotest branches2-9 "${testcvs} add dir1" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir1 added to the repository
--> Using per-directory sticky tag "'`'"b1'"
	  echo "file3 first revision" > dir1/file3
	  dotest branches2-10 "${testcvs} add dir1/file3" \
"${PROG}"' [a-z]*: scheduling file `dir1/file3'\'' for addition on branch `b1'\''
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest branches2-11 "${testcvs} -q ci -madd ." \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/Attic/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/dir1/Attic/file3,v
done
Checking in dir1/file3;
${TESTDIR}/cvsroot/first-dir/dir1/Attic/file3,v  <--  file3
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  # Check out the second branch, and update the working
	  # directory to the first branch, to make sure the right
	  # happens with dir1.
	  cd ../..
	  mkdir b2; cd b2
	  dotest branches2-12 "${testcvs} -q co -r b2 first-dir" \
'U first-dir/file1'
	  cd first-dir
	  dotest branches2-13 "${testcvs} update -d -r b1 dir1" \
"${PROG} [a-z]*: Updating dir1
U dir1/file3"
	  dotest branches2-14 "${testcvs} -q status" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		b2 (branch: 1\.1\.4)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Up-to-date

   Working revision:	1\.1\.2\.1.*
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/dir1/Attic/file3,v
   Sticky Tag:		b1 (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  # FIXME: Just clobbering the directory like this is a bit
	  # tacky, although people generally expect it to work.  Maybe
	  # we should release it instead.  We do it a few other places
	  # below as well.
	  rm -r dir1
	  dotest branches2-15 "${testcvs} update -d -j b1 dir1" \
"${PROG} [a-z]*: Updating dir1
U dir1/file3"
	  # FIXCVS: The `No revision control file' stuff seems to be
	  # CVS's way of telling us that we're adding the file on a
	  # branch, and the file is not on that branch yet.  This
	  # should be nicer.
	  dotest branches2-16 "${testcvs} -q status" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		b2 (branch: 1\.1\.4)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		b2 - MISSING from RCS file!
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  cd ../../trunk/first-dir
	  dotest branches2-17 "${testcvs} update -d -P dir1" \
"${PROG} [a-z]*: Updating dir1"
	  dotest_fail branches2-18 "test -d dir1"
	  dotest branches2-19 "${testcvs} update -d -P -r b1 dir1" \
"${PROG} [a-z]*: Updating dir1
U dir1/file3"
	  dotest branches2-20 "${testcvs} -q status" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Up-to-date

   Working revision:	1\.1\.2\.1.*
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/dir1/Attic/file3,v
   Sticky Tag:		b1 (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  rm -r dir1
	  dotest branches2-21 "${testcvs} update -d -P -j b1 dir1" \
"${PROG} [a-z]*: Updating dir1
U dir1/file3"
	  dotest branches2-22 "${testcvs} -q status" \
"===================================================================
File: file1            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file3            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/dir1/Attic/file3,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  cd ../..
	  rm -r b1 b2

	  # Check out branch b1 twice.  Crate a new directory in one
	  # working directory, then do a cvs update in the other
	  # working directory and see if the tags are right.
	  mkdir b1a
	  mkdir b1b
	  cd b1b
	  dotest branches2-23 "${testcvs} -q co -r b1 first-dir" \
'U first-dir/file1
U first-dir/file2
U first-dir/dir1/file3'
	  cd ../b1a
	  dotest branches2-24 "${testcvs} -q co -r b1 first-dir" \
'U first-dir/file1
U first-dir/file2
U first-dir/dir1/file3'
	  cd first-dir
	  mkdir dir2
	  dotest branches2-25 "${testcvs} add dir2" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir2 added to the repository
--> Using per-directory sticky tag "'`'"b1'"
	  echo "file4 first revision" > dir2/file4
	  dotest branches2-26 "${testcvs} add dir2/file4" \
"${PROG}"' [a-z]*: scheduling file `dir2/file4'\'' for addition on branch `b1'\''
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest branches2-27 "${testcvs} -q commit -madd" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/dir2/Attic/file4,v
done
Checking in dir2/file4;
${TESTDIR}/cvsroot/first-dir/dir2/Attic/file4,v  <--  file4
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  cd ../../b1b/first-dir
	  dotest branches2-28 "${testcvs} update -d dir2" \
"${PROG} [a-z]*: Updating dir2
U dir2/file4"
	  cd dir2
	  dotest branches2-29 "${testcvs} -q status" \
"===================================================================
File: file4            	Status: Up-to-date

   Working revision:	1\.1\.2\.1.*
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/dir2/Attic/file4,v
   Sticky Tag:		b1 (branch: 1\.1\.2)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest branches2-30 "cat CVS/Tag" 'Tb1'

	  # Test update -A on a subdirectory
	  cd ..
	  rm -r dir2
	  dotest branches2-31 "${testcvs} update -A -d dir2" \
"${PROG} [a-z]*: Updating dir2"
	  cd dir2
	  dotest branches2-32 "${testcvs} -q status" ''
	  dotest_fail branches2-33 "test -f CVS/Tag"

	  # Add a file on the trunk.
	  echo "file5 first revision" > file5
	  dotest branches2-34 "${testcvs} add file5" \
"${PROG}"' [a-z]*: scheduling file `file5'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest branches2-35 "${testcvs} -q commit -madd" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/dir2/file5,v
done
Checking in file5;
${TESTDIR}/cvsroot/first-dir/dir2/file5,v  <--  file5
initial revision: 1\.1
done"

	  cd ../../../trunk/first-dir
	  dotest branches2-36 "${testcvs} -q update -d dir2" 'U dir2/file5'
	  cd dir2
	  dotest branches2-37 "${testcvs} -q status" \
"===================================================================
File: file5            	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/dir2/file5,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest_fail branches2-38 "test -f CVS/status"

	  cd ../../..
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r trunk b1a b1b
	  ;;

d3570 1
a3570 1
	  dotest_sort importb-1 \
d3572 2
a3573 1
"
a3574 2
N first-dir/file1
N first-dir/file2
d3586 1
a3586 1
	  dotest_sort importb-2 \
d3588 2
a3589 1
"
d3591 2
d3594 1
a3594 5
	${PROG} checkout -jfreemunger:yesterday -jfreemunger first-dir
2 conflicts created by this import.
C first-dir/file1
C first-dir/file2
Use the following command to help the merge:"
d4923 1
a4923 1
	  dotest conflicts3-14 "${testcvs} add sdir" \
a4924 12
	  touch sdir/sfile
	  dotest conflicts3-14a "${testcvs} add sdir/sfile" \
"${PROG} [a-z]*: scheduling file .sdir/sfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest conflicts3-14b "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/sfile,v
done
Checking in sdir/sfile;
${TESTDIR}/cvsroot/first-dir/sdir/sfile,v  <--  sfile
initial revision: 1\.1
done"

a4948 5
	    cd ..
	    dotest conflicts3-16a "${testcvs} -q update first-dir" \
"${QUESTION} first-dir/sdir
${PROG} [a-z]*: ignoring first-dir/sdir (CVS/Entries missing)"
	    cd first-dir
a4962 4
	  cd ..
	  dotest conflicts3-20 "${testcvs} -q update first-dir" \
"${PROG} [a-z]*: ignoring first-dir/newdir (CVS/Entries missing)"
	  cd first-dir
a4964 28
	  # The previous tests have left CVS/Entries in something of a mess.
	  # While we "should" be able to deal with that (maybe), for now
	  # we just start over.
	  cd ..
	  rm -r first-dir
	  dotest conflicts3-20a "${testcvs} -q co -l first-dir" ''
	  cd first-dir

	  dotest conflicts3-21 "${testcvs} -q update -d sdir" "U sdir/sfile"
	  rm -r sdir/CVS
	  dotest conflicts3-22 "${testcvs} -q update" "? sdir"
	  if test "x$remote" = xyes; then
	    # It isn't particularly swift that CVS prints this
	    # "cannot open CVS/Entries" where it has already printed
	    # "? sdir".  At least I don't think so.  But do note: (1)
	    # non-fatal error, and (2) tells us which directory has
	    # the problem.
	    dotest_fail conflicts3-23 "${testcvs} -q update -PdA" \
"${QUESTION} sdir
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory
${PROG} update: move away sdir/sfile; it is in the way
C sdir/sfile"
	  else
	    dotest conflicts3-23 "${testcvs} -q update -PdA" \
"${QUESTION} sdir"
	  fi

a4972 11
	  # Roadmap to various modules tests:
	  # -a:
	  #   error on incorrect placement: modules
	  #   error combining with other options: modules2-a*
	  #   use to specify a file more than once: modules3
	  #   use with ! feature: modules4
	  # regular modules: modules, modules2, cvsadm
	  # ampersand modules: modules2
	  # -s: modules.
	  # -d: modules, modules3, cvsadm
	  # slashes in module names: modules3
d5808 59
a5866 35
	cvsadm)
	  # These test check the content of CVS' administrative
	  # files as they are checked out in various configurations.
	  # (As a side note, I'm not using the "-q" flag in any of
	  # this code, which should provide some extra checking for
          # those messages which don't seem to be checked thoroughly
	  # anywhere else.)  To do a thorough test, we need to make
	  # a bunch of modules in various configurations.
	  #
	  # <1mod> is a directory at the top level of cvsroot
	  #    ``foo bar''
	  # <2mod> is a directory at the second level of cvsroot
	  #    ``foo bar/baz''
	  # <1d1mod> is a directory at the top level which is
	  #   checked out into another directory
	  #     ``foo -d bar baz''
	  # <1d2mod> is a directory at the second level which is
	  #   checked out into another directory
	  #     ``foo -d bar baz/quux''
	  # <2d1mod> is a directory at the top level which is
	  #   checked out into a directory that is two deep
	  #     ``foo -d bar/baz quux''
	  # <2d2mod> is a directory at the second level which is
	  #   checked out into a directory that is two deep
	  #     ``foo -d bar/baz quux''
	  #
	  # The tests do each of these types separately and in twos.
	  # We also repeat each test -d flag for 1-deep and 2-deep
	  # directories.
	  #
	  # Each test should check the output for the Repository
	  # file, since that is the one which varies depending on 
	  # the directory and how it was checked out.
	  #
	  # Yes, this is verbose, but at least it's very thorough.
d5868 10
a5877 2
	  # convenience variables
	  REP=${CVSROOT}
a5878 1
	  # First, check out the modules file and edit it.
d5880 12
a5891 49
	  dotest cvsadm-1 "${testcvs} co CVSROOT/modules" \
"U CVSROOT/modules"

	  # Try to determine whether RELATIVE_REPOS is defined
	  # so that we can make the following a lot less
	  # verbose.

	  echo "${CVSROOT_DIRNAME}/." > ${TESTDIR}/dotest.abs
	  echo "." > ${TESTDIR}/dotest.rel
	  if cmp ${TESTDIR}/dotest.abs CVS/Repository >/dev/null 2>&1; then
	    AREP="${CVSROOT_DIRNAME}/"
	  elif cmp ${TESTDIR}/dotest.rel CVS/Repository >/dev/null 2>&1; then
	    AREP=""
	  else
	    fail "Cannot figure out if RELATIVE_REPOS is defined."
	  fi

	  # Test CVS/Root once.  Since there is only one part of
	  # the code which writes CVS/Root files (Create_Admin),
	  # there is no point in testing this every time.
	  dotest cvsadm-1a "cat CVS/Root" ${REP}
	  dotest cvsadm-1b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1c "cat CVSROOT/CVS/Root" ${REP}
	  dotest cvsadm-1d "cat CVSROOT/CVS/Repository" \
"${AREP}CVSROOT"
          # All of the defined module names begin with a number.
	  # All of the top-level directory names begin with "dir".
	  # All of the subdirectory names begin with "sub".
	  # All of the top-level modules begin with "mod".
	  echo "# Module defs for cvsadm tests" > CVSROOT/modules
	  echo "1mod mod1" >> CVSROOT/modules
	  echo "1mod-2 mod1-2" >> CVSROOT/modules
	  echo "2mod mod2/sub2" >> CVSROOT/modules
	  echo "2mod-2 mod2-2/sub2-2" >> CVSROOT/modules
	  echo "1d1mod -d dir1d1 mod1" >> CVSROOT/modules
	  echo "1d1mod-2 -d dir1d1-2 mod1-2" >> CVSROOT/modules
	  echo "1d2mod -d dir1d2 mod2/sub2" >> CVSROOT/modules
	  echo "1d2mod-2 -d dir1d2-2 mod2-2/sub2-2" >> CVSROOT/modules
	  echo "2d1mod -d dir2d1/sub2d1 mod1" >> CVSROOT/modules
	  echo "2d1mod-2 -d dir2d1-2/sub2d1-2 mod1-2" >> CVSROOT/modules
	  echo "2d2mod -d dir2d2/sub2d2 mod2/sub2" >> CVSROOT/modules
	  echo "2d2mod-2 -d dir2d2-2/sub2d2-2 mod2-2/sub2-2" >> CVSROOT/modules
	  dotest cvsadm-1e "${testcvs} ci -m add-modules" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining CVSROOT
Checking in CVSROOT/modules;
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d5893 3
a5895 38
${PROG} [a-z]*: Rebuilding administrative file database"
	  rm -rf CVS CVSROOT;

	  # Create the various modules
	  mkdir ${CVSROOT_DIRNAME}/mod1
	  mkdir ${CVSROOT_DIRNAME}/mod1-2
	  mkdir ${CVSROOT_DIRNAME}/mod2
	  mkdir ${CVSROOT_DIRNAME}/mod2/sub2
	  mkdir ${CVSROOT_DIRNAME}/mod2-2
	  mkdir ${CVSROOT_DIRNAME}/mod2-2/sub2-2
	  dotest cvsadm-2 "${testcvs} co mod1 mod1-2 mod2 mod2-2" \
"${PROG} [a-z]*: Updating mod1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod2
${PROG} [a-z]*: Updating mod2/sub2
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/sub2-2"

	  # Populate the directories for the halibut
	  echo "file1" > mod1/file1
	  echo "file1-2" > mod1-2/file1-2
	  echo "file2" > mod2/sub2/file2
	  echo "file2-2" > mod2-2/sub2-2/file2-2
	  dotest cvsadm-2a "${testcvs} add mod1/file1 mod1-2/file1-2 mod2/sub2/file2 mod2-2/sub2-2/file2-2" \
"${PROG} [a-z]*: scheduling file .mod1/file1. for addition
${PROG} [a-z]*: scheduling file .mod1-2/file1-2. for addition
${PROG} [a-z]*: scheduling file .mod2/sub2/file2. for addition
${PROG} [a-z]*: scheduling file .mod2-2/sub2-2/file2-2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"

	  dotest cvsadm-2b "${testcvs} ci -m yup mod1 mod1-2 mod2 mod2-2" \
"${PROG} [a-z]*: Examining mod1
${PROG} [a-z]*: Examining mod1-2
${PROG} [a-z]*: Examining mod2
${PROG} [a-z]*: Examining mod2/sub2
${PROG} [a-z]*: Examining mod2-2
${PROG} [a-z]*: Examining mod2-2/sub2-2
RCS file: ${CVSROOT_DIRNAME}/mod1/file1,v
d5897 1
a5897 3
Checking in mod1/file1;
${CVSROOT_DIRNAME}/mod1/file1,v  <--  file1
initial revision: 1.1
d5899 24
a5922 17
RCS file: ${CVSROOT_DIRNAME}/mod1-2/file1-2,v
done
Checking in mod1-2/file1-2;
${CVSROOT_DIRNAME}/mod1-2/file1-2,v  <--  file1-2
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod2/sub2/file2,v
done
Checking in mod2/sub2/file2;
${CVSROOT_DIRNAME}/mod2/sub2/file2,v  <--  file2
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod2-2/sub2-2/file2-2,v
done
Checking in mod2-2/sub2-2/file2-2;
${CVSROOT_DIRNAME}/mod2-2/sub2-2/file2-2,v  <--  file2-2
initial revision: 1.1
a5923 3
	  # Finished creating the modules -- clean up.
	  rm -rf CVS mod1 mod1-2 mod2 mod2-2
	  # Done.
d5925 116
a6040 8
	  ##################################################
	  ## Start the dizzying array of possibilities.
	  ## Begin with each module type separately.
	  ##################################################
	  
	  # Pattern -- after each checkout, first check the top-level
	  # CVS directory.  Then, check the directories in numerical
	  # order.
d6042 42
a6083 8
	  dotest cvsadm-3 "${testcvs} co 1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1"
	  dotest cvsadm-3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-3d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod
d6085 15
a6099 8
	  dotest cvsadm-4 "${testcvs} co 2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  dotest cvsadm-4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-4d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod
d6101 6
a6106 8
	  dotest cvsadm-5 "${testcvs} co 1d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  dotest cvsadm-5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-5d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1
d6108 7
a6114 8
	  dotest cvsadm-6 "${testcvs} co 1d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  dotest cvsadm-6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-6d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2
d6116 40
a6155 10
	  dotest cvsadm-7 "${testcvs} co 2d1mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  dotest cvsadm-7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-7d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-7f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir2d1
d6157 1
a6157 10
	  dotest cvsadm-8 "${testcvs} co 2d2mod" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  dotest cvsadm-8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-8d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-8f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d2
d6159 23
a6181 4
	  ##################################################
	  ## You are in a shell script of twisted little
	  ## module combination statements, all alike.
	  ##################################################
d6183 9
a6191 17
	  ### 1mod
	  
	  dotest cvsadm-9 "${testcvs} co 1mod 1mod-2" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating 1mod-2
U 1mod-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-9b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-9d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1mod copy
	  dotest cvsadm-9f "cat 1mod-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS 1mod 1mod-2
d6193 14
a6206 16
	  # 1mod 2mod redmod bluemod
	  dotest cvsadm-10 "${testcvs} co 1mod 2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  # the usual for the top level
	  dotest cvsadm-10b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-10d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2dmod
	  dotest cvsadm-10f "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod 2mod
d6208 2
a6209 15
	  dotest cvsadm-11 "${testcvs} co 1mod 1d1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  # the usual for the top level
	  dotest cvsadm-11b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-11d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod
	  dotest cvsadm-11f "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod dir1d1
d6211 13
a6223 15
	  dotest cvsadm-12 "${testcvs} co 1mod 1d2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-12b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-12d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-12f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod dir1d2
d6225 4
a6228 17
	  dotest cvsadm-13 "${testcvs} co 1mod 2d1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-13b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-13d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-13f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-13h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod dir2d1
d6230 9
a6238 17
	  dotest cvsadm-14 "${testcvs} co 1mod 2d2mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-14b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-14d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-14f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-14h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 1mod dir2d2
d6240 29
d6270 3
a6272 17
	  ### 2mod
	  
	  dotest cvsadm-15 "${testcvs} co 2mod 2mod-2" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating 2mod-2
U 2mod-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-15b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-15d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2mod copy
	  dotest cvsadm-15f "cat 2mod-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS 2mod 2mod-2
d6274 16
d6291 11
a6301 15
	  dotest cvsadm-16 "${testcvs} co 2mod 1d1mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  # the usual for the top level
	  dotest cvsadm-16b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-16d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d1mod
	  dotest cvsadm-16f "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 2mod dir1d1
d6303 17
a6319 15
	  dotest cvsadm-17 "${testcvs} co 2mod 1d2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-17b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-17d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod
	  dotest cvsadm-17f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod dir1d2
d6321 8
a6328 17
	  dotest cvsadm-18 "${testcvs} co 2mod 2d1mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-18b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-18d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-18f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-18h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 2mod dir2d1
d6330 11
a6340 17
	  dotest cvsadm-19 "${testcvs} co 2mod 2d2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-19b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-19d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-19f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-19h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod dir2d2
d6342 5
d6348 39
a6386 1
	  ### 1d1mod
d6388 1
a6388 15
	  dotest cvsadm-20 "${testcvs} co 1d1mod 1d1mod-2" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir1d1-2
U dir1d1-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-20b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-20d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod copy
	  dotest cvsadm-20f "cat dir1d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir1d1 dir1d1-2
d6390 3
a6392 15
	  dotest cvsadm-21 "${testcvs} co 1d1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  # the usual for the top level
	  dotest cvsadm-21b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-21d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-21f "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d1 dir1d2
d6394 7
a6400 17
	  dotest cvsadm-22 "${testcvs} co 1d1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-22b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-22d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-22f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-22h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1 dir2d1
d6402 8
a6409 17
	  dotest cvsadm-23 "${testcvs} co 1d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-23b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-23d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-23f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-23h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d1 dir2d2
d6411 5
d6417 5
a6421 1
	  ### 1d2mod
d6423 9
a6431 15
	  dotest cvsadm-24 "${testcvs} co 1d2mod 1d2mod-2" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir1d2-2
U dir1d2-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-24b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-24d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod copy
	  dotest cvsadm-24f "cat dir1d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir1d2 dir1d2-2
d6433 12
a6444 17
	  dotest cvsadm-25 "${testcvs} co 1d2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  # the usual for the top level
	  dotest cvsadm-25b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-25d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-25f "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-25h "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d2 dir2d1
d6446 6
a6451 17
	  dotest cvsadm-26 "${testcvs} co 1d2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-26b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-26d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-26f "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-26h "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2 dir2d2
d6453 10
d6464 4
a6467 1
	  # 2d1mod
d6469 4
a6472 19
	  dotest cvsadm-27 "${testcvs} co 2d1mod 2d1mod-2" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir2d1-2/sub2d1-2
U dir2d1-2/sub2d1-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-27b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-27d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-27f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-27h "cat dir2d1-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-27j "cat dir2d1-2/sub2d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir2d1 dir2d1-2
d6474 8
a6481 19
	  dotest cvsadm-28 "${testcvs} co 2d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  # the usual for the top level
	  dotest cvsadm-28b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-28d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-28f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-28h "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-28j "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d1 dir2d2
d6483 4
a6486 2
	  
	  # 2d2mod
d6488 8
a6495 19
	  dotest cvsadm-29 "${testcvs} co 2d2mod 2d2mod-2" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2
${PROG} [a-z]*: Updating dir2d2-2/sub2d2-2
U dir2d2-2/sub2d2-2/file2-2"
	  # the usual for the top level
	  dotest cvsadm-29b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for 2d2mod
	  dotest cvsadm-29d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-29f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-29h "cat dir2d2-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-29j "cat dir2d2-2/sub2d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir2d2 dir2d2-2
d6497 4
a6500 4
	  ##################################################
	  ## And now, all of that again using the "-d" flag
	  ## on the command line.
	  ##################################################
d6502 18
a6519 8
	  dotest cvsadm-1d3 "${testcvs} co -d dir 1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d3d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6521 18
a6538 8
	  dotest cvsadm-1d4 "${testcvs} co -d dir 2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d4d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6540 1
a6540 8
	  dotest cvsadm-1d5 "${testcvs} co -d dir 1d1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d5d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6542 4
a6545 8
	  dotest cvsadm-1d6 "${testcvs} co -d dir 1d2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d6d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6547 8
a6554 8
	  dotest cvsadm-1d7 "${testcvs} co -d dir 2d1mod" \
"${PROG} [a-z]*: Updating dir
U dir/file1"
	  dotest cvsadm-1d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d7d "cat dir/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6556 4
a6559 8
	  dotest cvsadm-1d8 "${testcvs} co -d dir 2d2mod" \
"${PROG} [a-z]*: Updating dir
U dir/file2"
	  dotest cvsadm-1d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-1d8d "cat dir/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6561 35
a6595 3
	  ##################################################
	  ## Los Combonaciones
	  ##################################################
d6597 1
a6597 1
	  ### 1mod
d6599 4
a6602 18
	  dotest cvsadm-1d9 "${testcvs} co -d dir 1mod 1mod-2" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/1mod-2
U dir/1mod-2/file1-2"
	  # the usual for the top level
	  dotest cvsadm-1d9b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d9d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d9f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1mod copy
	  dotest cvsadm-1d9h "cat dir/1mod-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir
d6604 7
a6610 18
	  # 1mod 2mod redmod bluemod
	  dotest cvsadm-1d10 "${testcvs} co -d dir 1mod 2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2"
	  dotest cvsadm-1d10b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d10d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d10f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2dmod
	  dotest cvsadm-1d10h "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6612 40
a6651 17
	  dotest cvsadm-1d11 "${testcvs} co -d dir 1mod 1d1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-1d11b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d11d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d11f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod
	  dotest cvsadm-1d11h "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6653 33
a6685 17
	  dotest cvsadm-1d12 "${testcvs} co -d dir 1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d12b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d12d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d12f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-1d12h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6687 7
a6693 19
	  dotest cvsadm-1d13 "${testcvs} co -d dir 1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d13b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d13d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d13f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d13h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d13j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6695 5
a6699 19
	  dotest cvsadm-1d14 "${testcvs} co -d dir 1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d14b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d14d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1mod
	  dotest cvsadm-1d14f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d14h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d14j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6701 5
d6707 11
a6717 1
	  ### 2mod
d6719 6
a6724 17
	  dotest cvsadm-1d15 "${testcvs} co -d dir 2mod 2mod-2" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/2mod-2
U dir/2mod-2/file2-2"
	  dotest cvsadm-1d15b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d15d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d15f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2mod copy
	  dotest cvsadm-1d15h "cat dir/2mod-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir
d6726 11
a6736 17
	  dotest cvsadm-1d16 "${testcvs} co -d dir 2mod 1d1mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-1d16b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d16d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d16f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d1mod
	  dotest cvsadm-1d16h "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6738 9
a6746 17
	  dotest cvsadm-1d17 "${testcvs} co -d dir 2mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d17b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d17d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d17f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod
	  dotest cvsadm-1d17h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6748 9
a6756 19
	  dotest cvsadm-1d18 "${testcvs} co -d dir 2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d18b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d18d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d18f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-1d18h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d18j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6758 22
a6779 19
	  dotest cvsadm-1d19 "${testcvs} co -d dir 2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d19b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d19d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2mod
	  dotest cvsadm-1d19f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d19h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d19j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6781 6
d6788 8
a6795 1
	  ### 1d1mod
d6797 2
a6798 17
	  dotest cvsadm-1d20 "${testcvs} co -d dir 1d1mod 1d1mod-2" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir1d1-2
U dir/dir1d1-2/file1-2"
	  dotest cvsadm-1d20b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d20d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d20f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d1mod copy
	  dotest cvsadm-1d20h "cat dir/dir1d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir
d6800 16
a6815 17
	  dotest cvsadm-1d21 "${testcvs} co -d dir 1d1mod 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-1d21b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d21d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d21f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 1d2mod
	  dotest cvsadm-1d21h "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6817 10
a6826 19
	  dotest cvsadm-1d22 "${testcvs} co -d dir 1d1mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d22b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d22d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d22f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d22h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d22j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6828 19
a6846 19
	  dotest cvsadm-1d23 "${testcvs} co -d dir 1d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d23b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d23d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d1mod
	  dotest cvsadm-1d23f "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d23h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d23j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6848 31
d6880 5
a6884 1
	  ### 1d2mod
d6886 11
a6896 17
	  dotest cvsadm-1d24 "${testcvs} co -d dir 1d2mod 1d2mod-2" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir1d2-2
U dir/dir1d2-2/file2-2"
	  dotest cvsadm-1d24b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d24d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d24f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 1d2mod copy
	  dotest cvsadm-1d24h "cat dir/dir1d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir
d6898 8
a6905 19
	  dotest cvsadm-1d25 "${testcvs} co -d dir 1d2mod 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-1d25b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d25d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d25f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d1mod
	  dotest cvsadm-1d25h "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d25j "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d6907 9
a6915 19
	  dotest cvsadm-1d26 "${testcvs} co -d dir 1d2mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d26b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d26d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 1d2mod
	  dotest cvsadm-1d26f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d26h "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d26j "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6917 17
d6935 8
a6942 1
	  # 2d1mod
d6944 5
a6948 21
	  dotest cvsadm-1d27 "${testcvs} co -d dir 2d1mod 2d1mod-2" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir/dir2d1-2/sub2d1-2
U dir/dir2d1-2/sub2d1-2/file1-2"
	  dotest cvsadm-1d27b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d27d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-1d27f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d27h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d1mod
	  dotest cvsadm-1d27j "cat dir/dir2d1-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d27l "cat dir/dir2d1-2/sub2d1-2/CVS/Repository" \
"${AREP}mod1-2"
	  rm -rf CVS dir
d6950 2
a6951 21
	  dotest cvsadm-1d28 "${testcvs} co -d dir 2d1mod 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-1d28b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d28d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d1mod
	  dotest cvsadm-1d28f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d28h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  # the usual for 2d2mod
	  dotest cvsadm-1d28j "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d28l "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d6953 8
a6960 2
	  
	  # 2d2mod
d6962 7
a6968 21
	  dotest cvsadm-1d29 "${testcvs} co -d dir 2d2mod 2d2mod-2" \
"${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2
${PROG} [a-z]*: Updating dir/dir2d2-2/sub2d2-2
U dir/dir2d2-2/sub2d2-2/file2-2"
	  dotest cvsadm-1d29b "cat CVS/Repository" \
"${AREP}\."
	  # the usual for the dir level
	  dotest cvsadm-1d29d "cat dir/CVS/Repository" \
"${AREP}\."
	  # the usual for 2d2mod
	  dotest cvsadm-1d29f "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d29h "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  # the usual for 2d2mod
	  dotest cvsadm-1d29j "cat dir/dir2d2-2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-1d29l "cat dir/dir2d2-2/sub2d2-2/CVS/Repository" \
"${AREP}mod2-2/sub2-2"
	  rm -rf CVS dir
d6970 29
a6998 4
	  ##################################################
	  ## And now, some of that again using the "-d" flag
	  ## on the command line, but use a longer path.
	  ##################################################
d7000 10
a7009 10
	  dotest cvsadm-2d3 "${testcvs} co -d dir/dir2 1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d3d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d3f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7011 5
a7015 10
	  dotest cvsadm-2d4 "${testcvs} co -d dir/dir2 2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d4d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d4f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7017 16
a7032 10
	  dotest cvsadm-2d5 "${testcvs} co -d dir/dir2 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d5d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d5f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7034 5
a7038 10
	  dotest cvsadm-2d6 "${testcvs} co -d dir/dir2 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d6d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d6f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7040 6
a7045 10
	  dotest cvsadm-2d7 "${testcvs} co -d dir/dir2 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file1"
	  dotest cvsadm-2d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d7d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d7f "cat dir/dir2/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7047 12
a7058 10
	  dotest cvsadm-2d8 "${testcvs} co -d dir/dir2 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2
U dir/dir2/file2"
	  dotest cvsadm-2d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-2d8d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-2d8f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7060 5
a7064 4
	  ##################################################
	  ## And now, a few of those tests revisited to
	  ## test the behavior of the -N flag.
	  ##################################################
d7066 20
a7085 8
	  dotest cvsadm-N3 "${testcvs} co -N 1mod" \
"${PROG} [a-z]*: Updating 1mod
U 1mod/file1"
	  dotest cvsadm-N3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N3d "cat 1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS 1mod
d7087 4
a7090 8
	  dotest cvsadm-N4 "${testcvs} co -N 2mod" \
"${PROG} [a-z]*: Updating 2mod
U 2mod/file2"
	  dotest cvsadm-N4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N4d "cat 2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS 2mod
d7092 18
a7109 8
	  dotest cvsadm-N5 "${testcvs} co -N 1d1mod" \
"${PROG} [a-z]*: Updating dir1d1
U dir1d1/file1"
	  dotest cvsadm-N5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N5d "cat dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir1d1
d7111 4
a7114 8
	  dotest cvsadm-N6 "${testcvs} co -N 1d2mod" \
"${PROG} [a-z]*: Updating dir1d2
U dir1d2/file2"
	  dotest cvsadm-N6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N6d "cat dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir1d2
d7116 8
a7123 10
	  dotest cvsadm-N7 "${testcvs} co -N 2d1mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  dotest cvsadm-N7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N7d "cat dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N7f "cat dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir2d1
d7125 75
a7199 10
	  dotest cvsadm-N8 "${testcvs} co -N 2d2mod" \
"${PROG} [a-z]*: Updating dir2d2/sub2d2
U dir2d2/sub2d2/file2"
	  dotest cvsadm-N8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N8d "cat dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N8f "cat dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir2d2
d7201 12
a7212 1
	  ## the ones in one-deep directories
d7214 6
a7219 10
	  dotest cvsadm-N1d3 "${testcvs} co -N -d dir 1mod" \
"${PROG} [a-z]*: Updating dir/1mod
U dir/1mod/file1"
	  dotest cvsadm-N1d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d3d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d3f "cat dir/1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7221 18
a7238 10
	  dotest cvsadm-N1d4 "${testcvs} co -N -d dir 2mod" \
"${PROG} [a-z]*: Updating dir/2mod
U dir/2mod/file2"
	  dotest cvsadm-N1d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d4d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d4f "cat dir/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7240 31
a7270 10
	  dotest cvsadm-N1d5 "${testcvs} co -N -d dir 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir1d1
U dir/dir1d1/file1"
	  dotest cvsadm-N1d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d5d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d5d "cat dir/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7272 3
a7274 10
	  dotest cvsadm-N1d6 "${testcvs} co -N -d dir 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir1d2
U dir/dir1d2/file2"
	  dotest cvsadm-N1d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d6d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d6f "cat dir/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7276 16
a7291 12
	  dotest cvsadm-N1d7 "${testcvs} co -N -d dir 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2d1/sub2d1
U dir/dir2d1/sub2d1/file1"
	  dotest cvsadm-N1d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d7d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d7f "cat dir/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N1d7h "cat dir/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7293 3
a7295 12
	  dotest cvsadm-N1d8 "${testcvs} co -N -d dir 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2d2/sub2d2
U dir/dir2d2/sub2d2/file2"
	  dotest cvsadm-N1d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d8d "cat dir/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N1d8d "cat dir/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N1d8d "cat dir/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7297 4
a7300 1
	  ## the ones in two-deep directories
d7302 75
a7376 12
	  dotest cvsadm-N2d3 "${testcvs} co -N -d dir/dir2 1mod" \
"${PROG} [a-z]*: Updating dir/dir2/1mod
U dir/dir2/1mod/file1"
	  dotest cvsadm-N2d3b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d3d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d3f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d3h "cat dir/dir2/1mod/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7378 7
a7384 12
	  dotest cvsadm-N2d4 "${testcvs} co -N -d dir/dir2 2mod" \
"${PROG} [a-z]*: Updating dir/dir2/2mod
U dir/dir2/2mod/file2"
	  dotest cvsadm-N2d4b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d4d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d4f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d4h "cat dir/dir2/2mod/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7386 11
a7396 12
	  dotest cvsadm-N2d5 "${testcvs} co -N -d dir/dir2 1d1mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir1d1
U dir/dir2/dir1d1/file1"
	  dotest cvsadm-N2d5b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d5d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d5f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d5h "cat dir/dir2/dir1d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7398 7
a7404 12
	  dotest cvsadm-N2d6 "${testcvs} co -N -d dir/dir2 1d2mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir1d2
U dir/dir2/dir1d2/file2"
	  dotest cvsadm-N2d6b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d6d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d6f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d6h "cat dir/dir2/dir1d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7406 16
a7421 14
	  dotest cvsadm-N2d7 "${testcvs} co -N -d dir/dir2 2d1mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir2d1/sub2d1
U dir/dir2/dir2d1/sub2d1/file1"
	  dotest cvsadm-N2d7b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d7d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d7f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d7f "cat dir/dir2/dir2d1/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d7h "cat dir/dir2/dir2d1/sub2d1/CVS/Repository" \
"${AREP}mod1"
	  rm -rf CVS dir
d7423 3
a7425 14
	  dotest cvsadm-N2d8 "${testcvs} co -N -d dir/dir2 2d2mod" \
"${PROG} [a-z]*: Updating dir/dir2/dir2d2/sub2d2
U dir/dir2/dir2d2/sub2d2/file2"
	  dotest cvsadm-N2d8b "cat CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d8d "cat dir/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d8f "cat dir/dir2/CVS/Repository" \
"${AREP}\."
	  dotest cvsadm-N2d8h "cat dir/dir2/dir2d2/CVS/Repository" \
"${AREP}CVSROOT/Emptydir"
	  dotest cvsadm-N2d8j "cat dir/dir2/dir2d2/sub2d2/CVS/Repository" \
"${AREP}mod2/sub2"
	  rm -rf CVS dir
d7427 1
a7427 3
	  ##################################################
	  ## That's enough of that, thank you very much.
	  ##################################################
a7428 11
	  # remove our junk
	  cd ..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/1mod
	  rm -rf ${CVSROOT_DIRNAME}/1mod-2
	  rm -rf ${CVSROOT_DIRNAME}/2mod
	  rm -rf ${CVSROOT_DIRNAME}/2mod-2
	  rm -rf ${CVSROOT_DIRNAME}/mod1
	  rm -rf ${CVSROOT_DIRNAME}/mod1-2
	  rm -rf ${CVSROOT_DIRNAME}/mod2
	  rm -rf ${CVSROOT_DIRNAME}/mod2-2
d7431 3
a7433 4
	abspath)
	
	  # These tests test the thituations thin thwitch thoo theck
	  # things thout twith thabsolute thaths.  Threally.
d7435 3
a7437 3
	  #
	  # CHECKOUTS
	  #
d7439 4
a7442 5
	  # Create a few modules to use
	  mkdir ${CVSROOT_DIRNAME}/mod1 ${CVSROOT_DIRNAME}/mod2
	  dotest abspath-1a "${testcvs} co mod1 mod2" \
"${PROG} [a-z]*: Updating mod1
${PROG} [a-z]*: Updating mod2"
d7444 3
a7446 39
	  # Populate the module
	  echo "file1" > mod1/file1
	  echo "file2" > mod2/file2
	  dotest abspath-1b "${testcvs} add mod1/file1 mod2/file2" \
"${PROG} [a-z]*: scheduling file .mod1/file1. for addition
${PROG} [a-z]*: scheduling file .mod2/file2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"

	  dotest abspath-1c "${testcvs} ci -m yup mod1 mod2" \
"${PROG} [a-z]*: Examining mod1
${PROG} [a-z]*: Examining mod2
RCS file: ${CVSROOT_DIRNAME}/mod1/file1,v
done
Checking in mod1/file1;
${CVSROOT_DIRNAME}/mod1/file1,v  <--  file1
initial revision: 1.1
done
RCS file: ${CVSROOT_DIRNAME}/mod2/file2,v
done
Checking in mod2/file2;
${CVSROOT_DIRNAME}/mod2/file2,v  <--  file2
initial revision: 1.1
done"
	  # Finished creating the module -- clean up.
	  rm -rf CVS mod1 mod2
	  # Done.
	  
	  # Try checking out the module in a local directory
	  dotest abspath-2a "${testcvs} co -d ${TESTDIR}/1 mod1" \
"${PROG} [a-z]*: Updating ${TESTDIR}/1
U ${TESTDIR}/1/file1"

	  # Are we relative or absolute in our Repository file?
	  echo "${CVSROOT_DIRNAME}/mod1" > ${TESTDIR}/dotest.abs
	  echo "mod1" > ${TESTDIR}/dotest.rel
	  if cmp ${TESTDIR}/dotest.abs ${TESTDIR}/1/CVS/Repository >/dev/null 2>&1; then
	    AREP="${CVSROOT_DIRNAME}/"
	  elif cmp ${TESTDIR}/dotest.rel ${TESTDIR}/1/CVS/Repository >/dev/null 2>&1; then
	    AREP=""
d7448 1
a7448 1
	    fail "Cannot figure out if RELATIVE_REPOS is defined."
d7450 7
a7456 1
	  rm -f ${TESTDIR}/dotest.rel ${TESTDIR}/dotest.abs
d7458 5
a7462 2
	  dotest abspath-2b "cat ${TESTDIR}/1/CVS/Repository" \
"${AREP}mod1"
d7464 2
a7465 2
	  # Done.  Clean up.
	  rm -rf ${TESTDIR}/1
d7467 8
d7476 3
a7478 10
	  # Now try in a subdirectory.  We're not covering any more
	  # code here, but we might catch a future error if someone
	  # changes the checkout code.
	  dotest abspath-3a "${testcvs} co -d ${TESTDIR}/1/2 mod1" \
"${PROG} [a-z]*: Updating ${TESTDIR}/1/2
U ${TESTDIR}/1/2/file1"
	  dotest abspath-3b "cat ${TESTDIR}/1/2/CVS/Repository" \
"${AREP}mod1"
	  # Done.  Clean up.
	  rm -rf ${TESTDIR}/1
d7480 3
d7484 83
a7566 8
	  # Now try someplace where we don't have permission.
	  mkdir ${TESTDIR}/barf
	  chmod -w ${TESTDIR}/barf
	  dotest_fail abspath-4 "${testcvs} co -d ${TESTDIR}/barf/sub mod1" \
"${PROG} \[[a-z]* aborted\]: cannot make directory sub: No such file or directory"
	  chmod +w ${TESTDIR}/barf
	  rmdir ${TESTDIR}/barf
	  # Done.  Nothing to clean up.
d7568 3
d7572 1
a7572 14
	  # Try checking out two modules into the same directory.
	  dotest abspath-5a "${testcvs} co -d ${TESTDIR}/1 mod1 mod2" \
"${PROG} [a-z]*: Updating ${TESTDIR}/1/mod1
U ${TESTDIR}/1/mod1/file1
${PROG} [a-z]*: Updating ${TESTDIR}/1/mod2
U ${TESTDIR}/1/mod2/file2"
	  dotest abspath-5b "cat ${TESTDIR}/1/CVS/Repository" \
"${AREP}."
	  dotest abspath-5c "cat ${TESTDIR}/1/mod1/CVS/Repository" \
"${AREP}mod1"
	  dotest abspath-5d "cat ${TESTDIR}/1/mod2/CVS/Repository" \
"${AREP}mod2"
	  # Done.  Clean up.
	  rm -rf ${TESTDIR}/1
d7574 1
d7576 4
a7579 19
	  # Try checking out the top-level module.
	  dotest abspath-6a "${testcvs} co -d ${TESTDIR}/1 ." \
"${PROG} [a-z]*: Updating ${TESTDIR}/1
${PROG} [a-z]*: Updating ${TESTDIR}/1/CVSROOT
${DOTSTAR}
${PROG} [a-z]*: Updating ${TESTDIR}/1/mod1
U ${TESTDIR}/1/mod1/file1
${PROG} [a-z]*: Updating ${TESTDIR}/1/mod2
U ${TESTDIR}/1/mod2/file2"
	  dotest abspath-6b "cat ${TESTDIR}/1/CVS/Repository" \
"${AREP}."
	  dotest abspath-6c "cat ${TESTDIR}/1/CVSROOT/CVS/Repository" \
"${AREP}CVSROOT"
	  dotest abspath-6c "cat ${TESTDIR}/1/mod1/CVS/Repository" \
"${AREP}mod1"
	  dotest abspath-6d "cat ${TESTDIR}/1/mod2/CVS/Repository" \
"${AREP}mod2"
	  # Done.  Clean up.
	  rm -rf ${TESTDIR}/1
d7581 11
a7591 3
	  #
	  # FIXME: do other functions here (e.g. update /tmp/foo)
	  #
d7593 6
a7598 2
	  # Finished with all tests.  Remove the module.
	  rm -rf ${CVSROOT_DIRNAME}/mod1 ${CVSROOT_DIRNAME}/mod1
d7600 7
a7606 4
	  # FIXME: the absolute pathname fixes create CVS directories
	  # wherever they can.  That means for the standard TESTDIR, a
	  # /tmp/CVS directory will be created as well.  It's not safe
	  # to remove it, however.
d7608 9
a7616 1
	  ;;
d7618 14
a7631 3
	toplevel)
	  # test the feature that cvs creates a CVS subdir also for
	  # the toplevel directory
d7633 3
a7635 4
	  # Some test, somewhere, is creating Emptydir.  That test
	  # should, perhaps, clean up for itself, but I don't know which
	  # one it is.
	  rm -rf ${CVSROOT_DIRNAME}/CVSROOT/Emptydir
d7637 8
a7644 7
	  mkdir 1; cd 1
	  dotest toplevel-1 "${testcvs} -q co -l ." ''
	  mkdir top-dir second-dir
	  dotest toplevel-2 "${testcvs} add top-dir second-dir" \
"Directory ${TESTDIR}/cvsroot/top-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
	  cd top-dir
d7646 22
a7667 6
	  touch file1
	  dotest toplevel-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest toplevel-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/top-dir/file1,v
d7669 2
a7670 2
Checking in file1;
${TESTDIR}/cvsroot/top-dir/file1,v  <--  file1
d7675 5
a7679 12
	  cd second-dir
	  touch file2
	  dotest toplevel-3s "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest toplevel-4s "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/second-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/second-dir/file2,v  <--  file2
initial revision: 1\.1
done"
d7681 3
a7683 5
	  cd ../..
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel-5 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"
d7685 2
a7686 5
	  dotest toplevel-6 "${testcvs} update top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  dotest toplevel-7 "${testcvs} update"  \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating top-dir"
d7688 2
a7689 18
	  dotest toplevel-8 "${testcvs} update -d top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  # There is some sentiment that
	  #   "${PROG} [a-z]*: Updating \.
          #   ${PROG} [a-z]*: Updating top-dir"
	  # is correct but it isn't clear why that would be correct instead
	  # of the remote CVS behavior (which also updates CVSROOT).
	  #
	  # The DOTSTAR matches of a bunch of lines like
	  # "U CVSROOT/checkoutlist".  Trying to match them more precisely
	  # seemed to cause trouble.  For example CVSROOT/cvsignore will
	  # be present or absent depending on whether we ran the "ignore"
	  # test or not.
	  dotest toplevel-9 "${testcvs} update -d" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating CVSROOT
${DOTSTAR}
${PROG} [a-z]*: Updating top-dir"
d7691 53
a7743 9
	  cd ..
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel-10 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"
	  # This tests more or less the same thing, in a particularly
	  # "real life" example.
	  dotest toplevel-11 "${testcvs} -q update -d second-dir" \
"U second-dir/file2"
d7745 4
a7748 12
	  # Now remove the CVS directory (people may do this manually,
	  # especially if they formed their habits with CVS
	  # 1.9 and older, which didn't create it.  Or perhaps the working
	  # directory itself was created with 1.9 or older).
	  rm -r CVS
	  # Now set the permissions so we can't recreate it.
	  chmod -w ../1
	  # Now see whether CVS has trouble because it can't create CVS.
	  dotest toplevel-12 "${testcvs} co top-dir" \
"${PROG} [a-z]*: warning: cannot make directory CVS in \.: Permission denied
${PROG} [a-z]*: Updating top-dir"
	  chmod +w ../1
d7750 3
d7754 4
a7757 3
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/top-dir ${CVSROOT_DIRNAME}/second-dir
	  ;;
d7759 13
a7771 52
	mflag)
	  for message in '' ' ' '	
           ' '    	  	test' ; do
	    # Set up
	    mkdir a-dir; cd a-dir
	    # Test handling of -m during import
	    echo testa >>test
	    if ${testcvs} import -m "$message" a-dir A A1 >>${LOGFILE} 2>&1;then
	        pass 156
	    else
		fail 156
	    fi
	    # Must import twice since the first time uses inline code that
	    # avoids RCS call.
	    echo testb >>test
	    if ${testcvs} import -m "$message" a-dir A A2 >>${LOGFILE} 2>&1;then
		pass 157
	    else
		fail 157
	    fi
	    # Test handling of -m during ci
	    cd ..; rm -r a-dir
	    if ${testcvs} co a-dir >>${LOGFILE} 2>&1; then
		pass 158
	    else
		fail 158
	    fi
	    cd a-dir
	    echo testc >>test
	    if ${testcvs} ci -m "$message" >>${LOGFILE} 2>&1; then
		pass 159
	    else
		fail 159
	    fi
	    # Test handling of -m during rm/ci
	    rm test;
	    if ${testcvs} rm test >>${LOGFILE} 2>&1; then
		pass 160
	    else
		fail 160
	    fi
	    if ${testcvs} ci -m "$message" >>${LOGFILE} 2>&1; then
		pass 161
	    else
		fail 161
	    fi
	    # Clean up
	    cd ..
	    rm -r a-dir
	    rm -rf ${CVSROOT_DIRNAME}/a-dir
	  done
	  ;;
d7773 2
a7774 6
	editor)
	  # More tests of log messages, in this case the ability to
	  # run an external editor.
	  # TODO:
	  #   * also test $EDITOR, $CVSEDITOR, &c.
	  #   * test what happens if up-to-date check fails.
d7776 4
a7779 10
	  # Our "editor" puts "x" at the start of each line, so we
	  # can see the "CVS:" lines.
	  cat >${TESTDIR}/editme <<EOF
#!${TESTSHELL}
sleep 1
sed <\$1 -e 's/^/x&/g' >${TESTDIR}/edit.new
mv ${TESTDIR}/edit.new \$1
exit 0
EOF
	  chmod +x ${TESTDIR}/editme
d7781 12
a7792 2
	  mkdir 1; cd 1
	  dotest editor-1 "${testcvs} -q co -l ." ''
d7794 1
a7794 1
	  dotest editor-2 "${testcvs} add first-dir" \
d7797 6
a7802 7
	  touch file1 file2
	  dotest editor-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest editor-4 "${testcvs} -e ${TESTDIR}/editme -q ci" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d7804 2
a7805 8
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
d7808 9
a7816 20
	  dotest editor-5 "${testcvs} -q tag -b br" "T file1
T file2"
	  dotest editor-6 "${testcvs} -q update -r br" ''
	  echo modify >>file1
	  dotest editor-7 "${testcvs} -e ${TESTDIR}/editme -q ci" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  # OK, now we want to make sure "ci -r" puts in the branch
	  # where appropriate.  Note that we can check in on the branch
	  # without being on the branch, because there is not a revision
	  # already on the branch.  If there were a revision on the branch,
	  # CVS would correctly give an up-to-date check failed.
	  dotest editor-8 "${testcvs} -q update -A" "U file1"
	  echo add a line >>file2
	  dotest editor-9 "${testcvs} -q -e ${TESTDIR}/editme ci -rbr file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
d7818 38
d7857 4
a7860 37
	  dotest editor-log-file1 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file1
xCVS: ----------------------------------------------------------------------
============================================================================="
d7862 9
a7870 78
	  # The only difference between the two expect strings is the
	  # presence or absence of "Committing in ." for 1.1.2.1.
	  dotest editor-log-file2 "${testcvs} log -N file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file2
xCVS: ----------------------------------------------------------------------
=============================================================================" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Added Files:
xCVS: 	file1 file2
xCVS: ----------------------------------------------------------------------
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
x
xCVS: ----------------------------------------------------------------------
xCVS: Enter Log.  Lines beginning with .CVS:. are removed automatically
xCVS:
xCVS: Committing in .
xCVS:
xCVS: Modified Files:
xCVS:  Tag: br
xCVS: 	file2
xCVS: ----------------------------------------------------------------------
============================================================================="
	  cd ../..
	  rm -r 1
	  rm ${TESTDIR}/editme
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d7872 6
a7877 42
	errmsg1)
	  mkdir ${CVSROOT_DIRNAME}/1dir
	  mkdir 1
	  cd 1
	  if ${testcvs} -q co 1dir; then
	      pass 162
	  else
	      fail 162
	  fi
	  cd 1dir
	  touch foo
	  if ${testcvs} add foo 2>>${LOGFILE}; then
	      pass 163
	  else
	      fail 163
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	      pass 164
	  else
	      fail 164
	  fi
	  cd ../..
	  mkdir 2
	  cd 2
	  if ${testcvs} -q co 1dir >>${LOGFILE}; then
	      pass 165
	  else
	      fail 165
	  fi
	  chmod a-w 1dir
	  cd ../1/1dir
	  rm foo;
	  if ${testcvs} rm foo >>${LOGFILE} 2>&1; then
	      pass 166
	  else
	      fail 166
	  fi
	  if ${testcvs} ci -m removed >>${LOGFILE} 2>&1; then
	      pass 167
	  else
	      fail 167
	  fi
d7879 7
a7885 15
	  cd ../../2/1dir
	  # FIXME: should be using dotest.
	  ${testcvs} -q update 2>../tst167.err
	  cat ../tst167.err >>${LOGFILE}
	  cat <<EOF >../tst167.ans
${PROG} server: warning: foo is not (any longer) pertinent
${PROG} update: unable to remove ./foo: Permission denied
EOF
	  if cmp ../tst167.ans ../tst167.err >/dev/null ||
	  ( echo "${PROG} [update aborted]: cannot rename file foo to CVS/,,foo: Permission denied" | cmp - ../tst167.err >/dev/null )
	  then
	      pass 168
	  else
	      fail 168
	  fi
d7887 22
d7910 11
a7920 5
	  chmod u+w 1dir
	  cd ..
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/1dir
	  ;;
d7922 8
a7929 7
	errmsg2)
	  # More tests of various miscellaneous error handling,
	  # and cvs add behavior in general.
	  # See also test basicb-4a, concerning "cvs ci CVS".
	  # Too many tests to mention test the simple cases of
	  # adding files and directories.
	  # Test basicb-2a10 tests cvs -n add.
d7931 16
a7946 31
	  # First the usual setup; create a directory first-dir.
	  mkdir 1; cd 1
	  dotest errmsg2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest errmsg2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  dotest_fail errmsg2-3 "${testcvs} add CVS" \
"${PROG} [a-z]*: cannot add special file .CVS.; skipping"
	  touch file1
	  # For the most part add returns a failure exitstatus if
	  # there are any errors, even if the remaining files are
	  # processed without incident.  The "cannot add
	  # special file" message fits this pattern, at
	  # least currently.
	  dotest_fail errmsg2-4 "${testcvs} add CVS file1" \
"${PROG} [a-z]*: cannot add special file .CVS.; skipping
${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # I'm not sure these tests completely convey the various strange
	  # behaviors that CVS had before it specially checked for "." and
	  # "..".  Suffice it to say that these are unlikely to work right
	  # without a special case.
	  dotest_fail errmsg2-5 "${testcvs} add ." \
"${PROG} [a-z]*: cannot add special file .\..; skipping"
	  dotest_fail errmsg2-6 "${testcvs} add .." \
"${PROG} [a-z]*: cannot add special file .\.\..; skipping"
	  # Make sure that none of the error messages left droppings
	  # which interfere with normal operation.
	  dotest errmsg2-7 "${testcvs} -q ci -m add-file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d7948 14
a7961 1
Checking in file1;
d7963 1
a7963 1
initial revision: 1\.1
a7964 1
	  mkdir sdir
d7966 10
a7975 2
	  dotest errmsg2-8 "${testcvs} add first-dir/sdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"
d7977 6
a7982 10
	  cd first-dir

	  touch file10
	  mkdir sdir10
	  dotest errmsg2-10 "${testcvs} add file10 sdir10" \
"${PROG} [a-z]*: scheduling file .file10. for addition
Directory ${TESTDIR}/cvsroot/first-dir/sdir10 added to the repository
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest errmsg2-11 "${testcvs} -q ci -m add-file10" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file10,v
d7984 2
a7985 7
Checking in file10;
${TESTDIR}/cvsroot/first-dir/file10,v  <--  file10
initial revision: 1\.1
done"
	  # Try to see that there are no droppings left by
	  # any of the previous tests.
	  dotest errmsg2-12 "${testcvs} -q update" ""
d7987 10
a7996 2
	  # Now test adding files with '/' in the name, both one level
	  # down and more than one level down.
d7998 3
a8000 3
	  mkdir first-dir/sdir10/ssdir
	  dotest errmsg2-13 "${testcvs} add first-dir/sdir10/ssdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir10/ssdir added to the repository"
d8002 3
a8004 9
	  touch first-dir/sdir10/ssdir/ssfile
	  dotest errmsg2-14 \
	    "${testcvs} add first-dir/sdir10/ssdir/ssfile" \
"${PROG} [a-z]*: scheduling file .first-dir/sdir10/ssdir/ssfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  touch first-dir/file15
	  dotest errmsg2-15 "${testcvs} add first-dir/file15" \
"${PROG} [a-z]*: scheduling file .first-dir/file15. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d8006 4
a8009 14
	  # Now the case where we try to give it a directory which is not
	  # under CVS control.
	  mkdir bogus-dir
	  touch bogus-dir/file16
	  # The first message, from local CVS, is nice.  The second one
	  # is not nice; would be good to fix remote CVS to give a clearer
	  # message (e.g. the one from local CVS).  But at least it is an
	  # error message.
	  dotest_fail errmsg2-16 "${testcvs} add bogus-dir/file16" \
"${PROG} [a-z]*: in directory bogus-dir:
${PROG} \[[a-z]* aborted\]: there is no version here; do .${PROG} checkout. first" \
"${PROG} [a-z]*: cannot open CVS/Entries for reading: No such file or directory
${PROG} \[add aborted\]: no repository"
	  rm -r bogus-dir
d8011 7
a8017 5
	  # One error condition we don't test for is trying to add a file
	  # or directory which already is there.

	  dotest errmsg2-17 "${testcvs} -q ci -m checkin" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file15,v
d8019 7
a8025 3
Checking in first-dir/file15;
${TESTDIR}/cvsroot/first-dir/file15,v  <--  file15
initial revision: 1\.1
d8027 7
a8033 1
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir10/ssdir/ssfile,v
d8035 2
a8036 4
Checking in first-dir/sdir10/ssdir/ssfile;
${TESTDIR}/cvsroot/first-dir/sdir10/ssdir/ssfile,v  <--  ssfile
initial revision: 1\.1
done"
d8039 3
a8041 2
	  rm -r 1
	  rm -rf ${TESTDIR}/cvsroot/first-dir
d8044 5
a8048 1
	devcom)
d8052 1
a8052 5
	  if ${testcvs} -q co first-dir >>${LOGFILE} ; then
	      pass 169
	  else
	      fail 169
	  fi
a8054 28
	  echo abb >abb
	  if ${testcvs} add abb 2>>${LOGFILE}; then
	      pass 170
	  else
	      fail 170
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	      pass 171
	  else
	      fail 171
	  fi
	  dotest_fail 171a0 "${testcvs} watch" "Usage${DOTSTAR}"
	  if ${testcvs} watch on; then
	      pass 172
	  else
	      fail 172
	  fi
	  echo abc >abc
	  if ${testcvs} add abc 2>>${LOGFILE}; then
	      pass 173
	  else
	      fail 173
	  fi
	  if ${testcvs} ci -m added >>${LOGFILE} 2>&1; then
	      pass 174
	  else
	      fail 174
	  fi
d8056 6
a8061 3
	  cd ../..
	  mkdir 2
	  cd 2
d8063 10
a8072 16
	  if ${testcvs} -q co first-dir >>${LOGFILE}; then
	      pass 175
	  else
	      fail 175
	  fi
	  cd first-dir
	  if test -w abb; then
	      fail 176
	  else
	      pass 176
	  fi
	  if test -w abc; then
	      fail 177
	  else
	      pass 177
	  fi
d8074 6
a8079 11
	  if ${testcvs} editors >../ans178.tmp; then
	      pass 178
	  else
	      fail 178
	  fi
	  cat ../ans178.tmp >>${LOGFILE}
	  if test -s ../ans178.tmp; then
	      fail 178a
	  else
	      pass 178a
	  fi
d8081 3
a8083 5
	  if ${testcvs} edit abb; then
	      pass 179
	  else
	      fail 179
	  fi
d8085 8
a8092 11
	  if ${testcvs} editors >../ans180.tmp; then
	      pass 180
	  else
	      fail 180
	  fi
	  cat ../ans180.tmp >>${LOGFILE}
	  if test -s ../ans180.tmp; then
	      pass 181
	  else
	      fail 181
	  fi
d8094 9
a8102 8
	  echo aaaa >>abb
	  if ${testcvs} ci -m modify abb >>${LOGFILE} 2>&1; then
	      pass 182
	  else
	      fail 182
	  fi
	  # Unedit of a file not being edited should be a noop.
	  dotest 182.5 "${testcvs} unedit abb" ''
d8104 4
a8107 11
	  if ${testcvs} editors >../ans183.tmp; then
	      pass 183
	  else
	      fail 183
	  fi
	  cat ../ans183.tmp >>${LOGFILE}
	  if test -s ../ans183.tmp; then
	      fail 184
	  else
	      pass 184
	  fi
d8109 11
a8119 5
	  if test -w abb; then
	      fail 185
	  else
	      pass 185
	  fi
d8121 8
a8128 39
	  if ${testcvs} edit abc; then
	      pass 186a1
	  else
	      fail 186a1
	  fi
	  # Unedit of an unmodified file.
	  if ${testcvs} unedit abc; then
	      pass 186a2
	  else
	      fail 186a2
	  fi
	  if ${testcvs} edit abc; then
	      pass 186a3
	  else
	      fail 186a3
	  fi
	  echo changedabc >abc
	  # Try to unedit a modified file; cvs should ask for confirmation
	  if (echo no | ${testcvs} unedit abc) >>${LOGFILE}; then
	      pass 186a4
	  else
	      fail 186a4
	  fi
	  if echo changedabc | cmp - abc; then
	      pass 186a5
	  else
	      fail 186a5
	  fi
	  # OK, now confirm the unedit
	  if (echo yes | ${testcvs} unedit abc) >>${LOGFILE}; then
	      pass 186a6
	  else
	      fail 186a6
	  fi
	  if echo abc | cmp - abc; then
	      pass 186a7
	  else
	      fail 186a7
	  fi
d8130 15
a8144 1
	  dotest devcom-a0 "${testcvs} watchers" ''
d8146 6
a8151 3
	  # FIXME: This probably should be an error message instead
	  # of silently succeeding and printing nothing.
	  dotest devcom-a-nonexist "${testcvs} watchers nonexist" ''
d8153 1
a8153 7
	  dotest devcom-a1 "${testcvs} watch add" ''
	  dotest devcom-a2 "${testcvs} watchers" \
"abb	${username}	edit	unedit	commit
abc	${username}	edit	unedit	commit"
	  dotest devcom-a3 "${testcvs} watch remove -a unedit abb" ''
	  dotest devcom-a4 "${testcvs} watchers abb" \
"abb	${username}	edit	commit"
d8155 6
a8160 8
	  # Check tagging and checking out while we have a CVS
	  # directory in the repository.
	  dotest devcom-t0 "${testcvs} -q tag tag" \
'T abb
T abc'
	  cd ../..
	  mkdir 3
	  cd 3
d8162 1
a8162 5
	  # Test commented out because the bug it tests for is not fixed
	  # The error is:
	  # cvs watchers: cannot open CVS/Entries for reading: No such file or directory
	  # cvs: ../../work/ccvs/src/fileattr.c:75: fileattr_read: Assertion `fileattr_stored_repos != ((void *)0)' failed.
:	  dotest devcom-t-nonexist "${testcvs} watchers nonexist" fixme
d8164 6
a8169 5
	  dotest devcom-t1 "${testcvs} -q co -rtag first-dir/abb" \
'U first-dir/abb'
	  cd ..
	  # Since first-dir/abb is readonly, use -f.
	  rm -rf 3
d8171 1
a8171 9
	  # Test checking out the directory rather than the file.
	  mkdir 3
	  cd 3
	  dotest devcom-t2 "${testcvs} -q co -rtag first-dir" \
'U first-dir/abb
U first-dir/abc'
	  cd ..
	  # Since the files are readonly, use -f.
	  rm -rf 3
d8173 6
a8178 12
	  # Now do it again, after removing the val-tags file created
	  # by devcom-t1 to force CVS to search the repository
	  # containing CVS directories.
	  rm ${CVSROOT_DIRNAME}/CVSROOT/val-tags
	  mkdir 3
	  cd 3
	  dotest devcom-t3 "${testcvs} -q co -rtag first-dir" \
'U first-dir/abb
U first-dir/abc'
	  cd ..
	  # Since the files are readonly, use -f.
	  rm -rf 3
d8180 36
a8215 6
	  # Now remove all the file attributes
	  cd 2/first-dir
	  dotest devcom-b0 "${testcvs} watch off" ''
	  dotest devcom-b1 "${testcvs} watch remove" ''
	  # Test that CVS 1.6 and earlier can handle the repository.
	  dotest_fail devcom-b2 "test -d ${CVSROOT_DIRNAME}/first-dir/CVS"
d8217 1
a8217 10
	  # Now test watching just some, not all, files.
	  dotest devcom-some0 "${testcvs} watch on abc" ''
	  cd ../..
	  mkdir 3
	  cd 3
	  dotest devcom-some1 "${testcvs} -q co first-dir" 'U first-dir/abb
U first-dir/abc'
	  dotest devcom-some2 "test -w first-dir/abb" ''
	  dotest_fail devcom-some3 "test -w first-dir/abc" ''
	  cd ..
d8219 12
a8230 4
	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi
d8232 11
a8242 4
	  # Use -f because of the readonly files.
	  rm -rf 1 2 3
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d8244 10
a8253 8
	devcom2)
	  # More watch tests, most notably setting watches on
	  # files in various different states.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest devcom2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
d8255 8
a8262 4
	  # This should probably be an error; setting a watch on a totally
	  # unknown file is more likely to be a typo than intentional.
	  # But that isn't the currently implemented behavior.
	  dotest devcom2-2 "${testcvs} watch on w1" ''
d8264 8
a8271 8
	  touch w1 w2 w3 nw1
	  dotest devcom2-3 "${testcvs} add w1 w2 w3 nw1" "${DOTSTAR}"
	  # Letting the user set the watch here probably can be considered
	  # a feature--although it leads to a few potentially strange
	  # consequences like one user can set the watch and another actually
	  # adds the file.
	  dotest devcom2-4 "${testcvs} watch on w2" ''
	  dotest devcom2-5 "${testcvs} -q ci -m add-them" "${DOTSTAR}"
d8273 9
a8281 4
	  # Note that this test differs in a subtle way from devcom-some0;
	  # in devcom-some0 the watch is creating a new fileattr file, and
	  # here we are modifying an existing one.
	  dotest devcom2-6 "${testcvs} watch on w3" ''
d8283 11
a8293 18
	  # Now test that all the watches got set on the correct files
	  # FIXME: CVS should have a way to report whether watches are
	  # set, I think.  The "check it out and see if it read-only" is
	  # sort of OK, but is complicated by CVSREAD and doesn't help
	  # if the file is added and not yet committed or some such.
	  # Probably "cvs status" should report "watch: on" if watch is on
	  # (and nothing if watch is off, so existing behavior is preserved).
	  cd ../..
	  mkdir 2
	  cd 2
	  dotest devcom2-7 "${testcvs} -q co first-dir" 'U first-dir/nw1
U first-dir/w1
U first-dir/w2
U first-dir/w3'
	  dotest devcom2-8 "test -w first-dir/nw1" ''
	  dotest_fail devcom2-9 "test -w first-dir/w1" ''
	  dotest_fail devcom2-10 "test -w first-dir/w2" ''
	  dotest_fail devcom2-11 "test -w first-dir/w3" ''
d8295 8
a8302 18
	  cd first-dir
	  # OK, now we want to try files in various states with cvs edit.
	  dotest devcom2-12 "${testcvs} edit w4" \
"${PROG} edit: no such file w4; ignored"
	  # Try the same thing with a per-directory watch set.
	  dotest devcom2-13 "${testcvs} watch on" ''
	  dotest devcom2-14 "${testcvs} edit w5" \
"${PROG} edit: no such file w5; ignored"
	  dotest devcom2-15 "${testcvs} editors" ''
	  dotest devcom2-16 "${testcvs} editors w4" ''
	  # Make sure there are no droppings lying around
	  dotest devcom2-17 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw1	_watched=
Fw2	_watched=
Fw3	_watched=
Fnw1	_watched=
D	_watched="
	  cd ..
d8304 10
a8313 1
	  cd ..
d8315 9
a8323 4
	  # Use -f because of the readonly files.
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d8325 9
a8333 8
	devcom3)
	  # More watch tests, most notably handling of features designed
	  # for future expansion.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest devcom3-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
d8335 9
a8343 4
	  touch w1 w2
	  dotest devcom3-2 "${testcvs} add w1 w2" "${DOTSTAR}"
	  dotest devcom3-3 "${testcvs} watch on w1 w2" ''
	  dotest devcom3-4 "${testcvs} -q ci -m add-them" "${DOTSTAR}"
d8345 119
a8463 20
	  # OK, since we are about to delve into CVS's internals, make
	  # sure that we seem to be correct about how they work.
	  dotest devcom3-5 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw1	_watched=
Fw2	_watched="
	  # Now write a few more lines, just as if we were a newer version
	  # of CVS implementing some new feature.
	  cat <<EOF >>${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
Enew	line	here
G@@#$^!@@#=&
EOF
	  # Now get CVS to write to the fileattr file....
	  dotest devcom3-6 "${testcvs} watch off w1" ''
	  # ...and make sure that it hasn't clobbered our new lines.
	  # Note that writing these lines in another order would be OK
	  # too.
	  dotest devcom3-7 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw2	_watched=
G@@#..!@@#=&
Enew	line	here"
d8465 22
a8486 14
	  # See what CVS does when a file name is duplicated.  The
	  # behavior of all versions of CVS since file attributes were
	  # implemented is that it nukes the duplications.  This seems
	  # reasonable enough, although it means it isn't clear how
	  # useful duplicates would be for purposes of future
	  # expansion.  But in the interests of keeping behaviors
	  # predictable, might as well test for it, I guess.
	  echo 'Fw2	duplicate=' >>${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
	  dotest devcom3-8 "${testcvs} watch on w1" ''
	  dotest devcom3-9 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw2	_watched=
Fw1	_watched=
Enew	line	here
G@@#..!@@#=&"
d8488 1
a8488 1
	  cd ../..
d8490 3
a8492 2
	  # Use -f because of the readonly files.
	  rm -rf 1
d8494 1
d8497 2
a8498 2
	watch4)
	  # More watch tests, including adding directories.
d8500 1
a8500 1
	  dotest watch4-0a "${testcvs} -q co -l ." ''
d8502 1
a8502 1
	  dotest watch4-0b "${testcvs} add first-dir" \
a8503 1

d8505 8
a8512 4
	  dotest watch4-1 "${testcvs} watch on" ''
	  # This is just like the 173 test
	  touch file1
	  dotest watch4-2 "${testcvs} add file1" \
d8515 1
a8515 1
	  dotest watch4-3 "${testcvs} -q ci -m add" \
d8522 5
a8526 26
	  # Now test the analogous behavior for directories.
	  mkdir subdir
	  dotest watch4-4 "${testcvs} add subdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"
	  cd subdir
	  touch sfile
	  dotest watch4-5 "${testcvs} add sfile" \
"${PROG} [a-z]*: scheduling file .sfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest watch4-6 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/sfile,v
done
Checking in sfile;
${TESTDIR}/cvsroot/first-dir/subdir/sfile,v  <--  sfile
initial revision: 1\.1
done"
	  cd ../../..
	  mkdir 2; cd 2
	  dotest watch4-7 "${testcvs} -q co first-dir" "U first-dir/file1
U first-dir/subdir/sfile"
	  dotest_fail watch4-8 "test -w first-dir/file1" ''
	  dotest_fail watch4-9 "test -w first-dir/subdir/sfile" ''
	  cd first-dir
	  dotest watch4-10 "${testcvs} edit file1" ''
	  echo 'edited in 2' >file1
	  cd ../..
d8528 6
a8533 4
	  cd 1/first-dir
	  dotest watch4-11 "${testcvs} edit file1" ''
	  echo 'edited in 1' >file1
	  dotest watch4-12 "${testcvs} -q ci -m edit-in-1" \
d8538 67
d8606 1
a8606 30
	  cd 2/first-dir
	  dotest watch4-13 "${testcvs} -q update" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into file1
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in file1
C file1"
	  if (echo yes | ${testcvs} unedit file1) >>${LOGFILE}; then
	    pass watch4-14
	  else
	    fail watch4-15
	  fi
	  # This could plausibly be defined to either go back to the revision
	  # which was cvs edit'd (the status quo), or back to revision 1.2
	  # (that is, the merge could update CVS/Base/file1).  We pick the
	  # former because it is easier to implement, not because we have
	  # thought much about which is better.
	  dotest watch4-16 "cat file1" ''
	  # Make sure CVS really thinks we are at 1.1.
	  dotest watch4-17 "${testcvs} -q update" "U file1"
	  dotest watch4-18 "cat file1" "edited in 1"
	  cd ../..

	  # As a sanity check, make sure we are in the right place.
	  dotest watch4-cleanup-1 "test -d 1" ''
	  dotest watch4-cleanup-1 "test -d 2" ''
	  # Specify -f because of the readonly files.
	  rm -rf 1 2
d8610 3
a8612 5
	ignore)
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt
d8614 4
a8617 5
	  dotest 187a1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
	  cd CVSROOT
	  echo rootig.c >cvsignore
	  dotest 187a2 "${testcvs} add cvsignore" "${PROG}"' [a-z]*: scheduling file `cvsignore'"'"' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d8619 5
a8623 11
	  # As of Jan 96, local CVS prints "Examining ." and remote doesn't.
	  # Accept either.
	  dotest 187a3 " ${testcvs} ci -m added" \
"${PROG} [a-z]*: Examining \.
RCS file: ${TESTDIR}/cvsroot/CVSROOT/cvsignore,v
done
Checking in cvsignore;
${TESTDIR}/cvsroot/CVSROOT/cvsignore,v  <--  cvsignore
initial revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
d8625 5
a8629 6
	  cd ..
	  if echo "yes" | ${testcvs} release -d CVSROOT >>${LOGFILE} ; then
	      pass 187a4
	  else
	      fail 187a4
	  fi
d8631 4
a8634 11
	  # CVS looks at the home dir from getpwuid, not HOME (is that correct
	  # behavior?), so this is hard to test and we won't try.
	  # echo foobar.c >${HOME}/.cvsignore
	  CVSIGNORE=envig.c; export CVSIGNORE
	  mkdir dir-to-import
	  cd dir-to-import
	  touch foobar.c bar.c rootig.c defig.o envig.c optig.c
	  # We use sort because we can't predict the order in which
	  # the files will be listed.
	  dotest_sort 188a "${testcvs} import -m m -I optig.c first-dir tag1 tag2" \
'
d8636 19
a8654 9
I first-dir/defig.o
I first-dir/envig.c
I first-dir/optig.c
I first-dir/rootig.c
N first-dir/bar.c
N first-dir/foobar.c
No conflicts created by this import'
	  dotest_sort 188b "${testcvs} import -m m -I ! second-dir tag3 tag4" \
'
d8656 1
a8656 9
N second-dir/bar.c
N second-dir/defig.o
N second-dir/envig.c
N second-dir/foobar.c
N second-dir/optig.c
N second-dir/rootig.c
No conflicts created by this import'
	  cd ..
	  rm -r dir-to-import
d8658 6
a8663 22
	  mkdir 1
	  cd 1
	  dotest 189a "${testcvs} -q co second-dir" \
'U second-dir/bar.c
U second-dir/defig.o
U second-dir/envig.c
U second-dir/foobar.c
U second-dir/optig.c
U second-dir/rootig.c'
	  dotest 189b "${testcvs} -q co first-dir" 'U first-dir/bar.c
U first-dir/foobar.c'
	  cd first-dir
	  touch rootig.c defig.o envig.c optig.c notig.c
	  dotest 189c "${testcvs} -q update -I optig.c" "${QUESTION} notig.c"
	  # The fact that CVS requires us to specify -I CVS here strikes me
	  # as a bug.
	  dotest_sort 189d "${testcvs} -q update -I ! -I CVS" \
"${QUESTION} defig.o
${QUESTION} envig.c
${QUESTION} notig.c
${QUESTION} optig.c
${QUESTION} rootig.c"
d8665 1
a8665 15
	  # Now test that commands other than update also print "? notig.c"
	  # where appropriate.  Only test this for remote, because local
	  # CVS only prints it on update.
	  rm optig.c
	  if test "x$remote" = xyes; then
	    dotest 189e "${testcvs} -q diff" "${QUESTION} notig.c"

	    # Force the server to be contacted.  Ugh.  Having CVS
	    # contact the server for the sole purpose of checking
	    # the CVSROOT/cvsignore file does not seem like such a
	    # good idea, so I imagine this will continue to be
	    # necessary.  Oh well, at least we test CVS's ablity to
	    # handle a file with a modified timestamp but unmodified
	    # contents.
	    touch bar.c
a8666 1
	    dotest 189f "${testcvs} -q ci -m commit-it" "${QUESTION} notig.c"
d8669 7
a8675 16
	  # now test .cvsignore files
	  cd ..
	  echo notig.c >first-dir/.cvsignore
	  echo foobar.c >second-dir/.cvsignore
	  touch first-dir/notig.c second-dir/notig.c second-dir/foobar.c
	  dotest_sort 190 "${testcvs} -qn update" \
"${QUESTION} first-dir/.cvsignore
${QUESTION} second-dir/.cvsignore
${QUESTION} second-dir/notig.c"
	  dotest_sort 191 "${testcvs} -qn update -I! -I CVS" \
"${QUESTION} first-dir/.cvsignore
${QUESTION} first-dir/defig.o
${QUESTION} first-dir/envig.c
${QUESTION} first-dir/rootig.c
${QUESTION} second-dir/.cvsignore
${QUESTION} second-dir/notig.c"
d8677 27
a8703 10
	  if echo yes | ${testcvs} release -d first-dir \
	    >${TESTDIR}/ignore.tmp; then
	    pass ignore-192
	  else
	    fail ignore-192
	  fi
	  dotest ignore-193 "cat ${TESTDIR}/ignore.tmp" \
"${QUESTION} \.cvsignore
You have \[0\] altered files in this repository.
Are you sure you want to release (and delete) directory .first-dir': "
d8705 20
a8724 13
	  echo add a line >>second-dir/foobar.c
	  rm second-dir/notig.c second-dir/.cvsignore
	  if echo yes | ${testcvs} release -d second-dir \
	    >${TESTDIR}/ignore.tmp; then
	    pass ignore-194
	  else
	    fail ignore-194
	  fi
	  dotest ignore-195 "cat ${TESTDIR}/ignore.tmp" \
"M foobar.c
You have \[1\] altered files in this repository.
Are you sure you want to release (and delete) directory .second-dir': "
	  cd ..
a8725 5
	  cd ..
	  rm -r wnt
	  rm ${TESTDIR}/ignore.tmp
	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${CVSROOT_DIRNAME}/second-dir
	  ;;
a8726 3
	binfiles)
	  # Test cvs's ability to handle binary files.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
d8728 11
a8738 11
	  dotest binfiles-1 "${testcvs} -q co first-dir" ''
	  awk 'BEGIN { printf "%c%c%c%c%c%c", 2, 10, 137, 0, 13, 10 }' \
	    </dev/null >binfile.dat
	  cat binfile.dat binfile.dat >binfile2.dat
	  cd first-dir
	  cp ../binfile.dat binfile
	  dotest binfiles-2 "${testcvs} add -kb binfile" \
"${PROG}"' [a-z]*: scheduling file `binfile'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest binfiles-3 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
d8740 2
a8741 2
Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
d8745 9
a8753 10
	  mkdir 2; cd 2
	  dotest binfiles-4 "${testcvs} -q co first-dir" 'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-5 "cmp ../../1/binfile.dat binfile" ''
	  # Testing that sticky options is -kb is the closest thing we have
	  # to testing that binary files work right on non-unix machines
	  # (until there is automated testing for such machines, of course).
	  dotest binfiles-5.5 "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
d8755 21
a8775 5
   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
d8777 1
a8777 11
	  # Test whether the default options from the RCS file are
	  # also used when operating on files instead of whole
	  # directories
          cd ../..
	  mkdir 3; cd 3
	  dotest binfiles-5.5b0 "${testcvs} -q co first-dir/binfile" \
'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-5.5b1 "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
d8779 3
a8781 8
   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  cd ../..
	  rm -r 3
	  cd 2/first-dir
d8783 5
a8787 9
	  cp ../../1/binfile2.dat binfile
	  dotest binfiles-6 "${testcvs} -q ci -m modify-it" \
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../../1/first-dir
	  dotest binfiles-7 "${testcvs} -q update" '[UP] binfile'
	  dotest binfiles-8 "cmp ../binfile2.dat binfile" ''
d8789 1
a8789 17
	  # Now test handling of conflicts with binary files.
	  cp ../binfile.dat binfile
	  dotest binfiles-con0 "${testcvs} -q ci -m modify-it" \
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.3; previous revision: 1\.2
done"
	  cd ../../2/first-dir
	  echo 'edits in dir 2' >binfile
	  dotest binfiles-con1 "${testcvs} -q update" \
"U binfile
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.3 from repository is now in binfile
${PROG} [a-z]*: file from working directory is now in \.#binfile\.1\.2
C binfile"
	  dotest binfiles-con2 "cmp binfile ../../1/binfile.dat" ''
	  dotest binfiles-con3 "cat .#binfile.1.2" 'edits in dir 2'
d8791 1
a8791 8
	  cp ../../1/binfile2.dat binfile
	  dotest binfiles-con4 "${testcvs} -q ci -m resolve-it" \
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.4; previous revision: 1\.3
done"
	  cd ../../1/first-dir
	  dotest binfiles-con5 "${testcvs} -q update" '[UP] binfile'
d8793 16
a8808 5
	  dotest binfiles-9 "${testcvs} -q update -A" ''
	  dotest binfiles-10 "${testcvs} -q update -kk" '[UP] binfile'
	  dotest binfiles-11 "${testcvs} -q update" ''
	  dotest binfiles-12 "${testcvs} -q update -A" '[UP] binfile'
	  dotest binfiles-13 "${testcvs} -q update -A" ''
d8810 6
a8815 2
	  cd ../..
	  rm -r 1
a8816 8
	  mkdir 3
	  cd 3
	  dotest binfiles-13a0 "${testcvs} -q co -r HEAD first-dir" \
'U first-dir/binfile'
	  cd first-dir
	  dotest binfiles-13a1 "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
d8818 4
a8821 7
   Working revision:	1\.4.*
   Repository revision:	1\.4	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		HEAD (revision: 1\.4)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  cd ../..
	  rm -r 3
d8823 4
a8826 12
	  cd 2/first-dir
	  echo 'this file is $''RCSfile$' >binfile
	  dotest binfiles-14a "${testcvs} -q ci -m modify-it" \
"Checking in binfile;
${TESTDIR}/cvsroot/first-dir/binfile,v  <--  binfile
new revision: 1\.5; previous revision: 1\.4
done"
	  dotest binfiles-14b "cat binfile" 'this file is $''RCSfile$'
	  # See binfiles-5.5 for discussion of -kb.
	  dotest binfiles-14c "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
d8828 4
a8831 16
   Working revision:	1\.5.*
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  dotest binfiles-14d "${testcvs} admin -kv binfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
done"
	  # cvs admin doesn't change the checked-out file or its sticky
	  # kopts.  There probably should be a way which does (but
	  # what if the file is modified?  And do we try to version
	  # control the kopt setting?)
	  dotest binfiles-14e "cat binfile" 'this file is $''RCSfile$'
	  dotest binfiles-14f "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
a8832 10
   Working revision:	1\.5.*
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  dotest binfiles-14g "${testcvs} -q update -A" '[UP] binfile'
	  dotest binfiles-14h "cat binfile" 'this file is binfile,v'
	  dotest binfiles-14i "${testcvs} status binfile" \
"===================================================================
File: binfile          	Status: Up-to-date
d8834 3
a8836 5
   Working revision:	1\.5.*
   Repository revision:	1\.5	${TESTDIR}/cvsroot/first-dir/binfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kv"
a8837 16
	  # Do sticky options work when used with 'cvs update'?
	  echo "Not a binary file." > nibfile
	  dotest binfiles-sticky1 "${testcvs} -q add nibfile" \
"${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest binfiles-sticky2 "${testcvs} -q ci -m add-it nibfile" \
	    "RCS file: ${TESTDIR}/cvsroot/first-dir/nibfile,v
done
Checking in nibfile;
${TESTDIR}/cvsroot/first-dir/nibfile,v  <--  nibfile
initial revision: 1\.1
done"
	  dotest binfiles-sticky3 "${testcvs} -q update -kb nibfile" \
	    '[UP] nibfile'
	  dotest binfiles-sticky4 "${testcvs} -q status nibfile" \
"===================================================================
File: nibfile          	Status: Up-to-date
d8839 18
a8856 5
   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
a8857 6
	  # Now test that -A can clear the sticky option.
	  dotest binfiles-sticky5 "${testcvs} -q update -A nibfile" \
"[UP] nibfile"
	  dotest binfiles-sticky6 "${testcvs} -q status nibfile" \
"===================================================================
File: nibfile          	Status: Up-to-date
d8859 11
a8869 12
   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
	  dotest binfiles-15 "${testcvs} -q admin -kb nibfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/nibfile,v
done"
	  dotest binfiles-16 "${testcvs} -q update nibfile" "[UP] nibfile"
	  dotest binfiles-17 "${testcvs} -q status nibfile" \
"===================================================================
File: nibfile          	Status: Up-to-date
a8870 5
   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/first-dir/nibfile,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
d8872 13
a8884 13
	  dotest binfiles-o1 "${testcvs} admin -o1.3:: binfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
deleting revision 1\.5
deleting revision 1\.4
done"
	  dotest binfiles-o2 "${testcvs} admin -o::1.3 binfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
deleting revision 1\.2
deleting revision 1\.1
done"
	  dotest binfiles-o3 "${testcvs} -q log -h -N binfile" "
RCS file: ${TESTDIR}/cvsroot/first-dir/binfile,v
Working file: binfile
d8889 17
a8905 2
keyword substitution: v
total revisions: 1
d8908 5
a8912 4
	  cd ../..
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 2
	  ;;
d8914 19
a8932 18
	binfiles2)
	  # Test cvs's ability to handle binary files, particularly branching
	  # and joining.  The key thing we are worrying about is that CVS
	  # doesn't print "cannot merge binary files" or some such, in 
	  # situations where no merging is required.
	  # See also "join" which does this with non-binary files.
	  #
	  # Cases (we are merging from the branch to the trunk):
	  # binfile.dat) File added on branch, not on trunk.
	  #      File should be marked for addition.
	  # brmod) File modified on branch, not on trunk.
	  #      File should be copied over to trunk (no merging is needed).
	  # brmod-trmod) File modified on branch, also on trunk.
	  #      This is a conflict.  Present the user with both files and
	  #      let them figure it out.
	  # brmod-wdmod) File modified on branch, not modified in the trunk
	  #      repository, but modified in the (trunk) working directory.
	  #      This is also a conflict.
d8934 27
a8960 4
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest binfiles2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
d8962 37
a8998 8
	  # The most important thing here is that binfile, binfile2, &c
	  # each be distinct from each other.  We also make sure to include
	  # a few likely end-of-line patterns to make sure nothing is
	  # being munged as if in text mode.
	  awk 'BEGIN { printf "%c%c%c%c%c%c", 2, 10, 137, 0, 13, 10 }' \
	    </dev/null >../binfile
	  cat ../binfile ../binfile >../binfile2
	  cat ../binfile2 ../binfile >../binfile3
d9000 3
a9002 30
	  # FIXCVS: unless a branch has at least one file on it,
	  # tag_check_valid won't know it exists.  So if brmod didn't
	  # exist, we would have to invent it.
	  cp ../binfile brmod
	  cp ../binfile brmod-trmod
	  cp ../binfile brmod-wdmod
	  dotest binfiles2-1a \
"${testcvs} add -kb brmod brmod-trmod brmod-wdmod" \
"${PROG} [a-z]*: scheduling file .brmod. for addition
${PROG} [a-z]*: scheduling file .brmod-trmod. for addition
${PROG} [a-z]*: scheduling file .brmod-wdmod. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest binfiles2-1b "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod,v
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
initial revision: 1\.1
d9004 21
a9024 44
	  dotest binfiles2-2 "${testcvs} -q tag -b br" 'T brmod
T brmod-trmod
T brmod-wdmod'
	  dotest binfiles2-3 "${testcvs} -q update -r br" ''
	  cp ../binfile binfile.dat
	  dotest binfiles2-4 "${testcvs} add -kb binfile.dat" \
"${PROG} [a-z]*: scheduling file .binfile\.dat. for addition on branch .br.
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  cp ../binfile2 brmod
	  cp ../binfile2 brmod-trmod
	  cp ../binfile2 brmod-wdmod
	  dotest binfiles2-5 "${testcvs} -q ci -m br-changes" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/binfile\.dat,v
done
Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/Attic/binfile\.dat,v  <--  binfile\.dat
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest binfiles2-6 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: binfile\.dat is not (any longer) pertinent
[UP] brmod
[UP] brmod-trmod
[UP] brmod-wdmod"
	  dotest_fail binfiles2-7 "test -f binfile.dat" ''
	  dotest binfiles2-7-brmod "cmp ../binfile brmod"
	  cp ../binfile3 brmod-trmod
	  dotest binfiles2-7a "${testcvs} -q ci -m tr-modify" \
"Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.2; previous revision: 1\.1
done"
	  cp ../binfile3 brmod-wdmod
d9026 4
a9029 12
	  dotest binfiles2-8 "${testcvs} -q update -j br" \
"U binfile\.dat
U brmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-trmod
${PROG} [a-z]*: file from working directory is now in .#brmod-trmod.1.2
C brmod-trmod
M brmod-wdmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-wdmod
${PROG} [a-z]*: file from working directory is now in .#brmod-wdmod.1.1
C brmod-wdmod"
d9031 4
a9034 6
	  dotest binfiles2-9 "cmp ../binfile binfile.dat"
	  dotest binfiles2-9-brmod "cmp ../binfile2 brmod"
	  dotest binfiles2-9-brmod-trmod "cmp ../binfile2 brmod-trmod"
	  dotest binfiles2-9-brmod-trmod "cmp ../binfile2 brmod-wdmod"
	  dotest binfiles2-9a-brmod-trmod "cmp ../binfile3 .#brmod-trmod.1.2"
	  dotest binfiles2-9a-brmod-wdmod "cmp ../binfile3 .#brmod-wdmod.1.1"
d9036 5
a9040 18
	  # Test that everything was properly scheduled.
	  dotest binfiles2-10 "${testcvs} -q ci -m checkin" \
"Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/binfile\.dat,v  <--  binfile\.dat
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.3; previous revision: 1\.2
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.2; previous revision: 1\.1
done"
d9042 5
a9046 31
	  dotest_fail binfiles2-o1 "${testcvs} -q admin -o :1.2 brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.2
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v: can't remove branch point 1\.1
${PROG} [a-z]*: cannot modify RCS file for .brmod-trmod."
	  dotest binfiles2-o2 "${testcvs} -q admin -o 1.1.2.1: brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.1\.2\.1
done"
	  dotest binfiles2-o3 "${testcvs} -q admin -o :1.2 brmod-trmod" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
deleting revision 1\.2
deleting revision 1\.1
done"
	  dotest binfiles2-o4 "${testcvs} -q log -N brmod-trmod" "
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
Working file: brmod-trmod
head: 1\.3
branch:
locks: strict
access list:
keyword substitution: b
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
checkin
============================================================================="
	  cd ..
	  cd ..
d9048 4
a9051 3
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1
	  ;;
a9052 16
	mcopy)
	  # See comment at "mwrap" test for list of other wrappers tests.
	  # Test cvs's ability to handle nonmergeable files specified with
	  # -m 'COPY' in wrappers.  Similar to the binfiles2 test,
	  # which tests the same thing for binary files
	  # (which are non-mergeable in the same sense).
	  #
	  # Cases (we are merging from the branch to the trunk):
	  # brmod) File modified on branch, not on trunk.
	  #      File should be copied over to trunk (no merging is needed).
	  # brmod-trmod) File modified on branch, also on trunk.
	  #      This is a conflict.  Present the user with both files and
	  #      let them figure it out.
	  # brmod-wdmod) File modified on branch, not modified in the trunk
	  #      repository, but modified in the (trunk) working directory.
	  #      This is also a conflict.
d9054 2
a9055 3
	  # For the moment, remote CVS can't pass wrappers from CVSWRAPPERS
	  # (see wrap_send).  So skip these tests for remote.
	  if test "x$remote" = xno; then
a9056 4
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest mcopy-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
d9058 7
a9064 39
	  # FIXCVS: unless a branch has at least one file on it,
	  # tag_check_valid won't know it exists.  So if brmod didn't
	  # exist, we would have to invent it.
	  echo 'brmod initial contents' >brmod
	  echo 'brmod-trmod initial contents' >brmod-trmod
	  echo 'brmod-wdmod initial contents' >brmod-wdmod
	  echo "* -m 'COPY'" >.cvswrappers
	  dotest mcopy-1a \
"${testcvs} add .cvswrappers brmod brmod-trmod brmod-wdmod" \
"${PROG} [a-z]*: scheduling file .\.cvswrappers. for addition
${PROG} [a-z]*: scheduling file .brmod. for addition
${PROG} [a-z]*: scheduling file .brmod-trmod. for addition
${PROG} [a-z]*: scheduling file .brmod-wdmod. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest mcopy-1b "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/\.cvswrappers,v
done
Checking in \.cvswrappers;
${TESTDIR}/cvsroot/first-dir/\.cvswrappers,v  <--  \.cvswrappers
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod,v
done
Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-trmod,v
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
initial revision: 1\.1
done"
a9065 35
	  # NOTE: .cvswrappers files are broken (see comment in
	  # src/wrapper.c).  So doing everything via the environment
	  # variable is a workaround.  Better would be to test them
	  # both.
	  CVSWRAPPERS="* -m 'COPY'"
	  export CVSWRAPPERS
	  dotest mcopy-2 "${testcvs} -q tag -b br" 'T \.cvswrappers
T brmod
T brmod-trmod
T brmod-wdmod'
	  dotest mcopy-3 "${testcvs} -q update -r br" ''
	  echo 'modify brmod on br' >brmod
	  echo 'modify brmod-trmod on br' >brmod-trmod
	  echo 'modify brmod-wdmod on br' >brmod-wdmod
	  dotest mcopy-5 "${testcvs} -q ci -m br-changes" \
"Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest mcopy-6 "${testcvs} -q update -A" \
"[UP] brmod
[UP] brmod-trmod
[UP] brmod-wdmod"
	  dotest mcopy-7 "cat brmod brmod-trmod brmod-wdmod" \
"brmod initial contents
brmod-trmod initial contents
brmod-wdmod initial contents"
d9067 7
a9073 7
	  echo 'modify brmod-trmod again on trunk' >brmod-trmod
	  dotest mcopy-7a "${testcvs} -q ci -m tr-modify" \
"Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.2; previous revision: 1\.1
done"
	  echo 'modify brmod-wdmod in working dir' >brmod-wdmod
a9074 11
	  dotest mcopy-8 "${testcvs} -q update -j br" \
"U brmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-trmod
${PROG} [a-z]*: file from working directory is now in .#brmod-trmod.1.2
C brmod-trmod
M brmod-wdmod
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1.1.2.1 from repository is now in brmod-wdmod
${PROG} [a-z]*: file from working directory is now in .#brmod-wdmod.1.1
C brmod-wdmod"
d9076 7
a9082 7
	  dotest mcopy-9 "cat brmod brmod-trmod brmod-wdmod" \
"modify brmod on br
modify brmod-trmod on br
modify brmod-wdmod on br"
	  dotest mcopy-9a "cat .#brmod-trmod.1.2 .#brmod-wdmod.1.1" \
"modify brmod-trmod again on trunk
modify brmod-wdmod in working dir"
a9083 16
	  # Test that everything was properly scheduled.
	  dotest mcopy-10 "${testcvs} -q ci -m checkin" \
"Checking in brmod;
${TESTDIR}/cvsroot/first-dir/brmod,v  <--  brmod
new revision: 1\.2; previous revision: 1\.1
done
Checking in brmod-trmod;
${TESTDIR}/cvsroot/first-dir/brmod-trmod,v  <--  brmod-trmod
new revision: 1\.3; previous revision: 1\.2
done
Checking in brmod-wdmod;
${TESTDIR}/cvsroot/first-dir/brmod-wdmod,v  <--  brmod-wdmod
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ..
	  cd ..
d9085 7
a9091 3
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1
	  unset CVSWRAPPERS
a9092 1
	  fi # end of tests to be skipped for remote
d9094 7
a9100 1
	  ;;
a9101 3
	binwrap)
	  # Test the ability to specify binary-ness based on file name.
	  # See "mwrap" for a list of other wrappers tests.
d9103 7
a9109 3
	  mkdir dir-to-import
	  cd dir-to-import
	  touch foo.c foo.exe
d9111 3
a9113 4
	  # While we're here, test for rejection of duplicate tag names.
	  dotest_fail binwrap-0 \
	    "${testcvs} import -m msg -I ! first-dir dup dup" \
"${PROG} \[[a-z]* aborted\]: tag .dup. was specified more than once"
d9115 4
a9118 3
	  if ${testcvs} import -m message -I ! -W "*.exe -k 'b'" \
	      first-dir tag1 tag2 >>${LOGFILE}; then
	    pass binwrap-1
d9120 1
a9120 1
	    fail binwrap-1
a9121 7
	  cd ..
	  rm -r dir-to-import
	  dotest binwrap-2 "${testcvs} -q co first-dir" 'U first-dir/foo.c
U first-dir/foo.exe'
	  dotest binwrap-3 "${testcvs} -q status first-dir" \
"===================================================================
File: foo\.c            	Status: Up-to-date
d9123 7
a9129 5
   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.c,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)
d9131 7
a9137 2
===================================================================
File: foo\.exe          	Status: Up-to-date
d9139 8
a9146 8
   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.exe,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d9148 5
a9152 16
	binwrap2)
	  # Test the ability to specify binary-ness based on file name.
	  # See "mwrap" for a list of other wrappers tests.

	  mkdir dir-to-import
	  cd dir-to-import
	  touch foo.c foo.exe

	  # Specify that all files are binary except *.c.
	  # The order seems to matter, with the earlier rules taking
	  # precedence.  I'm not sure whether that is good or not,
	  # but it is the current behavior.
	  if ${testcvs} import -m message -I ! \
	      -W "*.c -k 'o'" -W "* -k 'b'" \
	      first-dir tag1 tag2 >>${LOGFILE}; then
	    pass binwrap2-1
d9154 1
a9154 1
	    fail binwrap2-1
a9155 7
	  cd ..
	  rm -r dir-to-import
	  dotest binwrap2-2 "${testcvs} -q co first-dir" 'U first-dir/foo.c
U first-dir/foo.exe'
	  dotest binwrap2-3 "${testcvs} -q status first-dir" \
"===================================================================
File: foo\.c            	Status: Up-to-date
d9157 42
a9198 5
   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.c,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-ko
d9200 1
a9200 9
===================================================================
File: foo\.exe          	Status: Up-to-date

   Working revision:	1\.1\.1\.1.*
   Repository revision:	1\.1\.1\.1	${TESTDIR}/cvsroot/first-dir/foo\.exe,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	-kb"
	  rm -r first-dir
d9204 11
a9214 46
        binwrap3)
          # Test communication of file-specified -k wrappers between
          # client and server, in `import':
          #
          #   1. Set up a directory tree, populate it with files.
          #   2. Give each directory a different .cvswrappers file. 
          #   3. Give the server its own .cvswrappers file.
          #   4. Import the whole tree, see if the right files got set
          #      to binary.
          #
          # The tree has a top ("0th") level, and two subdirs, sub1/
          # and sub2/; sub2/ contains directory subsub/.  Every
          # directory has a .cvswrappers file as well as regular
          # files.
          #
          # In the file names, "foo-b.*" should end up binary, and
          # "foo-t.*" should end up text.  Don't worry about the two
          # letter extensions; they're just there to help me keep
          # things straight.
          #
          # Here's the directory tree:
          #
          # ./
          #    .cvswrappers
          #    foo-b.c0
          #    foo-b.sb
          #    foo-t.c1
          #    foo-t.st
          #
          #    sub1/             sub2/
          #      .cvswrappers      .cvswrappers
          #      foo-b.c1          foo-b.sb
          #      foo-b.sb          foo-b.st
          #      foo-t.c0          foo-t.c0
          #      foo-t.st          foo-t.c1
          #                        foo-t.c2
          #                        foo-t.c3
          #
          #                        subsub/
          #                          .cvswrappers
          #                          foo-b.c3
          #                          foo-b.sb
          #                          foo-t.c0
          #                          foo-t.c1
          #                          foo-t.c2
          #                          foo-t.st
d9216 37
a9252 3
          binwrap3_line1="This is a test file "
          binwrap3_line2="containing little of use "
          binwrap3_line3="except this non-haiku"
d9254 4
a9257 1
          binwrap3_text="${binwrap3_line1}${binwrap3_line2}${binwrap3_line3}"
d9259 3
a9261 1
          cd ${TESTDIR}
d9263 7
a9269 4
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt
d9271 4
a9274 11
          mkdir binwrap3 # the 0th dir
          mkdir binwrap3/sub1
          mkdir binwrap3/sub2
          mkdir binwrap3/sub2/subsub
          
          echo "*.c0 -k 'b'" > binwrap3/.cvswrappers
          echo "whatever -k 'b'" >> binwrap3/.cvswrappers
          echo ${binwrap3_text} > binwrap3/foo-b.c0
          echo ${binwrap3_text} > binwrap3/foo-b.sb
          echo ${binwrap3_text} > binwrap3/foo-t.c1
          echo ${binwrap3_text} > binwrap3/foo-t.st
d9276 20
a9295 6
          echo "*.c1 -k 'b'" > binwrap3/sub1/.cvswrappers
          echo "whatever -k 'b'" >> binwrap3/sub1/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub1/foo-b.c1
          echo ${binwrap3_text} > binwrap3/sub1/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub1/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub1/foo-t.st
d9297 13
a9309 7
          echo "*.st -k 'b'" > binwrap3/sub2/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub2/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub2/foo-b.st
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c1
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c2
          echo ${binwrap3_text} > binwrap3/sub2/foo-t.c3
d9311 10
a9320 9
          echo "*.c3 -k 'b'" > binwrap3/sub2/subsub/.cvswrappers
          echo "foo -k 'b'" >> binwrap3/sub2/subsub/.cvswrappers
          echo "c0* -k 'b'" >> binwrap3/sub2/subsub/.cvswrappers
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-b.c3
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-b.sb
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c0
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c1
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.c2
          echo ${binwrap3_text} > binwrap3/sub2/subsub/foo-t.st
d9322 10
a9331 11
          # Now set up CVSROOT/cvswrappers, the easy way:
	  dotest binwrap3-1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
          # This destroys anything currently in cvswrappers, but
	  # presumably other tests will take care of it themselves if
	  # they use cvswrappers:
	  echo "foo*.sb  -k 'b'" > cvswrappers
	  dotest binwrap3-2 "${testcvs} -q ci -m cvswrappers-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d9333 14
a9346 2
${PROG} [a-z]*: Rebuilding administrative file database"
          cd ..
d9348 31
a9378 3
          # Avoid environmental interference
          CVSWRAPPERS_SAVED=${CVSWRAPPERS}
          unset CVSWRAPPERS
d9380 6
a9385 8
          # Do the import
          cd binwrap3
	  # Not importing .cvswrappers tests whether the client is really
	  # letting the server know "honestly" whether the file is binary,
	  # rather than just letting the server see the .cvswrappers file.
          dotest binwrap3-2a \
"${testcvs} import -m . -I .cvswrappers binwrap3 tag1 tag2" \
"[NI] ${DOTSTAR}"
d9387 19
a9405 13
	  # OK, now test "cvs add".
          cd ..
	  rm -r binwrap3
          dotest binwrap3-2b "${testcvs} co binwrap3" "${DOTSTAR}"
          cd binwrap3
	  cd sub2
	  echo "*.newbin -k 'b'" > .cvswrappers
	  echo .cvswrappers >.cvsignore
	  echo .cvsignore >>.cvsignore
	  touch file1.newbin file1.txt
	  dotest binwrap3-2c "${testcvs} add file1.newbin file1.txt" \
"${PROG} [a-z]*: scheduling file .file1\.newbin. for addition
${PROG} [a-z]*: scheduling file .file1\.txt. for addition
d9407 10
a9416 2
	  dotest binwrap3-2d "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/binwrap3/sub2/file1\.newbin,v
d9418 2
a9419 2
Checking in file1\.newbin;
${TESTDIR}/cvsroot/binwrap3/sub2/file1\.newbin,v  <--  file1\.newbin
d9422 1
a9422 1
RCS file: ${TESTDIR}/cvsroot/binwrap3/sub2/file1\.txt,v
d9424 2
a9425 2
Checking in file1\.txt;
${TESTDIR}/cvsroot/binwrap3/sub2/file1\.txt,v  <--  file1\.txt
d9428 37
a9464 1
	  cd ..
d9466 49
a9514 5
          # Now check out the module and see which files are binary.
          cd ..
	  rm -r binwrap3
          dotest binwrap3-3 "${testcvs} co binwrap3" "${DOTSTAR}"
          cd binwrap3
d9516 1
a9516 3
          # Running "cvs status" and matching output is too
          # error-prone, too likely to falsely fail.  Instead, we'll
          # just grep the Entries lines:
d9518 4
a9521 2
          dotest binwrap3-top1 "grep foo-b.c0 ./CVS/Entries" \
                 "/foo-b.c0/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9523 3
a9525 2
          dotest binwrap3-top2 "grep foo-b.sb ./CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9527 11
a9537 2
          dotest binwrap3-top3 "grep foo-t.c1 ./CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"
d9539 38
a9576 2
          dotest binwrap3-top4 "grep foo-t.st ./CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"
d9578 3
a9580 2
          dotest binwrap3-sub1-1 "grep foo-b.c1 sub1/CVS/Entries" \
                 "/foo-b.c1/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9582 15
a9596 2
          dotest binwrap3-sub1-2 "grep foo-b.sb sub1/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9598 11
a9608 2
          dotest binwrap3-sub1-3 "grep foo-t.c0 sub1/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"
d9610 7
a9616 2
          dotest binwrap3-sub1-4 "grep foo-t.st sub1/CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"
d9618 4
a9621 2
          dotest binwrap3-sub2-1 "grep foo-b.sb sub2/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9623 16
a9638 2
          dotest binwrap3-sub2-2 "grep foo-b.st sub2/CVS/Entries" \
                 "/foo-b.st/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9640 17
a9656 2
          dotest binwrap3-sub2-3 "grep foo-t.c0 sub2/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"
d9658 28
a9685 2
          dotest binwrap3-sub2-4 "grep foo-t.c1 sub2/CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"
d9687 7
a9693 2
          dotest binwrap3-sub2-5 "grep foo-t.c2 sub2/CVS/Entries" \
                 "/foo-t.c2/1.1.1.1/[A-Za-z0-9 	:]*//"
d9695 19
a9713 2
          dotest binwrap3-sub2-6 "grep foo-t.c3 sub2/CVS/Entries" \
                 "/foo-t.c3/1.1.1.1/[A-Za-z0-9 	:]*//"
d9715 19
a9733 2
          dotest binwrap3-subsub1 "grep foo-b.c3 sub2/subsub/CVS/Entries" \
                 "/foo-b.c3/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9735 19
a9753 2
          dotest binwrap3-subsub2 "grep foo-b.sb sub2/subsub/CVS/Entries" \
                 "/foo-b.sb/1.1.1.1/[A-Za-z0-9 	:]*/-kb/"
d9755 6
a9760 2
          dotest binwrap3-subsub3 "grep foo-t.c0 sub2/subsub/CVS/Entries" \
                 "/foo-t.c0/1.1.1.1/[A-Za-z0-9 	:]*//"
a9761 2
          dotest binwrap3-subsub4 "grep foo-t.c1 sub2/subsub/CVS/Entries" \
                 "/foo-t.c1/1.1.1.1/[A-Za-z0-9 	:]*//"
d9763 11
a9773 2
          dotest binwrap3-subsub5 "grep foo-t.c2 sub2/subsub/CVS/Entries" \
                 "/foo-t.c2/1.1.1.1/[A-Za-z0-9 	:]*//"
d9775 18
a9792 2
          dotest binwrap3-subsub6 "grep foo-t.st sub2/subsub/CVS/Entries" \
                 "/foo-t.st/1.1.1.1/[A-Za-z0-9 	:]*//"
d9794 1
a9794 4
	  dotest binwrap3-sub2-add1 "grep file1.newbin sub2/CVS/Entries" \
	    "/file1.newbin/1.1/[A-Za-z0-9 	:]*/-kb/"
	  dotest binwrap3-sub2-add2 "grep file1.txt sub2/CVS/Entries" \
	    "/file1.txt/1.1/[A-Za-z0-9 	:]*//"
d9796 14
a9809 8
          # Restore and clean up
          cd ..
	  rm -r binwrap3 CVSROOT
	  cd ..
	  rm -r wnt
	  rm -rf ${CVSROOT_DIRNAME}/binwrap3
          CVSWRAPPERS=${CVSWRAPPERS_SAVED}
          ;; 
d9811 4
a9814 13
	mwrap)
	  # Tests of various wrappers features:
	  # -m 'COPY' and cvs update: mwrap
	  # -m 'COPY' and joining: mcopy
	  # -k: binwrap, binwrap2
	  # -t/-f: hasn't been written yet.
	  # 
	  # Tests of different ways of specifying wrappers:
	  # CVSROOT/cvswrappers: mwrap
	  # -W: binwrap, binwrap2
	  # .cvswrappers in working directory, local: mcopy
	  # CVSROOT/cvswrappers, .cvswrappers remote: binwrap3
	  # CVSWRAPPERS environment variable: mcopy
d9816 1
a9816 2
	  # This test is similar to binfiles-con1; -m 'COPY' specifies
	  # non-mergeableness the same way that -kb does.
d9818 4
a9821 4
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt
d9823 4
a9826 12
	  dotest mwrap-c1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  echo "* -m 'COPY'" >>cvswrappers
	  dotest mwrap-c2 "${testcvs} -q ci -m wrapper-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  mkdir m1; cd m1
	  dotest mwrap-1 "${testcvs} -q co -l ." ''
d9828 1
a9828 1
	  dotest mwrap-2 "${testcvs} add first-dir" \
d9831 3
a9833 3
	  touch aa
	  dotest mwrap-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
a9834 45
	  dotest mwrap-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done"
	  cd ../..
	  mkdir m2; cd m2
	  dotest mwrap-5 "${testcvs} -q co first-dir" "U first-dir/aa"
	  cd first-dir
	  echo "changed in m2" >aa
	  dotest mwrap-6 "${testcvs} -q ci -m m2-mod" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../..
	  cd m1/first-dir
	  echo "changed in m1" >aa
	  dotest_fail mwrap-7 "${testcvs} -nq update" "C aa"
	  dotest mwrap-8 "${testcvs} -q update" \
"U aa
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.2 from repository is now in aa
${PROG} [a-z]*: file from working directory is now in \.#aa\.1\.1
C aa"
	  dotest mwrap-9 "cat aa" "changed in m2"
	  dotest mwrap-10 "cat .#aa.1.1" "changed in m1"
	  cd ../..
	  cd CVSROOT
	  echo '# comment out' >cvswrappers
	  dotest mwrap-ce "${testcvs} -q ci -m wrapper-mod" \
"Checking in cvswrappers;
${TESTDIR}/cvsroot/CVSROOT/cvswrappers,v  <--  cvswrappers
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  rm -r CVSROOT
	  rm -r m1 m2
	  cd ..
	  rm -r wnt
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d9836 4
a9839 9
	info)
	  # Administrative file tests.
	  # Here is a list of where each administrative file is tested:
	  # loginfo: info
	  # modules: modules, modules2, modules3
	  # cvsignore: ignore
	  # verifymsg: info
	  # cvswrappers: mwrap
	  # config: config
d9841 1
a9841 40
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt

	  dotest info-1 "${testcvs} -q co CVSROOT" "[UP] CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  echo "ALL sh -c \"echo x\${=MYENV}\${=OTHER}y\${=ZEE}=\$USER=\$CVSROOT= >>$TESTDIR/testlog; cat >/dev/null\"" > loginfo
          # The following cases test the format string substitution
          echo "ALL echo %{sVv} >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %{v} >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %s >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "ALL echo %{V}AX >>$TESTDIR/testlog2; cat >/dev/null" >> loginfo
          echo "first-dir echo %sux >>$TESTDIR/testlog2; cat >/dev/null" \
            >> loginfo

	  # Might be nice to move this to crerepos tests; it should
	  # work to create a loginfo file if you didn't create one
	  # with "cvs init".
	  : dotest info-2 "${testcvs} add loginfo" \
"${PROG}"' [a-z]*: scheduling file `loginfo'"'"' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'

	  dotest info-3 "${testcvs} -q ci -m new-loginfo" \
"Checking in loginfo;
${TESTDIR}/cvsroot/CVSROOT/loginfo,v  <--  loginfo
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest info-5 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  touch file1
	  dotest info-6 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  echo "cvs -s OTHER=not-this -s MYENV=env-" >>$HOME/.cvsrc
	  dotest info-6a "${testcvs} -q -s OTHER=value ci -m add-it" \
a9846 7
done
${PROG} [a-z]*: loginfo:1: no such user variable \${=ZEE}"
	  echo line1 >>file1
	  dotest info-7 "${testcvs} -q -s OTHER=value -s ZEE=z ci -m mod-it" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
a9847 12
	  cd ..
	  dotest info-9 "cat $TESTDIR/testlog" "xenv-valueyz=${username}=${TESTDIR}/cvsroot="
          dotest info-10 "cat $TESTDIR/testlog2" 'first-dir file1,NONE,1.1
first-dir 1.1
first-dir file1
first-dir NONEAX
first-dir file1ux
first-dir file1,1.1,1.2
first-dir 1.2
first-dir file1
first-dir 1.1AX
first-dir file1ux'
d9849 4
a9852 33
	  cd CVSROOT
	  echo '# do nothing' >loginfo
	  dotest info-11 "${testcvs} -q -s ZEE=garbage ci -m nuke-loginfo" \
"Checking in loginfo;
${TESTDIR}/cvsroot/CVSROOT/loginfo,v  <--  loginfo
new revision: 1\.[0-9]; previous revision: 1\.[0-9]
done
${PROG} [a-z]*: Rebuilding administrative file database"

	  # Now test verifymsg
	  cat >${TESTDIR}/vscript <<EOF
#!${TESTSHELL}
if head -1 < \$1 | grep '^BugId:[ ]*[0-9][0-9]*$' > /dev/null; then
    exit 0
else
    echo "No BugId found."
    exit 1
fi
EOF
	  chmod +x ${TESTDIR}/vscript
	  echo "^first-dir ${TESTDIR}/vscript" >>verifymsg
	  dotest info-v1 "${testcvs} -q ci -m add-verification" \
"Checking in verifymsg;
${TESTDIR}/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"

	  cd ../first-dir
	  echo line2 >>file1
	  dotest_fail info-v2 "${testcvs} -q ci -m bogus" \
"No BugId found\.
${PROG} \[[a-z]* aborted\]: Message verification failed"
d9854 1
d9856 2
a9857 2
BugId: 42
and many more lines after it
d9859 1
a9859 1
	  dotest info-v3 "${testcvs} -q ci -F ${TESTDIR}/comment.tmp" \
d9862 1
a9862 1
new revision: 1\.3; previous revision: 1\.2
d9864 8
a9871 11
	  cd ..
	  mkdir another-dir
	  cd another-dir
	  touch file2
	  dotest_fail info-v4 \
	    "${testcvs} import -m bogus first-dir/another x y" \
"No BugId found\.
${PROG} \[[a-z]* aborted\]: Message verification failed"
	  rm file2
	  cd ..
	  rmdir another-dir
d9873 9
a9881 9
	  cd CVSROOT
	  echo '# do nothing' >verifymsg
	  dotest info-cleanup-verifymsg "${testcvs} -q ci -m nuke-verifymsg" \
"Checking in verifymsg;
${TESTDIR}/cvsroot/CVSROOT/verifymsg,v  <--  verifymsg
new revision: 1\.[0-9]; previous revision: 1\.[0-9]
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
d9883 16
a9898 14
	  if echo "yes" | ${testcvs} release -d CVSROOT >>${LOGFILE} ; then
	    pass info-cleanup
	  else
	    fail info-cleanup
	  fi
	  if echo "yes" | ${testcvs} release -d first-dir >>${LOGFILE} ; then
	    pass info-cleanup-2
	  else
	    fail info-cleanup-2
	  fi
	  cd ..
	  rm -r wnt
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d9900 12
a9911 3
	config)
	  # Tests of the CVSROOT/config file.  See the comment at the
	  # "info" tests for a full list of administrative file tests.
d9913 57
a9969 4
	  # On Windows, we can't check out CVSROOT, because the case
	  # insensitivity means that this conflicts with cvsroot.
	  mkdir wnt
	  cd wnt
d9971 2
a9972 31
	  dotest config-1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
	  cd CVSROOT
	  echo 'bogus line' >config
	  dotest config-3 "${testcvs} -q ci -m change-to-bogus-line" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  echo 'BogusOption=yes' >config
	  dotest config-4 "${testcvs} -q ci -m change-to-bogus-opt" \
"${PROG} [a-z]*: syntax error in ${TESTDIR}/cvsroot/CVSROOT/config: line 'bogus line' is missing '='
Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.3; previous revision: 1\.2
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  echo '# No config is a good config' > config
	  dotest config-5 "${testcvs} -q ci -m change-to-comment" \
"${PROG} [a-z]*: ${TESTDIR}/cvsroot/CVSROOT/config: unrecognized keyword 'BogusOption'
Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.4; previous revision: 1\.3
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  dotest config-6 "${testcvs} -q update" ''

	  cd ..
	  rm -r CVSROOT
	  cd ..
	  rm -r wnt
d9975 3
a9977 9
	serverpatch)
	  # Test remote CVS handling of unpatchable files.  This isn't
	  # much of a test for local CVS.
	  # We test this with some keyword expansion games, but the situation
	  # also arises if the user modifies the file while CVS is running.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest serverpatch-1 "${testcvs} -q co first-dir" ''
d9979 4
a9982 1
	  cd first-dir
d9984 7
a9990 6
	  # Add a file with an RCS keyword.
	  echo '$''Name$' > file1
	  echo '1' >> file1
	  dotest serverpatch-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
d9992 6
a9997 2
	  dotest serverpatch-3 "${testcvs} -q commit -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d10000 1
a10000 1
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d10003 1
d10005 12
a10016 2
	  # Tag the file.
	  dotest serverpatch-4 "${testcvs} -q tag tag file1" 'T file1'
a10017 1
	  # Check out a tagged copy of the file.
d10019 4
a10022 4
	  mkdir 2
	  cd 2
	  dotest serverpatch-5 "${testcvs} -q co -r tag first-dir" \
'U first-dir/file1'
d10024 5
a10028 3
	  # Remove the tag.  This will leave the tag string in the
	  # expansion of the Name keyword.
	  dotest serverpatch-6 "${testcvs} -q update -A" ''
d10030 28
a10057 8
	  # Modify and check in the first copy.
	  cd ../1/first-dir
	  echo '2' >> file1
	  dotest serverpatch-7 "${testcvs} -q ci -mx file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
d10059 12
a10070 9
	  # Now update the second copy.  When using remote CVS, the
	  # patch will fail, forcing the file to be refetched.
	  cd ../../2/first-dir
	  dotest serverpatch-8 "${testcvs} -q update" \
'U file1' \
'P file1
'"${PROG}"' [a-z]*: checksum failure after patch to ./file1; will refetch
'"${PROG}"' [a-z]*: refetching unpatchable files
U file1'
d10072 3
a10074 3
	  cd ../..
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d10077 17
a10093 11
	log)
	  # Test selecting revisions with cvs log.
	  # See also log2 tests for more tests.
	  # See also branches-14.3 for logging with a branch off of a branch.
	  # See also multibranch-14 for logging with several branches off the
	  #   same branchpoint.
	  # Tests of each option to cvs log:
	  #   -h: admin-19a-log
	  #   -N: log, log2, admin-19a-log
	  #   -b, -r: log
	  #   -d: rcs
d10095 8
a10102 3
	  # Check in a file with a few revisions and branches.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest log-1 "${testcvs} -q co first-dir" ''
d10104 2
a10105 23
	  echo 'first revision' > file1
	  dotest log-2 "${testcvs} add file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'

	  # While we're at it, check multi-line comments, input from file,
	  # and trailing whitespace trimming
	  echo 'line 1     '	 >${TESTDIR}/comment.tmp
	  echo '     '		>>${TESTDIR}/comment.tmp
	  echo 'line 2	'	>>${TESTDIR}/comment.tmp
	  echo '	'	>>${TESTDIR}/comment.tmp
	  echo '  	  '	>>${TESTDIR}/comment.tmp
	  dotest log-3 "${testcvs} -q commit -F ${TESTDIR}/comment.tmp" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  rm -f ${TESTDIR}/comment.tmp

	  echo 'second revision' > file1
	  dotest log-4 "${testcvs} -q ci -m2 file1" \
d10110 4
a10113 5

	  dotest log-5 "${testcvs} -q tag -b branch file1" 'T file1'

	  echo 'third revision' > file1
	  dotest log-6 "${testcvs} -q ci -m3 file1" \
d10118 5
a10122 5

	  dotest log-7 "${testcvs} -q update -r branch" '[UP] file1'

	  echo 'first branch revision' > file1
	  dotest log-8 "${testcvs} -q ci -m1b file1" \
d10125 1
a10125 1
new revision: 1\.2\.2\.1; previous revision: 1\.2
d10127 4
a10130 5

	  dotest log-9 "${testcvs} -q tag tag file1" 'T file1'

	  echo 'second branch revision' > file1
	  dotest log-10 "${testcvs} -q ci -m2b file1" \
d10133 1
a10133 1
new revision: 1\.2\.2\.2; previous revision: 1\.2\.2\.1
d10135 11
a10145 4

	  # Set up a bunch of shell variables to make the later tests
	  # easier to describe.=
	  log_header="
d10147 13
a10159 16
Working file: file1
head: 1\.3
branch:
locks: strict
access list:"
	  log_tags='symbolic names:
	tag: 1\.2\.2\.1
	branch: 1\.2\.0\.2'
	  log_header2='keyword substitution: kv'
	  log_dash='----------------------------
revision'
	  log_date="date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;"
	  log_lines="  lines: ${PLUS}1 -1"
	  log_rev1="${log_dash} 1\.1
${log_date}
line 1
d10161 9
a10169 15
line 2"
	  log_rev2="${log_dash} 1\.2
${log_date}${log_lines}
branches:  1\.2\.2;
2"
	  log_rev3="${log_dash} 1\.3
${log_date}${log_lines}
3"
	  log_rev1b="${log_dash} 1\.2\.2\.1
${log_date}${log_lines}
1b"
	  log_rev2b="${log_dash} 1\.2\.2\.2
${log_date}${log_lines}
2b"
	  log_trailer='============================================================================='
d10171 25
a10195 1
	  # Now, finally, test the log output.
d10197 30
a10226 12
	  dotest log-11 "${testcvs} log file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"
d10228 4
a10231 11
	  dotest log-12 "${testcvs} log -N file1" \
"${log_header}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"
d10233 24
a10256 10
	  dotest log-13 "${testcvs} log -b file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 3
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_trailer}"
d10258 8
a10265 8
	  dotest log-14 "${testcvs} log -r file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
d10267 5
a10271 82
	  dotest log-15 "${testcvs} log -r1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2}
${log_trailer}"

	  dotest log-16 "${testcvs} log -r1.2.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  # This test would fail with the old invocation of rlog, but it
	  # works with the builtin log support.
	  dotest log-17 "${testcvs} log -rbranch file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-18 "${testcvs} log -r1.2.2. file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  # This test would fail with the old invocation of rlog, but it
	  # works with the builtin log support.
	  dotest log-19 "${testcvs} log -rbranch. file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  dotest log-20 "${testcvs} log -r1.2: file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev3}
${log_rev2}
${log_trailer}"

	  dotest log-21 "${testcvs} log -r:1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-22 "${testcvs} log -r1.1:1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-o0 "${testcvs} admin -o 1.2.2.2:: file1" \
d10273 4
d10278 7
a10284 2
	  dotest log-o1 "${testcvs} admin -o ::1.2.2.1 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d10286 10
a10295 3
	  dotest log-o2 "${testcvs} admin -o 1.2.2.1:: file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.2\.2\.2
d10297 5
a10301 15
	  dotest log-o3 "${testcvs} log file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 4;	selected revisions: 4
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev1b}
${log_trailer}"
	  dotest log-o4 "${testcvs} -q update -p -r 1.2.2.1 file1" \
"first branch revision"
	  cd ..
	  rm -r first-dir
d10305 11
a10315 2
	log2)
	  # More "cvs log" tests, for example the file description.
d10317 7
a10323 9
	  # Check in a file
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest log2-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo 'first revision' > file1
	  dotest log2-2 "${testcvs} add -m file1-is-for-testing file1" \
"${PROG}"' [a-z]*: scheduling file `file1'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest log2-3 "${testcvs} -q commit -m 1" \
d10329 6
d10336 4
a10339 3
	  # Setting the file description with add -m doesn't yet work
	  # client/server, so skip log2-4 for remote.
	  if test "x$remote" = xno; then
d10341 12
a10352 16
	  dotest log2-4 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
file1-is-for-testing
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
============================================================================="
d10354 9
a10362 1
	  fi # end of tests skipped for remote
d10364 2
a10365 4
	  dotest log2-5 "${testcvs} admin -t-change-description file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log2-6 "${testcvs} log -N file1" "
d10372 3
d10376 1
a10376 1
total revisions: 1;	selected revisions: 1
a10377 1
change-description
d10380 7
a10386 25
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
============================================================================="

	  # I believe that in Real Life (TM), this is broken for remote.
	  # That is, the filename in question must be the filename of a
	  # file on the server.  It only happens to work here because the
	  # client machine and the server machine are one and the same.
	  echo 'longer description' >${TESTDIR}/descrip
	  echo 'with two lines' >>${TESTDIR}/descrip
	  dotest log2-7 "${testcvs} admin -t${TESTDIR}/descrip file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest log2-8 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
longer description
with two lines
d10388 3
a10390 3
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
d10393 3
a10395 11
	  # Reading the description from stdin is broken for remote.
	  # See comments in cvs.texinfo for a few more notes on this.
	  if test "x$remote" = xno; then

	    if echo change from stdin | ${testcvs} admin -t -q file1
	    then
	      pass log2-9
	    else
	      fail log2-9
	    fi
	    dotest log2-10 "${testcvs} log -N file1" "
d10402 3
d10406 1
a10406 1
total revisions: 1;	selected revisions: 1
a10407 1
change from stdin
d10410 3
a10412 2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
1
d10415 3
a10417 1
	  fi # end of tests skipped for remote
d10419 15
a10433 3
	  cd ..
	  rm ${TESTDIR}/descrip
	  rm -r first-dir
d10435 1
a10436 1
	  ;;
d10438 21
a10458 2
	ann)
	  # Tests of "cvs annotate".  See also basica-10.
d10460 1
a10460 1
	  dotest ann-1 "${testcvs} -q co -l ." ''
d10462 1
a10462 1
	  dotest ann-2 "${testcvs} add first-dir" \
d10464 13
a10476 9
	  cd first-dir
	  cat >file1 <<EOF
this
is
the
ancestral
file
EOF
	  dotest ann-3 "${testcvs} add file1" \
d10478 3
a10480 2
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest ann-4 "${testcvs} -q ci -m add file1" \
d10486 6
d10493 5
a10497 12
	  cat >file1 <<EOF
this
is
a
file

with
a
blank
line
EOF
	  dotest ann-5 "${testcvs} -q ci -m modify file1" \
d10500 22
a10521 1
new revision: 1\.2; previous revision: 1\.1
a10522 6
	  dotest ann-6 "${testcvs} -q tag -b br" "T file1"
	  cat >file1 <<EOF
this
is
a
trunk file
d10524 23
a10546 16
with
a
blank
line
EOF
	  dotest ann-7 "${testcvs} -q ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest ann-8 "${testcvs} -q update -r br" "[UP] file1"
	  cat >file1 <<EOF
this
is
a
file
d10548 21
a10568 42
with
a
blank
line
and some
branched content
EOF
	  dotest ann-9 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"
	  # Note that this annotates the trunk despite the presence
	  # of a sticky tag in the current directory.  This is
	  # fairly bogus, but it is the longstanding behavior for
	  # whatever that is worth.
	  dotest ann-10 "${testcvs} ann" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.3          (${username} *[0-9a-zA-Z-]*): trunk file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line"
	  dotest ann-11 "${testcvs} ann -r br" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.1          (${username} *[0-9a-zA-Z-]*): file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): and some
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): branched content"
a10569 4
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d10571 5
a10575 3
	crerepos)
	  # Various tests relating to creating repositories, operating
	  # on repositories created with old versions of CVS, etc.
d10577 4
a10580 4
	  # Because this test is all about -d options and such, it
	  # at least to some extent needs to be different for remote vs.
	  # local.
	  if test "x$remote" = "xno"; then
a10581 5
	    # First, if the repository doesn't exist at all...
	    dotest_fail crerepos-1 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} \[[a-z]* aborted\]: ${TESTDIR}/crerepos/CVSROOT: .*"
	    mkdir crerepos
d10583 2
a10584 5
	    # The repository exists but CVSROOT doesn't.
	    dotest_fail crerepos-2 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} \[[a-z]* aborted\]: ${TESTDIR}/crerepos/CVSROOT: .*"
	    mkdir crerepos/CVSROOT
a10585 4
	    # Checkout of nonexistent module
	    dotest_fail crerepos-3 \
"${testcvs} -d ${TESTDIR}/crerepos co cvs-sanity" \
"${PROG} [a-z]*: cannot find module .cvs-sanity. - ignored"
d10587 6
a10592 19
	    # Now test that CVS works correctly without a modules file
	    # or any of that other stuff.  In particular, it *must*
	    # function if administrative files added to CVS recently (since
	    # CVS 1.3) do not exist, because the repository might have
	    # been created with an old version of CVS.
	    mkdir tmp; cd tmp
	    dotest crerepos-4 \
"${testcvs} -q -d ${TESTDIR}/crerepos co CVSROOT" \
''
	    if echo yes | \
${testcvs} -d ${TESTDIR}/crerepos release -d CVSROOT >>${LOGFILE}; then
	      pass crerepos-5
	    else
	      fail crerepos-5
	    fi
	    rm -r CVS
	    cd ..
	    # The directory tmp should be empty
	    dotest crerepos-6 "rmdir tmp" ''
a10593 1
	    CREREPOS_ROOT=${TESTDIR}/crerepos
d10595 33
a10627 6
	  else
	    # For remote, just create the repository.  We don't yet do
	    # the various other tests above for remote but that should be
	    # changed.
	    mkdir crerepos
	    mkdir crerepos/CVSROOT
d10629 31
a10659 1
	    CREREPOS_ROOT=:ext:`hostname`:${TESTDIR}/crerepos
d10661 30
a10690 1
	  fi
d10692 9
a10700 7
	  if test "x$remote" = "xno"; then
	    # Test that CVS rejects a relative path in CVSROOT.
	    mkdir 1; cd 1
	    dotest_fail crerepos-6a "${testcvs} -q -d ../crerepos get ." \
"${PROG} \[[a-z]* aborted\]: CVSROOT ../crerepos must be an absolute pathname"
	    cd ..
	    rm -r 1
d10702 3
a10704 13
	    mkdir 1; cd 1
	    dotest_fail crerepos-6b "${testcvs} -d crerepos init" \
"${PROG} \[[a-z]* aborted\]: CVSROOT crerepos must be an absolute pathname"
	    cd ..
	    rm -r 1
	  else # remote
	    # Test that CVS rejects a relative path in CVSROOT.
	    mkdir 1; cd 1
	    dotest_fail crerepos-6a \
"${testcvs} -q -d :ext:`hostname`:../crerepos get ." \
"Root ../crerepos must be an absolute pathname"
	    cd ..
	    rm -r 1
d10706 1
a10706 27
	    mkdir 1; cd 1
	    dotest_fail crerepos-6b \
"${testcvs} -d :ext:`hostname`:crerepos init" \
"Root crerepos must be an absolute pathname"
	    cd ..
	    rm -r 1
	  fi # end of tests to be skipped for remote

	  # CVS better not create a history file--if the administrator 
	  # doesn't need it and wants to save on disk space, they just
	  # delete it.
	  dotest_fail crerepos-7 \
"test -f ${TESTDIR}/crerepos/CVSROOT/history" ''

	  # Now test mixing repositories.  This kind of thing tends to
	  # happen accidentally when people work with several repositories.
	  mkdir 1; cd 1
	  dotest crerepos-8 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest crerepos-9 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch file1
	  dotest crerepos-10 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest crerepos-11 "${testcvs} -q ci -m add-it" \
a10707 4
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
d10709 1
a10709 159
	  cd ../..
	  rm -r 1

	  mkdir 1; cd 1
	  dotest crerepos-12 "${testcvs} -d ${CREREPOS_ROOT} -q co -l ." ''
	  mkdir crerepos-dir
	  dotest crerepos-13 "${testcvs} add crerepos-dir" \
"Directory ${TESTDIR}/crerepos/crerepos-dir added to the repository"
	  cd crerepos-dir
	  touch cfile
	  dotest crerepos-14 "${testcvs} add cfile" \
"${PROG} [a-z]*: scheduling file .cfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest crerepos-15 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/crerepos/crerepos-dir/cfile,v
done
Checking in cfile;
${TESTDIR}/crerepos/crerepos-dir/cfile,v  <--  cfile
initial revision: 1\.1
done"
	  cd ../..
	  rm -r 1

	  mkdir 1; cd 1
	  dotest crerepos-16 "${testcvs} co first-dir" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/file1"
	  dotest crerepos-17 "${testcvs} -d ${CREREPOS_ROOT} co crerepos-dir" \
"${PROG} [a-z]*: Updating crerepos-dir
U crerepos-dir/cfile"

	  if test x`cat CVS/Repository` = x.; then
	    # RELATIVE_REPOS
	    # Fatal error so that we don't go traipsing through the
	    # directories which happen to have the same names from the
	    # wrong repository.
	    dotest_fail crerepos-18 "${testcvs} -q update" \
"${PROG} \[[a-z]* aborted\]: cannot open directory ${TESTDIR}/cvsroot/crerepos-dir: .*" ''
	  else
	    if test "$remote" = no; then
	      # The lack of an error doesn't mean CVS is really
	      # working (things are getting logged to the wrong
	      # history file and such).
	      dotest crerepos-18 "${testcvs} -q update" ''
	    else
	      # Fatal error so that we don't go traipsing through the
	      # directories which happen to have the same names from the
	      # wrong repository.
	      dotest_fail crerepos-18 "${testcvs} -q update" \
"protocol error: directory .${TESTDIR}/crerepos/crerepos-dir. not within root .${TESTDIR}/cvsroot."
	    fi
	  fi

	  cd ..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${TESTDIR}/crerepos
	  ;;

	rcs)
	  # Test ability to import an RCS file.  Note that this format
	  # is fixed--files written by RCS5, and other software which
	  # implements this format, will be out there "forever" and
	  # CVS must always be able to import such files.

	  # See tests admin-13, admin-25 and rcs-8a for exporting RCS files.

	  mkdir ${CVSROOT_DIRNAME}/first-dir

	  # Currently the way to import an RCS file is to copy it
	  # directly into the repository.
	  #
	  # This file was written by RCS 5.7, and then the dates were
	  # hacked so that we test year 2000 stuff.  Note also that
	  # "author" names are just strings, as far as importing
	  # RCS files is concerned--they need not correspond to user
	  # IDs on any particular system.
	  #
	  # I also tried writing a file with the RCS supplied with
	  # HPUX A.09.05.  According to "man rcsintro" this is
	  # "Revision Number: 3.0; Release Date: 83/05/11".  There
	  # were a few minor differences like whitespace but at least
	  # in simple cases like this everything else seemed the same
	  # as the file written by RCS 5.7 (so I won't try to make it
	  # a separate test case).

	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head	1.3;
access;
symbols;
locks; strict;
comment	@@# @@;


1.3
date	2000.11.24.15.58.37;	author kingdon;	state Exp;
branches;
next	1.2;

1.2
date	96.11.24.15.57.41;	author kingdon;	state Exp;
branches;
next	1.1;

1.1
date	96.11.24.15.56.05;	author kingdon;	state Exp;
branches;
next	;


desc
@@file1 is for testing CVS
@@


1.3
log
@@delete second line; modify twelfth line
@@
text
@@This is the first line
This is the third line
This is the fourth line
This is the fifth line
This is the sixth line
This is the seventh line
This is the eighth line
This is the ninth line
This is the tenth line
This is the eleventh line
This is the twelfth line (and what a line it is)
This is the thirteenth line
@@


1.2
log
@@add more lines
@@
text
@@a1 1
This is the second line
d11 1
a11 1
This is the twelfth line
@@


1.1
log
@@add file1
@@
text
@@d2 12
@@
EOF
	  dotest rcs-1 "${testcvs} -q co first-dir" 'U first-dir/file1'
	  cd first-dir
	  dotest rcs-2 "${testcvs} -q log" "
d10712 1
a10712 1
head: 1\.3
d10716 3
a10718 1
symbolic names:
d10720 1
a10720 15
total revisions: 3;	selected revisions: 3
description:
file1 is for testing CVS
----------------------------
revision 1\.3
date: 2000/11/24 15:58:37;  author: kingdon;  state: Exp;  lines: ${PLUS}1 -2
delete second line; modify twelfth line
----------------------------
revision 1\.2
date: 1996/11/24 15:57:41;  author: kingdon;  state: Exp;  lines: ${PLUS}12 -0
add more lines
----------------------------
revision 1\.1
date: 1996/11/24 15:56:05;  author: kingdon;  state: Exp;
add file1
d10722 5
d10728 16
a10743 5
	  # Note that the dates here are chosen so that (a) we test
	  # at least one date after 2000, (b) we will notice if the
	  # month and day are getting mixed up with each other.
	  # TODO: also test that year isn't getting mixed up with month
	  # or day, for example 01-02-03.
d10745 79
a10823 6
	  # ISO8601 format.  There are many, many, other variations
	  # specified by ISO8601 which we should be testing too.
	  dotest rcs-3 "${testcvs} -q log -d 1996-12-11<" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
d10829 1
a10829 1
total revisions: 3;	selected revisions: 1
d10831 4
a10834 1
file1 is for testing CVS
d10837 10
a10846 2
date: 2000/11/24 15:58:37;  author: kingdon;  state: Exp;  lines: ${PLUS}1 -2
delete second line; modify twelfth line
d10849 51
a10899 7
	  # RFC822 format (as amended by RFC1123).
	  if ${testcvs} -q log -d '<3 Apr 2000 00:00' >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-4 "cat ${TESTDIR}/rcs4.tmp" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
d10904 1
d10906 1
a10906 1
total revisions: 3;	selected revisions: 2
d10908 9
a10916 1
file1 is for testing CVS
d10919 2
a10920 2
date: 1996/11/24 15:57:41;  author: kingdon;  state: Exp;  lines: ${PLUS}12 -0
add more lines
d10923 6
a10928 2
date: 1996/11/24 15:56:05;  author: kingdon;  state: Exp;
add file1
a10929 3
	  else
	    fail rcs-4
	  fi
d10931 8
a10938 26
	  # OK, here is another one.  This one was written by hand based on
	  # doc/RCSFILES and friends.
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file2,v
head			 	1.5                 ;
     branch        1.2.6;
access ;
symbols branch:1.2.6;
locks;
testofanewphrase @@without newphrase we'd have trouble extending @@@@ all@@ ;
1.5 date 71.01.01.01.00.00; author joe; state bogus; branches; next 1.4;
1.4 date 71.01.01.00.00.05; author joe; state bogus; branches; next 1.3;
1.3 date 70.12.31.15.00.05; author joe; state bogus; branches; next 1.2;
1.2 date 70.12.31.12.15.05; author me; state bogus; branches 1.2.6.1; next 1.1;
1.1 date 70.12.31.11.00.05; author joe; state bogus; branches; next; newph;
1.2.6.1 date 71.01.01.08.00.05; author joe; state Exp; branches; next;
desc @@@@
1.5 log @@@@ newphrase1; newphrase2 42; text @@head revision@@
1.4 log @@@@ text @@d1 1
a1 1
new year revision@@
1.3 log @@@@ text @@d1 1
a1 1
old year revision@@
1.2 log @@@@ text @@d1 1
a1 1
mid revision@@ 1.1
d10940 25
a10964 10
log           @@@@ text @@d1 1
a1 1
start revision@@
1.2.6.1 log @@@@ text @@d1 1
a1 1
branch revision@@
EOF
	  # First test the default branch.
	  dotest rcs-5 "${testcvs} -q update file2" "U file2"
	  dotest rcs-6 "cat file2" "branch revision"
d10966 8
a10973 29
	  # Check in a revision on the branch to force CVS to
	  # interpret every revision in the file.
	  dotest rcs-6a "${testcvs} -q update -r branch file2" ""
	  echo "next branch revision" > file2
	  dotest rcs-6b "${testcvs} -q ci -m mod file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.2\.6\.2; previous revision: 1\.2\.6\.1
done"

	  # Now get rid of the default branch, it will get in the way.
	  dotest rcs-7 "${testcvs} admin -b file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  # But we do want to make sure that "cvs admin" leaves the newphrases
	  # in the file.
	  # The extra whitespace regexps are for the RCS library, which does
	  # not preserve whitespace in the dogmatic manner of RCS 5.7. -twp
	  dotest rcs-8 \
"grep testofanewphrase ${CVSROOT_DIRNAME}/first-dir/file2,v" \
"testofanewphrase[	 ][ 	]*@@without newphrase we'd have trouble extending @@@@ all@@[	 ]*;"
	  # The easiest way to test for newphrases in deltas and deltatexts
	  # is to just look at the whole file, I guess.
	  dotest rcs-8a "cat ${CVSROOT_DIRNAME}/first-dir/file2,v" \
"head	1\.5;
access;
symbols
	branch:1.2.6;
locks;
a10974 1
testofanewphrase	@@without newphrase we'd have trouble extending @@@@ all@@;
d10976 2
a10977 17
1\.5
date	71\.01\.01\.01\.00\.00;	author joe;	state bogus;
branches;
next	1\.4;

1\.4
date	71\.01\.01\.00\.00\.05;	author joe;	state bogus;
branches;
next	1\.3;

1\.3
date	70\.12\.31\.15\.00\.05;	author joe;	state bogus;
branches;
next	1\.2;

1\.2
date	70\.12\.31\.12\.15\.05;	author me;	state bogus;
d10979 1
a10979 6
	1\.2\.6\.1;
next	1\.1;

1\.1
date	70\.12\.31\.11\.00\.05;	author joe;	state bogus;
branches;
a10980 1
newph	;
d10982 2
a10983 7
1\.2\.6\.1
date	71\.01\.01\.08\.00\.05;	author joe;	state Exp;
branches;
next	1\.2\.6\.2;

1\.2\.6\.2
date	[0-9.]*;	author ${username};	state Exp;
a10991 36
1\.5
log
@@@@
newphrase1	;
newphrase2	42;
text
@@head revision@@


1\.4
log
@@@@
text
@@d1 1
a1 1
new year revision@@


1\.3
log
@@@@
text
@@d1 1
a1 1
old year revision@@


1\.2
log
@@@@
text
@@d1 1
a1 1
mid revision@@


d10994 2
a10995 1
@@@@
a10996 7
@@d1 1
a1 1
start revision@@


1\.2\.6\.1
log
a10997 4
text
@@d1 1
a1 1
branch revision@@
d11000 1
a11000 1
1\.2\.6\.2
d11002 1
a11002 1
@@mod
d11005 2
a11006 3
@@d1 1
a1 1
next branch revision
d11009 4
a11012 3
	  # For remote, the "update -p -D" usage seems not to work.
	  # I'm not sure what is going on.
	  if test "x$remote" = "xno"; then
d11014 11
a11024 7
	  if ${testcvs} -q update -p -D '1970-12-31 11:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-9 "cat ${TESTDIR}/rcs4.tmp" "start revision"
	  else
	    fail rcs-9
	  fi
d11026 18
a11043 7
	  if ${testcvs} -q update -p -D '1970-12-31 12:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-10 "cat ${TESTDIR}/rcs4.tmp" "mid revision"
	  else
	    fail rcs-10
	  fi
d11045 8
a11052 34
	  if ${testcvs} -q update -p -D '1971-01-01 00:30 UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-11 "cat ${TESTDIR}/rcs4.tmp" "new year revision"
	  else
	    fail rcs-11
	  fi

	  # Same test as rcs-10, but with am/pm.
	  if ${testcvs} -q update -p -D 'December 31, 1970 12:30pm UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-12 "cat ${TESTDIR}/rcs4.tmp" "mid revision"
	  else
	    fail rcs-12
	  fi

	  # Same test as rcs-11, but with am/pm.
	  if ${testcvs} -q update -p -D 'January 1, 1971 12:30am UT' file2 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs-13 "cat ${TESTDIR}/rcs4.tmp" "new year revision"
	  else
	    fail rcs-13
	  fi

	  fi # end of tests skipped for remote

	  # OK, now make sure cvs log doesn't have any trouble with the
	  # newphrases and such.
	  dotest rcs-14 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.5
d11054 2
a11055 1
locks:
a11056 2
symbolic names:
	branch: 1\.2\.6
d11058 1
a11058 1
total revisions: 7;	selected revisions: 7
d11061 22
a11082 16
revision 1\.5
date: 1971/01/01 01:00:00;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.4
date: 1971/01/01 00:00:05;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.3
date: 1970/12/31 15:00:05;  author: joe;  state: bogus;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.2
date: 1970/12/31 12:15:05;  author: me;  state: bogus;  lines: ${PLUS}1 -1
branches:  1\.2\.6;
\*\*\* empty log message \*\*\*
d11085 2
a11086 10
date: 1970/12/31 11:00:05;  author: joe;  state: bogus;
\*\*\* empty log message \*\*\*
----------------------------
revision 1\.2\.6\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -1
mod
----------------------------
revision 1\.2\.6\.1
date: 1971/01/01 08:00:05;  author: joe;  state: Exp;  lines: ${PLUS}1 -1
\*\*\* empty log message \*\*\*
a11087 1
	  cd ..
d11089 7
a11095 3
	  rm -r first-dir ${TESTDIR}/rcs4.tmp
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11097 14
a11110 1
	big)
d11112 3
a11114 23
	  # Test ability to operate on big files.  Intention is to
	  # test various realloc'ing code in RCS_deltas, rcsgetkey,
	  # etc.  "big" is currently defined to be 1000 lines (64000
	  # bytes), which in terms of files that users will use is not
	  # large, merely average, but my reasoning is that this
	  # should be big enough to make sure realloc'ing is going on
	  # and that raising it a lot would start to stress resources
	  # on machines which run the tests, without any significant
	  # benefit.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest big-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  for i in 0 1 2 3 4 5 6 7 8 9; do
	    for j in 0 1 2 3 4 5 6 7 8 9; do
	      for k in 0 1 2 3 4 5 6 7 8 9; do
		echo \
"This is line ($i,$j,$k) which goes into the file file1 for testing" >>file1
	      done
	    done
	  done
	  dotest big-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
d11116 2
a11117 2
	  dotest big-3 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
d11119 2
a11120 2
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
d11123 4
d11128 34
a11161 8
	  mkdir 2
	  cd 2
	  dotest big-4 "${testcvs} -q get first-dir" "U first-dir/file1"
	  cd ../first-dir
	  echo "add a line to the end" >>file1
	  dotest big-5 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
a11163 5
	  cd ../2/first-dir
	  # The idea here is particularly to test the Rcs-diff response
	  # and the reallocing thereof, for remote.
	  dotest big-6 "${testcvs} -q update" "[UP] file1"
	  cd ../..
d11165 10
a11174 4
	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi
d11176 3
a11178 1
	  rm -r first-dir 2
d11182 35
a11216 7
	modes)
	  # Test repository permissions (CVSUMASK and so on).
	  # Although the tests in this section "cheat" by testing
	  # repository permissions, which are sort of not a user-visible
	  # sort of thing, the modes do have user-visible consequences,
	  # such as whether a second user can check out the files.  But
	  # it would be awkward to test the consequences, so we don't.
d11218 2
a11219 4
	  # Solaris /bin/sh doesn't support export -n.  I'm not sure
	  # what we can do about this, other than hope that whoever
	  # is running the tests doesn't have CVSUMASK set.
	  #export -n CVSUMASK # if unset, defaults to 002
d11221 1
a11221 1
	  umask 077
d11223 2
a11224 18
	  dotest modes-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest modes-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  dotest modes-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest modes-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done"
	  dotest modes-5 "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
"-r--r--r-- .*"
d11226 3
a11228 13
	  # Test for whether we can set the execute bit.
	  chmod +x aa
	  echo change it >>aa
	  dotest modes-6 "${testcvs} -q ci -m set-execute-bit" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done"
	  # If CVS let us update the execute bit, it would be set here.
	  # But it doesn't, and as far as I know that is longstanding
	  # CVS behavior.
	  dotest modes-7 "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
"-r--r--r-- .*"
d11230 9
a11238 10
	  # OK, now manually change the modes and see what happens.
	  chmod g=r,o= ${TESTDIR}/cvsroot/first-dir/aa,v
	  echo second line >>aa
	  dotest modes-7a "${testcvs} -q ci -m set-execute-bit" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest modes-7b "ls -l ${TESTDIR}/cvsroot/first-dir/aa,v" \
"-r--r----- .*"
d11240 32
a11271 10
	  CVSUMASK=007
	  export CVSUMASK
	  touch ab
	  # Might as well test the execute bit too.
	  chmod +x ab
	  dotest modes-8 "${testcvs} add ab" \
"${PROG} [a-z]*: scheduling file .ab. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest modes-9 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/ab,v
d11273 2
a11274 14
Checking in ab;
${TESTDIR}/cvsroot/first-dir/ab,v  <--  ab
initial revision: 1\.1
done"
	  if test "x$remote" = xyes; then
	    # The problem here is that the CVSUMASK environment variable
	    # needs to be set on the server (e.g. .bashrc).  This is, of
	    # course, bogus, but that is the way it is currently.
	    dotest modes-10 "ls -l ${TESTDIR}/cvsroot/first-dir/ab,v" \
"-r-xr-x---.*" "-r-xr-xr-x.*"
	  else
	    dotest modes-10 "ls -l ${TESTDIR}/cvsroot/first-dir/ab,v" \
"-r-xr-x---.*"
	  fi
d11276 14
a11289 31
	  # OK, now add a file on a branch.  Check that the mode gets
	  # set the same way (it is a different code path in CVS).
	  dotest modes-11 "${testcvs} -q tag -b br" 'T aa
T ab'
	  dotest modes-12 "${testcvs} -q update -r br" ''
	  touch ac
	  dotest modes-13 "${testcvs} add ac" \
"${PROG} [a-z]*: scheduling file .ac. for addition on branch .br.
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # Not sure it really makes sense to refer to a "previous revision"
	  # when we are just now adding the file; as far as I know
	  # that is longstanding CVS behavior, for what it's worth.
	  dotest modes-14 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/ac,v
done
Checking in ac;
${TESTDIR}/cvsroot/first-dir/Attic/ac,v  <--  ac
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  if test "x$remote" = xyes; then
	    # The problem here is that the CVSUMASK environment variable
	    # needs to be set on the server (e.g. .bashrc).  This is, of
	    # course, bogus, but that is the way it is currently.
	    dotest modes-15 \
"ls -l ${TESTDIR}/cvsroot/first-dir/Attic/ac,v" \
"-r--r--r--.*"
	  else
	    dotest modes-15 \
"ls -l ${TESTDIR}/cvsroot/first-dir/Attic/ac,v" \
"-r--r-----.*"
	  fi
d11291 11
a11301 6
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  # Perhaps should restore the umask and CVSUMASK.  But the other
	  # tests "should" not care about them...
	  ;;
d11303 20
a11322 30
	stamps)
	  # Test timestamps.
	  mkdir 1; cd 1
	  dotest stamps-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest stamps-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  echo '$''Id$' >kw
	  ls -l aa >${TESTDIR}/1/stamp.aa.touch
	  ls -l kw >${TESTDIR}/1/stamp.kw.touch
	  # "sleep 1" would suffice if we could assume ls --full-time, but
	  # that is as far as I know unique to GNU ls.  Is there some POSIX.2
	  # way to get the timestamp of a file, including the seconds?
	  sleep 60
	  dotest stamps-3 "${testcvs} add aa kw" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: scheduling file .kw. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  ls -l aa >${TESTDIR}/1/stamp.aa.add
	  ls -l kw >${TESTDIR}/1/stamp.kw.add
	  # "cvs add" should not muck with the timestamp.
	  dotest stamps-4aa \
"cmp ${TESTDIR}/1/stamp.aa.touch ${TESTDIR}/1/stamp.aa.add" ''
	  dotest stamps-4kw \
"cmp ${TESTDIR}/1/stamp.kw.touch ${TESTDIR}/1/stamp.kw.add" ''
	  sleep 60
	  dotest stamps-5 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
d11324 3
a11326 3
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
d11328 1
a11328 1
RCS file: ${TESTDIR}/cvsroot/first-dir/kw,v
d11330 3
a11332 3
Checking in kw;
${TESTDIR}/cvsroot/first-dir/kw,v  <--  kw
initial revision: 1\.1
d11334 21
a11354 37
	  ls -l aa >${TESTDIR}/1/stamp.aa.ci
	  ls -l kw >${TESTDIR}/1/stamp.kw.ci
	  # If there are no keywords, "cvs ci" leaves the timestamp alone
	  # If there are, it sets the timestamp to the date of the commit.
	  # I'm not sure how logical this is, but it is intentional.
	  # If we wanted to get fancy we would make sure the time as
	  # reported in "cvs log kw" matched stamp.kw.ci.  But that would
	  # be a lot of work.
	  dotest stamps-6aa \
	    "cmp ${TESTDIR}/1/stamp.aa.add ${TESTDIR}/1/stamp.aa.ci" ''
	  if cmp ${TESTDIR}/1/stamp.kw.add ${TESTDIR}/1/stamp.kw.ci >/dev/null
	  then
	    fail stamps-6kw
	  else
	    pass stamps-6kw
	  fi
	  cd ../..
	  sleep 60
	  mkdir 2
	  cd 2
	  dotest stamps-7 "${testcvs} -q get first-dir" "U first-dir/aa
U first-dir/kw"
	  cd first-dir
	  ls -l aa >${TESTDIR}/1/stamp.aa.get
	  ls -l kw >${TESTDIR}/1/stamp.kw.get
	  # On checkout, CVS should set the timestamp to the date that the
	  # file was committed.  Could check that the time as reported in
	  # "cvs log aa" matches stamp.aa.get, but that would be a lot of
	  # work.
	  if cmp ${TESTDIR}/1/stamp.aa.ci ${TESTDIR}/1/stamp.aa.get >/dev/null
	  then
	    fail stamps-8aa
	  else
	    pass stamps-8aa
	  fi
	  dotest stamps-8kw \
	    "cmp ${TESTDIR}/1/stamp.kw.ci ${TESTDIR}/1/stamp.kw.get" ''
d11356 8
a11363 49
	  # Now we want to see what "cvs update" does.
	  sleep 60
	  echo add a line >>aa
	  echo add a line >>kw
	  dotest stamps-9 "${testcvs} -q ci -m change-them" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done
Checking in kw;
${TESTDIR}/cvsroot/first-dir/kw,v  <--  kw
new revision: 1\.2; previous revision: 1\.1
done"
	  ls -l aa >${TESTDIR}/1/stamp.aa.ci2
	  ls -l kw >${TESTDIR}/1/stamp.kw.ci2
	  cd ../..
	  cd 1/first-dir
	  sleep 60
	  dotest stamps-10 "${testcvs} -q update" '[UP] aa
[UP] kw'
	  # this doesn't serve any function other than being able to
	  # look at it manually, as we have no machinery for dates being
	  # newer or older than other dates.
	  date >${TESTDIR}/1/stamp.debug.update
	  ls -l aa >${TESTDIR}/1/stamp.aa.update
	  ls -l kw >${TESTDIR}/1/stamp.kw.update
	  # stamp.aa.update and stamp.kw.update should both be approximately
	  # the same as stamp.debug.update.  Perhaps we could be testing
	  # this in a more fancy fashion by "touch stamp.before" before
	  # stamps-10, "touch stamp.after" after, and then using ls -t
	  # to check them.  But for now we just make sure that the *.update
	  # stamps differ from the *.ci2 ones.
	  # As for the rationale, this is so that if one updates and gets
	  # a new revision, then "make" will be sure to regard those files
	  # as newer than .o files which may be sitting around.
	  if cmp ${TESTDIR}/1/stamp.aa.update ${TESTDIR}/1/stamp.aa.ci2 \
	     >/dev/null
	  then
	    fail stamps-11aa
	  else
	    pass stamps-11aa
	  fi
	  if cmp ${TESTDIR}/1/stamp.kw.update ${TESTDIR}/1/stamp.kw.ci2 \
	     >/dev/null
	  then
	    fail stamps-11kw
	  else
	    pass stamps-11kw
	  fi
d11365 8
a11372 1
	  cd ../..
d11374 8
a11381 4
	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi
d11383 10
a11392 3
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11394 10
a11403 11
	sticky)
	  # More tests of sticky tags, particularly non-branch sticky tags.
	  # See many tests (e.g. multibranch) for ordinary sticky tag
	  # operations such as adding files on branches.
	  # See "head" test for interaction between stick tags and HEAD.
	  mkdir 1; cd 1
	  dotest sticky-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest sticky-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
d11405 4
a11408 38
	  touch file1
	  dotest sticky-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest sticky-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest sticky-5 "${testcvs} -q tag tag1" "T file1"
	  echo add a line >>file1
	  dotest sticky-6 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest sticky-7 "${testcvs} -q update -r tag1" "[UP] file1"
	  dotest sticky-8 "cat file1" ''
	  dotest sticky-9 "${testcvs} -q update" ''
	  dotest sticky-10 "cat file1" ''
	  touch file2
	  dotest_fail sticky-11 "${testcvs} add file2" \
"${PROG} [a-z]*: cannot add file on non-branch tag tag1"
	  dotest sticky-12 "${testcvs} -q update -A" "[UP] file1
${QUESTION} file2" "${QUESTION} file2
[UP] file1"
	  dotest sticky-13 "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest sticky-14 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
d11410 17
a11426 3
	  # Now back to tag1
	  dotest sticky-15 "${testcvs} -q update -r tag1" "[UP] file1
${PROG} [a-z]*: file2 is no longer in the repository"
d11428 16
a11443 15
	  rm file1
	  dotest sticky-16 "${testcvs} rm file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  # Hmm, this command seems to silently remove the tag from
	  # the file.  This appears to be intentional.
	  # The silently part especially strikes me as odd, though.
	  dotest sticky-17 "${testcvs} -q ci -m remove-it" ""
	  dotest sticky-18 "${testcvs} -q update -A" "U file1
U file2"
	  dotest sticky-19 "${testcvs} -q update -r tag1" \
"${PROG} [a-z]*: file1 is no longer in the repository
${PROG} [a-z]*: file2 is no longer in the repository"
	  dotest sticky-20 "${testcvs} -q update -A" "U file1
U file2"
d11445 15
a11459 11
	  # Now try with a numeric revision.
	  dotest sticky-21 "${testcvs} -q update -r 1.1 file1" "U file1"
	  rm file1
	  dotest sticky-22 "${testcvs} rm file1" \
"${PROG} [a-z]*: cannot remove file .file1. which has a numeric sticky tag of .1\.1."
	  # The old behavior was that remove allowed this and then commit
	  # gave an error, which was somewhat hard to clear.  I mean, you
	  # could get into a long elaborate discussion of this being a
	  # conflict and two ways to resolve it, but I don't really see
	  # why CVS should have a concept of conflict that arises, not from
	  # parallel development, but from CVS's own sticky tags.
d11461 15
a11475 7
	  # I'm kind of surprised that the "file1 was lost" doesn't crop
	  # up elsewhere in the testsuite.  It is a long-standing
	  # discrepency between local and remote CVS and should probably
	  # be cleaned up at some point.
	  dotest sticky-23 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: file1 was lost
U file1" "U file1"
d11477 17
a11493 4
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11495 17
a11511 16
	keyword)
	  # Test keyword expansion.
	  # Various other tests relate to our ability to correctly
	  # set the keyword expansion mode.
	  # "binfiles" tests "cvs admin -k".
	  # "binfiles" and "binfiles2" test "cvs add -k".
	  # "rdiff" tests "cvs co -k".
	  # "binfiles" (and this test) test "cvs update -k".
	  # "binwrap" tests setting the mode from wrappers.
	  # I don't think any test is testing "cvs import -k".
	  mkdir 1; cd 1
	  dotest keyword-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest keyword-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
a11512 17
	  echo '$''Author$' > file1
	  echo '$''Date$' >> file1
	  echo '$''Header$' >> file1
	  echo '$''Id$' >> file1
	  echo '$''Locker$' >> file1
	  echo '$''Name$' >> file1
	  echo '$''RCSfile$' >> file1
	  echo '$''Revision$' >> file1
	  echo '$''Source$' >> file1
	  echo '$''State$' >> file1
	  echo '$''Nonkey$' >> file1
	  # Omit the trailing dollar sign
	  echo '$''Date' >> file1
	  # Put two keywords on one line
	  echo '$''State$' '$''State$' >> file1
	  # Use a header for Log
	  echo 'xx $''Log$' >> file1
d11514 17
a11530 28
	  dotest keyword-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest keyword-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest keyword-5 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Locker:  "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"
a11531 7
	  # Use cvs admin to lock the RCS file in order to check -kkvl
	  # vs. -kkv.  CVS does not normally lock RCS files, but some
	  # people use cvs admin to enforce reserved checkouts.
	  dotest keyword-6 "${testcvs} admin -l file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 locked
done"
d11533 15
a11547 19
	  dotest keyword-7 "${testcvs} update -kkv file1" "U file1"
	  dotest keyword-8 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
"'\$'"Locker:  "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"
d11549 15
a11563 19
	  dotest keyword-9 "${testcvs} update -kkvl file1" "U file1"
	  dotest keyword-10 "cat file1" \
'\$'"Author: ${username} "'\$'"
"'\$'"Date: [0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9] "'\$'"
"'\$'"Header: ${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp ${username} "'\$'"
"'\$'"Id: file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp ${username} "'\$'"
"'\$'"Locker: ${username} "'\$'"
"'\$'"Name:  "'\$'"
"'\$'"RCSfile: file1,v "'\$'"
"'\$'"Revision: 1\.1 "'\$'"
"'\$'"Source: ${TESTDIR}/cvsroot/first-dir/file1,v "'\$'"
"'\$'"State: Exp "'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State: Exp "'\$'" "'\$'"State: Exp "'\$'"
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"
d11565 17
a11581 19
	  dotest keyword-11 "${testcvs} update -kk file1" "U file1"
	  dotest keyword-12 "cat file1" \
'\$'"Author"'\$'"
"'\$'"Date"'\$'"
"'\$'"Header"'\$'"
"'\$'"Id"'\$'"
"'\$'"Locker"'\$'"
"'\$'"Name"'\$'"
"'\$'"RCSfile"'\$'"
"'\$'"Revision"'\$'"
"'\$'"Source"'\$'"
"'\$'"State"'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State"'\$'" "'\$'"State"'\$'"
xx "'\$'"Log"'\$'"
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"
d11583 17
a11599 6
	  dotest keyword-13 "${testcvs} update -kv file1" "U file1"
	  dotest keyword-14 "cat file1" \
"${username}
[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]
${TESTDIR}/cvsroot/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp
file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp
d11602 1
a11602 11
file1,v
1\.1
${TESTDIR}/cvsroot/first-dir/file1,v
Exp
"'\$'"Nonkey"'\$'"
"'\$'"Date
Exp Exp
xx file1,v
xx Revision 1\.1  [0-9/]* [0-9:]*  ${username}
xx add
xx"
d11604 31
a11634 16
	  dotest keyword-15 "${testcvs} update -ko file1" "U file1"
	  dotest keyword-16 "cat file1" \
'\$'"Author"'\$'"
"'\$'"Date"'\$'"
"'\$'"Header"'\$'"
"'\$'"Id"'\$'"
"'\$'"Locker"'\$'"
"'\$'"Name"'\$'"
"'\$'"RCSfile"'\$'"
"'\$'"Revision"'\$'"
"'\$'"Source"'\$'"
"'\$'"State"'\$'"
"'\$'"Nonkey"'\$'"
"'\$'"Date
"'\$'"State"'\$'" "'\$'"State"'\$'"
xx "'\$'"Log"'\$'
d11636 17
a11652 1
	  # Test the Name keyword.  First go back to normal expansion.
d11654 17
a11670 1
	  dotest keyword-17 "${testcvs} update -A file1" "U file1"
a11671 14
	  echo '$''Name$' > file1
	  dotest keyword-18 "${testcvs} ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest keyword-19 "${testcvs} -q tag tag1" "T file1"
	  echo "change" >> file1
	  dotest keyword-20 "${testcvs} -q ci -m mod2 file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest keyword-21 "${testcvs} -q update -r tag1" "[UP] file1"
d11673 1
a11673 4
	  # FIXME: This test fails when remote.  The second expect
	  # string below should be removed when this is fixed.
	  dotest keyword-22 "cat file1" '\$'"Name: tag1 "'\$' \
'\$'"Name:  "'\$'
d11675 15
a11689 1
	  dotest keyword-23 "${testcvs} update -A file1" "[UP] file1"
d11691 17
a11707 4
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11709 17
a11725 12
	keywordlog)
	  # Test the Log keyword.
	  mkdir 1; cd 1
	  dotest keywordlog-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest keywordlog-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo change >file1
	  dotest keywordlog-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a11726 4
	  # Note that we wanted to try "ci -r 1.3 -m add file1" and CVS
	  # seemed to get all confused, thinking it was adding on a branch
	  # or something.  FIXME?  Do something about this?  Document it
	  # in BUGS or someplace?
d11728 1
a11728 7
	  dotest keywordlog-4 "${testcvs} -q ci -m add file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
d11730 19
a11748 4
	  cd ../..
	  mkdir 2; cd 2
	  dotest keywordlog-4a "${testcvs} -q co first-dir" "U first-dir/file1"
	  cd ../1/first-dir
d11750 19
a11768 18
	  echo 'xx $''Log$' > file1
	  cat >${TESTDIR}/comment.tmp <<EOF
First log line
Second log line
EOF
	  dotest keywordlog-5 "${testcvs} ci -F ${TESTDIR}/comment.tmp file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  rm -f ${TESTDIR}/comment.tmp
	  dotest keywordlog-6 "${testcvs} -q tag -b br" "T file1"
	  dotest keywordlog-7 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"
d11770 2
a11771 9
	  cd ../../2/first-dir
	  dotest keywordlog-8 "${testcvs} -q update" "[UP] file1"
	  dotest keywordlog-9 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"
	  cd ../../1/first-dir
d11773 42
a11814 16
	  echo "change" >> file1
	  dotest keywordlog-10 "${testcvs} ci -m modify file1" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest keywordlog-11 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"
d11816 8
a11823 12
	  cd ../../2/first-dir
	  dotest keywordlog-12 "${testcvs} -q update" "[UP] file1"
	  dotest keywordlog-13 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"
d11825 8
a11832 57
	  cd ../../1/first-dir
	  dotest keywordlog-14 "${testcvs} -q update -r br" "[UP] file1"
	  echo br-change >>file1
	  dotest keywordlog-15 "${testcvs} -q ci -m br-modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"
	  dotest keywordlog-16 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
	  cd ../../2/first-dir
	  dotest keywordlog-17 "${testcvs} -q update -r br" "[UP] file1"
	  dotest keywordlog-18 "cat file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
	  cd ../..
	  dotest keywordlog-19 "${testcvs} -q co -p -r br first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2\.2\.1  [0-9/]* [0-9:]*  ${username}
xx br-modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
br-change"
	  dotest keywordlog-20 "${testcvs} -q co -p first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.3  [0-9/]* [0-9:]*  ${username}
xx modify
xx
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx
change"
	  dotest keywordlog-21 "${testcvs} -q co -p -r 1.2 first-dir/file1" \
"xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.2  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"
d11834 8
a11841 3
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11843 8
a11850 16
	head)
	  # Testing handling of the HEAD special tag.
	  # There are many cases involving added and removed files
	  # which we don't yet try to deal with.
	  # TODO: We also could be paying much closer attention to
	  # "head of the trunk" versus "head of the default branch".
	  # That is what "cvs import" is doing here (but I didn't really
	  # fully follow through on writing the tests for that case).
	  mkdir imp-dir
	  cd imp-dir
	  echo 'imported contents' >file1
	  # It may seem like we don't do much with file2, but do note that
	  # the "cvs diff" invocations do also diff file2 (and come up empty).
	  echo 'imported contents' >file2
	  dotest_sort head-1 "${testcvs} import -m add first-dir tag1 tag2" \
"
d11852 3
a11854 67
N first-dir/file1
N first-dir/file2
No conflicts created by this import"
	  cd ..
	  rm -r imp-dir
	  mkdir 1
	  cd 1
	  dotest head-2 "${testcvs} -q co first-dir" \
"U first-dir/file1
U first-dir/file2"
	  cd first-dir
	  echo 'add a line on trunk' >> file1
	  dotest head-3 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest head-4 "${testcvs} -q tag trunktag" "T file1
T file2"
	  echo 'add a line on trunk after trunktag' >> file1
	  dotest head-5 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest head-6 "${testcvs} -q tag -b br1" "T file1
T file2"
	  dotest head-7 "${testcvs} -q update -r br1" ""
	  echo 'modify on branch' >>file1
	  dotest head-8 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3\.2\.1; previous revision: 1\.3
done"
	  dotest head-9 "${testcvs} -q tag brtag" "T file1
T file2"
	  echo 'modify on branch after brtag' >>file1
	  dotest head-10 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3\.2\.2; previous revision: 1\.3\.2\.1
done"
	  # With no sticky tags, HEAD is the head of the trunk.
	  dotest head-trunk-setup "${testcvs} -q update -A" "[UP] file1"
	  dotest head-trunk-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # and diff thinks so too.  Case (a) from the comment in
	  # cvs.texinfo (Common options).
	  dotest_fail head-trunk-diff "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.3
retrieving revision 1\.3\.2\.2
diff -c -r1\.3 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.3
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,3 \*\*\*\*
--- 1,5 ----
  imported contents
  add a line on trunk
  add a line on trunk after trunktag
${PLUS} modify on branch
${PLUS} modify on branch after brtag"
d11856 1
a11856 9
	  # With a branch sticky tag, HEAD is the head of the trunk.
	  dotest head-br1-setup "${testcvs} -q update -r br1" "[UP] file1"
	  dotest head-br1-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # But diff thinks that HEAD is "br1".  Case (b) from cvs.texinfo.
	  # Probably people are relying on it.
	  dotest head-br1-diff "${testcvs} -q diff -c -r HEAD -r br1" ""
d11858 18
a11875 25
	  # With a nonbranch sticky tag on a branch,
	  # HEAD is the head of the trunk
	  dotest head-brtag-setup "${testcvs} -q update -r brtag" "[UP] file1"
	  dotest head-brtag-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # But diff thinks that HEAD is "brtag".  Case (c) from
	  # cvs.texinfo (the "strange, maybe accidental" case).
	  dotest_fail head-brtag-diff "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.3\.2\.1
retrieving revision 1\.3\.2\.2
diff -c -r1\.3\.2\.1 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.3\.2\.1
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 2,4 \*\*\*\*
--- 2,5 ----
  add a line on trunk
  add a line on trunk after trunktag
  modify on branch
${PLUS} modify on branch after brtag"
d11877 18
a11894 30
	  # With a nonbranch sticky tag on the trunk, HEAD is the head
	  # of the trunk, I think.
	  dotest head-trunktag-setup "${testcvs} -q update -r trunktag" \
"[UP] file1"
	  dotest head-trunktag-check "cat file1" "imported contents
add a line on trunk"
	  dotest head-trunktag-update "${testcvs} -q update -r HEAD -p file1" \
"imported contents
add a line on trunk
add a line on trunk after trunktag"
	  # Like head-brtag-diff, HEAD is the sticky tag.  Similarly
	  # questionable.
	  dotest_fail head-trunktag-diff \
	    "${testcvs} -q diff -c -r HEAD -r br1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.2
retrieving revision 1\.3\.2\.2
diff -c -r1\.2 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.2
--- file1	[0-9/]* [0-9:]*	1\.3\.2\.2
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1,2 \*\*\*\*
--- 1,5 ----
  imported contents
  add a line on trunk
${PLUS} add a line on trunk after trunktag
${PLUS} modify on branch
${PLUS} modify on branch after brtag"
d11896 17
a11912 4
	  # Also might test what happens if we setup with update -r
	  # HEAD.  In general, if sticky tags matter, does the
	  # behavior of "update -r <foo>" (without -p) depend on the
	  # sticky tags before or after the update?
d11914 17
a11930 24
	  # Note that we are testing both the case where this deletes
	  # a revision (file1) and the case where it does not (file2)
	  dotest_fail head-o0a "${testcvs} admin -o ::br1" \
"${PROG} [a-z]*: Administrating \.
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: cannot remove revision 1\.3\.2\.1 because it has tags
${PROG} [a-z]*: cannot modify RCS file for .file1.
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  dotest head-o0b "${testcvs} tag -d brtag" \
"${PROG} [a-z]*: Untagging \.
D file1
D file2"
	  dotest head-o1 "${testcvs} admin -o ::br1" \
"${PROG} [a-z]*: Administrating \.
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.3\.2\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11932 19
a11950 8
	tagdate)
	  # Test combining -r and -D.
	  mkdir 1; cd 1
	  dotest tagdate-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest tagdate-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
d11952 19
a11970 32
	  echo trunk-1 >file1
	  dotest tagdate-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest tagdate-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest tagdate-5 "${testcvs} -q tag -b br1" "T file1"
	  dotest tagdate-6 "${testcvs} -q tag -b br2" "T file1"
	  echo trunk-2 >file1
	  dotest tagdate-7 "${testcvs} -q ci -m modify-on-trunk" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  # We are testing -r -D where br1 is a (magic) branch without
	  # any revisions.  First the case where br2 doesn't have any
	  # revisions either:
	  dotest tagdate-8 "${testcvs} -q update -p -r br1 -D now" "trunk-1"
	  dotest tagdate-9 "${testcvs} -q update -r br2" "[UP] file1"
	  echo br2-1 >file1
	  dotest tagdate-10 "${testcvs} -q ci -m modify-on-br2" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done"
	  # Then the case where br2 does have revisions:
	  dotest tagdate-11 "${testcvs} -q update -p -r br1 -D now" "trunk-1"
a11971 4
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d11973 1
a11973 11
	multibranch2)
	  # Commit the first delta on branch A when there is an older
	  # branch, B, that already has a delta.  A and B come from the
	  # same branch point.  Then verify that branches A and B are
	  # in the right order.
	  mkdir 1; cd 1
	  dotest multibranch2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest multibranch2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
d11975 17
a11991 23
	  echo trunk-1 >file1
	  echo trunk-1 >file2
	  dotest multibranch2-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest multibranch2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest multibranch2-5 "${testcvs} -q tag -b A" "T file1
T file2"
	  dotest multibranch2-6 "${testcvs} -q tag -b B" "T file1
T file2"
d11993 17
a12009 12
	  dotest multibranch2-7 "${testcvs} -q update -r B" ''
	  echo branch-B >file1
	  echo branch-B >file2
	  dotest multibranch2-8 "${testcvs} -q ci -m modify-on-B" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.4\.1; previous revision: 1\.1
done"
d12011 17
a12027 9
	  dotest multibranch2-9 "${testcvs} -q update -r A" '[UP] file1
[UP] file2'
	  echo branch-A >file1
	  # When using cvs-1.9.20, this commit gets a failed assertion in rcs.c.
	  dotest multibranch2-10 "${testcvs} -q ci -m modify-on-A" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
d12029 19
a12047 28
	  dotest multibranch2-11 "${testcvs} -q log file1" \
"
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	B: 1\.1\.0\.4
	A: 1\.1\.0\.2
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;
branches:  1\.1\.2;  1\.1\.4;
add
----------------------------
revision 1\.1\.4\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;  lines: ${PLUS}1 -1
modify-on-B
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;  lines: ${PLUS}1 -1
modify-on-A
============================================================================="
d12049 19
a12067 21
	  # This one is more concise.
	  dotest multibranch2-12 "${testcvs} -q log -r1.1 file1" \
"
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	B: 1\.1\.0\.4
	A: 1\.1\.0\.2
keyword substitution: kv
total revisions: 3;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: $username;  state: Exp;
branches:  1\.1\.2;  1\.1\.4;
add
============================================================================="
a12068 3
	  # OK, try very much the same thing except we run update -j to
	  # bring the changes from B to A.  Probably tests many of the
	  # same code paths but might as well keep it separate, I guess.
d12070 1
a12070 17
	  dotest multibranch2-13 "${testcvs} -q update -r B" "[UP] file1
[UP] file2"
	  dotest multibranch2-14 "${testcvs} -q update -r A -j B file2" \
"[UP] file2
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
retrieving revision 1.1
retrieving revision 1.1.4.1
Merging differences between 1.1 and 1.1.4.1 into file2"
	  dotest multibranch2-15 "${testcvs} -q ci -m commit-on-A file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d12072 17
d12090 17
a12106 20
	admin)
	  # More "cvs admin" tests.
	  # The basicb-21 test tests rejecting an illegal option.
	  # For -l and -u, see "reserved" and "keyword" tests.
	  # "binfiles" test has a test of "cvs admin -k".
	  # "log2" test has tests of -t and -q options to cvs admin.
	  # "rcs" tests -b option also.
	  # For -o, see:
	  #   admin-22-o1 through admin-23 (various cases not involving ::)
	  #   binfiles2-o* (:rev, rev on trunk; rev:, deleting entire branch)
	  #   basica-o1 through basica-o3 (basic :: usage)
	  #   head-o1 (::branch, where this deletes a revision or is noop)
	  #   branches-o1 (::branch, similar, with different branch topology)
	  #   log-o1 (1.3.2.1::)
	  #   binfiles-o1 (1.3:: and ::1.3)
	  #   Also could be testing:
	  #     1.3.2.6::1.3.2.8
	  #     1.3.2.6::1.3.2
	  #     1.3.2.1::1.3.2.6
	  #     1.3::1.3.2.6 (error?  or synonym for ::1.3.2.6?)
d12108 19
a12126 6
	  mkdir 1; cd 1
	  dotest admin-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest admin-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
d12128 19
a12146 6
	  dotest_fail admin-3 "${testcvs} -q admin -i file1" \
"${PROG} admin: the -i option to admin is not supported
${PROG} admin: run add or import to create an RCS file
${PROG} \[admin aborted\]: specify ${PROG} -H admin for usage information"
	  dotest_fail admin-4 "${testcvs} -q log file1" \
"${PROG} [a-z]*: nothing known about file1"
a12147 30
	  # Set up some files, file2 a plain one and file1 with a revision
	  # on a branch.
	  touch file1 file2
	  dotest admin-5 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest admin-6 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  dotest admin-7 "${testcvs} -q tag -b br" "T file1
T file2"
	  dotest admin-8 "${testcvs} -q update -r br" ""
	  echo 'add a line on the branch' >> file1
	  dotest admin-9 "${testcvs} -q ci -m modify-on-branch" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest admin-10 "${testcvs} -q update -A" "U file1"
d12149 1
a12149 9
	  # Try to recurse with a numeric revision arg.
	  # If we wanted to comprehensive about this, we would also test
	  # this for -l, -u, and all the different -o syntaxes.
	  dotest_fail admin-10a "${testcvs} -q admin -b1.1.2" \
"${PROG} [a-z]*: while processing more than one file:
${PROG} \[[a-z]* aborted\]: attempt to specify a numeric revision"
	  dotest_fail admin-10b "${testcvs} -q admin -m1.1:bogus file1 file2" \
"${PROG} [a-z]*: while processing more than one file:
${PROG} \[[a-z]* aborted\]: attempt to specify a numeric revision"
d12151 17
a12167 8
	  # try a bad symbolic revision
	  dotest_fail admin-10c "${testcvs} -q admin -bBOGUS" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file1,v: Symbolic name BOGUS is undefined.
${PROG} [a-z]*: cannot modify RCS file for .file1.
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file2,v: Symbolic name BOGUS is undefined.
${PROG} [a-z]*: cannot modify RCS file for .file2."
d12169 19
a12187 58
	  # Note that -s option applies to the new default branch, not
	  # the old one.
	  # Also note that the implementation of -a via "rcs" requires
	  # no space between -a and the argument.  However, we expect
	  # to change that once CVS parses options.
	  dotest admin-11 "${testcvs} -q admin -afoo,bar -abaz \
-b1.1.2 -cxx -U -sfoo file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-11a "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch: 1\.1\.2
locks:
access list:
	foo
	bar
	baz
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="
	  dotest admin-12 "${testcvs} -q admin -bbr file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-12a "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch: 1\.1\.2
locks:
access list:
	foo
	bar
	baz
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="
d12189 19
a12207 21
	  # "cvs log" doesn't print the comment leader.  RCS 5.7 will print
	  # the comment leader only if one specifies "-V4" to rlog.  So it
	  # seems like the only way to test it is by looking at the RCS file
	  # directly.  This also serves as a test of exporting RCS files
	  # (analogous to the import tests in "rcs").
	  # Rather than try to write a rigorous check for whether the
	  # file CVS exports is legal, we just write a simpler
	  # test for what CVS actually exports, and figure we can revise
	  # the check as needed (within the confines of the RCS5 format as
	  # documented in RCSFILES).
	  dotest admin-13 "cat ${CVSROOT_DIRNAME}/first-dir/file1,v" \
"head	1\.1;
branch	1\.1\.2;
access
	foo
	bar
	baz;
symbols
	br:1\.1\.0\.2;
locks;
comment	@@xx@@;
d12210 1
a12210 5
1\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches
	1\.1\.2\.1;
next	;
d12212 21
a12232 4
1\.1\.2\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
branches;
next	;
d12234 21
d12256 2
a12257 2
desc
@@@@
d12259 21
d12281 4
a12284 6
1\.1
log
@@add
@@
text
@@@@
d12286 10
d12297 10
a12306 33
1\.1\.2\.1
log
@@modify-on-branch
@@
text
@@a0 1
add a line on the branch
@@"
	  dotest admin-14 "${testcvs} -q admin -aauth3 -aauth2,foo \
-soneone:1.1 -m1.1:changed-log-message -ntagone: file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  dotest admin-15 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.1
branch:
locks: strict
access list:
	auth3
	auth2
	foo
symbolic names:
	tagone: 1\.1
	br: 1\.1\.0\.2
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: oneone;
changed-log-message
============================================================================="
d12308 10
a12317 31
	  dotest admin-16 "${testcvs} -q admin \
-A${CVSROOT_DIRNAME}/first-dir/file2,v -b -L -Nbr:1.1 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-17 "${testcvs} -q log file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	bar
	baz
	auth3
	auth2
symbolic names:
	br: 1\.1
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="
d12319 10
a12328 30
	  dotest_fail admin-18 "${testcvs} -q admin -nbr:1.1.2 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file1,v: symbolic name br already bound to 1\.1
${PROG} [a-z]*: cannot modify RCS file for .file1."
	  dotest admin-19 "${testcvs} -q admin -ebaz -ebar,auth3 -nbr file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-20 "${testcvs} -q log file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	auth2
symbolic names:
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.2;
add
----------------------------
revision 1.1.2.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: foo;  lines: ${PLUS}1 -0
modify-on-branch
============================================================================="
d12330 10
a12339 9
	  # OK, this is starting to get ridiculous, in terms of
	  # testing a feature (access lists) which doesn't do anything
	  # useful, but what about nonexistent files and
	  # relative pathnames in admin -A?
	  dotest_fail admin-19a-nonexist \
"${testcvs} -q admin -A${TESTDIR}/foo/bar file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} [a-z]*: Couldn't open rcs file .${TESTDIR}/foo/bar.: No such file or directory
${PROG} \[[a-z]* aborted\]: cannot continue"
d12341 10
a12350 3
	  # In the remote case, we are cd'd off into the temp directory
	  # and so these tests give "No such file or directory" errors.
	  if test "x$remote" = xno; then
d12352 4
a12355 21
	  dotest admin-19a-admin "${testcvs} -q admin -A../../cvsroot/first-dir/file2,v file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  dotest admin-19a-log "${testcvs} -q log -h -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
	foo
	auth2
	auth3
keyword substitution: kv
total revisions: 2
============================================================================="
	  # Put the access list back, to avoid special cases later.
	  dotest admin-19a-fix "${testcvs} -q admin -eauth3 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
	  fi # end of tests skipped for remote
d12357 8
a12364 120
	  # Add another revision to file2, so we can delete one.
	  echo 'add a line' >> file2
	  dotest admin-21 "${testcvs} -q ci -m modify file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest admin-22 "${testcvs} -q admin -o1.1 file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
deleting revision 1\.1
done"
	  # Test admin -o.  More variants that we could be testing:
	  # * REV: [on branch]
	  # * REV1:REV2 [deleting whole branch]
	  # * high branch numbers (e.g. 1.2.2.3.2.3)
	  # ... and probably others.  See RCS_delete_revs for ideas.

	  echo first rev > aaa
	  dotest admin-22-o1 "${testcvs} add aaa" \
"${PROG} [a-z]*: scheduling file .aaa. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest admin-22-o2 "${testcvs} -q ci -m first aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
done
Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
initial revision: 1\.1
done"
	  echo second rev >> aaa
	  dotest admin-22-o3 "${testcvs} -q ci -m second aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.2; previous revision: 1\.1
done"
	  echo third rev >> aaa
	  dotest admin-22-o4 "${testcvs} -q ci -m third aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3; previous revision: 1\.2
done"
	  echo fourth rev >> aaa
	  dotest admin-22-o5 "${testcvs} -q ci -m fourth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.4; previous revision: 1\.3
done"
	  echo fifth rev >>aaa
	  dotest admin-22-o6 "${testcvs} -q ci -m fifth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.5; previous revision: 1\.4
done"
	  echo sixth rev >> aaa
	  dotest admin-22-o7 "${testcvs} -q ci -m sixth aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.6; previous revision: 1\.5
done"
	  dotest admin-22-o8 "${testcvs} admin -l1.6 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
1\.6 locked
done"
	  dotest admin-22-o9 "${testcvs} log -r1.6 aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.6
branch:
locks: strict
	${username}: 1\.6
access list:
symbolic names:
keyword substitution: kv
total revisions: 6;	selected revisions: 1
description:
----------------------------
revision 1\.6	locked by: ${username};
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
sixth
============================================================================="
	  dotest_fail admin-22-o10 "${testcvs} admin -o1.5: aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/aaa,v: can't remove locked revision 1\.6
${PROG} [a-z]*: cannot modify RCS file for .aaa."
	  dotest admin-22-o11 "${testcvs} admin -u aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
1\.6 unlocked
done"
	  dotest admin-22-o12 "${testcvs} admin -o1.5: aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.6
deleting revision 1\.5
done"
	  dotest admin-22-o13 "${testcvs} log aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.4
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 4;	selected revisions: 4
description:
----------------------------
revision 1\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
fourth
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
third
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
second
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
first
============================================================================="
d12366 8
a12373 81
	  dotest admin-22-o14 "${testcvs} tag -b -r1.3 br1 aaa" "T aaa"
	  dotest admin-22-o15 "${testcvs} update -rbr1 aaa" "U aaa"
	  echo new branch rev >> aaa
	  dotest admin-22-o16 "${testcvs} ci -m new-branch aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.1; previous revision: 1\.3
done"
	  dotest_fail admin-22-o17 "${testcvs} admin -o1.2:1.4 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.4
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/aaa,v: can't remove branch point 1\.3
${PROG} [a-z]*: cannot modify RCS file for .aaa."
	  dotest admin-22-o18 "${testcvs} update -p -r1.4 aaa" \
"===================================================================
Checking out aaa
RCS:  ${TESTDIR}/cvsroot/first-dir/aaa,v
VERS: 1\.4
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
first rev
second rev
third rev
fourth rev"
	  echo second branch rev >> aaa
	  dotest admin-22-o19 "${testcvs} ci -m branch-two aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.2; previous revision: 1\.3\.2\.1
done"
	  echo third branch rev >> aaa
	  dotest admin-22-o20 "${testcvs} ci -m branch-three aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.3; previous revision: 1\.3\.2\.2
done"
	  echo fourth branch rev >> aaa
	  dotest admin-22-o21 "${testcvs} ci -m branch-four aaa" \
"Checking in aaa;
${TESTDIR}/cvsroot/first-dir/aaa,v  <--  aaa
new revision: 1\.3\.2\.4; previous revision: 1\.3\.2\.3
done"
	  dotest admin-22-o22 "${testcvs} admin -o:1.3.2.3 aaa" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
deleting revision 1\.3\.2\.1
deleting revision 1\.3\.2\.2
deleting revision 1\.3\.2\.3
done"
	  dotest admin-22-o23 "${testcvs} log aaa" "
RCS file: ${TESTDIR}/cvsroot/first-dir/aaa,v
Working file: aaa
head: 1\.4
branch:
locks: strict
access list:
symbolic names:
	br1: 1\.3\.0\.2
keyword substitution: kv
total revisions: 5;	selected revisions: 5
description:
----------------------------
revision 1\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
fourth
----------------------------
revision 1\.3
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
branches:  1\.3\.2;
third
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
second
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
first
----------------------------
revision 1\.3\.2\.4
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}4 -0
branch-four
============================================================================="
d12375 8
a12382 8
	  dotest admin-22-o24 "${testcvs} -q update -p -r 1.3.2.4 aaa" \
"first rev
second rev
third rev
new branch rev
second branch rev
third branch rev
fourth branch rev"
d12384 8
a12391 25
	  # The bit here about how there is a "tagone" tag pointing to
	  # a nonexistent revision is documented by rcs.  I dunno, I
	  # wonder whether the "cvs admin -o" should give a warning in
	  # this case.
	  dotest admin-23 "${testcvs} -q log file2" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
Working file: file2
head: 1\.2
branch:
locks: strict
access list:
	auth3
	auth2
	foo
symbolic names:
	tagone: 1\.1
	br: 1\.1\.0\.2
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
modify
============================================================================="
d12393 10
a12402 8
	  dotest admin-25 "cat ${CVSROOT_DIRNAME}/first-dir/file1,v" \
"head	1\.1;
access
	foo
	auth2;
symbols;
locks; strict;
comment	@@xx@@;
d12404 10
d12415 1
a12415 5
1\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches
	1\.1\.2\.1;
next	;
d12417 10
a12426 4
1\.1\.2\.1
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
branches;
next	;
d12428 10
d12439 10
a12448 2
desc
@@@@
d12450 10
d12461 12
a12472 6
1\.1
log
@@add
@@
text
@@@@
d12474 12
d12487 1
a12487 13
1\.1\.2\.1
log
@@modify-on-branch
@@
text
@@a0 1
add a line on the branch
@@"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;
d12489 12
a12500 11
	reserved)
	  # Tests of reserved checkouts.  Eventually this will test
	  # rcslock.pl (or equivalent) and all kinds of stuff.  Right
	  # now it just does some very basic checks on cvs admin -u
	  # and cvs admin -l.
	  # Also should test locking on a branch (and making sure that
	  # locks from one branch don't get mixed up with those from
	  # another.  Both the case where one of the branches is the
	  # main branch, and in which neither one is).
	  # See also test keyword, which tests that keywords and -kkvl
	  # do the right thing in the presence of locks.
d12502 12
a12513 18
	  # The usual setup, directory first-dir containing file file1.
	  mkdir 1; cd 1
	  dotest reserved-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest reserved-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  touch file1
	  dotest reserved-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest reserved-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
d12515 12
a12526 20
	  dotest reserved-5 "${testcvs} -q admin -l file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 locked
done"
	  dotest reserved-6 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
	${username}: 1\.1
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1	locked by: ${username};
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add
============================================================================="
d12528 12
a12539 6
	  # Note that this just tests the owner of the lock giving
	  # it up.  It doesn't test breaking a lock.
	  dotest reserved-7 "${testcvs} -q admin -u file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
1\.1 unlocked
done"
d12541 14
a12554 15
	  dotest reserved-8 "${testcvs} log -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
add
============================================================================="
d12556 14
a12569 7
	  # rcslock.pl tests.  Of course, the point isn't to test
	  # rcslock.pl from the distribution but equivalent
	  # functionality (for example, many sites may have an old
	  # rcslock.pl).  The functionality of this hook falls
	  # short of the real rcslock.pl though.
	  # Note that we can use rlog or look at the RCS file directly,
	  # but we can't use "cvs log" because "cvs commit" has a lock.
d12571 3
a12573 14
	  cat >${TESTDIR}/lockme <<EOF
#!${TESTSHELL}
line=\`grep <\$1/\$2,v 'locks ${username}:1\.[0-9];'\`
if test -z "\$line"; then
  # It isn't locked
  exit 0
else
  user=\`echo \$line | sed -e 's/locks \\(${username}\\):[0-9.]*;.*/\\1/'\`
  version=\`echo \$line | sed -e 's/locks ${username}:\\([0-9.]*\\);.*/\\1/'\`
  echo "\$user has file a-lock locked for version  \$version"
  exit 1
fi
EOF
	  chmod +x ${TESTDIR}/lockme
d12575 1
a12575 15
	  echo stuff > a-lock
	  dotest reserved-9 "${testcvs} add a-lock" \
"${PROG} [a-z]*: scheduling file .a-lock. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest reserved-10 "${testcvs} -q ci -m new a-lock" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a-lock,v
done
Checking in a-lock;
${TESTDIR}/cvsroot/first-dir/a-lock,v  <--  a-lock
initial revision: 1\.1
done"
	  # FIXME: the contents of CVSROOT fluctuate a lot
	  # here. Maybe the expect pattern should just
	  # confirm that commitinfo is one of the files checked out,
	  # but for now we just check that CVS exited with success.
d12577 5
a12581 52
	  if ${testcvs} -q co CVSROOT >>${LOGFILE} ; then
	    pass reserved-11
	  else
	    fail reserved-11
	  fi
	  cd CVSROOT
	  echo "DEFAULT ${TESTDIR}/lockme" >>commitinfo
	  dotest reserved-12 "${testcvs} -q ci -m rcslock commitinfo" \
"Checking in commitinfo;
${TESTDIR}/cvsroot/CVSROOT/commitinfo,v  <--  commitinfo
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..; cd first-dir

	  # Simulate (approximately) what a-lock would look like
	  # if someone else had locked revision 1.1.
	  sed -e 's/locks; strict;/locks fred:1.1; strict;/' ${TESTDIR}/cvsroot/first-dir/a-lock,v > a-lock,v
	  chmod 644 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  dotest reserved-13 "mv a-lock,v ${TESTDIR}/cvsroot/first-dir/a-lock,v"
	  chmod 444 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  echo more stuff >> a-lock
	  dotest_fail reserved-13b "${testcvs} ci -m '' a-lock" \
"fred has file a-lock locked for version  1\.1
${PROG} [a-z]*: Pre-commit check failed
${PROG} \[[a-z]* aborted\]: correct above errors first!"

	  dotest reserved-14 "${testcvs} admin -u1.1 a-lock" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a-lock,v
1\.1 unlocked
done"
	  dotest reserved-15 "${testcvs} -q ci -m success a-lock" \
"Checking in a-lock;
${TESTDIR}/cvsroot/first-dir/a-lock,v  <--  a-lock
new revision: 1\.2; previous revision: 1\.1
done"

	  # undo commitinfo changes
	  cd ../CVSROOT
	  echo '# vanilla commitinfo' >commitinfo
	  dotest reserved-16 "${testcvs} -q ci -m back commitinfo" \
"Checking in commitinfo;
${TESTDIR}/cvsroot/CVSROOT/commitinfo,v  <--  commitinfo
new revision: 1\.3; previous revision: 1\.2
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..; rm -r CVSROOT; cd first-dir

	  cd ../..
	  rm -r 1
	  rm ${TESTDIR}/lockme
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
a13441 3
	  cd ..
	  rm -rf diffmerge2
	  rm -rf ${CVSROOT_DIRNAME}/diffmerge2
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d555 1
a555 2
	tests="${tests} rcslib multibranch import importb importc"
	tests="${tests} join join2 join3"
d559 1
a559 1
	tests="${tests} cvsadm emptydir abspath toplevel"
d566 1
a566 5
	tests="${tests} serverpatch log log2 ann crerepos rcs rcs2"
	tests="${tests} history"
	tests="${tests} big modes modes2 stamps"
	# PreservePermissions stuff: permissions, symlinks et al.
	tests="${tests} perms symlinks hardlinks"
d1069 25
d1108 12
d1127 1
a3659 1
		# importc -- bunch o' files in bunch o' directories
a3974 50
	importc)
	  # Test importing a bunch o' files in a bunch o' directories.
	  mkdir 1; cd 1
	  mkdir adir bdir cdir
	  mkdir adir/sub1 adir/sub2
	  mkdir adir/sub1/ssdir
	  mkdir bdir/subdir
	  touch adir/sub1/file1 adir/sub2/file2 adir/sub1/ssdir/ssfile
	  touch bdir/subdir/file1
	  touch cdir/cfile
	  dotest_sort importc-1 \
"${testcvs} import -m import-it first-dir vendor release" \
"

N first-dir/adir/sub1/file1
N first-dir/adir/sub1/ssdir/ssfile
N first-dir/adir/sub2/file2
N first-dir/bdir/subdir/file1
N first-dir/cdir/cfile
No conflicts created by this import
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/adir
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/adir/sub1
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/adir/sub1/ssdir
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/adir/sub2
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/bdir
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/bdir/subdir
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/first-dir/cdir"
	  cd ..
	  mkdir 2; cd 2
	  dotest importc-2 "${testcvs} -q co first-dir" \
"U first-dir/adir/sub1/file1
U first-dir/adir/sub1/ssdir/ssfile
U first-dir/adir/sub2/file2
U first-dir/bdir/subdir/file1
U first-dir/cdir/cfile"
	  cd first-dir
	  dotest importc-3 "${testcvs} update adir/sub1" \
"${PROG} [a-z]*: Updating adir/sub1
${PROG} [a-z]*: Updating adir/sub1/ssdir"
	  dotest importc-4 "${testcvs} update adir/sub1 bdir/subdir" \
"${PROG} [a-z]*: Updating adir/sub1
${PROG} [a-z]*: Updating adir/sub1/ssdir
${PROG} [a-z]*: Updating bdir/subdir"
	  cd ..

	  cd ..
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a7289 9
	  dotest_fail cvsadm-2d3-1 "${testcvs} co -d dir/dir2 1mod" \
"${PROG} [a-z]*: cannot chdir to dir: No such file or directory
${PROG} [a-z]*: ignoring module 1mod"

	  if test "$remote" = no; then
	  # Remote can't handle this, even with the "mkdir dir".
	  # This was also true of CVS 1.9.

	  mkdir dir
d7295 2
a7296 1
	  dotest_fail cvsadm-2d3d "test -f dir/CVS/Repository" ""
a7300 1
	  mkdir dir
d7306 2
a7311 1
	  mkdir dir
d7317 2
a7322 1
	  mkdir dir
d7328 2
a7333 1
	  mkdir dir
d7339 2
a7344 1
	  mkdir dir
d7350 2
a7492 1
	  mkdir dir
d7498 2
a7505 1
	  mkdir dir
d7511 2
a7518 1
	  mkdir dir
d7524 2
a7531 1
	  mkdir dir
d7537 2
a7544 1
	  mkdir dir
d7550 2
a7559 1
	  mkdir dir
d7565 2
a7574 2
	  fi # end of tests to be skipped for remote

a7591 83
	emptydir)
	  # Various tests of the Emptydir (CVSNULLREPOS) code.  See also:
	  #   cvsadm: tests of Emptydir in various module definitions
	  #   basicb: Test that "Emptydir" is non-special in ordinary contexts

	  mkdir 1; cd 1
	  dotest emptydir-1 "${testcvs} co CVSROOT/modules" \
"U CVSROOT/modules"
	  echo "# Module defs for emptydir tests" > CVSROOT/modules
	  echo "2d1mod -d dir2d1/sub2d1 mod1" >> CVSROOT/modules

	  dotest emptydir-2 "${testcvs} ci -m add-modules" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining CVSROOT
Checking in CVSROOT/modules;
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  rm -rf CVS CVSROOT

	  mkdir ${CVSROOT_DIRNAME}/mod1
	  # Populate.  Not sure we really need to do this.
	  dotest emptydir-3 "${testcvs} co mod1" \
"${PROG} [a-z]*: Updating mod1"
	  echo "file1" > mod1/file1
	  dotest emptydir-4 "${testcvs} add mod1/file1" \
"${PROG} [a-z]*: scheduling file .mod1/file1. for addition
${PROG} [a-z]*: use '${PROG} commit' to add this file permanently"
	  dotest emptydir-5 "${testcvs} -q ci -m yup mod1" \
"RCS file: ${CVSROOT_DIRNAME}/mod1/file1,v
done
Checking in mod1/file1;
${CVSROOT_DIRNAME}/mod1/file1,v  <--  file1
initial revision: 1\.1
done"
	  rm -r mod1 CVS
	  # End Populate.

	  dotest emptydir-6 "${testcvs} co 2d1mod" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1"
	  cd dir2d1
	  touch emptyfile
	  # The fact that CVS lets us add a file here is a CVS bug, right?
	  # I can just make this an error message (on the add and/or the
	  # commit) without getting flamed, right?
	  # Right?
	  # Right?
	  dotest emptydir-7 "${testcvs} add emptyfile" \
"${PROG} [a-z]*: scheduling file .emptyfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest emptydir-8 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/CVSROOT/Emptydir/emptyfile,v
done
Checking in emptyfile;
${TESTDIR}/cvsroot/CVSROOT/Emptydir/emptyfile,v  <--  emptyfile
initial revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  rm -r CVS dir2d1

	  # OK, while we have an Emptydir around, test a few obscure
	  # things about it.
	  mkdir edir; cd edir
	  dotest emptydir-9 "${testcvs} -q co -l CVSROOT" \
"U CVSROOT${DOTSTAR}"
	  cd CVSROOT
	  dotest_fail emptydir-10 "test -d Emptydir" ''
	  # This tests the code in find_dirs which skips Emptydir.
	  dotest emptydir-11 "${testcvs} -q -n update -d -P" ''
	  cd ../..
	  rm -r edir

	  cd ..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/mod1
	  # I guess for the moment the convention is going to be
	  # that we don't need to remove ${CVSROOT_DIRNAME}/CVSROOT/Emptydir
	  ;;

a7634 7
	  if test "$remote" = yes; then
	    dotest_fail abspath-2a "${testcvs} co -d ${TESTDIR}/1 mod1" \
"${PROG} \[server aborted\]: absolute pathname .${TESTDIR}/1. illegal for server"
	    dotest abspath-2a-try2 "${testcvs} co -d 1 mod1" \
"${PROG} [a-z]*: Updating 1
U 1/file1"
	  else
a7637 1
	  fi # remote workaround
a7660 29

	  # Note that for the same reason that the shell command
	  # "touch 1/2/3" requires directories 1 and 1/2 to already
	  # exist, we expect ${TESTDIR}/1 to already exist.  I believe
	  # this is the behavior of CVS 1.9 and earlier.
	  if test "$remote" = no; then
	  dotest_fail abspath-3.1 "${testcvs} co -d ${TESTDIR}/1/2 mod1" \
"${PROG} [a-z]*: cannot chdir to 1: No such file or directory
${PROG} [a-z]*: ignoring module mod1"
	  fi
	  dotest_fail abspath-3.2 "${testcvs} co -d 1/2 mod1" \
"${PROG} [a-z]*: cannot chdir to 1: No such file or directory
${PROG} [a-z]*: ignoring module mod1"
	  mkdir 1

	  if test "$remote" = yes; then
	    # The server wants the directory to exist, but that is
	    # a bug, it should only need to exist on the client side.
	    # See also cvsadm-2d3.
	    dotest_fail abspath-3a "${testcvs} co -d 1/2 mod1" \
"${PROG} [a-z]*: cannot chdir to 1: No such file or directory
${PROG} [a-z]*: ignoring module mod1"
	    cd 1
	    dotest abspath-3a-try2 "${testcvs} co -d 2 mod1" \
"${PROG} [a-z]*: Updating 2
U 2/file1"
	    cd ..
	    rm -r 1/CVS
	  else
a7663 1
	  fi # remote workaround
a7665 6

	  # For all the same reasons that we want "1" to already
	  # exist, we don't to mess with it to traverse it, for
	  # example by creating a CVS directory.

	  dotest_fail abspath-3c "test -d ${TESTDIR}/1/CVS" ''
d7673 1
a7673 5
	  if test "$remote" = yes; then
	    dotest_fail abspath-4 "${testcvs} co -d ${TESTDIR}/barf/sub mod1" \
"${PROG} \[server aborted\]: absolute pathname .${TESTDIR}/barf/sub. illegal for server"
	  else
	    dotest_fail abspath-4 "${testcvs} co -d ${TESTDIR}/barf/sub mod1" \
a7674 1
	  fi
d7681 1
a7681 8
	  if test "$remote" = yes; then
	    dotest abspath-5a "${testcvs} co -d 1 mod1 mod2" \
"${PROG} [a-z]*: Updating 1/mod1
U 1/mod1/file1
${PROG} [a-z]*: Updating 1/mod2
U 1/mod2/file2"
	  else
	    dotest abspath-5a "${testcvs} co -d ${TESTDIR}/1 mod1 mod2" \
a7685 1
	  fi # end remote workaround
d7697 1
a7697 11
	  if test "$remote" = yes; then
	    dotest abspath-6a "${testcvs} co -d 1 ." \
"${PROG} [a-z]*: Updating 1
${PROG} [a-z]*: Updating 1/CVSROOT
${DOTSTAR}
${PROG} [a-z]*: Updating 1/mod1
U 1/mod1/file1
${PROG} [a-z]*: Updating 1/mod2
U 1/mod2/file2"
	  else
	    dotest abspath-6a "${testcvs} co -d ${TESTDIR}/1 ." \
a7704 1
	  fi # end of remote workaround
a7715 33
	  # Test that an absolute pathname to some other directory
	  # doesn't mess with the current working directory.
	  mkdir 1
	  cd 1
	  if test "$remote" = yes; then
	    dotest_fail abspath-7a "${testcvs} -q co -d ../2 mod2" \
"${PROG} server: protocol error: .\.\./2. contains more leading \.\.
${PROG} \[server aborted\]: than the 0 which Max-dotdot specified"
	    cd ..
	    dotest abspath-7a-try2 "${testcvs} -q co -d 2 mod2" \
"U 2/file2"
	    cd 1
	  else
	  dotest abspath-7a "${testcvs} -q co -d ${TESTDIR}/2 mod2" \
"U ${TESTDIR}/2/file2"
	  fi # remote workaround
	  dotest abspath-7b "ls" ""
	  dotest abspath-7c "${testcvs} -q co mod1" \
"U mod1/file1"
	  cd mod1
	  if test "$remote" = yes; then
	    cd ../..
	    dotest abspath-7d "${testcvs} -q co -d 3 mod2" \
"U 3/file2"
	    cd 1/mod1
	  else
	  dotest abspath-7d "${testcvs} -q co -d ${TESTDIR}/3 mod2" \
"U ${TESTDIR}/3/file2"
	  fi # remote workaround
	  dotest abspath-7e "${testcvs} -q update -d" ""
	  cd ../..
	  rm -r 1 2 3

d7721 6
a7726 1
	  rm -rf ${CVSROOT_DIRNAME}/mod1 ${CVSROOT_DIRNAME}/mod2
d7736 1
a7736 3
	  # one it is (cvsadm, emptydir, &c).
	  # (On the other hand, should CVS care whether there is an
	  # Emptydir?  That would seem a bit odd).
d7897 1
a7897 1
sed <\$1 -e 's/^/x/' >${TESTDIR}/edit.new
d10523 1
a10523 3
	  # Tests of "cvs annotate".  See also:
	  #   basica-10  A simple annotate test
	  #   rcs        Annotate and the year 2000
a10628 16
	  # FIXCVS: shouldn't "-r 1.2.0.2" be the same as "-r br"?
	  dotest ann-12 "${testcvs} ann -r 1.2.0.2 file1" ""
	  dotest ann-13 "${testcvs} ann -r 1.2.2 file1" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.1          (${username} *[0-9a-zA-Z-]*): file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): and some
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): branched content"
a10986 23
	  # Intended behavior for "cvs annotate" is that it displays the
	  # last two digits of the year.  Make sure it does that rather
	  # than some bogosity like "100".
	  dotest rcs-4a "${testcvs} annotate file1" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (kingdon  24-Nov-96): This is the first line
1\.2          (kingdon  24-Nov-96): This is the third line
1\.2          (kingdon  24-Nov-96): This is the fourth line
1\.2          (kingdon  24-Nov-96): This is the fifth line
1\.2          (kingdon  24-Nov-96): This is the sixth line
1\.2          (kingdon  24-Nov-96): This is the seventh line
1\.2          (kingdon  24-Nov-96): This is the eighth line
1\.2          (kingdon  24-Nov-96): This is the ninth line
1\.2          (kingdon  24-Nov-96): This is the tenth line
1\.2          (kingdon  24-Nov-96): This is the eleventh line
1\.3          (kingdon  24-Nov-00): This is the twelfth line (and what a line it is)
1\.2          (kingdon  24-Nov-96): This is the thirteenth line"

	  # Probably should split this test into two at this point (file1
	  # above this line and file2 below), as the two share little
	  # data/setup.

d10988 1
a10988 3
	  # doc/RCSFILES and friends.  One subtle point is that none of
	  # the lines end with newlines; that is a feature which we
	  # should be testing.
d11163 4
d11209 2
a11260 137
	rcs2)
	  # More date tests.  Might as well do this as a separate
	  # test from "rcs", so that we don't need to perturb the
	  # "written by RCS 5.7" RCS file.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  # Significance of various dates:
	  # * At least one Y2K standard refers to recognizing 9 Sep 1999
	  #   (as an example of a pre-2000 date, I guess).
	  # * At least one Y2K standard refers to recognizing 1 Jan 2001
	  #   (as an example of a post-2000 date, I guess).
	  # * Many Y2K standards refer to 2000 being a leap year.
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head 1.7; access; symbols; locks; strict;
1.7 date 2004.08.31.01.01.01; author sue; state; branches; next 1.6;
1.6 date 2004.02.29.01.01.01; author sue; state; branches; next 1.5;
1.5 date 2003.02.28.01.01.01; author sue; state; branches; next 1.4;
1.4 date 2001.01.01.01.01.01; author sue; state; branches; next 1.3;
1.3 date 2000.02.29.01.01.01; author sue; state; branches; next 1.2;
1.2 date 99.09.09.01.01.01; author sue; state; branches; next 1.1;
1.1 date 98.09.10.01.01.01; author sue; state; branches; next;
desc @@a test file@@
1.7 log @@@@ text @@head revision@@
1.6 log @@@@ text @@d1 1
a1 1
2004 was a great year for leaping@@
1.5 log @@@@ text @@d1 1
a1 1
2003 wasn't@@
1.4 log @@@@ text @@d1 1
a1 1
two year hiatus@@
1.3 log @@@@ text @@d1 1
a1 1
2000 is also a good year for leaping@@
1.2 log @@@@ text @@d1 1
a1 1
Tonight we're going to party like it's a certain year@@
1.1 log @@@@ text @@d1 1
a1 1
Need to start somewhere@@
EOF
	  dotest rcs2-1 "${testcvs} -q co first-dir" 'U first-dir/file1'
	  cd first-dir

	  # 9 Sep 1999
	  if ${testcvs} -q update -p -D '1999-09-09 11:30 UT' file1 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs2-2 "cat ${TESTDIR}/rcs4.tmp" \
"Tonight we're going to party like it's a certain year"
	  else
	    fail rcs2-2
	  fi
	  # 1 Jan 2001.
	  if ${testcvs} -q update -p -D '2001-01-01 11:30 UT' file1 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs2-3 "cat ${TESTDIR}/rcs4.tmp" \
"two year hiatus"
	  else
	    fail rcs2-3
	  fi
	  # 29 Feb 2000
	  if ${testcvs} -q update -p -D '2000-02-29 11:30 UT' file1 \
	      >${TESTDIR}/rcs4.tmp
	  then
	    dotest rcs2-4 "cat ${TESTDIR}/rcs4.tmp" \
"2000 is also a good year for leaping"
	  else
	    fail rcs2-4
	  fi
	  # 29 Feb 2003 is invalid
	  if ${testcvs} -q update -p -D '2003-02-29 11:30 UT' file1 \
	      >${TESTDIR}/rcs4.tmp 2>&1
	  then
	    fail rcs2-5
	  else
	    dotest rcs2-5 "cat ${TESTDIR}/rcs4.tmp" \
"${PROG} \[[a-z]* aborted\]: Can't parse date/time: 2003-02-29 11:30 UT"
	  fi
	  rm ${TESTDIR}/rcs4.tmp

	  cd ..
	  rm -r first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	history)
	  # CVSROOT/history tests:
	  # history: various "cvs history" invocations
	  # basic2: Generating the CVSROOT/history file via CVS commands.

	  # Put in some data for the history file (discarding what was
	  # there before).  Note that this file format is fixed; the
	  # user may wish to analyze data from a previous version of
	  # CVS.  If we phase out this format, it should be done
	  # slowly and carefully.
	  cat >${CVSROOT_DIRNAME}/CVSROOT/history <<EOF
O3395c677|anonymous|<remote>/*0|ccvs||ccvs
M339cafae|nk|<remote>|ccvs/src|1.229|sanity.sh
M339dc339|kingdon|~/work/*0|ccvs/src|1.231|sanity.sh
W33a6eada|anonymous|<remote>*4|ccvs/emx||Makefile.in
C3b235f50|kingdon|<remote>|ccvs/emx|1.3|README
M3b23af50|kingdon|~/work/*0|ccvs/doc|1.281|cvs.texinfo
EOF
	  dotest history-1 "${testcvs} history -e -a" \
"O 06/04 19:48 ${PLUS}0000 anonymous ccvs     =ccvs= <remote>/\*
W 06/17 19:51 ${PLUS}0000 anonymous       Makefile\.in ccvs/emx == <remote>/emx
M 06/10 21:12 ${PLUS}0000 kingdon   1\.231 sanity\.sh   ccvs/src == ~/work/ccvs/src
C 06/10 11:51 ${PLUS}0000 kingdon   1\.3   README      ccvs/emx == <remote>
M 06/10 17:33 ${PLUS}0000 kingdon   1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc
M 06/10 01:36 ${PLUS}0000 nk        1\.229 sanity\.sh   ccvs/src == <remote>"
	  if ${testcvs} history -e -a -D '10 Jun 1997 13:00 UT' \
	      >${TESTDIR}/output.tmp
	  then
	    dotest history-2 "cat ${TESTDIR}/output.tmp" \
"W 06/17 19:51 ${PLUS}0000 anonymous       Makefile\.in ccvs/emx == <remote>/emx
M 06/10 21:12 ${PLUS}0000 kingdon   1\.231 sanity\.sh   ccvs/src == ~/work/ccvs/src
C 06/10 11:51 ${PLUS}0000 kingdon   1\.3   README      ccvs/emx == <remote>
M 06/10 17:33 ${PLUS}0000 kingdon   1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc"
	  else
	    fail history-2
	  fi
	  if ${testcvs} history -e -a -D '10 Jun 2001 13:00 UT' \
	      >${TESTDIR}/output.tmp
	  then
	    # For reasons that are completely unclear to me, the number
	    # of spaces betwen "kingdon" and "1.281" is different than
	    # for the other tests.
	    dotest history-3 "cat ${TESTDIR}/output.tmp" \
"M 06/10 17:33 ${PLUS}0000 kingdon 1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc"
	  else
	    fail history-3
	  fi
	  rm ${TESTDIR}/output.tmp
	  ;;

a11443 45
	modes2)
	  # More tests of file permissions in the working directory
	  # and that sort of thing.

	  # The usual setup, file first-dir/aa with two revisions.
	  mkdir 1; cd 1
	  dotest modes2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest modes2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch aa
	  dotest modes2-3 "${testcvs} add aa" \
"${PROG} [a-z]*: scheduling file .aa. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest modes2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done"
	  echo "more money" >> aa
	  dotest modes2-5 "${testcvs} -q ci -m add" \
"Checking in aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
new revision: 1\.2; previous revision: 1\.1
done"

	  # OK, here is the test.  The idea is to see what
	  # No_Difference does if it can't open the file.
	  chmod a= aa
	  # If we don't change the st_mtime, CVS doesn't even try to read
	  # the file.
	  touch aa
	  dotest_fail modes2-6 "${testcvs} -q update -r 1.1 aa" \
"${PROG} \[update aborted\]: cannot open file aa for comparing: Permission denied" \
"${PROG} \[update aborted\]: reading aa: Permission denied"

	  chmod u+rwx aa
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a11583 196
	perms)
	  # short cut around checking out and committing CVSROOT
	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  echo 'PreservePermissions=yes' > ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config

	  mkdir 1; cd 1
	  dotest perms-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest perms-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  touch foo
	  chmod 431 foo
	  dotest perms-3 "${testcvs} add foo" \
"${PROG} [a-z]*: scheduling file .foo. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest perms-4 "${testcvs} -q ci -m ''" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/foo,v
done
Checking in foo;
${TESTDIR}/cvsroot/first-dir/foo,v  <--  foo
initial revision: 1\.1
done"

	  # Test checking out files with different permissions.
	  cd ../..
	  mkdir 2; cd 2
	  dotest perms-5 "${testcvs} -q co first-dir" "U first-dir/foo"
	  cd first-dir
	  if test "$remote" = no; then
	    # PreservePermissions not yet implemented for remote.
	    dotest perms-6 "ls -l foo" "-r---wx--x .* foo"
	  fi

	  cd ../..
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir

	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  touch ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config
	  ;;

	symlinks)
	  # short cut around checking out and committing CVSROOT
	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  echo 'PreservePermissions=yes' > ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config

	  mkdir 1; cd 1
	  dotest symlinks-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest symlinks-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  dotest symlinks-2.1 "ln -s ${TESTDIR}/fumble slink" ""
	  dotest symlinks-3 "${testcvs} add slink" \
"${PROG} [a-z]*: scheduling file .slink. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  if test "$remote" = yes; then
	    # Remote doesn't implement PreservePermissions, and in its
	    # absence the correct behavior is to follow the symlink.
	    dotest_fail symlinks-4 "${testcvs} -q ci -m ''" \
"${PROG} \[commit aborted\]: reading slink: No such file or directory"
	  else
	    dotest symlinks-4 "${testcvs} -q ci -m ''" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/slink,v
done
Checking in slink;
${TESTDIR}/cvsroot/first-dir/slink,v  <--  slink
initial revision: 1\.1
done"

	    # Test checking out symbolic links.
	    cd ../..
	    mkdir 2; cd 2
	    dotest symlinks-5 "${testcvs} -q co first-dir" "U first-dir/slink"
	    cd first-dir
	    dotest symlinks-6 "ls -l slink" \
"l[rwx\-]* .* slink -> ${TESTDIR}/fumble"
	  fi

	  cd ../..
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir

	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  touch ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config
	  ;;

	hardlinks)
	  # short cut around checking out and committing CVSROOT
	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  echo 'PreservePermissions=yes' > ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config

	  mkdir 1; cd 1
	  dotest hardlinks-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest hardlinks-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  # Make up some ugly filenames, to test that they get
	  # encoded properly in the delta nodes.  Note that `dotest' screws
	  # up if some arguments have embedded spaces.
	  if touch aaaa
	  then
	    pass hardlinks-2.1
	  else
	    fail hardlinks-2.1
	  fi

	  if ln aaaa b.b.b.b
	  then
	    pass hardlinks-2.2
	  else
	    fail hardlinks-2.2
	  fi

	  if ln aaaa 'dd dd dd'
	  then
	    pass hardlinks-2.3
	  else
	    fail hardlinks-2.3
	  fi

	  dotest hardlinks-3 "${testcvs} add [abd]*" \
"${PROG} [a-z]*: scheduling file .aaaa. for addition
${PROG} [a-z]*: scheduling file .b\.b\.b\.b. for addition
${PROG} [a-z]*: scheduling file .dd dd dd. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest hardlinks-4 "${testcvs} -q ci -m ''" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaaa,v
done
Checking in aaaa;
${TESTDIR}/cvsroot/first-dir/aaaa,v  <--  aaaa
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/b\.b\.b\.b,v
done
Checking in b\.b\.b\.b;
${TESTDIR}/cvsroot/first-dir/b\.b\.b\.b,v  <--  b\.b\.b\.b
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dd dd dd,v
done
Checking in dd dd dd;
${TESTDIR}/cvsroot/first-dir/dd dd dd,v  <--  dd dd dd
initial revision: 1\.1
done"
	  # Test checking out hardlinked files.
	  cd ../..
	  mkdir 2; cd 2
	  if test "$remote" = yes; then
	    # Remote does not implement PreservePermissions.
	    dotest hardlinks-5 "${testcvs} -q co first-dir" \
"U first-dir/aaaa
U first-dir/b\.b\.b\.b
U first-dir/dd dd dd"
	    cd first-dir
	    dotest hardlinks-6 "ls -l [abd]*" \
"-[rwx\-]* *1 .* aaaa
-[rwx\-]* *1 .* b\.b\.b\.b
-[rwx\-]* *1 .* dd dd dd"
	  else
	    dotest hardlinks-5 "${testcvs} -q co first-dir" \
"U first-dir/aaaa
U first-dir/b\.b\.b\.b
U first-dir/dd dd dd"
	    cd first-dir
	    # To make sure that the files are properly hardlinked, it
	    # would be nice to do `ls -i' and make sure all the inodes
	    # match.  But I think that would require expr to support
	    # tagged regexps, and I don't think we can rely on that.
	    # So instead we just see that each file has the right
	    # number of links. -twp
	    dotest hardlinks-6 "ls -l [abd]*" \
"-[rwx\-]* *3 .* aaaa
-[rwx\-]* *3 .* b\.b\.b\.b
-[rwx\-]* *3 .* dd dd dd"
	  fi

	  cd ../..
	  rm -rf 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir

	  rm -f ${CVSROOT_DIRNAME}/CVSROOT/config
	  touch ${CVSROOT_DIRNAME}/CVSROOT/config
	  chmod 444 ${CVSROOT_DIRNAME}/CVSROOT/config
	  ;;

d12134 18
a12151 5

	  # CVS 1.9 and older thought that HEAD is "brtag" (this was
	  # noted as "strange, maybe accidental").  But "br1" makes a
	  # whole lot more sense.
	  dotest head-brtag-diff "${testcvs} -q diff -c -r HEAD -r br1" ""
d12163 2
a12164 1
	  # Like head-brtag-diff, there is a non-branch sticky tag.
d12170 1
a12170 1
retrieving revision 1\.3
d12172 2
a12173 2
diff -c -r1\.3 -r1\.3\.2\.2
\*\*\* file1	[0-9/]* [0-9:]*	1\.3
d12176 1
a12176 1
\*\*\* 1,3 \*\*\*\*
d12180 1
a12180 1
  add a line on trunk after trunktag
a12998 186
	  # Tests of cvs admin -n.  Make use of the results of
	  # admin-1 through admin-25.
	  # FIXME: We probably shouldn't make use of those results;
	  # this test is way too long as it is.

	  # tagtwo should be a revision
	  #
	  dotest admin-26-1 "${testcvs} admin -ntagtwo:tagone file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
      	  
	  # br1 should be a branch
	  #
	  dotest admin-26-2 "${testcvs} admin -nbr1:br file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
      	  
	  # Attach some tags using RCS versions
	  #
	  dotest admin-26-3 "${testcvs} admin -ntagthree:1.1 file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"

	  dotest admin-26-4 "${testcvs} admin -nbr2:1.1.2 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"

	  dotest admin-26-5 "${testcvs} admin -nbr4:1.1.0.2 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
      	  
	  # Check results so far
	  #
	  dotest admin-26-6 "${testcvs} status -v file2" \
"===================================================================
File: file2            	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${TESTDIR}/cvsroot/first-dir/file2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	br4                      	(branch: 1\.1\.2)
	br2                      	(branch: 1\.1\.2)
	tagthree                 	(revision: 1\.1)
	br1                      	(branch: 1\.1\.2)
	tagtwo                   	(revision: 1\.1)
	tagone                   	(revision: 1\.1)
	br                       	(branch: 1\.1\.2)"

      	  
	  # Add a couple more revisions
	  #
	  echo "nuthr_line" >> file2
	  dotest admin-27-1 "${testcvs} commit -m nuthr_line file2"  \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.3; previous revision: 1\.2
done"

	  echo "yet_another" >> file2
	  dotest admin-27-2 "${testcvs} commit -m yet_another file2"  \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.4; previous revision: 1\.3
done"
      	  
	  # Fail trying to reattach existing tag with -n
	  #
	  dotest admin-27-3 "${testcvs} admin -ntagfour:1.1 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"

	  dotest_fail admin-27-4 "${testcvs} admin -ntagfour:1.3 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file2,v: symbolic name tagfour already bound to 1\.1
${PROG} [a-z]*: cannot modify RCS file for .file2."
      	  
	  # Succeed at reattaching existing tag, using -N
	  #
	  dotest admin-27-5 "${testcvs} admin -Ntagfour:1.3 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
      	  
	  # Fail on some bogus operations
	  # Try to attach to nonexistant tag
	  #
	  dotest_fail admin-28-1 "${testcvs} admin -ntagsix:tagfive file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: tag .tagfive. does not exist"
      	  
	  # Try a some nonexisting numeric target tags
	  #
	  dotest_fail admin-28-2 "${testcvs} admin -ntagseven:2.1 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: revision .2\.1. does not exist"

	  dotest_fail admin-28-3 "${testcvs} admin -ntageight:2.1.2 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: revision .2\.1\.2. does not exist"
      	  
	  # Try some invalid targets
	  #
	  dotest_fail admin-28-4 "${testcvs} admin -ntagnine:1.a.2 file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: tag .1\.a\.2. must start with a letter"

	  dotest_fail admin-28-5 "${testcvs} admin -ntagten:BO+GUS file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: tag .BO${PLUS}GUS. does not exist"
      	  
	  dotest_fail admin-28-6 "${testcvs} admin -nq.werty:tagfour file2"  \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
${PROG} \[[a-z]* aborted\]: tag .q\.werty. must not contain the characters ..*"

	  # Verify the archive
	  #
	  dotest admin-29 "cat ${TESTDIR}/cvsroot/first-dir/file2,v" \
"head	1\.4;
access
	auth3
	auth2
	foo;
symbols
	tagfour:1\.3
	br4:1\.1\.0\.2
	br2:1\.1\.0\.2
	tagthree:1\.1
	br1:1\.1\.0\.2
	tagtwo:1\.1
	tagone:1\.1
	br:1\.1\.0\.2;
locks; strict;
comment	@@# @@;


1\.4
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches;
next	1\.3;

1\.3
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches;
next	1\.2;

1\.2
date	[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
branches;
next	;


desc
@@@@


1\.4
log
@@yet_another
@@
text
@@add a line
nuthr_line
yet_another
@@


1\.3
log
@@nuthr_line
@@
text
@@d3 1
@@


1\.2
log
@@modify
@@
text
@@d2 1
@@"

a13143 5
	  # OK, now test "cvs admin -l" in the case where someone
	  # else has the file locked.
	  dotest_fail reserved-13c "${testcvs} admin -l a-lock" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a-lock,v
${PROG} \[[a-z]* aborted\]: Revision 1\.1 is already locked by fred"
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d515 2
a516 6
# clean any old remnants (we need the chmod because some tests make
# directories read-only)
if test -d ${TESTDIR}; then
    chmod -R a+wx ${TESTDIR}
    rm -rf ${TESTDIR}
fi
d552 1
a552 1
	tests="basica basicb basicc basic1 deep basic2 commit-readonly"
d560 1
a560 1
	tests="${tests} cvsadm emptydir abspath toplevel toplevel2"
a564 1
	tests="${tests} unedit-without-baserev"
d566 2
a567 2
	tests="${tests} binwrap3 mwrap info taginfo config"
	tests="${tests} serverpatch log log2 ann ann-id crerepos rcs rcs2"
d574 1
a574 1
	tests="${tests} head tagdate multibranch2 tag8k"
d896 1
d898 1
a898 6

	  # The top-level CVS directory is not created by default.
	  # I'm leaving basicb-1a and basicb-1b untouched, mostly, in
	  # case we decide that the default should be reversed...

	  dotest_fail basicb-1a "test -d CVS" ''
d904 1
a904 1
:	  dotest basicb-1b "cat CVS/Repository" \
d1009 1
a1009 4

	  # basicb-9a and basicb-9b: see note about basicb-1a

	  dotest_fail basicb-9a "test -d CVS" ''
d1015 1
a1015 1
:	  dotest basicb-9b "cat CVS/Repository" \
d1071 1
a1071 17
	  cd ..

	  # Try to remove all revisions in a file.
	  dotest_fail basicb-o1 "${testcvs} admin -o1.1 topfile" \
"RCS file: ${TESTDIR}/cvsroot/topfile,v
deleting revision 1\.1
${PROG} \[[a-z]* aborted\]: attempt to delete all revisions"
	  dotest basicb-o2 "${testcvs} -q update -d first-dir" \
"U first-dir/Emptydir/sfile1
U first-dir/sdir2/sfile2"
	  dotest_fail basicb-o3 \
"${testcvs} admin -o1.1:1.2 first-dir/sdir2/sfile2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir2/sfile2,v
deleting revision 1\.2
deleting revision 1\.1
${PROG} \[[a-z]* aborted\]: attempt to delete all revisions"
	  cd ..
d1111 4
a1114 5
	  # way to get it to work currently is to let CVS create it,
	  # and then blow it away (don't complain if it does not
	  # exist).  But that is perfectly legal; people who are used
	  # to the old behavior especially may be interested.
	  rm -rf CVS
a2020 41
	commit-readonly)
	  mkdir 1; cd 1
	  module=x

	  : > junk
	  dotest commit-readonly-1 "$testcvs -Q import -m . $module X Y" ''
	  dotest commit-readonly-2 "$testcvs -Q co $module" ''
	  cd $module

	  file=m

	  # Include an rcs keyword to be expanded.
	  echo '$Id''$' > $file

	  dotest commit-readonly-3 "$testcvs add $file" \
"${PROG} [a-z]*: scheduling file .$file. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest commit-readonly-4 "$testcvs -Q ci -m . $file" \
"RCS file: ${TESTDIR}/cvsroot/$module/$file,v
done
Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
initial revision: 1\.1
done"

	  echo line2 >> $file
	  # Make the file read-only.
	  chmod a-w $file

	  dotest commit-readonly-5 "$testcvs -Q ci -m . $file" \
"Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
new revision: 1\.2; previous revision: 1\.1
done"

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;


a3526 11
	  # Test behavior of symlinks in the repository.
	  dotest rcslib-symlink-1 "ln -s file1,v ${CVSROOT_DIRNAME}/first-dir/file2,v"
	  dotest rcslib-symlink-2 "${testcvs} update file2" "U file2"
	  echo "This is a change" >> file2
	  dotest rcslib-symlink-3 "${testcvs} ci -m because file2" \
"Checking in file2;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file2
new revision: 1\.1\.2\.2; previous revision: 1\.1\.2\.1
done"
	  dotest rcslib-symlink-4 "test -L ${CVSROOT_DIRNAME}/first-dir/file2,v"

a3757 1
		rm imported-f2-orig.tmp
a3985 27

	  echo modify >>cdir/cfile
	  dotest importc-5 \
"${testcvs} -q rtag -b -r release wip_test first-dir" ""
	  dotest importc-6 "${testcvs} -q update -r wip_test" "M cdir/cfile"

	  if test "$remote" = no; then
	    # This checkin should just succeed.  That it doesn't is a
	    # bug (CVS 1.9.16 through the present seem to have it; CVS
	    # 1.9 did not).
	    dotest_fail importc-7 "${testcvs} -q ci -m modify -r wip_test" \
"${PROG} [a-z]*: in directory adir/sub1/ssdir:
${PROG} \[[a-z]* aborted\]: there is no version here; do .cvs checkout. first"
	    # The workaround is to leave off the "-r wip_test".
	    dotest importc-8 "${testcvs} -q ci -m modify" \
"Checking in cdir/cfile;
${TESTDIR}/cvsroot/first-dir/cdir/cfile,v  <--  cfile
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done"
	  else
	    # Remote doesn't have the bug in the first place.
	    dotest importc-7 "${testcvs} -q ci -m modify -r wip_test" \
"Checking in cdir/cfile;
${TESTDIR}/cvsroot/first-dir/cdir/cfile,v  <--  cfile
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done"
	  fi
a5799 4
	  # Other CVS release tests:
	  #   info-cleanup-0 for "cvs -n release".
	  #   ignore-193 for the text of the question that cvs release asks.
	  #     Also for interactions with cvsignore.
d5824 2
a5825 3
	  cd ampermodule
	  dotest modules2-10 "${testcvs} add first-dir/amper1" \
"${PROG} [a-z]*: scheduling file .first-dir/amper1. for addition
a5826 1
	  cd ..
a6151 1
somewhat -a first-dir !first-dir/subdir
a6172 15
	  if test "$remote" = no; then
	    # This is strange behavior, in that the order of the
	    # "!first-dir/subdir" and "first-dir" matter, and it isn't
	    # clear that they should.  I suspect it is long-standing
	    # strange behavior but I haven't verified that.
	    dotest modules4-11a "${testcvs} -q co somewhat" \
"U first-dir/file1
U first-dir/subdir/file2"
	  else
	    # But remote seems to do it the other way.
	    dotest modules4-11a "${testcvs} -q co somewhat" "U first-dir/file1"
	    dotest_fail modules4-11b "test -d first-dir/subdir" ''
	  fi
	  rm -r first-dir

d6243 1
a6243 17
	  # First, set TopLevelAdmin=yes so we're sure to get
	  # top-level CVS directories.
	  mkdir 1; cd 1
	  dotest cvsadm-setup-1 "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "TopLevelAdmin=yes" >config
	  dotest cvsadm-setup-2 "${testcvs} -q ci -m yes-top-level" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
	  rm -r 1

	  # Second, check out the modules file and edit it.
d6299 13
a6311 14
	  dotest cvsadm-2 "${testcvs} -q co -l ." ''
	  mkdir mod1
	  mkdir mod1-2
	  mkdir mod2
	  mkdir mod2/sub2
	  mkdir mod2-2
	  mkdir mod2-2/sub2-2
	  dotest cvsadm-2a "${testcvs} add mod1 mod1-2 mod2 mod2/sub2 mod2-2 mod2-2/sub2-2" \
"Directory ${TESTDIR}/cvsroot/mod1 added to the repository
Directory ${TESTDIR}/cvsroot/mod1-2 added to the repository
Directory ${TESTDIR}/cvsroot/mod2 added to the repository
Directory ${TESTDIR}/cvsroot/mod2/sub2 added to the repository
Directory ${TESTDIR}/cvsroot/mod2-2 added to the repository
Directory ${TESTDIR}/cvsroot/mod2-2/sub2-2 added to the repository"
d6318 1
a6318 1
	  dotest cvsadm-2aa "${testcvs} add mod1/file1 mod1-2/file1-2 mod2/sub2/file2 mod2-2/sub2-2/file2-2" \
a7595 13
	  dotest cvsadm-cleanup-1 "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "# empty file" >config
	  dotest cvsadm-cleanup-2 "${testcvs} -q ci -m cvsadm-cleanup" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
          cd ..
          rm -rf CVSROOT CVS

d7621 2
a7622 1
"${PROG} [a-z]*: Examining CVSROOT
d7635 2
a7636 3
	  cd mod1
	  dotest emptydir-4 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
a7637 1
          cd ..
d7645 1
a7645 1
	  rm -rf mod1 CVS
d7670 1
a7670 1
	  rm -rf CVS dir2d1
d7710 4
a7713 10
	  cd mod1
	  dotest abspath-1ba "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use '${PROG} commit' to add this file permanently"
          cd ..
          cd mod2
	  dotest abspath-1bb "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add this file permanently"
          cd ..
d7796 1
a7796 1
	    rm -rf 1/CVS
a7936 15
	  # First set the TopLevelAdmin setting.
	  mkdir 1; cd 1
	  dotest toplevel-1a "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "TopLevelAdmin=yes" >config
	  dotest toplevel-1b "${testcvs} -q ci -m yes-top-level" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
	  rm -r 1

a8006 1

a8019 1
	  # First string is for local, second is for remote.
a8021 4
${PROG} [a-z]*: Updating top-dir" \
"${PROG} [a-z]*: warning: cannot make directory CVS in \.: Permission denied
${PROG} [a-z]*: in directory \.:
${PROG} [a-z]*: cannot open CVS/Entries for reading: No such file or directory
a8022 1

a8024 86
	  dotest toplevel-cleanup-1 "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "# empty file" >config
	  dotest toplevel-cleanup-2 "${testcvs} -q ci -m toplevel-cleanup" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/top-dir ${CVSROOT_DIRNAME}/second-dir
	  ;;

	toplevel2)
	  # Similar to toplevel, but test the case where TopLevelAdmin=no.

	  # First set the TopLevelAdmin setting.
	  mkdir 1; cd 1
	  dotest toplevel2-1a "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "TopLevelAdmin=no" >config
	  dotest toplevel2-1b "${testcvs} -q ci -m no-top-level" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
	  rm -r 1

	  # Now set up some directories and subdirectories
	  mkdir 1; cd 1
	  dotest toplevel2-1 "${testcvs} -q co -l ." ''
	  mkdir top-dir second-dir
	  dotest toplevel2-2 "${testcvs} add top-dir second-dir" \
"Directory ${TESTDIR}/cvsroot/top-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
	  cd top-dir

	  touch file1
	  dotest toplevel2-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest toplevel2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/top-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/top-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  cd ..

	  cd second-dir
	  touch file2
	  dotest toplevel2-3s "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest toplevel2-4s "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/second-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/second-dir/file2,v  <--  file2
initial revision: 1\.1
done"

	  cd ../..
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel2-5 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"

	  dotest toplevel2-6 "${testcvs} update top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  dotest toplevel2-7 "${testcvs} update"  \
"${PROG} [a-z]*: Updating top-dir"

	  dotest toplevel2-8 "${testcvs} update -d top-dir" \
"${PROG} [a-z]*: Updating top-dir"
	  # Contrast this with toplevel-9, which has TopLevelAdmin=yes.
	  dotest toplevel2-9 "${testcvs} update -d" \
"${PROG} [a-z]*: Updating top-dir"

a8025 20
	  rm -r 1; mkdir 1; cd 1
	  dotest toplevel2-10 "${testcvs} co top-dir" \
"${PROG} [a-z]*: Updating top-dir
U top-dir/file1"
	  # This tests more or less the same thing, in a particularly
	  # "real life" example.  With TopLevelAdmin=yes, this command
	  # would give us second-dir and CVSROOT directories too.
	  dotest toplevel2-11 "${testcvs} -q update -d" ""

	  dotest toplevel2-cleanup-1 "${testcvs} -q co CVSROOT/config" \
"U CVSROOT/config"
	  cd CVSROOT
	  echo "# empty file" >config
	  dotest toplevel2-cleanup-2 "${testcvs} -q ci -m toplevel2-cleanup" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
a8819 11
	  # OK, now change the tab to a space, and see that CVS gives
	  # a reasonable error (this is database corruption but CVS should
	  # not lose its mind).
	  sed -e 's/Fw2	/Fw2 /' <${CVSROOT_DIRNAME}/first-dir/CVS/fileattr \
	    >${CVSROOT_DIRNAME}/first-dir/CVS/fileattr.new
	  mv ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr.new \
	    ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
	  mkdir 2; cd 2
	  dotest_fail devcom3-10 "${testcvs} -Q co ." \
"${PROG} \[[a-z]* aborted\]: file attribute database corruption: tab missing in ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr"
	  cd ..
d8822 1
a8822 1
	  rm -rf 1 2
a8916 100
	unedit-without-baserev)
	  mkdir 1; cd 1
	  module=x

	  file=m
	  echo foo > $file
	  dotest unedit-without-baserev-1 \
	    "$testcvs -Q import -m . $module X Y" ''
	  dotest unedit-without-baserev-2 "$testcvs -Q co $module" ''
	  cd $module

	  dotest unedit-without-baserev-3 "$testcvs -Q edit $file" ''

	  echo add a line >> $file
	  rm -f CVS/Baserev

	  # This will fail on most systems.
	  if echo "yes" | ${testcvs} -Q unedit $file \
	    >${TESTDIR}/test.tmp 2>&1 ; then
	    dotest unedit-without-baserev-4 "cat ${TESTDIR}/test.tmp" \
"m has been modified; revert changes${QUESTION} ${PROG} unedit: m not mentioned in CVS/Baserev
${PROG} unedit: run update to complete the unedit"
	  else
	    fail unedit-without-baserev-4
	  fi

	  # SunOS4.1.4 systems make it this far, but with a corrupted
	  # CVS/Entries file.  Demonstrate the corruption!
	  dotest unedit-without-baserev-5 "cat CVS/Entries" \
	    "/$file/1\.1\.1\.1/.*"

	  if test "$remote" = yes; then
	    dotest unedit-without-baserev-6 "${testcvs} -q update" "U m"
	  else
	    dotest unedit-without-baserev-6 "${testcvs} -q update" \
"${PROG} update: warning: m was lost
U m"
	  fi

	  # OK, those were the easy cases.  Now tackle the hard one
	  # (the reason that CVS/Baserev was invented rather than just
	  # getting the revision from CVS/Entries).  This is very
	  # similar to watch4-10 through watch4-18 but with Baserev
	  # missing.
	  cd ../..
	  mkdir 2; cd 2
	  dotest unedit-without-baserev-7 "${testcvs} -Q co x" ''
	  cd x

	  dotest unedit-without-baserev-10 "${testcvs} edit m" ''
	  echo 'edited in 2' >m
	  cd ../..

	  cd 1/x
	  dotest unedit-without-baserev-11 "${testcvs} edit m" ''
	  echo 'edited in 1' >m
	  dotest unedit-without-baserev-12 "${testcvs} -q ci -m edit-in-1" \
"Checking in m;
${TESTDIR}/cvsroot/x/m,v  <--  m
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../..
	  cd 2/x
	  dotest unedit-without-baserev-13 "${testcvs} -q update" \
"RCS file: ${TESTDIR}/cvsroot/x/m,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.2
Merging differences between 1\.1\.1\.1 and 1\.2 into m
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in m
C m"
	  rm CVS/Baserev
	  if (echo yes | ${testcvs} unedit m) >${TESTDIR}/test.tmp 2>&1; then
	    dotest unedit-without-baserev-14 "cat ${TESTDIR}/test.tmp" \
"m has been modified; revert changes${QUESTION} ${PROG} unedit: m not mentioned in CVS/Baserev
${PROG} unedit: run update to complete the unedit"
	  else
	    fail unedit-without-baserev-14
	  fi
	  if test "$remote" = yes; then
	    dotest unedit-without-baserev-15 "${testcvs} -q update" "U m"
	  else
	    dotest unedit-without-baserev-15 "${testcvs} -q update" \
"${PROG} update: warning: m was lost
U m"
	  fi
	  # The following tests are kind of degenerate compared with
	  # watch4-16 through watch4-18 but might as well make sure that
	  # nothing seriously wrong has happened to the working directory.
	  dotest unedit-without-baserev-16 "cat m" 'edited in 1'
	  # Make sure CVS really thinks we are at 1.2.
	  dotest unedit-without-baserev-17 "${testcvs} -q update" ""
	  dotest unedit-without-baserev-18 "cat m" "edited in 1"

	  cd ../..
	  rm -rf 1
	  rm -r 2
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

a10076 1
	  # taginfo: taginfo
a10209 3
	  dotest_fail info-cleanup-0 "${testcvs} -n release -d CVSROOT" \
"${PROG} \[release aborted\]: cannot run command ${DOTSTAR}"

a10224 106
	taginfo)
	  # Tests of the CVSROOT/taginfo file.  See the comment at the
	  # "info" tests for a full list of administrative file tests.

	  # Tests to add:
	  #   -F to move
	  #   -d
	  #   rtag

	  mkdir 1; cd 1
	  dotest taginfo-1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
	  cd CVSROOT
	  cat >${TESTDIR}/1/loggit <<EOF
#!${TESTSHELL}
if test "\$1" = rejectme; then
  exit 1
else
  echo "\$@@" >>${TESTDIR}/1/taglog
  exit 0
fi
EOF
	  chmod +x ${TESTDIR}/1/loggit
	  echo "ALL ${TESTDIR}/1/loggit" >taginfo
	  dotest taginfo-2 "${testcvs} -q ci -m check-in-taginfo" \
"Checking in taginfo;
${TESTDIR}/cvsroot/CVSROOT/taginfo,v  <--  taginfo
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..

	  # taginfo-3 used to rely on the top-level CVS directory
	  # being created to add "first-dir" to the repository.  Since
	  # that won't happen anymore, we create the directory in the
	  # repository.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest taginfo-3 "${testcvs} -q co first-dir" ''

	  cd first-dir
	  echo first >file1
	  dotest taginfo-4 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest taginfo-5 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest taginfo-6 "${testcvs} -q tag tag1" "T file1"
	  dotest taginfo-7 "${testcvs} -q tag -b br" "T file1"
	  dotest taginfo-8 "${testcvs} -q update -r br" ""
	  echo add text on branch >>file1
	  dotest taginfo-9 "${testcvs} -q ci -m modify-on-br" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest taginfo-10 "${testcvs} -q tag -F -c brtag" "T file1"

	  dotest_fail taginfo-11 "${testcvs} -q tag rejectme" \
"${PROG} [a-z]*: Pre-tag check failed
${PROG} \[[a-z]* aborted\]: correct the above errors first!"

	  # When we are using taginfo to allow/disallow, it would be
	  # convenient to be able to use "cvs -n tag" to test whether
	  # the allow/disallow functionality is working as expected.
	  dotest taginfo-12 "${testcvs} -nq tag rejectme" "T file1"

	  # But when taginfo is used for logging, it is a pain for -n
	  # to call taginfo, since taginfo doesn't know whether -n was
	  # specified or not.
	  dotest taginfo-13 "${testcvs} -nq tag would-be-tag" "T file1"

	  # The "br" example should be passing 1.1.2 or 1.1.0.2.
	  # But it turns out that is very hard to implement, since
	  # check_fileproc doesn't know what branch number it will
	  # get.  Probably the whole thing should be re-architected
	  # so that taginfo only allows/denies tagging, and a new
	  # hook, which is done from tag_fileproc, does logging.
	  # That would solve this, some more subtle races, and also
	  # the fact that it is nice for users to run "-n tag foo" to
	  # see whether a tag would be allowed.  Failing that,
	  # I suppose passing "1.1.branch" or "branch" for "br"
	  # would be an improvement.
	  dotest taginfo-examine "cat ${TESTDIR}/1/taglog" \
"tag1 add ${TESTDIR}/cvsroot/first-dir file1 1.1
br add ${TESTDIR}/cvsroot/first-dir file1 1.1
brtag mov ${TESTDIR}/cvsroot/first-dir file1 1.1.2.1"

	  cd ..
	  cd CVSROOT
	  echo '# Keep life simple' > taginfo
	  dotest taginfo-cleanup-1 "${testcvs} -q ci -m check-in-taginfo" \
"Checking in taginfo;
${TESTDIR}/cvsroot/CVSROOT/taginfo,v  <--  taginfo
new revision: 1\.3; previous revision: 1\.2
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ..
	  cd ..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a10236 2
	  # We can't rely on specific revisions, since other tests
	  # might need to modify CVSROOT/config
d10240 1
a10240 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d10248 1
a10248 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d10256 1
a10256 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d10306 1
a10306 1
	  dotest serverpatch-6 "${testcvs} -q update -A first-dir" ''
a10844 2
	  dotest_fail ann-14 "${testcvs} ann -r bill-clintons-chastity file1" \
"${PROG} \[[a-z]* aborted\]: no such tag bill-clintons-chastity"
a10850 47
	ann-id)
	  # Demonstrate that cvs-1.9.28.1 improperly expands rcs keywords in
	  # the output of `cvs annotate' -- it uses values from the previous
	  # delta.  In this case, `1.1' instead of `1.2', even though it puts
	  # the proper version number on the prefix to each line of output.
	  mkdir 1; cd 1
	  dotest ann-id-1 "${testcvs} -q co -l ." ''
	  module=x
	  mkdir $module
	  dotest ann-id-2 "${testcvs} add $module" \
"Directory ${TESTDIR}/cvsroot/$module added to the repository"
	  cd $module

	  file=m
	  echo '$Id''$' > $file

	  dotest ann-id-3 "$testcvs add $file" \
"${PROG} [a-z]*: scheduling file .$file. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest ann-id-4 "$testcvs -Q ci -m . $file" \
"RCS file: ${TESTDIR}/cvsroot/$module/$file,v
done
Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
initial revision: 1\.1
done"

	  echo line2 >> $file
	  dotest ann-id-5 "$testcvs -Q ci -m . $file" \
"Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
new revision: 1\.2; previous revision: 1\.1
done"

	  # The version number after $file,v should be `1.2'.
	  # 1.9.28.1 puts `1.1' there.
	  dotest ann-id-6 "$testcvs -Q ann $file" \
"Annotations for $file
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1.2          ($username *[0-9a-zA-Z-]*): "'\$'"Id: $file,v 1.1 [0-9/]* [0-9:]* $username Exp "'\$'"
1.2          ($username *[0-9a-zA-Z-]*): line2"

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

d10892 1
a10892 1
	    rm -rf CVS
d10996 1
a10996 1
	  if test x`cat crerepos-dir/CVS/Repository` = xcrerepos-dir; then
a11261 2
	  # ' Match the single quote in above here doc -- for font-lock mode.

a11536 2
	  # ' Match the 3rd single quote in the here doc -- for font-lock mode.

d11847 1
d11849 1
a11849 2
	  # the file.  Note that some versions of "touch" require that we
	  # do this while the file is still writable.
a11850 1
	  chmod a= aa
a12991 85
	tag8k)
	  # In cvs-1.9.27, there is a bug that can cause an abort.
	  # It happens when you commit a change to a ,v file that has
	  # just the right amount of tag/branch info to align one of the
	  # semicolons in the branch info to be on a 8k-byte boundary.
	  # The result: rcsbuf_getkey got an abort.  This failure doesn't
	  # corrupt the ,v file -- that would be really serious.  But it
	  # does leave stale write locks that have to be removed manually.

	  mkdir 1
	  cd 1

	  module=x

	  : > junk
	  dotest tag8k-1 "$testcvs -Q import -m . $module X Y" ''
	  dotest tag8k-2 "$testcvs -Q co $module" ''
	  cd $module

	  file=m
	  : > $file
	  dotest tag8k-3 "$testcvs add $file" \
"${PROG} [a-z]*: scheduling file .$file. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest tag8k-4 "$testcvs -Q ci -m . $file" \
"RCS file: ${TESTDIR}/cvsroot/$module/$file,v
done
Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
initial revision: 1\.1
done"

	  # It seems there have to be at least two versions.
	  echo a > $file
	  dotest tag8k-5 "$testcvs -Q ci -m . $file" \
"Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
new revision: 1\.2; previous revision: 1\.1
done"

	  # Add just under 8K worth of tags.
	  t=TAG---------------------------------------------------------------------
	  t=$t$t
	  t=$t$t$t$t$t
	  # Now $t is 720 bytes long.

	  # Apply some tags with that long prefix.
	  dotest tag8k-6  "$testcvs -Q tag $t-0 $file" ''
	  dotest tag8k-7  "$testcvs -Q tag $t-1 $file" ''
	  dotest tag8k-8  "$testcvs -Q tag $t-2 $file" ''
	  dotest tag8k-9  "$testcvs -Q tag $t-3 $file" ''
	  dotest tag8k-10 "$testcvs -Q tag $t-4 $file" ''
	  dotest tag8k-11 "$testcvs -Q tag $t-5 $file" ''
	  dotest tag8k-12 "$testcvs -Q tag $t-6 $file" ''
	  dotest tag8k-13 "$testcvs -Q tag $t-7 $file" ''
	  dotest tag8k-14 "$testcvs -Q tag $t-8 $file" ''
	  dotest tag8k-15 "$testcvs -Q tag $t-9 $file" ''
	  dotest tag8k-16 "$testcvs -Q tag $t-a $file" ''

	  # Determine the length of the author value.
	  name=`sed -n 's/.*;	author \([^;]*\);.*/\1/p' ${TESTDIR}/cvsroot/$module/$file,v|head -1`
	  name_len=`expr length $name`

	  # CAREFUL: this will lose if $name is longer than 16.
	  # Then, form a string of length 16 - $name_len.
	  add_len=`expr 16 - $name_len`
	  suffix=`expr substr 1234567890123456 1 $add_len`

	  # Add a final tag with length chosen so that it will push the
	  # offset of the `;' in the 2nd occurrence of `;\tauthor' in the
	  # ,v file to exactly 8192.
	  dotest tag8k-17 "$testcvs -Q tag "x8bytes-$suffix" $file" ''

	  # This commit would fail with 1.9.27.
	  echo a >> $file
	  dotest tag8k-18 "$testcvs -Q ci -m . $file" \
"Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
new revision: 1\.3; previous revision: 1\.2
done"
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

a13002 1
	  #   basicb-o* (attempt to delete all revisions)
a13944 15
	  # Now test for a bug involving branches and locks
	  sed -e 's/locks; strict;/locks fred:1.2; strict;/' ${TESTDIR}/cvsroot/first-dir/a-lock,v > a-lock,v
	  chmod 644 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  dotest reserved-16 \
"mv a-lock,v ${TESTDIR}/cvsroot/first-dir/a-lock,v" ""
	  chmod 444 ${TESTDIR}/cvsroot/first-dir/a-lock,v
	  dotest reserved-17 "${testcvs} -q tag -b br a-lock" "T a-lock"
	  dotest reserved-18 "${testcvs} -q update -r br a-lock" ""
	  echo edit it >>a-lock
	  dotest reserved-19 "${testcvs} -q ci -m modify a-lock" \
"Checking in a-lock;
${TESTDIR}/cvsroot/first-dir/a-lock,v  <--  a-lock
new revision: 1\.2\.2\.1; previous revision: 1\.2
done"

d13948 1
a13948 1
	  dotest reserved-cleanup-1 "${testcvs} -q ci -m back commitinfo" \
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@a45 9
# We want to invoke a predictable set of i18n behaviors, not whatever
# the user running this script might have set.
# In particular:
#   'sort' and tabs and spaces (LC_COLLATE).
#   Messages from getopt (LC_MESSAGES) (in the future, CVS itself might 
#     also alter its messages based on LC_MESSAGES).
LC_ALL=C
export LC_ALL

d72 6
d480 1
a480 2
  fi 2>${TESTDIR}/dotest.tmp1
  cat ${TESTDIR}/dotest.tmp1 >>${TESTDIR}/dotest.tmp
d556 1
a556 1
	tests="basica basicb basicc basic1 deep basic2 files commit-readonly"
d558 1
a558 2
	tests="${tests} rdiff diff death death2 rmadd rmadd2 dirs dirs2"
	tests="${tests} branches branches2 tagc"
d560 1
a560 2
	tests="${tests} import-after-initial"
	tests="${tests} join join2 join3 join-readonly-conflict"
a563 1
	tests="${tests} mkmodules-temp-file-removal"
d570 1
a570 2
	tests="${tests} ignore binfiles binfiles2 binfiles3"
	tests="${tests} mcopy binwrap binwrap2"
d572 1
a572 5
	tests="${tests} serverpatch log log2 ann ann-id"
	# Repository Storage (RCS file format, CVS lock files, creating
	# a repository without "cvs init", &c).
	tests="${tests} crerepos rcs rcs2 rcs3 lockfiles"
	# More history browsing, &c.
d574 1
a574 1
	tests="${tests} big modes modes2 modes3 stamps"
a583 5
	# Release of multiple directories
	tests="${tests} release"
	# Multiple root directories and low-level protocol tests.
	tests="${tests} multiroot multiroot2 multiroot3 multiroot4"
	tests="${tests} reposmv pserver server client"
d632 4
a635 7
	# Currently we test :fork: and :ext: (see crerepos test).
	# Testing :pserver: would be hard (inetd issues).
	# Also :ext: and :fork support CVS_SERVER in a convenient way.
	# If you want to edit this script to change the next line to
	# :ext:, you can run the tests that way.  There is a known
	# difference in modes-15 (see comments there).
	CVSROOT=:fork:${CVSROOT_DIRNAME} ; export CVSROOT
d728 2
a729 2
\*\*\* sdir/ssdir/ssfile	[0-9/]* [0-9:]*	1\.1
--- sdir/ssdir/ssfile	[0-9/]* [0-9:]*
d741 2
a742 2
\*\*\* sdir/ssdir/ssfile	[0-9/]* [0-9:]*	1\.1
--- sdir/ssdir/ssfile	[0-9/]* [0-9:]*
a1142 2
	  # FIXME: this test is intended for the TopLevelAdmin=yes case;
	  # should adjust/move it accordingly.
a1151 10
	  cd first-dir
	  dotest basicc-6 "${testcvs} release -d" ""
	  dotest basicc-7 "test -d ../first-dir" ""
	  dotest basicc-8 "${testcvs} -Q release -d ." \
"${PROG} release: deletion of directory \. failed: .*"
	  dotest basicc-9 "test -d ../second-dir" ""
	  dotest basicc-10 "test -d ../first-dir" ""
	  # For CVS to make a syntactic check for "." wouldn't suffice.
	  dotest basicc-11 "${testcvs} -Q release -d ./." \
"${PROG} release: deletion of directory \./\. failed: .*"
d1153 1
a1153 11
	  cd ..

	  mkdir 2; cd 2
	  dotest basicc-12 "${testcvs} -Q co ." ""
	  dotest basicc-13 "echo *" "CVS CVSROOT first-dir second-dir"
	  dotest basicc-14 "${testcvs} -Q release first-dir second-dir" ""
	  dotest basicc-15 "${testcvs} -Q release -d first-dir second-dir" ""
	  dotest basicc-16 "echo *" "CVS CVSROOT"

	  cd ..
	  rm -r 1 2
a2049 102
	files)
	  # Test of how we specify files on the command line
	  # (recurse.c and that sort of thing).  Vaguely similar to
	  # tests like basic* and deep.  See modules and such tests
	  # for what happens when we throw in modules and co -d, &c.

	  # This particular test is fairly carefully crafted, to spot
	  # one particular issue with remote.
	  mkdir 1; cd 1
	  dotest files-1 "${testcvs} -q co -l ." ""
	  mkdir first-dir
	  dotest files-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch tfile
	  dotest files-3 "${testcvs} add tfile" \
"${PROG} [a-z]*: scheduling file .tfile. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest files-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/tfile,v
done
Checking in tfile;
${TESTDIR}/cvsroot/first-dir/tfile,v  <--  tfile
initial revision: 1\.1
done"
	  dotest files-5 "${testcvs} -q tag -b C" "T tfile"
	  dotest files-6 "${testcvs} -q update -r C" ""
	  mkdir dir
	  dotest files-7 "${testcvs} add dir" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir added to the repository
--> Using per-directory sticky tag .C'"
	  cd dir
	  touch .file
	  dotest files-6 "${testcvs} add .file" \
"${PROG} [a-z]*: scheduling file .\.file' for addition on branch .C.
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  mkdir sdir
	  dotest files-7 "${testcvs} add sdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir/sdir added to the repository
--> Using per-directory sticky tag .C'"
	  cd sdir
	  mkdir ssdir
	  dotest files-8 "${testcvs} add ssdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir added to the repository
--> Using per-directory sticky tag .C'"
	  cd ssdir
	  touch .file
	  dotest files-9 "${testcvs} add .file" \
"${PROG} [a-z]*: scheduling file .\.file' for addition on branch .C.
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  cd ../..
	  dotest files-10 "${testcvs} -q ci -m test" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v
done
Checking in \.file;
${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v
done
Checking in sdir/ssdir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest files-11 \
"${testcvs} commit -m test -f ./.file ./sdir/ssdir/.file" \
"Checking in \.file;
${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.2; previous revision: 1\.1\.2\.1
done
Checking in \./sdir/ssdir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.2; previous revision: 1\.1\.2\.1
done"
	  if test "$remote" = yes; then
	    # This is a bug, looks like that toplevel_repos cruft in
	    # client.c is coming back to haunt us.
	    # May want to think about the whole issue, toplevel_repos
	    # has always been crufty and trying to patch it up again
	    # might be a mistake.
	    dotest_fail files-12 \
"${testcvs} commit -f -m test ./sdir/ssdir/.file ./.file" \
"${PROG} server: Up-to-date check failed for .\.file'
${PROG} \[server aborted\]: correct above errors first!"
	  else
	    dotest files-12 \
"${testcvs} commit -f -m test ./sdir/ssdir/.file ./.file" \
"Checking in \./sdir/ssdir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.3; previous revision: 1\.1\.2\.2
done
Checking in \.file;
${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.3; previous revision: 1\.1\.2\.2
done"
	  fi
	  cd ../../..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRECTORY}/first-dir
	  ;;

a2196 25
	diff)
	  # Various tests specific to the "cvs diff" command.
	  # Related tests:
	  #   death2: -N
	  #   rcslib: cvs diff and $Name.
	  #   rdiff: cvs rdiff.
	  #   diffmerge*: nuts and bolts (stuff within diff library)
	  mkdir 1; cd 1
	  dotest diff-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest diff-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir

	  # diff is anomalous.  Most CVS commands print the "nothing
	  # known" message (or worse yet, no message in some cases) but
	  # diff says "I know nothing".  Shrug.
	  dotest_fail diff-3 "${testcvs} diff xyzpdq" \
"${PROG} [a-z]*: I know nothing about xyzpdq"

	  cd ../..
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  rm -r 1
	  ;;

a2896 467
	rmadd)
	  # More tests of adding and removing files.
	  # In particular ci -r.
	  # Other ci -r tests:
	  #   * editor-9: checking in a modified file,
	  #     where "ci -r" means a branch.
	  #   * basica-8a1: checking in a modified file with numeric revision.
	  #   * basica-8a2: likewise.
	  #   * keywordlog-4: adding a new file with numeric revision.
	  mkdir 1; cd 1
	  dotest rmadd-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest rmadd-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo first file1 >file1
	  dotest rmadd-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  dotest_fail rmadd-4 "${testcvs} -q ci -r 1.2.2.4 -m add" \
"${PROG} [a-z]*: cannot add file .file1' with revision .1\.2\.2\.4'; must be on trunk
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  dotest_fail rmadd-5 "${testcvs} -q ci -r 1.2.2 -m add" \
"${PROG} [a-z]*: cannot add file .file1' with revision .1\.2\.2'; must be on trunk
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  dotest_fail rmadd-6 "${testcvs} -q ci -r mybranch -m add" \
"${PROG} \[[a-z]* aborted\]: no such tag mybranch"

	  # The thing with the trailing periods strikes me as a very
	  # bizarre behavior, but it would seem to be intentional
	  # (see commit.c).  It probably could go away....
	  dotest rmadd-7 "${testcvs} -q ci -r 7.... -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 7\.1
done"
	  if test "$remote" = yes; then
	    # I guess remote doesn't set a sticky tag in this case.
	    # Kind of odd, in the sense that rmadd-24a does set one
	    # both local and remote.
	    dotest_fail rmadd-7a "test -f CVS/Tag"
	    echo T7 >CVS/Tag
	  else
	    dotest rmadd-7a "cat CVS/Tag" "T7"
	  fi

	  dotest rmadd-8 "${testcvs} -q tag -b mybranch" "T file1"
	  dotest rmadd-9 "${testcvs} -q tag mynonbranch" "T file1"

	  touch file2
	  # The previous "cvs ci -r" set a sticky tag of '7'.  Seems a
	  # bit odd, and I guess commit.c (findmaxrev) makes '7' sticky
	  # tags unnecessary (?).  I kind of suspect that it should be
	  # saying "sticky tag is not a branch" like keywordlog-4b.
	  # Or something.
	  dotest rmadd-10 "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition on branch .7'
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # As in the previous example, CVS is confused....
	  dotest rmadd-11 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 7\.1
done"

	  dotest rmadd-12 "${testcvs} -q update -A" ""
	  touch file3
	  dotest rmadd-13 "${testcvs} add file3" \
"${PROG} [a-z]*: scheduling file .file3. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # Huh?  file2 is not up to date?  Seems buggy to me....
	  dotest_fail rmadd-14 "${testcvs} -q ci -r mybranch -m add" \
"${PROG} [a-z]*: Up-to-date check failed for .file2'
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  # Whatever, let's not let file2 distract us....
	  dotest rmadd-15 "${testcvs} -q ci -r mybranch -m add file3" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file3,v
done
Checking in file3;
${TESTDIR}/cvsroot/first-dir/Attic/file3,v  <--  file3
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  touch file4
	  dotest rmadd-16 "${testcvs} add file4" \
"${PROG} [a-z]*: scheduling file .file4. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  # Same "Up-to-date check" issues as in rmadd-14.
	  # The "no such tag" thing is due to the fact that we only
	  # update val-tags when the tag is used (might be more of a
	  # bug than a feature, I dunno).
	  dotest_fail rmadd-17 \
"${testcvs} -q ci -r mynonbranch -m add file4" \
"${PROG} \[[a-z]* aborted\]: no such tag mynonbranch"
	  # Try to make CVS write val-tags.
	  dotest rmadd-18 "${testcvs} -q update -p -r mynonbranch file1" \
"first file1"
	  # Oops, -p suppresses writing val-tags (probably a questionable
	  # behavior).
	  dotest_fail rmadd-19 \
"${testcvs} -q ci -r mynonbranch -m add file4" \
"${PROG} \[[a-z]* aborted\]: no such tag mynonbranch"
	  # Now make CVS write val-tags for real.
	  dotest rmadd-20 "${testcvs} -q update -r mynonbranch file1" ""
	  # Oops - CVS isn't distinguishing between a branch tag and
	  # a non-branch tag.
	  dotest rmadd-21 \
"${testcvs} -q ci -r mynonbranch -m add file4" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file4,v
done
Checking in file4;
${TESTDIR}/cvsroot/first-dir/Attic/file4,v  <--  file4
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  # OK, we add this one in a vanilla way, but then check in
	  # a modification with ci -r and sniff around for sticky tags.
	  echo file5 >file5
	  dotest rmadd-22 "${testcvs} add file5" \
"${PROG} [a-z]*: scheduling file .file5. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  if test "$remote" = yes; then
	    # Interesting bug (or missing feature) here.  findmaxrev
	    # gets the major revision from the Entries.  Well, remote
	    # doesn't send the entries for files which are not involved.
	    dotest rmadd-23 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file5,v
done
Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
initial revision: 1\.1
done"
	    dotest rmadd-23-workaround \
"${testcvs} -q ci -r 7 -m bump-it file5" \
"Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
new revision: 7\.1; previous revision: 1\.1
done"
	  else
	    dotest rmadd-23 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file5,v
done
Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
initial revision: 7\.1
done"
	  fi
	  echo change it >file5
	  dotest_fail rmadd-24 "${testcvs} -q ci -r 4.8 -m change file5" \
"Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/file5,v: revision 4\.8 too low; must be higher than 7\.1
${PROG} [a-z]*: could not check in file5
7\.1 unlocked"
	  dotest rmadd-24a "${testcvs} -q ci -r 8.4 -m change file5" \
"Checking in file5;
${TESTDIR}/cvsroot/first-dir/file5,v  <--  file5
new revision: 8\.4; previous revision: 7\.1
done"
	  # I'm not really sure that a sticky tag make sense here.
	  # It seems to be longstanding behavior for what that is worth.
	  dotest rmadd-25 "${testcvs} status file5" \
"===================================================================
File: file5            	Status: Up-to-date

   Working revision:	8\.4.*
   Repository revision:	8\.4	${TESTDIR}/cvsroot/first-dir/file5,v
   Sticky Tag:		8\.4
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	rmadd2)
	  # Tests of undoing commits, including in the presence of
	  # adding and removing files.  See join for a list of -j tests.
	  mkdir 1; cd 1
	  dotest rmadd2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest rmadd2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo 'initial contents' >file1
	  dotest rmadd2-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest rmadd2-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest rmadd2-5 "${testcvs} rm -f file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest rmadd2-6 "${testcvs} -q ci -m remove" \
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done"
	  dotest rmadd2-7 "${testcvs} -q update -j 1.2 -j 1.1 file1" "U file1"
	  dotest rmadd2-8 "${testcvs} -q ci -m readd" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  echo 'new contents' >file1
	  dotest rmadd2-9 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done"
	  dotest rmadd2-10 "${testcvs} -q update -j 1.4 -j 1.3 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.4
retrieving revision 1\.3
Merging differences between 1\.4 and 1\.3 into file1"
	  dotest rmadd2-11 "${testcvs} -q ci -m undo" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.5; previous revision: 1\.4
done"
	  dotest rmadd2-12 "cat file1" "initial contents"
	  dotest rmadd2-13 "${testcvs} -q update -p -r 1.3" "initial contents"

	  # Hmm, might be a bit odd that this works even if 1.3 is not
	  # the head.
	  dotest rmadd2-14 "${testcvs} -q update -j 1.3 -j 1.2 file1" \
"${PROG} [a-z]*: scheduling file1 for removal"
	  dotest rmadd2-15 "${testcvs} -q ci -m re-remove" \
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.5
done"
	  cd ../..

	  rm -r 1
	  rm -rf ${TESTDIR}/cvsroot/first-dir
	  ;;

	dirs)
	  # Tests related to removing and adding directories.
	  # See also:
	  #   conflicts (especially dir1 in conflicts-130): What happens if
	  #     directory exists in repository and a non-CVS-controlled
	  #     directory in the working directory?
	  #   conflicts3-15.  More cases, especially where CVS directory
	  #     exists but without CVS/Repository and friends.
	  #   conflicts3-22.  Similar to conflicts-130 but there is a file
	  #     in the directory.
	  #   dirs2.  Sort of similar to conflicts3-22 but somewhat different.
	  mkdir imp-dir; cd imp-dir
	  echo file1 >file1
	  mkdir sdir
	  echo sfile >sdir/sfile
	  dotest_sort dirs-1 \
"${testcvs} import -m import-it dir1 vend rel" "

N dir1/file1
N dir1/sdir/sfile
No conflicts created by this import
${PROG} [a-z]*: Importing ${TESTDIR}/cvsroot/dir1/sdir"
	  cd ..

	  mkdir 1; cd 1
	  dotest dirs-2 "${testcvs} -Q co dir1" ""

	  # Various CVS administrators are in the habit of removing
	  # the repository directory for things they don't want any
	  # more.  I've even been known to do it myself (on rare
	  # occasions).  Not the usual recommended practice, but we want
	  # to try to come up with some kind of reasonable/documented/sensible
	  # behavior.
	  rm -rf ${CVSROOT_DIRNAME}/dir1/sdir

	  dotest dirs-3 "${testcvs} update" \
"${PROG} [a-z]*: Updating dir1
${PROG} [a-z]*: Updating dir1/sdir
${PROG} [a-z]*: cannot open directory ${TESTDIR}/cvsroot/dir1/sdir: No such file or directory
${PROG} [a-z]*: skipping directory dir1/sdir"
	  dotest dirs-3a "${testcvs} update -d" \
"${PROG} [a-z]*: Updating dir1
${PROG} [a-z]*: Updating dir1/sdir
${PROG} [a-z]*: cannot open directory ${TESTDIR}/cvsroot/dir1/sdir: No such file or directory
${PROG} [a-z]*: skipping directory dir1/sdir"

	  # If we say "yes", then CVS gives errors about not being able to
	  # create lock files.
	  if echo no | ${testcvs} release -d dir1/sdir \
	      >${TESTDIR}/output.tmp 2>&1; then
	    pass dirs-4
	  else
	    fail dirs-4
	  fi
	  # The fact that it says "skipping directory " rather than
	  # "skipping directory dir1/sdir" is some kind of bug.
	  dotest dirs-4a "cat ${TESTDIR}/output.tmp" \
"${PROG} [a-z]*: cannot open directory ${TESTDIR}/cvsroot/dir1/sdir: No such file or directory
${PROG} [a-z]*: skipping directory 
You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .dir1/sdir': .. .release' aborted by user choice."

	  # OK, if "cvs release" won't help, we'll try it the other way...
	  rm -r dir1/sdir

	  dotest dirs-5 "cat dir1/CVS/Entries" \
"/file1/1.1.1.1/[a-zA-Z0-9 :]*//
D/sdir////"
	  dotest dirs-6 "${testcvs} update" "${PROG} [a-z]*: Updating dir1"
	  dotest dirs-7 "cat dir1/CVS/Entries" \
"/file1/1.1.1.1/[a-zA-Z0-9 :]*//
D/sdir////"
	  dotest dirs-8 "${testcvs} update -d dir1" \
"${PROG} [a-z]*: Updating dir1"

	  cd ..

	  rm -r imp-dir 1
	  rm ${TESTDIR}/output.tmp

	  # clean up our repositories
	  rm -rf ${CVSROOT_DIRNAME}/dir1
	  ;;

	dirs2)
	  # See "dirs" for a list of tests involving adding and
	  # removing directories.
	  mkdir 1; cd 1
	  dotest dirs2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest dirs2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  mkdir sdir
	  dotest dirs2-3 "${testcvs} add sdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/sdir added to the repository"
	  touch sdir/file1
	  dotest dirs2-4 "${testcvs} add sdir/file1" \
"${PROG} [a-z]*: scheduling file .sdir/file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest dirs2-5 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/file1,v
done
Checking in sdir/file1;
${TESTDIR}/cvsroot/first-dir/sdir/file1,v  <--  file1
initial revision: 1\.1
done"
	  rm -r sdir/CVS
	  if test "$remote" = yes; then
	    # This is just like conflicts3-23
	    dotest_fail dirs2-6 "${testcvs} update -d" \
"${QUESTION} sdir
${PROG} server: Updating \.
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory
${PROG} server: Updating sdir
${PROG} update: move away sdir/file1; it is in the way
C sdir/file1"
	    rm sdir/file1

	    # This is where things are not just like conflicts3-23
	    # As with conflicts3-23, all these CVS/Entries* warnings
	    # are somewhat doubtful, and we probably should think some
	    # about whether they should be changed/fixed.
	    dotest dirs2-7 "${testcvs} update -d" \
"${QUESTION} sdir
${PROG} server: Updating \.
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory
${PROG} server: Updating sdir
U sdir/file1
${PROG} update: cannot open CVS/Entries.Log: No such file or directory"
	  else
	    dotest dirs2-6 "${testcvs} update -d" \
"${PROG} update: Updating \.
${QUESTION} sdir"
	    rm sdir/file1
	    dotest dirs2-7 "${testcvs} update -d" \
"${PROG} update: Updating \.
${QUESTION} sdir"
	  fi
	  cd ../..

	  # Now, the same thing (more or less) on a branch.
	  mkdir 2; cd 2
	  dotest dirs2-8 "${testcvs} -q co first-dir" 'U first-dir/sdir/file1'
	  cd first-dir
	  dotest dirs2-9 "${testcvs} -q tag -b br" "T sdir/file1"
	  rm -r sdir/CVS
	  if test "$remote" = yes; then
	    # Cute little quirk of val-tags; if we don't recurse into
	    # the directories where the tag is defined, val-tags won't
	    # get updated.
	    dotest_fail dirs2-10 "${testcvs} update -d -r br" \
"${QUESTION} sdir
${PROG} \[server aborted\]: no such tag br"
	    dotest dirs2-10-rem \
"${testcvs} -q rdiff -u -r 1.1 -r br first-dir/sdir/file1" \
""
	    dotest_fail dirs2-10-again "${testcvs} update -d -r br" \
"${QUESTION} sdir
${PROG} server: Updating \.
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory
${PROG} update: cannot open CVS/Tag: No such file or directory
${PROG} update: cannot open CVS/Tag: No such file or directory
${PROG} server: Updating sdir
${PROG} update: move away sdir/file1; it is in the way
C sdir/file1
${PROG} update: cannot open CVS/Tag: No such file or directory"
	  else
	    dotest_fail dirs2-10 "${testcvs} update -d -r br" \
"${PROG} update: in directory sdir:
${PROG} \[update aborted\]: there is no version here; do 'cvs checkout' first"
	  fi
	  cd ../..

	  # OK, the above tests make the situation somewhat harder
	  # than it might be, in the sense that they actually have a
	  # file which is alive on the branch we are updating.  Let's
	  # try it where it is just a directory where all the files
	  # have been removed.
	  mkdir 3; cd 3
	  dotest dirs2-11 "${testcvs} -q co -r br first-dir" \
"U first-dir/sdir/file1"
	  cd first-dir
	  # Hmm, this doesn't mention the branch like add does.  That's
	  # an odd non-orthogonality.
	  dotest dirs2-12 "${testcvs} rm -f sdir/file1" \
"${PROG} [a-z]*: scheduling .sdir/file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest dirs2-13 "${testcvs} -q ci -m remove" \
"Removing sdir/file1;
${TESTDIR}/cvsroot/first-dir/sdir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1\.2
done"
	  cd ../../2/first-dir
	  if test "$remote" = yes; then
	    dotest dirs2-14 "${testcvs} update -d -r br" \
"${QUESTION} sdir
${PROG} server: Updating \.
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory
${PROG} update: cannot open CVS/Tag: No such file or directory
${PROG} update: cannot open CVS/Tag: No such file or directory
${PROG} server: Updating sdir
${PROG} update: cannot open CVS/Tag: No such file or directory"
	  else
	    dotest dirs2-14 "${testcvs} update -d -r br" \
"${PROG} update: Updating \.
${QUESTION} sdir"
	  fi
	  cd ../..

	  rm -r 1 2 3
	  rm -rf ${TESTDIR}/cvsroot/first-dir
	  ;;

d3392 9
a3400 7
	tagc)
	  # Test the tag -c option.
	  mkdir 1; cd 1
	  dotest tagc-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest tagc-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
d3402 2
a3403 56
	  touch file1
	  dotest tagc-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest tagc-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest tagc-5 "${testcvs} -q tag -c tag1" "T file1"
	  touch file1
	  dotest tagc-6 "${testcvs} -q tag -c tag2" "T file1"
	  # Avoid timestamp granularity bugs (FIXME: CVS should be
	  # doing the sleep, right?).
	  sleep 1
	  echo myedit >>file1
	  dotest_fail tagc-7 "${testcvs} -q tag -c tag3" \
"${PROG} [a-z]*: file1 is locally modified
${PROG} \[[a-z]* aborted\]: correct the above errors first!"
	  cd ../..
	  mkdir 2
	  cd 2
	  dotest tagc-8 "${testcvs} -q co first-dir" "U first-dir/file1"
	  cd ../1/first-dir
	  dotest tagc-9 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../../2/first-dir
	  # That this is an error is a bug.  Although the bug has existed
	  # since tag -c was created, I don't think there would be a
	  # compatibility problem with just fixing it.
	  dotest_fail tagc-10 "${testcvs} -q tag -c tag4" \
"${PROG} [a-z]*: file1 is locally modified
${PROG} \[[a-z]* aborted\]: correct the above errors first!"
	  cd ../..

	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	rcslib)
	  # Test librarification of RCS.
	  # First: test whether `cvs diff' handles $Name expansion
	  # correctly.	We diff two revisions with their symbolic tags;
	  # neither tag should be expanded in the output.  Also diff
	  # one revision with the working copy.

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  dotest rcsdiff-1 "${testcvs} -q co first-dir" ''
	  cd first-dir
	  echo "I am the first foo, and my name is $""Name$." > foo.c
	  dotest rcsdiff-2 "${testcvs} add -m new-file foo.c" \
d3606 1
a3606 40
	  dotest rcslib-symlink-4 "ls -l $CVSROOT_DIRNAME/first-dir/file2,v" \
".*$CVSROOT_DIRNAME/first-dir/file2,v -> file1,v"
	  # Test 5 reveals a problem with having symlinks in the
	  # repository.  CVS will try to tag both of the files
	  # separately.  After processing one, it will do the same
	  # operation to the other, which is actually the same file,
	  # so the tag will already be there.  FIXME: do we bother
	  # changing operations to notice cases like this?  This
	  # strikes me as a difficult problem.  -Noel
	  dotest rcslib-symlink-5 "${testcvs} tag the_tag" \
"${PROG} [a-z]*: Tagging .
T file1
W file2 : the_tag already exists on version 1.1.2.1 : NOT MOVING tag to version 1.1.2.2"
	  dotest rcslib-symlink-6 "ls -l $CVSROOT_DIRNAME/first-dir/file2,v" \
".*$CVSROOT_DIRNAME/first-dir/file2,v -> file1,v"

	  # Symlinks tend to interact poorly with the Attic.
	  cd ..
	  mkdir 2; cd 2
	  dotest rcslib-symlink-7 "${testcvs} -q co first-dir" \
"U first-dir/file1
U first-dir/file2"
	  cd first-dir
	  dotest rcslib-symlink-8 "${testcvs} rm -f file2" \
"${PROG} [a-z]*: scheduling .file2. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest rcslib-symlink-9 "${testcvs} -q ci -m rm-it" \
"Removing file2;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file2
new revision: delete; previous revision: 1\.2
done"
	  # OK, why this message happens twice is relatively clear
	  # (the check_* and rtag_* calls to start_recursion).
	  # Why it happens a third time I didn't try to find out.
	  dotest rcslib-symlink-10 \
"${testcvs} -q rtag -b -r the_tag brtag first-dir" \
"${PROG} [a-z]*: could not read RCS file for file2
${PROG} [a-z]*: could not read RCS file for first-dir/file2
${PROG} [a-z]*: could not read RCS file for first-dir/file2"
	  cd ..
d3616 1
a3616 1
	  rm -r first-dir 2
d3721 1
a3721 1
		  echo imported file"$i" > imported-f"$i"
d3732 5
a3736 12
		dotest_sort import-96 \
"${testcvs} import -m first-import first-dir vendor-branch junk-1_0" \
"

I first-dir/RCS
N first-dir/imported-f1
N first-dir/imported-f2
N first-dir/imported-f3
N first-dir/imported-f4
No conflicts created by this import"

		dotest import-96.5 "cmp ../imported-f2-orig.tmp imported-f2" ''
d3738 5
d3746 5
a3750 5
		dotest import-97 "${testcvs} -q co first-dir" \
"U first-dir/imported-f1
U first-dir/imported-f2
U first-dir/imported-f3
U first-dir/imported-f4"
a3752 1

d3754 5
a3758 1
		  dotest import-98-$i "test -f imported-f$i" ''
d3760 5
a3764 1
		dotest_fail import-98.5 "test -d RCS" ''
d3768 5
a3772 3
		dotest import-99 "${testcvs} rm imported-f1" \
"${PROG}"' [a-z]*: scheduling `imported-f1'\'' for removal
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove this file permanently'
d3778 5
a3782 10
		dotest import-100 "${testcvs} ci -m local-changes" \
"${PROG} [a-z]*: Examining .
Removing imported-f1;
${TESTDIR}/cvsroot/first-dir/imported-f1,v  <--  imported-f1
new revision: delete; previous revision: 1\.1\.1\.1
done
Checking in imported-f2;
${TESTDIR}/cvsroot/first-dir/imported-f2,v  <--  imported-f2
new revision: 1\.2; previous revision: 1\.1
done"
d3785 5
a3789 28
		dotest import-101 "${testcvs} log imported-f1" \
"
RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/imported-f1,v
Working file: imported-f1
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	junk-1_0: 1\.1\.1\.1
	vendor-branch: 1\.1\.1
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: dead;  lines: ${PLUS}0 -0
local-changes
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
branches:  1\.1\.1;
Initial revision
----------------------------
revision 1\.1\.1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}0 -0
first-import
============================================================================="
d3792 5
a3796 4
		dotest import-102 "${testcvs} update -rvendor-branch" \
"${PROG} [a-z]*: Updating .
[UP] imported-f1
[UP] imported-f2"
d3800 6
a3805 3
		dotest import-103 "${testcvs} rm imported-f4" \
"${PROG}"' [a-z]*: scheduling `imported-f4'\'' for removal
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to remove this file permanently'
d3808 5
a3812 6
		dotest import-104 \
"${testcvs} ci -m vendor-removed imported-f4" \
"Removing imported-f4;
${TESTDIR}/cvsroot/first-dir/imported-f4,v  <--  imported-f4
new revision: delete; previous revision: 1\.1\.1\.1
done"
d3815 5
a3819 3
		dotest import-105 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: imported-f1 is not (any longer) pertinent
[UP] imported-f2"
d3824 1
a3824 1
		  echo rev 2 of file $i >> imported-f"$i"
d3828 10
a3837 17
		dotest_sort import-106 \
"${testcvs} import -m second-import first-dir vendor-branch junk-2_0" \
"


	${PROG} checkout -jvendor-branch:yesterday -jvendor-branch first-dir
2 conflicts created by this import.
C first-dir/imported-f1
C first-dir/imported-f2
I first-dir/RCS
U first-dir/imported-f3
U first-dir/imported-f4
Use the following command to help the merge:"

		dotest import-106.5 "cmp ../imported-f2-orig.tmp imported-f2" \
''

a3838 1

d3842 5
a3846 4
		dotest import-107 "${testcvs} co first-dir" \
"${PROG} [a-z]*: Updating first-dir
[UP] first-dir/imported-f3
[UP] first-dir/imported-f4"
d3850 5
a3854 1
		dotest_fail import-108 "test -f imported-f1" ''
d3857 5
a3861 1
		  dotest import-109-$i "test -f imported-f$i" ''
d3865 5
a3869 3
		dotest import-110 "${testcvs} -q update -rvendor-branch" \
"[UP] imported-f1
[UP] imported-f2"
d3871 5
a3875 1
		dotest import-111 "test -f imported-f4" ''
d3878 5
a3882 3
		dotest import-112 "${testcvs} -q update -A" \
"${PROG} [a-z]*: warning: imported-f1 is not (any longer) pertinent
[UP] imported-f2"
d3897 5
a3901 1
		dotest_fail import-114 "test -f imported-f1" ''
d3904 5
a3908 1
		  dotest import-115-$i "test -f imported-f$i" ''
a3952 2
	  # We use an explicit -d option to test that it is reflected
	  # in the suggested checkout.
d3954 1
a3954 1
"${testcvs} -d ${CVSROOT} import -m add -b 1.1.3 first-dir freemunger freemunger-1_0" \
d3958 1
a3958 1
	${PROG} -d ${CVSROOT} checkout -jfreemunger:yesterday -jfreemunger first-dir
a4026 1
	  # Also the -d option.
d4033 2
a4034 10
	  # If I'm correctly reading the Single Unix Specification,
	  # version 2, then "touch -t 197107040343" or "touch -t 203412251801"
	  # should work.  But GNU touch seems to have other ideas.
	  # I sort of wonder if this is lossage by the standards bodies,
	  # I'm not sure.
	  # Note that some versions of touch when used without -t don't handle
	  # y2k and/or set the seconds reliably.
	  # We should probably find a different way of doing this.
	  touch 0704034371 bdir/subdir/file1
	  touch 1225180134 cdir/cfile
d4036 1
a4036 1
"${testcvs} import -d -m import-it first-dir vendor release" \
a4094 57

	  # TODO: should also be testing "import -d" when we update
	  # an existing file.
	  dotest importc-8 "${testcvs} -q log cdir/cfile" "
RCS file: ${TESTDIR}/cvsroot/first-dir/cdir/cfile,v
Working file: cdir/cfile
head: 1\.1
branch: 1\.1\.1
locks: strict
access list:
symbolic names:
	wip_test: 1\.1\.1\.1\.0\.2
	release: 1\.1\.1\.1
	vendor: 1\.1\.1
keyword substitution: kv
total revisions: 3;	selected revisions: 3
description:
----------------------------
revision 1\.1
date: 2034/12/2[4-6] [0-9][0-9]:01:[0-9][0-9];  author: ${username};  state: Exp;
branches:  1\.1\.1;
Initial revision
----------------------------
revision 1\.1\.1\.1
date: 2034/12/2[4-6] [0-9][0-9]:01:[0-9][0-9];  author: ${username};  state: Exp;  lines: ${PLUS}0 -0
branches:  1\.1\.1\.1\.2;
import-it
----------------------------
revision 1\.1\.1\.1\.2\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
modify
============================================================================="

	  dotest importc-9 "${testcvs} -q log bdir/subdir/file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/bdir/subdir/file1,v
Working file: bdir/subdir/file1
head: 1\.1
branch: 1\.1\.1
locks: strict
access list:
symbolic names:
	wip_test: 1\.1\.1\.1\.0\.2
	release: 1\.1\.1\.1
	vendor: 1\.1\.1
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.1
date: 1971/07/0[3-5] [0-9][0-9]:43:[0-9][0-9];  author: ${username};  state: Exp;
branches:  1\.1\.1;
Initial revision
----------------------------
revision 1\.1\.1\.1
date: 1971/07/0[3-5] [0-9][0-9]:43:[0-9][0-9];  author: ${username};  state: Exp;  lines: ${PLUS}0 -0
import-it
============================================================================="
a4101 56
	import-after-initial)
	  # Properly handle the case in which the first version of a
	  # file is created by a regular cvs add and commit, and there
	  # is a subsequent cvs import of the same file.  cvs update with
	  # a date tag must resort to searching the vendor branch only if
	  # the initial version of the file was created at the same time
	  # as the initial version on the vendor branch.

	  mkdir 1; cd 1
	  module=x

	  echo > unused-file

	  # Create the module.
	  dotest import-after-initial-1 \
	    "$testcvs -Q import -m. $module X Y" ''

	  file=m
	  # Check it out and add a file.
	  dotest import-after-initial-2 "$testcvs -Q co $module" ''
	  cd $module
	  echo original > $file
	  dotest import-after-initial-3 "${testcvs} -Q add $file" \
"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest import-after-initial-4 "${testcvs} -Q ci -m. $file" \
"RCS file: ${TESTDIR}/cvsroot/$module/$file,v
done
Checking in $file;
${TESTDIR}/cvsroot/$module/$file,v  <--  $file
initial revision: 1\.1
done"

	  # Delay a little so the following import isn't done in the same
	  # second as the preceding commit.
	  sleep 2

	  # Do the first import of $file *after* $file already has an
	  # initial version.
	  mkdir sub
	  cd sub
	  echo newer-via-import > $file
	  dotest import-after-initial-5 \
	    "$testcvs -Q import -m. $module X Y2" ''
	  cd ..

	  # Sleep a second so we're sure to be after the second of the import.
	  sleep 1

	  dotest import-after-initial-6 \
	    "$testcvs -Q update -p -D now $file" 'original'

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

a4110 2
	  # See also rmadd2, which tests -j cases not involving branches
	  #   (e.g. undoing a commit)
a4730 54
	join-readonly-conflict)
	  # Demonstrate that cvs-1.9.29 can fail on 2nd and subsequent
	  # conflict-evoking join attempts.
	  # Even with that version of CVS, This test failed only in
	  # client-server mode, and would have been noticed in normal
	  # operation only for files that were read-only (either due to
	  # use of cvs' global -r option, setting the CVSREAD envvar,
	  # or use of watch lists).
	  mkdir 1; cd 1
	  dotest join-readonly-conflict-1 "$testcvs -q co -l ." ''
	  module=x
	  mkdir $module
	  $testcvs -q add $module >>$LOGFILE 2>&1
	  cd $module

	  file=m
	  echo trunk > $file
	  $testcvs -q add $file >>$LOGFILE 2>&1
	  $testcvs -q ci -m . $file >>$LOGFILE 2>&1

	  $testcvs tag -b B $file >>$LOGFILE 2>&1
	  $testcvs -q update -rB $file >>$LOGFILE 2>&1
	  echo branch B > $file
	  $testcvs ci -m . $file >>$LOGFILE 2>&1

	  rm $file
	  $testcvs update -A $file >>$LOGFILE 2>&1
	  # Make sure $file is read-only.  This can happen more realistically
	  # via patch -- which could be used to apply a delta, yet would
	  # preserve a file's read-only permissions.
	  echo conflict > $file; chmod u-w $file
	  $testcvs update -r B $file >>$LOGFILE 2>&1

	  rm -f $file
	  $testcvs update -A $file >>$LOGFILE 2>&1
	  # This one would fail because cvs couldn't open the existing
	  # (and read-only) .# file for writing.
	  echo conflict > $file

	  test -w ".#$file.1.1" && fail "$file is writable"
	  dotest join-readonly-conflict-2 "$testcvs update -r B $file" \
"RCS file: ${TESTDIR}/cvsroot/$module/$file,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into $file
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in $file
C m"

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

a4975 8
		dotest conflicts-129a "${testcvs} -nq update a" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/a,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into a
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in a
C a"
a5165 3
	  # BEGIN TESTS USING THE FILE A
	  # FIXME: would be cleaner to separate them out into their own
	  # tests; conflicts2 is getting long.
a5188 38

	  # Now one level up.
	  cd ..
	  dotest conflicts2-142b7 "${testcvs} rm -f first-dir/a" \
"${PROG} [a-z]*: scheduling .first-dir/a. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"

	  if test "$remote" = no; then
	    # The "nothing known" is a bug.  Correct behavior is for a to get
	    # created, as above.  Cause is pretty obvious - add.c
	    # calls update() without dealing with the fact we are chdir'd.
	    # Also note that resurrecting 1.2 instead of 1.1 is also a
	    # bug, I think (the same part of add.c has a comment which says
	    # "XXX - bugs here; this really resurrect the head" which
	    # presumably refers to this).
	    # The fix for both is presumably to call RCS_checkout() or
	    # something other than update().
	    dotest conflicts2-142b8 "${testcvs} add first-dir/a" \
"${PROG} [a-z]*: nothing known about first-dir
${PROG} [a-z]*: first-dir/a, version 1\.2, resurrected"
	    cd first-dir
	    # Now recover from the damage that the 142b8 test did.
	    dotest conflicts2-142b9 "${testcvs} rm -f a" \
"${PROG} [a-z]*: scheduling .a. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  else
	    # Haven't investigated this one.
	    dotest_fail conflicts2-142b8 "${testcvs} add first-dir/a" \
"${PROG} add: in directory \.:
${PROG} \[add aborted\]: there is no version here; do 'cvs checkout' first"
	    cd first-dir
	  fi

	  # As before, 1.2 instead of 1.1 is a bug.
	  dotest conflicts2-142b10 "${testcvs} add a" "U a
${PROG} [a-z]*: a, version 1\.2, resurrected"
	  # As with conflicts2-142b6, check that things are normal again.
	  dotest conflicts2-142b11 "${testcvs} -q update" ''
a5189 1
	  # END TESTS USING THE FILE A
d5441 1
a5441 1
	  dotest conflicts3-22 "${testcvs} -q update" "${QUESTION} sdir"
a5458 31
	  # Not that it should really affect much, but let's do the case
	  # where sfile has been removed.  For example, suppose that sdir
	  # had been a CVS-controlled directory which was then removed
	  # by removing each file (and using update -P or some such).  Then
	  # suppose that the build process creates an sdir directory which
	  # is not supposed to be under CVS.
	  rm -r sdir
	  dotest conflicts3-24 "${testcvs} -q update -d sdir" "U sdir/sfile"
	  rm sdir/sfile
	  dotest conflicts3-25 "${testcvs} rm sdir/sfile" \
"${PROG} [a-z]*: scheduling .sdir/sfile. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest conflicts3-26 "${testcvs} ci -m remove sdir/sfile" \
"Removing sdir/sfile;
${TESTDIR}/cvsroot/first-dir/sdir/sfile,v  <--  sfile
new revision: delete; previous revision: 1\.1
done"
	  rm -r sdir/CVS
	  dotest conflicts3-27 "${testcvs} -q update" "${QUESTION} sdir"
	  if test "x$remote" = xyes; then
	    # Regarding "cannot open CVS/Entries", see comments at
	    # conflicts3-23.
	    dotest conflicts3-28 "${testcvs} -q update -PdA" \
"${QUESTION} sdir
${PROG} update: in directory sdir:
${PROG} update: cannot open CVS/Entries for reading: No such file or directory"
	  else
	    dotest conflicts3-28 "${testcvs} -q update -PdA" \
"${QUESTION} sdir"
	  fi

d5909 4
a5912 1
	  # See comment at "release" for list of other cvs release tests.
d5986 2
a5987 1
	  # At least for now there is no way to tell CVS that
d5990 16
a6005 6
	  # This seems like a pretty sensible behavior to me, in the
	  # sense that first-dir doesn't "really" exist within
	  # third-dir, so CVS just acts as if there is nothing there
	  # to do.
	  dotest modules2-17 "${testcvs} update -d" \
"${PROG} [a-z]*: Updating \."
a6334 24
	mkmodules-temp-file-removal)
	  # When a file listed in checkoutlist doesn't exist, cvs-1.10.4
	  # would fail to remove the CVSROOT/.#[0-9]* temporary file it
	  # creates while mkmodules is in the process of trying to check
	  # out the missing file.

	  mkdir 1; cd 1
	  dotest mtfr-1 "${testcvs} -Q co CVSROOT" ''
	  cd CVSROOT
	  echo no-such-file >> checkoutlist
	  dotest mtfr-2 "${testcvs} -Q ci -m. checkoutlist" \
"Checking in checkoutlist;
$CVSROOT_DIRNAME/CVSROOT/checkoutlist,v  <--  checkoutlist
new revision: 1\.2; previous revision: 1\.1
done
$PROG [a-z]*: Rebuilding administrative file database"

	  dotest mtfr-3 "echo $CVSROOT_DIRNAME/CVSROOT/.#[0-9]*" \
	    "$CVSROOT_DIRNAME/CVSROOT/\.#\[0-9\]\*"

	  cd ../..
	  rm -rf 1
	  ;;

d7815 5
a7819 4
	  # It doesn't make any sense to add a file (or do much of anything
	  # else) in Emptydir; Emptydir is a placeholder indicating that
	  # the working directory doesn't correspond to anything in
	  # the repository.
d7823 8
a7830 2
	  dotest_fail emptydir-8 "${testcvs} -q ci -m add" \
"${PROG} \[[a-z]* aborted\]: cannot check in to ${TESTDIR}/cvsroot/CVSROOT/Emptydir"
d8809 11
a8819 1
	  dotest devcom-178 "${testcvs} editors" ""
d8827 11
a8837 7
	  # Here we test for the traditional ISO C ctime() date format.
	  # We assume the C locale; I guess that works provided we set
	  # LC_ALL at the start of this script but whether these
	  # strings should vary based on locale does not strike me as
	  # self-evident.
	  dotest devcom-180 "${testcvs} editors" \
"abb	${username}	[SMTWF][uoehra][neduit] [JFAMSOND][aepuco][nbrylgptvc] [0-9 ][0-9] [0-9:]* [0-9][0-9][0-9][0-9] GMT	[-a-zA-Z_.0-9]*	${TESTDIR}/2/first-dir"
d8848 11
a8858 1
	  dotest devcom-183 "${testcvs} editors" ""
d9086 1
a9086 1
	  cat <<'EOF' >>${CVSROOT_DIRNAME}/first-dir/CVS/fileattr
d9253 1
a9253 1
	    "/$file/1\.1\.1\.1/${DOTSTAR}"
a9478 7
	  # List of binary file tests:
	  #   * conflicts, "cvs admin": binfiles
	  #   * branching and joining: binfiles2
	  #   * adding and removing files: binfiles3
	  #   * -k wrappers: binwrap, binwrap2, binwrap3
	  #   * "cvs import" and wrappers: binwrap, binwrap2, binwrap3
	  #   * -k option to "cvs import": none yet, as far as I know.
d9482 2
a9483 2
	  awk 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | tr '@@' '\000' >binfile.dat
d9580 1
a9715 5
	  # Check that the contents were right.  This isn't the hard case
	  # (in which RCS_delete_revs does a diff), but might as well.
	  dotest binfiles-o4 "${testcvs} -q update binfile" "U binfile"
	  dotest binfiles-o5 "cmp binfile ../../1/binfile.dat" ""

a9717 1
	  rm -r 1
d9749 2
a9750 2
	  awk 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | tr '@@' '\000' >../binfile
a9904 90
	binfiles3)
	  # More binary file tests, especially removing, adding, &c.
	  # See "binfiles" for a list of binary file tests.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1; cd 1
	  dotest binfiles3-1 "${testcvs} -q co first-dir" ''
	  awk 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | tr '@@' '\000' >binfile.dat
	  cd first-dir
	  echo hello >file1
	  dotest binfiles3-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest binfiles3-3 "${testcvs} -q ci -m add-it" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  rm file1
	  dotest binfiles3-4 "${testcvs} rm file1" \
"${PROG} [a-z]*: scheduling .file1. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest binfiles3-5 "${testcvs} -q ci -m remove-it" \
"Removing file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: delete; previous revision: 1\.1
done"
	  cp ../binfile.dat file1
	  dotest binfiles3-6 "${testcvs} add -kb file1" \
"${PROG} [a-z]*: re-adding file file1 (in place of dead revision 1\.2)
${PROG} [a-z]*: use .cvs commit. to add this file permanently"
	  # The idea behind this test is to make sure that the file
	  # gets opened in binary mode to send to "cvs ci".
	  dotest binfiles3-6a "cat CVS/Entries" \
"/file1/0/[A-Za-z0-9 :]*/-kb/
D"
	  # TODO: This just tests the case where the old keyword
	  # expansion mode is the default (RCS_getexpand == NULL
	  # in checkaddfile()); should also test the case in which
	  # we are changing it from one non-default value to another.
	  dotest binfiles3-7 "${testcvs} -q ci -m readd-it" \
"${PROG} [a-z]*: changing keyword expansion mode to -kb
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"
	  dotest binfiles3-8 "${testcvs} -q log -h -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.3
branch:
locks: strict
access list:
keyword substitution: b
total revisions: 3
============================================================================="

	  # OK, now test admin -o on a binary file.  See "admin"
	  # test for a more complete list of admin -o tests.
	  cp ${TESTDIR}/1/binfile.dat ${TESTDIR}/1/binfile4.dat
	  echo '%%$$##@@@@!!jjiiuull' | tr j '\000' >>${TESTDIR}/1/binfile4.dat
	  cp ${TESTDIR}/1/binfile4.dat ${TESTDIR}/1/binfile5.dat
	  echo 'aawwee%$$##@@@@!!jjil' | tr w '\000' >>${TESTDIR}/1/binfile5.dat

	  cp ../binfile4.dat file1
	  dotest binfiles3-9 "${testcvs} -q ci -m change" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done"
	  cp ../binfile5.dat file1
	  dotest binfiles3-10 "${testcvs} -q ci -m change" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.5; previous revision: 1\.4
done"
	  dotest binfiles3-11 "${testcvs} admin -o 1.3::1.5 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.4
done"
	  dotest binfiles3-12 "${testcvs} -q update -r 1.3 file1" "U file1"
	  dotest binfiles3-13 "cmp file1 ${TESTDIR}/1/binfile.dat" ""

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d10450 1
a10450 18
	  if test "$remote" = no; then
	    dotest mwrap-7 "${testcvs} -nq update" \
"U aa
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.2 from repository is now in aa
${PROG} [a-z]*: file from working directory is now in \.#aa\.1\.1
C aa"
	  else
	    # The tagged text code swallows up "U aa" but isn't yet up to
	    # trying to figure out how it interacts with the "C aa" and
	    # other stuff.  The whole deal of having both is pretty iffy.
	    dotest mwrap-7 "${testcvs} -nq update" \
"${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.2 from repository is now in aa
${PROG} [a-z]*: file from working directory is now in \.#aa\.1\.1
C aa
U aa"
	  fi
a10632 1
	  rm $HOME/.cvsrc
d10642 2
a10710 10
	  # Deleting: the cases are basically either the tag existed,
	  # or it didn't exist.
	  dotest taginfo-14 "${testcvs} -q tag -d tag1" "D file1"
	  dotest taginfo-15 "${testcvs} -q tag -d tag1" ""

	  # Likewise with rtag.
	  dotest taginfo-16 "${testcvs} -q rtag tag1 first-dir" ""
	  dotest taginfo-17 "${testcvs} -q rtag -d tag1 first-dir" ""
	  dotest taginfo-18 "${testcvs} -q rtag -d tag1 first-dir" ""

d10725 1
a10725 6
brtag mov ${TESTDIR}/cvsroot/first-dir file1 1.1.2.1
tag1 del ${TESTDIR}/cvsroot/first-dir file1 1.1
tag1 del ${TESTDIR}/cvsroot/first-dir
tag1 add ${TESTDIR}/cvsroot/first-dir file1 1.1
tag1 del ${TESTDIR}/cvsroot/first-dir file1 1.1
tag1 del ${TESTDIR}/cvsroot/first-dir"
a10861 1
	  #   -s, -R: rcs3
a11005 22
	  dotest log-14a "${testcvs} log -rHEAD file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  # The user might not realize that "-r" must not take a space.
	  # In the error message, HEAD is a file name, not a tag name (which
	  # might be confusing itself).
	  dotest_fail log-14b "${testcvs} log -r HEAD file1" \
"${PROG} [a-z]*: nothing known about HEAD
${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

a11184 3
	  dotest_fail log2-7a "${testcvs} admin -t${TESTDIR}/nonexist file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
${PROG} \[[a-z]* aborted\]: can't stat ${TESTDIR}/nonexist: No such file or directory"
a11206 5
	    # TODO: `cvs admin -t "my message" file1' is a request to
	    # read the message from stdin and to operate on two files.
	    # Should test that there is an error because "my message"
	    # doesn't exist.

a11242 1
	  #   keywordlog Annotate and $Log.
a11473 12
	    # Use :ext: rather than :fork:.  Most of the tests use :fork:,
	    # so we want to make sure that we test :ext: _somewhere_.

	    # Maybe a bit dubious in the sense that people need to
	    # have rsh working to run the tests, but at least it
	    # isn't inetd :-).  Might want to think harder about this -
	    # maybe try :ext:, and if it fails, print a (single, nice)
	    # message and fall back to :fork:.  Maybe testing :ext:
	    # with our own CVS_RSH rather than worrying about a system one
	    # would do the trick.

	    # Note that we set CVS_SERVER at the beginning.
a11475 6
	    # If we're going to do remote testing, make sure 'rsh' works first.
	    host="`hostname`"
	    if test "x`${CVS_RSH-rsh} $host -n 'echo hi'`" != "xhi"; then
		echo "ERROR: cannot test remote CVS, because \`rsh $host' fails." >&2
		exit 1
	    fi
a11493 4
	    # Note that having the client reject the pathname (as :fork:
	    # does), does _not_ test for the bugs we are trying to catch
	    # here.  The point is that malicious clients might send all
	    # manner of things and the server better protect itself.
d11563 22
a11584 3
	  dotest crerepos-18 "${testcvs} update" \
"${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: Updating crerepos-dir"
a11587 5
	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

a12147 26

	  dotest rcs2-6 "${testcvs} -q update -p -D 2007-01-07 file1" \
"head revision"
	  # This assumes that the clock of the machine running the tests
	  # is set to at least the year 1998 or so.  There don't seem
	  # to be a lot of ways to test the relative date code (short
	  # of something like LD_LIBRARY_PRELOAD'ing in our own
	  # getttimeofday, or hacking the CVS source with testing
	  # features, which always seems to be problematic since then
	  # someone feels like documenting them and things go downhill
	  # from there).
	  if ${testcvs} -q update -p -D '100 months' file1 \
	      >${TESTDIR}/rcs4.tmp 2>&1
	  then
	    dotest rcs2-7 "cat ${TESTDIR}/rcs4.tmp" "head revision"
	  else
	    fail rcs2-7
	  fi
	  if ${testcvs} -q update -p -D '8 years' file1 \
	      >${TESTDIR}/rcs4.tmp 2>&1
	  then
	    dotest rcs2-8 "cat ${TESTDIR}/rcs4.tmp" "head revision"
	  else
	    fail rcs2-8
	  fi

a12154 143
	rcs3)
	  # More RCS file tests, in particular at least some of the
	  # error handling issues.
	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head 1.1; access; symbols; locks; expand o; 1.1 date 2007.03.20.04.03.02
; author jeremiah ;state ;  branches; next;desc@@@@1.1log@@@@text@@head@@
EOF
	  mkdir 1; cd 1
	  # CVS requires whitespace between "desc" and its value.
	  # The rcsfile(5) manpage doesn't really seem to answer the
	  # question one way or the other (it has a grammar but almost
	  # nothing about lexical analysis).
	  dotest_fail rcs3-1 "${testcvs} -q co first-dir" \
"${PROG} \[[a-z]* aborted\]: unexpected end of file reading ${TESTDIR}/cvsroot/first-dir/file1,v"
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head 1.1; access; symbols; locks; expand o; 1.1 date 2007.03.20.04.03.02
; author jeremiah ;state ;  branches; next;desc @@@@1.1log@@@@text@@head@@
EOF
	  # Whitespace issues, likewise.
	  dotest_fail rcs3-2 "${testcvs} -q co first-dir" \
"${PROG} \[[a-z]* aborted\]: unexpected '.x6c' reading revision number in RCS file ${TESTDIR}/cvsroot/first-dir/file1,v"
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head 1.1; access; symbols; locks; expand o; 1.1 date 2007.03.20.04.03.02
; author jeremiah ;state ;  branches; next;desc @@@@1.1 log@@@@text@@head@@
EOF
	  # Charming array of different messages for similar
	  # whitespace issues (depending on where the whitespace is).
	  dotest_fail rcs3-3 "${testcvs} -q co first-dir" \
"${PROG} \[[a-z]* aborted\]: EOF while looking for value in RCS file ${TESTDIR}/cvsroot/first-dir/file1,v"
	  cat <<EOF >${CVSROOT_DIRNAME}/first-dir/file1,v
head 1.1; access; symbols; locks; expand o; 1.1 date 2007.03.20.04.03.02
; author jeremiah ;state ;  branches; next;desc @@@@1.1 log @@@@text @@head@@
EOF
	  dotest rcs3-4 "${testcvs} -q co first-dir" 'U first-dir/file1'
	  if test "$remote" = no; then
	    # Ouch, didn't expect this one.  FIXCVS.  Or maybe just remove
	    # the feature, if this is a -s problem?
	    dotest_fail rcs3-5 "${testcvs} log -s nostate first-dir/file1" \
".*[Aa]ssertion.*failed${DOTSTAR}" ".*failed assertion${DOTSTAR}"
	  else # remote
	    # Is this a reaction to the lack of TopLevelAdmin or something?
	    # Seems pretty strange to me.  Seems vaguely similar to the
	    # "no repository" message in errmsg2-16 although I'm leaving
	    # it here in case there is a difference between "cvs add" and a
	    # normal start_recursion command like "cvs log".
	    dotest_fail rcs3-5 "${testcvs} log -s nostate first-dir/file1" \
"${PROG} log: cannot open CVS/Entries for reading: No such file or directory
${PROG} \[log aborted\]: no repository"
	    cd first-dir
	    dotest_fail rcs3-5a "${testcvs} log -s nostate file1" \
"${DOTSTAR}ssertion.*failed${DOTSTAR}" "${DOTSTAR}failed assertion${DOTSTAR}"
	    cd ..
	  fi # remote

	  # See remote code above for rationale for cd.
	  cd first-dir
	  dotest rcs3-6 "${testcvs} log -R file1" \
"${TESTDIR}/cvsroot/first-dir/file1,v"

	  # OK, now put an extraneous '\0' at the end.
	  awk </dev/null 'BEGIN { printf "@@%c", 10 }' | tr '@@' '\000' \
	    >>${CVSROOT_DIRNAME}/first-dir/file1,v
	  dotest_fail rcs3-7 "${testcvs} log -s nostate file1" \
"${PROG} \[[a-z]* aborted\]: unexpected '.x0' reading revision number in RCS file ${TESTDIR}/cvsroot/first-dir/file1,v"

	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	lockfiles)
	  # Tests of CVS lock files.
	  # TODO-maybe: Add a test where we arrange for a loginfo
	  # script (or some such) to ensure that locks are in place
	  # so then we can see how they are behaving.

	  mkdir 1; cd 1
	  mkdir sdir
	  mkdir sdir/ssdir
	  echo file >sdir/ssdir/file1
	  dotest lockfiles-1 \
"${testcvs} -Q import -m import-it first-dir bar baz" ""
	  cd ..

	  mkdir 2; cd 2
	  dotest lockfiles-2 "${testcvs} -q co first-dir" \
"U first-dir/sdir/ssdir/file1"
	  dotest lockfiles-3 "${testcvs} -Q co CVSROOT" ""
	  cd CVSROOT
	  echo "LockDir=${TESTDIR}/locks" >config
	  dotest lockfiles-4 "${testcvs} -q ci -m config-it" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../first-dir/sdir/ssdir
	  # The error message appears twice because Lock_Cleanup only
	  # stops recursing after the first attempt.
	  dotest_fail lockfiles-5 "${testcvs} -q update" \
"${PROG} \[[a-z]* aborted\]: cannot stat ${TESTDIR}/locks: No such file or directory
${PROG} \[[a-z]* aborted\]: cannot stat ${TESTDIR}/locks: No such file or directory"
	  mkdir ${TESTDIR}/locks
	  chmod u=rwx,g=r,o= ${TESTDIR}/locks
	  umask 0077
	  CVSUMASK=0077; export CVSUMASK
	  dotest lockfiles-6 "${testcvs} -q update" ""
	  # TODO: should also be testing that CVS continues to honor the
	  # umask and CVSUMASK normally.  In the case of the umask, CVS
	  # doesn't seem to use it for much (although it perhaps should).
	  dotest lockfiles-7 "ls ${TESTDIR}/locks/first-dir/sdir/ssdir" ""

	  # The policy is that when CVS creates new lock directories, they
	  # inherit the permissions from the parent directory.  CVSUMASK
	  # isn't right, because typically the reason for LockDir is to
	  # use a different set of permissions.
	  dotest lockfiles-7a "ls -ld ${TESTDIR}/locks/first-dir" \
"drwxr----- .*first-dir"
	  dotest lockfiles-7b "ls -ld ${TESTDIR}/locks/first-dir/sdir/ssdir" \
"drwxr----- .*first-dir/sdir/ssdir"

	  cd ../../..
	  dotest lockfiles-8 "${testcvs} -q update" ""

	  cd CVSROOT
	  echo "# nobody here but us comments" >config
	  dotest lockfiles-cleanup-1 "${testcvs} -q ci -m config-it" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	  cd ../..
	  # Perhaps should restore the umask and CVSUMASK to what they
	  # were before.  But the other tests "should" not care about them...
	  umask 0077
	  unset CVSUMASK
	  rm -r ${TESTDIR}/locks
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d12371 1
a12371 4
	    # course, bogus, but that is the way it is currently.  The
	    # first match is for the :ext: method (where the CVSUMASK
	    # won't be set), while the second is for the :fork: method
	    # (where it will be).
d12374 1
a12374 1
"-r--r--r--.*" "-r--r-----.*"
a12433 58
	modes3)
	  # Repository permissions.  Particularly, what happens if we
	  # can't read/write in the repository.
	  # TODO: the case where we can access the repository, just not
	  # the attic (may that one can remain a fatal error, seems less
	  # useful for access control).
	  mkdir 1; cd 1
	  dotest modes-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir second-dir
	  dotest modes-2 "${testcvs} add first-dir second-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository
Directory ${TESTDIR}/cvsroot/second-dir added to the repository"
	  touch first-dir/aa second-dir/ab
	  dotest modes-3 "${testcvs} add first-dir/aa second-dir/ab" \
"${PROG} [a-z]*: scheduling file .first-dir/aa. for addition
${PROG} [a-z]*: scheduling file .second-dir/ab. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest modes-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/aa,v
done
Checking in first-dir/aa;
${TESTDIR}/cvsroot/first-dir/aa,v  <--  aa
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/second-dir/ab,v
done
Checking in second-dir/ab;
${TESTDIR}/cvsroot/second-dir/ab,v  <--  ab
initial revision: 1\.1
done"
	  chmod a= ${TESTDIR}/cvsroot/first-dir
	  dotest modes-5 "${testcvs} update" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: cannot open directory ${TESTDIR}/cvsroot/first-dir: Permission denied
${PROG} [a-z]*: skipping directory first-dir
${PROG} [a-z]*: Updating second-dir"

	  # OK, I can see why one might say the above case could be a
	  # fatal error, because normally users without access to first-dir
	  # won't have it in their working directory.  But the next
	  # one is more of a problem if it is fatal.
	  rm -r first-dir
	  dotest modes-6 "${testcvs} update -dP" \
"${PROG} [a-z]*: Updating .
${PROG} [a-z]*: Updating CVSROOT
U ${DOTSTAR}
${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: cannot open directory ${TESTDIR}/cvsroot/first-dir: Permission denied
${PROG} [a-z]*: skipping directory first-dir
${PROG} [a-z]*: Updating second-dir"

	  cd ..
	  rm -r 1
	  chmod u+rwx ${TESTDIR}/cvsroot/first-dir
	  rm -rf ${TESTDIR}/cvsroot/first-dir ${TESTDIR}/cvsroot/second-dir
	  ;;

a12875 2
	  # Other keyword expansion tests:
	  #   keywordlog - $Log.
d13074 1
a13074 1
	  echo initial >file1
d13079 6
a13084 2
	  # See "rmadd" for a list of other tests of cvs ci -r.
	  dotest keywordlog-4 "${testcvs} -q ci -r 1.3 -m add file1" \
d13089 1
a13089 1
initial revision: 1\.3
d13097 1
a13097 1
	  echo 'xx $''Log$' >> file1
a13101 7
	  # As with rmadd-25, "cvs ci -r" sets a sticky tag.
	  dotest_fail keywordlog-4b \
"${testcvs} ci -F ${TESTDIR}/comment.tmp file1" \
"${PROG} [a-z]*: sticky tag .1\.3. for file .file1. is not a branch
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  dotest keywordlog-4c "${testcvs} -q update -A" "M file1"

d13105 1
a13105 1
new revision: 1\.4; previous revision: 1\.3
d13110 2
a13111 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13119 2
a13120 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13130 1
a13130 1
new revision: 1\.5; previous revision: 1\.4
d13133 2
a13134 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.5  [0-9/]* [0-9:]*  ${username}
d13137 1
a13137 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13146 2
a13147 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.5  [0-9/]* [0-9:]*  ${username}
d13150 1
a13150 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13162 1
a13162 1
new revision: 1\.4\.2\.1; previous revision: 1\.4
d13165 2
a13166 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4\.2\.1  [0-9/]* [0-9:]*  ${username}
d13169 1
a13169 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13177 2
a13178 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4\.2\.1  [0-9/]* [0-9:]*  ${username}
d13181 1
a13181 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13188 2
a13189 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4\.2\.1  [0-9/]* [0-9:]*  ${username}
d13192 1
a13192 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13198 2
a13199 3
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.5  [0-9/]* [0-9:]*  ${username}
d13202 1
a13202 1
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
d13207 3
a13209 4
	  dotest keywordlog-21 "${testcvs} -q co -p -r 1.4 first-dir/file1" \
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
a13213 32
	  cd 2/first-dir
	  # OK, the basic rule for keyword expansion is that it
	  # happens on checkout.  And the rule for annotate is that
	  # it annotates a checked-in revision, rather than a checked-out
	  # file.  So, although it is kind of confusing that the latest
	  # revision does not appear in the annotated output, and the
	  # annotated output does not quite match what you'd get with
	  # update or checkout, the behavior is more or less logical.
	  # The same issue occurs with annotate and other keywords,
	  # I think, although it is particularly noticeable for $Log.
	  dotest keywordlog-22 "${testcvs} ann -r br file1" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.3          (${username} *[0-9a-zA-Z-]*): initial
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): xx "'\$'"Log: file1,v "'\$'"
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): xx First log line
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): xx Second log line
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): xx
1\.4\.2\.1      (${username} *[0-9a-zA-Z-]*): br-change"
	  dotest keywordlog-23 "${testcvs} ann -r HEAD file1" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.3          (${username} *[0-9a-zA-Z-]*): initial
1\.5          (${username} *[0-9a-zA-Z-]*): xx "'\$'"Log: file1,v "'\$'"
1\.5          (${username} *[0-9a-zA-Z-]*): xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
1\.5          (${username} *[0-9a-zA-Z-]*): xx First log line
1\.5          (${username} *[0-9a-zA-Z-]*): xx Second log line
1\.5          (${username} *[0-9a-zA-Z-]*): xx
1\.5          (${username} *[0-9a-zA-Z-]*): change"
	  cd ../..

d13624 1
a13624 1
	  # Extract the author value.
d13626 1
a13627 1
	  # Form a suffix string of length (16 - length($name)).
d13629 3
a13631 2
	  sed_pattern=`echo $name|sed s/././g`
	  suffix=`echo 1234567890123456|sed s/$sed_pattern//`
d13666 1
a13666 2
	  #   binfiles-o1 (1.3:: and ::1.3; binary files)
	  #   binfiles3-9 (binary files)
a13805 1
	  # Note that we must accept either 2 or 4 digit year.
d13820 1
a13820 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
d13826 1
a13826 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
d14225 1
a14225 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
d14231 1
a14231 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state foo;
d14396 1
a14396 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
d14401 1
a14401 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
d14406 1
a14406 1
date	[0-9][0-9]*\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9]\.[0-9][0-9];	author ${username};	state Exp;
a15498 1970
	release)
	  # Tests of "cvs release", particularly multiple arguments.
	  # Other CVS release tests:
	  #   info-cleanup-0 for "cvs -n release".
	  #   ignore-193 for the text of the question that cvs release asks.
	  #     Also for interactions with cvsignore.
	  #   basicc: "-d .", global -Q, no arguments (is a noop),
	  #     "cvs release" without -d, multiple arguments.
	  #   dirs-4: repository directory has been deleted.
	  #   modules2-6: multiple arguments.

	  # First the usual setup; create a directory first-dir.
	  mkdir 1; cd 1
	  dotest release-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest release-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  mkdir dir1
	  dotest release-3 "${testcvs} add dir1" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir1 added to the repository"
	  mkdir dir2
	  dotest release-4 "${testcvs} add dir2" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir2 added to the repository"
          cd dir2
	  mkdir dir3
	  dotest release-5 "${testcvs} add dir3" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir2/dir3 added to the repository"

          cd ../..
	  dotest release-6 "${testcvs} release -d first-dir/dir2/dir3 first-dir/dir1" \
"You have .0. altered files in this repository.
Are you sure you want to release (and delete) directory .first-dir/dir2/dir3.: \
You have .0. altered files in this repository.
Are you sure you want to release (and delete) directory .first-dir/dir1.: " <<EOF
yes
yes
EOF
	  dotest_fail release-7 "test -d first-dir/dir1" ''
	  dotest_fail release-8 "test -d first-dir/dir2/dir3" ''
	  dotest release-9 "${testcvs} update" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating first-dir
${PROG} [a-z]*: Updating first-dir/dir2"

          cd first-dir
	  mkdir dir1
	  dotest release-10 "${testcvs} add dir1" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir1 added to the repository"
          cd dir2
	  mkdir dir3
	  dotest release-11 "${testcvs} add dir3" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir2/dir3 added to the repository"

          cd ../..
	  dotest release-12 "${testcvs} release first-dir/dir2/dir3 first-dir/dir1" \
"You have .0. altered files in this repository.
Are you sure you want to release directory .first-dir/dir2/dir3.: .. .release. aborted by user choice.
You have .0. altered files in this repository.
Are you sure you want to release directory .first-dir/dir1.: " <<EOF
no
yes
EOF
	  dotest release-13 "${testcvs} release first-dir/dir2/dir3 first-dir/dir2" \
"You have .0. altered files in this repository.
Are you sure you want to release directory .first-dir/dir2/dir3.: \
You have .0. altered files in this repository.
Are you sure you want to release directory .first-dir/dir2.: " <<EOF
yes
yes
EOF
	  dotest release-14 "test -d first-dir/dir1" ''
	  dotest release-15 "test -d first-dir/dir2/dir3" ''
	  rm -rf first-dir/dir1 first-dir/dir2

	  dotest release-16 "${testcvs} update" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating first-dir"
	  cd ..
	  rm -rf 1
	  ;;
	  
	multiroot)
	
	  #
	  # set up two repositories
	  #

	  CVSROOT1_DIRNAME=${TESTDIR}/root1
	  CVSROOT2_DIRNAME=${TESTDIR}/root2
	  CVSROOT1=${CVSROOT1_DIRNAME} ; export CVSROOT1
	  CVSROOT2=${CVSROOT2_DIRNAME} ; export CVSROOT2
	  if test "x$remote" = xyes; then
	      CVSROOT1=:fork:${CVSROOT1_DIRNAME} ; export CVSROOT1
	      CVSROOT2=:fork:${CVSROOT2_DIRNAME} ; export CVSROOT2
	  fi
	  testcvs1="${testcvs} -d ${CVSROOT1}"
	  testcvs2="${testcvs} -d ${CVSROOT2}"

	  dotest multiroot-setup-1 "mkdir ${CVSROOT1_DIRNAME} ${CVSROOT2_DIRNAME}" ""
	  dotest multiroot-setup-2 "${testcvs1} init" ""
	  dotest multiroot-setup-3 "${testcvs2} init" ""

	  #
	  # create some directories in root1
	  #
	  mkdir 1; cd 1
	  dotest multiroot-setup-4 "${testcvs1} co -l ." "${PROG} [a-z]*: Updating ."
	  mkdir mod1-1 mod1-2
	  dotest multiroot-setup-5 "${testcvs1} add mod1-1 mod1-2" \
"Directory ${CVSROOT1_DIRNAME}/mod1-1 added to the repository
Directory ${CVSROOT1_DIRNAME}/mod1-2 added to the repository"
	  echo file1-1 > mod1-1/file1-1
	  echo file1-2 > mod1-2/file1-2
	  dotest multiroot-setup-6 "${testcvs1} add mod1-1/file1-1 mod1-2/file1-2" \
"${PROG} [a-z]*: scheduling file .mod1-1/file1-1. for addition
${PROG} [a-z]*: scheduling file .mod1-2/file1-2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"
	  dotest multiroot-setup-7 "${testcvs1} commit -m is" \
"${PROG} [a-z]*: Examining \.
${PROG} [a-z]*: Examining mod1-1
${PROG} [a-z]*: Examining mod1-2
RCS file: ${CVSROOT1_DIRNAME}/mod1-1/file1-1,v
done
Checking in mod1-1/file1-1;
${CVSROOT1_DIRNAME}/mod1-1/file1-1,v  <--  file1-1
initial revision: 1.1
done
RCS file: ${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
done
Checking in mod1-2/file1-2;
${CVSROOT1_DIRNAME}/mod1-2/file1-2,v  <--  file1-2
initial revision: 1.1
done"
	  cd ..
	  rm -rf 1

	  #
	  # create some directories in root2
	  #
	  mkdir 1; cd 1
	  dotest multiroot-setup-8 "${testcvs2} co -l ." "${PROG} [a-z]*: Updating ."
	  mkdir mod2-1 mod2-2
	  dotest multiroot-setup-9 "${testcvs2} add mod2-1 mod2-2" \
"Directory ${CVSROOT2_DIRNAME}/mod2-1 added to the repository
Directory ${CVSROOT2_DIRNAME}/mod2-2 added to the repository"
	  echo file2-1 > mod2-1/file2-1
	  echo file2-2 > mod2-2/file2-2
	  dotest multiroot-setup-6 "${testcvs2} add mod2-1/file2-1 mod2-2/file2-2" \
"${PROG} [a-z]*: scheduling file .mod2-1/file2-1. for addition
${PROG} [a-z]*: scheduling file .mod2-2/file2-2. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"
	  dotest multiroot-setup-10 "${testcvs2} commit -m anyone" \
"${PROG} [a-z]*: Examining \.
${PROG} [a-z]*: Examining mod2-1
${PROG} [a-z]*: Examining mod2-2
RCS file: ${CVSROOT2_DIRNAME}/mod2-1/file2-1,v
done
Checking in mod2-1/file2-1;
${CVSROOT2_DIRNAME}/mod2-1/file2-1,v  <--  file2-1
initial revision: 1.1
done
RCS file: ${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
done
Checking in mod2-2/file2-2;
${CVSROOT2_DIRNAME}/mod2-2/file2-2,v  <--  file2-2
initial revision: 1.1
done"
	  cd ..
	  rm -rf 1

	  # check out a few directories, from simple/shallow to
	  # complex/deep
	  mkdir 1; cd 1

	  # OK, this case is kind of weird.  If we just run things from
	  # here, without CVS/Root, then CVS will contact the server
	  # mentioned in CVSROOT (which is irrelevant) which will print
	  # some messages.  Our workaround is to make sure we have a
	  # CVS/Root file at top level.  In the future, it is possible
	  # the best behavior will be to extend the existing behavior
	  # ("being called from a directory without CVS administration
	  # has always meant to process each of the sub-dirs") to also
	  # do that if there is no CVSROOT, CVS/Root, or -d at top level.
	  # 
	  # The local case could stumble through the tests without creating
	  # the top-level CVS/Root, but we create it for local and for
	  # remote to reduce special cases later in the test.
	  dotest multiroot-workaround "${testcvs1} -q co -l ." ""

	  dotest multiroot-setup-11 "${testcvs1} co mod1-1 mod1-2" \
"${PROG} [a-z]*: Updating mod1-1
U mod1-1/file1-1
${PROG} [a-z]*: Updating mod1-2
U mod1-2/file1-2"
	  dotest multiroot-setup-12 "${testcvs2} co mod2-1 mod2-2" \
"${PROG} [a-z]*: Updating mod2-1
U mod2-1/file2-1
${PROG} [a-z]*: Updating mod2-2
U mod2-2/file2-2"
	  cd mod1-2
	  dotest multiroot-setup-13 "${testcvs2} co mod2-2" \
"${PROG} [a-z]*: Updating mod2-2
U mod2-2/file2-2"
	  cd ..
	  cd mod2-2
	  dotest multiroot-setup-14 "${testcvs1} co mod1-2" \
"${PROG} [a-z]*: Updating mod1-2
U mod1-2/file1-2"
	  cd ..

	  # Try to determine whether RELATIVE_REPOS is defined
	  # so that we can make the following a lot less
	  # verbose.

	  echo "${CVSROOT1_DIRNAME}/mod1-1" > dotest.abs
	  echo "mod1-1" > dotest.rel
	  if cmp dotest.abs mod1-1/CVS/Repository >/dev/null 2>&1; then
	    AREP1="${CVSROOT1_DIRNAME}/"
	    AREP2="${CVSROOT2_DIRNAME}/"
	  elif cmp dotest.rel mod1-1/CVS/Repository >/dev/null 2>&1; then
	    AREP1=""
	    AREP2=""
	  else
	    fail "Cannot figure out if RELATIVE_REPOS is defined."
	  fi
	  rm -f dotest.abs dotest.rel

	  #
	  # Make sure that the Root and Repository files contain the
	  # correct information.
	  #
	  dotest multiroot-cvsadm-1a "cat mod1-1/CVS/Root" "${CVSROOT1}"
	  dotest multiroot-cvsadm-1b "cat mod1-1/CVS/Repository" "${AREP1}mod1-1"
	  dotest multiroot-cvsadm-2a "cat mod2-1/CVS/Root" "${CVSROOT2}"
	  dotest multiroot-cvsadm-2b "cat mod2-1/CVS/Repository" "${AREP2}mod2-1"
	  dotest multiroot-cvsadm-3a "cat mod1-2/CVS/Root" "${CVSROOT1}"
	  dotest multiroot-cvsadm-3b "cat mod1-2/CVS/Repository" "${AREP1}mod1-2"
	  dotest multiroot-cvsadm-3c "cat mod1-2/mod2-2/CVS/Root" "${CVSROOT2}"
	  dotest multiroot-cvsadm-3d "cat mod1-2/mod2-2/CVS/Repository" "${AREP2}mod2-2"
	  dotest multiroot-cvsadm-4a "cat mod2-2/CVS/Root" "${CVSROOT2}"
	  dotest multiroot-cvsadm-4b "cat mod2-2/CVS/Repository" "${AREP2}mod2-2"
	  dotest multiroot-cvsadm-4c "cat mod2-2/mod1-2/CVS/Root" "${CVSROOT1}"
	  dotest multiroot-cvsadm-4d "cat mod2-2/mod1-2/CVS/Repository" "${AREP1}mod1-2"

	  #
	  # Start testing various cvs commands.  Begin with commands
	  # without extra arguments (e.g. "cvs update", "cvs diff",
	  # etc.
	  #

	  # Do at least one command with both CVSROOTs to make sure
	  # that there's not some kind of unexpected dependency on the
	  # choice of which CVSROOT is specified on the command line.

	  if test "${AREP1}" = ""; then
	    # RELATIVE_REPOS.
	    dotest multiroot-update-1a "${testcvs1} update" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root1/mod2-2: No such file or directory
${PROG} [a-z]*: skipping directory mod1-2/mod2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root1/mod2-1: No such file or directory
${PROG} [a-z]*: skipping directory mod2-1
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root1/mod2-2: No such file or directory
${PROG} [a-z]*: skipping directory mod2-2"

	    # Same deal but with -d ${CVSROOT2}.
	    dotest multiroot-update-1b "${testcvs2} update" \
"${PROG} [a-z]*: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root2/mod1-1: No such file or directory
${PROG} [a-z]*: skipping directory mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root2/mod1-2: No such file or directory
${PROG} [a-z]*: skipping directory mod1-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/mod1-2
${PROG} [a-z]*: cannot open directory ${TESTDIR}/root2/mod1-2: No such file or directory
${PROG} [a-z]*: skipping directory mod2-2/mod1-2"
	  else
	    # non-RELATIVE_REPOS.
	    if test "$remote" = no; then
	      # The basic idea is that -d overrides CVS/Root.
	      # With RELATIVE_REPOS, CVS could print an error when it
	      # tries to recurse to mod2-2, which doesn't exist in
	      # this repository (?)  With absolute, CVS will just look at the
	      # CVS/Repository for the other root (and log to the wrong
	      # history file and that sort of thing).
	      dotest multiroot-update-1a "${testcvs1} update" \
"${PROG} update: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/mod1-2"
	    else
	      # Hmm, this one is specific to non-RELATIVE_REPOS too I think.
	      dotest_fail multiroot-update-1a "${testcvs1} update" \
"protocol error: directory '${TESTDIR}/root2/mod2-2' not within root '${TESTDIR}/root1'"
	    fi # non-remote

	    # Same deal but with -d ${CVSROOT2}.
	    if test "$remote" = no; then
	      dotest multiroot-update-1b "${testcvs2} update" \
"${PROG} update: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/mod1-2"
	    else
	      dotest_fail multiroot-update-1b "${testcvs2} update" \
"protocol error: directory '${TESTDIR}/root1' not within root '${TESTDIR}/root2'"
	    fi # non-remote
	  fi # non-RELATIVE_REPOS

	  # modify all files and do a diff

	  echo bobby >> mod1-1/file1-1
	  echo brown >> mod1-2/file1-2
	  echo goes >> mod2-1/file2-1
	  echo down >> mod2-2/file2-2

	  dotest_status multiroot-diff-1 1 "${testcvs} diff" \
"${PROG} diff: Diffing \.
${PROG} [a-z]*: Diffing mod1-1
Index: mod1-1/file1-1
===================================================================
RCS file: ${TESTDIR}/root1/mod1-1/file1-1,v
retrieving revision 1\.1
diff -r1\.1 file1-1
1a2
> bobby
${PROG} [a-z]*: Diffing mod1-2
Index: mod1-2/file1-2
===================================================================
RCS file: ${TESTDIR}/root1/mod1-2/file1-2,v
retrieving revision 1\.1
diff -r1\.1 file1-2
1a2
> brown
${PROG} [a-z]*: Diffing mod2-2/mod1-2
${PROG} [a-z]*: Diffing mod1-2/mod2-2
${PROG} [a-z]*: Diffing mod2-1
Index: mod2-1/file2-1
===================================================================
RCS file: ${TESTDIR}/root2/mod2-1/file2-1,v
retrieving revision 1\.1
diff -r1\.1 file2-1
1a2
> goes
${PROG} [a-z]*: Diffing mod2-2
Index: mod2-2/file2-2
===================================================================
RCS file: ${TESTDIR}/root2/mod2-2/file2-2,v
retrieving revision 1\.1
diff -r1\.1 file2-2
1a2
> down" \
"${PROG} server: Diffing \.
${PROG} [a-z]*: Diffing mod1-1
Index: mod1-1/file1-1
===================================================================
RCS file: ${TESTDIR}/root1/mod1-1/file1-1,v
retrieving revision 1\.1
diff -r1\.1 file1-1
1a2
> bobby
${PROG} [a-z]*: Diffing mod1-2
Index: mod1-2/file1-2
===================================================================
RCS file: ${TESTDIR}/root1/mod1-2/file1-2,v
retrieving revision 1\.1
diff -r1\.1 file1-2
1a2
> brown
${PROG} [a-z]*: Diffing mod2-2
${PROG} [a-z]*: Diffing mod2-2/mod1-2
${PROG} [a-z]*: Diffing mod1-2
${PROG} [a-z]*: Diffing mod1-2/mod2-2
${PROG} [a-z]*: Diffing mod2-1
Index: mod2-1/file2-1
===================================================================
RCS file: ${TESTDIR}/root2/mod2-1/file2-1,v
retrieving revision 1\.1
diff -r1\.1 file2-1
1a2
> goes
${PROG} [a-z]*: Diffing mod2-2
Index: mod2-2/file2-2
===================================================================
RCS file: ${TESTDIR}/root2/mod2-2/file2-2,v
retrieving revision 1\.1
diff -r1\.1 file2-2
1a2
> down"


	  dotest multiroot-commit-1 "${testcvs} commit -m actually" \
"${PROG} [a-z]*: Examining \.
${PROG} [a-z]*: Examining mod1-1
${PROG} [a-z]*: Examining mod1-2
${PROG} [a-z]*: Examining mod2-2/mod1-2
Checking in mod1-1/file1-1;
${TESTDIR}/root1/mod1-1/file1-1,v  <--  file1-1
new revision: 1.2; previous revision: 1.1
done
Checking in mod1-2/file1-2;
${TESTDIR}/root1/mod1-2/file1-2,v  <--  file1-2
new revision: 1.2; previous revision: 1.1
done
${PROG} [a-z]*: Examining mod1-2/mod2-2
${PROG} [a-z]*: Examining mod2-1
${PROG} [a-z]*: Examining mod2-2
Checking in mod2-1/file2-1;
${TESTDIR}/root2/mod2-1/file2-1,v  <--  file2-1
new revision: 1.2; previous revision: 1.1
done
Checking in mod2-2/file2-2;
${TESTDIR}/root2/mod2-2/file2-2,v  <--  file2-2
new revision: 1.2; previous revision: 1.1
done"

	  dotest multiroot-update-2 "${testcvs} update" \
"${PROG} update: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod2-2/mod1-2
U mod2-2/mod1-2/file1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
U mod1-2/mod2-2/file2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2" \
"${PROG} server: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/mod1-2
P mod2-2/mod1-2/file1-2
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
P mod1-2/mod2-2/file2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2"

	  dotest multiroot-tag-1 "${testcvs} tag cattle" \
"${PROG} tag: Tagging \.
${PROG} [a-z]*: Tagging mod1-1
T mod1-1/file1-1
${PROG} [a-z]*: Tagging mod1-2
T mod1-2/file1-2
${PROG} [a-z]*: Tagging mod2-2/mod1-2
${PROG} [a-z]*: Tagging mod1-2/mod2-2
T mod1-2/mod2-2/file2-2
${PROG} [a-z]*: Tagging mod2-1
T mod2-1/file2-1
${PROG} [a-z]*: Tagging mod2-2" \
"${PROG} server: Tagging \.
${PROG} [a-z]*: Tagging mod1-1
T mod1-1/file1-1
${PROG} [a-z]*: Tagging mod1-2
T mod1-2/file1-2
${PROG} [a-z]*: Tagging mod2-2
${PROG} [a-z]*: Tagging mod2-2/mod1-2
${PROG} [a-z]*: Tagging mod1-2
${PROG} [a-z]*: Tagging mod1-2/mod2-2
T mod1-2/mod2-2/file2-2
${PROG} [a-z]*: Tagging mod2-1
T mod2-1/file2-1
${PROG} [a-z]*: Tagging mod2-2"

	  echo anotherfile1-1 > mod1-1/anotherfile1-1
	  echo anotherfile2-1 > mod2-1/anotherfile2-1
	  echo anotherfile1-2 > mod2-2/mod1-2/anotherfile1-2
	  echo anotherfile2-2 > mod1-2/mod2-2/anotherfile2-2

	  if test "x$remote" = xno; then
	    dotest multiroot-add-1 "${testcvs} add mod1-1/anotherfile1-1 mod2-1/anotherfile2-1 mod2-2/mod1-2/anotherfile1-2 mod1-2/mod2-2/anotherfile2-2" \
"${PROG} [a-z]*: scheduling file .mod1-1/anotherfile1-1. for addition
${PROG} [a-z]*: scheduling file .mod2-1/anotherfile2-1. for addition
${PROG} [a-z]*: scheduling file .mod2-2/mod1-2/anotherfile1-2. for addition
${PROG} [a-z]*: scheduling file .mod1-2/mod2-2/anotherfile2-2. for addition
${PROG} [a-z]*: use 'cvs commit' to add these files permanently"
          else
	    cd mod1-1
	    dotest multiroot-add-1a "${testcvs} add anotherfile1-1" \
"${PROG} [a-z]*: scheduling file .anotherfile1-1. for addition
${PROG} [a-z]*: use 'cvs commit' to add this file permanently"
	    cd ../mod2-1
	    dotest multiroot-add-1b "${testcvs} add anotherfile2-1" \
"${PROG} [a-z]*: scheduling file .anotherfile2-1. for addition
${PROG} [a-z]*: use 'cvs commit' to add this file permanently"
	    cd ../mod2-2/mod1-2
	    dotest multiroot-add-1c "${testcvs} add anotherfile1-2" \
"${PROG} [a-z]*: scheduling file .anotherfile1-2. for addition
${PROG} [a-z]*: use 'cvs commit' to add this file permanently"
	    cd ../../mod1-2/mod2-2
	    dotest multiroot-add-1d "${testcvs} add anotherfile2-2" \
"${PROG} [a-z]*: scheduling file .anotherfile2-2. for addition
${PROG} [a-z]*: use 'cvs commit' to add this file permanently"
	    cd ../..
          fi

	  dotest multiroot-status-1 "${testcvs} status -v" \
"${PROG} status: Examining \.
${PROG} [a-z]*: Examining mod1-1
===================================================================
File: anotherfile1-1   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file1-1          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-1/file1-1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod1-2
===================================================================
File: file1-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-2/mod1-2
===================================================================
File: anotherfile1-2   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file1-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod1-2/mod2-2
===================================================================
File: anotherfile2-2   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file2-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-1
===================================================================
File: anotherfile2-1   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file2-1          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-1/file2-1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-2
===================================================================
File: file2-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)" \
"${PROG} server: Examining \.
${PROG} [a-z]*: Examining mod1-1
===================================================================
File: anotherfile1-1   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file1-1          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-1/file1-1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod1-2
===================================================================
File: file1-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-2
${PROG} [a-z]*: Examining mod2-2/mod1-2
===================================================================
File: anotherfile1-2   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file1-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod1-2
${PROG} [a-z]*: Examining mod1-2/mod2-2
===================================================================
File: anotherfile2-2   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file2-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-1
===================================================================
File: anotherfile2-1   	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file2-1          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-1/file2-1,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)

${PROG} [a-z]*: Examining mod2-2
===================================================================
File: file2-2          	Status: Up-to-date

   Working revision:	1\.2.*
   Repository revision:	1\.2	${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	cattle                   	(revision: 1\.2)"

	  dotest multiroot-commit-2 "${testcvs} commit -m reading" \
"${PROG} [a-z]*: Examining \.
${PROG} [a-z]*: Examining mod1-1
${PROG} [a-z]*: Examining mod1-2
${PROG} [a-z]*: Examining mod2-2/mod1-2
RCS file: ${CVSROOT1_DIRNAME}/mod1-1/anotherfile1-1,v
done
Checking in mod1-1/anotherfile1-1;
${CVSROOT1_DIRNAME}/mod1-1/anotherfile1-1,v  <--  anotherfile1-1
initial revision: 1\.1
done
RCS file: ${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v
done
Checking in mod2-2/mod1-2/anotherfile1-2;
${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v  <--  anotherfile1-2
initial revision: 1\.1
done
${PROG} [a-z]*: Examining mod1-2/mod2-2
${PROG} [a-z]*: Examining mod2-1
${PROG} [a-z]*: Examining mod2-2
RCS file: ${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v
done
Checking in mod1-2/mod2-2/anotherfile2-2;
${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v  <--  anotherfile2-2
initial revision: 1\.1
done
RCS file: ${CVSROOT2_DIRNAME}/mod2-1/anotherfile2-1,v
done
Checking in mod2-1/anotherfile2-1;
${CVSROOT2_DIRNAME}/mod2-1/anotherfile2-1,v  <--  anotherfile2-1
initial revision: 1\.1
done"

	  dotest multiroot-update-3 "${testcvs} update" \
"${PROG} update: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
U mod1-2/anotherfile1-2
${PROG} [a-z]*: Updating mod2-2/mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2
U mod2-2/anotherfile2-2" \
"${PROG} server: Updating \.
${PROG} [a-z]*: Updating mod1-1
${PROG} [a-z]*: Updating mod1-2
U mod1-2/anotherfile1-2
${PROG} [a-z]*: Updating mod2-2
${PROG} [a-z]*: Updating mod2-2/mod1-2
${PROG} [a-z]*: Updating mod1-2
${PROG} [a-z]*: Updating mod1-2/mod2-2
${PROG} [a-z]*: Updating mod2-1
${PROG} [a-z]*: Updating mod2-2
U mod2-2/anotherfile2-2"

	  dotest multiroot-log-1 "${testcvs} log" \
"${PROG} log: Logging \.
${PROG} [a-z]*: Logging mod1-1

RCS file: ${CVSROOT1_DIRNAME}/mod1-1/anotherfile1-1,v
Working file: mod1-1/anotherfile1-1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-1/file1-1,v
Working file: mod1-1/file1-1
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod1-2

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v
Working file: mod1-2/anotherfile1-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
Working file: mod1-2/file1-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod2-2/mod1-2

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v
Working file: mod2-2/mod1-2/anotherfile1-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
Working file: mod2-2/mod1-2/file1-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod1-2/mod2-2

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v
Working file: mod1-2/mod2-2/anotherfile2-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
Working file: mod1-2/mod2-2/file2-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
=============================================================================
${PROG} [a-z]*: Logging mod2-1

RCS file: ${CVSROOT2_DIRNAME}/mod2-1/anotherfile2-1,v
Working file: mod2-1/anotherfile2-1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-1/file2-1,v
Working file: mod2-1/file2-1
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
=============================================================================
${PROG} [a-z]*: Logging mod2-2

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v
Working file: mod2-2/anotherfile2-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
Working file: mod2-2/file2-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
=============================================================================" \
"${PROG} server: Logging \.
${PROG} [a-z]*: Logging mod1-1

RCS file: ${CVSROOT1_DIRNAME}/mod1-1/anotherfile1-1,v
Working file: mod1-1/anotherfile1-1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-1/file1-1,v
Working file: mod1-1/file1-1
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod1-2

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v
Working file: mod1-2/anotherfile1-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
Working file: mod1-2/file1-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod2-2
${PROG} [a-z]*: Logging mod2-2/mod1-2

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/anotherfile1-2,v
Working file: mod2-2/mod1-2/anotherfile1-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT1_DIRNAME}/mod1-2/file1-2,v
Working file: mod2-2/mod1-2/file1-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
is
=============================================================================
${PROG} [a-z]*: Logging mod1-2
${PROG} [a-z]*: Logging mod1-2/mod2-2

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v
Working file: mod1-2/mod2-2/anotherfile2-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
Working file: mod1-2/mod2-2/file2-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
=============================================================================
${PROG} [a-z]*: Logging mod2-1

RCS file: ${CVSROOT2_DIRNAME}/mod2-1/anotherfile2-1,v
Working file: mod2-1/anotherfile2-1
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-1/file2-1,v
Working file: mod2-1/file2-1
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
=============================================================================
${PROG} [a-z]*: Logging mod2-2

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/anotherfile2-2,v
Working file: mod2-2/anotherfile2-2
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
reading
=============================================================================

RCS file: ${CVSROOT2_DIRNAME}/mod2-2/file2-2,v
Working file: mod2-2/file2-2
head: 1\.2
branch:
locks: strict
access list:
symbolic names:
	cattle: 1\.2
keyword substitution: kv
total revisions: 2;	selected revisions: 2
description:
----------------------------
revision 1\.2
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;  lines: ${PLUS}1 -0
actually
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
anyone
============================================================================="


	  # After the simple cases, let's execute some commands which
	  # refer to parts of our checked-out tree (e.g. "cvs update
	  # mod1-1 mod2-2")

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  # clean up after ourselves
	  cd ..
	  rm -r 1

	  # clean up our repositories
	  rm -rf root1 root2
	  ;;

	multiroot2)
	  # More multiroot tests.  In particular, nested directories.

	  CVSROOT1_DIRNAME=${TESTDIR}/root1
	  CVSROOT2_DIRNAME=${TESTDIR}/root2
	  CVSROOT1=${CVSROOT1_DIRNAME} ; export CVSROOT1
	  CVSROOT2=${CVSROOT2_DIRNAME} ; export CVSROOT2
	  if test "x$remote" = xyes; then
	      CVSROOT1=:fork:${CVSROOT1_DIRNAME} ; export CVSROOT1
	      CVSROOT2=:fork:${CVSROOT2_DIRNAME} ; export CVSROOT2
	  fi

	  dotest multiroot2-1 "${testcvs} -d ${CVSROOT1} init" ""
	  dotest multiroot2-2 "${testcvs} -d ${CVSROOT2} init" ""

	  mkdir imp-dir; cd imp-dir
	  echo file1 >file1
	  mkdir sdir
	  echo sfile >sdir/sfile
	  mkdir sdir/ssdir
	  echo ssfile >sdir/ssdir/ssfile
	  dotest_sort multiroot2-3 \
"${testcvs} -d ${CVSROOT1} import -m import-to-root1 dir1 vend rel" "

N dir1/file1
N dir1/sdir/sfile
N dir1/sdir/ssdir/ssfile
No conflicts created by this import
${PROG} [a-z]*: Importing ${TESTDIR}/root1/dir1/sdir
${PROG} [a-z]*: Importing ${TESTDIR}/root1/dir1/sdir/ssdir"
	  cd sdir
	  dotest_sort multiroot2-4 \
"${testcvs} -d ${CVSROOT2} import -m import-to-root2 sdir vend2 rel2" "

N sdir/sfile
N sdir/ssdir/ssfile
No conflicts created by this import
${PROG} [a-z]*: Importing ${TESTDIR}/root2/sdir/ssdir"
	  cd ../..

	  mkdir 1; cd 1
	  # Get TopLevelAdmin-like behavior.
	  dotest multiroot2-5 "${testcvs} -d ${CVSROOT1} -q co -l ."
	  dotest multiroot2-5 "${testcvs} -d ${CVSROOT1} -q co dir1" \
"U dir1/file1
U dir1/sdir/sfile
U dir1/sdir/ssdir/ssfile"
	  cd dir1
	  dotest multiroot2-6 "${testcvs} -Q release -d sdir" ""
	  dotest multiroot2-7 "${testcvs} -d ${CVSROOT2} -q co sdir" \
"U sdir/sfile
U sdir/ssdir/ssfile"
	  cd ..
	  # This has one subtle effect - it deals with Entries.Log
	  # so that the next test doesn't get trace messages for
	  # Entries.Log
	  dotest multiroot2-8 "${testcvs} update" \
"${PROG} update: Updating \.
${PROG} update: Updating dir1
${PROG} update: Updating dir1/sdir
${PROG} update: Updating dir1/sdir/ssdir" \
"${PROG} server: Updating \.
${PROG} server: Updating dir1
${PROG} server: Updating dir1
${PROG} server: Updating dir1/sdir
${PROG} server: Updating dir1/sdir/ssdir"
	  # Two reasons we don't run this on the server: (1) the server
	  # also prints some trace messages, and (2) the server trace
	  # messages are subject to out-of-order bugs (this one is hard
	  # to work around).
	  if test "$remote" = no; then
	    dotest multiroot2-9 "${testcvs} -t update" \
"${PROG} update: notice: main loop with CVSROOT=${TESTDIR}/root1
${PROG} update: Updating \.
${PROG} update: Updating dir1
${PROG} update: notice: main loop with CVSROOT=${TESTDIR}/root2
${PROG} update: Updating dir1/sdir
${PROG} update: Updating dir1/sdir/ssdir"
	  fi

	  dotest multiroot2-9 "${testcvs} -q tag tag1" \
"T dir1/file1
T dir1/sdir/sfile
T dir1/sdir/ssdir/ssfile"
	  echo "change it" >>dir1/file1
	  echo "change him too" >>dir1/sdir/sfile
	  dotest multiroot2-10 "${testcvs} -q ci -m modify" \
"Checking in dir1/file1;
${TESTDIR}/root1/dir1/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done
Checking in dir1/sdir/sfile;
${TESTDIR}/root2/sdir/sfile,v  <--  sfile
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest multiroot2-11 "${testcvs} -q tag tag2" \
"T dir1/file1
T dir1/sdir/sfile
T dir1/sdir/ssdir/ssfile"
	  dotest_status multiroot2-12 1 \
"${testcvs} -q diff -u -r tag1 -r tag2" \
"Index: dir1/file1
===================================================================
RCS file: ${TESTDIR}/root1/dir1/file1,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.2
diff -u -r1\.1\.1\.1 -r1\.2
--- dir1/file1	[0-9/]* [0-9:]*	1\.1\.1\.1
${PLUS}${PLUS}${PLUS} dir1/file1	[0-9/]* [0-9:]*	1\.2
@@@@ -1 ${PLUS}1,2 @@@@
 file1
${PLUS}change it
Index: dir1/sdir/sfile
===================================================================
RCS file: ${TESTDIR}/root2/sdir/sfile,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.2
diff -u -r1\.1\.1\.1 -r1\.2
--- dir1/sdir/sfile	[0-9/]* [0-9:]*	1\.1\.1\.1
${PLUS}${PLUS}${PLUS} dir1/sdir/sfile	[0-9/]* [0-9:]*	1\.2
@@@@ -1 ${PLUS}1,2 @@@@
 sfile
${PLUS}change him too"

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  # clean up after ourselves
	  cd ..
	  rm -r imp-dir 1

	  # clean up our repositories
	  rm -rf root1 root2
	  ;;

	multiroot3)
	  # More multiroot tests.  Directories are side-by-side, not nested.
	  # Not drastically different from multiroot but it covers somewhat
	  # different stuff.

	  if test "x$remote" = xyes; then
	    CVSROOT1=:fork:${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT2=:fork:${TESTDIR}/root2 ; export CVSROOT2
	  else
	    CVSROOT1=${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT2=${TESTDIR}/root2 ; export CVSROOT2
	  fi

	  mkdir 1; cd 1
	  dotest multiroot3-1 "${testcvs} -d ${CVSROOT1} init" ""
	  dotest multiroot3-2 "${testcvs} -d ${CVSROOT1} -q co -l ." ""
	  mkdir dir1
	  dotest multiroot3-3 "${testcvs} add dir1" \
"Directory ${TESTDIR}/root1/dir1 added to the repository"
	  dotest multiroot3-4 "${testcvs} -d ${CVSROOT2} init" ""
	  rm -r CVS
	  dotest multiroot3-5 "${testcvs} -d ${CVSROOT2} -q co -l ." ""
	  mkdir dir2

	  # OK, the problem is that CVS/Entries doesn't look quite right,
	  # I suppose because of the "rm -r".
	  # For local this fixes it up.
	  dotest multiroot3-6 "${testcvs} -d ${CVSROOT1} -q co dir1" ""
	  if test "$remote" = yes; then
	    # For remote that doesn't do it.  Use the quick and dirty fix.
	    echo "D/dir1////" >CVS/Entries
	    echo "D/dir2////" >>CVS/Entries
	  fi

	  dotest multiroot3-7 "${testcvs} add dir2" \
"Directory ${TESTDIR}/root2/dir2 added to the repository"

	  touch dir1/file1 dir2/file2
	  if test "$remote" = yes; then
	    # Trying to add them both in one command doesn't work,
	    # because add.c doesn't do multiroot (it doesn't use recurse.c).
	    # Furthermore, it can't deal with the parent directory
	    # having a different root from the child, hence the cd.
	    cd dir1
	    dotest multiroot3-8 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	    cd ..
	    dotest multiroot3-8a "${testcvs} add dir2/file2" \
"${PROG} [a-z]*: scheduling file .dir2/file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  else
	    dotest multiroot3-8 "${testcvs} add dir1/file1 dir2/file2" \
"${PROG} [a-z]*: scheduling file .dir1/file1. for addition
${PROG} [a-z]*: scheduling file .dir2/file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  fi

	  dotest multiroot3-9 "${testcvs} -q ci -m add-them" \
"RCS file: ${TESTDIR}/root2/dir2/file2,v
done
Checking in dir2/file2;
${TESTDIR}/root2/dir2/file2,v  <--  file2
initial revision: 1\.1
done
RCS file: ${TESTDIR}/root1/dir1/file1,v
done
Checking in dir1/file1;
${TESTDIR}/root1/dir1/file1,v  <--  file1
initial revision: 1\.1
done"

	  if test "`cat dir1/CVS/Repository`" = "dir1"; then
	    # RELATIVE_REPOS
	    # That this is an error is good - we are asking CVS to do
	    # something which doesn't make sense.
	    dotest_fail multiroot3-10 \
"${testcvs} -q -d ${CVSROOT1} diff dir1/file1 dir2/file2" \
"${PROG} [a-z]*: failed to create lock directory in repository .${TESTDIR}/root1/dir2': No such file or directory
${PROG} [a-z]*: failed to obtain dir lock in repository .${TESTDIR}/root1/dir2'
${PROG} \[[a-z]* aborted\]: read lock failed - giving up"
	  else
	    # Not RELATIVE_REPOS.
	    if test "$remote" = yes; then
	      # This is good behavior - we are asking CVS to do something
	      # which doesn't make sense.
	      dotest_fail multiroot3-10 \
"${testcvs} -q -d ${CVSROOT1} diff dir1/file1 dir2/file2" \
"protocol error: directory '${TESTDIR}/root2/dir2' not within root '${TESTDIR}/root1'"
	    else
	      # Local isn't as picky as we'd want in terms of getting
	      # the wrong root.
	      dotest multiroot3-10 \
"${testcvs} -q -d ${CVSROOT1} diff dir1/file1 dir2/file2" ""
	    fi
	  fi
	  # This one is supposed to work.
	  dotest multiroot3-11 "${testcvs} -q diff dir1/file1 dir2/file2" ""

	  cd ..

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  rm -r 1
	  rm -rf ${TESTDIR}/root1 ${TESTDIR}/root2
	  unset CVSROOT1
	  unset CVSROOT2
	  ;;

	multiroot4)
	  # More multiroot tests, in particular we have two roots with
	  # similarly-named directories and we try to see that CVS can
	  # keep them separate.
	  if test "x$remote" = xyes; then
	    CVSROOT1=:fork:${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT2=:fork:${TESTDIR}/root2 ; export CVSROOT2
	  else
	    CVSROOT1=${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT2=${TESTDIR}/root2 ; export CVSROOT2
	  fi

	  mkdir 1; cd 1
	  dotest multiroot4-1 "${testcvs} -d ${CVSROOT1} init" ""
	  dotest multiroot4-2 "${testcvs} -d ${CVSROOT1} -q co -l ." ""
	  mkdir dircom
	  dotest multiroot4-3 "${testcvs} add dircom" \
"Directory ${TESTDIR}/root1/dircom added to the repository"
	  cd dircom
	  touch file1
	  dotest multiroot4-4 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest multiroot4-5 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/root1/dircom/file1,v
done
Checking in file1;
${TESTDIR}/root1/dircom/file1,v  <--  file1
initial revision: 1\.1
done"
	  cd ../..
	  mkdir 2; cd 2
	  dotest multiroot4-6 "${testcvs} -d ${CVSROOT2} init" ""
	  dotest multiroot4-7 "${testcvs} -d ${CVSROOT2} -q co -l ." ""
	  mkdir dircom
	  dotest multiroot4-8 "${testcvs} add dircom" \
"Directory ${TESTDIR}/root2/dircom added to the repository"
	  cd dircom
	  touch file2
	  dotest multiroot4-9 "${testcvs} add file2" \
"${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest multiroot4-10 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/root2/dircom/file2,v
done
Checking in file2;
${TESTDIR}/root2/dircom/file2,v  <--  file2
initial revision: 1\.1
done"

	  cd ../..
	  cd 1/dircom
	  # This may look contrived; the real world example which inspired
	  # it was that a user was changing from local to remote.  Cases
	  # like switching servers (among those mounting the same
	  # repository) and so on would also look the same.
	  mkdir sdir2
	  dotest multiroot4-11 "${testcvs} -d ${CVSROOT2} add sdir2" \
"Directory ${TESTDIR}/root2/dircom/sdir2 added to the repository"

	  dotest multiroot4-12 "${testcvs} -q update" ""
	  cd ..
	  dotest multiroot4-13 "${testcvs} -q update dircom" ""
	  cd ..

	  rm -r 1 2
	  rm -rf ${TESTDIR}/root1 ${TESTDIR}/root2
	  unset CVSROOT1
	  unset CVSROOT2
	  ;;

	reposmv)
	  # More tests of repositories and specifying them.
	  # Similar to crerepos but that test is probably getting big
	  # enough.

	  if test "x$remote" = xyes; then
	    CVSROOT1=:fork:${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT_MOVED=:fork:${TESTDIR}/root-moved ; export CVSROOT1
	  else
	    CVSROOT1=${TESTDIR}/root1 ; export CVSROOT1
	    CVSROOT_MOVED=${TESTDIR}/root-moved ; export CVSROOT1
	  fi

	  dotest reposmv-setup-1 "${testcvs} -d ${CVSROOT1} init" ""
	  mkdir imp-dir; cd imp-dir
	  echo file1 >file1
	  dotest reposmv-setup-2 \
"${testcvs} -d ${CVSROOT1} import -m add dir1 vendor release" \
"N dir1/file1

No conflicts created by this import"
	  cd ..

	  mkdir 1; cd 1
	  dotest reposmv-1 "${testcvs} -d ${CVSROOT1} -Q co dir1" ""
	  mv ${TESTDIR}/root1 ${TESTDIR}/root-moved
	  cd dir1

	  # If we didn't have a relative repository, get one now.
	  dotest reposmv-1a "cat CVS/Repository" \
"${TESTDIR}/root1/dir1" "dir1"
	  echo dir1 >CVS/Repository

	  # There were some duplicated warnings and such; only test
	  # for the part of the error message which makes sense.
	  # Bug: "skipping directory " without filename.
	  if test "$remote" = no; then
	    dotest reposmv-2 "${testcvs} update" "${DOTSTAR}
${PROG} update: ignoring CVS/Root because it specifies a non-existent repository ${TESTDIR}/root1
${PROG} update: cannot open directory ${TESTDIR}/cvsroot/dir1: No such file or directory
${PROG} update: skipping directory "
	  else
	    dotest_fail reposmv-2 "${testcvs} update" \
"Cannot access ${TESTDIR}/root1/CVSROOT
No such file or directory"
	  fi

	  # CVS/Root overrides $CVSROOT
	  if test "$remote" = no; then
	    CVSROOT_SAVED=${CVSROOT}
	    CVSROOT=${TESTDIR}/root-moved; export CVSROOT
	    dotest reposmv-3 "${testcvs} update" \
"${DOTSTAR}
${PROG} update: ignoring CVS/Root because it specifies a non-existent repository ${TESTDIR}/root1
${PROG} update: Updating \.
${DOTSTAR}"
	    CVSROOT=${CVSROOT_SAVED}; export CVSROOT
	  else
	    CVSROOT_SAVED=${CVSROOT}
	    CVSROOT=:fork:${TESTDIR}/root-moved; export CVSROOT
	    dotest_fail reposmv-3 "${testcvs} update" \
"Cannot access ${TESTDIR}/root1/CVSROOT
No such file or directory"
	    CVSROOT=${CVSROOT_SAVED}; export CVSROOT
	  fi

	  if test "$remote" = no; then
	    # CVS/Root doesn't seem to quite completely override $CVSROOT
	    # Bug?  Not necessarily a big deal if it only affects error
	    # messages.
	    CVSROOT_SAVED=${CVSROOT}
	    CVSROOT=${TESTDIR}/root-none; export CVSROOT
	    dotest_fail reposmv-4 "${testcvs} update" \
"${PROG} update: in directory \.:
${PROG} update: ignoring CVS/Root because it specifies a non-existent repository ${TESTDIR}/root1
${PROG} \[update aborted\]: ${TESTDIR}/root-none/CVSROOT: No such file or directory"
	    CVSROOT=${CVSROOT_SAVED}; export CVSROOT
	  else
	    CVSROOT_SAVED=${CVSROOT}
	    CVSROOT=:fork:${TESTDIR}/root-none; export CVSROOT
	    dotest_fail reposmv-4 "${testcvs} update" \
"Cannot access ${TESTDIR}/root1/CVSROOT
No such file or directory"
	    CVSROOT=${CVSROOT_SAVED}; export CVSROOT
	  fi

	  # -d overrides CVS/Root
	  # 
	  # Oddly enough, with CVS 1.10 I think this didn't work for
	  # local (that is, it would appear that CVS/Root would not
	  # get used, but would produce an error if it didn't exist).
	  dotest reposmv-5 "${testcvs} -d ${CVSROOT_MOVED} update" \
"${PROG} [a-z]*: Updating \."

	  # TODO: could also test various other things, like what if the
	  # user removes CVS/Root (which is legit).  Or another set of
	  # tests would be if both repositories exist but we want to make
	  # sure that CVS is using the correct one.

	  cd ../..
	  rm -r imp-dir 1
	  rm -rf root1 root2
	  unset CVSROOT1
	  ;;

	pserver)
	  # Test basic pserver functionality.
	  if test "$remote" = yes; then
	    # First set SystemAuth=no.  Not really necessary, I don't
	    # think, but somehow it seems like the clean thing for
	    # the testsuite.
	    mkdir 1; cd 1
	    dotest pserver-1 "${testcvs} -Q co CVSROOT" ""
	    cd CVSROOT
	    echo "SystemAuth=no" >config
	    dotest pserver-2 "${testcvs} -q ci -m config-it" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	    echo "testme:q6WV9d2t848B2:`id -un`" \
	      >${CVSROOT_DIRNAME}/CVSROOT/passwd
	    ${testcvs} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d
END AUTH REQUEST
EOF
	    dotest pserver-3 "cat ${TESTDIR}/pserver.tmp" \
"error 0 Server configuration missing --allow-root in inetd.conf"

	    # Sending the Root and noop before waiting for the
	    # "I LOVE YOU" is bogus, but hopefully we can get
	    # away with it.
	    ${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d
END AUTH REQUEST
Root ${CVSROOT_DIRNAME}
noop
EOF
	    dotest pserver-4 "cat ${TESTDIR}/pserver.tmp" \
"I LOVE YOU${DOTSTAR}ok"

	    ${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d
END AUTH REQUEST
Root ${TESTDIR}/1
noop
EOF
	    dotest pserver-5 "cat ${TESTDIR}/pserver.tmp" \
"I LOVE YOU${DOTSTAR}E Protocol error: Root says \"${TESTDIR}/1\" but pserver says \"${CVSROOT_DIRNAME}\"
error  "

	    ${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d^b?hd
END AUTH REQUEST
EOF
	    dotest pserver-6 "cat ${TESTDIR}/pserver.tmp" \
"I HATE YOU"

	    # Clean up.
	    echo "# comments only" >config
	    dotest pserver-cleanup-1 "${testcvs} -q ci -m config-it" \
"Checking in config;
${TESTDIR}/cvsroot/CVSROOT/config,v  <--  config
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
	    cd ../..
	    rm -r 1
	    rm ${CVSROOT_DIRNAME}/CVSROOT/passwd
	  fi # skip the whole thing for local
	  ;;

	server)
	  # Some tests of the server (independent of the client).
	  if test "$remote" = yes; then
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Directory bogus
mumble/bar
update
EOF
	      dotest server-1 "cat ${TESTDIR}/server.tmp" \
"E Protocol error: Root request missing
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-1
	    fi

	    # Could also test for relative pathnames here (so that crerepos-6a
	    # and crerepos-6b can use :fork:).
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Set OTHER=variable
Set MYENV=env-value
init ${TESTDIR}/crerepos
EOF
	      dotest server-2 "cat ${TESTDIR}/server.tmp" "ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-2
	    fi
	    dotest server-3 "test -d ${TESTDIR}/crerepos/CVSROOT" ""

	    # Now some tests of gzip-file-contents (used by jCVS).
	    awk 'BEGIN {
printf "%c%c%c%c%c%c.6%c%c+I-.%c%c%c%c5%c;%c%c%c%c", 
31, 139, 8, 64, 5, 7, 64, 3, 225, 2, 64, 198, 185, 5, 64, 64, 64}' \
	      </dev/null | tr '\100' '\000' >gzipped.dat
	    echo Root ${TESTDIR}/crerepos >session.dat
	    # Note that the CVS client sends "-b 1.1.1", and this
	    # test doesn't.  But the server also defaults to that.
	    cat <<EOF >>session.dat
UseUnchanged
gzip-file-contents 3
Argument -m
Argument msg
Argumentx 
Argument dir1
Argument tag1
Argument tag2
Directory .
in-real-life-this-is-funky-but-server-seems-to-ignore-it
Modified file1
u=rw,g=r,o=r
z25
EOF
	    cat gzipped.dat >>session.dat
	    echo import >>session.dat
	    if ${testcvs} server >${TESTDIR}/server.tmp <session.dat; then
	      dotest server-4 "cat ${TESTDIR}/server.tmp" "M N dir1/file1
M 
M No conflicts created by this import
M 
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-4
	    fi
	    dotest server-5 \
"${testcvs} -q -d ${TESTDIR}/crerepos co -p dir1/file1" "test"

	    if test "$keep" = yes; then
	      echo Keeping ${TESTDIR} and exiting due to --keep
	      exit 0
	    fi

	    rm -rf ${TESTDIR}/crerepos
	    rm gzipped.dat session.dat
	    rm ${TESTDIR}/server.tmp
	  fi # skip the whole thing for local
	  ;;

	client)
	  # Some tests of the client (independent of the server).
	  if test "$remote" = yes; then
	    cat >${TESTDIR}/serveme <<EOF
#!${TESTSHELL}
# This is admittedly a bit cheezy, in the sense that we make lots
# of assumptions about what the client is going to send us.
# We don't mention Repository, because current clients don't require it.
# Sending these at our own pace, rather than waiting for the client to
# make the requests, is bogus, but hopefully we can get away with it.
echo "Valid-requests Root Valid-responses valid-requests Directory Entry Modified Unchanged Argument Argumentx ci co update"
echo "ok"
echo "M special message"
echo "Created first-dir/"
echo "${TESTDIR}/cvsroot/first-dir/file1"
echo "/file1/1.1///"
echo "u=rw,g=rw,o=rw"
echo "4"
echo "xyz"
echo "ok"
cat >/dev/null
EOF
	    chmod +x ${TESTDIR}/serveme
	    CVS_SERVER=${TESTDIR}/serveme; export CVS_SERVER
	    mkdir 1; cd 1
	    dotest_fail client-1 "${testcvs} -q co first-dir" \
"${PROG} \[checkout aborted\]: This server does not support the global -q option\."
	    dotest client-2 "${testcvs} co first-dir" "special message"

	    cat >${TESTDIR}/serveme <<EOF
#!${TESTSHELL}
echo "Valid-requests Root Valid-responses valid-requests Directory Entry Modified Unchanged Argument Argumentx ci co update"
echo "ok"
echo "M merge-it"
echo "Copy-file ./"
echo "${TESTDIR}/cvsroot/first-dir/file1"
echo "${TESTDIR}/bogus/.#file1.1.1"
echo "Merged ./"
echo "${TESTDIR}/cvsroot/first-dir/file1"
echo "/file1/1.2///"
echo "u=rw,g=rw,o=rw"
echo "4"
echo "abd"
echo "ok"
cat >/dev/null
EOF
	    cd first-dir
	    mkdir ${TESTDIR}/bogus
	    dotest_fail client-3 "${testcvs} update" "merge-it
${PROG} \[update aborted\]: protocol error: Copy-file tried to specify directory"
	    cat >${TESTDIR}/serveme <<EOF
#!${TESTSHELL}
echo "Valid-requests Root Valid-responses valid-requests Directory Entry Modified Unchanged Argument Argumentx ci co update"
echo "ok"
echo "M merge-it"
echo "Copy-file ./"
echo "${TESTDIR}/cvsroot/first-dir/file1"
echo ".#file1.1.1"
echo "Merged ./"
echo "${TESTDIR}/cvsroot/first-dir/file1"
echo "/file1/1.2///"
echo "u=rw,g=rw,o=rw"
echo "4"
echo "abc"
echo "ok"
cat >/dev/null
EOF
	    dotest client-4 "${testcvs} update" "merge-it"
	    dotest client-5 "cat .#file1.1.1" "xyz"
	    dotest client-6 "cat CVS/Entries" "/file1/1.2/[A-Za-z0-9 :]*//
D"
	    dotest client-7 "cat file1" "abc"

	    cat >${TESTDIR}/serveme <<EOF
#!${TESTSHELL}
echo "Valid-requests Root Valid-responses valid-requests Directory Entry Modified Unchanged Argument Argumentx ci co update"
echo "ok"
echo "M OK, whatever"
echo "ok"
cat >${TESTDIR}/client.tmp
EOF
	    chmod u=rw,go= file1
	    # By specifying the time zone in local time, we don't
	    # know exactly how that will translate to GMT.
	    dotest client-8 "${testcvs} update -D 99-10-04" "OK, whatever"
	    dotest client-9 "cat ${TESTDIR}/client.tmp" \
"Root ${TESTDIR}/cvsroot
Valid-responses [-a-zA-Z ]*
valid-requests
Argument -D
Argument [34] Oct 1999 [0-9][0-9]:00:00 -0000
Directory \.
${TESTDIR}/cvsroot/first-dir
Entry /file1/1\.2///
Modified file1
u=rw,g=,o=
4
abc
update"

	    cd ../..
	    rm -r 1
	    rmdir ${TESTDIR}/bogus
	    rm ${TESTDIR}/serveme
	    CVS_SERVER=${testcvs}; export CVS_SERVER
	  fi # skip the whole thing for local
	  ;;

a15537 7
# * Test the following compatibility issues:
#   - The filler fields in "D" entries in CVS/Entries get preserved
#     (per cvs.texinfo).
#   - Unrecognized entry types in CVS/Entries get ignored (looks like
#     this needs to be documented in cvs.texinfo, but is not)
#   - Test that unrecognized files in CVS directories (e.g. CVS/Foobar)
#     are ignored (per cvs.texinfo).
@


1.1.1.16
log
@Latest version from Cyclic
@
text
@a99 4
"")
  echo "Usage: `basename $0` [-r] [--keep] CVS-TO-TEST [TESTS-TO-RUN...]" 1>&2
  exit 1
  ;;
d101 2
a102 2
  testcvs=$1
  ;;
d104 2
a105 2
  testcvs=`pwd`/$1
  ;;
d284 7
a290 12
      if test x"$4" != x; then
	# We want to match either the empty string or $4.
	dotest_internal "$1" "$2" "$4"
      else
	echo "** expected: " >>${LOGFILE}
	echo "$3" >>${LOGFILE}
	echo "$3" > ${TESTDIR}/dotest.exp
	rm -f ${TESTDIR}/dotest.ex2
	echo "** got: " >>${LOGFILE}
	cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
	fail "$1"
      fi
d560 1
a560 2
	tests="basica basicb basicc basic1 deep basic2"
	tests="${tests} files spacefiles commit-readonly"
d563 1
a563 1
	tests="${tests} branches branches2 tagc tagf"
d575 1
a575 1
	tests="${tests} devcom devcom2 devcom3 watch4 watch5"
d583 1
a583 1
	tests="${tests} crerepos rcs rcs2 rcs3 lockfiles backuprecover"
d588 1
a588 1
	tests="${tests} perms symlinks symlinks2 hardlinks"
d590 1
a590 1
	tests="${tests} sticky keyword keyword2 keywordlog"
d600 1
a600 1
	tests="${tests} rmroot reposmv pserver server server2 client"
a1176 3
	  # The Linux 2.2 kernel lets you delete ".".  That's OK either way,
	  # the point is that CVS must not mess with anything *outside* "."
	  # the way that CVS 1.10 and older tried to.
d1178 1
a1178 1
"" "${PROG} release: deletion of directory \. failed: .*"
d1180 1
a1181 7
	  # On Linux 2.2 systems, the cwd may be gone, so we recreate it
          # to allow basicc-11 to actually happen 
	  if ! test -d ../first-dir; then
	    cd ..
	    mkdir ./first-dir
            cd ./first-dir
	  fi
d1183 1
a1183 3
"" "${PROG} release: deletion of directory \./\. failed: .*"
	  dotest basicc-11a "test -d ../second-dir" ""

a2175 14

	    # Sync up the version numbers so that the rest of the
	    # tests don't need to expect different numbers based
	    # local or remote.
	    dotest files-12-workaround \
"${testcvs} commit -f -m test sdir/ssdir/.file .file" \
"Checking in sdir/ssdir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.3; previous revision: 1\.1\.2\.2
done
Checking in \.file;
${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.3; previous revision: 1\.1\.2\.2
done"
a2187 18
	  dotest files-13 \
"${testcvs} commit -fmtest ./sdir/../sdir/ssdir/..///ssdir/.file" \
"Checking in \./sdir/\.\./sdir/ssdir/\.\.///ssdir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.4; previous revision: 1\.1\.2\.3
done"
	  if test "$remote" = yes; then
	    dotest_fail files-14 \
"${testcvs} commit -fmtest ../../first-dir/dir/.file" \
"protocol error: .\.\./\.\./first-dir/dir' has too many \.\."
	  else
	    dotest files-14 \
"${testcvs} commit -fmtest ../../first-dir/dir/.file" \
"Checking in \.\./\.\./first-dir/dir/\.file;
${TESTDIR}/cvsroot/first-dir/dir/Attic/\.file,v  <--  \.file
new revision: 1\.1\.2\.4; previous revision: 1\.1\.2\.3
done"
	  fi
d2191 1
a2191 103
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	spacefiles)
	  # More filename tests, in particular spaces in file names.
	  # If we start using eval in dotest, this test should become
	  # easier to write (in fact, it may be possible to just
	  # change a few of the names in basica or some other test,
	  # always good to keep the testsuite concise).

	  # I wrote this test to worry about problems in do_module;
	  # but then I found that the CVS server has its own problems
	  # with filenames starting with "-".  Work around it for now.
	  if test "$remote" = yes; then
	    dashb=dashb
	    dashc=dashc
	  else
	    dashb=-b
	    dashc=-c
	  fi

	  mkdir 1; cd 1
	  dotest spacefiles-1 "${testcvs} -q co -l ." ""
	  touch ./${dashc} top
	  dotest spacefiles-2 "${testcvs} add -- ${dashc} top" \
"${PROG} [a-z]*: scheduling file .${dashc}. for addition
${PROG} [a-z]*: scheduling file .top. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest spacefiles-3 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/${dashc},v
done
Checking in ${dashc};
${TESTDIR}/cvsroot/${dashc},v  <--  ${dashc}
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/top,v
done
Checking in top;
${TESTDIR}/cvsroot/top,v  <--  top
initial revision: 1\.1
done"
	  mkdir 'first dir'
	  if ${testcvs} add 'first dir' >${TESTDIR}/output.tmp 2>&1; then
	    dotest spacefiles-4 "cat ${TESTDIR}/output.tmp" \
"Directory ${TESTDIR}/cvsroot/first dir added to the repository"
	  else
	    fail spacefiles-4
	  fi
	  mkdir ./${dashb}
	  dotest spacefiles-5 "${testcvs} add -- ${dashb}" \
"Directory ${TESTDIR}/cvsroot/${dashb} added to the repository"
	  cd 'first dir'
	  touch 'a file'
	  if ${testcvs} add 'a file' >${TESTDIR}/output.tmp 2>&1; then
	    dotest spacefiles-6 "cat ${TESTDIR}/output.tmp" \
"${PROG} [a-z]*: scheduling file .a file. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  else
	    fail spacefiles-6
	  fi
	  dotest spacefiles-7 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first dir/a file,v
done
Checking in a file;
${TESTDIR}/cvsroot/first dir/a file,v  <--  a file
initial revision: 1\.1
done"
	  dotest spacefiles-8 "${testcvs} -q tag new-tag" "T a file"
	  cd ../..

	  mkdir 2; cd 2
	  # Leading slash strikes me as kind of oddball, but there is
	  # a special case for it in do_module.  And (in the case of
	  # "top", rather than "-c") it has worked in CVS 1.10.6 and
	  # presumably back to CVS 1.3 or so.
	  dotest spacefiles-9 "${testcvs} -q co -- /top" "U \./top"
	  dotest spacefiles-10 "${testcvs} co -- ${dashb}" \
"${PROG} [a-z]*: Updating ${dashb}"
	  dotest spacefiles-11 "${testcvs} -q co -- ${dashc}" "U \./${dashc}"
	  rm ./${dashc}
	  dotest spacefiles-12 "${testcvs} -q co -- /${dashc}" "U \./${dashc}"
	  if ${testcvs} -q co 'first dir' >${TESTDIR}/output.tmp 2>&1; then
	    dotest spacefiles-13 "cat ${TESTDIR}/output.tmp" \
"U first dir/a file"
	  else
	    fail spacefiles-13
	  fi
	  cd ..

	  mkdir 3; cd 3
	  if ${testcvs} -q co 'first dir/a file' >${TESTDIR}/output.tmp 2>&1
	  then
	    dotest spacefiles-14 "cat ${TESTDIR}/output.tmp" \
"U first dir/a file"
	  else
	    fail spacefiles-14
	  fi
	  cd ..

	  rm -r 1 2 3
	  rm -rf "${CVSROOT_DIRNAME}/first dir"
	  rm -r ${CVSROOT_DIRNAME}/${dashb}
	  rm -f ${CVSROOT_DIRNAME}/${dashc},v ${CVSROOT_DIRNAME}/top,v
a2359 35
	  touch abc
	  dotest diff-4 "${testcvs} add abc" \
"${PROG} [a-z]*: scheduling file .abc. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest diff-5 "${testcvs} -q ci -mtest" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/abc,v
done
Checking in abc;
${TESTDIR}/cvsroot/first-dir/abc,v  <--  abc
initial revision: 1\.1
done"
	  echo "extern int gethostname ();" >abc
	  dotest diff-6 "${testcvs} -q ci -mtest" \
"Checking in abc;
${TESTDIR}/cvsroot/first-dir/abc,v  <--  abc
new revision: 1\.2; previous revision: 1\.1
done"
	  echo "#include <winsock.h>" >abc
	  # check the behavior of the --ifdef=MACRO option
	  dotest_fail diff-7 "${testcvs} -q diff --ifdef=HAVE_WINSOCK_H" \
"Index: abc
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/abc,v
retrieving revision 1\.2
diff --ifdef=HAVE_WINSOCK_H -r1\.2 abc
#ifndef HAVE_WINSOCK_H
extern int gethostname ();
#else /\* HAVE_WINSOCK_H \*/
#include <winsock\.h>
#endif /\* HAVE_WINSOCK_H \*/"

	  if test "$keep" = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi
a3266 1
	  dotest rmadd2-4a "${testcvs} -Q tag tagone" ""
a3308 22
	  dotest rmadd2-16 "${testcvs} log -h file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/Attic/file1,v
Working file: file1
head: 1\.6
branch:
locks: strict
access list:
symbolic names:
	tagone: 1\.1
keyword substitution: kv
total revisions: 6
============================================================================="
	  dotest rmadd2-17 "${testcvs} status -v file1" \
"===================================================================
File: no file file1		Status: Up-to-date

   Working revision:	No entry for file1
   Repository revision:	1\.6	${TESTDIR}/cvsroot/first-dir/Attic/file1,v

   Existing Tags:
	tagone                   	(revision: 1.1)"

d3488 1
a3488 1
${PROG} \[update aborted\]: there is no version here; do '${PROG} checkout' first"
a3587 4
	  # Modify this file before branching, to deal with the case where
	  # someone is hacking along, says "oops, I should be doing this on
	  # a branch", and only then creates the branch.
	  echo 1:br1 >file1
d3594 2
a3595 2
"${PROG} [a-z]*: Updating \.
M file1"
a4079 114
	tagf)
	  # More tagging tests, including using tag -F to convert a
	  # branch tag to a regular tag and recovering thereof.

	  # Setup; check in first-dir/file1
	  mkdir 1; cd 1
	  dotest tagf-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest tagf-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  touch file1 file2
	  dotest tagf-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest tagf-4 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"

	  # Now create a branch and commit a revision there.
	  dotest tagf-5 "${testcvs} -q tag -b br" "T file1
T file2"
	  dotest tagf-6 "${testcvs} -q update -r br" ""
	  echo brmod >> file1
	  echo brmod >> file2
	  dotest tagf-7 "${testcvs} -q ci -m modify" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  # Here we make it a non-branch tag.  Some think this should
	  # be an error.  But if -F means "I want to put this tag here,
	  # never mind whether there was a tag of that name before", then
	  # an error wouldn't fit.
	  dotest tagf-8 "${testcvs} -q tag -F br" "T file1
T file2"
	  echo moremod >> file1
	  echo moremod >> file2
	  dotest tagf-9 "${testcvs} -q status -v file1" \
"===================================================================
File: file1            	Status: Locally Modified

   Working revision:	1\.1\.2\.1.*
   Repository revision:	1\.1\.2\.1	${TESTDIR}/cvsroot/first-dir/file1,v
   Sticky Tag:		br (revision: 1\.1\.2\.1)
   Sticky Date:		(none)
   Sticky Options:	(none)

   Existing Tags:
	br                       	(revision: 1\.1\.2\.1)"

	  # Now, how do we recover?
	  dotest tagf-10 "${testcvs} -q tag -d br" "D file1
D file2"
	  # This creates a new branch, 1.1.4.  See the code in RCS_magicrev
	  # which will notice that there is a (non-magic) 1.1.2 and thus
	  # skip that number.
	  dotest tagf-11 "${testcvs} -q tag -r 1.1 -b br file1" "T file1"
	  # Fix it with admin -n (cf admin-18, admin-26-4).
	  dotest tagf-12 "${testcvs} -q admin -nbr:1.1.2 file2" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done"
	  # Another variation on the file2 test would be to use two working
	  # directories so that the update -r br would need to
	  # a merge to get from 1.1.2.1 to the head of the 1.1.2 branch.
	  dotest tagf-13 "${testcvs} -q update -r br" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1\.2\.1
retrieving revision 1\.1
Merging differences between 1\.1\.2\.1 and 1\.1 into file1
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in file1
C file1
M file2"
	  # CVS is giving a conflict because we are trying to get back to
	  # 1.1.4.  I'm not sure why it is a conflict rather than just
	  # "M file1".
	  dotest tagf-14 "cat file1" \
"<<<<<<< file1
brmod
moremod
[=]======
[>]>>>>>> 1\.1"
	  echo resolve >file1
	  dotest tagf-15 "${testcvs} -q ci -m recovered" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.1; previous revision: 1\.1
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
new revision: 1\.1\.2\.2; previous revision: 1\.1\.2\.1
done"
	  cd ../..

	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d4817 1
a4817 1
${PROG} \[[a-z]* aborted\]: there is no version here; do .${PROG} checkout. first"
a4890 9
	  # Now tests of absolute pathnames and .. as repository directory.
	  cd ../1
	  dotest_fail importc-10 \
"${testcvs} import -m imp ../other vendor release2" \
"${PROG} \[[a-z]* aborted\]: directory \.\./other not relative within the repository"
	  dotest_fail importc-11 \
"${testcvs} import -m imp ${TESTDIR}/other vendor release3" \
"${PROG} \[[a-z]* aborted\]: directory ${TESTDIR}/other not relative within the repository"
	  dotest_fail importc-12 "test -d ${TESTDIR}/other" ""
a4891 1

d6135 1
a6135 1
${PROG} \[add aborted\]: there is no version here; do '${PROG} checkout' first"
d7140 1
a7140 1
"absolute pathname .${TESTDIR}/1/src/sub1/sub2/sub3/dir. illegal for server"
a9731 4
	  dotest errmsg2-18 "${testcvs} -Q tag test" ''

	  dotest_fail errmsg2-19 "${testcvs} annotate -rtest -Dyesterday" \
"${PROG} \[[a-z]* aborted\]: rcsbuf_open: internal error"
a10080 25
	  # Now test disconnected "cvs edit" and the format of the 
	  # CVS/Notify file.
	  if test "$remote" = yes; then
	    CVS_SERVER_SAVED=${CVS_SERVER}
	    CVS_SERVER=${TESTDIR}/cvs-none; export CVS_SERVER

	    # The ${DOTSTAR} matches the exact exec error message
	    # (which varies) and either "end of file from server"
	    # (if the process doing the exec exits before the parent
	    # gets around to sending data to it) or "broken pipe" (if it
	    # is the other way around).
	    dotest_fail devcom3-9a "${testcvs} edit w1" \
"${PROG} \[edit aborted\]: cannot exec ${TESTDIR}/cvs-none: ${DOTSTAR}"
	    dotest devcom3-9b "test -w w1" ""
	    dotest devcom3-9c "cat CVS/Notify" \
"Ew1	[SMTWF][uoehra][neduit] [JFAMSOND][aepuco][nbrylgptvc] [0-9 ][0-9] [0-9:]* [0-9][0-9][0-9][0-9] GMT	[-a-zA-Z_.0-9]*	${TESTDIR}/1/first-dir	EUC"
	    CVS_SERVER=${CVS_SERVER_SAVED}; export CVS_SERVER
	    dotest devcom3-9d "${testcvs} -q update" ""
	    dotest_fail devcom3-9e "test -f CVS/Notify" ""
	    dotest devcom3-9f "${testcvs} watchers w1" \
"w1	${username}	tedit	tunedit	tcommit"
	    dotest devcom3-9g "${testcvs} unedit w1" ""
	    dotest devcom3-9h "${testcvs} watchers w1" ""
	  fi

a10189 65
	watch5)
	  # This test was designed to catch a problem in server
	  # mode where an 'cvs edit'd file disappeared from the
	  # CVS/Base directory when 'cvs status' or 'cvs update'
	  # was called on the file after the file was touched.
	  #
	  # This test is still here to prevent the bug from
	  # being reintroduced.
	  #
	  # The rationale for having CVS/Base stay around is that
	  # CVS/Base should be there if "cvs edit" has been run (this
	  # may be helpful as a "cvs editors" analogue, it is
	  # client-side and based on working directory not username;
	  # but more importantly, it isn't clear why a "cvs status"
	  # would act like an unedit, and even if it does, it would
	  # need to make the file read-only again).

	  mkdir watch5; cd watch5
	  dotest watch5-0a "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest watch5-0b "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"

	  cd first-dir
	  dotest watch5-1 "${testcvs} watch on" ''
	  # This is just like the 173 test
	  touch file1
	  dotest watch5-2 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest watch5-3 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest watch5-4 "${testcvs} edit file1" ''
	  dotest watch5-5 "test -f CVS/Base/file1" ''
	  if ${testcvs} status file1 >>${LOGFILE} 2>&1; then
		pass watch5-6
	  else
		fail watch5-6
	  fi
	  dotest watch5-7 "test -f CVS/Base/file1" ''

	  # Here's where the file used to dissappear
	  touch file1
	  if ${testcvs} status file1 >>${LOGFILE} 2>&1; then
		pass watch5-8
	  else
		fail watch5-8
	  fi
	  dotest watch5-10 "test -f CVS/Base/file1" ''

	  # Make sure update won't remove the file either
	  touch file1
	  dotest watch5-11 "${testcvs} -q up" ''
	  dotest watch5-12 "test -f CVS/Base/file1" ''

	  cd ../..
	  rm -r watch5
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d10915 1
a10915 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a13297 6
	  # 
	  # Hmm, if this test is run on the 31st of the month, and 100
	  # months from now is a month with only 30 days (e.g. run on
	  # 31 May 1999), it seems to fail.
	  # 
	  # Sigh.
d13463 4
a13466 68
	backuprecover)
	  # Tests to make sure we get the expected behavior
	  # when we recover a repository from an old backup
	  #
	  # Details:
	  #   Backup will be older than some developer's workspaces
	  #	This means the first attempt at an update will fail
	  #	The workaround for this is to replace the CVS
	  #	  directories with those from a "new" checkout from
	  #	  the recovered repository.  Due to this, multiple
	  #	  merges should cause conflicts (the same data
	  #	  will be merged more than once).
	  #	A workspace updated before the date of the recovered
	  #	  copy will not need any extra attention
	  #
	  # Note that backuprecover-15 is probably a failure case
	  #   If nobody else had a more recent update, the data would be lost
	  #	permanently
	  #   Granted, the developer should have been notified not to do this
	  #	by now, but still...
	  #
	  mkdir backuprecover; cd backuprecover
	  mkdir 1; cd 1
	  dotest backuprecover-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest backuprecover-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  mkdir dir
	  dotest backuprecover-3 "${testcvs} add dir" \
"Directory ${TESTDIR}/cvsroot/first-dir/dir added to the repository"
	  touch file1 dir/file2
	  dotest backuprecover-4 "${testcvs} -q add file1 dir/file2" \
"${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"
	  dotest backuprecover-5 "${testcvs} -q ci -mtest" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/dir/file2,v
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  echo "Line one" >>file1
	  echo "  is the place" >>file1
	  echo "    we like to begin" >>file1
	  echo "Anything else" >>file1
	  echo "  looks like" >>file1
	  echo "    a sin" >>file1
	  echo "File 2" >>dir/file2
	  echo "  is the place" >>dir/file2
	  echo "    the rest of it goes"  >>dir/file2
	  echo "Why I don't use" >>dir/file2
	  echo "  something like 'foo'" >>dir/file2
	  echo "    God only knows" >>dir/file2
	  dotest backuprecover-6 "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.2; previous revision: 1\.1
done"
d13468 20
a13487 247
	  # Simulate the lazy developer
	  # (he did some work but didn't check it in...)
	  cd ../..
	  mkdir 2; cd 2
	  dotest backuprecover-7 "${testcvs} -Q co first-dir" ''
	  cd first-dir
	  sed -e"s/looks like/just looks like/" file1 >tmp; mv tmp file1
	  sed -e"s/don't use/don't just use/" dir/file2 >tmp; mv tmp dir/file2

	  # developer 1 is on a roll
	  cd ../../1/first-dir
	  echo "I need some more words" >>file1
	  echo "  to fill up this space" >>file1
	  echo "    anything else would be a disgrace" >>file1
	  echo "My rhymes cross many boundries" >>dir/file2
	  echo "  this time it's files" >>dir/file2
	  echo "    a word that fits here would be something like dials" >>dir/file2
	  dotest backuprecover-8 "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.3; previous revision: 1\.2
done"

	  # Save a backup copy
	  cp -r ${TESTDIR}/cvsroot/first-dir ${TESTDIR}/cvsroot/backup

	  # Simulate developer 3
	  cd ../..
	  mkdir 3; cd 3
	  dotest backuprecover-9a "${testcvs} -Q co first-dir" ''
	  cd first-dir
	  echo >>file1
	  echo >>dir/file2
	  echo "Developer 1 makes very lame rhymes" >>file1
	  echo "  I think he should quit and become a mime" >>file1
	  echo "What the %*^# kind of rhyme crosses a boundry?" >>dir/file2
	  echo "  I think you should quit and get a job in the foundry" >>dir/file2
	  dotest backuprecover-9b "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.4; previous revision: 1\.3
done"

	  # Developer 4 so we can simulate a conflict later...
	  cd ../..
	  mkdir 4; cd 4
	  dotest backuprecover-10 "${testcvs} -Q co first-dir" ''
	  cd first-dir
	  sed -e"s/quit and/be fired so he can/" dir/file2 >tmp; mv tmp dir/file2

	  # And back to developer 1
	  cd ../../1/first-dir
	  dotest backuprecover-11 "${testcvs} -Q update" ''
	  echo >>file1
	  echo >>dir/file2
	  echo "Oh yeah, well rhyme this" >>file1
	  echo "  developer three" >>file1
	  echo "    you want opposition" >>file1
	  echo "      you found some in me!" >>file1
	  echo "I'll give you mimes" >>dir/file2
	  echo "  and foundries galore!"  >>dir/file2
	  echo "    your head will spin" >>dir/file2
	  echo "      once you find what's in store!" >>dir/file2
	  dotest backuprecover-12 "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.5; previous revision: 1\.4
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.5; previous revision: 1\.4
done"

	  # developer 3'll do a bit of work that never gets checked in
	  cd ../../3/first-dir
	  dotest backuprecover-13 "${testcvs} -Q update" ''
	  sed -e"s/very/some extremely/" file1 >tmp; mv tmp file1
	  dotest backuprecover-14 "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.6; previous revision: 1\.5
done"
	  echo >>file1
	  echo "Tee hee hee hee" >>file1
	  echo >>dir/file2
	  echo "Find what's in store?" >>dir/file2
	  echo "  Oh, I'm so sure!" >>dir/file2
	  echo "    You've got an ill, and I have the cure!"  >>dir/file2

	  # Slag the original and restore it a few revisions back
	  rm -rf ${TESTDIR}/cvsroot/first-dir
	  mv ${TESTDIR}/cvsroot/backup ${TESTDIR}/cvsroot/first-dir

	  # Have developer 1 try an update and lose some data
	  #
	  # Feel free to imagine the horrific scream of despair
	  cd ../../1/first-dir
	  dotest backuprecover-15 "${testcvs} update" \
"${PROG} [a-z]*: Updating .
U file1
${PROG} [a-z]*: Updating dir
U dir/file2"

	  # Developer 3 tries the same thing (he has an office)
	  # but fails without losing data since all of his files have
	  # uncommitted changes
	  cd ../../3/first-dir
	  dotest_fail backuprecover-16 "${testcvs} update" \
"${PROG} [a-z]*: Updating \.
${PROG} \[[a-z]* aborted\]: could not find desired version 1\.6 in ${TESTDIR}/cvsroot/first-dir/file1,v"

	  # create our workspace fixin' script
	  cd ../..
	  echo \
"#!/bin/sh

# This script will copy the CVS database dirs from the checked out
# version of a newly recovered repository and replace the CVS
# database dirs in a workspace with later revisions than those in the
# recovered repository
cd repos-first-dir
DATADIRS=\`find . -name CVS\`
cd ../first-dir
find . -name CVS |xargs rm -rf
for file in \${DATADIRS}; do
	cp -r ../repos-first-dir/\${file} \${file}
done" >fixit

	  # We only need to fix the workspaces of developers 3 and 4
	  # (1 lost all her data and 2 has an update date from
	  # before the date the backup was made)
	  cd 3
	  dotest backuprecover-17 \
		"${testcvs} -Q co -d repos-first-dir first-dir" ''
	  cd ../4
	  dotest backuprecover-18 \
		"${testcvs} -Q co -d repos-first-dir first-dir" ''
	  sh ../fixit
	  cd ../3; sh ../fixit

	  # (re)commit developer 3's stuff
	  cd first-dir
	  dotest backuprecover-19 "${testcvs} -q ci -mrecover/merge" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.4; previous revision: 1\.3
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.4; previous revision: 1\.3
done"

	  # and we should get a conflict on developer 4's stuff
	  cd ../../4/first-dir
	  dotest backuprecover-20 "${testcvs} update" \
"${PROG} [a-z]*: Updating \.
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.3
retrieving revision 1\.4
Merging differences between 1\.3 and 1\.4 into file1
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in file1
C file1
${PROG} [a-z]*: Updating dir
RCS file: ${TESTDIR}/cvsroot/first-dir/dir/file2,v
retrieving revision 1\.3
retrieving revision 1\.4
Merging differences between 1\.3 and 1\.4 into file2
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in dir/file2
C dir/file2"
	  sed -e \
"/^<<<<<<</,/^=======/d
/^>>>>>>>/d" file1 >tmp; mv tmp file1
	  sed -e \
"/^<<<<<<</,/^=======/d
/^>>>>>>>/d
s/quit and/be fired so he can/" dir/file2 >tmp; mv tmp dir/file2
	  dotest backuprecover-21 "${testcvs} -q ci -mrecover/merge" \
"Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.5; previous revision: 1\.4
done"

	  # go back and commit developer 2's stuff to prove it can still be done
	  cd ../../2/first-dir
	  dotest backuprecover-22 "${testcvs} -Q update" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.2
retrieving revision 1\.4
Merging differences between 1\.2 and 1\.4 into file1
RCS file: ${TESTDIR}/cvsroot/first-dir/dir/file2,v
retrieving revision 1\.2
retrieving revision 1\.5
Merging differences between 1\.2 and 1\.5 into file2"
	  dotest backuprecover-23 "${testcvs} -q ci -mtest" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.5; previous revision: 1\.4
done
Checking in dir/file2;
${TESTDIR}/cvsroot/first-dir/dir/file2,v  <--  file2
new revision: 1\.6; previous revision: 1\.5
done"

	  # and restore the data to developer 1
	  cd ../../1/first-dir
	  dotest backuprecover-24 "${testcvs} -Q update" ''

	  cd ../../..
	  rm -r backuprecover
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	history)
	  # CVSROOT/history tests:
	  # history: various "cvs history" invocations
	  # basic2: Generating the CVSROOT/history file via CVS commands.

	  # Put in some data for the history file (discarding what was
	  # there before).  Note that this file format is fixed; the
	  # user may wish to analyze data from a previous version of
	  # CVS.  If we phase out this format, it should be done
	  # slowly and carefully.
	  cat >${CVSROOT_DIRNAME}/CVSROOT/history <<EOF
O3395c677|anonymous|<remote>/*0|ccvs||ccvs
M339cafae|nk|<remote>|ccvs/src|1.229|sanity.sh
M339dc339|kingdon|~/work/*0|ccvs/src|1.231|sanity.sh
W33a6eada|anonymous|<remote>*4|ccvs/emx||Makefile.in
C3b235f50|kingdon|<remote>|ccvs/emx|1.3|README
M3b23af50|kingdon|~/work/*0|ccvs/doc|1.281|cvs.texinfo
EOF
	  dotest history-1 "${testcvs} history -e -a" \
"O 06/04 19:48 ${PLUS}0000 anonymous ccvs     =ccvs= <remote>/\*
W 06/17 19:51 ${PLUS}0000 anonymous       Makefile\.in ccvs/emx == <remote>/emx
M 06/10 21:12 ${PLUS}0000 kingdon   1\.231 sanity\.sh   ccvs/src == ~/work/ccvs/src
C 06/10 11:51 ${PLUS}0000 kingdon   1\.3   README      ccvs/emx == <remote>
M 06/10 17:33 ${PLUS}0000 kingdon   1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc
M 06/10 01:36 ${PLUS}0000 nk        1\.229 sanity\.sh   ccvs/src == <remote>"
a14036 39
	symlinks2)
	  # Symlinks in working directory without PreservePermissions.
	  # Also see: symlinks: with PreservePermissions
	  # rcslib-symlink-*: symlinks in repository.
	  mkdir 1; cd 1
	  dotest symlinks2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest symlinks2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo nonsymlink > slink
	  dotest symlinks2-3 "${testcvs} add slink" \
"${PROG} [a-z]*: scheduling file .slink. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest symlinks2-4 "${testcvs} -q ci -m ''" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/slink,v
done
Checking in slink;
${TESTDIR}/cvsroot/first-dir/slink,v  <--  slink
initial revision: 1\.1
done"
	  rm slink
	  # Choose name cvslog.* so it is in default ignore list.
	  echo second file >cvslog.file2
	  dotest symlinks2-5 "ln -s cvslog.file2 slink" ""
	  dotest symlinks2-6 "${testcvs} -q ci -m linkify" \
"Checking in slink;
${TESTDIR}/cvsroot/first-dir/slink,v  <--  slink
new revision: 1\.2; previous revision: 1\.1
done"
	  dotest symlinks2-7 "${testcvs} -q update -r 1.1 slink" "[UP] slink"
	  dotest symlinks2-8 "cat slink" "nonsymlink"
	  dotest symlinks2-9 "ls -l slink" "-[-rwx]* .* slink"
	  cd ../..

	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a14243 1
	  # "keyword2" tests "cvs update -kk -j" with text and binary files
d14425 4
a14428 1
	  dotest keyword-22 "cat file1" '\$'"Name: tag1 "'\$'
d14430 1
a14430 12
	  if test "$remote" = yes; then
	    # Like serverpatch-8.  Not sure there is anything much we
	    # can or should do about this.
	    dotest keyword-23 "${testcvs} update -A file1" "P file1
${PROG} update: checksum failure after patch to \./file1; will refetch
${PROG} client: refetching unpatchable files
U file1"
	  else
	    dotest keyword-23 "${testcvs} update -A file1" "[UP] file1"
	  fi
	  dotest keyword-24 "cat file1" '\$'"Name:  "'\$'"
change"
a14628 25
	  #
	  # test the operation of 'admin -o' in conjunction with keywords
	  # (especially Log - this used to munge the RCS file for all time)
	  #

	  dotest keywordlog-24 \
"${testcvs} admin -oHEAD 1/first-dir/file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
deleting revision 1\.5
done"

	  dotest keywordlog-25 \
"${testcvs} -q co -p first-dir/file1" \
"initial
xx "'\$'"Log: file1,v "'\$'"
xx Revision 1\.4  [0-9/]* [0-9:]*  ${username}
xx First log line
xx Second log line
xx"

	  if test $keep = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

a14632 164
	keyword2)
	  # Test merging on files with keywords:
	  #   without -kk
	  #   with -kk
	  #     on text files
	  #     on binary files
	  # Note:  This test assumes that CVS has already passed the binfiles
	  #    test sequence
	  # Note2:  We are testing positive on binary corruption here
	  #    we probably really DON'T want to 'cvs update -kk' a binary file...
	  mkdir 1; cd 1
	  dotest keyword2-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest keyword2-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir

	  echo '$''Revision$' >> file1
	  echo "I" >>file1
	  echo "like" >>file1
	  echo "long" >>file1
	  echo "files!" >>file1
	  echo "" >>file1
	  echo "a test line for our times" >>file1
	  echo "" >>file1
	  echo "They" >>file1
	  echo "make" >>file1
	  echo "diff" >>file1
	  echo "look like it" >>file1
	  echo "did a much better" >>file1
	  echo "job." >>file1
	  dotest keyword2-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  awk 'BEGIN { printf "%c%c%c%sRevision: 1.1 $@@%c%c", \
	    2, 10, 137, "$", 13, 10 }' \
	    </dev/null | tr '@@' '\000' >../binfile.dat
	  cp ../binfile.dat .
	  dotest keyword2-5 "${testcvs} add -kb binfile.dat" \
"${PROG} [a-z]*: scheduling file .binfile\.dat. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  dotest keyword2-6 "${testcvs} -q ci -m add" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/binfile\.dat,v
done
Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/binfile\.dat,v  <--  binfile\.dat
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  dotest keyword2-7 "${testcvs} -q tag -b branch" \
"T binfile\.dat
T file1"

	  sed -e 's/our/the best of and the worst of/' file1 >f; mv f file1
	  dotest keyword2-8 "${testcvs} -q ci -m change" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done"

	  dotest keyword2-9 "${testcvs} -q update -r branch" '[UP] file1'

	  echo "what else do we have?" >>file1
	  dotest keyword2-10 "${testcvs} -q ci -m change" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  # Okay, first a conflict in file1 - should be okay with binfile.dat
	  dotest keyword2-11 "${testcvs} -q update -A -j branch" \
"U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file1
rcsmerge: warning: conflicts during merge"

	  dotest_fail keyword2-12 "${testcvs} diff file1" \
"Index: file1
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.2
diff -r1\.2 file1
0a1
> <<<<<<< file1
1a3,5
> =======
> \\\$""Revision: 1\.1\.2\.1 \\\$
> >>>>>>> 1\.1\.2\.1
14a19
> what else do we have${QUESTION}"

	  # Here's the problem... shouldn't -kk a binary file...
	  rm file1
	  if test "$remote" = yes; then
	    dotest keyword2-13 "${testcvs} -q update -A -kk -j branch" \
"U binfile.dat
U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file1"
	  else
	    dotest keyword2-13 "${testcvs} -q update -A -kk -j branch" \
"U binfile.dat
${PROG} [a-z]*: warning: file1 was lost
U file1
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file1"
	  fi

	  # binfile won't get checked in, but it is now corrupt and could
	  # have been checked in if it had changed on the branch...
	  dotest keyword2-14 "${testcvs} -q ci -m change" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.3; previous revision: 1\.2
done"

	  dotest_fail keyword2-15 "cmp binfile.dat ../binfile.dat" \
"binfile\.dat \.\./binfile\.dat differ: char 13, line 2"

	  # Okay, restore everything and make CVS try and merge a binary file...
	  dotest keyword2-16 "${testcvs} -q update -A" \
"[UP] binfile.dat
[UP] file1"
	  dotest keyword2-17 "${testcvs} -q tag -b branch2" \
"T binfile\.dat
T file1"
	  dotest keyword2-18 "${testcvs} -q update -r branch2" ''

	  awk 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | tr '@@' '\000' >>binfile.dat
	  dotest keyword2-19 "${testcvs} -q ci -m badbadbad" \
"Checking in binfile\.dat;
${TESTDIR}/cvsroot/first-dir/binfile\.dat,v  <--  binfile\.dat
new revision: 1\.1\.4\.1; previous revision: 1\.1
done"
	  dotest keyword2-20 "${testcvs} -q update -A -kk -j branch2" \
"U binfile\.dat
RCS file: ${TESTDIR}/cvsroot/first-dir/binfile\.dat,v
retrieving revision 1\.1
retrieving revision 1\.1\.4\.1
Merging differences between 1\.1 and 1\.1\.4\.1 into binfile\.dat
U file1"

	  # Yep, it's broke, 'cept for that gal in Hodunk who uses -kk
	  # so that some files only merge when she says so.  Time to clean up...
	  cd ../..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

a14802 15
	  #
	  # Note that this is not a complete test.  It relies on the fact
	  # that update, checkout and export have a LOT of shared code.
	  # Notice:
	  #	1)  checkout is never tested at all with -r -D
	  #	2)  update never uses an argument to '-D' besides 'now'
	  #		(this test does not provide enough data to prove
	  #		that 'cvs update' with both a '-r' and a '-D'
	  #		specified does not ignore '-D': a 'cvs up
	  #		-r<branch> -Dnow' and a 'cvs up -r<branch>'
	  #		should specify the same file revision).
	  #	3)  export uses '-r<branch> -D<when there was a different
	  #		revision>', hopefully completing this behavior test
	  #		for checkout and update as well.
	  #
a14839 1

a14842 24
	  # For some reason, doing this on a branch seems to be relevant.
	  dotest_fail tagdate-12 "${testcvs} -q update -j:yesterday" \
"${PROG} \[[a-z]* aborted\]: argument to join may not contain a date specifier without a tag"
	  # And check export

	  # Wish some shorter sleep interval would suffice, but I need to
	  # guarantee that the point in time specified by the argument to -D
	  # in tagdate-14 and tagdate-16
	  # falls in the space of time between commits to br2 and I
	  # figure 60 seconds is probably a large enough range to
	  # account for most network file system delays and such...
	  # as it stands, it takes between 1 and 2 seconds between
	  # calling CVS on my machine and the -D argument being used to
	  # recall the file revision and this timing will certainly vary
	  # by several seconds between machines - dependant on CPUspeeds,
	  # I/O speeds, load, etc.
	  sleep 60

	  echo br2-2 >file1
	  dotest tagdate-13 "${testcvs} -q ci -m modify-2-on-br2" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.1\.4\.2; previous revision: 1\.1\.4\.1
done"
d14844 1
a14844 60
	  mkdir 2; cd 
	  if ${testcvs} -q export -r br2 -D'1 minute ago' first-dir \
			>${TESTDIR}/tagdate.tmp 2>&1; then
	    if ${EXPR} "`cat ${TESTDIR}/tagdate.tmp`" : \
"[UP] first-dir/file1" >/dev/null; then
	      pass tagdate-14
	    else
	      echo "** expected: " >>${LOGFILE}
	      echo "[UP] first-dir/file1" >>${LOGFILE}
	      echo "** got: " >>${LOGFILE}
	      cat ${TESTDIR}/tagdate.tmp >>${LOGFILE}
	      fail tagdate-14
	    fi
	  else
	    echo "Bad exit status" >>${LOGFILE}
	    fail tagdate-14
	  fi

	  if ${EXPR} "`cat first-dir/file1`" : "br2-1" >/dev/null; then
	    pass tagdate-15
	  else
	    fail tagdate-15
	  fi

	  # Now for annotate
	  cd ../1/first-dir
	  if ${testcvs} annotate -rbr2 -D'1 minute ago' \
			>${TESTDIR}/tagdate.tmp 2>&1; then
	    if ${EXPR} "`cat ${TESTDIR}/tagdate.tmp`" : \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1\.4\.1      (${username} *[0-9a-zA-Z-]*): br2-1" >/dev/null; then
	      pass tagdate-16
	    else
	      echo "** expected: " >>${LOGFILE}
	      echo "Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1\.4\.1      (${username} *[0-9a-zA-Z-]*): br2-1" >>${LOGFILE}
	      echo "** got: " >>${LOGFILE}
	      cat ${TESTDIR}/tagdate.tmp >>${LOGFILE}
	      fail tagdate-16
	    fi
	  else
	    echo "Bad exit status" >>${LOGFILE}
	    fail tagdate-16
	  fi

	  dotest tagdate-17 "${testcvs} annotate -rbr2 -Dnow" \
"Annotations for file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1\.4\.2      (${username} *[0-9a-zA-Z-]*): br2-2"

	  if test $keep = yes; then
	    echo Keeping ${TESTDIR} and exiting due to --keep
	    exit 0
	  fi

	  cd ../..
	  rm ${TESTDIR}/tagdate.tmp
	  rm -r 1 2
a15086 1
	  # -n: admin, tagf tests.
a15391 5
	  # Now test that plain -e is at least parsed right.  CVS 1.10
	  # would wrongly treat "-e file1" as "-efile1".
	  dotest_fail admin-19a-2 "${testcvs} -q admin -e file1" \
"${PROG} \[[a-z]* aborted\]: removing entire access list not yet implemented"

d17405 1
a17405 1
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d17410 1
a17410 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d17414 1
a17414 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d17418 1
a17418 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
d17422 1
a17422 1
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a18512 41
	rmroot)
	  # When the Entries/Root file is removed from an existing
	  # workspace, CVS should assume $CVSROOT instead
	  #
	  # Right now only checking that CVS exits normally on an
	  # update once CVS/Root is deleted
	  #
	  # There was a time when this would core dump when run in
	  # client/server mode

	  mkdir 1; cd 1
	  dotest rmroot-setup-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest rmroot-setup-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
          cd first-dir
	  touch file1 file2
	  dotest rmroot-setup-3 "${testcvs} add file1 file2" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: scheduling file .file2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
	  dotest rmroot-setup-4 "${testcvs} -q commit -minit" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/file2,v
done
Checking in file2;
${TESTDIR}/cvsroot/first-dir/file2,v  <--  file2
initial revision: 1\.1
done"
	  rm CVS/Root
	  dotest rmroot-1 "${testcvs} -q update" ''

	  cd ../..
	  rm -rf 1
	  ;;

d18659 1
a18659 2
"${DOTSTAR} LOVE YOU
ok"
d18671 1
a18671 2
"${DOTSTAR} LOVE YOU
E Protocol error: Root says \"${TESTDIR}/1\" but pserver says \"${CVSROOT_DIRNAME}\"
a18683 20
	    ${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN VERIFICATION REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d^b?hd
END VERIFICATION REQUEST
EOF
	    dotest pserver-7 "cat ${TESTDIR}/pserver.tmp" \
"I HATE YOU"

	    ${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver >${TESTDIR}/pserver.tmp 2>&1 <<EOF
BEGIN VERIFICATION REQUEST
${CVSROOT_DIRNAME}
testme
Ay::'d
END VERIFICATION REQUEST
EOF
	    dotest pserver-8 "cat ${TESTDIR}/pserver.tmp" \
"${DOTSTAR} LOVE YOU"

d18729 2
a18730 2
	    awk 'BEGIN { \
printf "%c%c%c%c%c%c.6%c%c+I-.%c%c%c%c5%c;%c%c%c%c", \
d18733 1
d18736 1
a18736 2
	    cat <<EOF >session.dat
Root ${TESTDIR}/crerepos
d18746 1
a18746 1
${TESTDIR}/crerepos
a18765 171
	    # OK, here are some notify tests.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Notify file1
E	Fri May  7 13:21:09 1999 GMT	myhost	some-work-dir	EUC
noop
EOF
	      dotest server-6 "cat ${TESTDIR}/server.tmp" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-6
	    fi
	    # Sending the second "noop" before waiting for the output
	    # from the first is bogus but hopefully we can get away
	    # with it.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Notify file1
E	Fri May  7 13:21:09 1999 GMT	myhost	some-work-dir	EUC
noop
Notify file1
E	The 57th day of Discord in the YOLD 3165	myhost	some-work-dir	EUC
noop
EOF
	      dotest server-7 "cat ${TESTDIR}/server.tmp" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok
Notified \./
${TESTDIR}/crerepos/dir1/file1
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-7
	    fi

	    # OK, now test a few error conditions.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Notify file1
E	Setting Orange, the 52th day of Discord in the YOLD 3165	myhost	some-work-dir	EUC
noop
EOF
	      # FIXCVS: should give "error" and no "Notified", like server-9
	      dotest server-8 "cat ${TESTDIR}/server.tmp" \
"E ${PROG} server: invalid character in editor value
Notified \./
${TESTDIR}/crerepos/dir1/file1
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-8
	    fi

	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Notify file1
E	Setting Orange+57th day of Discord	myhost	some-work-dir	EUC
noop
EOF
	      dotest server-9 "cat ${TESTDIR}/server.tmp" \
"E Protocol error; misformed Notify request
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-9
	    fi

	    # First demonstrate an interesting quirk in the protocol.
	    # The "watchers" request selects the files to operate based
	    # on files which exist in the working directory.  So if we
	    # don't send "Entry" or the like, it won't do anything.
	    # Wants to be documented in cvsclient.texi...
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
watchers
EOF
	      dotest server-10 "cat ${TESTDIR}/server.tmp" \
"ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-10
	    fi

	    # See if "watchers" and "editors" display the right thing.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Entry /file1/1.1////
watchers
EOF
	      dotest server-11 "cat ${TESTDIR}/server.tmp" \
"M file1	${username}	tedit	tunedit	tcommit
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-11
	    fi
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Entry /file1/1.1////
editors
EOF
	      dotest server-12 "cat ${TESTDIR}/server.tmp" \
"M file1	${username}	The 57th day of Discord in the YOLD 3165	myhost	some-work-dir
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-12
	    fi

	    # Now do an unedit.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
Notify file1
U	7 May 1999 15:00 GMT	myhost	some-work-dir	EUC
noop
EOF
	      dotest server-13 "cat ${TESTDIR}/server.tmp" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-13
	    fi

	    # Now try "watchers" and "editors" again.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
watchers
EOF
	      dotest server-14 "cat ${TESTDIR}/server.tmp" \
"ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-14
	    fi
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/crerepos
Directory .
${TESTDIR}/crerepos/dir1
editors
EOF
	      dotest server-15 "cat ${TESTDIR}/server.tmp" \
"ok"
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server-15
	    fi

a18776 67
	server2)
	  # More server tests, in particular testing that various
	  # possible security holes are plugged.
	  if test "$remote" = yes; then
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/cvsroot
Directory .
${TESTDIR}/cvsroot/../dir1
noop
EOF
	      dotest server2-1 "cat ${TESTDIR}/server.tmp" \
"E protocol error: directory '${TESTDIR}/cvsroot/\.\./dir1' not within root '${TESTDIR}/cvsroot'
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server2-1
	    fi

	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/cvsroot
Directory .
${TESTDIR}/cvsrootdir1
noop
EOF
	      dotest server2-2 "cat ${TESTDIR}/server.tmp" \
"E protocol error: directory '${TESTDIR}/cvsrootdir1' not within root '${TESTDIR}/cvsroot'
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server2-2
	    fi

	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/cvsroot
Directory .
${TESTDIR}
noop
EOF
	      dotest server2-3 "cat ${TESTDIR}/server.tmp" \
"E protocol error: directory '${TESTDIR}' not within root '${TESTDIR}/cvsroot'
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server2-3
	    fi

	    # OK, now a few tests for the rule that one cannot pass a
	    # filename containing a slash to Modified, Is-modified,
	    # Notify, Questionable, or Unchanged.  For completeness
	    # we'd try them all.  For lazyness/conciseness we don't.
	    if ${testcvs} server >${TESTDIR}/server.tmp <<EOF; then
Root ${TESTDIR}/cvsroot
Directory .
${TESTDIR}/cvsroot
Unchanged foo/bar
noop
EOF
	      dotest server2-4 "cat ${TESTDIR}/server.tmp" \
"E protocol error: directory 'foo/bar' not within current directory
error  "
	    else
	      echo "exit status was $?" >>${LOGFILE}
	      fail server2-4
	    fi
	  fi
	  ;;

d18920 2
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d28 15
d71 1
a71 2
tmp=`(cd /tmp; /bin/pwd || pwd) 2>/dev/null`
: ${TESTDIR=$tmp/cvs-sanity}
a123 1
author="[-a-zA-Z0-9][-a-zA-Z0-9]*"
d157 1
a157 8
# clean any old remnants (we need the chmod because some tests make
# directories read-only)
if test -d ${TESTDIR}; then
    chmod -R a+wx ${TESTDIR}
    rm -rf ${TESTDIR}
fi
mkdir ${TESTDIR}
cd ${TESTDIR}
d159 1
a159 6
# Make sure various tools work the way we expect, or try to find
# versions that do.
: ${AWK=awk}
: ${EXPR=expr}
: ${ID=id}
: ${TR=tr}
d161 10
a170 8
find_tool ()
{
  GLOCS="`echo $PATH | sed 's/:/ /g'` /usr/local/bin /usr/contrib/bin /usr/gnu/bin /local/bin /local/gnu/bin /gun/bin"
  TOOL=""
  for path in $GLOCS ; do
    if test -x $path/g$1 ; then
      if test "X`$path/g$1 --version`" != "X--version" ; then
        TOOL=$path/g$1
d174 3
a176 3
    if test -x $path/$1 ; then
      if test "X`$path/$1 --version`" != "X--version" ; then
        TOOL=$path/$1
a180 43
  if test -z "$TOOL"; then
    :
  else
    echo "Notice: The default version of $1 is defective, using" >&2
    echo "$TOOL instead." >&2
  fi
  echo "$TOOL"
}  

# You can't run CVS as root; print a nice error message here instead
# of somewhere later, after making a mess.
case "`$ID -u`" in
  "0")
    echo "Test suite does not work correctly when run as root" >&2
    exit 1
    ;;

  "")
    ID=`find_tool id`
    if test -z "$ID" ; then
      echo 'Running these tests requires an "id" program that understands the' >&2
      echo '-u and -n flags.  Make sure that such an id (GNU, or many but not' >&2
      echo 'all vendor-supplied versions) is in your path.' >&2
      exit 1
    fi
    ;;
esac
username=`$ID -un`
if $EXPR "${username}" : "${username}" >/dev/null; then
  : good, it works
else
  echo "Test suite does not work correctly when run by a username" >&2
  echo "containing regular expression meta-characters." >&2
  exit 1
fi

# Cause NextStep 3.3 users to lose in a more graceful fashion.
if $EXPR 'abc
def' : 'abc
def' >/dev/null; then
  : good, it works
else
  EXPR=`find_tool expr`
d182 3
a184 3
    echo 'Running these tests requires an "expr" program that can handle' >&2
    echo 'multi-line patterns.  Make sure that such an expr (GNU, or many but' >&2
    echo 'not all vendor-supplied versions) is in your path.' >&2
d194 14
a207 1
  EXPR=`find_tool expr`
a217 29
# More SunOS lossage...
echo 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' >${TESTDIR}/foo
cat ${TESTDIR}/foo ${TESTDIR}/foo ${TESTDIR}/foo ${TESTDIR}/foo >${TESTDIR}/bar
cat ${TESTDIR}/bar ${TESTDIR}/bar ${TESTDIR}/bar ${TESTDIR}/bar >${TESTDIR}/foo
cat ${TESTDIR}/foo ${TESTDIR}/foo ${TESTDIR}/foo ${TESTDIR}/foo >${TESTDIR}/bar
if $EXPR "`cat ${TESTDIR}/bar`" : "`cat ${TESTDIR}/bar`" >/dev/null; then
  : good, it works
else
  EXPR=`find_tool expr`
  if test -z "$EXPR" ; then
    echo 'Warning: you are using a version of expr which does not correctly'
    echo 'match large patterns.  Some tests may spuriously fail.'
    echo 'You may wish to make sure GNU expr is in your path.'
    EXPR=expr
  fi
fi
if $EXPR "`cat ${TESTDIR}/bar`x" : "`cat ${TESTDIR}/bar`y" >/dev/null; then
  EXPR=`find_tool expr`
  if test -z "$EXPR" ; then
    echo 'Warning: you are using a version of expr which does not correctly'
    echo 'match large patterns.  Some tests may spuriously pass.'
    echo 'You may wish to make sure GNU expr is in your path.'
    EXPR=expr
  fi
else
  : good, it works
fi
rm -f ${TESTDIR}/foo ${TESTDIR}/bar

a267 13
# now make sure that tr works on NULs
if $EXPR `echo "123" | ${TR} '2' '\0'` : "123" >/dev/null; then
  TR=`find_tool tr`
  if test -z "$TR" ; then
    echo 'Warning: you are using a version of tr which does not correctly'
    echo 'handle NUL bytes.  Some tests may spuriously pass or fail.'
    echo 'You may wish to make sure GNU tr is in your path.'
    TR=tr
  fi
else
  : good, it works
fi

d362 2
a363 1
  while [ $line -le `wc -l <${TESTDIR}/dotest.tmp` ] ; do
d368 1
a368 2
      echo "Line $line:" >> ${LOGFILE}
      echo "**** expected: " >>${LOGFILE}
d370 1
a370 1
      echo "**** got: " >>${LOGFILE}
d446 1
a446 1
  if eval "$2" >${TESTDIR}/dotest.tmp 2>&1; then
d461 1
a461 1
  if eval "$2" >${TESTDIR}/dotest.tmp 2>&1; then
d485 1
a485 1
  if eval "$2" >${TESTDIR}/dotest.tmp 2>&1; then
d500 1
a500 1
  eval "$3" >${TESTDIR}/dotest.tmp 2>&1
d516 1
a516 1
  if eval "$2" >${TESTDIR}/dotest.tmp1 2>&1; then
d524 1
a524 1
  ${TR} '	' ' ' < ${TESTDIR}/dotest.tmp1 | sort > ${TESTDIR}/dotest.tmp
d528 8
d576 1
a576 1
	tests="${tests} join join2 join3 join-readonly-conflict join-admin"
a577 1
	tests="${tests} clean"
d579 1
a579 1
	tests="${tests} modules modules2 modules3 modules4 modules5"
d590 1
a590 1
	tests="${tests} serverpatch log log2 logopt ann ann-id"
d598 1
a598 1
	# tests="${tests} perms symlinks symlinks2 hardlinks"
a669 1
dotest 1a "${testcvs} init" ''
a807 15

	  # Test using -r to create a branch
	  dotest_fail basica-8a3 "${testcvs} -q ci -m bogus -r 3.0.0" \
"Checking in ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
${PROG} [a-z]*: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v: can't find branch point 3\.0
${PROG} [a-z]*: could not check in ssfile"
	  dotest basica-8a4 "${testcvs} -q ci -m valid -r 3.1.2" \
"Checking in ssfile;
${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 3\.1\.2\.1; previous revision: 3\.1
done"
	  # now get rid of the sticky tag and go back to the trunk
	  dotest basica-8a5 "${testcvs} -q up -A" "[UP] ssfile"

a816 9
	  dotest_fail basica-8b1 "${testcvs} -q diff -r1.2 -r1.3 -C 3isacrowd" \
"Index: sdir/ssdir/ssfile
===================================================================
RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
retrieving revision 1\.2
retrieving revision 1\.3
diff -C3isacrowd -r1\.2 -r1\.3
${PROG} [a-z]*: invalid context length argument"

a866 4
	  dotest basica-o6a "${testcvs} admin -o 3.1.2: ssfile" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/sdir/ssdir/ssfile,v
deleting revision 3\.1\.2\.1
done"
d1196 1
a1196 1
	  if test ! -d ../first-dir; then
d2070 38
a2107 44
"O [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir           =first-dir= ${TMPPWD}/\*
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir           == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir           == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1      == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1      == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1/dir2 == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir           == ${TMPPWD}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TMPPWD}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir           == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1      == ${TMPPWD}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1      == ${TMPPWD}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1      == ${TMPPWD}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1/dir2 == ${TMPPWD}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1/dir2 == ${TMPPWD}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1/dir2 == ${TMPPWD}
F [0-9-]* [0-9:]* ${PLUS}0000 ${username}                     =first-dir= ${TMPPWD}/\*
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-head:A\]
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-revision:1\.1\]
O [0-9-]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= ${TMPPWD}/\*
U [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TMPPWD}/first-dir
U [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir           == ${TMPPWD}/first-dir" \
"O [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir           =first-dir= <remote>/\*
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir           == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir           == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1      == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1      == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1/dir2 == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1/dir2 == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir           == <remote>
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == <remote>
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir           == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1      == <remote>
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1      == <remote>
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1      == <remote>
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1/dir2 == <remote>
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1/dir2 == <remote>
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1/dir2 == <remote>
F [0-9-]* [0-9:]* ${PLUS}0000 ${username}                     =first-dir= <remote>/\*
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-head:A\]
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-tag:rtagged-by-head\]
T [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir \[rtagged-by-revision:1\.1\]
O [0-9-]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= <remote>/\*"
d2249 4
a2252 3
	  # (it might be better to just change a few of the names in
	  # basica or some other test instead, always good to keep the
	  # testsuite concise).
d2286 2
a2287 1
	  dotest spacefiles-4 "${testcvs} add 'first dir'" \
d2289 3
d2297 2
a2298 1
	  dotest spacefiles-6 "${testcvs} add 'a file'" \
d2301 3
d2325 2
a2326 1
	  dotest spacefiles-13 "${testcvs} -q co 'first dir'" \
d2328 3
d2334 3
a2336 1
	  dotest spacefiles-14 "${testcvs} -q co 'first dir/a file'" \
d2338 3
d3576 6
d3584 1
a3584 1
	  echo no | dotest dirs-4 "${testcvs} release -d dir1/sdir" \
d3606 1
d3955 1
a3955 1
[=]======
d4517 1
a4517 1
	  dotest_fail rcslib-diffrgx-3 "${testcvs} diff -c -F'.*(' rgx.c" \
d4907 1
a4907 1
 ${PROG} checkout -jvendor-branch:yesterday -jvendor-branch first-dir
d4953 1
a4953 1
"${PROG} [a-z]*: file first-dir/imported-f1 does not exist, but is present in revision junk-2_0
d5017 1
a5017 1
 ${PROG} -d ${CVSROOT} checkout -jfreemunger:yesterday -jfreemunger first-dir
d5150 1
a5150 1
	    dotest importc-7a "${testcvs} -q ci -m modify" \
d5157 1
a5157 1
	    dotest importc-7r "${testcvs} -q ci -m modify -r wip_test" \
a5690 57
	  # Checkout the mainline again to try merging from the trunk
	  # to a branch.
	  cd ..
	  rm -r first-dir
	  dotest join-30 "${testcvs} -q co first-dir" \
'U first-dir/file2
U first-dir/file3
U first-dir/file4
U first-dir/file7'
	  cd first-dir

	  # Tag the current revisions on the trunk.
	  dotest join-31 "${testcvs} -q tag T3 ." \
'T file2
T file3
T file4
T file7'

	  # Modify file7.
	  echo 'second revision of file7' > file7
	  dotest join-32 "${testcvs} -q ci -mx ." \
"Checking in file7;
${TESTDIR}/cvsroot/first-dir/file7,v  <--  file7
new revision: 1\.2; previous revision: 1\.1
done"

	  # And Tag again.
	  dotest join-33 "${testcvs} -q tag T4 ." \
'T file2
T file3
T file4
T file7'

	  # Now update branch to T3.
	  cd ../../2/first-dir
	  dotest join-34 "${testcvs} -q up -jT3" \
"${PROG} [a-z]*: file file4 does not exist, but is present in revision T3
U file7"

	  # Verify that the right changes have been scheduled.
	  dotest join-35 "${testcvs} -q update" \
'A file7'

	  # Now update to T4.
	  # This is probably a bug, although in this particular case it just
	  # happens to do the right thing; see above join-20.
	  dotest join-36 "${testcvs} -q up -j T3 -j T4" \
"A file7
RCS file: ${TESTDIR}/cvsroot/first-dir/file7,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into file7"

	  # Verify that the right changes have been scheduled.
	  dotest join-37 "${testcvs} -q update" \
'A file7'

a5977 43
	join-admin)
	  mkdir 1; cd 1
	  dotest join-admin-1 "$testcvs -q co -l ." ''
	  module=x
	  mkdir $module
	  $testcvs -q add $module >>$LOGFILE 2>&1
	  cd $module

	  # Create a file so applying the first tag works.
	  echo foo > a
	  $testcvs -Q add a > /dev/null 2>&1
	  $testcvs -Q ci -m. a > /dev/null 2>&1

	  $testcvs -Q tag -b B
	  $testcvs -Q tag -b M1
	  echo '$''Id$' > b
	  $testcvs -Q add b > /dev/null 2>&1
	  $testcvs -Q ci -m. b > /dev/null 2>&1
	  $testcvs -Q tag -b M2

	  $testcvs -Q update -r B
	  $testcvs -Q update -kk -jM1 -jM2
	  $testcvs -Q ci -m. b >/dev/null 2>&1

	  $testcvs -Q update -A

	  # Verify that the -kk flag from the update did not
	  # propagate to the repository.
	  dotest join-admin-1 "$testcvs status b" \
"===================================================================
File: b                	Status: Up-to-date

   Working revision:	1\.1.*
   Repository revision:	1\.1	${TESTDIR}/cvsroot/x/b,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

d6265 1
d6267 1
a6267 17
		# Make sure we detect any one of the three conflict markers
		mv a aa
		grep '^<<<<<<<' aa >a
		dotest conflicts-status-2 "${testcvs} -nq ci -m try a" \
"${PROG} [a-z]*: warning: file .a. seems to still contain conflict indicators"

		grep '^=======' aa >a
		dotest conflicts-status-3 "${testcvs} -nq ci -m try a" \
"${PROG} [a-z]*: warning: file .a. seems to still contain conflict indicators"

		grep '^>>>>>>>' aa >a
		dotest conflicts-status-4 "${testcvs} -qn ci -m try a" \
"${PROG} [a-z]*: warning: file .a. seems to still contain conflict indicators"

		mv aa a
		echo lame attempt at resolving it >>a
		dotest conflicts-status-5 "${testcvs} status a" \
d6286 1
a6286 1
		dotest conflicts-status-6 "${testcvs} status a" \
d6300 1
a6300 1
		dotest conflicts-status-7 "${testcvs} status a" \
a6792 56
	clean)
	  # Test update -C (overwrite local mods w/ repository copies)
	  mkdir 1; cd 1
	  dotest clean-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest clean-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo "The usual boring test text." > cleanme.txt
          dotest clean-3 "${testcvs} add cleanme.txt" \
"${PROG} [a-z]*: scheduling file .cleanme\.txt. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest clean-4 "${testcvs} -q ci -m clean-3" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/cleanme\.txt,v
done
Checking in cleanme\.txt;
${TESTDIR}/cvsroot/first-dir/cleanme\.txt,v  <--  cleanme\.txt
initial revision: 1\.1
done"
          # Okay, preparation is done, now test.
          # Check that updating an unmodified copy works.
	  dotest clean-5 "${testcvs} -q update" ''
          # Check that updating -C an unmodified copy works.
	  dotest clean-6 "${testcvs} -q update -C" ''
          # Check that updating a modified copy works.
	  echo "fish" >> cleanme.txt
	  dotest clean-7 "${testcvs} -q update" 'M cleanme\.txt'
          # Check that updating -C a modified copy works.
	  dotest clean-8 "${testcvs} -q update -C" \
"(Locally modified cleanme\.txt moved to \.#cleanme\.txt\.1\.1)
U cleanme\.txt"
	  # And check that the backup copy really was made.
	  dotest clean-9 "cat .#cleanme.txt.1.1" \
"The usual boring test text\.
fish"

          # Do it all again, this time naming the file explicitly.
	  rm .#cleanme.txt.1.1
	  dotest clean-10 "${testcvs} -q update cleanme.txt" ''
	  dotest clean-11 "${testcvs} -q update -C cleanme.txt" ''
	  echo "bluegill" >> cleanme.txt
	  dotest clean-12 "${testcvs} -q update cleanme.txt" 'M cleanme\.txt'
	  dotest clean-13 "${testcvs} -q update -C cleanme.txt" \
"(Locally modified cleanme\.txt moved to \.#cleanme\.txt\.1\.1)
U cleanme\.txt"
	  # And check that the backup copy really was made.
	  dotest clean-14 "cat .#cleanme.txt.1.1" \
"The usual boring test text\.
bluegill"

          # Done.  Clean up.
	  cd ../..
          rm -rf 1
	  rm -rf ${TESTDIR}/cvsroot/first-dir
	  ;;

a6804 1
	  # -i, -o, -u, -e, -t: modules5
d6896 5
a6900 1
	  dotest modules-143 "${testcvs} -q co first-dir" ""
d6904 2
a6905 2
	  dotest modules-143a "${testcvs} add subdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"
a6906 1
	  cd subdir
d6908 1
a6908 2
	  dotest modules-143b "${testcvs} add ssdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir/ssdir added to the repository"
d6912 5
a6916 4
	  dotest modules-144 "${testcvs} add a b" \
"${PROG} [a-z]*: scheduling file .a. for addition
${PROG} [a-z]*: scheduling file .b. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d6918 5
a6922 15
	  dotest modules-145 "${testcvs} ci -m added" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining ssdir
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/a,v
done
Checking in a;
${TESTDIR}/cvsroot/first-dir/subdir/a,v  <--  a
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/b,v
done
Checking in b;
${TESTDIR}/cvsroot/first-dir/subdir/b,v  <--  b
initial revision: 1\.1
done"
d6925 5
a6929 12
	  dotest modules-146 "${testcvs} -q co CVSROOT" \
"U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg"
d6935 5
a6939 22
	  dotest modules-147 "${testcvs} -q update" ""

	  cat >CVSROOT/modules <<EOF
realmodule first-dir/subdir a
dirmodule first-dir/subdir
namedmodule -d nameddir first-dir/subdir
aliasmodule -a first-dir/subdir/a
aliasnested -a first-dir/subdir/ssdir
topfiles -a first-dir/file1 first-dir/file2
world -a .
statusmod -s Mungeable
# Options must come before arguments.  It is possible this should
# be relaxed at some point (though the result would be bizarre for
# -a); for now test the current behavior.
bogusalias first-dir/subdir/a -a
EOF
	  dotest modules-148 "${testcvs} ci -m 'add modules' CVSROOT/modules" \
"Checking in CVSROOT/modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"
d6941 19
d6965 1
a6965 1
	  dotest modules-148a0 "${testcvs} co -c" 'aliasmodule  -a first-dir/subdir/a
d6977 1
a6977 1
	  dotest modules-148a1 "${testcvs} co -s" \
d6985 25
a7009 7
	  dotest modules-149a1 "${testcvs} co realmodule" "U realmodule/a"
	  dotest modules-149a2 "test -d realmodule && test -f realmodule/a" ""
	  dotest_fail modules-149a3 "test -f realmodule/b" ""
	  dotest modules-149a4 "${testcvs} -q co realmodule" ""
	  dotest modules-149a5 "echo yes | ${testcvs} release -d realmodule" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .realmodule.: "
d7011 1
a7011 1
	  dotest_fail modules-149b1 "${testcvs} co realmodule/a" \
d7017 20
a7036 6
	  dotest modules-150c "${testcvs} co dirmodule/a" "U dirmodule/a"
	  dotest modules-150d "test -d dirmodule && test -f dirmodule/a" ""
	  dotest_fail modules-150e "test -f dirmodule/b" ""
	  dotest modules-150f "echo yes | ${testcvs} release -d dirmodule" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .dirmodule.: "
d7040 8
a7047 5
	  # We accept a zero exit status because it is what CVS does
	  # (Dec 95).  Probably the exit status should be nonzero,
	  # however.
	  dotest modules-150g1 "${testcvs} co dirmodule/nonexist" \
"${PROG} [a-z]*: warning: new-born dirmodule/nonexist has disappeared"
d7051 5
a7055 1
	  dotest_fail modules-150g2 "test -f dirmodule/a || test -f dirmodule/b" ""
d7060 1
a7060 2
	  dotest modules-150h1 "${testcvs} -q co namedmodule" \
'U nameddir/a
d7062 5
a7066 1
	  dotest modules-150h2 "test -f nameddir/a && test -f nameddir/b" ""
d7068 1
a7068 1
	  dotest modules-150h3 "${testcvs} -q co namedmodule" 'M nameddir/a'
d7070 6
a7075 4
	  dotest modules-150h4 "${testcvs} -q co namedmodule" 'U nameddir/a'
	  dotest modules-150h99 "echo yes | ${testcvs} release -d nameddir" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .nameddir.: "
d7079 10
a7088 2
	  dotest modules-151 "${testcvs} co aliasmodule" ""
	  dotest_fail modules-152 "test -d aliasmodule" ""
d7090 12
a7101 1
	  dotest modules-153 "${testcvs} -q co aliasmodule" "M first-dir/subdir/a"
a7220 2
	  echo 'ampdirmod -d newdir &first-dir &second-dir' >> modules
	  echo 'badmod -d newdir' >> modules
a7296 2
	  cd ..
	  rm -r 1
d7300 2
a7327 16
	  # Now test the "ampdirmod" and "badmod" modules to be sure that
	  # options work with ampersand modules but don't prevent the
	  # "missing directory" error message.
	  mkdir 1; cd 1
	  dotest modules2-20 "${testcvs} co ampdirmod" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/amper1
${PROG} [a-z]*: Updating second-dir"
	  dotest modules2-21 "test -f newdir/first-dir/amper1" ""
	  dotest_fail modules2-22 "${testcvs} co badmod" \
"${PROG} [a-z]*: modules file missing directory for module badmod" \
"${PROG} [a-z]*: modules file missing directory for module badmod
${PROG} \[[a-z]* aborted\]: cannot expand modules"
	  cd ..
	  rm -r 1

d7649 2
a7650 222
	modules5)
	  # Test module programs

	  mkdir ${CVSROOT_DIRNAME}/first-dir
	  mkdir 1
	  cd 1
	  dotest modules5-1 "${testcvs} -q co first-dir" ""
	  cd first-dir
	  mkdir subdir
	  dotest modules5-2 "${testcvs} add subdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir added to the repository"
	  cd subdir
	  mkdir ssdir
	  dotest modules5-3 "${testcvs} add ssdir" \
"Directory ${TESTDIR}/cvsroot/first-dir/subdir/ssdir added to the repository"
	  touch a b
	  dotest modules5-4 "${testcvs} add a b" \
"${PROG} [a-z]*: scheduling file .a. for addition
${PROG} [a-z]*: scheduling file .b. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"

	  dotest modules5-5 "${testcvs} ci -m added" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining ssdir
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/a,v
done
Checking in a;
${TESTDIR}/cvsroot/first-dir/subdir/a,v  <--  a
initial revision: 1\.1
done
RCS file: ${TESTDIR}/cvsroot/first-dir/subdir/b,v
done
Checking in b;
${TESTDIR}/cvsroot/first-dir/subdir/b,v  <--  b
initial revision: 1\.1
done"

	  cd ..
	  dotest modules5-6 "${testcvs} -q co CVSROOT" \
"U CVSROOT/checkoutlist
U CVSROOT/commitinfo
U CVSROOT/config
U CVSROOT/cvswrappers
U CVSROOT/editinfo
U CVSROOT/loginfo
U CVSROOT/modules
U CVSROOT/notify
U CVSROOT/rcsinfo
U CVSROOT/taginfo
U CVSROOT/verifymsg"

	  for i in checkin checkout update export tag; do
	    cat >> ${CVSROOT_DIRNAME}/$i.sh <<EOF
#! /bin/sh
echo "$i script invoked in \`pwd\`"
echo "args: \$@@"
EOF
	    chmod +x ${CVSROOT_DIRNAME}/$i.sh
	  done

	  OPTS="-i ${CVSROOT_DIRNAME}/checkin.sh -o${CVSROOT_DIRNAME}/checkout.sh -u ${CVSROOT_DIRNAME}/update.sh -e ${CVSROOT_DIRNAME}/export.sh -t${CVSROOT_DIRNAME}/tag.sh"
	  cat >CVSROOT/modules <<EOF
realmodule ${OPTS} first-dir/subdir a
dirmodule ${OPTS} first-dir/subdir
namedmodule -d nameddir ${OPTS} first-dir/subdir
EOF

	  dotest modules5-7 "${testcvs} ci -m 'add modules' CVSROOT/modules" \
"" \
"Checking in CVSROOT/modules;
${TESTDIR}/cvsroot/CVSROOT/modules,v  <--  modules
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
done
${PROG} [a-z]*: Rebuilding administrative file database"

	  cd ..
	  rm -rf first-dir
	  # Test that real modules check out to realmodule/a, not subdir/a.
	  if test "$remote" = "yes"; then
	    dotest modules5-8 "${testcvs} co realmodule" \
"U realmodule/a
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkout\.sh. .realmodule..
checkout script invoked in .*
args: realmodule"
	  else
	    dotest modules5-8 "${testcvs} co realmodule" \
"U realmodule/a
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkout\.sh. .realmodule..
checkout script invoked in ${TESTDIR}/1
args: realmodule"
	  fi
	  dotest modules5-9 "test -d realmodule && test -f realmodule/a" ""
	  dotest_fail modules5-10 "test -f realmodule/b" ""
	  if test "$remote" = "yes"; then
	    dotest modules5-11 "${testcvs} -q co realmodule" \
"checkout script invoked in .*
args: realmodule"
	    dotest modules5-12 "${testcvs} -q update" \
"${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/update\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
update script invoked in /.*/realmodule
args: ${CVSROOT_DIRNAME}/first-dir/subdir"
	    echo "change" >>realmodule/a
	    dotest modules5-13 "${testcvs} -q ci -m." \
"Checking in realmodule/a;
${CVSROOT_DIRNAME}/first-dir/subdir/a,v  <--  a
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkin\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
checkin script invoked in /.*/realmodule
args: ${CVSROOT_DIRNAME}/first-dir/subdir"
	  else
	    dotest modules5-11 "${testcvs} -q co realmodule" \
"checkout script invoked in ${TESTDIR}/1
args: realmodule"
	    dotest modules5-12 "${testcvs} -q update" \
"${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/update\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
update script invoked in ${TESTDIR}/1/realmodule
args: ${CVSROOT_DIRNAME}/first-dir/subdir"
	    echo "change" >>realmodule/a
	    dotest modules5-13 "${testcvs} -q ci -m." \
"Checking in realmodule/a;
${CVSROOT_DIRNAME}/first-dir/subdir/a,v  <--  a
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkin\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
checkin script invoked in ${TESTDIR}/1/realmodule
args: ${CVSROOT_DIRNAME}/first-dir/subdir"
	  fi
	  dotest modules5-14 "echo yes | ${testcvs} release -d realmodule" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .realmodule.: "
	  dotest modules5-15 "${testcvs} -q rtag -Dnow MYTAG realmodule" \
"tag script invoked in ${TESTDIR}/1
args: realmodule MYTAG"
	  if test "$remote" = "yes"; then
	    dotest modules5-16 "${testcvs} -q export -r MYTAG realmodule" \
"U realmodule/a
export script invoked in .*
args: realmodule"
	  else
	    dotest modules5-16 "${testcvs} -q export -r MYTAG realmodule" \
"U realmodule/a
export script invoked in ${TESTDIR}/1
args: realmodule"
	  fi

	  dotest_fail modules5-17 "${testcvs} co realmodule/a" \
"${PROG}"' [a-z]*: module `realmodule/a'\'' is a request for a file in a module which is not a directory' \
"${PROG}"' [a-z]*: module `realmodule/a'\'' is a request for a file in a module which is not a directory
'"${PROG}"' \[[a-z]* aborted\]: cannot expand modules'

	  # FIXCVS: The client gets confused in these cases and tries to
	  # store the scripts in the wrong places.
	  if test "$remote" != "yes"; then
	    # Now test the ability to check out a single file from a directory
	    dotest modules5-18 "${testcvs} co dirmodule/a" \
"U dirmodule/a
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkout\.sh. .dirmodule..
checkout script invoked in ${TESTDIR}/1
args: dirmodule"
	    dotest modules5-19 "test -d dirmodule && test -f dirmodule/a" ""
	    dotest_fail modules5-20 "test -f dirmodule/b" ""
	    dotest modules5-21 "echo yes | ${testcvs} release -d dirmodule" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .dirmodule.: "

	    # Now test the ability to correctly reject a non-existent filename.
	    # For maximum studliness we would check that an error message is
	    # being output.
	    # We accept a zero exit status because it is what CVS does
	    # (Dec 95).  Probably the exit status should be nonzero,
	    # however.
	    dotest modules5-22 "${testcvs} co dirmodule/nonexist" \
"${PROG} [a-z]*: warning: new-born dirmodule/nonexist has disappeared
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/checkout\.sh. .dirmodule..
checkout script invoked in ${TESTDIR}/1
args: dirmodule"

	    # We tolerate the creation of the dirmodule directory, since that
	    # is what CVS does, not because we view that as preferable to not
	    # creating it.
	    dotest_fail modules5-23 "test -f dirmodule/a || test -f dirmodule/b" ""
	    rm -r dirmodule

	    # Now test that a module using -d checks out to the specified
	    # directory.
	    dotest modules5-24 "${testcvs} -q co namedmodule" \
"U nameddir/a
U nameddir/b
checkout script invoked in ${TESTDIR}/1
args: nameddir"
	    dotest modules5-25 "test -f nameddir/a && test -f nameddir/b" ""
	    echo add line >>nameddir/a
	    # This seems suspicious: when we checkout an existing directory,
	    # the checkout script gets executed in addition to the update
	    # script.  Is that by design or accident?
	    dotest modules5-26 "${testcvs} -q co namedmodule" \
"M nameddir/a
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/update\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
update script invoked in ${TESTDIR}/1/nameddir
args: ${CVSROOT_DIRNAME}/first-dir/subdir
checkout script invoked in ${TESTDIR}/1
args: nameddir"
	    rm nameddir/a
	    dotest modules5-27 "${testcvs} -q co namedmodule" \
"U nameddir/a
${PROG} [a-z]*: Executing ..${CVSROOT_DIRNAME}/update\.sh. .${CVSROOT_DIRNAME}/first-dir/subdir..
update script invoked in ${TESTDIR}/1/nameddir
args: ${CVSROOT_DIRNAME}/first-dir/subdir
checkout script invoked in ${TESTDIR}/1
args: nameddir"
	    dotest modules5-28 "echo yes | ${testcvs} release -d nameddir" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .nameddir.: "
	  fi

	  cd ..
	  rm -rf 1 ${CVSROOT_DIRNAME}/first-dir ${CVSROOT_DIRNAME}/*.sh
	  ;;

	mkmodules-temp-file-removal)
	  # When a file listed in checkoutlist doesn't exist, cvs-1.10.4
d7780 1
a7780 3
${PROG} [a-z]*: Rebuilding administrative file database" \
"${PROG} [a-z]*: Examining .
${PROG} [a-z]*: Examining CVSROOT"
a9117 2
	  echo "2d1moda -d dir2d1/suba moda/modasub" >> CVSROOT/modules
	  echo "comb -a 2d1mod 2d1moda" >> CVSROOT/modules
d9125 1
a9125 2
${PROG} [a-z]*: Rebuilding administrative file database" \
"${PROG} [a-z]*: Examining CVSROOT"
d9128 1
a9128 1
	  mkdir ${CVSROOT_DIRNAME}/mod1 ${CVSROOT_DIRNAME}/moda
d9130 2
a9131 4
	  dotest emptydir-3 "${testcvs} -q co -l ." ""
	  dotest emptydir-3a "${testcvs} co mod1 moda" \
"${PROG} [a-z]*: Updating mod1
${PROG} [a-z]*: Updating moda"
d9133 6
a9138 9
	  mkdir moda/modasub
	  dotest emptydir-3b "${testcvs} add moda/modasub" \
"Directory ${TESTDIR}/cvsroot/moda/modasub added to the repository"
	  echo "filea" > moda/modasub/filea
	  dotest emptydir-4 "${testcvs} add mod1/file1 moda/modasub/filea" \
"${PROG} [a-z]*: scheduling file .mod1/file1. for addition
${PROG} [a-z]*: scheduling file .moda/modasub/filea. for addition
${PROG} [a-z]*: use '${PROG} commit' to add these files permanently"
	  dotest emptydir-5 "${testcvs} -q ci -m yup" \
a9143 6
done
RCS file: ${CVSROOT_DIRNAME}/moda/modasub/filea,v
done
Checking in moda/modasub/filea;
${CVSROOT_DIRNAME}/moda/modasub/filea,v  <--  filea
initial revision: 1\.1
d9145 1
a9145 1
	  rm -rf mod1 moda CVS
d9157 5
a9161 5
	  dotest_fail emptydir-7 "${testcvs} add emptyfile" \
"${PROG} \[[a-z]* aborted\]: cannot add to ${TESTDIR}/cvsroot/CVSROOT/Emptydir"
	  mkdir emptydir
	  dotest_fail emptydir-8 "${testcvs} add emptydir" \
"${PROG} \[[a-z]* aborted\]: cannot add to ${TESTDIR}/cvsroot/CVSROOT/Emptydir"
a9175 1
	  cd ..
a9176 13
	  # Now start playing with moda.
	  mkdir 2; cd 2
	  dotest emptydir-12 "${testcvs} -q co 2d1moda" \
"U dir2d1/suba/filea"
	  # OK, this is the crux of the matter.  Some people think
	  # it would be more logical if this showed "moda".  But why
	  # "moda" (from module 2d1moda) and not "." (from module 2d1mod)?
	  dotest emptydir-13 "cat dir2d1/CVS/Repository" "CVSROOT/Emptydir"
	  dotest emptydir-14 "${testcvs} co comb" \
"${PROG} [a-z]*: Updating dir2d1/sub2d1
U dir2d1/sub2d1/file1
${PROG} [a-z]*: Updating dir2d1/suba"
	  dotest emptydir-15 "cat dir2d1/CVS/Repository" "CVSROOT/Emptydir"
d9179 2
a9180 2
	  rm -r 1 2
	  rm -rf ${CVSROOT_DIRNAME}/mod1 ${CVSROOT_DIRNAME}/moda
a10004 8
	  # while we're here... check commit with no CVS directory
	  dotest_fail errmsg2-8a "${testcvs} -q ci first-dir nonexistant" \
"${PROG} [a-z]*: nothing known about .nonexistant'
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  dotest_fail errmsg2-8b "${testcvs} -q ci nonexistant first-dir" \
"${PROG} [a-z]*: nothing known about .nonexistant'
${PROG} \[[a-z]* aborted\]: correct above errors first!"
	  dotest errmsg2-8c "${testcvs} -q ci first-dir" ""
a10077 10
	  # trying to import the repository

	  if test "$remote" = "no"; then
	    cd ${CVSROOT_DIRNAME}
	    dotest_fail errmsg2-20 "${testcvs} import -mtest . A B" \
"${PROG} \[[a-z]* aborted\]: attempt to import the repository"
	    dotest_fail errmsg2-21 "${testcvs} import -mtest first-dir A B" \
"${PROG} \[[a-z]* aborted\]: attempt to import the repository"
	  fi

d10369 1
a10369 19
	  # Do a little error testing
	  dotest devcom2-18 "${testcvs} -q co -d first+dir first-dir" \
"U first${PLUS}dir/nw1
U first${PLUS}dir/w1
U first${PLUS}dir/w2
U first${PLUS}dir/w3"
	  cd first+dir
	  dotest_fail devcom2-19 "${testcvs} edit" \
"${PROG} \[[a-z]* aborted\]: current directory (${TESTDIR}/2/first${PLUS}dir) contains an invalid character (${PLUS},>;=\\\\t\\\\n)"

	  # Make sure there are no droppings lying around
	  dotest devcom2-20 "cat ${CVSROOT_DIRNAME}/first-dir/CVS/fileattr" \
"Fw1	_watched=
Fw2	_watched=
Fw3	_watched=
Fnw1	_watched=
D	_watched="

	  cd ../..
d10642 3
a10644 1
	  echo "yes" | dotest unedit-without-baserev-4 "${testcvs} -Q unedit $file" \
d10647 3
d10697 2
a10698 1
	  echo yes | dotest unedit-without-baserev-14 "${testcvs} unedit m" \
d10701 3
d10847 7
a10853 1
	  echo yes | dotest ignore-192 "${testcvs} release -d first-dir" \
d10860 7
a10866 1
	  echo yes | dotest ignore-194 "${testcvs} release -d second-dir" \
d10874 1
d10890 2
a10891 2
	  ${AWK} 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | ${TR} '@@' '\000' >binfile.dat
d11162 2
a11163 2
	  ${AWK} 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | ${TR} '@@' '\000' >../binfile
d11324 2
a11325 2
	  ${AWK} 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | ${TR} '@@' '\000' >binfile.dat
d11380 1
a11380 1
	  echo '%%$$##@@@@!!jjiiuull' | ${TR} j '\000' >>${TESTDIR}/1/binfile4.dat
d11382 1
a11382 1
	  echo 'aawwee%$$##@@@@!!jjil' | ${TR} w '\000' >>${TESTDIR}/1/binfile5.dat
a12013 1
	  rm -f $TESTDIR/testlog $TESTDIR/testlog2
a12053 7
	  echo line0 >>file1
	  dotest info-6b "${testcvs} -q -sOTHER=foo ci -m mod-it" \
"Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
new revision: 1\.2; previous revision: 1\.1
done
${PROG} [a-z]*: loginfo:1: no such user variable \${=ZEE}"
d12058 1
a12058 1
new revision: 1\.3; previous revision: 1\.2
a12070 5
first-dir file1ux
first-dir file1,1.2,1.3
first-dir 1.3
first-dir file1
first-dir 1.2AX
d12078 1
a12078 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
a12088 1
    sleep 1
d12097 1
a12097 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d12114 1
a12114 1
new revision: 1\.4; previous revision: 1\.3
d12133 1
a12133 1
new revision: 1\.[0-9]*; previous revision: 1\.[0-9]*
d12395 2
a12396 4
	  #   -d: logopt, rcs
	  #   -s: logopt, rcs3
	  #   -R: logopt, rcs3
	  #   -w, -t: not tested yet (TODO)
a12562 27
#	  Check that unusual syntax works correctly.

	  dotest log-14c "${testcvs} log -r: file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
	  dotest log-14d "${testcvs} log -r, file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
	  dotest log-14e "${testcvs} log -r. file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

a12602 12
	  # Multiple -r options are undocumented; see comments in
	  # cvs.texinfo about whether they should be deprecated.
	  dotest log-18a "${testcvs} log -r1.2.2.2 -r1.3:1.3 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev3}
${log_rev2b}
${log_trailer}"

d12733 4
d12743 2
a12744 1
"${PROG} \[[a-z]* aborted\]: can't stat ${TESTDIR}/nonexist: No such file or directory"
d12763 3
a12765 4
	  # TODO: `cvs admin -t "my message" file1' is a request to
	  # read the message from stdin and to operate on two files.
	  # Should test that there is an error because "my message"
	  # doesn't exist.
d12767 12
a12778 2
	  dotest log2-9 "echo change from stdin | ${testcvs} admin -t -q file1" ""
	  dotest log2-10 "${testcvs} log -N file1" "
d12795 2
a12803 43
	logopt)
	  # Some tests of log.c's option parsing and such things.
	  mkdir 1; cd 1
	  dotest logopt-1 "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest logopt-2 "${testcvs} add first-dir" \
"Directory ${TESTDIR}/cvsroot/first-dir added to the repository"
	  cd first-dir
	  echo hi >file1
	  dotest logopt-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest logopt-4 "${testcvs} -q ci -m add file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done
Checking in file1;
${TESTDIR}/cvsroot/first-dir/file1,v  <--  file1
initial revision: 1\.1
done"
	  cd ..

	  dotest logopt-5 "${testcvs} log -R -d 2038-01-01" \
"${PROG} [a-z]*: Logging \.
${PROG} [a-z]*: Logging first-dir
${TESTDIR}/cvsroot/first-dir/file1,v"
	  dotest logopt-6 "${testcvs} log -d 2038-01-01 -R" \
"${PROG} [a-z]*: Logging \.
${PROG} [a-z]*: Logging first-dir
${TESTDIR}/cvsroot/first-dir/file1,v"
	  dotest logopt-6a "${testcvs} log -Rd 2038-01-01" \
"${PROG} [a-z]*: Logging \.
${PROG} [a-z]*: Logging first-dir
${TESTDIR}/cvsroot/first-dir/file1,v"
	  dotest logopt-7 "${testcvs} log -s Exp -R" \
"${PROG} [a-z]*: Logging \.
${PROG} [a-z]*: Logging first-dir
${TESTDIR}/cvsroot/first-dir/file1,v"

	  cd ..
	  rm -r 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

d13299 1
a13299 1
	  dotest rcs-3 "${testcvs} -q log -d '1996-12-11<'" "
d13318 3
a13320 2
	  dotest rcs-4 "${testcvs} -q log -d '<3 Apr 2000 00:00'" \
"
d13341 3
d13548 7
a13554 2
	  dotest rcs-9 "${testcvs} -q update -p -D '1970-12-31 11:30 UT' file2" \
"start revision"
d13556 7
a13562 2
	  dotest rcs-10 "${testcvs} -q update -p -D '1970-12-31 12:30 UT' file2" \
"mid revision"
d13564 7
a13570 2
	  dotest rcs-11 "${testcvs} -q update -p -D '1971-01-01 00:30 UT' file2" \
"new year revision"
d13573 7
a13579 2
	  dotest rcs-12 "${testcvs} -q update -p -D 'December 31, 1970 12:30pm UT' file2" \
"mid revision"
d13582 7
a13588 2
	  dotest rcs-13 "${testcvs} -q update -p -D 'January 1, 1971 12:30am UT' file2" \
"new year revision"
a13633 40
	  # Now test each date format for "cvs log -d".
	  # Earlier than 1971-01-01
	  dotest rcs-15 "${testcvs} -q log -d '<1971-01-01 00:00 GMT' file2 \
	    | grep revision" \
"total revisions: 7;	selected revisions: 3
revision 1\.3
revision 1\.2
revision 1\.1"
	  # Later than 1971-01-01
	  dotest rcs-16 "${testcvs} -q log -d '1971-01-01 00:00 GMT<' file2 \
	    | grep revision" \
"total revisions: 7;	selected revisions: 4
revision 1\.5
revision 1\.4
revision 1\.2\.6\.2
revision 1\.2\.6\.1"
	  # Alternate syntaxes for later and earlier; multiple -d options
	  dotest rcs-17 "${testcvs} -q log -d '>1971-01-01 00:00 GMT' \
	    -d '1970-12-31 12:15 GMT>' file2 | grep revision" \
"total revisions: 7;	selected revisions: 5
revision 1\.5
revision 1\.4
revision 1\.1
revision 1\.2\.6\.2
revision 1\.2\.6\.1"
	  # Range, and single date
	  dotest rcs-18 "${testcvs} -q log -d '1970-12-31 11:30 GMT' \
	    -d '1971-01-01 00:00:05 GMT<1971-01-01 01:00:01 GMT' \
	    file2 | grep revision" \
"total revisions: 7;	selected revisions: 2
revision 1\.5
revision 1\.1"
	  # Alternate range syntax; equality
	  dotest rcs-19 "${testcvs} -q log \
	    -d '1971-01-01 01:00:01 GMT>=1971-01-01 00:00:05 GMT' \
	    file2 | grep revision" \
"total revisions: 7;	selected revisions: 2
revision 1\.5
revision 1\.4"

d13636 1
a13636 1
	  rm -r first-dir
d13687 4
a13690 1
	  dotest rcs2-2 "${testcvs} -q update -p -D '1999-09-09 11:30 UT' file1" \
d13692 3
d13696 4
a13699 1
	  dotest rcs2-3 "${testcvs} -q update -p -D '2001-01-01 11:30 UT' file1" \
d13701 3
d13705 4
a13708 1
	  dotest rcs2-4 "${testcvs} -q update -p -D '2000-02-29 11:30 UT' file1" \
d13710 3
d13714 6
a13719 1
	  dotest_fail rcs2-5 "${testcvs} -q update -p -D '2003-02-29 11:30 UT' file1" \
d13721 1
d13739 16
a13754 4
	  dotest rcs2-7 "${testcvs} -q update -p -D '100 months' file1" \
"head revision"
	  dotest rcs2-8 "${testcvs} -q update -p -D '8 years' file1" \
"head revision"
d13775 1
a13775 1
"${PROG} \[[a-z]* aborted\]: EOF while looking for value in RCS file ${TESTDIR}/cvsroot/first-dir/file1,v"
d13796 16
a13811 4

	  # Ouch, didn't expect this one.  FIXCVS.  Or maybe just remove
	  # the feature, if this is a -s problem?
	  dotest_fail rcs3-5 "${testcvs} log -s nostate first-dir/file1" \
d13813 2
a13814 4
	  cd first-dir
	  dotest_fail rcs3-5a "${testcvs} log -s nostate file1" \
"${DOTSTAR}ssertion.*failed${DOTSTAR}" "${DOTSTAR}failed assertion${DOTSTAR}"
	  cd ..
d13822 1
a13822 1
	  ${AWK} </dev/null 'BEGIN { printf "@@%c", 10 }' | ${TR} '@@' '\000' \
a13884 1
	  dotest lockfiles-9 "${testcvs} -q co -l ." ""
d14102 1
a14102 1
DATADIRS=\`find . -name CVS -print\`
d14104 1
a14104 1
find . -name CVS -print | xargs rm -rf
a14206 2
O3396c677|anonymous|<remote>/src|ccvs||src
O3397c677|kingdon|<remote>/*0|ccvs||ccvs
a14207 1
M339cafff|anonymous|<remote>|ccvs/src|1.23|Makefile
d14214 29
a14242 63
"O 1997-06-04 19:48 ${PLUS}0000 anonymous ccvs     =ccvs= <remote>/\*
O 1997-06-05 14:00 ${PLUS}0000 anonymous ccvs     =src=  <remote>/\*
M 1997-06-10 01:38 ${PLUS}0000 anonymous 1\.23  Makefile    ccvs/src == <remote>
W 1997-06-17 19:51 ${PLUS}0000 anonymous       Makefile\.in ccvs/emx == <remote>/emx
O 1997-06-06 08:12 ${PLUS}0000 kingdon   ccvs     =ccvs= <remote>/\*
M 1997-06-10 21:12 ${PLUS}0000 kingdon   1\.231 sanity\.sh   ccvs/src == ~/work/ccvs/src
C 2001-06-10 11:51 ${PLUS}0000 kingdon   1\.3   README      ccvs/emx == <remote>
M 2001-06-10 17:33 ${PLUS}0000 kingdon   1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc
M 1997-06-10 01:36 ${PLUS}0000 nk        1\.229 sanity\.sh   ccvs/src == <remote>"

	  dotest history-2 "${testcvs} history -e -a -D '10 Jun 1997 13:00 UT'" \
"W 1997-06-17 19:51 ${PLUS}0000 anonymous       Makefile\.in ccvs/emx == <remote>/emx
M 1997-06-10 21:12 ${PLUS}0000 kingdon   1\.231 sanity\.sh   ccvs/src == ~/work/ccvs/src
C 2001-06-10 11:51 ${PLUS}0000 kingdon   1\.3   README      ccvs/emx == <remote>
M 2001-06-10 17:33 ${PLUS}0000 kingdon   1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc"

	  dotest history-3 "${testcvs} history -e -a -D '10 Jun 2001 13:00 UT'" \
"M 2001-06-10 17:33 ${PLUS}0000 kingdon 1\.281 cvs\.texinfo ccvs/doc == ~/work/ccvs/doc"

	  dotest history-4 "${testcvs} history -ac sanity.sh" \
"M 1997-06-10 21:12 ${PLUS}0000 kingdon 1\.231 sanity\.sh ccvs/src == ~/work/ccvs/src
M 1997-06-10 01:36 ${PLUS}0000 nk      1\.229 sanity\.sh ccvs/src == <remote>"

	  dotest history-5 "${testcvs} history -a -xCGUWAMR README sanity.sh" \
"M 1997-06-10 21:12 ${PLUS}0000 kingdon 1\.231 sanity\.sh ccvs/src == ~/work/ccvs/src
C 2001-06-10 11:51 ${PLUS}0000 kingdon 1\.3   README    ccvs/emx == <remote>
M 1997-06-10 01:36 ${PLUS}0000 nk      1\.229 sanity\.sh ccvs/src == <remote>"

	  dotest history-6 "${testcvs} history -xCGUWAMR -a -f README -f sanity.sh" \
"M 1997-06-10 21:12 ${PLUS}0000 kingdon 1\.231 sanity\.sh ccvs/src == ~/work/ccvs/src
C 2001-06-10 11:51 ${PLUS}0000 kingdon 1\.3   README    ccvs/emx == <remote>
M 1997-06-10 01:36 ${PLUS}0000 nk      1\.229 sanity\.sh ccvs/src == <remote>"

	  dotest history-7 "${testcvs} history -xCGUWAMR -a -f sanity.sh README" \
"M 1997-06-10 21:12 ${PLUS}0000 kingdon 1\.231 sanity\.sh ccvs/src == ~/work/ccvs/src
C 2001-06-10 11:51 ${PLUS}0000 kingdon 1\.3   README    ccvs/emx == <remote>
M 1997-06-10 01:36 ${PLUS}0000 nk      1\.229 sanity\.sh ccvs/src == <remote>"

	  dotest history-8 "${testcvs} history -ca -D '1970-01-01 00:00 UT'" \
"M 1997-06-10 01:36 ${PLUS}0000 nk        1\.229 sanity.sh   ccvs/src == <remote>
M 1997-06-10 01:38 ${PLUS}0000 anonymous 1\.23  Makefile    ccvs/src == <remote>
M 1997-06-10 21:12 ${PLUS}0000 kingdon   1\.231 sanity.sh   ccvs/src == ~/work/ccvs/src
M 2001-06-10 17:33 ${PLUS}0000 kingdon   1\.281 cvs.texinfo ccvs/doc == ~/work/ccvs/doc"

	  dotest history-9 "${testcvs} history -acl" \
"M 2001-06-10 17:33 ${PLUS}0000 kingdon   1\.281 cvs.texinfo ccvs/doc == ~/work/ccvs/doc
M 1997-06-10 01:38 ${PLUS}0000 anonymous 1\.23  Makefile    ccvs/src == <remote>
M 1997-06-10 21:12 ${PLUS}0000 kingdon   1\.231 sanity.sh   ccvs/src == ~/work/ccvs/src"

	  dotest history-10 "${testcvs} history -lca -D '1970-01-01 00:00 UT'" \
"M 2001-06-10 17:33 ${PLUS}0000 kingdon   1\.281 cvs.texinfo ccvs/doc == ~/work/ccvs/doc
M 1997-06-10 01:38 ${PLUS}0000 anonymous 1\.23  Makefile    ccvs/src == <remote>
M 1997-06-10 21:12 ${PLUS}0000 kingdon   1\.231 sanity.sh   ccvs/src == ~/work/ccvs/src"

	  dotest history-11 "${testcvs} history -aw" \
"O 1997-06-04 19:48 ${PLUS}0000 anonymous ccvs =ccvs= <remote>/\*
O 1997-06-05 14:00 ${PLUS}0000 anonymous ccvs =src=  <remote>/\*
O 1997-06-06 08:12 ${PLUS}0000 kingdon   ccvs =ccvs= <remote>/\*"

	  dotest history-12 "${testcvs} history -aw -D'1970-01-01 00:00 UT'" \
"O 1997-06-04 19:48 ${PLUS}0000 anonymous ccvs =ccvs= <remote>/\*
O 1997-06-05 14:00 ${PLUS}0000 anonymous ccvs =src=  <remote>/\*
O 1997-06-06 08:12 ${PLUS}0000 kingdon   ccvs =ccvs= <remote>/\*"
d14484 1
a14484 1
	  dotest modes3-1 "${testcvs} -q co -l ." ''
d14486 1
a14486 1
	  dotest modes3-2 "${testcvs} add first-dir second-dir" \
d14490 1
a14490 1
	  dotest modes3-3 "${testcvs} add first-dir/aa second-dir/ab" \
d14494 1
a14494 1
	  dotest modes3-4 "${testcvs} -q ci -m add" \
d14508 1
a14508 1
	  dotest modes3-5 "${testcvs} update" \
d14520 1
a14520 1
	  dotest modes3-6 "${testcvs} update -dP" \
d15473 1
a15473 1
	  ${AWK} 'BEGIN { printf "%c%c%c%sRevision: 1.1 $@@%c%c", \
d15475 1
a15475 1
	    </dev/null | ${TR} '@@' '\000' >../binfile.dat
d15580 2
a15581 2
	  ${AWK} 'BEGIN { printf "%c%c%c@@%c%c", 2, 10, 137, 13, 10 }' \
	    </dev/null | ${TR} '@@' '\000' >>binfile.dat
d15854 22
a15875 3
	  dotest tagdate-14 "${testcvs} -q export -r br2 -D'1 minute ago' first-dir" \
"[UP] first-dir/file1"
	  dotest tagdate-15 "cat first-dir/file1" "br2-1"
d15879 3
a15881 1
	  dotest tagdate-16 "${testcvs} annotate -rbr2 -D'1 minute ago'" \
d15884 15
a15898 1
1\.1\.4\.1      (${username} *[0-9a-zA-Z-]*): br2-1"
d15911 1
d16455 2
a16456 4
	  fi # end of tests skipped for remote

	  # Now test that plain -e works right.
	  dotest admin-19a-2 "${testcvs} -q admin -e file1" \
d16459 1
a16459 10
	  dotest admin-19a-3 "${testcvs} -q log -h -N file1" "
RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
Working file: file1
head: 1\.1
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 2
============================================================================="
d16461 4
a16464 4
	  # Put the access list back, to avoid special cases later.
	  dotest admin-19a-4 "${testcvs} -q admin -afoo,auth2 file1" \
"RCS file: ${TESTDIR}/cvsroot/first-dir/file1,v
done"
d17023 1
a17023 1
line=\`grep <\$1/\$2,v 'locks ${author}:1\.[0-9];'\`
d17028 2
a17029 2
  user=\`echo \$line | sed -e 's/locks \\(${author}\\):[0-9.]*;.*/\\1/'\`
  version=\`echo \$line | sed -e 's/locks ${author}:\\([0-9.]*\\);.*/\\1/'\`
d19482 1
a19482 1
"${PROG} [a-z]*: failed to create lock directory for .${TESTDIR}/root1/dir2' (${TESTDIR}/root1/dir2/#cvs.lock): No such file or directory
d19503 1
a19503 31
	  # make sure we can't access across repositories
	  # FIXCVS: we probably shouldn't even create the local directories
	  # in this case, but we do, so deal with it.
	  mkdir 1a
	  cd 1a
	  dotest_fail multiroot3-12 \
"${testcvs} -d ${CVSROOT1} -q co ../root2/dir2" \
"${PROG} [a-z]*: in directory \.\./root2/dir2:
${PROG} [a-z]*: .\.\..-relative repositories are not supported.
${PROG} \[[a-z]* aborted\]: illegal source repository"
	  rm -rf ../root2
	  dotest_fail multiroot3-13 \
"${testcvs} -d ${CVSROOT2} -q co ../root1/dir1" \
"${PROG} [a-z]*: in directory \.\./root1/dir1:
${PROG} [a-z]*: .\.\..-relative repositories are not supported.
${PROG} \[[a-z]* aborted\]: illegal source repository"
	  rm -rf ../root1
	  dotest_fail multiroot3-14 \
"${testcvs} -d ${CVSROOT1} -q co ./../root2/dir2" \
"${PROG} [a-z]*: in directory \./\.\./root2/dir2:
${PROG} [a-z]*: .\.\..-relative repositories are not supported.
${PROG} \[[a-z]* aborted\]: illegal source repository"
	  rm -rf ../root2
	  dotest_fail multiroot3-15 \
"${testcvs} -d ${CVSROOT2} -q co ./../root1/dir1" \
"${PROG} [a-z]*: in directory \./\.\./root1/dir1:
${PROG} [a-z]*: .\.\..-relative repositories are not supported.
${PROG} \[[a-z]* aborted\]: illegal source repository"
	  rm -rf ../root1

	  cd ../..
d19736 1
a19736 1
   	    # First set SystemAuth=no.  Not really necessary, I don't
d19749 3
a19751 8
	    cat >${CVSROOT_DIRNAME}/CVSROOT/passwd <<EOF
testme:q6WV9d2t848B2:$username
anonymous::$username
$username:
willfail:   :whocares
EOF
	    dotest_fail pserver-3 "${testcvs} pserver" \
"error 0 Server configuration missing --allow-root in inetd.conf" <<EOF
d19758 2
d19764 1
a19764 3
	    dotest pserver-4 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU
ok" <<EOF
d19773 3
d19777 1
a19777 4
	    dotest pserver-5 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU
E Protocol error: Root says \"${TESTDIR}/1\" but pserver says \"${CVSROOT_DIRNAME}\"
error  " <<EOF
d19786 4
d19791 1
a19791 2
	    dotest_fail pserver-6 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"I HATE YOU" <<EOF
d19798 2
d19801 1
a19801 2
	    dotest_fail pserver-7 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"I HATE YOU" <<EOF
d19808 2
d19811 1
a19811 2
	    dotest pserver-8 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU" <<EOF
d19818 2
a19819 52

# Tests pserver-9 through pserver-13 are about empty passwords

            # Test empty password (both sides) for aliased user
	    dotest pserver-9 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU" <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
anonymous
A
END AUTH REQUEST
EOF

            # Test empty password (server side only) for aliased user
	    dotest pserver-10 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU" <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
anonymous
Aanythingwouldworkhereittrulydoesnotmatter
END AUTH REQUEST
EOF

            # Test empty (both sides) password for non-aliased user
	    dotest pserver-11 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU" <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
${username}
A
END AUTH REQUEST
EOF

            # Test empty (server side only) password for non-aliased user
	    dotest pserver-12 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} LOVE YOU" <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
${username}
Anypasswordwouldworkwhynotthisonethen
END AUTH REQUEST
EOF

            # Test failure of whitespace password
	    dotest_fail pserver-13 "${testcvs} --allow-root=${CVSROOT_DIRNAME} pserver" \
"${DOTSTAR} HATE YOU" <<EOF
BEGIN AUTH REQUEST
${CVSROOT_DIRNAME}
willfail
Amquiteunabletocomeupwithinterestingpasswordsanymore
END AUTH REQUEST
EOF
d19838 1
a19838 3
	    dotest server-1 "${testcvs} server" \
"E Protocol error: Root request missing
error  " <<EOF
d19843 7
d19853 1
a19853 1
	    dotest server-2 "${testcvs} server" "ok" <<EOF
d19858 5
d19866 1
a19866 1
	    ${AWK} 'BEGIN { \
d19869 1
a19869 1
	      </dev/null | ${TR} '\100' '\000' >gzipped.dat
d19890 2
a19891 2
	    dotest server-4 "${testcvs} server" \
"M N dir1/file1
d19895 5
a19899 1
ok" <session.dat
d19904 1
a19904 4
	    dotest server-6 "${testcvs} server" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok" <<EOF
d19912 8
d19923 1
a19923 7
	    dotest server-7 "${testcvs} server" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok
Notified \./
${TESTDIR}/crerepos/dir1/file1
ok" <<EOF
d19934 11
d19947 1
a19947 6
	    # FIXCVS: should give "error" and no "Notified", like server-9
	    dotest server-8 "${testcvs} server" \
"E ${PROG} server: invalid character in editor value
Notified \./
${TESTDIR}/crerepos/dir1/file1
ok" <<EOF
d19955 10
d19966 1
a19966 3
	    dotest server-9 "${testcvs} server" \
"E Protocol error; misformed Notify request
error  " <<EOF
d19974 7
d19987 1
a19987 1
	    dotest server-10 "${testcvs} server" "ok" <<EOF
d19993 7
d20001 1
a20001 3
	    dotest server-11 "${testcvs} server" \
"M file1	${username}	tedit	tunedit	tcommit
ok" <<EOF
d20008 8
a20015 3
	    dotest server-12 "${testcvs} server" \
"M file1	${username}	The 57th day of Discord in the YOLD 3165	myhost	some-work-dir
ok" <<EOF
d20022 7
d20031 1
a20031 4
	    dotest server-13 "${testcvs} server" \
"Notified \./
${TESTDIR}/crerepos/dir1/file1
ok" <<EOF
d20039 8
d20049 1
a20049 1
	    dotest server-14 "${testcvs} server" "ok" <<EOF
d20055 7
a20061 1
	    dotest server-15 "${testcvs} server" "ok" <<EOF
d20067 6
d20081 1
d20089 1
a20089 3
	    dotest server2-1 "${testcvs} server" \
"E protocol error: directory '${TESTDIR}/cvsroot/\.\./dir1' not within root '${TESTDIR}/cvsroot'
error  " <<EOF
d20095 7
d20103 1
a20103 3
	    dotest server2-2 "${testcvs} server" \
"E protocol error: directory '${TESTDIR}/cvsrootdir1' not within root '${TESTDIR}/cvsroot'
error  " <<EOF
d20109 7
d20117 1
a20117 3
	    dotest 2-3 "${testcvs} server" \
"E protocol error: directory '${TESTDIR}' not within root '${TESTDIR}/cvsroot'
error  " <<EOF
d20123 7
d20135 1
a20135 3
	    dotest server2-4 "${testcvs} server" \
"E protocol error: directory 'foo/bar' not within current directory
error  " <<EOF
d20142 7
d20178 1
a20178 1
"${PROG} \[checkout aborted\]: This server does not support the global -q option${DOTSTAR}"
a20199 2
	    # The ${DOTSTAR} is to match a potential "broken pipe" if the
	    # client exits before the server script sends everything
d20201 1
a20201 1
${PROG} \[update aborted\]: protocol error: Copy-file tried to specify director${DOTSTAR}"
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@d21 4
a24 12
# usage:
exit_usage ()
{
    echo "Usage: `basename $0` [-kr] [-f FROM-TEST] CVS-TO-TEST [TESTS-TO-RUN...]" 1>&2
    exit 2
}
# -r		test remote instead of local cvs.
# -k 		try to keep directories created by individual tests around
# -f FROM-TEST	run TESTS-TO-RUN, skipping all tests in the list before
#		FROM-TEST
#
# TESTS-TO-RUN are the names of the tests to run; if omitted default to all tests.
d40 23
d64 6
d71 11
a81 32
#
# read our options
#
unset fromtest
keep=false
remote=false
while getopts f:kr option ; do
    case "$option" in
	f)
	    fromtest="$OPTARG"
	    ;;
	k)
	    # The -k (keep) option will eventually cause all the tests to leave around the
	    # contents of the /tmp directory; right now only some implement it.  Not
	    # originally intended to be useful with more than one test, but this should work
	    # if each test uses a uniquely named dir (use the name of the test).
	    keep=:
	    ;;
	r)
	    remote=:
	    ;;
	\?)
	    exit_usage
	    ;;
    esac
done

# boot the arguments we used above
while test $OPTIND -gt 1 ; do
    shift
    OPTIND=`expr $OPTIND - 1`
done
d87 2
a88 1
  exit_usage
d97 1
a99 11


###
### GUTS
###

# "debugger"
#set -x

echo 'This test should produce no other output than this line, and a final "OK".'

a110 1
hostname="[-_.a-zA-Z0-9]*"
a115 4
# Regexp to match a date in RFC822 format (as amended by RFC1123).
RFCDATE="[a-zA-Z0-9 ][a-zA-Z0-9 ]* [0-9:][0-9:]* -0000"
RFCDATE_EPOCH="1 Jan 1970 00:00:00 -0000"

d117 1
a117 1
if test -r /bin/sh; then
d121 1
a121 1
  if test ! -r "$TESTSHELL"; then
a143 25
# The default value of /tmp/cvs-sanity for TESTDIR is dubious,
# because it loses if two people/scripts try to run the tests
# at the same time.  Some possible solutions:
# 1.  Use /tmp/cvs-test$$.  One disadvantage is that the old
#     cvs-test* directories would pile up, because they wouldn't
#     necessarily get removed.
# 2.  Have everyone/everything running the testsuite set
#     TESTDIR to some appropriate directory.
# 3.  Have the default value of TESTDIR be some variation of
#     `pwd`/cvs-sanity.  The biggest problem here is that we have
#     been fairly careful to test that CVS prints in messages the
#     actual pathnames that we pass to it, rather than a different
#     pathname for the same directory, as may come out of `pwd`.
#     So this would be lost if everything was `pwd`-based.  I suppose
#     if we wanted to get baroque we could start making symlinks
#     to ensure the two are different.
tmp=`(cd /tmp; /bin/pwd || pwd) 2>/dev/null`

# Now:
#	1) Set TESTDIR if it's not set already
#	2) Remove any old test remnants
#	3) Create $TESTDIR
#	4) Normalize TESTDIR with `cd && (/bin/pwd || pwd)`
#	   (This will match CVS output later)
: ${TESTDIR=$tmp/cvs-sanity}
d150 1
a150 11
# These exits are important.  The first time I tried this, if the `mkdir && cd`
# failed then the build directory would get blown away.  Some people probably
# wouldn't appreciate that.
mkdir ${TESTDIR} || exit 1
cd ${TESTDIR} || exit 1
TESTDIR=`(/bin/pwd || pwd) 2>/dev/null`
# Ensure $TESTDIR is absolute
if test -z "${TESTDIR}" || echo "${TESTDIR}" |grep '^[^/]'; then
    echo "Unable to resolve TESTDIR to an absolute directory." >&2
    exit 1
fi
d162 1
a162 1
  GLOCS="`echo $PATH | sed 's/:/ /g'` /usr/local/bin /usr/contrib/bin /usr/gnu/bin /local/bin /local/gnu/bin /gnu/bin"
d166 1
a166 2
      RES="`$path/g$1 --version </dev/null 2>/dev/null`"
      if test "X$RES" != "X--version" && test "X$RES" != "X" ; then
d172 1
a172 2
      RES="`$path/$1 --version </dev/null 2>/dev/null`"
      if test "X$RES" != "X--version" && test "X$RES" != "X" ; then
d181 2
a182 2
    echo "Notice: The default version of \`$1' is defective, using" >&2
    echo "\`$TOOL' instead." >&2
d189 12
a200 7
#
# FIXME - find_tool() finds the 'gid' from GNU id-utils if I pull 'id' out of
# my path.
for pass in false :; do
  case "`$ID -u 2>/dev/null`" in
    "0")
      echo "Test suite does not work correctly when run as root" >&2
d202 3
a204 19
      ;;

    "")
      if $pass; then :; else
	ID=`find_tool id`
      fi
      if $pass || test -z "$ID" ; then
	echo "Running these tests requires an \`id' program that understands the" >&2
	echo "-u and -n flags.  Make sure that such an id (GNU, or many but not" >&2
	echo "all vendor-supplied versions) is in your path." >&2
	exit 1
      fi
      ;;

    *)
      break
      ;;
  esac
done
d272 1
a301 15
# Now that we have DOTSTAR, make sure it works with big matches
if $EXPR "`cat ${TESTDIR}/bar`" : "${DOTSTAR}xyzABC${DOTSTAR}$" >/dev/null; then
  : good, it works
else
  EXPR=`find_tool expr`
  if test -z "$EXPR" ; then
    echo 'Warning: you are using a version of expr which does not correctly'
    echo 'match large patterns.  Some tests may spuriously fail.'
    echo 'You may wish to make sure GNU expr is in your path.'
    EXPR=expr
  fi
fi

rm -f ${TESTDIR}/foo ${TESTDIR}/bar

a352 13
  if $EXPR "`cat ${TESTDIR}/dotest.tmp`" : "$3${ENDANCHOR}" >/dev/null; then
    # Why, I hear you ask, do we write this to the logfile
    # even when the test passes?  The reason is that the test
    # may give us the regexp which we were supposed to match,
    # but sometimes it may be useful to look at the exact
    # text which was output.  For example, suppose one wants
    # to grep for a particular warning, and make _sure_ that
    # CVS never hits it (even in cases where the tests might
    # match it with .*).  Or suppose one wants to see the exact
    # date format output in a certain case (where the test will
    # surely use a somewhat non-specific pattern).
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    pass "$1"
d355 21
a375 4
  elif test -z "$3" && test ! -s ${TESTDIR}/dotest.tmp; then
    pass "$1"
  elif test x"$4" != x; then
    if $EXPR "`cat ${TESTDIR}/dotest.tmp`" : "$4${ENDANCHOR}" >/dev/null; then
d379 34
a412 9
      echo "** expected: " >>${LOGFILE}
      echo "$3" >>${LOGFILE}
      echo "$3" > ${TESTDIR}/dotest.ex1
      echo "** or: " >>${LOGFILE}
      echo "$4" >>${LOGFILE}
      echo "$4" > ${TESTDIR}/dotest.ex2
      echo "** got: " >>${LOGFILE}
      cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
      fail "$1"
a413 7
  else
    echo "** expected: " >>${LOGFILE}
    echo "$3" >>${LOGFILE}
    echo "$3" > ${TESTDIR}/dotest.exp
    echo "** got: " >>${LOGFILE}
    cat ${TESTDIR}/dotest.tmp >>${LOGFILE}
    fail "$1"
a434 3
    elif test -z "`sed -n ${line}p ${TESTDIR}/dotest.tmp`" &&
       test -z "`sed -n ${line}p ${TESTDIR}/dotest.exp`"; then
      :
d515 4
a518 3
  eval "$2" >${TESTDIR}/dotest.tmp 2>&1
  status=$?
  if test "$status" != 0; then
d530 4
a533 3
  eval "$2" >${TESTDIR}/dotest.tmp 2>&1
  status=$?
  if test "$status" != 0; then
d554 2
a555 3
  eval "$2" >${TESTDIR}/dotest.tmp 2>&1
  status=$?
  if test "$status" = 0; then
d559 4
a562 1
  fi
d571 3
a573 1
  if test "$status" != "$2"; then
d585 4
a588 3
  eval "$2" >${TESTDIR}/dotest.tmp1 2>&1
  status=$?
  if test "$status" != 0; then
d597 15
d630 1
a630 1
	tests="version basica basicb basicc basic1 deep basic2"
d633 2
a634 2
	tests="${tests} rdiff diff death death2 rm-update-message rmadd rmadd2"
	tests="${tests} dirs dirs2 branches branches2 tagc tagf"
d637 1
a637 2
	tests="${tests} join join2 join3 join-readonly-conflict"
	tests="${tests} join-admin join-admin-2"
d645 1
a645 1
	tests="${tests} mflag editor errmsg1 errmsg2 adderrmsg"
d649 1
a649 1
	tests="${tests} ignore ignore-on-branch binfiles binfiles2 binfiles3"
a672 1
	tests="${tests} fork"
d679 2
a680 1
# Returns: 0 for same, 1 for different
d687 1
d701 2
a702 1
		return 1
d710 1
a710 1
				return 1
a714 1
	return 0
d717 13
d731 2
d734 7
a740 9
#
# The following 4 functions are used by the diffmerge1 test case.  They set up,
# respectively, the four versions of the files necessary:
#
#	1.  Ancestor revisions.
#	2.  "Your" changes.
#	3.  "My" changes.
#	4.  Expected merge result.
#
d742 12
a753 5
# Create ancestor revisions for diffmerge1
diffmerge_create_older_files() {
	  # This test case was supplied by Noah Friedman:
	  cat >testcase01 <<EOF
// Button.java
d755 2
a756 1
package random.application;
d758 5
a762 1
import random.util.*;
d764 17
a780 8
public class Button
{
  /* Instantiates a Button with origin (0, 0) and zero width and height.
   * You must call an initializer method to properly initialize the Button.
   */
  public Button ()
  {
    super ();
d782 9
a790 4
    _titleColor = Color.black;
    _disabledTitleColor = Color.gray;
    _titleFont = Font.defaultFont ();
  }
d792 20
a811 12
  /* Convenience constructor for instantiating a Button with
   * bounds x, y, width, and height.  Equivalent to
   *     foo = new Button ();
   *     foo.init (x, y, width, height);
   */
  public Button (int x, int y, int width, int height)
  {
    this ();
    init (x, y, width, height);
  }
}
EOF
d813 12
a824 897
	  # This test case was supplied by Jacob Burckhardt:
	  cat >testcase02 <<EOF
a
a
a
a
a
EOF

	  # This test case was supplied by Karl Tomlinson who also wrote the
	  # patch which lets CVS correctly handle this and several other cases:
	  cat >testcase03 <<EOF
x
s
a
b
s
y
EOF

	  # This test case was supplied by Karl Tomlinson:
	  cat >testcase04 <<EOF
s
x
m
m
x
s
v
s
x
m
m
x
s
EOF

	  # This test case was supplied by Karl Tomlinson:
	  cat >testcase05 <<EOF
s
x
m
m
x
x
x
x
x
x
x
x
x
x
s
s
s
s
s
s
s
s
s
s
v
EOF

	  # This test case was supplied by Jacob Burckhardt:
	  cat >testcase06 <<EOF
g











i
EOF

	  # This test is supposed to verify that the horizon lines are the same
	  # for both 2-way diffs, but unfortunately, it does not fail with the
	  # old version of cvs.  However, Karl Tomlinson still thought it would
	  # be good to test it anyway:
	  cat >testcase07 <<EOF
h
f









g
r



i










i
EOF

	  # This test case was supplied by Jacob Burckhardt:
	  cat >testcase08 <<EOF
Both changes move this line to the end of the file.

no
changes
here

First change will delete this line.

First change will also delete this line.

    no
    changes
    here

Second change will change it here.

        no
        changes
        here
EOF

	  # This test case was supplied by Jacob Burckhardt.  Note that I do not
	  # think cvs has ever failed with this case, but I include it anyway,
	  # since I think it is a hard case.  It is hard because Peter Miller's
	  # fmerge utility fails on it:
	  cat >testcase09 <<EOF
m
a
{
}
b
{
}
EOF

	  # This test case was supplied by Martin Dorey and simplified by Jacob
	  # Burckhardt:
	  cat >testcase10 <<EOF

    petRpY ( MtatRk );
    fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

    MtatRk = MQfr_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_KRLIep * jfle_Uecopd_MfJe_fY_nEtek );
    OjZy MtatRk = Uead_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_MfJe_fY_nEtek, nRVVep );

    Bloke_GttpfIRte_MtpeaL ( &acI );
MTGTXM Uead_Ktz_qjT_jfle_Uecopd ( fYt Y, uofd *nRVVep )
{
    fV ( Y < 16 )
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                      Y * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }
    elke
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtqfppHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                 ( Y - 16 ) * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }

}


/****************************************************************************
*                                                                           *
*   Uead Mectopk ( Uelatfue to tze cRppeYt raptftfoY )                      *
*                                                                           *
****************************************************************************/

MTGTXM Uead_Mectopk ( RfYt64 Mtapt_Mectop, RfYt64 KRL_Mectopk, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    MtatRk = Uead_HfkQ ( FaptftfoY_TaIle.Uelatfue_Mectop + Mtapt_Mectop, KRL_Mectopk, nRVVep );

    petRpY ( MtatRk );

}
    HfkQipfte ( waYdle,                 /*  waYdle                         */
                waYdleFok,              /*  ZVVket VpoL ktapt oV dfkQ      */
                (coYkt RfYt8*) nRVVep,  /*  nRVVep                         */
                0,                      /*  MRrepVlRoRk KfxoYfkL           */
                beYgtz                  /*  nEtek to Apfte                 */
              );

    petRpY ( Zy );
}
EOF
}

# Create "your" revisions for diffmerge1
diffmerge_create_your_files() {
	  # remove the Button() method
	  cat >testcase01 <<\EOF
// Button.java

package random.application;

import random.util.*;

public class Button
{
  /* Instantiates a Button with origin (0, 0) and zero width and height.
   * You must call an initializer method to properly initialize the Button.
   */
  public Button ()
  {
    super ();

    _titleColor = Color.black;
    _disabledTitleColor = Color.gray;
    _titleFont = Font.defaultFont ();
  }
}
EOF

	  cat >testcase02 <<\EOF
y
a
a
a
a
EOF

	  cat >testcase03 <<\EOF
x
s
a
b
s
b
s
y
EOF

	  cat >testcase04 <<\EOF
s
m
s
v
s
m
s
EOF

	  cat >testcase05 <<\EOF
v
s
m
s
s
s
s
s
s
s
s
s
s
v
EOF

	  # Test case 6 and test case 7 both use the same input files, but they
	  # order the input files differently.  In one case, a certain file is
	  # used as the older file, but in the other test case, that same file
	  # is used as the file which has changes.  I could have put echo
	  # commands here, but since the echo lines would be the same as those
	  # in the previous function, I decided to save space and avoid repeating
	  # several lines of code.  Instead, I merely swap the files:
	  mv testcase07 tmp
	  mv testcase06 testcase07
	  mv tmp testcase06

	  # Make the date newer so that cvs thinks that the files are changed:
	  touch testcase06 testcase07

	  cat >testcase08 <<\EOF
no
changes
here

First change has now added this in.

    no
    changes
    here

Second change will change it here.

        no
        changes
        here

Both changes move this line to the end of the file.
EOF

	  cat >testcase09 <<\EOF

m
a
{
}
b
{
}
c
{
}
EOF

	  cat >testcase10 <<\EOF

    fV ( BzQkV_URYYfYg ) (*jfle_Uecopdk)[0].jfle_Uecopd_KRLIep = ZpfgfYal_jUK;

    petRpY ( MtatRk );
    fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

    fV ( jfle_Uecopd_KRLIep < 16 )
    {
        MtatRk = Uead_Ktz_qjT_jfle_Uecopd ( jfle_Uecopd_KRLIep, (uofd*)nRVVep );
    }
    elke
    {
        MtatRk = ZreY_GttpfIRte_MtpeaL ( qjT_jfle_Uecopdk, qjT_jfle_Uecopd_BoRYt, HGTG_TvFD, KXbb, KXbb, &acI );
        fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

        MtatRk = MQfr_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_KRLIep * jfle_Uecopd_MfJe_fY_nEtek );
        OjZy MtatRk = Uead_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_MfJe_fY_nEtek, nRVVep );

    Bloke_GttpfIRte_MtpeaL ( &acI );
MTGTXM Uead_Ktz_qjT_jfle_Uecopd ( fYt Y, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    fV ( Y < 16 )
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                      Y * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }
    elke
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtqfppHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                 ( Y - 16 ) * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }

    petRpY ( MtatRk );

}


/****************************************************************************
*                                                                           *
*   Uead Mectopk ( Uelatfue to tze cRppeYt raptftfoY )                      *
*                                                                           *
****************************************************************************/

MTGTXM Uead_Mectopk ( RfYt64 Mtapt_Mectop, RfYt64 KRL_Mectopk, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    MtatRk = Uead_HfkQ ( FaptftfoY_TaIle.Uelatfue_Mectop + Mtapt_Mectop, KRL_Mectopk, nRVVep );

    petRpY ( MtatRk );

}
    HfkQipfte ( waYdle,                 /*  waYdle                         */
                waYdleFok,              /*  ZVVket VpoL ktapt oV dfkQ      */
                (coYkt RfYt8*) nRVVep,  /*  nRVVep                         */
                0,                      /*  MRrepVlRoRk KfxoYfkL           */
                beYgtz                  /*  nEtek to Apfte                 */
              );

    petRpY ( Zy );
}

EOF
}

# Create "my" revisions for diffmerge1
diffmerge_create_my_files() {
          # My working copy still has the Button() method, but I
	  # comment out some code at the top of the class.
	  cat >testcase01 <<\EOF
// Button.java

package random.application;

import random.util.*;

public class Button
{
  /* Instantiates a Button with origin (0, 0) and zero width and height.
   * You must call an initializer method to properly initialize the Button.
   */
  public Button ()
  {
    super ();

    // _titleColor = Color.black;
    // _disabledTitleColor = Color.gray;
    // _titleFont = Font.defaultFont ();
  }

  /* Convenience constructor for instantiating a Button with
   * bounds x, y, width, and height.  Equivalent to
   *     foo = new Button ();
   *     foo.init (x, y, width, height);
   */
  public Button (int x, int y, int width, int height)
  {
    this ();
    init (x, y, width, height);
  }
}
EOF

	  cat >testcase02 <<\EOF
a
a
a
a
m
EOF

	  cat >testcase03 <<\EOF
x
s
c
s
b
s
y
EOF

	  cat >testcase04 <<\EOF
v
s
x
m
m
x
s
v
s
x
m
m
x
s
v
EOF

	  # Note that in test case 5, there are no changes in the "mine"
	  # section, which explains why there is no command here which writes to
	  # file testcase05.

	  # no changes for testcase06

	  # The two branches make the same changes:
	  cp ../yours/testcase07 .

	  cat >testcase08 <<\EOF
no
changes
here

First change will delete this line.

First change will also delete this line.

    no
    changes
    here

Second change has now changed it here.

        no
        changes
        here

Both changes move this line to the end of the file.
EOF

	  cat >testcase09 <<\EOF
m
a
{
}
b
{
}
c
{
}
EOF

	  cat >testcase10 <<\EOF

    petRpY ( MtatRk );
    fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

    MtatRk = MQfr_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_KRLIep * jfle_Uecopd_MfJe_fY_nEtek );
    OjZy MtatRk = Uead_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_MfJe_fY_nEtek, nRVVep );

    Bloke_GttpfIRte_MtpeaL ( &acI );
MTGTXM Uead_Ktz_qjT_jfle_Uecopd ( fYt Y, uofd *nRVVep )
{
    fV ( Y < 16 )
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                      Y * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }
    elke
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtqfppHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                 ( Y - 16 ) * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }

}


/****************************************************************************
*                                                                           *
*   Uead Mectopk ( Uelatfue to tze cRppeYt raptftfoY )                      *
*                                                                           *
****************************************************************************/

MTGTXM Uead_Mectopk ( RfYt64 Mtapt_Mectop, RfYt64 KRL_Mectopk, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    MtatRk = Uead_HfkQ ( FaptftfoY_TaIle.Uelatfue_Mectop + Mtapt_Mectop, KRL_Mectopk, nRVVep );

    petRpY ( MtatRk );

}
    HfkQipfte ( waYdle,                 /*  waYdle                         */
                waYdleFok,              /*  ZVVket VpoL ktapt oV dfkQ      */
                (coYkt RfYt8*) nRVVep,  /*  nRVVep                         */
                beYgtz                  /*  nEtek to Apfte                 */
              );

    petRpY ( Zy );
}

EOF
}

# Create expected results of merge for diffmerge1
diffmerge_create_expected_files() {
	  cat >testcase01 <<\EOF
// Button.java

package random.application;

import random.util.*;

public class Button
{
  /* Instantiates a Button with origin (0, 0) and zero width and height.
   * You must call an initializer method to properly initialize the Button.
   */
  public Button ()
  {
    super ();

    // _titleColor = Color.black;
    // _disabledTitleColor = Color.gray;
    // _titleFont = Font.defaultFont ();
  }
}
EOF

	  cat >testcase02 <<\EOF
y
a
a
a
m
EOF

	  cat >testcase03 <<\EOF
x
s
c
s
b
s
b
s
y
EOF

	  cat >testcase04 <<\EOF
v
s
m
s
v
s
m
s
v
EOF

	  # Since there are no changes in the "mine" section, just take exactly
	  # the version in the "yours" section:
	  cp ../yours/testcase05 .

	  cp ../yours/testcase06 .

	  # Since the two branches make the same changes, the result should be
	  # the same as both branches.  Here, I happen to pick yours to copy from,
	  # but I could have also picked mine, since the source of the copy is
	  # the same in either case.  However, the mine has already been
	  # altered by the update command, so don't use it.  Instead, use the
	  # yours section which has not had an update on it and so is unchanged:
	  cp ../yours/testcase07 .

	  cat >testcase08 <<\EOF
no
changes
here

First change has now added this in.

    no
    changes
    here

Second change has now changed it here.

        no
        changes
        here

Both changes move this line to the end of the file.
EOF

	  cat >testcase09 <<\EOF

m
a
{
}
b
{
}
c
{
}
EOF

	  cat >testcase10 <<\EOF

    fV ( BzQkV_URYYfYg ) (*jfle_Uecopdk)[0].jfle_Uecopd_KRLIep = ZpfgfYal_jUK;

    petRpY ( MtatRk );
    fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

    fV ( jfle_Uecopd_KRLIep < 16 )
    {
        MtatRk = Uead_Ktz_qjT_jfle_Uecopd ( jfle_Uecopd_KRLIep, (uofd*)nRVVep );
    }
    elke
    {
        MtatRk = ZreY_GttpfIRte_MtpeaL ( qjT_jfle_Uecopdk, qjT_jfle_Uecopd_BoRYt, HGTG_TvFD, KXbb, KXbb, &acI );
        fV ( MtatRk != Zy ) UDTXUK_DUUZU ( BGKT_ZFDK_qjT_HGTG );

        MtatRk = MQfr_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_KRLIep * jfle_Uecopd_MfJe_fY_nEtek );
        OjZy MtatRk = Uead_GttpfIRte_MtpeaL ( &acI, jfle_Uecopd_MfJe_fY_nEtek, nRVVep );

    Bloke_GttpfIRte_MtpeaL ( &acI );
MTGTXM Uead_Ktz_qjT_jfle_Uecopd ( fYt Y, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    fV ( Y < 16 )
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                      Y * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }
    elke
    {
        petRpY ( Uead_Mectopk ( noot_Uecopd.qVtqfppHatabcY0 * noot_Uecopd.MectopkFepBlRktep +
                                                 ( Y - 16 ) * jfle_Uecopd_MfJe_fY_Mectopk,
                                jfle_Uecopd_MfJe_fY_Mectopk,
                                nRVVep ) );
    }

    petRpY ( MtatRk );

}


/****************************************************************************
*                                                                           *
*   Uead Mectopk ( Uelatfue to tze cRppeYt raptftfoY )                      *
*                                                                           *
****************************************************************************/

MTGTXM Uead_Mectopk ( RfYt64 Mtapt_Mectop, RfYt64 KRL_Mectopk, uofd *nRVVep )
{
MTGTXM MtatRk = Zy;

    MtatRk = Uead_HfkQ ( FaptftfoY_TaIle.Uelatfue_Mectop + Mtapt_Mectop, KRL_Mectopk, nRVVep );

    petRpY ( MtatRk );

}
    HfkQipfte ( waYdle,                 /*  waYdle                         */
                waYdleFok,              /*  ZVVket VpoL ktapt oV dfkQ      */
                (coYkt RfYt8*) nRVVep,  /*  nRVVep                         */
                beYgtz                  /*  nEtek to Apfte                 */
              );

    petRpY ( Zy );
}

EOF
}

# Set up CVSROOT (the crerepos tests will test operating without CVSROOT set).
CVSROOT_DIRNAME=${TESTDIR}/cvsroot
if $remote; then
	# Currently we test :fork: and :ext: (see crerepos test).
	# Testing :pserver: would be hard (inetd issues).
	# Also :ext: and :fork support CVS_SERVER in a convenient way.
	# If you want to edit this script to change the next line to
	# :ext:, you can run the tests that way.  There is a known
	# difference in modes-15 (see comments there).
	CVSROOT=:fork:${CVSROOT_DIRNAME} ; export CVSROOT
	CVS_SERVER=${testcvs}; export CVS_SERVER
else
	CVSROOT=${CVSROOT_DIRNAME} ; export CVSROOT
fi

dotest 1 "${testcvs} init" ''
dotest 1a "${testcvs} init" ''

### The big loop
for what in $tests; do
	if test -n "$fromtest" ; then
	    if test $fromtest = $what ; then
		unset fromtest
	    else
		continue
	    fi
	fi
	case $what in

	version)
	  # We've had cases where the version command started dumping core,
	  # so we might as well test it
	  dotest version-1 "${testcvs} --version" \
'
Concurrent Versions System (CVS) [0-9.]*.*

Copyright (c) [-0-9]* Brian Berliner, david d .zoo. zuhn, 
                        Jeff Polk, and other authors

CVS may be copied only under the terms of the GNU General Public License,
a copy of which can be found with the CVS distribution kit.

Specify the --help option for further information about CVS'

	  if $remote; then
		dotest version-2r "${testcvs} version" \
'Client: Concurrent Versions System (CVS) [0-9.]* (client/server)
Server: Concurrent Versions System (CVS) [0-9.]* (client/server)'
	  else
		dotest version-2 "${testcvs} version" \
'Concurrent Versions System (CVS) [0-9.]*.*'
	  fi
	  ;;

	basica)
	  # Similar in spirit to some of the basic1, and basic2
	  # tests, but hopefully a lot faster.  Also tests operating on
	  # files two directories down *without* operating on the parent dirs.

	  # Tests basica-0a and basica-0b provide the equivalent of the:
	  #    mkdir ${CVSROOT_DIRNAME}/first-dir
	  # used by many of the tests.  It is "more official" in the sense
	  # that is does everything through CVS; the reason most of the
	  # tests don't use it is mostly historical.
	  mkdir 1; cd 1
	  dotest basica-0a "${testcvs} -q co -l ." ''
	  mkdir first-dir
	  dotest basica-0b "${testcvs} add first-dir" \
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
	  cd ..
	  rm -r 1

	  dotest basica-1 "${testcvs} -q co first-dir" ''
	  cd first-dir

	  # Test a few operations, to ensure they gracefully do
	  # nothing in an empty directory.
	  dotest basica-1a0 "${testcvs} -q update" ''
	  dotest basica-1a1 "${testcvs} -q diff -c" ''
	  dotest basica-1a2 "${testcvs} -q status" ''

	  mkdir sdir
	  # Remote CVS gives the "cannot open CVS/Entries" error, which is
	  # clearly a bug, but not a simple one to fix.
	  dotest basica-1a10 "${testcvs} -n add sdir" \
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository" \
"${PROG} add: cannot open CVS/Entries for reading: No such file or directory
Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository"
	  dotest_fail basica-1a11 \
	    "test -d ${CVSROOT_DIRNAME}/first-dir/sdir" ''
	  dotest basica-2 "${testcvs} add sdir" \
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository"
	  cd sdir
	  mkdir ssdir
	  dotest basica-3 "${testcvs} add ssdir" \
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir added to the repository"
	  cd ssdir
	  echo ssfile >ssfile

	  # Trying to commit it without a "cvs add" should be an error.
	  # The "use `cvs add' to create an entry" message is the one
	  # that I consider to be more correct, but local cvs prints the
	  # "nothing known" message and noone has gotten around to fixing it.
	  dotest_fail basica-notadded "${testcvs} -q ci ssfile" \
"${PROG} [a-z]*: use .${PROG} add. to create an entry for ssfile
${PROG}"' \[[a-z]* aborted\]: correct above errors first!' \
"${PROG}"' [a-z]*: nothing known about `ssfile'\''
'"${PROG}"' \[[a-z]* aborted\]: correct above errors first!'

	  dotest basica-4 "${testcvs} add ssfile" \
"${PROG}"' [a-z]*: scheduling file `ssfile'\'' for addition
'"${PROG}"' [a-z]*: use .'"${PROG}"' commit. to add this file permanently'
	  dotest_fail basica-4a "${testcvs} tag tag0 ssfile" \
"${PROG} [a-z]*: nothing known about ssfile
${PROG} "'\[[a-z]* aborted\]: correct the above errors first!'
	  cd ../..
	  dotest basica-5 "${testcvs} -q ci -m add-it" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
done
Checking in sdir/ssdir/ssfile;
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
initial revision: 1\.1
done"
	  dotest_fail basica-5a \
	    "${testcvs} -q tag BASE sdir/ssdir/ssfile" \
"${PROG} [a-z]*: Attempt to add reserved tag name BASE
${PROG} \[[a-z]* aborted\]: failed to set tag BASE to revision 1\.1 in ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v"
	  dotest basica-5b "${testcvs} -q tag NOT_RESERVED" \
'T sdir/ssdir/ssfile'

	  dotest basica-6 "${testcvs} -q update" ''
	  echo "ssfile line 2" >>sdir/ssdir/ssfile
	  dotest_status basica-6.2 1 "${testcvs} -q diff -c" \
"Index: sdir/ssdir/ssfile
===================================================================
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
retrieving revision 1\.1
diff -c -r1\.1 ssfile
\*\*\* sdir/ssdir/ssfile	${RFCDATE}	1\.1
--- sdir/ssdir/ssfile	${RFCDATE}
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
d831 1
a831 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d834 2
a835 2
\*\*\* sdir/ssdir/ssfile	${RFCDATE}	1\.1
--- sdir/ssdir/ssfile	${RFCDATE}
d843 1
a843 1
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d856 1
a856 1
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d861 1
a861 1
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d868 1
a868 1
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d875 2
a876 2
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v: can't find branch point 3\.0
d880 1
a880 1
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
d890 1
a890 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d898 1
a898 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
a918 21
	  # Test resurrecting with strange revision numbers
	  cd sdir/ssdir
	  dotest basica-r1 "${testcvs} rm -f ssfile" \
"${PROG} [a-z]*: scheduling .ssfile. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest basica-r2 "${testcvs} -q ci -m remove" \
"Removing ssfile;
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: delete; previous revision: 3\.1
done"
	  dotest basica-r3 "${testcvs} -q up -p -r 3.1 ssfile >ssfile" ""
	  dotest basica-r4 "${testcvs} add ssfile" \
"${PROG} [a-z]*: re-adding file ssfile (in place of dead revision 3\.2)
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
	  dotest basica-r5 "${testcvs} -q ci -m resurrect" \
"Checking in ssfile;
${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v  <--  ssfile
new revision: 3\.3; previous revision: 3\.2
done"
	  cd ../..

d926 1
a926 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d929 1
a929 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d932 3
a934 3
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v: Revision NOT_EXIST doesn't exist.
${PROG} [a-z]*: RCS file for .ssfile. not modified\."
d936 1
a936 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d939 1
a939 3
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
deleting revision 3\.3
deleting revision 3\.2
d942 1
a942 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d945 1
a945 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d950 1
a950 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d955 1
a955 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d959 1
a959 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/ssdir/ssfile,v
d999 1
a999 1
"RCS file: ${CVSROOT_DIRNAME}/topfile,v
d1002 1
a1002 1
${CVSROOT_DIRNAME}/topfile,v  <--  topfile
d1018 1
a1018 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d1035 1
a1035 1
"${CVSROOT_DIRNAME}/\." \
d1038 1
a1038 1
"${CVSROOT_DIRNAME}/first-dir" \
d1047 2
a1048 2
"Directory ${CVSROOT_DIRNAME}/first-dir/Emptydir added to the repository
Directory ${CVSROOT_DIRNAME}/first-dir/sdir2 added to the repository"
d1084 1
a1084 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Emptydir/sfile1,v
d1087 1
a1087 1
${CVSROOT_DIRNAME}/first-dir/Emptydir/sfile1,v  <--  sfile1
d1090 1
a1090 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir2/sfile2,v
d1093 1
a1093 1
${CVSROOT_DIRNAME}/first-dir/sdir2/sfile2,v  <--  sfile2
d1099 1
a1099 1
${CVSROOT_DIRNAME}/first-dir/Emptydir/sfile1,v  <--  sfile1
d1107 1
a1107 1
${CVSROOT_DIRNAME}/first-dir/sdir2/sfile2,v  <--  sfile2
d1149 1
a1149 1
"${CVSROOT_DIRNAME}/\." \
d1152 1
a1152 1
"${CVSROOT_DIRNAME}/\." \
d1155 1
a1155 1
"${CVSROOT_DIRNAME}/first-dir" \
d1158 1
a1158 1
"${CVSROOT_DIRNAME}/first-dir/Emptydir" \
d1161 1
a1161 1
"${CVSROOT_DIRNAME}/first-dir/sdir2" \
d1191 1
a1191 1
"Directory ${CVSROOT_DIRNAME}/second-dir added to the repository"
d1198 1
a1198 1
"RCS file: ${CVSROOT_DIRNAME}/second-dir/aa,v
d1201 1
a1201 1
${CVSROOT_DIRNAME}/second-dir/aa,v  <--  aa
d1208 1
a1208 1
"RCS file: ${CVSROOT_DIRNAME}/topfile,v
d1216 1
a1216 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir2/sfile2,v
d1237 1
a1237 1
	  if $keep; then
d1256 2
a1257 2
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository
Directory ${CVSROOT_DIRNAME}/second-dir added to the repository"
d1314 1
a1314 1
	  mkdir basic1; cd basic1
d1447 1
a1447 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d1450 1
a1450 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d1453 1
a1453 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file3,v
d1456 1
a1456 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d1459 1
a1459 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d1462 1
a1462 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d1465 1
a1465 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file5,v
d1468 1
a1468 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d1479 1
a1479 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file2,v
d1488 1
a1488 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file3,v
d1497 1
a1497 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file4,v
d1506 1
a1506 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file5,v
d1564 1
a1564 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file2,v
d1573 1
a1573 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file3,v
d1582 1
a1582 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file4,v
d1591 1
a1591 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file5,v
d1631 1
a1631 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d1635 1
a1635 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d1639 1
a1639 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d1643 1
a1643 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d1677 1
a1677 1
	  if $keep; then
d1682 1
a1682 1
	  rm -r basic1
d1694 1
a1694 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir1[/dir0-9]* added to the repository"
d1703 1
a1703 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file1,v
d1706 1
a1706 1
${CVSROOT_DIRNAME}/first-dir/dir1/file1,v  <--  file1
d1709 1
a1709 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file1,v
d1712 1
a1712 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file1,v  <--  file1
d1715 1
a1715 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/file1,v
d1718 1
a1718 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/file1,v  <--  file1
d1721 1
a1721 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/file1,v
d1724 1
a1724 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/file1,v  <--  file1
d1727 1
a1727 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v
d1730 1
a1730 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
d1733 1
a1733 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v
d1736 1
a1736 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
d1739 1
a1739 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v
d1742 1
a1742 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
d1745 1
a1745 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v
d1748 1
a1748 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
d1759 1
a1759 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/dir8/file1,v  <--  file1
d1792 1
a1792 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/dir7/file1,v  <--  file1
d1808 1
a1808 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/file1,v  <--  file1
d1812 1
a1812 1
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/dir3/dir4/dir5/dir6/file1,v  <--  file1
d1840 13
a1852 79
### XXX maybe should use 'cvs imprt -b1 -m new-module first-dir F F1' in an
### empty directory to do this instead of hacking directly into $CVSROOT
		mkdir ${CVSROOT_DIRNAME}/first-dir
		dotest basic2-1 "${testcvs} -q co first-dir" ''
		for i in first-dir dir1 dir2 ; do
			if test ! -d $i ; then
				mkdir $i
				dotest basic2-2-$i "${testcvs} add $i" \
"Directory ${CVSROOT_DIRNAME}/.*/$i added to the repository"
			fi

			cd $i

			for j in file6 file7; do
				echo $j > $j
			done

			dotest basic2-3-$i "${testcvs} add file6 file7" \
"${PROG} [a-z]*: scheduling file .file6. for addition
${PROG} [a-z]*: scheduling file .file7. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"

		done
		cd ../../..
		dotest basic2-4 "${testcvs} update first-dir" \
"${PROG} [a-z]*: Updating first-dir
A first-dir/file6
A first-dir/file7
${PROG} [a-z]*: Updating first-dir/dir1
A first-dir/dir1/file6
A first-dir/dir1/file7
${PROG} [a-z]*: Updating first-dir/dir1/dir2
A first-dir/dir1/dir2/file6
A first-dir/dir1/dir2/file7"

		# fixme: doesn't work right for added files.
		dotest basic2-5 "${testcvs} log first-dir" \
"${PROG} [a-z]*: Logging first-dir
${PROG} [a-z]*: file6 has been added, but not committed
${PROG} [a-z]*: file7 has been added, but not committed
${PROG} [a-z]*: Logging first-dir/dir1
${PROG} [a-z]*: file6 has been added, but not committed
${PROG} [a-z]*: file7 has been added, but not committed
${PROG} [a-z]*: Logging first-dir/dir1/dir2
${PROG} [a-z]*: file6 has been added, but not committed
${PROG} [a-z]*: file7 has been added, but not committed"

		dotest basic2-6 "${testcvs} status first-dir" \
"${PROG} [a-z]*: Examining first-dir
===================================================================
File: file6            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file7            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

${PROG} [a-z]*: Examining first-dir/dir1
===================================================================
File: file6            	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file7            	Status: Locally Added
d1854 1
a1854 5
   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)
d1856 3
a1858 3
${PROG} [a-z]*: Examining first-dir/dir1/dir2
===================================================================
File: file6            	Status: Locally Added
d1860 12
a1871 5
   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)
d1873 6
a1878 2
===================================================================
File: file7            	Status: Locally Added
d1880 5
a1884 5
   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
d1893 5
a1897 37
		dotest basic2-8 "${testcvs} -q ci -m 'second dive' first-dir" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file6,v
done
Checking in first-dir/file6;
${CVSROOT_DIRNAME}/first-dir/file6,v  <--  file6
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/file7,v
done
Checking in first-dir/file7;
${CVSROOT_DIRNAME}/first-dir/file7,v  <--  file7
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file6,v
done
Checking in first-dir/dir1/file6;
${CVSROOT_DIRNAME}/first-dir/dir1/file6,v  <--  file6
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file7,v
done
Checking in first-dir/dir1/file7;
${CVSROOT_DIRNAME}/first-dir/dir1/file7,v  <--  file7
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file6,v
done
Checking in first-dir/dir1/dir2/file6;
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file6,v  <--  file6
initial revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file7,v
done
Checking in first-dir/dir1/dir2/file7;
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file7,v  <--  file7
initial revision: 1\.1
done"
d1899 5
a1903 10
		dotest basic2-9 "${testcvs} tag second-dive first-dir" \
"${PROG} [a-z]*: Tagging first-dir
T first-dir/file6
T first-dir/file7
${PROG} [a-z]*: Tagging first-dir/dir1
T first-dir/dir1/file6
T first-dir/dir1/file7
${PROG} [a-z]*: Tagging first-dir/dir1/dir2
T first-dir/dir1/dir2/file6
T first-dir/dir1/dir2/file7"
d1917 5
a1921 3
			dotest basic2-10-$i "${testcvs} rm file7" \
"${PROG} [a-z]*: scheduling .file7. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
d1926 5
a1930 3
			dotest basic2-11-$i "${testcvs} add file14" \
"${PROG} [a-z]*: scheduling file .file14. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"
a1931 1

d1933 5
a1937 13
		dotest basic2-12 "${testcvs} update first-dir" \
"${PROG} [a-z]*: Updating first-dir
A first-dir/file14
M first-dir/file6
R first-dir/file7
${PROG} [a-z]*: Updating first-dir/dir1
A first-dir/dir1/file14
M first-dir/dir1/file6
R first-dir/dir1/file7
${PROG} [a-z]*: Updating first-dir/dir1/dir2
A first-dir/dir1/dir2/file14
M first-dir/dir1/dir2/file6
R first-dir/dir1/dir2/file7"
d1940 5
a1944 3
		dotest basic2-13 "${testcvs} log first-dir" \
"${PROG} [a-z]*: Logging first-dir
${PROG} [a-z]*: file14 has been added, but not committed
d1946 5
a1950 190
RCS file: ${CVSROOT_DIRNAME}/first-dir/file6,v
Working file: first-dir/file6
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
=============================================================================

RCS file: ${CVSROOT_DIRNAME}/first-dir/file7,v
Working file: first-dir/file7
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
=============================================================================
${PROG} [a-z]*: Logging first-dir/dir1
${PROG} [a-z]*: file14 has been added, but not committed

RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file6,v
Working file: first-dir/dir1/file6
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
=============================================================================

RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file7,v
Working file: first-dir/dir1/file7
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
=============================================================================
${PROG} [a-z]*: Logging first-dir/dir1/dir2
${PROG} [a-z]*: file14 has been added, but not committed

RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file6,v
Working file: first-dir/dir1/dir2/file6
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
=============================================================================

RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file7,v
Working file: first-dir/dir1/dir2/file7
head: 1\.1
branch:
locks: strict
access list:
symbolic names:
	second-dive: 1\.1
keyword substitution: kv
total revisions: 1;	selected revisions: 1
description:
----------------------------
revision 1\.1
date: [0-9/]* [0-9:]*;  author: ${username};  state: Exp;
second dive
============================================================================="

		dotest basic2-14 "${testcvs} status first-dir" \
"${PROG} [a-z]*: Examining first-dir
===================================================================
File: file14           	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file6            	Status: Locally Modified

   Working revision:	1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file6,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file7		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file7,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

${PROG} [a-z]*: Examining first-dir/dir1
===================================================================
File: file14           	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file6            	Status: Locally Modified

   Working revision:	1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir1/file6,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file7		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir1/file7,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

${PROG} [a-z]*: Examining first-dir/dir1/dir2
===================================================================
File: file14           	Status: Locally Added

   Working revision:	New file!
   Repository revision:	No revision control file
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: file6            	Status: Locally Modified

   Working revision:	1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file6,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)

===================================================================
File: no file file7		Status: Locally Removed

   Working revision:	-1\.1.*
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file7,v
   Sticky Tag:		(none)
   Sticky Date:		(none)
   Sticky Options:	(none)"
d1959 6
a1964 47
		dotest basic2-16 "${testcvs} ci -m 'third dive' first-dir" \
"${PROG} [a-z]*: Examining first-dir
${PROG} [a-z]*: Examining first-dir/dir1
${PROG} [a-z]*: Examining first-dir/dir1/dir2
RCS file: ${CVSROOT_DIRNAME}/first-dir/file14,v
done
Checking in first-dir/file14;
${CVSROOT_DIRNAME}/first-dir/file14,v  <--  file14
initial revision: 1\.1
done
Checking in first-dir/file6;
${CVSROOT_DIRNAME}/first-dir/file6,v  <--  file6
new revision: 1\.2; previous revision: 1\.1
done
Removing first-dir/file7;
${CVSROOT_DIRNAME}/first-dir/file7,v  <--  file7
new revision: delete; previous revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/file14,v
done
Checking in first-dir/dir1/file14;
${CVSROOT_DIRNAME}/first-dir/dir1/file14,v  <--  file14
initial revision: 1\.1
done
Checking in first-dir/dir1/file6;
${CVSROOT_DIRNAME}/first-dir/dir1/file6,v  <--  file6
new revision: 1\.2; previous revision: 1\.1
done
Removing first-dir/dir1/file7;
${CVSROOT_DIRNAME}/first-dir/dir1/file7,v  <--  file7
new revision: delete; previous revision: 1\.1
done
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file14,v
done
Checking in first-dir/dir1/dir2/file14;
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file14,v  <--  file14
initial revision: 1\.1
done
Checking in first-dir/dir1/dir2/file6;
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file6,v  <--  file6
new revision: 1\.2; previous revision: 1\.1
done
Removing first-dir/dir1/dir2/file7;
${CVSROOT_DIRNAME}/first-dir/dir1/dir2/file7,v  <--  file7
new revision: delete; previous revision: 1\.1
done"
		dotest basic2-17 "${testcvs} -q update first-dir" ''
d1966 5
a1970 10
		dotest basic2-18 "${testcvs} tag third-dive first-dir" \
"${PROG} [a-z]*: Tagging first-dir
T first-dir/file14
T first-dir/file6
${PROG} [a-z]*: Tagging first-dir/dir1
T first-dir/dir1/file14
T first-dir/dir1/file6
${PROG} [a-z]*: Tagging first-dir/dir1/dir2
T first-dir/dir1/dir2/file14
T first-dir/dir1/dir2/file6"
d1972 5
a1976 3
		dotest basic2-19 "echo yes | ${testcvs} release -d first-dir" \
"You have \[0\] altered files in this repository\.
Are you sure you want to release (and delete) directory .first-dir.: "
d1979 5
a1983 1
		dotest_fail basic2-20 "test -d first-dir" ""
d1988 5
a1992 4
		dotest basic2-21 "${testcvs} rtag rtagged-by-head first-dir" \
"${PROG} [a-z]*: Tagging first-dir
${PROG} [a-z]*: Tagging first-dir/dir1
${PROG} [a-z]*: Tagging first-dir/dir1/dir2"
d1995 5
a1999 4
		dotest basic2-22 "${testcvs} rtag -r rtagged-by-head rtagged-by-tag first-dir" \
"${PROG} [a-z]*: Tagging first-dir
${PROG} [a-z]*: Tagging first-dir/dir1
${PROG} [a-z]*: Tagging first-dir/dir1/dir2"
d2002 5
a2006 4
		dotest basic2-23 "${testcvs} rtag -r1.1 rtagged-by-revision first-dir" \
"${PROG} [a-z]*: Tagging first-dir
${PROG} [a-z]*: Tagging first-dir/dir1
${PROG} [a-z]*: Tagging first-dir/dir1/dir2"
d2009 6
a2014 55
		dotest basic2-24 "${testcvs} rdiff -r1.1 -rrtagged-by-head first-dir" \
"${PROG} [a-z]*: Diffing first-dir
Index: first-dir/file6
diff -c first-dir/file6:1\.1 first-dir/file6:1\.2
\*\*\* first-dir/file6:1\.1	.*
--- first-dir/file6	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
--- 1,2 ----
  file6
${PLUS} file6
Index: first-dir/file7
diff -c first-dir/file7:1\.1 first-dir/file7:removed
\*\*\* first-dir/file7:1.1	.*
--- first-dir/file7	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- file7
--- 0 ----
${PROG} [a-z]*: Diffing first-dir/dir1
Index: first-dir/dir1/file6
diff -c first-dir/dir1/file6:1\.1 first-dir/dir1/file6:1\.2
\*\*\* first-dir/dir1/file6:1\.1	.*
--- first-dir/dir1/file6	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
--- 1,2 ----
  file6
${PLUS} file6
Index: first-dir/dir1/file7
diff -c first-dir/dir1/file7:1\.1 first-dir/dir1/file7:removed
\*\*\* first-dir/dir1/file7:1\.1	.*
--- first-dir/dir1/file7	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- file7
--- 0 ----
${PROG} [a-z]*: Diffing first-dir/dir1/dir2
Index: first-dir/dir1/dir2/file6
diff -c first-dir/dir1/dir2/file6:1\.1 first-dir/dir1/dir2/file6:1\.2
\*\*\* first-dir/dir1/dir2/file6:1\.1	.*
--- first-dir/dir1/dir2/file6	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
--- 1,2 ----
  file6
${PLUS} file6
Index: first-dir/dir1/dir2/file7
diff -c first-dir/dir1/dir2/file7:1\.1 first-dir/dir1/dir2/file7:removed
\*\*\* first-dir/dir1/dir2/file7:1\.1	.*
--- first-dir/dir1/dir2/file7	.*
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\* 1 \*\*\*\*
- file7
--- 0 ----"
d2016 5
a2020 10
		dotest basic2-25 "${testcvs} export -r rtagged-by-head first-dir" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/file14
U first-dir/file6
${PROG} [a-z]*: Updating first-dir/dir1
U first-dir/dir1/file14
U first-dir/dir1/file6
${PROG} [a-z]*: Updating first-dir/dir1/dir2
U first-dir/dir1/dir2/file14
U first-dir/dir1/dir2/file6"
d2023 7
a2029 10
		dotest basic2-26 "${testcvs} export -r rtagged-by-tag first-dir" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/file14
U first-dir/file6
${PROG} [a-z]*: Updating first-dir/dir1
U first-dir/dir1/file14
U first-dir/dir1/file6
${PROG} [a-z]*: Updating first-dir/dir1/dir2
U first-dir/dir1/dir2/file14
U first-dir/dir1/dir2/file6"
d2031 5
a2035 1
		dotest basic2-27 "directory_cmp 1dir first-dir"
d2039 5
a2043 13
		dotest basic2-28 "${testcvs} export -rrtagged-by-revision -d export-dir first-dir" \
"${PROG} [a-z]*: Updating export-dir
U export-dir/file14
U export-dir/file6
U export-dir/file7
${PROG} [a-z]*: Updating export-dir/dir1
U export-dir/dir1/file14
U export-dir/dir1/file6
U export-dir/dir1/file7
${PROG} [a-z]*: Updating export-dir/dir1/dir2
U export-dir/dir1/dir2/file14
U export-dir/dir1/dir2/file6
U export-dir/dir1/dir2/file7"
d2045 5
a2049 13
		dotest basic2-29 "${testcvs} co -r1.1 first-dir" \
"${PROG} [a-z]*: Updating first-dir
U first-dir/file14
U first-dir/file6
U first-dir/file7
${PROG} [a-z]*: Updating first-dir/dir1
U first-dir/dir1/file14
U first-dir/dir1/file6
U first-dir/dir1/file7
${PROG} [a-z]*: Updating first-dir/dir1/dir2
U first-dir/dir1/dir2/file14
U first-dir/dir1/dir2/file6
U first-dir/dir1/dir2/file7"
d2054 7
a2060 1
		dotest basic2-30 "directory_cmp first-dir export-dir"
d2065 1
a2065 1
		dotest_sort basic2-31 "${testcvs} import -m first-import second-dir first-immigration immigration1 immigration1_0" \
d2078 2
a2079 2
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/second-dir/dir1
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/second-dir/dir1/dir2"
d2082 7
a2088 13
		dotest basic2-32 "${testcvs} export -r HEAD second-dir" \
"${PROG} [a-z]*: Updating second-dir
U second-dir/file14
U second-dir/file6
U second-dir/file7
${PROG} [a-z]*: Updating second-dir/dir1
U second-dir/dir1/file14
U second-dir/dir1/file6
U second-dir/dir1/file7
${PROG} [a-z]*: Updating second-dir/dir1/dir2
U second-dir/dir1/dir2/file14
U second-dir/dir1/dir2/file6
U second-dir/dir1/dir2/file7"
d2090 5
a2094 1
		dotest basic2-33 "directory_cmp first-dir second-dir"
d2104 5
a2108 3
		dotest basic2-34 "${testcvs} update -A -l *file*" \
"[UP] file6
${PROG} [a-z]*: file7 is no longer in the repository"
d2112 10
a2121 8
		dotest basic2-35 "${testcvs} tag -l -d rtagged-by-revision" \
"${PROG} [a-z]*: Untagging \.
D file14
D file6"
		dotest basic2-36 "${testcvs} tag -l rtagged-by-revision" \
"${PROG} [a-z]*: Tagging \.
T file14
T file6"
d2128 1
a2128 1
		dotest basic2-37 "${testcvs} -q diff -u" ''
d2130 5
a2134 4
		dotest basic2-38 "${testcvs} update" \
"${PROG} [a-z]*: Updating .
${PROG} [a-z]*: Updating dir1
${PROG} [a-z]*: Updating dir1/dir2"
d2140 7
a2146 2
#		dotest basic2-39 "directory_cmp 1dir first-dir"

d2161 17
a2177 17
"O [0-9-]* [0-9:]* ${PLUS}0000 ${username} first-dir           =first-dir= ${TESTDIR}/\*
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir           == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir           == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1      == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1      == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file6     first-dir/dir1/dir2 == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file7     first-dir/dir1/dir2 == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir           == ${TESTDIR}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TESTDIR}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir           == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1      == ${TESTDIR}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1      == ${TESTDIR}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1      == ${TESTDIR}
A [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.1 file14    first-dir/dir1/dir2 == ${TESTDIR}
M [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir/dir1/dir2 == ${TESTDIR}
R [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file7     first-dir/dir1/dir2 == ${TESTDIR}
F [0-9-]* [0-9:]* ${PLUS}0000 ${username}                     =first-dir= ${TESTDIR}/\*
d2181 3
a2183 3
O [0-9-]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= ${TESTDIR}/\*
U [0-9-]* [0-9:]* ${PLUS}0000 ${username} 1\.2 file6     first-dir           == ${TESTDIR}/first-dir
W [0-9-]* [0-9:]* ${PLUS}0000 ${username}     file7     first-dir           == ${TESTDIR}/first-dir" \
d2204 1
a2204 2
O [0-9-]* [0-9:]* ${PLUS}0000 ${username} \[1\.1\] first-dir           =first-dir= <remote>/\*
W [0-9-]* [0-9:]* ${PLUS}0000 ${username}     file7     first-dir           == <remote>" \
d2222 1
a2222 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d2229 1
a2229 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/tfile,v
d2232 1
a2232 1
${CVSROOT_DIRNAME}/first-dir/tfile,v  <--  tfile
d2239 1
a2239 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir added to the repository
d2248 1
a2248 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir/sdir added to the repository
d2253 1
a2253 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir added to the repository
d2262 1
a2262 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v
d2265 1
a2265 1
${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v  <--  \.file
d2268 1
a2268 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v
d2271 1
a2271 1
${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
d2277 1
a2277 1
${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v  <--  \.file
d2281 1
a2281 1
${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
d2284 1
a2284 1
	  if $remote; then
d2301 1
a2301 1
${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
d2305 1
a2305 1
${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v  <--  \.file
d2312 1
a2312 1
${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
d2316 1
a2316 1
${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v  <--  \.file
d2323 1
a2323 1
${CVSROOT_DIRNAME}/first-dir/dir/sdir/ssdir/Attic/\.file,v  <--  \.file
d2326 1
a2326 1
	  if $remote; then
d2334 1
a2334 1
${CVSROOT_DIRNAME}/first-dir/dir/Attic/\.file,v  <--  \.file
d2353 1
a2353 1
	  if $remote; then
d2369 1
a2369 1
"RCS file: ${CVSROOT_DIRNAME}/${dashc},v
d2372 1
a2372 1
${CVSROOT_DIRNAME}/${dashc},v  <--  ${dashc}
d2375 1
a2375 1
RCS file: ${CVSROOT_DIRNAME}/top,v
d2378 1
a2378 1
${CVSROOT_DIRNAME}/top,v  <--  top
d2383 1
a2383 1
"Directory ${CVSROOT_DIRNAME}/first dir added to the repository"
d2386 1
a2386 1
"Directory ${CVSROOT_DIRNAME}/${dashb} added to the repository"
d2393 1
a2393 1
"RCS file: ${CVSROOT_DIRNAME}/first dir/a file,v
d2396 1
a2396 1
${CVSROOT_DIRNAME}/first dir/a file,v  <--  a file
d2446 1
a2446 1
"RCS file: ${CVSROOT_DIRNAME}/$module/$file,v
d2449 1
a2449 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d2459 1
a2459 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d2497 1
a2497 1
${CVSROOT_DIRNAME}/trdiff/foo,v  <--  foo
d2508 1
a2508 1
"RCS file: ${CVSROOT_DIRNAME}/trdiff/new,v
d2511 1
a2511 1
${CVSROOT_DIRNAME}/trdiff/new,v  <--  new
d2526 1
a2526 1
   Repository revision:	1\.2	${CVSROOT_DIRNAME}/trdiff/foo,v
d2564 5
a2568 4
		if $keep; then
		  echo Keeping ${TESTDIR} and exiting due to --keep
		  exit 0
		fi
d2586 1
a2586 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d2599 1
a2599 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/abc,v
d2602 1
a2602 1
${CVSROOT_DIRNAME}/first-dir/abc,v  <--  abc
d2608 1
a2608 1
${CVSROOT_DIRNAME}/first-dir/abc,v  <--  abc
d2616 1
a2616 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/abc,v
d2625 1
a2625 1
	  if $keep; then
d2656 1
a2656 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir added to the repository"
d2663 1
a2663 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/sfile,v
d2666 1
a2666 1
${CVSROOT_DIRNAME}/first-dir/subdir/sfile,v  <--  sfile
d2675 1
a2675 1
${CVSROOT_DIRNAME}/first-dir/subdir/sfile,v  <--  sfile
d2749 1
a2749 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d2752 1
a2752 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d2761 1
a2761 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d2893 1
a2893 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d2925 1
a2925 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d2929 1
a2929 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d2933 1
a2933 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d3029 1
a3029 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3032 1
a3032 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3035 1
a3035 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d3038 1
a3038 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3071 2
a3072 2
\*\*\* file1	${RFCDATE}	[0-9.]*
--- /dev/null	${RFCDATE_EPOCH}
d3080 1
a3080 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3095 2
a3096 2
\*\*\* file1	${RFCDATE}	[0-9.]*
--- /dev/null	${RFCDATE_EPOCH}
d3110 2
a3111 2
\*\*\* file1	[-a-zA-Z0-9: ]*	[0-9.]*
--- /dev/null	${RFCDATE_EPOCH}
d3124 2
a3125 2
\*\*\* first-dir/file1:1\.1	[a-zA-Z0-9: ]*
--- first-dir/file1	[a-zA-Z0-9: ]*
d3146 2
a3147 2
\*\*\* /dev/null	${RFCDATE_EPOCH}
--- file1	${RFCDATE}
d3155 1
a3155 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3165 1
a3165 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3180 1
a3180 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d3183 1
a3183 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d3191 1
a3191 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3202 1
a3202 1
${PROG} [a-z]*: file4 is no longer in the repository"
d3211 1
a3211 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d3221 1
a3221 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file3,v
d3224 1
a3224 1
${CVSROOT_DIRNAME}/first-dir/Attic/file3,v  <--  file3
d3237 2
a3238 2
\*\*\* /dev/null	${RFCDATE_EPOCH}
--- file3	${RFCDATE}	[0-9.]*
d3247 1
a3247 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3251 2
a3252 2
\*\*\* file1	${RFCDATE}	[0-9.]*
--- file1	${RFCDATE}	[0-9.]*
d3265 1
a3265 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3269 2
a3270 2
\*\*\* file1	${RFCDATE}	[0-9.]*
--- file1	${RFCDATE}	[0-9.]*
d3280 2
a3281 2
\*\*\* /dev/null	${RFCDATE_EPOCH}
--- file2	${RFCDATE}	[0-9.]*
d3290 2
a3291 2
\*\*\* /dev/null	${RFCDATE_EPOCH}
--- file3	${RFCDATE}	[0-9.]*
d3300 2
a3301 2
\*\*\* file4	${RFCDATE}	[0-9.]*
--- /dev/null	${RFCDATE_EPOCH}
d3325 2
a3326 2
\*\*\* /dev/null	${RFCDATE_EPOCH}
--- file1	${RFCDATE}	[0-9.]*
a3331 26
	  # now back to the trunk
	  dotest death2-21 "${testcvs} -q update -A" \
"U file2
[UP] file4"

	  # test merging with a dead file
	  dotest death2-22 "${testcvs} -q co first-dir" \
"U first-dir/file1
U first-dir/file2
U first-dir/file4"

	  cd first-dir
	  dotest death2-23 "${testcvs} rm -f file4" \
"${PROG} [a-z]*: scheduling .file4. for removal
${PROG} [a-z]*: use .${PROG} commit. to remove this file permanently"
	  dotest death2-24 "${testcvs} -q ci -m removed file4" \
"Removing file4;
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
new revision: delete; previous revision: 1\.2
done"
	  cd ..
	  echo "new stuff" >file4
	  dotest_fail death2-25 "${testcvs} up file4" \
"${PROG} [a-z]*: conflict: file4 is modified but no longer in the repository
C file4"

a3334 36
	rm-update-message)
	  # FIXME
	  # local CVS prints a warning message when update notices a missing
	  # file and client/server CVS doesn't.  These should be identical.
	  mkdir rm-update-message; cd rm-update-message
	  mkdir $CVSROOT_DIRNAME/rm-update-message
	  dotest rm-update-message-setup-1 "$testcvs -q co rm-update-message" ''
	  cd rm-update-message
	  file=x
	  echo >$file
	  dotest rm-update-message-setup-2 "$testcvs -q add $file" \
"$PROG [a-z]*: use .cvs commit. to add this file permanently"
	  dotest rm-update-message-setup-3 "$testcvs -q ci -mcreate $file" \
"RCS file: $CVSROOT_DIRNAME/rm-update-message/$file,v
done
Checking in $file;
$CVSROOT_DIRNAME/rm-update-message/$file,v  <--  $file
initial revision: 1\.1
done"

	  rm $file
	  if $remote; then
	    dotest rm-update-message-1 "$testcvs up $file" "U $file"
	  else
	    dotest rm-update-message-1 "$testcvs up $file" \
"$PROG [a-z]*: warning: $file was lost
U $file"
	  fi

	  cd ../..
	  if $keep; then :; else
	    rm -rf rm-update-message
	    rm -rf $CVSROOT_DIRNAME/rm-update-message
	  fi
	  ;;

d3348 1
a3348 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d3368 1
a3368 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3371 1
a3371 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3374 1
a3374 1
	  if $remote; then
d3398 1
a3398 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d3401 1
a3401 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d3416 1
a3416 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file3,v
d3419 1
a3419 1
${CVSROOT_DIRNAME}/first-dir/Attic/file3,v  <--  file3
d3448 1
a3448 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file4,v
d3451 1
a3451 1
${CVSROOT_DIRNAME}/first-dir/Attic/file4,v  <--  file4
d3461 1
a3461 1
	  if $remote; then
d3465 2
a3466 2
	    dotest rmadd-23r "${testcvs} -q ci -m add" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file5,v
d3469 1
a3469 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d3472 1
a3472 1
	    dotest rmadd-23-workaroundr \
d3475 1
a3475 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d3480 1
a3480 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file5,v
d3483 1
a3483 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d3490 2
a3491 2
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file5,v: revision 4\.8 too low; must be higher than 7\.1
d3496 1
a3496 1
${CVSROOT_DIRNAME}/first-dir/file5,v  <--  file5
d3506 1
a3506 1
   Repository revision:	8\.4	${CVSROOT_DIRNAME}/first-dir/file5,v
d3523 1
a3523 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d3530 1
a3530 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3533 1
a3533 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3542 1
a3542 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3548 1
a3548 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3554 1
a3554 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3558 1
a3558 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3564 1
a3564 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
a3573 6

	  # Check that -p can get arbitrary revisions of a removed file
	  dotest rmadd2-14a "${testcvs} -q update -p" "initial contents"
	  dotest rmadd2-14b "${testcvs} -q update -p -r 1.5" "initial contents"
	  dotest rmadd2-14c "${testcvs} -q update -p -r 1.3" "initial contents"

d3576 1
a3576 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3580 1
a3580 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file1,v
d3596 1
a3596 1
   Repository revision:	1\.6	${CVSROOT_DIRNAME}/first-dir/Attic/file1,v
d3604 1
a3604 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d3628 1
a3628 1
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/dir1/sdir"
d3645 1
a3645 1
${PROG} [a-z]*: cannot open directory ${CVSROOT_DIRNAME}/dir1/sdir: No such file or directory
d3650 1
a3650 1
${PROG} [a-z]*: cannot open directory ${CVSROOT_DIRNAME}/dir1/sdir: No such file or directory
d3658 1
a3658 1
"${PROG} [a-z]*: cannot open directory ${CVSROOT_DIRNAME}/dir1/sdir: No such file or directory
d3691 1
a3691 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d3695 1
a3695 1
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository"
d3701 1
a3701 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/file1,v
d3704 1
a3704 1
${CVSROOT_DIRNAME}/first-dir/sdir/file1,v  <--  file1
d3708 1
a3708 1
	  if $remote; then
d3713 2
a3718 1
	    rm -r sdir/CVS
d3721 3
d3727 2
d3730 2
a3731 1
U sdir/file1"
d3749 1
a3749 1
	  if $remote; then
d3762 4
d3768 2
a3769 1
C sdir/file1"
d3793 1
a3793 1
${CVSROOT_DIRNAME}/first-dir/sdir/file1,v  <--  file1
d3797 1
a3797 1
	  if $remote; then
d3799 1
a3799 1
"${QUESTION} sdir/file1
d3801 6
a3806 1
${PROG} server: Updating sdir"
d3815 1
a3815 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d3835 1
a3835 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d3838 1
a3838 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3841 1
a3841 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d3844 1
a3844 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d3847 1
a3847 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file3,v
d3850 1
a3850 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d3853 1
a3853 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d3856 1
a3856 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3863 1
a3863 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3889 1
a3889 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3893 1
a3893 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d3897 1
a3897 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3909 1
a3909 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d3913 1
a3913 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3930 1
a3930 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3944 1
a3944 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d3949 1
a3949 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d3992 1
a3992 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d3996 2
a3997 2
\*\*\* file4	${RFCDATE}	1\.1
--- file4	${RFCDATE}	1\.3
d4007 1
a4007 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d4011 2
a4012 2
\*\*\* file4	${RFCDATE}	1\.1
--- file4	${RFCDATE}	1\.2\.2\.1
d4020 1
a4020 1
	    "RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4032 1
a4032 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4034 1
a4034 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d4036 1
a4036 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file3,v
d4038 1
a4038 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d4042 1
a4042 1
	  if $keep; then
d4069 1
a4069 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4072 1
a4072 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4095 1
a4095 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir1 added to the repository
d4102 1
a4102 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file2,v
d4105 1
a4105 1
${CVSROOT_DIRNAME}/first-dir/Attic/file2,v  <--  file2
d4108 1
a4108 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir1/Attic/file3,v
d4111 1
a4111 1
${CVSROOT_DIRNAME}/first-dir/dir1/Attic/file3,v  <--  file3
d4131 1
a4131 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4140 1
a4140 1
   Repository revision:	1\.1\.2\.1	${CVSROOT_DIRNAME}/first-dir/dir1/Attic/file3,v
d4162 1
a4162 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4188 1
a4188 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4197 1
a4197 1
   Repository revision:	1\.1\.2\.1	${CVSROOT_DIRNAME}/first-dir/dir1/Attic/file3,v
d4211 1
a4211 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4220 1
a4220 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir1/Attic/file3,v
d4246 1
a4246 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir2 added to the repository
d4253 1
a4253 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/dir2/Attic/file4,v
d4256 1
a4256 1
${CVSROOT_DIRNAME}/first-dir/dir2/Attic/file4,v  <--  file4
d4270 1
a4270 1
   Repository revision:	1\.1\.2\.1	${CVSROOT_DIRNAME}/first-dir/dir2/Attic/file4,v
d4291 1
a4291 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/dir2/file5,v
d4294 1
a4294 1
${CVSROOT_DIRNAME}/first-dir/dir2/file5,v  <--  file5
d4306 1
a4306 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/dir2/file5,v
d4323 1
a4323 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d4330 1
a4330 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4333 1
a4333 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4353 1
a4353 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4357 6
a4362 1
	  dotest tagc-10 "${testcvs} -q tag -c tag4" "T file1"
d4378 1
a4378 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d4386 1
a4386 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4389 1
a4389 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4392 1
a4392 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d4395 1
a4395 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d4407 1
a4407 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4411 1
a4411 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d4427 1
a4427 1
   Repository revision:	1\.1\.2\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4444 1
a4444 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d4450 1
a4450 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4470 1
a4470 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4474 1
a4474 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d4498 1
a4498 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d4501 1
a4501 1
${CVSROOT_DIRNAME}/first-dir/foo.c,v  <--  foo\.c
d4508 1
a4508 1
RCS:  ${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d4516 1
a4516 1
${CVSROOT_DIRNAME}/first-dir/foo\.c,v  <--  foo\.c
d4523 1
a4523 1
RCS:  ${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d4532 1
a4532 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d4546 1
a4546 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d4573 1
a4573 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/rgx\.c,v
d4576 1
a4576 1
${CVSROOT_DIRNAME}/first-dir/rgx\.c,v  <--  rgx\.c
d4592 1
a4592 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/rgx\.c,v
d4595 2
a4596 2
\*\*\* rgx\.c	${RFCDATE}	1\.1
--- rgx\.c	${RFCDATE}
d4625 1
a4625 1
"Directory ${CVSROOT_DIRNAME}.*/first-dir added to the repository"
d4637 1
a4637 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4640 1
a4640 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4646 1
a4646 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4656 1
a4656 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d4667 1
a4667 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4672 1
a4672 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4694 1
a4694 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file2
d4725 1
a4725 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file2
d4740 1
a4740 1
	  if $keep; then
d4760 1
a4760 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4763 1
a4763 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4777 1
a4777 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4784 1
a4784 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d4795 1
a4795 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d4823 1
a4823 1
	  if $keep; then
d4904 1
a4904 1
${CVSROOT_DIRNAME}/first-dir/imported-f1,v  <--  imported-f1
d4908 1
a4908 1
${CVSROOT_DIRNAME}/first-dir/imported-f2,v  <--  imported-f2
d4915 1
a4915 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/imported-f1,v
d4958 1
a4958 1
${CVSROOT_DIRNAME}/first-dir/imported-f4,v  <--  imported-f4
d4964 1
a4964 1
"${PROG} [a-z]*: imported-f1 is no longer in the repository
d5018 1
a5018 1
"${PROG} [a-z]*: imported-f1 is no longer in the repository
d5026 1
a5026 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/imported-f2,v
d5122 1
a5122 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d5185 7
a5191 7
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/adir
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/adir/sub1
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/adir/sub1/ssdir
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/adir/sub2
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/bdir
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/bdir/subdir
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/first-dir/cdir"
d5214 1
a5214 8
	  if $remote; then
	    # Remote doesn't have the bug in the first place.
	    dotest importc-7r "${testcvs} -q ci -m modify -r wip_test" \
"Checking in cdir/cfile;
${CVSROOT_DIRNAME}/first-dir/cdir/cfile,v  <--  cfile
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done"
	  else
d5224 8
a5231 1
${CVSROOT_DIRNAME}/first-dir/cdir/cfile,v  <--  cfile
d5239 1
a5239 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/cdir/cfile,v
d5269 1
a5269 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/bdir/subdir/file1,v
d5331 2
a5332 1
	  dotest import-after-initial-3 "${testcvs} -Q add $file" ""
d5334 1
a5334 1
"RCS file: ${CVSROOT_DIRNAME}/$module/$file,v
d5337 1
a5337 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d5456 1
a5456 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file3,v
d5459 1
a5459 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d5462 1
a5462 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file4,v
d5465 1
a5465 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d5468 1
a5468 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file6,v
d5471 1
a5471 1
${CVSROOT_DIRNAME}/first-dir/file6,v  <--  file6
d5474 1
a5474 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file8,v
d5477 1
a5477 1
${CVSROOT_DIRNAME}/first-dir/file8,v  <--  file8
d5502 1
a5502 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d5505 1
a5505 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d5509 1
a5509 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d5513 1
a5513 1
${CVSROOT_DIRNAME}/first-dir/file6,v  <--  file6
d5516 1
a5516 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file7,v
d5519 1
a5519 1
${CVSROOT_DIRNAME}/first-dir/file7,v  <--  file7
d5523 1
a5523 1
${CVSROOT_DIRNAME}/first-dir/file8,v  <--  file8
d5550 1
a5550 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d5554 1
a5554 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d5557 1
a5557 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file5,v
d5560 1
a5560 1
${CVSROOT_DIRNAME}/first-dir/Attic/file5,v  <--  file5
d5564 1
a5564 1
${CVSROOT_DIRNAME}/first-dir/Attic/file6,v  <--  file6
d5591 1
a5591 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/file1,v
d5594 1
a5594 1
${CVSROOT_DIRNAME}/first-dir/Attic/file1,v  <--  file1
d5598 1
a5598 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d5602 1
a5602 1
${CVSROOT_DIRNAME}/first-dir/file3,v  <--  file3
d5606 1
a5606 1
${CVSROOT_DIRNAME}/first-dir/file4,v  <--  file4
d5610 1
a5610 1
${CVSROOT_DIRNAME}/first-dir/Attic/file5,v  <--  file5
d5614 1
a5614 1
${CVSROOT_DIRNAME}/first-dir/Attic/file6,v  <--  file6
d5677 1
a5677 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d5711 1
a5711 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d5749 1
a5749 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
a5762 35
	  # Checkout the mainline again to try updating and merging between two
	  # branches in the same step
	  # this seems a likely scenario - the user finishes up on branch and
	  # updates to br2 and merges in the same step - and there was a bug
	  # once that if the file was removed in the update then it wouldn't be
	  # readded in the merge
	  cd ..
	  rm -r first-dir
	  dotest join-twobranch-1 "${testcvs} -q co -rbranch first-dir" \
'U first-dir/file1
U first-dir/file2
U first-dir/file8'
	  cd first-dir
	  dotest join-twobranch-2 "${testcvs} -q update -rbr2 -jbranch" \
"cvs [a-z]*: file1 is no longer in the repository
U file1
U file2
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into file2
U file3
${PROG} [a-z]*: scheduling file3 for removal
U file4
${PROG} [a-z]*: file file4 has been modified, but has been removed in revision branch
U file7
${PROG} [a-z]*: file8 is no longer in the repository
U file8"
	  # Verify that the right changes have been scheduled.
	  dotest join-twobranch-3 "${testcvs} -q update" \
"A file1
M file2
R file3
A file8"

d5785 1
a5785 1
${CVSROOT_DIRNAME}/first-dir/file7,v  <--  file7
d5811 1
a5811 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file7,v
d5835 1
a5835 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d5842 1
a5842 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d5845 1
a5845 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5856 1
a5856 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/bradd,v
d5859 1
a5859 1
${CVSROOT_DIRNAME}/first-dir/Attic/bradd,v  <--  bradd
d5863 1
a5863 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5875 1
a5875 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d5882 1
a5882 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d5894 1
a5894 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/file1,v
d5902 1
a5902 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5919 1
a5919 1
"${PROG} [a-z]*: bradd is no longer in the repository
d5929 1
a5929 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/Attic/bradd,v
d5935 1
a5935 1
${CVSROOT_DIRNAME}/first-dir/bradd,v  <--  bradd
d5952 1
a5952 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d5959 1
a5959 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d5962 1
a5962 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5970 1
a5970 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5985 1
a5985 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d5988 1
a5988 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d5991 1
a5991 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d6001 1
a6001 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d6023 1
a6023 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d6034 1
a6034 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
a6053 3
	  # Previously, only tests 1 & 11 were being tested.  I added the
	  # intermediate dotest's to try and diagnose a different failure
	  #
d6061 1
a6061 1
	  mkdir join-readonly-conflict; cd join-readonly-conflict
d6063 1
a6063 1
	  module=join-readonly-conflict
d6070 2
a6071 9
	  dotest join-readonly-conflict-2 "$testcvs -Q add $file" ''

	  dotest join-readonly-conflict-3 "$testcvs -q ci -m . $file" \
"RCS file: $CVSROOT_DIRNAME/$module/$file,v
done
Checking in $file;
$CVSROOT_DIRNAME/$module/$file,v  <--  $file
initial revision: 1\.1
done"
d6073 2
a6074 2
	  dotest join-readonly-conflict-4 "$testcvs tag -b B $file" "T $file"
	  dotest join-readonly-conflict-5 "$testcvs -q update -rB $file" ''
d6076 1
a6076 5
	  dotest join-readonly-conflict-6 "$testcvs -q ci -m . $file" \
"Checking in $file;
$CVSROOT_DIRNAME/$module/$file,v  <--  $file
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
d6079 1
a6079 1
	  dotest join-readonly-conflict-7 "$testcvs -Q update -A $file" ''
d6084 1
a6084 8
	  dotest join-readonly-conflict-8 "$testcvs update -r B $file" \
"RCS file: $CVSROOT_DIRNAME/$module/$file,v
retrieving revision 1\.1
retrieving revision 1\.1\.2\.1
Merging differences between 1\.1 and 1\.1\.2\.1 into $file
rcsmerge: warning: conflicts during merge
$PROG [a-z]*: conflicts found in $file
C $file"
a6085 1
	  # restore to the trunk
d6087 1
a6087 2
	  dotest join-readonly-conflict-9 "$testcvs -Q update -A $file" ''

d6092 3
a6094 8
	  # verify that the backup file is writable
	  if test -w ".#$file.1.1"; then
	    fail "join-readonly-conflict-10 : .#$file.1.1 is writable"
	  else
	    pass "join-readonly-conflict-10"
	  fi
	  dotest join-readonly-conflict-11 "$testcvs update -r B $file" \
"RCS file: $CVSROOT_DIRNAME/$module/$file,v
d6099 1
a6099 1
$PROG [a-z]*: conflicts found in $file
d6103 2
a6104 4
	  if $keep; then :; else
	    rm -rf join-readonly-conflict
	    rm -rf $CVSROOT_DIRNAME/$module
	  fi
d6140 1
a6140 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/x/b,v
a6149 81
	join-admin-2)
	  # Show that when a merge (via update -kk -jtag1 -jtag2) first
	  # removes a file, then modifies another containing an $Id...$ line,
	  # the resulting file contains the unexpanded `$Id.$' string, as
	  # -kk requires.
	  mkdir 1; cd 1
	  dotest join-admin-2-1 "$testcvs -q co -l ." ''
	  module=x
	  mkdir $module
	  dotest join-admin-2-2 "$testcvs -q add $module" \
"Directory ${CVSROOT_DIRNAME}/x added to the repository"
	  cd $module

	  # Create a file so applying the first tag works.
	  echo '$''Id$' > e0
	  cp e0 e
	  dotest join-admin-2-3 "$testcvs -Q add e" ''
	  dotest join-admin-2-4 "$testcvs -Q ci -m. e" \
"RCS file: ${CVSROOT_DIRNAME}/x/e,v
done
Checking in e;
${CVSROOT_DIRNAME}/x/e,v  <--  e
initial revision: 1\.1
done"

	  dotest join-admin-2-5 "$testcvs -Q tag -b T" '' "${QUESTION} e0"
	  dotest join-admin-2-6 "$testcvs -Q update -r T" '' "${QUESTION} e0"
	  cp e0 e
	  dotest join-admin-2-7 "$testcvs -Q ci -m. e" \
"Checking in e;
${CVSROOT_DIRNAME}/x/e,v  <--  e
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"

	  dotest join-admin-2-8 "$testcvs -Q update -A" '' "${QUESTION} e0"
	  dotest join-admin-2-9 "$testcvs -Q tag -b M1" '' "${QUESTION} e0"

	  echo '$''Id$' > b
	  dotest join-admin-2-10 "$testcvs -Q add b" ''
	  cp e0 e
	  dotest join-admin-2-11 "$testcvs -Q ci -m. b e" \
"RCS file: ${CVSROOT_DIRNAME}/x/b,v
done
Checking in b;
${CVSROOT_DIRNAME}/x/b,v  <--  b
initial revision: 1\.1
done
Checking in e;
${CVSROOT_DIRNAME}/x/e,v  <--  e
new revision: 1\.2; previous revision: 1\.1
done"

	  dotest join-admin-2-12 "$testcvs -Q tag -b M2" '' "${QUESTION} e0"

	  dotest join-admin-2-13 "$testcvs -Q update -r T" '' "${QUESTION} e0"
	  dotest join-admin-2-14 "$testcvs update -kk -jM1 -jM2" \
"${PROG} [a-z]*: Updating .
U b
U e
RCS file: ${CVSROOT_DIRNAME}/x/e,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into e
${QUESTION} e0" \
"${QUESTION} e0
${PROG} [a-z]*: Updating .
U b
U e
RCS file: ${CVSROOT_DIRNAME}/x/e,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into e"

	  # Verify that the $Id.$ string is not expanded.
	  dotest join-admin-2-15 "cat e" '$''Id$'

	  cd ../..
	  rm -rf 1
	  rm -rf ${CVSROOT_DIRNAME}/$module
	  ;;

d6221 1
a6221 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6224 1
a6224 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6252 1
a6252 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6266 1
a6266 1
	  # "Entry Invalid" is a rather strange output here.  Something like
d6268 2
d6271 10
a6280 3
"${PROG} [a-z]*: a is no longer in the repository
===================================================================
File: a                	Status: Entry Invalid
d6283 1
a6283 1
   Repository revision:	1\.1\.2\.1	${CVSROOT_DIRNAME}/first-dir/a,v
d6288 1
a6288 1
"${PROG} [a-z]*: a is no longer in the repository"
d6316 1
a6316 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6319 1
a6319 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6327 2
d6333 1
a6333 1
RCS:  ${CVSROOT_DIRNAME}/first-dir/a,v
d6352 1
a6352 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir1 added to the repository"
d6355 1
a6355 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6364 2
d6370 1
a6370 1
RCS:  ${CVSROOT_DIRNAME}/first-dir/a,v
d6391 1
a6391 1
   Repository revision:	1\.2	${CVSROOT_DIRNAME}/first-dir/a,v
d6396 1
a6396 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6404 1
a6404 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6415 1
a6415 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6429 1
a6429 1
   Repository revision:	1\.2	${CVSROOT_DIRNAME}/first-dir/a,v
d6459 1
a6459 1
   Repository revision:	1\.2	${CVSROOT_DIRNAME}/first-dir/a,v
d6466 1
a6466 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6478 1
a6478 1
   Repository revision:	1\.3	${CVSROOT_DIRNAME}/first-dir/a,v
d6484 1
a6484 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6492 1
a6492 1
   Repository revision:	1\.4	${CVSROOT_DIRNAME}/first-dir/a,v
d6587 1
a6587 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a,v
d6590 1
a6590 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6593 1
a6593 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/abc,v
d6596 1
a6596 1
${CVSROOT_DIRNAME}/first-dir/abc,v  <--  abc
d6618 1
a6618 1
${CVSROOT_DIRNAME}/first-dir/a,v  <--  a
d6641 1
a6641 7
	  if $remote; then
	    # Haven't investigated this one.
	    dotest_fail conflicts2-142b8 "${testcvs} add first-dir/a" \
"${PROG} add: in directory \.:
${PROG} \[add aborted\]: there is no version here; do '${PROG} checkout' first"
	    cd first-dir
	  else
d6659 6
d6685 1
a6685 1
${CVSROOT_DIRNAME}/first-dir/abc,v  <--  abc
d6707 1
a6707 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa\.c,v
d6710 1
a6710 1
${CVSROOT_DIRNAME}/first-dir/aa\.c,v  <--  aa\.c
d6713 1
a6713 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/same\.c,v
d6716 1
a6716 1
${CVSROOT_DIRNAME}/first-dir/same\.c,v  <--  same\.c
d6729 1
a6729 1
	  if $remote; then
d6749 1
a6749 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/aa\.c,v"
d6792 1
a6792 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d6803 1
a6803 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d6806 1
a6806 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d6809 1
a6809 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d6812 1
a6812 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d6834 1
a6834 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d6838 1
a6838 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d6843 2
a6844 2
"${PROG} [a-z]*: file1 is no longer in the repository
${PROG} [a-z]*: file2 is no longer in the repository"
d6846 2
a6847 2
"${PROG} [a-z]*: file1 is no longer in the repository
${PROG} [a-z]*: file2 is no longer in the repository"
d6853 1
a6853 1
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository"
d6859 1
a6859 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir/sfile,v
d6862 1
a6862 1
${CVSROOT_DIRNAME}/first-dir/sdir/sfile,v  <--  sfile
d6879 1
a6879 1
	  if $remote; then
d6926 6
a6931 1
	  if $remote; then
d6934 2
d6957 1
a6957 1
${CVSROOT_DIRNAME}/first-dir/sdir/sfile,v  <--  sfile
d6962 9
a6970 1
	  dotest conflicts3-28 "${testcvs} -q update -PdA" \
d6972 1
d6986 1
a6986 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d6993 1
a6993 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/cleanme\.txt,v
d6996 1
a6996 1
${CVSROOT_DIRNAME}/first-dir/cleanme\.txt,v  <--  cleanme\.txt
a7029 28
	  # Now try with conflicts
	  cd ..
	  dotest clean-15 "${testcvs} -q co -d second-dir first-dir" \
'U second-dir/cleanme\.txt'
	  cd second-dir
	  echo "conflict test" >> cleanme.txt
	  dotest clean-16 "${testcvs} -q ci -m." \
"Checking in cleanme\.txt;
${CVSROOT_DIRNAME}/first-dir/cleanme\.txt,v  <--  cleanme\.txt
new revision: 1\.2; previous revision: 1\.1
done"
	  cd ../first-dir
	  echo "fish" >> cleanme.txt
	  dotest clean-17 "${testcvs} -nq update" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/cleanme\.txt,v
retrieving revision 1\.1
retrieving revision 1\.2
Merging differences between 1\.1 and 1\.2 into cleanme\.txt
rcsmerge: warning: conflicts during merge
${PROG} [a-z]*: conflicts found in cleanme\.txt
C cleanme\.txt"
	  dotest clean-18 "${testcvs} -q update -C" \
"(Locally modified cleanme\.txt moved to \.#cleanme\.txt\.1\.1)
U cleanme\.txt"
	  dotest clean-19 "cat .#cleanme.txt.1.1" \
"The usual boring test text\.
fish"
	  
d7033 1
a7033 1
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
d7072 1
a7072 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7096 1
a7096 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7123 1
a7123 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7145 1
a7145 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir added to the repository"
d7150 1
a7150 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir/ssdir added to the repository"
d7162 1
a7162 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/a,v
d7165 1
a7165 1
${CVSROOT_DIRNAME}/first-dir/subdir/a,v  <--  a
d7168 1
a7168 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/b,v
d7171 1
a7171 1
${CVSROOT_DIRNAME}/first-dir/subdir/b,v  <--  b
d7211 1
a7211 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7340 1
a7340 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d7343 1
a7343 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d7346 1
a7346 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d7349 1
a7349 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d7366 1
a7366 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d7388 3
a7390 3
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository
Directory ${CVSROOT_DIRNAME}/second-dir added to the repository
Directory ${CVSROOT_DIRNAME}/third-dir added to the repository"
d7397 1
a7397 1
"RCS file: ${CVSROOT_DIRNAME}/third-dir/file3,v
d7400 1
a7400 1
${CVSROOT_DIRNAME}/third-dir/file3,v  <--  file3
d7412 4
a7415 8
	  cat >> modules << EOF
ampermodule &first-dir &second-dir
combmodule third-dir file3 &first-dir
ampdirmod -d newdir &first-dir &second-dir
badmod -d newdir
messymod first-dir &messymodchild
messymodchild -d sdir/child second-dir
EOF
d7420 1
a7420 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
a7447 20
	  # There used to be a nasty-hack that made CVS skip creation of the
	  # module dir (in this case ampermodule) when -n was specified
	  dotest modules2-ampermod-1 "${testcvs} -q co -n ampermodule" ''
	  dotest modules2-ampermod-2 "test -d ampermodule/first-dir" ''
	  dotest modules2-ampermod-3 "test -d ampermodule/second-dir" ''

	  # Test release of a module
	  if echo yes |${testcvs} release -d ampermodule >>${LOGFILE}; then
	    pass modules2-ampermod-release-1
	  else
	    fail modules2-ampermod-release-1
	  fi
	  dotest_fail modules2-ampermod-release-2 "test -d ampermodule" ''

	  # and the '-n' test again, but in conjunction with '-d'
	  dotest modules2-ampermod-4 "${testcvs} -q co -n -d newname ampermodule" ''
	  dotest modules2-ampermod-5 "test -d newname/first-dir" ''
	  dotest modules2-ampermod-6 "test -d newname/second-dir" ''
	  rm -rf newname

d7471 1
a7471 1
	  if $remote; then
d7473 1
a7473 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/amper1,v
d7476 1
a7476 1
${CVSROOT_DIRNAME}/first-dir/amper1,v  <--  amper1
d7484 1
a7484 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/amper1,v
d7487 1
a7487 1
${CVSROOT_DIRNAME}/first-dir/amper1,v  <--  amper1
d7532 1
a7532 2
	  dotest modules2-22 "test -d newdir/second-dir" ""
	  dotest_fail modules2-23 "${testcvs} co badmod" \
a7538 47
	  # Confirm that a rename with added depth nested in an ampersand
	  # module works.
	  mkdir 1; cd 1
	  dotest modules2-nestedrename-1 "${testcvs} -q co messymod" \
"U messymod/amper1"
	  dotest modules2-nestedrename-2 "test -d messymod/sdir" ''
	  dotest modules2-nestedrename-3 "test -d messymod/sdir/CVS" ''
	  dotest modules2-nestedrename-4 "test -d messymod/sdir/child" ''
	  dotest modules2-nestedrename-5 "test -d messymod/sdir/child/CVS" ''
	  cd ..; rm -r 1

	  # FIXME:  client/server has a bug.  It should be working like a local
	  # repository in this case, but fails to check out the second module
	  # in the list when a branch is specified.
	  mkdir 1; cd 1
	  dotest modules2-ampertag-setup-1 \
"${testcvs} -Q rtag tag first-dir second-dir third-dir" \
''
	  dotest modules2-ampertag-1 "${testcvs} -q co -rtag ampermodule" \
"U first-dir/amper1"
	  if $remote; then
	    dotest_fail modules2-ampertag-2 "test -d ampermodule/second-dir" ''
	    dotest_fail modules2-ampertag-3 "test -d ampermodule/second-dir/CVS" ''
	  else
	    dotest modules2-ampertag-2 "test -d ampermodule/second-dir" ''
	    dotest modules2-ampertag-3 "test -d ampermodule/second-dir/CVS" ''
	  fi
	  cd ..; rm -r 1

	  # Test for tag files when an ampermod is renamed with more path
	  # elements than it started with.
	  #
	  # FIXME: This is currently broken in the remote case, possibly only
	  # because the messymodchild isn't being checked out at all.
	  mkdir 1; cd 1
#	  dotest modules2-tagfiles-setup-1 \
#"${testcvs} -Q rtag -b branch first-dir second-dir" \
#''
	  dotest modules2-tagfiles-1 "${testcvs} -q co -rtag messymod" \
"U messymod/amper1"
	  if $remote; then
	    dotest_fail modules2-tagfiles-2r "test -d messymod/sdir" ''
	  else
	    dotest modules2-tagfiles-2 "cat messymod/sdir/CVS/Tag" 'Ttag'
	  fi
	  cd ..; rm -r 1

d7551 1
a7551 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
a7559 1
	  cd ..;  rm -r 1
d7562 3
d7580 1
a7580 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d7588 1
a7588 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d7591 1
a7591 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d7610 1
a7610 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7630 2
a7631 2
"${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/second-dir/suba
${PROG} [a-z]*: Importing ${CVSROOT_DIRNAME}/second-dir/suba/subb
d7643 1
a7643 1
	  if $remote; then
d7647 1
a7647 1
"Directory ${CVSROOT_DIRNAME}/second-dir/suba added to the repository"
d7651 1
a7651 1
"Directory ${CVSROOT_DIRNAME}/second-dir/suba/subb added to the repository"
d7661 1
a7661 1
"RCS file: ${CVSROOT_DIRNAME}/second-dir/suba/subb/fileb,v
d7664 1
a7664 1
${CVSROOT_DIRNAME}/second-dir/suba/subb/fileb,v  <--  fileb
d7689 1
a7689 1
	  if $remote; then
d7711 3
a7713 3
	  if $remote; then :; else
	    mkdir 1; cd 1
	    dotest modules3-12 "${testcvs} -q co path/in/modules" \
d7715 2
a7716 3
	    dotest modules3-13 "test -f path/in/modules/first-dir/file1" ''
	    cd ..; rm -r 1
	  fi # end of tests skipped for remote
d7718 1
a7718 1
	  # Now here is where it used to get seriously bogus.
d7722 1
a7722 1
	  # CVS used to create this even though rtag should *never* affect
d7724 3
a7726 3
	  dotest_fail modules3-15 "test -d path/in/modules" ''
	  # Just for trivia's sake, rdiff was not similarly vulnerable
	  # because it passed 0 for run_module_prog to do_module.
d7728 1
d7753 1
a7753 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d7758 1
a7758 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir added to the repository"
d7771 1
a7771 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d7774 1
a7774 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d7777 1
a7777 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/file2,v
d7780 1
a7780 1
${CVSROOT_DIRNAME}/first-dir/subdir/file2,v  <--  file2
d7796 1
a7796 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7814 1
a7814 5
	  if $remote; then
	    # But remote seems to do it the other way.
	    dotest modules4-11a "${testcvs} -q co somewhat" "U first-dir/file1"
	    dotest_fail modules4-11b "test -d first-dir/subdir" ''
	  else
d7822 4
d7838 1
a7838 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/file2,v
d7870 1
a7870 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir added to the repository"
d7874 1
a7874 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir/ssdir added to the repository"
d7884 1
a7884 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/a,v
d7887 1
a7887 1
${CVSROOT_DIRNAME}/first-dir/subdir/a,v  <--  a
d7890 1
a7890 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/b,v
d7893 1
a7893 1
${CVSROOT_DIRNAME}/first-dir/subdir/b,v  <--  b
d7930 1
a7930 1
${CVSROOT_DIRNAME}/CVSROOT/modules,v  <--  modules
d7938 1
a7938 1
	  if $remote; then
d7953 1
a7953 1
	  if $remote; then
a7992 2
args: realmodule MYTAG" \
"tag script invoked in $tmp/cvs-serv[0-9a-z]*
d7994 1
a7994 1
	  if $remote; then
d8013 1
a8013 1
	  if $remote; then :; else
d8152 1
a8152 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d8225 6
a8230 6
"Directory ${CVSROOT_DIRNAME}/mod1 added to the repository
Directory ${CVSROOT_DIRNAME}/mod1-2 added to the repository
Directory ${CVSROOT_DIRNAME}/mod2 added to the repository
Directory ${CVSROOT_DIRNAME}/mod2/sub2 added to the repository
Directory ${CVSROOT_DIRNAME}/mod2-2 added to the repository
Directory ${CVSROOT_DIRNAME}/mod2-2/sub2-2 added to the repository"
d8330 1
a8330 1
"${AREP}\."
d8341 1
a8341 1
"${AREP}mod2"
d8431 1
a8431 1
"${AREP}."
d8449 1
a8449 1
"${AREP}mod2"
d8519 1
a8519 1
"${AREP}."
d8537 1
a8537 1
"${AREP}mod2"
d8590 1
a8590 1
"${AREP}\."
d8608 1
a8608 1
"${AREP}mod2"
d8645 1
a8645 1
"${AREP}\."
d8663 1
a8663 1
"${AREP}mod2"
d8681 1
a8681 1
"${AREP}\."
d8686 1
a8686 1
"${AREP}\."
d8701 1
a8701 1
"${AREP}\."
d8706 1
a8706 1
"${AREP}mod2"
d8724 1
a8724 1
"${AREP}mod2"
d8729 1
a8729 1
"${AREP}mod2-2"
d8888 1
a8888 1
"${AREP}\."
d8908 1
a8908 1
"${AREP}mod2"
d8925 1
a8925 1
"${AREP}mod2"
d8943 1
a8943 1
"${AREP}mod2"
d8961 1
a8961 1
"${AREP}mod2"
d8979 1
a8979 1
"${AREP}mod2"
d8985 1
a8985 1
"${AREP}\."
d8999 1
a8999 1
"${AREP}mod2"
d9005 1
a9005 1
"${AREP}mod2"
d9064 1
a9064 1
"${AREP}\."
d9084 1
a9084 1
"${AREP}mod2"
d9101 1
a9101 1
"${AREP}mod2"
d9119 1
a9119 1
"${AREP}mod2"
d9125 1
a9125 1
"${AREP}\."
d9139 1
a9139 1
"${AREP}mod2"
d9145 1
a9145 1
"${AREP}mod2"
d9162 1
a9162 1
"${AREP}CVSROOT/Emptydir"
d9165 1
a9165 1
"${AREP}\."
d9170 1
a9170 1
"${AREP}\."
d9184 1
a9184 1
"${AREP}CVSROOT/Emptydir"
d9187 1
a9187 1
"${AREP}\."
d9192 1
a9192 1
"${AREP}mod2"
d9212 1
a9212 1
"${AREP}mod2"
d9217 1
a9217 1
"${AREP}mod2-2"
d9231 3
a9233 3
	  if $remote; then :; else
	    # Remote can't handle this, even with the "mkdir dir".
	    # This was also true of CVS 1.9.
d9235 2
a9236 2
	    mkdir dir
	    dotest cvsadm-2d3 "${testcvs} co -d dir/dir2 1mod" \
d9239 1
a9239 1
	    dotest cvsadm-2d3b "cat CVS/Repository" \
d9241 2
a9242 2
	    dotest_fail cvsadm-2d3d "test -f dir/CVS/Repository" ""
	    dotest cvsadm-2d3f "cat dir/dir2/CVS/Repository" \
d9244 1
a9244 1
	    rm -rf CVS dir
d9246 2
a9247 2
	    mkdir dir
	    dotest cvsadm-2d4 "${testcvs} co -d dir/dir2 2mod" \
d9250 1
a9250 1
	    dotest cvsadm-2d4b "cat CVS/Repository" \
d9252 1
a9252 1
	    dotest cvsadm-2d4f "cat dir/dir2/CVS/Repository" \
d9254 1
a9254 1
	    rm -rf CVS dir
d9256 2
a9257 2
	    mkdir dir
	    dotest cvsadm-2d5 "${testcvs} co -d dir/dir2 1d1mod" \
d9260 1
a9260 1
	    dotest cvsadm-2d5b "cat CVS/Repository" \
d9262 1
a9262 1
	    dotest cvsadm-2d5f "cat dir/dir2/CVS/Repository" \
d9264 1
a9264 1
	    rm -rf CVS dir
d9266 2
a9267 2
	    mkdir dir
	    dotest cvsadm-2d6 "${testcvs} co -d dir/dir2 1d2mod" \
d9270 1
a9270 1
	    dotest cvsadm-2d6b "cat CVS/Repository" \
d9272 1
a9272 1
	    dotest cvsadm-2d6f "cat dir/dir2/CVS/Repository" \
d9274 1
a9274 1
	    rm -rf CVS dir
d9276 2
a9277 2
	    mkdir dir
	    dotest cvsadm-2d7 "${testcvs} co -d dir/dir2 2d1mod" \
d9280 1
a9280 1
	    dotest cvsadm-2d7b "cat CVS/Repository" \
d9282 1
a9282 1
	    dotest cvsadm-2d7f "cat dir/dir2/CVS/Repository" \
d9284 1
a9284 1
	    rm -rf CVS dir
d9286 2
a9287 2
	    mkdir dir
	    dotest cvsadm-2d8 "${testcvs} co -d dir/dir2 2d2mod" \
d9290 1
a9290 1
	    dotest cvsadm-2d8b "cat CVS/Repository" \
d9292 1
a9292 1
	    dotest cvsadm-2d8f "cat dir/dir2/CVS/Repository" \
d9294 1
a9294 1
	    rm -rf CVS dir
d9296 4
a9299 4
	    ##################################################
	    ## And now, a few of those tests revisited to
	    ## test the behavior of the -N flag.
	    ##################################################
d9301 1
a9301 1
	    dotest cvsadm-N3 "${testcvs} co -N 1mod" \
d9304 1
a9304 1
	    dotest cvsadm-N3b "cat CVS/Repository" \
d9306 1
a9306 1
	    dotest cvsadm-N3d "cat 1mod/CVS/Repository" \
d9308 1
a9308 1
	    rm -rf CVS 1mod
d9310 1
a9310 1
	    dotest cvsadm-N4 "${testcvs} co -N 2mod" \
d9313 1
a9313 1
	    dotest cvsadm-N4b "cat CVS/Repository" \
d9315 1
a9315 1
	    dotest cvsadm-N4d "cat 2mod/CVS/Repository" \
d9317 1
a9317 1
	    rm -rf CVS 2mod
d9319 1
a9319 1
	    dotest cvsadm-N5 "${testcvs} co -N 1d1mod" \
d9322 1
a9322 1
	    dotest cvsadm-N5b "cat CVS/Repository" \
d9324 1
a9324 1
	    dotest cvsadm-N5d "cat dir1d1/CVS/Repository" \
d9326 1
a9326 1
	    rm -rf CVS dir1d1
d9328 1
a9328 1
	    dotest cvsadm-N6 "${testcvs} co -N 1d2mod" \
d9331 1
a9331 1
	    dotest cvsadm-N6b "cat CVS/Repository" \
d9333 1
a9333 1
	    dotest cvsadm-N6d "cat dir1d2/CVS/Repository" \
d9335 1
a9335 1
	    rm -rf CVS dir1d2
d9337 1
a9337 1
	    dotest cvsadm-N7 "${testcvs} co -N 2d1mod" \
d9340 1
a9340 1
	    dotest cvsadm-N7b "cat CVS/Repository" \
d9342 3
a9344 3
	    dotest cvsadm-N7d "cat dir2d1/CVS/Repository" \
"${AREP}\."
	    dotest cvsadm-N7f "cat dir2d1/sub2d1/CVS/Repository" \
d9346 1
a9346 1
	    rm -rf CVS dir2d1
d9348 1
a9348 1
	    dotest cvsadm-N8 "${testcvs} co -N 2d2mod" \
d9351 1
a9351 1
	    dotest cvsadm-N8b "cat CVS/Repository" \
d9353 3
a9355 3
	    dotest cvsadm-N8d "cat dir2d2/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N8f "cat dir2d2/sub2d2/CVS/Repository" \
d9357 1
a9357 1
	    rm -rf CVS dir2d2
d9359 1
a9359 1
	    ## the ones in one-deep directories
d9361 1
a9361 1
	    dotest cvsadm-N1d3 "${testcvs} co -N -d dir 1mod" \
d9364 1
a9364 1
	    dotest cvsadm-N1d3b "cat CVS/Repository" \
d9366 1
a9366 1
	    dotest cvsadm-N1d3d "cat dir/CVS/Repository" \
d9368 1
a9368 1
	    dotest cvsadm-N1d3f "cat dir/1mod/CVS/Repository" \
d9370 1
a9370 1
	    rm -rf CVS dir
d9372 1
a9372 1
	    dotest cvsadm-N1d4 "${testcvs} co -N -d dir 2mod" \
d9375 3
a9377 1
	    dotest cvsadm-N1d4b "cat CVS/Repository" \
d9379 1
a9379 3
	    dotest cvsadm-N1d4d "cat dir/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N1d4f "cat dir/2mod/CVS/Repository" \
d9381 1
a9381 1
	    rm -rf CVS dir
d9383 1
a9383 1
	    dotest cvsadm-N1d5 "${testcvs} co -N -d dir 1d1mod" \
d9386 1
a9386 1
	    dotest cvsadm-N1d5b "cat CVS/Repository" \
d9388 1
a9388 1
	    dotest cvsadm-N1d5d "cat dir/CVS/Repository" \
d9390 1
a9390 1
	    dotest cvsadm-N1d5d "cat dir/dir1d1/CVS/Repository" \
d9392 1
a9392 1
	    rm -rf CVS dir
d9394 1
a9394 1
	    dotest cvsadm-N1d6 "${testcvs} co -N -d dir 1d2mod" \
d9397 3
a9399 1
	    dotest cvsadm-N1d6b "cat CVS/Repository" \
d9401 1
a9401 3
	    dotest cvsadm-N1d6d "cat dir/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N1d6f "cat dir/dir1d2/CVS/Repository" \
d9403 1
a9403 1
	    rm -rf CVS dir
d9405 1
a9405 1
	    dotest cvsadm-N1d7 "${testcvs} co -N -d dir 2d1mod" \
d9408 1
a9408 1
	    dotest cvsadm-N1d7b "cat CVS/Repository" \
d9410 3
a9412 1
	    dotest cvsadm-N1d7d "cat dir/CVS/Repository" \
d9414 1
a9414 3
	    dotest cvsadm-N1d7f "cat dir/dir2d1/CVS/Repository" \
"${AREP}\."
	    dotest cvsadm-N1d7h "cat dir/dir2d1/sub2d1/CVS/Repository" \
d9416 1
a9416 1
	    rm -rf CVS dir
d9418 1
a9418 1
	    dotest cvsadm-N1d8 "${testcvs} co -N -d dir 2d2mod" \
d9421 1
a9421 1
	    dotest cvsadm-N1d8b "cat CVS/Repository" \
d9423 1
a9423 1
	    dotest cvsadm-N1d8d "cat dir/CVS/Repository" \
d9425 3
a9427 3
	    dotest cvsadm-N1d8d "cat dir/dir2d2/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N1d8d "cat dir/dir2d2/sub2d2/CVS/Repository" \
d9429 1
a9429 1
	    rm -rf CVS dir
d9431 1
a9431 1
	    ## the ones in two-deep directories
d9433 2
a9434 2
	    mkdir dir
	    dotest cvsadm-N2d3 "${testcvs} co -N -d dir/dir2 1mod" \
d9437 1
a9437 1
	    dotest cvsadm-N2d3b "cat CVS/Repository" \
d9439 1
a9439 1
	    dotest cvsadm-N2d3f "cat dir/dir2/CVS/Repository" \
d9441 1
a9441 1
	    dotest cvsadm-N2d3h "cat dir/dir2/1mod/CVS/Repository" \
d9443 1
a9443 1
	    rm -rf CVS dir
d9445 2
a9446 2
	    mkdir dir
	    dotest cvsadm-N2d4 "${testcvs} co -N -d dir/dir2 2mod" \
d9449 3
a9451 1
	    dotest cvsadm-N2d4b "cat CVS/Repository" \
d9453 1
a9453 3
	    dotest cvsadm-N2d4f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N2d4h "cat dir/dir2/2mod/CVS/Repository" \
d9455 1
a9455 1
	    rm -rf CVS dir
d9457 2
a9458 2
	    mkdir dir
	    dotest cvsadm-N2d5 "${testcvs} co -N -d dir/dir2 1d1mod" \
d9461 1
a9461 1
	    dotest cvsadm-N2d5b "cat CVS/Repository" \
d9463 1
a9463 1
	    dotest cvsadm-N2d5f "cat dir/dir2/CVS/Repository" \
d9465 1
a9465 1
	    dotest cvsadm-N2d5h "cat dir/dir2/dir1d1/CVS/Repository" \
d9467 1
a9467 1
	    rm -rf CVS dir
d9469 2
a9470 2
	    mkdir dir
	    dotest cvsadm-N2d6 "${testcvs} co -N -d dir/dir2 1d2mod" \
d9473 3
a9475 1
	    dotest cvsadm-N2d6b "cat CVS/Repository" \
d9477 1
a9477 3
	    dotest cvsadm-N2d6f "cat dir/dir2/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N2d6h "cat dir/dir2/dir1d2/CVS/Repository" \
d9479 1
a9479 1
	    rm -rf CVS dir
d9481 2
a9482 2
	    mkdir dir
	    dotest cvsadm-N2d7 "${testcvs} co -N -d dir/dir2 2d1mod" \
d9485 3
a9487 1
	    dotest cvsadm-N2d7b "cat CVS/Repository" \
d9489 1
a9489 1
	    dotest cvsadm-N2d7f "cat dir/dir2/CVS/Repository" \
d9491 1
a9491 3
	    dotest cvsadm-N2d7g "cat dir/dir2/dir2d1/CVS/Repository" \
"${AREP}\."
	    dotest cvsadm-N2d7h "cat dir/dir2/dir2d1/sub2d1/CVS/Repository" \
d9493 1
a9493 1
	    rm -rf CVS dir
d9495 2
a9496 2
	    mkdir dir
	    dotest cvsadm-N2d8 "${testcvs} co -N -d dir/dir2 2d2mod" \
d9499 1
a9499 1
	    dotest cvsadm-N2d8b "cat CVS/Repository" \
d9501 1
a9501 1
	    dotest cvsadm-N2d8f "cat dir/dir2/CVS/Repository" \
d9503 3
a9505 3
	    dotest cvsadm-N2d8h "cat dir/dir2/dir2d2/CVS/Repository" \
"${AREP}mod2"
	    dotest cvsadm-N2d8j "cat dir/dir2/dir2d2/sub2d2/CVS/Repository" \
d9507 1
a9507 1
	    rm -rf CVS dir
d9521 1
a9521 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d9550 1
a9550 1
	  echo "2d1mod -d dir2d1/sub/sub2d1 mod1" >> CVSROOT/modules
d9552 1
a9552 2
	  echo "2d1modb -d dir2d1/suba mod1" >> CVSROOT/modules
	  echo "comb -a 2d1modb 2d1moda" >> CVSROOT/modules
d9573 1
a9573 1
"Directory ${CVSROOT_DIRNAME}/moda/modasub added to the repository"
d9596 2
a9597 2
"${PROG} [a-z]*: Updating dir2d1/sub/sub2d1
U dir2d1/sub/sub2d1/file1"
d9605 1
a9605 1
"${PROG} \[[a-z]* aborted\]: cannot add to ${CVSROOT_DIRNAME}/CVSROOT/Emptydir"
d9608 1
a9608 1
"${PROG} \[[a-z]* aborted\]: cannot add to ${CVSROOT_DIRNAME}/CVSROOT/Emptydir"
d9629 7
a9635 8
	  # OK, this is the crux of the matter.  This used to show "Emptydir",
	  # but everyone seemed to think it should show "moda".  This
	  # usually works better, but not always as shown by the following
	  # test.
	  dotest emptydir-13 "cat dir2d1/CVS/Repository" "moda"
	  dotest_fail emptydir-14 "${testcvs} co comb" \
"${PROG} [a-z]*: existing repository ${CVSROOT_DIRNAME}/moda/modasub does not match ${TESTDIR}/cvsroot/mod1
${PROG} [a-z]*: ignoring module 2d1modb
d9637 1
a9637 1
	  dotest emptydir-15 "cat dir2d1/CVS/Repository" "moda"
d9695 1
a9695 1
	  if $remote; then
d9702 1
a9702 1
	    dotest abspath-2a "${testcvs} co -d ${TESTDIR}/1 mod1" \
d9734 2
a9735 2
	  if $remote; then :; else
	    dotest_fail abspath-3.1 "${testcvs} co -d ${TESTDIR}/1/2 mod1" \
d9744 1
a9744 1
	  if $remote; then
d9777 2
a9778 2
	  if $remote; then
	    dotest_fail abspath-4r "${testcvs} co -d ${TESTDIR}/barf/sub mod1" \
d9790 2
a9791 2
	  if $remote; then
	    dotest abspath-5ar "${testcvs} co -d 1 mod1 mod2" \
d9814 2
a9815 2
	  if $remote; then
	    dotest abspath-6ar "${testcvs} co -d 1 ." \
d9848 2
a9849 2
	  if $remote; then
	    dotest_fail abspath-7ar "${testcvs} -q co -d ../2 mod2" \
d9853 1
a9853 1
	    dotest abspath-7a-try2r "${testcvs} -q co -d 2 mod2" \
d9857 1
a9857 1
	    dotest abspath-7a "${testcvs} -q co -d ${TESTDIR}/2 mod2" \
d9864 1
a9864 1
	  if $remote; then
d9866 1
a9866 1
	    dotest abspath-7dr "${testcvs} -q co -d 3 mod2" \
d9905 1
a9905 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d9916 2
a9917 2
"Directory ${CVSROOT_DIRNAME}/top-dir added to the repository
Directory ${CVSROOT_DIRNAME}/second-dir added to the repository"
d9925 1
a9925 1
"RCS file: ${CVSROOT_DIRNAME}/top-dir/file1,v
d9928 1
a9928 1
${CVSROOT_DIRNAME}/top-dir/file1,v  <--  file1
d9939 1
a9939 1
"RCS file: ${CVSROOT_DIRNAME}/second-dir/file2,v
d9942 1
a9942 1
${CVSROOT_DIRNAME}/second-dir/file2,v  <--  file2
a10000 1
${PROG} [a-z]*: warning: cannot make directory CVS in \.: Permission denied
d10013 1
a10013 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d10034 1
a10034 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d10046 2
a10047 2
"Directory ${CVSROOT_DIRNAME}/top-dir added to the repository
Directory ${CVSROOT_DIRNAME}/second-dir added to the repository"
d10055 1
a10055 1
"RCS file: ${CVSROOT_DIRNAME}/top-dir/file1,v
d10058 1
a10058 1
${CVSROOT_DIRNAME}/top-dir/file1,v  <--  file1
d10069 1
a10069 1
"RCS file: ${CVSROOT_DIRNAME}/second-dir/file2,v
d10072 1
a10072 1
${CVSROOT_DIRNAME}/second-dir/file2,v  <--  file2
d10109 1
a10109 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d10193 1
a10193 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d10201 1
a10201 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d10204 1
a10204 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d10207 1
a10207 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d10210 1
a10210 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d10219 1
a10219 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d10231 1
a10231 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d10236 1
a10236 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d10249 1
d10261 1
d10276 1
a10276 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d10289 1
d10301 1
d10310 1
a10310 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d10323 1
d10335 1
d10396 14
a10409 5
	  dotest 168 "${testcvs} -q update" \
"${PROG} [a-z]*: foo is no longer in the repository
${PROG} update: unable to remove foo: Permission denied" \
"${PROG} [a-z]*: foo is no longer in the repository
${PROG} update: unable to remove \./foo: Permission denied"
d10431 1
a10431 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d10456 1
a10456 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d10459 1
a10459 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d10465 1
a10465 1
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir added to the repository"
d10481 1
a10481 1
Directory ${CVSROOT_DIRNAME}/first-dir/sdir10 added to the repository
d10484 1
a10484 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file10,v
d10487 1
a10487 1
${CVSROOT_DIRNAME}/first-dir/file10,v  <--  file10
d10499 1
a10499 1
"Directory ${CVSROOT_DIRNAME}/first-dir/sdir10/ssdir added to the repository"
d10530 1
a10530 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file15,v
d10533 1
a10533 1
${CVSROOT_DIRNAME}/first-dir/file15,v  <--  file15
d10536 1
a10536 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/sdir10/ssdir/ssfile,v
d10539 1
a10539 1
${CVSROOT_DIRNAME}/first-dir/sdir10/ssdir/ssfile,v  <--  ssfile
d10544 3
d10549 1
a10549 1
	  if $remote; then :; else
d10559 1
a10559 51
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  ;;

	adderrmsg)
	  # Test some of the error messages the 'add' command can return and
	  # their reactions to '-q'.

	  # First the usual setup; create a directory first-dir.
	  mkdir 1; cd 1
	  dotest adderrmsg-init1 "${testcvs} -q co -l ." ''
	  mkdir adderrmsg-dir
	  dotest adderrmsg-init2 "${testcvs} add adderrmsg-dir" \
"Directory ${CVSROOT_DIRNAME}/adderrmsg-dir added to the repository"
          cd adderrmsg-dir

	  # try to add the admin dir
	  dotest_fail adderrmsg-1 "${testcvs} add CVS" \
"${PROG} [a-z]*: cannot add special file .CVS.; skipping"
	  # might not want to see this message when you 'cvs add *'
	  dotest_fail adderrmsg-2 "${testcvs} -q add CVS" ""

	  # to test some other messages
	  touch file1
	  dotest adderrmsg-3 "${testcvs} add file1" \
"${PROG} [a-z]*: scheduling file .file1. for addition
${PROG} [a-z]*: use .${PROG} commit. to add this file permanently"

	  # add it twice
	  dotest_fail adderrmsg-4 "${testcvs} add file1" \
"${PROG} [a-z]*: file1 has already been entered"
	  dotest_fail adderrmsg-5 "${testcvs} -q add file1" ""

	  dotest adderrmsg-6 "${testcvs} -q ci -madd" \
"RCS file: ${CVSROOT_DIRNAME}/adderrmsg-dir/file1,v
done
Checking in file1;
${CVSROOT_DIRNAME}/adderrmsg-dir/file1,v  <--  file1
initial revision: 1\.1
done"

	  # file in Entries & repository
	  dotest_fail adderrmsg-7 "${testcvs} add file1" \
"${PROG} [a-z]*: file1 already exists, with version number 1\.1"
	  dotest_fail adderrmsg-8 "${testcvs} -q add file1" ""

	  # clean up
	  cd ../..
	  if $keep; then :; else
	      rm -r 1
	      rm -rf ${CVSROOT_DIRNAME}/adderrmsg-dir
	  fi
d10772 1
a10772 1
	  if $keep; then
d10925 1
a10925 1
	  if $remote; then
d10934 1
a10934 1
	    dotest_fail devcom3-9ar "${testcvs} edit w1" \
d10936 2
a10937 2
	    dotest devcom3-9br "test -w w1" ""
	    dotest devcom3-9cr "cat CVS/Notify" \
d10940 3
a10942 3
	    dotest devcom3-9dr "${testcvs} -q update" ""
	    dotest_fail devcom3-9er "test -f CVS/Notify" ""
	    dotest devcom3-9fr "${testcvs} watchers w1" \
d10944 2
a10945 2
	    dotest devcom3-9gr "${testcvs} unedit w1" ""
	    dotest devcom3-9hr "${testcvs} watchers w1" ""
d10972 1
a10972 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d10982 1
a10982 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d10985 1
a10985 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d10991 1
a10991 1
"Directory ${CVSROOT_DIRNAME}/first-dir/subdir added to the repository"
d10998 1
a10998 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/subdir/sfile,v
d11001 1
a11001 1
${CVSROOT_DIRNAME}/first-dir/subdir/sfile,v  <--  sfile
d11020 1
a11020 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11026 1
a11026 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d11078 1
a11078 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d11088 1
a11088 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d11091 1
a11091 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11148 2
a11149 2
	  if $remote; then
	    dotest unedit-without-baserev-6r "${testcvs} -q update" "U m"
d11175 1
a11175 1
${CVSROOT_DIRNAME}/x/m,v  <--  m
d11181 1
a11181 1
"RCS file: ${CVSROOT_DIRNAME}/x/m,v
d11192 2
a11193 2
	  if $remote; then
	    dotest unedit-without-baserev-15r "${testcvs} -q update" "U m"
d11216 2
a11217 2
	  mkdir ignore
	  cd ignore
d11219 1
a11219 1
	  dotest ignore-1 "${testcvs} -q co CVSROOT" "U CVSROOT/${DOTSTAR}"
d11222 1
a11222 1
	  dotest ignore-2 "${testcvs} add cvsignore" "${PROG}"' [a-z]*: scheduling file `cvsignore'"'"' for addition
d11227 1
a11227 1
	  dotest ignore-3 " ${testcvs} ci -m added" \
d11229 1
a11229 1
RCS file: ${CVSROOT_DIRNAME}/CVSROOT/cvsignore,v
d11232 1
a11232 1
${CVSROOT_DIRNAME}/CVSROOT/cvsignore,v  <--  cvsignore
d11239 1
a11239 1
	      pass ignore-4
d11241 1
a11241 1
	      fail ignore-4
d11253 1
a11253 1
	  dotest_sort ignore-5 "${testcvs} import -m m -I optig.c ignore/first-dir tag1 tag2" \
d11256 6
a11261 6
I ignore/first-dir/defig.o
I ignore/first-dir/envig.c
I ignore/first-dir/optig.c
I ignore/first-dir/rootig.c
N ignore/first-dir/bar.c
N ignore/first-dir/foobar.c
d11263 1
a11263 1
	  dotest_sort ignore-6 "${testcvs} import -m m -I ! ignore/second-dir tag3 tag4" \
d11266 6
a11271 6
N ignore/second-dir/bar.c
N ignore/second-dir/defig.o
N ignore/second-dir/envig.c
N ignore/second-dir/foobar.c
N ignore/second-dir/optig.c
N ignore/second-dir/rootig.c
d11278 1
a11278 1
	  dotest ignore-7 "${testcvs} -q co -dsecond-dir ignore/second-dir" \
d11285 1
a11285 1
	  dotest ignore-8 "${testcvs} -q co -dfirst-dir ignore/first-dir" 'U first-dir/bar.c
d11289 1
a11289 1
	  dotest ignore-9 "${testcvs} -q update -I optig.c" "${QUESTION} notig.c"
d11292 1
a11292 1
	  dotest_sort ignore-10 "${testcvs} -q update -I ! -I CVS" \
d11303 2
a11304 2
	  if $remote; then
	    dotest ignore-11r "${testcvs} -q diff" "${QUESTION} notig.c"
d11315 1
a11315 1
	    dotest ignore-11r "${testcvs} -q ci -m commit-it" "${QUESTION} notig.c"
d11323 1
a11323 1
	  dotest_sort ignore-12 "${testcvs} -qn update" \
d11327 1
a11327 1
	  dotest_sort ignore-13 "${testcvs} -qn update -I! -I CVS" \
d11335 1
a11335 1
	  echo yes | dotest ignore-14 "${testcvs} release -d first-dir" \
d11342 1
a11342 1
	  echo yes | dotest ignore-15 "${testcvs} release -d second-dir" \
a11345 39

	  cd ../..
	  if $keep; then :; else
	    rm -r ignore
	    rm -rf ${CVSROOT_DIRNAME}/ignore
	  fi
	  ;;

	ignore-on-branch)
	  # Test that CVS _doesn't_ ignore files on branches because they were
	  # added to the trunk.
	  mkdir ignore-on-branch; cd ignore-on-branch
	  mkdir $CVSROOT_DIRNAME/ignore-on-branch

	  # create file1 & file2 on trunk
	  dotest ignore-on-branch-setup-1 "$testcvs -q co -dsetup ignore-on-branch" ''
	  cd setup
	  echo file1 >file1 
	  dotest ignore-on-branch-setup-2 "$testcvs -q add file1" \
"$PROG [a-z]*: use .cvs commit. to add this file permanently"
	  dotest ignore-on-branch-setup-3 "$testcvs -q ci -mfile1 file1" \
"RCS file: $CVSROOT_DIRNAME/ignore-on-branch/file1,v
done
Checking in file1;
$CVSROOT_DIRNAME/ignore-on-branch/file1,v  <--  file1
initial revision: 1\.1
done"
	  dotest ignore-on-branch-setup-4 "$testcvs -q tag -b branch" 'T file1'
	  echo file2 >file2 
	  dotest ignore-on-branch-setup-5 "$testcvs -q add file2" \
"$PROG [a-z]*: use .cvs commit. to add this file permanently"
	  dotest ignore-on-branch-setup-6 "$testcvs -q ci -mtrunk file2" \
"RCS file: $CVSROOT_DIRNAME/ignore-on-branch/file2,v
done
Checking in file2;
$CVSROOT_DIRNAME/ignore-on-branch/file2,v  <--  file2
initial revision: 1\.1
done"

d11347 4
a11350 36

	  # Check out branch.
	  #
	  # - This was the original failure case - file2 would not be flagged
	  #   with a '?'
	  dotest ignore-on-branch-1 "$testcvs -q co -rbranch ignore-on-branch" \
'U ignore-on-branch/file1'
	  cd ignore-on-branch
	  echo file2 on branch >file2 
	  dotest ignore-on-branch-2 "$testcvs -nq update" '? file2'

	  # Now set up for a join.  One of the original fixes for this would
	  # print out a 'U' and a '?' during a join which added a file.
	  if $remote; then
	    dotest ignore-on-branch-3 "$testcvs -q tag -b branch2" \
'? file2
T file1'
	  else
	    dotest ignore-on-branch-3 "$testcvs -q tag -b branch2" 'T file1'
	  fi
	  dotest ignore-on-branch-4 "$testcvs -q add file2" \
"$PROG [a-z]*: use .cvs commit. to add this file permanently"
	  dotest ignore-on-branch-5 "$testcvs -q ci -mbranch file2" \
"Checking in file2;
$CVSROOT_DIRNAME/ignore-on-branch/file2,v  <--  file2
new revision: 1\.1\.2\.1; previous revision: 1\.1
done"
	  dotest ignore-on-branch-6 "$testcvs -q up -rbranch2" \
"$PROG [a-z]*: file2 is no longer in the repository"
	  dotest ignore-on-branch-7 "$testcvs -q up -jbranch" 'U file2'

	  cd ../..
	  if $keep; then :; else
	    rm -r ignore-on-branch
	    rm -rf $CVSROOT_DIRNAME/ignore-on-branch
	  fi
d11374 1
a11374 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile,v
d11377 1
a11377 1
${CVSROOT_DIRNAME}/first-dir/binfile,v  <--  binfile
d11393 1
a11393 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11411 1
a11411 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11422 1
a11422 1
${CVSROOT_DIRNAME}/first-dir/binfile,v  <--  binfile
d11433 1
a11433 1
${CVSROOT_DIRNAME}/first-dir/binfile,v  <--  binfile
d11450 1
a11450 1
${CVSROOT_DIRNAME}/first-dir/binfile,v  <--  binfile
d11474 1
a11474 1
   Repository revision:	1\.4	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11485 1
a11485 1
${CVSROOT_DIRNAME}/first-dir/binfile,v  <--  binfile
d11495 1
a11495 1
   Repository revision:	1\.5	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11500 1
a11500 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile,v
d11512 1
a11512 1
   Repository revision:	1\.5	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11523 1
a11523 1
   Repository revision:	1\.5	${CVSROOT_DIRNAME}/first-dir/binfile,v
d11533 1
a11533 1
	    "RCS file: ${CVSROOT_DIRNAME}/first-dir/nibfile,v
d11536 1
a11536 1
${CVSROOT_DIRNAME}/first-dir/nibfile,v  <--  nibfile
d11546 1
a11546 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/nibfile,v
d11559 1
a11559 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/nibfile,v
d11564 1
a11564 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/nibfile,v
d11572 1
a11572 1
   Repository revision:	1\.1	${CVSROOT_DIRNAME}/first-dir/nibfile,v
d11578 1
a11578 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile,v
d11583 1
a11583 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile,v
d11588 1
a11588 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile,v
d11655 1
a11655 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod,v
d11658 1
a11658 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d11661 1
a11661 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11664 1
a11664 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11667 1
a11667 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v
d11670 1
a11670 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d11685 1
a11685 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/binfile\.dat,v
d11688 1
a11688 1
${CVSROOT_DIRNAME}/first-dir/Attic/binfile\.dat,v  <--  binfile\.dat
d11692 1
a11692 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d11696 1
a11696 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11700 1
a11700 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d11704 1
a11704 1
"${PROG} [a-z]*: binfile\.dat is no longer in the repository
d11713 1
a11713 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11741 1
a11741 1
${CVSROOT_DIRNAME}/first-dir/binfile\.dat,v  <--  binfile\.dat
d11745 1
a11745 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d11749 1
a11749 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11753 1
a11753 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d11758 1
a11758 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11760 2
a11761 2
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v: can't remove branch point 1\.1
${PROG} [a-z]*: RCS file for .brmod-trmod. not modified\."
d11763 1
a11763 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11767 1
a11767 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11772 1
a11772 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11807 1
a11807 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d11810 1
a11810 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11819 1
a11819 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11838 1
a11838 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11842 1
a11842 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d11862 1
a11862 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11868 1
a11868 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d11872 1
a11872 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d11902 1
a11902 1
	  if $remote; then :; else
d11904 4
a11907 4
	    mkdir ${CVSROOT_DIRNAME}/first-dir
	    mkdir 1; cd 1
	    dotest mcopy-1 "${testcvs} -q co first-dir" ''
	    cd first-dir
d11909 8
a11916 8
	    # FIXCVS: unless a branch has at least one file on it,
	    # tag_check_valid won't know it exists.  So if brmod didn't
	    # exist, we would have to invent it.
	    echo 'brmod initial contents' >brmod
	    echo 'brmod-trmod initial contents' >brmod-trmod
	    echo 'brmod-wdmod initial contents' >brmod-wdmod
	    echo "* -m 'COPY'" >.cvswrappers
	    dotest mcopy-1a \
d11923 2
a11924 2
	    dotest mcopy-1b "${testcvs} -q ci -m add" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/\.cvswrappers,v
d11927 1
a11927 1
${CVSROOT_DIRNAME}/first-dir/\.cvswrappers,v  <--  \.cvswrappers
d11930 1
a11930 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod,v
d11933 1
a11933 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d11936 1
a11936 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v
d11939 1
a11939 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11942 1
a11942 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v
d11945 1
a11945 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d11949 7
a11955 7
	    # NOTE: .cvswrappers files are broken (see comment in
	    # src/wrapper.c).  So doing everything via the environment
	    # variable is a workaround.  Better would be to test them
	    # both.
	    CVSWRAPPERS="* -m 'COPY'"
	    export CVSWRAPPERS
	    dotest mcopy-2 "${testcvs} -q tag -b br" 'T \.cvswrappers
d11959 5
a11963 5
	    dotest mcopy-3 "${testcvs} -q update -r br" ''
	    echo 'modify brmod on br' >brmod
	    echo 'modify brmod-trmod on br' >brmod-trmod
	    echo 'modify brmod-wdmod on br' >brmod-wdmod
	    dotest mcopy-5 "${testcvs} -q ci -m br-changes" \
d11965 1
a11965 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d11969 1
a11969 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11973 1
a11973 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d11976 1
a11976 1
	    dotest mcopy-6 "${testcvs} -q update -A" \
d11980 1
a11980 1
	    dotest mcopy-7 "cat brmod brmod-trmod brmod-wdmod" \
d11985 2
a11986 2
	    echo 'modify brmod-trmod again on trunk' >brmod-trmod
	    dotest mcopy-7a "${testcvs} -q ci -m tr-modify" \
d11988 1
a11988 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d11991 1
a11991 1
	    echo 'modify brmod-wdmod in working dir' >brmod-wdmod
d11993 1
a11993 1
	    dotest mcopy-8 "${testcvs} -q update -j br" \
d12005 1
a12005 1
	    dotest mcopy-9 "cat brmod brmod-trmod brmod-wdmod" \
d12009 1
a12009 1
	    dotest mcopy-9a "cat .#brmod-trmod.1.2 .#brmod-wdmod.1.1" \
d12013 2
a12014 2
	    # Test that everything was properly scheduled.
	    dotest mcopy-10 "${testcvs} -q ci -m checkin" \
d12016 1
a12016 1
${CVSROOT_DIRNAME}/first-dir/brmod,v  <--  brmod
d12020 1
a12020 1
${CVSROOT_DIRNAME}/first-dir/brmod-trmod,v  <--  brmod-trmod
d12024 1
a12024 1
${CVSROOT_DIRNAME}/first-dir/brmod-wdmod,v  <--  brmod-wdmod
d12027 2
a12028 2
	    cd ..
	    cd ..
d12030 3
a12032 3
	    rm -rf ${CVSROOT_DIRNAME}/first-dir
	    rm -r 1
	    unset CVSWRAPPERS
d12066 1
a12066 1
   Repository revision:	1\.1\.1\.1	${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d12075 1
a12075 1
   Repository revision:	1\.1\.1\.1	${CVSROOT_DIRNAME}/first-dir/foo\.exe,v
d12111 1
a12111 1
   Repository revision:	1\.1\.1\.1	${CVSROOT_DIRNAME}/first-dir/foo\.c,v
d12120 1
a12120 1
   Repository revision:	1\.1\.1\.1	${CVSROOT_DIRNAME}/first-dir/foo\.exe,v
d12234 1
a12234 1
${CVSROOT_DIRNAME}/CVSROOT/cvswrappers,v  <--  cvswrappers
d12268 1
a12268 1
"RCS file: ${CVSROOT_DIRNAME}/binwrap3/sub2/file1\.newbin,v
d12271 1
a12271 1
${CVSROOT_DIRNAME}/binwrap3/sub2/file1\.newbin,v  <--  file1\.newbin
d12274 1
a12274 1
RCS file: ${CVSROOT_DIRNAME}/binwrap3/sub2/file1\.txt,v
d12277 1
a12277 1
${CVSROOT_DIRNAME}/binwrap3/sub2/file1\.txt,v  <--  file1\.txt
d12393 1
a12393 1
${CVSROOT_DIRNAME}/CVSROOT/cvswrappers,v  <--  cvswrappers
d12402 1
a12402 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d12409 1
a12409 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa,v
d12412 1
a12412 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d12422 1
a12422 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d12428 8
a12435 1
	  if $remote; then
a12444 7
	  else
	    dotest mwrap-7 "${testcvs} -nq update" \
"U aa
${PROG} [a-z]*: nonmergeable file needs merge
${PROG} [a-z]*: revision 1\.2 from repository is now in aa
${PROG} [a-z]*: file from working directory is now in \.#aa\.1\.1
C aa"
d12459 1
a12459 1
${CVSROOT_DIRNAME}/CVSROOT/cvswrappers,v  <--  cvswrappers
d12508 1
a12508 1
${CVSROOT_DIRNAME}/CVSROOT/loginfo,v  <--  loginfo
d12523 1
a12523 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d12526 1
a12526 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12533 1
a12533 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12540 1
a12540 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12544 1
a12544 1
	  dotest info-9 "cat $TESTDIR/testlog" "xenv-valueyz=${username}=${CVSROOT_DIRNAME}="
d12565 1
a12565 1
${CVSROOT_DIRNAME}/CVSROOT/loginfo,v  <--  loginfo
d12585 1
a12585 1
${CVSROOT_DIRNAME}/CVSROOT/verifymsg,v  <--  verifymsg
d12602 1
a12602 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12621 1
a12621 1
${CVSROOT_DIRNAME}/CVSROOT/verifymsg,v  <--  verifymsg
d12669 1
a12669 1
${CVSROOT_DIRNAME}/CVSROOT/taginfo,v  <--  taginfo
d12688 1
a12688 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d12691 1
a12691 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12700 1
a12700 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12741 8
a12748 8
"tag1 add ${CVSROOT_DIRNAME}/first-dir file1 1.1
br add ${CVSROOT_DIRNAME}/first-dir file1 1.1
brtag mov ${CVSROOT_DIRNAME}/first-dir file1 1.1.2.1
tag1 del ${CVSROOT_DIRNAME}/first-dir file1 1.1
tag1 del ${CVSROOT_DIRNAME}/first-dir
tag1 add ${CVSROOT_DIRNAME}/first-dir file1 1.1
tag1 del ${CVSROOT_DIRNAME}/first-dir file1 1.1
tag1 del ${CVSROOT_DIRNAME}/first-dir"
d12755 1
a12755 1
${CVSROOT_DIRNAME}/CVSROOT/taginfo,v  <--  taginfo
d12781 1
a12781 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d12787 1
a12787 1
"${PROG} [a-z]*: syntax error in ${CVSROOT_DIRNAME}/CVSROOT/config: line 'bogus line' is missing '='
d12789 1
a12789 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d12795 1
a12795 1
"${PROG} [a-z]*: ${CVSROOT_DIRNAME}/CVSROOT/config: unrecognized keyword 'BogusOption'
d12797 1
a12797 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d12829 1
a12829 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d12832 1
a12832 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12855 1
a12855 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12906 1
a12906 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d12909 1
a12909 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12917 1
a12917 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12926 1
a12926 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12935 1
a12935 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12944 1
a12944 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d12951 1
a12951 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
a12956 6
	  rlog_header="
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
head: 1\.3
branch:
locks: strict
access list:"
a13079 7
	  dotest log-14f "${testcvs} log -r:: file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 0
description:
${log_trailer}"
a13153 9
	  dotest log-20a "${testcvs} log -r1.2:: file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

a13163 9
	  dotest log-21a "${testcvs} log -r::1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev1}
${log_trailer}"

a13173 239
	  dotest log-22a "${testcvs} log -r1.1::1.2 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 0
description:
${log_trailer}"

	  dotest log-22b "${testcvs} log -r1.1::1.3 file1" \
"${log_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2}
${log_trailer}"

	  # Now the same tests but with rlog

	  dotest log-r11 "${testcvs} rlog first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-r12 "${testcvs} rlog -N first-dir/file1" \
"${rlog_header}
${log_header2}
total revisions: 5;	selected revisions: 5
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-r13 "${testcvs} rlog -b first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 3
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-r14 "${testcvs} rlog -r first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  dotest log-r14a "${testcvs} rlog -rHEAD first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  dotest_fail log-r14b "${testcvs} rlog -r HEAD first-dir/file1" \
"${PROG} [a-z]*: cannot find module .HEAD. - ignored
${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  dotest log-r14c "${testcvs} rlog -r: first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
	  dotest log-r14d "${testcvs} rlog -r, first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
	  dotest log-r14e "${testcvs} rlog -r. first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"
	  dotest log-r14f "${testcvs} rlog -r:: first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 0
description:
${log_trailer}"

	  dotest log-r15 "${testcvs} rlog -r1.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2}
${log_trailer}"

	  dotest log-r16 "${testcvs} rlog -r1.2.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-r17 "${testcvs} rlog -rbranch first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2b}
${log_rev1b}
${log_trailer}"

	  dotest log-r18 "${testcvs} rlog -r1.2.2. first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  dotest log-r18a "${testcvs} rlog -r1.2.2.2 -r1.3:1.3 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev3}
${log_rev2b}
${log_trailer}"

	  dotest log-r19 "${testcvs} rlog -rbranch. first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2b}
${log_trailer}"

	  dotest log-r20 "${testcvs} rlog -r1.2: first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev3}
${log_rev2}
${log_trailer}"

	  dotest log-r20a "${testcvs} rlog -r1.2:: first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev3}
${log_trailer}"

	  dotest log-r21 "${testcvs} rlog -r:1.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-r21a "${testcvs} rlog -r::1.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev1}
${log_trailer}"

	  dotest log-r22 "${testcvs} rlog -r1.1:1.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 2
description:
${log_rev2}
${log_rev1}
${log_trailer}"

	  dotest log-r22a "${testcvs} rlog -r1.1::1.2 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 0
description:
${log_trailer}"

	  dotest log-r22b "${testcvs} rlog -r1.1::1.3 first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 5;	selected revisions: 1
description:
${log_rev2}
${log_trailer}"

	  # Now test outdating revisions

d13175 1
a13175 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13178 1
a13178 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13181 1
a13181 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
a13194 11
	  dotest log-ro3 "${testcvs} rlog first-dir/file1" \
"${rlog_header}
${log_tags}
${log_header2}
total revisions: 4;	selected revisions: 4
description:
${log_rev3}
${log_rev2}
${log_rev1}
${log_rev1b}
${log_trailer}"
d13214 1
a13214 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13217 1
a13217 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13222 1
a13222 1
	  if $remote; then :; else
d13224 2
a13225 2
	    dotest log2-4 "${testcvs} log -N file1" "
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13244 1
a13244 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13247 1
a13247 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13266 1
a13266 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13271 1
a13271 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13295 1
a13295 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13324 1
a13324 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d13331 1
a13331 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13334 1
a13334 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13342 1
a13342 1
${CVSROOT_DIRNAME}/first-dir/file1,v"
d13346 1
a13346 1
${CVSROOT_DIRNAME}/first-dir/file1,v"
d13350 1
a13350 1
${CVSROOT_DIRNAME}/first-dir/file1,v"
d13354 1
a13354 1
${CVSROOT_DIRNAME}/first-dir/file1,v"
d13370 1
a13370 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d13383 1
a13383 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13386 1
a13386 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13402 1
a13402 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13419 1
a13419 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13438 1
a13438 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13487 1
a13487 49
	  dotest_fail ann-14 "${testcvs} ann -r bill-clintons-chastity file1" \
"${PROG} \[[a-z]* aborted\]: no such tag bill-clintons-chastity"

	  # Now get rid of the working directory and test rannotate

	  cd ../..
	  rm -r 1
	  dotest ann-r10 "${testcvs} rann first-dir" \
"Annotations for first-dir/file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.3          (${username} *[0-9a-zA-Z-]*): trunk file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line"
	  dotest ann-r11 "${testcvs} rann -r br first-dir" \
"Annotations for first-dir/file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.1          (${username} *[0-9a-zA-Z-]*): file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): and some
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): branched content"
	  dotest ann-r12 "${testcvs} rann -r 1.2.0.2 first-dir/file1" ""
	  dotest ann-r13 "${testcvs} rann -r 1.2.2 first-dir/file1" \
"Annotations for first-dir/file1
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
1\.1          (${username} *[0-9a-zA-Z-]*): this
1\.1          (${username} *[0-9a-zA-Z-]*): is
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.1          (${username} *[0-9a-zA-Z-]*): file
1\.2          (${username} *[0-9a-zA-Z-]*): 
1\.2          (${username} *[0-9a-zA-Z-]*): with
1\.2          (${username} *[0-9a-zA-Z-]*): a
1\.2          (${username} *[0-9a-zA-Z-]*): blank
1\.2          (${username} *[0-9a-zA-Z-]*): line
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): and some
1\.2\.2\.1      (${username} *[0-9a-zA-Z-]*): branched content"
	  dotest_fail ann-r14 "${testcvs} rann -r bill-clintons-chastity first-dir/file1" \
d13490 2
d13505 1
a13505 1
"Directory ${CVSROOT_DIRNAME}/$module added to the repository"
d13515 1
a13515 1
"RCS file: ${CVSROOT_DIRNAME}/$module/$file,v
d13518 1
a13518 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d13525 1
a13525 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d13549 1
a13549 30
	  if $remote; then

	    # For remote, just create the repository.  We don't yet do
	    # the various other tests above for remote but that should be
	    # changed.
	    mkdir crerepos
	    mkdir crerepos/CVSROOT

	    # Use :ext: rather than :fork:.  Most of the tests use :fork:,
	    # so we want to make sure that we test :ext: _somewhere_.

	    # Maybe a bit dubious in the sense that people need to
	    # have rsh working to run the tests, but at least it
	    # isn't inetd :-).  Might want to think harder about this -
	    # maybe try :ext:, and if it fails, print a (single, nice)
	    # message and fall back to :fork:.  Maybe testing :ext:
	    # with our own CVS_RSH rather than worrying about a system one
	    # would do the trick.

	    # Note that we set CVS_SERVER at the beginning.
	    CREREPOS_ROOT=:ext:`hostname`:${TESTDIR}/crerepos

	    # If we're going to do remote testing, make sure 'rsh' works first.
	    host="`hostname`"
	    if test "x`${CVS_RSH-rsh} $host -n 'echo hi'`" != "xhi"; then
		echo "ERROR: cannot test remote CVS, because \`${CVS_RSH-rsh} $host' fails." >&2
		exit 1
	    fi

	  else
d13590 27
d13619 1
a13619 1
	  if $remote; then
d13622 2
a13623 10
	    # Note that having the client reject the pathname (as :fork:
	    # does), does _not_ test for the bugs we are trying to catch
	    # here.  The point is that malicious clients might send all
	    # manner of things and the server better protect itself.
	    dotest_fail crerepos-6a-r \
"${testcvs} -q -d :ext:`hostname`:../crerepos get ." \
"${PROG} [a-z]*: CVSROOT (\":ext:${hostname}:\.\./crerepos\")
${PROG} [a-z]*: may only specify a positive, non-zero, integer port (not \"\.\.\")\.
${PROG} [a-z]*: perhaps you entered a relative pathname${QUESTION}
${PROG} \[[a-z]* aborted\]: Bad CVSROOT\."
d13628 2
a13629 7
	    dotest_fail crerepos-6b-r \
"${testcvs} -d :ext:`hostname`:crerepos init" \
"${PROG} [a-z]*: CVSROOT (\":ext:${hostname}:crerepos\")
${PROG} [a-z]*: requires a path spec
${PROG} [a-z]*: :(gserver|kserver|pserver):\[\[user\]\[:password\]@@\]host\[:\[port\]\]/path
${PROG} [a-z]*: \[:(ext|server):\]\[\[user\]@@\]host\[:\]/path
${PROG} \[[a-z]* aborted\]: Bad CVSROOT\."
d13632 1
a13632 1
	  else # local
d13635 7
a13641 3
	    # piping the output of this test to /dev/null since we have no way of knowing
	    # what error messages different rsh implementations will output.
	    dotest_fail crerepos-6a "${testcvs} -q -d ../crerepos get . >/dev/null 2>&1" ""
d13646 3
a13648 3
	    dotest_fail crerepos-6b "${testcvs} -d crerepos init" \
"${PROG} [a-z]*: CVSROOT \"crerepos\" must be an absolute pathname
${PROG} \[[a-z]* aborted\]: Bad CVSROOT\."
d13665 1
a13665 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d13672 1
a13672 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13675 1
a13675 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d13714 1
a13714 1
	  if $keep; then
d13823 1
a13823 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13857 1
a13857 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13877 1
a13877 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d13969 1
a13969 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d13975 1
a13975 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d14121 1
a14121 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d14307 1
a14307 1
"${PROG} \[[a-z]* aborted\]: EOF while looking for value in RCS file ${CVSROOT_DIRNAME}/first-dir/file1,v"
d14314 1
a14314 1
"${PROG} \[[a-z]* aborted\]: unexpected '.x6c' reading revision number in RCS file ${CVSROOT_DIRNAME}/first-dir/file1,v"
d14322 1
a14322 1
"${PROG} \[[a-z]* aborted\]: EOF while looking for value in RCS file ${CVSROOT_DIRNAME}/first-dir/file1,v"
d14341 1
a14341 1
"${CVSROOT_DIRNAME}/first-dir/file1,v"
d14347 1
a14347 1
"${PROG} \[[a-z]* aborted\]: unexpected '.x0' reading revision number in RCS file ${CVSROOT_DIRNAME}/first-dir/file1,v"
d14376 1
a14376 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d14413 1
a14413 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d14453 1
a14453 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d14457 1
a14457 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir added to the repository"
d14462 1
a14462 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d14465 1
a14465 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14468 1
a14468 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir/file2,v
d14471 1
a14471 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14488 1
a14488 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14492 1
a14492 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14502 2
a14503 2
	  sed -e "s/looks like/just looks like/" file1 >tmp; mv tmp file1
	  sed -e "s/don't use/don't just use/" dir/file2 >tmp; mv tmp dir/file2
d14515 1
a14515 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14519 1
a14519 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14524 1
a14524 1
	  cp -r ${CVSROOT_DIRNAME}/first-dir ${TESTDIR}/cvsroot/backup
d14539 1
a14539 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14543 1
a14543 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14552 1
a14552 1
	  sed -e "s/quit and/be fired so he can/" dir/file2 >tmp; mv tmp dir/file2
d14569 1
a14569 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14573 1
a14573 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14580 1
a14580 1
	  sed -e "s/very/some extremely/" file1 >tmp; mv tmp file1
d14583 1
a14583 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14594 2
a14595 2
	  rm -rf ${CVSROOT_DIRNAME}/first-dir
	  mv ${CVSROOT_DIRNAME}/backup ${TESTDIR}/cvsroot/first-dir
d14613 1
a14613 1
${PROG} \[[a-z]* aborted\]: could not find desired version 1\.6 in ${CVSROOT_DIRNAME}/first-dir/file1,v"
d14648 1
a14648 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14652 1
a14652 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14660 1
a14660 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d14668 1
a14668 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir/file2,v
d14684 1
a14684 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14691 1
a14691 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d14695 1
a14695 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/dir/file2,v
d14701 1
a14701 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14705 1
a14705 1
${CVSROOT_DIRNAME}/first-dir/dir/file2,v  <--  file2
d14832 1
a14832 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d14835 1
a14835 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14846 1
a14846 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d14855 1
a14855 1
	  if $keep; then
d14882 1
a14882 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d14889 1
a14889 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa,v
d14892 1
a14892 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d14895 1
a14895 1
	  dotest modes-5 "ls -l ${CVSROOT_DIRNAME}/first-dir/aa,v" \
d14903 1
a14903 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d14909 1
a14909 1
	  dotest modes-7 "ls -l ${CVSROOT_DIRNAME}/first-dir/aa,v" \
d14913 1
a14913 1
	  chmod g=r,o= ${CVSROOT_DIRNAME}/first-dir/aa,v
d14917 1
a14917 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d14920 1
a14920 1
	  dotest modes-7b "ls -l ${CVSROOT_DIRNAME}/first-dir/aa,v" \
d14932 1
a14932 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/ab,v
d14935 1
a14935 1
${CVSROOT_DIRNAME}/first-dir/ab,v  <--  ab
d14938 1
a14938 1
	  if $remote; then
d14942 1
a14942 1
	    dotest modes-10r "ls -l ${CVSROOT_DIRNAME}/first-dir/ab,v" \
d14945 1
a14945 1
	    dotest modes-10 "ls -l ${CVSROOT_DIRNAME}/first-dir/ab,v" \
d14962 1
a14962 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/Attic/ac,v
d14965 1
a14965 1
${CVSROOT_DIRNAME}/first-dir/Attic/ac,v  <--  ac
d14968 1
a14968 1
	  if $remote; then
d14975 2
a14976 2
	    dotest modes-15r \
"ls -l ${CVSROOT_DIRNAME}/first-dir/Attic/ac,v" \
d14980 1
a14980 1
"ls -l ${CVSROOT_DIRNAME}/first-dir/Attic/ac,v" \
d15000 1
a15000 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15007 1
a15007 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa,v
d15010 1
a15010 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d15016 1
a15016 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d15047 2
a15048 2
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository
Directory ${CVSROOT_DIRNAME}/second-dir added to the repository"
d15055 1
a15055 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa,v
d15058 1
a15058 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d15061 1
a15061 1
RCS file: ${CVSROOT_DIRNAME}/second-dir/ab,v
d15064 1
a15064 1
${CVSROOT_DIRNAME}/second-dir/ab,v  <--  ab
d15067 1
a15067 1
	  chmod a= ${CVSROOT_DIRNAME}/first-dir
d15071 1
a15071 1
${PROG} [a-z]*: cannot open directory ${CVSROOT_DIRNAME}/first-dir: Permission denied
d15085 1
a15085 1
${PROG} [a-z]*: cannot open directory ${CVSROOT_DIRNAME}/first-dir: Permission denied
d15091 2
a15092 2
	  chmod u+rwx ${CVSROOT_DIRNAME}/first-dir
	  rm -rf ${CVSROOT_DIRNAME}/first-dir ${TESTDIR}/cvsroot/second-dir
d15101 1
a15101 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15124 1
a15124 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aa,v
d15127 1
a15127 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d15130 1
a15130 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/kw,v
d15133 1
a15133 1
${CVSROOT_DIRNAME}/first-dir/kw,v  <--  kw
d15180 1
a15180 1
${CVSROOT_DIRNAME}/first-dir/aa,v  <--  aa
d15184 1
a15184 1
${CVSROOT_DIRNAME}/first-dir/kw,v  <--  kw
d15226 1
a15226 1
	  if $keep; then
d15245 1
a15245 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15257 1
a15257 1
${CVSROOT_DIRNAME}/first-dir/foo,v  <--  foo
d15266 1
a15266 1
	  if $remote; then :; else
d15290 1
a15290 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15297 1
a15297 1
	  if $remote; then
d15300 1
a15300 1
	    dotest_fail symlinks-4r "${testcvs} -q ci -m ''" \
d15307 1
a15307 1
${CVSROOT_DIRNAME}/first-dir/slink,v  <--  slink
d15337 1
a15337 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15347 1
a15347 1
${CVSROOT_DIRNAME}/first-dir/slink,v  <--  slink
d15356 1
a15356 1
${CVSROOT_DIRNAME}/first-dir/slink,v  <--  slink
d15378 1
a15378 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15414 1
a15414 1
${CVSROOT_DIRNAME}/first-dir/aaaa,v  <--  aaaa
d15420 1
a15420 1
${CVSROOT_DIRNAME}/first-dir/b\.b\.b\.b,v  <--  b\.b\.b\.b
d15426 1
a15426 1
${CVSROOT_DIRNAME}/first-dir/dd dd dd,v  <--  dd dd dd
d15432 1
a15432 1
	  if $remote; then
d15434 1
a15434 1
	    dotest hardlinks-5r "${testcvs} -q co first-dir" \
d15439 1
a15439 1
	    dotest hardlinks-6r "ls -l [abd]*" \
d15479 1
a15479 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15487 1
a15487 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d15490 1
a15490 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15497 1
a15497 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15514 1
a15514 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d15517 1
a15517 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d15583 1
a15583 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15608 1
a15608 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d15611 1
a15611 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15617 1
a15617 1
"'\$'"Header: ${CVSROOT_DIRNAME}/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
d15623 1
a15623 1
"'\$'"Source: ${CVSROOT_DIRNAME}/first-dir/file1,v "'\$'"
d15637 1
a15637 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d15645 1
a15645 1
"'\$'"Header: ${CVSROOT_DIRNAME}/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp "'\$'"
d15651 1
a15651 1
"'\$'"Source: ${CVSROOT_DIRNAME}/first-dir/file1,v "'\$'"
d15665 1
a15665 1
"'\$'"Header: ${CVSROOT_DIRNAME}/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp ${username} "'\$'"
d15671 1
a15671 1
"'\$'"Source: ${CVSROOT_DIRNAME}/first-dir/file1,v "'\$'"
d15705 1
a15705 1
${CVSROOT_DIRNAME}/first-dir/file1,v 1\.1 [0-9/]* [0-9:]* ${username} Exp
d15711 1
a15711 1
${CVSROOT_DIRNAME}/first-dir/file1,v
d15745 1
a15745 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15752 1
a15752 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15759 1
a15759 1
	  if $remote; then
d15762 1
a15762 1
	    dotest keyword-23r "${testcvs} update -A file1" "P file1
d15783 1
a15783 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d15792 1
a15792 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d15795 1
a15795 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15818 1
a15818 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15845 1
a15845 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15879 1
a15879 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d15976 1
a15976 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d15989 1
a15989 1
	  if $keep; then
d16012 1
a16012 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d16042 1
a16042 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile\.dat,v
d16045 1
a16045 1
${CVSROOT_DIRNAME}/first-dir/binfile\.dat,v  <--  binfile\.dat
d16048 1
a16048 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16051 1
a16051 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16062 1
a16062 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16071 1
a16071 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16078 1
a16078 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16087 1
a16087 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16101 2
a16102 2
	  if $remote; then
	    dotest keyword2-13r "${testcvs} -q update -A -kk -j branch" \
d16105 1
a16105 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16114 1
a16114 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16124 1
a16124 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16144 1
a16144 1
${CVSROOT_DIRNAME}/first-dir/binfile\.dat,v  <--  binfile\.dat
d16149 1
a16149 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/binfile\.dat,v
d16193 1
a16193 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16201 1
a16201 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16210 1
a16210 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16218 1
a16218 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16232 1
a16232 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16236 2
a16237 2
\*\*\* file1	${RFCDATE}	1\.3
--- file1	${RFCDATE}	1\.3\.2\.2
d16285 1
a16285 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16289 2
a16290 2
\*\*\* file1	${RFCDATE}	1\.3
--- file1	${RFCDATE}	1\.3\.2\.2
d16309 1
a16309 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16311 2
a16312 2
${PROG} [a-z]*: RCS file for .file1. not modified\.
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16320 1
a16320 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16323 1
a16323 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16351 1
a16351 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d16359 1
a16359 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16362 1
a16362 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16370 1
a16370 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16381 1
a16381 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16409 1
a16409 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16430 1
a16430 1
	  if $keep; then
d16449 1
a16449 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d16459 1
a16459 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16462 1
a16462 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16465 1
a16465 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16468 1
a16468 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d16481 1
a16481 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16485 1
a16485 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d16495 1
a16495 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16501 1
a16501 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16531 1
a16531 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16558 1
a16558 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16564 1
a16564 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d16597 1
a16597 1
"RCS file: ${CVSROOT_DIRNAME}/$module/$file,v
d16600 1
a16600 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d16608 1
a16608 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d16632 1
a16632 1
	  name=`sed -n 's/.*;	author \([^;]*\);.*/\1/p' ${CVSROOT_DIRNAME}/$module/$file,v|head -1`
d16648 1
a16648 1
${CVSROOT_DIRNAME}/$module/$file,v  <--  $file
d16685 1
a16685 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d16703 1
a16703 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16706 1
a16706 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16709 1
a16709 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16712 1
a16712 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d16721 1
a16721 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d16738 6
a16743 6
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file1,v: Symbolic name BOGUS is undefined.
${PROG} [a-z]*: RCS file for .file1. not modified\.
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file2,v: Symbolic name BOGUS is undefined.
${PROG} [a-z]*: RCS file for .file2. not modified\."
d16752 1
a16752 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16755 1
a16755 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16778 1
a16778 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16781 1
a16781 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16862 1
a16862 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16865 1
a16865 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d16888 1
a16888 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16891 1
a16891 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16919 3
a16921 3
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file1,v: symbolic name br already bound to 1\.1
${PROG} [a-z]*: RCS file for .file1. not modified\."
d16923 1
a16923 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16926 1
a16926 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16955 1
a16955 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16961 4
a16964 3
	  if $remote; then :; else
	    dotest admin-19a-admin "${testcvs} -q admin -A../../cvsroot/first-dir/file2,v file1" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16966 2
a16967 2
	    dotest admin-19a-log "${testcvs} -q log -h -N file1" "
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16983 1
a16983 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16986 1
a16986 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d16998 1
a16998 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17005 1
a17005 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d17009 1
a17009 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17023 1
a17023 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17026 1
a17026 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17032 1
a17032 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17038 1
a17038 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17044 1
a17044 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17050 1
a17050 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17056 1
a17056 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17060 1
a17060 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17064 1
a17064 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17081 3
a17083 3
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/aaa,v: can't remove locked revision 1\.6
${PROG} [a-z]*: RCS file for .aaa. not modified\."
d17085 1
a17085 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17089 1
a17089 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17094 1
a17094 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17127 1
a17127 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17131 1
a17131 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17133 2
a17134 2
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/aaa,v: can't remove branch point 1\.3
${PROG} [a-z]*: RCS file for .aaa. not modified\."
d17138 1
a17138 1
RCS:  ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17148 1
a17148 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17154 1
a17154 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17160 1
a17160 1
${CVSROOT_DIRNAME}/first-dir/aaa,v  <--  aaa
d17164 1
a17164 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17170 1
a17170 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/aaa,v
d17218 1
a17218 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17290 1
a17290 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17296 1
a17296 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17302 1
a17302 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17306 1
a17306 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17310 1
a17310 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17320 1
a17320 1
   Repository revision:	1\.2	${CVSROOT_DIRNAME}/first-dir/file2,v
d17340 1
a17340 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d17347 1
a17347 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d17354 1
a17354 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17358 3
a17360 3
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file2,v: symbolic name tagfour already bound to 1\.1
${PROG} [a-z]*: RCS file for .file2. not modified\."
d17365 1
a17365 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17371 3
a17373 4
	  dotest_fail admin-28-1 "${testcvs} admin -ntagsix:tagfive file2" \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file2,v: Symbolic name or revision tagfive is undefined\.
${PROG} [a-z]*: RCS file for .file2. not modified\."
d17378 1
a17378 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17382 1
a17382 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17388 1
a17388 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17391 4
a17394 9
	  # Confirm that a missing tag is not a fatal error.
	  dotest admin-28-5.1 "${testcvs} -Q tag BO+GUS file1" ''
	  dotest_fail admin-28-5.2 "${testcvs} admin -ntagten:BO+GUS file2 file1"  \
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
${PROG} [a-z]*: ${CVSROOT_DIRNAME}/first-dir/file2,v: Symbolic name or revision BO${PLUS}GUS is undefined\.
${PROG} [a-z]*: RCS file for .file2. not modified\.
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
done"

d17396 1
a17396 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d17401 1
a17401 1
	  dotest admin-29 "cat ${CVSROOT_DIRNAME}/first-dir/file2,v" \
d17490 1
a17490 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d17497 1
a17497 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17500 1
a17500 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d17505 1
a17505 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17509 1
a17509 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17528 1
a17528 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17533 1
a17533 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d17565 1
a17565 1
  echo "\$user has file a-lock locked for version  \$version" >&2
d17576 1
a17576 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17579 1
a17579 1
${CVSROOT_DIRNAME}/first-dir/a-lock,v  <--  a-lock
d17596 1
a17596 1
${CVSROOT_DIRNAME}/CVSROOT/commitinfo,v  <--  commitinfo
d17604 4
a17607 4
	  sed -e 's/locks; strict;/locks fred:1.1; strict;/' ${CVSROOT_DIRNAME}/first-dir/a-lock,v > a-lock,v
	  chmod 644 ${CVSROOT_DIRNAME}/first-dir/a-lock,v
	  dotest reserved-13 "mv a-lock,v ${CVSROOT_DIRNAME}/first-dir/a-lock,v"
	  chmod 444 ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17616 1
a17616 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17620 1
a17620 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17625 1
a17625 1
${CVSROOT_DIRNAME}/first-dir/a-lock,v  <--  a-lock
d17630 2
a17631 2
	  sed -e 's/locks; strict;/locks fred:1.2; strict;/' ${CVSROOT_DIRNAME}/first-dir/a-lock,v > a-lock,v
	  chmod 644 ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17633 2
a17634 2
"mv a-lock,v ${CVSROOT_DIRNAME}/first-dir/a-lock,v" ""
	  chmod 444 ${CVSROOT_DIRNAME}/first-dir/a-lock,v
d17640 1
a17640 1
${CVSROOT_DIRNAME}/first-dir/a-lock,v  <--  a-lock
d17649 1
a17649 1
${CVSROOT_DIRNAME}/CVSROOT/commitinfo,v  <--  commitinfo
d17694 35
a17728 4
	  # These are the files we both start out with:
	  mkdir import
	  cd import
	  diffmerge_create_older_files
d17734 1
d17736 3
a17738 11
	  # Check out two working copies, one for "you" and one for
	  # "me".  If no branch is used and cvs detects that only one
	  # of the two people made changes, then cvs does not run the
	  # merge algorithm.  But if a branch is used, then cvs does run
	  # the merge algorithm (even in this case of only one of the two
	  # people having made changes).  CVS used to have a bug in this
	  # case.  Therefore, it is important to test this case by
	  # using a branch:
	  ${testcvs} rtag     -b tag diffmerge1 >/dev/null 2>&1
	  ${testcvs} checkout -r tag diffmerge1 >/dev/null 2>&1
	  mv diffmerge1 yours
d17740 19
a17758 1
	  mv diffmerge1 mine
d17760 8
a17767 45
	  # In your working copy, you'll make changes, and
	  # then check in your changes before I check in mine:
	  cd yours
	  diffmerge_create_your_files
          dotest diffmerge1_yours "${testcvs} -q ci -m yours" \
"Checking in testcase01;
${CVSROOT_DIRNAME}/diffmerge1/testcase01,v  <--  testcase01
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase02;
${CVSROOT_DIRNAME}/diffmerge1/testcase02,v  <--  testcase02
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase03;
${CVSROOT_DIRNAME}/diffmerge1/testcase03,v  <--  testcase03
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase04;
${CVSROOT_DIRNAME}/diffmerge1/testcase04,v  <--  testcase04
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase05;
${CVSROOT_DIRNAME}/diffmerge1/testcase05,v  <--  testcase05
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase06;
${CVSROOT_DIRNAME}/diffmerge1/testcase06,v  <--  testcase06
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase07;
${CVSROOT_DIRNAME}/diffmerge1/testcase07,v  <--  testcase07
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase08;
${CVSROOT_DIRNAME}/diffmerge1/testcase08,v  <--  testcase08
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase09;
${CVSROOT_DIRNAME}/diffmerge1/testcase09,v  <--  testcase09
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done
Checking in testcase10;
${CVSROOT_DIRNAME}/diffmerge1/testcase10,v  <--  testcase10
new revision: 1\.1\.1\.1\.2\.1; previous revision: 1\.1\.1\.1
done"
d17769 2
a17770 1
	  # Change my copy.  Then I
d17772 35
a17806 51
	  cd ../mine
	  diffmerge_create_my_files
	  dotest diffmerge1_mine "${testcvs} -q update -j tag" \
"M testcase01
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase01,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase01
M testcase02
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase02,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase02
M testcase03
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase03,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase03
M testcase04
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase04,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase04
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase05,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase05
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase06,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase06
M testcase07
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase07,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase07
M testcase08
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase08,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase08
M testcase09
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase09,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase09
M testcase10
RCS file: ${CVSROOT_DIRNAME}/diffmerge1/testcase10,v
retrieving revision 1\.1\.1\.1
retrieving revision 1\.1\.1\.1\.2\.1
Merging differences between 1\.1\.1\.1 and 1\.1\.1\.1\.2\.1 into testcase10"
d17809 23
a17831 15
	  # in any case if the files do not look like the final text
	  # in the files in directory comp_me, then the test flunks:
	  cd ..
	  mkdir comp_me
	  cd comp_me
	  diffmerge_create_expected_files
	  cd ..
	  rm mine/.#*

	  # If you have GNU's version of diff, you may try
	  # uncommenting the following line which will give more
	  # fine-grained information about how cvs differed from the
	  # correct result:
	  #dotest diffmerge1_cmp "diff -u --recursive --exclude=CVS comp_me mine" ''
	  dotest diffmerge1_cmp "directory_cmp comp_me mine"
d17835 2
a17836 3
	  if $keep; then :; else
	    rm -rf diffmerge1 ${CVSROOT_DIRNAME}/diffmerge1
	  fi
d18540 1
a18540 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d18544 1
a18544 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir1 added to the repository"
d18547 1
a18547 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir2 added to the repository"
d18551 1
a18551 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir2/dir3 added to the repository"
d18572 1
a18572 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir1 added to the repository"
d18576 1
a18576 1
"Directory ${CVSROOT_DIRNAME}/first-dir/dir2/dir3 added to the repository"
d18616 1
a18616 1
	  if $remote; then
d18811 1
a18811 5
	    if $remote; then
	      # Hmm, this one is specific to non-RELATIVE_REPOS too I think.
	      dotest_fail multiroot-update-1ar "${testcvs1} update" \
"protocol error: directory '${TESTDIR}/root2/mod2-2' not within root '${TESTDIR}/root1'"
	    else
d18826 5
a18830 1
	    fi # remote
d18833 1
a18833 4
	    if $remote; then
	      dotest_fail multiroot-update-1b "${testcvs2} update" \
"protocol error: directory '${TESTDIR}/root1' not within root '${TESTDIR}/root2'"
	    else
d18842 4
a18845 1
	    fi # remote
d19008 8
a19015 1
	  if $remote; then
d19017 1
a19017 1
	    dotest multiroot-add-1ar "${testcvs} add anotherfile1-1" \
d19021 1
a19021 1
	    dotest multiroot-add-1br "${testcvs} add anotherfile2-1" \
d19025 1
a19025 1
	    dotest multiroot-add-1cr "${testcvs} add anotherfile1-2" \
d19029 1
a19029 1
	    dotest multiroot-add-1dr "${testcvs} add anotherfile2-2" \
a19032 7
          else
	    dotest multiroot-add-1 "${testcvs} add mod1-1/anotherfile1-1 mod2-1/anotherfile2-1 mod2-2/mod1-2/anotherfile1-2 mod1-2/mod2-2/anotherfile2-2" \
"${PROG} [a-z]*: scheduling file .mod1-1/anotherfile1-1. for addition
${PROG} [a-z]*: scheduling file .mod2-1/anotherfile2-1. for addition
${PROG} [a-z]*: scheduling file .mod2-2/mod1-2/anotherfile1-2. for addition
${PROG} [a-z]*: scheduling file .mod1-2/mod2-2/anotherfile2-2. for addition
${PROG} [a-z]*: use .${PROG} commit. to add these files permanently"
d19789 1
a19789 1
	  if $keep; then
d19809 1
a19809 1
	  if $remote; then
d19872 1
a19872 1
	  if $remote; then :; else
d19874 1
a19874 1
" -> main loop with CVSROOT=${TESTDIR}/root1
d19877 1
a19877 1
 -> main loop with CVSROOT=${TESTDIR}/root2
d19909 2
a19910 2
--- dir1/file1	${RFCDATE}	1\.1\.1\.1
${PLUS}${PLUS}${PLUS} dir1/file1	${RFCDATE}	1\.2
d19920 2
a19921 2
--- dir1/sdir/sfile	${RFCDATE}	1\.1\.1\.1
${PLUS}${PLUS}${PLUS} dir1/sdir/sfile	${RFCDATE}	1\.2
d19926 1
a19926 1
	  if $keep; then
d19944 1
a19944 1
	  if $remote; then
d19967 1
a19967 1
	  if $remote; then
d19977 1
a19977 1
	  if $remote; then
d20022 1
a20022 1
	    if $remote; then
d20070 1
a20070 1
	  if $keep; then
d20085 1
a20085 1
	  if $remote; then
d20166 1
a20166 1
"Directory ${CVSROOT_DIRNAME}/first-dir added to the repository"
d20174 1
a20174 1
"RCS file: ${CVSROOT_DIRNAME}/first-dir/file1,v
d20177 1
a20177 1
${CVSROOT_DIRNAME}/first-dir/file1,v  <--  file1
d20180 1
a20180 1
RCS file: ${CVSROOT_DIRNAME}/first-dir/file2,v
d20183 1
a20183 1
${CVSROOT_DIRNAME}/first-dir/file2,v  <--  file2
d20198 1
a20198 1
	  if $remote; then
d20229 1
a20229 5
	  if $remote; then
	    dotest_fail reposmv-2r "${testcvs} update" \
"Cannot access ${TESTDIR}/root1/CVSROOT
No such file or directory"
	  else
d20232 1
a20232 1
${PROG} update: cannot open directory ${CVSROOT_DIRNAME}/dir1: No such file or directory
d20234 4
d20241 1
a20241 8
	  if $remote; then
	    CVSROOT_SAVED=${CVSROOT}
	    CVSROOT=:fork:${TESTDIR}/root-moved; export CVSROOT
	    dotest_fail reposmv-3r "${testcvs} update" \
"Cannot access ${TESTDIR}/root1/CVSROOT
No such file or directory"
	    CVSROOT=${CVSROOT_SAVED}; export CVSROOT
	  else
d20250 1
a20250 3
	  fi

	  if $remote; then
d20252 2
a20253 2
	    CVSROOT=:fork:${TESTDIR}/root-none; export CVSROOT
	    dotest_fail reposmv-4 "${testcvs} update" \
d20257 3
a20259 1
	  else
d20270 7
d20300 1
a20300 1
	  if $remote; then
d20310 1
a20310 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d20440 1
a20440 1
${CVSROOT_DIRNAME}/CVSROOT/config,v  <--  config
d20452 1
a20452 1
	  if $remote; then
d20621 1
a20621 1
	    if $keep; then
d20634 1
a20634 1
	  if $remote; then
d20636 1
a20636 1
"E protocol error: directory '${CVSROOT_DIRNAME}/\.\./dir1' not within root '${TESTDIR}/cvsroot'
d20638 1
a20638 1
Root ${CVSROOT_DIRNAME}
d20640 1
a20640 1
${CVSROOT_DIRNAME}/../dir1
d20645 1
a20645 1
"E protocol error: directory '${CVSROOT_DIRNAME}dir1' not within root '${TESTDIR}/cvsroot'
d20647 1
a20647 1
Root ${CVSROOT_DIRNAME}
d20649 1
a20649 1
${CVSROOT_DIRNAME}dir1
d20654 1
a20654 1
"E protocol error: directory '${TESTDIR}' not within root '${CVSROOT_DIRNAME}'
d20656 1
a20656 1
Root ${CVSROOT_DIRNAME}
d20669 1
a20669 1
Root ${CVSROOT_DIRNAME}
d20671 1
a20671 1
${CVSROOT_DIRNAME}
d20680 1
a20680 1
	  if $remote; then
d20692 1
a20692 1
echo "${CVSROOT_DIRNAME}/first-dir/file1"
d20713 1
a20713 1
echo "${CVSROOT_DIRNAME}/first-dir/file1"
d20716 1
a20716 1
echo "${CVSROOT_DIRNAME}/first-dir/file1"
d20736 1
a20736 1
echo "${CVSROOT_DIRNAME}/first-dir/file1"
d20739 1
a20739 1
echo "${CVSROOT_DIRNAME}/first-dir/file1"
d20766 1
a20766 1
"Root ${CVSROOT_DIRNAME}
d20772 1
a20772 1
${CVSROOT_DIRNAME}/first-dir
a20787 28
	fork)
	  # Test that the server defaults to the correct executable in :fork:
	  # mode.  See the note in the TODO at the end of this file about this.
	  #
	  # This test and client should be left after all other references to
	  # CVS_SERVER are removed from this script.
	  #
	  # The client series of tests already tests that CVS_SERVER is
	  # working, but that test might be better here.
	  if $remote; then
	    mkdir fork; cd fork
	    unset CVS_SERVER
	    # So looking through $PATH for cvs won't work...
	    echo "echo junk" >cvs
	    chmod a+x cvs
	    save_PATH=$PATH; PATH=.:$PATH
	    dotest fork-1 "$testcvs -d:fork:$CVSROOT_DIRNAME version" \
'Client: \(.*\)
Server: \1'
	    CVS_SERVER=${testcvs}; export CVS_SERVER
	    PATH=$save_PATH; unset save_PATH
	    cd ..
	    if $keep; then :; else
	      rm -rf fork
	    fi
	  fi
	  ;;

a20793 8
# Sanity check sanity.sh.  :)
#
# Test our exit directory so that tests that exit in an incorrect directory are
# noticed during single test runs.
if test "x$TESTDIR" != "x`pwd`"; then
	fail "cleanup: PWD != TESTDIR (\``pwd`' != \`$TESTDIR')"
fi

d20797 1
a20831 8
#   - Test 'cvs history' with symlinks in the path to the working directory.
#   - Remove most of the CVS_SERVER stuff after a reasonable amount of time.
#     The "fork" & "client" series of tests should be left.  4/2/00, CVS
#     1.11.0.1 was altered so that it would default to program_name (set from
#     argv[0]) rather than "cvs", but I'd like this script to work on legacy
#     versions of CVS for awhile.
#   - Testsuite doesn't work with usernames over eight characters in length.
#     Fix it.
a20833 6
# Exit if keep set
if $keep; then
  echo "Keeping ${TESTDIR} and exiting due to -k (keep) option."
  exit 0
fi

d20835 1
a20835 1
cd `dirname ${TESTDIR}`
@


