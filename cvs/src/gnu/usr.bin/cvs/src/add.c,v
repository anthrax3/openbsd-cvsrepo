head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.16
	OPENBSD_6_1:1.1.1.16.0.66
	OPENBSD_6_1_BASE:1.1.1.16
	OPENBSD_6_0:1.1.1.16.0.62
	OPENBSD_6_0_BASE:1.1.1.16
	OPENBSD_5_9:1.1.1.16.0.58
	OPENBSD_5_9_BASE:1.1.1.16
	OPENBSD_5_8:1.1.1.16.0.60
	OPENBSD_5_8_BASE:1.1.1.16
	OPENBSD_5_7:1.1.1.16.0.52
	OPENBSD_5_7_BASE:1.1.1.16
	OPENBSD_5_6:1.1.1.16.0.56
	OPENBSD_5_6_BASE:1.1.1.16
	OPENBSD_5_5:1.1.1.16.0.54
	OPENBSD_5_5_BASE:1.1.1.16
	OPENBSD_5_4:1.1.1.16.0.50
	OPENBSD_5_4_BASE:1.1.1.16
	OPENBSD_5_3:1.1.1.16.0.48
	OPENBSD_5_3_BASE:1.1.1.16
	OPENBSD_5_2:1.1.1.16.0.46
	OPENBSD_5_2_BASE:1.1.1.16
	OPENBSD_5_1_BASE:1.1.1.16
	OPENBSD_5_1:1.1.1.16.0.44
	OPENBSD_5_0:1.1.1.16.0.42
	OPENBSD_5_0_BASE:1.1.1.16
	OPENBSD_4_9:1.1.1.16.0.40
	OPENBSD_4_9_BASE:1.1.1.16
	OPENBSD_4_8:1.1.1.16.0.38
	OPENBSD_4_8_BASE:1.1.1.16
	OPENBSD_4_7:1.1.1.16.0.34
	OPENBSD_4_7_BASE:1.1.1.16
	OPENBSD_4_6:1.1.1.16.0.36
	OPENBSD_4_6_BASE:1.1.1.16
	OPENBSD_4_5:1.1.1.16.0.32
	OPENBSD_4_5_BASE:1.1.1.16
	OPENBSD_4_4:1.1.1.16.0.30
	OPENBSD_4_4_BASE:1.1.1.16
	OPENBSD_4_3:1.1.1.16.0.28
	OPENBSD_4_3_BASE:1.1.1.16
	OPENBSD_4_2:1.1.1.16.0.26
	OPENBSD_4_2_BASE:1.1.1.16
	OPENBSD_4_1:1.1.1.16.0.24
	OPENBSD_4_1_BASE:1.1.1.16
	OPENBSD_4_0:1.1.1.16.0.22
	OPENBSD_4_0_BASE:1.1.1.16
	OPENBSD_3_9:1.1.1.16.0.20
	OPENBSD_3_9_BASE:1.1.1.16
	OPENBSD_3_8:1.1.1.16.0.18
	OPENBSD_3_8_BASE:1.1.1.16
	OPENBSD_3_7:1.1.1.16.0.16
	OPENBSD_3_7_BASE:1.1.1.16
	OPENBSD_3_6:1.1.1.16.0.14
	OPENBSD_3_6_BASE:1.1.1.16
	OPENBSD_3_5:1.1.1.16.0.12
	OPENBSD_3_5_BASE:1.1.1.16
	OPENBSD_3_4:1.1.1.16.0.10
	OPENBSD_3_4_BASE:1.1.1.16
	OPENBSD_3_3:1.1.1.16.0.8
	OPENBSD_3_3_BASE:1.1.1.16
	OPENBSD_3_2:1.1.1.16.0.6
	OPENBSD_3_2_BASE:1.1.1.16
	OPENBSD_3_1:1.1.1.16.0.4
	OPENBSD_3_1_BASE:1.1.1.16
	OPENBSD_3_0:1.1.1.16.0.2
	OPENBSD_3_0_BASE:1.1.1.16
	cvs-1-11-1p1:1.1.1.16
	OPENBSD_2_9:1.1.1.15.0.2
	OPENBSD_2_9_BASE:1.1.1.15
	cvs-1-11:1.1.1.15
	OPENBSD_2_8:1.1.1.14.0.6
	OPENBSD_2_8_BASE:1.1.1.14
	OPENBSD_2_7:1.1.1.14.0.4
	OPENBSD_2_7_BASE:1.1.1.14
	OPENBSD_2_6:1.1.1.14.0.2
	OPENBSD_2_6_BASE:1.1.1.14
	cvs-1-10-7:1.1.1.14
	OPENBSD_2_5:1.1.1.13.0.2
	OPENBSD_2_5_BASE:1.1.1.13
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.1.1.12.0.2
	OPENBSD_2_4_BASE:1.1.1.12
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.55;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.36;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.15;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.21;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.17;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.54;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.26.51;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.32;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.20.59;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.23;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.08.22.20.52.50;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.32.35;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.09.10.05.06.20;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.02.10.18.57.37;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Add
 * 
 * Adds a file or directory to the RCS source repository.  For a file,
 * the entry is marked as "needing to be added" in the user's own CVS
 * directory, and really added to the repository when it is committed.
 * For a directory, it is added at the appropriate place in the source
 * repository and a CVS directory is generated within the directory.
 * 
 * The -m option is currently the only supported option.  Some may wish to
 * supply standard "rcs" options here, but I've found that this causes more
 * trouble than anything else.
 * 
 * The user files or directories must already exist.  For a directory, it must
 * not already have a CVS file in it.
 * 
 * An "add" on a file that has been "remove"d but not committed will cause the
 * file to be resurrected.
 */

#include "cvs.h"
#include "save-cwd.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)add.c 1.55 94/10/22 $";
USE(rcsid);
#endif

static int add_directory PROTO((char *repository, char *dir));
static int build_entry PROTO((char *repository, char *user, char *options,
		        char *message, List * entries, char *tag));

static const char *const add_usage[] =
{
    "Usage: %s %s [-k rcs-kflag] [-m message] files...\n",
    "\t-k\tUse \"rcs-kflag\" to add the file with the specified kflag.\n",
    "\t-m\tUse \"message\" for the creation log.\n",
    NULL
};

int
add (argc, argv)
    int argc;
    char **argv;
{
    char *message = NULL;
    char *user;
    int i;
    char *repository;
    int c;
    int err = 0;
    int added_files = 0;
    char *options = NULL;
    List *entries;
    Vers_TS *vers;

    if (argc == 1 || argc == -1)
	usage (add_usage);

    wrap_setup ();

    /* parse args */
    optind = 1;
    while ((c = getopt (argc, argv, "k:m:")) != -1)
    {
	switch (c)
	{
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;

	    case 'm':
		message = xstrdup (optarg);
		break;
	    case '?':
	    default:
		usage (add_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    if (argc <= 0)
	usage (add_usage);

    /* find the repository associated with our current dir */
    repository = Name_Repository ((char *) NULL, (char *) NULL);

#ifdef CLIENT_SUPPORT
    if (client_active)
      {
	int i;
	start_server ();
	ign_setup ();
	option_with_arg ("-k", options);
	option_with_arg ("-m", message);
	for (i = 0; i < argc; ++i)
	  /* FIXME: Does this erroneously call Create_Admin in error
	     conditions which are only detected once the server gets its
	     hands on things?  */
	  if (isdir (argv[i]))
	    {
	      char *tag;
	      char *date;
	      char *rcsdir = xmalloc (strlen (repository)
				      + strlen (argv[i]) + 10);

	      /* before we do anything else, see if we have any
		 per-directory tags */
	      ParseTag (&tag, &date);

	      sprintf (rcsdir, "%s/%s", repository, argv[i]);

	      Create_Admin (argv[i], argv[i], rcsdir, tag, date);

	      if (tag)
		free (tag);
	      if (date)
		free (date);
	      free (rcsdir);
	    }
	send_files (argc, argv, 0, 0);
	if (fprintf (to_server, "add\n") < 0)
	  error (1, errno, "writing to server");
	return get_responses_and_close ();
      }
#endif

    entries = Entries_Open (0);

    /* walk the arg list adding files/dirs */
    for (i = 0; i < argc; i++)
    {
	int begin_err = err;
	int begin_added_files = added_files;

	user = argv[i];
	strip_trailing_slashes (user);
	if (strchr (user, '/') != NULL)
	{
	    error (0, 0,
	     "cannot add files with '/' in their name; %s not added", user);
	    err++;
	    continue;
	}

	vers = Version_TS (repository, options, (char *) NULL, (char *) NULL,
			   user, 0, 0, entries, (List *) NULL);
	if (vers->vn_user == NULL)
	{
	    /* No entry available, ts_rcs is invalid */
	    if (vers->vn_rcs == NULL)
	    {
		/* There is no RCS file either */
		if (vers->ts_user == NULL)
		{
		    /* There is no user file either */
		    error (0, 0, "nothing known about %s", user);
		    err++;
		}
		else if (!isdir (user) || wrap_name_has (user, WRAP_TOCVS))
		{
		    /*
		     * See if a directory exists in the repository with
		     * the same name.  If so, blow this request off.
		     */
		    char dname[PATH_MAX];
		    (void) sprintf (dname, "%s/%s", repository, user);
		    if (isdir (dname))
		    {
			error (0, 0,
			       "cannot add file `%s' since the directory",
			       user);
			error (0, 0, "`%s' already exists in the repository",
			       dname);
			error (1, 0, "illegal filename overlap");
		    }

		    /* There is a user file, so build the entry for it */
		    if (build_entry (repository, user, vers->options,
				     message, entries, vers->tag) != 0)
			err++;
		    else 
		    {
			added_files++;
			if (!quiet)
			{
#ifdef DEATH_SUPPORT
			    if (vers->tag)
				error (0, 0, "\
scheduling %s `%s' for addition on branch `%s'",
				       (wrap_name_has (user, WRAP_TOCVS)
					? "wrapper"
					: "file"),
				       user, vers->tag);
			    else
#endif /* DEATH_SUPPORT */
			    error (0, 0, "scheduling %s `%s' for addition",
				   (wrap_name_has (user, WRAP_TOCVS)
				    ? "wrapper"
				    : "file"),
				   user);
			}
		    }
		}
	    }
#ifdef DEATH_SUPPORT
	    else if (RCS_isdead (vers->srcfile, vers->vn_rcs))
	    {
		if (isdir (user) && !wrap_name_has (user, WRAP_TOCVS))
		{
		    error (0, 0, "the directory `%s' cannot be added because a file of the", user);
		    error (1, 0, "same name already exists in the repository.");
		}
		else
		{
		    if (vers->tag)
			error (0, 0, "file `%s' will be added on branch `%s' from version %s",
			       user, vers->tag, vers->vn_rcs);
		    else
			error (0, 0, "version %s of `%s' will be resurrected",
			       vers->vn_rcs, user);
		    Register (entries, user, "0", vers->ts_user, NULL,
			      vers->tag, NULL, NULL);
		    ++added_files;
		}
	    }
#endif /* DEATH_SUPPORT */
	    else
	    {
		/*
		 * There is an RCS file already, so somebody else must've
		 * added it
		 */
		error (0, 0, "%s added independently by second party", user);
		err++;
	    }
	}
	else if (vers->vn_user[0] == '0' && vers->vn_user[1] == '\0')
	{

	    /*
	     * An entry for a new-born file, ts_rcs is dummy, but that is
	     * inappropriate here
	     */
	    error (0, 0, "%s has already been entered", user);
	    err++;
	}
	else if (vers->vn_user[0] == '-')
	{
	    /* An entry for a removed file, ts_rcs is invalid */
	    if (vers->ts_user == NULL)
	    {
		/* There is no user file (as it should be) */
		if (vers->vn_rcs == NULL)
		{

		    /*
		     * There is no RCS file, so somebody else must've removed
		     * it from under us
		     */
		    error (0, 0,
			   "cannot resurrect %s; RCS file removed by second party", user);
		    err++;
		}
		else
		{

		    /*
		     * There is an RCS file, so remove the "-" from the
		     * version number and restore the file
		     */
		    char *tmp = xmalloc (strlen (user) + 50);

		    (void) strcpy (tmp, vers->vn_user + 1);
		    (void) strcpy (vers->vn_user, tmp);
		    (void) sprintf (tmp, "Resurrected %s", user);
		    Register (entries, user, vers->vn_user, tmp, vers->options,
			      vers->tag, vers->date, vers->ts_conflict);
		    free (tmp);

		    /* XXX - bugs here; this really resurrect the head */
		    /* Note that this depends on the Register above actually
		       having written Entries, or else it won't really
		       check the file out.  */
		    if (update (2, argv + i - 1) == 0)
		    {
			error (0, 0, "%s, version %s, resurrected", user,
			       vers->vn_user);
		    }
		    else
		    {
			error (0, 0, "could not resurrect %s", user);
			err++;
		    }
		}
	    }
	    else
	    {
		/* The user file shouldn't be there */
		error (0, 0, "%s should be removed and is still there (or is back again)", user);
		err++;
	    }
	}
	else
	{
	    /* A normal entry, ts_rcs is valid, so it must already be there */
	    error (0, 0, "%s already exists, with version number %s", user,
		   vers->vn_user);
	    err++;
	}
	freevers_ts (&vers);

	/* passed all the checks.  Go ahead and add it if its a directory */
	if (begin_err == err
	    && isdir (user)
	    && !wrap_name_has (user, WRAP_TOCVS))
	{
	    err += add_directory (repository, user);
	    continue;
	}
#ifdef SERVER_SUPPORT
	if (server_active && begin_added_files != added_files)
	    server_checked_in (user, ".", repository);
#endif
    }
    if (added_files)
	error (0, 0, "use 'cvs commit' to add %s permanently",
	       (added_files == 1) ? "this file" : "these files");

    Entries_Close (entries);

    if (message)
	free (message);

    return (err);
}

/*
 * The specified user file is really a directory.  So, let's make sure that
 * it is created in the RCS source repository, and that the user's directory
 * is updated to include a CVS directory.
 * 
 * Returns 1 on failure, 0 on success.
 */
static int
add_directory (repository, dir)
    char *repository;
    char *dir;
{
    char rcsdir[PATH_MAX];
    struct saved_cwd cwd;
    char message[PATH_MAX + 100];
    char *tag, *date;

    if (strchr (dir, '/') != NULL)
    {
	error (0, 0,
	       "directory %s not added; must be a direct sub-directory", dir);
	return (1);
    }
    if (strcmp (dir, CVSADM) == 0)
    {
	error (0, 0, "cannot add a `%s' directory", CVSADM);
	return (1);
    }

    /* before we do anything else, see if we have any per-directory tags */
    ParseTag (&tag, &date);

    /* now, remember where we were, so we can get back */
    if (save_cwd (&cwd))
	return (1);
    if (chdir (dir) < 0)
    {
	error (0, errno, "cannot chdir to %s", dir);
	return (1);
    }
#ifdef SERVER_SUPPORT
    if (!server_active && isfile (CVSADM))
#else
    if (isfile (CVSADM))
#endif
    {
	error (0, 0, "%s/%s already exists", dir, CVSADM);
	goto out;
    }

    (void) sprintf (rcsdir, "%s/%s", repository, dir);
    if (isfile (rcsdir) && !isdir (rcsdir))
    {
	error (0, 0, "%s is not a directory; %s not added", rcsdir, dir);
	goto out;
    }

    /* setup the log message */
    (void) sprintf (message, "Directory %s added to the repository\n", rcsdir);
    if (tag)
    {
	(void) strcat (message, "--> Using per-directory sticky tag `");
	(void) strcat (message, tag);
	(void) strcat (message, "'\n");
    }
    if (date)
    {
	(void) strcat (message, "--> Using per-directory sticky date `");
	(void) strcat (message, date);
	(void) strcat (message, "'\n");
    }

    if (!isdir (rcsdir))
    {
	mode_t omask;
	Node *p;
	List *ulist;

#if 0
	char line[MAXLINELEN];

	(void) printf ("Add directory %s to the repository (y/n) [n] ? ",
		       rcsdir);
	(void) fflush (stdout);
	clearerr (stdin);
	if (fgets (line, sizeof (line), stdin) == NULL ||
	    (line[0] != 'y' && line[0] != 'Y'))
	{
	    error (0, 0, "directory %s not added", rcsdir);
	    goto out;
	}
#endif

	omask = umask ((mode_t) 2);
	if (CVS_MKDIR (rcsdir, 0777) < 0)
	{
	    error (0, errno, "cannot mkdir %s", rcsdir);
	    (void) umask (omask);
	    goto out;
	}
	(void) umask (omask);

	/*
	 * Set up an update list with a single title node for Update_Logfile
	 */
	ulist = getlist ();
	p = getnode ();
	p->type = UPDATE;
	p->delproc = update_delproc;
	p->key = xstrdup ("- New directory");
	p->data = (char *) T_TITLE;
	(void) addnode (ulist, p);
	Update_Logfile (rcsdir, message, (char *) NULL, (FILE *) NULL, ulist);
	dellist (&ulist);
    }

#ifdef SERVER_SUPPORT
    if (!server_active)
	Create_Admin (".", dir, rcsdir, tag, date);
#else
    Create_Admin (".", dir, rcsdir, tag, date);
#endif
    if (tag)
	free (tag);
    if (date)
	free (date);

    (void) printf ("%s", message);
out:
    if (restore_cwd (&cwd, NULL))
      exit (1);
    free_cwd (&cwd);
    return (0);
}

/*
 * Builds an entry for a new file and sets up "CVS/file",[pt] by
 * interrogating the user.  Returns non-zero on error.
 */
static int
build_entry (repository, user, options, message, entries, tag)
    char *repository;
    char *user;
    char *options;
    char *message;
    List *entries;
    char *tag;
{
    char fname[PATH_MAX];
    char line[MAXLINELEN];
    FILE *fp;

#ifndef DEATH_SUPPORT
 /* when using the rcs death support, this case is not a problem. */
    /*
     * There may be an old file with the same name in the Attic! This is,
     * perhaps, an awkward place to check for this, but other places are
     * equally awkward.
     */
    (void) sprintf (fname, "%s/%s/%s%s", repository, CVSATTIC, user, RCSEXT);
    if (isreadable (fname))
    {
	error (0, 0, "there is an old file %s already in %s/%s", user,
	       repository, CVSATTIC);
	return (1);
    }
#endif /* no DEATH_SUPPORT */

    if (noexec)
	return (0);

    /*
     * The options for the "add" command are store in the file CVS/user,p
     * XXX - no they are not!
     */
    (void) sprintf (fname, "%s/%s%s", CVSADM, user, CVSEXT_OPT);
    fp = open_file (fname, "w+");
    if (fclose (fp) == EOF)
	error(1, errno, "cannot close %s", fname);

    /*
     * And the requested log is read directly from the user and stored in the
     * file user,t.  If the "message" argument is set, use it as the
     * initial creation log (which typically describes the file).
     */
    (void) sprintf (fname, "%s/%s%s", CVSADM, user, CVSEXT_LOG);
    fp = open_file (fname, "w+");
    if (message && fputs (message, fp) == EOF)
	    error (1, errno, "cannot write to %s", fname);
    if (fclose(fp) == EOF)
        error(1, errno, "cannot close %s", fname);

    /*
     * Create the entry now, since this allows the user to interrupt us above
     * without needing to clean anything up (well, we could clean up the ,p
     * and ,t files, but who cares).
     */
    (void) sprintf (line, "Initial %s", user);
    Register (entries, user, "0", line, options, tag, (char *) 0, (char *) 0);
    return (0);
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d104 1
a104 1
	if (options) send_arg(options);
a130 1
	send_file_names (argc, argv);
d132 2
a133 1
	send_to_server ("add\012", 0);
d441 1
a441 1
	omask = umask (cvsumask);
d520 10
a529 1
     * The requested log is read directly from the user and stored in the
d542 2
a543 2
     * without needing to clean anything up (well, we could clean up the
     * ,t file, but who cares).
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d28 6
a33 1
#include "savecwd.h"
d197 1
d206 1
d216 1
d237 1
d499 16
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d126 1
a126 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d152 1
a152 1
			   user, 0, 0, entries, (RCSNode *) NULL);
d469 1
a469 1
      exit (EXIT_FAILURE);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d30 1
a30 1
static int add_directory PROTO((char *repository, List *, char *dir));
a117 2
	      strip_trailing_slashes (argv[i]);

a124 13

	      if (strchr (argv[i], '/') == NULL)
		  Subdir_Register ((List *) NULL, (char *) NULL, argv[i]);
	      else
	      {
		  char *cp, *b;

		  cp = xstrdup (argv[i]);
		  b = strrchr (cp, '/');
		  *b++ = '\0';
		  Subdir_Register ((List *) NULL, cp, b);
		  free (cp);
	      }
a139 1
	struct file_info finfo;
d151 2
a152 13
	memset (&finfo, 0, sizeof finfo);
	finfo.file = user;
	finfo.update_dir = "";
	finfo.fullname = user;
	finfo.repository = repository;
	finfo.entries = entries;
	finfo.rcs = NULL;

	/* We pass force_tag_match as 1.  If the directory has a
           sticky branch tag, and there is already an RCS file which
           does not have that tag, then the head revision is
           meaningless to us.  */
	vers = Version_TS (&finfo, options, NULL, NULL, 1, 0);
a182 14
		    if (vers->options == NULL || *vers->options == '\0')
		    {
			/* No options specified on command line (or in
			   rcs file if it existed, e.g. the file exists
			   on another branch).  Check for a value from
			   the wrapper stuff.  */
			if (wrap_name_has (user, WRAP_RCSOPTION))
			{
			    if (vers->options)
				free (vers->options);
			    vers->options = wrap_rcsoption (user, 1);
			}
		    }

d187 1
a187 1
		    else
d222 2
a223 6
			/* I'm not sure that mentioning vers->vn_rcs makes
			   any sense here; I can't think of a way to word the
			   message which is not confusing.  */
			error (0, 0, "\
re-adding file %s (in place of dead revision %s)",
			       user, vers->vn_rcs);
d319 1
a319 1
	    err += add_directory (repository, entries, user);
d347 1
a347 1
add_directory (repository, entries, dir)
a348 1
    List *entries;
d374 1
a374 1
    if ( CVS_CHDIR (dir) < 0)
a415 1
	struct logfile_info *li;
d432 2
a433 1
	if (!noexec)
d435 1
a435 7
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcsdir, 0777) < 0)
	    {
		error (0, errno, "cannot mkdir %s", rcsdir);
		(void) umask (omask);
		goto out;
	    }
d437 1
d439 1
d449 1
a449 4
	li = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
	li->type = T_TITLE;
	li->tag = xstrdup (tag);
	p->data = (char *) li;
d451 1
a451 1
	Update_Logfile (rcsdir, message, (FILE *) NULL, ulist);
a465 6
    if (restore_cwd (&cwd, NULL))
	exit (EXIT_FAILURE);
    free_cwd (&cwd);

    Subdir_Register (entries, (char *) NULL, dir);

a466 3

    return (0);

@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d95 1
a95 1
    {
d102 4
a105 4
	    /* FIXME: Does this erroneously call Create_Admin in error
	       conditions which are only detected once the server gets its
	       hands on things?  */
	    if (isdir (argv[i]))
d107 33
a139 33
		char *tag;
		char *date;
		char *rcsdir = xmalloc (strlen (repository)
					+ strlen (argv[i]) + 10);

		/* before we do anything else, see if we have any
		   per-directory tags */
		ParseTag (&tag, &date);

		sprintf (rcsdir, "%s/%s", repository, argv[i]);

		strip_trailing_slashes (argv[i]);

		Create_Admin (argv[i], argv[i], rcsdir, tag, date);

		if (tag)
		    free (tag);
		if (date)
		    free (date);
		free (rcsdir);

		if (strchr (argv[i], '/') == NULL)
		    Subdir_Register ((List *) NULL, (char *) NULL, argv[i]);
		else
		{
		    char *cp, *b;

		    cp = xstrdup (argv[i]);
		    b = strrchr (cp, '/');
		    *b++ = '\0';
		    Subdir_Register ((List *) NULL, cp, b);
		    free (cp);
		}
d142 1
a142 1
	send_files (argc, argv, 0, 0, 1);
d145 1
a145 1
    }
a153 1
#ifdef SERVER_SUPPORT
a154 1
#endif
d198 1
a198 2
		    char *dname = xmalloc (strlen (repository) + strlen (user)
					   + 10);
a208 1
		    free (dname);
d254 2
a255 4
		    error (0, 0, "\
the directory `%s' cannot be added because a file of the", user);
		    error (1, 0, "\
same name already exists in the repository.");
d260 1
a260 2
			error (0, 0, "\
file `%s' will be added on branch `%s' from version %s",
d307 2
a308 2
		    error (0, 0, "\
cannot resurrect %s; RCS file removed by second party", user);
d346 1
a346 2
		error (0, 0, "\
%s should be removed and is still there (or is back again)", user);
d397 1
a397 1
    char *rcsdir = NULL;
d399 1
a399 1
    char *message = NULL;
a434 1
    rcsdir = xmalloc (strlen (repository) + strlen (dir) + 10);
a442 1
    message = xmalloc (strlen (rcsdir) + 80);
a501 1
	li->rev_old = li->rev_new = NULL;
d520 1
a520 1
	error_exit ();
a525 2
    free (rcsdir);
    free (message);
d531 1
a531 1
	error_exit ();
a532 2
    if (rcsdir != NULL)
	free (rcsdir);
d549 1
a549 1
    char *fname;
a560 1
    fname = xmalloc (strlen (user) + 80);
a566 1
    free (fname);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a41 41
static char *combine_dir PROTO ((char *, char *));

/* Given a directory DIR and a subdirectory within it, SUBDIR, combine
   the two into a new directory name.  Returns a newly malloc'd string.
   For now this is a fairly simple affair, but perhaps it will want
   to have grander ambitions in the context of VMS or others (or perhaps
   not, perhaps that should all be hidden inside CVS_FOPEN and libc and so
   on, and CVS should just see foo/bar/baz style pathnames).  */
static char *
combine_dir (dir, subdir)
    char *dir;
    char *subdir;
{
    char *retval;
    size_t dir_len;

    dir_len = strlen (dir);
    retval = xmalloc (dir_len + strlen (subdir) + 10);
    if (dir_len >= 2
	&& dir[dir_len - 1] == '.'
	&& ISDIRSEP (dir[dir_len - 2]))
    {
	/* The dir name has an extraneous "." at the end.
	   I'm not completely sure that this is the best place
	   to strip it off--it is possible that Name_Repository
	   should do so, or it shouldn't be in the CVS/Repository
	   file in the first place.  Fixing it here seems like
	   a safe, small change, but I'm not sure it catches
	   all the cases.  */
	strncpy (retval, dir, dir_len - 2);
	retval[dir_len - 2] = '\0';
    }
    else
    {
	strcpy (retval, dir);
    }
    strcat (retval, "/");
    strcat (retval, subdir);
    return retval;
}

d109 2
a110 1
		char *rcsdir;
d116 1
a116 1
		rcsdir = combine_dir (repository, argv[i]);
d142 1
a142 1
	send_files (argc, argv, 0, 0, 1, 0);
d443 2
a444 1
    rcsdir = combine_dir (repository, dir);
d474 14
a487 7
	/* There used to be some code here which would prompt for
	   whether to add the directory.  The details of that code had
	   bitrotted, but more to the point it can't work
	   client/server, doesn't ask in the right way for GUIs, etc.
	   A better way of making it harder to accidentally add
	   directories would be to have to add and commit directories
	   like for files.  The code was #if 0'd at least since CVS 1.5.  */
d565 1
a565 1
    char *line;
a589 1
    line = xmalloc (strlen (user) + 20);
a591 1
    free (line);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d106 1
a106 1
    while ((c = getopt (argc, argv, "+k:m:")) != -1)
a149 1
		int nonbranch;
d154 1
a154 1
		ParseTag (&tag, &date, &nonbranch);
d160 1
a160 1
		Create_Admin (argv[i], argv[i], rcsdir, tag, date, nonbranch);
d182 1
a182 2
	/* FIXME: should be able to pass SEND_NO_CONTENTS, I think.  */
	send_files (argc, argv, 0, 0, SEND_BUILD_DIRS);
d268 4
a271 7
		    if (vers->nonbranch)
		    {
			error (0, 0,
			       "cannot add file on non-branch tag %s",
			       vers->tag);
			++err;
		    }
d274 2
a275 5
			/* There is a user file, so build the entry for it */
			if (build_entry (repository, user, vers->options,
					 message, entries, vers->tag) != 0)
			    err++;
			else
d277 2
a278 5
			    added_files++;
			    if (!quiet)
			    {
				if (vers->tag)
				    error (0, 0, "\
d280 10
a289 12
					   (wrap_name_has (user, WRAP_TOCVS)
					    ? "wrapper"
					    : "file"),
					   user, vers->tag);
				else
				    error (0, 0,
					   "scheduling %s `%s' for addition",
					   (wrap_name_has (user, WRAP_TOCVS)
					    ? "wrapper"
					    : "file"),
					   user);
			    }
d305 4
a308 7
		    if (vers->nonbranch)
		    {
			error (0, 0,
			       "cannot add file on non-branch tag %s",
			       vers->tag);
			++err;
		    }
d310 4
a313 11
		    {
			if (vers->tag)
			    error (0, 0, "\
file `%s' will be added on branch `%s' from version %s",
				   user, vers->tag, vers->vn_rcs);
			else
			    /* I'm not sure that mentioning
			       vers->vn_rcs makes any sense here; I
			       can't think of a way to word the
			       message which is not confusing.  */
			    error (0, 0, "\
d315 4
a318 5
				   user, vers->vn_rcs);
			Register (entries, user, "0", vers->ts_user, NULL,
				  vers->tag, NULL, NULL);
			++added_files;
		    }
a448 1
    int nonbranch;
d463 1
a463 1
    ParseTag (&tag, &date, &nonbranch);
d553 1
a553 1
	Create_Admin (".", dir, rcsdir, tag, date, nonbranch);
d555 1
a555 1
    Create_Admin (".", dir, rcsdir, tag, date, nonbranch);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d105 1
a105 1
    optind = 0;
a185 3
	if (message)
	    free (message);
	free (repository);
a451 1
    free (repository);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a28 1
#include "fileattr.h"
d30 1
a30 1
static int add_directory PROTO ((struct file_info *finfo));
a38 1
    "(Specify the --help global option for a list of other help options)\n",
d42 41
d89 1
a97 1
    struct saved_cwd cwd;
d131 2
a132 36
    /* First some sanity checks.  I know that the CVS case is (sort of)
       also handled by add_directory, but we need to check here so the
       client won't get all confused in send_file_names.  */
    for (i = 0; i < argc; i++)
    {
	int skip_file = 0;

	/* If it were up to me I'd probably make this a fatal error.
	   But some people are really fond of their "cvs add *", and
	   don't seem to object to the warnings.
	   Whatever.  */
	strip_trailing_slashes (argv[i]);
	if (strcmp (argv[i], ".") == 0
	    || strcmp (argv[i], "..") == 0
	    || fncmp (argv[i], CVSADM) == 0)
	{
	    error (0, 0, "cannot add special file `%s'; skipping", argv[i]);
	    skip_file = 1;
	}

	if (skip_file)
	{
	    int j;

	    /* FIXME: We don't do anything about free'ing argv[i].  But
	       the problem is that it is only sometimes allocated (see
	       cvsrc.c).  */

	    for (j = i; j < argc - 1; ++j)
		argv[j] = argv[j + 1];
	    --argc;
	    /* Check the new argv[i] again.  */
	    --i;
	    ++err;
	}
    }
a137 8

	if (argc == 0)
	    /* We snipped out all the arguments in the above sanity
	       check.  We can just forget the whole thing (and we
	       better, because if we fired up the server and passed it
	       nothing, it would spit back a usage message).  */
	    return err;

a141 5

	repository = Name_Repository (NULL, NULL);
	send_a_repository ("", repository, "");
	free (repository);

a151 26
		char *p;
		char *update_dir;
		/* This is some mungeable storage into which we can point
		   with p and/or update_dir.  */
		char *filedir;

		if (save_cwd (&cwd))
		    error_exit ();

		filedir = xstrdup (argv[i]);
		p = last_component (filedir);
		if (p == filedir)
		{
		    update_dir = "";
		}
		else
		{
		    p[-1] = '\0';
		    update_dir = filedir;
		    if (CVS_CHDIR (update_dir) < 0)
			error (1, errno,
			       "could not chdir to %s", update_dir);
		}

		/* find the repository associated with our current dir */
		repository = Name_Repository (NULL, update_dir);
d157 1
a157 5
		rcsdir = xmalloc (strlen (repository) + strlen (p) + 5);
		sprintf (rcsdir, "%s/%s", repository, p);

		Create_Admin (p, argv[i], rcsdir, tag, date,
			      nonbranch, 0);
d159 1
a159 1
		send_a_repository ("", repository, update_dir);
d161 1
a161 3
		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		free_cwd (&cwd);
d169 1
a169 1
		if (p == filedir)
d173 7
a179 1
		    Subdir_Register ((List *) NULL, update_dir, p);
a180 2
		free (repository);
		free (filedir);
d183 2
a184 1
	send_files (argc, argv, 0, 0, SEND_BUILD_DIRS | SEND_NO_CONTENTS);
d188 2
a189 1
	return err + get_responses_and_close ();
d193 2
a202 3
	char *p;

	memset (&finfo, 0, sizeof finfo);
d204 3
a206 6
	if (save_cwd (&cwd))
	    error_exit ();

	finfo.fullname = xstrdup (argv[i]);
	p = last_component (argv[i]);
	if (p == argv[i])
d208 4
a211 10
	    finfo.update_dir = "";
	    finfo.file = p;
	}
	else
	{
	    p[-1] = '\0';
	    finfo.update_dir = argv[i];
	    finfo.file = p;
	    if (CVS_CHDIR (finfo.update_dir) < 0)
		error (1, errno, "could not chdir to %s", finfo.update_dir);
d214 4
a217 11
	/* Add wrappers for this directory.  They exist only until
	   the next call to wrap_add_file.  */
	wrap_add_file (CVSDOTWRAPPER, 1);

	finfo.rcs = NULL;

	/* Find the repository associated with our current dir.  */
	repository = Name_Repository (NULL, finfo.update_dir);

	entries = Entries_Open (0);

d220 1
d236 1
a236 1
		    error (0, 0, "nothing known about %s", finfo.fullname);
d239 1
a239 2
		else if (!isdir (finfo.file)
			 || wrap_name_has (finfo.file, WRAP_TOCVS))
d245 1
a245 2
		    char *dname = xmalloc (strlen (repository)
					   + strlen (finfo.file)
d247 1
a247 1
		    (void) sprintf (dname, "%s/%s", repository, finfo.file);
d252 1
a252 1
			       finfo.fullname);
d265 1
a265 1
			if (wrap_name_has (finfo.file, WRAP_RCSOPTION))
d269 1
a269 1
			    vers->options = wrap_rcsoption (finfo.file, 1);
d283 1
a283 1
			if (build_entry (repository, finfo.file, vers->options,
d294 1
a294 2
					   (wrap_name_has (finfo.file,
							   WRAP_TOCVS)
d297 1
a297 1
					   finfo.fullname, vers->tag);
d301 1
a301 2
					   (wrap_name_has (finfo.file,
							   WRAP_TOCVS)
d304 1
a304 1
					   finfo.fullname);
d312 1
a312 2
		if (isdir (finfo.file)
		    && !wrap_name_has (finfo.file, WRAP_TOCVS))
d315 1
a315 1
the directory `%s' cannot be added because a file of the", finfo.fullname);
d333 1
a333 1
				   finfo.fullname, vers->tag, vers->vn_rcs);
d341 2
a342 3
				   finfo.fullname, vers->vn_rcs);
			Register (entries, finfo.file, "0", vers->ts_user,
				  NULL,
d354 1
a354 2
		error (0, 0, "%s added independently by second party",
		       finfo.fullname);
d365 1
a365 1
	    error (0, 0, "%s has already been entered", finfo.fullname);
d382 1
a382 1
cannot resurrect %s; RCS file removed by second party", finfo.fullname);
d392 1
a392 1
		    char *tmp = xmalloc (strlen (finfo.file) + 50);
d396 2
a397 3
		    (void) sprintf (tmp, "Resurrected %s", finfo.file);
		    Register (entries, finfo.file, vers->vn_user, tmp,
			      vers->options,
d407 1
a407 2
			error (0, 0, "%s, version %s, resurrected",
			       finfo.fullname,
d412 1
a412 1
			error (0, 0, "could not resurrect %s", finfo.fullname);
d421 1
a421 1
%s should be removed and is still there (or is back again)", finfo.fullname);
d428 1
a428 2
	    error (0, 0, "%s already exists, with version number %s",
		   finfo.fullname,
d436 2
a437 2
	    && isdir (finfo.file)
	    && !wrap_name_has (finfo.file, WRAP_TOCVS))
d439 2
a440 1
	    err += add_directory (&finfo);
a441 2
	else
	{
d443 2
a444 2
	    if (server_active && begin_added_files != added_files)
		server_checked_in (finfo.file, finfo.update_dir, repository);
a445 9
	}
	free (repository);
	Entries_Close (entries);

	if (restore_cwd (&cwd, NULL))
	    error_exit ();
	free_cwd (&cwd);

	free (finfo.fullname);
d448 1
a448 2
	error (0, 0, "use '%s commit' to add %s permanently",
	       program_name,
d451 2
d455 1
d468 4
a471 2
add_directory (finfo)
    struct file_info *finfo;
a472 4
    char *repository = finfo->repository;
    List *entries = finfo->entries;
    char *dir = finfo->file;

a477 1
    char *attrs;
a480 1
	/* "Can't happen".  */
d485 1
a485 1
    if (fncmp (dir, CVSADM) == 0)
a493 6
    /* Remember the default attributes from this directory, so we can apply
       them to the new directory.  */
    fileattr_startdir (repository);
    attrs = fileattr_getall (NULL);
    fileattr_free ();

d499 1
a499 1
	error (0, errno, "cannot chdir to %s", finfo->fullname);
d508 1
a508 1
	error (0, 0, "%s/%s already exists", finfo->fullname, CVSADM);
d512 1
a512 2
    rcsdir = xmalloc (strlen (repository) + strlen (dir) + 5);
    sprintf (rcsdir, "%s/%s", repository, dir);
d515 1
a515 2
	error (0, 0, "%s is not a directory; %s not added", rcsdir,
	       finfo->fullname);
d520 1
a520 4
    message = xmalloc (strlen (rcsdir)
		       + 80
		       + (tag == NULL ? 0 : strlen (tag) + 80)
		       + (date == NULL ? 0 : strlen (date) + 80));
a561 9
	/* Now set the default file attributes to the ones we inherited
	   from the parent directory.  */
	fileattr_startdir (rcsdir);
	fileattr_setall (NULL, attrs);
	fileattr_write ();
	fileattr_free ();
	if (attrs != NULL)
	    free (attrs);

d582 1
a582 1
	Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0);
d584 1
a584 1
    Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0);
d597 1
a597 2
    cvs_output (message, 0);

@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d267 1
a267 1
	entries = Entries_Open (0, NULL);
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a58 3
    /* Nonzero if we found a slash, and are thus adding files in a
       subdirectory.  */
    int found_slash = 0;
a110 14
	else
	{
	    char *p;
	    p = argv[i];
	    while (*p != '\0')
	    {
		if (ISDIRSEP (*p))
		{
		    found_slash = 1;
		    break;
		}
		++p;
	    }
	}
d146 3
a148 10
	/* If !found_slash, refrain from sending "Directory", for
	   CVS 1.9 compatibility.  If we only tried to deal with servers
	   which are at least CVS 1.9.26 or so, we wouldn't have to
	   special-case this.  */
	if (found_slash)
	{
	    repository = Name_Repository (NULL, NULL);
	    send_a_repository ("", repository, "");
	    free (repository);
	}
d197 1
a197 2
		if (found_slash)
		    send_a_repository ("", repository, update_dir);
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d243 1
a244 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d423 1
a423 1
				  vers->options,
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@a174 1
	{
a177 10
	    /* FIXME-also: if filenames are case-insensitive on the
	       client, and the directory in the repository already
	       exists and is named "foo", and the command is "cvs add
	       FOO", this call to Create_Admin puts the wrong thing in
	       CVS/Repository and so a subsequent "cvs update" will
	       give an error.  The fix will be to have the server report
	       back what it actually did (e.g. use tagged text for the
	       "Directory %s added" message), and then Create_Admin,
	       which should also fix the error handling concerns.  */

a242 1
	}
a260 3
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	char *found_name;
#endif
a296 54
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case)
	{
	    /* Need to check whether there is a directory with the
	       same name but different case.  We'll check for files
	       with the same name later (when Version_TS calls
	       RCS_parse which calls fopen_case).  If CVS some day
	       records directories in the RCS files, then we should be
	       able to skip the separate check here, which would be
	       cleaner.  */
	    DIR *dirp;
	    struct dirent *dp;

	    dirp = CVS_OPENDIR (finfo.repository);
	    if (dirp == NULL)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    found_name = NULL;
	    errno = 0;
	    while ((dp = readdir (dirp)) != NULL)
	    {
		if (cvs_casecmp (dp->d_name, finfo.file) == 0)
		{
		    if (found_name != NULL)
			error (1, 0, "%s is ambiguous; could mean %s or %s",
			       finfo.file, dp->d_name, found_name);
		    found_name = xstrdup (dp->d_name);
		}
	    }
	    if (errno != 0)
		error (1, errno, "cannot read directory %s", finfo.repository);
	    closedir (dirp);

	    if (found_name != NULL)
	    {
		/* OK, we are about to patch up the name, so patch up
		   the temporary directory too to match.  The isdir
		   should "always" be true (since files have ,v), but
		   I guess we might as well make some attempt to not
		   get confused by stray files in the repository.  */
		if (isdir (finfo.file))
		{
		    if (CVS_MKDIR (found_name, 0777) < 0
			&& errno != EEXIST)
			error (0, errno, "cannot create %s", finfo.file);
		}

		/* OK, we found a directory with the same name, maybe in
		   a different case.  Treat it as if the name were the
		   same.  */
		finfo.file = found_name;
	    }
	}
#endif

a540 4
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
	if (ign_case && found_name != NULL)
	    free (found_name);
#endif
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@a61 1
    size_t cvsroot_len;
a94 2
    cvsroot_len = strlen (CVSroot_directory);

d160 1
a160 5
	if (options)
	{
	    send_arg (options);
	    free (options);
	}
a221 11
		/* don't add stuff to Emptydir */
		if (strncmp (repository, CVSroot_directory, cvsroot_len) == 0
		    && ISDIRSEP (repository[cvsroot_len])
		    && strncmp (repository + cvsroot_len + 1,
				CVSROOTADM,
				sizeof CVSROOTADM - 1) == 0
		    && ISDIRSEP (repository[cvsroot_len + sizeof CVSROOTADM])
		    && strcmp (repository + cvsroot_len + sizeof CVSROOTADM + 1,
			       CVSNULLREPOS) == 0)
		    error (1, 0, "cannot add to %s", repository);

d230 1
a230 1
			      nonbranch, 0, 1);
a306 11
	/* don't add stuff to Emptydir */
	if (strncmp (repository, CVSroot_directory, cvsroot_len) == 0
	    && ISDIRSEP (repository[cvsroot_len])
	    && strncmp (repository + cvsroot_len + 1,
			CVSROOTADM,
			sizeof CVSROOTADM - 1) == 0
	    && ISDIRSEP (repository[cvsroot_len + sizeof CVSROOTADM])
	    && strcmp (repository + cvsroot_len + sizeof CVSROOTADM + 1,
		       CVSNULLREPOS) == 0)
	    error (1, 0, "cannot add to %s", repository);

a621 2
    if (options)
	free (options);
d772 3
a775 1
        Create_Admin (".", finfo->fullname, rcsdir, tag, date, nonbranch, 0, 1);
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@d96 1
a96 1
    cvsroot_len = strlen (current_parsed_root->directory);
d114 1
a114 2
	    if (!quiet)
		error (0, 0, "cannot add special file `%s'; skipping", argv[i]);
d150 1
a150 1
    if (current_parsed_root->isremote)
d230 1
a230 1
		if (strncmp (repository, current_parsed_root->directory, cvsroot_len) == 0
d326 1
a326 1
	if (strncmp (repository, current_parsed_root->directory, cvsroot_len) == 0
d359 1
a359 1
	    while ((dp = CVS_READDIR (dirp)) != NULL)
d371 1
a371 1
	    CVS_CLOSEDIR (dirp);
d451 2
a452 2
				"cannot add file on non-branch tag %s",
				vers->tag);
d508 2
a509 4
			if (!quiet)
			{
			    if (vers->tag)
				error (0, 0, "\
d511 7
a517 7
					finfo.fullname, vers->tag, vers->vn_rcs);
			    else
				/* I'm not sure that mentioning
				   vers->vn_rcs makes any sense here; I
				   can't think of a way to word the
				   message which is not confusing.  */
				error (0, 0, "\
d519 1
a519 2
					finfo.fullname, vers->vn_rcs);
			}
d545 1
a545 2
	    if (!quiet)
		error (0, 0, "%s has already been entered", finfo.fullname);
d610 3
a612 4
	    if (!quiet)
		error (0, 0, "%s already exists, with version number %s",
			finfo.fullname,
			vers->vn_user);
d644 1
a644 1
    if (added_files && !really_quiet)
@


