head	1.21;
access;
symbols
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.18
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.14
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.16
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.8
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.12
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.10
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.36
	OPENBSD_5_0:1.20.0.34
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.32
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.30
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.26
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.28
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.24
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.22
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.20
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.18
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.16
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.14
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.12
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	cvs-1-11-1p1:1.1.1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	cvs-1-11:1.1.1.16
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	cvs-1-10-7:1.1.1.15
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	cvs-1-10-5:1.1.1.14
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	cvs-1-10:1.1.1.13
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.06.18.41.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.08.08.01.45;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.10.19.31.36;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.21.18.25.54;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.09.10.05.21.33;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	99.02.28.21.58.05;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	98.08.22.21.04.44;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	98.07.13.04.17.10;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.05.14.21.16.39;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.03.12.07.22.50;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	98.02.22.08.56.10;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.06.28.03.45.33;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.04.21.04.41.11;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.03.18.02.10.02;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.02.21.06.55.02;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.10.18.04.19.47;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.06.22.51.21;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.05.04.07.26.05;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.34;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.23;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.10;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.58;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.56;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.32;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.28.03;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.29.03;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.41;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.59.18;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.54.34;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.08.22.20.54.06;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.02.28.21.33.42;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.09.10.05.06.28;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.02.10.18.57.48;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.09.28.22.45.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.21
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 *
 * "update" updates the version in the present directory with respect to the RCS
 * repository.  The present version must have been created by "checkout". The
 * user can keep up-to-date by calling "update" whenever he feels like it.
 *
 * The present version can be committed by "commit", but this keeps the version
 * in tact.
 *
 * Arguments following the options are taken to be file names to be updated,
 * rather than updating the entire directory.
 *
 * Modified or non-existent RCS files are checked out and reported as U
 * <user_file>
 *
 * Modified user files are reported as M <user_file>.  If both the RCS file and
 * the user file have been modified, the user file is replaced by the result
 * of rcsmerge, and a backup file is written for the user in .#file.version.
 * If this throws up irreconcilable differences, the file is reported as C
 * <user_file>, and as M <user_file> otherwise.
 *
 * Files added but not yet committed are reported as A <user_file>. Files
 * removed but not yet committed are reported as R <user_file>.
 *
 * If the current directory contains subdirectories that hold concurrent
 * versions, these are updated too.  If the -d option was specified, new
 * directories added to the repository are automatically created and updated
 * as well.
 */

#include "cvs.h"
#include "savecwd.h"
#ifdef SERVER_SUPPORT
#include "md5.h"
#endif
#include "watch.h"
#include "fileattr.h"
#include "edit.h"
#include "getline.h"
#include "buffer.h"
#include "hardlink.h"

static int checkout_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts,
				 int adding, int merging, int update_server));
#ifdef SERVER_SUPPORT
static void checkout_to_buffer PROTO ((void *, const char *, size_t));
#endif
#ifdef SERVER_SUPPORT
static int patch_file PROTO ((struct file_info *finfo,
			      Vers_TS *vers_ts, 
			      int *docheckout, struct stat *file_info,
			      unsigned char *checksum));
static void patch_file_write PROTO ((void *, const char *, size_t));
#endif
static int merge_file PROTO ((struct file_info *finfo, Vers_TS *vers));
static int scratch_file PROTO((struct file_info *finfo, Vers_TS *vers));
static Dtype update_dirent_proc PROTO ((void *callerdat, char *dir,
					char *repository, char *update_dir,
					List *entries));
static int update_dirleave_proc PROTO ((void *callerdat, char *dir,
					int err, char *update_dir,
					List *entries));
static int update_fileproc PROTO ((void *callerdat, struct file_info *));
static int update_filesdone_proc PROTO ((void *callerdat, int err,
					 char *repository, char *update_dir,
					 List *entries));
#ifdef PRESERVE_PERMISSIONS_SUPPORT
static int get_linkinfo_proc PROTO ((void *callerdat, struct file_info *));
#endif
static void write_letter PROTO ((struct file_info *finfo, int letter));
static void join_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts));

static char *options = NULL;
static char *tag = NULL;
static char *date = NULL;
/* This is a bit of a kludge.  We call WriteTag at the beginning
   before we know whether nonbranch is set or not.  And then at the
   end, once we have the right value for nonbranch, we call WriteTag
   again.  I don't know whether the first call is necessary or not.
   rewrite_tag is nonzero if we are going to have to make that second
   call.  */
static int rewrite_tag;
static int nonbranch;

/* If we set the tag or date for a subdirectory, we use this to undo
   the setting.  See update_dirent_proc.  */
static char *tag_update_dir;

static char *join_rev1, *date_rev1;
static char *join_rev2, *date_rev2;
static int aflag = 0;
static int toss_local_changes = 0;
static int force_tag_match = 1;
static int update_build_dirs = 0;
static int update_prune_dirs = 0;
static int pipeout = 0;
static int dotemplate = 0;
#ifdef SERVER_SUPPORT
static int patches = 0;
static int rcs_diff_patches = 0;
#endif
static List *ignlist = (List *) NULL;
static time_t last_register_time;
static const char *const update_usage[] =
{
    "Usage: %s %s [-APCdflRp] [-k kopt] [-r rev] [-D date] [-j rev]\n",
    "    [-I ign] [-W spec] [-t id] [files...]\n",
    "\t-A\tReset any sticky tags/date/kopts.\n",
    "\t-P\tPrune empty directories.\n",
    "\t-C\tOverwrite locally modified files with clean repository copies.\n",
    "\t-d\tBuild directories, like checkout does.\n",
    "\t-f\tForce a head revision match if tag/date not found.\n",
    "\t-l\tLocal directory only, no recursion.\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-p\tSend updates to standard output (avoids stickiness).\n",
    "\t-k kopt\tUse RCS kopt -k option on checkout. (is sticky)\n",
    "\t-r rev\tUpdate using specified revision/tag (is sticky).\n",
    "\t-D date\tSet date to update from (is sticky).\n",
    "\t-j rev\tMerge in changes made between current revision and rev.\n",
    "\t-I ign\tMore files to ignore (! to reset).\n",
    "\t-W spec\tWrappers specification line.\n",
    "\t-t id\tRCS identifier to expand on update.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

/*
 * update is the argv,argc based front end for arg parsing
 */
int
update (argc, argv)
    int argc;
    char **argv;
{
    int c, err;
    int local = 0;			/* recursive by default */
    int which;				/* where to look for files and dirs */

    if (argc == -1)
	usage (update_usage);

    ign_setup ();
    wrap_setup ();

    /* parse the args */
    optind = 0;
    while ((c = getopt (argc, argv, "+ApCPflRQqduk:r:t:D:j:I:W:")) != -1)
    {
	switch (c)
	{
	    case 'A':
		aflag = 1;
		break;
	    case 'C':
		toss_local_changes = 1;
		break;
	    case 'I':
		ign_add (optarg, 0);
		break;
	    case 'W':
		wrap_add (optarg, 0);
		break;
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'Q':
	    case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
#endif
		    error (1, 0,
			   "-q or -Q must be specified before \"%s\"",
			   command_name);
		break;
	    case 'd':
		update_build_dirs = 1;
		break;
	    case 'f':
		force_tag_match = 0;
		break;
	    case 'r':
		tag = optarg;
		break;
	    case 't':
		if (RCS_citag)
		    free(RCS_citag);
		RCS_citag = strdup(optarg);
		break;
	    case 'D':
		date = Make_Date (optarg);
		break;
	    case 'P':
		update_prune_dirs = 1;
		break;
	    case 'p':
		pipeout = 1;
		noexec = 1;		/* so no locks will be created */
		break;
	    case 'j':
		if (join_rev2)
		    error (1, 0, "only two -j options can be specified");
		if (join_rev1)
		    join_rev2 = optarg;
		else
		    join_rev1 = optarg;
		break;
	    case 'u':
#ifdef SERVER_SUPPORT
		if (server_active)
		{
		    patches = 1;
		    rcs_diff_patches = server_use_rcs_diff ();
		}
		else
#endif
		    usage (update_usage);
		break;
	    case '?':
	    default:
		usage (update_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote) 
    {
	int pass;

	/* The first pass does the regular update.  If we receive at least
	   one patch which failed, we do a second pass and just fetch
	   those files whose patches failed.  */
	pass = 1;
	do
	{
	    int status;

	    start_server ();

	    if (local)
		send_arg("-l");
	    if (update_build_dirs)
		send_arg("-d");
	    if (pipeout)
		send_arg("-p");
	    if (!force_tag_match)
		send_arg("-f");
	    if (aflag)
		send_arg("-A");
	    if (toss_local_changes)
		send_arg("-C");
	    if (update_prune_dirs)
		send_arg("-P");
	    client_prune_dirs = update_prune_dirs;
	    option_with_arg ("-r", tag);
	    if (options && options[0] != '\0')
		send_arg (options);
	    if (date)
		client_senddate (date);
	    if (join_rev1)
		option_with_arg ("-j", join_rev1);
	    if (join_rev2)
		option_with_arg ("-j", join_rev2);
	    wrap_send ();

	    if (failed_patches_count == 0)
	    {
                unsigned int flags = 0;

		/* If the server supports the command "update-patches", that 
		   means that it knows how to handle the -u argument to update,
		   which means to send patches instead of complete files.

		   We don't send -u if failed_patches != NULL, so that the
		   server doesn't try to send patches which will just fail
		   again.  At least currently, the client also clobbers the
		   file and tells the server it is lost, which also will get
		   a full file instead of a patch, but it seems clean to omit
		   -u.  */
		if (supported_request ("update-patches"))
		    send_arg ("-u");

                if (update_build_dirs)
                    flags |= SEND_BUILD_DIRS;

                if (toss_local_changes) {
                    flags |= SEND_NO_CONTENTS;
                    flags |= BACKUP_MODIFIED_FILES;
                }

		/* If noexec, probably could be setting SEND_NO_CONTENTS.
		   Same caveats as for "cvs status" apply.  */

		send_files (argc, argv, local, aflag, flags);
		send_file_names (argc, argv, SEND_EXPAND_WILD);
	    }
	    else
	    {
		int i;

		(void) printf ("%s client: refetching unpatchable files\n",
			       program_name);

		if (toplevel_wd != NULL
		    && CVS_CHDIR (toplevel_wd) < 0)
		{
		    error (1, errno, "could not chdir to %s", toplevel_wd);
		}

		for (i = 0; i < failed_patches_count; i++)
		    if (unlink_file (failed_patches[i]) < 0
			&& !existence_error (errno))
			error (0, errno, "cannot remove %s",
			       failed_patches[i]);
		send_files (failed_patches_count, failed_patches, local,
			    aflag, update_build_dirs ? SEND_BUILD_DIRS : 0);
		send_file_names (failed_patches_count, failed_patches, 0);
		free_names (&failed_patches_count, failed_patches);
	    }

	    send_to_server ("update\012", 0);

	    status = get_responses_and_close ();

	    /* If there are any conflicts, the server will return a
               non-zero exit status.  If any patches failed, we still
               want to run the update again.  We use a pass count to
               avoid an endless loop.  */

	    /* Notes: (1) assuming that status != 0 implies a
	       potential conflict is the best we can cleanly do given
	       the current protocol.  I suppose that trying to
	       re-fetch in cases where there was a more serious error
	       is probably more or less harmless, but it isn't really
	       ideal.  (2) it would be nice to have a testsuite case for the
	       conflict-and-patch-failed case.  */

	    if (status != 0
		&& (failed_patches_count == 0 || pass > 1))
	    {
		if (failed_patches_count > 0)
		    free_names (&failed_patches_count, failed_patches);
		return status;
	    }

	    ++pass;
	} while (failed_patches_count > 0);

	return 0;
    }
#endif

    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, aflag, "");
    if (join_rev1 != NULL)
        tag_check_valid_join (join_rev1, argc, argv, local, aflag, "");
    if (join_rev2 != NULL)
        tag_check_valid_join (join_rev2, argc, argv, local, aflag, "");

    /*
     * If we are updating the entire directory (for real) and building dirs
     * as we go, we make sure there is no static entries file and write the
     * tag file as appropriate
     */
    if (argc <= 0 && !pipeout)
    {
	if (update_build_dirs)
	{
	    if (unlink_file (CVSADM_ENTSTAT) < 0 && ! existence_error (errno))
		error (1, errno, "cannot remove file %s", CVSADM_ENTSTAT);
#ifdef SERVER_SUPPORT
	    if (server_active)
	    {
		char *repos = Name_Repository (NULL, NULL);
		server_clear_entstat (".", repos);
		free (repos);
	    }
#endif
	}

	/* keep the CVS/Tag file current with the specified arguments */
	if (aflag || tag || date)
	{
	    char *repos = Name_Repository (NULL, NULL);
	    WriteTag ((char *) NULL, tag, date, 0, ".", repos);
	    free (repos);
	    rewrite_tag = 1;
	    nonbranch = 0;
	}
    }

    /* look for files/dirs locally and in the repository */
    which = W_LOCAL | W_REPOS;

    /* look in the attic too if a tag or date is specified */
    if (tag != NULL || date != NULL || joining())
	which |= W_ATTIC;

    /* call the command line interface */
    err = do_update (argc, argv, options, tag, date, force_tag_match,
		     local, update_build_dirs, aflag, update_prune_dirs,
		     pipeout, which, join_rev1, join_rev2, (char *) NULL, 1);

    /* free the space Make_Date allocated if necessary */
    if (date != NULL)
	free (date);

    return (err);
}

/*
 * Command line interface to update (used by checkout)
 */
int
do_update (argc, argv, xoptions, xtag, xdate, xforce, local, xbuild, xaflag,
	   xprune, xpipeout, which, xjoin_rev1, xjoin_rev2, preload_update_dir,
	   xdotemplate)
    int argc;
    char **argv;
    char *xoptions;
    char *xtag;
    char *xdate;
    int xforce;
    int local;
    int xbuild;
    int xaflag;
    int xprune;
    int xpipeout;
    int which;
    char *xjoin_rev1;
    char *xjoin_rev2;
    char *preload_update_dir;
    int xdotemplate;
{
    int err = 0;
    char *cp;

    /* fill in the statics */
    options = xoptions;
    tag = xtag;
    date = xdate;
    force_tag_match = xforce;
    update_build_dirs = xbuild;
    aflag = xaflag;
    update_prune_dirs = xprune;
    pipeout = xpipeout;
    dotemplate = xdotemplate;

    /* setup the join support */
    join_rev1 = xjoin_rev1;
    join_rev2 = xjoin_rev2;
    if (join_rev1 && (cp = strchr (join_rev1, ':')) != NULL)
    {
	*cp++ = '\0';
	date_rev1 = Make_Date (cp);
    }
    else
	date_rev1 = (char *) NULL;
    if (join_rev2 && (cp = strchr (join_rev2, ':')) != NULL)
    {
	*cp++ = '\0';
	date_rev2 = Make_Date (cp);
    }
    else
	date_rev2 = (char *) NULL;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	/* We need to do an extra recursion, bleah.  It's to make sure
	   that we know as much as possible about file linkage. */
	hardlist = getlist();
	working_dir = xgetwd();		/* save top-level working dir */

	/* FIXME-twp: the arguments to start_recursion make me dizzy.  This
	   function call was copied from the update_fileproc call that
	   follows it; someone should make sure that I did it right. */
	err = start_recursion (get_linkinfo_proc, (FILESDONEPROC) NULL,
			       (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
			       argc, argv, local, which, aflag, 1,
			       preload_update_dir, 1);
	if (err)
	    return (err);

	/* FIXME-twp: at this point we should walk the hardlist
	   and update the `links' field of each hardlink_info struct
	   to list the files that are linked on dist.  That would make
	   it easier & more efficient to compare the disk linkage with
	   the repository linkage (a simple strcmp). */
    }
#endif

    /* call the recursion processor */
    err = start_recursion (update_fileproc, update_filesdone_proc,
			   update_dirent_proc, update_dirleave_proc, NULL,
			   argc, argv, local, which, aflag, 1,
			   preload_update_dir, 1);

#ifdef SERVER_SUPPORT
    if (server_active)
	return err;
#endif

    /* see if we need to sleep before returning to avoid time-stamp races */
    if (last_register_time)
    {
	sleep_past (last_register_time);
    }

    return (err);
}

#ifdef PRESERVE_PERMISSIONS_SUPPORT
/*
 * The get_linkinfo_proc callback adds each file to the hardlist
 * (see hardlink.c).
 */

static int
get_linkinfo_proc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    char *fullpath;
    Node *linkp;
    struct hardlink_info *hlinfo;

    /* Get the full pathname of the current file. */
    fullpath = xmalloc (strlen(working_dir) +
			strlen(finfo->fullname) + 2);
    sprintf (fullpath, "%s/%s", working_dir, finfo->fullname);

    /* To permit recursing into subdirectories, files
       are keyed on the full pathname and not on the basename. */
    linkp = lookup_file_by_inode (fullpath);
    if (linkp == NULL)
    {
	/* The file isn't on disk; we are probably restoring
	   a file that was removed. */
	return 0;
    }
    
    /* Create a new, empty hardlink_info node. */
    hlinfo = (struct hardlink_info *)
	xmalloc (sizeof (struct hardlink_info));

    hlinfo->status = (Ctype) 0;	/* is this dumb? */
    hlinfo->checked_out = 0;

    linkp->data = (char *) hlinfo;

    return 0;
}
#endif

/*
 * This is the callback proc for update.  It is called for each file in each
 * directory by the recursion code.  The current directory is the local
 * instantiation.  file is the file name we are to operate on. update_dir is
 * set to the path relative to where we started (for pretty printing).
 * repository is the repository. entries and srcfiles are the pre-parsed
 * entries and source control files.
 * 
 * This routine decides what needs to be done for each file and does the
 * appropriate magic for checkout
 */
static int
update_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    int retval;
    Ctype status;
    Vers_TS *vers;

    status = Classify_File (finfo, tag, date, options, force_tag_match,
			    aflag, &vers, pipeout);

    /* Keep track of whether TAG is a branch tag.
       Note that if it is a branch tag in some files and a nonbranch tag
       in others, treat it as a nonbranch tag.  It is possible that case
       should elicit a warning or an error.  */
    if (rewrite_tag
	&& tag != NULL
	&& finfo->rcs != NULL)
    {
	char *rev = RCS_getversion (finfo->rcs, tag, NULL, 1, NULL);
	if (rev != NULL
	    && !RCS_nodeisbranch (finfo->rcs, tag))
	    nonbranch = 1;
	if (rev != NULL)
	    free (rev);
    }

    if (pipeout)
    {
	/*
	 * We just return success without doing anything if any of the really
	 * funky cases occur
	 * 
	 * If there is still a valid RCS file, do a regular checkout type
	 * operation
	 */
	switch (status)
	{
	    case T_UNKNOWN:		/* unknown file was explicitly asked
					 * about */
	    case T_REMOVE_ENTRY:	/* needs to be un-registered */
	    case T_ADDED:		/* added but not committed */
		retval = 0;
		break;
	    case T_CONFLICT:		/* old punt-type errors */
		retval = 1;
		break;
	    case T_UPTODATE:		/* file was already up-to-date */
	    case T_NEEDS_MERGE:		/* needs merging */
	    case T_MODIFIED:		/* locally modified */
	    case T_REMOVED:		/* removed but not committed */
	    case T_CHECKOUT:		/* needs checkout */
	    case T_PATCH:		/* needs patch */
		retval = checkout_file (finfo, vers, 0, 0, 0);
		break;

	    default:			/* can't ever happen :-) */
		error (0, 0,
		       "unknown file status %d for file %s", status, finfo->file);
		retval = 0;
		break;
	}
    }
    else
    {
	switch (status)
	{
	    case T_UNKNOWN:		/* unknown file was explicitly asked
					 * about */
	    case T_UPTODATE:		/* file was already up-to-date */
		retval = 0;
		break;
	    case T_CONFLICT:		/* old punt-type errors */
		retval = 1;
		write_letter (finfo, 'C');
		break;
	    case T_NEEDS_MERGE:		/* needs merging */
		if (! toss_local_changes)
		{
		    retval = merge_file (finfo, vers);
		    break;
		}
		/* else FALL THROUGH */
	    case T_MODIFIED:		/* locally modified */
		retval = 0;
                if (toss_local_changes)
                {
                    char *bakname;
                    bakname = backup_file (finfo->file, vers->vn_user);
                    /* This behavior is sufficiently unexpected to
                       justify overinformativeness, I think. */
#ifdef SERVER_SUPPORT
                    if ((! really_quiet) && (! server_active))
#else /* ! SERVER_SUPPORT */
                    if (! really_quiet)
#endif /* SERVER_SUPPORT */
                        (void) printf ("(Locally modified %s moved to %s)\n",
                                       finfo->file, bakname);
                    free (bakname);

                    /* The locally modified file is still present, but
                       it will be overwritten by the repository copy
                       after this. */
                    status = T_CHECKOUT;
                    retval = checkout_file (finfo, vers, 0, 0, 1);
                }
                else 
                {
                    if (vers->ts_conflict)
                    {
                        char *filestamp;
                        int retcode;

                        /*
                         * If the timestamp has changed and no
                         * conflict indicators are found, it isn't a
                         * 'C' any more.
                         */

#ifdef SERVER_SUPPORT
                        if (server_active)
                            retcode = vers->ts_conflict[0] != '=';
                        else 
                        {
                            filestamp = time_stamp (finfo->file);
                            retcode = strcmp (vers->ts_conflict, filestamp);
                            free (filestamp);
                        }
#else
                        filestamp = time_stamp (finfo->file);
                        retcode = strcmp (vers->ts_conflict, filestamp);
                        free (filestamp);
#endif

                        if (retcode)
                        {
                            /* The timestamps differ.  But if there
                               are conflict markers print 'C' anyway.  */
                            retcode = !file_has_markers (finfo);
                        }

                        if (!retcode)
                        {
                            write_letter (finfo, 'C');
                            retval = 1;
                        }
                        else
                        {
                            /* Reregister to clear conflict flag. */
                            Register (finfo->entries, finfo->file, 
                                      vers->vn_rcs, vers->ts_rcs,
                                      vers->options, vers->tag,
                                      vers->date, (char *)0);
                        }
                    }
                    if (!retval)
                    {
                        write_letter (finfo, 'M');
                        retval = 0;
                    }
                }
		break;
	    case T_PATCH:		/* needs patch */
#ifdef SERVER_SUPPORT
		if (patches)
		{
		    int docheckout;
		    struct stat file_info;
		    unsigned char checksum[16];

		    retval = patch_file (finfo,
					 vers, &docheckout,
					 &file_info, checksum);
		    if (! docheckout)
		    {
		        if (server_active && retval == 0)
			    server_updated (finfo, vers,
					    (rcs_diff_patches
					     ? SERVER_RCS_DIFF
					     : SERVER_PATCHED),
					    file_info.st_mode, checksum,
					    (struct buffer *) NULL);
			break;
		    }
		}
#endif
		/* If we're not running as a server, just check the
		   file out.  It's simpler and faster than producing
		   and applying patches.  */
		/* Fall through.  */
	    case T_CHECKOUT:		/* needs checkout */
		retval = checkout_file (finfo, vers, 0, 0, 1);
		break;
	    case T_ADDED:		/* added but not committed */
		write_letter (finfo, 'A');
		retval = 0;
		break;
	    case T_REMOVED:		/* removed but not committed */
		write_letter (finfo, 'R');
		retval = 0;
		break;
	    case T_REMOVE_ENTRY:	/* needs to be un-registered */
		retval = scratch_file (finfo, vers);
		break;
	    default:			/* can't ever happen :-) */
		error (0, 0,
		       "unknown file status %d for file %s", status, finfo->file);
		retval = 0;
		break;
	}
    }

    /* only try to join if things have gone well thus far */
    if (retval == 0 && join_rev1)
	join_file (finfo, vers);

    /* if this directory has an ignore list, add this file to it */
    if (ignlist && (status != T_UNKNOWN || vers->ts_user == NULL))
    {
	Node *p;

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (finfo->file);
	if (addnode (ignlist, p) != 0)
	    freenode (p);
    }

    freevers_ts (&vers);
    return (retval);
}

static void update_ignproc PROTO ((char *, char *));

static void
update_ignproc (file, dir)
    char *file;
    char *dir;
{
    struct file_info finfo;

    memset (&finfo, 0, sizeof (finfo));
    finfo.file = file;
    finfo.update_dir = dir;
    if (dir[0] == '\0')
	finfo.fullname = xstrdup (file);
    else
    {
	finfo.fullname = xmalloc (strlen (file) + strlen (dir) + 10);
	strcpy (finfo.fullname, dir);
	strcat (finfo.fullname, "/");
	strcat (finfo.fullname, file);
    }

    write_letter (&finfo, '?');
    free (finfo.fullname);
}

/* ARGSUSED */
static int
update_filesdone_proc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    if (rewrite_tag)
    {
	WriteTag (NULL, tag, date, nonbranch, update_dir, repository);
	rewrite_tag = 0;
    }

    /* if this directory has an ignore list, process it then free it */
    if (ignlist)
    {
	ignore_files (ignlist, entries, update_dir, update_ignproc);
	dellist (&ignlist);
    }

    /* Clean up CVS admin dirs if we are export */
    if (strcmp (command_name, "export") == 0)
    {
	/* I'm not sure the existence_error is actually possible (except
	   in cases where we really should print a message), but since
	   this code used to ignore all errors, I'll play it safe.  */
	if (unlink_file_dir (CVSADM) < 0 && !existence_error (errno))
	    error (0, errno, "cannot remove %s directory", CVSADM);
    }
#ifdef SERVER_SUPPORT
    else if (!server_active && !pipeout)
#else
    else if (!pipeout)
#endif /* SERVER_SUPPORT */
    {
        /* If there is no CVS/Root file, add one */
        if (!isfile (CVSADM_ROOT))
	    Create_Root ((char *) NULL, current_parsed_root->original);
    }

    return (err);
}

/*
 * update_dirent_proc () is called back by the recursion processor before a
 * sub-directory is processed for update.  In this case, update_dirent proc
 * will probably create the directory unless -d isn't specified and this is a
 * new directory.  A return code of 0 indicates the directory should be
 * processed by the recursion code.  A return of non-zero indicates the
 * recursion code should skip this directory.
 */
static Dtype
update_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repository;
    char *update_dir;
    List *entries;
{
    if (ignore_directory (update_dir))
    {
	/* print the warm fuzzy message */
	if (!quiet)
	  error (0, 0, "Ignoring %s", update_dir);
        return R_SKIP_ALL;
    }

    if (!isdir (dir))
    {
	/* if we aren't building dirs, blow it off */
	if (!update_build_dirs)
	    return (R_SKIP_ALL);

	/* Various CVS administrators are in the habit of removing
	   the repository directory for things they don't want any
	   more.  I've even been known to do it myself (on rare
	   occasions).  Not the usual recommended practice, but we
	   want to try to come up with some kind of
	   reasonable/documented/sensible behavior.  Generally
	   the behavior is to just skip over that directory (see
	   dirs test in sanity.sh; the case which reaches here
	   is when update -d is specified, and the working directory
	   is gone but the subdirectory is still mentioned in
	   CVS/Entries).  */
	if (1
#ifdef SERVER_SUPPORT
	    /* In the remote case, the client should refrain from
	       sending us the directory in the first place.  So we
	       want to continue to give an error, so clients make
	       sure to do this.  */
	    && !server_active
#endif
	    && !isdir (repository))
	    return R_SKIP_ALL;

	if (noexec)
	{
	    /* ignore the missing dir if -n is specified */
	    error (0, 0, "New directory `%s' -- ignored", update_dir);
	    return (R_SKIP_ALL);
	}
	else
	{
	    /* otherwise, create the dir and appropriate adm files */

	    /* If no tag or date were specified on the command line,
               and we're not using -A, we want the subdirectory to use
               the tag and date, if any, of the current directory.
               That way, update -d will work correctly when working on
               a branch.

	       We use TAG_UPDATE_DIR to undo the tag setting in
	       update_dirleave_proc.  If we did not do this, we would
	       not correctly handle a working directory with multiple
	       tags (and maybe we should prohibit such working
	       directories, but they work now and we shouldn't make
	       them stop working without more thought).  */
	    if ((tag == NULL && date == NULL) && ! aflag)
	    {
		ParseTag (&tag, &date, &nonbranch);
		if (tag != NULL || date != NULL)
		    tag_update_dir = xstrdup (update_dir);
	    }

	    make_directory (dir);
	    Create_Admin (dir, update_dir, repository, tag, date,
			  /* This is a guess.  We will rewrite it later
			     via WriteTag.  */
			  0,
			  0,
			  dotemplate);
	    rewrite_tag = 1;
	    nonbranch = 0;
	    Subdir_Register (entries, (char *) NULL, dir);
	}
    }
    /* Do we need to check noexec here? */
    else if (!pipeout)
    {
	char *cvsadmdir;

	/* The directory exists.  Check to see if it has a CVS
	   subdirectory.  */

	cvsadmdir = xmalloc (strlen (dir) + 80);
	strcpy (cvsadmdir, dir);
	strcat (cvsadmdir, "/");
	strcat (cvsadmdir, CVSADM);

	if (!isdir (cvsadmdir))
	{
	    /* We cannot successfully recurse into a directory without a CVS
	       subdirectory.  Generally we will have already printed
	       "? foo".  */
	    free (cvsadmdir);
	    return R_SKIP_ALL;
	}
	free (cvsadmdir);
    }

    /*
     * If we are building dirs and not going to stdout, we make sure there is
     * no static entries file and write the tag file as appropriate
     */
    if (!pipeout)
    {
	if (update_build_dirs)
	{
	    char *tmp;

	    tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ENTSTAT) + 10);
	    (void) sprintf (tmp, "%s/%s", dir, CVSADM_ENTSTAT);
	    if (unlink_file (tmp) < 0 && ! existence_error (errno))
		error (1, errno, "cannot remove file %s", tmp);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_clear_entstat (update_dir, repository);
#endif
	    free (tmp);
	}

	/* keep the CVS/Tag file current with the specified arguments */
	if (aflag || tag || date)
	{
	    WriteTag (dir, tag, date, 0, update_dir, repository);
	    rewrite_tag = 1;
	    nonbranch = 0;
	}

	/* initialize the ignore list for this directory */
	ignlist = getlist ();
    }

    /* print the warm fuzzy message */
    if (!quiet)
	error (0, 0, "Updating %s", update_dir);

    return (R_PROCESS);
}

/*
 * update_dirleave_proc () is called back by the recursion code upon leaving
 * a directory.  It will prune empty directories if needed and will execute
 * any appropriate update programs.
 */
/* ARGSUSED */
static int
update_dirleave_proc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
{
    FILE *fp;

    /* Delete the ignore list if it hasn't already been done.  */
    if (ignlist)
	dellist (&ignlist);

    /* If we set the tag or date for a new subdirectory in
       update_dirent_proc, and we're now done with that subdirectory,
       undo the tag/date setting.  Note that we know that the tag and
       date were both originally NULL in this case.  */
    if (tag_update_dir != NULL && strcmp (update_dir, tag_update_dir) == 0)
    {
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
	if (date != NULL)
	{
	    free (date);
	    date = NULL;
	}
	nonbranch = 0;
	free (tag_update_dir);
	tag_update_dir = NULL;
    }

    /* run the update_prog if there is one */
    /* FIXME: should be checking for errors from CVS_FOPEN and printing
       them if not existence_error.  */
    if (err == 0 && !pipeout && !noexec &&
	(fp = CVS_FOPEN (CVSADM_UPROG, "r")) != NULL)
    {
	char *cp;
	char *repository;
	char *line = NULL;
	size_t line_allocated = 0;

	repository = Name_Repository ((char *) NULL, update_dir);
	if (get_line (&line, &line_allocated, fp) >= 0)
	{
	    if ((cp = strrchr (line, '\n')) != NULL)
		*cp = '\0';
	    run_setup (line);
	    run_arg (repository);
	    cvs_output (program_name, 0);
	    cvs_output (" ", 1);
	    cvs_output (command_name, 0);
	    cvs_output (": Executing '", 0);
	    run_print (stdout);
	    cvs_output ("'\n", 0);
	    cvs_flushout ();
	    (void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
	}
	else if (ferror (fp))
	    error (0, errno, "cannot read %s", CVSADM_UPROG);
	else
	    error (0, 0, "unexpected end of file on %s", CVSADM_UPROG);

	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", CVSADM_UPROG);
	if (line != NULL)
	    free (line);
	free (repository);
    }

    if (strchr (dir, '/') == NULL)
    {
	/* FIXME: chdir ("..") loses with symlinks.  */
	/* Prune empty dirs on the way out - if necessary */
	(void) CVS_CHDIR ("..");
	if (update_prune_dirs && isemptydir (dir, 0))
	{
	    /* I'm not sure the existence_error is actually possible (except
	       in cases where we really should print a message), but since
	       this code used to ignore all errors, I'll play it safe.	*/
	    if (unlink_file_dir (dir) < 0 && !existence_error (errno))
		error (0, errno, "cannot remove %s directory", dir);
	    Subdir_Deregister (entries, (char *) NULL, dir);
	}
    }

    return (err);
}

static int isremoved PROTO ((Node *, void *));

/* Returns 1 if the file indicated by node has been removed.  */
static int
isremoved (node, closure)
    Node *node;
    void *closure;
{
    Entnode *entdata = (Entnode*) node->data;

    /* If the first character of the version is a '-', the file has been
       removed. */
    return (entdata->version && entdata->version[0] == '-') ? 1 : 0;
}

/* Returns 1 if the argument directory is completely empty, other than the
   existence of the CVS directory entry.  Zero otherwise.  If MIGHT_NOT_EXIST
   and the directory doesn't exist, then just return 0.  */
int
isemptydir (dir, might_not_exist)
    char *dir;
    int might_not_exist;
{
    DIR *dirp;
    struct dirent *dp;

    if ((dirp = CVS_OPENDIR (dir)) == NULL)
    {
	if (might_not_exist && existence_error (errno))
	    return 0;
	error (0, errno, "cannot open directory %s for empty check", dir);
	return (0);
    }
    errno = 0;
    while ((dp = CVS_READDIR (dirp)) != NULL)
    {
	if (strcmp (dp->d_name, ".") != 0
	    && strcmp (dp->d_name, "..") != 0)
	{
	    if (strcmp (dp->d_name, CVSADM) != 0)
	    {
		/* An entry other than the CVS directory.  The directory
		   is certainly not empty. */
		(void) CVS_CLOSEDIR (dirp);
		return (0);
	    }
	    else
	    {
		/* The CVS directory entry.  We don't have to worry about
		   this unless the Entries file indicates that files have
		   been removed, but not committed, in this directory.
		   (Removing the directory would prevent people from
		   comitting the fact that they removed the files!) */
		List *l;
		int files_removed;
		struct saved_cwd cwd;

		if (save_cwd (&cwd))
		    error_exit ();

		if (CVS_CHDIR (dir) < 0)
		    error (1, errno, "cannot change directory to %s", dir);
		l = Entries_Open (0, NULL);
		files_removed = walklist (l, isremoved, 0);
		Entries_Close (l);

		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		free_cwd (&cwd);

		if (files_removed != 0)
		{
		    /* There are files that have been removed, but not
		       committed!  Do not consider the directory empty. */
		    (void) CVS_CLOSEDIR (dirp);
		    return (0);
		}
	    }
	}
	errno = 0;
    }
    if (errno != 0)
    {
	error (0, errno, "cannot read directory %s", dir);
	(void) CVS_CLOSEDIR (dirp);
	return (0);
    }
    (void) CVS_CLOSEDIR (dirp);
    return (1);
}

/*
 * scratch the Entries file entry associated with a file
 */
static int
scratch_file (finfo, vers)
    struct file_info *finfo;
    Vers_TS *vers;
{
    history_write ('W', finfo->update_dir, "", finfo->file, finfo->repository);
    Scratch_Entry (finfo->entries, finfo->file);
#ifdef SERVER_SUPPORT
    if (server_active)
    {
	if (vers->ts_user == NULL)
	    server_scratch_entry_only ();
	server_updated (finfo, vers,
		SERVER_UPDATED, (mode_t) -1,
		(unsigned char *) NULL,
		(struct buffer *) NULL);
    }
#endif
    if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
	error (0, errno, "unable to remove %s", finfo->fullname);
    else
#ifdef SERVER_SUPPORT
	/* skip this step when the server is running since
	 * server_updated should have handled it */
	if (!server_active)
#endif
    {
	/* keep the vers structure up to date in case we do a join
	 * - if there isn't a file, it can't very well have a version number, can it?
	 */
	if (vers->vn_user != NULL)
	{
	    free (vers->vn_user);
	    vers->vn_user = NULL;
	}
	if (vers->ts_user != NULL)
	{
	    free (vers->ts_user);
	    vers->ts_user = NULL;
	}
    }
    return (0);
}

/*
 * Check out a file.
 */
static int
checkout_file (finfo, vers_ts, adding, merging, update_server)
    struct file_info *finfo;
    Vers_TS *vers_ts;
    int adding;
    int merging;
    int update_server;
{
    char *backup;
    int set_time, retval = 0;
    int status;
    int file_is_dead;
    struct buffer *revbuf;

    backup = NULL;
    revbuf = NULL;

    /* Don't screw with backup files if we're going to stdout, or if
       we are the server.  */
    if (!pipeout
#ifdef SERVER_SUPPORT
	&& ! server_active
#endif
	)
    {
	backup = xmalloc (strlen (finfo->file)
			  + sizeof (CVSADM)
			  + sizeof (CVSPREFIX)
			  + 10);
	(void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, finfo->file);
	if (isfile (finfo->file))
	    rename_file (finfo->file, backup);
	else
	{
	    /* If -f/-t wrappers are being used to wrap up a directory,
	       then backup might be a directory instead of just a file.  */
	    if (unlink_file_dir (backup) < 0)
	    {
		/* Not sure if the existence_error check is needed here.  */
		if (!existence_error (errno))
		    /* FIXME: should include update_dir in message.  */
		    error (0, errno, "error removing %s", backup);
	    }
	    free (backup);
	    backup = NULL;
	}
    }

    file_is_dead = RCS_isdead (vers_ts->srcfile, vers_ts->vn_rcs);

    if (!file_is_dead)
    {
	/*
	 * if we are checking out to stdout, print a nice message to
	 * stderr, and add the -p flag to the command */
	if (pipeout)
	{
	    if (!quiet)
	    {
		cvs_outerr ("\
===================================================================\n\
Checking out ", 0);
		cvs_outerr (finfo->fullname, 0);
		cvs_outerr ("\n\
RCS:  ", 0);
		cvs_outerr (vers_ts->srcfile->path, 0);
		cvs_outerr ("\n\
VERS: ", 0);
		cvs_outerr (vers_ts->vn_rcs, 0);
		cvs_outerr ("\n***************\n", 0);
	    }
	}

#ifdef SERVER_SUPPORT
	if (update_server
	    && server_active
	    && ! pipeout
	    && ! file_gzip_level
	    && ! joining ()
	    && ! wrap_name_has (finfo->file, WRAP_FROMCVS))
	{
	    revbuf = buf_nonio_initialize ((BUFMEMERRPROC) NULL);
	    status = RCS_checkout (vers_ts->srcfile, (char *) NULL,
				   vers_ts->vn_rcs, vers_ts->vn_tag,
				   vers_ts->options, RUN_TTY,
				   checkout_to_buffer, revbuf);
	}
	else
#endif
	    status = RCS_checkout (vers_ts->srcfile,
				   pipeout ? NULL : finfo->file,
				   vers_ts->vn_rcs, vers_ts->vn_tag,
				   vers_ts->options, RUN_TTY,
				   (RCSCHECKOUTPROC) NULL, (void *) NULL);
    }
    if (file_is_dead || status == 0)
    {
	mode_t mode;

	mode = (mode_t) -1;

	if (!pipeout)
	{
	    Vers_TS *xvers_ts;

	    if (revbuf != NULL && !noexec)
	    {
		struct stat sb;

		/* FIXME: We should have RCS_checkout return the mode.
		   That would also fix the kludge with noexec, above, which
		   is here only because noexec doesn't write srcfile->path
		   for us to stat.  */
		if (stat (vers_ts->srcfile->path, &sb) < 0)
		    error (1, errno, "cannot stat %s",
			   vers_ts->srcfile->path);
		mode = sb.st_mode &~ (S_IWRITE | S_IWGRP | S_IWOTH);
	    }

	    if (cvswrite
		&& !file_is_dead
		&& !fileattr_get (finfo->file, "_watched"))
	    {
		if (revbuf == NULL)
		    xchmod (finfo->file, 1);
		else
		{
		    /* We know that we are the server here, so
                       although xchmod checks umask, we don't bother.  */
		    mode |= (((mode & S_IRUSR) ? S_IWUSR : 0)
			     | ((mode & S_IRGRP) ? S_IWGRP : 0)
			     | ((mode & S_IROTH) ? S_IWOTH : 0));
		}
	    }

	    {
		/* A newly checked out file is never under the spell
		   of "cvs edit".  If we think we were editing it
		   from a previous life, clean up.  Would be better to
		   check for same the working directory instead of
		   same user, but that is hairy.  */

		struct addremove_args args;

		editor_set (finfo->file, getcaller (), NULL);

		memset (&args, 0, sizeof args);
		args.remove_temp = 1;
		watch_modify_watchers (finfo->file, &args);
	    }

	    /* set the time from the RCS file iff it was unknown before */
	    set_time =
		(!noexec
		 && (vers_ts->vn_user == NULL ||
		     strncmp (vers_ts->ts_rcs, "Initial", 7) == 0)
		 && !file_is_dead);

	    wrap_fromcvs_process_file (finfo->file);

	    xvers_ts = Version_TS (finfo, options, tag, date, 
				   force_tag_match, set_time);
	    if (strcmp (xvers_ts->options, "-V4") == 0)
		xvers_ts->options[0] = '\0';

	    if (revbuf != NULL)
	    {
		/* If we stored the file data into a buffer, then we
                   didn't create a file at all, so xvers_ts->ts_user
                   is wrong.  The correct value is to have it be the
                   same as xvers_ts->ts_rcs, meaning that the working
                   file is unchanged from the RCS file.

		   FIXME: We should tell Version_TS not to waste time
		   statting the nonexistent file.

		   FIXME: Actually, I don't think the ts_user value
		   matters at all here.  The only use I know of is
		   that it is printed in a trace message by
		   Server_Register.  */

		if (xvers_ts->ts_user != NULL)
		    free (xvers_ts->ts_user);
		xvers_ts->ts_user = xstrdup (xvers_ts->ts_rcs);
	    }

	    (void) time (&last_register_time);

	    if (file_is_dead)
	    {
		if (xvers_ts->vn_user != NULL)
		{
		    error (0, 0,
			   "warning: %s is not (any longer) pertinent",
 			   finfo->fullname);
		}
		Scratch_Entry (finfo->entries, finfo->file);
#ifdef SERVER_SUPPORT
		if (server_active && xvers_ts->ts_user == NULL)
		    server_scratch_entry_only ();
#endif
		/* FIXME: Rather than always unlink'ing, and ignoring the
		   existence_error, we should do the unlink only if
		   vers_ts->ts_user is non-NULL.  Then there would be no
		   need to ignore an existence_error (for example, if the
		   user removes the file while we are running).  */
		if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
		{
		    error (0, errno, "cannot remove %s", finfo->fullname);
		}
	    }
	    else
		Register (finfo->entries, finfo->file,
			  adding ? "0" : xvers_ts->vn_rcs,
			  xvers_ts->ts_user, xvers_ts->options,
			  xvers_ts->tag, xvers_ts->date,
			  (char *)0); /* Clear conflict flag on fresh checkout */

	    /* fix up the vers structure, in case it is used by join */
	    if (join_rev1)
	    {
		if (vers_ts->vn_user != NULL)
		    free (vers_ts->vn_user);
		if (vers_ts->vn_rcs != NULL)
		    free (vers_ts->vn_rcs);
		vers_ts->vn_user = xstrdup (xvers_ts->vn_rcs);
		vers_ts->vn_rcs = xstrdup (xvers_ts->vn_rcs);
	    }

	    /* If this is really Update and not Checkout, recode history */
	    if (strcmp (command_name, "update") == 0)
		history_write ('U', finfo->update_dir, xvers_ts->vn_rcs, finfo->file,
			       finfo->repository);

	    freevers_ts (&xvers_ts);

	    if (!really_quiet && !file_is_dead)
	    {
		write_letter (finfo, 'U');
	    }
	}

#ifdef SERVER_SUPPORT
	if (update_server && server_active)
	    server_updated (finfo, vers_ts,
			    merging ? SERVER_MERGED : SERVER_UPDATED,
			    mode, (unsigned char *) NULL, revbuf);
#endif
    }
    else
    {
	if (backup != NULL)
	{
	    rename_file (backup, finfo->file);
	    free (backup);
	    backup = NULL;
	}

	error (0, 0, "could not check out %s", finfo->fullname);

	retval = status;
    }

    if (backup != NULL)
    {
	/* If -f/-t wrappers are being used to wrap up a directory,
	   then backup might be a directory instead of just a file.  */
	if (unlink_file_dir (backup) < 0)
	{
	    /* Not sure if the existence_error check is needed here.  */
	    if (!existence_error (errno))
		/* FIXME: should include update_dir in message.  */
		error (0, errno, "error removing %s", backup);
	}
	free (backup);
    }

    return (retval);
}

#ifdef SERVER_SUPPORT

/* This function is used to write data from a file being checked out
   into a buffer.  */

static void
checkout_to_buffer (callerdat, data, len)
     void *callerdat;
     const char *data;
     size_t len;
{
    struct buffer *buf = (struct buffer *) callerdat;

    buf_output (buf, data, len);
}

#endif /* SERVER_SUPPORT */

#ifdef SERVER_SUPPORT

/* This structure is used to pass information between patch_file and
   patch_file_write.  */

struct patch_file_data
{
    /* File name, for error messages.  */
    const char *filename;
    /* File to which to write.  */
    FILE *fp;
    /* Whether to compute the MD5 checksum.  */
    int compute_checksum;
    /* Data structure for computing the MD5 checksum.  */
    struct cvs_MD5Context context;
    /* Set if the file has a final newline.  */
    int final_nl;
};

/* Patch a file.  Runs diff.  This is only done when running as the
 * server.  The hope is that the diff will be smaller than the file
 * itself.
 */
static int
patch_file (finfo, vers_ts, docheckout, file_info, checksum)
    struct file_info *finfo;
    Vers_TS *vers_ts;
    int *docheckout;
    struct stat *file_info;
    unsigned char *checksum;
{
    char *backup;
    char *file1;
    char *file2;
    int retval = 0;
    int retcode = 0;
    int fail;
    long file_size;
    FILE *e;
    struct patch_file_data data;

    *docheckout = 0;

    if (noexec || pipeout || joining ())
    {
	*docheckout = 1;
	return 0;
    }

    /* If this file has been marked as being binary, then never send a
       patch.  */
    if (strcmp (vers_ts->options, "-kb") == 0)
    {
	*docheckout = 1;
	return 0;
    }

    /* First check that the first revision exists.  If it has been nuked
       by cvs admin -o, then just fall back to checking out entire
       revisions.  In some sense maybe we don't have to do this; after
       all cvs.texinfo says "Make sure that no-one has checked out a
       copy of the revision you outdate" but then again, that advice
       doesn't really make complete sense, because "cvs admin" operates
       on a working directory and so _someone_ will almost always have
       _some_ revision checked out.  */
    {
	char *rev;

	rev = RCS_gettag (finfo->rcs, vers_ts->vn_user, 1, NULL);
	if (rev == NULL)
	{
	    *docheckout = 1;
	    return 0;
	}
	else
	    free (rev);
    }

    /* If the revision is dead, let checkout_file handle it rather
       than duplicating the processing here.  */
    if (RCS_isdead (vers_ts->srcfile, vers_ts->vn_rcs))
    {
	*docheckout = 1;
	return 0;
    }

    backup = xmalloc (strlen (finfo->file)
		      + sizeof (CVSADM)
		      + sizeof (CVSPREFIX)
		      + 10);
    (void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, finfo->file);
    if (isfile (finfo->file))
        rename_file (finfo->file, backup);
    else
    {
	if (unlink_file (backup) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", backup);
    }

    file1 = xmalloc (strlen (finfo->file)
		     + sizeof (CVSADM)
		     + sizeof (CVSPREFIX)
		     + 10);
    (void) sprintf (file1, "%s/%s%s-1", CVSADM, CVSPREFIX, finfo->file);
    file2 = xmalloc (strlen (finfo->file)
		     + sizeof (CVSADM)
		     + sizeof (CVSPREFIX)
		     + 10);
    (void) sprintf (file2, "%s/%s%s-2", CVSADM, CVSPREFIX, finfo->file);

    fail = 0;

    /* We need to check out both revisions first, to see if either one
       has a trailing newline.  Because of this, we don't use rcsdiff,
       but just use diff.  */

    e = CVS_FOPEN (file1, "w");
    if (e == NULL)
	error (1, errno, "cannot open %s", file1);

    data.filename = file1;
    data.fp = e;
    data.final_nl = 0;
    data.compute_checksum = 0;

    retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
			    vers_ts->vn_user, (char *) NULL,
			    vers_ts->options, RUN_TTY,
			    patch_file_write, (void *) &data);

    if (fclose (e) < 0)
	error (1, errno, "cannot close %s", file1);

    if (retcode != 0 || ! data.final_nl)
	fail = 1;

    if (! fail)
    {
	e = CVS_FOPEN (file2, "w");
	if (e == NULL)
	    error (1, errno, "cannot open %s", file2);

	data.filename = file2;
	data.fp = e;
	data.final_nl = 0;
	data.compute_checksum = 1;
	cvs_MD5Init (&data.context);

	retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
				vers_ts->vn_rcs, vers_ts->vn_tag,
				vers_ts->options, RUN_TTY,
				patch_file_write, (void *) &data);

	fseek(e, 0L, SEEK_END);
	file_size = ftell(e);

	if (fclose (e) < 0)
	    error (1, errno, "cannot close %s", file2);

	if (retcode != 0 || ! data.final_nl)
	    fail = 1;
	else
	    cvs_MD5Final (checksum, &data.context);
    }	  

    retcode = 0;
    if (! fail)
    {
	char *diff_options;

	/* If the client does not support the Rcs-diff command, we
           send a context diff, and the client must invoke patch.
           That approach was problematical for various reasons.  The
           new approach only requires running diff in the server; the
           client can handle everything without invoking an external
           program.  */
	if (! rcs_diff_patches)
	{
	    /* We use -c, not -u, because that is what CVS has
	       traditionally used.  Kind of a moot point, now that
	       Rcs-diff is preferred, so there is no point in making
	       the compatibility issues worse.  */
	    diff_options = "-c";
	}
	else
	{
	    /* Now that diff is librarified, we could be passing -a if
	       we wanted to.  However, it is unclear to me whether we
	       would want to.  Does diff -a, in any significant
	       percentage of cases, produce patches which are smaller
	       than the files it is patching?  I guess maybe text
	       files with character sets which diff regards as
	       'binary'.  Conversely, do they tend to be much larger
	       in the bad cases?  This needs some more
	       thought/investigation, I suspect.  */

	    diff_options = "-n";
	}
	retcode = diff_exec (file1, file2, NULL, NULL, diff_options, finfo->file);

	/* A retcode of 0 means no differences.  1 means some differences.  */
	if (retcode != 0
	    && retcode != 1)
	{
	    fail = 1;
	}
	else
	{
#define BINARY "Binary"
	    char buf[sizeof BINARY];
	    unsigned int c;

	    /* Stat the original RCS file, and then adjust it the way
	       that RCS_checkout would.  FIXME: This is an abstraction
	       violation.  */
	    if (CVS_STAT (vers_ts->srcfile->path, file_info) < 0)
		error (1, errno, "could not stat %s", vers_ts->srcfile->path);
	    if (chmod (finfo->file,
		       file_info->st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH))
		< 0)
		error (0, errno, "cannot change mode of file %s", finfo->file);
	    if (cvswrite
		&& !fileattr_get (finfo->file, "_watched"))
		xchmod (finfo->file, 1);

	    /* Check the diff output to make sure patch will be handle it.  */
	    e = CVS_FOPEN (finfo->file, "r");
	    if (e == NULL)
		error (1, errno, "could not open diff output file %s",
		       finfo->fullname);
	    c = fread (buf, 1, sizeof BINARY - 1, e);
	    buf[c] = '\0';
	    if (strcmp (buf, BINARY) == 0)
	    {
		/* These are binary files.  We could use diff -a, but
		   patch can't handle that.  */
		fail = 1;
	    }
	    else {
		/*
		 * Don't send a diff if just sending the entire file
		 * would be smaller
		 */
		fseek(e, 0L, SEEK_END);
		if (file_size < ftell(e))
		    fail = 1;
	    }

	    fclose (e);
	}
    }

    if (! fail)
    {
        Vers_TS *xvers_ts;

        /* This stuff is just copied blindly from checkout_file.  I
	   don't really know what it does.  */
        xvers_ts = Version_TS (finfo, options, tag, date,
			       force_tag_match, 0);
	if (strcmp (xvers_ts->options, "-V4") == 0)
	    xvers_ts->options[0] = '\0';

	Register (finfo->entries, finfo->file, xvers_ts->vn_rcs,
		  xvers_ts->ts_user, xvers_ts->options,
		  xvers_ts->tag, xvers_ts->date, NULL);

	if (CVS_STAT (finfo->file, file_info) < 0)
	    error (1, errno, "could not stat %s", finfo->file);

	/* If this is really Update and not Checkout, recode history */
	if (strcmp (command_name, "update") == 0)
	    history_write ('P', finfo->update_dir, xvers_ts->vn_rcs, finfo->file,
			   finfo->repository);

	freevers_ts (&xvers_ts);

	if (!really_quiet)
	{
	    write_letter (finfo, 'P');
	}
    }
    else
    {
	int old_errno = errno;		/* save errno value over the rename */

	if (isfile (backup))
	    rename_file (backup, finfo->file);

	if (retcode != 0 && retcode != 1)
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? old_errno : 0,
		   "could not diff %s", finfo->fullname);

	*docheckout = 1;
	retval = retcode;
    }

    if (unlink_file (backup) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", backup);
    if (unlink_file (file1) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", file1);
    if (unlink_file (file2) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", file2);

    free (backup);
    free (file1);
    free (file2);
    return (retval);
}

/* Write data to a file.  Record whether the last byte written was a
   newline.  Optionally compute a checksum.  This is called by
   patch_file via RCS_checkout.  */

static void
patch_file_write (callerdat, buffer, len)
     void *callerdat;
     const char *buffer;
     size_t len;
{
    struct patch_file_data *data = (struct patch_file_data *) callerdat;

    if (fwrite (buffer, 1, len, data->fp) != len)
	error (1, errno, "cannot write %s", data->filename);

    data->final_nl = (buffer[len - 1] == '\n');

    if (data->compute_checksum)
	cvs_MD5Update (&data->context, (unsigned char *) buffer, len);
}

#endif /* SERVER_SUPPORT */

/*
 * Several of the types we process only print a bit of information consisting
 * of a single letter and the name.
 */
static void
write_letter (finfo, letter)
    struct file_info *finfo;
    int letter;
{
    if (!really_quiet)
    {
	char *tag = NULL;
	/* Big enough for "+updated" or any of its ilk.  */
	char buf[80];

	switch (letter)
	{
	    case 'U':
		tag = "updated";
		break;
	    default:
		/* We don't yet support tagged output except for "U".  */
		break;
	}

	if (tag != NULL)
	{
	    snprintf (buf, sizeof buf, "+%s", tag);
	    cvs_output_tagged (buf, NULL);
	}
	buf[0] = letter;
	buf[1] = ' ';
	buf[2] = '\0';
	cvs_output_tagged ("text", buf);
	cvs_output_tagged ("fname", finfo->fullname);
	cvs_output_tagged ("newline", NULL);
	if (tag != NULL)
	{
	    snprintf (buf, sizeof buf, "-%s", tag);
	    cvs_output_tagged (buf, NULL);
	}
    }
    return;
}

/*
 * Do all the magic associated with a file which needs to be merged
 */
static int
merge_file (finfo, vers)
    struct file_info *finfo;
    Vers_TS *vers;
{
    char *backup;
    int status;
    int retcode = 0;
    int retval;

    /*
     * The users currently modified file is moved to a backup file name
     * ".#filename.version", so that it will stay around for a few days
     * before being automatically removed by some cron daemon.  The "version"
     * is the version of the file that the user was most up-to-date with
     * before the merge.
     */
    backup = xmalloc (strlen (finfo->file)
		      + strlen (vers->vn_user)
		      + sizeof (BAKPREFIX)
		      + 10);
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, finfo->file, vers->vn_user);

    if (unlink_file (backup) && !existence_error (errno))
	error (0, errno, "unable to remove %s", backup);
    copy_file (finfo->file, backup);
    xchmod (finfo->file, 1);

    if (strcmp (vers->options, "-kb") == 0
	|| wrap_merge_is_copy (finfo->file)
	|| special_file_mismatch (finfo, NULL, vers->vn_rcs))
    {
	/* For binary files, a merge is always a conflict.  Same for
	   files whose permissions or linkage do not match.  We give the
	   user the two files, and let them resolve it.  It is possible
	   that we should require a "touch foo" or similar step before
	   we allow a checkin.  */

	/* TODO: it may not always be necessary to regard a permission
	   mismatch as a conflict.  The working file and the RCS file
	   have a common ancestor `A'; if the working file's permissions
	   match A's, then it's probably safe to overwrite them with the
	   RCS permissions.  Only if the working file, the RCS file, and
	   A all disagree should this be considered a conflict.  But more
	   thought needs to go into this, and in the meantime it is safe
	   to treat any such mismatch as an automatic conflict. -twp */

#ifdef SERVER_SUPPORT
	if (server_active)
	    server_copy_file (finfo->file, finfo->update_dir,
			      finfo->repository, backup);
#endif

	status = checkout_file (finfo, vers, 0, 1, 1);

	/* Is there a better term than "nonmergeable file"?  What we
	   really mean is, not something that CVS cannot or does not
	   want to merge (there might be an external manual or
	   automatic merge process).  */
	error (0, 0, "nonmergeable file needs merge");
	error (0, 0, "revision %s from repository is now in %s",
	       vers->vn_rcs, finfo->fullname);
	error (0, 0, "file from working directory is now in %s", backup);
	write_letter (finfo, 'C');

	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
	retval = 0;
	goto out;
    }

    status = RCS_merge(finfo->rcs, vers->srcfile->path, finfo->file,
		       vers->options, vers->vn_user, vers->vn_rcs);
    if (status != 0 && status != 1)
    {
	error (0, status == -1 ? errno : 0,
	       "could not merge revision %s of %s", vers->vn_user, finfo->fullname);
	error (status == -1 ? 1 : 0, 0, "restoring %s from backup file %s",
	       finfo->fullname, backup);
	rename_file (backup, finfo->file);
	retval = 1;
	goto out;
    }

    if (strcmp (vers->options, "-V4") == 0)
	vers->options[0] = '\0';

    /* This file is the result of a merge, which means that it has
       been modified.  We use a special timestamp string which will
       not compare equal to any actual timestamp.  */
    {
	char *cp = 0;

	if (status)
	{
	    (void) time (&last_register_time);
	    cp = time_stamp (finfo->file);
	}
	Register (finfo->entries, finfo->file, vers->vn_rcs,
		  "Result of merge", vers->options, vers->tag,
		  vers->date, cp);
	if (cp)
	    free (cp);
    }

    /* fix up the vers structure, in case it is used by join */
    if (join_rev1)
    {
	if (vers->vn_user != NULL)
	    free (vers->vn_user);
	vers->vn_user = xstrdup (vers->vn_rcs);
    }

#ifdef SERVER_SUPPORT
    /* Send the new contents of the file before the message.  If we
       wanted to be totally correct, we would have the client write
       the message only after the file has safely been written.  */
    if (server_active)
    {
        server_copy_file (finfo->file, finfo->update_dir, finfo->repository,
			  backup);
	server_updated (finfo, vers, SERVER_MERGED,
			(mode_t) -1, (unsigned char *) NULL,
			(struct buffer *) NULL);
    }
#endif

    /* FIXME: the noexec case is broken.  RCS_merge could be doing the
       xcmp on the temporary files without much hassle, I think.  */
    if (!noexec && !xcmp (backup, finfo->file))
    {
	cvs_output (finfo->fullname, 0);
	cvs_output (" already contains the differences between ", 0);
	cvs_output (vers->vn_user, 0);
	cvs_output (" and ", 0);
	cvs_output (vers->vn_rcs, 0);
	cvs_output ("\n", 1);

	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
	retval = 0;
	goto out;
    }

    if (status == 1)
    {
	error (0, 0, "conflicts found in %s", finfo->fullname);

	write_letter (finfo, 'C');

	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);

    }
    else if (retcode == -1)
    {
	error (1, errno, "fork failed while examining update of %s",
	       finfo->fullname);
    }
    else
    {
	write_letter (finfo, 'M');
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
    }
    retval = 0;
 out:
    free (backup);
    return retval;
}

/*
 * Do all the magic associated with a file which needs to be joined
 * (-j option)
 */
static void
join_file (finfo, vers)
    struct file_info *finfo;
    Vers_TS *vers;
{
    char *backup;
    char *t_options;
    int status;

    char *rev1;
    char *rev2;
    char *jrev1;
    char *jrev2;
    char *jdate1;
    char *jdate2;

    if (trace)
	fprintf (stderr, "%s-> join_file(%s, %s%s%s%s, %s, %s)\n",
		CLIENT_SERVER_STR,
		finfo->file,
		vers->tag ? vers->tag : "",
		vers->tag ? " (" : "",
		vers->vn_rcs ? vers->vn_rcs : "",
		vers->tag ? ")" : "",
		join_rev1 ? join_rev1 : "",
		join_rev2 ? join_rev2 : "");

    jrev1 = join_rev1;
    jrev2 = join_rev2;
    jdate1 = date_rev1;
    jdate2 = date_rev2;

    /* Determine if we need to do anything at all.  */
    if (vers->srcfile == NULL ||
	vers->srcfile->path == NULL)
    {
	return;
    }

    /* If only one join revision is specified, it becomes the second
       revision.  */
    if (jrev2 == NULL)
    {
	jrev2 = jrev1;
	jrev1 = NULL;
	jdate2 = jdate1;
	jdate1 = NULL;
    }

    /* Convert the second revision, walking branches and dates.  */
    rev2 = RCS_getversion (vers->srcfile, jrev2, jdate2, 1, (int *) NULL);

    /* If this is a merge of two revisions, get the first revision.
       If only one join tag was specified, then the first revision is
       the greatest common ancestor of the second revision and the
       working file.  */
    if (jrev1 != NULL)
	rev1 = RCS_getversion (vers->srcfile, jrev1, jdate1, 1, (int *) NULL);
    else
    {
	/* Note that we use vn_rcs here, since vn_user may contain a
           special string such as "-nn".  */
	if (vers->vn_rcs == NULL)
	    rev1 = NULL;
	else if (rev2 == NULL)
	{
	    /* This means that the file never existed on the branch.
               It does not mean that the file was removed on the
               branch: that case is represented by a dead rev2.  If
               the file never existed on the branch, then we have
               nothing to merge, so we just return.  */
	    return;
	}
	else
	    rev1 = gca (vers->vn_rcs, rev2);
    }

    /* Handle a nonexistent or dead merge target.  */
    if (rev2 == NULL || RCS_isdead (vers->srcfile, rev2))
    {
	char *mrev;

	if (rev2 != NULL)
	    free (rev2);

	/* If the first revision doesn't exist either, then there is
           no change between the two revisions, so we don't do
           anything.  */
	if (rev1 == NULL || RCS_isdead (vers->srcfile, rev1))
	{
	    if (rev1 != NULL)
		free (rev1);
	    return;
	}

	/* If we are merging two revisions, then the file was removed
	   between the first revision and the second one.  In this
	   case we want to mark the file for removal.

	   If we are merging one revision, then the file has been
	   removed between the greatest common ancestor and the merge
	   revision.  From the perspective of the branch on to which
	   we ar emerging, which may be the trunk, either 1) the file
	   does not currently exist on the target, or 2) the file has
	   not been modified on the target branch since the greatest
	   common ancestor, or 3) the file has been modified on the
	   target branch since the greatest common ancestor.  In case
	   1 there is nothing to do.  In case 2 we mark the file for
	   removal.  In case 3 we have a conflict.

	   Note that the handling is slightly different depending upon
	   whether one or two join targets were specified.  If two
	   join targets were specified, we don't check whether the
	   file was modified since a given point.  My reasoning is
	   that if you ask for an explicit merge between two tags,
	   then you want to merge in whatever was changed between
	   those two tags.  If a file was removed between the two
	   tags, then you want it to be removed.  However, if you ask
	   for a merge of a branch, then you want to merge in all
	   changes which were made on the branch.  If a file was
	   removed on the branch, that is a change to the file.  If
	   the file was also changed on the main line, then that is
	   also a change.  These two changes--the file removal and the
	   modification--must be merged.  This is a conflict.  */

	/* If the user file is dead, or does not exist, or has been
           marked for removal, then there is nothing to do.  */
	if (vers->vn_user == NULL
	    || vers->vn_user[0] == '-'
	    || RCS_isdead (vers->srcfile, vers->vn_user))
	{
	    if (rev1 != NULL)
		free (rev1);
	    return;
	}

	/* If the user file has been marked for addition, or has been
	   locally modified, then we have a conflict which we can not
	   resolve.  No_Difference will already have been called in
	   this case, so comparing the timestamps is sufficient to
	   determine whether the file is locally modified.  */
	if (strcmp (vers->vn_user, "0") == 0
	    || (vers->ts_user != NULL
		&& strcmp (vers->ts_user, vers->ts_rcs) != 0))
	{
	    if (jdate2 != NULL)
		error (0, 0,
		       "file %s is locally modified, but has been removed in revision %s as of %s",
		       finfo->fullname, jrev2, jdate2);
	    else
		error (0, 0,
		       "file %s is locally modified, but has been removed in revision %s",
		       finfo->fullname, jrev2);

	    /* FIXME: Should we arrange to return a non-zero exit
               status?  */

	    if (rev1 != NULL)
		free (rev1);

	    return;
	}

	/* If only one join tag was specified, and the user file has
           been changed since the greatest common ancestor (rev1),
           then there is a conflict we can not resolve.  See above for
           the rationale.  */
	if (join_rev2 == NULL
	    && strcmp (rev1, vers->vn_user) != 0)
	{
	    if (jdate2 != NULL)
		error (0, 0,
		       "file %s has been modified, but has been removed in revision %s as of %s",
		       finfo->fullname, jrev2, jdate2);
	    else
		error (0, 0,
		       "file %s has been modified, but has been removed in revision %s",
		       finfo->fullname, jrev2);

	    /* FIXME: Should we arrange to return a non-zero exit
               status?  */

	    if (rev1 != NULL)
		free (rev1);

	    return;
	}

	if (rev1 != NULL)
	    free (rev1);

	/* The user file exists and has not been modified.  Mark it
           for removal.  FIXME: If we are doing a checkout, this has
           the effect of first checking out the file, and then
           removing it.  It would be better to just register the
           removal. 
	
	   The same goes for a removal then an add.  e.g.
	   cvs up -rbr -jbr2 could remove and readd the same file
	 */
	/* save the rev since server_updated might invalidate it */
	mrev = xmalloc (strlen (vers->vn_user) + 2);
	sprintf (mrev, "-%s", vers->vn_user);
#ifdef SERVER_SUPPORT
	if (server_active)
	{
	    server_scratch (finfo->file);
	    server_updated (finfo, vers, SERVER_UPDATED, (mode_t) -1,
			    (unsigned char *) NULL, (struct buffer *) NULL);
	}
#endif
	Register (finfo->entries, finfo->file, mrev, vers->ts_rcs,
		  vers->options, vers->tag, vers->date, vers->ts_conflict);
	free (mrev);
	/* We need to check existence_error here because if we are
           running as the server, and the file is up to date in the
           working directory, the client will not have sent us a copy.  */
	if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
	    error (0, errno, "cannot remove file %s", finfo->fullname);
#ifdef SERVER_SUPPORT
	if (server_active)
	    server_checked_in (finfo->file, finfo->update_dir,
			       finfo->repository);
#endif
	if (! really_quiet)
	    error (0, 0, "scheduling %s for removal", finfo->fullname);

	return;
    }

    /* If the target of the merge is the same as the working file
       revision, then there is nothing to do.  */
    if (vers->vn_user != NULL && strcmp (rev2, vers->vn_user) == 0)
    {
	if (rev1 != NULL)
	    free (rev1);
	free (rev2);
	return;
    }

    /* If rev1 is dead or does not exist, then the file was added
       between rev1 and rev2.  */
    if (rev1 == NULL || RCS_isdead (vers->srcfile, rev1))
    {
	if (rev1 != NULL)
	    free (rev1);
	free (rev2);

	/* If the file does not exist in the working directory, then
           we can just check out the new revision and mark it for
           addition.  */
	if (vers->vn_user == NULL)
	{
	    char *saved_options = options;
	    Vers_TS *xvers;

	    xvers = Version_TS (finfo, vers->options, jrev2, jdate2, 1, 0);

	    /* Reset any keyword expansion option.  Otherwise, when a
	       command like `cvs update -kk -jT1 -jT2' creates a new file
	       (because a file had the T2 tag, but not T1), the subsequent
	       commit of that just-added file effectively would set the
	       admin `-kk' option for that file in the repository.  */
	    options = NULL;

	    /* FIXME: If checkout_file fails, we should arrange to
               return a non-zero exit status.  */
	    status = checkout_file (finfo, xvers, 1, 0, 1);
	    options = saved_options;

	    freevers_ts (&xvers);

	    return;
	}

	/* The file currently exists in the working directory, so we
           have a conflict which we can not resolve.  Note that this
           is true even if the file is marked for addition or removal.  */

	if (jdate2 != NULL)
	    error (0, 0,
		   "file %s exists, but has been added in revision %s as of %s",
		   finfo->fullname, jrev2, jdate2);
	else
	    error (0, 0,
		   "file %s exists, but has been added in revision %s",
		   finfo->fullname, jrev2);

	return;
    }

    /* If the two merge revisions are the same, then there is nothing
       to do.  */
    if (strcmp (rev1, rev2) == 0)
    {
	free (rev1);
	free (rev2);
	return;
    }

    /* If there is no working file, then we can't do the merge.  */
    if (vers->vn_user == NULL)
    {
	free (rev1);
	free (rev2);

	if (jdate2 != NULL)
	    error (0, 0,
		   "file %s does not exist, but is present in revision %s as of %s",
		   finfo->fullname, jrev2, jdate2);
	else
	    error (0, 0,
		   "file %s does not exist, but is present in revision %s",
		   finfo->fullname, jrev2);

	/* FIXME: Should we arrange to return a non-zero exit status?  */

	return;
    }

#ifdef SERVER_SUPPORT
    if (server_active && !isreadable (finfo->file))
    {
	int retcode;
	/* The file is up to date.  Need to check out the current contents.  */
	retcode = RCS_checkout (vers->srcfile, finfo->file,
				vers->vn_user, (char *) NULL,
				(char *) NULL, RUN_TTY,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
	if (retcode != 0)
	    error (1, 0,
		   "failed to check out %s file", finfo->fullname);
    }
#endif

    /*
     * The users currently modified file is moved to a backup file name
     * ".#filename.version", so that it will stay around for a few days
     * before being automatically removed by some cron daemon.  The "version"
     * is the version of the file that the user was most up-to-date with
     * before the merge.
     */
    backup = xmalloc (strlen (finfo->file)
		      + strlen (vers->vn_user)
		      + sizeof (BAKPREFIX)
		      + 10);
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, finfo->file, vers->vn_user);

    if (unlink_file (backup) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", backup);
    copy_file (finfo->file, backup);
    xchmod (finfo->file, 1);

    t_options = vers->options;
#if 0
    if (*t_options == '\0')
	t_options = "-kk";		/* to ignore keyword expansions */
#endif

    /* If the source of the merge is the same as the working file
       revision, then we can just RCS_checkout the target (no merging
       as such).  In the text file case, this is probably quite
       similar to the RCS_merge, but in the binary file case,
       RCS_merge gives all kinds of trouble.  */
    if (vers->vn_user != NULL
	&& strcmp (rev1, vers->vn_user) == 0
	/* See comments above about how No_Difference has already been
	   called.  */
	&& vers->ts_user != NULL
	&& strcmp (vers->ts_user, vers->ts_rcs) == 0

	/* This is because of the worry below about $Name.  If that
	   isn't a problem, I suspect this code probably works for
	   text files too.  */
	&& (strcmp (t_options, "-kb") == 0
	    || wrap_merge_is_copy (finfo->file)))
    {
	/* FIXME: what about nametag?  What does RCS_merge do with
	   $Name?  */
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, t_options,
			  RUN_TTY, (RCSCHECKOUTPROC)0, NULL) != 0)
	    status = 2;
	else
	    status = 0;

	/* OK, this is really stupid.  RCS_checkout carefully removes
	   write permissions, and we carefully put them back.  But
	   until someone gets around to fixing it, that seems like the
	   easiest way to get what would seem to be the right mode.
	   I don't check CVSWRITE or _watched; I haven't thought about
	   that in great detail, but it seems like a watched file should
	   be checked out (writable) after a merge.  */
	xchmod (finfo->file, 1);

	/* Traditionally, the text file case prints a whole bunch of
	   scary looking and verbose output which fails to tell the user
	   what is really going on (it gives them rev1 and rev2 but doesn't
	   indicate in any way that rev1 == vn_user).  I think just a
	   simple "U foo" is good here; it seems analogous to the case in
	   which the file was added on the branch in terms of what to
	   print.  */
	write_letter (finfo, 'U');
    }
    else if (strcmp (t_options, "-kb") == 0
	     || wrap_merge_is_copy (finfo->file)
	     || special_file_mismatch (finfo, rev1, rev2))
    {
	/* We are dealing with binary files, or files with a
	   permission/linkage mismatch, and real merging would
	   need to take place.  This is a conflict.  We give the user
	   the two files, and let them resolve it.  It is possible
	   that we should require a "touch foo" or similar step before
	   we allow a checkin.  */
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, t_options,
			  RUN_TTY, (RCSCHECKOUTPROC)0, NULL) != 0)
	    status = 2;
	else
	    status = 0;

	/* OK, this is really stupid.  RCS_checkout carefully removes
	   write permissions, and we carefully put them back.  But
	   until someone gets around to fixing it, that seems like the
	   easiest way to get what would seem to be the right mode.
	   I don't check CVSWRITE or _watched; I haven't thought about
	   that in great detail, but it seems like a watched file should
	   be checked out (writable) after a merge.  */
	xchmod (finfo->file, 1);

	/* Hmm.  We don't give them REV1 anywhere.  I guess most people
	   probably don't have a 3-way merge tool for the file type in
	   question, and might just get confused if we tried to either
	   provide them with a copy of the file from REV1, or even just
	   told them what REV1 is so they can get it themself, but it
	   might be worth thinking about.  */
	/* See comment in merge_file about the "nonmergeable file"
	   terminology.  */
	error (0, 0, "nonmergeable file needs merge");
	error (0, 0, "revision %s from repository is now in %s",
	       rev2, finfo->fullname);
	error (0, 0, "file from working directory is now in %s", backup);
	write_letter (finfo, 'C');
    }
    else
	status = RCS_merge (finfo->rcs, vers->srcfile->path, finfo->file,
			    t_options, rev1, rev2);

    if (status != 0 && status != 1)
    {
	error (0, status == -1 ? errno : 0,
	       "could not merge revision %s of %s", rev2, finfo->fullname);
	error (status == -1 ? 1 : 0, 0, "restoring %s from backup file %s",
	       finfo->fullname, backup);
	rename_file (backup, finfo->file);
    }
    free (rev1);
    free (rev2);

    /* The file has changed, but if we just checked it out it may
       still have the same timestamp it did when it was first
       registered above in checkout_file.  We register it again with a
       dummy timestamp to make sure that later runs of CVS will
       recognize that it has changed.

       We don't actually need to register again if we called
       RCS_checkout above, and we aren't running as the server.
       However, that is not the normal case, and calling Register
       again won't cost much in that case.  */
    {
	char *cp = 0;

	if (status)
	{
	    (void) time (&last_register_time);
	    cp = time_stamp (finfo->file);
	}
	Register (finfo->entries, finfo->file,
		  vers->vn_rcs ? vers->vn_rcs : "0", "Result of merge",
		  vers->options, vers->tag, vers->date, cp);
	if (cp)
	    free(cp);
    }

#ifdef SERVER_SUPPORT
    if (server_active)
    {
	server_copy_file (finfo->file, finfo->update_dir, finfo->repository,
			  backup);
	server_updated (finfo, vers, SERVER_MERGED,
			(mode_t) -1, (unsigned char *) NULL,
			(struct buffer *) NULL);
    }
#endif
    free (backup);
}

/*
 * Report whether revisions REV1 and REV2 of FINFO agree on:
 *   . file ownership
 *   . permissions
 *   . major and minor device numbers
 *   . symbolic links
 *   . hard links
 *
 * If either REV1 or REV2 is NULL, the working copy is used instead.
 *
 * Return 1 if the files differ on these data.
 */

int
special_file_mismatch (finfo, rev1, rev2)
    struct file_info *finfo;
    char *rev1;
    char *rev2;
{
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    struct stat sb;
    RCSVers *vp;
    Node *n;
    uid_t rev1_uid, rev2_uid;
    gid_t rev1_gid, rev2_gid;
    mode_t rev1_mode, rev2_mode;
    unsigned long dev_long;
    dev_t rev1_dev, rev2_dev;
    char *rev1_symlink = NULL;
    char *rev2_symlink = NULL;
    List *rev1_hardlinks = NULL;
    List *rev2_hardlinks = NULL;
    int check_uids, check_gids, check_modes;
    int result;

    /* If we don't care about special file info, then
       don't report a mismatch in any case. */
    if (!preserve_perms)
	return 0;

    /* When special_file_mismatch is called from No_Difference, the
       RCS file has been only partially parsed.  We must read the
       delta tree in order to compare special file info recorded in
       the delta nodes.  (I think this is safe. -twp) */
    if (finfo->rcs->flags & PARTIAL)
	RCS_reparsercsfile (finfo->rcs, NULL, NULL);

    check_uids = check_gids = check_modes = 1;

    /* Obtain file information for REV1.  If this is null, then stat
       finfo->file and use that info. */
    /* If a revision does not know anything about its status,
       then presumably it doesn't matter, and indicates no conflict. */

    if (rev1 == NULL)
    {
	if (islink (finfo->file))
	    rev1_symlink = xreadlink (finfo->file);
	else
	{
#ifdef HAVE_ST_RDEV
	    if (CVS_LSTAT (finfo->file, &sb) < 0)
		error (1, errno, "could not get file information for %s",
		       finfo->file);
	    rev1_uid = sb.st_uid;
	    rev1_gid = sb.st_gid;
	    rev1_mode = sb.st_mode;
	    if (S_ISBLK (rev1_mode) || S_ISCHR (rev1_mode))
		rev1_dev = sb.st_rdev;
#else
	    error (1, 0, "cannot handle device files on this system (%s)",
		   finfo->file);
#endif
	}
	rev1_hardlinks = list_linked_files_on_disk (finfo->file);
    }
    else
    {
	n = findnode (finfo->rcs->versions, rev1);
	vp = (RCSVers *) n->data;

	n = findnode (vp->other_delta, "symlink");
	if (n != NULL)
	    rev1_symlink = xstrdup (n->data);
	else
	{
	    n = findnode (vp->other_delta, "owner");
	    if (n == NULL)
		check_uids = 0;	/* don't care */
	    else
		rev1_uid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "group");
	    if (n == NULL)
		check_gids = 0;	/* don't care */
	    else
		rev1_gid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "permissions");
	    if (n == NULL)
		check_modes = 0;	/* don't care */
	    else
		rev1_mode = strtoul (n->data, NULL, 8);

	    n = findnode (vp->other_delta, "special");
	    if (n == NULL)
		rev1_mode |= S_IFREG;
	    else
	    {
		/* If the size of `ftype' changes, fix the sscanf call also */
		char ftype[16+1];
		if (sscanf (n->data, "%16s %lu", ftype,
			    &dev_long) < 2)
		    error (1, 0, "%s:%s has bad `special' newphrase %s",
			   finfo->file, rev1, n->data);
		rev1_dev = dev_long;
		if (strcmp (ftype, "character") == 0)
		    rev1_mode |= S_IFCHR;
		else if (strcmp (ftype, "block") == 0)
		    rev1_mode |= S_IFBLK;
		else
		    error (0, 0, "%s:%s unknown file type `%s'",
			   finfo->file, rev1, ftype);
	    }

	    rev1_hardlinks = vp->hardlinks;
	    if (rev1_hardlinks == NULL)
		rev1_hardlinks = getlist();
	}
    }

    /* Obtain file information for REV2. */
    if (rev2 == NULL)
    {
	if (islink (finfo->file))
	    rev2_symlink = xreadlink (finfo->file);
	else
	{
#ifdef HAVE_ST_RDEV
	    if (CVS_LSTAT (finfo->file, &sb) < 0)
		error (1, errno, "could not get file information for %s",
		       finfo->file);
	    rev2_uid = sb.st_uid;
	    rev2_gid = sb.st_gid;
	    rev2_mode = sb.st_mode;
	    if (S_ISBLK (rev2_mode) || S_ISCHR (rev2_mode))
		rev2_dev = sb.st_rdev;
#else
	    error (1, 0, "cannot handle device files on this system (%s)",
		   finfo->file);
#endif
	}
	rev2_hardlinks = list_linked_files_on_disk (finfo->file);
    }
    else
    {
	n = findnode (finfo->rcs->versions, rev2);
	vp = (RCSVers *) n->data;

	n = findnode (vp->other_delta, "symlink");
	if (n != NULL)
	    rev2_symlink = xstrdup (n->data);
	else
	{
	    n = findnode (vp->other_delta, "owner");
	    if (n == NULL)
		check_uids = 0;	/* don't care */
	    else
		rev2_uid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "group");
	    if (n == NULL)
		check_gids = 0;	/* don't care */
	    else
		rev2_gid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "permissions");
	    if (n == NULL)
		check_modes = 0;	/* don't care */
	    else
		rev2_mode = strtoul (n->data, NULL, 8);

	    n = findnode (vp->other_delta, "special");
	    if (n == NULL)
		rev2_mode |= S_IFREG;
	    else
	    {
		/* If the size of `ftype' changes, fix the sscanf call also */
		char ftype[16+1];
		if (sscanf (n->data, "%16s %lu", ftype,
			    &dev_long) < 2)
		    error (1, 0, "%s:%s has bad `special' newphrase %s",
			   finfo->file, rev2, n->data);
		rev2_dev = dev_long;
		if (strcmp (ftype, "character") == 0)
		    rev2_mode |= S_IFCHR;
		else if (strcmp (ftype, "block") == 0)
		    rev2_mode |= S_IFBLK;
		else
		    error (0, 0, "%s:%s unknown file type `%s'",
			   finfo->file, rev2, ftype);
	    }

	    rev2_hardlinks = vp->hardlinks;
	    if (rev2_hardlinks == NULL)
		rev2_hardlinks = getlist();
	}
    }

    /* Check the user/group ownerships and file permissions, printing
       an error for each mismatch found.  Return 0 if all characteristics
       matched, and 1 otherwise. */

    result = 0;

    /* Compare symlinks first, since symlinks are simpler (don't have
       any other characteristics). */
    if (rev1_symlink != NULL && rev2_symlink == NULL)
    {
	error (0, 0, "%s is a symbolic link",
	       (rev1 == NULL ? "working file" : rev1));
	result = 1;
    }
    else if (rev1_symlink == NULL && rev2_symlink != NULL)
    {
	error (0, 0, "%s is a symbolic link",
	       (rev2 == NULL ? "working file" : rev2));
	result = 1;
    }
    else if (rev1_symlink != NULL)
	result = (strcmp (rev1_symlink, rev2_symlink) == 0);
    else
    {
	/* Compare user ownership. */
	if (check_uids && rev1_uid != rev2_uid)
	{
	    error (0, 0, "%s: owner mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}

	/* Compare group ownership. */
	if (check_gids && rev1_gid != rev2_gid)
	{
	    error (0, 0, "%s: group mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
    
	/* Compare permissions. */
	if (check_modes &&
	    (rev1_mode & 07777) != (rev2_mode & 07777))
	{
	    error (0, 0, "%s: permission mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}

	/* Compare device file characteristics. */
	if ((rev1_mode & S_IFMT) != (rev2_mode & S_IFMT))
	{
	    error (0, 0, "%s: %s and %s are different file types",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
	else if (S_ISBLK (rev1_mode))
	{
	    if (rev1_dev != rev2_dev)
	    {
		error (0, 0, "%s: device numbers of %s and %s do not match",
		       finfo->file,
		       (rev1 == NULL ? "working file" : rev1),
		       (rev2 == NULL ? "working file" : rev2));
		result = 1;
	    }
	}

	/* Compare hard links. */
	if (compare_linkage_lists (rev1_hardlinks, rev2_hardlinks) == 0)
	{
	    error (0, 0, "%s: hard linkage of %s and %s do not match",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
    }

    if (rev1_symlink != NULL)
	free (rev1_symlink);
    if (rev2_symlink != NULL)
	free (rev2_symlink);
    if (rev1_hardlinks != NULL)
	dellist (&rev1_hardlinks);
    if (rev2_hardlinks != NULL)
	dellist (&rev2_hardlinks);

    return result;
#else
    return 0;
#endif
}

int
joining ()
{
    return (join_rev1 != NULL);
}
@


1.20
log
@minor string cleanings; tdeval ok
@
text
@d1098 1
a1098 1
	if (getline (&line, &line_allocated, fp) >= 0)
@


1.19
log
@Allow a CVS tagname to be expanded during checkout, export and update to be
specified on the command line; ok niklas@@ pval@@
@
text
@d1947 1
a1947 1
	    sprintf (buf, "+%s", tag);
d1958 1
a1958 1
	    sprintf (buf, "-%s", tag);
@


1.18
log
@Merge local changes; work in progress
@
text
@d112 1
a112 1
    "    [-I ign] [-W spec] [files...]\n",
d127 1
d152 1
a152 1
    while ((c = getopt (argc, argv, "+ApCPflRQqduk:r:D:j:I:W:")) != -1)
d198 5
@


1.17
log
@Integrate local changes
@
text
@d61 1
a61 1
static int scratch_file PROTO((struct file_info *finfo));
d102 1
d111 1
a111 1
    "Usage: %s %s [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]\n",
d121 1
a121 1
    "\t-k kopt\tUse RCS kopt -k option on checkout.\n",
d237 1
a237 1
    if (client_active) 
d413 1
a413 1
		     pipeout, which, join_rev1, join_rev2, (char *) NULL);
d427 2
a428 1
	   xprune, xpipeout, which, xjoin_rev1, xjoin_rev2, preload_update_dir)
d444 1
d458 1
d510 5
d518 1
a518 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
a585 3
    int resurrecting;

    resurrecting = 0;
a630 1
#ifdef SERVER_SUPPORT
a631 1
#endif
d656 6
a661 2
		retval = merge_file (finfo, vers);
		break;
d741 1
a742 1
	    case T_PATCH:		/* needs patch */
d764 1
a768 1
#endif
d781 1
a781 12
		retval = scratch_file (finfo);
#ifdef SERVER_SUPPORT
		if (server_active && retval == 0)
		{
		    if (vers->ts_user == NULL)
			server_scratch_entry_only ();
		    server_updated (finfo, vers,
				    SERVER_UPDATED, (mode_t) -1,
				    (unsigned char *) NULL,
				    (struct buffer *) NULL);
		}
#endif
d796 1
a796 1
    if (ignlist)
d876 1
a876 1
	    Create_Root ((char *) NULL, CVSroot_original);
d969 1
a969 1
			  1);
d1172 1
a1172 1
    while ((dp = readdir (dirp)) != NULL)
d1181 1
a1181 1
		(void) closedir (dirp);
d1212 1
a1212 1
		    (void) closedir (dirp);
d1222 1
a1222 1
	(void) closedir (dirp);
d1225 1
a1225 1
    (void) closedir (dirp);
d1233 1
a1233 1
scratch_file (finfo)
d1235 1
d1239 11
d1252 21
d1776 1
a1776 1
	retcode = diff_exec (file1, file2, diff_options, finfo->file);
d2152 11
d2331 8
a2338 1
           removal.  */
a2346 2
	mrev = xmalloc (strlen (vers->vn_user) + 2);
	sprintf (mrev, "-%s", vers->vn_user);
d2389 1
d2404 1
@


1.16
log
@Add missing local change that was lost in a merge.
@
text
@d97 1
d114 1
d150 1
a150 1
    while ((c = getopt (argc, argv, "+ApPflRQqduk:r:D:j:I:W:")) != -1)
d157 3
d260 2
d276 1
a276 11
	    /* If the server supports the command "update-patches", that means
	       that it knows how to handle the -u argument to update, which
	       means to send patches instead of complete files.

	       We don't send -u if failed_patches != NULL, so that the
	       server doesn't try to send patches which will just fail
	       again.  At least currently, the client also clobbers the
	       file and tells the server it is lost, which also will get
	       a full file instead of a patch, but it seems clean to omit
	       -u.  */
	    if (failed_patches == NULL)
d278 12
a291 1
	    }
d293 8
a300 2
	    if (failed_patches == NULL)
	    {
d303 2
a304 2
		send_files (argc, argv, local, aflag,
			    update_build_dirs ? SEND_BUILD_DIRS : 0);
d328 1
a330 3
	    failed_patches = NULL;
	    failed_patches_count = 0;

d349 1
a349 1
		&& (failed_patches == NULL || pass > 1))
d351 2
d357 1
a357 1
	} while (failed_patches != NULL);
d383 5
a387 1
		server_clear_entstat (".", Name_Repository (NULL, NULL));
d394 3
a396 2
	    WriteTag ((char *) NULL, tag, date, 0,
		      ".", Name_Repository (NULL, NULL));
d506 1
a506 1
    /* see if we need to sleep before returning */
d509 2
a510 8
	time_t now;

	for (;;)
	{
	    (void) time (&now);
	    if (now != last_register_time) break;
	    sleep (1);			/* to avoid time-stamp races */
	}
d657 43
a699 17
		if (vers->ts_conflict)
		{
		    char *filestamp;
		    int retcode;

		    /*
		     * If the timestamp has changed and no conflict indicators
		     * are found, it isn't a 'C' any more.
		     */
#ifdef SERVER_SUPPORT
		    if (server_active)
			retcode = vers->ts_conflict[0] != '=';
		    else {
			filestamp = time_stamp (finfo->file);
			retcode = strcmp (vers->ts_conflict, filestamp);
			free (filestamp);
		    }
d701 32
a732 30
		    filestamp = time_stamp (finfo->file);
		    retcode = strcmp (vers->ts_conflict, filestamp);
		    free (filestamp);
#endif

		    if (retcode)
		    {
			/* The timestamps differ.  But if there are conflict
			   markers print 'C' anyway.  */
			retcode = !file_has_markers (finfo);
		    }

		    if (!retcode)
		    {
			write_letter (finfo, 'C');
			retval = 1;
		    }
		    else
		    {
			/* Reregister to clear conflict flag. */
			Register (finfo->entries, finfo->file, vers->vn_rcs, vers->ts_rcs,
				  vers->options, vers->tag,
				  vers->date, (char *)0);
		    }
		}
		if (!retval)
		{
		    write_letter (finfo, 'M');
		    retval = 0;
		}
d972 2
a973 1
			  0);
d1059 4
d1108 1
d2113 1
a2113 1
    char *options;
d2348 7
d2397 1
a2397 1
		   "file %s is present in revision %s as of %s",
d2401 1
a2401 1
		   "file %s is present in revision %s",
d2443 1
a2443 1
    options = vers->options;
d2445 2
a2446 2
    if (*options == '\0')
	options = "-kk";		/* to ignore keyword expansions */
d2464 1
a2464 1
	&& (strcmp (options, "-kb") == 0
d2469 1
a2469 1
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, options,
d2493 1
a2493 1
    else if (strcmp (options, "-kb") == 0
d2503 1
a2503 1
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, options,
d2534 1
a2534 1
			    options, rev1, rev2);
d2565 3
a2567 3
	Register (finfo->entries, finfo->file, vers->vn_rcs,
		  "Result of merge", vers->options, vers->tag,
		  vers->date, cp);
d2615 2
a2616 2
    List *rev1_hardlinks;
    List *rev2_hardlinks;
d2645 1
d2654 4
d2723 1
d2732 4
@


1.15
log
@Integrate local changes
@
text
@d1655 3
@


1.14
log
@Integrate local changes
@
text
@d492 4
a495 2
	(void) time (&now);
	if (now == last_register_time)
d497 1
d1651 1
a1651 1
				vers_ts->vn_rcs, (char *) NULL,
@


1.13
log
@Integrate local changes
@
text
@d4 1
a4 1
 * 
d7 1
a7 1
 * 
d11 1
a11 1
 * 
d14 1
a14 1
 * 
d17 1
a17 1
 * 
d20 1
a20 1
 * 
d26 1
a26 1
 * 
d29 1
a29 1
 * 
a286 1
		send_file_names (argc, argv, SEND_EXPAND_WILD);
d291 1
d307 4
a310 2
		    (void) unlink_file (failed_patches[i]);
		send_file_names (failed_patches_count, failed_patches, 0);
d313 1
d637 1
a637 9
		if (noexec)
		{
		    retval = 1;
		    write_letter (finfo, 'C');
		}
		else
		{
		    retval = merge_file (finfo, vers);
		}
d872 22
d1305 1
a1305 1
	    if (revbuf != NULL)
d1309 4
a1312 1
		/* FIXME: We should have RCS_checkout return the mode.  */
d1512 1
a1512 1
    struct MD5Context context;
d1592 5
a1596 1
        (void) unlink_file (backup);
d1645 1
a1645 1
	MD5Init (&data.context);
d1658 1
a1658 1
	    MD5Final (checksum, &data.context);
d1793 9
a1801 3
    (void) unlink_file (backup);
    (void) unlink_file (file1);
    (void) unlink_file (file2);
d1827 1
a1827 1
	MD5Update (&data->context, (unsigned char *) buffer, len);
d1903 2
a1904 1
    (void) unlink_file (backup);
d2007 2
d2011 7
a2017 2
	printf ("%s already contains the differences between %s and %s\n",
		finfo->fullname, vers->vn_user, vers->vn_rcs);
d2026 1
a2026 2
	if (!noexec)
	    error (0, 0, "conflicts found in %s", finfo->fullname);
d2377 3
a2379 1
    (void) unlink_file (backup);
@


1.12
log
@Integrate local changes
@
text
@a1641 2
	/* FIXME: It might be better to come up with a diff library
           which can be shared with the diffutils.  */
d1650 4
a1653 2
	    /* We use -c, not -u, because we have no way of knowing
	       which DIFF is in use.  */
d1935 4
a1938 1
    (void) time (&last_register_time);
d1943 2
d1946 4
a1949 2
	Register (finfo->entries, finfo->file, vers->vn_rcs, vers->ts_rcs, vers->options,
		  vers->tag, vers->date, cp);
d2448 10
a2457 11
#ifdef SERVER_SUPPORT
    /*
     * If we're in server mode, then we need to re-register the file
     * even if there were no conflicts (status == 0).
     * This tells server_updated() to send the modified file back to
     * the client.
     */
    if (status == 1 || (status == 0 && server_active))
#else
    if (status == 1)
#endif
d2462 2
d2465 4
a2468 3
	Register (finfo->entries, finfo->file,
		  vers->vn_rcs, vers->ts_rcs, vers->options,
		  vers->tag, vers->date, cp);
@


1.11
log
@more careful scanf
@
text
@a532 1
    hlinfo->links = NULL;
d2507 2
a2508 2
    char *rev1_hardlinks = NULL;
    char *rev2_hardlinks = NULL;
d2546 1
a2546 1
	rev1_hardlinks = list_files_linked_to (finfo->file);
d2597 3
a2599 5
	    n = findnode (vp->other_delta, "hardlinks");
	    if (n == NULL)
		rev1_hardlinks = xstrdup ("");
	    else
		rev1_hardlinks = xstrdup (n->data);
d2619 1
a2619 1
	rev2_hardlinks = list_files_linked_to (finfo->file);
d2670 3
a2672 5
	    n = findnode (vp->other_delta, "hardlinks");
	    if (n == NULL)
		rev2_hardlinks = xstrdup ("");
	    else
		rev2_hardlinks = xstrdup (n->data);
d2753 1
a2753 1
	if (strcmp (rev1_hardlinks, rev2_hardlinks) != 0)
d2768 1
a2768 1
	free (rev1_hardlinks);
d2770 1
a2770 1
	free (rev2_hardlinks);
@


1.10
log
@Integrate local changes
@
text
@d2583 1
a2583 1
		char ftype[16];
d2658 1
a2658 1
		char ftype[16];
@


1.9
log
@Integrate local changes
@
text
@d45 2
d49 4
a52 1
				 int adding));
d72 3
d90 4
d452 26
d497 44
d611 1
a611 1
		retval = checkout_file (finfo, vers, 0);
d714 2
a715 1
					    &file_info, checksum);
d725 1
a725 7
		retval = checkout_file (finfo, vers, 0);
#ifdef SERVER_SUPPORT
		if (server_active && retval == 0)
		    server_updated (finfo, vers,
				    SERVER_UPDATED, (struct stat *) NULL,
				    (unsigned char *) NULL);
#endif
d743 3
a745 2
				    SERVER_UPDATED, (struct stat *) NULL,
				    (unsigned char *) NULL);
d887 20
d998 21
d1138 1
a1138 1
		l = Entries_Open (0);
d1185 1
a1185 1
checkout_file (finfo, vers_ts, adding)
d1189 2
a1193 1
    int retcode = 0;
d1196 1
a1197 1
    /* Solely to suppress a warning from gcc -Wall.  */
d1199 1
d1201 7
a1207 2
    /* don't screw with backup files if we're going to stdout */
    if (!pipeout)
d1217 1
d1227 3
d1257 21
a1277 5
	status = RCS_checkout (vers_ts->srcfile,
			       pipeout ? NULL : finfo->file,
			       vers_ts->vn_rcs, vers_ts->vn_tag,
			       vers_ts->options, RUN_TTY,
			       (RCSCHECKOUTPROC) NULL, (void *) NULL);
d1281 4
d1289 11
d1303 12
a1314 1
		xchmod (finfo->file, 1);
d1346 21
d1375 1
a1375 1
			   finfo->fullname);
d1422 7
d1432 2
a1433 3
	int old_errno = errno;		/* save errno value over the rename */

	if (!pipeout && isfile (backup))
d1435 3
d1439 1
a1439 2
	error (retcode == -1 ? 1 : 0, retcode == -1 ? old_errno : 0,
	       "could not check out %s", finfo->fullname);
d1441 1
a1441 1
	retval = retcode;
d1444 1
a1444 1
    if (!pipeout)
d1463 18
d1557 8
d1879 2
a1880 1
	|| wrap_merge_is_copy (finfo->file))
d1882 2
a1883 1
	/* For binary files, a merge is always a conflict.  We give the
d1887 10
a1896 1
	status = checkout_file (finfo, vers, 0);
a1897 3
	/* Send the new contents of the file before the message.  If we
	   wanted to be totally correct, we would have the client write
	   the message only after the file has safely been written.  */
a1898 1
	{
a1900 3
	    server_updated (finfo, vers, SERVER_MERGED,
			    (struct stat *) NULL, (unsigned char *) NULL);
	}
d1902 3
d1965 2
a1966 1
			(struct stat *) NULL, (unsigned char *) NULL);
d2200 2
a2201 2
	    server_updated (finfo, vers, SERVER_UPDATED, (struct stat *) NULL,
			    (unsigned char *) NULL);
d2254 1
a2254 8
	    status = checkout_file (finfo, xvers, 1);

#ifdef SERVER_SUPPORT
	    if (server_active && status == 0)
		server_updated (finfo, xvers,
				SERVER_UPDATED, (struct stat *) NULL,
				(unsigned char *) NULL);
#endif
d2316 1
a2316 1
	    error (1, retcode == -1 ? errno : 0,
d2389 2
a2390 1
	     || wrap_merge_is_copy (finfo->file))
d2392 2
a2393 1
	/* We are dealing with binary files, but real merging would
d2471 2
a2472 1
			(struct stat *) NULL, (unsigned char *) NULL);
d2476 305
@


1.8
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d67 1
a67 4
static int write_letter PROTO((char *file, int letter, char *update_dir));
#ifdef SERVER_SUPPORT
static void join_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts));
#else
a68 1
#endif
d112 1
d259 8
a266 1
	       means to send patches instead of complete files.  */
a268 4
#ifndef DONT_USE_PATCH
		/* Systems which don't have the patch program ported to them
		   will want to define DONT_USE_PATCH; then CVS won't try to
		   invoke patch.  */
a270 1
#endif
d550 1
a550 1
		(void) write_letter (finfo->file, 'C', finfo->update_dir);
d556 1
a556 1
		    (void) write_letter (finfo->file, 'C', finfo->update_dir);
d560 1
a560 28
		    if (wrap_merge_is_copy (finfo->file))
#if 0
			/* Look, we can't clobber the user's file.  We
			   know it is modified and we're going to
			   overwrite their mod?  Puh-leeze.  The
			   correct behavior is probably something like
			   what merge_file does for -kb, which is to
			   give the users both files and tell them
			   what the two filenames are.  Of course, -m
			   in wrappers needs to be documented *much*
			   better.  Anyway, until then, make this a
			   fatal error.  */

			/* Should we be warning the user that we are
			 * overwriting the user's copy of the file?  */
			retval =
			  checkout_file (finfo, vers, 0);
#else
		    {
		        error (0, 0, "A -m 'COPY' wrapper is specified");
			error (0, 0, "but file %s needs merge",
			       finfo->fullname);
			error (1, 0, "\
You probably want to avoid -m 'COPY' wrappers");
#endif
		    }
		    else
			retval = merge_file (finfo, vers);
d597 1
a597 1
			(void) write_letter (finfo->file, 'C', finfo->update_dir);
d609 4
a612 1
		    retval = write_letter (finfo->file, 'M', finfo->update_dir);
a635 1
		/* Fall through.  */
d637 2
a638 2
		   file out.  It's simpler and faster than starting up
		   two new processes (diff and patch).  */
d651 2
a652 1
		retval = write_letter (finfo->file, 'A', finfo->update_dir);
d655 2
a656 1
		retval = write_letter (finfo->file, 'R', finfo->update_dir);
d706 17
a722 1
    (void) write_letter (file, '?', dir);
d803 1
a803 1
	    error (0, 0, "New directory `%s' -- ignored", dir);
d813 1
d916 2
a917 1
	    run_setup ("%s %s", line, repository);
d1077 3
d1093 7
a1099 1
	    (void) unlink_file_dir (backup);
d1139 1
a1139 1
	    if (cvswrite == TRUE
d1161 5
a1165 7
	    if (vers_ts->vn_user == NULL ||
		strncmp (vers_ts->ts_rcs, "Initial", 7) == 0)
	    {
		set_time = 1;
	    }
	    else
		set_time = 0;
d1226 1
a1226 1
		write_letter (finfo->file, 'U', finfo->update_dir);
d1247 7
a1253 1
	(void) unlink_file_dir (backup);
d1317 21
d1414 1
a1414 1
	const char *diff_options;
d1432 10
a1441 9
	    /* FIXME: We should use -a if diff supports it.  We should
               probably just copy over most or all of the diff
               handling in the RCS configure script.  */
	    /* IMHO, we shouldn't copy over anything which even
	       vaguely resembles the RCS configure script.  That kind of
	       thing tends to be ugly, slow, and fragile.  It also is a
	       a support headache for CVS to behave differently in subtle
	       ways based on whether it was installed correctly.  Instead we
	       should come up with a diff library.  -kingdon, Apr 1997.  */
d1444 1
a1444 1
	run_setup ("%s %s %s %s", DIFF, diff_options, file1, file2);
d1447 1
a1447 1
	if ((retcode = run_exec (RUN_TTY, finfo->file, RUN_TTY, RUN_NORMAL)) != 0
d1467 1
a1467 1
	    if (cvswrite == TRUE
d1525 1
a1525 1
	    write_letter (finfo->file, 'P', finfo->update_dir);
d1571 1
a1571 1
	MD5Update (&data->context, buffer, len);
d1580 3
a1582 3
static int
write_letter (file, letter, update_dir)
    char *file;
a1583 1
    char *update_dir;
d1587 19
a1605 1
	char buf[2];
d1608 5
a1612 2
	cvs_output (buf, 2);
	if (update_dir[0])
d1614 2
a1615 2
	    cvs_output (update_dir, 0);
	    cvs_output ("/", 1);
a1616 2
	cvs_output (file, 0);
	cvs_output ("\n", 1);
d1618 1
a1618 1
    return (0);
d1651 2
a1652 1
    if (strcmp (vers->options, "-kb") == 0)
d1671 5
a1675 1
	error (0, 0, "binary file needs merge");
d1679 1
a1679 1
	write_letter (finfo->file, 'C', finfo->update_dir);
d1687 1
a1687 1
    status = RCS_merge(vers->srcfile->path, 
d1750 1
a1750 1
	write_letter (finfo->file, 'C', finfo->update_dir);
d1762 1
a1762 1
	write_letter (finfo->file, 'M', finfo->update_dir);
a1796 8
    if (wrap_merge_is_copy (finfo->file))
    {
	error (0, 0,
	       "Cannot merge %s because it is a merge-by-copy file.",
	       finfo->fullname);
	return;
    }

d2092 1
a2092 1
    
a2110 1
#ifdef HAVE_RCS5
a2114 1
#endif
d2116 85
a2200 1
    status = RCS_merge (vers->srcfile->path, options, rev1, rev2);
@


1.7
log
@Integrate local changes
@
text
@d95 1
d138 1
a138 1
    optind = 1;
d204 1
d206 2
d562 12
d578 9
d654 4
a657 2
					    SERVER_PATCHED, &file_info,
					    checksum);
d1272 1
a1272 1
/* Patch a file.  Runs rcsdiff.  This is only done when running as the
d1386 30
a1415 10
	/* FIXME: This whole thing with diff/patch is rather more
	   convoluted than necessary (lots of forks and execs, need to
	   worry about versions of diff and patch, etc.).  Also, we
	   send context lines which aren't needed (in the rare case in
	   which the diff doesn't apply, the checksum would catches it).
	   Solution perhaps is to librarify the RCS routines which apply
	   deltas or something equivalent.  */
	/* This is -c, not -u, because we have no way of knowing which
	   DIFF is in use.  */
	run_setup ("%s -c %s %s", DIFF, file1, file2);
@


1.6
log
@Integrate local changes
@
text
@d53 1
d77 9
d138 1
a138 1
    while ((c = getopt (argc, argv, "ApPflRQqduk:r:D:j:I:W:")) != -1)
d273 4
a276 1
		send_files (argc, argv, local, aflag, update_build_dirs, 0);
d295 1
a295 1
			    aflag, update_build_dirs, 0);
d358 4
a361 5
	    WriteTag ((char *) NULL, tag, date);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_sticky (".", Name_Repository (NULL, NULL), tag, date);
#endif
d481 17
d715 6
d791 6
a796 1
	    Create_Admin (dir, update_dir, repository, tag, date);
d848 3
a850 5
	    WriteTag (dir, tag, date);
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_set_sticky (update_dir, repository, tag, date);
#endif
d1100 2
a1101 1
			       vers_ts->options, RUN_TTY);
d1227 18
d1265 1
d1269 9
a1277 1
    if (pipeout || joining ())
d1309 22
a1330 9
    if (noexec)
	retcode = 0;
    else
	retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
				vers_ts->vn_user, (char *) NULL,
				vers_ts->options, file1);
    if (retcode != 0)
        fail = 1;
    else
d1332 1
a1332 1
        e = CVS_FOPEN (file1, "r");
d1334 7
a1340 11
	    fail = 1;
	else
	{
	    if (fseek (e, (long) -1, SEEK_END) == 0
		&& getc (e) != '\n')
	    {
	        fail = 1;
	    }
	    fclose (e);
	}
    }
d1342 1
a1342 7
    if (! fail)
    {
        /* Check it out into finfo->file, and then move to file2, so that we
           can get the right modes into *FILE_INFO.  We can't check it
           out directly into file2 because co doesn't understand how
           to do that.  */
	retcode = RCS_checkout (vers_ts->srcfile, finfo->file,
d1344 7
a1350 2
				vers_ts->options, RUN_TTY);
	if (retcode != 0)
d1353 1
a1353 46
	{
	    if (!isreadable (finfo->file))
	    {
	        /* File is dead.  */
	        fail = 1;
	    }
	    else
	    {
	        rename_file (finfo->file, file2);
		if (cvswrite == TRUE
		    && !fileattr_get (finfo->file, "_watched"))
		    xchmod (file2, 1);
		e = CVS_FOPEN (file2, "r");
		if (e == NULL)
		    fail = 1;
		else
		{
		    struct MD5Context context;
		    int nl;
		    unsigned char buf[8192];
		    unsigned len;

		    nl = 0;

		    /* Compute the MD5 checksum and make sure there is
                       a trailing newline.  */
		    MD5Init (&context);
		    while ((len = fread (buf, 1, sizeof buf, e)) != 0)
		    {
			nl = buf[len - 1] == '\n';
		        MD5Update (&context, buf, len);
		    }
		    MD5Final (checksum, &context);

		    if (ferror (e) || ! nl)
		    {
		        fail = 1;
		    }

		    fseek(e, 0L, SEEK_END);
		    file_size = ftell(e);

		    fclose (e);
		}
	    }
	}
d1382 13
d1437 2
a1438 2
	if ( CVS_STAT (file2, file_info) < 0)
	    error (1, errno, "could not stat %s", file2);
d1476 23
a1498 1
#endif
d1994 2
a1995 1
				(char *) NULL, RUN_TTY);
@


1.5
log
@Integrate local changes
@
text
@d44 1
d210 2
d215 1
d263 1
a263 1
		send_files (argc, argv, local, aflag, update_build_dirs);
d282 1
a282 1
			    aflag, update_build_dirs);
d291 17
a307 1
	    if (status != 0)
d309 1
d311 1
d792 1
a792 1
	    char tmp[PATH_MAX];
d794 1
d802 1
d843 2
d850 2
a851 1
	char line[MAXLINELEN];
d854 1
a854 1
	if (fgets (line, sizeof (line), fp) != NULL)
d867 9
a875 1
	(void) fclose (fp);
d1012 1
a1012 1
    char backup[PATH_MAX];
d1021 4
d1029 3
a1031 1
	    (void) unlink_file (backup);
d1177 6
a1182 1
	(void) unlink_file (backup);
d1200 3
a1202 3
    char backup[PATH_MAX];
    char file1[PATH_MAX];
    char file2[PATH_MAX];
d1217 4
d1226 5
a1230 1
    
d1232 4
d1429 3
d1471 1
a1471 1
    char backup[PATH_MAX];
d1474 1
d1483 4
d1518 4
a1521 2
	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
	return 0;
d1533 2
a1534 1
	return (1);
d1576 4
a1579 2
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
	return (0);
d1594 2
a1595 1
	error (1, errno, "fork failed while examining update of %s", finfo->fullname);
d1600 2
a1601 1
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
d1603 4
a1606 1
    return (0);
d1618 1
a1618 1
    char backup[PATH_MAX];
d1944 4
d2006 1
@


1.4
log
@Integrate local changes
@
text
@d37 1
a52 1
static int isemptydir PROTO((char *dir));
d259 1
a259 1
		send_files (argc, argv, local, aflag);
d268 1
a268 1
		if (toplevel_wd[0] != '\0'
d278 1
a278 1
			    aflag);
d542 3
a544 15
			/*
			 * If the timestamps differ, look for Conflict
			 * indicators to see if 'C' anyway.
			 */
			run_setup ("%s", GREP);
			run_arg (RCS_MERGE_PAT);
			run_arg (finfo->file);
			retcode = run_exec (RUN_TTY, DEVNULL,
					    RUN_TTY,RUN_NORMAL);
			if (retcode == -1)
			{
			    error (1, errno,
				"fork failed while examining conflict in `%s'",
				       finfo->fullname);
			}
d546 1
d832 4
a835 1
	    (void) printf ("%s %s: Executing '", program_name, command_name);
d837 1
a837 1
	    (void) printf ("'\n");
d849 1
a849 1
	if (update_prune_dirs && isemptydir (dir))
d863 3
a865 4
/*
 * Returns 1 if the argument directory is completely empty, other than the
 * existence of the CVS directory entry.  Zero otherwise.
 */
d867 16
a882 1
isemptydir (dir)
d884 1
d891 3
a893 1
	error (0, 0, "cannot open directory %s for empty check", dir);
d896 1
d899 2
a900 2
	if (strcmp (dp->d_name, ".") != 0 && strcmp (dp->d_name, "..") != 0 &&
	    strcmp (dp->d_name, CVSADM) != 0)
d902 39
a940 2
	    (void) closedir (dirp);
	    return (0);
d942 7
d1004 11
a1014 6
		(void) fprintf (stderr, "\
===================================================================\n");
		(void) fprintf (stderr, "Checking out %s\n", finfo->fullname);
		(void) fprintf (stderr, "RCS:  %s\n", vers_ts->srcfile->path);
		(void) fprintf (stderr, "VERS: %s\n", vers_ts->vn_rcs);
		(void) fprintf (stderr, "***************\n");
@


1.3
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d44 2
a45 2
static int checkout_file PROTO((char *file, char *repository, List *entries,
			  RCSNode *rcsnode, Vers_TS *vers_ts, char *update_dir));
d47 4
a50 4
static int patch_file PROTO((char *file, char *repository, List *entries,
		       RCSNode*rcsnode, Vers_TS *vers_ts, char *update_dir,
		       int *docheckout, struct stat *file_info,
		       unsigned char *checksum));
d53 12
a64 9
static int merge_file PROTO((char *file, char *repository, List *entries,
		       Vers_TS *vers, char *update_dir));
static int scratch_file PROTO((char *file, char *repository, List * entries,
			 char *update_dir));
static Dtype update_dirent_proc PROTO((char *dir, char *repository, char *update_dir));
static int update_dirleave_proc PROTO((char *dir, int err, char *update_dir));
static int update_fileproc PROTO ((struct file_info *));
static int update_filesdone_proc PROTO((int err, char *repository,
					char *update_dir));
d67 1
a67 2
static void join_file PROTO((char *file, RCSNode *rcsnode, Vers_TS *vers_ts,
		       char *update_dir, List *entries, char *repository));
d69 1
a69 2
static void join_file PROTO((char *file, RCSNode *rcsnode, Vers_TS *vers_ts,
		       char *update_dir, List *entries));
d97 1
a97 1
    "\t-p\tSend updates to standard output.\n",
d99 2
a100 2
    "\t-r rev\tUpdate using specified revision/tag.\n",
    "\t-D date\tSet date to update from.\n",
d232 2
d240 1
d247 7
a253 13
		struct request *rq;

		for (rq = requests; rq->name != NULL; rq++)
		{
		    if (strcmp (rq->name, "update-patches") == 0)
		    {
			if (rq->status == rq_supported)
			{
			    send_arg("-u");
			}
			break;
		    }
		}
d269 1
a269 1
		    && chdir (toplevel_wd) < 0)
d298 4
a301 2
    /* FIXME: We don't call tag_check_valid on join_rev1 and join_rev2
       yet (make sure to handle ':' correctly if we do, though).  */
d405 1
a405 1
			   update_dirent_proc, update_dirleave_proc,
d407 1
a407 1
			   preload_update_dir, 1, 0);
d434 2
a435 1
update_fileproc (finfo)
d441 1
d443 4
a446 3
    status = Classify_File (finfo->file, tag, date, options, force_tag_match,
			    aflag, finfo->repository, finfo->entries, finfo->rcs, &vers,
			    finfo->update_dir, pipeout);
d475 1
a475 2
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
					vers, finfo->update_dir);
d509 2
a510 2
			retval = checkout_file (finfo->file, finfo->repository, finfo->entries,
						finfo->rcs, vers, finfo->update_dir);
d512 1
a512 2
			retval = merge_file (finfo->file, finfo->repository, finfo->entries,
					     vers, finfo->update_dir);
d582 2
a583 2
		    retval = patch_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
					 vers, finfo->update_dir, &docheckout,
d588 1
a588 1
			    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d601 1
a601 2
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
					vers, finfo->update_dir);
d604 1
a604 1
		    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d616 1
a616 1
		retval = scratch_file (finfo->file, finfo->repository, finfo->entries, finfo->update_dir);
d619 4
a622 1
		    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d625 1
d638 1
a638 5
#ifdef SERVER_SUPPORT
	join_file (finfo->file, finfo->rcs, vers, finfo->update_dir, finfo->entries, finfo->repository);
#else
	join_file (finfo->file, finfo->rcs, vers, finfo->update_dir, finfo->entries);
#endif
d668 2
a669 1
update_filesdone_proc (err, repository, update_dir)
d673 1
d678 1
a678 1
	ignore_files (ignlist, update_dir, update_ignproc);
d699 1
a699 1
	    Create_Root( (char *) NULL, CVSroot );
d714 2
a715 1
update_dirent_proc (dir, repository, update_dir)
d719 1
d722 1
a722 1
      {
d727 1
a727 1
      }
d746 1
d820 2
a821 1
update_dirleave_proc (dir, err, update_dir)
d825 1
d831 1
a831 1
	(fp = fopen (CVSADM_UPROG, "r")) != NULL)
d852 1
a852 4
    /* FIXME: chdir ("..") loses with symlinks.  */
    /* Prune empty dirs on the way out - if necessary */
    (void) chdir ("..");
    if (update_prune_dirs && isemptydir (dir))
d854 12
a865 5
	/* I'm not sure the existence_error is actually possible (except
	   in cases where we really should print a message), but since
	   this code used to ignore all errors, I'll play it safe.  */
	if (unlink_file_dir (dir) < 0 && !existence_error (errno))
	    error (0, errno, "cannot remove %s directory", dir);
d882 1
a882 1
    if ((dirp = opendir (dir)) == NULL)
d904 2
a905 5
scratch_file (file, repository, entries, update_dir)
    char *file;
    char *repository;
    List *entries;
    char *update_dir;
d907 4
a910 3
    history_write ('W', update_dir, "", file, repository);
    Scratch_Entry (entries, file);
    (void) unlink_file (file);
d915 1
a915 1
 * check out a file - essentially returns the result of the fork on "co".
d918 2
a919 5
checkout_file (file, repository, entries, rcsnode, vers_ts, update_dir)
    char *file;
    char *repository;
    List *entries;
    RCSNode *rcsnode;
d921 1
a921 1
    char *update_dir;
d932 3
a934 3
	(void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, file);
	if (isfile (file))
	    rename_file (file, backup);
d952 1
a952 5
		if (update_dir[0])
		    (void) fprintf (stderr, "Checking out %s/%s\n",
				    update_dir, file);
		else
		    (void) fprintf (stderr, "Checking out %s\n", file);
d959 4
a962 3
	status = RCS_checkout (vers_ts->srcfile->path,
			       pipeout ? NULL : file, vers_ts->vn_tag,
			       vers_ts->options, RUN_TTY, 0, 0);
a968 42
	    int resurrecting;

	    resurrecting = 0;

	    if (file_is_dead && joining())
	    {
		if (RCS_getversion (vers_ts->srcfile, join_rev1,
				    date_rev1, 1, 0)
		    || (join_rev2 != NULL && 
			RCS_getversion (vers_ts->srcfile, join_rev2,
					date_rev2, 1, 0)))
		{
		    /* when joining, we need to get dead files checked
		       out.  Try harder.  */
		    /* I think that RCS_FLAGS_FORCE is here only because
		       passing -f to co used to enable checking out
		       a dead revision in the old version of death
		       support which used a hacked RCS instead of using
		       the RCS state.  */
		    retcode = RCS_checkout (vers_ts->srcfile->path, file,
		                            vers_ts->vn_rcs,
		                            vers_ts->options, RUN_TTY,
		                            RCS_FLAGS_FORCE, 0);
		    if (retcode != 0)
		    {
			error (retcode == -1 ? 1 : 0,
			       retcode == -1 ? errno : 0,
			       "could not check out %s", file);
			(void) unlink_file (backup);
			return (retcode);
		    }
		    file_is_dead = 0;
		    resurrecting = 1;
		}
		else
		{
		    /* If the file is dead and does not contain either of
		       the join revisions, then we don't want to check it
		       out. */
		    return 0;
		}
	    }
d972 2
a973 2
		&& !fileattr_get (file, "_watched"))
		xchmod (file, 1);
d984 1
a984 1
		editor_set (file, getcaller (), NULL);
d988 1
a988 1
		watch_modify_watchers (file, &args);
d1000 1
a1000 1
	    wrap_fromcvs_process_file (file);
d1002 2
a1003 2
	    xvers_ts = Version_TS (repository, options, tag, date, file,
			      force_tag_match, set_time, entries, rcsnode);
d1013 3
a1015 8
		    if (update_dir[0] == '\0')
			error (0, 0,
			       "warning: %s is not (any longer) pertinent",
			       file);
		    else
			error (0, 0,
			       "warning: %s/%s is not (any longer) pertinent",
			       update_dir, file);
d1017 11
a1027 2
		Scratch_Entry (entries, file);
		if (unlink_file (file) < 0 && ! existence_error (errno))
d1029 1
a1029 5
		    if (update_dir[0] == '\0')
			error (0, errno, "cannot remove %s", file);
		    else
			error (0, errno, "cannot remove %s/%s", update_dir,
			       file);
d1033 5
a1037 5
	      Register (entries, file,
			resurrecting ? "0" : xvers_ts->vn_rcs,
			xvers_ts->ts_user, xvers_ts->options,
			xvers_ts->tag, xvers_ts->date,
			(char *)0); /* Clear conflict flag on fresh checkout */
d1052 2
a1053 2
		history_write ('U', update_dir, xvers_ts->vn_rcs, file,
			       repository);
d1059 1
a1059 1
		write_letter (file, 'U', update_dir);
d1068 1
a1068 1
	    rename_file (backup, file);
d1071 1
a1071 1
	       "could not check out %s", file);
d1088 2
a1089 6
patch_file (file, repository, entries, rcsnode, vers_ts, update_dir,
	    docheckout, file_info, checksum)
    char *file;
    char *repository;
    List *entries;
    RCSNode *rcsnode;
a1090 1
    char *update_dir;
d1112 3
a1114 3
    (void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, file);
    if (isfile (file))
        rename_file (file, backup);
d1118 2
a1119 2
    (void) sprintf (file1, "%s/%s%s-1", CVSADM, CVSPREFIX, file);
    (void) sprintf (file2, "%s/%s%s-2", CVSADM, CVSPREFIX, file);
d1129 3
a1131 3
	retcode = RCS_checkout (vers_ts->srcfile->path, NULL,
	                        vers_ts->vn_user,
	                        vers_ts->options, file1, 0, 0);
d1136 1
a1136 1
        e = fopen (file1, "r");
d1152 1
a1152 1
        /* Check it out into file, and then move to file2, so that we
d1156 3
a1158 3
	retcode = RCS_checkout (vers_ts->srcfile->path, file,
	                        vers_ts->vn_rcs,
	                        vers_ts->options, RUN_TTY, 0, 0);
d1163 1
a1163 1
	    if (!isreadable (file))
d1170 1
a1170 1
	        rename_file (file, file2);
d1172 1
a1172 1
		    && !fileattr_get (file, "_watched"))
d1174 1
a1174 1
		e = fopen (file2, "r");
d1225 1
a1225 1
	if ((retcode = run_exec (RUN_TTY, file, RUN_TTY, RUN_NORMAL)) != 0
d1237 1
a1237 1
	    e = fopen (file, "r");
d1239 2
a1240 1
		error (1, errno, "could not open diff output file %s", file);
d1269 2
a1270 2
        xvers_ts = Version_TS (repository, options, tag, date, file,
			       force_tag_match, 0, entries, rcsnode);
d1274 1
a1274 1
	Register (entries, file, xvers_ts->vn_rcs,
d1278 1
a1278 1
	if (stat (file2, file_info) < 0)
d1283 2
a1284 2
	    history_write ('P', update_dir, xvers_ts->vn_rcs, file,
			   repository);
d1290 1
a1290 1
	    write_letter (file, 'P', update_dir);
d1298 1
a1298 1
	    rename_file (backup, file);
d1302 1
a1302 1
		   "could not diff %s", file);
d1347 2
a1348 4
merge_file (file, repository, entries, vers, update_dir)
    char *file;
    char *repository;
    List *entries;
a1349 1
    char *update_dir;
a1350 1
    char user[PATH_MAX];
d1362 1
a1362 5
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, file, vers->vn_user);
    if (update_dir[0])
	(void) sprintf (user, "%s/%s", update_dir, file);
    else
	(void) strcpy (user, file);
d1365 31
a1395 2
    copy_file (file, backup);
    xchmod (file, 1);
d1402 1
a1402 1
	       "could not merge revision %s of %s", vers->vn_user, user);
d1404 2
a1405 2
	       user, backup);
	rename_file (backup, file);
d1416 2
a1417 2
	    cp = time_stamp (file);
	Register (entries, file, vers->vn_rcs, vers->ts_rcs, vers->options,
d1437 3
a1439 2
        server_copy_file (file, update_dir, repository, backup);
	server_updated (file, update_dir, repository, SERVER_MERGED,
d1444 1
a1444 1
    if (!noexec && !xcmp (backup, file))
d1447 2
a1448 2
		user, vers->vn_user, vers->vn_rcs);
	history_write ('G', update_dir, vers->vn_rcs, file, repository);
d1455 1
a1455 1
	    error (0, 0, "conflicts found in %s", user);
d1457 1
a1457 1
	write_letter (file, 'C', update_dir);
d1459 1
a1459 1
	history_write ('C', update_dir, vers->vn_rcs, file, repository);
d1464 1
a1464 1
	error (1, errno, "fork failed while examining update of %s", user);
d1468 2
a1469 2
	write_letter (file, 'M', update_dir);
	history_write ('G', update_dir, vers->vn_rcs, file, repository);
d1479 2
a1480 8
#ifdef SERVER_SUPPORT
join_file (file, rcsnode, vers, update_dir, entries, repository)
    char *repository;
#else
join_file (file, rcsnode, vers, update_dir, entries)
#endif
    char *file;
    RCSNode *rcsnode;
a1481 2
    char *update_dir;
    List *entries;
a1482 1
    char user[PATH_MAX];
d1499 1
a1499 1
    if (wrap_merge_is_copy (file))
a1500 1
	/* FIXME: Should be including update_dir in message.  */
d1502 2
a1503 1
	       "Cannot merge %s because it is a merge-by-copy file.", file);
d1507 1
a1507 1
    /* determine if we need to do anything at all */
d1514 2
a1515 3
    /* in all cases, use two revs. */

    /* if only one rev is specified, it becomes the second rev */
d1524 10
a1533 5
    /* The file in the working directory doesn't exist in CVS/Entries.
       FIXME: Shouldn't this case result in additional processing (if
       the file was added going from rev1 to rev2, then do the equivalent
       of a "cvs add")?  (yes; easier said than done.. :-) */
    if (vers->vn_user == NULL)
d1535 13
a1547 5
	/* No merge possible YET. */
	if (jdate2 != NULL)
	    error (0, 0,
		   "file %s is present in revision %s as of %s",
		   file, jrev2, jdate2);
d1549 1
a1549 4
	    error (0, 0,
		   "file %s is present in revision %s",
		   file, jrev2);
	return;
d1552 2
a1553 4
    /* Fix for bug CVS/193:
     * Used to dump core if the file had been removed on the current branch.
     */
    if (strcmp(vers->vn_user, "0") == 0)
d1555 79
a1633 5
        error(0, 0,
              "file %s has been deleted",
              file);
        return;
    }
d1635 2
a1636 1
    /* convert the second rev spec, walking branches and dates. */
d1638 6
a1643 4
    rev2 = RCS_getversion (vers->srcfile, jrev2, jdate2, 1, 0);
    if (rev2 == NULL)
    {
	if (!quiet)
d1647 2
a1648 2
		       "cannot find revision %s as of %s in file %s",
		       jrev2, jdate2, file);
d1651 10
a1660 2
		       "cannot find revision %s in file %s",
		       jrev2, file);
d1662 35
d1700 3
a1702 2
    /* skip joining identical revs */
    if (strcmp (rev2, vers->vn_user) == 0)
d1704 2
a1705 1
	/* No merge necessary.  */
d1710 3
a1712 1
    if (jrev1 == NULL)
d1714 8
a1721 10
	char *tst;
	/* if the first rev is missing, then it is implied to be the
	   greatest common ancestor of both the join rev, and the
	   checked out rev. */
	
	/* FIXME: What is this check for '!' about?  If it is legal to
	   have '!' in the first character of vn_user, it isn't
	   documented at struct vers_ts in cvs.h.  */
	tst = vers->vn_user;
	if (*tst == '!')
d1723 7
a1729 13
	    /* file was dead.  merge anyway and pretend it's been
	       added. */
	    ++tst;
	    Register (entries, file, "0", vers->ts_user, vers->options,
		      vers->tag, (char *) 0, (char *) 0);
	}
	rev1 = gca (tst, rev2);
	if (rev1 == NULL)
	{
	    /* this should not be possible */
	    error (0, 0, "bad gca");
	    abort();
	}
d1731 6
a1736 7
	tst = RCS_gettag (vers->srcfile, rev2, 1, 0);
	if (tst == NULL)
	{
	    /* this should not be possible. */
	    error (0, 0, "cannot find gca");
	    abort();
	}
d1738 1
a1738 1
	free (tst);
a1739 5
	/* these two cases are noops */
	if (strcmp (rev1, rev2) == 0)
	{
	    free (rev1);
	    free (rev2);
d1742 15
d1758 4
a1761 1
    else
d1763 3
a1765 18
	/* otherwise, convert the first rev spec, walking branches and
	   dates.  */

	rev1 = RCS_getversion (vers->srcfile, jrev1, jdate1, 1, 0);
	if (rev1 == NULL)
	{
	  if (!quiet) {
	    if (jdate1 != NULL)
		error (0, 0,
		       "cannot find revision %s as of %s in file %s",
		       jrev1, jdate1, file);
	    else
		error (0, 0,
		       "cannot find revision %s in file %s",
		       jrev1, file);
	  }
	  return;
	}
d1768 5
a1772 1
    /* do the join */
d1774 4
a1777 40
#if 0
    dome {
	/* special handling when two revisions are specified */
	if (join_rev1 && join_rev2)
	{
	    rev = RCS_getversion (vers->srcfile, join_rev2, date_rev2, 1, 0);
	    if (rev == NULL)
	    {
		if (!quiet && date_rev2 == NULL)
		    error (0, 0,
			   "cannot find revision %s in file %s", join_rev2, file);
		return;
	    }
	    
	    baserev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1, 0);
	    if (baserev == NULL)
	    {
		if (!quiet && date_rev1 == NULL)
		    error (0, 0,
			   "cannot find revision %s in file %s", join_rev1, file);
		free (rev);
		return;
	    }
	    
	    /*
	     * nothing to do if:
	     *	second revision matches our BASE revision (vn_user) &&
	     *	both revisions are on the same branch
	     */
	    if (strcmp (vers->vn_user, rev) == 0 &&
		numdots (baserev) == numdots (rev))
	    {
		/* might be the same branch.  take a real look */
		char *dot = strrchr (baserev, '.');
		int len = (dot - baserev) + 1;
		
		if (strncmp (baserev, rev, len) == 0)
		    return;
	    }
	}
d1779 7
a1785 32
	{
	    rev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1, 0);
	    if (rev == NULL)
		return;
	    if (strcmp (rev, vers->vn_user) == 0) /* no merge necessary */
	    {
		free (rev);
		return;
	    }
	    
	    baserev = RCS_whatbranch (file, join_rev1, rcsnode);
	    if (baserev)
	    {
		char *cp;
		
		/* we get a branch -- turn it into a revision, or NULL if trunk */
		if ((cp = strrchr (baserev, '.')) == NULL)
		{
		    free (baserev);
		    baserev = (char *) NULL;
		}
		else
		    *cp = '\0';
	    }
	}
	if (baserev && strcmp (baserev, rev) == 0)
	{
	    /* they match -> nothing to do */
	    free (rev);
	    free (baserev);
	    return;
	}
a1786 3
#endif

    /* OK, so we have two revisions; continue on */
d1789 1
a1789 1
    if (server_active && !isreadable (file))
d1793 3
a1795 2
	retcode = RCS_checkout (vers->srcfile->path, "", vers->vn_user, NULL,
	                        RUN_TTY, 0, 0);
d1798 1
a1798 1
		   "failed to check out %s file", file);
d1809 1
a1809 5
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, file, vers->vn_user);
    if (update_dir[0])
	(void) sprintf (user, "%s/%s", update_dir, file);
    else
	(void) strcpy (user, file);
d1812 2
a1813 2
    copy_file (file, backup);
    xchmod (file, 1);
d1827 1
a1827 1
	       "could not merge revision %s of %s", rev2, user);
d1829 2
a1830 2
	       user, backup);
	rename_file (backup, file);
d1850 3
a1852 2
	    cp = time_stamp (file);
	Register (entries, file, vers->vn_rcs, vers->ts_rcs, vers->options,
d1861 3
a1863 2
	server_copy_file (file, update_dir, repository, backup);
	server_updated (file, update_dir, repository, SERVER_MERGED,
@


1.2
log
@Don't use the result of "diff" if just sending the new file would be shorter
@
text
@d45 1
a45 1
			  List *srcfiles, Vers_TS *vers_ts, char *update_dir));
d48 1
a48 1
		       List *srcfiles, Vers_TS *vers_ts, char *update_dir,
d64 1
a64 1
static void join_file PROTO((char *file, List *srcfiles, Vers_TS *vers_ts,
d67 1
a67 1
static void join_file PROTO((char *file, List *srcfiles, Vers_TS *vers_ts,
d260 1
a260 1
		send_file_names (argc, argv);
d278 1
a278 1
		send_file_names (failed_patches_count, failed_patches);
d442 1
a442 1
			    aflag, finfo->repository, finfo->entries, finfo->srcfiles, &vers,
d472 1
a472 1
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
d508 1
a508 1
						finfo->srcfiles, vers, finfo->update_dir);
d552 1
a552 2
			    if (finfo->update_dir[0] == '\0')
				error (1, errno,
d554 1
a554 5
				       finfo->file);
			    else
				error (1, errno,
			     "fork failed while examining conflict in `%s/%s'",
				       finfo->update_dir, finfo->file);
d581 1
a581 1
		    retval = patch_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
d600 1
a600 1
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
d635 1
a635 1
	join_file (finfo->file, finfo->srcfiles, vers, finfo->update_dir, finfo->entries, finfo->repository);
d637 1
a637 1
	join_file (finfo->file, finfo->srcfiles, vers, finfo->update_dir, finfo->entries);
d744 2
a745 1
    else
d909 1
a909 1
checkout_file (file, repository, entries, srcfiles, vers_ts, update_dir)
d913 1
a913 1
    List *srcfiles;
d1042 1
a1042 1
			      force_tag_match, set_time, entries, srcfiles);
a1044 14
	    /* If no keyword expansion was specified on command line,
	       use whatever was in the file.  This is how we tell the client
	       whether a file is binary.  */
	    if (xvers_ts->options[0] == '\0')
	    {
		if (vers_ts->srcfile->expand != NULL)
		{
		    free (xvers_ts->options);
		    xvers_ts->options =
			xmalloc (strlen (vers_ts->srcfile->expand) + 3);
		    strcpy (xvers_ts->options, "-k");
		    strcat (xvers_ts->options, vers_ts->srcfile->expand);
		}
	    }
d1127 1
a1127 1
patch_file (file, repository, entries, srcfiles, vers_ts, update_dir,
d1132 1
a1132 1
    List *srcfiles;
d1313 1
a1313 1
			       force_tag_match, 0, entries, srcfiles);
d1501 1
a1501 1
join_file (file, srcfiles, vers, update_dir, entries, repository)
d1504 1
a1504 1
join_file (file, srcfiles, vers, update_dir, entries)
d1507 1
a1507 1
    List *srcfiles;
d1731 1
a1731 1
	    baserev = RCS_whatbranch (file, join_rev1, srcfiles);
@


1.1
log
@Initial revision
@
text
@a36 3
#ifdef CLIENT_SUPPORT
#include "update.h"
#endif
d40 3
a42 5

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)update.c 1.95 94/10/22 $";
USE(rcsid);
#endif
d59 3
a61 5
static int update_file_proc PROTO((char *file, char *update_dir, char *repository,
			     List * entries, List * srcfiles));
#ifndef CLIENT_SUPPORT
static int update_filesdone_proc PROTO((int err, char *repository, char *update_dir));
#endif
a62 1
static void ignore_files PROTO((List * ilist, char *update_dir));
a83 3
#ifdef CLIENT_SUPPORT
List *ignlist = (List *) NULL;
#else
a84 1
#endif
a216 2
	    ign_setup ();

d259 2
d262 1
d278 1
d286 1
a286 2
	    if (fprintf (to_server, "update\n") < 0)
		error (1, errno, "writing to server");
d298 5
d312 1
a312 1
	    if (unlink_file (CVSADM_ENTSTAT) < 0 && errno != ENOENT)
d404 1
a404 1
    err = start_recursion (update_file_proc, update_filesdone_proc,
d434 2
a435 6
update_file_proc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d441 3
a443 3
    status = Classify_File (file, tag, date, options, force_tag_match,
			    aflag, repository, entries, srcfiles, &vers,
			    update_dir, pipeout);
d472 2
a473 2
		retval = checkout_file (file, repository, entries, srcfiles,
					vers, update_dir);
d478 1
a478 1
		       "unknown file status %d for file %s", status, file);
d494 1
a494 1
		(void) write_letter (file, 'C', update_dir);
d500 1
a500 1
		    (void) write_letter (file, 'C', update_dir);
d504 1
a504 1
		    if (wrap_merge_is_copy (file))
d507 2
a508 2
			retval = checkout_file (file, repository, entries,
						srcfiles, vers, update_dir);
d510 2
a511 2
			retval = merge_file (file, repository, entries,
					     vers, update_dir);
d529 1
a529 1
			filestamp = time_stamp (file);
d534 1
a534 1
		    filestamp = time_stamp (file);
d545 1
a545 1
			run_setup ("%s -s", GREP);
d547 2
a548 2
			run_arg (file);
			retcode = run_exec (RUN_TTY, RUN_TTY,
d552 1
a552 1
			    if (update_dir[0] == '\0')
d555 1
a555 1
				       file);
d559 1
a559 1
				       update_dir, file);
d564 1
a564 1
			(void) write_letter (file, 'C', update_dir);
d570 1
a570 1
			Register (entries, file, vers->vn_rcs, vers->ts_rcs,
d576 1
a576 1
		    retval = write_letter (file, 'M', update_dir);
d586 2
a587 2
		    retval = patch_file (file, repository, entries, srcfiles,
					 vers, update_dir, &docheckout,
d592 1
a592 1
			    server_updated (file, update_dir, repository,
d605 2
a606 2
		retval = checkout_file (file, repository, entries, srcfiles,
					vers, update_dir);
d609 1
a609 1
		    server_updated (file, update_dir, repository,
d615 1
a615 1
		retval = write_letter (file, 'A', update_dir);
d618 1
a618 1
		retval = write_letter (file, 'R', update_dir);
d621 1
a621 1
		retval = scratch_file (file, repository, entries, update_dir);
d624 1
a624 1
		    server_updated (file, update_dir, repository,
d631 1
a631 1
		       "unknown file status %d for file %s", status, file);
d640 1
a640 1
	join_file (file, srcfiles, vers, update_dir, entries, repository);
d642 1
a642 1
	join_file (file, srcfiles, vers, update_dir, entries);
d652 1
a652 1
	p->key = xstrdup (file);
d661 10
a670 3
/*
 * update_filesdone_proc () is used
 */
a671 4
#ifdef CLIENT_SUPPORT
/* Also used by client.c  */
int
#else
a672 1
#endif
d681 1
a681 1
	ignore_files (ignlist, update_dir);
a685 6
#ifdef CLIENT_SUPPORT
    /* In the client, we need to clean these up after we create them.  Doing
       it here might would clean up the user's previous contents even on
       SIGINT which probably is bad.  */
    if (!client_active && strcmp (command_name, "export") == 0)
#else
a686 1
#endif
d688 5
a692 3
	run_setup ("%s -fr", RM);
	run_arg (CVSADM);
	(void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
a693 1
#ifdef CVSADM_ROOT
a700 6
#ifdef CLIENT_SUPPORT
        if (!isfile (CVSADM_ROOT)
	    /* but only if we want it */
	    && ! (getenv ("CVS_IGNORE_REMOTE_ROOT") && strchr (CVSroot, ':'))
	    )
#else /* No CLIENT_SUPPORT */
a701 1
#endif /* No CLIENT_SUPPORT */
a703 1
#endif /* CVSADM_ROOT */
d749 22
d783 1
a783 1
	    if (unlink_file (tmp) < 0 && errno != ENOENT)
d849 1
d854 5
a858 3
	run_setup ("%s -fr", RM);
	run_arg (dir);
	(void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d924 1
a924 1
#ifdef DEATH_SUPPORT
a925 1
#endif
a936 1
#ifdef DEATH_SUPPORT
d939 1
a939 11
    if (!file_is_dead) {
#endif
    
    run_setup ("%s%s -q -r%s %s", Rcsbin, RCS_CO, vers_ts->vn_rcs,
	       vers_ts->options);

    /*
     * if we are checking out to stdout, print a nice message to stderr, and
     * add the -p flag to the command
     */
    if (pipeout)
d941 4
a944 2
	run_arg ("-p");
	if (!quiet)
d946 13
a958 9
	    (void) fprintf (stderr, "===================================================================\n");
	    if (update_dir[0])
		(void) fprintf (stderr, "Checking out %s/%s\n",
				update_dir, file);
	    else
		(void) fprintf (stderr, "Checking out %s\n", file);
	    (void) fprintf (stderr, "RCS:  %s\n", vers_ts->srcfile->path);
	    (void) fprintf (stderr, "VERS: %s\n", vers_ts->vn_rcs);
	    (void) fprintf (stderr, "***************\n");
a959 6
    }

    /* tack on the rcs and maybe the user file */
    run_arg (vers_ts->srcfile->path);
    if (!pipeout)
	run_arg (file);
d961 3
a963 1
#ifdef DEATH_SUPPORT
d965 1
a965 5
    if (file_is_dead || (retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
#else
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
#endif
        (pipeout ? (RUN_NORMAL|RUN_REALLY) : RUN_NORMAL))) == 0)
a969 1
#ifdef DEATH_SUPPORT
d976 29
a1004 9
		/* when joining, we need to get dead files checked
		   out.  Try harder.  */
		run_setup ("%s%s -q -r%s %s", Rcsbin, RCS_CO, vers_ts->vn_rcs,
			   vers_ts->options);
		
		run_arg ("-f");
		run_arg (vers_ts->srcfile->path);
		run_arg (file);
		if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
d1006 4
a1009 4
		    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
			   "could not check out %s", file);
		    (void) unlink_file (backup);
		    return (retcode);
a1010 2
		file_is_dead = 0;
		resurrecting = 1;
d1013 3
a1015 1
	    if (cvswrite == TRUE && !file_is_dead)
d1017 16
a1032 4
#else /* No DEATH_SUPPORT */
	    if (cvswrite == TRUE)
		xchmod (file, 1);
#endif /* No DEATH_SUPPORT */
d1049 14
a1065 1
#ifdef DEATH_SUPPORT
d1080 1
a1080 1
		if (unlink_file (file) < 0 && errno != ENOENT)
a1094 5
#else /* No DEATH_SUPPORT */
	    Register (entries, file, xvers_ts->vn_rcs, xvers_ts->ts_user,
		      xvers_ts->options, xvers_ts->tag, xvers_ts->date,
		      (char *)0);  /* Clear conflict flag on fresh checkout */
#endif /* No DEATH_SUPPORT */
a1113 1
#ifdef DEATH_SUPPORT
a1114 3
#else
	    if (!really_quiet)
#endif
d1116 1
a1116 4
		if (update_dir[0])
		    (void) printf ("U %s/%s\n", update_dir, file);
		else
		    (void) printf ("U %s\n", file);
d1163 1
d1188 7
a1194 3
    run_setup ("%s%s -q -p -r%s %s %s", Rcsbin, RCS_CO, vers_ts->vn_user,
	       vers_ts->options, vers_ts->srcfile->path);
    if (run_exec (RUN_TTY, file1, RUN_TTY, RUN_NORMAL) != 0)
d1218 4
a1221 3
        run_setup ("%s%s -q -r%s %s %s %s", Rcsbin, RCS_CO, vers_ts->vn_rcs,
		   vers_ts->options, vers_ts->srcfile->path, file);
	if (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL) != 0)
d1233 2
a1234 1
		if (cvswrite == TRUE)
d1263 3
d1272 1
d1310 10
d1351 1
a1351 4
	    if (update_dir[0])
	      (void) printf ("P %s/%s\n", update_dir, file);
	    else
	      (void) printf ("P %s\n", file);
d1389 4
d1394 6
a1399 3
	    (void) printf ("%c %s/%s\n", letter, update_dir, file);
	else
	    (void) printf ("%c %s\n", letter, file);
d1496 1
a1496 2
	if (!really_quiet)
	    (void) printf ("C %s\n", user);
d1507 1
a1507 2
	if (!really_quiet)
	    (void) printf ("M %s\n", user);
d1591 11
d1604 1
a1604 1
    rev2 = RCS_getversion (vers->srcfile, jrev2, jdate2, 1);
d1656 1
a1656 1
	tst = RCS_gettag (vers->srcfile, rev2, 1);
d1679 1
a1679 1
	rev1 = RCS_getversion (vers->srcfile, jrev1, jdate1, 1);
d1703 1
a1703 1
	    rev = RCS_getversion (vers->srcfile, join_rev2, date_rev2, 1);
d1712 1
a1712 1
	    baserev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1);
d1740 1
a1740 1
	    rev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1);
d1781 2
a1782 3
	run_setup ("%s%s -q -r%s", Rcsbin, RCS_CO, vers->vn_user);
	run_arg (vers->srcfile->path);
	retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d1826 9
d1836 1
a1855 74
}

/*
 * Process the current directory, looking for files not in ILIST and not on
 * the global ignore list for this directory.
 */
static void
ignore_files (ilist, update_dir)
    List *ilist;
    char *update_dir;
{
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    char *file;
    char *xdir;

    /* we get called with update_dir set to "." sometimes... strip it */
    if (strcmp (update_dir, ".") == 0)
	xdir = "";
    else
	xdir = update_dir;

    dirp = opendir (".");
    if (dirp == NULL)
	return;

    ign_add_file (CVSDOTIGNORE, 1);
    wrap_add_file (CVSDOTWRAPPER, 1);

    while ((dp = readdir (dirp)) != NULL)
    {
	file = dp->d_name;
	if (strcmp (file, ".") == 0 || strcmp (file, "..") == 0)
	    continue;
	if (findnode (ilist, file) != NULL)
	    continue;

	if (
#ifdef DT_DIR
		dp->d_type != DT_UNKNOWN ||
#endif
		lstat(file, &sb) != -1) 
	{

	    if (
#ifdef DT_DIR
		dp->d_type == DT_DIR || dp->d_type == DT_UNKNOWN &&
#endif
		S_ISDIR(sb.st_mode))
	    {
		char temp[PATH_MAX];

		(void) sprintf (temp, "%s/%s", file, CVSADM);
		if (isdir (temp))
		    continue;
	    }
#ifdef S_ISLNK
	    else if (
#ifdef DT_DIR
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN && 
#endif
		S_ISLNK(sb.st_mode))
	    {
		continue;
	    }
#endif
    	}
	
	if (ign_name (file))
	    continue;
	(void) write_letter (file, '?', xdir);
    }
    (void) closedir (dirp);
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d37 3
a42 3
#include "watch.h"
#include "fileattr.h"
#include "edit.h"
d66 3
a68 2
static int update_filesdone_proc PROTO((int err, char *repository,
					char *update_dir));
d70 1
d92 3
d96 1
d229 2
a272 2
	    {
		send_file_names (argc, argv);
a273 1
	    }
a288 1
		send_file_names (failed_patches_count, failed_patches);
d296 2
a297 1
	    send_to_server ("update\012", 0);
a308 5
    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, aflag, "");
    /* FIXME: We don't call tag_check_valid on join_rev1 and join_rev2
       yet (make sure to handle ':' correctly if we do, though).  */

d318 1
a318 1
	    if (unlink_file (CVSADM_ENTSTAT) < 0 && ! existence_error (errno))
d555 1
a555 1
			run_setup ("%s", GREP);
d558 1
a558 1
			retcode = run_exec (RUN_TTY, DEVNULL,
d671 3
a673 10
static void update_ignproc PROTO ((char *, char *));

static void
update_ignproc (file, dir)
    char *file;
    char *dir;
{
    (void) write_letter (file, '?', dir);
}

d675 4
d680 1
d689 1
a689 1
	ignore_files (ignlist, update_dir, update_ignproc);
d694 6
d701 1
d715 6
d722 1
d783 1
a783 1
	    if (unlink_file (tmp) < 0 && ! existence_error (errno))
a848 1
    /* FIXME: chdir ("..") loses with symlinks.  */
d941 1
a941 1
    run_setup ("%s%s -q -r%s %s", Rcsbin, RCS_CO, vers_ts->vn_tag,
d988 9
a996 28
		if (RCS_getversion (vers_ts->srcfile, join_rev1,
				    date_rev1, 1, 0)
		    || (join_rev2 != NULL && 
			RCS_getversion (vers_ts->srcfile, join_rev2,
					date_rev2, 1, 0)))
		{
		    /* when joining, we need to get dead files checked
		       out.  Try harder.  */
		    run_setup ("%s%s -q -r%s %s", Rcsbin, RCS_CO,
			       vers_ts->vn_rcs,
			       vers_ts->options);

		    run_arg ("-f");
		    run_arg (vers_ts->srcfile->path);
		    run_arg (file);
		    retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		    if (retcode != 0)
		    {
			error (retcode == -1 ? 1 : 0,
			       retcode == -1 ? errno : 0,
			       "could not check out %s", file);
			(void) unlink_file (backup);
			return (retcode);
		    }
		    file_is_dead = 0;
		    resurrecting = 1;
		}
		else
d998 4
a1001 4
		    /* If the file is dead and does not contain either of
		       the join revisions, then we don't want to check it
		       out. */
		    return 0;
d1003 2
a1005 1
#endif /* DEATH_SUPPORT */
d1007 4
a1010 5
	    if (cvswrite == TRUE
#ifdef DEATH_SUPPORT
		&& !file_is_dead
#endif
		&& !fileattr_get (file, "_watched"))
d1012 1
a1012 16

	    {
		/* A newly checked out file is never under the spell
		   of "cvs edit".  If we think we were editing it
		   from a previous life, clean up.  Would be better to
		   check for same the working directory instead of
		   same user, but that is hairy.  */

		struct addremove_args args;

		editor_set (file, getcaller (), NULL);

		memset (&args, 0, sizeof args);
		args.remove_temp = 1;
		watch_modify_watchers (file, &args);
	    }
a1028 14
	    /* If no keyword expansion was specified on command line,
	       use whatever was in the file.  This is how we tell the client
	       whether a file is binary.  */
	    if (xvers_ts->options[0] == '\0')
	    {
		if (vers_ts->srcfile->expand != NULL)
		{
		    free (xvers_ts->options);
		    xvers_ts->options =
			xmalloc (strlen (vers_ts->srcfile->expand) + 3);
		    strcpy (xvers_ts->options, "-k");
		    strcat (xvers_ts->options, vers_ts->srcfile->expand);
		}
	    }
d1047 1
a1047 1
		if (unlink_file (file) < 0 && ! existence_error (errno))
d1206 1
a1206 2
		if (cvswrite == TRUE
		    && !fileattr_get (file, "_watched"))
a1546 11
    /* Fix for bug CVS/193:
     * Used to dump core if the file had been removed on the current branch.
     */
    if (strcmp(vers->vn_user, "0") == 0)
    {
        error(0, 0,
              "file %s has been deleted",
              file);
        return;
    }

d1549 1
a1549 1
    rev2 = RCS_getversion (vers->srcfile, jrev2, jdate2, 1, 0);
d1601 1
a1601 1
	tst = RCS_gettag (vers->srcfile, rev2, 1, 0);
d1624 1
a1624 1
	rev1 = RCS_getversion (vers->srcfile, jrev1, jdate1, 1, 0);
d1648 1
a1648 1
	    rev = RCS_getversion (vers->srcfile, join_rev2, date_rev2, 1, 0);
d1657 1
a1657 1
	    baserev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1, 0);
d1685 1
a1685 1
	    rev = RCS_getversion (vers->srcfile, join_rev1, date_rev1, 1, 0);
a1771 9
#ifdef SERVER_SUPPORT
    /*
     * If we're in server mode, then we need to re-register the file
     * even if there were no conflicts (status == 0).
     * This tells server_updated() to send the modified file back to
     * the client.
     */
    if (status == 1 || (status == 0 && server_active))
#else
a1772 1
#endif
d1792 74
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d44 5
d64 2
a65 1
static int update_fileproc PROTO ((struct file_info *));
d410 1
a410 1
    err = start_recursion (update_fileproc, update_filesdone_proc,
d440 6
a445 2
update_fileproc (finfo)
    struct file_info *finfo;
d451 3
a453 3
    status = Classify_File (finfo->file, tag, date, options, force_tag_match,
			    aflag, finfo->repository, finfo->entries, finfo->srcfiles, &vers,
			    finfo->update_dir, pipeout);
d482 2
a483 2
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
					vers, finfo->update_dir);
d488 1
a488 1
		       "unknown file status %d for file %s", status, finfo->file);
d504 1
a504 1
		(void) write_letter (finfo->file, 'C', finfo->update_dir);
d510 1
a510 1
		    (void) write_letter (finfo->file, 'C', finfo->update_dir);
d514 1
a514 1
		    if (wrap_merge_is_copy (finfo->file))
d517 2
a518 2
			retval = checkout_file (finfo->file, finfo->repository, finfo->entries,
						finfo->srcfiles, vers, finfo->update_dir);
d520 2
a521 2
			retval = merge_file (finfo->file, finfo->repository, finfo->entries,
					     vers, finfo->update_dir);
d539 1
a539 1
			filestamp = time_stamp (finfo->file);
d544 1
a544 1
		    filestamp = time_stamp (finfo->file);
d557 1
a557 1
			run_arg (finfo->file);
d562 1
a562 1
			    if (finfo->update_dir[0] == '\0')
d565 1
a565 1
				       finfo->file);
d569 1
a569 1
				       finfo->update_dir, finfo->file);
d574 1
a574 1
			(void) write_letter (finfo->file, 'C', finfo->update_dir);
d580 1
a580 1
			Register (finfo->entries, finfo->file, vers->vn_rcs, vers->ts_rcs,
d586 1
a586 1
		    retval = write_letter (finfo->file, 'M', finfo->update_dir);
d596 2
a597 2
		    retval = patch_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
					 vers, finfo->update_dir, &docheckout,
d602 1
a602 1
			    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d615 2
a616 2
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles,
					vers, finfo->update_dir);
d619 1
a619 1
		    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d625 1
a625 1
		retval = write_letter (finfo->file, 'A', finfo->update_dir);
d628 1
a628 1
		retval = write_letter (finfo->file, 'R', finfo->update_dir);
d631 1
a631 1
		retval = scratch_file (finfo->file, finfo->repository, finfo->entries, finfo->update_dir);
d634 1
a634 1
		    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d641 1
a641 1
		       "unknown file status %d for file %s", status, finfo->file);
d650 1
a650 1
	join_file (finfo->file, finfo->srcfiles, vers, finfo->update_dir, finfo->entries, finfo->repository);
d652 1
a652 1
	join_file (finfo->file, finfo->srcfiles, vers, finfo->update_dir, finfo->entries);
d662 1
a662 1
	p->key = xstrdup (finfo->file);
d698 3
a700 5
	/* I'm not sure the existence_error is actually possible (except
	   in cases where we really should print a message), but since
	   this code used to ignore all errors, I'll play it safe.  */
	if (unlink_file_dir (CVSADM) < 0 && !existence_error (errno))
	    error (0, errno, "cannot remove %s directory", CVSADM);
d702 1
d713 1
a758 22
    else
    {
	char *cvsadmdir;

	/* The directory exists.  Check to see if it has a CVS
	   subdirectory.  */

	cvsadmdir = xmalloc (strlen (dir) + 80);
	strcpy (cvsadmdir, dir);
	strcat (cvsadmdir, "/");
	strcat (cvsadmdir, CVSADM);

	if (!isdir (cvsadmdir))
	{
	    /* We cannot successfully recurse into a directory without a CVS
	       subdirectory.  Generally we will have already printed
	       "? foo".  */
	    free (cvsadmdir);
	    return R_SKIP_ALL;
	}
	free (cvsadmdir);
    }
d842 3
a844 5
	/* I'm not sure the existence_error is actually possible (except
	   in cases where we really should print a message), but since
	   this code used to ignore all errors, I'll play it safe.  */
	if (unlink_file_dir (dir) < 0 && !existence_error (errno))
	    error (0, errno, "cannot remove %s directory", dir);
d910 1
a910 1
    int status;
d912 1
d924 1
d927 11
a937 1
    if (!file_is_dead)
d939 2
a940 4
	/*
	 * if we are checking out to stdout, print a nice message to
	 * stderr, and add the -p flag to the command */
	if (pipeout)
d942 9
a950 13
	    if (!quiet)
	    {
		(void) fprintf (stderr, "\
===================================================================\n");
		if (update_dir[0])
		    (void) fprintf (stderr, "Checking out %s/%s\n",
				    update_dir, file);
		else
		    (void) fprintf (stderr, "Checking out %s\n", file);
		(void) fprintf (stderr, "RCS:  %s\n", vers_ts->srcfile->path);
		(void) fprintf (stderr, "VERS: %s\n", vers_ts->vn_rcs);
		(void) fprintf (stderr, "***************\n");
	    }
d952 6
d959 1
a959 3
	status = RCS_checkout (vers_ts->srcfile->path,
			       pipeout ? NULL : file, vers_ts->vn_tag,
			       vers_ts->options, RUN_TTY, 0, 0);
d961 5
a965 1
    if (file_is_dead || status == 0)
d970 1
d985 8
a992 9
		    /* I think that RCS_FLAGS_FORCE is here only because
		       passing -f to co used to enable checking out
		       a dead revision in the old version of death
		       support which used a hacked RCS instead of using
		       the RCS state.  */
		    retcode = RCS_checkout (vers_ts->srcfile->path, file,
		                            vers_ts->vn_rcs,
		                            vers_ts->options, RUN_TTY,
		                            RCS_FLAGS_FORCE, 0);
d1012 1
d1015 1
d1017 1
d1069 1
d1099 5
d1123 1
d1125 3
d1129 4
a1132 1
		write_letter (file, 'U', update_dir);
d1203 3
a1205 7
    if (noexec)
	retcode = 0;
    else
	retcode = RCS_checkout (vers_ts->srcfile->path, NULL,
	                        vers_ts->vn_user,
	                        vers_ts->options, file1, 0, 0);
    if (retcode != 0)
d1229 3
a1231 4
	retcode = RCS_checkout (vers_ts->srcfile->path, file,
	                        vers_ts->vn_rcs,
	                        vers_ts->options, RUN_TTY, 0, 0);
	if (retcode != 0)
a1278 1
    retcode = 0;
d1347 4
a1350 1
	    write_letter (file, 'P', update_dir);
a1387 4
	char buf[2];
	buf[0] = letter;
	buf[1] = ' ';
	cvs_output (buf, 2);
d1389 3
a1391 6
	{
	    cvs_output (update_dir, 0);
	    cvs_output ("/", 1);
	}
	cvs_output (file, 0);
	cvs_output ("\n", 1);
d1488 2
a1489 1
	write_letter (file, 'C', update_dir);
d1500 2
a1501 1
	write_letter (file, 'M', update_dir);
d1775 3
a1777 2
	retcode = RCS_checkout (vers->srcfile->path, "", vers->vn_user, NULL,
	                        RUN_TTY, 0, 0);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d45 1
a45 1
			  RCSNode *rcsnode, Vers_TS *vers_ts, char *update_dir));
d48 1
a48 1
		       RCSNode*rcsnode, Vers_TS *vers_ts, char *update_dir,
d64 1
a64 1
static void join_file PROTO((char *file, RCSNode *rcsnode, Vers_TS *vers_ts,
d67 1
a67 1
static void join_file PROTO((char *file, RCSNode *rcsnode, Vers_TS *vers_ts,
d260 1
a260 1
		send_file_names (argc, argv, SEND_EXPAND_WILD);
d278 1
a278 1
		send_file_names (failed_patches_count, failed_patches, 0);
d442 1
a442 1
			    aflag, finfo->repository, finfo->entries, finfo->rcs, &vers,
d472 1
a472 1
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
d508 1
a508 1
						finfo->rcs, vers, finfo->update_dir);
d552 2
a553 1
			    error (1, errno,
d555 5
a559 1
				       finfo->fullname);
d586 1
a586 1
		    retval = patch_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
d605 1
a605 1
		retval = checkout_file (finfo->file, finfo->repository, finfo->entries, finfo->rcs,
d640 1
a640 1
	join_file (finfo->file, finfo->rcs, vers, finfo->update_dir, finfo->entries, finfo->repository);
d642 1
a642 1
	join_file (finfo->file, finfo->rcs, vers, finfo->update_dir, finfo->entries);
d749 1
a749 2
    /* Do we need to check noexec here? */
    else if (!pipeout)
d913 1
a913 1
checkout_file (file, repository, entries, rcsnode, vers_ts, update_dir)
d917 1
a917 1
    RCSNode *rcsnode;
d1046 1
a1046 1
			      force_tag_match, set_time, entries, rcsnode);
d1049 14
d1145 1
a1145 1
patch_file (file, repository, entries, rcsnode, vers_ts, update_dir,
d1150 1
a1150 1
    RCSNode *rcsnode;
d1317 1
a1317 1
			       force_tag_match, 0, entries, rcsnode);
d1505 1
a1505 1
join_file (file, rcsnode, vers, update_dir, entries, repository)
d1508 1
a1508 1
join_file (file, rcsnode, vers, update_dir, entries)
d1511 1
a1511 1
    RCSNode *rcsnode;
d1735 1
a1735 1
	    baserev = RCS_whatbranch (file, join_rev1, rcsnode);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d44 2
a45 2
static int checkout_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts,
				 int adding));
d47 4
a50 4
static int patch_file PROTO ((struct file_info *finfo,
			      Vers_TS *vers_ts, 
			      int *docheckout, struct stat *file_info,
			      unsigned char *checksum));
d53 9
a61 12
static int merge_file PROTO ((struct file_info *finfo, Vers_TS *vers));
static int scratch_file PROTO((struct file_info *finfo));
static Dtype update_dirent_proc PROTO ((void *callerdat, char *dir,
					char *repository, char *update_dir,
					List *entries));
static int update_dirleave_proc PROTO ((void *callerdat, char *dir,
					int err, char *update_dir,
					List *entries));
static int update_fileproc PROTO ((void *callerdat, struct file_info *));
static int update_filesdone_proc PROTO ((void *callerdat, int err,
					 char *repository, char *update_dir,
					 List *entries));
d64 2
a65 1
static void join_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts));
d67 2
a68 1
static void join_file PROTO ((struct file_info *finfo, Vers_TS *vers_ts));
d96 1
a96 1
    "\t-p\tSend updates to standard output (avoids stickiness).\n",
d98 2
a99 2
    "\t-r rev\tUpdate using specified revision/tag (is sticky).\n",
    "\t-D date\tSet date to update from (is sticky).\n",
a230 2
	    if (options && options[0] != '\0')
		send_arg (options);
a236 1
	    wrap_send ();
d243 13
a255 7
#ifndef DONT_USE_PATCH
		/* Systems which don't have the patch program ported to them
		   will want to define DONT_USE_PATCH; then CVS won't try to
		   invoke patch.  */
		if (supported_request ("update-patches"))
		    send_arg ("-u");
#endif
d271 1
a271 1
		    && CVS_CHDIR (toplevel_wd) < 0)
d300 2
a301 4
    if (join_rev1 != NULL)
        tag_check_valid_join (join_rev1, argc, argv, local, aflag, "");
    if (join_rev2 != NULL)
        tag_check_valid_join (join_rev2, argc, argv, local, aflag, "");
d405 1
a405 1
			   update_dirent_proc, update_dirleave_proc, NULL,
d407 1
a407 1
			   preload_update_dir, 1);
d434 1
a434 2
update_fileproc (callerdat, finfo)
    void *callerdat;
a439 1
    int resurrecting;
d441 3
a443 4
    resurrecting = 0;

    status = Classify_File (finfo, tag, date, options, force_tag_match,
			    aflag, &vers, pipeout);
d472 2
a473 1
		retval = checkout_file (finfo, vers, 0);
d507 2
a508 2
			retval =
			  checkout_file (finfo, vers, 0);
d510 2
a511 1
			retval = merge_file (finfo, vers);
d581 2
a582 2
		    retval = patch_file (finfo,
					 vers, &docheckout,
d587 1
a587 1
			    server_updated (finfo, vers,
d600 2
a601 1
		retval = checkout_file (finfo, vers, 0);
d604 1
a604 1
		    server_updated (finfo, vers,
d616 1
a616 1
		retval = scratch_file (finfo);
d619 1
a619 4
		{
		    if (vers->ts_user == NULL)
			server_scratch_entry_only ();
		    server_updated (finfo, vers,
a621 1
		}
d634 5
a638 1
	join_file (finfo, vers);
d668 1
a668 2
update_filesdone_proc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
a671 1
    List *entries;
d676 1
a676 1
	ignore_files (ignlist, entries, update_dir, update_ignproc);
d697 1
a697 1
	    Create_Root ((char *) NULL, CVSroot_original);
d712 1
a712 2
update_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
a715 1
    List *entries;
d718 1
a718 1
    {
d723 1
a723 1
    }
a741 1
	    Subdir_Register (entries, (char *) NULL, dir);
d815 1
a815 2
update_dirleave_proc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
a818 1
    List *entries;
d824 1
a824 1
	(fp = CVS_FOPEN (CVSADM_UPROG, "r")) != NULL)
d845 4
a848 1
    if (strchr (dir, '/') == NULL)
d850 5
a854 12
	/* FIXME: chdir ("..") loses with symlinks.  */
	/* Prune empty dirs on the way out - if necessary */
	(void) CVS_CHDIR ("..");
	if (update_prune_dirs && isemptydir (dir))
	{
	    /* I'm not sure the existence_error is actually possible (except
	       in cases where we really should print a message), but since
	       this code used to ignore all errors, I'll play it safe.	*/
	    if (unlink_file_dir (dir) < 0 && !existence_error (errno))
		error (0, errno, "cannot remove %s directory", dir);
	    Subdir_Deregister (entries, (char *) NULL, dir);
	}
d871 1
a871 1
    if ((dirp = CVS_OPENDIR (dir)) == NULL)
d893 5
a897 2
scratch_file (finfo)
    struct file_info *finfo;
d899 3
a901 4
    history_write ('W', finfo->update_dir, "", finfo->file, finfo->repository);
    Scratch_Entry (finfo->entries, finfo->file);
    if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
	error (0, errno, "unable to remove %s", finfo->fullname);
d906 1
a906 1
 * Check out a file.
d909 5
a913 2
checkout_file (finfo, vers_ts, adding)
    struct file_info *finfo;
d915 1
a915 1
    int adding;
d926 3
a928 3
	(void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, finfo->file);
	if (isfile (finfo->file))
	    rename_file (finfo->file, backup);
d946 5
a950 1
		(void) fprintf (stderr, "Checking out %s\n", finfo->fullname);
d957 3
a959 4
	status = RCS_checkout (vers_ts->srcfile,
			       pipeout ? NULL : finfo->file,
			       vers_ts->vn_rcs, vers_ts->vn_tag,
			       vers_ts->options, RUN_TTY);
d966 42
d1011 2
a1012 2
		&& !fileattr_get (finfo->file, "_watched"))
		xchmod (finfo->file, 1);
d1023 1
a1023 1
		editor_set (finfo->file, getcaller (), NULL);
d1027 1
a1027 1
		watch_modify_watchers (finfo->file, &args);
d1039 1
a1039 1
	    wrap_fromcvs_process_file (finfo->file);
d1041 2
a1042 2
	    xvers_ts = Version_TS (finfo, options, tag, date, 
				   force_tag_match, set_time);
d1052 8
a1059 3
		    error (0, 0,
			   "warning: %s is not (any longer) pertinent",
			   finfo->fullname);
d1061 2
a1062 11
		Scratch_Entry (finfo->entries, finfo->file);
#ifdef SERVER_SUPPORT
		if (server_active && xvers_ts->ts_user == NULL)
		    server_scratch_entry_only ();
#endif
		/* FIXME: Rather than always unlink'ing, and ignoring the
		   existence_error, we should do the unlink only if
		   vers_ts->ts_user is non-NULL.  Then there would be no
		   need to ignore an existence_error (for example, if the
		   user removes the file while we are running).  */
		if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
d1064 5
a1068 1
		    error (0, errno, "cannot remove %s", finfo->fullname);
d1072 5
a1076 5
		Register (finfo->entries, finfo->file,
			  adding ? "0" : xvers_ts->vn_rcs,
			  xvers_ts->ts_user, xvers_ts->options,
			  xvers_ts->tag, xvers_ts->date,
			  (char *)0); /* Clear conflict flag on fresh checkout */
d1091 2
a1092 2
		history_write ('U', finfo->update_dir, xvers_ts->vn_rcs, finfo->file,
			       finfo->repository);
d1098 1
a1098 1
		write_letter (finfo->file, 'U', finfo->update_dir);
d1107 1
a1107 1
	    rename_file (backup, finfo->file);
d1110 1
a1110 1
	       "could not check out %s", finfo->fullname);
d1127 6
a1132 2
patch_file (finfo, vers_ts, docheckout, file_info, checksum)
    struct file_info *finfo;
d1134 1
d1155 3
a1157 3
    (void) sprintf (backup, "%s/%s%s", CVSADM, CVSPREFIX, finfo->file);
    if (isfile (finfo->file))
        rename_file (finfo->file, backup);
d1161 2
a1162 2
    (void) sprintf (file1, "%s/%s%s-1", CVSADM, CVSPREFIX, finfo->file);
    (void) sprintf (file2, "%s/%s%s-2", CVSADM, CVSPREFIX, finfo->file);
d1172 3
a1174 3
	retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
				vers_ts->vn_user, (char *) NULL,
				vers_ts->options, file1);
d1179 1
a1179 1
        e = CVS_FOPEN (file1, "r");
d1195 1
a1195 1
        /* Check it out into finfo->file, and then move to file2, so that we
d1199 3
a1201 3
	retcode = RCS_checkout (vers_ts->srcfile, finfo->file,
				vers_ts->vn_rcs, (char *) NULL,
				vers_ts->options, RUN_TTY);
d1206 1
a1206 1
	    if (!isreadable (finfo->file))
d1213 1
a1213 1
	        rename_file (finfo->file, file2);
d1215 1
a1215 1
		    && !fileattr_get (finfo->file, "_watched"))
d1217 1
a1217 1
		e = CVS_FOPEN (file2, "r");
d1265 1
a1265 1
	if ((retcode = run_exec (RUN_TTY, finfo->file, RUN_TTY, RUN_NORMAL)) != 0
d1277 1
a1277 1
	    e = CVS_FOPEN (finfo->file, "r");
d1279 1
a1279 2
		error (1, errno, "could not open diff output file %s",
		       finfo->fullname);
d1298 2
a1299 2
        xvers_ts = Version_TS (finfo, options, tag, date,
			       force_tag_match, 0);
d1303 1
a1303 1
	Register (finfo->entries, finfo->file, xvers_ts->vn_rcs,
d1307 1
a1307 1
	if ( CVS_STAT (file2, file_info) < 0)
d1312 2
a1313 2
	    history_write ('P', finfo->update_dir, xvers_ts->vn_rcs, finfo->file,
			   finfo->repository);
d1319 1
a1319 1
	    write_letter (finfo->file, 'P', finfo->update_dir);
d1327 1
a1327 1
	    rename_file (backup, finfo->file);
d1331 1
a1331 1
		   "could not diff %s", finfo->fullname);
d1376 4
a1379 2
merge_file (finfo, vers)
    struct file_info *finfo;
d1381 1
d1383 1
d1395 5
a1399 1
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, finfo->file, vers->vn_user);
d1402 2
a1403 31
    copy_file (finfo->file, backup);
    xchmod (finfo->file, 1);

    if (strcmp (vers->options, "-kb") == 0)
    {
	/* For binary files, a merge is always a conflict.  We give the
	   user the two files, and let them resolve it.  It is possible
	   that we should require a "touch foo" or similar step before
	   we allow a checkin.  */
	status = checkout_file (finfo, vers, 0);
#ifdef SERVER_SUPPORT
	/* Send the new contents of the file before the message.  If we
	   wanted to be totally correct, we would have the client write
	   the message only after the file has safely been written.  */
	if (server_active)
	{
	    server_copy_file (finfo->file, finfo->update_dir,
			      finfo->repository, backup);
	    server_updated (finfo, vers, SERVER_MERGED,
			    (struct stat *) NULL, (unsigned char *) NULL);
	}
#endif
	error (0, 0, "binary file needs merge");
	error (0, 0, "revision %s from repository is now in %s",
	       vers->vn_rcs, finfo->fullname);
	error (0, 0, "file from working directory is now in %s", backup);
	write_letter (finfo->file, 'C', finfo->update_dir);

	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
	return 0;
    }
d1410 1
a1410 1
	       "could not merge revision %s of %s", vers->vn_user, finfo->fullname);
d1412 2
a1413 2
	       finfo->fullname, backup);
	rename_file (backup, finfo->file);
d1424 2
a1425 2
	    cp = time_stamp (finfo->file);
	Register (finfo->entries, finfo->file, vers->vn_rcs, vers->ts_rcs, vers->options,
d1445 2
a1446 3
        server_copy_file (finfo->file, finfo->update_dir, finfo->repository,
			  backup);
	server_updated (finfo, vers, SERVER_MERGED,
d1451 1
a1451 1
    if (!noexec && !xcmp (backup, finfo->file))
d1454 2
a1455 2
		finfo->fullname, vers->vn_user, vers->vn_rcs);
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
d1462 1
a1462 1
	    error (0, 0, "conflicts found in %s", finfo->fullname);
d1464 1
a1464 1
	write_letter (finfo->file, 'C', finfo->update_dir);
d1466 1
a1466 1
	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
d1471 1
a1471 1
	error (1, errno, "fork failed while examining update of %s", finfo->fullname);
d1475 2
a1476 2
	write_letter (finfo->file, 'M', finfo->update_dir);
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file, finfo->repository);
d1486 8
a1493 2
join_file (finfo, vers)
    struct file_info *finfo;
d1495 2
d1498 1
d1515 1
a1515 1
    if (wrap_merge_is_copy (finfo->file))
d1517 1
d1519 1
a1519 2
	       "Cannot merge %s because it is a merge-by-copy file.",
	       finfo->fullname);
d1523 1
a1523 1
    /* Determine if we need to do anything at all.  */
d1530 3
a1532 2
    /* If only one join revision is specified, it becomes the second
       revision.  */
d1541 5
a1545 10
    /* Convert the second revision, walking branches and dates.  */
    rev2 = RCS_getversion (vers->srcfile, jrev2, jdate2, 1, (int *) NULL);

    /* If this is a merge of two revisions, get the first revision.
       If only one join tag was specified, then the first revision is
       the greatest common ancestor of the second revision and the
       working file.  */
    if (jrev1 != NULL)
	rev1 = RCS_getversion (vers->srcfile, jrev1, jdate1, 1, (int *) NULL);
    else
d1547 5
a1551 13
	/* Note that we use vn_rcs here, since vn_user may contain a
           special string such as "-nn".  */
	if (vers->vn_rcs == NULL)
	    rev1 = NULL;
	else if (rev2 == NULL)
	{
	    /* This means that the file never existed on the branch.
               It does not mean that the file was removed on the
               branch: that case is represented by a dead rev2.  If
               the file never existed on the branch, then we have
               nothing to merge, so we just return.  */
	    return;
	}
d1553 4
a1556 1
	    rev1 = gca (vers->vn_rcs, rev2);
d1559 4
a1562 2
    /* Handle a nonexistent or dead merge target.  */
    if (rev2 == NULL || RCS_isdead (vers->srcfile, rev2))
d1564 5
a1568 4
	char *mrev;

	if (rev2 != NULL)
	    free (rev2);
d1570 1
a1570 9
	/* If the first revision doesn't exist either, then there is
           no change between the two revisions, so we don't do
           anything.  */
	if (rev1 == NULL || RCS_isdead (vers->srcfile, rev1))
	{
	    if (rev1 != NULL)
		free (rev1);
	    return;
	}
d1572 4
a1575 74
	/* If we are merging two revisions, then the file was removed
	   between the first revision and the second one.  In this
	   case we want to mark the file for removal.

	   If we are merging one revision, then the file has been
	   removed between the greatest common ancestor and the merge
	   revision.  From the perspective of the branch on to which
	   we ar emerging, which may be the trunk, either 1) the file
	   does not currently exist on the target, or 2) the file has
	   not been modified on the target branch since the greatest
	   common ancestor, or 3) the file has been modified on the
	   target branch since the greatest common ancestor.  In case
	   1 there is nothing to do.  In case 2 we mark the file for
	   removal.  In case 3 we have a conflict.

	   Note that the handling is slightly different depending upon
	   whether one or two join targets were specified.  If two
	   join targets were specified, we don't check whether the
	   file was modified since a given point.  My reasoning is
	   that if you ask for an explicit merge between two tags,
	   then you want to merge in whatever was changed between
	   those two tags.  If a file was removed between the two
	   tags, then you want it to be removed.  However, if you ask
	   for a merge of a branch, then you want to merge in all
	   changes which were made on the branch.  If a file was
	   removed on the branch, that is a change to the file.  If
	   the file was also changed on the main line, then that is
	   also a change.  These two changes--the file removal and the
	   modification--must be merged.  This is a conflict.  */

	/* If the user file is dead, or does not exist, or has been
           marked for removal, then there is nothing to do.  */
	if (vers->vn_user == NULL
	    || vers->vn_user[0] == '-'
	    || RCS_isdead (vers->srcfile, vers->vn_user))
	{
	    if (rev1 != NULL)
		free (rev1);
	    return;
	}

	/* If the user file has been marked for addition, or has been
	   locally modified, then we have a conflict which we can not
	   resolve.  No_Difference will already have been called in
	   this case, so comparing the timestamps is sufficient to
	   determine whether the file is locally modified.  */
	if (strcmp (vers->vn_user, "0") == 0
	    || (vers->ts_user != NULL
		&& strcmp (vers->ts_user, vers->ts_rcs) != 0))
	{
	    if (jdate2 != NULL)
		error (0, 0,
		       "file %s is locally modified, but has been removed in revision %s as of %s",
		       finfo->fullname, jrev2, jdate2);
	    else
		error (0, 0,
		       "file %s is locally modified, but has been removed in revision %s",
		       finfo->fullname, jrev2);

	    /* FIXME: Should we arrange to return a non-zero exit
               status?  */

	    if (rev1 != NULL)
		free (rev1);

	    return;
	}

	/* If only one join tag was specified, and the user file has
           been changed since the greatest common ancestor (rev1),
           then there is a conflict we can not resolve.  See above for
           the rationale.  */
	if (join_rev2 == NULL
	    && strcmp (rev1, vers->vn_user) != 0)
d1579 2
a1580 2
		       "file %s has been modified, but has been removed in revision %s as of %s",
		       finfo->fullname, jrev2, jdate2);
d1583 2
a1584 10
		       "file %s has been modified, but has been removed in revision %s",
		       finfo->fullname, jrev2);

	    /* FIXME: Should we arrange to return a non-zero exit
               status?  */

	    if (rev1 != NULL)
		free (rev1);

	    return;
a1585 35

	if (rev1 != NULL)
	    free (rev1);

	/* The user file exists and has not been modified.  Mark it
           for removal.  FIXME: If we are doing a checkout, this has
           the effect of first checking out the file, and then
           removing it.  It would be better to just register the
           removal.  */
#ifdef SERVER_SUPPORT
	if (server_active)
	{
	    server_scratch (finfo->file);
	    server_updated (finfo, vers, SERVER_UPDATED, (struct stat *) NULL,
			    (unsigned char *) NULL);
	}
#endif
	mrev = xmalloc (strlen (vers->vn_user) + 2);
	sprintf (mrev, "-%s", vers->vn_user);
	Register (finfo->entries, finfo->file, mrev, vers->ts_rcs,
		  vers->options, vers->tag, vers->date, vers->ts_conflict);
	free (mrev);
	/* We need to check existence_error here because if we are
           running as the server, and the file is up to date in the
           working directory, the client will not have sent us a copy.  */
	if (unlink_file (finfo->file) < 0 && ! existence_error (errno))
	    error (0, errno, "cannot remove file %s", finfo->fullname);
#ifdef SERVER_SUPPORT
	if (server_active)
	    server_checked_in (finfo->file, finfo->update_dir,
			       finfo->repository);
#endif
	if (! really_quiet)
	    error (0, 0, "scheduling %s for removal", finfo->fullname);

d1589 2
a1590 3
    /* If the target of the merge is the same as the working file
       revision, then there is nothing to do.  */
    if (vers->vn_user != NULL && strcmp (rev2, vers->vn_user) == 0)
d1592 1
a1592 2
	if (rev1 != NULL)
	    free (rev1);
d1597 1
a1597 3
    /* If rev1 is dead or does not exist, then the file was added
       between rev1 and rev2.  */
    if (rev1 == NULL || RCS_isdead (vers->srcfile, rev1))
d1599 24
a1622 3
	if (rev1 != NULL)
	    free (rev1);
	free (rev2);
d1624 2
a1625 4
	/* If the file does not exist in the working directory, then
           we can just check out the new revision and mark it for
           addition.  */
	if (vers->vn_user == NULL)
d1627 4
a1630 1
	    Vers_TS *xvers;
d1632 1
a1632 14
	    xvers = Version_TS (finfo, vers->options, jrev2, jdate2, 1, 0);

	    /* FIXME: If checkout_file fails, we should arrange to
               return a non-zero exit status.  */
	    status = checkout_file (finfo, xvers, 1);

#ifdef SERVER_SUPPORT
	    if (server_active && status == 0)
		server_updated (finfo, xvers,
				SERVER_UPDATED, (struct stat *) NULL,
				(unsigned char *) NULL);
#endif

	    freevers_ts (&xvers);
d1634 5
a1640 15

	/* The file currently exists in the working directory, so we
           have a conflict which we can not resolve.  Note that this
           is true even if the file is marked for addition or removal.  */

	if (jdate2 != NULL)
	    error (0, 0,
		   "file %s exists, but has been added in revision %s as of %s",
		   finfo->fullname, jrev2, jdate2);
	else
	    error (0, 0,
		   "file %s exists, but has been added in revision %s",
		   finfo->fullname, jrev2);

	return;
d1642 4
d1647 15
a1661 7
    /* If the two merge revisions are the same, then there is nothing
       to do.  */
    if (strcmp (rev1, rev2) == 0)
    {
	free (rev1);
	free (rev2);
	return;
d1664 1
a1664 5
    /* If there is no working file, then we can't do the merge.  */
    if (vers->vn_user == NULL)
    {
	free (rev1);
	free (rev2);
d1666 40
a1705 4
	if (jdate2 != NULL)
	    error (0, 0,
		   "file %s is present in revision %s as of %s",
		   finfo->fullname, jrev2, jdate2);
d1707 34
a1740 3
	    error (0, 0,
		   "file %s is present in revision %s",
		   finfo->fullname, jrev2);
d1742 1
a1742 4
	/* FIXME: Should we arrange to return a non-zero exit status?  */

	return;
    }
d1745 1
a1745 1
    if (server_active && !isreadable (finfo->file))
d1749 2
a1750 3
	retcode = RCS_checkout (vers->srcfile, finfo->file,
				vers->vn_user, (char *) NULL,
				(char *) NULL, RUN_TTY);
d1753 1
a1753 1
		   "failed to check out %s file", finfo->fullname);
d1764 5
a1768 1
    (void) sprintf (backup, "%s%s.%s", BAKPREFIX, finfo->file, vers->vn_user);
d1771 2
a1772 2
    copy_file (finfo->file, backup);
    xchmod (finfo->file, 1);
d1786 1
a1786 1
	       "could not merge revision %s of %s", rev2, finfo->fullname);
d1788 2
a1789 2
	       finfo->fullname, backup);
	rename_file (backup, finfo->file);
d1809 2
a1810 3
	    cp = time_stamp (finfo->file);
	Register (finfo->entries, finfo->file,
		  vers->vn_rcs, vers->ts_rcs, vers->options,
d1819 2
a1820 3
	server_copy_file (finfo->file, finfo->update_dir, finfo->repository,
			  backup);
	server_updated (finfo, vers, SERVER_MERGED,
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a36 1
#include "savecwd.h"
d52 1
d259 1
a259 1
		send_files (argc, argv, local, aflag, update_build_dirs);
d268 1
a268 1
		if (toplevel_wd != NULL
d278 1
a278 1
			    aflag, update_build_dirs);
d542 15
a556 3
			/* The timestamps differ.  But if there are conflict
			   markers print 'C' anyway.  */
			retcode = !file_has_markers (finfo);
a557 1

d843 1
a843 4
	    cvs_output (program_name, 0);
	    cvs_output (" ", 1);
	    cvs_output (command_name, 0);
	    cvs_output (": Executing '", 0);
d845 1
a845 1
	    cvs_output ("'\n", 0);
d857 1
a857 1
	if (update_prune_dirs && isemptydir (dir, 0))
d871 4
a874 3
static int isremoved PROTO ((Node *, void *));

/* Returns 1 if the file indicated by node has been removed.  */
d876 1
a876 16
isremoved (node, closure)
    Node *node;
    void *closure;
{
    Entnode *entdata = (Entnode*) node->data;

    /* If the first character of the version is a '-', the file has been
       removed. */
    return (entdata->version && entdata->version[0] == '-') ? 1 : 0;
}

/* Returns 1 if the argument directory is completely empty, other than the
   existence of the CVS directory entry.  Zero otherwise.  If MIGHT_NOT_EXIST
   and the directory doesn't exist, then just return 0.  */
int
isemptydir (dir, might_not_exist)
a877 1
    int might_not_exist;
d884 1
a884 3
	if (might_not_exist && existence_error (errno))
	    return 0;
	error (0, errno, "cannot open directory %s for empty check", dir);
a886 1
    errno = 0;
d889 2
a890 2
	if (strcmp (dp->d_name, ".") != 0
	    && strcmp (dp->d_name, "..") != 0)
d892 2
a893 39
	    if (strcmp (dp->d_name, CVSADM) != 0)
	    {
		/* An entry other than the CVS directory.  The directory
		   is certainly not empty. */
		(void) closedir (dirp);
		return (0);
	    }
	    else
	    {
		/* The CVS directory entry.  We don't have to worry about
		   this unless the Entries file indicates that files have
		   been removed, but not committed, in this directory.
		   (Removing the directory would prevent people from
		   comitting the fact that they removed the files!) */
		List *l;
		int files_removed;
		struct saved_cwd cwd;

		if (save_cwd (&cwd))
		    error_exit ();

		if (CVS_CHDIR (dir) < 0)
		    error (1, errno, "cannot change directory to %s", dir);
		l = Entries_Open (0);
		files_removed = walklist (l, isremoved, 0);
		Entries_Close (l);

		if (restore_cwd (&cwd, NULL))
		    error_exit ();
		free_cwd (&cwd);

		if (files_removed != 0)
		{
		    /* There are files that have been removed, but not
		       committed!  Do not consider the directory empty. */
		    (void) closedir (dirp);
		    return (0);
		}
	    }
a894 7
	errno = 0;
    }
    if (errno != 0)
    {
	error (0, errno, "cannot read directory %s", dir);
	(void) closedir (dirp);
	return (0);
d950 6
a955 11
		cvs_outerr ("\
===================================================================\n\
Checking out ", 0);
		cvs_outerr (finfo->fullname, 0);
		cvs_outerr ("\n\
RCS:  ", 0);
		cvs_outerr (vers_ts->srcfile->path, 0);
		cvs_outerr ("\n\
VERS: ", 0);
		cvs_outerr (vers_ts->vn_rcs, 0);
		cvs_outerr ("\n***************\n", 0);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a43 1
#include "getline.h"
a208 2
	int pass;

a211 1
	pass = 1;
d259 1
a259 1
		send_files (argc, argv, local, aflag, update_build_dirs, 0);
d278 1
a278 1
			    aflag, update_build_dirs, 0);
d287 1
a287 17

	    /* If there are any conflicts, the server will return a
               non-zero exit status.  If any patches failed, we still
               want to run the update again.  We use a pass count to
               avoid an endless loop.  */

	    /* Notes: (1) assuming that status != 0 implies a
	       potential conflict is the best we can cleanly do given
	       the current protocol.  I suppose that trying to
	       re-fetch in cases where there was a more serious error
	       is probably more or less harmless, but it isn't really
	       ideal.  (2) it would be nice to have a testsuite case for the
	       conflict-and-patch-failed case.  */

	    if (status != 0
		&& (failed_patches == NULL || pass > 1))
	    {
a288 1
	    }
a289 1
	    ++pass;
d770 1
a770 1
	    char *tmp;
a771 1
	    tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ENTSTAT) + 10);
a778 1
	    free (tmp);
a818 2
    /* FIXME: should be checking for errors from CVS_FOPEN and printing
       them if not existence_error.  */
d824 1
a824 2
	char *line = NULL;
	size_t line_allocated = 0;
d827 1
a827 1
	if (getline (&line, &line_allocated, fp) >= 0)
d840 1
a840 9
	else if (ferror (fp))
	    error (0, errno, "cannot read %s", CVSADM_UPROG);
	else
	    error (0, 0, "unexpected end of file on %s", CVSADM_UPROG);

	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", CVSADM_UPROG);
	if (line != NULL)
	    free (line);
d977 1
a977 1
    char *backup;
a985 4
	backup = xmalloc (strlen (finfo->file)
			  + sizeof (CVSADM)
			  + sizeof (CVSPREFIX)
			  + 10);
d990 1
a990 3
	    /* If -f/-t wrappers are being used to wrap up a directory,
	       then backup might be a directory instead of just a file.  */
	    (void) unlink_file_dir (backup);
d1136 1
a1136 6
    {
	/* If -f/-t wrappers are being used to wrap up a directory,
	   then backup might be a directory instead of just a file.  */
	(void) unlink_file_dir (backup);
	free (backup);
    }
d1154 3
a1156 3
    char *backup;
    char *file1;
    char *file2;
a1169 4
    backup = xmalloc (strlen (finfo->file)
		      + sizeof (CVSADM)
		      + sizeof (CVSPREFIX)
		      + 10);
d1175 1
a1175 5

    file1 = xmalloc (strlen (finfo->file)
		     + sizeof (CVSADM)
		     + sizeof (CVSPREFIX)
		     + 10);
a1176 4
    file2 = xmalloc (strlen (finfo->file)
		     + sizeof (CVSADM)
		     + sizeof (CVSPREFIX)
		     + 10);
a1356 3
    free (backup);
    free (file1);
    free (file2);
d1396 1
a1396 1
    char *backup;
a1398 1
    int retval;
a1406 4
    backup = xmalloc (strlen (finfo->file)
		      + strlen (vers->vn_user)
		      + sizeof (BAKPREFIX)
		      + 10);
d1438 2
a1439 4
	history_write ('C', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
	retval = 0;
	goto out;
d1451 1
a1451 2
	retval = 1;
	goto out;
d1493 2
a1494 4
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
	retval = 0;
	goto out;
d1509 1
a1509 2
	error (1, errno, "fork failed while examining update of %s",
	       finfo->fullname);
d1514 1
a1514 2
	history_write ('G', finfo->update_dir, vers->vn_rcs, finfo->file,
		       finfo->repository);
d1516 1
a1516 4
    retval = 0;
 out:
    free (backup);
    return retval;
d1528 1
a1528 1
    char *backup;
a1853 4
    backup = xmalloc (strlen (finfo->file)
		      + strlen (vers->vn_user)
		      + sizeof (BAKPREFIX)
		      + 10);
a1911 1
    free (backup);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a52 1
static void patch_file_write PROTO ((void *, const char *, size_t));
a75 9
/* This is a bit of a kludge.  We call WriteTag at the beginning
   before we know whether nonbranch is set or not.  And then at the
   end, once we have the right value for nonbranch, we call WriteTag
   again.  I don't know whether the first call is necessary or not.
   rewrite_tag is nonzero if we are going to have to make that second
   call.  */
static int rewrite_tag;
static int nonbranch;

d128 1
a128 1
    while ((c = getopt (argc, argv, "+ApPflRQqduk:r:D:j:I:W:")) != -1)
d263 1
a263 4
		/* If noexec, probably could be setting SEND_NO_CONTENTS.
		   Same caveats as for "cvs status" apply.  */
		send_files (argc, argv, local, aflag,
			    update_build_dirs ? SEND_BUILD_DIRS : 0);
d282 1
a282 1
			    aflag, update_build_dirs ? SEND_BUILD_DIRS : 0);
d345 5
a349 4
	    WriteTag ((char *) NULL, tag, date, 0,
		      ".", Name_Repository (NULL, NULL));
	    rewrite_tag = 1;
	    nonbranch = 0;
a468 17

    /* Keep track of whether TAG is a branch tag.
       Note that if it is a branch tag in some files and a nonbranch tag
       in others, treat it as a nonbranch tag.  It is possible that case
       should elicit a warning or an error.  */
    if (rewrite_tag
	&& tag != NULL
	&& finfo->rcs != NULL)
    {
	char *rev = RCS_getversion (finfo->rcs, tag, NULL, 1, NULL);
	if (rev != NULL
	    && !RCS_nodeisbranch (finfo->rcs, tag))
	    nonbranch = 1;
	if (rev != NULL)
	    free (rev);
    }

a685 6
    if (rewrite_tag)
    {
	WriteTag (NULL, tag, date, nonbranch, update_dir, repository);
	rewrite_tag = 0;
    }

d756 1
a756 6
	    Create_Admin (dir, update_dir, repository, tag, date,
			  /* This is a guess.  We will rewrite it later
			     via WriteTag.  */
			  0);
	    rewrite_tag = 1;
	    nonbranch = 0;
d808 5
a812 3
	    WriteTag (dir, tag, date, 0, update_dir, repository);
	    rewrite_tag = 1;
	    nonbranch = 0;
d1062 1
a1062 2
			       vers_ts->options, RUN_TTY,
			       (RCSCHECKOUTPROC) NULL, (void *) NULL);
a1187 18

/* This structure is used to pass information between patch_file and
   patch_file_write.  */

struct patch_file_data
{
    /* File name, for error messages.  */
    const char *filename;
    /* File to which to write.  */
    FILE *fp;
    /* Whether to compute the MD5 checksum.  */
    int compute_checksum;
    /* Data structure for computing the MD5 checksum.  */
    struct MD5Context context;
    /* Set if the file has a final newline.  */
    int final_nl;
};

a1206 1
    struct patch_file_data data;
d1210 1
a1210 9
    if (noexec || pipeout || joining ())
    {
	*docheckout = 1;
	return 0;
    }

    /* If this file has been marked as being binary, then never send a
       patch.  */
    if (strcmp (vers_ts->options, "-kb") == 0)
d1242 23
a1264 20

    e = CVS_FOPEN (file1, "w");
    if (e == NULL)
	error (1, errno, "cannot open %s", file1);

    data.filename = file1;
    data.fp = e;
    data.final_nl = 0;
    data.compute_checksum = 0;

    retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
			    vers_ts->vn_user, (char *) NULL,
			    vers_ts->options, RUN_TTY,
			    patch_file_write, (void *) &data);

    if (fclose (e) < 0)
	error (1, errno, "cannot close %s", file1);

    if (retcode != 0 || ! data.final_nl)
	fail = 1;
d1268 5
a1272 11
	e = CVS_FOPEN (file2, "w");
	if (e == NULL)
	    error (1, errno, "cannot open %s", file2);

	data.filename = file2;
	data.fp = e;
	data.final_nl = 0;
	data.compute_checksum = 1;
	MD5Init (&data.context);

	retcode = RCS_checkout (vers_ts->srcfile, (char *) NULL,
d1274 37
a1310 2
				vers_ts->options, RUN_TTY,
				patch_file_write, (void *) &data);
d1312 4
a1315 2
	if (fclose (e) < 0)
	    error (1, errno, "cannot close %s", file2);
d1317 4
a1320 4
	if (retcode != 0 || ! data.final_nl)
	    fail = 1;
	else
	    MD5Final (checksum, &data.context);
a1348 13
	    /* Stat the original RCS file, and then adjust it the way
	       that RCS_checkout would.  FIXME: This is an abstraction
	       violation.  */
	    if (CVS_STAT (vers_ts->srcfile->path, file_info) < 0)
		error (1, errno, "could not stat %s", vers_ts->srcfile->path);
	    if (chmod (finfo->file,
		       file_info->st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH))
		< 0)
		error (0, errno, "cannot change mode of file %s", finfo->file);
	    if (cvswrite == TRUE
		&& !fileattr_get (finfo->file, "_watched"))
		xchmod (finfo->file, 1);

d1381 2
a1382 2
	if (CVS_STAT (finfo->file, file_info) < 0)
	    error (1, errno, "could not stat %s", finfo->file);
d1420 1
a1420 23

/* Write data to a file.  Record whether the last byte written was a
   newline.  Optionally compute a checksum.  This is called by
   patch_file via RCS_checkout.  */

static void
patch_file_write (callerdat, buffer, len)
     void *callerdat;
     const char *buffer;
     size_t len;
{
    struct patch_file_data *data = (struct patch_file_data *) callerdat;

    if (fwrite (buffer, 1, len, data->fp) != len)
	error (1, errno, "cannot write %s", data->filename);

    data->final_nl = (buffer[len - 1] == '\n');

    if (data->compute_checksum)
	MD5Update (&data->context, buffer, len);
}

#endif /* SERVER_SUPPORT */
d1916 1
a1916 2
				(char *) NULL, RUN_TTY,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@a94 1
static int rcs_diff_patches = 0;
d137 1
a137 1
    optind = 0;
a202 1
		{
a203 2
		    rcs_diff_patches = server_use_rcs_diff ();
		}
a557 12
#if 0
			/* Look, we can't clobber the user's file.  We
			   know it is modified and we're going to
			   overwrite their mod?  Puh-leeze.  The
			   correct behavior is probably something like
			   what merge_file does for -kb, which is to
			   give the users both files and tell them
			   what the two filenames are.  Of course, -m
			   in wrappers needs to be documented *much*
			   better.  Anyway, until then, make this a
			   fatal error.  */

a561 9
#else
		    {
		        error (0, 0, "A -m 'COPY' wrapper is specified");
			error (0, 0, "but file %s needs merge",
			       finfo->fullname);
			error (1, 0, "\
You probably want to avoid -m 'COPY' wrappers");
#endif
		    }
d629 2
a630 4
					    (rcs_diff_patches
					     ? SERVER_RCS_DIFF
					     : SERVER_PATCHED),
					    &file_info, checksum);
d1245 1
a1245 1
/* Patch a file.  Runs diff.  This is only done when running as the
d1358 10
a1367 30
	const char *diff_options;

	/* FIXME: It might be better to come up with a diff library
           which can be shared with the diffutils.  */
	/* If the client does not support the Rcs-diff command, we
           send a context diff, and the client must invoke patch.
           That approach was problematical for various reasons.  The
           new approach only requires running diff in the server; the
           client can handle everything without invoking an external
           program.  */
	if (! rcs_diff_patches)
	{
	    /* We use -c, not -u, because we have no way of knowing
	       which DIFF is in use.  */
	    diff_options = "-c";
	}
	else
	{
	    /* FIXME: We should use -a if diff supports it.  We should
               probably just copy over most or all of the diff
               handling in the RCS configure script.  */
	    /* IMHO, we shouldn't copy over anything which even
	       vaguely resembles the RCS configure script.  That kind of
	       thing tends to be ugly, slow, and fragile.  It also is a
	       a support headache for CVS to behave differently in subtle
	       ways based on whether it was installed correctly.  Instead we
	       should come up with a diff library.  -kingdon, Apr 1997.  */
	    diff_options = "-n";
	}
	run_setup ("%s %s %s %s", DIFF, diff_options, file1, file2);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d67 4
a70 1
static void write_letter PROTO ((struct file_info *finfo, int letter));
d72 1
a115 1
    "(Specify the --help global option for a list of other help options)\n",
d262 1
a262 8
	       means to send patches instead of complete files.

	       We don't send -u if failed_patches != NULL, so that the
	       server doesn't try to send patches which will just fail
	       again.  At least currently, the client also clobbers the
	       file and tells the server it is lost, which also will get
	       a full file instead of a patch, but it seems clean to omit
	       -u.  */
d265 4
d271 1
d551 1
a551 1
		write_letter (finfo, 'C');
d557 1
a557 1
		    write_letter (finfo, 'C');
d561 28
a588 1
		    retval = merge_file (finfo, vers);
d625 1
a625 1
			write_letter (finfo, 'C');
d637 1
a637 4
		{
		    write_letter (finfo, 'M');
		    retval = 0;
		}
d661 1
d663 2
a664 2
		   file out.  It's simpler and faster than producing
		   and applying patches.  */
d677 1
a677 2
		write_letter (finfo, 'A');
		retval = 0;
d680 1
a680 2
		write_letter (finfo, 'R');
		retval = 0;
d730 1
a730 17
    struct file_info finfo;

    memset (&finfo, 0, sizeof (finfo));
    finfo.file = file;
    finfo.update_dir = dir;
    if (dir[0] == '\0')
	finfo.fullname = xstrdup (file);
    else
    {
	finfo.fullname = xmalloc (strlen (file) + strlen (dir) + 10);
	strcpy (finfo.fullname, dir);
	strcat (finfo.fullname, "/");
	strcat (finfo.fullname, file);
    }

    write_letter (&finfo, '?');
    free (finfo.fullname);
d811 1
a811 1
	    error (0, 0, "New directory `%s' -- ignored", update_dir);
a820 1
			  0,
d923 1
a923 2
	    run_setup (line);
	    run_arg (repository);
a1082 3
    /* Solely to suppress a warning from gcc -Wall.  */
    backup = NULL;

d1096 1
a1096 7
	    if (unlink_file_dir (backup) < 0)
	    {
		/* Not sure if the existence_error check is needed here.  */
		if (!existence_error (errno))
		    /* FIXME: should include update_dir in message.  */
		    error (0, errno, "error removing %s", backup);
	    }
d1136 1
a1136 1
	    if (cvswrite
d1158 7
a1164 5
	    set_time =
		(!noexec
		 && (vers_ts->vn_user == NULL ||
		     strncmp (vers_ts->ts_rcs, "Initial", 7) == 0)
		 && !file_is_dead);
d1225 1
a1225 1
		write_letter (finfo, 'U');
d1246 1
a1246 7
	if (unlink_file_dir (backup) < 0)
	{
	    /* Not sure if the existence_error check is needed here.  */
	    if (!existence_error (errno))
		/* FIXME: should include update_dir in message.  */
		error (0, errno, "error removing %s", backup);
	}
a1308 21
    /* First check that the first revision exists.  If it has been nuked
       by cvs admin -o, then just fall back to checking out entire
       revisions.  In some sense maybe we don't have to do this; after
       all cvs.texinfo says "Make sure that no-one has checked out a
       copy of the revision you outdate" but then again, that advice
       doesn't really make complete sense, because "cvs admin" operates
       on a working directory and so _someone_ will almost always have
       _some_ revision checked out.  */
    {
	char *rev;

	rev = RCS_gettag (finfo->rcs, vers_ts->vn_user, 1, NULL);
	if (rev == NULL)
	{
	    *docheckout = 1;
	    return 0;
	}
	else
	    free (rev);
    }

d1385 1
a1385 1
	char *diff_options;
d1403 9
a1411 10
	    /* Now that diff is librarified, we could be passing -a if
	       we wanted to.  However, it is unclear to me whether we
	       would want to.  Does diff -a, in any significant
	       percentage of cases, produce patches which are smaller
	       than the files it is patching?  I guess maybe text
	       files with character sets which diff regards as
	       'binary'.  Conversely, do they tend to be much larger
	       in the bad cases?  This needs some more
	       thought/investigation, I suspect.  */

d1414 1
a1414 1
	retcode = diff_exec (file1, file2, diff_options, finfo->file);
d1417 1
a1417 1
	if (retcode != 0
d1437 1
a1437 1
	    if (cvswrite
d1485 1
a1485 1
	    write_letter (finfo, 'P');
d1531 1
a1531 1
	MD5Update (&data->context, (unsigned char *) buffer, len);
d1540 3
a1542 3
static void
write_letter (finfo, letter)
    struct file_info *finfo;
d1544 1
d1548 1
a1548 19
	char *tag = NULL;
	/* Big enough for "+updated" or any of its ilk.  */
	char buf[80];

	switch (letter)
	{
	    case 'U':
		tag = "updated";
		break;
	    default:
		/* We don't yet support tagged output except for "U".  */
		break;
	}

	if (tag != NULL)
	{
	    sprintf (buf, "+%s", tag);
	    cvs_output_tagged (buf, NULL);
	}
d1551 2
a1552 5
	buf[2] = '\0';
	cvs_output_tagged ("text", buf);
	cvs_output_tagged ("fname", finfo->fullname);
	cvs_output_tagged ("newline", NULL);
	if (tag != NULL)
d1554 2
a1555 2
	    sprintf (buf, "-%s", tag);
	    cvs_output_tagged (buf, NULL);
d1557 2
d1560 1
a1560 1
    return;
d1593 1
a1593 2
    if (strcmp (vers->options, "-kb") == 0
	|| wrap_merge_is_copy (finfo->file))
d1612 1
a1612 5
	/* Is there a better term than "nonmergeable file"?  What we
	   really mean is, not something that CVS cannot or does not
	   want to merge (there might be an external manual or
	   automatic merge process).  */
	error (0, 0, "nonmergeable file needs merge");
d1616 1
a1616 1
	write_letter (finfo, 'C');
d1624 1
a1624 1
    status = RCS_merge(finfo->rcs, vers->srcfile->path, finfo->file,
d1687 1
a1687 1
	write_letter (finfo, 'C');
d1699 1
a1699 1
	write_letter (finfo, 'M');
d1734 8
d2037 1
a2037 1

d2056 1
d2061 1
d2063 1
a2063 85
    /* If the source of the merge is the same as the working file
       revision, then we can just RCS_checkout the target (no merging
       as such).  In the text file case, this is probably quite
       similar to the RCS_merge, but in the binary file case,
       RCS_merge gives all kinds of trouble.  */
    if (vers->vn_user != NULL
	&& strcmp (rev1, vers->vn_user) == 0
	/* See comments above about how No_Difference has already been
	   called.  */
	&& vers->ts_user != NULL
	&& strcmp (vers->ts_user, vers->ts_rcs) == 0

	/* This is because of the worry below about $Name.  If that
	   isn't a problem, I suspect this code probably works for
	   text files too.  */
	&& (strcmp (options, "-kb") == 0
	    || wrap_merge_is_copy (finfo->file)))
    {
	/* FIXME: what about nametag?  What does RCS_merge do with
	   $Name?  */
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, options,
			  RUN_TTY, (RCSCHECKOUTPROC)0, NULL) != 0)
	    status = 2;
	else
	    status = 0;

	/* OK, this is really stupid.  RCS_checkout carefully removes
	   write permissions, and we carefully put them back.  But
	   until someone gets around to fixing it, that seems like the
	   easiest way to get what would seem to be the right mode.
	   I don't check CVSWRITE or _watched; I haven't thought about
	   that in great detail, but it seems like a watched file should
	   be checked out (writable) after a merge.  */
	xchmod (finfo->file, 1);

	/* Traditionally, the text file case prints a whole bunch of
	   scary looking and verbose output which fails to tell the user
	   what is really going on (it gives them rev1 and rev2 but doesn't
	   indicate in any way that rev1 == vn_user).  I think just a
	   simple "U foo" is good here; it seems analogous to the case in
	   which the file was added on the branch in terms of what to
	   print.  */
	write_letter (finfo, 'U');
    }
    else if (strcmp (options, "-kb") == 0
	     || wrap_merge_is_copy (finfo->file))
    {
	/* We are dealing with binary files, but real merging would
	   need to take place.  This is a conflict.  We give the user
	   the two files, and let them resolve it.  It is possible
	   that we should require a "touch foo" or similar step before
	   we allow a checkin.  */
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, options,
			  RUN_TTY, (RCSCHECKOUTPROC)0, NULL) != 0)
	    status = 2;
	else
	    status = 0;

	/* OK, this is really stupid.  RCS_checkout carefully removes
	   write permissions, and we carefully put them back.  But
	   until someone gets around to fixing it, that seems like the
	   easiest way to get what would seem to be the right mode.
	   I don't check CVSWRITE or _watched; I haven't thought about
	   that in great detail, but it seems like a watched file should
	   be checked out (writable) after a merge.  */
	xchmod (finfo->file, 1);

	/* Hmm.  We don't give them REV1 anywhere.  I guess most people
	   probably don't have a 3-way merge tool for the file type in
	   question, and might just get confused if we tried to either
	   provide them with a copy of the file from REV1, or even just
	   told them what REV1 is so they can get it themself, but it
	   might be worth thinking about.  */
	/* See comment in merge_file about the "nonmergeable file"
	   terminology.  */
	error (0, 0, "nonmergeable file needs merge");
	error (0, 0, "revision %s from repository is now in %s",
	       rev2, finfo->fullname);
	error (0, 0, "file from working directory is now in %s", backup);
	write_letter (finfo, 'C');
    }
    else
	status = RCS_merge (finfo->rcs, vers->srcfile->path, finfo->file,
			    options, rev1, rev2);

@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a44 2
#include "buffer.h"
#include "hardlink.h"
d47 1
a47 4
				 int adding, int merging, int update_server));
#ifdef SERVER_SUPPORT
static void checkout_to_buffer PROTO ((void *, const char *, size_t));
#endif
a66 3
#ifdef PRESERVE_PERMISSIONS_SUPPORT
static int get_linkinfo_proc PROTO ((void *callerdat, struct file_info *));
#endif
a81 4
/* If we set the tag or date for a subdirectory, we use this to undo
   the setting.  See update_dirent_proc.  */
static char *tag_update_dir;

a439 26
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	/* We need to do an extra recursion, bleah.  It's to make sure
	   that we know as much as possible about file linkage. */
	hardlist = getlist();
	working_dir = xgetwd();		/* save top-level working dir */

	/* FIXME-twp: the arguments to start_recursion make me dizzy.  This
	   function call was copied from the update_fileproc call that
	   follows it; someone should make sure that I did it right. */
	err = start_recursion (get_linkinfo_proc, (FILESDONEPROC) NULL,
			       (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
			       argc, argv, local, which, aflag, 1,
			       preload_update_dir, 1);
	if (err)
	    return (err);

	/* FIXME-twp: at this point we should walk the hardlist
	   and update the `links' field of each hardlink_info struct
	   to list the files that are linked on dist.  That would make
	   it easier & more efficient to compare the disk linkage with
	   the repository linkage (a simple strcmp). */
    }
#endif

a458 44
#ifdef PRESERVE_PERMISSIONS_SUPPORT
/*
 * The get_linkinfo_proc callback adds each file to the hardlist
 * (see hardlink.c).
 */

static int
get_linkinfo_proc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    char *fullpath;
    Node *linkp;
    struct hardlink_info *hlinfo;

    /* Get the full pathname of the current file. */
    fullpath = xmalloc (strlen(working_dir) +
			strlen(finfo->fullname) + 2);
    sprintf (fullpath, "%s/%s", working_dir, finfo->fullname);

    /* To permit recursing into subdirectories, files
       are keyed on the full pathname and not on the basename. */
    linkp = lookup_file_by_inode (fullpath);
    if (linkp == NULL)
    {
	/* The file isn't on disk; we are probably restoring
	   a file that was removed. */
	return 0;
    }
    
    /* Create a new, empty hardlink_info node. */
    hlinfo = (struct hardlink_info *)
	xmalloc (sizeof (struct hardlink_info));

    hlinfo->status = (Ctype) 0;	/* is this dumb? */
    hlinfo->checked_out = 0;
    hlinfo->links = NULL;

    linkp->data = (char *) hlinfo;

    return 0;
}
#endif

d529 1
a529 1
		retval = checkout_file (finfo, vers, 0, 0, 0);
d632 1
a632 2
					    file_info.st_mode, checksum,
					    (struct buffer *) NULL);
d642 7
a648 1
		retval = checkout_file (finfo, vers, 0, 0, 1);
d666 2
a667 3
				    SERVER_UPDATED, (mode_t) -1,
				    (unsigned char *) NULL,
				    (struct buffer *) NULL);
a808 20

	    /* If no tag or date were specified on the command line,
               and we're not using -A, we want the subdirectory to use
               the tag and date, if any, of the current directory.
               That way, update -d will work correctly when working on
               a branch.

	       We use TAG_UPDATE_DIR to undo the tag setting in
	       update_dirleave_proc.  If we did not do this, we would
	       not correctly handle a working directory with multiple
	       tags (and maybe we should prohibit such working
	       directories, but they work now and we shouldn't make
	       them stop working without more thought).  */
	    if ((tag == NULL && date == NULL) && ! aflag)
	    {
		ParseTag (&tag, &date, &nonbranch);
		if (tag != NULL || date != NULL)
		    tag_update_dir = xstrdup (update_dir);
	    }

a899 21
    /* If we set the tag or date for a new subdirectory in
       update_dirent_proc, and we're now done with that subdirectory,
       undo the tag/date setting.  Note that we know that the tag and
       date were both originally NULL in this case.  */
    if (tag_update_dir != NULL && strcmp (update_dir, tag_update_dir) == 0)
    {
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
	if (date != NULL)
	{
	    free (date);
	    date = NULL;
	}
	nonbranch = 0;
	free (tag_update_dir);
	tag_update_dir = NULL;
    }

d1019 1
a1019 1
		l = Entries_Open (0, NULL);
d1066 1
a1066 1
checkout_file (finfo, vers_ts, adding, merging, update_server)
a1069 2
    int merging;
    int update_server;
d1073 1
a1075 1
    struct buffer *revbuf;
d1077 1
a1078 1
    revbuf = NULL;
d1080 2
a1081 7
    /* Don't screw with backup files if we're going to stdout, or if
       we are the server.  */
    if (!pipeout
#ifdef SERVER_SUPPORT
	&& ! server_active
#endif
	)
a1090 1
	{
a1099 3
	    free (backup);
	    backup = NULL;
	}
d1127 5
a1131 21
#ifdef SERVER_SUPPORT
	if (update_server
	    && server_active
	    && ! pipeout
	    && ! file_gzip_level
	    && ! joining ()
	    && ! wrap_name_has (finfo->file, WRAP_FROMCVS))
	{
	    revbuf = buf_nonio_initialize ((BUFMEMERRPROC) NULL);
	    status = RCS_checkout (vers_ts->srcfile, (char *) NULL,
				   vers_ts->vn_rcs, vers_ts->vn_tag,
				   vers_ts->options, RUN_TTY,
				   checkout_to_buffer, revbuf);
	}
	else
#endif
	    status = RCS_checkout (vers_ts->srcfile,
				   pipeout ? NULL : finfo->file,
				   vers_ts->vn_rcs, vers_ts->vn_tag,
				   vers_ts->options, RUN_TTY,
				   (RCSCHECKOUTPROC) NULL, (void *) NULL);
a1134 4
	mode_t mode;

	mode = (mode_t) -1;

a1138 11
	    if (revbuf != NULL)
	    {
		struct stat sb;

		/* FIXME: We should have RCS_checkout return the mode.  */
		if (stat (vers_ts->srcfile->path, &sb) < 0)
		    error (1, errno, "cannot stat %s",
			   vers_ts->srcfile->path);
		mode = sb.st_mode &~ (S_IWRITE | S_IWGRP | S_IWOTH);
	    }

d1142 1
a1142 12
	    {
		if (revbuf == NULL)
		    xchmod (finfo->file, 1);
		else
		{
		    /* We know that we are the server here, so
                       although xchmod checks umask, we don't bother.  */
		    mode |= (((mode & S_IRUSR) ? S_IWUSR : 0)
			     | ((mode & S_IRGRP) ? S_IWGRP : 0)
			     | ((mode & S_IROTH) ? S_IWOTH : 0));
		}
	    }
a1173 21
	    if (revbuf != NULL)
	    {
		/* If we stored the file data into a buffer, then we
                   didn't create a file at all, so xvers_ts->ts_user
                   is wrong.  The correct value is to have it be the
                   same as xvers_ts->ts_rcs, meaning that the working
                   file is unchanged from the RCS file.

		   FIXME: We should tell Version_TS not to waste time
		   statting the nonexistent file.

		   FIXME: Actually, I don't think the ts_user value
		   matters at all here.  The only use I know of is
		   that it is printed in a trace message by
		   Server_Register.  */

		if (xvers_ts->ts_user != NULL)
		    free (xvers_ts->ts_user);
		xvers_ts->ts_user = xstrdup (xvers_ts->ts_rcs);
	    }

d1182 1
a1182 1
 			   finfo->fullname);
a1228 7

#ifdef SERVER_SUPPORT
	if (update_server && server_active)
	    server_updated (finfo, vers_ts,
			    merging ? SERVER_MERGED : SERVER_UPDATED,
			    mode, (unsigned char *) NULL, revbuf);
#endif
d1232 3
a1234 2
	if (backup != NULL)
	{
a1235 3
	    free (backup);
	    backup = NULL;
	}
d1237 2
a1238 1
	error (0, 0, "could not check out %s", finfo->fullname);
d1240 1
a1240 1
	retval = status;
d1243 1
a1243 1
    if (backup != NULL)
a1261 18
/* This function is used to write data from a file being checked out
   into a buffer.  */

static void
checkout_to_buffer (callerdat, data, len)
     void *callerdat;
     const char *data;
     size_t len;
{
    struct buffer *buf = (struct buffer *) callerdat;

    buf_output (buf, data, len);
}

#endif /* SERVER_SUPPORT */

#ifdef SERVER_SUPPORT

a1336 8
    /* If the revision is dead, let checkout_file handle it rather
       than duplicating the processing here.  */
    if (RCS_isdead (vers_ts->srcfile, vers_ts->vn_rcs))
    {
	*docheckout = 1;
	return 0;
    }

d1641 1
a1641 2
	|| wrap_merge_is_copy (finfo->file)
	|| special_file_mismatch (finfo, NULL, vers->vn_rcs))
d1643 1
a1643 2
	/* For binary files, a merge is always a conflict.  Same for
	   files whose permissions or linkage do not match.  We give the
d1647 1
a1647 10

	/* TODO: it may not always be necessary to regard a permission
	   mismatch as a conflict.  The working file and the RCS file
	   have a common ancestor `A'; if the working file's permissions
	   match A's, then it's probably safe to overwrite them with the
	   RCS permissions.  Only if the working file, the RCS file, and
	   A all disagree should this be considered a conflict.  But more
	   thought needs to go into this, and in the meantime it is safe
	   to treat any such mismatch as an automatic conflict. -twp */

d1649 3
d1653 1
d1656 3
a1659 3

	status = checkout_file (finfo, vers, 0, 1, 1);

d1720 1
a1720 2
			(mode_t) -1, (unsigned char *) NULL,
			(struct buffer *) NULL);
d1954 2
a1955 2
	    server_updated (finfo, vers, SERVER_UPDATED, (mode_t) -1,
			    (unsigned char *) NULL, (struct buffer *) NULL);
d2008 8
a2015 1
	    status = checkout_file (finfo, xvers, 1, 0, 1);
d2077 1
a2077 1
	    error (1, 0,
d2150 1
a2150 2
	     || wrap_merge_is_copy (finfo->file)
	     || special_file_mismatch (finfo, rev1, rev2))
d2152 1
a2152 2
	/* We are dealing with binary files, or files with a
	   permission/linkage mismatch, and real merging would
d2230 1
a2230 2
			(mode_t) -1, (unsigned char *) NULL,
			(struct buffer *) NULL);
a2233 305
}

/*
 * Report whether revisions REV1 and REV2 of FINFO agree on:
 *   . file ownership
 *   . permissions
 *   . major and minor device numbers
 *   . symbolic links
 *   . hard links
 *
 * If either REV1 or REV2 is NULL, the working copy is used instead.
 *
 * Return 1 if the files differ on these data.
 */

int
special_file_mismatch (finfo, rev1, rev2)
    struct file_info *finfo;
    char *rev1;
    char *rev2;
{
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    struct stat sb;
    RCSVers *vp;
    Node *n;
    uid_t rev1_uid, rev2_uid;
    gid_t rev1_gid, rev2_gid;
    mode_t rev1_mode, rev2_mode;
    unsigned long dev_long;
    dev_t rev1_dev, rev2_dev;
    char *rev1_symlink = NULL;
    char *rev2_symlink = NULL;
    char *rev1_hardlinks = NULL;
    char *rev2_hardlinks = NULL;
    int check_uids, check_gids, check_modes;
    int result;

    /* If we don't care about special file info, then
       don't report a mismatch in any case. */
    if (!preserve_perms)
	return 0;

    /* When special_file_mismatch is called from No_Difference, the
       RCS file has been only partially parsed.  We must read the
       delta tree in order to compare special file info recorded in
       the delta nodes.  (I think this is safe. -twp) */
    if (finfo->rcs->flags & PARTIAL)
	RCS_reparsercsfile (finfo->rcs, NULL, NULL);

    check_uids = check_gids = check_modes = 1;

    /* Obtain file information for REV1.  If this is null, then stat
       finfo->file and use that info. */
    /* If a revision does not know anything about its status,
       then presumably it doesn't matter, and indicates no conflict. */

    if (rev1 == NULL)
    {
	if (islink (finfo->file))
	    rev1_symlink = xreadlink (finfo->file);
	else
	{
	    if (CVS_LSTAT (finfo->file, &sb) < 0)
		error (1, errno, "could not get file information for %s",
		       finfo->file);
	    rev1_uid = sb.st_uid;
	    rev1_gid = sb.st_gid;
	    rev1_mode = sb.st_mode;
	    if (S_ISBLK (rev1_mode) || S_ISCHR (rev1_mode))
		rev1_dev = sb.st_rdev;
	}
	rev1_hardlinks = list_files_linked_to (finfo->file);
    }
    else
    {
	n = findnode (finfo->rcs->versions, rev1);
	vp = (RCSVers *) n->data;

	n = findnode (vp->other_delta, "symlink");
	if (n != NULL)
	    rev1_symlink = xstrdup (n->data);
	else
	{
	    n = findnode (vp->other_delta, "owner");
	    if (n == NULL)
		check_uids = 0;	/* don't care */
	    else
		rev1_uid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "group");
	    if (n == NULL)
		check_gids = 0;	/* don't care */
	    else
		rev1_gid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "permissions");
	    if (n == NULL)
		check_modes = 0;	/* don't care */
	    else
		rev1_mode = strtoul (n->data, NULL, 8);

	    n = findnode (vp->other_delta, "special");
	    if (n == NULL)
		rev1_mode |= S_IFREG;
	    else
	    {
		/* If the size of `ftype' changes, fix the sscanf call also */
		char ftype[16];
		if (sscanf (n->data, "%16s %lu", ftype,
			    &dev_long) < 2)
		    error (1, 0, "%s:%s has bad `special' newphrase %s",
			   finfo->file, rev1, n->data);
		rev1_dev = dev_long;
		if (strcmp (ftype, "character") == 0)
		    rev1_mode |= S_IFCHR;
		else if (strcmp (ftype, "block") == 0)
		    rev1_mode |= S_IFBLK;
		else
		    error (0, 0, "%s:%s unknown file type `%s'",
			   finfo->file, rev1, ftype);
	    }

	    n = findnode (vp->other_delta, "hardlinks");
	    if (n == NULL)
		rev1_hardlinks = xstrdup ("");
	    else
		rev1_hardlinks = xstrdup (n->data);
	}
    }

    /* Obtain file information for REV2. */
    if (rev2 == NULL)
    {
	if (islink (finfo->file))
	    rev2_symlink = xreadlink (finfo->file);
	else
	{
	    if (CVS_LSTAT (finfo->file, &sb) < 0)
		error (1, errno, "could not get file information for %s",
		       finfo->file);
	    rev2_uid = sb.st_uid;
	    rev2_gid = sb.st_gid;
	    rev2_mode = sb.st_mode;
	    if (S_ISBLK (rev2_mode) || S_ISCHR (rev2_mode))
		rev2_dev = sb.st_rdev;
	}
	rev2_hardlinks = list_files_linked_to (finfo->file);
    }
    else
    {
	n = findnode (finfo->rcs->versions, rev2);
	vp = (RCSVers *) n->data;

	n = findnode (vp->other_delta, "symlink");
	if (n != NULL)
	    rev2_symlink = xstrdup (n->data);
	else
	{
	    n = findnode (vp->other_delta, "owner");
	    if (n == NULL)
		check_uids = 0;	/* don't care */
	    else
		rev2_uid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "group");
	    if (n == NULL)
		check_gids = 0;	/* don't care */
	    else
		rev2_gid = strtoul (n->data, NULL, 10);

	    n = findnode (vp->other_delta, "permissions");
	    if (n == NULL)
		check_modes = 0;	/* don't care */
	    else
		rev2_mode = strtoul (n->data, NULL, 8);

	    n = findnode (vp->other_delta, "special");
	    if (n == NULL)
		rev2_mode |= S_IFREG;
	    else
	    {
		/* If the size of `ftype' changes, fix the sscanf call also */
		char ftype[16];
		if (sscanf (n->data, "%16s %lu", ftype,
			    &dev_long) < 2)
		    error (1, 0, "%s:%s has bad `special' newphrase %s",
			   finfo->file, rev2, n->data);
		rev2_dev = dev_long;
		if (strcmp (ftype, "character") == 0)
		    rev2_mode |= S_IFCHR;
		else if (strcmp (ftype, "block") == 0)
		    rev2_mode |= S_IFBLK;
		else
		    error (0, 0, "%s:%s unknown file type `%s'",
			   finfo->file, rev2, ftype);
	    }

	    n = findnode (vp->other_delta, "hardlinks");
	    if (n == NULL)
		rev2_hardlinks = xstrdup ("");
	    else
		rev2_hardlinks = xstrdup (n->data);
	}
    }

    /* Check the user/group ownerships and file permissions, printing
       an error for each mismatch found.  Return 0 if all characteristics
       matched, and 1 otherwise. */

    result = 0;

    /* Compare symlinks first, since symlinks are simpler (don't have
       any other characteristics). */
    if (rev1_symlink != NULL && rev2_symlink == NULL)
    {
	error (0, 0, "%s is a symbolic link",
	       (rev1 == NULL ? "working file" : rev1));
	result = 1;
    }
    else if (rev1_symlink == NULL && rev2_symlink != NULL)
    {
	error (0, 0, "%s is a symbolic link",
	       (rev2 == NULL ? "working file" : rev2));
	result = 1;
    }
    else if (rev1_symlink != NULL)
	result = (strcmp (rev1_symlink, rev2_symlink) == 0);
    else
    {
	/* Compare user ownership. */
	if (check_uids && rev1_uid != rev2_uid)
	{
	    error (0, 0, "%s: owner mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}

	/* Compare group ownership. */
	if (check_gids && rev1_gid != rev2_gid)
	{
	    error (0, 0, "%s: group mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
    
	/* Compare permissions. */
	if (check_modes &&
	    (rev1_mode & 07777) != (rev2_mode & 07777))
	{
	    error (0, 0, "%s: permission mismatch between %s and %s",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}

	/* Compare device file characteristics. */
	if ((rev1_mode & S_IFMT) != (rev2_mode & S_IFMT))
	{
	    error (0, 0, "%s: %s and %s are different file types",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
	else if (S_ISBLK (rev1_mode))
	{
	    if (rev1_dev != rev2_dev)
	    {
		error (0, 0, "%s: device numbers of %s and %s do not match",
		       finfo->file,
		       (rev1 == NULL ? "working file" : rev1),
		       (rev2 == NULL ? "working file" : rev2));
		result = 1;
	    }
	}

	/* Compare hard links. */
	if (strcmp (rev1_hardlinks, rev2_hardlinks) != 0)
	{
	    error (0, 0, "%s: hard linkage of %s and %s do not match",
		   finfo->file,
		   (rev1 == NULL ? "working file" : rev1),
		   (rev2 == NULL ? "working file" : rev2));
	    result = 1;
	}
    }

    if (rev1_symlink != NULL)
	free (rev1_symlink);
    if (rev2_symlink != NULL)
	free (rev2_symlink);
    if (rev1_hardlinks != NULL)
	free (rev1_hardlinks);
    if (rev2_hardlinks != NULL)
	free (rev2_hardlinks);

    return result;
#else
    return 0;
#endif
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d533 1
d2497 2
a2498 2
    List *rev1_hardlinks;
    List *rev2_hardlinks;
d2536 1
a2536 1
	rev1_hardlinks = list_linked_files_on_disk (finfo->file);
d2587 5
a2591 3
	    rev1_hardlinks = vp->hardlinks;
	    if (rev1_hardlinks == NULL)
		rev1_hardlinks = getlist();
d2611 1
a2611 1
	rev2_hardlinks = list_linked_files_on_disk (finfo->file);
d2662 5
a2666 3
	    rev2_hardlinks = vp->hardlinks;
	    if (rev2_hardlinks == NULL)
		rev2_hardlinks = getlist();
d2747 1
a2747 1
	if (compare_linkage_lists (rev1_hardlinks, rev2_hardlinks) == 0)
d2762 1
a2762 1
	dellist (&rev1_hardlinks);
d2764 1
a2764 1
	dellist (&rev2_hardlinks);
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d1641 2
d1651 2
a1652 4
	    /* We use -c, not -u, because that is what CVS has
	       traditionally used.  Kind of a moot point, now that
	       Rcs-diff is preferred, so there is no point in making
	       the compatibility issues worse.  */
d1924 1
a1924 4

    /* This file is the result of a merge, which means that it has
       been modified.  We use a special timestamp string which will
       not compare equal to any actual timestamp.  */
a1928 2
	{
	    (void) time (&last_register_time);
d1930 2
a1931 4
	}
	Register (finfo->entries, finfo->file, vers->vn_rcs,
		  "Result of merge", vers->options, vers->tag,
		  vers->date, cp);
d2430 11
a2440 10
    /* The file has changed, but if we just checked it out it may
       still have the same timestamp it did when it was first
       registered above in checkout_file.  We register it again with a
       dummy timestamp to make sure that later runs of CVS will
       recognize that it has changed.

       We don't actually need to register again if we called
       RCS_checkout above, and we aren't running as the server.
       However, that is not the normal case, and calling Register
       again won't cost much in that case.  */
a2444 2
	{
	    (void) time (&last_register_time);
d2446 3
a2448 4
	}
	Register (finfo->entries, finfo->file, vers->vn_rcs,
		  "Result of merge", vers->options, vers->tag,
		  vers->date, cp);
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d4 1
a4 1
 *
d7 1
a7 1
 *
d11 1
a11 1
 *
d14 1
a14 1
 *
d17 1
a17 1
 *
d20 1
a20 1
 *
d26 1
a26 1
 *
d29 1
a29 1
 *
d287 1
a291 1
		send_file_names (argc, argv, SEND_EXPAND_WILD);
d307 2
a308 4
		    if (unlink_file (failed_patches[i]) < 0
			&& !existence_error (errno))
			error (0, errno, "cannot remove %s",
			       failed_patches[i]);
a310 1
		send_file_names (failed_patches_count, failed_patches, 0);
d634 9
a642 1
		retval = merge_file (finfo, vers);
a876 22
	/* Various CVS administrators are in the habit of removing
	   the repository directory for things they don't want any
	   more.  I've even been known to do it myself (on rare
	   occasions).  Not the usual recommended practice, but we
	   want to try to come up with some kind of
	   reasonable/documented/sensible behavior.  Generally
	   the behavior is to just skip over that directory (see
	   dirs test in sanity.sh; the case which reaches here
	   is when update -d is specified, and the working directory
	   is gone but the subdirectory is still mentioned in
	   CVS/Entries).  */
	if (1
#ifdef SERVER_SUPPORT
	    /* In the remote case, the client should refrain from
	       sending us the directory in the first place.  So we
	       want to continue to give an error, so clients make
	       sure to do this.  */
	    && !server_active
#endif
	    && !isdir (repository))
	    return R_SKIP_ALL;

d1288 1
a1288 1
	    if (revbuf != NULL && !noexec)
d1292 1
a1292 4
		/* FIXME: We should have RCS_checkout return the mode.
		   That would also fix the kludge with noexec, above, which
		   is here only because noexec doesn't write srcfile->path
		   for us to stat.  */
d1492 1
a1492 1
    struct cvs_MD5Context context;
d1571 1
a1571 5
    {
	if (unlink_file (backup) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", backup);
    }
d1620 1
a1620 1
	cvs_MD5Init (&data.context);
d1633 1
a1633 1
	    cvs_MD5Final (checksum, &data.context);
d1758 3
a1760 9
    if (unlink_file (backup) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", backup);
    if (unlink_file (file1) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", file1);
    if (unlink_file (file2) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", file2);
d1786 1
a1786 1
	cvs_MD5Update (&data->context, (unsigned char *) buffer, len);
d1862 1
a1862 2
    if (unlink_file (backup) && !existence_error (errno))
	error (0, errno, "unable to remove %s", backup);
a1964 2
    /* FIXME: the noexec case is broken.  RCS_merge could be doing the
       xcmp on the temporary files without much hassle, I think.  */
d1967 2
a1968 7
	cvs_output (finfo->fullname, 0);
	cvs_output (" already contains the differences between ", 0);
	cvs_output (vers->vn_user, 0);
	cvs_output (" and ", 0);
	cvs_output (vers->vn_rcs, 0);
	cvs_output ("\n", 1);

d1977 2
a1978 1
	error (0, 0, "conflicts found in %s", finfo->fullname);
d2329 1
a2329 3
    if (unlink_file (backup) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", backup);
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@d492 2
a493 4
	for (;;)
	{
	    (void) time (&now);
	    if (now != last_register_time) break;
a494 1
	}
d1647 1
a1647 1
				vers_ts->vn_rcs, vers_ts->vn_tag,
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@a96 1
static int toss_local_changes = 0;
a112 1
    "\t-C\tOverwrite locally modified files with clean repository copies.\n",
d148 1
a148 1
    while ((c = getopt (argc, argv, "+ApCPflRQqduk:r:D:j:I:W:")) != -1)
a154 3
	    case 'C':
		toss_local_changes = 1;
		break;
a254 2
	    if (toss_local_changes)
		send_arg("-C");
d269 11
a279 1
	    if (failed_patches_count == 0)
a280 12
                unsigned int flags = 0;

		/* If the server supports the command "update-patches", that 
		   means that it knows how to handle the -u argument to update,
		   which means to send patches instead of complete files.

		   We don't send -u if failed_patches != NULL, so that the
		   server doesn't try to send patches which will just fail
		   again.  At least currently, the client also clobbers the
		   file and tells the server it is lost, which also will get
		   a full file instead of a patch, but it seems clean to omit
		   -u.  */
d283 1
d285 2
a286 8
                if (update_build_dirs)
                    flags |= SEND_BUILD_DIRS;

                if (toss_local_changes) {
                    flags |= SEND_NO_CONTENTS;
                    flags |= BACKUP_MODIFIED_FILES;
                }

d289 2
a290 2

		send_files (argc, argv, local, aflag, flags);
a313 1
		free_names (&failed_patches_count, failed_patches);
d316 3
d337 1
a337 1
		&& (failed_patches_count == 0 || pass > 1))
a338 2
		if (failed_patches_count > 0)
		    free_names (&failed_patches_count, failed_patches);
d343 1
a343 1
	} while (failed_patches_count > 0);
d369 1
a369 5
	    {
		char *repos = Name_Repository (NULL, NULL);
		server_clear_entstat (".", repos);
		free (repos);
	    }
d376 2
a377 3
	    char *repos = Name_Repository (NULL, NULL);
	    WriteTag ((char *) NULL, tag, date, 0, ".", repos);
	    free (repos);
d487 1
a487 1
    /* see if we need to sleep before returning to avoid time-stamp races */
d490 8
a497 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
d644 17
a660 43
                if (toss_local_changes)
                {
                    char *bakname;
                    bakname = backup_file (finfo->file, vers->vn_user);
                    /* This behavior is sufficiently unexpected to
                       justify overinformativeness, I think. */
#ifdef SERVER_SUPPORT
                    if ((! really_quiet) && (! server_active))
#else /* ! SERVER_SUPPORT */
                    if (! really_quiet)
#endif /* SERVER_SUPPORT */
                        (void) printf ("(Locally modified %s moved to %s)\n",
                                       finfo->file, bakname);
                    free (bakname);

                    /* The locally modified file is still present, but
                       it will be overwritten by the repository copy
                       after this. */
                    status = T_CHECKOUT;
                    retval = checkout_file (finfo, vers, 0, 0, 1);
                }
                else 
                {
                    if (vers->ts_conflict)
                    {
                        char *filestamp;
                        int retcode;

                        /*
                         * If the timestamp has changed and no
                         * conflict indicators are found, it isn't a
                         * 'C' any more.
                         */

#ifdef SERVER_SUPPORT
                        if (server_active)
                            retcode = vers->ts_conflict[0] != '=';
                        else 
                        {
                            filestamp = time_stamp (finfo->file);
                            retcode = strcmp (vers->ts_conflict, filestamp);
                            free (filestamp);
                        }
d662 30
a691 32
                        filestamp = time_stamp (finfo->file);
                        retcode = strcmp (vers->ts_conflict, filestamp);
                        free (filestamp);
#endif

                        if (retcode)
                        {
                            /* The timestamps differ.  But if there
                               are conflict markers print 'C' anyway.  */
                            retcode = !file_has_markers (finfo);
                        }

                        if (!retcode)
                        {
                            write_letter (finfo, 'C');
                            retval = 1;
                        }
                        else
                        {
                            /* Reregister to clear conflict flag. */
                            Register (finfo->entries, finfo->file, 
                                      vers->vn_rcs, vers->ts_rcs,
                                      vers->options, vers->tag,
                                      vers->date, (char *)0);
                        }
                    }
                    if (!retval)
                    {
                        write_letter (finfo, 'M');
                        retval = 0;
                    }
                }
d931 1
a931 2
			  0,
			  1);
a1016 4
    /* Delete the ignore list if it hasn't already been done.  */
    if (ignlist)
	dellist (&ignlist);

a1061 1
	    cvs_flushout ();
d2052 1
a2052 1
    char *t_options;
a2286 7
	    /* Reset any keyword expansion option.  Otherwise, when a
	       command like `cvs update -kk -jT1 -jT2' creates a new file
	       (because a file had the T2 tag, but not T1), the subsequent
	       commit of that just-added file effectively would set the
	       admin `-kk' option for that file in the repository.  */
	    options = NULL;

d2329 1
a2329 1
		   "file %s does not exist, but is present in revision %s as of %s",
d2333 1
a2333 1
		   "file %s does not exist, but is present in revision %s",
d2375 1
a2375 1
    t_options = vers->options;
d2377 2
a2378 2
    if (*t_options == '\0')
	t_options = "-kk";		/* to ignore keyword expansions */
d2396 1
a2396 1
	&& (strcmp (t_options, "-kb") == 0
d2401 1
a2401 1
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, t_options,
d2425 1
a2425 1
    else if (strcmp (t_options, "-kb") == 0
d2435 1
a2435 1
	if (RCS_checkout (finfo->rcs, finfo->file, rev2, NULL, t_options,
d2466 1
a2466 1
			    t_options, rev1, rev2);
d2497 3
a2499 3
	Register (finfo->entries, finfo->file,
		  vers->vn_rcs ? vers->vn_rcs : "0", "Result of merge",
		  vers->options, vers->tag, vers->date, cp);
d2547 2
a2548 2
    List *rev1_hardlinks = NULL;
    List *rev2_hardlinks = NULL;
a2576 1
#ifdef HAVE_ST_RDEV
a2584 4
#else
	    error (1, 0, "cannot handle device files on this system (%s)",
		   finfo->file);
#endif
a2649 1
#ifdef HAVE_ST_RDEV
a2657 4
#else
	    error (1, 0, "cannot handle device files on this system (%s)",
		   finfo->file);
#endif
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d61 1
a61 1
static int scratch_file PROTO((struct file_info *finfo, Vers_TS *vers));
a101 1
static int dotemplate = 0;
d110 1
a110 1
    "Usage: %s %s [-APCdflRp] [-k kopt] [-r rev] [-D date] [-j rev]\n",
d120 1
a120 1
    "\t-k kopt\tUse RCS kopt -k option on checkout. (is sticky)\n",
d236 1
a236 1
    if (current_parsed_root->isremote) 
d412 1
a412 1
		     pipeout, which, join_rev1, join_rev2, (char *) NULL, 1);
d426 1
a426 2
	   xprune, xpipeout, which, xjoin_rev1, xjoin_rev2, preload_update_dir,
	   xdotemplate)
a441 1
    int xdotemplate;
a454 1
    dotemplate = xdotemplate;
a505 5
#ifdef SERVER_SUPPORT
    if (server_active)
	return err;
#endif

d509 2
a510 1
	sleep_past (last_register_time);
d578 3
d626 1
d628 1
d653 2
a654 6
		if (! toss_local_changes)
		{
		    retval = merge_file (finfo, vers);
		    break;
		}
		/* else FALL THROUGH */
d734 1
a735 1
#ifdef SERVER_SUPPORT
a756 1
#endif
d761 1
d774 12
a785 1
		retval = scratch_file (finfo, vers);
d800 1
a800 1
    if (ignlist && (status != T_UNKNOWN || vers->ts_user == NULL))
d880 1
a880 1
	    Create_Root ((char *) NULL, current_parsed_root->original);
d973 1
a973 1
			  dotemplate);
d1176 1
a1176 1
    while ((dp = CVS_READDIR (dirp)) != NULL)
d1185 1
a1185 1
		(void) CVS_CLOSEDIR (dirp);
d1216 1
a1216 1
		    (void) CVS_CLOSEDIR (dirp);
d1226 1
a1226 1
	(void) CVS_CLOSEDIR (dirp);
d1229 1
a1229 1
    (void) CVS_CLOSEDIR (dirp);
d1237 1
a1237 1
scratch_file (finfo, vers)
a1238 1
    Vers_TS *vers;
a1241 11
#ifdef SERVER_SUPPORT
    if (server_active)
    {
	if (vers->ts_user == NULL)
	    server_scratch_entry_only ();
	server_updated (finfo, vers,
		SERVER_UPDATED, (mode_t) -1,
		(unsigned char *) NULL,
		(struct buffer *) NULL);
    }
#endif
a1243 21
    else
#ifdef SERVER_SUPPORT
	/* skip this step when the server is running since
	 * server_updated should have handled it */
	if (!server_active)
#endif
    {
	/* keep the vers structure up to date in case we do a join
	 * - if there isn't a file, it can't very well have a version number, can it?
	 */
	if (vers->vn_user != NULL)
	{
	    free (vers->vn_user);
	    vers->vn_user = NULL;
	}
	if (vers->ts_user != NULL)
	{
	    free (vers->ts_user);
	    vers->ts_user = NULL;
	}
    }
d1743 1
a1743 1
	retcode = diff_exec (file1, file2, NULL, NULL, diff_options, finfo->file);
a2108 11
    if (trace)
	fprintf (stderr, "%s-> join_file(%s, %s%s%s%s, %s, %s)\n",
		CLIENT_SERVER_STR,
		finfo->file,
		vers->tag ? vers->tag : "",
		vers->tag ? " (" : "",
		vers->vn_rcs ? vers->vn_rcs : "",
		vers->tag ? ")" : "",
		join_rev1 ? join_rev1 : "",
		join_rev2 ? join_rev2 : "");

d2277 1
a2277 8
           removal. 
	
	   The same goes for a removal then an add.  e.g.
	   cvs up -rbr -jbr2 could remove and readd the same file
	 */
	/* save the rev since server_updated might invalidate it */
	mrev = xmalloc (strlen (vers->vn_user) + 2);
	sprintf (mrev, "-%s", vers->vn_user);
d2286 2
a2329 1
	    char *saved_options = options;
a2343 1
	    options = saved_options;
@


