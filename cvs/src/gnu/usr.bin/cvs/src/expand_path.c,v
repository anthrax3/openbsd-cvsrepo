head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.20
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.18
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.14
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.10
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.12
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.4
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.1.1.8.0.48
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.46
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.44
	OPENBSD_5_0:1.1.1.8.0.42
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.40
	OPENBSD_4_9_BASE:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.38
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.34
	OPENBSD_4_7_BASE:1.1.1.8
	OPENBSD_4_6:1.1.1.8.0.36
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.32
	OPENBSD_4_5_BASE:1.1.1.8
	OPENBSD_4_4:1.1.1.8.0.30
	OPENBSD_4_4_BASE:1.1.1.8
	OPENBSD_4_3:1.1.1.8.0.28
	OPENBSD_4_3_BASE:1.1.1.8
	OPENBSD_4_2:1.1.1.8.0.26
	OPENBSD_4_2_BASE:1.1.1.8
	OPENBSD_4_1:1.1.1.8.0.24
	OPENBSD_4_1_BASE:1.1.1.8
	OPENBSD_4_0:1.1.1.8.0.22
	OPENBSD_4_0_BASE:1.1.1.8
	OPENBSD_3_9:1.1.1.8.0.20
	OPENBSD_3_9_BASE:1.1.1.8
	OPENBSD_3_8:1.1.1.8.0.18
	OPENBSD_3_8_BASE:1.1.1.8
	OPENBSD_3_7:1.1.1.8.0.16
	OPENBSD_3_7_BASE:1.1.1.8
	OPENBSD_3_6:1.1.1.8.0.14
	OPENBSD_3_6_BASE:1.1.1.8
	OPENBSD_3_5:1.1.1.8.0.12
	OPENBSD_3_5_BASE:1.1.1.8
	OPENBSD_3_4:1.1.1.8.0.10
	OPENBSD_3_4_BASE:1.1.1.8
	OPENBSD_3_3:1.1.1.8.0.8
	OPENBSD_3_3_BASE:1.1.1.8
	OPENBSD_3_2:1.1.1.8.0.6
	OPENBSD_3_2_BASE:1.1.1.8
	OPENBSD_3_1:1.1.1.8.0.4
	OPENBSD_3_1_BASE:1.1.1.8
	OPENBSD_3_0:1.1.1.8.0.2
	OPENBSD_3_0_BASE:1.1.1.8
	cvs-1-11-1p1:1.1.1.8
	OPENBSD_2_9:1.1.1.7.0.10
	OPENBSD_2_9_BASE:1.1.1.7
	cvs-1-11:1.1.1.7
	OPENBSD_2_8:1.1.1.7.0.8
	OPENBSD_2_8_BASE:1.1.1.7
	OPENBSD_2_7:1.1.1.7.0.6
	OPENBSD_2_7_BASE:1.1.1.7
	OPENBSD_2_6:1.1.1.7.0.4
	OPENBSD_2_6_BASE:1.1.1.7
	cvs-1-10-7:1.1.1.7
	OPENBSD_2_5:1.1.1.7.0.2
	OPENBSD_2_5_BASE:1.1.1.7
	cvs-1-10-5:1.1.1.7
	OPENBSD_2_4:1.1.1.6.0.4
	OPENBSD_2_4_BASE:1.1.1.6
	cvs-1-10:1.1.1.6
	cvs-1-9-28:1.1.1.6
	OPENBSD_2_3:1.1.1.6.0.2
	OPENBSD_2_3_BASE:1.1.1.6
	cvs-1-9-26:1.1.1.6
	cvs-1-9-24:1.1.1.6
	OPENBSD_2_2:1.1.1.5.0.4
	OPENBSD_2_2_BASE:1.1.1.5
	cvs-1-9-10:1.1.1.5
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.4
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.06.03.17.02.36;	author jcs;	state Exp;
branches;
next	1.1;

1.1
date	96.01.30.00.18.06;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.18.06;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.41.50;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.19.31;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.32;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.03.18.01.56.03;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.02.22.08.21.11;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.02.28.21.32.53;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@backport commitid support from newer CVS (with a different random id
generator)

writing a commitid is currently disabled

ok deraadt
@
text
@/* expand_path.c -- expand environmental variables in passed in string
 *
 * The main routine is expand_path(), it is the routine that handles
 * the '~' character in four forms: 
 *     ~name
 *     ~name/
 *     ~/
 *     ~
 * and handles environment variables contained within the pathname
 * which are defined by:
 *     ${var_name}   (var_name is the name of the environ variable)
 *     $var_name     (var_name ends w/ non-alphanumeric char other than '_')
 */

#include "cvs.h"
#include <sys/types.h>

static char *expand_variable PROTO((char *env, char *file, int line));


/* User variables.  */

List *variable_list = NULL;

static void variable_delproc PROTO ((Node *));

static void
variable_delproc (node)
    Node *node;
{
    free (node->data);
}

/* Currently used by -s option; we might want a way to set user
   variables in a file in the $CVSROOT/CVSROOT directory too.  */

void
variable_set (nameval)
    char *nameval;
{
    char *p;
    char *name;
    Node *node;

    p = nameval;
    while (isalnum ((unsigned char) *p) || *p == '_')
	++p;
    if (*p != '=')
	error (1, 0, "illegal character in user variable name in %s", nameval);
    if (p == nameval)
	error (1, 0, "empty user variable name in %s", nameval);
    name = xmalloc (p - nameval + 1);
    strncpy (name, nameval, p - nameval);
    name[p - nameval] = '\0';
    /* Make p point to the value.  */
    ++p;
    if (strchr (p, '\012') != NULL)
	error (1, 0, "linefeed in user variable value in %s", nameval);

    if (variable_list == NULL)
	variable_list = getlist ();

    node = findnode (variable_list, name);
    if (node == NULL)
    {
	node = getnode ();
	node->type = VARIABLE;
	node->delproc = variable_delproc;
	node->key = name;
	node->data = xstrdup (p);
	(void) addnode (variable_list, node);
    }
    else
    {
	/* Replace the old value.  For example, this means that -s
	   options on the command line override ones from .cvsrc.  */
	free (node->data);
	node->data = xstrdup (p);
	free (name);
    }
}

/* This routine will expand the pathname to account for ~ and $
   characters as described above.  Returns a pointer to a newly
   malloc'd string.  If an error occurs, an error message is printed
   via error() and NULL is returned.  FILE and LINE are the filename
   and linenumber to include in the error message.  FILE must point
   to something; LINE can be zero to indicate the line number is not
   known.  */
char *
expand_path (name, file, line)
    char *name;
    char *file;
    int line;
{
    char *s;
    char *d;

    char *mybuf = NULL;
    size_t mybuf_size = 0;
    char *buf = NULL;
    size_t buf_size = 0;

    size_t doff;

    char *result;

    /* Sorry this routine is so ugly; it is a head-on collision
       between the `traditional' unix *d++ style and the need to
       dynamically allocate.  It would be much cleaner (and probably
       faster, not that this is a bottleneck for CVS) with more use of
       strcpy & friends, but I haven't taken the effort to rewrite it
       thusly.  */

    /* First copy from NAME to MYBUF, expanding $<foo> as we go.  */
    s = name;
    d = mybuf;
    doff = d - mybuf;
    expand_string (&mybuf, &mybuf_size, doff + 1);
    d = mybuf + doff;
    while ((*d++ = *s))
    {
	if (*s++ == '$')
	{
	    char *p = d;
	    char *e;
	    int flag = (*s == '{');

	    doff = d - mybuf;
	    expand_string (&mybuf, &mybuf_size, doff + 1);
	    d = mybuf + doff;
	    for (; (*d++ = *s); s++)
	    {
		if (flag
		    ? *s =='}'
		    : isalnum ((unsigned char) *s) == 0 && *s != '_')
		    break;
		doff = d - mybuf;
		expand_string (&mybuf, &mybuf_size, doff + 1);
		d = mybuf + doff;
	    }
	    *--d = '\0';
	    e = expand_variable (&p[flag], file, line);

	    if (e)
	    {
		doff = d - mybuf;
		expand_string (&mybuf, &mybuf_size, doff + 1);
		d = mybuf + doff;
		for (d = &p[-1]; (*d++ = *e++);)
		{
		    doff = d - mybuf;
		    expand_string (&mybuf, &mybuf_size, doff + 1);
		    d = mybuf + doff;
		}
		--d;
		if (flag && *s)
		    s++;
	    }
	    else
		/* expand_variable has already printed an error message.  */
		goto error_exit;
	}
	doff = d - mybuf;
	expand_string (&mybuf, &mybuf_size, doff + 1);
	d = mybuf + doff;
    }
    doff = d - mybuf;
    expand_string (&mybuf, &mybuf_size, doff + 1);
    d = mybuf + doff;
    *d = '\0';

    /* Then copy from MYBUF to BUF, expanding ~.  */
    s = mybuf;
    d = buf;
    /* If you don't want ~username ~/ to be expanded simply remove
     * This entire if statement including the else portion
     */
    if (*s++ == '~')
    {
	char *t;
	char *p=s;
	if (*s=='/' || *s==0)
	    t = get_homedir ();
	else
	{
#ifdef GETPWNAM_MISSING
	    for (; *p!='/' && *p; p++)
		;
	    *p = 0;
	    if (line != 0)
		error (0, 0,
		       "%s:%d:tilde expansion not supported on this system",
		       file, line);
	    else
		error (0, 0, "%s:tilde expansion not supported on this system",
		       file);
	    return NULL;
#else
	    struct passwd *ps;
	    for (; *p!='/' && *p; p++)
		;
	    *p = 0;
	    ps = getpwnam (s);
	    if (ps == 0)
	    {
		if (line != 0)
		    error (0, 0, "%s:%d: no such user %s",
			   file, line, s);
		else
		    error (0, 0, "%s: no such user %s", file, s);
		return NULL;
	    }
	    t = ps->pw_dir;
#endif
	}
	if (t == NULL)
	    error (1, 0, "cannot find home directory");

	doff = d - buf;
	expand_string (&buf, &buf_size, doff + 1);
	d = buf + doff;
	while ((*d++ = *t++))
	{
	    doff = d - buf;
	    expand_string (&buf, &buf_size, doff + 1);
	    d = buf + doff;
	}
	--d;
	if (*p == 0)
	    *p = '/';	       /* always add / */
	s=p;
    }
    else
	--s;
	/* Kill up to here */
    doff = d - buf;
    expand_string (&buf, &buf_size, doff + 1);
    d = buf + doff;
    while ((*d++ = *s++))
    {
	doff = d - buf;
	expand_string (&buf, &buf_size, doff + 1);
	d = buf + doff;
    }
    doff = d - buf;
    expand_string (&buf, &buf_size, doff + 1);
    d = buf + doff;
    *d = '\0';

    /* OK, buf contains the value we want to return.  Clean up and return
       it.  */
    free (mybuf);
    /* Save a little memory with xstrdup; buf will tend to allocate
       more than it needs to.  */
    result = xstrdup (buf);
    free (buf);
    return result;

 error_exit:
    if (mybuf != NULL)
	free (mybuf);
    if (buf != NULL)
	free (buf);
    return NULL;
}

static char *
expand_variable (name, file, line)
    char *name;
    char *file;
    int line;
{
    if (strcmp (name, CVSROOT_ENV) == 0)
	return current_parsed_root->original;
    else if (strcmp (name, "RCSBIN") == 0)
    {
	error (0, 0, "RCSBIN internal variable is no longer supported");
	return NULL;
    }
    else if (strcmp (name, EDITOR1_ENV) == 0)
	return Editor;
    else if (strcmp (name, EDITOR2_ENV) == 0)
	return Editor;
    else if (strcmp (name, EDITOR3_ENV) == 0)
	return Editor;
    else if (strcmp (name, "USER") == 0)
	return getcaller ();
    else if (strcmp (name, "SESSIONID") == 0 || strcmp (name, "COMMITID") == 0)
	return global_session_id;
    else if (isalpha ((unsigned char) name[0]))
    {
	/* These names are reserved for future versions of CVS,
	   so that is why it is an error.  */
	if (line != 0)
	    error (0, 0, "%s:%d: no such internal variable $%s",
		   file, line, name);
	else
	    error (0, 0, "%s: no such internal variable $%s",
		   file, name);
	return NULL;
    }
    else if (name[0] == '=')
    {
	Node *node;
	/* Crazy syntax for a user variable.  But we want
	   *something* that lets the user name a user variable
	   anything he wants, without interference from
	   (existing or future) internal variables.  */
	node = findnode (variable_list, name + 1);
	if (node == NULL)
	{
	    if (line != 0)
		error (0, 0, "%s:%d: no such user variable ${%s}",
		       file, line, name);
	    else
		error (0, 0, "%s: no such user variable ${%s}",
		       file, name);
	    return NULL;
	}
	return node->data;
    }
    else
    {
	/* It is an unrecognized character.  We return an error to
	   reserve these for future versions of CVS; it is plausible
	   that various crazy syntaxes might be invented for inserting
	   information about revisions, branches, etc.  */
	if (line != 0)
	    error (0, 0, "%s:%d: unrecognized variable syntax %s",
		   file, line, name);
	else
	    error (0, 0, "%s: unrecognized variable syntax %s",
		   file, name);
	return NULL;
    }
}
@


1.1
log
@Initial revision
@
text
@d18 72
a89 11
static char *expand_variable PROTO((char *env));
extern char *xmalloc ();
extern void  free ();

/* char *expand_pathname(char *name)
 *
 * This routine will expand the pathname to account for ~
 * and $ characters as described above.  If an error occurs, NULL
 * is returned.
 * Will only expand Built in CVS variables all others are ignored.
 */
d91 1
a91 1
expand_path (name)
d93 2
d96 55
a150 9
	char *s;
	char *d;
	char  mybuf[PATH_MAX];
	char  buf[PATH_MAX];
	char *result;
	s = name;
	d = mybuf;
	while ((*d++ = *s))
		if (*s++ == '$')
d152 3
a154 21
			char *p = d;
			char *e;
			int flag = (*s == '{');
			
			for (; (*d++ = *s); s++)
			    if (flag ? *s =='}' :
					isalnum (*s) == 0 && *s!='_' )
				break;
			*--d = 0;
			e = expand_variable (&p[flag]);
			
			if (e)
			{
			    for (d = &p[-1]; (*d++ = *e++);)
				;
			    --d;
			    if (flag && *s)
				s++;
			}
			else
			    return NULL;	/* no env variable */
d156 30
a185 7
	*d = 0;
	 s = mybuf;
	 d = buf;
	/* If you don't want ~username ~/ to be expanded simply remove
	 * This entire if statement including the else portion
	 */
	if (*s++ == '~')
d187 23
a209 4
		char *t;
		char *p=s;
		if (*s=='/' || *s==0)
		    t = getenv ("HOME");
d211 17
a227 16
		{
			struct passwd *ps;
			for (; *p!='/' && *p; p++)
			    ;
			*p = 0;
			ps = getpwnam (s);
			if (ps == 0)
				return NULL;   /* no such user */
			t = ps->pw_dir;
		    }
		while ((*d++ = *t++))
		    ;
		--d;
		if (*p == 0)
			*p = '/';	       /* always add / */
		s=p;
d229 37
a265 9
	else
	    --s;
	    /* Kill up to here */
	while ((*d++ = *s++))
	    ;
	*d=0;
	result = xmalloc (sizeof(char) * strlen(buf)+1);
	strcpy (result, buf);
	return result;
d267 1
d269 4
a272 2
expand_variable (name)
	char *name;
d274 24
a297 7
	/* There is nothing expanding this function to allow it
	 * to read a file in the $CVSROOT/CVSROOT directory that
	 * says which environmental variables could be expanded
	 * or just say everything is fair game to be expanded
	 */
	if ( strcmp (name, CVSROOT_ENV) == 0 )
		return CVSroot;
d299 33
a331 8
	if ( strcmp (name, RCSBIN_ENV)  == 0 )
		return Rcsbin;
	else
	if ( strcmp (name, EDITOR1_ENV) == 0 )
		return Editor;
	else
	if ( strcmp (name, EDITOR2_ENV) == 0 )
		return Editor;
d333 4
a336 8
	if ( strcmp (name, EDITOR3_ENV) == 0 )
		return Editor;
	else
		return NULL;
		/* The code here could also just
		 * return whatever getenv would
		 * return.
		 */
@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d18 1
a18 1
static char *expand_variable PROTO((char *env, char *file, int line));
d22 7
a28 68

/* User variables.  */

List *variable_list = NULL;

static void variable_delproc PROTO ((Node *));

static void
variable_delproc (node)
    Node *node;
{
    free (node->data);
}

/* Currently used by -s option; we might want a way to set user
   variables in a file in the $CVSROOT/CVSROOT directory too.  */

void
variable_set (nameval)
    char *nameval;
{
    char *p;
    char *name;
    Node *node;

    p = nameval;
    while (isalnum (*p) || *p == '_')
	++p;
    if (*p != '=')
	error (1, 0, "illegal character in user variable name in %s", nameval);
    if (p == nameval)
	error (1, 0, "empty user variable name in %s", nameval);
    name = xmalloc (p - nameval + 1);
    strncpy (name, nameval, p - nameval);
    name[p - nameval] = '\0';
    /* Make p point to the value.  */
    ++p;
    if (strchr (p, '\012') != NULL)
	error (1, 0, "linefeed in user variable value in %s", nameval);

    if (variable_list == NULL)
	variable_list = getlist ();

    node = findnode (variable_list, name);
    if (node == NULL)
    {
	node = getnode ();
	node->type = VARIABLE;
	node->delproc = variable_delproc;
	node->key = name;
	node->data = xstrdup (p);
	(void) addnode (variable_list, node);
    }
    else
    {
	/* Replace the old value.  For example, this means that -s
	   options on the command line override ones from .cvsrc.  */
	free (node->data);
	node->data = xstrdup (p);
	free (name);
    }
}

/* This routine will expand the pathname to account for ~ and $
    characters as described above.  If an error occurs, an error
    message is printed via error() and NULL is returned.  FILE and
    LINE are the filename and linenumber to include in the error
    message.  */
d30 1
a30 1
expand_path (name, file, line)
a31 2
    char *file;
    int line;
d33 39
a71 10
    char *s;
    char *d;
    /* FIXME: arbitrary limit.  */
    char  mybuf[PATH_MAX];
    char  buf[PATH_MAX];
    char *result;
    s = name;
    d = mybuf;
    while ((*d++ = *s))
	if (*s++ == '$')
d73 16
a88 15
	    char *p = d;
	    char *e;
	    int flag = (*s == '{');

	    for (; (*d++ = *s); s++)
		if (flag
		    ? *s =='}'
		    : isalnum (*s) == 0 && *s != '_')
		    break;
	    *--d = 0;
	    e = expand_variable (&p[flag], file, line);

	    if (e)
	    {
		for (d = &p[-1]; (*d++ = *e++);)
d91 3
a93 6
		if (flag && *s)
		    s++;
	    }
	    else
		/* expand_variable has already printed an error message.  */
		return NULL;
a94 12
    *d = 0;
    s = mybuf;
    d = buf;
    /* If you don't want ~username ~/ to be expanded simply remove
     * This entire if statement including the else portion
     */
    if (*s++ == '~')
    {
	char *t;
	char *p=s;
	if (*s=='/' || *s==0)
	    t = get_homedir ();
d96 3
a98 18
	{
	    struct passwd *ps;
	    for (; *p!='/' && *p; p++)
		;
	    *p = 0;
	    ps = getpwnam (s);
	    if (ps == 0)
	    {
		if (line != 0)
		    error (0, 0, "%s:%d: no such user %s",
			   file, line, s);
		else
		    error (0, 0, "%s: no such user %s", file, s);
		return NULL;
	    }
	    t = ps->pw_dir;
	}
	while ((*d++ = *t++))
d100 4
a103 14
	--d;
	if (*p == 0)
	    *p = '/';	       /* always add / */
	s=p;
    }
    else
	--s;
	/* Kill up to here */
    while ((*d++ = *s++))
	;
    *d=0;
    result = xmalloc (sizeof(char) * strlen(buf)+1);
    strcpy (result, buf);
    return result;
a104 1

d106 2
a107 4
expand_variable (name, file, line)
    char *name;
    char *file;
    int line;
d109 25
a133 58
    if (strcmp (name, CVSROOT_ENV) == 0)
	return CVSroot;
    else if (strcmp (name, RCSBIN_ENV)  == 0)
	return Rcsbin;
    else if (strcmp (name, EDITOR1_ENV) == 0)
	return Editor;
    else if (strcmp (name, EDITOR2_ENV) == 0)
	return Editor;
    else if (strcmp (name, EDITOR3_ENV) == 0)
	return Editor;
    else if (strcmp (name, "USER") == 0)
	return getcaller ();
    else if (isalpha (name[0]))
    {
	/* These names are reserved for future versions of CVS,
	   so that is why it is an error.  */
	if (line != 0)
	    error (0, 0, "%s:%d: no such internal variable $%s",
		   file, line, name);
	else
	    error (0, 0, "%s: no such internal variable $%s",
		   file, name);
	return NULL;
    }
    else if (name[0] == '=')
    {
	Node *node;
	/* Crazy syntax for a user variable.  But we want
	   *something* that lets the user name a user variable
	   anything he wants, without interference from
	   (existing or future) internal variables.  */
	node = findnode (variable_list, name + 1);
	if (node == NULL)
	{
	    if (line != 0)
		error (0, 0, "%s:%d: no such user variable ${%s}",
		       file, line, name);
	    else
		error (0, 0, "%s: no such user variable ${%s}",
		       file, name);
	    return NULL;
	}
	return node->data;
    }
    else
    {
	/* It is an unrecognized character.  We return an error to
	   reserve these for future versions of CVS; it is plausible
	   that various crazy syntaxes might be invented for inserting
	   information about revisions, branches, etc.  */
	if (line != 0)
	    error (0, 0, "%s:%d: unrecognized varaible syntax %s",
		   file, line, name);
	else
	    error (0, 0, "%s: unrecognized varaible syntax %s",
		   file, name);
	return NULL;
    }
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@d19 2
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d84 4
a87 6
   characters as described above.  Returns a pointer to a newly
   malloc'd string.  If an error occurs, an error message is printed
   via error() and NULL is returned.  FILE and LINE are the filename
   and linenumber to include in the error message.  FILE must point
   to something; LINE can be zero to indicate the line number is not
   known.  */
d184 1
a184 1
	return CVSroot_original;
d234 1
a234 1
	    error (0, 0, "%s:%d: unrecognized variable syntax %s",
d237 1
a237 1
	    error (0, 0, "%s: unrecognized variable syntax %s",
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d98 3
a100 8

    char *mybuf = NULL;
    size_t mybuf_size = 0;
    char *buf = NULL;
    size_t buf_size = 0;

    size_t doff;

a101 9

    /* Sorry this routine is so ugly; it is a head-on collision
       between the `traditional' unix *d++ style and the need to
       dynamically allocate.  It would be much cleaner (and probably
       faster, not that this is a bottleneck for CVS) with more use of
       strcpy & friends, but I haven't taken the effort to rewrite it
       thusly.  */

    /* First copy from NAME to MYBUF, expanding $<foo> as we go.  */
a103 3
    doff = d - mybuf;
    expand_string (&mybuf, &mybuf_size, doff + 1);
    d = mybuf + doff;
a104 1
    {
a110 3
	    doff = d - mybuf;
	    expand_string (&mybuf, &mybuf_size, doff + 1);
	    d = mybuf + doff;
a111 1
	    {
d116 1
a116 5
		doff = d - mybuf;
		expand_string (&mybuf, &mybuf_size, doff + 1);
		d = mybuf + doff;
	    }
	    *--d = '\0';
a120 3
		doff = d - mybuf;
		expand_string (&mybuf, &mybuf_size, doff + 1);
		d = mybuf + doff;
d122 1
a122 5
		{
		    doff = d - mybuf;
		    expand_string (&mybuf, &mybuf_size, doff + 1);
		    d = mybuf + doff;
		}
d129 1
a129 1
		goto error_exit;
d131 1
a131 10
	doff = d - mybuf;
	expand_string (&mybuf, &mybuf_size, doff + 1);
	d = mybuf + doff;
    }
    doff = d - mybuf;
    expand_string (&mybuf, &mybuf_size, doff + 1);
    d = mybuf + doff;
    *d = '\0';

    /* Then copy from MYBUF to BUF, expanding ~.  */
a160 3
	doff = d - buf;
	expand_string (&buf, &buf_size, doff + 1);
	d = buf + doff;
d162 1
a162 5
	{
	    doff = d - buf;
	    expand_string (&buf, &buf_size, doff + 1);
	    d = buf + doff;
	}
a170 3
    doff = d - buf;
    expand_string (&buf, &buf_size, doff + 1);
    d = buf + doff;
d172 4
a175 17
    {
	doff = d - buf;
	expand_string (&buf, &buf_size, doff + 1);
	d = buf + doff;
    }
    doff = d - buf;
    expand_string (&buf, &buf_size, doff + 1);
    d = buf + doff;
    *d = '\0';

    /* OK, buf contains the value we want to return.  Clean up and return
       it.  */
    free (mybuf);
    /* Save a little memory with xstrdup; buf will tend to allocate
       more than it needs to.  */
    result = xstrdup (buf);
    free (buf);
a176 7

 error_exit:
    if (mybuf != NULL)
	free (mybuf);
    if (buf != NULL)
	free (buf);
    return NULL;
@


1.1.1.6
log
@Latest version from Cyclic
@
text
@a186 13
#ifdef GETPWNAM_MISSING
	    for (; *p!='/' && *p; p++)
		;
	    *p = 0;
	    if (line != 0)
		error (0, 0,
		       "%s:%d:tilde expansion not supported on this system",
		       file, line);
	    else
		error (0, 0, "%s:tilde expansion not supported on this system",
		       file);
	    return NULL;
#else
a201 1
#endif
d259 2
a260 5
    else if (strcmp (name, "RCSBIN") == 0)
    {
	error (0, 0, "RCSBIN internal variable is no longer supported");
	return NULL;
    }
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d46 1
a46 1
    while (isalnum ((unsigned char) *p) || *p == '_')
d136 1
a136 1
		    : isalnum ((unsigned char) *s) == 0 && *s != '_')
a216 3
	if (t == NULL)
	    error (1, 0, "cannot find home directory");

d286 1
a286 1
    else if (isalpha ((unsigned char) name[0]))
@


1.1.1.8
log
@Latest from Cyclic Software
@
text
@d275 1
a275 1
	return current_parsed_root->original;
@


