head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.66
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.62
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.58
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.60
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.52
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.56
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.54
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.50
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.48
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.46
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.44
	OPENBSD_5_0:1.13.0.42
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.40
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.38
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.34
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.36
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.32
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.30
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.28
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.26
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.24
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.22
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.20
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.18
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.16
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.14
	OPENBSD_3_6_BASE:1.13
	OPENBSD_3_5:1.13.0.12
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.10
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.8
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.6
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.4
	OPENBSD_3_1_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	cvs-1-11-1p1:1.1.1.14
	OPENBSD_2_9:1.12.0.10
	OPENBSD_2_9_BASE:1.12
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	cvs-1-10-7:1.1.1.13
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.21.58.01;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.08.22.21.04.37;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	98.03.12.07.22.44;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	98.02.22.08.56.06;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.06.28.03.45.32;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.04.21.04.41.07;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.03.18.02.09.58;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.02.21.06.54.58;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.10.18.04.19.40;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.31.13.05.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.12.03.31.59;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.21;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.09;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.53;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.47;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.45;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.20;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.38;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.53;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.28;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.59.05;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.08.22.20.53.46;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.33.24;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Merge local changes; work in progress
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * The functions in this file provide an interface for performing 
 * operations directly on RCS files. 
 */

#include "cvs.h"
#include <assert.h>
#include <stdio.h>
#include "diffrun.h"

/* This file, rcs.h, and rcs.c, together sometimes known as the "RCS
   library", are intended to define our interface to RCS files.

   Whether there will also be a version of RCS which uses this
   library, or whether the library will be packaged for uses beyond
   CVS or RCS (many people would like such a thing) is an open
   question.  Some considerations:

   1.  An RCS library for CVS must have the capabilities of the
   existing CVS code which accesses RCS files.  In particular, simple
   approaches will often be slow.

   2.  An RCS library should not use code from the current RCS
   (5.7 and its ancestors).  The code has many problems.  Too few
   comments, too many layers of abstraction, too many global variables
   (the correct number for a library is zero), too much intricately
   interwoven functionality, and too many clever hacks.  Paul Eggert,
   the current RCS maintainer, agrees.

   3.  More work needs to be done in terms of separating out the RCS
   library from the rest of CVS (for example, cvs_output should be
   replaced by a callback, and the declarations should be centralized
   into rcs.h, and probably other such cleanups).

   4.  To be useful for RCS and perhaps for other uses, the library
   may need features beyond those needed by CVS.

   5.  Any changes to the RCS file format *must* be compatible.  Many,
   many tools (not just CVS and RCS) can at least import this format.
   RCS and CVS must preserve the current ability to import/export it
   (preferably improved--magic branches are currently a roadblock).
   See doc/RCSFILES in the CVS distribution for documentation of this
   file format.

   On a related note, see the comments at diff_exec, later in this file,
   for more on the diff library.  */

static void RCS_output_diff_options PROTO ((char *, char *, char *, char *));


/* Stuff to deal with passing arguments the way libdiff.a wants to deal
   with them.  This is a crufty interface; there is no good reason for it
   to resemble a command line rather than something closer to "struct
   log_data" in log.c.  */

/* First call call_diff_setup to setup any initial arguments.  The
   argument will be parsed into whitespace separated words and added
   to the global call_diff_argv list.

   Then, optionally, call call_diff_arg for each additional argument
   that you'd like to pass to the diff library.

   Finally, call call_diff or call_diff3 to produce the diffs.  */

static char **call_diff_argv;
static int call_diff_argc;
static int call_diff_argc_allocated;

static void call_diff_add_arg PROTO ((const char *));
static void call_diff_setup PROTO ((const char *prog));
static int call_diff PROTO ((char *out));
static int call_diff3 PROTO ((char *out));

static void call_diff_write_output PROTO((const char *, size_t));
static void call_diff_flush_output PROTO((void));
static void call_diff_write_stdout PROTO((const char *));
static void call_diff_error PROTO((const char *, const char *, const char *));

/* VARARGS */
static void 
call_diff_setup (prog)
    const char *prog;
{
    char *cp;
    int i;
    char *call_diff_prog;

    /* clean out any malloc'ed values from call_diff_argv */
    for (i = 0; i < call_diff_argc; i++)
    {
	if (call_diff_argv[i])
	{
	    free (call_diff_argv[i]);
	    call_diff_argv[i] = (char *) 0;
	}
    }
    call_diff_argc = 0;

    call_diff_prog = xstrdup (prog);

    /* put each word into call_diff_argv, allocating it as we go */
    for (cp = strtok (call_diff_prog, " \t");
	 cp != NULL;
	 cp = strtok ((char *) NULL, " \t"))
	call_diff_add_arg (cp);
    free (call_diff_prog);
}

static void
call_diff_arg (s)
    const char *s;
{
    call_diff_add_arg (s);
}

static void
call_diff_add_arg (s)
    const char *s;
{
    /* allocate more argv entries if we've run out */
    if (call_diff_argc >= call_diff_argc_allocated)
    {
	call_diff_argc_allocated += 50;
	call_diff_argv = (char **)
	    xrealloc ((char *) call_diff_argv,
		      call_diff_argc_allocated * sizeof (char **));
    }

    if (s)
	call_diff_argv[call_diff_argc++] = xstrdup (s);
    else
	/* Not post-incremented on purpose!  */
	call_diff_argv[call_diff_argc] = (char *) 0;
}

/* Callback function for the diff library to write data to the output
   file.  This is used when we are producing output to stdout.  */

static void
call_diff_write_output (text, len)
    const char *text;
    size_t len;
{
    if (len > 0)
	cvs_output (text, len);
}

/* Call back function for the diff library to flush the output file.
   This is used when we are producing output to stdout.  */

static void
call_diff_flush_output ()
{
    cvs_flushout ();
}

/* Call back function for the diff library to write to stdout.  */

static void
call_diff_write_stdout (text)
    const char *text;
{
    cvs_output (text, 0);
}

/* Call back function for the diff library to write to stderr.  */

static void
call_diff_error (format, a1, a2)
    const char *format;
    const char *a1;
    const char *a2;
{
    /* FIXME: Should we somehow indicate that this error is coming from
       the diff library?  */
    error (0, 0, format, a1, a2);
}

/* This set of callback functions is used if we are sending the diff
   to stdout.  */

static struct diff_callbacks call_diff_stdout_callbacks =
{
    call_diff_write_output,
    call_diff_flush_output,
    call_diff_write_stdout,
    call_diff_error
};

/* This set of callback functions is used if we are sending the diff
   to a file.  */

static struct diff_callbacks call_diff_file_callbacks =
{
    (void (*) PROTO((const char *, size_t))) NULL,
    (void (*) PROTO((void))) NULL,
    call_diff_write_stdout,
    call_diff_error
};

static int
call_diff (out)
    char *out;
{
    if (out == RUN_TTY)
	return diff_run (call_diff_argc, call_diff_argv, NULL,
			 &call_diff_stdout_callbacks);
    else
	return diff_run (call_diff_argc, call_diff_argv, out,
			 &call_diff_file_callbacks);
}

static int
call_diff3 (out)
    char *out;
{
    if (out == RUN_TTY)
	return diff3_run (call_diff_argc, call_diff_argv, NULL,
			  &call_diff_stdout_callbacks);
    else
	return diff3_run (call_diff_argc, call_diff_argv, out,
			  &call_diff_file_callbacks);
}



/* Merge revisions REV1 and REV2. */

int
RCS_merge(rcs, path, workfile, options, rev1, rev2)
    RCSNode *rcs;
    char *path;
    char *workfile;
    char *options;
    char *rev1;
    char *rev2;
{
    char *xrev1, *xrev2;
    char *tmp1, *tmp2;
    char *diffout = NULL;
    int retval;

    if (options != NULL && options[0] != '\0')
      assert (options[0] == '-' && options[1] == 'k');

    cvs_output ("RCS file: ", 0);
    cvs_output (rcs->path, 0);
    cvs_output ("\n", 1);

    /* Calculate numeric revision numbers from rev1 and rev2 (may be
       symbolic). */
    xrev1 = RCS_gettag (rcs, rev1, 0, NULL);
    xrev2 = RCS_gettag (rcs, rev2, 0, NULL);

    /* Check out chosen revisions.  The error message when RCS_checkout
       fails is not very informative -- it is taken verbatim from RCS 5.7,
       and relies on RCS_checkout saying something intelligent upon failure. */
    cvs_output ("retrieving revision ", 0);
    cvs_output (xrev1, 0);
    cvs_output ("\n", 1);

    tmp1 = cvs_temp_name();
    if (RCS_checkout (rcs, NULL, xrev1, rev1, options, tmp1,
		      (RCSCHECKOUTPROC)0, NULL))
    {
	cvs_outerr ("rcsmerge: co failed\n", 0);
	error_exit();
    }

    cvs_output ("retrieving revision ", 0);
    cvs_output (xrev2, 0);
    cvs_output ("\n", 1);

    tmp2 = cvs_temp_name();
    if (RCS_checkout (rcs, NULL, xrev2, rev2, options, tmp2,
		      (RCSCHECKOUTPROC)0, NULL))
    {
	cvs_outerr ("rcsmerge: co failed\n", 0);
	error_exit();
    }

    /* Merge changes. */
    cvs_output ("Merging differences between ", 0);
    cvs_output (xrev1, 0);
    cvs_output (" and ", 0);
    cvs_output (xrev2, 0);
    cvs_output (" into ", 0);
    cvs_output (workfile, 0);
    cvs_output ("\n", 1);

    /* Remember that the first word in the `call_diff_setup' string is used now
       only for diagnostic messages -- CVS no longer forks to run diff3. */
    diffout = cvs_temp_name();
    call_diff_setup ("diff3");
    call_diff_arg ("-E");
    call_diff_arg ("-am");

    call_diff_arg ("-L");
    call_diff_arg (workfile);
    call_diff_arg ("-L");
    call_diff_arg (xrev1);
    call_diff_arg ("-L");
    call_diff_arg (xrev2);

    call_diff_arg (workfile);
    call_diff_arg (tmp1);
    call_diff_arg (tmp2);

    retval = call_diff3 (diffout);

    if (retval == 1)
	cvs_outerr ("rcsmerge: warning: conflicts during merge\n", 0);
    else if (retval == 2)
	error_exit();

    if (diffout)
	copy_file (diffout, workfile);

    /* Clean up. */
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmp1) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmp1);
	}
	free (tmp1);
	if (unlink_file (tmp2) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmp2);
	}
	free (tmp2);
	if (diffout)
	{
	    if (unlink_file (diffout) < 0)
	    {
		if (!existence_error (errno))
		    error (0, errno, "cannot remove temp file %s", diffout);
	    }
	    free (diffout);
	}
	free (xrev1);
	free (xrev2);
	noexec = save_noexec;
    }

    return retval;
}

/* Diff revisions and/or files.  OPTS controls the format of the diff
   (it contains options such as "-w -c", &c), or "" for the default.
   OPTIONS controls keyword expansion, as a string starting with "-k",
   or "" to use the default.  REV1 is the first revision to compare
   against; it must be non-NULL.  If REV2 is non-NULL, compare REV1
   and REV2; if REV2 is NULL compare REV1 with the file in the working
   directory, whose name is WORKFILE.  LABEL1 and LABEL2 are default
   file labels, and (if non-NULL) should be added as -L options
   to diff.  Output goes to stdout.

   Return value is 0 for success, -1 for a failure which set errno,
   or positive for a failure which printed a message on stderr.

   This used to exec rcsdiff, but now calls RCS_checkout and diff_exec.

   An issue is what timezone is used for the dates which appear in the
   diff output.  rcsdiff uses the -z flag, which is not presently
   processed by CVS diff, but I'm not sure exactly how hard to worry
   about this--any such features are undocumented in the context of
   CVS, and I'm not sure how important to users.  */
int
RCS_exec_rcsdiff (rcsfile, opts, options, rev1, rev2, label1, label2, workfile)
    RCSNode *rcsfile;
    char *opts;
    char *options;
    char *rev1;
    char *rev2;
    char *label1;
    char *label2;
    char *workfile;
{
    char *tmpfile1;
    char *tmpfile2;
    char *use_file2;
    int status, retval;

    tmpfile1 = cvs_temp_name ();
    tmpfile2 = NULL;

    cvs_output ("\
===================================================================\n\
RCS file: ", 0);
    cvs_output (rcsfile->path, 0);
    cvs_output ("\n", 1);

    /* Historically, `cvs diff' has expanded the $Name keyword to the
       empty string when checking out revisions.  This is an accident,
       but no one has considered the issue thoroughly enough to determine
       what the best behavior is.  Passing NULL for the `nametag' argument
       preserves the existing behavior. */

    cvs_output ("retrieving revision ", 0);
    cvs_output (rev1, 0);
    cvs_output ("\n", 1);
    status = RCS_checkout (rcsfile, NULL, rev1, NULL, options, tmpfile1,
			   (RCSCHECKOUTPROC)0, NULL);
    if (status > 0)
    {
	retval = status;
	goto error_return;
    }
    else if (status < 0)
    {
	error (0, errno,
	       "cannot check out revision %s of %s", rev1, rcsfile->path);
	retval = 1;
	goto error_return;
    }

    if (rev2 == NULL)
    {
	assert (workfile != NULL);
	use_file2 = workfile;
    }
    else
    {
	tmpfile2 = cvs_temp_name ();
	cvs_output ("retrieving revision ", 0);
	cvs_output (rev2, 0);
	cvs_output ("\n", 1);
	status = RCS_checkout (rcsfile, NULL, rev2, NULL, options,
			       tmpfile2, (RCSCHECKOUTPROC)0, NULL);
	if (status > 0)
	{
	    retval = status;
	    goto error_return;
	}
	else if (status < 0)
	{
	    error (0, errno,
		   "cannot check out revision %s of %s", rev2, rcsfile->path);
	    return 1;
	}
	use_file2 = tmpfile2;
    }

    RCS_output_diff_options (opts, rev1, rev2, workfile);
    status = diff_execv (tmpfile1, use_file2, label1, label2, opts, RUN_TTY);
    if (status >= 0)
    {
	retval = status;
	goto error_return;
    }
    else if (status < 0)
    {
	error (0, errno,
	       "cannot diff %s and %s", tmpfile1, use_file2);
	retval = 1;
	goto error_return;
    }

 error_return:
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmpfile1) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmpfile1);
	}
	noexec = save_noexec;
    }
    free (tmpfile1);
    if (tmpfile2 != NULL)
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmpfile2) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmpfile2);
	}
	noexec = save_noexec;
	free (tmpfile2);
    }

    return retval;
}


/* Show differences between two files.  This is the start of a diff library.

   Some issues:

   * Should option parsing be part of the library or the caller?  The
   former allows the library to add options without changing the callers,
   but it causes various problems.  One is that something like --brief really
   wants special handling in CVS, and probably the caller should retain
   some flexibility in this area.  Another is online help (the library could
   have some feature for providing help, but how does that interact with
   the help provided by the caller directly?).  Another is that as things
   stand currently, there is no separate namespace for diff options versus
   "cvs diff" options like -l (that is, if the library adds an option which
   conflicts with a CVS option, it is trouble).

   * This isn't required for a first-cut diff library, but if there
   would be a way for the caller to specify the timestamps that appear
   in the diffs (rather than the library getting them from the files),
   that would clean up the kludgy utime() calls in patch.c.

   Show differences between FILE1 and FILE2.  Either one can be
   DEVNULL to indicate a nonexistent file (same as an empty file
   currently, I suspect, but that may be an issue in and of itself).
   OPTIONS is a list of diff options, or "" if none.  At a minimum,
   CVS expects that -c (update.c, patch.c) and -n (update.c) will be
   supported.  Other options, like -u, --speed-large-files, &c, will
   be specified if the user specified them.

   OUT is a filename to send the diffs to, or RUN_TTY to send them to
   stdout.  Error messages go to stderr.  Return value is 0 for
   success, -1 for a failure which set errno, 1 for success (and some
   differences were found), or >1 for a failure which printed a
   message on stderr.  */

int
diff_exec (file1, file2, label1, label2, options, out)
    char *file1;
    char *file2;
    char *label1;
    char *label2;
    char *options;
    char *out;
{
    char *args;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If either file1 or file2 are special files, pretend they are
       /dev/null.  Reason: suppose a file that represents a block
       special device in one revision becomes a regular file.  CVS
       must find the `difference' between these files, but a special
       file contains no data useful for calculating this metric.  The
       safe thing to do is to treat the special file as an empty file,
       thus recording the regular file's full contents.  Doing so will
       create extremely large deltas at the point of transition
       between device files and regular files, but this is probably
       very rare anyway.

       There may be ways around this, but I think they are fraught
       with danger. -twp */

    if (preserve_perms &&
	strcmp (file1, DEVNULL) != 0 &&
	strcmp (file2, DEVNULL) != 0)
    {
	struct stat sb1, sb2;

	if (CVS_LSTAT (file1, &sb1) < 0)
	    error (1, errno, "cannot get file information for %s", file1);
	if (CVS_LSTAT (file2, &sb2) < 0)
	    error (1, errno, "cannot get file information for %s", file2);

	if (!S_ISREG (sb1.st_mode) && !S_ISDIR (sb1.st_mode))
	    file1 = DEVNULL;
	if (!S_ISREG (sb2.st_mode) && !S_ISDIR (sb2.st_mode))
	    file2 = DEVNULL;
    }
#endif

    args = xmalloc (strlen (options) + 10);
    /* The first word in this string is used only for error reporting. */
    sprintf (args, "diff %s", options);
    call_diff_setup (args);
    if (label1)
	call_diff_arg (label1);
    if (label2)
	call_diff_arg (label2);
    call_diff_arg (file1);
    call_diff_arg (file2);
    free (args);

    return call_diff (out);
}

int
diff_execv (file1, file2, label1, label2, options, out)
    char *file1;
    char *file2;
    char *label1;
    char *label2;
    char *options;
    char *out;
{
    char *args;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Pretend that special files are /dev/null for purposes of making
       diffs.  See comments in diff_exec. */

    if (preserve_perms &&
	strcmp (file1, DEVNULL) != 0 &&
	strcmp (file2, DEVNULL) != 0)
    {
	struct stat sb1, sb2;

	if (CVS_LSTAT (file1, &sb1) < 0)
	    error (1, errno, "cannot get file information for %s", file1);
	if (CVS_LSTAT (file2, &sb2) < 0)
	    error (1, errno, "cannot get file information for %s", file2);

	if (!S_ISREG (sb1.st_mode) && !S_ISDIR (sb1.st_mode))
	    file1 = DEVNULL;
	if (!S_ISREG (sb2.st_mode) && !S_ISDIR (sb2.st_mode))
	    file2 = DEVNULL;
    }
#endif

    args = xmalloc (strlen (options) + 10);
    /* The first word in this string is used only for error reporting.  */
    /* I guess we are pretty confident that options starts with a space.  */
    sprintf (args, "diff%s", options);
    call_diff_setup (args);
    if (label1)
	call_diff_arg (label1);
    if (label2)
	call_diff_arg (label2);
    call_diff_arg (file1);
    call_diff_arg (file2);
    free (args);

    return call_diff (out);
}

/* Print the options passed to DIFF, in the format used by rcsdiff.
   The rcsdiff code that produces this output is extremely hairy, and
   it is not clear how rcsdiff decides which options to print and
   which not to print.  The code below reproduces every rcsdiff run
   that I have seen. */

static void
RCS_output_diff_options (opts, rev1, rev2, workfile)
    char *opts;
    char *rev1;
    char *rev2;
    char *workfile;
{
    char *tmp;

    tmp = (char *) xmalloc (strlen (opts) + strlen (rev1) + 10);

    sprintf (tmp, "diff%s -r%s", opts, rev1);
    cvs_output (tmp, 0);
    free (tmp);

    if (rev2)
    {
	cvs_output (" -r", 3);
	cvs_output (rev2, 0);
    }
    else
    {
	assert (workfile != NULL);
	cvs_output (" ", 1);
	cvs_output (workfile, 0);
    }
    cvs_output ("\n", 1);
}
@


1.12
log
@Integrate local changes
@
text
@d533 1
a533 1
diff_exec (file1, file2, options, out)
d536 2
d580 4
@


1.11
log
@Integrate local changes
@
text
@d150 2
a151 1
    cvs_output (text, len);
@


1.10
log
@Integrate local changes
@
text
@d14 2
d80 5
d142 63
a204 2
/* diff_run is imported from libdiff.a. */
extern int diff_run PROTO ((int argc, char **argv, char *out));
a209 11
    /* Try to keep the out-of-order bugs at bay (protocol_pipe for cvs_output
       with has "Index: foo" and such; stdout and/or stderr for diff's
       output).  I think the only reason that this used to not be such
       a problem is that the time spent on the fork() and exec() of diff
       slowed us down enough to let the "Index:" make it through first.

       The real fix, of course, will be to have the diff library do all
       its output through callbacks (which CVS will supply as cvs_output
       and cvs_outerr).  */
    sleep (1);

d211 2
a212 1
	return diff_run (call_diff_argc, call_diff_argv, NULL);
d214 2
a215 1
	return diff_run (call_diff_argc, call_diff_argv, out);
a217 2
extern int diff3_run PROTO ((int argc, char **argv, char *out));

a221 11
    /* Try to keep the out-of-order bugs at bay (protocol_pipe for cvs_output
       with has "Index: foo" and such; stdout and/or stderr for diff's
       output).  I think the only reason that this used to not be such
       a problem is that the time spent on the fork() and exec() of diff
       slowed us down enough to let the "Index:" make it through first.

       The real fix, of course, will be to have the diff library do all
       its output through callbacks (which CVS will supply as cvs_output
       and cvs_outerr).  */
    sleep (1);

d223 2
a224 1
	return diff3_run (call_diff_argc, call_diff_argv, NULL);
d226 2
a227 1
	return diff3_run (call_diff_argc, call_diff_argv, out);
@


1.9
log
@Integrate local changes
@
text
@d490 36
a525 1
    char *args = xmalloc (strlen (options) + 10);
d545 25
a569 1
    char *args = xmalloc (strlen (options) + 10);
@


1.8
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d15 2
a16 10
/* This file, rcs.h, and rcs.c, are intended to define our interface
   to RCS files.  As of July, 1996, there are still a few places that
   still exec RCS commands directly.  The intended long-term direction
   is to have CVS access RCS files via an RCS library (rcs.c can be
   considered a start at one), for performance, cleanliness (CVS has
   some awful hacks to work around RCS behaviors which don't make
   sense for CVS), installation hassles, ease of implementing the CVS
   server (I don't think that the output-out-of-order bug can be
   completely fixed as long as CVS calls RCS), and perhaps other
   reasons.
d27 1
a27 1
   2.  An RCS library should not use the code from the current RCS
d49 2
a50 1
   On somewhat related notes:
d52 1
a52 16
   1.  A library for diff is an obvious idea.  The one thing which I'm
   not so sure about is that I think CVS probably wants the ability to
   allow arbitrarily-bizarre (and possibly customized for particular
   file formats) external diff programs.

   2.  A library for patch is another such idea.  CVS's needs are
   smaller than the functionality of the standalone patch program (it
   only calls patch in the client, and only needs to be able to patch
   unmodified versions, which is something that RCS_deltas already
   does in a different context).  But it is silly for CVS to be making
   people install patch as well as CVS for such a simple purpose.  */

/* For RCS file PATH, make symbolic tag TAG point to revision REV.
   This validates that TAG is OK for a user to use.  Return value is
   -1 for error (and errno is set to indicate the error), positive for
   error (and an error message has been printed), or zero for success.  */
d54 126
a179 9
int
RCS_exec_settag(path, tag, rev)
    const char *path;
    const char *tag;
    const char *rev;
{
    run_setup ("%s%s -x,v/ -q -N%s:%s", Rcsbin, RCS, tag, rev);
    run_arg (path);
    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d182 4
a185 2
/* NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  */
d187 7
a193 4
RCS_exec_deltag(path, tag, noerr)
    const char *path;
    const char *tag;
    int noerr;
d195 112
a306 3
    run_setup ("%s%s -x,v/ -q -N%s", Rcsbin, RCS, tag);
    run_arg (path);
    return run_exec (RUN_TTY, RUN_TTY, noerr ? DEVNULL : RUN_TTY, RUN_NORMAL);
d309 20
a328 1
/* set RCS branch to REV */
d330 9
a338 3
RCS_exec_setbranch(path, rev)
    const char *path;
    const char *rev;
d340 106
a445 3
    run_setup ("%s%s -x,v/ -q -b%s", Rcsbin, RCS, rev ? rev : "");
    run_arg (path);
    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d448 35
a482 2
/* Lock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  */
d484 15
a498 8
RCS_exec_lock(path, rev, noerr)
    const char *path;
    const char *rev;
    int noerr;
{
    run_setup ("%s%s -x,v/ -q -l%s", Rcsbin, RCS, rev ? rev : "");
    run_arg (path);
    return run_exec (RUN_TTY, RUN_TTY, noerr ? DEVNULL : RUN_TTY, RUN_NORMAL);
a500 2
/* Unlock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  */
d502 22
a523 8
RCS_exec_unlock(path, rev, noerr)
    const char *path;
    const char *rev;
    int noerr;
{
    run_setup ("%s%s -x,v/ -q -u%s", Rcsbin, RCS, rev ? rev : "");
    run_arg (path);
    return run_exec (RUN_TTY, RUN_TTY, noerr ? DEVNULL : RUN_TTY, RUN_NORMAL);
d526 11
a536 41
/* Merge revisions REV1 and REV2. */
int
RCS_merge(path, options, rev1, rev2)
     const char *path;
     const char *options;
     const char *rev1;
     const char *rev2;
{
    int status;

    /* XXX - Do merge by hand instead of using rcsmerge, due to -k handling */

    run_setup ("%s%s -x,v/ %s -r%s -r%s %s", Rcsbin, RCS_RCSMERGE,
	       options, rev1, rev2, path);
    status = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
#ifndef HAVE_RCS5
    if (status == 0) 
    {
	error (1, 0, "CVS no longer supports RCS versions older than RCS5");
	/* This case needs to call file_has_markers to see if the file
	   contains conflict indicators.  But is anyone using the !HAVE_RCS5
	   code any more?  */
    }
#endif
    return status;
}

/* Check in to RCSFILE with revision REV (which must be greater than the
   largest revision) and message MESSAGE (which is checked for legality).
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If FLAGS &
   RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS & RCS_FLAGS_MODTIME,
   use the working file's modification time for the checkin time.
   WORKFILE is the working file to check in from, or NULL to use the usual
   RCS rules for deriving it from the RCSFILE.
   
   Return value is -1 for error (and errno is set to indicate the
   error), positive for error (and an error message has been printed),
   or zero for success.  */
int
RCS_checkin (rcsfile, workfile, message, rev, flags)
    char *rcsfile;
d538 8
a545 16
    char *message;
    char *rev;
    int flags;
{
    /* The desired behavior regarding permissions is to preserve the
       permissions on RCSFILE if it already exists.  Based on looking
       at the RCS 5.7 source, it would appear that RCS_CI does this
       except when it is creating RCSFILE (reasonable), or when
       RCSFILE was created with rcs -i (this is strange, and quite
       possibly unintentional).  In those two cases it copies the
       permissions from the workfile.

       Anyway, the fix is simple enough: we preserve the mode ourself.  */
    struct stat sb;
    int fix_mode = 1;
    int retval;
d547 1
a547 1
    if (CVS_STAT (rcsfile, &sb) < 0)
d549 2
a550 22
	fix_mode = 0;
	if (!existence_error (errno))
	    error (0, errno, "warning: cannot stat %s", rcsfile);
    }
    run_setup ("%s%s -x,v/ -w%s -f %s%s", Rcsbin, RCS_CI, getcaller (),
	       rev ? "-r" : "", rev ? rev : "");
    if (flags & RCS_FLAGS_DEAD)
	run_arg ("-sdead");
    if (flags & RCS_FLAGS_QUIET)
	run_arg ("-q");
    if (flags & RCS_FLAGS_MODTIME)
	run_arg ("-d");
    run_args ("-m%s", make_message_rcslegal (message));
    if (workfile != NULL)
	run_arg (workfile);
    run_arg (rcsfile);
    retval = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
    if (retval == 0 && fix_mode)
    {
	if (chmod (rcsfile, sb.st_mode) < 0)
	    error (0, errno, "warning: cannot change permissions on %s",
		   rcsfile);
d552 7
a558 1
    return retval;
@


1.7
log
@Integrate local changes
@
text
@d202 1
a202 1
    run_setup ("%s%s -x,v/ -f %s%s", Rcsbin, RCS_CI,
@


1.6
log
@Integrate local changes
@
text
@d54 2
a55 2
   TODO: improve rcsfile.5 in the RCS distribution so that it more
   completely documents this format.
a161 28
}

/* Check out a revision from RCSFILE into WORKFILE, or to standard output
   if WORKFILE is NULL.  TAG is the tag to check out, or NULL if one
   should check out the head of the default branch.  OPTIONS is a string
   such as -kb or -kkv, for keyword expansion options, or NULL if there
   are none.  If WORKFILE is NULL, run regardless of noexec; if non-NULL,
   noexec inhibits execution.  SOUT is what to do with standard output
   (typically RUN_TTY).  */
int
RCS_exec_checkout (rcsfile, workfile, tag, options, sout)
    char *rcsfile;
    char *workfile;
    char *tag;
    char *options;
    char *sout;
{
    run_setup ("%s%s -x,v/ -q %s%s", Rcsbin, RCS_CO,
               tag ? "-r" : "", tag ? tag : "");
    if (options != NULL && options[0] != '\0')
	run_arg (options);
    if (workfile == NULL)
	run_arg ("-p");
    run_arg (rcsfile);
    if (workfile != NULL)
	run_arg (workfile);
    return run_exec (RUN_TTY, sout, RUN_TTY,
                     workfile == NULL ? (RUN_NORMAL | RUN_REALLY) : RUN_NORMAL);
@


1.5
log
@Integrate local changes
@
text
@d198 5
a202 1
   RCS rules for deriving it from the RCSFILE.  */
d211 19
d242 8
a249 1
    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
@


1.4
log
@Integrate local changes
@
text
@d155 4
a158 6
	/* Run GREP to see if there appear to be conflicts in the file */
	run_setup ("%s", GREP);
	run_arg (RCS_MERGE_PAT);
	run_arg (path);
	status = (run_exec (RUN_TTY, DEVNULL, RUN_TTY, RUN_NORMAL) == 0);

@


1.3
log
@retain -Z options to rcs commands even though they do not work (rcs
commands spawn children which do not inherit the -Z option...) but also
look in the RCSLOCALID environment variable. cvs sets this to "OpenBSD",
as read from the options file.
@
text
@d15 56
d77 1
a77 1
RCS_settag(path, tag, rev)
a81 11
    if (strcmp (tag, TAG_BASE) == 0
	|| strcmp (tag, TAG_HEAD) == 0)
    {
	/* Print the name of the tag might be considered redundant
	   with the caller, which also prints it.  Perhaps this helps
	   clarify why the tag name is considered reserved, I don't
	   know.  */
	error (0, 0, "Attempt to add reserved tag name %s", tag);
	return 1;
    }

d90 1
a90 1
RCS_deltag(path, tag, noerr)
d102 1
a102 1
RCS_setbranch(path, rev)
d114 1
a114 1
RCS_lock(path, rev, noerr)
d127 1
a127 1
RCS_unlock(path, rev, noerr)
d167 6
a172 9
   if WORKFILE is NULL.  If WORKFILE is "", let RCS pick the working file
   name.  TAG is the tag to check out, or NULL if one should check out
   the head of the default branch.  OPTIONS is a string such as
   -kb or -kkv, for keyword expansion options, or NULL if there are none.
   If WORKFILE is NULL, run regardless of noexec; if non-NULL, noexec
   inhibits execution.  SOUT is what to do with standard output
   (typically RUN_TTY).  If FLAGS & RCS_FLAGS_LOCK, lock it.  If
   FLAGS & RCS_FLAGS_FORCE, check out even on top of an existing file.
   If NOERR is nonzero, suppress errors.  */
d174 1
a174 1
RCS_checkout (rcsfile, workfile, tag, options, sout, flags, noerr)
a179 2
    int flags;
    int noerr;
a186 4
    if (flags & RCS_FLAGS_LOCK)
	run_arg ("-l");
    if (flags & RCS_FLAGS_FORCE)
	run_arg ("-f");
d188 1
a188 1
    if (workfile != NULL && workfile[0] != '\0')
d190 1
a190 1
    return run_exec (RUN_TTY, sout, noerr ? DEVNULL : RUN_TTY,
d196 5
a200 6
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If NOERR, do not
   report errors.  If FLAGS & RCS_FLAGS_QUIET suppress errors somewhat more
   selectively.  If FLAGS & RCS_FLAGS_MODTIME, use the working file's
   modification time for the checkin time.  WORKFILE is the working file
   to check in from, or NULL to use the usual RCS rules for deriving it
   from the RCSFILE.  */
d202 1
a202 1
RCS_checkin (rcsfile, workfile, message, rev, flags, noerr)
a207 1
    int noerr;
d221 1
a221 1
    return run_exec (RUN_TTY, RUN_TTY, noerr ? DEVNULL : RUN_TTY, RUN_NORMAL);
@


1.2
log
@new extension: the $CVSROOT/CVSROOT/options file (if it exists) supports:
    tag=-ZOpenBSD (passes -ZOpenBSD to co/ci)
    umask=002 (force a umask while cvs is running)
    dlimit=49152 (force a 48MB process data limit)
@
text
@a19 2
char *RCS_citag;

a150 2
    if (RCS_citag)
	run_arg (RCS_citag);
a182 2
    if (RCS_citag)
	run_arg (RCS_citag);
@


1.1
log
@Initial revision
@
text
@d13 8
d28 12
a39 1
    run_setup ("%s%s -q -N%s:%s", Rcsbin, RCS, tag, rev);
d50 1
d52 1
a52 1
    run_setup ("%s%s -q -N%s", Rcsbin, RCS, tag);
d63 1
a63 1
    run_setup ("%s%s -q -b%s", Rcsbin, RCS, rev ? rev : "");
d76 1
a76 1
    run_setup ("%s%s -q -l%s", Rcsbin, RCS, rev ? rev : "");
d87 1
d89 1
a89 1
    run_setup ("%s%s -q -u%s", Rcsbin, RCS, rev ? rev : "");
a103 4
    /* We pass -E to rcsmerge so that it will not indicate a conflict if
       both things we are merging are modified the same way.

       Well, okay, but my rcsmerge doesn't take a -E option.  --JimB */
d106 1
a106 1
    run_setup ("%s%s %s -r%s -r%s %s", Rcsbin, RCS_RCSMERGE,
d113 1
a113 1
	run_setup ("%s -s", GREP);
d116 1
a116 1
	status = (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL) == 0);
d121 73
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a30 1
    int noerr;
a66 1
    int noerr;
d83 4
d96 1
a96 1
	run_setup ("%s", GREP);
d99 1
a99 1
	status = (run_exec (RUN_TTY, DEVNULL, RUN_TTY, RUN_NORMAL) == 0);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a12 1
#include <assert.h>
d20 1
a20 1
    run_setup ("%s%s -x,v/ -q -N%s:%s", Rcsbin, RCS, tag, rev);
d33 1
a33 1
    run_setup ("%s%s -x,v/ -q -N%s", Rcsbin, RCS, tag);
d44 1
a44 1
    run_setup ("%s%s -x,v/ -q -b%s", Rcsbin, RCS, rev ? rev : "");
d57 1
a57 1
    run_setup ("%s%s -x,v/ -q -l%s", Rcsbin, RCS, rev ? rev : "");
d70 1
a70 1
    run_setup ("%s%s -x,v/ -q -u%s", Rcsbin, RCS, rev ? rev : "");
d87 1
a87 1
    run_setup ("%s%s -x,v/ %s -r%s -r%s %s", Rcsbin, RCS_RCSMERGE,
a101 69
}

/* Check out a revision from RCSFILE into WORKFILE, or to standard output
   if WORKFILE is NULL.  If WORKFILE is "", let RCS pick the working file
   name.  TAG is the tag to check out, or NULL if one should check out
   the head of the default branch.  OPTIONS is a string such as
   -kb or -kkv, for keyword expansion options, or NULL if there are none.
   If WORKFILE is NULL, run regardless of noexec; if non-NULL, noexec
   inhibits execution.  SOUT is what to do with standard output
   (typically RUN_TTY).  If FLAGS & RCS_FLAGS_LOCK, lock it.  If
   FLAGS & RCS_FLAGS_FORCE, check out even on top of an existing file.
   If NOERR is nonzero, suppress errors.  */
int
RCS_checkout (rcsfile, workfile, tag, options, sout, flags, noerr)
    char *rcsfile;
    char *workfile;
    char *tag;
    char *options;
    char *sout;
    int flags;
    int noerr;
{
    run_setup ("%s%s -x,v/ -q %s%s", Rcsbin, RCS_CO,
               tag ? "-r" : "", tag ? tag : "");
    if (options != NULL && options[0] != '\0')
	run_arg (options);
    if (workfile == NULL)
	run_arg ("-p");
    if (flags & RCS_FLAGS_LOCK)
	run_arg ("-l");
    if (flags & RCS_FLAGS_FORCE)
	run_arg ("-f");
    run_arg (rcsfile);
    if (workfile != NULL && workfile[0] != '\0')
	run_arg (workfile);
    return run_exec (RUN_TTY, sout, noerr ? DEVNULL : RUN_TTY,
                     workfile == NULL ? (RUN_NORMAL | RUN_REALLY) : RUN_NORMAL);
}

/* Check in to RCSFILE with revision REV (which must be greater than the
   largest revision) and message MESSAGE (which is checked for legality).
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If NOERR, do not
   report errors.  If FLAGS & RCS_FLAGS_QUIET suppress errors somewhat more
   selectively.  If FLAGS & RCS_FLAGS_MODTIME, use the working file's
   modification time for the checkin time.  WORKFILE is the working file
   to check in from, or NULL to use the usual RCS rules for deriving it
   from the RCSFILE.  */
int
RCS_checkin (rcsfile, workfile, message, rev, flags, noerr)
    char *rcsfile;
    char *workfile;
    char *message;
    char *rev;
    int flags;
    int noerr;
{
    run_setup ("%s%s -x,v/ -f %s%s", Rcsbin, RCS_CI,
	       rev ? "-r" : "", rev ? rev : "");
    if (flags & RCS_FLAGS_DEAD)
	run_arg ("-sdead");
    if (flags & RCS_FLAGS_QUIET)
	run_arg ("-q");
    if (flags & RCS_FLAGS_MODTIME)
	run_arg ("-d");
    run_args ("-m%s", make_message_rcslegal (message));
    if (workfile != NULL)
	run_arg (workfile);
    run_arg (rcsfile);
    return run_exec (RUN_TTY, RUN_TTY, noerr ? DEVNULL : RUN_TTY, RUN_NORMAL);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a14 5
/* For RCS file PATH, make symbolic tag TAG point to revision REV.
   This validates that TAG is OK for a user to use.  Return value is
   -1 for error (and errno is set to indicate the error), positive for
   error (and an error message has been printed), or zero for success.  */

a20 11
    if (strcmp (tag, TAG_BASE) == 0
	|| strcmp (tag, TAG_HEAD) == 0)
    {
	/* Print the name of the tag might be considered redundant
	   with the caller, which also prints it.  Perhaps this helps
	   clarify why the tag name is considered reserved, I don't
	   know.  */
	error (0, 0, "Attempt to add reserved tag name %s", tag);
	return 1;
    }

@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a14 56
/* This file, rcs.h, and rcs.c, are intended to define our interface
   to RCS files.  As of July, 1996, there are still a few places that
   still exec RCS commands directly.  The intended long-term direction
   is to have CVS access RCS files via an RCS library (rcs.c can be
   considered a start at one), for performance, cleanliness (CVS has
   some awful hacks to work around RCS behaviors which don't make
   sense for CVS), installation hassles, ease of implementing the CVS
   server (I don't think that the output-out-of-order bug can be
   completely fixed as long as CVS calls RCS), and perhaps other
   reasons.

   Whether there will also be a version of RCS which uses this
   library, or whether the library will be packaged for uses beyond
   CVS or RCS (many people would like such a thing) is an open
   question.  Some considerations:

   1.  An RCS library for CVS must have the capabilities of the
   existing CVS code which accesses RCS files.  In particular, simple
   approaches will often be slow.

   2.  An RCS library should not use the code from the current RCS
   (5.7 and its ancestors).  The code has many problems.  Too few
   comments, too many layers of abstraction, too many global variables
   (the correct number for a library is zero), too much intricately
   interwoven functionality, and too many clever hacks.  Paul Eggert,
   the current RCS maintainer, agrees.

   3.  More work needs to be done in terms of separating out the RCS
   library from the rest of CVS (for example, cvs_output should be
   replaced by a callback, and the declarations should be centralized
   into rcs.h, and probably other such cleanups).

   4.  To be useful for RCS and perhaps for other uses, the library
   may need features beyond those needed by CVS.

   5.  Any changes to the RCS file format *must* be compatible.  Many,
   many tools (not just CVS and RCS) can at least import this format.
   RCS and CVS must preserve the current ability to import/export it
   (preferably improved--magic branches are currently a roadblock).
   TODO: improve rcsfile.5 in the RCS distribution so that it more
   completely documents this format.

   On somewhat related notes:

   1.  A library for diff is an obvious idea.  The one thing which I'm
   not so sure about is that I think CVS probably wants the ability to
   allow arbitrarily-bizarre (and possibly customized for particular
   file formats) external diff programs.

   2.  A library for patch is another such idea.  CVS's needs are
   smaller than the functionality of the standalone patch program (it
   only calls patch in the client, and only needs to be able to patch
   unmodified versions, which is something that RCS_deltas already
   does in a different context).  But it is silly for CVS to be making
   people install patch as well as CVS for such a simple purpose.  */

d21 1
a21 1
RCS_exec_settag(path, tag, rev)
d26 11
d45 1
a45 1
RCS_exec_deltag(path, tag, noerr)
d57 1
a57 1
RCS_exec_setbranch(path, rev)
d69 1
a69 1
RCS_exec_lock(path, rev, noerr)
d82 1
a82 1
RCS_exec_unlock(path, rev, noerr)
d122 9
a130 6
   if WORKFILE is NULL.  TAG is the tag to check out, or NULL if one
   should check out the head of the default branch.  OPTIONS is a string
   such as -kb or -kkv, for keyword expansion options, or NULL if there
   are none.  If WORKFILE is NULL, run regardless of noexec; if non-NULL,
   noexec inhibits execution.  SOUT is what to do with standard output
   (typically RUN_TTY).  */
d132 1
a132 1
RCS_exec_checkout (rcsfile, workfile, tag, options, sout)
d138 2
d147 4
d152 1
a152 1
    if (workfile != NULL)
d154 1
a154 1
    return run_exec (RUN_TTY, sout, RUN_TTY,
d160 6
a165 5
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If FLAGS &
   RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS & RCS_FLAGS_MODTIME,
   use the working file's modification time for the checkin time.
   WORKFILE is the working file to check in from, or NULL to use the usual
   RCS rules for deriving it from the RCSFILE.  */
d167 1
a167 1
RCS_checkin (rcsfile, workfile, message, rev, flags)
d173 1
d187 1
a187 1
    return run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d155 6
a160 4
	error (1, 0, "CVS no longer supports RCS versions older than RCS5");
	/* This case needs to call file_has_markers to see if the file
	   contains conflict indicators.  But is anyone using the !HAVE_RCS5
	   code any more?  */
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d198 1
a198 5
   RCS rules for deriving it from the RCSFILE.
   
   Return value is -1 for error (and errno is set to indicate the
   error), positive for error (and an error message has been printed),
   or zero for success.  */
a206 19
    /* The desired behavior regarding permissions is to preserve the
       permissions on RCSFILE if it already exists.  Based on looking
       at the RCS 5.7 source, it would appear that RCS_CI does this
       except when it is creating RCSFILE (reasonable), or when
       RCSFILE was created with rcs -i (this is strange, and quite
       possibly unintentional).  In those two cases it copies the
       permissions from the workfile.

       Anyway, the fix is simple enough: we preserve the mode ourself.  */
    struct stat sb;
    int fix_mode = 1;
    int retval;

    if (CVS_STAT (rcsfile, &sb) < 0)
    {
	fix_mode = 0;
	if (!existence_error (errno))
	    error (0, errno, "warning: cannot stat %s", rcsfile);
    }
d219 1
a219 8
    retval = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
    if (retval == 0 && fix_mode)
    {
	if (chmod (rcsfile, sb.st_mode) < 0)
	    error (0, errno, "warning: cannot change permissions on %s",
		   rcsfile);
    }
    return retval;
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d54 2
a55 2
   See doc/RCSFILES in the CVS distribution for documentation of this
   file format.
d162 28
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d202 1
a202 1
    run_setup ("%s%s -x,v/ -w%s -f %s%s", Rcsbin, RCS_CI, getcaller (),
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d15 10
a24 2
/* This file, rcs.h, and rcs.c, together sometimes known as the "RCS
   library", are intended to define our interface to RCS files.
d35 1
a35 1
   2.  An RCS library should not use code from the current RCS
d57 1
a57 2
   On a related note, see the comments at diff_exec, later in this file,
   for more on the diff library.  */
d59 16
a74 1
static void RCS_output_diff_options PROTO ((char *, char *, char *, char *));
d76 9
a84 52

/* Stuff to deal with passing arguments the way libdiff.a wants to deal
   with them.  This is a crufty interface; there is no good reason for it
   to resemble a command line rather than something closer to "struct
   log_data" in log.c.  */

/* First call call_diff_setup to setup any initial arguments.  The
   argument will be parsed into whitespace separated words and added
   to the global call_diff_argv list.

   Then, optionally, call call_diff_arg for each additional argument
   that you'd like to pass to the diff library.

   Finally, call call_diff or call_diff3 to produce the diffs.  */

static char **call_diff_argv;
static int call_diff_argc;
static int call_diff_argc_allocated;

static void call_diff_add_arg PROTO ((const char *));
static void call_diff_setup PROTO ((const char *prog));
static int call_diff PROTO ((char *out));
static int call_diff3 PROTO ((char *out));

/* VARARGS */
static void 
call_diff_setup (prog)
    const char *prog;
{
    char *cp;
    int i;
    char *call_diff_prog;

    /* clean out any malloc'ed values from call_diff_argv */
    for (i = 0; i < call_diff_argc; i++)
    {
	if (call_diff_argv[i])
	{
	    free (call_diff_argv[i]);
	    call_diff_argv[i] = (char *) 0;
	}
    }
    call_diff_argc = 0;

    call_diff_prog = xstrdup (prog);

    /* put each word into call_diff_argv, allocating it as we go */
    for (cp = strtok (call_diff_prog, " \t");
	 cp != NULL;
	 cp = strtok ((char *) NULL, " \t"))
	call_diff_add_arg (cp);
    free (call_diff_prog);
d87 7
a93 3
static void
call_diff_arg (s)
    const char *s;
d95 3
a97 1
    call_diff_add_arg (s);
d100 5
a104 3
static void
call_diff_add_arg (s)
    const char *s;
d106 3
a108 14
    /* allocate more argv entries if we've run out */
    if (call_diff_argc >= call_diff_argc_allocated)
    {
	call_diff_argc_allocated += 50;
	call_diff_argv = (char **)
	    xrealloc ((char *) call_diff_argv,
		      call_diff_argc_allocated * sizeof (char **));
    }

    if (s)
	call_diff_argv[call_diff_argc++] = xstrdup (s);
    else
	/* Not post-incremented on purpose!  */
	call_diff_argv[call_diff_argc] = (char *) 0;
d111 11
a121 22
/* diff_run is imported from libdiff.a. */
extern int diff_run PROTO ((int argc, char **argv, char *out));

static int
call_diff (out)
    char *out;
{
    /* Try to keep the out-of-order bugs at bay (protocol_pipe for cvs_output
       with has "Index: foo" and such; stdout and/or stderr for diff's
       output).  I think the only reason that this used to not be such
       a problem is that the time spent on the fork() and exec() of diff
       slowed us down enough to let the "Index:" make it through first.

       The real fix, of course, will be to have the diff library do all
       its output through callbacks (which CVS will supply as cvs_output
       and cvs_outerr).  */
    sleep (1);

    if (out == RUN_TTY)
	return diff_run (call_diff_argc, call_diff_argv, NULL);
    else
	return diff_run (call_diff_argc, call_diff_argv, out);
d124 11
a134 21
extern int diff3_run PROTO ((int argc, char **argv, char *out));

static int
call_diff3 (out)
    char *out;
{
    /* Try to keep the out-of-order bugs at bay (protocol_pipe for cvs_output
       with has "Index: foo" and such; stdout and/or stderr for diff's
       output).  I think the only reason that this used to not be such
       a problem is that the time spent on the fork() and exec() of diff
       slowed us down enough to let the "Index:" make it through first.

       The real fix, of course, will be to have the diff library do all
       its output through callbacks (which CVS will supply as cvs_output
       and cvs_outerr).  */
    sleep (1);

    if (out == RUN_TTY)
	return diff3_run (call_diff_argc, call_diff_argv, NULL);
    else
	return diff3_run (call_diff_argc, call_diff_argv, out);
a136 2


a137 1

d139 39
a177 3
RCS_merge(rcs, path, workfile, options, rev1, rev2)
    RCSNode *rcs;
    char *path;
d179 15
a193 7
    char *options;
    char *rev1;
    char *rev2;
{
    char *xrev1, *xrev2;
    char *tmp1, *tmp2;
    char *diffout = NULL;
d196 1
a196 34
    if (options != NULL && options[0] != '\0')
      assert (options[0] == '-' && options[1] == 'k');

    cvs_output ("RCS file: ", 0);
    cvs_output (rcs->path, 0);
    cvs_output ("\n", 1);

    /* Calculate numeric revision numbers from rev1 and rev2 (may be
       symbolic). */
    xrev1 = RCS_gettag (rcs, rev1, 0, NULL);
    xrev2 = RCS_gettag (rcs, rev2, 0, NULL);

    /* Check out chosen revisions.  The error message when RCS_checkout
       fails is not very informative -- it is taken verbatim from RCS 5.7,
       and relies on RCS_checkout saying something intelligent upon failure. */
    cvs_output ("retrieving revision ", 0);
    cvs_output (xrev1, 0);
    cvs_output ("\n", 1);

    tmp1 = cvs_temp_name();
    if (RCS_checkout (rcs, NULL, xrev1, rev1, options, tmp1,
		      (RCSCHECKOUTPROC)0, NULL))
    {
	cvs_outerr ("rcsmerge: co failed\n", 0);
	error_exit();
    }

    cvs_output ("retrieving revision ", 0);
    cvs_output (xrev2, 0);
    cvs_output ("\n", 1);

    tmp2 = cvs_temp_name();
    if (RCS_checkout (rcs, NULL, xrev2, rev2, options, tmp2,
		      (RCSCHECKOUTPROC)0, NULL))
d198 22
a219 2
	cvs_outerr ("rcsmerge: co failed\n", 0);
	error_exit();
a220 68

    /* Merge changes. */
    cvs_output ("Merging differences between ", 0);
    cvs_output (xrev1, 0);
    cvs_output (" and ", 0);
    cvs_output (xrev2, 0);
    cvs_output (" into ", 0);
    cvs_output (workfile, 0);
    cvs_output ("\n", 1);

    /* Remember that the first word in the `call_diff_setup' string is used now
       only for diagnostic messages -- CVS no longer forks to run diff3. */
    diffout = cvs_temp_name();
    call_diff_setup ("diff3");
    call_diff_arg ("-E");
    call_diff_arg ("-am");

    call_diff_arg ("-L");
    call_diff_arg (workfile);
    call_diff_arg ("-L");
    call_diff_arg (xrev1);
    call_diff_arg ("-L");
    call_diff_arg (xrev2);

    call_diff_arg (workfile);
    call_diff_arg (tmp1);
    call_diff_arg (tmp2);

    retval = call_diff3 (diffout);

    if (retval == 1)
	cvs_outerr ("rcsmerge: warning: conflicts during merge\n", 0);
    else if (retval == 2)
	error_exit();

    if (diffout)
	copy_file (diffout, workfile);

    /* Clean up. */
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmp1) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmp1);
	}
	free (tmp1);
	if (unlink_file (tmp2) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmp2);
	}
	free (tmp2);
	if (diffout)
	{
	    if (unlink_file (diffout) < 0)
	    {
		if (!existence_error (errno))
		    error (0, errno, "cannot remove temp file %s", diffout);
	    }
	    free (diffout);
	}
	free (xrev1);
	free (xrev2);
	noexec = save_noexec;
    }

a221 252
}

/* Diff revisions and/or files.  OPTS controls the format of the diff
   (it contains options such as "-w -c", &c), or "" for the default.
   OPTIONS controls keyword expansion, as a string starting with "-k",
   or "" to use the default.  REV1 is the first revision to compare
   against; it must be non-NULL.  If REV2 is non-NULL, compare REV1
   and REV2; if REV2 is NULL compare REV1 with the file in the working
   directory, whose name is WORKFILE.  LABEL1 and LABEL2 are default
   file labels, and (if non-NULL) should be added as -L options
   to diff.  Output goes to stdout.

   Return value is 0 for success, -1 for a failure which set errno,
   or positive for a failure which printed a message on stderr.

   This used to exec rcsdiff, but now calls RCS_checkout and diff_exec.

   An issue is what timezone is used for the dates which appear in the
   diff output.  rcsdiff uses the -z flag, which is not presently
   processed by CVS diff, but I'm not sure exactly how hard to worry
   about this--any such features are undocumented in the context of
   CVS, and I'm not sure how important to users.  */
int
RCS_exec_rcsdiff (rcsfile, opts, options, rev1, rev2, label1, label2, workfile)
    RCSNode *rcsfile;
    char *opts;
    char *options;
    char *rev1;
    char *rev2;
    char *label1;
    char *label2;
    char *workfile;
{
    char *tmpfile1;
    char *tmpfile2;
    char *use_file2;
    int status, retval;

    tmpfile1 = cvs_temp_name ();
    tmpfile2 = NULL;

    cvs_output ("\
===================================================================\n\
RCS file: ", 0);
    cvs_output (rcsfile->path, 0);
    cvs_output ("\n", 1);

    /* Historically, `cvs diff' has expanded the $Name keyword to the
       empty string when checking out revisions.  This is an accident,
       but no one has considered the issue thoroughly enough to determine
       what the best behavior is.  Passing NULL for the `nametag' argument
       preserves the existing behavior. */

    cvs_output ("retrieving revision ", 0);
    cvs_output (rev1, 0);
    cvs_output ("\n", 1);
    status = RCS_checkout (rcsfile, NULL, rev1, NULL, options, tmpfile1,
			   (RCSCHECKOUTPROC)0, NULL);
    if (status > 0)
    {
	retval = status;
	goto error_return;
    }
    else if (status < 0)
    {
	error (0, errno,
	       "cannot check out revision %s of %s", rev1, rcsfile->path);
	retval = 1;
	goto error_return;
    }

    if (rev2 == NULL)
    {
	assert (workfile != NULL);
	use_file2 = workfile;
    }
    else
    {
	tmpfile2 = cvs_temp_name ();
	cvs_output ("retrieving revision ", 0);
	cvs_output (rev2, 0);
	cvs_output ("\n", 1);
	status = RCS_checkout (rcsfile, NULL, rev2, NULL, options,
			       tmpfile2, (RCSCHECKOUTPROC)0, NULL);
	if (status > 0)
	{
	    retval = status;
	    goto error_return;
	}
	else if (status < 0)
	{
	    error (0, errno,
		   "cannot check out revision %s of %s", rev2, rcsfile->path);
	    return 1;
	}
	use_file2 = tmpfile2;
    }

    RCS_output_diff_options (opts, rev1, rev2, workfile);
    status = diff_execv (tmpfile1, use_file2, label1, label2, opts, RUN_TTY);
    if (status >= 0)
    {
	retval = status;
	goto error_return;
    }
    else if (status < 0)
    {
	error (0, errno,
	       "cannot diff %s and %s", tmpfile1, use_file2);
	retval = 1;
	goto error_return;
    }

 error_return:
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmpfile1) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmpfile1);
	}
	noexec = save_noexec;
    }
    free (tmpfile1);
    if (tmpfile2 != NULL)
    {
	int save_noexec = noexec;
	noexec = 0;
	if (unlink_file (tmpfile2) < 0)
	{
	    if (!existence_error (errno))
		error (0, errno, "cannot remove temp file %s", tmpfile2);
	}
	noexec = save_noexec;
	free (tmpfile2);
    }

    return retval;
}


/* Show differences between two files.  This is the start of a diff library.

   Some issues:

   * Should option parsing be part of the library or the caller?  The
   former allows the library to add options without changing the callers,
   but it causes various problems.  One is that something like --brief really
   wants special handling in CVS, and probably the caller should retain
   some flexibility in this area.  Another is online help (the library could
   have some feature for providing help, but how does that interact with
   the help provided by the caller directly?).  Another is that as things
   stand currently, there is no separate namespace for diff options versus
   "cvs diff" options like -l (that is, if the library adds an option which
   conflicts with a CVS option, it is trouble).

   * This isn't required for a first-cut diff library, but if there
   would be a way for the caller to specify the timestamps that appear
   in the diffs (rather than the library getting them from the files),
   that would clean up the kludgy utime() calls in patch.c.

   Show differences between FILE1 and FILE2.  Either one can be
   DEVNULL to indicate a nonexistent file (same as an empty file
   currently, I suspect, but that may be an issue in and of itself).
   OPTIONS is a list of diff options, or "" if none.  At a minimum,
   CVS expects that -c (update.c, patch.c) and -n (update.c) will be
   supported.  Other options, like -u, --speed-large-files, &c, will
   be specified if the user specified them.

   OUT is a filename to send the diffs to, or RUN_TTY to send them to
   stdout.  Error messages go to stderr.  Return value is 0 for
   success, -1 for a failure which set errno, 1 for success (and some
   differences were found), or >1 for a failure which printed a
   message on stderr.  */

int
diff_exec (file1, file2, options, out)
    char *file1;
    char *file2;
    char *options;
    char *out;
{
    char *args = xmalloc (strlen (options) + 10);
    /* The first word in this string is used only for error reporting. */
    sprintf (args, "diff %s", options);
    call_diff_setup (args);
    call_diff_arg (file1);
    call_diff_arg (file2);
    free (args);

    return call_diff (out);
}

int
diff_execv (file1, file2, label1, label2, options, out)
    char *file1;
    char *file2;
    char *label1;
    char *label2;
    char *options;
    char *out;
{
    char *args = xmalloc (strlen (options) + 10);
    /* The first word in this string is used only for error reporting.  */
    /* I guess we are pretty confident that options starts with a space.  */
    sprintf (args, "diff%s", options);
    call_diff_setup (args);
    if (label1)
	call_diff_arg (label1);
    if (label2)
	call_diff_arg (label2);
    call_diff_arg (file1);
    call_diff_arg (file2);
    free (args);

    return call_diff (out);
}

/* Print the options passed to DIFF, in the format used by rcsdiff.
   The rcsdiff code that produces this output is extremely hairy, and
   it is not clear how rcsdiff decides which options to print and
   which not to print.  The code below reproduces every rcsdiff run
   that I have seen. */

static void
RCS_output_diff_options (opts, rev1, rev2, workfile)
    char *opts;
    char *rev1;
    char *rev2;
    char *workfile;
{
    char *tmp;

    tmp = (char *) xmalloc (strlen (opts) + strlen (rev1) + 10);

    sprintf (tmp, "diff%s -r%s", opts, rev1);
    cvs_output (tmp, 0);
    free (tmp);

    if (rev2)
    {
	cvs_output (" -r", 3);
	cvs_output (rev2, 0);
    }
    else
    {
	assert (workfile != NULL);
	cvs_output (" ", 1);
	cvs_output (workfile, 0);
    }
    cvs_output ("\n", 1);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d490 1
a490 36
    char *args;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If either file1 or file2 are special files, pretend they are
       /dev/null.  Reason: suppose a file that represents a block
       special device in one revision becomes a regular file.  CVS
       must find the `difference' between these files, but a special
       file contains no data useful for calculating this metric.  The
       safe thing to do is to treat the special file as an empty file,
       thus recording the regular file's full contents.  Doing so will
       create extremely large deltas at the point of transition
       between device files and regular files, but this is probably
       very rare anyway.

       There may be ways around this, but I think they are fraught
       with danger. -twp */

    if (preserve_perms &&
	strcmp (file1, DEVNULL) != 0 &&
	strcmp (file2, DEVNULL) != 0)
    {
	struct stat sb1, sb2;

	if (CVS_LSTAT (file1, &sb1) < 0)
	    error (1, errno, "cannot get file information for %s", file1);
	if (CVS_LSTAT (file2, &sb2) < 0)
	    error (1, errno, "cannot get file information for %s", file2);

	if (!S_ISREG (sb1.st_mode) && !S_ISDIR (sb1.st_mode))
	    file1 = DEVNULL;
	if (!S_ISREG (sb2.st_mode) && !S_ISDIR (sb2.st_mode))
	    file2 = DEVNULL;
    }
#endif

    args = xmalloc (strlen (options) + 10);
d510 1
a510 25
    char *args;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Pretend that special files are /dev/null for purposes of making
       diffs.  See comments in diff_exec. */

    if (preserve_perms &&
	strcmp (file1, DEVNULL) != 0 &&
	strcmp (file2, DEVNULL) != 0)
    {
	struct stat sb1, sb2;

	if (CVS_LSTAT (file1, &sb1) < 0)
	    error (1, errno, "cannot get file information for %s", file1);
	if (CVS_LSTAT (file2, &sb2) < 0)
	    error (1, errno, "cannot get file information for %s", file2);

	if (!S_ISREG (sb1.st_mode) && !S_ISDIR (sb1.st_mode))
	    file1 = DEVNULL;
	if (!S_ISREG (sb2.st_mode) && !S_ISDIR (sb2.st_mode))
	    file2 = DEVNULL;
    }
#endif

    args = xmalloc (strlen (options) + 10);
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a13 2
#include <stdio.h>
#include "diffrun.h"
a77 5
static void call_diff_write_output PROTO((const char *, size_t));
static void call_diff_flush_output PROTO((void));
static void call_diff_write_stdout PROTO((const char *));
static void call_diff_error PROTO((const char *, const char *, const char *));

d135 2
a136 63
/* Callback function for the diff library to write data to the output
   file.  This is used when we are producing output to stdout.  */

static void
call_diff_write_output (text, len)
    const char *text;
    size_t len;
{
    cvs_output (text, len);
}

/* Call back function for the diff library to flush the output file.
   This is used when we are producing output to stdout.  */

static void
call_diff_flush_output ()
{
    cvs_flushout ();
}

/* Call back function for the diff library to write to stdout.  */

static void
call_diff_write_stdout (text)
    const char *text;
{
    cvs_output (text, 0);
}

/* Call back function for the diff library to write to stderr.  */

static void
call_diff_error (format, a1, a2)
    const char *format;
    const char *a1;
    const char *a2;
{
    /* FIXME: Should we somehow indicate that this error is coming from
       the diff library?  */
    error (0, 0, format, a1, a2);
}

/* This set of callback functions is used if we are sending the diff
   to stdout.  */

static struct diff_callbacks call_diff_stdout_callbacks =
{
    call_diff_write_output,
    call_diff_flush_output,
    call_diff_write_stdout,
    call_diff_error
};

/* This set of callback functions is used if we are sending the diff
   to a file.  */

static struct diff_callbacks call_diff_file_callbacks =
{
    (void (*) PROTO((const char *, size_t))) NULL,
    (void (*) PROTO((void))) NULL,
    call_diff_write_stdout,
    call_diff_error
};
d142 11
d154 1
a154 2
	return diff_run (call_diff_argc, call_diff_argv, NULL,
			 &call_diff_stdout_callbacks);
d156 1
a156 2
	return diff_run (call_diff_argc, call_diff_argv, out,
			 &call_diff_file_callbacks);
d159 2
d165 11
d177 1
a177 2
	return diff3_run (call_diff_argc, call_diff_argv, NULL,
			  &call_diff_stdout_callbacks);
d179 1
a179 2
	return diff3_run (call_diff_argc, call_diff_argv, out,
			  &call_diff_file_callbacks);
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d150 1
a150 2
    if (len > 0)
	cvs_output (text, len);
@


1.1.1.14
log
@Latest from Cyclic Software
@
text
@d533 1
a533 1
diff_exec (file1, file2, label1, label2, options, out)
a535 2
    char *label1;
    char *label2;
a577 4
    if (label1)
	call_diff_arg (label1);
    if (label2)
	call_diff_arg (label2);
@


