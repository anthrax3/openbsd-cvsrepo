head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.22
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.18
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.14
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.16
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.8
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.12
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.10
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.6
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.32
	OPENBSD_5_0:1.19.0.30
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.28
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.26
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.22
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.24
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.20
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.18
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.16
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.14
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.12
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.10
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	OPENBSD_3_5:1.18.0.12
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.10
	OPENBSD_3_4_BASE:1.18
	OPENBSD_3_3:1.18.0.8
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.6
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.4
	OPENBSD_3_1_BASE:1.18
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	cvs-1-11-1p1:1.1.1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_9_BASE:1.17
	cvs-1-11:1.1.1.16
	OPENBSD_2_8:1.16.0.6
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.4
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.16.0.2
	OPENBSD_2_6_BASE:1.16
	cvs-1-10-7:1.1.1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	cvs-1-10-5:1.1.1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	cvs-1-10:1.1.1.13
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.09.18.16.05;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches
	1.18.10.1
	1.18.12.1;
next	1.17;

1.17
date	2001.02.10.19.31.34;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	99.09.10.05.21.32;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	99.02.28.21.57.49;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	98.08.22.21.04.25;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	98.07.13.04.17.00;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	98.03.12.07.22.27;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.02.22.08.55.55;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.06.28.03.45.27;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.04.21.04.41.02;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.03.18.02.09.54;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.02.21.06.54.52;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.18.04.19.27;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.05.06.22.51.11;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.27.20.26.16;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.30.01.10.34;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.15.48.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.02;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.43;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.23;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.26;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.23;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.59;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.03;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.37;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.05;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.36;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.53.49;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.08.22.20.53.03;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.02.28.21.32.45;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.09.10.05.06.21;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.02.10.18.57.39;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;

1.18.10.1
date	2004.06.09.19.51.06;	author brad;	state Exp;
branches;
next	;

1.18.12.1
date	2004.06.09.19.31.48;	author brad;	state Exp;
branches;
next	;


desc
@@


1.20
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 *
 * Commit Files
 *
 * "commit" commits the present version to the RCS repository, AFTER
 * having done a test on conflicts.
 *
 * The call is: cvs commit [options] files...
 *
 */

#include <assert.h>
#include "cvs.h"
#include "getline.h"
#include "edit.h"
#include "fileattr.h"
#include "hardlink.h"

static Dtype check_direntproc PROTO ((void *callerdat, char *dir,
				      char *repos, char *update_dir,
				      List *entries));
static int check_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int check_filesdoneproc PROTO ((void *callerdat, int err,
				       char *repos, char *update_dir,
				       List *entries));
static int checkaddfile PROTO((char *file, char *repository, char *tag,
			       char *options, RCSNode **rcsnode));
static Dtype commit_direntproc PROTO ((void *callerdat, char *dir,
				       char *repos, char *update_dir,
				       List *entries));
static int commit_dirleaveproc PROTO ((void *callerdat, char *dir,
				       int err, char *update_dir,
				       List *entries));
static int commit_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int commit_filesdoneproc PROTO ((void *callerdat, int err,
					char *repository, char *update_dir,
					List *entries));
static int finaladd PROTO((struct file_info *finfo, char *revision, char *tag,
			   char *options));
static int findmaxrev PROTO((Node * p, void *closure));
static int lock_RCS PROTO((char *user, RCSNode *rcs, char *rev,
			   char *repository));
static int precommit_list_proc PROTO((Node * p, void *closure));
static int precommit_proc PROTO((char *repository, char *filter));
static int remove_file PROTO ((struct file_info *finfo, char *tag,
			       char *message));
static void fixaddfile PROTO((char *file, char *repository));
static void fixbranch PROTO((RCSNode *, char *branch));
static void unlockrcs PROTO((RCSNode *rcs));
static void ci_delproc PROTO((Node *p));
static void masterlist_delproc PROTO((Node *p));
static char *locate_rcs PROTO((char *file, char *repository));

struct commit_info
{
    Ctype status;			/* as returned from Classify_File() */
    char *rev;				/* a numeric rev, if we know it */
    char *tag;				/* any sticky tag, or -r option */
    char *options;			/* Any sticky -k option */
};
struct master_lists
{
    List *ulist;			/* list for Update_Logfile */
    List *cilist;			/* list with commit_info structs */
};

static int force_ci = 0;
static int got_message;
static int run_module_prog = 1;
static int aflag;
static char *saved_tag;
static char *write_dirtag;
static int write_dirnonbranch;
static char *logfile;
static List *mulist;
static List *saved_ulist;
static char *saved_message;
static time_t last_register_time;

static const char *const commit_usage[] =
{
    "Usage: %s %s [-nRlf] [-m msg | -F logfile] [-r rev] files...\n",
    "    -n          Do not run the module program (if any).\n",
    "    -R          Process directories recursively.\n",
    "    -l          Local directory only (not recursive).\n",
    "    -f          Force the file to be committed; disables recursion.\n",
    "    -F logfile  Read the log message from file.\n",
    "    -m msg      Log message.\n",
    "    -r rev      Commit to this branch or trunk revision.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

#ifdef CLIENT_SUPPORT
/* Identify a file which needs "? foo" or a Questionable request.  */
struct question {
    /* The two fields for the Directory request.  */
    char *dir;
    char *repos;

    /* The file name.  */
    char *file;

    struct question *next;
};

struct find_data {
    List *ulist;
    int argc;
    char **argv;

    /* This is used from dirent to filesdone time, for each directory,
       to make a list of files we have already seen.  */
    List *ignlist;

    /* Linked list of files which need "? foo" or a Questionable request.  */
    struct question *questionables;

    /* Only good within functions called from the filesdoneproc.  Stores
       the repository (pointer into storage managed by the recursion
       processor.  */
    char *repository;

    /* Non-zero if we should force the commit.  This is enabled by
       either -f or -r options, unlike force_ci which is just -f.  */
    int force;
};

static Dtype find_dirent_proc PROTO ((void *callerdat, char *dir,
				      char *repository, char *update_dir,
				      List *entries));

static Dtype
find_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repository;
    char *update_dir;
    List *entries;
{
    struct find_data *find_data = (struct find_data *)callerdat;

    /* This check seems to slowly be creeping throughout CVS (update
       and send_dirent_proc by CVS 1.5, diff in 31 Oct 1995.  My guess
       is that it (or some variant thereof) should go in all the
       dirent procs.  Unless someone has some better idea...  */
    if (!isdir (dir))
	return (R_SKIP_ALL);

    /* initialize the ignore list for this directory */
    find_data->ignlist = getlist ();

    /* Print the same warm fuzzy as in check_direntproc, since that
       code will never be run during client/server operation and we
       want the messages to match. */
    if (!quiet)
	error (0, 0, "Examining %s", update_dir);

    return R_PROCESS;
}

/* Here as a static until we get around to fixing ignore_files to pass
   it along as an argument.  */
static struct find_data *find_data_static;

static void find_ignproc PROTO ((char *, char *));

static void
find_ignproc (file, dir)
    char *file;
    char *dir;
{
    struct question *p;

    p = (struct question *) xmalloc (sizeof (struct question));
    p->dir = xstrdup (dir);
    p->repos = xstrdup (find_data_static->repository);
    p->file = xstrdup (file);
    p->next = find_data_static->questionables;
    find_data_static->questionables = p;
}

static int find_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));

static int
find_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    struct find_data *find_data = (struct find_data *)callerdat;
    find_data->repository = repository;

    /* if this directory has an ignore list, process it then free it */
    if (find_data->ignlist)
    {
	find_data_static = find_data;
	ignore_files (find_data->ignlist, entries, update_dir, find_ignproc);
	dellist (&find_data->ignlist);
    }

    find_data->repository = NULL;

    return err;
}

static int find_fileproc PROTO ((void *callerdat, struct file_info *finfo));

/* Machinery to find out what is modified, added, and removed.  It is
   possible this should be broken out into a new client_classify function;
   merging it with classify_file is almost sure to be a mess, though,
   because classify_file has all kinds of repository processing.  */
static int
find_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    Vers_TS *vers;
    enum classify_type status;
    Node *node;
    struct find_data *args = (struct find_data *)callerdat;
    struct logfile_info *data;
    struct file_info xfinfo;

    /* if this directory has an ignore list, add this file to it */
    if (args->ignlist)
    {
	Node *p;

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (finfo->file);
	if (addnode (args->ignlist, p) != 0)
	    freenode (p);
    }

    xfinfo = *finfo;
    xfinfo.repository = NULL;
    xfinfo.rcs = NULL;

    vers = Version_TS (&xfinfo, NULL, saved_tag, NULL, 0, 0);
    if (vers->ts_user == NULL
	&& vers->vn_user != NULL
	&& vers->vn_user[0] == '-')
	/* FIXME: If vn_user is starts with "-" but ts_user is
	   non-NULL, what classify_file does is print "%s should be
	   removed and is still there".  I'm not sure what it does
	   then.  We probably should do the same.  */
	status = T_REMOVED;
    else if (vers->vn_user == NULL)
    {
	if (vers->ts_user == NULL)
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
	else
	    error (0, 0, "use `%s add' to create an entry for %s",
		   program_name, finfo->fullname);
	freevers_ts (&vers);
	return 1;
    }
    else if (vers->ts_user != NULL
	     && vers->vn_user != NULL
	     && vers->vn_user[0] == '0')
	/* FIXME: If vn_user is "0" but ts_user is NULL, what classify_file
	   does is print "new-born %s has disappeared" and removes the entry.
	   We probably should do the same.  */
	status = T_ADDED;
    else if (vers->ts_user != NULL
	     && vers->ts_rcs != NULL
	     && (args->force || strcmp (vers->ts_user, vers->ts_rcs) != 0))
	/* If we are forcing commits, pretend that the file is
           modified.  */
	status = T_MODIFIED;
    else
    {
	/* This covers unmodified files, as well as a variety of other
	   cases.  FIXME: we probably should be printing a message and
	   returning 1 for many of those cases (but I'm not sure
	   exactly which ones).  */
	freevers_ts (&vers);
	return 0;
    }

    node = getnode ();
    node->key = xstrdup (finfo->fullname);

    data = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
    data->type = status;
    data->tag = xstrdup (vers->tag);
    data->rev_old = data->rev_new = NULL;

    node->type = UPDATE;
    node->delproc = update_delproc;
    node->data = (char *) data;
    (void)addnode (args->ulist, node);

    ++args->argc;

    freevers_ts (&vers);
    return 0;
}

static int copy_ulist PROTO ((Node *, void *));

static int
copy_ulist (node, data)
    Node *node;
    void *data;
{
    struct find_data *args = (struct find_data *)data;
    args->argv[args->argc++] = node->key;
    return 0;
}
#endif /* CLIENT_SUPPORT */

int
commit (argc, argv)
    int argc;
    char **argv;
{
    int c;
    int err = 0;
    int local = 0;

    if (argc == -1)
	usage (commit_usage);

#ifdef CVS_BADROOT
    /*
     * For log purposes, do not allow "root" to commit files.  If you look
     * like root, but are really logged in as a non-root user, it's OK.
     */
    /* FIXME: Shouldn't this check be much more closely related to the
       readonly user stuff (CVSROOT/readers, &c).  That is, why should
       root be able to "cvs init", "cvs import", &c, but not "cvs ci"?  */
    if (geteuid () == (uid_t) 0
#  ifdef CLIENT_SUPPORT
	/* Who we are on the client side doesn't affect logging.  */
	&& !current_parsed_root->isremote
#  endif
	)
    {
	struct passwd *pw;

	if ((pw = (struct passwd *) getpwnam (getcaller ())) == NULL)
	    error (1, 0, "you are unknown to this system");
	if (pw->pw_uid == (uid_t) 0)
	    error (1, 0, "cannot commit files as 'root'");
    }
#endif /* CVS_BADROOT */

    optind = 0;
    while ((c = getopt (argc, argv, "+nlRm:fF:r:")) != -1)
    {
	switch (c)
	{
	    case 'n':
		run_module_prog = 0;
		break;
	    case 'm':
#ifdef FORCE_USE_EDITOR
		use_editor = 1;
#else
		use_editor = 0;
#endif
		if (saved_message)
		{
		    free (saved_message);
		    saved_message = NULL;
		}

		saved_message = xstrdup(optarg);
		break;
	    case 'r':
		if (saved_tag)
		    free (saved_tag);
		saved_tag = xstrdup (optarg);
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'f':
		force_ci = 1;
		local = 1;		/* also disable recursion */
		break;
	    case 'F':
#ifdef FORCE_USE_EDITOR
		use_editor = 1;
#else
		use_editor = 0;
#endif
		logfile = optarg;
		break;
	    case '?':
	    default:
		usage (commit_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    /* numeric specified revision means we ignore sticky tags... */
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
    {
	aflag = 1;
	/* strip trailing dots */
	while (saved_tag[strlen (saved_tag) - 1] == '.')
	    saved_tag[strlen (saved_tag) - 1] = '\0';
    }

    /* some checks related to the "-F logfile" option */
    if (logfile)
    {
	size_t size = 0, len;

	if (saved_message)
	    error (1, 0, "cannot specify both a message and a log file");

	get_file (logfile, logfile, "r", &saved_message, &size, &len);
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	struct find_data find_args;

	ign_setup ();

	find_args.ulist = getlist ();
	find_args.argc = 0;
	find_args.questionables = NULL;
	find_args.ignlist = NULL;
	find_args.repository = NULL;

	/* It is possible that only a numeric tag should set this.
	   I haven't really thought about it much.
	   Anyway, I suspect that setting it unnecessarily only causes
	   a little unneeded network traffic.  */
	find_args.force = force_ci || saved_tag != NULL;

	err = start_recursion (find_fileproc, find_filesdoneproc,
			       find_dirent_proc, (DIRLEAVEPROC) NULL,
			       (void *)&find_args,
			       argc, argv, local, W_LOCAL, 0, 0,
			       (char *)NULL, 0);
	if (err)
	    error (1, 0, "correct above errors first!");

	if (find_args.argc == 0)
	{
	    /* Nothing to commit.  Exit now without contacting the
	       server (note that this means that we won't print "?
	       foo" for files which merit it, because we don't know
	       what is in the CVSROOT/cvsignore file).  */
	    dellist (&find_args.ulist);
	    return 0;
	}

	/* Now we keep track of which files we actually are going to
	   operate on, and only work with those files in the future.
	   This saves time--we don't want to search the file system
	   of the working directory twice.  */
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
	find_args.argc = 0;
	walklist (find_args.ulist, copy_ulist, &find_args);

	/* Do this before calling do_editor; don't ask for a log
	   message if we can't talk to the server.  But do it after we
	   have made the checks that we can locally (to more quickly
	   catch syntax errors, the case where no files are modified,
	   added or removed, etc.).

	   On the other hand, calling start_server before do_editor
	   means that we chew up server resources the whole time that
	   the user has the editor open (hours or days if the user
	   forgets about it), which seems dubious.  */
	start_server ();

	/*
	 * We do this once, not once for each directory as in normal CVS.
	 * The protocol is designed this way.  This is a feature.
	 */
	if (use_editor)
	    do_editor (".", &saved_message, (char *)NULL, find_args.ulist);

	/* Run the user-defined script to verify/check information in
	 *the log message
	 */
	do_verify (saved_message, (char *)NULL);

	/* We always send some sort of message, even if empty.  */
	/* FIXME: is that true?  There seems to be some code in do_editor
	   which can leave the message NULL.  */
	option_with_arg ("-m", saved_message);

	/* OK, now process all the questionable files we have been saving
	   up.  */
	{
	    struct question *p;
	    struct question *q;

	    p = find_args.questionables;
	    while (p != NULL)
	    {
		if (ign_inhibit_server || !supported_request ("Questionable"))
		{
		    cvs_output ("? ", 2);
		    if (p->dir[0] != '\0')
		    {
			cvs_output (p->dir, 0);
			cvs_output ("/", 1);
		    }
		    cvs_output (p->file, 0);
		    cvs_output ("\n", 1);
		}
		else
		{
		    send_to_server ("Directory ", 0);
		    send_to_server (p->dir[0] == '\0' ? "." : p->dir, 0);
		    send_to_server ("\012", 1);
		    send_to_server (p->repos, 0);
		    send_to_server ("\012", 1);

		    send_to_server ("Questionable ", 0);
		    send_to_server (p->file, 0);
		    send_to_server ("\012", 1);
		}
		free (p->dir);
		free (p->repos);
		free (p->file);
		q = p->next;
		free (p);
		p = q;
	    }
	}

	if (local)
	    send_arg("-l");
	if (force_ci)
	    send_arg("-f");
	if (!run_module_prog)
	    send_arg("-n");
	option_with_arg ("-r", saved_tag);

	/* FIXME: This whole find_args.force/SEND_FORCE business is a
	   kludge.  It would seem to be a server bug that we have to
	   say that files are modified when they are not.  This makes
	   "cvs commit -r 2" across a whole bunch of files a very slow
	   operation (and it isn't documented in cvsclient.texi).  I
	   haven't looked at the server code carefully enough to be
	   _sure_ why this is needed, but if it is because the "ci"
	   program, which we used to call, wanted the file to exist,
	   then it would be relatively simple to fix in the server.  */
	send_files (find_args.argc, find_args.argv, local, 0,
		    find_args.force ? SEND_FORCE : 0);

	/* Sending only the names of the files which were modified, added,
	   or removed means that the server will only do an up-to-date
	   check on those files.  This is different from local CVS and
	   previous versions of client/server CVS, but it probably is a Good
	   Thing, or at least Not Such A Bad Thing.  */
	send_file_names (find_args.argc, find_args.argv, 0);
	free (find_args.argv);
	dellist (&find_args.ulist);

	send_to_server ("ci\012", 0);
	err = get_responses_and_close ();
	if (err != 0 && use_editor && saved_message != NULL)
	{
	    /* If there was an error, don't nuke the user's carefully
	       constructed prose.  This is something of a kludge; a better
	       solution is probably more along the lines of #150 in TODO
	       (doing a second up-to-date check before accepting the
	       log message has also been suggested, but that seems kind of
	       iffy because the real up-to-date check could still fail,
	       another error could occur, &c.  Also, a second check would
	       slow things down).  */

	    char *fname;
	    FILE *fp;

	    fp = cvs_temp_file (&fname);
	    if (fp == NULL)
		error (1, 0, "cannot create temporary file %s", fname);
	    if (fwrite (saved_message, 1, strlen (saved_message), fp)
		!= strlen (saved_message))
		error (1, errno, "cannot write temporary file %s", fname);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close temporary file %s", fname);
	    error (0, 0, "saving log message in %s", fname);
	    free (fname);
	}
	return err;
    }
#endif

    if (saved_tag != NULL)
	tag_check_valid (saved_tag, argc, argv, local, aflag, "");

    /* XXX - this is not the perfect check for this */
    if (argc <= 0)
	write_dirtag = saved_tag;

    wrap_setup ();

    lock_tree_for_write (argc, argv, local, W_LOCAL, aflag);

    /*
     * Set up the master update list and hard link list
     */
    mulist = getlist ();

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	hardlist = getlist ();

	/*
	 * We need to save the working directory so that
	 * check_fileproc can construct a full pathname for each file.
	 */
	working_dir = xgetwd();
    }
#endif

    /*
     * Run the recursion processor to verify the files are all up-to-date
     */
    err = start_recursion (check_fileproc, check_filesdoneproc,
			   check_direntproc, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 1);
    if (err)
    {
	Lock_Cleanup ();
	error (1, 0, "correct above errors first!");
    }

    /*
     * Run the recursion processor to commit the files
     */
    write_dirnonbranch = 0;
    if (noexec == 0)
	err = start_recursion (commit_fileproc, commit_filesdoneproc,
			       commit_direntproc, commit_dirleaveproc, NULL,
			       argc, argv, local, W_LOCAL, aflag, 0,
			       (char *) NULL, 1);

    /*
     * Unlock all the dirs and clean up
     */
    Lock_Cleanup ();
    dellist (&mulist);

#ifdef SERVER_SUPPORT
    if (server_active)
	return err;
#endif

    /* see if we need to sleep before returning to avoid time-stamp races */
    if (last_register_time)
    {
	sleep_past (last_register_time);
    }

    return (err);
}

/* This routine determines the status of a given file and retrieves
   the version information that is associated with that file. */

static
Ctype
classify_file_internal (finfo, vers)
    struct file_info *finfo;
    Vers_TS **vers;
{
    int save_noexec, save_quiet, save_really_quiet;
    Ctype status;

    /* FIXME: Do we need to save quiet as well as really_quiet?  Last
       time I glanced at Classify_File I only saw it looking at really_quiet
       not quiet.  */
    save_noexec = noexec;
    save_quiet = quiet;
    save_really_quiet = really_quiet;
    noexec = quiet = really_quiet = 1;

    /* handle specified numeric revision specially */
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
    {
	/* If the tag is for the trunk, make sure we're at the head */
	if (numdots (saved_tag) < 2)
	{
	    status = Classify_File (finfo, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, vers, 0);
	    if (status == T_UPTODATE || status == T_MODIFIED ||
		status == T_ADDED)
	    {
		Ctype xstatus;

		freevers_ts (vers);
		xstatus = Classify_File (finfo, saved_tag, (char *) NULL,
					 (char *) NULL, 1, aflag, vers, 0);
		if (xstatus == T_REMOVE_ENTRY)
		    status = T_MODIFIED;
		else if (status == T_MODIFIED && xstatus == T_CONFLICT)
		    status = T_MODIFIED;
		else
		    status = xstatus;
	    }
	}
	else
	{
	    char *xtag, *cp;

	    /*
	     * The revision is off the main trunk; make sure we're
	     * up-to-date with the head of the specified branch.
	     */
	    xtag = xstrdup (saved_tag);
	    if ((numdots (xtag) & 1) != 0)
	    {
		cp = strrchr (xtag, '.');
		*cp = '\0';
	    }
	    status = Classify_File (finfo, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, vers, 0);
	    if ((status == T_REMOVE_ENTRY || status == T_CONFLICT)
		&& (cp = strrchr (xtag, '.')) != NULL)
	    {
		/* pluck one more dot off the revision */
		*cp = '\0';
		freevers_ts (vers);
		status = Classify_File (finfo, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, vers, 0);
		if (status == T_UPTODATE || status == T_REMOVE_ENTRY)
		    status = T_MODIFIED;
	    }
	    /* now, muck with vers to make the tag correct */
	    free ((*vers)->tag);
	    (*vers)->tag = xstrdup (saved_tag);
	    free (xtag);
	}
    }
    else
	status = Classify_File (finfo, saved_tag, (char *) NULL, (char *) NULL,
				1, 0, vers, 0);
    noexec = save_noexec;
    quiet = save_quiet;
    really_quiet = save_really_quiet;

    return status;
}

/*
 * Check to see if a file is ok to commit and make sure all files are
 * up-to-date
 */
/* ARGSUSED */
static int
check_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    Ctype status;
    char *xdir;
    Node *p;
    List *ulist, *cilist;
    Vers_TS *vers;
    struct commit_info *ci;
    struct logfile_info *li;

    size_t cvsroot_len = strlen (current_parsed_root->directory);

    if (!finfo->repository)
    {
	error (0, 0, "nothing known about `%s'", finfo->fullname);
	return (1);
    }

    if (strncmp (finfo->repository, current_parsed_root->directory, cvsroot_len) == 0
	&& ISDIRSEP (finfo->repository[cvsroot_len])
	&& strncmp (finfo->repository + cvsroot_len + 1,
		    CVSROOTADM,
		    sizeof (CVSROOTADM) - 1) == 0
	&& ISDIRSEP (finfo->repository[cvsroot_len + sizeof (CVSROOTADM)])
	&& strcmp (finfo->repository + cvsroot_len + sizeof (CVSROOTADM) + 1,
		   CVSNULLREPOS) == 0
	)
	error (1, 0, "cannot check in to %s", finfo->repository);

    status = classify_file_internal (finfo, &vers);

    /*
     * If the force-commit option is enabled, and the file in question
     * appears to be up-to-date, just make it look modified so that
     * it will be committed.
     */
    if (force_ci && status == T_UPTODATE)
	status = T_MODIFIED;

    switch (status)
    {
	case T_CHECKOUT:
	case T_PATCH:
	case T_NEEDS_MERGE:
	case T_CONFLICT:
	case T_REMOVE_ENTRY:
	    error (0, 0, "Up-to-date check failed for `%s'", finfo->fullname);
	    freevers_ts (&vers);
	    return (1);
	case T_MODIFIED:
	case T_ADDED:
	case T_REMOVED:
	    /*
	     * some quick sanity checks; if no numeric -r option specified:
	     *	- can't have a sticky date
	     *	- can't have a sticky tag that is not a branch
	     * Also,
	     *	- if status is T_REMOVED, can't have a numeric tag
	     *	- if status is T_ADDED, rcs file must not exist unless on
	     *    a branch or head is dead
	     *	- if status is T_ADDED, can't have a non-trunk numeric rev
	     *	- if status is T_MODIFIED and a Conflict marker exists, don't
	     *    allow the commit if timestamp is identical or if we find
	     *    an RCS_MERGE_PAT in the file.
	     */
	    if (!saved_tag || !isdigit ((unsigned char) *saved_tag))
	    {
		if (vers->date)
		{
		    error (0, 0,
			   "cannot commit with sticky date for file `%s'",
			   finfo->fullname);
		    freevers_ts (&vers);
		    return (1);
		}
		if (status == T_MODIFIED && vers->tag &&
		    !RCS_isbranch (finfo->rcs, vers->tag))
		{
		    error (0, 0,
			   "sticky tag `%s' for file `%s' is not a branch",
			   vers->tag, finfo->fullname);
		    freevers_ts (&vers);
		    return (1);
		}
	    }
	    if (status == T_MODIFIED && !force_ci && vers->ts_conflict)
	    {
		char *filestamp;
		int retcode;

		/*
		 * We found a "conflict" marker.
		 *
		 * If the timestamp on the file is the same as the
		 * timestamp stored in the Entries file, we block the commit.
		 */
#ifdef SERVER_SUPPORT
		if (server_active)
		    retcode = vers->ts_conflict[0] != '=';
		else {
		    filestamp = time_stamp (finfo->file);
		    retcode = strcmp (vers->ts_conflict, filestamp);
		    free (filestamp);
		}
#else
		filestamp = time_stamp (finfo->file);
		retcode = strcmp (vers->ts_conflict, filestamp);
		free (filestamp);
#endif
		if (retcode == 0)
		{
		    error (0, 0,
			  "file `%s' had a conflict and has not been modified",
			   finfo->fullname);
		    freevers_ts (&vers);
		    return (1);
		}

		if (file_has_markers (finfo))
		{
		    /* Make this a warning, not an error, because we have
		       no way of knowing whether the "conflict indicators"
		       are really from a conflict or whether they are part
		       of the document itself (cvs.texinfo and sanity.sh in
		       CVS itself, for example, tend to want to have strings
		       like ">>>>>>>" at the start of a line).  Making people
		       kludge this the way they need to kludge keyword
		       expansion seems undesirable.  And it is worse than
		       keyword expansion, because there is no -ko
		       analogue.  */
		    error (0, 0,
			   "\
warning: file `%s' seems to still contain conflict indicators",
			   finfo->fullname);
		}
	    }

	    if (status == T_REMOVED
		&& vers->tag
		&& isdigit ((unsigned char) *vers->tag))
	    {
		/* Remove also tries to forbid this, but we should check
		   here.  I'm only _sure_ about somewhat obscure cases
		   (hacking the Entries file, using an old version of
		   CVS for the remove and a new one for the commit), but
		   there might be other cases.  */
		error (0, 0,
	"cannot remove file `%s' which has a numeric sticky tag of `%s'",
			   finfo->fullname, vers->tag);
		freevers_ts (&vers);
		return (1);
	    }
	    if (status == T_ADDED)
	    {
	        if (vers->tag == NULL)
		{
		    if (finfo->rcs != NULL &&
			!RCS_isdead (finfo->rcs, finfo->rcs->head))
		    {
			error (0, 0,
		    "cannot add file `%s' when RCS file `%s' already exists",
			       finfo->fullname, finfo->rcs->path);
			freevers_ts (&vers);
			return (1);
		    }
		}
		else if (isdigit ((unsigned char) *vers->tag) &&
		    numdots (vers->tag) > 1)
		{
		    error (0, 0,
		"cannot add file `%s' with revision `%s'; must be on trunk",
			       finfo->fullname, vers->tag);
		    freevers_ts (&vers);
		    return (1);
		}
	    }

	    /* done with consistency checks; now, to get on with the commit */
	    if (finfo->update_dir[0] == '\0')
		xdir = ".";
	    else
		xdir = finfo->update_dir;
	    if ((p = findnode (mulist, xdir)) != NULL)
	    {
		ulist = ((struct master_lists *) p->data)->ulist;
		cilist = ((struct master_lists *) p->data)->cilist;
	    }
	    else
	    {
		struct master_lists *ml;

		ulist = getlist ();
		cilist = getlist ();
		p = getnode ();
		p->key = xstrdup (xdir);
		p->type = UPDATE;
		ml = (struct master_lists *)
		    xmalloc (sizeof (struct master_lists));
		ml->ulist = ulist;
		ml->cilist = cilist;
		p->data = (char *) ml;
		p->delproc = masterlist_delproc;
		(void) addnode (mulist, p);
	    }

	    /* first do ulist, then cilist */
	    p = getnode ();
	    p->key = xstrdup (finfo->file);
	    p->type = UPDATE;
	    p->delproc = update_delproc;
	    li = ((struct logfile_info *)
		  xmalloc (sizeof (struct logfile_info)));
	    li->type = status;
	    li->tag = xstrdup (vers->tag);
	    li->rev_old = xstrdup (vers->vn_rcs);
	    li->rev_new = NULL;
	    p->data = (char *) li;
	    (void) addnode (ulist, p);

	    p = getnode ();
	    p->key = xstrdup (finfo->file);
	    p->type = UPDATE;
	    p->delproc = ci_delproc;
	    ci = (struct commit_info *) xmalloc (sizeof (struct commit_info));
	    ci->status = status;
	    if (vers->tag)
		if (isdigit ((unsigned char) *vers->tag))
		    ci->rev = xstrdup (vers->tag);
		else
		    ci->rev = RCS_whatbranch (finfo->rcs, vers->tag);
	    else
		ci->rev = (char *) NULL;
	    ci->tag = xstrdup (vers->tag);
	    ci->options = xstrdup(vers->options);
	    p->data = (char *) ci;
	    (void) addnode (cilist, p);

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    if (preserve_perms)
	    {
		/* Add this file to hardlist, indexed on its inode.  When
		   we are done, we can find out what files are hardlinked
		   to a given file by looking up its inode in hardlist. */
		char *fullpath;
		Node *linkp;
		struct hardlink_info *hlinfo;

		/* Get the full pathname of the current file. */
		fullpath = xmalloc (strlen(working_dir) +
				    strlen(finfo->fullname) + 2);
		sprintf (fullpath, "%s/%s", working_dir, finfo->fullname);

		/* To permit following links in subdirectories, files
                   are keyed on finfo->fullname, not on finfo->name. */
		linkp = lookup_file_by_inode (fullpath);

		/* If linkp is NULL, the file doesn't exist... maybe
		   we're doing a remove operation? */
		if (linkp != NULL)
		{
		    /* Create a new hardlink_info node, which will record
		       the current file's status and the links listed in its
		       `hardlinks' delta field.  We will append this
		       hardlink_info node to the appropriate hardlist entry. */
		    hlinfo = (struct hardlink_info *)
			xmalloc (sizeof (struct hardlink_info));
		    hlinfo->status = status;
		    linkp->data = (char *) hlinfo;
		}
	    }
#endif

	    break;
	case T_UNKNOWN:
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
	    freevers_ts (&vers);
	    return (1);
	case T_UPTODATE:
	    break;
	default:
	    error (0, 0, "CVS internal error: unknown status %d", status);
	    break;
    }

    freevers_ts (&vers);
    return (0);
}

/*
 * By default, return the code that tells do_recursion to examine all
 * directories
 */
/* ARGSUSED */
static Dtype
check_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
{
    if (!isdir (dir))
	return (R_SKIP_ALL);

    if (!quiet)
	error (0, 0, "Examining %s", update_dir);

    return (R_PROCESS);
}

/*
 * Walklist proc to run pre-commit checks
 */
static int
precommit_list_proc (p, closure)
    Node *p;
    void *closure;
{
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == T_ADDED
	|| li->type == T_MODIFIED
	|| li->type == T_REMOVED)
    {
	run_arg (p->key);
    }
    return (0);
}

/*
 * Callback proc for pre-commit checking
 */
static int
precommit_proc (repository, filter)
    char *repository;
    char *filter;
{
    /* see if the filter is there, only if it's a full path */
    if (isabsolute (filter))
    {
    	char *s, *cp;

	s = xstrdup (filter);
	for (cp = s; *cp; cp++)
	    if (isspace ((unsigned char) *cp))
	    {
		*cp = '\0';
		break;
	    }
	if (!isfile (s))
	{
	    error (0, errno, "cannot find pre-commit filter `%s'", s);
	    free (s);
	    return (1);			/* so it fails! */
	}
	free (s);
    }

    run_setup (filter);
    run_arg (repository);
    (void) walklist (saved_ulist, precommit_list_proc, NULL);
    return (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL|RUN_REALLY));
}

/*
 * Run the pre-commit checks for the dir
 */
/* ARGSUSED */
static int
check_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
    int err;
    char *repos;
    char *update_dir;
    List *entries;
{
    int n;
    Node *p;

    /* find the update list for this dir */
    p = findnode (mulist, update_dir);
    if (p != NULL)
	saved_ulist = ((struct master_lists *) p->data)->ulist;
    else
	saved_ulist = (List *) NULL;

    /* skip the checks if there's nothing to do */
    if (saved_ulist == NULL || saved_ulist->list->next == saved_ulist->list)
	return (err);

    /* run any pre-commit checks */
    if ((n = Parse_Info (CVSROOTADM_COMMITINFO, repos, precommit_proc, 1)) > 0)
    {
	error (0, 0, "Pre-commit check failed");
	err += n;
    }

    return (err);
}

/*
 * Do the work of committing a file
 */
static int maxrev;
static char *sbranch;

/* ARGSUSED */
static int
commit_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    Node *p;
    int err = 0;
    List *ulist, *cilist;
    struct commit_info *ci;

    /* Keep track of whether write_dirtag is a branch tag.
       Note that if it is a branch tag in some files and a nonbranch tag
       in others, treat it as a nonbranch tag.  It is possible that case
       should elicit a warning or an error.  */
    if (write_dirtag != NULL
	&& finfo->rcs != NULL)
    {
	char *rev = RCS_getversion (finfo->rcs, write_dirtag, NULL, 1, NULL);
	if (rev != NULL
	    && !RCS_nodeisbranch (finfo->rcs, write_dirtag))
	    write_dirnonbranch = 1;
	if (rev != NULL)
	    free (rev);
    }

    if (finfo->update_dir[0] == '\0')
	p = findnode (mulist, ".");
    else
	p = findnode (mulist, finfo->update_dir);

    /*
     * if p is null, there were file type command line args which were
     * all up-to-date so nothing really needs to be done
     */
    if (p == NULL)
	return (0);
    ulist = ((struct master_lists *) p->data)->ulist;
    cilist = ((struct master_lists *) p->data)->cilist;

    /*
     * At this point, we should have the commit message unless we were called
     * with files as args from the command line.  In that latter case, we
     * need to get the commit message ourselves
     */
    if (!(got_message))
    {
	got_message = 1;
	if (use_editor)
	    do_editor (finfo->update_dir, &saved_message,
		       finfo->repository, ulist);
	do_verify (saved_message, finfo->repository);
    }

    p = findnode (cilist, finfo->file);
    if (p == NULL)
	return (0);

    ci = (struct commit_info *) p->data;
    if (ci->status == T_MODIFIED)
    {
	if (finfo->rcs == NULL)
	    error (1, 0, "internal error: no parsed RCS file");
	if (lock_RCS (finfo->file, finfo->rcs, ci->rev,
		      finfo->repository) != 0)
	{
	    unlockrcs (finfo->rcs);
	    err = 1;
	    goto out;
	}
    }
    else if (ci->status == T_ADDED)
    {
	if (checkaddfile (finfo->file, finfo->repository, ci->tag, ci->options,
			  &finfo->rcs) != 0)
	{
	    fixaddfile (finfo->file, finfo->repository);
	    err = 1;
	    goto out;
	}

	/* adding files with a tag, now means adding them on a branch.
	   Since the branch test was done in check_fileproc for
	   modified files, we need to stub it in again here. */

	if (ci->tag

	    /* If numeric, it is on the trunk; check_fileproc enforced
	       this.  */
	    && !isdigit ((unsigned char) ci->tag[0]))
	{
	    if (finfo->rcs == NULL)
		error (1, 0, "internal error: no parsed RCS file");
	    if (ci->rev)
		free (ci->rev);
	    ci->rev = RCS_whatbranch (finfo->rcs, ci->tag);
	    err = Checkin ('A', finfo, finfo->rcs->path, ci->rev,
			   ci->tag, ci->options, saved_message);
	    if (err != 0)
	    {
		unlockrcs (finfo->rcs);
		fixbranch (finfo->rcs, sbranch);
	    }

	    (void) time (&last_register_time);

	    ci->status = T_UPTODATE;
	}
    }

    /*
     * Add the file for real
     */
    if (ci->status == T_ADDED)
    {
	char *xrev = (char *) NULL;

	if (ci->rev == NULL)
	{
	    /* find the max major rev number in this directory */
	    maxrev = 0;
	    (void) walklist (finfo->entries, findmaxrev, NULL);
	    if (finfo->rcs->head) {
		/* resurrecting: include dead revision */
		int thisrev = atoi (finfo->rcs->head);
		if (thisrev > maxrev)
		    maxrev = thisrev;
	    }
	    if (maxrev == 0)
		maxrev = 1;
	    xrev = xmalloc (20);
	    (void) sprintf (xrev, "%d", maxrev);
	}

	/* XXX - an added file with symbolic -r should add tag as well */
	err = finaladd (finfo, ci->rev ? ci->rev : xrev, ci->tag, ci->options);
	if (xrev)
	    free (xrev);
    }
    else if (ci->status == T_MODIFIED)
    {
	err = Checkin ('M', finfo,
		       finfo->rcs->path, ci->rev, ci->tag,
		       ci->options, saved_message);

	(void) time (&last_register_time);

	if (err != 0)
	{
	    unlockrcs (finfo->rcs);
	    fixbranch (finfo->rcs, sbranch);
	}
    }
    else if (ci->status == T_REMOVED)
    {
	err = remove_file (finfo, ci->tag, saved_message);
#ifdef SERVER_SUPPORT
	if (server_active) {
	    server_scratch_entry_only ();
	    server_updated (finfo,
			    NULL,

			    /* Doesn't matter, it won't get checked.  */
			    SERVER_UPDATED,

			    (mode_t) -1,
			    (unsigned char *) NULL,
			    (struct buffer *) NULL);
	}
#endif
    }

    /* Clearly this is right for T_MODIFIED.  I haven't thought so much
       about T_ADDED or T_REMOVED.  */
    notify_do ('C', finfo->file, getcaller (), NULL, NULL, finfo->repository);

out:
    if (err != 0)
    {
	/* on failure, remove the file from ulist */
	p = findnode (ulist, finfo->file);
	if (p)
	    delnode (p);
    }
    else
    {
	/* On success, retrieve the new version number of the file and
           copy it into the log information (see logmsg.c
           (logfile_write) for more details).  We should only update
           the version number for files that have been added or
           modified but not removed.  Why?  classify_file_internal
           will return the version number of a file even after it has
           been removed from the archive, which is not the behavior we
           want for our commitlog messages; we want the old version
           number and then "NONE." */

	if (ci->status != T_REMOVED)
	{
	    p = findnode (ulist, finfo->file);
	    if (p)
	    {
		Vers_TS *vers;
		struct logfile_info *li;

		(void) classify_file_internal (finfo, &vers);
		li = (struct logfile_info *) p->data;
		li->rev_new = xstrdup (vers->vn_rcs);
		freevers_ts (&vers);
	    }
	}
    }
    if (SIG_inCrSect ())
	SIG_endCrSect ();

    return (err);
}

/*
 * Log the commit and clean up the update list
 */
/* ARGSUSED */
static int
commit_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    Node *p;
    List *ulist;

    p = findnode (mulist, update_dir);
    if (p == NULL)
	return (err);

    ulist = ((struct master_lists *) p->data)->ulist;

    got_message = 0;


    Update_Logfile (repository, saved_message, (FILE *) 0, ulist);

    /* Build the administrative files if necessary.  */
    {
	char *p;

	if (strncmp (current_parsed_root->directory, repository,
		     strlen (current_parsed_root->directory)) != 0)
	    error (0, 0,
		 "internal error: repository (%s) doesn't begin with root (%s)",
		   repository, current_parsed_root->directory);
	p = repository + strlen (current_parsed_root->directory);
	if (*p == '/')
	    ++p;
	if (strcmp ("CVSROOT", p) == 0
	    /* Check for subdirectories because people may want to create
	       subdirectories and list files therein in checkoutlist.  */
	    || strncmp ("CVSROOT/", p, strlen ("CVSROOT/")) == 0
	    )
	{
	    /* "Database" might a little bit grandiose and/or vague,
	       but "checked-out copies of administrative files, unless
	       in the case of modules and you are using ndbm in which
	       case modules.{pag,dir,db}" is verbose and excessively
	       focused on how the database is implemented.  */

	    /* mkmodules requires the absolute name of the CVSROOT directory.
	       Remove anything after the `CVSROOT' component -- this is
	       necessary when committing in a subdirectory of CVSROOT.  */
	    char *admin_dir = xstrdup (repository);
	    int cvsrootlen = strlen ("CVSROOT");
	    assert (admin_dir[p - repository + cvsrootlen] == '\0'
		    || admin_dir[p - repository + cvsrootlen] == '/');
	    admin_dir[p - repository + cvsrootlen] = '\0';

	    cvs_output (program_name, 0);
	    cvs_output (" ", 1);
	    cvs_output (command_name, 0);
	    cvs_output (": Rebuilding administrative file database\n", 0);
	    mkmodules (admin_dir);
	    free (admin_dir);
	}
    }

    if (err == 0 && run_module_prog)
    {
	FILE *fp;

	if ((fp = CVS_FOPEN (CVSADM_CIPROG, "r")) != NULL)
	{
	    char *line;
	    int line_length;
	    size_t line_chars_allocated;
	    char *repos;

	    line = NULL;
	    line_chars_allocated = 0;
	    line_length = get_line (&line, &line_chars_allocated, fp);
	    if (line_length > 0)
	    {
		/* Remove any trailing newline.  */
		if (line[line_length - 1] == '\n')
		    line[--line_length] = '\0';
		repos = Name_Repository ((char *) NULL, update_dir);
		run_setup (line);
		run_arg (repos);
		cvs_output (program_name, 0);
		cvs_output (" ", 1);
		cvs_output (command_name, 0);
		cvs_output (": Executing '", 0);
		run_print (stdout);
		cvs_output ("'\n", 0);
		cvs_flushout ();
		(void) run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
		free (repos);
	    }
	    else
	    {
		if (ferror (fp))
		    error (0, errno, "warning: error reading %s",
			   CVSADM_CIPROG);
	    }
	    if (line != NULL)
		free (line);
	    if (fclose (fp) < 0)
		error (0, errno, "warning: cannot close %s", CVSADM_CIPROG);
	}
	else
	{
	    if (! existence_error (errno))
		error (0, errno, "warning: cannot open %s", CVSADM_CIPROG);
	}
    }

    return (err);
}

/*
 * Get the log message for a dir
 */
/* ARGSUSED */
static Dtype
commit_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
{
    Node *p;
    List *ulist;
    char *real_repos;

    if (!isdir (dir))
	return (R_SKIP_ALL);

    /* find the update list for this dir */
    p = findnode (mulist, update_dir);
    if (p != NULL)
	ulist = ((struct master_lists *) p->data)->ulist;
    else
	ulist = (List *) NULL;

    /* skip the files as an optimization */
    if (ulist == NULL || ulist->list->next == ulist->list)
	return (R_SKIP_FILES);

    /* get commit message */
    real_repos = Name_Repository (dir, update_dir);
    got_message = 1;
    if (use_editor)
	do_editor (update_dir, &saved_message, real_repos, ulist);
    do_verify (saved_message, real_repos);
    free (real_repos);
    return (R_PROCESS);
}

/*
 * Process the post-commit proc if necessary
 */
/* ARGSUSED */
static int
commit_dirleaveproc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
{
    /* update the per-directory tag info */
    /* FIXME?  Why?  The "commit examples" node of cvs.texinfo briefly
       mentions commit -r being sticky, but apparently in the context of
       this being a confusing feature!  */
    if (err == 0 && write_dirtag != NULL)
    {
	char *repos = Name_Repository (dir, update_dir);
	WriteTag (NULL, write_dirtag, NULL, write_dirnonbranch,
		  update_dir, repos);
	free (repos);
    }

    return (err);
}

/*
 * find the maximum major rev number in an entries file
 */
static int
findmaxrev (p, closure)
    Node *p;
    void *closure;
{
    int thisrev;
    Entnode *entdata;

    entdata = (Entnode *) p->data;
    if (entdata->type != ENT_FILE)
	return (0);
    thisrev = atoi (entdata->version);
    if (thisrev > maxrev)
	maxrev = thisrev;
    return (0);
}

/*
 * Actually remove a file by moving it to the attic
 * XXX - if removing a ,v file that is a relative symbolic link to
 * another ,v file, we probably should add a ".." component to the
 * link to keep it relative after we move it into the attic.

   Return value is 0 on success, or >0 on error (in which case we have
   printed an error message).  */
static int
remove_file (finfo, tag, message)
    struct file_info *finfo;
    char *tag;
    char *message;
{
    int retcode;

    int branch;
    int lockflag;
    char *corev;
    char *rev;
    char *prev_rev;
    char *old_path;

    corev = NULL;
    rev = NULL;
    prev_rev = NULL;

    retcode = 0;

    if (finfo->rcs == NULL)
	error (1, 0, "internal error: no parsed RCS file");

    branch = 0;
    if (tag && !(branch = RCS_nodeisbranch (finfo->rcs, tag)))
    {
	/* a symbolic tag is specified; just remove the tag from the file */
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0)
	{
	    if (!quiet)
		error (0, retcode == -1 ? errno : 0,
		       "failed to remove tag `%s' from `%s'", tag,
		       finfo->fullname);
	    return (1);
	}
	RCS_rewrite (finfo->rcs, NULL, NULL);
	Scratch_Entry (finfo->entries, finfo->file);
	return (0);
    }

    /* we are removing the file from either the head or a branch */
    /* commit a new, dead revision. */

    /* Print message indicating that file is going to be removed. */
    cvs_output ("Removing ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output (";\n", 0);

    rev = NULL;
    lockflag = 1;
    if (branch)
    {
	char *branchname;

	rev = RCS_whatbranch (finfo->rcs, tag);
	if (rev == NULL)
	{
	    error (0, 0, "cannot find branch \"%s\".", tag);
	    return (1);
	}

	branchname = RCS_getbranch (finfo->rcs, rev, 1);
	if (branchname == NULL)
	{
	    /* no revision exists on this branch.  use the previous
	       revision but do not lock. */
	    corev = RCS_gettag (finfo->rcs, tag, 1, (int *) NULL);
	    prev_rev = xstrdup(rev);
	    lockflag = 0;
	} else
	{
	    corev = xstrdup (rev);
	    prev_rev = xstrdup(branchname);
	    free (branchname);
	}

    } else  /* Not a branch */
    {
        /* Get current head revision of file. */
	prev_rev = RCS_head (finfo->rcs);
    }

    /* if removing without a tag or a branch, then make sure the default
       branch is the trunk. */
    if (!tag && !branch)
    {
        if (RCS_setbranch (finfo->rcs, NULL) != 0)
	{
	    error (0, 0, "cannot change branch to default for %s",
		   finfo->fullname);
	    return (1);
	}
	RCS_rewrite (finfo->rcs, NULL, NULL);
    }

    /* check something out.  Generally this is the head.  If we have a
       particular rev, then name it.  */
    retcode = RCS_checkout (finfo->rcs, finfo->file, rev ? corev : NULL,
			    (char *) NULL, (char *) NULL, RUN_TTY,
			    (RCSCHECKOUTPROC) NULL, (void *) NULL);
    if (retcode != 0)
    {
	error (0, 0,
	       "failed to check out `%s'", finfo->fullname);
	return (1);
    }

    /* Except when we are creating a branch, lock the revision so that
       we can check in the new revision.  */
    if (lockflag)
    {
	if (RCS_lock (finfo->rcs, rev ? corev : NULL, 1) == 0)
	    RCS_rewrite (finfo->rcs, NULL, NULL);
    }

    if (corev != NULL)
	free (corev);

    retcode = RCS_checkin (finfo->rcs, finfo->file, message, rev,
			   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
    if (retcode	!= 0)
    {
	if (!quiet)
	    error (0, retcode == -1 ? errno : 0,
		   "failed to commit dead revision for `%s'", finfo->fullname);
	return (1);
    }
    /* At this point, the file has been committed as removed.  We should
       probably tell the history file about it  */
    history_write ('R', NULL, finfo->rcs->head, finfo->file, finfo->repository);

    if (rev != NULL)
	free (rev);

    old_path = xstrdup (finfo->rcs->path);
    if (!branch)
	RCS_setattic (finfo->rcs, 1);

    /* Print message that file was removed. */
    cvs_output (old_path, 0);
    cvs_output ("  <--  ", 0);
    cvs_output (finfo->file, 0);
    cvs_output ("\nnew revision: delete; previous revision: ", 0);
    cvs_output (prev_rev, 0);
    cvs_output ("\ndone\n", 0);
    free(prev_rev);

    free (old_path);

    Scratch_Entry (finfo->entries, finfo->file);
    return (0);
}

/*
 * Do the actual checkin for added files
 */
static int
finaladd (finfo, rev, tag, options)
    struct file_info *finfo;
    char *rev;
    char *tag;
    char *options;
{
    int ret;
    char *rcs;

    rcs = locate_rcs (finfo->file, finfo->repository);
    ret = Checkin ('A', finfo, rcs, rev, tag, options, saved_message);
    if (ret == 0)
    {
	char *tmp = xmalloc (strlen (finfo->file) + sizeof (CVSADM)
			     + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (tmp, "%s/%s%s", CVSADM, finfo->file, CVSEXT_LOG);
	if (unlink_file (tmp) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmp);
	free (tmp);
    }
    else
	fixaddfile (finfo->file, finfo->repository);

    (void) time (&last_register_time);
    free (rcs);

    return (ret);
}

/*
 * Unlock an rcs file
 */
static void
unlockrcs (rcs)
    RCSNode *rcs;
{
    int retcode;

    if ((retcode = RCS_unlock (rcs, NULL, 0)) != 0)
	error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
	       "could not unlock %s", rcs->path);
    else
	RCS_rewrite (rcs, NULL, NULL);
}

/*
 * remove a partially added file.  if we can parse it, leave it alone.
 */
static void
fixaddfile (file, repository)
    char *file;
    char *repository;
{
    RCSNode *rcsfile;
    char *rcs;
    int save_really_quiet;

    rcs = locate_rcs (file, repository);
    save_really_quiet = really_quiet;
    really_quiet = 1;
    if ((rcsfile = RCS_parsercsfile (rcs)) == NULL)
    {
	if (unlink_file (rcs) < 0)
	    error (0, errno, "cannot remove %s", rcs);
    }
    else
	freercsnode (&rcsfile);
    really_quiet = save_really_quiet;
    free (rcs);
}

/*
 * put the branch back on an rcs file
 */
static void
fixbranch (rcs, branch)
    RCSNode *rcs;
    char *branch;
{
    int retcode;

    if (branch != NULL)
    {
	if ((retcode = RCS_setbranch (rcs, branch)) != 0)
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "cannot restore branch to %s for %s", branch, rcs->path);
	RCS_rewrite (rcs, NULL, NULL);
    }
}

/*
 * do the initial part of a file add for the named file.  if adding
 * with a tag, put the file in the Attic and point the symbolic tag
 * at the committed revision.
 */

static int
checkaddfile (file, repository, tag, options, rcsnode)
    char *file;
    char *repository;
    char *tag;
    char *options;
    RCSNode **rcsnode;
{
    char *rcs;
    char *fname;
    mode_t omask;
    int retcode = 0;
    int newfile = 0;
    RCSNode *rcsfile = NULL;
    int retval;
    int adding_on_branch;

    /* Callers expect to be able to use either "" or NULL to mean the
       default keyword expansion.  */
    if (options != NULL && options[0] == '\0')
	options = NULL;
    if (options != NULL)
	assert (options[0] == '-' && options[1] == 'k');

    /* If numeric, it is on the trunk; check_fileproc enforced
       this.  */
    adding_on_branch = tag != NULL && !isdigit ((unsigned char) tag[0]);

    if (adding_on_branch)
    {
	rcs = xmalloc (strlen (repository) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
        (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	if (! isreadable (rcs))
	{
	    (void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcs);;
	    (void) umask (omask);
	    (void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
			    RCSEXT);
	}
    }
    else
	rcs = locate_rcs (file, repository);

    if (isreadable (rcs))
    {
	/* file has existed in the past.  Prepare to resurrect. */
	char *rev;
	char *oldexpand;

	if ((rcsfile = *rcsnode) == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    retval = 1;
	    goto out;
	}

	oldexpand = RCS_getexpand (rcsfile);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
	{
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcsfile, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcsfile->flags & INATTIC))
	    {
		error (0, 0, "warning: expected %s to be in Attic",
		       rcsfile->path);
	    }

	    sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);

	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

	    if (RCS_setattic (rcsfile, 0))
	    {
		retval = 1;
		goto out;
	    }
	}

	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
	/* and lock it */
	if (lock_RCS (file, rcsfile, rev, repository))
	{
	    error (0, 0, "cannot lock `%s'.", rcs);
	    if (rev != NULL)
		free (rev);
	    retval = 1;
	    goto out;
	}

	if (rev != NULL)
	    free (rev);
    }
    else
    {
	/* this is the first time we have ever seen this file; create
	   an rcs file.  */

	char *desc;
	size_t descalloc;
	size_t desclen;

	char *opt;

	desc = NULL;
	descalloc = 0;
	desclen = 0;
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
	    /* FIXME: Should be including update_dir in the appropriate
	       place here.  */
	    get_file (fname, fname, "r", &desc, &descalloc, &desclen);
	free (fname);

	/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the
	   end of the log message if the message is nonempty.
	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg,
	   which we don't try to do here.  */
	if (desclen > 0)
	{
	    expand_string (&desc, &descalloc, desclen + 1);
	    desc[desclen++] = '\012';
	}

	/* Set RCS keyword expansion options.  */
	if (options != NULL)
	    opt = options + 2;
	else
	    opt = NULL;

	/* This message is an artifact of the time when this
	   was implemented via "rcs -i".  It should be revised at
	   some point (does the "initial revision" in the message from
	   RCS_checkin indicate that this is a new file?  Or does the
	   "RCS file" message serve some function?).  */
	cvs_output ("RCS file: ", 0);
	cvs_output (rcs, 0);
	cvs_output ("\ndone\n", 0);

	if (add_rcs_file (NULL, rcs, file, NULL, opt,
			  NULL, NULL, 0, NULL,
			  desc, desclen, NULL) != 0)
	{
	    retval = 1;
	    goto out;
	}
	rcsfile = RCS_parsercsfile (rcs);
	newfile = 1;
	if (desc != NULL)
	    free (desc);
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}
    }

    /* when adding a file for the first time, and using a tag, we need
       to create a dead revision on the trunk.  */
    if (adding_on_branch)
    {
	if (newfile)
	{
	    char *tmp;
	    FILE *fp;

	    /* move the new file out of the way. */
	    fname = xmalloc (strlen (file) + sizeof (CVSADM)
			     + sizeof (CVSPREFIX) + 10);
	    (void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	    rename_file (file, fname);

	    /* Create empty FILE.  Can't use copy_file with a DEVNULL
	       argument -- copy_file now ignores device files. */
	    fp = fopen (file, "w");
	    if (fp == NULL)
		error (1, errno, "cannot open %s for writing", file);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", file);

	    tmp = xmalloc (strlen (file) + strlen (tag) + 80);
	    /* commit a dead revision. */
	    (void) sprintf (tmp, "file %s was initially added on branch %s.",
			    file, tag);
	    retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
				   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
	    free (tmp);
	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not create initial dead revision %s", rcs);
		retval = 1;
		goto out;
	    }

	    /* put the new file back where it was */
	    rename_file (fname, file);
	    free (fname);

	    /* double-check that the file was written correctly */
	    freercsnode (&rcsfile);
	    rcsfile = RCS_parse (file, repository);
	    if (rcsfile == NULL)
	    {
		error (0, 0, "could not read %s", rcs);
		retval = 1;
		goto out;
	    }
	    if (rcsnode != NULL)
		*rcsnode = rcsfile;

	    /* and lock it once again. */
	    if (lock_RCS (file, rcsfile, NULL, repository))
	    {
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
		goto out;
	    }
	}

	/* when adding with a tag, we need to stub a branch, if it
	   doesn't already exist.  */

	if (rcsfile == NULL)
	{
	    if (rcsnode != NULL && *rcsnode != NULL)
		rcsfile = *rcsnode;
	    else
	    {
		rcsfile = RCS_parse (file, repository);
		if (rcsfile == NULL)
		{
		    error (0, 0, "could not read %s", rcs);
		    retval = 1;
		    goto out;
		}
	    }
	}

	if (!RCS_nodeisbranch (rcsfile, tag))
	{
	    /* branch does not exist.  Stub it.  */
	    char *head;
	    char *magicrev;

	    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);
	    magicrev = RCS_magicrev (rcsfile, head);

	    retcode = RCS_settag (rcsfile, tag, magicrev);
	    RCS_rewrite (rcsfile, NULL, NULL);

	    free (head);
	    free (magicrev);

	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not stub branch %s for %s", tag, rcs);
		retval = 1;
		goto out;
	    }
	}
	else
	{
	    /* lock the branch. (stubbed branches need not be locked.)  */
	    if (lock_RCS (file, rcsfile, NULL, repository))
	    {
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
		goto out;
	    }
	}

	if (rcsnode && *rcsnode != rcsfile)
	{
	    freercsnode(rcsnode);
	    *rcsnode = rcsfile;
	}
    }

    fileattr_newfile (file);

    /* At this point, we used to set the file mode of the RCS file
       based on the mode of the file in the working directory.  If we
       are creating the RCS file for the first time, add_rcs_file does
       this already.  If we are re-adding the file, then perhaps it is
       consistent to preserve the old file mode, just as we preserve
       the old keyword expansion mode.

       If we decide that we should change the modes, then we can't do
       it here anyhow.  At this point, the RCS file may be owned by
       somebody else, so a chmod will fail.  We need to instead do the
       chmod after rewriting it.

       FIXME: In general, I think the file mode (and the keyword
       expansion mode) should be associated with a particular revision
       of the file, so that it is possible to have different revisions
       of a file have different modes.  */

    retval = 0;

 out:
    if (retval != 0 && SIG_inCrSect ())
	SIG_endCrSect ();
    free (rcs);
    return retval;
}

/*
 * Attempt to place a lock on the RCS file; returns 0 if it could and 1 if it
 * couldn't.  If the RCS file currently has a branch as the head, we must
 * move the head back to the trunk before locking the file, and be sure to
 * put the branch back as the head if there are any errors.
 */
static int
lock_RCS (user, rcs, rev, repository)
    char *user;
    RCSNode *rcs;
    char *rev;
    char *repository;
{
    char *branch = NULL;
    int err = 0;

    /*
     * For a specified, numeric revision of the form "1" or "1.1", (or when
     * no revision is specified ""), definitely move the branch to the trunk
     * before locking the RCS file.
     *
     * The assumption is that if there is more than one revision on the trunk,
     * the head points to the trunk, not a branch... and as such, it's not
     * necessary to move the head in this case.
     */
    if (rev == NULL
	|| (rev && isdigit ((unsigned char) *rev) && numdots (rev) < 2))
    {
	branch = xstrdup (rcs->branch);
	if (branch != NULL)
	{
	    if (RCS_setbranch (rcs, NULL) != 0)
	    {
		error (0, 0, "cannot change branch to default for %s",
		       rcs->path);
		if (branch)
		    free (branch);
		return (1);
	    }
	}
	err = RCS_lock(rcs, NULL, 1);
    }
    else
    {
	(void) RCS_lock(rcs, rev, 1);
    }

    /* We used to call RCS_rewrite here, and that might seem
       appropriate in order to write out the locked revision
       information.  However, such a call would actually serve no
       purpose.  CVS locks will prevent any interference from other
       CVS processes.  The comment above rcs_internal_lockfile
       explains that it is already unsafe to use RCS and CVS
       simultaneously.  It follows that writing out the locked
       revision information here would add no additional security.

       If we ever do care about it, the proper fix is to create the
       RCS lock file before calling this function, and maintain it
       until the checkin is complete.

       The call to RCS_lock is still required at present, since in
       some cases RCS_checkin will determine which revision to check
       in by looking for a lock.  FIXME: This is rather roundabout,
       and a more straightforward approach would probably be easier to
       understand.  */

    if (err == 0)
    {
	if (sbranch != NULL)
	    free (sbranch);
	sbranch = branch;
	return (0);
    }

    /* try to restore the branch if we can on error */
    if (branch != NULL)
	fixbranch (rcs, branch);

    if (branch)
	free (branch);
    return (1);
}

/*
 * free an UPDATE node's data
 */
void
update_delproc (p)
    Node *p;
{
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->tag)
	free (li->tag);
    if (li->rev_old)
	free (li->rev_old);
    if (li->rev_new)
	free (li->rev_new);
    free (li);
}

/*
 * Free the commit_info structure in p.
 */
static void
ci_delproc (p)
    Node *p;
{
    struct commit_info *ci;

    ci = (struct commit_info *) p->data;
    if (ci->rev)
	free (ci->rev);
    if (ci->tag)
	free (ci->tag);
    if (ci->options)
	free (ci->options);
    free (ci);
}

/*
 * Free the commit_info structure in p.
 */
static void
masterlist_delproc (p)
    Node *p;
{
    struct master_lists *ml;

    ml = (struct master_lists *) p->data;
    dellist (&ml->ulist);
    dellist (&ml->cilist);
    free (ml);
}

/* Find an RCS file in the repository.  Most parts of CVS will want to
   rely instead on RCS_parse which performs a similar operation and is
   called by recurse.c which then puts the result in useful places
   like the rcs field of struct file_info.

   REPOSITORY is the repository (including the directory) and FILE is
   the filename within that directory (without RCSEXT).  Returns a
   newly-malloc'd array containing the absolute pathname of the RCS
   file that was found.  */
static char *
locate_rcs (file, repository)
    char *file;
    char *repository;
{
    char *rcs;

    rcs = xmalloc (strlen (repository) + strlen (file) + sizeof (RCSEXT) + 10);
    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    if (!isreadable (rcs))
    {
	(void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file, RCSEXT);
	if (!isreadable (rcs))
	    (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
    }
    return rcs;
}
@


1.19
log
@Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.

ok millert@@
@
text
@d1485 1
a1485 1
	    line_length = getline (&line, &line_chars_allocated, fp);
@


1.18
log
@Merge local changes; work in progress
@
text
@d475 6
a480 1
	find_args.argv = (char **) xmalloc (find_args.argc * sizeof (char **));
@


1.18.10.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@d475 1
a475 6
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
@


1.18.12.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@d475 1
a475 6
	if (size_overflow_p (xtimes (find_args.argc, sizeof (char **))))
	{
	    find_args.argc = 0;
	    return 0;
	}
	find_args.argv = xmalloc (xtimes (find_args.argc, sizeof (char **)));
@


1.17
log
@Integrate local changes
@
text
@d88 7
a94 7
    "\t-n\tDo not run the module program (if any).\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-l\tLocal directory only (not recursive).\n",
    "\t-f\tForce the file to be committed; disables recursion.\n",
    "\t-F file\tRead the log message from file.\n",
    "\t-m msg\tLog message.\n",
    "\t-r rev\tCommit to this branch or trunk revision.\n",
d347 1
a347 1
	&& !client_active
d435 1
a435 1
    if (client_active)
d594 1
a594 2
	    fname = cvs_temp_name ();
	    fp = CVS_FOPEN (fname, "w+");
d603 1
d618 1
a618 1
    lock_tree_for_write (argc, argv, local, aflag);
d666 5
d674 1
a674 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
d785 1
a785 1
    size_t cvsroot_len = strlen (CVSroot_directory);
d793 1
a793 1
    if (strncmp (finfo->repository, CVSroot_directory, cvsroot_len) == 0
a816 1
#ifdef SERVER_SUPPORT
a817 1
#endif
d834 1
a834 1
	     *    a branch
d931 2
a932 12
		    char *rcs;

		    rcs = xmalloc (strlen (finfo->repository)
				   + strlen (finfo->file)
				   + sizeof RCSEXT
				   + 5);

		    /* Don't look in the attic; if it exists there we
		       will move it back out in checkaddfile.  */
		    sprintf(rcs, "%s/%s%s", finfo->repository, finfo->file,
			    RCSEXT);
		    if (isreadable (rcs))
d936 1
a936 1
			       finfo->fullname, rcs);
a937 1
			free (rcs);
a939 1
		    free (rcs);
d941 1
a941 1
		if (vers->tag && isdigit ((unsigned char) *vers->tag) &&
d1304 6
d1429 2
a1430 2
	if (strncmp (CVSroot_directory, repository,
		     strlen (CVSroot_directory)) != 0)
d1433 2
a1434 2
		   repository, CVSroot_directory);
	p = repository + strlen (CVSroot_directory);
a1594 1
    char *cp;
a1600 3
    cp = strchr (entdata->version, '.');
    if (cp != NULL)
	*cp = '\0';
a1601 2
    if (cp != NULL)
	*cp = '.';
d1949 1
a1949 1
		error (0, 0, "internal error: confused about attic for %s",
a1950 2
		retval = 1;
		goto out;
@


1.16
log
@Integrate local changes
@
text
@d266 1
d288 1
d426 1
a426 2
	int n, logfd;
	struct stat statbuf;
d431 1
a431 16
	/* FIXME: Why is this binary?  Needs more investigation.  */
	if ((logfd = CVS_OPEN (logfile, O_RDONLY | OPEN_BINARY)) < 0)
	    error (1, errno, "cannot open log file %s", logfile);

	if (fstat(logfd, &statbuf) < 0)
	    error (1, errno, "cannot find size of log file %s", logfile);

	saved_message = xmalloc (statbuf.st_size + 1);

	/* FIXME: Should keep reading until EOF, rather than assuming the
	   first read gets the whole thing.  */
	if ((n = read (logfd, saved_message, statbuf.st_size + 1)) < 0)
	    error (1, errno, "cannot read log message from %s", logfile);

	(void) close (logfd);
	saved_message[n] = '\0';
d462 1
d467 1
d469 1
d575 2
d666 1
d669 2
a670 8
	time_t now;

	for (;;)
	{
	    (void) time (&now);
	    if (now != last_register_time) break;
	    sleep (1);			/* to avoid time-stamp races */
	}
d783 6
d1285 2
d1397 2
d1499 1
d1582 1
d1584 2
a1585 1
		  update_dir, Name_Repository (dir, update_dir));
d1753 3
d1967 5
d2054 5
d2063 1
a2063 1
    if (adding_on_branch && newfile)
d2065 4
a2068 2
	char *tmp;
	FILE *fp;
d2070 13
a2082 28
	/* move the new file out of the way. */
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSPREFIX) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	rename_file (file, fname);

	/* Create empty FILE.  Can't use copy_file with a DEVNULL
	   argument -- copy_file now ignores device files. */
	fp = fopen (file, "w");
	if (fp == NULL)
	    error (1, errno, "cannot open %s for writing", file);
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", file);

	tmp = xmalloc (strlen (file) + strlen (tag) + 80);
	/* commit a dead revision. */
	(void) sprintf (tmp, "file %s was initially added on branch %s.",
			file, tag);
	retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
			       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
	free (tmp);
	if (retcode != 0)
	{
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "could not create initial dead revision %s", rcs);
	    retval = 1;
	    goto out;
	}
d2084 14
a2097 3
	/* put the new file back where it was */
	rename_file (fname, file);
	free (fname);
d2099 15
a2113 14
	/* double-check that the file was written correctly */
	freercsnode (&rcsfile);
	rcsfile = RCS_parse (file, repository);
	if (rcsfile == NULL)
	{
	    error (0, 0, "could not read %s", rcs);
	    retval = 1;
	    goto out;
	}
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}
d2115 7
a2121 6
	/* and lock it once again. */
	if (lock_RCS (file, rcsfile, NULL, repository))
	{
	    error (0, 0, "cannot lock `%s'.", rcs);
	    retval = 1;
	    goto out;
a2122 1
    }
a2123 2
    if (adding_on_branch)
    {
d2206 2
@


1.15
log
@Integrate local changes
@
text
@d679 1
a679 2
	(void) time (&now);
	if (now == last_register_time)
d681 2
@


1.14
log
@Integrate local changes
@
text
@a51 1
static void fix_rcs_modes PROTO((char *rcs, char *user));
d342 6
a347 1
    if (geteuid () == (uid_t) 0)
d413 1
a413 1
    if (saved_tag && isdigit (*saved_tag))
a567 7
	/* Sending only the names of the files which were modified, added,
	   or removed means that the server will only do an up-to-date
	   check on those files.  This is different from local CVS and
	   previous versions of client/server CVS, but it probably is a Good
	   Thing, or at least Not Such A Bad Thing.  */
	send_file_names (find_args.argc, find_args.argv, 0);

d580 7
d710 1
a710 1
    if (saved_tag && isdigit (*saved_tag))
d794 13
d845 1
a845 1
	    if (!saved_tag || !isdigit (*saved_tag))
d917 3
a919 1
	    if (status == T_REMOVED && vers->tag && isdigit (*vers->tag))
d958 1
a958 1
		if (vers->tag && isdigit (*vers->tag) &&
d1018 1
a1018 1
		if (isdigit (*vers->tag))
d1137 1
a1137 1
	    if (isspace (*cp))
d1284 5
a1288 1
	if (ci->tag)
d1622 3
a1624 1
 */
a1630 1
    mode_t omask;
a1631 1
    char *tmp;
a1720 10
#ifdef SERVER_SUPPORT
    if (server_active) {
	/* If this is the server, there will be a file sitting in the
	   temp directory which is the kludgy way in which server.c
	   tells time_stamp that the file is no longer around.  Remove
	   it so we can create temp files with that name (ignore errors).  */
	unlink_file (finfo->file);
    }
#endif

d1757 1
a1757 1
    old_path = finfo->rcs->path;
d1759 1
a1759 26
    {
	/* this was the head; really move it into the Attic */
	tmp = xmalloc(strlen(finfo->repository) +
		      sizeof('/') +
		      sizeof(CVSATTIC) +
		      sizeof('/') +
		      strlen(finfo->file) +
		      sizeof(RCSEXT) + 1);
	(void) sprintf (tmp, "%s/%s", finfo->repository, CVSATTIC);
	omask = umask (cvsumask);
	(void) CVS_MKDIR (tmp, 0777);
	(void) umask (omask);
	(void) sprintf (tmp, "%s/%s/%s%s", finfo->repository, CVSATTIC,
			finfo->file, RCSEXT);

	if (strcmp (finfo->rcs->path, tmp) != 0
	    && CVS_RENAME (finfo->rcs->path, tmp) == -1
	    && (isreadable (finfo->rcs->path) || !isreadable (tmp)))
	{
	    free(tmp);
	    return (1);
	}
	/* The old value of finfo->rcs->path is in old_path, and is
           freed below.  */
	finfo->rcs->path = tmp;
    }
d1770 1
a1770 2
    if (old_path != finfo->rcs->path)
	free (old_path);
d1796 3
a1798 1
	(void) unlink_file (tmp);
d1842 4
a1845 1
	(void) unlink_file (rcs);
d1892 12
d1905 1
a1905 1
    if (tag)
d1928 1
d1937 24
a1960 3
	if (tag == NULL)
	{
	    char *oldfile;
a1961 3
	    /* we are adding on the trunk, so move the file out of the
	       Attic. */
	    oldfile = xstrdup (rcs);
d1964 1
a1964 1
	    if (strcmp (oldfile, rcs) == 0)
a1965 4
		error (0, 0, "internal error: confused about attic for %s",
		       oldfile);
	    out1:
		free (oldfile);
a1968 17
	    if (CVS_RENAME (oldfile, rcs) != 0)
	    {
		error (0, errno, "failed to move `%s' out of the attic",
		       oldfile);
		goto out1;
	    }
	    if (isreadable (oldfile)
		|| !isreadable (rcs))
	    {
		error (0, 0, "\
internal error: `%s' didn't move out of the attic",
		       oldfile);
		goto out1;
	    }
	    free (oldfile);
	    free (rcsfile->path);
	    rcsfile->path = xstrdup (rcs);
d2021 1
a2021 1
	if (options && options[0] == '-' && options[1] == 'k')
d2050 1
a2050 1
    if (tag && newfile)
d2112 1
a2112 1
    if (tag != NULL)
d2176 16
a2191 7
    /* I don't think fix_rcs_modes is needed any more.  In the
       add_rcs_file case, the algorithms used by add_rcs_file and
       fix_rcs_modes are the same, so there is no need to go through
       it all twice.  In the other cases, I think we want to just
       preserve the mode that the file had before we started.  That is
       a behavior change, but I would think a desirable one.  */
    fix_rcs_modes (rcs, file);
d2225 2
a2226 1
    if (rev == NULL || (rev && isdigit (*rev) && numdots (rev) < 2))
a2280 63
}

/* Called when "add"ing files to the RCS respository.  It doesn't seem to
   be possible to get RCS to use the right mode, so we change it after
   the fact.  TODO: now that RCS has been librarified, we have the power
   to change this. */

static void
fix_rcs_modes (rcs, user)
    char *rcs;
    char *user;
{
    struct stat sb;
    mode_t rcs_mode;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Do ye nothing to the modes on a symbolic link. */
    if (preserve_perms && islink (user))
	return;
#endif

    if (CVS_STAT (user, &sb) < 0)
    {
	/* FIXME: Should be ->fullname.  */
	error (0, errno, "warning: cannot stat %s", user);
	return;
    }

    /* Now we compute the new mode.

       TODO: decide whether this whole thing can/should be skipped
       when `preserve_perms' is set.  Almost certainly so. -twp

       The algorithm that we use is:

       Write permission is always off (this is what RCS and CVS have always
       done).

       If S_IRUSR is on (user read), then the read permission of
       the RCS file will be on.  It would seem that if this is off,
       then other users can't do "cvs update" and such, so perhaps this
       should be hardcoded to being on (it is a strange case, though--the
       case in which a user file doesn't have user read permission on).

       If S_IXUSR is on (user execute), then set execute permission
       on the RCS file.  This allows other users who check out the file
       to get the right setting for whether a shell script (for example)
       has the executable bit set.

       The result of that calculation is modified by CVSUMASK.  The
       reason, of course, that the read and execute settings take the
       user bit and copy it to all three bits (user, group, other), is
       that it should be CVSUMASK, not the umask of individual users,
       which is the sole determiner of modes in the repository.  */

    rcs_mode = 0;
    if (sb.st_mode & S_IRUSR)
	rcs_mode |= S_IRUSR | S_IRGRP | S_IROTH;
    if (sb.st_mode & S_IXUSR)
	rcs_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
    rcs_mode &= ~cvsumask;
    if (chmod (rcs, rcs_mode) < 0)
	error (0, errno, "warning: cannot change mode of %s", rcs);
@


1.13
log
@Integrate local changes
@
text
@d1437 4
a1440 3
	    assert (admin_dir[p - repository + strlen ("CVSROOT")] == '\0'
		    || admin_dir[p - repository + strlen ("CVSROOT")] == '/');
	    admin_dir[p - repository + strlen ("CVSROOT")] = '\0';
@


1.12
log
@Integrate local changes
@
text
@d4 1
a4 1
 * 
d7 1
a7 1
 * 
d9 1
a9 1
 * 
d14 1
a14 1
 * 
d32 1
a32 1
			       char *options, RCSNode **rcsnode)); 
d77 1
a77 1
static char *tag;
d82 2
a83 1
static char *message;
d251 1
a251 1
    vers = Version_TS (&xfinfo, NULL, tag, NULL, 0, 0);
d368 1
a368 1
		if (message)
d370 2
a371 2
		    free (message);
		    message = NULL;
d374 1
a374 1
		message = xstrdup(optarg);
d377 3
a379 3
		if (tag)
		    free (tag);
		tag = xstrdup (optarg);
d409 1
a409 1
    if (tag && isdigit (*tag))
d413 2
a414 2
	while (tag[strlen (tag) - 1] == '.')
	    tag[strlen (tag) - 1] = '\0';
d423 1
a423 1
	if (message)
d433 1
a433 1
	message = xmalloc (statbuf.st_size + 1);
d437 1
a437 1
	if ((n = read (logfd, message, statbuf.st_size + 1)) < 0)
d441 1
a441 1
	message[n] = '\0';
d445 1
a445 1
    if (client_active) 
a446 1
	int err;
d461 1
a461 1
	find_args.force = force_ci || tag != NULL;
d503 1
a503 1
	    do_editor (".", &message, (char *)NULL, find_args.ulist);
d508 1
a508 1
	do_verify (message, (char *)NULL);  	
d513 1
a513 1
	option_with_arg ("-m", message);
d562 1
a562 1
	option_with_arg ("-r", tag);
d585 1
a585 1
	if (err != 0 && use_editor && message != NULL)
d603 2
a604 1
	    if (fwrite (message, 1, strlen (message), fp) != strlen (message))
d614 2
a615 2
    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, aflag, "");
d619 1
a619 1
	write_dirtag = tag;
a654 11
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	/* hardlist now includes a complete index of the files
	   to be committed, indexed by inode.  For each inode,
	   compile a list of the files that are linked to it,
	   and save this list in each file's hardlink_info node. */
	(void) walklist (hardlist, cache_hardlinks_proc, NULL);
    }
#endif

d676 1
a676 1
	if (now == last_register_time) 
d706 1
a706 1
    if (tag && isdigit (*tag))
d709 1
a709 1
	if (numdots (tag) < 2)
d719 1
a719 1
		xstatus = Classify_File (finfo, tag, (char *) NULL,
d737 1
a737 1
	    xtag = xstrdup (tag);
d758 1
a758 1
	    (*vers)->tag = xstrdup (tag);
d763 1
a763 1
	status = Classify_File (finfo, tag, (char *) NULL, (char *) NULL,
d789 1
a789 1
    
d828 1
a828 1
	    if (!tag || !isdigit (*tag))
a1039 1
		    hlinfo->links = NULL;
a1105 1
static List *ulist;
d1115 1
a1115 1
	
d1134 1
a1134 1
    (void) walklist (ulist, precommit_list_proc, NULL);
d1156 1
a1156 1
	ulist = ((struct master_lists *) p->data)->ulist;
d1158 1
a1158 1
	ulist = (List *) NULL;
d1161 1
a1161 1
    if (ulist == NULL || ulist->list->next == ulist->list)
d1229 3
a1231 2
	    do_editor (finfo->update_dir, &message, finfo->repository, ulist);
	do_verify (message, finfo->repository);  
d1271 1
a1271 1
			   ci->tag, ci->options, message);
d1311 1
a1311 1
		       ci->options, message);
d1323 1
a1323 1
	err = remove_file (finfo, ci->tag, message);
d1363 1
a1363 1
	
d1371 1
a1371 1
	    
d1407 1
a1407 1
    Update_Logfile (repository, message, (FILE *) 0, ulist);
d1415 3
a1417 1
	    error (0, 0, "internal error: repository (%s) doesn't begin with root (%s)", repository, CVSroot_directory);
d1421 5
a1425 1
	if (strcmp ("CVSROOT", p) == 0)
d1433 8
d1445 2
a1446 1
	    mkmodules (repository);
d1459 1
a1459 1
	    char *repository;
d1469 1
a1469 1
		repository = Name_Repository ((char *) NULL, update_dir);
d1471 1
a1471 1
		run_arg (repository);
d1479 1
a1479 1
		free (repository);
d1536 2
a1537 2
	do_editor (update_dir, &message, real_repos, ulist);
    do_verify (message, real_repos);  
d1629 1
a1629 1
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0) 
d1662 1
a1662 1
	
d1683 1
a1683 1
    
d1688 1
a1688 1
        if (RCS_setbranch (finfo->rcs, NULL) != 0) 
d1747 1
a1747 1
	tmp = xmalloc(strlen(finfo->repository) + 
d1757 3
a1759 2
	(void) sprintf (tmp, "%s/%s/%s%s", finfo->repository, CVSATTIC, finfo->file, RCSEXT);
	
d1802 1
a1802 1
    ret = Checkin ('A', finfo, rcs, rev, tag, options, message);
d1939 1
a1939 1
	    
d2162 1
a2162 1
	} 
d2208 1
a2208 1
     * 
@


1.11
log
@Integrate local changes
@
text
@d22 1
a84 1

d625 1
a625 1
     * Set up the master update list
d629 13
d654 11
d1019 37
d1344 3
a1346 2
			    (struct stat *) NULL,
			    (unsigned char *) NULL);
d1710 2
a1711 3
	if (!quiet)
	    error (0, retcode == -1 ? errno : 0,
		   "failed to check out `%s'", finfo->fullname);
d2045 1
d2052 8
a2059 1
	copy_file (DEVNULL, file);
d2228 19
a2246 1
    RCS_rewrite (rcs, NULL, NULL);
d2252 1
a2252 6
	if (branch)
	{
	    sbranch = branch;
	}
	else
	    sbranch = NULL;
d2267 2
a2268 1
   the fact.  */
d2278 6
d2292 3
@


1.10
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d95 1
d148 7
d157 7
d250 1
a250 1
    vers = Version_TS (&xfinfo, NULL, NULL, NULL, 0, 0);
d264 2
a265 2
	    error (0, 0, "use `cvs add' to create an entry for %s",
		   finfo->fullname);
d339 3
d363 1
a363 1
		use_editor = TRUE;
d365 1
a365 1
		use_editor = FALSE;
d392 1
a392 1
		use_editor = TRUE;
d394 1
a394 1
		use_editor = FALSE;
d446 1
d511 2
d577 3
a579 3
	   _sure_ why this is needed, but if it is because RCS_CI
	   wants the file to exist, then it would be relatively simple
	   (but not trivial) to fix in the server.  */
d584 26
a609 1
	return get_responses_and_close ();
d682 4
a685 1
    
d869 10
d880 2
a881 1
			   "file `%s' still contains conflict indicators",
a882 2
		    freevers_ts (&vers);
		    return (1);
d888 5
d1012 2
a1013 1
 * Print warm fuzzies while examining the dirs
d1024 3
d1083 2
a1084 1
    run_setup ("%s %s", filter, repository);
d1404 2
a1405 1
		run_setup ("%s %s", line, repository);
d1437 1
a1437 1
 * Get the log message for a dir and print a warm fuzzy
d1452 3
a1465 4
    /* print the warm fuzzy */
    if (!quiet)
	error (0, 0, "Committing %s", update_dir);

d1560 1
a1560 1
    if (tag && !(branch = RCS_isbranch (finfo->rcs, tag)))
d1563 1
a1563 1
	if ((retcode = RCS_deltag (finfo->rcs, tag, 1)) != 0) 
d1571 1
d1628 1
d1657 4
a1660 1
	RCS_lock (finfo->rcs, rev ? corev : NULL, 0);
d1665 1
a1665 1
    retcode = RCS_checkin (finfo->rcs->path, finfo->file, message, rev,
d1766 2
d1808 1
a1919 1
	run_setup ("%s%s -x,v/ -i", Rcsbin, RCS);
d1921 9
d1936 3
a1938 1
	    run_args ("-t%s/%s%s", CVSADM, file, CVSEXT_LOG);
d1941 10
d1953 16
a1968 3
	    run_arg (options);
	run_arg (rcs);
	if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
a1969 2
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "could not create %s", rcs);
d1973 1
d1975 2
d1996 1
a1996 1
	retcode = RCS_checkin (rcs, NULL, tmp, NULL,
d2011 2
a2012 1
	assert (rcsfile == NULL);
d2066 1
d2099 6
d2106 1
d2153 1
a2153 1
	err = RCS_lock(rcs, NULL, 0);
d2159 1
@


1.9
log
@Integrate local changes
@
text
@d335 1
a335 1
    optind = 1;
d549 10
@


1.8
log
@Integrate local changes
@
text
@d78 1
d127 4
d262 1
a262 1
	     && (force_ci || strcmp (vers->ts_user, vers->ts_rcs) != 0))
d336 1
a336 1
    while ((c = getopt (argc, argv, "nlRm:fF:r:")) != -1)
d438 6
d549 2
a550 1
	send_files (find_args.argc, find_args.argv, local, 0, 0, force_ci);
d588 1
d1064 15
d1411 3
d1416 2
a1417 6
	WriteTag ((char *) NULL, write_dirtag, (char *) NULL);
#ifdef SERVER_SUPPORT
	if (server_active)
	    server_set_sticky (update_dir, Name_Repository (dir, update_dir),
			       write_dirtag, (char *) NULL);
#endif
d1564 2
a1565 1
			    (char *) NULL, (char *) NULL, RUN_TTY);
@


1.7
log
@Integrate local changes
@
text
@d257 3
a259 1
	     && strcmp (vers->ts_user, vers->ts_rcs) != 0)
d538 1
a538 1
	send_files (find_args.argc, find_args.argv, local, 0, 0);
d2025 4
a2028 8
/*
 * Called when "add"ing files to the RCS respository, as it is necessary to
 * preserve the file modes in the same fashion that RCS does.  This would be
 * automatic except that we are placing the RCS ,v file very far away from
 * the user file, and I can't seem to convince RCS of the location of the
 * user file.  So we munge it here, after the ,v file has been successfully
 * initialized with "rcs -i".
 */
d2035 1
d2037 39
a2075 2
    if ( CVS_STAT (user, &sb) != -1)
	(void) chmod (rcs, (int) sb.st_mode & ~0222);
@


1.6
log
@Integrate local changes
@
text
@d57 1
a57 1
static void locate_rcs PROTO((char *file, char *repository, char *rcs));
d274 1
d473 5
d536 1
a536 1
	send_files (find_args.argc, find_args.argv, local, 0);
d567 1
a567 1
	lock_tree_cleanup ();
d583 1
a583 1
    lock_tree_cleanup ();
d600 6
a605 8
/*
 * Check to see if a file is ok to commit and make sure all files are
 * up-to-date
 */
/* ARGSUSED */
static int
check_fileproc (callerdat, finfo)
    void *callerdat;
d607 1
d609 1
d611 1
a611 8
    char *xdir;
    Node *p;
    List *ulist, *cilist;
    Vers_TS *vers;
    struct commit_info *ci;
    struct logfile_info *li;
    int save_noexec, save_quiet, save_really_quiet;

d624 1
a624 1
				    (char *) NULL, 1, aflag, &vers, 0);
d630 1
a630 1
		freevers_ts (&vers);
d632 1
a632 1
					 (char *) NULL, 1, aflag, &vers, 0);
d656 1
a656 1
				    (char *) NULL, 1, aflag, &vers, 0);
d662 1
a662 1
		freevers_ts (&vers);
d664 1
a664 1
					(char *) NULL, 1, aflag, &vers, 0);
d669 2
a670 2
	    free (vers->tag);
	    vers->tag = xstrdup (tag);
d676 1
a676 1
				1, 0, &vers, 0);
d681 23
d793 1
a793 16
		/*
		 * If the timestamps differ, look for Conflict indicators
		 * in the file to see if we should block the commit anyway
		 */
		run_setup ("%s", GREP);
		run_arg (RCS_MERGE_PAT);
		run_arg (finfo->file);
		retcode = run_exec (RUN_TTY, DEVNULL, RUN_TTY, RUN_REALLY);
		    
		if (retcode == -1)
		{
		    error (1, errno,
			   "fork failed while examining conflict in `%s'",
			   finfo->fullname);
		}
		else if (retcode == 0)
d815 6
a820 1
		    char rcs[PATH_MAX];
d832 1
d835 1
d885 2
d1036 1
a1036 1
static char sbranch[PATH_MAX];
d1068 2
a1069 2
    if (use_editor && !got_message)
      {
d1071 4
a1074 2
	do_editor (finfo->update_dir, &message, finfo->repository, ulist);
      }
d1193 27
d1297 4
a1300 2
		(void) printf ("%s %s: Executing '", program_name,
			       command_name);
d1302 1
a1302 1
		(void) printf ("'\n");
d1359 2
a1361 3
    {
	got_message = 1;
	real_repos = Name_Repository (dir, update_dir);
d1363 2
a1364 2
	free (real_repos);
    }
d1472 3
a1474 1
    (void) printf ("Removing %s;\n", finfo->fullname);
d1594 6
a1599 4
    (void) printf ("%s  <--  %s\n", old_path, finfo->file);
    (void) printf ("new revision: delete; ");
    (void) printf ("previous revision: %s\n", prev_rev);
    (void) printf ("done\n");
d1620 1
a1620 2
    char tmp[PATH_MAX];
    char rcs[PATH_MAX];
d1622 1
a1622 1
    locate_rcs (finfo->file, finfo->repository, rcs);
d1626 2
d1630 1
d1636 1
d1664 1
a1664 1
    char rcs[PATH_MAX];
d1667 1
a1667 1
    locate_rcs (file, repository, rcs);
d1675 1
d1688 1
a1688 1
    if (branch != NULL && branch[0] != '\0')
d1710 2
a1711 2
    char rcs[PATH_MAX];
    char fname[PATH_MAX];
d1716 1
d1720 2
d1735 1
a1735 1
	locate_rcs (file, repository, rcs);
d1737 1
a1737 1
    if (isreadable(rcs))
a1739 1
	char oldfile[PATH_MAX];
d1745 2
a1746 1
	    return (1);
d1751 2
d1755 1
a1755 1
	    strcpy (oldfile, rcs);
d1758 16
a1773 3
	    if (strcmp (oldfile, rcs) == 0
		|| CVS_RENAME (oldfile, rcs) != 0
		|| isreadable (oldfile)
d1776 4
a1779 3
		error (0, 0, "failed to move `%s' out of the attic.",
		       file);
		return (1);
d1781 1
d1788 2
a1789 1
	if (lock_RCS (file, rcsfile, rev, repository)) {
d1791 4
a1794 2
	    free (rev);
	    return (1);
d1797 5
a1801 2
	free (rev);
    } else {
d1806 2
d1813 1
d1823 2
a1824 1
	    return (1);
d1836 2
d1853 2
a1854 1
	    return (1);
d1859 1
d1866 2
a1867 1
	    return (1);
d1876 2
a1877 1
	if (lock_RCS (file, rcsfile, NULL, repository)) {
d1879 2
a1880 1
	    return (1);
d1899 2
a1900 1
		    return (1);
d1905 2
a1906 1
	if (!RCS_nodeisbranch (rcsfile, tag)) {
d1910 1
a1910 1
	    
d1923 2
a1924 1
		return (1);
d1930 2
a1931 1
	    if (lock_RCS (file, rcsfile, NULL, repository)) {
d1933 2
a1934 1
		return (1);
d1948 5
a1952 1
    return (0);
d2003 2
d2007 1
a2007 2
	    (void) strcpy (sbranch, branch);
	    free (branch);
d2010 1
a2010 1
	    sbranch[0] = '\0';
d2054 4
d2095 11
a2105 5
/*
 * Find an RCS file in the repository.
 */
static void
locate_rcs (file, repository, rcs)
d2108 1
d2110 2
a2111 1
{
d2119 1
@


1.5
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d17 1
d23 7
a29 3
static Dtype check_direntproc PROTO((char *dir, char *repos, char *update_dir));
static int check_fileproc PROTO((struct file_info *finfo));
static int check_filesdoneproc PROTO((int err, char *repos, char *update_dir));
d32 12
a43 7
static Dtype commit_direntproc PROTO((char *dir, char *repos, char *update_dir));
static int commit_dirleaveproc PROTO((char *dir, int err, char *update_dir));
static int commit_fileproc PROTO((struct file_info *finfo));
static int commit_filesdoneproc PROTO((int err, char *repository, char *update_dir));
static int finaladd PROTO((char *file, char *revision, char *tag,
			   char *options, char *update_dir,
			   char *repository, List *entries));
d45 2
a46 2
static int lock_RCS PROTO((char *user, char *rcs, char *rev, char *repository));
static int lockrcsfile PROTO((char *file, char *repository, char *rev));
d49 2
a50 2
static int remove_file PROTO((char *file, char *repository, char *tag,
			char *message, List *entries, RCSNode *rcsnode));
d53 2
a54 2
static void fixbranch PROTO((char *file, char *repository, char *branch));
static void unlockrcs PROTO((char *file, char *repository));
d98 12
d114 12
d128 64
a191 3
/* Pass as a static until we get around to fixing start_recursion to
   pass along a void * where we can stash it.  */
struct find_data *find_data_static;
d193 4
a196 1
static int find_fileproc PROTO ((struct file_info *finfo));
d203 2
a204 1
find_fileproc (finfo)
d210 15
a224 1
    struct find_data *args = find_data_static;
d226 5
a230 3
    vers = Version_TS ((char *)NULL, (char *)NULL, (char *)NULL,
		       (char *)NULL,
		       finfo->file, 0, 0, finfo->entries, (RCSNode *)NULL);
d234 4
d251 3
d271 4
d277 1
a277 1
    node->data = (char *) status;
d282 1
d400 1
a400 1
	if ((logfd = open (logfile, O_RDONLY | OPEN_BINARY)) < 0)
a423 4
	/* Note that we don't do ignore file processing here, and we
	   don't call ignore_files.  This means that we won't print "?
	   foo" for stray files.  Sounds OK, the doc only promises
	   that update does that.  */
d426 9
a434 5
	find_data_static = &find_args;
	err = start_recursion (find_fileproc, (FILESDONEPROC) NULL,
				(DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
				argc, argv, local, W_LOCAL, 0, 0,
				(char *)NULL, 0, 0);
d439 4
d453 10
a462 6
	/*
	 * Do this before calling do_editor; don't ask for a log
	 * message if we can't talk to the server.  But do it after we
	 * have made the checks that we can locally (to more quickly
	 * catch syntax errors, the case where no files are modified,
	 * added or removed, etc.).  */
d475 41
d557 2
a558 3
			   check_direntproc, (DIRLEAVEPROC) NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 1,
			   0);
d570 1
a570 1
			       commit_direntproc, commit_dirleaveproc,
d572 1
a572 1
			       (char *) NULL, 1, 0);
d600 2
a601 1
check_fileproc (finfo)
d610 1
d624 2
a625 3
	    status = Classify_File (finfo->file, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, finfo->repository,
				    finfo->entries, finfo->rcs, &vers, finfo->update_dir, 0);
d632 2
a633 4
		xstatus = Classify_File (finfo->file, tag, (char *) NULL,
					 (char *) NULL, 1, aflag, finfo->repository,
					 finfo->entries, finfo->rcs, &vers, finfo->update_dir,
					 0);
d656 2
a657 3
	    status = Classify_File (finfo->file, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, finfo->repository,
				    finfo->entries, finfo->rcs, &vers, finfo->update_dir, 0);
d664 2
a665 4
		status = Classify_File (finfo->file, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, finfo->repository,
					finfo->entries, finfo->rcs, &vers, finfo->update_dir,
					0);
d676 2
a677 3
	status = Classify_File (finfo->file, tag, (char *) NULL, (char *) NULL,
				1, 0, finfo->repository, finfo->entries, finfo->rcs, &vers,
				finfo->update_dir, 0);
d711 2
a712 1
	     *	- if status is T_ADDED, rcs file must not exist
d806 3
a808 1
		char rcs[PATH_MAX];
d810 12
a821 10
		/* Don't look in the attic; if it exists there we will
		   move it back out in checkaddfile.  */
		sprintf(rcs, "%s/%s%s", finfo->repository, finfo->file, RCSEXT);
		if (isreadable (rcs))
		{
		    error (0, 0,
		"cannot add file `%s' when RCS file `%s' already exists",
			   finfo->fullname, rcs);
		    freevers_ts (&vers);
		    return (1);
d867 5
a871 1
	    p->data = (char *) status;
d912 2
a913 1
check_direntproc (dir, repos, update_dir)
d917 1
d933 6
a938 2
    if (p->data == (char *) T_ADDED || p->data == (char *) T_MODIFIED ||
	p->data == (char *) T_REMOVED)
d985 2
a986 1
check_filesdoneproc (err, repos, update_dir)
d990 1
d1024 2
a1025 1
commit_fileproc (finfo)
a1031 1
    char rcs[PATH_MAX];
d1065 4
a1068 1
	if (lockrcsfile (finfo->file, finfo->repository, ci->rev) != 0)
d1070 1
a1070 1
	    unlockrcs (finfo->file, finfo->repository);
d1089 4
a1092 2
	if (ci->tag) {
	    locate_rcs (finfo->file, finfo->repository, rcs);
d1094 2
a1095 2
	    err = Checkin ('A', finfo->file, finfo->update_dir, finfo->repository, rcs, ci->rev,
			   ci->tag, ci->options, message, finfo->entries);
d1098 2
a1099 2
		unlockrcs (finfo->file, finfo->repository);
		fixbranch (finfo->file, finfo->repository, sbranch);
d1127 1
a1127 2
	err = finaladd (finfo->file, ci->rev ? ci->rev : xrev, ci->tag, ci->options,
			finfo->update_dir, finfo->repository, finfo->entries);
d1133 3
a1135 4
	locate_rcs (finfo->file, finfo->repository, rcs);
	err = Checkin ('M', finfo->file, finfo->update_dir, finfo->repository,
		       rcs, ci->rev, ci->tag,
		       ci->options, message, finfo->entries);
d1141 2
a1142 2
	    unlockrcs (finfo->file, finfo->repository);
	    fixbranch (finfo->file, finfo->repository, sbranch);
d1147 1
a1147 2
	err = remove_file (finfo->file, finfo->repository, ci->tag, message,
			   finfo->entries, finfo->rcs);
d1151 3
a1153 1
	    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d1155 3
a1157 1
			    SERVER_UPDATED, (struct stat *) NULL,
d1184 2
a1185 1
commit_filesdoneproc (err, repository, update_dir)
d1189 1
a1190 1
    char *xtag = (char *) NULL;
d1202 2
a1203 7
    /* see if we need to specify a per-directory or -r option tag */
    if (tag == NULL)
	ParseTag (&xtag, (char **) NULL);

    Update_Logfile (repository, message, tag ? tag : xtag, (FILE *) 0, ulist);
    if (xtag)
	free (xtag);
d1209 4
a1212 3
	if (strncmp (CVSroot, repository, strlen (CVSroot)) != 0)
	    error (0, 0, "internal error: repository doesn't begin with root");
	p = repository + strlen (CVSroot);
d1235 1
a1235 1
	if ((fp = fopen (CVSADM_CIPROG, "r")) != NULL)
d1285 2
a1286 1
commit_direntproc (dir, repos, update_dir)
d1290 1
d1327 2
a1328 1
commit_dirleaveproc (dir, err, update_dir)
d1332 1
d1361 2
d1381 2
a1382 3
remove_file (file, repository, tag, message, entries, rcsnode)
    char *file;
    char *repository;
a1384 2
    List *entries;
    RCSNode *rcsnode;
a1387 1
    char rcs[PATH_MAX];
d1395 1
d1403 2
a1404 1
    locate_rcs (file, repository, rcs);
d1407 1
a1407 1
    if (tag && !(branch = RCS_isbranch (rcsnode, tag)))
d1410 1
a1410 1
	if ((retcode = RCS_deltag (rcs, tag, 1)) != 0) 
d1414 2
a1415 1
		       "failed to remove tag `%s' from `%s'", tag, rcs);
d1418 1
a1418 1
	Scratch_Entry (entries, file);
d1426 1
a1426 1
    (void) printf ("Removing %s;\n", file);
d1429 1
a1429 1
    lockflag = RCS_FLAGS_LOCK;
d1434 1
a1434 1
	rev = RCS_whatbranch (rcsnode, tag);
d1441 1
a1441 6
	if (rcsnode == NULL)
	{
	    error (0, 0, "boy, I'm confused.");
	    return (1);
	}
	branchname = RCS_getbranch (rcsnode, rev, 1);
d1446 1
a1446 1
	    corev = RCS_gettag (rcsnode, tag, 1, 0);
a1457 1

d1459 1
a1459 6
	if (rcsnode == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    return (1);
	}
	prev_rev = RCS_head (rcsnode);
d1466 1
a1466 1
        if (RCS_setbranch (rcs, NULL) != 0) 
d1469 1
a1469 1
		   rcs);
d1480 1
a1480 1
	unlink_file (file);
d1485 3
a1487 4
       particular rev, then name it.  except when creating a branch,
       lock the rev we're checking out.  */
    retcode = RCS_checkout (rcs, "", rev ? corev : NULL, NULL, RUN_TTY,
                            lockflag, 1);
d1492 1
a1492 1
		   "failed to check out `%s'", rcs);
d1496 5
d1504 2
a1505 1
    retcode = RCS_checkin (rcs, NULL, message, rev, RCS_FLAGS_DEAD, 1);
d1510 1
a1510 1
		   "failed to commit dead revision for `%s'", rcs);
d1517 1
d1521 1
a1521 1
	tmp = xmalloc(strlen(repository) + 
d1525 1
a1525 1
		      strlen(file) +
d1527 1
a1527 1
	(void) sprintf (tmp, "%s/%s", repository, CVSATTIC);
d1531 1
a1531 1
	(void) sprintf (tmp, "%s/%s/%s%s", repository, CVSATTIC, file, RCSEXT);
d1533 3
a1535 3
	if (strcmp (rcs, tmp) != 0
	    && rename (rcs, tmp) == -1
	    && (isreadable (rcs) || !isreadable (tmp)))
d1540 3
a1542 1
	free(tmp);
d1546 1
a1546 1
    (void) printf ("%s  <--  %s\n", rcs, file);
d1552 4
a1555 1
    Scratch_Entry (entries, file);
d1563 2
a1564 2
finaladd (file, rev, tag, options, update_dir, repository, entries)
    char *file;
a1567 3
    char *update_dir;
    char *repository;
    List *entries;
d1573 2
a1574 3
    locate_rcs (file, repository, rcs);
    ret = Checkin ('A', file, update_dir, repository, rcs, rev, tag, options,
		   message, entries);
d1577 1
a1577 1
	(void) sprintf (tmp, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
d1581 1
a1581 1
	fixaddfile (file, repository);
d1592 2
a1593 3
unlockrcs (file, repository)
    char *file;
    char *repository;
d1595 1
a1595 4
    char rcs[PATH_MAX];
    int retcode = 0;

    locate_rcs (file, repository, rcs);
d1599 1
a1599 1
	       "could not unlock %s", rcs);
d1628 2
a1629 3
fixbranch (file, repository, branch)
    char *file;
    char *repository;
d1632 1
a1632 2
    char rcs[PATH_MAX];
    int retcode = 0;
a1635 1
	locate_rcs (file, repository, rcs);
d1638 1
a1638 1
		   "cannot restore branch to %s for %s", branch, rcs);
d1661 1
d1665 11
a1675 6
	(void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	omask = umask (cvsumask);
	if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
	    error (1, errno, "cannot make directory `%s'", rcs);;
	(void) umask (omask);
	(void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file, RCSEXT);
d1685 6
a1690 1
	RCSNode *rcsfile;
d1700 1
a1700 1
		|| rename (oldfile, rcs) != 0
d1708 2
d1712 1
a1712 7
	if ((rcsfile = *rcsnode) == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    return (1);
	}

	rev = RCS_getversion (rcsfile, tag, NULL, 1, 0);
d1714 1
a1714 1
	if (lock_RCS (file, rcs, rev, repository)) {
d1761 1
a1761 1
			       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET, 0);
d1772 14
a1785 1
	
d1787 1
a1787 1
	if (lock_RCS (file, rcs, NULL, repository)) {
a1796 1
	RCSNode *rcsfile;
a1797 1
	rcsfile = RCS_parse (file, repository);
d1800 11
a1810 2
	    error (0, 0, "could not read %s", rcs);
	    return (1);
d1812 1
a1812 1
	
d1818 1
a1818 1
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, 0);
d1820 7
a1826 1
	    if ((retcode = RCS_settag(rcs, tag, magicrev)) != 0)
a1831 13
	    
	    freercsnode (&rcsfile);
	    
	    /* reparse the file, then add it to our list. */
	    rcsfile = RCS_parse (file, repository);
	    if (rcsfile == NULL)
	    {
		error (0, 0, "could not reparse %s", rcs);
		return (1);
	    }

	    free (head);
	    free (magicrev);
d1836 1
a1836 1
	    if (lock_RCS (file, rcs, NULL, repository)) {
d1842 5
a1846 3
	if (rcsnode)
		freercsnode(rcsnode);
	*rcsnode = rcsfile;
a1855 18
 * Lock the rcs file ``file''
 */
static int
lockrcsfile (file, repository, rev)
    char *file;
    char *repository;
    char *rev;
{
    char rcs[PATH_MAX];

    locate_rcs (file, repository, rcs);
    if (lock_RCS (file, rcs, rev, repository) != 0)
	return (1);
    else
	return (0);
}

/*
d1864 1
a1864 1
    char *rcs;
a1867 1
    RCSNode *rcsfile;
d1882 2
a1883 6
	if ((rcsfile = RCS_parsercsfile (rcs)) == NULL)
	{
	    /* invalid rcs file? */
	    err = 1;
	}
	else
d1885 1
a1885 4
	    /* rcsfile is valid */
	    branch = xstrdup (rcsfile->branch);
	    freercsnode (&rcsfile);
	    if (branch != NULL)
d1887 5
a1891 8
		if (RCS_setbranch (rcs, NULL) != 0)
		{
		    error (0, 0, "cannot change branch to default for %s",
			   rcs);
		    if (branch)
			free (branch);
		    return (1);
		}
a1892 1
	    err = RCS_lock(rcs, NULL, 0);
d1894 1
d1915 1
a1915 1
	fixbranch (user, repository, branch);
d1937 1
a1937 1
    if (stat (user, &sb) != -1)
d1942 1
a1942 1
 * free an UPDATE node's data (really nothing to do)
d1948 6
a1953 1
    p->data = (char *) NULL;
@


1.4
log
@Integrate local changes to CVS
@
text
@d26 1
a26 1
			       char *options, List *srcfiles)); 
d40 1
a40 1
			char *message, List *entries, List *srcfiles));
a111 10
    char *fullname;

    fullname = xmalloc (strlen (finfo->update_dir) + strlen (finfo->file) + 10);
    fullname[0] = '\0';
    if (finfo->update_dir[0] != '\0')
    {
	strcat (fullname, finfo->update_dir);
	strcat (fullname, "/");
    }
    strcat (fullname, finfo->file);
d115 1
a115 1
		       finfo->file, 0, 0, finfo->entries, (List *)NULL);
d120 1
a120 2
    else if (vers->ts_user == NULL
	     && vers->vn_user == NULL)
d122 5
a126 2
	error (0, 0, "nothing known about `%s'", fullname);
	free (fullname);
d139 4
a142 5
	/* This covers unmodified files, as well as a variety of other cases
	   (e.g. "touch foo", "cvs ci foo").  FIXME: we probably should be
	   printing a message and returning 1 for many of those cases (but
	   I'm not sure exactly which ones).  */
	free (fullname);
d147 1
a147 8
    node->key = xmalloc (strlen (finfo->update_dir) + strlen (finfo->file) + 8);
    node->key[0] = '\0';
    if (finfo->update_dir[0] != '\0')
    {
	strcpy (node->key, finfo->update_dir);
	strcat (node->key, "/");
    }
    strcat (node->key, finfo->file);
a155 2
    free (fullname);

d272 1
d281 2
d353 1
a353 1
	send_file_names (find_args.argc, find_args.argv);
d449 1
a449 1
				    finfo->entries, finfo->srcfiles, &vers, finfo->update_dir, 0);
d458 1
a458 1
					 finfo->entries, finfo->srcfiles, &vers, finfo->update_dir,
d484 1
a484 1
				    finfo->entries, finfo->srcfiles, &vers, finfo->update_dir, 0);
d493 1
a493 1
					finfo->entries, finfo->srcfiles, &vers, finfo->update_dir,
d506 1
a506 1
				1, 0, finfo->repository, finfo->entries, finfo->srcfiles, &vers,
d529 1
a529 5
	    if (finfo->update_dir[0] == '\0')
		error (0, 0, "Up-to-date check failed for `%s'", finfo->file);
	    else
		error (0, 0, "Up-to-date check failed for `%s/%s'",
		       finfo->update_dir, finfo->file);
d551 3
a553 9
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
			       "cannot commit with sticky date for file `%s'",
			       finfo->file);
		    else
			error
			  (0, 0,
			   "cannot commit with sticky date for file `%s/%s'",
			   finfo->update_dir, finfo->file);
d558 1
a558 1
		    !RCS_isbranch (finfo->file, vers->tag, finfo->srcfiles))
d560 3
a562 9
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
			       "sticky tag `%s' for file `%s' is not a branch",
			       vers->tag, finfo->file);
		    else
			error
			  (0, 0,
			   "sticky tag `%s' for file `%s/%s' is not a branch",
			   vers->tag, finfo->update_dir, finfo->file);
d593 1
a593 2
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
d595 1
a595 5
			       finfo->file);
		    else
			error (0, 0,
		       "file `%s/%s' had a conflict and has not been modified",
			       finfo->update_dir, finfo->file);
d611 3
a613 8
		    if (finfo->update_dir[0] == '\0')
			error (1, errno,
			       "fork failed while examining conflict in `%s'",
			       finfo->file);
		    else
			error (1, errno,
			     "fork failed while examining conflict in `%s/%s'",
			       finfo->update_dir, finfo->file);
d617 3
a619 8
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
			       "file `%s' still contains conflict indicators",
			       finfo->file);
		    else
			error (0, 0,
			     "file `%s/%s' still contains conflict indicators",
			       finfo->update_dir, finfo->file);
d627 1
a627 2
		if (finfo->update_dir[0] == '\0')
		    error (0, 0,
d629 1
a629 5
			   finfo->file, vers->tag);
		else
		    error (0, 0,
	"cannot remove file `%s/%s' which has a numeric sticky tag of `%s'",
			   finfo->update_dir, finfo->file, vers->tag);
d642 1
a642 2
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
d644 1
a644 5
			       finfo->file, rcs);
		    else
			error (0, 0,
		"cannot add file `%s/%s' when RCS file `%s' already exists",
			       finfo->update_dir, finfo->file, rcs);
d651 1
a651 2
		    if (finfo->update_dir[0] == '\0')
			error (0, 0,
d653 1
a653 5
			       finfo->file, vers->tag);
		    else
			error (0, 0,
		"cannot add file `%s/%s' with revision `%s'; must be on trunk",
			       finfo->update_dir, finfo->file, vers->tag);
d705 1
a705 1
		    ci->rev = RCS_whatbranch (finfo->file, vers->tag, finfo->srcfiles);
d714 1
a714 4
	    if (finfo->update_dir[0] == '\0')
		error (0, 0, "nothing known about `%s'", finfo->file);
	    else
		error (0, 0, "nothing known about `%s/%s'", finfo->update_dir, finfo->file);
d888 1
a888 1
			  finfo->srcfiles) != 0)
d901 1
a901 1
	    ci->rev = RCS_whatbranch (finfo->file, ci->tag, finfo->srcfiles);
d958 1
a958 1
			   finfo->entries, finfo->srcfiles);
d1185 1
a1185 1
remove_file (file, repository, tag, message, entries, srcfiles)
d1191 1
a1191 1
    List *srcfiles;
a1202 2
    Node *p;
    RCSNode *rcsfile;
d1213 1
a1213 1
    if (tag && !(branch = RCS_isbranch (file, tag, srcfiles)))
d1239 1
a1239 1
	rev = RCS_whatbranch (file, tag, srcfiles);
d1246 1
a1246 2
	p = findnode (srcfiles, file);
	if (p == NULL)
d1251 1
a1251 2
	rcsfile = (RCSNode *) p->data;
	branchname = RCS_getbranch (rcsfile, rev, 1);
d1256 1
a1256 1
	    corev = RCS_gettag (rcsfile, tag, 1, 0);
d1270 1
a1270 2
	p = findnode (srcfiles, file);
	if (p == NULL)
d1275 1
a1275 2
	rcsfile = (RCSNode *) p->data;
	prev_rev = RCS_head (rcsfile);
d1465 1
a1465 1
checkaddfile (file, repository, tag, options, srcfiles)
d1470 1
a1470 1
    List *srcfiles;
a1494 1
	Node *p;
d1515 1
a1515 2
	p = findnode (srcfiles, file);
	if (p == NULL)
a1520 1
	rcsfile = (RCSNode *) p->data;
a1592 1
	Node *p;
d1602 1
a1602 1
	if (!RCS_nodeisbranch (tag, rcsfile)) {
d1636 1
a1636 9
	}	    

	/* add (replace) this rcs file to our list */
	p = findnode (srcfiles, file);

	if (p != NULL)
	  freercsnode((RCSNode **) &p->data);

	delnode(p);
d1638 3
a1640 1
	RCS_addnode (file, rcsfile, srcfiles);
@


1.3
log
@Integrate local changes
@
text
@a21 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)commit.c 1.101 94/10/07 $";
USE(rcsid);
#endif

d23 1
a23 2
static int check_fileproc PROTO((char *file, char *update_dir, char *repository,
			   List * entries, List * srcfiles));
d29 1
a29 2
static int commit_fileproc PROTO((char *file, char *update_dir, char *repository,
			    List * entries, List * srcfiles));
d71 2
d98 1
a98 1
static int find_fileproc PROTO ((char *, char *, char *, List *, List *));
d105 2
a106 6
find_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d114 1
a114 1
    fullname = xmalloc (strlen (update_dir) + strlen (file) + 10);
d116 1
a116 1
    if (update_dir[0] != '\0')
d118 1
a118 1
	strcat (fullname, update_dir);
d121 1
a121 1
    strcat (fullname, file);
d125 1
a125 1
		       file, 0, 0, entries, (List *)NULL);
d156 1
a156 1
    node->key = xmalloc (strlen (update_dir) + strlen (file) + 8);
d158 1
a158 1
    if (update_dir[0] != '\0')
d160 1
a160 1
	strcpy (node->key, update_dir);
d163 1
a163 1
    strcat (node->key, file);
d419 12
d440 2
a441 6
check_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d462 3
a464 3
	    status = Classify_File (file, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, repository,
				    entries, srcfiles, &vers, update_dir, 0);
d471 3
a473 3
		xstatus = Classify_File (file, tag, (char *) NULL,
					 (char *) NULL, 1, aflag, repository,
					 entries, srcfiles, &vers, update_dir,
d497 3
a499 3
	    status = Classify_File (file, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, repository,
				    entries, srcfiles, &vers, update_dir, 0);
d506 3
a508 3
		status = Classify_File (file, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, repository,
					entries, srcfiles, &vers, update_dir,
d520 3
a522 3
	status = Classify_File (file, tag, (char *) NULL, (char *) NULL,
				1, 0, repository, entries, srcfiles, &vers,
				update_dir, 0);
d544 2
a545 2
	    if (update_dir[0] == '\0')
		error (0, 0, "Up-to-date check failed for `%s'", file);
d548 1
a548 1
		       update_dir, file);
d570 1
a570 1
		    if (update_dir[0] == '\0')
d573 1
a573 1
			       file);
d578 1
a578 1
			   update_dir, file);
d583 1
a583 1
		    !RCS_isbranch (file, vers->tag, srcfiles))
d585 1
a585 1
		    if (update_dir[0] == '\0')
d588 1
a588 1
			       vers->tag, file);
d593 1
a593 1
			   vers->tag, update_dir, file);
d613 1
a613 1
		    filestamp = time_stamp (file);
d618 1
a618 1
		filestamp = time_stamp (file);
d624 1
a624 1
		    if (update_dir[0] == '\0')
d627 1
a627 1
			       file);
d631 1
a631 1
			       update_dir, file);
d642 1
a642 1
		run_arg (file);
d647 1
a647 1
		    if (update_dir[0] == '\0')
d650 1
a650 1
			       file);
d654 1
a654 1
			       update_dir, file);
d658 1
a658 1
		    if (update_dir[0] == '\0')
d661 1
a661 1
			       file);
d665 1
a665 1
			       update_dir, file);
d673 1
a673 1
		if (update_dir[0] == '\0')
d676 1
a676 1
			   file, vers->tag);
d680 1
a680 1
			   update_dir, file, vers->tag);
d687 1
a687 2
#ifndef DEATH_SUPPORT
#ifdef DEATH_SUPPORT
d690 1
a690 4
		sprintf(rcs, "%s/%s%s", repository, file, RCSEXT);
#else
		locate_rcs (file, repository, rcs);
#endif
d693 1
a693 1
		    if (update_dir[0] == '\0')
d696 1
a696 1
			       file, rcs);
d700 1
a700 1
			       update_dir, file, rcs);
a703 1
#endif
d707 1
a707 1
		    if (update_dir[0] == '\0')
d710 1
a710 1
			       file, vers->tag);
d714 1
a714 1
			       update_dir, file, vers->tag);
d721 1
a721 1
	    if (update_dir[0] == '\0')
d724 1
a724 1
		xdir = update_dir;
d750 1
a750 1
	    p->key = xstrdup (file);
d757 1
a757 1
	    p->key = xstrdup (file);
d766 1
a766 1
		    ci->rev = RCS_whatbranch (file, vers->tag, srcfiles);
d775 2
a776 2
	    if (update_dir[0] == '\0')
		error (0, 0, "nothing known about `%s'", file);
d778 1
a778 1
		error (0, 0, "nothing known about `%s/%s'", update_dir, file);
d901 2
a902 6
commit_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d910 1
a910 1
    if (update_dir[0] == '\0')
d913 1
a913 1
	p = findnode (mulist, update_dir);
d932 1
a932 1
	do_editor (update_dir, &message, repository, ulist);
d935 1
a935 1
    p = findnode (cilist, file);
d942 1
a942 1
	if (lockrcsfile (file, repository, ci->rev) != 0)
d944 1
a944 1
	    unlockrcs (file, repository);
d951 2
a952 2
	if (checkaddfile (file, repository, ci->tag, ci->options,
			  srcfiles) != 0)
d954 1
a954 1
	    fixaddfile (file, repository);
a958 1
#ifdef DEATH_SUPPORT
d964 4
a967 4
	    locate_rcs (file, repository, rcs);
	    ci->rev = RCS_whatbranch (file, ci->tag, srcfiles);
	    err = Checkin ('A', file, update_dir, repository, rcs, ci->rev,
			   ci->tag, ci->options, message, entries);
d970 2
a971 2
		unlockrcs (file, repository);
		fixbranch (file, repository, sbranch);
d974 2
a977 1
#endif /* DEATH_SUPPORT */
d991 1
a991 1
	    (void) walklist (entries, findmaxrev, NULL);
d999 2
a1000 2
	err = finaladd (file, ci->rev ? ci->rev : xrev, ci->tag, ci->options,
			update_dir, repository, entries);
d1006 2
a1007 2
	locate_rcs (file, repository, rcs);
	err = Checkin ('M', file, update_dir, repository,
d1009 4
a1012 1
		       ci->options, message, entries);
d1015 2
a1016 2
	    unlockrcs (file, repository);
	    fixbranch (file, repository, sbranch);
d1021 2
a1022 2
	err = remove_file (file, repository, ci->tag, message,
			   entries, srcfiles);
d1026 1
a1026 1
	    server_updated (file, update_dir, repository,
d1036 1
a1036 1
    notify_do ('C', file, getcaller (), NULL, NULL, repository);
d1042 1
a1042 1
	p = findnode (ulist, file);
d1080 25
a1261 1
#ifdef DEATH_SUPPORT
d1263 1
a1263 1
    char *lockflag;
a1272 2
    lockflag = 0;
#endif /* DEATH_SUPPORT */
a1277 1
#ifdef DEATH_SUPPORT
a1279 3
#else
    if (tag)
#endif
a1292 1
#ifdef DEATH_SUPPORT
d1300 1
a1300 1
    lockflag = "-l";
d1326 1
a1326 1
	    lockflag = "";
d1373 4
a1376 6
    run_setup ("%s%s %s %s%s %s", Rcsbin, RCS_CO,
	       lockflag,
	       rev ? "-r" : "",
	       rev ? corev : "", rcs); 
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, DEVNULL, RUN_NORMAL))
	!= 0) {
d1386 3
a1388 10
#ifdef DEATH_STATE
    run_setup ("%s%s -f -sdead %s%s", Rcsbin, RCS_CI, rev ? "-r" : "",
#else
    run_setup ("%s%s -K %s%s", Rcsbin, RCS_CI, rev ? "-r" : "",
#endif
	       rev ? rev : ""); 
    run_args ("-m%s", make_message_rcslegal (message));
    run_arg (rcs);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, DEVNULL, RUN_NORMAL))
	!= 0) {
a1398 3
#else /* No DEATH_SUPPORT */
    else
#endif /* No DEATH_SUPPORT */
a1412 1
#ifdef DEATH_SUPPORT
a1431 13
#else /* No DEATH_SUPPORT */

	if ((strcmp (rcs, tmp) == 0 || rename (rcs, tmp) != -1) ||
	    (!isreadable (rcs) && isreadable (tmp)))
 	{
	    Scratch_Entry (entries, file);
	    /* FIXME: should free tmp.  */
	    return (0);
	}
	/* FIXME: should free tmp.  */
    }
    return (1);
#endif /* No DEATH_SUPPORT */
d1461 3
a1545 1
#ifdef DEATH_SUPPORT
a1546 1
#endif
a1547 1
#ifndef DEATH_SUPPORT
a1557 1
#endif
a1559 1
#ifdef DEATH_SUPPORT
d1606 1
a1606 1
	run_setup ("%s%s -i", Rcsbin, RCS);
d1632 1
a1632 1
	
d1640 1
a1640 1
	(void) sprintf (tmp, "-mfile %s was initially added on branch %s.",
d1642 2
a1643 6
#ifdef DEATH_STATE
	run_setup ("%s%s -q -f -sdead", Rcsbin, RCS_CI);
#else
	run_setup ("%s%s -q -K", Rcsbin, RCS_CI);
#endif
	run_arg (tmp);
d1645 1
a1645 2
	run_arg (rcs);
	if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
a1721 14
#else /* No DEATH_SUPPORT */
    run_setup ("%s%s -i", Rcsbin, RCS);
    run_args ("-t%s/%s%s", CVSADM, file, CVSEXT_LOG);
    /* Set RCS keyword expansion options.  */
    if (options && options[0] == '-' && options[1] == 'k')
	run_arg (options);
    run_arg (rcs);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL)) != 0)
    {
	error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
	       "could not create %s", rcs);
	return (1);
    }
#endif /* No DEATH_SUPPORT */
@


1.2
log
@Fix it so we can resurrect dead files on tagged branches.
@
text
@d18 3
d32 1
a32 1
			 List *srcfiles)); 
a41 1
static int fsortcmp PROTO((const Node * p, const Node * q));
a42 1
static int lock_filesdoneproc PROTO((int err, char *repository, char *update_dir));
a76 1
static List *locklist;
d92 107
d317 29
d347 5
a351 4
	 * Do this now; don't ask for a log message if we can't talk to the
	 * server.  But if there is a syntax error in the options, give
	 * an error message without connecting.
	 */
a352 2
	
	ign_setup ();
a356 3
	 *
	 * We could provide the lists of changed, modified, etc. files,
	 * however.  Our failure to do so is just laziness, not design.
d359 1
a359 1
	    do_editor (".", &message, (char *)NULL, (List *)NULL);
d372 7
a378 1
	send_files (argc, argv, local, 0);
d380 1
a380 2
	if (fprintf (to_server, "ci\n") < 0)
	    error (1, errno, "writing to server");
d385 3
d394 1
a394 12
    /*
     * Run the recursion processor to find all the dirs to lock and lock all
     * the dirs
     */
    locklist = getlist ();
    err = start_recursion ((int (*) ()) NULL, lock_filesdoneproc,
			   (Dtype (*) ()) NULL, (int (*) ()) NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 0,
			   0);
    sortlist (locklist, fsortcmp);
    if (Writer_Lock (locklist) != 0)
	error (1, 0, "lock failed - giving up");
d405 1
a405 1
			   check_direntproc, (int (*) ()) NULL, argc,
d410 1
a410 1
	Lock_Cleanup ();
d426 1
a426 1
    Lock_Cleanup ();
a427 33
    dellist (&locklist);
    return (err);
}

/*
 * compare two lock list nodes (for sort)
 */
static int
fsortcmp (p, q)
    const Node *p;
    const Node *q;
{
    return (strcmp (p->key, q->key));
}

/*
 * Create a list of repositories to lock
 */
/* ARGSUSED */
static int
lock_filesdoneproc (err, repository, update_dir)
    int err;
    char *repository;
    char *update_dir;
{
    Node *p;

    p = getnode ();
    p->type = LOCK;
    p->key = xstrdup (repository);
    /* FIXME-KRP: this error condition should not simply be passed by. */
    if (p->key == NULL || addnode (locklist, p) != 0)
	freenode (p);
d641 1
a641 1
		run_setup ("%s -s", GREP);
d644 1
a644 1
		retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d961 2
a962 1
	if (checkaddfile (file, repository, ci->tag, srcfiles) != 0)
d1041 4
a1088 1
	char *cp;
a1089 2
	char line[MAXLINELEN];
	char *repository;
a1090 1
	/* It is not an error if Checkin.prog does not exist.  */
d1093 9
a1101 1
	    if (fgets (line, sizeof (line), fp) != NULL)
d1103 3
a1105 2
		if ((cp = strrchr (line, '\n')) != NULL)
		    *cp = '\0';
d1115 15
a1129 1
	    (void) fclose (fp);
d1314 1
a1314 1
	    corev = RCS_gettag (rcsfile, tag, 1);
d1410 1
a1410 1
	omask = umask (2);
a1471 2
	(void) sprintf (tmp, "%s/%s%s", CVSADM, file, CVSEXT_OPT);
	(void) unlink_file (tmp);
d1548 1
a1548 1
checkaddfile (file, repository, tag, srcfiles)
d1552 1
a1554 2
    FILE *fp;
    char *cp;
d1567 1
a1567 1
	omask = umask (2);
d1612 1
a1612 1
	rev = RCS_getversion (rcsfile, tag, NULL, 1);
d1632 3
a1634 20
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_OPT);
	fp = fopen (fname, "r");
	/* If the file does not exist, no big deal.  In particular, the
	   server does not (yet at least) create CVSEXT_OPT files.  */
	if (fp == NULL)
	{
	    if (errno != ENOENT)
		error (1, errno, "cannot open %s", fname);
	}
	else
	{
	    while (fgets (fname, sizeof (fname), fp) != NULL)
	    {
		if ((cp = strrchr (fname, '\n')) != NULL)
		    *cp = '\0';
		if (*fname)
		    run_arg (fname);
	    }
	    (void) fclose (fp);
	}
d1649 1
a1649 1
	char tmp[PATH_MAX];
d1655 2
a1656 1
	
d1658 2
a1659 1
	(void) sprintf (tmp, "-mfile %s was initially added on branch %s.", file, tag);
d1666 1
d1704 1
a1704 1
	    head = RCS_getversion (rcsfile, NULL, NULL, 0);
d1748 3
a1750 10
    (void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_OPT);
    fp = open_file (fname, "r");
    while (fgets (fname, sizeof (fname), fp) != NULL)
    {
	if ((cp = strrchr (fname, '\n')) != NULL)
	    *cp = '\0';
	if (*fname)
	    run_arg (fname);
    }
    (void) fclose (fp);
d1759 2
@


1.1
log
@Initial revision
@
text
@d592 1
a592 1

d613 1
d1446 1
d1457 1
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a17 3
#include "getline.h"
#include "edit.h"
#include "fileattr.h"
d29 1
a29 1
			       char *options, List *srcfiles)); 
d39 1
d41 1
d76 1
a91 107
#ifdef CLIENT_SUPPORT
struct find_data {
    List *ulist;
    int argc;
    char **argv;
};

/* Pass as a static until we get around to fixing start_recursion to
   pass along a void * where we can stash it.  */
struct find_data *find_data_static;

static int find_fileproc PROTO ((char *, char *, char *, List *, List *));

/* Machinery to find out what is modified, added, and removed.  It is
   possible this should be broken out into a new client_classify function;
   merging it with classify_file is almost sure to be a mess, though,
   because classify_file has all kinds of repository processing.  */
static int
find_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
{
    Vers_TS *vers;
    enum classify_type status;
    Node *node;
    struct find_data *args = find_data_static;
    char *fullname;

    fullname = xmalloc (strlen (update_dir) + strlen (file) + 10);
    fullname[0] = '\0';
    if (update_dir[0] != '\0')
    {
	strcat (fullname, update_dir);
	strcat (fullname, "/");
    }
    strcat (fullname, file);

    vers = Version_TS ((char *)NULL, (char *)NULL, (char *)NULL,
		       (char *)NULL,
		       file, 0, 0, entries, (List *)NULL);
    if (vers->ts_user == NULL
	&& vers->vn_user != NULL
	&& vers->vn_user[0] == '-')
	status = T_REMOVED;
    else if (vers->ts_user == NULL
	     && vers->vn_user == NULL)
    {
	error (0, 0, "nothing known about `%s'", fullname);
	free (fullname);
	return 1;
    }
    else if (vers->ts_user != NULL
	     && vers->vn_user != NULL
	     && vers->vn_user[0] == '0')
	status = T_ADDED;
    else if (vers->ts_user != NULL
	     && vers->ts_rcs != NULL
	     && strcmp (vers->ts_user, vers->ts_rcs) != 0)
	status = T_MODIFIED;
    else
    {
	/* This covers unmodified files, as well as a variety of other cases
	   (e.g. "touch foo", "cvs ci foo").  FIXME: we probably should be
	   printing a message and returning 1 for many of those cases (but
	   I'm not sure exactly which ones).  */
	free (fullname);
	return 0;
    }

    node = getnode ();
    node->key = xmalloc (strlen (update_dir) + strlen (file) + 8);
    node->key[0] = '\0';
    if (update_dir[0] != '\0')
    {
	strcpy (node->key, update_dir);
	strcat (node->key, "/");
    }
    strcat (node->key, file);

    node->type = UPDATE;
    node->delproc = update_delproc;
    node->data = (char *) status;
    (void)addnode (args->ulist, node);

    ++args->argc;

    free (fullname);

    return 0;
}

static int copy_ulist PROTO ((Node *, void *));

static int
copy_ulist (node, data)
    Node *node;
    void *data;
{
    struct find_data *args = (struct find_data *)data;
    args->argv[args->argc++] = node->key;
    return 0;
}
#endif /* CLIENT_SUPPORT */

a209 29
	struct find_data find_args;

	ign_setup ();

	/* Note that we don't do ignore file processing here, and we
	   don't call ignore_files.  This means that we won't print "?
	   foo" for stray files.  Sounds OK, the doc only promises
	   that update does that.  */
	find_args.ulist = getlist ();
	find_args.argc = 0;
	find_data_static = &find_args;
	err = start_recursion (find_fileproc, (FILESDONEPROC) NULL,
				(DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
				argc, argv, local, W_LOCAL, 0, 0,
				(char *)NULL, 0, 0);
	if (err)
	    error (1, 0, "correct above errors first!");

	if (find_args.argc == 0)
	    return 0;

	/* Now we keep track of which files we actually are going to
	   operate on, and only work with those files in the future.
	   This saves time--we don't want to search the file system
	   of the working directory twice.  */
	find_args.argv = (char **) xmalloc (find_args.argc * sizeof (char **));
	find_args.argc = 0;
	walklist (find_args.ulist, copy_ulist, &find_args);

d211 4
a214 5
	 * Do this before calling do_editor; don't ask for a log
	 * message if we can't talk to the server.  But do it after we
	 * have made the checks that we can locally (to more quickly
	 * catch syntax errors, the case where no files are modified,
	 * added or removed, etc.).  */
d216 2
d222 3
d227 1
a227 1
	    do_editor (".", &message, (char *)NULL, find_args.ulist);
d240 1
a240 7
	/* Sending only the names of the files which were modified, added,
	   or removed means that the server will only do an up-to-date
	   check on those files.  This is different from local CVS and
	   previous versions of client/server CVS, but it probably is a Good
	   Thing, or at least Not Such A Bad Thing.  */
	send_file_names (find_args.argc, find_args.argv);
	send_files (find_args.argc, find_args.argv, local, 0);
d242 2
a243 1
	send_to_server ("ci\012", 0);
a247 3
    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, aflag, "");

d254 12
a265 1
    lock_tree_for_write (argc, argv, local, aflag);
d276 1
a276 1
			   check_direntproc, (DIRLEAVEPROC) NULL, argc,
d281 1
a281 1
	lock_tree_cleanup ();
d297 1
a297 1
    lock_tree_cleanup ();
d299 33
d545 1
a545 1
		run_setup ("%s", GREP);
d548 1
a548 1
		retcode = run_exec (RUN_TTY, DEVNULL, RUN_TTY, RUN_REALLY);
d864 1
a864 2
	if (checkaddfile (file, repository, ci->tag, ci->options,
			  srcfiles) != 0)
a942 4
    /* Clearly this is right for T_MODIFIED.  I haven't thought so much
       about T_ADDED or T_REMOVED.  */
    notify_do ('C', file, getcaller (), NULL, NULL, repository);

d987 1
d989 2
d992 1
d995 1
a995 9
	    char *line;
	    int line_length;
	    size_t line_chars_allocated;
	    char *repository;

	    line = NULL;
	    line_chars_allocated = 0;
	    line_length = getline (&line, &line_chars_allocated, fp);
	    if (line_length > 0)
d997 2
a998 3
		/* Remove any trailing newline.  */
		if (line[line_length - 1] == '\n')
		    line[--line_length] = '\0';
d1008 1
a1008 15
	    else
	    {
		if (ferror (fp))
		    error (0, errno, "warning: error reading %s",
			   CVSADM_CIPROG);
	    }
	    if (line != NULL)
		free (line);
	    if (fclose (fp) < 0)
		error (0, errno, "warning: cannot close %s", CVSADM_CIPROG);
	}
	else
	{
	    if (! existence_error (errno))
		error (0, errno, "warning: cannot open %s", CVSADM_CIPROG);
d1193 1
a1193 1
	    corev = RCS_gettag (rcsfile, tag, 1, 0);
d1289 1
a1289 1
	omask = umask (cvsumask);
d1351 2
d1429 1
a1429 1
checkaddfile (file, repository, tag, options, srcfiles)
a1432 1
    char *options;
d1435 2
d1448 1
a1448 1
	omask = umask (cvsumask);
d1492 1
a1492 1
	rev = RCS_getversion (rcsfile, tag, NULL, 1, 0);
d1512 20
a1531 3
	/* Set RCS keyword expansion options.  */
	if (options && options[0] == '-' && options[1] == 'k')
	    run_arg (options);
d1546 1
a1546 1
	char *tmp;
d1552 1
a1552 2

	tmp = xmalloc (strlen (file) + strlen (tag) + 80);
d1554 1
a1554 2
	(void) sprintf (tmp, "-mfile %s was initially added on branch %s.",
			file, tag);
a1560 1
	free (tmp);
d1598 1
a1598 1
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, 0);
d1642 10
a1651 3
    /* Set RCS keyword expansion options.  */
    if (options && options[0] == '-' && options[1] == 'k')
	run_arg (options);
a1659 2

    fileattr_newfile (file);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d22 5
d28 2
a29 1
static int check_fileproc PROTO((struct file_info *finfo));
d35 2
a36 1
static int commit_fileproc PROTO((struct file_info *finfo));
a77 2
static time_t last_register_time;

d103 1
a103 1
static int find_fileproc PROTO ((struct file_info *finfo));
d110 6
a115 2
find_fileproc (finfo)
    struct file_info *finfo;
d123 1
a123 1
    fullname = xmalloc (strlen (finfo->update_dir) + strlen (finfo->file) + 10);
d125 1
a125 1
    if (finfo->update_dir[0] != '\0')
d127 1
a127 1
	strcat (fullname, finfo->update_dir);
d130 1
a130 1
    strcat (fullname, finfo->file);
d134 1
a134 1
		       finfo->file, 0, 0, finfo->entries, (List *)NULL);
d165 1
a165 1
    node->key = xmalloc (strlen (finfo->update_dir) + strlen (finfo->file) + 8);
d167 1
a167 1
    if (finfo->update_dir[0] != '\0')
d169 1
a169 1
	strcpy (node->key, finfo->update_dir);
d172 1
a172 1
    strcat (node->key, finfo->file);
a427 12

    if (last_register_time)
    {
	time_t now;

	(void) time (&now);
	if (now == last_register_time) 
	{
	    sleep (1);			/* to avoid time-stamp races */
	}
    }

d437 6
a442 2
check_fileproc (finfo)
    struct file_info *finfo;
d463 3
a465 3
	    status = Classify_File (finfo->file, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, finfo->repository,
				    finfo->entries, finfo->srcfiles, &vers, finfo->update_dir, 0);
d472 3
a474 3
		xstatus = Classify_File (finfo->file, tag, (char *) NULL,
					 (char *) NULL, 1, aflag, finfo->repository,
					 finfo->entries, finfo->srcfiles, &vers, finfo->update_dir,
d498 3
a500 3
	    status = Classify_File (finfo->file, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, finfo->repository,
				    finfo->entries, finfo->srcfiles, &vers, finfo->update_dir, 0);
d507 3
a509 3
		status = Classify_File (finfo->file, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, finfo->repository,
					finfo->entries, finfo->srcfiles, &vers, finfo->update_dir,
d521 3
a523 3
	status = Classify_File (finfo->file, tag, (char *) NULL, (char *) NULL,
				1, 0, finfo->repository, finfo->entries, finfo->srcfiles, &vers,
				finfo->update_dir, 0);
d545 2
a546 2
	    if (finfo->update_dir[0] == '\0')
		error (0, 0, "Up-to-date check failed for `%s'", finfo->file);
d549 1
a549 1
		       finfo->update_dir, finfo->file);
d571 1
a571 1
		    if (finfo->update_dir[0] == '\0')
d574 1
a574 1
			       finfo->file);
d579 1
a579 1
			   finfo->update_dir, finfo->file);
d584 1
a584 1
		    !RCS_isbranch (finfo->file, vers->tag, finfo->srcfiles))
d586 1
a586 1
		    if (finfo->update_dir[0] == '\0')
d589 1
a589 1
			       vers->tag, finfo->file);
d594 1
a594 1
			   vers->tag, finfo->update_dir, finfo->file);
d614 1
a614 1
		    filestamp = time_stamp (finfo->file);
d619 1
a619 1
		filestamp = time_stamp (finfo->file);
d625 1
a625 1
		    if (finfo->update_dir[0] == '\0')
d628 1
a628 1
			       finfo->file);
d632 1
a632 1
			       finfo->update_dir, finfo->file);
d643 1
a643 1
		run_arg (finfo->file);
d648 1
a648 1
		    if (finfo->update_dir[0] == '\0')
d651 1
a651 1
			       finfo->file);
d655 1
a655 1
			       finfo->update_dir, finfo->file);
d659 1
a659 1
		    if (finfo->update_dir[0] == '\0')
d662 1
a662 1
			       finfo->file);
d666 1
a666 1
			       finfo->update_dir, finfo->file);
d674 1
a674 1
		if (finfo->update_dir[0] == '\0')
d677 1
a677 1
			   finfo->file, vers->tag);
d681 1
a681 1
			   finfo->update_dir, finfo->file, vers->tag);
d689 1
d692 4
a695 1
		sprintf(rcs, "%s/%s%s", finfo->repository, finfo->file, RCSEXT);
d698 1
a698 1
		    if (finfo->update_dir[0] == '\0')
d701 1
a701 1
			       finfo->file, rcs);
d705 1
a705 1
			       finfo->update_dir, finfo->file, rcs);
d712 1
a712 1
		    if (finfo->update_dir[0] == '\0')
d715 1
a715 1
			       finfo->file, vers->tag);
d719 1
a719 1
			       finfo->update_dir, finfo->file, vers->tag);
d726 1
a726 1
	    if (finfo->update_dir[0] == '\0')
d729 1
a729 1
		xdir = finfo->update_dir;
d755 1
a755 1
	    p->key = xstrdup (finfo->file);
d762 1
a762 1
	    p->key = xstrdup (finfo->file);
d771 1
a771 1
		    ci->rev = RCS_whatbranch (finfo->file, vers->tag, finfo->srcfiles);
d780 2
a781 2
	    if (finfo->update_dir[0] == '\0')
		error (0, 0, "nothing known about `%s'", finfo->file);
d783 1
a783 1
		error (0, 0, "nothing known about `%s/%s'", finfo->update_dir, finfo->file);
d906 6
a911 2
commit_fileproc (finfo)
    struct file_info *finfo;
d919 1
a919 1
    if (finfo->update_dir[0] == '\0')
d922 1
a922 1
	p = findnode (mulist, finfo->update_dir);
d941 1
a941 1
	do_editor (finfo->update_dir, &message, finfo->repository, ulist);
d944 1
a944 1
    p = findnode (cilist, finfo->file);
d951 1
a951 1
	if (lockrcsfile (finfo->file, finfo->repository, ci->rev) != 0)
d953 1
a953 1
	    unlockrcs (finfo->file, finfo->repository);
d960 2
a961 2
	if (checkaddfile (finfo->file, finfo->repository, ci->tag, ci->options,
			  finfo->srcfiles) != 0)
d963 1
a963 1
	    fixaddfile (finfo->file, finfo->repository);
d968 1
d974 4
a977 4
	    locate_rcs (finfo->file, finfo->repository, rcs);
	    ci->rev = RCS_whatbranch (finfo->file, ci->tag, finfo->srcfiles);
	    err = Checkin ('A', finfo->file, finfo->update_dir, finfo->repository, rcs, ci->rev,
			   ci->tag, ci->options, message, finfo->entries);
d980 2
a981 2
		unlockrcs (finfo->file, finfo->repository);
		fixbranch (finfo->file, finfo->repository, sbranch);
a983 2
	    (void) time (&last_register_time);

d986 1
d1000 1
a1000 1
	    (void) walklist (finfo->entries, findmaxrev, NULL);
d1008 2
a1009 2
	err = finaladd (finfo->file, ci->rev ? ci->rev : xrev, ci->tag, ci->options,
			finfo->update_dir, finfo->repository, finfo->entries);
d1015 2
a1016 2
	locate_rcs (finfo->file, finfo->repository, rcs);
	err = Checkin ('M', finfo->file, finfo->update_dir, finfo->repository,
d1018 1
a1018 4
		       ci->options, message, finfo->entries);

	(void) time (&last_register_time);

d1021 2
a1022 2
	    unlockrcs (finfo->file, finfo->repository);
	    fixbranch (finfo->file, finfo->repository, sbranch);
d1027 2
a1028 2
	err = remove_file (finfo->file, finfo->repository, ci->tag, message,
			   finfo->entries, finfo->srcfiles);
d1032 1
a1032 1
	    server_updated (finfo->file, finfo->update_dir, finfo->repository,
d1042 1
a1042 1
    notify_do ('C', finfo->file, getcaller (), NULL, NULL, finfo->repository);
d1048 1
a1048 1
	p = findnode (ulist, finfo->file);
a1085 25
    /* Build the administrative files if necessary.  */
    {
	char *p;

	if (strncmp (CVSroot, repository, strlen (CVSroot)) != 0)
	    error (0, 0, "internal error: repository doesn't begin with root");
	p = repository + strlen (CVSroot);
	if (*p == '/')
	    ++p;
	if (strcmp ("CVSROOT", p) == 0)
	{
	    /* "Database" might a little bit grandiose and/or vague,
	       but "checked-out copies of administrative files, unless
	       in the case of modules and you are using ndbm in which
	       case modules.{pag,dir,db}" is verbose and excessively
	       focused on how the database is implemented.  */

	    cvs_output (program_name, 0);
	    cvs_output (" ", 1);
	    cvs_output (command_name, 0);
	    cvs_output (": Rebuilding administrative file database\n", 0);
	    mkmodules (repository);
	}
    }

d1243 1
d1245 1
a1245 1
    int lockflag;
d1255 2
d1262 1
d1265 3
d1281 1
d1289 1
a1289 1
    lockflag = RCS_FLAGS_LOCK;
d1315 1
a1315 1
	    lockflag = 0;
d1362 6
a1367 4
    retcode = RCS_checkout (rcs, "", rev ? corev : NULL, NULL, RUN_TTY,
                            lockflag, 1);
    if (retcode != 0)
    {
d1377 10
a1386 3
    retcode = RCS_checkin (rcs, NULL, message, rev, RCS_FLAGS_DEAD, 1);
    if (retcode	!= 0)
    {
d1397 3
d1414 1
d1434 13
a1475 3

    (void) time (&last_register_time);

d1558 1
d1560 1
d1574 1
d1621 1
a1621 1
	run_setup ("%s%s -x,v/ -i", Rcsbin, RCS);
d1647 1
a1647 1

d1655 1
a1655 1
	(void) sprintf (tmp, "file %s was initially added on branch %s.",
d1657 6
a1662 2
	retcode = RCS_checkin (rcs, NULL, tmp, NULL,
			       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET, 0);
d1664 2
a1665 1
	if (retcode != 0)
d1742 14
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d26 1
a26 1
			       char *options, RCSNode **rcsnode)); 
d40 1
a40 1
			char *message, List *entries, RCSNode *rcsnode));
d112 10
d125 1
a125 1
		       finfo->file, 0, 0, finfo->entries, (RCSNode *)NULL);
d130 2
a131 1
    else if (vers->vn_user == NULL)
d133 2
a134 5
	if (vers->ts_user == NULL)
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
	else
	    error (0, 0, "use `cvs add' to create an entry for %s",
		   finfo->fullname);
d147 5
a151 4
	/* This covers unmodified files, as well as a variety of other
	   cases.  FIXME: we probably should be printing a message and
	   returning 1 for many of those cases (but I'm not sure
	   exactly which ones).  */
d156 8
a163 1
    node->key = xstrdup (finfo->fullname);
d172 2
a289 1
	/* FIXME: Why is this binary?  Needs more investigation.  */
a297 2
	/* FIXME: Should keep reading until EOF, rather than assuming the
	   first read gets the whole thing.  */
d368 1
a368 1
	send_file_names (find_args.argc, find_args.argv, 0);
d464 1
a464 1
				    finfo->entries, finfo->rcs, &vers, finfo->update_dir, 0);
d473 1
a473 1
					 finfo->entries, finfo->rcs, &vers, finfo->update_dir,
d499 1
a499 1
				    finfo->entries, finfo->rcs, &vers, finfo->update_dir, 0);
d508 1
a508 1
					finfo->entries, finfo->rcs, &vers, finfo->update_dir,
d521 1
a521 1
				1, 0, finfo->repository, finfo->entries, finfo->rcs, &vers,
d544 5
a548 1
	    error (0, 0, "Up-to-date check failed for `%s'", finfo->fullname);
d570 9
a578 3
		    error (0, 0,
			   "cannot commit with sticky date for file `%s'",
			   finfo->fullname);
d583 1
a583 1
		    !RCS_isbranch (finfo->rcs, vers->tag))
d585 9
a593 3
		    error (0, 0,
			   "sticky tag `%s' for file `%s' is not a branch",
			   vers->tag, finfo->fullname);
d624 2
a625 1
		    error (0, 0,
d627 5
a631 1
			   finfo->fullname);
d647 8
a654 3
		    error (1, errno,
			   "fork failed while examining conflict in `%s'",
			   finfo->fullname);
d658 8
a665 3
		    error (0, 0,
			   "file `%s' still contains conflict indicators",
			   finfo->fullname);d673 2
a674 1
		error (0, 0,
d676 5
a680 1
			   finfo->fullname, vers->tag);
d693 2
a694 1
		    error (0, 0,
d696 5
a700 1
			   finfo->fullname, rcs);
d707 2
a708 1
		    error (0, 0,
d710 5
a714 1
			       finfo->fullname, vers->tag);
d766 1
a766 1
		    ci->rev = RCS_whatbranch (finfo->rcs, vers->tag);
d775 4
a778 1
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
d952 1
a952 1
			  &finfo->rcs) != 0)
d965 1
a965 1
	    ci->rev = RCS_whatbranch (finfo->rcs, ci->tag);
d1022 1
a1022 1
			   finfo->entries, finfo->rcs);
d1249 1
a1249 1
remove_file (file, repository, tag, message, entries, rcsnode)
d1255 1
a1255 1
    RCSNode *rcsnode;
d1267 2
d1279 1
a1279 1
    if (tag && !(branch = RCS_isbranch (rcsnode, tag)))
d1305 1
a1305 1
	rev = RCS_whatbranch (rcsnode, tag);
d1312 2
a1313 1
	if (rcsnode == NULL)
d1318 2
a1319 1
	branchname = RCS_getbranch (rcsnode, rev, 1);
d1324 1
a1324 1
	    corev = RCS_gettag (rcsnode, tag, 1, 0);
d1338 2
a1339 1
	if (rcsnode == NULL)
d1344 2
a1345 1
	prev_rev = RCS_head (rcsnode);
d1535 1
a1535 1
checkaddfile (file, repository, tag, options, rcsnode)
d1540 1
a1540 1
    RCSNode **rcsnode;
d1565 1
d1586 2
a1587 1
	if ((rcsfile = *rcsnode) == NULL)
d1593 1
d1666 1
d1676 1
a1676 1
	if (!RCS_nodeisbranch (rcsfile, tag)) {
d1710 9
a1718 1
	} 
d1720 1
a1720 3
	if (rcsnode)
		freercsnode(rcsnode);
	*rcsnode = rcsfile;
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a16 1
#include <assert.h>
d22 3
a24 7
static Dtype check_direntproc PROTO ((void *callerdat, char *dir,
				      char *repos, char *update_dir,
				      List *entries));
static int check_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int check_filesdoneproc PROTO ((void *callerdat, int err,
				       char *repos, char *update_dir,
				       List *entries));
d27 7
a33 12
static Dtype commit_direntproc PROTO ((void *callerdat, char *dir,
				       char *repos, char *update_dir,
				       List *entries));
static int commit_dirleaveproc PROTO ((void *callerdat, char *dir,
				       int err, char *update_dir,
				       List *entries));
static int commit_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int commit_filesdoneproc PROTO ((void *callerdat, int err,
					char *repository, char *update_dir,
					List *entries));
static int finaladd PROTO((struct file_info *finfo, char *revision, char *tag,
			   char *options));
d35 2
a36 2
static int lock_RCS PROTO((char *user, RCSNode *rcs, char *rev,
			   char *repository));
d39 2
a40 2
static int remove_file PROTO ((struct file_info *finfo, char *tag,
			       char *message));
d43 2
a44 2
static void fixbranch PROTO((RCSNode *, char *branch));
static void unlockrcs PROTO((RCSNode *rcs));
a87 12
/* Identify a file which needs "? foo" or a Questionable request.  */
struct question {
    /* The two fields for the Directory request.  */
    char *dir;
    char *repos;

    /* The file name.  */
    char *file;

    struct question *next;
};

a91 12

    /* This is used from dirent to filesdone time, for each directory,
       to make a list of files we have already seen.  */
    List *ignlist;

    /* Linked list of files which need "? foo" or a Questionable request.  */
    struct question *questionables;

    /* Only good within functions called from the filesdoneproc.  Stores
       the repository (pointer into storage managed by the recursion
       processor.  */
    char *repository;
d94 3
a96 64
static Dtype find_dirent_proc PROTO ((void *callerdat, char *dir,
				      char *repository, char *update_dir,
				      List *entries));

static Dtype
find_dirent_proc (callerdat, dir, repository, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repository;
    char *update_dir;
    List *entries;
{
    struct find_data *find_data = (struct find_data *)callerdat;

    /* initialize the ignore list for this directory */
    find_data->ignlist = getlist ();
    return R_PROCESS;
}

/* Here as a static until we get around to fixing ignore_files to pass
   it along as an argument.  */
static struct find_data *find_data_static;

static void find_ignproc PROTO ((char *, char *));

static void
find_ignproc (file, dir)
    char *file;
    char *dir;
{
    struct question *p;

    p = (struct question *) xmalloc (sizeof (struct question));
    p->dir = xstrdup (dir);
    p->repos = xstrdup (find_data_static->repository);
    p->file = xstrdup (file);
    p->next = find_data_static->questionables;
    find_data_static->questionables = p;
}

static int find_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repository, char *update_dir,
				      List *entries));

static int
find_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
    int err;
    char *repository;
    char *update_dir;
    List *entries;
{
    struct find_data *find_data = (struct find_data *)callerdat;
    find_data->repository = repository;

    /* if this directory has an ignore list, process it then free it */
    if (find_data->ignlist)
    {
	find_data_static = find_data;
	ignore_files (find_data->ignlist, entries, update_dir, find_ignproc);
	dellist (&find_data->ignlist);
    }

    find_data->repository = NULL;
d98 1
a98 4
    return err;
}

static int find_fileproc PROTO ((void *callerdat, struct file_info *finfo));
d105 1
a105 2
find_fileproc (callerdat, finfo)
    void *callerdat;
d111 1
a111 15
    struct find_data *args = (struct find_data *)callerdat;
    struct logfile_info *data;
    struct file_info xfinfo;

    /* if this directory has an ignore list, add this file to it */
    if (args->ignlist)
    {
	Node *p;

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (finfo->file);
	if (addnode (args->ignlist, p) != 0)
	    freenode (p);
    }
d113 3
a115 5
    xfinfo = *finfo;
    xfinfo.repository = NULL;
    xfinfo.rcs = NULL;

    vers = Version_TS (&xfinfo, NULL, NULL, NULL, 0, 0);
a118 4
	/* FIXME: If vn_user is starts with "-" but ts_user is
	   non-NULL, what classify_file does is print "%s should be
	   removed and is still there".  I'm not sure what it does
	   then.  We probably should do the same.  */
a131 3
	/* FIXME: If vn_user is "0" but ts_user is NULL, what classify_file
	   does is print "new-born %s has disappeared" and removes the entry.
	   We probably should do the same.  */
a148 4
    data = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
    data->type = status;
    data->tag = xstrdup (vers->tag);

d151 1
a151 1
    node->data = (char *) data;
a155 1
    freevers_ts (&vers);
d273 1
a273 1
	if ((logfd = CVS_OPEN (logfile, O_RDONLY | OPEN_BINARY)) < 0)
d297 4
d303 5
a307 9
	find_args.questionables = NULL;
	find_args.ignlist = NULL;
	find_args.repository = NULL;

	err = start_recursion (find_fileproc, find_filesdoneproc,
			       find_dirent_proc, (DIRLEAVEPROC) NULL,
			       (void *)&find_args,
			       argc, argv, local, W_LOCAL, 0, 0,
			       (char *)NULL, 0);
a311 4
	    /* Nothing to commit.  Exit now without contacting the
	       server (note that this means that we won't print "?
	       foo" for files which merit it, because we don't know
	       what is in the CVSROOT/cvsignore file).  */
d322 6
a327 10
	/* Do this before calling do_editor; don't ask for a log
	   message if we can't talk to the server.  But do it after we
	   have made the checks that we can locally (to more quickly
	   catch syntax errors, the case where no files are modified,
	   added or removed, etc.).

	   On the other hand, calling start_server before do_editor
	   means that we chew up server resources the whole time that
	   the user has the editor open (hours or days if the user
	   forgets about it), which seems dubious.  */
a339 41
	/* OK, now process all the questionable files we have been saving
	   up.  */
	{
	    struct question *p;
	    struct question *q;

	    p = find_args.questionables;
	    while (p != NULL)
	    {
		if (ign_inhibit_server || !supported_request ("Questionable"))
		{
		    cvs_output ("? ", 2);
		    if (p->dir[0] != '\0')
		    {
			cvs_output (p->dir, 0);
			cvs_output ("/", 1);
		    }
		    cvs_output (p->file, 0);
		    cvs_output ("\n", 1);
		}
		else
		{
		    send_to_server ("Directory ", 0);
		    send_to_server (p->dir[0] == '\0' ? "." : p->dir, 0);
		    send_to_server ("\012", 1);
		    send_to_server (p->repos, 0);
		    send_to_server ("\012", 1);

		    send_to_server ("Questionable ", 0);
		    send_to_server (p->file, 0);
		    send_to_server ("\012", 1);
		}
		free (p->dir);
		free (p->repos);
		free (p->file);
		q = p->next;
		free (p);
		p = q;
	    }
	}

d381 3
a383 2
			   check_direntproc, (DIRLEAVEPROC) NULL, NULL, argc,
			   argv, local, W_LOCAL, aflag, 0, (char *) NULL, 1);
d395 1
a395 1
			       commit_direntproc, commit_dirleaveproc, NULL,
d397 1
a397 1
			       (char *) NULL, 1);
d425 1
a425 2
check_fileproc (callerdat, finfo)
    void *callerdat;
a433 1
    struct logfile_info *li;
d447 3
a449 2
	    status = Classify_File (finfo, (char *) NULL, (char *) NULL,
				    (char *) NULL, 1, aflag, &vers, 0);
d456 4
a459 2
		xstatus = Classify_File (finfo, tag, (char *) NULL,
					 (char *) NULL, 1, aflag, &vers, 0);
d482 3
a484 2
	    status = Classify_File (finfo, xtag, (char *) NULL,
				    (char *) NULL, 1, aflag, &vers, 0);
d491 4
a494 2
		status = Classify_File (finfo, xtag, (char *) NULL,
					(char *) NULL, 1, aflag, &vers, 0);
d505 3
a507 2
	status = Classify_File (finfo, tag, (char *) NULL, (char *) NULL,
				1, 0, &vers, 0);
d541 1
a541 2
	     *	- if status is T_ADDED, rcs file must not exist unless on
	     *    a branch
d635 6
a640 1
	        if (vers->tag == NULL)
d642 5
a646 14
		    char rcs[PATH_MAX];

		    /* Don't look in the attic; if it exists there we
		       will move it back out in checkaddfile.  */
		    sprintf(rcs, "%s/%s%s", finfo->repository, finfo->file,
			    RCSEXT);
		    if (isreadable (rcs))
		    {
			error (0, 0,
		    "cannot add file `%s' when RCS file `%s' already exists",
			       finfo->fullname, rcs);
			freevers_ts (&vers);
			return (1);
		    }
d692 1
a692 5
	    li = ((struct logfile_info *)
		  xmalloc (sizeof (struct logfile_info)));
	    li->type = status;
	    li->tag = xstrdup (vers->tag);
	    p->data = (char *) li;
d733 1
a733 2
check_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a736 1
    List *entries;
d752 2
a753 6
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == T_ADDED
	|| li->type == T_MODIFIED
	|| li->type == T_REMOVED)
d800 1
a800 2
check_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
a803 1
    List *entries;
d837 1
a837 2
commit_fileproc (callerdat, finfo)
    void *callerdat;
d844 1
d878 1
a878 4
	if (finfo->rcs == NULL)
	    error (1, 0, "internal error: no parsed RCS file");
	if (lock_RCS (finfo->file, finfo->rcs, ci->rev,
		      finfo->repository) != 0)
d880 1
a880 1
	    unlockrcs (finfo->rcs);
d899 2
a900 4
	if (ci->tag)
	{
	    if (finfo->rcs == NULL)
		error (1, 0, "internal error: no parsed RCS file");
d902 2
a903 2
	    err = Checkin ('A', finfo, finfo->rcs->path, ci->rev,
			   ci->tag, ci->options, message);
d906 2
a907 2
		unlockrcs (finfo->rcs);
		fixbranch (finfo->rcs, sbranch);
d935 2
a936 1
	err = finaladd (finfo, ci->rev ? ci->rev : xrev, ci->tag, ci->options);
d942 4
a945 3
	err = Checkin ('M', finfo,
		       finfo->rcs->path, ci->rev, ci->tag,
		       ci->options, message);
d951 2
a952 2
	    unlockrcs (finfo->rcs);
	    fixbranch (finfo->rcs, sbranch);
d957 2
a958 1
	err = remove_file (finfo, ci->tag, message);
d962 1
a962 3
	    server_updated (finfo,
			    NULL,

d964 1
a964 3
			    SERVER_UPDATED,

			    (struct stat *) NULL,
d991 1
a991 2
commit_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
a994 1
    List *entries;
d996 1
d1008 7
a1014 2

    Update_Logfile (repository, message, (FILE *) 0, ulist);
d1020 3
a1022 4
	if (strncmp (CVSroot_directory, repository,
		     strlen (CVSroot_directory)) != 0)
	    error (0, 0, "internal error: repository (%s) doesn't begin with root (%s)", repository, CVSroot_directory);
	p = repository + strlen (CVSroot_directory);
d1045 1
a1045 1
	if ((fp = CVS_FOPEN (CVSADM_CIPROG, "r")) != NULL)
d1095 1
a1095 2
commit_direntproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a1098 1
    List *entries;
d1135 1
a1135 2
commit_dirleaveproc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
a1138 1
    List *entries;
a1166 2
    if (entdata->type != ENT_FILE)
	return (0);
d1185 3
a1187 2
remove_file (finfo, tag, message)
    struct file_info *finfo;
d1190 2
d1195 1
a1202 1
    char *old_path;
d1210 1
a1210 2
    if (finfo->rcs == NULL)
	error (1, 0, "internal error: no parsed RCS file");
d1213 1
a1213 1
    if (tag && !(branch = RCS_isbranch (finfo->rcs, tag)))
d1216 1
a1216 1
	if ((retcode = RCS_deltag (finfo->rcs, tag, 1)) != 0) 
d1220 1
a1220 2
		       "failed to remove tag `%s' from `%s'", tag,
		       finfo->fullname);
d1223 1
a1223 1
	Scratch_Entry (finfo->entries, finfo->file);
d1231 1
a1231 1
    (void) printf ("Removing %s;\n", finfo->fullname);
d1234 1
a1234 1
    lockflag = 1;
d1239 1
a1239 1
	rev = RCS_whatbranch (finfo->rcs, tag);
d1246 6
a1251 1
	branchname = RCS_getbranch (finfo->rcs, rev, 1);
d1256 1
a1256 1
	    corev = RCS_gettag (finfo->rcs, tag, 1, (int *) NULL);
d1268 1
d1270 6
a1275 1
	prev_rev = RCS_head (finfo->rcs);
d1282 1
a1282 1
        if (RCS_setbranch (finfo->rcs, NULL) != 0) 
d1285 1
a1285 1
		   finfo->fullname);
d1296 1
a1296 1
	unlink_file (finfo->file);
d1301 4
a1304 3
       particular rev, then name it.  */
    retcode = RCS_checkout (finfo->rcs, finfo->file, rev ? corev : NULL,
			    (char *) NULL, (char *) NULL, RUN_TTY);
d1309 1
a1309 1
		   "failed to check out `%s'", finfo->fullname);
a1312 5
    /* Except when we are creating a branch, lock the revision so that
       we can check in the new revision.  */
    if (lockflag)
	RCS_lock (finfo->rcs, rev ? corev : NULL, 0);

d1316 1
a1316 2
    retcode = RCS_checkin (finfo->rcs->path, finfo->file, message, rev,
			   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
d1321 1
a1321 1
		   "failed to commit dead revision for `%s'", finfo->fullname);
a1327 1
    old_path = finfo->rcs->path;
d1331 1
a1331 1
	tmp = xmalloc(strlen(finfo->repository) + 
d1335 1
a1335 1
		      strlen(finfo->file) +
d1337 1
a1337 1
	(void) sprintf (tmp, "%s/%s", finfo->repository, CVSATTIC);
d1341 1
a1341 1
	(void) sprintf (tmp, "%s/%s/%s%s", finfo->repository, CVSATTIC, finfo->file, RCSEXT);
d1343 3
a1345 3
	if (strcmp (finfo->rcs->path, tmp) != 0
	    && CVS_RENAME (finfo->rcs->path, tmp) == -1
	    && (isreadable (finfo->rcs->path) || !isreadable (tmp)))
d1350 1
a1350 3
	/* The old value of finfo->rcs->path is in old_path, and is
           freed below.  */
	finfo->rcs->path = tmp;
d1354 1
a1354 1
    (void) printf ("%s  <--  %s\n", old_path, finfo->file);
d1360 1
a1360 4
    if (old_path != finfo->rcs->path)
	free (old_path);

    Scratch_Entry (finfo->entries, finfo->file);
d1368 2
a1369 2
finaladd (finfo, rev, tag, options)
    struct file_info *finfo;
d1373 3
d1381 3
a1383 2
    locate_rcs (finfo->file, finfo->repository, rcs);
    ret = Checkin ('A', finfo, rcs, rev, tag, options, message);
d1386 1
a1386 1
	(void) sprintf (tmp, "%s/%s%s", CVSADM, finfo->file, CVSEXT_LOG);
d1390 1
a1390 1
	fixaddfile (finfo->file, finfo->repository);
d1401 3
a1403 2
unlockrcs (rcs)
    RCSNode *rcs;
d1405 4
a1408 1
    int retcode;
d1412 1
a1412 1
	       "could not unlock %s", rcs->path);
d1441 3
a1443 2
fixbranch (rcs, branch)
    RCSNode *rcs;
d1446 2
a1447 1
    int retcode;
d1451 1
d1454 1
a1454 1
		   "cannot restore branch to %s for %s", branch, rcs->path);
a1476 1
    RCSNode *rcsfile = NULL;
d1480 6
a1485 11
        (void) sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
	if (! isreadable (rcs))
	{
	    (void) sprintf(rcs, "%s/%s", repository, CVSATTIC);
	    omask = umask (cvsumask);
	    if (CVS_MKDIR (rcs, 0777) != 0 && errno != EEXIST)
		error (1, errno, "cannot make directory `%s'", rcs);;
	    (void) umask (omask);
	    (void) sprintf (rcs, "%s/%s/%s%s", repository, CVSATTIC, file,
			    RCSEXT);
	}
d1495 1
a1495 6

	if ((rcsfile = *rcsnode) == NULL)
	{
	    error (0, 0, "could not find parsed rcsfile %s", file);
	    return (1);
	}
d1505 1
a1505 1
		|| CVS_RENAME (oldfile, rcs) != 0
a1512 2
	    free (rcsfile->path);
	    rcsfile->path = xstrdup (rcs);
d1515 7
a1521 1
	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
d1523 1
a1523 1
	if (lock_RCS (file, rcsfile, rev, repository)) {
d1570 1
a1570 1
			       RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
d1581 1
a1581 14

	assert (rcsfile == NULL);
	rcsfile = RCS_parse (file, repository);
	if (rcsfile == NULL)
	{
	    error (0, 0, "could not read %s", rcs);
	    return (1);
	}
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}

d1583 1
a1583 1
	if (lock_RCS (file, rcsfile, NULL, repository)) {
d1593 1
d1595 1
d1598 2
a1599 11
	    if (rcsnode != NULL && *rcsnode != NULL)
		rcsfile = *rcsnode;
	    else
	    {
		rcsfile = RCS_parse (file, repository);
		if (rcsfile == NULL)
		{
		    error (0, 0, "could not read %s", rcs);
		    return (1);
		}
	    }
d1601 1
a1601 1

d1607 1
a1607 1
	    head = RCS_getversion (rcsfile, NULL, NULL, 0, (int *) NULL);
d1609 1
a1609 7

	    retcode = RCS_settag (rcsfile, tag, magicrev);

	    free (head);
	    free (magicrev);

	    if (retcode != 0)
d1615 13
d1632 1
a1632 1
	    if (lock_RCS (file, rcsfile, NULL, repository)) {
d1638 3
a1640 5
	if (rcsnode && *rcsnode != rcsfile)
	{
	    freercsnode(rcsnode);
	    *rcsnode = rcsfile;
	}
d1650 18
d1676 1
a1676 1
    RCSNode *rcs;
d1680 1
d1695 6
a1700 2
	branch = xstrdup (rcs->branch);
	if (branch != NULL)
d1702 4
a1705 1
	    if (RCS_setbranch (rcs, NULL) != 0)
d1707 8
a1714 5
		error (0, 0, "cannot change branch to default for %s",
		       rcs->path);
		if (branch)
		    free (branch);
		return (1);
d1716 1
a1717 1
	err = RCS_lock(rcs, NULL, 0);
d1738 1
a1738 1
	fixbranch (rcs, branch);
d1760 1
a1760 1
    if ( CVS_STAT (user, &sb) != -1)
d1765 1
a1765 1
 * free an UPDATE node's data
d1771 1
a1771 6
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->tag)
	free (li->tag);
    free (li);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d57 1
a57 1
static char *locate_rcs PROTO((char *file, char *repository));
a273 1
    data->rev_old = data->rev_new = NULL;
a471 5
	/* Run the user-defined script to verify/check information in
	 *the log message
	 */
	do_verify (message, (char *)NULL);  	

d530 1
a530 1
	send_files (find_args.argc, find_args.argv, local, 0, 0);
d561 1
a561 1
	Lock_Cleanup ();
d577 1
a577 1
    Lock_Cleanup ();
d594 8
a601 6
/* This routine determines the status of a given file and retrieves
   the version information that is associated with that file. */

static
Ctype
classify_file_internal (finfo, vers)
a602 1
    Vers_TS **vers;
d604 7
d612 1
a612 2
    Ctype status;
    
d625 1
a625 1
				    (char *) NULL, 1, aflag, vers, 0);
d631 1
a631 1
		freevers_ts (vers);
d633 1
a633 1
					 (char *) NULL, 1, aflag, vers, 0);
d657 1
a657 1
				    (char *) NULL, 1, aflag, vers, 0);
d663 1
a663 1
		freevers_ts (vers);
d665 1
a665 1
					(char *) NULL, 1, aflag, vers, 0);
d670 2
a671 2
	    free ((*vers)->tag);
	    (*vers)->tag = xstrdup (tag);
d677 1
a677 1
				1, 0, vers, 0);
a681 23
    return status;
}

/*
 * Check to see if a file is ok to commit and make sure all files are
 * up-to-date
 */
/* ARGSUSED */
static int
check_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    Ctype status;
    char *xdir;
    Node *p;
    List *ulist, *cilist;
    Vers_TS *vers;
    struct commit_info *ci;
    struct logfile_info *li;
    
    status = classify_file_internal (finfo, &vers);

d771 16
a786 1
		if (file_has_markers (finfo))
d808 1
a808 6
		    char *rcs;

		    rcs = xmalloc (strlen (finfo->repository)
				   + strlen (finfo->file)
				   + sizeof RCSEXT
				   + 5);
a819 1
			free (rcs);
a821 1
		    free (rcs);
a870 2
	    li->rev_old = xstrdup (vers->vn_rcs);
	    li->rev_new = NULL;
d1020 1
a1020 1
static char *sbranch;
d1052 2
a1053 2
    if (!(got_message))
    {
d1055 2
a1056 4
	if (use_editor)
	    do_editor (finfo->update_dir, &message, finfo->repository, ulist);
	do_verify (message, finfo->repository);  
    }
a1174 27
    else
    {
	/* On success, retrieve the new version number of the file and
           copy it into the log information (see logmsg.c
           (logfile_write) for more details).  We should only update
           the version number for files that have been added or
           modified but not removed.  Why?  classify_file_internal
           will return the version number of a file even after it has
           been removed from the archive, which is not the behavior we
           want for our commitlog messages; we want the old version
           number and then "NONE." */
	
	if (ci->status != T_REMOVED)
	{
	    p = findnode (ulist, finfo->file);
	    if (p)
	    {
		Vers_TS *vers;
		struct logfile_info *li;
	    
		(void) classify_file_internal (finfo, &vers);
		li = (struct logfile_info *) p->data;
		li->rev_new = xstrdup (vers->vn_rcs);
		freevers_ts (&vers);
	    }
	}
    }
d1252 2
a1253 4
		cvs_output (program_name, 0);
		cvs_output (" ", 1);
		cvs_output (command_name, 0);
		cvs_output (": Executing '", 0);
d1255 1
a1255 1
		cvs_output ("'\n", 0);
a1311 2
    real_repos = Name_Repository (dir, update_dir);
    got_message = 1;
d1313 3
d1317 2
a1318 2
    do_verify (message, real_repos);  
    free (real_repos);
d1426 1
a1426 3
    cvs_output ("Removing ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output (";\n", 0);
d1546 4
a1549 6
    cvs_output (old_path, 0);
    cvs_output ("  <--  ", 0);
    cvs_output (finfo->file, 0);
    cvs_output ("\nnew revision: delete; previous revision: ", 0);
    cvs_output (prev_rev, 0);
    cvs_output ("\ndone\n", 0);
d1570 2
a1571 1
    char *rcs;
d1573 1
a1573 1
    rcs = locate_rcs (finfo->file, finfo->repository);
a1576 2
	char *tmp = xmalloc (strlen (finfo->file) + sizeof (CVSADM)
			     + sizeof (CVSEXT_LOG) + 10);
a1578 1
	free (tmp);
a1583 1
    free (rcs);
d1611 1
a1611 1
    char *rcs;
d1614 1
a1614 1
    rcs = locate_rcs (file, repository);
a1621 1
    free (rcs);
d1634 1
a1634 1
    if (branch != NULL)
d1656 2
a1657 2
    char *rcs;
    char *fname;
a1661 1
    int retval;
a1664 2
	rcs = xmalloc (strlen (repository) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
d1678 1
a1678 1
	rcs = locate_rcs (file, repository);
d1680 1
a1680 1
    if (isreadable (rcs))
d1683 1
d1689 1
a1689 2
	    retval = 1;
	    goto out;
a1693 2
	    char *oldfile;

d1696 1
a1696 1
	    oldfile = xstrdup (rcs);
d1699 3
a1701 16
	    if (strcmp (oldfile, rcs) == 0)
	    {
		error (0, 0, "internal error: confused about attic for %s",
		       oldfile);
	    out1:
		free (oldfile);
		retval = 1;
		goto out;
	    }
	    if (CVS_RENAME (oldfile, rcs) != 0)
	    {
		error (0, errno, "failed to move `%s' out of the attic",
		       oldfile);
		goto out1;
	    }
	    if (isreadable (oldfile)
d1704 3
a1706 4
		error (0, 0, "\
internal error: `%s' didn't move out of the attic",
		       oldfile);
		goto out1;
a1707 1
	    free (oldfile);
d1714 1
a1714 2
	if (lock_RCS (file, rcsfile, rev, repository))
	{
d1716 2
a1717 4
	    if (rev != NULL)
		free (rev);
	    retval = 1;
	    goto out;
d1720 2
a1721 5
	if (rev != NULL)
	    free (rev);
    }
    else
    {
a1725 2
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG) + 10);
a1730 1
	free (fname);
d1740 1
a1740 2
	    retval = 1;
	    goto out;
a1751 2
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSPREFIX) + 10);
d1767 1
a1767 2
	    retval = 1;
	    goto out;
a1771 1
	free (fname);
d1778 1
a1778 2
	    retval = 1;
	    goto out;
d1787 1
a1787 2
	if (lock_RCS (file, rcsfile, NULL, repository))
	{
d1789 1
a1789 2
	    retval = 1;
	    goto out;
d1808 1
a1808 2
		    retval = 1;
		    goto out;
d1813 1
a1813 2
	if (!RCS_nodeisbranch (rcsfile, tag))
	{
d1817 1
a1817 1

d1830 1
a1830 2
		retval = 1;
		goto out;
d1836 1
a1836 2
	    if (lock_RCS (file, rcsfile, NULL, repository))
	    {
d1838 1
a1838 2
		retval = 1;
		goto out;
d1852 1
a1852 5
    retval = 0;

 out:
    free (rcs);
    return retval;
a1902 2
	if (sbranch != NULL)
	    free (sbranch);
d1905 2
a1906 1
	    sbranch = branch;
d1909 1
a1909 1
	    sbranch = NULL;
a1952 4
    if (li->rev_old)
	free (li->rev_old);
    if (li->rev_new)
	free (li->rev_new);
d1990 5
a1994 11
/* Find an RCS file in the repository.  Most parts of CVS will want to
   rely instead on RCS_parse which performs a similar operation and is
   called by recurse.c which then puts the result in useful places
   like the rcs field of struct file_info.

   REPOSITORY is the repository (including the directory) and FILE is
   the filename within that directory (without RCSEXT).  Returns a
   newly-malloc'd array containing the absolute pathname of the RCS
   file that was found.  */
static char *
locate_rcs (file, repository)
d1997 1
a1998 3
    char *rcs;

    rcs = xmalloc (strlen (repository) + strlen (file) + sizeof (RCSEXT) + 10);
a2005 1
    return rcs;
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d257 1
a257 3
	     && (force_ci || strcmp (vers->ts_user, vers->ts_rcs) != 0))
	/* If we are forcing commits, pretend that the file is
           modified.  */
d536 1
a536 1
	send_files (find_args.argc, find_args.argv, local, 0, 0, force_ci);
d2023 8
a2030 4
/* Called when "add"ing files to the RCS respository.  It doesn't seem to
   be possible to get RCS to use the right mode, so we change it after
   the fact.  */

a2036 1
    mode_t rcs_mode;
d2038 2
a2039 39
    if (CVS_STAT (user, &sb) < 0)
    {
	/* FIXME: Should be ->fullname.  */
	error (0, errno, "warning: cannot stat %s", user);
	return;
    }

    /* Now we compute the new mode.

       The algorithm that we use is:

       Write permission is always off (this is what RCS and CVS have always
       done).

       If S_IRUSR is on (user read), then the read permission of
       the RCS file will be on.  It would seem that if this is off,
       then other users can't do "cvs update" and such, so perhaps this
       should be hardcoded to being on (it is a strange case, though--the
       case in which a user file doesn't have user read permission on).

       If S_IXUSR is on (user execute), then set execute permission
       on the RCS file.  This allows other users who check out the file
       to get the right setting for whether a shell script (for example)
       has the executable bit set.

       The result of that calculation is modified by CVSUMASK.  The
       reason, of course, that the read and execute settings take the
       user bit and copy it to all three bits (user, group, other), is
       that it should be CVSUMASK, not the umask of individual users,
       which is the sole determiner of modes in the repository.  */

    rcs_mode = 0;
    if (sb.st_mode & S_IRUSR)
	rcs_mode |= S_IRUSR | S_IRGRP | S_IROTH;
    if (sb.st_mode & S_IXUSR)
	rcs_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
    rcs_mode &= ~cvsumask;
    if (chmod (rcs, rcs_mode) < 0)
	error (0, errno, "warning: cannot change mode of %s", rcs);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a77 1
static int write_dirnonbranch;
a125 4

    /* Non-zero if we should force the commit.  This is enabled by
       either -f or -r options, unlike force_ci which is just -f.  */
    int force;
d257 1
a257 1
	     && (args->force || strcmp (vers->ts_user, vers->ts_rcs) != 0))
d331 1
a331 1
    while ((c = getopt (argc, argv, "+nlRm:fF:r:")) != -1)
a432 6
	/* It is possible that only a numeric tag should set this.
	   I haven't really thought about it much.
	   Anyway, I suspect that setting it unnecessarily only causes
	   a little unneeded network traffic.  */
	find_args.force = force_ci || tag != NULL;

d538 1
a538 2
	send_files (find_args.argc, find_args.argv, local, 0,
		    find_args.force ? SEND_FORCE : 0);
a575 1
    write_dirnonbranch = 0;
a1050 15
    /* Keep track of whether write_dirtag is a branch tag.
       Note that if it is a branch tag in some files and a nonbranch tag
       in others, treat it as a nonbranch tag.  It is possible that case
       should elicit a warning or an error.  */
    if (write_dirtag != NULL
	&& finfo->rcs != NULL)
    {
	char *rev = RCS_getversion (finfo->rcs, write_dirtag, NULL, 1, NULL);
	if (rev != NULL
	    && !RCS_nodeisbranch (finfo->rcs, write_dirtag))
	    write_dirnonbranch = 1;
	if (rev != NULL)
	    free (rev);
    }

a1382 3
    /* FIXME?  Why?  The "commit examples" node of cvs.texinfo briefly
       mentions commit -r being sticky, but apparently in the context of
       this being a confusing feature!  */
d1385 6
a1390 2
	WriteTag (NULL, write_dirtag, NULL, write_dirnonbranch,
		  update_dir, Name_Repository (dir, update_dir));
d1537 1
a1537 2
			    (char *) NULL, (char *) NULL, RUN_TTY,
			    (RCSCHECKOUTPROC) NULL, (void *) NULL);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d335 1
a335 1
    optind = 0;
a548 10

	/* FIXME: This whole find_args.force/SEND_FORCE business is a
	   kludge.  It would seem to be a server bug that we have to
	   say that files are modified when they are not.  This makes
	   "cvs commit -r 2" across a whole bunch of files a very slow
	   operation (and it isn't documented in cvsclient.texi).  I
	   haven't looked at the server code carefully enough to be
	   _sure_ why this is needed, but if it is because RCS_CI
	   wants the file to exist, then it would be relatively simple
	   (but not trivial) to fix in the server.  */
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a94 1
    "(Specify the --help global option for a list of other help options)\n",
a146 7
    /* This check seems to slowly be creeping throughout CVS (update
       and send_dirent_proc by CVS 1.5, diff in 31 Oct 1995.  My guess
       is that it (or some variant thereof) should go in all the
       dirent procs.  Unless someone has some better idea...  */
    if (!isdir (dir))
	return (R_SKIP_ALL);

a148 7

    /* Print the same warm fuzzy as in check_direntproc, since that
       code will never be run during client/server operation and we
       want the messages to match. */
    if (!quiet)
	error (0, 0, "Examining %s", update_dir);

d235 1
a235 1
    vers = Version_TS (&xfinfo, NULL, tag, NULL, 0, 0);
d249 2
a250 2
	    error (0, 0, "use `%s add' to create an entry for %s",
		   program_name, finfo->fullname);
a323 3
    /* FIXME: Shouldn't this check be much more closely related to the
       readonly user stuff (CVSROOT/readers, &c).  That is, why should
       root be able to "cvs init", "cvs import", &c, but not "cvs ci"?  */
d345 1
a345 1
		use_editor = 1;
d347 1
a347 1
		use_editor = 0;
d374 1
a374 1
		use_editor = 1;
d376 1
a376 1
		use_editor = 0;
a427 1
	int err;
a491 2
	/* FIXME: is that true?  There seems to be some code in do_editor
	   which can leave the message NULL.  */
d556 3
a558 3
	   _sure_ why this is needed, but if it is because the "ci"
	   program, which we used to call, wanted the file to exist,
	   then it would be relatively simple to fix in the server.  */
d563 1
a563 26
	err = get_responses_and_close ();
	if (err != 0 && use_editor && message != NULL)
	{
	    /* If there was an error, don't nuke the user's carefully
	       constructed prose.  This is something of a kludge; a better
	       solution is probably more along the lines of #150 in TODO
	       (doing a second up-to-date check before accepting the
	       log message has also been suggested, but that seems kind of
	       iffy because the real up-to-date check could still fail,
	       another error could occur, &c.  Also, a second check would
	       slow things down).  */

	    char *fname;
	    FILE *fp;

	    fname = cvs_temp_name ();
	    fp = CVS_FOPEN (fname, "w+");
	    if (fp == NULL)
		error (1, 0, "cannot create temporary file %s", fname);
	    if (fwrite (message, 1, strlen (message), fp) != strlen (message))
		error (1, errno, "cannot write temporary file %s", fname);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close temporary file %s", fname);
	    error (0, 0, "saving log message in %s", fname);
	}
	return err;
d636 1
a636 4

    /* FIXME: Do we need to save quiet as well as really_quiet?  Last
       time I glanced at Classify_File I only saw it looking at really_quiet
       not quiet.  */
a819 10
		    /* Make this a warning, not an error, because we have
		       no way of knowing whether the "conflict indicators"
		       are really from a conflict or whether they are part
		       of the document itself (cvs.texinfo and sanity.sh in
		       CVS itself, for example, tend to want to have strings
		       like ">>>>>>>" at the start of a line).  Making people
		       kludge this the way they need to kludge keyword
		       expansion seems undesirable.  And it is worse than
		       keyword expansion, because there is no -ko
		       analogue.  */
d821 1
a821 2
			   "\
warning: file `%s' seems to still contain conflict indicators",
d823 2
a829 5
		/* Remove also tries to forbid this, but we should check
		   here.  I'm only _sure_ about somewhat obscure cases
		   (hacking the Entries file, using an old version of
		   CVS for the remove and a new one for the commit), but
		   there might be other cases.  */
d949 1
a949 2
 * By default, return the code that tells do_recursion to examine all
 * directories
a959 3
    if (!isdir (dir))
	return (R_SKIP_ALL);

d1016 1
a1016 2
    run_setup (filter);
    run_arg (repository);
d1336 1
a1336 2
		run_setup (line);
		run_arg (repository);
d1368 1
a1368 1
 * Get the log message for a dir
a1382 3
    if (!isdir (dir))
	return (R_SKIP_ALL);

d1394 4
d1492 1
a1492 1
    if (tag && !(branch = RCS_nodeisbranch (finfo->rcs, tag)))
d1495 1
a1495 1
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0) 
a1502 1
	RCS_rewrite (finfo->rcs, NULL, NULL);
a1558 1
	RCS_rewrite (finfo->rcs, NULL, NULL);
d1587 1
a1587 4
    {
	if (RCS_lock (finfo->rcs, rev ? corev : NULL, 1) == 0)
	    RCS_rewrite (finfo->rcs, NULL, NULL);
    }
d1592 1
a1592 1
    retcode = RCS_checkin (finfo->rcs, finfo->file, message, rev,
a1692 2
    else
	RCS_rewrite (rcs, NULL, NULL);
a1732 1
	RCS_rewrite (rcs, NULL, NULL);
d1844 1
a1845 9
	char *desc;
	size_t descalloc;
	size_t desclen;

	char *opt;

	desc = NULL;
	descalloc = 0;
	desclen = 0;
d1852 1
a1852 3
	    /* FIXME: Should be including update_dir in the appropriate
	       place here.  */
	    get_file (fname, fname, "r", &desc, &descalloc, &desclen);
a1854 10
	/* From reading the RCS 5.7 source, "rcs -i" adds a newline to the
	   end of the log message if the message is nonempty.
	   Do it.  RCS also deletes certain whitespace, in cleanlogmsg,
	   which we don't try to do here.  */
	if (desclen > 0)
	{
	    expand_string (&desc, &descalloc, desclen + 1);
	    desc[desclen++] = '\012';
	}

d1857 3
a1859 16
	    opt = options + 2;
	else
	    opt = NULL;

	/* This message is an artifact of the time when this
	   was implemented via "rcs -i".  It should be revised at
	   some point (does the "initial revision" in the message from
	   RCS_checkin indicate that this is a new file?  Or does the
	   "RCS file" message serve some function?).  */
	cvs_output ("RCS file: ", 0);
	cvs_output (rcs, 0);
	cvs_output ("\ndone\n", 0);

	if (add_rcs_file (NULL, rcs, file, NULL, opt,
			  NULL, NULL, 0, NULL,
			  desc, desclen, NULL) != 0)
d1861 2
a1865 1
	rcsfile = RCS_parsercsfile (rcs);
a1866 2
	if (desc != NULL)
	    free (desc);
d1886 1
a1886 1
	retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
d1901 1
a1901 2
	/* double-check that the file was written correctly */
	freercsnode (&rcsfile);
a1954 1
	    RCS_rewrite (rcsfile, NULL, NULL);
a1986 6
    /* I don't think fix_rcs_modes is needed any more.  In the
       add_rcs_file case, the algorithms used by add_rcs_file and
       fix_rcs_modes are the same, so there is no need to go through
       it all twice.  In the other cases, I think we want to just
       preserve the mode that the file had before we started.  That is
       a behavior change, but I would think a desirable one.  */
a1987 1

d2034 1
a2034 1
	err = RCS_lock(rcs, NULL, 1);
a2039 1
    RCS_rewrite (rcs, NULL, NULL);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a21 1
#include "hardlink.h"
d84 1
d625 1
a625 1
     * Set up the master update list and hard link list
a628 13
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	hardlist = getlist ();

	/*
	 * We need to save the working directory so that
	 * check_fileproc can construct a full pathname for each file.
	 */
	working_dir = xgetwd();
    }
#endif

a640 11
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (preserve_perms)
    {
	/* hardlist now includes a complete index of the files
	   to be committed, indexed by inode.  For each inode,
	   compile a list of the files that are linked to it,
	   and save this list in each file's hardlink_info node. */
	(void) walklist (hardlist, cache_hardlinks_proc, NULL);
    }
#endif

a994 37

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    if (preserve_perms)
	    {
		/* Add this file to hardlist, indexed on its inode.  When
		   we are done, we can find out what files are hardlinked
		   to a given file by looking up its inode in hardlist. */
		char *fullpath;
		Node *linkp;
		struct hardlink_info *hlinfo;

		/* Get the full pathname of the current file. */
		fullpath = xmalloc (strlen(working_dir) +
				    strlen(finfo->fullname) + 2);
		sprintf (fullpath, "%s/%s", working_dir, finfo->fullname);

		/* To permit following links in subdirectories, files
                   are keyed on finfo->fullname, not on finfo->name. */
		linkp = lookup_file_by_inode (fullpath);

		/* If linkp is NULL, the file doesn't exist... maybe
		   we're doing a remove operation? */
		if (linkp != NULL)
		{
		    /* Create a new hardlink_info node, which will record
		       the current file's status and the links listed in its
		       `hardlinks' delta field.  We will append this
		       hardlink_info node to the appropriate hardlist entry. */
		    hlinfo = (struct hardlink_info *)
			xmalloc (sizeof (struct hardlink_info));
		    hlinfo->status = status;
		    hlinfo->links = NULL;
		    linkp->data = (char *) hlinfo;
		}
	    }
#endif

d1283 2
a1284 3
			    (mode_t) -1,
			    (unsigned char *) NULL,
			    (struct buffer *) NULL);
d1648 3
a1650 2
	error (0, 0,
	       "failed to check out `%s'", finfo->fullname);
a1983 1
	FILE *fp;
d1990 1
a1990 8

	/* Create empty FILE.  Can't use copy_file with a DEVNULL
	   argument -- copy_file now ignores device files. */
	fp = fopen (file, "w");
	if (fp == NULL)
	    error (1, errno, "cannot open %s for writing", file);
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", file);
d2159 1
a2159 19

    /* We used to call RCS_rewrite here, and that might seem
       appropriate in order to write out the locked revision
       information.  However, such a call would actually serve no
       purpose.  CVS locks will prevent any interference from other
       CVS processes.  The comment above rcs_internal_lockfile
       explains that it is already unsafe to use RCS and CVS
       simultaneously.  It follows that writing out the locked
       revision information here would add no additional security.

       If we ever do care about it, the proper fix is to create the
       RCS lock file before calling this function, and maintain it
       until the checkin is complete.

       The call to RCS_lock is still required at present, since in
       some cases RCS_checkin will determine which revision to check
       in by looking for a lock.  FIXME: This is rather roundabout,
       and a more straightforward approach would probably be easier to
       understand.  */
d2165 6
a2170 1
	sbranch = branch;
d2185 1
a2185 2
   the fact.  TODO: now that RCS has been librarified, we have the power
   to change this. */
a2194 6
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Do ye nothing to the modes on a symbolic link. */
    if (preserve_perms && islink (user))
	return;
#endif

a2202 3

       TODO: decide whether this whole thing can/should be skipped
       when `preserve_perms' is set.  Almost certainly so. -twp
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d4 1
a4 1
 *
d7 1
a7 1
 *
d9 1
a9 1
 *
d14 1
a14 1
 *
d32 1
a32 1
			       char *options, RCSNode **rcsnode));
d77 1
a77 1
static char *saved_tag;
d82 1
a82 2
static List *saved_ulist;
static char *saved_message;
d250 1
a250 1
    vers = Version_TS (&xfinfo, NULL, saved_tag, NULL, 0, 0);
d367 1
a367 1
		if (saved_message)
d369 2
a370 2
		    free (saved_message);
		    saved_message = NULL;
d373 1
a373 1
		saved_message = xstrdup(optarg);
d376 3
a378 3
		if (saved_tag)
		    free (saved_tag);
		saved_tag = xstrdup (optarg);
d408 1
a408 1
    if (saved_tag && isdigit (*saved_tag))
d412 2
a413 2
	while (saved_tag[strlen (saved_tag) - 1] == '.')
	    saved_tag[strlen (saved_tag) - 1] = '\0';
d422 1
a422 1
	if (saved_message)
d432 1
a432 1
	saved_message = xmalloc (statbuf.st_size + 1);
d436 1
a436 1
	if ((n = read (logfd, saved_message, statbuf.st_size + 1)) < 0)
d440 1
a440 1
	saved_message[n] = '\0';
d444 1
a444 1
    if (client_active)
d446 1
d461 1
a461 1
	find_args.force = force_ci || saved_tag != NULL;
d503 1
a503 1
	    do_editor (".", &saved_message, (char *)NULL, find_args.ulist);
d508 1
a508 1
	do_verify (saved_message, (char *)NULL);
d513 1
a513 1
	option_with_arg ("-m", saved_message);
d562 1
a562 1
	option_with_arg ("-r", saved_tag);
d585 1
a585 1
	if (err != 0 && use_editor && saved_message != NULL)
d603 1
a603 2
	    if (fwrite (saved_message, 1, strlen (saved_message), fp)
		!= strlen (saved_message))
d613 2
a614 2
    if (saved_tag != NULL)
	tag_check_valid (saved_tag, argc, argv, local, aflag, "");
d618 1
a618 1
	write_dirtag = saved_tag;
d654 11
d686 1
a686 1
	if (now == last_register_time)
d716 1
a716 1
    if (saved_tag && isdigit (*saved_tag))
d719 1
a719 1
	if (numdots (saved_tag) < 2)
d729 1
a729 1
		xstatus = Classify_File (finfo, saved_tag, (char *) NULL,
d747 1
a747 1
	    xtag = xstrdup (saved_tag);
d768 1
a768 1
	    (*vers)->tag = xstrdup (saved_tag);
d773 1
a773 1
	status = Classify_File (finfo, saved_tag, (char *) NULL, (char *) NULL,
d799 1
a799 1

d838 1
a838 1
	    if (!saved_tag || !isdigit (*saved_tag))
d1050 1
d1117 1
d1127 1
a1127 1

d1146 1
a1146 1
    (void) walklist (saved_ulist, precommit_list_proc, NULL);
d1168 1
a1168 1
	saved_ulist = ((struct master_lists *) p->data)->ulist;
d1170 1
a1170 1
	saved_ulist = (List *) NULL;
d1173 1
a1173 1
    if (saved_ulist == NULL || saved_ulist->list->next == saved_ulist->list)
d1241 2
a1242 3
	    do_editor (finfo->update_dir, &saved_message,
		       finfo->repository, ulist);
	do_verify (saved_message, finfo->repository);
d1282 1
a1282 1
			   ci->tag, ci->options, saved_message);
d1322 1
a1322 1
		       ci->options, saved_message);
d1334 1
a1334 1
	err = remove_file (finfo, ci->tag, saved_message);
d1374 1
a1374 1

d1382 1
a1382 1

d1418 1
a1418 1
    Update_Logfile (repository, saved_message, (FILE *) 0, ulist);
d1426 1
a1426 3
	    error (0, 0,
		 "internal error: repository (%s) doesn't begin with root (%s)",
		   repository, CVSroot_directory);
d1430 1
a1430 5
	if (strcmp ("CVSROOT", p) == 0
	    /* Check for subdirectories because people may want to create
	       subdirectories and list files therein in checkoutlist.  */
	    || strncmp ("CVSROOT/", p, strlen ("CVSROOT/")) == 0
	    )
a1437 8
	    /* mkmodules requires the absolute name of the CVSROOT directory.
	       Remove anything after the `CVSROOT' component -- this is
	       necessary when committing in a subdirectory of CVSROOT.  */
	    char *admin_dir = xstrdup (repository);
	    assert (admin_dir[p - repository + strlen ("CVSROOT")] == '\0'
		    || admin_dir[p - repository + strlen ("CVSROOT")] == '/');
	    admin_dir[p - repository + strlen ("CVSROOT")] = '\0';

d1442 1
a1442 2
	    mkmodules (admin_dir);
	    free (admin_dir);
d1455 1
a1455 1
	    char *repos;
d1465 1
a1465 1
		repos = Name_Repository ((char *) NULL, update_dir);
d1467 1
a1467 1
		run_arg (repos);
d1475 1
a1475 1
		free (repos);
d1532 2
a1533 2
	do_editor (update_dir, &saved_message, real_repos, ulist);
    do_verify (saved_message, real_repos);
d1625 1
a1625 1
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0)
d1658 1
a1658 1

d1679 1
a1679 1

d1684 1
a1684 1
        if (RCS_setbranch (finfo->rcs, NULL) != 0)
d1743 1
a1743 1
	tmp = xmalloc(strlen(finfo->repository) +
d1753 2
a1754 3
	(void) sprintf (tmp, "%s/%s/%s%s", finfo->repository, CVSATTIC,
			finfo->file, RCSEXT);

d1797 1
a1797 1
    ret = Checkin ('A', finfo, rcs, rev, tag, options, saved_message);
d1934 1
a1934 1

d2157 1
a2157 1
	}
d2203 1
a2203 1
     *
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d896 1
a896 1
			   finfo->fullname);
d907 2
a914 2
	    if (status == T_ADDED)
	    {
d916 1
a916 1
		{
d938 2
a982 2
	    p->type = UPDATE;
	    p->delproc = update_delproc;
d990 2
a1008 2
	    p->data = (char *) ci;
	    (void) addnode (cilist, p);
d1045 2
a1061 2

/*
d1064 2
a1066 2
/* ARGSUSED */
static Dtype
d1069 2
d1072 1
a1073 3
    char *update_dir;
    List *entries;
{
d1077 2
a1090 2
    void *closure;
{
d1097 2
a1105 1
 * Callback proc for pre-commit checking
d1107 1
d1115 1
a1115 1
    {
d1117 1
a1117 1

a1131 2
    }

d1135 2
a1142 2
/* ARGSUSED */
static int
d1145 2
d1148 1
a1150 1
    List *entries;
d1156 1
a1156 1
    p = findnode (mulist, update_dir);
d1158 1
a1158 1
	saved_ulist = ((struct master_lists *) p->data)->ulist;
d1160 2
a1161 2
	saved_ulist = (List *) NULL;

d1163 1
a1163 1
    if (saved_ulist == NULL || saved_ulist->list->next == saved_ulist->list)
d1178 1
a1178 1
 */
d1180 1
a1180 1
static char *sbranch;
a1181 2
/* ARGSUSED */
static int
d1184 2
a1189 1
    List *ulist, *cilist;
a1190 1

d1206 2
a1224 2
     * need to get the commit message ourselves
     */
d1227 1
a1227 1
	got_message = 1;
d1233 2
a1240 2
    if (ci->status == T_MODIFIED)
    {
d1245 2
d1248 1
a1248 1
	    unlockrcs (finfo->rcs);
a1264 2
	   modified files, we need to stub it in again here. */

d1269 1
a1269 1
	    ci->rev = RCS_whatbranch (finfo->rcs, ci->tag);
d1272 2
a1273 2
	    if (err != 0)
	    {
d1276 2
a1302 2

	/* XXX - an added file with symbolic -r should add tag as well */
d1304 2
a1308 2
    else if (ci->status == T_MODIFIED)
    {
d1312 2
a1316 2
	if (err != 0)
	{
d1319 2
a1322 2
    else if (ci->status == T_REMOVED)
    {
d1324 2
a1326 2
	if (server_active) {
	    server_scratch_entry_only ();
d1330 1
a1330 1
			    /* Doesn't matter, it won't get checked.  */
d1336 2
a1351 2
	    delnode (p);
    }
d1379 2
a1387 2
/* ARGSUSED */
static int
d1390 2
d1393 1
a1394 2
    char *update_dir;
    List *entries;
d1396 1
a1405 2
    got_message = 0;

d1408 2
a1412 2
	char *p;

d1419 2
a1420 2
	if (*p == '/')
	    ++p;
d1426 2
a1432 2
	       focused on how the database is implemented.  */

d1437 5
a1441 4
	    int cvsrootlen = strlen ("CVSROOT");
	    assert (admin_dir[p - repository + cvsrootlen] == '\0'
		    || admin_dir[p - repository + cvsrootlen] == '/');
	    admin_dir[p - repository + cvsrootlen] = '\0';
a1444 2
	    cvs_output (command_name, 0);
	    cvs_output (": Rebuilding administrative file database\n", 0);
d1447 2
d1454 1
a1454 1
	FILE *fp;
d1456 1
a1456 1
	if ((fp = CVS_FOPEN (CVSADM_CIPROG, "r")) != NULL)
d1459 1
a1459 1
	    int line_length;
d1461 1
a1461 1
	    char *repos;
a1468 2
		if (line[line_length - 1] == '\n')
		    line[--line_length] = '\0';
d1476 2
d1479 1
a1479 1
		cvs_output ("'\n", 0);
d1481 1
a1481 1
		free (repos);
d1503 1
a1503 1

d1505 1
a1505 1
 * Get the log message for a dir
a1506 2
/* ARGSUSED */
static Dtype
d1509 2
d1512 1
a1514 1
    List *entries;
a1517 2
    char *real_repos;

d1521 2
d1532 1
a1532 3
	return (R_SKIP_FILES);

    /* get commit message */
d1535 1
a1535 1
    if (use_editor)
d1539 2
a1546 2
/* ARGSUSED */
static int
d1549 2
d1552 1
a1554 3
    List *entries;
{
    /* update the per-directory tag info */
d1558 2
a1559 2
    if (err == 0 && write_dirtag != NULL)
    {
d1562 2
d1580 2
a1583 2
    if (entdata->type != ENT_FILE)
	return (0);
a1599 2
 */
static int
d1602 4
a1605 2
    char *tag;
    char *message;
a1606 1
    mode_t omask;
d1608 1
d1614 1
a1616 1
    char *old_path;
a1621 2
    retcode = 0;

d1625 2
d1628 2
a1629 2
    if (tag && !(branch = RCS_nodeisbranch (finfo->rcs, tag)))
    {
d1631 1
a1631 1
	if ((retcode = RCS_deltag (finfo->rcs, tag)) != 0)
a1632 2
	    if (!quiet)
		error (0, retcode == -1 ? errno : 0,
d1635 2
a1636 2
	    return (1);
	}
d1639 2
a1645 2

    /* Print message indicating that file is going to be removed. */
d1649 3
a1651 1

d1653 1
a1653 1
    lockflag = 1;
d1656 1
a1656 1
	char *branchname;
d1658 1
a1658 1
	rev = RCS_whatbranch (finfo->rcs, tag);
a1661 2
	    return (1);
	}
d1664 2
d1668 1
a1668 1
	    /* no revision exists on this branch.  use the previous
d1670 1
a1670 1
	    corev = RCS_gettag (finfo->rcs, tag, 1, (int *) NULL);
a1679 1
    } else  /* Not a branch */
a1680 1
        /* Get current head revision of file. */
d1682 2
d1685 1
a1685 1

d1688 1
a1688 1
    if (!tag && !branch)
d1690 2
a1691 2
        if (RCS_setbranch (finfo->rcs, NULL) != 0)
	{
d1693 2
a1694 1
		   finfo->fullname);
a1696 1
	RCS_rewrite (finfo->rcs, NULL, NULL);
d1703 1
a1703 1
	   tells time_stamp that the file is no longer around.  Remove
d1705 1
a1705 1
	unlink_file (finfo->file);
a1707 2

    /* check something out.  Generally this is the head.  If we have a
d1712 2
a1713 2
    if (retcode != 0)
    {
d1716 2
a1718 2
    }

d1727 2
a1729 2
	free (corev);

d1732 2
d1736 1
a1736 1
	if (!quiet)
d1738 1
a1738 1
		   "failed to commit dead revision for `%s'", finfo->fullname);
d1743 1
a1745 1
    old_path = finfo->rcs->path;
d1747 1
a1747 1
    {
d1749 1
a1749 1
	tmp = xmalloc(strlen(finfo->repository) +
d1751 1
a1751 1
		      sizeof(CVSATTIC) +
d1753 1
a1753 1
		      strlen(finfo->file) +
d1755 1
a1755 1
	(void) sprintf (tmp, "%s/%s", finfo->repository, CVSATTIC);
a1756 2
	(void) CVS_MKDIR (tmp, 0777);
	(void) umask (omask);
d1763 2
a1766 2
	    return (1);
	}
d1770 2
a1772 2

    /* Print message that file was removed. */
d1779 2
a1780 2
    free(prev_rev);

d1785 2
a1791 2
 */
static int
d1794 2
d1797 2
a1798 4
    char *tag;
    char *options;
{
    int ret;
d1800 1
a1800 1

d1803 2
a1804 2
    if (ret == 0)
    {
d1808 3
d1812 1
a1812 2
	free (tmp);
    }
d1814 2
a1815 1
	fixaddfile (finfo->file, finfo->repository);
a1817 1
    free (rcs);
a1823 2
 */
static void
d1826 1
a1826 1
{
d1829 2
a1830 2
    if ((retcode = RCS_unlock (rcs, NULL, 0)) != 0)
	error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
d1834 2
d1845 1
a1845 1
{
d1847 2
a1848 2
    char *rcs;
    int save_really_quiet;
d1850 1
a1850 1
    rcs = locate_rcs (file, repository);
d1856 1
a1858 1
    free (rcs);
a1862 2
 */
static void
d1865 2
a1866 2
    char *branch;
{
d1868 2
a1870 1
    if (branch != NULL)
d1872 1
a1872 2
	if ((retcode = RCS_setbranch (rcs, branch)) != 0)
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
d1875 2
a1891 2
    RCSNode **rcsnode;
{
d1894 2
d1897 2
a1900 2
    RCSNode *rcsfile = NULL;
    int retval;
a1901 2
    if (tag)
    {
d1915 3
a1917 1
    }
d1919 1
a1919 1
	rcs = locate_rcs (file, repository);
d1921 1
a1921 2
    if (isreadable (rcs))
    {
a1922 1
	char *rev;
d1930 4
d1937 1
a1937 3
	    char *oldfile;

	    /* we are adding on the trunk, so move the file out of the
a1938 2
	    oldfile = xstrdup (rcs);
	    sprintf (rcs, "%s/%s%s", repository, file, RCSEXT);
d1956 2
a1957 2
		|| !isreadable (rcs))
	    {
d1962 1
a1962 1
	    }
d1966 3
a1968 1
	}
a1969 2
	rev = RCS_getversion (rcsfile, tag, NULL, 1, (int *) NULL);
	/* and lock it */
d1972 1
a1972 1
	    error (0, 0, "cannot lock `%s'.", rcs);
d1977 2
a1978 2
	}

d1984 2
a1985 1
	/* this is the first time we have ever seen this file; create
a1986 1

d1998 2
a2001 2
	   server does not (yet at least) create CVSEXT_LOG files.  */
	if (isfile (fname))
d2006 1
a2006 1

d2017 2
a2018 2
	/* Set RCS keyword expansion options.  */
	if (options && options[0] == '-' && options[1] == 'k')
d2035 1
a2035 1
	{
d2038 1
a2038 1
	}
d2040 1
a2040 1
	newfile = 1;
d2043 2
d2050 1
d2053 2
a2054 1
	FILE *fp;
a2056 4
	fname = xmalloc (strlen (file) + sizeof (CVSADM)
			 + sizeof (CVSPREFIX) + 10);
	(void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	rename_file (file, fname);
d2065 2
a2069 2
	(void) sprintf (tmp, "file %s was initially added on branch %s.",
			file, tag);
d2072 2
a2076 2
	    error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		   "could not create initial dead revision %s", rcs);
d2079 2
a2082 2
	/* put the new file back where it was */
	rename_file (fname, file);
d2100 1
a2100 1
	/* and lock it once again. */
d2103 1
a2103 1
	    error (0, 0, "cannot lock `%s'.", rcs);
d2106 2
a2112 1
	/* when adding with a tag, we need to stub a branch, if it
d2115 1
a2115 2
	if (rcsfile == NULL)
	{
d2128 1
a2128 1
	}
d2132 2
a2134 2
	    char *head;
	    char *magicrev;
d2137 1
a2137 1
	    magicrev = RCS_magicrev (rcsfile, head);
d2146 2
a2148 2
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not stub branch %s for %s", tag, rcs);
d2151 3
a2153 1
	    }
a2155 2
	{
	    /* lock the branch. (stubbed branches need not be locked.)  */
d2158 1
a2158 1
		error (0, 0, "cannot lock `%s'.", rcs);
d2161 2
a2163 2
	}

d2169 2
a2172 2
    fileattr_newfile (file);

d2179 1
a2179 1
    fix_rcs_modes (rcs, file);
d2186 2
d2197 1
a2197 1
lock_RCS (user, rcs, rev, repository)
d2199 1
a2199 1
    RCSNode *rcs;
a2200 1
    char *repository;
d2202 1
d2208 1
a2208 1
     * no revision is specified ""), definitely move the branch to the trunk
d2210 1
a2210 1
     *
a2214 2
    if (rev == NULL || (rev && isdigit (*rev) && numdots (rev) < 2))
    {
d2217 1
a2217 1
	{
d2219 1
a2219 1
	    {
d2225 1
d2227 2
a2229 1
	err = RCS_lock(rcs, NULL, 1);
a2232 2
	(void) RCS_lock(rcs, rev, 1);
    }
d2252 2
a2254 2
    if (err == 0)
    {
d2258 2
d2263 1
a2263 1
    /* try to restore the branch if we can on error */
d2265 1
a2265 1
	fixbranch (rcs, branch);
a2269 2
}

d2275 2
d2281 1
a2282 3
    struct stat sb;
    mode_t rcs_mode;

d2331 2
d2334 1
a2334 1

d2336 1
a2336 1
 * free an UPDATE node's data
a2339 2
    Node *p;
{
d2350 2
a2385 2
}

d2397 2
a2398 1
    char *file;
a2399 1
{
d2403 2
d2410 1
a2412 1
    return rcs;
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d52 1
d343 1
a343 6
    if (geteuid () == (uid_t) 0
#  ifdef CLIENT_SUPPORT
	/* Who we are on the client side doesn't affect logging.  */
	&& !client_active
#  endif
	)
d409 1
a409 1
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
d564 7
a582 7
	/* Sending only the names of the files which were modified, added,
	   or removed means that the server will only do an up-to-date
	   check on those files.  This is different from local CVS and
	   previous versions of client/server CVS, but it probably is a Good
	   Thing, or at least Not Such A Bad Thing.  */
	send_file_names (find_args.argc, find_args.argv, 0);

d706 1
a706 1
    if (saved_tag && isdigit ((unsigned char) *saved_tag))
a789 13
    size_t cvsroot_len = strlen (CVSroot_directory);

    if (strncmp (finfo->repository, CVSroot_directory, cvsroot_len) == 0
	&& ISDIRSEP (finfo->repository[cvsroot_len])
	&& strncmp (finfo->repository + cvsroot_len + 1,
		    CVSROOTADM,
		    sizeof (CVSROOTADM) - 1) == 0
	&& ISDIRSEP (finfo->repository[cvsroot_len + sizeof (CVSROOTADM)])
	&& strcmp (finfo->repository + cvsroot_len + sizeof (CVSROOTADM) + 1,
		   CVSNULLREPOS) == 0
	)
	error (1, 0, "cannot check in to %s", finfo->repository);

d828 1
a828 1
	    if (!saved_tag || !isdigit ((unsigned char) *saved_tag))
d900 1
a900 3
	    if (status == T_REMOVED
		&& vers->tag
		&& isdigit ((unsigned char) *vers->tag))
d939 1
a939 1
		if (vers->tag && isdigit ((unsigned char) *vers->tag) &&
d999 1
a999 1
		if (isdigit ((unsigned char) *vers->tag))
d1118 1
a1118 1
	    if (isspace ((unsigned char) *cp))
d1265 1
a1265 5
	if (ci->tag

	    /* If numeric, it is on the trunk; check_fileproc enforced
	       this.  */
	    && !isdigit ((unsigned char) ci->tag[0]))
d1599 1
a1599 3

   Return value is 0 on success, or >0 on error (in which case we have
   printed an error message).  */
d1606 1
d1608 1
d1698 10
d1744 1
a1744 1
    old_path = xstrdup (finfo->rcs->path);
d1746 26
a1771 1
	RCS_setattic (finfo->rcs, 1);
d1782 2
a1783 1
    free (old_path);
d1809 1
a1809 3
	if (unlink_file (tmp) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmp);
d1853 1
a1853 4
    {
	if (unlink_file (rcs) < 0)
	    error (0, errno, "cannot remove %s", rcs);
    }
a1899 12
    int adding_on_branch;

    /* Callers expect to be able to use either "" or NULL to mean the
       default keyword expansion.  */
    if (options != NULL && options[0] == '\0')
	options = NULL;
    if (options != NULL)
	assert (options[0] == '-' && options[1] == 'k');

    /* If numeric, it is on the trunk; check_fileproc enforced
       this.  */
    adding_on_branch = tag != NULL && !isdigit ((unsigned char) tag[0]);
d1901 1
a1901 1
    if (adding_on_branch)
a1923 1
	char *oldexpand;
d1932 3
a1934 24
	oldexpand = RCS_getexpand (rcsfile);
	if ((oldexpand != NULL
	     && options != NULL
	     && strcmp (options + 2, oldexpand) != 0)
	    || (oldexpand == NULL && options != NULL))
	{
	    /* We tell the user about this, because it means that the
	       old revisions will no longer retrieve the way that they
	       used to.  */
	    error (0, 0, "changing keyword expansion mode to %s", options);
	    RCS_setexpand (rcsfile, options + 2);
	}

	if (!adding_on_branch)
	{
	    /* We are adding on the trunk, so move the file out of the
	       Attic.  */
	    if (!(rcsfile->flags & INATTIC))
	    {
		error (0, 0, "internal error: confused about attic for %s",
		       rcsfile->path);
		retval = 1;
		goto out;
	    }
d1936 3
d1941 1
a1941 1
	    if (RCS_setattic (rcsfile, 0))
d1943 4
d1950 17
d2019 1
a2019 1
	if (options != NULL)
d2048 1
a2048 1
    if (adding_on_branch && newfile)
d2110 1
a2110 1
    if (adding_on_branch)
d2174 7
a2180 16
    /* At this point, we used to set the file mode of the RCS file
       based on the mode of the file in the working directory.  If we
       are creating the RCS file for the first time, add_rcs_file does
       this already.  If we are re-adding the file, then perhaps it is
       consistent to preserve the old file mode, just as we preserve
       the old keyword expansion mode.

       If we decide that we should change the modes, then we can't do
       it here anyhow.  At this point, the RCS file may be owned by
       somebody else, so a chmod will fail.  We need to instead do the
       chmod after rewriting it.

       FIXME: In general, I think the file mode (and the keyword
       expansion mode) should be associated with a particular revision
       of the file, so that it is possible to have different revisions
       of a file have different modes.  */
d2214 1
a2214 2
    if (rev == NULL
	|| (rev && isdigit ((unsigned char) *rev) && numdots (rev) < 2))
d2269 63
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@d679 2
a680 1
	for (;;)
a681 2
	    (void) time (&now);
	    if (now != last_register_time) break;
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@a265 1
	freevers_ts (&vers);
a286 1
	freevers_ts (&vers);
d424 2
a425 1
	size_t size = 0, len;
d430 16
a445 1
	get_file (logfile, logfile, "r", &saved_message, &size, &len);
a475 1
	{
a479 1
	    dellist (&find_args.ulist);
a480 1
	}
a585 2
	free (find_args.argv);
	dellist (&find_args.ulist);
a674 1
    /* see if we need to sleep before returning to avoid time-stamp races */
d677 8
a684 2
	while (time ((time_t *) NULL) == last_register_time)
	    sleep (1);
a796 6
    if (!finfo->repository)
    {
	error (0, 0, "nothing known about `%s'", finfo->fullname);
	return (1);
    }

a1292 2
	    if (ci->rev)
		free (ci->rev);
a1402 2
    if (SIG_inCrSect ())
	SIG_endCrSect ();
a1502 1
		cvs_flushout ();
a1584 1
	char *repos = Name_Repository (dir, update_dir);
d1586 1
a1586 2
		  update_dir, repos);
	free (repos);
a1753 3
    /* At this point, the file has been committed as removed.  We should
       probably tell the history file about it  */
    history_write ('R', NULL, finfo->rcs->head, finfo->file, finfo->repository);
a1964 5
	    /* Begin a critical section around the code that spans the
	       first commit on the trunk of a file that's already been
	       committed on a branch.  */
	    SIG_beginCrSect ();

a2046 5
	if (rcsnode != NULL)
	{
	    assert (*rcsnode == NULL);
	    *rcsnode = rcsfile;
	}
d2051 1
a2051 1
    if (adding_on_branch)
d2053 25
a2077 1
	if (newfile)
d2079 5
a2083 2
	    char *tmp;
	    FILE *fp;
d2085 3
a2087 13
	    /* move the new file out of the way. */
	    fname = xmalloc (strlen (file) + sizeof (CVSADM)
			     + sizeof (CVSPREFIX) + 10);
	    (void) sprintf (fname, "%s/%s%s", CVSADM, CVSPREFIX, file);
	    rename_file (file, fname);

	    /* Create empty FILE.  Can't use copy_file with a DEVNULL
	       argument -- copy_file now ignores device files. */
	    fp = fopen (file, "w");
	    if (fp == NULL)
		error (1, errno, "cannot open %s for writing", file);
	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", file);
d2089 14
a2102 14
	    tmp = xmalloc (strlen (file) + strlen (tag) + 80);
	    /* commit a dead revision. */
	    (void) sprintf (tmp, "file %s was initially added on branch %s.",
			    file, tag);
	    retcode = RCS_checkin (rcsfile, NULL, tmp, NULL,
				   RCS_FLAGS_DEAD | RCS_FLAGS_QUIET);
	    free (tmp);
	    if (retcode != 0)
	    {
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "could not create initial dead revision %s", rcs);
		retval = 1;
		goto out;
	    }
d2104 6
a2109 23
	    /* put the new file back where it was */
	    rename_file (fname, file);
	    free (fname);

	    /* double-check that the file was written correctly */
	    freercsnode (&rcsfile);
	    rcsfile = RCS_parse (file, repository);
	    if (rcsfile == NULL)
	    {
		error (0, 0, "could not read %s", rcs);
		retval = 1;
		goto out;
	    }
	    if (rcsnode != NULL)
		*rcsnode = rcsfile;

	    /* and lock it once again. */
	    if (lock_RCS (file, rcsfile, NULL, repository))
	    {
		error (0, 0, "cannot lock `%s'.", rcs);
		retval = 1;
		goto out;
	    }
d2111 1
d2113 2
a2196 2
    if (retval != 0 && SIG_inCrSect ())
	SIG_endCrSect ();
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d88 7
a94 7
    "    -n          Do not run the module program (if any).\n",
    "    -R          Process directories recursively.\n",
    "    -l          Local directory only (not recursive).\n",
    "    -f          Force the file to be committed; disables recursion.\n",
    "    -F logfile  Read the log message from file.\n",
    "    -m msg      Log message.\n",
    "    -r rev      Commit to this branch or trunk revision.\n",
d347 1
a347 1
	&& !current_parsed_root->isremote
d435 1
a435 1
    if (current_parsed_root->isremote)
d594 2
a595 1
	    fp = cvs_temp_file (&fname);
a603 1
	    free (fname);
d618 1
a618 1
    lock_tree_for_write (argc, argv, local, W_LOCAL, aflag);
a665 5
#ifdef SERVER_SUPPORT
    if (server_active)
	return err;
#endif

d669 2
a670 1
	sleep_past (last_register_time);
d781 1
a781 1
    size_t cvsroot_len = strlen (current_parsed_root->directory);
d789 1
a789 1
    if (strncmp (finfo->repository, current_parsed_root->directory, cvsroot_len) == 0
d813 1
d815 1
d832 1
a832 1
	     *    a branch or head is dead
d929 12
a940 2
		    if (finfo->rcs != NULL &&
			!RCS_isdead (finfo->rcs, finfo->rcs->head))
d944 1
a944 1
			       finfo->fullname, finfo->rcs->path);
d946 1
d949 1
d951 1
a951 1
		else if (isdigit ((unsigned char) *vers->tag) &&
a1313 6
	    if (finfo->rcs->head) {
		/* resurrecting: include dead revision */
		int thisrev = atoi (finfo->rcs->head);
		if (thisrev > maxrev)
		    maxrev = thisrev;
	    }
d1433 2
a1434 2
	if (strncmp (current_parsed_root->directory, repository,
		     strlen (current_parsed_root->directory)) != 0)
d1437 2
a1438 2
		   repository, current_parsed_root->directory);
	p = repository + strlen (current_parsed_root->directory);
d1599 1
d1606 3
d1610 2
d1959 1
a1959 1
		error (0, 0, "warning: expected %s to be in Attic",
d1961 2
@


