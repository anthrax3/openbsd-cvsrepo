head	1.5;
access;
symbols
	OPENBSD_6_0:1.4.0.18
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.14
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.16
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.12
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.10
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.6
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.4
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.2
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.30
	OPENBSD_5_0:1.3.0.28
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.26
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.24
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.20
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.22
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.18
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.16
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.14
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.12
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.10
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.8
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.6
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.4
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.12
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.10
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.1.1.12.0.2
	OPENBSD_3_0_BASE:1.1.1.12
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.1.1.11.0.2
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.10.0.8
	OPENBSD_2_8_BASE:1.1.1.10
	OPENBSD_2_7:1.1.1.10.0.6
	OPENBSD_2_7_BASE:1.1.1.10
	OPENBSD_2_6:1.1.1.10.0.4
	OPENBSD_2_6_BASE:1.1.1.10
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.1.1.10.0.2
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.9.0.4
	OPENBSD_2_4_BASE:1.1.1.9
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.9
	OPENBSD_2_3:1.1.1.9.0.2
	OPENBSD_2_3_BASE:1.1.1.9
	cvs-1-9-26:1.1.1.9
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2016.08.16.18.57.10;	author tb;	state Exp;
branches;
next	1.4;
commitid	hwEqPHLhtOTsmYZn;

1.4
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2004.10.23.16.25.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.06.05.31.51;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.14;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.00;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.42;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.40;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.37;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.12;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.47;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.20;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.05;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.43;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.5
log
@When the commit message is empty, don't default to c)ontinue
(committing without log message), but to a)bort.

ok jcs, natano; millert and tj agree
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 */

#include "cvs.h"
#include "getline.h"

static int find_type PROTO((Node * p, void *closure));
static int fmt_proc PROTO((Node * p, void *closure));
static int logfile_write PROTO((char *repository, char *filter,
			  char *message, FILE * logfp, List * changes));
static int rcsinfo_proc PROTO((char *repository, char *template));
static int title_proc PROTO((Node * p, void *closure));
static int update_logfile_proc PROTO((char *repository, char *filter));
static void setup_tmpfile PROTO((FILE * xfp, char *xprefix, List * changes));
static int editinfo_proc PROTO((char *repository, char *template));
static int verifymsg_proc PROTO((char *repository, char *script));

static FILE *fp;
static char *str_list;
static char *str_list_format;	/* The format for str_list's contents. */
static char *editinfo_editor;
static char *verifymsg_script;
static Ctype type;

/*
 * Puts a standard header on the output which is either being prepared for an
 * editor session, or being sent to a logfile program.  The modified, added,
 * and removed files are included (if any) and formatted to look pretty. */
static char *prefix;
static int col;
static char *tag;
static void
setup_tmpfile (xfp, xprefix, changes)
    FILE *xfp;
    char *xprefix;
    List *changes;
{
    /* set up statics */
    fp = xfp;
    prefix = xprefix;

    type = T_MODIFIED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sModified Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
    type = T_ADDED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sAdded Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
    type = T_REMOVED;
    if (walklist (changes, find_type, NULL) != 0)
    {
	(void) fprintf (fp, "%sRemoved Files:\n", prefix);
	col = 0;
	(void) walklist (changes, fmt_proc, NULL);
	(void) fprintf (fp, "\n");
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
    }
}

/*
 * Looks for nodes of a specified type and returns 1 if found
 */
static int
find_type (p, closure)
    Node *p;
    void *closure;
{
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
	return (1);
    else
	return (0);
}

/*
 * Breaks the files list into reasonable sized lines to avoid line wrap...
 * all in the name of pretty output.  It only works on nodes whose types
 * match the one we're looking for
 */
static int
fmt_proc (p, closure)
    Node *p;
    void *closure;
{
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
    {
        if (li->tag == NULL
	    ? tag != NULL
	    : tag == NULL || strcmp (tag, li->tag) != 0)
	{
	    if (col > 0)
	        (void) fprintf (fp, "\n");
	    (void) fprintf (fp, "%s", prefix);
	    col = strlen (prefix);
	    while (col < 6)
	    {
	        (void) fprintf (fp, " ");
		++col;
	    }

	    if (li->tag == NULL)
	        (void) fprintf (fp, "No tag");
	    else
	        (void) fprintf (fp, "Tag: %s", li->tag);

	    if (tag != NULL)
	        free (tag);
	    tag = xstrdup (li->tag);

	    /* Force a new line.  */
	    col = 70;
	}

	if (col == 0)
	{
	    (void) fprintf (fp, "%s\t", prefix);
	    col = 8;
	}
	else if (col > 8 && (col + (int) strlen (p->key)) > 70)
	{
	    (void) fprintf (fp, "\n%s\t", prefix);
	    col = 8;
	}
	(void) fprintf (fp, "%s ", p->key);
	col += strlen (p->key) + 1;
    }
    return (0);
}

/*
 * Builds a temporary file using setup_tmpfile() and invokes the user's
 * editor on the file.  The header garbage in the resultant file is then
 * stripped and the log message is stored in the "message" argument.
 * 
 * If REPOSITORY is non-NULL, process rcsinfo for that repository; if it
 * is NULL, use the CVSADM_TEMPLATE file instead.
 */
void
do_editor (dir, messagep, repository, changes)
    char *dir;
    char **messagep;
    char *repository;
    List *changes;
{
    static int reuse_log_message = 0;
    char *line;
    int line_length;
    size_t line_chars_allocated;
    char *fname;
    struct stat pre_stbuf, post_stbuf;
    int retcode = 0;

    if (noexec || reuse_log_message)
	return;

    /* Abort creation of temp file if no editor is defined */
    if (strcmp (Editor, "") == 0 && !editinfo_editor)
	error(1, 0, "no editor defined, must use -e or -m");

    /* Create a temporary file */
    /* FIXME - It's possible we should be relying on cvs_temp_file to open
     * the file here - we get race conditions otherwise.
     */
    fname = cvs_temp_name ();
  again:
    if ((fp = CVS_FOPEN (fname, "w+")) == NULL)
	error (1, 0, "cannot create temporary file %s", fname);

    if (*messagep)
    {
	(void) fprintf (fp, "%s", *messagep);

	if ((*messagep)[0] == '\0' ||
	    (*messagep)[strlen (*messagep) - 1] != '\n')
	    (void) fprintf (fp, "\n");
    }
    else
	(void) fprintf (fp, "\n");

    if (repository != NULL)
	/* tack templates on if necessary */
	(void) Parse_Info (CVSROOTADM_RCSINFO, repository, rcsinfo_proc, 1);
    else
    {
	FILE *tfp;
	char buf[1024];
	size_t n;
	size_t nwrite;

	/* Why "b"?  */
	tfp = CVS_FOPEN (CVSADM_TEMPLATE, "rb");
	if (tfp == NULL)
	{
	    if (!existence_error (errno))
		error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	}
	else
	{
	    while (!feof (tfp))
	    {
		char *p = buf;
		n = fread (buf, 1, sizeof buf, tfp);
		nwrite = n;
		while (nwrite > 0)
		{
		    n = fwrite (p, 1, nwrite, fp);
		    nwrite -= n;
		    p += n;
		}
		if (ferror (tfp))
		    error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	    }
	    if (fclose (tfp) < 0)
		error (0, errno, "cannot close %s", CVSADM_TEMPLATE);
	}
    }

    (void) fprintf (fp,
  "%s----------------------------------------------------------------------\n",
		    CVSEDITPREFIX);
    (void) fprintf (fp,
  "%sEnter Log.  Lines beginning with `%.*s' are removed automatically\n%s\n",
		    CVSEDITPREFIX, CVSEDITPREFIXLEN, CVSEDITPREFIX,
		    CVSEDITPREFIX);
    if (dir != NULL && *dir)
	(void) fprintf (fp, "%sCommitting in %s\n%s\n", CVSEDITPREFIX,
			dir, CVSEDITPREFIX);
    if (changes != NULL)
	setup_tmpfile (fp, CVSEDITPREFIX, changes);
    (void) fprintf (fp,
  "%s----------------------------------------------------------------------\n",
		    CVSEDITPREFIX);

    /* finish off the temp file */
    if (fclose (fp) == EOF)
        error (1, errno, "%s", fname);
    if ( CVS_STAT (fname, &pre_stbuf) == -1)
	pre_stbuf.st_mtime = 0;

    if (editinfo_editor)
	free (editinfo_editor);
    editinfo_editor = (char *) NULL;
#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
	; /* nothing, leave editinfo_editor NULL */
    else
#endif
    if (repository != NULL)
	(void) Parse_Info (CVSROOTADM_EDITINFO, repository, editinfo_proc, 0);

    /* run the editor */
    run_setup (editinfo_editor ? editinfo_editor : Editor);
    run_arg (fname);
    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
			     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
	error (editinfo_editor ? 1 : 0, retcode == -1 ? errno : 0,
	       editinfo_editor ? "Logfile verification failed" :
	       "warning: editor session failed");

    /* put the entire message back into the *messagep variable */

    fp = open_file (fname, "r");

    if (*messagep)
	free (*messagep);

    if ( CVS_STAT (fname, &post_stbuf) != 0)
	    error (1, errno, "cannot find size of temp file %s", fname);

    if (post_stbuf.st_size == 0)
	*messagep = NULL;
    else
    {
	/* On NT, we might read less than st_size bytes, but we won't
	   read more.  So this works.  */
	*messagep = (char *) xmalloc (post_stbuf.st_size + 1);
 	*messagep[0] = '\0';
    }

    line = NULL;
    line_chars_allocated = 0;

    if (*messagep)
    {
	size_t message_len = post_stbuf.st_size + 1;
	size_t offset = 0;
	while (1)
	{
	    line_length = get_line (&line, &line_chars_allocated, fp);
	    if (line_length == -1)
	    {
		if (ferror (fp))
		    error (0, errno, "warning: cannot read %s", fname);
		break;
	    }
	    if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
		continue;
	    if (offset + line_length >= message_len)
		expand_string (messagep, &message_len,
				offset + line_length + 1);
	    (void) strcpy (*messagep + offset, line);
	    offset += line_length;
	}
    }
    if (fclose (fp) < 0)
	error (0, errno, "warning: cannot close %s", fname);

    if (pre_stbuf.st_mtime == post_stbuf.st_mtime ||
	*messagep == NULL ||
	strcmp (*messagep, "\n") == 0)
    {
	for (;;)
	{
	    (void) printf ("\nLog message unchanged or not specified\n");
	    (void) printf ("a)bort, c)ontinue, e)dit, !)reuse this message unchanged for remaining dirs\n");
	    (void) printf ("Action: (abort) ");
	    (void) fflush (stdout);
	    line_length = get_line (&line, &line_chars_allocated, stdin);
	    if (line_length < 0)
	    {
		error (0, errno, "cannot read from stdin");
		if (unlink_file (fname) < 0)
		    error (0, errno,
			   "warning: cannot remove temp file %s", fname);
		error (1, 0, "aborting");
	    }
	    else if (line_length == 0
		     || *line == '\n' || *line == 'a' || *line == 'A')
		{
		    if (unlink_file (fname) < 0)
			error (0, errno, "warning: cannot remove temp file %s", fname);
		    error (1, 0, "aborted by user");
		}
	    if (*line == 'c' || *line == 'C')
		break;	
	    if (*line == 'e' || *line == 'E')
		goto again;
	    if (*line == '!')
	    {
		reuse_log_message = 1;
		break;
	    }
	    (void) printf ("Unknown input\n");
	}
    }
    if (line)
	free (line);
    if (unlink_file (fname) < 0)
	error (0, errno, "warning: cannot remove temp file %s", fname);
    free (fname);
}

/* Runs the user-defined verification script as part of the commit or import 
   process.  This verification is meant to be run whether or not the user 
   included the -m atribute.  unlike the do_editor function, this is 
   independant of the running of an editor for getting a message.
 */
void
do_verify (message, repository)
    char *message;
    char *repository;
{
    FILE *fp;
    char *fname;
    int retcode = 0;

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
	/* The verification will happen on the server.  */
	return;
#endif

    /* FIXME? Do we really want to skip this on noexec?  What do we do
       for the other administrative files?  */
    if (noexec)
	return;

    /* If there's no message, then we have nothing to verify.  Can this
       case happen?  And if so why would we print a message?  */
    if (message == NULL)
    {
	cvs_output ("No message to verify\n", 0);
	return;
    }

    /* open a temporary file, write the message to the 
       temp file, and close the file.  */

    if ((fp = cvs_temp_file (&fname)) == NULL)
	error (1, errno, "cannot create temporary file %s", fname);
    else
    {
	fprintf (fp, "%s", message);
	if ((message)[0] == '\0' ||
	    (message)[strlen (message) - 1] != '\n')
	    (void) fprintf (fp, "%s", "\n");
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", fname);

	/* Get the name of the verification script to run  */

	if (repository != NULL)
	    (void) Parse_Info (CVSROOTADM_VERIFYMSG, repository, 
			       verifymsg_proc, 0);

	/* Run the verification script  */

	if (verifymsg_script)
	{
	    run_setup (verifymsg_script);
	    run_arg (fname);
	    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
				     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
	    {
		/* Since following error() exits, delete the temp file
		   now.  */
		if (unlink_file (fname) < 0)
		    error (0, errno, "cannot remove %s", fname);

		error (1, retcode == -1 ? errno : 0, 
		       "Message verification failed");
	    }
	}

	/* Delete the temp file  */

	if (unlink_file (fname) < 0)
	    error (0, errno, "cannot remove %s", fname);
	free (fname);
    }
}

/*
 * callback proc for Parse_Info for rcsinfo templates this routine basically
 * copies the matching template onto the end of the tempfile we are setting
 * up
 */
/* ARGSUSED */
static int
rcsinfo_proc (repository, template)
    char *repository;
    char *template;
{
    static char *last_template;
    FILE *tfp;

    /* nothing to do if the last one included is the same as this one */
    if (last_template && strcmp (last_template, template) == 0)
	return (0);
    if (last_template)
	free (last_template);
    last_template = xstrdup (template);

    if ((tfp = CVS_FOPEN (template, "r")) != NULL)
    {
	char *line = NULL;
	size_t line_chars_allocated = 0;

	while (get_line (&line, &line_chars_allocated, tfp) >= 0)
	    (void) fputs (line, fp);
	if (ferror (tfp))
	    error (0, errno, "warning: cannot read %s", template);
	if (fclose (tfp) < 0)
	    error (0, errno, "warning: cannot close %s", template);
	if (line)
	    free (line);
	return (0);
    }
    else
    {
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
	return (1);
    }
}

/*
 * Uses setup_tmpfile() to pass the updated message on directly to any
 * logfile programs that have a regular expression match for the checked in
 * directory in the source repository.  The log information is fed into the
 * specified program as standard input.
 */
static FILE *logfp;
static char *message;
static List *changes;

void
Update_Logfile (repository, xmessage, xlogfp, xchanges)
    char *repository;
    char *xmessage;
    FILE *xlogfp;
    List *xchanges;
{
    /* nothing to do if the list is empty */
    if (xchanges == NULL || xchanges->list->next == xchanges->list)
	return;

    /* set up static vars for update_logfile_proc */
    message = xmessage;
    logfp = xlogfp;
    changes = xchanges;

    /* call Parse_Info to do the actual logfile updates */
    (void) Parse_Info (CVSROOTADM_LOGINFO, repository, update_logfile_proc, 1);
}

/*
 * callback proc to actually do the logfile write from Update_Logfile
 */
static int
update_logfile_proc (repository, filter)
    char *repository;
    char *filter;
{
    return (logfile_write (repository, filter, message, logfp, changes));
}

/*
 * concatenate each filename/version onto str_list
 */
static int
title_proc (p, closure)
    Node *p;
    void *closure;
{
    struct logfile_info *li;
    char *c;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
    {
	/* Until we decide on the correct logging solution when we add
	   directories or perform imports, T_TITLE nodes will only
	   tack on the name provided, regardless of the format string.
	   You can verify that this assumption is safe by checking the
	   code in add.c (add_directory) and import.c (import). */

	str_list = xrealloc (str_list, strlen (str_list) + 5);
	(void) strcat (str_list, " ");

	if (li->type == T_TITLE)
	{
	    str_list = xrealloc (str_list,
				 strlen (str_list) + strlen (p->key) + 5);
	    (void) strcat (str_list, p->key);
	}
	else
	{
	    /* All other nodes use the format string. */

	    for (c = str_list_format; *c != '\0'; c++)
	    {
		switch (*c)
		{
		case 's':
		    str_list =
			xrealloc (str_list,
				  strlen (str_list) + strlen (p->key) + 5);
		    (void) strcat (str_list, p->key);
		    break;
		case 't':
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->tag ? strlen (li->tag) : 0)
				   + 10)
				  );
		    (void) strcat (str_list, (li->tag ? li->tag : ""));
		    break;
		case 'V':
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_old ? strlen (li->rev_old) : 0)
				   + 10)
				  );
		    (void) strcat (str_list, (li->rev_old
					      ? li->rev_old : "NONE"));
		    break;
		case 'v':
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_new ? strlen (li->rev_new) : 0)
				   + 10)
				  );
		    (void) strcat (str_list, (li->rev_new
					      ? li->rev_new : "NONE"));
		    break;
		/* All other characters, we insert an empty field (but
		   we do put in the comma separating it from other
		   fields).  This way if future CVS versions add formatting
		   characters, one can write a loginfo file which at least
		   won't blow up on an old CVS.  */
		}
		if (*(c + 1) != '\0')
		{
		    str_list = xrealloc (str_list, strlen (str_list) + 5);
		    (void) strcat (str_list, ",");
		}
	    }
	}
    }
    return (0);
}

/*
 * Writes some stuff to the logfile "filter" and returns the status of the
 * filter program.
 */
static int
logfile_write (repository, filter, message, logfp, changes)
    char *repository;
    char *filter;
    char *message;
    FILE *logfp;
    List *changes;
{
    FILE *pipefp;
    char *prog;
    char *cp;
    int c;
    int pipestatus;
    char *fmt_percent;		/* the location of the percent sign
				   that starts the format string. */

    /* The user may specify a format string as part of the filter.
       Originally, `%s' was the only valid string.  The string that
       was substituted for it was:

         <repository-name> <file1> <file2> <file3> ...

       Each file was either a new directory/import (T_TITLE), or a
       added (T_ADDED), modified (T_MODIFIED), or removed (T_REMOVED)
       file.

       It is desirable to preserve that behavior so lots of commitlog
       scripts won't die when they get this new code.  At the same
       time, we'd like to pass other information about the files (like
       version numbers, statuses, or checkin times).

       The solution is to allow a format string that allows us to
       specify those other pieces of information.  The format string
       will be composed of `%' followed by a single format character,
       or followed by a set of format characters surrounded by `{' and
       `}' as separators.  The format characters are:

         s = file name
         t = tag name
	 V = old version number (pre-checkin)
	 v = new version number (post-checkin)

       For example, valid format strings are:

         %{}
	 %s
	 %{s}
	 %{sVv}
	 %{Vvts}

       There's no reason that more items couldn't be added (like
       modification date or file status [added, modified, updated,
       etc.]) -- the code modifications would be minimal (logmsg.c
       (title_proc) and commit.c (check_fileproc)).

       The output will be a string of tokens separated by spaces.  For
       backwards compatibility, the the first token will be the
       repository name.  The rest of the tokens will be
       comma-delimited lists of the information requested in the
       format string.  For example, if `/u/src/master' is the
       repository, `%{sVv}' is the format string, and three files
       (ChangeLog, Makefile, foo.c) were modified, the output might
       be:

         /u/src/master ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13

       Why this duplicates the old behavior when the format string is
       `%s' is left as an exercise for the reader. */

    fmt_percent = strchr (filter, '%');
    if (fmt_percent)
    {
	int len;
	char *srepos;
	char *fmt_begin, *fmt_end;	/* beginning and end of the
					   format string specified in
					   filter. */
	char *fmt_continue;		/* where the string continues
					   after the format string (we
					   might skip a '}') somewhere
					   in there... */

	/* Grab the format string. */

	if ((*(fmt_percent + 1) == ' ') || (*(fmt_percent + 1) == '\0'))
	{
	    /* The percent stands alone.  This is an error.  We could
	       be treating ' ' like any other formatting character, but
	       using it as a formatting character seems like it would be
	       a mistake.  */

	    /* Would be nice to also be giving the line number.  */
	    error (0, 0, "loginfo: '%%' not followed by formatting character");
	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin;
	    fmt_continue = fmt_begin;
	}
	else if (*(fmt_percent + 1) == '{')
	{
	    /* The percent has a set of characters following it. */

	    fmt_begin = fmt_percent + 2;
	    fmt_end = strchr (fmt_begin, '}');
	    if (fmt_end)
	    {
		/* Skip over the '}' character. */

		fmt_continue = fmt_end + 1;
	    }
	    else
	    {
		/* There was no close brace -- assume that format
                   string continues to the end of the line. */

		/* Would be nice to also be giving the line number.  */
		error (0, 0, "loginfo: '}' missing");
		fmt_end = fmt_begin + strlen (fmt_begin);
		fmt_continue = fmt_end;
	    }
	}
	else
	{
	    /* The percent has a single character following it.  FIXME:
	       %% should expand to a regular percent sign.  */

	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin + 1;
	    fmt_continue = fmt_end;
	}

	len = fmt_end - fmt_begin;
	str_list_format = xmalloc (len + 1);
	strncpy (str_list_format, fmt_begin, len);
	str_list_format[len] = '\0';

	/* Allocate an initial chunk of memory.  As we build up the string
	   we will realloc it.  */
	if (!str_list)
	    str_list = xmalloc (1);
	str_list[0] = '\0';

	/* Add entries to the string.  Don't bother looking for
           entries if the format string is empty. */

	if (str_list_format[0] != '\0')
	{
	    type = T_TITLE;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_ADDED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_MODIFIED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_REMOVED;
	    (void) walklist (changes, title_proc, NULL);
	}

	free (str_list_format);
	
	/* Construct the final string. */

	srepos = Short_Repository (repository);

	prog = cp = xmalloc ((fmt_percent - filter) + 2 * strlen (srepos)
			+ 2 * strlen (str_list) + strlen (fmt_continue)
			+ 10);
	(void) memcpy (cp, filter, fmt_percent - filter);
	cp += fmt_percent - filter;
	*cp++ = '"';
	cp = shell_escape (cp, srepos);
	cp = shell_escape (cp, str_list);
	*cp++ = '"';
	(void) strcpy (cp, fmt_continue);
	    
	/* To be nice, free up some memory. */

	free (str_list);
	str_list = (char *) NULL;
    }
    else
    {
	/* There's no format string. */
	prog = xstrdup (filter);
    }

    if ((pipefp = run_popen (prog, "w")) == NULL)
    {
	if (!noexec)
	    error (0, 0, "cannot write entry to log filter: %s", prog);
	free (prog);
	return (1);
    }
    (void) fprintf (pipefp, "Update of %s\n", repository);
    (void) fprintf (pipefp, "In directory %s:", hostname);
    cp = xgetwd ();
    if (cp == NULL)
	fprintf (pipefp, "<cannot get working directory: %s>\n\n",
		 strerror (errno));
    else
    {
	fprintf (pipefp, "%s\n\n", cp);
	free (cp);
    }

    setup_tmpfile (pipefp, "", changes);
    (void) fprintf (pipefp, "Log Message:\n%s\n", message);
    if (logfp != (FILE *) 0)
    {
	(void) fprintf (pipefp, "Status:\n");
	rewind (logfp);
	while ((c = getc (logfp)) != EOF)
	    (void) putc ((char) c, pipefp);
    }
    free (prog);
    pipestatus = pclose (pipefp);
    return ((pipestatus == -1) || (pipestatus == 127)) ? 1 : 0;
}

/*
 * We choose to use the *last* match within the editinfo file for this
 * repository.  This allows us to have a global editinfo program for the
 * root of some hierarchy, for example, and different ones within different
 * sub-directories of the root (like a special checker for changes made to
 * the "src" directory versus changes made to the "doc" or "test"
 * directories.
 */
/* ARGSUSED */
static int
editinfo_proc(repository, editor)
    char *repository;
    char *editor;
{
    /* nothing to do if the last match is the same as this one */
    if (editinfo_editor && strcmp (editinfo_editor, editor) == 0)
	return (0);
    if (editinfo_editor)
	free (editinfo_editor);

    editinfo_editor = xstrdup (editor);
    return (0);
}

/*  This routine is calld by Parse_Info.  it asigns the name of the
 *  message verification script to the global variable verify_script
 */
static int
verifymsg_proc (repository, script)
    char *repository;
    char *script;
{
    if (verifymsg_script && strcmp (verifymsg_script, script) == 0)
	return (0);
    if (verifymsg_script)
	free (verifymsg_script);
    verifymsg_script = xstrdup (script);
    return (0);
}
@


1.4
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d349 1
a349 1
	    (void) printf ("Action: (continue) ");
d361 1
a361 3
		     || *line == '\n' || *line == 'c' || *line == 'C')
		break;
	    if (*line == 'a' || *line == 'A')
d367 2
@


1.3
log
@Add support for passing the tag name in to the program specified by the
loginfo file.  From NetBSD.  OK otto@@
@
text
@d322 1
a322 1
	    line_length = getline (&line, &line_chars_allocated, fp);
d351 1
a351 1
	    line_length = getline (&line, &line_chars_allocated, stdin);
d492 1
a492 1
	while (getline (&line, &line_chars_allocated, tfp) >= 0)
@


1.2
log
@start editor in an empty line as used to be; deraadt@@ agrees.
@
text
@d593 9
d681 1
d691 1
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d10 1
a10 5

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)logmsg.c 1.48 94/09/29 $";
USE(rcsid);
#endif
d14 2
a15 3
static int logfile_write PROTO((char *repository, char *filter, char *title,
			  char *message, char *revision, FILE * logfp,
			  List * changes));
d21 1
d25 1
d27 1
d36 1
d51 1
a51 2
	(void) fprintf (fp, "%s\t", prefix);
	col = 8;
d54 5
d64 1
a64 2
	(void) fprintf (fp, "%s\t", prefix);
	col = 8;
d67 5
d77 1
a77 2
	(void) fprintf (fp, "%s\t", prefix);
	col = 8;
d80 5
d96 4
a99 1
    if (p->data == (char *) type)
d115 4
a118 1
    if (p->data == (char *) type)
d120 33
a152 1
	if ((col + (int) strlen (p->key)) > 70)
d168 2
a169 4
 * rcsinfo - is the name of a file containing lines tacked onto the end of the
 * RCS info offered to the user for editing. If specified, the '-m' flag to
 * "commit" is disabled -- users are forced to run the editor.
 * 
d179 4
a182 1
    char line[MAXLINELEN], fname[L_tmpnam+1];
d189 4
d194 4
a197 1
    (void) tmpnam (fname);
d199 1
a199 1
    if ((fp = fopen (fname, "w+")) == NULL)
d206 2
a207 1
	if ((*messagep)[strlen (*messagep) - 1] != '\n')
d216 34
d255 3
a257 2
  "%sEnter Log.  Lines beginning with `%s' are removed automatically\n%s\n",
		    CVSEDITPREFIX, CVSEDITPREFIX, CVSEDITPREFIX);
d268 3
a270 2
    (void) fclose (fp);
    if (stat (fname, &pre_stbuf) == -1)
d276 5
d285 1
a285 1
    run_setup ("%s", editinfo_editor ? editinfo_editor : Editor);
d300 1
a300 1
    if (stat (fname, &post_stbuf) != 0)
d307 2
d313 2
a314 2
/* !!! XXX FIXME: fgets is broken.  This should not have any line
   length limits. */
d318 3
a320 1
	while (fgets (line, sizeof (line), fp) != NULL)
d322 8
a329 1
	    if (strncmp (line, CVSEDITPREFIX, sizeof (CVSEDITPREFIX) - 1) == 0)
d331 5
a335 1
	    (void) strcat (*messagep, line);
d338 3
a340 1
    (void) fclose (fp);
d351 11
a361 3
	    *line = '\0';
	    (void) fgets (line, sizeof (line), stdin);
	    if (*line == '\0' || *line == '\n' || *line == 'c' || *line == 'C')
d364 5
a368 1
		error (1, 0, "aborted by user");
d379 85
a463 1
    (void) unlink_file (fname);
a478 1
    char line[MAXLINELEN];
d487 1
a487 1
    if ((tfp = fopen (template, "r")) != NULL)
d489 4
a492 1
	while (fgets (line, sizeof (line), tfp) != NULL)
d494 6
a499 1
	(void) fclose (tfp);
d504 1
a504 1
	error (0, 0, "Couldn't open rcsinfo template file %s", template);
a514 1
static char *title;
a516 1
static char *revision;
d520 1
a520 1
Update_Logfile (repository, xmessage, xrevision, xlogfp, xchanges)
a522 1
    char *xrevision;
a525 2
    char *srepos;

a531 1
    revision = xrevision;
a534 23
    /* figure out a good title string */
    srepos = Short_Repository (repository);

    /* allocate a chunk of memory to hold the title string */
    if (!str_list)
	str_list = xmalloc (MAXLISTLEN);
    str_list[0] = '\0';

    type = T_TITLE;
    (void) walklist (changes, title_proc, NULL);
    type = T_ADDED;
    (void) walklist (changes, title_proc, NULL);
    type = T_MODIFIED;
    (void) walklist (changes, title_proc, NULL);
    type = T_REMOVED;
    (void) walklist (changes, title_proc, NULL);
    title = xmalloc (strlen (srepos) + strlen (str_list) + 1 + 2); /* for 's */
    (void) sprintf (title, "'%s%s'", srepos, str_list);

    /* to be nice, free up this chunk of memory */
    free (str_list);
    str_list = (char *) NULL;

a536 3

    /* clean up */
    free (title);
d547 1
a547 2
    return (logfile_write (repository, filter, title, message, revision,
			   logfp, changes));
d551 1
a551 1
 * concatenate each name onto str_list
d558 5
a562 1
    if (p->data == (char *) type)
d564 7
d572 54
a625 1
	(void) strcat (str_list, p->key);
a630 7
 * Since some systems don't define this...
 */
#ifndef MAXHOSTNAMELEN
#define	MAXHOSTNAMELEN	256
#endif

/*
d635 1
a635 1
logfile_write (repository, filter, title, message, revision, logfp, changes)
a637 1
    char *title;
a638 1
    char *revision;
d642 2
a643 3
    char cwd[PATH_MAX];
    FILE *pipefp, *Popen ();
    char *prog = xmalloc (MAXPROGLEN);
d646 92
d739 78
a816 6
    /* XXX <woods@@web.net> -- this is gross, ugly, and a hack!  FIXME! */
    /*
     * A maximum of 6 %s arguments are supported in the filter
     */
    (void) sprintf (prog, filter, title, title, title, title, title, title);
    if ((pipefp = Popen (prog, "w")) == NULL)
d824 11
a834 4
    (void) fprintf (pipefp, "In directory %s:%s\n\n", hostname,
		    ((cp = getwd (cwd)) != NULL) ? cp : cwd);
    if (revision && *revision)
	(void) fprintf (pipefp, "Revision/Branch: %s\n\n", revision);
d845 2
a846 1
    return (pclose (pipefp));
d870 16
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a9 1
#include "getline.h"
d132 1
a132 4
    char *line;
    int line_length;
    size_t line_chars_allocated;
    char fname[L_tmpnam+1];
a134 1
    char *p;
d175 1
a175 2
    if (fclose (fp) == EOF)
        error (1, errno, "%s", fname);
d212 2
a213 2
    line = NULL;
    line_chars_allocated = 0;
d217 1
a217 2
	p = *messagep;
	while (1)
a218 7
	    line_length = getline (&line, &line_chars_allocated, fp);
	    if (line_length == -1)
	    {
		if (ferror (fp))
		    error (0, errno, "warning: cannot read %s", fname);
		break;
	    }
d221 1
a221 2
	    (void) strcpy (p, line);
	    p += line_length;
d224 1
a224 3
    if (fclose (fp) < 0)
	error (0, errno, "warning: cannot close %s", fname);

d235 3
a237 3
	    line_length = getline (&line, &line_chars_allocated, stdin);
	    if (line_length <= 0
		    || *line == '\n' || *line == 'c' || *line == 'C')
d251 1
a251 4
    if (line)
	free (line);
    if (unlink_file (fname) < 0)
	error (0, errno, "warning: cannot remove temp file %s", fname);
d267 1
d278 1
a278 4
	char *line = NULL;
	size_t line_chars_allocated = 0;

	while (getline (&line, &line_chars_allocated, tfp) >= 0)
d280 1
a280 6
	if (ferror (tfp))
	    error (0, errno, "warning: cannot read %s", template);
	if (fclose (tfp) < 0)
	    error (0, errno, "warning: cannot close %s", template);
	if (line)
	    free (line);
d285 1
a285 1
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d12 5
d429 1
a429 1
    FILE *pipefp, *run_popen ();
d439 1
a439 1
    if ((pipefp = run_popen (prog, "w")) == NULL)
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d115 4
a118 2
 * If REPOSITORY is non-NULL, process rcsinfo for that repository; if it
 * is NULL, use the CVSADM_TEMPLATE file instead.
a138 4
    /* Abort creation of temp file if no editor is defined */
    if (strcmp (Editor, "") == 0 && !editinfo_editor)
	error(1, 0, "no editor defined, must use -e or -m");

a157 35
    else
    {
	FILE *tfp;
	char buf[1024];
	char *p;
	size_t n;
	size_t nwrite;

	/* Why "b"?  */
	tfp = fopen (CVSADM_TEMPLATE, "rb");
	if (tfp == NULL)
	{
	    if (!existence_error (errno))
		error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	}
	else
	{
	    while (!feof (tfp))
	    {
		n = fread (buf, 1, sizeof buf, tfp);
		nwrite = n;
		p = buf;
		while (nwrite > 0)
		{
		    n = fwrite (p, 1, nwrite, fp);
		    nwrite -= n;
		    p += n;
		}
		if (ferror (tfp))
		    error (1, errno, "cannot read %s", CVSADM_TEMPLATE);
	    }
	    if (fclose (tfp) < 0)
		error (0, errno, "cannot close %s", CVSADM_TEMPLATE);
	}
    }
a208 2
	/* On NT, we might read less than st_size bytes, but we won't
	   read more.  So this works.  */
d424 1
a424 1
    FILE *pipefp;
a427 1
    int pipestatus;
d429 1
d431 1
a431 1
     * Only 1 %s argument is supported in the filter
d433 1
a433 1
    (void) sprintf (prog, filter, title);
d456 1
a456 2
    pipestatus = pclose (pipefp);
    return ((pipestatus == -1) || (pipestatus == 127)) ? 1 : 0;
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d15 2
a16 1
			  char *message, FILE * logfp, List * changes));
a33 1
static char *tag;
d48 2
a49 1
	col = 0;
a51 5
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
d57 2
a58 1
	col = 0;
a60 5
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
d66 2
a67 1
	col = 0;
a69 5
	if (tag != NULL)
	{
	    free (tag);
	    tag = NULL;
	}
d81 1
a81 4
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
d97 1
a97 4
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
d99 1
a99 33
        if (li->tag == NULL
	    ? tag != NULL
	    : tag == NULL || strcmp (tag, li->tag) != 0)
	{
	    if (col > 0)
	        (void) fprintf (fp, "\n");
	    (void) fprintf (fp, "%s", prefix);
	    col = strlen (prefix);
	    while (col < 6)
	    {
	        (void) fprintf (fp, " ");
		++col;
	    }

	    if (li->tag == NULL)
	        (void) fprintf (fp, "No tag");
	    else
	        (void) fprintf (fp, "Tag: %s", li->tag);

	    if (tag != NULL)
	        free (tag);
	    tag = xstrdup (li->tag);

	    /* Force a new line.  */
	    col = 70;
	}

	if (col == 0)
	{
	    (void) fprintf (fp, "%s\t", prefix);
	    col = 8;
	}
	else if (col > 8 && (col + (int) strlen (p->key)) > 70)
d129 1
a129 1
    char *fname;
d142 1
a142 1
    fname = cvs_temp_name ();
d144 1
a144 1
    if ((fp = CVS_FOPEN (fname, "w+")) == NULL)
d169 1
a169 1
	tfp = CVS_FOPEN (CVSADM_TEMPLATE, "rb");
d214 1
a214 1
    if ( CVS_STAT (fname, &pre_stbuf) == -1)
d239 1
a239 1
    if ( CVS_STAT (fname, &post_stbuf) != 0)
d291 1
a291 5
		{
		    if (unlink_file (fname) < 0)
			error (0, errno, "warning: cannot remove temp file %s", fname);
		    error (1, 0, "aborted by user");
		}
a305 1
    free (fname);
d329 1
a329 1
    if ((tfp = CVS_FOPEN (template, "r")) != NULL)
d360 1
d364 1
a364 1
Update_Logfile (repository, xmessage, xlogfp, xchanges)
d367 1
d379 1
d421 2
a422 2
    return (logfile_write (repository, filter, title, message, logfp,
			   changes));
d433 1
a433 4
    struct logfile_info *li;

    li = (struct logfile_info *) p->data;
    if (li->type == type)
d453 1
a453 1
logfile_write (repository, filter, title, message, logfp, changes)
d458 1
d483 2
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d14 1
a14 1
static int logfile_write PROTO((char *repository, char *filter,
a20 1
static int verifymsg_proc PROTO((char *repository, char *script));
a23 1
static char *str_list_format;	/* The format for str_list's contents. */
a24 1
static char *verifymsg_script;
a190 1

d201 1
a201 2
	if ((*messagep)[0] == '\0' ||
	    (*messagep)[strlen (*messagep) - 1] != '\n')
d250 2
a251 3
  "%sEnter Log.  Lines beginning with `%.*s' are removed automatically\n%s\n",
		    CVSEDITPREFIX, CVSEDITPREFIXLEN, CVSEDITPREFIX,
		    CVSEDITPREFIX);
a269 5
#ifdef CLIENT_SUPPORT
    if (client_active)
	; /* nothing, leave editinfo_editor NULL */
    else
#endif
d317 1
a317 1
	    if (strncmp (line, CVSEDITPREFIX, CVSEDITPREFIXLEN) == 0)
a362 77
/* Runs the user-defined verification script as part of the commit or import 
   process.  This verification is meant to be run whether or not the user 
   included the -m atribute.  unlike the do_editor function, this is 
   independant of the running of an editor for getting a message.
 */
void
do_verify (message, repository)
    char *message;
    char *repository;
{
    FILE *fp;
    char *fname;
    int retcode = 0;

#ifdef CLIENT_SUPPORT
    if (client_active)
	/* The verification will happen on the server.  */
	return;
#endif

    /* FIXME? Do we really want to skip this on noexec?  What do we do
       for the other administrative files?  */
    if (noexec)
	return;

    /* If there's no message, then we have nothing to verify.  Can this
       case happen?  And if so why would we print a message?  */
    if (message == NULL)
    {
	cvs_output ("No message to verify\n", 0);
	return;
    }

    /* Get a temp filename, open a temporary file, write the message to the 
       temp file, and close the file.  */

    fname = cvs_temp_name ();

    if ((fp = fopen (fname, "w")) < 0)
    {
	error (1, 0, "cannot create temporary file %s", fname);
	return;
    }
    else
    {
	fprintf (fp, "%s", message);
	if ((message)[0] == '\0' ||
	    (message)[strlen (message) - 1] != '\n')
	    (void) fprintf (fp, "%s", "\n");
	if (fclose (fp) == EOF)
	    error (1, errno, "%s", fname);

	/* Get the name of the verification script to run  */

	if (repository != NULL)
	    (void) Parse_Info (CVSROOTADM_VERIFYMSG, repository, 
			       verifymsg_proc, 0);

	/* Run the verification script  */

	if (verifymsg_script)
	{
	    run_setup ("%s", verifymsg_script);
	    run_arg (fname);
	    if ((retcode = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
				     RUN_NORMAL | RUN_SIGIGNORE)) != 0)
		error (1, retcode == -1 ? errno : 0, 
		       "Message verification failed");
	}

	/* Close and delete the temp file  */

	unlink_file (fname);
	free (fname);
    }
}

d412 1
d424 2
d435 23
d460 3
d473 2
a474 1
    return (logfile_write (repository, filter, message, logfp, changes));
d478 1
a478 1
 * concatenate each filename/version onto str_list
a485 1
    char *c;
a489 6
	/* Until we decide on the correct logging solution when we add
	   directories or perform imports, T_TITLE nodes will only
	   tack on the name provided, regardless of the format string.
	   You can verify that this assumption is safe by checking the
	   code in add.c (add_directory) and import.c (import). */

d491 1
a491 34

	if (li->type == T_TITLE)
	{
	    (void) strcat (str_list, p->key);
	}
	else
	{
	    /* All other nodes use the format string. */

	    for (c = str_list_format; *c != '\0'; c++)
	    {
		switch (*c)
		{
		case 's':
		    (void) strcat (str_list, p->key);
		    break;
		case 'V':
		    (void) strcat (str_list, (li->rev_old
					      ? li->rev_old : "NONE"));
		    break;
		case 'v':
		    (void) strcat (str_list, (li->rev_new
					      ? li->rev_new : "NONE"));
		    break;
		/* All other characters, we insert an empty field (but
		   we do put in the comma separating it from other
		   fields).  This way if future CVS versions add formatting
		   characters, one can write a loginfo file which at least
		   won't blow up on an old CVS.  */
		}
		if (*(c + 1) != '\0')
		    (void) strcat (str_list, ",");
	    }
	}
d497 2
a498 1
 * Since some systems don't define this...  */
d508 1
a508 1
logfile_write (repository, filter, message, logfp, changes)
d511 1
d518 1
a518 1
    char *prog;
a521 165
    char *fmt_percent;		/* the location of the percent sign
				   that starts the format string. */

    prog = xmalloc (MAXPROGLEN);
      
    /* The user may specify a format string as part of the filter.
       Originally, `%s' was the only valid string.  The string that
       was substituted for it was:

         <repository-name> <file1> <file2> <file3> ...

       Each file was either a new directory/import (T_TITLE), or a
       added (T_ADDED), modified (T_MODIFIED), or removed (T_REMOVED)
       file.

       It is desirable to preserve that behavior so lots of commitlog
       scripts won't die when they get this new code.  At the same
       time, we'd like to pass other information about the files (like
       version numbers, statuses, or checkin times).

       The solution is to allow a format string that allows us to
       specify those other pieces of information.  The format string
       will be composed of `%' followed by a single format character,
       or followed by a set of format characters surrounded by `{' and
       `}' as separators.  The format characters are:

         s = file name
	 V = old version number (pre-checkin)
	 v = new version number (post-checkin)

       For example, valid format strings are:

         %{}
	 %s
	 %{s}
	 %{sVv}

       There's no reason that more items couldn't be added (like
       modification date or file status [added, modified, updated,
       etc.]) -- the code modifications would be minimal (logmsg.c
       (title_proc) and commit.c (check_fileproc)).

       The output will be a string of tokens separated by spaces.  For
       backwards compatibility, the the first token will be the
       repository name.  The rest of the tokens will be
       comma-delimited lists of the information requested in the
       format string.  For example, if `/u/src/master' is the
       repository, `%{sVv}' is the format string, and three files
       (ChangeLog, Makefile, foo.c) were modified, the output might
       be:

         /u/src/master ChangeLog,1.1,1.2 Makefile,1.3,1.4 foo.c,1.12,1.13

       Why this duplicates the old behavior when the format string is
       `%s' is left as an exercise for the reader. */

    fmt_percent = strchr (filter, '%');
    if (fmt_percent)
    {
	int len;
	char *srepos;
	char *fmt_begin, *fmt_end;	/* beginning and end of the
					   format string specified in
					   filter. */
	char *fmt_continue;		/* where the string continues
					   after the format string (we
					   might skip a '}') somewhere
					   in there... */

	/* Grab the format string. */

	if ((*(fmt_percent + 1) == ' ') || (*(fmt_percent + 1) == '\0'))
	{
	    /* The percent stands alone.  This is an error.  We could
	       be treating ' ' like any other formatting character, but
	       using it as a formatting character seems like it would be
	       a mistake.  */

	    /* Would be nice to also be giving the line number.  */
	    error (0, 0, "loginfo: '%%' not followed by formatting character");
	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin;
	    fmt_continue = fmt_begin;
	}
	else if (*(fmt_percent + 1) == '{')
	{
	    /* The percent has a set of characters following it. */

	    fmt_begin = fmt_percent + 2;
	    fmt_end = strchr (fmt_begin, '}');
	    if (fmt_end)
	    {
		/* Skip over the '}' character. */

		fmt_continue = fmt_end + 1;
	    }
	    else
	    {
		/* There was no close brace -- assume that format
                   string continues to the end of the line. */

		/* Would be nice to also be giving the line number.  */
		error (0, 0, "loginfo: '}' missing");
		fmt_end = fmt_begin + strlen (fmt_begin);
		fmt_continue = fmt_end;
	    }
	}
	else
	{
	    /* The percent has a single character following it.  FIXME:
	       %% should expand to a regular percent sign.  */

	    fmt_begin = fmt_percent + 1;
	    fmt_end = fmt_begin + 1;
	    fmt_continue = fmt_end;
	}

	len = fmt_end - fmt_begin;
	str_list_format = xmalloc (sizeof (char) * (len + 1));
	strncpy (str_list_format, fmt_begin, len);
	str_list_format[len] = '\0';
	
	/* Allocate a chunk of memory to hold the string. */

	if (!str_list)
	    str_list = xmalloc (MAXLISTLEN);
	str_list[0] = '\0';

	/* Add entries to the string.  Don't bother looking for
           entries if the format string is empty. */

	if (str_list_format[0] != '\0')
	{
	    type = T_TITLE;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_ADDED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_MODIFIED;
	    (void) walklist (changes, title_proc, NULL);
	    type = T_REMOVED;
	    (void) walklist (changes, title_proc, NULL);
	}

	/* Construct the final string. */

	srepos = Short_Repository (repository);

	(void) strncpy (prog, filter, fmt_percent - filter);
	prog[fmt_percent - filter] = '\0';
	(void) strcat (prog, "'");
	(void) strcat (prog, srepos);
	(void) strcat (prog, str_list);
	(void) strcat (prog, "'");
	(void) strcat (prog, fmt_continue);
	    
	/* To be nice, free up some memory. */

	free (str_list);
	str_list = (char *) NULL;
    }
    else
    {
	/* There's no format string. */
	strcpy (prog, filter);
    }
d523 4
a571 16
    return (0);
}

/*  This routine is calld by Parse_Info.  it asigns the name of the
 *  message verification script to the global variable verify_script
 */
static int
verifymsg_proc (repository, script)
    char *repository;
    char *script;
{
    if (verifymsg_script && strcmp (verifymsg_script, script) == 0)
	return (0);
    if (verifymsg_script)
	free (verifymsg_script);
    verifymsg_script = xstrdup (script);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d412 1
a412 2
    fp = fopen (fname, "w");
    if (fp == NULL)
d414 1
a414 1
	error (1, errno, "cannot create temporary file %s", fname);
a554 1
	str_list = xrealloc (str_list, strlen (str_list) + 5);
a558 2
	    str_list = xrealloc (str_list,
				 strlen (str_list) + strlen (p->key) + 5);
a569 3
		    str_list =
			xrealloc (str_list,
				  strlen (str_list) + strlen (p->key) + 5);
a572 6
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_old ? strlen (li->rev_old) : 0)
				   + 10)
				  );
a576 6
		    str_list =
			xrealloc (str_list,
				  (strlen (str_list)
				   + (li->rev_new ? strlen (li->rev_new) : 0)
				   + 10)
				  );
a586 2
		{
		    str_list = xrealloc (str_list, strlen (str_list) + 5);
a587 1
		}
d595 6
d612 1
d621 2
d739 2
a741 2
	/* Allocate an initial chunk of memory.  As we build up the string
	   we will realloc it.  */
d743 1
a743 1
	    str_list = xmalloc (1);
a764 3
	prog = xmalloc ((fmt_percent - filter) + strlen (srepos)
			+ strlen (str_list) + strlen (fmt_continue)
			+ 10);
d781 1
a781 1
	prog = xstrdup (filter);
d792 2
a793 11
    (void) fprintf (pipefp, "In directory %s:", hostname);
    cp = xgetwd ();
    if (cp == NULL)
	fprintf (pipefp, "<cannot get working directory: %s>\n\n",
		 strerror (errno));
    else
    {
	fprintf (pipefp, "%s\n\n", cp);
	free (cp);
    }

@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@a773 2
	free (str_list_format);
	
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d285 1
a285 1
    run_setup (editinfo_editor ? editinfo_editor : Editor);
d348 2
a349 10
	    if (line_length < 0)
	    {
		error (0, errno, "cannot read from stdin");
		if (unlink_file (fname) < 0)
		    error (0, errno,
			   "warning: cannot remove temp file %s", fname);
		error (1, 0, "aborting");
	    }
	    else if (line_length == 0
		     || *line == '\n' || *line == 'c' || *line == 'C')
d414 1
d416 2
d437 1
a437 1
	    run_setup (verifymsg_script);
a440 5
	    {
		/* Since following error() exits, delete the temp file
		   now.  */
		unlink_file (fname);

a442 1
	    }
d445 1
a445 1
	/* Delete the temp file  */
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d449 1
a449 2
		if (unlink_file (fname) < 0)
		    error (0, errno, "cannot remove %s", fname);
d458 1
a458 2
	if (unlink_file (fname) < 0)
	    error (0, errno, "cannot remove %s", fname);
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@d185 1
d219 1
a233 1
		char *p = buf;
d236 1
d318 1
a318 2
	size_t message_len = post_stbuf.st_size + 1;
	size_t offset = 0;
d330 2
a331 5
	    if (offset + line_length >= message_len)
		expand_string (messagep, &message_len,
				offset + line_length + 1);
	    (void) strcpy (*messagep + offset, line);
	    offset += line_length;
d762 1
a762 1
	str_list_format = xmalloc (len + 1);
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d193 1
a194 3
    /* FIXME - It's possible we should be relying on cvs_temp_file to open
     * the file here - we get race conditions otherwise.
     */
d208 2
d275 1
a275 1
    if (current_parsed_root->isremote)
d399 1
a399 1
    if (current_parsed_root->isremote)
d417 1
a417 1
    /* open a temporary file, write the message to the 
d420 4
a423 1
    if ((fp = cvs_temp_file (&fname)) == NULL)
d795 2
a796 2
	prog = cp = xmalloc ((fmt_percent - filter) + 2 * strlen (srepos)
			+ 2 * strlen (str_list) + strlen (fmt_continue)
d798 7
a804 7
	(void) memcpy (cp, filter, fmt_percent - filter);
	cp += fmt_percent - filter;
	*cp++ = '"';
	cp = shell_escape (cp, srepos);
	cp = shell_escape (cp, str_list);
	*cp++ = '"';
	(void) strcpy (cp, fmt_continue);
@


