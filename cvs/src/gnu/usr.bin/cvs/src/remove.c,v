head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.13.0.66
	OPENBSD_6_1_BASE:1.1.1.13
	OPENBSD_6_0:1.1.1.13.0.62
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.58
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.60
	OPENBSD_5_8_BASE:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.52
	OPENBSD_5_7_BASE:1.1.1.13
	OPENBSD_5_6:1.1.1.13.0.56
	OPENBSD_5_6_BASE:1.1.1.13
	OPENBSD_5_5:1.1.1.13.0.54
	OPENBSD_5_5_BASE:1.1.1.13
	OPENBSD_5_4:1.1.1.13.0.50
	OPENBSD_5_4_BASE:1.1.1.13
	OPENBSD_5_3:1.1.1.13.0.48
	OPENBSD_5_3_BASE:1.1.1.13
	OPENBSD_5_2:1.1.1.13.0.46
	OPENBSD_5_2_BASE:1.1.1.13
	OPENBSD_5_1_BASE:1.1.1.13
	OPENBSD_5_1:1.1.1.13.0.44
	OPENBSD_5_0:1.1.1.13.0.42
	OPENBSD_5_0_BASE:1.1.1.13
	OPENBSD_4_9:1.1.1.13.0.40
	OPENBSD_4_9_BASE:1.1.1.13
	OPENBSD_4_8:1.1.1.13.0.38
	OPENBSD_4_8_BASE:1.1.1.13
	OPENBSD_4_7:1.1.1.13.0.34
	OPENBSD_4_7_BASE:1.1.1.13
	OPENBSD_4_6:1.1.1.13.0.36
	OPENBSD_4_6_BASE:1.1.1.13
	OPENBSD_4_5:1.1.1.13.0.32
	OPENBSD_4_5_BASE:1.1.1.13
	OPENBSD_4_4:1.1.1.13.0.30
	OPENBSD_4_4_BASE:1.1.1.13
	OPENBSD_4_3:1.1.1.13.0.28
	OPENBSD_4_3_BASE:1.1.1.13
	OPENBSD_4_2:1.1.1.13.0.26
	OPENBSD_4_2_BASE:1.1.1.13
	OPENBSD_4_1:1.1.1.13.0.24
	OPENBSD_4_1_BASE:1.1.1.13
	OPENBSD_4_0:1.1.1.13.0.22
	OPENBSD_4_0_BASE:1.1.1.13
	OPENBSD_3_9:1.1.1.13.0.20
	OPENBSD_3_9_BASE:1.1.1.13
	OPENBSD_3_8:1.1.1.13.0.18
	OPENBSD_3_8_BASE:1.1.1.13
	OPENBSD_3_7:1.1.1.13.0.16
	OPENBSD_3_7_BASE:1.1.1.13
	OPENBSD_3_6:1.1.1.13.0.14
	OPENBSD_3_6_BASE:1.1.1.13
	OPENBSD_3_5:1.1.1.13.0.12
	OPENBSD_3_5_BASE:1.1.1.13
	OPENBSD_3_4:1.1.1.13.0.10
	OPENBSD_3_4_BASE:1.1.1.13
	OPENBSD_3_3:1.1.1.13.0.8
	OPENBSD_3_3_BASE:1.1.1.13
	OPENBSD_3_2:1.1.1.13.0.6
	OPENBSD_3_2_BASE:1.1.1.13
	OPENBSD_3_1:1.1.1.13.0.4
	OPENBSD_3_1_BASE:1.1.1.13
	OPENBSD_3_0:1.1.1.13.0.2
	OPENBSD_3_0_BASE:1.1.1.13
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.1.1.12.0.2
	OPENBSD_2_9_BASE:1.1.1.12
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.1.1.11.0.8
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.6
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.4
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.11.0.2
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.24;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.12;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.55;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.50;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.44;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.22;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.45;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.55;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.30;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.33.27;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.46;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Remove a File
 * 
 * Removes entries from the present version. The entries will be removed from
 * the RCS repository upon the next "commit".
 * 
 * "remove" accepts no options, only file names that are to be removed.  The
 * file must not exist in the current directory for "remove" to work
 * correctly.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)remove.c 1.39 94/10/07 $";
USE(rcsid);
#endif

static int remove_fileproc PROTO((char *file, char *update_dir,
			    char *repository, List *entries,
			    List *srcfiles));
static Dtype remove_dirproc PROTO((char *dir, char *repos, char *update_dir));

static int force;
static int local;
static int removed_files;
static int existing_files;

static const char *const remove_usage[] =
{
    "Usage: %s %s [-flR] [files...]\n",
    "\t-f\tDelete the file before removing it.\n",
    "\t-l\tProcess this directory only (not recursive).\n",
    "\t-R\tProcess directories recursively.\n",
    NULL
};

int
cvsremove (argc, argv)
    int argc;
    char **argv;
{
    int c, err;

    if (argc == -1)
	usage (remove_usage);

    optind = 1;
    while ((c = getopt (argc, argv, "flR")) != -1)
    {
	switch (c)
	{
	    case 'f':
		force = 1;
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case '?':
	    default:
		usage (remove_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    wrap_setup ();

#ifdef CLIENT_SUPPORT
    if (client_active) {
	start_server ();
	ign_setup ();
	if (local)
	    send_arg("-l");
	send_files (argc, argv, local, 0);
	if (fprintf (to_server, "remove\n") < 0)
	    error (1, errno, "writing to server");
        return get_responses_and_close ();
    }
#endif

    /* start the recursion processor */
    err = start_recursion (remove_fileproc, (int (*) ()) NULL, remove_dirproc,
			   (int (*) ()) NULL, argc, argv, local,
			   W_LOCAL, 0, 1, (char *) NULL, 1, 0);

    if (removed_files)
	error (0, 0, "use '%s commit' to remove %s permanently", program_name,
	       (removed_files == 1) ? "this file" : "these files");

    if (existing_files)
	error (0, 0,
	       ((existing_files == 1) ?
		"%d file exists; use `%s' to remove it first" :
		"%d files exist; use `%s' to remove them first"),
	       existing_files, RM);

    return (err);
}

/*
 * remove the file, only if it has already been physically removed
 */
/* ARGSUSED */
static int
remove_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
{
    char fname[PATH_MAX];
    Vers_TS *vers;

    /*
     * If unlinking the file works, good.  If not, the "unremoved"
     * error will indicate problems.
     */
    if (force)
	(void) unlink (file);

    vers = Version_TS (repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       file, 0, 0, entries, srcfiles);

    if (vers->ts_user != NULL)
    {
	existing_files++;
	if (!quiet)
	    error (0, 0, "file `%s' still in working directory", file);
    }
    else if (vers->vn_user == NULL)
    {
	if (!quiet)
	    error (0, 0, "nothing known about `%s'", file);
    }
    else if (vers->vn_user[0] == '0' && vers->vn_user[1] == '\0')
    {
	/*
	 * It's a file that has been added, but not commited yet. So,
	 * remove the ,p and ,t file for it and scratch it from the
	 * entries file.
	 */
	Scratch_Entry (entries, file);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_OPT);
	(void) unlink_file (fname);
	(void) sprintf (fname, "%s/%s%s", CVSADM, file, CVSEXT_LOG);
	(void) unlink_file (fname);
	if (!quiet)
	    error (0, 0, "removed `%s'", file);

#ifdef SERVER_SUPPORT
	if (server_active)
	    server_checked_in (file, update_dir, repository);
#endif
    }
    else if (vers->vn_user[0] == '-')
    {
	if (!quiet)
	    error (0, 0, "file `%s' already scheduled for removal", file);
    }
    else
    {
	/* Re-register it with a negative version number.  */
	(void) strcpy (fname, "-");
	(void) strcat (fname, vers->vn_user);
	Register (entries, file, fname, vers->ts_rcs, vers->options,
		  vers->tag, vers->date, vers->ts_conflict);
	if (!quiet)
	    error (0, 0, "scheduling `%s' for removal", file);
	removed_files++;

#ifdef SERVER_SUPPORT
	if (server_active)
	    server_checked_in (file, update_dir, repository);
#endif
    }

    freevers_ts (&vers);
    return (0);
}

/*
 * Print a warm fuzzy message
 */
/* ARGSUSED */
static Dtype
remove_dirproc (dir, repos, update_dir)
    char *dir;
    char *repos;
    char *update_dir;
{
    if (!quiet)
	error (0, 0, "Removing %s", update_dir);
    return (R_PROCESS);
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a84 1
	send_file_names (argc, argv);
d86 2
a87 1
	send_to_server ("remove\012", 0);
d93 3
a95 3
    err = start_recursion (remove_fileproc, (FILESDONEPROC) NULL,
                           remove_dirproc, (DIRLEAVEPROC) NULL, argc, argv,
                           local, W_LOCAL, 0, 1, (char *) NULL, 1, 0);
d126 4
d131 1
a131 15
    {
	if (!noexec)
	{
	    if (unlink (file) < 0 && ! existence_error (errno))
	    {
		if (update_dir[0] == '\0')
		    error (0, errno, "unable to remove %s", file);
		else
		    error (0, errno, "unable to remove %s/%s", update_dir,
			   file);
	    }
	}
	/* else FIXME should probably act as if the file doesn't exist
	   in doing the following checks.  */
    }
d151 3
a153 2
	 * remove the ,t file for it and scratch it from the
	 * entries file.  */
d155 2
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d20 8
a27 1
static int remove_fileproc PROTO((struct file_info *finfo));
d104 3
a106 3
		"%d file exists; remove it first" :
		"%d files exist; remove them first"),
	       existing_files);
d116 6
a121 2
remove_fileproc (finfo)
    struct file_info *finfo;
d130 1
a130 1
	    if (unlink (finfo->file) < 0 && ! existence_error (errno))
d132 2
a133 2
		if (finfo->update_dir[0] == '\0')
		    error (0, errno, "unable to remove %s", finfo->file);
d135 2
a136 2
		    error (0, errno, "unable to remove %s/%s", finfo->update_dir,
			   finfo->file);
d143 2
a144 2
    vers = Version_TS (finfo->repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       finfo->file, 0, 0, finfo->entries, finfo->srcfiles);
d150 1
a150 1
	    error (0, 0, "file `%s' still in working directory", finfo->file);
d155 1
a155 1
	    error (0, 0, "nothing known about `%s'", finfo->file);
d163 2
a164 2
	Scratch_Entry (finfo->entries, finfo->file);
	(void) sprintf (fname, "%s/%s%s", CVSADM, finfo->file, CVSEXT_LOG);
d167 1
a167 1
	    error (0, 0, "removed `%s'", finfo->file);
d171 1
a171 1
	    server_checked_in (finfo->file, finfo->update_dir, finfo->repository);
d177 1
a177 1
	    error (0, 0, "file `%s' already scheduled for removal", finfo->file);
d184 1
a184 1
	Register (finfo->entries, finfo->file, fname, vers->ts_rcs, vers->options,
d187 1
a187 1
	    error (0, 0, "scheduling `%s' for removal", finfo->file);
d192 1
a192 1
	    server_checked_in (finfo->file, finfo->update_dir, finfo->repository);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d78 1
a78 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d121 5
a125 1
		error (0, errno, "unable to remove %s", finfo->fullname);
d133 1
a133 1
		       finfo->file, 0, 0, finfo->entries, finfo->rcs);
d139 1
a139 2
	    error (0, 0, "file `%s' still in working directory",
		   finfo->fullname);
d144 1
a144 1
	    error (0, 0, "nothing known about `%s'", finfo->fullname);
d156 1
a156 1
	    error (0, 0, "removed `%s'", finfo->fullname);
d166 1
a166 2
	    error (0, 0, "file `%s' already scheduled for removal",
		   finfo->fullname);
d176 1
a176 1
	    error (0, 0, "scheduling `%s' for removal", finfo->fullname);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d20 2
a21 4
static int remove_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static Dtype remove_dirproc PROTO ((void *callerdat, char *dir,
				    char *repos, char *update_dir,
				    List *entries));
a73 23
	/* Call expand_wild so that the local removal of files will
           work.  It's ok to do it always because we have to send the
           file names expanded anyway.  */
	expand_wild (argc, argv, &argc, &argv);
	
	if (force)
	{
	    if (!noexec)
	    {
		int i;

		for (i = 0; i < argc; i++)
		{
		    if ( CVS_UNLINK (argv[i]) < 0 && ! existence_error (errno))
		    {
			error (0, errno, "unable to remove %s", argv[i]);
		    }
		}
	    }
	    /* else FIXME should probably act as if the file doesn't exist
	       in doing the following checks.  */
	}

d78 1
a78 1
	send_file_names (argc, argv, 0);
d87 2
a88 3
                           remove_dirproc, (DIRLEAVEPROC) NULL, NULL,
			   argc, argv,
                           local, W_LOCAL, 0, 1, (char *) NULL, 1);
d109 1
a109 2
remove_fileproc (callerdat, finfo)
    void *callerdat;
d119 1
a119 1
	    if ( CVS_UNLINK (finfo->file) < 0 && ! existence_error (errno))
d128 2
a129 1
    vers = Version_TS (finfo, NULL, NULL, NULL, 0, 0);
d192 1
a192 2
remove_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a195 1
    List *entries;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d104 1
a104 1
	send_files (argc, argv, local, 0, 0);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a19 4
#ifdef CLIENT_SUPPORT
static int remove_force_fileproc PROTO ((void *callerdat,
					 struct file_info *finfo));
#endif
d85 9
a93 4
		start_recursion (remove_force_fileproc, (FILESDONEPROC) NULL,
				 (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
				 (void *) NULL, argc, argv, local, W_LOCAL,
				 0, 0, (char *) NULL, 0);
d104 1
a104 1
	send_files (argc, argv, local, 0, 0, 0);
a129 20
#ifdef CLIENT_SUPPORT

/*
 * This is called via start_recursion if we are running as the client
 * and the -f option was used.  We just physically remove the file.
 */

/*ARGSUSED*/
static int
remove_force_fileproc (callerdat, finfo)
     void *callerdat;
     struct file_info *finfo;
{
    if (CVS_UNLINK (finfo->file) < 0 && ! existence_error (errno))
	error (0, errno, "unable to remove %s", finfo->fullname);
    return 0;
}

#endif

d139 1
a170 2
	char *fname;

a175 4
	fname = xmalloc (strlen (finfo->file)
			 + sizeof (CVSADM)
			 + sizeof (CVSEXT_LOG)
			 + 10);
a184 1
	free (fname);
a193 2
	char *fname;

a194 1
	fname = xmalloc (strlen (vers->vn_user) + 5);
a206 1
	free (fname);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d54 1
a54 1
    while ((c = getopt (argc, argv, "+flR")) != -1)
d103 1
a103 2
	/* FIXME: Can't we set SEND_NO_CONTENTS here?  Needs investigation.  */
	send_files (argc, argv, local, 0, 0);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d53 1
a53 1
    optind = 0;
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a39 1
    "(Specify the --help global option for a list of other help options)\n",
a216 16
    }
    else if (vers->tag != NULL && isdigit (*vers->tag))
    {
	/* Commit will just give an error, and so there seems to be
	   little reason to allow the remove.  I mean, conflicts that
	   arise out of parallel development are one thing, but conflicts
	   that arise from sticky tags are quite another.

	   I would have thought that non-branch sticky tags should be the
	   same but at least now, removing a file with a non-branch sticky
	   tag means to delete the tag from the file.  I'm not sure that
	   is a good behavior, but until it is changed, we need to allow
	   it.  */
	error (0, 0, "\
cannot remove file `%s' which has a numeric sticky tag of `%s'",
	       finfo->fullname, vers->tag);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d103 1
a105 1
	send_file_names (argc, argv, 0);
d203 1
a203 3
	if (unlink_file (fname) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", CVSEXT_LOG);
d219 1
a219 1
    else if (vers->tag != NULL && isdigit ((unsigned char) *vers->tag))
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@a105 1
	free_names (&argc, argv);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d80 1
a80 1
    if (current_parsed_root->isremote) {
d118 1
a118 1
    if (removed_files && !really_quiet)
@


