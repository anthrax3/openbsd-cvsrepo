head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.20
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.16.0.22
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.18
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.14
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.16
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.8
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.12
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.10
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.28
	OPENBSD_5_0:1.15.0.26
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.24
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.22
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.18
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.20
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.16
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.14
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.12
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.10
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.8
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.16
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.14
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.12
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.10
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.8
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.6
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	cvs-1-11-1p1:1.1.1.14
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	cvs-1-10-7:1.1.1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	cvs-1-10-5:1.1.1.12
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	cvs-1-10:1.1.1.11
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.20.19.18.13;	author otto;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches
	1.14.12.1
	1.14.14.1
	1.14.16.1;
next	1.13;

1.13
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.21.57.58;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.03.12.07.22.38;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	98.02.22.08.56.02;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.06.28.03.45.30;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.04.21.04.41.06;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.03.18.02.09.58;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.02.21.06.54.57;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.18.04.19.38;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.05.06.22.51.17;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.20.26.21;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.09.00.01.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.19;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.07;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.49;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.45;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.41;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.17;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.34;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.50;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.23;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.55;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.02.28.21.33.10;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.02.10.18.57.43;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;

1.14.12.1
date	2005.04.23.03.00.21;	author brad;	state Exp;
branches;
next	;

1.14.14.1
date	2005.04.23.02.42.18;	author brad;	state Exp;
branches;
next	;

1.14.16.1
date	2005.05.23.06.37.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.16
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Patch
 * 
 * Create a Larry Wall format "patch" file between a previous release and the
 * current head of a module, or between two releases.  Can specify the
 * release as either a date or a revision number.
 */

#include <assert.h>
#include "cvs.h"
#include "getline.h"

static RETSIGTYPE patch_cleanup PROTO((void));
static Dtype patch_dirproc PROTO ((void *callerdat, char *dir,
				   char *repos, char *update_dir,
				   List *entries));
static int patch_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int patch_proc PROTO((int argc, char **argv, char *xwhere,
		       char *mwhere, char *mfile, int shorten,
		       int local_specified, char *mname, char *msg));

static int force_tag_match = 1;
static int patch_short = 0;
static int toptwo_diffs = 0;
static int local = 0;
static char *options = NULL;
static char *rev1 = NULL;
static int rev1_validated = 0;
static char *rev2 = NULL;
static int rev2_validated = 0;
static char *date1 = NULL;
static char *date2 = NULL;
static char *tmpfile1 = NULL;
static char *tmpfile2 = NULL;
static char *tmpfile3 = NULL;
static int unidiff = 0;

static const char *const patch_usage[] =
{
    "Usage: %s %s [-flR] [-c|-u] [-s|-t] [-V %%d]\n",
    "    -r rev|-D date [-r rev2 | -D date2] modules...\n",
    "\t-f\tForce a head revision match if tag/date not found.\n",
    "\t-l\tLocal directory only, not recursive\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-c\tContext diffs (default)\n",
    "\t-u\tUnidiff format.\n",
    "\t-s\tShort patch - one liner per file.\n",
    "\t-t\tTop two diffs - last change made to the file.\n",
    "\t-D date\tDate.\n",
    "\t-r rev\tRevision - symbolic or numeric.\n",
    "\t-V vers\tUse RCS Version \"vers\" for keyword expansion.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

int
patch (argc, argv)
    int argc;
    char **argv;
{
    register int i;
    int c;
    int err = 0;
    DBM *db;

    if (argc == -1)
	usage (patch_usage);

    optind = 0;
    while ((c = getopt (argc, argv, "+V:k:cuftsQqlRD:r:")) != -1)
    {
	switch (c)
	{
	    case 'Q':
	    case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
#endif
		    error (1, 0,
			   "-q or -Q must be specified before \"%s\"",
			   command_name);
		break;
	    case 'f':
		force_tag_match = 0;
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 't':
		toptwo_diffs = 1;
		break;
	    case 's':
		patch_short = 1;
		break;
	    case 'D':
		if (rev2 != NULL || date2 != NULL)
		    error (1, 0,
		       "no more than two revisions/dates can be specified");
		if (rev1 != NULL || date1 != NULL)
		    date2 = Make_Date (optarg);
		else
		    date1 = Make_Date (optarg);
		break;
	    case 'r':
		if (rev2 != NULL || date2 != NULL)
		    error (1, 0,
		       "no more than two revisions/dates can be specified");
		if (rev1 != NULL || date1 != NULL)
		    rev2 = optarg;
		else
		    rev1 = optarg;
		break;
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;
	    case 'V':
		/* This option is pretty seriously broken:
		   1.  It is not clear what it does (does it change keyword
		   expansion behavior?  If so, how?  Or does it have
		   something to do with what version of RCS we are using?
		   Or the format we write RCS files in?).
		   2.  Because both it and -k use the options variable,
		   specifying both -V and -k doesn't work.
		   3.  At least as of CVS 1.9, it doesn't work (failed
		   assertion in RCS_checkout where it asserts that options
		   starts with -k).  Few people seem to be complaining.
		   In the future (perhaps the near future), I have in mind
		   removing it entirely, and updating NEWS and cvs.texinfo,
		   but in case it is a good idea to give people more time
		   to complain if they would miss it, I'll just add this
		   quick and dirty error message for now.  */
		error (1, 0,
		       "the -V option is obsolete and should not be used");
#if 0
		if (atoi (optarg) <= 0)
		    error (1, 0, "must specify a version number to -V");
		if (options)
		    free (options);
		options = xmalloc (strlen (optarg) + 1 + 2);	/* for the -V */
		(void) sprintf (options, "-V%s", optarg);
#endif
		break;
	    case 'u':
		unidiff = 1;		/* Unidiff */
		break;
	    case 'c':			/* Context diff */
		unidiff = 0;
		break;
	    case '?':
	    default:
		usage (patch_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    /* Sanity checks */
    if (argc < 1)
	usage (patch_usage);

    if (toptwo_diffs && patch_short)
	error (1, 0, "-t and -s options are mutually exclusive");
    if (toptwo_diffs && (date1 != NULL || date2 != NULL ||
			 rev1 != NULL || rev2 != NULL))
	error (1, 0, "must not specify revisions/dates with -t option!");

    if (!toptwo_diffs && (date1 == NULL && date2 == NULL &&
			  rev1 == NULL && rev2 == NULL))
	error (1, 0, "must specify at least one revision/date!");
    if (date1 != NULL && date2 != NULL)
	if (RCS_datecmp (date1, date2) >= 0)
	    error (1, 0, "second date must come after first date!");

    /* if options is NULL, make it a NULL string */
    if (options == NULL)
	options = xstrdup ("");

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	/* We're the client side.  Fire up the remote server.  */
	start_server ();
	
	ign_setup ();

	if (local)
	    send_arg("-l");
	if (!force_tag_match)
	    send_arg("-f");
	if (toptwo_diffs)
	    send_arg("-t");
	if (patch_short)
	    send_arg("-s");
	if (unidiff)
	    send_arg("-u");

	if (rev1)
	    option_with_arg ("-r", rev1);
	if (date1)
	    client_senddate (date1);
	if (rev2)
	    option_with_arg ("-r", rev2);
	if (date2)
	    client_senddate (date2);
	if (options[0] != '\0')
	    send_arg (options);

	{
	    int i;
	    for (i = 0; i < argc; ++i)
		send_arg (argv[i]);
	}

	send_to_server ("rdiff\012", 0);
        return get_responses_and_close ();
    }
#endif

    /* clean up if we get a signal */
#ifdef SIGABRT
    (void) SIG_register (SIGABRT, patch_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_register (SIGHUP, patch_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_register (SIGINT, patch_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_register (SIGQUIT, patch_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_register (SIGPIPE, patch_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_register (SIGTERM, patch_cleanup);
#endif

    db = open_module ();
    for (i = 0; i < argc; i++)
	err += do_module (db, argv[i], PATCH, "Patching", patch_proc,
			  (char *) NULL, 0, 0, 0, 0, (char *) NULL);
    close_module (db);
    free (options);
    patch_cleanup ();
    return (err);
}

/*
 * callback proc for doing the real work of patching
 */
/* ARGSUSED */
static int
patch_proc (argc, argv, xwhere, mwhere, mfile, shorten, local_specified,
	    mname, msg)
    int argc;
    char **argv;
    char *xwhere;
    char *mwhere;
    char *mfile;
    int shorten;
    int local_specified;
    char *mname;
    char *msg;
{
    char *myargv[2];
    int err = 0;
    int which;
    char *repository;
    char *where;

    repository = xmalloc (strlen (current_parsed_root->directory) + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile) + 1) + 2);
    (void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
    where = xmalloc (strlen (argv[0]) + (mfile == NULL ? 0 : strlen (mfile) + 1)
		     + 1);
    (void) strcpy (where, argv[0]);

    /* if mfile isn't null, we need to set up to do only part of the module */
    if (mfile != NULL)
    {
	char *cp;
	char *path;

	/* if the portion of the module is a path, put the dir part on repos */
	if ((cp = strrchr (mfile, '/')) != NULL)
	{
	    *cp = '\0';
	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	    mfile = cp + 1;
	}

	/* take care of the rest */
	path = xmalloc (strlen (repository) + strlen (mfile) + 2);
	(void) sprintf (path, "%s/%s", repository, mfile);
	if (isdir (path))
	{
	    /* directory means repository gets the dir tacked on */
	    (void) strcpy (repository, path);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	}
	else
	{
	    myargv[0] = argv[0];
	    myargv[1] = mfile;
	    argc = 2;
	    argv = myargv;
	}
	free (path);
    }

    /* cd to the starting repository */
    if ( CVS_CHDIR (repository) < 0)
    {
	error (0, errno, "cannot chdir to %s", repository);
	free (repository);
	return (1);
    }
    free (repository);

    if (force_tag_match)
	which = W_REPOS | W_ATTIC;
    else
	which = W_REPOS;

    if (rev1 != NULL && !rev1_validated)
    {
	tag_check_valid (rev1, argc - 1, argv + 1, local, 0, NULL);
	rev1_validated = 1;
    }
    if (rev2 != NULL && !rev2_validated)
    {
	tag_check_valid (rev2, argc - 1, argv + 1, local, 0, NULL);
	rev2_validated = 1;
    }

    /* start the recursion processor */
    err = start_recursion (patch_fileproc, (FILESDONEPROC) NULL, patch_dirproc,
			   (DIRLEAVEPROC) NULL, NULL,
			   argc - 1, argv + 1, local,
			   which, 0, 1, where, 1);
    free (where);

    return (err);
}

/*
 * Called to examine a particular RCS file, as appropriate with the options
 * that were set above.
 */
/* ARGSUSED */
static int
patch_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    struct utimbuf t;
    char *vers_tag, *vers_head;
    char *rcs = NULL;
    char *rcs_orig = NULL;
    RCSNode *rcsfile;
    FILE *fp1, *fp2, *fp3;
    int ret = 0;
    int isattic = 0;
    int retcode = 0;
    char *file1;
    char *file2;
    char *strippath;
    char *line1, *line2;
    size_t line1_chars_allocated;
    size_t line2_chars_allocated;
    char *cp1, *cp2;
    FILE *fp;
    int line_length;

    line1 = NULL;
    line1_chars_allocated = 0;
    line2 = NULL;
    line2_chars_allocated = 0;

    /* find the parsed rcs file */
    if ((rcsfile = finfo->rcs) == NULL)
    {
	ret = 1;
	goto out2;
    }
    if ((rcsfile->flags & VALID) && (rcsfile->flags & INATTIC))
	isattic = 1;

    rcs_orig = rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
    (void) sprintf (rcs, "%s%s", finfo->file, RCSEXT);

    /* if vers_head is NULL, may have been removed from the release */
    if (isattic && rev2 == NULL && date2 == NULL)
	vers_head = NULL;
    else
    {
	vers_head = RCS_getversion (rcsfile, rev2, date2, force_tag_match,
				    (int *) NULL);
	if (vers_head != NULL && RCS_isdead (rcsfile, vers_head))
	{
	    free (vers_head);
	    vers_head = NULL;
	}
    }

    if (toptwo_diffs)
    {
	if (vers_head == NULL)
	{
	    ret = 1;
	    goto out2;
	}

	if (!date1)
	    date1 = xmalloc (MAXDATELEN);
	*date1 = '\0';
	if (RCS_getrevtime (rcsfile, vers_head, date1, 1) == -1)
	{
	    if (!really_quiet)
		error (0, 0, "cannot find date in rcs file %s revision %s",
		       rcs, vers_head);
	    ret = 1;
	    goto out2;
	}
    }
    vers_tag = RCS_getversion (rcsfile, rev1, date1, force_tag_match,
			       (int *) NULL);
    if (vers_tag != NULL && RCS_isdead (rcsfile, vers_tag))
    {
        free (vers_tag);
	vers_tag = NULL;
    }

    if (vers_tag == NULL && vers_head == NULL)
    {
	/* Nothing known about specified revs.  */
	ret = 0;
	goto out2;
    }

    if (vers_tag && vers_head && strcmp (vers_head, vers_tag) == 0)
    {
	/* Not changed between releases.  */
	ret = 0;
	goto out2;
    }

    if (patch_short)
    {
	cvs_output ("File ", 0);
	cvs_output (finfo->fullname, 0);
	if (vers_tag == NULL)
	{
	    cvs_output (" is new; current revision ", 0);
	    cvs_output (vers_head, 0);
	    cvs_output ("\n", 1);
	}
	else if (vers_head == NULL)
	{
	    cvs_output (" is removed; not included in ", 0);
	    if (rev2 != NULL)
	    {
		cvs_output ("release tag ", 0);
		cvs_output (rev2, 0);
	    }
	    else if (date2 != NULL)
	    {
		cvs_output ("release date ", 0);
		cvs_output (date2, 0);
	    }
	    else
		cvs_output ("current release", 0);
	    cvs_output ("\n", 1);
	}
	else
	{
	    cvs_output (" changed from revision ", 0);
	    cvs_output (vers_tag, 0);
	    cvs_output (" to ", 0);
	    cvs_output (vers_head, 0);
	    cvs_output ("\n", 1);
	}
	ret = 0;
	goto out2;
    }

    /* Create 3 empty files.  I'm not really sure there is any advantage
     * to doing so now rather than just waiting until later.
     *
     * There is - cvs_temp_file opens the file so that it can guarantee that
     * we have exclusive write access to the file.  Unfortunately we spoil that
     * by closing it and reopening it again.  Of course any better solution
     * requires that the RCS functions accept open file pointers rather than
     * simple file names.
     */
    if ((fp1 = cvs_temp_file (&tmpfile1)) == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile1);
	ret = 1;
	goto out;
    }
    else
	if (fclose (fp1) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile1);
    if ((fp2 = cvs_temp_file (&tmpfile2)) == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile2);
	ret = 1;
	goto out;
    }
    else
	if (fclose (fp2) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile2);
    if ((fp3 = cvs_temp_file (&tmpfile3)) == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile3);
	ret = 1;
	goto out;
    }
    else
	if (fclose (fp3) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile3);

    if (vers_tag != NULL)
    {
	retcode = RCS_checkout (rcsfile, (char *) NULL, vers_tag,
				rev1, options, tmpfile1,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
	if (retcode != 0)
	{
	    error (0, 0,
		   "cannot check out revision %s of %s", vers_tag, rcs);
	    ret = 1;
	    goto out;
	}
	memset ((char *) &t, 0, sizeof (t));
	if ((t.actime = t.modtime = RCS_getrevtime (rcsfile, vers_tag,
						    (char *) 0, 0)) != -1)
	    /* I believe this timestamp only affects the dates in our diffs,
	       and therefore should be on the server, not the client.  */
	    (void) utime (tmpfile1, &t);
    }
    else if (toptwo_diffs)
    {
	ret = 1;
	goto out;
    }
    if (vers_head != NULL)
    {
	retcode = RCS_checkout (rcsfile, (char *) NULL, vers_head,
				rev2, options, tmpfile2,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
	if (retcode != 0)
	{
	    error (0, 0,
		   "cannot check out revision %s of %s", vers_head, rcs);
	    ret = 1;
	    goto out;
	}
	if ((t.actime = t.modtime = RCS_getrevtime (rcsfile, vers_head,
						    (char *) 0, 0)) != -1)
	    /* I believe this timestamp only affects the dates in our diffs,
	       and therefore should be on the server, not the client.  */
	    (void) utime (tmpfile2, &t);
    }

    switch (diff_exec (tmpfile1, tmpfile2, NULL, NULL, unidiff ? "-u" : "-c", tmpfile3))
    {
	case -1:			/* fork/wait failure */
	    error (1, errno, "fork for diff failed on %s", rcs);
	    break;
	case 0:				/* nothing to do */
	    break;
	case 1:
	    /*
	     * The two revisions are really different, so read the first two
	     * lines of the diff output file, and munge them to include more
	     * reasonable file names that "patch" will understand.
	     */

	    /* Output an "Index:" line for patch to use */
	    cvs_output ("Index: ", 0);
	    cvs_output (finfo->fullname, 0);
	    cvs_output ("\n", 1);

	    fp = open_file (tmpfile3, "r");
	    if (get_line (&line1, &line1_chars_allocated, fp) < 0 ||
		get_line (&line2, &line2_chars_allocated, fp) < 0)
	    {
		if (feof (fp))
		    error (0, 0, "\
failed to read diff file header %s for %s: end of file", tmpfile3, rcs);
		else
		    error (0, errno,
			   "failed to read diff file header %s for %s",
			   tmpfile3, rcs);
		ret = 1;
		if (fclose (fp) < 0)
		    error (0, errno, "error closing %s", tmpfile3);
		goto out;
	    }
	    if (!unidiff)
	    {
		if (strncmp (line1, "*** ", 4) != 0 ||
		    strncmp (line2, "--- ", 4) != 0 ||
		    (cp1 = strchr (line1, '\t')) == NULL ||
		    (cp2 = strchr (line2, '\t')) == NULL)
		{
		    error (0, 0, "invalid diff header for %s", rcs);
		    ret = 1;
		    if (fclose (fp) < 0)
			error (0, errno, "error closing %s", tmpfile3);
		    goto out;
		}
	    }
	    else
	    {
		if (strncmp (line1, "--- ", 4) != 0 ||
		    strncmp (line2, "+++ ", 4) != 0 ||
		    (cp1 = strchr (line1, '\t')) == NULL ||
		    (cp2 = strchr  (line2, '\t')) == NULL)
		{
		    error (0, 0, "invalid unidiff header for %s", rcs);
		    ret = 1;
		    if (fclose (fp) < 0)
			error (0, errno, "error closing %s", tmpfile3);
		    goto out;
		}
	    }
	    assert (current_parsed_root != NULL);
	    assert (current_parsed_root->directory != NULL);
	    {
		strippath = xmalloc (strlen (current_parsed_root->directory) + 2);
		(void) sprintf (strippath, "%s/", current_parsed_root->directory);
	    }
	    /*else
		strippath = xstrdup (REPOS_STRIP); */
	    if (strncmp (rcs, strippath, strlen (strippath)) == 0)
		rcs += strlen (strippath);
	    free (strippath);
	    if (vers_tag != NULL)
	    {
		file1 = xmalloc (strlen (finfo->fullname)
				 + strlen (vers_tag)
				 + 10);
		(void) sprintf (file1, "%s:%s", finfo->fullname, vers_tag);
	    }
	    else
	    {
		file1 = xstrdup (DEVNULL);
	    }
	    file2 = xmalloc (strlen (finfo->fullname)
			     + (vers_head != NULL ? strlen (vers_head) : 10)
			     + 10);
	    (void) sprintf (file2, "%s:%s", finfo->fullname,
			    vers_head ? vers_head : "removed");

	    /* Note that the string "diff" is specified by POSIX (for -c)
	       and is part of the diff output format, not the name of a
	       program.  */
	    if (unidiff)
	    {
		cvs_output ("diff -u ", 0);
		cvs_output (file1, 0);
		cvs_output (" ", 1);
		cvs_output (file2, 0);
		cvs_output ("\n", 1);

		cvs_output ("--- ", 0);
		cvs_output (file1, 0);
		cvs_output (cp1, 0);
		cvs_output ("+++ ", 0);
	    }
	    else
	    {
		cvs_output ("diff -c ", 0);
		cvs_output (file1, 0);
		cvs_output (" ", 1);
		cvs_output (file2, 0);
		cvs_output ("\n", 1);

		cvs_output ("*** ", 0);
		cvs_output (file1, 0);
		cvs_output (cp1, 0);
		cvs_output ("--- ", 0);
	    }

	    cvs_output (finfo->fullname, 0);
	    cvs_output (cp2, 0);

	    /* spew the rest of the diff out */
	    while ((line_length
		    = get_line (&line1, &line1_chars_allocated, fp))
		   >= 0)
		cvs_output (line1, 0);
	    if (line_length < 0 && !feof (fp))
		error (0, errno, "cannot read %s", tmpfile3);

	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", tmpfile3);
	    free (file1);
	    free (file2);
	    break;
	default:
	    error (0, 0, "diff failed for %s", finfo->fullname);
    }
  out:
    if (line1)
        free (line1);
    if (line2)
        free (line2);
    if (CVS_UNLINK (tmpfile1) < 0)
	error (0, errno, "cannot unlink %s", tmpfile1);
    if (CVS_UNLINK (tmpfile2) < 0)
	error (0, errno, "cannot unlink %s", tmpfile2);
    if (CVS_UNLINK (tmpfile3) < 0)
	error (0, errno, "cannot unlink %s", tmpfile3);
    free (tmpfile1);
    free (tmpfile2);
    free (tmpfile3);
    tmpfile1 = tmpfile2 = tmpfile3 = NULL;

 out2:
    if (vers_tag != NULL)
	free (vers_tag);
    if (vers_head != NULL)
	free (vers_head);
    if (rcs_orig)
	free (rcs_orig);
    return (ret);
}

/*
 * Print a warm fuzzy message
 */
/* ARGSUSED */
static Dtype
patch_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *repos;
    char *update_dir;
    List *entries;
{
    if (!quiet)
	error (0, 0, "Diffing %s", update_dir);
    return (R_PROCESS);
}

/*
 * Clean up temporary files
 */
static RETSIGTYPE
patch_cleanup ()
{
    /* Note that the checks for existence_error are because we are
       called from a signal handler, without SIG_begincrsect, so
       we don't know whether the files got created.  */

    if (tmpfile1 != NULL)
    {
	if (unlink_file (tmpfile1) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile1);
	free (tmpfile1);
    }
    if (tmpfile2 != NULL)
    {
	if (unlink_file (tmpfile2) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile2);
	free (tmpfile2);
    }
    if (tmpfile3 != NULL)
    {
	if (unlink_file (tmpfile3) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile3);
	free (tmpfile3);
    }
    tmpfile1 = tmpfile2 = tmpfile3 = NULL;
}
@


1.15
log
@Fixes from Derek Price, CAN-2005-0753. ok deraadt@@
@
text
@d606 2
a607 2
	    if (getline (&line1, &line1_chars_allocated, fp) < 0 ||
		getline (&line2, &line2_chars_allocated, fp) < 0)
d712 1
a712 1
		    = getline (&line1, &line1_chars_allocated, fp))
@


1.14
log
@Merge local changes; work in progress
@
text
@d378 1
d408 1
a408 1
    rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
d747 2
a748 2
    if (rcs != NULL)
	free (rcs);
@


1.14.16.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@a377 1
    char *rcs_orig = NULL;
d407 1
a407 1
    rcs_orig = rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
d746 2
a747 2
    if (rcs_orig)
	free (rcs_orig);
@


1.14.12.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@a377 1
    char *rcs_orig = NULL;
d407 1
a407 1
    rcs_orig = rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
d746 2
a747 2
    if (rcs_orig)
	free (rcs_orig);
@


1.14.14.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@a377 1
    char *rcs_orig = NULL;
d407 1
a407 1
    rcs_orig = rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
d746 2
a747 2
    if (rcs_orig)
	free (rcs_orig);
@


1.13
log
@Integrate local changes
@
text
@d15 1
d193 1
a193 1
    if (client_active)
d256 1
a256 1
			  (char *) NULL, 0, 0, 0, (char *) NULL);
d286 5
a290 5
    repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile)) + 30);
    (void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
    where = xmalloc (strlen (argv[0]) + (mfile == NULL ? 0 : strlen (mfile))
		     + 10);
d311 1
a311 1
	path = xmalloc (strlen (repository) + strlen (mfile) + 5);
d506 9
a514 4
       to doing so now rather than just waiting until later.  */
    tmpfile1 = cvs_temp_name ();
    fp1 = CVS_FOPEN (tmpfile1, "w+");
    if (fp1 == NULL)
d523 1
a523 3
    tmpfile2 = cvs_temp_name ();
    fp2 = CVS_FOPEN (tmpfile2, "w+");
    if (fp2 == NULL)
d532 1
a532 3
    tmpfile3 = cvs_temp_name ();
    fp3 = CVS_FOPEN (tmpfile3, "w+");
    if (fp3 == NULL)
d585 1
a585 1
    switch (diff_exec (tmpfile1, tmpfile2, unidiff ? "-u" : "-c", tmpfile3))
d648 2
a649 1
	    if (CVSroot_directory != NULL)
d651 2
a652 2
		strippath = xmalloc (strlen (CVSroot_directory) + 10);
		(void) sprintf (strippath, "%s/", CVSroot_directory);
d654 2
a655 2
	    else
		strippath = xstrdup (REPOS_STRIP);
@


1.12
log
@Integrate local changes
@
text
@d23 1
a23 1
static int patch_proc PROTO((int *pargc, char **argv, char *xwhere,
d233 3
d267 1
a267 1
patch_proc (pargc, argv, xwhere, mwhere, mfile, shorten, local_specified,
d269 1
a269 1
    int *pargc;
d279 1
d321 4
a324 7
	    int i;

	    /* a file means muck argv */
	    for (i = 1; i < *pargc; i++)
		free (argv[i]);
	    argv[1] = xstrdup (mfile);
	    (*pargc) = 2;
d345 1
a345 1
	tag_check_valid (rev1, *pargc - 1, argv + 1, local, 0, NULL);
d350 1
a350 1
	tag_check_valid (rev2, *pargc - 1, argv + 1, local, 0, NULL);
d357 1
a357 1
			   *pargc - 1, argv + 1, local,
d739 4
@


1.11
log
@Integrate local changes
@
text
@d766 4
d772 3
a774 1
	(void) unlink_file (tmpfile1);
d779 3
a781 1
	(void) unlink_file (tmpfile2);
d786 3
a788 1
	(void) unlink_file (tmpfile3);
@


1.10
log
@Integrate local changes
@
text
@d502 3
d506 10
a515 2
    if ((fp1 = CVS_FOPEN (tmpfile1, "w+")) != NULL)
	(void) fclose (fp1);
d517 10
a526 2
    if ((fp2 = CVS_FOPEN (tmpfile2, "w+")) != NULL)
	(void) fclose (fp2);
d528 4
a531 7
    if ((fp3 = CVS_FOPEN (tmpfile3, "w+")) != NULL)
	(void) fclose (fp3);
    if (fp1 == NULL || fp2 == NULL || fp3 == NULL)
    {
	/* FIXME: should be printing a proper error message, with errno-based
	   message, and the filename which we could not create.  */
	error (0, 0, "cannot create temporary files");
d535 4
d546 2
a547 3
	    if (!really_quiet)
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "co of revision %s in %s failed", vers_tag, rcs);
d570 2
a571 3
	    if (!really_quiet)
		error (retcode == -1 ? 1 : 0, retcode == -1 ? errno : 0,
		       "co of revision %s in %s failed", vers_head, rcs);
d605 7
a611 2
		error (0, errno, "failed to read diff file header %s for %s",
		       tmpfile3, rcs);
d613 2
a614 1
		(void) fclose (fp);
d626 2
a627 1
		    (void) fclose (fp);
d640 2
a641 1
		    (void) fclose (fp);
@


1.9
log
@Integrate local changes
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d57 1
d389 1
d466 2
a467 1
	(void) printf ("File %s ", finfo->fullname);
d469 5
a473 1
	    (void) printf ("is new; current revision %s\n", vers_head);
d476 1
a476 1
	    (void) printf ("is removed; not included in ");
d478 4
a481 1
		(void) printf ("release tag %s", rev2);
d483 4
a486 1
		(void) printf ("release date %s", date2);
d488 2
a489 2
		(void) printf ("current release");
	    (void) printf ("\n");
d492 7
a498 2
	    (void) printf ("changed from revision %s to %s\n",
			   vers_tag, vers_head);
a562 3
    run_setup ("%s -%c", DIFF, unidiff ? 'u' : 'c');
    run_arg (tmpfile1);
    run_arg (tmpfile2);
d564 1
a564 1
    switch (run_exec (RUN_TTY, tmpfile3, RUN_TTY, RUN_REALLY))
d579 3
a581 3
	    (void) fflush (stdout);
	    (void) printf ("Index: %s\n", finfo->fullname);
	    (void) fflush (stdout);
d646 3
a648 3
	    /* Note that this prints "diff" not DIFF.  The format of a diff
	       does not depend on the name of the program which happens to
	       have produced it.  */
d651 10
a660 2
		(void) printf ("diff -u %s %s\n", file1, file2);
		(void) printf ("--- %s%s+++ ", file1, cp1);
d664 10
a673 2
		(void) printf ("diff -c %s %s\n", file1, file2);
		(void) printf ("*** %s%s--- ", file1, cp1);
d676 3
a678 1
	    (void) printf ("%s%s", finfo->fullname, cp2);
d680 9
a688 3
	    while (getline (&line1, &line1_chars_allocated, fp) >= 0)
		(void) fputs (line1, stdout);
	    (void) fclose (fp);
d700 6
a705 4
    /* FIXME: should be checking for errors.  */
    (void) CVS_UNLINK (tmpfile1);
    (void) CVS_UNLINK (tmpfile2);
    (void) CVS_UNLINK (tmpfile3);
@


1.8
log
@Integrate local changes
@
text
@d45 1
a45 1
    "Usage: %s %s [-fl] [-c|-u] [-s|-t] [-V %%d]\n",
d49 1
d73 1
a73 1
    optind = 1;
d517 3
a519 1
		(void) utime (tmpfile1, &t);
d541 3
a543 1
		(void) utime (tmpfile2, &t);
@


1.7
log
@Integrate local changes
@
text
@d73 1
a73 1
    while ((c = getopt (argc, argv, "V:k:cuftsQqlRD:r:")) != -1)
d503 2
a504 1
				rev1, options, tmpfile1);
d526 2
a527 1
				rev2, options, tmpfile2);
@


1.6
log
@Integrate local changes
@
text
@d127 18
d151 1
a260 1
static char where[PATH_MAX];
d276 2
a277 1
    char repository[PATH_MAX];
d279 2
d282 2
d290 1
a290 1
	char path[PATH_MAX];
d304 1
d323 1
d330 1
d333 1
d356 1
d373 1
a373 2
    char rcsspace[1][PATH_MAX];
    char *rcs = rcsspace[0];
d379 3
a381 1
    char file1[PATH_MAX], file2[PATH_MAX], strippath[PATH_MAX];
d395 4
a398 1
	return (1);
d402 1
d422 4
a425 1
	    return (1);
d428 1
a428 1
	    date1 = xmalloc (50);	/* plenty big :-) */
d435 2
a436 1
	    return (1);
d448 5
a452 1
	return (0);			/* nothing known about specified revs */
d455 5
a459 1
	return (0);			/* not changed between releases */
d480 2
a481 1
	return (0);
d598 2
d601 1
d603 1
a603 1
		(void) strcpy (strippath, REPOS_STRIP);
d606 1
d609 3
d616 1
a616 1
		(void) strcpy (file1, DEVNULL);
d618 3
d643 2
d662 4
@


1.5
log
@Integrate local changes
@
text
@d359 5
d457 1
a457 1
				(char *) NULL, options, tmpfile1);
d479 1
a479 1
				(char *) NULL, options, tmpfile2);
a494 5

    line1 = NULL;
    line1_chars_allocated = 0;
    line2 = NULL;
    line2_chars_allocated = 0;
@


1.4
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d19 4
a22 2
static Dtype patch_dirproc PROTO((char *dir, char *repos, char *update_dir));
static int patch_fileproc PROTO((struct file_info *finfo));
d33 1
a33 1
static int rev1_validated = 1;
d35 1
a35 1
static int rev2_validated = 1;
d38 3
a40 1
static char tmpfile1[L_tmpnam+1], tmpfile2[L_tmpnam+1], tmpfile3[L_tmpnam+1];
d260 1
a260 1
    (void) sprintf (repository, "%s/%s", CVSroot, argv[0]);
d302 1
a302 1
    if (chdir (repository) < 0)
d326 3
a328 2
			   (DIRLEAVEPROC) NULL, *pargc - 1, argv + 1, local,
			   which, 0, 1, where, 1, 1);
d339 2
a340 1
patch_fileproc (finfo)
d371 9
a379 1
	vers_head = RCS_getversion (rcsfile, rev2, date2, force_tag_match, 0);
d397 7
a403 1
    vers_tag = RCS_getversion (rcsfile, rev1, date1, force_tag_match, 0);
d405 1
a405 1
    if (vers_tag == NULL && (vers_head == NULL || isattic))
d432 2
a433 1
    if ((fp1 = fopen (tmpnam (tmpfile1), "w+")) != NULL)
d435 2
a436 1
    if ((fp2 = fopen (tmpnam (tmpfile2), "w+")) != NULL)
d438 2
a439 1
    if ((fp3 = fopen (tmpnam (tmpfile3), "w+")) != NULL)
d443 2
d451 2
a452 2
	retcode = RCS_checkout (rcsfile->path, NULL, vers_tag, options, tmpfile1,
	                        0, 0);
d473 2
a474 1
	retcode = RCS_checkout (rcsfile->path, NULL, vers_head, options, tmpfile2, 0, 0);
d551 2
a552 2
	    if (CVSroot != NULL)
		(void) sprintf (strippath, "%s/", CVSroot);
d597 7
a603 3
    (void) unlink (tmpfile1);
    (void) unlink (tmpfile2);
    (void) unlink (tmpfile3);
d612 2
a613 1
patch_dirproc (dir, repos, update_dir)
d617 1
d630 2
a631 1
    if (tmpfile1[0] != '\0')
d633 4
a636 1
    if (tmpfile2[0] != '\0')
d638 4
a641 1
    if (tmpfile3[0] != '\0')
d643 3
@


1.3
log
@Integrate local changes to CVS
@
text
@d339 2
a340 3
    char rcsspace[PATH_MAX];
    char *rcs = rcsspace;
    Node *p;
d350 1
a350 1
    char *cp1, *cp2, *commap;
d354 1
a354 2
    p = findnode (finfo->srcfiles, finfo->file);
    if (p == NULL)
a355 1
    rcsfile = (RCSNode *) p->data;
d393 1
a393 1
	(void) printf ("File ");
d395 1
a395 1
	    (void) printf ("%s is new; current revision %s\n", rcs, vers_head);
d398 1
a398 1
	    (void) printf ("%s is removed; not included in ", rcs);
d408 2
a409 2
	    (void) printf ("%s changed from revision %s to %s\n",
			   rcs, vers_tag, vers_head);
d486 1
a486 4
	    if (finfo->update_dir[0])
	      (void) printf ("Index: %s/%s\n", finfo->update_dir, finfo->file);
	    else
	      (void) printf ("Index: %s\n", finfo->file);
a530 2
	    commap = strrchr (rcs, ',');
	    *commap = '\0';
d533 1
a533 2
		(void) sprintf (file1, "%s%s%s:%s", finfo->update_dir,
				finfo->update_dir[0] ? "/" : "", rcs, vers_tag);
d539 1
a539 2
	    (void) sprintf (file2, "%s%s%s:%s", finfo->update_dir,
			    finfo->update_dir[0] ? "/" : "", rcs,
d541 4
d556 1
a556 3
	    if (finfo->update_dir[0] != '\0')
		(void) printf ("%s/", finfo->update_dir);
	    (void) printf ("%s%s", rcs, cp2);
d563 1
a563 1
	    error (0, 0, "diff failed for %s", rcs);
@


1.2
log
@-f state was negated in remote operation
@
text
@a17 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)patch.c 1.57 94/09/30 $";
USE(rcsid);
#endif

d20 1
a20 2
static int patch_fileproc PROTO((char *file, char *update_dir, char *repository,
			   List * entries, List * srcfiles));
d334 2
a335 6
patch_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d355 1
a355 1
    p = findnode (srcfiles, file);
d362 1
a362 1
    (void) sprintf (rcs, "%s%s", file, RCSEXT);
a399 1
#ifdef DEATH_SUPPORT
a409 4
#else
	    (void) printf ("%s is removed; not included in release %s\n",
			   rcs, rev2 ? rev2 : date2);
#endif
d429 3
a431 3
	run_setup ("%s%s %s -p -q -r%s", Rcsbin, RCS_CO, options, vers_tag);
	run_arg (rcsfile->path);
	if ((retcode = run_exec (RUN_TTY, tmpfile1, RUN_TTY, RUN_NORMAL)) != 0)
d451 2
a452 3
	run_setup ("%s%s %s -p -q -r%s", Rcsbin, RCS_CO, options, vers_head);
	run_arg (rcsfile->path);
	if ((retcode = run_exec (RUN_TTY, tmpfile2, RUN_TTY, RUN_NORMAL)) != 0)
d473 1
a473 1
    switch (run_exec (RUN_TTY, tmpfile3, RUN_TTY, RUN_NORMAL))
d489 2
a490 2
	    if (update_dir[0])
	      (void) printf ("Index: %s/%s\n", update_dir, file);
d492 1
a492 1
	      (void) printf ("Index: %s\n", file);
d541 2
a542 2
		(void) sprintf (file1, "%s%s%s:%s", update_dir,
				update_dir[0] ? "/" : "", rcs, vers_tag);
d548 2
a549 2
	    (void) sprintf (file2, "%s%s%s:%s", update_dir,
			    update_dir[0] ? "/" : "", rcs,
d562 2
a563 2
	    if (update_dir[0] != '\0')
		(void) printf ("%s/", update_dir);
d578 4
a581 3
    (void) unlink_file (tmpfile1);
    (void) unlink_file (tmpfile2);
    (void) unlink_file (tmpfile3);
@


1.1
log
@Initial revision
@
text
@d16 1
d37 1
d39 1
d182 1
a182 1
	if (force_tag_match)
d208 1
a208 2
	if (fprintf (to_server, "rdiff\n") < 0)
	    error (1, errno, "writing to server");
d315 11
d327 2
a328 2
    err = start_recursion (patch_fileproc, (int (*) ()) NULL, patch_dirproc,
			   (int (*) ()) NULL, *pargc - 1, argv + 1, local,
d358 3
a360 1
    char line1[MAXLINELEN], line2[MAXLINELEN];
d378 1
a378 1
	vers_head = RCS_getversion (rcsfile, rev2, date2, force_tag_match);
d396 1
a396 1
    vers_tag = RCS_getversion (rcsfile, rev1, date1, force_tag_match);
d483 6
d512 2
a513 2
	    if (fgets (line1, sizeof (line1), fp) == NULL ||
		fgets (line2, sizeof (line2), fp) == NULL)
d581 3
a583 2
	    while (fgets (line1, sizeof (line1), fp) != NULL)
		(void) printf ("%s", line1);
d590 4
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a15 1
#include "getline.h"
a35 1
static int rev1_validated = 1;
a36 1
static int rev2_validated = 1;
d205 2
a206 1
	send_to_server ("rdiff\012", 0);
a312 11
    if (rev1 != NULL && !rev1_validated)
    {
	tag_check_valid (rev1, *pargc - 1, argv + 1, local, 0, NULL);
	rev1_validated = 1;
    }
    if (rev2 != NULL && !rev2_validated)
    {
	tag_check_valid (rev2, *pargc - 1, argv + 1, local, 0, NULL);
	rev2_validated = 1;
    }

d314 2
a315 2
    err = start_recursion (patch_fileproc, (FILESDONEPROC) NULL, patch_dirproc,
			   (DIRLEAVEPROC) NULL, *pargc - 1, argv + 1, local,
d345 1
a345 3
    char *line1, *line2;
    size_t line1_chars_allocated;
    size_t line2_chars_allocated;
d363 1
a363 1
	vers_head = RCS_getversion (rcsfile, rev2, date2, force_tag_match, 0);
d381 1
a381 1
    vers_tag = RCS_getversion (rcsfile, rev1, date1, force_tag_match, 0);
a467 6

    line1 = NULL;
    line1_chars_allocated = 0;
    line2 = NULL;
    line2_chars_allocated = 0;

d491 2
a492 2
	    if (getline (&line1, &line1_chars_allocated, fp) < 0 ||
		getline (&line2, &line2_chars_allocated, fp) < 0)
d560 2
a561 3
	    /* spew the rest of the diff out */
	    while (getline (&line1, &line1_chars_allocated, fp) >= 0)
		(void) fputs (line1, stdout);
a567 4
    if (line1)
        free (line1);
    if (line2)
        free (line2);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d18 5
d25 2
a26 1
static int patch_fileproc PROTO((struct file_info *finfo));
d340 6
a345 2
patch_fileproc (finfo)
    struct file_info *finfo;
d365 1
a365 1
    p = findnode (finfo->srcfiles, finfo->file);
d372 1
a372 1
    (void) sprintf (rcs, "%s%s", finfo->file, RCSEXT);
d410 1
d421 4
d444 3
a446 3
	retcode = RCS_checkout (rcsfile->path, NULL, vers_tag, options, tmpfile1,
	                        0, 0);
	if (retcode != 0)
d466 3
a468 2
	retcode = RCS_checkout (rcsfile->path, NULL, vers_head, options, tmpfile2, 0, 0);
	if (retcode != 0)
d489 1
a489 1
    switch (run_exec (RUN_TTY, tmpfile3, RUN_TTY, RUN_REALLY))
d505 2
a506 2
	    if (finfo->update_dir[0])
	      (void) printf ("Index: %s/%s\n", finfo->update_dir, finfo->file);
d508 1
a508 1
	      (void) printf ("Index: %s\n", finfo->file);
d557 2
a558 2
		(void) sprintf (file1, "%s%s%s:%s", finfo->update_dir,
				finfo->update_dir[0] ? "/" : "", rcs, vers_tag);
d564 2
a565 2
	    (void) sprintf (file2, "%s%s%s:%s", finfo->update_dir,
			    finfo->update_dir[0] ? "/" : "", rcs,
d578 2
a579 2
	    if (finfo->update_dir[0] != '\0')
		(void) printf ("%s/", finfo->update_dir);
d594 3
a596 4
    /* FIXME: should be checking for errors.  */
    (void) unlink (tmpfile1);
    (void) unlink (tmpfile2);
    (void) unlink (tmpfile3);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d339 3
a341 2
    char rcsspace[1][PATH_MAX];
    char *rcs = rcsspace[0];
d351 1
a351 1
    char *cp1, *cp2;
d355 2
a356 1
    if ((rcsfile = finfo->rcs) == NULL)
d358 1
d396 1
a396 1
	(void) printf ("File %s ", finfo->fullname);
d398 1
a398 1
	    (void) printf ("is new; current revision %s\n", vers_head);
d401 1
a401 1
	    (void) printf ("is removed; not included in ");
d411 2
a412 2
	    (void) printf ("changed from revision %s to %s\n",
			   vers_tag, vers_head);
d489 4
a492 1
	    (void) printf ("Index: %s\n", finfo->fullname);
d537 2
d541 2
a542 1
		(void) sprintf (file1, "%s:%s", finfo->fullname, vers_tag);
d548 2
a549 1
	    (void) sprintf (file2, "%s:%s", finfo->fullname,
a550 4

	    /* Note that this prints "diff" not DIFF.  The format of a diff
	       does not depend on the name of the program which happens to
	       have produced it.  */
d562 3
a564 1
	    (void) printf ("%s%s", finfo->fullname, cp2);
d571 1
a571 1
	    error (0, 0, "diff failed for %s", finfo->fullname);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d19 2
a20 4
static Dtype patch_dirproc PROTO ((void *callerdat, char *dir,
				   char *repos, char *update_dir,
				   List *entries));
static int patch_fileproc PROTO ((void *callerdat, struct file_info *finfo));
d31 1
a31 1
static int rev1_validated = 0;
d33 1
a33 1
static int rev2_validated = 0;
d36 1
a36 3
static char *tmpfile1 = NULL;
static char *tmpfile2 = NULL;
static char *tmpfile3 = NULL;
d256 1
a256 1
    (void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
d298 1
a298 1
    if ( CVS_CHDIR (repository) < 0)
d322 2
a323 3
			   (DIRLEAVEPROC) NULL, NULL,
			   *pargc - 1, argv + 1, local,
			   which, 0, 1, where, 1);
d334 1
a334 2
patch_fileproc (callerdat, finfo)
    void *callerdat;
d365 1
a365 9
    {
	vers_head = RCS_getversion (rcsfile, rev2, date2, force_tag_match,
				    (int *) NULL);
	if (vers_head != NULL && RCS_isdead (rcsfile, vers_head))
	{
	    free (vers_head);
	    vers_head = NULL;
	}
    }
d383 1
a383 7
    vers_tag = RCS_getversion (rcsfile, rev1, date1, force_tag_match,
			       (int *) NULL);
    if (vers_tag != NULL && RCS_isdead (rcsfile, vers_tag))
    {
        free (vers_tag);
	vers_tag = NULL;
    }
d385 1
a385 1
    if (vers_tag == NULL && vers_head == NULL)
d412 1
a412 2
    tmpfile1 = cvs_temp_name ();
    if ((fp1 = CVS_FOPEN (tmpfile1, "w+")) != NULL)
d414 1
a414 2
    tmpfile2 = cvs_temp_name ();
    if ((fp2 = CVS_FOPEN (tmpfile2, "w+")) != NULL)
d416 1
a416 2
    tmpfile3 = cvs_temp_name ();
    if ((fp3 = CVS_FOPEN (tmpfile3, "w+")) != NULL)
a419 2
	/* FIXME: should be printing a proper error message, with errno-based
	   message, and the filename which we could not create.  */
d426 2
a427 2
	retcode = RCS_checkout (rcsfile, (char *) NULL, vers_tag,
				(char *) NULL, options, tmpfile1);
d448 1
a448 2
	retcode = RCS_checkout (rcsfile, (char *) NULL, vers_head,
				(char *) NULL, options, tmpfile2);
d525 2
a526 2
	    if (CVSroot_directory != NULL)
		(void) sprintf (strippath, "%s/", CVSroot_directory);
d571 3
a573 7
    (void) CVS_UNLINK (tmpfile1);
    (void) CVS_UNLINK (tmpfile2);
    (void) CVS_UNLINK (tmpfile3);
    free (tmpfile1);
    free (tmpfile2);
    free (tmpfile3);
    tmpfile1 = tmpfile2 = tmpfile3 = NULL;
d582 1
a582 2
patch_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a585 1
    List *entries;
d598 1
a598 2
    if (tmpfile1 != NULL)
    {
d600 1
a600 4
	free (tmpfile1);
    }
    if (tmpfile2 != NULL)
    {
d602 1
a602 4
	free (tmpfile2);
    }
    if (tmpfile3 != NULL)
    {
a603 3
	free (tmpfile3);
    }
    tmpfile1 = tmpfile2 = tmpfile3 = NULL;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d180 1
a180 1
	if (!force_tag_match)
a358 5
    line1 = NULL;
    line1_chars_allocated = 0;
    line2 = NULL;
    line2_chars_allocated = 0;

d452 1
a452 1
				rev1, options, tmpfile1);
d474 1
a474 1
				rev2, options, tmpfile2);
d490 5
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a126 18
		/* This option is pretty seriously broken:
		   1.  It is not clear what it does (does it change keyword
		   expansion behavior?  If so, how?  Or does it have
		   something to do with what version of RCS we are using?
		   Or the format we write RCS files in?).
		   2.  Because both it and -k use the options variable,
		   specifying both -V and -k doesn't work.
		   3.  At least as of CVS 1.9, it doesn't work (failed
		   assertion in RCS_checkout where it asserts that options
		   starts with -k).  Few people seem to be complaining.
		   In the future (perhaps the near future), I have in mind
		   removing it entirely, and updating NEWS and cvs.texinfo,
		   but in case it is a good idea to give people more time
		   to complain if they would miss it, I'll just add this
		   quick and dirty error message for now.  */
		error (1, 0,
		       "the -V option is obsolete and should not be used");
#if 0
a132 1
#endif
d242 1
d258 1
a258 2
    char *repository;
    char *where;
a259 2
    repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile)) + 30);
a260 2
    where = xmalloc (strlen (argv[0]) + (mfile == NULL ? 0 : strlen (mfile))
		     + 10);
d267 1
a267 1
	char *path;
a280 1
	path = xmalloc (strlen (repository) + strlen (mfile) + 5);
a298 1
	free (path);
a304 1
	free (repository);
a306 1
    free (repository);
a328 1
    free (where);
d345 2
a346 1
    char *rcs = NULL;
d352 1
a352 3
    char *file1;
    char *file2;
    char *strippath;
d366 1
a366 4
    {
	ret = 1;
	goto out2;
    }
a369 1
    rcs = xmalloc (strlen (finfo->file) + sizeof (RCSEXT) + 5);
d389 1
a389 4
	{
	    ret = 1;
	    goto out2;
	}
d392 1
a392 1
	    date1 = xmalloc (MAXDATELEN);
d399 1
a399 2
	    ret = 1;
	    goto out2;
d411 1
a411 5
    {
	/* Nothing known about specified revs.  */
	ret = 0;
	goto out2;
    }
d414 1
a414 5
    {
	/* Not changed between releases.  */
	ret = 0;
	goto out2;
    }
d435 1
a435 2
	ret = 0;
	goto out2;
a551 2
	    {
		strippath = xmalloc (strlen (CVSroot_directory) + 10);
a552 1
	    }
d554 1
a554 1
		strippath = xstrdup (REPOS_STRIP);
a556 1
	    free (strippath);
a558 3
		file1 = xmalloc (strlen (finfo->fullname)
				 + strlen (vers_tag)
				 + 10);
d563 1
a563 1
		file1 = xstrdup (DEVNULL);
a564 3
	    file2 = xmalloc (strlen (finfo->fullname)
			     + (vers_head != NULL ? strlen (vers_head) : 10)
			     + 10);
a586 2
	    free (file1);
	    free (file2);
a603 4

 out2:
    if (rcs != NULL)
	free (rcs);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d73 1
a73 1
    while ((c = getopt (argc, argv, "+V:k:cuftsQqlRD:r:")) != -1)
d503 1
a503 2
				rev1, options, tmpfile1,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
d525 1
a525 2
				rev2, options, tmpfile2,
				(RCSCHECKOUTPROC) NULL, (void *) NULL);
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d45 1
a45 1
    "Usage: %s %s [-flR] [-c|-u] [-s|-t] [-V %%d]\n",
a48 1
    "\t-R\tProcess directories recursively.\n",
d72 1
a72 1
    optind = 0;
d516 1
a516 3
	    /* I believe this timestamp only affects the dates in our diffs,
	       and therefore should be on the server, not the client.  */
	    (void) utime (tmpfile1, &t);
d538 1
a538 3
	    /* I believe this timestamp only affects the dates in our diffs,
	       and therefore should be on the server, not the client.  */
	    (void) utime (tmpfile2, &t);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a56 1
    "(Specify the --help global option for a list of other help options)\n",
a387 1
    int line_length;
d464 1
a464 2
	cvs_output ("File ", 0);
	cvs_output (finfo->fullname, 0);
d466 1
a466 5
	{
	    cvs_output (" is new; current revision ", 0);
	    cvs_output (vers_head, 0);
	    cvs_output ("\n", 1);
	}
d469 1
a469 1
	    cvs_output (" is removed; not included in ", 0);
d471 1
a471 4
	    {
		cvs_output ("release tag ", 0);
		cvs_output (rev2, 0);
	    }
d473 1
a473 4
	    {
		cvs_output ("release date ", 0);
		cvs_output (date2, 0);
	    }
d475 2
a476 2
		cvs_output ("current release", 0);
	    cvs_output ("\n", 1);
d479 2
a480 7
	{
	    cvs_output (" changed from revision ", 0);
	    cvs_output (vers_tag, 0);
	    cvs_output (" to ", 0);
	    cvs_output (vers_head, 0);
	    cvs_output ("\n", 1);
	}
d545 3
d549 1
a549 1
    switch (diff_exec (tmpfile1, tmpfile2, unidiff ? "-u" : "-c", tmpfile3))
d564 3
a566 3
	    cvs_output ("Index: ", 0);
	    cvs_output (finfo->fullname, 0);
	    cvs_output ("\n", 1);
d631 3
a633 3
	    /* Note that the string "diff" is specified by POSIX (for -c)
	       and is part of the diff output format, not the name of a
	       program.  */
d636 2
a637 10
		cvs_output ("diff -u ", 0);
		cvs_output (file1, 0);
		cvs_output (" ", 1);
		cvs_output (file2, 0);
		cvs_output ("\n", 1);

		cvs_output ("--- ", 0);
		cvs_output (file1, 0);
		cvs_output (cp1, 0);
		cvs_output ("+++ ", 0);
d641 2
a642 10
		cvs_output ("diff -c ", 0);
		cvs_output (file1, 0);
		cvs_output (" ", 1);
		cvs_output (file2, 0);
		cvs_output ("\n", 1);

		cvs_output ("*** ", 0);
		cvs_output (file1, 0);
		cvs_output (cp1, 0);
		cvs_output ("--- ", 0);
d645 1
a645 3
	    cvs_output (finfo->fullname, 0);
	    cvs_output (cp2, 0);

d647 3
a649 9
	    while ((line_length
		    = getline (&line1, &line1_chars_allocated, fp))
		   >= 0)
		cvs_output (line1, 0);
	    if (line_length < 0 && !feof (fp))
		error (0, errno, "cannot read %s", tmpfile3);

	    if (fclose (fp) < 0)
		error (0, errno, "cannot close %s", tmpfile3);
d661 4
a664 6
    if (CVS_UNLINK (tmpfile1) < 0)
	error (0, errno, "cannot unlink %s", tmpfile1);
    if (CVS_UNLINK (tmpfile2) < 0)
	error (0, errno, "cannot unlink %s", tmpfile2);
    if (CVS_UNLINK (tmpfile3) < 0)
	error (0, errno, "cannot unlink %s", tmpfile3);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a501 3

    /* Create 3 empty files.  I'm not really sure there is any advantage
       to doing so now rather than just waiting until later.  */
d503 2
a504 10
    fp1 = CVS_FOPEN (tmpfile1, "w+");
    if (fp1 == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile1);
	ret = 1;
	goto out;
    }
    else
	if (fclose (fp1) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile1);
d506 2
a507 10
    fp2 = CVS_FOPEN (tmpfile2, "w+");
    if (fp2 == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile2);
	ret = 1;
	goto out;
    }
    else
	if (fclose (fp2) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile2);
d509 7
a515 4
    fp3 = CVS_FOPEN (tmpfile3, "w+");
    if (fp3 == NULL)
    {
	error (0, errno, "cannot create temporary file %s", tmpfile3);
a518 4
    else
	if (fclose (fp3) < 0)
	    error (0, errno, "warning: cannot close %s", tmpfile3);

d526 3
a528 2
	    error (0, 0,
		   "cannot check out revision %s of %s", vers_tag, rcs);
d551 3
a553 2
	    error (0, 0,
		   "cannot check out revision %s of %s", vers_head, rcs);
d587 2
a588 7
		if (feof (fp))
		    error (0, 0, "\
failed to read diff file header %s for %s: end of file", tmpfile3, rcs);
		else
		    error (0, errno,
			   "failed to read diff file header %s for %s",
			   tmpfile3, rcs);
d590 1
a590 2
		if (fclose (fp) < 0)
		    error (0, errno, "error closing %s", tmpfile3);
d602 1
a602 2
		    if (fclose (fp) < 0)
			error (0, errno, "error closing %s", tmpfile3);
d615 1
a615 2
		    if (fclose (fp) < 0)
			error (0, errno, "error closing %s", tmpfile3);
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a765 4
    /* Note that the checks for existence_error are because we are
       called from a signal handler, without SIG_begincrsect, so
       we don't know whether the files got created.  */

d768 1
a768 3
	if (unlink_file (tmpfile1) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile1);
d773 1
a773 3
	if (unlink_file (tmpfile2) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile2);
d778 1
a778 3
	if (unlink_file (tmpfile3) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmpfile3);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d23 1
a23 1
static int patch_proc PROTO((int argc, char **argv, char *xwhere,
a232 3
#ifdef SIGABRT
    (void) SIG_register (SIGABRT, patch_cleanup);
#endif
d264 1
a264 1
patch_proc (argc, argv, xwhere, mwhere, mfile, shorten, local_specified,
d266 1
a266 1
    int argc;
a275 1
    char *myargv[2];
d317 7
a323 4
	    myargv[0] = argv[0];
	    myargv[1] = mfile;
	    argc = 2;
	    argv = myargv;
d344 1
a344 1
	tag_check_valid (rev1, argc - 1, argv + 1, local, 0, NULL);
d349 1
a349 1
	tag_check_valid (rev2, argc - 1, argv + 1, local, 0, NULL);
d356 1
a356 1
			   argc - 1, argv + 1, local,
a737 4
    if (vers_tag != NULL)
	free (vers_tag);
    if (vers_head != NULL)
	free (vers_head);
@


1.1.1.14
log
@Latest from Cyclic Software
@
text
@a14 1
#include <assert.h>
d192 1
a192 1
    if (current_parsed_root->isremote)
d255 1
a255 1
			  (char *) NULL, 0, 0, 0, 0, (char *) NULL);
d285 5
a289 5
    repository = xmalloc (strlen (current_parsed_root->directory) + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile) + 1) + 2);
    (void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
    where = xmalloc (strlen (argv[0]) + (mfile == NULL ? 0 : strlen (mfile) + 1)
		     + 1);
d310 1
a310 1
	path = xmalloc (strlen (repository) + strlen (mfile) + 2);
d505 4
a508 9
     * to doing so now rather than just waiting until later.
     *
     * There is - cvs_temp_file opens the file so that it can guarantee that
     * we have exclusive write access to the file.  Unfortunately we spoil that
     * by closing it and reopening it again.  Of course any better solution
     * requires that the RCS functions accept open file pointers rather than
     * simple file names.
     */
    if ((fp1 = cvs_temp_file (&tmpfile1)) == NULL)
d517 3
a519 1
    if ((fp2 = cvs_temp_file (&tmpfile2)) == NULL)
d528 3
a530 1
    if ((fp3 = cvs_temp_file (&tmpfile3)) == NULL)
d583 1
a583 1
    switch (diff_exec (tmpfile1, tmpfile2, NULL, NULL, unidiff ? "-u" : "-c", tmpfile3))
d646 1
a646 2
	    assert (current_parsed_root != NULL);
	    assert (current_parsed_root->directory != NULL);
d648 2
a649 2
		strippath = xmalloc (strlen (current_parsed_root->directory) + 2);
		(void) sprintf (strippath, "%s/", current_parsed_root->directory);
d651 2
a652 2
	    /*else
		strippath = xstrdup (REPOS_STRIP); */
@


