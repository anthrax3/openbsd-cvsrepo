head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.14
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.16
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.12
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.8
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.10
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.6
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.20
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.18
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.16
	OPENBSD_5_0:1.26.0.14
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.12
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.10
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.16
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.14
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.12
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.10
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.8
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	OPENBSD_3_5:1.24.0.12
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.10
	OPENBSD_3_4_BASE:1.24
	OPENBSD_3_3:1.24.0.8
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.6
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.4
	OPENBSD_3_1_BASE:1.24
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_9_BASE:1.23
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.22.0.6
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.4
	OPENBSD_2_7_BASE:1.22
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.03.17.02.36;	author jcs;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.11.00.52.43;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.09.18.16.05;	author otto;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches
	1.24.10.1
	1.24.12.1;
next	1.23;

1.23
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	99.09.10.05.21.32;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	99.02.28.21.57.50;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	98.08.22.21.04.27;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	98.07.13.04.17.02;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	98.03.12.07.22.30;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	98.02.22.09.27.20;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	98.02.22.08.55.58;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	97.06.28.03.45.28;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	97.04.26.08.33.28;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.04.21.04.41.04;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.03.29.04.49.50;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	97.03.18.02.09.55;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.02.21.06.54.53;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.10.18.17.44.21;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.10.18.04.19.29;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.05.31.13.05.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.12.03.31.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.06.22.51.13;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.27.20.26.18;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.30.01.10.39;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.19.10.41.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.48;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.28;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.06;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.14;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.09;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.49;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.38.01;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.26.40;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.28.28;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.20.53;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.06.58.15;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.03.53.27;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.52.41;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.32.26;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.06.19;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.18.57.36;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.45.39;	author tholo;	state Exp;
branches;
next	;

1.24.10.1
date	2004.06.09.19.51.06;	author brad;	state Exp;
branches;
next	;

1.24.12.1
date	2004.06.09.19.31.48;	author brad;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS kit.
 */

/*
 * basic information used in all source files
 *
 */


#include "config.h"		/* this is stuff found via autoconf */
#include "options.h"		/* these are some larger questions which
				   can't easily be automatically checked
				   for */

/* Changed from if __STDC__ to ifdef __STDC__ because of Sun's acc compiler */

#ifdef __STDC__
#define	PTR	void *
#else
#define	PTR	char *
#endif

/* Add prototype support.  */
#ifndef PROTO
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#define PROTO(ARGS) ARGS
#else
#define PROTO(ARGS) ()
#endif
#endif

#include <stdio.h>

/* Under OS/2, <stdio.h> doesn't define popen()/pclose(). */
#ifdef USE_OWN_POPEN
#include "popen.h"
#endif

/* Begin GNULIB headers.  */
#include "xsize.h"
/* End GNULIB headers.  */

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
extern void exit ();
extern char *getenv();
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif

#ifdef SERVER_SUPPORT
/* If the system doesn't provide strerror, it won't be declared in
   string.h.  */
char *strerror ();
#endif

#include <fnmatch.h> /* This is supposed to be available on Posix systems */

#include <ctype.h>
#include <pwd.h>
#include <signal.h>

#ifdef HAVE_ERRNO_H
#include <errno.h>
#else
#ifndef errno
extern int errno;
#endif /* !errno */
#endif /* HAVE_ERRNO_H */

#include "system.h"

#include "hash.h"
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
#include "client.h"
#endif

#ifdef MY_NDBM
#include "myndbm.h"
#else
#include <ndbm.h>
#endif /* MY_NDBM */

#include "regex.h"
#include "getopt.h"
#include "wait.h"

#include "rcs.h"


/* This actually gets set in system.h.  Note that the _ONLY_ reason for
   this is if various system calls (getwd, getcwd, readlink) require/want
   us to use it.  All other parts of CVS allocate pathname buffers
   dynamically, and we want to keep it that way.  */
#ifndef PATH_MAX
#ifdef MAXPATHLEN
#define	PATH_MAX MAXPATHLEN+2
#else
#define	PATH_MAX 1024+2
#endif
#endif /* PATH_MAX */

/* Definitions for the CVS Administrative directory and the files it contains.
   Here as #define's to make changing the names a simple task.  */

#ifdef USE_VMS_FILENAMES
#define CVSADM          "CVS"
#define CVSADM_ENT      "CVS/Entries."
#define CVSADM_ENTBAK   "CVS/Entries.Backup"
#define CVSADM_ENTLOG   "CVS/Entries.Log"
#define CVSADM_ENTSTAT  "CVS/Entries.Static"
#define CVSADM_REP      "CVS/Repository."
#define CVSADM_ROOT     "CVS/Root."
#define CVSADM_CIPROG   "CVS/Checkin.prog"
#define CVSADM_UPROG    "CVS/Update.prog"
#define CVSADM_TAG      "CVS/Tag."
#define CVSADM_NOTIFY   "CVS/Notify."
#define CVSADM_NOTIFYTMP "CVS/Notify.tmp"
#define CVSADM_BASE      "CVS/Base"
#define CVSADM_BASEREV   "CVS/Baserev."
#define CVSADM_BASEREVTMP "CVS/Baserev.tmp"
#define CVSADM_TEMPLATE "CVS/Template."
#else /* USE_VMS_FILENAMES */
#define	CVSADM		"CVS"
#define	CVSADM_ENT	"CVS/Entries"
#define	CVSADM_ENTBAK	"CVS/Entries.Backup"
#define CVSADM_ENTLOG	"CVS/Entries.Log"
#define	CVSADM_ENTSTAT	"CVS/Entries.Static"
#define	CVSADM_REP	"CVS/Repository"
#define	CVSADM_ROOT	"CVS/Root"
#define	CVSADM_CIPROG	"CVS/Checkin.prog"
#define	CVSADM_UPROG	"CVS/Update.prog"
#define	CVSADM_TAG	"CVS/Tag"
#define CVSADM_NOTIFY	"CVS/Notify"
#define CVSADM_NOTIFYTMP "CVS/Notify.tmp"
/* A directory in which we store base versions of files we currently are
   editing with "cvs edit".  */
#define CVSADM_BASE     "CVS/Base"
#define CVSADM_BASEREV  "CVS/Baserev"
#define CVSADM_BASEREVTMP "CVS/Baserev.tmp"
/* File which contains the template for use in log messages.  */
#define CVSADM_TEMPLATE "CVS/Template"
#endif /* USE_VMS_FILENAMES */

/* This is the special directory which we use to store various extra
   per-directory information in the repository.  It must be the same as
   CVSADM to avoid creating a new reserved directory name which users cannot
   use, but is a separate #define because if anyone changes it (which I don't
   recommend), one needs to deal with old, unconverted, repositories.
   
   See fileattr.h for details about file attributes, the only thing stored
   in CVSREP currently.  */
#define CVSREP "CVS"

/*
 * Definitions for the CVSROOT Administrative directory and the files it
 * contains.  This directory is created as a sub-directory of the $CVSROOT
 * environment variable, and holds global administration information for the
 * entire source repository beginning at $CVSROOT.
 */
#define	CVSROOTADM		"CVSROOT"
#define	CVSROOTADM_MODULES	"modules"
#define	CVSROOTADM_LOGINFO	"loginfo"
#define	CVSROOTADM_RCSINFO	"rcsinfo"
#define CVSROOTADM_COMMITINFO	"commitinfo"
#define CVSROOTADM_TAGINFO      "taginfo"
#define	CVSROOTADM_EDITINFO	"editinfo"
#define CVSROOTADM_VERIFYMSG    "verifymsg"
#define	CVSROOTADM_HISTORY	"history"
#define CVSROOTADM_VALTAGS	"val-tags"
#define	CVSROOTADM_IGNORE	"cvsignore"
#define	CVSROOTADM_CHECKOUTLIST "checkoutlist"
#define CVSROOTADM_WRAPPER	"cvswrappers"
#define CVSROOTADM_NOTIFY	"notify"
#define CVSROOTADM_USERS	"users"
#define CVSROOTADM_READERS	"readers"
#define CVSROOTADM_WRITERS	"writers"
#define CVSROOTADM_PASSWD	"passwd"
#define CVSROOTADM_CONFIG	"config"

#define CVSNULLREPOS		"Emptydir"	/* an empty directory */

/* Other CVS file names */

/* Files go in the attic if the head main branch revision is dead,
   otherwise they go in the regular repository directories.  The whole
   concept of having an attic is sort of a relic from before death
   support but on the other hand, it probably does help the speed of
   some operations (such as main branch checkouts and updates).  */
#define	CVSATTIC	"Attic"

#define	CVSLCK		"#cvs.lock"
#define	CVSRFL		"#cvs.rfl"
#define	CVSWFL		"#cvs.wfl"
#define CVSRFLPAT	"#cvs.rfl.*"	/* wildcard expr to match read locks */
#define	CVSEXT_LOG	",t"
#define	CVSPREFIX	",,"
#define CVSDOTIGNORE	".cvsignore"
#define CVSDOTWRAPPER   ".cvswrappers"

/* Command attributes -- see function lookup_command_attribute(). */
#define CVS_CMD_IGNORE_ADMROOT        1

/* Set if CVS needs to create a CVS/Root file upon completion of this
   command.  The name may be slightly confusing, because the flag
   isn't really as general purpose as it seems (it is not set for cvs
   release).  */

#define CVS_CMD_USES_WORK_DIR         2

#define CVS_CMD_MODIFIES_REPOSITORY   4

/* miscellaneous CVS defines */

/* This is the string which is at the start of the non-log-message lines
   that we put up for the user when they edit the log message.  */
#define	CVSEDITPREFIX	"CVS: "
/* Number of characters in CVSEDITPREFIX to compare when deciding to strip
   off those lines.  We don't check for the space, to accomodate users who
   have editors which strip trailing spaces.  */
#define CVSEDITPREFIXLEN 4

#define	CVSLCKAGE	(60*60)		/* 1-hour old lock files cleaned up */
#define	CVSLCKSLEEP	30		/* wait 30 seconds before retrying */
#define	CVSBRANCH	"1.1.1"		/* RCS branch used for vendor srcs */

#ifdef USE_VMS_FILENAMES
#define BAKPREFIX       "_$"
#define DEVNULL         "NLA0:"
#else /* USE_VMS_FILENAMES */
#define	BAKPREFIX	".#"		/* when rcsmerge'ing */
#ifndef DEVNULL
#define	DEVNULL		"/dev/null"
#endif
#endif /* USE_VMS_FILENAMES */

/*
 * Special tags. -rHEAD	refers to the head of an RCS file, regardless of any
 * sticky tags. -rBASE	refers to the current revision the user has checked
 * out This mimics the behaviour of RCS.
 */
#define	TAG_HEAD	"HEAD"
#define	TAG_BASE	"BASE"

/* Environment variable used by CVS */
#define	CVSREAD_ENV	"CVSREAD"	/* make files read-only */
#define	CVSREAD_DFLT	0		/* writable files by default */

#define	CVSREADONLYFS_ENV "CVSREADONLYFS" /* repository is read-only */

#define	TMPDIR_ENV	"TMPDIR"	/* Temporary directory */
/* #define	TMPDIR_DFLT		   Set by options.h */

#define	EDITOR1_ENV	"CVSEDITOR"	/* which editor to use */
#define	EDITOR2_ENV	"VISUAL"	/* which editor to use */
#define	EDITOR3_ENV	"EDITOR"	/* which editor to use */
/* #define	EDITOR_DFLT		   Set by options.h */

#define	CVSROOT_ENV	"CVSROOT"	/* source directory root */
#define	CVSROOT_DFLT	NULL		/* No dflt; must set for checkout */

#define	IGNORE_ENV	"CVSIGNORE"	/* More files to ignore */
#define WRAPPER_ENV     "CVSWRAPPERS"   /* name of the wrapper file */

#define	CVSUMASK_ENV	"CVSUMASK"	/* Effective umask for repository */
/* #define	CVSUMASK_DFLT		   Set by options.h */

/*
 * If the beginning of the Repository matches the following string, strip it
 * so that the output to the logfile does not contain a full pathname.
 *
 * If the CVSROOT environment variable is set, it overrides this define.
 */
#define	REPOS_STRIP	"/master/"

/* Large enough to hold DATEFORM.  Not an arbitrary limit as long as
   it is used for that purpose, and not to hold a string from the
   command line, the client, etc.  */
#define MAXDATELEN	50

/* The type of an entnode.  */
enum ent_type
{
    ENT_FILE, ENT_SUBDIR
};

/* structure of a entry record */
struct entnode
{
    enum ent_type type;
    char *user;
    char *version;

    /* Timestamp, or "" if none (never NULL).  */
    char *timestamp;

    /* Keyword expansion options, or "" if none (never NULL).  */
    char *options;

    char *tag;
    char *date;
    char *conflict;
};
typedef struct entnode Entnode;

/* The type of request that is being done in do_module() */
enum mtype
{
    CHECKOUT, TAG, PATCH, EXPORT, MISC
};

/*
 * structure used for list-private storage by Entries_Open() and
 * Version_TS() and Find_Directories().
 */
struct stickydirtag
{
    /* These fields pass sticky tag information from Entries_Open() to
       Version_TS().  */
    int aflag;
    char *tag;
    char *date;
    int nonbranch;

    /* This field is set by Entries_Open() if there was subdirectory
       information; Find_Directories() uses it to see whether it needs
       to scan the directory itself.  */
    int subdirs;
};

/* Flags for find_{names,dirs} routines */
#define W_LOCAL			0x01	/* look for files locally */
#define W_REPOS			0x02	/* look for files in the repository */
#define W_ATTIC			0x04	/* look for files in the attic */

/* Flags for return values of direnter procs for the recursion processor */
enum direnter_type
{
    R_PROCESS = 1,			/* process files and maybe dirs */
    R_SKIP_FILES,			/* don't process files in this dir */
    R_SKIP_DIRS,			/* don't process sub-dirs */
    R_SKIP_ALL				/* don't process files or dirs */
};
#ifdef ENUMS_CAN_BE_TROUBLE
typedef int Dtype;
#else
typedef enum direnter_type Dtype;
#endif

extern char *program_name, *program_path, *command_name;
extern char *Tmpdir, *Editor;
extern int cvsadmin_root;
extern char *CurDir;
extern int really_quiet, quiet;
extern int use_editor;
extern int cvswrite;
extern mode_t cvsumask;
extern int disable_mdocdate;
extern char *RCS_citag;

/* Access method specified in CVSroot. */
typedef enum {
  null_method, local_method, server_method, pserver_method, kserver_method, gserver_method,
  ext_method, fork_method
} CVSmethod;
extern char *method_names[];	/* change this in root.c if you change
				   the enum above */

typedef struct cvsroot_s {
    char *original;		/* the complete source CVSroot string */
    CVSmethod method;		/* one of the enum values above */
    char *username;		/* the username or NULL if method == local */
    char *password;		/* the username or NULL if method == local */
    char *hostname;		/* the hostname or NULL if method == local */
    int port;			/* the port or zero if method == local */
    char *directory;		/* the directory name */
#ifdef CLIENT_SUPPORT
    unsigned char isremote;	/* nonzero if we are doing remote access */
#endif /* CLIENT_SUPPORT */
} cvsroot_t;

/* This global variable holds the global -d option.  It is NULL if -d
   was not used, which means that we must get the CVSroot information
   from the CVSROOT environment variable or from a CVS/Root file.  */
extern char *CVSroot_cmdline;

/* These variables keep track of all of the CVSROOT directories that
   have been seen by the client and the current one of those selected.  */
extern List *root_directories;
extern cvsroot_t *current_parsed_root;

extern char *emptydir_name PROTO ((void));
extern int safe_location PROTO ((void));

extern int trace;		/* Show all commands */
extern int noexec;		/* Don't modify disk anywhere */
extern int readonlyfs;		/* fail on all write locks; succeed all read locks */
extern int logoff;		/* Don't write history entry */

extern int top_level_admin;

#ifdef CLIENT_SUPPORT
extern List *dirs_sent_to_server; /* used to decide which "Argument
				     xxx" commands to send to each
				     server in multiroot mode. */
#endif

extern char hostname[];

/* Externs that are included directly in the CVS sources */

int RCS_merge PROTO((RCSNode *, char *, char *, char *, char *, char *));
/* Flags used by RCS_* functions.  See the description of the individual
   functions for which flags mean what for each function.  */
#define RCS_FLAGS_FORCE 1
#define RCS_FLAGS_DEAD 2
#define RCS_FLAGS_QUIET 4
#define RCS_FLAGS_MODTIME 8
#define RCS_FLAGS_KEEPFILE 16

extern int RCS_exec_rcsdiff PROTO ((RCSNode *rcsfile,
				    char *opts, char *options,
				    char *rev1, char *rev2,
				    char *label1, char *label2,
				    char *workfile));
extern int diff_exec PROTO ((char *file1, char *file2,
			     char *label1, char *label2,
			     char *options, char *out));
extern int diff_execv PROTO ((char *file1, char *file2,
			      char *label1, char *label2,
			      char *options, char *out));



#include "error.h"

DBM *open_module PROTO((void));
FILE *open_file PROTO((const char *, const char *));
List *Find_Directories PROTO((char *repository, int which, List *entries));
void Entries_Close PROTO((List *entries));
List *Entries_Open PROTO ((int aflag, char *update_dir));
void Subdirs_Known PROTO((List *entries));
void Subdir_Register PROTO((List *, const char *, const char *));
void Subdir_Deregister PROTO((List *, const char *, const char *));

char *Make_Date PROTO((char *rawdate));
char *date_from_time_t PROTO ((time_t));
void date_to_internet PROTO ((char *, const char *));
void date_to_tm PROTO ((struct tm *, const char *));
void tm_to_internet PROTO ((char *, const struct tm *));

char *Name_Repository PROTO((char *dir, char *update_dir));
char *Short_Repository PROTO((char *repository));
void Sanitize_Repository_Name PROTO((char *repository));

char *Name_Root PROTO((char *dir, char *update_dir));
void free_cvsroot_t PROTO((cvsroot_t *root_in));
cvsroot_t *parse_cvsroot PROTO((char *root));
cvsroot_t *local_cvsroot PROTO((char *dir));
void Create_Root PROTO((char *dir, char *rootdir));
void root_allow_add PROTO ((char *));
void root_allow_free PROTO ((void));
int root_allow_ok PROTO ((char *));

char *gca PROTO((const char *rev1, const char *rev2));
extern void check_numeric PROTO ((const char *, int, char **));
char *getcaller PROTO((void));
char *time_stamp PROTO((char *file));

void *xmalloc PROTO((size_t bytes));
void *xrealloc PROTO((void *ptr, size_t bytes));
void expand_string PROTO ((char **, size_t *, size_t));
void allocate_and_strcat PROTO ((char **, size_t *, const char *));
char *xstrdup PROTO((const char *str));
void strip_trailing_newlines PROTO((char *str));
int pathname_levels PROTO ((char *path));

typedef	int (*CALLPROC)	PROTO((char *repository, char *value));
int Parse_Info PROTO((char *infofile, char *repository, CALLPROC callproc, int all));
extern int parse_config PROTO ((char *));

typedef	RETSIGTYPE (*SIGCLEANUPPROC)	PROTO(());
int SIG_register PROTO((int sig, SIGCLEANUPPROC sigcleanup));
int isdir PROTO((const char *file));
int isfile PROTO((const char *file));
int islink PROTO((const char *file));
int isdevice PROTO ((const char *));
int isreadable PROTO((const char *file));
int iswritable PROTO((const char *file));
int isaccessible PROTO((const char *file, const int mode));
int isabsolute PROTO((const char *filename));
char *xreadlink PROTO((const char *link));
char *last_component PROTO((char *path));
char *get_homedir PROTO ((void));
char *cvs_temp_name PROTO ((void));
FILE *cvs_temp_file PROTO ((char **filename));

int numdots PROTO((const char *s));
char *increment_revnum PROTO ((const char *));
int compare_revnums PROTO ((const char *, const char *));
int unlink_file PROTO((const char *f));
int unlink_file_dir PROTO((const char *f));
int update PROTO((int argc, char *argv[]));
int xcmp PROTO((const char *file1, const char *file2));
int yesno PROTO((void));
void *valloc PROTO((size_t bytes));
time_t get_date PROTO((char *date));
extern int Create_Admin PROTO ((char *dir, char *update_dir,
				char *repository, char *tag, char *date,
				int nonbranch, int warn, int dotemplate));
extern int expand_at_signs PROTO ((char *, off_t, FILE *));

/* Locking subsystem (implemented in lock.c).  */

int Reader_Lock PROTO((char *xrepository));
void Lock_Cleanup PROTO((void));

/* Writelock an entire subtree, well the part specified by ARGC, ARGV, LOCAL,
   and AFLAG, anyway.  */
void lock_tree_for_write PROTO ((int argc, char **argv, int local, int which,
				 int aflag));

/* See lock.c for description.  */
extern void lock_dir_for_write PROTO ((char *));

/* LockDir setting from CVSROOT/config.  */
extern char *lock_dir;

void Scratch_Entry PROTO((List * list, char *fname));
void ParseTag PROTO((char **tagp, char **datep, int *nonbranchp));
void WriteTag PROTO ((char *dir, char *tag, char *date, int nonbranch,
		      char *update_dir, char *repository));
void cat_module PROTO((int status));
void check_entries PROTO((char *dir));
void close_module PROTO((DBM * db));
void copy_file PROTO((const char *from, const char *to));
void fperrmsg PROTO((FILE * fp, int status, int errnum, char *message,...));
void free_names PROTO((int *pargc, char *argv[]));

extern int ign_name PROTO ((char *name));
void ign_add PROTO((char *ign, int hold));
void ign_add_file PROTO((char *file, int hold));
void ign_setup PROTO((void));
void ign_dir_add PROTO((char *name));
int ignore_directory PROTO((char *name));
typedef void (*Ignore_proc) PROTO ((char *, char *));
extern void ignore_files PROTO ((List *, List *, char *, Ignore_proc));
extern int ign_inhibit_server;
extern int ign_case;

#include "update.h"

void line2argv PROTO ((int *pargc, char ***argv, char *line, char *sepchars));
void make_directories PROTO((const char *name));
void make_directory PROTO((const char *name));
extern int mkdir_if_needed PROTO ((char *name));
void rename_file PROTO((const char *from, const char *to));
/* Expand wildcards in each element of (ARGC,ARGV).  This is according to the
   files which exist in the current directory, and accordingly to OS-specific
   conventions regarding wildcard syntax.  It might be desirable to change the
   former in the future (e.g. "cvs status *.h" including files which don't exist
   in the working directory).  The result is placed in *PARGC and *PARGV;
   the *PARGV array itself and all the strings it contains are newly
   malloc'd.  It is OK to call it with PARGC == &ARGC or PARGV == &ARGV.  */
extern void expand_wild PROTO ((int argc, char **argv, 
                                int *pargc, char ***pargv));

#ifdef SERVER_SUPPORT
extern int cvs_casecmp PROTO ((char *, char *));
extern int fopen_case PROTO ((char *, char *, FILE **, char **));
#endif

void strip_trailing_slashes PROTO((char *path));
void update_delproc PROTO((Node * p));
void usage PROTO((const char *const *cpp));
void xchmod PROTO((char *fname, int writable));
char *xgetwd PROTO((void));
List *Find_Names PROTO((char *repository, int which, int aflag,
		  List ** optentries));
void Register PROTO((List * list, char *fname, char *vn, char *ts,
	       char *options, char *tag, char *date, char *ts_conflict));
void Update_Logfile PROTO((char *repository, char *xmessage, FILE * xlogfp,
		     List * xchanges));
void do_editor PROTO((char *dir, char **messagep,
		      char *repository, List * changes));

void do_verify PROTO((char *message, char *repository));

typedef	int (*CALLBACKPROC)	PROTO((int argc, char *argv[], char *where,
	char *mwhere, char *mfile, int shorten, int local_specified,
	char *omodule, char *msg));

/* This is the structure that the recursion processor passes to the
   fileproc to tell it about a particular file.  */
struct file_info
{
    /* Name of the file, without any directory component.  */
    char *file;

    /* Name of the directory we are in, relative to the directory in
       which this command was issued.  We have cd'd to this directory
       (either in the working directory or in the repository, depending
       on which sort of recursion we are doing).  If we are in the directory
       in which the command was issued, this is "".  */
    char *update_dir;

    /* update_dir and file put together, with a slash between them as
       necessary.  This is the proper way to refer to the file in user
       messages.  */
    char *fullname;

    /* Name of the directory corresponding to the repository which contains
       this file.  */
    char *repository;

    /* The pre-parsed entries for this directory.  */
    List *entries;

    RCSNode *rcs;
};

typedef	int (*FILEPROC) PROTO ((void *callerdat, struct file_info *finfo));
typedef	int (*FILESDONEPROC) PROTO ((void *callerdat, int err,
				     char *repository, char *update_dir,
				     List *entries));
typedef	Dtype (*DIRENTPROC) PROTO ((void *callerdat, char *dir,
				    char *repos, char *update_dir,
				    List *entries));
typedef	int (*DIRLEAVEPROC) PROTO ((void *callerdat, char *dir, int err,
				    char *update_dir, List *entries));

extern int mkmodules PROTO ((char *dir));
extern int init PROTO ((int argc, char **argv));

int do_module PROTO((DBM * db, char *mname, enum mtype m_type, char *msg,
		CALLBACKPROC callback_proc, char *where, int shorten,
		int local_specified, int run_module_prog, int build_dirs,
		char *extra_arg));
void history_write PROTO((int type, char *update_dir, char *revs, char *name,
		    char *repository));
int start_recursion PROTO((FILEPROC fileproc, FILESDONEPROC filesdoneproc,
		     DIRENTPROC direntproc, DIRLEAVEPROC dirleaveproc,
		     void *callerdat,
		     int argc, char *argv[], int local, int which,
		     int aflag, int readlock, char *update_preload,
		     int dosrcs));
void SIG_beginCrSect PROTO((void));
void SIG_endCrSect PROTO((void));
int SIG_inCrSect PROTO((void));
void read_cvsrc PROTO((int *argc, char ***argv, char *cmdname));

char *make_message_rcslegal PROTO((char *message));
extern int file_has_markers PROTO ((const struct file_info *));
extern void get_file PROTO ((const char *, const char *, const char *,
			     char **, size_t *, size_t *));
extern char *shell_escape PROTO((char *buf, const char *str));
char *backup_file PROTO((const char *file, const char *suffix));
extern void resolve_symlink PROTO ((char **filename));
void sleep_past PROTO ((time_t desttime));

/* flags for run_exec(), the fast system() for CVS */
#define	RUN_NORMAL		0x0000	/* no special behaviour */
#define	RUN_COMBINED		0x0001	/* stdout is duped to stderr */
#define	RUN_REALLY		0x0002	/* do the exec, even if noexec is on */
#define	RUN_STDOUT_APPEND	0x0004	/* append to stdout, don't truncate */
#define	RUN_STDERR_APPEND	0x0008	/* append to stderr, don't truncate */
#define	RUN_SIGIGNORE		0x0010	/* ignore interrupts for command */
#define	RUN_TTY		(char *)0	/* for the benefit of lint */

void run_arg PROTO((const char *s));
void run_print PROTO((FILE * fp));
void run_setup PROTO ((const char *prog));
int run_exec PROTO((const char *stin, const char *stout, const char *sterr,
		    int flags));

/* other similar-minded stuff from run.c.  */
FILE *run_popen PROTO((const char *, const char *));
int piped_child PROTO((char **, int *, int *));
void close_on_exec PROTO((int));

pid_t waitpid PROTO((pid_t, int *, int));

/*
 * a struct vers_ts contains all the information about a file including the
 * user and rcs file names, and the version checked out and the head.
 *
 * this is usually obtained from a call to Version_TS which takes a
 * tag argument for the RCS file if desired
 */
struct vers_ts
{
    /* rcs version user file derives from, from CVS/Entries.
       It can have the following special values:

       NULL = file is not mentioned in Entries (this is also used for a
	      directory).
       "" = ILLEGAL!  The comment used to say that it meant "no user file"
	    but as far as I know CVS didn't actually use it that way.
	    Note that according to cvs.texinfo, "" is not legal in the
	    Entries file.
       0 = user file is new
       -vers = user file to be removed.  */
    char *vn_user;

    /* Numeric revision number corresponding to ->vn_tag (->vn_tag
       will often be symbolic).  */
    char *vn_rcs;
    /* If ->tag is a simple tag in the RCS file--a tag which really
       exists which is not a magic revision--and if ->date is NULL,
       then this is a copy of ->tag.  Otherwise, it is a copy of
       ->vn_rcs.  */
    char *vn_tag;

    /* This is the timestamp from stating the file in the working directory.
       It is NULL if there is no file in the working directory.  It is
       "Is-modified" if we know the file is modified but don't have its
       contents.  */
    char *ts_user;
    /* Timestamp from CVS/Entries.  For the server, ts_user and ts_rcs
       are computed in a slightly different way, but the fact remains that
       if they are equal the file in the working directory is unmodified
       and if they differ it is modified.  */
    char *ts_rcs;

    /* Options from CVS/Entries (keyword expansion), malloc'd.  If none,
       then it is an empty string (never NULL).  */
    char *options;

    /* If non-NULL, there was a conflict (or merely a merge?  See merge_file)
       and the time stamp in this field is the time stamp of the working
       directory file which was created with the conflict markers in it.
       This is from CVS/Entries.  */
    char *ts_conflict;

    /* Tag specified on the command line, or if none, tag stored in
       CVS/Entries.  */
    char *tag;
    /* Date specified on the command line, or if none, date stored in
       CVS/Entries.  */
    char *date;
    /* If this is 1, then tag is not a branch tag.  If this is 0, then
       tag may or may not be a branch tag.  */
    int nonbranch;

    /* Pointer to entries file node  */
    Entnode *entdata;

    /* Pointer to parsed src file info */
    RCSNode *srcfile;
};
typedef struct vers_ts Vers_TS;

Vers_TS *Version_TS PROTO ((struct file_info *finfo, char *options, char *tag,
			    char *date, int force_tag_match,
			    int set_time));
void freevers_ts PROTO ((Vers_TS ** versp));

/* Miscellaneous CVS infrastructure which layers on top of the recursion
   processor (for example, needs struct file_info).  */

int Checkin PROTO ((int type, struct file_info *finfo, char *rcs, char *rev,
		    char *tag, char *options, char *message));
int No_Difference PROTO ((struct file_info *finfo, Vers_TS *vers));
/* TODO: can the finfo argument to special_file_mismatch be changed? -twp */
int special_file_mismatch PROTO ((struct file_info *finfo,
				  char *rev1, char *rev2));

/* CVSADM_BASEREV stuff, from entries.c.  */
extern char *base_get PROTO ((struct file_info *));
extern void base_register PROTO ((struct file_info *, char *));
extern void base_deregister PROTO ((struct file_info *));

/*
 * defines for Classify_File() to determine the current state of a file.
 * These are also used as types in the data field for the list we make for
 * Update_Logfile in commit, import, and add.
 */
enum classify_type
{
    T_UNKNOWN = 1,			/* no old-style analog existed	 */
    T_CONFLICT,				/* C (conflict) list		 */
    T_NEEDS_MERGE,			/* G (needs merging) list	 */
    T_MODIFIED,				/* M (needs checked in) list 	 */
    T_CHECKOUT,				/* O (needs checkout) list	 */
    T_ADDED,				/* A (added file) list		 */
    T_REMOVED,				/* R (removed file) list	 */
    T_REMOVE_ENTRY,			/* W (removed entry) list	 */
    T_UPTODATE,				/* File is up-to-date		 */
    T_PATCH,				/* P Like C, but can patch	 */
    T_TITLE				/* title for node type 		 */
};
typedef enum classify_type Ctype;

Ctype Classify_File PROTO
    ((struct file_info *finfo, char *tag, char *date, char *options,
      int force_tag_match, int aflag, Vers_TS **versp, int pipeout));

/*
 * structure used for list nodes passed to Update_Logfile() and
 * do_editor().
 */
struct logfile_info
{
  enum classify_type type;
  char *tag;
  char *rev_old;		/* rev number before a commit/modify,
				   NULL for add or import */
  char *rev_new;		/* rev number after a commit/modify,
				   add, or import, NULL for remove */
};

/* Wrappers.  */

typedef enum { WRAP_MERGE, WRAP_COPY } WrapMergeMethod;
typedef enum {
    /* -t and -f wrapper options.  Treating directories as single files.  */
    WRAP_TOCVS,
    WRAP_FROMCVS,
    /* -k wrapper option.  Default keyword expansion options.  */
    WRAP_RCSOPTION
} WrapMergeHas;

void  wrap_setup PROTO((void));
int   wrap_name_has PROTO((const char *name,WrapMergeHas has));
char *wrap_rcsoption PROTO ((const char *fileName, int asFlag));
char *wrap_tocvs_process_file PROTO((const char *fileName));
int   wrap_merge_is_copy PROTO((const char *fileName));
void wrap_fromcvs_process_file PROTO ((const char *fileName));
void wrap_add_file PROTO((const char *file,int temp));
void wrap_add PROTO((char *line,int temp));
void wrap_send PROTO ((void));
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
void wrap_unparse_rcs_options PROTO ((char **, int));
#endif /* SERVER_SUPPORT || CLIENT_SUPPORT */

/* Pathname expansion */
char *expand_path PROTO((char *name, char *file, int line));

/* User variables.  */
extern List *variable_list;

extern void variable_set PROTO ((char *nameval));

int watch PROTO ((int argc, char **argv));
int edit PROTO ((int argc, char **argv));
int unedit PROTO ((int argc, char **argv));
int editors PROTO ((int argc, char **argv));
int watchers PROTO ((int argc, char **argv));
extern int annotate PROTO ((int argc, char **argv));
extern int add PROTO ((int argc, char **argv));
extern int admin PROTO ((int argc, char **argv));
extern int checkout PROTO ((int argc, char **argv));
extern int commit PROTO ((int argc, char **argv));
extern int diff PROTO ((int argc, char **argv));
extern int history PROTO ((int argc, char **argv));
extern int import PROTO ((int argc, char **argv));
extern int cvslog PROTO ((int argc, char **argv));
#ifdef AUTH_CLIENT_SUPPORT
extern int login PROTO((int argc, char **argv));
int logout PROTO((int argc, char **argv));
#endif /* AUTH_CLIENT_SUPPORT */
extern int patch PROTO((int argc, char **argv));
extern int release PROTO((int argc, char **argv));
extern int cvsremove PROTO((int argc, char **argv));
extern int rtag PROTO((int argc, char **argv));
extern int cvsstatus PROTO((int argc, char **argv));
extern int cvstag PROTO((int argc, char **argv));
extern int version PROTO((int argc, char **argv));

extern unsigned long int lookup_command_attribute PROTO((char *));

#if defined(AUTH_CLIENT_SUPPORT) || defined(AUTH_SERVER_SUPPORT)
char *scramble PROTO ((char *str));
char *descramble PROTO ((char *str));
#endif /* AUTH_CLIENT_SUPPORT || AUTH_SERVER_SUPPORT */

#ifdef AUTH_CLIENT_SUPPORT
char *get_cvs_password PROTO((void));
int get_cvs_port_number PROTO((const cvsroot_t *root));
char *normalize_cvsroot PROTO((const cvsroot_t *root));
#endif /* AUTH_CLIENT_SUPPORT */

extern void tag_check_valid PROTO ((char *, int, char **, int, int, char *));
extern void tag_check_valid_join PROTO ((char *, int, char **, int, int,
					 char *));

#include "server.h"

/* From server.c and documented there.  */
extern void cvs_output PROTO ((const char *, size_t));
extern void cvs_output_binary PROTO ((char *, size_t));
extern void cvs_outerr PROTO ((const char *, size_t));
extern void cvs_flusherr PROTO ((void));
extern void cvs_flushout PROTO ((void));
extern void cvs_output_tagged PROTO ((char *, char *));

extern char *global_session_id;
@


1.27
log
@backport commitid support from newer CVS (with a different random id
generator)

writing a commitid is currently disabled

ok deraadt
@
text
@d521 1
a521 1
time_t get_date PROTO((char *date, struct timeb *now));
@


1.26
log
@Add a CVSROOT/config option "DisableMdocdate" (default:no) to turn off
the OpenBSD-specific Mdocdate expansion. This is useful to avoid
conflicts that arise between the server's expansion of Mdocdate and
the upstream code when maintaining forked OpenBSD derived code on an
OpenBSD CVS server.

"I must grudgingly agree that this is neccessary" deraadt@@
@
text
@d910 2
@


1.25
log
@Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.

ok millert@@
@
text
@d372 1
@


1.24
log
@Merge local changes; work in progress
@
text
@d44 4
@


1.24.10.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@a43 4
/* Begin GNULIB headers.  */
#include "xsize.h"
/* End GNULIB headers.  */

@


1.24.12.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@a43 4
/* Begin GNULIB headers.  */
#include "xsize.h"
/* End GNULIB headers.  */

@


1.23
log
@Integrate local changes
@
text
@d319 1
a319 1
    CHECKOUT, TAG, PATCH, EXPORT
d372 1
a372 1
  local_method, server_method, pserver_method, kserver_method, gserver_method,
d378 13
a395 7
extern char *CVSroot_original;	/* the active, complete CVSroot string */
extern int client_active;	/* nonzero if we are doing remote access */
extern CVSmethod CVSroot_method; /* one of the enum values above */
extern char *CVSroot_username;	/* the username or NULL if method == local */
extern char *CVSroot_hostname;	/* the hostname or NULL if method == local */
extern char *CVSroot_directory;	/* the directory name */

d399 1
a399 1
extern char *current_root;
d435 3
a437 2
extern int diff_exec PROTO ((char *file1, char *file2, char *options,
			     char *out));
d457 3
a459 1
void date_to_internet PROTO ((char *, char *));
d466 3
a468 2
int parse_cvsroot PROTO((char *CVSroot));
void set_local_cvsroot PROTO((char *dir));
d482 1
d505 1
d529 2
a530 1
void lock_tree_for_write PROTO ((int argc, char **argv, int local, int aflag));
a566 1
char *backup_file PROTO((const char *file, const char *suffix));
d646 2
a647 1
		int local_specified, int run_module_prog, char *extra_arg));
d665 2
d668 1
a797 1
#ifdef SERVER_SUPPORT
a798 1
#endif
d888 2
@


1.22
log
@Integrate local changes
@
text
@d396 1
d507 1
a507 1
				int nonbranch, int warn));
d533 1
a533 1
void fperror PROTO((FILE * fp, int status, int errnum, char *message,...));
d554 1
d586 1
a586 1
typedef	int (*CALLBACKPROC)	PROTO((int *pargc, char *argv[], char *where,
d645 1
d863 1
d880 2
a888 4

#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
#include "server.h"
#endif
@


1.21
log
@Integrate local changes
@
text
@d468 1
a468 1
char *xmalloc PROTO((size_t bytes));
@


1.20
log
@Integrate local changes
@
text
@d373 1
a373 1
  ext_method
d378 5
d390 5
d404 5
a408 5
#ifdef AUTH_SERVER_SUPPORT
extern char *Pserver_Repos;     /* used to check that same repos is
                                   transmitted in pserver auth and in
                                   CVS protocol. */
#endif /* AUTH_SERVER_SUPPORT */
d449 1
d520 3
d649 1
a669 1
int filter_stream_through_program PROTO((int, int, char **, pid_t *));
@


1.19
log
@Integrate local changes
@
text
@d392 2
@


1.18
log
@Integrate local changes
@
text
@d436 2
a484 1
int link_file PROTO ((const char *from, const char *to));
d842 1
a842 1
extern int status PROTO((int argc, char **argv));
@


1.17
log
@Merge local changes to support a configuration file with Cyclic's scheme
@
text
@d409 1
d430 1
a430 1
List *Entries_Open PROTO((int aflag));
d469 1
d474 1
d737 3
@


1.16
log
@Integrate local changes
@
text
@a474 1
void parseopts PROTO ((const char *root));
@


1.15
log
@Integrate local changes
@
text
@d130 2
d149 2
d189 1
a189 1
#define CVSROOTADM_OPTIONS	"options"
d214 4
a217 5
/* Set if CVS does _not_ need to create a CVS/Root file upon
   completion of this command.  The name is confusing, both because
   the meaning is closer to "does not use working directory" than
   "uses working directory" and because the flag isn't really as
   general purpose as it seems (cvs release sets it).  */
a246 3
#define	FALSE		0
#define	TRUE		1

d257 1
a257 1
#define	CVSREAD_DFLT	FALSE		/* writable files by default */
a260 3
#define	RCSBIN_ENV	"RCSBIN"	/* RCS binary directory */
/* #define	RCSBIN_DFLT		   Set by options.h */

d303 2
d306 2
d309 1
d361 1
a361 1
extern char *Rcsbin, *Tmpdir, *Editor;
d372 2
a373 1
  local_method, server_method, pserver_method, kserver_method, ext_method
d385 2
d402 1
a402 6
int RCS_exec_settag PROTO((const char *, const char *, const char *));
int RCS_exec_deltag PROTO((const char *, const char *, int));
int RCS_exec_setbranch PROTO((const char *, const char *));
int RCS_exec_lock PROTO((const char *, const char *, int));
int RCS_exec_unlock PROTO((const char *, const char *, int));
int RCS_merge PROTO((const char *, const char *, const char *, const char *));
d409 11
a419 2
int RCS_checkin PROTO ((char *rcsfile, char *workfile, char *message,
			char *rev, int flags));
d433 1
d436 2
a437 1

d447 2
a448 3
int same_directories PROTO((char *dir1, char *dir2));
char *Short_Repository PROTO((char *repository));
char *gca PROTO((char *rev1, char *rev2));
d461 2
d478 2
d488 4
a491 3
void Create_Admin PROTO((char *dir, char *update_dir,
			 char *repository, char *tag, char *date,
			 int nonbranch));
d529 1
a529 1
void line2argv PROTO ((int *pargc, char ***argv, char *line));
d566 1
a566 1
	char *mwhere, char *mfile, int horten, int local_specified,
d627 3
a629 1
extern int file_has_markers PROTO ((struct file_info *));
d642 3
a644 8
#ifdef HAVE_VPRINTF
void run_setup PROTO((const char *fmt,...));
void run_args PROTO((const char *fmt,...));
#else
void run_setup ();
void run_args ();
#endif
int run_exec PROTO((char *stin, char *stout, char *sterr, int flags));
d664 10
a673 4
     * it can have the following special values:
     *    empty = no user file
     *    0 = user file is new
     *    -vers = user file to be removed.  */
d696 2
a697 1
    /* Options from CVS/Entries (keyword expansion).  */
d736 5
d802 3
d854 1
d856 1
d860 1
@


1.14
log
@Allow a private tag when we expand RCS identifiers ourselves as well.
@
text
@d426 2
d432 4
d447 1
@


1.13
log
@Integrate local changes
@
text
@d366 1
@


1.12
log
@Integrate local changes
@
text
@d331 2
a401 2
int RCS_exec_checkout PROTO ((char *rcsfile, char *workfile, char *tag,
			      char *options, char *sout));
d467 2
a468 1
			 char *repository, char *tag, char *date));
a481 1
void ParseTag PROTO((char **tagp, char **datep));
d483 3
a485 1
void WriteTag PROTO((char *dir, char *tag, char *date));
d660 3
a662 1
       It is NULL if there is no file in the working directory.  */
d685 3
@


1.11
log
@Integrate local changes
@
text
@d519 5
@


1.10
log
@Integrate local changes
@
text
@d2 8
d101 4
a104 1
/* XXX - for now this is static */
d113 2
a114 10
/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 *
 * Definitions for the CVS Administrative directory and the files it contains.
 * Here as #define's to make changing the names a simple task.
 */
d209 7
d217 1
d289 4
a292 10
/*
 * The maximum number of files per each CVS directory. This is mainly for
 * sizing arrays statically rather than dynamically.  3000 seems plenty for
 * now.
 */
#define	MAXFILEPERDIR	3000
#define	MAXLINELEN	5000		/* max input line from a file */
#define	MAXPROGLEN	30000		/* max program length to system() */
#define	MAXLISTLEN	40000		/* For [A-Z]list holders */
#define MAXDATELEN	50		/* max length for a date */
d434 1
d437 1
d440 1
d504 1
a504 1
void line2argv PROTO((int *pargc, char *argv[], char *line));
d754 1
a754 1
char *wrap_fromcvs_process_file PROTO((const char *fileName));
d783 1
@


1.9
log
@Undo CVSroot change in main.c
Pass CVS root directory as an argument to parseopts()
Add prototype for parseopts()
@
text
@a0 2
/* $CVSid: @@(#)cvs.h 1.86 94/10/22 $	 */

d171 1
d179 3
d204 5
d210 3
d214 5
d379 6
a434 1
int Reader_Lock PROTO((char *xrepository));
a436 1
int Writer_Lock PROTO((List * list));
d461 3
d470 2
a471 3
/* Remove locks set by lock_tree_for_write.  Currently removes readlocks
   too.  */
void lock_tree_cleanup PROTO ((void));
a479 1
void (*error_set_cleanup PROTO((void (*) (void)))) PROTO ((void));
a510 1
void strip_path PROTO((char *path));
d525 2
d589 1
d724 4
d765 19
a796 2
extern void tag_lockdir PROTO ((char *));
extern void tag_unlockdir PROTO ((void));
d801 1
@


1.8
log
@Integrate local changes
@
text
@d428 1
@


1.7
log
@retain -Z options to rcs commands even though they do not work (rcs
commands spawn children which do not inherit the -Z option...) but also
look in the RCSLOCALID environment variable. cvs sets this to "OpenBSD",
as read from the options file.
@
text
@a78 1
#include "server.h"
a103 6
/* just in case this implementation does not define this */
#ifndef L_tmpnam
#define	L_tmpnam	50
#endif


d236 4
a239 1
/* #define	RCSBIN_DFLT		   Set by config.h */
d244 1
a244 1
/* #define	EDITOR_DFLT		   Set by config.h */
d253 1
a253 1
/* #define	CVSUMASK_DFLT		   Set by config.h */
d274 6
d283 1
a300 81
 * defines for Classify_File() to determine the current state of a file.
 * These are also used as types in the data field for the list we make for
 * Update_Logfile in commit, import, and add.
 */
enum classify_type
{
    T_UNKNOWN = 1,			/* no old-style analog existed	 */
    T_CONFLICT,				/* C (conflict) list		 */
    T_NEEDS_MERGE,			/* G (needs merging) list	 */
    T_MODIFIED,				/* M (needs checked in) list 	 */
    T_CHECKOUT,				/* O (needs checkout) list	 */
    T_ADDED,				/* A (added file) list		 */
    T_REMOVED,				/* R (removed file) list	 */
    T_REMOVE_ENTRY,			/* W (removed entry) list	 */
    T_UPTODATE,				/* File is up-to-date		 */
#ifdef SERVER_SUPPORT
    T_PATCH,				/* P Like C, but can patch	 */
#endif
    T_TITLE				/* title for node type 		 */
};
typedef enum classify_type Ctype;

/*
 * a struct vers_ts contains all the information about a file including the
 * user and rcs file names, and the version checked out and the head.
 *
 * this is usually obtained from a call to Version_TS which takes a tag argument
 * for the RCS file if desired
 */
struct vers_ts
{
    /* rcs version user file derives from, from CVS/Entries.
     * it can have the following special values:
     *    empty = no user file
     *    0 = user file is new
     *    -vers = user file to be removed.  */
    char *vn_user;

    /* Numeric revision number corresponding to ->vn_tag (->vn_tag
       will often be symbolic).  */
    char *vn_rcs;
    /* If ->tag corresponds to a tag which really exists in this file,
       this is just a copy of ->tag.  If not, this is either NULL or
       the head revision.  (Or something like that, see RCS_getversion
       and friends).  */
    char *vn_tag;

    /* This is the timestamp from stating the file in the working directory.
       It is NULL if there is no file in the working directory.  */
    char *ts_user;
    /* Timestamp from CVS/Entries.  For the server, ts_user and ts_rcs
       are computed in a slightly different way, but the fact remains that
       if they are equal the file in the working directory is unmodified
       and if they differ it is modified.  */
    char *ts_rcs;

    /* Options from CVS/Entries (keyword expansion).  */
    char *options;

    /* If non-NULL, there was a conflict (or merely a merge?  See merge_file)
       and the time stamp in this field is the time stamp of the working
       directory file which was created with the conflict markers in it.
       This is from CVS/Entries.  */
    char *ts_conflict;

    /* Tag specified on the command line, or if none, tag stored in
       CVS/Entries.  */
    char *tag;
    /* Date specified on the command line, or if none, date stored in
       CVS/Entries.  */
    char *date;

    /* Pointer to entries file node  */
    Entnode *entdata;

    /* Pointer to parsed src file info */
    RCSNode *srcfile;
};
typedef struct vers_ts Vers_TS;

/*
d302 1
a302 1
 * Version_TS().
d306 2
d311 4
a314 1
    char *options;
d330 3
d334 1
d337 1
a337 2
extern char *Rcsbin, *Editor, *CVSroot;
extern char *CVSADM_Root;
d345 14
d368 5
a372 5
int RCS_settag PROTO((const char *, const char *, const char *));
int RCS_deltag PROTO((const char *, const char *, int));
int RCS_setbranch PROTO((const char *, const char *));
int RCS_lock PROTO((const char *, const char *, int));
int RCS_unlock PROTO((const char *, const char *, int));
d374 2
a375 3
int RCS_checkout PROTO ((char *rcsfile, char *workfile, char *tag,
			 char *options,
                         char *sout, int flags, int noerr));
d378 4
a381 5
#define RCS_FLAGS_LOCK 1
#define RCS_FLAGS_FORCE 2
#define RCS_FLAGS_DEAD 4
#define RCS_FLAGS_QUIET 8
#define RCS_FLAGS_MODTIME 16
d383 1
a383 1
			char *rev, int flags, int noerr));
d391 1
a391 1
List *Find_Directories PROTO((char *repository, int which));
d394 3
d400 2
a411 2
int No_Difference PROTO((char *file, Vers_TS * vers, List * entries,
			 char *repository, char *update_dir));
d427 1
a460 1
void freevers_ts PROTO((Vers_TS ** versp));
d469 1
a469 1
extern void ignore_files PROTO ((List *, char *, Ignore_proc));
d478 1
a495 7
int Checkin PROTO((int type, char *file, char *update_dir,
		   char *repository, char *rcs, char *rev,
		   char *tag, char *options, char *message, List *entries));
Ctype Classify_File PROTO((char *file, char *tag, char *date, char *options,
		     int force_tag_match, int aflag, char *repository,
		     List *entries, RCSNode *rcsnode, Vers_TS **versp,
		     char *update_dir, int pipeout));
d500 2
a501 5
void Update_Logfile PROTO((char *repository, char *xmessage, char *xrevision,
		     FILE * xlogfp, List * xchanges));
Vers_TS *Version_TS PROTO((char *repository, char *options, char *tag,
		     char *date, char *user, int force_tag_match,
		     int set_time, List * entries, RCSNode * rcs));
d538 9
a546 4
typedef	int (*FILEPROC)		PROTO((struct file_info *finfo));
typedef	int (*FILESDONEPROC)	PROTO((int err, char *repository, char *update_dir));
typedef	Dtype (*DIRENTPROC)	PROTO((char *dir, char *repos, char *update_dir));
typedef	int (*DIRLEAVEPROC)	PROTO((char *dir, int err, char *update_dir));
a553 4
int do_recursion PROTO((FILEPROC xfileproc, FILESDONEPROC xfilesdoneproc,
		  DIRENTPROC xdirentproc, DIRLEAVEPROC xdirleaveproc,
		  Dtype xflags, int xwhich, int xaflag, int xreadlock,
		  int xdosrcs));
d558 1
d561 1
a561 1
		     int dosrcs, int wd_is_repos));
d596 107
d706 7
a712 1
typedef enum { WRAP_TOCVS, WRAP_FROMCVS, WRAP_CONFLICT } WrapMergeHas;
d716 1
d722 1
d744 4
d749 8
d758 3
a760 2
extern void cvs_output PROTO ((char *, size_t));
extern void cvs_outerr PROTO ((char *, size_t));
@


1.6
log
@new extension: the $CVSROOT/CVSROOT/options file (if it exists) supports:
    tag=-ZOpenBSD (passes -ZOpenBSD to co/ci)
    umask=002 (force a umask while cvs is running)
    dlimit=49152 (force a 48MB process data limit)
@
text
@a418 1
extern char *RCS_citag;		/* special -Z tag for RCS */
@


1.5
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d187 1
d419 1
@


1.4
log
@Integrate local changes to CVS
@
text
@d121 17
d153 3
a189 4
/* support for the modules file (CVSROOTADM_MODULES) */
#define	CVSMODULE_OPTS	"ad:i:lo:e:s:t:u:"/* options in modules file */
#define CVSMODULE_SPEC	'&'		/* special delimiter */

a199 1
#define	CVSTFL		"#cvs.tfl"
d213 5
d222 1
d422 1
d448 1
a448 1
List *Find_Dirs PROTO((char *repository, int which));
d461 1
a461 1
char *xrealloc PROTO((char *ptr, size_t bytes));
a471 1
int ign_name PROTO((char *name));
d516 1
d525 1
d533 10
d554 1
a554 1
		     List *entries, List *srcfiles, Vers_TS **versp,
d564 1
a564 1
		     int set_time, List * entries, List * xfiles));
d586 5
d598 1
a598 3
    /* The pre-parsed versions of the RCS files.  This is filled in only
       if dosrcs was passed as nonzero to start_recursion.  */
    List *srcfiles;
d607 1
d625 1
a625 1
void read_cvsrc PROTO((int *argc, char ***argv));
d683 1
@


1.3
log
@Integrate local changes
@
text
@a13 19
/* AIX requires this to be the first thing in the file. */
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not __GNUC__ */
#if HAVE_ALLOCA_H
#include <alloca.h>
#else /* not HAVE_ALLOCA_H */
#ifdef _AIX
 #pragma alloca
#else /* not _AIX */
#ifdef ALLOCA_IN_STDLIB
 /* then we need do nothing */
#else
char *alloca ();
#endif /* not ALLOCA_IN_STDLIB */
#endif /* not _AIX */
#endif /* not HAVE_ALLOCA_H */
#endif /* not __GNUC__ */

a30 7
#if __GNUC__ == 2
#define USE(var) static const char sizeof##var = sizeof(sizeof##var) + sizeof(var)
#else
#define USE(var) static const char standalone_semis_illegal_sigh
#endif


a92 5
/* Define to enable alternate death support (which uses the RCS state).  */
#define DEATH_STATE 1

#define DEATH_SUPPORT 1

a384 1
#ifdef CVSADM_ROOT
a386 1
#endif /* CVSADM_ROOT */
d407 14
a430 1
#ifdef CVSADM_ROOT
a433 1
#endif /* CVSADM_ROOT */
d459 1
d538 28
a565 2
typedef	int (*FILEPROC)		PROTO((char *file, char *update_dir, char *repository,
	List *	entries, List *	srcfiles));
d570 2
d613 1
a613 1
FILE *Popen PROTO((const char *, const char *));
a629 2
/* Pathname expansion */
char *expand_path PROTO((char *name));
d633 8
d653 3
@


1.2
log
@CVSREADONLYFS environment variable short-circuits read-only lock requirements
@
text
@d24 3
d28 1
d59 5
d87 1
a87 1
#include <fnmatch.h>		/* This is supposed to be available on Posix systems */
d162 15
d192 1
d195 4
a198 1
#define CVSROOTADM_WRAPPER      "cvswrappers"
a218 1
#define	CVSEXT_OPT	",p"
d265 3
d290 1
d338 46
a383 17
    char *vn_user;			/* rcs version user file derives from
					 * it can have the following special
					 * values:
					 *    empty = no user file
					 *    0 = user file is new
					 *    -vers = user file to be removed */
    char *vn_rcs;			/* the version for the rcs file
					 * (tag version?) 	 */
    char *ts_user;			/* the timestamp for the user file */
    char *ts_rcs;			/* the user timestamp from entries */
    char *options;			/* opts from Entries file
					 * (keyword expansion)	 */
    char *ts_conflict;			/* Holds time_stamp of conflict */
    char *tag;				/* tag stored in the Entries file */
    char *date;				/* date stored in the Entries file */
    Entnode *entdata;			/* pointer to entries file node  */
    RCSNode *srcfile;			/* pointer to parsed src file info */
d414 1
a414 1
extern char *program_name, *command_name;
d424 1
d462 1
d465 2
a466 1
int Parse_Info PROTO((char *infofile, char *repository, int PROTO((*callproc)) PROTO(()), int all));
d468 2
a469 1
int SIG_register PROTO((int sig, RETSIGTYPE PROTO((*fn)) PROTO(())));
d477 1
a480 1
int joining PROTO((void));
d483 1
d488 1
d492 1
d494 9
d514 1
d520 6
d554 10
d565 4
a568 4
	       int PROTO((*callback_proc)) (), char *where, int shorten,
	       int local_specified, int run_module_prog, char *extra_arg));
int do_recursion PROTO((int PROTO((*xfileproc)) (), int PROTO((*xfilesdoneproc)) (),
		  Dtype PROTO((*xdirentproc)) (), int PROTO((*xdirleaveproc)) (),
a570 4
int do_update PROTO((int argc, char *argv[], char *xoptions, char *xtag,
	       char *xdate, int xforce, int local, int xbuild,
	       int xaflag, int xprune, int xpipeout, int which,
	       char *xjoin_rev1, char *xjoin_rev2, char *preload_update_dir));
d573 2
a574 2
int start_recursion PROTO((int PROTO((*fileproc)) (), int PROTO((*filesdoneproc)) (),
		     Dtype PROTO((*direntproc)) (), int PROTO((*dirleaveproc)) (),
d611 1
a611 1

d622 2
d626 13
@


1.1
log
@Initial revision
@
text
@d222 2
d367 1
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a23 3
#ifdef ALLOCA_IN_STDLIB
 /* then we need do nothing */
#else
a24 1
#endif /* not ALLOCA_IN_STDLIB */
a54 5
/* Under OS/2, <stdio.h> doesn't define popen()/pclose(). */
#ifdef USE_OWN_POPEN
#include "popen.h"
#endif

d78 1
a78 1
#include <fnmatch.h> /* This is supposed to be available on Posix systems */
a152 15
#define CVSADM_NOTIFY	"CVS/Notify"
#define CVSADM_NOTIFYTMP "CVS/Notify.tmp"
/* A directory in which we store base versions of files we currently are
   editing with "cvs edit".  */
#define CVSADM_BASE     "CVS/Base"

/* This is the special directory which we use to store various extra
   per-directory information in the repository.  It must be the same as
   CVSADM to avoid creating a new reserved directory name which users cannot
   use, but is a separate #define because if anyone changes it (which I don't
   recommend), one needs to deal with old, unconverted, repositories.
   
   See fileattr.h for details about file attributes, the only thing stored
   in CVSREP currently.  */
#define CVSREP "CVS"
a167 1
#define CVSROOTADM_VALTAGS	"val-tags"
d170 1
a170 4
#define CVSROOTADM_WRAPPER	"cvswrappers"
#define CVSROOTADM_NOTIFY	"notify"
#define CVSROOTADM_USERS	"users"

d191 1
a235 3
#define	CVSUMASK_ENV	"CVSUMASK"	/* Effective umask for repository */
/* #define	CVSUMASK_DFLT		   Set by config.h */

a257 1
    char *user;
d305 17
a321 46
    /* rcs version user file derives from, from CVS/Entries.
     * it can have the following special values:
     *    empty = no user file
     *    0 = user file is new
     *    -vers = user file to be removed.  */
    char *vn_user;

    /* Numeric revision number corresponding to ->vn_tag (->vn_tag
       will often be symbolic).  */
    char *vn_rcs;
    /* If ->tag corresponds to a tag which really exists in this file,
       this is just a copy of ->tag.  If not, this is either NULL or
       the head revision.  (Or something like that, see RCS_getversion
       and friends).  */
    char *vn_tag;

    /* This is the timestamp from stating the file in the working directory.
       It is NULL if there is no file in the working directory.  */
    char *ts_user;
    /* Timestamp from CVS/Entries.  For the server, ts_user and ts_rcs
       are computed in a slightly different way, but the fact remains that
       if they are equal the file in the working directory is unmodified
       and if they differ it is modified.  */
    char *ts_rcs;

    /* Options from CVS/Entries (keyword expansion).  */
    char *options;

    /* If non-NULL, there was a conflict (or merely a merge?  See merge_file)
       and the time stamp in this field is the time stamp of the working
       directory file which was created with the conflict markers in it.
       This is from CVS/Entries.  */
    char *ts_conflict;

    /* Tag specified on the command line, or if none, tag stored in
       CVS/Entries.  */
    char *tag;
    /* Date specified on the command line, or if none, date stored in
       CVS/Entries.  */
    char *date;

    /* Pointer to entries file node  */
    Entnode *entdata;

    /* Pointer to parsed src file info */
    RCSNode *srcfile;
d352 1
a352 1
extern char *program_name, *program_path, *command_name;
a361 1
extern mode_t cvsumask;
a397 1
void strip_trailing_newlines PROTO((char *str));
d400 1
a400 2
typedef	int (*CALLPROC)	PROTO((char *repository, char *value));
int Parse_Info PROTO((char *infofile, char *repository, CALLPROC callproc, int all));
d402 1
a402 2
typedef	RETSIGTYPE (*SIGCLEANUPPROC)	PROTO(());
int SIG_register PROTO((int sig, SIGCLEANUPPROC sigcleanup));
a409 1
int isaccessible PROTO((const char *file, const int mode));
d413 1
a415 1
int link_file PROTO ((const char *from, const char *to));
a419 1
void *valloc PROTO((size_t bytes));
a422 1

a423 9

/* Writelock an entire subtree, well the part specified by ARGC, ARGV, LOCAL,
   and AFLAG, anyway.  */
void lock_tree_for_write PROTO ((int argc, char **argv, int local, int aflag));

/* Remove locks set by lock_tree_for_write.  Currently removes readlocks
   too.  */
void lock_tree_cleanup PROTO ((void));

a434 1

a439 6
typedef void (*Ignore_proc) PROTO ((char *, char *));
extern void ignore_files PROTO ((List *, char *, Ignore_proc));
extern int ign_inhibit_server;

#include "update.h"

a467 10

typedef	int (*CALLBACKPROC)	PROTO((int *pargc, char *argv[], char *where,
	char *mwhere, char *mfile, int horten, int local_specified,
	char *omodule, char *msg));
typedef	int (*FILEPROC)		PROTO((char *file, char *update_dir, char *repository,
	List *	entries, List *	srcfiles));
typedef	int (*FILESDONEPROC)	PROTO((int err, char *repository, char *update_dir));
typedef	Dtype (*DIRENTPROC)	PROTO((char *dir, char *repos, char *update_dir));
typedef	int (*DIRLEAVEPROC)	PROTO((char *dir, int err, char *update_dir));

d469 4
a472 4
		CALLBACKPROC callback_proc, char *where, int shorten,
		int local_specified, int run_module_prog, char *extra_arg));
int do_recursion PROTO((FILEPROC xfileproc, FILESDONEPROC xfilesdoneproc,
		  DIRENTPROC xdirentproc, DIRLEAVEPROC xdirleaveproc,
d475 4
d481 2
a482 2
int start_recursion PROTO((FILEPROC fileproc, FILESDONEPROC filesdoneproc,
		     DIRENTPROC direntproc, DIRLEAVEPROC dirleaveproc,
d519 1
a519 1

a529 2
/* Pathname expansion */
char *expand_path PROTO((char *name));
a531 13

int watch PROTO ((int argc, char **argv));
int edit PROTO ((int argc, char **argv));
int unedit PROTO ((int argc, char **argv));
int editors PROTO ((int argc, char **argv));
int watchers PROTO ((int argc, char **argv));

#if defined(AUTH_CLIENT_SUPPORT) || defined(AUTH_SERVER_SUPPORT)
char *scramble PROTO ((char *str));
char *descramble PROTO ((char *str));
#endif /* AUTH_CLIENT_SUPPORT || AUTH_SERVER_SUPPORT */

extern void tag_check_valid PROTO ((char *, int, char **, int, int, char *));
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d14 19
d50 7
d119 5
d414 1
d417 1
a436 14
int RCS_checkout PROTO ((char *rcsfile, char *workfile, char *tag,
			 char *options,
                         char *sout, int flags, int noerr));
/* Flags used by RCS_* functions.  See the description of the individual
   functions for which flags mean what for each function.  */
#define RCS_FLAGS_LOCK 1
#define RCS_FLAGS_FORCE 2
#define RCS_FLAGS_DEAD 4
#define RCS_FLAGS_QUIET 8
#define RCS_FLAGS_MODTIME 16
int RCS_checkin PROTO ((char *rcsfile, char *workfile, char *message,
			char *rev, int flags, int noerr));


d447 1
d451 1
a476 1
char *get_homedir PROTO ((void));
d555 2
a556 28

/* This is the structure that the recursion processor passes to the
   fileproc to tell it about a particular file.  */
struct file_info
{
    /* Name of the file, without any directory component.  */
    char *file;

    /* Name of the directory we are in, relative to the directory in
       which this command was issued.  We have cd'd to this directory
       (either in the working directory or in the repository, depending
       on which sort of recursion we are doing).  If we are in the directory
       in which the command was issued, this is "".  */
    char *update_dir;

    /* Name of the directory corresponding to the repository which contains
       this file.  */
    char *repository;

    /* The pre-parsed entries for this directory.  */
    List *entries;

    /* The pre-parsed versions of the RCS files.  This is filled in only
       if dosrcs was passed as nonzero to start_recursion.  */
    List *srcfiles;
};

typedef	int (*FILEPROC)		PROTO((struct file_info *finfo));
a560 2
extern int mkmodules PROTO ((char *dir));

d602 1
a602 1
FILE *run_popen PROTO((const char *, const char *));
d619 2
a623 8
/* Pathname expansion */
char *expand_path PROTO((char *name, char *file, int line));

/* User variables.  */
extern List *variable_list;

extern void variable_set PROTO ((char *nameval));

a635 3

extern void cvs_output PROTO ((char *, size_t));
extern void cvs_outerr PROTO ((char *, size_t));
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a120 17

#ifdef USE_VMS_FILENAMES
#define CVSADM          "CVS"
#define CVSADM_ENT      "CVS/Entries."
#define CVSADM_ENTBAK   "CVS/Entries.Backup"
#define CVSADM_ENTLOG   "CVS/Entries.Log"
#define CVSADM_ENTSTAT  "CVS/Entries.Static"
#define CVSADM_REP      "CVS/Repository."
#define CVSADM_ROOT     "CVS/Root."
#define CVSADM_CIPROG   "CVS/Checkin.prog"
#define CVSADM_UPROG    "CVS/Update.prog"
#define CVSADM_TAG      "CVS/Tag."
#define CVSADM_NOTIFY   "CVS/Notify."
#define CVSADM_NOTIFYTMP "CVS/Notify.tmp"
#define CVSADM_BASE      "CVS/Base"
#define CVSADM_TEMPLATE "CVS/Template."
#else /* USE_VMS_FILENAMES */
a135 3
/* File which contains the template for use in log messages.  */
#define CVSADM_TEMPLATE "CVS/Template"
#endif /* USE_VMS_FILENAMES */
d170 4
d184 1
a197 5

#ifdef USE_VMS_FILENAMES
#define BAKPREFIX       "_$"
#define DEVNULL         "NLA0:"
#else /* USE_VMS_FILENAMES */
a201 1
#endif /* USE_VMS_FILENAMES */
a397 1

d423 1
a423 1
List *Find_Directories PROTO((char *repository, int which));
d436 1
a436 1
void *xrealloc PROTO((void *ptr, size_t bytes));
d447 1
a491 1
extern int ign_name PROTO ((char *name));
a499 1
extern int ign_case;
a506 10
/* Expand wildcards in each element of (ARGC,ARGV).  This is according to the
   files which exist in the current directory, and accordingly to OS-specific
   conventions regarding wildcard syntax.  It might be desirable to change the
   former in the future (e.g. "cvs status *.h" including files which don't exist
   in the working directory).  The result is placed in *PARGC and *PARGV;
   the *PARGV array itself and all the strings it contains are newly
   malloc'd.  It is OK to call it with PARGC == &ARGC or PARGV == &ARGV.  */
extern void expand_wild PROTO ((int argc, char **argv, 
                                int *pargc, char ***pargv));

d518 1
a518 1
		     List *entries, RCSNode *rcsnode, Vers_TS **versp,
d528 1
a528 1
		     int set_time, List * entries, RCSNode * rcs));
a549 5
    /* update_dir and file put together, with a slash between them as
       necessary.  This is the proper way to refer to the file in user
       messages.  */
    char *fullname;

d557 3
a559 1
    RCSNode *rcs;
a567 1
extern int init PROTO ((int argc, char **argv));
d585 1
a585 1
void read_cvsrc PROTO((int *argc, char ***argv, char *cmdname));
a642 1
extern int annotate PROTO ((int argc, char **argv));
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d79 1
d105 6
d240 1
a240 4
/* #define	RCSBIN_DFLT		   Set by options.h */

#define	TMPDIR_ENV	"TMPDIR"	/* Temporary directory */
/* #define	TMPDIR_DFLT		   Set by options.h */
d245 1
a245 1
/* #define	EDITOR_DFLT		   Set by options.h */
d254 1
a254 1
/* #define	CVSUMASK_DFLT		   Set by options.h */
a274 6
/* The type of an entnode.  */
enum ent_type
{
    ENT_FILE, ENT_SUBDIR
};

a277 1
    enum ent_type type;
d295 81
d377 1
a377 1
 * Version_TS() and Find_Directories().
a380 2
    /* These fields pass sticky tag information from Entries_Open() to
       Version_TS().  */
d384 1
a384 4
    /* This field is set by Entries_Open() if there was subdirectory
       information; Find_Directories() uses it to see whether it needs
       to scan the directory itself.  */
    int subdirs;
a399 3
#ifdef ENUMS_CAN_BE_TROUBLE
typedef int Dtype;
#else
a400 1
#endif
d403 2
a404 1
extern char *Rcsbin, *Tmpdir, *Editor;
a411 14
/* Access method specified in CVSroot. */
typedef enum {
  local_method, server_method, pserver_method, kserver_method, ext_method
} CVSmethod;
extern char *method_names[];	/* change this in root.c if you change
				   the enum above */

extern char *CVSroot_original;	/* the active, complete CVSroot string */
extern int client_active;	/* nonzero if we are doing remote access */
extern CVSmethod CVSroot_method; /* one of the enum values above */
extern char *CVSroot_username;	/* the username or NULL if method == local */
extern char *CVSroot_hostname;	/* the hostname or NULL if method == local */
extern char *CVSroot_directory;	/* the directory name */

d420 5
a424 5
int RCS_exec_settag PROTO((const char *, const char *, const char *));
int RCS_exec_deltag PROTO((const char *, const char *, int));
int RCS_exec_setbranch PROTO((const char *, const char *));
int RCS_exec_lock PROTO((const char *, const char *, int));
int RCS_exec_unlock PROTO((const char *, const char *, int));
d426 3
a428 2
int RCS_exec_checkout PROTO ((char *rcsfile, char *workfile, char *tag,
			      char *options, char *sout));
d431 5
a435 4
#define RCS_FLAGS_FORCE 1
#define RCS_FLAGS_DEAD 2
#define RCS_FLAGS_QUIET 4
#define RCS_FLAGS_MODTIME 8
d437 1
a437 1
			char *rev, int flags));
d445 1
a445 1
List *Find_Directories PROTO((char *repository, int which, List *entries));
a447 3
void Subdirs_Known PROTO((List *entries));
void Subdir_Register PROTO((List *, const char *, const char *));
void Subdir_Deregister PROTO((List *, const char *, const char *));
a450 2
int parse_cvsroot PROTO((char *CVSroot));
void set_local_cvsroot PROTO((char *dir));
d461 2
a477 1
char *cvs_temp_name PROTO ((void));
d511 1
d520 1
a520 1
extern void ignore_files PROTO ((List *, List *, char *, Ignore_proc));
a528 1
extern int mkdir_if_needed PROTO ((char *name));
d546 7
d557 5
a561 2
void Update_Logfile PROTO((char *repository, char *xmessage, FILE * xlogfp,
		     List * xchanges));
d598 4
a601 9
typedef	int (*FILEPROC) PROTO ((void *callerdat, struct file_info *finfo));
typedef	int (*FILESDONEPROC) PROTO ((void *callerdat, int err,
				     char *repository, char *update_dir,
				     List *entries));
typedef	Dtype (*DIRENTPROC) PROTO ((void *callerdat, char *dir,
				    char *repos, char *update_dir,
				    List *entries));
typedef	int (*DIRLEAVEPROC) PROTO ((void *callerdat, char *dir, int err,
				    char *update_dir, List *entries));
d609 4
a616 1
		     void *callerdat,
d619 1
a619 1
		     int dosrcs));
a653 107
/*
 * a struct vers_ts contains all the information about a file including the
 * user and rcs file names, and the version checked out and the head.
 *
 * this is usually obtained from a call to Version_TS which takes a
 * tag argument for the RCS file if desired
 */
struct vers_ts
{
    /* rcs version user file derives from, from CVS/Entries.
     * it can have the following special values:
     *    empty = no user file
     *    0 = user file is new
     *    -vers = user file to be removed.  */
    char *vn_user;

    /* Numeric revision number corresponding to ->vn_tag (->vn_tag
       will often be symbolic).  */
    char *vn_rcs;
    /* If ->tag is a simple tag in the RCS file--a tag which really
       exists which is not a magic revision--and if ->date is NULL,
       then this is a copy of ->tag.  Otherwise, it is a copy of
       ->vn_rcs.  */
    char *vn_tag;

    /* This is the timestamp from stating the file in the working directory.
       It is NULL if there is no file in the working directory.  */
    char *ts_user;
    /* Timestamp from CVS/Entries.  For the server, ts_user and ts_rcs
       are computed in a slightly different way, but the fact remains that
       if they are equal the file in the working directory is unmodified
       and if they differ it is modified.  */
    char *ts_rcs;

    /* Options from CVS/Entries (keyword expansion).  */
    char *options;

    /* If non-NULL, there was a conflict (or merely a merge?  See merge_file)
       and the time stamp in this field is the time stamp of the working
       directory file which was created with the conflict markers in it.
       This is from CVS/Entries.  */
    char *ts_conflict;

    /* Tag specified on the command line, or if none, tag stored in
       CVS/Entries.  */
    char *tag;
    /* Date specified on the command line, or if none, date stored in
       CVS/Entries.  */
    char *date;

    /* Pointer to entries file node  */
    Entnode *entdata;

    /* Pointer to parsed src file info */
    RCSNode *srcfile;
};
typedef struct vers_ts Vers_TS;

Vers_TS *Version_TS PROTO ((struct file_info *finfo, char *options, char *tag,
			    char *date, int force_tag_match,
			    int set_time));
void freevers_ts PROTO ((Vers_TS ** versp));

/* Miscellaneous CVS infrastructure which layers on top of the recursion
   processor (for example, needs struct file_info).  */

int Checkin PROTO ((int type, struct file_info *finfo, char *rcs, char *rev,
		    char *tag, char *options, char *message));
int No_Difference PROTO ((struct file_info *finfo, Vers_TS *vers));

/*
 * defines for Classify_File() to determine the current state of a file.
 * These are also used as types in the data field for the list we make for
 * Update_Logfile in commit, import, and add.
 */
enum classify_type
{
    T_UNKNOWN = 1,			/* no old-style analog existed	 */
    T_CONFLICT,				/* C (conflict) list		 */
    T_NEEDS_MERGE,			/* G (needs merging) list	 */
    T_MODIFIED,				/* M (needs checked in) list 	 */
    T_CHECKOUT,				/* O (needs checkout) list	 */
    T_ADDED,				/* A (added file) list		 */
    T_REMOVED,				/* R (removed file) list	 */
    T_REMOVE_ENTRY,			/* W (removed entry) list	 */
    T_UPTODATE,				/* File is up-to-date		 */
#ifdef SERVER_SUPPORT
    T_PATCH,				/* P Like C, but can patch	 */
#endif
    T_TITLE				/* title for node type 		 */
};
typedef enum classify_type Ctype;

Ctype Classify_File PROTO
    ((struct file_info *finfo, char *tag, char *date, char *options,
      int force_tag_match, int aflag, Vers_TS **versp, int pipeout));

/*
 * structure used for list nodes passed to Update_Logfile() and
 * do_editor().
 */
struct logfile_info
{
  enum classify_type type;
  char *tag;
};

d657 1
a657 7
typedef enum {
    /* -t and -f wrapper options.  Treating directories as single files.  */
    WRAP_TOCVS,
    WRAP_FROMCVS,
    /* -k wrapper option.  Default keyword expansion options.  */
    WRAP_RCSOPTION
} WrapMergeHas;
a660 1
char *wrap_rcsoption PROTO ((const char *fileName, int asFlag));
a665 1
void wrap_send PROTO ((void));
a686 4
#ifdef AUTH_CLIENT_SUPPORT
char *get_cvs_password PROTO((void));
#endif /* AUTH_CLIENT_SUPPORT */

a687 8
extern void tag_check_valid_join PROTO ((char *, int, char **, int, int,
					 char *));
extern void tag_lockdir PROTO ((char *));
extern void tag_unlockdir PROTO ((void));

extern void cvs_output PROTO ((const char *, size_t));
extern void cvs_outerr PROTO ((const char *, size_t));
extern void cvs_flusherr PROTO ((void));
d689 2
a690 3
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
#include "server.h"
#endif
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d1 2
a172 1
#define CVSROOTADM_VERIFYMSG    "verifymsg"
a179 3
#define CVSROOTADM_READERS	"readers"
#define CVSROOTADM_WRITERS	"writers"
#define CVSROOTADM_PASSWD	"passwd"
a200 5
/* Command attributes -- see function lookup_command_attribute(). */
#define CVS_CMD_IGNORE_ADMROOT        1
#define CVS_CMD_USES_WORK_DIR         2
#define CVS_CMD_MODIFIES_REPOSITORY   4

a201 3

/* This is the string which is at the start of the non-log-message lines
   that we put up for the user when they edit the log message.  */
a202 5
/* Number of characters in CVSEDITPREFIX to compare when deciding to strip
   off those lines.  We don't check for the space, to accomodate users who
   have editors which strip trailing spaces.  */
#define CVSEDITPREFIXLEN 4

a359 6
#ifdef AUTH_SERVER_SUPPORT
extern char *Pserver_Repos;     /* used to check that same repos is
                                   transmitted in pserver auth and in
                                   CVS protocol. */
#endif /* AUTH_SERVER_SUPPORT */

d410 1
d413 1
a436 3
/* Locking subsystem (implemented in lock.c).  */

int Reader_Lock PROTO((char *xrepository));
d443 3
a445 2
/* See lock.c for description.  */
extern void lock_dir_for_write PROTO ((char *));
d454 1
d486 1
a500 2
void do_verify PROTO((char *message, char *repository));

a562 1
extern int file_has_markers PROTO ((struct file_info *));
a696 4
  char *rev_old;		/* rev number before a commit/modify,
				   NULL for add or import */
  char *rev_new;		/* rev number after a commit/modify,
				   add, or import, NULL for remove */
a733 19
extern int add PROTO ((int argc, char **argv));
extern int admin PROTO ((int argc, char **argv));
extern int checkout PROTO ((int argc, char **argv));
extern int commit PROTO ((int argc, char **argv));
extern int diff PROTO ((int argc, char **argv));
extern int history PROTO ((int argc, char **argv));
extern int import PROTO ((int argc, char **argv));
extern int cvslog PROTO ((int argc, char **argv));
#ifdef AUTH_CLIENT_SUPPORT
extern int login PROTO((int argc, char **argv));
#endif /* AUTH_CLIENT_SUPPORT */
extern int patch PROTO((int argc, char **argv));
extern int release PROTO((int argc, char **argv));
extern int cvsremove PROTO((int argc, char **argv));
extern int rtag PROTO((int argc, char **argv));
extern int status PROTO((int argc, char **argv));
extern int cvstag PROTO((int argc, char **argv));

extern unsigned long int lookup_command_attribute PROTO((char *));
d747 2
a752 1
extern void cvs_flushout PROTO ((void));
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a1 8
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS kit.
 */

/*
d93 1
a93 4
/* This actually gets set in system.h.  Note that the _ONLY_ reason for
   this is if various system calls (getwd, getcwd, readlink) require/want
   us to use it.  All other parts of CVS allocate pathname buffers
   dynamically, and we want to keep it that way.  */
d102 10
a111 2
/* Definitions for the CVS Administrative directory and the files it contains.
   Here as #define's to make changing the names a simple task.  */
a204 7

/* Set if CVS does _not_ need to create a CVS/Root file upon
   completion of this command.  The name is confusing, both because
   the meaning is closer to "does not use working directory" than
   "uses working directory" and because the flag isn't really as
   general purpose as it seems (cvs release sets it).  */

a205 1

d275 10
a284 4
/* Large enough to hold DATEFORM.  Not an arbitrary limit as long as
   it is used for that purpose, and not to hold a string from the
   command line, the client, etc.  */
#define MAXDATELEN	50
a424 1

a426 1
void expand_string PROTO ((char **, size_t *, size_t));
a428 1

d491 1
a491 1
void line2argv PROTO ((int *pargc, char ***argv, char *line));
d741 1
a741 1
void wrap_fromcvs_process_file PROTO ((const char *fileName));
a769 1
int logout PROTO((int argc, char **argv));
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a513 5
#ifdef SERVER_SUPPORT
extern int cvs_casecmp PROTO ((char *, char *));
extern int fopen_case PROTO ((char *, char *, FILE **, char **));
#endif

@


1.1.1.9
log
@Latest release from Cyclic Software
@
text
@a327 2
    int nonbranch;

d396 2
d462 1
a462 2
			 char *repository, char *tag, char *date,
			 int nonbranch));
d476 1
d478 1
a478 3
void ParseTag PROTO((char **tagp, char **datep, int *nonbranchp));
void WriteTag PROTO ((char *dir, char *tag, char *date, int nonbranch,
		      char *update_dir, char *repository));
d653 1
a653 3
       It is NULL if there is no file in the working directory.  It is
       "Is-modified" if we know the file is modified but don't have its
       contents.  */
a675 3
    /* If this is 1, then tag is not a branch tag.  If this is 0, then
       tag may or may not be a branch tag.  */
    int nonbranch;
@


1.1.1.10
log
@Latest version from Cyclic Software
@
text
@a420 2


a424 4
void root_allow_add PROTO ((char *));
void root_allow_free PROTO ((void));
int root_allow_ok PROTO ((char *));

a435 1
int pathname_levels PROTO ((char *path));
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a129 2
#define CVSADM_BASEREV   "CVS/Baserev."
#define CVSADM_BASEREVTMP "CVS/Baserev.tmp"
a146 2
#define CVSADM_BASEREV  "CVS/Baserev"
#define CVSADM_BASEREVTMP "CVS/Baserev.tmp"
a184 1
#define CVSROOTADM_CONFIG	"config"
d209 5
a213 4
/* Set if CVS needs to create a CVS/Root file upon completion of this
   command.  The name may be slightly confusing, because the flag
   isn't really as general purpose as it seems (it is not set for cvs
   release).  */
d243 3
d256 4
a259 1
#define	CVSREAD_DFLT	0		/* writable files by default */
a302 2

    /* Timestamp, or "" if none (never NULL).  */
a303 2

    /* Keyword expansion options, or "" if none (never NULL).  */
a304 1

d356 1
a356 1
extern char *Tmpdir, *Editor;
d366 1
a366 2
  local_method, server_method, pserver_method, kserver_method, gserver_method,
  ext_method
a377 2
extern char *emptydir_name PROTO ((void));

d392 6
a397 1
int RCS_merge PROTO((RCSNode *, char *, char *, char *, char *, char *));
d404 2
a405 11

extern int RCS_exec_rcsdiff PROTO ((RCSNode *rcsfile,
				    char *opts, char *options,
				    char *rev1, char *rev2,
				    char *label1, char *label2,
				    char *workfile));
extern int diff_exec PROTO ((char *file1, char *file2, char *options,
			     char *out));
extern int diff_execv PROTO ((char *file1, char *file2,
			      char *label1, char *label2,
			      char *options, char *out));
a418 1

d421 1
a421 2
char *Short_Repository PROTO((char *repository));
void Sanitize_Repository_Name PROTO((char *repository));
d431 3
a433 2
char *gca PROTO((const char *rev1, const char *rev2));
extern void check_numeric PROTO ((const char *, int, char **));
a445 2
extern int parse_config PROTO ((char *));

a459 2
char *increment_revnum PROTO ((const char *));
int compare_revnums PROTO ((const char *, const char *));
d468 3
a470 4
extern int Create_Admin PROTO ((char *dir, char *update_dir,
				char *repository, char *tag, char *date,
				int nonbranch, int warn));
extern int expand_at_signs PROTO ((char *, off_t, FILE *));
d508 1
a508 1
void line2argv PROTO ((int *pargc, char ***argv, char *line, char *sepchars));
d545 1
a545 1
	char *mwhere, char *mfile, int shorten, int local_specified,
d606 1
a606 3
extern int file_has_markers PROTO ((const struct file_info *));
extern void get_file PROTO ((const char *, const char *, const char *,
			     char **, size_t *, size_t *));
d619 8
a626 3
void run_setup PROTO ((const char *prog));
int run_exec PROTO((const char *stin, const char *stout, const char *sterr,
		    int flags));
d646 4
a649 10
       It can have the following special values:

       NULL = file is not mentioned in Entries (this is also used for a
	      directory).
       "" = ILLEGAL!  The comment used to say that it meant "no user file"
	    but as far as I know CVS didn't actually use it that way.
	    Note that according to cvs.texinfo, "" is not legal in the
	    Entries file.
       0 = user file is new
       -vers = user file to be removed.  */
d672 1
a672 2
    /* Options from CVS/Entries (keyword expansion), malloc'd.  If none,
       then it is an empty string (never NULL).  */
a710 5
/* CVSADM_BASEREV stuff, from entries.c.  */
extern char *base_get PROTO ((struct file_info *));
extern void base_register PROTO ((struct file_info *, char *));
extern void base_deregister PROTO ((struct file_info *));

a771 3
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
void wrap_unparse_rcs_options PROTO ((char **, int));
#endif /* SERVER_SUPPORT || CLIENT_SUPPORT */
a820 1
/* From server.c and documented there.  */
a821 1
extern void cvs_output_binary PROTO ((char *, size_t));
a824 1
extern void cvs_output_tagged PROTO ((char *, char *));
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a404 1
#define RCS_FLAGS_KEEPFILE 16
d425 1
a425 1
List *Entries_Open PROTO ((int aflag, char *update_dir));
a463 1
int isdevice PROTO ((const char *));
a467 1
char *xreadlink PROTO((const char *link));
a729 3
/* TODO: can the finfo argument to special_file_mismatch be changed? -twp */
int special_file_mismatch PROTO ((struct file_info *finfo,
				  char *rev1, char *rev2));
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a431 2
char *date_from_time_t PROTO ((time_t));

d479 1
d837 1
a837 1
extern int cvsstatus PROTO((int argc, char **argv));
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@a387 2
extern int top_level_admin;

@


1.1.1.15
log
@Latest version from Cyclic
@
text
@d370 1
a370 1
  ext_method, fork_method
a374 5
/* This global variable holds the global -d option.  It is NULL if -d
   was not used, which means that we must get the CVSroot information
   from the CVSROOT environment variable or from a CVS/Root file.  */
extern char *CVSroot_cmdline;

a381 5
/* These variables keep track of all of the CVSROOT directories that
   have been seen by the client and the current one of those selected.  */
extern List *root_directories;
extern char *current_root;

d390 5
a394 5
#ifdef CLIENT_SUPPORT
extern List *dirs_sent_to_server; /* used to decide which "Argument
				     xxx" commands to send to each
				     server in multiroot mode. */
#endif
a434 1
void date_to_internet PROTO ((char *, char *));
a504 3

/* LockDir setting from CVSROOT/config.  */
extern char *lock_dir;
a630 1
extern void resolve_symlink PROTO ((char **filename));
d651 1
@


1.1.1.16
log
@Latest version from Cyclic
@
text
@d464 1
a464 1
void *xmalloc PROTO((size_t bytes));
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@a392 1
extern int safe_location PROTO ((void));
d502 1
a502 1
				int nonbranch, int warn, int dotemplate));
d528 1
a528 1
void fperrmsg PROTO((FILE * fp, int status, int errnum, char *message,...));
a548 1
char *backup_file PROTO((const char *file, const char *suffix));
d580 1
a580 1
typedef	int (*CALLBACKPROC)	PROTO((int argc, char *argv[], char *where,
a638 1
int SIG_inCrSect PROTO((void));
a855 1
extern int version PROTO((int argc, char **argv));
a871 2
#include "server.h"

d879 4
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@d317 1
a317 1
    CHECKOUT, TAG, PATCH, EXPORT, MISC
d369 1
a369 1
  null_method, local_method, server_method, pserver_method, kserver_method, gserver_method,
a374 13
typedef struct cvsroot_s {
    char *original;		/* the complete source CVSroot string */
    CVSmethod method;		/* one of the enum values above */
    char *username;		/* the username or NULL if method == local */
    char *password;		/* the username or NULL if method == local */
    char *hostname;		/* the hostname or NULL if method == local */
    int port;			/* the port or zero if method == local */
    char *directory;		/* the directory name */
#ifdef CLIENT_SUPPORT
    unsigned char isremote;	/* nonzero if we are doing remote access */
#endif /* CLIENT_SUPPORT */
} cvsroot_t;

d380 7
d390 1
a390 1
extern cvsroot_t *current_parsed_root;
d425 2
a426 3
extern int diff_exec PROTO ((char *file1, char *file2,
			     char *label1, char *label2,
			     char *options, char *out));
d446 1
a446 3
void date_to_internet PROTO ((char *, const char *));
void date_to_tm PROTO ((struct tm *, const char *));
void tm_to_internet PROTO ((char *, const struct tm *));
d453 2
a454 3
void free_cvsroot_t PROTO((cvsroot_t *root_in));
cvsroot_t *parse_cvsroot PROTO((char *root));
cvsroot_t *local_cvsroot PROTO((char *dir));
a467 1
void allocate_and_strcat PROTO ((char **, size_t *, const char *));
a489 1
FILE *cvs_temp_file PROTO ((char **filename));
d513 1
a513 2
void lock_tree_for_write PROTO ((int argc, char **argv, int local, int which,
				 int aflag));
d550 1
d630 1
a630 2
		int local_specified, int run_module_prog, int build_dirs,
		char *extra_arg));
a647 2
extern char *shell_escape PROTO((char *buf, const char *str));
char *backup_file PROTO((const char *file, const char *suffix));
a648 1
void sleep_past PROTO ((time_t desttime));
d778 1
d780 1
a869 2
int get_cvs_port_number PROTO((const cvsroot_t *root));
char *normalize_cvsroot PROTO((const cvsroot_t *root));
@


