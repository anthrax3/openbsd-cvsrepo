head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.12.0.62
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.58
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.60
	OPENBSD_5_8_BASE:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.52
	OPENBSD_5_7_BASE:1.1.1.12
	OPENBSD_5_6:1.1.1.12.0.56
	OPENBSD_5_6_BASE:1.1.1.12
	OPENBSD_5_5:1.1.1.12.0.54
	OPENBSD_5_5_BASE:1.1.1.12
	OPENBSD_5_4:1.1.1.12.0.50
	OPENBSD_5_4_BASE:1.1.1.12
	OPENBSD_5_3:1.1.1.12.0.48
	OPENBSD_5_3_BASE:1.1.1.12
	OPENBSD_5_2:1.1.1.12.0.46
	OPENBSD_5_2_BASE:1.1.1.12
	OPENBSD_5_1_BASE:1.1.1.12
	OPENBSD_5_1:1.1.1.12.0.44
	OPENBSD_5_0:1.1.1.12.0.42
	OPENBSD_5_0_BASE:1.1.1.12
	OPENBSD_4_9:1.1.1.12.0.40
	OPENBSD_4_9_BASE:1.1.1.12
	OPENBSD_4_8:1.1.1.12.0.38
	OPENBSD_4_8_BASE:1.1.1.12
	OPENBSD_4_7:1.1.1.12.0.34
	OPENBSD_4_7_BASE:1.1.1.12
	OPENBSD_4_6:1.1.1.12.0.36
	OPENBSD_4_6_BASE:1.1.1.12
	OPENBSD_4_5:1.1.1.12.0.32
	OPENBSD_4_5_BASE:1.1.1.12
	OPENBSD_4_4:1.1.1.12.0.30
	OPENBSD_4_4_BASE:1.1.1.12
	OPENBSD_4_3:1.1.1.12.0.28
	OPENBSD_4_3_BASE:1.1.1.12
	OPENBSD_4_2:1.1.1.12.0.26
	OPENBSD_4_2_BASE:1.1.1.12
	OPENBSD_4_1:1.1.1.12.0.24
	OPENBSD_4_1_BASE:1.1.1.12
	OPENBSD_4_0:1.1.1.12.0.22
	OPENBSD_4_0_BASE:1.1.1.12
	OPENBSD_3_9:1.1.1.12.0.20
	OPENBSD_3_9_BASE:1.1.1.12
	OPENBSD_3_8:1.1.1.12.0.18
	OPENBSD_3_8_BASE:1.1.1.12
	OPENBSD_3_7:1.1.1.12.0.16
	OPENBSD_3_7_BASE:1.1.1.12
	OPENBSD_3_6:1.1.1.12.0.14
	OPENBSD_3_6_BASE:1.1.1.12
	OPENBSD_3_5:1.1.1.12.0.12
	OPENBSD_3_5_BASE:1.1.1.12
	OPENBSD_3_4:1.1.1.12.0.10
	OPENBSD_3_4_BASE:1.1.1.12
	OPENBSD_3_3:1.1.1.12.0.8
	OPENBSD_3_3_BASE:1.1.1.12
	OPENBSD_3_2:1.1.1.12.0.6
	OPENBSD_3_2_BASE:1.1.1.12
	OPENBSD_3_1:1.1.1.12.0.4
	OPENBSD_3_1_BASE:1.1.1.12
	OPENBSD_3_0:1.1.1.12.0.2
	OPENBSD_3_0_BASE:1.1.1.12
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.1.1.11.0.10
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.11.0.8
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.6
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.4
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.11.0.2
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.06;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.52;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.33;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.33;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.30;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.05;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.41;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.13;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.58.43;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.32.55;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Find Names
 * 
 * Finds all the pertinent file names, both from the administration and from the
 * repository
 * 
 * Find Dirs
 * 
 * Finds all pertinent sub-directories of the checked out instantiation and the
 * repository (and optionally the attic)
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)find_names.c 1.45 94/10/22 $";
USE(rcsid);
#endif

static int find_dirs PROTO((char *dir, List * list, int checkadm));
static int find_rcs PROTO((char *dir, List * list));

static List *filelist;

/*
 * add the key from entry on entries list to the files list
 */
static int add_entries_proc PROTO((Node *, void *));
static int
add_entries_proc (node, closure)
     Node *node;
     void *closure;
{
    Node *fnode;

    fnode = getnode ();
    fnode->type = FILES;
    fnode->key = xstrdup (node->key);
    if (addnode (filelist, fnode) != 0)
	freenode (fnode);
    return (0);
}

/*
 * compare two files list node (for sort)
 */
static int fsortcmp PROTO ((const Node *, const Node *));
static int
fsortcmp (p, q)
    const Node *p;
    const Node *q;
{
    return (strcmp (p->key, q->key));
}

List *
Find_Names (repository, which, aflag, optentries)
    char *repository;
    int which;
    int aflag;
    List **optentries;
{
    List *entries;
    List *files;
    char dir[PATH_MAX];

    /* make a list for the files */
    files = filelist = getlist ();

    /* look at entries (if necessary) */
    if (which & W_LOCAL)
    {
	/* parse the entries file (if it exists) */
	entries = Entries_Open (aflag);
	if (entries != NULL)
	{
	    /* walk the entries file adding elements to the files list */
	    (void) walklist (entries, add_entries_proc, NULL);

	    /* if our caller wanted the entries list, return it; else free it */
	    if (optentries != NULL)
		*optentries = entries;
	    else
		Entries_Close (entries);
	}
    }

    if ((which & W_REPOS) && repository && !isreadable (CVSADM_ENTSTAT))
    {
	/* search the repository */
	if (find_rcs (repository, files) != 0)
	    error (1, errno, "cannot open directory %s", repository);

	/* search the attic too */
	if (which & W_ATTIC)
	{
	    (void) sprintf (dir, "%s/%s", repository, CVSATTIC);
	    (void) find_rcs (dir, files);
	}
    }

    /* sort the list into alphabetical order and return it */
    sortlist (files, fsortcmp);
    return (files);
}

/*
 * create a list of directories to traverse from the current directory
 */
List *
Find_Dirs (repository, which)
    char *repository;
    int which;
{
    List *dirlist;

    /* make a list for the directories */
    dirlist = getlist ();

    /* find the local ones */
    if (which & W_LOCAL)
    {
	/* look only for CVS controlled sub-directories */
	if (find_dirs (".", dirlist, 1) != 0)
	    error (1, errno, "cannot open current directory");
    }

    /* look for sub-dirs in the repository */
    if ((which & W_REPOS) && repository)
    {
	/* search the repository */
	if (find_dirs (repository, dirlist, 0) != 0)
	    error (1, errno, "cannot open directory %s", repository);

#ifdef ATTIC_DIR_SUPPORT		/* XXX - FIXME */
	/* search the attic too */
	if (which & W_ATTIC)
	{
	    char dir[PATH_MAX];

	    (void) sprintf (dir, "%s/%s", repository, CVSATTIC);
	    (void) find_dirs (dir, dirlist, 0);
	}
#endif
    }

    /* sort the list into alphabetical order and return it */
    sortlist (dirlist, fsortcmp);
    return (dirlist);
}

/*
 * Finds all the ,v files in the argument directory, and adds them to the
 * files list.  Returns 0 for success and non-zero if the argument directory
 * cannot be opened.
 */
static int
find_rcs (dir, list)
    char *dir;
    List *list;
{
    Node *p;
    struct dirent *dp;
    DIR *dirp;

    /* set up to read the dir */
    if ((dirp = opendir (dir)) == NULL)
	return (1);

    /* read the dir, grabbing the ,v files */
    while ((dp = readdir (dirp)) != NULL)
    {
	if (fnmatch (RCSPAT, dp->d_name, 0) == 0) 
	{
	    char *comma;

	    comma = strrchr (dp->d_name, ',');	/* strip the ,v */
	    *comma = '\0';
	    p = getnode ();
	    p->type = FILES;
	    p->key = xstrdup (dp->d_name);
	    if (addnode (list, p) != 0)
		freenode (p);
	}
    }
    (void) closedir (dirp);
    return (0);
}

/*
 * Finds all the subdirectories of the argument dir and adds them to the
 * specified list.  Sub-directories without a CVS administration directory
 * are optionally ignored  Returns 0 for success or 1 on error.
 */
static int
find_dirs (dir, list, checkadm)
    char *dir;
    List *list;
    int checkadm;
{
    Node *p;
    char tmp[PATH_MAX];
    struct dirent *dp;
    DIR *dirp;

    /* set up to read the dir */
    if ((dirp = opendir (dir)) == NULL)
	return (1);

    /* read the dir, grabbing sub-dirs */
    while ((dp = readdir (dirp)) != NULL)
    {
	if (strcmp (dp->d_name, ".") == 0 ||
	    strcmp (dp->d_name, "..") == 0 ||
	    strcmp (dp->d_name, CVSATTIC) == 0 ||
	    strcmp (dp->d_name, CVSLCK) == 0)
	    continue;

#ifdef DT_DIR
	if (dp->d_type != DT_DIR) 
	{
	    if (dp->d_type != DT_UNKNOWN && dp->d_type != DT_LNK)
		continue;
#endif
	    /* don't bother stating ,v files */
	    if (fnmatch (RCSPAT, dp->d_name, 0) == 0)
		continue;

	    sprintf (tmp, "%s/%s", dir, dp->d_name);
	    if (!isdir (tmp))
		continue;

#ifdef DT_DIR
	}
#endif

	/* check for administration directories (if needed) */
	if (checkadm)
	{
	    /* blow off symbolic links to dirs in local dir */
#ifdef DT_DIR
	    if (dp->d_type != DT_DIR)
	    {
		/* we're either unknown or a symlink at this point */
		if (dp->d_type == DT_LNK)
		    continue;
#endif
		if (islink (tmp))
		    continue;
#ifdef DT_DIR
	    }
#endif

	    /* check for new style */
	    (void) sprintf (tmp, "%s/%s/%s", dir, dp->d_name, CVSADM);
	    if (!isdir (tmp))
		continue;
	}

	/* put it in the list */
	p = getnode ();
	p->type = DIRS;
	p->key = xstrdup (dp->d_name);
	if (addnode (list, p) != 0)
	    freenode (p);
    }
    (void) closedir (dirp);
    return (0);
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d222 1
a222 2
	    strcmp (dp->d_name, CVSLCK) == 0 ||
	    strcmp (dp->d_name, CVSREP) == 0)
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d21 5
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d112 1
a112 1
Find_Directories (repository, which)
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d21 1
a21 2
static int find_dirs PROTO((char *dir, List * list, int checkadm,
			    List *entries));
a22 2
static int add_subdir_proc PROTO((Node *, void *));
static int register_subdir_proc PROTO((Node *, void *));
a34 1
    Entnode *entnode;
a36 4
    entnode = (Entnode *) node->data;
    if (entnode->type != ENT_FILE)
	return (0);

a108 42
 * Add an entry from the subdirs list to the directories list.  This
 * is called via walklist.
 */

static int
add_subdir_proc (p, closure)
     Node *p;
     void *closure;
{
    List *dirlist = (List *) closure;
    Entnode *entnode;
    Node *dnode;

    entnode = (Entnode *) p->data;
    if (entnode->type != ENT_SUBDIR)
	return 0;

    dnode = getnode ();
    dnode->type = DIRS;
    dnode->key = xstrdup (entnode->user);
    if (addnode (dirlist, dnode) != 0)
	freenode (dnode);
    return 0;
}

/*
 * Register a subdirectory.  This is called via walklist.
 */

/*ARGSUSED*/
static int
register_subdir_proc (p, closure)
     Node *p;
     void *closure;
{
    List *entries = (List *) closure;

    Subdir_Register (entries, (char *) NULL, p->key);
    return 0;
}

/*
d112 1
a112 1
Find_Directories (repository, which, entries)
a114 1
    List *entries;
d124 3
a126 40
	List *tmpentries;
	struct stickydirtag *sdtp;

	/* Look through the Entries file.  */

	if (entries != NULL)
	    tmpentries = entries;
	else if (isfile (CVSADM_ENT))
	    tmpentries = Entries_Open (0);
	else
	    tmpentries = NULL;

	if (tmpentries != NULL)
	    sdtp = (struct stickydirtag *) tmpentries->list->data;

	/* If we do have an entries list, then if sdtp is NULL, or if
           sdtp->subdirs is nonzero, all subdirectory information is
           recorded in the entries list.  */
	if (tmpentries != NULL && (sdtp == NULL || sdtp->subdirs))
	    walklist (tmpentries, add_subdir_proc, (void *) dirlist);
	else
	{
	    /* This is an old working directory, in which subdirectory
               information is not recorded in the Entries file.  Find
               the subdirectories the hard way, and, if possible, add
               it to the Entries file for next time.  */
	    if (find_dirs (".", dirlist, 1, tmpentries) != 0)
		error (1, errno, "cannot open current directory");
	    if (tmpentries != NULL)
	    {
		if (! list_isempty (dirlist))
		    walklist (dirlist, register_subdir_proc,
			      (void *) tmpentries);
		else
		    Subdirs_Known (tmpentries);
	    }
	}

	if (entries == NULL && tmpentries != NULL)
	    Entries_Close (tmpentries);
d133 1
a133 1
	if (find_dirs (repository, dirlist, 0, entries) != 0)
d143 1
a143 1
	    (void) find_dirs (dir, dirlist, 0, entries);
d168 1
a168 1
    if ((dirp = CVS_OPENDIR (dir)) == NULL)
d192 3
a194 5
 * Finds all the subdirectories of the argument dir and adds them to
 * the specified list.  Sub-directories without a CVS administration
 * directory are optionally ignored.  If ENTRIES is not NULL, all
 * files on the list are ignored.  Returns 0 for success or 1 on
 * error.
d197 1
a197 1
find_dirs (dir, list, checkadm, entries)
a200 1
    List *entries;
d208 1
a208 1
    if ((dirp = CVS_OPENDIR (dir)) == NULL)
a218 6
	    continue;

	/* findnode() is going to be significantly faster than stat()
	   because it involves no system calls.  That is why we bother
	   with the entries argument, and why we check this first.  */
	if (entries != NULL && findnode (entries, dp->d_name) != NULL)
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d74 1
a105 2
	    char *dir;
	    dir = xmalloc (strlen (repository) + sizeof (CVSATTIC) + 10);
a107 1
	    free (dir);
d224 10
a233 5
	/* We don't need to look in the attic because directories
	   never go in the attic.  In the future, there hopefully will
	   be a better mechanism for detecting whether a directory in
	   the repository is alive or dead; it may or may not involve
	   moving directories to the attic.  */
a346 3
		/* FIXME: tmp is not set here, or doesn't seem to be.
		   This would appear to just be a mistake...  Needs more
		   investigation to be sure...  */
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d291 1
a291 2
    char *tmp = NULL;
    size_t tmp_size = 0;
a324 3
	    expand_string (&tmp,
			   &tmp_size,
			   strlen (dir) + strlen (dp->d_name) + 10);
d344 3
a346 2
		/* Note that we only get here if we already set tmp
		   above.  */
a353 4
	    expand_string (&tmp,
			   &tmp_size,
			   (strlen (dir) + strlen (dp->d_name)
			    + sizeof (CVSADM) + 10));
a366 2
    if (tmp != NULL)
	free (tmp);
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d259 1
a259 1
	if (CVS_FNMATCH (RCSPAT, dp->d_name, 0) == 0) 
d323 1
a323 1
	    if (CVS_FNMATCH (RCSPAT, dp->d_name, 0) == 0)
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a202 9

	    /* FIXME-maybe: find_dirs is bogus for this usage because
	       it skips CVSATTIC and CVSLCK directories--those names
	       should be special only in the repository.  However, in
	       the interests of not perturbing this code, we probably
	       should leave well enough alone unless we want to write
	       a sanity.sh test case (which would operate by manually
	       hacking on the CVS/Entries file).  */

a294 10
    int skip_emptydir = 0;

    /* First figure out whether we need to skip directories named
       Emptydir.  Except in the CVSNULLREPOS case, Emptydir is just
       a normal directory name.  */
    if (isabsolute (dir)
	&& strncmp (dir, CVSroot_directory, strlen (CVSroot_directory)) == 0
	&& ISDIRSEP (dir[strlen (CVSroot_directory)])
	&& strcmp (dir + strlen (CVSroot_directory) + 1, CVSROOTADM) == 0)
	skip_emptydir = 1;
a313 4
	    continue;

	if (skip_emptydir
	    && strcmp (dp->d_name, CVSNULLREPOS) == 0)
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d53 12
d82 1
a82 1
	entries = Entries_Open (aflag, NULL);
d185 1
a185 1
	    tmpentries = Entries_Open (0, NULL);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a52 5
/* Find files in the repository and/or working directory.  On error,
   may either print a nonfatal error and return NULL, or just give
   a fatal error.  On success, return non-NULL (even if it is an empty
   list).  */

d88 1
a88 4
	{
	    error (0, errno, "cannot open directory %s", repository);
	    goto error_exit;
	}
d96 1
a96 5
	    if (find_rcs (dir, files) != 0
		&& !existence_error (errno))
		/* For now keep this a fatal error, seems less useful
		   for access control than the case above.  */
		error (1, errno, "cannot open directory %s", dir);
a103 3
 error_exit:
    dellist (&files);
    return NULL;
d238 1
a238 3
 * cannot be opened, in which case errno is set to indicate the error.
 * In the error case LIST is left in some reasonable state (unchanged, or
 * containing the files which were found before the error occurred).
a253 1
    errno = 0;
a267 8
	errno = 0;
    }
    if (errno != 0)
    {
	int save_errno = errno;
	(void) closedir (dirp);
	errno = save_errno;
	return 1;
d278 1
a278 1
 * error, in which case errno is set to indicate the error.
a307 1
    errno = 0;
d315 1
a315 1
	    goto do_it_again;
d321 1
a321 1
	    goto do_it_again;
d325 1
a325 1
	    goto do_it_again;
d331 1
a331 1
		goto do_it_again;
d335 1
a335 1
		goto do_it_again;
d342 1
a342 1
		goto do_it_again;
d357 1
a357 1
		    goto do_it_again;
d362 1
a362 1
		    goto do_it_again;
d374 1
a374 1
		goto do_it_again;
a382 10

    do_it_again:
	errno = 0;
    }
    if (errno != 0)
    {
	int save_errno = errno;
	(void) closedir (dirp);
	errno = save_errno;
	return 1;
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d272 1
a272 1
    while ((dp = CVS_READDIR (dirp)) != NULL)
d291 1
a291 1
	(void) CVS_CLOSEDIR (dirp);
d295 1
a295 1
    (void) CVS_CLOSEDIR (dirp);
d324 3
a326 3
	&& strncmp (dir, current_parsed_root->directory, strlen (current_parsed_root->directory)) == 0
	&& ISDIRSEP (dir[strlen (current_parsed_root->directory)])
	&& strcmp (dir + strlen (current_parsed_root->directory) + 1, CVSROOTADM) == 0)
d335 1
a335 1
    while ((dp = CVS_READDIR (dirp)) != NULL)
d417 1
a417 1
	(void) CVS_CLOSEDIR (dirp);
d421 1
a421 1
    (void) CVS_CLOSEDIR (dirp);
@


