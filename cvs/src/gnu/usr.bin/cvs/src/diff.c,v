head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.40
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.42
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.38
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.34
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.36
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.28
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.32
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.30
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.26
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.24
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.22
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.20
	OPENBSD_5_0:1.2.0.18
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.16
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.14
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.10
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.12
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.8
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.6
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.4
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.1.1.15.0.24
	OPENBSD_4_1_BASE:1.1.1.15
	OPENBSD_4_0:1.1.1.15.0.22
	OPENBSD_4_0_BASE:1.1.1.15
	OPENBSD_3_9:1.1.1.15.0.20
	OPENBSD_3_9_BASE:1.1.1.15
	OPENBSD_3_8:1.1.1.15.0.18
	OPENBSD_3_8_BASE:1.1.1.15
	OPENBSD_3_7:1.1.1.15.0.16
	OPENBSD_3_7_BASE:1.1.1.15
	OPENBSD_3_6:1.1.1.15.0.14
	OPENBSD_3_6_BASE:1.1.1.15
	OPENBSD_3_5:1.1.1.15.0.12
	OPENBSD_3_5_BASE:1.1.1.15
	OPENBSD_3_4:1.1.1.15.0.10
	OPENBSD_3_4_BASE:1.1.1.15
	OPENBSD_3_3:1.1.1.15.0.8
	OPENBSD_3_3_BASE:1.1.1.15
	OPENBSD_3_2:1.1.1.15.0.6
	OPENBSD_3_2_BASE:1.1.1.15
	OPENBSD_3_1:1.1.1.15.0.4
	OPENBSD_3_1_BASE:1.1.1.15
	OPENBSD_3_0:1.1.1.15.0.2
	OPENBSD_3_0_BASE:1.1.1.15
	cvs-1-11-1p1:1.1.1.15
	OPENBSD_2_9:1.1.1.14.0.8
	OPENBSD_2_9_BASE:1.1.1.14
	cvs-1-11:1.1.1.14
	OPENBSD_2_8:1.1.1.14.0.6
	OPENBSD_2_8_BASE:1.1.1.14
	OPENBSD_2_7:1.1.1.14.0.4
	OPENBSD_2_7_BASE:1.1.1.14
	OPENBSD_2_6:1.1.1.14.0.2
	OPENBSD_2_6_BASE:1.1.1.14
	cvs-1-10-7:1.1.1.14
	OPENBSD_2_5:1.1.1.13.0.2
	OPENBSD_2_5_BASE:1.1.1.13
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.1.1.12.0.2
	OPENBSD_2_4_BASE:1.1.1.12
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2007.05.12.13.58.35;	author sturm;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.04;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.46;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.27;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.29;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.25;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.00;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.09;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.39;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.08;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.40;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.53.52;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.32.49;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.09.10.05.06.22;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@when comparing two revisions of a directory tree, don't show dead files
as new in the 2nd revision

'makes sense' niallo, ok xsa
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Difference
 * 
 * Run diff against versions in the repository.  Options that are specified are
 * passed on directly to "rcsdiff".
 * 
 * Without any file arguments, runs diff against all the currently modified
 * files.
 */

#include "cvs.h"

enum diff_file
{
    DIFF_ERROR,
    DIFF_ADDED,
    DIFF_REMOVED,
    DIFF_DIFFERENT,
    DIFF_SAME
};

static Dtype diff_dirproc PROTO ((void *callerdat, char *dir,
				  char *pos_repos, char *update_dir,
				  List *entries));
static int diff_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repos, char *update_dir,
				      List *entries));
static int diff_dirleaveproc PROTO ((void *callerdat, char *dir,
				     int err, char *update_dir,
				     List *entries));
static enum diff_file diff_file_nodiff PROTO ((struct file_info *finfo,
					       Vers_TS *vers,
					       enum diff_file));
static int diff_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static void diff_mark_errors PROTO((int err));


/* Global variables.  Would be cleaner if we just put this stuff in a
   struct like log.c does.  */

/* Command line tags, from -r option.  Points into argv.  */
static char *diff_rev1, *diff_rev2;
/* Command line dates, from -D option.  Malloc'd.  */
static char *diff_date1, *diff_date2;
static char *use_rev1, *use_rev2;
static int have_rev1_label, have_rev2_label;

/* Revision of the user file, if it is unchanged from something in the
   repository and we want to use that fact.  */
static char *user_file_rev;

static char *options;
static char *opts;
static size_t opts_allocated = 1;
static int diff_errors;
static int empty_files = 0;

/* FIXME: should be documenting all the options here.  They don't
   perfectly match rcsdiff options (for example, we always support
   --ifdef and --context, but rcsdiff only does if diff does).  */
static const char *const diff_usage[] =
{
    "Usage: %s %s [-lNR] [rcsdiff-options]\n",
    "    [[-r rev1 | -D date1] [-r rev2 | -D date2]] [files...] \n",
    "\t-l\tLocal directory only, not recursive\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-D d1\tDiff revision for date against working file.\n",
    "\t-D d2\tDiff rev1/date1 against date2.\n",
    "\t-N\tinclude diffs for added and removed files.\n",
    "\t-r rev1\tDiff revision for rev1 against working file.\n",
    "\t-r rev2\tDiff rev1/date1 against rev2.\n",
    "\t--ifdef=arg\tOutput diffs in ifdef format.\n",
    "(consult the documentation for your diff program for rcsdiff-options.\n",
    "The most popular is -c for context diffs but there are many more).\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

/* I copied this array directly out of diff.c in diffutils 2.7, after
   removing the following entries, none of which seem relevant to use
   with CVS:
     --help
     --version
     --recursive
     --unidirectional-new-file
     --starting-file
     --exclude
     --exclude-from
     --sdiff-merge-assist

   I changed the options which take optional arguments (--context and
   --unified) to return a number rather than a letter, so that the
   optional argument could be handled more easily.  I changed the
   --paginate and --brief options to return a number, since -l and -q
   mean something else to cvs diff.

   The numbers 129- that appear in the fourth element of some entries
   tell the big switch in `diff' how to process those options. -- Ian

   The following options, which diff lists as "An alias, no longer
   recommended" have been removed: --file-label --entire-new-file
   --ascii --print.  */

static struct option const longopts[] =
{
    {"ignore-blank-lines", 0, 0, 'B'},
    {"context", 2, 0, 143},
    {"ifdef", 1, 0, 131},
    {"show-function-line", 1, 0, 'F'},
    {"speed-large-files", 0, 0, 'H'},
    {"ignore-matching-lines", 1, 0, 'I'},
    {"label", 1, 0, 'L'},
    {"new-file", 0, 0, 'N'},
    {"initial-tab", 0, 0, 'T'},
    {"width", 1, 0, 'W'},
    {"text", 0, 0, 'a'},
    {"ignore-space-change", 0, 0, 'b'},
    {"minimal", 0, 0, 'd'},
    {"ed", 0, 0, 'e'},
    {"forward-ed", 0, 0, 'f'},
    {"ignore-case", 0, 0, 'i'},
    {"paginate", 0, 0, 144},
    {"rcs", 0, 0, 'n'},
    {"show-c-function", 0, 0, 'p'},

    /* This is a potentially very useful option, except the output is so
       silly.  It would be much better for it to look like "cvs rdiff -s"
       which displays all the same info, minus quite a few lines of
       extraneous garbage.  */
    {"brief", 0, 0, 145},

    {"report-identical-files", 0, 0, 's'},
    {"expand-tabs", 0, 0, 't'},
    {"ignore-all-space", 0, 0, 'w'},
    {"side-by-side", 0, 0, 'y'},
    {"unified", 2, 0, 146},
    {"left-column", 0, 0, 129},
    {"suppress-common-lines", 0, 0, 130},
    {"old-line-format", 1, 0, 132},
    {"new-line-format", 1, 0, 133},
    {"unchanged-line-format", 1, 0, 134},
    {"line-format", 1, 0, 135},
    {"old-group-format", 1, 0, 136},
    {"new-group-format", 1, 0, 137},
    {"unchanged-group-format", 1, 0, 138},
    {"changed-group-format", 1, 0, 139},
    {"horizon-lines", 1, 0, 140},
    {"binary", 0, 0, 142},
    {0, 0, 0, 0}
};

/* CVS 1.9 and similar versions seemed to have pretty weird handling
   of -y and -T.  In the cases where it called rcsdiff,
   they would have the meanings mentioned below.  In the cases where it
   called diff, they would have the meanings mentioned in "longopts".
   Noone seems to have missed them, so I think the right thing to do is
   just to remove the options altogether (which I have done).

   In the case of -z and -q, "cvs diff" did not accept them even back
   when we called rcsdiff (at least, it hasn't accepted them
   recently).

   In comparing rcsdiff to the new CVS implementation, I noticed that
   the following rcsdiff flags are not handled by CVS diff:

	   -y: perform diff even when the requested revisions are the
		   same revision number
	   -q: run quietly
	   -T: preserve modification time on the RCS file
	   -z: specify timezone for use in file labels

   I think these are not really relevant.  -y is undocumented even in
   RCS 5.7, and seems like a minor change at best.  According to RCS
   documentation, -T only applies when a RCS file has been modified
   because of lock changes; doesn't CVS sidestep RCS's entire lock
   structure?  -z seems to be unsupported by CVS diff, and has a
   different meaning as a global option anyway.  (Adding it could be
   a feature, but if it is left out for now, it should not break
   anything.)  For the purposes of producing output, CVS diff appears
   mostly to ignore -q.  Maybe this should be fixed, but I think it's
   a larger issue than the changes included here.  */

int
diff (argc, argv)
    int argc;
    char **argv;
{
    char tmp[50];
    int c, err = 0;
    int local = 0;
    int which;
    int option_index;

    if (argc == -1)
	usage (diff_usage);

    have_rev1_label = have_rev2_label = 0;

    /*
     * Note that we catch all the valid arguments here, so that we can
     * intercept the -r arguments for doing revision diffs; and -l/-R for a
     * non-recursive/recursive diff.
     */

    /* Clean out our global variables (multiroot can call us multiple
       times and the server can too, if the client sends several
       diff commands).  */
    if (opts == NULL)
    {
	opts_allocated = 1;
	opts = xmalloc (opts_allocated);
    }
    opts[0] = '\0';
    diff_rev1 = NULL;
    diff_rev2 = NULL;
    diff_date1 = NULL;
    diff_date2 = NULL;

    optind = 0;
    while ((c = getopt_long (argc, argv,
	       "+abcdefhilnpstuwy0123456789BHNRTC:D:F:I:L:U:V:W:k:r:",
			     longopts, &option_index)) != -1)
    {
	switch (c)
	{
	    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
	    case 'h': case 'i': case 'n': case 'p': case 's': case 't':
	    case 'u': case 'w': case 'y':
            case '0': case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
	    case 'B': case 'H': case 'T':
		(void) sprintf (tmp, " -%c", (char) c);
		allocate_and_strcat (&opts, &opts_allocated, tmp);
		break;
	    case 'L':
		if (have_rev1_label++)
		    if (have_rev2_label++)
		    {
			error (0, 0, "extra -L arguments ignored");
			break;
		    }

	        allocate_and_strcat (&opts, &opts_allocated, " -L");
	        allocate_and_strcat (&opts, &opts_allocated, optarg);
		break;
	    case 'C': case 'F': case 'I': case 'U': case 'V': case 'W':
		(void) sprintf (tmp, " -%c", (char) c);
		allocate_and_strcat (&opts, &opts_allocated, tmp);
		allocate_and_strcat (&opts, &opts_allocated, optarg);
		break;
	    case 131:
		/* --ifdef.  */
		allocate_and_strcat (&opts, &opts_allocated, " --ifdef=");
		allocate_and_strcat (&opts, &opts_allocated, optarg);
		break;
	    case 129: case 130:           case 132: case 133: case 134:
	    case 135: case 136: case 137: case 138: case 139: case 140:
	    case 141: case 142: case 143: case 144: case 145: case 146:
		allocate_and_strcat (&opts, &opts_allocated, " --");
		allocate_and_strcat (&opts, &opts_allocated,
				     longopts[option_index].name);
		if (longopts[option_index].has_arg == 1
		    || (longopts[option_index].has_arg == 2
			&& optarg != NULL))
		{
		    allocate_and_strcat (&opts, &opts_allocated, "=");
		    allocate_and_strcat (&opts, &opts_allocated, optarg);
		}
		break;
	    case 'R':
		local = 0;
		break;
	    case 'l':
		local = 1;
		break;
	    case 'k':
		if (options)
		    free (options);
		options = RCS_check_kflag (optarg);
		break;
	    case 'r':
		if (diff_rev2 != NULL || diff_date2 != NULL)
		    error (1, 0,
		       "no more than two revisions/dates can be specified");
		if (diff_rev1 != NULL || diff_date1 != NULL)
		    diff_rev2 = optarg;
		else
		    diff_rev1 = optarg;
		break;
	    case 'D':
		if (diff_rev2 != NULL || diff_date2 != NULL)
		    error (1, 0,
		       "no more than two revisions/dates can be specified");
		if (diff_rev1 != NULL || diff_date1 != NULL)
		    diff_date2 = Make_Date (optarg);
		else
		    diff_date1 = Make_Date (optarg);
		break;
	    case 'N':
		empty_files = 1;
		break;
	    case '?':
	    default:
		usage (diff_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    /* make sure options is non-null */
    if (!options)
	options = xstrdup ("");

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote) {
	/* We're the client side.  Fire up the remote server.  */
	start_server ();
	
	ign_setup ();

	if (local)
	    send_arg("-l");
	if (empty_files)
	    send_arg("-N");
	send_option_string (opts);
	if (options[0] != '\0')
	    send_arg (options);
	if (diff_rev1)
	    option_with_arg ("-r", diff_rev1);
	if (diff_date1)
	    client_senddate (diff_date1);
	if (diff_rev2)
	    option_with_arg ("-r", diff_rev2);
	if (diff_date2)
	    client_senddate (diff_date2);

	/* Send the current files unless diffing two revs from the archive */
	if (diff_rev2 == NULL && diff_date2 == NULL)
	    send_files (argc, argv, local, 0, 0);
	else
	    send_files (argc, argv, local, 0, SEND_NO_CONTENTS);

	send_file_names (argc, argv, SEND_EXPAND_WILD);

	send_to_server ("diff\012", 0);
        err = get_responses_and_close ();
	free (options);
	options = NULL;
	return (err);
    }
#endif

    if (diff_rev1 != NULL)
	tag_check_valid (diff_rev1, argc, argv, local, 0, "");
    if (diff_rev2 != NULL)
	tag_check_valid (diff_rev2, argc, argv, local, 0, "");

    which = W_LOCAL;
    if (diff_rev1 != NULL || diff_date1 != NULL)
	which |= W_REPOS | W_ATTIC;

    wrap_setup ();

    /* start the recursion processor */
    err = start_recursion (diff_fileproc, diff_filesdoneproc, diff_dirproc,
			   diff_dirleaveproc, NULL, argc, argv, local,
			   which, 0, 1, (char *) NULL, 1);

    /* clean up */
    free (options);
    options = NULL;

    if (diff_date1 != NULL)
	free (diff_date1);
    if (diff_date2 != NULL)
	free (diff_date2);

    return (err);
}

/*
 * Do a file diff
 */
/* ARGSUSED */
static int
diff_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    int status, err = 2;		/* 2 == trouble, like rcsdiff */
    Vers_TS *vers;
    enum diff_file empty_file = DIFF_DIFFERENT;
    char *tmp;
    char *tocvsPath;
    char *fname;
    char *label1;
    char *label2;

    /* Initialize these solely to avoid warnings from gcc -Wall about
       variables that might be used uninitialized.  */
    tmp = NULL;
    fname = NULL;

    user_file_rev = 0;
    vers = Version_TS (finfo, NULL, NULL, NULL, 1, 0);

    if (diff_rev2 != NULL || diff_date2 != NULL)
    {
	/* Skip all the following checks regarding the user file; we're
	   not using it.  */
    }
    else if (vers->vn_user == NULL)
    {
	/* The file does not exist in the working directory.  */
	if ((diff_rev1 != NULL || diff_date1 != NULL)
	    && vers->srcfile != NULL)
	{
	    /* The file does exist in the repository.  */
	    if (empty_files)
		empty_file = DIFF_REMOVED;
	    else
	    {
		int exists;

		exists = 0;
		/* special handling for TAG_HEAD */
		if (diff_rev1 && strcmp (diff_rev1, TAG_HEAD) == 0)
		{
		    char *head =
			(vers->vn_rcs == NULL
			 ? NULL
			 : RCS_branch_head (vers->srcfile, vers->vn_rcs));
		    exists = head != NULL;
		    if (head != NULL)
			free (head);
		}
		else
		{
		    Vers_TS *xvers;

		    xvers = Version_TS (finfo, NULL, diff_rev1, diff_date1,
					1, 0);
		    exists = xvers->vn_rcs != NULL;
		    freevers_ts (&xvers);
		}
		if (exists)
		    error (0, 0,
			   "%s no longer exists, no comparison available",
			   finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
	else
	{
	    error (0, 0, "I know nothing about %s", finfo->fullname);
	    freevers_ts (&vers);
	    diff_mark_errors (err);
	    return (err);
	}
    }
    else if (vers->vn_user[0] == '0' && vers->vn_user[1] == '\0')
    {
	if (empty_files)
	    empty_file = DIFF_ADDED;
	else
	{
	    error (0, 0, "%s is a new entry, no comparison available",
		   finfo->fullname);
	    freevers_ts (&vers);
	    diff_mark_errors (err);
	    return (err);
	}
    }
    else if (vers->vn_user[0] == '-')
    {
	if (empty_files)
	    empty_file = DIFF_REMOVED;
	else
	{
	    error (0, 0, "%s was removed, no comparison available",
		   finfo->fullname);
	    freevers_ts (&vers);
	    diff_mark_errors (err);
	    return (err);
	}
    }
    else
    {
	if (vers->vn_rcs == NULL && vers->srcfile == NULL)
	{
	    error (0, 0, "cannot find revision control file for %s",
		   finfo->fullname);
	    freevers_ts (&vers);
	    diff_mark_errors (err);
	    return (err);
	}
	else
	{
	    if (vers->ts_user == NULL)
	    {
		error (0, 0, "cannot find %s", finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	    else if (!strcmp (vers->ts_user, vers->ts_rcs)) 
	    {
		/* The user file matches some revision in the repository
		   Diff against the repository (for remote CVS, we might not
		   have a copy of the user file around).  */
		user_file_rev = vers->vn_user;
	    }
	}
    }

    empty_file = diff_file_nodiff (finfo, vers, empty_file);
    if (empty_file == DIFF_SAME || empty_file == DIFF_ERROR)
    {
	freevers_ts (&vers);
	if (empty_file == DIFF_SAME)
	{
	    /* In the server case, would be nice to send a "Checked-in"
	       response, so that the client can rewrite its timestamp.
	       server_checked_in by itself isn't the right thing (it
	       needs a server_register), but I'm not sure what is.
	       It isn't clear to me how "cvs status" handles this (that
	       is, for a client which sends Modified not Is-modified to
	       "cvs status"), but it does.  */
	    return (0);
	}
	else
	{
	    diff_mark_errors (err);
	    return (err);
	}
    }

    if (empty_file == DIFF_DIFFERENT)
    {
	int dead1, dead2;

	if (use_rev1 == NULL)
	    dead1 = 0;
	else
	    dead1 = RCS_isdead (vers->srcfile, use_rev1);
	if (use_rev2 == NULL)
	    dead2 = 0;
	else
	    dead2 = RCS_isdead (vers->srcfile, use_rev2);

	if (dead1 && dead2)
	{
	    freevers_ts (&vers);
	    return (0);
	}
	else if (dead1)
	{
	    if (empty_files)
	        empty_file = DIFF_ADDED;
	    else
	    {
		error (0, 0, "%s is a new entry, no comparison available",
		       finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
	else if (dead2)
	{
	    if (empty_files)
		empty_file = DIFF_REMOVED;
	    else
	    {
		error (0, 0, "%s was removed, no comparison available",
		       finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
    }

    /* Output an "Index:" line for patch to use */
    cvs_output ("Index: ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output ("\n", 1);

    tocvsPath = wrap_tocvs_process_file(finfo->file);
    if (tocvsPath)
    {
	/* Backup the current version of the file to CVS/,,filename */
	fname = xmalloc (strlen (finfo->file)
			 + sizeof CVSADM
			 + sizeof CVSPREFIX
			 + 10);
	sprintf(fname,"%s/%s%s",CVSADM, CVSPREFIX, finfo->file);
	if (unlink_file_dir (fname) < 0)
	    if (! existence_error (errno))
		error (1, errno, "cannot remove %s", fname);
	rename_file (finfo->file, fname);
	/* Copy the wrapped file to the current directory then go to work */
	copy_file (tocvsPath, finfo->file);
    }

    /* Set up file labels appropriate for compatibility with the Larry Wall
     * implementation of patch if the user didn't specify.  This is irrelevant
     * according to the POSIX.2 specification.
     */
    label1 = NULL;
    label2 = NULL;
    if (!have_rev1_label)
    {
	if (empty_file == DIFF_ADDED)
	    label1 =
		make_file_label (DEVNULL, NULL, NULL);
	else
	    label1 =
		make_file_label (finfo->fullname, use_rev1, vers ? vers->srcfile : NULL);
    }

    if (!have_rev2_label)
    {
	if (empty_file == DIFF_REMOVED)
	    label2 =
		make_file_label (DEVNULL, NULL, NULL);
	else
	    label2 =
		make_file_label (finfo->fullname, use_rev2, vers ? vers->srcfile : NULL);
    }

    if (empty_file == DIFF_ADDED || empty_file == DIFF_REMOVED)
    {
	/* This is fullname, not file, possibly despite the POSIX.2
	 * specification, because that's the way all the Larry Wall
	 * implementations of patch (are there other implementations?) want
	 * things and the POSIX.2 spec appears to leave room for this.
	 */
	cvs_output ("\
===================================================================\n\
RCS file: ", 0);
	cvs_output (finfo->fullname, 0);
	cvs_output ("\n", 1);

	cvs_output ("diff -N ", 0);
	cvs_output (finfo->fullname, 0);
	cvs_output ("\n", 1);

	if (empty_file == DIFF_ADDED)
	{
	    if (use_rev2 == NULL)
		status = diff_exec (DEVNULL, finfo->file, label1, label2, opts, RUN_TTY);
	    else
	    {
		int retcode;

		tmp = cvs_temp_name ();
		retcode = RCS_checkout (vers->srcfile, (char *) NULL,
					use_rev2, (char *) NULL,
					(*options
					 ? options
					 : vers->options),
					tmp, (RCSCHECKOUTPROC) NULL,
					(void *) NULL);
		if (retcode != 0)
		{
		    diff_mark_errors (err);
		    return err;
		}

		status = diff_exec (DEVNULL, tmp, label1, label2, opts, RUN_TTY);
	    }
	}
	else
	{
	    int retcode;

	    tmp = cvs_temp_name ();
	    retcode = RCS_checkout (vers->srcfile, (char *) NULL,
				    use_rev1, (char *) NULL,
				    *options ? options : vers->options,
				    tmp, (RCSCHECKOUTPROC) NULL,
				    (void *) NULL);
	    if (retcode != 0)
	    {
		diff_mark_errors (err);
		return err;
	    }

	    status = diff_exec (tmp, DEVNULL, label1, label2, opts, RUN_TTY);
	}
    }
    else
    {
	status = RCS_exec_rcsdiff (vers->srcfile, opts,
				   *options ? options : vers->options,
				   use_rev1, use_rev2,
				   label1, label2,
				   finfo->file);

	if (label1) free (label1);
	if (label2) free (label2);
    }

    switch (status)
    {
	case -1:			/* fork failed */
	    error (1, errno, "fork failed while diffing %s",
		   vers->srcfile->path);
	case 0:				/* everything ok */
	    err = 0;
	    break;
	default:			/* other error */
	    err = status;
	    break;
    }

    if (tocvsPath)
    {
	if (unlink_file_dir (finfo->file) < 0)
	    if (! existence_error (errno))
		error (1, errno, "cannot remove %s", finfo->file);

	rename_file (fname, finfo->file);
	if (unlink_file (tocvsPath) < 0)
	    error (1, errno, "cannot remove %s", tocvsPath);
	free (fname);
    }

    if (empty_file == DIFF_REMOVED
	|| (empty_file == DIFF_ADDED && use_rev2 != NULL))
    {
	if (CVS_UNLINK (tmp) < 0)
	    error (0, errno, "cannot remove %s", tmp);
	free (tmp);
    }

    freevers_ts (&vers);
    diff_mark_errors (err);
    return (err);
}

/*
 * Remember the exit status for each file.
 */
static void
diff_mark_errors (err)
    int err;
{
    if (err > diff_errors)
	diff_errors = err;
}

/*
 * Print a warm fuzzy message when we enter a dir
 *
 * Don't try to diff directories that don't exist! -- DW
 */
/* ARGSUSED */
static Dtype
diff_dirproc (callerdat, dir, pos_repos, update_dir, entries)
    void *callerdat;
    char *dir;
    char *pos_repos;
    char *update_dir;
    List *entries;
{
    /* XXX - check for dirs we don't want to process??? */

    /* YES ... for instance dirs that don't exist!!! -- DW */
    if (!isdir (dir))
	return (R_SKIP_ALL);

    if (!quiet)
	error (0, 0, "Diffing %s", update_dir);
    return (R_PROCESS);
}

/*
 * Concoct the proper exit status - done with files
 */
/* ARGSUSED */
static int
diff_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
    int err;
    char *repos;
    char *update_dir;
    List *entries;
{
    return (diff_errors);
}

/*
 * Concoct the proper exit status - leaving directories
 */
/* ARGSUSED */
static int
diff_dirleaveproc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
    char *dir;
    int err;
    char *update_dir;
    List *entries;
{
    return (diff_errors);
}

/*
 * verify that a file is different
 */
static enum diff_file
diff_file_nodiff (finfo, vers, empty_file)
    struct file_info *finfo;
    Vers_TS *vers;
    enum diff_file empty_file;
{
    Vers_TS *xvers;
    int retcode;

    /* free up any old use_rev* variables and reset 'em */
    if (use_rev1)
	free (use_rev1);
    if (use_rev2)
	free (use_rev2);
    use_rev1 = use_rev2 = (char *) NULL;

    if (diff_rev1 || diff_date1)
    {
	/* special handling for TAG_HEAD */
	if (diff_rev1 && strcmp (diff_rev1, TAG_HEAD) == 0)
	    use_rev1 = ((vers->vn_rcs == NULL || vers->srcfile == NULL)
			? NULL
			: RCS_branch_head (vers->srcfile, vers->vn_rcs));
	else
	{
	    xvers = Version_TS (finfo, NULL, diff_rev1, diff_date1, 1, 0);
	    if (xvers->vn_rcs != NULL)
		use_rev1 = xstrdup (xvers->vn_rcs);
	    freevers_ts (&xvers);
	}
    }
    if (diff_rev2 || diff_date2)
    {
	/* special handling for TAG_HEAD */
	if (diff_rev2 && strcmp (diff_rev2, TAG_HEAD) == 0)
	    use_rev2 = ((vers->vn_rcs == NULL || vers->srcfile == NULL)
			? NULL
			: RCS_branch_head (vers->srcfile, vers->vn_rcs));
	else
	{
	    xvers = Version_TS (finfo, NULL, diff_rev2, diff_date2, 1, 0);
	    if (xvers->vn_rcs != NULL)
		use_rev2 = xstrdup (xvers->vn_rcs);
	    freevers_ts (&xvers);
	}

	if (use_rev1 == NULL)
	{
	    /* The first revision does not exist.  If EMPTY_FILES is
               true, treat this as an added file.  Otherwise, warn
               about the missing tag.  */
	    if (use_rev2 == NULL || RCS_isdead( vers->srcfile, use_rev2 ) )
		/* At least in the case where DIFF_REV1 and DIFF_REV2
		   are both numeric, we should be returning some kind
		   of error (see basicb-8a0 in testsuite).  The symbolic
		   case may be more complicated.  */
		return DIFF_SAME;
	    else if (empty_files)
		return DIFF_ADDED;
	    else if (diff_rev1)
		error (0, 0, "tag %s is not in file %s", diff_rev1,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date1, finfo->fullname);
	    return DIFF_ERROR;
	}

	if (use_rev2 == NULL)
	{
	    /* The second revision does not exist.  If EMPTY_FILES is
               true, treat this as a removed file.  Otherwise warn
               about the missing tag.  */
	    if (empty_files)
		return DIFF_REMOVED;
	    else if (diff_rev2)
		error (0, 0, "tag %s is not in file %s", diff_rev2,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date2, finfo->fullname);
	    return DIFF_ERROR;
	}

	/* now, see if we really need to do the diff */
	if (strcmp (use_rev1, use_rev2) == 0)
	    return DIFF_SAME;
	else
	    return DIFF_DIFFERENT;
    }

    if ((diff_rev1 || diff_date1) && use_rev1 == NULL)
    {
	/* The first revision does not exist, and no second revision
           was given.  */
	if (empty_files)
	{
	    if (empty_file == DIFF_REMOVED)
		return DIFF_SAME;
	    else
	    {
		if (user_file_rev && use_rev2 == NULL)
		    use_rev2 = xstrdup (user_file_rev);
		return DIFF_ADDED;
	    }
	}
	else
	{
	    if (diff_rev1)
		error (0, 0, "tag %s is not in file %s", diff_rev1,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date1, finfo->fullname);
	    return DIFF_ERROR;
	}
    }

    if (user_file_rev)
    {
        /* drop user_file_rev into first unused use_rev */
        if (!use_rev1) 
	    use_rev1 = xstrdup (user_file_rev);
	else if (!use_rev2)
	    use_rev2 = xstrdup (user_file_rev);
	/* and if not, it wasn't needed anyhow */
	user_file_rev = 0;
    }

    /* now, see if we really need to do the diff */
    if (use_rev1 && use_rev2) 
    {
	if (strcmp (use_rev1, use_rev2) == 0)
	    return DIFF_SAME;
	else
	    return DIFF_DIFFERENT;
    }

    if (use_rev1 == NULL
	|| (vers->vn_user != NULL && strcmp (use_rev1, vers->vn_user) == 0))
    {
	if (empty_file == DIFF_DIFFERENT
	    && vers->ts_user != NULL
	    && strcmp (vers->ts_rcs, vers->ts_user) == 0
	    && (!(*options) || strcmp (options, vers->options) == 0))
	{
	    return DIFF_SAME;
	}
	if (use_rev1 == NULL
	    && (vers->vn_user[0] != '0' || vers->vn_user[1] != '\0'))
	{
	    if (vers->vn_user[0] == '-')
		use_rev1 = xstrdup (vers->vn_user + 1);
	    else
		use_rev1 = xstrdup (vers->vn_user);
	}
    }

    /* If we already know that the file is being added or removed,
       then we don't want to do an actual file comparison here.  */
    if (empty_file != DIFF_DIFFERENT)
	return empty_file;

    /*
     * with 0 or 1 -r option specified, run a quick diff to see if we
     * should bother with it at all.
     */

    retcode = RCS_cmp_file (vers->srcfile, use_rev1,
			    *options ? options : vers->options,
			    finfo->file);

    return retcode == 0 ? DIFF_SAME : DIFF_DIFFERENT;
}
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d19 8
a26 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)diff.c 1.61 94/10/22 $";
USE(rcsid);
#endif
d28 13
a40 7
static Dtype diff_dirproc PROTO((char *dir, char *pos_repos, char *update_dir));
static int diff_filesdoneproc PROTO((int err, char *repos, char *update_dir));
static int diff_dirleaveproc PROTO((char *dir, int err, char *update_dir));
static int diff_file_nodiff PROTO((char *file, char *repository, List *entries,
			     List *srcfiles, Vers_TS *vers));
static int diff_fileproc PROTO((char *file, char *update_dir, char *repository,
			  List * entries, List * srcfiles));
d43 5
d49 1
d52 1
a53 1
#ifdef SERVER_SUPPORT
a56 1
#endif
d59 2
a60 1
static char opts[PATH_MAX];
d64 3
d69 1
a69 2
    "Usage: %s %s [-lN] [rcsdiff-options]\n",
#ifdef CVS_DIFFDATE
a70 3
#else
    "    [-r rev1 [-r rev2]] [files...] \n",
#endif
d72 1
d78 4
d85 104
d198 1
d203 2
d210 9
a218 3
#ifdef SERVER_SUPPORT
    /* Need to be able to do this command more than once (according to
       the protocol spec, even if the current client doesn't use it).  */
d220 9
a228 4
#endif
    optind = 1;
    while ((c = getopt (argc, argv,
		   "abcdefhilnpqtuw0123456789BHNQRTC:D:F:I:L:V:k:r:")) != -1)
d233 20
a252 4
	    case 'h': case 'i': case 'n': case 'p': case 't': case 'u':
	    case 'w': case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9': case 'B':
	    case 'H': case 'T': case 'Q':
d254 17
a270 2
		(void) strcat (opts, tmp);
		if (c == 'Q')
d272 2
a273 3
		    quiet = 1;
		    really_quiet = 1;
		    c = 'q';
a275 7
	    case 'C': case 'F': case 'I': case 'L': case 'V':
#ifndef CVS_DIFFDATE
	    case 'D':
#endif
		(void) sprintf (tmp, " -%c%s", (char) c, optarg);
		(void) strcat (opts, tmp);
		break;
a281 3
	    case 'q':
		quiet = 1;
		break;
a295 1
#ifdef CVS_DIFFDATE
a304 1
#endif
d322 1
a322 1
    if (client_active) {
d333 2
a343 13
#if 0
/* FIXME:  We shouldn't have to send current files to diff two revs, but it
   doesn't work yet and I haven't debugged it.  So send the files --
   it's slower but it works.  gnu@@cygnus.com  Apr94  */

/* Idea: often times the changed region of a file is relatively small.
   It would be cool if the client could just divide the file into 4k
   blocks or whatever and send hash values for the blocks.  Send hash
   values for blocks aligned with the beginning of the file and the
   end of the file.  Then the server can tell how much of the head and
   tail of the file is unchanged.  Well, hash collisions will screw
   things up, but MD5 has 128 bits of hash value...  */

d346 1
a346 1
	    send_files (argc, argv, local);
d348 3
a350 4
	    send_file_names (argc, argv);
#else
	send_files (argc, argv, local, 0);
#endif
d352 1
a352 2
	if (fprintf (to_server, "diff\n") < 0)
	    error (1, errno, "writing to server");
d355 1
d360 5
d366 1
a366 1
    if (diff_rev2 != NULL || diff_date2 != NULL)
d373 2
a374 2
			   diff_dirleaveproc, argc, argv, local,
			   which, 0, 1, (char *) NULL, 1, 0);
d378 7
d393 3
a395 6
diff_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
d399 2
a400 7
    enum {
	DIFF_ERROR,
	DIFF_ADDED,
	DIFF_REMOVED,
	DIFF_NEITHER
    } empty_file = DIFF_NEITHER;
    char tmp[L_tmpnam+1];
d402 8
a409 1
    char fname[PATH_MAX];
a410 1
#ifdef SERVER_SUPPORT
d412 1
a412 3
#endif
    vers = Version_TS (repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       file, 1, 0, entries, srcfiles);
d421 48
a468 4
	error (0, 0, "I know nothing about %s", file);
	freevers_ts (&vers);
	diff_mark_errors (err);
	return (err);
d476 2
a477 1
	    error (0, 0, "%s is a new entry, no comparison available", file);
d489 2
a490 1
	    error (0, 0, "%s was removed, no comparison available", file);
d500 2
a501 1
	    error (0, 0, "cannot find revision control file for %s", file);
d510 1
a510 1
		error (0, 0, "cannot find %s", file);
a514 1
#ifdef SERVER_SUPPORT
a521 1
#endif
d525 2
a526 1
    if (empty_file == DIFF_NEITHER && diff_file_nodiff (file, repository, entries, srcfiles, vers))
d529 16
a544 1
	return (0);
d547 45
a591 4
#ifdef DEATH_SUPPORT
    /* FIXME: Check whether use_rev1 and use_rev2 are dead and deal
       accordingly.  */
#endif
d594 3
a596 6
    (void) fflush (stdout);
    if (update_dir[0])
	(void) printf ("Index: %s/%s\n", update_dir, file);
    else
	(void) printf ("Index: %s\n", file);
    (void) fflush (stdout);
d598 1
a598 1
    tocvsPath = wrap_tocvs_process_file(file);
d602 5
a606 1
	sprintf(fname,"%s/%s%s",CVSADM, CVSPREFIX, file);
d608 3
a610 3
	    if (errno != ENOENT)
		error (1, errno, "cannot remove %s", file);
	rename_file (file, fname);
d612 27
a638 1
	copy_file (tocvsPath, file);
d643 14
a656 3
	(void) printf ("===================================================================\nRCS file: %s\n",
		       file);
	(void) printf ("diff -N %s\n", file);
d660 22
a681 1
	    run_setup ("%s %s %s %s", DIFF, opts, DEVNULL, file);
d685 9
a693 9
	    /*
	     * FIXME: Should be setting use_rev1 using the logic in
	     * diff_file_nodiff, and using that revision.  This code
	     * is broken for "cvs diff -N -r foo".
	     */
	    run_setup ("%s%s -p -q %s -r%s", Rcsbin, RCS_CO,
		       *options ? options : vers->options, vers->vn_rcs);
	    run_arg (vers->srcfile->path);
	    if (run_exec (RUN_TTY, tmpnam (tmp), RUN_TTY, RUN_REALLY) == -1)
d695 2
a696 3
		(void) unlink (tmp);
		error (1, errno, "fork failed during checkout of %s",
		       vers->srcfile->path);
d699 1
a699 1
	    run_setup ("%s %s %s %s", DIFF, opts, tmp, DEVNULL);
d704 8
a711 12
	if (use_rev2)
	{
	    run_setup ("%s%s %s %s -r%s -r%s", Rcsbin, RCS_DIFF,
		       opts, *options ? options : vers->options,
		       use_rev1, use_rev2);
	}
	else
	{
	    run_setup ("%s%s %s %s -r%s", Rcsbin, RCS_DIFF, opts,
		       *options ? options : vers->options, use_rev1);
	}
	run_arg (vers->srcfile->path);
d714 1
a714 2
    switch ((status = run_exec (RUN_TTY, RUN_TTY, RUN_TTY,
	RUN_REALLY|RUN_COMBINED)))
d717 1
a717 1
	    error (1, errno, "fork failed during rcsdiff of %s",
d729 3
a731 3
	if (unlink_file_dir (file) < 0)
	    if (errno != ENOENT)
		error (1, errno, "cannot remove %s", file);
d733 1
a733 1
	rename_file (fname,file);
d735 2
a736 1
	    error (1, errno, "cannot remove %s", file);
d739 7
a745 2
    if (empty_file == DIFF_REMOVED)
	(void) unlink (tmp);
a746 1
    (void) fflush (stdout);
d765 2
d770 2
a771 1
diff_dirproc (dir, pos_repos, update_dir)
d775 1
d778 5
d793 2
a794 1
diff_filesdoneproc (err, repos, update_dir)
d798 1
d808 2
a809 1
diff_dirleaveproc (dir, err, update_dir)
d813 1
d819 1
a819 1
 * verify that a file is different 0=same 1=different
d821 3
a823 6
static int
diff_file_nodiff (file, repository, entries, srcfiles, vers)
    char *file;
    char *repository;
    List *entries;
    List *srcfiles;
d825 1
d828 1
a828 1
    char tmp[L_tmpnam+1];
d841 3
a843 1
	    use_rev1 = xstrdup (vers->vn_rcs);
d846 3
a848 12
	    xvers = Version_TS (repository, (char *) NULL, diff_rev1,
				diff_date1, file, 1, 0, entries, srcfiles);
	    if (xvers->vn_rcs == NULL)
	    {
		if (diff_rev1)
		    error (0, 0, "tag %s is not in file %s", diff_rev1, file);
		else
		    error (0, 0, "no revision for date %s in file %s",
			   diff_date1, file);
		return (1);
	    }
	    use_rev1 = xstrdup (xvers->vn_rcs);
d856 3
a858 1
	    use_rev2 = xstrdup (vers->vn_rcs);
d861 3
a863 12
	    xvers = Version_TS (repository, (char *) NULL, diff_rev2,
				diff_date2, file, 1, 0, entries, srcfiles);
	    if (xvers->vn_rcs == NULL)
	    {
		if (diff_rev1)
		    error (0, 0, "tag %s is not in file %s", diff_rev2, file);
		else
		    error (0, 0, "no revision for date %s in file %s",
			   diff_date2, file);
		return (1);
	    }
	    use_rev2 = xstrdup (xvers->vn_rcs);
d867 38
d906 30
a935 5
	if (use_rev1 && use_rev2) {
	    return (strcmp (use_rev1, use_rev2) == 0);
	} else {
	    error(0, 0, "No HEAD revision for file %s", file);
	    return (1);
d938 2
a939 2
#ifdef SERVER_SUPPORT
    if (user_file_rev) 
d943 1
a943 1
	  use_rev1 = xstrdup (user_file_rev);
d945 1
a945 1
	  use_rev2 = xstrdup (user_file_rev);
d953 4
a956 1
	return (strcmp (use_rev1, use_rev2) == 0);
d958 3
a960 2
#endif /* SERVER_SUPPORT */
    if (use_rev1 == NULL || strcmp (use_rev1, vers->vn_user) == 0)
d962 4
a965 2
	if (strcmp (vers->ts_rcs, vers->ts_user) == 0 &&
	    (!(*options) || strcmp (options, vers->options) == 0))
d967 9
a975 1
	    return (1);
a976 2
	if (use_rev1 == NULL)
	    use_rev1 = xstrdup (vers->vn_user);
d979 5
d988 6
a993 21
    run_setup ("%s%s -p -q %s -r%s", Rcsbin, RCS_CO,
	       *options ? options : vers->options, use_rev1);
    run_arg (vers->srcfile->path);
    switch (run_exec (RUN_TTY, tmpnam (tmp), RUN_TTY, RUN_REALLY))
    {
	case 0:				/* everything ok */
	    if (xcmp (file, tmp) == 0)
	    {
		(void) unlink (tmp);
		return (1);
	    }
	    break;
	case -1:			/* fork failed */
	    (void) unlink (tmp);
	    error (1, errno, "fork failed during checkout of %s",
		   vers->srcfile->path);
	default:
	    break;
    }
    (void) unlink (tmp);
    return (0);
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a185 1
	send_file_names (argc, argv);
d187 12
a198 4
	/* FIXME: We shouldn't have to send current files to diff two
	   revs, but it doesn't work yet and I haven't debugged it.
	   So send the files -- it's slower but it works.
	   gnu@@cygnus.com Apr94 */
d201 5
a206 1
	send_files (argc, argv, local, 0);
d208 2
a209 1
	send_to_server ("diff\012", 0);
a215 5
    if (diff_rev1 != NULL)
	tag_check_valid (diff_rev1, argc, argv, local, 0, "");
    if (diff_rev2 != NULL)
	tag_check_valid (diff_rev2, argc, argv, local, 0, "");

d353 1
a353 1
	    if (! existence_error (errno))
d423 1
a423 1
	    if (! existence_error (errno))
a452 2
 *
 * Don't try to diff directories that don't exist! -- DW
a461 5

    /* YES ... for instance dirs that don't exist!!! -- DW */
    if (!isdir (dir) )
      return (R_SKIP_ALL);
  
d525 2
a526 5
		/* Don't gripe if it doesn't exist, just ignore! */
		if (! isfile (file))
                  /* null statement */ ;
		else if (diff_rev1)
                    error (0, 0, "tag %s is not in file %s", diff_rev1, file);
d547 1
a547 4
		/* Don't gripe if it doesn't exist, just ignore! */
		if (! isfile (file))
                  /* null statement */ ;
		else if (diff_rev1)
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d19 5
d29 2
a30 1
static int diff_fileproc PROTO((struct file_info *finfo));
d230 6
a235 2
diff_fileproc (finfo)
    struct file_info *finfo;
d252 2
a253 2
    vers = Version_TS (finfo->repository, (char *) NULL, (char *) NULL, (char *) NULL,
		       finfo->file, 1, 0, finfo->entries, finfo->srcfiles);
d262 1
a262 1
	error (0, 0, "I know nothing about %s", finfo->file);
d273 1
a273 1
	    error (0, 0, "%s is a new entry, no comparison available", finfo->file);
d285 1
a285 1
	    error (0, 0, "%s was removed, no comparison available", finfo->file);
d295 1
a295 1
	    error (0, 0, "cannot find revision control file for %s", finfo->file);
d304 1
a304 1
		error (0, 0, "cannot find %s", finfo->file);
d321 1
a321 1
    if (empty_file == DIFF_NEITHER && diff_file_nodiff (finfo->file, finfo->repository, finfo->entries, finfo->srcfiles, vers))
d327 1
d330 1
d334 2
a335 2
    if (finfo->update_dir[0])
	(void) printf ("Index: %s/%s\n", finfo->update_dir, finfo->file);
d337 1
a337 1
	(void) printf ("Index: %s\n", finfo->file);
d340 1
a340 1
    tocvsPath = wrap_tocvs_process_file(finfo->file);
d344 1
a344 1
	sprintf(fname,"%s/%s%s",CVSADM, CVSPREFIX, finfo->file);
d347 2
a348 2
		error (1, errno, "cannot remove %s", finfo->file);
	rename_file (finfo->file, fname);
d350 1
a350 1
	copy_file (tocvsPath, finfo->file);
d356 2
a357 2
		       finfo->file);
	(void) printf ("diff -N %s\n", finfo->file);
d361 1
a361 1
	    run_setup ("%s %s %s %s", DIFF, opts, DEVNULL, finfo->file);
a364 2
	    int retcode;

d370 4
a373 4
	    retcode = RCS_checkout (vers->srcfile->path, NULL, vers->vn_rcs,
	                            *options ? options : vers->options, tmpnam (tmp),
	                            0, 0);
	    if (retcode == -1)
a378 1
	    /* FIXME: what if retcode > 0?  */
d387 1
a387 1
	    run_setup ("%s%s -x,v/ %s %s -r%s -r%s", Rcsbin, RCS_DIFF,
d393 1
a393 1
	    run_setup ("%s%s -x,v/ %s %s -r%s", Rcsbin, RCS_DIFF, opts,
d415 1
a415 1
	if (unlink_file_dir (finfo->file) < 0)
d417 1
a417 1
		error (1, errno, "cannot remove %s", finfo->file);
d419 1
a419 1
	rename_file (fname,finfo->file);
d421 1
a421 1
	    error (1, errno, "cannot remove %s", finfo->file);
a505 1
    int retcode;
a532 2

		freevers_ts (&xvers);
a557 2

		freevers_ts (&xvers);
d605 4
a608 3
    retcode = RCS_checkout (vers->srcfile->path, NULL, use_rev1,
                            *options ? options : vers->options, tmpnam (tmp), 0, 0);
    switch (retcode)
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d23 1
a23 1
			     RCSNode *rcs, Vers_TS *vers));
d180 1
a180 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d243 1
a243 1
		       finfo->file, 1, 0, finfo->entries, finfo->rcs);
d252 1
a252 1
	error (0, 0, "I know nothing about %s", finfo->fullname);
d263 1
a263 2
	    error (0, 0, "%s is a new entry, no comparison available",
		   finfo->fullname);
d275 1
a275 2
	    error (0, 0, "%s was removed, no comparison available",
		   finfo->fullname);
d285 1
a285 2
	    error (0, 0, "cannot find revision control file for %s",
		   finfo->fullname);
d294 1
a294 1
		error (0, 0, "cannot find %s", finfo->fullname);
d311 1
a311 1
    if (empty_file == DIFF_NEITHER && diff_file_nodiff (finfo->file, finfo->repository, finfo->entries, finfo->rcs, vers))
d322 4
a325 1
    (void) printf ("Index: %s\n", finfo->fullname);
a342 2
	/* This is file, not fullname, because it is the "Index:" line which
	   is supposed to contain the directory.  */
d488 1
a488 1
diff_file_nodiff (file, repository, entries, rcs, vers)
d492 1
a492 1
    RCSNode *rcs;
d514 1
a514 1
				diff_date1, file, 1, 0, entries, rcs);
d541 1
a541 1
				diff_date2, file, 1, 0, entries, rcs);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d19 6
a24 22
enum diff_file
{
    DIFF_ERROR,
    DIFF_ADDED,
    DIFF_REMOVED,
    DIFF_DIFFERENT,
    DIFF_SAME
};

static Dtype diff_dirproc PROTO ((void *callerdat, char *dir,
				  char *pos_repos, char *update_dir,
				  List *entries));
static int diff_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repos, char *update_dir,
				      List *entries));
static int diff_dirleaveproc PROTO ((void *callerdat, char *dir,
				     int err, char *update_dir,
				     List *entries));
static enum diff_file diff_file_nodiff PROTO ((struct file_info *finfo,
					       Vers_TS *vers,
					       enum diff_file));
static int diff_fileproc PROTO ((void *callerdat, struct file_info *finfo));
a37 2
/* FIXME: arbitrary limit (security hole, if the client passes us
   data which overflows it).  */
a41 3
/* FIXME: should be documenting all the options here.  They don't
   perfectly match rcsdiff options (for example, we always support
   --ifdef and --context, but rcsdiff only does if diff does).  */
d45 1
d47 3
a58 73
/* I copied this array directly out of diff.c in diffutils 2.7, after
   removing the following entries, none of which seem relevant to use
   with CVS:
     --help
     --version
     --recursive
     --unidirectional-new-file
     --starting-file
     --exclude
     --exclude-from
     --sdiff-merge-assist

   I changed the options which take optional arguments (--context and
   --unified) to return a number rather than a letter, so that the
   optional argument could be handled more easily.  I changed the
   --paginate and --brief options to return a number, since -l and -q
   mean something else to cvs diff.

   The numbers 129- that appear in the fourth element of some entries
   tell the big switch in `diff' how to process those options. -- Ian

   The following options, which diff lists as "An alias, no longer
   recommended" have been removed: --file-label --entire-new-file
   --ascii --print.  */

static struct option const longopts[] =
{
    {"ignore-blank-lines", 0, 0, 'B'},
    {"context", 2, 0, 143},
    {"ifdef", 1, 0, 147},
    {"show-function-line", 1, 0, 'F'},
    {"speed-large-files", 0, 0, 'H'},
    {"ignore-matching-lines", 1, 0, 'I'},
    {"label", 1, 0, 'L'},
    {"new-file", 0, 0, 'N'},
    {"initial-tab", 0, 0, 'T'},
    {"width", 1, 0, 'W'},
    {"text", 0, 0, 'a'},
    {"ignore-space-change", 0, 0, 'b'},
    {"minimal", 0, 0, 'd'},
    {"ed", 0, 0, 'e'},
    {"forward-ed", 0, 0, 'f'},
    {"ignore-case", 0, 0, 'i'},
    {"paginate", 0, 0, 144},
    {"rcs", 0, 0, 'n'},
    {"show-c-function", 0, 0, 'p'},

    /* This is a potentially very useful option, except the output is so
       silly.  It would be much better for it to look like "cvs rdiff -s"
       which displays all the same info, minus quite a few lines of
       extraneous garbage.  */
    {"brief", 0, 0, 145},

    {"report-identical-files", 0, 0, 's'},
    {"expand-tabs", 0, 0, 't'},
    {"ignore-all-space", 0, 0, 'w'},
    {"side-by-side", 0, 0, 'y'},
    {"unified", 2, 0, 146},
    {"left-column", 0, 0, 129},
    {"suppress-common-lines", 0, 0, 130},
    {"old-line-format", 1, 0, 132},
    {"new-line-format", 1, 0, 133},
    {"unchanged-line-format", 1, 0, 134},
    {"line-format", 1, 0, 135},
    {"old-group-format", 1, 0, 136},
    {"new-group-format", 1, 0, 137},
    {"unchanged-group-format", 1, 0, 138},
    {"changed-group-format", 1, 0, 139},
    {"horizon-lines", 1, 0, 140},
    {"binary", 0, 0, 142},
    {0, 0, 0, 0}
};

a67 1
    int option_index;
d83 2
a84 3
    while ((c = getopt_long (argc, argv,
	       "abcdefhilnpstuwy0123456789BHNRTC:D:F:I:L:U:V:W:k:r:",
			     longopts, &option_index)) != -1)
d89 4
a92 4
	    case 'h': case 'i': case 'n': case 'p': case 's': case 't':
	    case 'u': case 'w': case 'y': case '0': case '1': case '2':
	    case '3': case '4': case '5': case '6': case '7': case '8':
	    case '9': case 'B': case 'H': case 'T':
d95 1
a95 20
		break;
	    case 'C': case 'F': case 'I': case 'L': case 'U': case 'V':
	    case 'W':
		(void) sprintf (tmp, " -%c", (char) c);
		strcat (opts, tmp);
		strcat (opts, optarg);
		break;
	    case 147:
		/* --ifdef.  */
		strcat (opts, " -D");
		strcat (opts, optarg);
		break;
	    case 129: case 130: case 131: case 132: case 133: case 134:
	    case 135: case 136: case 137: case 138: case 139: case 140:
	    case 141: case 142: case 143: case 144: case 145: case 146:
		strcat (opts, " --");
		strcat (opts, longopts[option_index].name);
		if (longopts[option_index].has_arg == 1
		    || (longopts[option_index].has_arg == 2
			&& optarg != NULL))
d97 3
a99 2
		    strcat (opts, "=");
		    strcat (opts, optarg);
d102 7
d115 3
d132 1
d142 1
d204 1
a204 1
    if (diff_rev1 != NULL || diff_date1 != NULL)
d211 2
a212 2
			   diff_dirleaveproc, NULL, argc, argv, local,
			   which, 0, 1, (char *) NULL, 1);
d224 1
a224 2
diff_fileproc (callerdat, finfo)
    void *callerdat;
d229 7
a235 2
    enum diff_file empty_file = DIFF_DIFFERENT;
    char *tmp;
d242 2
a243 1
    vers = Version_TS (finfo, NULL, NULL, NULL, 1, 0);
d252 4
a255 40
	/* The file does not exist in the working directory.  */
	if ((diff_rev1 != NULL || diff_date1 != NULL)
	    && vers->srcfile != NULL)
	{
	    /* The file does exist in the repository.  */
	    if (empty_files)
		empty_file = DIFF_REMOVED;
	    else
	    {
		int exists;

		exists = 0;
		/* special handling for TAG_HEAD */
		if (diff_rev1 && strcmp (diff_rev1, TAG_HEAD) == 0)
		    exists = vers->vn_rcs != NULL;
		else
		{
		    Vers_TS *xvers;

		    xvers = Version_TS (finfo, NULL, diff_rev1, diff_date1,
					1, 0);
		    exists = xvers->vn_rcs != NULL;
		    freevers_ts (&xvers);
		}
		if (exists)
		    error (0, 0,
			   "%s no longer exists, no comparison available",
			   finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
	else
	{
	    error (0, 0, "I know nothing about %s", finfo->fullname);
	    freevers_ts (&vers);
	    diff_mark_errors (err);
	    return (err);
	}
d314 1
a314 2
    empty_file = diff_file_nodiff (finfo, vers, empty_file);
    if (empty_file == DIFF_SAME || empty_file == DIFF_ERROR)
d317 1
a317 7
	if (empty_file == DIFF_SAME)
	    return (0);
	else
	{
	    diff_mark_errors (err);
	    return (err);
	}
d320 2
a321 45
    if (empty_file == DIFF_DIFFERENT)
    {
	int dead1, dead2;

	if (use_rev1 == NULL)
	    dead1 = 0;
	else
	    dead1 = RCS_isdead (vers->srcfile, use_rev1);
	if (use_rev2 == NULL)
	    dead2 = 0;
	else
	    dead2 = RCS_isdead (vers->srcfile, use_rev2);

	if (dead1 && dead2)
	{
	    freevers_ts (&vers);
	    return (0);
	}
	else if (dead1)
	{
	    if (empty_files)
	        empty_file = DIFF_ADDED;
	    else
	    {
		error (0, 0, "%s is a new entry, no comparison available",
		       finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
	else if (dead2)
	{
	    if (empty_files)
		empty_file = DIFF_REMOVED;
	    else
	    {
		error (0, 0, "%s was removed, no comparison available",
		       finfo->fullname);
		freevers_ts (&vers);
		diff_mark_errors (err);
		return (err);
	    }
	}
    }
d351 1
a351 23
	    if (use_rev2 == NULL)
		run_setup ("%s %s %s %s", DIFF, opts, DEVNULL, finfo->file);
	    else
	    {
		int retcode;

		tmp = cvs_temp_name ();
		retcode = RCS_checkout (vers->srcfile, (char *) NULL,
					use_rev2, (char *) NULL,
					(*options
					 ? options
					 : vers->options),
					tmp);
		if (retcode == -1)
		{
		    (void) CVS_UNLINK (tmp);
		    error (1, errno, "fork failed during checkout of %s",
			   vers->srcfile->path);
		}
		/* FIXME: what if retcode > 0?  */

		run_setup ("%s %s %s %s", DIFF, opts, DEVNULL, tmp);
	    }
d357 8
a364 5
	    tmp = cvs_temp_name ();
	    retcode = RCS_checkout (vers->srcfile, (char *) NULL,
				    use_rev1, (char *) NULL,
				    *options ? options : vers->options,
				    tmp);
d367 1
a367 1
		(void) CVS_UNLINK (tmp);
d417 2
a418 6
    if (empty_file == DIFF_REMOVED
	|| (empty_file == DIFF_ADDED && use_rev2 != NULL))
    {
	(void) CVS_UNLINK (tmp);
	free (tmp);
    }
d444 1
a444 2
diff_dirproc (callerdat, dir, pos_repos, update_dir, entries)
    void *callerdat;
a447 1
    List *entries;
d465 1
a465 2
diff_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
a468 1
    List *entries;
d478 1
a478 2
diff_dirleaveproc (callerdat, dir, err, update_dir, entries)
    void *callerdat;
a481 1
    List *entries;
d487 1
a487 1
 * verify that a file is different
d489 6
a494 3
static enum diff_file
diff_file_nodiff (finfo, vers, empty_file)
    struct file_info *finfo;
a495 1
    enum diff_file empty_file;
d498 1
a498 1
    char *tmp;
d515 17
a531 3
	    xvers = Version_TS (finfo, NULL, diff_rev1, diff_date1, 1, 0);
	    if (xvers->vn_rcs != NULL)
		use_rev1 = xstrdup (xvers->vn_rcs);
d542 17
a558 3
	    xvers = Version_TS (finfo, NULL, diff_rev2, diff_date2, 1, 0);
	    if (xvers->vn_rcs != NULL)
		use_rev2 = xstrdup (xvers->vn_rcs);
a561 34
	if (use_rev1 == NULL)
	{
	    /* The first revision does not exist.  If EMPTY_FILES is
               true, treat this as an added file.  Otherwise, warn
               about the missing tag.  */
	    if (use_rev2 == NULL)
		return DIFF_SAME;
	    else if (empty_files)
		return DIFF_ADDED;
	    else if (diff_rev1)
		error (0, 0, "tag %s is not in file %s", diff_rev1,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date1, finfo->fullname);
	    return DIFF_ERROR;
	}

	if (use_rev2 == NULL)
	{
	    /* The second revision does not exist.  If EMPTY_FILES is
               true, treat this as a removed file.  Otherwise warn
               about the missing tag.  */
	    if (empty_files)
		return DIFF_REMOVED;
	    else if (diff_rev2)
		error (0, 0, "tag %s is not in file %s", diff_rev2,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date2, finfo->fullname);
	    return DIFF_ERROR;
	}

d563 5
a567 32
	if (strcmp (use_rev1, use_rev2) == 0)
	    return DIFF_SAME;
	else
	    return DIFF_DIFFERENT;
    }

    if ((diff_rev1 || diff_date1) && use_rev1 == NULL)
    {
	/* The first revision does not exist, and no second revision
           was given.  */
	if (empty_files)
	{
	    if (empty_file == DIFF_REMOVED)
		return DIFF_SAME;
	    else
	    {
#ifdef SERVER_SUPPORT
		if (user_file_rev && use_rev2 == NULL)
		    use_rev2 = xstrdup (user_file_rev);
#endif
		return DIFF_ADDED;
	    }
	}
	else
	{
	    if (diff_rev1)
		error (0, 0, "tag %s is not in file %s", diff_rev1,
		       finfo->fullname);
	    else
		error (0, 0, "no revision for date %s in file %s",
		       diff_date1, finfo->fullname);
	    return DIFF_ERROR;
a569 1

d571 1
a571 1
    if (user_file_rev)
d585 1
a585 4
	if (strcmp (use_rev1, use_rev2) == 0)
	    return DIFF_SAME;
	else
	    return DIFF_DIFFERENT;
d588 1
a588 2
    if (use_rev1 == NULL
	|| (vers->vn_user != NULL && strcmp (use_rev1, vers->vn_user) == 0))
d593 1
a593 1
	    return DIFF_SAME;
a598 5
    /* If we already know that the file is being added or removed,
       then we don't want to do an actual file comparison here.  */
    if (empty_file != DIFF_DIFFERENT)
	return empty_file;

d603 2
a604 5
    tmp = cvs_temp_name ();
    retcode = RCS_checkout (vers->srcfile, (char *) NULL, use_rev1,
			    (char *) NULL,
			    *options ? options : vers->options,
			    tmp);
d608 1
a608 1
	    if (xcmp (finfo->file, tmp) == 0)
d610 2
a611 3
		(void) CVS_UNLINK (tmp);
		free (tmp);
		return DIFF_SAME;
d615 1
a615 1
	    (void) CVS_UNLINK (tmp);
d621 2
a622 3
    (void) CVS_UNLINK (tmp);
    free (tmp);
    return DIFF_DIFFERENT;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d54 3
a56 2
static char *opts;
static size_t opts_allocated = 1;
a148 22
static void strcat_and_allocate PROTO ((char **, size_t *, const char *));

/* *STR is a pointer to a malloc'd string.  *LENP is its allocated
   length.  Add SRC to the end of it, reallocating if necessary.  */
static void
strcat_and_allocate (str, lenp, src)
    char **str;
    size_t *lenp;
    const char *src;
{
    size_t new_size;

    new_size = strlen (*str) + strlen (src) + 1;
    if (*str == NULL || new_size >= *lenp)
    {
	while (new_size >= *lenp)
	    *lenp *= 2;
	*str = xrealloc (*str, *lenp);
    }
    strcat (*str, src);
}

d168 3
a170 9

    /* For server, need to be able to do this command more than once
       (according to the protocol spec, even if the current client
       doesn't use it).  */
    if (opts == NULL)
    {
	opts_allocated = 1;
	opts = xmalloc (opts_allocated);
    }
d172 1
a172 1

d186 1
a186 1
		strcat_and_allocate (&opts, &opts_allocated, tmp);
d191 2
a192 2
		strcat_and_allocate (&opts, &opts_allocated, tmp);
		strcat_and_allocate (&opts, &opts_allocated, optarg);
d196 2
a197 2
		strcat_and_allocate (&opts, &opts_allocated, " -D");
		strcat_and_allocate (&opts, &opts_allocated, optarg);
d202 2
a203 3
		strcat_and_allocate (&opts, &opts_allocated, " --");
		strcat_and_allocate (&opts, &opts_allocated,
				     longopts[option_index].name);
d208 2
a209 2
		    strcat_and_allocate (&opts, &opts_allocated, "=");
		    strcat_and_allocate (&opts, &opts_allocated, optarg);
d287 1
a287 1
	send_files (argc, argv, local, 0, 0);
d331 1
a331 1
    char *fname;
a510 4
	fname = xmalloc (strlen (finfo->file)
			 + sizeof CVSADM
			 + sizeof CVSPREFIX
			 + 10);
d514 1
a514 1
		error (1, errno, "cannot remove %s", fname);
d612 1
a612 2
	    error (1, errno, "cannot remove %s", tocvsPath);
	free (fname);
a830 1

d834 2
a835 4
	if (empty_file == DIFF_DIFFERENT
	    && vers->ts_user != NULL
	    && strcmp (vers->ts_rcs, vers->ts_user) == 0
	    && (!(*options) || strcmp (options, vers->options) == 0))
d839 2
a840 8
	if (use_rev1 == NULL
	    && (vers->vn_user[0] != '0' || vers->vn_user[1] != '\0'))
	{
	    if (vers->vn_user[0] == '-')
		use_rev1 = xstrdup (vers->vn_user + 1);
	    else
		use_rev1 = xstrdup (vers->vn_user);
	}
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a71 3
    "\t--ifdef=arg\tOutput diffs in ifdef format.\n",
    "(consult the documentation for your diff program for rcsdiff-options.\n",
    "The most popular is -c for context diffs but there are many more).\n",
a296 2
	if (options[0] != '\0')
	    send_arg (options);
d315 1
a315 1
	send_files (argc, argv, local, 0, 0, 0);
a778 4
		/* At least in the case where DIFF_REV1 and DIFF_REV2
		   are both numeric, we should be returning some kind
		   of error (see basicb-8a0 in testsuite).  The symbolic
		   case may be more complicated.  */
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d205 1
a205 1
	       "+abcdefhilnpstuwy0123456789BHNRTC:D:F:I:L:U:V:W:k:r:",
d312 5
a316 1

d319 2
a320 3
	    send_files (argc, argv, local, 0, 0);
	else
	    send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
d579 1
a579 2
					tmp, (RCSCHECKOUTPROC) NULL,
					(void *) NULL);
d599 1
a599 2
				    tmp, (RCSCHECKOUTPROC) NULL,
				    (void *) NULL);
d742 1
d903 3
a905 2

    retcode = RCS_cmp_file (vers->srcfile, use_rev1,
d907 21
a927 3
			    finfo->file);

    return retcode == 0 ? DIFF_SAME : DIFF_DIFFERENT;
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d47 1
d51 1
d64 1
a64 1
    "Usage: %s %s [-lNR] [rcsdiff-options]\n",
a66 1
    "\t-R\tProcess directories recursively.\n",
d203 1
a203 1
    optind = 0;
d363 1
d365 1
d461 1
d469 1
a477 8
	{
	    /* In the server case, would be nice to send a "Checked-in"
	       response, so that the client can rewrite its timestamp.
	       server_checked_in by itself isn't the right thing (it
	       needs a server_register), but I'm not sure what is.
	       It isn't clear to me how "cvs status" handles this (that
	       is, for a client which sends Modified not Is-modified to
	       "cvs status"), but it does.  */
a478 1
	}
d646 1
a646 1
	rename_file (fname, finfo->file);
d831 1
d834 1
d850 1
d870 1
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
a45 1
static int have_rev1_label, have_rev2_label;
a73 1
    "(Specify the --help global option for a list of other help options)\n",
d106 1
a106 1
    {"ifdef", 1, 0, 131},
d112 1
a112 1
    {"initial-tab", 0, 0, 148},
d133 1
a133 1
    {"side-by-side", 0, 0, 147},
a149 31
/* CVS 1.9 and similar versions seemed to have pretty weird handling
   of -y and -T.  In the cases where it called rcsdiff,
   they would have the meanings mentioned below.  In the cases where it
   called diff, they would have the meanings mentioned in "longopts".
   Noone seems to have missed them, so I think the right thing to do is
   just to remove the options altogether (which I have done).

   In the case of -z and -q, "cvs diff" did not accept them even back
   when we called rcsdiff (at least, it hasn't accepted them
   recently).

   In comparing rcsdiff to the new CVS implementation, I noticed that
   the following rcsdiff flags are not handled by CVS diff:

	   -y: perform diff even when the requested revisions are the
		   same revision number
	   -q: run quietly
	   -T: preserve modification time on the RCS file
	   -z: specify timezone for use in file labels

   I think these are not really relevant.  -y is undocumented even in
   RCS 5.7, and seems like a minor change at best.  According to RCS
   documentation, -T only applies when a RCS file has been modified
   because of lock changes; doesn't CVS sidestep RCS's entire lock
   structure?  -z seems to be unsupported by CVS diff, and has a
   different meaning as a global option anyway.  (Adding it could be
   a feature, but if it is left out for now, it should not break
   anything.)  For the purposes of producing output, CVS diff appears
   mostly to ignore -q.  Maybe this should be fixed, but I think it's
   a larger issue than the changes included here.  */

a185 2
    have_rev1_label = have_rev2_label = 0;

d204 1
a204 1
	       "+abcdefhilnpstuw0123456789BHNRC:D:F:I:L:U:V:W:k:r:",
d211 1
a211 1
	    case 'u': case 'w': case '0': case '1': case '2':
d213 1
a213 1
	    case '9': case 'B': case 'H':
d217 2
a218 12
	    case 'L':
		if (have_rev1_label++)
		    if (have_rev2_label++)
		    {
			error (0, 0, "extra -L arguments ignored");
			break;
		    }

	        strcat_and_allocate (&opts, &opts_allocated, " -L");
	        strcat_and_allocate (&opts, &opts_allocated, optarg);
		break;
	    case 'C': case 'F': case 'I': case 'U': case 'V': case 'W':
d223 1
a223 1
	    case 131:
d228 1
a228 1
	    case 129: case 130:           case 132: case 133: case 134:
a230 1
	    case 147: case 148:
a361 5
    /* Initialize these solely to avoid warnings from gcc -Wall about
       variables that might be used uninitialized.  */
    tmp = NULL;
    fname = NULL;

d537 3
a539 3
    cvs_output ("Index: ", 0);
    cvs_output (finfo->fullname, 0);
    cvs_output ("\n", 1);
d562 3
a564 9
	cvs_output ("\
===================================================================\n\
RCS file: ", 0);
	cvs_output (finfo->file, 0);
	cvs_output ("\n", 1);

	cvs_output ("diff -N ", 0);
	cvs_output (finfo->file, 0);
	cvs_output ("\n", 1);
d569 1
a569 1
		status = diff_exec (DEVNULL, finfo->file, opts, RUN_TTY);
d590 1
a590 1
		status = diff_exec (DEVNULL, tmp, opts, RUN_TTY);
d611 1
a611 1
	    status = diff_exec (tmp, DEVNULL, opts, RUN_TTY);
d616 12
a627 19
	char *label1 = NULL;
	char *label2 = NULL;

	if (!have_rev1_label)
	    label1 =
		make_file_label (finfo->fullname, use_rev1, vers->srcfile);

	if (!have_rev2_label)
	    label2 =
		make_file_label (finfo->fullname, use_rev2, vers->srcfile);

	status = RCS_exec_rcsdiff (vers->srcfile, opts,
				   *options ? options : vers->options,
				   use_rev1, use_rev2,
				   label1, label2,
				   finfo->file);

	if (label1) free (label1);
	if (label2) free (label2);
d630 2
a631 1
    switch (status)
d634 1
a634 1
	    error (1, errno, "fork failed while diffing %s",
d663 1
d697 3
a699 3
    if (!isdir (dir))
	return (R_SKIP_ALL);

d856 1
a856 1
	    use_rev1 = xstrdup (user_file_rev);
d858 1
a858 1
	    use_rev2 = xstrdup (user_file_rev);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d639 1
a639 1
		if (retcode != 0)
d641 3
a643 2
		    diff_mark_errors (err);
		    return err;
d645 1
d660 1
a660 1
	    if (retcode != 0)
d662 3
a664 2
		diff_mark_errors (err);
		return err;
d666 1
d722 1
a722 2
	if (CVS_UNLINK (tmp) < 0)
	    error (0, errno, "cannot remove %s", tmp);
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d437 1
a437 9
		{
		    char *head =
			(vers->vn_rcs == NULL
			 ? NULL
			 : RCS_branch_head (vers->srcfile, vers->vn_rcs));
		    exists = head != NULL;
		    if (head != NULL)
			free (head);
		}
d817 1
a817 3
	    use_rev1 = ((vers->vn_rcs == NULL || vers->srcfile == NULL)
			? NULL
			: RCS_branch_head (vers->srcfile, vers->vn_rcs));
d830 1
a830 3
	    use_rev2 = ((vers->vn_rcs == NULL || vers->srcfile == NULL)
			? NULL
			: RCS_branch_head (vers->srcfile, vers->vn_rcs));
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a42 5

/* Global variables.  Would be cleaner if we just put this stuff in a
   struct like log.c does.  */

/* Command line tags, from -r option.  Points into argv.  */
a43 1
/* Command line dates, from -D option.  Malloc'd.  */
d227 3
a229 3
    /* Clean out our global variables (multiroot can call us multiple
       times and the server can too, if the client sends several
       diff commands).  */
a235 4
    diff_rev1 = NULL;
    diff_rev2 = NULL;
    diff_date1 = NULL;
    diff_date2 = NULL;
d356 2
a363 2
	send_file_names (argc, argv, SEND_EXPAND_WILD);

a366 1
	options = NULL;
a388 7
    options = NULL;

    if (diff_date1 != NULL)
	free (diff_date1);
    if (diff_date2 != NULL)
	free (diff_date2);

@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d280 1
a280 1
		strcat_and_allocate (&opts, &opts_allocated, " --ifdef=");
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@d120 1
a120 1
    {"initial-tab", 0, 0, 'T'},
d141 1
a141 1
    {"side-by-side", 0, 0, 'y'},
d189 22
d249 1
a249 1
	       "+abcdefhilnpstuwy0123456789BHNRTC:D:F:I:L:U:V:W:k:r:",
d256 3
a258 4
	    case 'u': case 'w': case 'y':
            case '0': case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
	    case 'B': case 'H': case 'T':
d260 1
a260 1
		allocate_and_strcat (&opts, &opts_allocated, tmp);
d270 2
a271 2
	        allocate_and_strcat (&opts, &opts_allocated, " -L");
	        allocate_and_strcat (&opts, &opts_allocated, optarg);
d275 2
a276 2
		allocate_and_strcat (&opts, &opts_allocated, tmp);
		allocate_and_strcat (&opts, &opts_allocated, optarg);
d280 2
a281 2
		allocate_and_strcat (&opts, &opts_allocated, " --ifdef=");
		allocate_and_strcat (&opts, &opts_allocated, optarg);
d286 3
a288 2
		allocate_and_strcat (&opts, &opts_allocated, " --");
		allocate_and_strcat (&opts, &opts_allocated,
d294 2
a295 2
		    allocate_and_strcat (&opts, &opts_allocated, "=");
		    allocate_and_strcat (&opts, &opts_allocated, optarg);
d344 1
a344 1
    if (current_parsed_root->isremote) {
a424 2
    char *label1;
    char *label2;
a634 26
    /* Set up file labels appropriate for compatibility with the Larry Wall
     * implementation of patch if the user didn't specify.  This is irrelevant
     * according to the POSIX.2 specification.
     */
    label1 = NULL;
    label2 = NULL;
    if (!have_rev1_label)
    {
	if (empty_file == DIFF_ADDED)
	    label1 =
		make_file_label (DEVNULL, NULL, NULL);
	else
	    label1 =
		make_file_label (finfo->fullname, use_rev1, vers ? vers->srcfile : NULL);
    }

    if (!have_rev2_label)
    {
	if (empty_file == DIFF_REMOVED)
	    label2 =
		make_file_label (DEVNULL, NULL, NULL);
	else
	    label2 =
		make_file_label (finfo->fullname, use_rev2, vers ? vers->srcfile : NULL);
    }

d637 2
a638 5
	/* This is fullname, not file, possibly despite the POSIX.2
	 * specification, because that's the way all the Larry Wall
	 * implementations of patch (are there other implementations?) want
	 * things and the POSIX.2 spec appears to leave room for this.
	 */
d642 1
a642 1
	cvs_output (finfo->fullname, 0);
d646 1
a646 1
	cvs_output (finfo->fullname, 0);
d652 1
a652 1
		status = diff_exec (DEVNULL, finfo->file, label1, label2, opts, RUN_TTY);
d671 1
a671 1
		status = diff_exec (DEVNULL, tmp, label1, label2, opts, RUN_TTY);
d690 1
a690 1
	    status = diff_exec (tmp, DEVNULL, label1, label2, opts, RUN_TTY);
d695 11
@


