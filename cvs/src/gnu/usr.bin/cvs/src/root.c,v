head	1.6;
access;
symbols
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.18
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.14
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.16
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.12
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.10
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.6
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.4
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.2
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.44
	OPENBSD_5_0:1.5.0.42
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.40
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.38
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.34
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.36
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.32
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.30
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.28
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.26
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.24
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.22
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.20
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.18
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.16
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.14
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.12
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.10
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.1.1.11.0.6
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.4
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.2
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.10.0.2
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.9.0.4
	OPENBSD_2_4_BASE:1.1.1.9
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.9
	OPENBSD_2_3:1.1.1.9.0.2
	OPENBSD_2_3_BASE:1.1.1.9
	cvs-1-9-26:1.1.1.9
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.21.23.49.11;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.10.19.31.36;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.12.07.49.18;	author todd;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.25;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.13;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.51;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.48;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.23;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.27.48;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.28.55;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.31;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.29;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.10.05.06.26;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.46;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.6
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Mark D. Baushke
 *
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Name of Root
 * 
 * Determine the path to the CVSROOT and set "Root" accordingly.
 */

#include "cvs.h"
#include "getline.h"

/* Printable names for things in the current_parsed_root->method enum variable.
   Watch out if the enum is changed in cvs.h! */

char *method_names[] = {
    "undefined", "local", "server (ssh)", "pserver", "kserver", "gserver", "ext", "fork"
};

#ifndef DEBUG

char *
Name_Root (dir, update_dir)
    char *dir;
    char *update_dir;
{
    FILE *fpin;
    char *ret, *xupdate_dir;
    char *root = NULL;
    size_t root_allocated = 0;
    char *tmp;
    char *cvsadm;
    char *cp;

    if (update_dir && *update_dir)
	xupdate_dir = update_dir;
    else
	xupdate_dir = ".";

    if (dir != NULL)
    {
	cvsadm = xmalloc (strlen (dir) + sizeof (CVSADM) + 10);
	(void) sprintf (cvsadm, "%s/%s", dir, CVSADM);
	tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
	(void) sprintf (tmp, "%s/%s", dir, CVSADM_ROOT);
    }
    else
    {
	cvsadm = xstrdup (CVSADM);
	tmp = xstrdup (CVSADM_ROOT);
    }

    /*
     * Do not bother looking for a readable file if there is no cvsadm
     * directory present.
     *
     * It is possible that not all repositories will have a CVS/Root
     * file. This is ok, but the user will need to specify -d
     * /path/name or have the environment variable CVSROOT set in
     * order to continue.  */
    if ((!isdir (cvsadm)) || (!isreadable (tmp)))
    {
	ret = NULL;
	goto out;
    }

    /*
     * The assumption here is that the CVS Root is always contained in the
     * first line of the "Root" file.
     */
    fpin = open_file (tmp, "r");

    if (get_line (&root, &root_allocated, fpin) < 0)
    {
	/* FIXME: should be checking for end of file separately; errno
	   is not set in that case.  */
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, errno, "cannot read %s", CVSADM_ROOT);
	error (0, 0, "please correct this problem");
	ret = NULL;
	goto out;
    }
    (void) fclose (fpin);
    if ((cp = strrchr (root, '\n')) != NULL)
	*cp = '\0';			/* strip the newline */

    /*
     * root now contains a candidate for CVSroot. It must be an
     * absolute pathname or specify a remote server.
     */

    if (
#ifdef CLIENT_SUPPORT
	(strchr (root, ':') == NULL) &&
#endif
    	! isabsolute (root))
    {
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, 0,
	       "ignoring %s because it does not contain an absolute pathname.",
	       CVSADM_ROOT);
	ret = NULL;
	goto out;
    }

#ifdef CLIENT_SUPPORT
    if ((strchr (root, ':') == NULL) && !isdir (root))
#else /* ! CLIENT_SUPPORT */
    if (!isdir (root))
#endif /* CLIENT_SUPPORT */
    {
	error (0, 0, "in directory %s:", xupdate_dir);
	error (0, 0,
	       "ignoring %s because it specifies a non-existent repository %s",
	       CVSADM_ROOT, root);
	ret = NULL;
	goto out;
    }

    /* allocate space to return and fill it in */
    strip_trailing_slashes (root);
    ret = xstrdup (root);
 out:
    free (cvsadm);
    free (tmp);
    if (root != NULL)
	free (root);
    return (ret);
}

/*
 * Write the CVS/Root file so that the environment variable CVSROOT
 * and/or the -d option to cvs will be validated or not necessary for
 * future work.
 */
void
Create_Root (dir, rootdir)
    char *dir;
    char *rootdir;
{
    FILE *fout;
    char *tmp;

    if (noexec)
	return;

    /* record the current cvs root */

    if (rootdir != NULL)
    {
        if (dir != NULL)
	{
	    tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
	    (void) sprintf (tmp, "%s/%s", dir, CVSADM_ROOT);
	}
        else
	    tmp = xstrdup (CVSADM_ROOT);

        fout = open_file (tmp, "w+");
        if (fprintf (fout, "%s\n", rootdir) < 0)
	    error (1, errno, "write to %s failed", tmp);
        if (fclose (fout) == EOF)
	    error (1, errno, "cannot close %s", tmp);
	free (tmp);
    }
}

#endif /* ! DEBUG */


/* The root_allow_* stuff maintains a list of legal CVSROOT
   directories.  Then we can check against them when a remote user
   hands us a CVSROOT directory.  */

static int root_allow_count;
static char **root_allow_vector;
static int root_allow_size;

void
root_allow_add (arg)
    char *arg;
{
    char *p;

    if (root_allow_size <= root_allow_count)
    {
	if (root_allow_size == 0)
	{
	    root_allow_size = 1;
	    root_allow_vector =
		(char **) malloc (root_allow_size * sizeof (char *));
	}
	else
	{
	    root_allow_size *= 2;
	    root_allow_vector =
		(char **) realloc (root_allow_vector,
				   root_allow_size * sizeof (char *));
	}

	if (root_allow_vector == NULL)
	{
	no_memory:
	    /* Strictly speaking, we're not supposed to output anything
	       now.  But we're about to exit(), give it a try.  */
	    printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket
	       subsystems on NT and OS2 or dealing with windows
	       and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
    }
    p = malloc (strlen (arg) + 1);
    if (p == NULL)
	goto no_memory;
    strcpy (p, arg);
    root_allow_vector[root_allow_count++] = p;
}

void
root_allow_free ()
{
    if (root_allow_vector != NULL)
	free_names (&root_allow_count, root_allow_vector);
    root_allow_size = 0;
}

int
root_allow_ok (arg)
    char *arg;
{
    int i;

    if (root_allow_count == 0)
    {
	/* Probably someone upgraded from CVS before 1.9.10 to 1.9.10
	   or later without reading the documentation about
	   --allow-root.  Printing an error here doesn't disclose any
	   particularly useful information to an attacker because a
	   CVS server configured in this way won't let *anyone* in.  */

	/* Note that we are called from a context where we can spit
	   back "error" rather than waiting for the next request which
	   expects responses.  */
	printf ("\
error 0 Server configuration missing --allow-root in inetd.conf\n");
	error_exit ();
    }

    for (i = 0; i < root_allow_count; ++i)
	if (strcmp (root_allow_vector[i], arg) == 0)
	    return 1;
    return 0;
}



/* This global variable holds the global -d option.  It is NULL if -d
   was not used, which means that we must get the CVSroot information
   from the CVSROOT environment variable or from a CVS/Root file.  */

char *CVSroot_cmdline;



/* Parse a CVSROOT variable into its constituent parts -- method,
 * username, hostname, directory.  The prototypical CVSROOT variable
 * looks like:
 *
 * :method:user@@host:path
 *
 * Some methods may omit fields; local, for example, doesn't need user
 * and host.
 *
 * Returns pointer to new cvsroot_t on success, NULL on failure. */

cvsroot_t *current_parsed_root = NULL;



/* allocate and initialize a cvsroot_t
 *
 * We must initialize the strings to NULL so we know later what we should
 * free
 *
 * Some of the other zeroes remain meaningful as, "never set, use default",
 * or the like
 */
static cvsroot_t *
new_cvsroot_t ()
{
    cvsroot_t *newroot;

    /* gotta store it somewhere */
    newroot = xmalloc(sizeof(cvsroot_t));

    newroot->original = NULL;
    newroot->method = null_method;
    newroot->username = NULL;
    newroot->password = NULL;
    newroot->hostname = NULL;
    newroot->port = 0;
    newroot->directory = NULL;
#ifdef CLIENT_SUPPORT
    newroot->isremote = 0;
#endif /* CLIENT_SUPPORT */

    return newroot;
}



/* Dispose of a cvsroot_t and its component parts */
void
free_cvsroot_t (root)
    cvsroot_t *root;
{
    if (root->original != NULL)
	free (root->original);
    if (root->username != NULL)
	free (root->username);
    if (root->password != NULL)
    {
	/* I like to be paranoid */
	memset (root->password, 0, strlen (root->password));
	free (root->password);
    }
    if (root->hostname != NULL)
	free (root->hostname);
    if (root->directory != NULL)
	free (root->directory);
    free (root);
}



/*
 * parse a CVSROOT string to allocate and return a new cvsroot_t structure
 */
cvsroot_t *
parse_cvsroot (root_in)
    char *root_in;
{
    cvsroot_t *newroot;			/* the new root to be returned */
    char *cvsroot_save;			/* what we allocated so we can dispose
					 * it when finished */
    char *firstslash;			/* save where the path spec starts
					 * while we parse
					 * [[user][:password]@@]host[:[port]]
					 */
    char *cvsroot_copy, *p, *q;		/* temporary pointers for parsing */
    char *new_hostname;
    int check_hostname, no_port, no_password;

    /* allocate some space */
    newroot = new_cvsroot_t();

    /* save the original string */
    newroot->original = xstrdup (root_in);

    /* and another copy we can munge while parsing */
    cvsroot_save = cvsroot_copy = xstrdup (root_in);

    if (*cvsroot_copy == ':')
    {
	char *method = ++cvsroot_copy;

	/* Access method specified, as in
	 * "cvs -d :(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path",
	 * "cvs -d [:(ext|server):][[user]@@]host[:]/path",
	 * "cvs -d :local:e:\path",
	 * "cvs -d :fork:/path".
	 * We need to get past that part of CVSroot before parsing the
	 * rest of it.
	 */

	if (! (p = strchr (method, ':')))
	{
	    error (0, 0, "bad CVSroot: %s", root_in);
	    free (cvsroot_save);
	    goto error_exit;
	}
	*p = '\0';
	cvsroot_copy = ++p;

	/* Now we have an access method -- see if it's valid. */

	if (strcmp (method, "local") == 0)
	    newroot->method = local_method;
	else if (strcmp (method, "pserver") == 0)
	    newroot->method = pserver_method;
	else if (strcmp (method, "kserver") == 0)
	    newroot->method = kserver_method;
	else if (strcmp (method, "gserver") == 0)
	    newroot->method = gserver_method;
	else if (strcmp (method, "server") == 0)
	    newroot->method = server_method;
	else if (strcmp (method, "ext") == 0)
	    newroot->method = ext_method;
	else if (strcmp (method, "fork") == 0)
	    newroot->method = fork_method;
	else
	{
	    error (0, 0, "unknown method in CVSroot: %s", root_in);
	    free (cvsroot_save);
	    goto error_exit;
	}
    }
    else
    {
	/* If the method isn't specified, assume
	   SERVER_METHOD/EXT_METHOD if the string contains a colon or
	   LOCAL_METHOD otherwise.  */

	newroot->method = ((*cvsroot_copy != '/' && strchr (cvsroot_copy, '/'))
/*#ifdef RSH_NOT_TRANSPARENT
			  ? server_method
#else*/
			  ? ext_method
/*#endif*/
			  : local_method);
    }

#ifdef CLIENT_SUPPORT
    newroot->isremote = (newroot->method != local_method);
#endif /* CLIENT_SUPPORT */


    if ((newroot->method != local_method)
	&& (newroot->method != fork_method))
    {
	/* split the string into [[user][:password]@@]host[:[port]] & /path
	 *
	 * this will allow some characters such as '@@' & ':' to remain unquoted
	 * in the path portion of the spec
	 */
	if ((p = strchr (cvsroot_copy, '/')) == NULL)
	{
	    error (0, 0, "CVSROOT (\"%s\")", root_in);
	    error (0, 0, "requires a path spec");
	    error (0, 0, ":(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path");
	    error (0, 0, "[:(ext|server):][[user]@@]host[:]/path");
	    free (cvsroot_save);
	    goto error_exit;
	}
	firstslash = p;		/* == NULL if '/' not in string */
	*p = '\0';

	/* Check to see if there is a username[:password] in the string. */
	if ((p = strchr (cvsroot_copy, '@@')) != NULL)
	{
	    *p = '\0';
	    /* check for a password */
	    if ((q = strchr (cvsroot_copy, ':')) != NULL)
	    {
		*q = '\0';
		newroot->password = xstrdup (++q);
		/* Don't check for *newroot->password == '\0' since
		 * a user could conceivably wish to specify a blank password
		 * (newroot->password == NULL means to use the
		 * password from .cvspass)
		 */
	    }

	    /* copy the username */
	    if (*cvsroot_copy != '\0')
		/* a blank username is impossible, so leave it NULL in that
		 * case so we know to use the default username
		 */
		newroot->username = xstrdup (cvsroot_copy);

	    cvsroot_copy = ++p;
	}

	new_hostname = NULL;
	if (*cvsroot_copy == '[')
	{
		p = strchr(cvsroot_copy, ']');
		if (p != NULL)
		{
			*p = '\0';
			new_hostname = xstrdup (cvsroot_copy+1);
			*p++ = ']';
			if (*p == ':')
				cvsroot_copy = p;
		}
	}

	/* now deal with host[:[port]] */

	/* the port */
	if ((p = strchr (cvsroot_copy, ':')) != NULL)
	{
	    *p++ = '\0';
	    if (strlen(p))
	    {
		q = p;
		if (*q == '-') q++;
		while (*q)
		{
		    if (!isdigit(*q++))
		    {
			error(0, 0, "CVSROOT (\"%s\")", root_in);
			error(0, 0, "may only specify a positive, non-zero, integer port (not \"%s\").",
				p);
			error(0, 0, "perhaps you entered a relative pathname?");
			free (cvsroot_save);
			if (new_hostname != NULL)
			    free (new_hostname);
			goto error_exit;
		    }
		}
		if ((newroot->port = atoi (p)) <= 0)
		{
		    error (0, 0, "CVSROOT (\"%s\")", root_in);
		    error(0, 0, "may only specify a positive, non-zero, integer port (not \"%s\").",
			    p);
		    error(0, 0, "perhaps you entered a relative pathname?");
		    if (new_hostname != NULL)
			free (new_hostname);
		    free (cvsroot_save);
		    goto error_exit;
		}
	    }
	}

	/* copy host */
	if (new_hostname != NULL)
	    newroot->hostname = new_hostname;
	else if (*cvsroot_copy != '\0')
	    /* blank hostnames are invalid, but for now leave the field NULL
	     * and catch the error during the sanity checks later
	     */
	    newroot->hostname = xstrdup (cvsroot_copy);

	/* restore the '/' */
	cvsroot_copy = firstslash;
	*cvsroot_copy = '/';
    }

    /* parse the path for all methods */
    newroot->directory = xstrdup(cvsroot_copy);
    free (cvsroot_save);

    /*
     * Do various sanity checks.
     */

#if ! defined (CLIENT_SUPPORT) && ! defined (DEBUG)
    if (newroot->method != local_method)
    {
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set for a remote access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
    }
#endif

#if ! defined (SERVER_SUPPORT) && ! defined (DEBUG)
    if (newroot->method == fork_method)
    {
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set to use the :fork: access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
     }
#endif

    if (newroot->username && ! newroot->hostname)
    {
	error (0, 0, "missing hostname in CVSROOT: \"%s\"", root_in);
	goto error_exit;
    }

    check_hostname = 0;
    no_password = 0;
    no_port = 0;
    switch (newroot->method)
    {
    case local_method:
	if (newroot->username || newroot->hostname)
	{
	    error (0, 0, "can't specify hostname and username in CVSROOT");
	    error (0, 0, "(\"%s\")", root_in);
	    error (0, 0, "when using local access method");
	    goto error_exit;
	}
	/* cvs.texinfo has always told people that CVSROOT must be an
	   absolute pathname.  Furthermore, attempts to use a relative
	   pathname produced various errors (I couldn't get it to work),
	   so there would seem to be little risk in making this a fatal
	   error.  */
	if (!isabsolute (newroot->directory))
	{
	    error (0, 0, "CVSROOT \"%s\" must be an absolute pathname",
		   newroot->directory);
	    goto error_exit;
	}
	no_port = 1;
	no_password = 1;
	break;
    case fork_method:
	/* We want :fork: to behave the same as other remote access
           methods.  Therefore, don't check to see that the repository
           name is absolute -- let the server do it.  */
	if (newroot->username || newroot->hostname)
	{
	    error (0, 0, "can't specify hostname and username in CVSROOT");
	    error (0, 0, "(\"%s\")", root_in);
	    error (0, 0, "when using fork access method");
	    goto error_exit;
	}
	if (!isabsolute (newroot->directory))
	{
	    error (0, 0, "CVSROOT \"%s\" must be an absolute pathname",
		   newroot->directory);
	    goto error_exit;
	}
	no_port = 1;
	no_password = 1;
	break;
    case kserver_method:
#ifndef HAVE_KERBEROS
	error (0, 0, "CVSROOT \"%s\"", root_in);
       	error (0, 0, "is set for a kerberos access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
#else
	check_hostname = 1;
	break;
#endif
    case gserver_method:
#ifndef HAVE_GSSAPI
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set for a GSSAPI access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
#else
	check_hostname = 1;
	break;
#endif
    case server_method:
    case ext_method:
	no_port = 1;
	no_password = 1;
	check_hostname = 1;
	break;
    case pserver_method:
	check_hostname = 1;
	break;
    }

    if (no_password && newroot->password)
    {
	error (0, 0, "CVSROOT password specification is only valid for");
	error (0, 0, "pserver connection method.");
	goto error_exit;
    }

    if (check_hostname && !newroot->hostname)
    {
	error (0, 0, "didn't specify hostname in CVSROOT: %s", root_in);
	goto error_exit;
    }

    if (no_port && newroot->port)
	{
	    error (0, 0, "CVSROOT port specification is only valid for gserver, kserver,");
	    error (0, 0, "and pserver connection methods.");
	    goto error_exit;
	}

    if (*newroot->directory == '\0')
    {
	error (0, 0, "missing directory in CVSROOT: %s", root_in);
	goto error_exit;
    }
    
    /* Hooray!  We finally parsed it! */
    return newroot;

error_exit:
    free_cvsroot_t (newroot);
    return NULL;
}



#ifdef AUTH_CLIENT_SUPPORT
/* Use root->username, root->hostname, root->port, and root->directory
 * to create a normalized CVSROOT fit for the .cvspass file
 *
 * username defaults to the result of getcaller()
 * port defaults to the result of get_cvs_port_number()
 *
 * FIXME - we could cache the canonicalized version of a root inside the
 * cvsroot_t, but we'd have to un'const the input here and stop expecting the
 * caller to be responsible for our return value
 */
char *
normalize_cvsroot (root)
    const cvsroot_t *root;
{
    char *cvsroot_canonical;
    char *p, *hostname, *username;
    char port_s[64];

    /* get the appropriate port string */
    sprintf (port_s, "%d", get_cvs_port_number (root));

    /* use a lower case hostname since we know hostnames are case insensitive */
    /* Some logic says we should be tacking our domain name on too if it isn't
     * there already, but for now this works.  Reverse->Forward lookups are
     * almost certainly too much since that would make CVS immune to some of
     * the DNS trickery that makes life easier for sysadmins when they want to
     * move a repository or the like
     */
    p = hostname = xstrdup(root->hostname);
    while (*p)
    {
	*p = tolower(*p);
	p++;
    }

    /* get the username string */
    username = root->username ? root->username : getcaller();
    cvsroot_canonical = xmalloc ( strlen(username)
				+ strlen(hostname) + strlen(port_s)
				+ strlen(root->directory) + 12);
    sprintf (cvsroot_canonical, ":pserver:%s@@%s:%s%s",
	    username, hostname, port_s, root->directory);

    free (hostname);
    return cvsroot_canonical;
}
#endif /* AUTH_CLIENT_SUPPORT */



/* allocate and return a cvsroot_t structure set up as if we're using the local
 * repository DIR.  */
cvsroot_t *
local_cvsroot (dir)
    char *dir;
{
    cvsroot_t *newroot = new_cvsroot_t();

    newroot->original = xstrdup(dir);
    newroot->method = local_method;
    newroot->directory = xstrdup(dir);

    return newroot;
}



#ifdef DEBUG
/* This is for testing the parsing function.  Use

     gcc -I. -I.. -I../lib -DDEBUG root.c -o root

   to compile.  */

#include <stdio.h>

char *program_name = "testing";
char *command_name = "parse_cvsroot";		/* XXX is this used??? */

/* Toy versions of various functions when debugging under unix.  Yes,
   these make various bad assumptions, but they're pretty easy to
   debug when something goes wrong.  */

void
error_exit PROTO ((void))
{
    exit (1);
}

int
isabsolute (dir)
    const char *dir;
{
    return (dir && (*dir == '/'));
}

void
main (argc, argv)
    int argc;
    char *argv[];
{
    program_name = argv[0];

    if (argc != 2)
    {
	fprintf (stderr, "Usage: %s <CVSROOT>\n", program_name);
	exit (2);
    }
  
    if ((current_parsed_root = parse_cvsroot (argv[1])) == NULL)
    {
	fprintf (stderr, "%s: Parsing failed.\n", program_name);
	exit (1);
    }
    printf ("CVSroot: %s\n", argv[1]);
    printf ("current_parsed_root->method: %s\n", method_names[current_parsed_root->method]);
    printf ("current_parsed_root->username: %s\n",
	    current_parsed_root->username ? current_parsed_root->username : "NULL");
    printf ("current_parsed_root->hostname: %s\n",
	    current_parsed_root->hostname ? current_parsed_root->hostname : "NULL");
    printf ("current_parsed_root->directory: %s\n", current_parsed_root->directory);

   exit (0);
   /* NOTREACHED */
}
#endif
@


1.5
log
@Merge local changes; work in progress
@
text
@d75 1
a75 1
    if (getline (&root, &root_allocated, fpin) < 0)
@


1.4
log
@permit [] hostname formats in CVSroot, for v6
@
text
@d15 1
a15 1
/* Printable names for things in the CVSroot_method enum variable.
d19 1
a19 1
    "local", "server (ssh)", "pserver", "kserver", "gserver", "ext", "fork"
d268 2
d276 2
d287 1
a287 1
 * Returns zero on success, non-zero on failure. */
d289 1
a289 6
char *CVSroot_original = NULL;	/* the CVSroot that was passed in */
int client_active;		/* nonzero if we are doing remote access */
CVSmethod CVSroot_method;	/* one of the enum values defined in cvs.h */
char *CVSroot_username;		/* the username or NULL if method == local */
char *CVSroot_hostname;		/* the hostname or NULL if method == local */
char *CVSroot_directory;	/* the directory name */
d291 38
a328 3
int
parse_cvsroot (CVSroot)
    char *CVSroot;
d330 16
a345 19
    static int cvsroot_parsed = 0;
    char *cvsroot_copy, *cvsroot_save, *p;
    int check_hostname;

    /* Don't go through the trouble twice. */
    if (cvsroot_parsed)
    {
	error (0, 0, "WARNING (parse_cvsroot): someone called me twice!\n");
	return 0;
    }

    if (CVSroot_original != NULL)
	free (CVSroot_original);
    if (CVSroot_directory != NULL)
	free (CVSroot_directory);
    if (CVSroot_username != NULL)
	free (CVSroot_username);
    if (CVSroot_hostname != NULL)
	free (CVSroot_hostname);
d347 28
a374 2
    CVSroot_original = xstrdup (CVSroot);
    cvsroot_save = cvsroot_copy = xstrdup (CVSroot);
d381 2
a382 1
	 * "cvs -d :pserver:user@@host:/path",
a383 1
	 * "cvs -d :kserver:user@@host:/path", or
d391 1
a391 1
	    error (0, 0, "bad CVSroot: %s", CVSroot);
d393 1
a393 1
	    return 1;
d401 1
a401 1
	    CVSroot_method = local_method;
d403 1
a403 1
	    CVSroot_method = pserver_method;
d405 1
a405 1
	    CVSroot_method = kserver_method;
d407 1
a407 1
	    CVSroot_method = gserver_method;
d409 1
a409 1
	    CVSroot_method = server_method;
d411 1
a411 1
	    CVSroot_method = ext_method;
d413 1
a413 1
	    CVSroot_method = fork_method;
d416 1
a416 1
	    error (0, 0, "unknown method in CVSroot: %s", CVSroot);
d418 1
a418 1
	    return 1;
d427 2
a428 2
	CVSroot_method = ((strchr (cvsroot_copy, ':'))
#ifdef RSH_NOT_TRANSPARENT
d430 1
a430 1
#else
d432 1
a432 1
#endif
d436 3
a438 3
    client_active = (CVSroot_method != local_method);

    /* Check for username/hostname if we're not LOCAL_METHOD. */
a439 2
    CVSroot_username = NULL;
    CVSroot_hostname = NULL;
d441 2
a442 2
    if ((CVSroot_method != local_method)
	&& (CVSroot_method != fork_method))
d444 16
a459 1
	/* Check to see if there is a username in the string. */
d461 1
d465 19
a483 1
	    CVSroot_username = xstrdup (cvsroot_copy);
a484 2
	    if (*CVSroot_username == '\0')
		CVSroot_username = NULL;
d487 1
d494 1
a494 1
			CVSroot_hostname = xstrdup (cvsroot_copy+1);
d497 1
a497 1
				cvsroot_copy = p+1;
d500 5
a504 1
	else if ((p = strchr (cvsroot_copy, ':')) != NULL)
d506 31
a536 6
	    *p = '\0';
	    CVSroot_hostname = xstrdup (cvsroot_copy);
	    cvsroot_copy = ++p;
      
	    if (*CVSroot_hostname == '\0')
		CVSroot_hostname = NULL;
d538 13
d553 2
a554 1
    CVSroot_directory = xstrdup(cvsroot_copy);
d557 4
d562 1
a562 1
    if (CVSroot_method != local_method)
d564 4
a567 4
	error (0, 0, "Your CVSROOT is set for a remote access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
a569 2
  
    /* Do various sanity checks. */
d571 11
a581 1
    if (CVSroot_username && ! CVSroot_hostname)
d583 2
a584 2
	error (0, 0, "missing hostname in CVSROOT: %s", CVSroot);
	return 1;
d588 3
a590 1
    switch (CVSroot_method)
d593 1
a593 1
	if (CVSroot_username || CVSroot_hostname)
d596 1
d598 1
a598 2
	    error (0, 0, "(%s)", CVSroot);
	    return 1;
d605 8
a612 3
	if (!isabsolute (CVSroot_directory))
	    error (1, 0, "CVSROOT %s must be an absolute pathname",
		   CVSroot_directory);
d618 1
a618 1
	if (CVSroot_username || CVSroot_hostname)
d621 1
d623 7
a629 2
	    error (0, 0, "(%s)", CVSroot);
	    return 1;
d631 2
d636 4
a639 4
	error (0, 0, "Your CVSROOT is set for a kerberos access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
d646 4
a649 4
	error (0, 0, "Your CVSROOT is set for a GSSAPI access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
d656 4
d665 8
a672 1
    if (check_hostname)
d674 5
a678 1
	if (! CVSroot_hostname)
d680 3
a682 2
	    error (0, 0, "didn't specify hostname in CVSROOT: %s", CVSroot);
	    return 1;
a683 1
    }
d685 1
a685 1
    if (*CVSroot_directory == '\0')
d687 2
a688 2
	error (0, 0, "missing directory in CVSROOT: %s", CVSroot);
	return 1;
d692 55
a746 1
    return 0;
d748 1
a750 2
/* Set up the global CVSroot* variables as if we're using the local
   repository DIR.  */
d752 4
a755 2
void
set_local_cvsroot (dir)
d758 7
a764 14
    if (CVSroot_original != NULL)
	free (CVSroot_original);
    CVSroot_original = xstrdup(dir);
    CVSroot_method = local_method;
    if (CVSroot_directory != NULL)
	free (CVSroot_directory);
    CVSroot_directory = xstrdup(dir);
    if (CVSroot_username != NULL)
	free (CVSroot_username);
    CVSroot_username = NULL;
    if (CVSroot_hostname != NULL)
	free (CVSroot_hostname);
    CVSroot_hostname = NULL;
    client_active = 0;
d768 1
a777 1
char *CVSroot;
a790 7
char *
xstrdup (str)
     const char *str;
{
    return strdup (str);
}

d811 1
a811 1
    if (parse_cvsroot (argv[1]))
d817 6
a822 6
    printf ("CVSroot_method: %s\n", method_names[CVSroot_method]);
    printf ("CVSroot_username: %s\n",
	    CVSroot_username ? CVSroot_username : "NULL");
    printf ("CVSroot_hostname: %s\n",
	    CVSroot_hostname ? CVSroot_hostname : "NULL");
    printf ("CVSroot_directory: %s\n", CVSroot_directory);
@


1.3
log
@Integrate local changes
@
text
@d400 13
a412 1
	if ((p = strchr (cvsroot_copy, ':')) != NULL)
@


1.2
log
@rsh was changed to ssh. reflect this in error messages.  ok deraadt@@
@
text
@d177 1
a177 1
static unsigned int root_allow_count;
d179 1
a179 1
static unsigned int root_allow_size;
d236 1
a236 2
	free (root_allow_vector);
    root_allow_count = 0;
d244 1
a244 1
    unsigned int i;
d297 1
a297 1
    char *cvsroot_copy, *p;
d307 9
d317 1
a317 1
    cvsroot_copy = xstrdup (CVSroot);
d319 1
a319 1
    if ((*cvsroot_copy == ':'))
d335 1
d360 1
d391 1
a391 1
	if ((p = strchr (cvsroot_copy, '@@')))
a392 1
	    CVSroot_username = cvsroot_copy;
d394 1
d400 1
a400 1
	if ((p = strchr (cvsroot_copy, ':')))
a401 1
	    CVSroot_hostname = cvsroot_copy;
d403 1
d411 2
a412 1
    CVSroot_directory = cvsroot_copy;
a435 1
    case fork_method:
d439 1
a439 2
	    error (0, 0, "when using %s access method",
		   CVSroot_method == local_method ? "local" : "fork");
d452 12
d512 1
a512 3
   repository DIR.  DIR must point to storage which will last for the
   rest of the CVS invocation (for example, the caller might malloc it
   and never free it, or free it just before exiting CVS).  */
d518 3
a520 1
    CVSroot_original = dir;
d522 5
a526 1
    CVSroot_directory = CVSroot_original;
d528 2
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 * specified in the README file that comes with the CVS 1.4 kit.
a9 2
 * If this looks like of modified clone of Name_Repository() in
 * repos.c, it is... 
d13 1
d15 8
a22 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)root.c,v 1.2 1994/09/15 05:32:17 zoo Exp";
USE(rcsid);
#endif
d25 3
a27 3
Name_Root(dir, update_dir)
     char *dir;
     char *update_dir;
d31 4
a34 3
    char root[PATH_MAX];
    char tmp[PATH_MAX];
    char cvsadm[PATH_MAX];
d44 1
d46 1
d51 2
a52 2
	(void) strcpy (cvsadm, CVSADM);
	(void) strcpy (tmp, CVSADM_ROOT);
d59 1
a59 1
     * It is possiible that not all repositories will have a CVS/Root
d62 1
a62 2
     * order to continue.
     */
d65 2
a66 7
	if (CVSroot == NULL)
	{
	    error (0, 0, "in directory %s:", xupdate_dir);
	    error (0, 0, "must set the CVSROOT environment variable");
	    error (0, 0, "or specify the '-d' option to %s.", program_name);
	}
	return (NULL);
d75 1
a75 1
    if (fgets (root, PATH_MAX, fpin) == NULL)
d77 2
d82 2
a83 1
	return (NULL);
d91 1
a91 1
     * absolute pathname
d94 1
d96 1
a96 5
    /* It must specify a server via remote CVS or be an absolute pathname.  */
    if ((strchr (root, ':') == NULL)
    	&& ! isabsolute (root))
#else
    if (root[0] != '/')
d98 1
d104 2
a105 1
	return (NULL);
d110 1
a110 1
#else
d112 1
a112 1
#endif
d118 2
a119 1
	return (NULL);
d123 1
a123 1
    strip_path (root);
d125 5
a133 27
 * Returns non-zero if the two directories have the same stat values
 * which indicates that they are really the same directories.
 */
int
same_directories (dir1, dir2)
     char *dir1;
     char *dir2;
{
    struct stat sb1;
    struct stat sb2;
    int ret;

    if (stat (dir1, &sb1) < 0)
        return (0);
    if (stat (dir2, &sb2) < 0)
        return (0);
    
    ret = 0;
    if ( (memcmp( &sb1.st_dev, &sb2.st_dev, sizeof(dev_t) ) == 0) &&
	 (memcmp( &sb1.st_ino, &sb2.st_ino, sizeof(ino_t) ) == 0))
        ret = 1;

    return (ret);
}


/*
d140 2
a141 2
     char *dir;
     char *rootdir;
d144 4
a147 1
    char tmp[PATH_MAX];
d154 2
d157 1
d159 2
a160 1
	    (void) strcpy (tmp, CVSADM_ROOT);
d166 1
d169 406
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d53 1
a53 1
     * It is possible that not all repositories will have a CVS/Root
d95 1
a95 1
#else /* ! CLIENT_SUPPORT */
d97 1
a97 1
#endif /* CLIENT_SUPPORT */
d108 1
a108 1
#else /* ! CLIENT_SUPPORT */
d110 1
a110 1
#endif /* CLIENT_SUPPORT */
a163 3

    if (noexec)
	return;
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d16 5
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@a15 9
/* Printable names for things in the CVSroot_method enum variable.
   Watch out if the enum is changed in cvs.h! */

char *method_names[] = {
  "local", "server (rsh)", "pserver", "kserver", "ext"
};

#ifndef DEBUG

d51 2
a52 1
     * order to continue.  */
d54 9
a62 1
        return (NULL);
d133 1
a133 1
    if ( CVS_STAT (dir1, &sb1) < 0)
d135 1
a135 1
    if ( CVS_STAT (dir2, &sb2) < 0)
a177 238

#endif /* ! DEBUG */


/* Parse a CVSROOT variable into its constituent parts -- method,
 * username, hostname, directory.  The prototypical CVSROOT variable
 * looks like:
 *
 * :method:user@@host:path
 *
 * Some methods may omit fields; local, for example, doesn't need user
 * and host.
 *
 * Returns zero on success, non-zero on failure. */

char *CVSroot_original = NULL;	/* the CVSroot that was passed in */
int client_active;		/* nonzero if we are doing remote access */
CVSmethod CVSroot_method;	/* one of the enum values defined in cvs.h */
char *CVSroot_username;		/* the username or NULL if method == local */
char *CVSroot_hostname;		/* the hostname or NULL if method == local */
char *CVSroot_directory;	/* the directory name */

int
parse_cvsroot (CVSroot)
    char *CVSroot;
{
    static int cvsroot_parsed = 0;
    char *cvsroot_copy, *p;

    /* Don't go through the trouble twice. */
    if (cvsroot_parsed)
    {
	error (0, 0, "WARNING (parse_cvsroot): someone called me twice!\n");
	return 0;
    }

    CVSroot_original = xstrdup (CVSroot);
    cvsroot_copy = xstrdup (CVSroot);

    if ((*cvsroot_copy == ':'))
    {
	char *method = ++cvsroot_copy;

	/* Access method specified, as in
	 * "cvs -d :pserver:user@@host:/path",
	 * "cvs -d :local:e:\path", or
	 * "cvs -d :kserver:user@@host:/path".
	 * We need to get past that part of CVSroot before parsing the
	 * rest of it.
	 */

	if (! (p = strchr (method, ':')))
	{
	    error (0, 0, "bad CVSroot: %s", CVSroot);
	    return 1;
	}
	*p = '\0';
	cvsroot_copy = ++p;

	/* Now we have an access method -- see if it's valid. */

	if (strcmp (method, "local") == 0)
	    CVSroot_method = local_method;
	else if (strcmp (method, "pserver") == 0)
	    CVSroot_method = pserver_method;
	else if (strcmp (method, "kserver") == 0)
	    CVSroot_method = kserver_method;
	else if (strcmp (method, "server") == 0)
	    CVSroot_method = server_method;
	else if (strcmp (method, "ext") == 0)
	    CVSroot_method = ext_method;
	else
	{
	    error (0, 0, "unknown method in CVSroot: %s", CVSroot);
	    return 1;
	}
    }
    else
    {
	/* If the method isn't specified, assume
	   SERVER_METHOD/EXT_METHOD if the string contains a colon or
	   LOCAL_METHOD otherwise.  */

	CVSroot_method = ((strchr (cvsroot_copy, ':'))
#ifdef RSH_NOT_TRANSPARENT
			  ? server_method
#else
			  ? ext_method
#endif
			  : local_method);
    }

    client_active = (CVSroot_method != local_method);

    /* Check for username/hostname if we're not LOCAL_METHOD. */

    CVSroot_username = NULL;
    CVSroot_hostname = NULL;

    if (CVSroot_method != local_method)
    {
	/* Check to see if there is a username in the string. */

	if ((p = strchr (cvsroot_copy, '@@')))
	{
	    CVSroot_username = cvsroot_copy;
	    *p = '\0';
	    cvsroot_copy = ++p;
	    if (*CVSroot_username == '\0')
		CVSroot_username = NULL;
	}

	if ((p = strchr (cvsroot_copy, ':')))
	{
	    CVSroot_hostname = cvsroot_copy;
	    *p = '\0';
	    cvsroot_copy = ++p;
      
	    if (*CVSroot_hostname == '\0')
		CVSroot_hostname = NULL;
	}
    }

    CVSroot_directory = cvsroot_copy;

#if ! defined (CLIENT_SUPPORT) && ! defined (DEBUG)
    if (CVSroot_method != local_method)
    {
	error (0, 0, "Your CVSROOT is set for a remote access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
    }
#endif
  
    /* Do various sanity checks. */

    if (CVSroot_username && ! CVSroot_hostname)
    {
	error (0, 0, "missing hostname in CVSROOT: %s", CVSroot);
	return 1;
    }

    switch (CVSroot_method)
    {
    case local_method:
	if (CVSroot_username || CVSroot_hostname)
	{
	    error (0, 0, "can't specify hostname and username in CVSROOT");
	    error (0, 0, "when using local access method");
	    error (0, 0, "(%s)", CVSroot);
	    return 1;
	}
	break;
    case kserver_method:
#ifndef HAVE_KERBEROS
	error (0, 0, "Your CVSROOT is set for a kerberos access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
#endif
    case server_method:
    case ext_method:
    case pserver_method:
	if (! CVSroot_hostname)
	{
	    error (0, 0, "didn't specify hostname in CVSROOT: %s", CVSroot);
	    return 1;
	}
	break;
    }

    if (*CVSroot_directory == '\0')
    {
	error (0, 0, "missing directory in CVSROOT: %s", CVSroot);
	return 1;
    }
    
    /* Hooray!  We finally parsed it! */
    return 0;
}


/* Set up the global CVSroot* variables as if we're using the local
   repository DIR. */

void
set_local_cvsroot (dir)
    char *dir;
{
    CVSroot_original = xstrdup (dir);
    CVSroot_method = local_method;
    CVSroot_directory = CVSroot_original;
    CVSroot_username = NULL;
    CVSroot_hostname = NULL;
    client_active = 0;
}


#ifdef DEBUG
/* This is for testing the parsing function. */

#include <stdio.h>

char *CVSroot;
char *program_name = "testing";
char *command_name = "parse_cvsroot";		/* XXX is this used??? */

void
main (argc, argv)
    int argc;
    char *argv[];
{
    program_name = argv[0];

    if (argc != 2)
    {
	fprintf (stderr, "Usage: %s <CVSROOT>\n", program_name);
	exit (2);
    }
  
    if (parse_cvsroot (argv[1]))
    {
	fprintf (stderr, "%s: Parsing failed.", program_name);
	exit (1);
    }
    printf ("CVSroot: %s\n", argv[1]);
    printf ("CVSroot_method: %s\n", method_names[CVSroot_method]);
    printf ("CVSroot_username: %s\n",
	    CVSroot_username ? CVSroot_username : "NULL");
    printf ("CVSroot_hostname: %s\n",
	    CVSroot_hostname ? CVSroot_hostname : "NULL");
    printf ("CVSroot_directory: %s\n", CVSroot_directory);

   exit (0);
   /* NOTREACHED */
}
#endif
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d83 1
a83 1
     * absolute pathname or specify a remote server.
a85 1
    if (
d87 6
a92 3
	(strchr (root, ':') == NULL) &&
#endif
    	! isabsolute (root))
d115 1
a115 1
    strip_trailing_slashes (root);
a199 20
#ifdef AUTH_SERVER_SUPPORT
/* Die if CVSroot_directory and Pserver_Repos don't match. */
static void
check_root_consistent ()
{
    /* FIXME: Should be using a deferred error, as the rest of
       serve_root does.  As it is now the call to error could conceivably
       cause deadlock, as noted in server_cleanup.  Best solution would
       presumably be to write some code so that error() automatically
       defers the error in those cases where that is needed.  */

    if ((Pserver_Repos != NULL) && (CVSroot_directory != NULL))
	if (strcmp (Pserver_Repos, CVSroot_directory) != 0)
	    error (1, 0, "repository mismatch: \"%s\" vs \"%s\"",
		   Pserver_Repos, CVSroot_directory);
}

#endif /* AUTH_SERVER_SUPPORT */


a301 3
#ifdef AUTH_SERVER_SUPPORT
    check_root_consistent ();
#endif /* AUTH_SERVER_SUPPORT */
a370 3
#ifdef AUTH_SERVER_SUPPORT
    check_root_consistent ();
#endif /* AUTH_SERVER_SUPPORT */
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a14 1
#include "getline.h"
d32 3
a34 4
    char *root = NULL;
    size_t root_allocated = 0;
    char *tmp;
    char *cvsadm;
a43 1
	cvsadm = xmalloc (strlen (dir) + sizeof (CVSADM) + 10);
a44 1
	tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
d49 2
a50 2
	cvsadm = xstrdup (CVSADM);
	tmp = xstrdup (CVSADM_ROOT);
d62 1
a62 4
    {
	ret = NULL;
	goto out;
    }
d70 1
a70 1
    if (getline (&root, &root_allocated, fpin) < 0)
a71 2
	/* FIXME: should be checking for end of file separately; errno
	   is not set in that case.  */
d75 1
a75 2
	ret = NULL;
	goto out;
d96 1
a96 2
	ret = NULL;
	goto out;
d109 1
a109 2
	ret = NULL;
	goto out;
a114 5
 out:
    free (cvsadm);
    free (tmp);
    if (root != NULL)
	free (root);
d156 1
a156 1
    char *tmp;
a165 2
	{
	    tmp = xmalloc (strlen (dir) + sizeof (CVSADM_ROOT) + 10);
a166 1
	}
d168 1
a168 2
	    tmp = xstrdup (CVSADM_ROOT);

a173 1
	free (tmp);
a351 8
	/* cvs.texinfo has always told people that CVSROOT must be an
	   absolute pathname.  Furthermore, attempts to use a relative
	   pathname produced various errors (I couldn't get it to work),
	   so there would seem to be little risk in making this a fatal
	   error.  */
	if (!isabsolute (CVSroot_directory))
	    error (1, 0, "CVSROOT %s must be an absolute pathname",
		   CVSroot_directory);
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d230 1
a230 5
    /* FIXME?  Possible that the wording should be more clear (e.g.
          Root says "%s" but pserver protocol says "%s"
       or something which would aid people who are writing implementations
       of the client side of the CVS protocol.  I don't see any security
       problem with revealing that information.  */
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@a201 80
/* The root_allow_* stuff maintains a list of legal CVSROOT
   directories.  Then we can check against them when a remote user
   hands us a CVSROOT directory.  */

static unsigned int root_allow_count;
static char **root_allow_vector;
static unsigned int root_allow_size;

void
root_allow_add (arg)
    char *arg;
{
    char *p;

    if (root_allow_size <= root_allow_count)
    {
	if (root_allow_size == 0)
	{
	    root_allow_size = 1;
	    root_allow_vector =
		(char **) malloc (root_allow_size * sizeof (char *));
	}
	else
	{
	    root_allow_size *= 2;
	    root_allow_vector =
		(char **) realloc (root_allow_vector,
				   root_allow_size * sizeof (char *));
	}

	if (root_allow_vector == NULL)
	{
	no_memory:
	    /* Strictly speaking, we're not supposed to output anything
	       now.  But we're about to exit(), give it a try.  */
	    printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket
	       subsystems on NT and OS2 or dealing with windows
	       and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
    }
    p = malloc (strlen (arg) + 1);
    if (p == NULL)
	goto no_memory;
    strcpy (p, arg);
    root_allow_vector[root_allow_count++] = p;
}

void
root_allow_free ()
{
    if (root_allow_vector != NULL)
	free (root_allow_vector);
    root_allow_count = 0;
    root_allow_size = 0;
}

int
root_allow_ok (arg)
    char *arg;
{
    unsigned int i;
    for (i = 0; i < root_allow_count; ++i)
	if (strcmp (root_allow_vector[i], arg) == 0)
	    return 1;
    return 0;
}


@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d5 1
a5 1
 * specified in the README file that comes with the CVS source distribution.
d21 1
a21 1
    "local", "server (rsh)", "pserver", "kserver", "gserver", "ext"
d27 3
a29 3
Name_Root (dir, update_dir)
    char *dir;
    char *update_dir;
d136 27
d169 2
a170 2
    char *dir;
    char *rootdir;
a274 17

    if (root_allow_count == 0)
    {
	/* Probably someone upgraded from CVS before 1.9.10 to 1.9.10
	   or later without reading the documentation about
	   --allow-root.  Printing an error here doesn't disclose any
	   particularly useful information to an attacker because a
	   CVS server configured in this way won't let *anyone* in.  */

	/* Note that we are called from a context where we can spit
	   back "error" rather than waiting for the next request which
	   expects responses.  */
	printf ("\
error 0 Server configuration missing --allow-root in inetd.conf\n");
	error_exit ();
    }

a329 1
    int check_hostname;
a368 2
	else if (strcmp (method, "gserver") == 0)
	    CVSroot_method = gserver_method;
a447 1
    check_hostname = 0;
a473 11
	check_hostname = 1;
	break;
    case gserver_method:
#ifndef HAVE_GSSAPI
	error (0, 0, "Your CVSROOT is set for a GSSAPI access method");
	error (0, 0, "but your CVS executable doesn't support it");
	error (0, 0, "(%s)", CVSroot);
	return 1;
#endif
	check_hostname = 1;
	break;
a476 6
	check_hostname = 1;
	break;
    }

    if (check_hostname)
    {
d482 1
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d21 1
a21 1
    "local", "server (rsh)", "pserver", "kserver", "gserver", "ext", "fork"
a270 5
/* This global variable holds the global -d option.  It is NULL if -d
   was not used, which means that we must get the CVSroot information
   from the CVSROOT environment variable or from a CVS/Root file.  */

char *CVSroot_cmdline;
d290 24
d338 2
a339 3
	 * "cvs -d :local:e:\path",
	 * "cvs -d :kserver:user@@host:/path", or
	 * "cvs -d :fork:/path".
a365 2
	else if (strcmp (method, "fork") == 0)
	    CVSroot_method = fork_method;
d394 1
a394 2
    if ((CVSroot_method != local_method)
	&& (CVSroot_method != fork_method))
d419 3
a444 1
    case fork_method:
d448 1
a448 2
	    error (0, 0, "when using %s access method",
		   CVSroot_method == local_method ? "local" : "fork");
d467 1
a467 1
#else
a469 1
#endif
d476 1
a476 1
#else
a478 1
#endif
d507 1
a507 3
   repository DIR.  DIR must point to storage which will last for the
   rest of the CVS invocation (for example, the caller might malloc it
   and never free it, or free it just before exiting CVS).  */
d513 1
a513 1
    CVSroot_original = dir;
d516 3
d526 1
a526 5
/* This is for testing the parsing function.  Use

     gcc -I. -I.. -I../lib -DDEBUG root.c -o root

   to compile.  */
a533 24
/* Toy versions of various functions when debugging under unix.  Yes,
   these make various bad assumptions, but they're pretty easy to
   debug when something goes wrong.  */

void
error_exit PROTO ((void))
{
    exit (1);
}

char *
xstrdup (str)
     const char *str;
{
    return strdup (str);
}

int
isabsolute (dir)
    const char *dir;
{
    return (dir && (*dir == '/'));
}

d549 1
a549 1
	fprintf (stderr, "%s: Parsing failed.\n", program_name);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d10 2
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d177 1
a177 1
static int root_allow_count;
d179 1
a179 1
static int root_allow_size;
d236 2
a237 1
	free_names (&root_allow_count, root_allow_vector);
d245 1
a245 1
    int i;
d298 1
a298 1
    char *cvsroot_copy, *cvsroot_save, *p;
a307 9
    if (CVSroot_original != NULL)
	free (CVSroot_original);
    if (CVSroot_directory != NULL)
	free (CVSroot_directory);
    if (CVSroot_username != NULL)
	free (CVSroot_username);
    if (CVSroot_hostname != NULL)
	free (CVSroot_hostname);

d309 1
a309 1
    cvsroot_save = cvsroot_copy = xstrdup (CVSroot);
d311 1
a311 1
    if (*cvsroot_copy == ':')
a326 1
	    free (cvsroot_save);
a350 1
	    free (cvsroot_save);
d381 1
a381 1
	if ((p = strchr (cvsroot_copy, '@@')) != NULL)
d383 1
a384 1
	    CVSroot_username = xstrdup (cvsroot_copy);
d390 1
a390 1
	if ((p = strchr (cvsroot_copy, ':')) != NULL)
d392 1
a393 1
	    CVSroot_hostname = xstrdup (cvsroot_copy);
d401 1
a401 2
    CVSroot_directory = xstrdup(cvsroot_copy);
    free (cvsroot_save);
d425 1
d429 2
a430 1
	    error (0, 0, "when using local access method");
a442 12
    case fork_method:
	/* We want :fork: to behave the same as other remote access
           methods.  Therefore, don't check to see that the repository
           name is absolute -- let the server do it.  */
	if (CVSroot_username || CVSroot_hostname)
	{
	    error (0, 0, "can't specify hostname and username in CVSROOT");
	    error (0, 0, "when using fork access method");
	    error (0, 0, "(%s)", CVSroot);
	    return 1;
	}
	break;
d491 3
a493 1
   repository DIR.  */
d499 1
a499 3
    if (CVSroot_original != NULL)
	free (CVSroot_original);
    CVSroot_original = xstrdup(dir);
d501 1
a501 5
    if (CVSroot_directory != NULL)
	free (CVSroot_directory);
    CVSroot_directory = xstrdup(dir);
    if (CVSroot_username != NULL)
	free (CVSroot_username);
a502 2
    if (CVSroot_hostname != NULL)
	free (CVSroot_hostname);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d15 1
a15 1
/* Printable names for things in the current_parsed_root->method enum variable.
d19 1
a19 1
    "undefined", "local", "server (rsh)", "pserver", "kserver", "gserver", "ext", "fork"
a267 2


a273 2


d283 1
a283 1
 * Returns pointer to new cvsroot_t on success, NULL on failure. */
d285 6
a290 1
cvsroot_t *current_parsed_root = NULL;
d292 3
a294 12


/* allocate and initialize a cvsroot_t
 *
 * We must initialize the strings to NULL so we know later what we should
 * free
 *
 * Some of the other zeroes remain meaningful as, "never set, use default",
 * or the like
 */
static cvsroot_t *
new_cvsroot_t ()
d296 19
a314 43
    cvsroot_t *newroot;

    /* gotta store it somewhere */
    newroot = xmalloc(sizeof(cvsroot_t));

    newroot->original = NULL;
    newroot->method = null_method;
    newroot->username = NULL;
    newroot->password = NULL;
    newroot->hostname = NULL;
    newroot->port = 0;
    newroot->directory = NULL;
#ifdef CLIENT_SUPPORT
    newroot->isremote = 0;
#endif /* CLIENT_SUPPORT */

    return newroot;
}



/* Dispose of a cvsroot_t and its component parts */
void
free_cvsroot_t (root)
    cvsroot_t *root;
{
    if (root->original != NULL)
	free (root->original);
    if (root->username != NULL)
	free (root->username);
    if (root->password != NULL)
    {
	/* I like to be paranoid */
	memset (root->password, 0, strlen (root->password));
	free (root->password);
    }
    if (root->hostname != NULL)
	free (root->hostname);
    if (root->directory != NULL)
	free (root->directory);
    free (root);
}

d316 2
a317 26

/*
 * parse a CVSROOT string to allocate and return a new cvsroot_t structure
 */
cvsroot_t *
parse_cvsroot (root_in)
    char *root_in;
{
    cvsroot_t *newroot;			/* the new root to be returned */
    char *cvsroot_save;			/* what we allocated so we can dispose
					 * it when finished */
    char *firstslash;			/* save where the path spec starts
					 * while we parse
					 * [[user][:password]@@]host[:[port]]
					 */
    char *cvsroot_copy, *p, *q;		/* temporary pointers for parsing */
    int check_hostname, no_port, no_password;

    /* allocate some space */
    newroot = new_cvsroot_t();

    /* save the original string */
    newroot->original = xstrdup (root_in);

    /* and another copy we can munge while parsing */
    cvsroot_save = cvsroot_copy = xstrdup (root_in);
d324 1
a324 2
	 * "cvs -d :(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path",
	 * "cvs -d [:(ext|server):][[user]@@]host[:]/path",
d326 1
d334 1
a334 1
	    error (0, 0, "bad CVSroot: %s", root_in);
d336 1
a336 1
	    goto error_exit;
d344 1
a344 1
	    newroot->method = local_method;
d346 1
a346 1
	    newroot->method = pserver_method;
d348 1
a348 1
	    newroot->method = kserver_method;
d350 1
a350 1
	    newroot->method = gserver_method;
d352 1
a352 1
	    newroot->method = server_method;
d354 1
a354 1
	    newroot->method = ext_method;
d356 1
a356 1
	    newroot->method = fork_method;
d359 1
a359 1
	    error (0, 0, "unknown method in CVSroot: %s", root_in);
d361 1
a361 1
	    goto error_exit;
d370 2
a371 2
	newroot->method = ((*cvsroot_copy != '/' && strchr (cvsroot_copy, '/'))
/*#ifdef RSH_NOT_TRANSPARENT
d373 1
a373 1
#else*/
d375 1
a375 1
/*#endif*/
d379 3
a381 3
#ifdef CLIENT_SUPPORT
    newroot->isremote = (newroot->method != local_method);
#endif /* CLIENT_SUPPORT */
d383 2
d386 2
a387 2
    if ((newroot->method != local_method)
	&& (newroot->method != fork_method))
d389 1
a389 16
	/* split the string into [[user][:password]@@]host[:[port]] & /path
	 *
	 * this will allow some characters such as '@@' & ':' to remain unquoted
	 * in the path portion of the spec
	 */
	if ((p = strchr (cvsroot_copy, '/')) == NULL)
	{
	    error (0, 0, "CVSROOT (\"%s\")", root_in);
	    error (0, 0, "requires a path spec");
	    error (0, 0, ":(gserver|kserver|pserver):[[user][:password]@@]host[:[port]]/path");
	    error (0, 0, "[:(ext|server):][[user]@@]host[:]/path");
	    free (cvsroot_save);
	    goto error_exit;
	}
	firstslash = p;		/* == NULL if '/' not in string */
	*p = '\0';
a390 1
	/* Check to see if there is a username[:password] in the string. */
d394 1
a394 19
	    /* check for a password */
	    if ((q = strchr (cvsroot_copy, ':')) != NULL)
	    {
		*q = '\0';
		newroot->password = xstrdup (++q);
		/* Don't check for *newroot->password == '\0' since
		 * a user could conceivably wish to specify a blank password
		 * (newroot->password == NULL means to use the
		 * password from .cvspass)
		 */
	    }

	    /* copy the username */
	    if (*cvsroot_copy != '\0')
		/* a blank username is impossible, so leave it NULL in that
		 * case so we know to use the default username
		 */
		newroot->username = xstrdup (cvsroot_copy);

d396 2
a399 3
	/* now deal with host[:[port]] */

	/* the port */
d402 7
a408 39
	    *p++ = '\0';
	    if (strlen(p))
	    {
		q = p;
		if (*q == '-') q++;
		while (*q)
		{
		    if (!isdigit(*q++))
		    {
			error(0, 0, "CVSROOT (\"%s\")", root_in);
			error(0, 0, "may only specify a positive, non-zero, integer port (not \"%s\").",
				p);
			error(0, 0, "perhaps you entered a relative pathname?");
			free (cvsroot_save);
			goto error_exit;
		    }
		}
		if ((newroot->port = atoi (p)) <= 0)
		{
		    error (0, 0, "CVSROOT (\"%s\")", root_in);
		    error(0, 0, "may only specify a positive, non-zero, integer port (not \"%s\").",
			    p);
		    error(0, 0, "perhaps you entered a relative pathname?");
		    free (cvsroot_save);
		    goto error_exit;
		}
	    }
	}

	/* copy host */
	if (*cvsroot_copy != '\0')
	    /* blank hostnames are invalid, but for now leave the field NULL
	     * and catch the error during the sanity checks later
	     */
	    newroot->hostname = xstrdup (cvsroot_copy);

	/* restore the '/' */
	cvsroot_copy = firstslash;
	*cvsroot_copy = '/';
d411 1
a411 2
    /* parse the path for all methods */
    newroot->directory = xstrdup(cvsroot_copy);
a413 4
    /*
     * Do various sanity checks.
     */

d415 1
a415 1
    if (newroot->method != local_method)
d417 4
a420 4
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set for a remote access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
d423 2
d426 1
a426 11
#if ! defined (SERVER_SUPPORT) && ! defined (DEBUG)
    if (newroot->method == fork_method)
    {
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set to use the :fork: access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
     }
#endif

    if (newroot->username && ! newroot->hostname)
d428 2
a429 2
	error (0, 0, "missing hostname in CVSROOT: \"%s\"", root_in);
	goto error_exit;
d433 1
a433 3
    no_password = 0;
    no_port = 0;
    switch (newroot->method)
d436 1
a436 1
	if (newroot->username || newroot->hostname)
a438 1
	    error (0, 0, "(\"%s\")", root_in);
d440 2
a441 1
	    goto error_exit;
d448 3
a450 8
	if (!isabsolute (newroot->directory))
	{
	    error (0, 0, "CVSROOT \"%s\" must be an absolute pathname",
		   newroot->directory);
	    goto error_exit;
	}
	no_port = 1;
	no_password = 1;
d456 1
a456 1
	if (newroot->username || newroot->hostname)
a458 1
	    error (0, 0, "(\"%s\")", root_in);
d460 2
a461 1
	    goto error_exit;
a462 8
	if (!isabsolute (newroot->directory))
	{
	    error (0, 0, "CVSROOT \"%s\" must be an absolute pathname",
		   newroot->directory);
	    goto error_exit;
	}
	no_port = 1;
	no_password = 1;
d466 4
a469 4
	error (0, 0, "CVSROOT \"%s\"", root_in);
       	error (0, 0, "is set for a kerberos access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
d476 4
a479 4
	error (0, 0, "CVSROOT \"%s\"", root_in);
	error (0, 0, "is set for a GSSAPI access method but your");
	error (0, 0, "CVS executable doesn't support it");
	goto error_exit;
a485 4
	no_port = 1;
	no_password = 1;
	check_hostname = 1;
	break;
d491 1
a491 8
    if (no_password && newroot->password)
    {
	error (0, 0, "CVSROOT password specification is only valid for");
	error (0, 0, "pserver connection method.");
	goto error_exit;
    }

    if (check_hostname && !newroot->hostname)
d493 1
a493 5
	error (0, 0, "didn't specify hostname in CVSROOT: %s", root_in);
	goto error_exit;
    }

    if (no_port && newroot->port)
d495 2
a496 3
	    error (0, 0, "CVSROOT port specification is only valid for gserver, kserver,");
	    error (0, 0, "and pserver connection methods.");
	    goto error_exit;
d498 1
d500 1
a500 1
    if (*newroot->directory == '\0')
d502 2
a503 2
	error (0, 0, "missing directory in CVSROOT: %s", root_in);
	goto error_exit;
d507 1
a507 5
    return newroot;

error_exit:
    free_cvsroot_t (newroot);
    return NULL;
d511 2
d514 2
a515 55
#ifdef AUTH_CLIENT_SUPPORT
/* Use root->username, root->hostname, root->port, and root->directory
 * to create a normalized CVSROOT fit for the .cvspass file
 *
 * username defaults to the result of getcaller()
 * port defaults to the result of get_cvs_port_number()
 *
 * FIXME - we could cache the canonicalized version of a root inside the
 * cvsroot_t, but we'd have to un'const the input here and stop expecting the
 * caller to be responsible for our return value
 */
char *
normalize_cvsroot (root)
    const cvsroot_t *root;
{
    char *cvsroot_canonical;
    char *p, *hostname, *username;
    char port_s[64];

    /* get the appropriate port string */
    sprintf (port_s, "%d", get_cvs_port_number (root));

    /* use a lower case hostname since we know hostnames are case insensitive */
    /* Some logic says we should be tacking our domain name on too if it isn't
     * there already, but for now this works.  Reverse->Forward lookups are
     * almost certainly too much since that would make CVS immune to some of
     * the DNS trickery that makes life easier for sysadmins when they want to
     * move a repository or the like
     */
    p = hostname = xstrdup(root->hostname);
    while (*p)
    {
	*p = tolower(*p);
	p++;
    }

    /* get the username string */
    username = root->username ? root->username : getcaller();
    cvsroot_canonical = xmalloc ( strlen(username)
				+ strlen(hostname) + strlen(port_s)
				+ strlen(root->directory) + 12);
    sprintf (cvsroot_canonical, ":pserver:%s@@%s:%s%s",
	    username, hostname, port_s, root->directory);

    free (hostname);
    return cvsroot_canonical;
}
#endif /* AUTH_CLIENT_SUPPORT */



/* allocate and return a cvsroot_t structure set up as if we're using the local
 * repository DIR.  */
cvsroot_t *
local_cvsroot (dir)
d518 14
a531 7
    cvsroot_t *newroot = new_cvsroot_t();

    newroot->original = xstrdup(dir);
    newroot->method = local_method;
    newroot->directory = xstrdup(dir);

    return newroot;
a534 1

d544 1
d558 7
d585 1
a585 1
    if ((current_parsed_root = parse_cvsroot (argv[1])) == NULL)
d591 6
a596 6
    printf ("current_parsed_root->method: %s\n", method_names[current_parsed_root->method]);
    printf ("current_parsed_root->username: %s\n",
	    current_parsed_root->username ? current_parsed_root->username : "NULL");
    printf ("current_parsed_root->hostname: %s\n",
	    current_parsed_root->hostname ? current_parsed_root->hostname : "NULL");
    printf ("current_parsed_root->directory: %s\n", current_parsed_root->directory);
@


