head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.13
	OPENBSD_6_0:1.1.1.13.0.64
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.60
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.62
	OPENBSD_5_8_BASE:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.54
	OPENBSD_5_7_BASE:1.1.1.13
	OPENBSD_5_6:1.1.1.13.0.58
	OPENBSD_5_6_BASE:1.1.1.13
	OPENBSD_5_5:1.1.1.13.0.56
	OPENBSD_5_5_BASE:1.1.1.13
	OPENBSD_5_4:1.1.1.13.0.52
	OPENBSD_5_4_BASE:1.1.1.13
	OPENBSD_5_3:1.1.1.13.0.50
	OPENBSD_5_3_BASE:1.1.1.13
	OPENBSD_5_2:1.1.1.13.0.48
	OPENBSD_5_2_BASE:1.1.1.13
	OPENBSD_5_1_BASE:1.1.1.13
	OPENBSD_5_1:1.1.1.13.0.46
	OPENBSD_5_0:1.1.1.13.0.44
	OPENBSD_5_0_BASE:1.1.1.13
	OPENBSD_4_9:1.1.1.13.0.42
	OPENBSD_4_9_BASE:1.1.1.13
	OPENBSD_4_8:1.1.1.13.0.40
	OPENBSD_4_8_BASE:1.1.1.13
	OPENBSD_4_7:1.1.1.13.0.36
	OPENBSD_4_7_BASE:1.1.1.13
	OPENBSD_4_6:1.1.1.13.0.38
	OPENBSD_4_6_BASE:1.1.1.13
	OPENBSD_4_5:1.1.1.13.0.34
	OPENBSD_4_5_BASE:1.1.1.13
	OPENBSD_4_4:1.1.1.13.0.32
	OPENBSD_4_4_BASE:1.1.1.13
	OPENBSD_4_3:1.1.1.13.0.30
	OPENBSD_4_3_BASE:1.1.1.13
	OPENBSD_4_2:1.1.1.13.0.28
	OPENBSD_4_2_BASE:1.1.1.13
	OPENBSD_4_1:1.1.1.13.0.26
	OPENBSD_4_1_BASE:1.1.1.13
	OPENBSD_4_0:1.1.1.13.0.24
	OPENBSD_4_0_BASE:1.1.1.13
	OPENBSD_3_9:1.1.1.13.0.22
	OPENBSD_3_9_BASE:1.1.1.13
	OPENBSD_3_8:1.1.1.13.0.20
	OPENBSD_3_8_BASE:1.1.1.13
	OPENBSD_3_7:1.1.1.13.0.18
	OPENBSD_3_7_BASE:1.1.1.13
	OPENBSD_3_6:1.1.1.13.0.16
	OPENBSD_3_6_BASE:1.1.1.13
	OPENBSD_3_5:1.1.1.13.0.14
	OPENBSD_3_5_BASE:1.1.1.13
	OPENBSD_3_4:1.1.1.13.0.12
	OPENBSD_3_4_BASE:1.1.1.13
	OPENBSD_3_3:1.1.1.13.0.10
	OPENBSD_3_3_BASE:1.1.1.13
	OPENBSD_3_2:1.1.1.13.0.8
	OPENBSD_3_2_BASE:1.1.1.13
	OPENBSD_3_1:1.1.1.13.0.6
	OPENBSD_3_1_BASE:1.1.1.13
	OPENBSD_3_0:1.1.1.13.0.4
	OPENBSD_3_0_BASE:1.1.1.13
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.1.1.13.0.2
	OPENBSD_2_9_BASE:1.1.1.13
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.1.1.12.0.8
	OPENBSD_2_8_BASE:1.1.1.12
	OPENBSD_2_7:1.1.1.12.0.6
	OPENBSD_2_7_BASE:1.1.1.12
	OPENBSD_2_6:1.1.1.12.0.4
	OPENBSD_2_6_BASE:1.1.1.12
	cvs-1-10-7:1.1.1.12
	OPENBSD_2_5:1.1.1.12.0.2
	OPENBSD_2_5_BASE:1.1.1.12
	cvs-1-10-5:1.1.1.12
	OPENBSD_2_4:1.1.1.11.0.4
	OPENBSD_2_4_BASE:1.1.1.11
	cvs-1-10:1.1.1.11
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.31;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.53;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.32;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.10;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.17;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.13;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.55.51;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.26.47;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.30;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.20.57;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.21;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.02.28.21.32.31;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.02.10.18.57.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Interface between the client and the rest of CVS.  */

/* Stuff shared with the server.  */
extern char *mode_to_string PROTO((mode_t));
extern int change_mode PROTO((char *, char *));

extern int gzip_level;
extern int filter_through_gzip PROTO((int, int, int, pid_t *));
extern int filter_through_gunzip PROTO((int, int, pid_t *));

#ifdef CLIENT_SUPPORT
/*
 * Functions to perform CVS commands via the protocol.  argc and argv
 * are the arguments and the return value is the exit status (zero success
 * nonzero failure).
 */
extern int client_commit PROTO((int argc, char **argv));
extern int client_update PROTO((int argc, char **argv));
extern int client_checkout PROTO((int argc, char **argv));
extern int client_diff PROTO((int argc, char **argv));
extern int client_log PROTO((int argc, char **argv));
extern int client_add PROTO((int argc, char **argv));
extern int client_remove PROTO((int argc, char **argv));
extern int client_status PROTO((int argc, char **argv));
extern int client_rdiff PROTO((int argc, char **argv));
extern int client_tag PROTO((int argc, char **argv));
extern int client_rtag PROTO((int argc, char **argv));
extern int client_import PROTO((int argc, char **argv));
extern int client_admin PROTO((int argc, char **argv));
extern int client_export PROTO((int argc, char **argv));
extern int client_history PROTO((int argc, char **argv));
extern int client_release PROTO((int argc, char **argv));

/*
 * Flag variable for seeing whether common code is running as a client
 * or to do a local operation.
 */
extern int client_active;

/* Is the -P option to checkout or update specified?  */
extern int client_prune_dirs;

/* Stream to write to the server.  */
extern FILE *to_server;
/* Stream to read from the server.  */
extern FILE *from_server;

/* Internal functions that handle client communication to server, etc.  */
int supported_request PROTO ((char *));
void option_with_arg PROTO((char *option, char *arg));

/* Get the responses and then close the connection.  */
extern int get_responses_and_close PROTO((void));

extern int get_server_responses PROTO((void));

/* Start up the connection to the server on the other end.  */
void
start_server PROTO((void));

/* Send the names of all the argument files to the server.  */
void
send_file_names PROTO((int argc, char **argv));

/*
 * Send Repository, Modified and Entry.  argc and argv contain only
 * the files to operate on (or empty for everything), not options.
 * local is nonzero if we should not recurse (-l option).  Also sends
 * Argument lines for argc and argv, so should be called after options
 * are sent.
 */
void
send_files PROTO((int argc, char **argv, int local, int aflag));

/*
 * Like send_files but never send "Unchanged"--just send the contents of the
 * file in that case.  This is used to fix it if you import a directory which
 * happens to have CVS directories (yes it is obscure but the testsuite tests
 * it).
 */
void
send_files_contents PROTO((int argc, char **argv, int local, int aflag));

/* Send an argument to the remote server.  */
void
send_arg PROTO((char *string));

/* Send a string of single-char options to the remote server, one by one.  */
void
send_option_string PROTO((char *string));

#endif /* CLIENT_SUPPORT */

/*
 * This structure is used to catalog the responses the client is
 * prepared to see from the server.
 */

struct response
{
    /* Name of the response.  */
    char *name;

#ifdef CLIENT_SUPPORT
    /*
     * Function to carry out the response.  ARGS is the text of the
     * command after name and, if present, a single space, have been
     * stripped off.  The function can scribble into ARGS if it wants.
     */
    void (*func) PROTO((char *args, int len));

    /*
     * ok and error are special; they indicate we are at the end of the
     * responses, and error indicates we should exit with nonzero
     * exitstatus.
     */
    enum {response_type_normal, response_type_ok, response_type_error} type;
#endif

    /* Used by the server to indicate whether response is supported by
       the client, as set by the Valid-responses request.  */
    enum {
      /*
       * Failure to implement this response can imply a fatal
       * error.  This should be set only for responses which were in the
       * original version of the protocol; it should not be set for new
       * responses.
       */
      rs_essential,

      /* Some clients might not understand this response.  */
      rs_optional,

      /*
       * Set by the server to one of the following based on what this
       * client actually supports.
       */
      rs_supported,
      rs_not_supported
      } status;
};

/* Table of responses ending in an entry with a NULL name.  */

extern struct response responses[];

#ifdef CLIENT_SUPPORT

extern void client_senddate PROTO((const char *date));
extern void client_expand_modules PROTO((int argc, char **argv, int local));
extern void client_send_expansions PROTO((int local));
extern void client_nonexpanded_setup PROTO((void));

extern char **failed_patches;
extern int failed_patches_count;
extern char toplevel_wd[];
extern void client_import_setup PROTO((char *repository));
extern int client_process_import_file
    PROTO((char *message, char *vfile, char *vtag,
	   int targc, char *targv[], char *repository));
extern void client_import_done PROTO((void));

#endif /* CLIENT_SUPPORT */
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a32 5
extern int client_watch PROTO((int argc, char **argv));
extern int client_watchers PROTO((int argc, char **argv));
extern int client_editors PROTO((int argc, char **argv));
extern int client_edit PROTO((int argc, char **argv));
extern int client_unedit PROTO((int argc, char **argv));
a39 6
/*
 * Flag variable for seeing whether the server has been started yet.
 * As of this writing, only edit.c:notify_check() uses it.
 */
extern int server_started;

d43 4
a46 11
#ifdef AUTH_CLIENT_SUPPORT
extern int use_authenticating_server;
int connect_to_pserver PROTO((int *tofdp, int* fromfdp, int verify_only));
# ifndef CVS_AUTH_PORT
# define CVS_AUTH_PORT 2401
# endif /* CVS_AUTH_PORT */
#endif /* AUTH_CLIENT_SUPPORT */

/* Talking to the server. */
void send_to_server PROTO((char *str, size_t len));
void read_from_server PROTO((char *buf, size_t len));
d68 3
a70 1
 * local is nonzero if we should not recurse (-l option).
d162 1
a162 1
extern void client_notify PROTO((char *, char *, char *, int, char *));
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a61 4
#ifdef AUTH_SERVER_SUPPORT
extern void authenticate_connection PROTO ((void));
#endif

@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a37 2
extern int client_init PROTO ((int argc, char **argv));
extern int client_annotate PROTO ((int argc, char **argv));
d85 1
a85 5
send_file_names PROTO((int argc, char **argv, unsigned int flags));

/* Flags for send_file_names.  */
/* Expand wild cards?  */
#define SEND_EXPAND_WILD 1
a172 2

extern void send_init_command PROTO ((void));
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a7 1
extern int file_gzip_level;
d11 29
a39 1
#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)
d41 5
a45 4
extern int cvsencrypt;

#ifdef ENCRYPTION
#ifdef HAVE_KERBEROS
a46 10
/* We can't declare the arguments without including krb.h, and I don't
   want to do that in every file.  */
extern struct buffer *krb_encrypt_buffer_initialize ();

#endif /* HAVE_KERBEROS */
#endif /* ENCRYPTION */

#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

#ifdef CLIENT_SUPPORT
d65 1
a65 5
extern void pserver_authenticate_connection PROTO ((void));
#endif

#if defined (SERVER_SUPPORT) && defined (HAVE_KERBEROS)
extern void kserver_authenticate_connection PROTO ((void));
d177 1
a177 1
extern void client_send_expansions PROTO((int local, char *where));
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d85 10
a94 2
send_files PROTO((int argc, char **argv, int local, int aflag,
		  int build_dirs));
d163 1
a163 2
extern void client_send_expansions PROTO((int local, char *where,
					  int build_dirs));
d170 1
a170 1
extern char *toplevel_wd;
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d86 1
a86 1
		  int build_dirs, int force));
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d86 1
a86 6
		  unsigned int flags));

/* Flags for send_files.  */
#define SEND_BUILD_DIRS 1
#define SEND_FORCE 2
#define SEND_NO_CONTENTS 4
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d172 1
a172 1
	   int targc, char *targv[], char *repository, int all_files_binary));
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@a13 1
/* Whether the connection should be encrypted.  */
a15 3
/* Whether the connection should use per-packet authentication.  */
extern int cvsauthenticate;

a16 1

a23 8

#ifdef HAVE_GSSAPI

/* Set this to turn on GSSAPI encryption.  */
extern int cvs_gssapi_encrypt;

#endif /* HAVE_GSSAPI */

a25 8
#ifdef HAVE_GSSAPI

/* We can't declare the arguments without including gssapi.h, and I
   don't want to do that in every file.  */
extern struct buffer *cvs_gssapi_wrap_buffer_initialize ();

#endif /* HAVE_GSSAPI */

d40 1
a40 2
void connect_to_pserver PROTO ((int *tofdp, int* fromfdp, int verify_only,
				int do_gssapi));
d46 1
a46 1
#if defined (AUTH_SERVER_SUPPORT) || (defined (SERVER_SUPPORT) && defined (HAVE_GSSAPI))
a100 2
extern void send_a_repository PROTO ((char *, char *, char *));

a117 2
     * Note that although LEN is given, ARGS is also guaranteed to be
     * '\0' terminated.
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d5 1
a5 1
extern int change_mode PROTO((char *, char *, int));
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d9 2
d198 1
a198 2
	   int targc, char *targv[], char *repository, int all_files_binary,
	   int modtime));
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@a111 1
#define BACKUP_MODIFIED_FILES 8
@


