head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.12.0.68
	OPENBSD_6_2_BASE:1.1.1.12
	OPENBSD_6_1:1.1.1.12.0.66
	OPENBSD_6_1_BASE:1.1.1.12
	OPENBSD_6_0:1.1.1.12.0.62
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.58
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.60
	OPENBSD_5_8_BASE:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.52
	OPENBSD_5_7_BASE:1.1.1.12
	OPENBSD_5_6:1.1.1.12.0.56
	OPENBSD_5_6_BASE:1.1.1.12
	OPENBSD_5_5:1.1.1.12.0.54
	OPENBSD_5_5_BASE:1.1.1.12
	OPENBSD_5_4:1.1.1.12.0.50
	OPENBSD_5_4_BASE:1.1.1.12
	OPENBSD_5_3:1.1.1.12.0.48
	OPENBSD_5_3_BASE:1.1.1.12
	OPENBSD_5_2:1.1.1.12.0.46
	OPENBSD_5_2_BASE:1.1.1.12
	OPENBSD_5_1_BASE:1.1.1.12
	OPENBSD_5_1:1.1.1.12.0.44
	OPENBSD_5_0:1.1.1.12.0.42
	OPENBSD_5_0_BASE:1.1.1.12
	OPENBSD_4_9:1.1.1.12.0.40
	OPENBSD_4_9_BASE:1.1.1.12
	OPENBSD_4_8:1.1.1.12.0.38
	OPENBSD_4_8_BASE:1.1.1.12
	OPENBSD_4_7:1.1.1.12.0.34
	OPENBSD_4_7_BASE:1.1.1.12
	OPENBSD_4_6:1.1.1.12.0.36
	OPENBSD_4_6_BASE:1.1.1.12
	OPENBSD_4_5:1.1.1.12.0.32
	OPENBSD_4_5_BASE:1.1.1.12
	OPENBSD_4_4:1.1.1.12.0.30
	OPENBSD_4_4_BASE:1.1.1.12
	OPENBSD_4_3:1.1.1.12.0.28
	OPENBSD_4_3_BASE:1.1.1.12
	OPENBSD_4_2:1.1.1.12.0.26
	OPENBSD_4_2_BASE:1.1.1.12
	OPENBSD_4_1:1.1.1.12.0.24
	OPENBSD_4_1_BASE:1.1.1.12
	OPENBSD_4_0:1.1.1.12.0.22
	OPENBSD_4_0_BASE:1.1.1.12
	OPENBSD_3_9:1.1.1.12.0.20
	OPENBSD_3_9_BASE:1.1.1.12
	OPENBSD_3_8:1.1.1.12.0.18
	OPENBSD_3_8_BASE:1.1.1.12
	OPENBSD_3_7:1.1.1.12.0.16
	OPENBSD_3_7_BASE:1.1.1.12
	OPENBSD_3_6:1.1.1.12.0.14
	OPENBSD_3_6_BASE:1.1.1.12
	OPENBSD_3_5:1.1.1.12.0.12
	OPENBSD_3_5_BASE:1.1.1.12
	OPENBSD_3_4:1.1.1.12.0.10
	OPENBSD_3_4_BASE:1.1.1.12
	OPENBSD_3_3:1.1.1.12.0.8
	OPENBSD_3_3_BASE:1.1.1.12
	OPENBSD_3_2:1.1.1.12.0.6
	OPENBSD_3_2_BASE:1.1.1.12
	OPENBSD_3_1:1.1.1.12.0.4
	OPENBSD_3_1_BASE:1.1.1.12
	OPENBSD_3_0:1.1.1.12.0.2
	OPENBSD_3_0_BASE:1.1.1.12
	cvs-1-11-1p1:1.1.1.12
	OPENBSD_2_9:1.1.1.11.0.2
	OPENBSD_2_9_BASE:1.1.1.11
	cvs-1-11:1.1.1.11
	OPENBSD_2_8:1.1.1.10.0.8
	OPENBSD_2_8_BASE:1.1.1.10
	OPENBSD_2_7:1.1.1.10.0.6
	OPENBSD_2_7_BASE:1.1.1.10
	OPENBSD_2_6:1.1.1.10.0.4
	OPENBSD_2_6_BASE:1.1.1.10
	cvs-1-10-7:1.1.1.10
	OPENBSD_2_5:1.1.1.10.0.2
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.9.0.4
	OPENBSD_2_4_BASE:1.1.1.9
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.9
	OPENBSD_2_3:1.1.1.9.0.2
	OPENBSD_2_3_BASE:1.1.1.9
	cvs-1-9-26:1.1.1.9
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	96.01.30.00.18.35;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.18.35;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.42.24;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.20.11;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.59;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.58;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.33;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.28.06;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.29.04;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.42;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.45;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.02.10.18.57.49;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.09.28.22.45.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Implementation for "cvs watch add", "cvs watchers", and related commands

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

#include "cvs.h"
#include "edit.h"
#include "fileattr.h"
#include "watch.h"

const char *const watch_usage[] =
{
    "Usage: %s %s [on|off|add|remove] [-l] [-a action] [files...]\n",
    "on/off: turn on/off read-only checkouts of files\n",
    "add/remove: add or remove notification on actions\n",
    "-l (on/off/add/remove): Local directory only, not recursive\n",
    "-a (add/remove): Specify what actions, one of\n",
    "    edit,unedit,commit,all,none\n",
    NULL
};

static struct addremove_args the_args;

void
watch_modify_watchers (file, what)
    char *file;
    struct addremove_args *what;
{
    char *curattr = fileattr_get0 (file, "_watchers");
    char *p;
    char *pend;
    char *nextp;
    char *who;
    int who_len;
    char *mycurattr;
    char *mynewattr;
    size_t mynewattr_size;

    int add_edit_pending;
    int add_unedit_pending;
    int add_commit_pending;
    int remove_edit_pending;
    int remove_unedit_pending;
    int remove_commit_pending;
    int add_tedit_pending;
    int add_tunedit_pending;
    int add_tcommit_pending;

    who = getcaller ();
    who_len = strlen (who);

    /* Look for current watcher types for this user.  */
    mycurattr = NULL;
    if (curattr != NULL)
    {
	p = curattr;
	while (1) {
	    if (strncmp (who, p, who_len) == 0
		&& p[who_len] == '>')
	    {
		/* Found this user.  */
		mycurattr = p + who_len + 1;
	    }
	    p = strchr (p, ',');
	    if (p == NULL)
		break;
	    ++p;
	}
    }
    if (mycurattr != NULL)
    {
	mycurattr = xstrdup (mycurattr);
	p = strchr (mycurattr, ',');
	if (p != NULL)
	    *p = '\0';
    }

    /* Now copy mycurattr to mynewattr, making the requisite modifications.
       Note that we add a dummy '+' to the start of mynewattr, to reduce
       special cases (but then we strip it off when we are done).  */

    mynewattr_size = sizeof "+edit+unedit+commit+tedit+tunedit+tcommit";
    if (mycurattr != NULL)
	mynewattr_size += strlen (mycurattr);
    mynewattr = xmalloc (mynewattr_size);
    mynewattr[0] = '\0';

    add_edit_pending = what->adding && what->edit;
    add_unedit_pending = what->adding && what->unedit;
    add_commit_pending = what->adding && what->commit;
    remove_edit_pending = !what->adding && what->edit;
    remove_unedit_pending = !what->adding && what->unedit;
    remove_commit_pending = !what->adding && what->commit;
    add_tedit_pending = what->add_tedit;
    add_tunedit_pending = what->add_tunedit;
    add_tcommit_pending = what->add_tcommit;

    /* Copy over existing watch types, except those to be removed.  */
    p = mycurattr;
    while (p != NULL)
    {
	pend = strchr (p, '+');
	if (pend == NULL)
	{
	    pend = p + strlen (p);
	    nextp = NULL;
	}
	else
	    nextp = pend + 1;

	/* Process this item.  */
	if (pend - p == 4 && strncmp ("edit", p, 4) == 0)
	{
	    if (!remove_edit_pending)
		strcat (mynewattr, "+edit");
	    add_edit_pending = 0;
	}
	else if (pend - p == 6 && strncmp ("unedit", p, 6) == 0)
	{
	    if (!remove_unedit_pending)
		strcat (mynewattr, "+unedit");
	    add_unedit_pending = 0;
	}
	else if (pend - p == 6 && strncmp ("commit", p, 6) == 0)
	{
	    if (!remove_commit_pending)
		strcat (mynewattr, "+commit");
	    add_commit_pending = 0;
	}
	else if (pend - p == 5 && strncmp ("tedit", p, 5) == 0)
	{
	    if (!what->remove_temp)
		strcat (mynewattr, "+tedit");
	    add_tedit_pending = 0;
	}
	else if (pend - p == 7 && strncmp ("tunedit", p, 7) == 0)
	{
	    if (!what->remove_temp)
		strcat (mynewattr, "+tunedit");
	    add_tunedit_pending = 0;
	}
	else if (pend - p == 7 && strncmp ("tcommit", p, 7) == 0)
	{
	    if (!what->remove_temp)
		strcat (mynewattr, "+tcommit");
	    add_tcommit_pending = 0;
	}
	else
	{
	    char *mp;

	    /* Copy over any unrecognized watch types, for future
	       expansion.  */
	    mp = mynewattr + strlen (mynewattr);
	    *mp++ = '+';
	    strncpy (mp, p, pend - p);
	    *(mp + (pend - p)) = '\0';
	}

	/* Set up for next item.  */
	p = nextp;
    }

    /* Add in new watch types.  */
    if (add_edit_pending)
	strcat (mynewattr, "+edit");
    if (add_unedit_pending)
	strcat (mynewattr, "+unedit");
    if (add_commit_pending)
	strcat (mynewattr, "+commit");
    if (add_tedit_pending)
	strcat (mynewattr, "+tedit");
    if (add_tunedit_pending)
	strcat (mynewattr, "+tunedit");
    if (add_tcommit_pending)
	strcat (mynewattr, "+tcommit");

    {
	char *curattr_new;

	curattr_new =
	  fileattr_modify (curattr,
			   who,
			   mynewattr[0] == '\0' ? NULL : mynewattr + 1,
			   '>',
			   ',');
	/* If the attribute is unchanged, don't rewrite the attribute file.  */
	if (!((curattr_new == NULL && curattr == NULL)
	      || (curattr_new != NULL
		  && curattr != NULL
		  && strcmp (curattr_new, curattr) == 0)))
	    fileattr_set (file,
			  "_watchers",
			  curattr_new);
	if (curattr_new != NULL)
	    free (curattr_new);
    }

    if (curattr != NULL)
	free (curattr);
    if (mycurattr != NULL)
	free (mycurattr);
}

static int addremove_fileproc PROTO ((char *, char *, char *, List *, List *));

static int
addremove_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
{
    watch_modify_watchers (file, &the_args);
    return 0;
}

static int addremove_filesdoneproc PROTO ((int, char *, char *));

static int
addremove_filesdoneproc (err, repository, update_dir)
    int err;
    char *repository;
    char *update_dir;
{
    if (the_args.setting_default)
	watch_modify_watchers (NULL, &the_args);
    return err;
}

static int watch_addremove PROTO ((int argc, char **argv));

static int
watch_addremove (argc, argv)
    int argc;
    char **argv;
{
    int c;
    int local = 0;
    int err;
    int a_omitted;

    a_omitted = 1;
    the_args.commit = 0;
    the_args.edit = 0;
    the_args.unedit = 0;
    optind = 1;
    while ((c = getopt (argc, argv, "la:")) != -1)
    {
	switch (c)
	{
	    case 'l':
		local = 1;
		break;
	    case 'a':
		a_omitted = 0;
		if (strcmp (optarg, "edit") == 0)
		    the_args.edit = 1;
		else if (strcmp (optarg, "unedit") == 0)
		    the_args.unedit = 1;
		else if (strcmp (optarg, "commit") == 0)
		    the_args.commit = 1;
		else if (strcmp (optarg, "all") == 0)
		{
		    the_args.edit = 1;
		    the_args.unedit = 1;
		    the_args.commit = 1;
		}
		else if (strcmp (optarg, "none") == 0)
		{
		    the_args.edit = 0;
		    the_args.unedit = 0;
		    the_args.commit = 0;
		}
		else
		    usage (watch_usage);
		break;
	    case '?':
	    default:
		usage (watch_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

    if (a_omitted)
    {
	the_args.edit = 1;
	the_args.unedit = 1;
	the_args.commit = 1;
    }

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	start_server ();
	ign_setup ();

	if (local)
	    send_arg ("-l");
	/* FIXME: copes poorly with "all" if server is extended to have
	   new watch types and client is still running an old version.  */
	if (the_args.edit)
	{
	    send_arg ("-a");
	    send_arg ("edit");
	}
	if (the_args.unedit)
	{
	    send_arg ("-a");
	    send_arg ("unedit");
	}
	if (the_args.commit)
	{
	    send_arg ("-a");
	    send_arg ("commit");
	}
	if (!the_args.edit && !the_args.unedit && !the_args.commit)
	{
	    send_arg ("-a");
	    send_arg ("none");
	}
	send_file_names (argc, argv);
	/* FIXME:  We shouldn't have to send current files, but I'm not sure
	   whether it works.  So send the files --
	   it's slower but it works.  */
	send_files (argc, argv, local, 0);
	send_to_server (the_args.adding ?
                        "watch-add\012" : "watch-remove\012",
                        0);
	return get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    the_args.setting_default = (argc <= 0);

    lock_tree_for_write (argc, argv, local, 0);

    err = start_recursion (addremove_fileproc, addremove_filesdoneproc,
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
			   argc, argv, local, W_LOCAL, 0, 0, (char *)NULL,
			   1, 0);

    lock_tree_cleanup ();
    return err;
}

int
watch_add (argc, argv)
    int argc;
    char **argv;
{
    the_args.adding = 1;
    return watch_addremove (argc, argv);
}

int
watch_remove (argc, argv)
    int argc;
    char **argv;
{
    the_args.adding = 0;
    return watch_addremove (argc, argv);
}

int
watch (argc, argv)
    int argc;
    char **argv;
{
    if (argc == -1)
	usage (watch_usage);
    if (strcmp (argv[1], "on") == 0)
    {
	--argc;
	++argv;
	return watch_on (argc, argv);
    }
    else if (strcmp (argv[1], "off") == 0)
    {
	--argc;
	++argv;
	return watch_off (argc, argv);
    }
    else if (strcmp (argv[1], "add") == 0)
    {
	--argc;
	++argv;
	return watch_add (argc, argv);
    }
    else if (strcmp (argv[1], "remove") == 0)
    {
	--argc;
	++argv;
	return watch_remove (argc, argv);
    }
    else
	usage (watch_usage);
    return 0;
}

static const char *const watchers_usage[] =
{
    "Usage: %s %s [files...]\n",
    NULL
};

static int watchers_fileproc PROTO ((char *, char *, char *, List *, List *));

static int
watchers_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
{
    char *them;
    char *p;

    them = fileattr_get0 (file, "_watchers");
    if (them == NULL)
	return 0;

    if (update_dir[0] == '\0')
	printf ("%s", file);
    else
	printf ("%s/%s", update_dir, file);

    p = them;
    while (1)
    {
	putc ('\t', stdout);
	while (*p != '>' && *p != '\0')
	    putc (*p++, stdout);
	if (*p == '\0')
	{
	    /* Only happens if attribute is misformed.  */
	    putc ('\n', stdout);
	    break;
	}
	++p;
	putc ('\t', stdout);
	while (1)
	{
	    while (*p != '+' && *p != ',' && *p != '\0')
		putc (*p++, stdout);
	    if (*p == '\0')
	    {
		putc ('\n', stdout);
		goto out;
	    }
	    if (*p == ',')
	    {
		++p;
		break;
	    }
	    ++p;
	    putc ('\t', stdout);
	}
	putc ('\n', stdout);
    }
  out:;
    return 0;
}

int
watchers (argc, argv)
    int argc;
    char **argv;
{
    int local = 0;
    int c;

    if (argc == -1)
	usage (watchers_usage);

    optind = 1;
    while ((c = getopt (argc, argv, "l")) != -1)
    {
	switch (c)
	{
	    case 'l':
		local = 1;
		break;
	    case '?':
	    default:
		usage (watchers_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	start_server ();
	ign_setup ();

	if (local)
	    send_arg ("-l");
	send_file_names (argc, argv);
	/* FIXME:  We shouldn't have to send current files, but I'm not sure
	   whether it works.  So send the files --
	   it's slower but it works.  */
	send_files (argc, argv, local, 0);
	send_to_server ("watchers\012", 0);
	return get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    return start_recursion (watchers_fileproc, (FILESDONEPROC) NULL,
			    (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
			    argc, argv, local, W_LOCAL, 0, 1, (char *)NULL,
			    1, 0);
}
@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a213 2
    if (mynewattr != NULL)
	free (mynewattr);
d216 1
a216 1
static int addremove_fileproc PROTO ((struct file_info *finfo));
d219 6
a224 2
addremove_fileproc (finfo)
    struct file_info *finfo;
d226 1
a226 1
    watch_modify_watchers (finfo->file, &the_args);
d384 1
a384 1
    if (argc <= 1)
d421 1
a421 1
static int watchers_fileproc PROTO ((struct file_info *finfo));
d424 6
a429 2
watchers_fileproc (finfo)
    struct file_info *finfo;
d434 1
a434 1
    them = fileattr_get0 (finfo->file, "_watchers");
d438 2
a439 2
    if (finfo->update_dir[0] == '\0')
	printf ("%s", finfo->file);
d441 1
a441 1
	printf ("%s/%s", finfo->update_dir, finfo->file);
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@d334 1
a334 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d432 4
a435 1
    fputs (finfo->fullname, stdout);
d510 1
a510 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d218 1
a218 2
static int addremove_fileproc PROTO ((void *callerdat,
				      struct file_info *finfo));
d221 1
a221 2
addremove_fileproc (callerdat, finfo)
    void *callerdat;
d228 1
a228 2
static int addremove_filesdoneproc PROTO ((void *, int, char *, char *,
					   List *));
d231 1
a231 2
addremove_filesdoneproc (callerdat, err, repository, update_dir, entries)
    void *callerdat;
a234 1
    List *entries;
d351 1
a351 1
			   (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
d353 1
a353 1
			   1);
d419 1
a419 2
static int watchers_fileproc PROTO ((void *callerdat,
				     struct file_info *finfo));
d422 1
a422 2
watchers_fileproc (callerdat, finfo)
    void *callerdat;
d518 1
a518 1
			    (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
d520 1
a520 1
			    1);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d11 5
a15 1
   GNU General Public License for more details.  */
d343 1
a343 1
	send_files (argc, argv, local, 0, 0);
d360 1
a360 1
    Lock_Cleanup ();
d518 1
a518 1
	send_files (argc, argv, local, 0, 0);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d339 1
a339 1
	send_files (argc, argv, local, 0, 0, 0);
d514 1
a514 1
	send_files (argc, argv, local, 0, 0, 0);
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d259 1
a259 1
    while ((c = getopt (argc, argv, "+la:")) != -1)
d336 4
a339 1
	send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
d486 1
a486 1
    while ((c = getopt (argc, argv, "+l")) != -1)
d511 4
a514 1
	send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d20 1
a20 1
    "Usage: %s %s [on|off|add|remove] [-lR] [-a action] [files...]\n",
a23 1
    "-R (on/off/add/remove): Process directories recursively\n",
d258 2
a259 2
    optind = 0;
    while ((c = getopt (argc, argv, "+lRa:")) != -1)
a265 3
	    case 'R':
		local = 0;
		break;
d413 1
a413 3
    "Usage: %s %s [-lR] [files...]\n",
    "\t-l\tProcess this directory only (not recursive).\n",
    "\t-R\tProcess directories recursively.\n",
d482 2
a483 2
    optind = 0;
    while ((c = getopt (argc, argv, "+lR")) != -1)
a488 3
		break;
	    case 'R':
		local = 0;
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@a26 1
    "(Specify the --help global option for a list of other help options)\n",
a419 1
    "(Specify the --help global option for a list of other help options)\n",
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d340 1
a341 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d440 1
a440 1
    cvs_output (finfo->fullname, 0);
d445 1
a445 1
	cvs_output ("\t", 1);
d447 1
a447 1
	    cvs_output (p++, 1);
d451 1
a451 1
	    cvs_output ("\n", 1);
d455 1
a455 1
	cvs_output ("\t", 1);
d459 1
a459 1
		cvs_output (p++, 1);
d462 1
a462 1
		cvs_output ("\n", 1);
d471 1
a471 1
	    cvs_output ("\t", 1);
d473 1
a473 1
	cvs_output ("\n", 1);
d518 1
a519 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@a475 1
    free (them);
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d311 1
a311 1
    if (current_parsed_root->isremote)
d351 1
a351 1
    lock_tree_for_write (argc, argv, local, W_LOCAL, 0);
d512 1
a512 1
    if (current_parsed_root->isremote)
@


