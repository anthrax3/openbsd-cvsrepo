head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.54
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.50
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.46
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.48
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.40
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.44
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.42
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.38
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.36
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.34
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.32
	OPENBSD_5_0:1.3.0.30
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.28
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.1.16.0.6
	OPENBSD_3_2_BASE:1.1.1.16
	OPENBSD_3_1:1.1.1.16.0.4
	OPENBSD_3_1_BASE:1.1.1.16
	OPENBSD_3_0:1.1.1.16.0.2
	OPENBSD_3_0_BASE:1.1.1.16
	cvs-1-11-1p1:1.1.1.16
	OPENBSD_2_9:1.1.1.15.0.2
	OPENBSD_2_9_BASE:1.1.1.15
	cvs-1-11:1.1.1.15
	OPENBSD_2_8:1.1.1.14.0.8
	OPENBSD_2_8_BASE:1.1.1.14
	OPENBSD_2_7:1.1.1.14.0.6
	OPENBSD_2_7_BASE:1.1.1.14
	OPENBSD_2_6:1.1.1.14.0.4
	OPENBSD_2_6_BASE:1.1.1.14
	cvs-1-10-7:1.1.1.14
	OPENBSD_2_5:1.1.1.14.0.2
	OPENBSD_2_5_BASE:1.1.1.14
	cvs-1-10-5:1.1.1.14
	OPENBSD_2_4:1.1.1.13.0.2
	OPENBSD_2_4_BASE:1.1.1.13
	cvs-1-10:1.1.1.13
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.1.1.12.0.2
	OPENBSD_2_3_BASE:1.1.1.12
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.1.1.10.0.2
	OPENBSD_2_2_BASE:1.1.1.10
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.1.1.9.0.2
	OPENBSD_2_1_BASE:1.1.1.9
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2004.06.09.18.16.05;	author otto;	state Exp;
branches;
next	1.2;

1.2
date	2002.12.09.00.45.34;	author millert;	state Exp;
branches
	1.2.4.1
	1.2.6.1;
next	1.1;

1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.31;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.20;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.06;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.56;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.54;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.29;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.38.25;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.27.58;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.29.01;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.21.38;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.06.59.16;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.03.54.30;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.02.28.21.33.39;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.02.10.18.57.48;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;

1.2.4.1
date	2004.06.09.19.51.06;	author brad;	state Exp;
branches;
next	;

1.2.6.1
date	2004.06.09.19.31.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.

ok millert@@
@
text
@/* filesubr.c --- subroutines for dealing with files
   Jim Blandy <jimb@@cyclic.com>

   This file is part of GNU CVS.

   GNU CVS is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

/* These functions were moved out of subr.c because they need different
   definitions under operating systems (like, say, Windows NT) with different
   file system semantics.  */

#include <assert.h>
#include "cvs.h"

static int deep_remove_dir PROTO((const char *path));

/*
 * Copies "from" to "to".
 */
void
copy_file (from, to)
    const char *from;
    const char *to;
{
    struct stat sb;
    struct utimbuf t;
    int fdin, fdout;

    if (trace)
	(void) fprintf (stderr, "%s-> copy(%s,%s)\n",
			CLIENT_SERVER_STR, from, to);
    if (noexec)
	return;

    /* If the file to be copied is a link or a device, then just create
       the new link or device appropriately. */
    if (islink (from))
    {
	char *source = xreadlink (from);
	symlink (source, to);
	free (source);
	return;
    }

    if (isdevice (from))
    {
#if defined(HAVE_MKNOD) && defined(HAVE_ST_RDEV)
	if (stat (from, &sb) < 0)
	    error (1, errno, "cannot stat %s", from);
	mknod (to, sb.st_mode, sb.st_rdev);
#else
	error (1, 0, "cannot copy device files on this system (%s)", from);
#endif
    }
    else
    {
	/* Not a link or a device... probably a regular file. */
	if ((fdin = open (from, O_RDONLY)) < 0)
	    error (1, errno, "cannot open %s for copying", from);
	if (fstat (fdin, &sb) < 0)
	    error (1, errno, "cannot fstat %s", from);
	if ((fdout = creat (to, (int) sb.st_mode & 07777)) < 0)
	    error (1, errno, "cannot create %s for copying", to);
	if (sb.st_size > 0)
	{
	    char buf[BUFSIZ];
	    int n;
	    
	    for (;;) 
	    {
		n = read (fdin, buf, sizeof(buf));
		if (n == -1)
		{
#ifdef EINTR
		    if (errno == EINTR)
			continue;
#endif
		    error (1, errno, "cannot read file %s for copying", from);
		}
		else if (n == 0) 
		    break;
		
		if (write(fdout, buf, n) != n) {
		    error (1, errno, "cannot write file %s for copying", to);
		}
	    }

#ifdef HAVE_FSYNC
	    if (fsync (fdout)) 
		error (1, errno, "cannot fsync file %s after copying", to);
#endif
	}

	if (close (fdin) < 0) 
	    error (0, errno, "cannot close %s", from);
	if (close (fdout) < 0)
	    error (1, errno, "cannot close %s", to);
    }

    /* now, set the times for the copied file to match those of the original */
    memset ((char *) &t, 0, sizeof (t));
    t.actime = sb.st_atime;
    t.modtime = sb.st_mtime;
    (void) utime (to, &t);
}

/* FIXME-krp: these functions would benefit from caching the char * &
   stat buf.  */

/*
 * Returns non-zero if the argument file is a directory, or is a symbolic
 * link which points to a directory.
 */
int
isdir (file)
    const char *file;
{
    struct stat sb;

    if (stat (file, &sb) < 0)
	return (0);
    return (S_ISDIR (sb.st_mode));
}

/*
 * Returns non-zero if the argument file is a symbolic link.
 */
int
islink (file)
    const char *file;
{
#ifdef S_ISLNK
    struct stat sb;

    if (CVS_LSTAT (file, &sb) < 0)
	return (0);
    return (S_ISLNK (sb.st_mode));
#else
    return (0);
#endif
}

/*
 * Returns non-zero if the argument file is a block or
 * character special device.
 */
int
isdevice (file)
    const char *file;
{
    struct stat sb;

    if (CVS_LSTAT (file, &sb) < 0)
	return (0);
#ifdef S_ISBLK
    if (S_ISBLK (sb.st_mode))
	return 1;
#endif
#ifdef S_ISCHR
    if (S_ISCHR (sb.st_mode))
	return 1;
#endif
    return 0;
}

/*
 * Returns non-zero if the argument file exists.
 */
int
isfile (file)
    const char *file;
{
    return isaccessible(file, F_OK);
}

/*
 * Returns non-zero if the argument file is readable.
 */
int
isreadable (file)
    const char *file;
{
    return isaccessible(file, R_OK);
}

/*
 * Returns non-zero if the argument file is writable.
 */
int
iswritable (file)
    const char *file;
{
    return isaccessible(file, W_OK);
}

/*
 * Returns non-zero if the argument file is accessable according to
 * mode.  If compiled with SETXID_SUPPORT also works if cvs has setxid
 * bits set.
 */
int
isaccessible (file, mode)
    const char *file;
    const int mode;
{
#ifdef SETXID_SUPPORT
    struct stat sb;
    int umask = 0;
    int gmask = 0;
    int omask = 0;
    int uid;
    
    if (stat(file, &sb) == -1)
	return 0;
    if (mode == F_OK)
	return 1;

    uid = geteuid();
    if (uid == 0)		/* superuser */
    {
	if (mode & X_OK)
	    return sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH);
	else
	    return 1;
    }
	
    if (mode & R_OK)
    {
	umask |= S_IRUSR;
	gmask |= S_IRGRP;
	omask |= S_IROTH;
    }
    if (mode & W_OK)
    {
	umask |= S_IWUSR;
	gmask |= S_IWGRP;
	omask |= S_IWOTH;
    }
    if (mode & X_OK)
    {
	umask |= S_IXUSR;
	gmask |= S_IXGRP;
	omask |= S_IXOTH;
    }

    if (sb.st_uid == uid)
	return (sb.st_mode & umask) == umask;
    else if (sb.st_gid == getegid())
	return (sb.st_mode & gmask) == gmask;
    else
	return (sb.st_mode & omask) == omask;
#else
    return access(file, mode) == 0;
#endif
}

/*
 * Open a file and die if it fails
 */
FILE *
open_file (name, mode)
    const char *name;
    const char *mode;
{
    FILE *fp;

    if ((fp = fopen (name, mode)) == NULL)
	error (1, errno, "cannot open %s", name);
    return (fp);
}

/*
 * Make a directory and die if it fails
 */
void
make_directory (name)
    const char *name;
{
    struct stat sb;

    if (stat (name, &sb) == 0 && (!S_ISDIR (sb.st_mode)))
	    error (0, 0, "%s already exists but is not a directory", name);
    if (!noexec && mkdir (name, 0777) < 0)
	error (1, errno, "cannot make directory %s", name);
}

/*
 * Make a path to the argument directory, printing a message if something
 * goes wrong.
 */
void
make_directories (name)
    const char *name;
{
    char *cp;

    if (noexec)
	return;

    if (mkdir (name, 0777) == 0 || errno == EEXIST)
	return;
    if (! existence_error (errno))
    {
	error (0, errno, "cannot make path to %s", name);
	return;
    }
    if ((cp = strrchr (name, '/')) == NULL)
	return;
    *cp = '\0';
    make_directories (name);
    *cp++ = '/';
    if (*cp == '\0')
	return;
    (void) mkdir (name, 0777);
}

/* Create directory NAME if it does not already exist; fatal error for
   other errors.  Returns 0 if directory was created; 1 if it already
   existed.  */
int
mkdir_if_needed (name)
    char *name;
{
    if (mkdir (name, 0777) < 0)
    {
	if (!(errno == EEXIST
	      || (errno == EACCES && isdir (name))))
	    error (1, errno, "cannot make directory %s", name);
	return 1;
    }
    return 0;
}

/*
 * Change the mode of a file, either adding write permissions, or removing
 * all write permissions.  Either change honors the current umask setting.
 *
 * Don't do anything if PreservePermissions is set to `yes'.  This may
 * have unexpected consequences for some uses of xchmod.
 */
void
xchmod (fname, writable)
    char *fname;
    int writable;
{
    struct stat sb;
    mode_t mode, oumask;

    if (preserve_perms)
	return;

    if (stat (fname, &sb) < 0)
    {
	if (!noexec)
	    error (0, errno, "cannot stat %s", fname);
	return;
    }
    oumask = umask (0);
    (void) umask (oumask);
    if (writable)
    {
	mode = sb.st_mode | (~oumask
			     & (((sb.st_mode & S_IRUSR) ? S_IWUSR : 0)
				| ((sb.st_mode & S_IRGRP) ? S_IWGRP : 0)
				| ((sb.st_mode & S_IROTH) ? S_IWOTH : 0)));
    }
    else
    {
	mode = sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH) & ~oumask;
    }

    if (trace)
	(void) fprintf (stderr, "%s-> chmod(%s,%o)\n",
			CLIENT_SERVER_STR, fname,
			(unsigned int) mode);
    if (noexec)
	return;

    if (chmod (fname, mode) < 0)
	error (0, errno, "cannot change mode of file %s", fname);
}

/*
 * Rename a file and die if it fails
 */
void
rename_file (from, to)
    const char *from;
    const char *to;
{
    if (trace)
	(void) fprintf (stderr, "%s-> rename(%s,%s)\n",
			CLIENT_SERVER_STR, from, to);
    if (noexec)
	return;

    if (rename (from, to) < 0)
	error (1, errno, "cannot rename file %s to %s", from, to);
}

/*
 * unlink a file, if possible.
 */
int
unlink_file (f)
    const char *f;
{
    if (trace)
	(void) fprintf (stderr, "%s-> unlink_file(%s)\n",
			CLIENT_SERVER_STR, f);
    if (noexec)
	return (0);

    return (CVS_UNLINK (f));
}

/*
 * Unlink a file or dir, if possible.  If it is a directory do a deep
 * removal of all of the files in the directory.  Return -1 on error
 * (in which case errno is set).
 */
int
unlink_file_dir (f)
    const char *f;
{
    struct stat sb;

    if (trace
#ifdef SERVER_SUPPORT
	/* This is called by the server parent process in contexts where
	   it is not OK to send output (e.g. after we sent "ok" to the
	   client).  */
	&& !server_active
#endif
	)
	(void) fprintf (stderr, "-> unlink_file_dir(%s)\n", f);

    if (noexec)
	return (0);

    /* For at least some unices, if root tries to unlink() a directory,
       instead of doing something rational like returning EISDIR,
       the system will gleefully go ahead and corrupt the filesystem.
       So we first call stat() to see if it is OK to call unlink().  This
       doesn't quite work--if someone creates a directory between the
       call to stat() and the call to unlink(), we'll still corrupt
       the filesystem.  Where is the Unix Haters Handbook when you need
       it?  */
    if (stat (f, &sb) < 0)
    {
	if (existence_error (errno))
	{
	    /* The file or directory doesn't exist anyhow.  */
	    return -1;
	}
    }
    else if (S_ISDIR (sb.st_mode))
	return deep_remove_dir (f);

    return CVS_UNLINK (f);
}

/* Remove a directory and everything it contains.  Returns 0 for
 * success, -1 for failure (in which case errno is set).
 */

static int
deep_remove_dir (path)
    const char *path;
{
    DIR		  *dirp;
    struct dirent *dp;

    if (rmdir (path) != 0)
    {
	if (errno == ENOTEMPTY
	    || errno == EEXIST
	    /* Ugly workaround for ugly AIX 4.1 (and 3.2) header bug
	       (it defines ENOTEMPTY and EEXIST to 17 but actually
	       returns 87).  */
	    || (ENOTEMPTY == 17 && EEXIST == 17 && errno == 87))
	{
	    if ((dirp = CVS_OPENDIR (path)) == NULL)
		/* If unable to open the directory return
		 * an error
		 */
		return -1;

	    errno = 0;
	    while ((dp = CVS_READDIR (dirp)) != NULL)
	    {
		char *buf;

		if (strcmp (dp->d_name, ".") == 0 ||
			    strcmp (dp->d_name, "..") == 0)
		    continue;

		buf = xmalloc (strlen (path) + strlen (dp->d_name) + 5);
		sprintf (buf, "%s/%s", path, dp->d_name);

		/* See comment in unlink_file_dir explanation of why we use
		   isdir instead of just calling unlink and checking the
		   status.  */
		if (isdir(buf)) 
		{
		    if (deep_remove_dir(buf))
		    {
			CVS_CLOSEDIR(dirp);
			free (buf);
			return -1;
		    }
		}
		else
		{
		    if (CVS_UNLINK (buf) != 0)
		    {
			CVS_CLOSEDIR(dirp);
			free (buf);
			return -1;
		    }
		}
		free (buf);

		errno = 0;
	    }
	    if (errno != 0)
	    {
		int save_errno = errno;
		CVS_CLOSEDIR (dirp);
		errno = save_errno;
		return -1;
	    }
	    CVS_CLOSEDIR (dirp);
	    return rmdir (path);
	}
	else
	    return -1;
    }

    /* Was able to remove the directory return 0 */
    return 0;
}

/* Read NCHARS bytes from descriptor FD into BUF.
   Return the number of characters successfully read.
   The number returned is always NCHARS unless end-of-file or error.  */
static size_t
block_read (fd, buf, nchars)
    int fd;
    char *buf;
    size_t nchars;
{
    char *bp = buf;
    size_t nread;

    do 
    {
	nread = read (fd, bp, nchars);
	if (nread == (size_t)-1)
	{
#ifdef EINTR
	    if (errno == EINTR)
		continue;
#endif
	    return (size_t)-1;
	}

	if (nread == 0)
	    break; 

	bp += nread;
	nchars -= nread;
    } while (nchars != 0);

    return bp - buf;
} 

    
/*
 * Compare "file1" to "file2". Return non-zero if they don't compare exactly.
 * If FILE1 and FILE2 are special files, compare their salient characteristics
 * (i.e. major/minor device numbers, links, etc.
 */
int
xcmp (file1, file2)
    const char *file1;
    const char *file2;
{
    char *buf1, *buf2;
    struct stat sb1, sb2;
    int fd1, fd2;
    int ret;

    if (CVS_LSTAT (file1, &sb1) < 0)
	error (1, errno, "cannot lstat %s", file1);
    if (CVS_LSTAT (file2, &sb2) < 0)
	error (1, errno, "cannot lstat %s", file2);

    /* If FILE1 and FILE2 are not the same file type, they are unequal. */
    if ((sb1.st_mode & S_IFMT) != (sb2.st_mode & S_IFMT))
	return 1;

    /* If FILE1 and FILE2 are symlinks, they are equal if they point to
       the same thing. */
    if (S_ISLNK (sb1.st_mode) && S_ISLNK (sb2.st_mode))
    {
	int result;
	buf1 = xreadlink (file1);
	buf2 = xreadlink (file2);
	result = (strcmp (buf1, buf2) == 0);
	free (buf1);
	free (buf2);
	return result;
    }

    /* If FILE1 and FILE2 are devices, they are equal if their device
       numbers match. */
    if (S_ISBLK (sb1.st_mode) || S_ISCHR (sb1.st_mode))
    {
#ifdef HAVE_ST_RDEV
	if (sb1.st_rdev == sb2.st_rdev)
	    return 0;
	else
	    return 1;
#else
	error (1, 0, "cannot compare device files on this system (%s and %s)",
	       file1, file2);
#endif
    }

    if ((fd1 = open (file1, O_RDONLY)) < 0)
	error (1, errno, "cannot open file %s for comparing", file1);
    if ((fd2 = open (file2, O_RDONLY)) < 0)
	error (1, errno, "cannot open file %s for comparing", file2);

    /* A generic file compare routine might compare st_dev & st_ino here 
       to see if the two files being compared are actually the same file.
       But that won't happen in CVS, so we won't bother. */

    if (sb1.st_size != sb2.st_size)
	ret = 1;
    else if (sb1.st_size == 0)
	ret = 0;
    else
    {
	/* FIXME: compute the optimal buffer size by computing the least
	   common multiple of the files st_blocks field */
	size_t buf_size = 8 * 1024;
	size_t read1;
	size_t read2;

	buf1 = xmalloc (buf_size);
	buf2 = xmalloc (buf_size);

	do 
	{
	    read1 = block_read (fd1, buf1, buf_size);
	    if (read1 == (size_t)-1)
		error (1, errno, "cannot read file %s for comparing", file1);

	    read2 = block_read (fd2, buf2, buf_size);
	    if (read2 == (size_t)-1)
		error (1, errno, "cannot read file %s for comparing", file2);

	    /* assert (read1 == read2); */

	    ret = memcmp(buf1, buf2, read1);
	} while (ret == 0 && read1 == buf_size);

	free (buf1);
	free (buf2);
    }
	
    (void) close (fd1);
    (void) close (fd2);
    return (ret);
}

/* Generate a unique temporary filename.  Returns a pointer to a newly
 * malloc'd string containing the name.  Returns successfully or not at
 * all.
 *
 *     THIS FUNCTION IS DEPRECATED!!!  USE cvs_temp_file INSTEAD!!!
 *
 * and yes, I know about the way the rcs commands use temp files.  I think
 * they should be converted too but I don't have time to look into it right
 * now.
 */
char *
cvs_temp_name ()
{
    char *fn;
    FILE *fp;

    fp = cvs_temp_file (&fn);
    if (fp == NULL)
	error (1, errno, "Failed to create temporary file");
    if (fclose (fp) == EOF)
	error (0, errno, "Failed to close temporary file %s", fn);
    return fn;
}

/* Generate a unique temporary filename and return an open file stream
 * to the truncated file by that name
 *
 *  INPUTS
 *	filename	where to place the pointer to the newly allocated file
 *   			name string
 *
 *  OUTPUTS
 *	filename	dereferenced, will point to the newly allocated file
 *			name string.  This value is undefined if the function
 *			returns an error.
 *
 *  RETURNS
 *	An open file pointer to a read/write mode empty temporary file with the
 *	unique file name or NULL on failure.
 *
 *  ERRORS
 *	on error, errno will be set to some value either by CVS_FOPEN or
 *	whatever system function is called to generate the temporary file name
 */
/* There are at least four functions for generating temporary
 * filenames.  We use mkstemp (BSD 4.3) if possible, else tempnam (SVID 3),
 * else mktemp (BSD 4.3), and as last resort tmpnam (POSIX).  Reason is that
 * mkstemp, tempnam, and mktemp both allow to specify the directory in which
 * the temporary file will be created.
 *
 * And the _correct_ way to use the deprecated functions probably involves
 * opening file descriptors using O_EXCL & O_CREAT and even doing the annoying
 * NFS locking thing, but until I hear of more problems, I'm not going to
 * bother.
 */
FILE *cvs_temp_file (filename)
    char **filename;
{
    char *fn;
    FILE *fp;

    /* FIXME - I'd like to be returning NULL here in noexec mode, but I think
     * some of the rcs & diff functions which rely on a temp file run in
     * noexec mode too.
     */

    assert (filename != NULL);

#ifdef HAVE_MKSTEMP

    {
    int fd;

    fn = xmalloc (strlen (Tmpdir) + 11);
    sprintf (fn, "%s/%s", Tmpdir, "cvsXXXXXX" );
    fd = mkstemp (fn);

    /* a NULL return will be interpreted by callers as an error and
     * errno should still be set
     */
    if (fd == -1) fp = NULL;
    else if ((fp = CVS_FDOPEN (fd, "w+")) == NULL)
    {
	/* attempt to close and unlink the file since mkstemp returned successfully and
	 * we believe it's been created and opened
	 */
 	int save_errno = errno;
	if (close (fd))
	    error (0, errno, "Failed to close temporary file %s", fn);
	if (CVS_UNLINK (fn))
	    error (0, errno, "Failed to unlink temporary file %s", fn);
	errno = save_errno;
    }

    if (fp == NULL) free (fn);
    /* mkstemp is defined to open mode 0600 using glibc 2.0.7+ */
    /* FIXME - configure can probably tell us which version of glibc we are
     * linking to and not chmod for 2.0.7+
     */
    else chmod (fn, 0600);

    }

#elif HAVE_TEMPNAM

    /* tempnam has been deprecated due to under-specification */

    fn = tempnam (Tmpdir, "cvs");
    if (fn == NULL) fp = NULL;
    else if ((fp = CVS_FOPEN (fn, "w+")) == NULL) free (fn);
    else chmod (fn, 0600);

    /* tempnam returns a pointer to a newly malloc'd string, so there's
     * no need for a xstrdup
     */

#elif HAVE_MKTEMP

    /* mktemp has been deprecated due to the BSD 4.3 specification specifying
     * that XXXXXX will be replaced by a PID and a letter, creating only 26
     * possibilities, a security risk, and a race condition.
     */

    {
    char *ifn;

    ifn = xmalloc (strlen (Tmpdir) + 11);
    sprintf (ifn, "%s/%s", Tmpdir, "cvsXXXXXX" );
    fn = mktemp (ifn);

    if (fn == NULL) fp = NULL;
    else fp = CVS_FOPEN (fn, "w+");

    if (fp == NULL) free (ifn);
    else chmod (fn, 0600);

    }

#else	/* use tmpnam if all else fails */

    /* tmpnam is deprecated */

    {
    char ifn[L_tmpnam + 1];

    fn = tmpnam (ifn);

    if (fn == NULL) fp = NULL;
    else if ((fp = CVS_FOPEN (ifn, "w+")) != NULL)
    {
	fn = xstrdup (ifn);
	chmod (fn, 0600);
    }

    }

#endif

    *filename = fn;
    return fp;
}

/* Return non-zero iff FILENAME is absolute.
   Trivial under Unix, but more complicated under other systems.  */
int
isabsolute (filename)
    const char *filename;
{
    return filename[0] == '/';
}

/*
 * Return a string (dynamically allocated) with the name of the file to which
 * LINK is symlinked.
 */
char *
xreadlink (link)
    const char *link;
{
    char *file = NULL;
    char *tfile;
    int buflen = 128;
    int link_name_len;

    if (!islink (link))
	return NULL;

    /* Get the name of the file to which `from' is linked.
       FIXME: what portability issues arise here?  Are readlink &
       ENAMETOOLONG defined on all systems? -twp */
    do
    {
	file = xrealloc (file, buflen);
	link_name_len = readlink (link, file, buflen - 1);
	buflen *= 2;
    }
    while (link_name_len < 0 && errno == ENAMETOOLONG);

    if (link_name_len < 0)
	error (1, errno, "cannot readlink %s", link);

    file[link_name_len] = '\0';

    tfile = xstrdup (file);
    free (file);

    return tfile;
}


/* Return a pointer into PATH's last component.  */
char *
last_component (path)
    char *path;
{
    char *last = strrchr (path, '/');
    
    if (last && (last != path))
        return last + 1;
    else
        return path;
}

/* Return the home directory.  Returns a pointer to storage
   managed by this function or its callees (currently getenv).
   This function will return the same thing every time it is
   called.  Returns NULL if there is no home directory.

   Note that for a pserver server, this may return root's home
   directory.  What typically happens is that upon being started from
   inetd, before switching users, the code in cvsrc.c calls
   get_homedir which remembers root's home directory in the static
   variable.  Then the switch happens and get_homedir might return a
   directory that we don't even have read or execute permissions for
   (which is bad, when various parts of CVS try to read there).  One
   fix would be to make the value returned by get_homedir only good
   until the next call (which would free the old value).  Another fix
   would be to just always malloc our answer, and let the caller free
   it (that is best, because some day we may need to be reentrant).

   The workaround is to put -f in inetd.conf which means that
   get_homedir won't get called until after the switch in user ID.

   The whole concept of a "home directory" on the server is pretty
   iffy, although I suppose some people probably are relying on it for
   .cvsrc and such, in the cases where it works.  */
char *
get_homedir ()
{
    static char *home = NULL;
    char *env;
    struct passwd *pw;

    if (home != NULL)
	return home;

    if (
#ifdef SERVER_SUPPORT
	!server_active &&
#endif
	(env = getenv ("HOME")) != NULL)
	home = env;
    else if ((pw = (struct passwd *) getpwuid (getuid ()))
	     && pw->pw_dir)
	home = xstrdup (pw->pw_dir);
    else
	return 0;

    return home;
}

/* See cvs.h for description.  On unix this does nothing, because the
   shell expands the wildcards.  */
void
expand_wild (argc, argv, pargc, pargv)
    int argc;
    char **argv;
    int *pargc;
    char ***pargv;
{
    int i;
    if (size_overflow_p (xtimes (argc, sizeof (char *)))) {
	*pargc = 0;
	*pargv = NULL;
	error (0, 0, "expand_wild: too many arguments");
	return;
    }
    *pargc = argc;
    *pargv = xmalloc (xtimes (argc, sizeof (char *)));
    for (i = 0; i < argc; ++i)
	(*pargv)[i] = xstrdup (argv[i]);
}

#ifdef SERVER_SUPPORT
/* Case-insensitive string compare.  I know that some systems
   have such a routine, but I'm not sure I see any reasons for
   dealing with the hair of figuring out whether they do (I haven't
   looked into whether this is a performance bottleneck; I would guess
   not).  */
int
cvs_casecmp (str1, str2)
    char *str1;
    char *str2;
{
    char *p;
    char *q;
    int pqdiff;

    p = str1;
    q = str2;
    while ((pqdiff = tolower (*p) - tolower (*q)) == 0)
    {
	if (*p == '\0')
	    return 0;
	++p;
	++q;
    }
    return pqdiff;
}

/* Case-insensitive file open.  As you can see, this is an expensive
   call.  We don't regard it as our main strategy for dealing with
   case-insensitivity.  Returns errno code or 0 for success.  Puts the
   new file in *FP.  NAME and MODE are as for fopen.  If PATHP is not
   NULL, then put a malloc'd string containing the pathname as found
   into *PATHP.  *PATHP is only set if the return value is 0.

   Might be cleaner to separate the file finding (which just gives
   *PATHP) from the file opening (which the caller can do).  For one
   thing, might make it easier to know whether to put NAME or *PATHP
   into error messages.  */
int
fopen_case (name, mode, fp, pathp)
    char *name;
    char *mode;
    FILE **fp;
    char **pathp;
{
    struct dirent *dp;
    DIR *dirp;
    char *dir;
    char *fname;
    char *found_name;
    int retval;

    /* Separate NAME into directory DIR and filename within the directory
       FNAME.  */
    dir = xstrdup (name);
    fname = strrchr (dir, '/');
    if (fname == NULL)
	error (1, 0, "internal error: relative pathname in fopen_case");
    *fname++ = '\0';

    found_name = NULL;
    dirp = CVS_OPENDIR (dir);
    if (dirp == NULL)
    {
	if (existence_error (errno))
	{
	    /* This can happen if we are looking in the Attic and the Attic
	       directory does not exist.  Return the error to the caller;
	       they know what to do with it.  */
	    retval = errno;
	    goto out;
	}
	else
	{
	    /* Give a fatal error; that way the error message can be
	       more specific than if we returned the error to the caller.  */
	    error (1, errno, "cannot read directory %s", dir);
	}
    }
    errno = 0;
    while ((dp = CVS_READDIR (dirp)) != NULL)
    {
	if (cvs_casecmp (dp->d_name, fname) == 0)
	{
	    if (found_name != NULL)
		error (1, 0, "%s is ambiguous; could mean %s or %s",
		       fname, dp->d_name, found_name);
	    found_name = xstrdup (dp->d_name);
	}
    }
    if (errno != 0)
	error (1, errno, "cannot read directory %s", dir);
    CVS_CLOSEDIR (dirp);

    if (found_name == NULL)
    {
	*fp = NULL;
	retval = ENOENT;
    }
    else
    {
	char *p;

	/* Copy the found name back into DIR.  We are assuming that
	   found_name is the same length as fname, which is true as
	   long as the above code is just ignoring case and not other
	   aspects of filename syntax.  */
	p = dir + strlen (dir);
	*p++ = '/';
	strcpy (p, found_name);
	*fp = fopen (dir, mode);
	if (*fp == NULL)
	    retval = errno;
	else
	    retval = 0;
    }

    if (pathp == NULL)
	free (dir);
    else if (retval != 0)
	free (dir);
    else
	*pathp = dir;
    free (found_name);
 out:
    return retval;
}
#endif /* SERVER_SUPPORT */
@


1.2
log
@From Andrushock, s/sucess/success/g
@
text
@d968 6
d975 1
a975 1
    *pargv = (char **) xmalloc (argc * sizeof (char *));
@


1.2.4.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@a967 6
    if (size_overflow_p (xtimes (argc, sizeof (char *)))) {
	*pargc = 0;
	*pargv = NULL;
	error (0, 0, "expand_wild: too many arguments");
	return;
    }
d969 1
a969 1
    *pargv = xmalloc (xtimes (argc, sizeof (char *)));
@


1.2.6.1
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@a967 6
    if (size_overflow_p (xtimes (argc, sizeof (char *)))) {
	*pargc = 0;
	*pargv = NULL;
	error (0, 0, "expand_wild: too many arguments");
	return;
    }
d969 1
a969 1
    *pargv = xmalloc (xtimes (argc, sizeof (char *)));
@


1.1
log
@Initial revision
@
text
@d14 1
a14 5
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
d20 1
a22 13
#ifndef lint
static const char rcsid[] = "$CVSid:$";
USE(rcsid);
#endif

/*
 * I don't know of a convenient way to test this at configure time, or else
 * I'd certainly do it there.
 */
#if defined(NeXT)
#define LOSING_TMPNAM_FUNCTION
#endif

d38 2
a39 6
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> copy(%s,%s)\n",
			(server_active) ? 'S' : ' ', from, to);
#else
	(void) fprintf (stderr, "-> copy(%s,%s)\n", from, to);
#endif
d43 3
a45 7
    if ((fdin = open (from, O_RDONLY)) < 0)
	error (1, errno, "cannot open %s for copying", from);
    if (fstat (fdin, &sb) < 0)
	error (1, errno, "cannot fstat %s", from);
    if ((fdout = creat (to, (int) sb.st_mode & 07777)) < 0)
	error (1, errno, "cannot create %s for copying", to);
    if (sb.st_size > 0)
d47 5
a51 2
	char buf[BUFSIZ];
	int n;
d53 20
a72 1
	for (;;) 
d74 4
a77 2
	    n = read (fdin, buf, sizeof(buf));
	    if (n == -1)
d79 3
d83 2
a84 2
		if (errno == EINTR)
		    continue;
d86 8
a93 1
		error (1, errno, "cannot read file %s for copying", from);
a94 7
            else if (n == 0) 
		break;
  
	    if (write(fdout, buf, n) != n) {
		error (1, errno, "cannot write file %s for copying", to);
	    }
	}
d97 2
a98 2
	if (fsync (fdout)) 
	    error (1, errno, "cannot fsync file %s after copying", to);
d100 6
a107 5
    if (close (fdin) < 0) 
	error (0, errno, "cannot close %s", from);
    if (close (fdout) < 0)
	error (1, errno, "cannot close %s", to);

d143 1
a143 1
    if (lstat (file, &sb) < 0)
d152 2
a153 1
 * Returns non-zero if the argument file exists.
d156 1
a156 1
isfile (file)
d161 1
a161 1
    if (stat (file, &sb) < 0)
d163 19
a181 1
    return (1);
a185 1
 * XXX - must be careful if "cvs" is ever made setuid!
d191 1
a191 1
    return (access (file, R_OK) != -1);
d195 1
a195 2
 * Returns non-zero if the argument file is writable
 * XXX - muct be careful if "cvs" is ever made setuid!
d201 62
a262 1
    return (access (file, W_OK) != -1);
d287 1
a287 1
    struct stat buf;
d289 1
a289 1
    if (stat (name, &buf) == 0 && (!S_ISDIR (buf.st_mode)))
d310 1
a310 1
    if (errno != ENOENT)
d325 17
d344 4
a347 2
 * all write permissions.  Adding write permissions honors the current umask
 * setting.
d357 3
d366 2
d370 4
a373 5
	oumask = umask (0);
	(void) umask (oumask);
	mode = sb.st_mode | ~oumask & (((sb.st_mode & S_IRUSR) ? S_IWUSR : 0) |
				       ((sb.st_mode & S_IRGRP) ? S_IWGRP : 0) |
				       ((sb.st_mode & S_IROTH) ? S_IWOTH : 0));
d377 1
a377 1
	mode = sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH);
d381 3
a383 6
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> chmod(%s,%o)\n",
			(server_active) ? 'S' : ' ', fname, mode);
#else
	(void) fprintf (stderr, "-> chmod(%s,%o)\n", fname, mode);
#endif
d400 2
a401 6
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> rename(%s,%s)\n",
			(server_active) ? 'S' : ' ', from, to);
#else
	(void) fprintf (stderr, "-> rename(%s,%s)\n", from, to);
#endif
a409 21
 * link a file, if possible.
 */
int
link_file (from, to)
    const char *from;
    const char *to;
{
    if (trace)
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> link(%s,%s)\n",
			(server_active) ? 'S' : ' ', from, to);
#else
	(void) fprintf (stderr, "-> link(%s,%s)\n", from, to);
#endif
    if (noexec)
	return (0);

    return (link (from, to));
}

/*
d417 2
a418 6
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> unlink(%s)\n",
			(server_active) ? 'S' : ' ', f);
#else
	(void) fprintf (stderr, "-> unlink(%s)\n", f);
#endif
d422 1
a422 1
    return (unlink (f));
d434 3
a436 1
    if (trace)
d438 6
a443 3
	(void) fprintf (stderr, "%c-> unlink_file_dir(%s)\n",
			(server_active) ? 'S' : ' ', f);
#else
d445 1
a445 1
#endif
d449 9
a457 1
    if (unlink (f) != 0)
d459 5
a463 14
	/* under NEXTSTEP errno is set to return EPERM if
	 * the file is a directory,or if the user is not
	 * allowed to read or write to the file.
	 * [This is probably a bug in the O/S]
	 * other systems will return EISDIR to indicate
	 * that the path is a directory.
	 */
        if (errno == EISDIR || errno == EPERM)
                return deep_remove_dir (f);
        else
		/* The file wasn't a directory and some other
		 * error occured
		 */
                return -1;
d465 4
a468 2
    /* We were able to remove the file from the disk */
    return 0;
a480 1
    char	   buf[PATH_MAX];
d482 1
a482 1
    if ( rmdir (path) != 0 && errno == ENOTEMPTY )
d484 17
a500 5
	if ((dirp = opendir (path)) == NULL)
	    /* If unable to open the directory return
	     * an error
	     */
	    return -1;
d502 3
a504 5
	while ((dp = readdir (dirp)) != NULL)
	{
	    if (strcmp (dp->d_name, ".") == 0 ||
			strcmp (dp->d_name, "..") == 0)
		continue;
d506 2
a507 1
	    sprintf (buf, "%s/%s", path, dp->d_name);
d509 4
a512 3
	    if (unlink (buf) != 0 )
	    {
		if (errno == EISDIR || errno == EPERM)
d514 1
a514 1
		    if (deep_remove_dir (buf))
d516 2
a517 1
			closedir (dirp);
d523 6
a528 5
		    /* buf isn't a directory, or there are
		     * some sort of permision problems
		     */
		    closedir (dirp);
		    return -1;
d530 10
d541 2
d544 2
a545 2
	closedir (dirp);
	return rmdir (path);
d547 1
d589 2
d602 37
a642 4
    if (fstat (fd1, &sb1) < 0)
	error (1, errno, "cannot fstat %s", file1);
    if (fstat (fd2, &sb2) < 0)
	error (1, errno, "cannot fstat %s", file2);
d686 16
d703 41
a743 2
#ifdef LOSING_TMPNAM_FUNCTION
char *tmpnam(char *s)
d745 42
a786 1
    static char value[L_tmpnam+1];
a787 8
    if (s){
       strcpy(s,"/tmp/cvsXXXXXX");
       mktemp(s);
       return s;
    }else{
       strcpy(value,"/tmp/cvsXXXXXX");
       mktemp(s);
       return value;
d789 58
a847 1
#endif
d858 38
d903 2
a904 2

    if (last)
d909 193
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d154 5
a158 1
    return isaccessible(file, F_OK);
d163 1
d169 1
a169 1
    return isaccessible(file, R_OK);
d173 2
a174 1
 * Returns non-zero if the argument file is writable.
d180 1
a180 62
    return isaccessible(file, W_OK);
}

/*
 * Returns non-zero if the argument file is accessable according to
 * mode.  If compiled with SETXID_SUPPORT also works if cvs has setxid
 * bits set.
 */
int
isaccessible (file, mode)
    const char *file;
    const int mode;
{
#ifdef SETXID_SUPPORT
    struct stat sb;
    int umask = 0;
    int gmask = 0;
    int omask = 0;
    int uid;
    
    if (stat(file, &sb) == -1)
	return 0;
    if (mode == F_OK)
	return 1;

    uid = geteuid();
    if (uid == 0)		/* superuser */
    {
	if (mode & X_OK)
	    return sb.st_mode & (S_IXUSR|S_IXGRP|S_IXOTH);
	else
	    return 1;
    }
	
    if (mode & R_OK)
    {
	umask |= S_IRUSR;
	gmask |= S_IRGRP;
	omask |= S_IROTH;
    }
    if (mode & W_OK)
    {
	umask |= S_IWUSR;
	gmask |= S_IWGRP;
	omask |= S_IWOTH;
    }
    if (mode & X_OK)
    {
	umask |= S_IXUSR;
	gmask |= S_IXGRP;
	omask |= S_IXOTH;
    }

    if (sb.st_uid == uid)
	return (sb.st_mode & umask) == umask;
    else if (sb.st_gid == getegid())
	return (sb.st_mode & gmask) == gmask;
    else
	return (sb.st_mode & omask) == omask;
#else
    return access(file, mode) == 0;
#endif
d205 1
a205 1
    struct stat sb;
d207 1
a207 1
    if (stat (name, &sb) == 0 && (!S_ISDIR (sb.st_mode)))
d228 1
a228 1
    if (! existence_error (errno))
d245 2
a246 1
 * all write permissions.  Either change honors the current umask setting.
a261 2
    oumask = umask (0);
    (void) umask (oumask);
d264 5
a268 4
	mode = sb.st_mode | (~oumask
			     & (((sb.st_mode & S_IRUSR) ? S_IWUSR : 0)
				| ((sb.st_mode & S_IRGRP) ? S_IWGRP : 0)
				| ((sb.st_mode & S_IROTH) ? S_IWOTH : 0)));
d272 1
a272 1
	mode = sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH) & ~oumask;
d312 1
a312 3
 * link a file, if possible.  Warning: the Windows NT version of this
 * function just copies the file, so only use this function in ways
 * that can deal with either a link or a copy.
d404 1
a404 1
    if (rmdir (path) != 0 && (errno == ENOTEMPTY || errno == EEXIST)) 
d442 1
a442 2
	}

@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d26 5
a642 8
}

/* Return the home directory.  Returns a pointer to storage
   managed by this function or its callees (currently getenv).  */
char *
get_homedir ()
{
    return getenv ("HOME");
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d328 1
a328 2
			(server_active) ? 'S' : ' ', fname,
			(unsigned int) mode);
d330 1
a330 2
	(void) fprintf (stderr, "-> chmod(%s,%o)\n", fname,
			(unsigned int) mode);
d423 1
a423 11
    /* For at least some unices, if root tries to unlink() a directory,
       instead of doing something rational like returning EISDIR,
       the system will gleefully go ahead and corrupt the filesystem.
       So we first call isdir() to see if it is OK to call unlink().  This
       doesn't quite work--if someone creates a directory between the
       call to isdir() and the call to unlink(), we'll still corrupt
       the filesystem.  Where is the Unix Haters Handbook when you need
       it?  */
    if (isdir(f)) 
	return deep_remove_dir(f);
    else
d425 14
a438 2
	if (unlink (f) != 0)
	    return -1;
d472 1
a472 4
	    /* See comment in unlink_file_dir explanation of why we use
	       isdir instead of just calling unlink and checking the
	       status.  */
	    if (isdir(buf)) 
d474 1
a474 1
		if (deep_remove_dir(buf))
d476 5
a480 2
		    closedir(dirp);
		    return -1;
d482 1
a482 4
	    }
	    else
	    {
		if (unlink (buf) != 0)
d484 4
a487 1
		    closedir(dirp);
a645 16
}

/* See cvs.h for description.  On unix this does nothing, because the
   shell expands the wildcards.  */
void
expand_wild (argc, argv, pargc, pargv)
    int argc;
    char **argv;
    int *pargc;
    char ***pargv;
{
    int i;
    *pargc = argc;
    *pargv = (char **) xmalloc (argc * sizeof (char *));
    for (i = 0; i < argc; ++i)
	(*pargv)[i] = xstrdup (argv[i]);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a292 16
/* Create directory NAME if it does not already exist; fatal error for
   other errors.  Returns 0 if directory was created; 1 if it already
   existed.  */
int
mkdir_if_needed (name)
    char *name;
{
    if (mkdir (name, 0777) < 0)
    {
	if (errno != EEXIST)
	    error (1, errno, "cannot make directory %s", name);
	return 1;
    }
    return 0;
}

a598 5

/* Just in case this implementation does not define this.  */
#ifndef L_tmpnam
#define	L_tmpnam 50
#endif
d601 1
a601 2
char *
cvs_temp_name ()
d603 1
a603 1
    char value[L_tmpnam + 1];
d605 9
a613 4
    /* FIXME: Should be using TMPDIR.  */
    strcpy (value, "/tmp/cvsXXXXXX");
    mktemp (value);
    return xstrdup (value);
d615 1
a615 9
#else
/* Generate a unique temporary filename.  Returns a pointer to a newly
   malloc'd string containing the name.  Returns successfully or not at
   all.  */
char *
cvs_temp_name ()
{
    char value[L_tmpnam + 1];
    char *retval;
a616 9
    /* FIXME: should be using TMPDIR, perhaps by using tempnam on systems
       which have it.  */
    retval = tmpnam (value);
    if (retval == NULL)
	error (1, errno, "cannot generate temporary filename");
    return xstrdup (retval);
}
#endif

d645 1
a645 13
    static char home[PATH_MAX];
    char *env = getenv ("HOME");
    struct passwd *pw;

    if (env)
	strcpy (home, env);
    else if ((pw = (struct passwd *) getpwuid (getuid ()))
	     && pw->pw_dir)
	strcpy (home, pw->pw_dir);
    else
	return 0;

    return home;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d14 5
a18 1
   GNU General Public License for more details.  */
d472 1
a472 1
    if (rmdir (path) != 0)
d474 7
a480 6
	if (errno == ENOTEMPTY
	    || errno == EEXIST
	    /* Ugly workaround for ugly AIX 4.1 (and 3.2) header bug
	       (it defines ENOTEMPTY and EEXIST to 17 but actually
	       returns 87).  */
	    || (ENOTEMPTY == 17 && EEXIST == 17 && errno == 87))
d482 3
a484 5
	    if ((dirp = opendir (path)) == NULL)
		/* If unable to open the directory return
		 * an error
		 */
		return -1;
d486 6
a491 1
	    while ((dp = readdir (dirp)) != NULL)
d493 1
a493 10
		if (strcmp (dp->d_name, ".") == 0 ||
			    strcmp (dp->d_name, "..") == 0)
		    continue;

		sprintf (buf, "%s/%s", path, dp->d_name);

		/* See comment in unlink_file_dir explanation of why we use
		   isdir instead of just calling unlink and checking the
		   status.  */
		if (isdir(buf)) 
d495 2
a496 5
		    if (deep_remove_dir(buf))
		    {
			closedir(dirp);
			return -1;
		    }
d498 4
a501 1
		else
d503 2
a504 5
		    if (unlink (buf) != 0)
		    {
			closedir(dirp);
			return -1;
		    }
a506 2
	    closedir (dirp);
	    return rmdir (path);
d508 3
a510 3
	else
	    return -1;
    }
d675 1
a675 3
   managed by this function or its callees (currently getenv).
   This function will return the same thing every time it is
   called.  */
d679 1
a679 1
    static char *home = NULL;
a682 3
    if (home != NULL)
	return home;

d684 1
a684 1
	home = env;
d687 1
a687 1
	home = xstrdup (pw->pw_dir);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d466 1
a484 2
		char *buf;

a488 1
		buf = xmalloc (strlen (path) + strlen (dp->d_name) + 5);
a498 1
			free (buf);
a506 1
			free (buf);
a509 1
		free (buf);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a724 113

#ifdef SERVER_SUPPORT
/* Case-insensitive string compare.  I know that some systems
   have such a routine, but I'm not sure I see any reasons for
   dealing with the hair of figuring out whether they do (I haven't
   looked into whether this is a performance bottleneck; I would guess
   not).  */
int
cvs_casecmp (str1, str2)
    char *str1;
    char *str2;
{
    char *p;
    char *q;
    int pqdiff;

    p = str1;
    q = str2;
    while ((pqdiff = tolower (*p) - tolower (*q)) == 0)
    {
	if (*p == '\0')
	    return 0;
	++p;
	++q;
    }
    return pqdiff;
}

/* Case-insensitive file open.  As you can see, this is an expensive
   call.  We don't regard it as our main strategy for dealing with
   case-insensitivity.  Returns errno code or 0 for success.  Puts the
   new file in *FP.  NAME and MODE are as for fopen.  If PATHP is not
   NULL, then put a malloc'd string containing the pathname as found
   into *PATHP.  Note that a malloc'd string is put into *PATHP
   even if we return an error.  It doesn't mean anything, but it still
   must be freed.

   Might be cleaner to separate the file finding (which just gives
   *PATHP) from the file opening (which the caller can do).  For one
   thing, might make it easier to know whether to put NAME or *PATHP
   into error messages.  */
int
fopen_case (name, mode, fp, pathp)
    char *name;
    char *mode;
    FILE **fp;
    char **pathp;
{
    struct dirent *dp;
    DIR *dirp;
    char *dir;
    char *fname;
    char *found_name;
    int retval;

    /* Separate NAME into directory DIR and filename within the directory
       FNAME.  */
    dir = xstrdup (name);
    fname = strrchr (dir, '/');
    if (fname == NULL)
	error (1, 0, "internal error: relative pathname in fopen_case");
    *fname++ = '\0';

    found_name = NULL;
    dirp = CVS_OPENDIR (dir);
    if (dirp == NULL)
	error (1, errno, "cannot read directory %s", dir);
    errno = 0;
    while ((dp = readdir (dirp)) != NULL)
    {
	if (cvs_casecmp (dp->d_name, fname) == 0)
	{
	    if (found_name != NULL)
		error (1, 0, "%s is ambiguous; could mean %s or %s",
		       fname, dp->d_name, found_name);
	    found_name = xstrdup (dp->d_name);
	}
    }
    if (errno != 0)
	error (1, errno, "cannot read directory %s", dir);
    closedir (dirp);

    if (found_name == NULL)
    {
	*fp = NULL;
	retval = ENOENT;
    }
    else
    {
	char *p;

	/* Copy the found name back into DIR.  We are assuming that
	   found_name is the same length as fname, which is true as
	   long as the above code is just ignoring case and not other
	   aspects of filename syntax.  */
	p = dir + strlen (dir);
	*p++ = '/';
	strcpy (p, found_name);
	*fp = fopen (dir, mode);
	if (*fp == NULL)
	    retval = errno;
	else
	    retval = 0;
    }

    if (pathp == NULL)
	free (dir);
    else
	*pathp = dir;
    free (found_name);
    return retval;
}
#endif /* SERVER_SUPPORT */
@


1.1.1.9
log
@Latest release from Cyclic Software
@
text
@d758 3
a760 1
   into *PATHP.  *PATHP is only set if the return value is 0.
d791 1
a791 16
    {
	if (existence_error (errno))
	{
	    /* This can happen if we are looking in the Attic and the Attic
	       directory does not exist.  Return the error to the caller;
	       they know what to do with it.  */
	    retval = errno;
	    goto out;
	}
	else
	{
	    /* Give a fatal error; that way the error message can be
	       more specific than if we returned the error to the caller.  */
	    error (1, errno, "cannot read directory %s", dir);
	}
    }
a831 2
    else if (retval != 0)
	free (dir);
a834 1
 out:
@


1.1.1.10
log
@Latest version from Cyclic Software
@
text
@d22 8
d627 6
a632 9
/* Generate a unique temporary filename.  Returns a pointer to a newly
   malloc'd string containing the name.  Returns successfully or not at
   all.  */
/* There are at least three functions for generating temporary
   filenames.  We use tempnam (SVID 3) if possible, else mktemp (BSD
   4.3), and as last resort tmpnam (POSIX). Reason is that tempnam and
   mktemp both allow to specify the directory in which the temporary
   file will be created.  */
#ifdef HAVE_TEMPNAM
d636 1
a636 1
    char *retval;
d638 4
a641 6
    retval = tempnam (Tmpdir, "cvs");
    if (retval == NULL)
	error (1, errno, "cannot generate temporary filename");
    /* tempnam returns a pointer to a newly malloc'd string, so there's
       no need for a xstrdup  */
    return retval;
d644 3
a649 12
#  ifdef HAVE_MKTEMP
    char *value;
    char *retval;

    value = xmalloc (strlen (Tmpdir) + 40);
    sprintf (value, "%s/%s", Tmpdir, "cvsXXXXXX" );
    retval = mktemp (value);

    if (retval == NULL)
	error (1, errno, "cannot generate temporary filename");
    return value;
#  else
d653 2
d658 1
a658 2
    return xstrdup (value);
#  endif
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d290 1
a290 2
	if (!(errno == EEXIST
	      || (errno == EACCES && isdir (name))))
d419 1
a419 1
    if (trace
d421 4
a424 4
	/* This is called by the server parent process in contexts where
	   it is not OK to send output (e.g. after we sent "ok" to the
	   client).  */
	&& !server_active
a425 3
	)
	(void) fprintf (stderr, "-> unlink_file_dir(%s)\n", f);

d693 1
a693 20
   called.  Returns NULL if there is no home directory.

   Note that for a pserver server, this may return root's home
   directory.  What typically happens is that upon being started from
   inetd, before switching users, the code in cvsrc.c calls
   get_homedir which remembers root's home directory in the static
   variable.  Then the switch happens and get_homedir might return a
   directory that we don't even have read or execute permissions for
   (which is bad, when various parts of CVS try to read there).  One
   fix would be to make the value returned by get_homedir only good
   until the next call (which would free the old value).  Another fix
   would be to just always malloc our answer, and let the caller free
   it (that is best, because some day we may need to be reentrant).

   The workaround is to put -f in inetd.conf which means that
   get_homedir won't get called until after the switch in user ID.

   The whole concept of a "home directory" on the server is pretty
   iffy, although I suppose some people probably are relying on it for
   .cvsrc and such, in the cases where it works.  */
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d46 10
a55 9
    /* If the file to be copied is a link or a device, then just create
       the new link or device appropriately. */
    if (islink (from))
    {
	char *source = xreadlink (from);
	symlink (source, to);
	free (source);
	return;
    }
d57 1
a57 16
    if (isdevice (from))
    {
	if (stat (from, &sb) < 0)
	    error (1, errno, "cannot stat %s", from);
	mknod (to, sb.st_mode, sb.st_rdev);
    }
    else
    {
	/* Not a link or a device... probably a regular file. */
	if ((fdin = open (from, O_RDONLY)) < 0)
	    error (1, errno, "cannot open %s for copying", from);
	if (fstat (fdin, &sb) < 0)
	    error (1, errno, "cannot fstat %s", from);
	if ((fdout = creat (to, (int) sb.st_mode & 07777)) < 0)
	    error (1, errno, "cannot create %s for copying", to);
	if (sb.st_size > 0)
d59 2
a60 4
	    char buf[BUFSIZ];
	    int n;
	    
	    for (;;) 
a61 3
		n = read (fdin, buf, sizeof(buf));
		if (n == -1)
		{
d63 2
a64 2
		    if (errno == EINTR)
			continue;
d66 7
a72 8
		    error (1, errno, "cannot read file %s for copying", from);
		}
		else if (n == 0) 
		    break;
		
		if (write(fdout, buf, n) != n) {
		    error (1, errno, "cannot write file %s for copying", to);
		}
d74 1
d77 2
a78 2
	    if (fsync (fdout)) 
		error (1, errno, "cannot fsync file %s after copying", to);
d80 1
a80 1
	}
d82 4
a85 5
	if (close (fdin) < 0) 
	    error (0, errno, "cannot close %s", from);
	if (close (fdout) < 0)
	    error (1, errno, "cannot close %s", to);
    }
d122 1
a122 1
    if (CVS_LSTAT (file, &sb) < 0)
a130 23
 * Returns non-zero if the argument file is a block or
 * character special device.
 */
int
isdevice (file)
    const char *file;
{
    struct stat sb;

    if (CVS_LSTAT (file, &sb) < 0)
	return (0);
#ifdef S_ISBLK
    if (S_ISBLK (sb.st_mode))
	return 1;
#endif
#ifdef S_ISCHR
    if (S_ISCHR (sb.st_mode))
	return 1;
#endif
    return 0;
}

/*
a300 3
 *
 * Don't do anything if PreservePermissions is set to `yes'.  This may
 * have unexpected consequences for some uses of xchmod.
a309 3
    if (preserve_perms)
	return;

a419 2
    struct stat sb;

d436 1
a436 1
       So we first call stat() to see if it is OK to call unlink().  This
d438 1
a438 1
       call to stat() and the call to unlink(), we'll still corrupt
d441 3
a443 1
    if (stat (f, &sb) < 0)
d445 1
a445 3
	if (existence_error (errno))
	{
	    /* The file or directory doesn't exist anyhow.  */
a446 1
	}
d448 2
a449 4
    else if (S_ISDIR (sb.st_mode))
	return deep_remove_dir (f);

    return unlink (f);
a559 2
 * If FILE1 and FILE2 are special files, compare their salient characteristics
 * (i.e. major/minor device numbers, links, etc.
a570 32
    if (CVS_LSTAT (file1, &sb1) < 0)
	error (1, errno, "cannot lstat %s", file1);
    if (CVS_LSTAT (file2, &sb2) < 0)
	error (1, errno, "cannot lstat %s", file2);

    /* If FILE1 and FILE2 are not the same file type, they are unequal. */
    if ((sb1.st_mode & S_IFMT) != (sb2.st_mode & S_IFMT))
	return 1;

    /* If FILE1 and FILE2 are symlinks, they are equal if they point to
       the same thing. */
    if (S_ISLNK (sb1.st_mode) && S_ISLNK (sb2.st_mode))
    {
	int result;
	buf1 = xreadlink (file1);
	buf2 = xreadlink (file2);
	result = (strcmp (buf1, buf2) == 0);
	free (buf1);
	free (buf2);
	return result;
    }

    /* If FILE1 and FILE2 are devices, they are equal if their device
       numbers match. */
    if (S_ISBLK (sb1.st_mode) || S_ISCHR (sb1.st_mode))
    {
	if (sb1.st_rdev == sb2.st_rdev)
	    return 0;
	else
	    return 1;
    }

d575 4
a679 33
/*
 * Return a string (dynamically allocated) with the name of the file to which
 * LINK is symlinked.
 */
char *
xreadlink (link)
    const char *link;
{
    char *file = NULL;
    int buflen = BUFSIZ;

    if (!islink (link))
	return NULL;

    /* Get the name of the file to which `from' is linked.
       FIXME: what portability issues arise here?  Are readlink &
       ENAMETOOLONG defined on all systems? -twp */
    do
    {
	file = xrealloc (file, buflen);
	errno = 0;
	readlink (link, file, buflen);
	buflen *= 2;
    }
    while (errno == ENAMETOOLONG);

    if (errno)
	error (1, errno, "cannot readlink %s", link);

    return file;
}


d687 2
a688 2
    
    if (last && (last != path))
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@d418 23
d773 1
a773 3
    char *tfile;
    int buflen = 128;
    int link_name_len;
d784 2
a785 1
	link_name_len = readlink (link, file, buflen - 1);
d788 1
a788 1
    while (link_name_len < 0 && errno == ENAMETOOLONG);
d790 1
a790 1
    if (link_name_len < 0)
d793 2
a794 1
    file[link_name_len] = '\0';
a795 5
    tfile = xstrdup (file);
    free (file);

    return tfile;
}
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d37 6
a42 2
	(void) fprintf (stderr, "%s-> copy(%s,%s)\n",
			CLIENT_SERVER_STR, from, to);
d380 3
a382 2
	(void) fprintf (stderr, "%s-> chmod(%s,%o)\n",
			CLIENT_SERVER_STR, fname,
d384 4
d404 6
a409 2
	(void) fprintf (stderr, "%s-> rename(%s,%s)\n",
			CLIENT_SERVER_STR, from, to);
d425 6
a430 2
	(void) fprintf (stderr, "%s-> unlink(%s)\n",
			CLIENT_SERVER_STR, f);
a508 1
	    errno = 0;
a541 9

		errno = 0;
	    }
	    if (errno != 0)
	    {
		int save_errno = errno;
		closedir (dirp);
		errno = save_errno;
		return -1;
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@a53 1
#if defined(HAVE_MKNOD) && defined(HAVE_ST_RDEV)
a56 3
#else
	error (1, 0, "cannot copy device files on this system (%s)", from);
#endif
a622 1
#ifdef HAVE_ST_RDEV
a626 4
#else
	error (1, 0, "cannot compare device files on this system (%s and %s)",
	       file1, file2);
#endif
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@a19 1
#include <assert.h>
d416 1
a416 1
	(void) fprintf (stderr, "%s-> unlink_file(%s)\n",
d421 1
a421 1
    return (CVS_UNLINK (f));
d467 1
a467 1
    return CVS_UNLINK (f);
d490 1
a490 1
	    if ((dirp = CVS_OPENDIR (path)) == NULL)
d497 1
a497 1
	    while ((dp = CVS_READDIR (dirp)) != NULL)
d515 1
a515 1
			CVS_CLOSEDIR(dirp);
d522 1
a522 1
		    if (CVS_UNLINK (buf) != 0)
d524 1
a524 1
			CVS_CLOSEDIR(dirp);
d536 1
a536 1
		CVS_CLOSEDIR (dirp);
d540 1
a540 1
	    CVS_CLOSEDIR (dirp);
d687 8
a694 9
 * malloc'd string containing the name.  Returns successfully or not at
 * all.
 *
 *     THIS FUNCTION IS DEPRECATED!!!  USE cvs_temp_file INSTEAD!!!
 *
 * and yes, I know about the way the rcs commands use temp files.  I think
 * they should be converted too but I don't have time to look into it right
 * now.
 */
d698 1
a698 2
    char *fn;
    FILE *fp;
d700 6
a705 6
    fp = cvs_temp_file (&fn);
    if (fp == NULL)
	error (1, errno, "Failed to create temporary file");
    if (fclose (fp) == EOF)
	error (0, errno, "Failed to close temporary file %s", fn);
    return fn;
d707 3
a709 34

/* Generate a unique temporary filename and return an open file stream
 * to the truncated file by that name
 *
 *  INPUTS
 *	filename	where to place the pointer to the newly allocated file
 *   			name string
 *
 *  OUTPUTS
 *	filename	dereferenced, will point to the newly allocated file
 *			name string.  This value is undefined if the function
 *			returns an error.
 *
 *  RETURNS
 *	An open file pointer to a read/write mode empty temporary file with the
 *	unique file name or NULL on failure.
 *
 *  ERRORS
 *	on error, errno will be set to some value either by CVS_FOPEN or
 *	whatever system function is called to generate the temporary file name
 */
/* There are at least four functions for generating temporary
 * filenames.  We use mkstemp (BSD 4.3) if possible, else tempnam (SVID 3),
 * else mktemp (BSD 4.3), and as last resort tmpnam (POSIX).  Reason is that
 * mkstemp, tempnam, and mktemp both allow to specify the directory in which
 * the temporary file will be created.
 *
 * And the _correct_ way to use the deprecated functions probably involves
 * opening file descriptors using O_EXCL & O_CREAT and even doing the annoying
 * NFS locking thing, but until I hear of more problems, I'm not going to
 * bother.
 */
FILE *cvs_temp_file (filename)
    char **filename;
d711 21
a731 98
    char *fn;
    FILE *fp;

    /* FIXME - I'd like to be returning NULL here in noexec mode, but I think
     * some of the rcs & diff functions which rely on a temp file run in
     * noexec mode too.
     */

    assert (filename != NULL);

#ifdef HAVE_MKSTEMP

    {
    int fd;

    fn = xmalloc (strlen (Tmpdir) + 11);
    sprintf (fn, "%s/%s", Tmpdir, "cvsXXXXXX" );
    fd = mkstemp (fn);

    /* a NULL return will be interpreted by callers as an error and
     * errno should still be set
     */
    if (fd == -1) fp = NULL;
    else if ((fp = CVS_FDOPEN (fd, "w+")) == NULL)
    {
	/* attempt to close and unlink the file since mkstemp returned sucessfully and
	 * we believe it's been created and opened
	 */
 	int save_errno = errno;
	if (close (fd))
	    error (0, errno, "Failed to close temporary file %s", fn);
	if (CVS_UNLINK (fn))
	    error (0, errno, "Failed to unlink temporary file %s", fn);
	errno = save_errno;
    }

    if (fp == NULL) free (fn);
    /* mkstemp is defined to open mode 0600 using glibc 2.0.7+ */
    /* FIXME - configure can probably tell us which version of glibc we are
     * linking to and not chmod for 2.0.7+
     */
    else chmod (fn, 0600);

    }

#elif HAVE_TEMPNAM

    /* tempnam has been deprecated due to under-specification */

    fn = tempnam (Tmpdir, "cvs");
    if (fn == NULL) fp = NULL;
    else if ((fp = CVS_FOPEN (fn, "w+")) == NULL) free (fn);
    else chmod (fn, 0600);

    /* tempnam returns a pointer to a newly malloc'd string, so there's
     * no need for a xstrdup
     */

#elif HAVE_MKTEMP

    /* mktemp has been deprecated due to the BSD 4.3 specification specifying
     * that XXXXXX will be replaced by a PID and a letter, creating only 26
     * possibilities, a security risk, and a race condition.
     */

    {
    char *ifn;

    ifn = xmalloc (strlen (Tmpdir) + 11);
    sprintf (ifn, "%s/%s", Tmpdir, "cvsXXXXXX" );
    fn = mktemp (ifn);

    if (fn == NULL) fp = NULL;
    else fp = CVS_FOPEN (fn, "w+");

    if (fp == NULL) free (ifn);
    else chmod (fn, 0600);

    }

#else	/* use tmpnam if all else fails */

    /* tmpnam is deprecated */

    {
    char ifn[L_tmpnam + 1];

    fn = tmpnam (ifn);

    if (fn == NULL) fp = NULL;
    else if ((fp = CVS_FOPEN (ifn, "w+")) != NULL)
    {
	fn = xstrdup (ifn);
	chmod (fn, 0600);
    }

    }

d733 1
a733 5

    *filename = fn;
    return fp;
}

d822 1
a822 1
    char *env;
d828 1
a828 5
    if (
#ifdef SERVER_SUPPORT
	!server_active &&
#endif
	(env = getenv ("HOME")) != NULL)
d935 1
a935 1
    while ((dp = CVS_READDIR (dirp)) != NULL)
d947 1
a947 1
    CVS_CLOSEDIR (dirp);
@


