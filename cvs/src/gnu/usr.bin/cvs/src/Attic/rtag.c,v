head	1.2;
access;
symbols
	OPENBSD_2_9:1.1.1.13.0.2
	OPENBSD_2_9_BASE:1.1.1.13
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.1.1.12.0.8
	OPENBSD_2_8_BASE:1.1.1.12
	OPENBSD_2_7:1.1.1.12.0.6
	OPENBSD_2_7_BASE:1.1.1.12
	OPENBSD_2_6:1.1.1.12.0.4
	OPENBSD_2_6_BASE:1.1.1.12
	cvs-1-10-7:1.1.1.12
	OPENBSD_2_5:1.1.1.12.0.2
	OPENBSD_2_5_BASE:1.1.1.12
	cvs-1-10-5:1.1.1.12
	OPENBSD_2_4:1.1.1.11.0.2
	OPENBSD_2_4_BASE:1.1.1.11
	cvs-1-10:1.1.1.11
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2001.09.28.23.26.33;	author tholo;	state dead;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.26;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.14;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.58;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.52;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.49;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.24;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.49;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.56;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.32;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.08.22.20.53.54;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.02.28.21.33.30;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.02.10.18.57.46;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge local changes; work in progress
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Rtag
 * 
 * Add or delete a symbolic name to an RCS file, or a collection of RCS files.
 * Uses the modules database, if necessary.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)rtag.c 1.61 94/09/30 $";
USE(rcsid);
#endif

static int check_fileproc PROTO((char *file, char *update_dir,
     			 char *repository, List * entries,
			 List * srcfiles));
static int check_filesdoneproc PROTO((int err, char *repos, char *update_dir));
static int pretag_proc PROTO((char *repository, char *filter));
static void masterlist_delproc PROTO((Node *p));
static void tag_delproc PROTO((Node *p));
static int pretag_list_proc PROTO((Node *p, void *closure));

static Dtype rtag_dirproc PROTO((char *dir, char *repos, char *update_dir));
static int rtag_fileproc PROTO((char *file, char *update_dir,
			  char *repository, List * entries,
			  List * srcfiles));
static int rtag_proc PROTO((int *pargc, char **argv, char *xwhere,
		      char *mwhere, char *mfile, int shorten,
		      int local_specified, char *mname, char *msg));
static int rtag_delete PROTO((RCSNode *rcsfile));


struct tag_info
{
    Ctype status;
    char *rev;
    char *tag;
    char *options;
};

struct master_lists
{
    List *tlist;
};

static List *mtlist;
static List *tlist;

static char *symtag;
static char *numtag;
static int delete;			/* adding a tag by default */
static int attic_too;			/* remove tag from Attic files */
static int branch_mode;			/* make an automagic "branch" tag */
static char *date;
static int local;			/* recursive by default */
static int force_tag_match = 1;		/* force by default */
static int force_tag_move;              /* don't move existing tags by default */

static const char *const rtag_usage[] =
{
    "Usage: %s %s [-aflRnF] [-b] [-d] [-r tag|-D date] tag modules...\n",
    "\t-a\tClear tag from removed files that would not otherwise be tagged.\n",
    "\t-f\tForce a head revision match if tag/date not found.\n",
    "\t-l\tLocal directory only, not recursive\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-n\tNo execution of 'tag program'\n",
    "\t-d\tDelete the given Tag.\n",
    "\t-b\tMake the tag a \"branch\" tag, allowing concurrent development.\n",
    "\t-[rD]\tExisting tag or Date.\n",
    "\t-F\tMove tag if it already exists\n",	
    NULL
};

int
rtag (argc, argv)
    int argc;
    char **argv;
{
    register int i;
    int c;
    DBM *db;
    int run_module_prog = 1;
    int err = 0;

    if (argc == -1)
	usage (rtag_usage);

    optind = 1;
    while ((c = getopt (argc, argv, "FanfQqlRdbr:D:")) != -1)
    {
	switch (c)
	{
	    case 'a':
		attic_too = 1;
		break;
	    case 'n':
		run_module_prog = 0;
		break;
	    case 'Q':
	    case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
#endif
		    error (1, 0,
			   "-q or -Q must be specified before \"%s\"",
			   command_name);
		break;
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'd':
		delete = 1;
		break;
	    case 'f':
		force_tag_match = 0;
		break;
	    case 'b':
		branch_mode = 1;
		break;
	    case 'r':
		numtag = optarg;
		break;
	    case 'D':
		if (date)
		    free (date);
		date = Make_Date (optarg);
		break;
	    case 'F':
		force_tag_move = 1;
		break;
	    case '?':
	    default:
		usage (rtag_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;
    if (argc < 2)
	usage (rtag_usage);
    symtag = argv[0];
    argc--;
    argv++;

    if (date && numtag)
	error (1, 0, "-r and -D options are mutually exclusive");
    if (delete && branch_mode)
	error (0, 0, "warning: -b ignored with -d options");
    RCS_check_tag (symtag);

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	/* We're the client side.  Fire up the remote server.  */
	start_server ();
	
	ign_setup ();

	if (local)
	    send_arg("-l");
	if (delete)
	    send_arg("-d");
	if (branch_mode)
	    send_arg("-b");
	if (force_tag_move)
	    send_arg("-T");
	if (run_module_prog)
	    send_arg("-n");
	if (attic_too)
	    send_arg("-a");

	if (numtag)
	    option_with_arg ("-r", numtag);
	if (date)
	    client_senddate (date);

	send_arg (symtag);

	{
	    int i;
	    for (i = 0; i < argc; ++i)
		send_arg (argv[i]);
	}

	if (fprintf (to_server, "rtag\n") < 0)
	    error (1, errno, "writing to server");
        return get_responses_and_close ();
    }
#endif

    db = open_module ();
    for (i = 0; i < argc; i++)
    {
	/* XXX last arg should be repository, but doesn't make sense here */
	history_write ('T', (delete ? "D" : (numtag ? numtag : 
		       (date ? date : "A"))), symtag, argv[i], "");
	err += do_module (db, argv[i], TAG, delete ? "Untagging" : "Tagging",
			  rtag_proc, (char *) NULL, 0, 0, run_module_prog,
			  symtag);
    }
    close_module (db);
    return (err);
}

/*
 * callback proc for doing the real work of tagging
 */
/* ARGSUSED */
static int
rtag_proc (pargc, argv, xwhere, mwhere, mfile, shorten, local_specified,
	   mname, msg)
    int *pargc;
    char **argv;
    char *xwhere;
    char *mwhere;
    char *mfile;
    int shorten;
    int local_specified;
    char *mname;
    char *msg;
{
    int err = 0;
    int which;
    char repository[PATH_MAX];
    char where[PATH_MAX];

    (void) sprintf (repository, "%s/%s", CVSroot, argv[0]);
    (void) strcpy (where, argv[0]);

    /* if mfile isn't null, we need to set up to do only part of the module */
    if (mfile != NULL)
    {
	char *cp;
	char path[PATH_MAX];

	/* if the portion of the module is a path, put the dir part on repos */
	if ((cp = strrchr (mfile, '/')) != NULL)
	{
	    *cp = '\0';
	    (void) strcat (repository, "/");
	    (void) strcat (repository, mfile);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	    mfile = cp + 1;
	}

	/* take care of the rest */
	(void) sprintf (path, "%s/%s", repository, mfile);
	if (isdir (path))
	{
	    /* directory means repository gets the dir tacked on */
	    (void) strcpy (repository, path);
	    (void) strcat (where, "/");
	    (void) strcat (where, mfile);
	}
	else
	{
	    int i;

	    /* a file means muck argv */
	    for (i = 1; i < *pargc; i++)
		free (argv[i]);
	    argv[1] = xstrdup (mfile);
	    (*pargc) = 2;
	}
    }

    /* chdir to the starting directory */
    if (chdir (repository) < 0)
    {
	error (0, errno, "cannot chdir to %s", repository);
	return (1);
    }

    if (delete || attic_too || (force_tag_match && numtag))
	which = W_REPOS | W_ATTIC;
    else
	which = W_REPOS;

    /* check to make sure they are authorized to tag all the 
       specified files in the repository */

    mtlist = getlist();
    err = start_recursion (check_fileproc, check_filesdoneproc,
                           (Dtype (*) ()) NULL, (int (*) ()) NULL,
                           *pargc - 1, argv + 1, local, which, 0, 1,
                           where, 1, 1);
    
    if (err)
    {
       error (1, 0, "correct the above errors first!");
    }
     
    /* start the recursion processor */
    err = start_recursion (rtag_fileproc, (int (*) ()) NULL, rtag_dirproc,
			   (int (*) ()) NULL, *pargc - 1, argv + 1, local,
			   which, 0, 1, where, 1, 1);

    dellist(&mtlist);

    return (err);
}

/* check file that is to be tagged */
/* All we do here is add it to our list */

static int
check_fileproc(file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List * entries;
    List * srcfiles;
{
    char *xdir;
    Node *p;
    Vers_TS *vers;
    
    if (update_dir[0] == '\0')
	xdir = ".";
    else
	xdir = update_dir;
    if ((p = findnode (mtlist, xdir)) != NULL)
    {
	tlist = ((struct master_lists *) p->data)->tlist;
    }
    else
    {
	struct master_lists *ml;
        
	tlist = getlist ();
	p = getnode ();
	p->key = xstrdup (xdir);
	p->type = UPDATE;
	ml = (struct master_lists *)
	    xmalloc (sizeof (struct master_lists));
	ml->tlist = tlist;
	p->data = (char *) ml;
	p->delproc = masterlist_delproc;
	(void) addnode (mtlist, p);
    }
    /* do tlist */
    p = getnode ();
    p->key = xstrdup (file);
    p->type = UPDATE;
    p->delproc = tag_delproc;
    vers = Version_TS (repository, (char *) NULL, (char *) NULL,
        (char *) NULL, file, 0, 0, entries, srcfiles);
    p->data = RCS_getversion(vers->srcfile, numtag, date, force_tag_match);
    if (p->data != NULL)
    {
        int addit = 1;
        char *oversion;
        
        oversion = RCS_getversion (vers->srcfile, symtag, (char *) NULL, 1);
        if (oversion == NULL) 
        {
            if (delete)
            {
                addit = 0;
            }
        }
        else if (strcmp(oversion, p->data) == 0)
        {
            addit = 0;
        }
        else if (!force_tag_move)
        {
            addit = 0;
        }
        if (oversion != NULL)
        {
            free(oversion);
        }
        if (!addit)
        {
            free(p->data);
            p->data = NULL;
        }
    }
    freevers_ts (&vers);
    (void) addnode (tlist, p);
    return (0);
}
                         
static int
check_filesdoneproc(err, repos, update_dir)
    int err;
    char *repos;
    char *update_dir;
{
    int n;
    Node *p;

    p = findnode(mtlist, update_dir);
    if (p != NULL)
    {
        tlist = ((struct master_lists *) p->data)->tlist;
    }
    else
    {
        tlist = (List *) NULL;
    }
    if ((tlist == NULL) || (tlist->list->next == tlist->list))
    {
        return (err);
    }
    if ((n = Parse_Info(CVSROOTADM_TAGINFO, repos, pretag_proc, 1)) > 0)
    {
        error (0, 0, "Pre-tag check failed");
        err += n;
    }
    return (err);
}

static int
pretag_proc(repository, filter)
    char *repository;
    char *filter;
{
    if (filter[0] == '/')
    {
        char *s, *cp;

        s = xstrdup(filter);
        for (cp=s; *cp; cp++)
        {
            if (isspace(*cp))
            {
                *cp = '\0';
                break;
            }
        }
        if (!isfile(s))
        {
            error (0, errno, "cannot find pre-tag filter '%s'", s);
            free(s);
            return (1);
        }
        free(s);
    }
    run_setup("%s %s %s %s",
              filter,
              symtag,
              delete ? "del" : force_tag_move ? "mov" : "add",
              repository);
    walklist(tlist, pretag_list_proc, NULL);
    return (run_exec(RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL|RUN_REALLY));
}

static void
masterlist_delproc(p)
    Node *p;
{
    struct master_lists *ml;

    ml = (struct master_lists *)p->data;
    dellist(&ml->tlist);
    free(ml);
    return;
}

static void
tag_delproc(p)
    Node *p;
{
    if (p->data != NULL)
    {
        free(p->data);
        p->data = NULL;
    }
    return;
}

static int
pretag_list_proc(p, closure)
    Node *p;
    void *closure;
{
    if (p->data != NULL)
    {
        run_arg(p->key);
        run_arg(p->data);
    }
    return (0);
}

/*
 * Called to tag a particular file, as appropriate with the options that were
 * set above.
 */
/* ARGSUSED */
static int
rtag_fileproc (file, update_dir, repository, entries, srcfiles)
    char *file;
    char *update_dir;
    char *repository;
    List *entries;
    List *srcfiles;
{
    Node *p;
    RCSNode *rcsfile;
    char *version, *rev;
    int retcode = 0;

    /* find the parsed RCS data */
    p = findnode (srcfiles, file);
    if (p == NULL)
	return (1);
    rcsfile = (RCSNode *) p->data;

    /*
     * For tagging an RCS file which is a symbolic link, you'd best be
     * running with RCS 5.6, since it knows how to handle symbolic links
     * correctly without breaking your link!
     */

    if (delete)
	return (rtag_delete (rcsfile));

    /*
     * If we get here, we are adding a tag.  But, if -a was specified, we
     * need to check to see if a -r or -D option was specified.  If neither
     * was specified and the file is in the Attic, remove the tag.
     */
    if (attic_too && (!numtag && !date))
    {
	if ((rcsfile->flags & VALID) && (rcsfile->flags & INATTIC))
	    return (rtag_delete (rcsfile));
    }

    version = RCS_getversion (rcsfile, numtag, date, force_tag_match);
    if (version == NULL)
    {
	/* If -a specified, clean up any old tags */
	if (attic_too)
	    (void) rtag_delete (rcsfile);

	if (!quiet && !force_tag_match)
	{
	    error (0, 0, "cannot find tag `%s' in `%s'",
		   numtag ? numtag : "head", rcsfile->path);
	    return (1);
	}
	return (0);
    }
    if (numtag && isdigit (*numtag) && strcmp (numtag, version) != 0)
    {

	/*
	 * We didn't find a match for the numeric tag that was specified, but
	 * that's OK.  just pass the numeric tag on to rcs, to be tagged as
	 * specified.  Could get here if one tried to tag "1.1.1" and there
	 * was a 1.1.1 branch with some head revision.  In this case, we want
	 * the tag to reference "1.1.1" and not the revision at the head of
	 * the branch.  Use a symbolic tag for that.
	 */
	rev = branch_mode ? RCS_magicrev (rcsfile, version) : numtag;
	retcode = RCS_settag(rcsfile->path, symtag, numtag);
    }
    else
    {
       char *oversion;
       
       /*
	* As an enhancement for the case where a tag is being re-applied to
	* a large body of a module, make one extra call to Version_Number to
	* see if the tag is already set in the RCS file.  If so, check to
	* see if it needs to be moved.  If not, do nothing.  This will
	* likely save a lot of time when simply moving the tag to the
	* "current" head revisions of a module -- which I have found to be a
	* typical tagging operation.
	*/
       rev = branch_mode ? RCS_magicrev (rcsfile, version) : version;
       oversion = RCS_getversion (rcsfile, symtag, (char *) 0, 1);
       if (oversion != NULL)
       {
	  int isbranch = RCS_isbranch (file, symtag, srcfiles);

	  /*
	   * if versions the same and neither old or new are branches don't
	   * have to do anything
	   */
	  if (strcmp (version, oversion) == 0 && !branch_mode && !isbranch)
	  {
	     free (oversion);
	     free (version);
	     return (0);
	  }
	  
	  if (!force_tag_move) {	/* we're NOT going to move the tag */
	     if (update_dir[0])
		(void) printf ("W %s/%s", update_dir, file);
	     else
		(void) printf ("W %s", file);
	     
	     (void) printf (" : %s already exists on %s %s", 
			    symtag, isbranch ? "branch" : "version", oversion);
	     (void) printf (" : NOT MOVING tag to %s %s\n", 
			    branch_mode ? "branch" : "version", rev);
	     free (oversion);
	     free (version);
	     return (0);
	  }
	  free (oversion);
       }
       retcode = RCS_settag(rcsfile->path, symtag, rev);
    }

    if (retcode != 0)
    {
	error (1, retcode == -1 ? errno : 0,
	       "failed to set tag `%s' to revision `%s' in `%s'",
	       symtag, rev, rcsfile->path);
       free (version);
       return (1);
    }
    free (version);
    return (0);
}

/*
 * If -d is specified, "force_tag_match" is set, so that this call to
 * Version_Number() will return a NULL version string if the symbolic
 * tag does not exist in the RCS file.
 * 
 * If the -r flag was used, numtag is set, and we only delete the
 * symtag from files that have numtag.
 * 
 * This is done here because it's MUCH faster than just blindly calling
 * "rcs" to remove the tag... trust me.
 */
static int
rtag_delete (rcsfile)
    RCSNode *rcsfile;
{
    char *version;
    int retcode;

    if (numtag)
    {
	version = RCS_getversion (rcsfile, numtag, (char *) 0, 1);
	if (version == NULL)
	    return (0);
	free (version);
    }

    version = RCS_getversion (rcsfile, symtag, (char *) 0, 1);
    if (version == NULL)
	return (0);
    free (version);

    if ((retcode = RCS_deltag(rcsfile->path, symtag, 1)) != 0)
    {
	if (!quiet)
	    error (0, retcode == -1 ? errno : 0,
		   "failed to remove tag `%s' from `%s'", symtag,
		   rcsfile->path);
	return (1);
    }
    return (0);
}

/*
 * Print a warm fuzzy message
 */
/* ARGSUSED */
static Dtype
rtag_dirproc (dir, repos, update_dir)
    char *dir;
    char *repos;
    char *update_dir;
{
    if (!quiet)
	error (0, 0, "%s %s", delete ? "Untagging" : "Tagging", update_dir);
    return (R_PROCESS);
}



@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a57 1
static int numtag_validated = 0;
d178 1
a178 1
	    send_arg("-F");
d197 2
a198 1
	send_to_server ("rtag\012", 0);
a291 6
    if (numtag != NULL && !numtag_validated)
    {
	tag_check_valid (numtag, *pargc - 1, argv + 1, local, 0, NULL);
	numtag_validated = 1;
    }

d297 1
a297 1
                           (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
d307 2
a308 2
    err = start_recursion (rtag_fileproc, (FILESDONEPROC) NULL, rtag_dirproc,
			   (DIRLEAVEPROC) NULL, *pargc - 1, argv + 1, local,
d361 1
a361 1
    p->data = RCS_getversion(vers->srcfile, numtag, date, force_tag_match, 0);
d367 1
a367 1
        oversion = RCS_getversion (vers->srcfile, symtag, (char *) NULL, 1, 0);
d544 1
a544 1
    version = RCS_getversion (rcsfile, numtag, date, force_tag_match, 0);
d587 1
a587 1
       oversion = RCS_getversion (rcsfile, symtag, (char *) NULL, 1, 0);
d654 1
a654 1
	version = RCS_getversion (rcsfile, numtag, (char *) NULL, 1, 0);
d660 1
a660 1
    version = RCS_getversion (rcsfile, symtag, (char *) NULL, 1, 0);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d16 8
a23 1
static int check_fileproc PROTO((struct file_info *finfo));
d31 3
a33 1
static int rtag_fileproc PROTO((struct file_info *finfo));
d59 1
a59 1
static int delete_flag;			/* adding a tag by default */
d125 1
a125 1
		delete_flag = 1;
d160 1
a160 1
    if (delete_flag && branch_mode)
d174 1
a174 1
	if (delete_flag)
d207 1
a207 1
	history_write ('T', (delete_flag ? "D" : (numtag ? numtag : 
d209 1
a209 1
	err += do_module (db, argv[i], TAG, delete_flag ? "Untagging" : "Tagging",
d287 1
a287 1
    if (delete_flag || attic_too || (force_tag_match && numtag))
d326 6
a331 2
check_fileproc (finfo)
    struct file_info *finfo;
d337 1
a337 1
    if (finfo->update_dir[0] == '\0')
d340 1
a340 1
	xdir = finfo->update_dir;
d362 1
a362 1
    p->key = xstrdup (finfo->file);
d365 2
a366 2
    vers = Version_TS (finfo->repository, (char *) NULL, (char *) NULL,
        (char *) NULL, finfo->file, 0, 0, finfo->entries, finfo->srcfiles);
d376 1
a376 1
            if (delete_flag)
d463 1
a463 1
              delete_flag ? "del" : force_tag_move ? "mov" : "add",
d512 6
a517 2
rtag_fileproc (finfo)
    struct file_info *finfo;
d525 1
a525 1
    p = findnode (finfo->srcfiles, finfo->file);
d536 1
a536 1
    if (delete_flag)
d585 1
a585 1
	* a large body of a module, make one extra call to RCS_getversion to
d596 1
a596 1
	  int isbranch = RCS_isbranch (finfo->file, symtag, finfo->srcfiles);
d610 2
a611 2
	     if (finfo->update_dir[0])
		(void) printf ("W %s/%s", finfo->update_dir, finfo->file);
d613 1
a613 1
		(void) printf ("W %s", finfo->file);
d633 2
a634 4
        if (branch_mode)
	    free (rev);
        free (version);
        return (1);
a635 2
    if (branch_mode)
	free (rev);
d642 1
a642 1
 * RCS_getversion() will return a NULL version string if the symbolic
d693 1
a693 1
	error (0, 0, "%s %s", delete_flag ? "Untagging" : "Tagging", update_dir);
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d353 1
a353 1
        (char *) NULL, finfo->file, 0, 0, finfo->entries, finfo->rcs);
d502 1
d508 2
a509 1
    if ((rcsfile = finfo->rcs) == NULL)
d511 1
d564 1
a564 1
	char *oversion;
d566 25
a590 25
	/*
	 * As an enhancement for the case where a tag is being re-applied to
	 * a large body of a module, make one extra call to RCS_getversion to
	 * see if the tag is already set in the RCS file.  If so, check to
	 * see if it needs to be moved.  If not, do nothing.  This will
	 * likely save a lot of time when simply moving the tag to the
	 * "current" head revisions of a module -- which I have found to be a
	 * typical tagging operation.
	 */
	rev = branch_mode ? RCS_magicrev (rcsfile, version) : version;
	oversion = RCS_getversion (rcsfile, symtag, (char *) NULL, 1, 0);
	if (oversion != NULL)
	{
	    int isbranch = RCS_isbranch (finfo->rcs, symtag);

	    /*
	     * if versions the same and neither old or new are branches don't
	     * have to do anything
	     */
	    if (strcmp (version, oversion) == 0 && !branch_mode && !isbranch)
	    {
		free (oversion);
		free (version);
		return (0);
	    }
d592 17
a608 17
	    if (!force_tag_move)
	    {
		/* we're NOT going to move the tag */
		(void) printf ("W %s", finfo->fullname);

		(void) printf (" : %s already exists on %s %s", 
			       symtag, isbranch ? "branch" : "version",
			       oversion);
		(void) printf (" : NOT MOVING tag to %s %s\n", 
			       branch_mode ? "branch" : "version", rev);
		free (oversion);
		free (version);
		return (0);
	    }
	    free (oversion);
	}
	retcode = RCS_settag(rcsfile->path, symtag, rev);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d16 2
a17 4
static int check_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int check_filesdoneproc PROTO ((void *callerdat, int err,
				       char *repos, char *update_dir,
				       List *entries));
d23 2
a24 7
static Dtype rtag_dirproc PROTO ((void *callerdat, char *dir,
				  char *repos, char *update_dir,
				  List *entries));
static int rtag_fileproc PROTO ((void *callerdat, struct file_info *finfo));
static int rtag_filesdoneproc PROTO ((void *callerdat, int err,
				      char *repos, char *update_dir,
				      List *entries));
d230 1
a230 1
    (void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
d272 1
a272 1
    if ( CVS_CHDIR (repository) < 0)
d294 1
a294 1
                           (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
d296 1
a296 1
                           where, 1);
d304 3
a306 4
    err = start_recursion (rtag_fileproc, rtag_filesdoneproc, rtag_dirproc,
			   (DIRLEAVEPROC) NULL, NULL,
			   *pargc - 1, argv + 1, local,
			   which, 0, 0, where, 1);
d317 1
a317 2
check_fileproc (callerdat, finfo)
    void *callerdat;
d352 3
a354 3
    vers = Version_TS (finfo, NULL, NULL, NULL, 0, 0);
    p->data = RCS_getversion(vers->srcfile, numtag, date, force_tag_match,
			     (int *) NULL);
d360 1
a360 2
        oversion = RCS_getversion (vers->srcfile, symtag, (char *) NULL, 1,
				   (int *) NULL);
d392 1
a392 2
check_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
a395 1
    List *entries;
d499 1
a499 2
rtag_fileproc (callerdat, finfo)
    void *callerdat;
a505 4
    /* Lock the directory if it is not already locked.  We might be
       able to rely on rtag_dirproc for this.  */
    tag_lockdir (finfo->repository);

d530 1
a530 2
    version = RCS_getversion (rcsfile, numtag, date, force_tag_match,
			      (int *) NULL);
d557 1
a557 1
	retcode = RCS_settag(rcsfile, symtag, numtag);
d573 1
a573 2
	oversion = RCS_getversion (rcsfile, symtag, (char *) NULL, 1,
				   (int *) NULL);
d605 1
a605 1
	retcode = RCS_settag(rcsfile, symtag, rev);
d644 1
a644 2
	version = RCS_getversion (rcsfile, numtag, (char *) NULL, 1,
				  (int *) NULL);
d650 1
a650 2
    version = RCS_getversion (rcsfile, symtag, (char *) NULL, 1,
			      (int *) NULL);
d655 1
a655 1
    if ((retcode = RCS_deltag(rcsfile, symtag, 1)) != 0)
a665 15
/* Clear any lock we may hold on the current directory.  */

static int
rtag_filesdoneproc (callerdat, err, repos, update_dir, entries)
    void *callerdat;
    int err;
    char *repos;
    char *update_dir;
    List *entries;
{
    tag_unlockdir ();

    return (err);
}

d671 1
a671 2
rtag_dirproc (callerdat, dir, repos, update_dir, entries)
    void *callerdat;
a674 1
    List *entries;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d521 1
a521 9

    /* It would be nice to provide consistency with respect to
       commits; however CVS lacks the infrastructure to do that (see
       Concurrency in cvs.texinfo and comment in do_recursion).  We
       can and will prevent simultaneous tag operations from
       interfering with each other, by write locking each directory as
       we enter it, and unlocking it as we leave it.  */

    lock_dir_for_write (finfo->repository);
d697 1
a697 1
    Lock_Cleanup ();
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d167 1
a167 1

a169 2
	if (!force_tag_match)
	    send_arg ("-f");
d178 1
a178 1
	if (!run_module_prog)
a231 2
    /* Begin section which is identical to patch_proc--should this
       be abstracted out somehow?  */
d234 2
a235 2
    char *repository;
    char *where;
a236 2
    repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0])
			  + (mfile == NULL ? 0 : strlen (mfile)) + 30);
a237 2
    where = xmalloc (strlen (argv[0]) + (mfile == NULL ? 0 : strlen (mfile))
		     + 10);
d244 1
a244 1
	char *path;
a257 1
	path = xmalloc (strlen (repository) + strlen (mfile) + 5);
a275 1
	free (path);
d278 1
a278 1
    /* cd to the starting repository */
a281 1
	free (repository);
a283 2
    free (repository);
    /* End section which is identical to patch_proc.  */
d315 1
a315 1
    free (where);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d95 1
a95 1
    while ((c = getopt (argc, argv, "+FanfQqlRdbr:D:")) != -1)
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d94 1
a94 1
    optind = 0;
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d75 1
a75 2
    "\t-r rev\tExisting revision/tag.\n",
    "\t-D\tExisting date.\n",
a76 1
    "(Specify the --help global option for a list of other help options)\n",
d209 1
a209 2
	err += do_module (db, argv[i], TAG,
			  delete_flag ? "Untagging" : "Tagging",
d472 5
a476 4
    run_setup (filter);
    run_arg (symtag);
    run_arg (delete_flag ? "del" : force_tag_move ? "mov" : "add");
    run_arg (repository);
a596 2
	if (retcode == 0)
	    RCS_rewrite (rcsfile, NULL, NULL);
d616 1
a616 1
	    int isbranch = RCS_nodeisbranch (finfo->rcs, symtag);
a645 2
	if (retcode == 0)
	    RCS_rewrite (rcsfile, NULL, NULL);
d697 1
a697 1
    if ((retcode = RCS_deltag(rcsfile, symtag)) != 0)
a704 1
    RCS_rewrite (rcsfile, NULL, NULL);
a734 8
    if (ignore_directory (update_dir))
    {
	/* print the warm fuzzy message */
	if (!quiet)
	  error (0, 0, "Ignoring %s", update_dir);
        return R_SKIP_ALL;
    }

d736 1
a736 2
	error (0, 0, "%s %s", delete_flag ? "Untagging" : "Tagging",
	       update_dir);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d480 1
a480 1
    return (run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL));
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d67 1
a67 1
    "Usage: %s %s [-aflRnF] [-b] [-d] [-r rev|-D date] tag modules...\n",
a390 2
		/* Deleting a tag which did not exist is a noop and
		   should not be logged.  */
a393 5
	else if (delete_flag)
	{
	    free (p->data);
	    p->data = xstrdup (oversion);
	}
d461 1
a461 1
            if (isspace ((unsigned char) *cp))
d586 1
a586 3
    if (numtag
	&& isdigit ((unsigned char) *numtag)
	&& strcmp (numtag, version) != 0)
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d32 1
a32 1
static int rtag_proc PROTO((int argc, char **argv, char *xwhere,
d225 1
a225 1
rtag_proc (argc, argv, xwhere, mwhere, mfile, shorten, local_specified,
d227 1
a227 1
    int argc;
a238 1
    char *myargv[2];
d280 7
a286 4
	    myargv[0] = argv[0];
	    myargv[1] = mfile;
	    argc = 2;
	    argv = myargv;
d308 1
a308 1
	tag_check_valid (numtag, argc - 1, argv + 1, local, 0, NULL);
d318 1
a318 1
                           argc - 1, argv + 1, local, which, 0, 1,
d329 1
a329 1
			   argc - 1, argv + 1, local,
@


