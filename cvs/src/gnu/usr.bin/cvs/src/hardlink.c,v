head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.16
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.12
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.8
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.10
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.1.4.0.52
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.50
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.48
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.46
	OPENBSD_5_0:1.1.1.4.0.44
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.42
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.40
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.36
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.38
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.34
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.32
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.30
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.28
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.26
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.24
	OPENBSD_4_0_BASE:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.22
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.20
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.18
	OPENBSD_3_7_BASE:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.16
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.14
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.12
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.10
	OPENBSD_3_3_BASE:1.1.1.4
	OPENBSD_3_2:1.1.1.4.0.8
	OPENBSD_3_2_BASE:1.1.1.4
	OPENBSD_3_1:1.1.1.4.0.6
	OPENBSD_3_1_BASE:1.1.1.4
	OPENBSD_3_0:1.1.1.4.0.4
	OPENBSD_3_0_BASE:1.1.1.4
	cvs-1-11-1p1:1.1.1.4
	OPENBSD_2_9:1.1.1.4.0.2
	OPENBSD_2_9_BASE:1.1.1.4
	cvs-1-11:1.1.1.4
	OPENBSD_2_8:1.1.1.3.0.8
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.6
	OPENBSD_2_7_BASE:1.1.1.3
	OPENBSD_2_6:1.1.1.3.0.4
	OPENBSD_2_6_BASE:1.1.1.3
	cvs-1-10-7:1.1.1.3
	OPENBSD_2_5:1.1.1.3.0.2
	OPENBSD_2_5_BASE:1.1.1.3
	cvs-1-10-5:1.1.1.3
	OPENBSD_2_4:1.1.1.2.0.2
	OPENBSD_2_4_BASE:1.1.1.2
	cvs-1-10:1.1.1.2
	cvs-1-9-28:1.1.1.2
	OPENBSD_2_3:1.1.1.1.0.2
	OPENBSD_2_3_BASE:1.1.1.1
	cvs-1-9-26:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2013.08.08.03.16.13;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	98.03.12.06.58.45;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.03.12.06.58.45;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.07.13.03.53.58;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.02.28.21.32.56;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.02.10.18.57.40;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Prep for big ino_t: cast to unsigned long long and format with %ll or %q

httpd correction and ok kettenis@@
@
text
@/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

/* Collect and manage hardlink info associated with a particular file.  */

#include "cvs.h"
#include "hardlink.h"

/* The structure currently used to manage hardlink info is a list.
   Therefore, most of the functions which manipulate hardlink data
   are walklist procedures.  This is not a very efficient implementation;
   if someone decides to use a real hash table (for instance), then
   much of this code can be rewritten to be a little less arcane.

   Each element of `hardlist' represents an inode.  It is keyed on the
   inode number, and points to a list of files.  This is to make it
   easy to find out what files are linked to a given file FOO: find
   FOO's inode, look it up in hardlist, and retrieve the list of files
   associated with that inode.

   Each file node, in turn, is represented by a `hardlink_info' struct,
   which includes `status' and `links' fields.  The `status' field should
   be used by a procedure like commit_fileproc or update_fileproc to
   record each file's status; that way, after all file links have been
   recorded, CVS can check the linkage of files which are in doubt
   (i.e. T_NEEDS_MERGE files).

   TODO: a diagram of an example hardlist would help here. */

/* TODO: change this to something with a marginal degree of
   efficiency, like maybe a hash table.  Yeah. */

List *hardlist;		/* Record hardlink information for working files */
char *working_dir;	/* The top-level working directory, used for
			   constructing full pathnames. */

/* Return a pointer to FILEPATH's node in the hardlist.  This means
   looking up its inode, retrieving the list of files linked to that
   inode, and then looking up FILE in that list.  If the file doesn't
   seem to exist, return NULL. */
Node *
lookup_file_by_inode (filepath)
    const char *filepath;
{
    char *inodestr, *file;
    struct stat sb;
    Node *hp, *p;

    /* Get file's basename, so that we can stat it. */
    file = strrchr (filepath, '/');
    if (file)
	++file;
    else
	file = (char *) filepath;

    /* inodestr contains the hexadecimal representation of an
       inode, so it requires two bytes of text to represent
       each byte of the inode number. */
    inodestr = (char *) xmalloc (2*sizeof(ino_t) + 1);
    if (stat (file, &sb) < 0)
    {
	if (existence_error (errno))
	{
	    /* The file doesn't exist; we may be doing an update on a
	       file that's been removed.  A nonexistent file has no
	       link information, so return without changing hardlist. */
	    free (inodestr);
	    return NULL;
	}
	error (1, errno, "cannot stat %s", file);
    }

    sprintf (inodestr, "%llx", (unsigned long long) sb.st_ino);

    /* Find out if this inode is already in the hardlist, adding
       a new entry to the list if not. */
    hp = findnode (hardlist, inodestr);
    if (hp == NULL)
    {
	hp = getnode ();
	hp->type = NT_UNKNOWN;
	hp->key = inodestr;
	hp->data = (char *) getlist();
	hp->delproc = dellist;
	(void) addnode (hardlist, hp);
    }
    else
    {
	free (inodestr);
    }

    p = findnode ((List *) hp->data, filepath);
    if (p == NULL)
    {
	p = getnode();
	p->type = NT_UNKNOWN;
	p->key = xstrdup (filepath);
	p->data = NULL;
	(void) addnode ((List *) hp->data, p);
    }

    return p;
}

/* After a file has been checked out, add a node for it to the hardlist
   (if necessary) and mark it as checked out. */
void
update_hardlink_info (file)
    const char *file;
{
    char *path;
    Node *n;
    struct hardlink_info *hlinfo;

    if (file[0] == '/')
    {
	path = xstrdup (file);
    }
    else
    {
	/* file is a relative pathname; assume it's from the current
	   working directory. */
	char *dir = xgetwd();
	path = xmalloc (strlen(dir) + strlen(file) + 2);
	sprintf (path, "%s/%s", dir, file);
	free (dir);
    }

    n = lookup_file_by_inode (path);
    if (n == NULL)
    {
	/* Something is *really* wrong if the file doesn't exist here;
	   update_hardlink_info should be called only when a file has
	   just been checked out to a working directory. */
	error (1, 0, "lost hardlink info for %s", file);
    }

    if (n->data == NULL)
	n->data = (char *) xmalloc (sizeof (struct hardlink_info));
    hlinfo = (struct hardlink_info *) n->data;
    hlinfo->status = T_UPTODATE;
    hlinfo->checked_out = 1;
}

/* Return a List with all the files known to be linked to FILE in
   the working directory.  Used by special_file_mismatch, to determine
   whether it is safe to merge two files.

   FIXME: What is the memory allocation for the return value?  We seem
   to sometimes allocate a new list (getlist() call below) and sometimes
   return an existing list (where we return n->data).  */
List *
list_linked_files_on_disk (file)
    char *file;
{
    char *inodestr, *path;
    struct stat sb;
    Node *n;

    /* If hardlist is NULL, we have not been doing an operation that
       would permit us to know anything about the file's hardlinks
       (cvs update, cvs commit, etc).  Return an empty list. */
    if (hardlist == NULL)
	return getlist();

    /* Get the full pathname of file (assuming the working directory) */
    if (file[0] == '/')
	path = xstrdup (file);
    else
    {
	char *dir = xgetwd();
	path = (char *) xmalloc (strlen(dir) + strlen(file) + 2);
	sprintf (path, "%s/%s", dir, file);
	free (dir);
    }

    /* We do an extra lookup_file here just to make sure that there
       is a node for `path' in the hardlist.  If that were not so,
       comparing the working directory linkage against the repository
       linkage for a file would always fail. */
    (void) lookup_file_by_inode (path);

    if (stat (path, &sb) < 0)
	error (1, errno, "cannot stat %s", file);
    /* inodestr contains the hexadecimal representation of an
       inode, so it requires two bytes of text to represent
       each byte of the inode number. */
    inodestr = (char *) xmalloc (2*sizeof(ino_t) + 1);
    sprintf (inodestr, "%llx", (unsigned long long) sb.st_ino);

    /* Make sure the files linked to this inode are sorted. */
    n = findnode (hardlist, inodestr);
    sortlist ((List *) n->data, fsortcmp);

    free (inodestr);
    return (List *) n->data;
}

/* Compare the files in the `key' fields of two lists, returning 1 if
   the lists are equivalent and 0 otherwise.

   Only the basenames of each file are compared. This is an awful hack
   that exists because list_linked_files_on_disk returns full paths
   and the `hardlinks' structure of a RCSVers node contains only
   basenames.  That in turn is a result of the awful hack that only
   basenames are stored in the RCS file.  If anyone ever solves the
   problem of correctly managing cross-directory hardlinks, this
   function (along with most functions in this file) must be fixed. */
						      
int
compare_linkage_lists (links1, links2)
    List *links1;
    List *links2;
{
    Node *n1, *n2;
    char *p1, *p2;

    sortlist (links1, fsortcmp);
    sortlist (links2, fsortcmp);

    n1 = links1->list->next;
    n2 = links2->list->next;

    while (n1 != links1->list && n2 != links2->list)
    {
	/* Get the basenames of both files. */
	p1 = strrchr (n1->key, '/');
	if (p1 == NULL)
	    p1 = n1->key;
	else
	    ++p1;

	p2 = strrchr (n2->key, '/');
	if (p2 == NULL)
	    p2 = n2->key;
	else
	    ++p2;

	/* Compare the files' basenames. */
	if (strcmp (p1, p2) != 0)
	    return 0;

	n1 = n1->next;
	n2 = n2->next;
    }

    /* At this point we should be at the end of both lists; if not,
       one file has more links than the other, and return 1. */
    return (n1 == links1->list && n2 == links2->list);
}

/* Find a checked-out file in a list of filenames.  Used by RCS_checkout
   when checking out a new hardlinked file, to decide whether this file
   can be linked to any others that already exist.  The return value
   is not currently used. */

int
find_checkedout_proc (node, data)
    Node *node;
    void *data;
{
    Node **uptodate = (Node **) data;
    Node *link;
    char *dir = xgetwd();
    char *path;
    struct hardlink_info *hlinfo;

    /* If we have already found a file, don't do anything. */
    if (*uptodate != NULL)
	return 0;

    /* Look at this file in the hardlist and see whether the checked_out
       field is 1, meaning that it has been checked out during this CVS run. */
    path = (char *)
	xmalloc (strlen (dir) + strlen (node->key) + 2);
    sprintf (path, "%s/%s", dir, node->key);
    link = lookup_file_by_inode (path);
    free (path);
    free (dir);

    if (link == NULL)
    {
	/* We haven't seen this file -- maybe it hasn't been checked
	   out yet at all. */
	return 0;
    }

    hlinfo = (struct hardlink_info *) link->data;
    if (hlinfo->checked_out)
    {
	/* This file has been checked out recently, so it's safe to
           link to it. */
	*uptodate = link;
    }

    return 0;
}

@


1.1
log
@Initial revision
@
text
@a43 90
/* For check_link_proc: list all of the files named in an inode list. */
static int
list_files_proc (node, vstrp)
    Node *node;
    void *vstrp;
{
    char **strp, *file;
    int len;

    /* Get the file's basename.  This is because -- VERY IMPORTANT --
       the `hardlinks' field is presently defined only to include links
       within a directory.  So the hardlinks field might be `foo' or
       `mumble grump flink', but not `foo bar com/baz' or `wham ../bam
       ../thank/you'.  Someday it would be nice to extend this to
       permit cross-directory links, but the issues involved are
       hideous. */

    file = strrchr (node->key, '/');
    if (file)
	++file;
    else
	file = node->key;

    /* Is it safe to cast vstrp to (char **) here, and then play with
       the contents?  I think so, since vstrp will have started out
       a char ** to begin with, so we should not have alignment bugs. */
    strp = (char **) vstrp;
    len = (*strp == NULL ? 0 : strlen (*strp));
    *strp = (char *) xrealloc (*strp, len + strlen (file) + 2);
    if (*strp == NULL)
    {
	error (0, errno, "could not allocate memory");
	return 1;
    }
    if (sprintf (*strp + len, "%s ", file) < 0)
    {
	error (0, errno, "could not compile file list");
	return 1;
    }

    return 0;
}    

/* Set the link field of each hardlink_info node to `data', which is a
   list of linked files. */
static int
set_hardlink_field_proc (node, data)
    Node *node;
    void *data;
{
    struct hardlink_info *hlinfo = (struct hardlink_info *) node->data;
    hlinfo->links = xstrdup ((char *) data);

    return 0;
}

/* For each file being checked in, compile a list of the files linked
   to it, and cache the list in the file's hardlink_info field. */
int
cache_hardlinks_proc (node, data)
    Node *node;
    void *data;
{
    List *inode_links;
    char *p, *linked_files = NULL;
    int err;

    inode_links = (List *) node->data;

    /* inode->data is a list of hardlink_info structures: all the
       files linked to this inode.  We compile a string of each file
       named in this list, in alphabetical order, separated by spaces.
       Then store this string in the `links' field of each
       hardlink_info structure, so that RCS_checkin can easily add
       it to the `hardlinks' field of a new delta node. */

    sortlist (inode_links, fsortcmp);
    err = walklist (inode_links, list_files_proc, &linked_files);
    if (err)
	return err;

    /* Trim trailing whitespace. */
    p = linked_files + strlen(linked_files) - 1;
    while (p > linked_files && isspace (*p))
	*p-- = '\0';

    err = walklist (inode_links, set_hardlink_field_proc, linked_files);
    return err;
}

d66 1
a66 1
    inodestr = (char *) xmalloc (2*sizeof(ino_t)*sizeof(char) + 1);
d69 1
a69 1
	if (errno == ENOENT)
d80 1
a80 1
    sprintf (inodestr, "%lx", (unsigned long) sb.st_ino);
d88 1
a88 1
	hp->type = UNKNOWN;
d103 1
a103 1
	p->type = UNKNOWN;
d131 1
a131 1
	path = xmalloc (sizeof(char) * (strlen(dir) + strlen(file) + 2));
a149 1
    hlinfo->links = NULL;
d152 1
a152 1
/* Return a string listing all the files known to be linked to FILE in
d154 8
a161 4
   whether it is safe to merge two files. */
char *
list_files_linked_to (file)
    const char *file;
d163 1
a163 1
    char *inodestr, *filelist, *path;
a165 1
    int err;
d169 1
a169 1
       (cvs update, cvs commit, etc).  Return an empty string. */
d171 1
a171 1
	return xstrdup ("");
d179 1
a179 2
	path = (char *) xmalloc (sizeof(char) *
				 (strlen(dir) + strlen(file) + 2));
d195 2
a196 2
    inodestr = (char *) xmalloc (2*sizeof(ino_t)*sizeof(char) + 1);
    sprintf (inodestr, "%lx", (unsigned long) sb.st_ino);
d202 61
a262 4
    filelist = NULL;
    err = walklist ((List *) n->data, list_files_proc, &filelist);
    if (err)
	error (1, 0, "cannot get list of hardlinks for %s", file);
d264 40
a303 2
    free (inodestr);
    return filelist;
d305 1
@


1.1.1.1
log
@Latest version from Cyclic
@
text
@@


1.1.1.2
log
@Latest version from Cyclic
@
text
@d44 90
d240 1
d243 1
a243 1
/* Return a List with all the files known to be linked to FILE in
d245 4
a248 8
   whether it is safe to merge two files.

   FIXME: What is the memory allocation for the return value?  We seem
   to sometimes allocate a new list (getlist() call below) and sometimes
   return an existing list (where we return n->data).  */
List *
list_linked_files_on_disk (file)
    char *file;
d250 1
a250 1
    char *inodestr, *path;
d253 1
d257 1
a257 1
       (cvs update, cvs commit, etc).  Return an empty list. */
d259 1
a259 1
	return getlist();
d291 5
d297 1
a297 1
    return (List *) n->data;
a298 101

/* Compare the files in the `key' fields of two lists, returning 1 if
   the lists are equivalent and 0 otherwise.

   Only the basenames of each file are compared. This is an awful hack
   that exists because list_linked_files_on_disk returns full paths
   and the `hardlinks' structure of a RCSVers node contains only
   basenames.  That in turn is a result of the awful hack that only
   basenames are stored in the RCS file.  If anyone ever solves the
   problem of correctly managing cross-directory hardlinks, this
   function (along with most functions in this file) must be fixed. */
						      
int
compare_linkage_lists (links1, links2)
    List *links1;
    List *links2;
{
    Node *n1, *n2;
    char *p1, *p2;

    sortlist (links1, fsortcmp);
    sortlist (links2, fsortcmp);

    n1 = links1->list->next;
    n2 = links2->list->next;

    while (n1 != links1->list && n2 != links2->list)
    {
	/* Get the basenames of both files. */
	p1 = strrchr (n1->key, '/');
	if (p1 == NULL)
	    p1 = n1->key;
	else
	    ++p1;

	p2 = strrchr (n2->key, '/');
	if (p2 == NULL)
	    p2 = n2->key;
	else
	    ++p2;

	/* Compare the files' basenames. */
	if (strcmp (p1, p2) != 0)
	    return 0;

	n1 = n1->next;
	n2 = n2->next;
    }

    /* At this point we should be at the end of both lists; if not,
       one file has more links than the other, and return 1. */
    return (n1 == links1->list && n2 == links2->list);
}

/* Find a checked-out file in a list of filenames.  Used by RCS_checkout
   when checking out a new hardlinked file, to decide whether this file
   can be linked to any others that already exist.  The return value
   is not currently used. */

int
find_checkedout_proc (node, data)
    Node *node;
    void *data;
{
    Node **uptodate = (Node **) data;
    Node *link;
    char *dir = xgetwd();
    char *path;
    struct hardlink_info *hlinfo;

    /* If we have already found a file, don't do anything. */
    if (*uptodate != NULL)
	return 0;

    /* Look at this file in the hardlist and see whether the checked_out
       field is 1, meaning that it has been checked out during this CVS run. */
    path = (char *)
	xmalloc (sizeof(char) * (strlen (dir) + strlen (node->key) + 2));
    sprintf (path, "%s/%s", dir, node->key);
    link = lookup_file_by_inode (path);
    free (path);
    free (dir);

    if (link == NULL)
    {
	/* We haven't seen this file -- maybe it hasn't been checked
	   out yet at all. */
	return 0;
    }

    hlinfo = (struct hardlink_info *) link->data;
    if (hlinfo->checked_out)
    {
	/* This file has been checked out recently, so it's safe to
           link to it. */
	*uptodate = link;
    }

    return 0;
}

@


1.1.1.3
log
@Latest version from Cyclic
@
text
@d69 1
a69 1
	if (existence_error (errno))
@


1.1.1.4
log
@Latest from Cyclic Software
@
text
@d66 1
a66 1
    inodestr = (char *) xmalloc (2*sizeof(ino_t) + 1);
d88 1
a88 1
	hp->type = NT_UNKNOWN;
d103 1
a103 1
	p->type = NT_UNKNOWN;
d131 1
a131 1
	path = xmalloc (strlen(dir) + strlen(file) + 2);
d179 2
a180 1
	path = (char *) xmalloc (strlen(dir) + strlen(file) + 2);
d196 1
a196 1
    inodestr = (char *) xmalloc (2*sizeof(ino_t) + 1);
d283 1
a283 1
	xmalloc (strlen (dir) + strlen (node->key) + 2);
@


