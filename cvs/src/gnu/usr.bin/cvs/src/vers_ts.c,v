head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.13
	OPENBSD_6_0:1.1.1.13.0.62
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.58
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.60
	OPENBSD_5_8_BASE:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.52
	OPENBSD_5_7_BASE:1.1.1.13
	OPENBSD_5_6:1.1.1.13.0.56
	OPENBSD_5_6_BASE:1.1.1.13
	OPENBSD_5_5:1.1.1.13.0.54
	OPENBSD_5_5_BASE:1.1.1.13
	OPENBSD_5_4:1.1.1.13.0.50
	OPENBSD_5_4_BASE:1.1.1.13
	OPENBSD_5_3:1.1.1.13.0.48
	OPENBSD_5_3_BASE:1.1.1.13
	OPENBSD_5_2:1.1.1.13.0.46
	OPENBSD_5_2_BASE:1.1.1.13
	OPENBSD_5_1_BASE:1.1.1.13
	OPENBSD_5_1:1.1.1.13.0.44
	OPENBSD_5_0:1.1.1.13.0.42
	OPENBSD_5_0_BASE:1.1.1.13
	OPENBSD_4_9:1.1.1.13.0.40
	OPENBSD_4_9_BASE:1.1.1.13
	OPENBSD_4_8:1.1.1.13.0.38
	OPENBSD_4_8_BASE:1.1.1.13
	OPENBSD_4_7:1.1.1.13.0.34
	OPENBSD_4_7_BASE:1.1.1.13
	OPENBSD_4_6:1.1.1.13.0.36
	OPENBSD_4_6_BASE:1.1.1.13
	OPENBSD_4_5:1.1.1.13.0.32
	OPENBSD_4_5_BASE:1.1.1.13
	OPENBSD_4_4:1.1.1.13.0.30
	OPENBSD_4_4_BASE:1.1.1.13
	OPENBSD_4_3:1.1.1.13.0.28
	OPENBSD_4_3_BASE:1.1.1.13
	OPENBSD_4_2:1.1.1.13.0.26
	OPENBSD_4_2_BASE:1.1.1.13
	OPENBSD_4_1:1.1.1.13.0.24
	OPENBSD_4_1_BASE:1.1.1.13
	OPENBSD_4_0:1.1.1.13.0.22
	OPENBSD_4_0_BASE:1.1.1.13
	OPENBSD_3_9:1.1.1.13.0.20
	OPENBSD_3_9_BASE:1.1.1.13
	OPENBSD_3_8:1.1.1.13.0.18
	OPENBSD_3_8_BASE:1.1.1.13
	OPENBSD_3_7:1.1.1.13.0.16
	OPENBSD_3_7_BASE:1.1.1.13
	OPENBSD_3_6:1.1.1.13.0.14
	OPENBSD_3_6_BASE:1.1.1.13
	OPENBSD_3_5:1.1.1.13.0.12
	OPENBSD_3_5_BASE:1.1.1.13
	OPENBSD_3_4:1.1.1.13.0.10
	OPENBSD_3_4_BASE:1.1.1.13
	OPENBSD_3_3:1.1.1.13.0.8
	OPENBSD_3_3_BASE:1.1.1.13
	OPENBSD_3_2:1.1.1.13.0.6
	OPENBSD_3_2_BASE:1.1.1.13
	OPENBSD_3_1:1.1.1.13.0.4
	OPENBSD_3_1_BASE:1.1.1.13
	OPENBSD_3_0:1.1.1.13.0.2
	OPENBSD_3_0_BASE:1.1.1.13
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.1.1.12.0.2
	OPENBSD_2_9_BASE:1.1.1.12
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.1.1.11.0.8
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.6
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.4
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.11.0.2
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.36;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.26;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.14;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.36.01;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.59;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.28.08;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.29.06;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.21.44;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.59.21;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.33.46;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.49;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.39;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)vers_ts.c 1.45 94/10/07 $";
USE(rcsid);
#endif

#define ctime(X)	do not use ctime, please

#ifdef SERVER_SUPPORT
static void time_stamp_server PROTO((char *, Vers_TS *));
#endif

/*
 * Fill in and return a Vers_TS structure "user" is the name of the local
 * file; entries is the entries file - preparsed for our pleasure. xfiles is
 * all source code control files, preparsed for our pleasure
 */
Vers_TS *
Version_TS (repository, options, tag, date, user, force_tag_match,
	    set_time, entries, xfiles)
    char *repository;
    char *options;
    char *tag;
    char *date;
    char *user;
    int force_tag_match;
    int set_time;
    List *entries;
    List *xfiles;
{
    Node *p;
    RCSNode *rcsdata;
    Vers_TS *vers_ts;
    struct stickydirtag *sdtp;

    /* get a new Vers_TS struct */
    vers_ts = (Vers_TS *) xmalloc (sizeof (Vers_TS));
    memset ((char *) vers_ts, 0, sizeof (*vers_ts));

    /*
     * look up the entries file entry and fill in the version and timestamp
     * if entries is NULL, there is no entries file so don't bother trying to
     * look it up (used by checkout -P)
     */
    if (entries == NULL)
    {
	sdtp = NULL;
	p = NULL;
    }
    else
    {
	p = findnode (entries, user);
	sdtp = (struct stickydirtag *) entries->list->data; /* list-private */
    }

    if (p != NULL)
    {
	Entnode *entdata = (Entnode *) p->data;

	vers_ts->vn_user = xstrdup (entdata->version);
	vers_ts->ts_rcs = xstrdup (entdata->timestamp);
	vers_ts->ts_conflict = xstrdup (entdata->conflict);
	if (!tag)
	{
	    if (!(sdtp && sdtp->aflag))
		vers_ts->tag = xstrdup (entdata->tag);
	}
	if (!date)
	{
	    if (!(sdtp && sdtp->aflag))
		vers_ts->date = xstrdup (entdata->date);
	}
	if (!options || (options && *options == '\0'))
	{
	    if (!(sdtp && sdtp->aflag))
		vers_ts->options = xstrdup (entdata->options);
	}
	vers_ts->entdata = entdata;
    }

    /*
     * -k options specified on the command line override (and overwrite)
     * options stored in the entries file
     */
    if (options)
	vers_ts->options = xstrdup (options);
    else if (sdtp && sdtp->aflag == 0)
    {
	if (!vers_ts->options)
	    vers_ts->options = xstrdup (sdtp->options);
    }
    if (!vers_ts->options)
	vers_ts->options = xstrdup ("");

    /*
     * if tags were specified on the command line, they override what is in
     * the Entries file
     */
    if (tag || date)
    {
	vers_ts->tag = xstrdup (tag);
	vers_ts->date = xstrdup (date);
    }
    else if (!vers_ts->entdata && (sdtp && sdtp->aflag == 0))
    {
	if (!vers_ts->tag)
	    vers_ts->tag = xstrdup (sdtp->tag);
	if (!vers_ts->date)
	    vers_ts->date = xstrdup (sdtp->date);
    }

    /* Now look up the info on the source controlled file */
    if (xfiles != (List *) NULL)
    {
	p = findnode (xfiles, user);
	if (p != NULL)
	{
	    rcsdata = (RCSNode *) p->data;
	    rcsdata->refcount++;
	}
	else
	    rcsdata = NULL;
    }
    else if (repository != NULL)
	rcsdata = RCS_parse (user, repository);
    else
	rcsdata = NULL;

    if (rcsdata != NULL)
    {
	/* squirrel away the rcsdata pointer for others */
	vers_ts->srcfile = rcsdata;

#ifndef DEATH_SUPPORT
	/* (is this indeed death support?  I haven't looked carefully).  */
	/* get RCS version number into vn_rcs (if appropriate) */
	if (((vers_ts->tag || vers_ts->date) && force_tag_match) ||
	    ((rcsdata->flags & VALID) && (rcsdata->flags & INATTIC) == 0))
	{
#endif
	    if (vers_ts->tag && strcmp (vers_ts->tag, TAG_BASE) == 0)
		vers_ts->vn_rcs = xstrdup (vers_ts->vn_user);
	    else
		vers_ts->vn_rcs = RCS_getversion (rcsdata, vers_ts->tag,
					    vers_ts->date, force_tag_match);
#ifndef DEATH_SUPPORT
	} 
#endif

	/*
	 * If the source control file exists and has the requested revision,
	 * get the Date the revision was checked in.  If "user" exists, set
	 * its mtime.
	 */
	if (set_time)
	{
	    struct utimbuf t;

	    memset ((char *) &t, 0, sizeof (t));
	    if (vers_ts->vn_rcs &&
		(t.actime = t.modtime = RCS_getrevtime (rcsdata,
		 vers_ts->vn_rcs, (char *) 0, 0)) != -1)
		(void) utime (user, &t);
	}
    }

    /* get user file time-stamp in ts_user */
    if (entries != (List *) NULL)
    {
#ifdef SERVER_SUPPORT
	if (server_active)
	    time_stamp_server (user, vers_ts);
	else
#endif
	    vers_ts->ts_user = time_stamp (user);
    }

    return (vers_ts);
}

#ifdef SERVER_SUPPORT

/* Set VERS_TS->TS_USER to time stamp for FILE.  */

/* Separate these out to keep the logic below clearer.  */
#define mark_lost(V)		((V)->ts_user = 0)
#define mark_unchanged(V)	((V)->ts_user = xstrdup ((V)->ts_rcs))

static void
time_stamp_server (file, vers_ts)
    char *file;
    Vers_TS *vers_ts;
{
    struct stat sb;
    char *cp;

    if (stat (file, &sb) < 0)
    {
	if (errno != ENOENT)
	    error (1, errno, "cannot stat temp file");
	if (use_unchanged)
	  {
	    /* Missing file means lost or unmodified; check entries
	       file to see which.

	       XXX FIXME - If there's no entries file line, we
	       wouldn't be getting the file at all, so consider it
	       lost.  I don't know that that's right, but it's not
	       clear to me that either choice is.  Besides, would we
	       have an RCS string in that case anyways?  */
	    if (vers_ts->entdata == NULL)
	      mark_lost (vers_ts);
	    else if (vers_ts->entdata->timestamp
		     && vers_ts->entdata->timestamp[0] == '=')
	      mark_unchanged (vers_ts);
	    else
	      mark_lost (vers_ts);
	  }
	else
	  {
	    /* Missing file in the temp directory means that the file
	       was not modified.  */
	    mark_unchanged (vers_ts);
	  }
    }
    else if (sb.st_mtime == 0)
    {
	if (use_unchanged)
	  /* We shouldn't reach this case any more!  */
	  abort ();

	/* Special code used by server.c to indicate the file was lost.  */
	mark_lost (vers_ts);
    }
    else
    {
	vers_ts->ts_user = xmalloc (25);
	cp = asctime (gmtime (&sb.st_mtime));	/* copy in the modify time */
	cp[24] = 0;
	(void) strcpy (vers_ts->ts_user, cp);
    }
}

#endif /* SERVER_SUPPORT */
/*
 * Gets the time-stamp for the file "file" and returns it in space it
 * allocates
 */
char *
time_stamp (file)
    char *file;
{
    struct stat sb;
    char *cp;
    char *ts;

    if (stat (file, &sb) < 0)
    {
	ts = NULL;
    }
    else
    {
	ts = xmalloc (25);
	cp = asctime (gmtime (&sb.st_mtime));	/* copy in the modify time */
	cp[24] = 0;
	(void) strcpy (ts, cp);
    }

    return (ts);
}

/*
 * free up a Vers_TS struct
 */
void
freevers_ts (versp)
    Vers_TS **versp;
{
    if ((*versp)->srcfile)
	freercsnode (&((*versp)->srcfile));
    if ((*versp)->vn_user)
	free ((*versp)->vn_user);
    if ((*versp)->vn_rcs)
	free ((*versp)->vn_rcs);
    if ((*versp)->ts_user)
	free ((*versp)->ts_user);
    if ((*versp)->ts_rcs)
	free ((*versp)->ts_rcs);
    if ((*versp)->options)
	free ((*versp)->options);
    if ((*versp)->tag)
	free ((*versp)->tag);
    if ((*versp)->date)
	free ((*versp)->date);
    if ((*versp)->ts_conflict)
	free ((*versp)->ts_conflict);
    free ((char *) *versp);
    *versp = (Vers_TS *) NULL;
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d16 2
a150 1
	    {
a151 2
		vers_ts->vn_tag = xstrdup (vers_ts->vn_user);
	    }
a152 1
	    {
d154 1
a154 15
					    vers_ts->date, force_tag_match, 1);
		if (vers_ts->vn_rcs == NULL)
		    vers_ts->vn_tag = NULL;
		else
		{
		    char *colon = strchr (vers_ts->vn_rcs, ':');
		    if (colon)
		    {
			vers_ts->vn_tag = xstrdup (colon+1);
			*colon = '\0';
		    }
		    else
			vers_ts->vn_tag = xstrdup (vers_ts->vn_rcs);
		}
	    }
d208 1
a208 1
	if (! existence_error (errno))
a293 2
    if ((*versp)->vn_tag)
	free ((*versp)->vn_tag);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d11 5
d141 5
a145 1
	if (vers_ts->tag && strcmp (vers_ts->tag, TAG_BASE) == 0)
d147 6
a152 9
	    vers_ts->vn_rcs = xstrdup (vers_ts->vn_user);
	    vers_ts->vn_tag = xstrdup (vers_ts->vn_user);
	}
	else
	{
	    vers_ts->vn_rcs = RCS_getversion (rcsdata, vers_ts->tag,
					vers_ts->date, force_tag_match, 1);
	    if (vers_ts->vn_rcs == NULL)
		vers_ts->vn_tag = NULL;
d155 5
a159 2
		char *colon = strchr (vers_ts->vn_rcs, ':');
		if (colon)
d161 8
a168 2
		    vers_ts->vn_tag = xstrdup (colon+1);
		    *colon = '\0';
a169 2
		else
		    vers_ts->vn_tag = xstrdup (vers_ts->vn_rcs);
d171 3
a173 1
	}
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d17 2
a18 2
 * file; entries is the entries file - preparsed for our pleasure. rcs is
 * the current source control file - preparsed for our pleasure.
d22 1
a22 1
	    set_time, entries, rcs)
d31 1
a31 1
    RCSNode *rcs;
d54 1
a54 1
	p = findnode_fn (entries, user);
d89 1
a89 1
    else if (!vers_ts->options)
d91 1
a91 1
	if (sdtp && sdtp->aflag == 0)
a92 14
	else if (rcs != NULL)
	{
	    /* If no keyword expansion was specified on command line,
	       use whatever was in the rcs file (if there is one).  This
	       is how we, if we are the server, tell the client whether
	       a file is binary.  */
	    char *rcsexpand = RCS_getexpand (rcs);
	    if (rcsexpand != NULL)
	    {
		vers_ts->options = xmalloc (strlen (rcsexpand) + 3);
		strcpy (vers_ts->options, "-k");
		strcat (vers_ts->options, rcsexpand);
	    }
	}
d115 1
a115 1
    if (rcs != NULL)
d117 8
a124 2
	rcsdata = rcs;
	rcsdata->refcount++;
a246 3
        struct tm *tm_p;
        struct tm local_tm;

d248 1
a248 16
	/* We want to use the same timestamp format as is stored in the
	   st_mtime.  For unix (and NT I think) this *must* be universal
	   time (UT), so that files don't appear to be modified merely
	   because the timezone has changed.  For VMS, or hopefully other
	   systems where gmtime returns NULL, the modification time is
	   stored in local time, and therefore it is not possible to cause
	   st_mtime to be out of sync by changing the timezone.  */
	tm_p = gmtime (&sb.st_mtime);
	if (tm_p)
	{
	    memcpy (&local_tm, tm_p, sizeof (local_tm));
	    cp = asctime (&local_tm);	/* copy in the modify time */
	}
	else
	    cp = ctime (&sb.st_mtime);

a272 2
	struct tm *tm_p;
        struct tm local_tm;
d274 1
a274 16
	/* We want to use the same timestamp format as is stored in the
	   st_mtime.  For unix (and NT I think) this *must* be universal
	   time (UT), so that files don't appear to be modified merely
	   because the timezone has changed.  For VMS, or hopefully other
	   systems where gmtime returns NULL, the modification time is
	   stored in local time, and therefore it is not possible to cause
	   st_mtime to be out of sync by changing the timezone.  */
	tm_p = gmtime (&sb.st_mtime);
	if (tm_p)
	{
	    memcpy (&local_tm, tm_p, sizeof (local_tm));
	    cp = asctime (&local_tm);	/* copy in the modify time */
	}
	else
	    cp = ctime(&sb.st_mtime);

@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d21 3
a23 2
Version_TS (finfo, options, tag, date, force_tag_match, set_time)
    struct file_info *finfo;
d27 1
d30 2
d47 1
a47 1
    if (finfo->entries == NULL)
d54 2
a55 2
	p = findnode_fn (finfo->entries, finfo->file);
	sdtp = (struct stickydirtag *) finfo->entries->list->data; /* list-private */
d91 3
a93 1
	if (finfo->rcs != NULL)
d99 1
a99 1
	    char *rcsexpand = RCS_getexpand (finfo->rcs);
d129 1
a129 1
    if (finfo->rcs != NULL)
d131 1
a131 1
	rcsdata = finfo->rcs;
d134 2
a135 2
    else if (finfo->repository != NULL)
	rcsdata = RCS_parse (finfo->file, finfo->repository);
a150 2
	    int simple;

d152 1
a152 2
					      vers_ts->date, force_tag_match,
					      &simple);
a154 2
	    else if (simple)
		vers_ts->vn_tag = xstrdup (vers_ts->tag);
d156 10
a165 1
		vers_ts->vn_tag = xstrdup (vers_ts->vn_rcs);
d181 1
a181 1
		(void) utime (finfo->file, &t);
d186 1
a186 1
    if (finfo->entries != (List *) NULL)
d190 1
a190 1
	    time_stamp_server (finfo->file, vers_ts);
d193 1
a193 1
	    vers_ts->ts_user = time_stamp (finfo->file);
d215 1
a215 1
    if ( CVS_STAT (file, &sb) < 0)
d293 1
a293 1
    if ( CVS_STAT (file, &sb) < 0)
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d209 4
d214 17
a230 12
	/* Missing file means lost or unmodified; check entries
	   file to see which.

	   XXX FIXME - If there's no entries file line, we
	   wouldn't be getting the file at all, so consider it
	   lost.  I don't know that that's right, but it's not
	   clear to me that either choice is.  Besides, would we
	   have an RCS string in that case anyways?  */
	if (vers_ts->entdata == NULL)
	    mark_lost (vers_ts);
	else if (vers_ts->entdata->timestamp
		 && vers_ts->entdata->timestamp[0] == '=')
d232 1
a232 2
	else
	    mark_lost (vers_ts);
d236 6
a241 2
	/* We shouldn't reach this case any more!  */
	abort ();
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d12 1
a12 1
static void time_stamp_server PROTO((char *, Vers_TS *, Entnode *));
a32 1
    Entnode *entdata;
a53 1
    entdata = NULL;
d56 1
a56 1
	entdata = (Entnode *) p->data;
d58 14
a71 8
#ifdef SERVER_SUPPORT
	/* An entries line with "D" in the timestamp indicates that the
	   client sent Is-modified without sending Entry.  So we want to
	   use the entries line for the sole purpose of telling
	   time_stamp_server what is up; we don't want the rest of CVS
	   to think there is an entries line.  */
	if (strcmp (entdata->timestamp, "D") != 0)
#endif
d73 2
a74 19
	    vers_ts->vn_user = xstrdup (entdata->version);
	    vers_ts->ts_rcs = xstrdup (entdata->timestamp);
	    vers_ts->ts_conflict = xstrdup (entdata->conflict);
	    if (!tag)
	    {
		if (!(sdtp && sdtp->aflag))
		    vers_ts->tag = xstrdup (entdata->tag);
	    }
	    if (!date)
	    {
		if (!(sdtp && sdtp->aflag))
		    vers_ts->date = xstrdup (entdata->date);
	    }
	    if (!options || (options && *options == '\0'))
	    {
		if (!(sdtp && sdtp->aflag))
		    vers_ts->options = xstrdup (entdata->options);
	    }
	    vers_ts->entdata = entdata;
d76 1
a116 1
	{
a117 2
	    vers_ts->nonbranch = sdtp->nonbranch;
	}
d180 1
a180 1
	    time_stamp_server (finfo->file, vers_ts, entdata);
d198 1
a198 1
time_stamp_server (file, vers_ts, entdata)
a200 1
    Entnode *entdata;
d218 1
a218 1
	if (entdata == NULL)
d220 2
a221 2
	else if (entdata->timestamp
		 && entdata->timestamp[0] == '=')
a222 5
	else if (entdata->timestamp != NULL
		 && (entdata->timestamp[0] == 'M'
		     || entdata->timestamp[0] == 'D')
		 && entdata->timestamp[1] == '\0')
	    vers_ts->ts_user = xstrdup ("Is-modified");
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@d180 1
a180 7
#ifdef SERVER_SUPPORT
	    if (server_active)
		server_modtime (finfo, vers_ts);
	    else
#endif
	    {
		struct utimbuf t;
d182 5
a186 12
		memset (&t, 0, sizeof (t));
		if (vers_ts->vn_rcs)
		{
		    t.modtime =
			RCS_getrevtime (rcsdata, vers_ts->vn_rcs, 0, 0);
		    if (t.modtime != (time_t) -1)
		    {
			t.actime = t.modtime;
			(void) utime (finfo->file, &t);
		    }
		}
	    }
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d15 5
a19 3
/* Fill in and return a Vers_TS structure for the file FINFO.  TAG and
   DATE are from the command line.  */

a22 4

    /* Keyword expansion options, I think generally from the command
       line.  Can be either NULL or "" to indicate none are specified
       here.  */
a59 12
	if (entdata->type == ENT_SUBDIR)
	{
	    /* According to cvs.texinfo, the various fields in the Entries
	       file for a directory (other than the name) do not have a
	       defined meaning.  We need to pass them along without getting
	       confused based on what is in them.  Therefore we make sure
	       not to set vn_user and the like from Entries, add.c and
	       perhaps other code will expect these fields to be NULL for
	       a directory.  */
	    vers_ts->entdata = entdata;
	}
	else
d82 5
a88 8
	/* Even if we don't have an "entries line" as such
	   (vers_ts->entdata), we want to pick up options which could
	   have been from a Kopt protocol request.  */
	if (!options || (options && *options == '\0'))
	{
	    if (!(sdtp && sdtp->aflag))
		vers_ts->options = xstrdup (entdata->options);
	}
d95 1
a95 1
    if (options && *options != '\0')
d97 1
a97 1
    else if (!vers_ts->options || *vers_ts->options == '\0')
d178 1
a178 1
	if (set_time && vers_ts->vn_rcs != NULL)
d189 1
a189 3
		t.modtime =
		    RCS_getrevtime (rcsdata, vers_ts->vn_rcs, 0, 0);
		if (t.modtime != (time_t) -1)
d191 7
a197 8
		    t.actime = t.modtime;

		    /* This used to need to ignore existence_errors
		       (for cases like where update.c now clears
		       set_time if noexec, but didn't used to).  I
		       think maybe now it doesn't (server_modtime does
		       not like those kinds of cases).  */
		    (void) utime (finfo->file, &t);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d254 1
a254 1
    if (CVS_LSTAT (file, &sb) < 0)
d325 1
a325 1
    if (CVS_LSTAT (file, &sb) < 0)
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a36 4
#ifdef UTIME_EXPECTS_WRITABLE
    int change_it_back = 0;
#endif

a211 8
#ifdef UTIME_EXPECTS_WRITABLE
		    if (!iswritable (finfo->file))
		    {
			xchmod (finfo->file, 1);
			change_it_back = 1;
		    }
#endif  /* UTIME_EXPECTS_WRITABLE  */

a217 8

#ifdef UTIME_EXPECTS_WRITABLE
		    if (change_it_back == 1)
		    {
			xchmod (finfo->file, 0);
			change_it_back = 0;
		    }
#endif  /*  UTIME_EXPECTS_WRITABLE  */
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d90 1
a90 1
	    if (!(tag || date) && !(sdtp && sdtp->aflag))
d92 7
a98 2
		vers_ts->tag = xstrdup (entdata->tag);
		vers_ts->date = xstrdup (entdata->date);
d105 1
a105 1
	if (!options || *options == '\0')
a128 2
		if (vers_ts->options != NULL)
		    free (vers_ts->options);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@a324 2
	/* Fix non-standard format.  */
	if (cp[8] == '0') cp[8] = ' ';
a367 2
	/* Fix non-standard format.  */
	if (cp[8] == '0') cp[8] = ' ';
@


