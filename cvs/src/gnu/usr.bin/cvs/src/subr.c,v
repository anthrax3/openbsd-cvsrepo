head	1.4;
access;
symbols
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.16
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.12
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.8
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.6
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.4
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.2
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.36
	OPENBSD_5_0:1.2.0.34
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.32
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.30
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.26
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.28
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.24
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.22
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.20
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.18
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.16
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.14
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.12
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.10
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.1.1.13.0.8
	OPENBSD_3_3_BASE:1.1.1.13
	OPENBSD_3_2:1.1.1.13.0.6
	OPENBSD_3_2_BASE:1.1.1.13
	OPENBSD_3_1:1.1.1.13.0.4
	OPENBSD_3_1_BASE:1.1.1.13
	OPENBSD_3_0:1.1.1.13.0.2
	OPENBSD_3_0_BASE:1.1.1.13
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.1.1.12.0.2
	OPENBSD_2_9_BASE:1.1.1.12
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.1.1.11.0.6
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.4
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.2
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.10.0.2
	OPENBSD_2_5_BASE:1.1.1.10
	cvs-1-10-5:1.1.1.10
	OPENBSD_2_4:1.1.1.9.0.4
	OPENBSD_2_4_BASE:1.1.1.9
	cvs-1-10:1.1.1.9
	cvs-1-9-28:1.1.1.9
	OPENBSD_2_3:1.1.1.9.0.2
	OPENBSD_2_3_BASE:1.1.1.9
	cvs-1-9-26:1.1.1.9
	cvs-1-9-24:1.1.1.8
	OPENBSD_2_2:1.1.1.7.0.2
	OPENBSD_2_2_BASE:1.1.1.7
	cvs-1-9-10:1.1.1.7
	OPENBSD_2_1:1.1.1.6.0.2
	OPENBSD_2_1_BASE:1.1.1.6
	cvs-1-9-8:1.1.1.6
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.06.18.41.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.30;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.19;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.05;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.53;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.29;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.06.28.03.29.01;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.02.22.08.21.37;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.03.12.06.59.14;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.02.28.21.33.37;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.09.10.05.06.28;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.47;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Various useful functions for the CVS support code.
 */

#include "cvs.h"
#include "getline.h"

#ifdef HAVE_NANOSLEEP
# include "xtime.h"
#else /* HAVE_NANOSLEEP */
# if !defined HAVE_USLEEP && defined HAVE_SELECT
    /* use select as a workaround */
#   include "xselect.h"
# endif /* !defined HAVE_USLEEP && defined HAVE_SELECT */
#endif /* !HAVE_NANOSLEEP */

extern char *getlogin ();

/*
 * malloc some data and die if it fails
 */
void *
xmalloc (bytes)
    size_t bytes;
{
    char *cp;

    /* Parts of CVS try to xmalloc zero bytes and then free it.  Some
       systems have a malloc which returns NULL for zero byte
       allocations but a free which can't handle NULL, so compensate. */
    if (bytes == 0)
	bytes = 1;

    cp = malloc (bytes);
    if (cp == NULL)
    {
	char buf[80];
	snprintf (buf, sizeof buf, "out of memory; can not allocate %lu bytes",
		 (unsigned long) bytes);
	error (1, 0, buf);
    }
    return (cp);
}

/*
 * realloc data and die if it fails [I've always wanted to have "realloc" do
 * a "malloc" if the argument is NULL, but you can't depend on it.  Here, I
 * can *force* it.
 */
void *
xrealloc (ptr, bytes)
    void *ptr;
    size_t bytes;
{
    char *cp;

    if (!ptr)
	cp = malloc (bytes);
    else
	cp = realloc (ptr, bytes);

    if (cp == NULL)
    {
	char buf[80];
	snprintf (buf, sizeof buf, "out of memory; can not reallocate %lu bytes",
		 (unsigned long) bytes);
	error (1, 0, buf);
    }
    return (cp);
}

/* Two constants which tune expand_string.  Having MIN_INCR as large
   as 1024 might waste a bit of memory, but it shouldn't be too bad
   (CVS used to allocate arrays of, say, 3000, PATH_MAX (8192, often),
   or other such sizes).  Probably anything which is going to allocate
   memory which is likely to get as big as MAX_INCR shouldn't be doing
   it in one block which must be contiguous, but since getrcskey does
   so, we might as well limit the wasted memory to MAX_INCR or so
   bytes.

   MIN_INCR and MAX_INCR should both be powers of two and we generally
   try to keep our allocations to powers of two for the most part.
   Most malloc implementations these days tend to like that.  */

#define MIN_INCR 1024
#define MAX_INCR (2*1024*1024)

/* *STRPTR is a pointer returned from malloc (or NULL), pointing to *N
   characters of space.  Reallocate it so that points to at least
   NEWSIZE bytes of space.  Gives a fatal error if out of memory;
   if it returns it was successful.  */
void
expand_string (strptr, n, newsize)
    char **strptr;
    size_t *n;
    size_t newsize;
{
    if (*n < newsize)
    {
	while (*n < newsize)
	{
	    if (*n < MIN_INCR)
		*n = MIN_INCR;
	    else if (*n >= MAX_INCR)
		*n += MAX_INCR;
	    else
	    {
		*n *= 2;
		if (*n > MAX_INCR)
		    *n = MAX_INCR;
	    }
	}
	*strptr = xrealloc (*strptr, *n);
    }
}

/* *STR is a pointer to a malloc'd string.  *LENP is its allocated
   length.  Add SRC to the end of it, reallocating if necessary.  */
void
allocate_and_strcat (str, lenp, src)
    char **str;
    size_t *lenp;
    const char *src;
{

    expand_string (str, lenp, strlen (*str) + strlen (src) + 1);
    strcat (*str, src);
}

/*
 * Duplicate a string, calling xmalloc to allocate some dynamic space
 */
char *
xstrdup (str)
    const char *str;
{
    char *s;

    if (str == NULL)
	return ((char *) NULL);
    s = xmalloc (strlen (str) + 1);
    (void) strcpy (s, str);
    return (s);
}

/* Remove trailing newlines from STRING, destructively. */
void
strip_trailing_newlines (str)
     char *str;
{
    int len;
    len = strlen (str) - 1;

    while (str[len] == '\n')
	str[len--] = '\0';
}

/* Return the number of levels that path ascends above where it starts.
   For example:
   "../../foo" -> 2
   "foo/../../bar" -> 1
   */
/* FIXME: Should be using ISDIRSEP, last_component, or some other
   mechanism which is more general than just looking at slashes,
   particularly for the client.c caller.  The server.c caller might
   want something different, so be careful.  */
int
pathname_levels (path)
    char *path;
{
    char *p;
    char *q;
    int level;
    int max_level;

    max_level = 0;
    p = path;
    level = 0;
    do
    {
	q = strchr (p, '/');
	if (q != NULL)
	    ++q;
	if (p[0] == '.' && p[1] == '.' && (p[2] == '\0' || p[2] == '/'))
	{
	    --level;
	    if (-level > max_level)
		max_level = -level;
	}
	else if (p[0] == '\0' || p[0] == '/' ||
		 (p[0] == '.' && (p[1] == '\0' || p[1] == '/')))
	    ;
	else
	    ++level;
	p = q;
    } while (p != NULL);
    return max_level;
}


/* Free a vector, where (*ARGV)[0], (*ARGV)[1], ... (*ARGV)[*PARGC - 1]
   are malloc'd and so is *ARGV itself.  Such a vector is allocated by
   line2argv or expand_wild, for example.  */
void
free_names (pargc, argv)
    int *pargc;
    char **argv;
{
    register int i;

    for (i = 0; i < *pargc; i++)
    {					/* only do through *pargc */
	free (argv[i]);
    }
    free (argv);
    *pargc = 0;				/* and set it to zero when done */
}

/* Convert LINE into arguments separated by SEPCHARS.  Set *ARGC
   to the number of arguments found, and (*ARGV)[0] to the first argument,
   (*ARGV)[1] to the second, etc.  *ARGV is malloc'd and so are each of
   (*ARGV)[0], (*ARGV)[1], ...  Use free_names() to return the memory
   allocated here back to the free pool.  */
void
line2argv (pargc, argv, line, sepchars)
    int *pargc;
    char ***argv;
    char *line;
    char *sepchars;
{
    char *cp;
    /* Could make a case for size_t or some other unsigned type, but
       we'll stick with int to avoid signed/unsigned warnings when
       comparing with *pargc.  */
    int argv_allocated;

    /* Small for testing.  */
    argv_allocated = 1;
    *argv = (char **) xmalloc (argv_allocated * sizeof (**argv));

    *pargc = 0;
    for (cp = strtok (line, sepchars); cp; cp = strtok ((char *) NULL, sepchars))
    {
	if (*pargc == argv_allocated)
	{
	    argv_allocated *= 2;
	    *argv = xrealloc (*argv, argv_allocated * sizeof (**argv));
	}
	(*argv)[*pargc] = xstrdup (cp);
	(*pargc)++;
    }
}

/*
 * Returns the number of dots ('.') found in an RCS revision number
 */
int
numdots (s)
    const char *s;
{
    int dots = 0;

    for (; *s; s++)
    {
	if (*s == '.')
	    dots++;
    }
    return (dots);
}

/* Compare revision numbers REV1 and REV2 by consecutive fields.
   Return negative, zero, or positive in the manner of strcmp.  The
   two revision numbers must have the same number of fields, or else
   compare_revnums will return an inaccurate result. */
int
compare_revnums (rev1, rev2)
    const char *rev1;
    const char *rev2;
{
    const char *s, *sp;
    const char *t, *tp;
    char *snext, *tnext;
    int result = 0;

    sp = s = rev1;
    tp = t = rev2;
    while (result == 0)
    {
	result = strtoul (sp, &snext, 10) - strtoul (tp, &tnext, 10);
	if (*snext == '\0' || *tnext == '\0')
	    break;
	sp = snext + 1;
	tp = tnext + 1;
    }

    return result;
}

char *
increment_revnum (rev)
    const char *rev;
{
    char *newrev, *p;
    int lastfield;
    size_t len = strlen (rev);

    newrev = (char *) xmalloc (len + 2);
    memcpy (newrev, rev, len + 1);
    p = strrchr (newrev, '.');
    if (p == NULL)
    {
	free (newrev);
	return NULL;
    }
    lastfield = atoi (++p);
    sprintf (p, "%d", lastfield + 1);

    return newrev;
}

/* Return the username by which the caller should be identified in
   CVS, in contexts such as the author field of RCS files, various
   logs, etc.  */
char *
getcaller ()
{
#ifndef SYSTEM_GETCALLER
    static char *cache;
    struct passwd *pw;
    uid_t uid;
#endif

    /* If there is a CVS username, return it.  */
#ifdef AUTH_SERVER_SUPPORT
    if (CVS_Username != NULL)
	return CVS_Username;
#endif

#ifdef SYSTEM_GETCALLER
    return SYSTEM_GETCALLER ();
#else
    /* Get the caller's login from his uid.  If the real uid is "root"
       try LOGNAME USER or getlogin(). If getlogin() and getpwuid()
       both fail, return the uid as a string.  */

    if (cache != NULL)
	return cache;

    uid = getuid ();
    if (uid == (uid_t) 0)
    {
	char *name;

	/* super-user; try getlogin() to distinguish */
	if (((name = getlogin ()) || (name = getenv("LOGNAME")) ||
	     (name = getenv("USER"))) && *name)
	{
	    cache = xstrdup (name);
	    return cache;
	}
    }
    if ((pw = (struct passwd *) getpwuid (uid)) == NULL)
    {
	char uidname[20];

	(void) snprintf (uidname, sizeof uidname, "uid%lu", (unsigned long) uid);
	cache = xstrdup (uidname);
	return cache;
    }
    cache = xstrdup (pw->pw_name);
    return cache;
#endif
}

#ifdef lint
#ifndef __GNUC__
/* ARGSUSED */
time_t
get_date (date)
    char *date;
{
    time_t foo = 0;

    return (foo);
}
#endif
#endif

/* Given two revisions, find their greatest common ancestor.  If the
   two input revisions exist, then rcs guarantees that the gca will
   exist.  */

char *
gca (rev1, rev2)
    const char *rev1;
    const char *rev2;
{
    int dots;
    char *gca;
    const char *p[2];
    int j[2];
    char *retval;

    if (rev1 == NULL || rev2 == NULL)
    {
	error (0, 0, "sanity failure in gca");
	abort();
    }

    /* The greatest common ancestor will have no more dots, and numbers
       of digits for each component no greater than the arguments.  Therefore
       this string will be big enough.  */
    gca = xmalloc (strlen (rev1) + strlen (rev2) + 100);

    /* walk the strings, reading the common parts. */
    gca[0] = '\0';
    p[0] = rev1;
    p[1] = rev2;
    do
    {
	int i;
	char c[2];
	char *s[2];
	
	for (i = 0; i < 2; ++i)
	{
	    /* swap out the dot */
	    s[i] = strchr (p[i], '.');
	    if (s[i] != NULL) {
		c[i] = *s[i];
	    }
	    
	    /* read an int */
	    j[i] = atoi (p[i]);
	    
	    /* swap back the dot... */
	    if (s[i] != NULL) {
		*s[i] = c[i];
		p[i] = s[i] + 1;
	    }
	    else
	    {
		/* or mark us at the end */
		p[i] = NULL;
	    }
	    
	}
	
	/* use the lowest. */
	(void) sprintf (gca + strlen (gca), "%d.",
			j[0] < j[1] ? j[0] : j[1]);

    } while (j[0] == j[1]
	     && p[0] != NULL
	     && p[1] != NULL);

    /* back up over that last dot. */
    gca[strlen(gca) - 1] = '\0';

    /* numbers differ, or we ran out of strings.  we're done with the
       common parts.  */

    dots = numdots (gca);
    if (dots == 0)
    {
	/* revisions differ in trunk major number.  */

	char *q;
	const char *s;

	s = (j[0] < j[1]) ? p[0] : p[1];

	if (s == NULL)
	{
	    /* we only got one number.  this is strange.  */
	    error (0, 0, "bad revisions %s or %s", rev1, rev2);
	    abort();
	}
	else
	{
	    /* we have a minor number.  use it.  */
	    q = gca + strlen (gca);
	    
	    *q++ = '.';
	    for ( ; *s != '.' && *s != '\0'; )
		*q++ = *s++;
	    
	    *q = '\0';
	}
    }
    else if ((dots & 1) == 0)
    {
	/* if we have an even number of dots, then we have a branch.
	   remove the last number in order to make it a revision.  */
	
	char *s;

	s = strrchr(gca, '.');
	*s = '\0';
    }

    retval = xstrdup (gca);
    free (gca);
    return retval;
}

/* Give fatal error if REV is numeric and ARGC,ARGV imply we are
   planning to operate on more than one file.  The current directory
   should be the working directory.  Note that callers assume that we
   will only be checking the first character of REV; it need not have
   '\0' at the end of the tag name and other niceties.  Right now this
   is only called from admin.c, but if people like the concept it probably
   should also be called from diff -r, update -r, get -r, and log -r.  */

void
check_numeric (rev, argc, argv)
    const char *rev;
    int argc;
    char **argv;
{
    if (rev == NULL || !isdigit ((unsigned char) *rev))
	return;

    /* Note that the check for whether we are processing more than one
       file is (basically) syntactic; that is, we don't behave differently
       depending on whether a directory happens to contain only a single
       file or whether it contains more than one.  I strongly suspect this
       is the least confusing behavior.  */
    if (argc != 1
	|| (!wrap_name_has (argv[0], WRAP_TOCVS) && isdir (argv[0])))
    {
	error (0, 0, "while processing more than one file:");
	error (1, 0, "attempt to specify a numeric revision");
    }
}

/*
 *  Sanity checks and any required fix-up on message passed to RCS via '-m'.
 *  RCS 5.7 requires that a non-total-whitespace, non-null message be provided
 *  with '-m'.  Returns a newly allocated, non-empty buffer with whitespace
 *  stripped from end of lines and end of buffer.
 *
 *  TODO: We no longer use RCS to manage repository files, so maybe this
 *  nonsense about non-empty log fields can be dropped.
 */
char *
make_message_rcslegal (message)
     char *message;
{
    char *dst, *dp, *mp;

    if (message == NULL) message = "";

    /* Strip whitespace from end of lines and end of string. */
    dp = dst = (char *) xmalloc (strlen (message) + 1);
    for (mp = message; *mp != '\0'; ++mp)
    {
	if (*mp == '\n')
	{
	    /* At end-of-line; backtrack to last non-space. */
	    while (dp > dst && (dp[-1] == ' ' || dp[-1] == '\t'))
		--dp;
	}
	*dp++ = *mp;
    }

    /* Backtrack to last non-space at end of string, and truncate. */
    while (dp > dst && isspace ((unsigned char) dp[-1]))
	--dp;
    *dp = '\0';

    /* After all that, if there was no non-space in the string,
       substitute a non-empty message. */
    if (*dst == '\0')
    {
	free (dst);
	dst = xstrdup ("*** empty log message ***");
    }

    return dst;
}

/* Does the file FINFO contain conflict markers?  The whole concept
   of looking at the contents of the file to figure out whether there are
   unresolved conflicts is kind of bogus (people do want to manage files
   which contain those patterns not as conflict markers), but for now it
   is what we do.  */
int
file_has_markers (finfo)
    const struct file_info *finfo;
{
    FILE *fp;
    char *line = NULL;
    size_t line_allocated = 0;
    int result;

    result = 0;
    fp = CVS_FOPEN (finfo->file, "r");
    if (fp == NULL)
	error (1, errno, "cannot open %s", finfo->fullname);
    while (get_line (&line, &line_allocated, fp) > 0)
    {
	if (strncmp (line, RCS_MERGE_PAT_1, sizeof RCS_MERGE_PAT_1 - 1) == 0 ||
	    strncmp (line, RCS_MERGE_PAT_2, sizeof RCS_MERGE_PAT_2 - 1) == 0 ||
	    strncmp (line, RCS_MERGE_PAT_3, sizeof RCS_MERGE_PAT_3 - 1) == 0)
	{
	    result = 1;
	    goto out;
	}
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", finfo->fullname);
out:
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", finfo->fullname);
    if (line != NULL)
	free (line);
    return result;
}

/* Read the entire contents of the file NAME into *BUF.
   If NAME is NULL, read from stdin.  *BUF
   is a pointer returned from malloc (or NULL), pointing to *BUFSIZE
   bytes of space.  The actual size is returned in *LEN.  On error,
   give a fatal error.  The name of the file to use in error messages
   (typically will include a directory if we have changed directory)
   is FULLNAME.  MODE is "r" for text or "rb" for binary.  */

void
get_file (name, fullname, mode, buf, bufsize, len)
    const char *name;
    const char *fullname;
    const char *mode;
    char **buf;
    size_t *bufsize;
    size_t *len;
{
    struct stat s;
    size_t nread;
    char *tobuf;
    FILE *e;
    size_t filesize;

    if (name == NULL)
    {
	e = stdin;
	filesize = 100;	/* force allocation of minimum buffer */
    }
    else
    {
	/* Although it would be cleaner in some ways to just read
	   until end of file, reallocating the buffer, this function
	   does get called on files in the working directory which can
	   be of arbitrary size, so I think we better do all that
	   extra allocation.  */

	if (CVS_STAT (name, &s) < 0)
	    error (1, errno, "can't stat %s", fullname);

	/* Convert from signed to unsigned.  */
	filesize = s.st_size;

	e = open_file (name, mode);
    }

    if (*buf == NULL || *bufsize <= filesize)
    {
	*bufsize = filesize + 1;
	*buf = xrealloc (*buf, *bufsize);
    }

    tobuf = *buf;
    nread = 0;
    while (1)
    {
	size_t got;

	got = fread (tobuf, 1, *bufsize - (tobuf - *buf), e);
	if (ferror (e))
	    error (1, errno, "can't read %s", fullname);
	nread += got;
	tobuf += got;

	if (feof (e))
	    break;

	/* Allocate more space if needed.  */
	if (tobuf == *buf + *bufsize)
	{
	    int c;
	    long off;

	    c = getc (e);
	    if (c == EOF)
		break;
	    off = tobuf - *buf;
	    expand_string (buf, bufsize, *bufsize + 100);
	    tobuf = *buf + off;
	    *tobuf++ = c;
	    ++nread;
	}
    }

    if (e != stdin && fclose (e) < 0)
	error (0, errno, "cannot close %s", fullname);

    *len = nread;

    /* Force *BUF to be large enough to hold a null terminator. */
    if (nread == *bufsize)
	expand_string (buf, bufsize, *bufsize + 1);
    (*buf)[nread] = '\0';
}


/* Follow a chain of symbolic links to its destination.  FILENAME
   should be a handle to a malloc'd block of memory which contains the
   beginning of the chain.  This routine will replace the contents of
   FILENAME with the destination (a real file).  */

void
resolve_symlink (filename)
     char **filename;
{
    if ((! filename) || (! *filename))
	return;

    while (islink (*filename))
    {
	char *newname;
#ifdef HAVE_READLINK
	/* The clean thing to do is probably to have each filesubr.c
	   implement this (with an error if not supported by the
	   platform, in which case islink would presumably return 0).
	   But that would require editing each filesubr.c and so the
	   expedient hack seems to be looking at HAVE_READLINK.  */
	newname = xreadlink (*filename);
#else
	error (1, 0, "internal error: islink doesn't like readlink");
#endif
	
	if (isabsolute (newname))
	{
	    free (*filename);
	    *filename = newname;
	}
	else
	{
	    char *oldname = last_component (*filename);
	    int dirlen = oldname - *filename;
	    char *fullnewname = xmalloc (dirlen + strlen (newname) + 1);
	    strncpy (fullnewname, *filename, dirlen);
	    strcpy (fullnewname + dirlen, newname);
	    free (newname);
	    free (*filename);
	    *filename = fullnewname;
	}
    }
}

/*
 * Rename a file to an appropriate backup name based on BAKPREFIX.
 * If suffix non-null, then ".<suffix>" is appended to the new name.
 *
 * Returns the new name, which caller may free() if desired.
 */
char *
backup_file (filename, suffix)
     const char *filename;
     const char *suffix;
{
    char *backup_name;

    if (suffix == NULL)
    {
        backup_name = xmalloc (sizeof (BAKPREFIX) + strlen (filename) + 1);
        sprintf (backup_name, "%s%s", BAKPREFIX, filename);
    }
    else
    {
        backup_name = xmalloc (sizeof (BAKPREFIX)
                               + strlen (filename)
                               + strlen (suffix)
                               + 2);  /* one for dot, one for trailing '\0' */
        sprintf (backup_name, "%s%s.%s", BAKPREFIX, filename, suffix);
    }

    if (isfile (filename))
        copy_file (filename, backup_name);

    return backup_name;
}

/*
 * Copy a string into a buffer escaping any shell metacharacters.  The
 * buffer should be at least twice as long as the string.
 *
 * Returns a pointer to the terminating NUL byte in buffer.
 */

char *
shell_escape(buf, str)
    char *buf;
    const char *str;
{
    static const char meta[] = "$`\\\"";
    const char *p;

    for (;;)
    {
	p = strpbrk(str, meta);
	if (!p) p = str + strlen(str);
	if (p > str)
	{
	    memcpy(buf, str, p - str);
	    buf += p - str;
	}
	if (!*p) break;
	*buf++ = '\\';
	*buf++ = *p++;
	str = p;
    }
    *buf = '\0';
    return buf;
}

/*
 * We can only travel forwards in time, not backwards.  :)
 */
void
sleep_past (desttime)
    time_t desttime;
{
    time_t t;
    long s;
    long us;

    while (time (&t) <= desttime)
    {
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tv;
	gettimeofday (&tv, NULL);
	if (tv.tv_sec > desttime)
	    break;
	s = desttime - tv.tv_sec;
	if (tv.tv_usec > 0)
	    us = 1000000 - tv.tv_usec;
	else
	{
	    s++;
	    us = 0;
	}
#else
	/* default to 20 ms increments */
	s = desttime - t;
	us = 20000;
#endif

#if defined(HAVE_NANOSLEEP)
	{
	    struct timespec ts;
	    ts.tv_sec = s;
	    ts.tv_nsec = us * 1000;
	    (void)nanosleep (&ts, NULL);
	}
#elif defined(HAVE_USLEEP)
	if (s > 0)
	    (void)sleep (s);
	else
	    (void)usleep (us);
#elif defined(HAVE_SELECT)
	{
	    /* use select instead of sleep since it is a fairly portable way of
	     * sleeping for ms.
	     */
	    struct timeval tv;
	    tv.tv_sec = s;
	    tv.tv_usec = us;
	    (void)select (0, (fd_set *)NULL, (fd_set *)NULL, (fd_set *)NULL, &tv);
	}
#else
	if (us > 0) s++;
	(void)sleep(s);
#endif
    }
}
@


1.3
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d385 1
a385 1
get_date (date, now)
a386 1
    struct timeb *now;
@


1.2
log
@minor string cleanings; tdeval ok
@
text
@d608 1
a608 1
    while (getline (&line, &line_allocated, fp) > 0)
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d12 1
d14 8
a21 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)subr.c 1.64 94/10/07 $";
USE(rcsid);
#endif
d28 1
a28 1
char *
d42 6
a47 1
	error (1, 0, "can not allocate %lu bytes", (unsigned long) bytes);
d56 1
a56 1
char *
d58 1
a58 1
    char *ptr;
d69 6
a74 1
	error (1, 0, "can not reallocate %lu bytes", (unsigned long) bytes);
d78 58
d152 58
a209 3
/*
 * Recover the space allocated by Find_Names() and line2argv()
 */
d221 1
d225 5
a229 5
/*
 * Convert a line into argc/argv components and return the result in the
 * arguments as passed.  Use free_names() to return the memory allocated here
 * back to the free pool.
 */
d231 1
a231 1
line2argv (pargc, argv, line)
d233 1
a233 1
    char **argv;
d235 1
d238 8
d248 1
a248 1
    for (cp = strtok (line, " \t"); cp; cp = strtok ((char *) NULL, " \t"))
d250 6
a255 1
	argv[*pargc] = xstrdup (cp);
d277 53
a329 5
/*
 * Get the caller's login from his uid. If the real uid is "root" try LOGNAME
 * USER or getlogin(). If getlogin() and getpwuid() both fail, return
 * the uid as a string.
 */
d333 2
a334 1
    static char uidname[20];
a335 1
    char *name;
d337 17
d358 2
d361 6
a366 3
	if (((name = getenv("LOGNAME")) || (name = getenv("USER")) ||
	     (name = getlogin ())) && *name)
	    return (name);
d370 5
a374 2
	(void) sprintf (uidname, "uid%lu", (unsigned long) uid);
	return (uidname);
d376 3
a378 1
    return (pw->pw_name);
d402 2
a403 2
    char *rev1;
    char *rev2;
d406 2
a407 2
    char gca[PATH_MAX];
    char *p[2];
d409 1
d417 5
d476 1
a476 1
	char *s;
d509 33
a541 1
    return (xstrdup (gca));
d547 5
a551 1
 *  with '-m'.
d557 95
a651 1
    if ((message == NULL) || (*message == '\0') || isspace (*message))
d653 10
a662 1
        char *t;
d664 8
a671 4
	if (message)
	    for (t = message; *t; t++)
	        if (!isspace (*t))
		    return message;
d673 4
a676 1
	return "*** empty log message ***\n";
d679 214
a892 1
    return message;
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a78 12
/* Remove trailing newlines from STRING, destructively. */
void
strip_trailing_newlines (str)
     char *str;
{
  int len;
  len = strlen (str) - 1;

  while (str[len] == '\n')
    str[len--] = '\0';
}

d151 2
a152 2
	if (((name = getlogin ()) || (name = getenv("LOGNAME")) ||
	     (name = getenv("USER"))) && *name)
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d13 5
d303 1
a303 2
 *  with '-m'.  Returns the original argument or a pointer to readonly
 *  static storage.
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d41 1
a41 1
void *
d43 1
a43 1
    void *ptr;
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a11 1
#include "getline.h"
a317 36
}

/* Does the file FINFO contain conflict markers?  The whole concept
   of looking at the contents of the file to figure out whether there are
   unresolved conflicts is kind of bogus (people do want to manage files
   which contain those patterns not as conflict markers), but for now it
   is what we do.  */
int
file_has_markers (finfo)
    struct file_info *finfo;
{
    FILE *fp;
    char *line = NULL;
    size_t line_allocated = 0;
    int result;

    result = 0;
    fp = CVS_FOPEN (finfo->file, "r");
    if (fp == NULL)
	error (1, errno, "cannot open %s", finfo->fullname);
    while (getline (&line, &line_allocated, fp) > 0)
    {
	if (strncmp (line, RCS_MERGE_PAT, sizeof RCS_MERGE_PAT - 1) == 0)
	{
	    result = 1;
	    goto out;
	}
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", finfo->fullname);
out:
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", finfo->fullname);
    if (line != NULL)
	free (line);
    return result;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a58 37
/* Two constants which tune expand_string.  Having MIN_INCR as large
   as 1024 might waste a bit of memory, but it shouldn't be too bad
   (CVS used to allocate arrays of, say, 3000, PATH_MAX (8192, often),
   or other such sizes).  Probably anything which is going to allocate
   memory which is likely to get as big as MAX_INCR shouldn't be doing
   it in one block which must be contiguous, but since getrcskey does
   so, we might as well limit the wasted memory to MAX_INCR or so
   bytes.  */

#define MIN_INCR 1024
#define MAX_INCR (2*1024*1024)

/* *STRPTR is a pointer returned from malloc (or NULL), pointing to *N
   characters of space.  Reallocate it so that points to at least
   NEWSIZE bytes of space.  Gives a fatal error if out of memory;
   if it returns it was successful.  */
void
expand_string (strptr, n, newsize)
    char **strptr;
    size_t *n;
    size_t newsize;
{
    if (*n < newsize)
    {
	while (*n < newsize)
	{
	    if (*n < MIN_INCR)
		*n += MIN_INCR;
	    else if (*n > MAX_INCR)
		*n += MAX_INCR;
	    else
		*n *= 2;
	}
	*strptr = xrealloc (*strptr, *n);
    }
}

d88 1
a88 1
 * Recover the space allocated by line2argv()
a100 1
    free (argv);
d104 5
a108 5
/* Convert LINE into arguments separated by space and tab.  Set *ARGC
   to the number of arguments found, and (*ARGV)[0] to the first argument,
   (*ARGV)[1] to the second, etc.  *ARGV is malloc'd and so are each of
   (*ARGV)[0], (*ARGV)[1], ...  Use free_names() to return the memory
   allocated here back to the free pool.  */
d112 1
a112 1
    char ***argv;
a115 8
    /* Could make a case for size_t or some other unsigned type, but
       we'll stick with int to avoid signed/unsigned warnings when
       comparing with *pargc.  */
    int argv_allocated;

    /* Small for testing.  */
    argv_allocated = 1;
    *argv = (char **) xmalloc (argv_allocated * sizeof (**argv));
d120 1
a120 6
	if (*pargc == argv_allocated)
	{
	    argv_allocated *= 2;
	    *argv = xrealloc (*argv, argv_allocated * sizeof (**argv));
	}
	(*argv)[*pargc] = xstrdup (cp);
d196 1
a196 1
    char *gca;
a198 1
    char *retval;
a205 5
    /* The greatest common ancestor will have no more dots, and numbers
       of digits for each component no greater than the arguments.  Therefore
       this string will be big enough.  */
    gca = xmalloc (strlen (rev1) + strlen (rev2) + 100);

d293 1
a293 3
    retval = xstrdup (gca);
    free (gca);
    return retval;
@


1.1.1.7
log
@Latest version from Cyclic Software
@
text
@d117 2
a118 2
    int len;
    len = strlen (str) - 1;
d120 2
a121 2
    while (str[len] == '\n')
	str[len--] = '\0';
d124 3
a126 45
/* Return the number of levels that path ascends above where it starts.
   For example:
   "../../foo" -> 2
   "foo/../../bar" -> 1
   */
/* FIXME: Should be using ISDIRSEP, last_component, or some other
   mechanism which is more general than just looking at slashes,
   particularly for the client.c caller.  The server.c caller might
   want something different, so be careful.  */
int
pathname_levels (path)
    char *path;
{
    char *p;
    char *q;
    int level;
    int max_level;

    max_level = 0;
    p = path;
    level = 0;
    do
    {
	q = strchr (p, '/');
	if (q != NULL)
	    ++q;
	if (p[0] == '.' && p[1] == '.' && (p[2] == '\0' || p[2] == '/'))
	{
	    --level;
	    if (-level > max_level)
		max_level = -level;
	}
	else if (p[0] == '.' && (p[1] == '\0' || p[1] == '/'))
	    ;
	else
	    ++level;
	p = q;
    } while (p != NULL);
    return max_level;
}


/* Free a vector, where (*ARGV)[0], (*ARGV)[1], ... (*ARGV)[*PARGC - 1]
   are malloc'd and so is *ARGV itself.  Such a vector is allocated by
   line2argv or expand_wild, for example.  */
d160 1
a160 3
    /* argv_allocated must be at least 3 because at some places
       (e.g. checkout_proc) cvs alters argv[2].  */
    argv_allocated = 4;
d193 5
a197 7
/* Return the username by which the caller should be identified in
   CVS, in contexts such as the author field of RCS files, various
   logs, etc.

   Returns a pointer to storage that we manage; it is good until the
   next call to getcaller () (provided that the caller doesn't call
   getlogin () or some such themself).  */
a204 10

    /* If there is a CVS username, return it.  */
#ifdef AUTH_SERVER_SUPPORT
    if (CVS_Username != NULL)
	return CVS_Username;
#endif

    /* Get the caller's login from his uid.  If the real uid is "root"
       try LOGNAME USER or getlogin(). If getlogin() and getpwuid()
       both fail, return the uid as a string.  */
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d33 1
a33 2
	error (1, 0, "out of memory; can not allocate %lu bytes",
	       (unsigned long) bytes);
d184 1
a184 1
/* Convert LINE into arguments separated by SEPCHARS.  Set *ARGC
d190 1
a190 1
line2argv (pargc, argv, line, sepchars)
a193 1
    char *sepchars;
d208 1
a208 1
    for (cp = strtok (line, sepchars); cp; cp = strtok ((char *) NULL, sepchars))
a236 50
/* Compare revision numbers REV1 and REV2 by consecutive fields.
   Return negative, zero, or positive in the manner of strcmp.  The
   two revision numbers must have the same number of fields, or else
   compare_revnums will return an inaccurate result. */
int
compare_revnums (rev1, rev2)
    const char *rev1;
    const char *rev2;
{
    const char *s, *sp;
    const char *t, *tp;
    char *snext, *tnext;
    int result = 0;

    sp = s = rev1;
    tp = t = rev2;
    while (result == 0)
    {
	result = strtoul (sp, &snext, 10) - strtoul (tp, &tnext, 10);
	if (*snext == '\0' || *tnext == '\0')
	    break;
	sp = snext + 1;
	tp = tnext + 1;
    }

    return result;
}

char *
increment_revnum (rev)
    const char *rev;
{
    char *newrev, *p;
    int lastfield;
    size_t len = strlen (rev);

    newrev = (char *) xmalloc (len + 2);
    memcpy (newrev, rev, len + 1);
    p = strrchr (newrev, '.');
    if (p == NULL)
    {
	free (newrev);
	return NULL;
    }
    lastfield = atoi (++p);
    sprintf (p, "%d", lastfield + 1);

    return newrev;
}

a246 1
#ifndef SYSTEM_GETCALLER
a250 1
#endif
a257 3
#ifdef SYSTEM_GETCALLER
    return SYSTEM_GETCALLER ();
#else
a275 1
#endif
d299 2
a300 2
    const char *rev1;
    const char *rev2;
d304 1
a304 1
    const char *p[2];
d373 1
a373 1
	const char *s;
a410 30
/* Give fatal error if REV is numeric and ARGC,ARGV imply we are
   planning to operate on more than one file.  The current directory
   should be the working directory.  Note that callers assume that we
   will only be checking the first character of REV; it need not have
   '\0' at the end of the tag name and other niceties.  Right now this
   is only called from admin.c, but if people like the concept it probably
   should also be called from diff -r, update -r, get -r, and log -r.  */

void
check_numeric (rev, argc, argv)
    const char *rev;
    int argc;
    char **argv;
{
    if (rev == NULL || !isdigit (*rev))
	return;

    /* Note that the check for whether we are processing more than one
       file is (basically) syntactic; that is, we don't behave differently
       depending on whether a directory happens to contain only a single
       file or whether it contains more than one.  I strongly suspect this
       is the least confusing behavior.  */
    if (argc != 1
	|| (!wrap_name_has (argv[0], WRAP_TOCVS) && isdir (argv[0])))
    {
	error (0, 0, "while processing more than one file:");
	error (1, 0, "attempt to specify a numeric revision");
    }
}

d414 2
a415 5
 *  with '-m'.  Returns a newly allocated, non-empty buffer with whitespace
 *  stripped from end of lines and end of buffer.
 *
 *  TODO: We no longer use RCS to manage repository files, so maybe this
 *  nonsense about non-empty log fields can be dropped.
d421 1
a421 7
    char *dst, *dp, *mp;

    if (message == NULL) message = "";

    /* Strip whitespace from end of lines and end of string. */
    dp = dst = (char *) xmalloc (strlen (message) + 1);
    for (mp = message; *mp != '\0'; ++mp)
d423 1
a423 8
	if (*mp == '\n')
	{
	    /* At end-of-line; backtrack to last non-space. */
	    while (dp > dst && (dp[-1] == ' ' || dp[-1] == '\t'))
		--dp;
	}
	*dp++ = *mp;
    }
d425 4
a428 4
    /* Backtrack to last non-space at end of string, and truncate. */
    while (dp > dst && isspace (dp[-1]))
	--dp;
    *dp = '\0';
d430 1
a430 6
    /* After all that, if there was no non-space in the string,
       substitute a non-empty message. */
    if (*dst == '\0')
    {
	free (dst);
	dst = xstrdup ("*** empty log message ***");
d433 1
a433 1
    return dst;
d443 1
a443 1
    const struct file_info *finfo;
a469 92
}

/* Read the entire contents of the file NAME into *BUF.
   If NAME is NULL, read from stdin.  *BUF
   is a pointer returned from malloc (or NULL), pointing to *BUFSIZE
   bytes of space.  The actual size is returned in *LEN.  On error,
   give a fatal error.  The name of the file to use in error messages
   (typically will include a directory if we have changed directory)
   is FULLNAME.  MODE is "r" for text or "rb" for binary.  */

void
get_file (name, fullname, mode, buf, bufsize, len)
    const char *name;
    const char *fullname;
    const char *mode;
    char **buf;
    size_t *bufsize;
    size_t *len;
{
    struct stat s;
    size_t nread;
    char *tobuf;
    FILE *e;
    size_t filesize;

    if (name == NULL)
    {
	e = stdin;
	filesize = 100;	/* force allocation of minimum buffer */
    }
    else
    {
	if (CVS_STAT (name, &s) < 0)
	    error (1, errno, "can't stat %s", fullname);
	/* Convert from signed to unsigned.  */
	filesize = s.st_size;

	e = open_file (name, mode);
    }

    if (*bufsize < filesize)
    {
	*bufsize = filesize;
	*buf = xrealloc (*buf, *bufsize);
    }

    tobuf = *buf;
    nread = 0;
    while (1)
    {
	size_t got;

	got = fread (tobuf, 1, *bufsize - (tobuf - *buf), e);
	if (ferror (e))
	    error (1, errno, "can't read %s", fullname);
	nread += got;
	tobuf += got;

	if (feof (e))
	    break;

	/* It's probably paranoid to think S.ST_SIZE might be
	   too small to hold the entire file contents, but we
	   handle it just in case.  */
	if (tobuf == *buf + *bufsize)
	{
	    int c;
	    long off;

	    c = getc (e);
	    if (c == EOF)
		break;
	    off = tobuf - *buf;
	    expand_string (buf, bufsize, *bufsize + 100);
	    tobuf = *buf + off;
	    *tobuf++ = c;
	    ++nread;
	}
    }

    if (e != stdin && fclose (e) < 0)
	error (0, errno, "cannot close %s", fullname);

    *len = nread;

    /* Force *BUF to be large enough to hold a null terminator. */
    if (*buf != NULL)
    {
	if (nread == *bufsize)
	    expand_string (buf, bufsize, *bufsize + 1);
	(*buf)[nread] = '\0';
    }
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d291 5
a295 1
   logs, etc.  */
d300 1
a300 1
    static char *cache;
d302 1
a318 3
    if (cache != NULL)
	return cache;

a321 2
	char *name;

d325 1
a325 4
	{
	    cache = xstrdup (name);
	    return cache;
	}
a328 2
	char uidname[20];

d330 1
a330 2
	cache = xstrdup (uidname);
	return cache;
d332 1
a332 2
    cache = xstrdup (pw->pw_name);
    return cache;
d611 1
a611 1
	if (CVS_LSTAT (name, &s) < 0)
a612 8

	/* Don't attempt to read special files or symlinks. */
	if (!S_ISREG (s.st_mode))
	{
	    *len = 0;
	    return;
	}

@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d67 1
a67 5
   bytes.

   MIN_INCR and MAX_INCR should both be powers of two and we generally
   try to keep our allocations to powers of two for the most part.
   Most malloc implementations these days tend to like that.  */
d87 2
a88 2
		*n = MIN_INCR;
	    else if (*n >= MAX_INCR)
a90 1
	    {
a91 3
		if (*n > MAX_INCR)
		    *n = MAX_INCR;
	    }
d490 1
a490 1
    if (rev == NULL || !isdigit ((unsigned char) *rev))
d537 1
a537 1
    while (dp > dst && isspace ((unsigned char) dp[-1]))
a684 46
    }
}


/* Follow a chain of symbolic links to its destination.  FILENAME
   should be a handle to a malloc'd block of memory which contains the
   beginning of the chain.  This routine will replace the contents of
   FILENAME with the destination (a real file).  */

void
resolve_symlink (filename)
     char **filename;
{
    if ((! filename) || (! *filename))
	return;

    while (islink (*filename))
    {
	char *newname;
#ifdef HAVE_READLINK
	/* The clean thing to do is probably to have each filesubr.c
	   implement this (with an error if not supported by the
	   platform, in which case islink would presumably return 0).
	   But that would require editing each filesubr.c and so the
	   expedient hack seems to be looking at HAVE_READLINK.  */
	newname = xreadlink (*filename);
#else
	error (1, 0, "internal error: islink doesn't like readlink");
#endif
	
	if (isabsolute (newname))
	{
	    free (*filename);
	    *filename = newname;
	}
	else
	{
	    char *oldname = last_component (*filename);
	    int dirlen = oldname - *filename;
	    char *fullnewname = xmalloc (dirlen + strlen (newname) + 1);
	    strncpy (fullnewname, *filename, dirlen);
	    strcpy (fullnewname + dirlen, newname);
	    free (newname);
	    free (*filename);
	    *filename = fullnewname;
	}
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d19 1
a19 1
void *
d33 2
a34 6
    {
	char buf[80];
	sprintf (buf, "out of memory; can not allocate %lu bytes",
		 (unsigned long) bytes);
	error (1, 0, buf);
    }
d56 1
a56 6
    {
	char buf[80];
	sprintf (buf, "out of memory; can not reallocate %lu bytes",
		 (unsigned long) bytes);
	error (1, 0, buf);
    }
d626 2
a627 5
	/* Although it would be cleaner in some ways to just read
	   until end of file, reallocating the buffer, this function
	   does get called on files in the working directory which can
	   be of arbitrary size, so I think we better do all that
	   extra allocation.  */
d629 6
a634 2
	if (CVS_STAT (name, &s) < 0)
	    error (1, errno, "can't stat %s", fullname);
d663 3
a665 1
	/* Allocate more space if needed.  */
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d174 1
a174 2
	else if (p[0] == '\0' || p[0] == '/' ||
		 (p[0] == '.' && (p[1] == '\0' || p[1] == '/')))
d221 3
a223 1
    argv_allocated = 1;
d589 1
a589 3
	if (strncmp (line, RCS_MERGE_PAT_1, sizeof RCS_MERGE_PAT_1 - 1) == 0 ||
	    strncmp (line, RCS_MERGE_PAT_2, sizeof RCS_MERGE_PAT_2 - 1) == 0 ||
	    strncmp (line, RCS_MERGE_PAT_3, sizeof RCS_MERGE_PAT_3 - 1) == 0)
d650 1
a650 1
    if (*buf == NULL || *bufsize <= filesize)
d652 1
a652 1
	*bufsize = filesize + 1;
d694 6
a699 3
    if (nread == *bufsize)
	expand_string (buf, bufsize, *bufsize + 1);
    (*buf)[nread] = '\0';
a746 34

/*
 * Rename a file to an appropriate backup name based on BAKPREFIX.
 * If suffix non-null, then ".<suffix>" is appended to the new name.
 *
 * Returns the new name, which caller may free() if desired.
 */
char *
backup_file (filename, suffix)
     const char *filename;
     const char *suffix;
{
    char *backup_name;

    if (suffix == NULL)
    {
        backup_name = xmalloc (sizeof (BAKPREFIX) + strlen (filename) + 1);
        sprintf (backup_name, "%s%s", BAKPREFIX, filename);
    }
    else
    {
        backup_name = xmalloc (sizeof (BAKPREFIX)
                               + strlen (filename)
                               + strlen (suffix)
                               + 2);  /* one for dot, one for trailing '\0' */
        sprintf (backup_name, "%s%s.%s", BAKPREFIX, filename, suffix);
    }

    if (isfile (filename))
        copy_file (filename, backup_name);

    return backup_name;
}

@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@a13 9
#ifdef HAVE_NANOSLEEP
# include "xtime.h"
#else /* HAVE_NANOSLEEP */
# if !defined HAVE_USLEEP && defined HAVE_SELECT
    /* use select as a workaround */
#   include "xselect.h"
# endif /* !defined HAVE_USLEEP && defined HAVE_SELECT */
#endif /* !HAVE_NANOSLEEP */

a113 13
/* *STR is a pointer to a malloc'd string.  *LENP is its allocated
   length.  Add SRC to the end of it, reallocating if necessary.  */
void
allocate_and_strcat (str, lenp, src)
    char **str;
    size_t *lenp;
    const char *src;
{

    expand_string (str, lenp, strlen (*str) + strlen (src) + 1);
    strcat (*str, src);
}

a778 93
/*
 * Copy a string into a buffer escaping any shell metacharacters.  The
 * buffer should be at least twice as long as the string.
 *
 * Returns a pointer to the terminating NUL byte in buffer.
 */

char *
shell_escape(buf, str)
    char *buf;
    const char *str;
{
    static const char meta[] = "$`\\\"";
    const char *p;

    for (;;)
    {
	p = strpbrk(str, meta);
	if (!p) p = str + strlen(str);
	if (p > str)
	{
	    memcpy(buf, str, p - str);
	    buf += p - str;
	}
	if (!*p) break;
	*buf++ = '\\';
	*buf++ = *p++;
	str = p;
    }
    *buf = '\0';
    return buf;
}

/*
 * We can only travel forwards in time, not backwards.  :)
 */
void
sleep_past (desttime)
    time_t desttime;
{
    time_t t;
    long s;
    long us;

    while (time (&t) <= desttime)
    {
#ifdef HAVE_GETTIMEOFDAY
	struct timeval tv;
	gettimeofday (&tv, NULL);
	if (tv.tv_sec > desttime)
	    break;
	s = desttime - tv.tv_sec;
	if (tv.tv_usec > 0)
	    us = 1000000 - tv.tv_usec;
	else
	{
	    s++;
	    us = 0;
	}
#else
	/* default to 20 ms increments */
	s = desttime - t;
	us = 20000;
#endif

#if defined(HAVE_NANOSLEEP)
	{
	    struct timespec ts;
	    ts.tv_sec = s;
	    ts.tv_nsec = us * 1000;
	    (void)nanosleep (&ts, NULL);
	}
#elif defined(HAVE_USLEEP)
	if (s > 0)
	    (void)sleep (s);
	else
	    (void)usleep (us);
#elif defined(HAVE_SELECT)
	{
	    /* use select instead of sleep since it is a fairly portable way of
	     * sleeping for ms.
	     */
	    struct timeval tv;
	    tv.tv_sec = s;
	    tv.tv_usec = us;
	    (void)select (0, (fd_set *)NULL, (fd_set *)NULL, (fd_set *)NULL, &tv);
	}
#else
	if (us > 0) s++;
	(void)sleep(s);
#endif
    }
}
@


