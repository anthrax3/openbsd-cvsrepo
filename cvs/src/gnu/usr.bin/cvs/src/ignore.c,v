head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.24
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.22
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.18
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.14
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.16
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.8
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.12
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.10
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.6
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.4
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.14.0.42
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.40
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.38
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.34
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.36
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.32
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.30
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.28
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.26
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.24
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.22
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.20
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.18
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.16
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.14
	OPENBSD_3_6_BASE:1.14
	OPENBSD_3_5:1.14.0.12
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.10
	OPENBSD_3_4_BASE:1.14
	OPENBSD_3_3:1.14.0.8
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.6
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_9_BASE:1.13
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2012.03.26.16.40.07;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.05.19.45.20;	author espie;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.21.57.52;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	98.02.22.08.55.59;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.06.28.03.45.28;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	97.03.29.04.49.51;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.03.18.02.09.56;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.02.21.06.54.54;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.11.09.13.58.48;	author michaels;	state Exp;
branches;
next	1.5;

1.5
date	96.10.18.04.19.32;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.05.06.22.51.14;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.20.26.19;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.01.07.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.10;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.55;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.37;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.36;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.33;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.08;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.38.14;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.43;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.16;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.32.58;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.42;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Adjust the default "ignore" list for cvs;
- don't ignore "core", it gets in the way when we import certain things
- ignore "*.core" to match the actual filenames we use for core dumps
suggested by landry@@
- ignore ".git" to avoid accidental imports of the directory when used
locally "on top of" cvs

various versions ok'd by landry@@ todd@@ espie@@ phessler@@ dcoppa@@
@
text
@/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

/*
 * .cvsignore file support contributed by David G. Grubbs <dgg@@odi.com>
 */

#include "cvs.h"
#include "getline.h"

/*
 * Ignore file section.
 * 
 *	"!" may be included any time to reset the list (i.e. ignore nothing);
 *	"*" may be specified to ignore everything.  It stays as the first
 *	    element forever, unless a "!" clears it out.
 */

static char **ign_list;			/* List of files to ignore in update
					 * and import */
static char **s_ign_list = NULL;
static int ign_count;			/* Number of active entries */
static int s_ign_count = 0;
static int ign_size;			/* This many slots available (plus
					 * one for a NULL) */
static int ign_hold = -1;		/* Index where first "temporary" item
					 * is held */

const char *ign_default = ". .. RCSLOG tags TAGS RCS SCCS .make.state\
 .*.swp *.core .git\
 .nse_depinfo #* .#* cvslog.* ,* CVS CVS.adm .del-* *.a *.olb *.o *.obj\
 *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej *.exe _$* *$ *.depend";

#define IGN_GROW 16			/* grow the list by 16 elements at a
					 * time */

/* Nonzero if we have encountered an -I ! directive, which means one should
   no longer ask the server about what is in CVSROOTADM_IGNORE.  */
int ign_inhibit_server;

/*
 * To the "ignore list", add the hard-coded default ignored wildcards above,
 * the wildcards found in $CVSROOT/CVSROOT/cvsignore, the wildcards found in
 * ~/.cvsignore and the wildcards found in the CVSIGNORE environment
 * variable.
 */
void
ign_setup ()
{
    char *home_dir;
    char *tmp;

    ign_inhibit_server = 0;

    /* Start with default list and special case */
    tmp = xstrdup (ign_default);
    ign_add (tmp, 0);
    free (tmp);

#ifdef CLIENT_SUPPORT
    /* The client handles another way, by (after it does its own ignore file
       processing, and only if !ign_inhibit_server), letting the server
       know about the files and letting it decide whether to ignore
       them based on CVSROOOTADM_IGNORE.  */
    if (!current_parsed_root->isremote)
#endif
    {
	char *file = xmalloc (strlen (current_parsed_root->directory) + sizeof (CVSROOTADM)
			      + sizeof (CVSROOTADM_IGNORE) + 10);
	/* Then add entries found in repository, if it exists */
	(void) sprintf (file, "%s/%s/%s", current_parsed_root->directory,
			CVSROOTADM, CVSROOTADM_IGNORE);
	ign_add_file (file, 0);
	free (file);
    }

    /* Then add entries found in home dir, (if user has one) and file exists */
    home_dir = get_homedir ();
    /* If we can't find a home directory, ignore ~/.cvsignore.  This may
       make tracking down problems a bit of a pain, but on the other
       hand it might be obnoxious to complain when CVS will function
       just fine without .cvsignore (and many users won't even know what
       .cvsignore is).  */
    if (home_dir)
    {
	char *file = xmalloc (strlen (home_dir) + sizeof (CVSDOTIGNORE) + 10);
	(void) sprintf (file, "%s/%s", home_dir, CVSDOTIGNORE);
	ign_add_file (file, 0);
	free (file);
    }

    /* Then add entries found in CVSIGNORE environment variable. */
    ign_add (getenv (IGNORE_ENV), 0);

    /* Later, add ignore entries found in -I arguments */
}

/*
 * Open a file and read lines, feeding each line to a line parser. Arrange
 * for keeping a temporary list of wildcards at the end, if the "hold"
 * argument is set.
 */
void
ign_add_file (file, hold)
    char *file;
    int hold;
{
    FILE *fp;
    char *line = NULL;
    size_t line_allocated = 0;

    /* restore the saved list (if any) */
    if (s_ign_list != NULL)
    {
	int i;

	for (i = 0; i < s_ign_count; i++)
	    ign_list[i] = s_ign_list[i];
	ign_count = s_ign_count;
	ign_list[ign_count] = NULL;

	s_ign_count = 0;
	free (s_ign_list);
	s_ign_list = NULL;
    }

    /* is this a temporary ignore file? */
    if (hold)
    {
	/* re-set if we had already done a temporary file */
	if (ign_hold >= 0)
	{
	    int i;

	    for (i = ign_hold; i < ign_count; i++)
		free (ign_list[i]);
	    ign_count = ign_hold;
	    ign_list[ign_count] = NULL;
	}
	else
	{
	    ign_hold = ign_count;
	}
    }

    /* load the file */
    fp = CVS_FOPEN (file, "r");
    if (fp == NULL)
    {
	if (! existence_error (errno))
	    error (0, errno, "cannot open %s", file);
	return;
    }
    while (get_line (&line, &line_allocated, fp) >= 0)
	ign_add (line, hold);
    if (ferror (fp))
	error (0, errno, "cannot read %s", file);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", file);
    free (line);
}

/* Parse a line of space-separated wildcards and add them to the list. */
void
ign_add (ign, hold)
    char *ign;
    int hold;
{
    if (!ign || !*ign)
	return;

    for (; *ign; ign++)
    {
	char *mark;
	char save;

	/* ignore whitespace before the token */
	if (isspace ((unsigned char) *ign))
	    continue;

	/*
	 * if we find a single character !, we must re-set the ignore list
	 * (saving it if necessary).  We also catch * as a special case in a
	 * global ignore file as an optimization
	 */
	if ((!*(ign+1) || isspace ((unsigned char) *(ign+1)))
	    && (*ign == '!' || *ign == '*'))
	{
	    if (!hold)
	    {
		/* permanently reset the ignore list */
		int i;

		for (i = 0; i < ign_count; i++)
		    free (ign_list[i]);
		ign_count = 0;
		ign_list[0] = NULL;

		/* if we are doing a '!', continue; otherwise add the '*' */
		if (*ign == '!')
		{
		    ign_inhibit_server = 1;
		    continue;
		}
	    }
	    else if (*ign == '!')
	    {
		/* temporarily reset the ignore list */
		int i;

		if (ign_hold >= 0)
		{
		    for (i = ign_hold; i < ign_count; i++)
			free (ign_list[i]);
		    ign_hold = -1;
		}
		s_ign_list = (char **) xmalloc (ign_count * sizeof (char *));
		for (i = 0; i < ign_count; i++)
		    s_ign_list[i] = ign_list[i];
		s_ign_count = ign_count;
		ign_count = 0;
		ign_list[0] = NULL;
		continue;
	    }
	}

	/* If we have used up all the space, add some more */
	if (ign_count >= ign_size)
	{
	    ign_size += IGN_GROW;
	    ign_list = (char **) xrealloc ((char *) ign_list,
					   (ign_size + 1) * sizeof (char *));
	}

	/* find the end of this token */
	for (mark = ign; *mark && !isspace ((unsigned char) *mark); mark++)
	     /* do nothing */ ;

	save = *mark;
	*mark = '\0';

	ign_list[ign_count++] = xstrdup (ign);
	ign_list[ign_count] = NULL;

	*mark = save;
	if (save)
	    ign = mark;
	else
	    ign = mark - 1;
    }
}

/* Set to 1 if filenames should be matched in a case-insensitive
   fashion.  Note that, contrary to the name and placement in ignore.c,
   this is no longer just for ignore patterns.  */
int ign_case;

/* Return 1 if the given filename should be ignored by update or import. */
int
ign_name (name)
    char *name;
{
    char **cpp = ign_list;

    if (cpp == NULL)
	return (0);

    if (ign_case)
    {
	/* We do a case-insensitive match by calling fnmatch on copies of
	   the pattern and the name which have been converted to
	   lowercase.  FIXME: would be much cleaner to just unify this
	   with the other case-insensitive fnmatch stuff (FOLD_FN_CHAR
	   in lib/fnmatch.c; os2_fnmatch in emx/system.c).  */
	char *name_lower;
	char *pat_lower;
	char *p;

	name_lower = xstrdup (name);
	for (p = name_lower; *p != '\0'; ++p)
	    *p = tolower (*p);
	while (*cpp)
	{
	    pat_lower = xstrdup (*cpp++);
	    for (p = pat_lower; *p != '\0'; ++p)
		*p = tolower (*p);
	    if (CVS_FNMATCH (pat_lower, name_lower, 0) == 0)
		goto matched;
	    free (pat_lower);
	}
	free (name_lower);
	return 0;
      matched:
	free (name_lower);
	free (pat_lower);
	return 1;
    }
    else
    {
	while (*cpp)
	    if (CVS_FNMATCH (*cpp++, name, 0) == 0)
		return 1;
	return 0;
    }
}

/* FIXME: This list of dirs to ignore stuff seems not to be used.
   Really?  send_dirent_proc and update_dirent_proc both call
   ignore_directory and do_module calls ign_dir_add.  No doubt could
   use some documentation/testsuite work.  */

static char **dir_ign_list = NULL;
static int dir_ign_max = 0;
static int dir_ign_current = 0;

/* Add a directory to list of dirs to ignore.  */
void
ign_dir_add (name)
    char *name;
{
    /* Make sure we've got the space for the entry.  */
    if (dir_ign_current <= dir_ign_max)
    {
	dir_ign_max += IGN_GROW;
	dir_ign_list =
	    (char **) xrealloc (dir_ign_list,
				(dir_ign_max + 1) * sizeof (char *));
    }

    dir_ign_list[dir_ign_current++] = xstrdup (name);
}


/* Return nonzero if NAME is part of the list of directories to ignore.  */

int
ignore_directory (name)
    char *name;
{
    int i;

    if (!dir_ign_list)
	return 0;

    i = dir_ign_current;
    while (i--)
    {
	if (strncmp (name, dir_ign_list[i], strlen (dir_ign_list[i])) == 0)
	    return 1;
    }

    return 0;
}

/*
 * Process the current directory, looking for files not in ILIST and
 * not on the global ignore list for this directory.  If we find one,
 * call PROC passing it the name of the file and the update dir.
 * ENTRIES is the entries list, which is used to identify known
 * directories.  ENTRIES may be NULL, in which case we assume that any
 * directory with a CVS administration directory is known.
 */
void
ignore_files (ilist, entries, update_dir, proc)
    List *ilist;
    List *entries;
    char *update_dir;
    Ignore_proc proc;
{
    int subdirs;
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    char *file;
    char *xdir;
    List *files;
    Node *p;

    /* Set SUBDIRS if we have subdirectory information in ENTRIES.  */
    if (entries == NULL)
	subdirs = 0;
    else
    {
	struct stickydirtag *sdtp;

	sdtp = (struct stickydirtag *) entries->list->data;
	subdirs = sdtp == NULL || sdtp->subdirs;
    }

    /* we get called with update_dir set to "." sometimes... strip it */
    if (strcmp (update_dir, ".") == 0)
	xdir = "";
    else
	xdir = update_dir;

    dirp = CVS_OPENDIR (".");
    if (dirp == NULL)
    {
	error (0, errno, "cannot open current directory");
	return;
    }

    ign_add_file (CVSDOTIGNORE, 1);
    wrap_add_file (CVSDOTWRAPPER, 1);

    /* Make a list for the files.  */
    files = getlist ();

    while (errno = 0, (dp = CVS_READDIR (dirp)) != NULL)
    {
	file = dp->d_name;
	if (strcmp (file, ".") == 0 || strcmp (file, "..") == 0)
	    continue;
	if (findnode_fn (ilist, file) != NULL)
	    continue;
	if (subdirs)
	{
	    Node *node;

	    node = findnode_fn (entries, file);
	    if (node != NULL
		&& ((Entnode *) node->data)->type == ENT_SUBDIR)
	    {
		char *p;
		int dir;

		/* For consistency with past behaviour, we only ignore
		   this directory if there is a CVS subdirectory.
		   This will normally be the case, but the user may
		   have messed up the working directory somehow.  */
		p = xmalloc (strlen (file) + sizeof CVSADM + 10);
		sprintf (p, "%s/%s", file, CVSADM);
		dir = isdir (p);
		free (p);
		if (dir)
		    continue;
	    }
	}

	/* We could be ignoring FIFOs and other files which are neither
	   regular files nor directories here.  */
	if (ign_name (file))
	    continue;

	if (
#ifdef DT_DIR
		dp->d_type != DT_UNKNOWN ||
#endif
		lstat(file, &sb) != -1) 
	{

	    if (
#ifdef DT_DIR
		dp->d_type == DT_DIR
		|| (dp->d_type == DT_UNKNOWN && S_ISDIR (sb.st_mode))
#else
		S_ISDIR (sb.st_mode)
#endif
		)
	    {
		if (! subdirs)
		{
		    char *temp;

		    temp = xmalloc (strlen (file) + sizeof (CVSADM) + 10);
		    (void) sprintf (temp, "%s/%s", file, CVSADM);
		    if (isdir (temp))
		    {
			free (temp);
			continue;
		    }
		    free (temp);
		}
	    }
#ifdef S_ISLNK
	    else if (
#ifdef DT_DIR
		     dp->d_type == DT_LNK
		     || (dp->d_type == DT_UNKNOWN && S_ISLNK(sb.st_mode))
#else
		     S_ISLNK (sb.st_mode)
#endif
		     )
	    {
		continue;
	    }
#endif
	}

	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (file);
	(void) addnode (files, p);
    }
    if (errno != 0)
	error (0, errno, "error reading current directory");
    (void) CVS_CLOSEDIR (dirp);

    sortlist (files, fsortcmp);
    for (p = files->list->next; p != files->list; p = p->next)
	(*proc) (p->key, xdir);
    dellist (&files);
}
@


1.16
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d36 2
a37 2
const char *ign_default = ". .. core RCSLOG tags TAGS RCS SCCS .make.state\
 .*.swp\
@


1.15
log
@ignore vim's .*.swp files.
okay fgs@@, millert@@
@
text
@d161 1
a161 1
    while (getline (&line, &line_allocated, fp) >= 0)
@


1.14
log
@Merge local changes; work in progress
@
text
@d37 1
@


1.13
log
@Integrate local changes
@
text
@d71 1
a71 1
    if (!client_active)
d74 1
a74 1
	char *file = xmalloc (strlen (CVSroot_directory) + sizeof (CVSROOTADM)
d77 1
a77 1
	(void) sprintf (file, "%s/%s/%s", CVSroot_directory,
d382 2
d412 4
a415 2
    errno = 0;
    while ((dp = readdir (dirp)) != NULL)
d419 1
a419 1
	    goto continue_loop;
d421 1
a421 1
	    goto continue_loop;
d442 1
a442 1
		    goto continue_loop;
d449 1
a449 1
	    goto continue_loop;
d476 1
a476 1
			goto continue_loop;
d491 1
a491 1
		goto continue_loop;
d494 1
a494 1
    	}
d496 4
a499 3
	(*proc) (file, xdir);
    continue_loop:
	errno = 0;
d503 6
a508 1
    (void) closedir (dirp);
@


1.12
log
@Integrate local changes
@
text
@d336 1
a336 3
    dir_ign_list[dir_ign_current] = name;

    dir_ign_current += 1 ;
d415 1
a415 1
	    continue;
d417 1
a417 1
	    continue;
d438 1
a438 1
		    continue;
d445 1
a445 1
	    continue;
d456 4
a459 1
		dp->d_type == DT_DIR || dp->d_type == DT_UNKNOWN &&
d461 1
a461 1
		S_ISDIR(sb.st_mode))
d472 1
a472 1
			continue;
d480 4
a483 1
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN && 
d485 1
a485 1
		S_ISLNK(sb.st_mode))
d487 1
a487 1
		continue;
d493 1
@


1.11
log
@Integrate local changes
@
text
@d85 5
d184 1
a184 1
	if (isspace (*ign))
d192 2
a193 1
	if ((!*(ign+1) || isspace (*(ign+1))) && (*ign == '!' || *ign == '*'))
d242 1
a242 1
	for (mark = ign; *mark && !isspace (*mark); mark++)
d404 2
d407 1
d412 1
d489 1
d491 2
@


1.10
log
@Integrate local changes
@
text
@d307 4
a310 1
/* FIXME: This list of dirs to ignore stuff seems not to be used.  */
d316 4
a319 3
/* add a directory to list of dirs to ignore */
void ign_dir_add (name)
     char *name;
d321 2
a322 2
  /* make sure we've got the space for the entry */
  if (dir_ign_current <= dir_ign_max)
d324 4
a327 2
      dir_ign_max += IGN_GROW;
      dir_ign_list = (char **) xrealloc ((char *) dir_ign_list, (dir_ign_max+1) * sizeof(char*));
d330 1
a330 1
  dir_ign_list[dir_ign_current] = name;
d332 1
a332 1
  dir_ign_current += 1 ;
d336 1
a336 3
/* this function returns 1 (true) if the given directory name is part of
 * the list of directories to ignore
 */
d338 3
a340 2
int ignore_directory (name)
     char *name;
d342 1
a342 1
  int i;
d344 2
a345 2
  if (!dir_ign_list)
    return 0;
d347 2
a348 2
  i = dir_ign_current;
  while (i--)
d350 2
a351 2
      if (strncmp(name, dir_ign_list[i], strlen(dir_ign_list[i])) == 0)
	return 1;
d354 1
a354 1
  return 0;
@


1.9
log
@Integrate local changes
@
text
@d272 3
a274 1
	   lowercase.  */
d287 1
a287 1
	    if (fnmatch (pat_lower, name_lower, 0) == 0)
d301 1
a301 1
	    if (fnmatch (*cpp++, name, 0) == 0)
@


1.8
log
@Integrate local changes
@
text
@d253 3
a255 2
/* Set to 1 if ignore file patterns should be matched in a case-insensitive
   fashion.  */
@


1.7
log
@Integrate local changes
@
text
@d1 10
d16 1
d110 2
a111 2
    /* FIXME: arbitrary limit.  */
    char line[1024];
d155 1
a155 1
    while (fgets (line, sizeof (line), fp))
d157 2
d161 1
@


1.6
log
@ignore "*.depend".
@
text
@a45 1
    char file[PATH_MAX];
d63 2
d69 1
d76 1
d79 1
d99 1
d432 1
a432 1
		    char temp[PATH_MAX];
d434 1
d437 2
d440 2
@


1.5
log
@Integrate local changes
@
text
@d27 1
a27 1
 *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej *.exe _$* *$";
@


1.4
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d23 1
a23 1
					 * is held, -1 if none.  */
d45 1
a45 1
    struct passwd *pw;
d65 2
a66 2
	(void) sprintf (file, "%s/%s/%s", CVSroot, CVSROOTADM,
			CVSROOTADM_IGNORE);
d71 2
a72 1
    if ((pw = (struct passwd *) getpwuid (getuid ())) && pw->pw_dir)
d74 1
a74 1
	(void) sprintf (file, "%s/%s", pw->pw_dir, CVSDOTIGNORE);
d132 1
a132 1
    fp = fopen (file, "r");
d331 6
a336 3
 * Process the current directory, looking for files not in ILIST and not on
 * the global ignore list for this directory.  If we find one, call PROC
 * passing it the name of the file and the update dir.
d339 1
a339 1
ignore_files (ilist, update_dir, proc)
d341 1
d345 1
d352 11
d369 1
a369 1
    dirp = opendir (".");
d383 28
d425 3
a427 1
		char temp[PATH_MAX];
d429 4
a432 3
		(void) sprintf (temp, "%s/%s", file, CVSADM);
		if (isdir (temp))
		    continue;
a445 4
	/* We could be ignoring FIFOs and other files which are neither
	   regular files nor directories here.  */
	if (ign_name (file))
	    continue;
@


1.3
log
@Integrate local changes to CVS
@
text
@d25 3
a27 1
const char *ign_default = ". .. core RCSLOG tags TAGS RCS SCCS .make.state .nse_depinfo #* .#* cvslog.* ,* CVS CVS.adm .del-* *.a *.o *.obj *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej";
d233 4
d247 35
a281 4
    while (*cpp)
	if (fnmatch (*cpp++, name, 0) == 0)
	    return (1);
    return (0);
d283 2
a284 1

d328 1
a328 1

@


1.2
log
@Make cvs import -I ! work wrt .cvsignore files
@
text
@a6 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)ignore.c 1.16 94/09/24 $";
USE(rcsid);
#endif

@


1.1
log
@Initial revision
@
text
@d27 2
a28 2
static int ign_hold;			/* Index where first "temporary" item
					 * is held */
d30 1
a30 1
const char *ign_default = ". .. core RCSLOG tags TAGS RCS SCCS .make.state .nse_depinfo #* .#* cvslog.* ,* CVS* .del-* *.a *.o *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej";
d35 4
d52 2
d59 13
a71 3
    /* Then add entries found in repository, if it exists */
    (void) sprintf (file, "%s/%s/%s", CVSroot, CVSROOTADM, CVSROOTADM_IGNORE);
    ign_add_file (file, 0);
d118 1
a118 1
	if (ign_hold)
d137 1
a137 1
	if (errno != ENOENT)
d184 2
d187 1
d194 1
a194 1
		if (ign_hold)
d198 1
a198 1
		    ign_hold = 0;
d294 78
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d30 1
a30 1
const char *ign_default = ". .. core RCSLOG tags TAGS RCS SCCS .make.state .nse_depinfo #* .#* cvslog.* ,* CVS CVS.adm .del-* *.a *.o *.obj *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej";
a34 4
/* Nonzero if we have encountered an -I ! directive, which means one should
   no longer ask the server about what is in CVSROOTADM_IGNORE.  */
int ign_inhibit_server;

a47 2
    ign_inhibit_server = 0;

d53 3
a55 13
#ifdef CLIENT_SUPPORT
    /* The client handles another way, by (after it does its own ignore file
       processing, and only if !ign_inhibit_server), letting the server
       know about the files and letting it decide whether to ignore
       them based on CVSROOOTADM_IGNORE.  */
    if (!client_active)
#endif
    {
	/* Then add entries found in repository, if it exists */
	(void) sprintf (file, "%s/%s/%s", CVSroot, CVSROOTADM,
			CVSROOTADM_IGNORE);
	ign_add_file (file, 0);
    }
d121 1
a121 1
	if (! existence_error (errno))
a167 2
		{
		    ign_inhibit_server = 1;
a168 1
		}
a274 78
}

/*
 * Process the current directory, looking for files not in ILIST and not on
 * the global ignore list for this directory.  If we find one, call PROC
 * passing it the name of the file and the update dir.
 */
void
ignore_files (ilist, update_dir, proc)
    List *ilist;
    char *update_dir;
    Ignore_proc proc;
{
    DIR *dirp;
    struct dirent *dp;
    struct stat sb;
    char *file;
    char *xdir;

    /* we get called with update_dir set to "." sometimes... strip it */
    if (strcmp (update_dir, ".") == 0)
	xdir = "";
    else
	xdir = update_dir;

    dirp = opendir (".");
    if (dirp == NULL)
	return;

    ign_add_file (CVSDOTIGNORE, 1);
    wrap_add_file (CVSDOTWRAPPER, 1);

    while ((dp = readdir (dirp)) != NULL)
    {
	file = dp->d_name;
	if (strcmp (file, ".") == 0 || strcmp (file, "..") == 0)
	    continue;
	if (findnode_fn (ilist, file) != NULL)
	    continue;

	if (
#ifdef DT_DIR
		dp->d_type != DT_UNKNOWN ||
#endif
		lstat(file, &sb) != -1) 
	{

	    if (
#ifdef DT_DIR
		dp->d_type == DT_DIR || dp->d_type == DT_UNKNOWN &&
#endif
		S_ISDIR(sb.st_mode))
	    {
		char temp[PATH_MAX];

		(void) sprintf (temp, "%s/%s", file, CVSADM);
		if (isdir (temp))
		    continue;
	    }
#ifdef S_ISLNK
	    else if (
#ifdef DT_DIR
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN && 
#endif
		S_ISLNK(sb.st_mode))
	    {
		continue;
	    }
#endif
    	}

	/* We could be ignoring FIFOs and other files which are neither
	   regular files nor directories here.  */
	if (ign_name (file))
	    continue;
	(*proc) (file, xdir);
    }
    (void) closedir (dirp);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d7 5
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d25 1
a25 3
const char *ign_default = ". .. core RCSLOG tags TAGS RCS SCCS .make.state\
 .nse_depinfo #* .#* cvslog.* ,* CVS CVS.adm .del-* *.a *.olb *.o *.obj\
 *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej *.exe _$* *$";
a230 4
/* Set to 1 if ignore file patterns should be matched in a case-insensitive
   fashion.  */
int ign_case;

d241 4
a244 35
    if (ign_case)
    {
	/* We do a case-insensitive match by calling fnmatch on copies of
	   the pattern and the name which have been converted to
	   lowercase.  */
	char *name_lower;
	char *pat_lower;
	char *p;

	name_lower = xstrdup (name);
	for (p = name_lower; *p != '\0'; ++p)
	    *p = tolower (*p);
	while (*cpp)
	{
	    pat_lower = xstrdup (*cpp++);
	    for (p = pat_lower; *p != '\0'; ++p)
		*p = tolower (*p);
	    if (fnmatch (pat_lower, name_lower, 0) == 0)
		goto matched;
	    free (pat_lower);
	}
	free (name_lower);
	return 0;
      matched:
	free (name_lower);
	free (pat_lower);
	return 1;
    }
    else
    {
	while (*cpp)
	    if (fnmatch (*cpp++, name, 0) == 0)
		return 1;
	return 0;
    }
d246 1
a246 2

/* FIXME: This list of dirs to ignore stuff seems not to be used.  */
d290 1
a290 1

@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d22 1
a22 1
static int ign_hold = -1;		/* Index where first "temporary" item
d45 1
a45 1
    char *home_dir;
d65 2
a66 2
	(void) sprintf (file, "%s/%s/%s", CVSroot_directory,
			CVSROOTADM, CVSROOTADM_IGNORE);
d71 1
a71 2
    home_dir = get_homedir ();
    if (home_dir)
d73 1
a73 1
	(void) sprintf (file, "%s/%s", home_dir, CVSDOTIGNORE);
d115 1
a115 1
	if (ign_hold >= 0)
d131 1
a131 1
    fp = CVS_FOPEN (file, "r");
d191 1
a191 1
		if (ign_hold >= 0)
d195 1
a195 1
		    ign_hold = -1;
d330 3
a332 6
 * Process the current directory, looking for files not in ILIST and
 * not on the global ignore list for this directory.  If we find one,
 * call PROC passing it the name of the file and the update dir.
 * ENTRIES is the entries list, which is used to identify known
 * directories.  ENTRIES may be NULL, in which case we assume that any
 * directory with a CVS administration directory is known.
d335 1
a335 1
ignore_files (ilist, entries, update_dir, proc)
a336 1
    List *entries;
a339 1
    int subdirs;
a345 11
    /* Set SUBDIRS if we have subdirectory information in ENTRIES.  */
    if (entries == NULL)
	subdirs = 0;
    else
    {
	struct stickydirtag *sdtp;

	sdtp = (struct stickydirtag *) entries->list->data;
	subdirs = sdtp == NULL || sdtp->subdirs;
    }

d352 1
a352 1
    dirp = CVS_OPENDIR (".");
a365 28
	if (subdirs)
	{
	    Node *node;

	    node = findnode_fn (entries, file);
	    if (node != NULL
		&& ((Entnode *) node->data)->type == ENT_SUBDIR)
	    {
		char *p;
		int dir;

		/* For consistency with past behaviour, we only ignore
		   this directory if there is a CVS subdirectory.
		   This will normally be the case, but the user may
		   have messed up the working directory somehow.  */
		p = xmalloc (strlen (file) + sizeof CVSADM + 10);
		sprintf (p, "%s/%s", file, CVSADM);
		dir = isdir (p);
		free (p);
		if (dir)
		    continue;
	    }
	}

	/* We could be ignoring FIFOs and other files which are neither
	   regular files nor directories here.  */
	if (ign_name (file))
	    continue;
d380 1
a380 3
		if (! subdirs)
		{
		    char temp[PATH_MAX];
d382 3
a384 4
		    (void) sprintf (temp, "%s/%s", file, CVSADM);
		    if (isdir (temp))
			continue;
		}
d398 4
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d46 1
a63 2
	char *file = xmalloc (strlen (CVSroot_directory) + sizeof (CVSROOTADM)
			      + sizeof (CVSROOTADM_IGNORE) + 10);
a67 1
	free (file);
a73 1
	char *file = xmalloc (strlen (home_dir) + sizeof (CVSDOTIGNORE) + 10);
a75 1
	free (file);
a94 1
    /* FIXME: arbitrary limit.  */
d427 1
a427 1
		    char *temp;
a428 1
		    temp = xmalloc (strlen (file) + sizeof (CVSADM) + 10);
a430 2
		    {
			free (temp);
a431 2
		    }
		    free (temp);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@a0 10
/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

a5 1
#include "getline.h"
d99 2
a100 2
    char *line = NULL;
    size_t line_allocated = 0;
d144 1
a144 1
    while (getline (&line, &line_allocated, fp) >= 0)
a145 2
    if (ferror (fp))
	error (0, errno, "cannot read %s", file);
a147 1
    free (line);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d253 2
a254 3
/* Set to 1 if filenames should be matched in a case-insensitive
   fashion.  Note that, contrary to the name and placement in ignore.c,
   this is no longer just for ignore patterns.  */
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d272 1
a272 3
	   lowercase.  FIXME: would be much cleaner to just unify this
	   with the other case-insensitive fnmatch stuff (FOLD_FN_CHAR
	   in lib/fnmatch.c; os2_fnmatch in emx/system.c).  */
d285 1
a285 1
	    if (CVS_FNMATCH (pat_lower, name_lower, 0) == 0)
d299 1
a299 1
	    if (CVS_FNMATCH (*cpp++, name, 0) == 0)
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d307 1
a307 4
/* FIXME: This list of dirs to ignore stuff seems not to be used.
   Really?  send_dirent_proc and update_dirent_proc both call
   ignore_directory and do_module calls ign_dir_add.  No doubt could
   use some documentation/testsuite work.  */
d313 3
a315 4
/* Add a directory to list of dirs to ignore.  */
void
ign_dir_add (name)
    char *name;
d317 2
a318 2
    /* Make sure we've got the space for the entry.  */
    if (dir_ign_current <= dir_ign_max)
d320 2
a321 4
	dir_ign_max += IGN_GROW;
	dir_ign_list =
	    (char **) xrealloc (dir_ign_list,
				(dir_ign_max + 1) * sizeof (char *));
d324 1
a324 1
    dir_ign_list[dir_ign_current] = name;
d326 1
a326 1
    dir_ign_current += 1 ;
d330 3
a332 1
/* Return nonzero if NAME is part of the list of directories to ignore.  */
d334 2
a335 3
int
ignore_directory (name)
    char *name;
d337 1
a337 1
    int i;
d339 2
a340 2
    if (!dir_ign_list)
	return 0;
d342 2
a343 2
    i = dir_ign_current;
    while (i--)
d345 2
a346 2
	if (strncmp (name, dir_ign_list[i], strlen (dir_ign_list[i])) == 0)
	    return 1;
d349 1
a349 1
    return 0;
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a84 5
    /* If we can't find a home directory, ignore ~/.cvsignore.  This may
       make tracking down problems a bit of a pain, but on the other
       hand it might be obnoxious to complain when CVS will function
       just fine without .cvsignore (and many users won't even know what
       .cvsignore is).  */
d179 1
a179 1
	if (isspace ((unsigned char) *ign))
d187 1
a187 2
	if ((!*(ign+1) || isspace ((unsigned char) *(ign+1)))
	    && (*ign == '!' || *ign == '*'))
d236 1
a236 1
	for (mark = ign; *mark && !isspace ((unsigned char) *mark); mark++)
a397 2
    {
	error (0, errno, "cannot open current directory");
a398 1
    }
a402 1
    errno = 0;
a478 1
	errno = 0;
a479 2
    if (errno != 0)
	error (0, errno, "error reading current directory");
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d336 3
a338 1
    dir_ign_list[dir_ign_current++] = xstrdup (name);
d417 1
a417 1
	    goto continue_loop;
d419 1
a419 1
	    goto continue_loop;
d440 1
a440 1
		    goto continue_loop;
d447 1
a447 1
	    goto continue_loop;
d458 1
a458 4
		dp->d_type == DT_DIR
		|| (dp->d_type == DT_UNKNOWN && S_ISDIR (sb.st_mode))
#else
		S_ISDIR (sb.st_mode)
d460 1
a460 1
		)
d471 1
a471 1
			goto continue_loop;
d479 1
a479 4
		     dp->d_type == DT_LNK
		     || (dp->d_type == DT_UNKNOWN && S_ISLNK(sb.st_mode))
#else
		     S_ISLNK (sb.st_mode)
d481 1
a481 1
		     )
d483 1
a483 1
		goto continue_loop;
a488 1
    continue_loop:
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d71 1
a71 1
    if (!current_parsed_root->isremote)
d74 1
a74 1
	char *file = xmalloc (strlen (current_parsed_root->directory) + sizeof (CVSROOTADM)
d77 1
a77 1
	(void) sprintf (file, "%s/%s/%s", current_parsed_root->directory,
a381 2
    List *files;
    Node *p;
d410 2
a411 4
    /* Make a list for the files.  */
    files = getlist ();

    while (errno = 0, (dp = CVS_READDIR (dirp)) != NULL)
d415 1
a415 1
	    continue;
d417 1
a417 1
	    continue;
d438 1
a438 1
		    continue;
d445 1
a445 1
	    continue;
d472 1
a472 1
			continue;
d487 1
a487 1
		continue;
d490 1
a490 1
	}
d492 3
a494 4
	p = getnode ();
	p->type = FILES;
	p->key = xstrdup (file);
	(void) addnode (files, p);
d498 1
a498 6
    (void) CVS_CLOSEDIR (dirp);

    sortlist (files, fsortcmp);
    for (p = files->list->next; p != files->list; p = p->next)
	(*proc) (p->key, xdir);
    dellist (&files);
@


