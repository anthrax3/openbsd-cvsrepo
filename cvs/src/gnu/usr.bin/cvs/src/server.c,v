head	1.37;
access;
symbols
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.10
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.36.0.6
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.34.0.4
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.6
	OPENBSD_5_0:1.33.0.4
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.4
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.31.0.24
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.20
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.18
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.16
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.14
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.31.0.12
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.10
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.8
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.31.0.6
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.31.0.4
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.4
	OPENBSD_3_4_BASE:1.28
	OPENBSD_3_3:1.28.0.2
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.26.0.6
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.4
	OPENBSD_3_1_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	cvs-1-11-1p1:1.1.1.17
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_9_BASE:1.24
	cvs-1-11:1.1.1.16
	OPENBSD_2_8:1.23.0.6
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.23.0.4
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	cvs-1-10-7:1.1.1.15
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	cvs-1-10-5:1.1.1.14
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	cvs-1-10:1.1.1.13
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2015.10.30.16.38.55;	author millert;	state Exp;
branches;
next	1.36;
commitid	Jv0xsl4CLoHre6BX;

1.36
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.20.04.34.09;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2010.10.15.10.18.42;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.13.19.30.32;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.09.18.16.05;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.19.15.28.32;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2003.12.29.05.28.21;	author deraadt;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2003.01.23.20.00.20;	author millert;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2003.01.20.02.52.50;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.29.00.00.39;	author tholo;	state Exp;
branches
	1.26.4.1
	1.26.6.1;
next	1.25;

1.25
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.10.19.31.36;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	99.09.10.05.21.33;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	99.02.28.21.58.03;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	98.08.22.21.04.41;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	98.07.13.04.17.08;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	98.03.12.07.22.47;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	98.02.22.09.27.25;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	98.02.22.08.56.07;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	97.08.04.19.24.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.06.28.03.45.32;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	97.04.21.04.41.09;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.03.18.02.09.59;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.02.21.06.55.00;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.10.18.17.44.28;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.10.18.04.19.42;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.05.30.07.48.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.24.10.03.43;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.06.22.51.19;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.04.27.20.26.23;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.01.30.01.10.56;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.29.22.57.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.20.21.58.37;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.19.10.40.06;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.34;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.28;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.17;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.20.01;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.53;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.51;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.26;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.53;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.58;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.34;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.59.11;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.54.23;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.08.22.20.53.58;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.02.28.21.33.33;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.09.10.05.06.27;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.02.10.18.57.47;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;

1.26.4.1
date	2003.01.22.23.55.05;	author miod;	state Exp;
branches;
next	;

1.26.6.1
date	2003.01.21.15.41.14;	author jason;	state Exp;
branches;
next	;

1.28.4.1
date	2004.05.20.19.52.30;	author brad;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2004.06.09.19.51.06;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2004.05.20.19.23.02;	author brad;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2004.06.09.19.31.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Use crypt_checkpass() instead of strcmp(hash, crypt(password, hash)).
Fixes a crash in pserver mode when CVSROOT/passwd contains an old
DES password.
@
text
@/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

#include <assert.h>
#include "cvs.h"
#include "watch.h"
#include "edit.h"
#include "fileattr.h"
#include "getline.h"
#include "buffer.h"

#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
# ifdef HAVE_GSSAPI
/* This stuff isn't included solely with SERVER_SUPPORT since some of these
 * functions (encryption & the like) get compiled with or without server
 * support.
 *
 * FIXME - They should be in a different file.
 */
#   include <netdb.h>
#   include "xgssapi.h"
/* We use Kerberos 5 routines to map the GSSAPI credential to a user
   name.  */
#   include <krb5.h>

/* We need this to wrap data.  */
static gss_ctx_id_t gcontext;

static void gserver_authenticate_connection PROTO((void));

/* Whether we are already wrapping GSSAPI communication.  */
static int cvs_gssapi_wrapping;

#   ifdef ENCRYPTION
/* Whether to encrypt GSSAPI communication.  We use a global variable
   like this because we use the same buffer type (gssapi_wrap) to
   handle both authentication and encryption, and we don't want
   multiple instances of that buffer in the communication stream.  */
int cvs_gssapi_encrypt;
#   endif
# endif	/* HAVE_GSSAPI */
#endif	/* defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT) */

#ifdef SERVER_SUPPORT

#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#endif

#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#include <sys/socket.h>
#endif

#ifdef HAVE_SYSLOG_H
#include <syslog.h>
#endif

#ifdef HAVE_KERBEROS
# include <netinet/in.h>
# include <krb.h>
# ifndef HAVE_KRB_GET_ERR_TEXT
#   define krb_get_err_text(status) krb_err_txt[status]
# endif

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

#endif

/* for select */
#include "xselect.h"

#ifndef O_NONBLOCK
#define O_NONBLOCK O_NDELAY
#endif

/* EWOULDBLOCK is not defined by POSIX, but some BSD systems will
   return it, rather than EAGAIN, for nonblocking writes.  */
#ifdef EWOULDBLOCK
#define blocking_error(err) ((err) == EWOULDBLOCK || (err) == EAGAIN)
#else
#define blocking_error(err) ((err) == EAGAIN)
#endif

/* For initgroups().  */
#if HAVE_INITGROUPS
#include <grp.h>
#endif /* HAVE_INITGROUPS */

# ifdef AUTH_SERVER_SUPPORT

#   ifdef HAVE_GETSPNAM
#     include <shadow.h>
#   endif

/* The cvs username sent by the client, which might or might not be
   the same as the system username the server eventually switches to
   run as.  CVS_Username gets set iff password authentication is
   successful. */
char *CVS_Username = NULL;

/* Used to check that same repos is transmitted in pserver auth and in
   later CVS protocol.  Exported because root.c also uses. */
static char *Pserver_Repos = NULL;

/* Should we check for system usernames/passwords?  Can be changed by
   CVSROOT/config.  */
int system_auth = 1;

# endif /* AUTH_SERVER_SUPPORT */

/* Should we disable Update-prog/Checkin-prog? Can be changed by
   CVSROOT/config.  */
int disable_x_prog = 0;


/* While processing requests, this buffer accumulates data to be sent to
   the client, and then once we are in do_cvs_command, we use it
   for all the data to be sent.  */
static struct buffer *buf_to_net;

/* This buffer is used to read input from the client.  */
static struct buffer *buf_from_net;

/*
 * This is where we stash stuff we are going to use.  Format string
 * which expects a single directory within it, starting with a slash.
 */
static char *server_temp_dir;

/* This is the original value of server_temp_dir, before any possible
   changes inserted by serve_max_dotdot.  */
static char *orig_server_temp_dir;

/* Nonzero if we should keep the temp directory around after we exit.  */
static int dont_delete_temp;

static void server_write_entries PROTO((void));

/* All server communication goes through buffer structures.  Most of
   the buffers are built on top of a file descriptor.  This structure
   is used as the closure field in a buffer.  */

struct fd_buffer
{
    /* The file descriptor.  */
    int fd;
    /* Nonzero if the file descriptor is in blocking mode.  */
    int blocking;
};

static struct buffer *fd_buffer_initialize
  PROTO ((int, int, void (*) (struct buffer *)));
static int fd_buffer_input PROTO((void *, char *, int, int, int *));
static int fd_buffer_output PROTO((void *, const char *, int, int *));
static int fd_buffer_flush PROTO((void *));
static int fd_buffer_block PROTO((void *, int));
static int fd_buffer_shutdown PROTO((void *));

/* Initialize a buffer built on a file descriptor.  FD is the file
   descriptor.  INPUT is nonzero if this is for input, zero if this is
   for output.  MEMORY is the function to call when a memory error
   occurs.  */

static struct buffer *
fd_buffer_initialize (fd, input, memory)
     int fd;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct fd_buffer *n;

    n = (struct fd_buffer *) xmalloc (sizeof *n);
    n->fd = fd;
    n->blocking = 1;
    return buf_initialize (input ? fd_buffer_input : NULL,
			   input ? NULL : fd_buffer_output,
			   input ? NULL : fd_buffer_flush,
			   fd_buffer_block,
			   fd_buffer_shutdown,
			   memory,
			   n);
}

/* The buffer input function for a buffer built on a file descriptor.  */

static int
fd_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int nbytes;

    if (! fd->blocking)
	nbytes = read (fd->fd, data, size);
    else
    {
	/* This case is not efficient.  Fortunately, I don't think it
           ever actually happens.  */
	nbytes = read (fd->fd, data, need == 0 ? 1 : need);
    }

    if (nbytes > 0)
    {
	*got = nbytes;
	return 0;
    }

    *got = 0;

    if (nbytes == 0)
    {
	/* End of file.  This assumes that we are using POSIX or BSD
           style nonblocking I/O.  On System V we will get a zero
           return if there is no data, even when not at EOF.  */
	return -1;
    }

    /* Some error occurred.  */

    if (blocking_error (errno))
    {
	/* Everything's fine, we just didn't get any data.  */
	return 0;
    }

    return errno;
}

/* The buffer output function for a buffer built on a file descriptor.  */

static int
fd_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = write (fd->fd, data, have);

	if (nbytes <= 0)
	{
	    if (! fd->blocking
		&& (nbytes == 0 || blocking_error (errno)))
	    {
		/* A nonblocking write failed to write any data.  Just
                   return.  */
		return 0;
	    }

	    /* Some sort of error occurred.  */

	    if (nbytes == 0)
	        return EIO;

	    return errno;
	}

	*wrote += nbytes;
	data += nbytes;
	have -= nbytes;
    }

    return 0;
}

/* The buffer flush function for a buffer built on a file descriptor.  */

/*ARGSUSED*/
static int
fd_buffer_flush (closure)
     void *closure;
{
    /* Nothing to do.  File descriptors are always flushed.  */
    return 0;
}

/* The buffer block function for a buffer built on a file descriptor.  */

static int
fd_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int flags;

    flags = fcntl (fd->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;

    if (block)
	flags &= ~O_NONBLOCK;
    else
	flags |= O_NONBLOCK;

    if (fcntl (fd->fd, F_SETFL, flags) < 0)
        return errno;

    fd->blocking = block;

    return 0;
}

/* The buffer shutdown function for a buffer built on a file descriptor.  */

static int
fd_buffer_shutdown (closure)
     void *closure;
{
    free (closure);
    return 0;
}

/* Populate all of the directories between BASE_DIR and its relative
   subdirectory DIR with CVSADM directories.  Return 0 for success or
   errno value.  */
static int create_adm_p PROTO((char *, char *));

static int
create_adm_p (base_dir, dir)
    char *base_dir;
    char *dir;
{
    char *dir_where_cvsadm_lives, *dir_to_register, *p, *tmp;
    int retval, done;
    FILE *f;

    if (strcmp (dir, ".") == 0)
	return 0;			/* nothing to do */

    /* Allocate some space for our directory-munging string. */
    p = malloc (strlen (dir) + 1);
    if (p == NULL)
	return ENOMEM;

    dir_where_cvsadm_lives = malloc (strlen (base_dir) + strlen (dir) + 100);
    if (dir_where_cvsadm_lives == NULL) {
	free(p);
	return ENOMEM;
    }

    /* Allocate some space for the temporary string in which we will
       construct filenames. */
    tmp = malloc (strlen (base_dir) + strlen (dir) + 100);
    if (tmp == NULL) {
	free(p);
	free(dir_where_cvsadm_lives);
	return ENOMEM;
    }

    
    /* We make several passes through this loop.  On the first pass,
       we simply create the CVSADM directory in the deepest directory.
       For each subsequent pass, we try to remove the last path
       element from DIR, create the CVSADM directory in the remaining
       pathname, and register the subdirectory in the newly created
       CVSADM directory. */

    retval = done = 0;

    strcpy (p, dir);
    strcpy (dir_where_cvsadm_lives, base_dir);
    strcat (dir_where_cvsadm_lives, "/");
    strcat (dir_where_cvsadm_lives, p);
    dir_to_register = NULL;

    while (1)
    {
	/* Create CVSADM. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM);
	if ((CVS_MKDIR (tmp, 0777) < 0) && (errno != EEXIST))
	{
	    retval = errno;
	    goto finish;
	}

	/* Create CVSADM_REP. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_REP);
	if (! isfile (tmp))
	{
	    /* Use Emptydir as the placeholder until the client sends
	       us the real value.  This code is similar to checkout.c
	       (emptydir_name), but the code below returns errors
	       differently.  */

	    char *empty;
	    empty = malloc (strlen (current_parsed_root->directory)
			    + sizeof (CVSROOTADM)
			    + sizeof (CVSNULLREPOS)
			    + 3);
	    if (! empty)
	    {
		retval = ENOMEM;
		goto finish;
	    }

	    /* Create the directory name. */
	    (void) sprintf (empty, "%s/%s/%s", current_parsed_root->directory,
			    CVSROOTADM, CVSNULLREPOS);

	    /* Create the directory if it doesn't exist. */
	    if (! isfile (empty))
	    {
		mode_t omask;
		omask = umask (cvsumask);
		if (CVS_MKDIR (empty, 0777) < 0)
		{
		    retval = errno;
		    free (empty);
		    goto finish;
		}
		(void) umask (omask);
	    }
	    
	    
	    f = CVS_FOPEN (tmp, "w");
	    if (f == NULL)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }
	    /* Write the directory name to CVSADM_REP. */
	    if (fprintf (f, "%s\n", empty) < 0)
	    {
		retval = errno;
		fclose (f);
		free (empty);
		goto finish;
	    }
	    if (fclose (f) == EOF)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }

	    /* Clean up after ourselves. */
	    free (empty);
	}

	/* Create CVSADM_ENT.  We open in append mode because we
	   don't want to clobber an existing Entries file.  */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_ENT);
	f = CVS_FOPEN (tmp, "a");
	if (f == NULL)
	{
	    retval = errno;
	    goto finish;
	}
	if (fclose (f) == EOF)
	{
	    retval = errno;
	    goto finish;
	}

	if (dir_to_register != NULL)
	{
	    /* FIXME: Yes, this results in duplicate entries in the
	       Entries.Log file, but it doesn't currently matter.  We
	       might need to change this later on to make sure that we
	       only write one entry.  */

	    Subdir_Register ((List *) NULL, dir_where_cvsadm_lives,
			     dir_to_register);
	}

	if (done)
	    break;

	dir_to_register = strrchr (p, '/');
	if (dir_to_register == NULL)
	{
	    dir_to_register = p;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    done = 1;
	}
	else
	{
	    *dir_to_register = '\0';
	    dir_to_register++;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    strcat (dir_where_cvsadm_lives, "/");
	    strcat (dir_where_cvsadm_lives, p);
	}
    }

  finish:
    free (tmp);
    free (dir_where_cvsadm_lives);
    free (p);
    return retval;
}

/*
 * Make directory DIR, including all intermediate directories if necessary.
 * Returns 0 for success or errno code.
 */
static int mkdir_p PROTO((char *));

static int
mkdir_p (dir)
     char *dir;
{
    char *p;
    char *q = malloc (strlen (dir) + 1);
    int retval;

    if (q == NULL)
	return ENOMEM;

    retval = 0;

    /*
     * Skip over leading slash if present.  We won't bother to try to
     * make '/'.
     */
    p = dir + 1;
    while (1)
    {
	while (*p != '/' && *p != '\0')
	    ++p;
	if (*p == '/')
	{
	    strncpy (q, dir, p - dir);
	    q[p - dir] = '\0';
	    if (q[p - dir - 1] != '/'  &&  CVS_MKDIR (q, 0777) < 0)
	    {
		int saved_errno = errno;

		if (saved_errno != EEXIST
		    && ((saved_errno != EACCES && saved_errno != EROFS)
			|| !isdir (q)))
		{
		    retval = saved_errno;
		    goto done;
		}
	    }
	    ++p;
	}
	else
	{
	    if (CVS_MKDIR (dir, 0777) < 0)
		retval = errno;
	    goto done;
	}
    }
  done:
    free (q);
    return retval;
}

/*
 * Print the error response for error code STATUS.  The caller is
 * reponsible for making sure we get back to the command loop without
 * any further output occuring.
 * Must be called only in contexts where it is OK to send output.
 */
static void
print_error (status)
    int status;
{
    char *msg;
    char tmpstr[80];

    buf_output0 (buf_to_net, "error  ");
    msg = strerror (status);
    if (msg == NULL)
    {
       sprintf (tmpstr, "unknown error %d", status);
       msg = tmpstr;
    }
    buf_output0 (buf_to_net, msg);
    buf_append_char (buf_to_net, '\n');

    buf_flush (buf_to_net, 0);
}

static int pending_error;
/*
 * Malloc'd text for pending error.  Each line must start with "E ".  The
 * last line should not end with a newline.
 */
static char *pending_error_text;

/* If an error is pending, print it and return 1.  If not, return 0.
   Must be called only in contexts where it is OK to send output.  */
static int
print_pending_error ()
{
    if (pending_error_text)
    {
	buf_output0 (buf_to_net, pending_error_text);
	buf_append_char (buf_to_net, '\n');
	if (pending_error)
	    print_error (pending_error);
	else
	    buf_output0 (buf_to_net, "error  \n");

	buf_flush (buf_to_net, 0);

	pending_error = 0;
	free (pending_error_text);
	pending_error_text = NULL;
	return 1;
    }
    else if (pending_error)
    {
	print_error (pending_error);
	pending_error = 0;
	return 1;
    }
    else
	return 0;
}

/* Is an error pending?  */
#define error_pending() (pending_error || pending_error_text)

static int alloc_pending PROTO ((size_t size));

/* Allocate SIZE bytes for pending_error_text and return nonzero
   if we could do it.  */
static int
alloc_pending (size)
    size_t size;
{
    if (error_pending ())
	/* Probably alloc_pending callers will have already checked for
	   this case.  But we might as well handle it if they don't, I
	   guess.  */
	return 0;
    pending_error_text = malloc (size);
    if (pending_error_text == NULL)
    {
	pending_error = ENOMEM;
	return 0;
    }
    return 1;
}

static void serve_is_modified PROTO ((char *));

static int supported_response PROTO ((char *));

static int
supported_response (name)
     char *name;
{
    struct response *rs;

    for (rs = responses; rs->name != NULL; ++rs)
	if (strcmp (rs->name, name) == 0)
	    return rs->status == rs_supported;
    error (1, 0, "internal error: testing support for unknown response?");
    /* NOTREACHED */
    return 0;
}

static void
serve_valid_responses (arg)
     char *arg;
{
    char *p = arg;
    char *q;
    struct response *rs;
    do
    {
	q = strchr (p, ' ');
	if (q != NULL)
	    *q++ = '\0';
	for (rs = responses; rs->name != NULL; ++rs)
	{
	    if (strcmp (rs->name, p) == 0)
		break;
	}
	if (rs->name == NULL)
	    /*
	     * It is a response we have never heard of (and thus never
	     * will want to use).  So don't worry about it.
	     */
	    ;
	else
	    rs->status = rs_supported;
	p = q;
    } while (q != NULL);
    for (rs = responses; rs->name != NULL; ++rs)
    {
	if (rs->status == rs_essential)
	{
	    buf_output0 (buf_to_net, "E response `");
	    buf_output0 (buf_to_net, rs->name);
	    buf_output0 (buf_to_net, "' not supported by client\nerror  \n");

	    /* FIXME: This call to buf_flush could conceivably
	       cause deadlock, as noted in server_cleanup.  */
	    buf_flush (buf_to_net, 1);

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
	else if (rs->status == rs_optional)
	    rs->status = rs_not_supported;
    }
}

static void
serve_root (arg)
    char *arg;
{
    char *env;
    char *path;
    
    if (error_pending()) return;

    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	return;
    }

    /* Sending "Root" twice is illegal.

       The other way to handle a duplicate Root requests would be as a
       request to clear out all state and start over as if it was a
       new connection.  Doing this would cause interoperability
       headaches, so it should be a different request, if there is
       any reason why such a feature is needed.  */
    if (current_parsed_root != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Protocol error: Duplicate Root request, for %s", arg);
	return;
    }

#ifdef AUTH_SERVER_SUPPORT
    if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: Root says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
    }
#endif

    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
    current_parsed_root = local_cvsroot (arg);

    /* For pserver, this will already have happened, and the call will do
       nothing.  But for rsh, we need to do it now.  */
    parse_config (current_parsed_root->directory);

    path = malloc (strlen (current_parsed_root->directory)
		   + sizeof (CVSROOTADM)
		   + 2);
    if (path == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
    if (readonlyfs == 0 && !isaccessible (path, R_OK | X_OK))
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (path)))
	    sprintf (pending_error_text, "E Cannot access %s", path);
	pending_error = save_errno;
    }
    free (path);

#ifdef HAVE_PUTENV
    env = malloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
    if (env == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, current_parsed_root->directory);
    (void) putenv (env);
    /* do not free env, as putenv has control of it */
#endif
}

static int max_dotdot_limit = 0;

/* Is this pathname OK to recurse into when we are running as the server?
   If not, call error() with a fatal error.  */
void
server_pathname_check (path)
    char *path;
{
    /* An absolute pathname is almost surely a path on the *client* machine,
       and is unlikely to do us any good here.  It also is probably capable
       of being a security hole in the anonymous readonly case.  */
    if (isabsolute (path))
	/* Giving an error is actually kind of a cop-out, in the sense
	   that it would be nice for "cvs co -d /foo/bar/baz" to work.
	   A quick fix in the server would be requiring Max-dotdot of
	   at least one if pathnames are absolute, and then putting
	   /abs/foo/bar/baz in the temp dir beside the /d/d/d stuff.
	   A cleaner fix in the server might be to decouple the
	   pathnames we pass back to the client from pathnames in our
	   temp directory (this would also probably remove the need
	   for Max-dotdot).  A fix in the client would have the client
	   turn it into "cd /foo/bar; cvs co -d baz" (more or less).
	   This probably has some problems with pathnames which appear
	   in messages.  */
	error (1, 0, "absolute pathname `%s' illegal for server", path);
    if (pathname_levels (path) > max_dotdot_limit)
    {
	/* Similar to the isabsolute case in security implications.  */
	error (0, 0, "protocol error: `%s' contains more leading ..", path);
	error (1, 0, "than the %d which Max-dotdot specified",
	       max_dotdot_limit);
    }
}

static int outside_root PROTO ((char *));

/* Is file or directory REPOS an absolute pathname within the
   current_parsed_root->directory?  If yes, return 0.  If no, set pending_error
   and return 1.  */
static int
outside_root (repos)
    char *repos;
{
    size_t repos_len = strlen (repos);
    size_t root_len = strlen (current_parsed_root->directory);

    /* I think isabsolute (repos) should always be true, and that
       any RELATIVE_REPOS stuff should only be in CVS/Repository
       files, not the protocol (for compatibility), but I'm putting
       in the isabsolute check just in case.  */
    if (!isabsolute (repos))
    {
	if (alloc_pending (repos_len + 80))
	    sprintf (pending_error_text, "\
E protocol error: %s is not absolute", repos);
	return 1;
    }

    if (repos_len < root_len
	|| strncmp (current_parsed_root->directory, repos, root_len) != 0)
    {
    not_within:
	if (alloc_pending (strlen (current_parsed_root->directory)
			   + strlen (repos)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within root '%s'",
		     repos, current_parsed_root->directory);
	return 1;
    }
    if (repos_len > root_len)
    {
	if (repos[root_len] != '/')
	    goto not_within;
	if (pathname_levels (repos + root_len + 1) > 0)
	    goto not_within;
    }
    return 0;
}

static int outside_dir PROTO ((char *));

/* Is file or directory FILE outside the current directory (that is, does
   it contain '/')?  If no, return 0.  If yes, set pending_error
   and return 1.  */
static int
outside_dir (file)
    char *file;
{
    if (strchr (file, '/') != NULL)
    {
	if (alloc_pending (strlen (file)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within current directory",
		     file);
	return 1;
    }
    return 0;
}
	
/*
 * Add as many directories to the temp directory as the client tells us it
 * will use "..", so we never try to access something outside the temp
 * directory via "..".
 */
static void
serve_max_dotdot (arg)
    char *arg;
{
    int lim = atoi (arg);
    int i;
    char *p;

    if (lim < 0 || lim > 10000)
	return;
    p = malloc (strlen (server_temp_dir) + 2 * lim + 10);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (p, server_temp_dir);
    for (i = 0; i < lim; ++i)
	strcat (p, "/d");
    if (server_temp_dir != orig_server_temp_dir)
	free (server_temp_dir);
    server_temp_dir = p;
    max_dotdot_limit = lim;
}

static char *dir_name;

static void
dirswitch (dir, repos)
    char *dir;
    char *repos;
{
    int status;
    FILE *f;
    size_t dir_len;

    server_write_entries ();

    if (error_pending()) return;

    /* Check for bad directory name.

       FIXME: could/should unify these checks with server_pathname_check
       except they need to report errors differently.  */
    if (isabsolute (dir))
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E absolute pathname `%s' illegal for server", dir);
	return;
    }
    if (pathname_levels (dir) > max_dotdot_limit)
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E protocol error: `%s' has too many ..", dir);
	return;
    }

    dir_len = strlen (dir);

    /* Check for a trailing '/'.  This is not ISDIRSEP because \ in the
       protocol is an ordinary character, not a directory separator (of
       course, it is perhaps unwise to use it in directory names, but that
       is another issue).  */
    if (dir_len > 0
	&& dir[dir_len - 1] == '/')
    {
	if (alloc_pending (80 + dir_len))
	    sprintf (pending_error_text,
		     "E protocol error: invalid directory syntax in %s", dir);
	return;
    }

    if (dir_name != NULL)
	free (dir_name);

    dir_name = malloc (strlen (server_temp_dir) + dir_len + 40);
    if (dir_name == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    
    strcpy (dir_name, server_temp_dir);
    strcat (dir_name, "/");
    strcat (dir_name, dir);

    status = mkdir_p (dir_name);
    if (status != 0
	&& status != EEXIST)
    {
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot mkdir %s", dir_name);
	pending_error = status;
	return;
    }

    /* We need to create adm directories in all path elements because
       we want the server to descend them, even if the client hasn't
       sent the appropriate "Argument xxx" command to match the
       already-sent "Directory xxx" command.  See recurse.c
       (start_recursion) for a big discussion of this.  */

    status = create_adm_p (server_temp_dir, dir);
    if (status != 0)
    {
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot create_adm_p %s", dir_name);
	pending_error = status;
	return;
    }

    if ( CVS_CHDIR (dir_name) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot change to %s", dir_name);
	pending_error = save_errno;
	return;
    }
    /*
     * This is pretty much like calling Create_Admin, but Create_Admin doesn't
     * report errors in the right way for us.
     */
    if ((CVS_MKDIR (CVSADM, 0777) < 0) && (errno != EEXIST))
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM)))
	    sprintf (pending_error_text,
		     "E cannot mkdir %s/%s", dir_name, CVSADM);
	pending_error = save_errno;
	return;
    }

    /* The following will overwrite the contents of CVSADM_REP.  This
       is the correct behavior -- mkdir_p may have written a
       placeholder value to this file and we need to insert the
       correct value. */

    f = CVS_FOPEN (CVSADM_REP, "w");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E cannot open %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s", repos) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
	fclose (f);
	return;
    }
    /* Non-remote CVS handles a module representing the entire tree
       (e.g., an entry like ``world -a .'') by putting /. at the end
       of the Repository file, so we do the same.  */
    if (strcmp (dir, ".") == 0
	&& current_parsed_root != NULL
	&& current_parsed_root->directory != NULL
	&& strcmp (current_parsed_root->directory, repos) == 0)
    {
        if (fprintf (f, "/.") < 0)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
		sprintf (pending_error_text,
			 "E error writing %s/%s", dir_name, CVSADM_REP);
	    pending_error = save_errno;
	    fclose (f);
	    return;
	}
    }
    if (fprintf (f, "\n") < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
	fclose (f);
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error closing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
	return;
    }
    /* We open in append mode because we don't want to clobber an
       existing Entries file.  */
    f = CVS_FOPEN (CVSADM_ENT, "a");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
	pending_error = save_errno;
	return;
    }
}

static void
serve_repository (arg)
    char *arg;
{
    if (alloc_pending (80))
	strcpy (pending_error_text,
		"E Repository request is obsolete; aborted");
    return;
}

static void
serve_directory (arg)
    char *arg;
{
    int status;
    char *repos;

    status = buf_read_line (buf_from_net, &repos, (int *) NULL);
    if (status == 0)
    {
	if (!outside_root (repos))
	    dirswitch (arg, repos);
	free (repos);
    }
    else if (status == -2)
    {
        pending_error = ENOMEM;
    }
    else
    {
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text == NULL)
	{
	    pending_error = ENOMEM;
	}
	else if (status == -1)
	{
	    sprintf (pending_error_text,
		     "E end of file reading mode for %s", arg);
	}
	else
	{
	    sprintf (pending_error_text,
		     "E error reading mode for %s", arg);
	    pending_error = status;
	}
    }
}

static void
serve_static_directory (arg)
    char *arg;
{
    FILE *f;

    if (error_pending ()) return;

    f = CVS_FOPEN (CVSADM_ENTSTAT, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENTSTAT);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENTSTAT);
	pending_error = save_errno;
	return;
    }
}

static void
serve_sticky (arg)
    char *arg;
{
    FILE *f;

    if (error_pending ()) return;

    f = CVS_FOPEN (CVSADM_TAG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_TAG);
	pending_error = save_errno;
	return;
    }
}

/*
 * Read SIZE bytes from buf_from_net, write them to FILE.
 *
 * Currently this isn't really used for receiving parts of a file --
 * the file is still sent over in one chunk.  But if/when we get
 * spiffy in-process gzip support working, perhaps the compressed
 * pieces could be sent over as they're ready, if the network is fast
 * enough.  Or something.
 */
static void
receive_partial_file (size, file)
     int size;
     int file;
{
    while (size > 0)
    {
	int status, nread;
	char *data;

	status = buf_read_data (buf_from_net, size, &data, &nread);
	if (status != 0)
	{
	    if (status == -2)
		pending_error = ENOMEM;
	    else
	    {
		pending_error_text = malloc (80);
		if (pending_error_text == NULL)
		    pending_error = ENOMEM;
		else if (status == -1)
		{
		    sprintf (pending_error_text,
			     "E premature end of file from client");
		    pending_error = 0;
		}
		else
		{
		    sprintf (pending_error_text,
			     "E error reading from client");
		    pending_error = status;
		}
	    }
	    return;
	}

	size -= nread;

	while (nread > 0)
	{
	    int nwrote;

	    nwrote = write (file, data, nread);
	    if (nwrote < 0)
	    {
	        int save_errno = errno;
		if (alloc_pending (40))
		    strcpy (pending_error_text, "E unable to write");
		pending_error = save_errno;

		/* Read and discard the file data.  */
		while (size > 0)
		{
		    int status, nread;
		    char *data;

		    status = buf_read_data (buf_from_net, size, &data, &nread);
		    if (status != 0)
			return;
		    size -= nread;
		}

		return;
	    }
	    nread -= nwrote;
	    data += nwrote;
	}
    }
}

/* Receive SIZE bytes, write to filename FILE.  */
static void
receive_file (size, file, gzipped)
     int size;
     char *file;
     int gzipped;
{
    int fd;
    char *arg = file;

    /* Write the file.  */
    fd = CVS_OPEN (arg, O_WRONLY | O_CREAT | O_TRUNC, 0600);
    if (fd < 0)
    {
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot open %s", arg);
	pending_error = save_errno;
	return;
    }

    if (gzipped)
    {
	/* Using gunzip_and_write isn't really a high-performance
	   approach, because it keeps the whole thing in memory
	   (contiguous memory, worse yet).  But it seems easier to
	   code than the alternative (and less vulnerable to subtle
	   bugs).  Given that this feature is mainly for
	   compatibility, that is the better tradeoff.  */

	int toread = size;
	char *filebuf;
	char *p;

	filebuf = malloc (size);
	p = filebuf;
	/* If NULL, we still want to read the data and discard it.  */

	while (toread > 0)
	{
	    int status, nread;
	    char *data;

	    status = buf_read_data (buf_from_net, toread, &data, &nread);
	    if (status != 0)
	    {
		if (status == -2)
		    pending_error = ENOMEM;
		else
		{
		    pending_error_text = malloc (80);
		    if (pending_error_text == NULL)
			pending_error = ENOMEM;
		    else if (status == -1)
		    {
			sprintf (pending_error_text,
				 "E premature end of file from client");
			pending_error = 0;
		    }
		    else
		    {
			sprintf (pending_error_text,
				 "E error reading from client");
			pending_error = status;
		    }
		}
		if (filebuf != NULL)
		    free(filebuf);
		return;
	    }

	    toread -= nread;

	    if (filebuf != NULL)
	    {
		memcpy (p, data, nread);
		p += nread;
	    }
	}
	if (filebuf == NULL)
	{
	    pending_error = ENOMEM;
	    goto out;
	}

	if (gunzip_and_write (fd, file, (unsigned char *) filebuf, size))
	{
	    if (alloc_pending (80))
		sprintf (pending_error_text,
			 "E aborting due to compression error");
	}
	free (filebuf);
    }
    else
	receive_partial_file (size, fd);

    if (pending_error_text)
    {
	char *p = realloc (pending_error_text,
			   strlen (pending_error_text) + strlen (arg) + 30);
	if (p)
	{
	    pending_error_text = p;
	    sprintf (p + strlen (p), ", file %s", arg);
	}
	/* else original string is supposed to be unchanged */
    }

 out:
    if (close (fd) < 0 && !error_pending ())
    {
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot close %s", arg);
	pending_error = save_errno;
	return;
    }
}

/* Kopt for the next file sent in Modified or Is-modified.  */
static char *kopt;

/* Timestamp (Checkin-time) for next file sent in Modified or
   Is-modified.  */
static int checkin_time_valid;
static time_t checkin_time;

static void serve_modified PROTO ((char *));

static void
serve_modified (arg)
     char *arg;
{
    int size, status;
    char *size_text;
    char *mode_text;

    int gzipped = 0;

    /*
     * This used to return immediately if error_pending () was true.
     * However, that fails, because it causes each line of the file to
     * be echoed back to the client as an unrecognized command.  The
     * client isn't reading from the socket, so eventually both
     * processes block trying to write to the other.  Now, we try to
     * read the file if we can.
     */

    status = buf_read_line (buf_from_net, &mode_text, (int *) NULL);
    if (status != 0)
    {
        if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading mode for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading mode for %s", arg);
		    pending_error = status;
		}
	    }
	}
	return;
    }

    status = buf_read_line (buf_from_net, &size_text, (int *) NULL);
    if (status != 0)
    {
	if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading size for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading size for %s", arg);
		    pending_error = status;
		}
	    }
	}
	free (mode_text);
	return;
    }
    if (size_text[0] == 'z')
    {
	gzipped = 1;
	size = atoi (size_text + 1);
    }
    else
	size = atoi (size_text);
    free (size_text);

    if (error_pending ())
    {
        /* Now that we know the size, read and discard the file data.  */
	while (size > 0)
	{
	    int status, nread;
	    char *data;

	    status = buf_read_data (buf_from_net, size, &data, &nread);
	    if (status != 0)
		return;
	    size -= nread;
	}
	free (mode_text);
	return;
    }

    if (outside_dir (arg))
    {
	free (mode_text);
	return;
    }

    if (size >= 0)
    {
	receive_file (size, arg, gzipped);
	if (error_pending ())
	{
	    free (mode_text);
	    return;
	}
    }

    if (checkin_time_valid)
    {
	struct utimbuf t;

	memset (&t, 0, sizeof (t));
	t.modtime = t.actime = checkin_time;
	if (utime (arg, &t) < 0)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (arg)))
		sprintf (pending_error_text, "E cannot utime %s", arg);
	    pending_error = save_errno;
	    free (mode_text);
	    return;
	}
	checkin_time_valid = 0;
    }

    {
	int status = change_mode (arg, mode_text, 0);
	free (mode_text);
	if (status)
	{
	    if (alloc_pending (40 + strlen (arg)))
		sprintf (pending_error_text,
			 "E cannot change mode for %s", arg);
	    pending_error = status;
	    return;
	}
    }

    /* Make sure that the Entries indicate the right kopt.  We probably
       could do this even in the non-kopt case and, I think, save a stat()
       call in time_stamp_server.  But for conservatism I'm leaving the
       non-kopt case alone.  */
    if (kopt != NULL)
	serve_is_modified (arg);
}


static void
serve_enable_unchanged (arg)
     char *arg;
{
}

struct an_entry {
    struct an_entry *next;
    char *entry;
};

static struct an_entry *entries;

static void serve_unchanged PROTO ((char *));

static void
serve_unchanged (arg)
    char *arg;
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;

    if (error_pending ()) return;

    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `=' in timestamp field.  */
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = '=';
	    break;
	}
    }
}

static void
serve_is_modified (arg)
    char *arg;
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;
    /* Have we found this file in "entries" yet.  */
    int found;

    if (error_pending ()) return;

    if (outside_dir (arg))
	return;

    /* Rewrite entries file to have `M' in timestamp field.  */
    found = 0;
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
	    {
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
	    }
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = 'M';
	    if (kopt != NULL)
	    {
		if (alloc_pending (strlen (name) + 80))
		    sprintf (pending_error_text,
			     "E protocol error: both Kopt and Entry for %s",
			     arg);
		free (kopt);
		kopt = NULL;
		return;
	    }
	    found = 1;
	    break;
	}
    }
    if (!found)
    {
	/* We got Is-modified but no Entry.  Add a dummy entry.
	   The "D" timestamp is what makes it a dummy.  */
	p = (struct an_entry *) malloc (sizeof (struct an_entry));
	if (p == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
	p->entry = malloc (strlen (arg) + 80);
	if (p->entry == NULL)
	{
	    pending_error = ENOMEM;
	    free (p);
	    return;
	}
	strcpy (p->entry, "/");
	strcat (p->entry, arg);
	strcat (p->entry, "//D/");
	if (kopt != NULL)
	{
	    strcat (p->entry, kopt);
	    free (kopt);
	    kopt = NULL;
	}
	strcat (p->entry, "/");
	p->next = entries;
	entries = p;
    }
}

static void serve_entry PROTO ((char *));

static void
serve_entry (arg)
     char *arg;
{
    struct an_entry *p;
    char *cp;
    int i = 0;
    if (error_pending()) return;

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
      if (!cp || *cp != '/')
      {
          if (alloc_pending (80))
              sprintf (pending_error_text,
                       "E protocol error: Malformed Entry");
           return;
      }
    cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    /* Leave space for serve_unchanged to write '=' if it wants.  */
    cp = malloc (strlen (arg) + 2);
    if (cp == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (cp, arg);
    p->next = entries;
    p->entry = cp;
    entries = p;
}

static void serve_kopt PROTO ((char *));

static void
serve_kopt (arg)
     char *arg;
{
    if (error_pending ())
	return;

    if (kopt != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Kopt request: %s", arg);
	return;
    }

    /* Do some sanity checks.  In particular, that it is not too long.
       This lets the rest of the code not worry so much about buffer
       overrun attacks.  Probably should call RCS_check_kflag here,
       but that would mean changing RCS_check_kflag to handle errors
       other than via exit(), fprintf(), and such.  */
    if (strlen (arg) > 10)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: invalid Kopt request: %s", arg);
	return;
    }

    kopt = malloc (strlen (arg) + 1);
    if (kopt == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (kopt, arg);
}

static void serve_checkin_time PROTO ((char *));

static void
serve_checkin_time (arg)
     char *arg;
{
    if (error_pending ())
	return;

    if (checkin_time_valid)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Checkin-time request: %s",
		     arg);
	return;
    }

    checkin_time = get_date (arg);
    if (checkin_time == (time_t)-1)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot parse date %s", arg);
	return;
    }
    checkin_time_valid = 1;
}

static void
server_write_entries ()
{
    FILE *f;
    struct an_entry *p;
    struct an_entry *q;

    if (entries == NULL)
	return;

    f = NULL;
    /* Note that we free all the entries regardless of errors.  */
    if (!error_pending ())
    {
	/* We open in append mode because we don't want to clobber an
           existing Entries file.  If we are checking out a module
           which explicitly lists more than one file in a particular
           directory, then we will wind up calling
           server_write_entries for each such file.  */
	f = CVS_FOPEN (CVSADM_ENT, "a");
	if (f == NULL)
	{
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (CVSADM_ENT)))
		sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
	    pending_error = save_errno;
	}
    }
    for (p = entries; p != NULL;)
    {
	if (!error_pending ())
	{
	    if (fprintf (f, "%s\n", p->entry) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen(CVSADM_ENT)))
		    sprintf (pending_error_text,
			     "E cannot write to %s", CVSADM_ENT);
		pending_error = save_errno;
	    }
	}
	free (p->entry);
	q = p->next;
	free (p);
	p = q;
    }
    entries = NULL;
    if (f != NULL && fclose (f) == EOF && !error_pending ())
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
	pending_error = save_errno;
    }
}

struct notify_note {
    /* Directory in which this notification happens.  malloc'd*/
    char *dir;

    /* malloc'd.  */
    char *filename;

    /* The following three all in one malloc'd block, pointed to by TYPE.
       Each '\0' terminated.  */
    /* "E" or "U".  */
    char *type;
    /* time+host+dir */
    char *val;
    char *watches;

    struct notify_note *next;
};

static struct notify_note *notify_list;
/* Used while building list, to point to the last node that already exists.  */
static struct notify_note *last_node;

static void serve_notify PROTO ((char *));

static void
serve_notify (arg)
    char *arg;
{
    struct notify_note *new = NULL;
    char *data = NULL;
    int status;

    if (error_pending ()) return;

    if (outside_dir (arg))
	return;

    if (dir_name == NULL)
	goto error;

    new = (struct notify_note *) malloc (sizeof (struct notify_note));
    if (new == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    new->dir = malloc (strlen (dir_name) + 1);
    new->filename = malloc (strlen (arg) + 1);
    if (new->dir == NULL || new->filename == NULL)
    {
	pending_error = ENOMEM;
	if (new->dir != NULL)
	    free (new->dir);
	free (new);
	return;
    }
    strcpy (new->dir, dir_name);
    strcpy (new->filename, arg);

    status = buf_read_line (buf_from_net, &data, (int *) NULL);
    if (status != 0)
    {
	if (status == -2)
	    pending_error = ENOMEM;
	else
	{
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
	    else
	    {
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading notification for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading notification for %s", arg);
		    pending_error = status;
		}
	    }
	}
	free (new->filename);
	free (new->dir);
	free (new);
    }
    else
    {
	char *cp;

	if (!data[0])
	    goto error;

	if (strchr (data, '+'))
	    goto error;

	new->type = data;
	if (data[1] != '\t')
	    goto error;
	data[1] = '\0';
	cp = data + 2;
	new->val = cp;
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '\0';
	new->watches = cp;
	/* If there is another tab, ignore everything after it,
	   for future expansion.  */
	cp = strchr (cp, '\t');
	if (cp != NULL)
	{
	    *cp = '\0';
	}

	new->next = NULL;

	if (last_node == NULL)
	{
	    notify_list = new;
	}
	else
	    last_node->next = new;
	last_node = new;
    }
    return;
  error:
    pending_error = 0;
    if (alloc_pending (80))
	strcpy (pending_error_text,
		"E Protocol error; misformed Notify request");
    if (data != NULL)
	free (data);
    if (new != NULL)
    {
	free (new->filename);
	free (new->dir);
	free (new);
    }
    return;
}

/* Process all the Notify requests that we have stored up.  Returns 0
   if successful, if not prints error message (via error()) and
   returns negative value.  */
static int
server_notify ()
{
    struct notify_note *p;
    char *repos;

    while (notify_list != NULL)
    {
	if ( CVS_CHDIR (notify_list->dir) < 0)
	{
	    error (0, errno, "cannot change to %s", notify_list->dir);
	    return -1;
	}
	repos = Name_Repository (NULL, NULL);

	lock_dir_for_write (repos);

	fileattr_startdir (repos);

	notify_do (*notify_list->type, notify_list->filename, getcaller(),
		   notify_list->val, notify_list->watches, repos);

	buf_output0 (buf_to_net, "Notified ");
	{
	    char *dir = notify_list->dir + strlen (server_temp_dir) + 1;
	    if (dir[0] == '\0')
	        buf_append_char (buf_to_net, '.');
	    else
	        buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '/');
	    buf_append_char (buf_to_net, '\n');
	}
	buf_output0 (buf_to_net, repos);
	buf_append_char (buf_to_net, '/');
	buf_output0 (buf_to_net, notify_list->filename);
	buf_append_char (buf_to_net, '\n');
	free (repos);

	p = notify_list->next;
	free (notify_list->filename);
	free (notify_list->dir);
	free (notify_list->type);
	free (notify_list);
	notify_list = p;

	fileattr_write ();
	fileattr_free ();

	Lock_Cleanup ();
    }

    last_node = NULL;

    /* The code used to call fflush (stdout) here, but that is no
       longer necessary.  The data is now buffered in buf_to_net,
       which will be flushed by the caller, do_cvs_command.  */

    return 0;
}

static int argument_count;
static char **argument_vector;
static int argument_vector_size;

static void
serve_argument (arg)
     char *arg;
{
    char *p;
    
    if (error_pending()) return;

    if (argument_count >= 10000)
    {
       if (alloc_pending (80))
           sprintf (pending_error_text,
                    "E Protocol error: too many arguments");
       return;
    }

    
    if (argument_vector_size <= argument_count)
    {
	argument_vector_size *= 2;
	argument_vector =
	    (char **) realloc ((char *)argument_vector,
			       argument_vector_size * sizeof (char *));
	if (argument_vector == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
    }
    p = malloc (strlen (arg) + 1);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (p, arg);
    argument_vector[argument_count++] = p;
}

static void
serve_argumentx (arg)
     char *arg;
{
    char *p;
    
    if (error_pending()) return;

    if (argument_count <= 1)
    {
        if (alloc_pending (80))
            sprintf (pending_error_text,
                     "E Protocol error: called argumentx without prior call to argument");
        return;
    }

    
    p = argument_vector[argument_count - 1];
    p = realloc (p, strlen (p) + 1 + strlen (arg) + 1);
    if (p == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcat (p, "\n");
    strcat (p, arg);
    argument_vector[argument_count - 1] = p;
}

static void
serve_global_option (arg)
    char *arg;
{
    if (arg[0] != '-' || arg[1] == '\0' || arg[2] != '\0')
    {
    error_return:
	if (alloc_pending (strlen (arg) + 80))
	    sprintf (pending_error_text,
		     "E Protocol error: bad global option %s",
		     arg);
	return;
    }
    switch (arg[1])
    {
	case 'n':
	    noexec = 1;
	    break;
	case 'q':
	    quiet = 1;
	    break;
	case 'r':
	    cvswrite = 0;
	    break;
	case 'Q':
	    really_quiet = 1;
	    break;
	case 'l':
	    logoff = 1;
	    break;
	case 't':
	    trace = 1;
	    break;
	default:
	    goto error_return;
    }
}

static void
serve_set (arg)
    char *arg;
{
    /* FIXME: This sends errors immediately (I think); they should be
       put into pending_error.  */
    variable_set (arg);
}

#ifdef ENCRYPTION

#ifdef HAVE_KERBEROS

static void
serve_kerberos_encrypt (arg)
     char *arg;
{
    /* All future communication with the client will be encrypted.  */

    buf_to_net = krb_encrypt_buffer_initialize (buf_to_net, 0, sched,
						kblock,
						buf_to_net->memory_error);
    buf_from_net = krb_encrypt_buffer_initialize (buf_from_net, 1, sched,
						  kblock,
						  buf_from_net->memory_error);
}

#endif /* HAVE_KERBEROS */

#ifdef HAVE_GSSAPI

static void
serve_gssapi_encrypt (arg)
     char *arg;
{
    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for stream
           authentication.  Flush everything we've output so far, and
           turn on encryption for future data.  On the input side, we
           should only have unwrapped as far as the Gssapi-encrypt
           command, so future unwrapping will become encrypted.  */
	buf_flush (buf_to_net, 1);
	cvs_gssapi_encrypt = 1;
	return;
    }

    /* All future communication with the client will be encrypted.  */

    cvs_gssapi_encrypt = 1;

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */

#endif /* ENCRYPTION */

#ifdef HAVE_GSSAPI

static void
serve_gssapi_authenticate (arg)
     char *arg;
{
    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for encryption.
           That includes authentication, so we don't have to do
           anything further.  */
	return;
    }

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */

#ifdef SERVER_FLOWCONTROL
/* The maximum we'll queue to the remote client before blocking.  */
# ifndef SERVER_HI_WATER
#  define SERVER_HI_WATER (2 * 1024 * 1024)
# endif /* SERVER_HI_WATER */
/* When the buffer drops to this, we restart the child */
# ifndef SERVER_LO_WATER
#  define SERVER_LO_WATER (1 * 1024 * 1024)
# endif /* SERVER_LO_WATER */

static int set_nonblock_fd PROTO((int));

/*
 * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */

static int
set_nonblock_fd (fd)
     int fd;
{
    int flags;

    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    return 0;
}

#endif /* SERVER_FLOWCONTROL */

static void serve_questionable PROTO((char *));

static void
serve_questionable (arg)
    char *arg;
{
    static int initted;

    if (!initted)
    {
	/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server,
	   and CVSIGNORE on server.  */
	ign_setup ();
	initted = 1;
    }

    if (dir_name == NULL)
    {
	buf_output0 (buf_to_net, "E Protocol error: 'Directory' missing");
	return;
    }

    if (outside_dir (arg))
	return;

    if (!ign_name (arg))
    {
	char *update_dir;

	buf_output (buf_to_net, "M ? ", 4);
	update_dir = dir_name + strlen (server_temp_dir) + 1;
	if (!(update_dir[0] == '.' && update_dir[1] == '\0'))
	{
	    buf_output0 (buf_to_net, update_dir);
	    buf_output (buf_to_net, "/", 1);
	}
	buf_output0 (buf_to_net, arg);
	buf_output (buf_to_net, "\n", 1);
    }
}

static void serve_case PROTO ((char *));

static void
serve_case (arg)
    char *arg;
{
    ign_case = 1;
}

static struct buffer *protocol;

/* This is the output which we are saving up to send to the server, in the
   child process.  We will push it through, via the `protocol' buffer, when
   we have a complete line.  */
static struct buffer *saved_output;
/* Likewise, but stuff which will go to stderr.  */
static struct buffer *saved_outerr;

static void
protocol_memory_error (buf)
    struct buffer *buf;
{
    error (1, ENOMEM, "Virtual memory exhausted");
}

/*
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
 */
static pid_t command_pid;

static void
outbuf_memory_error (buf)
    struct buffer *buf;
{
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    /*
     * We have arranged things so that printing this now either will
     * be legal, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */

    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
#ifdef HAVE_SYSLOG_H
    syslog (LOG_DAEMON | LOG_ERR, "virtual memory exhausted");
#endif
    error_exit ();
}

static void
input_memory_error (buf)
     struct buffer *buf;
{
    outbuf_memory_error (buf);
}



/* If command is legal, return 1.
 * Else if command is illegal and croak_on_illegal is set, then die.
 * Else just return 0 to indicate that command is illegal.
 */
static int
check_command_legal_p (cmd_name)
    char *cmd_name;
{
    /* Right now, only pserver notices illegal commands -- namely,
     * write attempts by a read-only user.  Therefore, if CVS_Username
     * is not set, this just returns 1, because CVS_Username unset
     * means pserver is not active.
     */
#ifdef AUTH_SERVER_SUPPORT
    if (CVS_Username == NULL)
        return 1;

    if (lookup_command_attribute (cmd_name) & CVS_CMD_MODIFIES_REPOSITORY)
    {
        /* This command has the potential to modify the repository, so
         * we check if the user have permission to do that.
         *
         * (Only relevant for remote users -- local users can do
         * whatever normal Unix file permissions allow them to do.)
         *
         * The decision method:
         *
         *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
         *    in it, then read-only access for user.
         *
         *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
         *    listed in it, then also read-only access for user.
         *
         *    Else read-write access for user.
         */

         char *linebuf = NULL;
         int num_red = 0;
         size_t linebuf_len = 0;
         char *fname;
         size_t flen;
         FILE *fp;
         int found_it = 0;
         
         /* else */
         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_READERS)
                + 3;

         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
			CVSROOTADM, CVSROOTADM_READERS);

         fp = fopen (fname, "r");

         if (fp == NULL)
	 {
	     if (!existence_error (errno))
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot open %s", fname);
		 free (fname);
		 return 0;
	     }
	 }
         else  /* successfully opened readers file */
         {
             while ((num_red = get_line (&linebuf, &linebuf_len, fp)) >= 0)
             {
                 /* Hmmm, is it worth importing my own readline
                    library into CVS?  It takes care of chopping
                    leading and trailing whitespace, "#" comments, and
                    newlines automatically when so requested.  Would
                    save some code here...  -kff */

                 /* Chop newline by hand, for strcmp()'s sake. */
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
                     linebuf[num_red - 1] = '\0';

                 if (strcmp (linebuf, CVS_Username) == 0)
                     goto handle_illegal;
             }
	     if (num_red < 0 && !feof (fp))
		 error (0, errno, "cannot read %s", fname);

             /* If not listed specifically as a reader, then this user
                has write access by default unless writers are also
                specified in a file . */
	     if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
         }
	 free (fname);

	 /* Now check the writers file.  */

         flen = strlen (current_parsed_root->directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_WRITERS)
                + 3;

         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
			CVSROOTADM, CVSROOTADM_WRITERS);

         fp = fopen (fname, "r");

         if (fp == NULL)
         {
	     if (linebuf)
	         free (linebuf);
	     if (existence_error (errno))
	     {
		 /* Writers file does not exist, so everyone is a writer,
		    by default.  */
		 free (fname);
		 return 1;
	     }
	     else
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot read %s", fname);
		 free (fname);
		 return 0;
	     }
         }

         found_it = 0;
         while ((num_red = get_line (&linebuf, &linebuf_len, fp)) >= 0)
         {
             /* Chop newline by hand, for strcmp()'s sake. */
             if (num_red > 0 && linebuf[num_red - 1] == '\n')
                 linebuf[num_red - 1] = '\0';
           
             if (strcmp (linebuf, CVS_Username) == 0)
             {
                 found_it = 1;
                 break;
             }
         }
	 if (num_red < 0 && !feof (fp))
	     error (0, errno, "cannot read %s", fname);

         if (found_it)
         {
             if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
             if (linebuf)
                 free (linebuf);
	     free (fname);
             return 1;
         }
         else   /* writers file exists, but this user not listed in it */
         {
         handle_illegal:
             if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
             if (linebuf)
                 free (linebuf);
	     free (fname);
	     return 0;
         }
    }
#endif /* AUTH_SERVER_SUPPORT */

    /* If ever reach end of this function, command must be legal. */
    return 1;
}



/* Execute COMMAND in a subprocess with the approriate funky things done.  */

static struct fd_set_wrapper { fd_set fds; } command_fds_to_drain;
static int max_command_fd;

#ifdef SERVER_FLOWCONTROL
static int flowcontrol_pipe[2];
#endif /* SERVER_FLOWCONTROL */

static void
do_cvs_command (cmd_name, command)
    char *cmd_name;
    int (*command) PROTO((int argc, char **argv));
{
    /*
     * The following file descriptors are set to -1 if that file is not
     * currently open.
     */

    /* Data on these pipes is a series of '\n'-terminated lines.  */
    int stdout_pipe[2];
    int stderr_pipe[2];

    /*
     * Data on this pipe is a series of counted (see buf_send_counted)
     * packets.  Each packet must be processed atomically (i.e. not
     * interleaved with data from stdout_pipe or stderr_pipe).
     */
    int protocol_pipe[2];
    
    int dev_null_fd = -1;

    int errs;

    command_pid = -1;
    stdout_pipe[0] = -1;
    stdout_pipe[1] = -1;
    stderr_pipe[0] = -1;
    stderr_pipe[1] = -1;
    protocol_pipe[0] = -1;
    protocol_pipe[1] = -1;

    server_write_entries ();

    if (print_pending_error ())
	goto free_args_and_return;

    /* Global `command_name' is probably "server" right now -- only
       serve_export() sets it to anything else.  So we will use local
       parameter `cmd_name' to determine if this command is legal for
       this user.  */
    if (!check_command_legal_p (cmd_name))
    {
	buf_output0 (buf_to_net, "E ");
	buf_output0 (buf_to_net, program_name);
	buf_output0 (buf_to_net, " [server aborted]: \"");
	buf_output0 (buf_to_net, cmd_name);
	buf_output0 (buf_to_net, "\" requires write access to the repository\n\
error  \n");
	goto free_args_and_return;
    }

    (void) server_notify ();

    /*
     * We use a child process which actually does the operation.  This
     * is so we can intercept its standard output.  Even if all of CVS
     * were written to go to some special routine instead of writing
     * to stdout or stderr, we would still need to do the same thing
     * for the RCS commands.
     */

    if (pipe (stdout_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (pipe (stderr_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (pipe (protocol_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
#ifdef SERVER_FLOWCONTROL
    if (pipe (flowcontrol_pipe) < 0)
    {
	buf_output0 (buf_to_net, "E pipe failed\n");
	print_error (errno);
	goto error_exit;
    }
    set_nonblock_fd (flowcontrol_pipe[0]);
    set_nonblock_fd (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

    dev_null_fd = CVS_OPEN (DEVNULL, O_RDONLY);
    if (dev_null_fd < 0)
    {
	buf_output0 (buf_to_net, "E open /dev/null failed\n");
	print_error (errno);
	goto error_exit;
    }

    /* We shouldn't have any partial lines from cvs_output and
       cvs_outerr, but we handle them here in case there is a bug.  */
    /* FIXME: appending a newline, rather than using "MT" as we
       do in the child process, is probably not really a very good
       way to "handle" them.  */
    if (! buf_empty_p (saved_output))
    {
	buf_append_char (saved_output, '\n');
	buf_copy_lines (buf_to_net, saved_output, 'M');
    }
    if (! buf_empty_p (saved_outerr))
    {
	buf_append_char (saved_outerr, '\n');
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
    }

    /* Flush out any pending data.  */
    buf_flush (buf_to_net, 1);

    /* Don't use vfork; we're not going to exec().  */
    command_pid = fork ();
    if (command_pid < 0)
    {
	buf_output0 (buf_to_net, "E fork failed\n");
	print_error (errno);
	goto error_exit;
    }
    if (command_pid == 0)
    {
	int exitstatus;

	/* Since we're in the child, and the parent is going to take
	   care of packaging up our error messages, we can clear this
	   flag.  */
	error_use_protocol = 0;

	protocol = fd_buffer_initialize (protocol_pipe[1], 0,
					 protocol_memory_error);

	/* At this point we should no longer be using buf_to_net and
           buf_from_net.  Instead, everything should go through
           protocol.  */
	buf_to_net = NULL;
	buf_from_net = NULL;

	/* These were originally set up to use outbuf_memory_error.
           Since we're now in the child, we should use the simpler
           protocol_memory_error function.  */
	saved_output->memory_error = protocol_memory_error;
	saved_outerr->memory_error = protocol_memory_error;

	if (dup2 (dev_null_fd, STDIN_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	if (dup2 (stdout_pipe[1], STDOUT_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	if (dup2 (stderr_pipe[1], STDERR_FILENO) < 0)
	    error (1, errno, "can't set up pipes");
	close (dev_null_fd);
	close (stdout_pipe[0]);
	close (stdout_pipe[1]);
	close (stderr_pipe[0]);
	close (stderr_pipe[1]);
	close (protocol_pipe[0]);
	close_on_exec (protocol_pipe[1]);
#ifdef SERVER_FLOWCONTROL
	close_on_exec (flowcontrol_pipe[0]);
	close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

	/*
	 * Set this in .bashrc if you want to give yourself time to attach
	 * to the subprocess with a debugger.
	 */
	if (getenv ("CVS_SERVER_SLEEP"))
	{
	    int secs = atoi (getenv ("CVS_SERVER_SLEEP"));
	    sleep (secs);
	}

	exitstatus = (*command) (argument_count, argument_vector);

	/* Output any partial lines.  If the client doesn't support
	   "MT", we go ahead and just tack on a newline since the
	   protocol doesn't support anything better.  */
	if (! buf_empty_p (saved_output))
	{
	    buf_output0 (protocol, supported_response ("MT") ? "MT text " : "M ");
	    buf_append_buffer (protocol, saved_output);
	    buf_output (protocol, "\n", 1);
	    buf_send_counted (protocol);
	}
	/* For now we just discard partial lines on stderr.  I suspect
	   that CVS can't write such lines unless there is a bug.  */

	/*
	 * When we exit, that will close the pipes, giving an EOF to
	 * the parent.
	 */
	buf_free (protocol);
	exit (exitstatus);
    }

    /* OK, sit around getting all the input from the child.  */
    {
	struct buffer *stdoutbuf;
	struct buffer *stderrbuf;
	struct buffer *protocol_inbuf;
	/* Number of file descriptors to check in select ().  */
	int num_to_check;
	int count_needed = 1;
#ifdef SERVER_FLOWCONTROL
	int have_flowcontrolled = 0;
#endif /* SERVER_FLOWCONTROL */

	FD_ZERO (&command_fds_to_drain.fds);
	num_to_check = stdout_pipe[0];
	FD_SET (stdout_pipe[0], &command_fds_to_drain.fds);
	if (stderr_pipe[0] > num_to_check)
	  num_to_check = stderr_pipe[0];
	FD_SET (stderr_pipe[0], &command_fds_to_drain.fds);
	if (protocol_pipe[0] > num_to_check)
	  num_to_check = protocol_pipe[0];
	FD_SET (protocol_pipe[0], &command_fds_to_drain.fds);
	if (STDOUT_FILENO > num_to_check)
	  num_to_check = STDOUT_FILENO;
	max_command_fd = num_to_check;
	/*
	 * File descriptors are numbered from 0, so num_to_check needs to
	 * be one larger than the largest descriptor.
	 */
	++num_to_check;
	if (num_to_check > FD_SETSIZE)
	{
	    buf_output0 (buf_to_net,
			 "E internal error: FD_SETSIZE not big enough.\n\
error  \n");
	    goto error_exit;
	}

	stdoutbuf = fd_buffer_initialize (stdout_pipe[0], 1,
					  input_memory_error);

	stderrbuf = fd_buffer_initialize (stderr_pipe[0], 1,
					  input_memory_error);

	protocol_inbuf = fd_buffer_initialize (protocol_pipe[0], 1,
					       input_memory_error);

	set_nonblock (buf_to_net);
	set_nonblock (stdoutbuf);
	set_nonblock (stderrbuf);
	set_nonblock (protocol_inbuf);

	if (close (stdout_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	stdout_pipe[1] = -1;

	if (close (stderr_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	stderr_pipe[1] = -1;

	if (close (protocol_pipe[1]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	protocol_pipe[1] = -1;

#ifdef SERVER_FLOWCONTROL
	if (close (flowcontrol_pipe[0]) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	flowcontrol_pipe[0] = -1;
#endif /* SERVER_FLOWCONTROL */

	if (close (dev_null_fd) < 0)
	{
	    buf_output0 (buf_to_net, "E close failed\n");
	    print_error (errno);
	    goto error_exit;
	}
	dev_null_fd = -1;

	while (stdout_pipe[0] >= 0
	       || stderr_pipe[0] >= 0
	       || protocol_pipe[0] >= 0
	       || count_needed <= 0)
	{
	    fd_set readfds;
	    fd_set writefds;
	    int numfds;
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;
	    struct timeval *timeout_ptr;
	    struct timeval timeout;

	    /*
	     * See if we are swamping the remote client and filling our VM.
	     * Tell child to hold off if we do.
	     */
	    bufmemsize = buf_count_mem (buf_to_net);
	    if (!have_flowcontrolled && (bufmemsize > SERVER_HI_WATER))
	    {
		if (write(flowcontrol_pipe[1], "S", 1) == 1)
		    have_flowcontrolled = 1;
	    }
	    else if (have_flowcontrolled && (bufmemsize < SERVER_LO_WATER))
	    {
		if (write(flowcontrol_pipe[1], "G", 1) == 1)
		    have_flowcontrolled = 0;
	    }
#endif /* SERVER_FLOWCONTROL */

	    FD_ZERO (&readfds);
	    FD_ZERO (&writefds);

	    if (count_needed <= 0)
	    {
		/* there is data pending which was read from the protocol pipe
		 * so don't block if we don't find any data
		 */
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		timeout_ptr = &timeout;
	    }
	    else
	    {
		/* block indefinately */
		timeout_ptr = NULL;
	    }

	    if (! buf_empty_p (buf_to_net))
		FD_SET (STDOUT_FILENO, &writefds);

	    if (stdout_pipe[0] >= 0)
	    {
		FD_SET (stdout_pipe[0], &readfds);
	    }
	    if (stderr_pipe[0] >= 0)
	    {
		FD_SET (stderr_pipe[0], &readfds);
	    }
	    if (protocol_pipe[0] >= 0)
	    {
		FD_SET (protocol_pipe[0], &readfds);
	    }

	    /* This process of selecting on the three pipes means that
	     we might not get output in the same order in which it
	     was written, thus producing the well-known
	     "out-of-order" bug.  If the child process uses
	     cvs_output and cvs_outerr, it will send everything on
	     the protocol_pipe and avoid this problem, so the
	     solution is to use cvs_output and cvs_outerr in the
	     child process.  */
	    do {
		/* This used to select on exceptions too, but as far
                   as I know there was never any reason to do that and
                   SCO doesn't let you select on exceptions on pipes.  */
		numfds = select (num_to_check, &readfds, &writefds,
				 (fd_set *)0, timeout_ptr);
		if (numfds < 0
			&& errno != EINTR)
		{
		    buf_output0 (buf_to_net, "E select failed\n");
		    print_error (errno);
		    goto error_exit;
		}
	    } while (numfds < 0);

	    if (numfds == 0)
	    {
		FD_ZERO (&readfds);
		FD_ZERO (&writefds);
	    }

	    if (FD_ISSET (STDOUT_FILENO, &writefds))
	    {
		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (protocol_pipe[0] >= 0
		&& (FD_ISSET (protocol_pipe[0], &readfds)))
	    {
		int status;
		int count_read;
		
		status = buf_input_data (protocol_inbuf, &count_read);

		if (status == -1)
		{
		    close (protocol_pipe[0]);
		    protocol_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/*
		 * We only call buf_copy_counted if we have read
		 * enough bytes to make it worthwhile.  This saves us
		 * from continually recounting the amount of data we
		 * have.
		 */
		count_needed -= count_read;
	    }
	    /* this is still part of the protocol pipe procedure, but it is
	     * outside the above conditional so that unprocessed data can be
	     * left in the buffer and stderr/stdout can be read when a flush
	     * signal is received and control can return here without passing
	     * through the select code and maybe blocking
	     */
	    while (count_needed <= 0)
	    {
		int special = 0;

		count_needed = buf_copy_counted (buf_to_net,
						     protocol_inbuf,
						     &special);

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);

		/* If SPECIAL got set to <0, it means that the child
		 * wants us to flush the pipe & maybe stderr or stdout.
		 *
		 * After that we break to read stderr & stdout again before
		 * going back to the protocol pipe
		 *
		 * Upon breaking, count_needed = 0, so the next pass will only
		 * perform a non-blocking select before returning here to finish
		 * processing data we already read from the protocol buffer
		 */
		 if (special == -1)
		 {
		     cvs_flushout();
		     break;
		 }
		if (special == -2)
		{
		    /* If the client supports the 'F' command, we send it. */
		    if (supported_response ("F"))
		    {
			buf_append_char (buf_to_net, 'F');
			buf_append_char (buf_to_net, '\n');
		    }
		    cvs_flusherr ();
		    break;
		}
	    }

	    if (stdout_pipe[0] >= 0
		&& (FD_ISSET (stdout_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stdoutbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stdoutbuf, 'M');

		if (status == -1)
		{
		    close (stdout_pipe[0]);
		    stdout_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (stderr_pipe[0] >= 0
		&& (FD_ISSET (stderr_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stderrbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stderrbuf, 'E');

		if (status == -1)
		{
		    close (stderr_pipe[0]);
		    stderr_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }
	}

	/*
	 * OK, we've gotten EOF on all the pipes.  If there is
	 * anything left on stdoutbuf or stderrbuf (this could only
	 * happen if there was no trailing newline), send it over.
	 */
	if (! buf_empty_p (stdoutbuf))
	{
	    buf_append_char (stdoutbuf, '\n');
	    buf_copy_lines (buf_to_net, stdoutbuf, 'M');
	}
	if (! buf_empty_p (stderrbuf))
	{
	    buf_append_char (stderrbuf, '\n');
	    buf_copy_lines (buf_to_net, stderrbuf, 'E');
	}
	if (! buf_empty_p (protocol_inbuf))
	    buf_output0 (buf_to_net,
			 "E Protocol error: uncounted data discarded\n");

#ifdef SERVER_FLOWCONTROL
	close (flowcontrol_pipe[1]);
	flowcontrol_pipe[1] = -1;
#endif /* SERVER_FLOWCONTROL */

	errs = 0;

	while (command_pid > 0)
	{
	    int status;
	    pid_t waited_pid;
	    waited_pid = waitpid (command_pid, &status, 0);
	    if (waited_pid < 0)
	    {
		/*
		 * Intentionally ignoring EINTR.  Other errors
		 * "can't happen".
		 */
		continue;
	    }
	    
	    if (WIFEXITED (status))
		errs += WEXITSTATUS (status);
	    else
	    {
	        int sig = WTERMSIG (status);
	        char buf[50];
		/*
		 * This is really evil, because signals might be numbered
		 * differently on the two systems.  We should be using
		 * signal names (either of the "Terminated" or the "SIGTERM"
		 * variety).  But cvs doesn't currently use libiberty...we
		 * could roll our own....  FIXME.
		 */
		buf_output0 (buf_to_net, "E Terminated with fatal signal ");
		sprintf (buf, "%d\n", sig);
		buf_output0 (buf_to_net, buf);

		/* Test for a core dump.  Is this portable?  */
		if (status & 0x80)
		{
		    buf_output0 (buf_to_net, "E Core dumped; preserving ");
		    buf_output0 (buf_to_net, orig_server_temp_dir);
		    buf_output0 (buf_to_net, " on server.\n\
E CVS locks may need cleaning up.\n");
		    dont_delete_temp = 1;
		}
		++errs;
	    }
	    if (waited_pid == command_pid)
		command_pid = -1;
	}

	/*
	 * OK, we've waited for the child.  By now all CVS locks are free
	 * and it's OK to block on the network.
	 */
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);
	buf_shutdown (protocol_inbuf);
	buf_free (protocol_inbuf);
	buf_shutdown (stderrbuf);
	buf_free (stderrbuf);
	buf_shutdown (stdoutbuf);
	buf_free (stdoutbuf);
    }

    if (errs)
	/* We will have printed an error message already.  */
	buf_output0 (buf_to_net, "error  \n");
    else
	buf_output0 (buf_to_net, "ok\n");
    goto free_args_and_return;

 error_exit:
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    while (command_pid > 0)
    {
	pid_t waited_pid;
	waited_pid = waitpid (command_pid, (int *) 0, 0);
	if (waited_pid < 0 && errno == EINTR)
	    continue;
	if (waited_pid == command_pid)
	    command_pid = -1;
    }

    close (dev_null_fd);
    close (protocol_pipe[0]);
    close (protocol_pipe[1]);
    close (stderr_pipe[0]);
    close (stderr_pipe[1]);
    close (stdout_pipe[0]);
    close (stdout_pipe[1]);
#ifdef SERVER_FLOWCONTROL
    close (flowcontrol_pipe[0]);
    close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

 free_args_and_return:
    /* Now free the arguments.  */
    {
	/* argument_vector[0] is a dummy argument, we don't mess with it.  */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }

    /* Flush out any data not yet sent.  */
    set_block (buf_to_net);
    buf_flush (buf_to_net, 1);

    return;
}

#ifdef SERVER_FLOWCONTROL
/*
 * Called by the child at convenient points in the server's execution for
 * the server child to block.. ie: when it has no locks active.
 */
void
server_pause_check()
{
    int paused = 0;
    char buf[1];

    while (read (flowcontrol_pipe[0], buf, 1) == 1)
    {
	if (*buf == 'S')	/* Stop */
	    paused = 1;
	else if (*buf == 'G')	/* Go */
	    paused = 0;
	else
	    return;		/* ??? */
    }
    while (paused) {
	int numfds, numtocheck;
	fd_set fds;

	FD_ZERO (&fds);
	FD_SET (flowcontrol_pipe[0], &fds);
	numtocheck = flowcontrol_pipe[0] + 1;
	
	do {
	    numfds = select (numtocheck, &fds, (fd_set *)0,
			     (fd_set *)0, (struct timeval *)NULL);
	    if (numfds < 0
		&& errno != EINTR)
	    {
		buf_output0 (buf_to_net, "E select failed\n");
		print_error (errno);
		return;
	    }
	} while (numfds < 0);
	    
	if (FD_ISSET (flowcontrol_pipe[0], &fds))
	{
	    int got;

	    while ((got = read (flowcontrol_pipe[0], buf, 1)) == 1)
	    {
		if (*buf == 'S')	/* Stop */
		    paused = 1;
		else if (*buf == 'G')	/* Go */
		    paused = 0;
		else
		    return;		/* ??? */
	    }

	    /* This assumes that we are using BSD or POSIX nonblocking
               I/O.  System V nonblocking I/O returns zero if there is
               nothing to read.  */
	    if (got == 0)
	        error (1, 0, "flow control EOF");
	    if (got < 0 && ! blocking_error (errno))
	    {
	        error (1, errno, "flow control read failed");
	    }
	}
    }
}
#endif /* SERVER_FLOWCONTROL */

/* This variable commented in server.h.  */
char *server_dir = NULL;

static void output_dir PROTO((char *, char *));

static void
output_dir (update_dir, repository)
    char *update_dir;
    char *repository;
{
    if (server_dir != NULL)
    {
	buf_output0 (protocol, server_dir);
	buf_output0 (protocol, "/");
    }
    if (update_dir[0] == '\0')
	buf_output0 (protocol, ".");
    else
	buf_output0 (protocol, update_dir);
    buf_output0 (protocol, "/\n");
    buf_output0 (protocol, repository);
    buf_output0 (protocol, "/");
}

/*
 * Entries line that we are squirreling away to send to the client when
 * we are ready.
 */
static char *entries_line;

/*
 * File which has been Scratch_File'd, we are squirreling away that fact
 * to inform the client when we are ready.
 */
static char *scratched_file;

/*
 * The scratched_file will need to be removed as well as having its entry
 * removed.
 */
static int kill_scratched_file;

void
server_register (name, version, timestamp, options, tag, date, conflict)
    char *name;
    char *version;
    char *timestamp;
    char *options;
    char *tag;
    char *date;
    char *conflict;
{
    int len;

    if (options == NULL)
	options = "";

    if (trace)
    {
	(void) fprintf (stderr,
			"%s-> server_register(%s, %s, %s, %s, %s, %s, %s)\n",
			CLIENT_SERVER_STR,
			name, version, timestamp ? timestamp : "", options,
			tag ? tag : "", date ? date : "",
			conflict ? conflict : "");
    }

    if (entries_line != NULL)
    {
	/*
	 * If CVS decides to Register it more than once (which happens
	 * on "cvs update foo/foo.c" where foo and foo.c are already
	 * checked out), use the last of the entries lines Register'd.
	 */
	free (entries_line);
    }

    /*
     * I have reports of Scratch_Entry and Register both happening, in
     * two different cases.  Using the last one which happens is almost
     * surely correct; I haven't tracked down why they both happen (or
     * even verified that they are for the same file).
     */
    if (scratched_file != NULL)
    {
	free (scratched_file);
	scratched_file = NULL;
    }

    len = (strlen (name) + strlen (version) + strlen (options) + 80);
    if (tag)
	len += strlen (tag);
    if (date)
	len += strlen (date);
    
    entries_line = xmalloc (len);
    sprintf (entries_line, "/%s/%s/", name, version);
    if (conflict != NULL)
    {
	strcat (entries_line, "+=");
    }
    strcat (entries_line, "/");
    strcat (entries_line, options);
    strcat (entries_line, "/");
    if (tag != NULL)
    {
	strcat (entries_line, "T");
	strcat (entries_line, tag);
    }
    else if (date != NULL)
    {
	strcat (entries_line, "D");
	strcat (entries_line, date);
    }
}

void
server_scratch (fname)
    char *fname;
{
    /*
     * I have reports of Scratch_Entry and Register both happening, in
     * two different cases.  Using the last one which happens is almost
     * surely correct; I haven't tracked down why they both happen (or
     * even verified that they are for the same file).
     *
     * Don't know if this is what whoever wrote the above comment was
     * talking about, but this can happen in the case where a join
     * removes a file - the call to Register puts the '-vers' into the
     * Entries file after the file is removed
     */
    if (entries_line != NULL)
    {
	free (entries_line);
	entries_line = NULL;
    }

    if (scratched_file != NULL)
    {
	buf_output0 (protocol,
		     "E CVS server internal error: duplicate Scratch_Entry\n");
	buf_send_counted (protocol);
	return;
    }
    scratched_file = xstrdup (fname);
    kill_scratched_file = 1;
}

void
server_scratch_entry_only ()
{
    kill_scratched_file = 0;
}

/* Print a new entries line, from a previous server_register.  */
static void
new_entries_line ()
{
    if (entries_line)
    {
	buf_output0 (protocol, entries_line);
	buf_output (protocol, "\n", 1);
    }
    else
	/* Return the error message as the Entries line.  */
	buf_output0 (protocol,
		     "CVS server internal error: Register missing\n");
    free (entries_line);
    entries_line = NULL;
}


static void
serve_ci (arg)
    char *arg;
{
    do_cvs_command ("commit", commit);
}

static void
checked_in_response (file, update_dir, repository)
    char *file;
    char *update_dir;
    char *repository;
{
    if (supported_response ("Mode"))
    {
	struct stat sb;
	char *mode_string;

	if ( CVS_STAT (file, &sb) < 0)
	{
	    /* Not clear to me why the file would fail to exist, but it
	       was happening somewhere in the testsuite.  */
	    if (!existence_error (errno))
		error (0, errno, "cannot stat %s", file);
	}
	else
	{
	    buf_output0 (protocol, "Mode ");
	    mode_string = mode_to_string (sb.st_mode);
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
	    free (mode_string);
	}
    }

    buf_output0 (protocol, "Checked-in ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, file);
    buf_output (protocol, "\n", 1);
    new_entries_line ();
}

void
server_checked_in (file, update_dir, repository)
    char *file;
    char *update_dir;
    char *repository;
{
    if (noexec)
	return;
    if (scratched_file != NULL && entries_line == NULL)
    {
	/*
	 * This happens if we are now doing a "cvs remove" after a previous
	 * "cvs add" (without a "cvs ci" in between).
	 */
	buf_output0 (protocol, "Remove-entry ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
	free (scratched_file);
	scratched_file = NULL;
    }
    else
    {
	checked_in_response (file, update_dir, repository);
    }
    buf_send_counted (protocol);
}

void
server_update_entries (file, update_dir, repository, updated)
    char *file;
    char *update_dir;
    char *repository;
    enum server_updated_arg4 updated;
{
    if (noexec)
	return;
    if (updated == SERVER_UPDATED)
	checked_in_response (file, update_dir, repository);
    else
    {
	if (!supported_response ("New-entry"))
	    return;
	buf_output0 (protocol, "New-entry ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
	new_entries_line ();
    }

    buf_send_counted (protocol);
}

static void
serve_update (arg)
    char *arg;
{
    do_cvs_command ("update", update);
}

static void
serve_diff (arg)
    char *arg;
{
    do_cvs_command ("diff", diff);
}

static void
serve_log (arg)
    char *arg;
{
    do_cvs_command ("log", cvslog);
}

static void
serve_rlog (arg)
    char *arg;
{
    /* Tell cvslog() to behave like rlog not log.  */
    command_name = "rlog";
    do_cvs_command ("rlog", cvslog);
}

static void
serve_add (arg)
    char *arg;
{
    do_cvs_command ("add", add);
}

static void
serve_remove (arg)
    char *arg;
{
    do_cvs_command ("remove", cvsremove);
}

static void
serve_status (arg)
    char *arg;
{
    do_cvs_command ("status", cvsstatus);
}

static void
serve_rdiff (arg)
    char *arg;
{
    do_cvs_command ("rdiff", patch);
}

static void
serve_tag (arg)
    char *arg;
{
    do_cvs_command ("cvstag", cvstag);
}

static void
serve_rtag (arg)
    char *arg;
{
    /* Tell cvstag() to behave like rtag not tag.  */
    command_name = "rtag";
    do_cvs_command ("rtag", cvstag);
}

static void
serve_import (arg)
    char *arg;
{
    do_cvs_command ("import", import);
}

static void
serve_admin (arg)
    char *arg;
{
    do_cvs_command ("admin", admin);
}

static void
serve_history (arg)
    char *arg;
{
    do_cvs_command ("history", history);
}

static void
serve_release (arg)
    char *arg;
{
    do_cvs_command ("release", release);
}

static void serve_watch_on PROTO ((char *));

static void
serve_watch_on (arg)
    char *arg;
{
    do_cvs_command ("watch_on", watch_on);
}

static void serve_watch_off PROTO ((char *));

static void
serve_watch_off (arg)
    char *arg;
{
    do_cvs_command ("watch_off", watch_off);
}

static void serve_watch_add PROTO ((char *));

static void
serve_watch_add (arg)
    char *arg;
{
    do_cvs_command ("watch_add", watch_add);
}

static void serve_watch_remove PROTO ((char *));

static void
serve_watch_remove (arg)
    char *arg;
{
    do_cvs_command ("watch_remove", watch_remove);
}

static void serve_watchers PROTO ((char *));

static void
serve_watchers (arg)
    char *arg;
{
    do_cvs_command ("watchers", watchers);
}

static void serve_editors PROTO ((char *));

static void
serve_editors (arg)
    char *arg;
{
    do_cvs_command ("editors", editors);
}

static void serve_noop PROTO ((char *));

static void
serve_noop (arg)
    char *arg;
{

    server_write_entries ();
    if (!print_pending_error ())
    {
	(void) server_notify ();
	buf_output0 (buf_to_net, "ok\n");
    }
    buf_flush (buf_to_net, 1);
}

static void serve_version PROTO ((char *));

static void
serve_version (arg)
    char *arg;
{
    do_cvs_command ("version", version);
}

static void serve_init PROTO ((char *));

static void
serve_init (arg)
    char *arg;
{
    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	/* Fall through to do_cvs_command which will return the
	   actual error.  */
    }

    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
    current_parsed_root = local_cvsroot (arg);

    do_cvs_command ("init", init);
}

static void serve_annotate PROTO ((char *));

static void
serve_annotate (arg)
    char *arg;
{
    do_cvs_command ("annotate", annotate);
}

static void serve_rannotate PROTO ((char *));

static void
serve_rannotate (arg)
    char *arg;
{
    /* Tell annotate() to behave like rannotate not annotate.  */
    command_name = "rannotate";
    do_cvs_command ("rannotate", annotate);
}

static void
serve_co (arg)
    char *arg;
{
    char *tempdir;
    int status;

    if (print_pending_error ())
	return;

    if (!isdir (CVSADM))
    {
	/*
	 * The client has not sent a "Repository" line.  Check out
	 * into a pristine directory.
	 */
	tempdir = malloc (strlen (server_temp_dir) + 80);
	if (tempdir == NULL)
	{
	    buf_output0 (buf_to_net, "E Out of memory\n");
	    return;
	}
	strcpy (tempdir, server_temp_dir);
	strcat (tempdir, "/checkout-dir");
	status = mkdir_p (tempdir);
	if (status != 0 && status != EEXIST)
	{
	    buf_output0 (buf_to_net, "E Cannot create ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
	    print_error (errno);
	    free (tempdir);
	    return;
	}

	if ( CVS_CHDIR (tempdir) < 0)
	{
	    buf_output0 (buf_to_net, "E Cannot change to directory ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
	    print_error (errno);
	    free (tempdir);
	    return;
	}
	free (tempdir);
    }

    /* Compensate for server_export()'s setting of command_name.
     *
     * [It probably doesn't matter if do_cvs_command() gets "export"
     *  or "checkout", but we ought to be accurate where possible.]
     */
    do_cvs_command ((strcmp (command_name, "export") == 0) ?
                    "export" : "checkout",
                    checkout);
}

static void
serve_export (arg)
    char *arg;
{
    /* Tell checkout() to behave like export not checkout.  */
    command_name = "export";
    serve_co (arg);
}

void
server_copy_file (file, update_dir, repository, newfile)
    char *file;
    char *update_dir;
    char *repository;
    char *newfile;
{
    /* At least for now, our practice is to have the server enforce
       noexec for the repository and the client enforce it for the
       working directory.  This might want more thought, and/or
       documentation in cvsclient.texi (other responses do it
       differently).  */

    if (!supported_response ("Copy-file"))
	return;
    buf_output0 (protocol, "Copy-file ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, file);
    buf_output0 (protocol, "\n");
    buf_output0 (protocol, newfile);
    buf_output0 (protocol, "\n");
}

/* See server.h for description.  */

void
server_modtime (finfo, vers_ts)
    struct file_info *finfo;
    Vers_TS *vers_ts;
{
    char date[MAXDATELEN];
    char outdate[MAXDATELEN];

    assert (vers_ts->vn_rcs != NULL);

    if (!supported_response ("Mod-time"))
	return;

    if (RCS_getrevtime (finfo->rcs, vers_ts->vn_rcs, date, 0) == (time_t) -1)
	/* FIXME? should we be printing some kind of warning?  For one
	   thing I'm not 100% sure whether this happens in non-error
	   circumstances.  */
	return;
    date_to_internet (outdate, date);
    buf_output0 (protocol, "Mod-time ");
    buf_output0 (protocol, outdate);
    buf_output0 (protocol, "\n");
}

/* See server.h for description.  */

#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
/* Need to prototype because mode_t might be smaller than int.  */
void
server_updated (
    struct file_info *finfo,
    Vers_TS *vers,
    enum server_updated_arg4 updated,
    mode_t mode,
    unsigned char *checksum,
    struct buffer *filebuf)
#else
void
server_updated (finfo, vers, updated, mode, checksum, filebuf)
    struct file_info *finfo;
    Vers_TS *vers;
    enum server_updated_arg4 updated;
    mode_t mode;
    unsigned char *checksum;
    struct buffer *filebuf;
#endif
{
    if (noexec)
    {
	/* Hmm, maybe if we did the same thing for entries_file, we
	   could get rid of the kludges in server_register and
	   server_scratch which refrain from warning if both
	   Scratch_Entry and Register get called.  Maybe.  */
	if (scratched_file)
	{
	    free (scratched_file);
	    scratched_file = NULL;
	}
	return;
    }

    if (entries_line != NULL && scratched_file == NULL)
    {
	FILE *f;
	struct buffer_data *list, *last;
	unsigned long size;
	char size_text[80];

	/* The contents of the file will be in one of filebuf,
	   list/last, or here.  */
	unsigned char *file;
	size_t file_allocated;
	size_t file_used;

	if (filebuf != NULL)
	{
	    size = buf_length (filebuf);
	    if (mode == (mode_t) -1)
		error (1, 0, "\
CVS server internal error: no mode in server_updated");
	}
	else
	{
	    struct stat sb;

	    if ( CVS_STAT (finfo->file, &sb) < 0)
	    {
		if (existence_error (errno))
		{
		    /* If we have a sticky tag for a branch on which
		       the file is dead, and cvs update the directory,
		       it gets a T_CHECKOUT but no file.  So in this
		       case just forget the whole thing.  */
		    free (entries_line);
		    entries_line = NULL;
		    goto done;
		}
		error (1, errno, "reading %s", finfo->fullname);
	    }
	    size = sb.st_size;
	    if (mode == (mode_t) -1)
	    {
		/* FIXME: When we check out files the umask of the
		   server (set in .bashrc if rsh is in use) affects
		   what mode we send, and it shouldn't.  */
		mode = sb.st_mode;
	    }
	}

	if (checksum != NULL)
	{
	    static int checksum_supported = -1;

	    if (checksum_supported == -1)
	    {
		checksum_supported = supported_response ("Checksum");
	    }

	    if (checksum_supported)
	    {
	        int i;
		char buf[3];

	        buf_output0 (protocol, "Checksum ");
		for (i = 0; i < 16; i++)
		{
		    sprintf (buf, "%02x", (unsigned int) checksum[i]);
		    buf_output0 (protocol, buf);
		}
		buf_append_char (protocol, '\n');
	    }
	}

	if (updated == SERVER_UPDATED)
	{
	    Node *node;
	    Entnode *entnode;

	    if (!(supported_response ("Created")
		  && supported_response ("Update-existing")))
		buf_output0 (protocol, "Updated ");
	    else
	    {
		assert (vers != NULL);
		if (vers->ts_user == NULL)
		    buf_output0 (protocol, "Created ");
		else
		    buf_output0 (protocol, "Update-existing ");
	    }

	    /* Now munge the entries to say that the file is unmodified,
	       in case we end up processing it again (e.g. modules3-6
	       in the testsuite).  */
	    node = findnode_fn (finfo->entries, finfo->file);
	    entnode = (Entnode *)node->data;
	    free (entnode->timestamp);
	    entnode->timestamp = xstrdup ("=");
	}
	else if (updated == SERVER_MERGED)
	    buf_output0 (protocol, "Merged ");
	else if (updated == SERVER_PATCHED)
	    buf_output0 (protocol, "Patched ");
	else if (updated == SERVER_RCS_DIFF)
	    buf_output0 (protocol, "Rcs-diff ");
	else
	    abort ();
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);

	new_entries_line ();

        {
	    char *mode_string;

	    mode_string = mode_to_string (mode);
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
	    free (mode_string);
	}

	list = last = NULL;

	file = NULL;
	file_allocated = 0;
	file_used = 0;

	if (size > 0)
	{
	    /* Throughout this section we use binary mode to read the
	       file we are sending.  The client handles any line ending
	       translation if necessary.  */

	    if (file_gzip_level
		/*
		 * For really tiny files, the gzip process startup
		 * time will outweigh the compression savings.  This
		 * might be computable somehow; using 100 here is just
		 * a first approximation.
		 */
		&& size > 100)
	    {
		/* Basing this routine on read_and_gzip is not a
		   high-performance approach.  But it seems easier
		   to code than the alternative (and less
		   vulnerable to subtle bugs).  Given that this feature
		   is mainly for compatibility, that is the better
		   tradeoff.  */

		int fd;

		/* Callers must avoid passing us a buffer if
                   file_gzip_level is set.  We could handle this case,
                   but it's not worth it since this case never arises
                   with a current client and server.  */
		if (filebuf != NULL)
		    error (1, 0, "\
CVS server internal error: unhandled case in server_updated");

		fd = CVS_OPEN (finfo->file, O_RDONLY | OPEN_BINARY, 0);
		if (fd < 0)
		    error (1, errno, "reading %s", finfo->fullname);
		if (read_and_gzip (fd, finfo->fullname, &file,
				   &file_allocated, &file_used,
				   file_gzip_level))
		    error (1, 0, "aborting due to compression error");
		size = file_used;
		if (close (fd) < 0)
		    error (1, errno, "reading %s", finfo->fullname);
		/* Prepending length with "z" is flag for using gzip here.  */
		buf_output0 (protocol, "z");
	    }
	    else if (filebuf == NULL)
	    {
		long status;

		f = CVS_FOPEN (finfo->file, "rb");
		if (f == NULL)
		    error (1, errno, "reading %s", finfo->fullname);
		status = buf_read_file (f, size, &list, &last);
		if (status == -2)
		    (*protocol->memory_error) (protocol);
		else if (status != 0)
		    error (1, ferror (f) ? errno : 0, "reading %s",
			   finfo->fullname);
		if (fclose (f) == EOF)
		    error (1, errno, "reading %s", finfo->fullname);
	    }
	}

	sprintf (size_text, "%lu\n", size);
	buf_output0 (protocol, size_text);

	if (file != NULL)
	{
	    buf_output (protocol, (char *) file, file_used);
	    free (file);
	    file = NULL;
	}
	else if (filebuf == NULL)
	    buf_append_data (protocol, list, last);
	else
	{
	    buf_append_buffer (protocol, filebuf);
	    buf_free (filebuf);
	}
	/* Note we only send a newline here if the file ended with one.  */

	/*
	 * Avoid using up too much disk space for temporary files.
	 * A file which does not exist indicates that the file is up-to-date,
	 * which is now the case.  If this is SERVER_MERGED, the file is
	 * not up-to-date, and we indicate that by leaving the file there.
	 * I'm thinking of cases like "cvs update foo/foo.c foo".
	 */
	if ((updated == SERVER_UPDATED
	     || updated == SERVER_PATCHED
	     || updated == SERVER_RCS_DIFF)
	    && filebuf == NULL
	    /* But if we are joining, we'll need the file when we call
	       join_file.  */
	    && !joining ())
	{
	    if (CVS_UNLINK (finfo->file) < 0)
		error (0, errno, "cannot remove temp file for %s",
		       finfo->fullname);
	}
    }
    else if (scratched_file != NULL && entries_line == NULL)
    {
	if (strcmp (scratched_file, finfo->file) != 0)
	    error (1, 0,
		   "CVS server internal error: `%s' vs. `%s' scratched",
		   scratched_file,
		   finfo->file);
	free (scratched_file);
	scratched_file = NULL;

	if (kill_scratched_file)
	    buf_output0 (protocol, "Removed ");
	else
	    buf_output0 (protocol, "Remove-entry ");
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);
	/* keep the vers structure up to date in case we do a join
	 * - if there isn't a file, it can't very well have a version number, can it?
	 *
	 * we do it here on the assumption that since we just told the client
	 * to remove the file/entry, it will, and we want to remember that.
	 * If it fails, that's the client's problem, not ours
	 */
	if (vers && vers->vn_user != NULL)
	{
	    free (vers->vn_user);
	    vers->vn_user = NULL;
	}
	if (vers && vers->ts_user != NULL)
	{
	    free (vers->ts_user);
	    vers->ts_user = NULL;
	}
    }
    else if (scratched_file == NULL && entries_line == NULL)
    {
	/*
	 * This can happen with death support if we were processing
	 * a dead file in a checkout.
	 */
    }
    else
	error (1, 0,
	       "CVS server internal error: Register *and* Scratch_Entry.\n");
    buf_send_counted (protocol);
  done:;
}

/* Return whether we should send patches in RCS format.  */

int
server_use_rcs_diff ()
{
    return supported_response ("Rcs-diff");
}

void
server_set_entstat (update_dir, repository)
    char *update_dir;
    char *repository;
{
    static int set_static_supported = -1;
    if (set_static_supported == -1)
	set_static_supported = supported_response ("Set-static-directory");
    if (!set_static_supported) return;

    buf_output0 (protocol, "Set-static-directory ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
}

void
server_clear_entstat (update_dir, repository)
     char *update_dir;
     char *repository;
{
    static int clear_static_supported = -1;
    if (clear_static_supported == -1)
	clear_static_supported = supported_response ("Clear-static-directory");
    if (!clear_static_supported) return;

    if (noexec)
	return;

    buf_output0 (protocol, "Clear-static-directory ");
    output_dir (update_dir, repository);
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
}

void
server_set_sticky (update_dir, repository, tag, date, nonbranch)
    char *update_dir;
    char *repository;
    char *tag;
    char *date;
    int nonbranch;
{
    static int set_sticky_supported = -1;

    assert (update_dir != NULL);

    if (set_sticky_supported == -1)
	set_sticky_supported = supported_response ("Set-sticky");
    if (!set_sticky_supported) return;

    if (noexec)
	return;

    if (tag == NULL && date == NULL)
    {
	buf_output0 (protocol, "Clear-sticky ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
    }
    else
    {
	buf_output0 (protocol, "Set-sticky ");
	output_dir (update_dir, repository);
	buf_output0 (protocol, "\n");
	if (tag != NULL)
	{
	    if (nonbranch)
		buf_output0 (protocol, "N");
	    else
		buf_output0 (protocol, "T");
	    buf_output0 (protocol, tag);
	}
	else
	{
	    buf_output0 (protocol, "D");
	    buf_output0 (protocol, date);
	}
	buf_output0 (protocol, "\n");
    }
    buf_send_counted (protocol);
}

struct template_proc_data
{
    char *update_dir;
    char *repository;
};

/* Here as a static until we get around to fixing Parse_Info to pass along
   a void * for it.  */
static struct template_proc_data *tpd;

static int
template_proc (repository, template)
    char *repository;
    char *template;
{
    FILE *fp;
    char buf[1024];
    size_t n;
    struct stat sb;
    struct template_proc_data *data = tpd;

    if (!supported_response ("Template"))
	/* Might want to warn the user that the rcsinfo feature won't work.  */
	return 0;
    buf_output0 (protocol, "Template ");
    output_dir (data->update_dir, data->repository);
    buf_output0 (protocol, "\n");

    fp = CVS_FOPEN (template, "rb");
    if (fp == NULL)
    {
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
	return 1;
    }
    if (fstat (fileno (fp), &sb) < 0)
    {
	error (0, errno, "cannot stat rcsinfo template file %s", template);
	return 1;
    }
    sprintf (buf, "%ld\n", (long) sb.st_size);
    buf_output0 (protocol, buf);
    while (!feof (fp))
    {
	n = fread (buf, 1, sizeof buf, fp);
	buf_output (protocol, buf, n);
	if (ferror (fp))
	{
	    error (0, errno, "cannot read rcsinfo template file %s", template);
	    (void) fclose (fp);
	    return 1;
	}
    }
    if (fclose (fp) < 0)
	error (0, errno, "cannot close rcsinfo template file %s", template);
    return 0;
}

void
server_template (update_dir, repository)
    char *update_dir;
    char *repository;
{
    struct template_proc_data data;
    data.update_dir = update_dir;
    data.repository = repository;
    tpd = &data;
    (void) Parse_Info (CVSROOTADM_RCSINFO, repository, template_proc, 1);
}

static void
serve_gzip_contents (arg)
     char *arg;
{
    int level;
    level = atoi (arg);
    if (level == 0)
	level = 6;
    file_gzip_level = level;
}

static void
serve_gzip_stream (arg)
     char *arg;
{
    int level;
    level = atoi (arg);
    if (level == 0)
	level = 6;

    /* All further communication with the client will be compressed.  */

    buf_to_net = compress_buffer_initialize (buf_to_net, 0, level,
					     buf_to_net->memory_error);
    buf_from_net = compress_buffer_initialize (buf_from_net, 1, level,
					       buf_from_net->memory_error);
}

/* Tell the client about RCS options set in CVSROOT/cvswrappers. */
static void
serve_wrapper_sendme_rcs_options (arg)
     char *arg;
{
    /* Actually, this is kind of sdrawkcab-ssa: the client wants
     * verbatim lines from a cvswrappers file, but the server has
     * already parsed the cvswrappers file into the wrap_list struct.
     * Therefore, the server loops over wrap_list, unparsing each
     * entry before sending it.
     */
    char *wrapper_line = NULL;

    wrap_setup ();

    for (wrap_unparse_rcs_options (&wrapper_line, 1);
         wrapper_line;
         wrap_unparse_rcs_options (&wrapper_line, 0))
    {
	buf_output0 (buf_to_net, "Wrapper-rcsOption ");
	buf_output0 (buf_to_net, wrapper_line);
	buf_output0 (buf_to_net, "\012");;
	free (wrapper_line);
    }

    buf_output0 (buf_to_net, "ok\012");

    /* The client is waiting for us, so we better send the data now.  */
    buf_flush (buf_to_net, 1);
}


static void
serve_ignore (arg)
    char *arg;
{
    /*
     * Just ignore this command.  This is used to support the
     * update-patches command, which is not a real command, but a signal
     * to the client that update will accept the -u argument.
     */
}

static int
expand_proc (argc, argv, where, mwhere, mfile, shorten,
	     local_specified, omodule, msg)
    int argc;
    char **argv;
    char *where;
    char *mwhere;
    char *mfile;
    int shorten;
    int local_specified;
    char *omodule;
    char *msg;
{
    int i;
    char *dir = argv[0];

    /* If mwhere has been specified, the thing we're expanding is a
       module -- just return its name so the client will ask for the
       right thing later.  If it is an alias or a real directory,
       mwhere will not be set, so send out the appropriate
       expansion. */

    if (mwhere != NULL)
    {
	buf_output0 (buf_to_net, "Module-expansion ");
	if (server_dir != NULL)
	{
	    buf_output0 (buf_to_net, server_dir);
	    buf_output0 (buf_to_net, "/");
	}
	buf_output0 (buf_to_net, mwhere);
	if (mfile != NULL)
	{
	    buf_append_char (buf_to_net, '/');
	    buf_output0 (buf_to_net, mfile);
	}
	buf_append_char (buf_to_net, '\n');
    }
    else
    {
	/* We may not need to do this anymore -- check the definition
           of aliases before removing */
	if (argc == 1)
	{
	    buf_output0 (buf_to_net, "Module-expansion ");
	    if (server_dir != NULL)
	    {
		buf_output0 (buf_to_net, server_dir);
		buf_output0 (buf_to_net, "/");
	    }
	    buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '\n');
	}
	else
	{
	    for (i = 1; i < argc; ++i)
	    {
	        buf_output0 (buf_to_net, "Module-expansion ");
		if (server_dir != NULL)
		{
		    buf_output0 (buf_to_net, server_dir);
		    buf_output0 (buf_to_net, "/");
		}
		buf_output0 (buf_to_net, dir);
		buf_append_char (buf_to_net, '/');
		buf_output0 (buf_to_net, argv[i]);
		buf_append_char (buf_to_net, '\n');
	    }
	}
    }
    return 0;
}

static void
serve_expand_modules (arg)
    char *arg;
{
    int i;
    int err;
    DBM *db;
    err = 0;

    server_expanding = 1;
    db = open_module ();
    for (i = 1; i < argument_count; i++)
	err += do_module (db, argument_vector[i],
			  CHECKOUT, "Updating", expand_proc,
			  NULL, 0, 0, 0, 0,
			  (char *) NULL);
    close_module (db);
    server_expanding = 0;
    {
	/* argument_vector[0] is a dummy argument, we don't mess with it.  */
	char **cp;
	for (cp = argument_vector + 1;
	     cp < argument_vector + argument_count;
	     ++cp)
	    free (*cp);

	argument_count = 1;
    }
    if (err)
	/* We will have printed an error message already.  */
	buf_output0 (buf_to_net, "error  \n");
    else
	buf_output0 (buf_to_net, "ok\n");

    /* The client is waiting for the module expansions, so we must
       send the output now.  */
    buf_flush (buf_to_net, 1);
}

void
server_prog (dir, name, which)
    char *dir;
    char *name;
    enum progs which;
{
    if (!supported_response ("Set-checkin-prog"))
    {
	buf_output0 (buf_to_net, "E \
warning: this client does not support -i or -u flags in the modules file.\n");
	return;
    }
    switch (which)
    {
	case PROG_CHECKIN:
	    buf_output0 (buf_to_net, "Set-checkin-prog ");
	    break;
	case PROG_UPDATE:
	    buf_output0 (buf_to_net, "Set-update-prog ");
	    break;
    }
    buf_output0 (buf_to_net, dir);
    buf_append_char (buf_to_net, '\n');
    buf_output0 (buf_to_net, name);
    buf_append_char (buf_to_net, '\n');
}

static void
serve_checkin_prog (arg)
    char *arg;
{
    FILE *f;

    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Checkin-prog disabled by configuration");
	return;
    }

    f = CVS_FOPEN (CVSADM_CIPROG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text,
		     "E cannot write to %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_CIPROG);
	pending_error = save_errno;
	return;
    }
}

static void
serve_update_prog (arg)
    char *arg;
{
    FILE *f;

    /* Before we do anything we first check if this command is not 
       disabled. */
    if (disable_x_prog)
    {
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Update-prog disabled by configuration");
	return;
    }
    
    /* Before we do anything we need to make sure we are not in readonly
       mode.  */
    if (!check_command_legal_p ("commit"))
    {
	/* I might be willing to make this a warning, except we lack the
	   machinery to do so.  */
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Flag -u in modules not allowed in readonly mode");
	return;
    }

    f = CVS_FOPEN (CVSADM_UPROG, "w+");
    if (f == NULL)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fprintf (f, "%s\n", arg) < 0)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
    if (fclose (f) == EOF)
    {
	int save_errno = errno;
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_UPROG);
	pending_error = save_errno;
	return;
    }
}

static void serve_valid_requests PROTO((char *arg));

#endif /* SERVER_SUPPORT */
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)

/*
 * Parts of this table are shared with the client code,
 * but the client doesn't need to know about the handler
 * functions.
 */

struct request requests[] =
{
#ifdef SERVER_SUPPORT
#define REQ_LINE(n, f, s) {n, f, s}
#else
#define REQ_LINE(n, f, s) {n, s}
#endif

  REQ_LINE("Root", serve_root, RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Valid-responses", serve_valid_responses,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("valid-requests", serve_valid_requests,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Repository", serve_repository, 0),
  REQ_LINE("Directory", serve_directory, RQ_ESSENTIAL),
  REQ_LINE("Max-dotdot", serve_max_dotdot, 0),
  REQ_LINE("Static-directory", serve_static_directory, 0),
  REQ_LINE("Sticky", serve_sticky, 0),
  REQ_LINE("Checkin-prog", serve_checkin_prog, 0),
  REQ_LINE("Update-prog", serve_update_prog, 0),
  REQ_LINE("Entry", serve_entry, RQ_ESSENTIAL),
  REQ_LINE("Kopt", serve_kopt, 0),
  REQ_LINE("Checkin-time", serve_checkin_time, 0),
  REQ_LINE("Modified", serve_modified, RQ_ESSENTIAL),
  REQ_LINE("Is-modified", serve_is_modified, 0),

  /* The client must send this request to interoperate with CVS 1.5
     through 1.9 servers.  The server must support it (although it can
     be and is a noop) to interoperate with CVS 1.5 to 1.9 clients.  */
  REQ_LINE("UseUnchanged", serve_enable_unchanged, RQ_ENABLEME | RQ_ROOTLESS),

  REQ_LINE("Unchanged", serve_unchanged, RQ_ESSENTIAL),
  REQ_LINE("Notify", serve_notify, 0),
  REQ_LINE("Questionable", serve_questionable, 0),
  REQ_LINE("Case", serve_case, 0),
  REQ_LINE("Argument", serve_argument, RQ_ESSENTIAL),
  REQ_LINE("Argumentx", serve_argumentx, RQ_ESSENTIAL),
  REQ_LINE("Global_option", serve_global_option, RQ_ROOTLESS),
  REQ_LINE("Gzip-stream", serve_gzip_stream, 0),
  REQ_LINE("wrapper-sendme-rcsOptions",
           serve_wrapper_sendme_rcs_options,
           0),
  REQ_LINE("Set", serve_set, RQ_ROOTLESS),
#ifdef ENCRYPTION
#  ifdef HAVE_KERBEROS
  REQ_LINE("Kerberos-encrypt", serve_kerberos_encrypt, 0),
#  endif
#  ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-encrypt", serve_gssapi_encrypt, 0),
#  endif
#endif
#ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-authenticate", serve_gssapi_authenticate, 0),
#endif
  REQ_LINE("expand-modules", serve_expand_modules, 0),
  REQ_LINE("ci", serve_ci, RQ_ESSENTIAL),
  REQ_LINE("co", serve_co, RQ_ESSENTIAL),
  REQ_LINE("update", serve_update, RQ_ESSENTIAL),
  REQ_LINE("diff", serve_diff, 0),
  REQ_LINE("log", serve_log, 0),
  REQ_LINE("rlog", serve_rlog, 0),
  REQ_LINE("add", serve_add, 0),
  REQ_LINE("remove", serve_remove, 0),
  REQ_LINE("update-patches", serve_ignore, 0),
  REQ_LINE("gzip-file-contents", serve_gzip_contents, 0),
  REQ_LINE("status", serve_status, 0),
  REQ_LINE("rdiff", serve_rdiff, 0),
  REQ_LINE("tag", serve_tag, 0),
  REQ_LINE("rtag", serve_rtag, 0),
  REQ_LINE("import", serve_import, 0),
  REQ_LINE("admin", serve_admin, 0),
  REQ_LINE("export", serve_export, 0),
  REQ_LINE("history", serve_history, 0),
  REQ_LINE("release", serve_release, 0),
  REQ_LINE("watch-on", serve_watch_on, 0),
  REQ_LINE("watch-off", serve_watch_off, 0),
  REQ_LINE("watch-add", serve_watch_add, 0),
  REQ_LINE("watch-remove", serve_watch_remove, 0),
  REQ_LINE("watchers", serve_watchers, 0),
  REQ_LINE("editors", serve_editors, 0),
  REQ_LINE("init", serve_init, RQ_ROOTLESS),
  REQ_LINE("annotate", serve_annotate, 0),
  REQ_LINE("rannotate", serve_rannotate, 0),
  REQ_LINE("noop", serve_noop, RQ_ROOTLESS),
  REQ_LINE("version", serve_version, RQ_ROOTLESS),
  REQ_LINE(NULL, NULL, 0)

#undef REQ_LINE
};

#endif /* SERVER_SUPPORT or CLIENT_SUPPORT */
#ifdef SERVER_SUPPORT

static void
serve_valid_requests (arg)
     char *arg;
{
    struct request *rq;
    if (print_pending_error ())
	return;
    buf_output0 (buf_to_net, "Valid-requests");
    for (rq = requests; rq->name != NULL; rq++)
    {
	if (rq->func != NULL)
	{
	    buf_append_char (buf_to_net, ' ');
	    buf_output0 (buf_to_net, rq->name);
	}
    }
    buf_output0 (buf_to_net, "\nok\n");

    /* The client is waiting for the list of valid requests, so we
       must send the output now.  */
    buf_flush (buf_to_net, 1);
}

#ifdef SUNOS_KLUDGE
/*
 * Delete temporary files.  SIG is the signal making this happen, or
 * 0 if not called as a result of a signal.
 */
static int command_pid_is_dead;
static void wait_sig (sig)
     int sig;
{
    int status;
    int save_errno = errno;

    pid_t r = wait (&status);
    if (r == command_pid)
	command_pid_is_dead++;
    errno = save_errno;
}
#endif /* SUNOS_KLUDGE */

void
server_cleanup (sig)
    int sig;
{
    /* Do "rm -rf" on the temp directory.  */
    static int called = 0;
    int status;
    int save_noexec;

    if (called++)
	return;

    /* already processing cleanup, do not want recursion */
#ifdef SIGABRT
    (void) SIG_deregister (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_deregister (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_deregister (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_deregister (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_deregister (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_deregister (SIGTERM, server_cleanup);
#endif

    if (buf_to_net != NULL)
    {
	/* FIXME: If this is not the final call from server, this
	   could deadlock, because the client might be blocked writing
	   to us.  This should not be a problem in practice, because
	   we do not generate much output when the client is not
	   waiting for it.  */
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);

	/* The calls to buf_shutdown are currently only meaningful
	   when we are using compression.  First we shut down
	   BUF_FROM_NET.  That will pick up the checksum generated
	   when the client shuts down its buffer.  Then, after we have
	   generated any final output, we shut down BUF_TO_NET.  */

	status = buf_shutdown (buf_from_net);
	if (status != 0)
	{
	    error (0, status, "shutting down buffer from client");
	    buf_flush (buf_to_net, 1);
	}
    }

    if (dont_delete_temp)
    {
	if (buf_to_net != NULL)
	    (void) buf_shutdown (buf_to_net);
	return;
    }

    /* What a bogus kludge.  This disgusting code makes all kinds of
       assumptions about SunOS, and is only for a bug in that system.
       So only enable it on Suns.  */
#ifdef SUNOS_KLUDGE
    if (command_pid > 0)
    {
	/* To avoid crashes on SunOS due to bugs in SunOS tmpfs
	   triggered by the use of rename() in RCS, wait for the
	   subprocess to die.  Unfortunately, this means draining output
	   while waiting for it to unblock the signal we sent it.  Yuck!  */
	int status;
	pid_t r;

	signal (SIGCHLD, wait_sig);
	if (sig)
	    /* Perhaps SIGTERM would be more correct.  But the child
	       process will delay the SIGINT delivery until its own
	       children have exited.  */
	    kill (command_pid, SIGINT);
	/* The caller may also have sent a signal to command_pid, so
	   always try waiting.  First, though, check and see if it's still
	   there....  */
    do_waitpid:
	r = waitpid (command_pid, &status, WNOHANG);
	if (r == 0)
	    ;
	else if (r == command_pid)
	    command_pid_is_dead++;
	else if (r == -1)
	    switch (errno)
	    {
		case ECHILD:
		    command_pid_is_dead++;
		    break;
		case EINTR:
		    goto do_waitpid;
	    }
	else
	    /* waitpid should always return one of the above values */
	    abort ();
	while (!command_pid_is_dead)
	{
	    struct timeval timeout;
	    struct fd_set_wrapper readfds;
	    char buf[100];
	    int i;

	    /* Use a non-zero timeout to avoid eating up CPU cycles.  */
	    timeout.tv_sec = 2;
	    timeout.tv_usec = 0;
	    readfds = command_fds_to_drain;
	    switch (select (max_command_fd + 1, &readfds.fds,
			    (fd_set *)0, (fd_set *)0,
			    &timeout))
	    {
		case -1:
		    if (errno != EINTR)
			abort ();
		case 0:
		    /* timeout */
		    break;
		case 1:
		    for (i = 0; i <= max_command_fd; i++)
		    {
			if (!FD_ISSET (i, &readfds.fds))
			    continue;
			/* this fd is non-blocking */
			while (read (i, buf, sizeof (buf)) >= 1)
			    ;
		    }
		    break;
		default:
		    abort ();
	    }
	}
    }
#endif /* SUNOS_KLUDGE */

    CVS_CHDIR (Tmpdir);
    /* Temporarily clear noexec, so that we clean up our temp directory
       regardless of it (this could more cleanly be handled by moving
       the noexec check to all the unlink_file_dir callers from
       unlink_file_dir itself).  */
    save_noexec = noexec;
    noexec = 0;
    /* FIXME?  Would be nice to not ignore errors.  But what should we do?
       We could try to do this before we shut down the network connection,
       and try to notify the client (but the client might not be waiting
       for responses).  We could try something like syslog() or our own
       log file.  */
    unlink_file_dir (orig_server_temp_dir);
    noexec = save_noexec;

    if (buf_to_net != NULL)
	(void) buf_shutdown (buf_to_net);
}

int server_active = 0;
int server_expanding = 0;

int
server (argc, argv)
     int argc;
     char **argv;
{
    if (argc == -1)
    {
	static const char *const msg[] =
	{
	    "Usage: %s %s\n",
	    "  Normally invoked by a cvs client on a remote machine.\n",
	    NULL
	};
	usage (msg);
    }
    /* Ignore argc and argv.  They might be from .cvsrc.  */

    buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0,
				       outbuf_memory_error);
    buf_from_net = stdio_buffer_initialize (stdin, 1, outbuf_memory_error);

    saved_output = buf_nonio_initialize (outbuf_memory_error);
    saved_outerr = buf_nonio_initialize (outbuf_memory_error);

    /* Since we're in the server parent process, error should use the
       protocol to report error messages.  */
    error_use_protocol = 1;

    /* OK, now figure out where we stash our temporary files.  */
    {
	char *p;

	/* The code which wants to chdir into server_temp_dir is not set
	   up to deal with it being a relative path.  So give an error
	   for that case.  */
	if (!isabsolute (Tmpdir))
	{
	    if (alloc_pending (80 + strlen (Tmpdir)))
		sprintf (pending_error_text,
			 "E Value of %s for TMPDIR is not absolute", Tmpdir);

	    /* FIXME: we would like this error to be persistent, that
	       is, not cleared by print_pending_error.  The current client
	       will exit as soon as it gets an error, but the protocol spec
	       does not require a client to do so.  */
	}
	else
	{
	    int status;
	    int i = 0;

	    server_temp_dir = malloc (strlen (Tmpdir) + 80);
	    if (server_temp_dir == NULL)
	    {
		/*
		 * Strictly speaking, we're not supposed to output anything
		 * now.  But we're about to exit(), give it a try.
		 */
		printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

		/* I'm doing this manually rather than via error_exit ()
		   because I'm not sure whether we want to call server_cleanup.
		   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
		/* Hook for OS-specific behavior, for example socket
		   subsystems on NT and OS2 or dealing with windows
		   and arguments on Mac.  */
		SYSTEM_CLEANUP ();
#endif

		exit (EXIT_FAILURE);
	    }
	    strcpy (server_temp_dir, Tmpdir);

	    /* Remove a trailing slash from TMPDIR if present.  */
	    p = server_temp_dir + strlen (server_temp_dir) - 1;
	    if (*p == '/')
		*p = '\0';

	    /*
	     * I wanted to use cvs-serv/PID, but then you have to worry about
	     * the permissions on the cvs-serv directory being right.  So
	     * use cvs-servPID.
	     */
	    strcat (server_temp_dir, "/cvs-serv");

	    p = server_temp_dir + strlen (server_temp_dir);
	    sprintf (p, "%ld", (long) getpid ());

	    orig_server_temp_dir = server_temp_dir;

	    /* Create the temporary directory, and set the mode to
               700, to discourage random people from tampering with
               it.  */
	    while ((status = mkdir_p (server_temp_dir)) == EEXIST)
	    {
	        static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";

	        if (i >= sizeof suffix - 1) break;
		if (i == 0) p = server_temp_dir + strlen (server_temp_dir);
		p[0] = suffix[i++];
		p[1] = '\0';
	    }
	    if (status != 0)
	    {
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
			    "E can't create temporary directory %s",
			    server_temp_dir);
		pending_error = status;
	    }
#ifndef CHMOD_BROKEN
	    else if (chmod (server_temp_dir, S_IRWXU) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
"E cannot change permissions on temporary directory %s",
			     server_temp_dir);
		pending_error = save_errno;
	    }
#endif
	    else if (CVS_CHDIR (server_temp_dir) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
"E cannot change to temporary directory %s",
			     server_temp_dir);
		pending_error = save_errno;
	    }
	}
    }

#ifdef SIGABRT
    (void) SIG_register (SIGABRT, server_cleanup);
#endif
#ifdef SIGHUP
    (void) SIG_register (SIGHUP, server_cleanup);
#endif
#ifdef SIGINT
    (void) SIG_register (SIGINT, server_cleanup);
#endif
#ifdef SIGQUIT
    (void) SIG_register (SIGQUIT, server_cleanup);
#endif
#ifdef SIGPIPE
    (void) SIG_register (SIGPIPE, server_cleanup);
#endif
#ifdef SIGTERM
    (void) SIG_register (SIGTERM, server_cleanup);
#endif

    /* Now initialize our argument vector (for arguments from the client).  */

    /* Small for testing.  */
    argument_vector_size = 1;
    argument_vector =
	(char **) malloc (argument_vector_size * sizeof (char *));
    if (argument_vector == NULL)
    {
	/*
	 * Strictly speaking, we're not supposed to output anything
	 * now.  But we're about to exit(), give it a try.
	 */
	printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (EXIT_FAILURE);
    }

    argument_count = 1;
    /* This gets printed if the client supports an option which the
       server doesn't, causing the server to print a usage message.
       FIXME: probably should be using program_name here.
       FIXME: just a nit, I suppose, but the usage message the server
       prints isn't literally true--it suggests "cvs server" followed
       by options which are for a particular command.  Might be nice to
       say something like "client apparently supports an option not supported
       by this server" or something like that instead of usage message.  */
    argument_vector[0] = "cvs server";

    while (1)
    {
	char *cmd, *orig_cmd;
	struct request *rq;
	int status;
	
	status = buf_read_line (buf_from_net, &cmd, (int *) NULL);
	if (status == -2)
	{
	    buf_output0 (buf_to_net, "E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");
	    break;
	}
	if (status != 0)
	    break;

	orig_cmd = cmd;
	for (rq = requests; rq->name != NULL; ++rq)
	    if (strncmp (cmd, rq->name, strlen (rq->name)) == 0)
	    {
		int len = strlen (rq->name);
		if (cmd[len] == '\0')
		    cmd += len;
		else if (cmd[len] == ' ')
		    cmd += len + 1;
		else
		    /*
		     * The first len characters match, but it's a different
		     * command.  e.g. the command is "cooperate" but we matched
		     * "co".
		     */
		    continue;

		if (!(rq->flags & RQ_ROOTLESS)
		    && current_parsed_root == NULL)
		{
		    /* For commands which change the way in which data
		       is sent and received, for example Gzip-stream,
		       this does the wrong thing.  Since the client
		       assumes that everything is being compressed,
		       unconditionally, there is no way to give this
		       error to the client without turning on
		       compression.  The obvious fix would be to make
		       Gzip-stream RQ_ROOTLESS (with the corresponding
		       change to the spec), and that might be a good
		       idea but then again I can see some settings in
		       CVSROOT about what compression level to allow.
		       I suppose a more baroque answer would be to
		       turn on compression (say, at level 1), just
		       enough to give the "Root request missing"
		       error.  For now we just lose.  */
		    if (alloc_pending (80))
			sprintf (pending_error_text,
				 "E Protocol error: Root request missing");
		}
		else
		    (*rq->func) (cmd);
		break;
	    }
	if (rq->name == NULL)
	{
	    if (!print_pending_error ())
	    {
	        buf_output0 (buf_to_net, "error  unrecognized request `");
		buf_output0 (buf_to_net, cmd);
		buf_append_char (buf_to_net, '\'');
		buf_append_char (buf_to_net, '\n');
	    }
	}
	free (orig_cmd);
    }
    server_cleanup (0);
    return 0;
}


#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
static void switch_to_user PROTO((const char *));

static void
switch_to_user (username)
    const char *username;
{
    struct passwd *pw;

    pw = getpwnam (username);
    if (pw == NULL)
    {
	/* Normally this won't be reached; check_password contains
	   a similar check.  */

	printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
    }

#if HAVE_INITGROUPS
    if (initgroups (pw->pw_name, pw->pw_gid) < 0
#  ifdef EPERM
	/* At least on the system I tried, initgroups() only works as root.
	   But we do still want to report ENOMEM and whatever other
	   errors initgroups() might dish up.  */
	&& errno != EPERM
#  endif
	)
    {
	/* This could be a warning, but I'm not sure I see the point
	   in doing that instead of an error given that it would happen
	   on every connection.  We could log it somewhere and not tell
	   the user.  But at least for now make it an error.  */
	printf ("error 0 initgroups failed: %s\n", strerror (errno));
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
    }
#endif /* HAVE_INITGROUPS */

#ifdef SETXID_SUPPORT
    /* honor the setgid bit iff set*/
    if (getgid() != getegid())
    {
	if (setgid (getegid ()) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
	}
    }
    else
#endif
    {
	if (setgid (pw->pw_gid) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
	}
    }
    
    if (setuid (pw->pw_uid) < 0)
    {
	/* Note that this means that if run as a non-root user,
	   CVSROOT/passwd must contain the user we are running as
	   (e.g. "joe:FsEfVcu:cvs" if run as "cvs" user).  This seems
	   cleaner than ignoring the error like CVS 1.10 and older but
	   it does mean that some people might need to update their
	   CVSROOT/passwd file.  */
	printf ("error 0 setuid failed: %s\n", strerror (errno));
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
    }

    /* We don't want our umask to change file modes.  The modes should
       be set by the modes used in the repository, and by the umask of
       the client.  */
    umask (0);

#ifdef AUTH_SERVER_SUPPORT
    /* Make sure our CVS_Username has been set. */
    if (CVS_Username == NULL)
	CVS_Username = xstrdup (username);
#endif
      
#if HAVE_PUTENV
    /* Set LOGNAME, USER and CVS_USER in the environment, in case they
       are already set to something else.  */
    {
	char *env;
#ifdef AUTH_SERVER_SUPPORT
	char *cvs_user;
#endif

	env = xmalloc (sizeof "LOGNAME=" + strlen (username));
	(void) sprintf (env, "LOGNAME=%s", username);
	(void) putenv (env);

	env = xmalloc (sizeof "USER=" + strlen (username));
	(void) sprintf (env, "USER=%s", username);
	(void) putenv (env);

#ifdef AUTH_SERVER_SUPPORT
        cvs_user = NULL != CVS_Username ? CVS_Username : "";
        env = xmalloc (sizeof "CVS_USER=" + strlen (cvs_user));
        (void) sprintf (env, "CVS_USER=%s", cvs_user);
        (void) putenv (env);
#endif
    }
#endif /* HAVE_PUTENV */
}
#endif

#ifdef AUTH_SERVER_SUPPORT


/* 
 * 0 means no entry found for this user.
 * 1 means entry found and password matches (or found password is empty)
 * 2 means entry found, but password does not match.
 *
 * If 1, host_user_ptr will be set to point at the system
 * username (i.e., the "real" identity, which may or may not be the
 * CVS username) of this user; caller may free this.  Global
 * CVS_Username will point at an allocated copy of cvs username (i.e.,
 * the username argument below).
 * kff todo: FIXME: last sentence is not true, it applies to caller.
 */
static int
check_repository_password (username, password, repository, host_user_ptr)
     char *username, *password, *repository, **host_user_ptr;
{
    int retval = 0;
    FILE *fp;
    char *filename;
    char *linebuf = NULL;
    size_t linebuf_len;
    int found_it = 0;
    int namelen;

    /* We don't use current_parsed_root->directory because it hasn't been set yet
     * -- our `repository' argument came from the authentication
     * protocol, not the regular CVS protocol.
     */

    filename = xmalloc (strlen (repository)
			+ 1
			+ strlen (CVSROOTADM)
			+ 1
			+ strlen (CVSROOTADM_PASSWD)
			+ 1);

    (void) sprintf (filename, "%s/%s/%s", repository,
                    CVSROOTADM, CVSROOTADM_PASSWD);

    fp = CVS_FOPEN (filename, "r");
    if (fp == NULL)
    {
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", filename);
	return 0;
    }

    /* Look for a relevant line -- one with this user's name. */
    namelen = strlen (username);
    while (get_line (&linebuf, &linebuf_len, fp) >= 0)
    {
	if ((strncmp (linebuf, username, namelen) == 0)
	    && (linebuf[namelen] == ':'))
        {
	    found_it = 1;
	    break;
        }
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", filename);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", filename);

    /* If found_it, then linebuf contains the information we need. */
    if (found_it)
    {
	char *found_password, *host_user_tmp;
        char *non_cvsuser_portion;

        /* We need to make sure lines such as 
         *
         *    "username::sysuser\n"
         *    "username:\n"
         *    "username:  \n"
         *
         * all result in a found_password of NULL, but we also need to
         * make sure that
         *
         *    "username:   :sysuser\n"
         *    "username: <whatever>:sysuser\n"
         *
         * continues to result in an impossible password.  That way,
         * an admin would be on safe ground by going in and tacking a
         * space onto the front of a password to disable the account
         * (a technique some people use to close accounts
         * temporarily).
         */

        /* Make `non_cvsuser_portion' contain everything after the CVS
           username, but null out any final newline. */
	non_cvsuser_portion = linebuf + namelen;
        strtok (non_cvsuser_portion, "\n");

        /* If there's a colon now, we just want to inch past it. */
        if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
            non_cvsuser_portion++;

        /* Okay, after this conditional chain, found_password and
           host_user_tmp will have useful values: */

        if ((non_cvsuser_portion == NULL)
            || (strlen (non_cvsuser_portion) == 0)
            || ((strspn (non_cvsuser_portion, " \t"))
                == strlen (non_cvsuser_portion)))
        {
            found_password = NULL;
            host_user_tmp = NULL;
        }
        else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
        {
            found_password = NULL;
            host_user_tmp = non_cvsuser_portion + 1;
            if (strlen (host_user_tmp) == 0)
                host_user_tmp = NULL;
        }
        else
        {
            found_password = strtok (non_cvsuser_portion, ":");
            host_user_tmp = strtok (NULL, ":");
        }

        /* Of course, maybe there was no system user portion... */
	if (host_user_tmp == NULL)
            host_user_tmp = username;

        /* Verify blank passwords directly, otherwise use crypt_checkpass(). */
        if ((found_password == NULL)
            || (crypt_checkpass (password, found_password) == 0))
        {
            /* Give host_user_ptr permanent storage. */
            *host_user_ptr = xstrdup (host_user_tmp);
	    retval = 1;
        }
	else
        {
            *host_user_ptr = NULL;
	    retval         = 2;
        }
    }
    else     /* Didn't find this user, so deny access. */
    {
	*host_user_ptr = NULL;
	retval = 0;
    }

    free (filename);
    if (linebuf)
        free (linebuf);

    return retval;
}


/* Return a hosting username if password matches, else NULL. */
static char *
check_password (username, password, repository)
    char *username, *password, *repository;
{
    int rc;
    char *host_user = NULL;

    /* First we see if this user has a password in the CVS-specific
       password file.  If so, that's enough to authenticate with.  If
       not, we'll check /etc/passwd. */

    rc = check_repository_password (username, password, repository,
				    &host_user);

    if (rc == 2)
	return NULL;

    /* else */

    if (rc == 1)
    {
        /* host_user already set by reference, so just return. */
        goto handle_return;
    }
    else if (rc == 0 && system_auth)
    {
	/* No cvs password found, so try /etc/passwd. */

	const char *found_passwd = NULL;
	struct passwd *pw;
#ifdef HAVE_GETSPNAM
	struct spwd *spw;

	spw = getspnam (username);
	if (spw != NULL)
	{
	    found_passwd = spw->sp_pwdp;
	}
#endif

	if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
	{
	    found_passwd = pw->pw_passwd;
	}
	
	if (found_passwd == NULL)
	{
	    printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
	
	if (*found_passwd)
        {
	    /* user exists and has a password */
	    host_user = ((! crypt_checkpass (password, found_passwd))
                         ? xstrdup (username) : NULL);
            goto handle_return;
        }
	else if (password && *password)
        {
	    /* user exists and has no system password, but we got
	       one as parameter */
	    host_user = xstrdup (username);
            goto handle_return;
        }
	else
        {
	    /* user exists but has no password at all */
	    host_user = NULL;
            goto handle_return;
        }
    }
    else if (rc == 0)
    {
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
    }
    else
    {
	/* Something strange happened.  We don't know what it was, but
	   we certainly won't grant authorization. */
	host_user = NULL;
        goto handle_return;
    }

handle_return:
    if (host_user)
    {
        /* Set CVS_Username here, in allocated space. 
           It might or might not be the same as host_user. */
        CVS_Username = xmalloc (strlen (username) + 1);
        strcpy (CVS_Username, username);
    }

    return host_user;
}

#endif /* AUTH_SERVER_SUPPORT */

#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)

/* Read username and password from client (i.e., stdin).
   If correct, then switch to run as that user and send an ACK to the
   client via stdout, else send NACK and die. */
void
pserver_authenticate_connection ()
{
    char *tmp = NULL;
    size_t tmp_allocated = 0;
#ifdef AUTH_SERVER_SUPPORT
    char *repository = NULL;
    size_t repository_allocated = 0;
    char *username = NULL;
    size_t username_allocated = 0;
    char *password = NULL;
    size_t password_allocated = 0;

    char *host_user;
    char *descrambled_password;
#endif /* AUTH_SERVER_SUPPORT */
    int verify_and_exit = 0;

    /* The Authentication Protocol.  Client sends:
     *
     *   BEGIN AUTH REQUEST\n
     *   <REPOSITORY>\n
     *   <USERNAME>\n
     *   <PASSWORD>\n
     *   END AUTH REQUEST\n
     *
     * Server uses above information to authenticate, then sends
     *
     *   I LOVE YOU\n
     *
     * if it grants access, else
     *
     *   I HATE YOU\n
     *
     * if it denies access (and it exits if denying).
     *
     * When the client is "cvs login", the user does not desire actual
     * repository access, but would like to confirm the password with
     * the server.  In this case, the start and stop strings are
     *
     *   BEGIN VERIFICATION REQUEST\n
     *
     *            and
     *
     *   END VERIFICATION REQUEST\n
     *
     * On a verification request, the server's responses are the same
     * (with the obvious semantics), but it exits immediately after
     * sending the response in both cases.
     *
     * Why is the repository sent?  Well, note that the actual
     * client/server protocol can't start up until authentication is
     * successful.  But in order to perform authentication, the server
     * needs to look up the password in the special CVS passwd file,
     * before trying /etc/passwd.  So the client transmits the
     * repository as part of the "authentication protocol".  The
     * repository will be redundantly retransmitted later, but that's no
     * big deal.
     */

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
    }
#endif

    /* Make sure the protocol starts off on the right foot... */
    if (getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX) < 0)
	/* FIXME: what?  We could try writing error/eof, but chances
	   are the network connection is dead bidirectionally.  log it
	   somewhere?  */
	;

    if (strcmp (tmp, "BEGIN VERIFICATION REQUEST\n") == 0)
	verify_and_exit = 1;
    else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") == 0)
	;
    else if (strcmp (tmp, "BEGIN GSSAPI REQUEST\n") == 0)
    {
#ifdef HAVE_GSSAPI
	free (tmp);
	gserver_authenticate_connection ();
	return;
#else
	error (1, 0, "GSSAPI authentication not supported by this server");
#endif
    }
    else
	error (1, 0, "bad auth protocol start: %s", tmp);

#ifndef AUTH_SERVER_SUPPORT

    error (1, 0, "Password authentication not supported by this server");

#else /* AUTH_SERVER_SUPPORT */

    /* Get the three important pieces of information in order. */
    /* See above comment about error handling.  */
    getline_safe (&repository, &repository_allocated, stdin, PATH_MAX);
    getline_safe (&username, &username_allocated, stdin, PATH_MAX);
    getline_safe (&password, &password_allocated, stdin, PATH_MAX);

    /* Make them pure. */ 
    strip_trailing_newlines (repository);
    strip_trailing_newlines (username);
    strip_trailing_newlines (password);

    /* ... and make sure the protocol ends on the right foot. */
    /* See above comment about error handling.  */
    getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX);
    if (strcmp (tmp,
		verify_and_exit ?
		"END VERIFICATION REQUEST\n" : "END AUTH REQUEST\n")
	!= 0)
    {
	error (1, 0, "bad auth protocol end: %s", tmp);
    }
    if (!root_allow_ok (repository))
    {
	printf ("error 0 %s: no such repository\n", repository);
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login refused for %s", repository);
#endif
	goto i_hate_you;
    }

    /* OK, now parse the config file, so we can use it to control how
       to check passwords.  If there was an error parsing the config
       file, parse_config already printed an error.  We keep going.
       Why?  Because if we didn't, then there would be no way to check
       in a new CVSROOT/config file to fix the broken one!  */
    parse_config (repository);

    /* We need the real cleartext before we hash it. */
    descrambled_password = descramble (password);
    host_user = check_password (username, descrambled_password, repository);
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
    if (host_user == NULL)
    {
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login failure (for %s)", repository);
#ifdef LOG_AUTHPRIV
        syslog (LOG_AUTHPRIV | LOG_NOTICE, "login failure by %s / %s (for %s)",
        	username, descrambled_password, repository);
#endif
#endif
    i_hate_you:
	printf ("I HATE YOU\n");
	fflush (stdout);

	/* Don't worry about server_cleanup, server_active isn't set
	   yet.  */
	error_exit ();
    }

    /* Don't go any farther if we're just responding to "cvs login". */
    if (verify_and_exit)
    {
	printf ("I LOVE YOU\n");
	fflush (stdout);

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (0);
    }

    /* Set Pserver_Repos so that we can check later that the same
       repository is sent in later client/server protocol. */
    Pserver_Repos = xmalloc (strlen (repository) + 1);
    strcpy (Pserver_Repos, repository);

    /* Switch to run as this user. */
    switch_to_user (host_user);
    free (host_user);
    free (tmp);
    free (repository);
    free (username);
    free (password);

    printf ("I LOVE YOU\n");
    fflush (stdout);
#endif /* AUTH_SERVER_SUPPORT */
}

#endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */


#ifdef HAVE_KERBEROS
void
kserver_authenticate_connection ()
{
    int status;
    char instance[INST_SZ];
    struct sockaddr_in peer;
    struct sockaddr_in laddr;
    int len;
    KTEXT_ST ticket;
    AUTH_DAT auth;
    char version[KRB_SENDAUTH_VLEN];
    char user[ANAME_SZ];

    strcpy (instance, "*");
    len = sizeof peer;
    if (getpeername (STDIN_FILENO, (struct sockaddr *) &peer, &len) < 0
	|| getsockname (STDIN_FILENO, (struct sockaddr *) &laddr,
			&len) < 0)
    {
	printf ("E Fatal error, aborting.\n\
error %s getpeername or getsockname failed\n", strerror (errno));
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
    }

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
    }
#endif

    status = krb_recvauth (KOPT_DO_MUTUAL, STDIN_FILENO, &ticket, "rcmd",
			   instance, &peer, &laddr, &auth, "", sched,
			   version);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: %s\n", krb_get_err_text(status));
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
    }

    memcpy (kblock, auth.session, sizeof (C_Block));

    /* Get the local name.  */
    status = krb_kntoln (&auth, user);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: can't get local name: %s\n", krb_get_err_text(status));
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
    }

    /* Switch to run as this user. */
    switch_to_user (user);
}
#endif /* HAVE_KERBEROS */

#ifdef HAVE_GSSAPI

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN (256)
#endif

/* Authenticate a GSSAPI connection.  This is called from
   pserver_authenticate_connection, and it handles success and failure
   the same way.  */

static void
gserver_authenticate_connection ()
{
    char hostname[MAXHOSTNAMELEN];
    struct hostent *hp;
    gss_buffer_desc tok_in, tok_out;
    char buf[1024];
    OM_uint32 stat_min, ret;
    gss_name_t server_name, client_name;
    gss_cred_id_t server_creds;
    int nbytes;
    gss_OID mechid;

    gethostname (hostname, sizeof hostname);
    hp = gethostbyname (hostname);
    if (hp == NULL)
	error (1, 0, "can't get canonical hostname");

    sprintf (buf, "cvs@@%s", hp->h_name);
    tok_in.value = buf;
    tok_in.length = strlen (buf);

    if (gss_import_name (&stat_min, &tok_in, GSS_C_NT_HOSTBASED_SERVICE,
			 &server_name) != GSS_S_COMPLETE)
	error (1, 0, "could not import GSSAPI service name %s", buf);

    /* Acquire the server credential to verify the client's
       authentication.  */
    if (gss_acquire_cred (&stat_min, server_name, 0, GSS_C_NULL_OID_SET,
			  GSS_C_ACCEPT, &server_creds,
			  NULL, NULL) != GSS_S_COMPLETE)
	error (1, 0, "could not acquire GSSAPI server credentials");

    gss_release_name (&stat_min, &server_name);

    /* The client will send us a two byte length followed by that many
       bytes.  */
    if (fread (buf, 1, 2, stdin) != 2)
	error (1, errno, "read of length failed");

    nbytes = ((buf[0] & 0xff) << 8) | (buf[1] & 0xff);
    assert (nbytes <= sizeof buf);

    if (fread (buf, 1, nbytes, stdin) != nbytes)
	error (1, errno, "read of data failed");

    gcontext = GSS_C_NO_CONTEXT;
    tok_in.length = nbytes;
    tok_in.value = buf;

    if (gss_accept_sec_context (&stat_min,
                                &gcontext,	/* context_handle */
                                server_creds,	/* verifier_cred_handle */
                                &tok_in,	/* input_token */
                                NULL,		/* channel bindings */
                                &client_name,	/* src_name */
                                &mechid,	/* mech_type */
                                &tok_out,	/* output_token */
                                &ret,
                                NULL,	 	/* ignore time_rec */
                                NULL)		/* ignore del_cred_handle */
	!= GSS_S_COMPLETE)
    {
	error (1, 0, "could not verify credentials");
    }

    /* FIXME: Use Kerberos v5 specific code to authenticate to a user.
       We could instead use an authentication to access mapping.  */
    {
	krb5_context kc;
	krb5_principal p;
	gss_buffer_desc desc;

	krb5_init_context (&kc);
	if (gss_display_name (&stat_min, client_name, &desc,
			      &mechid) != GSS_S_COMPLETE
	    || krb5_parse_name (kc, ((gss_buffer_t) &desc)->value, &p) != 0
	    || krb5_aname_to_localname (kc, p, sizeof buf, buf) != 0
	    || krb5_kuserok (kc, p, buf) != TRUE)
	{
	    error (1, 0, "access denied");
	}
	krb5_free_principal (kc, p);
	krb5_free_context (kc);
    }

    if (tok_out.length != 0)
    {
	char cbuf[2];

	cbuf[0] = (tok_out.length >> 8) & 0xff;
	cbuf[1] = tok_out.length & 0xff;
	if (fwrite (cbuf, 1, 2, stdout) != 2
	    || (fwrite (tok_out.value, 1, tok_out.length, stdout)
		!= tok_out.length))
	    error (1, errno, "fwrite failed");
    }

    switch_to_user (buf);

    printf ("I LOVE YOU\n");
    fflush (stdout);
}

#endif /* HAVE_GSSAPI */

#endif /* SERVER_SUPPORT */

#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)

/* This global variable is non-zero if the user requests encryption on
   the command line.  */
int cvsencrypt;

/* This global variable is non-zero if the users requests stream
   authentication on the command line.  */
int cvsauthenticate;

#ifdef HAVE_GSSAPI

/* An buffer interface using GSSAPI.  This is built on top of a
   packetizing buffer.  */

/* This structure is the closure field of the GSSAPI translation
   routines.  */

struct cvs_gssapi_wrap_data
{
    /* The GSSAPI context.  */
    gss_ctx_id_t gcontext;
};

static int cvs_gssapi_wrap_input PROTO((void *, const char *, char *, int));
static int cvs_gssapi_wrap_output PROTO((void *, const char *, char *, int,
					 int *));

/* Create a GSSAPI wrapping buffer.  We use a packetizing buffer with
   GSSAPI wrapping routines.  */

struct buffer *
cvs_gssapi_wrap_buffer_initialize (buf, input, gcontext, memory)
     struct buffer *buf;
     int input;
     gss_ctx_id_t gcontext;
     void (*memory) PROTO((struct buffer *));
{
    struct cvs_gssapi_wrap_data *gd;

    gd = (struct cvs_gssapi_wrap_data *) xmalloc (sizeof *gd);
    gd->gcontext = gcontext;

    return (packetizing_buffer_initialize
	    (buf,
	     input ? cvs_gssapi_wrap_input : NULL,
	     input ? NULL : cvs_gssapi_wrap_output,
	     gd,
	     memory));
}

/* Unwrap data using GSSAPI.  */

static int
cvs_gssapi_wrap_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
{
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf;

    inbuf.value = (void *) input;
    inbuf.length = size;

    if (gss_unwrap (&stat_min, gd->gcontext, &inbuf, &outbuf, &conf, NULL)
	!= GSS_S_COMPLETE)
    {
	error (1, 0, "gss_unwrap failed");
    }

    if (outbuf.length > size)
	abort ();

    memcpy (output, outbuf.value, outbuf.length);

    /* The real packet size is stored in the data, so we don't need to
       remember outbuf.length.  */

    gss_release_buffer (&stat_min, &outbuf);

    return 0;
}

/* Wrap data using GSSAPI.  */

static int
cvs_gssapi_wrap_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
{
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf_req, conf;

    inbuf.value = (void *) input;
    inbuf.length = size;

#ifdef ENCRYPTION
    conf_req = cvs_gssapi_encrypt;
#else
    conf_req = 0;
#endif

    if (gss_wrap (&stat_min, gd->gcontext, conf_req, GSS_C_QOP_DEFAULT,
		  &inbuf, &conf, &outbuf) != GSS_S_COMPLETE)
	error (1, 0, "gss_wrap failed");

    /* The packetizing buffer only permits us to add 100 bytes.
       FIXME: I don't know what, if anything, is guaranteed by GSSAPI.
       This may need to be increased for a different GSSAPI
       implementation, or we may need a different algorithm.  */
    if (outbuf.length > size + 100)
	abort ();

    memcpy (output, outbuf.value, outbuf.length);

    *translated = outbuf.length;

    gss_release_buffer (&stat_min, &outbuf);

    return 0;
}

#endif /* HAVE_GSSAPI */

#ifdef ENCRYPTION

#ifdef HAVE_KERBEROS

/* An encryption interface using Kerberos.  This is built on top of a
   packetizing buffer.  */

/* This structure is the closure field of the Kerberos translation
   routines.  */

struct krb_encrypt_data
{
    /* The Kerberos key schedule.  */
    Key_schedule sched;
    /* The Kerberos DES block.  */
    C_Block block;
};

static int krb_encrypt_input PROTO((void *, const char *, char *, int));
static int krb_encrypt_output PROTO((void *, const char *, char *, int,
				     int *));

/* Create a Kerberos encryption buffer.  We use a packetizing buffer
   with Kerberos encryption translation routines.  */

struct buffer *
krb_encrypt_buffer_initialize (buf, input, sched, block, memory)
     struct buffer *buf;
     int input;
     Key_schedule sched;
     C_Block block;
     void (*memory) PROTO((struct buffer *));
{
    struct krb_encrypt_data *kd;

    kd = (struct krb_encrypt_data *) xmalloc (sizeof *kd);
    memcpy (kd->sched, sched, sizeof (Key_schedule));
    memcpy (kd->block, block, sizeof (C_Block));

    return packetizing_buffer_initialize (buf,
					  input ? krb_encrypt_input : NULL,
					  input ? NULL : krb_encrypt_output,
					  kd,
					  memory);
}

/* Decrypt Kerberos data.  */

static int
krb_encrypt_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
{
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
    int tcount;

    DES_cbc_encrypt ((C_Block *) input, (C_Block *) output,
		     size, &kd->sched, &kd->block, 0);

    /* SIZE is the size of the buffer, which is set by the encryption
       routine.  The packetizing buffer will arrange for the first two
       bytes in the decrypted buffer to be the real (unaligned)
       length.  As a safety check, make sure that the length in the
       buffer corresponds to SIZE.  Note that the length in the buffer
       is just the length of the data.  We must add 2 to account for
       the buffer count itself.  */
    tcount = ((output[0] & 0xff) << 8) + (output[1] & 0xff);
    if (((tcount + 2 + 7) & ~7) != size)
      error (1, 0, "Decryption failure");

    return 0;
}

/* Encrypt Kerberos data.  */

static int
krb_encrypt_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
{
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
    int aligned;

    /* For security against a known plaintext attack, we should
       initialize any padding bytes to random values.  Instead, we
       just pick up whatever is on the stack, which is at least better
       than using zero.  */

    /* Align SIZE to an 8 byte boundary.  Note that SIZE includes the
       two byte buffer count at the start of INPUT which was added by
       the packetizing buffer.  */
    aligned = (size + 7) & ~7;

    /* We use DES_cbc_encrypt rather than krb_mk_priv because the
       latter sticks a timestamp in the block, and krb_rd_priv expects
       that timestamp to be within five minutes of the current time.
       Given the way the CVS server buffers up data, that can easily
       fail over a long network connection.  We trust krb_recvauth to
       guard against a replay attack.  */

    DES_cbc_encrypt ((C_Block *) input, (C_Block *) output, aligned,
		     &kd->sched, &kd->block, 1);

    *translated = aligned;

    return 0;
}

#endif /* HAVE_KERBEROS */
#endif /* ENCRYPTION */
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)
   the first '\0' byte.  */

void
cvs_output (str, len)
    const char *str;
    size_t len;
{
    if (len == 0)
	len = strlen (str);
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	buf_output (saved_output, str, len);
	buf_copy_lines (buf_to_net, saved_output, 'M');
    }
    else if (server_active)
    {
	buf_output (saved_output, str, len);
	buf_copy_lines (protocol, saved_output, 'M');
	buf_send_counted (protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}

/* Output LEN bytes at STR in binary mode.  If LEN is zero, then
   output zero bytes.  */

void
cvs_output_binary (str, len)
    char *str;
    size_t len;
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol || server_active)
    {
	struct buffer *buf;
	char size_text[40];

	if (error_use_protocol)
	    buf = buf_to_net;
	else
	    buf = protocol;

	if (!supported_response ("Mbinary"))
	{
	    error (0, 0, "\
this client does not support writing binary files to stdout");
	    return;
	}

	buf_output0 (buf, "Mbinary\012");
	sprintf (size_text, "%lu\012", (unsigned long) len);
	buf_output0 (buf, size_text);

	/* Not sure what would be involved in using buf_append_data here
	   without stepping on the toes of our caller (which is responsible
	   for the memory allocation of STR).  */
	buf_output (buf, str, len);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */
#ifdef USE_SETMODE_STDOUT
	int oldmode;

	/* It is possible that this should be the same ifdef as
	   USE_SETMODE_BINARY but at least for the moment we keep them
	   separate.  Mostly this is just laziness and/or a question
	   of what has been tested where.  Also there might be an
	   issue of setmode vs. _setmode.  */
	/* The Windows doc says to call setmode only right after startup.
	   I assume that what they are talking about can also be helped
	   by flushing the stream before changing the mode.  */
	fflush (stdout);
	oldmode = _setmode (_fileno (stdout), OPEN_BINARY);
	if (oldmode < 0)
	    error (0, errno, "failed to setmode on stdout");
#endif

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
#ifdef USE_SETMODE_STDOUT
	fflush (stdout);
	if (_setmode (_fileno (stdout), oldmode) != OPEN_BINARY)
	    error (0, errno, "failed to setmode on stdout");
#endif
    }
}

/* Like CVS_OUTPUT but output is for stderr not stdout.  */

void
cvs_outerr (str, len)
    const char *str;
    size_t len;
{
    if (len == 0)
	len = strlen (str);
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	buf_output (saved_outerr, str, len);
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
    }
    else if (server_active)
    {
	buf_output (saved_outerr, str, len);
	buf_copy_lines (protocol, saved_outerr, 'E');
	buf_send_counted (protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* Make sure that output appears in order if stdout and stderr
	   point to the same place.  For the server case this is taken
	   care of by the fact that saved_outerr always holds less
	   than a line.  */
	fflush (stdout);

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stderr);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}

/* Flush stderr.  stderr is normally flushed automatically, of course,
   but this function is used to flush information from the server back
   to the client.  */

void
cvs_flusherr ()
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* skip the actual stderr flush in this case since the parent process
	 * on the server should only be writing to stdout anyhow
	 */
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* make sure stderr is flushed before we send the flush count on the
	 * protocol pipe
	 */ 
	fflush (stderr);
	/* Send a special count to tell the parent to flush.  */
	buf_send_special_count (protocol, -2);
    }
    else
#endif
	fflush (stderr);
}

/* Make it possible for the user to see what has been written to
   stdout (it is up to the implementation to decide exactly how far it
   should go to ensure this).  */

void
cvs_flushout ()
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* Just do nothing.  This is because the code which
	   cvs_flushout replaces, setting stdout to line buffering in
	   main.c, didn't get called in the server child process.  But
	   in the future it is quite plausible that we'll want to make
	   this case work analogously to cvs_flusherr.
	 
	   FIXME - DRP - I tried to implement this and triggered the following
	   error: "Protocol error: uncounted data discarded".  I don't need
	   this feature right now, so I'm not going to bother with it yet.
	 */
	buf_send_special_count (protocol, -1);
    }
    else
#endif
	fflush (stdout);
}

/* Output TEXT, tagging it according to TAG.  There are lots more
   details about what TAG means in cvsclient.texi but for the simple
   case (e.g. non-client/server), TAG is just "newline" to output a
   newline (in which case TEXT must be NULL), and any other tag to
   output normal text.

   Note that there is no way to output either \0 or \n as part of TEXT.  */

void
cvs_output_tagged (tag, text)
    char *tag;
    char *text;
{
    if (text != NULL && strchr (text, '\n') != NULL)
	/* Uh oh.  The protocol has no way to cope with this.  For now
	   we dump core, although that really isn't such a nice
	   response given that this probably can be caused by newlines
	   in filenames and other causes other than bugs in CVS.  Note
	   that we don't want to turn this into "MT newline" because
	   this case is a newline within a tagged item, not a newline
	   as extraneous sugar for the user.  */
	assert (0);

    /* Start and end tags don't take any text, per cvsclient.texi.  */
    if (tag[0] == '+' || tag[0] == '-')
	assert (text == NULL);

#ifdef SERVER_SUPPORT
    if (server_active && supported_response ("MT"))
    {
	struct buffer *buf;

	if (error_use_protocol)
	    buf = buf_to_net;
	else
	    buf = protocol;

	buf_output0 (buf, "MT ");
	buf_output0 (buf, tag);
	if (text != NULL)
	{
	    buf_output (buf, " ", 1);
	    buf_output0 (buf, text);
	}
	buf_output (buf, "\n", 1);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif
    {
	if (strcmp (tag, "newline") == 0)
	    cvs_output ("\n", 1);
	else if (text != NULL)
	    cvs_output (text, 0);
    }
}
@


1.36
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@a5532 2
extern char *crypt PROTO((const char *, const char *));

d5659 1
a5659 1
        /* Verify blank passwords directly, otherwise use crypt(). */
d5661 1
a5661 2
            || ((strcmp (found_password, crypt (password, found_password))
                 == 0)))
d5754 1
a5754 2
	    host_user = ((! strcmp (found_passwd,
                                    crypt (password, found_passwd)))
@


1.35
log
@Move the declaration of `disable_x_prog' outside of a #ifdef AUTH_SERVER_SUPPORT
block where it had been mistakenly put in the first place (in r1.28).
@
text
@d1922 1
a1922 1
    checkin_time = get_date (arg, NULL);
@


1.34
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@d118 2
a122 2

# endif /* AUTH_SERVER_SUPPORT */
@


1.33
log
@Switch the remaining users of libdes in src to libcrypto,
telnet portion partially from the latest heimdal.

ok mikeb@@
@
text
@d2608 1
a2608 1
             while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
d2669 1
a2669 1
         while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
d5585 1
a5585 1
    while (getline (&linebuf, &linebuf_len, fp) >= 0)
@


1.32
log
@fix leaks found by parfait.
ok deraadt
@
text
@d6419 2
a6420 2
    des_cbc_encrypt ((C_Block *) input, (C_Block *) output,
		     size, kd->sched, &kd->block, 0);
d6459 1
a6459 1
    /* We use des_cbc_encrypt rather than krb_mk_priv because the
d6466 2
a6467 2
    des_cbc_encrypt ((C_Block *) input, (C_Block *) output, aligned,
		     kd->sched, &kd->block, 1);
@


1.31
log
@Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.

ok millert@@
@
text
@d358 2
a359 1
    if (dir_where_cvsadm_lives == NULL)
d361 1
d366 3
a368 1
    if (tmp == NULL)
d370 1
d1405 2
@


1.30
log
@Fix buffer overflow find by Stefan Esser, patch by Derek Robert Price.
@
text
@d933 1
a933 1
    if (lim < 0)
d1638 1
a1638 2
    if (error_pending ())
	return;
d1652 10
a1661 1
	    timefield = strchr (cp + 1, '/') + 1;
d1708 1
a1708 2
    if (error_pending ())
	return;
d1723 10
a1732 1
	    timefield = strchr (cp + 1, '/') + 1;
d1817 1
d1819 21
a1839 1
    p = (struct an_entry *) malloc (sizeof (struct an_entry));
d2071 3
d2205 9
d2244 9
d2610 1
a2610 1
                 if (linebuf[num_red - 1] == '\n')
d2665 1
a2665 1
             if (linebuf[num_red - 1] == '\n')
@


1.29
log
@re-entrancy hack that is currently needed for cvs to work correctly.
well, almost.  someone should track that down please.
@
text
@d1654 9
a1662 1
	    if (*timefield != '=')
d1664 2
a1672 1
		*timefield = '=';
d1674 10
d1717 9
a1725 1
	    if (!(timefield[0] == 'M' && timefield[1] == '/'))
d1727 2
a1735 1
		*timefield = 'M';
d1737 10
@


1.29.2.1
log
@MFC:
Fix by millert@@

Fix buffer overflow find by Stefan Esser, patch by Derek Robert Price.
@
text
@d1654 1
a1654 9
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1655 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1663 1
a1664 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = '=';
d1698 1
a1698 9
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1699 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1707 1
a1708 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = 'M';
@


1.29.2.2
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@d933 1
a933 1
    if (lim < 0 || lim > 10000)
d1638 2
a1639 1
    if (error_pending ()) return;
d1653 1
a1653 10
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
d1700 2
a1701 1
    if (error_pending ()) return;
d1716 1
a1716 10
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
a1800 1
    int i = 0;
d1802 1
a1802 21

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
      if (!cp || *cp != '/')
      {
          if (alloc_pending (80))
              sprintf (pending_error_text,
                       "E protocol error: Malformed Entry");
           return;
      }
    cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
a2033 3
	if (!data[0])
	    goto error;

a2164 9

    if (argument_count >= 10000)
    {
       if (alloc_pending (80))
           sprintf (pending_error_text,
                    "E Protocol error: too many arguments");
       return;
    }

a2194 9

    if (argument_count <= 1)
    {
        if (alloc_pending (80))
            sprintf (pending_error_text,
                     "E Protocol error: called argumentx without prior call to argument");
        return;
    }

d2552 1
a2552 1
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
d2607 1
a2607 1
             if (num_red > 0 && linebuf[num_red - 1] == '\n')
@


1.28
log
@Add a "DisableXProg" option to CVSROOT/config that can be used to
disable support for Update-prog and Checkin-prog.  This is a good
idea for anonymouse cvs servers or anyone who doesn't need this
feature.  From Stefan Esser.
@
text
@d4881 1
d4884 23
@


1.28.4.1
log
@MFC:
Fix by millert@@

Fix buffer overflow find by Stefan Esser, patch by Derek Robert Price.
@
text
@d1654 1
a1654 9
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1655 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1663 1
a1664 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = '=';
d1698 1
a1698 9
	    /* If the time field is not currently empty, then one of
	     * serve_modified, serve_is_modified, & serve_unchanged were
	     * already called for this file.  We would like to ignore the
	     * reinvocation silently or, better yet, exit with an error
	     * message, but we just avoid the copy-forward and overwrite the
	     * value from the last invocation instead.  See the comment below
	     * for more.
	     */
	    if (*timefield == '/')
a1699 2
		/* Copy forward one character.  Space was allocated for this
		 * already in serve_entry().  */
d1707 1
a1708 10
	    /* If *TIMEFIELD wasn't "/", we assume that it was because of
	     * multiple calls to Is-Modified & Unchanged by the client and
	     * just overwrite the value from the last call.  Technically, we
	     * should probably either ignore calls after the first or send the
	     * client an error, since the client/server protocol specification
	     * specifies that only one call to either Is-Modified or Unchanged
	     * is allowed, but broken versions of WinCVS & TortoiseCVS rely on
	     * this behavior.
	     */
	    *timefield = 'M';
@


1.28.4.2
log
@MFC:
Fix by otto@@

Several potential security problems found and fixed by Stefan Esser &
Sebastian Krahmer.
@
text
@d933 1
a933 1
    if (lim < 0 || lim > 10000)
d1638 2
a1639 1
    if (error_pending ()) return;
d1653 1
a1653 10
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
d1700 2
a1701 1
    if (error_pending ()) return;
d1716 1
a1716 10
	    if (!(timefield = strchr (cp + 1, '/')) || *++timefield == '\0')
	    {
		/* We didn't find the record separator or it is followed by
		 * the end of the string, so just exit.
		 */
		if (alloc_pending (80))
		    sprintf (pending_error_text,
		             "E Malformed Entry encountered.");
		return;
	    }
a1800 1
    int i = 0;
d1802 1
a1802 21

    /* Verify that the entry is well-formed.  This can avoid problems later.
     * At the moment we only check that the Entry contains five slashes in
     * approximately the correct locations since some of the code makes
     * assumptions about this.
     */
    cp = arg;
    if (*cp == 'D') cp++;
    while (i++ < 5)
    {
      if (!cp || *cp != '/')
      {
          if (alloc_pending (80))
              sprintf (pending_error_text,
                       "E protocol error: Malformed Entry");
           return;
      }
    cp = strchr (cp + 1, '/');
    }

    p = xmalloc (sizeof (struct an_entry));
a2033 3
	if (!data[0])
	    goto error;

a2164 9

    if (argument_count >= 10000)
    {
       if (alloc_pending (80))
           sprintf (pending_error_text,
                    "E Protocol error: too many arguments");
       return;
    }

a2194 9

    if (argument_count <= 1)
    {
        if (alloc_pending (80))
            sprintf (pending_error_text,
                     "E Protocol error: called argumentx without prior call to argument");
        return;
    }

d2552 1
a2552 1
                 if (num_red > 0 && linebuf[num_red - 1] == '\n')
d2607 1
a2607 1
             if (num_red > 0 && linebuf[num_red - 1] == '\n')
@


1.27
log
@In dirswitch(), don't free dir_name until right before allocating
it again.  This removes a potential double-free problem, whereby
this function could free dir_name and then immediately return due
to invalid directory syntax (without ever reassigning dir_name),
then re-enter and free dir_name again.  Fix from Stefan Esser.
@
text
@d118 4
d4636 11
d4681 10
@


1.26
log
@Merge remaining local changes, correct build issues
@
text
@a979 3
    if (dir_name != NULL)
	free (dir_name);

d994 3
@


1.26.4.1
log
@Pull in patch from current:
Fix (millert):
In dirswitch(), don't free dir_name until right before allocating
it again.  This removes a potential double-free problem, whereby
this function could free dir_name and then immediately return due
to invalid directory syntax (without ever reassigning dir_name),
then re-enter and free dir_name again.  Fix from Stefan Esser.
@
text
@d980 3
a996 3

    if (dir_name != NULL)
	free (dir_name);
@


1.26.6.1
log
@Pull in patch from current:
Fix (millert):
In dirswitch(), don't free dir_name until right before allocating
it again.  This removes a potential double-free problem, whereby
this function could free dir_name and then immediately return due
to invalid directory syntax (without ever reassigning dir_name),
then re-enter and free dir_name again.  Fix from Stefan Esser.
@
text
@d980 3
a996 3

    if (dir_name != NULL)
	free (dir_name);
@


1.25
log
@Merge local changes; work in progress
@
text
@d5355 4
a5358 1
	char *env, *cvs_user;
d5368 1
d5373 1
@


1.24
log
@Integrate local changes
@
text
@d19 10
a28 41
#ifdef SERVER_SUPPORT

#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#endif

#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#include <sys/socket.h>
#endif

#ifdef HAVE_KERBEROS
#  include <netinet/in.h>
#  include <krb.h>
#  ifndef HAVE_KRB_GET_ERR_TEXT
#    define krb_get_err_text(status) krb_err_txt[status]
#  endif

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

#endif

#ifdef HAVE_GSSAPI

#include <netdb.h>

#ifdef HAVE_GSSAPI_H
#include <gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_H
#include <gssapi/gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
#include <gssapi/gssapi_generic.h>
#endif

#ifndef HAVE_GSS_C_NT_HOSTBASED_SERVICE
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#endif

d31 1
a31 1
#include <krb5.h>
d41 1
a41 1
#  ifdef ENCRYPTION
d47 9
a55 1
#  endif
d57 2
d61 2
a62 4
/* for select */
#include <sys/types.h>
#ifdef HAVE_SYS_BSDTYPES_H
#include <sys/bsdtypes.h>
d65 5
a69 8
#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
d71 5
d78 2
a79 3
#if HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif
a92 6
#ifdef AUTH_SERVER_SUPPORT
#ifdef HAVE_GETSPNAM
#include <shadow.h>
#endif
#endif /* AUTH_SERVER_SUPPORT */

d97 6
a102 2

#ifdef AUTH_SERVER_SUPPORT
d118 1
a118 1
#endif /* AUTH_SERVER_SUPPORT */
d399 1
a399 1
	    empty = malloc (strlen (CVSroot_directory)
d402 1
a402 1
			    + 10);
d410 1
a410 1
	    (void) sprintf (empty, "%s/%s/%s", CVSroot_directory,
d576 2
d580 6
a585 2
    if (msg)
	buf_output0 (buf_to_net, msg);
d752 1
a752 1
    if (CVSroot_directory != NULL)
d775 4
a778 1
    set_local_cvsroot (arg);
d782 1
a782 1
    parse_config (CVSroot_directory);
d784 1
a784 1
    path = malloc (strlen (CVSroot_directory)
d786 1
a786 1
		   + 10);
d792 1
a792 1
    (void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
d803 1
a803 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (CVSroot_directory) + 1 + 1);
d809 1
a809 1
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot_directory);
d852 1
a852 1
   CVSroot_directory?  If yes, return 0.  If no, set pending_error
d859 1
a859 1
    size_t root_len = strlen (CVSroot_directory);
d874 1
a874 1
	|| strncmp (CVSroot_directory, repos, root_len) != 0)
d877 1
a877 1
	if (alloc_pending (strlen (CVSroot_directory)
d882 1
a882 1
		     repos, CVSroot_directory);
d1085 3
a1087 2
	&& CVSroot_directory != NULL
	&& strcmp (CVSroot_directory, repos) == 0)
d2417 3
d2477 1
a2477 1
         flen = strlen (CVSroot_directory)
d2483 1
a2483 1
         (void) sprintf (fname, "%s/%s/%s", CVSroot_directory,
d2529 1
a2529 1
         flen = strlen (CVSroot_directory)
d2535 1
a2535 1
         (void) sprintf (fname, "%s/%s/%s", CVSroot_directory,
d2777 1
d2779 1
d2796 3
a2798 3
	   "MT", we just throw out the partial line, like old versions
	   of CVS did, since the protocol can't support this.  */
	if (supported_response ("MT") && ! buf_empty_p (saved_output))
d2800 1
a2800 1
	    buf_output0 (protocol, "MT text ");
d2823 1
a2823 1
	int count_needed = 0;
d2911 2
a2912 1
	       || protocol_pipe[0] >= 0)
d2919 2
d2941 16
d2958 1
a2958 1
	        FD_SET (STDOUT_FILENO, &writefds);
d2974 7
a2980 7
	       we might not get output in the same order in which it
	       was written, thus producing the well-known
	       "out-of-order" bug.  If the child process uses
	       cvs_output and cvs_outerr, it will send everything on
	       the protocol_pipe and avoid this problem, so the
	       solution is to use cvs_output and cvs_outerr in the
	       child process.  */
d2986 1
a2986 1
				 (fd_set *)0, (struct timeval *)NULL);
d2988 1
a2988 1
		    && errno != EINTR)
d2995 7
a3001 1
	    
a3012 1
		int special;
d3035 12
a3046 3
		while (count_needed <= 0)
		{
		    count_needed = buf_copy_counted (buf_to_net,
d3050 2
a3051 2
		    /* What should we do with errors?  syslog() them?  */
		    buf_send_output (buf_to_net);
d3053 19
a3071 5
		    /* If SPECIAL got set to -1, it means that the child
		       wants us to flush the pipe.  We don't want to block
		       on the network, but we flush what we can.  If the
		       client supports the 'F' command, we send it.  */
		    if (special == -1)
d3073 2
a3074 7
			if (supported_response ("F"))
			{
			    buf_append_char (buf_to_net, 'F');
			    buf_append_char (buf_to_net, '\n');
			}

			cvs_flusherr ();
d3076 2
d3464 5
d3628 9
d3675 3
a3677 1
    do_cvs_command ("rtag", rtag);
d3801 4
a3804 1
    set_local_cvsroot (arg);
d3817 11
d4225 17
d4575 1
a4575 1
			  NULL, 0, 0, 0,
d4776 1
d4798 1
d4832 1
a4832 1
#ifdef sun
d4849 1
a4849 1
#endif
d4893 1
a4893 1
#ifdef sun
d4966 1
a4966 1
#endif
d5104 1
a5104 1
	    else
d5106 3
a5108 5
		if (chmod (server_temp_dir, S_IRWXU) < 0)
		{
		    int save_errno = errno;
		    if (alloc_pending (80 + strlen (server_temp_dir)))
			sprintf (pending_error_text,
d5110 2
a5111 3
				server_temp_dir);
		    pending_error = save_errno;
		}
d5114 9
d5218 1
a5218 1
		    && CVSroot_directory == NULL)
d5352 2
a5353 2
    /* Set LOGNAME and USER in the environment, in case they are
       already set to something else.  */
d5355 1
a5355 1
	char *env;
d5364 5
d5403 1
a5403 1
    /* We don't use CVSroot_directory because it hasn't been set yet
d5733 7
a5739 2
	(void) setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on);
d5795 5
a5799 6
	/* Just give a generic I HATE YOU.  This is because CVS 1.9.10
	   and older clients do not support "error".  Once more recent
	   clients are more widespread, probably want to fix this (it is
	   a real pain to track down why it isn't letting you in if it
	   won't say why, and I am not convinced that the potential
	   information disclosure to an attacker outweighs this).  */
d5801 1
d5817 7
d5905 7
a5911 2
	(void) setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on);
d6507 3
d6515 4
d6520 1
a6520 1
	buf_send_special_count (protocol, -1);
d6546 7
a6552 1
	   this case work analogously to cvs_flusherr.  */
@


1.23
log
@Integrate local changes
@
text
@d186 1
d208 1
a208 1
			   (int (*) PROTO((void *))) NULL,
d345 10
a751 2
    int save_errno;
    char *arg_dup;
d793 1
a793 8
    arg_dup = malloc (strlen (arg) + 1);
    if (arg_dup == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (arg_dup, arg);
    set_local_cvsroot (arg_dup);
a800 1
		   + sizeof (CVSROOTADM_HISTORY)
d808 1
a808 1
    if (!isaccessible (path, R_OK | X_OK))
d810 2
a811 3
	save_errno = errno;
	pending_error_text = malloc (80 + strlen (path));
	if (pending_error_text != NULL)
a814 11
    (void) strcat (path, "/");
    (void) strcat (path, CVSROOTADM_HISTORY);
    if (readonlyfs == 0 && isfile (path) && !isaccessible (path, R_OK | W_OK))
    {
	save_errno = errno;
	pending_error_text = malloc (80 + strlen (path));
	if (pending_error_text != NULL)
	    sprintf (pending_error_text, "E \
Sorry, you don't have read/write access to the history file %s", path);
	pending_error = save_errno;
    }
a1027 1
	pending_error = status;
d1030 1
a1042 1
	pending_error = status;
d1045 1
d1051 1
a1051 1
	pending_error = errno;
d1054 1
d1063 5
a1067 1
	pending_error = errno;
d1070 1
a1070 1
    
d1079 5
a1083 1
	pending_error = errno;
d1088 5
a1092 1
	pending_error = errno;
d1105 5
a1109 1
	    pending_error = errno;
d1116 5
a1120 1
	pending_error = errno;
d1126 5
a1130 1
	pending_error = errno;
d1138 1
a1138 1
	pending_error = errno;
d1141 1
d1146 1
a1146 1
	pending_error = errno;
d1149 1
d1158 1
a1158 4
    pending_error_text = malloc (80);
    if (pending_error_text == NULL)
	pending_error = ENOMEM;
    else
d1174 2
a1175 3
	if (outside_root (repos))
	    return;
	dirswitch (arg, repos);
d1214 1
a1214 1
	pending_error = errno;
d1217 1
d1222 1
a1222 1
	pending_error = errno;
d1225 1
d1241 1
a1241 1
	pending_error = errno;
d1244 1
d1249 1
a1249 1
	pending_error = errno;
d1252 1
d1257 1
a1257 1
	pending_error = errno;
d1260 1
d1319 4
a1322 4
		pending_error_text = malloc (40);
		if (pending_error_text != NULL)
		    sprintf (pending_error_text, "E unable to write");
		pending_error = errno;
d1358 2
a1359 2
	pending_error_text = malloc (40 + strlen (arg));
	if (pending_error_text)
d1361 1
a1361 1
	pending_error = errno;
d1427 1
a1427 1
	if (gunzip_and_write (fd, file, filebuf, size))
d1453 2
a1454 2
	pending_error_text = malloc (40 + strlen (arg));
	if (pending_error_text)
d1456 1
a1456 1
	pending_error = errno;
d1535 1
a1535 1
		    pending_error = errno;
d1539 1
d1564 1
d1569 2
d1572 1
d1577 5
a1581 1
	if (error_pending ()) return;
d1592 1
a1592 1
	    pending_error = errno;
d1595 2
d1607 1
a1607 2
	    pending_error_text = malloc (40 + strlen (arg));
	    if (pending_error_text)
d1882 1
a1882 1
	    pending_error = errno;
d1885 1
d1894 1
a1894 1
		pending_error = errno;
d1898 1
d1909 1
a1909 1
	pending_error = errno;
d1912 1
d1944 2
a1945 2
    struct notify_note *new;
    char *data;
d1953 3
a1961 2
    if (dir_name == NULL)
	goto error;
d1963 2
a1964 1
    if (new->dir == NULL)
d1967 3
a1972 6
    new->filename = malloc (strlen (arg) + 1);
    if (new->filename == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
d1998 3
d2048 2
a2049 2
    pending_error_text = malloc (80);
    if (pending_error_text)
d2052 8
a2059 1
    pending_error = 0;
d2102 1
d2690 1
d2696 1
d2702 1
d2709 1
d2720 1
d2748 1
d2782 1
d2784 1
d2786 1
d2821 1
d2878 1
d2886 1
d2894 1
d2903 1
d2912 1
d2980 1
a2991 42
	    if (stdout_pipe[0] >= 0
		&& (FD_ISSET (stdout_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stdoutbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stdoutbuf, 'M');

		if (status == -1)
		    stdout_pipe[0] = -1;
		else if (status > 0)
		{
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (stderr_pipe[0] >= 0
		&& (FD_ISSET (stderr_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stderrbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stderrbuf, 'E');

		if (status == -1)
		    stderr_pipe[0] = -1;
		else if (status > 0)
		{
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

d3002 2
d3005 1
d3008 1
d3045 50
d3116 5
d3175 6
d3211 4
d3270 1
d3711 1
a3711 1
static int noop PROTO ((int, char **));
d3713 3
a3715 4
static int
noop (argc, argv)
    int argc;
    char **argv;
d3717 8
a3724 1
    return 0;
d3727 1
a3727 1
static void serve_noop PROTO ((char *));
d3730 1
a3730 1
serve_noop (arg)
d3733 1
a3733 1
    do_cvs_command ("noop", noop);
d4110 1
a4110 1
	    buf_output (protocol, file, file_used);
d4407 1
a4407 1
expand_proc (pargc, argv, where, mwhere, mfile, shorten,
d4409 1
a4409 1
    int *pargc;
d4448 1
a4448 1
	if (*pargc == 1)
d4461 1
a4461 1
	    for (i = 1; i < *pargc; ++i)
d4553 1
a4553 1
	pending_error = errno;
d4556 1
d4561 1
a4561 1
	pending_error = errno;
d4565 1
d4570 1
a4570 1
	pending_error = errno;
d4573 1
d4599 1
a4599 1
	pending_error = errno;
d4602 1
d4607 1
a4607 1
	pending_error = errno;
d4610 1
d4615 1
a4615 1
	pending_error = errno;
d4618 1
d4671 1
a4671 1
  REQ_LINE("Global_option", serve_global_option, 0),
d4715 2
a4716 1
  REQ_LINE("noop", serve_noop, 0),
d4943 1
a4943 7
	    pending_error_text = malloc (80 + strlen (Tmpdir));
	    if (pending_error_text == NULL)
	    {
		pending_error = ENOMEM;
	    }
	    else
	    {
d4946 1
a4946 1
	    }
d4955 1
d5002 1
a5002 2
	    status = mkdir_p (server_temp_dir);
	    if (status != 0 && status != EEXIST)
d5004 13
a5016 3
		if (alloc_pending (80))
		    strcpy (pending_error_text,
			    "E can't create temporary directory");
d5025 4
a5028 3
		    if (alloc_pending (80))
			strcpy (pending_error_text, "\
E cannot change permissions on temporary directory");
d5036 3
d5218 1
a5218 1
	    printf ("error 0 setuid failed: %s\n", strerror (errno));
d5230 1
a5230 1
	    printf ("error 0 setuid failed: %s\n", strerror (errno));
d5255 6
d5286 1
a5286 1
 * 1 means entry found and password matches.
d5289 1
a5289 1
 * If success, host_user_ptr will be set to point at the system
d5294 1
d5347 1
a5347 1
    /* If found_it != 0, then linebuf contains the information we need. */
d5351 1
d5353 53
a5405 3
	strtok (linebuf, ":");
	found_password = strtok (NULL, ": \n");
	host_user_tmp = strtok (NULL, ": \n");
d5409 4
a5412 1
	if (strcmp (found_password, crypt (password, found_password)) == 0)
d5424 1
a5424 1
    else
d5507 1
a5507 1
                         ? username : NULL);
d5514 1
a5514 1
	    host_user = username;
d5644 1
a5644 1
    if (getline (&tmp, &tmp_allocated, stdin) < 0)
d5675 3
a5677 3
    getline (&repository, &repository_allocated, stdin);
    getline (&username, &username_allocated, stdin);
    getline (&password, &password_allocated, stdin);
d5686 1
a5686 1
    getline (&tmp, &tmp_allocated, stdin);
d5748 1
@


1.22
log
@Integrate local changes
@
text
@d754 1
a754 3
    /* Sending "Root" twice is illegal.  It would also be nice to
       check for the other case, in which there is no Root request
       prior to a request which requires one.
d875 67
d987 19
d1161 1
a1161 15
	/* I think isabsolute (repos) should always be true, and that
	   any RELATIVE_REPOS stuff should only be in CVS/Repository
	   files, not the protocol (for compatibility), but I'm putting
	   in the in isabsolute check just in case.  */
	if (isabsolute (repos)
	    && strncmp (CVSroot_directory,
			repos,
			strlen (CVSroot_directory)) != 0)
	{
	    if (alloc_pending (strlen (CVSroot_directory)
			       + strlen (repos)
			       + 80))
		sprintf (pending_error_text, "\
E protocol error: directory '%s' not within root '%s'",
			 repos, CVSroot_directory);
a1162 2
	}

d1549 3
d1624 3
d1667 3
d1920 3
d1974 3
d2016 1
a2016 1
    pending_error_text = malloc (40);
d2077 2
d2324 3
d5025 15
d5077 3
d5082 2
a5083 11
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (EXIT_FAILURE);
a5085 9
    /* FIXME?  We don't check for errors from initgroups, setuid, &c.
       I think this mainly would come up if someone is trying to run
       the server as a non-root user.  I think we should be checking for
       errors and aborting (as with the error above from getpwnam) if
       there is an error (presumably EPERM).  That means that pserver
       should continue to work right if all of the "system usernames"
       in CVSROOT/passwd match the user which the server is being run
       as (in inetd.conf), but fail otherwise.  */

d5087 17
a5103 1
    initgroups (pw->pw_name, pw->pw_gid);
d5110 8
a5117 1
	setgid (getegid ());
d5120 1
a5120 1
#else
d5122 8
a5129 1
	setgid (pw->pw_gid);
a5130 1
#endif
d5132 13
a5144 1
    setuid (pw->pw_uid);
d5549 1
a5549 6
    if (host_user)
    {
	printf ("I LOVE YOU\n");
	fflush (stdout);
    }
    else
a5553 3
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */
d5555 3
a5557 7
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

	exit (EXIT_FAILURE);
d5563 3
d5587 2
@


1.21
log
@Integrate local changes
@
text
@d136 1
a136 1
char *Pserver_Repos = NULL;
d344 176
d742 1
d771 23
a793 1
    set_local_cvsroot (arg);
d799 9
a807 4
    path = xmalloc (strlen (CVSroot_directory)
		    + sizeof (CVSROOTADM)
		    + sizeof (CVSROOTADM_HISTORY)
		    + 10);
a915 1
    char *b;
d951 1
a951 1
    status = mkdir_p (dir_name);	
d961 14
a974 10
    /* Note that this call to Subdir_Register will be a noop if the parent
       directory does not yet exist (for example, if the client sends
       "Directory foo" followed by "Directory .", then the subdirectory does
       not get registered, but if the client sends "Directory ." followed
       by "Directory foo", then the subdirectory does get registered.
       This seems pretty fishy, but maybe it is the way it needs to work.  */
    b = strrchr (dir_name, '/');
    *b = '\0';
    Subdir_Register ((List *) NULL, dir_name, b + 1);
    *b = '/';
d987 1
a987 1
    if (CVS_MKDIR (CVSADM, 0777) < 0)
a988 3
	if (errno == EEXIST)
	    /* Don't create the files again.  */
	    return;
d992 6
a1267 2
    pid_t gzip_pid = 0;
    int gzip_status;
a1279 5
    /*
     * FIXME: This doesn't do anything reasonable with gunzip's stderr, which
     * means that if gunzip writes to stderr, it will cause all manner of
     * protocol violations.
     */
d1281 48
a1328 1
	fd = filter_through_gunzip (fd, 0, &gzip_pid);
d1330 22
a1351 1
    receive_partial_file (size, fd);
d1365 1
a1371 2
	if (gzip_pid)
	    waitpid (gzip_pid, (int *) 0, 0);
a1373 9

    if (gzip_pid)
    {
	if (waitpid (gzip_pid, &gzip_status, 0) != gzip_pid)
	    error (1, errno, "waiting for gunzip process %ld",
		   (long) gzip_pid);
	else if (gzip_status != 0)
	    error (1, 0, "gunzip exited %d", gzip_status);
    }
d1379 5
d1487 16
d1728 28
d3192 2
a3193 2
			"%c-> server_register(%s, %s, %s, %s, %s, %s, %s)\n",
			(server_active) ? 'S' : ' ', /* silly */
d3659 6
d3683 1
a3683 6
    int year, month, day, hour, minute, second;
    /* Note that these strings are specified in RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
a3689 3
    /* The only hard part about this routine is converting the date
       formats.  In terms of functionality it all boils down to the
       call to RCS_getrevtime.  */
d3695 1
a3695 5

    sscanf (date, SDATEFORM, &year, &month, &day, &hour, &minute, &second);
    sprintf (date, "%d %s %d %d:%d:%d -0000", day,
	     month < 1 || month > 12 ? "???" : month_names[month - 1],
	     year, hour, minute, second);
d3697 1
a3697 1
    buf_output0 (protocol, date);
d3745 6
d3859 5
d3879 8
a3886 2
		int status, fd, gzip_status;
		pid_t gzip_pid;
d3899 6
a3904 10
		fd = filter_through_gzip (fd, 1, file_gzip_level, &gzip_pid);
		f = fdopen (fd, "rb");
		status = buf_read_file_to_eof (f, &list, &last);
		size = buf_chain_length (list);
		if (status == -2)
		    (*protocol->memory_error) (protocol);
		else if (status != 0)
		    error (1, ferror (f) ? errno : 0, "reading %s",
			   finfo->fullname);
		if (fclose (f) == EOF)
a3905 5
		if (waitpid (gzip_pid, &gzip_status, 0) == -1)
		    error (1, errno, "waiting for gzip process %ld",
			   (long) gzip_pid);
		else if (gzip_status != 0)
		    error (1, 0, "gzip exited %d", gzip_status);
d3930 7
a3936 1
	if (filebuf == NULL)
d3959 5
a3963 1
	    CVS_UNLINK (finfo->file);
d4458 17
a4474 14
  REQ_LINE("Root", serve_root, rq_essential),
  REQ_LINE("Valid-responses", serve_valid_responses, rq_essential),
  REQ_LINE("valid-requests", serve_valid_requests, rq_essential),
  REQ_LINE("Repository", serve_repository, rq_optional),
  REQ_LINE("Directory", serve_directory, rq_essential),
  REQ_LINE("Max-dotdot", serve_max_dotdot, rq_optional),
  REQ_LINE("Static-directory", serve_static_directory, rq_optional),
  REQ_LINE("Sticky", serve_sticky, rq_optional),
  REQ_LINE("Checkin-prog", serve_checkin_prog, rq_optional),
  REQ_LINE("Update-prog", serve_update_prog, rq_optional),
  REQ_LINE("Entry", serve_entry, rq_essential),
  REQ_LINE("Kopt", serve_kopt, rq_optional),
  REQ_LINE("Modified", serve_modified, rq_essential),
  REQ_LINE("Is-modified", serve_is_modified, rq_optional),
d4479 1
a4479 1
  REQ_LINE("UseUnchanged", serve_enable_unchanged, rq_enableme),
d4481 8
a4488 8
  REQ_LINE("Unchanged", serve_unchanged, rq_essential),
  REQ_LINE("Notify", serve_notify, rq_optional),
  REQ_LINE("Questionable", serve_questionable, rq_optional),
  REQ_LINE("Case", serve_case, rq_optional),
  REQ_LINE("Argument", serve_argument, rq_essential),
  REQ_LINE("Argumentx", serve_argumentx, rq_essential),
  REQ_LINE("Global_option", serve_global_option, rq_optional),
  REQ_LINE("Gzip-stream", serve_gzip_stream, rq_optional),
d4491 2
a4492 2
           rq_optional),
  REQ_LINE("Set", serve_set, rq_optional),
d4495 1
a4495 1
  REQ_LINE("Kerberos-encrypt", serve_kerberos_encrypt, rq_optional),
d4498 1
a4498 1
  REQ_LINE("Gssapi-encrypt", serve_gssapi_encrypt, rq_optional),
d4502 1
a4502 1
  REQ_LINE("Gssapi-authenticate", serve_gssapi_authenticate, rq_optional),
d4504 29
a4532 29
  REQ_LINE("expand-modules", serve_expand_modules, rq_optional),
  REQ_LINE("ci", serve_ci, rq_essential),
  REQ_LINE("co", serve_co, rq_essential),
  REQ_LINE("update", serve_update, rq_essential),
  REQ_LINE("diff", serve_diff, rq_optional),
  REQ_LINE("log", serve_log, rq_optional),
  REQ_LINE("add", serve_add, rq_optional),
  REQ_LINE("remove", serve_remove, rq_optional),
  REQ_LINE("update-patches", serve_ignore, rq_optional),
  REQ_LINE("gzip-file-contents", serve_gzip_contents, rq_optional),
  REQ_LINE("status", serve_status, rq_optional),
  REQ_LINE("rdiff", serve_rdiff, rq_optional),
  REQ_LINE("tag", serve_tag, rq_optional),
  REQ_LINE("rtag", serve_rtag, rq_optional),
  REQ_LINE("import", serve_import, rq_optional),
  REQ_LINE("admin", serve_admin, rq_optional),
  REQ_LINE("export", serve_export, rq_optional),
  REQ_LINE("history", serve_history, rq_optional),
  REQ_LINE("release", serve_release, rq_optional),
  REQ_LINE("watch-on", serve_watch_on, rq_optional),
  REQ_LINE("watch-off", serve_watch_off, rq_optional),
  REQ_LINE("watch-add", serve_watch_add, rq_optional),
  REQ_LINE("watch-remove", serve_watch_remove, rq_optional),
  REQ_LINE("watchers", serve_watchers, rq_optional),
  REQ_LINE("editors", serve_editors, rq_optional),
  REQ_LINE("init", serve_init, rq_optional),
  REQ_LINE("annotate", serve_annotate, rq_optional),
  REQ_LINE("noop", serve_noop, rq_optional),
  REQ_LINE(NULL, NULL, rq_optional)
d4933 10
a4942 1
		(*rq->func) (cmd);
@


1.20
log
@Integrate local changes
@
text
@d45 5
d51 2
d54 5
d3116 1
a3116 1
    do_cvs_command ("cvsremove", cvsremove);
d3130 1
a3130 1
    do_cvs_command ("patch", patch);
d3399 11
d3418 1
d5248 1
a5248 1
    if (gss_import_name (&stat_min, &tok_in, gss_nt_service_name,
@


1.19
log
@Integrate local changes
@
text
@d369 2
a370 1
		    && (saved_errno != EACCES || !isdir (q)))
d639 12
d2272 3
d2345 13
d2872 3
a2874 2
			name, version, timestamp, options, tag ? tag : "",
			date ? date : "", conflict ? conflict : "");
d3111 1
a3111 1
    do_cvs_command ("status", status);
d3613 1
a3613 1
	    && filebuf != NULL
d4815 1
d4817 1
a4817 1
	struct spwd *pw;
d4819 2
a4820 2
	pw = getspnam (username);
	if (pw != NULL)
d4822 1
a4822 1
	    found_passwd = pw->sp_pwdp;
d4824 1
a4824 2
#else
	struct passwd *pw;
d4826 1
a4826 2
	pw = getpwnam (username);
	if (pw != NULL)
a4829 1
#endif
d4831 1
a4831 1
	if (pw == NULL)
d4849 1
a4849 1
	if (found_passwd && *found_passwd)
d4851 1
d4859 2
d4866 1
d5625 1
a5625 1
	else if (server_active)
@


1.18
log
@Merge local changes to support a configuration file with Cyclic's scheme
@
text
@d1197 1
a1197 1
	int status = change_mode (arg, mode_text);
d3358 1
a3358 1
server_updated (finfo, vers, updated, file_info, checksum)
d3362 1
a3362 1
    struct stat *file_info;
d3364 1
a3382 1
	struct stat sb;
d3387 8
a3394 1
	if ( CVS_STAT (finfo->file, &sb) < 0)
d3396 18
a3413 1
	    if (existence_error (errno))
d3415 4
a3418 8
		/*
		 * If we have a sticky tag for a branch on which the
		 * file is dead, and cvs update the directory, it gets
		 * a T_CHECKOUT but no file.  So in this case just
		 * forget the whole thing.  */
		free (entries_line);
		entries_line = NULL;
		goto done;
a3419 1
	    error (1, errno, "reading %s", finfo->fullname);
d3488 1
a3488 7
	    /* FIXME: When we check out files the umask of the server
	       (set in .bashrc if rsh is in use) affects what mode we
	       send, and it shouldn't.  */
	    if (file_info != NULL)
	        mode_string = mode_to_string (file_info->st_mode);
	    else
	        mode_string = mode_to_string (sb.st_mode);
d3495 1
a3495 2
	size = 0;
	if (sb.st_size > 0)
d3508 1
a3508 1
		&& sb.st_size > 100)
d3513 8
d3543 1
a3543 1
	    else
a3546 1
		size = sb.st_size;
d3550 1
a3550 1
		status = buf_read_file (f, sb.st_size, &list, &last);
d3564 7
a3570 1
	buf_append_data (protocol, list, last);
d3583 1
d5640 1
a5640 1
	oldmode = _setmode (_fileno (stdout), _O_BINARY);
d5655 1
a5655 1
	if (_setmode (_fileno (stdout), oldmode) != _O_BINARY)
@


1.17
log
@Integrate local changes
@
text
@a623 1
    parseopts(CVSroot_directory);
@


1.16
log
@save errno in sigchld handlers
@
text
@d25 1
a25 1
#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS)
d30 5
a34 5
#include <netinet/in.h>
#include <krb.h>
#ifndef HAVE_KRB_GET_ERR_TEXT
#define krb_get_err_text(status) krb_err_txt[status]
#endif
d42 28
d107 2
a112 2
#endif /* AUTH_SERVER_SUPPORT */

d126 4
d364 1
a364 1
	    if (CVS_MKDIR (q, 0777) < 0)
d472 2
d563 18
d583 4
d689 1
d698 2
d704 2
a705 2
    if (strlen (dir) > 0
	&& dir[strlen (dir) - 1] == '/')
d707 1
a707 1
	if (alloc_pending (80 + strlen (dir)))
d709 1
a709 1
		     "E protocol error: illegal directory syntax in %s", dir);
d713 1
a713 1
    dir_name = malloc (strlen (server_temp_dir) + strlen (dir) + 40);
d734 6
d843 18
d1091 5
d1210 7
a1272 2
static void serve_is_modified PROTO ((char *));

d1309 10
a1326 1
	struct an_entry *p;
d1333 7
a1339 1
	p->entry = xmalloc (strlen (arg) + 80);
d1342 8
a1349 1
	strcat (p->entry, "//D//");
d1355 2
d1383 39
d1769 1
d1787 35
d1823 26
a2035 1
         free (fname);
d2038 10
a2047 1
             goto do_writers;
d2065 2
d2071 2
a2072 2
             fclose (fp);
             goto do_writers;
d2074 3
a2077 2
    do_writers:
         
a2087 1
         free (fname);
a2090 2
             /* writers file does not exist, so everyone is a writer,
                by default */
d2093 15
a2107 1
             return 1;
a2109 2
         /* else */

d2123 2
d2128 2
a2129 1
             fclose (fp);
d2132 1
d2138 2
a2139 1
             fclose (fp);
d2142 1
d3061 1
a3061 1
    do_cvs_command ("cvslog", cvslog);
d3333 2
d3367 10
d3378 1
d3784 32
d3852 5
d3872 5
d3885 5
d4068 1
d4085 3
d4090 1
a4090 1
#ifdef HAVE_KERBEROS
d4092 4
d4097 2
a4344 44
    /*
     * Put Rcsbin at the start of PATH, so that rcs programs can find
     * themselves.
     */
#ifdef HAVE_PUTENV
    if (Rcsbin != NULL && *Rcsbin)
    {
        char *p;
	char *env;

	p = getenv ("PATH");
	if (p != NULL)
	{
	    env = malloc (strlen (Rcsbin) + strlen (p) + sizeof "PATH=:");
	    if (env != NULL)
	        sprintf (env, "PATH=%s:%s", Rcsbin, p);
	}
	else
	{
	    env = malloc (strlen (Rcsbin) + sizeof "PATH=");
	    if (env != NULL)
	        sprintf (env, "PATH=%s", Rcsbin);
	}
	if (env == NULL)
	{
	    printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

	    exit (EXIT_FAILURE);
	}
	putenv (env);
    }
#endif

a4496 2
    server_active = 1;

d4549 1
a4549 1
#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT)
d4576 9
d4755 1
a4755 1
    else if (rc == 0)
d4814 21
d4855 4
d4867 1
d4877 1
d4942 13
a4954 1
    else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") != 0)
d4957 6
d4985 6
a4990 6
	/* At least for the moment I'm going to do the paranoid
	   security thing and not tell them how it failed.  I'm not
	   sure that is a good idea; it is a real pain when one needs
	   to track down what is going on for legitimate reasons.
	   The other issue is that the protocol doesn't really have
	   a good way for anything other than I HATE YOU.  */
d4993 7
d5051 2
d5055 1
a5055 1
#endif /* AUTH_SERVER_SUPPORT */
d5135 116
d5259 3
a5261 1
#ifdef ENCRYPTION
d5263 1
a5263 1
#ifdef HAVE_KERBEROS
d5265 2
a5266 3
/* An encryption interface using Kerberos.  This is built on top of
   the buffer structure.  We encrypt using a big endian two byte count
   field followed by a block of encrypted data.  */
d5268 2
a5269 2
/* This structure is the closure field of a Kerberos encryption
   buffer.  */
d5271 1
a5271 1
struct krb_encrypt_buffer
d5273 2
a5274 21
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The Kerberos key schedule.  */
    Key_schedule sched;
    /* The Kerberos DES block.  */
    C_Block block;
    /* For an input buffer, we may have to buffer up data here.  */
    /* This is non-zero if the buffered data is decrypted.  Otherwise,
       the buffered data is encrypted, and starts with the two byte
       count.  */
    int clear;
    /* The amount of buffered data.  */
    int holdsize;
    /* The buffer allocated to hold the data.  */
    char *holdbuf;
    /* The size of holdbuf.  */
    int holdbufsize;
    /* If clear is set, we need another data pointer to track where we
       are in holdbuf.  If clear is zero, then this pointer is not
       used.  */
    char *holddata;
d5277 3
a5279 5
static int krb_encrypt_buffer_input PROTO((void *, char *, int, int, int *));
static int krb_encrypt_buffer_output PROTO((void *, const char *, int, int *));
static int krb_encrypt_buffer_flush PROTO((void *));
static int krb_encrypt_buffer_block PROTO((void *, int));
static int krb_encrypt_buffer_shutdown PROTO((void *));
d5281 2
a5282 1
/* Create an encryption buffer.  */
d5285 1
a5285 1
krb_encrypt_buffer_initialize (buf, input, sched, block, memory)
d5288 1
a5288 2
     Key_schedule sched;
     C_Block block;
d5291 1
a5291 1
    struct krb_encrypt_buffer *kb;
d5293 2
a5294 2
    kb = (struct krb_encrypt_buffer *) xmalloc (sizeof *kb);
    memset (kb, 0, sizeof *kb);
d5296 6
a5301 17
    kb->buf = buf;
    memcpy (kb->sched, sched, sizeof (Key_schedule));
    memcpy (kb->block, block, sizeof (C_Block));
    if (input)
    {
	/* We add some space to the buffer to hold the length.  */
	kb->holdbufsize = BUFFER_DATA_SIZE + 16;
	kb->holdbuf = xmalloc (kb->holdbufsize);
    }

    return buf_initialize (input ? krb_encrypt_buffer_input : NULL,
			   input ? NULL : krb_encrypt_buffer_output,
			   input ? NULL : krb_encrypt_buffer_flush,
			   krb_encrypt_buffer_block,
			   krb_encrypt_buffer_shutdown,
			   memory,
			   kb);
d5304 1
a5304 1
/* Input data from a Kerberos encryption buffer.  */
d5307 4
a5310 4
krb_encrypt_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
a5311 1
     int *got;
d5313 5
a5317 1
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;
d5319 2
a5320 1
    *got = 0;
d5322 2
a5323 1
    if (kb->holdsize > 0 && kb->clear)
d5325 2
a5326 1
	int copy;
d5328 2
a5329 1
	copy = kb->holdsize;
d5331 1
a5331 8
	if (copy > size)
	{
	    memcpy (data, kb->holddata, size);
	    kb->holdsize -= size;
	    kb->holddata += size;
	    *got = size;
	    return 0;
	}
d5333 2
a5334 3
	memcpy (data, kb->holddata, copy);
	kb->holdsize = 0;
	kb->clear = 0;
d5336 1
a5336 5
	data += copy;
	need -= copy;
	size -= copy;
	*got = copy;
    }
d5338 2
a5339 6
    while (need > 0 || *got == 0)
    {
	int get, status, nread, count, dcount;
	char *bytes;
	char stackoutbuf[BUFFER_DATA_SIZE + 16];
	char *outbuf;
d5341 1
a5341 14
	/* If we don't already have the two byte count, get it.  */
	if (kb->holdsize < 2)
	{
	    get = 2 - kb->holdsize;
	    status = buf_read_data (kb->buf, get, &bytes, &nread);
	    if (status != 0)
	    {
		/* buf_read_data can return -2, but a buffer input
                   function is only supposed to return -1, 0, or an
                   error code.  */
		if (status == -2)
		    status = ENOMEM;
		return status;
	    }
d5343 13
a5355 6
	    if (nread == 0)
	    {
		/* The buffer is in nonblocking mode, and we didn't
                   manage to read anything.  */
		return 0;
	    }
d5357 2
a5358 16
	    if (get == 1)
		kb->holdbuf[1] = bytes[0];
	    else
	    {
		kb->holdbuf[0] = bytes[0];
		if (nread < 2)
		{
		    /* We only got one byte, but we needed two.  Stash
                       the byte we got, and try again.  */
		    kb->holdsize = 1;
		    continue;
		}
		kb->holdbuf[1] = bytes[1];
	    }
	    kb->holdsize = 2;
	}
d5360 5
a5364 1
	/* Read the encrypted block of data.  */
d5366 10
a5375 2
	count = (((kb->holdbuf[0] & 0xff) << 8)
		 + (kb->holdbuf[1] & 0xff));
d5377 1
a5377 3
	if (count + 2 > kb->holdbufsize)
	{
	    char *n;
d5379 1
a5379 5
	    /* This should be impossible, since we should have
	       allocated space for the largest possible block in the
	       initialize function.  However, we handle it just in
	       case something changes in the future, so that a current
	       server can handle a later client.  */
d5381 1
a5381 9
	    n = realloc (kb->holdbuf, count + 2);
	    if (n == NULL)
	    {
		(*kb->buf->memory_error) (kb->buf);
		return ENOMEM;
	    }
	    kb->holdbuf = n;
	    kb->holdbufsize = count + 2;
	}
d5383 2
a5384 1
	get = count - (kb->holdsize - 2);
d5386 1
a5386 10
	status = buf_read_data (kb->buf, get, &bytes, &nread);
	if (status != 0)
	{
	    /* buf_read_data can return -2, but a buffer input
               function is only supposed to return -1, 0, or an error
               code.  */
	    if (status == -2)
		status = ENOMEM;
	    return status;
	}
d5388 1
a5388 6
	if (nread == 0)
	{
	    /* We did not get any data.  Presumably the buffer is in
               nonblocking mode.  */
	    return 0;
	}
d5390 1
a5390 5
	/* FIXME: We could complicate the code here to avoid this
           memcpy in the common case of kb->holdsize == 2 && nread ==
           get.  */
	memcpy (kb->holdbuf + kb->holdsize, bytes, nread);
	kb->holdsize += nread;
d5392 2
a5393 7
	if (nread < get)
	{
	    /* We did not get all the data we need.  buf_read_data
               does not promise to return all the bytes requested, so
               we must try again.  */
	    continue;
	}
d5395 2
a5396 2
	/* We have a complete encrypted block of COUNT bytes at
           KB->HOLDBUF + 2.  Decrypt it.  */
d5398 7
a5404 13
	if (count <= sizeof stackoutbuf)
	    outbuf = stackoutbuf;
	else
	{
	    /* I believe this is currently impossible, but we handle
               it for the benefit of future client changes.  */
	    outbuf = malloc (count);
	    if (outbuf == NULL)
	    {
		(*kb->buf->memory_error) (kb->buf);
		return ENOMEM;
	    }
	}
d5406 3
a5408 2
	des_cbc_encrypt ((C_Block *) (kb->holdbuf + 2), (C_Block *) outbuf,
			 count, kb->sched, &kb->block, 0);
d5410 2
a5411 3
	/* The first two bytes in the decrypted buffer are the real
           (unaligned) length.  */
	dcount = ((outbuf[0] & 0xff) << 8) + (outbuf[1] & 0xff);
d5413 9
a5421 2
	if (((dcount + 2 + 7) & ~7) != count)
	    error (1, 0, "Decryption failure");
d5423 3
a5425 4
	if (dcount > size)
	{
	    /* We have too much data for the buffer.  We need to save
               some of it for the next call.  */
d5427 6
a5432 2
	    memcpy (data, outbuf + 2, size);
	    *got += size;
d5434 1
a5434 4
	    kb->holdsize = dcount - size;
	    memcpy (kb->holdbuf, outbuf + 2 + size, dcount - size);
	    kb->holddata = kb->holdbuf;
	    kb->clear = 1;
d5436 9
a5444 7
	    if (outbuf != stackoutbuf)
		free (outbuf);

	    return 0;
	}

	memcpy (data, outbuf + 2, dcount);
d5446 2
a5447 2
	if (outbuf != stackoutbuf)
	    free (outbuf);
d5449 10
a5458 7
	kb->holdsize = 0;

	data += dcount;
	need -= dcount;
	size -= dcount;
	*got += dcount;
    }
d5463 1
a5463 1
/* Output data to a Kerberos encryption buffer.  */
d5466 6
a5471 5
krb_encrypt_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
d5473 1
a5473 3
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;
    char inbuf[BUFFER_DATA_SIZE + 16];
    char outbuf[BUFFER_DATA_SIZE + 16];
a5475 11
    if (have > BUFFER_DATA_SIZE)
    {
	/* It would be easy to malloc a buffer, but I don't think this
           case can ever arise.  */
	abort ();
    }

    inbuf[0] = (have >> 8) & 0xff;
    inbuf[1] = have & 0xff;
    memcpy (inbuf + 2, data, have);

d5481 4
a5484 2
    /* Align (have + 2) (plus 2 for the count) to an 8 byte boundary.  */
    aligned = (have + 2 + 7) & ~7;
d5493 2
a5494 2
    des_cbc_encrypt ((C_Block *) inbuf, (C_Block *) (outbuf + 2), aligned,
		     kb->sched, &kb->block, 1);
d5496 1
a5496 2
    outbuf[0] = (aligned >> 8) & 0xff;
    outbuf[1] = aligned & 0xff;
d5498 1
a5498 53
    /* FIXME: It would be more efficient to get des_cbc_encrypt to put
       its output directly into a buffer_data structure, which we
       could then append to kb->buf.  That would save a memcpy.  */

    buf_output (kb->buf, outbuf, aligned + 2);

    *wrote = have;

    /* We will only be here because buf_send_output was called on the
       encryption buffer.  That means that we should now call
       buf_send_output on the underlying buffer.  */
    return buf_send_output (kb->buf);
}

/* Flush data to a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_flush (closure)
     void *closure;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    /* Flush the underlying buffer.  Note that if the original call to
       buf_flush passed 1 for the BLOCK argument, then the buffer will
       already have been set into blocking mode, so we should always
       pass 0 here.  */
    return buf_flush (kb->buf, 0);
}

/* The block routine for a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    if (block)
	return set_block (kb->buf);
    else
	return set_nonblock (kb->buf);
}

/* Shut down a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_shutdown (closure)
     void *closure;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    return buf_shutdown (kb->buf);
d5534 7
d5552 84
d5728 59
@


1.15
log
@Integrate local changes
@
text
@d3855 2
d3860 1
@


1.14
log
@Integrate local changes
@
text
@d92 1
a92 1
static char *CVS_Username = NULL;
d570 22
d620 1
d641 13
a1836 4
                 {
                     free (linebuf);
                     linebuf = NULL;
                     linebuf_len = 0;
a1837 5
                 }
                 /* else */
                 free (linebuf);
                 linebuf = NULL;
                 linebuf_len = 0;
d1865 2
a1880 3
                 free (linebuf);
                 linebuf = NULL;
                 linebuf_len = 0;
a1883 4
             /* else */
             free (linebuf);
             linebuf = NULL;
             linebuf_len = 0;
d1889 2
d1897 2
a2480 1
    int n;
d3077 36
d3200 2
d3299 3
a3301 1
	if ((updated == SERVER_UPDATED || updated == SERVER_PATCHED)
d3339 8
d3697 13
a4406 2
        free (linebuf);
        linebuf = NULL;
d4427 1
a4427 3
            *host_user_ptr = xmalloc (strlen (host_user_tmp) + 1);
            strcpy (*host_user_ptr, host_user_tmp);

d4443 2
d4659 8
d4680 1
@


1.13
log
@Integrate local changes
@
text
@d1102 2
d1142 62
d3310 1
a3310 1
server_set_sticky (update_dir, repository, tag, date)
d3315 1
d3341 4
a3344 1
	    buf_output0 (protocol, "T");
d3670 1
a3670 1
  REQ_LINE("Repository", serve_repository, rq_essential),
d3679 1
@


1.12
log
@Integrate local changes
@
text
@a62 4
#if HAVE_FCNTL_H
#include <fcntl.h>
#endif

d317 2
d334 4
a337 2
		if (errno != EEXIST
		    && (errno != EACCES || !isdir(q)))
d339 1
a339 1
		    retval = errno;
a348 2
	    else
		retval = 0;
d417 22
d517 1
a517 1
    char path[PATH_MAX];
d522 7
d530 5
a534 1
    
d555 1
d634 2
a635 2
	pending_error_text = malloc (80 + strlen(dir_name));
	sprintf(pending_error_text, "E cannot mkdir %s", dir_name);
d647 2
a648 2
	pending_error_text = malloc (80 + strlen(dir_name));
	sprintf(pending_error_text, "E cannot change to %s", dir_name);
d706 2
a707 2
	pending_error_text = malloc (80 + strlen(CVSADM_ENT));
	sprintf(pending_error_text, "E cannot open %s", CVSADM_ENT);
d713 2
a714 2
	pending_error_text = malloc (80 + strlen(CVSADM_ENT));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_ENT);
d782 2
a783 2
	pending_error_text = malloc (80 + strlen(CVSADM_ENTSTAT));
	sprintf(pending_error_text, "E cannot open %s", CVSADM_ENTSTAT);
d789 2
a790 2
	pending_error_text = malloc (80 + strlen(CVSADM_ENTSTAT));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_ENTSTAT);
d807 2
a808 2
	pending_error_text = malloc (80 + strlen(CVSADM_TAG));
	sprintf(pending_error_text, "E cannot open %s", CVSADM_TAG);
d814 2
a815 2
	pending_error_text = malloc (80 + strlen(CVSADM_TAG));
	sprintf(pending_error_text, "E cannot write to %s", CVSADM_TAG);
d821 2
a822 2
	pending_error_text = malloc (80 + strlen(CVSADM_TAG));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_TAG);
d1189 2
a1190 2
	    pending_error_text = malloc (80 + strlen(CVSADM_ENT));
	    sprintf(pending_error_text, "E cannot open %s", CVSADM_ENT);
d1200 3
a1202 2
		pending_error_text = malloc (80 + strlen(CVSADM_ENT));
		sprintf(pending_error_text, "E cannot write to %s", CVSADM_ENT);
d1214 2
a1215 2
	pending_error_text = malloc (80 + strlen(CVSADM_ENT));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_ENT);
d1472 4
a1475 3
	pending_error_text = malloc (strlen (arg) + 80);
	sprintf (pending_error_text, "E Protocol error: bad global option %s",
		 arg);
d1668 2
a1669 1
check_command_legal_p (char *cmd_name)
d2880 8
d3048 3
d3062 8
d3530 2
a3531 2
	pending_error_text = malloc (80 + strlen(CVSADM_CIPROG));
	sprintf(pending_error_text, "E cannot open %s", CVSADM_CIPROG);
d3537 3
a3539 2
	pending_error_text = malloc (80 + strlen(CVSADM_CIPROG));
	sprintf(pending_error_text, "E cannot write to %s", CVSADM_CIPROG);
d3545 2
a3546 2
	pending_error_text = malloc (80 + strlen(CVSADM_CIPROG));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_CIPROG);
d3560 2
a3561 2
	pending_error_text = malloc (80 + strlen(CVSADM_UPROG));
	sprintf(pending_error_text, "E cannot open %s", CVSADM_UPROG);
d3567 2
a3568 2
	pending_error_text = malloc (80 + strlen(CVSADM_UPROG));
	sprintf(pending_error_text, "E cannot write to %s", CVSADM_UPROG);
d3574 2
a3575 2
	pending_error_text = malloc (80 + strlen(CVSADM_UPROG));
	sprintf(pending_error_text, "E cannot close %s", CVSADM_UPROG);
d3991 7
a3997 2
	    if (status == EEXIST)
		status = 0;
d3999 1
a3999 4
	    if (status == 0)
		status = chmod (server_temp_dir, S_IRWXU);
#endif
	    if (status != 0)
d4001 8
a4008 2
		pending_error_text = "E can't create temporary directory";
		pending_error = status;
d4010 1
d4407 9
a4415 4
    char tmp[PATH_MAX];
    char repository[PATH_MAX];
    char username[PATH_MAX];
    char password[PATH_MAX];
d4474 6
a4479 1
    fgets (tmp, PATH_MAX, stdin);
d4486 4
a4489 3
    fgets (repository, PATH_MAX, stdin);
    fgets (username, PATH_MAX, stdin);
    fgets (password, PATH_MAX, stdin);
d4497 2
a4498 1
    fgets (tmp, PATH_MAX, stdin);
d4553 4
@


1.11
log
@Undo CVSroot change in main.c
Pass CVS root directory as an argument to parseopts()
Add prototype for parseopts()
@
text
@d1 10
d21 4
d47 11
a57 1
#include <sys/time.h>
d90 14
a103 16
/* Functions which the server calls.  */
int add PROTO((int argc, char **argv));
int admin PROTO((int argc, char **argv));
int checkout PROTO((int argc, char **argv));
int commit PROTO((int argc, char **argv));
int diff PROTO((int argc, char **argv));
int history PROTO((int argc, char **argv));
int import PROTO((int argc, char **argv));
int cvslog PROTO((int argc, char **argv));
int patch PROTO((int argc, char **argv));
int release PROTO((int argc, char **argv));
int cvsremove PROTO((int argc, char **argv));
int rtag PROTO((int argc, char **argv));
int status PROTO((int argc, char **argv));
int tag PROTO((int argc, char **argv));
int update PROTO((int argc, char **argv));
d420 3
a422 1
int
d475 10
a491 2
static int use_dir_and_repos = 0;

d691 7
a697 1
    dirswitch (arg + 1, arg);
a706 1
    use_dir_and_repos = 1;
a1055 1
#endif /* SERVER_SUPPORT */
a1056 7
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)

int use_unchanged = 0;

#endif
#ifdef SERVER_SUPPORT

a1060 37
    use_unchanged = 1;
}

static void
serve_lost (arg)
    char *arg;
{
    if (use_unchanged)
    {
	/* A missing file already indicates it is nonexistent.  */
	return;
    }
    else
    {
	struct utimbuf ut;
	int fd = CVS_OPEN (arg, O_WRONLY | O_CREAT | O_TRUNC, 0666);
	if (fd < 0 || close (fd) < 0)
	{
	    pending_error = errno;
	    pending_error_text = malloc (80 + strlen(arg));
	    sprintf(pending_error_text, "E cannot open %s", arg);
	    return;
	}
	/*
	 * Set the times to the beginning of the epoch to tell time_stamp()
	 * that the file was lost.
	 */
	ut.actime = 0;
	ut.modtime = 0;
	if (utime (arg, &ut) < 0)
	{
	    pending_error = errno;
	    pending_error_text = malloc (80 + strlen(arg));
	    sprintf(pending_error_text, "E cannot utime %s", arg);
	    return;
	}
    }
d1074 5
d1081 3
a1083 6
    if (!use_unchanged) 
    {
	/* A missing file already indicates it is unchanged.  */
	return;
    }
    else
d1085 12
a1096 16
	struct an_entry *p;
	char *name;
	char *cp;
	char *timefield;

	/* Rewrite entries file to have `=' in timestamp field.  */
	for (p = entries; p != NULL; p = p->next)
	{
	    name = p->entry + 1;
	    cp = strchr (name, '/');
	    if (cp != NULL
		&& strlen (arg) == cp - name
		&& strncmp (arg, name, cp - name) == 0)
	    {
		timefield = strchr (cp + 1, '/') + 1;
		if (*timefield != '=')
d1098 2
a1099 8
		    cp = timefield + strlen (timefield);
		    cp[1] = '\0';
		    while (cp > timefield)
		    {
			*cp = cp[-1];
			--cp;
		    }
		    *timefield = '=';
d1101 1
a1101 1
		break;
d1103 1
a1325 3
    List *list;
    Node *node;
    int status;
d1336 1
a1336 8
	/* Now writelock.  */
	list = getlist ();
	node = getnode ();
	node->type = LOCK;
	node->key = xstrdup (repos);
	status = addnode (list, node);
	assert (status == 0);
	Writer_Lock (list);
a1343 1
	if (use_dir_and_repos)
a1367 1
	/* Remove the writelock.  */
a1368 1
	dellist (&list);
d1617 1
a1617 2
    server_cleanup (0);
    exit (EXIT_FAILURE);
d1627 158
d1795 2
a1796 1
do_cvs_command (command)
d1832 15
d1882 1
a1882 1
    dev_null_fd = CVS_OPEN ("/dev/null", O_RDONLY);
d2414 3
d2424 1
a2424 1
    if (use_dir_and_repos)
d2426 2
a2427 5
	if (update_dir[0] == '\0')
	    buf_output0 (protocol, ".");
	else
	    buf_output0 (protocol, update_dir);
	buf_output0 (protocol, "/\n");
d2429 5
d2579 1
d2584 1
a2584 1
    do_cvs_command (commit);
d2679 1
a2679 1
    do_cvs_command (update);
d2686 1
a2686 1
    do_cvs_command (diff);
d2693 1
a2693 1
    do_cvs_command (cvslog);
d2700 1
a2700 1
    do_cvs_command (add);
d2707 1
a2707 1
    do_cvs_command (cvsremove);
d2714 1
a2714 1
    do_cvs_command (status);
d2721 1
a2721 1
    do_cvs_command (patch);
d2728 1
a2728 1
    do_cvs_command (tag);
d2735 1
a2735 1
    do_cvs_command (rtag);
d2742 1
a2742 1
    do_cvs_command (import);
d2749 1
a2749 1
    do_cvs_command (admin);
d2756 1
a2756 1
    do_cvs_command (history);
d2763 1
a2763 1
    do_cvs_command (release);
d2772 1
a2772 1
    do_cvs_command (watch_on);
d2781 1
a2781 1
    do_cvs_command (watch_off);
d2790 1
a2790 1
    do_cvs_command (watch_add);
d2799 1
a2799 1
    do_cvs_command (watch_remove);
d2808 1
a2808 1
    do_cvs_command (watchers);
d2817 1
a2817 1
    do_cvs_command (editors);
d2836 1
a2836 1
    do_cvs_command (noop);
d2847 1
a2847 1
    do_cvs_command (init);
d2856 1
a2856 1
    do_cvs_command (annotate);
d2905 9
a2913 1
    do_cvs_command (checkout);
d3033 2
a3034 3
	       (set in .bashrc if rsh is in use, or set in main.c in
	       the kerberos case, I think) affects what mode we send,
	       and it shouldn't.  */
a3409 5
    /*
     * FIXME: error handling is bogus; do_module can write to stdout and/or
     * stderr and we're not using do_cvs_command.
     */

d3548 1
a3548 1
  REQ_LINE("Directory", serve_directory, rq_optional),
d3556 4
a3559 1
  REQ_LINE("Lost", serve_lost, rq_optional),
d3561 2
a3562 1
  REQ_LINE("Unchanged", serve_unchanged, rq_optional),
d3845 11
d3888 2
d3899 12
d3931 16
d3950 1
d3952 2
d3955 2
d3958 2
d3961 2
d3964 2
a3965 1
    
d3980 11
d4073 10
d4104 4
a4107 3
    /* Inhibit access by randoms.  Don't want people randomly
       changing our temporary tree before we check things in.  */
    umask (077);
d4136 6
d4155 5
d4162 1
a4162 1
			+ strlen ("CVSROOT")
d4164 1
a4164 1
			+ strlen ("passwd")
d4167 2
a4168 3
    strcpy (filename, repository);
    strcat (filename, "/CVSROOT");
    strcat (filename, "/passwd");
d4199 1
a4199 1
	char *found_password;
d4203 4
a4206 2
	*host_user_ptr = strtok (NULL, ": \n");
	if (*host_user_ptr == NULL) *host_user_ptr = username;
d4208 5
d4214 1
d4216 4
a4219 1
	    retval = 2;
d4239 1
a4239 1
    char *host_user;
d4248 5
d4254 4
a4257 3
	return host_user;
    else if (rc == 2)
	return 0;
d4285 11
d4300 6
a4305 2
	    return ((! strcmp (found_passwd, crypt (password, found_passwd)))
		    ? username : NULL);
d4307 4
a4310 1
	    return username;
d4312 4
a4315 1
	    return NULL;
d4321 11
a4331 1
	return NULL;
d4333 2
d4445 10
d4460 7
d4468 6
d4504 5
d4530 5
d4546 5
d5022 6
d5060 26
@


1.10
log
@Integrate local changes
@
text
@d504 1
a504 1
    parseopts();
@


1.9
log
@who wrote this code? nonblocking pipe, select, and then not deal with a
read of zero? spin city. i think this deals properly with dead sockets.
@
text
@d6 2
d11 17
d47 8
d56 3
d83 7
d97 4
d104 91
a194 2
static char no_mem_error;
#define NO_MEM_ERROR (&no_mem_error)
d196 2
a197 1
static void server_write_entries PROTO((void));
d199 1
a199 10
/*
 * Read a line from the stream "instream" without command line editing.
 *
 * Action is compatible with "readline", e.g. space for the result is
 * malloc'd and should be freed by the caller.
 *
 * A NULL return means end of file.  A return of NO_MEM_ERROR means
 * that we are out of memory.
 */
static char *read_line PROTO((FILE *));
d201 6
a206 3
static char *
read_line (stream)
    FILE *stream;
d208 5
a212 11
    int c;
    char *result;
    int input_index = 0;
    int result_size = 80;

    fflush (stdout);
    result = (char *) malloc (result_size);
    if (result == NULL)
	return NO_MEM_ERROR;
    
    while (1)
d214 5
a218 3
	c = fgetc (stream);
	
	if (c == EOF)
d220 14
a233 14
	    free (result);
	    return NULL;
	}
	
	if (c == '\n')
	    break;
	
	result[input_index++] = c;
	while (input_index >= result_size)
	{
	    result_size *= 2;
	    result = (char *) realloc (result, result_size);
	    if (result == NULL)
		return NO_MEM_ERROR;
d235 4
d240 40
a279 3
    
    result[input_index++] = '\0';
    return result;
d341 1
d348 1
a348 1
    printf ("error  ");
d351 4
a354 2
	printf ("%s", msg);
    printf ("\n");
d364 2
a365 1
/* If an error is pending, print it and return 1.  If not, return 0.  */
d371 2
a372 1
	printf ("%s\n", pending_error_text);
d376 4
a379 1
	    printf ("error  \n");
d443 8
a450 2
	    printf ("E response `%s' not supported by client\nerror  \n",
		    rs->name);
a464 1
    extern char *CVSroot;
d469 2
d472 1
a472 1
    (void) sprintf (path, "%s/%s", arg, CVSROOTADM);
a492 7
    CVSroot = malloc (strlen (arg) + 1);
    if (CVSroot == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (CVSroot, arg);
d494 1
a494 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (CVSroot) + 1 + 1);
d500 1
a500 1
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, arg);
d531 2
a532 1
    free (server_temp_dir);
d545 1
d574 7
a580 1
    if (chdir (dir_name) < 0)
d599 1
a599 1
    f = fopen (CVSADM_REP, "w");
d605 21
a625 1
    if (fprintf (f, "%s\n", repos) < 0)
d636 3
a638 1
    f = fopen (CVSADM_ENT, "w+");
d666 1
d668 1
d670 2
a671 2
    repos = read_line (stdin);
    if (repos == NULL)
d673 2
a674 15
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text)
	{
	    if (feof (stdin))
		sprintf (pending_error_text,
			 "E end of file reading mode for %s", arg);
	    else
	    {
		sprintf (pending_error_text,
			 "E error reading mode for %s", arg);
		pending_error = errno;
	    }
	}
	else
	    pending_error = ENOMEM;
d676 1
a676 1
    else if (repos == NO_MEM_ERROR)
d678 1
a678 1
	pending_error = ENOMEM;
d682 16
a697 2
	dirswitch (arg, repos);
	free (repos);
d706 4
a709 1
    f = fopen (CVSADM_ENTSTAT, "w+");
d731 4
a734 1
    f = fopen (CVSADM_TAG, "w+");
d759 1
a759 1
 * Read SIZE bytes from stdin, write them to FILE.
a771 2
    char buf[16*1024], *bufp;
    int toread, nread, nwrote;
d774 2
a775 3
	toread = sizeof (buf);
	if (toread > size)
	    toread = size;
d777 2
a778 2
	nread = fread (buf, 1, toread, stdin);
	if (nread <= 0)
d780 3
a782 1
	    if (feof (stdin))
d785 3
a787 1
		if (pending_error_text)
d794 1
a794 6
		    pending_error = ENOMEM;
	    }
	    else if (ferror (stdin))
	    {
		pending_error_text = malloc (40);
		if (pending_error_text)
d797 2
a798 9
		pending_error = errno;
	    }
	    else
	    {
		pending_error_text = malloc (40);
		if (pending_error_text)
		    sprintf (pending_error_text,
			     "E short read from client");
		pending_error = 0;
d802 1
d804 2
a805 2
	bufp = buf;
	while (nread)
d807 3
a809 1
	    nwrote = write (file, bufp, nread);
d813 1
a813 1
		if (pending_error_text)
d816 13
d832 1
a832 1
	    bufp += nwrote;
d850 1
a850 1
    fd = open (arg, O_WRONLY | O_CREAT | O_TRUNC, 0600);
d907 1
a907 1
    int size;
d913 8
a920 1
    if (error_pending ()) return;
d922 2
a923 2
    mode_text = read_line (stdin);
    if (mode_text == NULL)
d925 3
a927 2
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text)
d929 3
a931 3
	    if (feof (stdin))
		sprintf (pending_error_text,
			 "E end of file reading mode for %s", arg);
d934 9
a942 3
		sprintf (pending_error_text,
			 "E error reading mode for %s", arg);
		pending_error = errno;
a944 7
	else
	    pending_error = ENOMEM;
	return;
    } 
    else if (mode_text == NO_MEM_ERROR)
    {
	pending_error = ENOMEM;
d947 3
a949 2
    size_text = read_line (stdin);
    if (size_text == NULL)
d951 3
a953 2
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text)
d955 3
a957 3
	    if (feof (stdin))
		sprintf (pending_error_text,
			 "E end of file reading size for %s", arg);
d960 9
a968 3
		sprintf (pending_error_text,
			 "E error reading size for %s", arg);
		pending_error = errno;
a970 7
	else
	    pending_error = ENOMEM;
	return;
    } 
    else if (size_text == NO_MEM_ERROR)
    {
	pending_error = ENOMEM;
d974 1
a974 1
      {
d977 1
a977 1
      }
d979 1
a979 1
      size = atoi (size_text);
d982 16
d999 1
a999 1
      {
d1002 1
a1002 1
      }
d1032 1
a1032 1
  use_unchanged = 1;
d1047 1
a1047 1
	int fd = open (arg, O_WRONLY | O_CREAT | O_TRUNC, 0666);
d1163 6
a1168 1
	f = fopen (CVSADM_ENT, "w");
d1231 1
d1258 2
a1259 2
    data = read_line (stdin);
    if (data == NULL)
d1261 3
a1263 2
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text)
d1265 3
a1267 3
	    if (feof (stdin))
		sprintf (pending_error_text,
			 "E end of file reading mode for %s", arg);
d1270 9
a1278 3
		sprintf (pending_error_text,
			 "E error reading mode for %s", arg);
		pending_error = errno;
a1280 2
	else
	    pending_error = ENOMEM;
d1282 1
a1282 1
    else if (data == NO_MEM_ERROR)
d1284 1
a1284 5
	pending_error = ENOMEM;
    }
    else
    {
	char *cp;
d1347 1
a1347 1
	if (chdir (notify_list->dir) < 0)
d1368 1
a1368 1
	printf ("Notified ");
d1373 1
a1373 1
		fputs (".", stdout);
d1375 8
a1382 7
		fputs (dir, stdout);
	    fputs ("/\n", stdout);
	}
	fputs (repos, stdout);
	fputs ("/", stdout);
	fputs (notify_list->filename, stdout);
	fputs ("\n", stdout);
d1398 5
a1402 3
    /* do_cvs_command writes to stdout via write(), not stdio, so better
       flush out the buffer.  */
    fflush (stdout);
a1504 13

/*
 * We must read data from a child process and send it across the
 * network.  We do not want to block on writing to the network, so we
 * store the data from the child process in memory.  A BUFFER
 * structure holds the status of one communication, and uses a linked
 * list of buffer_data structures to hold data.
 */

struct buffer
{
    /* Data.  */
    struct buffer_data *data;
d1506 2
a1507 2
    /* Last buffer on data chain.  */
    struct buffer_data *last;
d1509 3
a1511 16
    /* File descriptor to write to or read from.  */
    int fd;

    /* Nonzero if this is an output buffer (sanity check).  */
    int output;

    /* Nonzero if the file descriptor is in nonblocking mode.  */
    int nonblocking;

    /* Function to call if we can't allocate memory.  */
    void (*memory_error) PROTO((struct buffer *));
};

/* Data is stored in lists of these structures.  */

struct buffer_data
d1513 1
a1513 2
    /* Next buffer in linked list.  */
    struct buffer_data *next;
d1515 7
a1521 18
    /*
     * A pointer into the data area pointed to by the text field.  This
     * is where to find data that has not yet been written out.
     */
    char *bufp;

    /* The number of data bytes found at BUFP.  */
    int size;

    /*
     * Actual buffer.  This never changes after the structure is
     * allocated.  The buffer is BUFFER_DATA_SIZE bytes.
     */
    char *text;
};

/* The size we allocate for each buffer_data structure.  */
#define BUFFER_DATA_SIZE (4096)
d1523 3
a1534 1
#endif /* SERVER_FLOWCONTROL */
d1536 12
a1547 2
/* Linked list of available buffer_data structures.  */
static struct buffer_data *free_buffer_data;
d1549 7
a1555 18
static void allocate_buffer_datas PROTO((void));
static inline struct buffer_data *get_buffer_data PROTO((void));
static int buf_empty_p PROTO((struct buffer *));
static void buf_output PROTO((struct buffer *, const char *, int));
static void buf_output0 PROTO((struct buffer *, const char *));
static inline void buf_append_char PROTO((struct buffer *, int));
static int buf_send_output PROTO((struct buffer *));
static int set_nonblock PROTO((struct buffer *));
static int set_block PROTO((struct buffer *));
static int buf_send_counted PROTO((struct buffer *));
static inline void buf_append_data PROTO((struct buffer *,
				     struct buffer_data *,
				     struct buffer_data *));
static int buf_read_file PROTO((FILE *, long, struct buffer_data **,
				  struct buffer_data **));
static int buf_input_data PROTO((struct buffer *, int *));
static void buf_copy_lines PROTO((struct buffer *, struct buffer *, int));
static int buf_copy_counted PROTO((struct buffer *, struct buffer *));
a1556 3
#ifdef SERVER_FLOWCONTROL
static int buf_count_mem PROTO((struct buffer *));
static int set_nonblock_fd PROTO((int));
d1558 2
a1559 2

/* Allocate more buffer_data structures.  */
d1562 2
a1563 1
allocate_buffer_datas ()
d1565 1
a1565 3
    struct buffer_data *alc;
    char *space;
    int i;
d1567 7
a1573 2
    /* Allocate buffer_data structures in blocks of 16.  */
#define ALLOC_COUNT (16)
d1575 3
a1577 4
    alc = ((struct buffer_data *)
	   malloc (ALLOC_COUNT * sizeof (struct buffer_data)));
    space = (char *) valloc (ALLOC_COUNT * BUFFER_DATA_SIZE);
    if (alc == NULL || space == NULL)
d1579 3
a1581 1
    for (i = 0; i < ALLOC_COUNT; i++, alc++, space += BUFFER_DATA_SIZE)
d1583 12
a1594 4
	alc->next = free_buffer_data;
	free_buffer_data = alc;
	alc->text = space;
    }	  
d1597 1
a1597 1
/* Get a new buffer_data structure.  */
d1599 3
a1601 2
static inline struct buffer_data *
get_buffer_data ()
d1603 1
a1603 12
    struct buffer_data *ret;

    if (free_buffer_data == NULL)
    {
	allocate_buffer_datas ();
	if (free_buffer_data == NULL)
	    return NULL;
    }

    ret = free_buffer_data;
    free_buffer_data = ret->next;
    return ret;
d1605 2
d1608 9
a1616 4
/* See whether a buffer is empty.  */

static int
buf_empty_p (buf)
d1619 1
a1619 6
    struct buffer_data *data;

    for (data = buf->data; data != NULL; data = data->next)
	if (data->size > 0)
	    return 0;
    return 1;
a1621 1
#ifdef SERVER_FLOWCONTROL
d1623 2
a1624 2
 * Count how much data is stored in the buffer..
 * Note that each buffer is a malloc'ed chunk BUFFER_DATA_SIZE.
d1626 1
d1628 2
a1629 2
static int
buf_count_mem (buf)
d1632 4
a1635 2
    struct buffer_data *data;
    int mem = 0;
d1637 5
a1641 2
    for (data = buf->data; data != NULL; data = data->next)
	mem += BUFFER_DATA_SIZE;
d1643 4
a1646 1
    return mem;
a1647 3
#endif /* SERVER_FLOWCONTROL */

/* Add data DATA of length LEN to BUF.  */
d1650 2
a1651 4
buf_output (buf, data, len)
    struct buffer *buf;
    const char *data;
    int len;
d1653 4
a1656 9
    if (buf->data != NULL
	&& (((buf->last->text + BUFFER_DATA_SIZE)
	     - (buf->last->bufp + buf->last->size))
	    >= len))
    {
	memcpy (buf->last->bufp + buf->last->size, data, len);
	buf->last->size += len;
	return;
    }
d1658 2
a1659 3
    while (1)
    {
	struct buffer_data *newdata;
d1661 3
a1663 6
	newdata = get_buffer_data ();
	if (newdata == NULL)
	{
	    (*buf->memory_error) (buf);
	    return;
	}
d1665 8
a1672 6
	if (buf->data == NULL)
	    buf->data = newdata;
	else
	    buf->last->next = newdata;
	newdata->next = NULL;
	buf->last = newdata;
d1674 3
a1676 1
	newdata->bufp = newdata->text;
d1678 8
a1685 6
	if (len <= BUFFER_DATA_SIZE)
	{
	    newdata->size = len;
	    memcpy (newdata->text, data, len);
	    return;
	}
d1687 1
a1687 2
	newdata->size = BUFFER_DATA_SIZE;
	memcpy (newdata->text, data, BUFFER_DATA_SIZE);
d1689 7
a1695 3
	data += BUFFER_DATA_SIZE;
	len -= BUFFER_DATA_SIZE;
    }
d1697 1
a1697 2
    /*NOTREACHED*/
}
d1699 2
a1700 1
/* Add a '\0' terminated string to BUF.  */
d1702 1
a1702 7
static void
buf_output0 (buf, string)
    struct buffer *buf;
    const char *string;
{
    buf_output (buf, string, strlen (string));
}
d1704 7
a1710 1
/* Add a single character to BUF.  */
d1712 11
a1722 8
static inline void
buf_append_char (buf, ch)
    struct buffer *buf;
    int ch;
{
    if (buf->data != NULL
	&& (buf->last->text + BUFFER_DATA_SIZE
	    != buf->last->bufp + buf->last->size))
d1724 2
a1725 2
	*(buf->last->bufp + buf->last->size) = ch;
	++buf->last->size;
d1727 2
a1728 1
    else
d1730 6
a1735 1
	char b;
d1737 5
a1741 2
	b = ch;
	buf_output (buf, &b, 1);
a1742 1
}
d1744 12
a1755 5
/*
 * Send all the output we've been saving up.  Returns 0 for success or
 * errno code.  If the buffer has been set to be nonblocking, this
 * will just write until the write would block.
 */
d1757 2
a1758 6
static int
buf_send_output (buf)
     struct buffer *buf;
{
    if (! buf->output)
	abort ();
d1760 8
a1767 1
    while (buf->data != NULL)
d1769 1
a1769 1
	struct buffer_data *data;
d1771 4
a1774 4
	data = buf->data;
	while (data->size > 0)
	{
	    int nbytes;
d1776 2
a1777 4
	    nbytes = write (buf->fd, data->bufp, data->size);
	    if (nbytes <= 0)
	    {
		int status;
d1779 11
a1789 13
		if (buf->nonblocking
		    && (nbytes == 0
#ifdef EWOULDBLOCK
			|| errno == EWOULDBLOCK
#endif
			|| errno == EAGAIN))
		{
		    /*
		     * A nonblocking write failed to write any data.
		     * Just return.
		     */
		    return 0;
		}
d1791 1
a1791 812
		/*
		 * An error, or EOF.  Throw away all the data and
		 * return.
		 */
		if (nbytes == 0)
		    status = EIO;
		else
		    status = errno;

		buf->last->next = free_buffer_data;
		free_buffer_data = buf->data;
		buf->data = NULL;
		buf->last = NULL;

		return status;
	    }

	    data->size -= nbytes;
	    data->bufp += nbytes;
	}

	buf->data = data->next;
	data->next = free_buffer_data;
	free_buffer_data = data;
    }

    buf->last = NULL;

    return 0;
}

#ifdef SERVER_FLOWCONTROL
/*
 * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */

static int
set_nonblock_fd (fd)
     int fd;
{
    int flags;

    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    return 0;
}
#endif /* SERVER_FLOWCONTROL */

static int
set_nonblock (buf)
     struct buffer *buf;
{
    int flags;

    if (buf->nonblocking)
	return 0;
    flags = fcntl (buf->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (buf->fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    buf->nonblocking = 1;
    return 0;
}

/*
 * Set buffer BUF to blocking I/O.  Returns 0 for success or errno
 * code.
 */

static int
set_block (buf)
     struct buffer *buf;
{
    int flags;

    if (! buf->nonblocking)
	return 0;
    flags = fcntl (buf->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (buf->fd, F_SETFL, flags & ~O_NONBLOCK) < 0)
	return errno;
    buf->nonblocking = 0;
    return 0;
}

/*
 * Send a character count and some output.  Returns errno code or 0 for
 * success.
 *
 * Sending the count in binary is OK since this is only used on a pipe
 * within the same system.
 */

static int
buf_send_counted (buf)
     struct buffer *buf;
{
    int size;
    struct buffer_data *data;

    if (! buf->output)
	abort ();

    size = 0;
    for (data = buf->data; data != NULL; data = data->next)
	size += data->size;

    data = get_buffer_data ();
    if (data == NULL)
    {
	(*buf->memory_error) (buf);
	return ENOMEM;
    }

    data->next = buf->data;
    buf->data = data;
    if (buf->last == NULL)
	buf->last = data;

    data->bufp = data->text;
    data->size = sizeof (int);

    *((int *) data->text) = size;

    return buf_send_output (buf);
}

/* Append a list of buffer_data structures to an buffer.  */

static inline void
buf_append_data (buf, data, last)
     struct buffer *buf;
     struct buffer_data *data;
     struct buffer_data *last;
{
    if (data != NULL)
    {
	if (buf->data == NULL)
	    buf->data = data;
	else
	    buf->last->next = data;
	buf->last = last;
    }
}

/*
 * Copy the contents of file F into buffer_data structures.  We can't
 * copy directly into an buffer, because we want to handle failure and
 * succeess differently.  Returns 0 on success, or -2 if out of
 * memory, or a status code on error.  Since the caller happens to
 * know the size of the file, it is passed in as SIZE.  On success,
 * this function sets *RETP and *LASTP, which may be passed to
 * buf_append_data.
 */

static int
buf_read_file (f, size, retp, lastp)
    FILE *f;
    long size;
    struct buffer_data **retp;
    struct buffer_data **lastp;
{
    int status;

    *retp = NULL;
    *lastp = NULL;

    while (size > 0)
    {
	struct buffer_data *data;
	int get;

	data = get_buffer_data ();
	if (data == NULL)
	{
	    status = -2;
	    goto error_return;
	}

	if (*retp == NULL)
	    *retp = data;
	else
	    (*lastp)->next = data;
	data->next = NULL;
	*lastp = data;

	data->bufp = data->text;
	data->size = 0;

	if (size > BUFFER_DATA_SIZE)
	    get = BUFFER_DATA_SIZE;
	else
	    get = size;

	errno = EIO;
	if (fread (data->text, get, 1, f) != 1)
	{
	    status = errno;
	    goto error_return;
	}

	data->size += get;
	size -= get;
    }

    return 0;

  error_return:
    if (*retp != NULL)
    {
	(*lastp)->next = free_buffer_data;
	free_buffer_data = *retp;
    }
    return status;
}

static int
buf_read_file_to_eof (f, retp, lastp)
     FILE *f;
     struct buffer_data **retp;
     struct buffer_data **lastp;
{
    int status;

    *retp = NULL;
    *lastp = NULL;

    while (!feof (f))
    {
	struct buffer_data *data;
	int get, nread;

	data = get_buffer_data ();
	if (data == NULL)
	{
	    status = -2;
	    goto error_return;
	}

	if (*retp == NULL)
	    *retp = data;
	else
	    (*lastp)->next = data;
	data->next = NULL;
	*lastp = data;

	data->bufp = data->text;
	data->size = 0;

	get = BUFFER_DATA_SIZE;

	errno = EIO;
	nread = fread (data->text, 1, get, f);
	if (nread == 0 && !feof (f))
	{
	    status = errno;
	    goto error_return;
	}

	data->size = nread;
    }

    return 0;

  error_return:
    if (*retp != NULL)
    {
	(*lastp)->next = free_buffer_data;
	free_buffer_data = *retp;
    }
    return status;
}

static int
buf_chain_length (buf)
     struct buffer_data *buf;
{
    int size = 0;
    while (buf)
    {
	size += buf->size;
	buf = buf->next;
    }
    return size;
}

/*
 * Read an arbitrary amount of data from a file descriptor into an
 * input buffer.  The file descriptor will be in nonblocking mode, and
 * we just grab what we can.  Return 0 on success, or -1 on end of
 * file, or -2 if out of memory, or an error code.  If COUNTP is not
 * NULL, *COUNTP is set to the number of bytes read.
 */

static int
buf_input_data (buf, countp)
     struct buffer *buf;
     int *countp;
{
    if (buf->output)
	abort ();

    if (countp != NULL)
	*countp = 0;

    while (1)
    {
	int get;
	int nbytes;

	if (buf->data == NULL
	    || (buf->last->bufp + buf->last->size
		== buf->last->text + BUFFER_DATA_SIZE))
	{
	    struct buffer_data *data;

	    data = get_buffer_data ();
	    if (data == NULL)
	    {
		(*buf->memory_error) (buf);
		return -2;
	    }

	    if (buf->data == NULL)
		buf->data = data;
	    else
		buf->last->next = data;
	    data->next = NULL;
	    buf->last = data;

	    data->bufp = data->text;
	    data->size = 0;
	}

	get = ((buf->last->text + BUFFER_DATA_SIZE)
	       - (buf->last->bufp + buf->last->size));
	nbytes = read (buf->fd, buf->last->bufp + buf->last->size, get);
	if (nbytes <= 0)
	{
	    if (nbytes == 0)
	    {
		/*
		 * This assumes that we are using POSIX or BSD style
		 * nonblocking I/O.  On System V we will get a zero
		 * return if there is no data, even when not at EOF.
		 */
		return -1;
	    }

	    if (errno == EAGAIN
#ifdef EWOULDBLOCK
		|| errno == EWOULDBLOCK
#endif
		)
	      return 0;

	    return errno;
	}

	buf->last->size += nbytes;
	if (countp != NULL)
	    *countp += nbytes;
    }

    /*NOTREACHED*/
}

/*
 * Copy lines from an input buffer to an output buffer.  This copies
 * all complete lines (characters up to a newline) from INBUF to
 * OUTBUF.  Each line in OUTBUF is preceded by the character COMMAND
 * and a space.
 */

static void
buf_copy_lines (outbuf, inbuf, command)
     struct buffer *outbuf;
     struct buffer *inbuf;
     int command;
{
    if (! outbuf->output || inbuf->output)
	abort ();

    while (1)
    {
	struct buffer_data *data;
	struct buffer_data *nldata;
	char *nl;
	int len;

	/* See if there is a newline in INBUF.  */
	nldata = NULL;
	nl = NULL;
	for (data = inbuf->data; data != NULL; data = data->next)
	{
	    nl = memchr (data->bufp, '\n', data->size);
	    if (nl != NULL)
	    {
		nldata = data;
		break;
	    }
	}

	if (nldata == NULL)
	{
	    /* There are no more lines in INBUF.  */
	    return;
	}

	/* Put in the command.  */
	buf_append_char (outbuf, command);
	buf_append_char (outbuf, ' ');

	if (inbuf->data != nldata)
	{
	    /*
	     * Simply move over all the buffers up to the one containing
	     * the newline.
	     */
	    for (data = inbuf->data; data->next != nldata; data = data->next)
		;
	    data->next = NULL;
	    buf_append_data (outbuf, inbuf->data, data);
	    inbuf->data = nldata;
	}

	/*
	 * If the newline is at the very end of the buffer, just move
	 * the buffer onto OUTBUF.  Otherwise we must copy the data.
	 */
	len = nl + 1 - nldata->bufp;
	if (len == nldata->size)
	{
	    inbuf->data = nldata->next;
	    if (inbuf->data == NULL)
		inbuf->last = NULL;

	    nldata->next = NULL;
	    buf_append_data (outbuf, nldata, nldata);
	}
	else
	{
	    buf_output (outbuf, nldata->bufp, len);
	    nldata->bufp += len;
	    nldata->size -= len;
	}
    }
}

/*
 * Copy counted data from one buffer to another.  The count is an
 * integer, host size, host byte order (it is only used across a
 * pipe).  If there is enough data, it should be moved over.  If there
 * is not enough data, it should remain on the original buffer.  This
 * returns the number of bytes it needs to see in order to actually
 * copy something over.
 */

static int
buf_copy_counted (outbuf, inbuf)
     struct buffer *outbuf;
     struct buffer *inbuf;
{
    if (! outbuf->output || inbuf->output)
	abort ();

    while (1)
    {
	struct buffer_data *data;
	int need;
	union
	{
	    char intbuf[sizeof (int)];
	    int i;
	} u;
	char *intp;
	int count;
	struct buffer_data *start;
	int startoff;
	struct buffer_data *stop;
	int stopwant;

	/* See if we have enough bytes to figure out the count.  */
	need = sizeof (int);
	intp = u.intbuf;
	for (data = inbuf->data; data != NULL; data = data->next)
	{
	    if (data->size >= need)
	    {
		memcpy (intp, data->bufp, need);
		break;
	    }
	    memcpy (intp, data->bufp, data->size);
	    intp += data->size;
	    need -= data->size;
	}
	if (data == NULL)
	{
	    /* We don't have enough bytes to form an integer.  */
	    return need;
	}

	count = u.i;
	start = data;
	startoff = need;

	/*
	 * We have an integer in COUNT.  We have gotten all the data
	 * from INBUF in all buffers before START, and we have gotten
	 * STARTOFF bytes from START.  See if we have enough bytes
	 * remaining in INBUF.
	 */
	need = count - (start->size - startoff);
	if (need <= 0)
	{
	    stop = start;
	    stopwant = count;
	}
	else
	{
	    for (data = start->next; data != NULL; data = data->next)
	    {
		if (need <= data->size)
		    break;
		need -= data->size;
	    }
	    if (data == NULL)
	    {
		/* We don't have enough bytes.  */
		return need;
	    }
	    stop = data;
	    stopwant = need;
	}

	/*
	 * We have enough bytes.  Free any buffers in INBUF before
	 * START, and remove STARTOFF bytes from START, so that we can
	 * forget about STARTOFF.
	 */
	start->bufp += startoff;
	start->size -= startoff;

	if (start->size == 0)
	    start = start->next;

	if (stop->size == stopwant)
	{
	    stop = stop->next;
	    stopwant = 0;
	}

	while (inbuf->data != start)
	{
	    data = inbuf->data;
	    inbuf->data = data->next;
	    data->next = free_buffer_data;
	    free_buffer_data = data;
	}

	/*
	 * We want to copy over the bytes from START through STOP.  We
	 * only want STOPWANT bytes from STOP.
	 */

	if (start != stop)
	{
	    /* Attach the buffers from START through STOP to OUTBUF.  */
	    for (data = start; data->next != stop; data = data->next)
		;
	    inbuf->data = stop;
	    data->next = NULL;
	    buf_append_data (outbuf, start, data);
	}

	if (stopwant > 0)
	{
	    buf_output (outbuf, stop->bufp, stopwant);
	    stop->bufp += stopwant;
	    stop->size -= stopwant;
	}
    }

    /*NOTREACHED*/
}

/* While processing requests, this buffer accumulates data to be sent to
   the client, and then once we are in do_cvs_command, we use it
   for all the data to be sent.  */
static struct buffer buf_to_net;

static void serve_questionable PROTO((char *));

static void
serve_questionable (arg)
    char *arg;
{
    static int initted;

    if (!initted)
    {
	/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server,
	   and CVSIGNORE on server.  */
	ign_setup ();
	initted = 1;
    }

    if (dir_name == NULL)
    {
	buf_output0 (&buf_to_net, "E Protocol error: 'Directory' missing");
	return;
    }

    if (!ign_name (arg))
    {
	char *update_dir;

	buf_output (&buf_to_net, "M ? ", 4);
	update_dir = dir_name + strlen (server_temp_dir) + 1;
	if (!(update_dir[0] == '.' && update_dir[1] == '\0'))
	{
	    buf_output0 (&buf_to_net, update_dir);
	    buf_output (&buf_to_net, "/", 1);
	}
	buf_output0 (&buf_to_net, arg);
	buf_output (&buf_to_net, "\n", 1);
    }
}

static void serve_case PROTO ((char *));

static void
serve_case (arg)
    char *arg;
{
    ign_case = 1;
}

static struct buffer protocol;

/* This is the output which we are saving up to send to the server, in the
   child process.  We will push it through, via the `protocol' buffer, when
   we have a complete line.  */
static struct buffer saved_output;
/* Likewise, but stuff which will go to stderr.  */
static struct buffer saved_outerr;

static void
protocol_memory_error (buf)
    struct buffer *buf;
{
    error (1, ENOMEM, "Virtual memory exhausted");
}

/*
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
 */
static pid_t command_pid;

static void
outbuf_memory_error (buf)
    struct buffer *buf;
{
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);

    /*
     * We have arranged things so that printing this now either will
     * be legal, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */

    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
    server_cleanup (0);
    exit (EXIT_FAILURE);
}

static void
input_memory_error (buf)
     struct buffer *buf;
{
    outbuf_memory_error (buf);
}

/* Execute COMMAND in a subprocess with the approriate funky things done.  */

static struct fd_set_wrapper { fd_set fds; } command_fds_to_drain;
static int max_command_fd;

#ifdef SERVER_FLOWCONTROL
static int flowcontrol_pipe[2];
#endif /* SERVER_FLOWCONTROL */

static void
do_cvs_command (command)
    int (*command) PROTO((int argc, char **argv));
{
    /*
     * The following file descriptors are set to -1 if that file is not
     * currently open.
     */

    /* Data on these pipes is a series of '\n'-terminated lines.  */
    int stdout_pipe[2];
    int stderr_pipe[2];

    /*
     * Data on this pipe is a series of counted (see buf_send_counted)
     * packets.  Each packet must be processed atomically (i.e. not
     * interleaved with data from stdout_pipe or stderr_pipe).
     */
    int protocol_pipe[2];
    
    int dev_null_fd = -1;

    int errs;

    command_pid = -1;
    stdout_pipe[0] = -1;
    stdout_pipe[1] = -1;
    stderr_pipe[0] = -1;
    stderr_pipe[1] = -1;
    protocol_pipe[0] = -1;
    protocol_pipe[1] = -1;

    server_write_entries ();

    if (print_pending_error ())
	goto free_args_and_return;

    (void) server_notify ();

    /*
     * We use a child process which actually does the operation.  This
     * is so we can intercept its standard output.  Even if all of CVS
     * were written to go to some special routine instead of writing
     * to stdout or stderr, we would still need to do the same thing
     * for the RCS commands.
     */

    if (pipe (stdout_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    if (pipe (stderr_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    if (pipe (protocol_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
#ifdef SERVER_FLOWCONTROL
    if (pipe (flowcontrol_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    set_nonblock_fd (flowcontrol_pipe[0]);
    set_nonblock_fd (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */

    dev_null_fd = open ("/dev/null", O_RDONLY);
    if (dev_null_fd < 0)
    {
	print_error (errno);
	goto error_exit;
    }

    /* Don't use vfork; we're not going to exec().  */
    command_pid = fork ();
    if (command_pid < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    if (command_pid == 0)
    {
	int exitstatus;

	/* Since we're in the child, and the parent is going to take
	   care of packaging up our error messages, we can clear this
	   flag.  */
	error_use_protocol = 0;

	protocol.data = protocol.last = NULL;
	protocol.fd = protocol_pipe[1];
	protocol.output = 1;
	protocol.nonblocking = 0;
	protocol.memory_error = protocol_memory_error;

	saved_output.data = saved_output.last = NULL;
	saved_output.fd = -1;
	saved_output.output = 0;
	saved_output.nonblocking = 0;
	saved_output.memory_error = protocol_memory_error;
	saved_outerr = saved_output;

	if (dup2 (dev_null_fd, STDIN_FILENO) < 0)
d1825 3
a1827 3
	struct buffer stdoutbuf;
	struct buffer stderrbuf;
	struct buffer protocol_inbuf;
d1854 3
a1856 1
	    printf ("E internal error: FD_SETSIZE not big enough.\nerror  \n");
d1860 13
a1872 22
	stdoutbuf.data = stdoutbuf.last = NULL;
	stdoutbuf.fd = stdout_pipe[0];
	stdoutbuf.output = 0;
	stdoutbuf.nonblocking = 0;
	stdoutbuf.memory_error = input_memory_error;

	stderrbuf.data = stderrbuf.last = NULL;
	stderrbuf.fd = stderr_pipe[0];
	stderrbuf.output = 0;
	stderrbuf.nonblocking = 0;
	stderrbuf.memory_error = input_memory_error;

	protocol_inbuf.data = protocol_inbuf.last = NULL;
	protocol_inbuf.fd = protocol_pipe[0];
	protocol_inbuf.output = 0;
	protocol_inbuf.nonblocking = 0;
	protocol_inbuf.memory_error = input_memory_error;

	set_nonblock (&buf_to_net);
	set_nonblock (&stdoutbuf);
	set_nonblock (&stderrbuf);
	set_nonblock (&protocol_inbuf);
d1925 1
a1925 1
	    bufmemsize = buf_count_mem (&buf_to_net);
d1940 1
a1940 1
	    if (! buf_empty_p (&buf_to_net))
d1956 8
d1981 1
a1981 1
		buf_send_output (&buf_to_net);
d1989 1
a1989 1
	        status = buf_input_data (&stdoutbuf, (int *) NULL);
d1991 1
a1991 1
		buf_copy_lines (&buf_to_net, &stdoutbuf, 'M');
d2002 1
a2002 1
		buf_send_output (&buf_to_net);
d2010 1
a2010 1
	        status = buf_input_data (&stderrbuf, (int *) NULL);
d2012 1
a2012 1
		buf_copy_lines (&buf_to_net, &stderrbuf, 'E');
d2023 1
a2023 1
		buf_send_output (&buf_to_net);
d2031 1
d2033 9
a2041 1
		status = buf_input_data (&protocol_inbuf, &count_read);
d2050 20
a2069 3
		if (count_needed <= 0)
		    count_needed = buf_copy_counted (&buf_to_net,
						     &protocol_inbuf);
d2071 2
a2072 6
		if (status == -1)
		    protocol_pipe[0] = -1;
		else if (status > 0)
		{
		    print_error (status);
		    goto error_exit;
a2073 3

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (&buf_to_net);
d2082 1
a2082 1
	if (! buf_empty_p (&stdoutbuf))
d2084 2
a2085 2
	    buf_append_char (&stdoutbuf, '\n');
	    buf_copy_lines (&buf_to_net, &stdoutbuf, 'M');
d2087 1
a2087 1
	if (! buf_empty_p (&stderrbuf))
d2089 2
a2090 2
	    buf_append_char (&stderrbuf, '\n');
	    buf_copy_lines (&buf_to_net, &stderrbuf, 'E');
d2092 2
a2093 2
	if (! buf_empty_p (&protocol_inbuf))
	    buf_output0 (&buf_to_net,
d2117 1
d2125 3
a2127 1
		printf ("E Terminated with fatal signal %d\n", sig);
d2132 4
a2135 3
		    printf ("E Core dumped; preserving %s on server.\n\
E CVS locks may need cleaning up.\n",
			    server_temp_dir);
d2148 2
a2149 2
	set_block (&buf_to_net);
	buf_send_output (&buf_to_net);
d2154 1
a2154 1
	printf ("error  \n");
d2156 1
a2156 1
	printf ("ok\n");
d2193 5
d2243 3
a2245 1
	    while ((n = read (flowcontrol_pipe[0], buf, 1) == 1))
d2254 10
a2263 2
	    if (n == 0)
		paused = 0;		/* other end died */
d2279 1
a2279 1
	    buf_output0 (&protocol, ".");
d2281 2
a2282 2
	    buf_output0 (&protocol, update_dir);
	buf_output0 (&protocol, "/\n");
d2284 2
a2285 2
    buf_output0 (&protocol, repository);
    buf_output0 (&protocol, "/");
d2397 1
a2397 1
	buf_output0 (&protocol,
d2399 1
a2399 1
	buf_send_counted (&protocol);
d2418 2
a2419 2
	buf_output0 (&protocol, entries_line);
	buf_output (&protocol, "\n", 1);
d2423 1
a2423 1
	buf_output0 (&protocol,
d2447 1
a2447 1
	if (stat (file, &sb) < 0)
d2456 1
a2456 1
	    buf_output0 (&protocol, "Mode ");
d2458 2
a2459 2
	    buf_output0 (&protocol, mode_string);
	    buf_output0 (&protocol, "\n");
d2464 1
a2464 1
    buf_output0 (&protocol, "Checked-in ");
d2466 2
a2467 2
    buf_output0 (&protocol, file);
    buf_output (&protocol, "\n", 1);
d2485 1
a2485 1
	buf_output0 (&protocol, "Remove-entry ");
d2487 2
a2488 2
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
d2496 1
a2496 1
    buf_send_counted (&protocol);
d2514 1
a2514 1
	buf_output0 (&protocol, "New-entry ");
d2516 2
a2517 2
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
d2521 1
a2521 1
    buf_send_counted (&protocol);
d2694 1
a2694 7
    CVSroot = malloc (strlen (arg) + 1);
    if (CVSroot == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (CVSroot, arg);
d2727 1
a2727 1
	    printf ("E Out of memory\n");
d2735 3
a2737 1
	    printf ("E Cannot create %s\n", tempdir);
d2743 1
a2743 1
	if (chdir (tempdir) < 0)
d2745 3
a2747 1
	    printf ("E Cannot change to directory %s\n", tempdir);
d2775 1
a2775 1
    buf_output0 (&protocol, "Copy-file ");
d2777 4
a2780 4
    buf_output0 (&protocol, file);
    buf_output0 (&protocol, "\n");
    buf_output0 (&protocol, newfile);
    buf_output0 (&protocol, "\n");
d2783 2
d2786 3
a2788 4
server_updated (file, update_dir, repository, updated, file_info, checksum)
    char *file;
    char *update_dir;
    char *repository;
a2792 2
    char *short_pathname;

a2795 6
    short_pathname = xmalloc (strlen (update_dir) + strlen (file) + 10);
    if (update_dir[0] == '\0')
	strcpy (short_pathname, file);
    else
	sprintf (short_pathname, "%s/%s", update_dir, file);

d2804 1
a2804 1
	if (stat (file, &sb) < 0)
d2812 1
a2812 2
		 * forget the whole thing.
		 */
d2817 1
a2817 1
	    error (1, errno, "reading %s", short_pathname);
d2834 1
a2834 1
	        buf_output0 (&protocol, "Checksum ");
d2838 1
a2838 1
		    buf_output0 (&protocol, buf);
d2840 1
a2840 1
		buf_append_char (&protocol, '\n');
d2845 13
a2857 1
	    buf_output0 (&protocol, "Updated ");
d2859 1
a2859 1
	    buf_output0 (&protocol, "Merged ");
d2861 1
a2861 1
	    buf_output0 (&protocol, "Patched ");
d2864 3
a2866 3
	output_dir (update_dir, repository);
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
d2881 2
a2882 2
	    buf_output0 (&protocol, mode_string);
	    buf_output0 (&protocol, "\n");
d2894 1
a2894 1
	    if (gzip_level
d2906 1
a2906 1
		fd = open (file, O_RDONLY | OPEN_BINARY, 0);
d2908 2
a2909 2
		    error (1, errno, "reading %s", short_pathname);
		fd = filter_through_gzip (fd, 1, gzip_level, &gzip_pid);
d2914 1
a2914 1
		    (*protocol.memory_error) (&protocol);
d2917 1
a2917 1
			   short_pathname);
d2919 1
a2919 1
		    error (1, errno, "reading %s", short_pathname);
d2926 1
a2926 1
		buf_output0 (&protocol, "z");
d2933 1
a2933 1
		f = fopen (file, "rb");
d2935 1
a2935 1
		    error (1, errno, "reading %s", short_pathname);
d2938 1
a2938 1
		    (*protocol.memory_error) (&protocol);
d2941 1
a2941 1
			   short_pathname);
d2943 1
a2943 1
		    error (1, errno, "reading %s", short_pathname);
d2948 1
a2948 1
	buf_output0 (&protocol, size_text);
d2950 1
a2950 1
	buf_append_data (&protocol, list, last);
d2964 1
a2964 1
	    unlink (file);
d2968 1
a2968 1
	if (strcmp (scratched_file, file) != 0)
d2972 1
a2972 1
		   file);
d2977 1
a2977 1
	    buf_output0 (&protocol, "Removed ");
d2979 4
a2982 4
	    buf_output0 (&protocol, "Remove-entry ");
	output_dir (update_dir, repository);
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
d2994 2
a2995 3
    buf_send_counted (&protocol);
  done:
    free (short_pathname);
d3008 1
a3008 1
    buf_output0 (&protocol, "Set-static-directory ");
d3010 2
a3011 2
    buf_output0 (&protocol, "\n");
    buf_send_counted (&protocol);
d3027 1
a3027 1
    buf_output0 (&protocol, "Clear-static-directory ");
d3029 2
a3030 2
    buf_output0 (&protocol, "\n");
    buf_send_counted (&protocol);
d3041 3
d3053 1
a3053 1
	buf_output0 (&protocol, "Clear-sticky ");
d3055 1
a3055 1
	buf_output0 (&protocol, "\n");
d3059 1
a3059 1
	buf_output0 (&protocol, "Set-sticky ");
d3061 1
a3061 1
	buf_output0 (&protocol, "\n");
d3064 2
a3065 2
	    buf_output0 (&protocol, "T");
	    buf_output0 (&protocol, tag);
d3069 2
a3070 2
	    buf_output0 (&protocol, "D");
	    buf_output0 (&protocol, date);
d3072 1
a3072 1
	buf_output0 (&protocol, "\n");
d3074 1
a3074 1
    buf_send_counted (&protocol);
d3101 1
a3101 1
    buf_output0 (&protocol, "Template ");
d3103 1
a3103 1
    buf_output0 (&protocol, "\n");
d3105 1
a3105 1
    fp = fopen (template, "rb");
d3117 1
a3117 1
    buf_output0 (&protocol, buf);
d3121 1
a3121 1
	buf_output (&protocol, buf, n);
d3154 18
a3171 1
    gzip_level = level;
d3209 2
a3210 1
	printf ("Module-expansion %s", mwhere);
d3213 2
a3214 1
	    printf ("/%s", mfile);
d3216 1
a3216 1
	printf ("\n");
d3219 1
a3219 1
      {
d3223 5
a3227 1
	  printf ("Module-expansion %s\n", dir);
d3229 11
a3239 3
	  for (i = 1; i < *pargc; ++i)
	    printf ("Module-expansion %s/%s\n", dir, argv[i]);
      }
d3278 1
a3278 1
	printf ("error  \n");
d3280 5
a3284 1
	printf ("ok\n");
d3295 1
a3295 1
	printf ("E \
d3302 1
a3302 1
	    printf ("Set-checkin-prog ");
d3305 1
a3305 1
	    printf ("Set-update-prog ");
d3308 4
a3311 1
    printf ("%s\n%s\n", dir, name);
d3319 1
a3319 1
    f = fopen (CVSADM_CIPROG, "w+");
d3348 1
a3348 1
    f = fopen (CVSADM_UPROG, "w+");
d3412 1
d3414 5
d3462 1
a3462 1
    printf ("Valid-requests");
d3464 1
d3466 10
a3475 2
	    printf (" %s", rq->name);
    printf ("\nok\n");
d3487 4
a3490 4
  int status;
  pid_t r = wait (&status);
  if (r == command_pid)
    command_pid_is_dead++;
d3499 26
a3524 3
    int len;
    char *cmd;
    char *temp_dir;
d3527 3
d3531 1
d3537 18
a3554 17
    if (command_pid > 0) {
      /* To avoid crashes on SunOS due to bugs in SunOS tmpfs
	 triggered by the use of rename() in RCS, wait for the
	 subprocess to die.  Unfortunately, this means draining output
	 while waiting for it to unblock the signal we sent it.  Yuck!  */
      int status;
      pid_t r;

      signal (SIGCHLD, wait_sig);
      if (sig)
	/* Perhaps SIGTERM would be more correct.  But the child
	   process will delay the SIGINT delivery until its own
	   children have exited.  */
	kill (command_pid, SIGINT);
      /* The caller may also have sent a signal to command_pid, so
	 always try waiting.  First, though, check and see if it's still
	 there....  */
d3556 16
a3571 31
      r = waitpid (command_pid, &status, WNOHANG);
      if (r == 0)
	;
      else if (r == command_pid)
	command_pid_is_dead++;
      else if (r == -1)
	switch (errno) {
	case ECHILD:
	  command_pid_is_dead++;
	  break;
	case EINTR:
	  goto do_waitpid;
	}
      else
	/* waitpid should always return one of the above values */
	abort ();
      while (!command_pid_is_dead) {
	struct timeval timeout;
	struct fd_set_wrapper readfds;
	char buf[100];
	int i;

	/* Use a non-zero timeout to avoid eating up CPU cycles.  */
	timeout.tv_sec = 2;
	timeout.tv_usec = 0;
	readfds = command_fds_to_drain;
	switch (select (max_command_fd + 1, &readfds.fds,
			(fd_set *)0, (fd_set *)0,
			&timeout)) {
	case -1:
	  if (errno != EINTR)
d3573 14
a3586 5
	case 0:
	  /* timeout */
	  break;
	case 1:
	  for (i = 0; i <= max_command_fd; i++)
d3588 18
a3605 5
	      if (!FD_ISSET (i, &readfds.fds))
		continue;
	      /* this fd is non-blocking */
	      while (read (i, buf, sizeof (buf)) >= 1)
		;
a3606 3
	  break;
	default:
	  abort ();
a3607 1
      }
d3611 17
a3627 17
    /* This might be set by the user in ~/.bashrc, ~/.cshrc, etc.  */
    temp_dir = getenv ("TMPDIR");
    if (temp_dir == NULL || temp_dir[0] == '\0')
        temp_dir = "/tmp";
    chdir(temp_dir);

    len = strlen (server_temp_dir) + 80;
    cmd = malloc (len);
    if (cmd == NULL)
    {
	printf ("E Cannot delete %s on server; out of memory\n",
		server_temp_dir);
	return;
    }
    sprintf (cmd, "rm -rf %s", server_temp_dir);
    system (cmd);
    free (cmd);
d3650 7
d3698 39
a3736 4
	/* This might be set by the user in ~/.bashrc, ~/.cshrc, etc.  */
	char *temp_dir = getenv ("TMPDIR");
	if (temp_dir == NULL || temp_dir[0] == '\0')
	    temp_dir = "/tmp";
a3737 3
	server_temp_dir = malloc (strlen (temp_dir) + 80);
	if (server_temp_dir == NULL)
	{
d3739 3
a3741 2
	     * Strictly speaking, we're not supposed to output anything
	     * now.  But we're about to exit(), give it a try.
d3743 1
a3743 5
	    printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");
	    exit (EXIT_FAILURE);
	}
	strcpy (server_temp_dir, temp_dir);
d3745 2
a3746 4
	/* Remove a trailing slash from TMPDIR if present.  */
	p = server_temp_dir + strlen (server_temp_dir) - 1;
	if (*p == '/')
	    *p = '\0';
d3748 2
a3749 9
	/*
	 * I wanted to use cvs-serv/PID, but then you have to worry about
	 * the permissions on the cvs-serv directory being right.  So
	 * use cvs-servPID.
	 */
	strcat (server_temp_dir, "/cvs-serv");

	p = server_temp_dir + strlen (server_temp_dir);
	sprintf (p, "%ld", (long) getpid ());
d3776 9
a3784 7
    argument_vector[0] = "Dummy argument 0";

    buf_to_net.data = buf_to_net.last = NULL;
    buf_to_net.fd = STDOUT_FILENO;
    buf_to_net.output = 1;
    buf_to_net.nonblocking = 0;
    buf_to_net.memory_error = outbuf_memory_error;
d3792 1
d3794 2
a3795 4
	orig_cmd = cmd = read_line (stdin);
	if (cmd == NULL)
	    break;
	if (cmd == NO_MEM_ERROR)
d3797 1
a3797 1
	    printf ("E Fatal server error, aborting.\n\
d3801 4
d3816 76
a3891 13
		     * command.  e.g. the command is "cooperate" but we matched
		     * "co".
		     */
		    continue;
		(*rq->func) (cmd);
		break;
	    }
	if (rq->name == NULL)
	{
	    if (!print_pending_error ())
		printf ("error  unrecognized request `%s'\n", cmd);
	}
	free (orig_cmd);
d3893 1
a3893 2
    server_cleanup (0);
    return 0;
d3895 1
a3896 1

a3900 13
/* This was test code, which we may need again. */
#if 0
  /* If we were invoked this way, then stdin comes from the
     client and stdout/stderr writes to it. */
  int c;
  while ((c = getc (stdin)) != EOF && c != '*')
    {
      printf ("%c", toupper (c));
      fflush (stdout);
    }
  exit (0);
#endif /* 1/0 */

d3907 1
a3907 1
int
d3914 2
a3915 1
    char *linebuf;
d3929 2
a3930 2
  
    fp = fopen (filename, "r");
d3940 1
a3940 1
    while (1)
a3941 11
	linebuf = read_line(fp);
	if (linebuf == NULL)
        {
            free (linebuf);
	    break;
        }
	if (linebuf == NO_MEM_ERROR)
	{
            error (0, errno, "out of memory");
	    break;
	}
d3949 1
a3949 1
        
d3983 1
a3983 1
char *
d4005 10
a4015 1
	char *found_passwd;
d4018 6
d4025 1
a4025 1
        {
d4030 1
a4030 2
	found_passwd = pw->pw_passwd;

a4046 1

d4051 1
a4051 1
authenticate_connection ()
d4053 103
a4155 112
  char tmp[PATH_MAX];
  char repository[PATH_MAX];
  char username[PATH_MAX];
  char password[PATH_MAX];
  char *host_user;
  char *descrambled_password;
  struct passwd *pw;
  int verify_and_exit = 0;

  /* The Authentication Protocol.  Client sends:
   *
   *   BEGIN AUTH REQUEST\n
   *   <REPOSITORY>\n
   *   <USERNAME>\n
   *   <PASSWORD>\n
   *   END AUTH REQUEST\n
   *
   * Server uses above information to authenticate, then sends
   *
   *   I LOVE YOU\n
   *
   * if it grants access, else
   *
   *   I HATE YOU\n
   *
   * if it denies access (and it exits if denying).
   *
   * When the client is "cvs login", the user does not desire actual
   * repository access, but would like to confirm the password with
   * the server.  In this case, the start and stop strings are
   *
   *   BEGIN VERIFICATION REQUEST\n
   *
   *            and
   *
   *   END VERIFICATION REQUEST\n
   *
   * On a verification request, the server's responses are the same
   * (with the obvious semantics), but it exits immediately after
   * sending the response in both cases.
   *
   * Why is the repository sent?  Well, note that the actual
   * client/server protocol can't start up until authentication is
   * successful.  But in order to perform authentication, the server
   * needs to look up the password in the special CVS passwd file,
   * before trying /etc/passwd.  So the client transmits the
   * repository as part of the "authentication protocol".  The
   * repository will be redundantly retransmitted later, but that's no
   * big deal.
   */

  /* Since we're in the server parent process, error should use the
     protocol to report error messages.  */
  error_use_protocol = 1;

  /* Make sure the protocol starts off on the right foot... */
  fgets (tmp, PATH_MAX, stdin);
  if (strcmp (tmp, "BEGIN VERIFICATION REQUEST\n") == 0)
    verify_and_exit = 1;
  else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") != 0)
    error (1, 0, "bad auth protocol start: %s", tmp);
    
  /* Get the three important pieces of information in order. */
  fgets (repository, PATH_MAX, stdin);
  fgets (username, PATH_MAX, stdin);
  fgets (password, PATH_MAX, stdin);

  /* Make them pure. */ 
  strip_trailing_newlines (repository);
  strip_trailing_newlines (username);
  strip_trailing_newlines (password);

  /* ... and make sure the protocol ends on the right foot. */
  fgets (tmp, PATH_MAX, stdin);
  if (strcmp (tmp,
              verify_and_exit ?
              "END VERIFICATION REQUEST\n" : "END AUTH REQUEST\n")
           != 0)
    {
      error (1, 0, "bad auth protocol end: %s", tmp);
    }

  /* We need the real cleartext before we hash it. */
  descrambled_password = descramble (password);
  host_user = check_password (username, descrambled_password, repository);
  if (host_user)
    {
      printf ("I LOVE YOU\n");
      fflush (stdout);
      memset (descrambled_password, 0, strlen (descrambled_password));
      free (descrambled_password);
    }
  else
    {
      printf ("I HATE YOU\n");
      fflush (stdout);
      memset (descrambled_password, 0, strlen (descrambled_password));
      free (descrambled_password);
      exit (EXIT_FAILURE);
    }
  
  /* Don't go any farther if we're just responding to "cvs login". */
  if (verify_and_exit)
    exit (0);

  /* Switch to run as this user. */
  pw = getpwnam (host_user);
  if (pw == NULL)
    {
      error (1, 0,
             "fatal error, aborting.\nerror 0 %s: no such user\n",
             username);
a4156 4
  
#if HAVE_INITGROUPS
  initgroups (pw->pw_name, pw->pw_gid);
#endif /* HAVE_INITGROUPS */
d4158 6
a4163 21
  setgid (pw->pw_gid);
  setuid (pw->pw_uid);
  /* Inhibit access by randoms.  Don't want people randomly
     changing our temporary tree before we check things in.  */
  umask (077);
  
#if HAVE_PUTENV
  /* Set LOGNAME and USER in the environment, in case they are
     already set to something else.  */
  {
    char *env;
    
    env = xmalloc (sizeof "LOGNAME=" + strlen (username));
    (void) sprintf (env, "LOGNAME=%s", username);
    (void) putenv (env);
    
    env = xmalloc (sizeof "USER=" + strlen (username));
    (void) sprintf (env, "USER=%s", username);
    (void) putenv (env);
  }
#endif /* HAVE_PUTENV */
d4169 62
d4233 393
d4627 1
a4627 2
   the first '\0' byte.  Should not be called from the server parent process
   (yet at least, in the future it might be extended so that works).  */
d4631 1
a4631 1
    char *str;
d4636 1
a4637 7
	/* Eventually we'll probably want to make it so this case works,
	   but for now, callers who want to output something with
	   error_use_protocol in effect can just printf the "M foo"
	   themselves.  */
	abort ();
#ifdef SERVER_SUPPORT
    if (server_active)
d4639 8
a4646 3
	buf_output (&saved_output, str, len);
	buf_copy_lines (&protocol, &saved_output, 'M');
	buf_send_counted (&protocol);
d4653 1
a4653 1
	char *p = str;
d4657 1
a4657 1
	    written = fwrite (str, 1, to_write, stdout);
d4670 1
a4670 1
    char *str;
d4675 1
a4676 7
	/* Eventually we'll probably want to make it so this case works,
	   but for now, callers who want to output something with
	   error_use_protocol in effect can just printf the "E foo"
	   themselves.  */
	abort ();
#ifdef SERVER_SUPPORT
    if (server_active)
d4678 8
a4685 3
	buf_output (&saved_outerr, str, len);
	buf_copy_lines (&protocol, &saved_outerr, 'E');
	buf_send_counted (&protocol);
d4692 1
a4692 1
	char *p = str;
d4696 1
a4696 1
	    written = fwrite (str, 1, to_write, stderr);
d4703 23
@


1.8
log
@server must parseopts() after getting Root
@
text
@d2760 1
d2792 1
a2792 1
	    while (read (flowcontrol_pipe[0], buf, 1) == 1)
d2801 2
@


1.7
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d334 1
@


1.6
log
@Integrate local changes to CVS
@
text
@d30 1
d32 2
a33 1
#endif
d275 1
a275 1
	    exit (1);
d681 2
a682 1
	    error (1, errno, "waiting for gunzip process %d", gzip_pid);
d2191 9
d2241 1
a2241 1
    exit (1);
d3222 26
d3423 4
d3439 1
a3439 1
		fd = open (file, O_RDONLY, 0);
d3443 1
a3443 1
		f = fdopen (fd, "r");
d3454 2
a3455 1
		    error (1, errno, "waiting for gzip process %d", gzip_pid);
d3466 1
a3466 1
		f = fopen (file, "r");
d3607 6
d3614 63
d3901 1
d3931 2
d4128 1
a4128 1
	    exit (1);
d4152 1
a4152 1
	    exit (1);
d4169 1
a4169 1
	sprintf (p, "%d", getpid ());
d4192 1
a4192 1
	exit (1);
d4361 1
a4361 1
     char *username, *password, *repository;
d4363 9
a4371 2
  int rc;
  char *host_user;
d4373 5
a4377 11
  /* First we see if this user has a password in the CVS-specific
     password file.  If so, that's enough to authenticate with.  If
     not, we'll check /etc/passwd. */

  rc = check_repository_password (username, password, repository, &host_user);

  if (rc == 1)
    return host_user;
  else if (rc == 2)
    return 0;
  else if (rc == 0)
d4379 1
a4379 1
      /* No cvs password found, so try /etc/passwd. */
d4381 2
a4382 2
      struct passwd *pw;
      char *found_passwd;
d4384 2
a4385 2
      pw = getpwnam (username);
      if (pw == NULL)
d4387 13
a4399 13
          printf ("E Fatal error, aborting.\n"
                  "error 0 %s: no such user\n", username);
          exit (1);
        }
      found_passwd = pw->pw_passwd;
      
      if (found_passwd && *found_passwd)
        return (! strcmp (found_passwd, crypt (password, found_passwd))) ?
          username : NULL;
      else if (password && *password)
        return username;
      else
        return NULL;
d4401 1
a4401 1
  else
d4403 3
a4405 3
      /* Something strange happened.  We don't know what it was, but
         we certainly won't grant authorization. */
      return NULL;
d4514 1
a4514 1
      exit (1);
d4530 1
d4532 2
@


1.5
log
@Integrate local changes
@
text
@d28 5
d1244 9
a1432 3
    if (! buf->output)
	abort ();

d2191 7
d2349 7
d3792 1
d4137 2
d4159 2
a4160 2
check_repository_password (username, password, repository)
     char *username, *password, *repository;
d4166 2
a4167 2
    int ch;
    int found_it = 0, namelen, linelen;
a4179 13
    /* 32 is enough to cover the hashed password.  I don't know if this
     * counts as an arbitrary limit or not; it really depends on how
     * standardized crypt() is.
     * Answer: FreeBSD and Debian have played with the idea of making
     * crypt() do MD5 which has a longer value; it would better not to
     * make assumptions.  So yes, FIXME: arbitrary limit.
     */

    /*            USERNAME        :   PASSWD   \n      \0     */
    linelen = strlen (username) + 1  +  32  +   1   +   1;
    linebuf = xmalloc (linelen);
    memset (linebuf, 0, linelen);

d4190 1
a4190 1
    while (fgets (linebuf, linelen, fp))
d4192 11
d4209 2
a4210 6
	else if (! strchr (linebuf, '\n'))
	{
	    while ((ch = getc (fp)) != '\n')
		if (ch == EOF)
		    break;
	}
d4224 2
a4225 1

d4232 2
d4235 1
d4243 2
a4244 2
/* Return 1 if password matches, else 0. */
int
d4249 1
d4255 1
a4255 1
  rc = check_repository_password (username, password, repository);
d4258 1
a4258 1
    return 1;
d4278 2
a4279 1
        return (! strcmp (found_passwd, crypt (password, found_passwd)));
d4281 1
a4281 1
        return 1;
d4283 1
a4283 1
        return 0;
d4289 1
a4289 1
      return 0;
a4299 1
  int len;
d4304 1
a4305 1
  char server_user[PATH_MAX];
d4384 2
a4385 2

  if (check_password (username, descrambled_password, repository))
d4406 1
a4406 1
  pw = getpwnam (username);
d4443 81
@


1.4
log
@if CVSREADONLYFS, access to the history file is irrelevant
@
text
@d1 1
d3 3
a45 1
void server_cleanup PROTO((int sig));
d231 2
d289 1
a289 1
    if (access (path, R_OK | X_OK))
d299 1
a299 1
    if (readonlyfs == 0 && isfile (path) && access (path, R_OK | W_OK))
d357 2
a363 1
    char *dirname;
d371 5
a375 2
    dirname = malloc (strlen (server_temp_dir) + strlen (dir) + 40);
    if (dirname == NULL)
d381 3
a383 3
    strcpy (dirname, server_temp_dir);
    strcat (dirname, "/");
    strcat (dirname, dir);
d385 1
a385 1
    status = mkdir_p (dirname);	
d390 2
a391 2
	pending_error_text = malloc (80 + strlen(dirname));
	sprintf(pending_error_text, "E cannot mkdir %s", dirname);
d394 1
a394 1
    if (chdir (dirname) < 0)
d397 2
a398 2
	pending_error_text = malloc (80 + strlen(dirname));
	sprintf(pending_error_text, "E cannot change to %s", dirname);
d445 1
a445 2
    free (dirname);
}    
d949 200
d1295 11
a1315 1
static int buf_len PROTO((struct buffer *));
d1328 5
d1391 20
a1502 23
 * Count how many bytes are in the buffer
 */

static int
buf_len (buf)
     struct buffer *buf;
{
    struct buffer_data *data;
    int count = 0;

    if (! buf->output)
	abort ();

    for (data = buf->data; data; data = data->next)
    {
	count += data->size;
    }
	
    return (count);
}


/*
d1574 1
d1581 15
d2135 43
d2226 4
d2267 2
d2292 9
d2340 3
a2364 1
	struct buffer outbuf;
d2371 3
a2397 6
	outbuf.data = outbuf.last = NULL;
	outbuf.fd = STDOUT_FILENO;
	outbuf.output = 1;
	outbuf.nonblocking = 0;
	outbuf.memory_error = outbuf_memory_error;

d2416 1
a2416 1
	set_nonblock (&outbuf);
d2442 9
d2465 19
d2487 14
a2500 15
	    if (! buf_empty_p (&outbuf))
	      FD_SET (STDOUT_FILENO, &writefds);
	    if ( buf_len (&outbuf) < 2*1024*1024) {
		if (stdout_pipe[0] >= 0)
		{
		    FD_SET (stdout_pipe[0], &readfds);
		}
		if (stderr_pipe[0] >= 0)
		{
		    FD_SET (stderr_pipe[0], &readfds);
		}
		if (protocol_pipe[0] >= 0)
		{
		    FD_SET (protocol_pipe[0], &readfds);
		}
d2520 1
a2520 1
		buf_send_output (&outbuf);
d2530 1
a2530 1
		buf_copy_lines (&outbuf, &stdoutbuf, 'M');
d2541 1
a2541 1
		buf_send_output (&outbuf);
d2551 1
a2551 1
		buf_copy_lines (&outbuf, &stderrbuf, 'E');
d2562 1
a2562 1
		buf_send_output (&outbuf);
d2581 2
a2582 1
		  count_needed = buf_copy_counted (&outbuf, &protocol_inbuf);
d2593 1
a2593 1
		buf_send_output (&outbuf);
d2605 1
a2605 1
	    buf_copy_lines (&outbuf, &stdoutbuf, 'M');
d2610 1
a2610 1
	    buf_copy_lines (&outbuf, &stderrbuf, 'E');
d2613 1
a2613 1
	    buf_output0 (&outbuf,
d2664 2
a2665 2
	set_block (&outbuf);
	buf_send_output (&outbuf);
d2712 55
d2816 3
d2824 2
a2825 2
			name, version, timestamp, options, tag,
			date, conflict);
a2827 3
    if (options == NULL)
	options = "";

d2934 35
d2992 1
a2992 5
	buf_output0 (&protocol, "Checked-in ");
	output_dir (update_dir, repository);
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
	new_entries_line ();
d3007 1
a3007 1
	buf_output0 (&protocol, "Checked-in ");
d3013 4
a3018 4
    output_dir (update_dir, repository);
    buf_output0 (&protocol, file);
    buf_output (&protocol, "\n", 1);
    new_entries_line ();
d3113 73
d3287 1
a3287 1
	    if (errno == ENOENT)
d3585 8
a3592 1
      printf ("Module-expansion %s\n", mwhere);
d3762 2
d3786 7
d3815 1
d3829 1
d4057 6
d4064 1
d4108 306
d4415 1
@


1.3
log
@stall all three server:server pipes, and 2MB instead of 256K
@
text
@d294 1
a294 1
    if (isfile (path) && access (path, R_OK | W_OK))
@


1.2
log
@allow at most 256K of data to be queued
@
text
@d2168 13
a2180 11
	    if (stdout_pipe[0] >= 0 && buf_len (&outbuf) < 256*1024)
	    {
		FD_SET (stdout_pipe[0], &readfds);
	    }
	    if (stderr_pipe[0] >= 0)
	    {
		FD_SET (stderr_pipe[0], &readfds);
	    }
	    if (protocol_pipe[0] >= 0)
	    {
		FD_SET (protocol_pipe[0], &readfds);
@


1.1
log
@Initial revision
@
text
@d1097 1
d1260 23
d2168 1
a2168 1
	    if (stdout_pipe[0] >= 0)
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a0 1
#include <assert.h>
a1 3
#include "watch.h"
#include "edit.h"
#include "fileattr.h"
d42 1
a227 2
    /* NOTREACHED */
    return 0;
d284 1
a284 1
    if (!isaccessible (path, R_OK | X_OK))
d294 1
a294 1
    if (isfile (path) && !isaccessible (path, R_OK | W_OK))
a351 2
static char *dir_name;

d357 1
d365 2
a366 5
    if (dir_name != NULL)
	free (dir_name);

    dir_name = malloc (strlen (server_temp_dir) + strlen (dir) + 40);
    if (dir_name == NULL)
d372 3
a374 3
    strcpy (dir_name, server_temp_dir);
    strcat (dir_name, "/");
    strcat (dir_name, dir);
d376 1
a376 1
    status = mkdir_p (dir_name);	
d381 2
a382 2
	pending_error_text = malloc (80 + strlen(dir_name));
	sprintf(pending_error_text, "E cannot mkdir %s", dir_name);
d385 1
a385 1
    if (chdir (dir_name) < 0)
d388 2
a389 2
	pending_error_text = malloc (80 + strlen(dir_name));
	sprintf(pending_error_text, "E cannot change to %s", dir_name);
d436 2
a437 1
}
a940 200
struct notify_note {
    /* Directory in which this notification happens.  malloc'd*/
    char *dir;

    /* malloc'd.  */
    char *filename;

    /* The following three all in one malloc'd block, pointed to by TYPE.
       Each '\0' terminated.  */
    /* "E" or "U".  */
    char *type;
    /* time+host+dir */
    char *val;
    char *watches;

    struct notify_note *next;
};

static struct notify_note *notify_list;
/* Used while building list, to point to the last node that already exists.  */
static struct notify_note *last_node;

static void serve_notify PROTO ((char *));

static void
serve_notify (arg)
    char *arg;
{
    struct notify_note *new;
    char *data;

    if (error_pending ()) return;

    new = (struct notify_note *) malloc (sizeof (struct notify_note));
    if (new == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    if (dir_name == NULL)
	goto error;
    new->dir = malloc (strlen (dir_name) + 1);
    if (new->dir == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (new->dir, dir_name);
    new->filename = malloc (strlen (arg) + 1);
    if (new->filename == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (new->filename, arg);

    data = read_line (stdin);
    if (data == NULL)
    {
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text)
	{
	    if (feof (stdin))
		sprintf (pending_error_text,
			 "E end of file reading mode for %s", arg);
	    else
	    {
		sprintf (pending_error_text,
			 "E error reading mode for %s", arg);
		pending_error = errno;
	    }
	}
	else
	    pending_error = ENOMEM;
    }
    else if (data == NO_MEM_ERROR)
    {
	pending_error = ENOMEM;
    }
    else
    {
	char *cp;

	new->type = data;
	if (data[1] != '\t')
	    goto error;
	data[1] = '\0';
	cp = data + 2;
	new->val = cp;
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '+';
	cp = strchr (cp, '\t');
	if (cp == NULL)
	    goto error;
	*cp++ = '\0';
	new->watches = cp;
	/* If there is another tab, ignore everything after it,
	   for future expansion.  */
	cp = strchr (cp, '\t');
	if (cp != NULL)
	{
	    *cp = '\0';
	}

	new->next = NULL;

	if (last_node == NULL)
	{
	    notify_list = new;
	}
	else
	    last_node->next = new;
	last_node = new;
    }
    return;
  error:
    pending_error_text = malloc (40);
    if (pending_error_text)
	strcpy (pending_error_text,
		"E Protocol error; misformed Notify request");
    pending_error = 0;
    return;
}

/* Process all the Notify requests that we have stored up.  Returns 0
   if successful, if not prints error message (via error()) and
   returns negative value.  */
static int
server_notify ()
{
    struct notify_note *p;
    char *repos;
    List *list;
    Node *node;
    int status;

    while (notify_list != NULL)
    {
	if (chdir (notify_list->dir) < 0)
	{
	    error (0, errno, "cannot change to %s", notify_list->dir);
	    return -1;
	}
	repos = Name_Repository (NULL, NULL);

	/* Now writelock.  */
	list = getlist ();
	node = getnode ();
	node->type = LOCK;
	node->key = xstrdup (repos);
	status = addnode (list, node);
	assert (status == 0);
	Writer_Lock (list);

	fileattr_startdir (repos);

	notify_do (*notify_list->type, notify_list->filename, getcaller(),
		   notify_list->val, notify_list->watches, repos);

	printf ("Notified ");
	if (use_dir_and_repos)
	{
	    char *dir = notify_list->dir + strlen (server_temp_dir) + 1;
	    if (dir[0] == '\0')
		fputs (".", stdout);
	    else
		fputs (dir, stdout);
	    fputs ("/\n", stdout);
	}
	fputs (repos, stdout);
	fputs ("/", stdout);
	fputs (notify_list->filename, stdout);
	fputs ("\n", stdout);

	p = notify_list->next;
	free (notify_list->filename);
	free (notify_list->dir);
	free (notify_list->type);
	free (notify_list);
	notify_list = p;

	fileattr_write ();
	fileattr_free ();

	/* Remove the writelock.  */
	Lock_Cleanup ();
	dellist (&list);
    }
    /* do_cvs_command writes to stdout via write(), not stdio, so better
       flush out the buffer.  */
    fflush (stdout);
    return 0;
}

a1086 11
#ifdef SERVER_FLOWCONTROL
/* The maximum we'll queue to the remote client before blocking.  */
# ifndef SERVER_HI_WATER
#  define SERVER_HI_WATER (2 * 1024 * 1024)
# endif /* SERVER_HI_WATER */
/* When the buffer drops to this, we restart the child */
# ifndef SERVER_LO_WATER
#  define SERVER_LO_WATER (1 * 1024 * 1024)
# endif /* SERVER_LO_WATER */
#endif /* SERVER_FLOWCONTROL */

a1108 5
#ifdef SERVER_FLOWCONTROL
static int buf_count_mem PROTO((struct buffer *));
static int set_nonblock_fd PROTO((int));
#endif /* SERVER_FLOWCONTROL */

a1166 20
#ifdef SERVER_FLOWCONTROL
/*
 * Count how much data is stored in the buffer..
 * Note that each buffer is a malloc'ed chunk BUFFER_DATA_SIZE.
 */

static int
buf_count_mem (buf)
    struct buffer *buf;
{
    struct buffer_data *data;
    int mem = 0;

    for (data = buf->data; data != NULL; data = data->next)
	mem += BUFFER_DATA_SIZE;

    return mem;
}
#endif /* SERVER_FLOWCONTROL */

a1329 1
#ifdef SERVER_FLOWCONTROL
a1335 15
set_nonblock_fd (fd)
     int fd;
{
    int flags;

    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    return 0;
}
#endif /* SERVER_FLOWCONTROL */

static int
a1874 43
/* While processing requests, this buffer accumulates data to be sent to
   the client, and then once we are in do_cvs_command, we use it
   for all the data to be sent.  */
static struct buffer buf_to_net;

static void serve_questionable PROTO((char *));

static void
serve_questionable (arg)
    char *arg;
{
    static int initted;

    if (!initted)
    {
	/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server,
	   and CVSIGNORE on server.  */
	ign_setup ();
	initted = 1;
    }

    if (dir_name == NULL)
    {
	buf_output0 (&buf_to_net, "E Protocol error: 'Directory' missing");
	return;
    }

    if (!ign_name (arg))
    {
	char *update_dir;

	buf_output (&buf_to_net, "M ? ", 4);
	update_dir = dir_name + strlen (server_temp_dir) + 1;
	if (!(update_dir[0] == '.' && update_dir[1] == '\0'))
	{
	    buf_output0 (&buf_to_net, update_dir);
	    buf_output (&buf_to_net, "/", 1);
	}
	buf_output0 (&buf_to_net, arg);
	buf_output (&buf_to_net, "\n", 1);
    }
}

a1922 4
#ifdef SERVER_FLOWCONTROL
static int flowcontrol_pipe[2];
#endif /* SERVER_FLOWCONTROL */

a1959 2
    (void) server_notify ();

a1982 9
#ifdef SERVER_FLOWCONTROL
    if (pipe (flowcontrol_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    set_nonblock_fd (flowcontrol_pipe[0]);
    set_nonblock_fd (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */
a2021 3
#ifdef SERVER_FLOWCONTROL
	close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */
d2044 1
a2050 3
#ifdef SERVER_FLOWCONTROL
	int have_flowcontrolled = 0;
#endif /* SERVER_FLOWCONTROL */
d2075 6
d2099 1
a2099 1
	set_nonblock (&buf_to_net);
a2124 9
#ifdef SERVER_FLOWCONTROL
	if (close (flowcontrol_pipe[0]) < 0)
	{
	    print_error (errno);
	    goto error_exit;
	}
	flowcontrol_pipe[0] = -1;
#endif /* SERVER_FLOWCONTROL */

a2138 19
#ifdef SERVER_FLOWCONTROL
	    int bufmemsize;

	    /*
	     * See if we are swamping the remote client and filling our VM.
	     * Tell child to hold off if we do.
	     */
	    bufmemsize = buf_count_mem (&buf_to_net);
	    if (!have_flowcontrolled && (bufmemsize > SERVER_HI_WATER))
	    {
		if (write(flowcontrol_pipe[1], "S", 1) == 1)
		    have_flowcontrolled = 1;
	    }
	    else if (have_flowcontrolled && (bufmemsize < SERVER_LO_WATER))
	    {
		if (write(flowcontrol_pipe[1], "G", 1) == 1)
		    have_flowcontrolled = 0;
	    }
#endif /* SERVER_FLOWCONTROL */
d2142 2
a2143 3
	    if (! buf_empty_p (&buf_to_net))
	        FD_SET (STDOUT_FILENO, &writefds);

d2174 1
a2174 1
		buf_send_output (&buf_to_net);
d2184 1
a2184 1
		buf_copy_lines (&buf_to_net, &stdoutbuf, 'M');
d2195 1
a2195 1
		buf_send_output (&buf_to_net);
d2205 1
a2205 1
		buf_copy_lines (&buf_to_net, &stderrbuf, 'E');
d2216 1
a2216 1
		buf_send_output (&buf_to_net);
d2235 1
a2235 2
		    count_needed = buf_copy_counted (&buf_to_net,
						     &protocol_inbuf);
d2246 1
a2246 1
		buf_send_output (&buf_to_net);
d2258 1
a2258 1
	    buf_copy_lines (&buf_to_net, &stdoutbuf, 'M');
d2263 1
a2263 1
	    buf_copy_lines (&buf_to_net, &stderrbuf, 'E');
d2266 1
a2266 1
	    buf_output0 (&buf_to_net,
d2317 2
a2318 2
	set_block (&buf_to_net);
	buf_send_output (&buf_to_net);
a2364 55
#ifdef SERVER_FLOWCONTROL
/*
 * Called by the child at convenient points in the server's execution for
 * the server child to block.. ie: when it has no locks active.
 */
void
server_pause_check()
{
    int paused = 0;
    char buf[1];

    while (read (flowcontrol_pipe[0], buf, 1) == 1)
    {
	if (*buf == 'S')	/* Stop */
	    paused = 1;
	else if (*buf == 'G')	/* Go */
	    paused = 0;
	else
	    return;		/* ??? */
    }
    while (paused) {
	int numfds, numtocheck;
	fd_set fds;

	FD_ZERO (&fds);
	FD_SET (flowcontrol_pipe[0], &fds);
	numtocheck = flowcontrol_pipe[0] + 1;
	
	do {
	    numfds = select (numtocheck, &fds, (fd_set *)0,
			     (fd_set *)0, (struct timeval *)NULL);
	    if (numfds < 0
		&& errno != EINTR)
	    {
		print_error (errno);
		return;
	    }
	} while (numfds < 0);
	    
	if (FD_ISSET (flowcontrol_pipe[0], &fds))
	{
	    while (read (flowcontrol_pipe[0], buf, 1) == 1)
	    {
		if (*buf == 'S')	/* Stop */
		    paused = 1;
		else if (*buf == 'G')	/* Go */
		    paused = 0;
		else
		    return;		/* ??? */
	    }
	}
    }
}
#endif /* SERVER_FLOWCONTROL */

a2413 3
    if (options == NULL)
	options = "";

d2419 2
a2420 2
			name, version, timestamp, options, tag ? tag : "",
			date ? date : "", conflict ? conflict : "");
d2423 3
a2531 35
static void
checked_in_response (file, update_dir, repository)
    char *file;
    char *update_dir;
    char *repository;
{
    if (supported_response ("Mode"))
    {
	struct stat sb;
	char *mode_string;

	if (stat (file, &sb) < 0)
	{
	    /* Not clear to me why the file would fail to exist, but it
	       was happening somewhere in the testsuite.  */
	    if (!existence_error (errno))
		error (0, errno, "cannot stat %s", file);
	}
	else
	{
	    buf_output0 (&protocol, "Mode ");
	    mode_string = mode_to_string (sb.st_mode);
	    buf_output0 (&protocol, mode_string);
	    buf_output0 (&protocol, "\n");
	    free (mode_string);
	}
    }

    buf_output0 (&protocol, "Checked-in ");
    output_dir (update_dir, repository);
    buf_output0 (&protocol, file);
    buf_output (&protocol, "\n", 1);
    new_entries_line ();
}

d2555 5
a2559 1
	checked_in_response (file, update_dir, repository);
d2574 1
a2574 1
	checked_in_response (file, update_dir, repository);
a2579 4
	output_dir (update_dir, repository);
	buf_output0 (&protocol, file);
	buf_output (&protocol, "\n", 1);
	new_entries_line ();
d2582 4
a2679 73
static void serve_watch_on PROTO ((char *));

static void
serve_watch_on (arg)
    char *arg;
{
    do_cvs_command (watch_on);
}

static void serve_watch_off PROTO ((char *));

static void
serve_watch_off (arg)
    char *arg;
{
    do_cvs_command (watch_off);
}

static void serve_watch_add PROTO ((char *));

static void
serve_watch_add (arg)
    char *arg;
{
    do_cvs_command (watch_add);
}

static void serve_watch_remove PROTO ((char *));

static void
serve_watch_remove (arg)
    char *arg;
{
    do_cvs_command (watch_remove);
}

static void serve_watchers PROTO ((char *));

static void
serve_watchers (arg)
    char *arg;
{
    do_cvs_command (watchers);
}

static void serve_editors PROTO ((char *));

static void
serve_editors (arg)
    char *arg;
{
    do_cvs_command (editors);
}

static int noop PROTO ((int, char **));

static int
noop (argc, argv)
    int argc;
    char **argv;
{
    return 0;
}

static void serve_noop PROTO ((char *));

static void
serve_noop (arg)
    char *arg;
{
    do_cvs_command (noop);
}

d2781 1
a2781 1
	    if (existence_error (errno))
d3079 1
a3079 8
    {
	printf ("Module-expansion %s", mwhere);
	if (mfile != NULL)
	{
	    printf ("/%s", mfile);
	}
	printf ("\n");
    }
a3248 2
  REQ_LINE("Notify", serve_notify, rq_optional),
  REQ_LINE("Questionable", serve_questionable, rq_optional),
a3270 7
  REQ_LINE("watch-on", serve_watch_on, rq_optional),
  REQ_LINE("watch-off", serve_watch_off, rq_optional),
  REQ_LINE("watch-add", serve_watch_add, rq_optional),
  REQ_LINE("watch-remove", serve_watch_remove, rq_optional),
  REQ_LINE("watchers", serve_watchers, rq_optional),
  REQ_LINE("editors", serve_editors, rq_optional),
  REQ_LINE("noop", serve_noop, rq_optional),
a3292 1
#ifdef sun
a3305 1
#endif
a3532 6
    buf_to_net.data = buf_to_net.last = NULL;
    buf_to_net.fd = STDOUT_FILENO;
    buf_to_net.output = 1;
    buf_to_net.nonblocking = 0;
    buf_to_net.memory_error = outbuf_memory_error;

a3533 1

a3576 306

#ifdef AUTH_SERVER_SUPPORT

/* This was test code, which we may need again. */
#if 0
  /* If we were invoked this way, then stdin comes from the
     client and stdout/stderr writes to it. */
  int c;
  while ((c = getc (stdin)) != EOF && c != '*')
    {
      printf ("%c", toupper (c));
      fflush (stdout);
    }
  exit (0);
#endif /* 1/0 */


/* 
 * 0 means no entry found for this user.
 * 1 means entry found and password matches.
 * 2 means entry found, but password does not match.
 */
int
check_repository_password (username, password, repository)
     char *username, *password, *repository;
{
    int retval = 0;
    FILE *fp;
    char *filename;
    char *linebuf;
    int ch;
    int found_it = 0, namelen, linelen;

    filename = xmalloc (strlen (repository)
			+ 1
			+ strlen ("CVSROOT")
			+ 1
			+ strlen ("passwd")
			+ 1);

    strcpy (filename, repository);
    strcat (filename, "/CVSROOT");
    strcat (filename, "/passwd");
  
    /* 32 is enough to cover the hashed password.  I don't know if this
     * counts as an arbitrary limit or not; it really depends on how
     * standardized crypt() is.
     * Answer: FreeBSD and Debian have played with the idea of making
     * crypt() do MD5 which has a longer value; it would better not to
     * make assumptions.  So yes, FIXME: arbitrary limit.
     */

    /*            USERNAME        :   PASSWD   \n      \0     */
    linelen = strlen (username) + 1  +  32  +   1   +   1;
    linebuf = xmalloc (linelen);
    memset (linebuf, 0, linelen);

    fp = fopen (filename, "r");
    if (fp == NULL)
    {
	if (!existence_error (errno))
	    error (0, errno, "cannot open %s", filename);
	return 0;
    }

    /* Look for a relevant line -- one with this user's name. */
    namelen = strlen (username);
    while (fgets (linebuf, linelen, fp))
    {
	if ((strncmp (linebuf, username, namelen) == 0)
	    && (linebuf[namelen] == ':'))
        {
	    found_it = 1;
	    break;
        }
	else if (! strchr (linebuf, '\n'))
	{
	    while ((ch = getc (fp)) != '\n')
		if (ch == EOF)
		    break;
	}
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", filename);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", filename);

    /* If found_it != 0, then linebuf contains the information we need. */
    if (found_it)
    {
	char *found_password;

	strtok (linebuf, ":");
	found_password = strtok (NULL, ": \n");

	if (strcmp (found_password, crypt (password, found_password)) == 0)
	    retval = 1;
	else
	    retval = 2;
    }
    else
	retval = 0;

    free (filename);

    return retval;
}


/* Return 1 if password matches, else 0. */
int
check_password (username, password, repository)
     char *username, *password, *repository;
{
  int rc;

  /* First we see if this user has a password in the CVS-specific
     password file.  If so, that's enough to authenticate with.  If
     not, we'll check /etc/passwd. */

  rc = check_repository_password (username, password, repository);

  if (rc == 1)
    return 1;
  else if (rc == 2)
    return 0;
  else if (rc == 0)
    {
      /* No cvs password found, so try /etc/passwd. */

      struct passwd *pw;
      char *found_passwd;

      pw = getpwnam (username);
      if (pw == NULL)
        {
          printf ("E Fatal error, aborting.\n"
                  "error 0 %s: no such user\n", username);
          exit (1);
        }
      found_passwd = pw->pw_passwd;
      
      if (found_passwd && *found_passwd)
        return (! strcmp (found_passwd, crypt (password, found_passwd)));
      else if (password && *password)
        return 1;
      else
        return 0;
    }
  else
    {
      /* Something strange happened.  We don't know what it was, but
         we certainly won't grant authorization. */
      return 0;
    }
}


/* Read username and password from client (i.e., stdin).
   If correct, then switch to run as that user and send an ACK to the
   client via stdout, else send NACK and die. */
void
authenticate_connection ()
{
  int len;
  char tmp[PATH_MAX];
  char repository[PATH_MAX];
  char username[PATH_MAX];
  char password[PATH_MAX];
  char *descrambled_password;
  char server_user[PATH_MAX];
  struct passwd *pw;
  int verify_and_exit = 0;

  /* The Authentication Protocol.  Client sends:
   *
   *   BEGIN AUTH REQUEST\n
   *   <REPOSITORY>\n
   *   <USERNAME>\n
   *   <PASSWORD>\n
   *   END AUTH REQUEST\n
   *
   * Server uses above information to authenticate, then sends
   *
   *   I LOVE YOU\n
   *
   * if it grants access, else
   *
   *   I HATE YOU\n
   *
   * if it denies access (and it exits if denying).
   *
   * When the client is "cvs login", the user does not desire actual
   * repository access, but would like to confirm the password with
   * the server.  In this case, the start and stop strings are
   *
   *   BEGIN VERIFICATION REQUEST\n
   *
   *            and
   *
   *   END VERIFICATION REQUEST\n
   *
   * On a verification request, the server's responses are the same
   * (with the obvious semantics), but it exits immediately after
   * sending the response in both cases.
   *
   * Why is the repository sent?  Well, note that the actual
   * client/server protocol can't start up until authentication is
   * successful.  But in order to perform authentication, the server
   * needs to look up the password in the special CVS passwd file,
   * before trying /etc/passwd.  So the client transmits the
   * repository as part of the "authentication protocol".  The
   * repository will be redundantly retransmitted later, but that's no
   * big deal.
   */

  /* Since we're in the server parent process, error should use the
     protocol to report error messages.  */
  error_use_protocol = 1;

  /* Make sure the protocol starts off on the right foot... */
  fgets (tmp, PATH_MAX, stdin);
  if (strcmp (tmp, "BEGIN VERIFICATION REQUEST\n") == 0)
    verify_and_exit = 1;
  else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") != 0)
    error (1, 0, "bad auth protocol start: %s", tmp);
    
  /* Get the three important pieces of information in order. */
  fgets (repository, PATH_MAX, stdin);
  fgets (username, PATH_MAX, stdin);
  fgets (password, PATH_MAX, stdin);

  /* Make them pure. */ 
  strip_trailing_newlines (repository);
  strip_trailing_newlines (username);
  strip_trailing_newlines (password);

  /* ... and make sure the protocol ends on the right foot. */
  fgets (tmp, PATH_MAX, stdin);
  if (strcmp (tmp,
              verify_and_exit ?
              "END VERIFICATION REQUEST\n" : "END AUTH REQUEST\n")
           != 0)
    {
      error (1, 0, "bad auth protocol end: %s", tmp);
    }

  /* We need the real cleartext before we hash it. */
  descrambled_password = descramble (password);

  if (check_password (username, descrambled_password, repository))
    {
      printf ("I LOVE YOU\n");
      fflush (stdout);
      memset (descrambled_password, 0, strlen (descrambled_password));
      free (descrambled_password);
    }
  else
    {
      printf ("I HATE YOU\n");
      fflush (stdout);
      memset (descrambled_password, 0, strlen (descrambled_password));
      free (descrambled_password);
      exit (1);
    }
  
  /* Don't go any farther if we're just responding to "cvs login". */
  if (verify_and_exit)
    exit (0);

  /* Switch to run as this user. */
  pw = getpwnam (username);
  if (pw == NULL)
    {
      error (1, 0,
             "fatal error, aborting.\nerror 0 %s: no such user\n",
             username);
    }
  
  initgroups (pw->pw_name, pw->pw_gid);
  setgid (pw->pw_gid);
  setuid (pw->pw_uid);
  /* Inhibit access by randoms.  Don't want people randomly
     changing our temporary tree before we check things in.  */
  umask (077);
  
#if HAVE_PUTENV
  /* Set LOGNAME and USER in the environment, in case they are
     already set to something else.  */
  {
    char *env;
    
    env = xmalloc (sizeof "LOGNAME=" + strlen (username));
    (void) sprintf (env, "LOGNAME=%s", username);
    (void) putenv (env);
    
    env = xmalloc (sizeof "USER=" + strlen (username));
    (void) sprintf (env, "USER=%s", username);
    (void) putenv (env);
  }
#endif /* HAVE_PUTENV */
}

#endif /* AUTH_SERVER_SUPPORT */


a3577 1

@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@a27 5
#ifdef AUTH_SERVER_SUPPORT
/* For initgroups().  */
#include <grp.h>
#endif

a1238 9

static void
serve_set (arg)
    char *arg;
{
    /* FIXME: This sends errors immediately (I think); they should be
       put into pending_error.  */
    variable_set (arg);
}
d1419 3
a2179 7
/* This is the output which we are saving up to send to the server, in the
   child process.  We will push it through, via the `protocol' buffer, when
   we have a complete line.  */
static struct buffer saved_output;
/* Likewise, but stuff which will go to stderr.  */
static struct buffer saved_outerr;

a2330 7
	saved_output.data = saved_output.last = NULL;
	saved_output.fd = -1;
	saved_output.output = 0;
	saved_output.nonblocking = 0;
	saved_output.memory_error = protocol_memory_error;
	saved_outerr = saved_output;

a3766 1
  REQ_LINE("Set", serve_set, rq_optional),
a4110 2
extern char *crypt PROTO((const char *, const char *));

d4131 2
a4132 2
check_repository_password (username, password, repository, host_user_ptr)
     char *username, *password, *repository, **host_user_ptr;
d4138 2
a4139 2
    int found_it = 0;
    int namelen;
d4152 13
d4175 1
a4175 1
    while (1)
a4176 11
	linebuf = read_line(fp);
	if (linebuf == NULL)
        {
            free (linebuf);
	    break;
        }
	if (linebuf == NO_MEM_ERROR)
	{
            error (0, errno, "out of memory");
	    break;
	}
d4183 6
a4188 2
        free (linebuf);
        
d4202 1
a4202 2
	*host_user_ptr = strtok (NULL, ": \n");
	if (*host_user_ptr == NULL) *host_user_ptr = username;
a4208 2
    {
	*host_user_ptr = NULL;
a4209 1
    }
d4217 2
a4218 2
/* Return a hosting username if password matches, else NULL. */
char *
a4222 1
  char *host_user;
d4228 1
a4228 1
  rc = check_repository_password (username, password, repository, &host_user);
d4231 1
a4231 1
    return host_user;
d4251 1
a4251 2
        return (! strcmp (found_passwd, crypt (password, found_passwd))) ?
          username : NULL;
d4253 1
a4253 1
        return username;
d4255 1
a4255 1
        return NULL;
d4261 1
a4261 1
      return NULL;
d4272 1
a4276 1
  char *host_user;
d4278 1
d4357 2
a4358 2
  host_user = check_password (username, descrambled_password, repository);
  if (host_user)
d4379 1
a4379 1
  pw = getpwnam (host_user);
a4415 81
/* Output LEN bytes at STR.  If LEN is zero, then output up to (not including)
   the first '\0' byte.  Should not be called from the server parent process
   (yet at least, in the future it might be extended so that works).  */

void
cvs_output (str, len)
    char *str;
    size_t len;
{
    if (len == 0)
	len = strlen (str);
    if (error_use_protocol)
	/* Eventually we'll probably want to make it so this case works,
	   but for now, callers who want to output something with
	   error_use_protocol in effect can just printf the "M foo"
	   themselves.  */
	abort ();
#ifdef SERVER_SUPPORT
    if (server_active)
    {
	buf_output (&saved_output, str, len);
	buf_copy_lines (&protocol, &saved_output, 'M');
	buf_send_counted (&protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	char *p = str;

	while (to_write > 0)
	{
	    written = fwrite (str, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}

/* Like CVS_OUTPUT but output is for stderr not stdout.  */

void
cvs_outerr (str, len)
    char *str;
    size_t len;
{
    if (len == 0)
	len = strlen (str);
    if (error_use_protocol)
	/* Eventually we'll probably want to make it so this case works,
	   but for now, callers who want to output something with
	   error_use_protocol in effect can just printf the "E foo"
	   themselves.  */
	abort ();
#ifdef SERVER_SUPPORT
    if (server_active)
    {
	buf_output (&saved_outerr, str, len);
	buf_copy_lines (&protocol, &saved_outerr, 'E');
	buf_send_counted (&protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	char *p = str;

	while (to_write > 0)
	{
	    written = fwrite (str, 1, to_write, stderr);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
    }
}
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a29 1
#if HAVE_INITGROUPS
d31 1
a31 2
#endif /* HAVE_INITGROUPS */
#endif /* AUTH_SERVER_SUPPORT */
d273 1
a273 1
	    exit (EXIT_FAILURE);
d679 1
a679 2
	    error (1, errno, "waiting for gunzip process %ld",
		   (long) gzip_pid);
a2187 9

static void serve_case PROTO ((char *));

static void
serve_case (arg)
    char *arg;
{
    ign_case = 1;
}
d2229 1
a2229 1
    exit (EXIT_FAILURE);
a3209 26

static void serve_init PROTO ((char *));

static void
serve_init (arg)
    char *arg;
{
    CVSroot = malloc (strlen (arg) + 1);
    if (CVSroot == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (CVSroot, arg);

    do_cvs_command (init);
}

static void serve_annotate PROTO ((char *));

static void
serve_annotate (arg)
    char *arg;
{
    do_cvs_command (annotate);
}
a3384 4
	    /* Throughout this section we use binary mode to read the
	       file we are sending.  The client handles any line ending
	       translation if necessary.  */

d3397 1
a3397 1
		fd = open (file, O_RDONLY | OPEN_BINARY, 0);
d3401 1
a3401 1
		f = fdopen (fd, "rb");
d3412 1
a3412 2
		    error (1, errno, "waiting for gzip process %ld",
			   (long) gzip_pid);
d3423 1
a3423 1
		f = fopen (file, "rb");
a3563 6

struct template_proc_data
{
    char *update_dir;
    char *repository;
};
a3564 63
/* Here as a static until we get around to fixing Parse_Info to pass along
   a void * for it.  */
static struct template_proc_data *tpd;

static int
template_proc (repository, template)
    char *repository;
    char *template;
{
    FILE *fp;
    char buf[1024];
    size_t n;
    struct stat sb;
    struct template_proc_data *data = tpd;

    if (!supported_response ("Template"))
	/* Might want to warn the user that the rcsinfo feature won't work.  */
	return 0;
    buf_output0 (&protocol, "Template ");
    output_dir (data->update_dir, data->repository);
    buf_output0 (&protocol, "\n");

    fp = fopen (template, "rb");
    if (fp == NULL)
    {
	error (0, errno, "Couldn't open rcsinfo template file %s", template);
	return 1;
    }
    if (fstat (fileno (fp), &sb) < 0)
    {
	error (0, errno, "cannot stat rcsinfo template file %s", template);
	return 1;
    }
    sprintf (buf, "%ld\n", (long) sb.st_size);
    buf_output0 (&protocol, buf);
    while (!feof (fp))
    {
	n = fread (buf, 1, sizeof buf, fp);
	buf_output (&protocol, buf, n);
	if (ferror (fp))
	{
	    error (0, errno, "cannot read rcsinfo template file %s", template);
	    (void) fclose (fp);
	    return 1;
	}
    }
    if (fclose (fp) < 0)
	error (0, errno, "cannot close rcsinfo template file %s", template);
    return 0;
}

void
server_template (update_dir, repository)
    char *update_dir;
    char *repository;
{
    struct template_proc_data data;
    data.update_dir = update_dir;
    data.repository = repository;
    tpd = &data;
    (void) Parse_Info (CVSROOTADM_RCSINFO, repository, template_proc, 1);
}

a3788 1
  REQ_LINE("Case", serve_case, rq_optional),
a3817 2
  REQ_LINE("init", serve_init, rq_optional),
  REQ_LINE("annotate", serve_annotate, rq_optional),
d4013 1
a4013 1
	    exit (EXIT_FAILURE);
d4037 1
a4037 1
	    exit (EXIT_FAILURE);
d4054 1
a4054 1
	sprintf (p, "%ld", (long) getpid ());
d4077 1
a4077 1
	exit (EXIT_FAILURE);
d4246 1
a4246 1
    char *username, *password, *repository;
d4248 2
a4249 2
    int rc;
    char *host_user;
d4251 11
a4261 12
    /* First we see if this user has a password in the CVS-specific
       password file.  If so, that's enough to authenticate with.  If
       not, we'll check /etc/passwd. */

    rc = check_repository_password (username, password, repository,
				    &host_user);

    if (rc == 1)
	return host_user;
    else if (rc == 2)
	return 0;
    else if (rc == 0)
d4263 1
a4263 1
	/* No cvs password found, so try /etc/passwd. */
d4265 2
a4266 2
	struct passwd *pw;
	char *found_passwd;
d4268 2
a4269 2
	pw = getpwnam (username);
	if (pw == NULL)
d4271 13
a4283 13
	    printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);
	    exit (EXIT_FAILURE);
	}
	found_passwd = pw->pw_passwd;

	if (found_passwd && *found_passwd)
	    return ((! strcmp (found_passwd, crypt (password, found_passwd)))
		    ? username : NULL);
	else if (password && *password)
	    return username;
	else
	    return NULL;
d4285 1
a4285 1
    else
d4287 3
a4289 3
	/* Something strange happened.  We don't know what it was, but
	   we certainly won't grant authorization. */
	return NULL;
d4398 1
a4398 1
      exit (EXIT_FAILURE);
a4413 1
#if HAVE_INITGROUPS
a4414 2
#endif /* HAVE_INITGROUPS */

@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a5 2
#include "getline.h"
#include "buffer.h"
a8 17
#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS)
#include <sys/socket.h>
#endif

#ifdef HAVE_KERBEROS
#include <netinet/in.h>
#include <krb.h>
#ifndef HAVE_KRB_GET_ERR_TEXT
#define krb_get_err_text(status) krb_err_txt[status]
#endif

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

#endif

a27 8
/* EWOULDBLOCK is not defined by POSIX, but some BSD systems will
   return it, rather than EAGAIN, for nonblocking writes.  */
#ifdef EWOULDBLOCK
#define blocking_error(err) ((err) == EWOULDBLOCK || (err) == EAGAIN)
#else
#define blocking_error(err) ((err) == EAGAIN)
#endif

a28 3
#ifdef HAVE_GETSPNAM
#include <shadow.h>
#endif
a52 7
/* While processing requests, this buffer accumulates data to be sent to
   the client, and then once we are in do_cvs_command, we use it
   for all the data to be sent.  */
static struct buffer *buf_to_net;

/* This buffer is used to read input from the client.  */
static struct buffer *buf_from_net;
a59 4
/* This is the original value of server_temp_dir, before any possible
   changes inserted by serve_max_dotdot.  */
static char *orig_server_temp_dir;

d63 3
d68 10
a77 3
/* All server communication goes through buffer structures.  Most of
   the buffers are built on top of a file descriptor.  This structure
   is used as the closure field in a buffer.  */
d79 3
a81 1
struct fd_buffer
d83 11
a93 54
    /* The file descriptor.  */
    int fd;
    /* Nonzero if the file descriptor is in blocking mode.  */
    int blocking;
};

static struct buffer *fd_buffer_initialize
  PROTO ((int, int, void (*) (struct buffer *)));
static int fd_buffer_input PROTO((void *, char *, int, int, int *));
static int fd_buffer_output PROTO((void *, const char *, int, int *));
static int fd_buffer_flush PROTO((void *));
static int fd_buffer_block PROTO((void *, int));

/* Initialize a buffer built on a file descriptor.  FD is the file
   descriptor.  INPUT is nonzero if this is for input, zero if this is
   for output.  MEMORY is the function to call when a memory error
   occurs.  */

static struct buffer *
fd_buffer_initialize (fd, input, memory)
     int fd;
     int input;
     void (*memory) PROTO((struct buffer *));
{
    struct fd_buffer *n;

    n = (struct fd_buffer *) xmalloc (sizeof *n);
    n->fd = fd;
    n->blocking = 1;
    return buf_initialize (input ? fd_buffer_input : NULL,
			   input ? NULL : fd_buffer_output,
			   input ? NULL : fd_buffer_flush,
			   fd_buffer_block,
			   (int (*) PROTO((void *))) NULL,
			   memory,
			   n);
}

/* The buffer input function for a buffer built on a file descriptor.  */

static int
fd_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int nbytes;

    if (! fd->blocking)
	nbytes = read (fd->fd, data, size);
    else
d95 13
a107 52
	/* This case is not efficient.  Fortunately, I don't think it
           ever actually happens.  */
	nbytes = read (fd->fd, data, need == 0 ? 1 : need);
    }

    if (nbytes > 0)
    {
	*got = nbytes;
	return 0;
    }

    *got = 0;

    if (nbytes == 0)
    {
	/* End of file.  This assumes that we are using POSIX or BSD
           style nonblocking I/O.  On System V we will get a zero
           return if there is no data, even when not at EOF.  */
	return -1;
    }

    /* Some error occurred.  */

    if (blocking_error (errno))
    {
	/* Everything's fine, we just didn't get any data.  */
	return 0;
    }

    return errno;
}

/* The buffer output function for a buffer built on a file descriptor.  */

static int
fd_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;

    *wrote = 0;

    while (have > 0)
    {
	int nbytes;

	nbytes = write (fd->fd, data, have);

	if (nbytes <= 0)
d109 4
a112 14
	    if (! fd->blocking
		&& (nbytes == 0 || blocking_error (errno)))
	    {
		/* A nonblocking write failed to write any data.  Just
                   return.  */
		return 0;
	    }

	    /* Some sort of error occurred.  */

	    if (nbytes == 0)
	        return EIO;

	    return errno;
a113 4

	*wrote += nbytes;
	data += nbytes;
	have -= nbytes;
d115 3
a117 40

    return 0;
}

/* The buffer flush function for a buffer built on a file descriptor.  */

/*ARGSUSED*/
static int
fd_buffer_flush (closure)
     void *closure;
{
    /* Nothing to do.  File descriptors are always flushed.  */
    return 0;
}

/* The buffer block function for a buffer built on a file descriptor.  */

static int
fd_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct fd_buffer *fd = (struct fd_buffer *) closure;
    int flags;

    flags = fcntl (fd->fd, F_GETFL, 0);
    if (flags < 0)
	return errno;

    if (block)
	flags &= ~O_NONBLOCK;
    else
	flags |= O_NONBLOCK;

    if (fcntl (fd->fd, F_SETFL, flags) < 0)
        return errno;

    fd->blocking = block;

    return 0;
a178 1
 * Must be called only in contexts where it is OK to send output.
d185 1
a185 1
    buf_output0 (buf_to_net, "error  ");
d188 2
a189 4
	buf_output0 (buf_to_net, msg);
    buf_append_char (buf_to_net, '\n');

    buf_flush (buf_to_net, 0);
d199 1
a199 2
/* If an error is pending, print it and return 1.  If not, return 0.
   Must be called only in contexts where it is OK to send output.  */
d205 1
a205 2
	buf_output0 (buf_to_net, pending_error_text);
	buf_append_char (buf_to_net, '\n');
d209 1
a209 4
	    buf_output0 (buf_to_net, "error  \n");

	buf_flush (buf_to_net, 0);

d273 2
a274 8
	    buf_output0 (buf_to_net, "E response `");
	    buf_output0 (buf_to_net, rs->name);
	    buf_output0 (buf_to_net, "' not supported by client\nerror  \n");

	    /* FIXME: This call to buf_flush could conceivably
	       cause deadlock, as noted in server_cleanup.  */
	    buf_flush (buf_to_net, 1);

d289 1
a293 2

    set_local_cvsroot (arg);
d295 1
a295 1
    (void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
d316 7
d324 1
a324 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (CVSroot_directory) + 1 + 1);
d330 1
a330 1
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot_directory);
d360 1
a360 2
    if (server_temp_dir != orig_server_temp_dir)
	free (server_temp_dir);
a372 1
    char *b;
d401 1
a401 7

    b = strrchr (dir_name, '/');
    *b = '\0';
    Subdir_Register ((List *) NULL, dir_name, b + 1);
    *b = '/';

    if ( CVS_CHDIR (dir_name) < 0)
d420 1
a420 1
    f = CVS_FOPEN (CVSADM_REP, "w");
d426 1
a426 21
    if (fprintf (f, "%s", repos) < 0)
    {
	pending_error = errno;
	fclose (f);
	return;
    }
    /* Non-remote CVS handles a module representing the entire tree
       (e.g., an entry like ``world -a .'') by putting /. at the end
       of the Repository file, so we do the same.  */
    if (strcmp (dir, ".") == 0
	&& CVSroot_directory != NULL
	&& strcmp (CVSroot_directory, repos) == 0)
    {
        if (fprintf (f, "/.") < 0)
	{
	    pending_error = errno;
	    fclose (f);
	    return;
	}
    }
    if (fprintf (f, "\n") < 0)
d437 1
a437 3
    /* We open in append mode because we don't want to clobber an
       existing Entries file.  */
    f = CVS_FOPEN (CVSADM_ENT, "a");
a464 1
    int status;
a465 1

d467 2
a468 2
    status = buf_read_line (buf_from_net, &repos, (int *) NULL);
    if (status == 0)
d470 15
a484 2
	dirswitch (arg, repos);
	free (repos);
d486 1
a486 1
    else if (status == -2)
d488 1
a488 1
        pending_error = ENOMEM;
d492 2
a493 16
	pending_error_text = malloc (80 + strlen (arg));
	if (pending_error_text == NULL)
	{
	    pending_error = ENOMEM;
	}
	else if (status == -1)
	{
	    sprintf (pending_error_text,
		     "E end of file reading mode for %s", arg);
	}
	else
	{
	    sprintf (pending_error_text,
		     "E error reading mode for %s", arg);
	    pending_error = status;
	}
d502 1
a502 4

    if (error_pending ()) return;

    f = CVS_FOPEN (CVSADM_ENTSTAT, "w+");
d524 1
a524 4

    if (error_pending ()) return;

    f = CVS_FOPEN (CVSADM_TAG, "w+");
d549 1
a549 1
 * Read SIZE bytes from buf_from_net, write them to FILE.
d562 2
d566 3
a568 2
	int status, nread;
	char *data;
d570 2
a571 2
	status = buf_read_data (buf_from_net, size, &data, &nread);
	if (status != 0)
d573 1
a573 3
	    if (status == -2)
		pending_error = ENOMEM;
	    else
d576 1
a576 3
		if (pending_error_text == NULL)
		    pending_error = ENOMEM;
		else if (status == -1)
d583 6
a588 1
		{
d591 9
a599 2
		    pending_error = status;
		}
a602 1

d604 2
a605 2

	while (nread > 0)
d607 1
a607 3
	    int nwrote;

	    nwrote = write (file, data, nread);
d611 1
a611 1
		if (pending_error_text != NULL)
a613 13

		/* Read and discard the file data.  */
		while (size > 0)
		{
		    int status, nread;
		    char *data;

		    status = buf_read_data (buf_from_net, size, &data, &nread);
		    if (status != 0)
			return;
		    size -= nread;
		}

d617 1
a617 1
	    data += nwrote;
d635 1
a635 1
    fd = CVS_OPEN (arg, O_WRONLY | O_CREAT | O_TRUNC, 0600);
d692 1
a692 1
    int size, status;
d698 1
a698 8
    /*
     * This used to return immediately if error_pending () was true.
     * However, that fails, because it causes each line of the file to
     * be echoed back to the client as an unrecognized command.  The
     * client isn't reading from the socket, so eventually both
     * processes block trying to write to the other.  Now, we try to
     * read the file if we can.
     */
d700 2
a701 2
    status = buf_read_line (buf_from_net, &mode_text, (int *) NULL);
    if (status != 0)
d703 2
a704 3
        if (status == -2)
	    pending_error = ENOMEM;
	else
d706 3
a708 3
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
d711 3
a713 9
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading mode for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading mode for %s", arg);
		    pending_error = status;
		}
d716 7
d725 2
a726 3

    status = buf_read_line (buf_from_net, &size_text, (int *) NULL);
    if (status != 0)
d728 2
a729 3
	if (status == -2)
	    pending_error = ENOMEM;
	else
d731 3
a733 3
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
d736 3
a738 9
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading size for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading size for %s", arg);
		    pending_error = errno;
		}
d741 7
d751 1
a751 1
    {
d754 1
a754 1
    }
d756 1
a756 1
	size = atoi (size_text);
a758 16
    if (error_pending ())
    {
        /* Now that we know the size, read and discard the file data.  */
	while (size > 0)
	{
	    int status, nread;
	    char *data;

	    status = buf_read_data (buf_from_net, size, &data, &nread);
	    if (status != 0)
		return;
	    size -= nread;
	}
	return;
    }

d760 1
a760 1
    {
d763 1
a763 1
    }
d793 1
a793 1
    use_unchanged = 1;
d808 1
a808 1
	int fd = CVS_OPEN (arg, O_WRONLY | O_CREAT | O_TRUNC, 0666);
d924 1
a924 6
	/* We open in append mode because we don't want to clobber an
           existing Entries file.  If we are checking out a module
           which explicitly lists more than one file in a particular
           directory, then we will wind up calling
           server_write_entries for each such file.  */
	f = CVS_FOPEN (CVSADM_ENT, "a");
a986 1
    int status;
d1013 2
a1014 2
    status = buf_read_line (buf_from_net, &data, (int *) NULL);
    if (status != 0)
d1016 2
a1017 3
	if (status == -2)
	    pending_error = ENOMEM;
	else
d1019 3
a1021 3
	    pending_error_text = malloc (80 + strlen (arg));
	    if (pending_error_text == NULL)
		pending_error = ENOMEM;
d1024 3
a1026 9
		if (status == -1)
		    sprintf (pending_error_text,
			     "E end of file reading notification for %s", arg);
		else
		{
		    sprintf (pending_error_text,
			     "E error reading notification for %s", arg);
		    pending_error = status;
		}
d1029 2
d1032 5
a1036 1
    else
d1101 1
a1101 1
	if ( CVS_CHDIR (notify_list->dir) < 0)
d1122 1
a1122 1
	buf_output0 (buf_to_net, "Notified ");
d1127 1
a1127 1
	        buf_append_char (buf_to_net, '.');
d1129 7
a1135 8
	        buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '/');
	    buf_append_char (buf_to_net, '\n');
	}
	buf_output0 (buf_to_net, repos);
	buf_append_char (buf_to_net, '/');
	buf_output0 (buf_to_net, notify_list->filename);
	buf_append_char (buf_to_net, '\n');
d1151 3
a1153 5

    /* The code used to call fflush (stdout) here, but that is no
       longer necessary.  The data is now buffered in buf_to_net,
       which will be flushed by the caller, do_cvs_command.  */

d1256 25
d1282 5
a1286 2
#ifdef ENCRYPTION
#ifdef HAVE_KERBEROS
d1288 1
a1288 3
static void
serve_kerberos_encrypt (arg)
     char *arg;
d1290 11
a1300 1
    /* All future communication with the client will be encrypted.  */
d1302 9
a1310 7
    buf_to_net = krb_encrypt_buffer_initialize (buf_to_net, 0, sched,
						kblock,
						buf_to_net->memory_error);
    buf_from_net = krb_encrypt_buffer_initialize (buf_from_net, 1, sched,
						  kblock,
						  buf_from_net->memory_error);
}
a1311 3
#endif /* HAVE_KERBEROS */
#endif /* ENCRYPTION */

d1321 4
d1326 21
d1348 1
d1350 1
a1350 4
/*
 * Set buffer BUF to non-blocking I/O.  Returns 0 for success or errno
 * code.
 */
d1352 2
a1353 3
static int
set_nonblock_fd (fd)
     int fd;
d1355 6
a1360 1
    int flags;
d1362 11
a1372 6
    flags = fcntl (fd, F_GETFL, 0);
    if (flags < 0)
	return errno;
    if (fcntl (fd, F_SETFL, flags | O_NONBLOCK) < 0)
	return errno;
    return 0;
d1375 1
a1375 3
#endif /* SERVER_FLOWCONTROL */

static void serve_questionable PROTO((char *));
d1377 2
a1378 3
static void
serve_questionable (arg)
    char *arg;
d1380 1
a1380 1
    static int initted;
d1382 1
a1382 1
    if (!initted)
d1384 3
a1386 10
	/* Pick up ignores from CVSROOTADM_IGNORE, $HOME/.cvsignore on server,
	   and CVSIGNORE on server.  */
	ign_setup ();
	initted = 1;
    }

    if (dir_name == NULL)
    {
	buf_output0 (buf_to_net, "E Protocol error: 'Directory' missing");
	return;
d1389 3
a1391 14
    if (!ign_name (arg))
    {
	char *update_dir;

	buf_output (buf_to_net, "M ? ", 4);
	update_dir = dir_name + strlen (server_temp_dir) + 1;
	if (!(update_dir[0] == '.' && update_dir[1] == '\0'))
	{
	    buf_output0 (buf_to_net, update_dir);
	    buf_output (buf_to_net, "/", 1);
	}
	buf_output0 (buf_to_net, arg);
	buf_output (buf_to_net, "\n", 1);
    }
d1394 1
a1394 1
static void serve_case PROTO ((char *));
d1396 3
a1398 3
static void
serve_case (arg)
    char *arg;
d1400 1
a1400 4
    ign_case = 1;
}

static struct buffer *protocol;
d1402 4
a1405 12
/* This is the output which we are saving up to send to the server, in the
   child process.  We will push it through, via the `protocol' buffer, when
   we have a complete line.  */
static struct buffer *saved_output;
/* Likewise, but stuff which will go to stderr.  */
static struct buffer *saved_outerr;

static void
protocol_memory_error (buf)
    struct buffer *buf;
{
    error (1, ENOMEM, "Virtual memory exhausted");
d1408 1
d1410 2
a1411 2
 * Process IDs of the subprocess, or negative if that subprocess
 * does not exist.
a1412 1
static pid_t command_pid;
d1414 2
a1415 2
static void
outbuf_memory_error (buf)
d1418 2
a1419 4
    static const char msg[] = "E Fatal server error\n\
error ENOMEM Virtual memory exhausted.\n";
    if (command_pid > 0)
	kill (command_pid, SIGTERM);
d1421 2
a1422 5
    /*
     * We have arranged things so that printing this now either will
     * be legal, or the "E fatal error" line will get glommed onto the
     * end of an existing "E" or "M" response.
     */
d1424 1
a1424 4
    /* If this gives an error, not much we could do.  syslog() it?  */
    write (STDOUT_FILENO, msg, sizeof (msg) - 1);
    server_cleanup (0);
    exit (EXIT_FAILURE);
d1426 3
d1431 4
a1434 2
input_memory_error (buf)
     struct buffer *buf;
d1436 9
a1444 4
    outbuf_memory_error (buf);
}

/* Execute COMMAND in a subprocess with the approriate funky things done.  */
d1446 3
a1448 2
static struct fd_set_wrapper { fd_set fds; } command_fds_to_drain;
static int max_command_fd;
d1450 6
a1455 3
#ifdef SERVER_FLOWCONTROL
static int flowcontrol_pipe[2];
#endif /* SERVER_FLOWCONTROL */
d1457 6
a1462 8
static void
do_cvs_command (command)
    int (*command) PROTO((int argc, char **argv));
{
    /*
     * The following file descriptors are set to -1 if that file is not
     * currently open.
     */
d1464 1
a1464 3
    /* Data on these pipes is a series of '\n'-terminated lines.  */
    int stdout_pipe[2];
    int stderr_pipe[2];
d1466 6
a1471 8
    /*
     * Data on this pipe is a series of counted (see buf_send_counted)
     * packets.  Each packet must be processed atomically (i.e. not
     * interleaved with data from stdout_pipe or stderr_pipe).
     */
    int protocol_pipe[2];
    
    int dev_null_fd = -1;
d1473 2
a1474 1
    int errs;
d1476 3
a1478 7
    command_pid = -1;
    stdout_pipe[0] = -1;
    stdout_pipe[1] = -1;
    stderr_pipe[0] = -1;
    stderr_pipe[1] = -1;
    protocol_pipe[0] = -1;
    protocol_pipe[1] = -1;
d1480 2
a1481 1
    server_write_entries ();
d1483 1
a1483 2
    if (print_pending_error ())
	goto free_args_and_return;
d1485 7
a1491 1
    (void) server_notify ();
d1493 1
a1493 7
    /*
     * We use a child process which actually does the operation.  This
     * is so we can intercept its standard output.  Even if all of CVS
     * were written to go to some special routine instead of writing
     * to stdout or stderr, we would still need to do the same thing
     * for the RCS commands.
     */
d1495 8
a1502 1
    if (pipe (stdout_pipe) < 0)
d1504 2
a1505 2
	print_error (errno);
	goto error_exit;
d1507 1
a1507 12
    if (pipe (stderr_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    if (pipe (protocol_pipe) < 0)
    {
	print_error (errno);
	goto error_exit;
    }
#ifdef SERVER_FLOWCONTROL
    if (pipe (flowcontrol_pipe) < 0)
d1509 1
a1509 6
	print_error (errno);
	goto error_exit;
    }
    set_nonblock_fd (flowcontrol_pipe[0]);
    set_nonblock_fd (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */
d1511 2
a1512 5
    dev_null_fd = CVS_OPEN ("/dev/null", O_RDONLY);
    if (dev_null_fd < 0)
    {
	print_error (errno);
	goto error_exit;
d1514 1
d1516 5
a1520 12
    /* We shouldn't have any partial lines from cvs_output and
       cvs_outerr, but we handle them here in case there is a bug.  */
    if (! buf_empty_p (saved_output))
    {
	buf_append_char (saved_output, '\n');
	buf_copy_lines (buf_to_net, saved_output, 'M');
    }
    if (! buf_empty_p (saved_outerr))
    {
	buf_append_char (saved_outerr, '\n');
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
    }
d1522 6
a1527 2
    /* Flush out any pending data.  */
    buf_flush (buf_to_net, 1);
d1529 1
a1529 8
    /* Don't use vfork; we're not going to exec().  */
    command_pid = fork ();
    if (command_pid < 0)
    {
	print_error (errno);
	goto error_exit;
    }
    if (command_pid == 0)
d1531 1
a1531 1
	int exitstatus;
d1533 4
a1536 4
	/* Since we're in the child, and the parent is going to take
	   care of packaging up our error messages, we can clear this
	   flag.  */
	error_use_protocol = 0;
d1538 4
a1541 2
	protocol = fd_buffer_initialize (protocol_pipe[1], 0,
					 protocol_memory_error);
d1543 824
a2366 11
	/* At this point we should no longer be using buf_to_net and
           buf_from_net.  Instead, everything should go through
           protocol.  */
	buf_to_net = NULL;
	buf_from_net = NULL;

	/* These were originally set up to use outbuf_memory_error.
           Since we're now in the child, we should use the simpler
           protocol_memory_error function.  */
	saved_output->memory_error = protocol_memory_error;
	saved_outerr->memory_error = protocol_memory_error;
d2402 3
a2404 3
	struct buffer *stdoutbuf;
	struct buffer *stderrbuf;
	struct buffer *protocol_inbuf;
d2431 1
a2431 3
	    buf_output0 (buf_to_net,
			 "E internal error: FD_SETSIZE not big enough.\n\
error  \n");
d2435 22
a2456 13
	stdoutbuf = fd_buffer_initialize (stdout_pipe[0], 1,
					  input_memory_error);

	stderrbuf = fd_buffer_initialize (stderr_pipe[0], 1,
					  input_memory_error);

	protocol_inbuf = fd_buffer_initialize (protocol_pipe[0], 1,
					       input_memory_error);

	set_nonblock (buf_to_net);
	set_nonblock (stdoutbuf);
	set_nonblock (stderrbuf);
	set_nonblock (protocol_inbuf);
d2509 1
a2509 1
	    bufmemsize = buf_count_mem (buf_to_net);
d2524 1
a2524 1
	    if (! buf_empty_p (buf_to_net))
a2539 8
	    /* This process of selecting on the three pipes means that
	       we might not get output in the same order in which it
	       was written, thus producing the well-known
	       "out-of-order" bug.  If the child process uses
	       cvs_output and cvs_outerr, it will send everything on
	       the protocol_pipe and avoid this problem, so the
	       solution is to use cvs_output and cvs_outerr in the
	       child process.  */
d2557 1
a2557 1
		buf_send_output (buf_to_net);
d2565 1
a2565 1
	        status = buf_input_data (stdoutbuf, (int *) NULL);
d2567 1
a2567 1
		buf_copy_lines (buf_to_net, stdoutbuf, 'M');
d2578 1
a2578 1
		buf_send_output (buf_to_net);
d2586 1
a2586 1
	        status = buf_input_data (stderrbuf, (int *) NULL);
d2588 1
a2588 1
		buf_copy_lines (buf_to_net, stderrbuf, 'E');
d2599 1
a2599 1
		buf_send_output (buf_to_net);
a2606 1
		int special;
d2608 1
a2608 9
		status = buf_input_data (protocol_inbuf, &count_read);

		if (status == -1)
		    protocol_pipe[0] = -1;
		else if (status > 0)
		{
		    print_error (status);
		    goto error_exit;
		}
d2617 7
a2623 1
		while (count_needed <= 0)
d2625 3
a2627 18
		    count_needed = buf_copy_counted (buf_to_net,
						     protocol_inbuf,
						     &special);

		    /* What should we do with errors?  syslog() them?  */
		    buf_send_output (buf_to_net);

		    /* If SPECIAL got set to -1, it means that the child
		       wants us to flush the pipe.  We don't want to block
		       on the network, but we flush what we can.  If the
		       client supports the 'F' command, we send it.  */
		    if (special == -1)
		    {
			if (supported_response ("F"))
			{
			    buf_append_char (buf_to_net, 'F');
			    buf_append_char (buf_to_net, '\n');
			}
d2629 2
a2630 3
			cvs_flusherr ();
		    }
		}
d2639 1
a2639 1
	if (! buf_empty_p (stdoutbuf))
d2641 2
a2642 2
	    buf_append_char (stdoutbuf, '\n');
	    buf_copy_lines (buf_to_net, stdoutbuf, 'M');
d2644 1
a2644 1
	if (! buf_empty_p (stderrbuf))
d2646 2
a2647 2
	    buf_append_char (stderrbuf, '\n');
	    buf_copy_lines (buf_to_net, stderrbuf, 'E');
d2649 2
a2650 2
	if (! buf_empty_p (protocol_inbuf))
	    buf_output0 (buf_to_net,
a2673 1
	        char buf[50];
d2681 1
a2681 3
		buf_output0 (buf_to_net, "E Terminated with fatal signal ");
		sprintf (buf, "%d\n", sig);
		buf_output0 (buf_to_net, buf);
d2686 3
a2688 4
		    buf_output0 (buf_to_net, "E Core dumped; preserving ");
		    buf_output0 (buf_to_net, orig_server_temp_dir);
		    buf_output0 (buf_to_net, " on server.\n\
E CVS locks may need cleaning up.\n");
d2701 2
a2702 2
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);
d2707 1
a2707 1
	buf_output0 (buf_to_net, "error  \n");
d2709 1
a2709 1
	buf_output0 (buf_to_net, "ok\n");
a2745 5

    /* Flush out any data not yet sent.  */
    set_block (buf_to_net);
    buf_flush (buf_to_net, 1);

d2790 1
a2790 3
	    int got;

	    while ((got = read (flowcontrol_pipe[0], buf, 1)) == 1)
a2798 10

	    /* This assumes that we are using BSD or POSIX nonblocking
               I/O.  System V nonblocking I/O returns zero if there is
               nothing to read.  */
	    if (got == 0)
	        error (1, 0, "flow control EOF");
	    if (got < 0 && ! blocking_error (errno))
	    {
	        error (1, errno, "flow control read failed");
	    }
d2814 1
a2814 1
	    buf_output0 (protocol, ".");
d2816 2
a2817 2
	    buf_output0 (protocol, update_dir);
	buf_output0 (protocol, "/\n");
d2819 2
a2820 2
    buf_output0 (protocol, repository);
    buf_output0 (protocol, "/");
d2932 1
a2932 1
	buf_output0 (protocol,
d2934 1
a2934 1
	buf_send_counted (protocol);
d2953 2
a2954 2
	buf_output0 (protocol, entries_line);
	buf_output (protocol, "\n", 1);
d2958 1
a2958 1
	buf_output0 (protocol,
d2982 1
a2982 1
	if ( CVS_STAT (file, &sb) < 0)
d2991 1
a2991 1
	    buf_output0 (protocol, "Mode ");
d2993 2
a2994 2
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
d2999 1
a2999 1
    buf_output0 (protocol, "Checked-in ");
d3001 2
a3002 2
    buf_output0 (protocol, file);
    buf_output (protocol, "\n", 1);
d3020 1
a3020 1
	buf_output0 (protocol, "Remove-entry ");
d3022 2
a3023 2
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
d3031 1
a3031 1
    buf_send_counted (protocol);
d3049 1
a3049 1
	buf_output0 (protocol, "New-entry ");
d3051 2
a3052 2
	buf_output0 (protocol, file);
	buf_output (protocol, "\n", 1);
d3056 1
a3056 1
    buf_send_counted (protocol);
d3229 7
a3235 1
    set_local_cvsroot (arg);
d3268 1
a3268 1
	    buf_output0 (buf_to_net, "E Out of memory\n");
d3276 1
a3276 3
	    buf_output0 (buf_to_net, "E Cannot create ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
d3282 1
a3282 1
	if ( CVS_CHDIR (tempdir) < 0)
d3284 1
a3284 3
	    buf_output0 (buf_to_net, "E Cannot change to directory ");
	    buf_output0 (buf_to_net, tempdir);
	    buf_append_char (buf_to_net, '\n');
d3312 1
a3312 1
    buf_output0 (protocol, "Copy-file ");
d3314 4
a3317 4
    buf_output0 (protocol, file);
    buf_output0 (protocol, "\n");
    buf_output0 (protocol, newfile);
    buf_output0 (protocol, "\n");
a3319 2
/* See server.h for description.  */

d3321 4
a3324 3
server_updated (finfo, vers, updated, file_info, checksum)
    struct file_info *finfo;
    Vers_TS *vers;
d3329 2
d3334 6
d3348 1
a3348 1
	if ( CVS_STAT (finfo->file, &sb) < 0)
d3356 2
a3357 1
		 * forget the whole thing.  */
d3362 1
a3362 1
	    error (1, errno, "reading %s", finfo->fullname);
d3379 1
a3379 1
	        buf_output0 (protocol, "Checksum ");
d3383 1
a3383 1
		    buf_output0 (protocol, buf);
d3385 1
a3385 1
		buf_append_char (protocol, '\n');
d3390 1
a3390 13
	{
	    if (!(supported_response ("Created")
		  && supported_response ("Update-existing")))
		buf_output0 (protocol, "Updated ");
	    else
	    {
		assert (vers != NULL);
		if (vers->ts_user == NULL)
		    buf_output0 (protocol, "Created ");
		else
		    buf_output0 (protocol, "Update-existing ");
	    }
	}
d3392 1
a3392 1
	    buf_output0 (protocol, "Merged ");
d3394 1
a3394 1
	    buf_output0 (protocol, "Patched ");
d3397 3
a3399 3
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);
d3414 2
a3415 2
	    buf_output0 (protocol, mode_string);
	    buf_output0 (protocol, "\n");
d3427 1
a3427 1
	    if (file_gzip_level
d3439 1
a3439 1
		fd = CVS_OPEN (finfo->file, O_RDONLY | OPEN_BINARY, 0);
d3441 2
a3442 2
		    error (1, errno, "reading %s", finfo->fullname);
		fd = filter_through_gzip (fd, 1, file_gzip_level, &gzip_pid);
d3447 1
a3447 1
		    (*protocol->memory_error) (protocol);
d3450 1
a3450 1
			   finfo->fullname);
d3452 1
a3452 1
		    error (1, errno, "reading %s", finfo->fullname);
d3459 1
a3459 1
		buf_output0 (protocol, "z");
d3466 1
a3466 1
		f = CVS_FOPEN (finfo->file, "rb");
d3468 1
a3468 1
		    error (1, errno, "reading %s", finfo->fullname);
d3471 1
a3471 1
		    (*protocol->memory_error) (protocol);
d3474 1
a3474 1
			   finfo->fullname);
d3476 1
a3476 1
		    error (1, errno, "reading %s", finfo->fullname);
d3481 1
a3481 1
	buf_output0 (protocol, size_text);
d3483 1
a3483 1
	buf_append_data (protocol, list, last);
d3497 1
a3497 1
	    CVS_UNLINK (finfo->file);
d3501 1
a3501 1
	if (strcmp (scratched_file, finfo->file) != 0)
d3505 1
a3505 1
		   finfo->file);
d3510 1
a3510 1
	    buf_output0 (protocol, "Removed ");
d3512 4
a3515 4
	    buf_output0 (protocol, "Remove-entry ");
	output_dir (finfo->update_dir, finfo->repository);
	buf_output0 (protocol, finfo->file);
	buf_output (protocol, "\n", 1);
d3527 3
a3529 2
    buf_send_counted (protocol);
  done:;
d3542 1
a3542 1
    buf_output0 (protocol, "Set-static-directory ");
d3544 2
a3545 2
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
d3561 1
a3561 1
    buf_output0 (protocol, "Clear-static-directory ");
d3563 2
a3564 2
    buf_output0 (protocol, "\n");
    buf_send_counted (protocol);
a3574 3

    assert (update_dir != NULL);

d3584 1
a3584 1
	buf_output0 (protocol, "Clear-sticky ");
d3586 1
a3586 1
	buf_output0 (protocol, "\n");
d3590 1
a3590 1
	buf_output0 (protocol, "Set-sticky ");
d3592 1
a3592 1
	buf_output0 (protocol, "\n");
d3595 2
a3596 2
	    buf_output0 (protocol, "T");
	    buf_output0 (protocol, tag);
d3600 2
a3601 2
	    buf_output0 (protocol, "D");
	    buf_output0 (protocol, date);
d3603 1
a3603 1
	buf_output0 (protocol, "\n");
d3605 1
a3605 1
    buf_send_counted (protocol);
d3632 1
a3632 1
    buf_output0 (protocol, "Template ");
d3634 1
a3634 1
    buf_output0 (protocol, "\n");
d3636 1
a3636 1
    fp = CVS_FOPEN (template, "rb");
d3648 1
a3648 1
    buf_output0 (protocol, buf);
d3652 1
a3652 1
	buf_output (protocol, buf, n);
d3685 1
a3685 18
    file_gzip_level = level;
}

static void
serve_gzip_stream (arg)
     char *arg;
{
    int level;
    level = atoi (arg);
    if (level == 0)
	level = 6;

    /* All further communication with the client will be compressed.  */

    buf_to_net = compress_buffer_initialize (buf_to_net, 0, level,
					     buf_to_net->memory_error);
    buf_from_net = compress_buffer_initialize (buf_from_net, 1, level,
					       buf_from_net->memory_error);
d3723 1
a3723 2
	buf_output0 (buf_to_net, "Module-expansion ");
	buf_output0 (buf_to_net, mwhere);
d3726 1
a3726 2
	    buf_append_char (buf_to_net, '/');
	    buf_output0 (buf_to_net, mfile);
d3728 1
a3728 1
	buf_append_char (buf_to_net, '\n');
d3731 1
a3731 1
    {
d3735 1
a3735 5
	{
	    buf_output0 (buf_to_net, "Module-expansion ");
	    buf_output0 (buf_to_net, dir);
	    buf_append_char (buf_to_net, '\n');
	}
d3737 3
a3739 11
	{
	    for (i = 1; i < *pargc; ++i)
	    {
	        buf_output0 (buf_to_net, "Module-expansion ");
		buf_output0 (buf_to_net, dir);
		buf_append_char (buf_to_net, '/');
		buf_output0 (buf_to_net, argv[i]);
		buf_append_char (buf_to_net, '\n');
	    }
	}
    }
d3778 1
a3778 1
	buf_output0 (buf_to_net, "error  \n");
d3780 1
a3780 5
	buf_output0 (buf_to_net, "ok\n");

    /* The client is waiting for the module expansions, so we must
       send the output now.  */
    buf_flush (buf_to_net, 1);
d3791 1
a3791 1
	buf_output0 (buf_to_net, "E \
d3798 1
a3798 1
	    buf_output0 (buf_to_net, "Set-checkin-prog ");
d3801 1
a3801 1
	    buf_output0 (buf_to_net, "Set-update-prog ");
d3804 1
a3804 4
    buf_output0 (buf_to_net, dir);
    buf_append_char (buf_to_net, '\n');
    buf_output0 (buf_to_net, name);
    buf_append_char (buf_to_net, '\n');
d3812 1
a3812 1
    f = CVS_FOPEN (CVSADM_CIPROG, "w+");
d3841 1
a3841 1
    f = CVS_FOPEN (CVSADM_UPROG, "w+");
a3904 1
  REQ_LINE("Gzip-stream", serve_gzip_stream, rq_optional),
a3905 5
#ifdef ENCRYPTION
#ifdef HAVE_KERBEROS
  REQ_LINE("Kerberos-encrypt", serve_kerberos_encrypt, rq_optional),
#endif
#endif
d3949 1
a3949 1
    buf_output0 (buf_to_net, "Valid-requests");
a3950 1
    {
d3952 2
a3953 10
	{
	    buf_append_char (buf_to_net, ' ');
	    buf_output0 (buf_to_net, rq->name);
	}
    }
    buf_output0 (buf_to_net, "\nok\n");

    /* The client is waiting for the list of valid requests, so we
       must send the output now.  */
    buf_flush (buf_to_net, 1);
d3965 4
a3968 4
    int status;
    pid_t r = wait (&status);
    if (r == command_pid)
	command_pid_is_dead++;
d3977 3
a3979 26
    int status;
    int save_noexec;

    if (buf_to_net != NULL)
    {
	/* FIXME: If this is not the final call from server, this
	   could deadlock, because the client might be blocked writing
	   to us.  This should not be a problem in practice, because
	   we do not generate much output when the client is not
	   waiting for it.  */
	set_block (buf_to_net);
	buf_flush (buf_to_net, 1);

	/* The calls to buf_shutdown are currently only meaningful
	   when we are using compression.  First we shut down
	   BUF_FROM_NET.  That will pick up the checksum generated
	   when the client shuts down its buffer.  Then, after we have
	   generated any final output, we shut down BUF_TO_NET.  */

	status = buf_shutdown (buf_from_net);
	if (status != 0)
	{
	    error (0, status, "shutting down buffer from client");
	    buf_flush (buf_to_net, 1);
	}
    }
a3981 3
    {
	if (buf_to_net != NULL)
	    (void) buf_shutdown (buf_to_net);
a3982 1
    }
d3988 17
a4004 18
    if (command_pid > 0)
    {
	/* To avoid crashes on SunOS due to bugs in SunOS tmpfs
	   triggered by the use of rename() in RCS, wait for the
	   subprocess to die.  Unfortunately, this means draining output
	   while waiting for it to unblock the signal we sent it.  Yuck!  */
	int status;
	pid_t r;

	signal (SIGCHLD, wait_sig);
	if (sig)
	    /* Perhaps SIGTERM would be more correct.  But the child
	       process will delay the SIGINT delivery until its own
	       children have exited.  */
	    kill (command_pid, SIGINT);
	/* The caller may also have sent a signal to command_pid, so
	   always try waiting.  First, though, check and see if it's still
	   there....  */
d4006 31
a4036 16
	r = waitpid (command_pid, &status, WNOHANG);
	if (r == 0)
	    ;
	else if (r == command_pid)
	    command_pid_is_dead++;
	else if (r == -1)
	    switch (errno)
	    {
		case ECHILD:
		    command_pid_is_dead++;
		    break;
		case EINTR:
		    goto do_waitpid;
	    }
	else
	    /* waitpid should always return one of the above values */
d4038 5
a4042 14
	while (!command_pid_is_dead)
	{
	    struct timeval timeout;
	    struct fd_set_wrapper readfds;
	    char buf[100];
	    int i;

	    /* Use a non-zero timeout to avoid eating up CPU cycles.  */
	    timeout.tv_sec = 2;
	    timeout.tv_usec = 0;
	    readfds = command_fds_to_drain;
	    switch (select (max_command_fd + 1, &readfds.fds,
			    (fd_set *)0, (fd_set *)0,
			    &timeout))
d4044 5
a4048 18
		case -1:
		    if (errno != EINTR)
			abort ();
		case 0:
		    /* timeout */
		    break;
		case 1:
		    for (i = 0; i <= max_command_fd; i++)
		    {
			if (!FD_ISSET (i, &readfds.fds))
			    continue;
			/* this fd is non-blocking */
			while (read (i, buf, sizeof (buf)) >= 1)
			    ;
		    }
		    break;
		default:
		    abort ();
d4050 3
d4054 1
d4058 17
a4074 17
    CVS_CHDIR (Tmpdir);
    /* Temporarily clear noexec, so that we clean up our temp directory
       regardless of it (this could more cleanly be handled by moving
       the noexec check to all the unlink_file_dir callers from
       unlink_file_dir itself).  */
    save_noexec = noexec;
    noexec = 0;
    /* FIXME?  Would be nice to not ignore errors.  But what should we do?
       We could try to do this before we shut down the network connection,
       and try to notify the client (but the client might not be waiting
       for responses).  We could try something like syslog() or our own
       log file.  */
    unlink_file_dir (orig_server_temp_dir);
    noexec = save_noexec;

    if (buf_to_net != NULL)
	(void) buf_shutdown (buf_to_net);
a4096 7
    buf_to_net = fd_buffer_initialize (STDOUT_FILENO, 0,
				       outbuf_memory_error);
    buf_from_net = stdio_buffer_initialize (stdin, 1, outbuf_memory_error);

    saved_output = buf_nonio_initialize (outbuf_memory_error);
    saved_outerr = buf_nonio_initialize (outbuf_memory_error);

d4138 7
a4144 4
	/* The code which wants to chdir into server_temp_dir is not set
	   up to deal with it being a relative path.  So give an error
	   for that case.  */
	if (!isabsolute (Tmpdir))
d4146 7
a4152 14
	    pending_error_text = malloc (80 + strlen (Tmpdir));
	    if (pending_error_text == NULL)
	    {
		pending_error = ENOMEM;
	    }
	    else
	    {
		sprintf (pending_error_text,
			 "E Value of %s for TMPDIR is not absolute", Tmpdir);
	    }
	    /* FIXME: we would like this error to be persistent, that
	       is, not cleared by print_pending_error.  The current client
	       will exit as soon as it gets an error, but the protocol spec
	       does not require a client to do so.  */
d4154 1
a4154 14
	else
	{
	    server_temp_dir = malloc (strlen (Tmpdir) + 80);
	    if (server_temp_dir == NULL)
	    {
		/*
		 * Strictly speaking, we're not supposed to output anything
		 * now.  But we're about to exit(), give it a try.
		 */
		printf ("E Fatal server error, aborting.\n\
error ENOMEM Virtual memory exhausted.\n");
		exit (EXIT_FAILURE);
	    }
	    strcpy (server_temp_dir, Tmpdir);
d4156 4
a4159 4
	    /* Remove a trailing slash from TMPDIR if present.  */
	    p = server_temp_dir + strlen (server_temp_dir) - 1;
	    if (*p == '/')
		*p = '\0';
d4161 6
a4166 6
	    /*
	     * I wanted to use cvs-serv/PID, but then you have to worry about
	     * the permissions on the cvs-serv directory being right.  So
	     * use cvs-servPID.
	     */
	    strcat (server_temp_dir, "/cvs-serv");
d4168 2
a4169 5
	    p = server_temp_dir + strlen (server_temp_dir);
	    sprintf (p, "%ld", (long) getpid ());

	    orig_server_temp_dir = server_temp_dir;
	}
d4196 7
a4202 9
    /* This gets printed if the client supports an option which the
       server doesn't, causing the server to print a usage message.
       FIXME: probably should be using program_name here.
       FIXME: just a nit, I suppose, but the usage message the server
       prints isn't literally true--it suggests "cvs server" followed
       by options which are for a particular command.  Might be nice to
       say something like "client apparently supports an option not supported
       by this server" or something like that instead of usage message.  */
    argument_vector[0] = "cvs server";
a4209 1
	int status;
d4211 4
a4214 2
	status = buf_read_line (buf_from_net, &cmd, (int *) NULL);
	if (status == -2)
d4216 1
a4216 1
	    buf_output0 (buf_to_net, "E Fatal server error, aborting.\n\
a4219 4
	if (status != 0)
	    break;

	orig_cmd = cmd;
d4241 1
a4241 6
	    {
	        buf_output0 (buf_to_net, "error  unrecognized request `");
		buf_output0 (buf_to_net, cmd);
		buf_append_char (buf_to_net, '\'');
		buf_append_char (buf_to_net, '\n');
	    }
d4245 2
a4246 59
    server_cleanup (0);
    return 0;
}


#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT)
static void switch_to_user PROTO((const char *));

static void
switch_to_user (username)
    const char *username;
{
    struct passwd *pw;

    pw = getpwnam (username);
    if (pw == NULL)
    {
	printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", username);
	exit (EXIT_FAILURE);
    }

#if HAVE_INITGROUPS
    initgroups (pw->pw_name, pw->pw_gid);
#endif /* HAVE_INITGROUPS */

#ifdef SETXID_SUPPORT
    /* honor the setgid bit iff set*/
    if (getgid() != getegid())
    {
	setgid (getegid ());
    }
    else
#else
    {
	setgid (pw->pw_gid);
    }
#endif
    
    setuid (pw->pw_uid);
    /* Inhibit access by randoms.  Don't want people randomly
       changing our temporary tree before we check things in.  */
    umask (077);

#if HAVE_PUTENV
    /* Set LOGNAME and USER in the environment, in case they are
       already set to something else.  */
    {
	char *env;

	env = xmalloc (sizeof "LOGNAME=" + strlen (username));
	(void) sprintf (env, "LOGNAME=%s", username);
	(void) putenv (env);

	env = xmalloc (sizeof "USER=" + strlen (username));
	(void) sprintf (env, "USER=%s", username);
	(void) putenv (env);
    }
#endif /* HAVE_PUTENV */
a4247 1
#endif
d4249 1
d4254 13
d4273 1
a4273 1
static int
d4280 1
a4280 2
    char *linebuf = NULL;
    size_t linebuf_len;
d4294 2
a4295 2

    fp = CVS_FOPEN (filename, "r");
d4305 1
a4305 1
    while (getline (&linebuf, &linebuf_len, fp) >= 0)
d4307 11
d4325 1
a4325 1
        linebuf = NULL;
d4359 1
a4359 1
static char *
a4380 10
	const char *found_passwd = NULL;
#ifdef HAVE_GETSPNAM
	struct spwd *pw;

	pw = getspnam (username);
	if (pw != NULL)
	{
	    found_passwd = pw->sp_pwdp;
	}
#else
d4382 1
a4384 6
	if (pw != NULL)
	{
	    found_passwd = pw->pw_passwd;
	}
#endif
	
d4386 1
a4386 1
	{
d4391 2
a4392 1
	
d4409 1
d4414 1
a4414 1
pserver_authenticate_connection ()
d4416 112
a4527 58
    char tmp[PATH_MAX];
    char repository[PATH_MAX];
    char username[PATH_MAX];
    char password[PATH_MAX];
    char *host_user;
    char *descrambled_password;
    int verify_and_exit = 0;

    /* The Authentication Protocol.  Client sends:
     *
     *   BEGIN AUTH REQUEST\n
     *   <REPOSITORY>\n
     *   <USERNAME>\n
     *   <PASSWORD>\n
     *   END AUTH REQUEST\n
     *
     * Server uses above information to authenticate, then sends
     *
     *   I LOVE YOU\n
     *
     * if it grants access, else
     *
     *   I HATE YOU\n
     *
     * if it denies access (and it exits if denying).
     *
     * When the client is "cvs login", the user does not desire actual
     * repository access, but would like to confirm the password with
     * the server.  In this case, the start and stop strings are
     *
     *   BEGIN VERIFICATION REQUEST\n
     *
     *            and
     *
     *   END VERIFICATION REQUEST\n
     *
     * On a verification request, the server's responses are the same
     * (with the obvious semantics), but it exits immediately after
     * sending the response in both cases.
     *
     * Why is the repository sent?  Well, note that the actual
     * client/server protocol can't start up until authentication is
     * successful.  But in order to perform authentication, the server
     * needs to look up the password in the special CVS passwd file,
     * before trying /etc/passwd.  So the client transmits the
     * repository as part of the "authentication protocol".  The
     * repository will be redundantly retransmitted later, but that's no
     * big deal.
     */

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	(void) setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on);
d4529 4
a4532 1
#endif
d4534 21
a4554 50
    /* Make sure the protocol starts off on the right foot... */
    fgets (tmp, PATH_MAX, stdin);
    if (strcmp (tmp, "BEGIN VERIFICATION REQUEST\n") == 0)
	verify_and_exit = 1;
    else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") != 0)
	error (1, 0, "bad auth protocol start: %s", tmp);

    /* Get the three important pieces of information in order. */
    fgets (repository, PATH_MAX, stdin);
    fgets (username, PATH_MAX, stdin);
    fgets (password, PATH_MAX, stdin);

    /* Make them pure. */ 
    strip_trailing_newlines (repository);
    strip_trailing_newlines (username);
    strip_trailing_newlines (password);

    /* ... and make sure the protocol ends on the right foot. */
    fgets (tmp, PATH_MAX, stdin);
    if (strcmp (tmp,
		verify_and_exit ?
		"END VERIFICATION REQUEST\n" : "END AUTH REQUEST\n")
	!= 0)
    {
	error (1, 0, "bad auth protocol end: %s", tmp);
    }

    /* We need the real cleartext before we hash it. */
    descrambled_password = descramble (password);
    host_user = check_password (username, descrambled_password, repository);
    memset (descrambled_password, 0, strlen (descrambled_password));
    free (descrambled_password);
    if (host_user)
    {
	printf ("I LOVE YOU\n");
	fflush (stdout);
    }
    else
    {
	printf ("I HATE YOU\n");
	fflush (stdout);
	exit (EXIT_FAILURE);
    }

    /* Don't go any farther if we're just responding to "cvs login". */
    if (verify_and_exit)
	exit (0);

    /* Switch to run as this user. */
    switch_to_user (host_user);
a4559 62
#ifdef HAVE_KERBEROS
void
kserver_authenticate_connection ()
{
    int status;
    char instance[INST_SZ];
    struct sockaddr_in peer;
    struct sockaddr_in laddr;
    int len;
    KTEXT_ST ticket;
    AUTH_DAT auth;
    char version[KRB_SENDAUTH_VLEN];
    char user[ANAME_SZ];

    strcpy (instance, "*");
    len = sizeof peer;
    if (getpeername (STDIN_FILENO, (struct sockaddr *) &peer, &len) < 0
	|| getsockname (STDIN_FILENO, (struct sockaddr *) &laddr,
			&len) < 0)
    {
	printf ("E Fatal error, aborting.\n\
error %s getpeername or getsockname failed\n", strerror (errno));
	exit (EXIT_FAILURE);
    }

#ifdef SO_KEEPALIVE
    /* Set SO_KEEPALIVE on the socket, so that we don't hang forever
       if the client dies while we are waiting for input.  */
    {
	int on = 1;

	(void) setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on);
    }
#endif

    status = krb_recvauth (KOPT_DO_MUTUAL, STDIN_FILENO, &ticket, "rcmd",
			   instance, &peer, &laddr, &auth, "", sched,
			   version);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: %s\n", krb_get_err_text(status));
	exit (EXIT_FAILURE);
    }

    memcpy (kblock, auth.session, sizeof (C_Block));

    /* Get the local name.  */
    status = krb_kntoln (&auth, user);
    if (status != KSUCCESS)
    {
	printf ("E Fatal error, aborting.\n\
error 0 kerberos: can't get local name: %s\n", krb_get_err_text(status));
	exit (EXIT_FAILURE);
    }

    /* Switch to run as this user. */
    switch_to_user (user);
}
#endif /* HAVE_KERBEROS */

a4561 393
#if defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT)

/* This global variable is non-zero if the user requests encryption on
   the command line.  */
int cvsencrypt;

#ifdef ENCRYPTION

#ifdef HAVE_KERBEROS

/* An encryption interface using Kerberos.  This is built on top of
   the buffer structure.  We encrypt using a big endian two byte count
   field followed by a block of encrypted data.  */

/* This structure is the closure field of a Kerberos encryption
   buffer.  */

struct krb_encrypt_buffer
{
    /* The underlying buffer.  */
    struct buffer *buf;
    /* The Kerberos key schedule.  */
    Key_schedule sched;
    /* The Kerberos DES block.  */
    C_Block block;
    /* For an input buffer, we may have to buffer up data here.  */
    /* This is non-zero if the buffered data is decrypted.  Otherwise,
       the buffered data is encrypted, and starts with the two byte
       count.  */
    int clear;
    /* The amount of buffered data.  */
    int holdsize;
    /* The buffer allocated to hold the data.  */
    char *holdbuf;
    /* The size of holdbuf.  */
    int holdbufsize;
    /* If clear is set, we need another data pointer to track where we
       are in holdbuf.  If clear is zero, then this pointer is not
       used.  */
    char *holddata;
};

static int krb_encrypt_buffer_input PROTO((void *, char *, int, int, int *));
static int krb_encrypt_buffer_output PROTO((void *, const char *, int, int *));
static int krb_encrypt_buffer_flush PROTO((void *));
static int krb_encrypt_buffer_block PROTO((void *, int));
static int krb_encrypt_buffer_shutdown PROTO((void *));

/* Create an encryption buffer.  */

struct buffer *
krb_encrypt_buffer_initialize (buf, input, sched, block, memory)
     struct buffer *buf;
     int input;
     Key_schedule sched;
     C_Block block;
     void (*memory) PROTO((struct buffer *));
{
    struct krb_encrypt_buffer *kb;

    kb = (struct krb_encrypt_buffer *) xmalloc (sizeof *kb);
    memset (kb, 0, sizeof *kb);

    kb->buf = buf;
    memcpy (kb->sched, sched, sizeof (Key_schedule));
    memcpy (kb->block, block, sizeof (C_Block));
    if (input)
    {
	/* We add some space to the buffer to hold the length.  */
	kb->holdbufsize = BUFFER_DATA_SIZE + 16;
	kb->holdbuf = xmalloc (kb->holdbufsize);
    }

    return buf_initialize (input ? krb_encrypt_buffer_input : NULL,
			   input ? NULL : krb_encrypt_buffer_output,
			   input ? NULL : krb_encrypt_buffer_flush,
			   krb_encrypt_buffer_block,
			   krb_encrypt_buffer_shutdown,
			   memory,
			   kb);
}

/* Input data from a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_input (closure, data, need, size, got)
     void *closure;
     char *data;
     int need;
     int size;
     int *got;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    *got = 0;

    if (kb->holdsize > 0 && kb->clear)
    {
	int copy;

	copy = kb->holdsize;

	if (copy > size)
	{
	    memcpy (data, kb->holddata, size);
	    kb->holdsize -= size;
	    kb->holddata += size;
	    *got = size;
	    return 0;
	}

	memcpy (data, kb->holddata, copy);
	kb->holdsize = 0;
	kb->clear = 0;

	data += copy;
	need -= copy;
	size -= copy;
	*got = copy;
    }

    while (need > 0 || *got == 0)
    {
	int get, status, nread, count, dcount;
	char *bytes;
	char stackoutbuf[BUFFER_DATA_SIZE + 16];
	char *outbuf;

	/* If we don't already have the two byte count, get it.  */
	if (kb->holdsize < 2)
	{
	    get = 2 - kb->holdsize;
	    status = buf_read_data (kb->buf, get, &bytes, &nread);
	    if (status != 0)
	    {
		/* buf_read_data can return -2, but a buffer input
                   function is only supposed to return -1, 0, or an
                   error code.  */
		if (status == -2)
		    status = ENOMEM;
		return status;
	    }

	    if (nread == 0)
	    {
		/* The buffer is in nonblocking mode, and we didn't
                   manage to read anything.  */
		return 0;
	    }

	    if (get == 1)
		kb->holdbuf[1] = bytes[0];
	    else
	    {
		kb->holdbuf[0] = bytes[0];
		if (nread < 2)
		{
		    /* We only got one byte, but we needed two.  Stash
                       the byte we got, and try again.  */
		    kb->holdsize = 1;
		    continue;
		}
		kb->holdbuf[1] = bytes[1];
	    }
	    kb->holdsize = 2;
	}

	/* Read the encrypted block of data.  */

	count = (((kb->holdbuf[0] & 0xff) << 8)
		 + (kb->holdbuf[1] & 0xff));

	if (count + 2 > kb->holdbufsize)
	{
	    char *n;

	    /* This should be impossible, since we should have
	       allocated space for the largest possible block in the
	       initialize function.  However, we handle it just in
	       case something changes in the future, so that a current
	       server can handle a later client.  */

	    n = realloc (kb->holdbuf, count + 2);
	    if (n == NULL)
	    {
		(*kb->buf->memory_error) (kb->buf);
		return ENOMEM;
	    }
	    kb->holdbuf = n;
	    kb->holdbufsize = count + 2;
	}

	get = count - (kb->holdsize - 2);

	status = buf_read_data (kb->buf, get, &bytes, &nread);
	if (status != 0)
	{
	    /* buf_read_data can return -2, but a buffer input
               function is only supposed to return -1, 0, or an error
               code.  */
	    if (status == -2)
		status = ENOMEM;
	    return status;
	}

	if (nread == 0)
	{
	    /* We did not get any data.  Presumably the buffer is in
               nonblocking mode.  */
	    return 0;
	}

	/* FIXME: We could complicate the code here to avoid this
           memcpy in the common case of kb->holdsize == 2 && nread ==
           get.  */
	memcpy (kb->holdbuf + kb->holdsize, bytes, nread);
	kb->holdsize += nread;

	if (nread < get)
	{
	    /* We did not get all the data we need.  buf_read_data
               does not promise to return all the bytes requested, so
               we must try again.  */
	    continue;
	}

	/* We have a complete encrypted block of COUNT bytes at
           KB->HOLDBUF + 2.  Decrypt it.  */

	if (count <= sizeof stackoutbuf)
	    outbuf = stackoutbuf;
	else
	{
	    /* I believe this is currently impossible, but we handle
               it for the benefit of future client changes.  */
	    outbuf = malloc (count);
	    if (outbuf == NULL)
	    {
		(*kb->buf->memory_error) (kb->buf);
		return ENOMEM;
	    }
	}

	des_cbc_encrypt ((C_Block *) (kb->holdbuf + 2), (C_Block *) outbuf,
			 count, kb->sched, &kb->block, 0);

	/* The first two bytes in the decrypted buffer are the real
           (unaligned) length.  */
	dcount = ((outbuf[0] & 0xff) << 8) + (outbuf[1] & 0xff);

	if (((dcount + 2 + 7) & ~7) != count)
	    error (1, 0, "Decryption failure");

	if (dcount > size)
	{
	    /* We have too much data for the buffer.  We need to save
               some of it for the next call.  */

	    memcpy (data, outbuf + 2, size);
	    *got += size;

	    kb->holdsize = dcount - size;
	    memcpy (kb->holdbuf, outbuf + 2 + size, dcount - size);
	    kb->holddata = kb->holdbuf;
	    kb->clear = 1;

	    if (outbuf != stackoutbuf)
		free (outbuf);

	    return 0;
	}

	memcpy (data, outbuf + 2, dcount);

	if (outbuf != stackoutbuf)
	    free (outbuf);

	kb->holdsize = 0;

	data += dcount;
	need -= dcount;
	size -= dcount;
	*got += dcount;
    }

    return 0;
}

/* Output data to a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_output (closure, data, have, wrote)
     void *closure;
     const char *data;
     int have;
     int *wrote;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;
    char inbuf[BUFFER_DATA_SIZE + 16];
    char outbuf[BUFFER_DATA_SIZE + 16];
    int aligned;

    if (have > BUFFER_DATA_SIZE)
    {
	/* It would be easy to malloc a buffer, but I don't think this
           case can ever arise.  */
	abort ();
    }

    inbuf[0] = (have >> 8) & 0xff;
    inbuf[1] = have & 0xff;
    memcpy (inbuf + 2, data, have);

    /* For security against a known plaintext attack, we should
       initialize any padding bytes to random values.  Instead, we
       just pick up whatever is on the stack, which is at least better
       than using zero.  */

    /* Align (have + 2) (plus 2 for the count) to an 8 byte boundary.  */
    aligned = (have + 2 + 7) & ~7;

    /* We use des_cbc_encrypt rather than krb_mk_priv because the
       latter sticks a timestamp in the block, and krb_rd_priv expects
       that timestamp to be within five minutes of the current time.
       Given the way the CVS server buffers up data, that can easily
       fail over a long network connection.  We trust krb_recvauth to
       guard against a replay attack.  */

    des_cbc_encrypt ((C_Block *) inbuf, (C_Block *) (outbuf + 2), aligned,
		     kb->sched, &kb->block, 1);

    outbuf[0] = (aligned >> 8) & 0xff;
    outbuf[1] = aligned & 0xff;

    /* FIXME: It would be more efficient to get des_cbc_encrypt to put
       its output directly into a buffer_data structure, which we
       could then append to kb->buf.  That would save a memcpy.  */

    buf_output (kb->buf, outbuf, aligned + 2);

    *wrote = have;

    /* We will only be here because buf_send_output was called on the
       encryption buffer.  That means that we should now call
       buf_send_output on the underlying buffer.  */
    return buf_send_output (kb->buf);
}

/* Flush data to a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_flush (closure)
     void *closure;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    /* Flush the underlying buffer.  Note that if the original call to
       buf_flush passed 1 for the BLOCK argument, then the buffer will
       already have been set into blocking mode, so we should always
       pass 0 here.  */
    return buf_flush (kb->buf, 0);
}

/* The block routine for a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_block (closure, block)
     void *closure;
     int block;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    if (block)
	return set_block (kb->buf);
    else
	return set_nonblock (kb->buf);
}

/* Shut down a Kerberos encryption buffer.  */

static int
krb_encrypt_buffer_shutdown (closure)
     void *closure;
{
    struct krb_encrypt_buffer *kb = (struct krb_encrypt_buffer *) closure;

    return buf_shutdown (kb->buf);
}

#endif /* HAVE_KERBEROS */
#endif /* ENCRYPTION */
#endif /* defined (CLIENT_SUPPORT) || defined (SERVER_SUPPORT) */

d4563 2
a4564 1
   the first '\0' byte.  */
d4568 1
a4568 1
    const char *str;
d4573 6
d4580 1
a4580 1
    if (error_use_protocol)
d4582 3
a4584 8
	buf_output (saved_output, str, len);
	buf_copy_lines (buf_to_net, saved_output, 'M');
    }
    else if (server_active)
    {
	buf_output (saved_output, str, len);
	buf_copy_lines (protocol, saved_output, 'M');
	buf_send_counted (protocol);
d4591 1
a4591 1
	const char *p = str;
d4595 1
a4595 1
	    written = fwrite (p, 1, to_write, stdout);
d4608 1
a4608 1
    const char *str;
d4613 6
d4620 1
a4620 6
    if (error_use_protocol)
    {
	buf_output (saved_outerr, str, len);
	buf_copy_lines (buf_to_net, saved_outerr, 'E');
    }
    else if (server_active)
d4622 3
a4624 3
	buf_output (saved_outerr, str, len);
	buf_copy_lines (protocol, saved_outerr, 'E');
	buf_send_counted (protocol);
d4631 1
a4631 1
	const char *p = str;
d4635 1
a4635 1
	    written = fwrite (p, 1, to_write, stderr);
a4641 23
}

/* Flush stderr.  stderr is normally flushed automatically, of course,
   but this function is used to flush information from the server back
   to the client.  */

void
cvs_flusherr ()
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* Send a special count to tell the parent to flush.  */
	buf_send_special_count (protocol, -1);
    }
    else
#endif
	fflush (stderr);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a0 10
/* This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

a10 4
#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#endif

d33 1
a33 11

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif
d66 16
a81 14
#ifdef AUTH_SERVER_SUPPORT

/* The cvs username sent by the client, which might or might not be
   the same as the system username the server eventually switches to
   run as.  CVS_Username gets set iff password authentication is
   successful. */
static char *CVS_Username = NULL;

/* Used to check that same repos is transmitted in pserver auth and in
   later CVS protocol.  Exported because root.c also uses. */
char *Pserver_Repos = NULL;

#endif /* AUTH_SERVER_SUPPORT */

d398 1
a398 3
static int supported_response PROTO ((char *));

static int
a450 10
	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

d458 2
d658 1
a658 7
    pending_error_text = malloc (80);
    if (pending_error_text == NULL)
	pending_error = ENOMEM;
    else
	strcpy (pending_error_text,
		"E Repository request is obsolete; aborted");
    return;
d668 1
d1018 1
d1020 7
d1031 37
a1080 5
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;

d1083 11
d1095 11
a1105 15
    /* Rewrite entries file to have `=' in timestamp field.  */
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    timefield = strchr (cp + 1, '/') + 1;
	    if (*timefield != '=')
	    {
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
d1107 8
a1114 2
		    *cp = cp[-1];
		    --cp;
d1116 1
a1116 1
		*timefield = '=';
a1117 1
	    break;
d1340 3
d1353 8
a1360 1
	lock_dir_for_write (repos);
d1368 1
d1393 1
d1395 1
d1644 2
a1645 1
    error_exit ();
a1654 158


/* If command is legal, return 1.
 * Else if command is illegal and croak_on_illegal is set, then die.
 * Else just return 0 to indicate that command is illegal.
 */
static int
check_command_legal_p (char *cmd_name)
{
    /* Right now, only pserver notices illegal commands -- namely,
     * write attempts by a read-only user.  Therefore, if CVS_Username
     * is not set, this just returns 1, because CVS_Username unset
     * means pserver is not active.
     */
#ifdef AUTH_SERVER_SUPPORT
    if (CVS_Username == NULL)
        return 1;

    if (lookup_command_attribute (cmd_name) & CVS_CMD_MODIFIES_REPOSITORY)
    {
        /* This command has the potential to modify the repository, so
         * we check if the user have permission to do that.
         *
         * (Only relevant for remote users -- local users can do
         * whatever normal Unix file permissions allow them to do.)
         *
         * The decision method:
         *
         *    If $CVSROOT/CVSADMROOT_READERS exists and user is listed
         *    in it, then read-only access for user.
         *
         *    Or if $CVSROOT/CVSADMROOT_WRITERS exists and user NOT
         *    listed in it, then also read-only access for user.
         *
         *    Else read-write access for user.
         */

         char *linebuf = NULL;
         int num_red = 0;
         size_t linebuf_len = 0;
         char *fname;
         size_t flen;
         FILE *fp;
         int found_it = 0;
         
         /* else */
         flen = strlen (CVSroot_directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_READERS)
                + 3;

         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", CVSroot_directory,
			CVSROOTADM, CVSROOTADM_READERS);

         fp = fopen (fname, "r");
         free (fname);

         if (fp == NULL)
             goto do_writers;
         else  /* successfully opened readers file */
         {
             while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
             {
                 /* Hmmm, is it worth importing my own readline
                    library into CVS?  It takes care of chopping
                    leading and trailing whitespace, "#" comments, and
                    newlines automatically when so requested.  Would
                    save some code here...  -kff */

                 /* Chop newline by hand, for strcmp()'s sake. */
                 if (linebuf[num_red - 1] == '\n')
                     linebuf[num_red - 1] = '\0';

                 if (strcmp (linebuf, CVS_Username) == 0)
                 {
                     free (linebuf);
                     linebuf = NULL;
                     linebuf_len = 0;
                     goto handle_illegal;
                 }
                 /* else */
                 free (linebuf);
                 linebuf = NULL;
                 linebuf_len = 0;
             }

             /* If not listed specifically as a reader, then this user
                has write access by default unless writers are also
                specified in a file . */
             fclose (fp);
             goto do_writers;
         }

    do_writers:
         
         flen = strlen (CVSroot_directory)
                + strlen (CVSROOTADM)
                + strlen (CVSROOTADM_WRITERS)
                + 3;

         fname = xmalloc (flen);
         (void) sprintf (fname, "%s/%s/%s", CVSroot_directory,
			CVSROOTADM, CVSROOTADM_WRITERS);

         fp = fopen (fname, "r");
         free (fname);

         if (fp == NULL)
         {
             /* writers file does not exist, so everyone is a writer,
                by default */
             return 1;
         }

         /* else */

         found_it = 0;
         while ((num_red = getline (&linebuf, &linebuf_len, fp)) >= 0)
         {
             /* Chop newline by hand, for strcmp()'s sake. */
             if (linebuf[num_red - 1] == '\n')
                 linebuf[num_red - 1] = '\0';
           
             if (strcmp (linebuf, CVS_Username) == 0)
             {
                 free (linebuf);
                 linebuf = NULL;
                 linebuf_len = 0;
                 found_it = 1;
                 break;
             }
             /* else */
             free (linebuf);
             linebuf = NULL;
             linebuf_len = 0;
         }

         if (found_it)
         {
             fclose (fp);
             return 1;
         }
         else   /* writers file exists, but this user not listed in it */
         {
         handle_illegal:
             fclose (fp);
	     return 0;
         }
    }
#endif /* AUTH_SERVER_SUPPORT */

    /* If ever reach end of this function, command must be legal. */
    return 1;
}



d1665 1
a1665 2
do_cvs_command (cmd_name, command)
    char *cmd_name;
a1700 15
    /* Global `command_name' is probably "server" right now -- only
       serve_export() sets it to anything else.  So we will use local
       parameter `cmd_name' to determine if this command is legal for
       this user.  */
    if (!check_command_legal_p (cmd_name))
    {
	buf_output0 (buf_to_net, "E ");
	buf_output0 (buf_to_net, program_name);
	buf_output0 (buf_to_net, " [server aborted]: \"");
	buf_output0 (buf_to_net, cmd_name);
	buf_output0 (buf_to_net, "\" requires write access to the repository\n\
error  \n");
	goto free_args_and_return;
    }

d1736 1
a1736 1
    dev_null_fd = CVS_OPEN (DEVNULL, O_RDONLY);
a2266 3
/* This variable commented in server.h.  */
char *server_dir = NULL;

d2274 1
a2274 1
    if (server_dir != NULL)
d2276 5
a2280 2
	buf_output0 (protocol, server_dir);
	buf_output0 (protocol, "/");
a2281 5
    if (update_dir[0] == '\0')
	buf_output0 (protocol, ".");
    else
	buf_output0 (protocol, update_dir);
    buf_output0 (protocol, "/\n");
a2426 1

d2431 1
a2431 1
    do_cvs_command ("commit", commit);
d2526 1
a2526 1
    do_cvs_command ("update", update);
d2533 1
a2533 1
    do_cvs_command ("diff", diff);
d2540 1
a2540 1
    do_cvs_command ("cvslog", cvslog);
d2547 1
a2547 1
    do_cvs_command ("add", add);
d2554 1
a2554 1
    do_cvs_command ("cvsremove", cvsremove);
d2561 1
a2561 1
    do_cvs_command ("status", status);
d2568 1
a2568 1
    do_cvs_command ("patch", patch);
d2575 1
a2575 1
    do_cvs_command ("cvstag", cvstag);
d2582 1
a2582 1
    do_cvs_command ("rtag", rtag);
d2589 1
a2589 1
    do_cvs_command ("import", import);
d2596 1
a2596 1
    do_cvs_command ("admin", admin);
d2603 1
a2603 1
    do_cvs_command ("history", history);
d2610 1
a2610 1
    do_cvs_command ("release", release);
d2619 1
a2619 1
    do_cvs_command ("watch_on", watch_on);
d2628 1
a2628 1
    do_cvs_command ("watch_off", watch_off);
d2637 1
a2637 1
    do_cvs_command ("watch_add", watch_add);
d2646 1
a2646 1
    do_cvs_command ("watch_remove", watch_remove);
d2655 1
a2655 1
    do_cvs_command ("watchers", watchers);
d2664 1
a2664 1
    do_cvs_command ("editors", editors);
d2683 1
a2683 1
    do_cvs_command ("noop", noop);
d2694 1
a2694 1
    do_cvs_command ("init", init);
d2703 1
a2703 1
    do_cvs_command ("annotate", annotate);
d2752 1
a2752 9

    /* Compensate for server_export()'s setting of command_name.
     *
     * [It probably doesn't matter if do_cvs_command() gets "export"
     *  or "checkout", but we ought to be accurate where possible.]
     */
    do_cvs_command ((strcmp (command_name, "export") == 0) ?
                    "export" : "checkout",
                    checkout);
d2872 3
a2874 2
	       (set in .bashrc if rsh is in use) affects what mode we
	       send, and it shouldn't.  */
d3250 5
d3393 1
a3393 1
  REQ_LINE("Directory", serve_directory, rq_essential),
d3401 1
a3401 4

  /* The client must send this request to interoperate with CVS 1.5
     through 1.9 servers.  The server must support it (although it can
     be and is a noop) to interoperate with CVS 1.5 to 1.9 clients.  */
d3403 1
a3403 2

  REQ_LINE("Unchanged", serve_unchanged, rq_essential),
a3685 11

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

a3717 2
	    int status;

a3726 12

		/* I'm doing this manually rather than via error_exit ()
		   because I'm not sure whether we want to call server_cleanup.
		   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
		/* Hook for OS-specific behavior, for example socket
		   subsystems on NT and OS2 or dealing with windows
		   and arguments on Mac.  */
		SYSTEM_CLEANUP ();
#endif

a3746 16

	    /* Create the temporary directory, and set the mode to
               700, to discourage random people from tampering with
               it.  */
	    status = mkdir_p (server_temp_dir);
	    if (status == EEXIST)
		status = 0;
#ifndef CHMOD_BROKEN
	    if (status == 0)
		status = chmod (server_temp_dir, S_IRWXU);
#endif
	    if (status != 0)
	    {
		pending_error_text = "E can't create temporary directory";
		pending_error = status;
	    }
a3749 1
#ifdef SIGHUP
a3750 2
#endif
#ifdef SIGINT
a3751 2
#endif
#ifdef SIGQUIT
a3752 2
#endif
#ifdef SIGPIPE
a3753 2
#endif
#ifdef SIGTERM
d3755 1
a3755 2
#endif

a3769 11

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

a3851 10
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

d3873 3
a3875 4
    /* We don't want our umask to change file modes.  The modes should
       be set by the modes used in the repository, and by the umask of
       the client.  */
    umask (0);
a3903 6
 *
 * If success, host_user_ptr will be set to point at the system
 * username (i.e., the "real" identity, which may or may not be the
 * CVS username) of this user; caller may free this.  Global
 * CVS_Username will point at an allocated copy of cvs username (i.e.,
 * the username argument below).
a3916 5
    /* We don't use CVSroot_directory because it hasn't been set yet
     * -- our `repository' argument came from the authentication
     * protocol, not the regular CVS protocol.
     */

d3919 1
a3919 1
			+ strlen (CVSROOTADM)
d3921 1
a3921 1
			+ strlen (CVSROOTADM_PASSWD)
d3924 3
a3926 2
    (void) sprintf (filename, "%s/%s/%s", repository,
                    CVSROOTADM, CVSROOTADM_PASSWD);
d3957 1
a3957 1
	char *found_password, *host_user_tmp;
d3961 2
a3962 4
	host_user_tmp = strtok (NULL, ": \n");
	if (host_user_tmp == NULL)
            host_user_tmp = username;

a3963 5
        {
            /* Give host_user_ptr permanent storage. */
            *host_user_ptr = xmalloc (strlen (host_user_tmp) + 1);
            strcpy (*host_user_ptr, host_user_tmp);

a3964 1
        }
d3966 1
a3966 4
        {
            *host_user_ptr = NULL;
	    retval         = 2;
        }
d3986 1
a3986 1
    char *host_user = NULL;
a3994 5
    if (rc == 2)
	return NULL;

    /* else */

d3996 3
a3998 4
    {
        /* host_user already set by reference, so just return. */
        goto handle_return;
    }
a4025 11

	    /* I'm doing this manually rather than via error_exit ()
	       because I'm not sure whether we want to call server_cleanup.
	       Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	    /* Hook for OS-specific behavior, for example socket subsystems on
	       NT and OS2 or dealing with windows and arguments on Mac.  */
	    SYSTEM_CLEANUP ();
#endif

d4030 2
a4031 6
        {
	    host_user = ((! strcmp (found_passwd,
                                    crypt (password, found_passwd)))
                         ? username : NULL);
            goto handle_return;
        }
d4033 1
a4033 4
        {
	    host_user = username;
            goto handle_return;
        }
d4035 1
a4035 4
        {
	    host_user = NULL;
            goto handle_return;
        }
d4041 1
a4041 2
	host_user = NULL;
        goto handle_return;
a4042 11

handle_return:
    if (host_user)
    {
        /* Set CVS_Username here, in allocated space. 
           It might or might not be the same as host_user. */
        CVS_Username = xmalloc (strlen (username) + 1);
        strcpy (CVS_Username, username);
    }

    return host_user;
a4152 10
	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

a4157 7
    {
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif

a4158 6
    }

    /* Set Pserver_Repos so that we can check later that the same
       repository is sent in later client/server protocol. */
    Pserver_Repos = xmalloc (strlen (repository) + 1);
    strcpy (Pserver_Repos, repository);
a4188 5
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
a4209 5
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
a4220 5
#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
a4691 6
	/* Make sure that output appears in order if stdout and stderr
	   point to the same place.  For the server case this is taken
	   care of by the fact that saved_outerr always holds less
	   than a line.  */
	fflush (stdout);

a4723 26
}

/* Make it possible for the user to see what has been written to
   stdout (it is up to the implementation to decide exactly how far it
   should go to ensure this).  */

void
cvs_flushout ()
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol)
    {
	/* Flush what we can to the network, but don't block.  */
	buf_flush (buf_to_net, 0);
    }
    else if (server_active)
    {
	/* Just do nothing.  This is because the code which
	   cvs_flushout replaces, setting stdout to line buffering in
	   main.c, didn't get called in the server child process.  But
	   in the future it is quite plausible that we'll want to make
	   this case work analogously to cvs_flusherr.  */
    }
    else
#endif
	fflush (stdout);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d63 4
a320 2
    retval = 0;

d336 2
a337 4
		int saved_errno = errno;

		if (saved_errno != EEXIST
		    && (saved_errno != EACCES || !isdir (q)))
d339 1
a339 1
		    retval = saved_errno;
d349 2
a418 22

static int alloc_pending PROTO ((size_t size));

/* Allocate SIZE bytes for pending_error_text and return nonzero
   if we could do it.  */
static int
alloc_pending (size)
    size_t size;
{
    if (error_pending ())
	/* Probably alloc_pending callers will have already checked for
	   this case.  But we might as well handle it if they don't, I
	   guess.  */
	return 0;
    pending_error_text = malloc (size);
    if (pending_error_text == NULL)
    {
	pending_error = ENOMEM;
	return 0;
    }
    return 1;
}
d497 1
a497 1
    char *path;
a501 7
    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	return;
    }
d503 1
a503 5

    path = xmalloc (strlen (CVSroot_directory)
		    + sizeof (CVSROOTADM)
		    + sizeof (CVSROOTADM_HISTORY)
		    + 10);
a523 1
    free (path);
d601 2
a602 2
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot mkdir %s", dir_name);
d614 2
a615 2
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot change to %s", dir_name);
d673 2
a674 2
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
d680 2
a681 2
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
d749 2
a750 2
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_ENTSTAT);
d756 2
a757 2
	if (alloc_pending (80 + strlen (CVSADM_ENTSTAT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENTSTAT);
d774 2
a775 2
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_TAG);
d781 2
a782 2
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_TAG);
d788 2
a789 2
	if (alloc_pending (80 + strlen (CVSADM_TAG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_TAG);
d1156 2
a1157 2
	    if (alloc_pending (80 + strlen (CVSADM_ENT)))
		sprintf (pending_error_text, "E cannot open %s", CVSADM_ENT);
d1167 2
a1168 3
		if (alloc_pending (80 + strlen(CVSADM_ENT)))
		    sprintf (pending_error_text,
			     "E cannot write to %s", CVSADM_ENT);
d1180 2
a1181 2
	if (alloc_pending (80 + strlen (CVSADM_ENT)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_ENT);
d1438 3
a1440 4
	if (alloc_pending (strlen (arg) + 80))
	    sprintf (pending_error_text,
		     "E Protocol error: bad global option %s",
		     arg);
d1633 1
a1633 2
check_command_legal_p (cmd_name)
    char *cmd_name;
a2842 8
    if (!isabsolute (arg))
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Root %s must be an absolute pathname", arg);
	/* Fall through to do_cvs_command which will return the
	   actual error.  */
    }
a3002 3
	    Node *node;
	    Entnode *entnode;

a3013 8

	    /* Now munge the entries to say that the file is unmodified,
	       in case we end up processing it again (e.g. modules3-6
	       in the testsuite).  */
	    node = findnode_fn (finfo->entries, finfo->file);
	    entnode = (Entnode *)node->data;
	    free (entnode->timestamp);
	    entnode->timestamp = xstrdup ("=");
d3474 2
a3475 2
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_CIPROG);
d3481 2
a3482 3
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text,
		     "E cannot write to %s", CVSADM_CIPROG);
d3488 2
a3489 2
	if (alloc_pending (80 + strlen (CVSADM_CIPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_CIPROG);
d3503 2
a3504 2
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot open %s", CVSADM_UPROG);
d3510 2
a3511 2
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot write to %s", CVSADM_UPROG);
d3517 2
a3518 2
	if (alloc_pending (80 + strlen (CVSADM_UPROG)))
	    sprintf (pending_error_text, "E cannot close %s", CVSADM_UPROG);
d3934 7
a3940 1
	    if (status != 0 && status != EEXIST)
d3942 1
a3942 3
		if (alloc_pending (80))
		    strcpy (pending_error_text,
			    "E can't create temporary directory");
a3944 13
#ifndef CHMOD_BROKEN
	    else
	    {
		if (chmod (server_temp_dir, S_IRWXU) < 0)
		{
		    int save_errno = errno;
		    if (alloc_pending (80))
			strcpy (pending_error_text, "\
E cannot change permissions on temporary directory");
		    pending_error = save_errno;
		}
	    }
#endif
d4341 4
a4344 9
    char *tmp = NULL;
    size_t tmp_allocated = 0;
    char *repository = NULL;
    size_t repository_allocated = 0;
    char *username = NULL;
    size_t username_allocated = 0;
    char *password = NULL;
    size_t password_allocated = 0;

d4403 1
a4403 6
    if (getline (&tmp, &tmp_allocated, stdin) < 0)
	/* FIXME: what?  We could try writing error/eof, but chances
	   are the network connection is dead bidirectionally.  log it
	   somewhere?  */
	;

d4410 3
a4412 4
    /* See above comment about error handling.  */
    getline (&repository, &repository_allocated, stdin);
    getline (&username, &username_allocated, stdin);
    getline (&password, &password_allocated, stdin);
d4420 1
a4420 2
    /* See above comment about error handling.  */
    getline (&tmp, &tmp_allocated, stdin);
a4474 4
    free (tmp);
    free (repository);
    free (username);
    free (password);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a1100 2
static void serve_unchanged PROTO ((char *));

a1138 62
static void serve_is_modified PROTO ((char *));

static void
serve_is_modified (arg)
    char *arg;
{
    struct an_entry *p;
    char *name;
    char *cp;
    char *timefield;
    /* Have we found this file in "entries" yet.  */
    int found;

    if (error_pending ())
	return;

    /* Rewrite entries file to have `M' in timestamp field.  */
    found = 0;
    for (p = entries; p != NULL; p = p->next)
    {
	name = p->entry + 1;
	cp = strchr (name, '/');
	if (cp != NULL
	    && strlen (arg) == cp - name
	    && strncmp (arg, name, cp - name) == 0)
	{
	    timefield = strchr (cp + 1, '/') + 1;
	    if (!(timefield[0] == 'M' && timefield[1] == '/'))
	    {
		cp = timefield + strlen (timefield);
		cp[1] = '\0';
		while (cp > timefield)
		{
		    *cp = cp[-1];
		    --cp;
		}
		*timefield = 'M';
	    }
	    found = 1;
	    break;
	}
    }
    if (!found)
    {
	/* We got Is-modified but no Entry.  Add a dummy entry.
	   The "D" timestamp is what makes it a dummy.  */
	struct an_entry *p;
	p = (struct an_entry *) malloc (sizeof (struct an_entry));
	if (p == NULL)
	{
	    pending_error = ENOMEM;
	    return;
	}
	p->entry = xmalloc (strlen (arg) + 80);
	strcpy (p->entry, "/");
	strcat (p->entry, arg);
	strcat (p->entry, "//D//");
	p->next = entries;
	entries = p;
    }
}

d3244 1
a3244 1
server_set_sticky (update_dir, repository, tag, date, nonbranch)
a3248 1
    int nonbranch;
d3274 1
a3274 4
	    if (nonbranch)
		buf_output0 (protocol, "N");
	    else
		buf_output0 (protocol, "T");
d3600 1
a3600 1
  REQ_LINE("Repository", serve_repository, rq_optional),
a3608 1
  REQ_LINE("Is-modified", serve_is_modified, rq_optional),
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d92 1
a92 1
char *CVS_Username = NULL;
a568 22

static int max_dotdot_limit = 0;

/* Is this pathname OK to recurse into when we are running as the server?
   If not, call error() with a fatal error.  */
void
server_pathname_check (path)
    char *path;
{
    /* An absolute pathname is almost surely a path on the *client* machine,
       and is unlikely to do us any good here.  It also is probably capable
       of being a security hole in the anonymous readonly case.  */
    if (isabsolute (path))
	error (1, 0, "absolute pathname `%s' illegal for server", path);
    if (pathname_levels (path) > max_dotdot_limit)
    {
	/* Similar to the isabsolute case in security implications.  */
	error (0, 0, "protocol error: `%s' contains more leading ..", path);
	error (1, 0, "than the %d which Max-dotdot specified",
	       max_dotdot_limit);
    }
}
a596 1
    max_dotdot_limit = lim;
a616 13
    /* Check for a trailing '/'.  This is not ISDIRSEP because \ in the
       protocol is an ordinary character, not a directory separator (of
       course, it is perhaps unwise to use it in directory names, but that
       is another issue).  */
    if (strlen (dir) > 0
	&& dir[strlen (dir) - 1] == '/')
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E protocol error: illegal directory syntax in %s", dir);
	return;
    }

d1800 4
d1805 5
a1836 2
	     if (linebuf)
	         free (linebuf);
d1851 3
d1857 4
a1865 2
             if (linebuf)
                 free (linebuf);
a1871 2
             if (linebuf)
                 free (linebuf);
a3049 36
server_modtime (finfo, vers_ts)
    struct file_info *finfo;
    Vers_TS *vers_ts;
{
    char date[MAXDATELEN];
    int year, month, day, hour, minute, second;
    /* Note that these strings are specified in RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    if (!supported_response ("Mod-time"))
	return;

    /* The only hard part about this routine is converting the date
       formats.  In terms of functionality it all boils down to the
       call to RCS_getrevtime.  */
    if (RCS_getrevtime (finfo->rcs, vers_ts->vn_rcs, date, 0) == (time_t) -1)
	/* FIXME? should we be printing some kind of warning?  For one
	   thing I'm not 100% sure whether this happens in non-error
	   circumstances.  */
	return;

    sscanf (date, SDATEFORM, &year, &month, &day, &hour, &minute, &second);
    sprintf (date, "%d %s %d %d:%d:%d -0000", day,
	     month < 1 || month > 12 ? "???" : month_names[month - 1],
	     year, hour, minute, second);
    buf_output0 (protocol, "Mod-time ");
    buf_output0 (protocol, date);
    buf_output0 (protocol, "\n");
}

/* See server.h for description.  */

void
a3136 2
	else if (updated == SERVER_RCS_DIFF)
	    buf_output0 (protocol, "Rcs-diff ");
d3234 1
a3234 3
	if ((updated == SERVER_UPDATED
	     || updated == SERVER_PATCHED
	     || updated == SERVER_RCS_DIFF)
a3271 8
/* Return whether we should send patches in RCS format.  */

int
server_use_rcs_diff ()
{
    return supported_response ("Rcs-diff");
}

a3621 13

    /* Before we do anything we need to make sure we are not in readonly
       mode.  */
    if (!check_command_legal_p ("commit"))
    {
	/* I might be willing to make this a warning, except we lack the
	   machinery to do so.  */
	if (alloc_pending (80))
	    sprintf (pending_error_text, "\
E Flag -u in modules not allowed in readonly mode");
	return;
    }

d4319 2
d4341 3
a4343 1
            *host_user_ptr = xstrdup (host_user_tmp);
a4358 2
    if (linebuf)
        free (linebuf);
a4572 8
    if (!root_allow_ok (repository))
	/* At least for the moment I'm going to do the paranoid
	   security thing and not tell them how it failed.  I'm not
	   sure that is a good idea; it is a real pain when one needs
	   to track down what is going on for legitimate reasons.
	   The other issue is that the protocol doesn't really have
	   a good way for anything other than I HATE YOU.  */
	goto i_hate_you;
a4585 1
    i_hate_you:
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d25 1
a25 1
#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
d30 5
a34 5
#  include <netinet/in.h>
#  include <krb.h>
#  ifndef HAVE_KRB_GET_ERR_TEXT
#    define krb_get_err_text(status) krb_err_txt[status]
#  endif
a41 28
#ifdef HAVE_GSSAPI

#include <netdb.h>
#include <gssapi/gssapi.h>
#include <gssapi/gssapi_generic.h>

/* We use Kerberos 5 routines to map the GSSAPI credential to a user
   name.  */
#include <krb5.h>

/* We need this to wrap data.  */
static gss_ctx_id_t gcontext;

static void gserver_authenticate_connection PROTO((void));

/* Whether we are already wrapping GSSAPI communication.  */
static int cvs_gssapi_wrapping;

#  ifdef ENCRYPTION
/* Whether to encrypt GSSAPI communication.  We use a global variable
   like this because we use the same buffer type (gssapi_wrap) to
   handle both authentication and encryption, and we don't want
   multiple instances of that buffer in the communication stream.  */
int cvs_gssapi_encrypt;
#  endif

#endif

a78 2
#endif /* AUTH_SERVER_SUPPORT */

d83 2
a97 4
/* Should we check for system usernames/passwords?  Can be changed by
   CVSROOT/config.  */
int system_auth = 1;

d332 1
a332 1
	    if (q[p - dir - 1] != '/'  &&  CVS_MKDIR (q, 0777) < 0)
a439 2
static void serve_is_modified PROTO ((char *));

a528 18

    /* Sending "Root" twice is illegal.  It would also be nice to
       check for the other case, in which there is no Root request
       prior to a request which requires one.

       The other way to handle a duplicate Root requests would be as a
       request to clear out all state and start over as if it was a
       new connection.  Doing this would cause interoperability
       headaches, so it should be a different request, if there is
       any reason why such a feature is needed.  */
    if (CVSroot_directory != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E Protocol error: Duplicate Root request, for %s", arg);
	return;
    }

a530 4
    /* For pserver, this will already have happened, and the call will do
       nothing.  But for rsh, we need to do it now.  */
    parse_config (CVSroot_directory);

a631 1
    size_t dir_len;
a639 2
    dir_len = strlen (dir);

d644 2
a645 2
    if (dir_len > 0
	&& dir[dir_len - 1] == '/')
d647 1
a647 1
	if (alloc_pending (80 + dir_len))
d649 1
a649 1
		     "E protocol error: invalid directory syntax in %s", dir);
d653 1
a653 1
    dir_name = malloc (strlen (server_temp_dir) + dir_len + 40);
a673 6
    /* Note that this call to Subdir_Register will be a noop if the parent
       directory does not yet exist (for example, if the client sends
       "Directory foo" followed by "Directory .", then the subdirectory does
       not get registered, but if the client sends "Directory ." followed
       by "Directory foo", then the subdirectory does get registered.
       This seems pretty fishy, but maybe it is the way it needs to work.  */
a776 18
	/* I think isabsolute (repos) should always be true, and that
	   any RELATIVE_REPOS stuff should only be in CVS/Repository
	   files, not the protocol (for compatibility), but I'm putting
	   in the in isabsolute check just in case.  */
	if (isabsolute (repos)
	    && strncmp (CVSroot_directory,
			repos,
			strlen (CVSroot_directory)) != 0)
	{
	    if (alloc_pending (strlen (CVSroot_directory)
			       + strlen (repos)
			       + 80))
		sprintf (pending_error_text, "\
E protocol error: directory '%s' not within root '%s'",
			 repos, CVSroot_directory);
	    return;
	}

a1006 5
/* Kopt for the next file sent in Modified or Is-modified.  */
static char *kopt;

static void serve_modified PROTO ((char *));

a1120 7

    /* Make sure that the Entries indicate the right kopt.  We probably
       could do this even in the non-kopt case and, I think, save a stat()
       call in time_stamp_server.  But for conservatism I'm leaving the
       non-kopt case alone.  */
    if (kopt != NULL)
	serve_is_modified (arg);
d1177 2
a1214 10
	    if (kopt != NULL)
	    {
		if (alloc_pending (strlen (name) + 80))
		    sprintf (pending_error_text,
			     "E protocol error: both Kopt and Entry for %s",
			     arg);
		free (kopt);
		kopt = NULL;
		return;
	    }
d1223 1
d1230 1
a1230 7
	p->entry = malloc (strlen (arg) + 80);
	if (p->entry == NULL)
	{
	    pending_error = ENOMEM;
	    free (p);
	    return;
	}
d1233 1
a1233 8
	strcat (p->entry, "//D/");
	if (kopt != NULL)
	{
	    strcat (p->entry, kopt);
	    free (kopt);
	    kopt = NULL;
	}
	strcat (p->entry, "/");
a1238 2
static void serve_entry PROTO ((char *));

a1264 39
static void serve_kopt PROTO ((char *));

static void
serve_kopt (arg)
     char *arg;
{
    if (error_pending ())
	return;

    if (kopt != NULL)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Kopt request: %s", arg);
	return;
    }

    /* Do some sanity checks.  In particular, that it is not too long.
       This lets the rest of the code not worry so much about buffer
       overrun attacks.  Probably should call RCS_check_kflag here,
       but that would mean changing RCS_check_kflag to handle errors
       other than via exit(), fprintf(), and such.  */
    if (strlen (arg) > 10)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: invalid Kopt request: %s", arg);
	return;
    }

    kopt = malloc (strlen (arg) + 1);
    if (kopt == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (kopt, arg);
}

a1611 1

a1628 35

#ifdef HAVE_GSSAPI

static void
serve_gssapi_encrypt (arg)
     char *arg;
{
    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for stream
           authentication.  Flush everything we've output so far, and
           turn on encryption for future data.  On the input side, we
           should only have unwrapped as far as the Gssapi-encrypt
           command, so future unwrapping will become encrypted.  */
	buf_flush (buf_to_net, 1);
	cvs_gssapi_encrypt = 1;
	return;
    }

    /* All future communication with the client will be encrypted.  */

    cvs_gssapi_encrypt = 1;

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */

a1629 26

#ifdef HAVE_GSSAPI

static void
serve_gssapi_authenticate (arg)
     char *arg;
{
    if (cvs_gssapi_wrapping)
    {
	/* We're already using a gssapi_wrap buffer for encryption.
           That includes authentication, so we don't have to do
           anything further.  */
	return;
    }

    buf_to_net = cvs_gssapi_wrap_buffer_initialize (buf_to_net, 0,
						    gcontext,
						    buf_to_net->memory_error);
    buf_from_net = cvs_gssapi_wrap_buffer_initialize (buf_from_net, 1,
						      gcontext,
						      buf_from_net->memory_error);

    cvs_gssapi_wrapping = 1;
}

#endif /* HAVE_GSSAPI */
d1817 1
d1820 1
a1820 10
	 {
	     if (!existence_error (errno))
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot open %s", fname);
		 free (fname);
		 return 0;
	     }
	 }
a1837 2
	     if (num_red < 0 && !feof (fp))
		 error (0, errno, "cannot read %s", fname);
d1842 2
a1843 2
	     if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
a1844 3
	 free (fname);

	 /* Now check the writers file.  */
d1846 2
d1858 1
d1862 2
d1866 1
a1866 15
	     if (existence_error (errno))
	     {
		 /* Writers file does not exist, so everyone is a writer,
		    by default.  */
		 free (fname);
		 return 1;
	     }
	     else
	     {
		 /* Need to deny access, so that attackers can't fool
		    us with some sort of denial of service attack.  */
		 error (0, errno, "cannot read %s", fname);
		 free (fname);
		 return 0;
	     }
d1869 2
a1883 2
	 if (num_red < 0 && !feof (fp))
	     error (0, errno, "cannot read %s", fname);
d1887 1
a1887 2
             if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
a1889 1
	     free (fname);
d1895 1
a1895 2
             if (fclose (fp) < 0)
		 error (0, errno, "cannot close %s", fname);
a1897 1
	     free (fname);
d2816 1
a2816 1
    do_cvs_command ("log", cvslog);
a3087 2
    assert (vers_ts->vn_rcs != NULL);

a3119 10
    {
	/* Hmm, maybe if we did the same thing for entries_file, we
	   could get rid of the kludges in server_register and
	   server_scratch which refrain from warning if both
	   Scratch_Entry and Register get called.  Maybe.  */
	if (scratched_file)
	{
	    free (scratched_file);
	    scratched_file = NULL;
	}
a3120 1
    }
a3525 32
/* Tell the client about RCS options set in CVSROOT/cvswrappers. */
static void
serve_wrapper_sendme_rcs_options (arg)
     char *arg;
{
    /* Actually, this is kind of sdrawkcab-ssa: the client wants
     * verbatim lines from a cvswrappers file, but the server has
     * already parsed the cvswrappers file into the wrap_list struct.
     * Therefore, the server loops over wrap_list, unparsing each
     * entry before sending it.
     */
    char *wrapper_line = NULL;

    wrap_setup ();

    for (wrap_unparse_rcs_options (&wrapper_line, 1);
         wrapper_line;
         wrap_unparse_rcs_options (&wrapper_line, 0))
    {
	buf_output0 (buf_to_net, "Wrapper-rcsOption ");
	buf_output0 (buf_to_net, wrapper_line);
	buf_output0 (buf_to_net, "\012");;
	free (wrapper_line);
    }

    buf_output0 (buf_to_net, "ok\012");

    /* The client is waiting for us, so we better send the data now.  */
    buf_flush (buf_to_net, 1);
}


a3561 5
	if (server_dir != NULL)
	{
	    buf_output0 (buf_to_net, server_dir);
	    buf_output0 (buf_to_net, "/");
	}
a3576 5
	    if (server_dir != NULL)
	    {
		buf_output0 (buf_to_net, server_dir);
		buf_output0 (buf_to_net, "/");
	    }
a3584 5
		if (server_dir != NULL)
		{
		    buf_output0 (buf_to_net, server_dir);
		    buf_output0 (buf_to_net, "/");
		}
a3762 1
  REQ_LINE("Kopt", serve_kopt, rq_optional),
a3778 3
  REQ_LINE("wrapper-sendme-rcsOptions",
           serve_wrapper_sendme_rcs_options,
           rq_optional),
d3781 1
a3781 1
#  ifdef HAVE_KERBEROS
a3782 4
#  endif
#  ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-encrypt", serve_gssapi_encrypt, rq_optional),
#  endif
a3783 2
#ifdef HAVE_GSSAPI
  REQ_LINE("Gssapi-authenticate", serve_gssapi_authenticate, rq_optional),
d4027 44
d4223 2
d4277 1
a4277 1
#if defined (HAVE_KERBEROS) || defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)
a4303 9
    /* FIXME?  We don't check for errors from initgroups, setuid, &c.
       I think this mainly would come up if someone is trying to run
       the server as a non-root user.  I think we should be checking for
       errors and aborting (as with the error above from getpwnam) if
       there is an error (presumably EPERM).  That means that pserver
       should continue to work right if all of the "system usernames"
       in CVSROOT/passwd match the user which the server is being run
       as (in inetd.conf), but fail otherwise.  */

d4474 1
a4474 1
    else if (rc == 0 && system_auth)
a4532 21
    else if (rc == 0)
    {
	/* Note that the message _does_ distinguish between the case in
	   which we check for a system password and the case in which
	   we do not.  It is a real pain to track down why it isn't
	   letting you in if it won't say why, and I am not convinced
	   that the potential information disclosure to an attacker
	   outweighs this.  */
	printf ("error 0 no such user %s in CVSROOT/passwd\n", username);

	/* I'm doing this manually rather than via error_exit ()
	   because I'm not sure whether we want to call server_cleanup.
	   Needs more investigation....  */

#ifdef SYSTEM_CLEANUP
	/* Hook for OS-specific behavior, for example socket subsystems on
	   NT and OS2 or dealing with windows and arguments on Mac.  */
	SYSTEM_CLEANUP ();
#endif
	exit (EXIT_FAILURE);
    }
a4552 4
#endif /* AUTH_SERVER_SUPPORT */

#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)

a4560 1
#ifdef AUTH_SERVER_SUPPORT
a4569 1
#endif /* AUTH_SERVER_SUPPORT */
d4634 1
a4634 13
    else if (strcmp (tmp, "BEGIN AUTH REQUEST\n") == 0)
	;
    else if (strcmp (tmp, "BEGIN GSSAPI REQUEST\n") == 0)
    {
#ifdef HAVE_GSSAPI
	free (tmp);
	gserver_authenticate_connection ();
	return;
#else
	error (1, 0, "GSSAPI authentication not supported by this server");
#endif
    }
    else
a4636 6
#ifndef AUTH_SERVER_SUPPORT

    error (1, 0, "Password authentication not supported by this server");

#else /* AUTH_SERVER_SUPPORT */

d4659 6
a4664 6
	/* Just give a generic I HATE YOU.  This is because CVS 1.9.10
	   and older clients do not support "error".  Once more recent
	   clients are more widespread, probably want to fix this (it is
	   a real pain to track down why it isn't letting you in if it
	   won't say why, and I am not convinced that the potential
	   information disclosure to an attacker outweighs this).  */
a4666 7
    /* OK, now parse the config file, so we can use it to control how
       to check passwords.  If there was an error parsing the config
       file, parse_config already printed an error.  We keep going.
       Why?  Because if we didn't, then there would be no way to check
       in a new CVSROOT/config file to fix the broken one!  */
    parse_config (repository);

d4718 1
a4720 3
}

#endif /* AUTH_SERVER_SUPPORT || HAVE_GSSAPI */
a4799 116
#ifdef HAVE_GSSAPI

#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN (256)
#endif

/* Authenticate a GSSAPI connection.  This is called from
   pserver_authenticate_connection, and it handles success and failure
   the same way.  */

static void
gserver_authenticate_connection ()
{
    char hostname[MAXHOSTNAMELEN];
    struct hostent *hp;
    gss_buffer_desc tok_in, tok_out;
    char buf[1024];
    OM_uint32 stat_min, ret;
    gss_name_t server_name, client_name;
    gss_cred_id_t server_creds;
    int nbytes;
    gss_OID mechid;

    gethostname (hostname, sizeof hostname);
    hp = gethostbyname (hostname);
    if (hp == NULL)
	error (1, 0, "can't get canonical hostname");

    sprintf (buf, "cvs@@%s", hp->h_name);
    tok_in.value = buf;
    tok_in.length = strlen (buf);

    if (gss_import_name (&stat_min, &tok_in, gss_nt_service_name,
			 &server_name) != GSS_S_COMPLETE)
	error (1, 0, "could not import GSSAPI service name %s", buf);

    /* Acquire the server credential to verify the client's
       authentication.  */
    if (gss_acquire_cred (&stat_min, server_name, 0, GSS_C_NULL_OID_SET,
			  GSS_C_ACCEPT, &server_creds,
			  NULL, NULL) != GSS_S_COMPLETE)
	error (1, 0, "could not acquire GSSAPI server credentials");

    gss_release_name (&stat_min, &server_name);

    /* The client will send us a two byte length followed by that many
       bytes.  */
    if (fread (buf, 1, 2, stdin) != 2)
	error (1, errno, "read of length failed");

    nbytes = ((buf[0] & 0xff) << 8) | (buf[1] & 0xff);
    assert (nbytes <= sizeof buf);

    if (fread (buf, 1, nbytes, stdin) != nbytes)
	error (1, errno, "read of data failed");

    gcontext = GSS_C_NO_CONTEXT;
    tok_in.length = nbytes;
    tok_in.value = buf;

    if (gss_accept_sec_context (&stat_min,
                                &gcontext,	/* context_handle */
                                server_creds,	/* verifier_cred_handle */
                                &tok_in,	/* input_token */
                                NULL,		/* channel bindings */
                                &client_name,	/* src_name */
                                &mechid,	/* mech_type */
                                &tok_out,	/* output_token */
                                &ret,
                                NULL,	 	/* ignore time_rec */
                                NULL)		/* ignore del_cred_handle */
	!= GSS_S_COMPLETE)
    {
	error (1, 0, "could not verify credentials");
    }

    /* FIXME: Use Kerberos v5 specific code to authenticate to a user.
       We could instead use an authentication to access mapping.  */
    {
	krb5_context kc;
	krb5_principal p;
	gss_buffer_desc desc;

	krb5_init_context (&kc);
	if (gss_display_name (&stat_min, client_name, &desc,
			      &mechid) != GSS_S_COMPLETE
	    || krb5_parse_name (kc, ((gss_buffer_t) &desc)->value, &p) != 0
	    || krb5_aname_to_localname (kc, p, sizeof buf, buf) != 0
	    || krb5_kuserok (kc, p, buf) != TRUE)
	{
	    error (1, 0, "access denied");
	}
	krb5_free_principal (kc, p);
	krb5_free_context (kc);
    }

    if (tok_out.length != 0)
    {
	char cbuf[2];

	cbuf[0] = (tok_out.length >> 8) & 0xff;
	cbuf[1] = tok_out.length & 0xff;
	if (fwrite (cbuf, 1, 2, stdout) != 2
	    || (fwrite (tok_out.value, 1, tok_out.length, stdout)
		!= tok_out.length))
	    error (1, errno, "fwrite failed");
    }

    switch_to_user (buf);

    printf ("I LOVE YOU\n");
    fflush (stdout);
}

#endif /* HAVE_GSSAPI */

d4808 1
a4808 3
/* This global variable is non-zero if the users requests stream
   authentication on the command line.  */
int cvsauthenticate;
d4810 1
a4810 1
#ifdef HAVE_GSSAPI
d4812 3
a4814 2
/* An buffer interface using GSSAPI.  This is built on top of a
   packetizing buffer.  */
d4816 2
a4817 2
/* This structure is the closure field of the GSSAPI translation
   routines.  */
d4819 1
a4819 1
struct cvs_gssapi_wrap_data
d4821 21
a4841 2
    /* The GSSAPI context.  */
    gss_ctx_id_t gcontext;
d4844 5
a4848 3
static int cvs_gssapi_wrap_input PROTO((void *, const char *, char *, int));
static int cvs_gssapi_wrap_output PROTO((void *, const char *, char *, int,
					 int *));
d4850 1
a4850 2
/* Create a GSSAPI wrapping buffer.  We use a packetizing buffer with
   GSSAPI wrapping routines.  */
d4853 1
a4853 1
cvs_gssapi_wrap_buffer_initialize (buf, input, gcontext, memory)
d4856 2
a4857 1
     gss_ctx_id_t gcontext;
d4860 1
a4860 1
    struct cvs_gssapi_wrap_data *gd;
d4862 2
a4863 2
    gd = (struct cvs_gssapi_wrap_data *) xmalloc (sizeof *gd);
    gd->gcontext = gcontext;
d4865 17
a4881 6
    return (packetizing_buffer_initialize
	    (buf,
	     input ? cvs_gssapi_wrap_input : NULL,
	     input ? NULL : cvs_gssapi_wrap_output,
	     gd,
	     memory));
d4884 1
a4884 1
/* Unwrap data using GSSAPI.  */
d4887 4
a4890 4
cvs_gssapi_wrap_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
d4892 1
d4894 1
a4894 5
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf;
d4896 1
a4896 2
    inbuf.value = (void *) input;
    inbuf.length = size;
d4898 1
a4898 2
    if (gss_unwrap (&stat_min, gd->gcontext, &inbuf, &outbuf, &conf, NULL)
	!= GSS_S_COMPLETE)
d4900 21
a4920 1
	error (1, 0, "gss_unwrap failed");
d4923 6
a4928 2
    if (outbuf.length > size)
	abort ();
d4930 14
a4943 1
    memcpy (output, outbuf.value, outbuf.length);
d4945 6
a4950 2
    /* The real packet size is stored in the data, so we don't need to
       remember outbuf.length.  */
d4952 16
a4967 1
    gss_release_buffer (&stat_min, &outbuf);
d4969 1
a4969 2
    return 0;
}
d4971 2
a4972 1
/* Wrap data using GSSAPI.  */
d4974 3
a4976 13
static int
cvs_gssapi_wrap_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
{
    struct cvs_gssapi_wrap_data *gd =
	(struct cvs_gssapi_wrap_data *) fnclosure;
    gss_buffer_desc inbuf, outbuf;
    OM_uint32 stat_min;
    int conf_req, conf;
d4978 5
a4982 2
    inbuf.value = (void *) input;
    inbuf.length = size;
d4984 9
a4992 5
#ifdef ENCRYPTION
    conf_req = cvs_gssapi_encrypt;
#else
    conf_req = 0;
#endif
d4994 1
a4994 10
    if (gss_wrap (&stat_min, gd->gcontext, conf_req, GSS_C_QOP_DEFAULT,
		  &inbuf, &conf, &outbuf) != GSS_S_COMPLETE)
	error (1, 0, "gss_wrap failed");

    /* The packetizing buffer only permits us to add 100 bytes.
       FIXME: I don't know what, if anything, is guaranteed by GSSAPI.
       This may need to be increased for a different GSSAPI
       implementation, or we may need a different algorithm.  */
    if (outbuf.length > size + 100)
	abort ();
d4996 10
a5005 1
    memcpy (output, outbuf.value, outbuf.length);
d5007 6
a5012 1
    *translated = outbuf.length;
d5014 5
a5018 1
    gss_release_buffer (&stat_min, &outbuf);
d5020 7
a5026 2
    return 0;
}
d5028 2
a5029 1
#endif /* HAVE_GSSAPI */
d5031 13
a5043 1
#ifdef ENCRYPTION
d5045 2
a5046 1
#ifdef HAVE_KERBEROS
d5048 3
a5050 2
/* An encryption interface using Kerberos.  This is built on top of a
   packetizing buffer.  */
d5052 2
a5053 2
/* This structure is the closure field of the Kerberos translation
   routines.  */
d5055 4
a5058 7
struct krb_encrypt_data
{
    /* The Kerberos key schedule.  */
    Key_schedule sched;
    /* The Kerberos DES block.  */
    C_Block block;
};
d5060 2
a5061 3
static int krb_encrypt_input PROTO((void *, const char *, char *, int));
static int krb_encrypt_output PROTO((void *, const char *, char *, int,
				     int *));
d5063 4
a5066 2
/* Create a Kerberos encryption buffer.  We use a packetizing buffer
   with Kerberos encryption translation routines.  */
d5068 2
a5069 9
struct buffer *
krb_encrypt_buffer_initialize (buf, input, sched, block, memory)
     struct buffer *buf;
     int input;
     Key_schedule sched;
     C_Block block;
     void (*memory) PROTO((struct buffer *));
{
    struct krb_encrypt_data *kd;
d5071 2
a5072 3
    kd = (struct krb_encrypt_data *) xmalloc (sizeof *kd);
    memcpy (kd->sched, sched, sizeof (Key_schedule));
    memcpy (kd->block, block, sizeof (C_Block));
d5074 1
a5074 6
    return packetizing_buffer_initialize (buf,
					  input ? krb_encrypt_input : NULL,
					  input ? NULL : krb_encrypt_output,
					  kd,
					  memory);
}
d5076 2
a5077 1
/* Decrypt Kerberos data.  */
d5079 1
a5079 9
static int
krb_encrypt_input (fnclosure, input, output, size)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
{
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
    int tcount;
d5081 5
a5085 13
    des_cbc_encrypt ((C_Block *) input, (C_Block *) output,
		     size, kd->sched, &kd->block, 0);

    /* SIZE is the size of the buffer, which is set by the encryption
       routine.  The packetizing buffer will arrange for the first two
       bytes in the decrypted buffer to be the real (unaligned)
       length.  As a safety check, make sure that the length in the
       buffer corresponds to SIZE.  Note that the length in the buffer
       is just the length of the data.  We must add 2 to account for
       the buffer count itself.  */
    tcount = ((output[0] & 0xff) << 8) + (output[1] & 0xff);
    if (((tcount + 2 + 7) & ~7) != size)
      error (1, 0, "Decryption failure");
d5090 1
a5090 1
/* Encrypt Kerberos data.  */
d5093 5
a5097 6
krb_encrypt_output (fnclosure, input, output, size, translated)
     void *fnclosure;
     const char *input;
     char *output;
     int size;
     int *translated;
d5099 3
a5101 1
    struct krb_encrypt_data *kd = (struct krb_encrypt_data *) fnclosure;
d5104 11
d5120 2
a5121 4
    /* Align SIZE to an 8 byte boundary.  Note that SIZE includes the
       two byte buffer count at the start of INPUT which was added by
       the packetizing buffer.  */
    aligned = (size + 7) & ~7;
d5130 51
a5180 2
    des_cbc_encrypt ((C_Block *) input, (C_Block *) output, aligned,
		     kd->sched, &kd->block, 1);
d5182 5
a5186 1
    *translated = aligned;
d5188 1
a5188 1
    return 0;
a5223 7
	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */

a5234 84
/* Output LEN bytes at STR in binary mode.  If LEN is zero, then
   output zero bytes.  */

void
cvs_output_binary (str, len)
    char *str;
    size_t len;
{
#ifdef SERVER_SUPPORT
    if (error_use_protocol || server_active)
    {
	struct buffer *buf;
	char size_text[40];

	if (error_use_protocol)
	    buf = buf_to_net;
	else if (server_active)
	    buf = protocol;

	if (!supported_response ("Mbinary"))
	{
	    error (0, 0, "\
this client does not support writing binary files to stdout");
	    return;
	}

	buf_output0 (buf, "Mbinary\012");
	sprintf (size_text, "%lu\012", (unsigned long) len);
	buf_output0 (buf, size_text);

	/* Not sure what would be involved in using buf_append_data here
	   without stepping on the toes of our caller (which is responsible
	   for the memory allocation of STR).  */
	buf_output (buf, str, len);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif
    {
	size_t written;
	size_t to_write = len;
	const char *p = str;

	/* For symmetry with cvs_outerr we would call fflush (stderr)
	   here.  I guess the assumption is that stderr will be
	   unbuffered, so we don't need to.  That sounds like a sound
	   assumption from the manpage I looked at, but if there was
	   something fishy about it, my guess is that calling fflush
	   would not produce a significant performance problem.  */
#ifdef USE_SETMODE_STDOUT
	int oldmode;

	/* It is possible that this should be the same ifdef as
	   USE_SETMODE_BINARY but at least for the moment we keep them
	   separate.  Mostly this is just laziness and/or a question
	   of what has been tested where.  Also there might be an
	   issue of setmode vs. _setmode.  */
	/* The Windows doc says to call setmode only right after startup.
	   I assume that what they are talking about can also be helped
	   by flushing the stream before changing the mode.  */
	fflush (stdout);
	oldmode = _setmode (_fileno (stdout), _O_BINARY);
	if (oldmode < 0)
	    error (0, errno, "failed to setmode on stdout");
#endif

	while (to_write > 0)
	{
	    written = fwrite (p, 1, to_write, stdout);
	    if (written == 0)
		break;
	    p += written;
	    to_write -= written;
	}
#ifdef USE_SETMODE_STDOUT
	fflush (stdout);
	if (_setmode (_fileno (stdout), oldmode) != _O_BINARY)
	    error (0, errno, "failed to setmode on stdout");
#endif
    }
}

a5326 59
}

/* Output TEXT, tagging it according to TAG.  There are lots more
   details about what TAG means in cvsclient.texi but for the simple
   case (e.g. non-client/server), TAG is just "newline" to output a
   newline (in which case TEXT must be NULL), and any other tag to
   output normal text.

   Note that there is no way to output either \0 or \n as part of TEXT.  */

void
cvs_output_tagged (tag, text)
    char *tag;
    char *text;
{
    if (text != NULL && strchr (text, '\n') != NULL)
	/* Uh oh.  The protocol has no way to cope with this.  For now
	   we dump core, although that really isn't such a nice
	   response given that this probably can be caused by newlines
	   in filenames and other causes other than bugs in CVS.  Note
	   that we don't want to turn this into "MT newline" because
	   this case is a newline within a tagged item, not a newline
	   as extraneous sugar for the user.  */
	assert (0);

    /* Start and end tags don't take any text, per cvsclient.texi.  */
    if (tag[0] == '+' || tag[0] == '-')
	assert (text == NULL);

#ifdef SERVER_SUPPORT
    if (server_active && supported_response ("MT"))
    {
	struct buffer *buf;

	if (error_use_protocol)
	    buf = buf_to_net;
	else
	    buf = protocol;

	buf_output0 (buf, "MT ");
	buf_output0 (buf, tag);
	if (text != NULL)
	{
	    buf_output (buf, " ", 1);
	    buf_output0 (buf, text);
	}
	buf_output (buf, "\n", 1);

	if (!error_use_protocol)
	    buf_send_counted (protocol);
    }
    else
#endif
    {
	if (strcmp (tag, "newline") == 0)
	    cvs_output ("\n", 1);
	else if (text != NULL)
	    cvs_output (text, 0);
    }
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d1197 1
a1197 1
	int status = change_mode (arg, mode_text, 0);
d3358 1
a3358 1
server_updated (finfo, vers, updated, mode, checksum, filebuf)
d3362 1
a3362 1
    mode_t mode;
a3363 1
    struct buffer *filebuf;
d3382 1
d3387 1
a3387 8
	if (filebuf != NULL)
	{
	    size = buf_length (filebuf);
	    if (mode == (mode_t) -1)
		error (1, 0, "\
CVS server internal error: no mode in server_updated");
	}
	else
d3389 1
a3389 3
	    struct stat sb;

	    if ( CVS_STAT (finfo->file, &sb) < 0)
d3391 8
a3398 19
		if (existence_error (errno))
		{
		    /* If we have a sticky tag for a branch on which
		       the file is dead, and cvs update the directory,
		       it gets a T_CHECKOUT but no file.  So in this
		       case just forget the whole thing.  */
		    free (entries_line);
		    entries_line = NULL;
		    goto done;
		}
		error (1, errno, "reading %s", finfo->fullname);
	    }
	    size = sb.st_size;
	    if (mode == (mode_t) -1)
	    {
		/* FIXME: When we check out files the umask of the
		   server (set in .bashrc if rsh is in use) affects
		   what mode we send, and it shouldn't.  */
		mode = sb.st_mode;
d3400 1
d3469 7
a3475 1
	    mode_string = mode_to_string (mode);
d3482 2
a3483 1
	if (size > 0)
d3496 1
a3496 1
		&& size > 100)
a3500 8
		/* Callers must avoid passing us a buffer if
                   file_gzip_level is set.  We could handle this case,
                   but it's not worth it since this case never arises
                   with a current client and server.  */
		if (filebuf != NULL)
		    error (1, 0, "\
CVS server internal error: unhandled case in server_updated");

d3523 1
a3523 1
	    else if (filebuf == NULL)
d3527 1
d3531 1
a3531 1
		status = buf_read_file (f, size, &list, &last);
d3545 1
a3545 7
	if (filebuf == NULL)
	    buf_append_data (protocol, list, last);
	else
	{
	    buf_append_buffer (protocol, filebuf);
	    buf_free (filebuf);
	}
a3557 1
	    && filebuf != NULL
d5611 1
a5611 1
	oldmode = _setmode (_fileno (stdout), OPEN_BINARY);
d5626 1
a5626 1
	if (_setmode (_fileno (stdout), oldmode) != OPEN_BINARY)
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d369 1
a369 2
		    && ((saved_errno != EACCES && saved_errno != EROFS)
			|| !isdir (q)))
a637 12
	/* Giving an error is actually kind of a cop-out, in the sense
	   that it would be nice for "cvs co -d /foo/bar/baz" to work.
	   A quick fix in the server would be requiring Max-dotdot of
	   at least one if pathnames are absolute, and then putting
	   /abs/foo/bar/baz in the temp dir beside the /d/d/d stuff.
	   A cleaner fix in the server might be to decouple the
	   pathnames we pass back to the client from pathnames in our
	   temp directory (this would also probably remove the need
	   for Max-dotdot).  A fix in the client would have the client
	   turn it into "cd /foo/bar; cvs co -d baz" (more or less).
	   This probably has some problems with pathnames which appear
	   in messages.  */
a2258 3
    /* FIXME: appending a newline, rather than using "MT" as we
       do in the child process, is probably not really a very good
       way to "handle" them.  */
a2328 13
	/* Output any partial lines.  If the client doesn't support
	   "MT", we just throw out the partial line, like old versions
	   of CVS did, since the protocol can't support this.  */
	if (supported_response ("MT") && ! buf_empty_p (saved_output))
	{
	    buf_output0 (protocol, "MT text ");
	    buf_append_buffer (protocol, saved_output);
	    buf_output (protocol, "\n", 1);
	    buf_send_counted (protocol);
	}
	/* For now we just discard partial lines on stderr.  I suspect
	   that CVS can't write such lines unless there is a bug.  */

d2843 2
a2844 3
			name, version, timestamp ? timestamp : "", options,
			tag ? tag : "", date ? date : "",
			conflict ? conflict : "");
d3081 1
a3081 1
    do_cvs_command ("status", cvsstatus);
d3583 1
a3583 1
	    && filebuf == NULL
a4781 1
	struct passwd *pw;
d4783 1
a4783 1
	struct spwd *spw;
d4785 2
a4786 2
	spw = getspnam (username);
	if (spw != NULL)
d4788 1
a4788 1
	    found_passwd = spw->sp_pwdp;
d4790 2
a4791 1
#endif
d4793 2
a4794 1
	if (found_passwd == NULL && (pw = getpwnam (username)) != NULL)
d4798 1
d4800 1
a4800 1
	if (found_passwd == NULL)
d4818 1
a4818 1
	if (*found_passwd)
a4819 1
	    /* user exists and has a password */
a4826 2
	    /* user exists and has no system password, but we got
	       one as parameter */
a4831 1
	    /* user exists but has no password at all */
d5590 1
a5590 1
	else
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a44 5

#ifdef HAVE_GSSAPI_H
#include <gssapi.h>
#endif
#ifdef HAVE_GSSAPI_GSSAPI_H
a45 2
#endif
#ifdef HAVE_GSSAPI_GSSAPI_GENERIC_H
a46 5
#endif

#ifndef HAVE_GSS_C_NT_HOSTBASED_SERVICE
#define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
#endif
d3104 1
a3104 1
    do_cvs_command ("remove", cvsremove);
d3118 1
a3118 1
    do_cvs_command ("rdiff", patch);
a3386 11
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
/* Need to prototype because mode_t might be smaller than int.  */
void
server_updated (
    struct file_info *finfo,
    Vers_TS *vers,
    enum server_updated_arg4 updated,
    mode_t mode,
    unsigned char *checksum,
    struct buffer *filebuf)
#else
a3394 1
#endif
d5221 1
a5221 1
    if (gss_import_name (&stat_min, &tok_in, GSS_C_NT_HOSTBASED_SERVICE,
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d136 1
a136 1
static char *Pserver_Repos = NULL;
a343 176
/* Populate all of the directories between BASE_DIR and its relative
   subdirectory DIR with CVSADM directories.  Return 0 for success or
   errno value.  */
static int create_adm_p PROTO((char *, char *));

static int
create_adm_p (base_dir, dir)
    char *base_dir;
    char *dir;
{
    char *dir_where_cvsadm_lives, *dir_to_register, *p, *tmp;
    int retval, done;
    FILE *f;

    if (strcmp (dir, ".") == 0)
	return 0;			/* nothing to do */

    /* Allocate some space for our directory-munging string. */
    p = malloc (strlen (dir) + 1);
    if (p == NULL)
	return ENOMEM;

    dir_where_cvsadm_lives = malloc (strlen (base_dir) + strlen (dir) + 100);
    if (dir_where_cvsadm_lives == NULL)
	return ENOMEM;

    /* Allocate some space for the temporary string in which we will
       construct filenames. */
    tmp = malloc (strlen (base_dir) + strlen (dir) + 100);
    if (tmp == NULL)
	return ENOMEM;

    
    /* We make several passes through this loop.  On the first pass,
       we simply create the CVSADM directory in the deepest directory.
       For each subsequent pass, we try to remove the last path
       element from DIR, create the CVSADM directory in the remaining
       pathname, and register the subdirectory in the newly created
       CVSADM directory. */

    retval = done = 0;

    strcpy (p, dir);
    strcpy (dir_where_cvsadm_lives, base_dir);
    strcat (dir_where_cvsadm_lives, "/");
    strcat (dir_where_cvsadm_lives, p);
    dir_to_register = NULL;

    while (1)
    {
	/* Create CVSADM. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM);
	if ((CVS_MKDIR (tmp, 0777) < 0) && (errno != EEXIST))
	{
	    retval = errno;
	    goto finish;
	}

	/* Create CVSADM_REP. */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_REP);
	if (! isfile (tmp))
	{
	    /* Use Emptydir as the placeholder until the client sends
	       us the real value.  This code is similar to checkout.c
	       (emptydir_name), but the code below returns errors
	       differently.  */

	    char *empty;
	    empty = malloc (strlen (CVSroot_directory)
			    + sizeof (CVSROOTADM)
			    + sizeof (CVSNULLREPOS)
			    + 10);
	    if (! empty)
	    {
		retval = ENOMEM;
		goto finish;
	    }

	    /* Create the directory name. */
	    (void) sprintf (empty, "%s/%s/%s", CVSroot_directory,
			    CVSROOTADM, CVSNULLREPOS);

	    /* Create the directory if it doesn't exist. */
	    if (! isfile (empty))
	    {
		mode_t omask;
		omask = umask (cvsumask);
		if (CVS_MKDIR (empty, 0777) < 0)
		{
		    retval = errno;
		    free (empty);
		    goto finish;
		}
		(void) umask (omask);
	    }
	    
	    
	    f = CVS_FOPEN (tmp, "w");
	    if (f == NULL)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }
	    /* Write the directory name to CVSADM_REP. */
	    if (fprintf (f, "%s\n", empty) < 0)
	    {
		retval = errno;
		fclose (f);
		free (empty);
		goto finish;
	    }
	    if (fclose (f) == EOF)
	    {
		retval = errno;
		free (empty);
		goto finish;
	    }

	    /* Clean up after ourselves. */
	    free (empty);
	}

	/* Create CVSADM_ENT.  We open in append mode because we
	   don't want to clobber an existing Entries file.  */
	(void) sprintf (tmp, "%s/%s", dir_where_cvsadm_lives, CVSADM_ENT);
	f = CVS_FOPEN (tmp, "a");
	if (f == NULL)
	{
	    retval = errno;
	    goto finish;
	}
	if (fclose (f) == EOF)
	{
	    retval = errno;
	    goto finish;
	}

	if (dir_to_register != NULL)
	{
	    /* FIXME: Yes, this results in duplicate entries in the
	       Entries.Log file, but it doesn't currently matter.  We
	       might need to change this later on to make sure that we
	       only write one entry.  */

	    Subdir_Register ((List *) NULL, dir_where_cvsadm_lives,
			     dir_to_register);
	}

	if (done)
	    break;

	dir_to_register = strrchr (p, '/');
	if (dir_to_register == NULL)
	{
	    dir_to_register = p;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    done = 1;
	}
	else
	{
	    *dir_to_register = '\0';
	    dir_to_register++;
	    strcpy (dir_where_cvsadm_lives, base_dir);
	    strcat (dir_where_cvsadm_lives, "/");
	    strcat (dir_where_cvsadm_lives, p);
	}
    }

  finish:
    free (tmp);
    free (dir_where_cvsadm_lives);
    free (p);
    return retval;
}

a565 1
    char *arg_dup;
d594 1
a594 23
#ifdef AUTH_SERVER_SUPPORT
    if (Pserver_Repos != NULL)
    {
	if (strcmp (Pserver_Repos, arg) != 0)
	{
	    if (alloc_pending (80 + strlen (Pserver_Repos) + strlen (arg)))
		/* The explicitness is to aid people who are writing clients.
		   I don't see how this information could help an
		   attacker.  */
		sprintf (pending_error_text, "\
E Protocol error: Root says \"%s\" but pserver says \"%s\"",
			 arg, Pserver_Repos);
	}
    }
#endif
    arg_dup = malloc (strlen (arg) + 1);
    if (arg_dup == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
    strcpy (arg_dup, arg);
    set_local_cvsroot (arg_dup);
d600 4
a603 9
    path = malloc (strlen (CVSroot_directory)
		   + sizeof (CVSROOTADM)
		   + sizeof (CVSROOTADM_HISTORY)
		   + 10);
    if (path == NULL)
    {
	pending_error = ENOMEM;
	return;
    }
d712 1
d748 1
a748 1
    status = mkdir_p (dir_name);
d758 10
a767 14
    /* We need to create adm directories in all path elements because
       we want the server to descend them, even if the client hasn't
       sent the appropriate "Argument xxx" command to match the
       already-sent "Directory xxx" command.  See recurse.c
       (start_recursion) for a big discussion of this.  */

    status = create_adm_p (server_temp_dir, dir);
    if (status != 0)
    {
	pending_error = status;
	if (alloc_pending (80 + strlen (dir_name)))
	    sprintf (pending_error_text, "E cannot create_adm_p %s", dir_name);
	return;
    }
d780 1
a780 1
    if ((CVS_MKDIR (CVSADM, 0777) < 0) && (errno != EEXIST))
d782 3
a787 6
    
    /* The following will overwrite the contents of CVSADM_REP.  This
       is the correct behavior -- mkdir_p may have written a
       placeholder value to this file and we need to insert the
       correct value. */

d1058 2
d1072 5
d1078 1
a1078 48
    {
	/* Using gunzip_and_write isn't really a high-performance
	   approach, because it keeps the whole thing in memory
	   (contiguous memory, worse yet).  But it seems easier to
	   code than the alternative (and less vulnerable to subtle
	   bugs).  Given that this feature is mainly for
	   compatibility, that is the better tradeoff.  */

	int toread = size;
	char *filebuf;
	char *p;

	filebuf = malloc (size);
	p = filebuf;
	/* If NULL, we still want to read the data and discard it.  */

	while (toread > 0)
	{
	    int status, nread;
	    char *data;

	    status = buf_read_data (buf_from_net, toread, &data, &nread);
	    if (status != 0)
	    {
		if (status == -2)
		    pending_error = ENOMEM;
		else
		{
		    pending_error_text = malloc (80);
		    if (pending_error_text == NULL)
			pending_error = ENOMEM;
		    else if (status == -1)
		    {
			sprintf (pending_error_text,
				 "E premature end of file from client");
			pending_error = 0;
		    }
		    else
		    {
			sprintf (pending_error_text,
				 "E error reading from client");
			pending_error = status;
		    }
		}
		return;
	    }

	    toread -= nread;
d1080 1
a1080 22
	    if (filebuf != NULL)
	    {
		memcpy (p, data, nread);
		p += nread;
	    }
	}
	if (filebuf == NULL)
	{
	    pending_error = ENOMEM;
	    goto out;
	}

	if (gunzip_and_write (fd, file, filebuf, size))
	{
	    if (alloc_pending (80))
		sprintf (pending_error_text,
			 "E aborting due to compression error");
	}
	free (filebuf);
    }
    else
	receive_partial_file (size, fd);
a1093 1
 out:
d1100 2
d1104 9
a1117 5
/* Timestamp (Checkin-time) for next file sent in Modified or
   Is-modified.  */
static int checkin_time_valid;
static time_t checkin_time;

a1220 16
    if (checkin_time_valid)
    {
	struct utimbuf t;

	memset (&t, 0, sizeof (t));
	t.modtime = t.actime = checkin_time;
	if (utime (arg, &t) < 0)
	{
	    pending_error = errno;
	    if (alloc_pending (80 + strlen (arg)))
		sprintf (pending_error_text, "E cannot utime %s", arg);
	    return;
	}
	checkin_time_valid = 0;
    }

a1445 28
static void serve_checkin_time PROTO ((char *));

static void
serve_checkin_time (arg)
     char *arg;
{
    if (error_pending ())
	return;

    if (checkin_time_valid)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text,
		     "E protocol error: duplicate Checkin-time request: %s",
		     arg);
	return;
    }

    checkin_time = get_date (arg, NULL);
    if (checkin_time == (time_t)-1)
    {
	if (alloc_pending (80 + strlen (arg)))
	    sprintf (pending_error_text, "E cannot parse date %s", arg);
	return;
    }
    checkin_time_valid = 1;
}

d2882 2
a2883 2
			"%s-> server_register(%s, %s, %s, %s, %s, %s, %s)\n",
			CLIENT_SERVER_STR,
a3348 6
    /* At least for now, our practice is to have the server enforce
       noexec for the repository and the client enforce it for the
       working directory.  This might want more thought, and/or
       documentation in cvsclient.texi (other responses do it
       differently).  */

d3367 6
a3372 1
    char outdate[MAXDATELEN];
d3379 3
d3387 5
a3391 1
    date_to_internet (outdate, date);
d3393 1
a3393 1
    buf_output0 (protocol, outdate);
a3440 6
	/* The contents of the file will be in one of filebuf,
	   list/last, or here.  */
	unsigned char *file;
	size_t file_allocated;
	size_t file_used;

a3548 5

	file = NULL;
	file_allocated = 0;
	file_used = 0;

d3564 2
a3565 8
		/* Basing this routine on read_and_gzip is not a
		   high-performance approach.  But it seems easier
		   to code than the alternative (and less
		   vulnerable to subtle bugs).  Given that this feature
		   is mainly for compatibility, that is the better
		   tradeoff.  */

		int fd;
d3578 10
a3587 6
		if (read_and_gzip (fd, finfo->fullname, &file,
				   &file_allocated, &file_used,
				   file_gzip_level))
		    error (1, 0, "aborting due to compression error");
		size = file_used;
		if (close (fd) < 0)
d3589 5
d3618 1
a3618 7
	if (file != NULL)
	{
	    buf_output (protocol, file, file_used);
	    free (file);
	    file = NULL;
	}
	else if (filebuf == NULL)
d3641 1
a3641 5
	{
	    if (CVS_UNLINK (finfo->file) < 0)
		error (0, errno, "cannot remove temp file for %s",
		       finfo->fullname);
	}
d4136 14
a4149 17
  REQ_LINE("Root", serve_root, RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Valid-responses", serve_valid_responses,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("valid-requests", serve_valid_requests,
	   RQ_ESSENTIAL | RQ_ROOTLESS),
  REQ_LINE("Repository", serve_repository, 0),
  REQ_LINE("Directory", serve_directory, RQ_ESSENTIAL),
  REQ_LINE("Max-dotdot", serve_max_dotdot, 0),
  REQ_LINE("Static-directory", serve_static_directory, 0),
  REQ_LINE("Sticky", serve_sticky, 0),
  REQ_LINE("Checkin-prog", serve_checkin_prog, 0),
  REQ_LINE("Update-prog", serve_update_prog, 0),
  REQ_LINE("Entry", serve_entry, RQ_ESSENTIAL),
  REQ_LINE("Kopt", serve_kopt, 0),
  REQ_LINE("Checkin-time", serve_checkin_time, 0),
  REQ_LINE("Modified", serve_modified, RQ_ESSENTIAL),
  REQ_LINE("Is-modified", serve_is_modified, 0),
d4154 1
a4154 1
  REQ_LINE("UseUnchanged", serve_enable_unchanged, RQ_ENABLEME | RQ_ROOTLESS),
d4156 8
a4163 8
  REQ_LINE("Unchanged", serve_unchanged, RQ_ESSENTIAL),
  REQ_LINE("Notify", serve_notify, 0),
  REQ_LINE("Questionable", serve_questionable, 0),
  REQ_LINE("Case", serve_case, 0),
  REQ_LINE("Argument", serve_argument, RQ_ESSENTIAL),
  REQ_LINE("Argumentx", serve_argumentx, RQ_ESSENTIAL),
  REQ_LINE("Global_option", serve_global_option, 0),
  REQ_LINE("Gzip-stream", serve_gzip_stream, 0),
d4166 2
a4167 2
           0),
  REQ_LINE("Set", serve_set, RQ_ROOTLESS),
d4170 1
a4170 1
  REQ_LINE("Kerberos-encrypt", serve_kerberos_encrypt, 0),
d4173 1
a4173 1
  REQ_LINE("Gssapi-encrypt", serve_gssapi_encrypt, 0),
d4177 1
a4177 1
  REQ_LINE("Gssapi-authenticate", serve_gssapi_authenticate, 0),
d4179 29
a4207 29
  REQ_LINE("expand-modules", serve_expand_modules, 0),
  REQ_LINE("ci", serve_ci, RQ_ESSENTIAL),
  REQ_LINE("co", serve_co, RQ_ESSENTIAL),
  REQ_LINE("update", serve_update, RQ_ESSENTIAL),
  REQ_LINE("diff", serve_diff, 0),
  REQ_LINE("log", serve_log, 0),
  REQ_LINE("add", serve_add, 0),
  REQ_LINE("remove", serve_remove, 0),
  REQ_LINE("update-patches", serve_ignore, 0),
  REQ_LINE("gzip-file-contents", serve_gzip_contents, 0),
  REQ_LINE("status", serve_status, 0),
  REQ_LINE("rdiff", serve_rdiff, 0),
  REQ_LINE("tag", serve_tag, 0),
  REQ_LINE("rtag", serve_rtag, 0),
  REQ_LINE("import", serve_import, 0),
  REQ_LINE("admin", serve_admin, 0),
  REQ_LINE("export", serve_export, 0),
  REQ_LINE("history", serve_history, 0),
  REQ_LINE("release", serve_release, 0),
  REQ_LINE("watch-on", serve_watch_on, 0),
  REQ_LINE("watch-off", serve_watch_off, 0),
  REQ_LINE("watch-add", serve_watch_add, 0),
  REQ_LINE("watch-remove", serve_watch_remove, 0),
  REQ_LINE("watchers", serve_watchers, 0),
  REQ_LINE("editors", serve_editors, 0),
  REQ_LINE("init", serve_init, RQ_ROOTLESS),
  REQ_LINE("annotate", serve_annotate, 0),
  REQ_LINE("noop", serve_noop, 0),
  REQ_LINE(NULL, NULL, 0)
d4605 1
a4605 10

		if (!(rq->flags & RQ_ROOTLESS)
		    && CVSroot_directory == NULL)
		{
		    if (alloc_pending (80))
			sprintf (pending_error_text,
				 "E Protocol error: Root request missing");
		}
		else
		    (*rq->func) (cmd);
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@d754 3
a756 1
    /* Sending "Root" twice is illegal.
a876 67
static int outside_root PROTO ((char *));

/* Is file or directory REPOS an absolute pathname within the
   CVSroot_directory?  If yes, return 0.  If no, set pending_error
   and return 1.  */
static int
outside_root (repos)
    char *repos;
{
    size_t repos_len = strlen (repos);
    size_t root_len = strlen (CVSroot_directory);

    /* I think isabsolute (repos) should always be true, and that
       any RELATIVE_REPOS stuff should only be in CVS/Repository
       files, not the protocol (for compatibility), but I'm putting
       in the isabsolute check just in case.  */
    if (!isabsolute (repos))
    {
	if (alloc_pending (repos_len + 80))
	    sprintf (pending_error_text, "\
E protocol error: %s is not absolute", repos);
	return 1;
    }

    if (repos_len < root_len
	|| strncmp (CVSroot_directory, repos, root_len) != 0)
    {
    not_within:
	if (alloc_pending (strlen (CVSroot_directory)
			   + strlen (repos)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within root '%s'",
		     repos, CVSroot_directory);
	return 1;
    }
    if (repos_len > root_len)
    {
	if (repos[root_len] != '/')
	    goto not_within;
	if (pathname_levels (repos + root_len + 1) > 0)
	    goto not_within;
    }
    return 0;
}

static int outside_dir PROTO ((char *));

/* Is file or directory FILE outside the current directory (that is, does
   it contain '/')?  If no, return 0.  If yes, set pending_error
   and return 1.  */
static int
outside_dir (file)
    char *file;
{
    if (strchr (file, '/') != NULL)
    {
	if (alloc_pending (strlen (file)
			   + 80))
	    sprintf (pending_error_text, "\
E protocol error: directory '%s' not within current directory",
		     file);
	return 1;
    }
    return 0;
}
	
a921 19
    /* Check for bad directory name.

       FIXME: could/should unify these checks with server_pathname_check
       except they need to report errors differently.  */
    if (isabsolute (dir))
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E absolute pathname `%s' illegal for server", dir);
	return;
    }
    if (pathname_levels (dir) > max_dotdot_limit)
    {
	if (alloc_pending (80 + strlen (dir)))
	    sprintf (pending_error_text,
		     "E protocol error: `%s' has too many ..", dir);
	return;
    }

d1077 15
a1091 1
	if (outside_root (repos))
d1093 2
a1480 3
    if (outside_dir (arg))
	return;

a1552 3
    if (outside_dir (arg))
	return;

a1592 3
    if (outside_dir (arg))
	return;

a1842 3
    if (outside_dir (arg))
	return;

a1893 3
	if (strchr (data, '+'))
	    goto error;

d1933 1
a1933 1
    pending_error_text = malloc (80);
a1993 2
    last_node = NULL;

a2238 3
    if (outside_dir (arg))
	return;

a4933 15
		    /* For commands which change the way in which data
		       is sent and received, for example Gzip-stream,
		       this does the wrong thing.  Since the client
		       assumes that everything is being compressed,
		       unconditionally, there is no way to give this
		       error to the client without turning on
		       compression.  The obvious fix would be to make
		       Gzip-stream RQ_ROOTLESS (with the corresponding
		       change to the spec), and that might be a good
		       idea but then again I can see some settings in
		       CVSROOT about what compression level to allow.
		       I suppose a more baroque answer would be to
		       turn on compression (say, at level 1), just
		       enough to give the "Root request missing"
		       error.  For now we just lose.  */
a4970 3
	/* Normally this won't be reached; check_password contains
	   a similar check.  */

d4973 11
a4983 2
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
d4986 9
d4996 1
a4996 17
    if (initgroups (pw->pw_name, pw->pw_gid) < 0
#  ifdef EPERM
	/* At least on the system I tried, initgroups() only works as root.
	   But we do still want to report ENOMEM and whatever other
	   errors initgroups() might dish up.  */
	&& errno != EPERM
#  endif
	)
    {
	/* This could be a warning, but I'm not sure I see the point
	   in doing that instead of an error given that it would happen
	   on every connection.  We could log it somewhere and not tell
	   the user.  But at least for now make it an error.  */
	printf ("error 0 initgroups failed: %s\n", strerror (errno));
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
    }
d5003 1
a5003 8
	if (setgid (getegid ()) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setuid failed: %s\n", strerror (errno));
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
	}
d5006 1
a5006 1
#endif
d5008 1
a5008 8
	if (setgid (pw->pw_gid) < 0)
	{
	    /* See comments at setuid call below for more discussion.  */
	    printf ("error 0 setuid failed: %s\n", strerror (errno));
	    /* Don't worry about server_cleanup;
	       server_active isn't set yet.  */
	    error_exit ();
	}
d5010 1
d5012 1
a5012 13
    if (setuid (pw->pw_uid) < 0)
    {
	/* Note that this means that if run as a non-root user,
	   CVSROOT/passwd must contain the user we are running as
	   (e.g. "joe:FsEfVcu:cvs" if run as "cvs" user).  This seems
	   cleaner than ignoring the error like CVS 1.10 and older but
	   it does mean that some people might need to update their
	   CVSROOT/passwd file.  */
	printf ("error 0 setuid failed: %s\n", strerror (errno));
	/* Don't worry about server_cleanup; server_active isn't set yet.  */
	error_exit ();
    }

d5417 6
a5422 1
    if (host_user == NULL)
d5427 3
d5431 7
a5437 3
	/* Don't worry about server_cleanup, server_active isn't set
	   yet.  */
	error_exit ();
a5442 3
	printf ("I LOVE YOU\n");
	fflush (stdout);

a5463 2
    printf ("I LOVE YOU\n");
    fflush (stdout);
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@a185 1
static int fd_buffer_shutdown PROTO((void *));
d207 1
a207 1
			   fd_buffer_shutdown,
a343 10
/* The buffer shutdown function for a buffer built on a file descriptor.  */

static int
fd_buffer_shutdown (closure)
     void *closure;
{
    free (closure);
    return 0;
}

d741 2
d784 8
a791 1
    set_local_cvsroot (arg);
d799 1
d809 3
a811 2
	int save_errno = errno;
	if (alloc_pending (80 + strlen (path)))
d815 11
d1039 1
a1041 1
	pending_error = status;
d1054 1
a1056 1
	pending_error = status;
d1062 1
a1062 1
	int save_errno = errno;
a1064 1
	pending_error = save_errno;
d1073 1
a1073 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM)))
	    sprintf (pending_error_text,
		     "E cannot mkdir %s/%s", dir_name, CVSADM);
	pending_error = save_errno;
d1076 1
a1076 1

d1085 1
a1085 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E cannot open %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
d1090 1
a1090 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
d1103 1
a1103 5
	    int save_errno = errno;
	    if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
		sprintf (pending_error_text,
			 "E error writing %s/%s", dir_name, CVSADM_REP);
	    pending_error = save_errno;
d1110 1
a1110 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error writing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
d1116 1
a1116 5
	int save_errno = errno;
	if (alloc_pending (80 + strlen (dir_name) + strlen (CVSADM_REP)))
	    sprintf (pending_error_text,
		     "E error closing %s/%s", dir_name, CVSADM_REP);
	pending_error = save_errno;
d1124 1
a1124 1
	int save_errno = errno;
a1126 1
	pending_error = save_errno;
d1131 1
a1131 1
	int save_errno = errno;
a1133 1
	pending_error = save_errno;
d1142 4
a1145 1
    if (alloc_pending (80))
d1161 3
a1163 2
	if (!outside_root (repos))
	    dirswitch (arg, repos);
d1202 1
a1202 1
	int save_errno = errno;
a1204 1
	pending_error = save_errno;
d1209 1
a1209 1
	int save_errno = errno;
a1211 1
	pending_error = save_errno;
d1227 1
a1227 1
	int save_errno = errno;
a1229 1
	pending_error = save_errno;
d1234 1
a1234 1
	int save_errno = errno;
a1236 1
	pending_error = save_errno;
d1241 1
a1241 1
	int save_errno = errno;
a1243 1
	pending_error = save_errno;
d1302 4
a1305 4
	        int save_errno = errno;
		if (alloc_pending (40))
		    strcpy (pending_error_text, "E unable to write");
		pending_error = save_errno;
d1341 2
a1342 2
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
d1344 1
a1344 1
	pending_error = save_errno;
d1410 1
a1410 1
	if (gunzip_and_write (fd, file, (unsigned char *) filebuf, size))
d1436 2
a1437 2
	int save_errno = errno;
	if (alloc_pending (40 + strlen (arg)))
d1439 1
a1439 1
	pending_error = save_errno;
d1518 1
a1518 1
		    pending_error = status;
a1521 1
	free (mode_text);
a1545 1
	free (mode_text);
a1549 2
    {
	free (mode_text);
a1550 1
    }
d1555 1
a1555 5
	if (error_pending ())
	{
	    free (mode_text);
	    return;
	}
d1566 1
a1566 1
	    int save_errno = errno;
a1568 2
	    pending_error = save_errno;
	    free (mode_text);
d1579 2
a1580 1
	    if (alloc_pending (40 + strlen (arg)))
d1855 1
a1855 1
	    int save_errno = errno;
a1857 1
	    pending_error = save_errno;
d1866 1
a1866 1
		int save_errno = errno;
a1869 1
		pending_error = save_errno;
d1880 1
a1880 1
	int save_errno = errno;
a1882 1
	pending_error = save_errno;
d1914 2
a1915 2
    struct notify_note *new = NULL;
    char *data = NULL;
a1922 3
    if (dir_name == NULL)
	goto error;

d1929 2
d1932 6
d1939 1
a1939 1
    if (new->dir == NULL || new->filename == NULL)
a1941 3
	if (new->dir != NULL)
	    free (new->dir);
	free (new);
a1943 1
    strcpy (new->dir, dir_name);
a1968 3
	free (new->filename);
	free (new->dir);
	free (new);
d2016 2
a2017 2
    pending_error = 0;
    if (alloc_pending (80))
d2020 1
a2020 8
    if (data != NULL)
	free (data);
    if (new != NULL)
    {
	free (new->filename);
	free (new->dir);
	free (new);
    }
a2062 1
	free (repos);
a2649 1
	buf_output0 (buf_to_net, "E pipe failed\n");
a2654 1
	buf_output0 (buf_to_net, "E pipe failed\n");
a2659 1
	buf_output0 (buf_to_net, "E pipe failed\n");
a2665 1
	buf_output0 (buf_to_net, "E pipe failed\n");
a2675 1
	buf_output0 (buf_to_net, "E open /dev/null failed\n");
a2702 1
	buf_output0 (buf_to_net, "E fork failed\n");
a2735 1
	close (dev_null_fd);
a2736 1
	close (stdout_pipe[1]);
a2737 1
	close (stderr_pipe[1]);
a2771 1
	buf_free (protocol);
a2827 1
	    buf_output0 (buf_to_net, "E close failed\n");
a2834 1
	    buf_output0 (buf_to_net, "E close failed\n");
a2841 1
	    buf_output0 (buf_to_net, "E close failed\n");
a2849 1
	    buf_output0 (buf_to_net, "E close failed\n");
a2857 1
	    buf_output0 (buf_to_net, "E close failed\n");
a2924 1
		    buf_output0 (buf_to_net, "E select failed\n");
d2936 42
a2987 2
		{
		    close (protocol_pipe[0]);
a2988 1
		}
a2990 1
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
a3026 50

	    if (stdout_pipe[0] >= 0
		&& (FD_ISSET (stdout_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stdoutbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stdoutbuf, 'M');

		if (status == -1)
		{
		    close (stdout_pipe[0]);
		    stdout_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }

	    if (stderr_pipe[0] >= 0
		&& (FD_ISSET (stderr_pipe[0], &readfds)))
	    {
	        int status;

	        status = buf_input_data (stderrbuf, (int *) NULL);

		buf_copy_lines (buf_to_net, stderrbuf, 'E');

		if (status == -1)
		{
		    close (stderr_pipe[0]);
		    stderr_pipe[0] = -1;
		}
		else if (status > 0)
		{
		    buf_output0 (buf_to_net, "E buf_input_data failed\n");
		    print_error (status);
		    goto error_exit;
		}

		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
	    }
a3047 5
#ifdef SERVER_FLOWCONTROL
	close (flowcontrol_pipe[1]);
	flowcontrol_pipe[1] = -1;
#endif /* SERVER_FLOWCONTROL */

a3101 6
	buf_shutdown (protocol_inbuf);
	buf_free (protocol_inbuf);
	buf_shutdown (stderrbuf);
	buf_free (stderrbuf);
	buf_shutdown (stdoutbuf);
	buf_free (stdoutbuf);
a3131 4
#ifdef SERVER_FLOWCONTROL
    close (flowcontrol_pipe[0]);
    close (flowcontrol_pipe[1]);
#endif /* SERVER_FLOWCONTROL */
a3186 1
		buf_output0 (buf_to_net, "E select failed\n");
d3627 1
a3627 1
static void serve_noop PROTO ((char *));
d3629 4
a3632 3
static void
serve_noop (arg)
    char *arg;
d3634 1
a3634 8

    server_write_entries ();
    if (!print_pending_error ())
    {
	(void) server_notify ();
	buf_output0 (buf_to_net, "ok\n");
    }
    buf_flush (buf_to_net, 1);
d3637 1
a3637 1
static void serve_version PROTO ((char *));
d3640 1
a3640 1
serve_version (arg)
d3643 1
a3643 1
    do_cvs_command ("version", version);
d4020 1
a4020 1
	    buf_output (protocol, (char *) file, file_used);
d4317 1
a4317 1
expand_proc (argc, argv, where, mwhere, mfile, shorten,
d4319 1
a4319 1
    int argc;
d4358 1
a4358 1
	if (argc == 1)
d4371 1
a4371 1
	    for (i = 1; i < argc; ++i)
d4463 1
a4463 1
	int save_errno = errno;
a4465 1
	pending_error = save_errno;
d4470 1
a4470 1
	int save_errno = errno;
a4473 1
	pending_error = save_errno;
d4478 1
a4478 1
	int save_errno = errno;
a4480 1
	pending_error = save_errno;
d4506 1
a4506 1
	int save_errno = errno;
a4508 1
	pending_error = save_errno;
d4513 1
a4513 1
	int save_errno = errno;
a4515 1
	pending_error = save_errno;
d4520 1
a4520 1
	int save_errno = errno;
a4522 1
	pending_error = save_errno;
d4575 1
a4575 1
  REQ_LINE("Global_option", serve_global_option, RQ_ROOTLESS),
d4619 1
a4619 2
  REQ_LINE("noop", serve_noop, RQ_ROOTLESS),
  REQ_LINE("version", serve_version, RQ_ROOTLESS),
d4843 7
a4849 1
	    if (alloc_pending (80 + strlen (Tmpdir)))
d4852 1
a4852 1

a4860 1
	    int i = 0;
d4907 2
a4908 1
	    while ((status = mkdir_p (server_temp_dir)) == EEXIST)
d4910 3
a4912 13
	        static const char suffix[] = "abcdefghijklmnopqrstuvwxyz";

	        if (i >= sizeof suffix - 1) break;
		if (i == 0) p = server_temp_dir + strlen (server_temp_dir);
		p[0] = suffix[i++];
		p[1] = '\0';
	    }
	    if (status != 0)
	    {
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
			    "E can't create temporary directory %s",
			    server_temp_dir);
d4921 3
a4923 4
		    if (alloc_pending (80 + strlen (server_temp_dir)))
			sprintf (pending_error_text,
"E cannot change permissions on temporary directory %s",
				server_temp_dir);
a4930 3
#ifdef SIGABRT
    (void) SIG_register (SIGABRT, server_cleanup);
#endif
d5110 1
a5110 1
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
d5122 1
a5122 1
	    printf ("error 0 setgid failed: %s\n", strerror (errno));
a5146 6
#ifdef AUTH_SERVER_SUPPORT
    /* Make sure our CVS_Username has been set. */
    if (CVS_Username == NULL)
	CVS_Username = xstrdup (username);
#endif
      
d5172 1
a5172 1
 * 1 means entry found and password matches (or found password is empty)
d5175 1
a5175 1
 * If 1, host_user_ptr will be set to point at the system
a5179 1
 * kff todo: FIXME: last sentence is not true, it applies to caller.
d5232 1
a5232 1
    /* If found_it, then linebuf contains the information we need. */
a5235 1
        char *non_cvsuser_portion;
d5237 3
a5239 53
        /* We need to make sure lines such as 
         *
         *    "username::sysuser\n"
         *    "username:\n"
         *    "username:  \n"
         *
         * all result in a found_password of NULL, but we also need to
         * make sure that
         *
         *    "username:   :sysuser\n"
         *    "username: <whatever>:sysuser\n"
         *
         * continues to result in an impossible password.  That way,
         * an admin would be on safe ground by going in and tacking a
         * space onto the front of a password to disable the account
         * (a technique some people use to close accounts
         * temporarily).
         */

        /* Make `non_cvsuser_portion' contain everything after the CVS
           username, but null out any final newline. */
	non_cvsuser_portion = linebuf + namelen;
        strtok (non_cvsuser_portion, "\n");

        /* If there's a colon now, we just want to inch past it. */
        if (strchr (non_cvsuser_portion, ':') == non_cvsuser_portion)
            non_cvsuser_portion++;

        /* Okay, after this conditional chain, found_password and
           host_user_tmp will have useful values: */

        if ((non_cvsuser_portion == NULL)
            || (strlen (non_cvsuser_portion) == 0)
            || ((strspn (non_cvsuser_portion, " \t"))
                == strlen (non_cvsuser_portion)))
        {
            found_password = NULL;
            host_user_tmp = NULL;
        }
        else if (strncmp (non_cvsuser_portion, ":", 1) == 0)
        {
            found_password = NULL;
            host_user_tmp = non_cvsuser_portion + 1;
            if (strlen (host_user_tmp) == 0)
                host_user_tmp = NULL;
        }
        else
        {
            found_password = strtok (non_cvsuser_portion, ":");
            host_user_tmp = strtok (NULL, ":");
        }

        /* Of course, maybe there was no system user portion... */
d5243 1
a5243 4
        /* Verify blank passwords directly, otherwise use crypt(). */
        if ((found_password == NULL)
            || ((strcmp (found_password, crypt (password, found_password))
                 == 0)))
d5255 1
a5255 1
    else     /* Didn't find this user, so deny access. */
d5338 1
a5338 1
                         ? xstrdup (username) : NULL);
d5345 1
a5345 1
	    host_user = xstrdup (username);
d5475 1
a5475 1
    if (getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX) < 0)
d5506 3
a5508 3
    getline_safe (&repository, &repository_allocated, stdin, PATH_MAX);
    getline_safe (&username, &username_allocated, stdin, PATH_MAX);
    getline_safe (&password, &password_allocated, stdin, PATH_MAX);
d5517 1
a5517 1
    getline_safe (&tmp, &tmp_allocated, stdin, PATH_MAX);
a5578 1
    free (host_user);
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d19 41
a59 10
#if defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT)
# ifdef HAVE_GSSAPI
/* This stuff isn't included solely with SERVER_SUPPORT since some of these
 * functions (encryption & the like) get compiled with or without server
 * support.
 *
 * FIXME - They should be in a different file.
 */
#   include <netdb.h>
#   include "xgssapi.h"
d62 1
a62 1
#   include <krb5.h>
d72 1
a72 1
#   ifdef ENCRYPTION
d78 1
a78 3
#   endif
# endif	/* HAVE_GSSAPI */
#endif	/* defined(SERVER_SUPPORT) || defined(CLIENT_SUPPORT) */
a79 4
#ifdef SERVER_SUPPORT

#ifdef HAVE_WINSOCK_H
#include <winsock.h>
d82 4
a85 2
#if defined (AUTH_SERVER_SUPPORT) || defined (HAVE_KERBEROS) || defined (HAVE_GSSAPI)
#include <sys/socket.h>
d88 9
a96 2
#ifdef HAVE_SYSLOG_H
#include <syslog.h>
d99 2
a100 11
#ifdef HAVE_KERBEROS
# include <netinet/in.h>
# include <krb.h>
# ifndef HAVE_KRB_GET_ERR_TEXT
#   define krb_get_err_text(status) krb_err_txt[status]
# endif

/* Information we need if we are going to use Kerberos encryption.  */
static C_Block kblock;
static Key_schedule sched;

a102 3
/* for select */
#include "xselect.h"

d115 6
d125 2
a126 6

# ifdef AUTH_SERVER_SUPPORT

#   ifdef HAVE_GETSPNAM
#     include <shadow.h>
#   endif
d142 1
a142 1
# endif /* AUTH_SERVER_SUPPORT */
d423 1
a423 1
	    empty = malloc (strlen (current_parsed_root->directory)
d426 1
a426 1
			    + 3);
d434 1
a434 1
	    (void) sprintf (empty, "%s/%s/%s", current_parsed_root->directory,
a599 2
    char tmpstr[80];

d602 2
a603 6
    if (msg == NULL)
    {
       sprintf (tmpstr, "unknown error %d", status);
       msg = tmpstr;
    }
    buf_output0 (buf_to_net, msg);
d770 1
a770 1
    if (current_parsed_root != NULL)
d793 1
a793 4

    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
    current_parsed_root = local_cvsroot (arg);
d797 1
a797 1
    parse_config (current_parsed_root->directory);
d799 1
a799 1
    path = malloc (strlen (current_parsed_root->directory)
d801 1
a801 1
		   + 2);
d807 1
a807 1
    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
d818 1
a818 1
    env = malloc (strlen (CVSROOT_ENV) + strlen (current_parsed_root->directory) + 2);
d824 1
a824 1
    (void) sprintf (env, "%s=%s", CVSROOT_ENV, current_parsed_root->directory);
d867 1
a867 1
   current_parsed_root->directory?  If yes, return 0.  If no, set pending_error
d874 1
a874 1
    size_t root_len = strlen (current_parsed_root->directory);
d889 1
a889 1
	|| strncmp (current_parsed_root->directory, repos, root_len) != 0)
d892 1
a892 1
	if (alloc_pending (strlen (current_parsed_root->directory)
d897 1
a897 1
		     repos, current_parsed_root->directory);
d1100 2
a1101 3
	&& current_parsed_root != NULL
	&& current_parsed_root->directory != NULL
	&& strcmp (current_parsed_root->directory, repos) == 0)
a2430 3
#ifdef HAVE_SYSLOG_H
    syslog (LOG_DAEMON | LOG_ERR, "virtual memory exhausted");
#endif
d2488 1
a2488 1
         flen = strlen (current_parsed_root->directory)
d2494 1
a2494 1
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
d2540 1
a2540 1
         flen = strlen (current_parsed_root->directory)
d2546 1
a2546 1
         (void) sprintf (fname, "%s/%s/%s", current_parsed_root->directory,
a2787 1
	close_on_exec (protocol_pipe[1]);
a2788 1
	close_on_exec (flowcontrol_pipe[0]);
d2805 3
a2807 3
	   "MT", we go ahead and just tack on a newline since the
	   protocol doesn't support anything better.  */
	if (! buf_empty_p (saved_output))
d2809 1
a2809 1
	    buf_output0 (protocol, supported_response ("MT") ? "MT text " : "M ");
d2832 1
a2832 1
	int count_needed = 1;
d2920 1
a2920 2
	       || protocol_pipe[0] >= 0
	       || count_needed <= 0)
a2926 2
	    struct timeval *timeout_ptr;
	    struct timeval timeout;
a2946 16

	    if (count_needed <= 0)
	    {
		/* there is data pending which was read from the protocol pipe
		 * so don't block if we don't find any data
		 */
		timeout.tv_sec = 0;
		timeout.tv_usec = 0;
		timeout_ptr = &timeout;
	    }
	    else
	    {
		/* block indefinately */
		timeout_ptr = NULL;
	    }

d2948 1
a2948 1
		FD_SET (STDOUT_FILENO, &writefds);
d2964 7
a2970 7
	     we might not get output in the same order in which it
	     was written, thus producing the well-known
	     "out-of-order" bug.  If the child process uses
	     cvs_output and cvs_outerr, it will send everything on
	     the protocol_pipe and avoid this problem, so the
	     solution is to use cvs_output and cvs_outerr in the
	     child process.  */
d2976 1
a2976 1
				 (fd_set *)0, timeout_ptr);
d2978 1
a2978 1
			&& errno != EINTR)
d2985 1
a2985 7

	    if (numfds == 0)
	    {
		FD_ZERO (&readfds);
		FD_ZERO (&writefds);
	    }

d2997 1
d3020 3
a3022 12
	    }
	    /* this is still part of the protocol pipe procedure, but it is
	     * outside the above conditional so that unprocessed data can be
	     * left in the buffer and stderr/stdout can be read when a flush
	     * signal is received and control can return here without passing
	     * through the select code and maybe blocking
	     */
	    while (count_needed <= 0)
	    {
		int special = 0;

		count_needed = buf_copy_counted (buf_to_net,
d3026 2
a3027 2
		/* What should we do with errors?  syslog() them?  */
		buf_send_output (buf_to_net);
d3029 5
a3033 19
		/* If SPECIAL got set to <0, it means that the child
		 * wants us to flush the pipe & maybe stderr or stdout.
		 *
		 * After that we break to read stderr & stdout again before
		 * going back to the protocol pipe
		 *
		 * Upon breaking, count_needed = 0, so the next pass will only
		 * perform a non-blocking select before returning here to finish
		 * processing data we already read from the protocol buffer
		 */
		 if (special == -1)
		 {
		     cvs_flushout();
		     break;
		 }
		if (special == -2)
		{
		    /* If the client supports the 'F' command, we send it. */
		    if (supported_response ("F"))
d3035 7
a3041 2
			buf_append_char (buf_to_net, 'F');
			buf_append_char (buf_to_net, '\n');
a3042 2
		    cvs_flusherr ();
		    break;
a3428 5
     *
     * Don't know if this is what whoever wrote the above comment was
     * talking about, but this can happen in the case where a join
     * removes a file - the call to Register puts the '-vers' into the
     * Entries file after the file is removed
a3587 9
serve_rlog (arg)
    char *arg;
{
    /* Tell cvslog() to behave like rlog not log.  */
    command_name = "rlog";
    do_cvs_command ("rlog", cvslog);
}

static void
d3626 1
a3626 3
    /* Tell cvstag() to behave like rtag not tag.  */
    command_name = "rtag";
    do_cvs_command ("rtag", cvstag);
d3750 1
a3750 4

    if (current_parsed_root != NULL)
	free_cvsroot_t (current_parsed_root);
    current_parsed_root = local_cvsroot (arg);
a3762 11

static void serve_rannotate PROTO ((char *));

static void
serve_rannotate (arg)
    char *arg;
{
    /* Tell annotate() to behave like rannotate not annotate.  */
    command_name = "rannotate";
    do_cvs_command ("rannotate", annotate);
}
a4159 17
	/* keep the vers structure up to date in case we do a join
	 * - if there isn't a file, it can't very well have a version number, can it?
	 *
	 * we do it here on the assumption that since we just told the client
	 * to remove the file/entry, it will, and we want to remember that.
	 * If it fails, that's the client's problem, not ours
	 */
	if (vers && vers->vn_user != NULL)
	{
	    free (vers->vn_user);
	    vers->vn_user = NULL;
	}
	if (vers && vers->ts_user != NULL)
	{
	    free (vers->ts_user);
	    vers->ts_user = NULL;
	}
d4493 1
a4493 1
			  NULL, 0, 0, 0, 0,
a4693 1
  REQ_LINE("rlog", serve_rlog, 0),
a4714 1
  REQ_LINE("rannotate", serve_rannotate, 0),
d4748 1
a4748 1
#ifdef SUNOS_KLUDGE
d4762 1
a4762 1
#endif /* SUNOS_KLUDGE */
d4806 1
a4806 1
#ifdef SUNOS_KLUDGE
d4879 1
a4879 1
#endif /* SUNOS_KLUDGE */
d5017 1
a5017 1
	    else if (chmod (server_temp_dir, S_IRWXU) < 0)
d5019 5
a5023 3
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
d5025 3
a5027 2
			     server_temp_dir);
		pending_error = save_errno;
a5029 9
	    else if (CVS_CHDIR (server_temp_dir) < 0)
	    {
		int save_errno = errno;
		if (alloc_pending (80 + strlen (server_temp_dir)))
		    sprintf (pending_error_text,
"E cannot change to temporary directory %s",
			     server_temp_dir);
		pending_error = save_errno;
	    }
d5125 1
a5125 1
		    && current_parsed_root == NULL)
d5259 2
a5260 2
    /* Set LOGNAME, USER and CVS_USER in the environment, in case they
       are already set to something else.  */
d5262 1
a5262 1
	char *env, *cvs_user;
a5270 5

        cvs_user = NULL != CVS_Username ? CVS_Username : "";
        env = xmalloc (sizeof "CVS_USER=" + strlen (cvs_user));
        (void) sprintf (env, "CVS_USER=%s", cvs_user);
        (void) putenv (env);
d5305 1
a5305 1
    /* We don't use current_parsed_root->directory because it hasn't been set yet
d5635 2
a5636 7
	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
d5692 6
a5697 5
    {
	printf ("error 0 %s: no such repository\n", repository);
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login refused for %s", repository);
#endif
a5698 1
    }
a5713 7
#ifdef HAVE_SYSLOG_H
	syslog (LOG_DAEMON | LOG_NOTICE, "login failure (for %s)", repository);
#ifdef LOG_AUTHPRIV
        syslog (LOG_AUTHPRIV | LOG_NOTICE, "login failure by %s / %s (for %s)",
        	username, descrambled_password, repository);
#endif
#endif
d5795 2
a5796 7
	if (setsockopt (STDIN_FILENO, SOL_SOCKET, SO_KEEPALIVE,
			   (char *) &on, sizeof on) < 0)
	{
#ifdef HAVE_SYSLOG_H
	    syslog (LOG_DAEMON | LOG_ERR, "error setting KEEPALIVE: %m");
#endif
	}
a6391 3
	/* skip the actual stderr flush in this case since the parent process
	 * on the server should only be writing to stdout anyhow
	 */
a6396 4
	/* make sure stderr is flushed before we send the flush count on the
	 * protocol pipe
	 */ 
	fflush (stderr);
d6398 1
a6398 1
	buf_send_special_count (protocol, -2);
d6424 1
a6424 7
	   this case work analogously to cvs_flusherr.
	 
	   FIXME - DRP - I tried to implement this and triggered the following
	   error: "Protocol error: uncounted data discarded".  I don't need
	   this feature right now, so I'm not going to bother with it yet.
	 */
	buf_send_special_count (protocol, -1);
@


