head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.10
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.6
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.14
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.12
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.10
	OPENBSD_5_0:1.23.0.8
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.8
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.4
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.2
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.8
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.6
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.4
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.16.0.8
	OPENBSD_3_4_BASE:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_9_BASE:1.11
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2014.05.28.16.43.06;	author jcs;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.03.17.02.36;	author jcs;	state Exp;
branches;
next	1.23;

1.23
date	2009.12.14.21.15.55;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.11.00.52.43;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.08.08.30.56;	author jmc;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.26.20.50.05;	author niallo;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.20.19.18.13;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.16.22.15.10;	author millert;	state Exp;
branches
	1.18.2.1
	1.18.4.1
	1.18.6.1;
next	1.17;

1.17
date	2003.09.25.20.06.16;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.08.08.01.45;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.30.18.17.00;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.29.18.12.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.27.06.44.48;	author matthieu;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	99.09.10.05.21.33;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	99.02.28.21.57.58;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	98.08.22.21.04.34;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	98.07.13.04.17.05;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	98.05.14.21.16.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.03.12.07.22.41;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	98.02.22.08.56.04;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	97.06.28.03.45.31;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	97.04.26.08.33.31;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.20;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.08;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.50;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.46;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.43;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.19;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.38.19;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.27.36;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.28.51;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.21.26;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.06.59.02;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.03.54.13;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.53.39;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.33.17;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.06.25;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.18.57.45;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.45.38;	author tholo;	state Exp;
branches;
next	;

1.18.2.1
date	2005.04.23.03.00.21;	author brad;	state Exp;
branches;
next	;

1.18.4.1
date	2005.04.23.02.42.18;	author brad;	state Exp;
branches;
next	;

1.18.6.1
date	2005.05.23.06.37.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.26
log
@finally enable writing per-commit commitid tokens to rcs ,v files

ok deraadt@@ millert@@
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * The routines contained in this file do all the rcs file parsing and
 * manipulation
 */

#include <assert.h>
#include <err.h>
#include "cvs.h"
#include "edit.h"
#include "hardlink.h"

int preserve_perms = 0;

/* The RCS -k options, and a set of enums that must match the array.
   These come first so that we can use enum kflag in function
   prototypes.  */
static const char *const kflags[] =
  {"kv", "kvl", "k", "v", "o", "b", (char *) NULL};
enum kflag { KFLAG_KV = 0, KFLAG_KVL, KFLAG_K, KFLAG_V, KFLAG_O, KFLAG_B };

/* A structure we use to buffer the contents of an RCS file.  The
   various fields are only referenced directly by the rcsbuf_*
   functions.  We declare the struct here so that we can allocate it
   on the stack, rather than in memory.  */

struct rcsbuffer
{
    /* Points to the current position in the buffer.  */
    char *ptr;
    /* Points just after the last valid character in the buffer.  */
    char *ptrend;
    /* The file.  */
    FILE *fp;
    /* The name of the file, used for error messages.  */
    const char *filename;
    /* The starting file position of the data in the buffer.  */
    unsigned long pos;
    /* The length of the value.  */
    size_t vlen;
    /* Whether the value contains an '@@' string.  If so, we can not
       compress whitespace characters.  */
    int at_string;
    /* The number of embedded '@@' characters in an '@@' string.  If
       this is non-zero, we must search the string for pairs of '@@'
       and convert them to a single '@@'.  */
    int embedded_at;
};

static RCSNode *RCS_parsercsfile_i PROTO((FILE * fp, const char *rcsfile));
static char *RCS_getdatebranch PROTO((RCSNode * rcs, char *date, char *branch));
static void rcsbuf_open PROTO ((struct rcsbuffer *, FILE *fp,
				const char *filename, unsigned long pos));
static void rcsbuf_close PROTO ((struct rcsbuffer *));
static int rcsbuf_getkey PROTO ((struct rcsbuffer *, char **keyp,
				 char **valp));
static int rcsbuf_getrevnum PROTO ((struct rcsbuffer *, char **revp));
static char *rcsbuf_fill PROTO ((struct rcsbuffer *, char *ptr, char **keyp,
				 char **valp));
static int rcsbuf_valcmp PROTO ((struct rcsbuffer *));
static char *rcsbuf_valcopy PROTO ((struct rcsbuffer *, char *val, int polish,
				    size_t *lenp));
static void rcsbuf_valpolish PROTO ((struct rcsbuffer *, char *val, int polish,
				     size_t *lenp));
static void rcsbuf_valpolish_internal PROTO ((struct rcsbuffer *, char *to,
					      const char *from, size_t *lenp));
static unsigned long rcsbuf_ftell PROTO ((struct rcsbuffer *));
static void rcsbuf_get_buffered PROTO ((struct rcsbuffer *, char **datap,
					size_t *lenp));
static void rcsbuf_cache PROTO ((RCSNode *, struct rcsbuffer *));
static void rcsbuf_cache_close PROTO ((void));
static void rcsbuf_cache_open PROTO ((RCSNode *, long, FILE **,
				      struct rcsbuffer *));
static int checkmagic_proc PROTO((Node *p, void *closure));
static void do_branches PROTO((List * list, char *val));
static void do_symbols PROTO((List * list, char *val));
static void do_locks PROTO((List * list, char *val));
static void free_rcsnode_contents PROTO((RCSNode *));
static void free_rcsvers_contents PROTO((RCSVers *));
static void rcsvers_delproc PROTO((Node * p));
static char *translate_symtag PROTO((RCSNode *, const char *));
static char *RCS_addbranch PROTO ((RCSNode *, const char *));
static char *truncate_revnum_in_place PROTO ((char *));
static char *truncate_revnum PROTO ((const char *));
static char *printable_date PROTO((const char *));
static char *mdoc_date PROTO((const char *));
static char *escape_keyword_value PROTO ((const char *, int *));
static void expand_keywords PROTO((RCSNode *, RCSVers *, const char *,
				   const char *, size_t, enum kflag, char *,
				   size_t, char **, size_t *));
static void cmp_file_buffer PROTO((void *, const char *, size_t));

/* Routines for reading, parsing and writing RCS files. */
static RCSVers *getdelta PROTO ((struct rcsbuffer *, char *, char **,
				 char **));
static Deltatext *RCS_getdeltatext PROTO ((RCSNode *, FILE *,
					   struct rcsbuffer *));
static void freedeltatext PROTO ((Deltatext *));

static void RCS_putadmin PROTO ((RCSNode *, FILE *));
static void RCS_putdtree PROTO ((RCSNode *, char *, FILE *));
static void RCS_putdesc PROTO ((RCSNode *, FILE *));
static void putdelta PROTO ((RCSVers *, FILE *));
static int putrcsfield_proc PROTO ((Node *, void *));
static int putsymbol_proc PROTO ((Node *, void *));
static void RCS_copydeltas PROTO ((RCSNode *, FILE *, struct rcsbuffer *,
				   FILE *, Deltatext *, char *));
static int count_delta_actions PROTO ((Node *, void *));
static void putdeltatext PROTO ((FILE *, Deltatext *));

static FILE *rcs_internal_lockfile PROTO ((char *));
static void rcs_internal_unlockfile PROTO ((FILE *, char *));
static char *rcs_lockfilename PROTO ((char *));

/* The RCS file reading functions are called a lot, and they do some
   string comparisons.  This macro speeds things up a bit by skipping
   the function call when the first characters are different.  It
   evaluates its arguments multiple times.  */
#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp ((a), (b)) == 0)

/*
 * We don't want to use isspace() from the C library because:
 *
 * 1. The definition of "whitespace" in RCS files includes ASCII
 *    backspace, but the C locale doesn't.
 * 2. isspace is an very expensive function call in some implementations
 *    due to the addition of wide character support.
 */
static const char spacetab[] = {
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0,	/* 0x00 - 0x0f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x10 - 0x1f */
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x20 - 0x2f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x30 - 0x3f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x40 - 0x4f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x50 - 0x5f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x60 - 0x8f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x70 - 0x7f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x80 - 0x8f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x90 - 0x9f */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xa0 - 0xaf */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xb0 - 0xbf */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xc0 - 0xcf */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xd0 - 0xdf */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xe0 - 0xef */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  /* 0xf0 - 0xff */
};

#define whitespace(c)	(spacetab[(unsigned char)c] != 0)

static char *rcs_lockfile;
static int rcs_lockfd = -1;

/* A few generic thoughts on error handling, in particular the
   printing of unexpected characters that we find in the RCS file
   (that is, why we use '\x%x' rather than %c or some such).

   * Avoiding %c means we don't have to worry about what is printable
   and other such stuff.  In error handling, often better to keep it
   simple.

   * Hex rather than decimal or octal because character set standards
   tend to use hex.

   * Saying "character 0x%x" might make it sound like we are printing
   a file offset.  So we use '\x%x'.

   * Would be nice to print the offset within the file, but I can
   imagine various portability hassles (in particular, whether
   unsigned long is always big enough to hold file offsets).  */

/* Parse an rcsfile given a user file name and a repository.  If there is
   an error, we print an error message and return NULL.  If the file
   does not exist, we return NULL without printing anything (I'm not
   sure this allows the caller to do anything reasonable, but it is
   the current behavior).  */
RCSNode *
RCS_parse (file, repos)
    const char *file;
    const char *repos;
{
    RCSNode *rcs;
    FILE *fp;
    RCSNode *retval;
    char *rcsfile;

    /* We're creating a new RCSNode, so there is no hope of finding it
       in the cache.  */
    rcsbuf_cache_close ();

    rcsfile = xmalloc (strlen (repos) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
    (void) sprintf (rcsfile, "%s/%s%s", repos, file, RCSEXT);
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) != NULL) 
    {
        rcs = RCS_parsercsfile_i(fp, rcsfile);
	if (rcs != NULL) 
	    rcs->flags |= VALID;

	retval = rcs;
	goto out;
    }
    else if (! existence_error (errno))
    {
	error (0, errno, "cannot open %s", rcsfile);
	retval = NULL;
	goto out;
    }

    (void) sprintf (rcsfile, "%s/%s/%s%s", repos, CVSATTIC, file, RCSEXT);
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) != NULL) 
    {
        rcs = RCS_parsercsfile_i(fp, rcsfile);
	if (rcs != NULL)
	{
	    rcs->flags |= INATTIC;
	    rcs->flags |= VALID;
	}

	retval = rcs;
	goto out;
    }
    else if (! existence_error (errno))
    {
	error (0, errno, "cannot open %s", rcsfile);
	retval = NULL;
	goto out;
    }
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
    else if (ign_case)
    {
	int status;
	char *found_path;

	/* The client might be asking for a file which we do have
	   (which the client doesn't know about), but for which the
	   filename case differs.  We only consider this case if the
	   regular CVS_FOPENs fail, because fopen_case is such an
	   expensive call.  */
	(void) sprintf (rcsfile, "%s/%s%s", repos, file, RCSEXT);
	status = fopen_case (rcsfile, "rb", &fp, &found_path);
	if (status == 0)
	{
	    rcs = RCS_parsercsfile_i (fp, rcsfile);
	    if (rcs != NULL) 
		rcs->flags |= VALID;

	    free (rcs->path);
	    rcs->path = found_path;
	    retval = rcs;
	    goto out;
	}
	else if (! existence_error (status))
	{
	    error (0, status, "cannot open %s", rcsfile);
	    retval = NULL;
	    goto out;
	}

	(void) sprintf (rcsfile, "%s/%s/%s%s", repos, CVSATTIC, file, RCSEXT);
	status = fopen_case (rcsfile, "rb", &fp, &found_path);
	if (status == 0)
	{
	    rcs = RCS_parsercsfile_i (fp, rcsfile);
	    if (rcs != NULL)
	    {
		rcs->flags |= INATTIC;
		rcs->flags |= VALID;
	    }

	    free (rcs->path);
	    rcs->path = found_path;
	    retval = rcs;
	    goto out;
	}
	else if (! existence_error (status))
	{
	    error (0, status, "cannot open %s", rcsfile);
	    retval = NULL;
	    goto out;
	}
    }
#endif
    retval = NULL;

 out:
    free (rcsfile);

    return retval;
}

/*
 * Parse a specific rcsfile.
 */
RCSNode *
RCS_parsercsfile (rcsfile)
    char *rcsfile;
{
    FILE *fp;
    RCSNode *rcs;

    /* We're creating a new RCSNode, so there is no hope of finding it
       in the cache.  */
    rcsbuf_cache_close ();

    /* open the rcsfile */
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) == NULL)
    {
	error (0, errno, "Couldn't open rcs file `%s'", rcsfile);
	return (NULL);
    }

    rcs = RCS_parsercsfile_i (fp, rcsfile);

    return (rcs);
}


/*
 */ 
static RCSNode *
RCS_parsercsfile_i (fp, rcsfile)
    FILE *fp;
    const char *rcsfile;
{
    RCSNode *rdata;
    struct rcsbuffer rcsbuf;
    char *key, *value;

    /* make a node */
    rdata = (RCSNode *) xmalloc (sizeof (RCSNode));
    memset ((char *) rdata, 0, sizeof (RCSNode));
    rdata->refcount = 1;
    rdata->path = xstrdup (rcsfile);

    /* Process HEAD, BRANCH, and EXPAND keywords from the RCS header.

       Most cvs operations on the main branch don't need any more
       information.  Those that do call RCS_reparsercsfile to parse
       the rest of the header and the deltas.  */

    rcsbuf_open (&rcsbuf, fp, rcsfile, 0);

    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	goto l_error;
    if (STREQ (key, RCSDESC))
	goto l_error;

    if (STREQ (RCSHEAD, key) && value != NULL)
	rdata->head = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);

    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	goto l_error;
    if (STREQ (key, RCSDESC))
	goto l_error;

    if (STREQ (RCSBRANCH, key) && value != NULL)
    {
	char *cp;

	rdata->branch = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);
	if ((numdots (rdata->branch) & 1) != 0)
	{
	    /* turn it into a branch if it's a revision */
	    cp = strrchr (rdata->branch, '.');
	    *cp = '\0';
	}
    }

    /* Look ahead for expand, stopping when we see desc or a revision
       number.  */
    while (1)
    {
	char *cp;

	if (STREQ (RCSEXPAND, key))
	{
	    rdata->expand = rcsbuf_valcopy (&rcsbuf, value, 0,
					    (size_t *) NULL);
	    break;
	}

	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
	    /* do nothing */ ;
	if (*cp == '\0')
	    break;

	if (STREQ (RCSDESC, key))
	    break;

	if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	    break;
    }

    rdata->flags |= PARTIAL;

    rcsbuf_cache (rdata, &rcsbuf);

    return rdata;

l_error:
    error (0, 0, "`%s' does not appear to be a valid rcs file",
	   rcsfile);
    rcsbuf_close (&rcsbuf);
    freercsnode (&rdata);
    fclose (fp);
    return (NULL);
}


/* Do the real work of parsing an RCS file.

   On error, die with a fatal error; if it returns at all it was successful.

   If PFP is NULL, close the file when done.  Otherwise, leave it open
   and store the FILE * in *PFP.  */
void
RCS_reparsercsfile (rdata, pfp, rcsbufp)
    RCSNode *rdata;
    FILE **pfp;
    struct rcsbuffer *rcsbufp;
{
    FILE *fp;
    char *rcsfile;
    struct rcsbuffer rcsbuf;
    Node *q, *kv;
    RCSVers *vnode;
    int gotkey;
    char *cp;
    char *key, *value;

    assert (rdata != NULL);
    rcsfile = rdata->path;

    rcsbuf_cache_open (rdata, 0, &fp, &rcsbuf);

    /* make a node */
    /* This probably shouldn't be done until later: if a file has an
       empty revision tree (which is permissible), rdata->versions
       should be NULL. -twp */
    rdata->versions = getlist ();

    /*
     * process all the special header information, break out when we get to
     * the first revision delta
     */
    gotkey = 0;
    for (;;)
    {
	/* get the next key/value pair */
	if (!gotkey)
	{
	    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	    {
		error (1, 0, "`%s' does not appear to be a valid rcs file",
		       rcsfile);
	    }
	}

	gotkey = 0;

	/* Skip head, branch and expand tags; we already have them. */
	if (STREQ (key, RCSHEAD)
	    || STREQ (key, RCSBRANCH)
	    || STREQ (key, RCSEXPAND))
	{
	    continue;
	}

	if (STREQ (key, "access"))
	{
	    if (value != NULL)
	    {
		/* We pass the POLISH parameter as 1 because
                   RCS_addaccess expects nothing but spaces.  FIXME:
                   It would be easy and more efficient to change
                   RCS_addaccess.  */
		rdata->access = rcsbuf_valcopy (&rcsbuf, value, 1,
						(size_t *) NULL);
	    }
	    continue;
	}

	/* We always save lock information, so that we can handle
           -kkvl correctly when checking out a file. */
	if (STREQ (key, "locks"))
	{
	    if (value != NULL)
		rdata->locks_data = rcsbuf_valcopy (&rcsbuf, value, 0,
						    (size_t *) NULL);
	    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	    {
		error (1, 0, "premature end of file reading %s", rcsfile);
	    }
	    if (STREQ (key, "strict") && value == NULL)
	    {
		rdata->strict_locks = 1;
	    }
	    else
		gotkey = 1;
	    continue;
	}

	if (STREQ (RCSSYMBOLS, key))
	{
	    if (value != NULL)
		rdata->symbols_data = rcsbuf_valcopy (&rcsbuf, value, 0,
						      (size_t *) NULL);
	    continue;
	}

	/*
	 * check key for '.''s and digits (probably a rev) if it is a
	 * revision or `desc', we are done with the headers and are down to the
	 * revision deltas, so we break out of the loop
	 */
	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
	     /* do nothing */ ;
	/* Note that when comparing with RCSDATE, we are not massaging
           VALUE from the string found in the RCS file.  This is OK
           since we know exactly what to expect.  */
	if (*cp == '\0' && strncmp (RCSDATE, value, (sizeof RCSDATE) - 1) == 0)
	    break;

	if (STREQ (key, RCSDESC))
	    break;

	if (STREQ (key, "comment"))
	{
	    rdata->comment = rcsbuf_valcopy (&rcsbuf, value, 0,
					     (size_t *) NULL);
	    continue;
	}
	if (rdata->other == NULL)
	    rdata->other = getlist ();
	kv = getnode ();
	kv->type = rcsbuf_valcmp (&rcsbuf) ? RCSCMPFLD : RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = rcsbuf_valcopy (&rcsbuf, value, kv->type == RCSFIELD,
				   (size_t *) NULL);
	if (addnode (rdata->other, kv) != 0)
	{
	    error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    freenode (kv);
	}

	/* if we haven't grabbed it yet, we didn't want it */
    }

    /* We got out of the loop, so we have the first part of the first
       revision delta in KEY (the revision) and VALUE (the date key
       and its value).  This is what getdelta expects to receive.  */

    while ((vnode = getdelta (&rcsbuf, rcsfile, &key, &value)) != NULL)
    {
	/* get the node */
	q = getnode ();
	q->type = RCSVERS;
	q->delproc = rcsvers_delproc;
	q->data = (char *) vnode;
	q->key = vnode->version;

	/* add the nodes to the list */
	if (addnode (rdata->versions, q) != 0)
	{
#if 0
		purify_printf("WARNING: Adding duplicate version: %s (%s)\n",
			 q->key, rcsfile);
		freenode (q);
#endif
	}
    }

    /* Here KEY and VALUE are whatever caused getdelta to return NULL.  */

    if (STREQ (key, RCSDESC))
    {
	if (rdata->desc != NULL)
	{
	    error (0, 0,
		   "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    free (rdata->desc);
	}
	rdata->desc = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
    }

    rdata->delta_pos = rcsbuf_ftell (&rcsbuf);

    if (pfp == NULL)
	rcsbuf_cache (rdata, &rcsbuf);
    else
    {
	*pfp = fp;
	*rcsbufp = rcsbuf;
    }
    rdata->flags &= ~PARTIAL;
}

/* Move RCS into or out of the Attic, depending on TOATTIC.  If the
   file is already in the desired place, return without doing
   anything.  At some point may want to think about how this relates
   to RCS_rewrite but that is a bit hairy (if one wants renames to be
   atomic, or that kind of thing).  If there is an error, print a message
   and return 1.  On success, return 0.  */
int
RCS_setattic (rcs, toattic)
    RCSNode *rcs;
    int toattic;
{
    char *newpath;
    char *p;
    char *q;

    /* Some systems aren't going to let us rename an open file.  */
    rcsbuf_cache_close ();

    /* Could make the pathname computations in this file, and probably
       in other parts of rcs.c too, easier if the REPOS and FILE
       arguments to RCS_parse got stashed in the RCSNode.  */

    if (toattic)
    {
	mode_t omask;

	if (rcs->flags & INATTIC)
	    return 0;

	/* Example: rcs->path is "/foo/bar/baz,v".  */
	newpath = xmalloc (strlen (rcs->path) + sizeof CVSATTIC + 5);
	p = last_component (rcs->path);
	strncpy (newpath, rcs->path, p - rcs->path);
	strcpy (newpath + (p - rcs->path), CVSATTIC);

	/* Create the Attic directory if it doesn't exist.  */
	omask = umask (cvsumask);
	if (CVS_MKDIR (newpath, 0777) < 0 && errno != EEXIST)
	    error (0, errno, "cannot make directory %s", newpath);
	(void) umask (omask);

	strcat (newpath, "/");
	strcat (newpath, p);

	if (CVS_RENAME (rcs->path, newpath) < 0)
	{
	    int save_errno = errno;

	    /* The checks for isreadable look awfully fishy, but
	       I'm going to leave them here for now until I
	       can think harder about whether they take care of
	       some cases which should be handled somehow.  */

	    if (isreadable (rcs->path) || !isreadable (newpath))
	    {
		error (0, save_errno, "cannot rename %s to %s",
		       rcs->path, newpath);
		free (newpath);
		return 1;
	    }
	}
    }
    else
    {
	if (!(rcs->flags & INATTIC))
	    return 0;

	newpath = xmalloc (strlen (rcs->path));

	/* Example: rcs->path is "/foo/bar/Attic/baz,v".  */
	p = last_component (rcs->path);
	strncpy (newpath, rcs->path, p - rcs->path - 1);
	newpath[p - rcs->path - 1] = '\0';
	q = newpath + (p - rcs->path - 1) - (sizeof CVSATTIC - 1);
	assert (strncmp (q, CVSATTIC, sizeof CVSATTIC - 1) == 0);
	strcpy (q, p);

	if (CVS_RENAME (rcs->path, newpath) < 0)
	{
	    error (0, errno, "failed to move `%s' out of the attic",
		   rcs->path);
	    free (newpath);
	    return 1;
	}
    }

    free (rcs->path);
    rcs->path = newpath;

    return 0;
}

/*
 * Fully parse the RCS file.  Store all keyword/value pairs, fetch the
 * log messages for each revision, and fetch add and delete counts for
 * each revision (we could fetch the entire text for each revision,
 * but the only caller, log_fileproc, doesn't need that information,
 * so we don't waste the memory required to store it).  The add and
 * delete counts are stored on the OTHER field of the RCSVERSNODE
 * structure, under the names ";add" and ";delete", so that we don't
 * waste the memory space of extra fields in RCSVERSNODE for code
 * which doesn't need this information.
 */

void
RCS_fully_parse (rcs)
    RCSNode *rcs;
{
    FILE *fp;
    struct rcsbuffer rcsbuf;

    RCS_reparsercsfile (rcs, &fp, &rcsbuf);

    while (1)
    {
	char *key, *value;
	Node *vers;
	RCSVers *vnode;

	/* Rather than try to keep track of how much information we
           have read, just read to the end of the file.  */
	if (! rcsbuf_getrevnum (&rcsbuf, &key))
	    break;

	vers = findnode (rcs->versions, key);
	if (vers == NULL)
	    error (1, 0,
		   "mismatch in rcs file %s between deltas and deltatexts",
		   rcs->path);

	vnode = (RCSVers *) vers->data;

	while (rcsbuf_getkey (&rcsbuf, &key, &value))
	{
	    if (! STREQ (key, "text"))
	    {
		Node *kv;

		if (vnode->other == NULL)
		    vnode->other = getlist ();
		kv = getnode ();
		kv->type = rcsbuf_valcmp (&rcsbuf) ? RCSCMPFLD : RCSFIELD;
		kv->key = xstrdup (key);
		kv->data = rcsbuf_valcopy (&rcsbuf, value, kv->type == RCSFIELD,
					   (size_t *) NULL);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}

		continue;
	    }

	    if (! STREQ (vnode->version, rcs->head))
	    {
		unsigned long add, del;
		char buf[50];
		Node *kv;

		/* This is a change text.  Store the add and delete
                   counts.  */
		add = 0;
		del = 0;
		if (value != NULL)
		{
		    size_t vallen;
		    const char *cp;

		    rcsbuf_valpolish (&rcsbuf, value, 0, &vallen);
		    cp = value;
		    while (cp < value + vallen)
		    {
			char op;
			unsigned long count;

			op = *cp++;
			if (op != 'a' && op  != 'd')
			    error (1, 0, "\
unrecognized operation '\\x%x' in %s",
				   op, rcs->path);
			(void) strtoul (cp, (char **) &cp, 10);
			if (*cp++ != ' ')
			    error (1, 0, "space expected in %s",
				   rcs->path);
			count = strtoul (cp, (char **) &cp, 10);
			if (*cp++ != '\012')
			    error (1, 0, "linefeed expected in %s",
				   rcs->path);

			if (op == 'd')
			    del += count;
			else
			{
			    add += count;
			    while (count != 0)
			    {
				if (*cp == '\012')
				    --count;
				else if (cp == value + vallen)
				{
				    if (count != 1)
					error (1, 0, "\
invalid rcs file %s: premature end of value",
					       rcs->path);
				    else
					break;
				}
				++cp;
			    }
			}
		    }
		}

		sprintf (buf, "%lu", add);
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (";add");
		kv->data = xstrdup (buf);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}

		sprintf (buf, "%lu", del);
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (";delete");
		kv->data = xstrdup (buf);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}
	    }

	    /* We have found the "text" key which ends the data for
               this revision.  Break out of the loop and go on to the
               next revision.  */
	    break;
	}
    }

    rcsbuf_cache (rcs, &rcsbuf);
}

/*
 * freercsnode - free up the info for an RCSNode
 */
void
freercsnode (rnodep)
    RCSNode **rnodep;
{
    if (rnodep == NULL || *rnodep == NULL)
	return;

    ((*rnodep)->refcount)--;
    if ((*rnodep)->refcount != 0)
    {
	*rnodep = (RCSNode *) NULL;
	return;
    }
    free ((*rnodep)->path);
    if ((*rnodep)->head != (char *) NULL)
	free ((*rnodep)->head);
    if ((*rnodep)->branch != (char *) NULL)
	free ((*rnodep)->branch);
    free_rcsnode_contents (*rnodep);
    free ((char *) *rnodep);
    *rnodep = (RCSNode *) NULL;
}

/*
 * free_rcsnode_contents - free up the contents of an RCSNode without
 * freeing the node itself, or the file name, or the head, or the
 * path.  This returns the RCSNode to the state it is in immediately
 * after a call to RCS_parse.
 */
static void
free_rcsnode_contents (rnode)
    RCSNode *rnode;
{
    dellist (&rnode->versions);
    if (rnode->symbols != (List *) NULL)
	dellist (&rnode->symbols);
    if (rnode->symbols_data != (char *) NULL)
	free (rnode->symbols_data);
    if (rnode->expand != NULL)
	free (rnode->expand);
    if (rnode->other != (List *) NULL)
	dellist (&rnode->other);
    if (rnode->access != NULL)
	free (rnode->access);
    if (rnode->locks_data != NULL)
	free (rnode->locks_data);
    if (rnode->locks != (List *) NULL)
	dellist (&rnode->locks);
    if (rnode->comment != NULL)
	free (rnode->comment);
    if (rnode->desc != NULL)
	free (rnode->desc);
}

/* free_rcsvers_contents -- free up the contents of an RCSVers node,
   but also free the pointer to the node itself. */
/* Note: The `hardlinks' list is *not* freed, since it is merely a
   pointer into the `hardlist' structure (defined in hardlink.c), and
   that structure is freed elsewhere in the program. */

static void
free_rcsvers_contents (rnode)
    RCSVers *rnode;
{
    if (rnode->branches != (List *) NULL)
	dellist (&rnode->branches);
    if (rnode->date != (char *) NULL)
	free (rnode->date);
    if (rnode->next != (char *) NULL)
	free (rnode->next);
    if (rnode->author != (char *) NULL)
	free (rnode->author);
    if (rnode->state != (char *) NULL)
	free (rnode->state);
    if (rnode->other != (List *) NULL)
	dellist (&rnode->other);
    if (rnode->other_delta != NULL)
	dellist (&rnode->other_delta);
    if (rnode->text != NULL)
	freedeltatext (rnode->text);
    free ((char *) rnode);
}

/*
 * rcsvers_delproc - free up an RCSVers type node
 */
static void
rcsvers_delproc (p)
    Node *p;
{
    free_rcsvers_contents ((RCSVers *) p->data);
}

/* These functions retrieve keys and values from an RCS file using a
   buffer.  We use this somewhat complex approach because it turns out
   that for many common operations, CVS spends most of its time
   reading keys, so it's worth doing some fairly hairy optimization.  */

/* The number of bytes we try to read each time we need more data.  */

#define RCSBUF_BUFSIZE (8192)

/* The buffer we use to store data.  This grows as needed.  */

static char *rcsbuf_buffer = NULL;
static size_t rcsbuf_buffer_size = 0;

/* Whether rcsbuf_buffer is in use.  This is used as a sanity check.  */

static int rcsbuf_inuse;

/* Set up to start gathering keys and values from an RCS file.  This
   initializes RCSBUF.  */

static void
rcsbuf_open (rcsbuf, fp, filename, pos)
    struct rcsbuffer *rcsbuf;
    FILE *fp;
    const char *filename;
    unsigned long pos;
{
    if (rcsbuf_inuse)
	error (1, 0, "rcsbuf_open: internal error");
    rcsbuf_inuse = 1;

    if (rcsbuf_buffer_size < RCSBUF_BUFSIZE)
	expand_string (&rcsbuf_buffer, &rcsbuf_buffer_size, RCSBUF_BUFSIZE);

    rcsbuf->ptr = rcsbuf_buffer;
    rcsbuf->ptrend = rcsbuf_buffer;
    rcsbuf->fp = fp;
    rcsbuf->filename = filename;
    rcsbuf->pos = pos;
    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;
}

/* Stop gathering keys from an RCS file.  */

static void
rcsbuf_close (rcsbuf)
    struct rcsbuffer *rcsbuf;
{
    if (! rcsbuf_inuse)
	error (1, 0, "rcsbuf_close: internal error");
    rcsbuf_inuse = 0;
}

/* Read a key/value pair from an RCS file.  This sets *KEYP to point
   to the key, and *VALUEP to point to the value.  A missing or empty
   value is indicated by setting *VALUEP to NULL.

   This function returns 1 on success, or 0 on EOF.  If there is an
   error reading the file, or an EOF in an unexpected location, it
   gives a fatal error.

   This sets *KEYP and *VALUEP to point to storage managed by
   rcsbuf_getkey.  Moreover, *VALUEP has not been massaged from the
   RCS format: it may contain embedded whitespace and embedded '@@'
   characters.  Call rcsbuf_valcopy or rcsbuf_valpolish to do
   appropriate massaging.  */

/* Note that the extreme hair in rcsbuf_getkey is because profiling
   statistics show that it was worth it. */

static int
rcsbuf_getkey (rcsbuf, keyp, valp)
    struct rcsbuffer *rcsbuf;
    char **keyp;
    char **valp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* We've found the start of the key.  */

    *keyp = ptr;

    if (c != ';')
    {
	while (1)
	{
	    ++ptr;
	    if (ptr >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, (char **) NULL);
		if (ptr == NULL)
		    error (1, 0, "EOF in key in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    c = *ptr;
	    if (c == ';' || my_whitespace (c))
		break;
	}
    }

    /* Here *KEYP points to the key in the buffer, C is the character
       we found at the of the key, and PTR points to the location in
       the buffer where we found C.  We must set *PTR to \0 in order
       to terminate the key.  If the key ended with ';', then there is
       no value.  */

    *ptr = '\0';
    ++ptr;

    if (c == ';')
    {
	*valp = NULL;
	rcsbuf->ptr = ptr;
	return 1;
    }

    /* C must be whitespace.  Skip whitespace between the key and the
       value.  If we find ';' now, there is no value.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, keyp, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "EOF while looking for value in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}
	c = *ptr;
	if (c == ';')
	{
	    *valp = NULL;
	    rcsbuf->ptr = ptr + 1;
	    return 1;
	}
	if (! my_whitespace (c))
	    break;
	++ptr;
    }

    /* Now PTR points to the start of the value, and C is the first
       character of the value.  */

    if (c != '@@')
	*valp = ptr;
    else
    {
	char *pat;
	size_t vlen;

	/* Optimize the common case of a value composed of a single
	   '@@' string.  */

	rcsbuf->at_string = 1;

	++ptr;

	*valp = ptr;

	while (1)
	{
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	    {
		/* Note that we pass PTREND as the PTR value to
                   rcsbuf_fill, so that we will wind up setting PTR to
                   the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		/* Note that we pass PAT, not PTR, here.  */
		pat = rcsbuf_fill (rcsbuf, pat, keyp, valp);
		if (pat == NULL)
		{
		    /* EOF here is OK; it just means that the last
		       character of the file was an '@@' terminating a
		       value for a key type which does not require a
		       trailing ';'.  */
		    pat = rcsbuf->ptrend - 1;

		}
		ptrend = rcsbuf->ptrend;

		/* Note that the value of PTR is bogus here.  This is
		   OK, because we don't use it.  */
	    }

	    if (pat + 1 >= ptrend || pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ++rcsbuf->embedded_at;
	    ptr = pat + 2;
	}

	/* Here PAT points to the final '@@' in the string.  */

	*pat = '\0';

	vlen = pat - *valp;
	if (vlen == 0)
	    *valp = NULL;
	rcsbuf->vlen = vlen;

	ptr = pat + 1;
    }

    /* Certain keywords only have a '@@' string.  If there is no '@@'
       string, then the old getrcskey function assumed that they had
       no value, and we do the same.  */

    {
	char *k;

	k = *keyp;
	if (STREQ (k, RCSDESC)
	    || STREQ (k, "text")
	    || STREQ (k, "log"))
	{
	    if (c != '@@')
		*valp = NULL;
	    rcsbuf->ptr = ptr;
	    return 1;
	}
    }

    /* If we've already gathered a '@@' string, try to skip whitespace
       and find a ';'.  */
    if (c == '@@')
    {
	while (1)
	{
	    char n;

	    if (ptr >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    n = *ptr;
	    if (n == ';')
	    {
		/* We're done.  We already set everything up for this
                   case above.  */
		rcsbuf->ptr = ptr + 1;
		return 1;
	    }
	    if (! my_whitespace (n))
		break;
	    ++ptr;
	}

	/* The value extends past the '@@' string.  We need to undo the
           '@@' stripping done in the default case above.  This
           case never happens in a plain RCS file, but it can happen
           if user defined phrases are used.  */
	((*valp)--)[rcsbuf->vlen++] = '@@';
    }

    /* Here we have a value which is not a simple '@@' string.  We need
       to gather up everything until the next ';', including any '@@'
       strings.  *VALP points to the start of the value.  If
       RCSBUF->VLEN is not zero, then we have already read an '@@'
       string, and PTR points to the data following the '@@' string.
       Otherwise, PTR points to the start of the value.  */

    while (1)
    {
	char *start, *psemi, *pat;

	/* Find the ';' which must end the value.  */
	start = ptr;
	while ((psemi = memchr (ptr, ';', ptrend - ptr)) == NULL)
	{
	    int slen;

	    /* Note that we pass PTREND as the PTR value to
	       rcsbuf_fill, so that we will wind up setting PTR to the
	       location corresponding to the old PTREND, so that we
	       don't search the same bytes again.  */
	    slen = start - *valp;
	    ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
	    if (ptr == NULL)
		error (1, 0, "EOF in value in RCS file %s", rcsbuf->filename);
	    start = *valp + slen;
	    ptrend = rcsbuf->ptrend;
	}

	/* See if there are any '@@' strings in the value.  */
	pat = memchr (start, '@@', psemi - start);

	if (pat == NULL)
	{
	    size_t vlen;

	    /* We're done with the value.  Trim any trailing
               whitespace.  */

	    rcsbuf->ptr = psemi + 1;

	    start = *valp;
	    while (psemi > start && my_whitespace (psemi[-1]))
		--psemi;
	    *psemi = '\0';

	    vlen = psemi - start;
	    if (vlen == 0)
		*valp = NULL;
	    rcsbuf->vlen = vlen;

	    return 1;
	}

	/* We found an '@@' string in the value.  We set RCSBUF->AT_STRING
	   and RCSBUF->EMBEDDED_AT to indicate that we won't be able to
	   compress whitespace correctly for this type of value.
	   Since this type of value never arises in a normal RCS file,
	   this should not be a big deal.  It means that if anybody
	   adds a phrase which can have both an '@@' string and regular
	   text, they will have to handle whitespace compression
	   themselves.  */

	rcsbuf->at_string = 1;
	rcsbuf->embedded_at = -1;

	ptr = pat + 1;

	while (1)
	{
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	    {
		/* Note that we pass PTREND as the PTR value to
                   rcsbuff_fill, so that we will wind up setting PTR
                   to the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    if (pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ptr = pat + 2;
	}

	/* Here PAT points to the final '@@' in the string.  */
	ptr = pat + 1;
    }

#undef my_whitespace
}

/* Read an RCS revision number from an RCS file.  This sets *REVP to
   point to the revision number; it will point to space that is
   managed by the rcsbuf functions, and is only good until the next
   call to rcsbuf_getkey or rcsbuf_getrevnum.

   This function returns 1 on success, or 0 on EOF.  If there is an
   error reading the file, or an EOF in an unexpected location, it
   gives a fatal error.  */

static int
rcsbuf_getrevnum (rcsbuf, revp)
    struct rcsbuffer *rcsbuf;
    char **revp;
{
    char *ptr, *ptrend;
    char c;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    *revp = NULL;

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! whitespace (c))
	    break;

	++ptr;
    }

    if (! isdigit ((unsigned char) c) && c != '.')
	error (1, 0,
	       "\
unexpected '\\x%x' reading revision number in RCS file %s",
	       c, rcsbuf->filename);

    *revp = ptr;

    do
    {
	++ptr;
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, revp, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0,
		       "unexpected EOF reading revision number in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
    }
    while (isdigit ((unsigned char) c) || c == '.');

    if (! whitespace (c))
	error (1, 0, "\
unexpected '\\x%x' reading revision number in RCS file %s",
	       c, rcsbuf->filename);

    *ptr = '\0';

    rcsbuf->ptr = ptr + 1;

    return 1;
}

/* Fill RCSBUF_BUFFER with bytes from the file associated with RCSBUF,
   updating PTR and the PTREND field.  If KEYP and *KEYP are not NULL,
   then *KEYP points into the buffer, and must be adjusted if the
   buffer is changed.  Likewise for VALP.  Returns the new value of
   PTR, or NULL on error.  */

static char *
rcsbuf_fill (rcsbuf, ptr, keyp, valp)
    struct rcsbuffer *rcsbuf;
    char *ptr;
    char **keyp;
    char **valp;
{
    int got;

    if (rcsbuf->ptrend - rcsbuf_buffer + RCSBUF_BUFSIZE > rcsbuf_buffer_size)
    {
	int poff, peoff, koff, voff;

	poff = ptr - rcsbuf_buffer;
	peoff = rcsbuf->ptrend - rcsbuf_buffer;
	if (keyp != NULL && *keyp != NULL)
	    koff = *keyp - rcsbuf_buffer;
	if (valp != NULL && *valp != NULL)
	    voff = *valp - rcsbuf_buffer;
	koff = keyp == NULL ? 0 : *keyp - rcsbuf_buffer;
	voff = valp == NULL ? 0 : *valp - rcsbuf_buffer;

	expand_string (&rcsbuf_buffer, &rcsbuf_buffer_size,
		       rcsbuf_buffer_size + RCSBUF_BUFSIZE);

	ptr = rcsbuf_buffer + poff;
	rcsbuf->ptrend = rcsbuf_buffer + peoff;
	if (keyp != NULL && *keyp != NULL)
	    *keyp = rcsbuf_buffer + koff;
	if (valp != NULL && *valp != NULL)
	    *valp = rcsbuf_buffer + voff;
    }

    got = fread (rcsbuf->ptrend, 1, RCSBUF_BUFSIZE, rcsbuf->fp);
    if (got == 0)
    {
	if (ferror (rcsbuf->fp))
	    error (1, errno, "cannot read %s", rcsbuf->filename);
	return NULL;
    }

    rcsbuf->ptrend += got;

    return ptr;
}

/* Test whether the last value returned by rcsbuf_getkey is a composite
   value or not. */
   
static int
rcsbuf_valcmp (rcsbuf)
    struct rcsbuffer *rcsbuf;
{
    return rcsbuf->at_string && rcsbuf->embedded_at < 0;
}

/* Copy the value VAL returned by rcsbuf_getkey into a memory buffer,
   returning the memory buffer.  Polish the value like
   rcsbuf_valpolish, q.v.  */

static char *
rcsbuf_valcopy (rcsbuf, val, polish, lenp)
    struct rcsbuffer *rcsbuf;
    char *val;
    int polish;
    size_t *lenp;
{
    size_t vlen;
    int embedded_at;
    char *ret;

    if (val == NULL)
    {
	if (lenp != NULL)
	    *lenp = 0;
	return NULL;
    }

    vlen = rcsbuf->vlen;
    embedded_at = rcsbuf->embedded_at < 0 ? 0 : rcsbuf->embedded_at;

    ret = xmalloc (vlen - embedded_at + 1);

    if (rcsbuf->at_string ? embedded_at == 0 : ! polish)
    {
	/* No special action to take.  */
	memcpy (ret, val, vlen + 1);
	if (lenp != NULL)
	    *lenp = vlen;
	return ret;
    }

    rcsbuf_valpolish_internal (rcsbuf, ret, val, lenp);
    return ret;
}

/* Polish the value VAL returned by rcsbuf_getkey.  The POLISH
   parameter is non-zero if multiple embedded whitespace characters
   should be compressed into a single whitespace character.  Note that
   leading and trailing whitespace was already removed by
   rcsbuf_getkey.  Within an '@@' string, pairs of '@@' characters are
   compressed into a single '@@' character regardless of the value of
   POLISH.  If LENP is not NULL, set *LENP to the length of the value.  */

static void
rcsbuf_valpolish (rcsbuf, val, polish, lenp)
    struct rcsbuffer *rcsbuf;
    char *val;
    int polish;
    size_t *lenp;
{
    if (val == NULL)
    {
	if (lenp != NULL)
	    *lenp= 0;
	return;
    }

    if (rcsbuf->at_string ? rcsbuf->embedded_at == 0 : ! polish)
    {
	/* No special action to take.  */
	if (lenp != NULL)
	    *lenp = rcsbuf->vlen;
	return;
    }

    rcsbuf_valpolish_internal (rcsbuf, val, val, lenp);
}

/* Internal polishing routine, called from rcsbuf_valcopy and
   rcsbuf_valpolish.  */

static void
rcsbuf_valpolish_internal (rcsbuf, to, from, lenp)
    struct rcsbuffer *rcsbuf;
    char *to;
    const char *from;
    size_t *lenp;
{
    size_t len;

    len = rcsbuf->vlen;

    if (! rcsbuf->at_string)
    {
	char *orig_to;
	size_t clen;

	orig_to = to;

	for (clen = len; clen > 0; ++from, --clen)
	{
	    char c;

	    c = *from;
	    if (whitespace (c))
	    {
		/* Note that we know that clen can not drop to zero
                   while we have whitespace, because we know there is
                   no trailing whitespace.  */
		while (whitespace (from[1]))
		{
		    ++from;
		    --clen;
		}
		c = ' ';
	    }
	    *to++ = c;
	}

	*to = '\0';

	if (lenp != NULL)
	    *lenp = to - orig_to;
    }
    else
    {
	const char *orig_from;
	char *orig_to;
	int embedded_at;
	size_t clen;

	orig_from = from;
	orig_to = to;

	embedded_at = rcsbuf->embedded_at;
	assert (embedded_at > 0);

	if (lenp != NULL)
	    *lenp = len - embedded_at;

	for (clen = len; clen > 0; ++from, --clen)
	{
	    char c;

	    c = *from;
	    *to++ = c;
	    if (c == '@@')
	    {
		++from;

		/* Sanity check.  */
		if (*from != '@@' || clen == 0)
		    abort ();

		--clen;

		--embedded_at;
		if (embedded_at == 0)
		{
		    /* We've found all the embedded '@@' characters.
                       We can just memcpy the rest of the buffer after
                       this '@@' character.  */
		    if (orig_to != orig_from)
			memcpy (to, from + 1, clen - 1);
		    else
			memmove (to, from + 1, clen - 1);
		    from += clen;
		    to += clen - 1;
		    break;
		}
	    }
	}

	/* Sanity check.  */
	if (from != orig_from + len
	    || to != orig_to + (len - rcsbuf->embedded_at))
	{
	    abort ();
	}

	*to = '\0';
    }
}

#ifdef PRESERVE_PERMISSIONS_SUPPORT

/* Copy the next word from the value VALP returned by rcsbuf_getkey into a
   memory buffer, updating VALP and returning the memory buffer.  Return
   NULL when there are no more words. */

static char *
rcsbuf_valword (rcsbuf, valp)
    struct rcsbuffer *rcsbuf;
    char **valp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *pat;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    if (*valp == NULL)
	return NULL;

    for (ptr = *valp; my_whitespace (*ptr); ++ptr) ;
    if (*ptr == '\0')
    {
	assert (ptr - *valp == rcsbuf->vlen);
	*valp = NULL;
	rcsbuf->vlen = 0;
	return NULL;
    }

    /* PTR now points to the start of a value.  Find out whether it is
       a num, an id, a string or a colon. */
    c = *ptr;
    if (c == ':')
    {
	rcsbuf->vlen -= ++ptr - *valp;
	*valp = ptr;
	return xstrdup (":");
    }

    if (c == '@@')
    {
	int embedded_at = 0;
	size_t vlen;

	pat = ++ptr;
	while ((pat = strchr (pat, '@@')) != NULL)
	{
	    if (pat[1] != '@@')
		break;
	    ++embedded_at;
	    pat += 2;
	}

	/* Here PAT points to the final '@@' in the string.  */
	*pat++ = '\0';
	assert (rcsbuf->at_string);
	vlen = rcsbuf->vlen - (pat - *valp);
	rcsbuf->vlen = pat - ptr - 1;
	rcsbuf->embedded_at = embedded_at;
	ptr = rcsbuf_valcopy (rcsbuf, ptr, 0, (size_t *) NULL);
	*valp = pat;
	rcsbuf->vlen = vlen;
	if (strchr (pat, '@@') == NULL)
	    rcsbuf->at_string = 0;
	else
	    rcsbuf->embedded_at = -1;
	return ptr;
    }

    /* *PTR is neither `:', `;' nor `@@', so it should be the start of a num
       or an id.  Make sure it is not another special character. */
    if (c == '$' || c == '.' || c == ',')
    {
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);
    }

    pat = ptr;
    while (1)
    {
	/* Legitimate ID characters are digits, dots and any `graphic
           printing character that is not a special.' This test ought
	   to do the trick. */
	c = *++pat;
	if (!isprint ((unsigned char) c) ||
	    c == ';' || c == '$' || c == ',' || c == '@@' || c == ':')
	    break;
    }

    /* PAT points to the last non-id character in this word, and C is
       the character in its memory cell.  Check to make sure that it
       is a legitimate word delimiter -- whitespace or end. */
    if (c != '\0' && !my_whitespace (c))
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);

    *pat = '\0';
    rcsbuf->vlen -= pat - *valp;
    *valp = pat;
    return xstrdup (ptr);

#undef my_whitespace
}

#endif

/* Return the current position of an rcsbuf.  */

static unsigned long
rcsbuf_ftell (rcsbuf)
    struct rcsbuffer *rcsbuf;
{
    return rcsbuf->pos + (rcsbuf->ptr - rcsbuf_buffer);
}

/* Return a pointer to any data buffered for RCSBUF, along with the
   length.  */

static void
rcsbuf_get_buffered (rcsbuf, datap, lenp)
    struct rcsbuffer *rcsbuf;
    char **datap;
    size_t *lenp;
{
    *datap = rcsbuf->ptr;
    *lenp = rcsbuf->ptrend - rcsbuf->ptr;
}

/* CVS optimizes by quickly reading some header information from a
   file.  If it decides it needs to do more with the file, it reopens
   it.  We speed that up here by maintaining a cache of a single open
   file, to save the time it takes to reopen the file in the common
   case.  */

static RCSNode *cached_rcs;
static struct rcsbuffer cached_rcsbuf;

/* Cache RCS and RCSBUF.  This takes responsibility for closing
   RCSBUF->FP.  */

static void
rcsbuf_cache (rcs, rcsbuf)
    RCSNode *rcs;
    struct rcsbuffer *rcsbuf;
{
    if (cached_rcs != NULL)
	rcsbuf_cache_close ();
    cached_rcs = rcs;
    ++rcs->refcount;
    cached_rcsbuf = *rcsbuf;
}

/* If there is anything in the cache, close it.  */

static void
rcsbuf_cache_close ()
{
    if (cached_rcs != NULL)
    {
	if (fclose (cached_rcsbuf.fp) != 0)
	    error (0, errno, "cannot close %s", cached_rcsbuf.filename);
	rcsbuf_close (&cached_rcsbuf);
	freercsnode (&cached_rcs);
	cached_rcs = NULL;
    }
}

/* Open an rcsbuffer for RCS, getting it from the cache if possible.
   Set *FPP to the file, and *RCSBUFP to the rcsbuf.  The file should
   be put at position POS.  */

static void
rcsbuf_cache_open (rcs, pos, pfp, prcsbuf)
    RCSNode *rcs;
    long pos;
    FILE **pfp;
    struct rcsbuffer *prcsbuf;
{
    if (cached_rcs == rcs)
    {
	if (rcsbuf_ftell (&cached_rcsbuf) != pos)
	{
	    if (fseek (cached_rcsbuf.fp, pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file %s",
		       cached_rcsbuf.filename);
	    cached_rcsbuf.ptr = rcsbuf_buffer;
	    cached_rcsbuf.ptrend = rcsbuf_buffer;
	    cached_rcsbuf.pos = pos;
	}
	*pfp = cached_rcsbuf.fp;

	/* When RCS_parse opens a file using fopen_case, it frees the
           filename which we cached in CACHED_RCSBUF and stores a new
           file name in RCS->PATH.  We avoid problems here by always
           copying the filename over.  FIXME: This is hackish.  */
	cached_rcsbuf.filename = rcs->path;

	*prcsbuf = cached_rcsbuf;

	cached_rcs = NULL;

	/* Removing RCS from the cache removes a reference to it.  */
	--rcs->refcount;
	if (rcs->refcount <= 0)
	    error (1, 0, "rcsbuf_cache_open: internal error");
    }
    else
    {
	if (cached_rcs != NULL)
	    rcsbuf_cache_close ();

	*pfp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	if (*pfp == NULL)
	    error (1, 0, "unable to reopen `%s'", rcs->path);
	if (pos != 0)
	{
	    if (fseek (*pfp, pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file %s", rcs->path);
	}
	rcsbuf_open (prcsbuf, *pfp, rcs->path, pos);
    }
}


/*
 * process the symbols list of the rcs file
 */
static void
do_symbols (list, val)
    List *list;
    char *val;
{
    Node *p;
    char *cp = val;
    char *tag, *rev;

    for (;;)
    {
	/* skip leading whitespace */
	while (whitespace (*cp))
	    cp++;

	/* if we got to the end, we are done */
	if (*cp == '\0')
	    break;

	/* split it up into tag and rev */
	tag = cp;
	cp = strchr (cp, ':');
	*cp++ = '\0';
	rev = cp;
	while (!whitespace (*cp) && *cp != '\0')
	    cp++;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* make a new node and add it to the list */
	p = getnode ();
	p->key = xstrdup (tag);
	p->data = xstrdup (rev);
	(void) addnode (list, p);
    }
}

/*
 * process the locks list of the rcs file
 * Like do_symbols, but hash entries are keyed backwards: i.e.
 * an entry like `user:rev' is keyed on REV rather than on USER.
 */
static void
do_locks (list, val)
    List *list;
    char *val;
{
    Node *p;
    char *cp = val;
    char *user, *rev;

    for (;;)
    {
	/* skip leading whitespace */
	while (whitespace (*cp))
	    cp++;

	/* if we got to the end, we are done */
	if (*cp == '\0')
	    break;

	/* split it up into user and rev */
	user = cp;
	cp = strchr (cp, ':');
	*cp++ = '\0';
	rev = cp;
	while (!whitespace (*cp) && *cp != '\0')
	    cp++;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* make a new node and add it to the list */
	p = getnode ();
	p->key = xstrdup (rev);
	p->data = xstrdup (user);
	(void) addnode (list, p);
    }
}

/*
 * process the branches list of a revision delta
 */
static void
do_branches (list, val)
    List *list;
    char *val;
{
    Node *p;
    char *cp = val;
    char *branch;

    for (;;)
    {
	/* skip leading whitespace */
	while (whitespace (*cp))
	    cp++;

	/* if we got to the end, we are done */
	if (*cp == '\0')
	    break;

	/* find the end of this branch */
	branch = cp;
	while (!whitespace (*cp) && *cp != '\0')
	    cp++;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* make a new node and add it to the list */
	p = getnode ();
	p->key = xstrdup (branch);
	(void) addnode (list, p);
    }
}

/*
 * Version Number
 * 
 * Returns the requested version number of the RCS file, satisfying tags and/or
 * dates, and walking branches, if necessary.
 * 
 * The result is returned; null-string if error.
 */
char *
RCS_getversion (rcs, tag, date, force_tag_match, simple_tag)
    RCSNode *rcs;
    char *tag;
    char *date;
    int force_tag_match;
    int *simple_tag;
{
    if (simple_tag != NULL)
	*simple_tag = 0;

    /* make sure we have something to look at... */
    assert (rcs != NULL);

    if (tag && date)
    {
	char *branch, *rev;

	if (! RCS_nodeisbranch (rcs, tag))
	{
	    /* We can't get a particular date if the tag is not a
               branch.  */
	    return NULL;
	}

	/* Work out the branch.  */
	if (! isdigit ((unsigned char) tag[0]))
	    branch = RCS_whatbranch (rcs, tag);
	else
	    branch = xstrdup (tag);

	/* Fetch the revision of branch as of date.  */
	rev = RCS_getdatebranch (rcs, date, branch);
	free (branch);
	return (rev);
    }
    else if (tag)
	return (RCS_gettag (rcs, tag, force_tag_match, simple_tag));
    else if (date)
	return (RCS_getdate (rcs, date, force_tag_match));
    else
	return (RCS_head (rcs));

}

/*
 * Get existing revision number corresponding to tag or revision.
 * Similar to RCS_gettag but less interpretation imposed.
 * For example:
 * -- If tag designates a magic branch, RCS_tag2rev
 *    returns the magic branch number.
 * -- If tag is a branch tag, returns the branch number, not
 *    the revision of the head of the branch.
 * If tag or revision is not valid or does not exist in file,
 * return NULL.
 */
char *
RCS_tag2rev (rcs, tag)
    RCSNode *rcs;
    char *tag;
{
    char *rev, *pa, *pb;
    int i;

    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* If a valid revision, try to look it up */
    if ( RCS_valid_rev (tag) )
    {
	/* Make a copy so we can scribble on it */
	rev =  xstrdup (tag);

	/* If revision exists, return the copy */
	if (RCS_exist_rev (rcs, tag))
	    return rev;

	/* Nope, none such. If tag is not a branch we're done. */ 
	i = numdots (rev);
	if ((i & 1) == 1 )
	{
	    pa = strrchr (rev, '.');
	    if (i == 1 || *(pa-1) != RCS_MAGIC_BRANCH || *(pa-2) != '.')
	    {
		free (rev);
		error (1, 0, "revision `%s' does not exist", tag);
	    }
	}

	/* Try for a real (that is, exists in the RCS deltas) branch
	   (RCS_exist_rev just checks for real revisions and revisions
	   which have tags pointing to them).  */
	pa = RCS_getbranch (rcs, rev, 1);
	if (pa != NULL)
	{
	    free (pa);
	    return rev;
	}

       /* Tag is branch, but does not exist, try corresponding 
	* magic branch tag.
	*
	* FIXME: assumes all magic branches are of       
	* form "n.n.n ... .0.n".  I'll fix if somebody can
	* send me a method to get a magic branch tag with
	* the 0 in some other position -- <dan@@gasboy.com>
	*/ 
	pa = strrchr (rev, '.');
	pb = xmalloc (strlen (rev) + 3);
	*pa++ = 0;
	(void) sprintf (pb, "%s.%d.%s", rev, RCS_MAGIC_BRANCH, pa);
	free (rev);
	rev = pb;
	if (RCS_exist_rev (rcs, rev))
	    return rev;
	error (1, 0, "revision `%s' does not exist", tag);
    }


    RCS_check_tag (tag); /* exit if not a valid tag */

    /* If tag is "HEAD", special case to get head RCS revision */
    if (tag && STREQ (tag, TAG_HEAD))
        return (RCS_head (rcs));

    /* If valid tag let translate_symtag say yea or nay. */
    rev = translate_symtag (rcs, tag);

    if (rev)
        return rev;

    /* Trust the caller to print warnings. */
    return NULL;
}

/*
 * Find the revision for a specific tag.
 * If force_tag_match is set, return NULL if an exact match is not
 * possible otherwise return RCS_head ().  We are careful to look for
 * and handle "magic" revisions specially.
 * 
 * If the matched tag is a branch tag, find the head of the branch.
 * 
 * Returns pointer to newly malloc'd string, or NULL.
 */
char *
RCS_gettag (rcs, symtag, force_tag_match, simple_tag)
    RCSNode *rcs;
    char *symtag;
    int force_tag_match;
    int *simple_tag;
{
    char *tag = symtag;
    int tag_allocated = 0;

    if (simple_tag != NULL)
	*simple_tag = 0;

    /* make sure we have something to look at... */
    assert (rcs != NULL);

    /* XXX this is probably not necessary, --jtc */
    if (rcs->flags & PARTIAL) 
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* If tag is "HEAD", special case to get head RCS revision */
    if (tag && (STREQ (tag, TAG_HEAD) || *tag == '\0'))
#if 0 /* This #if 0 is only in the Cygnus code.  Why?  Death support?  */
	if (force_tag_match && (rcs->flags & VALID) && (rcs->flags & INATTIC))
	    return ((char *) NULL);	/* head request for removed file */
	else
#endif
	    return (RCS_head (rcs));

    if (!isdigit ((unsigned char) tag[0]))
    {
	char *version;

	/* If we got a symbolic tag, resolve it to a numeric */
	version = translate_symtag (rcs, tag);
	if (version != NULL)
	{
	    int dots;
	    char *magic, *branch, *cp;

	    tag = version;
	    tag_allocated = 1;

	    /*
	     * If this is a magic revision, we turn it into either its
	     * physical branch equivalent (if one exists) or into
	     * its base revision, which we assume exists.
	     */
	    dots = numdots (tag);
	    if (dots > 2 && (dots & 1) != 0)
	    {
		branch = strrchr (tag, '.');
		cp = branch++ - 1;
		while (*cp != '.')
		    cp--;

		/* see if we have .magic-branch. (".0.") */
		magic = xmalloc (strlen (tag) + 1);
		(void) sprintf (magic, ".%d.", RCS_MAGIC_BRANCH);
		if (strncmp (magic, cp, strlen (magic)) == 0)
		{
		    /* it's magic.  See if the branch exists */
		    *cp = '\0';		/* turn it into a revision */
		    (void) sprintf (magic, "%s.%s", tag, branch);
		    branch = RCS_getbranch (rcs, magic, 1);
		    free (magic);
		    if (branch != NULL)
		    {
			free (tag);
			return (branch);
		    }
		    return (tag);
		}
		free (magic);
	    }
	}
	else
	{
	    /* The tag wasn't there, so return the head or NULL */
	    if (force_tag_match)
		return (NULL);
	    else
		return (RCS_head (rcs));
	}
    }

    /*
     * numeric tag processing:
     *		1) revision number - just return it
     *		2) branch number   - find head of branch
     */

    /* strip trailing dots */
    while (tag[strlen (tag) - 1] == '.')
	tag[strlen (tag) - 1] = '\0';

    if ((numdots (tag) & 1) == 0)
    {
	char *branch;

	/* we have a branch tag, so we need to walk the branch */
	branch = RCS_getbranch (rcs, tag, force_tag_match);
	if (tag_allocated)
	    free (tag);
	return branch;
    }
    else
    {
	Node *p;

	/* we have a revision tag, so make sure it exists */
	p = findnode (rcs->versions, tag);
	if (p != NULL)
	{
	    /* We have found a numeric revision for the revision tag.
	       To support expanding the RCS keyword Name, if
	       SIMPLE_TAG is not NULL, tell the the caller that this
	       is a simple tag which co will recognize.  FIXME: Are
	       there other cases in which we should set this?  In
	       particular, what if we expand RCS keywords internally
	       without calling co?  */
	    if (simple_tag != NULL)
		*simple_tag = 1;
	    if (! tag_allocated)
		tag = xstrdup (tag);
	    return (tag);
	}
	else
	{
	    /* The revision wasn't there, so return the head or NULL */
	    if (tag_allocated)
		free (tag);
	    if (force_tag_match)
		return (NULL);
	    else
		return (RCS_head (rcs));
	}
    }
}

/*
 * Return a "magic" revision as a virtual branch off of REV for the RCS file.
 * A "magic" revision is one which is unique in the RCS file.  By unique, I
 * mean we return a revision which:
 *	- has a branch of 0 (see rcs.h RCS_MAGIC_BRANCH)
 *	- has a revision component which is not an existing branch off REV
 *	- has a revision component which is not an existing magic revision
 *	- is an even-numbered revision, to avoid conflicts with vendor branches
 * The first point is what makes it "magic".
 *
 * As an example, if we pass in 1.37 as REV, we will look for an existing
 * branch called 1.37.2.  If it did not exist, we would look for an
 * existing symbolic tag with a numeric part equal to 1.37.0.2.  If that
 * didn't exist, then we know that the 1.37.2 branch can be reserved by
 * creating a symbolic tag with 1.37.0.2 as the numeric part.
 *
 * This allows us to fork development with very little overhead -- just a
 * symbolic tag is used in the RCS file.  When a commit is done, a physical
 * branch is dynamically created to hold the new revision.
 *
 * Note: We assume that REV is an RCS revision and not a branch number.
 */
static char *check_rev;
char *
RCS_magicrev (rcs, rev)
    RCSNode *rcs;
    char *rev;
{
    int rev_num;
    char *xrev, *test_branch;

    xrev = xmalloc (strlen (rev) + 14); /* enough for .0.number */
    check_rev = xrev;

    /* only look at even numbered branches */
    for (rev_num = 2; ; rev_num += 2)
    {
	/* see if the physical branch exists */
	(void) sprintf (xrev, "%s.%d", rev, rev_num);
	test_branch = RCS_getbranch (rcs, xrev, 1);
	if (test_branch != NULL)	/* it did, so keep looking */
	{
	    free (test_branch);
	    continue;
	}

	/* now, create a "magic" revision */
	(void) sprintf (xrev, "%s.%d.%d", rev, RCS_MAGIC_BRANCH, rev_num);

	/* walk the symbols list to see if a magic one already exists */
	if (walklist (RCS_symbols(rcs), checkmagic_proc, NULL) != 0)
	    continue;

	/* we found a free magic branch.  Claim it as ours */
	return (xrev);
    }
}

/*
 * walklist proc to look for a match in the symbols list.
 * Returns 0 if the symbol does not match, 1 if it does.
 */
static int
checkmagic_proc (p, closure)
    Node *p;
    void *closure;
{
    if (STREQ (check_rev, p->data))
	return (1);
    else
	return (0);
}

/*
 * Given an RCSNode, returns non-zero if the specified revision number 
 * or symbolic tag resolves to a "branch" within the rcs file.
 *
 * FIXME: this is the same as RCS_nodeisbranch except for the special 
 *        case for handling a null rcsnode.
 */
int
RCS_isbranch (rcs, rev)
    RCSNode *rcs;
    const char *rev;
{
    /* numeric revisions are easy -- even number of dots is a branch */
    if (isdigit ((unsigned char) *rev))
	return ((numdots (rev) & 1) == 0);

    /* assume a revision if you can't find the RCS info */
    if (rcs == NULL)
	return (0);

    /* now, look for a match in the symbols list */
    return (RCS_nodeisbranch (rcs, rev));
}

/*
 * Given an RCSNode, returns non-zero if the specified revision number
 * or symbolic tag resolves to a "branch" within the rcs file.  We do
 * take into account any magic branches as well.
 */
int
RCS_nodeisbranch (rcs, rev)
    RCSNode *rcs;
    const char *rev;
{
    int dots;
    char *version;

    assert (rcs != NULL);

    /* numeric revisions are easy -- even number of dots is a branch */
    if (isdigit ((unsigned char) *rev))
	return ((numdots (rev) & 1) == 0);

    version = translate_symtag (rcs, rev);
    if (version == NULL)
	return (0);
    dots = numdots (version);
    if ((dots & 1) == 0)
    {
	free (version);
	return (1);
    }

    /* got a symbolic tag match, but it's not a branch; see if it's magic */
    if (dots > 2)
    {
	char *magic;
	char *branch = strrchr (version, '.');
	char *cp = branch - 1;
	while (*cp != '.')
	    cp--;

	/* see if we have .magic-branch. (".0.") */
	magic = xmalloc (strlen (version) + 1);
	(void) sprintf (magic, ".%d.", RCS_MAGIC_BRANCH);
	if (strncmp (magic, cp, strlen (magic)) == 0)
	{
	    free (magic);
	    free (version);
	    return (1);
	}
	free (magic);
    }
    free (version);
    return (0);
}

/*
 * Returns a pointer to malloc'ed memory which contains the branch
 * for the specified *symbolic* tag.  Magic branches are handled correctly.
 */
char *
RCS_whatbranch (rcs, rev)
    RCSNode *rcs;
    const char *rev;
{
    char *version;
    int dots;

    /* assume no branch if you can't find the RCS info */
    if (rcs == NULL)
	return ((char *) NULL);

    /* now, look for a match in the symbols list */
    version = translate_symtag (rcs, rev);
    if (version == NULL)
	return ((char *) NULL);
    dots = numdots (version);
    if ((dots & 1) == 0)
	return (version);

    /* got a symbolic tag match, but it's not a branch; see if it's magic */
    if (dots > 2)
    {
	char *magic;
	char *branch = strrchr (version, '.');
	char *cp = branch++ - 1;
	while (*cp != '.')
	    cp--;

	/* see if we have .magic-branch. (".0.") */
	magic = xmalloc (strlen (version) + 1);
	(void) sprintf (magic, ".%d.", RCS_MAGIC_BRANCH);
	if (strncmp (magic, cp, strlen (magic)) == 0)
	{
	    /* yep.  it's magic.  now, construct the real branch */
	    *cp = '\0';			/* turn it into a revision */
	    (void) sprintf (magic, "%s.%s", version, branch);
	    free (version);
	    return (magic);
	}
	free (magic);
    }
    free (version);
    return ((char *) NULL);
}

/*
 * Get the head of the specified branch.  If the branch does not exist,
 * return NULL or RCS_head depending on force_tag_match.
 * Returns NULL or a newly malloc'd string.
 */
char *
RCS_getbranch (rcs, tag, force_tag_match)
    RCSNode *rcs;
    char *tag;
    int force_tag_match;
{
    Node *p, *head;
    RCSVers *vn;
    char *xtag;
    char *nextvers;
    char *cp;

    /* make sure we have something to look at... */
    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* find out if the tag contains a dot, or is on the trunk */
    cp = strrchr (tag, '.');

    /* trunk processing is the special case */
    if (cp == NULL)
    {
	xtag = xmalloc (strlen (tag) + 1 + 1);	/* +1 for an extra . */
	(void) strcpy (xtag, tag);
	(void) strcat (xtag, ".");
	for (cp = rcs->head; cp != NULL;)
	{
	    if (strncmp (xtag, cp, strlen (xtag)) == 0)
		break;
	    p = findnode (rcs->versions, cp);
	    if (p == NULL)
	    {
		free (xtag);
		if (force_tag_match)
		    return (NULL);
		else
		    return (RCS_head (rcs));
	    }
	    vn = (RCSVers *) p->data;
	    cp = vn->next;
	}
	free (xtag);
	if (cp == NULL)
	{
	    if (force_tag_match)
		return (NULL);
	    else
		return (RCS_head (rcs));
	}
	return (xstrdup (cp));
    }

    /* if it had a `.', terminate the string so we have the base revision */
    *cp = '\0';

    /* look up the revision this branch is based on */
    p = findnode (rcs->versions, tag);

    /* put the . back so we have the branch again */
    *cp = '.';

    if (p == NULL)
    {
	/* if the base revision didn't exist, return head or NULL */
	if (force_tag_match)
	    return (NULL);
	else
	    return (RCS_head (rcs));
    }

    /* find the first element of the branch we are looking for */
    vn = (RCSVers *) p->data;
    if (vn->branches == NULL)
	return (NULL);
    xtag = xmalloc (strlen (tag) + 1 + 1);	/* 1 for the extra '.' */
    (void) strcpy (xtag, tag);
    (void) strcat (xtag, ".");
    head = vn->branches->list;
    for (p = head->next; p != head; p = p->next)
	if (strncmp (p->key, xtag, strlen (xtag)) == 0)
	    break;
    free (xtag);

    if (p == head)
    {
	/* we didn't find a match so return head or NULL */
	if (force_tag_match)
	    return (NULL);
	else
	    return (RCS_head (rcs));
    }

    /* now walk the next pointers of the branch */
    nextvers = p->key;
    do
    {
	p = findnode (rcs->versions, nextvers);
	if (p == NULL)
	{
	    /* a link in the chain is missing - return head or NULL */
	    if (force_tag_match)
		return (NULL);
	    else
		return (RCS_head (rcs));
	}
	vn = (RCSVers *) p->data;
	nextvers = vn->next;
    } while (nextvers != NULL);

    /* we have the version in our hand, so go for it */
    return (xstrdup (vn->version));
}

/* Returns the head of the branch which REV is on.  REV can be a
   branch tag or non-branch tag; symbolic or numeric.

   Returns a newly malloc'd string.  Returns NULL if a symbolic name
   isn't found.  */

char *
RCS_branch_head (rcs, rev)
    RCSNode *rcs;
    char *rev;
{
    char *num;
    char *br;
    char *retval;

    assert (rcs != NULL);

    if (RCS_nodeisbranch (rcs, rev))
	return RCS_getbranch (rcs, rev, 1);

    if (isdigit ((unsigned char) *rev))
	num = xstrdup (rev);
    else
    {
	num = translate_symtag (rcs, rev);
	if (num == NULL)
	    return NULL;
    }
    br = truncate_revnum (num);
    retval = RCS_getbranch (rcs, br, 1);
    free (br);
    free (num);
    return retval;
}

/* Get the branch point for a particular branch, that is the first
   revision on that branch.  For example, RCS_getbranchpoint (rcs,
   "1.3.2") will normally return "1.3.2.1".  TARGET may be either a
   branch number or a revision number; if a revnum, find the
   branchpoint of the branch to which TARGET belongs.

   Return RCS_head if TARGET is on the trunk or if the root node could
   not be found (this is sort of backwards from our behavior on a branch;
   the rationale is that the return value is a revision from which you
   can start walking the next fields and end up at TARGET).
   Return NULL on error.  */

static char *
RCS_getbranchpoint (rcs, target)
    RCSNode *rcs;
    char *target;
{
    char *branch, *bp;
    Node *vp;
    RCSVers *rev;
    int dots, isrevnum, brlen;

    dots = numdots (target);
    isrevnum = dots & 1;

    if (dots == 1)
	/* TARGET is a trunk revision; return rcs->head. */
	return (RCS_head (rcs));

    /* Get the revision number of the node at which TARGET's branch is
       rooted.  If TARGET is a branch number, lop off the last field;
       if it's a revision number, lop off the last *two* fields. */
    branch = xstrdup (target);
    bp = strrchr (branch, '.');
    if (bp == NULL)
	error (1, 0, "%s: confused revision number %s",
	       rcs->path, target);
    if (isrevnum)
	while (*--bp != '.')
	    ;
    *bp = '\0';

    vp = findnode (rcs->versions, branch);
    if (vp == NULL)
    {	
	error (0, 0, "%s: can't find branch point %s", rcs->path, target);
	return NULL;
    }
    rev = (RCSVers *) vp->data;

    *bp++ = '.';
    while (*bp && *bp != '.')
	++bp;
    brlen = bp - branch;

    vp = rev->branches->list->next;
    while (vp != rev->branches->list)
    {
	/* BRANCH may be a genuine branch number, e.g. `1.1.3', or
	   maybe a full revision number, e.g. `1.1.3.6'.  We have
	   found our branch point if the first BRANCHLEN characters
	   of the revision number match, *and* if the following
	   character is a dot. */
	if (strncmp (vp->key, branch, brlen) == 0 && vp->key[brlen] == '.')
	    break;
	vp = vp->next;
    }

    free (branch);
    if (vp == rev->branches->list)
    {
	error (0, 0, "%s: can't find branch point %s", rcs->path, target);
	return NULL;
    }
    else
	return (xstrdup (vp->key));
}

/*
 * Get the head of the RCS file.  If branch is set, this is the head of the
 * branch, otherwise the real head.
 * Returns NULL or a newly malloc'd string.
 */
char *
RCS_head (rcs)
    RCSNode *rcs;
{
    /* make sure we have something to look at... */
    assert (rcs != NULL);

    /*
     * NOTE: we call getbranch with force_tag_match set to avoid any
     * possibility of recursion
     */
    if (rcs->branch)
	return (RCS_getbranch (rcs, rcs->branch, 1));
    else
	return (xstrdup (rcs->head));
}

/*
 * Get the most recent revision, based on the supplied date, but use some
 * funky stuff and follow the vendor branch maybe
 */
char *
RCS_getdate (rcs, date, force_tag_match)
    RCSNode *rcs;
    char *date;
    int force_tag_match;
{
    char *cur_rev = NULL;
    char *retval = NULL;
    Node *p;
    RCSVers *vers = NULL;

    /* make sure we have something to look at... */
    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* if the head is on a branch, try the branch first */
    if (rcs->branch != NULL)
	retval = RCS_getdatebranch (rcs, date, rcs->branch);

    /* if we found a match, we are done */
    if (retval != NULL)
	return (retval);

    /* otherwise if we have a trunk, try it */
    if (rcs->head)
    {
	p = findnode (rcs->versions, rcs->head);
	while (p != NULL)
	{
	    /* if the date of this one is before date, take it */
	    vers = (RCSVers *) p->data;
	    if (RCS_datecmp (vers->date, date) <= 0)
	    {
		cur_rev = vers->version;
		break;
	    }

	    /* if there is a next version, find the node */
	    if (vers->next != NULL)
		p = findnode (rcs->versions, vers->next);
	    else
		p = (Node *) NULL;
	}
    }

    /*
     * at this point, either we have the revision we want, or we have the
     * first revision on the trunk (1.1?) in our hands
     */

    /* if we found what we're looking for, and it's not 1.1 return it */
    if (cur_rev != NULL)
    {
	if (! STREQ (cur_rev, "1.1"))
	    return (xstrdup (cur_rev));

	/* This is 1.1;  if the date of 1.1 is not the same as that for the
	   1.1.1.1 version, then return 1.1.  This happens when the first
	   version of a file is created by a regular cvs add and commit,
	   and there is a subsequent cvs import of the same file.  */
	p = findnode (rcs->versions, "1.1.1.1");
	if (p)
	{
	    vers = (RCSVers *) p->data;
	    if (RCS_datecmp (vers->date, date) != 0)
		return xstrdup ("1.1");
	}
    }

    /* look on the vendor branch */
    retval = RCS_getdatebranch (rcs, date, CVSBRANCH);

    /*
     * if we found a match, return it; otherwise, we return the first
     * revision on the trunk or NULL depending on force_tag_match and the
     * date of the first rev
     */
    if (retval != NULL)
	return (retval);

    if (vers && (!force_tag_match || RCS_datecmp (vers->date, date) <= 0))
	return (xstrdup (vers->version));
    else
	return (NULL);
}

/*
 * Look up the last element on a branch that was put in before the specified
 * date (return the rev or NULL)
 */
static char *
RCS_getdatebranch (rcs, date, branch)
    RCSNode *rcs;
    char *date;
    char *branch;
{
    char *cur_rev = NULL;
    char *cp;
    char *xbranch, *xrev;
    Node *p;
    RCSVers *vers;

    /* look up the first revision on the branch */
    xrev = xstrdup (branch);
    cp = strrchr (xrev, '.');
    if (cp == NULL)
    {
	free (xrev);
	return (NULL);
    }
    *cp = '\0';				/* turn it into a revision */

    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    p = findnode (rcs->versions, xrev);
    free (xrev);
    if (p == NULL)
	return (NULL);
    vers = (RCSVers *) p->data;

    /* Tentatively use this revision, if it is early enough.  */
    if (RCS_datecmp (vers->date, date) <= 0)
	cur_rev = vers->version;

    /* If no branches list, return now.  This is what happens if the branch
       is a (magic) branch with no revisions yet.  */
    if (vers->branches == NULL)
	return xstrdup (cur_rev);

    /* walk the branches list looking for the branch number */
    xbranch = xmalloc (strlen (branch) + 1 + 1); /* +1 for the extra dot */
    (void) strcpy (xbranch, branch);
    (void) strcat (xbranch, ".");
    for (p = vers->branches->list->next; p != vers->branches->list; p = p->next)
	if (strncmp (p->key, xbranch, strlen (xbranch)) == 0)
	    break;
    free (xbranch);
    if (p == vers->branches->list)
    {
	/* This is what happens if the branch is a (magic) branch with
	   no revisions yet.  Similar to the case where vers->branches ==
	   NULL, except here there was a another branch off the same
	   branchpoint.  */
	return xstrdup (cur_rev);
    }

    p = findnode (rcs->versions, p->key);

    /* walk the next pointers until you find the end, or the date is too late */
    while (p != NULL)
    {
	vers = (RCSVers *) p->data;
	if (RCS_datecmp (vers->date, date) <= 0)
	    cur_rev = vers->version;
	else
	    break;

	/* if there is a next version, find the node */
	if (vers->next != NULL)
	    p = findnode (rcs->versions, vers->next);
	else
	    p = (Node *) NULL;
    }

    /* Return whatever we found, which may be NULL.  */
    return xstrdup (cur_rev);
}

/*
 * Compare two dates in RCS format. Beware the change in format on January 1,
 * 2000, when years go from 2-digit to full format.
 */
int
RCS_datecmp (date1, date2)
    char *date1, *date2;
{
    int length_diff = strlen (date1) - strlen (date2);

    return (length_diff ? length_diff : strcmp (date1, date2));
}

/* Look up revision REV in RCS and return the date specified for the
   revision minus FUDGE seconds (FUDGE will generally be one, so that the
   logically previous revision will be found later, or zero, if we want
   the exact date).

   The return value is the date being returned as a time_t, or (time_t)-1
   on error (previously was documented as zero on error; I haven't checked
   the callers to make sure that they really check for (time_t)-1, but
   the latter is what this function really returns).  If DATE is non-NULL,
   then it must point to MAXDATELEN characters, and we store the same
   return value there in DATEFORM format.  */
time_t
RCS_getrevtime (rcs, rev, date, fudge)
    RCSNode *rcs;
    char *rev;
    char *date;
    int fudge;
{
    char tdate[MAXDATELEN];
    struct tm xtm, *ftm;
    time_t revdate = 0;
    Node *p;
    RCSVers *vers;

    /* make sure we have something to look at... */
    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* look up the revision */
    p = findnode (rcs->versions, rev);
    if (p == NULL)
	return (-1);
    vers = (RCSVers *) p->data;

    /* split up the date */
    ftm = &xtm;
    (void) sscanf (vers->date, SDATEFORM, &ftm->tm_year, &ftm->tm_mon,
		   &ftm->tm_mday, &ftm->tm_hour, &ftm->tm_min,
		   &ftm->tm_sec);

    /* If the year is from 1900 to 1999, RCS files contain only two
       digits, and sscanf gives us a year from 0-99.  If the year is
       2000+, RCS files contain all four digits and we subtract 1900,
       because the tm_year field should contain years since 1900.  */

    if (ftm->tm_year > 1900)
	ftm->tm_year -= 1900;

    /* put the date in a form getdate can grok */
    (void) sprintf (tdate, "%d/%d/%d GMT %d:%d:%d", ftm->tm_mon,
		    ftm->tm_mday, ftm->tm_year + 1900, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);

    /* turn it into seconds since the epoch */
    revdate = get_date (tdate);
    if (revdate != (time_t) -1)
    {
	revdate -= fudge;		/* remove "fudge" seconds */
	if (date)
	{
	    /* put an appropriate string into ``date'' if we were given one */
	    ftm = gmtime (&revdate);
	    (void) sprintf (date, DATEFORM,
			    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
			    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
			    ftm->tm_min, ftm->tm_sec);
	}
    }
    return (revdate);
}

List *
RCS_getlocks (rcs)
    RCSNode *rcs;
{
    assert(rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rcs->locks_data) {
	rcs->locks = getlist ();
	do_locks (rcs->locks, rcs->locks_data);
	free(rcs->locks_data);
	rcs->locks_data = NULL;
    }

    return rcs->locks;
}

List *
RCS_symbols(rcs)
    RCSNode *rcs;
{
    assert(rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rcs->symbols_data) {
	rcs->symbols = getlist ();
	do_symbols (rcs->symbols, rcs->symbols_data);
	free(rcs->symbols_data);
	rcs->symbols_data = NULL;
    }

    return rcs->symbols;
}

/*
 * Return the version associated with a particular symbolic tag.
 * Returns NULL or a newly malloc'd string.
 */
static char *
translate_symtag (rcs, tag)
    RCSNode *rcs;
    const char *tag;
{
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rcs->symbols != NULL)
    {
	Node *p;

	/* The symbols have already been converted into a list.  */
	p = findnode (rcs->symbols, tag);
	if (p == NULL)
	    return NULL;

	return xstrdup (p->data);
    }

    if (rcs->symbols_data != NULL)
    {
	size_t len;
	char *cp;

	/* Look through the RCS symbols information.  This is like
           do_symbols, but we don't add the information to a list.  In
           most cases, we will only be called once for this file, so
           generating the list is unnecessary overhead.  */

	len = strlen (tag);
	cp = rcs->symbols_data;
	while ((cp = strchr (cp, tag[0])) != NULL)
	{
	    if ((cp == rcs->symbols_data || whitespace (cp[-1]))
		&& strncmp (cp, tag, len) == 0
		&& cp[len] == ':')
	    {
		char *v, *r;

		/* We found the tag.  Return the version number.  */

		cp += len + 1;
		v = cp;
		while (! whitespace (*cp) && *cp != '\0')
		    ++cp;
		r = xmalloc (cp - v + 1);
		strncpy (r, v, cp - v);
		r[cp - v] = '\0';
		return r;
	    }

	    while (! whitespace (*cp) && *cp != '\0')
		++cp;
	}
    }

    return NULL;
}

/*
 * The argument ARG is the getopt remainder of the -k option specified on the
 * command line.  This function returns malloc'ed space that can be used
 * directly in calls to RCS V5, with the -k flag munged correctly.
 */
char *
RCS_check_kflag (arg)
    const char *arg;
{
    static const char *const  keyword_usage[] =
    {
      "%s %s: invalid RCS keyword expansion mode\n",
      "Valid expansion modes include:\n",
      "   -kkv\tGenerate keywords using the default form.\n",
      "   -kkvl\tLike -kkv, except locker's name inserted.\n",
      "   -kk\tGenerate only keyword names in keyword strings.\n",
      "   -kv\tGenerate only keyword values in keyword strings.\n",
      "   -ko\tGenerate the old keyword string (no changes from checked in file).\n",
      "   -kb\tGenerate binary file unmodified (merges not allowed) (RCS 5.7).\n",
      "(Specify the --help global option for a list of other help options)\n",
      NULL,
    };
    /* Big enough to hold any of the strings from kflags.  */
    char karg[10];
    char const *const *cpp = NULL;

    if (arg)
    {
	for (cpp = kflags; *cpp != NULL; cpp++)
	{
	    if (STREQ (arg, *cpp))
		break;
	}
    }

    if (arg == NULL || *cpp == NULL)
    {
	usage (keyword_usage);
    }

    (void) sprintf (karg, "-k%s", *cpp);
    return (xstrdup (karg));
}

/*
 * Do some consistency checks on the symbolic tag... These should equate
 * pretty close to what RCS checks, though I don't know for certain.
 */
void
RCS_check_tag (tag)
    const char *tag;
{
    char *invalid = "$,.:;@@";		/* invalid RCS tag characters */
    const char *cp;

    /*
     * The first character must be an alphabetic letter. The remaining
     * characters cannot be non-visible graphic characters, and must not be
     * in the set of "invalid" RCS identifier characters.
     */
    if (isalpha ((unsigned char) *tag))
    {
	for (cp = tag; *cp; cp++)
	{
	    if (!isgraph ((unsigned char) *cp))
		error (1, 0, "tag `%s' has non-visible graphic characters",
		       tag);
	    if (strchr (invalid, *cp))
		error (1, 0, "tag `%s' must not contain the characters `%s'",
		       tag, invalid);
	}
    }
    else
	error (1, 0, "tag `%s' must start with a letter", tag);
}

/*
 * TRUE if argument has valid syntax for an RCS revision or 
 * branch number.  All characters must be digits or dots, first 
 * and last characters must be digits, and no two consecutive 
 * characters may be dots.
 *
 * Intended for classifying things, so this function doesn't 
 * call error.
 */
int 
RCS_valid_rev (rev)
    char *rev;
{
   char last, c;
   last = *rev++;
   if (!isdigit ((unsigned char) last))
       return 0;
   while ((c = *rev++))   /* Extra parens placate -Wall gcc option */
   {
       if (c == '.')
       {
           if (last == '.')
               return 0;
           continue;
       }
       last = c;
       if (!isdigit ((unsigned char) c))
           return 0;
   }
   if (!isdigit ((unsigned char) last))
       return 0;
   return 1;
}

/*
 * Return true if RCS revision with TAG is a dead revision.
 */
int
RCS_isdead (rcs, tag)
    RCSNode *rcs;
    const char *tag;
{
    Node *p;
    RCSVers *version;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    p = findnode (rcs->versions, tag);
    if (p == NULL)
	return (0);

    version = (RCSVers *) p->data;
    return (version->dead);
}

/* Return the RCS keyword expansion mode.  For example "b" for binary.
   Returns a pointer into storage which is allocated and freed along with
   the rest of the RCS information; the caller should not modify this
   storage.  Returns NULL if the RCS file does not specify a keyword
   expansion mode; for all other errors, die with a fatal error.  */
char *
RCS_getexpand (rcs)
    RCSNode *rcs;
{
    /* Since RCS_parsercsfile_i now reads expand, don't need to worry
       about RCS_reparsercsfile.  */
    assert (rcs != NULL);
    return rcs->expand;
}

/* Set keyword expansion mode to EXPAND.  For example "b" for binary.  */
void
RCS_setexpand (rcs, expand)
    RCSNode *rcs;
    char *expand;
{
    /* Since RCS_parsercsfile_i now reads expand, don't need to worry
       about RCS_reparsercsfile.  */
    assert (rcs != NULL);
    if (rcs->expand != NULL)
	free (rcs->expand);
    rcs->expand = xstrdup (expand);
}

/* RCS keywords, and a matching enum.  */
struct rcs_keyword
{
    const char *string;
    size_t len;
};
#define KEYWORD_INIT(s) (s), sizeof (s) - 1
static struct rcs_keyword keywords[] =
{
    { KEYWORD_INIT ("Author") },
    { KEYWORD_INIT ("Date") },
    { KEYWORD_INIT ("Header") },
    { KEYWORD_INIT ("Id") },
    { KEYWORD_INIT ("Locker") },
    { KEYWORD_INIT ("Log") },
    { KEYWORD_INIT ("Name") },
    { KEYWORD_INIT ("RCSfile") },
    { KEYWORD_INIT ("Revision") },
    { KEYWORD_INIT ("Source") },
    { KEYWORD_INIT ("State") },
    { KEYWORD_INIT ("Mdocdate") },
    { NULL, 0 },
    { NULL, 0 }
};
enum keyword
{
    KEYWORD_AUTHOR = 0,
    KEYWORD_DATE,
    KEYWORD_HEADER,
    KEYWORD_ID,
    KEYWORD_LOCKER,
    KEYWORD_LOG,
    KEYWORD_NAME,
    KEYWORD_RCSFILE,
    KEYWORD_REVISION,
    KEYWORD_SOURCE,
    KEYWORD_STATE,
    KEYWORD_MDOCDATE,
    KEYWORD_LOCALID
};

/* Convert an RCS date string into a readable string.  This is like
   the RCS date2str function.  */

static char *
printable_date (rcs_date)
     const char *rcs_date;
{
    int year, mon, mday, hour, min, sec;
    char buf[100];

    (void) sscanf (rcs_date, SDATEFORM, &year, &mon, &mday, &hour, &min,
		   &sec);
    if (year < 1900)
	year += 1900;
    sprintf (buf, "%04d/%02d/%02d %02d:%02d:%02d", year, mon, mday,
	     hour, min, sec);
    return xstrdup (buf);
}

static char *
mdoc_date (rcs_date)
     const char *rcs_date;
{
    int year, mon, mday, hour, min, sec;
    char buf[100];
    char *months[] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
    (void) sscanf (rcs_date, SDATEFORM, &year, &mon, &mday, &hour, &min,
		   &sec);
    if (mon < 1 || mon > 12)
	errx(1, "mdoc_date: month index out of bounds");

    if (year < 1900)
	year += 1900;
    sprintf (buf, "%s %d %04d", months[mon - 1], mday, year);
    return xstrdup (buf);
}

/* Escape the characters in a string so that it can be included in an
   RCS value.  */

static char *
escape_keyword_value (value, free_value)
     const char *value;
     int *free_value;
{
    char *ret, *t;
    const char *s;

    for (s = value; *s != '\0'; s++)
    {
	char c;

	c = *s;
	if (c == '\t'
	    || c == '\n'
	    || c == '\\'
	    || c == ' '
	    || c == '$')
	{
	    break;
	}
    }

    if (*s == '\0')
    {
	*free_value = 0;
	return (char *) value;
    }

    ret = xmalloc (strlen (value) * 4 + 1);
    *free_value = 1;

    for (s = value, t = ret; *s != '\0'; s++, t++)
    {
	switch (*s)
	{
	default:
	    *t = *s;
	    break;
	case '\t':
	    *t++ = '\\';
	    *t = 't';
	    break;
	case '\n':
	    *t++ = '\\';
	    *t = 'n';
	    break;
	case '\\':
	    *t++ = '\\';
	    *t = '\\';
	    break;
	case ' ':
	    *t++ = '\\';
	    *t++ = '0';
	    *t++ = '4';
	    *t = '0';
	    break;
	case '$':
	    *t++ = '\\';
	    *t++ = '0';
	    *t++ = '4';
	    *t = '4';
	    break;
	}
    }

    *t = '\0';

    return ret;
}

/* Expand RCS keywords in the memory buffer BUF of length LEN.  This
   applies to file RCS and version VERS.  If NAME is not NULL, and is
   not a numeric revision, then it is the symbolic tag used for the
   checkout.  EXPAND indicates how to expand the keywords.  This
   function sets *RETBUF and *RETLEN to the new buffer and length.
   This function may modify the buffer BUF.  If BUF != *RETBUF, then
   RETBUF is a newly allocated buffer.  */

static void
expand_keywords (rcs, ver, name, log, loglen, expand, buf, len, retbuf, retlen)
     RCSNode *rcs;
     RCSVers *ver;
     const char *name;
     const char *log;
     size_t loglen;
     enum kflag expand;
     char *buf;
     size_t len;
     char **retbuf;
     size_t *retlen;
{
    struct expand_buffer
    {
	struct expand_buffer *next;
	char *data;
	size_t len;
	int free_data;
    } *ebufs = NULL;
    struct expand_buffer *ebuf_last = NULL;
    size_t ebuf_len = 0;
    char *locker;
    char *srch, *srch_next;
    size_t srch_len;

    if (expand == KFLAG_O || expand == KFLAG_B)
    {
	*retbuf = buf;
	*retlen = len;
	return;
    }

    if (RCS_citag != NULL && *RCS_citag && *RCS_citag != '-'
	&& keywords[KEYWORD_LOCALID].string == NULL) {
	keywords[KEYWORD_LOCALID].string = RCS_citag;
	keywords[KEYWORD_LOCALID].len = strlen(RCS_citag);
    }

    /* If we are using -kkvl, dig out the locker information if any.  */
    locker = NULL;
    if (expand == KFLAG_KVL)
    {
	Node *lock;
	lock = findnode (RCS_getlocks(rcs), ver->version);
	if (lock != NULL)
	    locker = xstrdup (lock->data);
    }

    /* RCS keywords look like $STRING$ or $STRING: VALUE$.  */
    srch = buf;
    srch_len = len;
    while ((srch_next = memchr (srch, '$', srch_len)) != NULL)
    {
	char *s, *send;
	size_t slen;
	const struct rcs_keyword *keyword;
	enum keyword kw;
	char *value;
	int free_value;
	char *sub;
	size_t sublen;

	srch_len -= (srch_next + 1) - srch;
	srch = srch_next + 1;

	/* Look for the first non alphanumeric character after the '$'.  */
	send = srch + srch_len;
	if (! isalpha((unsigned char) *srch))
	    continue;	/* first character of a tag must be a letter */
	for (s = srch+1; s < send; s++)
	    if (! isalnum ((unsigned char) *s))
		break;

	/* If the first non alphanumeric character is not '$' or ':',
           then this is not an RCS keyword.  */
	if (s == send || (*s != '$' && *s != ':'))
	    continue;

	/* See if this is one of the keywords.  */
	slen = s - srch;
	for (keyword = keywords; keyword->string != NULL; keyword++)
	{
	    if (keyword->len == slen
		&& strncmp (keyword->string, srch, slen) == 0)
	    {
		break;
	    }
	}
	if (keyword->string == NULL)
	    continue;

	kw = (enum keyword) (keyword - keywords);

	/* If the keyword ends with a ':', then the old value consists
           of the characters up to the next '$'.  If there is no '$'
           before the end of the line, though, then this wasn't an RCS
           keyword after all.  */
	if (*s == ':')
	{
	    for (; s < send; s++)
		if (*s == '$' || *s == '\n')
		    break;
	    if (s == send || *s != '$')
		continue;
	}

	/* At this point we must replace the string from SRCH to S
           with the expansion of the keyword KW.  */

	/* Get the value to use.  */
	free_value = 0;
	if (expand == KFLAG_K)
	    value = NULL;
	else
	{
	    switch (kw)
	    {
	    default:
		abort ();

	    case KEYWORD_AUTHOR:
		value = ver->author;
		break;

	    case KEYWORD_DATE:
		value = printable_date (ver->date);
		free_value = 1;
		break;

	    case KEYWORD_MDOCDATE:
		if (disable_mdocdate)
			continue;
		value = mdoc_date (ver->date);
		free_value = 1;
		break;

	    case KEYWORD_HEADER:
	    case KEYWORD_ID:
	    case KEYWORD_LOCALID:
		{
		    char *path;
		    int free_path;
		    char *date;

		    if (kw == KEYWORD_HEADER)
			path = rcs->path;
		    else
			path = last_component (rcs->path);
		    path = escape_keyword_value (path, &free_path);
		    date = printable_date (ver->date);
		    value = xmalloc (strlen (path)
				     + strlen (ver->version)
				     + strlen (date)
				     + strlen (ver->author)
				     + strlen (ver->state)
				     + (locker == NULL ? 0 : strlen (locker))
				     + 20);

		    sprintf (value, "%s %s %s %s %s%s%s",
			     path, ver->version, date, ver->author,
			     ver->state,
			     locker != NULL ? " " : "",
			     locker != NULL ? locker : "");
		    if (free_path)
			free (path);
		    free (date);
		    free_value = 1;
		}
		break;

	    case KEYWORD_LOCKER:
		value = locker;
		break;

	    case KEYWORD_LOG:
	    case KEYWORD_RCSFILE:
		value = escape_keyword_value (last_component (rcs->path),
					      &free_value);
		break;

	    case KEYWORD_NAME:
		if (name != NULL && ! isdigit ((unsigned char) *name))
		    value = (char *) name;
		else
		    value = NULL;
		break;

	    case KEYWORD_REVISION:
		value = ver->version;
		break;

	    case KEYWORD_SOURCE:
		value = escape_keyword_value (rcs->path, &free_value);
		break;

	    case KEYWORD_STATE:
		value = ver->state;
		break;
	    }
	}

	sub = xmalloc (keyword->len
		       + (value == NULL ? 0 : strlen (value))
		       + 10);
	if (expand == KFLAG_V)
	{
	    /* Decrement SRCH and increment S to remove the $
               characters.  */
	    --srch;
	    ++srch_len;
	    ++s;
	    sublen = 0;
	}
	else
	{
	    strcpy (sub, keyword->string);
	    sublen = strlen (keyword->string);
	    if (expand != KFLAG_K)
	    {
		sub[sublen] = ':';
		sub[sublen + 1] = ' ';
		sublen += 2;
	    }
	}
	if (value != NULL)
	{
	    strcpy (sub + sublen, value);
	    sublen += strlen (value);
	}
	if (expand != KFLAG_V && expand != KFLAG_K)
	{
	    sub[sublen] = ' ';
	    ++sublen;
	    sub[sublen] = '\0';
	}

	if (free_value)
	    free (value);

	/* The Log keyword requires special handling.  This behaviour
           is taken from RCS 5.7.  The special log message is what RCS
           uses for ci -k.  */
	if (kw == KEYWORD_LOG
	    && (sizeof "checked in with -k by " <= loglen
		|| log == NULL
		|| strncmp (log, "checked in with -k by ",
			    sizeof "checked in with -k by " - 1) != 0))
	{
	    char *start;
	    char *leader;
	    size_t leader_len, leader_sp_len;
	    const char *logend;
	    const char *snl;
	    int cnl;
	    char *date;
	    const char *sl;

	    /* We are going to insert the trailing $ ourselves, before
               the log message, so we must remove it from S, if we
               haven't done so already.  */
	    if (expand != KFLAG_V)
		++s;

	    /* CVS never has empty log messages, but old RCS files might.  */
	    if (log == NULL)
		log = "";

	    /* Find the start of the line.  */
	    start = srch;
	    while (start > buf && start[-1] != '\n')
		--start;

	    /* Copy the start of the line to use as a comment leader.  */
	    leader_len = srch - start;
	    if (expand != KFLAG_V)
		--leader_len;
	    leader = xmalloc (leader_len);
	    memcpy (leader, start, leader_len);
	    leader_sp_len = leader_len;
	    while (leader_sp_len > 0 && leader[leader_sp_len - 1] == ' ')
		--leader_sp_len;

	    /* RCS does some checking for an old style of Log here,
	       but we don't bother.  RCS issues a warning if it
	       changes anything.  */

	    /* Count the number of newlines in the log message so that
	       we know how many copies of the leader we will need.  */
	    cnl = 0;
	    logend = log + loglen;
	    for (snl = log; snl < logend; snl++)
		if (*snl == '\n')
		    ++cnl;

	    date = printable_date (ver->date);
	    sub = xrealloc (sub,
			    (sublen
			     + sizeof "Revision"
			     + strlen (ver->version)
			     + strlen (date)
			     + strlen (ver->author)
			     + loglen
			     + (cnl + 2) * leader_len
			     + 20));
	    if (expand != KFLAG_V)
	    {
		sub[sublen] = '$';
		++sublen;
	    }
	    sub[sublen] = '\n';
	    ++sublen;
	    memcpy (sub + sublen, leader, leader_len);
	    sublen += leader_len;
	    sprintf (sub + sublen, "Revision %s  %s  %s\n",
		     ver->version, date, ver->author);
	    sublen += strlen (sub + sublen);
	    free (date);

	    sl = log;
	    while (sl < logend)
	    {
		if (*sl == '\n')
		{
		    memcpy (sub + sublen, leader, leader_sp_len);
		    sublen += leader_sp_len;
		    sub[sublen] = '\n';
		    ++sublen;
		    ++sl;
		}
		else
		{
		    const char *slnl;

		    memcpy (sub + sublen, leader, leader_len);
		    sublen += leader_len;
		    for (slnl = sl; slnl < logend && *slnl != '\n'; ++slnl)
			;
		    if (slnl < logend)
			++slnl;
		    memcpy (sub + sublen, sl, slnl - sl);
		    sublen += slnl - sl;
		    sl = slnl;
		}
	    }

	    memcpy (sub + sublen, leader, leader_sp_len);
	    sublen += leader_sp_len;

	    free (leader);
	}

	/* Now SUB contains a string which is to replace the string
	   from SRCH to S.  SUBLEN is the length of SUB.  */

	if (srch + sublen == s)
	{
	    memcpy (srch, sub, sublen);
	    free (sub);
	}
	else
	{
	    struct expand_buffer *ebuf;

	    /* We need to change the size of the buffer.  We build a
               list of expand_buffer structures.  Each expand_buffer
               structure represents a portion of the final output.  We
               concatenate them back into a single buffer when we are
               done.  This minimizes the number of potentially large
               buffer copies we must do.  */

	    if (ebufs == NULL)
	    {
		ebufs = (struct expand_buffer *) xmalloc (sizeof *ebuf);
		ebufs->next = NULL;
		ebufs->data = buf;
		ebufs->free_data = 0;
		ebuf_len = srch - buf;
		ebufs->len = ebuf_len;
		ebuf_last = ebufs;
	    }
	    else
	    {
		assert (srch >= ebuf_last->data);
		assert (srch <= ebuf_last->data + ebuf_last->len);
		ebuf_len -= ebuf_last->len - (srch - ebuf_last->data);
		ebuf_last->len = srch - ebuf_last->data;
	    }

	    ebuf = (struct expand_buffer *) xmalloc (sizeof *ebuf);
	    ebuf->data = sub;
	    ebuf->len = sublen;
	    ebuf->free_data = 1;
	    ebuf->next = NULL;
	    ebuf_last->next = ebuf;
	    ebuf_last = ebuf;
	    ebuf_len += sublen;

	    ebuf = (struct expand_buffer *) xmalloc (sizeof *ebuf);
	    ebuf->data = s;
	    ebuf->len = srch_len - (s - srch);
	    ebuf->free_data = 0;
	    ebuf->next = NULL;
	    ebuf_last->next = ebuf;
	    ebuf_last = ebuf;
	    ebuf_len += srch_len - (s - srch);
	}

	srch_len -= (s - srch);
	srch = s;
    }

    if (locker != NULL)
	free (locker);

    if (ebufs == NULL)
    {
	*retbuf = buf;
	*retlen = len;
    }
    else
    {
	char *ret;

	ret = xmalloc (ebuf_len);
	*retbuf = ret;
	*retlen = ebuf_len;
	while (ebufs != NULL)
	{
	    struct expand_buffer *next;

	    memcpy (ret, ebufs->data, ebufs->len);
	    ret += ebufs->len;
	    if (ebufs->free_data)
		free (ebufs->data);
	    next = ebufs->next;
	    free (ebufs);
	    ebufs = next;
	}
    }
}

/* Check out a revision from an RCS file.

   If PFN is not NULL, then ignore WORKFILE and SOUT.  Call PFN zero
   or more times with the contents of the file.  CALLERDAT is passed,
   uninterpreted, to PFN.  (The current code will always call PFN
   exactly once for a non empty file; however, the current code
   assumes that it can hold the entire file contents in memory, which
   is not a good assumption, and might change in the future).

   Otherwise, if WORKFILE is not NULL, check out the revision to
   WORKFILE.  However, if WORKFILE is not NULL, and noexec is set,
   then don't do anything.

   Otherwise, if WORKFILE is NULL, check out the revision to SOUT.  If
   SOUT is RUN_TTY, then write the contents of the revision to
   standard output.  When using SOUT, the output is generally a
   temporary file; don't bother to get the file modes correct.

   REV is the numeric revision to check out.  It may be NULL, which
   means to check out the head of the default branch.

   If NAMETAG is not NULL, and is not a numeric revision, then it is
   the tag that should be used when expanding the RCS Name keyword.

   OPTIONS is a string such as "-kb" or "-kv" for keyword expansion
   options.  It may be NULL to use the default expansion mode of the
   file, typically "-kkv".

   On an error which prevented checking out the file, either print a
   nonfatal error and return 1, or give a fatal error.  On success,
   return 0.  */

/* This function mimics the behavior of `rcs co' almost exactly.  The
   chief difference is in its support for preserving file ownership,
   permissions, and special files across checkin and checkout -- see
   comments in RCS_checkin for some issues about this. -twp */

int
RCS_checkout (rcs, workfile, rev, nametag, options, sout, pfn, callerdat)
     RCSNode *rcs;
     char *workfile;
     char *rev;
     char *nametag;
     char *options;
     char *sout;
     RCSCHECKOUTPROC pfn;
     void *callerdat;
{
    int free_rev = 0;
    enum kflag expand;
    FILE *fp, *ofp;
    struct stat sb;
    struct rcsbuffer rcsbuf;
    char *key;
    char *value;
    size_t len;
    int free_value = 0;
    char *log = NULL;
    size_t loglen = 0;
    Node *vp = NULL;
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    uid_t rcs_owner = (uid_t) -1;
    gid_t rcs_group = (gid_t) -1;
    mode_t rcs_mode;
    int change_rcs_owner_or_group = 0;
    int change_rcs_mode = 0;
    int special_file = 0;
    unsigned long devnum_long;
    dev_t devnum = 0;
#endif

    if (trace)
    {
	(void) fprintf (stderr, "%s-> checkout (%s, %s, %s, %s)\n",
#ifdef SERVER_SUPPORT
			server_active ? "S" : " ",
#else
			"",
#endif
			rcs->path,
			rev != NULL ? rev : "",
			options != NULL ? options : "",
			(pfn != NULL ? "(function)"
			 : (workfile != NULL
			    ? workfile
			    : (sout != RUN_TTY ? sout : "(stdout)"))));
    }

    assert (rev == NULL || isdigit ((unsigned char) *rev));

    if (noexec && workfile != NULL)
	return 0;

    assert (sout == RUN_TTY || workfile == NULL);
    assert (pfn == NULL || (sout == RUN_TTY && workfile == NULL));

    /* Some callers, such as Checkin or remove_file, will pass us a
       branch.  */
    if (rev != NULL && (numdots (rev) & 1) == 0)
    {
	rev = RCS_getbranch (rcs, rev, 1);
	if (rev == NULL)
	    error (1, 0, "internal error: bad branch tag in checkout");
	free_rev = 1;
    }

    if (rev == NULL || STREQ (rev, rcs->head))
    {
	int gothead;

	/* We want the head revision.  Try to read it directly.  */

	if (rcs->flags & PARTIAL)
	    RCS_reparsercsfile (rcs, &fp, &rcsbuf);
	else
	    rcsbuf_cache_open (rcs, rcs->delta_pos, &fp, &rcsbuf);

	gothead = 0;
	if (! rcsbuf_getrevnum (&rcsbuf, &key))
	    error (1, 0, "unexpected EOF reading %s", rcs->path);
	while (rcsbuf_getkey (&rcsbuf, &key, &value))
	{
	    if (STREQ (key, "log"))
		log = rcsbuf_valcopy (&rcsbuf, value, 0, &loglen);
	    else if (STREQ (key, "text"))
	    {
		gothead = 1;
		break;
	    }
	}

	if (! gothead)
	{
	    error (0, 0, "internal error: cannot find head text");
	    if (free_rev)
		free (rev);
	    return 1;
	}

	rcsbuf_valpolish (&rcsbuf, value, 0, &len);

	if (fstat (fileno (fp), &sb) < 0)
	    error (1, errno, "cannot fstat %s", rcs->path);

	rcsbuf_cache (rcs, &rcsbuf);
    }
    else
    {
	struct rcsbuffer *rcsbufp;

	/* It isn't the head revision of the trunk.  We'll need to
	   walk through the deltas.  */

	fp = NULL;
	if (rcs->flags & PARTIAL)
	    RCS_reparsercsfile (rcs, &fp, &rcsbuf);

	if (fp == NULL)
	{
	    /* If RCS_deltas didn't close the file, we could use fstat
	       here too.  Probably should change it thusly....  */
	    if (stat (rcs->path, &sb) < 0)
		error (1, errno, "cannot stat %s", rcs->path);
	    rcsbufp = NULL;
	}
	else
	{
	    if (fstat (fileno (fp), &sb) < 0)
		error (1, errno, "cannot fstat %s", rcs->path);
	    rcsbufp = &rcsbuf;
	}

	RCS_deltas (rcs, fp, rcsbufp, rev, RCS_FETCH, &value, &len,
		    &log, &loglen);
	free_value = 1;
    }

    /* If OPTIONS is NULL or the empty string, then the old code would
       invoke the RCS co program with no -k option, which means that
       co would use the string we have stored in rcs->expand.  */
    if ((options == NULL || options[0] == '\0') && rcs->expand == NULL)
	expand = KFLAG_KV;
    else
    {
	const char *ouroptions;
	const char * const *cpp;

	if (options != NULL && options[0] != '\0')
	{
	    assert (options[0] == '-' && options[1] == 'k');
	    ouroptions = options + 2;
	}
	else
	    ouroptions = rcs->expand;

	for (cpp = kflags; *cpp != NULL; cpp++)
	    if (STREQ (*cpp, ouroptions))
		break;

	if (*cpp != NULL)
	    expand = (enum kflag) (cpp - kflags);
	else
	{
	    error (0, 0,
		   "internal error: unsupported substitution string -k%s",
		   ouroptions);
	    expand = KFLAG_KV;
	}
    }

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Handle special files and permissions, if that is desired. */
    if (preserve_perms)
    {
	RCSVers *vers;
	Node *info;

	vp = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	if (vp == NULL)
	    error (1, 0, "internal error: no revision information for %s",
		   rev == NULL ? rcs->head : rev);
	vers = (RCSVers *) vp->data;

	/* First we look for symlinks, which are simplest to handle. */
	info = findnode (vers->other_delta, "symlink");
	if (info != NULL)
	{
	    char *dest;

	    if (pfn != NULL || (workfile == NULL && sout == RUN_TTY))
		error (1, 0, "symbolic link %s:%s cannot be piped",
		       rcs->path, vers->version);
	    if (workfile == NULL)
		dest = sout;
	    else
		dest = workfile;

	    /* Remove `dest', just in case.  It's okay to get ENOENT here,
	       since we just want the file not to be there.  (TODO: decide
	       whether it should be considered an error for `dest' to exist
	       at this point.  If so, the unlink call should be removed and
	       `symlink' should signal the error. -twp) */
	    if (CVS_UNLINK (dest) < 0 && !existence_error (errno))
		error (1, errno, "cannot remove %s", dest);
	    if (symlink (info->data, dest) < 0)
		error (1, errno, "cannot create symbolic link from %s to %s",
		       dest, info->data);
	    if (free_value)
		free (value);
	    if (free_rev)
		free (rev);
	    return 0;
	}

	/* Next, we look at this file's hardlinks field, and see whether
	   it is linked to any other file that has been checked out.
	   If so, we don't do anything else -- just link it to that file.

	   If we are checking out a file to a pipe or temporary storage,
	   none of this should matter.  Hence the `workfile != NULL'
	   wrapper around the whole thing. -twp */

	if (workfile != NULL)
	{
	    List *links = vers->hardlinks;
	    if (links != NULL)
	    {
		Node *uptodate_link;

		/* For each file in the hardlinks field, check to see
		   if it exists, and if so, if it has been checked out
		   this iteration.  When walklist returns, uptodate_link
		   should point to a hardlist node representing a file
		   in `links' which has recently been checked out, or
		   NULL if no file in `links' has yet been checked out. */

		uptodate_link = NULL;
		(void) walklist (links, find_checkedout_proc, &uptodate_link);
		dellist (&links);

		/* If we've found a file that `workfile' is supposed to be
		   linked to, and it has been checked out since CVS was
		   invoked, then simply link workfile to that file and return.

		   If one of these conditions is not met, then
		   workfile is the first one in its hardlink group to
		   be checked out, and we must continue with a full
		   checkout. */

		if (uptodate_link != NULL)
		{
		    struct hardlink_info *hlinfo =
			(struct hardlink_info *) uptodate_link->data;

		    if (link (uptodate_link->key, workfile) < 0)
			error (1, errno, "cannot link %s to %s",
			       workfile, uptodate_link->key);
		    hlinfo->checked_out = 1;	/* probably unnecessary */
		    if (free_value)
			free (value);
		    if (free_rev)
			free (rev);
		    return 0;
		}
	    }
	}

	info = findnode (vers->other_delta, "owner");
	if (info != NULL)
	{
	    change_rcs_owner_or_group = 1;
	    rcs_owner = (uid_t) strtoul (info->data, NULL, 10);
	}
	info = findnode (vers->other_delta, "group");
	if (info != NULL)
	{
	    change_rcs_owner_or_group = 1;
	    rcs_group = (gid_t) strtoul (info->data, NULL, 10);
	}
	info = findnode (vers->other_delta, "permissions");
	if (info != NULL)
	{
	    change_rcs_mode = 1;
	    rcs_mode = (mode_t) strtoul (info->data, NULL, 8);
	}
	info = findnode (vers->other_delta, "special");
	if (info != NULL)
	{
	    /* If the size of `devtype' changes, fix the sscanf call also */
	    char devtype[16+1];

	    if (sscanf (info->data, "%16s %lu",
			devtype, &devnum_long) < 2)
		error (1, 0, "%s:%s has bad `special' newphrase %s",
		       workfile, vers->version, info->data);
	    devnum = devnum_long;
	    if (STREQ (devtype, "character"))
		special_file = S_IFCHR;
	    else if (STREQ (devtype, "block"))
		special_file = S_IFBLK;
	    else
		error (0, 0, "%s is a special file of unsupported type `%s'",
		       workfile, info->data);
	}
    }
#endif

    if (expand != KFLAG_O && expand != KFLAG_B)
    {
	char *newvalue;

	/* Don't fetch the delta node again if we already have it. */
	if (vp == NULL)
	{
	    vp = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	    if (vp == NULL)
		error (1, 0, "internal error: no revision information for %s",
		       rev == NULL ? rcs->head : rev);
	}

	expand_keywords (rcs, (RCSVers *) vp->data, nametag, log, loglen,
			 expand, value, len, &newvalue, &len);

	if (newvalue != value)
	{
	    if (free_value)
		free (value);
	    value = newvalue;
	    free_value = 1;
	}
    }

    if (free_rev)
	free (rev);

    if (log != NULL)
    {
	free (log);
	log = NULL;
    }

    if (pfn != NULL)
    {
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (special_file)
	    error (1, 0, "special file %s cannot be piped to anything",
		   rcs->path);
#endif
	/* The PFN interface is very simple to implement right now, as
           we always have the entire file in memory.  */
	if (len != 0)
	    pfn (callerdat, value, len);
    }
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    else if (special_file)
    {
#ifdef HAVE_MKNOD
	char *dest;

	/* Can send either to WORKFILE or to SOUT, as long as SOUT is
	   not RUN_TTY. */
	dest = workfile;
	if (dest == NULL)
	{
	    if (sout == RUN_TTY)
		error (1, 0, "special file %s cannot be written to stdout",
		       rcs->path);
	    dest = sout;
	}

	/* Unlink `dest', just in case.  It's okay if this provokes a
	   ENOENT error. */
	if (CVS_UNLINK (dest) < 0 && existence_error (errno))
	    error (1, errno, "cannot remove %s", dest);
	if (mknod (dest, special_file, devnum) < 0)
	    error (1, errno, "could not create special file %s",
		   dest);
#else
	error (1, 0,
"cannot create %s: unable to create special files on this system",
workfile);
#endif
    }
#endif
    else
    {
	/* Not a special file: write to WORKFILE or SOUT. */
	if (workfile == NULL)
	{
	    if (sout == RUN_TTY)
		ofp = stdout;
	    else
	    {
		/* Symbolic links should be removed before replacement, so that
		   `fopen' doesn't follow the link and open the wrong file. */
		if (islink (sout))
		    if (unlink_file (sout) < 0)
			error (1, errno, "cannot remove %s", sout);
		ofp = CVS_FOPEN (sout, expand == KFLAG_B ? "wb" : "w");
		if (ofp == NULL)
		    error (1, errno, "cannot open %s", sout);
	    }
	}
	else
	{
	    /* Output is supposed to go to WORKFILE, so we should open that
	       file.  Symbolic links should be removed first (see above). */
	    if (islink (workfile))
		if (unlink_file (workfile) < 0)
		    error (1, errno, "cannot remove %s", workfile);

	    ofp = CVS_FOPEN (workfile, expand == KFLAG_B ? "wb" : "w");

	    /* If the open failed because the existing workfile was not
	       writable, try to chmod the file and retry the open.  */
	    if (ofp == NULL && errno == EACCES
		&& isfile (workfile) && !iswritable (workfile))
	    {
		xchmod (workfile, 1);
		ofp = CVS_FOPEN (workfile, expand == KFLAG_B ? "wb" : "w");
	    }

	    if (ofp == NULL)
	    {
		error (0, errno, "cannot open %s", workfile);
		if (free_value)
		    free (value);
		return 1;
	    }
	}

	if (workfile == NULL && sout == RUN_TTY)
	{
	    if (expand == KFLAG_B)
		cvs_output_binary (value, len);
	    else
	    {
		/* cvs_output requires the caller to check for zero
		   length.  */
		if (len > 0)
		    cvs_output (value, len);
	    }
	}
	else
	{
	    /* NT 4.0 is said to have trouble writing 2099999 bytes
	       (for example) in a single fwrite.  So break it down
	       (there is no need to be writing that much at once
	       anyway; it is possible that LARGEST_FWRITE should be
	       somewhat larger for good performance, but for testing I
	       want to start with a small value until/unless a bigger
	       one proves useful).  */
#define LARGEST_FWRITE 8192
	    size_t nleft = len;
	    size_t nstep = (len < LARGEST_FWRITE ? len : LARGEST_FWRITE);
	    char *p = value;

	    while (nleft > 0)
	    {
		if (fwrite (p, 1, nstep, ofp) != nstep)
		{
		    error (0, errno, "cannot write %s",
			   (workfile != NULL
			    ? workfile
			    : (sout != RUN_TTY ? sout : "stdout")));
		    if (free_value)
			free (value);
		    return 1;
		}
		p += nstep;
		nleft -= nstep;
		if (nleft < nstep)
		    nstep = nleft;
	    }
	}
    }

    if (free_value)
	free (value);

    if (workfile != NULL)
    {
	int ret;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (!special_file && fclose (ofp) < 0)
	{
	    error (0, errno, "cannot close %s", workfile);
	    return 1;
	}

	if (change_rcs_owner_or_group)
	{
	    if (chown (workfile, rcs_owner, rcs_group) < 0)
		error (0, errno, "could not change owner or group of %s",
		       workfile);
	}

	ret = chmod (workfile,
		     change_rcs_mode
		     ? rcs_mode
		     : sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH));
#else
	if (fclose (ofp) < 0)
	{
	    error (0, errno, "cannot close %s", workfile);
	    return 1;
	}

	ret = chmod (workfile,
		     sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH));
#endif
	if (ret < 0)
	{
	    error (0, errno, "cannot change mode of file %s",
		   workfile);
	}
    }
    else if (sout != RUN_TTY)
    {
	if (
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    !special_file &&
#endif
	    fclose (ofp) < 0)
	{
	    error (0, errno, "cannot close %s", sout);
	    return 1;
	}
    }

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If we are in the business of preserving hardlinks, then
       mark this file as having been checked out. */
    if (preserve_perms && workfile != NULL)
	update_hardlink_info (workfile);
#endif

    return 0;
}

static RCSVers *RCS_findlock_or_tip PROTO ((RCSNode *rcs));

/* Find the delta currently locked by the user.  From the `ci' man page:

	"If rev is omitted, ci tries to  derive  the  new  revision
	 number  from  the  caller's  last lock.  If the caller has
	 locked the tip revision of a branch, the new  revision  is
	 appended  to  that  branch.   The  new  revision number is
	 obtained by incrementing the tip revision number.  If  the
	 caller  locked a non-tip revision, a new branch is started
	 at that revision by incrementing the highest branch number
	 at  that  revision.   The default initial branch and level
	 numbers are 1.

	 If rev is omitted and the caller has no lock, but owns the
	 file  and  locking is not set to strict, then the revision
	 is appended to the default branch (normally the trunk; see
	 the -b option of rcs(1))."

   RCS_findlock_or_tip finds the unique revision locked by the caller
   and returns its delta node.  If the caller has not locked any
   revisions (and is permitted to commit to an unlocked delta, as
   described above), return the tip of the default branch. */

static RCSVers *
RCS_findlock_or_tip (rcs)
    RCSNode *rcs;
{
    char *user = getcaller();
    Node *lock, *p;
    List *locklist;

    /* Find unique delta locked by caller. This code is very similar
       to the code in RCS_unlock -- perhaps it could be abstracted
       into a RCS_findlock function. */
    locklist = RCS_getlocks (rcs);
    lock = NULL;
    for (p = locklist->list->next; p != locklist->list; p = p->next)
    {
	if (STREQ (p->data, user))
	{
	    if (lock != NULL)
	    {
		error (0, 0, "\
%s: multiple revisions locked by %s; please specify one", rcs->path, user);
		return NULL;
	    }
	    lock = p;
	}
    }

    if (lock != NULL)
    {
	/* Found an old lock, but check that the revision still exists. */
	p = findnode (rcs->versions, lock->key);
	if (p == NULL)
	{
	    error (0, 0, "%s: can't unlock nonexistent revision %s",
		   rcs->path,
		   lock->key);
	    return NULL;
	}
	return (RCSVers *) p->data;
    }

    /* No existing lock.  The RCS rule is that this is an error unless
       locking is nonstrict AND the file is owned by the current
       user.  Trying to determine the latter is a portability nightmare
       in the face of NT, VMS, AFS, and other systems with non-unix-like
       ideas of users and owners.  In the case of CVS, we should never get
       here (as long as the traditional behavior of making sure to call
       RCS_lock persists).  Anyway, we skip the RCS error checks
       and just return the default branch or head.  The reasoning is that
       those error checks are to make users lock before a checkin, and we do
       that in other ways if at all anyway (e.g. rcslock.pl).  */

    p = findnode (rcs->versions, RCS_getbranch (rcs, rcs->branch, 0));
    return (RCSVers *) p->data;
}

/* Revision number string, R, must contain a `.'.
   Return a newly-malloc'd copy of the prefix of R up
   to but not including the final `.'.  */

static char *
truncate_revnum (r)
    const char *r;
{
    size_t len;
    char *new_r;
    char *dot = strrchr (r, '.');

    assert (dot);
    len = dot - r;
    new_r = xmalloc (len + 1);
    memcpy (new_r, r, len);
    *(new_r + len) = '\0';
    return new_r;
}

/* Revision number string, R, must contain a `.'.
   R must be writable.  Replace the rightmost `.' in R with
   the NUL byte and return a pointer to that NUL byte.  */

static char *
truncate_revnum_in_place (r)
    char *r;
{
    char *dot = strrchr (r, '.');
    assert (dot);
    *dot = '\0';
    return dot;
}

/* Revision number strings, R and S, must each contain a `.'.
   R and S must be writable and must have the same number of dots.
   Truncate R and S for the comparison, then restored them to their
   original state.
   Return the result (see compare_revnums) of comparing R and S
   ignoring differences in any component after the rightmost `.'.  */

static int
compare_truncated_revnums (r, s)
    char *r;
    char *s;
{
    char *r_dot = truncate_revnum_in_place (r);
    char *s_dot = truncate_revnum_in_place (s);
    int cmp;

    assert (numdots (r) == numdots (s));

    cmp = compare_revnums (r, s);

    *r_dot = '.';
    *s_dot = '.';

    return cmp;
}

/* Return a malloc'd copy of the string representing the highest branch
   number on BRANCHNODE.  If there are no branches on BRANCHNODE, return NULL.
   FIXME: isn't the max rev always the last one?
   If so, we don't even need a loop.  */

static char *max_rev PROTO ((const RCSVers *));

static char *
max_rev (branchnode)
    const RCSVers *branchnode;
{
    Node *head;
    Node *bp;
    char *max;

    if (branchnode->branches == NULL)
    {
        return NULL;
    }

    max = NULL;
    head = branchnode->branches->list;
    for (bp = head->next; bp != head; bp = bp->next)
    {
	if (max == NULL || compare_truncated_revnums (max, bp->key) < 0)
	{
	    max = bp->key;
	}
    }
    assert (max);

    return truncate_revnum (max);
}

/* Create BRANCH in RCS's delta tree.  BRANCH may be either a branch
   number or a revision number.  In the former case, create the branch
   with the specified number; in the latter case, create a new branch
   rooted at node BRANCH with a higher branch number than any others.
   Return the number of the tip node on the new branch. */

static char *
RCS_addbranch (rcs, branch)
    RCSNode *rcs;
    const char *branch;
{
    char *branchpoint, *newrevnum;
    Node *nodep, *bp;
    Node *marker;
    RCSVers *branchnode;

    /* Append to end by default.  */
    marker = NULL;

    branchpoint = xstrdup (branch);
    if ((numdots (branchpoint) & 1) == 0)
    {
	truncate_revnum_in_place (branchpoint);
    }

    /* Find the branch rooted at BRANCHPOINT. */
    nodep = findnode (rcs->versions, branchpoint);
    if (nodep == NULL)
    {
	error (0, 0, "%s: can't find branch point %s", rcs->path, branchpoint);
	free (branchpoint);
	return NULL;
    }
    free (branchpoint);
    branchnode = (RCSVers *) nodep->data;

    /* If BRANCH was a full branch number, make sure it is higher than MAX. */
    if ((numdots (branch) & 1) == 1)
    {
	if (branchnode->branches == NULL)
	{
	    /* We have to create the first branch on this node, which means
	       appending ".2" to the revision number. */
	    newrevnum = (char *) xmalloc (strlen (branch) + 3);
	    strcpy (newrevnum, branch);
	    strcat (newrevnum, ".2");
	}
	else
	{
	    char *max = max_rev (branchnode);
	    assert (max);
	    newrevnum = increment_revnum (max);
	    free (max);
	}
    }
    else
    {
	newrevnum = xstrdup (branch);

	if (branchnode->branches != NULL)
	{
	    Node *head;
	    Node *bp;

	    /* Find the position of this new branch in the sorted list
	       of branches.  */
	    head = branchnode->branches->list;
	    for (bp = head->next; bp != head; bp = bp->next)
	    {
		char *dot;
		int found_pos;

		/* The existing list must be sorted on increasing revnum.  */
		assert (bp->next == head
			|| compare_truncated_revnums (bp->key,
						      bp->next->key) < 0);
		dot = truncate_revnum_in_place (bp->key);
		found_pos = (compare_revnums (branch, bp->key) < 0);
		*dot = '.';

		if (found_pos)
		{
		    break;
		}
	    }
	    marker = bp;
	}
    }

    newrevnum = (char *) xrealloc (newrevnum, strlen (newrevnum) + 3);
    strcat (newrevnum, ".1");

    /* Add this new revision number to BRANCHPOINT's branches list. */
    if (branchnode->branches == NULL)
	branchnode->branches = getlist();
    bp = getnode();
    bp->key = xstrdup (newrevnum);

    /* Append to the end of the list by default, that is, just before
       the header node, `list'.  */
    if (marker == NULL)
	marker = branchnode->branches->list;

    {
	int fail;
	fail = insert_before (branchnode->branches, marker, bp);
	assert (!fail);
    }

    return newrevnum;
}

/* Check in to RCSFILE with revision REV (which must be greater than
   the largest revision) and message MESSAGE (which is checked for
   legality).  If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.
   If FLAGS & RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS &
   RCS_FLAGS_MODTIME, use the working file's modification time for the
   checkin time.  WORKFILE is the working file to check in from, or
   NULL to use the usual RCS rules for deriving it from the RCSFILE.
   If FLAGS & RCS_FLAGS_KEEPFILE, don't unlink the working file;
   unlinking the working file is standard RCS behavior, but is rarely
   appropriate for CVS.

   This function should almost exactly mimic the behavior of `rcs ci'.  The
   principal point of difference is the support here for preserving file
   ownership and permissions in the delta nodes.  This is not a clean
   solution -- precisely because it diverges from RCS's behavior -- but
   it doesn't seem feasible to do this anywhere else in the code. [-twp]
   
   Return value is -1 for error (and errno is set to indicate the
   error), positive for error (and an error message has been printed),
   or zero for success.  */

int
RCS_checkin (rcs, workfile, message, rev, flags)
    RCSNode *rcs;
    char *workfile;
    char *message;
    char *rev;
    int flags;
{
    RCSVers *delta, *commitpt;
    Deltatext *dtext;
    Node *nodep;
    char *tmpfile, *changefile, *chtext;
    char *diffopts;
    size_t bufsize;
    int buflen, chtextlen;
    int status, checkin_quiet, allocated_workfile;
    struct tm *ftm;
    time_t modtime;
    int adding_branch = 0;
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    struct stat sb;
#endif
    Node *np;

    commitpt = NULL;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* Get basename of working file.  Is there a library function to
       do this?  I couldn't find one. -twp */
    allocated_workfile = 0;
    if (workfile == NULL)
    {
	char *p;
	int extlen = strlen (RCSEXT);
	workfile = xstrdup (last_component (rcs->path));
	p = workfile + (strlen (workfile) - extlen);
	assert (strncmp (p, RCSEXT, extlen) == 0);
	*p = '\0';
	allocated_workfile = 1;
    }

    /* If the filename is a symbolic link, follow it and replace it
       with the destination of the link.  We need to do this before
       calling rcs_internal_lockfile, or else we won't put the lock in
       the right place. */
    resolve_symlink (&(rcs->path));

    checkin_quiet = flags & RCS_FLAGS_QUIET;
    if (!checkin_quiet)
    {
	cvs_output (rcs->path, 0);
	cvs_output ("  <--  ", 7);
	cvs_output (workfile, 0);
	cvs_output ("\n", 1);
    }

    /* Create new delta node. */
    delta = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (delta, 0, sizeof (RCSVers));
    delta->author = xstrdup (getcaller ());
    if (flags & RCS_FLAGS_MODTIME)
    {
	struct stat ws;
	if (stat (workfile, &ws) < 0)
	{
	    error (1, errno, "cannot stat %s", workfile);
	}
	modtime = ws.st_mtime;
    }
    else
	(void) time (&modtime);
    ftm = gmtime (&modtime);
    delta->date = (char *) xmalloc (MAXDATELEN);
    (void) sprintf (delta->date, DATEFORM,
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
    if (flags & RCS_FLAGS_DEAD)
    {
	delta->state = xstrdup (RCSDEAD);
	delta->dead = 1;
    }
    else
	delta->state = xstrdup ("Exp");

    delta->other_delta = getlist();

    /* save the commit ID */
    np = getnode();
    np->type = RCSFIELD;
    np->key = xstrdup ("commitid");
    np->data = xstrdup(global_session_id);
    addnode (delta->other_delta, np);

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If permissions should be preserved on this project, then
       save the permission info. */
    if (preserve_perms)
    {
	Node *np;
	char buf[64];	/* static buffer should be safe: see usage. -twp */

	delta->other_delta = getlist();

	if (CVS_LSTAT (workfile, &sb) < 0)
	    error (1, 1, "cannot lstat %s", workfile);

	if (S_ISLNK (sb.st_mode))
	{
	    np = getnode();
	    np->type = RCSFIELD;
	    np->key = xstrdup ("symlink");
	    np->data = xreadlink (workfile);
	    addnode (delta->other_delta, np);
	}
	else
	{
	    (void) sprintf (buf, "%u", sb.st_uid);
	    np = getnode();
	    np->type = RCSFIELD;
	    np->key = xstrdup ("owner");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);

	    (void) sprintf (buf, "%u", sb.st_gid);
	    np = getnode();
	    np->type = RCSFIELD;
	    np->key = xstrdup ("group");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);
	    
	    (void) sprintf (buf, "%o", sb.st_mode & 07777);
	    np = getnode();
	    np->type = RCSFIELD;
	    np->key = xstrdup ("permissions");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);

	    /* Save device number. */
	    switch (sb.st_mode & S_IFMT)
	    {
		case S_IFREG: break;
		case S_IFCHR:
		case S_IFBLK:
#ifdef HAVE_ST_RDEV
		    np = getnode();
		    np->type = RCSFIELD;
		    np->key = xstrdup ("special");
		    sprintf (buf, "%s %lu",
			     ((sb.st_mode & S_IFMT) == S_IFCHR
			      ? "character" : "block"),
			     (unsigned long) sb.st_rdev);
		    np->data = xstrdup (buf);
		    addnode (delta->other_delta, np);
#else
		    error (0, 0,
"can't preserve %s: unable to save device files on this system",
workfile);
#endif
		    break;

		default:
		    error (0, 0, "special file %s has unknown type", workfile);
	    }

	    /* Save hardlinks. */
	    delta->hardlinks = list_linked_files_on_disk (workfile);
	}
    }
#endif

    /* Create a new deltatext node. */
    dtext = (Deltatext *) xmalloc (sizeof (Deltatext));
    memset (dtext, 0, sizeof (Deltatext));

    dtext->log = make_message_rcslegal (message);

    /* If the delta tree is empty, then there's nothing to link the
       new delta into.  So make a new delta tree, snarf the working
       file contents, and just write the new RCS file. */
    if (rcs->head == NULL)
    {
	char *newrev;
	FILE *fout;

	/* Figure out what the first revision number should be. */
	if (rev == NULL || *rev == '\0')
	    newrev = xstrdup ("1.1");
	else if (numdots (rev) == 0)
	{
	    newrev = (char *) xmalloc (strlen (rev) + 3);
	    strcpy (newrev, rev);
	    strcat (newrev, ".1");
	}
	else
	    newrev = xstrdup (rev);

	/* Don't need to xstrdup NEWREV because it's already dynamic, and
	   not used for anything else.  (Don't need to free it, either.) */
	rcs->head = newrev;
	delta->version = xstrdup (newrev);
	nodep = getnode();
	nodep->type = RCSVERS;
	nodep->delproc = rcsvers_delproc;
	nodep->data = (char *) delta;
	nodep->key = delta->version;
	(void) addnode (rcs->versions, nodep);

	dtext->version = xstrdup (newrev);
	bufsize = 0;
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (preserve_perms && !S_ISREG (sb.st_mode))
	    /* Pretend file is empty.  */
	    bufsize = 0;
	else
#endif
	get_file (workfile, workfile,
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
		  &dtext->text, &bufsize, &dtext->len);

	if (!checkin_quiet)
	{
	    cvs_output ("initial revision: ", 0);
	    cvs_output (rcs->head, 0);
	    cvs_output ("\n", 1);
	}

	/* We are probably about to invalidate any cached file.  */
	rcsbuf_cache_close ();

	fout = rcs_internal_lockfile (rcs->path);
	RCS_putadmin (rcs, fout);
	RCS_putdtree (rcs, rcs->head, fout);
	RCS_putdesc (rcs, fout);
	rcs->delta_pos = ftell (fout);
	if (rcs->delta_pos == -1)
	    error (1, errno, "cannot ftell for %s", rcs->path);
	putdeltatext (fout, dtext);
	rcs_internal_unlockfile (fout, rcs->path);

	if ((flags & RCS_FLAGS_KEEPFILE) == 0)
	{
	    if (unlink_file (workfile) < 0)
		/* FIXME-update-dir: message does not include update_dir.  */
		error (0, errno, "cannot remove %s", workfile);
	}

	if (!checkin_quiet)
	    cvs_output ("done\n", 5);

	status = 0;
	goto checkin_done;
    }

    /* Derive a new revision number.  From the `ci' man page:

	 "If rev  is  a revision number, it must be higher than the
	 latest one on the branch to which  rev  belongs,  or  must
	 start a new branch.

	 If  rev is a branch rather than a revision number, the new
	 revision is appended to that branch.  The level number  is
	 obtained  by  incrementing the tip revision number of that
	 branch.  If rev  indicates  a  non-existing  branch,  that
	 branch  is  created  with  the  initial  revision numbered
	 rev.1."

       RCS_findlock_or_tip handles the case where REV is omitted.
       RCS 5.7 also permits REV to be "$" or to begin with a dot, but
       we do not address those cases -- every routine that calls
       RCS_checkin passes it a numeric revision. */

    if (rev == NULL || *rev == '\0')
    {
	/* Figure out where the commit point is by looking for locks.
	   If the commit point is at the tip of a branch (or is the
	   head of the delta tree), then increment its revision number
	   to obtain the new revnum.  Otherwise, start a new
	   branch. */
	commitpt = RCS_findlock_or_tip (rcs);
	if (commitpt == NULL)
	{
	    status = 1;
	    goto checkin_done;
	}
	else if (commitpt->next == NULL
		 || STREQ (commitpt->version, rcs->head))
	    delta->version = increment_revnum (commitpt->version);
	else
	    delta->version = RCS_addbranch (rcs, commitpt->version);
    }
    else
    {
	/* REV is either a revision number or a branch number.  Find the
	   tip of the target branch. */
	char *branch, *tip, *newrev, *p;
	int dots, isrevnum;

	assert (isdigit ((unsigned char) *rev));

	newrev = xstrdup (rev);
	dots = numdots (newrev);
	isrevnum = dots & 1;

	branch = xstrdup (rev);
	if (isrevnum)
	{
	    p = strrchr (branch, '.');
	    *p = '\0';
	}

	/* Find the tip of the target branch.  If we got a one- or two-digit
	   revision number, this will be the head of the tree.  Exception:
	   if rev is a single-field revision equal to the branch number of
	   the trunk (usually "1") then we want to treat it like an ordinary
	   branch revision. */
	if (dots == 0)
	{
	    tip = xstrdup (rcs->head);
	    if (atoi (tip) != atoi (branch))
	    {
		newrev = (char *) xrealloc (newrev, strlen (newrev) + 3);
		strcat (newrev, ".1");
		dots = isrevnum = 1;
	    }
	}
	else if (dots == 1)
	    tip = xstrdup (rcs->head);
	else
	    tip = RCS_getbranch (rcs, branch, 1);

	/* If the branch does not exist, and we were supplied an exact
	   revision number, signal an error.  Otherwise, if we were
	   given only a branch number, create it and set COMMITPT to
	   the branch point. */
	if (tip == NULL)
	{
	    if (isrevnum)
	    {
		error (0, 0, "%s: can't find branch point %s",
		       rcs->path, branch);
		free (branch);
		free (newrev);
		status = 1;
		goto checkin_done;
	    }
	    delta->version = RCS_addbranch (rcs, branch);
	    if (!delta->version)
	    {
		free (branch);
		free (newrev);
		status = 1;
		goto checkin_done;
	    }
	    adding_branch = 1;
	    p = strrchr (branch, '.');
	    *p = '\0';
	    tip = xstrdup (branch);
	}
	else
	{
	    if (isrevnum)
	    {
		/* NEWREV must be higher than TIP. */
		if (compare_revnums (tip, newrev) >= 0)
		{
		    error (0, 0,
			   "%s: revision %s too low; must be higher than %s",
			   rcs->path,
			   newrev, tip);
		    free (branch);
		    free (newrev);
		    free (tip);
		    status = 1;
		    goto checkin_done;
		}
		delta->version = xstrdup (newrev);
	    }
	    else
		/* Just increment the tip number to get the new revision. */
		delta->version = increment_revnum (tip);
	}

	nodep = findnode (rcs->versions, tip);
	commitpt = (RCSVers *) nodep->data;

	free (branch);
	free (newrev);
	free (tip);
    }

    assert (delta->version != NULL);

    /* If COMMITPT is locked by us, break the lock.  If it's locked
       by someone else, signal an error. */
    nodep = findnode (RCS_getlocks (rcs), commitpt->version);
    if (nodep != NULL)
    {
	if (! STREQ (nodep->data, delta->author))
	{
	    /* If we are adding a branch, then leave the old lock around.
	       That is sensible in the sense that when adding a branch,
	       we don't need to use the lock to tell us where to check
	       in.  It is fishy in the sense that if it is our own lock,
	       we break it.  However, this is the RCS 5.7 behavior (at
	       the end of addbranch in ci.c in RCS 5.7, it calls
	       removelock only if it is our own lock, not someone
	       else's).  */

	    if (!adding_branch)
	    {
		error (0, 0, "%s: revision %s locked by %s",
		       rcs->path,
		       nodep->key, nodep->data);
		status = 1;
		goto checkin_done;
	    }
	}
	else
	    delnode (nodep);
    }

    dtext->version = xstrdup (delta->version);

    /* Obtain the change text for the new delta.  If DELTA is to be the
       new head of the tree, then its change text should be the contents
       of the working file, and LEAFNODE's change text should be a diff.
       Else, DELTA's change text should be a diff between LEAFNODE and
       the working file. */

    tmpfile = cvs_temp_name();
    status = RCS_checkout (rcs, NULL, commitpt->version, NULL,
			   ((rcs->expand != NULL
			     && STREQ (rcs->expand, "b"))
			    ? "-kb"
			    : "-ko"),
			   tmpfile,
			   (RCSCHECKOUTPROC)0, NULL);
    if (status != 0)
	error (1, 0,
	       "could not check out revision %s of `%s'",
	       commitpt->version, rcs->path);

    bufsize = buflen = 0;
    chtext = NULL;
    chtextlen = 0;
    changefile = cvs_temp_name();

    /* Diff options should include --binary if the RCS file has -kb set
       in its `expand' field. */
    diffopts = (rcs->expand != NULL && STREQ (rcs->expand, "b")
		? "-a -n --binary"
		: "-a -n");

    if (STREQ (commitpt->version, rcs->head) &&
	numdots (delta->version) == 1)
    {
	/* If this revision is being inserted on the trunk, the change text
	   for the new delta should be the contents of the working file ... */
	bufsize = 0;
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (preserve_perms && !S_ISREG (sb.st_mode))
	    /* Pretend file is empty.  */
	    ;
	else
#endif
	get_file (workfile, workfile,
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
		  &dtext->text, &bufsize, &dtext->len);

	/* ... and the change text for the old delta should be a diff. */
	commitpt->text = (Deltatext *) xmalloc (sizeof (Deltatext));
	memset (commitpt->text, 0, sizeof (Deltatext));

	bufsize = 0;
	switch (diff_exec (workfile, tmpfile, NULL, NULL, diffopts, changefile))
	{
	    case 0:
	    case 1:
		break;
	    case -1:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, errno, "error diffing %s", workfile);
		break;
	    default:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, 0, "error diffing %s", workfile);
		break;
	}

	/* OK, the text file case here is really dumb.  Logically
	   speaking we want diff to read the files in text mode,
	   convert them to the canonical form found in RCS files
	   (which, we hope at least, is independent of OS--always
	   bare linefeeds), and then work with change texts in that
	   format.  However, diff_exec both generates change
	   texts and produces output for user purposes (e.g. patch.c),
	   and there is no way to distinguish between the two cases.
	   So we actually implement the text file case by writing the
	   change text as a text file, then reading it as a text file.
	   This should cause no harm, but doesn't strike me as
	   immensely clean.  */
	get_file (changefile, changefile,
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
		  &commitpt->text->text, &bufsize, &commitpt->text->len);

	/* If COMMITPT->TEXT->TEXT is NULL, it means that CHANGEFILE
	   was empty and that there are no differences between revisions.
	   In that event, we want to force RCS_rewrite to write an empty
	   string for COMMITPT's change text.  Leaving the change text
	   field set NULL won't work, since that means "preserve the original
	   change text for this delta." */
	if (commitpt->text->text == NULL)
	{
	    commitpt->text->text = xstrdup ("");
	    commitpt->text->len = 0;
	}
    }
    else
    {
	/* This file is not being inserted at the head, but on a side
	   branch somewhere.  Make a diff from the previous revision
	   to the working file. */
	switch (diff_exec (tmpfile, workfile, NULL, NULL, diffopts, changefile))
	{
	    case 0:
	    case 1:
		break;
	    case -1:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, errno, "error diffing %s", workfile);
		break;
	    default:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, 0, "error diffing %s", workfile);
		break;
	}
	/* See the comment above, at the other get_file invocation,
	   regarding binary vs. text.  */
	get_file (changefile, changefile, 
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
		  &dtext->text, &bufsize,
		  &dtext->len);
	if (dtext->text == NULL)
	{
	    dtext->text = xstrdup ("");
	    dtext->len = 0;
	}
    }

    /* Update DELTA linkage.  It is important not to do this before
       the very end of RCS_checkin; if an error arises that forces
       us to abort checking in, we must not have malformed deltas
       partially linked into the tree.

       If DELTA and COMMITPT are on different branches, do nothing --
       DELTA is linked to the tree through COMMITPT->BRANCHES, and we
       don't want to change `next' pointers.

       Otherwise, if the nodes are both on the trunk, link DELTA to
       COMMITPT; otherwise, link COMMITPT to DELTA. */

    if (numdots (commitpt->version) == numdots (delta->version))
    {
	if (STREQ (commitpt->version, rcs->head))
	{
	    delta->next = rcs->head;
	    rcs->head = xstrdup (delta->version);
	}
	else
	    commitpt->next = xstrdup (delta->version);
    }

    /* Add DELTA to RCS->VERSIONS. */
    if (rcs->versions == NULL)
	rcs->versions = getlist();
    nodep = getnode();
    nodep->type = RCSVERS;
    nodep->delproc = rcsvers_delproc;
    nodep->data = (char *) delta;
    nodep->key = delta->version;
    (void) addnode (rcs->versions, nodep);
	
    /* Write the new RCS file, inserting the new delta at COMMITPT. */
    if (!checkin_quiet)
    {
	cvs_output ("new revision: ", 14);
	cvs_output (delta->version, 0);
	cvs_output ("; previous revision: ", 21);
	cvs_output (commitpt->version, 0);
	cvs_output ("\n", 1);
    }

    RCS_rewrite (rcs, dtext, commitpt->version);

    if ((flags & RCS_FLAGS_KEEPFILE) == 0)
    {
	if (unlink_file (workfile) < 0)
	    /* FIXME-update-dir: message does not include update_dir.  */
	    error (1, errno, "cannot remove %s", workfile);
    }
    if (unlink_file (tmpfile) < 0)
	error (0, errno, "cannot remove %s", tmpfile);
    free (tmpfile);
    if (unlink_file (changefile) < 0)
	error (0, errno, "cannot remove %s", changefile);
    free (changefile);

    if (!checkin_quiet)
	cvs_output ("done\n", 5);

 checkin_done:
    if (allocated_workfile)
	free (workfile);

    if (commitpt != NULL && commitpt->text != NULL)
    {
	freedeltatext (commitpt->text);
	commitpt->text = NULL;
    }

    freedeltatext (dtext);
    if (status != 0)
	free_rcsvers_contents (delta);

    return status;
}

/* This structure is passed between RCS_cmp_file and cmp_file_buffer.  */

struct cmp_file_data
{
    const char *filename;
    FILE *fp;
    int different;
};

/* Compare the contents of revision REV of RCS file RCS with the
   contents of the file FILENAME.  OPTIONS is a string for the keyword
   expansion options.  Return 0 if the contents of the revision are
   the same as the contents of the file, 1 if they are different.  */

int
RCS_cmp_file (rcs, rev, options, filename)
     RCSNode *rcs;
     char *rev;
     char *options;
     const char *filename;
{
    int binary;
    FILE *fp;
    struct cmp_file_data data;
    int retcode;

    if (options != NULL && options[0] != '\0')
	binary = STREQ (options, "-kb");
    else
    {
	char *expand;

	expand = RCS_getexpand (rcs);
	if (expand != NULL && STREQ (expand, "b"))
	    binary = 1;
	else
	    binary = 0;
    }

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If CVS is to deal properly with special files (when
       PreservePermissions is on), the best way is to check out the
       revision to a temporary file and call `xcmp' on the two disk
       files.  xcmp needs to handle non-regular files properly anyway,
       so calling it simplifies RCS_cmp_file.  We *could* just yank
       the delta node out of the version tree and look for device
       numbers, but writing to disk and calling xcmp is a better
       abstraction (therefore probably more robust). -twp */

    if (preserve_perms)
    {
	char *tmp;

	tmp = cvs_temp_name();
	retcode = RCS_checkout(rcs, NULL, rev, NULL, options, tmp, NULL, NULL);
	if (retcode != 0)
	    return 1;

	retcode = xcmp (tmp, filename);
	if (CVS_UNLINK (tmp) < 0)
	    error (0, errno, "cannot remove %s", tmp);
	free (tmp);
	return retcode;
    }
    else
#endif
    {
        fp = CVS_FOPEN (filename, binary ? FOPEN_BINARY_READ : "r");
	if (fp == NULL)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (1, errno, "cannot open file %s for comparing", filename);
	
        data.filename = filename;
        data.fp = fp;
        data.different = 0;
	
        retcode = RCS_checkout (rcs, (char *) NULL, rev, (char *) NULL,
				options, RUN_TTY, cmp_file_buffer,
				(void *) &data);

        /* If we have not yet found a difference, make sure that we are at
           the end of the file.  */
        if (! data.different)
        {
	    if (getc (fp) != EOF)
		data.different = 1;
        }
	
        fclose (fp);

	if (retcode != 0)
	    return 1;
	
        return data.different;
    }
}

/* This is a subroutine of RCS_cmp_file.  It is passed to
   RCS_checkout.  */

#define CMP_BUF_SIZE (8 * 1024)

static void
cmp_file_buffer (callerdat, buffer, len)
     void *callerdat;
     const char *buffer;
     size_t len;
{
    struct cmp_file_data *data = (struct cmp_file_data *) callerdat;
    char *filebuf;

    /* If we've already found a difference, we don't need to check
       further.  */
    if (data->different)
	return;

    filebuf = xmalloc (len > CMP_BUF_SIZE ? CMP_BUF_SIZE : len);

    while (len > 0)
    {
	size_t checklen;

	checklen = len > CMP_BUF_SIZE ? CMP_BUF_SIZE : len;
	if (fread (filebuf, 1, checklen, data->fp) != checklen)
	{
	    if (ferror (data->fp))
		error (1, errno, "cannot read file %s for comparing",
		       data->filename);
	    data->different = 1;
	    free (filebuf);
	    return;
	}

	if (memcmp (filebuf, buffer, checklen) != 0)
	{
	    data->different = 1;
	    free (filebuf);
	    return;
	}

	buffer += checklen;
	len -= checklen;
    }

    free (filebuf);
}

/* For RCS file RCS, make symbolic tag TAG point to revision REV.
   This validates that TAG is OK for a user to use.  Return value is
   -1 for error (and errno is set to indicate the error), positive for
   error (and an error message has been printed), or zero for success.  */

int
RCS_settag (rcs, tag, rev)
    RCSNode *rcs;
    const char *tag;
    const char *rev;
{
    List *symbols;
    Node *node;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* FIXME: This check should be moved to RCS_check_tag.  There is no
       reason for it to be here.  */
    if (STREQ (tag, TAG_BASE)
	|| STREQ (tag, TAG_HEAD))
    {
	/* Print the name of the tag might be considered redundant
	   with the caller, which also prints it.  Perhaps this helps
	   clarify why the tag name is considered reserved, I don't
	   know.  */
	error (0, 0, "Attempt to add reserved tag name %s", tag);
	return 1;
    }

    /* A revision number of NULL means use the head or default branch.
       If rev is not NULL, it may be a symbolic tag or branch number;
       expand it to the correct numeric revision or branch head. */
    if (rev == NULL)
	rev = rcs->branch ? rcs->branch : rcs->head;

    /* At this point rcs->symbol_data may not have been parsed.
       Calling RCS_symbols will force it to be parsed into a list
       which we can easily manipulate.  */
    symbols = RCS_symbols (rcs);
    if (symbols == NULL)
    {
	symbols = getlist ();
	rcs->symbols = symbols;
    }
    node = findnode (symbols, tag);
    if (node != NULL)
    {
	free (node->data);
	node->data = xstrdup (rev);
    }
    else
    {
	node = getnode ();
	node->key = xstrdup (tag);
	node->data = xstrdup (rev);
	(void) addnode_at_front (symbols, node);
    }

    return 0;
}

/* Delete the symbolic tag TAG from the RCS file RCS.  Return 0 if
   the tag was found (and removed), or 1 if it was not present.  (In
   either case, the tag will no longer be in RCS->SYMBOLS.) */

int
RCS_deltag (rcs, tag)
    RCSNode *rcs;
    const char *tag;
{
    List *symbols;
    Node *node;
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    symbols = RCS_symbols (rcs);
    if (symbols == NULL)
	return 1;

    node = findnode (symbols, tag);
    if (node == NULL)
	return 1;

    delnode (node);

    return 0;
}

/* Set the default branch of RCS to REV.  */

int
RCS_setbranch (rcs, rev)
     RCSNode *rcs;
     const char *rev;
{
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rev && ! *rev)
	rev = NULL;

    if (rev == NULL && rcs->branch == NULL)
	return 0;
    if (rev != NULL && rcs->branch != NULL && STREQ (rev, rcs->branch))
	return 0;

    if (rcs->branch != NULL)
	free (rcs->branch);
    rcs->branch = xstrdup (rev);

    return 0;
}

/* Lock revision REV.  LOCK_QUIET is 1 to suppress output.  FIXME:
   Most of the callers only call us because RCS_checkin still tends to
   like a lock (a relic of old behavior inherited from the RCS ci
   program).  If we clean this up, only "cvs admin -l" will still need
   to call RCS_lock.  */

/* FIXME-twp: if a lock owned by someone else is broken, should this
   send mail to the lock owner?  Prompt user?  It seems like such an
   obscure situation for CVS as almost not worth worrying much
   about. */

int
RCS_lock (rcs, rev, lock_quiet)
     RCSNode *rcs;
     char *rev;
     int lock_quiet;
{
    List *locks;
    Node *p;
    char *user;
    char *xrev = NULL;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    locks = RCS_getlocks (rcs);
    if (locks == NULL)
	locks = rcs->locks = getlist();
    user = getcaller();

    /* A revision number of NULL means lock the head or default branch. */
    if (rev == NULL)
	xrev = RCS_head (rcs);
    else
	xrev = RCS_gettag (rcs, rev, 1, (int *) NULL);

    /* Make sure that the desired revision exists.  Technically,
       we can update the locks list without even checking this,
       but RCS 5.7 did this.  And it can't hurt. */
    if (xrev == NULL || findnode (rcs->versions, xrev) == NULL)
    {
	if (!lock_quiet)
	    error (0, 0, "%s: revision %s absent", rcs->path, rev);
	free (xrev);
	return 1;
    }

    /* Is this rev already locked? */
    p = findnode (locks, xrev);
    if (p != NULL)
    {
	if (STREQ (p->data, user))
	{
	    /* We already own the lock on this revision, so do nothing. */
	    free (xrev);
	    return 0;
	}

#if 0
	/* Well, first of all, "rev" below should be "xrev" to avoid
	   core dumps.  But more importantly, should we really be
	   breaking the lock unconditionally?  What CVS 1.9 does (via
	   RCS) is to prompt "Revision 1.1 is already locked by fred.
	   Do you want to break the lock? [ny](n): ".  Well, we don't
	   want to interact with the user (certainly not at the
	   server/protocol level, and probably not in the command-line
	   client), but isn't it more sensible to give an error and
	   let the user run "cvs admin -u" if they want to break the
	   lock?  */

	/* Break the lock. */	    
	if (!lock_quiet)
	{
	    cvs_output (rev, 0);
	    cvs_output (" unlocked\n", 0);
	}
	delnode (p);
#else
	error (1, 0, "Revision %s is already locked by %s", xrev, p->data);
#endif
    }

    /* Create a new lock. */
    p = getnode();
    p->key = xrev;	/* already xstrdupped */
    p->data = xstrdup (getcaller());
    (void) addnode_at_front (locks, p);

    if (!lock_quiet)
    {
	cvs_output (xrev, 0);
	cvs_output (" locked\n", 0);
    }

    return 0;
}

/* Unlock revision REV.  UNLOCK_QUIET is 1 to suppress output.  FIXME:
   Like RCS_lock, this can become a no-op if we do the checkin
   ourselves.

   If REV is not null and is locked by someone else, break their
   lock and notify them.  It is an open issue whether RCS_unlock
   queries the user about whether or not to break the lock. */

int
RCS_unlock (rcs, rev, unlock_quiet)
     RCSNode *rcs;
     char *rev;
     int unlock_quiet;
{
    Node *lock;
    List *locks;
    char *user;
    char *xrev = NULL;

    user = getcaller();
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* If rev is NULL, unlock the latest revision (first in
       rcs->locks) held by the caller. */
    if (rev == NULL)
    {
	Node *p;

	/* No-ops: attempts to unlock an empty tree or an unlocked file. */
	if (rcs->head == NULL)
	{
	    if (!unlock_quiet)
		cvs_outerr ("can't unlock an empty tree\n", 0);
	    return 0;
	}

	locks = RCS_getlocks (rcs);
	if (locks == NULL)
	{
	    if (!unlock_quiet)
		cvs_outerr ("No locks are set.\n", 0);
	    return 0;
	}

	lock = NULL;
	for (p = locks->list->next; p != locks->list; p = p->next)
	{
	    if (lock != NULL)
	    {
		if (!unlock_quiet)
		    error (0, 0, "\
%s: multiple revisions locked by %s; please specify one", rcs->path, user);
		return 1;
	    }
	    lock = p;
	}
	if (lock == NULL)
	    return 0;	/* no lock found, ergo nothing to do */
	xrev = xstrdup (lock->key);
    }
    else
    {
	xrev = RCS_gettag (rcs, rev, 1, (int *) NULL);
	if (xrev == NULL)
	{
	    error (0, 0, "%s: revision %s absent", rcs->path, rev);
	    return 1;
	}
    }

    lock = findnode (RCS_getlocks (rcs), xrev);
    if (lock == NULL)
    {
	/* This revision isn't locked. */
	free (xrev);
	return 0;
    }

    if (! STREQ (lock->data, user))
    {
        /* If the revision is locked by someone else, notify
	   them.  Note that this shouldn't ever happen if RCS_unlock
	   is called with a NULL revision, since that means "whatever
	   revision is currently locked by the caller." */
	char *repos, *workfile;
	repos = xstrdup (rcs->path);
	workfile = strrchr (repos, '/');
	*workfile++ = '\0';
	notify_do ('C', workfile, user, NULL, NULL, repos);
	free (repos);
    }

    delnode (lock);
    if (!unlock_quiet)
    {
	cvs_output (xrev, 0);
	cvs_output (" unlocked\n", 0);
    }

    free (xrev);
    return 0;
}

/* Add USER to the access list of RCS.  Do nothing if already present.
   FIXME-twp: check syntax of USER to make sure it's a valid id. */

void
RCS_addaccess (rcs, user)
    RCSNode *rcs;
    char *user;
{
    char *access, *a;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rcs->access == NULL)
	rcs->access = xstrdup (user);
    else
    {
	access = xstrdup (rcs->access);
	for (a = strtok (access, " "); a != NULL; a = strtok (NULL, " "))
	{
	    if (STREQ (a, user))
	    {
		free (access);
		return;
	    }
	}
	free (access);
	rcs->access = (char *) xrealloc
	    (rcs->access, strlen (rcs->access) + strlen (user) + 2);
	strcat (rcs->access, " ");
	strcat (rcs->access, user);
    }
}

/* Remove USER from the access list of RCS. */

void
RCS_delaccess (rcs, user)
    RCSNode *rcs;
    char *user;
{
    char *p, *s;
    int ulen;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rcs->access == NULL)
	return;

    if (user == NULL)
    {
        free (rcs->access);
        rcs->access = NULL;
        return;
    }

    p = rcs->access;
    ulen = strlen (user);
    while (p != NULL)
    {
	if (strncmp (p, user, ulen) == 0 && (p[ulen] == '\0' || p[ulen] == ' '))
	    break;
	p = strchr (p, ' ');
	if (p != NULL)
	    ++p;
    }

    if (p == NULL)
	return;

    s = p + ulen;
    while (*s != '\0')
	*p++ = *s++;
    *p = '\0';
}

char *
RCS_getaccess (rcs)
    RCSNode *rcs;
{
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    return rcs->access;
}

static int findtag PROTO ((Node *, void *));

/* Return a nonzero value if the revision specified by ARG is found.  */

static int
findtag (node, arg)
    Node *node;
    void *arg;
{
    char *rev = (char *)arg;

    if (STREQ (node->data, rev))
	return 1;
    else
	return 0;
}

/* Delete revisions between REV1 and REV2.  The changes between the two
   revisions must be collapsed, and the result stored in the revision
   immediately preceding the lower one.  Return 0 for successful completion,
   1 otherwise.

   Solution: check out the revision preceding REV1 and the revision
   following REV2.  Use call_diff to find aggregate diffs between
   these two revisions, and replace the delta text for the latter one
   with the new aggregate diff.  Alternatively, we could write a
   function that takes two change texts and combines them to produce a
   new change text, without checking out any revs or calling diff.  It
   would be hairy, but so, so cool.

   If INCLUSIVE is set, then TAG1 and TAG2, if non-NULL, tell us to
   delete that revision as well (cvs admin -o tag1:tag2).  If clear,
   delete up to but not including that revision (cvs admin -o tag1::tag2).
   This does not affect TAG1 or TAG2 being NULL; the meaning of the start
   point in ::tag2 and :tag2 is the same and likewise for end points.  */

int
RCS_delete_revs (rcs, tag1, tag2, inclusive)
    RCSNode *rcs;
    char *tag1;
    char *tag2;
    int inclusive;
{
    char *next;
    Node *nodep;
    RCSVers *revp = NULL;
    RCSVers *beforep;
    int status, found;
    int save_noexec;

    char *branchpoint = NULL;
    char *rev1 = NULL;
    char *rev2 = NULL;
    int rev1_inclusive = inclusive;
    int rev2_inclusive = inclusive;
    char *before = NULL;
    char *after = NULL;
    char *beforefile = NULL;
    char *afterfile = NULL;
    char *outfile = NULL;

    if (tag1 == NULL && tag2 == NULL)
	return 0;

    /* Assume error status until everything is finished. */
    status = 1;

    /* Make sure both revisions exist. */
    if (tag1 != NULL)
    {
	rev1 = RCS_gettag (rcs, tag1, 1, NULL);
	if (rev1 == NULL || (nodep = findnode (rcs->versions, rev1)) == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, tag1);
	    goto delrev_done;
	}
    }
    if (tag2 != NULL)
    {
	rev2 = RCS_gettag (rcs, tag2, 1, NULL);
	if (rev2 == NULL || (nodep = findnode (rcs->versions, rev2)) == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, tag2);
	    goto delrev_done;
	}
    }

    /* If rev1 is on the trunk and rev2 is NULL, rev2 should be
       RCS->HEAD.  (*Not* RCS_head(rcs), which may return rcs->branch
       instead.)  We need to check this special case early, in order
       to make sure that rev1 and rev2 get ordered correctly. */
    if (rev2 == NULL && numdots (rev1) == 1)
    {
	rev2 = xstrdup (rcs->head);
	rev2_inclusive = 1;
    }

    if (rev2 == NULL)
	rev2_inclusive = 1;

    if (rev1 != NULL && rev2 != NULL)
    {
	/* A range consisting of a branch number means the latest revision
	   on that branch. */
	if (RCS_isbranch (rcs, rev1) && STREQ (rev1, rev2))
	    rev1 = rev2 = RCS_getbranch (rcs, rev1, 0);
	else
	{
	    /* Make sure REV1 and REV2 are ordered correctly (in the
	       same order as the next field).  For revisions on the
	       trunk, REV1 should be higher than REV2; for branches,
	       REV1 should be lower.  */
	    /* Shouldn't we just be giving an error in the case where
	       the user specifies the revisions in the wrong order
	       (that is, always swap on the trunk, never swap on a
	       branch, in the non-error cases)?  It is not at all
	       clear to me that users who specify -o 1.4:1.2 really
	       meant to type -o 1.2:1.4, and the out of order usage
	       has never been documented, either by cvs.texinfo or
	       rcs(1).  */
	    char *temp;
	    int temp_inclusive;
	    if (numdots (rev1) == 1)
	    {
		if (compare_revnums (rev1, rev2) <= 0)
		{
		    temp = rev2;
		    rev2 = rev1;
		    rev1 = temp;

		    temp_inclusive = rev2_inclusive;
		    rev2_inclusive = rev1_inclusive;
		    rev1_inclusive = temp_inclusive;
		}
	    }
	    else if (compare_revnums (rev1, rev2) > 0)
	    {
		temp = rev2;
		rev2 = rev1;
		rev1 = temp;

		temp_inclusive = rev2_inclusive;
		rev2_inclusive = rev1_inclusive;
		rev1_inclusive = temp_inclusive;
	    }
	}
    }

    /* Basically the same thing; make sure that the ordering is what we
       need.  */
    if (rev1 == NULL)
    {
	assert (rev2 != NULL);
	if (numdots (rev2) == 1)
	{
	    /* Swap rev1 and rev2.  */
	    int temp_inclusive;

	    rev1 = rev2;
	    rev2 = NULL;

	    temp_inclusive = rev2_inclusive;
	    rev2_inclusive = rev1_inclusive;
	    rev1_inclusive = temp_inclusive;
	}
    }

    /* Put the revision number preceding the first one to delete into
       BEFORE (where "preceding" means according to the next field).
       If the first revision to delete is the first revision on its
       branch (e.g. 1.3.2.1), BEFORE should be the node on the trunk
       at which the branch is rooted.  If the first revision to delete
       is the head revision of the trunk, set BEFORE to NULL.

       Note that because BEFORE may not be on the same branch as REV1,
       it is not very handy for navigating the revision tree.  It's
       most useful just for checking out the revision preceding REV1. */
    before = NULL;
    branchpoint = RCS_getbranchpoint (rcs, rev1 != NULL ? rev1 : rev2);
    if (rev1 == NULL)
    {
	rev1 = xstrdup (branchpoint);
	if (numdots (branchpoint) > 1)
	{
	    char *bp;
	    bp = strrchr (branchpoint, '.');
	    while (*--bp != '.')
		;
	    *bp = '\0';
	    /* Note that this is exclusive, always, because the inclusive
	       flag doesn't affect the meaning when rev1 == NULL.  */
	    before = xstrdup (branchpoint);
	    *bp = '.';
	}
    }
    else if (! STREQ (rev1, branchpoint))
    {
	/* Walk deltas from BRANCHPOINT on, looking for REV1. */
	nodep = findnode (rcs->versions, branchpoint);
	revp = (RCSVers *) nodep->data;
	while (revp->next != NULL && ! STREQ (revp->next, rev1))
	{
	    revp = (RCSVers *) nodep->data;
	    nodep = findnode (rcs->versions, revp->next);
	}
	if (revp->next == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, rev1);
	    goto delrev_done;
	}
	if (rev1_inclusive)
	    before = xstrdup (revp->version);
	else
	{
	    before = rev1;
	    nodep = findnode (rcs->versions, before);
	    rev1 = xstrdup (((RCSVers *)nodep->data)->next);
	}
    }
    else if (!rev1_inclusive)
    {
	before = rev1;
	nodep = findnode (rcs->versions, before);
	rev1 = xstrdup (((RCSVers *)nodep->data)->next);
    }
    else if (numdots (branchpoint) > 1)
    {
	/* Example: rev1 is "1.3.2.1", branchpoint is "1.3.2.1".
	   Set before to "1.3".  */
	char *bp;
	bp = strrchr (branchpoint, '.');
	while (*--bp != '.')
	    ;
	*bp = '\0';
	before = xstrdup (branchpoint);
	*bp = '.';
    }

    /* If any revision between REV1 and REV2 is locked or is a branch point,
       we can't delete that revision and must abort. */
    after = NULL;
    next = rev1;
    found = 0;
    while (!found && next != NULL)
    {
	nodep = findnode (rcs->versions, next);
	revp = (RCSVers *) nodep->data;

	if (rev2 != NULL)
	    found = STREQ (revp->version, rev2);
	next = revp->next;

	if ((!found && next != NULL) || rev2_inclusive || rev2 == NULL)
	{
	    if (findnode (RCS_getlocks (rcs), revp->version))
	    {
		error (0, 0, "%s: can't remove locked revision %s",
		       rcs->path,
		       revp->version);
		goto delrev_done;
	    }
	    if (revp->branches != NULL)
	    {
		error (0, 0, "%s: can't remove branch point %s",
		       rcs->path,
		       revp->version);
		goto delrev_done;
	    }

	    /* Doing this only for the :: syntax is for compatibility.
	       See cvs.texinfo for somewhat more discussion.  */
	    if (!inclusive
		&& walklist (RCS_symbols (rcs), findtag, revp->version))
	    {
		/* We don't print which file this happens to on the theory
		   that the caller will print the name of the file in a
		   more useful fashion (fullname not rcs->path).  */
		error (0, 0, "cannot remove revision %s because it has tags",
		       revp->version);
		goto delrev_done;
	    }

	    /* It's misleading to print the `deleting revision' output
	       here, since we may not actually delete these revisions.
	       But that's how RCS does it.  Bleah.  Someday this should be
	       moved to the point where the revs are actually marked for
	       deletion. -twp */
	    cvs_output ("deleting revision ", 0);
	    cvs_output (revp->version, 0);
	    cvs_output ("\n", 1);
	}
    }

    if (rev2 == NULL)
	;
    else if (found)
    {
	if (rev2_inclusive)
	    after = xstrdup (next);
	else
	    after = xstrdup (revp->version);
    }
    else if (!inclusive)
    {
	/* In the case of an empty range, for example 1.2::1.2 or
	   1.2::1.3, we want to just do nothing.  */
	status = 0;
	goto delrev_done;
    }
    else
    {
	/* This looks fishy in the cases where tag1 == NULL or tag2 == NULL.
	   Are those cases really impossible?  */
	assert (tag1 != NULL);
	assert (tag2 != NULL);

	error (0, 0, "%s: invalid revision range %s:%s", rcs->path,
	       tag1, tag2);
	goto delrev_done;
    }

    if (after == NULL && before == NULL)
    {
	/* The user is trying to delete all revisions.  While an
	   RCS file without revisions makes sense to RCS (e.g. the
	   state after "rcs -i"), CVS has never been able to cope with
	   it.  So at least for now we just make this an error.

	   We don't include rcs->path in the message since "cvs admin"
	   already printed "RCS file:" and the name.  */
	error (1, 0, "attempt to delete all revisions");
    }

    /* The conditionals at this point get really hairy.  Here is the
       general idea:

       IF before != NULL and after == NULL
         THEN don't check out any revisions, just delete them
       IF before == NULL and after != NULL
         THEN only check out after's revision, and use it for the new deltatext
       ELSE
         check out both revisions and diff -n them.  This could use
	 RCS_exec_rcsdiff with some changes, like being able
	 to suppress diagnostic messages and to direct output. */

    if (after != NULL)
    {
	char *diffbuf;
	size_t bufsize, len;

#if defined (__CYGWIN32__) || defined (_WIN32)
	/* FIXME: This is an awful kludge, but at least until I have
	   time to work on it a little more and test it, I'd rather
	   give a fatal error than corrupt the file.  I think that we
	   need to use "-kb" and "--binary" and "rb" to get_file
	   (probably can do it always, not just for binary files, if
	   we are consistent between the RCS_checkout and the diff).  */
	{
	    char *expand = RCS_getexpand (rcs);
	    if (expand != NULL && STREQ (expand, "b"))
		error (1, 0,
		   "admin -o not implemented yet for binary on this system");
	}
#endif

	afterfile = cvs_temp_name();
	status = RCS_checkout (rcs, NULL, after, NULL, "-ko", afterfile,
			       (RCSCHECKOUTPROC)0, NULL);
	if (status > 0)
	    goto delrev_done;

	if (before == NULL)
	{
	    /* We are deleting revisions from the head of the tree,
	       so must create a new head. */
	    diffbuf = NULL;
	    bufsize = 0;
	    get_file (afterfile, afterfile, "r", &diffbuf, &bufsize, &len);

	    save_noexec = noexec;
	    noexec = 0;
	    if (unlink_file (afterfile) < 0)
		error (0, errno, "cannot remove %s", afterfile);
	    noexec = save_noexec;

	    free (afterfile);
	    afterfile = NULL;

	    free (rcs->head);
	    rcs->head = xstrdup (after);
	}
	else
	{
	    beforefile = cvs_temp_name();
	    status = RCS_checkout (rcs, NULL, before, NULL, "-ko", beforefile,
				   (RCSCHECKOUTPROC)0, NULL);
	    if (status > 0)
		goto delrev_done;

	    outfile = cvs_temp_name();
	    status = diff_exec (beforefile, afterfile, NULL, NULL, "-an", outfile);

	    if (status == 2)
	    {
		/* Not sure we need this message; will diff_exec already
		   have printed an error?  */
		error (0, 0, "%s: could not diff", rcs->path);
		status = 1;
		goto delrev_done;
	    }

	    diffbuf = NULL;
	    bufsize = 0;
	    get_file (outfile, outfile, "r", &diffbuf, &bufsize, &len);
	}

	/* Save the new change text in after's delta node. */
	nodep = findnode (rcs->versions, after);
	revp = (RCSVers *) nodep->data;

	assert (revp->text == NULL);

	revp->text = (Deltatext *) xmalloc (sizeof (Deltatext));
	memset ((Deltatext *) revp->text, 0, sizeof (Deltatext));
	revp->text->version = xstrdup (revp->version);
	revp->text->text = diffbuf;
	revp->text->len = len;

	/* If DIFFBUF is NULL, it means that OUTFILE is empty and that
	   there are no differences between the two revisions.  In that
	   case, we want to force RCS_copydeltas to write an empty string
	   for the new change text (leaving the text field set NULL
	   means "preserve the original change text for this delta," so
	   we don't want that). */
	if (revp->text->text == NULL)
	    revp->text->text = xstrdup ("");
    }

    /* Walk through the revisions (again) to mark each one as
       outdated.  (FIXME: would it be safe to use the `dead' field for
       this?  Doubtful.) */
    for (next = rev1;
	 next != NULL && (after == NULL || ! STREQ (next, after));
	 next = revp->next)
    {
	nodep = findnode (rcs->versions, next);
	revp = (RCSVers *) nodep->data;
	revp->outdated = 1;
    }

    /* Update delta links.  If BEFORE == NULL, we're changing the
       head of the tree and don't need to update any `next' links. */
    if (before != NULL)
    {
	/* If REV1 is the first node on its branch, then BEFORE is its
	   root node (on the trunk) and we have to update its branches
	   list.  Otherwise, BEFORE is on the same branch as AFTER, and
	   we can just change BEFORE's `next' field to point to AFTER.
	   (This should be safe: since findnode manages its lists via
	   the `hashnext' and `hashprev' fields, rather than `next' and
	   `prev', mucking with `next' and `prev' should not corrupt the
	   delta tree's internal structure.  Much. -twp) */

	if (rev1 == NULL)
	    /* beforep's ->next field already should be equal to after,
	       which I think is always NULL in this case.  */
	    ;
	else if (STREQ (rev1, branchpoint))
	{
	    nodep = findnode (rcs->versions, before);
	    revp = (RCSVers *) nodep->data;
	    nodep = revp->branches->list->next;
	    while (nodep != revp->branches->list &&
		   ! STREQ (nodep->key, rev1))
		nodep = nodep->next;
	    assert (nodep != revp->branches->list);
	    if (after == NULL)
		delnode (nodep);
	    else
	    {
		free (nodep->key);
		nodep->key = xstrdup (after);
	    }
	}
	else
	{
	    nodep = findnode (rcs->versions, before);
	    beforep = (RCSVers *) nodep->data;
	    free (beforep->next);
	    beforep->next = xstrdup (after);
	}
    }

    status = 0;

 delrev_done:
    if (rev1 != NULL)
	free (rev1);
    if (rev2 != NULL)
	free (rev2);
    if (branchpoint != NULL)
	free (branchpoint);
    if (before != NULL)
	free (before);
    if (after != NULL)
	free (after);

    save_noexec = noexec;
    noexec = 0;
    if (beforefile != NULL)
    {
	if (unlink_file (beforefile) < 0)
	    error (0, errno, "cannot remove %s", beforefile);
	free (beforefile);
    }
    if (afterfile != NULL)
    {
	if (unlink_file (afterfile) < 0)
	    error (0, errno, "cannot remove %s", afterfile);
	free (afterfile);
    }
    if (outfile != NULL)
    {
	if (unlink_file (outfile) < 0)
	    error (0, errno, "cannot remove %s", outfile);
	free (outfile);
    }
    noexec = save_noexec;

    return status;
}

/*
 * TRUE if there exists a symbolic tag "tag" in file.
 */
int 
RCS_exist_tag (rcs, tag)
    RCSNode *rcs;
    char *tag;
{

    assert (rcs != NULL);

    if (findnode (RCS_symbols (rcs), tag))
    return 1;
    return 0;

}

/*
 * TRUE if RCS revision number "rev" exists.
 * This includes magic branch revisions, not found in rcs->versions, 
 * but only in rcs->symbols, requiring a list walk to find them.
 * Take advantage of list walk callback function already used by 
 * RCS_delete_revs, above.
 */
int
RCS_exist_rev (rcs, rev)
    RCSNode *rcs;
    char *rev;
{

    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (findnode(rcs->versions, rev) != 0)
	return 1;

    if (walklist (RCS_symbols(rcs), findtag, rev) != 0)
	return 1;

    return 0;

}


/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */

struct line
{
    /* Text of this line.  Part of the same malloc'd block as the struct
       line itself (we probably should use the "struct hack" (char text[1])
       and save ourselves sizeof (char *) bytes).  Does not include \n;
       instead has_newline indicates the presence or absence of \n.  */
    char *text;
    /* Length of this line, not counting \n if has_newline is true.  */
    size_t len;
    /* Version in which it was introduced.  */
    RCSVers *vers;
    /* Nonzero if this line ends with \n.  This will always be true
       except possibly for the last line.  */
    int has_newline;
    /* Number of pointers to this struct line.  */
    int refcount;
};

struct linevector
{
    /* How many lines in use for this linevector?  */
    unsigned int nlines;
    /* How many lines allocated for this linevector?  */
    unsigned int lines_alloced;
    /* Pointer to array containing a pointer to each line.  */
    struct line **vector;
};

static void linevector_init PROTO ((struct linevector *));

/* Initialize *VEC to be a linevector with no lines.  */
static void
linevector_init (vec)
    struct linevector *vec;
{
    vec->lines_alloced = 0;
    vec->nlines = 0;
    vec->vector = NULL;
}

static int linevector_add PROTO ((struct linevector *vec, const char *text,
				  size_t len, RCSVers *vers,
				  unsigned int pos));

/* Given some text TEXT, add each of its lines to VEC before line POS
   (where line 0 is the first line).  The last line in TEXT may or may
   not be \n terminated.
   Set the version for each of the new lines to VERS.  This
   function returns non-zero for success.  It returns zero if the line
   number is out of range.

   Each of the lines in TEXT are copied to space which is managed with
   the linevector (and freed by linevector_free).  So the caller doesn't
   need to keep TEXT around after the call to this function.  */
static int
linevector_add (vec, text, len, vers, pos)
    struct linevector *vec;
    const char *text;
    size_t len;
    RCSVers *vers;
    unsigned int pos;
{
    const char *textend;
    unsigned int i;
    unsigned int nnew;
    const char *p;
    const char *nextline_text;
    size_t nextline_len;
    int nextline_newline;
    struct line *q;

    if (len == 0)
	return 1;

    textend = text + len;

    /* Count the number of lines we will need to add.  */
    nnew = 1;
    for (p = text; p < textend; ++p)
	if (*p == '\n' && p + 1 < textend)
	    ++nnew;

    /* Expand VEC->VECTOR if needed.  */
    if (vec->nlines + nnew >= vec->lines_alloced)
    {
	if (vec->lines_alloced == 0)
	    vec->lines_alloced = 10;
	while (vec->nlines + nnew >= vec->lines_alloced)
	    vec->lines_alloced *= 2;
	vec->vector = xrealloc (vec->vector,
				vec->lines_alloced * sizeof (*vec->vector));
    }

    /* Make room for the new lines in VEC->VECTOR.  */
    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)
	vec->vector[i] = vec->vector[i - nnew];

    if (pos > vec->nlines)
	return 0;

    /* Actually add the lines, to VEC->VECTOR.  */
    i = pos;
    nextline_text = text;
    nextline_newline = 0;
    for (p = text; p < textend; ++p)
	if (*p == '\n')
	{
	    nextline_newline = 1;
	    if (p + 1 == textend)
		/* If there are no characters beyond the last newline, we
		   don't consider it another line.  */
		break;
	    nextline_len = p - nextline_text;
	    q = (struct line *) xmalloc (sizeof (struct line) + nextline_len);
	    q->vers = vers;
	    q->text = (char *)q + sizeof (struct line);
	    q->len = nextline_len;
	    q->has_newline = nextline_newline;
	    q->refcount = 1;
	    memcpy (q->text, nextline_text, nextline_len);
	    vec->vector[i++] = q;

	    nextline_text = (char *)p + 1;
	    nextline_newline = 0;
	}
    nextline_len = p - nextline_text;
    q = (struct line *) xmalloc (sizeof (struct line) + nextline_len);
    q->vers = vers;
    q->text = (char *)q + sizeof (struct line);
    q->len = nextline_len;
    q->has_newline = nextline_newline;
    q->refcount = 1;
    memcpy (q->text, nextline_text, nextline_len);
    vec->vector[i] = q;

    vec->nlines += nnew;

    return 1;
}

static void linevector_delete PROTO ((struct linevector *, unsigned int,
				      unsigned int));

/* Remove NLINES lines from VEC at position POS (where line 0 is the
   first line).  */
static void
linevector_delete (vec, pos, nlines)
    struct linevector *vec;
    unsigned int pos;
    unsigned int nlines;
{
    unsigned int i;
    unsigned int last;

    last = vec->nlines - nlines;
    for (i = pos; i < pos + nlines; ++i)
    {
	if (--vec->vector[i]->refcount == 0)
	    free (vec->vector[i]);
    }
    for (i = pos; i < last; ++i)
	vec->vector[i] = vec->vector[i + nlines];
    vec->nlines -= nlines;
}

static void linevector_copy PROTO ((struct linevector *, struct linevector *));

/* Copy FROM to TO, copying the vectors but not the lines pointed to.  */
static void
linevector_copy (to, from)
    struct linevector *to;
    struct linevector *from;
{
    unsigned int ln;

    for (ln = 0; ln < to->nlines; ++ln)
    {
	if (--to->vector[ln]->refcount == 0)
	    free (to->vector[ln]);
    }
    if (from->nlines > to->lines_alloced)
    {
	to->lines_alloced = from->nlines;
	to->vector = (struct line **)
	    xrealloc (to->vector, to->lines_alloced * sizeof (*to->vector));
    }
    memcpy (to->vector, from->vector,
	    from->nlines * sizeof (*to->vector));
    to->nlines = from->nlines;
    for (ln = 0; ln < to->nlines; ++ln)
	++to->vector[ln]->refcount;
}

static void linevector_free PROTO ((struct linevector *));

/* Free storage associated with linevector.  */
static void
linevector_free (vec)
    struct linevector *vec;
{
    unsigned int ln;

    if (vec->vector != NULL)
    {
	for (ln = 0; ln < vec->nlines; ++ln)
	    if (--vec->vector[ln]->refcount == 0)
		free (vec->vector[ln]);

	free (vec->vector);
    }
}

static char *month_printname PROTO ((char *));

/* Given a textual string giving the month (1-12), terminated with any
   character not recognized by atoi, return the 3 character name to
   print it with.  I do not think it is a good idea to change these
   strings based on the locale; they are standard abbreviations (for
   example in rfc822 mail messages) which should be widely understood.
   Returns a pointer into static readonly storage.  */
static char *
month_printname (month)
    char *month;
{
    static const char *const months[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    int mnum;

    mnum = atoi (month);
    if (mnum < 1 || mnum > 12)
	return "???";
    return (char *)months[mnum - 1];
}

static int
apply_rcs_changes PROTO ((struct linevector *, const char *, size_t,
			  const char *, RCSVers *, RCSVers *));

/* Apply changes to the line vector LINES.  DIFFBUF is a buffer of
   length DIFFLEN holding the change text from an RCS file (the output
   of diff -n).  NAME is used in error messages.  The VERS field of
   any line added is set to ADDVERS.  The VERS field of any line
   deleted is set to DELVERS, unless DELVERS is NULL, in which case
   the VERS field of deleted lines is unchanged.  The function returns
   non-zero if the change text is applied successfully.  It returns
   zero if the change text does not appear to apply to LINES (e.g., a
   line number is invalid).  If the change text is improperly
   formatted (e.g., it is not the output of diff -n), the function
   calls error with a status of 1, causing the program to exit.  */

static int
apply_rcs_changes (lines, diffbuf, difflen, name, addvers, delvers)
     struct linevector *lines;
     const char *diffbuf;
     size_t difflen;
     const char *name;
     RCSVers *addvers;
     RCSVers *delvers;
{
    const char *p;
    const char *q;
    int op;
    /* The RCS format throws us for a loop in that the deltafrags (if
       we define a deltafrag as an add or a delete) need to be applied
       in reverse order.  So we stick them into a linked list.  */
    struct deltafrag {
	enum {FRAG_ADD, FRAG_DELETE} type;
	unsigned long pos;
	unsigned long nlines;
	const char *new_lines;
	size_t len;
	struct deltafrag *next;
    };
    struct deltafrag *dfhead;
    struct deltafrag *df;

    dfhead = NULL;
    for (p = diffbuf; p != NULL && p < diffbuf + difflen; )
    {
	op = *p++;
	if (op != 'a' && op != 'd')
	    /* Can't just skip over the deltafrag, because the value
	       of op determines the syntax.  */
	    error (1, 0, "unrecognized operation '\\x%x' in %s",
		   op, name);
	df = (struct deltafrag *) xmalloc (sizeof (struct deltafrag));
	df->next = dfhead;
	dfhead = df;
	df->pos = strtoul (p, (char **) &q, 10);

	if (p == q)
	    error (1, 0, "number expected in %s", name);
	p = q;
	if (*p++ != ' ')
	    error (1, 0, "space expected in %s", name);
	df->nlines = strtoul (p, (char **) &q, 10);
	if (p == q)
	    error (1, 0, "number expected in %s", name);
	p = q;
	if (*p++ != '\012')
	    error (1, 0, "linefeed expected in %s", name);

	if (op == 'a')
	{
	    unsigned int i;

	    df->type = FRAG_ADD;
	    i = df->nlines;
	    /* The text we want is the number of lines specified, or
	       until the end of the value, whichever comes first (it
	       will be the former except in the case where we are
	       adding a line which does not end in newline).  */
	    for (q = p; i != 0; ++q)
		if (*q == '\n')
		    --i;
		else if (q == diffbuf + difflen)
		{
		    if (i != 1)
			error (1, 0, "premature end of change in %s", name);
		    else
			break;
		}

	    /* Stash away a pointer to the text we are adding.  */
	    df->new_lines = p;
	    df->len = q - p;

	    p = q;
	}
	else
	{
	    /* Correct for the fact that line numbers in RCS files
	       start with 1.  */
	    --df->pos;

	    assert (op == 'd');
	    df->type = FRAG_DELETE;
	}
    }

    for (df = dfhead; df != NULL;)
    {
	unsigned int ln;

	switch (df->type)
	{
	case FRAG_ADD:
	    if (! linevector_add (lines, df->new_lines, df->len, addvers,
				  df->pos))
		return 0;
	    break;
	case FRAG_DELETE:
	    if (df->pos > lines->nlines
		|| df->pos + df->nlines > lines->nlines)
		return 0;
	    if (delvers != NULL)
		for (ln = df->pos; ln < df->pos + df->nlines; ++ln)
		    lines->vector[ln]->vers = delvers;
	    linevector_delete (lines, df->pos, df->nlines);
	    break;
	}
	df = df->next;
	free (dfhead);
	dfhead = df;
    }

    return 1;
}

/* Apply an RCS change text to a buffer.  The function name starts
   with rcs rather than RCS because this does not take an RCSNode
   argument.  NAME is used in error messages.  TEXTBUF is the text
   buffer to change, and TEXTLEN is the size.  DIFFBUF and DIFFLEN are
   the change buffer and size.  The new buffer is returned in *RETBUF
   and *RETLEN.  The new buffer is allocated by xmalloc.

   Return 1 for success.  On failure, call error and return 0.  */

int
rcs_change_text (name, textbuf, textlen, diffbuf, difflen, retbuf, retlen)
     const char *name;
     char *textbuf;
     size_t textlen;
     const char *diffbuf;
     size_t difflen;
     char **retbuf;
     size_t *retlen;
{
    struct linevector lines;
    int ret;

    *retbuf = NULL;
    *retlen = 0;

    linevector_init (&lines);

    if (! linevector_add (&lines, textbuf, textlen, NULL, 0))
	error (1, 0, "cannot initialize line vector");

    if (! apply_rcs_changes (&lines, diffbuf, difflen, name, NULL, NULL))
    {
	error (0, 0, "invalid change text in %s", name);
	ret = 0;
    }
    else
    {
	char *p;
	size_t n;
	unsigned int ln;

	n = 0;
	for (ln = 0; ln < lines.nlines; ++ln)
	    /* 1 for \n */
	    n += lines.vector[ln]->len + 1;

	p = xmalloc (n);
	*retbuf = p;

	for (ln = 0; ln < lines.nlines; ++ln)
	{
	    memcpy (p, lines.vector[ln]->text, lines.vector[ln]->len);
	    p += lines.vector[ln]->len;
	    if (lines.vector[ln]->has_newline)
		*p++ = '\n';
	}

	*retlen = p - *retbuf;
	assert (*retlen <= n);

	ret = 1;
    }

    linevector_free (&lines);

    return ret;
}

/* Walk the deltas in RCS to get to revision VERSION.

   If OP is RCS_ANNOTATE, then write annotations using cvs_output.

   If OP is RCS_FETCH, then put the contents of VERSION into a
   newly-malloc'd array and put a pointer to it in *TEXT.  Each line
   is \n terminated; the caller is responsible for converting text
   files if desired.  The total length is put in *LEN.

   If FP is non-NULL, it should be a file descriptor open to the file
   RCS with file position pointing to the deltas.  We close the file
   when we are done.

   If LOG is non-NULL, then *LOG is set to the log message of VERSION,
   and *LOGLEN is set to the length of the log message.

   On error, give a fatal error.  */

void
RCS_deltas (rcs, fp, rcsbuf, version, op, text, len, log, loglen)
    RCSNode *rcs;
    FILE *fp;
    struct rcsbuffer *rcsbuf;
    char *version;
    enum rcs_delta_op op;
    char **text;
    size_t *len;
    char **log;
    size_t *loglen;
{
    struct rcsbuffer rcsbuf_local;
    char *branchversion;
    char *cpversion;
    char *key;
    char *value;
    size_t vallen;
    RCSVers *vers;
    RCSVers *prev_vers;
    RCSVers *trunk_vers;
    char *next;
    int ishead, isnext, isversion, onbranch;
    Node *node;
    struct linevector headlines;
    struct linevector curlines;
    struct linevector trunklines;
    int foundhead;

    if (fp == NULL)
    {
	rcsbuf_cache_open (rcs, rcs->delta_pos, &fp, &rcsbuf_local);
	rcsbuf = &rcsbuf_local;
    }

    ishead = 1;
    vers = NULL;
    prev_vers = NULL;
    trunk_vers = NULL;
    next = NULL;
    onbranch = 0;
    foundhead = 0;

    linevector_init (&curlines);
    linevector_init (&headlines);
    linevector_init (&trunklines);

    /* We set BRANCHVERSION to the version we are currently looking
       for.  Initially, this is the version on the trunk from which
       VERSION branches off.  If VERSION is not a branch, then
       BRANCHVERSION is just VERSION.  */
    branchversion = xstrdup (version);
    cpversion = strchr (branchversion, '.');
    if (cpversion != NULL)
        cpversion = strchr (cpversion + 1, '.');
    if (cpversion != NULL)
        *cpversion = '\0';

    do {
	if (! rcsbuf_getrevnum (rcsbuf, &key))
	    error (1, 0, "unexpected EOF reading RCS file %s", rcs->path);

	if (next != NULL && ! STREQ (next, key))
	{
	    /* This is not the next version we need.  It is a branch
               version which we want to ignore.  */
	    isnext = 0;
	    isversion = 0;
	}
	else
	{
	    isnext = 1;

	    /* look up the revision */
	    node = findnode (rcs->versions, key);
	    if (node == NULL)
	        error (1, 0,
		       "mismatch in rcs file %s between deltas and deltatexts",
		       rcs->path);

	    /* Stash the previous version.  */
	    prev_vers = vers;

	    vers = (RCSVers *) node->data;
	    next = vers->next;

	    /* Compare key and trunkversion now, because key points to
	       storage controlled by rcsbuf_getkey.  */
	    if (STREQ (branchversion, key))
	        isversion = 1;
	    else
	        isversion = 0;
	}

	while (1)
	{
	    if (! rcsbuf_getkey (rcsbuf, &key, &value))
		error (1, 0, "%s does not appear to be a valid rcs file",
		       rcs->path);

	    if (log != NULL
		&& isversion
		&& STREQ (key, "log")
		&& STREQ (branchversion, version))
	    {
		*log = rcsbuf_valcopy (rcsbuf, value, 0, loglen);
	    }

	    if (STREQ (key, "text"))
	    {
		rcsbuf_valpolish (rcsbuf, value, 0, &vallen);
		if (ishead)
		{
		    if (! linevector_add (&curlines, value, vallen, NULL, 0))
			error (1, 0, "invalid rcs file %s", rcs->path);

		    ishead = 0;
		}
		else if (isnext)
		{
		    if (! apply_rcs_changes (&curlines, value, vallen,
					     rcs->path,
					     onbranch ? vers : NULL,
					     onbranch ? NULL : prev_vers))
			error (1, 0, "invalid change text in %s", rcs->path);
		}
		break;
	    }
	}

	if (isversion)
	{
	    /* This is either the version we want, or it is the
               branchpoint to the version we want.  */
	    if (STREQ (branchversion, version))
	    {
	        /* This is the version we want.  */
		linevector_copy (&headlines, &curlines);
		foundhead = 1;
		if (onbranch)
		{
		    /* We have found this version by tracking up a
                       branch.  Restore back to the lines we saved
                       when we left the trunk, and continue tracking
                       down the trunk.  */
		    onbranch = 0;
		    vers = trunk_vers;
		    next = vers->next;
		    linevector_copy (&curlines, &trunklines);
		    linevector_free (&trunklines);
		    linevector_init (&trunklines);
		}
	    }
	    else
	    {
	        Node *p;

	        /* We need to look up the branch.  */
	        onbranch = 1;

		if (numdots (branchversion) < 2)
		{
		    unsigned int ln;

		    /* We are leaving the trunk; save the current
                       lines so that we can restore them when we
                       continue tracking down the trunk.  */
		    trunk_vers = vers;
		    linevector_copy (&trunklines, &curlines);

		    /* Reset the version information we have
                       accumulated so far.  It only applies to the
                       changes from the head to this version.  */
		    for (ln = 0; ln < curlines.nlines; ++ln)
		        curlines.vector[ln]->vers = NULL;
		}

		/* The next version we want is the entry on
                   VERS->branches which matches this branch.  For
                   example, suppose VERSION is 1.21.4.3 and
                   BRANCHVERSION was 1.21.  Then we look for an entry
                   starting with "1.21.4" and we'll put it (probably
                   1.21.4.1) in NEXT.  We'll advance BRANCHVERSION by
                   two dots (in this example, to 1.21.4.3).  */

		if (vers->branches == NULL)
		    error (1, 0, "missing expected branches in %s",
			   rcs->path);
		*cpversion = '.';
		++cpversion;
		cpversion = strchr (cpversion, '.');
		if (cpversion == NULL)
		    error (1, 0, "version number confusion in %s",
			   rcs->path);
		for (p = vers->branches->list->next;
		     p != vers->branches->list;
		     p = p->next)
		    if (strncmp (p->key, branchversion,
				 cpversion - branchversion) == 0)
			break;
		if (p == vers->branches->list)
		    error (1, 0, "missing expected branch in %s",
			   rcs->path);

		next = p->key;

		cpversion = strchr (cpversion + 1, '.');
		if (cpversion != NULL)
		    *cpversion = '\0';
	    }
	}
	if (op == RCS_FETCH && foundhead)
	    break;
    } while (next != NULL);

    free (branchversion);

    rcsbuf_cache (rcs, rcsbuf);

    if (! foundhead)
        error (1, 0, "could not find desired version %s in %s",
	       version, rcs->path);

    /* Now print out or return the data we have just computed.  */
    switch (op)
    {
	case RCS_ANNOTATE:
	    {
		unsigned int ln;

		for (ln = 0; ln < headlines.nlines; ++ln)
		{
		    char *buf;
		    /* Period which separates year from month in date.  */
		    char *ym;
		    /* Period which separates month from day in date.  */
		    char *md;
		    RCSVers *prvers;

		    prvers = headlines.vector[ln]->vers;
		    if (prvers == NULL)
			prvers = vers;

		    buf = xmalloc (strlen (prvers->version) + 24);
		    sprintf (buf, "%-12s (%-8.8s ",
			     prvers->version,
			     prvers->author);
		    cvs_output (buf, 0);
		    free (buf);

		    /* Now output the date.  */
		    ym = strchr (prvers->date, '.');
		    if (ym == NULL)
		    {
			/* ??- is an ANSI trigraph.  The ANSI way to
			   avoid it is \? but some pre ANSI compilers
			   complain about the unrecognized escape
			   sequence.  Of course string concatenation
			   ("??" "-???") is also an ANSI-ism.  Testing
			   __STDC__ seems to be a can of worms, since
			   compilers do all kinds of things with it.  */
			cvs_output ("??", 0);
			cvs_output ("-???", 0);
			cvs_output ("-??", 0);
		    }
		    else
		    {
			md = strchr (ym + 1, '.');
			if (md == NULL)
			    cvs_output ("??", 0);
			else
			    cvs_output (md + 1, 2);

			cvs_output ("-", 1);
			cvs_output (month_printname (ym + 1), 0);
			cvs_output ("-", 1);
			/* Only output the last two digits of the year.  Our output
			   lines are long enough as it is without printing the
			   century.  */
			cvs_output (ym - 2, 2);
		    }
		    cvs_output ("): ", 0);
		    if (headlines.vector[ln]->len != 0)
			cvs_output (headlines.vector[ln]->text,
				    headlines.vector[ln]->len);
		    cvs_output ("\n", 1);
		}
	    }
	    break;
	case RCS_FETCH:
	    {
		char *p;
		size_t n;
		unsigned int ln;

		assert (text != NULL);
		assert (len != NULL);

		n = 0;
		for (ln = 0; ln < headlines.nlines; ++ln)
		    /* 1 for \n */
		    n += headlines.vector[ln]->len + 1;
		p = xmalloc (n);
		*text = p;
		for (ln = 0; ln < headlines.nlines; ++ln)
		{
		    memcpy (p, headlines.vector[ln]->text,
			    headlines.vector[ln]->len);
		    p += headlines.vector[ln]->len;
		    if (headlines.vector[ln]->has_newline)
			*p++ = '\n';
		}
		*len = p - *text;
		assert (*len <= n);
	    }
	    break;
    }

    linevector_free (&curlines);
    linevector_free (&headlines);
    linevector_free (&trunklines);

    return;
}

/* Read the information for a single delta from the RCS buffer RCSBUF,
   whose name is RCSFILE.  *KEYP and *VALP are either NULL, or the
   first key/value pair to read, as set by rcsbuf_getkey. Return NULL
   if there are no more deltas.  Store the key/value pair which
   terminated the read in *KEYP and *VALP.  */

static RCSVers *
getdelta (rcsbuf, rcsfile, keyp, valp)
    struct rcsbuffer *rcsbuf;
    char *rcsfile;
    char **keyp;
    char **valp;
{
    RCSVers *vnode;
    char *key, *value, *cp;
    Node *kv;

    /* Get revision number if it wasn't passed in. This uses
       rcsbuf_getkey because it doesn't croak when encountering
       unexpected input.  As a result, we have to play unholy games
       with `key' and `value'. */
    if (*keyp != NULL)
    {
	key = *keyp;
	value = *valp;
    }
    else
    {
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "%s: unexpected EOF", rcsfile);
    }

    /* Make sure that it is a revision number and not a cabbage 
       or something. */
    for (cp = key;
	 (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	 cp++)
	/* do nothing */ ;
    /* Note that when comparing with RCSDATE, we are not massaging
       VALUE from the string found in the RCS file.  This is OK since
       we know exactly what to expect.  */
    if (*cp != '\0' || strncmp (RCSDATE, value, (sizeof RCSDATE) - 1) != 0)
    {
	*keyp = key;
	*valp = value;
	return NULL;
    }

    vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (vnode, 0, sizeof (RCSVers));

    vnode->version = xstrdup (key);

    /* Grab the value of the date from value.  Note that we are not
       massaging VALUE from the string found in the RCS file.  */
    cp = value + (sizeof RCSDATE) - 1;	/* skip the "date" keyword */
    while (whitespace (*cp))		/* take space off front of value */
	cp++;

    vnode->date = xstrdup (cp);

    /* Get author field.  */
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (! STREQ (key, "author"))
	error (1, 0, "\
unable to parse %s; `author' not in the expected place", rcsfile);
    vnode->author = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);

    /* Get state field.  */
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (! STREQ (key, "state"))
	error (1, 0, "\
unable to parse %s; `state' not in the expected place", rcsfile);
    vnode->state = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);
    /* The value is optional, according to rcsfile(5).  */
    if (value != NULL && STREQ (value, "dead"))
    {
	vnode->dead = 1;
    }

    /* Note that "branches" and "next" are in fact mandatory, according
       to doc/RCSFILES.  */

    /* fill in the branch list (if any branches exist) */
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (STREQ (key, RCSDESC))
    {
	*keyp = key;
	*valp = value;
	/* Probably could/should be a fatal error.  */
	error (0, 0, "warning: 'branches' keyword missing from %s", rcsfile);
	return vnode;
    }
    if (value != (char *) NULL)
    {
	vnode->branches = getlist ();
	/* Note that we are not massaging VALUE from the string found
           in the RCS file.  */
	do_branches (vnode->branches, value);
    }

    /* fill in the next field if there is a next revision */
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (STREQ (key, RCSDESC))
    {
	*keyp = key;
	*valp = value;
	/* Probably could/should be a fatal error.  */
	error (0, 0, "warning: 'next' keyword missing from %s", rcsfile);
	return vnode;
    }
    if (value != (char *) NULL)
	vnode->next = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);

    /*
     * XXX - this is where we put the symbolic link stuff???
     * (into newphrases in the deltas).
     */
    while (1)
    {
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "unexpected end of file reading %s", rcsfile);

	/* The `desc' keyword is the end of the deltas. */
	if (strcmp (key, RCSDESC) == 0)
	    break;

#ifdef PRESERVE_PERMISSIONS_SUPPORT

	/* The `hardlinks' value is a group of words, which must
	   be parsed separately and added as a list to vnode->hardlinks. */
	if (strcmp (key, "hardlinks") == 0)
	{
	    char *word;

	    vnode->hardlinks = getlist();
	    while ((word = rcsbuf_valword (rcsbuf, &value)) != NULL)
	    {
		Node *n = getnode();
		n->key = word;
		addnode (vnode->hardlinks, n);
	    }
	    continue;
	}
#endif

	/* Enable use of repositories created by certain obsolete
	   versions of CVS.  This code should remain indefinately;
	   there is no procedure for converting old repositories, and
	   checking for it is harmless.  */
	if (STREQ (key, RCSDEAD))
	{
	    vnode->dead = 1;
	    if (vnode->state != NULL)
		free (vnode->state);
	    vnode->state = xstrdup ("dead");
	    continue;
	}
	/* if we have a new revision number, we're done with this delta */
	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
	    /* do nothing */ ;
	/* Note that when comparing with RCSDATE, we are not massaging
	   VALUE from the string found in the RCS file.  This is OK
	   since we know exactly what to expect.  */
	if (*cp == '\0' && strncmp (RCSDATE, value, strlen (RCSDATE)) == 0)
	    break;

	/* At this point, key and value represent a user-defined field
	   in the delta node. */
	if (vnode->other_delta == NULL)
	    vnode->other_delta = getlist ();
	kv = getnode ();
	kv->type = rcsbuf_valcmp (rcsbuf) ? RCSCMPFLD : RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = rcsbuf_valcopy (rcsbuf, value, kv->type == RCSFIELD,
				   (size_t *) NULL);
	if (addnode (vnode->other_delta, kv) != 0)
	{
	    /* Complaining about duplicate keys in newphrases seems
	       questionable, in that we don't know what they mean and
	       doc/RCSFILES has no prohibition on several newphrases
	       with the same key.  But we can't store more than one as
	       long as we store them in a List *.  */
	    error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    freenode (kv);
	}
    }

    /* Return the key which caused us to fail back to the caller.  */
    *keyp = key;
    *valp = value;

    return vnode;
}

static void
freedeltatext (d)
    Deltatext *d;
{
    if (d->version != NULL)
	free (d->version);
    if (d->log != NULL)
	free (d->log);
    if (d->text != NULL)
	free (d->text);
    if (d->other != (List *) NULL)
	dellist (&d->other);
    free (d);
}

static Deltatext *
RCS_getdeltatext (rcs, fp, rcsbuf)
    RCSNode *rcs;
    FILE *fp;
    struct rcsbuffer *rcsbuf;
{
    char *num;
    char *key, *value;
    Node *p;
    Deltatext *d;

    /* Get the revision number. */
    if (! rcsbuf_getrevnum (rcsbuf, &num))
    {
	/* If num == NULL, it means we reached EOF naturally.  That's
	   fine. */
	if (num == NULL)
	    return NULL;
	else
	    error (1, 0, "%s: unexpected EOF", rcs->path);
    }

    p = findnode (rcs->versions, num);
    if (p == NULL)
	error (1, 0, "mismatch in rcs file %s between deltas and deltatexts",
	       rcs->path);

    d = (Deltatext *) xmalloc (sizeof (Deltatext));
    d->version = xstrdup (num);

    /* Get the log message. */
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
	error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);
    if (! STREQ (key, "log"))
	error (1, 0, "%s, delta %s: expected `log', got `%s'",
	       rcs->path, num, key);
    d->log = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);

    /* Get random newphrases. */
    d->other = getlist();
    while (1)
    {
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);

	if (STREQ (key, "text"))
	    break;

	p = getnode();
	p->type = rcsbuf_valcmp (rcsbuf) ? RCSCMPFLD : RCSFIELD;
	p->key = xstrdup (key);
	p->data = rcsbuf_valcopy (rcsbuf, value, p->type == RCSFIELD,
				  (size_t *) NULL);
	if (addnode (d->other, p) < 0)
	{
	    error (0, 0, "warning: %s, delta %s: duplicate field `%s'",
		   rcs->path, num, key);
	}
    }

    /* Get the change text. We already know that this key is `text'. */
    d->text = rcsbuf_valcopy (rcsbuf, value, 0, &d->len);

    return d;
}

/* RCS output functions, for writing RCS format files from RCSNode
   structures.

   For most of this work, RCS 5.7 uses an `aprintf' function which aborts
   program upon error.  Instead, these functions check the output status
   of the stream right before closing it, and aborts if an error condition
   is found.  The RCS solution is probably the better one: it produces
   more overhead, but will produce a clearer diagnostic in the case of
   catastrophic error.  In either case, however, the repository will probably
   not get corrupted. */

static int
putsymbol_proc (symnode, fparg)
    Node *symnode;
    void *fparg;
{
    FILE *fp = (FILE *) fparg;

    /* A fiddly optimization: this code used to just call fprintf, but
       in an old repository with hundreds of tags this can get called
       hundreds of thousands of times when doing a cvs tag.  Since
       tagging is a relatively common operation, and using putc and
       fputs is just as comprehensible, the change is worthwhile.  */
    putc ('\n', fp);
    putc ('\t', fp);
    fputs (symnode->key, fp);
    putc (':', fp);
    fputs (symnode->data, fp);
    return 0;
}

static int putlock_proc PROTO ((Node *, void *));

/* putlock_proc is like putsymbol_proc, but key and data are reversed. */

static int
putlock_proc (symnode, fp)
    Node *symnode;
    void *fp;
{
    return fprintf ((FILE *) fp, "\n\t%s:%s", symnode->data, symnode->key);
}

static int
putrcsfield_proc (node, vfp)
    Node *node;
    void *vfp;
{
    FILE *fp = (FILE *) vfp;

    /* Some magic keys used internally by CVS start with `;'. Skip them. */
    if (node->key[0] == ';')
	return 0;

    fprintf (fp, "\n%s\t", node->key);
    if (node->data != NULL)
    {
	/* If the field's value contains evil characters,
	   it must be stringified. */
	/* FIXME: This does not quite get it right.  "7jk8f" is not a legal
	   value for a value in a newpharse, according to doc/RCSFILES,
	   because digits are not valid in an "id".  We might do OK by
	   always writing strings (enclosed in @@@@).  Would be nice to
	   explicitly mention this one way or another in doc/RCSFILES.
	   A case where we are wrong in a much more clear-cut way is that
	   we let through non-graphic characters such as whitespace and
	   control characters.  */

	if (node->type == RCSCMPFLD || strpbrk (node->data, "$,.:;@@") == NULL)
	    fputs (node->data, fp);
	else
	{
	    putc ('@@', fp);
	    expand_at_signs (node->data, (off_t) strlen (node->data), fp);
	    putc ('@@', fp);
	}
    }

    /* desc, log and text fields should not be terminated with semicolon;
       all other fields should be. */
    if (! STREQ (node->key, "desc") &&
	! STREQ (node->key, "log") &&
	! STREQ (node->key, "text"))
    {
	putc (';', fp);
    }
    return 0;
}

#ifdef PRESERVE_PERMISSIONS_SUPPORT

/* Save a filename in a `hardlinks' RCS field.  NODE->KEY will contain
   a full pathname, but currently only basenames are stored in the RCS
   node.  Assume that the filename includes nasty characters and
   @@-escape it. */

static int
puthardlink_proc (node, vfp)
    Node *node;
    void *vfp;
{
    FILE *fp = (FILE *) vfp;
    char *basename = strrchr (node->key, '/');

    if (basename == NULL)
	basename = node->key;
    else
	++basename;

    putc ('\t', fp);
    putc ('@@', fp);
    (void) expand_at_signs (basename, strlen (basename), fp);
    putc ('@@', fp);

    return 0;
}

#endif

/* Output the admin node for RCS into stream FP. */

static void
RCS_putadmin (rcs, fp)
    RCSNode *rcs;
    FILE *fp;
{
    fprintf (fp, "%s\t%s;\n", RCSHEAD, rcs->head ? rcs->head : "");
    if (rcs->branch)
	fprintf (fp, "%s\t%s;\n", RCSBRANCH, rcs->branch);

    fputs ("access", fp);
    if (rcs->access)
    {
	char *p, *s;
	s = xstrdup (rcs->access);
	for (p = strtok (s, " \n\t"); p != NULL; p = strtok (NULL, " \n\t"))
	    fprintf (fp, "\n\t%s", p);
	free (s);
    }
    fputs (";\n", fp);

    fputs (RCSSYMBOLS, fp);
    /* If we haven't had to convert the symbols to a list yet, don't
       force a conversion now; just write out the string.  */
    if (rcs->symbols == NULL && rcs->symbols_data != NULL)
    {
	fputs ("\n\t", fp);
	fputs (rcs->symbols_data, fp);
    }
    else
	walklist (RCS_symbols (rcs), putsymbol_proc, (void *) fp);
    fputs (";\n", fp);

    fputs ("locks", fp);
    if (rcs->locks_data)
	fprintf (fp, "\t%s", rcs->locks_data);
    else if (rcs->locks)
	walklist (rcs->locks, putlock_proc, (void *) fp);
    if (rcs->strict_locks)
	fprintf (fp, "; strict");
    fputs (";\n", fp);

    if (rcs->comment)
    {
	fprintf (fp, "comment\t@@");
	expand_at_signs (rcs->comment, (off_t) strlen (rcs->comment), fp);
	fputs ("@@;\n", fp);
    }
    if (rcs->expand && ! STREQ (rcs->expand, "kv"))
	fprintf (fp, "%s\t@@%s@@;\n", RCSEXPAND, rcs->expand);

    walklist (rcs->other, putrcsfield_proc, (void *) fp);

    putc ('\n', fp);
}

static void
putdelta (vers, fp)
    RCSVers *vers;
    FILE *fp;
{
    Node *bp, *start;

    /* Skip if no revision was supplied, or if it is outdated (cvs admin -o) */
    if (vers == NULL || vers->outdated)
	return;

    fprintf (fp, "\n%s\n%s\t%s;\t%s %s;\t%s %s;\nbranches",
	     vers->version,
	     RCSDATE, vers->date,
	     "author", vers->author,
	     "state", vers->state ? vers->state : "");

    if (vers->branches != NULL)
    {
	start = vers->branches->list;
	for (bp = start->next; bp != start; bp = bp->next)
	    fprintf (fp, "\n\t%s", bp->key);
    }

    fprintf (fp, ";\nnext\t%s;", vers->next ? vers->next : "");

    walklist (vers->other_delta, putrcsfield_proc, fp);

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (vers->hardlinks)
    {
	fprintf (fp, "\nhardlinks");
	walklist (vers->hardlinks, puthardlink_proc, fp);
	putc (';', fp);
    }
#endif
    putc ('\n', fp);
}

static void
RCS_putdtree (rcs, rev, fp)
    RCSNode *rcs;
    char *rev;
    FILE *fp;
{
    RCSVers *versp;
    Node *p, *branch;

    if (rev == NULL)
	return;

    /* Find the delta node for this revision. */
    p = findnode (rcs->versions, rev);
    if (p == NULL)
    {
        error (1, 0,
               "error parsing repository file %s, file may be corrupt.", 
               rcs->path);
    }
 
    versp = (RCSVers *) p->data;

    /* Print the delta node and recurse on its `next' node.  This prints
       the trunk.  If there are any branches printed on this revision,
       print those trunks as well. */
    putdelta (versp, fp);
    RCS_putdtree (rcs, versp->next, fp);
    if (versp->branches != NULL)
    {
	branch = versp->branches->list;
	for (p = branch->next; p != branch; p = p->next)
	    RCS_putdtree (rcs, p->key, fp);
    }
}

static void
RCS_putdesc (rcs, fp)
    RCSNode *rcs;
    FILE *fp;
{
    fprintf (fp, "\n\n%s\n@@", RCSDESC);
    if (rcs->desc != NULL)
    {
	off_t len = (off_t) strlen (rcs->desc);
	if (len > 0)
	{
	    expand_at_signs (rcs->desc, len, fp);
	    if (rcs->desc[len-1] != '\n')
		putc ('\n', fp);
	}
    }
    fputs ("@@\n", fp);
}

static void
putdeltatext (fp, d)
    FILE *fp;
    Deltatext *d;
{
    fprintf (fp, "\n\n%s\nlog\n@@", d->version);
    if (d->log != NULL)
    {
	int loglen = strlen (d->log);
	expand_at_signs (d->log, (off_t) loglen, fp);
	if (d->log[loglen-1] != '\n')
	    putc ('\n', fp);
    }
    putc ('@@', fp);

    walklist (d->other, putrcsfield_proc, fp);

    fputs ("\ntext\n@@", fp);
    if (d->text != NULL)
	expand_at_signs (d->text, (off_t) d->len, fp);
    fputs ("@@\n", fp);
}

/* TODO: the whole mechanism for updating deltas is kludgey... more
   sensible would be to supply all the necessary info in a `newdeltatext'
   field for RCSVers nodes. -twp */

/* Copy delta text nodes from FIN to FOUT.  If NEWDTEXT is non-NULL, it
   is a new delta text node, and should be added to the tree at the
   node whose revision number is INSERTPT.  (Note that trunk nodes are
   written in decreasing order, and branch nodes are written in
   increasing order.) */

static void
RCS_copydeltas (rcs, fin, rcsbufin, fout, newdtext, insertpt)
    RCSNode *rcs;
    FILE *fin;
    struct rcsbuffer *rcsbufin;
    FILE *fout;
    Deltatext *newdtext;
    char *insertpt;
{
    int actions;
    RCSVers *dadmin;
    Node *np;
    int insertbefore, found;
    char *bufrest;
    int nls;
    size_t buflen;
    char buf[8192];
    int got;

    /* Count the number of versions for which we have to do some
       special operation.  */
    actions = walklist (rcs->versions, count_delta_actions, (void *) NULL);

    /* Make a note of whether NEWDTEXT should be inserted
       before or after its INSERTPT. */
    insertbefore = (newdtext != NULL && numdots (newdtext->version) == 1);

    while (actions != 0 || newdtext != NULL)
    {
	Deltatext *dtext;

	dtext = RCS_getdeltatext (rcs, fin, rcsbufin);

	/* We shouldn't hit EOF here, because that would imply that
           some action was not taken, or that we could not insert
           NEWDTEXT.  */
	if (dtext == NULL)
	    error (1, 0, "internal error: EOF too early in RCS_copydeltas");

	found = (insertpt != NULL && STREQ (dtext->version, insertpt));
	if (found && insertbefore)
	{
	    putdeltatext (fout, newdtext);
	    newdtext = NULL;
	    insertpt = NULL;
	}

	np = findnode (rcs->versions, dtext->version);
	dadmin = (RCSVers *) np->data;

	/* If this revision has been outdated, just skip it. */
	if (dadmin->outdated)
	{
	    freedeltatext (dtext);
	    --actions;
	    continue;
	}
	   
	/* Update the change text for this delta.  New change text
	   data may come from cvs admin -m, cvs admin -o, or cvs ci. */
	if (dadmin->text != NULL)
	{
	    if (dadmin->text->log != NULL || dadmin->text->text != NULL)
		--actions;
	    if (dadmin->text->log != NULL)
	    {
		free (dtext->log);
		dtext->log = dadmin->text->log;
		dadmin->text->log = NULL;
	    }
	    if (dadmin->text->text != NULL)
	    {
		free (dtext->text);
		dtext->text = dadmin->text->text;
		dtext->len = dadmin->text->len;
		dadmin->text->text = NULL;
	    }
	}
	putdeltatext (fout, dtext);
	freedeltatext (dtext);

	if (found && !insertbefore)
	{
	    putdeltatext (fout, newdtext);
	    newdtext = NULL;
	    insertpt = NULL;
	}
    }

    /* Copy the rest of the file directly, without bothering to
       interpret it.  The caller will handle error checking by calling
       ferror.

       We just wrote a newline to the file, either in putdeltatext or
       in the caller.  However, we may not have read the corresponding
       newline from the file, because rcsbuf_getkey returns as soon as
       it finds the end of the '@@' string for the desc or text key.
       Therefore, we may read three newlines when we should really
       only write two, and we check for that case here.  This is not
       an semantically important issue; we only do it to make our RCS
       files look traditional.  */

    nls = 3;

    rcsbuf_get_buffered (rcsbufin, &bufrest, &buflen);
    if (buflen > 0)
    {
	if (bufrest[0] != '\n'
	    || strncmp (bufrest, "\n\n\n", buflen < 3 ? buflen : 3) != 0)
	{
	    nls = 0;
	}
	else
	{
	    if (buflen < 3)
		nls -= buflen;
	    else
	    {
		++bufrest;
		--buflen;
		nls = 0;
	    }
	}

	fwrite (bufrest, 1, buflen, fout);
    }

    while ((got = fread (buf, 1, sizeof buf, fin)) != 0)
    {
	if (nls > 0
	    && got >= nls
	    && buf[0] == '\n'
	    && strncmp (buf, "\n\n\n", nls) == 0)
	{
	    fwrite (buf + 1, 1, got - 1, fout);
	}
	else
	{
	    fwrite (buf, 1, got, fout);
	}

	nls = 0;
    }
}

/* A helper procedure for RCS_copydeltas.  This is called via walklist
   to count the number of RCS revisions for which some special action
   is required.  */

static int
count_delta_actions (np, ignore)
    Node *np;
    void *ignore;
{
    RCSVers *dadmin;

    dadmin = (RCSVers *) np->data;

    if (dadmin->outdated)
	return 1;

    if (dadmin->text != NULL
	&& (dadmin->text->log != NULL || dadmin->text->text != NULL))
    {
	return 1;
    }

    return 0;
}

/*
 * Clean up temporary files
 */
RETSIGTYPE
rcs_cleanup ()
{
    /* Note that the checks for existence_error are because we are
       called from a signal handler, so we don't know whether the
       files got created.  */

    /* FIXME: Do not perform buffered I/O from an interrupt handler like
       this (via error).  However, I'm leaving the error-calling code there
       in the hope that on the rare occasion the error call is actually made
       (e.g., a fluky I/O error or permissions problem prevents the deletion
       of a just-created file) reentrancy won't be an issue.  */
    if (rcs_lockfile != NULL)
    {
	char *tmp = rcs_lockfile;
	rcs_lockfile = NULL;
	if (rcs_lockfd >= 0)
	{
	    if (close (rcs_lockfd) != 0)
		error (0, errno, "error closing lock file %s", tmp);
	    rcs_lockfd = -1;
	}
	if (unlink_file (tmp) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", tmp);
    }
}

/* RCS_internal_lockfile and RCS_internal_unlockfile perform RCS-style
   locking on the specified RCSFILE: for a file called `foo,v', open
   for writing a file called `,foo,'.

   Note that we what do here is quite different from what RCS does.
   RCS creates the ,foo, file before it reads the RCS file (if it
   knows that it will be writing later), so that it actually serves as
   a lock.  We don't; instead we rely on CVS writelocks.  This means
   that if someone is running RCS on the file at the same time they
   are running CVS on it, they might lose (we read the file,
   then RCS writes it, then we write it, clobbering the
   changes made by RCS).  I believe the current sentiment about this
   is "well, don't do that".

   A concern has been expressed about whether adopting the RCS
   strategy would slow us down.  I don't think so, since we need to
   write the ,foo, file anyway (unless perhaps if O_EXCL is slower or
   something).

   These do not perform quite the same function as the RCS -l option
   for locking files: they are intended to prevent competing RCS
   processes from stomping all over each other's laundry.  Hence,
   they are `internal' locking functions.

   If there is an error, give a fatal error; if we return we always
   return a non-NULL value.  */

static FILE *
rcs_internal_lockfile (rcsfile)
    char *rcsfile;
{
    struct stat rstat;
    FILE *fp;
    static int first_call = 1;

    if (first_call)
    {
	first_call = 0;
	/* clean up if we get a signal */
#ifdef SIGABRT
	(void) SIG_register (SIGABRT, rcs_cleanup);
#endif
#ifdef SIGHUP
	(void) SIG_register (SIGHUP, rcs_cleanup);
#endif
#ifdef SIGINT
	(void) SIG_register (SIGINT, rcs_cleanup);
#endif
#ifdef SIGQUIT
	(void) SIG_register (SIGQUIT, rcs_cleanup);
#endif
#ifdef SIGPIPE
	(void) SIG_register (SIGPIPE, rcs_cleanup);
#endif
#ifdef SIGTERM
	(void) SIG_register (SIGTERM, rcs_cleanup);
#endif
    }

    /* Get the lock file name: `,file,' for RCS file `file,v'. */
    assert (rcs_lockfile == NULL);
    assert (rcs_lockfd < 0);
    rcs_lockfile = rcs_lockfilename (rcsfile);

    /* Use the existing RCS file mode, or read-only if this is a new
       file.  (Really, this is a lie -- if this is a new file,
       RCS_checkin uses the permissions from the working copy.  For
       actually creating the file, we use 0444 as a safe default mode.) */
    if (stat (rcsfile, &rstat) < 0)
    {
	if (existence_error (errno))
	    rstat.st_mode = S_IRUSR | S_IRGRP | S_IROTH;
	else
	    error (1, errno, "cannot stat %s", rcsfile);
    }

    /* Try to open exclusively.  POSIX.1 guarantees that O_EXCL|O_CREAT
       guarantees an exclusive open.  According to the RCS source, with
       NFS v2 we must also throw in O_TRUNC and use an open mask that makes
       the file unwriteable.  For extensive justification, see the comments for
       rcswriteopen() in rcsedit.c, in RCS 5.7.  This is kind of pointless
       in the CVS case; see comment at the start of this file concerning
       general ,foo, file strategy.

       There is some sentiment that with NFSv3 and such, that one can
       rely on O_EXCL these days.  This might be true for unix (I
       don't really know), but I am still pretty skeptical in the case
       of the non-unix systems.  */
    rcs_lockfd = open (rcs_lockfile,
		       OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
		       S_IRUSR | S_IRGRP | S_IROTH);

    if (rcs_lockfd < 0)
    {
	error (1, errno, "could not open lock file `%s'", rcs_lockfile);
    }

    /* Force the file permissions, and return a stream object. */
    /* Because we change the modes later, we don't worry about
       this in the non-HAVE_FCHMOD case.  */
#ifdef HAVE_FCHMOD
    if (fchmod (rcs_lockfd, rstat.st_mode) < 0)
	error (1, errno, "cannot change mode for %s", rcs_lockfile);
#endif
    fp = fdopen (rcs_lockfd, FOPEN_BINARY_WRITE);
    if (fp == NULL)
	error (1, errno, "cannot fdopen %s", rcs_lockfile);

    return fp;
}

static void
rcs_internal_unlockfile (fp, rcsfile)
    FILE *fp;
    char *rcsfile;
{
    assert (rcs_lockfile != NULL);
    assert (rcs_lockfd >= 0);

    /* Abort if we could not write everything successfully to LOCKFILE.
       This is not a great error-handling mechanism, but should prevent
       corrupting the repository. */

    if (ferror (fp))
	/* The only case in which using errno here would be meaningful
	   is if we happen to have left errno unmolested since the call
	   which produced the error (e.g. fprintf).  That is pretty
	   fragile even if it happens to sometimes be true.  The real
	   solution is to check each call to fprintf rather than waiting
	   until the end like this.  */
	error (1, 0, "error writing to lock file %s", rcs_lockfile);
    if (fclose (fp) == EOF)
	error (1, errno, "error closing lock file %s", rcs_lockfile);
    rcs_lockfd = -1;

    rename_file (rcs_lockfile, rcsfile);

    {
	/* Use a temporary to make sure there's no interval
	   (after rcs_lockfile has been freed but before it's set to NULL)
	   during which the signal handler's use of rcs_lockfile would
	   reference freed memory.  */
	char *tmp = rcs_lockfile;
	rcs_lockfile = NULL;
	free (tmp);
    }
}

static char *
rcs_lockfilename (rcsfile)
    char *rcsfile;
{
    char *lockfile, *lockp;
    char *rcsbase, *rcsp, *rcsend;
    int rcslen;

    /* Create the lockfile name. */
    rcslen = strlen (rcsfile);
    lockfile = (char *) xmalloc (rcslen + 10);
    rcsbase = last_component (rcsfile);
    rcsend = rcsfile + rcslen - sizeof(RCSEXT);
    for (lockp = lockfile, rcsp = rcsfile; rcsp < rcsbase; ++rcsp)
	*lockp++ = *rcsp;
    *lockp++ = ',';
    while (rcsp <= rcsend)
	*lockp++ = *rcsp++;
    *lockp++ = ',';
    *lockp = '\0';

    return lockfile;
}

/* Rewrite an RCS file.  The basic idea here is that the caller should
   first call RCS_reparsercsfile, then munge the data structures as
   desired (via RCS_delete_revs, RCS_settag, &c), then call RCS_rewrite.  */

void
RCS_rewrite (rcs, newdtext, insertpt)
    RCSNode *rcs;
    Deltatext *newdtext;
    char *insertpt;
{
    FILE *fin, *fout;
    struct rcsbuffer rcsbufin;

    if (noexec)
	return;

    /* Make sure we're operating on an actual file and not a symlink.  */
    resolve_symlink (&(rcs->path));

    fout = rcs_internal_lockfile (rcs->path);

    RCS_putadmin (rcs, fout);
    RCS_putdtree (rcs, rcs->head, fout);
    RCS_putdesc (rcs, fout);

    /* Open the original RCS file and seek to the first delta text. */
    rcsbuf_cache_open (rcs, rcs->delta_pos, &fin, &rcsbufin);

    /* Update delta_pos to the current position in the output file.
       Do NOT move these statements: they must be done after fin has
       been positioned at the old delta_pos, but before any delta
       texts have been written to fout. */
    rcs->delta_pos = ftell (fout);
    if (rcs->delta_pos == -1)
	error (1, errno, "cannot ftell in RCS file %s", rcs->path);

    RCS_copydeltas (rcs, fin, &rcsbufin, fout, newdtext, insertpt);

    /* We don't want to call rcsbuf_cache here, since we're about to
       delete the file.  */
    rcsbuf_close (&rcsbufin);
    if (ferror (fin))
	/* The only case in which using errno here would be meaningful
	   is if we happen to have left errno unmolested since the call
	   which produced the error (e.g. fread).  That is pretty
	   fragile even if it happens to sometimes be true.  The real
	   solution is to make sure that all the code which reads
	   from fin checks for errors itself (some does, some doesn't).  */
	error (0, 0, "warning: when closing RCS file `%s'", rcs->path);
    if (fclose (fin) < 0)
	error (0, errno, "warning: closing RCS file `%s'", rcs->path);

    rcs_internal_unlockfile (fout, rcs->path);
}

/* Abandon changes to an RCS file. */

void
RCS_abandon (rcs)
    RCSNode *rcs;
{
    free_rcsnode_contents (rcs);
    rcs->symbols_data = NULL;
    rcs->expand = NULL;
    rcs->access = NULL;
    rcs->locks_data = NULL;
    rcs->comment = NULL;
    rcs->desc = NULL;
    rcs->flags |= PARTIAL;
}

/*
 * For a given file with full pathname PATH and revision number REV,
 * produce a file label suitable for passing to diff.  The default
 * file label as used by RCS 5.7 looks like this:
 *
 *	FILENAME <tab> YYYY/MM/DD <sp> HH:MM:SS <tab> REVNUM
 *
 * The date and time used are the revision's last checkin date and time.
 * If REV is NULL, use the working copy's mtime instead.
 *
 * /dev/null is not statted but assumed to have been created on the Epoch.
 * At least using the POSIX.2 definition of patch, this should cause creation
 * of files on platforms such as Windoze where the null IO device isn't named
 * /dev/null to be parsed by patch properly.
 */
char *
make_file_label (path, rev, rcs)
    char *path;
    char *rev;
    RCSNode *rcs;
{
    char datebuf[MAXDATELEN + 1];
    char *label;

    label = (char *) xmalloc (strlen (path)
			      + (rev == NULL ? 0 : strlen (rev) + 1)
			      + MAXDATELEN
			      + 2);

    if (rev)
    {
	char date[MAXDATELEN + 1];
	/* revs cannot be attached to /dev/null ... duh. */
	assert (strcmp(DEVNULL, path));
	RCS_getrevtime (rcs, rev, datebuf, 0);
	(void) date_to_internet (date, datebuf);
	(void) sprintf (label, "-L%s\t%s\t%s", path, date, rev);
    }
    else
    {
	struct stat sb;
	struct tm *wm = NULL;

	if (strcmp(DEVNULL, path))
	{
	    char *file = last_component (path);
	    if (CVS_STAT (file, &sb) < 0)
		error (0, 1, "could not get info for `%s'", path);
	    else
		wm = gmtime (&sb.st_mtime);
	}
	if (wm == NULL)
	{
	    time_t t = 0;
	    wm = gmtime(&t);
	}

	(void) tm_to_internet (datebuf, wm);
	(void) sprintf (label, "-L%s\t%s", path, datebuf);
    }
    return label;
}
@


1.25
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@a4923 1
#ifdef notyet
a4924 1
#endif
@


1.24
log
@backport commitid support from newer CVS (with a different random id
generator)

writing a commitid is currently disabled

ok deraadt
@
text
@d3060 1
a3060 1
    revdate = get_date (tdate, (struct timeb *) NULL);
@


1.23
log
@Fix "cvs [update aborted]: out of memory; can not reallocate 5242880 bytes"
when checking out xenocara from a server running OpenBSD/amd64.

While processing RCS deltas, don't allocate twice as much memory as
needed when copying a line vector to a vector which has less lines.
Also, when switching back from a branch to trunk while searching an
RCS file for a revision, free the trunklines vector immediately after
lines saved in it have been copied back into the currentlines vector.
Somehow, these two changes together make the problem go away.

ok tobias@@, "this has been a serious annoyance" sthen@@, "sure" deraadt@@
@
text
@d4852 1
d4916 11
@


1.22
log
@Add a CVSROOT/config option "DisableMdocdate" (default:no) to turn off
the OpenBSD-specific Mdocdate expansion. This is useful to avoid
conflicts that arise between the server's expansion of Mdocdate and
the upstream code when maintaining forked OpenBSD derived code on an
OpenBSD CVS server.

"I must grudgingly agree that this is neccessary" deraadt@@
@
text
@d6761 1
a6761 4
	if (to->lines_alloced == 0)
	    to->lines_alloced = 10;
	while (from->nlines > to->lines_alloced)
	    to->lines_alloced *= 2;
d7184 2
@


1.21
log
@Febuary -> February
@
text
@d3631 2
@


1.20
log
@introduce Mdocdate tag, requested by jmc.
@
text
@d3406 1
a3406 1
    char *months[] = { "January", "Febuary", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
@


1.19
log
@Fixes from Derek Price, CAN-2005-0753. ok deraadt@@
@
text
@d12 1
d90 1
d3360 1
d3377 1
d3400 18
d3627 5
@


1.18
log
@Better fix for MALLOC_OPTIONS=J bug.  Something had problems with
returning a NULL label so now we just the epoch for the timestamp
if we cannot stat the file.  OK deraadt@@
@
text
@d2898 1
a2898 1
    if (!force_tag_match || RCS_datecmp (vers->date, date) <= 0)
d3971 1
a3971 1
    size_t loglen;
d7239 1
a7239 1
		    char buf[80];
d7250 1
d7255 1
@


1.18.6.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d2898 1
a2898 1
    if (vers && (!force_tag_match || RCS_datecmp (vers->date, date) <= 0))
d3971 1
a3971 1
    size_t loglen = 0;
d7239 1
a7239 1
		    char *buf;
a7249 1
		    buf = xmalloc (strlen (prvers->version) + 24);
a7253 1
		    free (buf);
@


1.18.2.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d2898 1
a2898 1
    if (vers && (!force_tag_match || RCS_datecmp (vers->date, date) <= 0))
d3971 1
a3971 1
    size_t loglen = 0;
d7239 1
a7239 1
		    char *buf;
a7249 1
		    buf = xmalloc (strlen (prvers->version) + 24);
a7253 1
		    free (buf);
@


1.18.4.1
log
@MFC:
Fix by otto@@

Fixes from Derek Price, CAN-2005-0753.
@
text
@d2898 1
a2898 1
    if (vers && (!force_tag_match || RCS_datecmp (vers->date, date) <= 0))
d3971 1
a3971 1
    size_t loglen = 0;
d7239 1
a7239 1
		    char *buf;
a7249 1
		    buf = xmalloc (strlen (prvers->version) + 24);
a7253 1
		    free (buf);
@


1.17
log
@Free buffer and set it to NULL on error lest it be used.
Fixes a crash when MALLOC_OPTIONS includes 'J' found by david@@.
@
text
@d8419 1
a8419 1
	else
d8425 2
a8426 10
	if (wm)
	{
	    (void) tm_to_internet (datebuf, wm);
	    (void) sprintf (label, "-L%s\t%s", path, datebuf);
	}
	else
	{
	    free(label);
	    label = NULL;
	}
@


1.16
log
@Allow a CVS tagname to be expanded during checkout, export and update to be
specified on the command line; ok niklas@@ pval@@
@
text
@d8430 5
@


1.15
log
@Merge local changes; work in progress
@
text
@d3511 2
a3512 1
    if (RCS_citag != NULL && keywords[KEYWORD_LOCALID].string == NULL) {
@


1.14
log
@Fixed version of Matthieu's change from revision 1.12
OK matthieu@@ && deraadt@@
@
text
@a94 5
enum rcs_delta_op {RCS_ANNOTATE, RCS_FETCH};
static void RCS_deltas PROTO ((RCSNode *, FILE *, struct rcsbuffer *, char *,
			       enum rcs_delta_op, char **, size_t *,
			       char **, size_t *));

d2124 1
a2124 1
 * exit with error.
d2203 2
a2204 3
    error (1, 0, "tag `%s' does not exist", tag);
    /* NOT REACHED -- error (1 ... ) does not return here */
    return 0;
d4154 1
a4154 1
	    if (unlink (dest) < 0 && !existence_error (errno))
d4324 1
a4324 1
	if (unlink (dest) < 0 && existence_error (errno))
d5267 1
a5267 1
	switch (diff_exec (workfile, tmpfile, diffopts, changefile))
d5315 1
a5315 1
	switch (diff_exec (tmpfile, workfile, diffopts, changefile))
d5695 1
a5695 1
     const char *rev;
d5714 2
a5715 18

    /* If rev is a branch number, lock the latest revision on that
       branch. I think that if the branch doesn't exist, it's
       okay to return 0 -- that just means that the branch is new,
       so we don't need to lock it anyway. -twp */
    else if (RCS_nodeisbranch (rcs, rev))
    {
	xrev = RCS_getbranch (rcs, (char *) rev, 1);
	if (xrev == NULL)
	{
	    if (!lock_quiet)
		error (0, 0, "%s: branch %s absent", rcs->path, rev);
	    return 1;
	}
    }

    if (xrev == NULL)
	xrev = xstrdup (rev);
d5720 1
a5720 1
    if (findnode (rcs->versions, xrev) == NULL)
d5723 1
a5723 1
	    error (0, 0, "%s: revision %s absent", rcs->path, xrev);
d5789 1
a5789 1
     const char *rev;
d5839 1
a5839 1
    else if (RCS_nodeisbranch (rcs, rev))
d5841 1
a5841 3
	/* If rev is a branch number, unlock the latest revision on that
	   branch. */
	xrev = RCS_getbranch (rcs, (char *) rev, 1);
d5844 1
a5844 1
	    error (0, 0, "%s: branch %s absent", rcs->path, rev);
a5847 3
    else
	/* REV is an exact revision number. */
	xrev = xstrdup (rev);
d6369 1
a6369 1
	    status = diff_exec (beforefile, afterfile, "-an", outfile);
d7008 1
a7008 1
static void
a8366 132

/* Annotate command.  In rcs.c for historical reasons (from back when
   what is now RCS_deltas was part of annotate_fileproc).  */

/* Options from the command line.  */

static int force_tag_match = 1;
static char *tag = NULL;
static char *date = NULL;

static int annotate_fileproc PROTO ((void *callerdat, struct file_info *));

static int
annotate_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    FILE *fp = NULL;
    struct rcsbuffer *rcsbufp = NULL;
    struct rcsbuffer rcsbuf;
    char *version;

    if (finfo->rcs == NULL)
        return (1);

    if (finfo->rcs->flags & PARTIAL)
    {
        RCS_reparsercsfile (finfo->rcs, &fp, &rcsbuf);
	rcsbufp = &rcsbuf;
    }

    version = RCS_getversion (finfo->rcs, tag, date, force_tag_match,
			      (int *) NULL);
    if (version == NULL)
        return 0;

    /* Distinguish output for various files if we are processing
       several files.  */
    cvs_outerr ("Annotations for ", 0);
    cvs_outerr (finfo->fullname, 0);
    cvs_outerr ("\n***************\n", 0);

    RCS_deltas (finfo->rcs, fp, rcsbufp, version, RCS_ANNOTATE, NULL,
		NULL, NULL, NULL);
    free (version);
    return 0;
}

static const char *const annotate_usage[] =
{
    "Usage: %s %s [-lRf] [-r rev|-D date] [files...]\n",
    "\t-l\tLocal directory only, no recursion.\n",
    "\t-R\tProcess directories recursively.\n",
    "\t-f\tUse head revision if tag/date not found.\n",
    "\t-r rev\tAnnotate file as of specified revision/tag.\n",
    "\t-D date\tAnnotate file as of specified date.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

/* Command to show the revision, date, and author where each line of a
   file was modified.  */

int
annotate (argc, argv)
    int argc;
    char **argv;
{
    int local = 0;
    int c;

    if (argc == -1)
	usage (annotate_usage);

    optind = 0;
    while ((c = getopt (argc, argv, "+lr:D:fR")) != -1)
    {
	switch (c)
	{
	    case 'l':
		local = 1;
		break;
	    case 'R':
		local = 0;
		break;
	    case 'r':
	        tag = optarg;
		break;
	    case 'D':
	        date = Make_Date (optarg);
		break;
	    case 'f':
	        force_tag_match = 0;
		break;
	    case '?':
	    default:
		usage (annotate_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	start_server ();
	ign_setup ();

	if (local)
	    send_arg ("-l");
	if (!force_tag_match)
	    send_arg ("-f");
	option_with_arg ("-r", tag);
	if (date)
	    client_senddate (date);
	send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
	send_file_names (argc, argv, SEND_EXPAND_WILD);
	send_to_server ("annotate\012", 0);
	return get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, 0, "");

    return start_recursion (annotate_fileproc, (FILESDONEPROC) NULL,
			    (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
			    argc, argv, local, W_LOCAL, 0, 1, (char *)NULL,
			    1);
}

d8376 5
d8388 1
a8388 1
    char datebuf[MAXDATELEN];
a8389 1
    char *file;
a8390 1
    file = last_component (path);
d8392 3
a8394 2
			      + (rev == NULL ? 0 : strlen (rev))
			      + 50);
d8398 3
a8400 1
	char *date;
d8402 1
a8402 1
	date = printable_date (datebuf);
a8403 1
	free (date);
d8408 1
a8408 1
	struct tm *wm;
d8410 8
a8417 2
	if (CVS_STAT (file, &sb) < 0)
	    error (0, 1, "could not get info for `%s'", path);
d8420 7
a8426 5
	    wm = gmtime (&sb.st_mtime);
	    (void) sprintf (datebuf, "%04d/%02d/%02d %02d:%02d:%02d",
			    wm->tm_year + 1900, wm->tm_mon + 1,
			    wm->tm_mday, wm->tm_hour,
			    wm->tm_min, wm->tm_sec);
@


1.13
log
@Nope, this makes cvs dump core
@
text
@d3549 1
a3549 1
	/* Look for the first non alphabetic character after the '$'.  */
d3551 4
a3554 2
	for (s = srch; s < send; s++)
	    if (! isalpha ((unsigned char) *s))
d3557 1
a3557 1
	/* If the first non alphabetic character is not '$' or ':',
@


1.12
log
@allow for local tags that  include numbers (like $XFree86$). First
character must be pure alpha though. Ok deraadt@@, tholo@@.
@
text
@d3549 1
a3549 1
	/* Look for the first non alphanumeric character after the '$'.  */
d3551 3
a3553 6
	if (isalpha(*srch)) /* first character of a tag should be a letter */
	    for (s = srch+1; s < send; s++)
		if (! isalnum ((unsigned char) *s))
		    break;
	else 
	    continue;
d3555 1
a3555 1
	/* If the first non alphanumeric character is not '$' or ':',
@


1.11
log
@Integrate local changes
@
text
@d3549 1
a3549 1
	/* Look for the first non alphabetic character after the '$'.  */
d3551 6
a3556 3
	for (s = srch; s < send; s++)
	    if (! isalpha ((unsigned char) *s))
		break;
d3558 1
a3558 1
	/* If the first non alphabetic character is not '$' or ':',
@


1.10
log
@Integrate local changes
@
text
@d63 1
d158 1
d547 1
a547 1
	kv->type = RCSFIELD;
d549 2
a550 1
	kv->data = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
d596 1
a596 3
	/* Don't need to rcsbuf_valcopy `value' because
	   getdelta already did that. */
	rdata->desc = xstrdup (value);
d752 1
a752 1
		kv->type = RCSFIELD;
d754 2
a755 1
		kv->data = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
d1033 3
d1291 1
a1291 1
           closing of the '@@' done in the default case above.  This
d1294 1
a1294 4
	if (rcsbuf->vlen != 0)
	    (*valp)[rcsbuf->vlen] = ' ';
	else
	    *valp = ptr;
d1336 1
a1336 406
	    rcsbuf->ptr = psemi + 1;

	    start = *valp;
	    while (psemi > start && my_whitespace (psemi[-1]))
		--psemi;
	    *psemi = '\0';

	    vlen = psemi - start;
	    if (vlen == 0)
		*valp = NULL;
	    rcsbuf->vlen = vlen;

	    return 1;
	}

	/* We found an '@@' string in the value.  We set
	   RCSBUF->AT_STRING, which means that we won't be able to
	   compress whitespace correctly for this type of value.
	   Since this type of value never arises in a normal RCS file,
	   this should not be a big deal.  It means that if anybody
	   adds a phrase which can have both an '@@' string and regular
	   text, they will have to handle whitespace compression
	   themselves.  */

	rcsbuf->at_string = 1;

	*pat = ' ';

	ptr = pat + 1;

	while (1)
	{
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	    {
		/* Note that we pass PTREND as the PTR value to
                   rcsbuff_fill, so that we will wind up setting PTR
                   to the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    if (pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ++rcsbuf->embedded_at;
	    ptr = pat + 2;
	}

	/* Here PAT points to the final '@@' in the string.  */

	*pat = ' ';

	ptr = pat + 1;
    }

#undef my_whitespace
}

/* TODO: Eliminate redundant code in rcsbuf_getkey, rcsbuf_getid,
   rcsbuf_getstring, rcsbuf_getword.  These last three functions were
   all created by hacking monstrous swaths of code from rcsbuf_getkey,
   and some engineering would make the code easier to read and
   maintain.

   Note that the extreme hair in rcsbuf_getkey is because profiling
   statistics show that it was worth it.

   We probably could be processing "hardlinks" by first calling
   rcsbuf_getkey, and breaking up the value afterwards; the code to
   break it up would not need to be hacked for speed.  This would
   remove the need for rcsbuf_getword, rcsbuf_getid, and
   rcsbuf_getstring, as the other calls are easy to remove.  */

/* Read an `id' (in the sense of rcsfile(5)) from RCSBUF, and store in
   IDP. */

static int
rcsbuf_getid (rcsbuf, idp)
    struct rcsbuffer *rcsbuf;
    char **idp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* We've found the start of the key.  */

    *idp = ptr;

    if (c != ';')
    {
	while (1)
	{
	    ++ptr;
	    if (ptr >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, idp, (char **) NULL);
		if (ptr == NULL)
		    error (1, 0, "EOF in key in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    c = *ptr;
	    if (c == ';' || my_whitespace (c))
		break;
	}
    }

    /* Here *IDP points to the id in the buffer, C is the character
       we found at the end of the key, and PTR points to the location in
       the buffer where we found C.  We may not set *PTR to \0, because
       it may overwrite a terminating semicolon.  The calling function
       must copy and terminate the id on its own. */

    rcsbuf->ptr = ptr;
    return 1;

#undef my_whitespace
}

/* Read an RCS @@-delimited string.  Store the result in STRP. */

static int
rcsbuf_getstring (rcsbuf, strp)
    struct rcsbuffer *rcsbuf;
    char **strp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char *pat;
    size_t vlen;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* PTR should now point to the start of a string. */
    if (c != '@@')
	error (1, 0, "expected @@-string at '\\x%x' in %s",
	       c, rcsbuf->filename);

    /* Optimize the common case of a value composed of a single
       '@@' string.  */

    rcsbuf->at_string = 1;
    
    ++ptr;
    
    *strp = ptr;
    
    while (1)
    {
	while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	{
	    /* Note that we pass PTREND as the PTR value to
	       rcsbuf_fill, so that we will wind up setting PTR to
	       the location corresponding to the old PTREND, so
	       that we don't search the same bytes again.  */
	    ptr = rcsbuf_fill (rcsbuf, ptrend, NULL, strp);
	    if (ptr == NULL)
		error (1, 0,
		       "EOF while looking for end of string in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	/* Handle the special case of an '@@' right at the end of
	   the known bytes.  */
	if (pat + 1 >= ptrend)
	{
	    /* Note that we pass PAT, not PTR, here.  */
	    pat = rcsbuf_fill (rcsbuf, pat, NULL, strp);
	    if (pat == NULL)
	    {
		/* EOF here is OK; it just means that the last
		   character of the file was an '@@' terminating a
		   value for a key type which does not require a
		   trailing ';'.  */
		pat = rcsbuf->ptrend - 1;
		
	    }
	    ptrend = rcsbuf->ptrend;
	    
	    /* Note that the value of PTR is bogus here.  This is
	       OK, because we don't use it.  */
	}
	
	if (pat + 1 >= ptrend || pat[1] != '@@')
	    break;
	
	/* We found an '@@' pair in the string.  Keep looking.  */
	++rcsbuf->embedded_at;
	ptr = pat + 2;
    }

    /* Here PAT points to the final '@@' in the string.  */
    
    *pat = '\0';
    
    vlen = pat - *strp;
    if (vlen == 0)
	*strp = NULL;
    rcsbuf->vlen = vlen;
    rcsbuf->ptr = pat + 1;
    
    return 1;

#undef my_whitespace
}

/* Read an RCS `word', in the sense of rcsfile(5) (an id, a num, a
   @@-delimited string, or `:').  Store the result in WORDP.  If a
   `;' is reached without reading any text, the result is NULL. */

static int
rcsbuf_getword (rcsbuf, wordp)
    struct rcsbuffer *rcsbuf;
    char **wordp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }
d1338 4
a1341 9
    /* If we have reached `;', there is no value. */
    if (c == ';')
    {
	*wordp = NULL;
	*ptr++ = '\0';
	rcsbuf->ptr = ptr;
	rcsbuf->vlen = 0;
	return 1;
    }
d1343 4
a1346 9
    /* PTR now points to the start of a value.  Find out whether it is
       a num, an id, a string or a colon. */
    if (c == ':')
    {
	*wordp = ptr++;
	rcsbuf->ptr = ptr;
	rcsbuf->vlen = 1;
	return 1;
    }
d1348 2
a1349 4
    if (c == '@@')
    {
	char *pat;
	size_t vlen;
d1351 8
a1358 2
	/* Optimize the common case of a value composed of a single
	   '@@' string.  */
d1361 1
d1363 1
a1363 3
	++ptr;

	*wordp = ptr;
d1370 2
a1371 2
                   rcsbuf_fill, so that we will wind up setting PTR to
                   the location corresponding to the old PTREND, so
d1373 1
a1373 1
		ptr = rcsbuf_fill (rcsbuf, ptrend, NULL, wordp);
d1385 4
a1388 11
		/* Note that we pass PAT, not PTR, here.  */
		pat = rcsbuf_fill (rcsbuf, pat, NULL, wordp);
		if (pat == NULL)
		{
		    /* EOF here is OK; it just means that the last
		       character of the file was an '@@' terminating a
		       value for a key type which does not require a
		       trailing ';'.  */
		    pat = rcsbuf->ptrend - 1;

		}
a1389 3

		/* Note that the value of PTR is bogus here.  This is
		   OK, because we don't use it.  */
d1392 1
a1392 1
	    if (pat + 1 >= ptrend || pat[1] != '@@')
a1395 1
	    ++rcsbuf->embedded_at;
d1400 1
a1400 53

	*pat = '\0';

	vlen = pat - *wordp;
	if (vlen == 0)
	    *wordp = NULL;
	rcsbuf->vlen = vlen;
	rcsbuf->ptr = pat + 1;

	return 1;
    }

    /* C is neither `:', `;' nor `@@', so it should be the start of a num
       or an id.  Make sure it is not another special character. */
    if (c == '$' || c == '.' || c == ',')
    {
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);
    }

    *wordp = ptr;
    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, wordp);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	/* Legitimate ID characters are digits, dots and any `graphic
           printing character that is not a special.' This test ought
	   to do the trick. */
	c = *ptr;
	if (isprint ((unsigned char) c) &&
	    c != ';' && c != '$' && c != ',' && c != '@@' && c != ':')
	{
	    ++ptr;
	    continue;
	}
	break;
    }

    /* PTR points to the last non-id character in this word, and C is
       the character in its memory cell.  Check to make sure that it
       is a legitimate word delimiter -- whitespace or semicolon. */
    if (c == ';' || my_whitespace (c))
    {
	rcsbuf->vlen = ptr - *wordp;
	rcsbuf->ptr = ptr;
	return 1;
a1402 5
    error (1, 0, "illegal special character in RCS field in %s",
	   rcsbuf->filename);
    /* Shut up compiler warnings.  */
    return 0;

d1509 2
d1536 10
d1569 1
a1569 1
    embedded_at = rcsbuf->embedded_at;
d1676 1
d1725 106
a2507 1
	free (version);
d2509 1
a2557 1
	free (version);
d2559 1
d3719 1
d3738 4
d4312 1
d4333 5
d4701 1
d4704 1
a4845 3
    /* Is the backend file a symbolic link?  Follow it and replace the
       filename with the destination of the link.  */

d4906 1
d4915 1
d4922 1
d4929 1
d4940 1
d4942 1
d4950 5
d4999 1
a4999 1
	nodep->key = xstrdup (newrev);
d5001 1
a5034 1
	freedeltatext (dtext);
d5046 2
a5047 1
	return 0;
d5143 7
d5374 1
a5374 1
    nodep->key = xstrdup (delta->version);
d5376 1
d5399 1
d5402 1
d5485 1
d5846 1
a5846 1
	    if (STREQ (p->data, user))
d5848 2
a5849 4
		if (lock != NULL)
		{
		    if (!unlock_quiet)
			error (0, 0, "\
d5851 1
a5851 3
		    return 1;
		}
		lock = p;
d5853 1
d5933 1
d5957 7
d5968 2
a5969 3
	if (p[ulen] == '\0' || p[ulen] == ' ')
	    if (strncmp (p, user, ulen) == 0)
		break;
d7368 1
a7368 1
    char *key, *value, *keybuf, *valbuf, *cp;
d7486 1
a7486 6
	int len;
	size_t valbuflen;

	key = NULL;

	if (! rcsbuf_getid (rcsbuf, &keybuf))
d7489 2
a7490 12
	/* rcsbuf_getid did not terminate the key, so copy it to new space. */
	len = rcsbuf->ptr - keybuf;
	key = (char *) xmalloc (sizeof(char) * (len + 1));
	strncpy (key, keybuf, len);
	key[len] = '\0';

	/* The `desc' keyword has only a single string value, with no
	   trailing semicolon, so it must be handled specially. */
	if (STREQ (key, RCSDESC))
	{
	    (void) rcsbuf_getstring (rcsbuf, &valbuf);
	    value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
a7491 1
	}
d7494 1
d7497 1
a7497 1
	if (STREQ (key, "hardlinks"))
d7499 1
a7499 1
	    Node *n;
d7502 1
a7502 1
	    while (1)
d7504 2
a7505 6
		if (! rcsbuf_getword (rcsbuf, &valbuf))
		    error (1, 0, "unexpected end of file reading %s", rcsfile);
		if (valbuf == NULL)
		    break;
		n = getnode();
		n->key = rcsbuf_valcopy (rcsbuf, valbuf, 1, NULL);
a7511 30
	/* Get the value. */
	value = NULL;
	while (1)
	{
	    if (! rcsbuf_getword (rcsbuf, &valbuf))
		error (1, 0, "unexpected end of file reading %s", rcsfile);
	    if (valbuf == NULL)
		break;

	    /* Copy valbuf to new space so we can polish it, then
	       append it to value. */

	    if (value == NULL)
	    {
		value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
	    }
	    else
	    {
		char *temp_value;

		temp_value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
		len = strlen (value);
		value = (char *) xrealloc
		    (value, sizeof(char) * (len + valbuflen + 2));
		value[len] = ' ';
		strcpy (value + len + 1, temp_value);
		free (temp_value);
	    }
	}

d7540 4
a7543 3
	kv->type = RCSFIELD;
	kv->key = key;
	kv->data = value;
d7628 1
a7628 1
	p->type = RCSFIELD;
d7630 2
a7631 1
	p->data = rcsbuf_valcopy (rcsbuf, value, 1, (size_t *) NULL);
d7712 2
a7713 2
	int n = strcspn (node->data, "$,.:;@@");
	if (node->data[n] == 0)
d7874 7
a7880 1
    assert (p != NULL);
d8001 1
d8121 1
a8121 1
static RETSIGTYPE
d8135 9
a8143 1
	if (unlink_file (rcs_lockfile) < 0
d8145 1
a8145 1
	    error (0, errno, "cannot remove %s", rcs_lockfile);
a8146 1
    rcs_lockfile = NULL;
a8179 1
    int fd;
d8188 3
d8210 1
d8237 3
a8239 3
    fd = open (rcs_lockfile,
	       OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
	       S_IRUSR | S_IRGRP | S_IROTH);
d8241 1
a8241 1
    if (fd < 0)
d8250 1
a8250 1
    if (fchmod (fd, rstat.st_mode) < 0)
d8253 1
a8253 1
    fp = fdopen (fd, FOPEN_BINARY_WRITE);
d8266 1
d8282 1
d8374 16
@


1.9
log
@Integrate local changes
@
text
@d156 2
d2525 10
d2558 1
a2558 1
    if (tag && (strcmp (tag, TAG_HEAD) == 0))
d4606 1
a4606 1
	    if (strcmp (devtype, "character") == 0)
d4608 1
a4608 1
	    else if (strcmp (devtype, "block") == 0)
d5169 3
a5244 1
	struct stat sb;
d5343 6
d5586 6
d6666 15
d6682 1
a6682 1
	status = RCS_checkout (rcs, NULL, after, NULL, NULL, afterfile,
d6710 1
a6710 1
	    status = RCS_checkout (rcs, NULL, before, NULL, NULL, beforefile,
d7166 1
a7166 1
	enum {ADD, DELETE} type;
d7206 1
a7206 1
	    df->type = ADD;
d7236 1
a7236 1
	    df->type = DELETE;
d7246 1
a7246 1
	case ADD:
d7251 1
a7251 1
	case DELETE:
d8480 24
a8527 4
   Note that we don't clean up the ,foo, file on ^C.  We probably should.
   I'm not completely sure whether RCS does or not (I looked at the code
   a little, and didn't find it).

a8534 1
    char *lockfile;
d8538 22
d8562 2
a8563 1
    lockfile = rcs_lockfilename (rcsfile);
d8589 2
a8590 1
    fd = open (lockfile, OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
d8595 1
a8595 1
	error (1, errno, "could not open lock file `%s'", lockfile);
d8603 1
a8603 1
	error (1, errno, "cannot change mode for %s", lockfile);
d8607 1
a8607 3
	error (1, errno, "cannot fdopen %s", lockfile);

    free (lockfile);
d8617 1
a8617 4
    char *lockfile;

    /* Get the lock file name: `,file,' for RCS file `file,v'. */
    lockfile = rcs_lockfilename (rcsfile);
d8630 1
a8630 1
	error (1, 0, "error writing to lock file %s", lockfile);
d8632 3
a8634 1
	error (1, errno, "error closing lock file %s", lockfile);
d8636 9
a8644 2
    rename_file (lockfile, rcsfile);
    free (lockfile);
d8768 2
a8769 2
    RCS_deltas (finfo->rcs, fp, rcsbufp, version, RCS_ANNOTATE, (char **) NULL,
		(size_t) NULL, (char **) NULL, (size_t *) NULL);
@


1.8
log
@Integrate local changes
@
text
@d156 18
d385 3
a387 1
	for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
d521 3
a523 1
	for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
d608 92
d788 2
a789 1
			    error (1, 0, "unrecognized operation '%c' in %s",
d1597 2
a1598 1
	error (1, 0, "expected @@-string at `%c' in %s", c, rcsbuf->filename);
d1855 1
a1855 1
	if (isprint (c) &&
d1923 1
a1923 1
    if (! isdigit (c) && c != '.')
d1925 2
a1926 1
	       "unexpected `%c' reading revision number in RCS file %s",
d1946 1
a1946 1
    while (isdigit (c) || c == '.');
d1949 2
a1950 1
	error (1, 0, "unexpected `%c' reading revision number in RCS file %s",
d2458 1
a2458 1
	if (! isdigit (tag[0]))
d2599 1
a2599 1
    if (!isdigit (tag[0]))
d2796 1
a2796 1
    if (isdigit (*rev))
d2823 1
a2823 1
    if (isdigit (*rev))
d3050 1
a3050 1
    if (isdigit (*rev))
d3222 17
a3238 2
    if (cur_rev != NULL && ! STREQ (cur_rev, "1.1"))
	return (xstrdup (cur_rev));
d3590 1
a3590 1
    if (isalpha (*tag))
d3594 1
a3594 1
	    if (!isgraph (*cp))
d3621 1
a3621 1
   if (!isdigit (last))
d3632 1
a3632 1
       if (!isdigit (c))
d3635 1
a3635 1
   if (!isdigit (last))
d3671 2
d3677 14
d3899 1
a3899 1
	    if (! isalpha (*s))
d4003 1
a4003 1
		if (name != NULL && ! isdigit (*name))
d4346 1
a4346 1
    assert (rev == NULL || isdigit (*rev));
d5180 5
a5184 31
    while (islink (rcs->path))
    {
	char *newname;
#ifdef HAVE_READLINK
	/* The clean thing to do is probably to have each filesubr.c
	   implement this (with an error if not supported by the
	   platform, in which case islink would presumably return 0).
	   But that would require editing each filesubr.c and so the
	   expedient hack seems to be looking at HAVE_READLINK.  */
	newname = xreadlink (rcs->path);
#else
	error (1, 0, "internal error: islink doesn't like readlink");
#endif
	
	if (isabsolute (newname))
	{
	    free (rcs->path);
	    rcs->path = newname;
	}
	else
	{
	    char *oldname = last_component (rcs->path);
	    int dirlen = oldname - rcs->path;
	    char *fullnewname = xmalloc (dirlen + strlen (newname) + 1);
	    strncpy (fullnewname, rcs->path, dirlen);
	    strcpy (fullnewname + dirlen, newname);
	    free (newname);
	    free (rcs->path);
	    rcs->path = fullnewname;
	}
    }
d5411 1
a5411 1
	assert (isdigit(*rev));
d6675 1
a6675 1
	    status = diff_exec (beforefile, afterfile, "-n", outfile);
d7142 2
a7143 1
	    error (1, 0, "unrecognized operation '%c' in %s", op, name);
d7669 3
a7671 1
    for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
d7855 3
a7857 1
	for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
d8599 3
d8754 1
a8755 1
	send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
d8791 1
a8791 1
    label = (char *) xmalloc (strlen (file)
d8800 1
a8800 1
	(void) sprintf (label, "-L%s\t%s\t%s", file, date, rev);
d8817 1
a8817 1
	    (void) sprintf (label, "-L%s\t%s", file, datebuf);
a8821 1

@


1.7
log
@Integrate local changes
@
text
@d1407 1
a1407 1
#undef my_whitespace;
d4481 3
d4553 1
d4555 10
d4566 6
a4571 1
		error (1, errno, "cannot open %s", workfile);
d4603 2
a4604 1
		    error (1, errno, "cannot write %s",
d4608 4
d4620 3
d4629 4
a4632 1
	    error (1, errno, "cannot close %s", workfile);
d4647 4
a4650 1
	    error (1, errno, "cannot close %s", workfile);
d4668 4
a4671 1
	    error (1, errno, "cannot close %s", sout);
a4680 5
    if (free_value)
	free (value);
    if (free_rev)
	free (rev);

d5007 1
d5028 35
d5337 1
d5383 17
a5399 5
	    error (0, 0, "%s: revision %s locked by %s",
		   rcs->path,
		   nodep->key, nodep->data);
	    status = 1;
	    goto checkin_done;
d5401 2
a5402 1
	delnode (nodep);
d6488 12
a6511 2
    assert (before != NULL || after != NULL);

d8290 1
a8290 1
int
d8629 3
@


1.6
log
@more careful scanf
@
text
@d84 3
d569 3
a571 1
	rdata->desc = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);
d807 3
d1292 474
d2360 83
d2912 35
d3474 34
d4170 2
a4171 2
    uid_t rcs_owner;
    gid_t rcs_group;
d4173 1
a4173 2
    int change_rcs_owner = 0;
    int change_rcs_group = 0;
a4324 1
	struct hardlink_info *hlinfo;
d4351 1
a4351 1
	    if (unlink (dest) < 0 && existence_error (errno))
d4373 2
a4374 2
	    info = findnode (vers->other_delta, "hardlinks");
	    if (info != NULL)
d4376 1
a4376 4
		char *links = xstrdup (info->data);
		char *working_dir = xgetwd();
		char *p, *file = NULL;
		Node *n, *uptodate_link;
d4380 5
a4384 1
		   this iteration. */
d4386 2
a4387 33
		for (p = strtok (links, " ");
		     p != NULL && uptodate_link == NULL;
		     p = strtok (NULL, " "))
		{
		    file = (char *)
			xmalloc (sizeof(char) *
				 (strlen(working_dir) + strlen(p) + 2));
		    sprintf (file, "%s/%s", working_dir, p);
		    n = lookup_file_by_inode (file);
		    if (n == NULL)
		    {
			if (strcmp (p, workfile) != 0)
			{
			    /* One of the files that WORKFILE should be
			       linked to is not even in the working directory.
			       The user should probably be warned. */
			    error (0, 0,
		"warning: %s should be hardlinked to %s, but is missing",
				   p, workfile);
			}
			free (file);
			continue;
		    }

		    /* hlinfo may be NULL if, for instance, a file is being
		       removed. */
		    hlinfo = (struct hardlink_info *) n->data;
		    if (hlinfo && hlinfo->checked_out)
			uptodate_link = n;
		    free (file);
		}
		free (links);
		free (working_dir);
d4391 1
a4391 1
		   invoked, then simply link workfile to that file.
d4393 3
a4395 4
		   If one of these conditions is not met, then we're
		   checking out workfile to a temp file or stdout, or
		   workfile is the first one in its hardlink group to be
		   checked out.  Either way we must continue with a full
d4400 3
d4419 1
a4419 1
	    change_rcs_owner = 1;
d4425 1
a4425 1
	    change_rcs_group = 1;
d4604 1
a4604 1
	if (change_rcs_owner || change_rcs_group)
d4607 1
a4607 1
		error (0, errno, "could not change file ownership on %s",
a5041 1
	char *fullpath;
d5096 1
a5096 19
	    fullpath = xgetwd();
	    fullpath = xrealloc (fullpath,
				 strlen(fullpath) + strlen(workfile) + 2);
	    sprintf (fullpath + strlen(fullpath), "/%s", workfile);

	    np = lookup_file_by_inode (fullpath);
	    if (np == NULL)
	    {
		error (1, 0, "lost information on %s's linkage", workfile);
	    }
	    else
	    {
		struct hardlink_info *hlinfo;
		hlinfo = (struct hardlink_info *) np->data;
		np = getnode();
		np->key = xstrdup ("hardlinks");
		np->data = xstrdup (hlinfo->links);
		(void) addnode (delta->other_delta, np);
	    }
d5588 3
d5782 5
a5786 2
   This is only required because the RCS ci program requires a lock.
   If we eventually do the checkin ourselves, this can become a no-op.  */
d5855 12
d5874 3
d6592 46
d7434 1
a7434 1
    char *key, *value, *cp;
d7498 2
a7499 1
    if (STREQ (value, "dead"))
d7550 6
a7555 1
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
d7558 8
d7567 3
d7571 53
d7652 2
a7653 2
	kv->key = xstrdup (key);
	kv->data = rcsbuf_valcopy (rcsbuf, value, 1, (size_t *) NULL);
d7843 30
d7958 8
a8294 2
    free (lockfile);

d8305 3
@


1.5
log
@Integrate local changes
@
text
@d3834 1
a3834 1
	    char devtype[16];
@


1.4
log
@Integrate local changes
@
text
@d14 3
d25 28
d55 21
a75 3
static int getrcskey PROTO((FILE * fp, char **keyp, char **valp,
			    size_t *lenp));
static void getrcsrev PROTO ((FILE *fp, char **revp));
d92 3
a94 2
static void RCS_deltas PROTO ((RCSNode *, FILE *, char *, enum rcs_delta_op,
			       char **, size_t *, char **, size_t *));
d97 4
a100 2
static RCSVers *getdelta PROTO ((FILE *, char *));
static Deltatext *RCS_getdeltatext PROTO ((RCSNode *, FILE *));
d109 3
a111 1
static void RCS_copydeltas PROTO ((RCSNode *, FILE *, FILE *, Deltatext *, char *));
d118 6
a152 1

d168 4
a180 1
	fclose (fp);
a200 1
	fclose (fp);
a228 1
	    fclose (fp);
a251 1
	    fclose (fp);
d283 4
a295 1
    fclose (fp);
d308 1
d317 1
a317 1
    /* Process HEAD and BRANCH keywords from the RCS header.  
d321 1
a321 1
       the rest of the header and the deltas.
d323 1
a323 9
       People often wonder whether this is inefficient, to open the
       file once here and once in RCS_reparsercsfile.  Well, it might
       help a little bit if we kept the file open (I haven't tried
       timing this myself), but basically the common case, which we
       want to optimize, is the one in which we call
       RCS_parsercsfile_i and not RCS_reparsercsfile (for example,
       "cvs update" on a lot of files most of which are unmodified).
       So making the case in which we call RCS_reparsercsfile fast is
       not as important.  */
d325 1
a325 1
    if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
d327 1
a327 1
    if (strcmp (key, RCSDESC) == 0)
d330 2
a331 2
    if (strcmp (RCSHEAD, key) == 0 && value != NULL)
	rdata->head = xstrdup (value);
d333 1
a333 1
    if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
d335 1
a335 1
    if (strcmp (key, RCSDESC) == 0)
d338 1
a338 1
    if (strcmp (RCSBRANCH, key) == 0 && value != NULL)
d342 1
a342 1
	rdata->branch = xstrdup (value);
d351 25
d377 3
d383 3
a385 12
    if (!really_quiet)
    {
	if (ferror(fp))
	{
	    error (1, 0, "error reading `%s'", rcsfile);
	}
	else
	{
	    error (0, 0, "`%s' does not appear to be a valid rcs file",
		   rcsfile);
	}
    }
d387 1
d399 1
a399 1
RCS_reparsercsfile (rdata, pfp)
d402 1
d406 1
a406 1

d409 1
a409 1
    long fpos;
d416 1
a416 3
    fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ);
    if (fp == NULL)
	error (1, 0, "unable to reopen `%s'", rcsfile);
d428 1
a430 2
	fpos = ftell (fp);

d432 1
a432 4

	/* if key is NULL here, then the file is missing some headers
	   or we had trouble reading the file. */
	if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
d434 1
a434 5
	    if (ferror(fp))
	    {
		error (1, 0, "error reading `%s'", rcsfile);
	    }
	    else
d441 7
a447 2
	/* Skip head and branch tags; we already have them. */
	if (strcmp (key, RCSHEAD) == 0 || strcmp (key, RCSBRANCH) == 0)
d449 1
d451 1
a451 1
	if (strcmp (key, "access") == 0)
d454 8
a461 1
		rdata->access = xstrdup (value);
d467 1
a467 1
	if (strcmp (key, "locks") == 0)
d470 7
a476 5
		rdata->locks_data = xstrdup (value);
	    fpos = ftell (fp);
	    if (getrcskey (fp, &key, &value, NULL) >= 0 &&
		strcmp (key, "strict") == 0 &&
		value == NULL)
d481 1
a481 1
		(void) fseek (fp, fpos, SEEK_SET);
d485 1
a485 1
	if (strcmp (RCSSYMBOLS, key) == 0)
d488 2
a489 7
		rdata->symbols_data = xstrdup(value);
	    continue;
	}

	if (strcmp (RCSEXPAND, key) == 0)
	{
	    rdata->expand = xstrdup (value);
d500 4
a503 1
	if (*cp == '\0' && strncmp (RCSDATE, value, strlen (RCSDATE)) == 0)
d506 1
a506 1
	if (strcmp (key, RCSDESC) == 0)
d509 1
a509 1
	if (strcmp (key, "comment") == 0)
d511 2
a512 1
	    rdata->comment = xstrdup (value);
d520 1
a520 1
	kv->data = xstrdup (value);
d531 3
a533 7
    /*
     * we got out of the loop, so we have the first part of the first
     * revision delta in our hand key=the revision and value=the date key and
     * its value
     */
    /* First, seek back to the start of the delta block. */
    (void) fseek (fp, fpos, SEEK_SET);
d535 1
a535 1
    while ((vnode = getdelta (fp, rcsfile)) != NULL)
d555 3
a557 2
    (void) getrcskey (fp, &key, &value, NULL);
    if (key != NULL && strcmp (key, RCSDESC) == 0)
d566 1
a566 1
	rdata->desc = xstrdup (value);
d569 1
a569 1
    rdata->delta_pos = ftell (fp);
d572 1
a572 4
    {
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", rcsfile);
    }
d576 1
d598 1
d600 1
a600 1
    RCS_reparsercsfile (rcs, &fp);
a603 1
	int c;
a604 1
	size_t vallen;
d610 1
a610 7
	do
	{
	    c = getc (fp);
	    if (c == EOF)
		break;
	} while (whitespace (c));
	if (c == EOF)
a611 2
	if (ungetc (c, fp) == EOF)
	    error (1, errno, "ungetc failed");
a612 1
	getrcsrev (fp, &key);
d621 1
a621 1
	while (getrcskey (fp, &key, &value, &vallen) >= 0)
d623 1
a623 1
	    if (strcmp (key, "text") != 0)
d632 1
a632 1
		kv->data = xstrdup (value);
d645 1
a645 1
	    if (strcmp (vnode->version, rcs->head) != 0)
d657 1
d660 1
d740 1
a740 2
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", rcs->path);
d835 14
d850 32
a881 21
/*
 * getrcskey - fill in the key and value from the rcs file the algorithm is
 *             as follows 
 *
 *    o skip whitespace
 *    o fill in key with everything up to next white 
 *      space or semicolon 
 *    o if key == "desc" then key and data are NULL and return -1 
 *    o if key wasn't terminated by a semicolon, skip white space and fill 
 *      in value with everything up to a semicolon 
 *    o compress all whitespace down to a single space 
 *    o if a word starts with @@, do funky rcs processing
 *    o strip whitespace off end of value or set value to NULL if it empty 
 *    o return 0 since we found something besides "desc"
 *
 * Sets *KEYP and *VALUEP to point to storage managed by the getrcskey
 * function; the contents are only valid until the next call to
 * getrcskey or getrcsrev.  If LENP is not NULL, this sets *LENP to
 * the length of *VALUEP; this is needed if the string might contain
 * binary data.
 */
d883 22
a904 4
static char *key = NULL;
static char *value = NULL;
static size_t keysize = 0;
static size_t valsize = 0;
d907 2
a908 2
getrcskey (fp, keyp, valp, lenp)
    FILE *fp;
a910 1
    size_t *lenp;
d912 40
a951 3
    char *cur, *max;
    int c;
    int just_string;
d953 1
a953 2
    if (lenp != NULL)
        *lenp = 0;
d955 1
a955 2
    /* skip leading whitespace */
    do
d957 1
a957 2
	c = getc (fp);
	if (c == EOF)
d959 4
a962 3
	    *keyp = (char *) NULL;
	    *valp = (char *) NULL;
	    return (-1);
a963 1
    } while (whitespace (c));
d965 12
a976 4
    /* fill in key */
    cur = key;
    max = key + keysize;
    while (!whitespace (c) && c != ';')
d978 1
a978 1
	if (cur >= max)
d980 12
a991 4
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
	    max = key + keysize;
d993 20
a1012 1
	*cur++ = c;
d1014 12
a1025 2
	c = getc (fp);
	if (c == EOF)
d1027 3
a1029 3
	    *keyp = (char *) NULL;
	    *valp = (char *) NULL;
	    return (-1);
d1031 3
d1035 7
a1041 1
    if (cur >= max)
d1043 67
a1109 4
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
	max = key + keysize;
a1110 1
    *cur = '\0';
d1112 4
a1115 2
    /* skip whitespace between key and val */
    while (whitespace (c))
d1117 6
a1122 2
	c = getc (fp);
	if (c == EOF)
d1124 4
a1127 3
	    *keyp = (char *) NULL;
	    *valp = (char *) NULL;
	    return (-1);
d1129 1
a1129 1
    } 
d1131 3
a1133 2
    /* if we ended key with a semicolon, there is no value */
    if (c == ';')
d1135 33
a1167 3
	*keyp = key;
	*valp = (char *) NULL;
	return (0);
d1170 6
a1175 7
    /* otherwise, there might be a value, so fill it in */
    cur = value;
    max = value + valsize;

    just_string = (strcmp (key, RCSDESC) == 0
		   || strcmp (key, "text") == 0
		   || strcmp (key, "log") == 0);
d1177 1
a1177 2
    /* process the value */
    for (;;)
d1179 24
a1202 2
	/* handle RCS "strings" */
	if (c == '@@') 
d1204 11
a1214 9
	    for (;;)
	    {
		c = getc (fp);
		if (c == EOF)
		{
		    *keyp = (char *) NULL;
		    *valp = (char *) NULL;
		    return (-1);
		}
d1216 4
a1219 13
		if (c == '@@')
		{
		    c = getc (fp);
		    if (c == EOF)
		    {
			*keyp = (char *) NULL;
			*valp = (char *) NULL;
			return (-1);
		    }
		    
		    if (c != '@@')
			break;
		}
d1221 1
a1221 9
		if (cur >= max)
		{
		    size_t curoff = cur - value;
		    expand_string (&value, &valsize, valsize + 1);
		    cur = value + curoff;
		    max = value + valsize;
		}
		*cur++ = c;
	    }
d1224 14
a1237 4
	/* The syntax for some key-value pairs is different; they
	   don't end with a semicolon.  */
	if (just_string)
	    break;
d1239 1
a1239 2
	/* compress whitespace down to a single space */
	if (whitespace (c))
d1241 13
a1253 9
	    do {
		c = getc (fp);
		if (c == EOF)
		{
		    *keyp = (char *) NULL;
		    *valp = (char *) NULL;
		    return (-1);
		}
	    } while (whitespace (c));
d1255 3
a1257 2
	    /* Do not include any trailing whitespace in the value. */
	    if (c != ';')
d1259 5
a1263 8
		if (cur >= max)
		{
		    size_t curoff = cur - value;
		    expand_string (&value, &valsize, valsize + 1);
		    cur = value + curoff;
		    max = value + valsize;
		}
		*cur++ = ' ';
d1265 7
d1274 33
a1306 3
	/* if we got a semi-colon we are done with the entire value */
	if (c == ';')
	    break;
d1308 3
a1310 1
	if (cur >= max)
d1312 4
a1315 4
	    size_t curoff = cur - value;
	    expand_string (&value, &valsize, valsize + 1);
	    cur = value + curoff;
	    max = value + valsize;
a1316 1
	*cur++ = c;
d1318 18
a1335 2
	c = getc (fp);
	if (c == EOF)
d1337 6
a1342 3
	    *keyp = (char *) NULL;
	    *valp = (char *) NULL;
	    return (-1);
d1344 100
d1446 20
a1465 2
    /* terminate the string */
    if (cur >= max)
d1467 3
a1469 4
	size_t curoff = cur - value;
	expand_string (&value, &valsize, valsize + 1);
	cur = value + curoff;
	max = value + valsize;
a1470 1
    *cur = '\0';
d1472 1
a1472 2
    /* if the string is empty, make it null */
    if (value && cur != value)
d1474 1
a1474 1
	*valp = value;
d1476 2
a1477 1
	    *lenp = cur - value;
d1479 2
a1480 4
    else
	*valp = NULL;
    *keyp = key;
    return (0);
d1483 3
a1485 3
/* Read an RCS revision number from FP.  Put a pointer to it in *REVP;
   it points to space managed by getrcsrev which is only good until
   the next call to getrcskey or getrcsrev.  */
d1487 5
a1491 3
getrcsrev (fp, revp)
    FILE *fp;
    char **revp;
d1493 10
a1502 3
    char *cur;
    char *max;
    int c;
d1504 1
a1504 3
    do {
	c = getc (fp);
	if (c == EOF)
d1506 16
a1521 5
	    /* FIXME: should be including filename in error message.  */
	    if (ferror (fp))
		error (1, errno, "cannot read rcs file");
	    else
		error (1, 0, "unexpected end of file reading rcs file");
a1522 1
    } while (whitespace (c));
d1524 1
a1524 3
    if (!(isdigit (c) || c == '.'))
	/* FIXME: should be including filename in error message.  */
	error (1, 0, "error reading rcs file; revision number expected");
d1526 4
a1529 3
    cur = key;
    max = key + keysize;
    while (isdigit (c) || c == '.')
d1531 14
a1544 1
	if (cur >= max)
d1546 29
a1574 4
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
	    max = key + keysize;
a1575 1
	*cur++ = c;
d1577 3
a1579 2
	c = getc (fp);
	if (c == EOF)
d1581 1
a1581 5
	    /* FIXME: should be including filename in error message.  */
	    if (ferror (fp))
		error (1, errno, "cannot read rcs file");
	    else
		error (1, 0, "unexpected end of file reading rcs file");
d1583 2
d1586 29
d1616 24
a1639 1
    if (cur >= max)
d1641 5
a1645 4
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
	max = key + keysize;
a1646 2
    *cur = '\0';
    *revp = key;
d1649 10
a1658 7
/* Like getrcsrev, but don't die on error.  Return the last character
   read (last call to getc, which may be EOF).  TODO: implement getrcsrev
   in terms of this function. */
static int
getrevnum (fp, revp)
    FILE *fp;
    char **revp;
d1660 18
a1677 3
    char *cur;
    char *max;
    int c;
d1679 1
a1679 6
    *revp = NULL;
    do {
	c = getc (fp);
	if (c == EOF)
	    return c;
    } while (whitespace (c));
d1681 1
a1681 2
    if (!(isdigit (c) || c == '.'))
	return c;
d1683 6
a1688 3
    cur = key;
    max = key + keysize;
    while (isdigit (c) || c == '.')
d1690 7
a1696 1
	if (cur >= max)
d1698 2
a1699 4
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
	    max = key + keysize;
d1701 1
a1701 6
	*cur = c;

	c = getc (fp);
	if (c == EOF)
	    break;
	cur++;
a1702 11

    if (cur >= max)
    {
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
	max = key + keysize;
    }
    *cur = '\0';
    *revp = key;
    return c;
d1705 1
d1905 1
a1905 1
	RCS_reparsercsfile (rcs, NULL);
d1908 1
a1908 1
    if (tag && (strcmp (tag, TAG_HEAD) == 0 || *tag == '\0'))
d2094 1
a2094 1
    if (strcmp (check_rev, p->data) == 0)
d2248 1
a2248 1
	RCS_reparsercsfile (rcs, NULL);
d2466 1
a2466 1
	RCS_reparsercsfile (rcs, NULL);
d2504 1
a2504 1
    if (cur_rev != NULL && strcmp (cur_rev, "1.1") != 0)
d2553 1
a2553 1
	RCS_reparsercsfile (rcs, NULL);
d2650 1
a2650 1
	RCS_reparsercsfile (rcs, NULL);
d2702 1
a2702 1
	RCS_reparsercsfile (rcs, NULL);
d2721 1
a2721 1
	RCS_reparsercsfile (rcs, NULL);
d2743 1
a2743 1
	RCS_reparsercsfile (rcs, NULL);
d2827 1
a2827 1
	    if (strcmp (arg, *cpp) == 0)
d2885 1
a2885 1
	RCS_reparsercsfile (rcs, NULL);
a2904 2
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3501 10
a3510 1
   file, typically "-kkv".  */
d3525 1
a3525 1
    FILE *fp;
d3527 1
d3534 12
a3545 1
    FILE *ofp;
d3582 1
a3582 1
    if (rev == NULL || strcmp (rev, rcs->head) == 0)
d3589 1
a3589 1
	    RCS_reparsercsfile (rcs, &fp);
d3591 1
a3591 7
	{
	    fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	    if (fp == NULL)
		error (1, 0, "unable to reopen `%s'", rcs->path);
	    if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file");
	}
d3594 7
a3600 10
	getrcsrev (fp, &key);
	while (getrcskey (fp, &key, &value, &len) >= 0)
	{
	    if (strcmp (key, "log") == 0)
	    {
		log = xmalloc (len);
		memcpy (log, value, len);
		loglen = len;
	    }
	    if (strcmp (key, "text") == 0)
d3615 2
d3620 1
a3620 2
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", rcs->path);
d3624 2
d3631 1
a3631 1
	    RCS_reparsercsfile (rcs, &fp);
d3639 1
d3645 1
d3648 2
a3649 1
	RCS_deltas (rcs, fp, rev, RCS_FETCH, &value, &len, &log, &loglen);
d3672 1
a3672 1
	    if (strcmp (*cpp, ouroptions) == 0)
d3686 166
a3853 1
	Node *p;
d3856 8
a3863 4
	p = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	if (p == NULL)
	    error (1, 0, "internal error: no revision information for %s",
		   rev == NULL ? rcs->head : rev);
d3865 1
a3865 1
	expand_keywords (rcs, (RCSVers *) p->data, nametag, log, loglen,
d3885 5
d3895 25
d3922 1
d3929 5
d3941 5
d3990 1
d3992 9
a4000 1
	if (workfile != NULL)
d4002 2
a4003 5
	    if (fclose (ofp) < 0)
		error (1, errno, "cannot close %s", workfile);
	    if (chmod (workfile,
		       sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH)) < 0)
		error (0, errno, "cannot change mode of file %s",
d4006 13
a4018 1
	else if (sout != RUN_TTY)
d4020 2
a4021 2
	    if (fclose (ofp) < 0)
		error (1, errno, "cannot close %s", sout);
d4024 16
d4088 1
a4088 1
	if (strcmp (p->data, user) == 0)
d4194 2
d4197 2
a4198 1
max_rev (const RCSVers *branchnode)
d4333 16
a4348 7
/* Check in to RCSFILE with revision REV (which must be greater than the
   largest revision) and message MESSAGE (which is checked for legality).
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If FLAGS &
   RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS & RCS_FLAGS_MODTIME,
   use the working file's modification time for the checkin time.
   WORKFILE is the working file to check in from, or NULL to use the usual
   RCS rules for deriving it from the RCSFILE.
a4353 4
/* TODO: RCS_checkin always unlinks the working file after checkin --
   then RCS_checkout checks it out again.  The logic should probably
   be reversed here. */

d4376 1
a4376 1
	RCS_reparsercsfile (rcs, NULL);
d4430 86
d4554 3
a4556 1
	get_file(workfile, workfile, "r", &dtext->text, &bufsize, &dtext->len);
d4565 3
d4579 6
a4584 6
	/* Removing the file here is an RCS user-visible behavior which
	   we almost surely do not need in the CVS case.  In fact, getting
	   rid of it should clean up link_file and friends in import.c.  */
	if (unlink_file (workfile) < 0)
	    /* FIXME-update-dir: message does not include update_dir.  */
	    error (0, errno, "cannot remove %s", workfile);
d4624 1
a4624 1
		 || strcmp (commitpt->version, rcs->head) == 0)
d4728 1
a4728 1
	if (strcmp (nodep->data, delta->author) != 0)
d4750 1
a4750 1
			     && strcmp (rcs->expand, "b") == 0)
d4756 1
a4756 1
	error (1, status < 0 ? errno : 0,
d4767 1
a4767 1
    diffopts = (rcs->expand != NULL && strcmp (rcs->expand, "b") == 0
d4771 1
a4771 1
    if (strcmp (commitpt->version, rcs->head) == 0 &&
d4778 1
a4778 1
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
d4814 1
a4814 1
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
d4851 1
a4851 1
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
d4875 1
a4875 1
	if (strcmp (commitpt->version, rcs->head) == 0)
d4905 6
a4910 6
    /* Removing the file here is an RCS user-visible behavior which
       we almost surely do not need in the CVS case.  In fact, getting
       rid of it should clean up link_file and friends in import.c.  */
    if (unlink_file (workfile) < 0)
	/* FIXME-update-dir: message does not include update_dir.  */
	error (1, errno, "cannot remove %s", workfile);
d4963 1
a4963 1
	binary = (strcmp (options, "-kb") == 0);
d4969 1
a4969 1
	if (expand != NULL && strcmp (expand, "b") == 0)
d4975 18
a4992 1
    fp = CVS_FOPEN (filename, binary ? FOPEN_BINARY_READ : "r");
d4994 7
a5000 11
    data.filename = filename;
    data.fp = fp;
    data.different = 0;

    retcode = RCS_checkout (rcs, (char *) NULL, rev, (char *) NULL,
			    options, RUN_TTY, cmp_file_buffer,
			    (void *) &data);

    /* If we have not yet found a difference, make sure that we are at
       the end of the file.  */
    if (! data.different)
d5002 24
a5025 2
	if (getc (fp) != EOF)
	    data.different = 1;
a5026 7

    fclose (fp);

    if (retcode != 0)
	return 1;

    return data.different;
d5094 1
a5094 1
	RCS_reparsercsfile (rcs, NULL);
d5098 2
a5099 2
    if (strcmp (tag, TAG_BASE) == 0
	|| strcmp (tag, TAG_HEAD) == 0)
d5153 1
a5153 1
	RCS_reparsercsfile (rcs, NULL);
d5176 4
a5179 1
	RCS_reparsercsfile (rcs, NULL);
d5183 1
a5183 1
    if (rev != NULL && rcs->branch != NULL && strcmp (rev, rcs->branch) == 0)
d5213 1
a5213 1
	RCS_reparsercsfile (rcs, NULL);
d5257 1
a5257 1
	if (strcmp (p->data, user) == 0)
d5309 1
a5309 1
	RCS_reparsercsfile (rcs, NULL);
d5336 1
a5336 1
	    if (strcmp (p->data, user) == 0)
d5375 1
a5375 1
    if (strcmp (lock->data, user) != 0)
d5411 1
a5411 1
	RCS_reparsercsfile (rcs, NULL);
d5420 1
a5420 1
	    if (strcmp (a, user) == 0)
d5444 1
a5444 1
	RCS_reparsercsfile (rcs, NULL);
d5475 1
a5475 1
	RCS_reparsercsfile (rcs, NULL);
d5491 1
a5491 1
    if (strcmp (node->data, rev) == 0)
d5584 1
a5584 1
	if (RCS_isbranch (rcs, rev1) && strcmp (rev1, rev2) == 0)
d5675 1
a5675 1
    else if (strcmp (rev1, branchpoint) != 0)
d5680 1
a5680 1
	while (revp->next != NULL && strcmp (revp->next, rev1) != 0)
d5729 1
a5729 1
	    found = (strcmp (revp->version, rev2) == 0);
a5825 7
	else if (status < 0)
	{
	    error (0, errno,
		   "cannot check out revision %s of %s", after, rcs->path);
	    goto delrev_done;
	}

a5852 6
	    else if (status < 0)
	    {
		error (0, errno, "cannot check out revision %s of %s",
		       before, rcs->path);
		goto delrev_done;
	    }
d5897 1
a5897 1
	 next != NULL && (after == NULL || strcmp (next, after) != 0);
d5922 1
a5922 1
	else if (strcmp (rev1, branchpoint) == 0)
d5928 1
a5928 1
		   strcmp (nodep->key, rev1) != 0)
d6448 1
a6448 1
RCS_deltas (rcs, fp, version, op, text, len, log, loglen)
d6451 1
d6459 1
a6468 1
    int n;
d6478 2
a6479 5
	fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	if (fp == NULL)
	    error (1, 0, "unable to reopen `%s'", rcs->path);
	if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
	    error (1, 0, "cannot fseek RCS file");
d6506 2
a6507 1
	getrcsrev (fp, &key);
d6509 1
a6509 1
	if (next != NULL && strcmp (next, key) != 0)
d6534 2
a6535 2
	       storage controlled by getrcskey.  */
	    if (strcmp (branchversion, key) == 0)
d6541 1
a6541 1
	while ((n = getrcskey (fp, &key, &value, &vallen)) >= 0)
d6543 4
d6549 2
a6550 2
		&& strcmp (key, "log") == 0
		&& strcmp (branchversion, version) == 0)
d6552 1
a6552 3
		*log = xmalloc (vallen);
		memcpy (*log, value, vallen);
		*loglen = vallen;
d6555 1
a6555 1
	    if (strcmp (key, "text") == 0)
d6557 1
a6575 2
	if (n < 0)
	    goto l_error;
d6581 1
a6581 1
	    if (strcmp (branchversion, version) == 0)
d6661 2
a6662 3
    
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", rcs->path);
a6765 7

  l_error:
    if (ferror (fp))
	error (1, errno, "cannot read %s", rcs->path);
    else
        error (1, 0, "%s does not appear to be a valid rcs file",
	       rcs->path);
d6768 6
d6775 2
a6776 2
getdelta (fp, rcsfile)
    FILE *fp;
d6778 2
a6782 1
    long fpos;
d6785 14
a6798 8
    vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (vnode, 0, sizeof (RCSVers));

    /* Get revision number. This uses getrcskey because it doesn't
       croak when encountering unexpected input.  As a result, we have
       to play unholy games with `key' and `value'. */
    fpos = ftell (fp);
    getrcskey (fp, &key, &value, NULL);
d6804 4
a6807 1
    if (*cp != '\0' || strncmp (RCSDATE, value, strlen (RCSDATE)) != 0)
d6809 2
a6810 2
	(void) fseek (fp, fpos, SEEK_SET);
	free (vnode);
d6813 4
d6819 3
a6821 2
    /* grab the value of the date from value */
    cp = value + strlen (RCSDATE);/* skip the "date" keyword */
d6828 5
a6832 3
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be using errno in case of ferror.  */
    if (key == NULL || strcmp (key, "author") != 0)
d6834 2
a6835 2
unable to parse rcs file; `author' not in the expected place");
    vnode->author = xstrdup (value);
d6838 5
a6842 3
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be using errno in case of ferror.  */
    if (key == NULL || strcmp (key, "state") != 0)
d6844 3
a6846 3
unable to parse rcs file; `state' not in the expected place");
    vnode->state = xstrdup (value);
    if (strcmp (value, "dead") == 0)
d6852 1
a6852 2
       to doc/RCSFILES.  We perhaps should be giving an error if they
       are not there.  */
d6855 5
a6859 4
    fpos = ftell (fp);
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be handling various error conditions better.  */
    if (key != NULL && strcmp (key, RCSDESC) == 0)
d6861 4
a6864 1
	(void) fseek (fp, fpos, SEEK_SET);
d6870 2
d6876 5
a6880 4
    fpos = ftell (fp);
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be handling various error conditions better.  */
    if (key != NULL && strcmp (key, RCSDESC) == 0)
d6882 4
a6885 1
	(void) fseek (fp, fpos, SEEK_SET);
d6889 1
a6889 1
	vnode->next = xstrdup (value);
a6894 1
    /* FIXME: Does not correctly handle errors, e.g. from stdio.  */
d6897 2
a6898 5
	fpos = ftell (fp);
	if (getrcskey (fp, &key, &value, NULL) < 0)
	    break;

	assert (key != NULL);
d6900 1
a6900 1
	if (strcmp (key, RCSDESC) == 0)
d6907 1
a6907 1
	if (strcmp(key, RCSDEAD) == 0)
d6918 3
d6931 1
a6931 1
	kv->data = xstrdup (value);
d6943 1
a6943 1
     }
d6945 3
a6947 3
    /* We got here because we read beyond the end of a delta.  Seek back
       to the beginning of the erroneous read. */
    (void) fseek (fp, fpos, SEEK_SET);
d6968 1
a6968 1
RCS_getdeltatext (rcs, fp)
d6971 1
a6974 1
    int n;
a6976 1
    size_t textlen;
d6979 1
a6979 4
    n = getrevnum (fp, &num);
    if (ferror (fp))
	error (1, errno, "%s: cannot read", rcs->path);
    if (n == EOF)
d6981 2
a6982 2
	/* If n == EOF and num == NULL, it means we reached EOF
	   naturally.  That's fine. */
d6998 1
a6998 1
    if (getrcskey (fp, &key, &value, NULL) < 0)
d7000 1
a7000 1
    if (strcmp (key, "log") != 0)
d7003 1
a7003 1
    d->log = xstrdup (value);
d7007 1
a7007 3
    for (n = getrcskey (fp, &key, &value, &textlen);
	 n >= 0 && strcmp (key, "text") != 0;
	 n = getrcskey (fp, &key, &value, &textlen))
d7009 6
d7018 1
a7018 1
	p->data = xstrdup (value);
a7024 2
    if (n < 0)
	error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);
d7027 1
a7027 3
    d->text = (char *) malloc (textlen + 1);
    d->len = textlen;
    memcpy (d->text, value, textlen);
d7044 1
a7044 1
putsymbol_proc (symnode, fp)
d7046 1
a7046 1
    void *fp;
d7048 13
a7060 1
    return fprintf ((FILE *) fp, "\n\t%s:%s", symnode->key, symnode->data);
d7112 3
a7114 3
    if (strcmp (node->key, "desc") != 0 &&
	strcmp (node->key, "log") != 0 &&
	strcmp (node->key, "text") != 0)
d7144 9
a7152 1
    walklist (RCS_symbols(rcs), putsymbol_proc, (void *) fp);
d7170 1
a7170 1
    if (rcs->expand && strcmp (rcs->expand, "kv") != 0)
d7292 1
a7292 1
RCS_copydeltas (rcs, fin, fout, newdtext, insertpt)
d7295 1
d7300 1
a7300 1
    Deltatext *dtext;
d7304 9
d7318 1
a7318 2
    found = 0;
    while ((dtext = RCS_getdeltatext (rcs, fin)) != NULL)
d7320 11
a7330 1
	found = (insertpt != NULL && strcmp (dtext->version, insertpt) == 0);
d7332 1
d7334 3
d7343 2
d7346 1
d7352 2
d7372 1
d7374 81
d7456 2
a7457 1
    putc ('\n', fout);
d7565 6
d7614 1
d7626 1
a7626 4
    if ((fin = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ)) == NULL) 
	error (1, errno, "cannot open RCS file `%s' for reading", rcs->path);
    if (fseek (fin, rcs->delta_pos, SEEK_SET) < 0)
	error (1, errno, "cannot fseek in RCS file %s", rcs->path);
d7636 1
a7636 1
    RCS_copydeltas (rcs, fin, fout, newdtext, insertpt);
d7638 3
d7642 7
a7648 1
	error (0, errno, "warning: when closing RCS file `%s'", rcs->path);
d7673 2
d7681 4
a7684 1
        RCS_reparsercsfile (finfo->rcs, &fp);
d7697 1
a7697 1
    RCS_deltas (finfo->rcs, fp, version, RCS_ANNOTATE, (char **) NULL,
@


1.3
log
@Integrate local changes
@
text
@d5 1
a5 1
 * specified in the README file that comes with the CVS 1.4 kit.
d13 1
a22 1
static void RCS_reparsercsfile PROTO((RCSNode *, int, FILE **));
d30 1
d32 1
d46 18
d255 14
a268 4
     *
     * Most cvs operatations on the main branch don't need any more
     * information.  Those that do call XXX to completely parse the
     * RCS file.  */
a320 3
   If ALL is nonzero, remember all keywords and values.  Otherwise
   only keep the ones we will need.

d323 2
a324 2
static void
RCS_reparsercsfile (rdata, all, pfp)
a325 1
    int all;
d331 1
a331 1
    Node *q;
d333 1
a333 1
    int n;
d345 3
d356 2
d362 1
a362 2
	if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL
	    || strcmp (key, RCSDESC) == 0)
d375 29
d419 1
a419 1
	 * revision, we are done with the headers and are down to the
d427 19
a445 20
	/* We always save lock information, so that we can handle
           -kkvl correctly when checking out a file.  We don't use a
           special field for this information, since it will normally
           not be set for a CVS file.  */
	if (all || strcmp (key, "locks") == 0)
	{
	    Node *kv;

	    if (rdata->other == NULL)
		rdata->other = getlist ();
	    kv = getnode ();
	    kv->type = RCSFIELD;
	    kv->key = xstrdup (key);
	    kv->data = xstrdup (value);
	    if (addnode (rdata->other, kv) != 0)
	    {
		error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		       key, rcsfile);
		freenode (kv);
	    }
d456 4
a459 1
    for (;;)
a460 108
	char *valp;

        vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
	memset (vnode, 0, sizeof (RCSVers));

	/* fill in the version before we forget it */
	vnode->version = xstrdup (key);

	/* grab the value of the date from value */
	valp = value + strlen (RCSDATE);/* skip the "date" keyword */
	while (whitespace (*valp))		/* take space off front of value */
	    valp++;

	vnode->date = xstrdup (valp);

	/* Get author field.  */
	(void) getrcskey (fp, &key, &value, NULL);
	/* FIXME: should be using errno in case of ferror.  */
	if (key == NULL || strcmp (key, "author") != 0)
	    error (1, 0, "\
unable to parse rcs file; `author' not in the expected place");
	vnode->author = xstrdup (value);

	/* Get state field.  */
	(void) getrcskey (fp, &key, &value, NULL);
	/* FIXME: should be using errno in case of ferror.  */
	if (key == NULL || strcmp (key, "state") != 0)
	    error (1, 0, "\
unable to parse rcs file; `state' not in the expected place");
	vnode->state = xstrdup (value);
	if (strcmp (value, "dead") == 0)
	{
	    vnode->dead = 1;
	}

	/* fill in the branch list (if any branches exist) */
	(void) getrcskey (fp, &key, &value, NULL);
	/* FIXME: should be handling various error conditions better.  */
	if (key != NULL && strcmp (key, RCSDESC) == 0)
	    value = NULL;
	if (value != (char *) NULL)
	{
	    vnode->branches = getlist ();
	    do_branches (vnode->branches, value);
	}

	/* fill in the next field if there is a next revision */
	(void) getrcskey (fp, &key, &value, NULL);
	/* FIXME: should be handling various error conditions better.  */
	if (key != NULL && strcmp (key, RCSDESC) == 0)
	    value = NULL;
	if (value != (char *) NULL)
	    vnode->next = xstrdup (value);

	/*
	 * at this point, we skip any user defined fields XXX - this is where
	 * we put the symbolic link stuff???
	 */
	/* FIXME: Does not correctly handle errors, e.g. from stdio.  */
	while ((n = getrcskey (fp, &key, &value, NULL)) >= 0)
	{
	    assert (key != NULL);

	    if (strcmp (key, RCSDESC) == 0)
	    {
		n = -1;
		break;
	    }

	    /* Enable use of repositories created by certain obsolete
	       versions of CVS.  This code should remain indefinately;
	       there is no procedure for converting old repositories, and
	       checking for it is harmless.  */
	    if (strcmp(key, RCSDEAD) == 0)
	    {
		vnode->dead = 1;
		if (vnode->state != NULL)
		    free (vnode->state);
		vnode->state = xstrdup ("dead");
		continue;
	    }
	    /* if we have a revision, break and do it */
	    for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
		 /* do nothing */ ;
	    if (*cp == '\0' && strncmp (RCSDATE, value, strlen (RCSDATE)) == 0)
		break;

	    if (all)
	    {
		Node *kv;

		if (vnode->other == NULL)
		    vnode->other = getlist ();
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (key);
		kv->data = xstrdup (value);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcsfile);
		    freenode (kv);
		}
	    }
	}

a476 7

	/*
	 * if we left the loop because there were no more keys, we break out
	 * of the revision processing loop
	 */
	if (n < 0)
	    break;
d479 2
a480 1
    if (all && key != NULL && strcmp (key, RCSDESC) == 0)
d482 1
a482 9
	Node *kv;

	if (rdata->other == NULL)
	    rdata->other = getlist ();
	kv = getnode ();
	kv->type = RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = xstrdup (value);
	if (addnode (rdata->other, kv) != 0)
d487 1
a487 1
	    freenode (kv);
d489 1
a492 1
    rdata->flags &= ~NODELTA;
d524 1
a524 1
    RCS_reparsercsfile (rcs, 1, &fp);
d722 10
d734 3
a736 3
/*
 * rcsvers_delproc - free up an RCSVers type node
 */
d738 2
a739 2
rcsvers_delproc (p)
    Node *p;
a740 4
    RCSVers *rnode;

    rnode = (RCSVers *) p->data;

d753 4
d761 10
d774 2
a775 1
 *    o skip whitespace o fill in key with everything up to next white 
d941 2
a942 1
	    if (cur >= max)
d944 8
a951 4
		size_t curoff = cur - value;
		expand_string (&value, &valsize, valsize + 1);
		cur = value + curoff;
		max = value + valsize;
a952 1
	    *cur++ = ' ';
d1063 53
d1157 42
d1260 1
a1260 1
	if (! RCS_isbranch (rcs, tag))
d1294 2
d1315 1
a1315 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1547 2
d1639 2
a1640 1
 * return NULL or RCS_head depending on force_tag_match
d1658 1
a1658 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1757 78
d1837 2
a1838 1
 * branch, otherwise the real head
d1876 1
a1876 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1963 1
a1963 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1975 2
a1976 1
    /* if no branches list, return now */
d1990 5
a1994 3
	/* FIXME: This case would seem to imply that the RCS file is
           somehow invalid.  Should we give an error message?  */
	return (NULL);
d2060 1
a2060 1
	RCS_reparsercsfile (rcs, 0, NULL);
a2082 1
#ifdef HAVE_RCS5
a2085 5
#else
    (void) sprintf (tdate, "%d/%d/%d %d:%d:%d", ftm->tm_mon,
		    ftm->tm_mday, ftm->tm_year + 1900, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
#endif
a2094 1
#ifdef HAVE_RCS5
a2095 3
#else
	    ftm = localtime (&revdate);
#endif
d2106 19
d2131 1
a2131 1
	RCS_reparsercsfile (rcs, 0, NULL);
d2145 1
d2153 1
a2153 1
	RCS_reparsercsfile (rcs, 0, NULL);
d2226 1
a2232 5
#ifndef HAVE_RCS5
    error (1, 0, "%s %s: your version of RCS does not support the -k option",
	   program_name, command_name);
#endif

d2295 1
a2295 1
	RCS_reparsercsfile (rcs, 0, NULL);
d2316 1
a2316 1
	RCS_reparsercsfile (rcs, 0, NULL);
d2500 1
a2500 1
    if (expand == KFLAG_KVL && rcs->other != NULL)
d2502 5
a2506 1
	Node *p;
d2508 9
a2516 46
	p = findnode (rcs->other, "locks");
	if (p != NULL)
	{
	    char *cp;
	    size_t verlen;

	    /* The format of the locking information is
	         USER:VERSION USER:VERSION ...
	       If we find our version on the list, we set LOCKER to
	       the corresponding user name.  */

	    verlen = strlen (ver->version);
	    cp = p->data;
	    while ((cp = strstr (cp, ver->version)) != NULL)
	    {
		if (cp > p->data
		    && cp[-1] == ':'
		    && (cp[verlen] == '\0'
			|| whitespace (cp[verlen])))
		{
		    char *cpend;

		    --cp;
		    cpend = cp;
		    while (cp > p->data && ! whitespace (*cp))
			--cp;
		    locker = xmalloc (cpend - cp + 1);
		    memcpy (locker, cp, cpend - cp);
		    locker[cpend - cp] = '\0';
		    break;
		}

		++cp;
	    }
	}
    }

    /* RCS keywords look like $STRING$ or $STRING: VALUE$.  */
    srch = buf;
    srch_len = len;
    while ((srch_next = memchr (srch, '$', srch_len)) != NULL)
    {
	char *s, *send;
	size_t slen;
	const struct rcs_keyword *keyword;
	enum keyword kw;
a2978 6
	if (rcs->flags & NODELTA)
	{
	    free_rcsnode_contents (rcs);
	    rcs->flags |= PARTIAL;
	}

d2980 1
a2980 1
	    RCS_reparsercsfile (rcs, 0, &fp);
d3028 1
a3028 1
	    RCS_reparsercsfile (rcs, 0, &fp);
d3137 9
a3145 2
	    if (len > 0)
		cvs_output (value, len);
d3149 24
a3172 5
	    if (fwrite (value, 1, len, ofp) != len)
		error (1, errno, "cannot write %s",
		       (workfile != NULL
			? workfile
			: (sout != RUN_TTY ? sout : "stdout")));
d3199 788
d4113 5
a4117 1
    int ret;
d4132 27
a4158 35
    ret = RCS_exec_settag (rcs->path, tag, rev);
    if (ret != 0)
	return ret;

    /* If we have already parsed the RCS file, update the tag
       information.  If we have not yet parsed it (i.e., the PARTIAL
       flag is set), the new tag information will be read when and if
       we do parse it.  */
    if ((rcs->flags & PARTIAL) == 0)
    {
	List *symbols;
	Node *node;

	/* At this point rcs->symbol_data may not have been parsed.
	   Calling RCS_symbols will force it to be parsed into a list
	   which we can easily manipulate.  */
	symbols = RCS_symbols (rcs);
	if (symbols == NULL)
	{
	    symbols = getlist ();
	    rcs->symbols = symbols;
	}
	node = findnode (symbols, tag);
	if (node != NULL)
	{
	    free (node->data);
	    node->data = xstrdup (rev);
	}
	else
	{
	    node = getnode ();
	    node->key = xstrdup (tag);
	    node->data = xstrdup (rev);
	    (void) addnode (symbols, node);
	}
a4160 3
    /* Setting the tag will most likely have invalidated delta_pos.  */
    rcs->flags |= NODELTA;

d4164 3
a4166 3
/* Delete the symbolic tag TAG from the RCS file RCS.  NOERR is 1 to
   suppress errors--FIXME it would be better to avoid the errors or
   some cleaner solution.  */
d4169 1
a4169 1
RCS_deltag (rcs, tag, noerr)
a4171 1
    int noerr;
d4173 4
a4176 1
    int ret;
d4178 3
a4180 3
    ret = RCS_exec_deltag (rcs->path, tag, noerr);
    if (ret != 0)
	return ret;
d4182 3
a4184 21
    /* If we have already parsed the RCS file, update the tag
       information.  If we have not yet parsed it (i.e., the PARTIAL
       flag is set), the new tag information will be read when and if
       we do parse it.  */
    if ((rcs->flags & PARTIAL) == 0)
    {
	List *symbols;

	/* At this point rcs->symbol_data may not have been parsed.
	   Calling RCS_symbols will force it to be parsed into a list
	   which we can easily manipulate.  */
	symbols = RCS_symbols (rcs);
	if (symbols != NULL)
	{
	    Node *node;

	    node = findnode (symbols, tag);
	    if (node != NULL)
		delnode (node);
	}
    }
d4186 1
a4186 2
    /* Deleting the tag will most likely have invalidated delta_pos.  */
    rcs->flags |= NODELTA;
d4198 2
a4199 1
    int ret;
a4205 4
    ret = RCS_exec_setbranch (rcs->path, rev);
    if (ret != 0)
	return ret;

a4209 4
    /* Changing the branch will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;

d4213 1
a4213 2
/* Lock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  FIXME:
d4216 4
d4222 1
a4222 1
RCS_lock (rcs, rev, noerr)
d4225 1
a4225 1
     int noerr;
d4227 65
a4291 1
    int ret;
d4293 11
a4303 7
    ret = RCS_exec_lock (rcs->path, rev, noerr);
    if (ret != 0)
	return ret;

    /* Setting a lock will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;
d4308 1
a4308 2
/* Unlock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  FIXME:
d4310 5
a4314 1
   ourselves.  */
d4317 1
a4317 1
RCS_unlock (rcs, rev, noerr)
d4320 1
a4320 1
     int noerr;
d4322 72
a4393 1
    int ret;
d4395 13
a4407 7
    ret = RCS_exec_unlock (rcs->path, rev, noerr);
    if (ret != 0)
	return ret;

    /* Setting a lock will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;
d4409 8
a4418 2

/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */
d4420 73
a4492 4
/* Linked list of allocated blocks.  Seems kind of silly to
   reinvent the obstack wheel, and this isn't as nice as obstacks
   in some ways, but obstacks are pretty baroque.  */
struct allocblock
d4494 7
a4500 4
    char *text;
    struct allocblock *next;
};
struct allocblock *blocks;
d4502 1
a4502 1
static void *block_alloc PROTO ((size_t));
d4504 4
a4507 3
static void *
block_alloc (n)
    size_t n;
d4509 6
a4514 6
    struct allocblock *blk;
    blk = (struct allocblock *) xmalloc (sizeof (struct allocblock));
    blk->text = xmalloc (n);
    blk->next = blocks;
    blocks = blk;
    return blk->text;
d4517 18
a4534 1
static void block_free PROTO ((void));
d4536 6
a4541 2
static void
block_free ()
d4543 23
a4565 2
    struct allocblock *p;
    struct allocblock *q;
d4567 443
a5009 2
    p = blocks;
    while (p != NULL)
d5011 3
a5013 4
	free (p->text);
	q = p->next;
	free (p);
	p = q;
d5015 3
a5017 1
    blocks = NULL;
d5019 2
d5024 4
a5027 1
    /* Text of this line.  */
d5036 2
d5062 1
a5062 1
static int linevector_add PROTO ((struct linevector *vec, char *text,
d5068 2
a5069 3
   not be \n terminated.  All \n in TEXT are changed to \0 (FIXME: I
   don't think this is needed, or used, now that we have the ->len
   field).  Set the version for each of the new lines to VERS.  This
d5071 5
a5075 1
   number is out of range.  */
d5079 1
a5079 1
    char *text;
d5084 1
a5084 1
    char *textend;
d5087 5
a5091 2
    char *p;
    struct line *lines;
a5102 2
    /* Allocate the struct line's.  */
    lines = block_alloc (nnew * sizeof (struct line));
d5122 1
a5122 1
    /* Actually add the lines, to LINES and VEC->VECTOR.  */
d5124 2
a5125 4
    lines[0].text = text;
    lines[0].vers = vers;
    lines[0].has_newline = 0;
    vec->vector[i++] = &lines[0];
d5129 1
a5129 2
	    *p = '\0';
	    lines[i - pos - 1].has_newline = 1;
d5134 23
a5156 8
	    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
	    lines[i - pos].text = p + 1;
	    lines[i - pos].vers = vers;
	    lines[i - pos].has_newline = 0;
	    vec->vector[i] = &lines[i - pos];
	    ++i;
	}
    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
d5177 5
d5195 7
d5214 2
d5220 1
a5220 2
/* Free storage associated with linevector (that is, the vector but
   not the lines pointed to).  */
d5225 2
d5228 5
d5234 1
d5295 1
a5295 1
	char *new_lines;
d5348 2
a5349 3
	    /* Copy the text we are adding into allocated space.  */
	    df->new_lines = block_alloc (q - p);
	    memcpy (df->new_lines, p, q - p);
d5399 3
a5401 3
   and *RETLEN.  The new buffer is allocated by xmalloc.  The function
   changes the contents of TEXTBUF.  This function returns 1 for
   success.  On failure, it calls error and returns 0.  */
a5458 5
    /* Note that this assumes that we have not called from anything
       else which uses the block vectors.  FIXME: We could fix this by
       saving and restoring the state of the block allocation code.  */
    block_free ();

d5510 5
a5514 13
	if (rcs->flags & NODELTA)
	{
	    free_rcsnode_contents (rcs);
	    RCS_reparsercsfile (rcs, 0, &fp);
	}
	else
	{
	    fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	    if (fp == NULL)
		error (1, 0, "unable to reopen `%s'", rcs->path);
	    if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file");
	}
d5591 1
a5591 6
		    char *p;

		    p = block_alloc (vallen);
		    memcpy (p, value, vallen);

		    if (! linevector_add (&curlines, p, vallen, NULL, 0))
d5730 12
a5741 1
			cvs_output ("?\?-??\?-??", 0);
d5759 3
a5761 2
		    cvs_output (headlines.vector[ln]->text,
				headlines.vector[ln]->len);
a5798 1
    block_free ();
d5808 714
d6547 1
a6547 1
        RCS_reparsercsfile (finfo->rcs, 0, &fp);
d6574 1
d6646 54
@


1.2
log
@Allow a private tag when we expand RCS identifiers ourselves as well.
@
text
@d804 2
d1051 1
d1053 5
a1057 1
	    error (1, errno, "cannot read rcs file");
d1081 4
a1084 1
	    error (1, errno, "cannot read rcs file");
d2681 1
a2681 1
	if (sublen == s - srch)
d2710 1
a2710 1
		assert (srch - ebuf_last->data <= ebuf_last->len);
d3445 3
a3447 3
static void linevector_add PROTO ((struct linevector *vec, char *text,
				   size_t len, RCSVers *vers,
				   unsigned int pos));
d3453 4
a3456 2
   field).  Set the version for each of the new lines to VERS.  */
static void
d3471 1
a3471 1
	return;
d3499 1
a3499 1
	error (1, 0, "invalid rcs file: line to add out of range");
d3525 2
d3606 208
d3956 3
a3958 1
		    linevector_add (&curlines, p, vallen, NULL, 0);
d3963 5
a3967 121
		    char *p;
		    char *q;
		    int op;
		    /* The RCS format throws us for a loop in that the
		       deltafrags (if we define a deltafrag as an
		       add or a delete) need to be applied in reverse
		       order.  So we stick them into a linked list.  */
		    struct deltafrag {
			enum {ADD, DELETE} type;
			unsigned long pos;
			unsigned long nlines;
			char *new_lines;
		        size_t len;
			struct deltafrag *next;
		    };
		    struct deltafrag *dfhead;
		    struct deltafrag *df;

		    dfhead = NULL;
		    for (p = value; p != NULL && p < value + vallen; )
		    {
			op = *p++;
			if (op != 'a' && op != 'd')
			    /* Can't just skip over the deltafrag, because
			       the value of op determines the syntax.  */
			    error (1, 0, "unrecognized operation '%c' in %s",
				   op, rcs->path);
			df = (struct deltafrag *)
			    xmalloc (sizeof (struct deltafrag));
			df->next = dfhead;
			dfhead = df;
			df->pos = strtoul (p, &q, 10);

			if (p == q)
			    error (1, 0, "number expected in %s",
				   rcs->path);
			p = q;
			if (*p++ != ' ')
			    error (1, 0, "space expected in %s",
				   rcs->path);
			df->nlines = strtoul (p, &q, 10);
			if (p == q)
			    error (1, 0, "number expected in %s",
				   rcs->path);
			p = q;
			if (*p++ != '\012')
			    error (1, 0, "linefeed expected in %s",
				   rcs->path);

			if (op == 'a')
			{
			    unsigned int i;

			    df->type = ADD;
			    i = df->nlines;
			    /* The text we want is the number of lines
			       specified, or until the end of the value,
			       whichever comes first (it will be the former
			       except in the case where we are adding a line
			       which does not end in newline).  */
			    for (q = p; i != 0; ++q)
				if (*q == '\n')
				    --i;
				else if (q == value + vallen)
				{
				    if (i != 1)
					error (1, 0, "\
invalid rcs file %s: premature end of value",
					       rcs->path);
				    else
					break;
				}

			    /* Copy the text we are adding into allocated
			       space.  */
			    df->new_lines = block_alloc (q - p);
			    memcpy (df->new_lines, p, q - p);
			    df->len = q - p;

			    p = q;
			}
			else
			{
			    /* Correct for the fact that line numbers in RCS
			       files start with 1.  */
			    --df->pos;

			    assert (op == 'd');
			    df->type = DELETE;
			}
		    }
		    for (df = dfhead; df != NULL;)
		    {
			unsigned int ln;

			switch (df->type)
			{
			case ADD:
			    linevector_add (&curlines, df->new_lines,
					    df->len,
					    onbranch ? vers : NULL,
					    df->pos);
			    break;
			case DELETE:
			    if (df->pos > curlines.nlines
				|| df->pos + df->nlines > curlines.nlines)
				error (1, 0, "\
invalid rcs file %s (`d' operand out of range)",
				       rcs->path);
			    if (! onbranch)
			        for (ln = df->pos;
				     ln < df->pos + df->nlines;
				     ++ln)
				    curlines.vector[ln]->vers = prev_vers;
			    linevector_delete (&curlines, df->pos, df->nlines);
			    break;
			}
		        df = df->next;
			free (dfhead);
			dfhead = df;
		    }
d4058 2
d4208 1
a4208 1
    "Usage: %s %s [-lf] [-r rev|-D date] [files...]\n",
d4210 1
d4232 1
a4232 1
    while ((c = getopt (argc, argv, "+lr:D:f")) != -1)
d4238 3
@


1.1
log
@Initial revision
@
text
@d14 6
a19 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)rcs.c 1.40 94/10/07 $";
USE(rcsid);
#endif
d22 1
d24 3
a26 2
static int getrcskey PROTO((FILE * fp, char **keyp, char **valp));
static int parse_rcs_proc PROTO((Node * file, void *closure));
d30 1
a30 2
static void null_delproc PROTO((Node * p));
static void rcsnode_delproc PROTO((Node * p));
d32 11
a42 3

static List *rcslist;
static char *repository;
a72 64
/*
 * Parse all the rcs files specified and return a list
 */
List *
RCS_parsefiles (files, xrepos)
    List *files;
    char *xrepos;
{
    /* initialize */
    repository = xrepos;
    rcslist = getlist ();

    /* walk the list parsing files */
    if (walklist (files, parse_rcs_proc, NULL) != 0)
    {
	/* free the list and return NULL on error */
	dellist (&rcslist);
	return ((List *) NULL);
    }
    else
	/* return the list we built */
	return (rcslist);
}

/*
 * Parse an rcs file into a node on the rcs list
 */
static int
parse_rcs_proc (file, closure)
    Node *file;
    void *closure;
{
    RCSNode *rdata;

    /* parse the rcs file into rdata */
    rdata = RCS_parse (file->key, repository);

    /* if we got a valid RCSNode back, put it on the list */
    if (rdata != (RCSNode *) NULL)
	RCS_addnode (file->key, rdata, rcslist);

    return (0);
}

/*
 * Add an RCSNode to a list of them.
 */

void
RCS_addnode (file, rcs, list)
    const char *file;
    RCSNode *rcs;
    List *list;
{
    Node *p;
    
    p = getnode ();
    p->key = xstrdup (file);
    p->delproc = rcsnode_delproc;
    p->type = RCSNODE;
    p->data = (char *) rcs;
    (void) addnode (list, p);
}

d74 5
a78 3
/*
 * Parse an rcsfile given a user file name and a repository
 */
d86 2
a87 7
    char rcsfile[PATH_MAX];

#ifdef LINES_CRLF_TERMINATED
    /* Some ports of RCS to Windows NT write RCS files with newline-
       delimited lines.  We would need to pass fopen a "binary" flag.  */
    abort ();
#endif
d89 2
d92 1
a92 1
    if ((fp = fopen (rcsfile, "r")) != NULL) 
d99 2
a100 1
	return (rcs);
d102 1
a102 1
    else if (errno != ENOENT)
d105 2
a106 1
	return NULL;
a108 6
#ifdef LINES_CRLF_TERMINATED
    /* Some ports of RCS to Windows NT write RCS files with newline-
       delimited lines.  We would need to pass fopen a "binary" flag.  */
    abort ();
#endif

d110 1
a110 1
    if ((fp = fopen (rcsfile, "r")) != NULL) 
d120 2
a121 1
	return (rcs);
d123 1
a123 1
    else if (errno != ENOENT)
d126 58
a183 1
	return NULL;
d185 5
d191 1
a191 1
    return (NULL);
a203 6
#ifdef LINES_CRLF_TERMINATED
    /* Some ports of RCS to Windows NT write RCS files with newline-
       delimited lines.  We would need to pass fopen a "binary" flag.  */
    abort ();
#endif

d205 1
a205 1
    if ((fp = fopen (rcsfile, "r")) == NULL)
d240 3
a242 1
    if (getrcskey (fp, &key, &value) == -1 || key == NULL)
d248 3
a250 1
    if (getrcskey (fp, &key, &value) == -1 || key == NULL)
d287 11
a297 7
/*
 * Do the real work of parsing an RCS file 
 *
 * There are no allowances for error here.
 */
void
RCS_reparsercsfile (rdata)
d299 2
d305 1
a305 1
    Node *q, *r;
d311 1
d314 1
a314 7
#ifdef LINES_CRLF_TERMINATED
    /* Some ports of RCS to Windows NT write RCS files with newline-
       delimited lines.  We would need to pass fopen a "binary" flag.  */
    abort ();
#endif

    fp = fopen(rcsfile, "r");
a319 1
    rdata->dates = getlist ();
d331 2
a332 1
	if (getrcskey (fp, &key, &value) == -1 || key == NULL)
a347 1
	    {
d349 7
a355 2
		continue;
	    }
d368 22
d401 6
a406 1
	char date[MAXDATELEN];
a411 1
	(void) strcpy (date, valp);
d413 1
a413 10
	/* get the nodes (q is by version, r is by date) */
	q = getnode ();
	r = getnode ();
	q->type = RCSVERS;
	r->type = RCSVERS;
	q->delproc = rcsvers_delproc;
	r->delproc = null_delproc;
	q->data = r->data = xmalloc (sizeof (RCSVers));
	memset (q->data, 0, sizeof (RCSVers));
	vnode = (RCSVers *) q->data;
d415 7
a421 5
	/* fill in the version before we forget it */
	q->key = vnode->version = xstrdup (key);

	/* throw away the author field */
	(void) getrcskey (fp, &key, &value);
d423 4
a426 6
	/* throw away the state field */
	(void) getrcskey (fp, &key, &value);
#ifdef DEATH_SUPPORT
	/* Accept this regardless of DEATH_STATE, so that we can read
	   repositories created with different versions of CVS.  */
	if (strcmp (key, "state") != 0)
d429 1
a433 4
#endif

	/* fill in the date field */
	r->key = vnode->date = xstrdup (date);
d436 4
a439 1
	(void) getrcskey (fp, &key, &value);
d447 4
a450 1
	(void) getrcskey (fp, &key, &value);
d458 2
a459 1
	while ((n = getrcskey (fp, &key, &value)) >= 0)
d461 12
a472 3
#ifdef DEATH_SUPPORT
	    /* Enable use of repositories created with a CVS which defines
	       DEATH_SUPPORT and not DEATH_STATE.  */
d476 3
a480 1
#endif
d486 20
d508 16
a523 3
	/* add the nodes to the lists */
	(void) addnode (rdata->versions, q);
	(void) addnode (rdata->dates, r);
d533 31
a563 1
    fclose (fp);
d568 9
a576 1
 * rcsnode_delproc - free up an RCS type node
d578 4
a581 3
static void
rcsnode_delproc (p)
    Node *p;
d583 153
a735 1
    freercsnode ((RCSNode **) & p->data);
a754 6
    dellist (&(*rnodep)->versions);
    dellist (&(*rnodep)->dates);
    if ((*rnodep)->symbols != (List *) NULL)
	dellist (&(*rnodep)->symbols);
    if ((*rnodep)->symbols_data != (char *) NULL)
	free ((*rnodep)->symbols_data);
d759 1
d765 21
d798 2
d802 4
a809 11
 * null_delproc - don't free anything since it will be free'd by someone else
 */
/* ARGSUSED */
static void
null_delproc (p)
    Node *p;
{
    /* don't do anything */
}

/*
d822 6
a834 2
#define ALLOCINCR 1024

d836 1
a836 1
getrcskey (fp, keyp, valp)
d840 1
d844 4
d868 3
a870 3
	    key = xrealloc (key, keysize + ALLOCINCR);
	    cur = key + keysize;
	    keysize += ALLOCINCR;
d885 3
a887 3
	key = xrealloc (key, keysize + ALLOCINCR);
	cur = key + keysize;
	keysize += ALLOCINCR;
a891 8
    /* if we got "desc", we are done with the file */
    if (strcmp (RCSDESC, key) == 0)
    {
	*keyp = (char *) NULL;
	*valp = (char *) NULL;
	return (-1);
    }

d916 4
d952 3
a954 3
		    value = xrealloc (value, valsize + ALLOCINCR);
		    cur = value + valsize;
		    valsize += ALLOCINCR;
d961 5
d981 3
a983 3
		value = xrealloc (value, valsize + ALLOCINCR);
		cur = value + valsize;
		valsize += ALLOCINCR;
d995 3
a997 3
	    value = xrealloc (value, valsize + ALLOCINCR);
	    cur = value + valsize;
	    valsize += ALLOCINCR;
d1014 3
a1016 3
	value = xrealloc (value, valsize + ALLOCINCR);
	cur = value + valsize;
	valsize += ALLOCINCR;
d1022 2
a1023 1
    if (value && *value != '\0')
d1025 3
d1034 55
d1174 1
a1174 1
RCS_getversion (rcs, tag, date, force_tag_match)
d1179 1
d1181 3
d1185 1
a1185 2
    if (rcs == NULL)
	return ((char *) NULL);
d1189 8
a1196 1
	char *cp, *rev, *tagrev;
d1198 5
a1202 7
	/*
	 * first lookup the tag; if that works, turn the revision into
	 * a branch and lookup the date.
	 */
	tagrev = RCS_gettag (rcs, tag, force_tag_match);
	if (tagrev == NULL)
	    return ((char *) NULL);
d1204 3
a1206 4
	if ((cp = strrchr (tagrev, '.')) != NULL)
	    *cp = '\0';
	rev = RCS_getdatebranch (rcs, date, tagrev);
	free (tagrev);
d1210 1
a1210 1
	return (RCS_gettag (rcs, tag, force_tag_match));
d1227 1
a1227 1
RCS_gettag (rcs, tag, force_tag_match)
d1229 1
a1229 1
    char *tag;
d1231 1
d1233 5
a1237 1
    Node *p;
d1240 1
a1240 2
    if (rcs == NULL)
	return ((char *) NULL);
d1244 1
a1244 1
	RCS_reparsercsfile (rcs);
d1257 2
d1260 2
a1261 6
	if (rcs == NULL)
	    p = NULL;
	else {
	    p = findnode (RCS_symbols(rcs), tag);
	}
	if (p != NULL)
d1266 2
a1267 1
	    tag = p->data;
a1286 2
		    char *xtag;

d1289 1
a1289 3
		    xtag = xstrdup (tag);
		    *cp = '.';		/* and back again */
		    (void) sprintf (magic, "%s.%s", xtag, branch);
d1294 1
a1294 1
			free (xtag);
d1297 1
a1297 1
		    return (xtag);
d1324 2
d1327 4
a1330 1
	return (RCS_getbranch (rcs, tag, force_tag_match));
d1334 2
d1337 1
a1337 4
	if (rcs == NULL)
	    p = NULL;
	else
	    p = findnode (rcs->versions, tag);
d1339 14
a1352 1
	    return (xstrdup (tag));
d1356 2
d1440 5
a1444 3
 * Given a list of RCSNodes, returns non-zero if the specified
 * revision number or symbolic tag resolves to a "branch" within the
 * rcs file.
d1447 3
a1449 4
RCS_isbranch (file, rev, srcfiles)
    char *file;
    char *rev;
    List *srcfiles;
a1450 3
    Node *p;
    RCSNode *rcs;

d1456 1
a1456 2
    p = findnode (srcfiles, file);
    if (p == NULL)
d1460 1
a1460 2
    rcs = (RCSNode *) p->data;
    return (RCS_nodeisbranch (rev, rcs));
d1469 1
a1469 2
RCS_nodeisbranch (rev, rcs)
    char *rev;
d1471 1
d1474 1
a1474 1
    Node *p;
d1480 2
a1481 2
    p = findnode (RCS_symbols(rcs), rev);
    if (p == NULL)
d1483 1
a1483 1
    dots = numdots (p->data);
d1485 2
d1488 1
d1494 1
a1494 1
	char *branch = strrchr (p->data, '.');
d1500 1
a1500 1
	magic = xmalloc (strlen (p->data) + 1);
d1505 1
d1509 1
d1519 3
a1521 4
RCS_whatbranch (file, rev, srcfiles)
    char *file;
    char *rev;
    List *srcfiles;
d1523 1
a1524 2
    Node *p;
    RCSNode *rcs;
d1527 1
a1527 2
    p = findnode (srcfiles, file);
    if (p == NULL)
d1531 2
a1532 3
    rcs = (RCSNode *) p->data;
    p = findnode (RCS_symbols(rcs), rev);
    if (p == NULL)
d1534 1
a1534 1
    dots = numdots (p->data);
d1536 1
a1536 1
	return (xstrdup (p->data));
d1542 1
a1542 1
	char *branch = strrchr (p->data, '.');
d1548 1
a1548 1
	magic = xmalloc (strlen (p->data) + 1);
d1554 2
a1555 2
	    (void) sprintf (magic, "%s.%s", p->data, branch);
	    *cp = '.';			/* and turn it back */
d1559 1
d1581 1
a1581 2
    if (rcs == NULL)
	return ((char *) NULL);
d1584 1
a1584 1
	RCS_reparsercsfile (rcs);
d1692 1
a1692 5
    if (rcs == NULL)
	return ((char *) NULL);

    if (rcs->branch)
	return (RCS_getbranch (rcs, rcs->branch, 1));
d1698 2
d1720 1
a1720 2
    if (rcs == NULL)
	return ((char *) NULL);
d1723 1
a1723 1
	RCS_reparsercsfile (rcs);
d1810 1
a1810 1
	RCS_reparsercsfile (rcs);
d1818 5
a1822 1
    /* if no branches list, return NULL */
d1824 1
a1824 1
	return (NULL);
d1835 3
d1839 1
d1859 2
a1860 5
    /* if we found something acceptable, return it - otherwise NULL */
    if (cur_rev != NULL)
	return (xstrdup (cur_rev));
    else
	return (NULL);
d1876 11
a1886 7
/*
 * Lookup the specified revision in the ,v file and return, in the date
 * argument, the date specified for the revision *minus one second*, so that
 * the logically previous revision will be found later.
 * 
 * Returns zero on failure, RCS revision time as a Unix "time_t" on success.
 */
d1901 1
a1901 2
    if (rcs == NULL)
	return (revdate);
d1904 1
a1904 1
	RCS_reparsercsfile (rcs);
d1917 6
d1929 1
a1929 1
		    ftm->tm_mday, ftm->tm_year, ftm->tm_hour,
d1933 1
a1933 1
		    ftm->tm_mday, ftm->tm_year, ftm->tm_hour,
d1966 1
a1966 1
	RCS_reparsercsfile (rcs);
d1979 63
a2049 2
    static const char *const kflags[] =
    {"kv", "kvl", "k", "v", "o", "b", (char *) NULL};
d2062 1
a2120 1
#ifdef DEATH_SUPPORT
d2133 1
a2133 1
	RCS_reparsercsfile (rcs);
d2142 2029
a4170 1
#endif /* DEATH_SUPPORT */
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d155 1
a155 1
    else if (! existence_error (errno))
d180 1
a180 1
    else if (! existence_error (errno))
a349 6
	if (strcmp (RCSEXPAND, key) == 0)
	{
	    rdata->expand = xstrdup (value);
	    continue;
	}

a496 2
    if ((*rnodep)->expand != NULL)
	free ((*rnodep)->expand);
d830 1
a830 1
RCS_getversion (rcs, tag, date, force_tag_match, return_both)
a834 1
    int return_both;
d837 2
a838 1
    assert (rcs != NULL);
d848 1
a848 1
	tagrev = RCS_gettag (rcs, tag, force_tag_match, 0);
d859 1
a859 1
	return (RCS_gettag (rcs, tag, force_tag_match, return_both));
d876 1
a876 1
RCS_gettag (rcs, symtag, force_tag_match, return_both)
d878 1
a878 1
    char *symtag;
a879 1
    int return_both;
a881 1
    char *tag = symtag;
d884 2
a885 1
    assert (rcs != NULL);
d985 1
a985 19
	{
	    /*
	     * we have found a numeric revision for the revision tag.
	     * To support expanding the RCS keyword Name, return both
	     * the numeric tag and the supplied tag (which might be
	     * symbolic).  They are separated with a ':' which is not
	     * a valid tag char.  The variable return_both is only set
	     * if this function is called through Version_TS ->
	     * RCS_getversion.
	     */
	    if (return_both)
	    {
		char *both = xmalloc(strlen(tag) + 2 + strlen(symtag));
		sprintf(both, "%s:%s", tag, symtag);
		return both;
	    }
	    else
		return (xstrdup (tag));
	}
d1214 2
a1215 1
    assert (rcs != NULL);
d1326 5
a1330 1
    assert (rcs != NULL);
a1335 2
    if (rcs->branch)
	return (RCS_getbranch (rcs, rcs->branch, 1));
d1356 2
a1357 1
    assert (rcs != NULL);
d1529 2
a1530 1
    assert (rcs != NULL);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d14 5
d26 1
d139 6
d146 1
a146 1
    if ((fp = fopen (rcsfile, FOPEN_BINARY_READ)) != NULL) 
d161 6
d168 1
a168 1
    if ((fp = fopen (rcsfile, FOPEN_BINARY_READ)) != NULL) 
d199 6
d206 1
a206 1
    if ((fp = fopen (rcsfile, FOPEN_BINARY_READ)) == NULL)
d296 1
a296 1
    Node *q;
d304 7
a310 1
    fp = fopen(rcsfile, FOPEN_BINARY_READ);
d316 1
d377 1
a377 6

        vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
	memset (vnode, 0, sizeof (RCSVers));

	/* fill in the version before we forget it */
	vnode->version = xstrdup (key);
d383 1
d385 13
a397 1
	vnode->date = xstrdup (valp);
d404 3
d414 4
d438 3
a440 4
	    /* Enable use of repositories created by certain obsolete
	       versions of CVS.  This code should remain indefinately;
	       there is no procedure for converting old repositories, and
	       checking for it is harmless.  */
d446 1
d454 3
a456 16
	/* get the node */
	q = getnode ();
	q->type = RCSVERS;
	q->delproc = rcsvers_delproc;
	q->data = (char *) vnode;
	q->key = vnode->version;

	/* add the nodes to the list */
	if (addnode (rdata->versions, q) != 0)
	{
#if 0
		purify_printf("WARNING: Adding duplicate version: %s (%s)\n",
			 q->key, rcsfile);
		freenode (q);
#endif
	}
d498 1
a525 2
    if (rnode->date != (char *) NULL)
	free (rnode->date);
d532 11
d1704 1
d1726 1
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d17 1
d21 1
d24 3
d56 64
a218 2
    if (strcmp (key, RCSDESC) == 0)
	goto l_error;
a224 2
    if (strcmp (key, RCSDESC) == 0)
	goto l_error;
d260 7
a266 8
/* Do the real work of parsing an RCS file.

   On error, die with a fatal error; if it returns at all it was successful.

   If PFP is NULL, close the file when done.  Otherwise, leave it open
   and store the FILE * in *PFP.  */
static void
RCS_reparsercsfile (rdata, pfp)
a267 1
    FILE **pfp;
a277 1
    assert (rdata != NULL);
d297 1
a297 2
	if (getrcskey (fp, &key, &value) == -1 || key == NULL
	    || strcmp (key, RCSDESC) == 0)
d360 1
a360 1
	/* Get author field.  */
a361 5
	/* FIXME: should be using errno in case of ferror.  */
	if (key == NULL || strcmp (key, "author") != 0)
	    error (1, 0, "\
unable to parse rcs file; `author' not in the expected place");
	vnode->author = xstrdup (value);
d363 1
a363 1
	/* Get state field.  */
d365 1
a365 2
	/* FIXME: should be using errno in case of ferror.  */
	if (key == NULL || strcmp (key, "state") != 0)
a374 3
	/* FIXME: should be handling various error conditions better.  */
	if (key != NULL && strcmp (key, RCSDESC) == 0)
	    value = NULL;
a382 3
	/* FIXME: should be handling various error conditions better.  */
	if (key != NULL && strcmp (key, RCSDESC) == 0)
	    value = NULL;
a389 1
	/* FIXME: Does not correctly handle errors, e.g. from stdio.  */
a391 8
	    assert (key != NULL);

	    if (strcmp (key, RCSDESC) == 0)
	    {
		n = -1;
		break;
	    }

d433 1
a433 9
    if (pfp == NULL)
    {
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", rcsfile);
    }
    else
    {
	*pfp = fp;
    }
d438 10
a511 4
 *
 * Sets *KEYP and *VALUEP to point to storage managed by the getrcskey
 * function; the contents are only valid until the next call to getrcskey
 * or getrcsrev.
d573 8
a645 7
	/* The syntax for some key-value pairs is different; they
	   don't end with a semicolon.  */
	if (strcmp (key, RCSDESC) == 0
	    || strcmp (key, "text") == 0
	    || strcmp (key, "log") == 0)
	    break;

a709 57
static void getrcsrev PROTO ((FILE *fp, char **revp));

/* Read an RCS revision number from FP.  Put a pointer to it in *REVP;
   it points to space managed by getrcsrev which is only good until
   the next call to getrcskey or getrcsrev.  */
static void
getrcsrev (fp, revp)
    FILE *fp;
    char **revp;
{
    char *cur;
    char *max;
    int c;

    do {
	c = getc (fp);
	if (c == EOF)
	    /* FIXME: should be including filename in error message.  */
	    error (1, errno, "cannot read rcs file");
    } while (whitespace (c));

    if (!(isdigit (c) || c == '.'))
	/* FIXME: should be including filename in error message.  */
	error (1, 0, "error reading rcs file; revision number expected");

    cur = key;
    max = key + keysize;
    while (isdigit (c) || c == '.')
    {
	if (cur >= max)
	{
	    key = xrealloc (key, keysize + ALLOCINCR);
	    cur = key + keysize;
	    keysize += ALLOCINCR;
	    max = key + keysize;
	}
	*cur++ = c;

	c = getc (fp);
	if (c == EOF)
	{
	    /* FIXME: should be including filename in error message.  */
	    error (1, errno, "cannot read rcs file");
	}
    }

    if (cur >= max)
    {
	key = xrealloc (key, keysize + ALLOCINCR);
	cur = key + keysize;
	keysize += ALLOCINCR;
	max = key + keysize;
    }
    *cur = '\0';
    *revp = key;
}

d855 1
a855 1
	RCS_reparsercsfile (rcs, NULL);
d1055 3
a1057 5
 * Given an RCSNode, returns non-zero if the specified revision number 
 * or symbolic tag resolves to a "branch" within the rcs file.
 *
 * FIXME: this is the same as RCS_nodeisbranch except for the special 
 *        case for handling a null rcsnode.
d1060 6
a1065 1
RCS_isbranch (rcs, rev)
d1067 1
a1067 2
    const char *rev;
{
d1073 2
a1074 1
    if (rcs == NULL)
d1078 2
a1079 1
    return (RCS_nodeisbranch (rcs, rev));
d1088 2
a1089 1
RCS_nodeisbranch (rcs, rev)
a1090 1
    const char *rev;
d1133 4
a1136 3
RCS_whatbranch (rcs, rev)
    RCSNode *rcs;
    const char *rev;
d1138 1
d1140 1
a1140 1
    int dots;
d1143 2
a1144 1
    if (rcs == NULL)
d1148 1
d1201 1
a1201 1
	RCS_reparsercsfile (rcs, NULL);
d1340 1
a1340 1
	RCS_reparsercsfile (rcs, NULL);
d1427 1
a1427 1
	RCS_reparsercsfile (rcs, NULL);
d1512 1
a1512 1
	RCS_reparsercsfile (rcs, NULL);
a1524 6

    /* If the year is from 1900 to 1999, RCS files contain only two
       digits, and sscanf gives us a year from 0-99.  If the year is
       2000+, RCS files contain all four digits and we subtract 1900,
       because the tm_year field should contain years since 1900.  */

d1568 1
a1568 1
	RCS_reparsercsfile (rcs, NULL);
d1673 1
a1673 1
	RCS_reparsercsfile (rcs, NULL);
a1680 565
}

/* Return the RCS keyword expansion mode.  For example "b" for binary.
   Returns a pointer into storage which is allocated and freed along with
   the rest of the RCS information; the caller should not modify this
   storage.  Returns NULL if the RCS file does not specify a keyword
   expansion mode; for all other errors, die with a fatal error.  */
char *
RCS_getexpand (rcs)
    RCSNode *rcs;
{
    assert (rcs != NULL);
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
    return rcs->expand;
}

/* Stuff related to annotate command.  This should perhaps be split
   into the stuff which knows about the guts of RCS files, and the
   command parsing type stuff.  */

/* Linked list of allocated blocks.  Seems kind of silly to
   reinvent the obstack wheel, and this isn't as nice as obstacks
   in some ways, but obstacks are pretty baroque.  */
struct allocblock
{
    char *text;
    struct allocblock *next;
};
struct allocblock *blocks;

static void *block_alloc PROTO ((size_t));

static void *
block_alloc (n)
    size_t n;
{
    struct allocblock *blk;
    blk = (struct allocblock *) xmalloc (sizeof (struct allocblock));
    blk->text = xmalloc (n);
    blk->next = blocks;
    blocks = blk;
    return blk->text;
}

static void block_free PROTO ((void));

static void
block_free ()
{
    struct allocblock *p;
    struct allocblock *q;

    p = blocks;
    while (p != NULL)
    {
	free (p->text);
	q = p->next;
	free (p);
	p = q;
    }
    blocks = NULL;
}

struct line
{
    /* Text of this line, terminated by \n or \0.  */
    char *text;
    /* Version in which it was introduced.  */
    RCSVers *vers;
    /* Nonzero if this line ends with \n.  This will always be true
       except possibly for the last line.  */
    int has_newline;
};

struct linevector
{
    /* How many lines in use for this linevector?  */
    unsigned int nlines;
    /* How many lines allocated for this linevector?  */
    unsigned int lines_alloced;
    /* Pointer to array containing a pointer to each line.  */
    struct line **vector;
};

static void linevector_init PROTO ((struct linevector *));

/* Initialize *VEC to be a linevector with no lines.  */
static void
linevector_init (vec)
    struct linevector *vec;
{
    vec->lines_alloced = 10;
    vec->nlines = 0;
    vec->vector = (struct line **)
	xmalloc (vec->lines_alloced * sizeof (*vec->vector));
}

static void linevector_add PROTO ((struct linevector *vec, char *text,
				   RCSVers *vers, unsigned int pos));

/* Given some text TEXT, add each of its lines to VEC before line POS
   (where line 0 is the first line).  The last line in TEXT may or may
   not be \n terminated.  All \n in TEXT are changed to \0.  Set the
   version for each of the new lines to VERS.  */
static void
linevector_add (vec, text, vers, pos)
    struct linevector *vec;
    char *text;
    RCSVers *vers;
    unsigned int pos;
{
    unsigned int i;
    unsigned int nnew;
    char *p;
    struct line *lines;

    assert (vec->lines_alloced > 0);

    /* Count the number of lines we will need to add.  */
    nnew = 1;
    for (p = text; *p != '\0'; ++p)
	if (*p == '\n' && p[1] != '\0')
	    ++nnew;
    /* Allocate the struct line's.  */
    lines = block_alloc (nnew * sizeof (struct line));

    /* Expand VEC->VECTOR if needed.  */
    if (vec->nlines + nnew >= vec->lines_alloced)
    {
	while (vec->nlines + nnew >= vec->lines_alloced)
	    vec->lines_alloced *= 2;
	vec->vector = xrealloc (vec->vector,
				vec->lines_alloced * sizeof (*vec->vector));
    }

    /* Make room for the new lines in VEC->VECTOR.  */
    for (i = vec->nlines + nnew - 1; i >= pos + nnew; --i)
	vec->vector[i] = vec->vector[i - nnew];

    if (pos > vec->nlines)
	error (1, 0, "invalid rcs file: line to add out of range");

    /* Actually add the lines, to LINES and VEC->VECTOR.  */
    i = pos;
    lines[0].text = text;
    lines[0].vers = vers;
    lines[0].has_newline = 0;
    vec->vector[i++] = &lines[0];
    for (p = text; *p != '\0'; ++p)
	if (*p == '\n')
	{
	    *p = '\0';
	    lines[i - pos - 1].has_newline = 1;
	    if (p[1] == '\0')
		/* If there are no characters beyond the last newline, we
		   don't consider it another line.  */
		break;
	    lines[i - pos].text = p + 1;
	    lines[i - pos].vers = vers;
	    lines[i - pos].has_newline = 0;
	    vec->vector[i] = &lines[i - pos];
	    ++i;
	}
    vec->nlines += nnew;
}

static void linevector_delete PROTO ((struct linevector *, unsigned int,
				      unsigned int));

/* Remove NLINES lines from VEC at position POS (where line 0 is the
   first line).  */
static void
linevector_delete (vec, pos, nlines)
    struct linevector *vec;
    unsigned int pos;
    unsigned int nlines;
{
    unsigned int i;
    unsigned int last;

    last = vec->nlines - nlines;
    for (i = pos; i < last; ++i)
	vec->vector[i] = vec->vector[i + nlines];
    vec->nlines -= nlines;
}

static void linevector_copy PROTO ((struct linevector *, struct linevector *));

/* Copy FROM to TO, copying the vectors but not the lines pointed to.  */
static void
linevector_copy (to, from)
    struct linevector *to;
    struct linevector *from;
{
    if (from->nlines > to->lines_alloced)
    {
	while (from->nlines > to->lines_alloced)
	    to->lines_alloced *= 2;
	to->vector = (struct line **)
	    xrealloc (to->vector, to->lines_alloced * sizeof (*to->vector));
    }
    memcpy (to->vector, from->vector,
	    from->nlines * sizeof (*to->vector));
    to->nlines = from->nlines;
}

static void linevector_free PROTO ((struct linevector *));

/* Free storage associated with linevector (that is, the vector but
   not the lines pointed to).  */
static void
linevector_free (vec)
    struct linevector *vec;
{
   free (vec->vector);
}

static char *month_printname PROTO ((char *));

/* Given a textual string giving the month (1-12), terminated with any
   character not recognized by atoi, return the 3 character name to
   print it with.  I do not think it is a good idea to change these
   strings based on the locale; they are standard abbreviations (for
   example in rfc822 mail messages) which should be widely understood.
   Returns a pointer into static readonly storage.  */
static char *
month_printname (month)
    char *month;
{
    static const char *const months[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    int mnum;

    mnum = atoi (month);
    if (mnum < 1 || mnum > 12)
	return "???";
    return (char *)months[mnum - 1];
}

static int annotate_fileproc PROTO ((struct file_info *));

static int
annotate_fileproc (finfo)
    struct file_info *finfo;
{
    FILE *fp;
    char *key;
    char *value;
    RCSVers *vers;
    RCSVers *prev_vers;
    int n;
    int ishead;
    Node *node;
    struct linevector headlines;
    struct linevector curlines;

    if (finfo->rcs == NULL)
        return (1);

    /* Distinguish output for various files if we are processing
       several files.  */
    cvs_outerr ("Annotations for ", 0);
    cvs_outerr (finfo->fullname, 0);
    cvs_outerr ("\n***************\n", 0);

    if (!(finfo->rcs->flags & PARTIAL))
	/* We are leaking memory by calling RCS_reparsefile again.  */
	error (0, 0, "internal warning: non-partial rcs in annotate_fileproc");
    RCS_reparsercsfile (finfo->rcs, &fp);

    ishead = 1;
    vers = NULL;

    do {
	getrcsrev (fp, &key);

	/* Stash the previous version.  */
	prev_vers = vers;

	/* look up the revision */
	node = findnode (finfo->rcs->versions, key);
	if (node == NULL)
	    error (1, 0, "mismatch in rcs file %s between deltas and deltatexts",
		   finfo->rcs->path);
	vers = (RCSVers *) node->data;

	while ((n = getrcskey (fp, &key, &value)) >= 0)
	{
	    if (strcmp (key, "text") == 0)
	    {
		if (ishead)
		{
		    char *p;

		    p = block_alloc (strlen (value) + 1);
		    strcpy (p, value);

		    linevector_init (&headlines);
		    linevector_init (&curlines);
		    linevector_add (&headlines, p, NULL, 0);
		    linevector_copy (&curlines, &headlines);
		    ishead = 0;
		}
		else
		{
		    char *p;
		    char *q;
		    int op;
		    /* The RCS format throws us for a loop in that the
		       deltafrags (if we define a deltafrag as an
		       add or a delete) need to be applied in reverse
		       order.  So we stick them into a linked list.  */
		    struct deltafrag {
			enum {ADD, DELETE} type;
			unsigned long pos;
			unsigned long nlines;
			char *new_lines;
			struct deltafrag *next;
		    };
		    struct deltafrag *dfhead;
		    struct deltafrag *df;

		    dfhead = NULL;
		    for (p = value; p != NULL && *p != '\0'; )
		    {
			op = *p++;
			if (op != 'a' && op != 'd')
			    /* Can't just skip over the deltafrag, because
			       the value of op determines the syntax.  */
			    error (1, 0, "unrecognized operation '%c' in %s",
				   op, finfo->rcs->path);
			df = (struct deltafrag *)
			    xmalloc (sizeof (struct deltafrag));
			df->next = dfhead;
			dfhead = df;
			df->pos = strtoul (p, &q, 10);

			if (p == q)
			    error (1, 0, "number expected in %s",
				   finfo->rcs->path);
			p = q;
			if (*p++ != ' ')
			    error (1, 0, "space expected in %s",
				   finfo->rcs->path);
			df->nlines = strtoul (p, &q, 10);
			if (p == q)
			    error (1, 0, "number expected in %s",
				   finfo->rcs->path);
			p = q;
			if (*p++ != '\012')
			    error (1, 0, "linefeed expected in %s",
				   finfo->rcs->path);

			if (op == 'a')
			{
			    unsigned int i;

			    df->type = ADD;
			    i = df->nlines;
			    /* The text we want is the number of lines
			       specified, or until the end of the value,
			       whichever comes first (it will be the former
			       except in the case where we are adding a line
			       which does not end in newline).  */
			    for (q = p; i != 0; ++q)
				if (*q == '\n')
				    --i;
				else if (*q == '\0')
				{
				    if (i != 1)
					error (1, 0, "\
invalid rcs file %s: premature end of value",
					       finfo->rcs->path);
				    else
					break;
				}

			    /* Copy the text we are adding into allocated
			       space.  */
			    df->new_lines = block_alloc (q - p + 1);
			    strncpy (df->new_lines, p, q - p);
			    df->new_lines[q - p] = '\0';

			    p = q;
			}
			else
			{
			    /* Correct for the fact that line numbers in RCS
			       files start with 1.  */
			    --df->pos;

			    assert (op == 'd');
			    df->type = DELETE;
			}
		    }
		    for (df = dfhead; df != NULL;)
		    {
			unsigned int ln;

			switch (df->type)
			{
			case ADD:
			    linevector_add (&curlines, df->new_lines,
					    NULL, df->pos);
			    break;
			case DELETE:
			    if (df->pos > curlines.nlines
				|| df->pos + df->nlines > curlines.nlines)
				error (1, 0, "\
invalid rcs file %s (`d' operand out of range)",
				       finfo->rcs->path);
			    for (ln = df->pos; ln < df->pos + df->nlines; ++ln)
				curlines.vector[ln]->vers = prev_vers;
			    linevector_delete (&curlines, df->pos, df->nlines);
			    break;
			}
		        df = df->next;
			free (dfhead);
			dfhead = df;
		    }
		}
		break;
	    }
	}
	if (n < 0)
	    goto l_error;
    } while (vers->next != NULL);

    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", finfo->rcs->path);

    /* Now print out the data we have just computed.  */
    {
	unsigned int ln;

	for (ln = 0; ln < headlines.nlines; ++ln)
	{
	    char buf[80];
	    /* Period which separates year from month in date.  */
	    char *ym;
	    /* Period which separates month from day in date.  */
	    char *md;
	    RCSVers *prvers;

	    prvers = headlines.vector[ln]->vers;
	    if (prvers == NULL)
		prvers = vers;

	    sprintf (buf, "%-12s (%-8.8s ",
		     prvers->version,
		     prvers->author);
	    cvs_output (buf, 0);

	    /* Now output the date.  */
	    ym = strchr (prvers->date, '.');
	    if (ym == NULL)
		cvs_output ("??-???-??", 0);
	    else
	    {
		md = strchr (ym + 1, '.');
		if (md == NULL)
		    cvs_output ("??", 0);
		else
		    cvs_output (md + 1, 2);

		cvs_output ("-", 1);
		cvs_output (month_printname (ym + 1), 0);
		cvs_output ("-", 1);
		/* Only output the last two digits of the year.  Our output
		   lines are long enough as it is without printing the
		   century.  */
		cvs_output (ym - 2, 2);
	    }
	    cvs_output ("): ", 0);
	    cvs_output (headlines.vector[ln]->text, 0);
	    cvs_output ("\n", 1);
	}
    }

    if (!ishead)
    {
	linevector_free (&curlines);
	linevector_free (&headlines);
    }
    block_free ();
    return 0;

  l_error:
    if (ferror (fp))
	error (1, errno, "cannot read %s", finfo->rcs->path);
    else
        error (1, 0, "%s does not appear to be a valid rcs file",
	       finfo->rcs->path);
    /* Shut up gcc -Wall.  */
    return 0;
}

static const char *const annotate_usage[] =
{
    "Usage: %s %s [-l] [files...]\n",
    "\t-l\tLocal directory only, no recursion.\n",
    NULL
};

/* Command to show the revision, date, and author where each line of a
   file was modified.  Currently it will only show the trunk, all the
   way to the head, but it would be useful to enhance it to (a) allow
   one to specify a revision, and display only as far as that (easy;
   just have annotate_fileproc set all the ->vers fields to NULL when
   you hit that revision), and (b) handle branches (not as easy, but
   doable).  The user interface for both (a) and (b) could be a -r
   option.  */

int
annotate (argc, argv)
    int argc;
    char **argv;
{
    int local = 0;
    int c;

    if (argc == -1)
	usage (annotate_usage);

    optind = 0;
    while ((c = getopt (argc, argv, "+l")) != -1)
    {
	switch (c)
	{
	    case 'l':
		local = 1;
		break;
	    case '?':
	    default:
		usage (annotate_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;

#ifdef CLIENT_SUPPORT
    if (client_active)
    {
	start_server ();
	ign_setup ();

	if (local)
	    send_arg ("-l");
	send_file_names (argc, argv, SEND_EXPAND_WILD);
	/* FIXME:  We shouldn't have to send current files, but I'm not sure
	   whether it works.  So send the files --
	   it's slower but it works.  */
	send_files (argc, argv, local, 0);
	send_to_server ("annotate\012", 0);
	return get_responses_and_close ();
    }
#endif /* CLIENT_SUPPORT */

    return start_recursion (annotate_fileproc, (FILESDONEPROC) NULL,
			    (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL,
			    argc, argv, local, W_LOCAL, 0, 1, (char *)NULL,
			    1, 0);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@a14 1
static void RCS_reparsercsfile PROTO((RCSNode *, int, FILE **));
d16 1
a16 3
static int getrcskey PROTO((FILE * fp, char **keyp, char **valp,
			    size_t *lenp));
static void getrcsrev PROTO ((FILE *fp, char **revp));
a19 1
static void free_rcsnode_contents PROTO((RCSNode *));
a20 5
static char *translate_symtag PROTO((RCSNode *, const char *));

enum rcs_delta_op {RCS_ANNOTATE, RCS_FETCH};
static void RCS_deltas PROTO ((RCSNode *, FILE *, char *, enum rcs_delta_op,
			       char **, size_t *));
d65 1
a65 1
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) != NULL) 
d81 1
a81 1
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) != NULL) 
d113 1
a113 1
    if ((fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ)) == NULL)
d148 1
a148 1
    if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
d156 1
a156 1
    if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
a198 3
   If ALL is nonzero, remember all keywords and values.  Otherwise
   only keep the ones we will need.

d202 1
a202 1
RCS_reparsercsfile (rdata, all, pfp)
a203 1
    int all;
d218 1
a218 1
    fp = CVS_FOPEN (rcsfile, FOPEN_BINARY_READ);
d235 1
a235 1
	if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL
d252 1
d254 2
a255 1
	    continue;
a273 18
	if (all)
	{
	    Node *kv;

	    if (rdata->other == NULL)
		rdata->other = getlist ();
	    kv = getnode ();
	    kv->type = RCSFIELD;
	    kv->key = xstrdup (key);
	    kv->data = xstrdup (value);
	    if (addnode (rdata->other, kv) != 0)
	    {
		error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		       key, rcsfile);
		freenode (kv);
	    }
	}

a284 1
	Node *kvstate;
d300 1
a300 1
	(void) getrcskey (fp, &key, &value, NULL);
d308 1
a308 1
	(void) getrcskey (fp, &key, &value, NULL);
a316 20
	if (! all)
	    kvstate = NULL;
	else
	{
	    if (vnode->other == NULL)
		vnode->other = getlist ();
	    kvstate = getnode ();
	    kvstate->type = RCSFIELD;
	    kvstate->key = xstrdup (key);
	    kvstate->data = xstrdup (value);
	    if (addnode (vnode->other, kvstate) != 0)
	    {
		error (0, 0,
		       "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
		       key, vnode->version, rcsfile);
		freenode (kvstate);
		kvstate = NULL;
	    }
	}
d319 1
a319 1
	(void) getrcskey (fp, &key, &value, NULL);
d330 1
a330 1
	(void) getrcskey (fp, &key, &value, NULL);
d342 1
a342 1
	while ((n = getrcskey (fp, &key, &value, NULL)) >= 0)
a358 5
		if (kvstate != NULL)
		{
		    free (kvstate->data);
		    kvstate->data = xstrdup ("dead");
		}
a365 20

	    if (all)
	    {
		Node *kv;

		if (vnode->other == NULL)
		    vnode->other = getlist ();
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (key);
		kv->data = xstrdup (value);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcsfile);
		    freenode (kv);
		}
	    }
a392 22
    if (all && key != NULL && strcmp (key, RCSDESC) == 0)
    {
	Node *kv;

	if (rdata->other == NULL)
	    rdata->other = getlist ();
	kv = getnode ();
	kv->type = RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = xstrdup (value);
	if (addnode (rdata->other, kv) != 0)
	{
	    error (0, 0,
		   "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    freenode (kv);
	}
    }

    rdata->delta_pos = ftell (fp);
    rdata->flags &= ~NODELTA;

a405 171
 * Fully parse the RCS file.  Store all keyword/value pairs, fetch the
 * log messages for each revision, and fetch add and delete counts for
 * each revision (we could fetch the entire text for each revision,
 * but the only caller, log_fileproc, doesn't need that information,
 * so we don't waste the memory required to store it).  The add and
 * delete counts are stored on the OTHER field of the RCSVERSNODE
 * structure, under the names ";add" and ";delete", so that we don't
 * waste the memory space of extra fields in RCSVERSNODE for code
 * which doesn't need this information.
 */

void
RCS_fully_parse (rcs)
    RCSNode *rcs;
{
    FILE *fp;

    RCS_reparsercsfile (rcs, 1, &fp);

    while (1)
    {
	int c;
	char *key, *value;
	size_t vallen;
	Node *vers;
	RCSVers *vnode;

	/* Rather than try to keep track of how much information we
           have read, just read to the end of the file.  */
	do
	{
	    c = getc (fp);
	    if (c == EOF)
		break;
	} while (whitespace (c));
	if (c == EOF)
	    break;
	if (ungetc (c, fp) == EOF)
	    error (1, errno, "ungetc failed");

	getrcsrev (fp, &key);
	vers = findnode (rcs->versions, key);
	if (vers == NULL)
	    error (1, 0,
		   "mismatch in rcs file %s between deltas and deltatexts",
		   rcs->path);

	vnode = (RCSVers *) vers->data;

	while (getrcskey (fp, &key, &value, &vallen) >= 0)
	{
	    if (strcmp (key, "text") != 0)
	    {
		Node *kv;

		if (vnode->other == NULL)
		    vnode->other = getlist ();
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (key);
		kv->data = xstrdup (value);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}

		continue;
	    }

	    if (strcmp (vnode->version, rcs->head) != 0)
	    {
		unsigned long add, del;
		char buf[50];
		Node *kv;

		/* This is a change text.  Store the add and delete
                   counts.  */
		add = 0;
		del = 0;
		if (value != NULL)
		{
		    const char *cp;

		    cp = value;
		    while (cp < value + vallen)
		    {
			char op;
			unsigned long count;

			op = *cp++;
			if (op != 'a' && op  != 'd')
			    error (1, 0, "unrecognized operation '%c' in %s",
				   op, rcs->path);
			(void) strtoul (cp, (char **) &cp, 10);
			if (*cp++ != ' ')
			    error (1, 0, "space expected in %s",
				   rcs->path);
			count = strtoul (cp, (char **) &cp, 10);
			if (*cp++ != '\012')
			    error (1, 0, "linefeed expected in %s",
				   rcs->path);

			if (op == 'd')
			    del += count;
			else
			{
			    add += count;
			    while (count != 0)
			    {
				if (*cp == '\012')
				    --count;
				else if (cp == value + vallen)
				{
				    if (count != 1)
					error (1, 0, "\
invalid rcs file %s: premature end of value",
					       rcs->path);
				    else
					break;
				}
				++cp;
			    }
			}
		    }
		}

		sprintf (buf, "%lu", add);
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (";add");
		kv->data = xstrdup (buf);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}

		sprintf (buf, "%lu", del);
		kv = getnode ();
		kv->type = RCSFIELD;
		kv->key = xstrdup (";delete");
		kv->data = xstrdup (buf);
		if (addnode (vnode->other, kv) != 0)
		{
		    error (0, 0,
			   "\
warning: duplicate key `%s' in version `%s' of RCS file `%s'",
			   key, vnode->version, rcs->path);
		    freenode (kv);
		}
	    }

	    /* We have found the "text" key which ends the data for
               this revision.  Break out of the loop and go on to the
               next revision.  */
	    break;
	}
    }

    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", rcs->path);
}

/*
d422 7
a432 1
    free_rcsnode_contents (*rnodep);
a437 21
 * free_rcsnode_contents - free up the contents of an RCSNode without
 * freeing the node itself, or the file name, or the head, or the
 * path.  This returns the RCSNode to the state it is in immediately
 * after a call to RCS_parse.
 */
static void
free_rcsnode_contents (rnode)
    RCSNode *rnode;
{
    dellist (&rnode->versions);
    if (rnode->symbols != (List *) NULL)
	dellist (&rnode->symbols);
    if (rnode->symbols_data != (char *) NULL)
	free (rnode->symbols_data);
    if (rnode->expand != NULL)
	free (rnode->expand);
    if (rnode->other != (List *) NULL)
	dellist (&rnode->other);
}

/*
a453 4
    if (rnode->author != (char *) NULL)
	free (rnode->author);
    if (rnode->other != (List *) NULL)
	dellist (&rnode->other);
d472 2
a473 4
 * function; the contents are only valid until the next call to
 * getrcskey or getrcsrev.  If LENP is not NULL, this sets *LENP to
 * the length of *VALUEP; this is needed if the string might contain
 * binary data.
d484 1
a484 1
getrcskey (fp, keyp, valp, lenp)
a487 1
    size_t *lenp;
a490 4
    int just_string;

    if (lenp != NULL)
        *lenp = 0;
a558 4
    just_string = (strcmp (key, RCSDESC) == 0
		   || strcmp (key, "text") == 0
		   || strcmp (key, "log") == 0);

d602 3
a604 1
	if (just_string)
d663 1
a663 2
    if (value && cur != value)
    {
a664 3
	if (lenp != NULL)
	    *lenp = cur - value;
    }
d671 2
d813 1
a813 1
RCS_getversion (rcs, tag, date, force_tag_match, simple_tag)
d818 1
a818 1
    int *simple_tag;
a819 3
    if (simple_tag != NULL)
	*simple_tag = 0;

d825 1
a825 1
	char *branch, *rev;
d827 7
a833 6
	if (! RCS_isbranch (rcs, tag))
	{
	    /* We can't get a particular date if the tag is not a
               branch.  */
	    return NULL;
	}
d835 4
a838 9
	/* Work out the branch.  */
	if (! isdigit (tag[0]))
	    branch = RCS_whatbranch (rcs, tag);
	else
	    branch = xstrdup (tag);

	/* Fetch the revision of branch as of date.  */
	rev = RCS_getdatebranch (rcs, date, branch);
	free (branch);
d842 1
a842 1
	return (RCS_gettag (rcs, tag, force_tag_match, simple_tag));
d859 1
a859 1
RCS_gettag (rcs, symtag, force_tag_match, simple_tag)
d863 1
a863 1
    int *simple_tag;
d865 1
a866 4
    int tag_allocated = 0;

    if (simple_tag != NULL)
	*simple_tag = 0;
d873 1
a873 1
	RCS_reparsercsfile (rcs, 0, NULL);
a885 2
	char *version;

d887 6
a892 2
	version = translate_symtag (rcs, tag);
	if (version != NULL)
d897 1
a897 2
	    tag = version;
	    tag_allocated = 1;
d917 2
d921 3
a923 1
		    (void) sprintf (magic, "%s.%s", tag, branch);
d928 1
a928 1
			free (tag);
d931 1
a931 1
		    return (tag);
a957 2
	char *branch;

d959 1
a959 4
	branch = RCS_getbranch (rcs, tag, force_tag_match);
	if (tag_allocated)
	    free (tag);
	return branch;
a962 2
	Node *p;

d964 4
a967 1
	p = findnode (rcs->versions, tag);
d970 17
a986 12
	    /* We have found a numeric revision for the revision tag.
	       To support expanding the RCS keyword Name, if
	       SIMPLE_TAG is not NULL, tell the the caller that this
	       is a simple tag which co will recognize.  FIXME: Are
	       there other cases in which we should set this?  In
	       particular, what if we expand RCS keywords internally
	       without calling co?  */
	    if (simple_tag != NULL)
		*simple_tag = 1;
	    if (! tag_allocated)
		tag = xstrdup (tag);
	    return (tag);
a990 2
	    if (tag_allocated)
		free (tag);
d1107 1
a1107 1
    char *version;
d1113 2
a1114 2
    version = translate_symtag (rcs, rev);
    if (version == NULL)
d1116 1
a1116 1
    dots = numdots (version);
a1117 2
    {
	free (version);
a1118 1
    }
d1124 1
a1124 1
	char *branch = strrchr (version, '.');
d1130 1
a1130 1
	magic = xmalloc (strlen (version) + 1);
a1134 1
	    free (version);
a1137 1
	free (version);
d1151 1
a1151 1
    char *version;
d1159 2
a1160 2
    version = translate_symtag (rcs, rev);
    if (version == NULL)
d1162 1
a1162 1
    dots = numdots (version);
d1164 1
a1164 1
	return (version);
d1170 1
a1170 1
	char *branch = strrchr (version, '.');
d1176 1
a1176 1
	magic = xmalloc (strlen (version) + 1);
d1182 2
a1183 2
	    (void) sprintf (magic, "%s.%s", version, branch);
	    free (version);
a1186 1
	free (version);
d1211 1
a1211 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1350 1
a1350 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1437 1
a1437 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1445 1
a1445 5
    /* Tentatively use this revision, if it is early enough.  */
    if (RCS_datecmp (vers->date, date) <= 0)
	cur_rev = vers->version;

    /* if no branches list, return now */
d1447 1
a1447 1
	return xstrdup (cur_rev);
a1457 3
    {
	/* FIXME: This case would seem to imply that the RCS file is
           somehow invalid.  Should we give an error message?  */
a1458 1
    }
d1478 5
a1482 2
    /* Return whatever we found, which may be NULL.  */
    return xstrdup (cur_rev);
d1522 1
a1522 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1584 1
a1584 1
	RCS_reparsercsfile (rcs, 0, NULL);
a1596 63
 * Return the version associated with a particular symbolic tag.
 */
static char *
translate_symtag (rcs, tag)
    RCSNode *rcs;
    const char *tag;
{
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, 0, NULL);

    if (rcs->symbols != NULL)
    {
	Node *p;

	/* The symbols have already been converted into a list.  */
	p = findnode (rcs->symbols, tag);
	if (p == NULL)
	    return NULL;

	return xstrdup (p->data);
    }

    if (rcs->symbols_data != NULL)
    {
	size_t len;
	char *cp;

	/* Look through the RCS symbols information.  This is like
           do_symbols, but we don't add the information to a list.  In
           most cases, we will only be called once for this file, so
           generating the list is unnecessary overhead.  */

	len = strlen (tag);
	cp = rcs->symbols_data;
	while ((cp = strchr (cp, tag[0])) != NULL)
	{
	    if ((cp == rcs->symbols_data || whitespace (cp[-1]))
		&& strncmp (cp, tag, len) == 0
		&& cp[len] == ':')
	    {
		char *v, *r;

		/* We found the tag.  Return the version number.  */

		cp += len + 1;
		v = cp;
		while (! whitespace (*cp) && *cp != '\0')
		    ++cp;
		r = xmalloc (cp - v + 1);
		strncpy (r, v, cp - v);
		r[cp - v] = '\0';
		return r;
	    }

	    while (! whitespace (*cp) && *cp != '\0')
		++cp;
	}
    }

    return NULL;
}

/*
d1689 1
a1689 1
	RCS_reparsercsfile (rcs, 0, NULL);
d1710 1
a1710 1
	RCS_reparsercsfile (rcs, 0, NULL);
a1712 464

/* Check out a revision from RCS.  This function optimizes by reading
   the head version directly if it is easy.  Check out the revision
   into WORKFILE, or to standard output if WORKFILE is NULL.  REV is
   the numeric revision to check out; it may be NULL, which means to
   check out the head of the default branch.  If NAMETAG is not NULL,
   it is the tag that should be used when expanding the RCS Name
   keyword.  OPTIONS is a string such as -kb or -kkv, for keyword
   expansion options, or NULL if there are none.  If WORKFILE is NULL,
   run regardless of noexec; if non-NULL, noexec inhibits execution.
   SOUT is what to do with standard output (typically RUN_TTY).  */

int
RCS_checkout (rcs, workfile, rev, nametag, options, sout)
     RCSNode *rcs;
     char *workfile;
     char *rev;
     char *nametag;
     char *options;
     char *sout;
{
    int free_rev = 0;
    FILE *fp;
    struct stat sb;
    char *key;
    char *value;
    size_t len;
    int free_value = 0;
    char *ouroptions;
    int keywords;
    int ret;

    if (trace)
    {
	(void) fprintf (stderr, "%s-> checkout (%s, %s, %s, %s)\n",
#ifdef SERVER_SUPPORT
			server_active ? "S" : " ",
#else
			"",
#endif
			rcs->path,
			rev != NULL ? rev : "",
			options != NULL ? options : "",
			(workfile != NULL
			 ? workfile
			 : (sout != RUN_TTY ? sout : "(stdout)")));
    }

    assert (rev == NULL || isdigit (*rev));

    if (noexec && workfile != NULL)
	return 0;

    assert (sout == RUN_TTY || workfile == NULL);

    /* Some callers, such as Checkin or remove_file, will pass us a
       branch.  */
    if (rev != NULL && (numdots (rev) & 1) == 0)
    {
	rev = RCS_getbranch (rcs, rev, 1);
	if (rev == NULL)
	    error (1, 0, "internal error: bad branch tag in checkout");
	free_rev = 1;
    }

    if (rev == NULL || strcmp (rev, rcs->head) == 0)
    {
	int gothead;

	/* We want the head revision.  Try to read it directly.  */

	if (rcs->flags & NODELTA)
	{
	    free_rcsnode_contents (rcs);
	    rcs->flags |= PARTIAL;
	}

	if (rcs->flags & PARTIAL)
	    RCS_reparsercsfile (rcs, 0, &fp);
	else
	{
	    fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	    if (fp == NULL)
		error (1, 0, "unable to reopen `%s'", rcs->path);
	    if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file");
	}

	gothead = 0;
	getrcsrev (fp, &key);
	while (getrcskey (fp, &key, &value, &len) >= 0)
	{
	    if (strcmp (key, "text") == 0)
	    {
		gothead = 1;
		break;
	    }
	}

	if (! gothead)
	{
	    error (0, 0, "internal error: cannot find head text");
	    if (free_rev)
		free (rev);
	    return 1;
	}

	if (fstat (fileno (fp), &sb) < 0)
	    error (1, errno, "cannot fstat %s", rcs->path);

	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", rcs->path);
    }
    else
    {
	/* It isn't the head revision of the trunk.  We'll need to
	   walk through the deltas.  */

	fp = NULL;
	if (rcs->flags & PARTIAL)
	    RCS_reparsercsfile (rcs, 0, &fp);

	if (fp == NULL)
	{
	    /* If RCS_deltas didn't close the file, we could use fstat
	       here too.  Probably should change it thusly....  */
	    if (stat (rcs->path, &sb) < 0)
		error (1, errno, "cannot stat %s", rcs->path);
	}
	else
	{
	    if (fstat (fileno (fp), &sb) < 0)
		error (1, errno, "cannot fstat %s", rcs->path);
	}

	RCS_deltas (rcs, fp, rev, RCS_FETCH, &value, &len);
	free_value = 1;
    }

    /* If OPTIONS is NULL or the empty string, then the old code would
       invoke the RCS co program with no -k option, which means that
       co would use the string we have stored in rcs->expand.  */
    if (options != NULL && options[0] != '\0')
    {
	assert (options[0] == '-' && options[1] == 'k');
	ouroptions = options + 2;
    }
    else if (rcs->expand != NULL)
	ouroptions = rcs->expand;
    else
	ouroptions = "kv";

    keywords = 0;

    if (strcmp (ouroptions, "o") != 0
	&& strcmp (ouroptions, "b") != 0)
    {
	register int inkeyword;
	register char *s, *send;

	/* Keyword expansion is being done.  Make sure the text does
	   not contain any keywords.  If it does have any, do the
	   regular checkout.  */
	inkeyword = 0;
	send = value + len;
	for (s = value; s < send; s++)
	{
	    register char c;

	    c = *s;
	    if (c == '$')
	    {
		if (inkeyword)
		{
		    keywords = 1;
		    break;
		}
		inkeyword = 1;
	    }
	    else if (c == ':')
	    {
		if (inkeyword)
		{
		    keywords = 1;
		    break;
		}
	    }
	    else if (inkeyword && ! isalpha ((unsigned char) c))
		inkeyword = 0;
	}
    }

    if (! keywords)
    {
	FILE *ofp;

	/* We have the text we want.  */

	if (workfile == NULL)
	{
	    if (sout == RUN_TTY)
		ofp = stdout;
	    else
	    {
		ofp = CVS_FOPEN (sout,
				 strcmp (ouroptions, "b") == 0 ? "wb" : "w");
		if (ofp == NULL)
		    error (1, errno, "cannot open %s", sout);
	    }
	}
	else
	{
	    ofp = CVS_FOPEN (workfile,
			     strcmp (ouroptions, "b") == 0 ? "wb" : "w");
	    if (ofp == NULL)
		error (1, errno, "cannot open %s", workfile);
	}

	if (fwrite (value, 1, len, ofp) != len)
	    error (1, errno, "cannot write %s",
		   (workfile != NULL
		    ? workfile
		    : (sout != RUN_TTY ? sout : "stdout")));

	if (workfile != NULL)
	{
	    if (fclose (ofp) < 0)
		error (1, errno, "cannot close %s", workfile);
	    if (chmod (workfile,
		       sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH)) < 0)
		error (0, errno, "cannot change mode of file %s",
		       workfile);
	}
	else if (sout != RUN_TTY)
	{
	    if (fclose (ofp) < 0)
		error (1, errno, "cannot close %s", sout);
	}

	if (free_value)
	    free (value);
	if (free_rev)
	    free (rev);

	return 0;
    }

    /* We were not able to optimize retrieving this revision.  */

#if 0
    /* A bit of debugging code to make sure that NAMETAG corresponds
       to REV.  */
    if (nametag != NULL && strcmp (nametag, rev) != 0)
    {
	char *numtag;

	numtag = translate_symtag (rcs, nametag);
	assert (rev != NULL && numtag != NULL && strcmp (numtag, rev) == 0);
	free (numtag);
    }
#endif

    if (free_value)
	free (value);

    ret = RCS_exec_checkout (rcs->path, workfile,
			     nametag != NULL ? nametag : rev,
			     options, sout);

    if (free_rev)
	free (rev);

    return ret;
}

/* For RCS file RCS, make symbolic tag TAG point to revision REV.
   This validates that TAG is OK for a user to use.  Return value is
   -1 for error (and errno is set to indicate the error), positive for
   error (and an error message has been printed), or zero for success.  */

int
RCS_settag (rcs, tag, rev)
    RCSNode *rcs;
    const char *tag;
    const char *rev;
{
    int ret;

    /* FIXME: This check should be moved to RCS_check_tag.  There is no
       reason for it to be here.  */
    if (strcmp (tag, TAG_BASE) == 0
	|| strcmp (tag, TAG_HEAD) == 0)
    {
	/* Print the name of the tag might be considered redundant
	   with the caller, which also prints it.  Perhaps this helps
	   clarify why the tag name is considered reserved, I don't
	   know.  */
	error (0, 0, "Attempt to add reserved tag name %s", tag);
	return 1;
    }

    ret = RCS_exec_settag (rcs->path, tag, rev);
    if (ret != 0)
	return ret;

    /* If we have already parsed the RCS file, update the tag
       information.  If we have not yet parsed it (i.e., the PARTIAL
       flag is set), the new tag information will be read when and if
       we do parse it.  */
    if ((rcs->flags & PARTIAL) == 0)
    {
	List *symbols;
	Node *node;

	/* At this point rcs->symbol_data may not have been parsed.
	   Calling RCS_symbols will force it to be parsed into a list
	   which we can easily manipulate.  */
	symbols = RCS_symbols (rcs);
	if (symbols == NULL)
	{
	    symbols = getlist ();
	    rcs->symbols = symbols;
	}
	node = findnode (symbols, tag);
	if (node != NULL)
	{
	    free (node->data);
	    node->data = xstrdup (rev);
	}
	else
	{
	    node = getnode ();
	    node->key = xstrdup (tag);
	    node->data = xstrdup (rev);
	    (void) addnode (symbols, node);
	}
    }

    /* Setting the tag will most likely have invalidated delta_pos.  */
    rcs->flags |= NODELTA;

    return 0;
}

/* Delete the symbolic tag TAG from the RCS file RCS.  NOERR is 1 to
   suppress errors--FIXME it would be better to avoid the errors or
   some cleaner solution.  */

int
RCS_deltag (rcs, tag, noerr)
    RCSNode *rcs;
    const char *tag;
    int noerr;
{
    int ret;

    ret = RCS_exec_deltag (rcs->path, tag, noerr);
    if (ret != 0)
	return ret;

    /* If we have already parsed the RCS file, update the tag
       information.  If we have not yet parsed it (i.e., the PARTIAL
       flag is set), the new tag information will be read when and if
       we do parse it.  */
    if ((rcs->flags & PARTIAL) == 0)
    {
	List *symbols;

	/* At this point rcs->symbol_data may not have been parsed.
	   Calling RCS_symbols will force it to be parsed into a list
	   which we can easily manipulate.  */
	symbols = RCS_symbols (rcs);
	if (symbols != NULL)
	{
	    Node *node;

	    node = findnode (symbols, tag);
	    if (node != NULL)
		delnode (node);
	}
    }

    /* Deleting the tag will most likely have invalidated delta_pos.  */
    rcs->flags |= NODELTA;

    return 0;
}

/* Set the default branch of RCS to REV.  */

int
RCS_setbranch (rcs, rev)
     RCSNode *rcs;
     const char *rev;
{
    int ret;

    if (rev == NULL && rcs->branch == NULL)
	return 0;
    if (rev != NULL && rcs->branch != NULL && strcmp (rev, rcs->branch) == 0)
	return 0;

    ret = RCS_exec_setbranch (rcs->path, rev);
    if (ret != 0)
	return ret;

    if (rcs->branch != NULL)
	free (rcs->branch);
    rcs->branch = xstrdup (rev);

    /* Changing the branch will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;

    return 0;
}

/* Lock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  FIXME:
   This is only required because the RCS ci program requires a lock.
   If we eventually do the checkin ourselves, this can become a no-op.  */

int
RCS_lock (rcs, rev, noerr)
     RCSNode *rcs;
     const char *rev;
     int noerr;
{
    int ret;

    ret = RCS_exec_lock (rcs->path, rev, noerr);
    if (ret != 0)
	return ret;

    /* Setting a lock will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;

    return 0;
}

/* Unlock revision REV.  NOERR is 1 to suppress errors--FIXME it would
   be better to avoid the errors or some cleaner solution.  FIXME:
   Like RCS_lock, this can become a no-op if we do the checkin
   ourselves.  */

int
RCS_unlock (rcs, rev, noerr)
     RCSNode *rcs;
     const char *rev;
     int noerr;
{
    int ret;

    ret = RCS_exec_unlock (rcs->path, rev, noerr);
    if (ret != 0)
	return ret;

    /* Setting a lock will have changed the data in the file, so
       delta_pos will no longer be correct.  */
    rcs->flags |= NODELTA;

    return 0;
}
d1714 3
a1716 1
/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */
d1763 1
a1763 1
    /* Text of this line.  */
a1764 2
    /* Length of this line, not counting \n if has_newline is true.  */
    size_t len;
d1789 1
a1789 1
    vec->lines_alloced = 0;
d1791 2
a1792 1
    vec->vector = NULL;
d1796 1
a1796 2
				   size_t len, RCSVers *vers,
				   unsigned int pos));
d1800 2
a1801 3
   not be \n terminated.  All \n in TEXT are changed to \0 (FIXME: I
   don't think this is needed, or used, now that we have the ->len
   field).  Set the version for each of the new lines to VERS.  */
d1803 1
a1803 1
linevector_add (vec, text, len, vers, pos)
a1805 1
    size_t len;
a1808 1
    char *textend;
d1814 1
a1814 4
    if (len == 0)
	return;

    textend = text + len;
d1818 2
a1819 2
    for (p = text; p < textend; ++p)
	if (*p == '\n' && p + 1 < textend)
a1826 2
	if (vec->lines_alloced == 0)
	    vec->lines_alloced = 10;
d1846 1
a1846 1
    for (p = text; p < textend; ++p)
d1851 1
a1851 1
	    if (p + 1 == textend)
a1854 1
	    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
a1860 1
    lines[i - pos - 1].len = p - lines[i - pos - 1].text;
a1893 2
	if (to->lines_alloced == 0)
	    to->lines_alloced = 10;
d1912 1
a1912 2
    if (vec->vector != NULL)
	free (vec->vector);
d1938 1
a1938 1
/* Walk the deltas in RCS to get to revision VERSION.
d1940 4
a1943 16
   If OP is RCS_ANNOTATE, then write annotations using cvs_output.

   If OP is RCS_FETCH, then put the contents of VERSION into a
   newly-malloc'd array and put a pointer to it in *TEXT.  Each line
   is \n terminated; the caller is responsible for converting text
   files if desired.  The total length is put in *LEN.

   If FP is non-NULL, it should be a file descriptor open to the file
   RCS with file position pointing to the deltas.  We close the file
   when we are done.

   On error, give a fatal error.  */

static void
RCS_deltas (rcs, fp, version, op, text, len)
    RCSNode *rcs;
a1944 7
    char *version;
    enum rcs_delta_op op;
    char **text;
    size_t *len;
{
    char *branchversion;
    char *cpversion;
a1946 1
    size_t vallen;
a1948 2
    RCSVers *trunk_vers;
    char *next;
d1950 1
a1950 1
    int ishead, isnext, isversion, onbranch;
a1953 2
    struct linevector trunklines;
    int foundhead;
d1955 13
a1967 16
    if (fp == NULL)
    {
	if (rcs->flags & NODELTA)
	{
	    free_rcsnode_contents (rcs);
	    RCS_reparsercsfile (rcs, 0, &fp);
	}
	else
	{
	    fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	    if (fp == NULL)
		error (1, 0, "unable to reopen `%s'", rcs->path);
	    if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file");
	}
    }
a1970 20
    prev_vers = NULL;
    trunk_vers = NULL;
    next = NULL;
    onbranch = 0;
    foundhead = 0;

    linevector_init (&curlines);
    linevector_init (&headlines);
    linevector_init (&trunklines);

    /* We set BRANCHVERSION to the version we are currently looking
       for.  Initially, this is the version on the trunk from which
       VERSION branches off.  If VERSION is not a branch, then
       BRANCHVERSION is just VERSION.  */
    branchversion = xstrdup (version);
    cpversion = strchr (branchversion, '.');
    if (cpversion != NULL)
        cpversion = strchr (cpversion + 1, '.');
    if (cpversion != NULL)
        *cpversion = '\0';
d1975 2
a1976 10
	if (next != NULL && strcmp (next, key) != 0)
	{
	    /* This is not the next version we need.  It is a branch
               version which we want to ignore.  */
	    isnext = 0;
	    isversion = 0;
	}
	else
	{
	    isnext = 1;
d1978 6
a1983 20
	    /* look up the revision */
	    node = findnode (rcs->versions, key);
	    if (node == NULL)
	        error (1, 0,
		       "mismatch in rcs file %s between deltas and deltatexts",
		       rcs->path);

	    /* Stash the previous version.  */
	    prev_vers = vers;

	    vers = (RCSVers *) node->data;
	    next = vers->next;

	    /* Compare key and trunkversion now, because key points to
	       storage controlled by getrcskey.  */
	    if (strcmp (branchversion, key) == 0)
	        isversion = 1;
	    else
	        isversion = 0;
	}
d1985 1
a1985 1
	while ((n = getrcskey (fp, &key, &value, &vallen)) >= 0)
d1993 2
a1994 2
		    p = block_alloc (vallen);
		    memcpy (p, value, vallen);
d1996 4
a1999 1
		    linevector_add (&curlines, p, vallen, NULL, 0);
d2002 1
a2002 1
		else if (isnext)
a2015 1
		        size_t len;
d2022 1
a2022 1
		    for (p = value; p != NULL && p < value + vallen; )
d2029 1
a2029 1
				   op, rcs->path);
d2038 1
a2038 1
				   rcs->path);
d2042 1
a2042 1
				   rcs->path);
d2046 1
a2046 1
				   rcs->path);
d2050 1
a2050 1
				   rcs->path);
d2066 1
a2066 1
				else if (q == value + vallen)
d2071 1
a2071 1
					       rcs->path);
d2078 3
a2080 3
			    df->new_lines = block_alloc (q - p);
			    memcpy (df->new_lines, p, q - p);
			    df->len = q - p;
d2102 1
a2102 3
					    df->len,
					    onbranch ? vers : NULL,
					    df->pos);
d2109 3
a2111 6
				       rcs->path);
			    if (! onbranch)
			        for (ln = df->pos;
				     ln < df->pos + df->nlines;
				     ++ln)
				    curlines.vector[ln]->vers = prev_vers;
d2125 4
d2130 5
a2134 1
	if (isversion)
d2136 20
a2155 19
	    /* This is either the version we want, or it is the
               branchpoint to the version we want.  */
	    if (strcmp (branchversion, version) == 0)
	    {
	        /* This is the version we want.  */
		linevector_copy (&headlines, &curlines);
		foundhead = 1;
		if (onbranch)
		{
		    /* We have found this version by tracking up a
                       branch.  Restore back to the lines we saved
                       when we left the trunk, and continue tracking
                       down the trunk.  */
		    onbranch = 0;
		    vers = trunk_vers;
		    next = vers->next;
		    linevector_copy (&curlines, &trunklines);
		}
	    }
d2158 5
a2162 4
	        Node *p;

	        /* We need to look up the branch.  */
	        onbranch = 1;
d2164 7
a2170 49
		if (numdots (branchversion) < 2)
		{
		    unsigned int ln;

		    /* We are leaving the trunk; save the current
                       lines so that we can restore them when we
                       continue tracking down the trunk.  */
		    trunk_vers = vers;
		    linevector_copy (&trunklines, &curlines);

		    /* Reset the version information we have
                       accumulated so far.  It only applies to the
                       changes from the head to this version.  */
		    for (ln = 0; ln < curlines.nlines; ++ln)
		        curlines.vector[ln]->vers = NULL;
		}

		/* The next version we want is the entry on
                   VERS->branches which matches this branch.  For
                   example, suppose VERSION is 1.21.4.3 and
                   BRANCHVERSION was 1.21.  Then we look for an entry
                   starting with "1.21.4" and we'll put it (probably
                   1.21.4.1) in NEXT.  We'll advance BRANCHVERSION by
                   two dots (in this example, to 1.21.4.3).  */

		if (vers->branches == NULL)
		    error (1, 0, "missing expected branches in %s",
			   rcs->path);
		*cpversion = '.';
		++cpversion;
		cpversion = strchr (cpversion, '.');
		if (cpversion == NULL)
		    error (1, 0, "version number confusion in %s",
			   rcs->path);
		for (p = vers->branches->list->next;
		     p != vers->branches->list;
		     p = p->next)
		    if (strncmp (p->key, branchversion,
				 cpversion - branchversion) == 0)
			break;
		if (p == vers->branches->list)
		    error (1, 0, "missing expected branch in %s",
			   rcs->path);

		next = p->key;

		cpversion = strchr (cpversion + 1, '.');
		if (cpversion != NULL)
		    *cpversion = '\0';
d2172 3
d2176 1
a2176 10
	if (op == RCS_FETCH && foundhead)
	    break;
    } while (next != NULL);

    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", rcs->path);

    if (! foundhead)
        error (1, 0, "could not find desired version %s in %s",
	       version, rcs->path);
d2178 1
a2178 2
    /* Now print out or return the data we have just computed.  */
    switch (op)
d2180 2
a2181 76
	case RCS_ANNOTATE:
	    {
		unsigned int ln;

		for (ln = 0; ln < headlines.nlines; ++ln)
		{
		    char buf[80];
		    /* Period which separates year from month in date.  */
		    char *ym;
		    /* Period which separates month from day in date.  */
		    char *md;
		    RCSVers *prvers;

		    prvers = headlines.vector[ln]->vers;
		    if (prvers == NULL)
			prvers = vers;

		    sprintf (buf, "%-12s (%-8.8s ",
			     prvers->version,
			     prvers->author);
		    cvs_output (buf, 0);

		    /* Now output the date.  */
		    ym = strchr (prvers->date, '.');
		    if (ym == NULL)
			cvs_output ("??-???-??", 0);
		    else
		    {
			md = strchr (ym + 1, '.');
			if (md == NULL)
			    cvs_output ("??", 0);
			else
			    cvs_output (md + 1, 2);

			cvs_output ("-", 1);
			cvs_output (month_printname (ym + 1), 0);
			cvs_output ("-", 1);
			/* Only output the last two digits of the year.  Our output
			   lines are long enough as it is without printing the
			   century.  */
			cvs_output (ym - 2, 2);
		    }
		    cvs_output ("): ", 0);
		    cvs_output (headlines.vector[ln]->text,
				headlines.vector[ln]->len);
		    cvs_output ("\n", 1);
		}
	    }
	    break;
	case RCS_FETCH:
	    {
		char *p;
		size_t n;
		unsigned int ln;

		assert (text != NULL);
		assert (len != NULL);

		n = 0;
		for (ln = 0; ln < headlines.nlines; ++ln)
		    /* 1 for \n */
		    n += headlines.vector[ln]->len + 1;
		p = xmalloc (n);
		*text = p;
		for (ln = 0; ln < headlines.nlines; ++ln)
		{
		    memcpy (p, headlines.vector[ln]->text,
			    headlines.vector[ln]->len);
		    p += headlines.vector[ln]->len;
		    if (headlines.vector[ln]->has_newline)
			*p++ = '\n';
		}
		*len = p - *text;
		assert (*len <= n);
	    }
	    break;
a2182 5

    linevector_free (&curlines);
    linevector_free (&headlines);
    linevector_free (&trunklines);

d2184 1
a2184 1
    return;
d2188 1
a2188 1
	error (1, errno, "cannot read %s", rcs->path);
d2191 2
a2192 42
	       rcs->path);
}


/* Annotate command.  In rcs.c for historical reasons (from back when
   what is now RCS_deltas was part of annotate_fileproc).  */

/* Options from the command line.  */

static int force_tag_match = 1;
static char *tag = NULL;
static char *date = NULL;

static int annotate_fileproc PROTO ((void *callerdat, struct file_info *));

static int
annotate_fileproc (callerdat, finfo)
    void *callerdat;
    struct file_info *finfo;
{
    FILE *fp = NULL;
    char *version;

    if (finfo->rcs == NULL)
        return (1);

    if (finfo->rcs->flags & PARTIAL)
        RCS_reparsercsfile (finfo->rcs, 0, &fp);

    version = RCS_getversion (finfo->rcs, tag, date, force_tag_match,
			      (int *) NULL);
    if (version == NULL)
        return 0;

    /* Distinguish output for various files if we are processing
       several files.  */
    cvs_outerr ("Annotations for ", 0);
    cvs_outerr (finfo->fullname, 0);
    cvs_outerr ("\n***************\n", 0);

    RCS_deltas (finfo->rcs, fp, version, RCS_ANNOTATE, NULL, NULL);
    free (version);
d2198 1
a2198 1
    "Usage: %s %s [-lf] [-r rev|-D date] [files...]\n",
a2199 3
    "\t-f\tUse head revision if tag/date not found.\n",
    "\t-r rev\tAnnotate file as of specified revision/tag.\n",
    "\t-D date\tAnnotate file as of specified date.\n",
d2204 7
a2210 1
   file was modified.  */
d2224 1
a2224 1
    while ((c = getopt (argc, argv, "+lr:D:f")) != -1)
a2230 9
	    case 'r':
	        tag = optarg;
		break;
	    case 'D':
	        date = Make_Date (optarg);
		break;
	    case 'f':
	        force_tag_match = 0;
		break;
a2247 5
	if (!force_tag_match)
	    send_arg ("-f");
	option_with_arg ("-r", tag);
	if (date)
	    client_senddate (date);
d2259 1
a2259 1
			    (DIRENTPROC) NULL, (DIRLEAVEPROC) NULL, NULL,
d2261 1
a2261 1
			    1);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d71 1
a71 2
    RCSNode *retval;
    char *rcsfile;
a72 2
    rcsfile = xmalloc (strlen (repos) + strlen (file)
		       + sizeof (RCSEXT) + sizeof (CVSATTIC) + 10);
d81 1
a81 2
	retval = rcs;
	goto out;
d86 1
a86 2
	retval = NULL;
	goto out;
d100 1
a100 2
	retval = rcs;
	goto out;
d105 1
a105 2
	retval = NULL;
	goto out;
a106 1
    retval = NULL;
d108 1
a108 4
 out:
    free (rcsfile);

    return retval;
d1862 1
a1862 1
		    ftm->tm_mday, ftm->tm_year + 1900, ftm->tm_hour,
d1866 1
a1866 1
		    ftm->tm_mday, ftm->tm_year + 1900, ftm->tm_hour,
d2309 5
a2313 13
	if (workfile == NULL && sout == RUN_TTY)
	{
	    if (len > 0)
		cvs_output (value, len);
	}
	else
	{
	    if (fwrite (value, 1, len, ofp) != len)
		error (1, errno, "cannot write %s",
		       (workfile != NULL
			? workfile
			: (sout != RUN_TTY ? sout : "stdout")));
	}
d3171 1
a3171 1
			cvs_output ("?\?-??\?-??", 0);
d3348 1
a3348 1
	send_files (argc, argv, local, 0, 0);
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d781 2
d816 3
a818 3
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
d833 3
a835 3
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
d900 3
a902 3
		    size_t curoff = cur - value;
		    expand_string (&value, &valsize, valsize + 1);
		    cur = value + curoff;
d929 3
a931 3
		size_t curoff = cur - value;
		expand_string (&value, &valsize, valsize + 1);
		cur = value + curoff;
d943 3
a945 3
	    size_t curoff = cur - value;
	    expand_string (&value, &valsize, valsize + 1);
	    cur = value + curoff;
d962 3
a964 3
	size_t curoff = cur - value;
	expand_string (&value, &valsize, valsize + 1);
	cur = value + curoff;
d1011 3
a1013 3
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
d1028 3
a1030 3
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
d1824 7
a1830 11
/* Look up revision REV in RCS and return the date specified for the
   revision minus FUDGE seconds (FUDGE will generally be one, so that the
   logically previous revision will be found later, or zero, if we want
   the exact date).

   The return value is the date being returned as a time_t, or (time_t)-1
   on error (previously was documented as zero on error; I haven't checked
   the callers to make sure that they really check for (time_t)-1, but
   the latter is what this function really returns).  If DATE is non-NULL,
   then it must point to MAXDATELEN characters, and we store the same
   return value there in DATEFORM format.  */
a2007 1
    /* Big enough to hold any of the strings from kflags.  */
d3367 1
a3367 1
	send_files (argc, argv, local, 0, 0, 0);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d61 3
a63 5
/* Parse an rcsfile given a user file name and a repository.  If there is
   an error, we print an error message and return NULL.  If the file
   does not exist, we return NULL without printing anything (I'm not
   sure this allows the caller to do anything reasonable, but it is
   the current behavior).  */
a113 61
#if defined (SERVER_SUPPORT) && !defined (FILENAMES_CASE_INSENSITIVE)
    else if (ign_case)
    {
	int status;
	char *found_path;

	/* The client might be asking for a file which we do have
	   (which the client doesn't know about), but for which the
	   filename case differs.  We only consider this case if the
	   regular CVS_FOPENs fail, because fopen_case is such an
	   expensive call.  */
	(void) sprintf (rcsfile, "%s/%s%s", repos, file, RCSEXT);
	status = fopen_case (rcsfile, "rb", &fp, &found_path);
	if (status == 0)
	{
	    rcs = RCS_parsercsfile_i (fp, rcsfile);
	    if (rcs != NULL) 
		rcs->flags |= VALID;

	    fclose (fp);
	    free (rcs->path);
	    rcs->path = found_path;
	    retval = rcs;
	    goto out;
	}
	else if (! existence_error (status))
	{
	    error (0, status, "cannot open %s", rcsfile);
	    free (found_path);
	    retval = NULL;
	    goto out;
	}
	free (found_path);

	(void) sprintf (rcsfile, "%s/%s/%s%s", repos, CVSATTIC, file, RCSEXT);
	status = fopen_case (rcsfile, "rb", &fp, &found_path);
	if (status == 0)
	{
	    rcs = RCS_parsercsfile_i (fp, rcsfile);
	    if (rcs != NULL)
	    {
		rcs->flags |= INATTIC;
		rcs->flags |= VALID;
	    }

	    fclose (fp);
	    free (rcs->path);
	    rcs->path = found_path;
	    retval = rcs;
	    goto out;
	}
	else if (! existence_error (status))
	{
	    error (0, status, "cannot open %s", rcsfile);
	    free (found_path);
	    retval = NULL;
	    goto out;
	}
	free (found_path);
    }
#endif
@


1.1.1.9
log
@Latest release from Cyclic Software
@
text
@a13 7
/* The RCS -k options, and a set of enums that must match the array.
   These come first so that we can use enum kflag in function
   prototypes.  */
static const char *const kflags[] =
  {"kv", "kvl", "k", "v", "o", "b", (char *) NULL};
enum kflag { KFLAG_KV = 0, KFLAG_KVL, KFLAG_K, KFLAG_V, KFLAG_O, KFLAG_B };

a25 6
static char *printable_date PROTO((const char *));
static char *escape_keyword_value PROTO ((const char *, int *));
static void expand_keywords PROTO((RCSNode *, RCSVers *, const char *,
				   const char *, size_t, enum kflag, char *,
				   size_t, char **, size_t *));
static void cmp_file_buffer PROTO((void *, const char *, size_t));
d29 1
a29 1
			       char **, size_t *, char **, size_t *));
d144 1
d148 1
d170 1
d174 1
d359 1
a359 5
	/* We always save lock information, so that we can handle
           -kkvl correctly when checking out a file.  We don't use a
           special field for this information, since it will normally
           not be set for a CVS file.  */
	if (all || strcmp (key, "locks") == 0)
d388 1
a416 1
	vnode->state = xstrdup (value);
d421 20
d483 5
a487 3
		if (vnode->state != NULL)
		    free (vnode->state);
		vnode->state = xstrdup ("dead");
d2059 2
d2169 10
a2178 619
/* RCS keywords, and a matching enum.  */
struct rcs_keyword
{
    const char *string;
    size_t len;
};
#define KEYWORD_INIT(s) (s), sizeof (s) - 1
static const struct rcs_keyword keywords[] =
{
    { KEYWORD_INIT ("Author") },
    { KEYWORD_INIT ("Date") },
    { KEYWORD_INIT ("Header") },
    { KEYWORD_INIT ("Id") },
    { KEYWORD_INIT ("Locker") },
    { KEYWORD_INIT ("Log") },
    { KEYWORD_INIT ("Name") },
    { KEYWORD_INIT ("RCSfile") },
    { KEYWORD_INIT ("Revision") },
    { KEYWORD_INIT ("Source") },
    { KEYWORD_INIT ("State") },
    { NULL, 0 }
};
enum keyword
{
    KEYWORD_AUTHOR = 0,
    KEYWORD_DATE,
    KEYWORD_HEADER,
    KEYWORD_ID,
    KEYWORD_LOCKER,
    KEYWORD_LOG,
    KEYWORD_NAME,
    KEYWORD_RCSFILE,
    KEYWORD_REVISION,
    KEYWORD_SOURCE,
    KEYWORD_STATE
};

/* Convert an RCS date string into a readable string.  This is like
   the RCS date2str function.  */

static char *
printable_date (rcs_date)
     const char *rcs_date;
{
    int year, mon, mday, hour, min, sec;
    char buf[100];

    (void) sscanf (rcs_date, SDATEFORM, &year, &mon, &mday, &hour, &min,
		   &sec);
    if (year < 1900)
	year += 1900;
    sprintf (buf, "%04d/%02d/%02d %02d:%02d:%02d", year, mon, mday,
	     hour, min, sec);
    return xstrdup (buf);
}

/* Escape the characters in a string so that it can be included in an
   RCS value.  */

static char *
escape_keyword_value (value, free_value)
     const char *value;
     int *free_value;
{
    char *ret, *t;
    const char *s;

    for (s = value; *s != '\0'; s++)
    {
	char c;

	c = *s;
	if (c == '\t'
	    || c == '\n'
	    || c == '\\'
	    || c == ' '
	    || c == '$')
	{
	    break;
	}
    }

    if (*s == '\0')
    {
	*free_value = 0;
	return (char *) value;
    }

    ret = xmalloc (strlen (value) * 4 + 1);
    *free_value = 1;

    for (s = value, t = ret; *s != '\0'; s++, t++)
    {
	switch (*s)
	{
	default:
	    *t = *s;
	    break;
	case '\t':
	    *t++ = '\\';
	    *t = 't';
	    break;
	case '\n':
	    *t++ = '\\';
	    *t = 'n';
	    break;
	case '\\':
	    *t++ = '\\';
	    *t = '\\';
	    break;
	case ' ':
	    *t++ = '\\';
	    *t++ = '0';
	    *t++ = '4';
	    *t = '0';
	    break;
	case '$':
	    *t++ = '\\';
	    *t++ = '0';
	    *t++ = '4';
	    *t = '4';
	    break;
	}
    }

    *t = '\0';

    return ret;
}

/* Expand RCS keywords in the memory buffer BUF of length LEN.  This
   applies to file RCS and version VERS.  If NAME is not NULL, and is
   not a numeric revision, then it is the symbolic tag used for the
   checkout.  EXPAND indicates how to expand the keywords.  This
   function sets *RETBUF and *RETLEN to the new buffer and length.
   This function may modify the buffer BUF.  If BUF != *RETBUF, then
   RETBUF is a newly allocated buffer.  */

static void
expand_keywords (rcs, ver, name, log, loglen, expand, buf, len, retbuf, retlen)
     RCSNode *rcs;
     RCSVers *ver;
     const char *name;
     const char *log;
     size_t loglen;
     enum kflag expand;
     char *buf;
     size_t len;
     char **retbuf;
     size_t *retlen;
{
    struct expand_buffer
    {
	struct expand_buffer *next;
	char *data;
	size_t len;
	int free_data;
    } *ebufs = NULL;
    struct expand_buffer *ebuf_last = NULL;
    size_t ebuf_len = 0;
    char *locker;
    char *srch, *srch_next;
    size_t srch_len;

    if (expand == KFLAG_O || expand == KFLAG_B)
    {
	*retbuf = buf;
	*retlen = len;
	return;
    }

    /* If we are using -kkvl, dig out the locker information if any.  */
    locker = NULL;
    if (expand == KFLAG_KVL && rcs->other != NULL)
    {
	Node *p;

	p = findnode (rcs->other, "locks");
	if (p != NULL)
	{
	    char *cp;
	    size_t verlen;

	    /* The format of the locking information is
	         USER:VERSION USER:VERSION ...
	       If we find our version on the list, we set LOCKER to
	       the corresponding user name.  */

	    verlen = strlen (ver->version);
	    cp = p->data;
	    while ((cp = strstr (cp, ver->version)) != NULL)
	    {
		if (cp > p->data
		    && cp[-1] == ':'
		    && (cp[verlen] == '\0'
			|| whitespace (cp[verlen])))
		{
		    char *cpend;

		    --cp;
		    cpend = cp;
		    while (cp > p->data && ! whitespace (*cp))
			--cp;
		    locker = xmalloc (cpend - cp + 1);
		    memcpy (locker, cp, cpend - cp);
		    locker[cpend - cp] = '\0';
		    break;
		}

		++cp;
	    }
	}
    }

    /* RCS keywords look like $STRING$ or $STRING: VALUE$.  */
    srch = buf;
    srch_len = len;
    while ((srch_next = memchr (srch, '$', srch_len)) != NULL)
    {
	char *s, *send;
	size_t slen;
	const struct rcs_keyword *keyword;
	enum keyword kw;
	char *value;
	int free_value;
	char *sub;
	size_t sublen;

	srch_len -= (srch_next + 1) - srch;
	srch = srch_next + 1;

	/* Look for the first non alphabetic character after the '$'.  */
	send = srch + srch_len;
	for (s = srch; s < send; s++)
	    if (! isalpha (*s))
		break;

	/* If the first non alphabetic character is not '$' or ':',
           then this is not an RCS keyword.  */
	if (s == send || (*s != '$' && *s != ':'))
	    continue;

	/* See if this is one of the keywords.  */
	slen = s - srch;
	for (keyword = keywords; keyword->string != NULL; keyword++)
	{
	    if (keyword->len == slen
		&& strncmp (keyword->string, srch, slen) == 0)
	    {
		break;
	    }
	}
	if (keyword->string == NULL)
	    continue;

	kw = (enum keyword) (keyword - keywords);

	/* If the keyword ends with a ':', then the old value consists
           of the characters up to the next '$'.  If there is no '$'
           before the end of the line, though, then this wasn't an RCS
           keyword after all.  */
	if (*s == ':')
	{
	    for (; s < send; s++)
		if (*s == '$' || *s == '\n')
		    break;
	    if (s == send || *s != '$')
		continue;
	}

	/* At this point we must replace the string from SRCH to S
           with the expansion of the keyword KW.  */

	/* Get the value to use.  */
	free_value = 0;
	if (expand == KFLAG_K)
	    value = NULL;
	else
	{
	    switch (kw)
	    {
	    default:
		abort ();

	    case KEYWORD_AUTHOR:
		value = ver->author;
		break;

	    case KEYWORD_DATE:
		value = printable_date (ver->date);
		free_value = 1;
		break;

	    case KEYWORD_HEADER:
	    case KEYWORD_ID:
		{
		    char *path;
		    int free_path;
		    char *date;

		    if (kw == KEYWORD_HEADER)
			path = rcs->path;
		    else
			path = last_component (rcs->path);
		    path = escape_keyword_value (path, &free_path);
		    date = printable_date (ver->date);
		    value = xmalloc (strlen (path)
				     + strlen (ver->version)
				     + strlen (date)
				     + strlen (ver->author)
				     + strlen (ver->state)
				     + (locker == NULL ? 0 : strlen (locker))
				     + 20);

		    sprintf (value, "%s %s %s %s %s%s%s",
			     path, ver->version, date, ver->author,
			     ver->state,
			     locker != NULL ? " " : "",
			     locker != NULL ? locker : "");
		    if (free_path)
			free (path);
		    free (date);
		    free_value = 1;
		}
		break;

	    case KEYWORD_LOCKER:
		value = locker;
		break;

	    case KEYWORD_LOG:
	    case KEYWORD_RCSFILE:
		value = escape_keyword_value (last_component (rcs->path),
					      &free_value);
		break;

	    case KEYWORD_NAME:
		if (name != NULL && ! isdigit (*name))
		    value = (char *) name;
		else
		    value = NULL;
		break;

	    case KEYWORD_REVISION:
		value = ver->version;
		break;

	    case KEYWORD_SOURCE:
		value = escape_keyword_value (rcs->path, &free_value);
		break;

	    case KEYWORD_STATE:
		value = ver->state;
		break;
	    }
	}

	sub = xmalloc (keyword->len
		       + (value == NULL ? 0 : strlen (value))
		       + 10);
	if (expand == KFLAG_V)
	{
	    /* Decrement SRCH and increment S to remove the $
               characters.  */
	    --srch;
	    ++srch_len;
	    ++s;
	    sublen = 0;
	}
	else
	{
	    strcpy (sub, keyword->string);
	    sublen = strlen (keyword->string);
	    if (expand != KFLAG_K)
	    {
		sub[sublen] = ':';
		sub[sublen + 1] = ' ';
		sublen += 2;
	    }
	}
	if (value != NULL)
	{
	    strcpy (sub + sublen, value);
	    sublen += strlen (value);
	}
	if (expand != KFLAG_V && expand != KFLAG_K)
	{
	    sub[sublen] = ' ';
	    ++sublen;
	    sub[sublen] = '\0';
	}

	if (free_value)
	    free (value);

	/* The Log keyword requires special handling.  This behaviour
           is taken from RCS 5.7.  The special log message is what RCS
           uses for ci -k.  */
	if (kw == KEYWORD_LOG
	    && (sizeof "checked in with -k by " <= loglen
		|| strncmp (log, "checked in with -k by ",
			    sizeof "checked in with -k by " - 1) != 0))
	{
	    char *start;
	    char *leader;
	    size_t leader_len, leader_sp_len;
	    const char *logend;
	    const char *snl;
	    int cnl;
	    char *date;
	    const char *sl;

	    /* We are going to insert the trailing $ ourselves, before
               the log message, so we must remove it from S, if we
               haven't done so already.  */
	    if (expand != KFLAG_V)
		++s;

	    /* Find the start of the line.  */
	    start = srch;
	    while (start > buf && start[-1] != '\n')
		--start;

	    /* Copy the start of the line to use as a comment leader.  */
	    leader_len = srch - start;
	    if (expand != KFLAG_V)
		--leader_len;
	    leader = xmalloc (leader_len);
	    memcpy (leader, start, leader_len);
	    leader_sp_len = leader_len;
	    while (leader_sp_len > 0 && leader[leader_sp_len - 1] == ' ')
		--leader_sp_len;

	    /* RCS does some checking for an old style of Log here,
	       but we don't bother.  RCS issues a warning if it
	       changes anything.  */

	    /* Count the number of newlines in the log message so that
	       we know how many copies of the leader we will need.  */
	    cnl = 0;
	    logend = log + loglen;
	    for (snl = log; snl < logend; snl++)
		if (*snl == '\n')
		    ++cnl;

	    date = printable_date (ver->date);
	    sub = xrealloc (sub,
			    (sublen
			     + sizeof "Revision"
			     + strlen (ver->version)
			     + strlen (date)
			     + strlen (ver->author)
			     + loglen
			     + (cnl + 2) * leader_len
			     + 20));
	    if (expand != KFLAG_V)
	    {
		sub[sublen] = '$';
		++sublen;
	    }
	    sub[sublen] = '\n';
	    ++sublen;
	    memcpy (sub + sublen, leader, leader_len);
	    sublen += leader_len;
	    sprintf (sub + sublen, "Revision %s  %s  %s\n",
		     ver->version, date, ver->author);
	    sublen += strlen (sub + sublen);
	    free (date);

	    sl = log;
	    while (sl < logend)
	    {
		if (*sl == '\n')
		{
		    memcpy (sub + sublen, leader, leader_sp_len);
		    sublen += leader_sp_len;
		    sub[sublen] = '\n';
		    ++sublen;
		    ++sl;
		}
		else
		{
		    const char *slnl;

		    memcpy (sub + sublen, leader, leader_len);
		    sublen += leader_len;
		    for (slnl = sl; slnl < logend && *slnl != '\n'; ++slnl)
			;
		    if (slnl < logend)
			++slnl;
		    memcpy (sub + sublen, sl, slnl - sl);
		    sublen += slnl - sl;
		    sl = slnl;
		}
	    }

	    memcpy (sub + sublen, leader, leader_sp_len);
	    sublen += leader_sp_len;

	    free (leader);
	}

	/* Now SUB contains a string which is to replace the string
	   from SRCH to S.  SUBLEN is the length of SUB.  */

	if (sublen == s - srch)
	{
	    memcpy (srch, sub, sublen);
	    free (sub);
	}
	else
	{
	    struct expand_buffer *ebuf;

	    /* We need to change the size of the buffer.  We build a
               list of expand_buffer structures.  Each expand_buffer
               structure represents a portion of the final output.  We
               concatenate them back into a single buffer when we are
               done.  This minimizes the number of potentially large
               buffer copies we must do.  */

	    if (ebufs == NULL)
	    {
		ebufs = (struct expand_buffer *) xmalloc (sizeof *ebuf);
		ebufs->next = NULL;
		ebufs->data = buf;
		ebufs->free_data = 0;
		ebuf_len = srch - buf;
		ebufs->len = ebuf_len;
		ebuf_last = ebufs;
	    }
	    else
	    {
		assert (srch >= ebuf_last->data);
		assert (srch - ebuf_last->data <= ebuf_last->len);
		ebuf_len -= ebuf_last->len - (srch - ebuf_last->data);
		ebuf_last->len = srch - ebuf_last->data;
	    }

	    ebuf = (struct expand_buffer *) xmalloc (sizeof *ebuf);
	    ebuf->data = sub;
	    ebuf->len = sublen;
	    ebuf->free_data = 1;
	    ebuf->next = NULL;
	    ebuf_last->next = ebuf;
	    ebuf_last = ebuf;
	    ebuf_len += sublen;

	    ebuf = (struct expand_buffer *) xmalloc (sizeof *ebuf);
	    ebuf->data = s;
	    ebuf->len = srch_len - (s - srch);
	    ebuf->free_data = 0;
	    ebuf->next = NULL;
	    ebuf_last->next = ebuf;
	    ebuf_last = ebuf;
	    ebuf_len += srch_len - (s - srch);
	}

	srch_len -= (s - srch);
	srch = s;
    }

    if (locker != NULL)
	free (locker);

    if (ebufs == NULL)
    {
	*retbuf = buf;
	*retlen = len;
    }
    else
    {
	char *ret;

	ret = xmalloc (ebuf_len);
	*retbuf = ret;
	*retlen = ebuf_len;
	while (ebufs != NULL)
	{
	    struct expand_buffer *next;

	    memcpy (ret, ebufs->data, ebufs->len);
	    ret += ebufs->len;
	    if (ebufs->free_data)
		free (ebufs->data);
	    next = ebufs->next;
	    free (ebufs);
	    ebufs = next;
	}
    }
}

/* Check out a revision from an RCS file.

   If PFN is not NULL, then ignore WORKFILE and SOUT.  Call PFN zero
   or more times with the contents of the file.  CALLERDAT is passed,
   uninterpreted, to PFN.  (The current code will always call PFN
   exactly once for a non empty file; however, the current code
   assumes that it can hold the entire file contents in memory, which
   is not a good assumption, and might change in the future).

   Otherwise, if WORKFILE is not NULL, check out the revision to
   WORKFILE.  However, if WORKFILE is not NULL, and noexec is set,
   then don't do anything.

   Otherwise, if WORKFILE is NULL, check out the revision to SOUT.  If
   SOUT is RUN_TTY, then write the contents of the revision to
   standard output.  When using SOUT, the output is generally a
   temporary file; don't bother to get the file modes correct.

   REV is the numeric revision to check out.  It may be NULL, which
   means to check out the head of the default branch.

   If NAMETAG is not NULL, and is not a numeric revision, then it is
   the tag that should be used when expanding the RCS Name keyword.

   OPTIONS is a string such as "-kb" or "-kv" for keyword expansion
   options.  It may be NULL to use the default expansion mode of the
   file, typically "-kkv".  */
d2181 1
a2181 1
RCS_checkout (rcs, workfile, rev, nametag, options, sout, pfn, callerdat)
a2187 2
     RCSCHECKOUTPROC pfn;
     void *callerdat;
a2189 1
    enum kflag expand;
d2196 3
a2198 3
    char *log = NULL;
    size_t loglen;
    FILE *ofp;
d2211 3
a2213 4
			(pfn != NULL ? "(function)"
			 : (workfile != NULL
			    ? workfile
			    : (sout != RUN_TTY ? sout : "(stdout)"))));
a2221 1
    assert (pfn == NULL || (sout == RUN_TTY && workfile == NULL));
a2259 6
	    if (strcmp (key, "log") == 0)
	    {
		log = xmalloc (len);
		memcpy (log, value, len);
		loglen = len;
	    }
d2303 1
a2303 1
	RCS_deltas (rcs, fp, rev, RCS_FETCH, &value, &len, &log, &loglen);
d2310 7
a2316 2
    if ((options == NULL || options[0] == '\0') && rcs->expand == NULL)
	expand = KFLAG_KV;
d2318 6
d2325 2
a2326 2
	const char *ouroptions;
	const char * const *cpp;
d2328 6
a2333 1
	if (options != NULL && options[0] != '\0')
d2335 1
a2335 5
	    assert (options[0] == '-' && options[1] == 'k');
	    ouroptions = options + 2;
	}
	else
	    ouroptions = rcs->expand;
d2337 20
a2356 12
	for (cpp = kflags; *cpp != NULL; cpp++)
	    if (strcmp (*cpp, ouroptions) == 0)
		break;

	if (*cpp != NULL)
	    expand = (enum kflag) (cpp - kflags);
	else
	{
	    error (0, 0,
		   "internal error: unsupported substitution string -k%s",
		   ouroptions);
	    expand = KFLAG_KV;
d2360 1
a2360 1
    if (expand != KFLAG_O && expand != KFLAG_B)
d2362 1
a2362 7
	Node *p;
	char *newvalue;

	p = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	if (p == NULL)
	    error (1, 0, "internal error: no revision information for %s",
		   rev == NULL ? rcs->head : rev);
d2364 1
a2364 2
	expand_keywords (rcs, (RCSVers *) p->data, nametag, log, loglen,
			 expand, value, len, &newvalue, &len);
a2365 24
	if (newvalue != value)
	{
	    if (free_value)
		free (value);
	    value = newvalue;
	    free_value = 1;
	}
    }

    if (log != NULL)
    {
	free (log);
	log = NULL;
    }

    if (pfn != NULL)
    {
	/* The PFN interface is very simple to implement right now, as
           we always have the entire file in memory.  */
	if (len != 0)
	    pfn (callerdat, value, len);
    }
    else
    {
d2372 2
a2373 1
		ofp = CVS_FOPEN (sout, expand == KFLAG_B ? "wb" : "w");
d2380 2
a2381 1
	    ofp = CVS_FOPEN (workfile, expand == KFLAG_B ? "wb" : "w");
a2413 1
    }
d2415 4
a2418 4
    if (free_value)
	free (value);
    if (free_rev)
	free (rev);
d2420 1
a2420 40
    return 0;
}

/* This structure is passed between RCS_cmp_file and cmp_file_buffer.  */

struct cmp_file_data
{
    const char *filename;
    FILE *fp;
    int different;
};

/* Compare the contents of revision REV of RCS file RCS with the
   contents of the file FILENAME.  OPTIONS is a string for the keyword
   expansion options.  Return 0 if the contents of the revision are
   the same as the contents of the file, 1 if they are different.  */

int
RCS_cmp_file (rcs, rev, options, filename)
     RCSNode *rcs;
     char *rev;
     char *options;
     const char *filename;
{
    int binary;
    FILE *fp;
    struct cmp_file_data data;
    int retcode;

    if (options != NULL && options[0] != '\0')
	binary = (strcmp (options, "-kb") == 0);
    else
    {
	char *expand;

	expand = RCS_getexpand (rcs);
	if (expand != NULL && strcmp (expand, "b") == 0)
	    binary = 1;
	else
	    binary = 0;
d2423 1
a2423 1
    fp = CVS_FOPEN (filename, binary ? FOPEN_BINARY_READ : "r");
d2425 10
a2434 14
    data.filename = filename;
    data.fp = fp;
    data.different = 0;

    retcode = RCS_checkout (rcs, (char *) NULL, rev, (char *) NULL,
			    options, RUN_TTY, cmp_file_buffer,
			    (void *) &data);

    /* If we have not yet found a difference, make sure that we are at
       the end of the file.  */
    if (! data.different)
    {
	if (getc (fp) != EOF)
	    data.different = 1;
d2436 1
d2438 2
a2439 1
    fclose (fp);
d2441 3
a2443 2
    if (retcode != 0)
	return 1;
d2445 2
a2446 2
    return data.different;
}
d2448 1
a2448 48
/* This is a subroutine of RCS_cmp_file.  It is passed to
   RCS_checkout.  */

#define CMP_BUF_SIZE (8 * 1024)

static void
cmp_file_buffer (callerdat, buffer, len)
     void *callerdat;
     const char *buffer;
     size_t len;
{
    struct cmp_file_data *data = (struct cmp_file_data *) callerdat;
    char *filebuf;

    /* If we've already found a difference, we don't need to check
       further.  */
    if (data->different)
	return;

    filebuf = xmalloc (len > CMP_BUF_SIZE ? CMP_BUF_SIZE : len);

    while (len > 0)
    {
	size_t checklen;

	checklen = len > CMP_BUF_SIZE ? CMP_BUF_SIZE : len;
	if (fread (filebuf, 1, checklen, data->fp) != checklen)
	{
	    if (ferror (data->fp))
		error (1, errno, "cannot read file %s for comparing",
		       data->filename);
	    data->different = 1;
	    free (filebuf);
	    return;
	}

	if (memcmp (filebuf, buffer, checklen) != 0)
	{
	    data->different = 1;
	    free (filebuf);
	    return;
	}

	buffer += checklen;
	len -= checklen;
    }

    free (filebuf);
a2890 3
   If LOG is non-NULL, then *LOG is set to the log message of VERSION,
   and *LOGLEN is set to the length of the log message.

d2894 1
a2894 1
RCS_deltas (rcs, fp, version, op, text, len, log, loglen)
a2900 2
    char **log;
    size_t *loglen;
a2995 10
	    if (log != NULL
		&& isversion
		&& strcmp (key, "log") == 0
		&& strcmp (branchversion, version) == 0)
	    {
		*log = xmalloc (vallen);
		memcpy (*log, value, vallen);
		*loglen = vallen;
	    }

d3361 1
a3361 2
    RCS_deltas (finfo->rcs, fp, version, RCS_ANNOTATE, (char **) NULL,
		(size_t) NULL, (char **) NULL, (size_t *) NULL);
d3430 4
a3433 1
	send_files (argc, argv, local, 0, SEND_NO_CONTENTS);
@


1.1.1.10
log
@Latest version from Cyclic Software
@
text
@a803 2
    if (rnode->state != (char *) NULL)
	free (rnode->state);
a1048 1
	{
d1050 1
a1050 5
	    if (ferror (fp))
		error (1, errno, "cannot read rcs file");
	    else
		error (1, 0, "unexpected end of file reading rcs file");
	}
d1074 1
a1074 4
	    if (ferror (fp))
		error (1, errno, "cannot read rcs file");
	    else
		error (1, 0, "unexpected end of file reading rcs file");
d2663 1
a2663 1
	if (srch + sublen == s)
d2692 1
a2692 1
		assert (srch <= ebuf_last->data + ebuf_last->len);
d3427 3
a3429 3
static int linevector_add PROTO ((struct linevector *vec, char *text,
				  size_t len, RCSVers *vers,
				  unsigned int pos));
d3435 2
a3436 4
   field).  Set the version for each of the new lines to VERS.  This
   function returns non-zero for success.  It returns zero if the line
   number is out of range.  */
static int
d3451 1
a3451 1
	return 1;
d3479 1
a3479 1
	return 0;
a3504 2

    return 1;
a3583 208
static int
apply_rcs_changes PROTO ((struct linevector *, const char *, size_t,
			  const char *, RCSVers *, RCSVers *));

/* Apply changes to the line vector LINES.  DIFFBUF is a buffer of
   length DIFFLEN holding the change text from an RCS file (the output
   of diff -n).  NAME is used in error messages.  The VERS field of
   any line added is set to ADDVERS.  The VERS field of any line
   deleted is set to DELVERS, unless DELVERS is NULL, in which case
   the VERS field of deleted lines is unchanged.  The function returns
   non-zero if the change text is applied successfully.  It returns
   zero if the change text does not appear to apply to LINES (e.g., a
   line number is invalid).  If the change text is improperly
   formatted (e.g., it is not the output of diff -n), the function
   calls error with a status of 1, causing the program to exit.  */

static int
apply_rcs_changes (lines, diffbuf, difflen, name, addvers, delvers)
     struct linevector *lines;
     const char *diffbuf;
     size_t difflen;
     const char *name;
     RCSVers *addvers;
     RCSVers *delvers;
{
    const char *p;
    const char *q;
    int op;
    /* The RCS format throws us for a loop in that the deltafrags (if
       we define a deltafrag as an add or a delete) need to be applied
       in reverse order.  So we stick them into a linked list.  */
    struct deltafrag {
	enum {ADD, DELETE} type;
	unsigned long pos;
	unsigned long nlines;
	char *new_lines;
	size_t len;
	struct deltafrag *next;
    };
    struct deltafrag *dfhead;
    struct deltafrag *df;

    dfhead = NULL;
    for (p = diffbuf; p != NULL && p < diffbuf + difflen; )
    {
	op = *p++;
	if (op != 'a' && op != 'd')
	    /* Can't just skip over the deltafrag, because the value
	       of op determines the syntax.  */
	    error (1, 0, "unrecognized operation '%c' in %s", op, name);
	df = (struct deltafrag *) xmalloc (sizeof (struct deltafrag));
	df->next = dfhead;
	dfhead = df;
	df->pos = strtoul (p, (char **) &q, 10);

	if (p == q)
	    error (1, 0, "number expected in %s", name);
	p = q;
	if (*p++ != ' ')
	    error (1, 0, "space expected in %s", name);
	df->nlines = strtoul (p, (char **) &q, 10);
	if (p == q)
	    error (1, 0, "number expected in %s", name);
	p = q;
	if (*p++ != '\012')
	    error (1, 0, "linefeed expected in %s", name);

	if (op == 'a')
	{
	    unsigned int i;

	    df->type = ADD;
	    i = df->nlines;
	    /* The text we want is the number of lines specified, or
	       until the end of the value, whichever comes first (it
	       will be the former except in the case where we are
	       adding a line which does not end in newline).  */
	    for (q = p; i != 0; ++q)
		if (*q == '\n')
		    --i;
		else if (q == diffbuf + difflen)
		{
		    if (i != 1)
			error (1, 0, "premature end of change in %s", name);
		    else
			break;
		}

	    /* Copy the text we are adding into allocated space.  */
	    df->new_lines = block_alloc (q - p);
	    memcpy (df->new_lines, p, q - p);
	    df->len = q - p;

	    p = q;
	}
	else
	{
	    /* Correct for the fact that line numbers in RCS files
	       start with 1.  */
	    --df->pos;

	    assert (op == 'd');
	    df->type = DELETE;
	}
    }

    for (df = dfhead; df != NULL;)
    {
	unsigned int ln;

	switch (df->type)
	{
	case ADD:
	    if (! linevector_add (lines, df->new_lines, df->len, addvers,
				  df->pos))
		return 0;
	    break;
	case DELETE:
	    if (df->pos > lines->nlines
		|| df->pos + df->nlines > lines->nlines)
		return 0;
	    if (delvers != NULL)
		for (ln = df->pos; ln < df->pos + df->nlines; ++ln)
		    lines->vector[ln]->vers = delvers;
	    linevector_delete (lines, df->pos, df->nlines);
	    break;
	}
	df = df->next;
	free (dfhead);
	dfhead = df;
    }

    return 1;
}

/* Apply an RCS change text to a buffer.  The function name starts
   with rcs rather than RCS because this does not take an RCSNode
   argument.  NAME is used in error messages.  TEXTBUF is the text
   buffer to change, and TEXTLEN is the size.  DIFFBUF and DIFFLEN are
   the change buffer and size.  The new buffer is returned in *RETBUF
   and *RETLEN.  The new buffer is allocated by xmalloc.  The function
   changes the contents of TEXTBUF.  This function returns 1 for
   success.  On failure, it calls error and returns 0.  */

int
rcs_change_text (name, textbuf, textlen, diffbuf, difflen, retbuf, retlen)
     const char *name;
     char *textbuf;
     size_t textlen;
     const char *diffbuf;
     size_t difflen;
     char **retbuf;
     size_t *retlen;
{
    struct linevector lines;
    int ret;

    *retbuf = NULL;
    *retlen = 0;

    linevector_init (&lines);

    if (! linevector_add (&lines, textbuf, textlen, NULL, 0))
	error (1, 0, "cannot initialize line vector");

    if (! apply_rcs_changes (&lines, diffbuf, difflen, name, NULL, NULL))
    {
	error (0, 0, "invalid change text in %s", name);
	ret = 0;
    }
    else
    {
	char *p;
	size_t n;
	unsigned int ln;

	n = 0;
	for (ln = 0; ln < lines.nlines; ++ln)
	    /* 1 for \n */
	    n += lines.vector[ln]->len + 1;

	p = xmalloc (n);
	*retbuf = p;

	for (ln = 0; ln < lines.nlines; ++ln)
	{
	    memcpy (p, lines.vector[ln]->text, lines.vector[ln]->len);
	    p += lines.vector[ln]->len;
	    if (lines.vector[ln]->has_newline)
		*p++ = '\n';
	}

	*retlen = p - *retbuf;
	assert (*retlen <= n);

	ret = 1;
    }

    linevector_free (&lines);

    /* Note that this assumes that we have not called from anything
       else which uses the block vectors.  FIXME: We could fix this by
       saving and restoring the state of the block allocation code.  */
    block_free ();

    return ret;
}

d3726 1
a3726 3
		    if (! linevector_add (&curlines, p, vallen, NULL, 0))
			error (1, 0, "invalid rcs file %s", rcs->path);

d3731 121
a3851 5
		    if (! apply_rcs_changes (&curlines, value, vallen,
					     rcs->path,
					     onbranch ? vers : NULL,
					     onbranch ? NULL : prev_vers))
			error (1, 0, "invalid change text in %s", rcs->path);
a3941 2
    free (branchversion);
    
d4090 1
a4090 1
    "Usage: %s %s [-lRf] [-r rev|-D date] [files...]\n",
a4091 1
    "\t-R\tProcess directories recursively.\n",
d4113 1
a4113 1
    while ((c = getopt (argc, argv, "+lr:D:fR")) != -1)
a4118 3
		break;
	    case 'R':
		local = 0;
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d5 1
a5 1
 * specified in the README file that comes with the CVS source distribution.
a12 1
#include "edit.h"
d22 1
a29 1
static void do_locks PROTO((List * list, char *val));
a30 1
static void free_rcsvers_contents PROTO((RCSVers *));
a43 18
/* Routines for reading, parsing and writing RCS files. */
static RCSVers *getdelta PROTO ((FILE *, char *));
static Deltatext *RCS_getdeltatext PROTO ((RCSNode *, FILE *));
static void freedeltatext PROTO ((Deltatext *));

static void RCS_putadmin PROTO ((RCSNode *, FILE *));
static void RCS_putdtree PROTO ((RCSNode *, char *, FILE *));
static void RCS_putdesc PROTO ((RCSNode *, FILE *));
static void putdelta PROTO ((RCSVers *, FILE *));
static int putrcsfield_proc PROTO ((Node *, void *));
static int putsymbol_proc PROTO ((Node *, void *));
static void RCS_copydeltas PROTO ((RCSNode *, FILE *, FILE *, Deltatext *, char *));
static void putdeltatext PROTO ((FILE *, Deltatext *));

static FILE *rcs_internal_lockfile PROTO ((char *));
static void rcs_internal_unlockfile PROTO ((FILE *, char *));
static char *rcs_lockfilename PROTO ((char *));

d235 4
a238 14

       Most cvs operations on the main branch don't need any more
       information.  Those that do call RCS_reparsercsfile to parse
       the rest of the header and the deltas.

       People often wonder whether this is inefficient, to open the
       file once here and once in RCS_reparsercsfile.  Well, it might
       help a little bit if we kept the file open (I haven't tried
       timing this myself), but basically the common case, which we
       want to optimize, is the one in which we call
       RCS_parsercsfile_i and not RCS_reparsercsfile (for example,
       "cvs update" on a lot of files most of which are unmodified).
       So making the case in which we call RCS_reparsercsfile fast is
       not as important.  */
d291 3
d296 2
a297 2
void
RCS_reparsercsfile (rdata, pfp)
d299 1
d305 1
a305 1
    Node *q, *kv;
d307 1
a307 1
    long fpos;
a318 3
    /* This probably shouldn't be done until later: if a file has an
       empty revision tree (which is permissible), rdata->versions
       should be NULL. -twp */
a326 2
	fpos = ftell (fp);

d331 2
a332 1
	if (getrcskey (fp, &key, &value, NULL) == -1 || key == NULL)
a344 29
	/* Skip head and branch tags; we already have them. */
	if (strcmp (key, RCSHEAD) == 0 || strcmp (key, RCSBRANCH) == 0)
	    continue;

	if (strcmp (key, "access") == 0)
	{
	    if (value != NULL)
		rdata->access = xstrdup (value);
	    continue;
	}

	/* We always save lock information, so that we can handle
           -kkvl correctly when checking out a file. */
	if (strcmp (key, "locks") == 0)
	{
	    if (value != NULL)
		rdata->locks_data = xstrdup (value);
	    fpos = ftell (fp);
	    if (getrcskey (fp, &key, &value, NULL) >= 0 &&
		strcmp (key, "strict") == 0 &&
		value == NULL)
	    {
		rdata->strict_locks = 1;
	    }
	    else
		(void) fseek (fp, fpos, SEEK_SET);
	    continue;
	}

d360 1
a360 1
	 * revision or `desc', we are done with the headers and are down to the
d368 20
a387 19
	if (strcmp (key, RCSDESC) == 0)
	    break;

	if (strcmp (key, "comment") == 0)
	{
	    rdata->comment = xstrdup (value);
	    continue;
	}
	if (rdata->other == NULL)
	    rdata->other = getlist ();
	kv = getnode ();
	kv->type = RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = xstrdup (value);
	if (addnode (rdata->other, kv) != 0)
	{
	    error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    freenode (kv);
d398 109
a506 2
    /* First, seek back to the start of the delta block. */
    (void) fseek (fp, fpos, SEEK_SET);
a507 2
    while ((vnode = getdelta (fp, rcsfile)) != NULL)
    {
d524 7
d533 1
a533 2
    (void) getrcskey (fp, &key, &value, NULL);
    if (key != NULL && strcmp (key, RCSDESC) == 0)
d535 9
a543 1
	if (rdata->desc != NULL)
d548 1
a548 1
	    free (rdata->desc);
a549 1
	rdata->desc = xstrdup (value);
d553 1
d585 1
a585 1
    RCS_reparsercsfile (rcs, &fp);
a782 10
    if (rnode->access != NULL)
	free (rnode->access);
    if (rnode->locks_data != NULL)
	free (rnode->locks_data);
    if (rnode->locks != (List *) NULL)
	dellist (&rnode->locks);
    if (rnode->comment != NULL)
	free (rnode->comment);
    if (rnode->desc != NULL)
	free (rnode->desc);
d785 3
a787 3
/* free_rcsvers_contents -- free up the contents of an RCSVers node,
   but also free the pointer to the node itself. */

d789 3
a791 1
free_rcsvers_contents (rnode)
d793 3
a795 1
{
a807 4
    if (rnode->other_delta != NULL)
	dellist (&rnode->other_delta);
    if (rnode->text != NULL)
	freedeltatext (rnode->text);
a811 10
 * rcsvers_delproc - free up an RCSVers type node
 */
static void
rcsvers_delproc (p)
    Node *p;
{
    free_rcsvers_contents ((RCSVers *) p->data);
}

/*
d815 1
a815 2
 *    o skip whitespace
 *    o fill in key with everything up to next white 
d981 1
a981 2
	    /* Do not include any trailing whitespace in the value. */
	    if (c != ';')
d983 4
a986 8
		if (cur >= max)
		{
		    size_t curoff = cur - value;
		    expand_string (&value, &valsize, valsize + 1);
		    cur = value + curoff;
		    max = value + valsize;
		}
		*cur++ = ' ';
d988 1
a1098 53
/* Like getrcsrev, but don't die on error.  Return the last character
   read (last call to getc, which may be EOF).  TODO: implement getrcsrev
   in terms of this function. */
static int
getrevnum (fp, revp)
    FILE *fp;
    char **revp;
{
    char *cur;
    char *max;
    int c;

    *revp = NULL;
    do {
	c = getc (fp);
	if (c == EOF)
	    return c;
    } while (whitespace (c));

    if (!(isdigit (c) || c == '.'))
	return c;

    cur = key;
    max = key + keysize;
    while (isdigit (c) || c == '.')
    {
	if (cur >= max)
	{
	    size_t curoff = cur - key;
	    expand_string (&key, &keysize, keysize + 1);
	    cur = key + curoff;
	    max = key + keysize;
	}
	*cur = c;

	c = getc (fp);
	if (c == EOF)
	    break;
	cur++;
    }

    if (cur >= max)
    {
	size_t curoff = cur - key;
	expand_string (&key, &keysize, keysize + 1);
	cur = key + curoff;
	max = key + keysize;
    }
    *cur = '\0';
    *revp = key;
    return c;
}

a1139 42
 * process the locks list of the rcs file
 * Like do_symbols, but hash entries are keyed backwards: i.e.
 * an entry like `user:rev' is keyed on REV rather than on USER.
 */
static void
do_locks (list, val)
    List *list;
    char *val;
{
    Node *p;
    char *cp = val;
    char *user, *rev;

    for (;;)
    {
	/* skip leading whitespace */
	while (whitespace (*cp))
	    cp++;

	/* if we got to the end, we are done */
	if (*cp == '\0')
	    break;

	/* split it up into user and rev */
	user = cp;
	cp = strchr (cp, ':');
	*cp++ = '\0';
	rev = cp;
	while (!whitespace (*cp) && *cp != '\0')
	    cp++;
	if (*cp != '\0')
	    *cp++ = '\0';

	/* make a new node and add it to the list */
	p = getnode ();
	p->key = xstrdup (rev);
	p->data = xstrdup (user);
	(void) addnode (list, p);
    }
}

/*
d1201 1
a1201 1
	if (! RCS_nodeisbranch (rcs, tag))
a1234 2
 * 
 * Returns pointer to newly malloc'd string, or NULL.
d1254 1
a1254 1
	RCS_reparsercsfile (rcs, NULL);
a1485 2
    assert (rcs != NULL);

d1576 1
a1576 2
 * return NULL or RCS_head depending on force_tag_match.
 * Returns NULL or a newly malloc'd string.
d1594 1
a1594 1
	RCS_reparsercsfile (rcs, NULL);
a1692 78
/* Get the branch point for a particular branch, that is the first
   revision on that branch.  For example, RCS_getbranchpoint (rcs,
   "1.3.2") will normally return "1.3.2.1".  TARGET may be either a
   branch number or a revision number; if a revnum, find the
   branchpoint of the branch to which TARGET belongs.

   Return RCS_head if TARGET is on the trunk or if the root node could
   not be found (this is sort of backwards from our behavior on a branch;
   the rationale is that the return value is a revision from which you
   can start walking the next fields and end up at TARGET).
   Return NULL on error.  */

static char *
RCS_getbranchpoint (rcs, target)
    RCSNode *rcs;
    char *target;
{
    char *branch, *bp;
    Node *vp;
    RCSVers *rev;
    int dots, isrevnum, brlen;

    dots = numdots (target);
    isrevnum = dots & 1;

    if (dots == 1)
	/* TARGET is a trunk revision; return rcs->head. */
	return (RCS_head (rcs));

    /* Get the revision number of the node at which TARGET's branch is
       rooted.  If TARGET is a branch number, lop off the last field;
       if it's a revision number, lop off the last *two* fields. */
    branch = xstrdup (target);
    bp = strrchr (branch, '.');
    if (bp == NULL)
	error (1, 0, "%s: confused revision number %s",
	       rcs->path, target);
    if (isrevnum)
	while (*--bp != '.')
	    ;
    *bp = '\0';

    vp = findnode (rcs->versions, branch);
    if (vp == NULL)
    {	
	error (0, 0, "%s: can't find branch point %s", rcs->path, target);
	return NULL;
    }
    rev = (RCSVers *) vp->data;

    *bp++ = '.';
    while (*bp && *bp != '.')
	++bp;
    brlen = bp - branch;

    vp = rev->branches->list->next;
    while (vp != rev->branches->list)
    {
	/* BRANCH may be a genuine branch number, e.g. `1.1.3', or
	   maybe a full revision number, e.g. `1.1.3.6'.  We have
	   found our branch point if the first BRANCHLEN characters
	   of the revision number match, *and* if the following
	   character is a dot. */
	if (strncmp (vp->key, branch, brlen) == 0 && vp->key[brlen] == '.')
	    break;
	vp = vp->next;
    }

    free (branch);
    if (vp == rev->branches->list)
    {
	error (0, 0, "%s: can't find branch point %s", rcs->path, target);
	return NULL;
    }
    else
	return (xstrdup (vp->key));
}

d1695 1
a1695 2
 * branch, otherwise the real head.
 * Returns NULL or a newly malloc'd string.
d1733 1
a1733 1
	RCS_reparsercsfile (rcs, NULL);
d1820 1
a1820 1
	RCS_reparsercsfile (rcs, NULL);
d1832 1
a1832 2
    /* If no branches list, return now.  This is what happens if the branch
       is a (magic) branch with no revisions yet.  */
d1846 3
a1848 5
	/* This is what happens if the branch is a (magic) branch with
	   no revisions yet.  Similar to the case where vers->branches ==
	   NULL, except here there was a another branch off the same
	   branchpoint.  */
	return xstrdup (cur_rev);
d1914 1
a1914 1
	RCS_reparsercsfile (rcs, NULL);
d1937 1
d1941 5
d1955 1
d1957 3
a1969 19
RCS_getlocks (rcs)
    RCSNode *rcs;
{
    assert(rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    if (rcs->locks_data) {
	rcs->locks = getlist ();
	do_locks (rcs->locks, rcs->locks_data);
	free(rcs->locks_data);
	rcs->locks_data = NULL;
    }

    return rcs->locks;
}

List *
d1976 1
a1976 1
	RCS_reparsercsfile (rcs, NULL);
a1989 1
 * Returns NULL or a newly malloc'd string.
d1997 1
a1997 1
	RCS_reparsercsfile (rcs, NULL);
a2069 1
      "(Specify the --help global option for a list of other help options)\n",
d2076 5
d2143 1
a2143 1
	RCS_reparsercsfile (rcs, NULL);
d2164 1
a2164 1
	RCS_reparsercsfile (rcs, NULL);
d2341 1
a2341 1
    if (expand == KFLAG_KVL)
d2343 38
a2380 5
	Node *lock;
	lock = findnode (RCS_getlocks(rcs), ver->version);
	if (lock != NULL)
	    locker = xstrdup (lock->data);
    }
d2852 6
d2859 1
a2859 1
	    RCS_reparsercsfile (rcs, &fp);
d2907 1
a2907 1
	    RCS_reparsercsfile (rcs, &fp);
d3016 2
a3017 9
	    if (expand == KFLAG_B)
		cvs_output_binary (value, len);
	    else
	    {
		/* cvs_output requires the caller to check for zero
		   length.  */
		if (len > 0)
		    cvs_output (value, len);
	    }
d3021 5
a3025 24
	    /* NT 4.0 is said to have trouble writing 2099999 bytes
	       (for example) in a single fwrite.  So break it down
	       (there is no need to be writing that much at once
	       anyway; it is possible that LARGEST_FWRITE should be
	       somewhat larger for good performance, but for testing I
	       want to start with a small value until/unless a bigger
	       one proves useful).  */
#define LARGEST_FWRITE 8192
	    size_t nleft = len;
	    size_t nstep = (len < LARGEST_FWRITE ? len : LARGEST_FWRITE);
	    char *p = value;

	    while (nleft > 0)
	    {
		if (fwrite (p, 1, nstep, ofp) != nstep)
		    error (1, errno, "cannot write %s",
			   (workfile != NULL
			    ? workfile
			    : (sout != RUN_TTY ? sout : "stdout")));
		p += nstep;
		nleft -= nstep;
		if (nleft < nstep)
		    nstep = nleft;
	    }
a3051 788
static RCSVers *RCS_findlock_or_tip PROTO ((RCSNode *rcs));

/* Find the delta currently locked by the user.  From the `ci' man page:

	"If rev is omitted, ci tries to  derive  the  new  revision
	 number  from  the  caller's  last lock.  If the caller has
	 locked the tip revision of a branch, the new  revision  is
	 appended  to  that  branch.   The  new  revision number is
	 obtained by incrementing the tip revision number.  If  the
	 caller  locked a non-tip revision, a new branch is started
	 at that revision by incrementing the highest branch number
	 at  that  revision.   The default initial branch and level
	 numbers are 1.

	 If rev is omitted and the caller has no lock, but owns the
	 file  and  locking is not set to strict, then the revision
	 is appended to the default branch (normally the trunk; see
	 the -b option of rcs(1))."

   RCS_findlock_or_tip finds the unique revision locked by the caller
   and returns its delta node.  If the caller has not locked any
   revisions (and is permitted to commit to an unlocked delta, as
   described above), return the tip of the default branch. */

static RCSVers *
RCS_findlock_or_tip (rcs)
    RCSNode *rcs;
{
    char *user = getcaller();
    Node *lock, *p;
    List *locklist;

    /* Find unique delta locked by caller. This code is very similar
       to the code in RCS_unlock -- perhaps it could be abstracted
       into a RCS_findlock function. */
    locklist = RCS_getlocks (rcs);
    lock = NULL;
    for (p = locklist->list->next; p != locklist->list; p = p->next)
    {
	if (strcmp (p->data, user) == 0)
	{
	    if (lock != NULL)
	    {
		error (0, 0, "\
%s: multiple revisions locked by %s; please specify one", rcs->path, user);
		return NULL;
	    }
	    lock = p;
	}
    }

    if (lock != NULL)
    {
	/* Found an old lock, but check that the revision still exists. */
	p = findnode (rcs->versions, lock->key);
	if (p == NULL)
	{
	    error (0, 0, "%s: can't unlock nonexistent revision %s",
		   rcs->path,
		   lock->key);
	    return NULL;
	}
	return (RCSVers *) p->data;
    }

    /* No existing lock.  The RCS rule is that this is an error unless
       locking is nonstrict AND the file is owned by the current
       user.  Trying to determine the latter is a portability nightmare
       in the face of NT, VMS, AFS, and other systems with non-unix-like
       ideas of users and owners.  In the case of CVS, we should never get
       here (as long as the traditional behavior of making sure to call
       RCS_lock persists).  Anyway, we skip the RCS error checks
       and just return the default branch or head.  The reasoning is that
       those error checks are to make users lock before a checkin, and we do
       that in other ways if at all anyway (e.g. rcslock.pl).  */

    p = findnode (rcs->versions, RCS_getbranch (rcs, rcs->branch, 0));
    return (RCSVers *) p->data;
}

/* Revision number string, R, must contain a `.'.
   Return a newly-malloc'd copy of the prefix of R up
   to but not including the final `.'.  */

static char *
truncate_revnum (r)
    const char *r;
{
    size_t len;
    char *new_r;
    char *dot = strrchr (r, '.');

    assert (dot);
    len = dot - r;
    new_r = xmalloc (len + 1);
    memcpy (new_r, r, len);
    *(new_r + len) = '\0';
    return new_r;
}

/* Revision number string, R, must contain a `.'.
   R must be writable.  Replace the rightmost `.' in R with
   the NUL byte and return a pointer to that NUL byte.  */

static char *
truncate_revnum_in_place (r)
    char *r;
{
    char *dot = strrchr (r, '.');
    assert (dot);
    *dot = '\0';
    return dot;
}

/* Revision number strings, R and S, must each contain a `.'.
   R and S must be writable and must have the same number of dots.
   Truncate R and S for the comparison, then restored them to their
   original state.
   Return the result (see compare_revnums) of comparing R and S
   ignoring differences in any component after the rightmost `.'.  */

static int
compare_truncated_revnums (r, s)
    char *r;
    char *s;
{
    char *r_dot = truncate_revnum_in_place (r);
    char *s_dot = truncate_revnum_in_place (s);
    int cmp;

    assert (numdots (r) == numdots (s));

    cmp = compare_revnums (r, s);

    *r_dot = '.';
    *s_dot = '.';

    return cmp;
}

/* Return a malloc'd copy of the string representing the highest branch
   number on BRANCHNODE.  If there are no branches on BRANCHNODE, return NULL.
   FIXME: isn't the max rev always the last one?
   If so, we don't even need a loop.  */

static char *
max_rev (const RCSVers *branchnode)
{
    Node *head;
    Node *bp;
    char *max;

    if (branchnode->branches == NULL)
    {
        return NULL;
    }

    max = NULL;
    head = branchnode->branches->list;
    for (bp = head->next; bp != head; bp = bp->next)
    {
	if (max == NULL || compare_truncated_revnums (max, bp->key) < 0)
	{
	    max = bp->key;
	}
    }
    assert (max);

    return truncate_revnum (max);
}

/* Create BRANCH in RCS's delta tree.  BRANCH may be either a branch
   number or a revision number.  In the former case, create the branch
   with the specified number; in the latter case, create a new branch
   rooted at node BRANCH with a higher branch number than any others.
   Return the number of the tip node on the new branch. */

static char *
RCS_addbranch (rcs, branch)
    RCSNode *rcs;
    const char *branch;
{
    char *branchpoint, *newrevnum;
    Node *nodep, *bp;
    Node *marker;
    RCSVers *branchnode;

    /* Append to end by default.  */
    marker = NULL;

    branchpoint = xstrdup (branch);
    if ((numdots (branchpoint) & 1) == 0)
    {
	truncate_revnum_in_place (branchpoint);
    }

    /* Find the branch rooted at BRANCHPOINT. */
    nodep = findnode (rcs->versions, branchpoint);
    if (nodep == NULL)
    {
	error (0, 0, "%s: can't find branch point %s", rcs->path, branchpoint);
	return NULL;
    }
    branchnode = (RCSVers *) nodep->data;

    /* If BRANCH was a full branch number, make sure it is higher than MAX. */
    if ((numdots (branch) & 1) == 1)
    {
	if (branchnode->branches == NULL)
	{
	    /* We have to create the first branch on this node, which means
	       appending ".2" to the revision number. */
	    newrevnum = (char *) xmalloc (strlen (branch) + 3);
	    strcpy (newrevnum, branch);
	    strcat (newrevnum, ".2");
	}
	else
	{
	    char *max = max_rev (branchnode);
	    assert (max);
	    newrevnum = increment_revnum (max);
	    free (max);
	}
    }
    else
    {
	newrevnum = xstrdup (branch);

	if (branchnode->branches != NULL)
	{
	    Node *head;
	    Node *bp;

	    /* Find the position of this new branch in the sorted list
	       of branches.  */
	    head = branchnode->branches->list;
	    for (bp = head->next; bp != head; bp = bp->next)
	    {
		char *dot;
		int found_pos;

		/* The existing list must be sorted on increasing revnum.  */
		assert (bp->next == head
			|| compare_truncated_revnums (bp->key,
						      bp->next->key) < 0);
		dot = truncate_revnum_in_place (bp->key);
		found_pos = (compare_revnums (branch, bp->key) < 0);
		*dot = '.';

		if (found_pos)
		{
		    break;
		}
	    }
	    marker = bp;
	}
    }

    newrevnum = (char *) xrealloc (newrevnum, strlen (newrevnum) + 3);
    strcat (newrevnum, ".1");

    /* Add this new revision number to BRANCHPOINT's branches list. */
    if (branchnode->branches == NULL)
	branchnode->branches = getlist();
    bp = getnode();
    bp->key = xstrdup (newrevnum);

    /* Append to the end of the list by default, that is, just before
       the header node, `list'.  */
    if (marker == NULL)
	marker = branchnode->branches->list;

    {
	int fail;
	fail = insert_before (branchnode->branches, marker, bp);
	assert (!fail);
    }

    return newrevnum;
}

/* Check in to RCSFILE with revision REV (which must be greater than the
   largest revision) and message MESSAGE (which is checked for legality).
   If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.  If FLAGS &
   RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS & RCS_FLAGS_MODTIME,
   use the working file's modification time for the checkin time.
   WORKFILE is the working file to check in from, or NULL to use the usual
   RCS rules for deriving it from the RCSFILE.
   
   Return value is -1 for error (and errno is set to indicate the
   error), positive for error (and an error message has been printed),
   or zero for success.  */

/* TODO: RCS_checkin always unlinks the working file after checkin --
   then RCS_checkout checks it out again.  The logic should probably
   be reversed here. */

int
RCS_checkin (rcs, workfile, message, rev, flags)
    RCSNode *rcs;
    char *workfile;
    char *message;
    char *rev;
    int flags;
{
    RCSVers *delta, *commitpt;
    Deltatext *dtext;
    Node *nodep;
    char *tmpfile, *changefile, *chtext;
    char *diffopts;
    size_t bufsize;
    int buflen, chtextlen;
    int status, checkin_quiet, allocated_workfile;
    struct tm *ftm;
    time_t modtime;

    commitpt = NULL;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    /* Get basename of working file.  Is there a library function to
       do this?  I couldn't find one. -twp */
    allocated_workfile = 0;
    if (workfile == NULL)
    {
	char *p;
	int extlen = strlen (RCSEXT);
	workfile = xstrdup (last_component (rcs->path));
	p = workfile + (strlen (workfile) - extlen);
	assert (strncmp (p, RCSEXT, extlen) == 0);
	*p = '\0';
	allocated_workfile = 1;
    }

    checkin_quiet = flags & RCS_FLAGS_QUIET;
    if (!checkin_quiet)
    {
	cvs_output (rcs->path, 0);
	cvs_output ("  <--  ", 7);
	cvs_output (workfile, 0);
	cvs_output ("\n", 1);
    }

    /* Create new delta node. */
    delta = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (delta, 0, sizeof (RCSVers));
    delta->author = xstrdup (getcaller ());
    if (flags & RCS_FLAGS_MODTIME)
    {
	struct stat ws;
	if (stat (workfile, &ws) < 0)
	{
	    error (1, errno, "cannot stat %s", workfile);
	}
	modtime = ws.st_mtime;
    }
    else
	(void) time (&modtime);
    ftm = gmtime (&modtime);
    delta->date = (char *) xmalloc (MAXDATELEN);
    (void) sprintf (delta->date, DATEFORM,
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
    if (flags & RCS_FLAGS_DEAD)
    {
	delta->state = xstrdup (RCSDEAD);
	delta->dead = 1;
    }
    else
	delta->state = xstrdup ("Exp");

    /* Create a new deltatext node. */
    dtext = (Deltatext *) xmalloc (sizeof (Deltatext));
    memset (dtext, 0, sizeof (Deltatext));

    dtext->log = make_message_rcslegal (message);

    /* If the delta tree is empty, then there's nothing to link the
       new delta into.  So make a new delta tree, snarf the working
       file contents, and just write the new RCS file. */
    if (rcs->head == NULL)
    {
	char *newrev;
	FILE *fout;

	/* Figure out what the first revision number should be. */
	if (rev == NULL || *rev == '\0')
	    newrev = xstrdup ("1.1");
	else if (numdots (rev) == 0)
	{
	    newrev = (char *) xmalloc (strlen (rev) + 3);
	    strcpy (newrev, rev);
	    strcat (newrev, ".1");
	}
	else
	    newrev = xstrdup (rev);

	/* Don't need to xstrdup NEWREV because it's already dynamic, and
	   not used for anything else.  (Don't need to free it, either.) */
	rcs->head = newrev;
	delta->version = xstrdup (newrev);
	nodep = getnode();
	nodep->type = RCSVERS;
	nodep->key = xstrdup (newrev);
	nodep->data = (char *) delta;
	(void) addnode (rcs->versions, nodep);

	dtext->version = xstrdup (newrev);
	bufsize = 0;
	get_file(workfile, workfile, "r", &dtext->text, &bufsize, &dtext->len);

	if (!checkin_quiet)
	{
	    cvs_output ("initial revision: ", 0);
	    cvs_output (rcs->head, 0);
	    cvs_output ("\n", 1);
	}

	fout = rcs_internal_lockfile (rcs->path);
	RCS_putadmin (rcs, fout);
	RCS_putdtree (rcs, rcs->head, fout);
	RCS_putdesc (rcs, fout);
	rcs->delta_pos = ftell (fout);
	if (rcs->delta_pos == -1)
	    error (1, errno, "cannot ftell for %s", rcs->path);
	putdeltatext (fout, dtext);
	rcs_internal_unlockfile (fout, rcs->path);
	freedeltatext (dtext);

	/* Removing the file here is an RCS user-visible behavior which
	   we almost surely do not need in the CVS case.  In fact, getting
	   rid of it should clean up link_file and friends in import.c.  */
	if (unlink_file (workfile) < 0)
	    /* FIXME-update-dir: message does not include update_dir.  */
	    error (0, errno, "cannot remove %s", workfile);

	if (!checkin_quiet)
	    cvs_output ("done\n", 5);

	return 0;
    }

    /* Derive a new revision number.  From the `ci' man page:

	 "If rev  is  a revision number, it must be higher than the
	 latest one on the branch to which  rev  belongs,  or  must
	 start a new branch.

	 If  rev is a branch rather than a revision number, the new
	 revision is appended to that branch.  The level number  is
	 obtained  by  incrementing the tip revision number of that
	 branch.  If rev  indicates  a  non-existing  branch,  that
	 branch  is  created  with  the  initial  revision numbered
	 rev.1."

       RCS_findlock_or_tip handles the case where REV is omitted.
       RCS 5.7 also permits REV to be "$" or to begin with a dot, but
       we do not address those cases -- every routine that calls
       RCS_checkin passes it a numeric revision. */

    if (rev == NULL || *rev == '\0')
    {
	/* Figure out where the commit point is by looking for locks.
	   If the commit point is at the tip of a branch (or is the
	   head of the delta tree), then increment its revision number
	   to obtain the new revnum.  Otherwise, start a new
	   branch. */
	commitpt = RCS_findlock_or_tip (rcs);
	if (commitpt == NULL)
	{
	    status = 1;
	    goto checkin_done;
	}
	else if (commitpt->next == NULL
		 || strcmp (commitpt->version, rcs->head) == 0)
	    delta->version = increment_revnum (commitpt->version);
	else
	    delta->version = RCS_addbranch (rcs, commitpt->version);
    }
    else
    {
	/* REV is either a revision number or a branch number.  Find the
	   tip of the target branch. */
	char *branch, *tip, *newrev, *p;
	int dots, isrevnum;

	assert (isdigit(*rev));

	newrev = xstrdup (rev);
	dots = numdots (newrev);
	isrevnum = dots & 1;

	branch = xstrdup (rev);
	if (isrevnum)
	{
	    p = strrchr (branch, '.');
	    *p = '\0';
	}

	/* Find the tip of the target branch.  If we got a one- or two-digit
	   revision number, this will be the head of the tree.  Exception:
	   if rev is a single-field revision equal to the branch number of
	   the trunk (usually "1") then we want to treat it like an ordinary
	   branch revision. */
	if (dots == 0)
	{
	    tip = xstrdup (rcs->head);
	    if (atoi (tip) != atoi (branch))
	    {
		newrev = (char *) xrealloc (newrev, strlen (newrev) + 3);
		strcat (newrev, ".1");
		dots = isrevnum = 1;
	    }
	}
	else if (dots == 1)
	    tip = xstrdup (rcs->head);
	else
	    tip = RCS_getbranch (rcs, branch, 1);

	/* If the branch does not exist, and we were supplied an exact
	   revision number, signal an error.  Otherwise, if we were
	   given only a branch number, create it and set COMMITPT to
	   the branch point. */
	if (tip == NULL)
	{
	    if (isrevnum)
	    {
		error (0, 0, "%s: can't find branch point %s",
		       rcs->path, branch);
		free (branch);
		free (newrev);
		status = 1;
		goto checkin_done;
	    }
	    delta->version = RCS_addbranch (rcs, branch);
	    p = strrchr (branch, '.');
	    *p = '\0';
	    tip = xstrdup (branch);
	}
	else
	{
	    if (isrevnum)
	    {
		/* NEWREV must be higher than TIP. */
		if (compare_revnums (tip, newrev) >= 0)
		{
		    error (0, 0,
			   "%s: revision %s too low; must be higher than %s",
			   rcs->path,
			   newrev, tip);
		    free (branch);
		    free (newrev);
		    free (tip);
		    status = 1;
		    goto checkin_done;
		}
		delta->version = xstrdup (newrev);
	    }
	    else
		/* Just increment the tip number to get the new revision. */
		delta->version = increment_revnum (tip);
	}

	nodep = findnode (rcs->versions, tip);
	commitpt = (RCSVers *) nodep->data;

	free (branch);
	free (newrev);
	free (tip);
    }

    assert (delta->version != NULL);

    /* If COMMITPT is locked by us, break the lock.  If it's locked
       by someone else, signal an error. */
    nodep = findnode (RCS_getlocks (rcs), commitpt->version);
    if (nodep != NULL)
    {
	if (strcmp (nodep->data, delta->author) != 0)
	{
	    error (0, 0, "%s: revision %s locked by %s",
		   rcs->path,
		   nodep->key, nodep->data);
	    status = 1;
	    goto checkin_done;
	}
	delnode (nodep);
    }

    dtext->version = xstrdup (delta->version);

    /* Obtain the change text for the new delta.  If DELTA is to be the
       new head of the tree, then its change text should be the contents
       of the working file, and LEAFNODE's change text should be a diff.
       Else, DELTA's change text should be a diff between LEAFNODE and
       the working file. */

    tmpfile = cvs_temp_name();
    status = RCS_checkout (rcs, NULL, commitpt->version, NULL,
			   ((rcs->expand != NULL
			     && strcmp (rcs->expand, "b") == 0)
			    ? "-kb"
			    : "-ko"),
			   tmpfile,
			   (RCSCHECKOUTPROC)0, NULL);
    if (status != 0)
	error (1, status < 0 ? errno : 0,
	       "could not check out revision %s of `%s'",
	       commitpt->version, rcs->path);

    bufsize = buflen = 0;
    chtext = NULL;
    chtextlen = 0;
    changefile = cvs_temp_name();

    /* Diff options should include --binary if the RCS file has -kb set
       in its `expand' field. */
    diffopts = (rcs->expand != NULL && strcmp (rcs->expand, "b") == 0
		? "-a -n --binary"
		: "-a -n");

    if (strcmp (commitpt->version, rcs->head) == 0 &&
	numdots (delta->version) == 1)
    {
	/* If this revision is being inserted on the trunk, the change text
	   for the new delta should be the contents of the working file ... */
	bufsize = 0;
	get_file (workfile, workfile,
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
		  &dtext->text, &bufsize, &dtext->len);

	/* ... and the change text for the old delta should be a diff. */
	commitpt->text = (Deltatext *) xmalloc (sizeof (Deltatext));
	memset (commitpt->text, 0, sizeof (Deltatext));

	bufsize = 0;
	switch (diff_exec (workfile, tmpfile, diffopts, changefile))
	{
	    case 0:
	    case 1:
		break;
	    case -1:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, errno, "error diffing %s", workfile);
		break;
	    default:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, 0, "error diffing %s", workfile);
		break;
	}

	/* OK, the text file case here is really dumb.  Logically
	   speaking we want diff to read the files in text mode,
	   convert them to the canonical form found in RCS files
	   (which, we hope at least, is independent of OS--always
	   bare linefeeds), and then work with change texts in that
	   format.  However, diff_exec both generates change
	   texts and produces output for user purposes (e.g. patch.c),
	   and there is no way to distinguish between the two cases.
	   So we actually implement the text file case by writing the
	   change text as a text file, then reading it as a text file.
	   This should cause no harm, but doesn't strike me as
	   immensely clean.  */
	get_file (changefile, changefile,
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
		  &commitpt->text->text, &bufsize, &commitpt->text->len);

	/* If COMMITPT->TEXT->TEXT is NULL, it means that CHANGEFILE
	   was empty and that there are no differences between revisions.
	   In that event, we want to force RCS_rewrite to write an empty
	   string for COMMITPT's change text.  Leaving the change text
	   field set NULL won't work, since that means "preserve the original
	   change text for this delta." */
	if (commitpt->text->text == NULL)
	{
	    commitpt->text->text = xstrdup ("");
	    commitpt->text->len = 0;
	}
    }
    else
    {
	/* This file is not being inserted at the head, but on a side
	   branch somewhere.  Make a diff from the previous revision
	   to the working file. */
	switch (diff_exec (tmpfile, workfile, diffopts, changefile))
	{
	    case 0:
	    case 1:
		break;
	    case -1:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, errno, "error diffing %s", workfile);
		break;
	    default:
		/* FIXME-update-dir: message does not include update_dir.  */
		error (1, 0, "error diffing %s", workfile);
		break;
	}
	/* See the comment above, at the other get_file invocation,
	   regarding binary vs. text.  */
	get_file (changefile, changefile, 
		  rcs->expand != NULL && strcmp (rcs->expand, "b") == 0 ? "rb" : "r",
		  &dtext->text, &bufsize,
		  &dtext->len);
	if (dtext->text == NULL)
	{
	    dtext->text = xstrdup ("");
	    dtext->len = 0;
	}
    }

    /* Update DELTA linkage.  It is important not to do this before
       the very end of RCS_checkin; if an error arises that forces
       us to abort checking in, we must not have malformed deltas
       partially linked into the tree.

       If DELTA and COMMITPT are on different branches, do nothing --
       DELTA is linked to the tree through COMMITPT->BRANCHES, and we
       don't want to change `next' pointers.

       Otherwise, if the nodes are both on the trunk, link DELTA to
       COMMITPT; otherwise, link COMMITPT to DELTA. */

    if (numdots (commitpt->version) == numdots (delta->version))
    {
	if (strcmp (commitpt->version, rcs->head) == 0)
	{
	    delta->next = rcs->head;
	    rcs->head = xstrdup (delta->version);
	}
	else
	    commitpt->next = xstrdup (delta->version);
    }

    /* Add DELTA to RCS->VERSIONS. */
    if (rcs->versions == NULL)
	rcs->versions = getlist();
    nodep = getnode();
    nodep->type = RCSVERS;
    nodep->key = xstrdup (delta->version);
    nodep->data = (char *) delta;
    (void) addnode (rcs->versions, nodep);
	
    /* Write the new RCS file, inserting the new delta at COMMITPT. */
    if (!checkin_quiet)
    {
	cvs_output ("new revision: ", 14);
	cvs_output (delta->version, 0);
	cvs_output ("; previous revision: ", 21);
	cvs_output (commitpt->version, 0);
	cvs_output ("\n", 1);
    }

    RCS_rewrite (rcs, dtext, commitpt->version);

    /* Removing the file here is an RCS user-visible behavior which
       we almost surely do not need in the CVS case.  In fact, getting
       rid of it should clean up link_file and friends in import.c.  */
    if (unlink_file (workfile) < 0)
	/* FIXME-update-dir: message does not include update_dir.  */
	error (1, errno, "cannot remove %s", workfile);
    if (unlink_file (tmpfile) < 0)
	error (0, errno, "cannot remove %s", tmpfile);
    if (unlink_file (changefile) < 0)
	error (0, errno, "cannot remove %s", changefile);

    if (!checkin_quiet)
	cvs_output ("done\n", 5);

 checkin_done:
    if (allocated_workfile)
	free (workfile);

    if (commitpt != NULL && commitpt->text != NULL)
    {
	freedeltatext (commitpt->text);
	commitpt->text = NULL;
    }

    freedeltatext (dtext);
    if (status != 0)
	free_rcsvers_contents (delta);

    return status;
}

d3178 1
a3178 5
    List *symbols;
    Node *node;

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3193 35
a3227 27
    /* A revision number of NULL means use the head or default branch.
       If rev is not NULL, it may be a symbolic tag or branch number;
       expand it to the correct numeric revision or branch head. */
    if (rev == NULL)
	rev = rcs->branch ? rcs->branch : rcs->head;

    /* At this point rcs->symbol_data may not have been parsed.
       Calling RCS_symbols will force it to be parsed into a list
       which we can easily manipulate.  */
    symbols = RCS_symbols (rcs);
    if (symbols == NULL)
    {
	symbols = getlist ();
	rcs->symbols = symbols;
    }
    node = findnode (symbols, tag);
    if (node != NULL)
    {
	free (node->data);
	node->data = xstrdup (rev);
    }
    else
    {
	node = getnode ();
	node->key = xstrdup (tag);
	node->data = xstrdup (rev);
	(void) addnode_at_front (symbols, node);
d3229 3
d3236 3
a3238 3
/* Delete the symbolic tag TAG from the RCS file RCS.  Return 0 if
   the tag was found (and removed), or 1 if it was not present.  (In
   either case, the tag will no longer be in RCS->SYMBOLS.) */
d3241 1
a3241 1
RCS_deltag (rcs, tag)
d3244 1
d3246 13
a3258 4
    List *symbols;
    Node *node;
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3260 7
a3266 3
    symbols = RCS_symbols (rcs);
    if (symbols == NULL)
	return 1;
d3268 5
a3272 3
    node = findnode (symbols, tag);
    if (node == NULL)
	return 1;
d3274 2
a3275 1
    delnode (node);
d3287 1
a3287 2
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3294 4
d3302 4
d3309 2
a3310 1
/* Lock revision REV.  LOCK_QUIET is 1 to suppress output.  FIXME:
a3312 4
/* FIXME-twp: if a lock owned by someone else is broken, should this
   send mail to the lock owner?  Prompt user?  It seems like such an
   obscure situation for CVS as almost not worth worrying much
   about. */
d3315 1
a3315 1
RCS_lock (rcs, rev, lock_quiet)
d3318 1
a3318 1
     int lock_quiet;
d3320 1
a3320 4
    List *locks;
    Node *p;
    char *user;
    char *xrev = NULL;
d3322 7
a3328 2
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3330 1
a3330 71
    locks = RCS_getlocks (rcs);
    if (locks == NULL)
	locks = rcs->locks = getlist();
    user = getcaller();

    /* A revision number of NULL means lock the head or default branch. */
    if (rev == NULL)
	xrev = RCS_head (rcs);

    /* If rev is a branch number, lock the latest revision on that
       branch. I think that if the branch doesn't exist, it's
       okay to return 0 -- that just means that the branch is new,
       so we don't need to lock it anyway. -twp */
    else if (RCS_nodeisbranch (rcs, rev))
    {
	xrev = RCS_getbranch (rcs, (char *) rev, 1);
	if (xrev == NULL)
	{
	    if (!lock_quiet)
		error (0, 0, "%s: branch %s absent", rcs->path, rev);
	    return 1;
	}
    }

    if (xrev == NULL)
	xrev = xstrdup (rev);

    /* Make sure that the desired revision exists.  Technically,
       we can update the locks list without even checking this,
       but RCS 5.7 did this.  And it can't hurt. */
    if (findnode (rcs->versions, xrev) == NULL)
    {
	if (!lock_quiet)
	    error (0, 0, "%s: revision %s absent", rcs->path, xrev);
	free (xrev);
	return 1;
    }

    /* Is this rev already locked? */
    p = findnode (locks, xrev);
    if (p != NULL)
    {
	if (strcmp (p->data, user) == 0)
	{
	    /* We already own the lock on this revision, so do nothing. */
	    free (xrev);
	    return 0;
	}

	/* Break the lock. */	    
	if (!lock_quiet)
	{
	    cvs_output (rev, 0);
	    cvs_output (" unlocked\n", 0);
	}
	delnode (p);
    }

    /* Create a new lock. */
    p = getnode();
    p->key = xrev;	/* already xstrdupped */
    p->data = xstrdup (getcaller());
    (void) addnode_at_front (locks, p);

    if (!lock_quiet)
    {
	cvs_output (xrev, 0);
	cvs_output (" locked\n", 0);
    }

    return 0;
d3333 2
a3334 1
/* Unlock revision REV.  UNLOCK_QUIET is 1 to suppress output.  FIXME:
d3336 1
a3336 5
   ourselves.

   If REV is not null and is locked by someone else, break their
   lock and notify them.  It is an open issue whether RCS_unlock
   queries the user about whether or not to break the lock. */
d3339 1
a3339 1
RCS_unlock (rcs, rev, unlock_quiet)
d3342 1
a3342 1
     int unlock_quiet;
d3344 1
a3344 14
    Node *lock;
    List *locks;
    char *user;
    char *xrev = NULL;

    user = getcaller();
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    /* If rev is NULL, unlock the latest revision (first in
       rcs->locks) held by the caller. */
    if (rev == NULL)
    {
	Node *p;
d3346 7
a3352 78
	/* No-ops: attempts to unlock an empty tree or an unlocked file. */
	if (rcs->head == NULL)
	{
	    if (!unlock_quiet)
		cvs_outerr ("can't unlock an empty tree\n", 0);
	    return 0;
	}

	locks = RCS_getlocks (rcs);
	if (locks == NULL)
	{
	    if (!unlock_quiet)
		cvs_outerr ("No locks are set.\n", 0);
	    return 0;
	}

	lock = NULL;
	for (p = locks->list->next; p != locks->list; p = p->next)
	{
	    if (strcmp (p->data, user) == 0)
	    {
		if (lock != NULL)
		{
		    if (!unlock_quiet)
			error (0, 0, "\
%s: multiple revisions locked by %s; please specify one", rcs->path, user);
		    return 1;
		}
		lock = p;
	    }
	}
	if (lock == NULL)
	    return 0;	/* no lock found, ergo nothing to do */
	xrev = xstrdup (lock->key);
    }
    else if (RCS_nodeisbranch (rcs, rev))
    {
	/* If rev is a branch number, unlock the latest revision on that
	   branch. */
	xrev = RCS_getbranch (rcs, (char *) rev, 1);
	if (xrev == NULL)
	{
	    error (0, 0, "%s: branch %s absent", rcs->path, rev);
	    return 1;
	}
    }
    else
	/* REV is an exact revision number. */
	xrev = xstrdup (rev);

    lock = findnode (RCS_getlocks (rcs), xrev);
    if (lock == NULL)
    {
	/* This revision isn't locked. */
	free (xrev);
	return 0;
    }

    if (strcmp (lock->data, user) != 0)
    {
        /* If the revision is locked by someone else, notify
	   them.  Note that this shouldn't ever happen if RCS_unlock
	   is called with a NULL revision, since that means "whatever
	   revision is currently locked by the caller." */
	char *repos, *workfile;
	repos = xstrdup (rcs->path);
	workfile = strrchr (repos, '/');
	*workfile++ = '\0';
	notify_do ('C', workfile, user, NULL, NULL, repos);
	free (repos);
    }

    delnode (lock);
    if (!unlock_quiet)
    {
	cvs_output (xrev, 0);
	cvs_output (" unlocked\n", 0);
    }
a3353 1
    free (xrev);
d3356 2
d3359 4
a3362 7
/* Add USER to the access list of RCS.  Do nothing if already present.
   FIXME-twp: check syntax of USER to make sure it's a valid id. */

void
RCS_addaccess (rcs, user)
    RCSNode *rcs;
    char *user;
d3364 4
a3367 1
    char *access, *a;
d3369 1
a3369 2
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);
d3371 10
a3380 18
    if (rcs->access == NULL)
	rcs->access = xstrdup (user);
    else
    {
	access = xstrdup (rcs->access);
	for (a = strtok (access, " "); a != NULL; a = strtok (NULL, " "))
	{
	    if (strcmp (a, user) == 0)
	    {
		free (access);
		return;
	    }
	}
	rcs->access = (char *) xrealloc
	    (rcs->access, strlen (rcs->access) + strlen (user) + 2);
	strcat (rcs->access, " ");
	strcat (rcs->access, user);
    }
d3383 1
a3383 1
/* Remove USER from the access list of RCS. */
d3385 2
a3386 4
void
RCS_delaccess (rcs, user)
    RCSNode *rcs;
    char *user;
d3388 2
a3389 2
    char *p, *s;
    int ulen;
d3391 1
a3391 8
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    if (rcs->access == NULL)
	return;

    p = rcs->access;
    ulen = strlen (user);
d3394 4
a3397 112
	if (p[ulen] == '\0' || p[ulen] == ' ')
	    if (strncmp (p, user, ulen) == 0)
		break;
	p = strchr (p, ' ');
	if (p != NULL)
	    ++p;
    }

    if (p == NULL)
	return;

    s = p + ulen;
    while (*s != '\0')
	*p++ = *s++;
    *p = '\0';
}

char *
RCS_getaccess (rcs)
    RCSNode *rcs;
{
    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, NULL);

    return rcs->access;
}

static int findtag PROTO ((Node *, void *));

/* Return a nonzero value if the revision specified by ARG is found.  */

static int
findtag (node, arg)
    Node *node;
    void *arg;
{
    char *rev = (char *)arg;

    if (strcmp (node->data, rev) == 0)
	return 1;
    else
	return 0;
}

/* Delete revisions between REV1 and REV2.  The changes between the two
   revisions must be collapsed, and the result stored in the revision
   immediately preceding the lower one.  Return 0 for successful completion,
   1 otherwise.

   Solution: check out the revision preceding REV1 and the revision
   following REV2.  Use call_diff to find aggregate diffs between
   these two revisions, and replace the delta text for the latter one
   with the new aggregate diff.  Alternatively, we could write a
   function that takes two change texts and combines them to produce a
   new change text, without checking out any revs or calling diff.  It
   would be hairy, but so, so cool.

   If INCLUSIVE is set, then TAG1 and TAG2, if non-NULL, tell us to
   delete that revision as well (cvs admin -o tag1:tag2).  If clear,
   delete up to but not including that revision (cvs admin -o tag1::tag2).
   This does not affect TAG1 or TAG2 being NULL; the meaning of the start
   point in ::tag2 and :tag2 is the same and likewise for end points.  */

int
RCS_delete_revs (rcs, tag1, tag2, inclusive)
    RCSNode *rcs;
    char *tag1;
    char *tag2;
    int inclusive;
{
    char *next;
    Node *nodep;
    RCSVers *revp = NULL;
    RCSVers *beforep;
    int status, found;
    int save_noexec;

    char *branchpoint = NULL;
    char *rev1 = NULL;
    char *rev2 = NULL;
    int rev1_inclusive = inclusive;
    int rev2_inclusive = inclusive;
    char *before = NULL;
    char *after = NULL;
    char *beforefile = NULL;
    char *afterfile = NULL;
    char *outfile = NULL;

    if (tag1 == NULL && tag2 == NULL)
	return 0;

    /* Assume error status until everything is finished. */
    status = 1;

    /* Make sure both revisions exist. */
    if (tag1 != NULL)
    {
	rev1 = RCS_gettag (rcs, tag1, 1, NULL);
	if (rev1 == NULL || (nodep = findnode (rcs->versions, rev1)) == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, tag1);
	    goto delrev_done;
	}
    }
    if (tag2 != NULL)
    {
	rev2 = RCS_gettag (rcs, tag2, 1, NULL);
	if (rev2 == NULL || (nodep = findnode (rcs->versions, rev2)) == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, tag2);
	    goto delrev_done;
	}
d3399 1
a3399 432

    /* If rev1 is on the trunk and rev2 is NULL, rev2 should be
       RCS->HEAD.  (*Not* RCS_head(rcs), which may return rcs->branch
       instead.)  We need to check this special case early, in order
       to make sure that rev1 and rev2 get ordered correctly. */
    if (rev2 == NULL && numdots (rev1) == 1)
    {
	rev2 = xstrdup (rcs->head);
	rev2_inclusive = 1;
    }

    if (rev2 == NULL)
	rev2_inclusive = 1;

    if (rev1 != NULL && rev2 != NULL)
    {
	/* A range consisting of a branch number means the latest revision
	   on that branch. */
	if (RCS_isbranch (rcs, rev1) && strcmp (rev1, rev2) == 0)
	    rev1 = rev2 = RCS_getbranch (rcs, rev1, 0);
	else
	{
	    /* Make sure REV1 and REV2 are ordered correctly (in the
	       same order as the next field).  For revisions on the
	       trunk, REV1 should be higher than REV2; for branches,
	       REV1 should be lower.  */
	    /* Shouldn't we just be giving an error in the case where
	       the user specifies the revisions in the wrong order
	       (that is, always swap on the trunk, never swap on a
	       branch, in the non-error cases)?  It is not at all
	       clear to me that users who specify -o 1.4:1.2 really
	       meant to type -o 1.2:1.4, and the out of order usage
	       has never been documented, either by cvs.texinfo or
	       rcs(1).  */
	    char *temp;
	    int temp_inclusive;
	    if (numdots (rev1) == 1)
	    {
		if (compare_revnums (rev1, rev2) <= 0)
		{
		    temp = rev2;
		    rev2 = rev1;
		    rev1 = temp;

		    temp_inclusive = rev2_inclusive;
		    rev2_inclusive = rev1_inclusive;
		    rev1_inclusive = temp_inclusive;
		}
	    }
	    else if (compare_revnums (rev1, rev2) > 0)
	    {
		temp = rev2;
		rev2 = rev1;
		rev1 = temp;

		temp_inclusive = rev2_inclusive;
		rev2_inclusive = rev1_inclusive;
		rev1_inclusive = temp_inclusive;
	    }
	}
    }

    /* Basically the same thing; make sure that the ordering is what we
       need.  */
    if (rev1 == NULL)
    {
	assert (rev2 != NULL);
	if (numdots (rev2) == 1)
	{
	    /* Swap rev1 and rev2.  */
	    int temp_inclusive;

	    rev1 = rev2;
	    rev2 = NULL;

	    temp_inclusive = rev2_inclusive;
	    rev2_inclusive = rev1_inclusive;
	    rev1_inclusive = temp_inclusive;
	}
    }

    /* Put the revision number preceding the first one to delete into
       BEFORE (where "preceding" means according to the next field).
       If the first revision to delete is the first revision on its
       branch (e.g. 1.3.2.1), BEFORE should be the node on the trunk
       at which the branch is rooted.  If the first revision to delete
       is the head revision of the trunk, set BEFORE to NULL.

       Note that because BEFORE may not be on the same branch as REV1,
       it is not very handy for navigating the revision tree.  It's
       most useful just for checking out the revision preceding REV1. */
    before = NULL;
    branchpoint = RCS_getbranchpoint (rcs, rev1 != NULL ? rev1 : rev2);
    if (rev1 == NULL)
    {
	rev1 = xstrdup (branchpoint);
	if (numdots (branchpoint) > 1)
	{
	    char *bp;
	    bp = strrchr (branchpoint, '.');
	    while (*--bp != '.')
		;
	    *bp = '\0';
	    /* Note that this is exclusive, always, because the inclusive
	       flag doesn't affect the meaning when rev1 == NULL.  */
	    before = xstrdup (branchpoint);
	    *bp = '.';
	}
    }
    else if (strcmp (rev1, branchpoint) != 0)
    {
	/* Walk deltas from BRANCHPOINT on, looking for REV1. */
	nodep = findnode (rcs->versions, branchpoint);
	revp = (RCSVers *) nodep->data;
	while (revp->next != NULL && strcmp (revp->next, rev1) != 0)
	{
	    revp = (RCSVers *) nodep->data;
	    nodep = findnode (rcs->versions, revp->next);
	}
	if (revp->next == NULL)
	{
	    error (0, 0, "%s: Revision %s doesn't exist.", rcs->path, rev1);
	    goto delrev_done;
	}
	if (rev1_inclusive)
	    before = xstrdup (revp->version);
	else
	{
	    before = rev1;
	    nodep = findnode (rcs->versions, before);
	    rev1 = xstrdup (((RCSVers *)nodep->data)->next);
	}
    }
    else if (!rev1_inclusive)
    {
	before = rev1;
	nodep = findnode (rcs->versions, before);
	rev1 = xstrdup (((RCSVers *)nodep->data)->next);
    }
    else if (numdots (branchpoint) > 1)
    {
	/* Example: rev1 is "1.3.2.1", branchpoint is "1.3.2.1".
	   Set before to "1.3".  */
	char *bp;
	bp = strrchr (branchpoint, '.');
	while (*--bp != '.')
	    ;
	*bp = '\0';
	before = xstrdup (branchpoint);
	*bp = '.';
    }

    /* If any revision between REV1 and REV2 is locked or is a branch point,
       we can't delete that revision and must abort. */
    after = NULL;
    next = rev1;
    found = 0;
    while (!found && next != NULL)
    {
	nodep = findnode (rcs->versions, next);
	revp = (RCSVers *) nodep->data;

	if (rev2 != NULL)
	    found = (strcmp (revp->version, rev2) == 0);
	next = revp->next;

	if ((!found && next != NULL) || rev2_inclusive || rev2 == NULL)
	{
	    if (findnode (RCS_getlocks (rcs), revp->version))
	    {
		error (0, 0, "%s: can't remove locked revision %s",
		       rcs->path,
		       revp->version);
		goto delrev_done;
	    }
	    if (revp->branches != NULL)
	    {
		error (0, 0, "%s: can't remove branch point %s",
		       rcs->path,
		       revp->version);
		goto delrev_done;
	    }

	    /* Doing this only for the :: syntax is for compatibility.
	       See cvs.texinfo for somewhat more discussion.  */
	    if (!inclusive
		&& walklist (RCS_symbols (rcs), findtag, revp->version))
	    {
		/* We don't print which file this happens to on the theory
		   that the caller will print the name of the file in a
		   more useful fashion (fullname not rcs->path).  */
		error (0, 0, "cannot remove revision %s because it has tags",
		       revp->version);
		goto delrev_done;
	    }

	    /* It's misleading to print the `deleting revision' output
	       here, since we may not actually delete these revisions.
	       But that's how RCS does it.  Bleah.  Someday this should be
	       moved to the point where the revs are actually marked for
	       deletion. -twp */
	    cvs_output ("deleting revision ", 0);
	    cvs_output (revp->version, 0);
	    cvs_output ("\n", 1);
	}
    }

    if (rev2 == NULL)
	;
    else if (found)
    {
	if (rev2_inclusive)
	    after = xstrdup (next);
	else
	    after = xstrdup (revp->version);
    }
    else if (!inclusive)
    {
	/* In the case of an empty range, for example 1.2::1.2 or
	   1.2::1.3, we want to just do nothing.  */
	status = 0;
	goto delrev_done;
    }
    else
    {
	/* This looks fishy in the cases where tag1 == NULL or tag2 == NULL.
	   Are those cases really impossible?  */
	assert (tag1 != NULL);
	assert (tag2 != NULL);

	error (0, 0, "%s: invalid revision range %s:%s", rcs->path,
	       tag1, tag2);
	goto delrev_done;
    }

    /* The conditionals at this point get really hairy.  Here is the
       general idea:

       IF before != NULL and after == NULL
         THEN don't check out any revisions, just delete them
       IF before == NULL and after != NULL
         THEN only check out after's revision, and use it for the new deltatext
       ELSE
         check out both revisions and diff -n them.  This could use
	 RCS_exec_rcsdiff with some changes, like being able
	 to suppress diagnostic messages and to direct output. */

    assert (before != NULL || after != NULL);

    if (after != NULL)
    {
	char *diffbuf;
	size_t bufsize, len;

	afterfile = cvs_temp_name();
	status = RCS_checkout (rcs, NULL, after, NULL, NULL, afterfile,
			       (RCSCHECKOUTPROC)0, NULL);
	if (status > 0)
	    goto delrev_done;

	else if (status < 0)
	{
	    error (0, errno,
		   "cannot check out revision %s of %s", after, rcs->path);
	    goto delrev_done;
	}

	if (before == NULL)
	{
	    /* We are deleting revisions from the head of the tree,
	       so must create a new head. */
	    diffbuf = NULL;
	    bufsize = 0;
	    get_file (afterfile, afterfile, "r", &diffbuf, &bufsize, &len);

	    save_noexec = noexec;
	    noexec = 0;
	    if (unlink_file (afterfile) < 0)
		error (0, errno, "cannot remove %s", afterfile);
	    noexec = save_noexec;

	    free (afterfile);
	    afterfile = NULL;

	    free (rcs->head);
	    rcs->head = xstrdup (after);
	}
	else
	{
	    beforefile = cvs_temp_name();
	    status = RCS_checkout (rcs, NULL, before, NULL, NULL, beforefile,
				   (RCSCHECKOUTPROC)0, NULL);
	    if (status > 0)
		goto delrev_done;
	    else if (status < 0)
	    {
		error (0, errno, "cannot check out revision %s of %s",
		       before, rcs->path);
		goto delrev_done;
	    }

	    outfile = cvs_temp_name();
	    status = diff_exec (beforefile, afterfile, "-n", outfile);

	    if (status == 2)
	    {
		/* Not sure we need this message; will diff_exec already
		   have printed an error?  */
		error (0, 0, "%s: could not diff", rcs->path);
		status = 1;
		goto delrev_done;
	    }

	    diffbuf = NULL;
	    bufsize = 0;
	    get_file (outfile, outfile, "r", &diffbuf, &bufsize, &len);
	}

	/* Save the new change text in after's delta node. */
	nodep = findnode (rcs->versions, after);
	revp = (RCSVers *) nodep->data;

	assert (revp->text == NULL);

	revp->text = (Deltatext *) xmalloc (sizeof (Deltatext));
	memset ((Deltatext *) revp->text, 0, sizeof (Deltatext));
	revp->text->version = xstrdup (revp->version);
	revp->text->text = diffbuf;
	revp->text->len = len;

	/* If DIFFBUF is NULL, it means that OUTFILE is empty and that
	   there are no differences between the two revisions.  In that
	   case, we want to force RCS_copydeltas to write an empty string
	   for the new change text (leaving the text field set NULL
	   means "preserve the original change text for this delta," so
	   we don't want that). */
	if (revp->text->text == NULL)
	    revp->text->text = xstrdup ("");
    }

    /* Walk through the revisions (again) to mark each one as
       outdated.  (FIXME: would it be safe to use the `dead' field for
       this?  Doubtful.) */
    for (next = rev1;
	 next != NULL && (after == NULL || strcmp (next, after) != 0);
	 next = revp->next)
    {
	nodep = findnode (rcs->versions, next);
	revp = (RCSVers *) nodep->data;
	revp->outdated = 1;
    }

    /* Update delta links.  If BEFORE == NULL, we're changing the
       head of the tree and don't need to update any `next' links. */
    if (before != NULL)
    {
	/* If REV1 is the first node on its branch, then BEFORE is its
	   root node (on the trunk) and we have to update its branches
	   list.  Otherwise, BEFORE is on the same branch as AFTER, and
	   we can just change BEFORE's `next' field to point to AFTER.
	   (This should be safe: since findnode manages its lists via
	   the `hashnext' and `hashprev' fields, rather than `next' and
	   `prev', mucking with `next' and `prev' should not corrupt the
	   delta tree's internal structure.  Much. -twp) */

	if (rev1 == NULL)
	    /* beforep's ->next field already should be equal to after,
	       which I think is always NULL in this case.  */
	    ;
	else if (strcmp (rev1, branchpoint) == 0)
	{
	    nodep = findnode (rcs->versions, before);
	    revp = (RCSVers *) nodep->data;
	    nodep = revp->branches->list->next;
	    while (nodep != revp->branches->list &&
		   strcmp (nodep->key, rev1) != 0)
		nodep = nodep->next;
	    assert (nodep != revp->branches->list);
	    if (after == NULL)
		delnode (nodep);
	    else
	    {
		free (nodep->key);
		nodep->key = xstrdup (after);
	    }
	}
	else
	{
	    nodep = findnode (rcs->versions, before);
	    beforep = (RCSVers *) nodep->data;
	    free (beforep->next);
	    beforep->next = xstrdup (after);
	}
    }

    status = 0;

 delrev_done:
    if (rev1 != NULL)
	free (rev1);
    if (rev2 != NULL)
	free (rev2);
    if (branchpoint != NULL)
	free (branchpoint);
    if (before != NULL)
	free (before);
    if (after != NULL)
	free (after);

    save_noexec = noexec;
    noexec = 0;
    if (beforefile != NULL)
    {
	if (unlink_file (beforefile) < 0)
	    error (0, errno, "cannot remove %s", beforefile);
	free (beforefile);
    }
    if (afterfile != NULL)
    {
	if (unlink_file (afterfile) < 0)
	    error (0, errno, "cannot remove %s", afterfile);
	free (afterfile);
    }
    if (outfile != NULL)
    {
	if (unlink_file (outfile) < 0)
	    error (0, errno, "cannot remove %s", outfile);
	free (outfile);
    }
    noexec = save_noexec;

    return status;
a3400 2

/* RCS_deltas and friends.  Processing of the deltas in RCS files.  */
d3404 1
a3404 4
    /* Text of this line.  Part of the same malloc'd block as the struct
       line itself (we probably should use the "struct hack" (char text[1])
       and save ourselves sizeof (char *) bytes).  Does not include \n;
       instead has_newline indicates the presence or absence of \n.  */
a3412 2
    /* Number of pointers to this struct line.  */
    int refcount;
d3437 1
a3437 1
static int linevector_add PROTO ((struct linevector *vec, const char *text,
d3443 3
a3445 2
   not be \n terminated.
   Set the version for each of the new lines to VERS.  This
d3447 1
a3447 5
   number is out of range.

   Each of the lines in TEXT are copied to space which is managed with
   the linevector (and freed by linevector_free).  So the caller doesn't
   need to keep TEXT around after the call to this function.  */
d3451 1
a3451 1
    const char *text;
d3456 1
a3456 1
    const char *textend;
d3459 2
a3460 5
    const char *p;
    const char *nextline_text;
    size_t nextline_len;
    int nextline_newline;
    struct line *q;
d3472 2
d3493 1
a3493 1
    /* Actually add the lines, to VEC->VECTOR.  */
d3495 4
a3498 2
    nextline_text = text;
    nextline_newline = 0;
d3502 2
a3503 1
	    nextline_newline = 1;
d3508 8
a3515 23
	    nextline_len = p - nextline_text;
	    q = (struct line *) xmalloc (sizeof (struct line) + nextline_len);
	    q->vers = vers;
	    q->text = (char *)q + sizeof (struct line);
	    q->len = nextline_len;
	    q->has_newline = nextline_newline;
	    q->refcount = 1;
	    memcpy (q->text, nextline_text, nextline_len);
	    vec->vector[i++] = q;

	    nextline_text = (char *)p + 1;
	    nextline_newline = 0;
	}
    nextline_len = p - nextline_text;
    q = (struct line *) xmalloc (sizeof (struct line) + nextline_len);
    q->vers = vers;
    q->text = (char *)q + sizeof (struct line);
    q->len = nextline_len;
    q->has_newline = nextline_newline;
    q->refcount = 1;
    memcpy (q->text, nextline_text, nextline_len);
    vec->vector[i] = q;

a3535 5
    for (i = pos; i < pos + nlines; ++i)
    {
	if (--vec->vector[i]->refcount == 0)
	    free (vec->vector[i]);
    }
a3548 7
    unsigned int ln;

    for (ln = 0; ln < to->nlines; ++ln)
    {
	if (--to->vector[ln]->refcount == 0)
	    free (to->vector[ln]);
    }
a3560 2
    for (ln = 0; ln < to->nlines; ++ln)
	++to->vector[ln]->refcount;
d3565 2
a3566 1
/* Free storage associated with linevector.  */
a3570 2
    unsigned int ln;

a3571 5
    {
	for (ln = 0; ln < vec->nlines; ++ln)
	    if (--vec->vector[ln]->refcount == 0)
		free (vec->vector[ln]);

a3572 1
    }
d3633 1
a3633 1
	const char *new_lines;
d3686 3
a3688 2
	    /* Stash away a pointer to the text we are adding.  */
	    df->new_lines = p;
d3738 3
a3740 3
   and *RETLEN.  The new buffer is allocated by xmalloc.

   Return 1 for success.  On failure, call error and return 0.  */
d3798 5
d3854 13
a3866 5
	fp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	if (fp == NULL)
	    error (1, 0, "unable to reopen `%s'", rcs->path);
	if (fseek (fp, rcs->delta_pos, SEEK_SET) != 0)
	    error (1, 0, "cannot fseek RCS file");
d3943 6
a3948 1
		    if (! linevector_add (&curlines, value, vallen, NULL, 0))
d4087 1
a4087 12
		    {
			/* ??- is an ANSI trigraph.  The ANSI way to
			   avoid it is \? but some pre ANSI compilers
			   complain about the unrecognized escape
			   sequence.  Of course string concatenation
			   ("??" "-???") is also an ANSI-ism.  Testing
			   __STDC__ seems to be a can of worms, since
			   compilers do all kinds of things with it.  */
			cvs_output ("??", 0);
			cvs_output ("-???", 0);
			cvs_output ("-??", 0);
		    }
d4105 2
a4106 3
		    if (headlines.vector[ln]->len != 0)
			cvs_output (headlines.vector[ln]->text,
				    headlines.vector[ln]->len);
d4144 1
a4153 714

static RCSVers *
getdelta (fp, rcsfile)
    FILE *fp;
    char *rcsfile;
{
    RCSVers *vnode;
    char *key, *value, *cp;
    long fpos;
    Node *kv;

    vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (vnode, 0, sizeof (RCSVers));

    /* Get revision number. This uses getrcskey because it doesn't
       croak when encountering unexpected input.  As a result, we have
       to play unholy games with `key' and `value'. */
    fpos = ftell (fp);
    getrcskey (fp, &key, &value, NULL);

    /* Make sure that it is a revision number and not a cabbage 
       or something. */
    for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
	/* do nothing */ ;
    if (*cp != '\0' || strncmp (RCSDATE, value, strlen (RCSDATE)) != 0)
    {
	(void) fseek (fp, fpos, SEEK_SET);
	free (vnode);
	return NULL;
    }
    vnode->version = xstrdup (key);

    /* grab the value of the date from value */
    cp = value + strlen (RCSDATE);/* skip the "date" keyword */
    while (whitespace (*cp))		/* take space off front of value */
	cp++;

    vnode->date = xstrdup (cp);

    /* Get author field.  */
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be using errno in case of ferror.  */
    if (key == NULL || strcmp (key, "author") != 0)
	error (1, 0, "\
unable to parse rcs file; `author' not in the expected place");
    vnode->author = xstrdup (value);

    /* Get state field.  */
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be using errno in case of ferror.  */
    if (key == NULL || strcmp (key, "state") != 0)
	error (1, 0, "\
unable to parse rcs file; `state' not in the expected place");
    vnode->state = xstrdup (value);
    if (strcmp (value, "dead") == 0)
    {
	vnode->dead = 1;
    }

    /* Note that "branches" and "next" are in fact mandatory, according
       to doc/RCSFILES.  We perhaps should be giving an error if they
       are not there.  */

    /* fill in the branch list (if any branches exist) */
    fpos = ftell (fp);
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be handling various error conditions better.  */
    if (key != NULL && strcmp (key, RCSDESC) == 0)
    {
	(void) fseek (fp, fpos, SEEK_SET);
	return vnode;
    }
    if (value != (char *) NULL)
    {
	vnode->branches = getlist ();
	do_branches (vnode->branches, value);
    }

    /* fill in the next field if there is a next revision */
    fpos = ftell (fp);
    (void) getrcskey (fp, &key, &value, NULL);
    /* FIXME: should be handling various error conditions better.  */
    if (key != NULL && strcmp (key, RCSDESC) == 0)
    {
	(void) fseek (fp, fpos, SEEK_SET);
	return vnode;
    }
    if (value != (char *) NULL)
	vnode->next = xstrdup (value);

    /*
     * XXX - this is where we put the symbolic link stuff???
     * (into newphrases in the deltas).
     */
    /* FIXME: Does not correctly handle errors, e.g. from stdio.  */
    while (1)
    {
	fpos = ftell (fp);
	if (getrcskey (fp, &key, &value, NULL) < 0)
	    break;

	assert (key != NULL);

	if (strcmp (key, RCSDESC) == 0)
	    break;

	/* Enable use of repositories created by certain obsolete
	   versions of CVS.  This code should remain indefinately;
	   there is no procedure for converting old repositories, and
	   checking for it is harmless.  */
	if (strcmp(key, RCSDEAD) == 0)
	{
	    vnode->dead = 1;
	    if (vnode->state != NULL)
		free (vnode->state);
	    vnode->state = xstrdup ("dead");
	    continue;
	}
	/* if we have a new revision number, we're done with this delta */
	for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
	    /* do nothing */ ;
	if (*cp == '\0' && strncmp (RCSDATE, value, strlen (RCSDATE)) == 0)
	    break;

	/* At this point, key and value represent a user-defined field
	   in the delta node. */
	if (vnode->other_delta == NULL)
	    vnode->other_delta = getlist ();
	kv = getnode ();
	kv->type = RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = xstrdup (value);
	if (addnode (vnode->other_delta, kv) != 0)
	{
	    /* Complaining about duplicate keys in newphrases seems
	       questionable, in that we don't know what they mean and
	       doc/RCSFILES has no prohibition on several newphrases
	       with the same key.  But we can't store more than one as
	       long as we store them in a List *.  */
	    error (0, 0, "warning: duplicate key `%s' in RCS file `%s'",
		   key, rcsfile);
	    freenode (kv);
	}
     }

    /* We got here because we read beyond the end of a delta.  Seek back
       to the beginning of the erroneous read. */
    (void) fseek (fp, fpos, SEEK_SET);

    return vnode;
}

static void
freedeltatext (d)
    Deltatext *d;
{
    if (d->version != NULL)
	free (d->version);
    if (d->log != NULL)
	free (d->log);
    if (d->text != NULL)
	free (d->text);
    if (d->other != (List *) NULL)
	dellist (&d->other);
    free (d);
}

static Deltatext *
RCS_getdeltatext (rcs, fp)
    RCSNode *rcs;
    FILE *fp;
{
    char *num;
    char *key, *value;
    int n;
    Node *p;
    Deltatext *d;
    size_t textlen;

    /* Get the revision number. */
    n = getrevnum (fp, &num);
    if (ferror (fp))
	error (1, errno, "%s: cannot read", rcs->path);
    if (n == EOF)
    {
	/* If n == EOF and num == NULL, it means we reached EOF
	   naturally.  That's fine. */
	if (num == NULL)
	    return NULL;
	else
	    error (1, 0, "%s: unexpected EOF", rcs->path);
    }

    p = findnode (rcs->versions, num);
    if (p == NULL)
	error (1, 0, "mismatch in rcs file %s between deltas and deltatexts",
	       rcs->path);

    d = (Deltatext *) xmalloc (sizeof (Deltatext));
    d->version = xstrdup (num);

    /* Get the log message. */
    if (getrcskey (fp, &key, &value, NULL) < 0)
	error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);
    if (strcmp (key, "log") != 0)
	error (1, 0, "%s, delta %s: expected `log', got `%s'",
	       rcs->path, num, key);
    d->log = xstrdup (value);

    /* Get random newphrases. */
    d->other = getlist();
    for (n = getrcskey (fp, &key, &value, &textlen);
	 n >= 0 && strcmp (key, "text") != 0;
	 n = getrcskey (fp, &key, &value, &textlen))
    {
	p = getnode();
	p->type = RCSFIELD;
	p->key = xstrdup (key);
	p->data = xstrdup (value);
	if (addnode (d->other, p) < 0)
	{
	    error (0, 0, "warning: %s, delta %s: duplicate field `%s'",
		   rcs->path, num, key);
	}
    }
    if (n < 0)
	error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);

    /* Get the change text. We already know that this key is `text'. */
    d->text = (char *) malloc (textlen + 1);
    d->len = textlen;
    memcpy (d->text, value, textlen);

    return d;
}

/* RCS output functions, for writing RCS format files from RCSNode
   structures.

   For most of this work, RCS 5.7 uses an `aprintf' function which aborts
   program upon error.  Instead, these functions check the output status
   of the stream right before closing it, and aborts if an error condition
   is found.  The RCS solution is probably the better one: it produces
   more overhead, but will produce a clearer diagnostic in the case of
   catastrophic error.  In either case, however, the repository will probably
   not get corrupted. */

static int
putsymbol_proc (symnode, fp)
    Node *symnode;
    void *fp;
{
    return fprintf ((FILE *) fp, "\n\t%s:%s", symnode->key, symnode->data);
}

static int putlock_proc PROTO ((Node *, void *));

/* putlock_proc is like putsymbol_proc, but key and data are reversed. */

static int
putlock_proc (symnode, fp)
    Node *symnode;
    void *fp;
{
    return fprintf ((FILE *) fp, "\n\t%s:%s", symnode->data, symnode->key);
}

static int
putrcsfield_proc (node, vfp)
    Node *node;
    void *vfp;
{
    FILE *fp = (FILE *) vfp;

    /* Some magic keys used internally by CVS start with `;'. Skip them. */
    if (node->key[0] == ';')
	return 0;

    fprintf (fp, "\n%s\t", node->key);
    if (node->data != NULL)
    {
	/* If the field's value contains evil characters,
	   it must be stringified. */
	/* FIXME: This does not quite get it right.  "7jk8f" is not a legal
	   value for a value in a newpharse, according to doc/RCSFILES,
	   because digits are not valid in an "id".  We might do OK by
	   always writing strings (enclosed in @@@@).  Would be nice to
	   explicitly mention this one way or another in doc/RCSFILES.
	   A case where we are wrong in a much more clear-cut way is that
	   we let through non-graphic characters such as whitespace and
	   control characters.  */
	int n = strcspn (node->data, "$,.:;@@");
	if (node->data[n] == 0)
	    fputs (node->data, fp);
	else
	{
	    putc ('@@', fp);
	    expand_at_signs (node->data, (off_t) strlen (node->data), fp);
	    putc ('@@', fp);
	}
    }

    /* desc, log and text fields should not be terminated with semicolon;
       all other fields should be. */
    if (strcmp (node->key, "desc") != 0 &&
	strcmp (node->key, "log") != 0 &&
	strcmp (node->key, "text") != 0)
    {
	putc (';', fp);
    }
    return 0;
}

/* Output the admin node for RCS into stream FP. */

static void
RCS_putadmin (rcs, fp)
    RCSNode *rcs;
    FILE *fp;
{
    fprintf (fp, "%s\t%s;\n", RCSHEAD, rcs->head ? rcs->head : "");
    if (rcs->branch)
	fprintf (fp, "%s\t%s;\n", RCSBRANCH, rcs->branch);

    fputs ("access", fp);
    if (rcs->access)
    {
	char *p, *s;
	s = xstrdup (rcs->access);
	for (p = strtok (s, " \n\t"); p != NULL; p = strtok (NULL, " \n\t"))
	    fprintf (fp, "\n\t%s", p);
	free (s);
    }
    fputs (";\n", fp);

    fputs (RCSSYMBOLS, fp);
    walklist (RCS_symbols(rcs), putsymbol_proc, (void *) fp);
    fputs (";\n", fp);

    fputs ("locks", fp);
    if (rcs->locks_data)
	fprintf (fp, "\t%s", rcs->locks_data);
    else if (rcs->locks)
	walklist (rcs->locks, putlock_proc, (void *) fp);
    if (rcs->strict_locks)
	fprintf (fp, "; strict");
    fputs (";\n", fp);

    if (rcs->comment)
    {
	fprintf (fp, "comment\t@@");
	expand_at_signs (rcs->comment, (off_t) strlen (rcs->comment), fp);
	fputs ("@@;\n", fp);
    }
    if (rcs->expand && strcmp (rcs->expand, "kv") != 0)
	fprintf (fp, "%s\t@@%s@@;\n", RCSEXPAND, rcs->expand);

    walklist (rcs->other, putrcsfield_proc, (void *) fp);

    putc ('\n', fp);
}

static void
putdelta (vers, fp)
    RCSVers *vers;
    FILE *fp;
{
    Node *bp, *start;

    /* Skip if no revision was supplied, or if it is outdated (cvs admin -o) */
    if (vers == NULL || vers->outdated)
	return;

    fprintf (fp, "\n%s\n%s\t%s;\t%s %s;\t%s %s;\nbranches",
	     vers->version,
	     RCSDATE, vers->date,
	     "author", vers->author,
	     "state", vers->state ? vers->state : "");

    if (vers->branches != NULL)
    {
	start = vers->branches->list;
	for (bp = start->next; bp != start; bp = bp->next)
	    fprintf (fp, "\n\t%s", bp->key);
    }

    fprintf (fp, ";\nnext\t%s;", vers->next ? vers->next : "");

    walklist (vers->other_delta, putrcsfield_proc, fp);

    putc ('\n', fp);
}

static void
RCS_putdtree (rcs, rev, fp)
    RCSNode *rcs;
    char *rev;
    FILE *fp;
{
    RCSVers *versp;
    Node *p, *branch;

    if (rev == NULL)
	return;

    /* Find the delta node for this revision. */
    p = findnode (rcs->versions, rev);
    assert (p != NULL);
    versp = (RCSVers *) p->data;

    /* Print the delta node and recurse on its `next' node.  This prints
       the trunk.  If there are any branches printed on this revision,
       print those trunks as well. */
    putdelta (versp, fp);
    RCS_putdtree (rcs, versp->next, fp);
    if (versp->branches != NULL)
    {
	branch = versp->branches->list;
	for (p = branch->next; p != branch; p = p->next)
	    RCS_putdtree (rcs, p->key, fp);
    }
}

static void
RCS_putdesc (rcs, fp)
    RCSNode *rcs;
    FILE *fp;
{
    fprintf (fp, "\n\n%s\n@@", RCSDESC);
    if (rcs->desc != NULL)
    {
	off_t len = (off_t) strlen (rcs->desc);
	if (len > 0)
	{
	    expand_at_signs (rcs->desc, len, fp);
	    if (rcs->desc[len-1] != '\n')
		putc ('\n', fp);
	}
    }
    fputs ("@@\n", fp);
}

static void
putdeltatext (fp, d)
    FILE *fp;
    Deltatext *d;
{
    fprintf (fp, "\n\n%s\nlog\n@@", d->version);
    if (d->log != NULL)
    {
	int loglen = strlen (d->log);
	expand_at_signs (d->log, (off_t) loglen, fp);
	if (d->log[loglen-1] != '\n')
	    putc ('\n', fp);
    }
    putc ('@@', fp);

    walklist (d->other, putrcsfield_proc, fp);

    fputs ("\ntext\n@@", fp);
    if (d->text != NULL)
	expand_at_signs (d->text, (off_t) d->len, fp);
    fputs ("@@\n", fp);
}

/* TODO: the whole mechanism for updating deltas is kludgey... more
   sensible would be to supply all the necessary info in a `newdeltatext'
   field for RCSVers nodes. -twp */

/* Copy delta text nodes from FIN to FOUT.  If NEWDTEXT is non-NULL, it
   is a new delta text node, and should be added to the tree at the
   node whose revision number is INSERTPT.  (Note that trunk nodes are
   written in decreasing order, and branch nodes are written in
   increasing order.) */

static void
RCS_copydeltas (rcs, fin, fout, newdtext, insertpt)
    RCSNode *rcs;
    FILE *fin;
    FILE *fout;
    Deltatext *newdtext;
    char *insertpt;
{
    Deltatext *dtext;
    RCSVers *dadmin;
    Node *np;
    int insertbefore, found;

    /* Make a note of whether NEWDTEXT should be inserted
       before or after its INSERTPT. */
    insertbefore = (newdtext != NULL && numdots (newdtext->version) == 1);

    found = 0;
    while ((dtext = RCS_getdeltatext (rcs, fin)) != NULL)
    {
	found = (insertpt != NULL && strcmp (dtext->version, insertpt) == 0);
	if (found && insertbefore)
	    putdeltatext (fout, newdtext);

	np = findnode (rcs->versions, dtext->version);
	dadmin = (RCSVers *) np->data;

	/* If this revision has been outdated, just skip it. */
	if (dadmin->outdated)
	    continue;
	   
	/* Update the change text for this delta.  New change text
	   data may come from cvs admin -m, cvs admin -o, or cvs ci. */
	if (dadmin->text != NULL)
	{
	    if (dadmin->text->log != NULL)
	    {
		free (dtext->log);
		dtext->log = dadmin->text->log;
		dadmin->text->log = NULL;
	    }
	    if (dadmin->text->text != NULL)
	    {
		free (dtext->text);
		dtext->text = dadmin->text->text;
		dtext->len = dadmin->text->len;
		dadmin->text->text = NULL;
	    }
	}
	putdeltatext (fout, dtext);
	freedeltatext (dtext);

	if (found && !insertbefore)
	    putdeltatext (fout, newdtext);
    }
    putc ('\n', fout);
}

/* RCS_internal_lockfile and RCS_internal_unlockfile perform RCS-style
   locking on the specified RCSFILE: for a file called `foo,v', open
   for writing a file called `,foo,'.

   Note that we what do here is quite different from what RCS does.
   RCS creates the ,foo, file before it reads the RCS file (if it
   knows that it will be writing later), so that it actually serves as
   a lock.  We don't; instead we rely on CVS writelocks.  This means
   that if someone is running RCS on the file at the same time they
   are running CVS on it, they might lose (we read the file,
   then RCS writes it, then we write it, clobbering the
   changes made by RCS).  I believe the current sentiment about this
   is "well, don't do that".

   A concern has been expressed about whether adopting the RCS
   strategy would slow us down.  I don't think so, since we need to
   write the ,foo, file anyway (unless perhaps if O_EXCL is slower or
   something).

   These do not perform quite the same function as the RCS -l option
   for locking files: they are intended to prevent competing RCS
   processes from stomping all over each other's laundry.  Hence,
   they are `internal' locking functions.

   Note that we don't clean up the ,foo, file on ^C.  We probably should.
   I'm not completely sure whether RCS does or not (I looked at the code
   a little, and didn't find it).

   If there is an error, give a fatal error; if we return we always
   return a non-NULL value.  */

static FILE *
rcs_internal_lockfile (rcsfile)
    char *rcsfile;
{
    char *lockfile;
    int fd;
    struct stat rstat;
    FILE *fp;

    /* Get the lock file name: `,file,' for RCS file `file,v'. */
    lockfile = rcs_lockfilename (rcsfile);

    /* Use the existing RCS file mode, or read-only if this is a new
       file.  (Really, this is a lie -- if this is a new file,
       RCS_checkin uses the permissions from the working copy.  For
       actually creating the file, we use 0444 as a safe default mode.) */
    if (stat (rcsfile, &rstat) < 0)
    {
	if (existence_error (errno))
	    rstat.st_mode = S_IRUSR | S_IRGRP | S_IROTH;
	else
	    error (1, errno, "cannot stat %s", rcsfile);
    }

    /* Try to open exclusively.  POSIX.1 guarantees that O_EXCL|O_CREAT
       guarantees an exclusive open.  According to the RCS source, with
       NFS v2 we must also throw in O_TRUNC and use an open mask that makes
       the file unwriteable.  For extensive justification, see the comments for
       rcswriteopen() in rcsedit.c, in RCS 5.7.  This is kind of pointless
       in the CVS case; see comment at the start of this file concerning
       general ,foo, file strategy.

       There is some sentiment that with NFSv3 and such, that one can
       rely on O_EXCL these days.  This might be true for unix (I
       don't really know), but I am still pretty skeptical in the case
       of the non-unix systems.  */
    fd = open (lockfile, OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
	       S_IRUSR | S_IRGRP | S_IROTH);

    if (fd < 0)
    {
	error (1, errno, "could not open lock file `%s'", lockfile);
    }

    free (lockfile);

    /* Force the file permissions, and return a stream object. */
    /* Because we change the modes later, we don't worry about
       this in the non-HAVE_FCHMOD case.  */
#ifdef HAVE_FCHMOD
    if (fchmod (fd, rstat.st_mode) < 0)
	error (1, errno, "cannot change mode for %s", lockfile);
#endif
    fp = fdopen (fd, FOPEN_BINARY_WRITE);
    if (fp == NULL)
	error (1, errno, "cannot fdopen %s", lockfile);
    return fp;
}

static void
rcs_internal_unlockfile (fp, rcsfile)
    FILE *fp;
    char *rcsfile;
{
    char *lockfile;

    /* Get the lock file name: `,file,' for RCS file `file,v'. */
    lockfile = rcs_lockfilename (rcsfile);

    /* Abort if we could not write everything successfully to LOCKFILE.
       This is not a great error-handling mechanism, but should prevent
       corrupting the repository. */

    if (ferror (fp))
	error (1, 0, "error writing to lock file %s", lockfile);
    if (fclose (fp) == EOF)
	error (1, errno, "error closing lock file %s", lockfile);

    rename_file (lockfile, rcsfile);
    free (lockfile);
}

static char *
rcs_lockfilename (rcsfile)
    char *rcsfile;
{
    char *lockfile, *lockp;
    char *rcsbase, *rcsp, *rcsend;
    int rcslen;

    /* Create the lockfile name. */
    rcslen = strlen (rcsfile);
    lockfile = (char *) xmalloc (rcslen + 10);
    rcsbase = last_component (rcsfile);
    rcsend = rcsfile + rcslen - sizeof(RCSEXT);
    for (lockp = lockfile, rcsp = rcsfile; rcsp < rcsbase; ++rcsp)
	*lockp++ = *rcsp;
    *lockp++ = ',';
    while (rcsp <= rcsend)
	*lockp++ = *rcsp++;
    *lockp++ = ',';
    *lockp = '\0';

    return lockfile;
}

/* Rewrite an RCS file.  The basic idea here is that the caller should
   first call RCS_reparsercsfile, then munge the data structures as
   desired (via RCS_delete_revs, RCS_settag, &c), then call RCS_rewrite.  */

void
RCS_rewrite (rcs, newdtext, insertpt)
    RCSNode *rcs;
    Deltatext *newdtext;
    char *insertpt;
{
    FILE *fin, *fout;

    if (noexec)
	return;

    fout = rcs_internal_lockfile (rcs->path);

    RCS_putadmin (rcs, fout);
    RCS_putdtree (rcs, rcs->head, fout);
    RCS_putdesc (rcs, fout);

    /* Open the original RCS file and seek to the first delta text. */
    if ((fin = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ)) == NULL) 
	error (1, errno, "cannot open RCS file `%s' for reading", rcs->path);
    if (fseek (fin, rcs->delta_pos, SEEK_SET) < 0)
	error (1, errno, "cannot fseek in RCS file %s", rcs->path);

    /* Update delta_pos to the current position in the output file.
       Do NOT move these statements: they must be done after fin has
       been positioned at the old delta_pos, but before any delta
       texts have been written to fout. */
    rcs->delta_pos = ftell (fout);
    if (rcs->delta_pos == -1)
	error (1, errno, "cannot ftell in RCS file %s", rcs->path);

    RCS_copydeltas (rcs, fin, fout, newdtext, insertpt);

    if (ferror (fin))
	error (0, errno, "warning: when closing RCS file `%s'", rcs->path);
    if (fclose (fin) < 0)
	error (0, errno, "warning: closing RCS file `%s'", rcs->path);

    rcs_internal_unlockfile (fout, rcs->path);
}
d4179 1
a4179 1
        RCS_reparsercsfile (finfo->rcs, &fp);
a4205 1
    "(Specify the --help global option for a list of other help options)\n",
a4276 54

/*
 * For a given file with full pathname PATH and revision number REV,
 * produce a file label suitable for passing to diff.  The default
 * file label as used by RCS 5.7 looks like this:
 *
 *	FILENAME <tab> YYYY/MM/DD <sp> HH:MM:SS <tab> REVNUM
 *
 * The date and time used are the revision's last checkin date and time.
 * If REV is NULL, use the working copy's mtime instead.
 */
char *
make_file_label (path, rev, rcs)
    char *path;
    char *rev;
    RCSNode *rcs;
{
    char datebuf[MAXDATELEN];
    char *label;
    char *file;

    file = last_component (path);
    label = (char *) xmalloc (strlen (file)
			      + (rev == NULL ? 0 : strlen (rev))
			      + 50);

    if (rev)
    {
	char *date;
	RCS_getrevtime (rcs, rev, datebuf, 0);
	date = printable_date (datebuf);
	(void) sprintf (label, "-L%s\t%s\t%s", file, date, rev);
	free (date);
    }
    else
    {
	struct stat sb;
	struct tm *wm;

	if (CVS_STAT (file, &sb) < 0)
	    error (0, 1, "could not get info for `%s'", path);
	else
	{
	    wm = gmtime (&sb.st_mtime);
	    (void) sprintf (datebuf, "%04d/%02d/%02d %02d:%02d:%02d",
			    wm->tm_year + 1900, wm->tm_mon + 1,
			    wm->tm_mday, wm->tm_hour,
			    wm->tm_min, wm->tm_sec);
	    (void) sprintf (label, "-L%s\t%s", file, datebuf);
	}
    }
    return label;
}

@


1.1.1.12
log
@Latest version from Cyclic
@
text
@a13 3
#include "hardlink.h"

int preserve_perms = 0;
a21 28
/* A structure we use to buffer the contents of an RCS file.  The
   various fields are only referenced directly by the rcsbuf_*
   functions.  We declare the struct here so that we can allocate it
   on the stack, rather than in memory.  */

struct rcsbuffer
{
    /* Points to the current position in the buffer.  */
    char *ptr;
    /* Points just after the last valid character in the buffer.  */
    char *ptrend;
    /* The file.  */
    FILE *fp;
    /* The name of the file, used for error messages.  */
    const char *filename;
    /* The starting file position of the data in the buffer.  */
    unsigned long pos;
    /* The length of the value.  */
    size_t vlen;
    /* Whether the value contains an '@@' string.  If so, we can not
       compress whitespace characters.  */
    int at_string;
    /* The number of embedded '@@' characters in an '@@' string.  If
       this is non-zero, we must search the string for pairs of '@@'
       and convert them to a single '@@'.  */
    int embedded_at;
};

d24 3
a26 21
static void rcsbuf_open PROTO ((struct rcsbuffer *, FILE *fp,
				const char *filename, unsigned long pos));
static void rcsbuf_close PROTO ((struct rcsbuffer *));
static int rcsbuf_getkey PROTO ((struct rcsbuffer *, char **keyp,
				 char **valp));
static int rcsbuf_getrevnum PROTO ((struct rcsbuffer *, char **revp));
static char *rcsbuf_fill PROTO ((struct rcsbuffer *, char *ptr, char **keyp,
				 char **valp));
static char *rcsbuf_valcopy PROTO ((struct rcsbuffer *, char *val, int polish,
				    size_t *lenp));
static void rcsbuf_valpolish PROTO ((struct rcsbuffer *, char *val, int polish,
				     size_t *lenp));
static void rcsbuf_valpolish_internal PROTO ((struct rcsbuffer *, char *to,
					      const char *from, size_t *lenp));
static unsigned long rcsbuf_ftell PROTO ((struct rcsbuffer *));
static void rcsbuf_get_buffered PROTO ((struct rcsbuffer *, char **datap,
					size_t *lenp));
static void rcsbuf_cache PROTO ((RCSNode *, struct rcsbuffer *));
static void rcsbuf_cache_close PROTO ((void));
static void rcsbuf_cache_open PROTO ((RCSNode *, long, FILE **,
				      struct rcsbuffer *));
d43 2
a44 3
static void RCS_deltas PROTO ((RCSNode *, FILE *, struct rcsbuffer *, char *,
			       enum rcs_delta_op, char **, size_t *,
			       char **, size_t *));
d47 2
a48 4
static RCSVers *getdelta PROTO ((struct rcsbuffer *, char *, char **,
				 char **));
static Deltatext *RCS_getdeltatext PROTO ((RCSNode *, FILE *,
					   struct rcsbuffer *));
d57 1
a57 3
static void RCS_copydeltas PROTO ((RCSNode *, FILE *, struct rcsbuffer *,
				   FILE *, Deltatext *, char *));
static int count_delta_actions PROTO ((Node *, void *));
a63 6
/* The RCS file reading functions are called a lot, and they do some
   string comparisons.  This macro speeds things up a bit by skipping
   the function call when the first characters are different.  It
   evaluates its arguments multiple times.  */
#define STREQ(a, b) ((a)[0] == (b)[0] && strcmp ((a), (b)) == 0)

d93 1
a108 4
    /* We're creating a new RCSNode, so there is no hope of finding it
       in the cache.  */
    rcsbuf_cache_close ();

d118 1
d139 1
d168 1
d192 1
a223 4
    /* We're creating a new RCSNode, so there is no hope of finding it
       in the cache.  */
    rcsbuf_cache_close ();

d233 1
a245 1
    struct rcsbuffer rcsbuf;
d254 1
a254 1
    /* Process HEAD, BRANCH, and EXPAND keywords from the RCS header.
d258 1
a258 1
       the rest of the header and the deltas.  */
d260 9
a268 1
    rcsbuf_open (&rcsbuf, fp, rcsfile, 0);
d270 1
a270 1
    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
d272 1
a272 1
    if (STREQ (key, RCSDESC))
d275 2
a276 2
    if (STREQ (RCSHEAD, key) && value != NULL)
	rdata->head = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);
d278 1
a278 1
    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
d280 1
a280 1
    if (STREQ (key, RCSDESC))
d283 1
a283 1
    if (STREQ (RCSBRANCH, key) && value != NULL)
d287 1
a287 1
	rdata->branch = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);
d296 5
a300 3
    /* Look ahead for expand, stopping when we see desc or a revision
       number.  */
    while (1)
d302 5
a306 3
	char *cp;

	if (STREQ (RCSEXPAND, key))
d308 2
a309 3
	    rdata->expand = rcsbuf_valcopy (&rcsbuf, value, 0,
					    (size_t *) NULL);
	    break;
a310 11

	for (cp = key; (isdigit (*cp) || *cp == '.') && *cp != '\0'; cp++)
	    /* do nothing */ ;
	if (*cp == '\0')
	    break;

	if (STREQ (RCSDESC, key))
	    break;

	if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	    break;
a311 11

    rdata->flags |= PARTIAL;

    rcsbuf_cache (rdata, &rcsbuf);

    return rdata;

l_error:
    error (0, 0, "`%s' does not appear to be a valid rcs file",
	   rcsfile);
    rcsbuf_close (&rcsbuf);
a312 1
    fclose (fp);
d324 1
a324 1
RCS_reparsercsfile (rdata, pfp, rcsbufp)
a326 1
    struct rcsbuffer *rcsbufp;
d330 1
a330 1
    struct rcsbuffer rcsbuf;
d333 1
a333 1
    int gotkey;
d340 3
a342 1
    rcsbuf_cache_open (rdata, 0, &fp, &rcsbuf);
a353 1
    gotkey = 0;
d356 2
d359 4
a362 1
	if (!gotkey)
d364 5
a368 1
	    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
d375 2
a376 7
	gotkey = 0;

	/* Skip head, branch and expand tags; we already have them. */
	if (STREQ (key, RCSHEAD)
	    || STREQ (key, RCSBRANCH)
	    || STREQ (key, RCSEXPAND))
	{
a377 1
	}
d379 1
a379 1
	if (STREQ (key, "access"))
d382 1
a382 8
	    {
		/* We pass the POLISH parameter as 1 because
                   RCS_addaccess expects nothing but spaces.  FIXME:
                   It would be easy and more efficient to change
                   RCS_addaccess.  */
		rdata->access = rcsbuf_valcopy (&rcsbuf, value, 1,
						(size_t *) NULL);
	    }
d388 1
a388 1
	if (STREQ (key, "locks"))
d391 5
a395 7
		rdata->locks_data = rcsbuf_valcopy (&rcsbuf, value, 0,
						    (size_t *) NULL);
	    if (! rcsbuf_getkey (&rcsbuf, &key, &value))
	    {
		error (1, 0, "premature end of file reading %s", rcsfile);
	    }
	    if (STREQ (key, "strict") && value == NULL)
d400 1
a400 1
		gotkey = 1;
d404 1
a404 1
	if (STREQ (RCSSYMBOLS, key))
d407 7
a413 2
		rdata->symbols_data = rcsbuf_valcopy (&rcsbuf, value, 0,
						      (size_t *) NULL);
d424 1
a424 4
	/* Note that when comparing with RCSDATE, we are not massaging
           VALUE from the string found in the RCS file.  This is OK
           since we know exactly what to expect.  */
	if (*cp == '\0' && strncmp (RCSDATE, value, (sizeof RCSDATE) - 1) == 0)
d427 1
a427 1
	if (STREQ (key, RCSDESC))
d430 1
a430 1
	if (STREQ (key, "comment"))
d432 1
a432 2
	    rdata->comment = rcsbuf_valcopy (&rcsbuf, value, 0,
					     (size_t *) NULL);
d440 1
a440 1
	kv->data = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
d451 7
a457 3
    /* We got out of the loop, so we have the first part of the first
       revision delta in KEY (the revision) and VALUE (the date key
       and its value).  This is what getdelta expects to receive.  */
d459 1
a459 1
    while ((vnode = getdelta (&rcsbuf, rcsfile, &key, &value)) != NULL)
d479 2
a480 3
    /* Here KEY and VALUE are whatever caused getdelta to return NULL.  */

    if (STREQ (key, RCSDESC))
d489 1
a489 1
	rdata->desc = rcsbuf_valcopy (&rcsbuf, value, 0, (size_t *) NULL);
d492 1
a492 1
    rdata->delta_pos = rcsbuf_ftell (&rcsbuf);
d495 4
a498 1
	rcsbuf_cache (rdata, &rcsbuf);
a501 1
	*rcsbufp = rcsbuf;
a522 1
    struct rcsbuffer rcsbuf;
d524 1
a524 1
    RCS_reparsercsfile (rcs, &fp, &rcsbuf);
d528 1
d530 1
d536 7
a542 1
	if (! rcsbuf_getrevnum (&rcsbuf, &key))
d544 2
d547 1
d556 1
a556 1
	while (rcsbuf_getkey (&rcsbuf, &key, &value))
d558 1
a558 1
	    if (! STREQ (key, "text"))
d567 1
a567 1
		kv->data = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
d580 1
a580 1
	    if (! STREQ (vnode->version, rcs->head))
a591 1
		    size_t vallen;
a593 1
		    rcsbuf_valpolish (&rcsbuf, value, 0, &vallen);
d673 2
a674 1
    rcsbuf_cache (rcs, &rcsbuf);
a768 5

/* These functions retrieve keys and values from an RCS file using a
   buffer.  We use this somewhat complex approach because it turns out
   that for many common operations, CVS spends most of its time
   reading keys, so it's worth doing some fairly hairy optimization.  */
d770 21
a790 1
/* The number of bytes we try to read each time we need more data.  */
d792 4
a795 1
#define RCSBUF_BUFSIZE (8192)
d797 2
a798 15
/* The buffer we use to store data.  This grows as needed.  */

static char *rcsbuf_buffer = NULL;
static size_t rcsbuf_buffer_size = 0;

/* Whether rcsbuf_buffer is in use.  This is used as a sanity check.  */

static int rcsbuf_inuse;

/* Set up to start gathering keys and values from an RCS file.  This
   initializes RCSBUF.  */

static void
rcsbuf_open (rcsbuf, fp, filename, pos)
    struct rcsbuffer *rcsbuf;
a799 48
    const char *filename;
    unsigned long pos;
{
    if (rcsbuf_inuse)
	error (1, 0, "rcsbuf_open: internal error");
    rcsbuf_inuse = 1;

    if (rcsbuf_buffer_size < RCSBUF_BUFSIZE)
	expand_string (&rcsbuf_buffer, &rcsbuf_buffer_size, RCSBUF_BUFSIZE);

    rcsbuf->ptr = rcsbuf_buffer;
    rcsbuf->ptrend = rcsbuf_buffer;
    rcsbuf->fp = fp;
    rcsbuf->filename = filename;
    rcsbuf->pos = pos;
    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;
}

/* Stop gathering keys from an RCS file.  */

static void
rcsbuf_close (rcsbuf)
    struct rcsbuffer *rcsbuf;
{
    if (! rcsbuf_inuse)
	error (1, 0, "rcsbuf_close: internal error");
    rcsbuf_inuse = 0;
}

/* Read a key/value pair from an RCS file.  This sets *KEYP to point
   to the key, and *VALUEP to point to the value.  A missing or empty
   value is indicated by setting *VALUEP to NULL.

   This function returns 1 on success, or 0 on EOF.  If there is an
   error reading the file, or an EOF in an unexpected location, it
   gives a fatal error.

   This sets *KEYP and *VALUEP to point to storage managed by
   rcsbuf_getkey.  Moreover, *VALUEP has not been massaged from the
   RCS format: it may contain embedded whitespace and embedded '@@'
   characters.  Call rcsbuf_valcopy or rcsbuf_valpolish to do
   appropriate massaging.  */

static int
rcsbuf_getkey (rcsbuf, keyp, valp)
    struct rcsbuffer *rcsbuf;
d802 1
d804 3
a806 3
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;
d808 2
a809 1
#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)
d811 2
a812 15
    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
d814 8
a821 18
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }
d823 4
a826 3
    /* Skip leading whitespace.  */

    while (1)
d828 1
a828 1
	if (ptr >= ptrend)
d830 4
a833 4
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
d835 1
d837 2
a838 14
	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* We've found the start of the key.  */

    *keyp = ptr;

    if (c != ';')
    {
	while (1)
d840 3
a842 12
	    ++ptr;
	    if (ptr >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, (char **) NULL);
		if (ptr == NULL)
		    error (1, 0, "EOF in key in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    c = *ptr;
	    if (c == ';' || my_whitespace (c))
		break;
d845 1
a845 11

    /* Here *KEYP points to the key in the buffer, C is the character
       we found at the of the key, and PTR points to the location in
       the buffer where we found C.  We must set *PTR to \0 in order
       to terminate the key.  If the key ended with ';', then there is
       no value.  */

    *ptr = '\0';
    ++ptr;

    if (c == ';')
d847 4
a850 3
	*valp = NULL;
	rcsbuf->ptr = ptr;
	return 1;
d852 1
d854 2
a855 4
    /* C must be whitespace.  Skip whitespace between the key and the
       value.  If we find ';' now, there is no value.  */

    while (1)
d857 2
a858 1
	if (ptr >= ptrend)
d860 3
a862 5
	    ptr = rcsbuf_fill (rcsbuf, ptr, keyp, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "EOF while looking for value in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
d864 8
a871 10
	c = *ptr;
	if (c == ';')
	{
	    *valp = NULL;
	    rcsbuf->ptr = ptr + 1;
	    return 1;
	}
	if (! my_whitespace (c))
	    break;
	++ptr;
d874 7
a880 2
    /* Now PTR points to the start of the value, and C is the first
       character of the value.  */
d882 2
a883 3
    if (c != '@@')
	*valp = ptr;
    else
d885 2
a886 13
	char *pat;
	size_t vlen;

	/* Optimize the common case of a value composed of a single
	   '@@' string.  */

	rcsbuf->at_string = 1;

	++ptr;

	*valp = ptr;

	while (1)
d888 1
a888 1
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
d890 7
a896 11
		/* Note that we pass PTREND as the PTR value to
                   rcsbuf_fill, so that we will wind up setting PTR to
                   the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
d898 1
a898 7
	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		/* Note that we pass PAT, not PTR, here.  */
		pat = rcsbuf_fill (rcsbuf, pat, keyp, valp);
		if (pat == NULL)
d900 11
a910 5
		    /* EOF here is OK; it just means that the last
		       character of the file was an '@@' terminating a
		       value for a key type which does not require a
		       trailing ';'.  */
		    pat = rcsbuf->ptrend - 1;
d912 6
d919 1
a919 4
		ptrend = rcsbuf->ptrend;

		/* Note that the value of PTR is bogus here.  This is
		   OK, because we don't use it.  */
a920 7

	    if (pat + 1 >= ptrend || pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ++rcsbuf->embedded_at;
	    ptr = pat + 2;
d923 4
a926 15
	/* Here PAT points to the final '@@' in the string.  */

	*pat = '\0';

	vlen = pat - *valp;
	if (vlen == 0)
	    *valp = NULL;
	rcsbuf->vlen = vlen;

	ptr = pat + 1;
    }

    /* Certain keywords only have a '@@' string.  If there is no '@@'
       string, then the old getrcskey function assumed that they had
       no value, and we do the same.  */
d928 2
a929 7
    {
	char *k;

	k = *keyp;
	if (STREQ (k, RCSDESC)
	    || STREQ (k, "text")
	    || STREQ (k, "log"))
d931 9
a939 14
	    if (c != '@@')
		*valp = NULL;
	    rcsbuf->ptr = ptr;
	    return 1;
	}
    }

    /* If we've already gathered a '@@' string, try to skip whitespace
       and find a ';'.  */
    if (c == '@@')
    {
	while (1)
	{
	    char n;
d941 2
a942 1
	    if (ptr >= ptrend)
d944 8
a951 13
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    n = *ptr;
	    if (n == ';')
	    {
		/* We're done.  We already set everything up for this
                   case above.  */
		rcsbuf->ptr = ptr + 1;
		return 1;
a952 3
	    if (! my_whitespace (n))
		break;
	    ++ptr;
d955 3
a957 38
	/* The value extends past the '@@' string.  We need to undo the
           closing of the '@@' done in the default case above.  This
           case never happens in a plain RCS file, but it can happen
           if user defined phrases are used.  */
	if (rcsbuf->vlen != 0)
	    (*valp)[rcsbuf->vlen] = ' ';
	else
	    *valp = ptr;
    }

    /* Here we have a value which is not a simple '@@' string.  We need
       to gather up everything until the next ';', including any '@@'
       strings.  *VALP points to the start of the value.  If
       RCSBUF->VLEN is not zero, then we have already read an '@@'
       string, and PTR points to the data following the '@@' string.
       Otherwise, PTR points to the start of the value.  */

    while (1)
    {
	char *start, *psemi, *pat;

	/* Find the ';' which must end the value.  */
	start = ptr;
	while ((psemi = memchr (ptr, ';', ptrend - ptr)) == NULL)
	{
	    int slen;

	    /* Note that we pass PTREND as the PTR value to
	       rcsbuf_fill, so that we will wind up setting PTR to the
	       location corresponding to the old PTREND, so that we
	       don't search the same bytes again.  */
	    slen = start - *valp;
	    ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
	    if (ptr == NULL)
		error (1, 0, "EOF in value in RCS file %s", rcsbuf->filename);
	    start = *valp + slen;
	    ptrend = rcsbuf->ptrend;
	}
d959 1
a959 4
	/* See if there are any '@@' strings in the value.  */
	pat = memchr (start, '@@', psemi - start);

	if (pat == NULL)
d961 4
a964 18
	    size_t vlen;

	    /* We're done with the value.  Trim any trailing
               whitespace.  */

	    rcsbuf->ptr = psemi + 1;

	    start = *valp;
	    while (psemi > start && my_whitespace (psemi[-1]))
		--psemi;
	    *psemi = '\0';

	    vlen = psemi - start;
	    if (vlen == 0)
		*valp = NULL;
	    rcsbuf->vlen = vlen;

	    return 1;
d966 1
d968 2
a969 16
	/* We found an '@@' string in the value.  We set
	   RCSBUF->AT_STRING, which means that we won't be able to
	   compress whitespace correctly for this type of value.
	   Since this type of value never arises in a normal RCS file,
	   this should not be a big deal.  It means that if anybody
	   adds a phrase which can have both an '@@' string and regular
	   text, they will have to handle whitespace compression
	   themselves.  */

	rcsbuf->at_string = 1;

	*pat = ' ';

	ptr = pat + 1;

	while (1)
d971 3
a973 31
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	    {
		/* Note that we pass PTREND as the PTR value to
                   rcsbuff_fill, so that we will wind up setting PTR
                   to the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    if (pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ++rcsbuf->embedded_at;
	    ptr = pat + 2;
a974 6

	/* Here PAT points to the final '@@' in the string.  */

	*pat = ' ';

	ptr = pat + 1;
d977 2
a978 28
#undef my_whitespace
}

/* Read an RCS revision number from an RCS file.  This sets *REVP to
   point to the revision number; it will point to space that is
   managed by the rcsbuf functions, and is only good until the next
   call to rcsbuf_getkey or rcsbuf_getrevnum.

   This function returns 1 on success, or 0 on EOF.  If there is an
   error reading the file, or an EOF in an unexpected location, it
   gives a fatal error.  */

static int
rcsbuf_getrevnum (rcsbuf, revp)
    struct rcsbuffer *rcsbuf;
    char **revp;
{
    char *ptr, *ptrend;
    char c;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    *revp = NULL;

    /* Skip leading whitespace.  */

    while (1)
d980 4
a983 13
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! whitespace (c))
	    break;

	++ptr;
d985 1
d987 2
a988 101
    if (! isdigit (c) && c != '.')
	error (1, 0,
	       "unexpected `%c' reading revision number in RCS file %s",
	       c, rcsbuf->filename);

    *revp = ptr;

    do
    {
	++ptr;
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, revp, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0,
		       "unexpected EOF reading revision number in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
    }
    while (isdigit (c) || c == '.');

    if (! whitespace (c))
	error (1, 0, "unexpected `%c' reading revision number in RCS file %s",
	       c, rcsbuf->filename);

    *ptr = '\0';

    rcsbuf->ptr = ptr + 1;

    return 1;
}

/* Fill RCSBUF_BUFFER with bytes from the file associated with RCSBUF,
   updating PTR and the PTREND field.  If KEYP and *KEYP are not NULL,
   then *KEYP points into the buffer, and must be adjusted if the
   buffer is changed.  Likewise for VALP.  Returns the new value of
   PTR, or NULL on error.  */

static char *
rcsbuf_fill (rcsbuf, ptr, keyp, valp)
    struct rcsbuffer *rcsbuf;
    char *ptr;
    char **keyp;
    char **valp;
{
    int got;

    if (rcsbuf->ptrend - rcsbuf_buffer + RCSBUF_BUFSIZE > rcsbuf_buffer_size)
    {
	int poff, peoff, koff, voff;

	poff = ptr - rcsbuf_buffer;
	peoff = rcsbuf->ptrend - rcsbuf_buffer;
	if (keyp != NULL && *keyp != NULL)
	    koff = *keyp - rcsbuf_buffer;
	if (valp != NULL && *valp != NULL)
	    voff = *valp - rcsbuf_buffer;

	expand_string (&rcsbuf_buffer, &rcsbuf_buffer_size,
		       rcsbuf_buffer_size + RCSBUF_BUFSIZE);

	ptr = rcsbuf_buffer + poff;
	rcsbuf->ptrend = rcsbuf_buffer + peoff;
	if (keyp != NULL && *keyp != NULL)
	    *keyp = rcsbuf_buffer + koff;
	if (valp != NULL && *valp != NULL)
	    *valp = rcsbuf_buffer + voff;
    }

    got = fread (rcsbuf->ptrend, 1, RCSBUF_BUFSIZE, rcsbuf->fp);
    if (got == 0)
    {
	if (ferror (rcsbuf->fp))
	    error (1, errno, "cannot read %s", rcsbuf->filename);
	return NULL;
    }

    rcsbuf->ptrend += got;

    return ptr;
}

/* Copy the value VAL returned by rcsbuf_getkey into a memory buffer,
   returning the memory buffer.  Polish the value like
   rcsbuf_valpolish, q.v.  */

static char *
rcsbuf_valcopy (rcsbuf, val, polish, lenp)
    struct rcsbuffer *rcsbuf;
    char *val;
    int polish;
    size_t *lenp;
{
    size_t vlen;
    int embedded_at;
    char *ret;

    if (val == NULL)
d990 1
d992 1
a992 2
	    *lenp = 0;
	return NULL;
d994 4
a997 17

    vlen = rcsbuf->vlen;
    embedded_at = rcsbuf->embedded_at;

    ret = xmalloc (vlen - embedded_at + 1);

    if (rcsbuf->at_string ? embedded_at == 0 : ! polish)
    {
	/* No special action to take.  */
	memcpy (ret, val, vlen + 1);
	if (lenp != NULL)
	    *lenp = vlen;
	return ret;
    }

    rcsbuf_valpolish_internal (rcsbuf, ret, val, lenp);
    return ret;
d1000 3
a1002 8
/* Polish the value VAL returned by rcsbuf_getkey.  The POLISH
   parameter is non-zero if multiple embedded whitespace characters
   should be compressed into a single whitespace character.  Note that
   leading and trailing whitespace was already removed by
   rcsbuf_getkey.  Within an '@@' string, pairs of '@@' characters are
   compressed into a single '@@' character regardless of the value of
   POLISH.  If LENP is not NULL, set *LENP to the length of the value.  */

d1004 3
a1006 5
rcsbuf_valpolish (rcsbuf, val, polish, lenp)
    struct rcsbuffer *rcsbuf;
    char *val;
    int polish;
    size_t *lenp;
d1008 3
a1010 6
    if (val == NULL)
    {
	if (lenp != NULL)
	    *lenp= 0;
	return;
    }
d1012 3
a1014 33
    if (rcsbuf->at_string ? rcsbuf->embedded_at == 0 : ! polish)
    {
	/* No special action to take.  */
	if (lenp != NULL)
	    *lenp = rcsbuf->vlen;
	return;
    }

    rcsbuf_valpolish_internal (rcsbuf, val, val, lenp);
}

/* Internal polishing routine, called from rcsbuf_valcopy and
   rcsbuf_valpolish.  */

static void
rcsbuf_valpolish_internal (rcsbuf, to, from, lenp)
    struct rcsbuffer *rcsbuf;
    char *to;
    const char *from;
    size_t *lenp;
{
    size_t len;

    len = rcsbuf->vlen;

    if (! rcsbuf->at_string)
    {
	char *orig_to;
	size_t clen;

	orig_to = to;

	for (clen = len; clen > 0; ++from, --clen)
d1016 5
a1020 16
	    char c;

	    c = *from;
	    if (whitespace (c))
	    {
		/* Note that we know that clen can not drop to zero
                   while we have whitespace, because we know there is
                   no trailing whitespace.  */
		while (whitespace (from[1]))
		{
		    ++from;
		    --clen;
		}
		c = ' ';
	    }
	    *to++ = c;
d1022 1
d1024 3
a1026 1
	*to = '\0';
d1028 3
a1030 4
	if (lenp != NULL)
	    *lenp = to - orig_to;
    }
    else
d1032 1
a1032 14
	const char *orig_from;
	char *orig_to;
	int embedded_at;
	size_t clen;

	orig_from = from;
	orig_to = to;

	embedded_at = rcsbuf->embedded_at;

	if (lenp != NULL)
	    *lenp = len - embedded_at;

	for (clen = len; clen > 0; ++from, --clen)
d1034 4
a1037 29
	    char c;

	    c = *from;
	    *to++ = c;
	    if (c == '@@')
	    {
		++from;

		/* Sanity check.  */
		if (*from != '@@' || clen == 0)
		    abort ();

		--clen;

		--embedded_at;
		if (embedded_at == 0)
		{
		    /* We've found all the embedded '@@' characters.
                       We can just memcpy the rest of the buffer after
                       this '@@' character.  */
		    if (orig_to != orig_from)
			memcpy (to, from + 1, clen - 1);
		    else
			memmove (to, from + 1, clen - 1);
		    from += clen;
		    to += clen - 1;
		    break;
		}
	    }
d1039 1
d1041 2
a1042 3
	/* Sanity check.  */
	if (from != orig_from + len
	    || to != orig_to + (len - rcsbuf->embedded_at))
d1044 5
a1048 1
	    abort ();
d1050 1
d1052 6
a1057 1
	*to = '\0';
d1059 2
d1063 7
a1069 5
/* Return the current position of an rcsbuf.  */

static unsigned long
rcsbuf_ftell (rcsbuf)
    struct rcsbuffer *rcsbuf;
d1071 3
a1073 2
    return rcsbuf->pos + (rcsbuf->ptr - rcsbuf_buffer);
}
d1075 6
a1080 2
/* Return a pointer to any data buffered for RCSBUF, along with the
   length.  */
d1082 2
a1083 33
static void
rcsbuf_get_buffered (rcsbuf, datap, lenp)
    struct rcsbuffer *rcsbuf;
    char **datap;
    size_t *lenp;
{
    *datap = rcsbuf->ptr;
    *lenp = rcsbuf->ptrend - rcsbuf->ptr;
}

/* CVS optimizes by quickly reading some header information from a
   file.  If it decides it needs to do more with the file, it reopens
   it.  We speed that up here by maintaining a cache of a single open
   file, to save the time it takes to reopen the file in the common
   case.  */

static RCSNode *cached_rcs;
static struct rcsbuffer cached_rcsbuf;

/* Cache RCS and RCSBUF.  This takes responsibility for closing
   RCSBUF->FP.  */

static void
rcsbuf_cache (rcs, rcsbuf)
    RCSNode *rcs;
    struct rcsbuffer *rcsbuf;
{
    if (cached_rcs != NULL)
	rcsbuf_cache_close ();
    cached_rcs = rcs;
    ++rcs->refcount;
    cached_rcsbuf = *rcsbuf;
}
d1085 3
a1087 27
/* If there is anything in the cache, close it.  */

static void
rcsbuf_cache_close ()
{
    if (cached_rcs != NULL)
    {
	if (fclose (cached_rcsbuf.fp) != 0)
	    error (0, errno, "cannot close %s", cached_rcsbuf.filename);
	rcsbuf_close (&cached_rcsbuf);
	freercsnode (&cached_rcs);
	cached_rcs = NULL;
    }
}

/* Open an rcsbuffer for RCS, getting it from the cache if possible.
   Set *FPP to the file, and *RCSBUFP to the rcsbuf.  The file should
   be put at position POS.  */

static void
rcsbuf_cache_open (rcs, pos, pfp, prcsbuf)
    RCSNode *rcs;
    long pos;
    FILE **pfp;
    struct rcsbuffer *prcsbuf;
{
    if (cached_rcs == rcs)
d1089 1
a1089 1
	if (rcsbuf_ftell (&cached_rcsbuf) != pos)
d1091 4
a1094 6
	    if (fseek (cached_rcsbuf.fp, pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file %s",
		       cached_rcsbuf.filename);
	    cached_rcsbuf.ptr = rcsbuf_buffer;
	    cached_rcsbuf.ptrend = rcsbuf_buffer;
	    cached_rcsbuf.pos = pos;
d1096 1
a1096 1
	*pfp = cached_rcsbuf.fp;
d1098 5
a1102 7
	/* When RCS_parse opens a file using fopen_case, it frees the
           filename which we cached in CACHED_RCSBUF and stores a new
           file name in RCS->PATH.  We avoid problems here by always
           copying the filename over.  FIXME: This is hackish.  */
	cached_rcsbuf.filename = rcs->path;

	*prcsbuf = cached_rcsbuf;
d1104 1
a1104 8
	cached_rcs = NULL;

	/* Removing RCS from the cache removes a reference to it.  */
	--rcs->refcount;
	if (rcs->refcount <= 0)
	    error (1, 0, "rcsbuf_cache_open: internal error");
    }
    else
d1106 4
a1109 12
	if (cached_rcs != NULL)
	    rcsbuf_cache_close ();

	*pfp = CVS_FOPEN (rcs->path, FOPEN_BINARY_READ);
	if (*pfp == NULL)
	    error (1, 0, "unable to reopen `%s'", rcs->path);
	if (pos != 0)
	{
	    if (fseek (*pfp, pos, SEEK_SET) != 0)
		error (1, 0, "cannot fseek RCS file %s", rcs->path);
	}
	rcsbuf_open (prcsbuf, *pfp, rcs->path, pos);
d1111 3
a1115 1

d1315 1
a1315 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d1318 1
a1318 1
    if (tag && (STREQ (tag, TAG_HEAD) || *tag == '\0'))
d1504 1
a1504 1
    if (STREQ (check_rev, p->data))
d1658 1
a1658 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d1876 1
a1876 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d1914 1
a1914 1
    if (cur_rev != NULL && ! STREQ (cur_rev, "1.1"))
d1963 1
a1963 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2060 1
a2060 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2112 1
a2112 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2131 1
a2131 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2153 1
a2153 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2237 1
a2237 1
	    if (STREQ (arg, *cpp))
d2295 1
a2295 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d2315 2
d2905 1
a2905 10
   file, typically "-kkv".

   On an error which prevented checking out the file, either print a
   nonfatal error and return 1, or give a fatal error.  On success,
   return 0.  */

/* This function mimics the behavior of `rcs co' almost exactly.  The
   chief difference is in its support for preserving file ownership,
   permissions, and special files across checkin and checkout -- see
   comments in RCS_checkin for some issues about this. -twp */
d2920 1
a2920 1
    FILE *fp, *ofp;
a2921 1
    struct rcsbuffer rcsbuf;
d2928 1
a2928 12
    Node *vp = NULL;
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    uid_t rcs_owner;
    gid_t rcs_group;
    mode_t rcs_mode;
    int change_rcs_owner = 0;
    int change_rcs_group = 0;
    int change_rcs_mode = 0;
    int special_file = 0;
    unsigned long devnum_long;
    dev_t devnum = 0;
#endif
d2965 1
a2965 1
    if (rev == NULL || STREQ (rev, rcs->head))
d2972 1
a2972 1
	    RCS_reparsercsfile (rcs, &fp, &rcsbuf);
d2974 7
a2980 1
	    rcsbuf_cache_open (rcs, rcs->delta_pos, &fp, &rcsbuf);
d2983 10
a2992 7
	if (! rcsbuf_getrevnum (&rcsbuf, &key))
	    error (1, 0, "unexpected EOF reading %s", rcs->path);
	while (rcsbuf_getkey (&rcsbuf, &key, &value))
	{
	    if (STREQ (key, "log"))
		log = rcsbuf_valcopy (&rcsbuf, value, 0, &loglen);
	    else if (STREQ (key, "text"))
a3006 2
	rcsbuf_valpolish (&rcsbuf, value, 0, &len);

d3010 2
a3011 1
	rcsbuf_cache (rcs, &rcsbuf);
a3014 2
	struct rcsbuffer *rcsbufp;

d3020 1
a3020 1
	    RCS_reparsercsfile (rcs, &fp, &rcsbuf);
a3027 1
	    rcsbufp = NULL;
a3032 1
	    rcsbufp = &rcsbuf;
d3035 1
a3035 2
	RCS_deltas (rcs, fp, rcsbufp, rev, RCS_FETCH, &value, &len,
		    &log, &loglen);
d3058 1
a3058 1
	    if (STREQ (*cpp, ouroptions))
a3071 166
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* Handle special files and permissions, if that is desired. */
    if (preserve_perms)
    {
	RCSVers *vers;
	Node *info;
	struct hardlink_info *hlinfo;

	vp = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	if (vp == NULL)
	    error (1, 0, "internal error: no revision information for %s",
		   rev == NULL ? rcs->head : rev);
	vers = (RCSVers *) vp->data;

	/* First we look for symlinks, which are simplest to handle. */
	info = findnode (vers->other_delta, "symlink");
	if (info != NULL)
	{
	    char *dest;

	    if (pfn != NULL || (workfile == NULL && sout == RUN_TTY))
		error (1, 0, "symbolic link %s:%s cannot be piped",
		       rcs->path, vers->version);
	    if (workfile == NULL)
		dest = sout;
	    else
		dest = workfile;

	    /* Remove `dest', just in case.  It's okay to get ENOENT here,
	       since we just want the file not to be there.  (TODO: decide
	       whether it should be considered an error for `dest' to exist
	       at this point.  If so, the unlink call should be removed and
	       `symlink' should signal the error. -twp) */
	    if (unlink (dest) < 0 && existence_error (errno))
		error (1, errno, "cannot remove %s", dest);
	    if (symlink (info->data, dest) < 0)
		error (1, errno, "cannot create symbolic link from %s to %s",
		       dest, info->data);
	    if (free_value)
		free (value);
	    if (free_rev)
		free (rev);
	    return 0;
	}

	/* Next, we look at this file's hardlinks field, and see whether
	   it is linked to any other file that has been checked out.
	   If so, we don't do anything else -- just link it to that file.

	   If we are checking out a file to a pipe or temporary storage,
	   none of this should matter.  Hence the `workfile != NULL'
	   wrapper around the whole thing. -twp */

	if (workfile != NULL)
	{
	    info = findnode (vers->other_delta, "hardlinks");
	    if (info != NULL)
	    {
		char *links = xstrdup (info->data);
		char *working_dir = xgetwd();
		char *p, *file = NULL;
		Node *n, *uptodate_link;

		/* For each file in the hardlinks field, check to see
		   if it exists, and if so, if it has been checked out
		   this iteration. */
		uptodate_link = NULL;
		for (p = strtok (links, " ");
		     p != NULL && uptodate_link == NULL;
		     p = strtok (NULL, " "))
		{
		    file = (char *)
			xmalloc (sizeof(char) *
				 (strlen(working_dir) + strlen(p) + 2));
		    sprintf (file, "%s/%s", working_dir, p);
		    n = lookup_file_by_inode (file);
		    if (n == NULL)
		    {
			if (strcmp (p, workfile) != 0)
			{
			    /* One of the files that WORKFILE should be
			       linked to is not even in the working directory.
			       The user should probably be warned. */
			    error (0, 0,
		"warning: %s should be hardlinked to %s, but is missing",
				   p, workfile);
			}
			free (file);
			continue;
		    }

		    /* hlinfo may be NULL if, for instance, a file is being
		       removed. */
		    hlinfo = (struct hardlink_info *) n->data;
		    if (hlinfo && hlinfo->checked_out)
			uptodate_link = n;
		    free (file);
		}
		free (links);
		free (working_dir);

		/* If we've found a file that `workfile' is supposed to be
		   linked to, and it has been checked out since CVS was
		   invoked, then simply link workfile to that file.

		   If one of these conditions is not met, then we're
		   checking out workfile to a temp file or stdout, or
		   workfile is the first one in its hardlink group to be
		   checked out.  Either way we must continue with a full
		   checkout. */

		if (uptodate_link != NULL)
		{
		    if (link (uptodate_link->key, workfile) < 0)
			error (1, errno, "cannot link %s to %s",
			       workfile, uptodate_link->key);
		    hlinfo->checked_out = 1;	/* probably unnecessary */
		    if (free_value)
			free (value);
		    if (free_rev)
			free (rev);
		    return 0;
		}
	    }
	}

	info = findnode (vers->other_delta, "owner");
	if (info != NULL)
	{
	    change_rcs_owner = 1;
	    rcs_owner = (uid_t) strtoul (info->data, NULL, 10);
	}
	info = findnode (vers->other_delta, "group");
	if (info != NULL)
	{
	    change_rcs_group = 1;
	    rcs_group = (gid_t) strtoul (info->data, NULL, 10);
	}
	info = findnode (vers->other_delta, "permissions");
	if (info != NULL)
	{
	    change_rcs_mode = 1;
	    rcs_mode = (mode_t) strtoul (info->data, NULL, 8);
	}
	info = findnode (vers->other_delta, "special");
	if (info != NULL)
	{
	    /* If the size of `devtype' changes, fix the sscanf call also */
	    char devtype[16];

	    if (sscanf (info->data, "%16s %lu",
			devtype, &devnum_long) < 2)
		error (1, 0, "%s:%s has bad `special' newphrase %s",
		       workfile, vers->version, info->data);
	    devnum = devnum_long;
	    if (strcmp (devtype, "character") == 0)
		special_file = S_IFCHR;
	    else if (strcmp (devtype, "block") == 0)
		special_file = S_IFBLK;
	    else
		error (0, 0, "%s is a special file of unsupported type `%s'",
		       workfile, info->data);
	}
    }
#endif

d3074 1
d3077 4
a3080 8
	/* Don't fetch the delta node again if we already have it. */
	if (vp == NULL)
	{
	    vp = findnode (rcs->versions, rev == NULL ? rcs->head : rev);
	    if (vp == NULL)
		error (1, 0, "internal error: no revision information for %s",
		       rev == NULL ? rcs->head : rev);
	}
d3082 1
a3082 1
	expand_keywords (rcs, (RCSVers *) vp->data, nametag, log, loglen,
a3101 5
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (special_file)
	    error (1, 0, "special file %s cannot be piped to anything",
		   rcs->path);
#endif
a3106 25
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    else if (special_file)
    {
	char *dest;

	/* Can send either to WORKFILE or to SOUT, as long as SOUT is
	   not RUN_TTY. */
	dest = workfile;
	if (dest == NULL)
	{
	    if (sout == RUN_TTY)
		error (1, 0, "special file %s cannot be written to stdout",
		       rcs->path);
	    dest = sout;
	}

	/* Unlink `dest', just in case.  It's okay if this provokes a
	   ENOENT error. */
	if (unlink (dest) < 0 && existence_error (errno))
	    error (1, errno, "cannot remove %s", dest);
	if (mknod (dest, special_file, devnum) < 0)
	    error (1, errno, "could not create special file %s",
		   dest);
    }
#endif
a3108 1
	/* Not a special file: write to WORKFILE or SOUT. */
a3114 5
		/* Symbolic links should be removed before replacement, so that
		   `fopen' doesn't follow the link and open the wrong file. */
		if (islink (sout))
		    if (unlink_file (sout) < 0)
			error (1, errno, "cannot remove %s", sout);
a3121 5
	    /* Output is supposed to go to WORKFILE, so we should open that
	       file.  Symbolic links should be removed first (see above). */
	    if (islink (workfile))
		if (unlink_file (workfile) < 0)
		    error (1, errno, "cannot remove %s", workfile);
a3165 1
    }
d3167 1
a3167 9
    if (workfile != NULL)
    {
	int ret;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (!special_file && fclose (ofp) < 0)
	    error (1, errno, "cannot close %s", workfile);

	if (change_rcs_owner || change_rcs_group)
d3169 5
a3173 2
	    if (chown (workfile, rcs_owner, rcs_group) < 0)
		error (0, errno, "could not change file ownership on %s",
d3176 1
a3176 13

	ret = chmod (workfile,
		     change_rcs_mode
		     ? rcs_mode
		     : sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH));
#else
	if (fclose (ofp) < 0)
	    error (1, errno, "cannot close %s", workfile);

	ret = chmod (workfile,
		     sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH));
#endif
	if (ret < 0)
d3178 2
a3179 2
	    error (0, errno, "cannot change mode of file %s",
		   workfile);
a3181 16
    else if (sout != RUN_TTY)
    {
	if (
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    !special_file &&
#endif
	    fclose (ofp) < 0)
	    error (1, errno, "cannot close %s", sout);
    }

#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If we are in the business of preserving hardlinks, then
       mark this file as having been checked out. */
    if (preserve_perms && workfile != NULL)
	update_hardlink_info (workfile);
#endif
d3230 1
a3230 1
	if (STREQ (p->data, user))
a3335 2
static char *max_rev PROTO ((const RCSVers *));

d3337 1
a3337 2
max_rev (branchnode)
    const RCSVers *branchnode;
d3472 7
a3478 16
/* Check in to RCSFILE with revision REV (which must be greater than
   the largest revision) and message MESSAGE (which is checked for
   legality).  If FLAGS & RCS_FLAGS_DEAD, check in a dead revision.
   If FLAGS & RCS_FLAGS_QUIET, tell ci to be quiet.  If FLAGS &
   RCS_FLAGS_MODTIME, use the working file's modification time for the
   checkin time.  WORKFILE is the working file to check in from, or
   NULL to use the usual RCS rules for deriving it from the RCSFILE.
   If FLAGS & RCS_FLAGS_KEEPFILE, don't unlink the working file;
   unlinking the working file is standard RCS behavior, but is rarely
   appropriate for CVS.

   This function should almost exactly mimic the behavior of `rcs ci'.  The
   principal point of difference is the support here for preserving file
   ownership and permissions in the delta nodes.  This is not a clean
   solution -- precisely because it diverges from RCS's behavior -- but
   it doesn't seem feasible to do this anywhere else in the code. [-twp]
d3484 4
d3510 1
a3510 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
a3563 86
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If permissions should be preserved on this project, then
       save the permission info. */
    if (preserve_perms)
    {
	Node *np;
	struct stat sb;
	char buf[64];	/* static buffer should be safe: see usage. -twp */
	char *fullpath;

	delta->other_delta = getlist();

	if (CVS_LSTAT (workfile, &sb) < 0)
	    error (1, 1, "cannot lstat %s", workfile);

	if (S_ISLNK (sb.st_mode))
	{
	    np = getnode();
	    np->key = xstrdup ("symlink");
	    np->data = xreadlink (workfile);
	    addnode (delta->other_delta, np);
	}
	else
	{
	    (void) sprintf (buf, "%u", sb.st_uid);
	    np = getnode();
	    np->key = xstrdup ("owner");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);

	    (void) sprintf (buf, "%u", sb.st_gid);
	    np = getnode();
	    np->key = xstrdup ("group");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);
	    
	    (void) sprintf (buf, "%o", sb.st_mode & 07777);
	    np = getnode();
	    np->key = xstrdup ("permissions");
	    np->data = xstrdup (buf);
	    addnode (delta->other_delta, np);

	    /* Save device number. */
	    switch (sb.st_mode & S_IFMT)
	    {
		case S_IFREG: break;
		case S_IFCHR:
		case S_IFBLK:
		    np = getnode();
		    np->key = xstrdup ("special");
		    sprintf (buf, "%s %lu",
			     ((sb.st_mode & S_IFMT) == S_IFCHR
			      ? "character" : "block"),
			     (unsigned long) sb.st_rdev);
		    np->data = xstrdup (buf);
		    addnode (delta->other_delta, np);
		    break;

		default:
		    error (0, 0, "special file %s has unknown type", workfile);
	    }

	    /* Save hardlinks. */
	    fullpath = xgetwd();
	    fullpath = xrealloc (fullpath,
				 strlen(fullpath) + strlen(workfile) + 2);
	    sprintf (fullpath + strlen(fullpath), "/%s", workfile);

	    np = lookup_file_by_inode (fullpath);
	    if (np == NULL)
	    {
		error (1, 0, "lost information on %s's linkage", workfile);
	    }
	    else
	    {
		struct hardlink_info *hlinfo;
		hlinfo = (struct hardlink_info *) np->data;
		np = getnode();
		np->key = xstrdup ("hardlinks");
		np->data = xstrdup (hlinfo->links);
		(void) addnode (delta->other_delta, np);
	    }
	}
    }
#endif

d3602 1
a3602 3
	get_file (workfile, workfile,
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
		  &dtext->text, &bufsize, &dtext->len);
a3610 3
	/* We are probably about to invalidate any cached file.  */
	rcsbuf_cache_close ();

d3622 6
a3627 6
	if ((flags & RCS_FLAGS_KEEPFILE) == 0)
	{
	    if (unlink_file (workfile) < 0)
		/* FIXME-update-dir: message does not include update_dir.  */
		error (0, errno, "cannot remove %s", workfile);
	}
d3667 1
a3667 1
		 || STREQ (commitpt->version, rcs->head))
d3771 1
a3771 1
	if (! STREQ (nodep->data, delta->author))
d3793 1
a3793 1
			     && STREQ (rcs->expand, "b"))
d3799 1
a3799 1
	error (1, 0,
d3810 1
a3810 1
    diffopts = (rcs->expand != NULL && STREQ (rcs->expand, "b")
d3814 1
a3814 1
    if (STREQ (commitpt->version, rcs->head) &&
d3821 1
a3821 1
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
d3857 1
a3857 1
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
d3894 1
a3894 1
		  rcs->expand != NULL && STREQ (rcs->expand, "b") ? "rb" : "r",
d3918 1
a3918 1
	if (STREQ (commitpt->version, rcs->head))
d3948 6
a3953 6
    if ((flags & RCS_FLAGS_KEEPFILE) == 0)
    {
	if (unlink_file (workfile) < 0)
	    /* FIXME-update-dir: message does not include update_dir.  */
	    error (1, errno, "cannot remove %s", workfile);
    }
d4006 1
a4006 1
	binary = STREQ (options, "-kb");
d4012 1
a4012 1
	if (expand != NULL && STREQ (expand, "b"))
d4018 1
a4018 18
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    /* If CVS is to deal properly with special files (when
       PreservePermissions is on), the best way is to check out the
       revision to a temporary file and call `xcmp' on the two disk
       files.  xcmp needs to handle non-regular files properly anyway,
       so calling it simplifies RCS_cmp_file.  We *could* just yank
       the delta node out of the version tree and look for device
       numbers, but writing to disk and calling xcmp is a better
       abstraction (therefore probably more robust). -twp */

    if (preserve_perms)
    {
	char *tmp;

	tmp = cvs_temp_name();
	retcode = RCS_checkout(rcs, NULL, rev, NULL, options, tmp, NULL, NULL);
	if (retcode != 0)
	    return 1;
d4020 14
a4033 4
	retcode = xcmp (tmp, filename);
	if (CVS_UNLINK (tmp) < 0)
	    error (0, errno, "cannot remove %s", tmp);
	return retcode;
a4034 22
    else
#endif
    {
        fp = CVS_FOPEN (filename, binary ? FOPEN_BINARY_READ : "r");
	
        data.filename = filename;
        data.fp = fp;
        data.different = 0;
	
        retcode = RCS_checkout (rcs, (char *) NULL, rev, (char *) NULL,
				options, RUN_TTY, cmp_file_buffer,
				(void *) &data);

        /* If we have not yet found a difference, make sure that we are at
           the end of the file.  */
        if (! data.different)
        {
	    if (getc (fp) != EOF)
		data.different = 1;
        }
	
        fclose (fp);
d4036 6
a4041 5
	if (retcode != 0)
	    return 1;
	
        return data.different;
    }
d4109 1
a4109 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4113 2
a4114 2
    if (STREQ (tag, TAG_BASE)
	|| STREQ (tag, TAG_HEAD))
d4168 1
a4168 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4191 1
a4191 4
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (rev && ! *rev)
	rev = NULL;
d4195 1
a4195 1
    if (rev != NULL && rcs->branch != NULL && STREQ (rev, rcs->branch))
d4225 1
a4225 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4269 1
a4269 1
	if (STREQ (p->data, user))
d4321 1
a4321 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4348 1
a4348 1
	    if (STREQ (p->data, user))
d4387 1
a4387 1
    if (! STREQ (lock->data, user))
d4423 1
a4423 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4432 1
a4432 1
	    if (STREQ (a, user))
d4456 1
a4456 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4487 1
a4487 1
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);
d4503 1
a4503 1
    if (STREQ (node->data, rev))
d4596 1
a4596 1
	if (RCS_isbranch (rcs, rev1) && STREQ (rev1, rev2))
d4687 1
a4687 1
    else if (! STREQ (rev1, branchpoint))
d4692 1
a4692 1
	while (revp->next != NULL && ! STREQ (revp->next, rev1))
d4741 1
a4741 1
	    found = STREQ (revp->version, rev2);
d4838 7
d4872 6
d4922 1
a4922 1
	 next != NULL && (after == NULL || ! STREQ (next, after));
d4947 1
a4947 1
	else if (STREQ (rev1, branchpoint))
d4953 1
a4953 1
		   ! STREQ (nodep->key, rev1))
d5473 1
a5473 1
RCS_deltas (rcs, fp, rcsbuf, version, op, text, len, log, loglen)
a5475 1
    struct rcsbuffer *rcsbuf;
a5482 1
    struct rcsbuffer rcsbuf_local;
d5492 1
d5502 5
a5506 2
	rcsbuf_cache_open (rcs, rcs->delta_pos, &fp, &rcsbuf_local);
	rcsbuf = &rcsbuf_local;
d5533 1
a5533 2
	if (! rcsbuf_getrevnum (rcsbuf, &key))
	    error (1, 0, "unexpected EOF reading RCS file %s", rcs->path);
d5535 1
a5535 1
	if (next != NULL && ! STREQ (next, key))
d5560 2
a5561 2
	       storage controlled by rcsbuf_getkey.  */
	    if (STREQ (branchversion, key))
d5567 1
a5567 1
	while (1)
a5568 4
	    if (! rcsbuf_getkey (rcsbuf, &key, &value))
		error (1, 0, "%s does not appear to be a valid rcs file",
		       rcs->path);

d5571 2
a5572 2
		&& STREQ (key, "log")
		&& STREQ (branchversion, version))
d5574 3
a5576 1
		*log = rcsbuf_valcopy (rcsbuf, value, 0, loglen);
d5579 1
a5579 1
	    if (STREQ (key, "text"))
a5580 1
		rcsbuf_valpolish (rcsbuf, value, 0, &vallen);
d5599 2
d5606 1
a5606 1
	    if (STREQ (branchversion, version))
d5686 3
a5688 2

    rcsbuf_cache (rcs, rcsbuf);
d5792 7
a5800 6
/* Read the information for a single delta from the RCS buffer RCSBUF,
   whose name is RCSFILE.  *KEYP and *VALP are either NULL, or the
   first key/value pair to read, as set by rcsbuf_getkey. Return NULL
   if there are no more deltas.  Store the key/value pair which
   terminated the read in *KEYP and *VALP.  */

d5802 2
a5803 2
getdelta (rcsbuf, rcsfile, keyp, valp)
    struct rcsbuffer *rcsbuf;
a5804 2
    char **keyp;
    char **valp;
d5808 1
d5811 8
a5818 14
    /* Get revision number if it wasn't passed in. This uses
       rcsbuf_getkey because it doesn't croak when encountering
       unexpected input.  As a result, we have to play unholy games
       with `key' and `value'. */
    if (*keyp != NULL)
    {
	key = *keyp;
	value = *valp;
    }
    else
    {
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "%s: unexpected EOF", rcsfile);
    }
d5824 1
a5824 4
    /* Note that when comparing with RCSDATE, we are not massaging
       VALUE from the string found in the RCS file.  This is OK since
       we know exactly what to expect.  */
    if (*cp != '\0' || strncmp (RCSDATE, value, (sizeof RCSDATE) - 1) != 0)
d5826 2
a5827 2
	*keyp = key;
	*valp = value;
a5829 4

    vnode = (RCSVers *) xmalloc (sizeof (RCSVers));
    memset (vnode, 0, sizeof (RCSVers));

d5832 2
a5833 3
    /* Grab the value of the date from value.  Note that we are not
       massaging VALUE from the string found in the RCS file.  */
    cp = value + (sizeof RCSDATE) - 1;	/* skip the "date" keyword */
d5840 3
a5842 5
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (! STREQ (key, "author"))
d5844 2
a5845 2
unable to parse %s; `author' not in the expected place", rcsfile);
    vnode->author = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);
d5848 3
a5850 5
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (! STREQ (key, "state"))
d5852 3
a5854 3
unable to parse %s; `state' not in the expected place", rcsfile);
    vnode->state = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);
    if (STREQ (value, "dead"))
d5860 2
a5861 1
       to doc/RCSFILES.  */
d5864 4
a5867 5
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (STREQ (key, RCSDESC))
d5869 1
a5869 4
	*keyp = key;
	*valp = value;
	/* Probably could/should be a fatal error.  */
	error (0, 0, "warning: 'branches' keyword missing from %s", rcsfile);
a5874 2
	/* Note that we are not massaging VALUE from the string found
           in the RCS file.  */
d5879 4
a5882 5
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
    {
	error (1, 0, "unexpected end of file reading %s", rcsfile);
    }
    if (STREQ (key, RCSDESC))
d5884 1
a5884 4
	*keyp = key;
	*valp = value;
	/* Probably could/should be a fatal error.  */
	error (0, 0, "warning: 'next' keyword missing from %s", rcsfile);
d5888 1
a5888 1
	vnode->next = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);
d5894 1
d5897 5
a5901 2
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "unexpected end of file reading %s", rcsfile);
d5903 1
a5903 1
	if (STREQ (key, RCSDESC))
d5910 1
a5910 1
	if (STREQ (key, RCSDEAD))
a5920 3
	/* Note that when comparing with RCSDATE, we are not massaging
	   VALUE from the string found in the RCS file.  This is OK
	   since we know exactly what to expect.  */
d5931 1
a5931 1
	kv->data = rcsbuf_valcopy (rcsbuf, value, 1, (size_t *) NULL);
d5943 1
a5943 1
    }
d5945 3
a5947 3
    /* Return the key which caused us to fail back to the caller.  */
    *keyp = key;
    *valp = value;
d5968 1
a5968 1
RCS_getdeltatext (rcs, fp, rcsbuf)
a5970 1
    struct rcsbuffer *rcsbuf;
d5974 1
d5977 1
d5980 4
a5983 1
    if (! rcsbuf_getrevnum (rcsbuf, &num))
d5985 2
a5986 2
	/* If num == NULL, it means we reached EOF naturally.  That's
	   fine. */
d6002 1
a6002 1
    if (! rcsbuf_getkey (rcsbuf, &key, &value))
d6004 1
a6004 1
    if (! STREQ (key, "log"))
d6007 1
a6007 1
    d->log = rcsbuf_valcopy (rcsbuf, value, 0, (size_t *) NULL);
d6011 3
a6013 1
    while (1)
a6014 6
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
	    error (1, 0, "%s, delta %s: unexpected EOF", rcs->path, num);

	if (STREQ (key, "text"))
	    break;

d6018 1
a6018 1
	p->data = rcsbuf_valcopy (rcsbuf, value, 1, (size_t *) NULL);
d6025 2
d6029 3
a6031 1
    d->text = rcsbuf_valcopy (rcsbuf, value, 0, &d->len);
d6048 1
a6048 1
putsymbol_proc (symnode, fparg)
d6050 1
a6050 1
    void *fparg;
d6052 1
a6052 13
    FILE *fp = (FILE *) fparg;

    /* A fiddly optimization: this code used to just call fprintf, but
       in an old repository with hundreds of tags this can get called
       hundreds of thousands of times when doing a cvs tag.  Since
       tagging is a relatively common operation, and using putc and
       fputs is just as comprehensible, the change is worthwhile.  */
    putc ('\n', fp);
    putc ('\t', fp);
    fputs (symnode->key, fp);
    putc (':', fp);
    fputs (symnode->data, fp);
    return 0;
d6104 3
a6106 3
    if (! STREQ (node->key, "desc") &&
	! STREQ (node->key, "log") &&
	! STREQ (node->key, "text"))
d6136 1
a6136 9
    /* If we haven't had to convert the symbols to a list yet, don't
       force a conversion now; just write out the string.  */
    if (rcs->symbols == NULL && rcs->symbols_data != NULL)
    {
	fputs ("\n\t", fp);
	fputs (rcs->symbols_data, fp);
    }
    else
	walklist (RCS_symbols (rcs), putsymbol_proc, (void *) fp);
d6154 1
a6154 1
    if (rcs->expand && ! STREQ (rcs->expand, "kv"))
d6276 1
a6276 1
RCS_copydeltas (rcs, fin, rcsbufin, fout, newdtext, insertpt)
a6278 1
    struct rcsbuffer *rcsbufin;
d6283 1
a6283 1
    int actions;
a6286 9
    char *bufrest;
    int nls;
    size_t buflen;
    char buf[8192];
    int got;

    /* Count the number of versions for which we have to do some
       special operation.  */
    actions = walklist (rcs->versions, count_delta_actions, (void *) NULL);
d6292 2
a6293 1
    while (actions != 0 || newdtext != NULL)
d6295 1
a6295 11
	Deltatext *dtext;

	dtext = RCS_getdeltatext (rcs, fin, rcsbufin);

	/* We shouldn't hit EOF here, because that would imply that
           some action was not taken, or that we could not insert
           NEWDTEXT.  */
	if (dtext == NULL)
	    error (1, 0, "internal error: EOF too early in RCS_copydeltas");

	found = (insertpt != NULL && STREQ (dtext->version, insertpt));
a6296 1
	{
a6297 3
	    newdtext = NULL;
	    insertpt = NULL;
	}
a6303 2
	{
	    --actions;
a6304 1
	}
a6309 2
	    if (dadmin->text->log != NULL || dadmin->text->text != NULL)
		--actions;
a6327 1
	{
a6328 81
	    newdtext = NULL;
	    insertpt = NULL;
	}
    }

    /* Copy the rest of the file directly, without bothering to
       interpret it.  The caller will handle error checking by calling
       ferror.

       We just wrote a newline to the file, either in putdeltatext or
       in the caller.  However, we may not have read the corresponding
       newline from the file, because rcsbuf_getkey returns as soon as
       it finds the end of the '@@' string for the desc or text key.
       Therefore, we may read three newlines when we should really
       only write two, and we check for that case here.  This is not
       an semantically important issue; we only do it to make our RCS
       files look traditional.  */

    nls = 3;

    rcsbuf_get_buffered (rcsbufin, &bufrest, &buflen);
    if (buflen > 0)
    {
	if (bufrest[0] != '\n'
	    || strncmp (bufrest, "\n\n\n", buflen < 3 ? buflen : 3) != 0)
	{
	    nls = 0;
	}
	else
	{
	    if (buflen < 3)
		nls -= buflen;
	    else
	    {
		++bufrest;
		--buflen;
		nls = 0;
	    }
	}

	fwrite (bufrest, 1, buflen, fout);
    }

    while ((got = fread (buf, 1, sizeof buf, fin)) != 0)
    {
	if (nls > 0
	    && got >= nls
	    && buf[0] == '\n'
	    && strncmp (buf, "\n\n\n", nls) == 0)
	{
	    fwrite (buf + 1, 1, got - 1, fout);
	}
	else
	{
	    fwrite (buf, 1, got, fout);
	}

	nls = 0;
    }
}

/* A helper procedure for RCS_copydeltas.  This is called via walklist
   to count the number of RCS revisions for which some special action
   is required.  */

int
count_delta_actions (np, ignore)
    Node *np;
    void *ignore;
{
    RCSVers *dadmin;

    dadmin = (RCSVers *) np->data;

    if (dadmin->outdated)
	return 1;

    if (dadmin->text != NULL
	&& (dadmin->text->log != NULL || dadmin->text->text != NULL))
    {
	return 1;
d6330 1
a6330 2

    return 0;
a6437 6
	/* The only case in which using errno here would be meaningful
	   is if we happen to have left errno unmolested since the call
	   which produced the error (e.g. fprintf).  That is pretty
	   fragile even if it happens to sometimes be true.  The real
	   solution is to check each call to fprintf rather than waiting
	   until the end like this.  */
a6480 1
    struct rcsbuffer rcsbufin;
d6492 4
a6495 1
    rcsbuf_cache_open (rcs, rcs->delta_pos, &fin, &rcsbufin);
d6505 1
a6505 1
    RCS_copydeltas (rcs, fin, &rcsbufin, fout, newdtext, insertpt);
a6506 3
    /* We don't want to call rcsbuf_cache here, since we're about to
       delete the file.  */
    rcsbuf_close (&rcsbufin);
d6508 1
a6508 7
	/* The only case in which using errno here would be meaningful
	   is if we happen to have left errno unmolested since the call
	   which produced the error (e.g. fread).  That is pretty
	   fragile even if it happens to sometimes be true.  The real
	   solution is to make sure that all the code which reads
	   from fin checks for errors itself (some does, some doesn't).  */
	error (0, 0, "warning: when closing RCS file `%s'", rcs->path);
a6532 2
    struct rcsbuffer *rcsbufp = NULL;
    struct rcsbuffer rcsbuf;
d6539 1
a6539 4
    {
        RCS_reparsercsfile (finfo->rcs, &fp, &rcsbuf);
	rcsbufp = &rcsbuf;
    }
d6552 1
a6552 1
    RCS_deltas (finfo->rcs, fp, rcsbufp, version, RCS_ANNOTATE, (char **) NULL,
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a83 3
static char *RCS_addbranch PROTO ((RCSNode *, const char *));
static char *truncate_revnum_in_place PROTO ((char *));
static char *truncate_revnum PROTO ((const char *));
d566 1
a566 3
	/* Don't need to rcsbuf_valcopy `value' because
	   getdelta already did that. */
	rdata->desc = xstrdup (value);
a801 3
/* Note: The `hardlinks' list is *not* freed, since it is merely a
   pointer into the `hardlist' structure (defined in hardlink.c), and
   that structure is freed elsewhere in the program. */
a1283 474
/* TODO: Eliminate redundant code in rcsbuf_getkey, rcsbuf_getid,
   rcsbuf_getstring, rcsbuf_getword.  These last three functions were
   all created by hacking monstrous swaths of code from rcsbuf_getkey,
   and some engineering would make the code easier to read and
   maintain.

   Note that the extreme hair in rcsbuf_getkey is because profiling
   statistics show that it was worth it.

   We probably could be processing "hardlinks" by first calling
   rcsbuf_getkey, and breaking up the value afterwards; the code to
   break it up would not need to be hacked for speed.  This would
   remove the need for rcsbuf_getword, rcsbuf_getid, and
   rcsbuf_getstring, as the other calls are easy to remove.  */

/* Read an `id' (in the sense of rcsfile(5)) from RCSBUF, and store in
   IDP. */

static int
rcsbuf_getid (rcsbuf, idp)
    struct rcsbuffer *rcsbuf;
    char **idp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		return 0;
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* We've found the start of the key.  */

    *idp = ptr;

    if (c != ';')
    {
	while (1)
	{
	    ++ptr;
	    if (ptr >= ptrend)
	    {
		ptr = rcsbuf_fill (rcsbuf, ptr, idp, (char **) NULL);
		if (ptr == NULL)
		    error (1, 0, "EOF in key in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }
	    c = *ptr;
	    if (c == ';' || my_whitespace (c))
		break;
	}
    }

    /* Here *IDP points to the id in the buffer, C is the character
       we found at the end of the key, and PTR points to the location in
       the buffer where we found C.  We may not set *PTR to \0, because
       it may overwrite a terminating semicolon.  The calling function
       must copy and terminate the id on its own. */

    rcsbuf->ptr = ptr;
    return 1;

#undef my_whitespace;
}

/* Read an RCS @@-delimited string.  Store the result in STRP. */

static int
rcsbuf_getstring (rcsbuf, strp)
    struct rcsbuffer *rcsbuf;
    char **strp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char *pat;
    size_t vlen;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* PTR should now point to the start of a string. */
    if (c != '@@')
	error (1, 0, "expected @@-string at `%c' in %s", c, rcsbuf->filename);

    /* Optimize the common case of a value composed of a single
       '@@' string.  */

    rcsbuf->at_string = 1;
    
    ++ptr;
    
    *strp = ptr;
    
    while (1)
    {
	while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	{
	    /* Note that we pass PTREND as the PTR value to
	       rcsbuf_fill, so that we will wind up setting PTR to
	       the location corresponding to the old PTREND, so
	       that we don't search the same bytes again.  */
	    ptr = rcsbuf_fill (rcsbuf, ptrend, NULL, strp);
	    if (ptr == NULL)
		error (1, 0,
		       "EOF while looking for end of string in RCS file %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	/* Handle the special case of an '@@' right at the end of
	   the known bytes.  */
	if (pat + 1 >= ptrend)
	{
	    /* Note that we pass PAT, not PTR, here.  */
	    pat = rcsbuf_fill (rcsbuf, pat, NULL, strp);
	    if (pat == NULL)
	    {
		/* EOF here is OK; it just means that the last
		   character of the file was an '@@' terminating a
		   value for a key type which does not require a
		   trailing ';'.  */
		pat = rcsbuf->ptrend - 1;
		
	    }
	    ptrend = rcsbuf->ptrend;
	    
	    /* Note that the value of PTR is bogus here.  This is
	       OK, because we don't use it.  */
	}
	
	if (pat + 1 >= ptrend || pat[1] != '@@')
	    break;
	
	/* We found an '@@' pair in the string.  Keep looking.  */
	++rcsbuf->embedded_at;
	ptr = pat + 2;
    }

    /* Here PAT points to the final '@@' in the string.  */
    
    *pat = '\0';
    
    vlen = pat - *strp;
    if (vlen == 0)
	*strp = NULL;
    rcsbuf->vlen = vlen;
    rcsbuf->ptr = pat + 1;
    
    return 1;

#undef my_whitespace
}

/* Read an RCS `word', in the sense of rcsfile(5) (an id, a num, a
   @@-delimited string, or `:').  Store the result in WORDP.  If a
   `;' is reached without reading any text, the result is NULL. */

static int
rcsbuf_getword (rcsbuf, wordp)
    struct rcsbuffer *rcsbuf;
    char **wordp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *ptrend;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    rcsbuf->vlen = 0;
    rcsbuf->at_string = 0;
    rcsbuf->embedded_at = 0;

    ptr = rcsbuf->ptr;
    ptrend = rcsbuf->ptrend;

    /* Sanity check.  */
    if (ptr < rcsbuf_buffer || ptr > rcsbuf_buffer + rcsbuf_buffer_size)
	abort ();

    /* If the pointer is more than RCSBUF_BUFSIZE bytes into the
       buffer, move back to the start of the buffer.  This keeps the
       buffer from growing indefinitely.  */
    if (ptr - rcsbuf_buffer >= RCSBUF_BUFSIZE)
    {
	int len;

	len = ptrend - ptr;

	/* Sanity check: we don't read more than RCSBUF_BUFSIZE bytes
           at a time, so we can't have more bytes than that past PTR.  */
	if (len > RCSBUF_BUFSIZE)
	    abort ();

	/* Update the POS field, which holds the file offset of the
           first byte in the RCSBUF_BUFFER buffer.  */
	rcsbuf->pos += ptr - rcsbuf_buffer;

	memcpy (rcsbuf_buffer, ptr, len);
	ptr = rcsbuf_buffer;
	ptrend = ptr + len;
	rcsbuf->ptrend = ptrend;
    }

    /* Skip leading whitespace.  */

    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, (char **) NULL);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	c = *ptr;
	if (! my_whitespace (c))
	    break;

	++ptr;
    }

    /* If we have reached `;', there is no value. */
    if (c == ';')
    {
	*wordp = NULL;
	*ptr++ = '\0';
	rcsbuf->ptr = ptr;
	rcsbuf->vlen = 0;
	return 1;
    }

    /* PTR now points to the start of a value.  Find out whether it is
       a num, an id, a string or a colon. */
    if (c == ':')
    {
	*wordp = ptr++;
	rcsbuf->ptr = ptr;
	rcsbuf->vlen = 1;
	return 1;
    }

    if (c == '@@')
    {
	char *pat;
	size_t vlen;

	/* Optimize the common case of a value composed of a single
	   '@@' string.  */

	rcsbuf->at_string = 1;

	++ptr;

	*wordp = ptr;

	while (1)
	{
	    while ((pat = memchr (ptr, '@@', ptrend - ptr)) == NULL)
	    {
		/* Note that we pass PTREND as the PTR value to
                   rcsbuf_fill, so that we will wind up setting PTR to
                   the location corresponding to the old PTREND, so
                   that we don't search the same bytes again.  */
		ptr = rcsbuf_fill (rcsbuf, ptrend, NULL, wordp);
		if (ptr == NULL)
		    error (1, 0,
			   "EOF while looking for end of string in RCS file %s",
			   rcsbuf->filename);
		ptrend = rcsbuf->ptrend;
	    }

	    /* Handle the special case of an '@@' right at the end of
               the known bytes.  */
	    if (pat + 1 >= ptrend)
	    {
		/* Note that we pass PAT, not PTR, here.  */
		pat = rcsbuf_fill (rcsbuf, pat, NULL, wordp);
		if (pat == NULL)
		{
		    /* EOF here is OK; it just means that the last
		       character of the file was an '@@' terminating a
		       value for a key type which does not require a
		       trailing ';'.  */
		    pat = rcsbuf->ptrend - 1;

		}
		ptrend = rcsbuf->ptrend;

		/* Note that the value of PTR is bogus here.  This is
		   OK, because we don't use it.  */
	    }

	    if (pat + 1 >= ptrend || pat[1] != '@@')
		break;

	    /* We found an '@@' pair in the string.  Keep looking.  */
	    ++rcsbuf->embedded_at;
	    ptr = pat + 2;
	}

	/* Here PAT points to the final '@@' in the string.  */

	*pat = '\0';

	vlen = pat - *wordp;
	if (vlen == 0)
	    *wordp = NULL;
	rcsbuf->vlen = vlen;
	rcsbuf->ptr = pat + 1;

	return 1;
    }

    /* C is neither `:', `;' nor `@@', so it should be the start of a num
       or an id.  Make sure it is not another special character. */
    if (c == '$' || c == '.' || c == ',')
    {
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);
    }

    *wordp = ptr;
    while (1)
    {
	if (ptr >= ptrend)
	{
	    ptr = rcsbuf_fill (rcsbuf, ptr, (char **) NULL, wordp);
	    if (ptr == NULL)
		error (1, 0, "unexpected end of file reading %s",
		       rcsbuf->filename);
	    ptrend = rcsbuf->ptrend;
	}

	/* Legitimate ID characters are digits, dots and any `graphic
           printing character that is not a special.' This test ought
	   to do the trick. */
	c = *ptr;
	if (isprint (c) &&
	    c != ';' && c != '$' && c != ',' && c != '@@' && c != ':')
	{
	    ++ptr;
	    continue;
	}
	break;
    }

    /* PTR points to the last non-id character in this word, and C is
       the character in its memory cell.  Check to make sure that it
       is a legitimate word delimiter -- whitespace or semicolon. */
    if (c == ';' || my_whitespace (c))
    {
	rcsbuf->vlen = ptr - *wordp;
	rcsbuf->ptr = ptr;
	return 1;
    }

    error (1, 0, "illegal special character in RCS field in %s",
	   rcsbuf->filename);
    /* Shut up compiler warnings.  */
    return 0;

#undef my_whitespace
}

a1877 83
 * Get existing revision number corresponding to tag or revision.
 * Similar to RCS_gettag but less interpretation imposed.
 * For example:
 * -- If tag designates a magic branch, RCS_tag2rev
 *    returns the magic branch number.
 * -- If tag is a branch tag, returns the branch number, not
 *    the revision of the head of the branch.
 * If tag or revision is not valid or does not exist in file,
 * exit with error.
 */
char *
RCS_tag2rev (rcs, tag)
    RCSNode *rcs;
    char *tag;
{
    char *rev, *pa, *pb;
    int i;

    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    /* If a valid revision, try to look it up */
    if ( RCS_valid_rev (tag) )
    {
	/* Make a copy so we can scribble on it */
	rev =  xstrdup (tag);

	/* If revision exists, return the copy */
	if (RCS_exist_rev (rcs, tag))
	    return rev;

	/* Nope, none such. If tag is not a branch we're done. */ 
	i = numdots (rev);
	if ((i & 1) == 1 )
	{
	    pa = strrchr (rev, '.');
	    if (i == 1 || *(pa-1) != RCS_MAGIC_BRANCH || *(pa-2) != '.')
	    {
		free (rev);
		error (1, 0, "revision `%s' does not exist", tag);
	    }
	}

       /* Tag is branch, but does not exist, try corresponding 
	* magic branch tag.
	*
	* FIXME: assumes all magic branches are of       
	* form "n.n.n ... .0.n".  I'll fix if somebody can
	* send me a method to get a magic branch tag with
	* the 0 in some other position -- <dan@@gasboy.com>
	*/ 
	pa = strrchr (rev, '.');
	pb = xmalloc (strlen (rev) + 3);
	*pa++ = 0;
	(void) sprintf (pb, "%s.%d.%s", rev, RCS_MAGIC_BRANCH, pa);
	free (rev);
	rev = pb;
	if (RCS_exist_rev (rcs, rev))
	    return rev;
	error (1, 0, "revision `%s' does not exist", tag);
    }


    RCS_check_tag (tag); /* exit if not a valid tag */

    /* If tag is "HEAD", special case to get head RCS revision */
    if (tag && (strcmp (tag, TAG_HEAD) == 0))
        return (RCS_head (rcs));

    /* If valid tag let translate_symtag say yea or nay. */
    rev = translate_symtag (rcs, tag);

    if (rev)
        return rev;

    error (1, 0, "tag `%s' does not exist", tag);
    /* NOT REACHED -- error (1 ... ) does not return here */
    return 0;
}

/*
a2346 35
/* Returns the head of the branch which REV is on.  REV can be a
   branch tag or non-branch tag; symbolic or numeric.

   Returns a newly malloc'd string.  Returns NULL if a symbolic name
   isn't found.  */

char *
RCS_branch_head (rcs, rev)
    RCSNode *rcs;
    char *rev;
{
    char *num;
    char *br;
    char *retval;

    assert (rcs != NULL);

    if (RCS_nodeisbranch (rcs, rev))
	return RCS_getbranch (rcs, rev, 1);

    if (isdigit (*rev))
	num = xstrdup (rev);
    else
    {
	num = translate_symtag (rcs, rev);
	if (num == NULL)
	    return NULL;
    }
    br = truncate_revnum (num);
    retval = RCS_getbranch (rcs, br, 1);
    free (br);
    free (num);
    return retval;
}

a2873 34
 * TRUE if argument has valid syntax for an RCS revision or 
 * branch number.  All characters must be digits or dots, first 
 * and last characters must be digits, and no two consecutive 
 * characters may be dots.
 *
 * Intended for classifying things, so this function doesn't 
 * call error.
 */
int 
RCS_valid_rev (rev)
    char *rev;
{
   char last, c;
   last = *rev++;
   if (!isdigit (last))
       return 0;
   while ((c = *rev++))   /* Extra parens placate -Wall gcc option */
   {
       if (c == '.')
       {
           if (last == '.')
               return 0;
           continue;
       }
       last = c;
       if (!isdigit (c))
           return 0;
   }
   if (!isdigit (last))
       return 0;
   return 1;
}

/*
d3528 2
a3529 2
    uid_t rcs_owner = (uid_t) -1;
    gid_t rcs_group = (gid_t) -1;
d3531 2
a3532 1
    int change_rcs_owner_or_group = 0;
d3684 1
d3711 1
a3711 1
	    if (unlink (dest) < 0 && !existence_error (errno))
d3733 2
a3734 2
	    List *links = vers->hardlinks;
	    if (links != NULL)
d3736 4
a3739 1
		Node *uptodate_link;
d3743 25
a3767 4
		   this iteration.  When walklist returns, uptodate_link
		   should point to a hardlist node representing a file
		   in `links' which has recently been checked out, or
		   NULL if no file in `links' has yet been checked out. */
d3769 9
a3777 3
		uptodate_link = NULL;
		(void) walklist (links, find_checkedout_proc, &uptodate_link);
		dellist (&links);
d3781 1
a3781 1
		   invoked, then simply link workfile to that file and return.
d3783 4
a3786 3
		   If one of these conditions is not met, then
		   workfile is the first one in its hardlink group to
		   be checked out, and we must continue with a full
a3790 3
		    struct hardlink_info *hlinfo =
			(struct hardlink_info *) uptodate_link->data;

d3807 1
a3807 1
	    change_rcs_owner_or_group = 1;
d3813 1
a3813 1
	    change_rcs_owner_or_group = 1;
d3992 1
a3992 1
	if (change_rcs_owner_or_group)
d3995 1
a3995 1
		error (0, errno, "could not change owner or group of %s",
d4430 1
d4485 19
a4503 1
	    delta->hardlinks = list_linked_files_on_disk (workfile);
a4994 3
	if (fp == NULL)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (1, errno, "cannot open file %s for comparing", filename);
d5186 2
a5187 5
   Most of the callers only call us because RCS_checkin still tends to
   like a lock (a relic of old behavior inherited from the RCS ci
   program).  If we clean this up, only "cvs admin -l" will still need
   to call RCS_lock.  */

a5255 12
#if 0
	/* Well, first of all, "rev" below should be "xrev" to avoid
	   core dumps.  But more importantly, should we really be
	   breaking the lock unconditionally?  What CVS 1.9 does (via
	   RCS) is to prompt "Revision 1.1 is already locked by fred.
	   Do you want to break the lock? [ny](n): ".  Well, we don't
	   want to interact with the user (certainly not at the
	   server/protocol level, and probably not in the command-line
	   client), but isn't it more sensible to give an error and
	   let the user run "cvs admin -u" if they want to break the
	   lock?  */

a5262 3
#else
	error (1, 0, "Revision %s is already locked by %s", xrev, p->data);
#endif
a5977 46

/*
 * TRUE if there exists a symbolic tag "tag" in file.
 */
int 
RCS_exist_tag (rcs, tag)
    RCSNode *rcs;
    char *tag;
{

    assert (rcs != NULL);

    if (findnode (RCS_symbols (rcs), tag))
    return 1;
    return 0;

}

/*
 * TRUE if RCS revision number "rev" exists.
 * This includes magic branch revisions, not found in rcs->versions, 
 * but only in rcs->symbols, requiring a list walk to find them.
 * Take advantage of list walk callback function already used by 
 * RCS_delete_revs, above.
 */
int
RCS_exist_rev (rcs, rev)
    RCSNode *rcs;
    char *rev;
{

    assert (rcs != NULL);

    if (rcs->flags & PARTIAL)
	RCS_reparsercsfile (rcs, (FILE **) NULL, (struct rcsbuffer *) NULL);

    if (findnode(rcs->versions, rev) != 0)
	return 1;

    if (walklist (RCS_symbols(rcs), findtag, rev) != 0)
	return 1;

    return 0;

}

d6774 1
a6774 1
    char *key, *value, *keybuf, *valbuf, *cp;
d6838 1
a6838 2
    /* The value is optional, according to rcsfile(5).  */
    if (value != NULL && STREQ (value, "dead"))
d6889 1
a6889 6
	int len;
	size_t valbuflen;

	key = NULL;

	if (! rcsbuf_getid (rcsbuf, &keybuf))
a6891 8
	/* rcsbuf_getid did not terminate the key, so copy it to new space. */
	len = rcsbuf->ptr - keybuf;
	key = (char *) xmalloc (sizeof(char) * (len + 1));
	strncpy (key, keybuf, len);
	key[len] = '\0';

	/* The `desc' keyword has only a single string value, with no
	   trailing semicolon, so it must be handled specially. */
a6892 3
	{
	    (void) rcsbuf_getstring (rcsbuf, &valbuf);
	    value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
a6893 53
	}

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	/* The `hardlinks' value is a group of words, which must
	   be parsed separately and added as a list to vnode->hardlinks. */
	if (STREQ (key, "hardlinks"))
	{
	    Node *n;

	    vnode->hardlinks = getlist();
	    while (1)
	    {
		if (! rcsbuf_getword (rcsbuf, &valbuf))
		    error (1, 0, "unexpected end of file reading %s", rcsfile);
		if (valbuf == NULL)
		    break;
		n = getnode();
		n->key = rcsbuf_valcopy (rcsbuf, valbuf, 1, NULL);
		addnode (vnode->hardlinks, n);
	    }
	    continue;
	}
#endif

	/* Get the value. */
	value = NULL;
	while (1)
	{
	    if (! rcsbuf_getword (rcsbuf, &valbuf))
		error (1, 0, "unexpected end of file reading %s", rcsfile);
	    if (valbuf == NULL)
		break;

	    /* Copy valbuf to new space so we can polish it, then
	       append it to value. */

	    if (value == NULL)
	    {
		value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
	    }
	    else
	    {
		char *temp_value;

		temp_value = rcsbuf_valcopy (rcsbuf, valbuf, 1, &valbuflen);
		len = strlen (value);
		value = (char *) xrealloc
		    (value, sizeof(char) * (len + valbuflen + 2));
		value[len] = ' ';
		strcpy (value + len + 1, temp_value);
		free (temp_value);
	    }
	}
d6922 2
a6923 2
	kv->key = key;
	kv->data = value;
a7112 30
#ifdef PRESERVE_PERMISSIONS_SUPPORT

/* Save a filename in a `hardlinks' RCS field.  NODE->KEY will contain
   a full pathname, but currently only basenames are stored in the RCS
   node.  Assume that the filename includes nasty characters and
   @@-escape it. */

static int
puthardlink_proc (node, vfp)
    Node *node;
    void *vfp;
{
    FILE *fp = (FILE *) vfp;
    char *basename = strrchr (node->key, '/');

    if (basename == NULL)
	basename = node->key;
    else
	++basename;

    putc ('\t', fp);
    putc ('@@', fp);
    (void) expand_at_signs (basename, strlen (basename), fp);
    putc ('@@', fp);

    return 0;
}

#endif

a7197 8
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    if (vers->hardlinks)
    {
	fprintf (fp, "\nhardlinks");
	walklist (vers->hardlinks, puthardlink_proc, fp);
	putc (';', fp);
    }
#endif
d7527 2
a7538 3

    free (lockfile);

@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d1407 1
a1407 1
#undef my_whitespace
a4472 3
    if (free_rev)
	free (rev);

a4541 1

a4542 10

	    /* If the open failed because the existing workfile was not
	       writable, try to chmod the file and retry the open.  */
	    if (ofp == NULL && errno == EACCES
		&& isfile (workfile) && !iswritable (workfile))
	    {
		xchmod (workfile, 1);
		ofp = CVS_FOPEN (workfile, expand == KFLAG_B ? "wb" : "w");
	    }

d4544 1
a4544 6
	    {
		error (0, errno, "cannot open %s", workfile);
		if (free_value)
		    free (value);
		return 1;
	    }
d4576 1
a4576 2
		{
		    error (0, errno, "cannot write %s",
a4579 4
		    if (free_value)
			free (value);
		    return 1;
		}
a4587 3
    if (free_value)
	free (value);

d4594 1
a4594 4
	{
	    error (0, errno, "cannot close %s", workfile);
	    return 1;
	}
d4609 1
a4609 4
	{
	    error (0, errno, "cannot close %s", workfile);
	    return 1;
	}
d4627 1
a4627 4
	{
	    error (0, errno, "cannot close %s", sout);
	    return 1;
	}
d4637 5
a4967 1
    int adding_branch = 0;
a4987 35
    /* Is the backend file a symbolic link?  Follow it and replace the
       filename with the destination of the link.  */

    while (islink (rcs->path))
    {
	char *newname;
#ifdef HAVE_READLINK
	/* The clean thing to do is probably to have each filesubr.c
	   implement this (with an error if not supported by the
	   platform, in which case islink would presumably return 0).
	   But that would require editing each filesubr.c and so the
	   expedient hack seems to be looking at HAVE_READLINK.  */
	newname = xreadlink (rcs->path);
#else
	error (1, 0, "internal error: islink doesn't like readlink");
#endif
	
	if (isabsolute (newname))
	{
	    free (rcs->path);
	    rcs->path = newname;
	}
	else
	{
	    char *oldname = last_component (rcs->path);
	    int dirlen = oldname - rcs->path;
	    char *fullnewname = xmalloc (dirlen + strlen (newname) + 1);
	    strncpy (fullnewname, rcs->path, dirlen);
	    strcpy (fullnewname + dirlen, newname);
	    free (newname);
	    free (rcs->path);
	    rcs->path = fullnewname;
	}
    }

a5261 1
	    adding_branch = 1;
d5307 5
a5311 17
	    /* If we are adding a branch, then leave the old lock around.
	       That is sensible in the sense that when adding a branch,
	       we don't need to use the lock to tell us where to check
	       in.  It is fishy in the sense that if it is our own lock,
	       we break it.  However, this is the RCS 5.7 behavior (at
	       the end of addbranch in ci.c in RCS 5.7, it calls
	       removelock only if it is our own lock, not someone
	       else's).  */

	    if (!adding_branch)
	    {
		error (0, 0, "%s: revision %s locked by %s",
		       rcs->path,
		       nodep->key, nodep->data);
		status = 1;
		goto checkin_done;
	    }
d5313 1
a5313 2
	else
	    delnode (nodep);
a6398 12
    if (after == NULL && before == NULL)
    {
	/* The user is trying to delete all revisions.  While an
	   RCS file without revisions makes sense to RCS (e.g. the
	   state after "rcs -i"), CVS has never been able to cope with
	   it.  So at least for now we just make this an error.

	   We don't include rcs->path in the message since "cvs admin"
	   already printed "RCS file:" and the name.  */
	error (1, 0, "attempt to delete all revisions");
    }

d6411 2
d8191 1
a8191 1
static int
a8529 3

    if (tag != NULL)
	tag_check_valid (tag, argc, argv, local, 0, "");
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@a155 18
/* A few generic thoughts on error handling, in particular the
   printing of unexpected characters that we find in the RCS file
   (that is, why we use '\x%x' rather than %c or some such).

   * Avoiding %c means we don't have to worry about what is printable
   and other such stuff.  In error handling, often better to keep it
   simple.

   * Hex rather than decimal or octal because character set standards
   tend to use hex.

   * Saying "character 0x%x" might make it sound like we are printing
   a file offset.  So we use '\x%x'.

   * Would be nice to print the offset within the file, but I can
   imagine various portability hassles (in particular, whether
   unsigned long is always big enough to hold file offsets).  */

d367 1
a367 3
	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
d501 1
a501 3
	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
a585 92
/* Move RCS into or out of the Attic, depending on TOATTIC.  If the
   file is already in the desired place, return without doing
   anything.  At some point may want to think about how this relates
   to RCS_rewrite but that is a bit hairy (if one wants renames to be
   atomic, or that kind of thing).  If there is an error, print a message
   and return 1.  On success, return 0.  */
int
RCS_setattic (rcs, toattic)
    RCSNode *rcs;
    int toattic;
{
    char *newpath;
    char *p;
    char *q;

    /* Some systems aren't going to let us rename an open file.  */
    rcsbuf_cache_close ();

    /* Could make the pathname computations in this file, and probably
       in other parts of rcs.c too, easier if the REPOS and FILE
       arguments to RCS_parse got stashed in the RCSNode.  */

    if (toattic)
    {
	mode_t omask;

	if (rcs->flags & INATTIC)
	    return 0;

	/* Example: rcs->path is "/foo/bar/baz,v".  */
	newpath = xmalloc (strlen (rcs->path) + sizeof CVSATTIC + 5);
	p = last_component (rcs->path);
	strncpy (newpath, rcs->path, p - rcs->path);
	strcpy (newpath + (p - rcs->path), CVSATTIC);

	/* Create the Attic directory if it doesn't exist.  */
	omask = umask (cvsumask);
	if (CVS_MKDIR (newpath, 0777) < 0 && errno != EEXIST)
	    error (0, errno, "cannot make directory %s", newpath);
	(void) umask (omask);

	strcat (newpath, "/");
	strcat (newpath, p);

	if (CVS_RENAME (rcs->path, newpath) < 0)
	{
	    int save_errno = errno;

	    /* The checks for isreadable look awfully fishy, but
	       I'm going to leave them here for now until I
	       can think harder about whether they take care of
	       some cases which should be handled somehow.  */

	    if (isreadable (rcs->path) || !isreadable (newpath))
	    {
		error (0, save_errno, "cannot rename %s to %s",
		       rcs->path, newpath);
		free (newpath);
		return 1;
	    }
	}
    }
    else
    {
	if (!(rcs->flags & INATTIC))
	    return 0;

	newpath = xmalloc (strlen (rcs->path));

	/* Example: rcs->path is "/foo/bar/Attic/baz,v".  */
	p = last_component (rcs->path);
	strncpy (newpath, rcs->path, p - rcs->path - 1);
	newpath[p - rcs->path - 1] = '\0';
	q = newpath + (p - rcs->path - 1) - (sizeof CVSATTIC - 1);
	assert (strncmp (q, CVSATTIC, sizeof CVSATTIC - 1) == 0);
	strcpy (q, p);

	if (CVS_RENAME (rcs->path, newpath) < 0)
	{
	    error (0, errno, "failed to move `%s' out of the attic",
		   rcs->path);
	    free (newpath);
	    return 1;
	}
    }

    free (rcs->path);
    rcs->path = newpath;

    return 0;
}

d674 1
a674 2
			    error (1, 0, "\
unrecognized operation '\\x%x' in %s",
d1482 1
a1482 2
	error (1, 0, "expected @@-string at '\\x%x' in %s",
	       c, rcsbuf->filename);
d1739 1
a1739 1
	if (isprint ((unsigned char) c) &&
d1807 1
a1807 1
    if (! isdigit ((unsigned char) c) && c != '.')
d1809 1
a1809 2
	       "\
unexpected '\\x%x' reading revision number in RCS file %s",
d1829 1
a1829 1
    while (isdigit ((unsigned char) c) || c == '.');
d1832 1
a1832 2
	error (1, 0, "\
unexpected '\\x%x' reading revision number in RCS file %s",
d2340 1
a2340 1
	if (! isdigit ((unsigned char) tag[0]))
d2481 1
a2481 1
    if (!isdigit ((unsigned char) tag[0]))
d2678 1
a2678 1
    if (isdigit ((unsigned char) *rev))
d2705 1
a2705 1
    if (isdigit ((unsigned char) *rev))
d2932 1
a2932 1
    if (isdigit ((unsigned char) *rev))
d3104 2
a3105 17
    if (cur_rev != NULL)
    {
	if (! STREQ (cur_rev, "1.1"))
	    return (xstrdup (cur_rev));

	/* This is 1.1;  if the date of 1.1 is not the same as that for the
	   1.1.1.1 version, then return 1.1.  This happens when the first
	   version of a file is created by a regular cvs add and commit,
	   and there is a subsequent cvs import of the same file.  */
	p = findnode (rcs->versions, "1.1.1.1");
	if (p)
	{
	    vers = (RCSVers *) p->data;
	    if (RCS_datecmp (vers->date, date) != 0)
		return xstrdup ("1.1");
	}
    }
d3457 1
a3457 1
    if (isalpha ((unsigned char) *tag))
d3461 1
a3461 1
	    if (!isgraph ((unsigned char) *cp))
d3488 1
a3488 1
   if (!isdigit ((unsigned char) last))
d3499 1
a3499 1
       if (!isdigit ((unsigned char) c))
d3502 1
a3502 1
   if (!isdigit ((unsigned char) last))
a3537 2
    /* Since RCS_parsercsfile_i now reads expand, don't need to worry
       about RCS_reparsercsfile.  */
a3541 14
/* Set keyword expansion mode to EXPAND.  For example "b" for binary.  */
void
RCS_setexpand (rcs, expand)
    RCSNode *rcs;
    char *expand;
{
    /* Since RCS_parsercsfile_i now reads expand, don't need to worry
       about RCS_reparsercsfile.  */
    assert (rcs != NULL);
    if (rcs->expand != NULL)
	free (rcs->expand);
    rcs->expand = xstrdup (expand);
}

d3743 1
a3743 1
	    if (! isalpha ((unsigned char) *s))
d3846 1
a3846 1
		if (name != NULL && ! isdigit ((unsigned char) *name))
d4189 1
a4189 1
    assert (rev == NULL || isdigit ((unsigned char) *rev));
d5020 34
a5053 5
    /* If the filename is a symbolic link, follow it and replace it
       with the destination of the link.  We need to do this before
       calling rcs_internal_lockfile, or else we won't put the lock in
       the right place. */
    resolve_symlink (&(rcs->path));
d5280 1
a5280 1
	assert (isdigit ((unsigned char) *rev));
d6544 1
a6544 1
	    status = diff_exec (beforefile, afterfile, "-an", outfile);
d7011 1
a7011 2
	    error (1, 0, "unrecognized operation '\\x%x' in %s",
		   op, name);
d7537 1
a7537 3
    for (cp = key;
	 (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	 cp++)
d7721 1
a7721 3
	for (cp = key;
	     (isdigit ((unsigned char) *cp) || *cp == '.') && *cp != '\0';
	     cp++)
a8462 3
    /* Make sure we're operating on an actual file and not a symlink.  */
    resolve_symlink (&(rcs->path));

d8615 1
a8616 1
	send_file_names (argc, argv, SEND_EXPAND_WILD);
d8652 1
a8652 1
    label = (char *) xmalloc (strlen (path)
d8661 1
a8661 1
	(void) sprintf (label, "-L%s\t%s\t%s", path, date, rev);
d8678 1
a8678 1
	    (void) sprintf (label, "-L%s\t%s", path, datebuf);
d8683 1
@


1.1.1.16
log
@Latest version from Cyclic
@
text
@a155 2
static char *rcs_lockfile;

a2522 10
	/* Try for a real (that is, exists in the RCS deltas) branch
	   (RCS_exist_rev just checks for real revisions and revisions
	   which have tags pointing to them).  */
	pa = RCS_getbranch (rcs, rev, 1);
	if (pa != NULL)
	{
	    free (pa);
	    return rev;
	}

d2546 1
a2546 1
    if (tag && STREQ (tag, TAG_HEAD))
d4586 1
a4586 1
	    if (STREQ (devtype, "character"))
d4588 1
a4588 1
	    else if (STREQ (devtype, "block"))
a5148 3
#ifdef PRESERVE_PERMISSIONS_SUPPORT
    struct stat sb;
#endif
d5219 1
a5317 6
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (preserve_perms && !S_ISREG (sb.st_mode))
	    /* Pretend file is empty.  */
	    bufsize = 0;
	else
#endif
a5554 6
#ifdef PRESERVE_PERMISSIONS_SUPPORT
	if (preserve_perms && !S_ISREG (sb.st_mode))
	    /* Pretend file is empty.  */
	    ;
	else
#endif
a6628 15
#if defined (__CYGWIN32__) || defined (_WIN32)
	/* FIXME: This is an awful kludge, but at least until I have
	   time to work on it a little more and test it, I'd rather
	   give a fatal error than corrupt the file.  I think that we
	   need to use "-kb" and "--binary" and "rb" to get_file
	   (probably can do it always, not just for binary files, if
	   we are consistent between the RCS_checkout and the diff).  */
	{
	    char *expand = RCS_getexpand (rcs);
	    if (expand != NULL && STREQ (expand, "b"))
		error (1, 0,
		   "admin -o not implemented yet for binary on this system");
	}
#endif

d6630 1
a6630 1
	status = RCS_checkout (rcs, NULL, after, NULL, "-ko", afterfile,
d6658 1
a6658 1
	    status = RCS_checkout (rcs, NULL, before, NULL, "-ko", beforefile,
d7114 1
a7114 1
	enum {FRAG_ADD, FRAG_DELETE} type;
d7154 1
a7154 1
	    df->type = FRAG_ADD;
d7184 1
a7184 1
	    df->type = FRAG_DELETE;
d7194 1
a7194 1
	case FRAG_ADD:
d7199 1
a7199 1
	case FRAG_DELETE:
a8427 24
/*
 * Clean up temporary files
 */
static RETSIGTYPE
rcs_cleanup ()
{
    /* Note that the checks for existence_error are because we are
       called from a signal handler, so we don't know whether the
       files got created.  */

    /* FIXME: Do not perform buffered I/O from an interrupt handler like
       this (via error).  However, I'm leaving the error-calling code there
       in the hope that on the rare occasion the error call is actually made
       (e.g., a fluky I/O error or permissions problem prevents the deletion
       of a just-created file) reentrancy won't be an issue.  */
    if (rcs_lockfile != NULL)
    {
	if (unlink_file (rcs_lockfile) < 0
	    && !existence_error (errno))
	    error (0, errno, "cannot remove %s", rcs_lockfile);
    }
    rcs_lockfile = NULL;
}

d8452 4
d8463 1
a8466 22
    static int first_call = 1;

    if (first_call)
    {
	first_call = 0;
	/* clean up if we get a signal */
#ifdef SIGHUP
	(void) SIG_register (SIGHUP, rcs_cleanup);
#endif
#ifdef SIGINT
	(void) SIG_register (SIGINT, rcs_cleanup);
#endif
#ifdef SIGQUIT
	(void) SIG_register (SIGQUIT, rcs_cleanup);
#endif
#ifdef SIGPIPE
	(void) SIG_register (SIGPIPE, rcs_cleanup);
#endif
#ifdef SIGTERM
	(void) SIG_register (SIGTERM, rcs_cleanup);
#endif
    }
d8469 1
a8469 2
    assert (rcs_lockfile == NULL);
    rcs_lockfile = rcs_lockfilename (rcsfile);
d8495 1
a8495 2
    fd = open (rcs_lockfile,
	       OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
d8500 1
a8500 1
	error (1, errno, "could not open lock file `%s'", rcs_lockfile);
d8508 1
a8508 1
	error (1, errno, "cannot change mode for %s", rcs_lockfile);
d8512 3
a8514 1
	error (1, errno, "cannot fdopen %s", rcs_lockfile);
d8524 4
a8527 1
    assert (rcs_lockfile != NULL);
d8540 1
a8540 1
	error (1, 0, "error writing to lock file %s", rcs_lockfile);
d8542 1
a8542 3
	error (1, errno, "error closing lock file %s", rcs_lockfile);

    rename_file (rcs_lockfile, rcsfile);
d8544 2
a8545 9
    {
	/* Use a temporary to make sure there's no interval
	   (after rcs_lockfile has been freed but before it's set to NULL)
	   during which the signal handler's use of rcs_lockfile would
	   reference freed memory.  */
	char *tmp = rcs_lockfile;
	rcs_lockfile = NULL;
	free (tmp);
    }
d8669 2
a8670 2
    RCS_deltas (finfo->rcs, fp, rcsbufp, version, RCS_ANNOTATE, NULL,
		NULL, NULL, NULL);
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@a62 1
static int rcsbuf_valcmp PROTO ((struct rcsbuffer *));
a156 1
static int rcs_lockfd = -1;
d545 1
a545 1
	kv->type = rcsbuf_valcmp (&rcsbuf) ? RCSCMPFLD : RCSFIELD;
d547 1
a547 2
	kv->data = rcsbuf_valcopy (&rcsbuf, value, kv->type == RCSFIELD,
				   (size_t *) NULL);
d593 3
a595 1
	rdata->desc = rcsbuf_valcopy (&rcsbuf, value, 1, (size_t *) NULL);
d751 1
a751 1
		kv->type = rcsbuf_valcmp (&rcsbuf) ? RCSCMPFLD : RCSFIELD;
d753 1
a753 2
		kv->data = rcsbuf_valcopy (&rcsbuf, value, kv->type == RCSFIELD,
					   (size_t *) NULL);
a1030 3
/* Note that the extreme hair in rcsbuf_getkey is because profiling
   statistics show that it was worth it. */

d1286 1
a1286 1
           '@@' stripping done in the default case above.  This
d1289 4
a1292 1
	((*valp)--)[rcsbuf->vlen++] = '@@';
d1329 408
a1736 1
	    size_t vlen;
d1738 2
a1739 2
	    /* We're done with the value.  Trim any trailing
               whitespace.  */
d1741 9
a1749 1
	    rcsbuf->ptr = psemi + 1;
d1751 9
a1759 4
	    start = *valp;
	    while (psemi > start && my_whitespace (psemi[-1]))
		--psemi;
	    *psemi = '\0';
d1761 4
a1764 4
	    vlen = psemi - start;
	    if (vlen == 0)
		*valp = NULL;
	    rcsbuf->vlen = vlen;
d1766 2
a1767 2
	    return 1;
	}
d1769 1
a1769 8
	/* We found an '@@' string in the value.  We set RCSBUF->AT_STRING
	   and RCSBUF->EMBEDDED_AT to indicate that we won't be able to
	   compress whitespace correctly for this type of value.
	   Since this type of value never arises in a normal RCS file,
	   this should not be a big deal.  It means that if anybody
	   adds a phrase which can have both an '@@' string and regular
	   text, they will have to handle whitespace compression
	   themselves.  */
d1771 1
a1771 2
	rcsbuf->at_string = 1;
	rcsbuf->embedded_at = -1;
d1773 1
a1773 1
	ptr = pat + 1;
d1780 2
a1781 2
                   rcsbuff_fill, so that we will wind up setting PTR
                   to the location corresponding to the old PTREND, so
d1783 1
a1783 1
		ptr = rcsbuf_fill (rcsbuf, ptrend, keyp, valp);
d1795 11
a1805 4
		ptr = rcsbuf_fill (rcsbuf, ptr, keyp, valp);
		if (ptr == NULL)
		    error (1, 0, "EOF in value in RCS file %s",
			   rcsbuf->filename);
d1807 3
d1812 1
a1812 1
	    if (pat[1] != '@@')
d1816 1
d1821 53
a1873 1
	ptr = pat + 1;
d1876 5
a1986 2
	koff = keyp == NULL ? 0 : *keyp - rcsbuf_buffer;
	voff = valp == NULL ? 0 : *valp - rcsbuf_buffer;
a2011 10
/* Test whether the last value returned by rcsbuf_getkey is a composite
   value or not. */
   
static int
rcsbuf_valcmp (rcsbuf)
    struct rcsbuffer *rcsbuf;
{
    return rcsbuf->at_string && rcsbuf->embedded_at < 0;
}

d2035 1
a2035 1
    embedded_at = rcsbuf->embedded_at < 0 ? 0 : rcsbuf->embedded_at;
a2141 1
	assert (embedded_at > 0);
a2189 106
#ifdef PRESERVE_PERMISSIONS_SUPPORT

/* Copy the next word from the value VALP returned by rcsbuf_getkey into a
   memory buffer, updating VALP and returning the memory buffer.  Return
   NULL when there are no more words. */

static char *
rcsbuf_valword (rcsbuf, valp)
    struct rcsbuffer *rcsbuf;
    char **valp;
{
    register const char * const my_spacetab = spacetab;
    register char *ptr, *pat;
    char c;

#define my_whitespace(c)	(my_spacetab[(unsigned char)c] != 0)

    if (*valp == NULL)
	return NULL;

    for (ptr = *valp; my_whitespace (*ptr); ++ptr) ;
    if (*ptr == '\0')
    {
	assert (ptr - *valp == rcsbuf->vlen);
	*valp = NULL;
	rcsbuf->vlen = 0;
	return NULL;
    }

    /* PTR now points to the start of a value.  Find out whether it is
       a num, an id, a string or a colon. */
    c = *ptr;
    if (c == ':')
    {
	rcsbuf->vlen -= ++ptr - *valp;
	*valp = ptr;
	return xstrdup (":");
    }

    if (c == '@@')
    {
	int embedded_at = 0;
	size_t vlen;

	pat = ++ptr;
	while ((pat = strchr (pat, '@@')) != NULL)
	{
	    if (pat[1] != '@@')
		break;
	    ++embedded_at;
	    pat += 2;
	}

	/* Here PAT points to the final '@@' in the string.  */
	*pat++ = '\0';
	assert (rcsbuf->at_string);
	vlen = rcsbuf->vlen - (pat - *valp);
	rcsbuf->vlen = pat - ptr - 1;
	rcsbuf->embedded_at = embedded_at;
	ptr = rcsbuf_valcopy (rcsbuf, ptr, 0, (size_t *) NULL);
	*valp = pat;
	rcsbuf->vlen = vlen;
	if (strchr (pat, '@@') == NULL)
	    rcsbuf->at_string = 0;
	else
	    rcsbuf->embedded_at = -1;
	return ptr;
    }

    /* *PTR is neither `:', `;' nor `@@', so it should be the start of a num
       or an id.  Make sure it is not another special character. */
    if (c == '$' || c == '.' || c == ',')
    {
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);
    }

    pat = ptr;
    while (1)
    {
	/* Legitimate ID characters are digits, dots and any `graphic
           printing character that is not a special.' This test ought
	   to do the trick. */
	c = *++pat;
	if (!isprint ((unsigned char) c) ||
	    c == ';' || c == '$' || c == ',' || c == '@@' || c == ':')
	    break;
    }

    /* PAT points to the last non-id character in this word, and C is
       the character in its memory cell.  Check to make sure that it
       is a legitimate word delimiter -- whitespace or end. */
    if (c != '\0' && !my_whitespace (c))
	error (1, 0, "illegal special character in RCS field in %s",
	       rcsbuf->filename);

    *pat = '\0';
    rcsbuf->vlen -= pat - *valp;
    *valp = pat;
    return xstrdup (ptr);

#undef my_whitespace
}

#endif

d2867 1
a2868 1
    free (version);
d2917 1
a2918 1
    free (version);
a4069 1
		|| log == NULL
a4087 4
	    /* CVS never has empty log messages, but old RCS files might.  */
	    if (log == NULL)
		log = "";

a4657 1
#ifdef HAVE_MKNOD
a4677 5
#else
	error (1, 0,
"cannot create %s: unable to create special files on this system",
workfile);
#endif
a5040 1
	free (branchpoint);
a5042 1
    free (branchpoint);
a5243 1
	    np->type = RCSFIELD;
a5251 1
	    np->type = RCSFIELD;
a5257 1
	    np->type = RCSFIELD;
a5263 1
	    np->type = RCSFIELD;
a5273 1
#ifdef HAVE_ST_RDEV
a5274 1
		    np->type = RCSFIELD;
a5281 5
#else
		    error (0, 0,
"can't preserve %s: unable to save device files on this system",
workfile);
#endif
d5326 1
a5326 1
	nodep->delproc = rcsvers_delproc;
a5327 1
	nodep->key = delta->version;
d5361 1
d5373 1
a5373 2
	status = 0;
	goto checkin_done;
a5468 7
	    if (!delta->version)
	    {
		free (branch);
		free (newrev);
		status = 1;
		goto checkin_done;
	    }
d5693 1
a5693 1
    nodep->delproc = rcsvers_delproc;
a5694 1
    nodep->key = delta->version;
a5716 1
    free (tmpfile);
a5718 1
    free (changefile);
a5800 1
	free (tmp);
d6161 1
a6161 1
	    if (lock != NULL)
d6163 4
a6166 2
		if (!unlock_quiet)
		    error (0, 0, "\
d6168 3
a6170 1
		return 1;
a6171 1
	    lock = p;
a6250 1
	free (access);
a6273 7
    if (user == NULL)
    {
        free (rcs->access);
        rcs->access = NULL;
        return;
    }

d6278 3
a6280 2
	if (strncmp (p, user, ulen) == 0 && (p[ulen] == '\0' || p[ulen] == ' '))
	    break;
d7679 1
a7679 1
    char *key, *value, *cp;
d7797 6
a7802 1
	if (! rcsbuf_getkey (rcsbuf, &key, &value))
d7805 12
a7816 2
	/* The `desc' keyword is the end of the deltas. */
	if (strcmp (key, RCSDESC) == 0)
d7818 1
a7820 1

d7823 1
a7823 1
	if (strcmp (key, "hardlinks") == 0)
d7825 1
a7825 1
	    char *word;
d7828 1
a7828 1
	    while ((word = rcsbuf_valword (rcsbuf, &value)) != NULL)
d7830 6
a7835 2
		Node *n = getnode();
		n->key = word;
d7842 30
d7900 3
a7902 4
	kv->type = rcsbuf_valcmp (rcsbuf) ? RCSCMPFLD : RCSFIELD;
	kv->key = xstrdup (key);
	kv->data = rcsbuf_valcopy (rcsbuf, value, kv->type == RCSFIELD,
				   (size_t *) NULL);
d7987 1
a7987 1
	p->type = rcsbuf_valcmp (rcsbuf) ? RCSCMPFLD : RCSFIELD;
d7989 1
a7989 2
	p->data = rcsbuf_valcopy (rcsbuf, value, p->type == RCSFIELD,
				  (size_t *) NULL);
d8070 2
a8071 2

	if (node->type == RCSCMPFLD || strpbrk (node->data, "$,.:;@@") == NULL)
d8232 1
a8232 7
    if (p == NULL)
    {
        error (1, 0,
               "error parsing repository file %s, file may be corrupt.", 
               rcs->path);
    }
 
a8352 1
	    freedeltatext (dtext);
d8472 1
a8472 1
RETSIGTYPE
d8486 1
a8486 9
	char *tmp = rcs_lockfile;
	rcs_lockfile = NULL;
	if (rcs_lockfd >= 0)
	{
	    if (close (rcs_lockfd) != 0)
		error (0, errno, "error closing lock file %s", tmp);
	    rcs_lockfd = -1;
	}
	if (unlink_file (tmp) < 0
d8488 1
a8488 1
	    error (0, errno, "cannot remove %s", tmp);
d8490 1
d8524 1
a8532 3
#ifdef SIGABRT
	(void) SIG_register (SIGABRT, rcs_cleanup);
#endif
a8551 1
    assert (rcs_lockfd < 0);
d8578 3
a8580 3
    rcs_lockfd = open (rcs_lockfile,
		       OPEN_BINARY | O_WRONLY | O_CREAT | O_EXCL | O_TRUNC,
		       S_IRUSR | S_IRGRP | S_IROTH);
d8582 1
a8582 1
    if (rcs_lockfd < 0)
d8591 1
a8591 1
    if (fchmod (rcs_lockfd, rstat.st_mode) < 0)
d8594 1
a8594 1
    fp = fdopen (rcs_lockfd, FOPEN_BINARY_WRITE);
a8606 1
    assert (rcs_lockfd >= 0);
a8621 1
    rcs_lockfd = -1;
a8712 16
}

/* Abandon changes to an RCS file. */

void
RCS_abandon (rcs)
    RCSNode *rcs;
{
    free_rcsnode_contents (rcs);
    rcs->symbols_data = NULL;
    rcs->expand = NULL;
    rcs->access = NULL;
    rcs->locks_data = NULL;
    rcs->comment = NULL;
    rcs->desc = NULL;
    rcs->flags |= PARTIAL;
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@d95 5
d2129 1
a2129 1
 * return NULL.
d2208 3
a2210 2
    /* Trust the caller to print warnings. */
    return NULL;
d4150 1
a4150 1
	    if (CVS_UNLINK (dest) < 0 && !existence_error (errno))
d4320 1
a4320 1
	if (CVS_UNLINK (dest) < 0 && existence_error (errno))
d5263 1
a5263 1
	switch (diff_exec (workfile, tmpfile, NULL, NULL, diffopts, changefile))
d5311 1
a5311 1
	switch (diff_exec (tmpfile, workfile, NULL, NULL, diffopts, changefile))
d5691 1
a5691 1
     char *rev;
d5710 18
a5727 2
    else
	xrev = RCS_gettag (rcs, rev, 1, (int *) NULL);
d5732 1
a5732 1
    if (xrev == NULL || findnode (rcs->versions, xrev) == NULL)
d5735 1
a5735 1
	    error (0, 0, "%s: revision %s absent", rcs->path, rev);
d5801 1
a5801 1
     char *rev;
d5851 1
a5851 1
    else
d5853 3
a5855 1
	xrev = RCS_gettag (rcs, rev, 1, (int *) NULL);
d5858 1
a5858 1
	    error (0, 0, "%s: revision %s absent", rcs->path, rev);
d5862 3
d6386 1
a6386 1
	    status = diff_exec (beforefile, afterfile, NULL, NULL, "-an", outfile);
d7025 1
a7025 1
void
d8384 132
a8524 5
 *
 * /dev/null is not statted but assumed to have been created on the Epoch.
 * At least using the POSIX.2 definition of patch, this should cause creation
 * of files on platforms such as Windoze where the null IO device isn't named
 * /dev/null to be parsed by patch properly.
d8532 1
a8532 1
    char datebuf[MAXDATELEN + 1];
d8534 1
d8536 1
d8538 2
a8539 3
			      + (rev == NULL ? 0 : strlen (rev) + 1)
			      + MAXDATELEN
			      + 2);
d8543 1
a8543 3
	char date[MAXDATELEN + 1];
	/* revs cannot be attached to /dev/null ... duh. */
	assert (strcmp(DEVNULL, path));
d8545 1
a8545 1
	(void) date_to_internet (date, datebuf);
d8547 1
d8552 1
a8552 1
	struct tm *wm = NULL;
d8554 2
a8555 8
	if (strcmp(DEVNULL, path))
	{
	    char *file = last_component (path);
	    if (CVS_STAT (file, &sb) < 0)
		error (0, 1, "could not get info for `%s'", path);
	    else
		wm = gmtime (&sb.st_mtime);
	}
d8558 5
a8562 7
	    time_t t = 0;
	    wm = gmtime(&t);
	}

	if (wm)
	{
	    (void) tm_to_internet (datebuf, wm);
@


