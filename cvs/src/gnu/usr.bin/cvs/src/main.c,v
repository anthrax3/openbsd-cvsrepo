head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.6
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.8
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.10
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.6
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.12
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.10
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.8
	OPENBSD_5_0:1.39.0.6
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.6
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.38.0.8
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.28
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.26
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.24
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.22
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.37.0.20
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.37.0.18
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.16
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.14
	OPENBSD_3_6_BASE:1.37
	OPENBSD_3_5:1.37.0.12
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.37.0.10
	OPENBSD_3_4_BASE:1.37
	OPENBSD_3_3:1.37.0.8
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.6
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.37.0.4
	OPENBSD_3_1_BASE:1.37
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	cvs-1-11-1p1:1.1.1.17
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_9_BASE:1.36
	cvs-1-11:1.1.1.16
	OPENBSD_2_8:1.35.0.6
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.35.0.4
	OPENBSD_2_7_BASE:1.35
	OPENBSD_2_6:1.35.0.2
	OPENBSD_2_6_BASE:1.35
	cvs-1-10-7:1.1.1.15
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	cvs-1-10-5:1.1.1.14
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	cvs-1-10:1.1.1.13
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.27.0.2
	OPENBSD_2_2_BASE:1.27
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.26.0.2
	OPENBSD_2_1_BASE:1.26
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2015.11.17.12.26.47;	author jca;	state Exp;
branches;
next	1.41;
commitid	pnbRuJGG0raYzIp8;

1.41
date	2013.12.03.01.32.49;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.03.17.02.36;	author jcs;	state Exp;
branches;
next	1.39;

1.39
date	2010.07.22.10.31.10;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.11.00.52.43;	author djm;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.35;

1.35
date	99.09.10.05.41.45;	author tholo;	state Exp;
branches;
next	1.34;

1.34
date	99.09.10.05.21.32;	author tholo;	state Exp;
branches;
next	1.33;

1.33
date	99.02.28.21.57.54;	author tholo;	state Exp;
branches;
next	1.32;

1.32
date	98.08.22.21.04.29;	author tholo;	state Exp;
branches;
next	1.31;

1.31
date	98.07.13.04.17.03;	author tholo;	state Exp;
branches;
next	1.30;

1.30
date	98.03.12.07.22.33;	author tholo;	state Exp;
branches;
next	1.29;

1.29
date	98.02.22.09.27.21;	author tholo;	state Exp;
branches;
next	1.28;

1.28
date	98.02.22.08.56.01;	author tholo;	state Exp;
branches;
next	1.27;

1.27
date	97.06.28.03.45.29;	author tholo;	state Exp;
branches;
next	1.26;

1.26
date	97.04.26.08.33.29;	author tholo;	state Exp;
branches;
next	1.25;

1.25
date	97.04.25.18.13.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.04.21.04.41.05;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	97.03.18.02.09.57;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	97.02.21.07.04.48;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	97.02.21.06.54.56;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	96.11.18.10.36.56;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.10.29.05.03.44;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	96.10.18.17.44.24;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	96.10.18.04.34.07;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	96.10.18.04.19.36;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	96.09.14.21.23.36;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.08.05.16.08.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.07.26.02.21.33;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.12.10.37.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.08.09.46.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.31.13.05.36;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.23.23.00.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.12.03.31.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.06.22.51.16;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.05.05.08.20.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.27.20.26.20;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.30.01.10.46;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.22.57.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.19.10.41.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.15;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.42.01;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.44;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.41;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.38;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.13;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.25;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.47;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.20;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.52;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.54.07;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.08.22.20.53.25;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.02.28.21.33.06;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.09.10.05.06.23;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.02.10.18.57.43;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Pledge cvs(1).

The initial pledge(2) call is broad, we can refine later when we know
whether we run in server, pserver client mode or regular client mode.
pserver server mode is likely broken, it will either be fixed or
removed.

With and ok semarie@@, "let's proceed." deraadt@@
@
text
@/*
 *    Copyright (c) 1992, Brian Berliner and Jeff Polk
 *    Copyright (c) 1989-1992, Brian Berliner
 *
 *    You may distribute under the terms of the GNU General Public License
 *    as specified in the README file that comes with the CVS source distribution.
 *
 * This is the main C driver for the CVS system.
 *
 * Credit to Dick Grune, Vrije Universiteit, Amsterdam, for writing
 * the shell-script CVS system that this is based on.
 *
 */

#include <assert.h>
#include "cvs.h"

#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#else
extern int gethostname ();
#endif

char *program_name;
char *program_path;
char *command_name;

char *global_session_id; /* Random session ID */

/* I'd dynamically allocate this, but it seems like gethostname
   requires a fixed size array.  If I'm remembering the RFCs right,
   256 should be enough.  */
#ifndef MAXHOSTNAMELEN
#define MAXHOSTNAMELEN  256
#endif

char hostname[MAXHOSTNAMELEN];

int use_editor = 1;
int use_cvsrc = 1;
int cvswrite = !CVSREAD_DFLT;
int really_quiet = 0;
int quiet = 0;
int trace = 0;
int noexec = 0;
int readonlyfs = 0;
int logoff = 0;

/* Set if we should be writing CVSADM directories at top level.  At
   least for now we'll make the default be off (the CVS 1.9, not CVS
   1.9.2, behavior). */
int top_level_admin = 0;

mode_t cvsumask = UMASK_DFLT;
char *RCS_citag = NULL;
int disable_mdocdate = 0;

char *CurDir;

/*
 * Defaults, for the environment variables that are not set
 */
char *Tmpdir = TMPDIR_DFLT;
char *Editor = EDITOR_DFLT;


/* When our working directory contains subdirectories with different
   values in CVS/Root files, we maintain a list of them.  */
List *root_directories = NULL;

/* We step through the above values.  This variable is set to reflect
 * the currently active value.
 *
 * Now static.  FIXME - this variable should be removable (well, localizable)
 * with a little more work.
 */
static char *current_root = NULL;


static const struct cmd
{
    char *fullname;		/* Full name of the function (e.g. "commit") */

    /* Synonyms for the command, nick1 and nick2.  We supply them
       mostly for two reasons: (1) CVS has always supported them, and
       we need to maintain compatibility, (2) if there is a need for a
       version which is shorter than the fullname, for ease in typing.
       Synonyms have the disadvantage that people will see "new" and
       then have to think about it, or look it up, to realize that is
       the operation they know as "add".  Also, this means that one
       cannot create a command "cvs new" with a different meaning.  So
       new synonyms are probably best used sparingly, and where used
       should be abbreviations of the fullname (preferably consisting
       of the first 2 or 3 or so letters).

       One thing that some systems do is to recognize any unique
       abbreviation, for example "annotat" "annota", etc., for
       "annotate".  The problem with this is that scripts and user
       habits will expect a certain abbreviation to be unique, and in
       a future release of CVS it may not be.  So it is better to
       accept only an explicit list of abbreviations and plan on
       supporting them in the future as well as now.  */

    char *nick1;
    char *nick2;
    
    int (*func) ();		/* Function takes (argc, argv) arguments. */
    unsigned long attr;		/* Attributes. */
} cmds[] =

{
    { "add",      "ad",       "new",       add,       CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "admin",    "adm",      "rcs",       admin,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "annotate", "ann",      "blame",     annotate,  CVS_CMD_USES_WORK_DIR },
    { "checkout", "co",       "get",       checkout,  0 },
    { "commit",   "ci",       "com",       commit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "diff",     "di",       "dif",       diff,      CVS_CMD_USES_WORK_DIR },
    { "edit",     NULL,       NULL,        edit,      CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "editors",  NULL,       NULL,        editors,   CVS_CMD_USES_WORK_DIR },
    { "export",   "exp",      "ex",        checkout,  CVS_CMD_USES_WORK_DIR },
    { "history",  "hi",       "his",       history,   CVS_CMD_USES_WORK_DIR },
    { "import",   "im",       "imp",       import,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR | CVS_CMD_IGNORE_ADMROOT},
    { "init",     NULL,       NULL,        init,      CVS_CMD_MODIFIES_REPOSITORY },
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
    { "kserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
#endif
    { "log",      "lo",       NULL,        cvslog,    CVS_CMD_USES_WORK_DIR },
#ifdef AUTH_CLIENT_SUPPORT
    { "login",    "logon",    "lgn",       login,     0 },
    { "logout",   NULL,       NULL,        logout,    0 },
#endif /* AUTH_CLIENT_SUPPORT */
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
    { "pserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
#endif
    { "rannotate","rann",     "ra",        annotate,  0 },
    { "rdiff",    "patch",    "pa",        patch,     0 },
    { "release",  "re",       "rel",       release,   0 },
    { "remove",   "rm",       "delete",    cvsremove, CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "rlog",     "rl",       NULL,        cvslog,    0 },
    { "rtag",     "rt",       "rfreeze",   cvstag,    CVS_CMD_MODIFIES_REPOSITORY },
#ifdef SERVER_SUPPORT
    { "server",   NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
#endif
    { "status",   "st",       "stat",      cvsstatus, CVS_CMD_USES_WORK_DIR },
    { "tag",      "ta",       "freeze",    cvstag,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "unedit",   NULL,       NULL,        unedit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "update",   "up",       "upd",       update,    CVS_CMD_USES_WORK_DIR },
    { "version",  "ve",       "ver",       version,   0 },
    { "watch",    NULL,       NULL,        watch,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "watchers", NULL,       NULL,        watchers,  CVS_CMD_USES_WORK_DIR },
    { NULL, NULL, NULL, NULL, 0 },
};

static const char *const usg[] =
{
    /* CVS usage messages never have followed the GNU convention of
       putting metavariables in uppercase.  I don't know whether that
       is a good convention or not, but if it changes it would have to
       change in all the usage messages.  For now, they consistently
       use lowercase, as far as I know.  Puncutation is pretty funky,
       though.  Sometimes they use none, as here.  Sometimes they use
       single quotes (not the TeX-ish `' stuff), as in --help-options.
       Sometimes they use double quotes, as in cvs -H add.

       Most (not all) of the usage messages seem to have periods at
       the end of each line.  I haven't tried to duplicate this style
       in --help as it is a rather different format from the rest.  */

    "Usage: %s [cvs-options] command [command-options-and-arguments]\n",
    "  where cvs-options are -q, -n, etc.\n",
    "    (specify --help-options for a list of options)\n",
    "  where command is add, admin, etc.\n",
    "    (specify --help-commands for a list of commands\n",
    "     or --help-synonyms for a list of command synonyms)\n",
    "  where command-options-and-arguments depend on the specific command\n",
    "    (specify -H followed by a command name for command-specific help)\n",
    "  Specify --help to receive this message\n",
    "\n",

    /* Some people think that a bug-reporting address should go here.  IMHO,
       the web sites are better because anything else is very likely to go
       obsolete in the years between a release and when someone might be
       reading this help.  Besides, we could never adequately discuss
       bug reporting in a concise enough way to put in a help message.  */

    /* I was going to put this at the top, but usage() wants the %s to
       be in the first line.  */
    "The Concurrent Versions System (CVS) is a tool for version control.\n",
    /* I really don't think I want to try to define "version control"
       in one line.  I'm not sure one can get more concise than the
       paragraph in ../cvs.spec without assuming the reader knows what
       version control means.  */

    "For CVS updates and additional information, see\n",
    "    the CVS home page at http://www.cvshome.org/ or\n",
    "    Pascal Molli's CVS site at http://www.loria.fr/~molli/cvs-index.html\n",
    NULL,
};

static const char *const cmd_usage[] =
{
    "CVS commands are:\n",
    "        add          Add a new file/directory to the repository\n",
    "        admin        Administration front end for rcs\n",
    "        annotate     Show last revision where each line was modified\n",
    "        checkout     Checkout sources for editing\n",
    "        commit       Check files into the repository\n",
    "        diff         Show differences between revisions\n",
    "        edit         Get ready to edit a watched file\n",
    "        editors      See who is editing a watched file\n",
    "        export       Export sources from CVS, similar to checkout\n",
    "        history      Show repository access history\n",
    "        import       Import sources into CVS, using vendor branches\n",
    "        init         Create a CVS repository if it doesn't exist\n",
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
    "        kserver      Kerberos server mode\n",
#endif
    "        log          Print out history information for files\n",
#ifdef AUTH_CLIENT_SUPPORT
    "        login        Prompt for password for authenticating server\n",
    "        logout       Removes entry in .cvspass for remote repository\n",
#endif /* AUTH_CLIENT_SUPPORT */
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
    "        pserver      Password server mode\n",
#endif
    "        rannotate    Show last revision where each line of module was modified\n",
    "        rdiff        Create 'patch' format diffs between releases\n",
    "        release      Indicate that a Module is no longer in use\n",
    "        remove       Remove an entry from the repository\n",
    "        rlog         Print out history information for a module\n",
    "        rtag         Add a symbolic tag to a module\n",
#ifdef SERVER_SUPPORT
    "        server       Server mode\n",
#endif
    "        status       Display status information on checked out files\n",
    "        tag          Add a symbolic tag to checked out version of files\n",
    "        unedit       Undo an edit command\n",
    "        update       Bring work tree in sync with repository\n",
    "        version      Show current CVS version(s)\n",
    "        watch        Set watches\n",
    "        watchers     See who is watching a file\n",
    "(Specify the --help option for a list of other help options)\n",
    NULL,
};

static const char *const opt_usage[] =
{
    /* Omit -b because it is just for compatibility.  */
    "CVS global options (specified before the command name) are:\n",
    "    -H           Displays usage information for command.\n",
    "    -Q           Cause CVS to be really quiet.\n",
    "    -q           Cause CVS to be somewhat quiet.\n",
    "    -r           Make checked-out files read-only.\n",
    "    -w           Make checked-out files read-write (default).\n",
    "    -l           Turn history logging off.\n",
    "    -n           Do not execute anything that will change the disk.\n",
    "    -t           Show trace of program execution -- try with -n.\n",
    "    -v           CVS version and copyright.\n",
    "    -R           Read-only repository.\n",
    "    -T tmpdir    Use 'tmpdir' for temporary files.\n",
    "    -e editor    Use 'editor' for editing log information.\n",
    "    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.\n",
    "    -f           Do not use the ~/.cvsrc file.\n",
#ifdef CLIENT_SUPPORT
    "    -z #         Use compression level '#' for net traffic.\n",
#ifdef ENCRYPTION
    "    -x           Encrypt all net traffic.\n",
#endif
    "    -a           Authenticate all net traffic.\n",
#endif
    "    -s VAR=VAL   Set CVS user variable.\n",
    "(Specify the --help option for a list of other help options)\n",
    NULL
};


static int
set_root_directory (p, ignored)
    Node *p;
    void *ignored;
{
    if (current_root == NULL && p->data == NULL)
    {
	current_root = p->key;
	return 1;
    }
    return 0;
}


static const char * const*
cmd_synonyms ()
{
    char ** synonyms;
    char ** line;
    const struct cmd *c = &cmds[0];
    /* Three more for title, "specify --help" line, and NULL.  */
    int numcmds = 3;

    while (c->fullname != NULL)
    {
	numcmds++;
	c++;
    }
    
    synonyms = (char **) xmalloc(numcmds * sizeof(char *));
    line = synonyms;
    *line++ = "CVS command synonyms are:\n";
    for (c = &cmds[0]; c->fullname != NULL; c++)
    {
	if (c->nick1 || c->nick2)
	{
	    *line = xmalloc (strlen (c->fullname)
			     + (c->nick1 != NULL ? strlen (c->nick1) : 0)
			     + (c->nick2 != NULL ? strlen (c->nick2) : 0)
			     + 40);
	    sprintf(*line, "        %-12s %s %s\n", c->fullname,
		    c->nick1 ? c->nick1 : "",
		    c->nick2 ? c->nick2 : "");
	    line++;
	}
    }
    *line++ = "(Specify the --help option for a list of other help options)\n";
    *line = NULL;
    
    return (const char * const*) synonyms; /* will never be freed */
}


unsigned long int
lookup_command_attribute (cmd_name)
     char *cmd_name;
{
    const struct cmd *cm;

    for (cm = cmds; cm->fullname; cm++)
    {
	if (strcmp (cmd_name, cm->fullname) == 0)
	    break;
    }
    return cm->attr;
}


static RETSIGTYPE
main_cleanup (sig)
    int sig;
{
#ifndef DONT_USE_SIGNALS
    const char *name;
    char temp[10];

    switch (sig)
    {
#ifdef SIGABRT
    case SIGABRT:
	name = "abort";
	break;
#endif
#ifdef SIGHUP
    case SIGHUP:
	name = "hangup";
	break;
#endif
#ifdef SIGINT
    case SIGINT:
	name = "interrupt";
	break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
	name = "quit";
	break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
	name = "broken pipe";
	break;
#endif
#ifdef SIGTERM
    case SIGTERM:
	name = "termination";
	break;
#endif
    default:
	/* This case should never be reached, because we list above all
	   the signals for which we actually establish a signal handler.  */
	sprintf (temp, "%d", sig);
	name = temp;
	break;
    }

    error (1, 0, "received %s signal", name);
#endif /* !DONT_USE_SIGNALS */
}

int
main (argc, argv)
    int argc;
    char **argv;
{
    char *CVSroot = CVSROOT_DFLT;
    char *cp, *end;
    const struct cmd *cm;
    int c, err = 0;
    int tmpdir_update_env, cvs_update_env;
    int free_CVSroot = 0;
    int free_Editor = 0;
    int free_Tmpdir = 0;

    int help = 0;		/* Has the user asked for help?  This
				   lets us support the `cvs -H cmd'
				   convention to give help for cmd. */
    static const char short_options[] = "+Qqrwtnlvb:T:e:d:Hfz:s:xaR";
    static struct option long_options[] =
    {
        {"help", 0, NULL, 'H'},
        {"version", 0, NULL, 'v'},
	{"help-commands", 0, NULL, 1},
	{"help-synonyms", 0, NULL, 2},
	{"help-options", 0, NULL, 4},
	{"allow-root", required_argument, NULL, 3},
        {0, 0, 0, 0}
    };
    /* `getopt_long' stores the option index here, but right now we
        don't use it. */
    int option_index = 0;

#ifdef SYSTEM_INITIALIZE
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_INITIALIZE (&argc, &argv);
#endif

#ifdef HAVE_TZSET
    /* On systems that have tzset (which is almost all the ones I know
       of), it's a good idea to call it.  */
    tzset ();
#endif

    /*
     * Just save the last component of the path for error messages
     */
    program_path = xstrdup (argv[0]);
#ifdef ARGV0_NOT_PROGRAM_NAME
    /* On some systems, e.g. VMS, argv[0] is not the name of the command
       which the user types to invoke the program.  */
    program_name = "cvs";
#else
    program_name = last_component (argv[0]);
#endif

    if (pledge("stdio rpath wpath cpath fattr getpw proc exec inet dns tty", NULL) == -1)
	    error (1, errno, "pledge init");

    /*
     * Query the environment variables up-front, so that
     * they can be overridden by command line arguments
     */
    cvs_update_env = 0;
    tmpdir_update_env = *Tmpdir;	/* TMPDIR_DFLT must be set */
    if ((cp = getenv (TMPDIR_ENV)) != NULL)
    {
	Tmpdir = cp;
	tmpdir_update_env = 0;		/* it's already there */
    }
    if ((cp = getenv (EDITOR1_ENV)) != NULL)
 	Editor = cp;
    else if ((cp = getenv (EDITOR2_ENV)) != NULL)
	Editor = cp;
    else if ((cp = getenv (EDITOR3_ENV)) != NULL)
	Editor = cp;
    if ((cp = getenv (CVSROOT_ENV)) != NULL)
    {
	CVSroot = cp;
	cvs_update_env = 0;		/* it's already there */
    }
    if (getenv (CVSREAD_ENV) != NULL)
	cvswrite = 0;
    if (getenv (CVSREADONLYFS_ENV)) {
	readonlyfs = 1;
	logoff = 1;
    }

    /* Set this to 0 to force getopt initialization.  getopt() sets
       this to 1 internally.  */
    optind = 0;

    /* We have to parse the options twice because else there is no
       chance to avoid reading the global options from ".cvsrc".  Set
       opterr to 0 for avoiding error messages about invalid options.
       */
    opterr = 0;

    while ((c = getopt_long
            (argc, argv, short_options, long_options, &option_index))
           != EOF)
    {
	if (c == 'f')
	    use_cvsrc = 0;
    }

    /*
     * Scan cvsrc file for global options.
     */
    if (use_cvsrc)
	read_cvsrc (&argc, &argv, "cvs");

    optind = 0;
    opterr = 1;

    while ((c = getopt_long
            (argc, argv, short_options, long_options, &option_index))
           != EOF)
    {
	switch (c)
	{
            case 1:
	        /* --help-commands */
                usage (cmd_usage);
                break;
            case 2:
	        /* --help-synonyms */
                usage (cmd_synonyms());
                break;
	    case 4:
		/* --help-options */
		usage (opt_usage);
		break;
	    case 3:
		/* --allow-root */
		root_allow_add (optarg);
		break;
	    case 'Q':
		really_quiet = 1;
		/* FALL THROUGH */
	    case 'q':
		quiet = 1;
		break;
	    case 'r':
		cvswrite = 0;
		break;
	    case 'w':
		cvswrite = 1;
		break;
	    case 't':
		trace = 1;
		break;
	    case 'n':
		noexec = 1;
	    case 'l':			/* Fall through */
		logoff = 1;
		break;
	    case 'R':
		logoff = 1;
		readonlyfs = 1;
		break;
	    case 'v':
		(void) fputs ("\n", stdout);
		version (0, (char **) NULL);    
		(void) fputs ("\n", stdout);
		(void) fputs ("\
Copyright (c) 1989-2001 Brian Berliner, david d `zoo' zuhn, \n\
                        Jeff Polk, and other authors\n", stdout);
		(void) fputs ("\n", stdout);
		(void) fputs ("CVS may be copied only under the terms of the GNU General Public License,\n", stdout);
		(void) fputs ("a copy of which can be found with the CVS distribution kit.\n", stdout);
		(void) fputs ("\n", stdout);

		(void) fputs ("Specify the --help option for further information about CVS\n", stdout);

		exit (0);
		break;
	    case 'b':
		/* This option used to specify the directory for RCS
		   executables.  But since we don't run them any more,
		   this is a noop.  Silently ignore it so that .cvsrc
		   and scripts and inetd.conf and such can work with
		   either new or old CVS.  */
		break;
	    case 'T':
		Tmpdir = xstrdup (optarg);
		free_Tmpdir = 1;
		tmpdir_update_env = 1;	/* need to update environment */
		break;
	    case 'e':
		Editor = xstrdup (optarg);
		free_Editor = 1;
		break;
	    case 'd':
		if (CVSroot_cmdline != NULL)
		    free (CVSroot_cmdline);
		CVSroot_cmdline = xstrdup (optarg);
		if (free_CVSroot)
		    free (CVSroot);
		CVSroot = xstrdup (optarg);
		free_CVSroot = 1;
		cvs_update_env = 1;	/* need to update environment */
		break;
	    case 'H':
	        help = 1;
		break;
            case 'f':
		use_cvsrc = 0; /* unnecessary, since we've done it above */
		break;
	    case 'z':
#ifdef CLIENT_SUPPORT
		gzip_level = atoi (optarg);
		if (gzip_level < 0 || gzip_level > 9)
		  error (1, 0,
			 "gzip compression level must be between 0 and 9");
#endif
		/* If no CLIENT_SUPPORT, we just silently ignore the gzip
		   level, so that users can have it in their .cvsrc and not
		   cause any trouble.  */
		break;
	    case 's':
		variable_set (optarg);
		break;
	    case 'x':
#ifdef CLIENT_SUPPORT
	        cvsencrypt = 1;
#endif /* CLIENT_SUPPORT */
		/* If no CLIENT_SUPPORT, ignore -x, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   If no ENCRYPTION, we still accept -x, but issue an
                   error if we are being run as a client.  */
		break;
	    case 'a':
#ifdef CLIENT_SUPPORT
		cvsauthenticate = 1;
#endif
		/* If no CLIENT_SUPPORT, ignore -a, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   We will issue an error later if stream
                   authentication is not supported.  */
		break;
	    case '?':
	    default:
                usage (usg);
	}
    }

    argc -= optind;
    argv += optind;
    if (argc < 1)
	usage (usg);

    /* Generate the cvs global session ID */

    {
	int i = 0;
	u_int32_t c;
	global_session_id = xmalloc(17);

	while (i <= 16) {
	    c = arc4random_uniform(75) + 48;
	    if ((c >= 48 && c <= 57) || (c >= 65 && c <= 90) ||
	        (c >= 97 && c <= 122)) {
		global_session_id[i] = c;
		i++;
	    }
	}
	global_session_id[16] = '\0';
    }

    if (trace)
	fprintf (stderr, "main: Session ID is %s", global_session_id);


    /* Look up the command name. */

    command_name = argv[0];
    for (cm = cmds; cm->fullname; cm++)
    {
	if (cm->nick1 && !strcmp (command_name, cm->nick1))
	    break;
	if (cm->nick2 && !strcmp (command_name, cm->nick2))
	    break;
	if (!strcmp (command_name, cm->fullname))
	    break;
    }

    if (!cm->fullname)
    {
	fprintf (stderr, "Unknown command: `%s'\n\n", command_name);
	usage (cmd_usage);
    }
    else
	command_name = cm->fullname;	/* Global pointer for later use */

    if (help)
    {
	argc = -1;		/* some functions only check for this */
	err = (*(cm->func)) (argc, argv);
    }
    else
    {
	/* The user didn't ask for help, so go ahead and authenticate,
           set up CVSROOT, and the rest of it. */

	/* The UMASK environment variable isn't handled with the
	   others above, since we don't want to signal errors if the
	   user has asked for help.  This won't work if somebody adds
	   a command-line flag to set the umask, since we'll have to
	   parse it before we get here. */

	if ((cp = getenv (CVSUMASK_ENV)) != NULL)
	{
	    /* FIXME: Should be accepting symbolic as well as numeric mask.  */
	    cvsumask = strtol (cp, &end, 8) & 0777;
	    if (*end != '\0')
		error (1, errno, "invalid umask value in %s (%s)",
		       CVSUMASK_ENV, cp);
	}

#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
	/* If we are invoked with a single argument "kserver", then we are
	   running as Kerberos server as root.  Do the authentication as
	   the very first thing, to minimize the amount of time we are
	   running as root.  */
	if (strcmp (command_name, "kserver") == 0)
	{
	    kserver_authenticate_connection ();

	    /* Pretend we were invoked as a plain server.  */
	    command_name = "server";
	}
#endif /* HAVE_KERBEROS */


#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
	if (strcmp (command_name, "pserver") == 0)
	{
	    /* The reason that --allow-root is not a command option
	       is mainly the comment in server() about how argc,argv
	       might be from .cvsrc.  I'm not sure about that, and
	       I'm not sure it is only true of command options, but
	       it seems easier to make it a global option.  */

	    /* Gets username and password from client, authenticates, then
	       switches to run as that user and sends an ACK back to the
	       client. */
	    pserver_authenticate_connection ();
      
	    /* Pretend we were invoked as a plain server.  */
	    command_name = "server";
	}
#endif /* (AUTH_SERVER_SUPPORT || HAVE_GSSAPI) && SERVER_SUPPORT */

#ifdef SERVER_SUPPORT
	server_active = strcmp (command_name, "server") == 0;
	if (server_active)
	{
	    if (pledge("stdio rpath wpath cpath fattr getpw proc exec", NULL) == -1)
	        error (1, errno, "pledge");

	}
#endif

	/* This is only used for writing into the history file.  For
	   remote connections, it might be nice to have hostname
	   and/or remote path, on the other hand I'm not sure whether
	   it is worth the trouble.  */

#ifdef SERVER_SUPPORT
	if (server_active)
	    CurDir = xstrdup ("<remote>");
	else
#endif
	{
	    CurDir = xgetwd ();
            if (CurDir == NULL)
		error (1, errno, "cannot get working directory");
	}

	if (Tmpdir == NULL || Tmpdir[0] == '\0')
	    Tmpdir = "/tmp";

#ifdef HAVE_PUTENV
	if (tmpdir_update_env)
	{
	    char *env;
	    env = xmalloc (strlen (TMPDIR_ENV) + strlen (Tmpdir) + 1 + 1);
	    (void) sprintf (env, "%s=%s", TMPDIR_ENV, Tmpdir);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
#endif

#ifndef DONT_USE_SIGNALS
	/* make sure we clean up on error */
#ifdef SIGABRT
	(void) SIG_register (SIGABRT, main_cleanup);
#endif
#ifdef SIGHUP
	(void) SIG_register (SIGHUP, main_cleanup);
#endif
#ifdef SIGINT
	(void) SIG_register (SIGINT, main_cleanup);
#endif
#ifdef SIGQUIT
	(void) SIG_register (SIGQUIT, main_cleanup);
#endif
#ifdef SIGPIPE
	(void) SIG_register (SIGPIPE, main_cleanup);
#endif
#ifdef SIGTERM
	(void) SIG_register (SIGTERM, main_cleanup);
#endif
#endif /* !DONT_USE_SIGNALS */

	gethostname(hostname, sizeof (hostname));

#ifdef KLUDGE_FOR_WNT_TESTSUITE
	/* Probably the need for this will go away at some point once
	   we call fflush enough places (e.g. fflush (stdout) in
	   cvs_outerr).  */
	(void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	(void) setvbuf (stderr, (char *) NULL, _IONBF, 0);
#endif /* KLUDGE_FOR_WNT_TESTSUITE */

	if (use_cvsrc)
	    read_cvsrc (&argc, &argv, command_name);

#ifdef SERVER_SUPPORT
	/* Fiddling with CVSROOT doesn't make sense if we're running
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

	if (!server_active)
#endif
	{
	    char *CVSADM_Root;
	    
	    /* See if we are able to find a 'better' value for CVSroot
	       in the CVSADM_ROOT directory. */

	    CVSADM_Root = NULL;

	    /* "cvs import" shouldn't check CVS/Root; in general it
	       ignores CVS directories and CVS/Root is likely to
	       specify a different repository than the one we are
	       importing to.  */

	    if (!(cm->attr & CVS_CMD_IGNORE_ADMROOT)

		/* -d overrides CVS/Root, so don't give an error if the
		   latter points to a nonexistent repository.  */
		&& CVSroot_cmdline == NULL)
	    {
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
	    }

	    if (CVSADM_Root != NULL)
	    {
		if (CVSroot == NULL || !cvs_update_env)
		{
		    CVSroot = CVSADM_Root;
		    cvs_update_env = 1;	/* need to update environment */
		}
	    }

	    /* Now we've reconciled CVSROOT from the command line, the
	       CVS/Root file, and the environment variable.  Do the
	       last sanity checks on the variable. */

	    if (! CVSroot)
	    {
		error (0, 0,
		       "No CVSROOT specified!  Please use the `-d' option");
		error (1, 0,
		       "or set the %s environment variable.", CVSROOT_ENV);
	    }
	    
	    if (! *CVSroot)
	    {
		error (0, 0,
		       "CVSROOT is set but empty!  Make sure that the");
		error (0, 0,
		       "specification of CVSROOT is legal, either via the");
		error (0, 0,
		       "`-d' option, the %s environment variable, or the",
		       CVSROOT_ENV);
		error (1, 0,
		       "CVS/Root file (if any).");
	    }
	}

	/* Here begins the big loop over unique cvsroot values.  We
           need to call do_recursion once for each unique value found
           in CVS/Root.  Prime the list with the current value. */

	/* Create the list. */
	assert (root_directories == NULL);
	root_directories = getlist ();

	/* Prime it. */
	if (CVSroot != NULL)
	{
	    Node *n;
	    n = getnode ();
	    n->type = NT_UNKNOWN;
	    n->key = xstrdup (CVSroot);
	    n->data = NULL;

	    if (addnode (root_directories, n))
		error (1, 0, "cannot add initial CVSROOT %s", n->key);
	}

	assert (current_root == NULL);

	/* If we're running the server, we want to execute this main
	   loop once and only once (we won't be serving multiple roots
	   from this connection, so there's no need to do it more than
	   once).  To get out of the loop, we perform a "break" at the
	   end of things.  */

	while (
#ifdef SERVER_SUPPORT
	       server_active ||
#endif
	       walklist (root_directories, set_root_directory, NULL)
	       )
	{
#ifdef SERVER_SUPPORT
	    /* Fiddling with CVSROOT doesn't make sense if we're running
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

	    if (!server_active)
#endif
	    {
		/* Now we're 100% sure that we have a valid CVSROOT
		   variable.  Parse it to see if we're supposed to do
		   remote accesses or use a special access method. */

		if (current_parsed_root != NULL)
		    free_cvsroot_t (current_parsed_root);
		if ((current_parsed_root = parse_cvsroot (current_root)) == NULL)
		    error (1, 0, "Bad CVSROOT.");

		if (current_parsed_root->method == pserver_method) {
			if (strcmp(command_name, "login") == 0) {
				if (pledge("stdio rpath wpath cpath fattr getpw inet dns tty", NULL) == -1)
					error (1, errno, "pledge");
			} else {
				if (pledge("stdio rpath wpath cpath fattr getpw proc exec inet dns", NULL) == -1)
					error (1, errno, "pledge");
			}
		} else {
			if (pledge("stdio rpath wpath cpath fattr getpw proc exec", NULL) == -1)
				error (1, errno, "pledge");
		}

		if (trace)
		    fprintf (stderr, "%s-> main loop with CVSROOT=%s\n",
			   CLIENT_SERVER_STR, current_root);

		/*
		 * Check to see if the repository exists.
		 */
#ifdef CLIENT_SUPPORT
		if (!current_parsed_root->isremote)
#endif	/* CLIENT_SUPPORT */
		{
		    char *path;
		    int save_errno;

		    path = xmalloc (strlen (current_parsed_root->directory)
				    + sizeof (CVSROOTADM)
				    + 20);
		    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
		    if (readonlyfs == 0 && !isaccessible (path, R_OK | X_OK))
		    {
			save_errno = errno;
			/* If this is "cvs init", the root need not exist yet.  */
			if (strcmp (command_name, "init") != 0)
			{
			    error (1, save_errno, "%s", path);
			}
		    }
		    free (path);
		}

#ifdef HAVE_PUTENV
		/* Update the CVSROOT environment variable if necessary. */
		/* FIXME (njc): should we always set this with the CVSROOT from the command line? */
		if (cvs_update_env)
		{
		    static char *prev;
		    char *env;
		    env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot)
				   + 1 + 1);
		    (void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
		    (void) putenv (env);
		    /* do not free env yet, as putenv has control of it */
		    /* but do free the previous value, if any */
		    if (prev != NULL)
			free (prev);
		    prev = env;
		}
#endif
	    }
	
	    /* Parse the CVSROOT/config file, but only for local.  For the
	       server, we parse it after we know $CVSROOT.  For the
	       client, it doesn't get parsed at all, obviously.  The
	       presence of the parse_config call here is not mean to
	       predetermine whether CVSROOT/config overrides things from
	       read_cvsrc and other such places or vice versa.  That sort
	       of thing probably needs more thought.  */
	    if (1
#ifdef SERVER_SUPPORT
		&& !server_active
#endif
#ifdef CLIENT_SUPPORT
		&& !current_parsed_root->isremote
#endif
		)
	    {
		/* If there was an error parsing the config file, parse_config
		   already printed an error.  We keep going.  Why?  Because
		   if we didn't, then there would be no way to check in a new
		   CVSROOT/config file to fix the broken one!  */
		parse_config (current_parsed_root->directory);
	    }

#ifdef CLIENT_SUPPORT
	    /* Need to check for current_parsed_root != NULL here since
	     * we could still be in server mode before the server function
	     * gets called below and sets the root
	     */
	    if (current_parsed_root != NULL && current_parsed_root->isremote)
	    {
		/* Create a new list for directory names that we've
		   sent to the server. */
		if (dirs_sent_to_server != NULL)
		    dellist (&dirs_sent_to_server);
		dirs_sent_to_server = getlist ();
	    }
#endif

	    err = (*(cm->func)) (argc, argv);
	
	    /* Mark this root directory as done.  When the server is
               active, current_root will be NULL -- don't try and
               remove it from the list. */

	    if (current_root != NULL)
	    {
		Node *n = findnode (root_directories, current_root);
		assert (n != NULL);
		n->data = (void *) 1;
		current_root = NULL;
	    }
	
#if 0
	    /* This will not work yet, since it tries to free (void *) 1. */
	    dellist (&root_directories);
#endif

#ifdef SERVER_SUPPORT
	    if (server_active)
	      break;
#endif
	} /* end of loop for cvsroot values */

    } /* end of stuff that gets done if the user DOESN'T ask for help */

    Lock_Cleanup ();

    free (program_path);
    if (CVSroot_cmdline != NULL)
	free (CVSroot_cmdline);
    if (free_CVSroot)
	free (CVSroot);
    if (free_Editor)
	free (Editor);
    if (free_Tmpdir)
	free (Tmpdir);
    root_allow_free ();

#ifdef SYSTEM_CLEANUP
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_CLEANUP ();
#endif

    /* This is exit rather than return because apparently that keeps
       some tools which check for memory leaks happier.  */
    exit (err ? EXIT_FAILURE : 0);
	/* Keep picky/stupid compilers (e.g. Visual C++ 5.0) happy.  */
	return 0;
}

char *
Make_Date (rawdate)
    char *rawdate;
{
    time_t unixtime;

    unixtime = get_date (rawdate);
    if (unixtime == (time_t) - 1)
	error (1, 0, "Can't parse date/time: %s", rawdate);
    return date_from_time_t (unixtime);
}

/* Convert a time_t to an RCS format date.  This is mainly for the
   use of "cvs history", because the CVSROOT/history file contains
   time_t format dates; most parts of CVS will want to avoid using
   time_t's directly, and instead use RCS_datecmp, Make_Date, &c.
   Assuming that the time_t is in GMT (as it generally should be),
   then the result will be in GMT too.

   Returns a newly malloc'd string.  */

char *
date_from_time_t (unixtime)
    time_t unixtime;
{
    struct tm *ftm;
    char date[MAXDATELEN];
    char *ret;

    ftm = gmtime (&unixtime);
    if (ftm == NULL)
	/* This is a system, like VMS, where the system clock is in local
	   time.  Hopefully using localtime here matches the "zero timezone"
	   hack I added to get_date (get_date of course being the relevant
	   issue for Make_Date, and for history.c too I think).  */
	ftm = localtime (&unixtime);

    (void) sprintf (date, DATEFORM,
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
    ret = xstrdup (date);
    return (ret);
}

/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is in our internal RCS format.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
date_to_internet (dest, source)
    char *dest;
    const char *source;
{
    struct tm date;

    date_to_tm (&date, source);
    tm_to_internet (dest, &date);
}

void
date_to_tm (dest, source)
    struct tm *dest;
    const char *source;
{
    if (sscanf (source, SDATEFORM,
		&dest->tm_year, &dest->tm_mon, &dest->tm_mday,
		&dest->tm_hour, &dest->tm_min, &dest->tm_sec)
	    != 6)
	/* Is there a better way to handle errors here?  I made this
	   non-fatal in case we are called from the code which can't
	   deal with fatal errors.  */
	error (0, 0, "internal error: bad date %s", source);

    if (dest->tm_year > 100)
	dest->tm_year -= 1900;

    dest->tm_mon -= 1;
}

/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is a pointer to a struct tm.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
tm_to_internet (dest, source)
    char *dest;
    const struct tm *source;
{
    /* Just to reiterate, these strings are from RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    
    sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", source->tm_mday,
	     source->tm_mon < 0 || source->tm_mon > 11 ? "???" : month_names[source->tm_mon],
	     source->tm_year + 1900, source->tm_hour, source->tm_min, source->tm_sec);
}

void
usage (cpp)
    register const char *const *cpp;
{
    (void) fprintf (stderr, *cpp++, program_name, command_name);
    for (; *cpp; cpp++)
	(void) fprintf (stderr, *cpp);
    error_exit();
}
@


1.41
log
@Kill usage of timeb.h for upcoming removal of libcompat.  OK deraadt@@
@
text
@d453 3
d753 6
d942 13
@


1.40
log
@backport commitid support from newer CVS (with a different random id
generator)

writing a commitid is currently disabled

ok deraadt
@
text
@d1081 1
a1081 1
    unixtime = get_date (rawdate, (struct timeb *) NULL);
@


1.39
log
@As per OpenCVS, general usage in coversation and apparently newer
upstream versions of this code, add blame as an alias for annotate.

ok henning@@ fgsch@@ deraadt@@ thib@@ krw@@
@
text
@d28 2
d645 21
@


1.38
log
@Add a CVSROOT/config option "DisableMdocdate" (default:no) to turn off
the OpenBSD-specific Mdocdate expansion. This is useful to avoid
conflicts that arise between the server's expansion of Mdocdate and
the upstream code when maintaining forked OpenBSD derived code on an
OpenBSD CVS server.

"I must grudgingly agree that this is neccessary" deraadt@@
@
text
@d112 1
a112 1
    { "annotate", "ann",      NULL,        annotate,  CVS_CMD_USES_WORK_DIR },
@


1.37
log
@Merge local changes; work in progress
@
text
@d54 1
@


1.36
log
@Integrate local changes
@
text
@d69 6
a74 2
   the currently active value. */
char *current_root = NULL;
d105 1
d109 12
a120 12
    { "add",      "ad",       "new",       add },
    { "admin",    "adm",      "rcs",       admin },
    { "annotate", "ann",      NULL,        annotate },
    { "checkout", "co",       "get",       checkout },
    { "commit",   "ci",       "com",       commit },
    { "diff",     "di",       "dif",       diff },
    { "edit",     NULL,	      NULL,	   edit },
    { "editors",  NULL,       NULL,	   editors },
    { "export",   "exp",      "ex",        checkout },
    { "history",  "hi",       "his",       history },
    { "import",   "im",       "imp",       import },
    { "init",     NULL,       NULL,        init },
d122 1
a122 1
    { "kserver",  NULL,       NULL,        server }, /* placeholder */
d124 1
a124 1
    { "log",      "lo",       "rlog",      cvslog },
d126 2
a127 2
    { "login",    "logon",    "lgn",       login },
    { "logout",   NULL,       NULL,        logout },
d130 1
a130 1
    { "pserver",  NULL,       NULL,        server }, /* placeholder */
d132 6
a137 4
    { "rdiff",    "patch",    "pa",        patch },
    { "release",  "re",       "rel",       release },
    { "remove",   "rm",       "delete",    cvsremove },
    { "rtag",     "rt",       "rfreeze",   rtag },
d139 1
a139 1
    { "server",   NULL,       NULL,        server },
d141 8
a148 8
    { "status",   "st",       "stat",      cvsstatus },
    { "tag",      "ta",       "freeze",    cvstag },
    { "unedit",   NULL,	      NULL,	   unedit },
    { "update",   "up",       "upd",       update },
    { "version",  "ve",       "ver",       version },
    { "watch",    NULL,	      NULL,	   watch },
    { "watchers", NULL,	      NULL,	   watchers },
    { NULL, NULL, NULL, NULL },
d223 1
d227 1
d236 1
d331 1
a331 1
    unsigned long int ret = 0;
d333 1
a333 1
    if (strcmp (cmd_name, "import") != 0)
d335 2
a336 38
        ret |= CVS_CMD_IGNORE_ADMROOT;
    }


    /* The following commands do not use a checked-out working
       directory.  We conservatively assume that everything else does.
       Feel free to add to this list if you are _certain_ something
       something doesn't use the WD. */
    if ((strcmp (cmd_name, "checkout") != 0) &&
        (strcmp (cmd_name, "init") != 0) &&
        (strcmp (cmd_name, "login") != 0) &&
	(strcmp (cmd_name, "logout") != 0) &&
        (strcmp (cmd_name, "rdiff") != 0) &&
        (strcmp (cmd_name, "release") != 0) &&
        (strcmp (cmd_name, "rtag") != 0))
    {
        ret |= CVS_CMD_USES_WORK_DIR;
    }


    /* The following commands do not modify the repository; we
       conservatively assume that everything else does.  Feel free to
       add to this list if you are _certain_ something is safe. */
    if ((strcmp (cmd_name, "annotate") != 0) &&
        (strcmp (cmd_name, "checkout") != 0) &&
        (strcmp (cmd_name, "diff") != 0) &&
        (strcmp (cmd_name, "rdiff") != 0) &&
        (strcmp (cmd_name, "update") != 0) &&
        (strcmp (cmd_name, "editors") != 0) &&
        (strcmp (cmd_name, "export") != 0) &&
        (strcmp (cmd_name, "history") != 0) &&
        (strcmp (cmd_name, "log") != 0) &&
        (strcmp (cmd_name, "noop") != 0) &&
        (strcmp (cmd_name, "watchers") != 0) &&
        (strcmp (cmd_name, "release") != 0) &&
        (strcmp (cmd_name, "status") != 0))
    {
        ret |= CVS_CMD_MODIFIES_REPOSITORY;
d338 1
a338 2

    return ret;
d557 1
a557 1
Copyright (c) 1989-2000 Brian Berliner, david d `zoo' zuhn, \n\
d588 2
a664 9
    /* This should probably remain a warning, rather than an error,
       for quite a while.  For one thing the version of VC distributed
       with GNU emacs 19.34 invokes 'cvs rlog' instead of 'cvs log'.  */
    if (strcmp (argv[0], "rlog") == 0)
    {
	error (0, 0, "warning: the rlog command is deprecated");
	error (0, 0, "use the synonymous log command instead");
    }

d813 1
a813 2
	    if ((lookup_command_attribute (command_name)
		 & CVS_CMD_IGNORE_ADMROOT)
d905 3
a907 1
		if (parse_cvsroot (current_root))
d911 2
a912 2
		    error (0, 0, "notice: main loop with CVSROOT=%s",
			   current_root);
d917 3
a919 1
		if (!client_active)
d924 1
a924 1
		    path = xmalloc (strlen (CVSroot_directory)
d927 1
a927 1
		    (void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
d972 1
a972 1
		&& !client_active
d980 1
a980 1
		parse_config (CVSroot_directory);
d984 5
a988 1
	    if (client_active)
d1106 1
a1106 1
    char *source;
d1108 1
a1108 1
    int year, month, day, hour, minute, second;
d1110 3
a1112 5
    /* Just to reiterate, these strings are from RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
d1114 5
d1120 3
a1122 2
		&year, &month, &day, &hour, &minute, &second)
	!= 6)
d1128 27
a1154 7
    /* Always send a four digit year.  */
    if (year < 100)
	year += 1900;

    sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", day,
	     month < 1 || month > 12 ? "???" : month_names[month - 1],
	     year, hour, minute, second);
@


1.35
log
@Add option to set the repository to read-only on the command line; from
Artur Grabowski <art@@stacken.kth.se>
@
text
@d116 1
a116 1
#ifdef SERVER_SUPPORT
d123 2
a124 1
#ifdef SERVER_SUPPORT
a126 1
#endif /* AUTH_CLIENT_SUPPORT */
d130 4
a134 1
    { "rtag",     "rt",       "rfreeze",   rtag },
d138 1
a140 3
#ifdef SERVER_SUPPORT
    { "server",   NULL,       NULL,        server },
#endif
d185 1
a185 1
    "    Cyclic Software at http://www.cyclic.com/ or\n",
d205 3
d210 2
a211 2
    "        login        Prompt for password for authenticating server.\n",
    "        logout       Removes entry in .cvspass for remote repository.\n",
d213 3
d220 3
d359 1
d379 5
a426 2
    extern char *version_string;
    extern char *config_string;
d438 1
d517 1
a517 1
            (argc, argv, "+f", NULL, NULL))
d534 1
a534 1
            (argc, argv, "+Qqrwtnlvb:T:e:d:Hfz:s:xaR", long_options, &option_index))
d580 2
a581 5
		/* Having the year here is a good idea, so people have
		   some idea of how long ago their version of CVS was
		   released.  */
		(void) fputs (version_string, stdout);
		(void) fputs (config_string, stdout);
d584 1
a584 1
Copyright (c) 1989-1998 Brian Berliner, david d `zoo' zuhn, \n\
d628 1
a628 1
		if (gzip_level <= 0 || gzip_level > 9)
d630 1
a630 1
			 "gzip compression level must be between 1 and 9");
d683 4
a686 1
	usage (cmd_usage);	        /* no match */
d794 3
a798 1
	(void) SIG_register (SIGHUP, Lock_Cleanup);
a801 1
	(void) SIG_register (SIGINT, Lock_Cleanup);
a804 1
	(void) SIG_register (SIGQUIT, Lock_Cleanup);
a807 1
	(void) SIG_register (SIGPIPE, Lock_Cleanup);
a810 1
	(void) SIG_register (SIGTERM, Lock_Cleanup);
d905 1
a905 1
	    n->type = UNKNOWN;
d948 1
a948 3
		 * Check to see if we can write into the history file.  If not,
		 * we assume that we can't work in the repository.
		 * BUT, only if the history file exists.
a949 1

d957 1
a957 2
				    + 20
				    + sizeof (CVSROOTADM_HISTORY));
d959 1
a959 1
		    if (!isaccessible (path, R_OK | X_OK))
a967 8
		    (void) strcat (path, "/");
		    (void) strcat (path, CVSROOTADM_HISTORY);
		    if (readonlyfs == 0 && isfile (path) && !isaccessible (path, R_OK | W_OK))
		    {
			save_errno = errno;
			error (0, 0, "Sorry, you don't have read/write access to the history file");
			error (1, save_errno, "%s", path);
		    }
d976 1
d982 5
a986 1
		    /* do not free env, as putenv has control of it */
@


1.34
log
@Integrate local changes
@
text
@d236 1
d519 1
a519 1
            (argc, argv, "+Qqrwtnlvb:T:e:d:Hfz:s:xa", long_options, &option_index))
d559 4
@


1.33
log
@Integrate local changes
@
text
@d225 1
a235 1
    "    -b bindir    Find RCS programs in 'bindir'.\n",
@


1.32
log
@Integrate local changes
@
text
@d15 1
d63 10
d252 15
a341 1
        (strcmp (cmd_name, "history") != 0) &&
a435 1
    int need_to_create_root = 0;
d595 3
d680 1
d682 2
d740 65
d806 4
d811 2
a812 2
           in server mode, since the client will send the repository
           directory after the connection is made. */
d829 7
a835 3
	    if (lookup_command_attribute (command_name)
                & CVS_CMD_IGNORE_ADMROOT)
            {
d837 1
a837 1
            }
a845 28
		/* Let -d override CVS/Root file.  The user might want
		   to change the access method, use a different server
		   (if there are two server machines which share the
		   repository using a networked file system), etc.  */
		else if (
#ifdef CLIENT_SUPPORT
		         !getenv ("CVS_IGNORE_REMOTE_ROOT") &&
#endif
			 strcmp (CVSroot, CVSADM_Root) != 0)
		{
		    /* Once we have verified that this root is usable,
		       we will want to write it into CVS/Root.

		       Don't do it for the "login" command, however.
		       Consider: if the user executes "cvs login" with
		       the working directory inside an already checked
		       out module, we'd incorrectly change the
		       CVS/Root file to reflect the CVSROOT of the
		       "cvs login" command.  Ahh, the things one
		       discovers. */

		    if (lookup_command_attribute (command_name)
                        & CVS_CMD_USES_WORK_DIR)
                    {
			need_to_create_root = 1;
                    }

		}
d849 2
a850 2
               CVS/Root file, and the environment variable.  Do the
               last sanity checks on the variable. */
d872 22
d895 19
a913 12
	    /* Now we're 100% sure that we have a valid CVSROOT
	       variable.  Parse it to see if we're supposed to do
	       remote accesses or use a special access method. */

	    if (parse_cvsroot (CVSroot))
		error (1, 0, "Bad CVSROOT.");

	    /*
	     * Check to see if we can write into the history file.  If not,
	     * we assume that we can't work in the repository.
	     * BUT, only if the history file exists.
	     */
d915 2
a916 1
	    if (!client_active)
d918 16
a933 2
		char *path;
		int save_errno;
d935 1
a935 6
		path = xmalloc (strlen (CVSroot_directory)
				+ sizeof (CVSROOTADM)
				+ 20
				+ sizeof (CVSROOTADM_HISTORY));
		(void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
		if (!isaccessible (path, R_OK | X_OK))
d937 20
a956 3
		    save_errno = errno;
		    /* If this is "cvs init", the root need not exist yet.  */
		    if (strcmp (command_name, "init") != 0)
d958 2
d962 1
d964 5
a968 3
		(void) strcat (path, "/");
		(void) strcat (path, CVSROOTADM_HISTORY);
		if (readonlyfs == 0 && isfile (path) && !isaccessible (path, R_OK | W_OK))
d970 6
a975 3
		    save_errno = errno;
		    error (0, 0, "Sorry, you don't have read/write access to the history file");
		    error (1, save_errno, "%s", path);
d977 1
a977 1
		free (path);
a978 15

#ifdef HAVE_PUTENV
	    /* Update the CVSROOT environment variable if necessary. */

	    if (cvs_update_env)
	    {
		char *env;
		env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot)
			       + 1 + 1);
		(void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
		(void) putenv (env);
		/* do not free env, as putenv has control of it */
	    }
#endif
	}
d980 8
a987 5
	/* This is only used for writing into the history file.  For
	   remote connections, it might be nice to have hostname
	   and/or remote path, on the other hand I'm not sure whether
	   it is worth the trouble.  */

d989 1
a989 3
	if (server_active)
	    CurDir = xstrdup ("<remote>");
	else
d991 2
a992 18
	{
	    CurDir = xgetwd ();
            if (CurDir == NULL)
		error (1, errno, "cannot get working directory");
	}

	if (Tmpdir == NULL || Tmpdir[0] == '\0')
	    Tmpdir = "/tmp";

#ifdef HAVE_PUTENV
	if (tmpdir_update_env)
	{
	    char *env;
	    env = xmalloc (strlen (TMPDIR_ENV) + strlen (Tmpdir) + 1 + 1);
	    (void) sprintf (env, "%s=%s", TMPDIR_ENV, Tmpdir);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
d994 8
d1003 9
a1011 5
#ifndef DONT_USE_SIGNALS
	/* make sure we clean up on error */
#ifdef SIGHUP
	(void) SIG_register (SIGHUP, main_cleanup);
	(void) SIG_register (SIGHUP, Lock_Cleanup);
a1012 17
#ifdef SIGINT
	(void) SIG_register (SIGINT, main_cleanup);
	(void) SIG_register (SIGINT, Lock_Cleanup);
#endif
#ifdef SIGQUIT
	(void) SIG_register (SIGQUIT, main_cleanup);
	(void) SIG_register (SIGQUIT, Lock_Cleanup);
#endif
#ifdef SIGPIPE
	(void) SIG_register (SIGPIPE, main_cleanup);
	(void) SIG_register (SIGPIPE, Lock_Cleanup);
#endif
#ifdef SIGTERM
	(void) SIG_register (SIGTERM, main_cleanup);
	(void) SIG_register (SIGTERM, Lock_Cleanup);
#endif
#endif /* !DONT_USE_SIGNALS */
d1014 5
a1018 1
	gethostname(hostname, sizeof (hostname));
d1020 12
a1031 10
#ifdef KLUDGE_FOR_WNT_TESTSUITE
	/* Probably the need for this will go away at some point once
	   we call fflush enough places (e.g. fflush (stdout) in
	   cvs_outerr).  */
	(void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	(void) setvbuf (stderr, (char *) NULL, _IONBF, 0);
#endif /* KLUDGE_FOR_WNT_TESTSUITE */

	if (use_cvsrc)
	    read_cvsrc (&argc, &argv, command_name);
a1032 8
	/* Parse the CVSROOT/config file, but only for local.  For the
	   server, we parse it after we know $CVSROOT.  For the
	   client, it doesn't get parsed at all, obviously.  The
	   presence of the parse_config call here is not mean to
	   predetermine whether CVSROOT/config overrides things from
	   read_cvsrc and other such places or vice versa.  That sort
	   of thing probably needs more thought.  */
	if (1
d1034 2
a1035 1
	    && !server_active
d1037 2
a1038 11
#ifdef CLIENT_SUPPORT
	    && !client_active
#endif
	    )
	{
	    /* If there was an error parsing the config file, parse_config
	       already printed an error.  We keep going.  Why?  Because
	       if we didn't, then there would be no way to check in a new
	       CVSROOT/config file to fix the broken one!  */
	    parse_config (CVSroot_directory);
	}
a1040 13
    err = (*(cm->func)) (argc, argv);

    if (need_to_create_root)
    {
	/* Update the CVS/Root file.  We might want to do this in
	   all directories that we recurse into, but currently we
	   don't.  Note that if there is an error writing the file,
	   we give an error/warning.  This is so if users try to rewrite
	   CVS/Root with the -d option (a documented feature), they will
	   either succeed, or be told why it didn't work.  */
	Create_Root (NULL, CVSroot);
    }

d1044 2
d1110 37
@


1.31
log
@Integrate local changes
@
text
@d45 6
d292 4
d311 2
a312 1
    if ((strcmp (cmd_name, "checkout") != 0) &&
d314 1
@


1.30
log
@Integrate local changes
@
text
@d113 1
a113 1
    { "status",   "st",       "stat",      status },
a975 1
    struct tm *ftm;
a976 2
    char date[MAXDATELEN];
    char *ret;
d981 19
d1005 2
a1006 1
	   hack I added to get_date.  */
@


1.29
log
@Merge local changes to support a configuration file with Cyclic's scheme
@
text
@d531 1
a531 1
Copyright (c) 1989-1997 Brian Berliner, david d `zoo' zuhn, \n\
@


1.28
log
@Integrate local changes
@
text
@d450 2
a451 2
	readonlyfs = TRUE;
	logoff = TRUE;
a825 1
		parseopts(CVSroot_directory);
a1007 71
}

void
parseopts(root)
    const char *root;
{
    char path[PATH_MAX];
    int save_errno;
    char buf[1024];
    const char *p;
    char *q;
    FILE *fp;

    if (root == NULL) {
	printf("no CVSROOT in parseopts\n");
	return;
    }
    p = strchr (root, ':');
    if (p)
	p++;
    else
	p = root;
    if (p == NULL) {
	printf("mangled CVSROOT in parseopts\n");
	return;
    }
    (void) sprintf (path, "%s/%s/%s", p, CVSROOTADM, CVSROOTADM_OPTIONS);
    if ((fp = fopen(path, "r")) != NULL) {
	while (fgets(buf, sizeof buf, fp) != NULL) {
	    if (buf[0] == '#')
		continue;
	    q = strrchr(buf, '\n');
	    if (q)
		*q = '\0';

	    if (!strncmp(buf, "tag=", 4)) {
		char *what;

		RCS_citag = strdup(buf+4);
		if (RCS_citag == NULL) {
			printf("no memory for local tag\n");
			return;
		}
		what = malloc(sizeof("RCSLOCALID")+1+strlen(RCS_citag)+1);
		if (what == NULL) {
			printf("no memory for local tag\n");
			return;
		}
		sprintf(what, "RCSLOCALID=%s", RCS_citag);
		putenv(what);
	    } else if (!strncmp(buf, "umask=", 6)) {
		mode_t mode;

		cvsumask = (mode_t)(strtol(buf+6, NULL, 8) & 0777);
	    }
	    else if (!strncmp(buf, "dlimit=", 7)) {
#ifdef BSD
#include <sys/resource.h>
		struct rlimit rl;

		if (getrlimit(RLIMIT_DATA, &rl) != -1) {
			rl.rlim_cur = atoi(buf+7);
			rl.rlim_cur *= 1024;

			(void) setrlimit(RLIMIT_DATA, &rl);
		}
#endif /* BSD */
	    }
	}
	fclose(fp);
    }
@


1.27
log
@Integrate local changes
@
text
@d6 1
a6 1
 *    as specified in the README file that comes with the CVS 1.4 kit.
d36 2
a37 2
int use_editor = TRUE;
int use_cvsrc = TRUE;
d39 6
a44 6
int really_quiet = FALSE;
int quiet = FALSE;
int trace = FALSE;
int noexec = FALSE;
int readonlyfs = FALSE;
int logoff = FALSE;
a52 1
char *Rcsbin = RCSBIN_DFLT;
d128 22
a149 23
    "Usage: %s [cvs-options] command [command-options] [files...]\n",
    "    Where 'cvs-options' are:\n",
    "        -H           Displays Usage information for command\n",
    "        -Q           Cause CVS to be really quiet.\n",
    "        -q           Cause CVS to be somewhat quiet.\n",
    "        -r           Make checked-out files read-only\n",
    "        -w           Make checked-out files read-write (default)\n",
    "        -l           Turn History logging off\n",
    "        -n           Do not execute anything that will change the disk\n",
    "        -t           Show trace of program execution -- Try with -n\n",
    "        -v           CVS version and copyright\n",
    "        -b bindir    Find RCS programs in 'bindir'\n",
    "        -T tmpdir    Use 'tmpdir' for temporary files\n",
    "        -e editor    Use 'editor' for editing log information\n",
    "        -d CVS_root  Overrides $CVSROOT as the root of the CVS tree\n",
    "        -f           Do not use the ~/.cvsrc file\n",
#ifdef CLIENT_SUPPORT
    "        -z #         Use compression level '#' for net traffic.\n",
#ifdef ENCRYPTION
    "        -x           Encrypt all net traffic.\n",
#endif
#endif
    "        -s VAR=VAL   Set CVS user variable.\n",
d151 18
a168 2
    "    and where 'command' is: add, admin, etc. (use the --help-commands\n",
    "    option for a list of commands)\n",
d202 1
a202 1
    "(Use the --help-synonyms option for a list of alternate command names)\n",
d206 29
d241 2
a242 1
    int numcmds = 2;		/* two more for title and end */
d267 1
d378 1
a378 1
    int rcsbin_update_env, tmpdir_update_env, cvs_update_env;
a381 1
    int free_Rcsbin = 0;
d392 1
a429 6
    rcsbin_update_env = *Rcsbin;	/* RCSBIN_DFLT must be set */
    if ((cp = getenv (RCSBIN_ENV)) != NULL)
    {
	Rcsbin = cp;
	rcsbin_update_env = 0;		/* it's already there */
    }
d448 1
a448 1
	cvswrite = FALSE;
a452 8
    if ((cp = getenv (CVSUMASK_ENV)) != NULL)
    {
	/* FIXME: Should be accepting symbolic as well as numeric mask.  */
	cvsumask = strtol (cp, &end, 8) & 0777;
	if (*end != '\0')
	    error (1, errno, "invalid umask value in %s (%s)",
		CVSUMASK_ENV, cp);
    }
d469 1
a469 1
	    use_cvsrc = FALSE;
d482 1
a482 1
            (argc, argv, "+Qqrwtnlvb:T:e:d:Hfz:s:x", long_options, &option_index))
d495 4
d504 1
a504 1
		really_quiet = TRUE;
d507 1
a507 1
		quiet = TRUE;
d510 1
a510 1
		cvswrite = FALSE;
d513 1
a513 1
		cvswrite = TRUE;
d516 1
a516 1
		trace = TRUE;
d519 1
a519 1
		noexec = TRUE;
d521 1
a521 1
		logoff = TRUE;
d524 3
d530 3
a532 4
		(void) fputs ("Copyright (c) 1993-1994 Brian Berliner\n", stdout);
		(void) fputs ("Copyright (c) 1993-1994 david d `zoo' zuhn\n", stdout);
		(void) fputs ("Copyright (c) 1992, Brian Berliner and Jeff Polk\n", stdout);
		(void) fputs ("Copyright (c) 1989-1992, Brian Berliner\n", stdout);
d536 4
d543 5
a547 3
		Rcsbin = xstrdup (optarg);
		free_Rcsbin = 1;
		rcsbin_update_env = 1;	/* need to update environment */
d567 1
a567 1
		use_cvsrc = FALSE; /* unnecessary, since we've done it above */
d592 9
d631 3
d677 1
a677 1
#if defined(AUTH_SERVER_SUPPORT) && defined(SERVER_SUPPORT)
d694 1
a694 1
#endif /* AUTH_SERVER_SUPPORT && SERVER_SUPPORT */
d696 2
d703 1
a703 2
#ifdef SERVER_SUPPORT
	if (strcmp (command_name, "server") != 0)
d851 1
a851 1
	if (strcmp (command_name, "server") == 0)
a864 10
	/* Now, see if we should update the environment with the
           Rcsbin value */
	if (rcsbin_update_env)
	{
	    char *env;
	    env = xmalloc (strlen (RCSBIN_ENV) + strlen (Rcsbin) + 1 + 1);
	    (void) sprintf (env, "%s=%s", RCSBIN_ENV, Rcsbin);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
a874 18
	/*
	 * If Rcsbin is set to something, make sure it is terminated with
	 * a slash character.  If not, add one.
	 */
	if (*Rcsbin)
	{
	    int len = strlen (Rcsbin);
	    char *rcsbin;

	    if (Rcsbin[len - 1] != '/')
	    {
		rcsbin = Rcsbin;
		Rcsbin = xmalloc (len + 2);	/* one for '/', one for NULL */
		(void) strcpy (Rcsbin, rcsbin);
		(void) strcat (Rcsbin, "/");
	    }
	}

d912 22
d942 4
a945 1
	   don't.  */
a957 2
    if (free_Rcsbin)
	free (Rcsbin);
d969 2
d985 1
a985 1
#ifdef HAVE_RCS5
d987 6
a992 3
#else
    ftm = localtime (&unixtime);
#endif
@


1.26
log
@Allow a private tag when we expand RCS identifiers ourselves as well.
@
text
@d166 1
a166 1
    "        diff         Run diffs between revisions\n",
d334 5
d343 1
a343 1
      {
d348 1
d350 1
a350 1
      };
d423 3
a425 5
    /* I'm not sure whether this needs to be 1 instead of 0 anymore.  Using
       1 used to accomplish what passing "+" as the first character to
       the option string does, but that reason doesn't exist anymore.  */
    optind = 1;

d447 1
a447 1
    optind = 1;
d453 1
a453 1
      {
d455 1
a455 1
          {
d464 4
d502 2
a503 1
		Rcsbin = optarg;
d507 2
a508 1
		Tmpdir = optarg;
d512 2
a513 1
		Editor = optarg;
d516 2
a517 1
		CVSroot = optarg;
d625 6
d898 11
d915 3
a917 3
    if (err)
	return (EXIT_FAILURE);
    return 0;
@


1.25
log
@1 byte underflow
@
text
@d46 1
d960 12
a971 3
		char *RCS_citag = strdup(buf+4);
		char *what = malloc(sizeof("RCSLOCALID")+1+strlen(RCS_citag)+1);
		
@


1.24
log
@Integrate local changes
@
text
@d960 1
a960 1
		char *what = malloc(sizeof("RCSLOCALID")+1+strlen(RCS_citag));
@


1.23
log
@Integrate local changes
@
text
@d416 3
a418 5
    /* This has the effect of setting getopt's ordering to REQUIRE_ORDER,
       which is what we need to distinguish between global options and
       command options.  FIXME: It would appear to be possible to do this
       much less kludgily by passing "+" as the first character to the
       option string we pass to getopt_long.  */
d429 1
a429 1
            (argc, argv, "f", NULL, NULL))
d431 1
a431 1
      {
d434 2
a435 2
      }
    
d446 1
a446 1
            (argc, argv, "Qqrwtnlvb:T:e:d:Hfz:s:x", long_options, &option_index))
@


1.22
log
@Fix a const poisoning warning
@
text
@d27 3
a29 3
/*
 * Since some systems don't define this...
 */
d105 1
d175 1
d212 4
a215 1
	    *line = xmalloc(100); /* wild guess */
d229 2
a230 1
lookup_command_attribute (char *cmd_name)
d239 1
a239 1
    
d241 1
d243 1
d250 1
a250 1
        
d728 1
a728 1
		char path[PATH_MAX];
d731 4
d754 1
a776 1
	CurDir = xmalloc (PATH_MAX);
d779 1
a779 1
	    strcpy (CurDir, "<remote>");
d783 3
a785 2
            if (!getwd (CurDir))
		error (1, 0, "cannot get working directory: %s", CurDir);
d898 1
a898 1
    char date[256];			/* XXX bigger than we'll ever need? */
@


1.21
log
@Integrate local changes
@
text
@d921 2
a922 1
    char *p;
d943 3
a945 3
	    p = strrchr(buf, '\n');
	    if (p)
		*p = '\0';
@


1.20
log
@Properly make use of the CVSROOT/options umask specification and limit
it via bitwise and with 0777.
@
text
@a54 21
/*
 * The path found in CVS/Root must match $CVSROOT and/or 'cvs -d root'
 */
int add PROTO((int argc, char **argv));
int admin PROTO((int argc, char **argv));
int checkout PROTO((int argc, char **argv));
int commit PROTO((int argc, char **argv));
int diff PROTO((int argc, char **argv));
int history PROTO((int argc, char **argv));
int import PROTO((int argc, char **argv));
int cvslog PROTO((int argc, char **argv));
#ifdef AUTH_CLIENT_SUPPORT
int login PROTO((int argc, char **argv));
#endif /* AUTH_CLIENT_SUPPORT */
int patch PROTO((int argc, char **argv));
int release PROTO((int argc, char **argv));
int cvsremove PROTO((int argc, char **argv));
int rtag PROTO((int argc, char **argv));
int status PROTO((int argc, char **argv));
int tag PROTO((int argc, char **argv));
int update PROTO((int argc, char **argv));
d82 1
a82 1

d114 1
a114 1
    { "tag",      "ta",       "freeze",    tag },
d222 44
a312 10
static void
error_cleanup PROTO((void))
{
    Lock_Cleanup();
#ifdef SERVER_SUPPORT
    if (server_active)
	server_cleanup (0);
#endif
}

a340 2
    error_set_cleanup (error_cleanup);

d347 6
d636 4
a639 2
#if 0
	    if (lookup_command_attribute (command_name) & CVS_CMD_IGNORE_ADMROOT)
d641 2
a642 4
#else
	    if (strcmp (command_name, "import") != 0)
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
#endif
d671 3
a673 9
#if 0
		    if (lookup_command_attribute (command_name) & CVS_CMD_USES_WORK_DIR)
#else
		    if ((strcmp (command_name, "checkout") != 0) &&
			(strcmp (command_name, "login") != 0) &&
			(strcmp (command_name, "rdiff") != 0) &&
			(strcmp (command_name, "release") != 0) &&
			(strcmp (command_name, "rtag") != 0))
#endif
d675 2
d843 7
a849 22
#ifdef HAVE_SETVBUF
	/*
	 * Make stdout line buffered, so 'tail -f' can monitor progress.
	 * Patch creates too much output to monitor and it runs slowly.
	 */
#  ifndef KLUDGE_FOR_WNT_TESTSUITE

	if (strcmp (cm->fullname, "patch"))
#    ifdef BUFSIZ  /* traditional SysV chokes when size == 0 */
	    (void) setvbuf (stdout, (char *) NULL, _IOLBF, BUFSIZ);
#    else
	    (void) setvbuf (stdout, (char *) NULL, _IOLBF, 0);
#    endif

#  else /* KLUDGE_FOR_WNT_TESTSUITE */

	    (void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	    (void) setvbuf (stderr, (char *) NULL, _IONBF, 0);

#  endif /* KLUDGE_FOR_WNT_TESTSUITE */

#endif /* HAVE_SETVBUF */
d911 1
a911 1
    exit (EXIT_FAILURE);
@


1.19
log
@Restore missing call to parseopts() for non-client/server
@
text
@d957 1
a957 2
		mode = (mode_t)strtol(buf+6, NULL, 8);
		(void) umask(mode);
@


1.18
log
@Undo CVSroot change in main.c
Pass CVS root directory as an argument to parseopts()
Add prototype for parseopts()
@
text
@d728 1
@


1.17
log
@Make "CVSroot" available to parseopts()
@
text
@a48 2
static char *CVSroot = CVSROOT_DFLT;

d305 1
d915 3
a917 1
parseopts()
d925 1
a925 1
    if (CVSroot == NULL) {
d929 1
a929 1
    p = strchr (CVSroot, ':');
d933 1
a933 1
	p = CVSroot;
@


1.16
log
@Integrate local changes
@
text
@d49 2
a306 1
    char *CVSroot = CVSROOT_DFLT;
@


1.15
log
@Disable logging to CVSROOT/history if we are running on a read-only file
system
@
text
@a12 21
 * Usage:
 *	cvs [options] command [options] [files/modules...]
 *
 * Where "command" is composed of:
 *		admin		RCS command
 *		checkout	Check out a module/dir/file
 *		export		Like checkout, but used for exporting sources
 *		update		Brings work tree in sync with repository
 *		commit		Checks files into the repository
 *		diff		Runs diffs between revisions
 *		log		Prints "rlog" information for files
 *		login		Record user, host, repos, password
 *		add		Adds an entry to the repository
 *		remove		Removes an entry from the repository
 *		status		Status info on the revisions
 *		rdiff		"patch" format diff listing between releases
 *		tag		Add/delete a symbolic tag to the RCS file
 *		rtag		Add/delete a symbolic tag to the RCS file
 *		import		Import sources into CVS, using vendor branches
 *		release		Indicate that Module is no longer in use.
 *		history		Display history of Users and Modules.
a22 9
#if HAVE_KERBEROS
#include <sys/socket.h>
#include <netinet/in.h>
#include <krb.h>
#ifndef HAVE_KRB_GET_ERR_TEXT
#define krb_get_err_text(status) krb_err_txt[status]
#endif
#endif

d25 1
a25 5
/*
 * Initialize comamnd_name to "cvs" so that the first call to
 * read_cvsrc tries to find global cvs options.
 */
char *command_name = "";
a35 3
#ifdef AUTH_CLIENT_SUPPORT
int use_authenticating_server = FALSE;
#endif /* AUTH_CLIENT_SUPPORT */
d53 1
a54 1
char *CVSroot = CVSROOT_DFLT;
a57 2
char *CVSADM_Root = CVSROOT_DFLT;

d77 1
a77 1
const struct cmd
d80 24
a103 2
    char *nick1;		/* alternate name (e.g. "ci") */
    char *nick2;		/* another alternate names (e.g. "ci") */
a104 3
#ifdef CLIENT_SUPPORT
    int (*client_func) ();	/* Function to do it via the protocol.  */
#endif
d108 14
a121 4
#ifdef CLIENT_SUPPORT
#define CMD_ENTRY(n1, n2, n3, f1, f2) { n1, n2, n3, f1, f2 }
#else
#define CMD_ENTRY(n1, n2, n3, f1, f2) { n1, n2, n3, f1 }
d123 1
a123 14

    CMD_ENTRY("add",      "ad",    "new",     add,       client_add),
    CMD_ENTRY("admin",    "adm",   "rcs",     admin,     client_admin),
    CMD_ENTRY("annotate", NULL,    NULL,      annotate,  client_annotate),
    CMD_ENTRY("checkout", "co",    "get",     checkout,  client_checkout),
    CMD_ENTRY("commit",   "ci",    "com",     commit,    client_commit),
    CMD_ENTRY("diff",     "di",    "dif",     diff,      client_diff),
    CMD_ENTRY("edit",     "edit",  "edit",    edit,      client_edit),
    CMD_ENTRY("editors",  "editors","editors",editors,   client_editors),
    CMD_ENTRY("export",   "exp",   "ex",      checkout,  client_export),
    CMD_ENTRY("history",  "hi",    "his",     history,   client_history),
    CMD_ENTRY("import",   "im",    "imp",     import,    client_import),
    CMD_ENTRY("init",     NULL,    NULL,      init,      client_init),
    CMD_ENTRY("log",      "lo",    "rlog",    cvslog,    client_log),
d125 4
a128 1
    CMD_ENTRY("login",    "logon", "lgn",     login,     login),
d130 10
a139 10
    CMD_ENTRY("rdiff",    "patch", "pa",      patch,     client_rdiff),
    CMD_ENTRY("release",  "re",    "rel",     release,   client_release),
    CMD_ENTRY("remove",   "rm",    "delete",  cvsremove, client_remove),
    CMD_ENTRY("status",   "st",    "stat",    status,    client_status),
    CMD_ENTRY("rtag",     "rt",    "rfreeze", rtag,      client_rtag),
    CMD_ENTRY("tag",      "ta",    "freeze",  tag,       client_tag),
    CMD_ENTRY("unedit",   "unedit","unedit",  unedit,    client_unedit),
    CMD_ENTRY("update",   "up",    "upd",     update,    client_update),
    CMD_ENTRY("watch",    "watch", "watch",   watch,     client_watch),
    CMD_ENTRY("watchers", "watchers","watchers",watchers,client_watchers),
d141 1
a141 6
    /*
     * The client_func is also server because we might have picked up a
     * CVSROOT environment variable containing a colon.  The client will send
     * the real root later.
     */
    CMD_ENTRY("server",   "server", "server", server,    server),
d143 1
a143 3
    CMD_ENTRY(NULL, NULL, NULL, NULL, NULL),

#undef CMD_ENTRY
d160 1
d165 4
a168 1
    "        -z #         Use 'gzip -#' for net traffic if possible.\n",
d180 1
a180 1
    "        add          Adds a new file/directory to the repository\n",
d182 1
a182 1
    "        annotate     Show revision where each line was modified\n",
d184 2
a185 2
    "        commit       Checks files into the repository\n",
    "        diff         Runs diffs between revisions\n",
d188 2
a189 1
    "        history      Shows status of files and users\n",
d191 2
a192 2
    "        export       Export sources from CVS, similar to checkout\n",
    "        log          Prints out 'rlog' information for files\n",
d196 1
a196 1
    "        rdiff        'patch' format diffs between releases\n",
d198 4
a201 3
    "        remove       Removes an entry from the repository\n",
    "        status       Status info on the revisions\n",
    "        tag          Add a symbolic tag to checked out version of RCS file\n",
d203 1
a203 2
    "        rtag         Add a symbolic tag to the RCS file\n",
    "        update       Brings work tree in sync with repository\n",
d206 1
d210 33
d245 1
a245 1
     int sig;
d247 1
d249 1
d253 31
a283 15
	case SIGHUP:
	    name = "hangup";
	    break;
	case SIGINT:
	    name = "interrupt";
	    break;
	case SIGQUIT:
	    name = "quit";
	    break;
	case SIGPIPE:
	    name = "broken pipe";
	    break;
	case SIGTERM:
	    name = "termination";
	    break;
d286 2
a287 1
    error (EXIT_FAILURE, 0, "received %s signal", name);
d305 1
d311 4
a314 4
    static int help = FALSE;
    static int version_flag = FALSE;
    static int help_commands = FALSE;
    int rcsbin_update_env, cvs_update_env = 0;
d317 4
a320 3
        {"help", 0, &help, TRUE},
        {"version", 0, &version_flag, TRUE},
	{"help-commands", 0, &help_commands, TRUE},
d326 1
d330 5
a334 4
/* The socket subsystems on NT and OS2 must be initialized before use */
#ifdef INITIALIZE_SOCKET_SUBSYSTEM
        INITIALIZE_SOCKET_SUBSYSTEM();
#endif /* INITIALIZE_SOCKET_SUBSYSTEM */
d340 5
a345 5

    CurDir = xmalloc (PATH_MAX);
#ifndef SERVER_SUPPORT
    if (!getwd (CurDir))
	error (1, 0, "cannot get working directory: %s", CurDir);
d352 1
a353 1
    cvs_update_env = 0;
d359 6
d423 1
a423 1
            (argc, argv, "Qqrwtnlvb:e:d:Hfz:s:", long_options, &option_index))
d428 7
a434 2
            case 0:
                /* getopt_long took care of setting the flag. */ 
d457 11
a467 1
                version_flag = TRUE;
d473 4
d485 1
a485 2
		use_cvsrc = FALSE;      /* this ensure that cvs -H works */
		help = TRUE;
d488 1
a488 1
		use_cvsrc = FALSE;
d504 9
a518 17
    if (version_flag == TRUE)
    {
        (void) fputs (version_string, stdout);
        (void) fputs (config_string, stdout);
        (void) fputs ("\n", stdout);
        (void) fputs ("Copyright (c) 1993-1994 Brian Berliner\n", stdout);
        (void) fputs ("Copyright (c) 1993-1994 david d `zoo' zuhn\n", stdout);
        (void) fputs ("Copyright (c) 1992, Brian Berliner and Jeff Polk\n", stdout);
        (void) fputs ("Copyright (c) 1989-1992, Brian Berliner\n", stdout);
        (void) fputs ("\n", stdout);
        (void) fputs ("CVS may be copied only under the terms of the GNU General Public License,\n", stdout);
        (void) fputs ("a copy of which can be found with the CVS distribution kit.\n", stdout);
        exit (0);
    }
    else if (help_commands)
	usage (cmd_usage);

a523 29
#ifdef HAVE_KERBEROS
    /* If we are invoked with a single argument "kserver", then we are
       running as Kerberos server as root.  Do the authentication as
       the very first thing, to minimize the amount of time we are
       running as root.  */
    if (strcmp (argv[0], "kserver") == 0)
    {
	int status;
	char instance[INST_SZ];
	struct sockaddr_in peer;
	struct sockaddr_in laddr;
	int len;
	KTEXT_ST ticket;
	AUTH_DAT auth;
	char version[KRB_SENDAUTH_VLEN];
	Key_schedule sched;
	char user[ANAME_SZ];
	struct passwd *pw;

	strcpy (instance, "*");
	len = sizeof peer;
	if (getpeername (STDIN_FILENO, (struct sockaddr *) &peer, &len) < 0
	    || getsockname (STDIN_FILENO, (struct sockaddr *) &laddr,
			    &len) < 0)
	{
	    printf ("E Fatal error, aborting.\n\
error %s getpeername or getsockname failed\n", strerror (errno));
	    exit (EXIT_FAILURE);
	}
d525 30
a554 9
	status = krb_recvauth (KOPT_DO_MUTUAL, STDIN_FILENO, &ticket, "rcmd",
			       instance, &peer, &laddr, &auth, "", sched,
			       version);
	if (status != KSUCCESS)
	{
	    printf ("E Fatal error, aborting.\n\
error 0 kerberos: %s\n", krb_get_err_text(status));
	    exit (EXIT_FAILURE);
	}
d556 5
a560 8
	/* Get the local name.  */
	status = krb_kntoln (&auth, user);
	if (status != KSUCCESS)
	{
	    printf ("E Fatal error, aborting.\n\
error 0 kerberos: can't get local name: %s\n", krb_get_err_text(status));
	    exit (EXIT_FAILURE);
	}
d562 1
a562 2
	pw = getpwnam (user);
	if (pw == NULL)
d564 5
a568 3
	    printf ("E Fatal error, aborting.\n\
error 0 %s: no such user\n", user);
	    exit (EXIT_FAILURE);
d571 6
a576 10
	initgroups (pw->pw_name, pw->pw_gid);
	setgid (pw->pw_gid);
	setuid (pw->pw_uid);
	/* Inhibit access by randoms.  Don't want people randomly
	   changing our temporary tree before we check things in.  */
	umask (077);

#if HAVE_PUTENV
	/* Set LOGNAME and USER in the environment, in case they are
           already set to something else.  */
d578 1
a578 1
	    char *env;
d580 2
a581 7
	    env = xmalloc (sizeof "LOGNAME=" + strlen (user));
	    (void) sprintf (env, "LOGNAME=%s", user);
	    (void) putenv (env);

	    env = xmalloc (sizeof "USER=" + strlen (user));
	    (void) sprintf (env, "USER=%s", user);
	    (void) putenv (env);
a582 5
#endif

	/* Pretend we were invoked as a plain server.  */
	argv[0] = "server";
    }
d587 6
a592 6
    if (strcmp (argv[0], "pserver") == 0)
    {
      /* Gets username and password from client, authenticates, then
         switches to run as that user and sends an ACK back to the
         client. */
      authenticate_connection ();
d594 3
a596 3
      /* Pretend we were invoked as a plain server.  */
      argv[0] = "server";
    }
d600 3
a602 41
    /*
     * See if we are able to find a 'better' value for CVSroot in the
     * CVSADM_ROOT directory.
     */
#ifdef SERVER_SUPPORT
    if (strcmp (argv[0], "server") == 0 && CVSroot == NULL)
        CVSADM_Root = NULL;
    else
        CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
#else /* No SERVER_SUPPORT */
    CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
#endif /* No SERVER_SUPPORT */
    if (CVSADM_Root != NULL)
    {
        if (CVSroot == NULL || !cvs_update_env)
        {
	    CVSroot = CVSADM_Root;
	    cvs_update_env = 1;	/* need to update environment */
        }
#ifdef CLIENT_SUPPORT
        else if (!getenv ("CVS_IGNORE_REMOTE_ROOT"))
#else /* ! CLIENT_SUPPORT */
        else
#endif /* CLIENT_SUPPORT */
        {
            /*
	     * Now for the hard part, compare the two directories. If they
	     * are not identical, then abort this command.
	     */
            if ((fncmp (CVSroot, CVSADM_Root) != 0) &&
		!same_directories(CVSroot, CVSADM_Root))
	    {
              error (0, 0, "%s value for CVS Root found in %s",
                     CVSADM_Root, CVSADM_ROOT);
              error (0, 0, "does not match command line -d %s setting",
                     CVSroot);
              error (1, 0,
                      "you may wish to try the cvs command again without the -d option ");
	    }
        }
    }
a603 28
    /* CVSroot may need fixing up, if an access-method was specified,
     * but not a user.  Later code assumes that if CVSroot contains an
     * access-method, then it also has a user.  We print a warning and
     * die if we can't guarantee that.
     */
    if (CVSroot
        && *CVSroot
        && (CVSroot[0] == ':')
        && (strchr (CVSroot, '@@') == NULL))
      {
        error (1, 0,
               "must also give a username if specifying access method");
      }

    /*
     * Specifying just the '-H' flag to the sub-command causes a Usage
     * message to be displayed.
     */
    command_name = cp = argv[0];
    if (help == TRUE || (argc > 1 && strcmp (argv[1], "-H") == 0))
	argc = -1;
    else
    {
	/*
	 * Check to see if we can write into the history file.  If not,
	 * we assume that we can't work in the repository.
	 * BUT, only if the history file exists.
	 */
d605 1
a605 1
        if (strcmp (command_name, "server") != 0 || CVSroot != NULL)
d608 19
a626 8
	    char path[PATH_MAX];
	    int save_errno;

	    if (!CVSroot || !*CVSroot)
		error (1, 0, "You don't have a %s environment variable",
		       CVSROOT_ENV);
	    (void) sprintf (path, "%s/%s", CVSroot, CVSROOTADM);
	    if (!isaccessible (path, R_OK | X_OK))
d628 10
a637 3
		save_errno = errno;
		/* If this is "cvs init", the root need not exist yet.  */
		if (strcmp (command_name, "init") != 0
d639 1
a639 7
		    /* If we are a remote client, the root need not exist
		       on the client machine (FIXME: we should also skip
		       the check for CVSROOTADM_HISTORY being writable;
		       it shouldn't matter if there is a read-only file
		       which happens to have the same name on the client
		       machine).  */
		    && strchr (CVSroot, ':') == NULL)
d641 1
d643 21
a663 3
		error (0, 0,
		    "Sorry, you don't have sufficient access to %s", CVSroot);
		error (1, save_errno, "%s", path);
d666 6
a671 3
	    (void) strcat (path, "/");
	    (void) strcat (path, CVSROOTADM_HISTORY);
	    if (readonlyfs == 0 && isfile (path) && !isaccessible (path, R_OK | W_OK))
a672 1
		save_errno = errno;
d674 3
a676 2
		 "Sorry, you don't have read/write access to the history file");
		error (1, save_errno, "%s", path);
d678 31
a708 3
	    parseopts();
	}
    }
d710 19
a728 9
#ifdef SERVER_SUPPORT
    if (strcmp (command_name, "server") == 0)
	/* This is only used for writing into the history file.  Might
	   be nice to have hostname and/or remote path, on the other hand
	   I'm not sure whether it is worth the trouble.  */
	strcpy (CurDir, "<remote>");
    else if (!getwd (CurDir))
	error (1, 0, "cannot get working directory: %s", CurDir);
#endif
d731 1
a731 4
    /* Now, see if we should update the environment with the Rcsbin value */
    if (cvs_update_env)
    {
	char *env;
d733 16
a748 8
	env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot) + 1 + 1);
	(void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
	(void) putenv (env);
	/* do not free env, as putenv has control of it */
    }
    if (rcsbin_update_env)
    {
	char *env;
d750 5
a754 5
	env = xmalloc (strlen (RCSBIN_ENV) + strlen (Rcsbin) + 1 + 1);
	(void) sprintf (env, "%s=%s", RCSBIN_ENV, Rcsbin);
	(void) putenv (env);
	/* do not free env, as putenv has control of it */
    }
d756 4
d761 2
a762 8
    /*
     * If Rcsbin is set to something, make sure it is terminated with
     * a slash character.  If not, add one.
     */
    if (*Rcsbin)
    {
	int len = strlen (Rcsbin);
	char *rcsbin;
d764 4
a767 1
	if (Rcsbin[len - 1] != '/')
d769 5
a773 4
	    rcsbin = Rcsbin;
	    Rcsbin = xmalloc (len + 2);	/* one for '/', one for NULL */
	    (void) strcpy (Rcsbin, rcsbin);
	    (void) strcat (Rcsbin, "/");
d775 9
a783 1
    }
d785 8
a792 9
    for (cm = cmds; cm->fullname; cm++)
    {
	if (cm->nick1 && !strcmp (cp, cm->nick1))
	    break;
	if (cm->nick2 && !strcmp (cp, cm->nick2))
	    break;
	if (!strcmp (cp, cm->fullname))
	    break;
    }
d794 8
a801 5
    if (!cm->fullname)
	usage (usg);			/* no match */
    else
    {
	command_name = cm->fullname;	/* Global pointer for later use */
d803 1
d825 1
d834 2
d837 3
d841 10
a850 1
#endif
d853 3
a855 1
	  read_cvsrc (&argc, &argv, command_name);
d857 1
a857 11
#ifdef CLIENT_SUPPORT
	/* If cvsroot contains a colon, try to do it via the protocol.  */
        {
	    char *p = CVSroot == NULL ? NULL : strchr (CVSroot, ':');
	    if (p)
		err = (*(cm->client_func)) (argc, argv);
	    else
		err = (*(cm->func)) (argc, argv);
	}
#else /* No CLIENT_SUPPORT */
	err = (*(cm->func)) (argc, argv);
d859 6
a864 1
#endif /* No CLIENT_SUPPORT */
d866 1
d868 7
@


1.14
log
@for RCSLOCALID thing, use malloc/putenv instead of setenv
@
text
@d337 1
a337 1
    if (getenv (CVSREADONLYFS_ENV))
d339 2
@


1.13
log
@fix a comment of mine
@
text
@d874 4
a877 1
		setenv("RCSLOCALID", RCS_citag, 1);
@


1.12
log
@s/__OpenBSD__/BSD/
@
text
@d892 1
a892 1
#endif /* __OpenBSD__ */
@


1.11
log
@more careful umask handling, but does it fix the bug i have seen?
@
text
@d882 1
a882 1
#ifdef __OpenBSD__
@


1.10
log
@retain -Z options to rcs commands even though they do not work (rcs
commands spawn children which do not inherit the -Z option...) but also
look in the RCSLOCALID environment variable. cvs sets this to "OpenBSD",
as read from the options file.
@
text
@d876 1
a876 1
		int mode;
d878 2
a879 2
		mode = strtol(buf+6, NULL, 8);
		umask((mode_t)mode);
@


1.9
log
@parseopts() may be called with CVSROOT still in client form
@
text
@d873 2
a874 1
		RCS_citag = strdup(buf+4);
@


1.8
log
@new extension: the $CVSROOT/CVSROOT/options file (if it exists) supports:
    tag=-ZOpenBSD (passes -ZOpenBSD to co/ci)
    umask=002 (force a umask while cvs is running)
    dlimit=49152 (force a 48MB process data limit)
@
text
@d850 14
a863 1
    (void) sprintf (path, "%s/%s/%s", CVSroot, CVSROOTADM, CVSROOTADM_OPTIONS);
@


1.7
log
@Integrate local changes to CVS; remove files no longer part of the CVS
distribution
@
text
@d681 1
d840 43
@


1.6
log
@report signal type before dying; from ian@@cygnus.com forwarded by niklas
@
text
@d38 6
d59 1
a59 1
char *command_name = "cvs";
d136 1
d145 1
d205 1
d256 1
a256 1
    error (1, 0, "received %s signal", name);
d374 1
a374 1
	read_cvsrc(&argc, &argv);
d498 1
a498 1
	    exit (1);
d508 1
a508 1
	    exit (1);
d517 1
a517 1
	    exit (1);
d525 1
a525 1
	    exit (1);
d655 2
d658 8
a665 1
		if (strchr (CVSroot, ':') == NULL)
a666 1
#endif
a669 1
#ifdef CLIENT_SUPPORT
a670 1
#endif
d784 1
a784 1
	  read_cvsrc(&argc, &argv);
a799 6
    /*
     * If the command's error count is modulo 256, we need to change it
     * so that we don't overflow the 8-bits we get to report exit status
     */
    if (err && (err % 256) == 0)
	err = 1;
d801 3
a803 1
    return (err);
d838 1
a838 1
    exit (1);
@


1.5
log
@Integrate local changes to CVS
@
text
@d223 2
a224 1
main_cleanup ()
d226 22
a247 1
    exit (1);
@


1.4
log
@Integrate local changes
@
text
@a46 5
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)main.c 1.78 94/10/07 $\n";
USE(rcsid);
#endif

a85 1
#ifdef CVSADM_ROOT
a89 1
#endif /* CVSADM_ROOT */
d185 1
a316 5
    /*
     * Scan cvsrc file for global options.
     */
    read_cvsrc(&argc, &argv);

d324 24
d349 1
a349 1
            (argc, argv, "Qqrwtnlvb:e:d:Hfz:", long_options, &option_index))
d398 1
a399 1
	    case 'z':
d404 7
a411 1
#endif
a539 1
#ifdef CVSADM_ROOT
a580 1
#endif /* CVSADM_ROOT */
@


1.3
log
@if CVSREADONLYFS, access to the history file is irrelevant
@
text
@d24 1
a36 1
#include "patchlevel.h"
d53 6
a58 1
char *command_name = "";
d69 3
d81 1
d106 3
a135 1
#ifndef CVS_NOADMIN
a136 1
#endif
d140 2
d146 3
d155 1
d157 2
a158 1

d193 8
a200 1
    "    and where 'command' is:\n",
d206 2
d212 3
d220 1
d223 2
d235 1
a235 1
error_cleanup ()
a243 2
#define KF_GETOPT_LONG 1

d251 1
a251 1
    char *cp;
d254 3
a256 1
    static int help = FALSE, version_flag = FALSE;
a257 1
    char tmp[PATH_MAX];
d262 1
d271 5
d279 1
d314 13
d395 1
a395 1
		usage (usg);
d400 1
a400 1
      {
a402 2
        (void) sprintf (tmp, "Patch Level: %d\n", PATCHLEVEL);
        (void) fputs (tmp, stdout);
d412 3
a414 1
      }
d506 15
d543 1
a543 1
#else
d545 1
a545 1
#endif
d565 14
d604 1
a604 1
	    if (access (path, R_OK | X_OK))
d620 1
a620 1
	    if (readonlyfs == 0 && isfile (path) && access (path, R_OK | W_OK))
@


1.2
log
@CVSREADONLYFS environment variable short-circuits read-only lock requirements
@
text
@d540 1
a540 1
	    if (isfile (path) && access (path, R_OK | W_OK))
@


1.1
log
@Initial revision
@
text
@d71 1
d274 2
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a23 1
 *		login		Record user, host, repos, password
d36 1
d53 1
a53 6
char *program_path;
/*
 * Initialize comamnd_name to "cvs" so that the first call to
 * read_cvsrc tries to find global cvs options.
 */
char *command_name = "cvs";
a63 3
#ifdef AUTH_CLIENT_SUPPORT
int use_authenticating_server = FALSE;
#endif /* AUTH_CLIENT_SUPPORT */
a71 1
mode_t cvsumask = UMASK_DFLT;
a95 3
#ifdef AUTH_CLIENT_SUPPORT
int login PROTO((int argc, char **argv));
#endif /* AUTH_CLIENT_SUPPORT */
d123 1
d125 1
a128 2
    CMD_ENTRY("edit",     "edit",  "edit",    edit,      client_edit),
    CMD_ENTRY("editors",  "editors","editors",editors,   client_editors),
a132 3
#ifdef AUTH_CLIENT_SUPPORT
    CMD_ENTRY("login",    "logon", "lgn",     login,     login),
#endif /* AUTH_CLIENT_SUPPORT */
a138 1
    CMD_ENTRY("unedit",   "unedit","unedit",  unedit,    client_unedit),
d140 1
a140 2
    CMD_ENTRY("watch",    "watch", "watch",   watch,     client_watch),
    CMD_ENTRY("watchers", "watchers","watchers",watchers,client_watchers),
d175 1
a175 8
    "    and where 'command' is: add, admin, etc. (use the --help-commands\n",
    "    option for a list of commands)\n",
    NULL,
};

static const char *const cmd_usage[] =
{
    "CVS commands are:\n",
a180 2
    "        edit         Get ready to edit a watched file\n",
    "        editors      See who is editing a watched file\n",
a184 3
#ifdef AUTH_CLIENT_SUPPORT
    "        login        Prompt for password for authenticating server.\n",
#endif /* AUTH_CLIENT_SUPPORT */
a189 1
    "        unedit       Undo an edit command\n",
a191 2
    "        watch        Set watches\n",
    "        watchers     See who is watching a file\n",
d202 1
a202 1
error_cleanup PROTO((void))
d211 2
d220 1
a220 1
    char *cp, *end;
d223 1
a223 3
    static int help = FALSE;
    static int version_flag = FALSE;
    static int help_commands = FALSE;
d225 1
a229 1
	{"help-commands", 0, &help_commands, TRUE},
a237 5
/* The socket subsystems on NT and OS2 must be initialized before use */
#ifdef INITIALIZE_SOCKET_SUBSYSTEM
        INITIALIZE_SOCKET_SUBSYSTEM();
#endif /* INITIALIZE_SOCKET_SUBSYSTEM */

a240 1
    program_path = xstrdup (argv[0]);
a272 13
    if ((cp = getenv (CVSUMASK_ENV)) != NULL)
    {
	/* FIXME: Should be accepting symbolic as well as numeric mask.  */
	cvsumask = strtol (cp, &end, 8) & 0777;
	if (*end != '\0')
	    error (1, errno, "invalid umask value in %s (%s)",
		CVSUMASK_ENV, cp);
    }

    /*
     * Scan cvsrc file for global options.
     */
    read_cvsrc(&argc, &argv);
d341 1
a341 1
                usage (usg);
d346 1
a346 1
    {
d349 2
d360 1
a360 3
    }
    else if (help_commands)
	usage (cmd_usage);
a451 15

#if defined(AUTH_SERVER_SUPPORT) && defined(SERVER_SUPPORT)
    if (strcmp (argv[0], "pserver") == 0)
    {
      /* Gets username and password from client, authenticates, then
         switches to run as that user and sends an ACK back to the
         client. */
      authenticate_connection ();
      
      /* Pretend we were invoked as a plain server.  */
      argv[0] = "server";
    }
#endif /* AUTH_SERVER_SUPPORT && SERVER_SUPPORT */


d474 1
a474 1
#else /* ! CLIENT_SUPPORT */
d476 1
a476 1
#endif /* CLIENT_SUPPORT */
a495 14
    /* CVSroot may need fixing up, if an access-method was specified,
     * but not a user.  Later code assumes that if CVSroot contains an
     * access-method, then it also has a user.  We print a warning and
     * die if we can't guarantee that.
     */
    if (CVSroot
        && *CVSroot
        && (CVSroot[0] == ':')
        && (strchr (CVSroot, '@@') == NULL))
      {
        error (1, 0,
               "must also give a username if specifying access method");
      }

d521 1
a521 1
	    if (!isaccessible (path, R_OK | X_OK))
d537 1
a537 1
	    if (isfile (path) && !isaccessible (path, R_OK | W_OK))
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d47 5
d90 1
d95 1
a190 1
    "        -s VAR=VAL   Set CVS user variable.\n",
d320 5
a331 24

    /* We have to parse the options twice because else there is no
       chance to avoid reading the global options from ".cvsrc".  Set
       opterr to 0 for avoiding error messages about invalid options.
       */
    opterr = 0;

    while ((c = getopt_long
            (argc, argv, "f", NULL, NULL))
           != EOF)
      {
	if (c == 'f')
	    use_cvsrc = FALSE;
      }
    
    /*
     * Scan cvsrc file for global options.
     */
    if (use_cvsrc)
	read_cvsrc(&argc, &argv);

    optind = 1;
    opterr = 1;

d333 1
a333 1
            (argc, argv, "Qqrwtnlvb:e:d:Hfz:s:", long_options, &option_index))
d382 1
a383 1
#ifdef CLIENT_SUPPORT
d388 1
a389 7
		/* If no CLIENT_SUPPORT, we just silently ignore the gzip
		   level, so that users can have it in their .cvsrc and not
		   cause any trouble.  */
		break;
	    case 's':
		variable_set (optarg);
		break;
d518 1
d560 1
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@a37 6
#ifdef HAVE_WINSOCK_H
#include <winsock.h>
#else
extern int gethostname ();
#endif

d53 1
a53 1
char *command_name = "";
a128 1
    CMD_ENTRY("annotate", NULL,    NULL,      annotate,  client_annotate),
a136 1
    CMD_ENTRY("init",     NULL,    NULL,      init,      client_init),
a195 1
    "        annotate     Show revision where each line was modified\n",
d224 1
a224 1
    exit (EXIT_FAILURE);
d340 1
a340 1
	read_cvsrc (&argc, &argv, "cvs");
d464 1
a464 1
	    exit (EXIT_FAILURE);
d474 1
a474 1
	    exit (EXIT_FAILURE);
d483 1
a483 1
	    exit (EXIT_FAILURE);
d491 1
a491 1
	    exit (EXIT_FAILURE);
a620 2
		/* If this is "cvs init", the root need not exist yet.  */
		if (strcmp (command_name, "init") != 0
d622 2
a623 7
		    /* If we are a remote client, the root need not exist
		       on the client machine (FIXME: we should also skip
		       the check for CVSROOTADM_HISTORY being writable;
		       it shouldn't matter if there is a read-only file
		       which happens to have the same name on the client
		       machine).  */
		    && strchr (CVSroot, ':') == NULL)
a624 1
		{
d628 1
d630 1
d744 1
a744 1
	  read_cvsrc (&argc, &argv, command_name);
d760 6
d767 1
a767 3
    if (err)
	return (EXIT_FAILURE);
    return 0;
d802 1
a802 1
    exit (EXIT_FAILURE);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d13 21
d44 9
d55 5
a59 1
char *command_name;
d70 3
a88 1
char *Tmpdir = TMPDIR_DFLT;
d90 1
d94 2
d115 1
a115 1
static const struct cmd
d118 2
a119 24

    /* Synonyms for the command, nick1 and nick2.  We supply them
       mostly for two reasons: (1) CVS has always supported them, and
       we need to maintain compatibility, (2) if there is a need for a
       version which is shorter than the fullname, for ease in typing.
       Synonyms have the disadvantage that people will see "new" and
       then have to think about it, or look it up, to realize that is
       the operation they know as "add".  Also, this means that one
       cannot create a command "cvs new" with a different meaning.  So
       new synonyms are probably best used sparingly, and where used
       should be abbreviations of the fullname (preferably consisting
       of the first 2 or 3 or so letters).

       One thing that some systems do is to recognize any unique
       abbreviation, for example "annotat" "annota", etc., for
       "annotate".  The problem with this is that scripts and user
       habits will expect a certain abbreviation to be unique, and in
       a future release of CVS it may not be.  So it is better to
       accept only an explicit list of abbreviations and plan on
       supporting them in the future as well as now.  */

    char *nick1;
    char *nick2;

d121 3
d127 4
a130 14
    { "add",      "ad",       "new",       add },
    { "admin",    "adm",      "rcs",       admin },
    { "annotate", "ann",      NULL,        annotate },
    { "checkout", "co",       "get",       checkout },
    { "commit",   "ci",       "com",       commit },
    { "diff",     "di",       "dif",       diff },
    { "edit",     NULL,	      NULL,	   edit },
    { "editors",  NULL,       NULL,	   editors },
    { "export",   "exp",      "ex",        checkout },
    { "history",  "hi",       "his",       history },
    { "import",   "im",       "imp",       import },
    { "init",     NULL,       NULL,        init },
#ifdef SERVER_SUPPORT
    { "kserver",  NULL,       NULL,        server }, /* placeholder */
d132 14
a145 1
    { "log",      "lo",       "rlog",      cvslog },
d147 1
a147 4
    { "login",    "logon",    "lgn",       login },
#ifdef SERVER_SUPPORT
    { "pserver",  NULL,       NULL,        server }, /* placeholder */
#endif
d149 10
a158 10
    { "rdiff",    "patch",    "pa",        patch },
    { "release",  "re",       "rel",       release },
    { "remove",   "rm",       "delete",    cvsremove },
    { "status",   "st",       "stat",      status },
    { "rtag",     "rt",       "rfreeze",   rtag },
    { "tag",      "ta",       "freeze",    tag },
    { "unedit",   NULL,	      NULL,	   unedit },
    { "update",   "up",       "upd",       update },
    { "watch",    NULL,	      NULL,	   watch },
    { "watchers", NULL,	      NULL,	   watchers },
d160 6
a165 1
    { "server",   NULL,       NULL,        server },
d167 3
a169 1
    { NULL, NULL, NULL, NULL },
a185 1
    "        -T tmpdir    Use 'tmpdir' for temporary files\n",
d190 1
a190 4
    "        -z #         Use compression level '#' for net traffic.\n",
#ifdef ENCRYPTION
    "        -x           Encrypt all net traffic.\n",
#endif
d202 1
a202 1
    "        add          Add a new file/directory to the repository\n",
d204 1
a204 1
    "        annotate     Show last revision where each line was modified\n",
d206 2
a207 2
    "        commit       Check files into the repository\n",
    "        diff         Run diffs between revisions\n",
d210 2
d213 1
a213 4
    "        history      Show repository access history\n",
    "        import       Import sources into CVS, using vendor branches\n",
    "        init         Create a CVS repository if it doesn't exist\n",
    "        log          Print out history information for files\n",
d217 1
a217 1
    "        rdiff        Create 'patch' format diffs between releases\n",
d219 3
a221 4
    "        remove       Remove an entry from the repository\n",
    "        rtag         Add a symbolic tag to a module\n",
    "        status       Display status information on checked out files\n",
    "        tag          Add a symbolic tag to checked out version of files\n",
d223 2
a224 1
    "        update       Bring work tree in sync with repository\n",
a226 1
    "(Use the --help-synonyms option for a list of alternate command names)\n",
a229 33
static const char * const*
cmd_synonyms ()
{
    char ** synonyms;
    char ** line;
    const struct cmd *c = &cmds[0];
    int numcmds = 2;		/* two more for title and end */

    while (c->fullname != NULL)
    {
	numcmds++;
	c++;
    }
    
    synonyms = (char **) xmalloc(numcmds * sizeof(char *));
    line = synonyms;
    *line++ = "CVS command synonyms are:\n";
    for (c = &cmds[0]; c->fullname != NULL; c++)
    {
	if (c->nick1 || c->nick2)
	{
	    *line = xmalloc(100); /* wild guess */
	    sprintf(*line, "        %-12s %s %s\n", c->fullname,
		    c->nick1 ? c->nick1 : "",
		    c->nick2 ? c->nick2 : "");
	    line++;
	}
    }
    *line = NULL;
    
    return (const char * const*) synonyms; /* will never be freed */
}

d231 1
a231 2
main_cleanup (sig)
    int sig;
d233 1
a233 41
#ifndef DONT_USE_SIGNALS
    const char *name;
    char temp[10];

    switch (sig)
    {
#ifdef SIGHUP
    case SIGHUP:
	name = "hangup";
	break;
#endif
#ifdef SIGINT
    case SIGINT:
	name = "interrupt";
	break;
#endif
#ifdef SIGQUIT
    case SIGQUIT:
	name = "quit";
	break;
#endif
#ifdef SIGPIPE
    case SIGPIPE:
	name = "broken pipe";
	break;
#endif
#ifdef SIGTERM
    case SIGTERM:
	name = "termination";
	break;
#endif
    default:
	/* This case should never be reached, because we list above all
	   the signals for which we actually establish a signal handler.  */
	sprintf (temp, "%d", sig);
	name = temp;
	break;
    }

    error (1, 0, "received %s signal", name);
#endif /* !DONT_USE_SIGNALS */
a250 1
    char *CVSroot = CVSROOT_DFLT;
d256 4
a259 4
    int rcsbin_update_env, tmpdir_update_env, cvs_update_env;
    int help = 0;		/* Has the user asked for help?  This
				   lets us support the `cvs -H cmd'
				   convention to give help for cmd. */
d262 3
a264 4
        {"help", 0, NULL, 'H'},
        {"version", 0, NULL, 'v'},
	{"help-commands", 0, NULL, 1},
	{"help-synonyms", 0, NULL, 2},
a269 1
    int need_to_create_root = 0;
d273 4
a276 5
#ifdef SYSTEM_INITIALIZE
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_INITIALIZE (&argc, &argv);
#endif
a281 5
#ifdef ARGV0_NOT_PROGRAM_NAME
    /* On some systems, e.g. VMS, argv[0] is not the name of the command
       which the user types to invoke the program.  */
    program_name = "cvs";
#else
d283 5
d294 1
a295 1
    rcsbin_update_env = *Rcsbin;	/* RCSBIN_DFLT must be set */
a300 6
    tmpdir_update_env = *Tmpdir;	/* TMPDIR_DFLT must be set */
    if ((cp = getenv (TMPDIR_ENV)) != NULL)
    {
	Tmpdir = cp;
	tmpdir_update_env = 0;		/* it's already there */
    }
d314 8
d355 1
a355 1
            (argc, argv, "Qqrwtnlvb:T:e:d:Hfz:s:x", long_options, &option_index))
d360 2
a361 7
            case 1:
	        /* --help-commands */
                usage (cmd_usage);
                break;
            case 2:
	        /* --help-synonyms */
                usage (cmd_synonyms());
d384 1
a384 11
		(void) fputs (version_string, stdout);
		(void) fputs (config_string, stdout);
		(void) fputs ("\n", stdout);
		(void) fputs ("Copyright (c) 1993-1994 Brian Berliner\n", stdout);
		(void) fputs ("Copyright (c) 1993-1994 david d `zoo' zuhn\n", stdout);
		(void) fputs ("Copyright (c) 1992, Brian Berliner and Jeff Polk\n", stdout);
		(void) fputs ("Copyright (c) 1989-1992, Brian Berliner\n", stdout);
		(void) fputs ("\n", stdout);
		(void) fputs ("CVS may be copied only under the terms of the GNU General Public License,\n", stdout);
		(void) fputs ("a copy of which can be found with the CVS distribution kit.\n", stdout);
		exit (0);
a389 4
	    case 'T':
		Tmpdir = optarg;
		tmpdir_update_env = 1;	/* need to update environment */
		break;
d398 2
a399 1
	        help = 1;
d402 1
a402 1
		use_cvsrc = FALSE; /* unnecessary, since we've done it above */
a417 9
	    case 'x':
#ifdef CLIENT_SUPPORT
	        cvsencrypt = 1;
#endif /* CLIENT_SUPPORT */
		/* If no CLIENT_SUPPORT, ignore -x, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   If no ENCRYPTION, we still accept -x, but issue an
                   error if we are being run as a client.  */
		break;
d424 17
d446 6
a451 5

    /* Look up the command name. */

    command_name = argv[0];
    for (cm = cmds; cm->fullname; cm++)
d453 22
a474 7
	if (cm->nick1 && !strcmp (command_name, cm->nick1))
	    break;
	if (cm->nick2 && !strcmp (command_name, cm->nick2))
	    break;
	if (!strcmp (command_name, cm->fullname))
	    break;
    }
d476 9
a484 4
    if (!cm->fullname)
	usage (cmd_usage);	        /* no match */
    else
	command_name = cm->fullname;	/* Global pointer for later use */
d486 8
a493 5
    if (strcmp (argv[0], "rlog") == 0)
    {
	error (0, 0, "warning: the rlog command is deprecated");
	error (0, 0, "use the synonymous log command instead");
    }
d495 2
a496 14
    if (help)
	argc = -1;		/* some functions only check for this */
    else
    {
	/* The user didn't ask for help, so go ahead and authenticate,
           set up CVSROOT, and the rest of it. */

	/* The UMASK environment variable isn't handled with the
	   others above, since we don't want to signal errors if the
	   user has asked for help.  This won't work if somebody adds
	   a command-line flag to set the umask, since we'll have to
	   parse it before we get here. */

	if ((cp = getenv (CVSUMASK_ENV)) != NULL)
d498 3
a500 5
	    /* FIXME: Should be accepting symbolic as well as numeric mask.  */
	    cvsumask = strtol (cp, &end, 8) & 0777;
	    if (*end != '\0')
		error (1, errno, "invalid umask value in %s (%s)",
		       CVSUMASK_ENV, cp);
d503 10
a512 6
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
	/* If we are invoked with a single argument "kserver", then we are
	   running as Kerberos server as root.  Do the authentication as
	   the very first thing, to minimize the amount of time we are
	   running as root.  */
	if (strcmp (command_name, "kserver") == 0)
d514 1
a514 1
	    kserver_authenticate_connection ();
d516 7
a522 2
	    /* Pretend we were invoked as a plain server.  */
	    command_name = "server";
d524 5
d533 6
a538 6
	if (strcmp (command_name, "pserver") == 0)
	{
	    /* Gets username and password from client, authenticates, then
	       switches to run as that user and sends an ACK back to the
	       client. */
	    pserver_authenticate_connection ();
d540 3
a542 3
	    /* Pretend we were invoked as a plain server.  */
	    command_name = "server";
	}
d546 55
a600 3
	/* Fiddling with CVSROOT doesn't make sense if we're running
           in server mode, since the client will send the repository
           directory after the connection is made. */
d602 14
d617 1
a617 1
	if (strcmp (command_name, "server") != 0)
d620 8
a627 19
	    char *CVSADM_Root;
	    
	    /* See if we are able to find a 'better' value for CVSroot
	       in the CVSADM_ROOT directory. */

	    CVSADM_Root = NULL;

	    /* "cvs import" shouldn't check CVS/Root; in general it
	       ignores CVS directories and CVS/Root is likely to
	       specify a different repository than the one we are
	       importing to.  */
#if 0
	    if (lookup_command_attribute (command_name) & CVS_CMD_IGNORE_ADMROOT)
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
#else
	    if (strcmp (command_name, "import") != 0)
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
#endif
	    if (CVSADM_Root != NULL)
d629 3
a631 10
		if (CVSroot == NULL || !cvs_update_env)
		{
		    CVSroot = CVSADM_Root;
		    cvs_update_env = 1;	/* need to update environment */
		}
		/* Let -d override CVS/Root file.  The user might want
		   to change the access method, use a different server
		   (if there are two server machines which share the
		   repository using a networked file system), etc.  */
		else if (
d633 7
a639 1
		         !getenv ("CVS_IGNORE_REMOTE_ROOT") &&
a640 1
			 strcmp (CVSroot, CVSADM_Root) != 0)
d642 3
a644 21
		    /* Once we have verified that this root is usable,
		       we will want to write it into CVS/Root.

		       Don't do it for the "login" command, however.
		       Consider: if the user executes "cvs login" with
		       the working directory inside an already checked
		       out module, we'd incorrectly change the
		       CVS/Root file to reflect the CVSROOT of the
		       "cvs login" command.  Ahh, the things one
		       discovers. */

#if 0
		    if (lookup_command_attribute (command_name) & CVS_CMD_USES_WORK_DIR)
#else
		    if ((strcmp (command_name, "checkout") != 0) &&
			(strcmp (command_name, "login") != 0) &&
			(strcmp (command_name, "rdiff") != 0) &&
			(strcmp (command_name, "release") != 0) &&
			(strcmp (command_name, "rtag") != 0))
#endif
			need_to_create_root = 1;
d647 3
a649 6

	    /* Now we've reconciled CVSROOT from the command line, the
               CVS/Root file, and the environment variable.  Do the
               last sanity checks on the variable. */

	    if (! CVSroot)
d651 1
d653 2
a654 16
		       "No CVSROOT specified!  Please use the `-d' option");
		error (1, 0,
		       "or set the %s environment variable.", CVSROOT_ENV);
	    }
	    
	    if (! *CVSroot)
	    {
		error (0, 0,
		       "CVSROOT is set but empty!  Make sure that the");
		error (0, 0,
		       "specification of CVSROOT is legal, either via the");
		error (0, 0,
		       "`-d' option, the %s environment variable, or the",
		       CVSROOT_ENV);
		error (1, 0,
		       "CVS/Root file (if any).");
d656 2
d659 9
a667 37
	    /* Now we're 100% sure that we have a valid CVSROOT
	       variable.  Parse it to see if we're supposed to do
	       remote accesses or use a special access method. */

	    if (parse_cvsroot (CVSroot))
		error (1, 0, "Bad CVSROOT.");

	    /*
	     * Check to see if we can write into the history file.  If not,
	     * we assume that we can't work in the repository.
	     * BUT, only if the history file exists.
	     */

	    if (!client_active)
	    {
		char path[PATH_MAX];
		int save_errno;

		(void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
		if (!isaccessible (path, R_OK | X_OK))
		{
		    save_errno = errno;
		    /* If this is "cvs init", the root need not exist yet.  */
		    if (strcmp (command_name, "init") != 0)
		    {
			error (1, save_errno, "%s", path);
		    }
		}
		(void) strcat (path, "/");
		(void) strcat (path, CVSROOTADM_HISTORY);
		if (isfile (path) && !isaccessible (path, R_OK | W_OK))
		{
		    save_errno = errno;
		    error (0, 0, "Sorry, you don't have read/write access to the history file");
		    error (1, save_errno, "%s", path);
		}
	    }
d670 4
a673 1
	    /* Update the CVSROOT environment variable if necessary. */
d675 8
a682 16
	    if (cvs_update_env)
	    {
		char *env;
		env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot)
			       + 1 + 1);
		(void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
		(void) putenv (env);
		/* do not free env, as putenv has control of it */
	    }
#endif
	}
	
	/* This is only used for writing into the history file.  For
	   remote connections, it might be nice to have hostname
	   and/or remote path, on the other hand I'm not sure whether
	   it is worth the trouble.  */
d684 5
a688 5
	CurDir = xmalloc (PATH_MAX);
#ifdef SERVER_SUPPORT
	if (strcmp (command_name, "server") == 0)
	    strcpy (CurDir, "<remote>");
	else
a689 4
	{
            if (!getwd (CurDir))
		error (1, 0, "cannot get working directory: %s", CurDir);
	}
d691 8
a698 2
	if (Tmpdir == NULL || Tmpdir[0] == '\0')
	    Tmpdir = "/tmp";
d700 1
a700 4
#ifdef HAVE_PUTENV
	/* Now, see if we should update the environment with the
           Rcsbin value */
	if (rcsbin_update_env)
d702 4
a705 5
	    char *env;
	    env = xmalloc (strlen (RCSBIN_ENV) + strlen (Rcsbin) + 1 + 1);
	    (void) sprintf (env, "%s=%s", RCSBIN_ENV, Rcsbin);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
d707 1
a707 9
	if (tmpdir_update_env)
	{
	    char *env;
	    env = xmalloc (strlen (TMPDIR_ENV) + strlen (Tmpdir) + 1 + 1);
	    (void) sprintf (env, "%s=%s", TMPDIR_ENV, Tmpdir);
	    (void) putenv (env);
	    /* do not free env, as putenv has control of it */
	}
#endif
d709 9
a717 8
	/*
	 * If Rcsbin is set to something, make sure it is terminated with
	 * a slash character.  If not, add one.
	 */
	if (*Rcsbin)
	{
	    int len = strlen (Rcsbin);
	    char *rcsbin;
d719 5
a723 8
	    if (Rcsbin[len - 1] != '/')
	    {
		rcsbin = Rcsbin;
		Rcsbin = xmalloc (len + 2);	/* one for '/', one for NULL */
		(void) strcpy (Rcsbin, rcsbin);
		(void) strcat (Rcsbin, "/");
	    }
	}
a724 1
#ifndef DONT_USE_SIGNALS
a745 1
#endif /* !DONT_USE_SIGNALS */
a753 2
#  ifndef KLUDGE_FOR_WNT_TESTSUITE

a754 3
#    ifdef BUFSIZ  /* traditional SysV chokes when size == 0 */
	    (void) setvbuf (stdout, (char *) NULL, _IOLBF, BUFSIZ);
#    else
d756 1
a756 10
#    endif

#  else /* KLUDGE_FOR_WNT_TESTSUITE */

	    (void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	    (void) setvbuf (stderr, (char *) NULL, _IONBF, 0);

#  endif /* KLUDGE_FOR_WNT_TESTSUITE */

#endif /* HAVE_SETVBUF */
d759 1
a759 1
	    read_cvsrc (&argc, &argv, command_name);
d761 11
a771 1
    } /* end of stuff that gets done if the user DOESN'T ask for help */
d773 1
a773 8
    err = (*(cm->func)) (argc, argv);

    if (need_to_create_root)
    {
	/* Update the CVS/Root file.  We might want to do this in
	   all directories that we recurse into, but currently we
	   don't.  */
	Create_Root (NULL, CVSroot);
a774 1

a775 7

#ifdef SYSTEM_CLEANUP
    /* Hook for OS-specific behavior, for example socket subsystems on
       NT and OS2 or dealing with windows and arguments on Mac.  */
    SYSTEM_CLEANUP ();
#endif

@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d54 21
d102 1
a102 1
    
d134 1
a134 1
    { "tag",      "ta",       "freeze",    cvstag },
a241 44

unsigned long int
lookup_command_attribute (char *cmd_name)
{
    unsigned long int ret = 0;

    if (strcmp (cmd_name, "import") != 0)
    {
        ret |= CVS_CMD_IGNORE_ADMROOT;
    }

    
    if ((strcmp (cmd_name, "checkout") != 0) &&
        (strcmp (cmd_name, "login") != 0) &&
        (strcmp (cmd_name, "rdiff") != 0) &&
        (strcmp (cmd_name, "release") != 0) &&
        (strcmp (cmd_name, "rtag") != 0))
    {
        ret |= CVS_CMD_USES_WORK_DIR;
    }
        

    /* The following commands do not modify the repository; we
       conservatively assume that everything else does.  Feel free to
       add to this list if you are _certain_ something is safe. */
    if ((strcmp (cmd_name, "checkout") != 0) &&
        (strcmp (cmd_name, "diff") != 0) &&
        (strcmp (cmd_name, "update") != 0) &&
        (strcmp (cmd_name, "history") != 0) &&
        (strcmp (cmd_name, "editors") != 0) &&
        (strcmp (cmd_name, "export") != 0) &&
        (strcmp (cmd_name, "history") != 0) &&
        (strcmp (cmd_name, "log") != 0) &&
        (strcmp (cmd_name, "noop") != 0) &&
        (strcmp (cmd_name, "watchers") != 0) &&
        (strcmp (cmd_name, "status") != 0))
    {
        ret |= CVS_CMD_MODIFIES_REPOSITORY;
    }

    return ret;
}


d289 10
d327 2
a334 6
#ifdef HAVE_TZSET
    /* On systems that have tzset (which is almost all the ones I know
       of), it's a good idea to call it.  */
    tzset ();
#endif

d606 5
a610 4

	    if (lookup_command_attribute (command_name)
                & CVS_CMD_IGNORE_ADMROOT)
            {
d612 1
a612 2
            }

d641 9
a649 3
		    if (lookup_command_attribute (command_name)
                        & CVS_CMD_USES_WORK_DIR)
                    {
a650 2
                    }

d816 22
a837 7
#ifdef KLUDGE_FOR_WNT_TESTSUITE
	/* Probably the need for this will go away at some point once
	   we call fflush enough places (e.g. fflush (stdout) in
	   cvs_outerr).  */
	(void) setvbuf (stdout, (char *) NULL, _IONBF, 0);
	(void) setvbuf (stderr, (char *) NULL, _IONBF, 0);
#endif /* KLUDGE_FOR_WNT_TESTSUITE */
d899 1
a899 1
    error_exit ();
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d27 3
a29 3
/* I'd dynamically allocate this, but it seems like gethostname
   requires a fixed size array.  If I'm remembering the RFCs right,
   256 should be enough.  */
a103 1
    { "logout",   NULL,       NULL,        logout },
a172 1
    "        logout       Removes entry in .cvspass for remote repository.\n",
d209 1
a209 4
	    *line = xmalloc (strlen (c->fullname)
			     + (c->nick1 != NULL ? strlen (c->nick1) : 0)
			     + (c->nick2 != NULL ? strlen (c->nick2) : 0)
			     + 40);
d223 1
a223 2
lookup_command_attribute (cmd_name)
     char *cmd_name;
d232 1
a232 1

a233 1
        (strcmp (cmd_name, "init") != 0) &&
a234 1
	(strcmp (cmd_name, "logout") != 0) &&
d241 1
a241 1

d707 1
a707 1
		char *path;
a709 4
		path = xmalloc (strlen (CVSroot_directory)
				+ sizeof (CVSROOTADM)
				+ 20
				+ sizeof (CVSROOTADM_HISTORY));
a727 1
		free (path);
d750 1
d753 1
a753 1
	    CurDir = xstrdup ("<remote>");
d757 2
a758 3
	    CurDir = xgetwd ();
            if (CurDir == NULL)
		error (1, errno, "cannot get working directory");
d871 1
a871 1
    char date[MAXDATELEN];
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d403 5
a407 3
    /* I'm not sure whether this needs to be 1 instead of 0 anymore.  Using
       1 used to accomplish what passing "+" as the first character to
       the option string does, but that reason doesn't exist anymore.  */
d418 1
a418 1
            (argc, argv, "+f", NULL, NULL))
d420 1
a420 1
    {
d423 2
a424 2
    }

d435 1
a435 1
            (argc, argv, "+Qqrwtnlvb:T:e:d:Hfz:s:x", long_options, &option_index))
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d164 1
a164 1
    "        diff         Show differences between revisions\n",
a331 5
    int free_CVSroot = 0;
    int free_Editor = 0;
    int free_Tmpdir = 0;
    int free_Rcsbin = 0;

d336 1
a336 1
    {
a340 1
	{"allow-root", required_argument, NULL, 3},
d342 1
a342 1
    };
d403 5
a407 3
    /* Set this to 0 to force getopt initialization.  getopt() sets
       this to 1 internally.  */
    optind = 0;
d429 1
a429 1
    optind = 0;
d435 1
a435 1
    {
d437 1
a437 1
	{
a445 4
	    case 3:
		/* --allow-root */
		root_allow_add (optarg);
		break;
d480 1
a480 2
		Rcsbin = xstrdup (optarg);
		free_Rcsbin = 1;
d484 1
a484 2
		Tmpdir = xstrdup (optarg);
		free_Tmpdir = 1;
d488 1
a488 2
		Editor = xstrdup (optarg);
		free_Editor = 1;
d491 1
a491 2
		CVSroot = xstrdup (optarg);
		free_CVSroot = 1;
a598 6
	    /* The reason that --allow-root is not a command option
	       is mainly the comment in server() about how argc,argv
	       might be from .cvsrc.  I'm not sure about that, and
	       I'm not sure it is only true of command options, but
	       it seems easier to make it a global option.  */

a864 11
    free (program_path);
    if (free_CVSroot)
	free (CVSroot);
    if (free_Editor)
	free (Editor);
    if (free_Tmpdir)
	free (Tmpdir);
    if (free_Rcsbin)
	free (Rcsbin);
    root_allow_free ();

d871 3
a873 3
    /* This is exit rather than return because apparently that keeps
       some tools which check for memory leaks happier.  */
    exit (err ? EXIT_FAILURE : 0);
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 *    as specified in the README file that comes with the CVS source distribution.
d36 2
a37 2
int use_editor = 1;
int use_cvsrc = 1;
d39 5
a43 5
int really_quiet = 0;
int quiet = 0;
int trace = 0;
int noexec = 0;
int logoff = 0;
d51 1
d127 23
a149 22
    /* CVS usage messages never have followed the GNU convention of
       putting metavariables in uppercase.  I don't know whether that
       is a good convention or not, but if it changes it would have to
       change in all the usage messages.  For now, they consistently
       use lowercase, as far as I know.  Puncutation is pretty funky,
       though.  Sometimes they use none, as here.  Sometimes they use
       single quotes (not the TeX-ish `' stuff), as in --help-options.
       Sometimes they use double quotes, as in cvs -H add.

       Most (not all) of the usage messages seem to have periods at
       the end of each line.  I haven't tried to duplicate this style
       in --help as it is a rather different format from the rest.  */

    "Usage: %s [cvs-options] command [command-options-and-arguments]\n",
    "  where cvs-options are -q, -n, etc.\n",
    "    (specify --help-options for a list of options)\n",
    "  where command is add, admin, etc.\n",
    "    (specify --help-commands for a list of commands\n",
    "     or --help-synonyms for a list of command synonyms)\n",
    "  where command-options-and-arguments depend on the specific command\n",
    "    (specify -H followed by a command name for command-specific help)\n",
    "  Specify --help to receive this message\n",
d151 2
a152 18

    /* Some people think that a bug-reporting address should go here.  IMHO,
       the web sites are better because anything else is very likely to go
       obsolete in the years between a release and when someone might be
       reading this help.  Besides, we could never adequately discuss
       bug reporting in a concise enough way to put in a help message.  */

    /* I was going to put this at the top, but usage() wants the %s to
       be in the first line.  */
    "The Concurrent Versions System (CVS) is a tool for version control.\n",
    /* I really don't think I want to try to define "version control"
       in one line.  I'm not sure one can get more concise than the
       paragraph in ../cvs.spec without assuming the reader knows what
       version control means.  */

    "For CVS updates and additional information, see\n",
    "    Cyclic Software at http://www.cyclic.com/ or\n",
    "    Pascal Molli's CVS site at http://www.loria.fr/~molli/cvs-index.html\n",
d186 1
a186 1
    "(Specify the --help option for a list of other help options)\n",
a189 29
static const char *const opt_usage[] =
{
    "CVS global options (specified before the command name) are:\n",
    "    -H           Displays usage information for command.\n",
    "    -Q           Cause CVS to be really quiet.\n",
    "    -q           Cause CVS to be somewhat quiet.\n",
    "    -r           Make checked-out files read-only.\n",
    "    -w           Make checked-out files read-write (default).\n",
    "    -l           Turn history logging off.\n",
    "    -n           Do not execute anything that will change the disk.\n",
    "    -t           Show trace of program execution -- try with -n.\n",
    "    -v           CVS version and copyright.\n",
    "    -b bindir    Find RCS programs in 'bindir'.\n",
    "    -T tmpdir    Use 'tmpdir' for temporary files.\n",
    "    -e editor    Use 'editor' for editing log information.\n",
    "    -d CVS_root  Overrides $CVSROOT as the root of the CVS tree.\n",
    "    -f           Do not use the ~/.cvsrc file.\n",
#ifdef CLIENT_SUPPORT
    "    -z #         Use compression level '#' for net traffic.\n",
#ifdef ENCRYPTION
    "    -x           Encrypt all net traffic.\n",
#endif
    "    -a           Authenticate all net traffic.\n",
#endif
    "    -s VAR=VAL   Set CVS user variable.\n",
    "(Specify the --help option for a list of other help options)\n",
    NULL
};

d196 1
a196 2
    /* Three more for title, "specify --help" line, and NULL.  */
    int numcmds = 3;
a220 1
    *line++ = "(Specify the --help option for a list of other help options)\n";
d331 1
a331 1
    int tmpdir_update_env, cvs_update_env;
d335 1
a345 1
	{"help-options", 0, NULL, 4},
d383 6
d407 1
a407 1
	cvswrite = 0;
d424 1
a424 1
	    use_cvsrc = 0;
d437 1
a437 1
            (argc, argv, "+Qqrwtnlvb:T:e:d:Hfz:s:xa", long_options, &option_index))
a449 4
	    case 4:
		/* --help-options */
		usage (opt_usage);
		break;
d455 1
a455 1
		really_quiet = 1;
d458 1
a458 1
		quiet = 1;
d461 1
a461 1
		cvswrite = 0;
d464 1
a464 1
		cvswrite = 1;
d467 1
a467 1
		trace = 1;
d470 1
a470 1
		noexec = 1;
d472 1
a472 1
		logoff = 1;
a474 3
		/* Having the year here is a good idea, so people have
		   some idea of how long ago their version of CVS was
		   released.  */
d478 4
a481 3
		(void) fputs ("\
Copyright (c) 1989-1997 Brian Berliner, david d `zoo' zuhn, \n\
                        Jeff Polk, and other authors\n", stdout);
a484 4
		(void) fputs ("\n", stdout);

		(void) fputs ("Specify the --help option for further information about CVS\n", stdout);

d488 3
a490 5
		/* This option used to specify the directory for RCS
		   executables.  But since we don't run them any more,
		   this is a noop.  Silently ignore it so that .cvsrc
		   and scripts and inetd.conf and such can work with
		   either new or old CVS.  */
d510 1
a510 1
		use_cvsrc = 0; /* unnecessary, since we've done it above */
a534 9
	    case 'a':
#ifdef CLIENT_SUPPORT
		cvsauthenticate = 1;
#endif
		/* If no CLIENT_SUPPORT, ignore -a, so that users can
                   have it in their .cvsrc and not cause any trouble.
                   We will issue an error later if stream
                   authentication is not supported.  */
		break;
a564 3
    /* This should probably remain a warning, rather than an error,
       for quite a while.  For one thing the version of VC distributed
       with GNU emacs 19.34 invokes 'cvs rlog' instead of 'cvs log'.  */
d608 1
a608 1
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
d625 1
a625 1
#endif /* (AUTH_SERVER_SUPPORT || HAVE_GSSAPI) && SERVER_SUPPORT */
a626 2
#ifdef SERVER_SUPPORT
	server_active = strcmp (command_name, "server") == 0;
d632 2
a633 1
	if (!server_active)
d780 1
a780 1
	if (server_active)
d794 10
d814 18
a868 22
	/* Parse the CVSROOT/config file, but only for local.  For the
	   server, we parse it after we know $CVSROOT.  For the
	   client, it doesn't get parsed at all, obviously.  The
	   presence of the parse_config call here is not mean to
	   predetermine whether CVSROOT/config overrides things from
	   read_cvsrc and other such places or vice versa.  That sort
	   of thing probably needs more thought.  */
	if (1
#ifdef SERVER_SUPPORT
	    && !server_active
#endif
#ifdef CLIENT_SUPPORT
	    && !client_active
#endif
	    )
	{
	    /* If there was an error parsing the config file, parse_config
	       already printed an error.  We keep going.  Why?  Because
	       if we didn't, then there would be no way to check in a new
	       CVSROOT/config file to fix the broken one!  */
	    parse_config (CVSroot_directory);
	}
d877 1
a877 4
	   don't.  Note that if there is an error writing the file,
	   we give an error/warning.  This is so if users try to rewrite
	   CVS/Root with the -d option (a documented feature), they will
	   either succeed, or be told why it didn't work.  */
d890 2
a902 2
	/* Keep picky/stupid compilers (e.g. Visual C++ 5.0) happy.  */
	return 0;
d917 1
a917 1

d919 3
a921 6
    if (ftm == NULL)
	/* This is a system, like VMS, where the system clock is in local
	   time.  Hopefully using localtime here matches the "zero timezone"
	   hack I added to get_date.  */
	ftm = localtime (&unixtime);

@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d525 1
a525 1
Copyright (c) 1989-1998 Brian Berliner, david d `zoo' zuhn, \n\
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d111 1
a111 1
    { "status",   "st",       "stat",      cvsstatus },
d970 1
d972 2
a977 19
    return date_from_time_t (unixtime);
}

/* Convert a time_t to an RCS format date.  This is mainly for the
   use of "cvs history", because the CVSROOT/history file contains
   time_t format dates; most parts of CVS will want to avoid using
   time_t's directly, and instead use RCS_datecmp, Make_Date, &c.
   Assuming that the time_t is in GMT (as it generally should be),
   then the result will be in GMT too.

   Returns a newly malloc'd string.  */

char *
date_from_time_t (unixtime)
    time_t unixtime;
{
    struct tm *ftm;
    char date[MAXDATELEN];
    char *ret;
d983 1
a983 2
	   hack I added to get_date (get_date of course being the relevant
	   issue for Make_Date, and for history.c too I think).  */
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a43 6

/* Set if we should be writing CVSADM directories at top level.  At
   least for now we'll make the default be off (the CVS 1.9, not CVS
   1.9.2, behavior). */
int top_level_admin = 0;

a283 4
    /* The following commands do not use a checked-out working
       directory.  We conservatively assume that everything else does.
       Feel free to add to this list if you are _certain_ something
       something doesn't use the WD. */
d299 1
a299 2
    if ((strcmp (cmd_name, "annotate") != 0) &&
        (strcmp (cmd_name, "checkout") != 0) &&
a300 1
        (strcmp (cmd_name, "rdiff") != 0) &&
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@a14 1
#include <assert.h>
a59 10

/* When our working directory contains subdirectories with different
   values in CVS/Root files, we maintain a list of them.  */
List *root_directories = NULL;

/* We step through the above values.  This variable is set to reflect
   the currently active value. */
char *current_root = NULL;


a238 15

static int
set_root_directory (p, ignored)
    Node *p;
    void *ignored;
{
    if (current_root == NULL && p->data == NULL)
    {
	current_root = p->key;
	return 1;
    }
    return 0;
}


d314 1
d409 1
a564 3
		if (CVSroot_cmdline != NULL)
		    free (CVSroot_cmdline);
		CVSroot_cmdline = xstrdup (optarg);
a646 1
    {
a647 2
	err = (*(cm->func)) (argc, argv);
    }
d704 40
d745 89
d835 15
d917 8
d926 4
a929 5
	/* Fiddling with CVSROOT doesn't make sense if we're running
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

	if (!server_active)
d931 1
d933 5
a937 76
	    char *CVSADM_Root;
	    
	    /* See if we are able to find a 'better' value for CVSroot
	       in the CVSADM_ROOT directory. */

	    CVSADM_Root = NULL;

	    /* "cvs import" shouldn't check CVS/Root; in general it
	       ignores CVS directories and CVS/Root is likely to
	       specify a different repository than the one we are
	       importing to.  */

	    if ((lookup_command_attribute (command_name)
		 & CVS_CMD_IGNORE_ADMROOT)

		/* -d overrides CVS/Root, so don't give an error if the
		   latter points to a nonexistent repository.  */
		&& CVSroot_cmdline == NULL)
	    {
		CVSADM_Root = Name_Root((char *) NULL, (char *) NULL);
	    }

	    if (CVSADM_Root != NULL)
	    {
		if (CVSroot == NULL || !cvs_update_env)
		{
		    CVSroot = CVSADM_Root;
		    cvs_update_env = 1;	/* need to update environment */
		}
	    }

	    /* Now we've reconciled CVSROOT from the command line, the
	       CVS/Root file, and the environment variable.  Do the
	       last sanity checks on the variable. */

	    if (! CVSroot)
	    {
		error (0, 0,
		       "No CVSROOT specified!  Please use the `-d' option");
		error (1, 0,
		       "or set the %s environment variable.", CVSROOT_ENV);
	    }
	    
	    if (! *CVSroot)
	    {
		error (0, 0,
		       "CVSROOT is set but empty!  Make sure that the");
		error (0, 0,
		       "specification of CVSROOT is legal, either via the");
		error (0, 0,
		       "`-d' option, the %s environment variable, or the",
		       CVSROOT_ENV);
		error (1, 0,
		       "CVS/Root file (if any).");
	    }
	}

	/* Here begins the big loop over unique cvsroot values.  We
           need to call do_recursion once for each unique value found
           in CVS/Root.  Prime the list with the current value. */

	/* Create the list. */
	assert (root_directories == NULL);
	root_directories = getlist ();

	/* Prime it. */
	if (CVSroot != NULL)
	{
	    Node *n;
	    n = getnode ();
	    n->type = UNKNOWN;
	    n->key = xstrdup (CVSroot);
	    n->data = NULL;

	    if (addnode (root_directories, n))
		error (1, 0, "cannot add initial CVSROOT %s", n->key);
d939 1
d941 1
a941 1
	assert (current_root == NULL);
d943 10
a952 143
	/* If we're running the server, we want to execute this main
	   loop once and only once (we won't be serving multiple roots
	   from this connection, so there's no need to do it more than
	   once).  To get out of the loop, we perform a "break" at the
	   end of things.  */

	while (
#ifdef SERVER_SUPPORT
	       server_active ||
#endif
	       walklist (root_directories, set_root_directory, NULL)
	       )
	{
#ifdef SERVER_SUPPORT
	    /* Fiddling with CVSROOT doesn't make sense if we're running
	       in server mode, since the client will send the repository
	       directory after the connection is made. */

	    if (!server_active)
#endif
	    {
		/* Now we're 100% sure that we have a valid CVSROOT
		   variable.  Parse it to see if we're supposed to do
		   remote accesses or use a special access method. */

		if (parse_cvsroot (current_root))
		    error (1, 0, "Bad CVSROOT.");

		if (trace)
		    error (0, 0, "notice: main loop with CVSROOT=%s",
			   current_root);

		/*
		 * Check to see if we can write into the history file.  If not,
		 * we assume that we can't work in the repository.
		 * BUT, only if the history file exists.
		 */

		if (!client_active)
		{
		    char *path;
		    int save_errno;

		    path = xmalloc (strlen (CVSroot_directory)
				    + sizeof (CVSROOTADM)
				    + 20
				    + sizeof (CVSROOTADM_HISTORY));
		    (void) sprintf (path, "%s/%s", CVSroot_directory, CVSROOTADM);
		    if (!isaccessible (path, R_OK | X_OK))
		    {
			save_errno = errno;
			/* If this is "cvs init", the root need not exist yet.  */
			if (strcmp (command_name, "init") != 0)
			{
			    error (1, save_errno, "%s", path);
			}
		    }
		    (void) strcat (path, "/");
		    (void) strcat (path, CVSROOTADM_HISTORY);
		    if (isfile (path) && !isaccessible (path, R_OK | W_OK))
		    {
			save_errno = errno;
			error (0, 0, "Sorry, you don't have read/write access to the history file");
			error (1, save_errno, "%s", path);
		    }
		    free (path);
		}

#ifdef HAVE_PUTENV
		/* Update the CVSROOT environment variable if necessary. */
		/* FIXME (njc): should we always set this with the CVSROOT from the command line? */
		if (cvs_update_env)
		{
		    char *env;
		    env = xmalloc (strlen (CVSROOT_ENV) + strlen (CVSroot)
				   + 1 + 1);
		    (void) sprintf (env, "%s=%s", CVSROOT_ENV, CVSroot);
		    (void) putenv (env);
		    /* do not free env, as putenv has control of it */
		}
#endif
	    }
	
	    /* Parse the CVSROOT/config file, but only for local.  For the
	       server, we parse it after we know $CVSROOT.  For the
	       client, it doesn't get parsed at all, obviously.  The
	       presence of the parse_config call here is not mean to
	       predetermine whether CVSROOT/config overrides things from
	       read_cvsrc and other such places or vice versa.  That sort
	       of thing probably needs more thought.  */
	    if (1
#ifdef SERVER_SUPPORT
		&& !server_active
#endif
#ifdef CLIENT_SUPPORT
		&& !client_active
#endif
		)
	    {
		/* If there was an error parsing the config file, parse_config
		   already printed an error.  We keep going.  Why?  Because
		   if we didn't, then there would be no way to check in a new
		   CVSROOT/config file to fix the broken one!  */
		parse_config (CVSroot_directory);
	    }

#ifdef CLIENT_SUPPORT
	    if (client_active)
	    {
		/* Create a new list for directory names that we've
		   sent to the server. */
		if (dirs_sent_to_server != NULL)
		    dellist (&dirs_sent_to_server);
		dirs_sent_to_server = getlist ();
	    }
#endif

	    err = (*(cm->func)) (argc, argv);
	
	    /* Mark this root directory as done.  When the server is
               active, current_root will be NULL -- don't try and
               remove it from the list. */

	    if (current_root != NULL)
	    {
		Node *n = findnode (root_directories, current_root);
		assert (n != NULL);
		n->data = (void *) 1;
		current_root = NULL;
	    }
	
#if 0
	    /* This will not work yet, since it tries to free (void *) 1. */
	    dellist (&root_directories);
#endif

#ifdef SERVER_SUPPORT
	    if (server_active)
	      break;
#endif
	} /* end of loop for cvsroot values */

    } /* end of stuff that gets done if the user DOESN'T ask for help */
a956 2
    if (CVSroot_cmdline != NULL)
	free (CVSroot_cmdline);
a1020 37
}

/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is in our internal RCS format.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
date_to_internet (dest, source)
    char *dest;
    char *source;
{
    int year, month, day, hour, minute, second;

    /* Just to reiterate, these strings are from RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    if (sscanf (source, SDATEFORM,
		&year, &month, &day, &hour, &minute, &second)
	!= 6)
	/* Is there a better way to handle errors here?  I made this
	   non-fatal in case we are called from the code which can't
	   deal with fatal errors.  */
	error (0, 0, "internal error: bad date %s", source);

    /* Always send a four digit year.  */
    if (year < 100)
	year += 1900;

    sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", day,
	     month < 1 || month > 12 ? "???" : month_names[month - 1],
	     year, hour, minute, second);
@


1.1.1.15
log
@Latest version from Cyclic
@
text
@a222 1
    /* Omit -b because it is just for compatibility.  */
d233 1
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@d114 1
a114 1
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
d121 1
a121 2
#endif /* AUTH_CLIENT_SUPPORT */
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
d124 1
d128 1
a129 4
#ifdef SERVER_SUPPORT
    { "server",   NULL,       NULL,        server },
#endif
    { "status",   "st",       "stat",      cvsstatus },
a132 1
    { "version",  "ve",       "ver",       version },
d135 3
d182 1
a182 1
    "    the CVS home page at http://www.cvshome.org/ or\n",
a201 3
#if defined (HAVE_KERBEROS) && defined (SERVER_SUPPORT)
    "        kserver      Kerberos server mode\n",
#endif
d204 2
a205 2
    "        login        Prompt for password for authenticating server\n",
    "        logout       Removes entry in .cvspass for remote repository\n",
a206 3
#if (defined(AUTH_SERVER_SUPPORT) || defined (HAVE_GSSAPI)) && defined(SERVER_SUPPORT)
    "        pserver      Password server mode\n",
#endif
a210 3
#ifdef SERVER_SUPPORT
    "        server       Server mode\n",
#endif
a345 1
        (strcmp (cmd_name, "release") != 0) &&
a364 5
#ifdef SIGABRT
    case SIGABRT:
	name = "abort";
	break;
#endif
d408 2
a420 1
    static const char short_options[] = "+Qqrwtnlvb:T:e:d:Hfz:s:xa";
d495 1
a495 1
            (argc, argv, short_options, long_options, &option_index))
d512 1
a512 1
            (argc, argv, short_options, long_options, &option_index))
d554 5
a558 2
		(void) fputs ("\n", stdout);
		version (0, (char **) NULL);    
d561 1
a561 1
Copyright (c) 1989-2000 Brian Berliner, david d `zoo' zuhn, \n\
d605 1
a605 1
		if (gzip_level < 0 || gzip_level > 9)
d607 1
a607 1
			 "gzip compression level must be between 0 and 9");
d660 1
a660 4
    {
	fprintf (stderr, "Unknown command: `%s'\n\n", command_name);
	usage (cmd_usage);
    }
a767 3
#ifdef SIGABRT
	(void) SIG_register (SIGABRT, main_cleanup);
#endif
d770 1
d774 1
d778 1
d782 1
d786 1
d881 1
a881 1
	    n->type = NT_UNKNOWN;
d924 3
a926 1
		 * Check to see if the repository exists.
d928 1
d936 2
a937 1
				    + 20);
d948 8
a963 1
		    static char *prev;
d969 1
a969 5
		    /* do not free env yet, as putenv has control of it */
		    /* but do free the previous value, if any */
		    if (prev != NULL)
			free (prev);
		    prev = env;
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d67 2
a68 6
 * the currently active value.
 *
 * Now static.  FIXME - this variable should be removable (well, localizable)
 * with a little more work.
 */
static char *current_root = NULL;
a98 1
    unsigned long attr;		/* Attributes. */
d102 12
a113 12
    { "add",      "ad",       "new",       add,       CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "admin",    "adm",      "rcs",       admin,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "annotate", "ann",      NULL,        annotate,  CVS_CMD_USES_WORK_DIR },
    { "checkout", "co",       "get",       checkout,  0 },
    { "commit",   "ci",       "com",       commit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "diff",     "di",       "dif",       diff,      CVS_CMD_USES_WORK_DIR },
    { "edit",     NULL,       NULL,        edit,      CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "editors",  NULL,       NULL,        editors,   CVS_CMD_USES_WORK_DIR },
    { "export",   "exp",      "ex",        checkout,  CVS_CMD_USES_WORK_DIR },
    { "history",  "hi",       "his",       history,   CVS_CMD_USES_WORK_DIR },
    { "import",   "im",       "imp",       import,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR | CVS_CMD_IGNORE_ADMROOT},
    { "init",     NULL,       NULL,        init,      CVS_CMD_MODIFIES_REPOSITORY },
d115 1
a115 1
    { "kserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
d117 1
a117 1
    { "log",      "lo",       NULL,        cvslog,    CVS_CMD_USES_WORK_DIR },
d119 2
a120 2
    { "login",    "logon",    "lgn",       login,     0 },
    { "logout",   NULL,       NULL,        logout,    0 },
d123 1
a123 1
    { "pserver",  NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR }, /* placeholder */
d125 4
a128 6
    { "rannotate","rann",     "ra",        annotate,  0 },
    { "rdiff",    "patch",    "pa",        patch,     0 },
    { "release",  "re",       "rel",       release,   0 },
    { "remove",   "rm",       "delete",    cvsremove, CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "rlog",     "rl",       NULL,        cvslog,    0 },
    { "rtag",     "rt",       "rfreeze",   cvstag,    CVS_CMD_MODIFIES_REPOSITORY },
d130 1
a130 1
    { "server",   NULL,       NULL,        server,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
d132 8
a139 8
    { "status",   "st",       "stat",      cvsstatus, CVS_CMD_USES_WORK_DIR },
    { "tag",      "ta",       "freeze",    cvstag,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "unedit",   NULL,       NULL,        unedit,    CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "update",   "up",       "upd",       update,    CVS_CMD_USES_WORK_DIR },
    { "version",  "ve",       "ver",       version,   0 },
    { "watch",    NULL,       NULL,        watch,     CVS_CMD_MODIFIES_REPOSITORY | CVS_CMD_USES_WORK_DIR },
    { "watchers", NULL,       NULL,        watchers,  CVS_CMD_USES_WORK_DIR },
    { NULL, NULL, NULL, NULL, 0 },
a213 1
    "        rannotate    Show last revision where each line of module was modified\n",
a216 1
    "        rlog         Print out history information for a module\n",
a224 1
    "        version      Show current CVS version(s)\n",
d318 23
a340 1
    const struct cmd *cm;
d342 16
a357 1
    for (cm = cmds; cm->fullname; cm++)
d359 1
a359 2
	if (strcmp (cmd_name, cm->fullname) == 0)
	    break;
d361 2
a362 1
    return cm->attr;
d573 1
a573 1
Copyright (c) 1989-2001 Brian Berliner, david d `zoo' zuhn, \n\
a603 2
		if (free_CVSroot)
		    free (CVSroot);
d679 9
d836 2
a837 1
	    if (!(cm->attr & CVS_CMD_IGNORE_ADMROOT)
d929 1
a929 3
		if (current_parsed_root != NULL)
		    free_cvsroot_t (current_parsed_root);
		if ((current_parsed_root = parse_cvsroot (current_root)) == NULL)
d933 2
a934 2
		    fprintf (stderr, "%s-> main loop with CVSROOT=%s\n",
			   CLIENT_SERVER_STR, current_root);
d939 1
a939 3
#ifdef CLIENT_SUPPORT
		if (!current_parsed_root->isremote)
#endif	/* CLIENT_SUPPORT */
d944 1
a944 1
		    path = xmalloc (strlen (current_parsed_root->directory)
d946 2
a947 2
				    + 2);
		    (void) sprintf (path, "%s/%s", current_parsed_root->directory, CVSROOTADM);
d992 1
a992 1
		&& !current_parsed_root->isremote
d1000 1
a1000 1
		parse_config (current_parsed_root->directory);
d1004 1
a1004 5
	    /* Need to check for current_parsed_root != NULL here since
	     * we could still be in server mode before the server function
	     * gets called below and sets the root
	     */
	    if (current_parsed_root != NULL && current_parsed_root->isremote)
d1122 1
a1122 1
    const char *source;
d1124 1
a1124 1
    struct tm date;
d1126 5
a1130 3
    date_to_tm (&date, source);
    tm_to_internet (dest, &date);
}
a1131 5
void
date_to_tm (dest, source)
    struct tm *dest;
    const char *source;
{
d1133 2
a1134 3
		&dest->tm_year, &dest->tm_mon, &dest->tm_mday,
		&dest->tm_hour, &dest->tm_min, &dest->tm_sec)
	    != 6)
d1140 7
a1146 27
    if (dest->tm_year > 100)
	dest->tm_year -= 1900;

    dest->tm_mon -= 1;
}

/* Convert a date to RFC822/1123 format.  This is used in contexts like
   dates to send in the protocol; it should not vary based on locale or
   other such conventions for users.  We should have another routine which
   does that kind of thing.

   The SOURCE date is a pointer to a struct tm.  DEST should point to
   storage managed by the caller, at least MAXDATELEN characters.  */
void
tm_to_internet (dest, source)
    char *dest;
    const struct tm *source;
{
    /* Just to reiterate, these strings are from RFC822 and do not vary
       according to locale.  */
    static const char *const month_names[] =
      {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
    
    sprintf (dest, "%d %s %d %02d:%02d:%02d -0000", source->tm_mday,
	     source->tm_mon < 0 || source->tm_mon > 11 ? "???" : month_names[source->tm_mon],
	     source->tm_year + 1900, source->tm_hour, source->tm_min, source->tm_sec);
@


