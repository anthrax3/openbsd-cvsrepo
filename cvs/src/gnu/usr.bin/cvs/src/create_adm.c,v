head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.11.0.66
	OPENBSD_6_1_BASE:1.1.1.11
	OPENBSD_6_0:1.1.1.11.0.62
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.58
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.60
	OPENBSD_5_8_BASE:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.52
	OPENBSD_5_7_BASE:1.1.1.11
	OPENBSD_5_6:1.1.1.11.0.56
	OPENBSD_5_6_BASE:1.1.1.11
	OPENBSD_5_5:1.1.1.11.0.54
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.50
	OPENBSD_5_4_BASE:1.1.1.11
	OPENBSD_5_3:1.1.1.11.0.48
	OPENBSD_5_3_BASE:1.1.1.11
	OPENBSD_5_2:1.1.1.11.0.46
	OPENBSD_5_2_BASE:1.1.1.11
	OPENBSD_5_1_BASE:1.1.1.11
	OPENBSD_5_1:1.1.1.11.0.44
	OPENBSD_5_0:1.1.1.11.0.42
	OPENBSD_5_0_BASE:1.1.1.11
	OPENBSD_4_9:1.1.1.11.0.40
	OPENBSD_4_9_BASE:1.1.1.11
	OPENBSD_4_8:1.1.1.11.0.38
	OPENBSD_4_8_BASE:1.1.1.11
	OPENBSD_4_7:1.1.1.11.0.34
	OPENBSD_4_7_BASE:1.1.1.11
	OPENBSD_4_6:1.1.1.11.0.36
	OPENBSD_4_6_BASE:1.1.1.11
	OPENBSD_4_5:1.1.1.11.0.32
	OPENBSD_4_5_BASE:1.1.1.11
	OPENBSD_4_4:1.1.1.11.0.30
	OPENBSD_4_4_BASE:1.1.1.11
	OPENBSD_4_3:1.1.1.11.0.28
	OPENBSD_4_3_BASE:1.1.1.11
	OPENBSD_4_2:1.1.1.11.0.26
	OPENBSD_4_2_BASE:1.1.1.11
	OPENBSD_4_1:1.1.1.11.0.24
	OPENBSD_4_1_BASE:1.1.1.11
	OPENBSD_4_0:1.1.1.11.0.22
	OPENBSD_4_0_BASE:1.1.1.11
	OPENBSD_3_9:1.1.1.11.0.20
	OPENBSD_3_9_BASE:1.1.1.11
	OPENBSD_3_8:1.1.1.11.0.18
	OPENBSD_3_8_BASE:1.1.1.11
	OPENBSD_3_7:1.1.1.11.0.16
	OPENBSD_3_7_BASE:1.1.1.11
	OPENBSD_3_6:1.1.1.11.0.14
	OPENBSD_3_6_BASE:1.1.1.11
	OPENBSD_3_5:1.1.1.11.0.12
	OPENBSD_3_5_BASE:1.1.1.11
	OPENBSD_3_4:1.1.1.11.0.10
	OPENBSD_3_4_BASE:1.1.1.11
	OPENBSD_3_3:1.1.1.11.0.8
	OPENBSD_3_3_BASE:1.1.1.11
	OPENBSD_3_2:1.1.1.11.0.6
	OPENBSD_3_2_BASE:1.1.1.11
	OPENBSD_3_1:1.1.1.11.0.4
	OPENBSD_3_1_BASE:1.1.1.11
	OPENBSD_3_0:1.1.1.11.0.2
	OPENBSD_3_0_BASE:1.1.1.11
	cvs-1-11-1p1:1.1.1.11
	OPENBSD_2_9:1.1.1.10.0.2
	OPENBSD_2_9_BASE:1.1.1.10
	cvs-1-11:1.1.1.10
	OPENBSD_2_8:1.1.1.9.0.8
	OPENBSD_2_8_BASE:1.1.1.9
	OPENBSD_2_7:1.1.1.9.0.6
	OPENBSD_2_7_BASE:1.1.1.9
	OPENBSD_2_6:1.1.1.9.0.4
	OPENBSD_2_6_BASE:1.1.1.9
	cvs-1-10-7:1.1.1.9
	OPENBSD_2_5:1.1.1.9.0.2
	OPENBSD_2_5_BASE:1.1.1.9
	cvs-1-10-5:1.1.1.9
	OPENBSD_2_4:1.1.1.8.0.4
	OPENBSD_2_4_BASE:1.1.1.8
	cvs-1-10:1.1.1.8
	cvs-1-9-28:1.1.1.8
	OPENBSD_2_3:1.1.1.8.0.2
	OPENBSD_2_3_BASE:1.1.1.8
	cvs-1-9-26:1.1.1.8
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.4
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.6.0.2
	OPENBSD_2_1_BASE:1.1.1.6
	cvs-1-9-8:1.1.1.6
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.41.45;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.19.25;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.28;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.24;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.04.21.04.27.07;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.21.06;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.03.12.06.58.38;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.02.28.21.32.48;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2001.02.10.18.57.39;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS 1.4 kit.
 * 
 * Create Administration.
 * 
 * Creates a CVS administration directory based on the argument repository; the
 * "Entries" file is prefilled from the "initrecord" argument.
 */

#include "cvs.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)create_adm.c 1.28 94/09/23 $";
USE(rcsid);
#endif

/* update_dir includes dir as its last component.  */

void
Create_Admin (dir, update_dir, repository, tag, date)
    char *dir;
    char *update_dir;
    char *repository;
    char *tag;
    char *date;
{
    FILE *fout;
    char *cp;
    char tmp[PATH_MAX];

#ifdef SERVER_SUPPORT
    if (trace)
      {
	char wd[PATH_MAX];
	getwd (wd);
	fprintf (stderr, "%c-> Create_Admin (%s, %s, %s, %s, %s) in %s\n",
		 (server_active) ? 'S' : ' ',
                dir, update_dir, repository, tag ? tag : "",
                date ? date : "", wd);
      }
#endif

    if (noexec)
	return;

    if (dir != NULL)
	(void) sprintf (tmp, "%s/%s", dir, CVSADM);
    else
	(void) strcpy (tmp, CVSADM);
    if (isfile (tmp))
	error (1, 0, "there is a version in %s already", update_dir);

    make_directory (tmp);

#ifdef CVSADM_ROOT
    /* record the current cvs root for later use */

    Create_Root (dir, CVSroot);
#endif /* CVSADM_ROOT */
    if (dir != NULL)
	(void) sprintf (tmp, "%s/%s", dir, CVSADM_REP);
    else
	(void) strcpy (tmp, CVSADM_REP);
    fout = fopen (tmp, "w+");
    if (fout == NULL)
    {
	if (update_dir[0] == '\0')
	    error (1, errno, "cannot open %s", tmp);
	else
	    error (1, errno, "cannot open %s/%s", update_dir, CVSADM_REP);
    }
    cp = repository;
    strip_path (cp);

#ifdef RELATIVE_REPOS
    /*
     * If the Repository file is to hold a relative path, try to strip off
     * the leading CVSroot argument.
     */
    if (CVSroot != NULL)
    {
	char path[PATH_MAX];

	(void) sprintf (path, "%s/", CVSroot);
	if (strncmp (repository, path, strlen (path)) == 0)
	    cp = repository + strlen (path);
    }
#endif

    if (fprintf (fout, "%s\n", cp) < 0)
    {
	if (update_dir[0] == '\0')
	    error (1, errno, "write to %s failed", tmp);
	else
	    error (1, errno, "write to %s/%s failed", update_dir, CVSADM_REP);
    }
    if (fclose (fout) == EOF)
    {
	if (update_dir[0] == '\0')
	    error (1, errno, "cannot close %s", tmp);
	else
	    error (1, errno, "cannot close %s/%s", update_dir, CVSADM_REP);
    }

    /* now, do the Entries file */
    if (dir != NULL)
	(void) sprintf (tmp, "%s/%s", dir, CVSADM_ENT);
    else
	(void) strcpy (tmp, CVSADM_ENT);
    fout = fopen (tmp, "w+");
    if (fout == NULL)
    {
	if (update_dir[0] == '\0')
	    error (1, errno, "cannot open %s", tmp);
	else
	    error (1, errno, "cannot open %s/%s", update_dir, CVSADM_ENT);
    }
    if (fclose (fout) == EOF)
    {
	if (update_dir[0] == '\0')
	    error (1, errno, "cannot close %s", tmp);
	else
	    error (1, errno, "cannot close %s/%s", update_dir, CVSADM_ENT);
    }

    /* Create a new CVS/Tag file */
    WriteTag (dir, tag, date);

#ifdef SERVER_SUPPORT
    if (server_active)
      server_set_sticky (update_dir, repository, tag, date);

    if (trace)
      {
	fprintf (stderr, "%c<- Create_Admin\n",
		 (server_active) ? 'S' : ' ');
      }
#endif

}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d16 5
d59 1
d63 1
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@d32 1
a32 1
    {
d39 1
a39 1
    }
d128 1
a128 4
    {
	server_set_sticky (update_dir, repository, tag, date);
	server_template (update_dir, repository);
    }
d131 1
a131 1
    {
d134 1
a134 1
    }
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d56 1
a56 1
    Create_Root (dir, CVSroot_original);
d61 1
a61 1
    fout = CVS_FOPEN (tmp, "w+");
d77 1
a77 1
    if (CVSroot_directory != NULL)
d81 1
a81 1
	(void) sprintf (path, "%s/", CVSroot_directory);
d107 1
a107 1
    fout = CVS_FOPEN (tmp, "w+");
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d28 1
a28 1
    char *tmp;
d33 2
a34 1
	char *wd = xgetwd ();
a38 1
	free (wd);
a44 1
    tmp = xmalloc (strlen (dir) + 100);
d70 1
a70 1
    strip_trailing_slashes (cp);
d79 1
a79 1
	char *path = xmalloc (strlen (CVSroot_directory) + 10);
a83 1
	free (path);
a139 1
    free (tmp);
@


1.1.1.6
log
@Latest release from Cyclic Software
@
text
@d19 1
a19 1
Create_Admin (dir, update_dir, repository, tag, date, nonbranch)
a24 1
    int nonbranch;
d126 1
a126 1
    WriteTag (dir, tag, date, nonbranch, update_dir, repository);
d131 1
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d16 1
a16 1
/* update_dir includes dir as its last component.
d18 2
a19 8
   Return value is 0 for success, or 1 if we printed a warning message.
   Note that many errors are still fatal; particularly for unlikely errors
   a fatal error is probably better than a warning which might be missed
   or after which CVS might do something non-useful.  If WARN is zero, then
   don't print warnings; all errors are fatal then.  */

int
Create_Admin (dir, update_dir, repository, tag, date, nonbranch, warn)
a25 1
    int warn;
a28 1
    char *reposcopy;
d34 2
a35 1
	fprintf (stderr, "%c-> Create_Admin (%s, %s, %s, %s, %s, %d, %d)\n",
d37 3
a39 2
		 dir, update_dir, repository, tag ? tag : "",
		 date ? date : "", nonbranch, warn);
d44 1
a44 1
	return 0;
d54 1
a54 15
    if (CVS_MKDIR (tmp, 0777) < 0)
    {
	if (warn)
	{
	    /* The reason that this is a warning, rather than silently
	       just skipping creating the directory, is that we don't want
	       CVS's behavior to vary subtly based on factors (like directory
	       permissions) which are not made clear to the user.  With
	       the warning at least we let them know what is going on.  */
	    error (0, errno, "warning: cannot make directory %s", tmp);
	    return 1;
	}
	else
	    error (1, errno, "cannot make directory %s", tmp);
    }
d71 2
a72 16
    reposcopy = xstrdup (repository);
    Sanitize_Repository_Name (reposcopy);

    /* The top level of the repository is a special case -- we need to
       write it with an extra dot at the end.  This trailing `.' stuff
       rubs me the wrong way -- on the other hand, I don't want to
       spend the time making sure all of the code can handle it if we
       don't do it. */

    if (strcmp (reposcopy, CVSroot_directory) == 0)
    {
	reposcopy = xrealloc (reposcopy, strlen (reposcopy) + 3);
	strcat (reposcopy, "/.");
    }

    cp = reposcopy;
d84 2
a85 2
	if (strncmp (cp, path, strlen (path)) == 0)
	    cp += strlen (path);
a141 1
    free (reposcopy);
a142 1
    return 0;
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@a61 6
	/* We want to print out the entire update_dir, since a lot of
	   our code calls this function with dir == "." or dir ==
	   NULL.  I hope that gives enough information in cases like
	   absolute pathnames; printing out xgetwd or something would
	   be way too verbose in the common cases.  */

d69 1
a69 3
	    error (0, errno, "warning: cannot make directory %s in %s",
		   CVSADM, update_dir);
	    free (tmp);
d73 1
a73 2
	    error (1, errno, "cannot make directory %s in %s",
		   CVSADM, update_dir);
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@d39 1
d42 2
a43 2
	fprintf (stderr, "%s-> Create_Admin (%s, %s, %s, %s, %s, %d, %d)\n",
		 CLIENT_SERVER_STR,
d47 1
@


1.1.1.10
log
@Latest from Cyclic Software
@
text
@d25 1
a25 2
Create_Admin (dir, update_dir, repository, tag, date, nonbranch, warn,
	      dotemplate)
a32 1
    int dotemplate;
d171 1
a171 1
    if (server_active && dotemplate)
@


1.1.1.11
log
@Latest from Cyclic Software
@
text
@d87 1
a87 1
    Create_Root (dir, current_parsed_root->original);
d109 1
a109 1
    if (strcmp (reposcopy, current_parsed_root->directory) == 0)
d122 1
d124 1
a124 1
    char *path = xmalloc (strlen (current_parsed_root->directory) + 2);
d126 4
a129 4
    (void) sprintf (path, "%s/", current_parsed_root->directory);
    if (strncmp (cp, path, strlen (path)) == 0)
	cp += strlen (path);
    free (path);
@


