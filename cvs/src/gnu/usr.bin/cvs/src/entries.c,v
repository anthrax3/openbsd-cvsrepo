head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.22
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.14
	OPENBSD_5_1:1.1.1.14.0.44
	OPENBSD_5_0:1.1.1.14.0.42
	OPENBSD_5_0_BASE:1.1.1.14
	OPENBSD_4_9:1.1.1.14.0.40
	OPENBSD_4_9_BASE:1.1.1.14
	OPENBSD_4_8:1.1.1.14.0.38
	OPENBSD_4_8_BASE:1.1.1.14
	OPENBSD_4_7:1.1.1.14.0.34
	OPENBSD_4_7_BASE:1.1.1.14
	OPENBSD_4_6:1.1.1.14.0.36
	OPENBSD_4_6_BASE:1.1.1.14
	OPENBSD_4_5:1.1.1.14.0.32
	OPENBSD_4_5_BASE:1.1.1.14
	OPENBSD_4_4:1.1.1.14.0.30
	OPENBSD_4_4_BASE:1.1.1.14
	OPENBSD_4_3:1.1.1.14.0.28
	OPENBSD_4_3_BASE:1.1.1.14
	OPENBSD_4_2:1.1.1.14.0.26
	OPENBSD_4_2_BASE:1.1.1.14
	OPENBSD_4_1:1.1.1.14.0.24
	OPENBSD_4_1_BASE:1.1.1.14
	OPENBSD_4_0:1.1.1.14.0.22
	OPENBSD_4_0_BASE:1.1.1.14
	OPENBSD_3_9:1.1.1.14.0.20
	OPENBSD_3_9_BASE:1.1.1.14
	OPENBSD_3_8:1.1.1.14.0.18
	OPENBSD_3_8_BASE:1.1.1.14
	OPENBSD_3_7:1.1.1.14.0.16
	OPENBSD_3_7_BASE:1.1.1.14
	OPENBSD_3_6:1.1.1.14.0.14
	OPENBSD_3_6_BASE:1.1.1.14
	OPENBSD_3_5:1.1.1.14.0.12
	OPENBSD_3_5_BASE:1.1.1.14
	OPENBSD_3_4:1.1.1.14.0.10
	OPENBSD_3_4_BASE:1.1.1.14
	OPENBSD_3_3:1.1.1.14.0.8
	OPENBSD_3_3_BASE:1.1.1.14
	OPENBSD_3_2:1.1.1.14.0.6
	OPENBSD_3_2_BASE:1.1.1.14
	OPENBSD_3_1:1.1.1.14.0.4
	OPENBSD_3_1_BASE:1.1.1.14
	OPENBSD_3_0:1.1.1.14.0.2
	OPENBSD_3_0_BASE:1.1.1.14
	cvs-1-11-1p1:1.1.1.14
	OPENBSD_2_9:1.1.1.13.0.2
	OPENBSD_2_9_BASE:1.1.1.13
	cvs-1-11:1.1.1.13
	OPENBSD_2_8:1.1.1.12.0.8
	OPENBSD_2_8_BASE:1.1.1.12
	OPENBSD_2_7:1.1.1.12.0.6
	OPENBSD_2_7_BASE:1.1.1.12
	OPENBSD_2_6:1.1.1.12.0.4
	OPENBSD_2_6_BASE:1.1.1.12
	cvs-1-10-7:1.1.1.12
	OPENBSD_2_5:1.1.1.12.0.2
	OPENBSD_2_5_BASE:1.1.1.12
	cvs-1-10-5:1.1.1.12
	OPENBSD_2_4:1.1.1.11.0.4
	OPENBSD_2_4_BASE:1.1.1.11
	cvs-1-10:1.1.1.11
	cvs-1-9-28:1.1.1.11
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.32;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.05;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.48;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.29;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.31;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.27;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.29.04.38.11;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.12;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.40;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.10;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.41;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	99.02.28.21.32.52;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.02.10.18.57.39;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * Entries file to Files file
 * 
 * Creates the file Files containing the names that comprise the project, from
 * the Entries file.
 */

#include "cvs.h"
#include "getline.h"

static Node *AddEntryNode PROTO((List * list, Entnode *entnode));

static Entnode *fgetentent PROTO((FILE *, char *, int *));
static int   fputentent PROTO((FILE *, Entnode *));

static Entnode *subdir_record PROTO((int, const char *, const char *));

static FILE *entfile;
static char *entfilename;		/* for error messages */

/*
 * Construct an Entnode
 */
static Entnode *Entnode_Create PROTO ((enum ent_type, const char *,
				       const char *, const char *,
				       const char *, const char *,
				       const char *, const char *));

static Entnode *
Entnode_Create(type, user, vn, ts, options, tag, date, ts_conflict)
    enum ent_type type;
    const char *user;
    const char *vn;
    const char *ts;
    const char *options;
    const char *tag;
    const char *date;
    const char *ts_conflict;
{
    Entnode *ent;
    
    /* Note that timestamp and options must be non-NULL */
    ent = (Entnode *) xmalloc (sizeof (Entnode));
    ent->type      = type;
    ent->user      = xstrdup (user);
    ent->version   = xstrdup (vn);
    ent->timestamp = xstrdup (ts ? ts : "");
    ent->options   = xstrdup (options ? options : "");
    ent->tag       = xstrdup (tag);
    ent->date      = xstrdup (date);
    ent->conflict  = xstrdup (ts_conflict);

    return ent;
}

/*
 * Destruct an Entnode
 */
static void Entnode_Destroy PROTO ((Entnode *));

static void
Entnode_Destroy (ent)
    Entnode *ent;
{
    free (ent->user);
    free (ent->version);
    free (ent->timestamp);
    free (ent->options);
    if (ent->tag)
	free (ent->tag);
    if (ent->date)
	free (ent->date);
    if (ent->conflict)
	free (ent->conflict);
    free (ent);
}

/*
 * Write out the line associated with a node of an entries file
 */
static int write_ent_proc PROTO ((Node *, void *));
static int
write_ent_proc (node, closure)
     Node *node;
     void *closure;
{
    Entnode *entnode;

    entnode = (Entnode *) node->data;

    if (closure != NULL && entnode->type != ENT_FILE)
	*(int *) closure = 1;

    if (fputentent(entfile, entnode))
	error (1, errno, "cannot write %s", entfilename);

    return (0);
}

/*
 * write out the current entries file given a list,  making a backup copy
 * first of course
 */
static void
write_entries (list)
    List *list;
{
    int sawdir;

    sawdir = 0;

    /* open the new one and walk the list writing entries */
    entfilename = CVSADM_ENTBAK;
    entfile = CVS_FOPEN (entfilename, "w+");
    if (entfile == NULL)
    {
	/* Make this a warning, not an error.  For example, one user might
	   have checked out a working directory which, for whatever reason,
	   contains an Entries.Log file.  A second user, without write access
	   to that working directory, might want to do a "cvs log".  The
	   problem rewriting Entries shouldn't affect the ability of "cvs log"
	   to work, although the warning is probably a good idea so that
	   whether Entries gets rewritten is not an inexplicable process.  */
	/* FIXME: should be including update_dir in message.  */
	error (0, errno, "cannot rewrite %s", entfilename);

	/* Now just return.  We leave the Entries.Log file around.  As far
	   as I know, there is never any data lying around in 'list' that
	   is not in Entries.Log at this time (if there is an error writing
	   Entries.Log that is a separate problem).  */
	return;
    }

    (void) walklist (list, write_ent_proc, (void *) &sawdir);
    if (! sawdir)
    {
	struct stickydirtag *sdtp;

	/* We didn't write out any directories.  Check the list
           private data to see whether subdirectory information is
           known.  If it is, we need to write out an empty D line.  */
	sdtp = (struct stickydirtag *) list->list->data;
	if (sdtp == NULL || sdtp->subdirs)
	    if (fprintf (entfile, "D\n") < 0)
		error (1, errno, "cannot write %s", entfilename);
    }
    if (fclose (entfile) == EOF)
	error (1, errno, "error closing %s", entfilename);

    /* now, atomically (on systems that support it) rename it */
    rename_file (entfilename, CVSADM_ENT);

    /* now, remove the log file */
    if (unlink_file (CVSADM_ENTLOG) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", CVSADM_ENTLOG);
}

/*
 * Removes the argument file from the Entries file if necessary.
 */
void
Scratch_Entry (list, fname)
    List *list;
    char *fname;
{
    Node *node;

    if (trace)
	(void) fprintf (stderr, "%s-> Scratch_Entry(%s)\n",
			CLIENT_SERVER_STR, fname);

    /* hashlookup to see if it is there */
    if ((node = findnode_fn (list, fname)) != NULL)
    {
	if (!noexec)
	{
	    entfilename = CVSADM_ENTLOG;
	    entfile = open_file (entfilename, "a");

	    if (fprintf (entfile, "R ") < 0)
		error (1, errno, "cannot write %s", entfilename);

	    write_ent_proc (node, NULL);

	    if (fclose (entfile) == EOF)
		error (1, errno, "error closing %s", entfilename);
	}

	delnode (node);			/* delete the node */

#ifdef SERVER_SUPPORT
	if (server_active)
	    server_scratch (fname);
#endif
    }
}

/*
 * Enters the given file name/version/time-stamp into the Entries file,
 * removing the old entry first, if necessary.
 */
void
Register (list, fname, vn, ts, options, tag, date, ts_conflict)
    List *list;
    char *fname;
    char *vn;
    char *ts;
    char *options;
    char *tag;
    char *date;
    char *ts_conflict;
{
    Entnode *entnode;
    Node *node;

#ifdef SERVER_SUPPORT
    if (server_active)
    {
	server_register (fname, vn, ts, options, tag, date, ts_conflict);
    }
#endif

    if (trace)
    {
	(void) fprintf (stderr, "%s-> Register(%s, %s, %s%s%s, %s, %s %s)\n",
			CLIENT_SERVER_STR,
			fname, vn, ts ? ts : "",
			ts_conflict ? "+" : "", ts_conflict ? ts_conflict : "",
			options, tag ? tag : "", date ? date : "");
    }

    entnode = Entnode_Create (ENT_FILE, fname, vn, ts, options, tag, date,
			      ts_conflict);
    node = AddEntryNode (list, entnode);

    if (!noexec)
    {
	entfilename = CVSADM_ENTLOG;
	entfile = CVS_FOPEN (entfilename, "a");

	if (entfile == NULL)
	{
	    /* Warning, not error, as in write_entries.  */
	    /* FIXME-update-dir: should be including update_dir in message.  */
	    error (0, errno, "cannot open %s", entfilename);
	    return;
	}

	if (fprintf (entfile, "A ") < 0)
	    error (1, errno, "cannot write %s", entfilename);

	write_ent_proc (node, NULL);

        if (fclose (entfile) == EOF)
	    error (1, errno, "error closing %s", entfilename);
    }
}

/*
 * Node delete procedure for list-private sticky dir tag/date info
 */
static void
freesdt (p)
    Node *p;
{
    struct stickydirtag *sdtp;

    sdtp = (struct stickydirtag *) p->data;
    if (sdtp->tag)
	free (sdtp->tag);
    if (sdtp->date)
	free (sdtp->date);
    free ((char *) sdtp);
}

/* Return the next real Entries line.  On end of file, returns NULL.
   On error, prints an error message and returns NULL.  */

static Entnode *
fgetentent(fpin, cmd, sawdir)
    FILE *fpin;
    char *cmd;
    int *sawdir;
{
    Entnode *ent;
    char *line;
    size_t line_chars_allocated;
    register char *cp;
    enum ent_type type;
    char *l, *user, *vn, *ts, *options;
    char *tag_or_date, *tag, *date, *ts_conflict;
    int line_length;

    line = NULL;
    line_chars_allocated = 0;

    ent = NULL;
    while ((line_length = get_line (&line, &line_chars_allocated, fpin)) > 0)
    {
	l = line;

	/* If CMD is not NULL, we are reading an Entries.Log file.
	   Each line in the Entries.Log file starts with a single
	   character command followed by a space.  For backward
	   compatibility, the absence of a space indicates an add
	   command.  */
	if (cmd != NULL)
	{
	    if (l[1] != ' ')
		*cmd = 'A';
	    else
	    {
		*cmd = l[0];
		l += 2;
	    }
	}

	type = ENT_FILE;

	if (l[0] == 'D')
	{
	    type = ENT_SUBDIR;
	    *sawdir = 1;
	    ++l;
	    /* An empty D line is permitted; it is a signal that this
	       Entries file lists all known subdirectories.  */
	}

	if (l[0] != '/')
	    continue;

	user = l + 1;
	if ((cp = strchr (user, '/')) == NULL)
	    continue;
	*cp++ = '\0';
	vn = cp;
	if ((cp = strchr (vn, '/')) == NULL)
	    continue;
	*cp++ = '\0';
	ts = cp;
	if ((cp = strchr (ts, '/')) == NULL)
	    continue;
	*cp++ = '\0';
	options = cp;
	if ((cp = strchr (options, '/')) == NULL)
	    continue;
	*cp++ = '\0';
	tag_or_date = cp;
	if ((cp = strchr (tag_or_date, '\n')) == NULL)
	    continue;
	*cp = '\0';
	tag = (char *) NULL;
	date = (char *) NULL;
	if (*tag_or_date == 'T')
	    tag = tag_or_date + 1;
	else if (*tag_or_date == 'D')
	    date = tag_or_date + 1;

	if ((ts_conflict = strchr (ts, '+')))
	    *ts_conflict++ = '\0';
	    
	/*
	 * XXX - Convert timestamp from old format to new format.
	 *
	 * If the timestamp doesn't match the file's current
	 * mtime, we'd have to generate a string that doesn't
	 * match anyways, so cheat and base it on the existing
	 * string; it doesn't have to match the same mod time.
	 *
	 * For an unmodified file, write the correct timestamp.
	 */
	{
	    struct stat sb;
	    if (strlen (ts) > 30 && CVS_STAT (user, &sb) == 0)
	    {
		char *c = ctime (&sb.st_mtime);
		/* Fix non-standard format.  */
		if (c[8] == '0') c[8] = ' ';

		if (!strncmp (ts + 25, c, 24))
		    ts = time_stamp (user);
		else
		{
		    ts += 24;
		    ts[0] = '*';
		}
	    }
	}

	ent = Entnode_Create (type, user, vn, ts, options, tag, date,
			      ts_conflict);
	break;
    }

    if (line_length < 0 && !feof (fpin))
	error (0, errno, "cannot read entries file");

    free (line);
    return ent;
}

static int
fputentent(fp, p)
    FILE *fp;
    Entnode *p;
{
    switch (p->type)
    {
    case ENT_FILE:
        break;
    case ENT_SUBDIR:
        if (fprintf (fp, "D") < 0)
	    return 1;
	break;
    }

    if (fprintf (fp, "/%s/%s/%s", p->user, p->version, p->timestamp) < 0)
	return 1;
    if (p->conflict)
    {
	if (fprintf (fp, "+%s", p->conflict) < 0)
	    return 1;
    }
    if (fprintf (fp, "/%s/", p->options) < 0)
	return 1;

    if (p->tag)
    {
	if (fprintf (fp, "T%s\n", p->tag) < 0)
	    return 1;
    }
    else if (p->date)
    {
	if (fprintf (fp, "D%s\n", p->date) < 0)
	    return 1;
    }
    else 
    {
	if (fprintf (fp, "\n") < 0)
	    return 1;
    }

    return 0;
}


/* Read the entries file into a list, hashing on the file name.

   UPDATE_DIR is the name of the current directory, for use in error
   messages, or NULL if not known (that is, noone has gotten around
   to updating the caller to pass in the information).  */
List *
Entries_Open (aflag, update_dir)
    int aflag;
    char *update_dir;
{
    List *entries;
    struct stickydirtag *sdtp = NULL;
    Entnode *ent;
    char *dirtag, *dirdate;
    int dirnonbranch;
    int do_rewrite = 0;
    FILE *fpin;
    int sawdir;

    /* get a fresh list... */
    entries = getlist ();

    /*
     * Parse the CVS/Tag file, to get any default tag/date settings. Use
     * list-private storage to tuck them away for Version_TS().
     */
    ParseTag (&dirtag, &dirdate, &dirnonbranch);
    if (aflag || dirtag || dirdate)
    {
	sdtp = (struct stickydirtag *) xmalloc (sizeof (*sdtp));
	memset ((char *) sdtp, 0, sizeof (*sdtp));
	sdtp->aflag = aflag;
	sdtp->tag = xstrdup (dirtag);
	sdtp->date = xstrdup (dirdate);
	sdtp->nonbranch = dirnonbranch;

	/* feed it into the list-private area */
	entries->list->data = (char *) sdtp;
	entries->list->delproc = freesdt;
    }

    sawdir = 0;

    fpin = CVS_FOPEN (CVSADM_ENT, "r");
    if (fpin == NULL)
    {
	if (update_dir != NULL)
	    error (0, 0, "in directory %s:", update_dir);
	error (0, errno, "cannot open %s for reading", CVSADM_ENT);
    }
    else
    {
	while ((ent = fgetentent (fpin, (char *) NULL, &sawdir)) != NULL) 
	{
	    (void) AddEntryNode (entries, ent);
	}

	if (fclose (fpin) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_ENT);
    }

    fpin = CVS_FOPEN (CVSADM_ENTLOG, "r");
    if (fpin != NULL) 
    {
	char cmd;
	Node *node;

	while ((ent = fgetentent (fpin, &cmd, &sawdir)) != NULL)
	{
	    switch (cmd)
	    {
	    case 'A':
		(void) AddEntryNode (entries, ent);
		break;
	    case 'R':
		node = findnode_fn (entries, ent->user);
		if (node != NULL)
		    delnode (node);
		Entnode_Destroy (ent);
		break;
	    default:
		/* Ignore unrecognized commands.  */
	        break;
	    }
	}
	do_rewrite = 1;
	if (fclose (fpin) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_ENTLOG);
    }

    /* Update the list private data to indicate whether subdirectory
       information is known.  Nonexistent list private data is taken
       to mean that it is known.  */
    if (sdtp != NULL)
	sdtp->subdirs = sawdir;
    else if (! sawdir)
    {
	sdtp = (struct stickydirtag *) xmalloc (sizeof (*sdtp));
	memset ((char *) sdtp, 0, sizeof (*sdtp));
	sdtp->subdirs = 0;
	entries->list->data = (char *) sdtp;
	entries->list->delproc = freesdt;
    }

    if (do_rewrite && !noexec)
	write_entries (entries);

    /* clean up and return */
    if (dirtag)
	free (dirtag);
    if (dirdate)
	free (dirdate);
    return (entries);
}

void
Entries_Close(list)
    List *list;
{
    if (list)
    {
	if (!noexec) 
        {
            if (isfile (CVSADM_ENTLOG))
		write_entries (list);
	}
	dellist(&list);
    }
}


/*
 * Free up the memory associated with the data section of an ENTRIES type
 * node
 */
static void
Entries_delproc (node)
    Node *node;
{
    Entnode *p;

    p = (Entnode *) node->data;
    Entnode_Destroy(p);
}

/*
 * Get an Entries file list node, initialize it, and add it to the specified
 * list
 */
static Node *
AddEntryNode (list, entdata)
    List *list;
    Entnode *entdata;
{
    Node *p;

    /* was it already there? */
    if ((p  = findnode_fn (list, entdata->user)) != NULL)
    {
	/* take it out */
	delnode (p);
    }

    /* get a node and fill in the regular stuff */
    p = getnode ();
    p->type = ENTRIES;
    p->delproc = Entries_delproc;

    /* this one gets a key of the name for hashing */
    /* FIXME This results in duplicated data --- the hash package shouldn't
       assume that the key is dynamically allocated.  The user's free proc
       should be responsible for freeing the key. */
    p->key = xstrdup (entdata->user);
    p->data = (char *) entdata;

    /* put the node into the list */
    addnode (list, p);
    return (p);
}

/*
 * Write out/Clear the CVS/Tag file.
 */
void
WriteTag (dir, tag, date, nonbranch, update_dir, repository)
    char *dir;
    char *tag;
    char *date;
    int nonbranch;
    char *update_dir;
    char *repository;
{
    FILE *fout;
    char *tmp;

    if (noexec)
	return;

    tmp = xmalloc ((dir ? strlen (dir) : 0)
		   + sizeof (CVSADM_TAG)
		   + 10);
    if (dir == NULL)
	(void) strcpy (tmp, CVSADM_TAG);
    else
	(void) sprintf (tmp, "%s/%s", dir, CVSADM_TAG);

    if (tag || date)
    {
	fout = open_file (tmp, "w+");
	if (tag)
	{
	    if (nonbranch)
	    {
		if (fprintf (fout, "N%s\n", tag) < 0)
		    error (1, errno, "write to %s failed", tmp);
	    }
	    else
	    {
		if (fprintf (fout, "T%s\n", tag) < 0)
		    error (1, errno, "write to %s failed", tmp);
	    }
	}
	else
	{
	    if (fprintf (fout, "D%s\n", date) < 0)
		error (1, errno, "write to %s failed", tmp);
	}
	if (fclose (fout) == EOF)
	    error (1, errno, "cannot close %s", tmp);
    }
    else
	if (unlink_file (tmp) < 0 && ! existence_error (errno))
	    error (1, errno, "cannot remove %s", tmp);
    free (tmp);
#ifdef SERVER_SUPPORT
    if (server_active)
	server_set_sticky (update_dir, repository, tag, date, nonbranch);
#endif
}

/* Parse the CVS/Tag file for the current directory.

   If it contains a date, sets *DATEP to the date in a newly malloc'd
   string, *TAGP to NULL, and *NONBRANCHP to an unspecified value.

   If it contains a branch tag, sets *TAGP to the tag in a newly
   malloc'd string, *NONBRANCHP to 0, and *DATEP to NULL.

   If it contains a nonbranch tag, sets *TAGP to the tag in a newly
   malloc'd string, *NONBRANCHP to 1, and *DATEP to NULL.

   If it does not exist, or contains something unrecognized by this
   version of CVS, set *DATEP and *TAGP to NULL and *NONBRANCHP to
   an unspecified value.

   If there is an error, print an error message, set *DATEP and *TAGP
   to NULL, and return.  */
void
ParseTag (tagp, datep, nonbranchp)
    char **tagp;
    char **datep;
    int *nonbranchp;
{
    FILE *fp;

    if (tagp)
	*tagp = (char *) NULL;
    if (datep)
	*datep = (char *) NULL;
    /* Always store a value here, even in the 'D' case where the value
       is unspecified.  Shuts up tools which check for references to
       uninitialized memory.  */
    if (nonbranchp != NULL)
	*nonbranchp = 0;
    fp = CVS_FOPEN (CVSADM_TAG, "r");
    if (fp)
    {
	char *line;
	int line_length;
	size_t line_chars_allocated;

	line = NULL;
	line_chars_allocated = 0;

	if ((line_length = get_line (&line, &line_chars_allocated, fp)) > 0)
	{
	    /* Remove any trailing newline.  */
	    if (line[line_length - 1] == '\n')
	        line[--line_length] = '\0';
	    switch (*line)
	    {
		case 'T':
		    if (tagp != NULL)
			*tagp = xstrdup (line + 1);
		    break;
		case 'D':
		    if (datep != NULL)
			*datep = xstrdup (line + 1);
		    break;
		case 'N':
		    if (tagp != NULL)
			*tagp = xstrdup (line + 1);
		    if (nonbranchp != NULL)
			*nonbranchp = 1;
		    break;
		default:
		    /* Silently ignore it; it may have been
		       written by a future version of CVS which extends the
		       syntax.  */
		    break;
	    }
	}

	if (line_length < 0)
	{
	    /* FIXME-update-dir: should include update_dir in messages.  */
	    if (feof (fp))
		error (0, 0, "cannot read %s: end of file", CVSADM_TAG);
	    else
		error (0, errno, "cannot read %s", CVSADM_TAG);
	}

	if (fclose (fp) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_TAG);

	free (line);
    }
    else if (!existence_error (errno))
	/* FIXME-update-dir: should include update_dir in message.  */
	error (0, errno, "cannot open %s", CVSADM_TAG);
}

/*
 * This is called if all subdirectory information is known, but there
 * aren't any subdirectories.  It records that fact in the list
 * private data.
 */

void
Subdirs_Known (entries)
     List *entries;
{
    struct stickydirtag *sdtp;

    /* If there is no list private data, that means that the
       subdirectory information is known.  */
    sdtp = (struct stickydirtag *) entries->list->data;
    if (sdtp != NULL && ! sdtp->subdirs)
    {
	FILE *fp;

	sdtp->subdirs = 1;
	if (!noexec)
	{
	    /* Create Entries.Log so that Entries_Close will do something.  */
	    entfilename = CVSADM_ENTLOG;
	    fp = CVS_FOPEN (entfilename, "a");
	    if (fp == NULL)
	    {
		int save_errno = errno;

		/* As in subdir_record, just silently skip the whole thing
		   if there is no CVSADM directory.  */
		if (! isdir (CVSADM))
		    return;
		error (1, save_errno, "cannot open %s", entfilename);
	    }
	    else
	    {
		if (fclose (fp) == EOF)
		    error (1, errno, "cannot close %s", entfilename);
	    }
	}
    }
}

/* Record subdirectory information.  */

static Entnode *
subdir_record (cmd, parent, dir)
     int cmd;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    /* None of the information associated with a directory is
       currently meaningful.  */
    entnode = Entnode_Create (ENT_SUBDIR, dir, "", "", "",
			      (char *) NULL, (char *) NULL,
			      (char *) NULL);

    if (!noexec)
    {
	if (parent == NULL)
	    entfilename = CVSADM_ENTLOG;
	else
	{
	    entfilename = xmalloc (strlen (parent)
				   + sizeof CVSADM_ENTLOG
				   + 10);
	    sprintf (entfilename, "%s/%s", parent, CVSADM_ENTLOG);
	}

	entfile = CVS_FOPEN (entfilename, "a");
	if (entfile == NULL)
	{
	    int save_errno = errno;

	    /* It is not an error if there is no CVS administration
               directory.  Permitting this case simplifies some
               calling code.  */

	    if (parent == NULL)
	    {
		if (! isdir (CVSADM))
		    return entnode;
	    }
	    else
	    {
		sprintf (entfilename, "%s/%s", parent, CVSADM);
		if (! isdir (entfilename))
		{
		    free (entfilename);
		    entfilename = NULL;
		    return entnode;
		}
	    }

	    error (1, save_errno, "cannot open %s", entfilename);
	}

	if (fprintf (entfile, "%c ", cmd) < 0)
	    error (1, errno, "cannot write %s", entfilename);

	if (fputentent (entfile, entnode) != 0)
	    error (1, errno, "cannot write %s", entfilename);

	if (fclose (entfile) == EOF)
	    error (1, errno, "error closing %s", entfilename);

	if (parent != NULL)
	{
	    free (entfilename);
	    entfilename = NULL;
	}
    }

    return entnode;
}

/*
 * Record the addition of a new subdirectory DIR in PARENT.  PARENT
 * may be NULL, which means the current directory.  ENTRIES is the
 * current entries list; it may be NULL, which means that it need not
 * be updated.
 */

void
Subdir_Register (entries, parent, dir)
     List *entries;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    /* Ignore attempts to register ".".  These can happen in the
       server code.  */
    if (dir[0] == '.' && dir[1] == '\0')
	return;

    entnode = subdir_record ('A', parent, dir);

    if (entries != NULL && (parent == NULL || strcmp (parent, ".") == 0))
	(void) AddEntryNode (entries, entnode);
    else
	Entnode_Destroy (entnode);
}

/*
 * Record the removal of a subdirectory.  The arguments are the same
 * as for Subdir_Register.
 */

void
Subdir_Deregister (entries, parent, dir)
     List *entries;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    entnode = subdir_record ('R', parent, dir);
    Entnode_Destroy (entnode);

    if (entries != NULL && (parent == NULL || strcmp (parent, ".") == 0))
    {
	Node *p;

	p = findnode_fn (entries, dir);
	if (p != NULL)
	    delnode (p);
    }
}



/* OK, the following base_* code tracks the revisions of the files in
   CVS/Base.  We do this in a file CVS/Baserev.  Separate from
   CVS/Entries because it needs to go in separate data structures
   anyway (the name in Entries must be unique), so this seemed
   cleaner.  The business of rewriting the whole file in
   base_deregister and base_register is the kind of thing we used to
   do for Entries and which turned out to be slow, which is why there
   is now the Entries.Log machinery.  So maybe from that point of
   view it is a mistake to do this separately from Entries, I dunno.

   We also need something analogous for:

   1. CVS/Template (so we can update the Template file automagically
   without the user needing to check out a new working directory).
   Updating would probably print a message (that part might be
   optional, although probably it should be visible because not all
   cvs commands would make the update happen and so it is a
   user-visible behavior).  Constructing version number for template
   is a bit hairy (base it on the timestamp on the server?  Or see if
   the template is in checkoutlist and if yes use its versioning and
   if no don't version it?)....

   2.  cvsignore (need to keep a copy in the working directory to do
   "cvs release" on the client side; see comment at src/release.c
   (release).  Would also allow us to stop needing Questionable.  */

enum base_walk {
    /* Set the revision for FILE to *REV.  */
    BASE_REGISTER,
    /* Get the revision for FILE and put it in a newly malloc'd string
       in *REV, or put NULL if not mentioned.  */
    BASE_GET,
    /* Remove FILE.  */
    BASE_DEREGISTER
};

static void base_walk PROTO ((enum base_walk, struct file_info *, char **));

/* Read through the lines in CVS/Baserev, taking the actions as documented
   for CODE.  */

static void
base_walk (code, finfo, rev)
    enum base_walk code;
    struct file_info *finfo;
    char **rev;
{
    FILE *fp;
    char *line;
    size_t line_allocated;
    FILE *newf;
    char *baserev_fullname;
    char *baserevtmp_fullname;

    line = NULL;
    line_allocated = 0;
    newf = NULL;

    /* First compute the fullnames for the error messages.  This
       computation probably should be broken out into a separate function,
       as recurse.c does it too and places like Entries_Open should be
       doing it.  */
    baserev_fullname = xmalloc (sizeof (CVSADM_BASEREV)
				+ strlen (finfo->update_dir)
				+ 2);
    baserev_fullname[0] = '\0';
    baserevtmp_fullname = xmalloc (sizeof (CVSADM_BASEREVTMP)
				   + strlen (finfo->update_dir)
				   + 2);
    baserevtmp_fullname[0] = '\0';
    if (finfo->update_dir[0] != '\0')
    {
	strcat (baserev_fullname, finfo->update_dir);
	strcat (baserev_fullname, "/");
	strcat (baserevtmp_fullname, finfo->update_dir);
	strcat (baserevtmp_fullname, "/");
    }
    strcat (baserev_fullname, CVSADM_BASEREV);
    strcat (baserevtmp_fullname, CVSADM_BASEREVTMP);

    fp = CVS_FOPEN (CVSADM_BASEREV, "r");
    if (fp == NULL)
    {
	if (!existence_error (errno))
	{
	    error (0, errno, "cannot open %s for reading", baserev_fullname);
	    goto out;
	}
    }

    switch (code)
    {
	case BASE_REGISTER:
	case BASE_DEREGISTER:
	    newf = CVS_FOPEN (CVSADM_BASEREVTMP, "w");
	    if (newf == NULL)
	    {
		error (0, errno, "cannot open %s for writing",
		       baserevtmp_fullname);
		goto out;
	    }
	    break;
	case BASE_GET:
	    *rev = NULL;
	    break;
    }

    if (fp != NULL)
    {
	while (get_line (&line, &line_allocated, fp) >= 0)
	{
	    char *linefile;
	    char *p;
	    char *linerev;

	    if (line[0] != 'B')
		/* Ignore, for future expansion.  */
		continue;

	    linefile = line + 1;
	    p = strchr (linefile, '/');
	    if (p == NULL)
		/* Syntax error, ignore.  */
		continue;
	    linerev = p + 1;
	    p = strchr (linerev, '/');
	    if (p == NULL)
		continue;

	    linerev[-1] = '\0';
	    if (fncmp (linefile, finfo->file) == 0)
	    {
		switch (code)
		{
		case BASE_REGISTER:
		case BASE_DEREGISTER:
		    /* Don't copy over the old entry, we don't want it.  */
		    break;
		case BASE_GET:
		    *p = '\0';
		    *rev = xstrdup (linerev);
		    *p = '/';
		    goto got_it;
		}
	    }
	    else
	    {
		linerev[-1] = '/';
		switch (code)
		{
		case BASE_REGISTER:
		case BASE_DEREGISTER:
		    if (fprintf (newf, "%s\n", line) < 0)
			error (0, errno, "error writing %s",
			       baserevtmp_fullname);
		    break;
		case BASE_GET:
		    break;
		}
	    }
	}
	if (ferror (fp))
	    error (0, errno, "cannot read %s", baserev_fullname);
    }
 got_it:

    if (code == BASE_REGISTER)
    {
	if (fprintf (newf, "B%s/%s/\n", finfo->file, *rev) < 0)
	    error (0, errno, "error writing %s",
		   baserevtmp_fullname);
    }

 out:

    if (line != NULL)
	free (line);

    if (fp != NULL)
    {
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", baserev_fullname);
    }
    if (newf != NULL)
    {
	if (fclose (newf) < 0)
	    error (0, errno, "cannot close %s", baserevtmp_fullname);
	rename_file (CVSADM_BASEREVTMP, CVSADM_BASEREV);
    }

    free (baserev_fullname);
    free (baserevtmp_fullname);
}

/* Return, in a newly malloc'd string, the revision for FILE in CVS/Baserev,
   or NULL if not listed.  */

char *
base_get (finfo)
    struct file_info *finfo;
{
    char *rev;
    base_walk (BASE_GET, finfo, &rev);
    return rev;
}

/* Set the revision for FILE to REV.  */

void
base_register (finfo, rev)
    struct file_info *finfo;
    char *rev;
{
    base_walk (BASE_REGISTER, finfo, &rev);
}

/* Remove FILE.  */

void
base_deregister (finfo)
    struct file_info *finfo;
{
    base_walk (BASE_DEREGISTER, finfo, NULL);
}
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d15 1
d17 4
a20 4
#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)entries.c 1.44 94/10/07 $";
USE(rcsid);
#endif
d22 1
a22 3
static Node *AddEntryNode PROTO((List * list, char *name, char *version,
			   char *timestamp, char *options, char *tag,
			   char *date, char *conflict));
d28 57
d93 6
a98 1
    Entnode *p;
d100 1
a100 10
    p = (Entnode *) node->data;
    if (fprintf (entfile, "/%s/%s/%s", node->key, p->version,
		 p->timestamp) == EOF)
	error (1, errno, "cannot write %s", entfilename);
    if (p->conflict)
    {
	if (fprintf (entfile, "+%s", p->conflict) < 0)
	    error (1, errno, "cannot write %s", entfilename);
    }
    if (fprintf (entfile, "/%s/", p->options) < 0)
a102 12
    if (p->tag)
    {
	if (fprintf (entfile, "T%s\n", p->tag) < 0)
	    error (1, errno, "cannot write %s", entfilename);
    }
    else if (p->date)
    {
	if (fprintf (entfile, "D%s\n", p->date) < 0)
	    error (1, errno, "cannot write %s", entfilename);
    }
    else if (fprintf (entfile, "\n") < 0)
	error (1, errno, "cannot write %s", entfilename);
d114 4
d120 33
a152 2
    entfile = open_file (entfilename, "w+");
    (void) walklist (list, write_ent_proc, NULL);
d160 3
a162 1
    unlink_file (CVSADM_ENTLOG);
d176 2
a177 6
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> Scratch_Entry(%s)\n",
			(server_active) ? 'S' : ' ', fname);
#else
	(void) fprintf (stderr, "-> Scratch_Entry(%s)\n", fname);
#endif
d180 1
a180 1
    if ((node = findnode (list, fname)) != NULL)
d182 14
d197 1
a201 2
	if (!noexec)
	    write_entries (list);	/* re-write the file */
d220 1
d232 2
a233 8
#ifdef SERVER_SUPPORT
	(void) fprintf (stderr, "%c-> Register(%s, %s, %s%s%s, %s, %s %s)\n",
			(server_active) ? 'S' : ' ',
			fname, vn, ts ? ts : "",
			ts_conflict ? "+" : "", ts_conflict ? ts_conflict : "",
			options, tag ? tag : "", date ? date : "");
#else
	(void) fprintf (stderr, "-> Register(%s, %s, %s%s%s, %s, %s %s)\n",
a236 1
#endif
d239 3
a241 1
    node = AddEntryNode (list, fname, vn, ts, options, tag, date, ts_conflict);
d245 14
a258 2
	entfile = open_file (CVSADM_ENTLOG, "a");
	
d262 1
a262 1
            error (1, errno, "error closing %s", CVSADM_ENTLOG);
a279 2
    if (sdtp->options)
	free (sdtp->options);
d283 2
a284 9
struct entent {
    char *user;
    char *vn;
    char *ts;
    char *options;
    char *tag;
    char *date;
    char *ts_conflict;
};
d286 2
a287 2
struct entent *
fgetentent(fpin)
d289 2
d292 3
a294 2
    static struct entent ent;
    static char line[MAXLINELEN];
d296 2
a297 1
    char *user, *vn, *ts, *options;
d299 1
d301 5
a305 1
    while (fgets (line, sizeof (line), fpin) != NULL)
d307 30
a336 1
	if (line[0] != '/')
d339 1
a339 1
	user = line + 1;
d365 1
a365 1
	
d381 1
a381 1
	    if (strlen (ts) > 30 && stat (user, &sb) == 0)
a382 1
		extern char *ctime ();
d384 3
a386 1
		
d397 36
a432 7
	ent.user = user;
	ent.vn = vn;
	ent.ts = ts;
	ent.options = options;
	ent.tag = tag;
	ent.date = date;
	ent.ts_conflict = ts_conflict;
d434 14
a447 1
	return &ent;
d450 1
a450 1
    return NULL;
d454 5
a458 3
/*
 * Read the entries file into a list, hashing on the file name.
 */
d460 1
a460 1
Entries_Open (aflag)
d462 1
d465 2
a466 1
    struct entent *ent;
d468 1
d471 1
d480 1
a480 1
    ParseTag (&dirtag, &dirdate);
a482 2
	struct stickydirtag *sdtp;

d488 1
d495 3
a497 1
    fpin = fopen (CVSADM_ENT, "r");
d499 3
d503 1
d506 17
a522 1
	while ((ent = fgetentent (fpin)) != NULL) 
d524 15
a538 25
	    (void) AddEntryNode (entries, 
				 ent->user,
				 ent->vn,
				 ent->ts,
				 ent->options,
				 ent->tag,
				 ent->date,
				 ent->ts_conflict);
	}

	fclose (fpin);
    }

    fpin = fopen (CVSADM_ENTLOG, "r");
    if (fpin != NULL) {
	while ((ent = fgetentent (fpin)) != NULL) 
	{
	    (void) AddEntryNode (entries, 
				 ent->user,
				 ent->vn,
				 ent->ts,
				 ent->options,
				 ent->tag,
				 ent->date,
				 ent->ts_conflict);
d541 17
a557 1
	fclose (fpin);
a563 2
    if (fpin)
	(void) fclose (fpin);
d598 1
a598 10
    free (p->version);
    free (p->timestamp);
    free (p->options);
    if (p->tag)
	free (p->tag);
    if (p->date)
	free (p->date);
    if (p->conflict)
	free (p->conflict);
    free ((char *) p);
d606 1
a606 1
AddEntryNode (list, name, version, timestamp, options, tag, date, conflict)
d608 1
a608 7
    char *name;
    char *version;
    char *timestamp;
    char *options;
    char *tag;
    char *date;
    char *conflict;
a610 1
    Entnode *entdata;
d613 1
a613 1
    if ((p  = findnode (list, name)) != NULL)
d625 5
a629 15
    p->key = xstrdup (name);

    /* malloc the data parts and fill them in */
    p->data = xmalloc (sizeof (Entnode));
    entdata = (Entnode *) p->data;
    entdata->version = xstrdup (version);
    entdata->timestamp = xstrdup (timestamp);
    if (entdata->timestamp == NULL)
       entdata->timestamp = xstrdup ("");/* must be non-NULL */
    entdata->options = xstrdup (options);
    if (entdata->options == NULL)
	entdata->options = xstrdup ("");/* must be non-NULL */
    entdata->conflict = xstrdup (conflict);
    entdata->tag = xstrdup (tag);
    entdata->date = xstrdup (date);
d640 1
a640 1
WriteTag (dir, tag, date)
d644 3
d649 1
a649 1
    char tmp[PATH_MAX];
d654 3
d667 10
a676 2
	    if (fprintf (fout, "T%s\n", tag) < 0)
		error (1, errno, "write to %s failed", tmp);
d687 1
a687 1
	if (unlink_file (tmp) < 0 && errno != ENOENT)
d689 5
d696 17
a712 3
/*
 * Parse the CVS/Tag file for the current directory.
 */
d714 1
a714 1
ParseTag (tagp, datep)
d717 1
a719 2
    char line[MAXLINELEN];
    char *cp;
d725 6
a730 1
    fp = fopen (CVSADM_TAG, "r");
d733 166
a898 1
	if (fgets (line, sizeof (line), fp) != NULL)
d900 2
a901 6
	    if ((cp = strrchr (line, '\n')) != NULL)
		*cp = '\0';
	    if (*line == 'T' && tagp)
		*tagp = xstrdup (line + 1);
	    else if (*line == 'D' && datep)
		*datep = xstrdup (line + 1);
a902 1
	(void) fclose (fp);
d904 283
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a14 1
#include "getline.h"
d21 3
a23 4
static Node *AddEntryNode PROTO((List * list, Entnode *entnode));

static Entnode *fgetentent PROTO((FILE *));
static int   fputentent PROTO((FILE *, Entnode *));
a28 48
 * Construct an Entnode
 */
Entnode *
Entnode_Create(user, vn, ts, options, tag, date, ts_conflict)
    const char *user;
    const char *vn;
    const char *ts;
    const char *options;
    const char *tag;
    const char *date;
    const char *ts_conflict;
{
    Entnode *ent;
    
    /* Note that timestamp and options must be non-NULL */
    ent = (Entnode *) xmalloc (sizeof (Entnode));
    ent->user      = xstrdup (user);
    ent->version   = xstrdup (vn);
    ent->timestamp = xstrdup (ts ? ts : "");
    ent->options   = xstrdup (options ? options : "");
    ent->tag       = xstrdup (tag);
    ent->date      = xstrdup (date);
    ent->conflict  = xstrdup (ts_conflict);

    return ent;
}

/*
 * Destruct an Entnode
 */
void
Entnode_Destroy (ent)
    Entnode *ent;
{
    free (ent->user);
    free (ent->version);
    free (ent->timestamp);
    free (ent->options);
    if (ent->tag)
	free (ent->tag);
    if (ent->date)
	free (ent->date);
    if (ent->conflict)
	free (ent->conflict);
    free (ent);
}

/*
d37 12
a48 1
    if (fputentent(entfile, (Entnode *) node->data))
d51 12
a133 1
    Entnode *entnode;
d159 1
a159 2
    entnode = Entnode_Create(fname, vn, ts, options, tag, date, ts_conflict);
    node = AddEntryNode (list, entnode);
d191 11
a201 1
static Entnode *
d205 2
a206 3
    Entnode *ent;
    char *line;
    size_t line_chars_allocated;
d211 1
a211 5
    line = NULL;
    line_chars_allocated = 0;

    ent = NULL;
    while (getline (&line, &line_chars_allocated, fpin) > 0)
d260 1
d273 7
a279 7
	ent = Entnode_Create(user, vn, ts, options, tag, date, ts_conflict);
	break;
    }

    free (line);
    return ent;
}
d281 1
a281 29
static int
fputentent(fp, p)
    FILE *fp;
    Entnode *p;
{
    if (fprintf (fp, "/%s/%s/%s", p->user, p->version, p->timestamp) < 0)
	return 1;
    if (p->conflict)
    {
	if (fprintf (fp, "+%s", p->conflict) < 0)
	    return 1;
    }
    if (fprintf (fp, "/%s/", p->options) < 0)
	return 1;

    if (p->tag)
    {
	if (fprintf (fp, "T%s\n", p->tag) < 0)
	    return 1;
    }
    else if (p->date)
    {
	if (fprintf (fp, "D%s\n", p->date) < 0)
	    return 1;
    }
    else 
    {
	if (fprintf (fp, "\n") < 0)
	    return 1;
d284 1
a284 1
    return 0;
d296 1
a296 1
    Entnode *ent;
d331 8
a338 1
	    (void) AddEntryNode (entries, ent);
d345 1
a345 2
    if (fpin != NULL) 
    {
d348 8
a355 1
	    (void) AddEntryNode (entries, ent);
d365 2
d401 10
a410 1
    Entnode_Destroy(p);
d418 1
a418 1
AddEntryNode (list, entdata)
d420 7
a426 1
    Entnode *entdata;
d429 1
d432 1
a432 1
    if ((p  = findnode (list, entdata->user)) != NULL)
d444 15
a458 5
    /* FIXME This results in duplicated data --- the hash package shouldn't
       assume that the key is dynamically allocated.  The user's free proc
       should be responsible for freeing the key. */
    p->key = xstrdup (entdata->user);
    p->data = (char *) entdata;
d502 1
a502 1
	if (unlink_file (tmp) < 0 && ! existence_error (errno))
d515 2
d525 1
a525 8
	char *line;
	int line_length;
	size_t line_chars_allocated;

	line = NULL;
	line_chars_allocated = 0;
	  
	if ((line_length = getline (&line, &line_chars_allocated, fp)) > 0)
d527 2
a528 3
	    /* Remove any trailing newline.  */
	    if (line[line_length - 1] == '\n')
	        line[--line_length] = '\0';
a534 1
	free (line);
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d17 5
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d129 1
a129 1
    if ((node = findnode_fn (list, fname)) != NULL)
d447 1
a447 1
    if ((p  = findnode_fn (list, entdata->user)) != NULL)
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d19 1
a19 1
static Entnode *fgetentent PROTO((FILE *, char *, int *));
a21 2
static Entnode *subdir_record PROTO((int, const char *, const char *));

d29 1
a29 2
Entnode_Create(type, user, vn, ts, options, tag, date, ts_conflict)
    enum ent_type type;
a41 1
    ent->type      = type;
d82 1
a82 8
    Entnode *entnode;

    entnode = (Entnode *) node->data;

    if (closure != NULL && entnode->type != ENT_FILE)
	*(int *) closure = 1;

    if (fputentent(entfile, entnode))
a95 4
    int sawdir;

    sawdir = 0;

d99 1
a99 13
    (void) walklist (list, write_ent_proc, (void *) &sawdir);
    if (! sawdir)
    {
	struct stickydirtag *sdtp;

	/* We didn't write out any directories.  Check the list
           private data to see whether subdirectory information is
           known.  If it is, we need to write out an empty D line.  */
	sdtp = (struct stickydirtag *) list->list->data;
	if (sdtp == NULL || sdtp->subdirs)
	    if (fprintf (entfile, "D\n") < 0)
		error (1, errno, "cannot write %s", entfilename);
    }
a130 14
	if (!noexec)
	{
	    entfilename = CVSADM_ENTLOG;
	    entfile = open_file (entfilename, "a");

	    if (fprintf (entfile, "R ") < 0)
		error (1, errno, "cannot write %s", entfilename);

	    write_ent_proc (node, NULL);

	    if (fclose (entfile) == EOF)
		error (1, errno, "error closing %s", entfilename);
	}

a131 1

d136 2
d182 1
a182 2
    entnode = Entnode_Create (ENT_FILE, fname, vn, ts, options, tag, date,
			      ts_conflict);
d187 2
a188 6
	entfilename = CVSADM_ENTLOG;
	entfile = open_file (entfilename, "a");

	if (fprintf (entfile, "A ") < 0)
	    error (1, errno, "cannot write %s", entfilename);

d192 1
a192 1
	    error (1, errno, "error closing %s", entfilename);
d210 2
d216 1
a216 1
fgetentent(fpin, cmd, sawdir)
a217 2
    char *cmd;
    int *sawdir;
d223 1
a223 2
    enum ent_type type;
    char *l, *user, *vn, *ts, *options;
d232 1
a232 30
	l = line;

	/* If CMD is not NULL, we are reading an Entries.Log file.
	   Each line in the Entries.Log file starts with a single
	   character command followed by a space.  For backward
	   compatibility, the absence of a space indicates an add
	   command.  */
	if (cmd != NULL)
	{
	    if (l[1] != ' ')
		*cmd = 'A';
	    else
	    {
		*cmd = l[0];
		l += 2;
	    }
	}

	type = ENT_FILE;

	if (l[0] == 'D')
	{
	    type = ENT_SUBDIR;
	    *sawdir = 1;
	    ++l;
	    /* An empty D line is permitted; it is a signal that this
	       Entries file lists all known subdirectories.  */
	}

	if (l[0] != '/')
d235 1
a235 1
	user = l + 1;
d261 1
a261 1

d277 1
a277 1
	    if (strlen (ts) > 30 && CVS_STAT (user, &sb) == 0)
d291 1
a291 2
	ent = Entnode_Create (type, user, vn, ts, options, tag, date,
			      ts_conflict);
a303 10
    switch (p->type)
    {
    case ENT_FILE:
        break;
    case ENT_SUBDIR:
        if (fprintf (fp, "D") < 0)
	    return 1;
	break;
    }

a341 1
    struct stickydirtag *sdtp = NULL;
a345 1
    int sawdir;
d357 2
d370 1
a370 3
    sawdir = 0;

    fpin = CVS_FOPEN (CVSADM_ENT, "r");
d375 1
a375 1
	while ((ent = fgetentent (fpin, (char *) NULL, &sawdir)) != NULL) 
d383 1
a383 1
    fpin = CVS_FOPEN (CVSADM_ENTLOG, "r");
d386 1
a386 4
	char cmd;
	Node *node;

	while ((ent = fgetentent (fpin, &cmd, &sawdir)) != NULL)
d388 1
a388 15
	    switch (cmd)
	    {
	    case 'A':
		(void) AddEntryNode (entries, ent);
		break;
	    case 'R':
		node = findnode_fn (entries, ent->user);
		if (node != NULL)
		    delnode (node);
		Entnode_Destroy (ent);
		break;
	    default:
		/* Ignore unrecognized commands.  */
	        break;
	    }
a393 14
    /* Update the list private data to indicate whether subdirectory
       information is known.  Nonexistent list private data is taken
       to mean that it is known.  */
    if (sdtp != NULL)
	sdtp->subdirs = sawdir;
    else if (! sawdir)
    {
	sdtp = (struct stickydirtag *) xmalloc (sizeof (*sdtp));
	memset ((char *) sdtp, 0, sizeof (*sdtp));
	sdtp->subdirs = 0;
	entries->list->data = (char *) sdtp;
	entries->list->delproc = freesdt;
    }

d525 1
a525 1
    fp = CVS_FOPEN (CVSADM_TAG, "r");
a546 156
    }
}

/*
 * This is called if all subdirectory information is known, but there
 * aren't any subdirectories.  It records that fact in the list
 * private data.
 */

void
Subdirs_Known (entries)
     List *entries;
{
    struct stickydirtag *sdtp;

    /* If there is no list private data, that means that the
       subdirectory information is known.  */
    sdtp = (struct stickydirtag *) entries->list->data;
    if (sdtp != NULL && ! sdtp->subdirs)
    {
	FILE *fp;

	sdtp->subdirs = 1;
	/* Create Entries.Log so that Entries_Close will do something.  */
	fp = open_file (CVSADM_ENTLOG, "a");
	if (fclose (fp) == EOF)
	    error (1, errno, "cannot close %s", CVSADM_ENTLOG);
    }
}

/* Record subdirectory information.  */

static Entnode *
subdir_record (cmd, parent, dir)
     int cmd;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    /* None of the information associated with a directory is
       currently meaningful.  */
    entnode = Entnode_Create (ENT_SUBDIR, dir, "", "", "",
			      (char *) NULL, (char *) NULL,
			      (char *) NULL);

    if (!noexec)
    {
	if (parent == NULL)
	    entfilename = CVSADM_ENTLOG;
	else
	{
	    entfilename = xmalloc (strlen (parent)
				   + sizeof CVSADM_ENTLOG
				   + 10);
	    sprintf (entfilename, "%s/%s", parent, CVSADM_ENTLOG);
	}

	entfile = CVS_FOPEN (entfilename, "a");
	if (entfile == NULL)
	{
	    int save_errno = errno;

	    /* It is not an error if there is no CVS administration
               directory.  Permitting this case simplifies some
               calling code.  */

	    if (parent == NULL)
	    {
		if (! isdir (CVSADM))
		    return entnode;
	    }
	    else
	    {
		sprintf (entfilename, "%s/%s", parent, CVSADM);
		if (! isdir (entfilename))
		{
		    free (entfilename);
		    entfilename = NULL;
		    return entnode;
		}
	    }

	    error (1, save_errno, "cannot open %s", entfilename);
	}

	if (fprintf (entfile, "%c ", cmd) < 0)
	    error (1, errno, "cannot write %s", entfilename);

	if (fputentent (entfile, entnode) != 0)
	    error (1, errno, "cannot write %s", entfilename);

	if (fclose (entfile) == EOF)
	    error (1, errno, "error closing %s", entfilename);

	if (parent != NULL)
	{
	    free (entfilename);
	    entfilename = NULL;
	}
    }

    return entnode;
}

/*
 * Record the addition of a new subdirectory DIR in PARENT.  PARENT
 * may be NULL, which means the current directory.  ENTRIES is the
 * current entries list; it may be NULL, which means that it need not
 * be updated.
 */

void
Subdir_Register (entries, parent, dir)
     List *entries;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    /* Ignore attempts to register ".".  These can happen in the
       server code.  */
    if (dir[0] == '.' && dir[1] == '\0')
	return;

    entnode = subdir_record ('A', parent, dir);

    if (entries != NULL && (parent == NULL || strcmp (parent, ".") == 0))
	(void) AddEntryNode (entries, entnode);
    else
	Entnode_Destroy (entnode);
}

/*
 * Record the removal of a subdirectory.  The arguments are the same
 * as for Subdir_Register.
 */

void
Subdir_Deregister (entries, parent, dir)
     List *entries;
     const char *parent;
     const char *dir;
{
    Entnode *entnode;

    entnode = subdir_record ('R', parent, dir);
    Entnode_Destroy (entnode);

    if (entries != NULL && (parent == NULL || strcmp (parent, ".") == 0))
    {
	Node *p;

	p = findnode_fn (entries, dir);
	if (p != NULL)
	    delnode (p);
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d30 1
a30 6
static Entnode *Entnode_Create PROTO ((enum ent_type, const char *,
				       const char *, const char *,
				       const char *, const char *,
				       const char *, const char *));

static Entnode *
d60 1
a60 3
static void Entnode_Destroy PROTO ((Entnode *));

static void
d599 1
a599 1
    char *tmp;
a603 3
    tmp = xmalloc ((dir ? strlen (dir) : 0)
		   + sizeof (CVSADM_TAG)
		   + 10);
a627 1
    free (tmp);
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@a673 3
	    /* if not 'T' or 'D' silently ignore it; it may have been
	       written by a future version of CVS which extends the
	       syntax.  */
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@a437 1
    int dirnonbranch;
d449 1
a449 1
    ParseTag (&dirtag, &dirdate, &dirnonbranch);
a456 1
	sdtp->nonbranch = dirnonbranch;
d600 1
a600 1
WriteTag (dir, tag, date, nonbranch, update_dir, repository)
a603 3
    int nonbranch;
    char *update_dir;
    char *repository;
d624 2
a625 10
	    if (nonbranch)
	    {
		if (fprintf (fout, "N%s\n", tag) < 0)
		    error (1, errno, "write to %s failed", tmp);
	    }
	    else
	    {
		if (fprintf (fout, "T%s\n", tag) < 0)
		    error (1, errno, "write to %s failed", tmp);
	    }
a638 4
#ifdef SERVER_SUPPORT
    if (server_active)
	server_set_sticky (update_dir, repository, tag, date, nonbranch);
#endif
d645 1
a645 1
ParseTag (tagp, datep, nonbranchp)
a647 1
    int *nonbranchp;
d670 7
a676 24
	    switch (*line)
	    {
		case 'T':
		    if (tagp != NULL)
			*tagp = xstrdup (line + 1);
		    if (nonbranchp != NULL)
			*nonbranchp = 0;
		    break;
		case 'D':
		    if (datep != NULL)
			*datep = xstrdup (line + 1);
		    break;
		case 'N':
		    if (tagp != NULL)
			*tagp = xstrdup (line + 1);
		    if (nonbranchp != NULL)
			*nonbranchp = 1;
		    break;
		default:
		    /* Silently ignore it; it may have been
		       written by a future version of CVS which extends the
		       syntax.  */
		    break;
	    }
d703 4
a706 7
	if (!noexec)
	{
	    /* Create Entries.Log so that Entries_Close will do something.  */
	    fp = open_file (CVSADM_ENTLOG, "a");
	    if (fclose (fp) == EOF)
		error (1, errno, "cannot close %s", CVSADM_ENTLOG);
	}
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@d658 3
a660 14
/* Parse the CVS/Tag file for the current directory.

   If it contains a date, sets *DATEP to the date in a newly malloc'd
   string, *TAGP to NULL, and *NONBRANCHP to an unspecified value.

   If it contains a branch tag, sets *TAGP to the tag in a newly
   malloc'd string, *NONBRANCHP to 0, and *DATEP to NULL.

   If it contains a nonbranch tag, sets *TAGP to the tag in a newly
   malloc'd string, *NONBRANCHP to 1, and *DATEP to NULL.

   If it does not exist, or contains something unrecognized by this
   version of CVS, set *DATEP and *TAGP to NULL and *NONBRANCHP to
   an unspecified value.  */
a672 5
    /* Always store a value here, even in the 'D' case where the value
       is unspecified.  Shuts up tools which check for references to
       uninitialized memory.  */
    if (nonbranchp != NULL)
	*nonbranchp = 0;
d682 1
a682 1

d693 2
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d120 1
a120 20
    entfile = CVS_FOPEN (entfilename, "w+");
    if (entfile == NULL)
    {
	/* Make this a warning, not an error.  For example, one user might
	   have checked out a working directory which, for whatever reason,
	   contains an Entries.Log file.  A second user, without write access
	   to that working directory, might want to do a "cvs log".  The
	   problem rewriting Entries shouldn't affect the ability of "cvs log"
	   to work, although the warning is probably a good idea so that
	   whether Entries gets rewritten is not an inexplicable process.  */
	/* FIXME: should be including update_dir in message.  */
	error (0, errno, "cannot rewrite %s", entfilename);

	/* Now just return.  We leave the Entries.Log file around.  As far
	   as I know, there is never any data lying around in 'list' that
	   is not in Entries.Log at this time (if there is an error writing
	   Entries.Log that is a separate problem).  */
	return;
    }

a264 3
/* Return the next real Entries line.  On end of file, returns NULL.
   On error, prints an error message and returns NULL.  */

a277 1
    int line_length;
d283 1
a283 1
    while ((line_length = getline (&line, &line_chars_allocated, fpin)) > 0)
a377 3
    if (line_length < 0 && !feof (fpin))
	error (0, errno, "cannot read entries file");

d671 1
a671 4
   an unspecified value.

   If there is an error, print an error message, set *DATEP and *TAGP
   to NULL, and return.  */
d727 1
a727 14

	if (line_length < 0)
	{
	    /* FIXME-update-dir: should include update_dir in messages.  */
	    if (feof (fp))
		error (0, 0, "cannot read %s: end of file", CVSADM_TAG);
	    else
		error (0, errno, "cannot read %s", CVSADM_TAG);
	}

	if (fclose (fp) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_TAG);

a729 3
    else if (!existence_error (errno))
	/* FIXME-update-dir: should include update_dir in message.  */
	error (0, errno, "cannot open %s", CVSADM_TAG);
a888 227
}



/* OK, the following base_* code tracks the revisions of the files in
   CVS/Base.  We do this in a file CVS/Baserev.  Separate from
   CVS/Entries because it needs to go in separate data structures
   anyway (the name in Entries must be unique), so this seemed
   cleaner.  The business of rewriting the whole file in
   base_deregister and base_register is the kind of thing we used to
   do for Entries and which turned out to be slow, which is why there
   is now the Entries.Log machinery.  So maybe from that point of
   view it is a mistake to do this separately from Entries, I dunno.

   We also need something analogous for:

   1. CVS/Template (so we can update the Template file automagically
   without the user needing to check out a new working directory).
   Updating would probably print a message (that part might be
   optional, although probably it should be visible because not all
   cvs commands would make the update happen and so it is a
   user-visible behavior).  Constructing version number for template
   is a bit hairy (base it on the timestamp on the server?  Or see if
   the template is in checkoutlist and if yes use its versioning and
   if no don't version it?)....

   2.  cvsignore (need to keep a copy in the working directory to do
   "cvs release" on the client side; see comment at src/release.c
   (release).  Would also allow us to stop needing Questionable.  */

enum base_walk {
    /* Set the revision for FILE to *REV.  */
    BASE_REGISTER,
    /* Get the revision for FILE and put it in a newly malloc'd string
       in *REV, or put NULL if not mentioned.  */
    BASE_GET,
    /* Remove FILE.  */
    BASE_DEREGISTER
};

static void base_walk PROTO ((enum base_walk, struct file_info *, char **));

/* Read through the lines in CVS/Baserev, taking the actions as documented
   for CODE.  */

static void
base_walk (code, finfo, rev)
    enum base_walk code;
    struct file_info *finfo;
    char **rev;
{
    FILE *fp;
    char *line;
    size_t line_allocated;
    FILE *newf;
    char *baserev_fullname;
    char *baserevtmp_fullname;

    line = NULL;
    line_allocated = 0;
    newf = NULL;

    /* First compute the fullnames for the error messages.  This
       computation probably should be broken out into a separate function,
       as recurse.c does it too and places like Entries_Open should be
       doing it.  */
    baserev_fullname = xmalloc (sizeof (CVSADM_BASEREV)
				+ strlen (finfo->update_dir)
				+ 2);
    baserev_fullname[0] = '\0';
    baserevtmp_fullname = xmalloc (sizeof (CVSADM_BASEREVTMP)
				   + strlen (finfo->update_dir)
				   + 2);
    baserevtmp_fullname[0] = '\0';
    if (finfo->update_dir[0] != '\0')
    {
	strcat (baserev_fullname, finfo->update_dir);
	strcat (baserev_fullname, "/");
	strcat (baserevtmp_fullname, finfo->update_dir);
	strcat (baserevtmp_fullname, "/");
    }
    strcat (baserev_fullname, CVSADM_BASEREV);
    strcat (baserevtmp_fullname, CVSADM_BASEREVTMP);

    fp = CVS_FOPEN (CVSADM_BASEREV, "r");
    if (fp == NULL)
    {
	if (!existence_error (errno))
	{
	    error (0, errno, "cannot open %s for reading", baserev_fullname);
	    goto out;
	}
    }

    switch (code)
    {
	case BASE_REGISTER:
	case BASE_DEREGISTER:
	    newf = CVS_FOPEN (CVSADM_BASEREVTMP, "w");
	    if (newf == NULL)
	    {
		error (0, errno, "cannot open %s for writing",
		       baserevtmp_fullname);
		goto out;
	    }
	    break;
	case BASE_GET:
	    *rev = NULL;
	    break;
    }

    if (fp != NULL)
    {
	while (getline (&line, &line_allocated, fp) >= 0)
	{
	    char *linefile;
	    char *p;
	    char *linerev;

	    if (line[0] != 'B')
		/* Ignore, for future expansion.  */
		continue;

	    linefile = line + 1;
	    p = strchr (linefile, '/');
	    if (p == NULL)
		/* Syntax error, ignore.  */
		continue;
	    linerev = p + 1;
	    p = strchr (linerev, '/');
	    if (p == NULL)
		continue;

	    linerev[-1] = '\0';
	    if (fncmp (linefile, finfo->file) == 0)
	    {
		switch (code)
		{
		case BASE_REGISTER:
		case BASE_DEREGISTER:
		    /* Don't copy over the old entry, we don't want it.  */
		    break;
		case BASE_GET:
		    *p = '\0';
		    *rev = xstrdup (linerev);
		    *p = '/';
		    goto got_it;
		}
	    }
	    else
	    {
		linerev[-1] = '/';
		switch (code)
		{
		case BASE_REGISTER:
		case BASE_DEREGISTER:
		    if (fprintf (newf, "%s\n", line) < 0)
			error (0, errno, "error writing %s",
			       baserevtmp_fullname);
		    break;
		case BASE_GET:
		    break;
		}
	    }
	}
	if (ferror (fp))
	    error (0, errno, "cannot read %s", baserev_fullname);
    }
 got_it:

    if (code == BASE_REGISTER)
    {
	if (fprintf (newf, "B%s/%s/\n", finfo->file, *rev) < 0)
	    error (0, errno, "error writing %s",
		   baserevtmp_fullname);
    }

 out:

    if (line != NULL)
	free (line);

    if (fp != NULL)
    {
	if (fclose (fp) < 0)
	    error (0, errno, "cannot close %s", baserev_fullname);
    }
    if (newf != NULL)
    {
	if (fclose (newf) < 0)
	    error (0, errno, "cannot close %s", baserevtmp_fullname);
	rename_file (CVSADM_BASEREVTMP, CVSADM_BASEREV);
    }

    free (baserev_fullname);
    free (baserevtmp_fullname);
}

/* Return, in a newly malloc'd string, the revision for FILE in CVS/Baserev,
   or NULL if not listed.  */

char *
base_get (finfo)
    struct file_info *finfo;
{
    char *rev;
    base_walk (BASE_GET, finfo, &rev);
    return rev;
}

/* Set the revision for FILE to REV.  */

void
base_register (finfo, rev)
    struct file_info *finfo;
    char *rev;
{
    base_walk (BASE_REGISTER, finfo, &rev);
}

/* Remove FILE.  */

void
base_deregister (finfo)
    struct file_info *finfo;
{
    base_walk (BASE_DEREGISTER, finfo, NULL);
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d453 3
a455 5
/* Read the entries file into a list, hashing on the file name.

   UPDATE_DIR is the name of the current directory, for use in error
   messages, or NULL if not known (that is, noone has gotten around
   to updating the caller to pass in the information).  */
d457 1
a457 1
Entries_Open (aflag, update_dir)
a458 1
    char *update_dir;
a494 3
    {
	if (update_dir != NULL)
	    error (0, 0, "in directory %s:", update_dir);
a495 1
    }
d800 3
a802 16
	    fp = CVS_FOPEN (CVSADM_ENTLOG, "a");
	    if (fp == NULL)
	    {
		int save_errno = errno;

		/* As in subdir_record, just silently skip the whole thing
		   if there is no CVSADM directory.  */
		if (! isdir (CVSADM))
		    return;
		error (1, save_errno, "cannot open %s", entfilename);
	    }
	    else
	    {
		if (fclose (fp) == EOF)
		    error (1, errno, "cannot close %s", CVSADM_ENTLOG);
	    }
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d160 1
a160 3
    if (unlink_file (CVSADM_ENTLOG) < 0
	&& !existence_error (errno))
	error (0, errno, "cannot remove %s", CVSADM_ENTLOG);
d174 6
a179 2
	(void) fprintf (stderr, "%s-> Scratch_Entry(%s)\n",
			CLIENT_SERVER_STR, fname);
d234 8
a241 2
	(void) fprintf (stderr, "%s-> Register(%s, %s, %s%s%s, %s, %s %s)\n",
			CLIENT_SERVER_STR,
d245 1
d255 1
a255 9
	entfile = CVS_FOPEN (entfilename, "a");

	if (entfile == NULL)
	{
	    /* Warning, not error, as in write_entries.  */
	    /* FIXME-update-dir: should be including update_dir in message.  */
	    error (0, errno, "cannot open %s", entfilename);
	    return;
	}
d510 1
a510 3
	if (fclose (fpin) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_ENT);
d538 1
a538 3
	if (fclose (fpin) < 0)
	    /* FIXME-update-dir: should include update_dir in message.  */
	    error (0, errno, "cannot close %s", CVSADM_ENTLOG);
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@d810 1
a810 2
	    entfilename = CVSADM_ENTLOG;
	    fp = CVS_FOPEN (entfilename, "a");
d824 1
a824 1
		    error (1, errno, "cannot close %s", entfilename);
@


1.1.1.14
log
@Latest from Cyclic Software
@
text
@d384 1
a384 3
		/* Fix non-standard format.  */
		if (c[8] == '0') c[8] = ' ';

@


