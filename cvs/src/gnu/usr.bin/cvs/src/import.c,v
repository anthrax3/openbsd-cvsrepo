head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.6
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.8
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.20
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.18
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.16
	OPENBSD_5_0:1.6.0.14
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.12
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.10
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.6
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.28
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.26
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.24
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.22
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.20
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.18
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.16
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.14
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.12
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.10
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	cvs-1-11-1p1:1.1.1.16
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	cvs-1-11:1.1.1.15
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	cvs-1-10-7:1.1.1.14
	OPENBSD_2_5:1.1.1.13.0.2
	OPENBSD_2_5_BASE:1.1.1.13
	cvs-1-10-5:1.1.1.13
	OPENBSD_2_4:1.1.1.12.0.2
	OPENBSD_2_4_BASE:1.1.1.12
	cvs-1-10:1.1.1.12
	cvs-1-9-28:1.1.1.12
	OPENBSD_2_3:1.1.1.11.0.2
	OPENBSD_2_3_BASE:1.1.1.11
	cvs-1-9-26:1.1.1.11
	cvs-1-9-24:1.1.1.10
	OPENBSD_2_2:1.1.1.9.0.2
	OPENBSD_2_2_BASE:1.1.1.9
	cvs-1-9-10:1.1.1.9
	OPENBSD_2_1:1.1.1.8.0.2
	OPENBSD_2_1_BASE:1.1.1.8
	cvs-1-9-8:1.1.1.8
	cvs-1-9-6:1.1.1.7
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2014.05.28.16.43.06;	author jcs;	state Exp;
branches;
next	1.7;

1.7
date	2013.06.03.17.02.36;	author jcs;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.25.15.26.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.28.23.26.33;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.10.19.31.35;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	99.09.10.05.21.32;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	99.06.16.14.02.20;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.33;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.18.11;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.41.56;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.19.38;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.35.37;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.37.33;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.01.56.09;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.04.21.04.27.19;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.06.28.03.28.44;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.02.22.08.21.16;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.03.12.06.58.47;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.07.13.03.54.04;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	99.02.28.21.32.59;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	99.09.10.05.06.23;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2001.02.10.18.57.42;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2001.09.28.22.45.37;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@finally enable writing per-commit commitid tokens to rcs ,v files

ok deraadt@@ millert@@
@
text
@/*
 * Copyright (c) 1992, Brian Berliner and Jeff Polk
 * Copyright (c) 1989-1992, Brian Berliner
 * 
 * You may distribute under the terms of the GNU General Public License as
 * specified in the README file that comes with the CVS source distribution.
 * 
 * "import" checks in the vendor release located in the current directory into
 * the CVS source repository.  The CVS vendor branch support is utilized.
 * 
 * At least three arguments are expected to follow the options:
 *	repository	Where the source belongs relative to the CVSROOT
 *	VendorTag	Vendor's major tag
 *	VendorReleTag	Tag for this particular release
 *
 * Additional arguments specify more Vendor Release Tags.
 */

#include "cvs.h"
#include "savecwd.h"
#include <assert.h>

static char *get_comment PROTO((char *user));
static int add_rev PROTO((char *message, RCSNode *rcs, char *vfile,
			  char *vers));
static int add_tags PROTO((RCSNode *rcs, char *vfile, char *vtag, int targc,
		     char *targv[]));
static int import_descend PROTO((char *message, char *vtag, int targc, char *targv[]));
static int import_descend_dir PROTO((char *message, char *dir, char *vtag,
			       int targc, char *targv[]));
static int process_import_file PROTO((char *message, char *vfile, char *vtag,
				int targc, char *targv[]));
static int update_rcs_file PROTO((char *message, char *vfile, char *vtag, int targc,
			    char *targv[], int inattic));
static void add_log PROTO((int ch, char *fname));

static int repos_len;
static char *vhead;
static char *vbranch;
static FILE *logfp;
static char *repository;
static int conflicts;
static int use_file_modtime;
static char *keyword_opt = NULL;

static const char *const import_usage[] =
{
    "Usage: %s %s [-d] [-k subst] [-I ign] [-m msg] [-b branch]\n",
    "    [-W spec] repository vendor-tag release-tags...\n",
    "\t-d\tUse the file's modification time as the time of import.\n",
    "\t-k sub\tSet default RCS keyword substitution mode.\n",
    "\t-I ign\tMore files to ignore (! to reset).\n",
    "\t-b bra\tVendor branch id.\n",
    "\t-m msg\tLog message.\n",
    "\t-W spec\tWrappers specification line.\n",
    "(Specify the --help global option for a list of other help options)\n",
    NULL
};

int
import (argc, argv)
    int argc;
    char **argv;
{
    char *message = NULL;
    char *tmpfile;
    char *cp;
    int i, c, msglen, err;
    List *ulist;
    Node *p;
    struct logfile_info *li;

    if (argc == -1)
	usage (import_usage);

    ign_setup ();
    wrap_setup ();

    vbranch = xstrdup (CVSBRANCH);
    optind = 0;
    while ((c = getopt (argc, argv, "+Qqdb:m:I:k:W:")) != -1)
    {
	switch (c)
	{
	    case 'Q':
	    case 'q':
#ifdef SERVER_SUPPORT
		/* The CVS 1.5 client sends these options (in addition to
		   Global_option requests), so we must ignore them.  */
		if (!server_active)
#endif
		    error (1, 0,
			   "-q or -Q must be specified before \"%s\"",
			   command_name);
		break;
	    case 'd':
#ifdef SERVER_SUPPORT
		if (server_active)
		{
		    /* CVS 1.10 and older clients will send this, but it
		       doesn't do any good.  So tell the user we can't
		       cope, rather than silently losing.  */
		    error (0, 0,
			   "warning: not setting the time of import from the file");
		    error (0, 0, "due to client limitations");
		}
#endif
		use_file_modtime = 1;
		break;
	    case 'b':
		free (vbranch);
		vbranch = xstrdup (optarg);
		break;
	    case 'm':
#ifdef FORCE_USE_EDITOR
		use_editor = 1;
#else
		use_editor = 0;
#endif
		message = xstrdup(optarg);
		break;
	    case 'I':
		ign_add (optarg, 0);
		break;
            case 'k':
		/* RCS_check_kflag returns strings of the form -kxx.  We
		   only use it for validation, so we can free the value
		   as soon as it is returned. */
		free (RCS_check_kflag (optarg));
		keyword_opt = optarg;
		break;
	    case 'W':
		wrap_add (optarg, 0);
		break;
	    case '?':
	    default:
		usage (import_usage);
		break;
	}
    }
    argc -= optind;
    argv += optind;
    if (argc < 3)
	usage (import_usage);

#ifdef SERVER_SUPPORT
    /* This is for handling the Checkin-time request.  It might seem a
       bit odd to enable the use_file_modtime code even in the case
       where Checkin-time was not sent for a particular file.  The
       effect is that we use the time of upload, rather than the time
       when we call RCS_checkin.  Since those times are both during
       CVS's run, that seems OK, and it is easier to implement than
       putting the "was Checkin-time sent" flag in CVS/Entries or some
       such place.  */

    if (server_active)
	use_file_modtime = 1;
#endif

    for (i = 1; i < argc; i++)		/* check the tags for validity */
    {
	int j;

	RCS_check_tag (argv[i]);
	for (j = 1; j < i; j++)
	    if (strcmp (argv[j], argv[i]) == 0)
		error (1, 0, "tag `%s' was specified more than once", argv[i]);
    }

    /* XXX - this should be a module, not just a pathname */
    if (! isabsolute (argv[0])
	&& pathname_levels (argv[0]) == 0)
    {
	if (current_parsed_root == NULL)
	{
	    error (0, 0, "missing CVSROOT environment variable\n");
	    error (1, 0, "Set it or specify the '-d' option to %s.",
		   program_name);
	}
	repository = xmalloc (strlen (current_parsed_root->directory)
			      + strlen (argv[0])
			      + 2);
	(void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
	repos_len = strlen (current_parsed_root->directory);
    }
    else
    {
	/* It is somewhere between a security hole and "unexpected" to
	   let the client start mucking around outside the cvsroot
	   (wouldn't get the right CVSROOT configuration, &c).  */
	error (1, 0, "directory %s not relative within the repository",
	       argv[0]);
    }

    /*
     * Consistency checks on the specified vendor branch.  It must be
     * composed of only numbers and dots ('.').  Also, for now we only
     * support branching to a single level, so the specified vendor branch
     * must only have two dots in it (like "1.1.1").
     */
    for (cp = vbranch; *cp != '\0'; cp++)
	if (!isdigit ((unsigned char) *cp) && *cp != '.')
	    error (1, 0, "%s is not a numeric branch", vbranch);
    if (numdots (vbranch) != 2)
	error (1, 0, "Only branches with two dots are supported: %s", vbranch);
    vhead = xstrdup (vbranch);
    cp = strrchr (vhead, '.');
    *cp = '\0';

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	/* For rationale behind calling start_server before do_editor, see
	   commit.c  */
	start_server ();
    }
#endif

    if (use_editor)
    {
	do_editor ((char *) NULL, &message, repository,
		   (List *) NULL);
    }
    do_verify (message, repository);
    msglen = message == NULL ? 0 : strlen (message);
    if (msglen == 0 || message[msglen - 1] != '\n')
    {
	char *nm = xmalloc (msglen + 2);
	*nm = '\0';
	if (message != NULL)
	{
	    (void) strcpy (nm, message);
	    free (message);
	}
	(void) strcat (nm + msglen, "\n");
	message = nm;
    }

#ifdef CLIENT_SUPPORT
    if (current_parsed_root->isremote)
    {
	int err;

	if (vbranch[0] != '\0')
	    option_with_arg ("-b", vbranch);
	if (message)
	    option_with_arg ("-m", message);
	if (keyword_opt != NULL)
	    option_with_arg ("-k", keyword_opt);
	/* The only ignore processing which takes place on the server side
	   is the CVSROOT/cvsignore file.  But if the user specified -I !,
	   the documented behavior is to not process said file.  */
	if (ign_inhibit_server)
	{
	    send_arg ("-I");
	    send_arg ("!");
	}
	wrap_send ();

	{
	    int i;
	    for (i = 0; i < argc; ++i)
		send_arg (argv[i]);
	}

	logfp = stdin;
	client_import_setup (repository);
	err = import_descend (message, argv[1], argc - 2, argv + 2);
	client_import_done ();
	if (message)
	    free (message);
	free (repository);
	free (vbranch);
	free (vhead);
	send_to_server ("import\012", 0);
	err += get_responses_and_close ();
	return err;
    }
#endif

    if (!safe_location ())
    {
	error (1, 0, "attempt to import the repository");
    }

    /*
     * Make all newly created directories writable.  Should really use a more
     * sophisticated security mechanism here.
     */
    (void) umask (cvsumask);
    make_directories (repository);

    /* Create the logfile that will be logged upon completion */
    if ((logfp = cvs_temp_file (&tmpfile)) == NULL)
	error (1, errno, "cannot create temporary file `%s'", tmpfile);
    /* On systems where we can unlink an open file, do so, so it will go
       away no matter how we exit.  FIXME-maybe: Should be checking for
       errors but I'm not sure which error(s) we get if we are on a system
       where one can't unlink open files.  */
    (void) CVS_UNLINK (tmpfile);
    (void) fprintf (logfp, "\nVendor Tag:\t%s\n", argv[1]);
    (void) fprintf (logfp, "Release Tags:\t");
    for (i = 2; i < argc; i++)
	(void) fprintf (logfp, "%s\n\t\t", argv[i]);
    (void) fprintf (logfp, "\n");

    /* Just Do It.  */
    err = import_descend (message, argv[1], argc - 2, argv + 2);
    if (conflicts)
    {
	if (!really_quiet)
	{
	    char buf[20];
	    char *buf2;

	    cvs_output_tagged ("+importmergecmd", NULL);
	    cvs_output_tagged ("newline", NULL);
	    sprintf (buf, "%d", conflicts);
	    cvs_output_tagged ("conflicts", buf);
	    cvs_output_tagged ("text", " conflicts created by this import.");
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("text",
			       "Use the following command to help the merge:");
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("text", "\t");
	    cvs_output_tagged ("text", program_name);
	    if (CVSroot_cmdline != NULL)
	    {
		cvs_output_tagged ("text", " -d ");
		cvs_output_tagged ("text", CVSroot_cmdline);
	    }
	    cvs_output_tagged ("text", " checkout -j");
	    buf2 = xmalloc (strlen (argv[1]) + 20);
	    sprintf (buf2, "%s:yesterday", argv[1]);
	    cvs_output_tagged ("mergetag1", buf2);
	    free (buf2);
	    cvs_output_tagged ("text", " -j");
	    cvs_output_tagged ("mergetag2", argv[1]);
	    cvs_output_tagged ("text", " ");
	    cvs_output_tagged ("repository", argv[0]);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("-importmergecmd", NULL);
	}

	/* FIXME: I'm not sure whether we need to put this information
           into the loginfo.  If we do, then note that it does not
           report any required -d option.  There is no particularly
           clean way to tell the server about the -d option used by
           the client.  */
	(void) fprintf (logfp, "\n%d conflicts created by this import.\n",
			conflicts);
	(void) fprintf (logfp,
			"Use the following command to help the merge:\n\n");
	(void) fprintf (logfp, "\t%s checkout ", program_name);
	(void) fprintf (logfp, "-j%s:yesterday -j%s %s\n\n",
			argv[1], argv[1], argv[0]);
    }
    else
    {
	if (!really_quiet)
	    cvs_output ("\nNo conflicts created by this import\n\n", 0);
	(void) fprintf (logfp, "\nNo conflicts created by this import\n\n");
    }

    /*
     * Write out the logfile and clean up.
     */
    ulist = getlist ();
    p = getnode ();
    p->type = UPDATE;
    p->delproc = update_delproc;
    p->key = xstrdup ("- Imported sources");
    li = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
    li->type = T_TITLE;
    li->tag = xstrdup (vbranch);
    li->rev_old = li->rev_new = NULL;
    p->data = (char *) li;
    (void) addnode (ulist, p);
    Update_Logfile (repository, message, logfp, ulist);
    dellist (&ulist);
    if (fclose (logfp) < 0)
	error (0, errno, "error closing %s", tmpfile);

    /* Make sure the temporary file goes away, even on systems that don't let
       you delete a file that's in use.  */
    if (CVS_UNLINK (tmpfile) < 0 && !existence_error (errno))
	error (0, errno, "cannot remove %s", tmpfile);
    free (tmpfile);

    if (message)
	free (message);
    free (repository);
    free (vbranch);
    free (vhead);

    return (err);
}

/* Process all the files in ".", then descend into other directories.
   Returns 0 for success, or >0 on error (in which case a message
   will have been printed).  */
static int
import_descend (message, vtag, targc, targv)
    char *message;
    char *vtag;
    int targc;
    char *targv[];
{
    DIR *dirp;
    struct dirent *dp;
    int err = 0;
    List *dirlist = NULL;

    /* first, load up any per-directory ignore lists */
    ign_add_file (CVSDOTIGNORE, 1);
    wrap_add_file (CVSDOTWRAPPER, 1);

    if ((dirp = CVS_OPENDIR (".")) == NULL)
    {
	error (0, errno, "cannot open directory");
	err++;
    }
    else
    {
	errno = 0;
	while ((dp = CVS_READDIR (dirp)) != NULL)
	{
	    if (strcmp (dp->d_name, ".") == 0 || strcmp (dp->d_name, "..") == 0)
		goto one_more_time_boys;
#ifdef SERVER_SUPPORT
	    /* CVS directories are created in the temp directory by
	       server.c because it doesn't special-case import.  So
	       don't print a message about them, regardless of -I!.  */
	    if (server_active && strcmp (dp->d_name, CVSADM) == 0)
		goto one_more_time_boys;
#endif
	    if (ign_name (dp->d_name))
	    {
		add_log ('I', dp->d_name);
		goto one_more_time_boys;
	    }

	    if (
#ifdef DT_DIR
		(dp->d_type == DT_DIR
		 || (dp->d_type == DT_UNKNOWN && isdir (dp->d_name)))
#else
		isdir (dp->d_name)
#endif
		&& !wrap_name_has (dp->d_name, WRAP_TOCVS)
		)
	    {
		Node *n;

		if (dirlist == NULL)
		    dirlist = getlist();

		n = getnode();
		n->key = xstrdup (dp->d_name);
		addnode(dirlist, n);
	    }
	    else if (
#ifdef DT_DIR
		     dp->d_type == DT_LNK
		     || (dp->d_type == DT_UNKNOWN && islink (dp->d_name))
#else
		     islink (dp->d_name)
#endif
		     )
	    {
		add_log ('L', dp->d_name);
		err++;
	    }
	    else
	    {
#ifdef CLIENT_SUPPORT
		if (current_parsed_root->isremote)
		    err += client_process_import_file (message, dp->d_name,
                                                       vtag, targc, targv,
                                                       repository,
                                                       keyword_opt != NULL &&
						       keyword_opt[0] == 'b',
						       use_file_modtime);
		else
#endif
		    err += process_import_file (message, dp->d_name,
						vtag, targc, targv);
	    }
	one_more_time_boys:
	    errno = 0;
	}
	if (errno != 0)
	{
	    error (0, errno, "cannot read directory");
	    ++err;
	}
	(void) CVS_CLOSEDIR (dirp);
    }

    if (dirlist != NULL)
    {
	Node *head, *p;

	head = dirlist->list;
	for (p = head->next; p != head; p = p->next)
	{
	    err += import_descend_dir (message, p->key, vtag, targc, targv);
	}

	dellist(&dirlist);
    }

    return (err);
}

/*
 * Process the argument import file.
 */
static int
process_import_file (message, vfile, vtag, targc, targv)
    char *message;
    char *vfile;
    char *vtag;
    int targc;
    char *targv[];
{
    char *rcs;
    int inattic = 0;

    rcs = xmalloc (strlen (repository) + strlen (vfile) + sizeof (RCSEXT)
		   + 5);
    (void) sprintf (rcs, "%s/%s%s", repository, vfile, RCSEXT);
    if (!isfile (rcs))
    {
	char *attic_name;

	attic_name = xmalloc (strlen (repository) + strlen (vfile) +
			      sizeof (CVSATTIC) + sizeof (RCSEXT) + 10);
	(void) sprintf (attic_name, "%s/%s/%s%s", repository, CVSATTIC,
			vfile, RCSEXT);
	if (!isfile (attic_name))
	{
	    int retval;
	    char *free_opt = NULL;
	    char *our_opt = keyword_opt;

	    free (attic_name);
	    /*
	     * A new import source file; it doesn't exist as a ,v within the
	     * repository nor in the Attic -- create it anew.
	     */
	    add_log ('N', vfile);

#ifdef SERVER_SUPPORT
	    /* The most reliable information on whether the file is binary
	       is what the client told us.  That is because if the client had
	       the wrong idea about binaryness, it corrupted the file, so
	       we might as well believe the client.  */
	    if (server_active)
	    {
		Node *node;
		List *entries;

		/* Reading all the entries for each file is fairly silly, and
		   probably slow.  But I am too lazy at the moment to do
		   anything else.  */
		entries = Entries_Open (0, NULL);
		node = findnode_fn (entries, vfile);
		if (node != NULL)
		{
		    Entnode *entdata = (Entnode *) node->data;
		    if (entdata->type == ENT_FILE)
		    {
			assert (entdata->options[0] == '-'
				&& entdata->options[1] == 'k');
			our_opt = xstrdup (entdata->options + 2);
			free_opt = our_opt;
		    }
		}
		Entries_Close (entries);
	    }
#endif

	    retval = add_rcs_file (message, rcs, vfile, vhead, our_opt,
				   vbranch, vtag, targc, targv,
				   NULL, 0, logfp);
	    if (free_opt != NULL)
		free (free_opt);
	    free (rcs);
	    return retval;
	}
	free (attic_name);
	inattic = 1;
    }

    free (rcs);
    /*
     * an rcs file exists. have to do things the official, slow, way.
     */
    return (update_rcs_file (message, vfile, vtag, targc, targv, inattic));
}

/*
 * The RCS file exists; update it by adding the new import file to the
 * (possibly already existing) vendor branch.
 */
static int
update_rcs_file (message, vfile, vtag, targc, targv, inattic)
    char *message;
    char *vfile;
    char *vtag;
    int targc;
    char *targv[];
    int inattic;
{
    Vers_TS *vers;
    int letter;
    char *tocvsPath;
    struct file_info finfo;

    memset (&finfo, 0, sizeof finfo);
    finfo.file = vfile;
    /* Not used, so don't worry about it.  */
    finfo.update_dir = NULL;
    finfo.fullname = finfo.file;
    finfo.repository = repository;
    finfo.entries = NULL;
    finfo.rcs = NULL;
    vers = Version_TS (&finfo, (char *) NULL, vbranch, (char *) NULL,
		       1, 0);
    if (vers->vn_rcs != NULL
	&& !RCS_isdead(vers->srcfile, vers->vn_rcs))
    {
	int different;

	/*
	 * The rcs file does have a revision on the vendor branch. Compare
	 * this revision with the import file; if they match exactly, there
	 * is no need to install the new import file as a new revision to the
	 * branch.  Just tag the revision with the new import tags.
	 * 
	 * This is to try to cut down the number of "C" conflict messages for
	 * locally modified import source files.
	 */
	tocvsPath = wrap_tocvs_process_file (vfile);
	/* FIXME: Why don't we pass tocvsPath to RCS_cmp_file if it is
           not NULL?  */
	different = RCS_cmp_file (vers->srcfile, vers->vn_rcs, "-ko", vfile);
	if (tocvsPath)
	    if (unlink_file_dir (tocvsPath) < 0)
		error (0, errno, "cannot remove %s", tocvsPath);

	if (!different)
	{
	    int retval = 0;

	    /*
	     * The two files are identical.  Just update the tags, print the
	     * "U", signifying that the file has changed, but needs no
	     * attention, and we're done.
	     */
	    if (add_tags (vers->srcfile, vfile, vtag, targc, targv))
		retval = 1;
	    add_log ('U', vfile);
	    freevers_ts (&vers);
	    return (retval);
	}
    }

    /* We may have failed to parse the RCS file; check just in case */
    if (vers->srcfile == NULL ||
	add_rev (message, vers->srcfile, vfile, vers->vn_rcs) ||
	add_tags (vers->srcfile, vfile, vtag, targc, targv))
    {
	freevers_ts (&vers);
	return (1);
    }

    if (vers->srcfile->branch == NULL || inattic ||
	strcmp (vers->srcfile->branch, vbranch) != 0)
    {
	conflicts++;
	letter = 'C';
    }
    else
	letter = 'U';
    add_log (letter, vfile);

    freevers_ts (&vers);
    return (0);
}

/*
 * Add the revision to the vendor branch
 */
static int
add_rev (message, rcs, vfile, vers)
    char *message;
    RCSNode *rcs;
    char *vfile;
    char *vers;
{
    int locked, status, ierrno;
    char *tocvsPath;

    if (noexec)
	return (0);

    locked = 0;
    if (vers != NULL)
    {
	/* Before RCS_lock existed, we were directing stdout, as well as
	   stderr, from the RCS command, to DEVNULL.  I wouldn't guess that
	   was necessary, but I don't know for sure.  */
	/* Earlier versions of this function printed a `fork failed' error
	   when RCS_lock returned an error code.  That's not appropriate
	   now that RCS_lock is librarified, but should the error text be
	   preserved? */
	if (RCS_lock (rcs, vbranch, 1) != 0)
	    return 1;
	locked = 1;
	RCS_rewrite (rcs, NULL, NULL);
    }
    tocvsPath = wrap_tocvs_process_file (vfile);

    status = RCS_checkin (rcs, tocvsPath == NULL ? vfile : tocvsPath,
			  message, vbranch,
			  (RCS_FLAGS_QUIET | RCS_FLAGS_KEEPFILE
			   | (use_file_modtime ? RCS_FLAGS_MODTIME : 0)));
    ierrno = errno;

    if ((tocvsPath != NULL) && (unlink_file_dir (tocvsPath) < 0))
	error (0, errno, "cannot remove %s", tocvsPath);

    if (status)
    {
	if (!noexec)
	{
	    fperrmsg (logfp, 0, status == -1 ? ierrno : 0,
		      "ERROR: Check-in of %s failed", rcs->path);
	    error (0, status == -1 ? ierrno : 0,
		   "ERROR: Check-in of %s failed", rcs->path);
	}
	if (locked)
	{
	    (void) RCS_unlock(rcs, vbranch, 0);
	    RCS_rewrite (rcs, NULL, NULL);
	}
	return (1);
    }
    return (0);
}

/*
 * Add the vendor branch tag and all the specified import release tags to the
 * RCS file.  The vendor branch tag goes on the branch root (1.1.1) while the
 * vendor release tags go on the newly added leaf of the branch (1.1.1.1,
 * 1.1.1.2, ...).
 */
static int
add_tags (rcs, vfile, vtag, targc, targv)
    RCSNode *rcs;
    char *vfile;
    char *vtag;
    int targc;
    char *targv[];
{
    int i, ierrno;
    Vers_TS *vers;
    int retcode = 0;
    struct file_info finfo;

    if (noexec)
	return (0);

    if ((retcode = RCS_settag(rcs, vtag, vbranch)) != 0)
    {
	ierrno = errno;
	fperrmsg (logfp, 0, retcode == -1 ? ierrno : 0,
		  "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
	error (0, retcode == -1 ? ierrno : 0,
	       "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
	return (1);
    }
    RCS_rewrite (rcs, NULL, NULL);

    memset (&finfo, 0, sizeof finfo);
    finfo.file = vfile;
    /* Not used, so don't worry about it.  */
    finfo.update_dir = NULL;
    finfo.fullname = finfo.file;
    finfo.repository = repository;
    finfo.entries = NULL;
    finfo.rcs = NULL;
    vers = Version_TS (&finfo, NULL, vtag, NULL, 1, 0);
    for (i = 0; i < targc; i++)
    {
	if ((retcode = RCS_settag (rcs, targv[i], vers->vn_rcs)) == 0)
	    RCS_rewrite (rcs, NULL, NULL);
	else
	{
	    ierrno = errno;
	    fperrmsg (logfp, 0, retcode == -1 ? ierrno : 0,
		      "WARNING: Couldn't add tag %s to %s", targv[i],
		      rcs->path);
	    error (0, retcode == -1 ? ierrno : 0,
		   "WARNING: Couldn't add tag %s to %s", targv[i],
		   rcs->path);
	}
    }
    freevers_ts (&vers);
    return (0);
}

/*
 * Stolen from rcs/src/rcsfnms.c, and adapted/extended.
 */
struct compair
{
    char *suffix, *comlead;
};

static const struct compair comtable[] =
{

/*
 * comtable pairs each filename suffix with a comment leader. The comment
 * leader is placed before each line generated by the $Log keyword. This
 * table is used to guess the proper comment leader from the working file's
 * suffix during initial ci (see InitAdmin()). Comment leaders are needed for
 * languages without multiline comments; for others they are optional.
 *
 * I believe that the comment leader is unused if you are using RCS 5.7, which
 * decides what leader to use based on the text surrounding the $Log keyword
 * rather than a specified comment leader.
 */
    {"a", "-- "},			/* Ada		 */
    {"ada", "-- "},
    {"adb", "-- "},
    {"asm", ";; "},			/* assembler (MS-DOS) */
    {"ads", "-- "},			/* Ada		 */
    {"bas", "' "},    			/* Visual Basic code */
    {"bat", ":: "},			/* batch (MS-DOS) */
    {"body", "-- "},			/* Ada		 */
    {"c", " * "},			/* C		 */
    {"c++", "// "},			/* C++ in all its infinite guises */
    {"cc", "// "},
    {"cpp", "// "},
    {"cxx", "// "},
    {"m", "// "},			/* Objective-C */
    {"cl", ";;; "},			/* Common Lisp	 */
    {"cmd", ":: "},			/* command (OS/2) */
    {"cmf", "c "},			/* CM Fortran	 */
    {"cs", " * "},			/* C*		 */
    {"csh", "# "},			/* shell	 */
    {"dlg", " * "},   			/* MS Windows dialog file */
    {"e", "# "},			/* efl		 */
    {"epsf", "% "},			/* encapsulated postscript */
    {"epsi", "% "},			/* encapsulated postscript */
    {"el", "; "},			/* Emacs Lisp	 */
    {"f", "c "},			/* Fortran	 */
    {"for", "c "},
    {"frm", "' "},    			/* Visual Basic form */
    {"h", " * "},			/* C-header	 */
    {"hh", "// "},			/* C++ header	 */
    {"hpp", "// "},
    {"hxx", "// "},
    {"in", "# "},			/* for Makefile.in */
    {"l", " * "},			/* lex (conflict between lex and
					 * franzlisp) */
    {"mac", ";; "},			/* macro (DEC-10, MS-DOS, PDP-11,
					 * VMS, etc) */
    {"mak", "# "},    			/* makefile, e.g. Visual C++ */
    {"me", ".\\\" "},			/* me-macros	t/nroff	 */
    {"ml", "; "},			/* mocklisp	 */
    {"mm", ".\\\" "},			/* mm-macros	t/nroff	 */
    {"ms", ".\\\" "},			/* ms-macros	t/nroff	 */
    {"man", ".\\\" "},			/* man-macros	t/nroff	 */
    {"1", ".\\\" "},			/* feeble attempt at man pages... */
    {"2", ".\\\" "},
    {"3", ".\\\" "},
    {"4", ".\\\" "},
    {"5", ".\\\" "},
    {"6", ".\\\" "},
    {"7", ".\\\" "},
    {"8", ".\\\" "},
    {"9", ".\\\" "},
    {"p", " * "},			/* pascal	 */
    {"pas", " * "},
    {"pl", "# "},			/* perl	(conflict with Prolog) */
    {"ps", "% "},			/* postscript	 */
    {"psw", "% "},			/* postscript wrap */
    {"pswm", "% "},			/* postscript wrap */
    {"r", "# "},			/* ratfor	 */
    {"rc", " * "},			/* Microsoft Windows resource file */
    {"red", "% "},			/* psl/rlisp	 */
#ifdef __sparc__
    {"s", "! "},			/* assembler	 */
#endif
#ifdef __sparc64__
    {"s", "! "},			/* assembler	 */
#endif
#ifdef __mc68000__
    {"s", "| "},			/* assembler	 */
#endif
#ifdef __pdp11__
    {"s", "/ "},			/* assembler	 */
#endif
#ifdef __vax__
    {"s", "# "},			/* assembler	 */
#endif
#ifdef __ksr__
    {"s", "# "},			/* assembler	 */
    {"S", "# "},			/* Macro assembler */
#endif
    {"sh", "# "},			/* shell	 */
    {"sl", "% "},			/* psl		 */
    {"spec", "-- "},			/* Ada		 */
    {"tex", "% "},			/* tex		 */
    {"y", " * "},			/* yacc		 */
    {"ye", " * "},			/* yacc-efl	 */
    {"yr", " * "},			/* yacc-ratfor	 */
    {"", "# "},				/* default for empty suffix	 */
    {NULL, "# "}			/* default for unknown suffix;	 */
/* must always be last		 */
};

static char *
get_comment (user)
    char *user;
{
    char *cp, *suffix;
    char *suffix_path;
    int i;
    char *retval;

    suffix_path = xmalloc (strlen (user) + 5);
    cp = strrchr (user, '.');
    if (cp != NULL)
    {
	cp++;

	/*
	 * Convert to lower-case, since we are not concerned about the
	 * case-ness of the suffix.
	 */
	(void) strcpy (suffix_path, cp);
	for (cp = suffix_path; *cp; cp++)
	    if (isupper ((unsigned char) *cp))
		*cp = tolower (*cp);
	suffix = suffix_path;
    }
    else
	suffix = "";			/* will use the default */
    for (i = 0;; i++)
    {
	if (comtable[i].suffix == NULL)
	{
	    /* Default.  Note we'll always hit this case before we
	       ever return NULL.  */
	    retval = comtable[i].comlead;
	    break;
	}
	if (strcmp (suffix, comtable[i].suffix) == 0)
	{
	    retval = comtable[i].comlead;
	    break;
	}
    }
    free (suffix_path);
    return retval;
}

/* Create a new RCS file from scratch.

   This probably should be moved to rcs.c now that it is called from
   places outside import.c.

   Return value is 0 for success, or nonzero for failure (in which
   case an error message will have already been printed).  */
int
add_rcs_file (message, rcs, user, add_vhead, key_opt,
	      add_vbranch, vtag, targc, targv,
	      desctext, desclen, add_logfp)
    /* Log message for the addition.  Not used if add_vhead == NULL.  */
    char *message;
    /* Filename of the RCS file to create.  */
    char *rcs;
    /* Filename of the file to serve as the contents of the initial
       revision.  Even if add_vhead is NULL, we use this to determine
       the modes to give the new RCS file.  */
    char *user;

    /* Revision number of head that we are adding.  Normally 1.1 but
       could be another revision as long as ADD_VBRANCH is a branch
       from it.  If NULL, then just add an empty file without any
       revisions (similar to the one created by "rcs -i").  */
    char *add_vhead;

    /* Keyword expansion mode, e.g., "b" for binary.  NULL means the
       default behavior.  */
    char *key_opt;

    /* Vendor branch to import to, or NULL if none.  If non-NULL, then
       vtag should also be non-NULL.  */
    char *add_vbranch;
    char *vtag;
    int targc;
    char *targv[];

    /* If non-NULL, description for the file.  If NULL, the description
       will be empty.  */
    char *desctext;
    size_t desclen;

    /* Write errors to here as well as via error (), or NULL if we should
       use only error ().  */
    FILE *add_logfp;
{
    FILE *fprcs, *fpuser;
    struct stat sb;
    struct tm *ftm;
    time_t now;
    char altdate1[MAXDATELEN];
    char *author;
    int i, ierrno, err = 0;
    mode_t mode;
    char *tocvsPath;
    char *userfile;
    char *local_opt = key_opt;
    char *free_opt = NULL;
    mode_t file_type;

    if (noexec)
	return (0);

    /* Note that as the code stands now, the -k option overrides any
       settings in wrappers (whether CVSROOT/cvswrappers, -W, or
       whatever).  Some have suggested this should be the other way
       around.  As far as I know the documentation doesn't say one way
       or the other.  Before making a change of this sort, should think
       about what is best, document it (in cvs.texinfo and NEWS), &c.  */

    if (local_opt == NULL)
    {
	if (wrap_name_has (user, WRAP_RCSOPTION))
	{
	    local_opt = free_opt = wrap_rcsoption (user, 0);
	}
    }

    tocvsPath = wrap_tocvs_process_file (user);
    userfile = (tocvsPath == NULL ? user : tocvsPath);

    /* Opening in text mode is probably never the right thing for the
       server (because the protocol encodes text files in a fashion
       which does not depend on what the client or server OS is, as
       documented in cvsclient.texi), but as long as the server just
       runs on unix it is a moot point.  */

    /* If PreservePermissions is set, then make sure that the file
       is a plain file before trying to open it.  Longstanding (although
       often unpopular) CVS behavior has been to follow symlinks, so we
       maintain that behavior if PreservePermissions is not on.

       NOTE: this error message used to be `cannot fstat', but is now
       `cannot lstat'.  I don't see a way around this, since we must
       stat the file before opening it. -twp */

    if (CVS_LSTAT (userfile, &sb) < 0)
    {
	/* not fatal, continue import */
	if (add_logfp != NULL)
	    fperrmsg (add_logfp, 0, errno,
			  "ERROR: cannot lstat file %s", userfile);
	error (0, errno, "cannot lstat file %s", userfile);
	goto read_error;
    }
    file_type = sb.st_mode & S_IFMT;

    fpuser = NULL;
    if (!preserve_perms || file_type == S_IFREG)
    {
	fpuser = CVS_FOPEN (userfile,
			    ((local_opt != NULL && strcmp (local_opt, "b") == 0)
			     ? "rb"
			     : "r")
	    );
	if (fpuser == NULL)
	{
	    /* not fatal, continue import */
	    if (add_logfp != NULL)
		fperrmsg (add_logfp, 0, errno,
			  "ERROR: cannot read file %s", userfile);
	    error (0, errno, "ERROR: cannot read file %s", userfile);
	    goto read_error;
	}
    }

    fprcs = CVS_FOPEN (rcs, "w+b");
    if (fprcs == NULL)
    {
	ierrno = errno;
	goto write_error_noclose;
    }

    /*
     * putadmin()
     */
    if (add_vhead != NULL)
    {
	if (fprintf (fprcs, "head     %s;\012", add_vhead) < 0)
	    goto write_error;
    }
    else
    {
	if (fprintf (fprcs, "head     ;\012") < 0)
	    goto write_error;
    }

    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "branch   %s;\012", add_vbranch) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, "access   ;\012") < 0 ||
	fprintf (fprcs, "symbols  ") < 0)
    {
	goto write_error;
    }

    for (i = targc - 1; i >= 0; i--)
    {
	/* RCS writes the symbols backwards */
	assert (add_vbranch != NULL);
	if (fprintf (fprcs, "%s:%s.1 ", targv[i], add_vbranch) < 0)
	    goto write_error;
    }

    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "%s:%s", vtag, add_vbranch) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, ";\012") < 0)
	goto write_error;

    if (fprintf (fprcs, "locks    ; strict;\012") < 0 ||
	/* XXX - make sure @@@@ processing works in the RCS file */
	fprintf (fprcs, "comment  @@%s@@;\012", get_comment (user)) < 0)
    {
	goto write_error;
    }

    if (local_opt != NULL)
    {
	if (fprintf (fprcs, "expand   @@%s@@;\012", local_opt) < 0)
	{
	    goto write_error;
	}
    }

    if (fprintf (fprcs, "\012") < 0)
      goto write_error;

    /* Write the revision(s), with the date and author and so on
       (that is "delta" rather than "deltatext" from rcsfile(5)).  */
    if (add_vhead != NULL)
    {
	if (use_file_modtime)
	    now = sb.st_mtime;
	else
	    (void) time (&now);
	ftm = gmtime (&now);
	(void) sprintf (altdate1, DATEFORM,
			ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
			ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
			ftm->tm_min, ftm->tm_sec);
	author = getcaller ();

	if (fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
	fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
		 altdate1, author) < 0)
	goto write_error;

	if (fprintf (fprcs, "branches") < 0)
	    goto write_error;
	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, " %s.1", add_vbranch) < 0)
		goto write_error;
	}
	if (fprintf (fprcs, ";\012") < 0)
	    goto write_error;

	if (fprintf (fprcs, "next     ;\012") < 0)
	    goto write_error;

	if (fprintf (fprcs, "commitid        %s;\012", global_session_id) < 0)
	    goto write_error;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	/* Store initial permissions if necessary. */
	if (preserve_perms)
	{
	    if (file_type == S_IFLNK)
	    {
		char *link = xreadlink (userfile);
		if (fprintf (fprcs, "symlink\t@@") < 0 ||
		    expand_at_signs (link, strlen (link), fprcs) < 0 ||
		    fprintf (fprcs, "@@;\012") < 0)
		    goto write_error;
		free (link);
	    }
	    else
	    {
		if (fprintf (fprcs, "owner\t%u;\012", sb.st_uid) < 0)
		    goto write_error;
		if (fprintf (fprcs, "group\t%u;\012", sb.st_gid) < 0)
		    goto write_error;
		if (fprintf (fprcs, "permissions\t%o;\012",
			     sb.st_mode & 07777) < 0)
		    goto write_error;
		switch (file_type)
		{
		    case S_IFREG: break;
		    case S_IFCHR:
		    case S_IFBLK:
#ifdef HAVE_ST_RDEV
			if (fprintf (fprcs, "special\t%s %lu;\012",
				     (file_type == S_IFCHR
				      ? "character"
				      : "block"),
				     (unsigned long) sb.st_rdev) < 0)
			    goto write_error;
#else
			error (0, 0,
"can't import %s: unable to import device files on this system",
userfile);
#endif
			break;
		    default:
			error (0, 0,
			       "can't import %s: unknown kind of special file",
			       userfile);
		}
	    }
	}
#endif

	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
		fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
			 altdate1, author) < 0 ||
		fprintf (fprcs, "branches ;\012") < 0 ||
		fprintf (fprcs, "next     ;\012") < 0 ||
		fprintf (fprcs, "commitid        %s;\012", global_session_id) < 0
		)
		goto write_error;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    /* Store initial permissions if necessary. */
	    if (preserve_perms)
	    {
		if (file_type == S_IFLNK)
		{
		    char *link = xreadlink (userfile);
		    if (fprintf (fprcs, "symlink\t@@") < 0 ||
			expand_at_signs (link, strlen (link), fprcs) < 0 ||
			fprintf (fprcs, "@@;\012") < 0)
			goto write_error;
		    free (link);
		}
		else
		{
		    if (fprintf (fprcs, "owner\t%u;\012", sb.st_uid) < 0 ||
			fprintf (fprcs, "group\t%u;\012", sb.st_gid) < 0 ||
			fprintf (fprcs, "permissions\t%o;\012",
				 sb.st_mode & 07777) < 0)
			goto write_error;
	    
		    switch (file_type)
		    {
			case S_IFREG: break;
			case S_IFCHR:
			case S_IFBLK:
#ifdef HAVE_ST_RDEV
			    if (fprintf (fprcs, "special\t%s %lu;\012",
					 (file_type == S_IFCHR
					  ? "character"
					  : "block"),
					 (unsigned long) sb.st_rdev) < 0)
				goto write_error;
#else
			    error (0, 0,
"can't import %s: unable to import device files on this system",
userfile);
#endif
			    break;
			default:
			    error (0, 0,
			      "cannot import %s: special file of unknown type",
			       userfile);
		    }
		}
	    }
#endif

	    if (fprintf (fprcs, "\012") < 0)
		goto write_error;
	}
    }

    /* Now write the description (possibly empty).  */
    if (fprintf (fprcs, "\012desc\012") < 0 ||
	fprintf (fprcs, "@@") < 0)
	goto write_error;
    if (desctext != NULL)
    {
	/* The use of off_t not size_t for the second argument is very
	   strange, since we are dealing with something which definitely
	   fits in memory.  */
	if (expand_at_signs (desctext, (off_t) desclen, fprcs) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, "@@\012\012\012") < 0)
	goto write_error;

    /* Now write the log messages and contents for the revision(s) (that
       is, "deltatext" rather than "delta" from rcsfile(5)).  */
    if (add_vhead != NULL)
    {
	if (fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
	    fprintf (fprcs, "log\012@@") < 0)
	    goto write_error;
	if (add_vbranch != NULL)
	{
	    /* We are going to put the log message in the revision on the
	       branch.  So putting it here too seems kind of redundant, I
	       guess (and that is what CVS has always done, anyway).  */
	    if (fprintf (fprcs, "Initial revision\012") < 0)
		goto write_error;
	}
	else
	{
	    if (expand_at_signs (message, (off_t) strlen (message), fprcs) < 0)
		goto write_error;
	}
	if (fprintf (fprcs, "@@\012") < 0 ||
	    fprintf (fprcs, "text\012@@") < 0)
	{
	    goto write_error;
	}

	/* Now copy over the contents of the file, expanding at signs.
	   If preserve_perms is set, do this only for regular files. */
	if (!preserve_perms || file_type == S_IFREG)
	{
	    char buf[8192];
	    unsigned int len;

	    while (1)
	    {
		len = fread (buf, 1, sizeof buf, fpuser);
		if (len == 0)
		{
		    if (ferror (fpuser))
			error (1, errno, "cannot read file %s for copying",
			       user);
		    break;
		}
		if (expand_at_signs (buf, len, fprcs) < 0)
		    goto write_error;
	    }
	}
	if (fprintf (fprcs, "@@\012\012") < 0)
	    goto write_error;
	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
		fprintf (fprcs, "log\012@@") < 0 ||
		expand_at_signs (message,
				 (off_t) strlen (message), fprcs) < 0 ||
		fprintf (fprcs, "@@\012text\012") < 0 ||
		fprintf (fprcs, "@@@@\012") < 0)
		goto write_error;
	}
    }

    if (fclose (fprcs) == EOF)
    {
	ierrno = errno;
	goto write_error_noclose;
    }
    /* Close fpuser only if we opened it to begin with. */
    if (fpuser != NULL)
    {
	if (fclose (fpuser) < 0)
	    error (0, errno, "cannot close %s", user);
    }

    /*
     * Fix the modes on the RCS files.  The user modes of the original
     * user file are propagated to the group and other modes as allowed
     * by the repository umask, except that all write permissions are
     * turned off.
     */
    mode = (sb.st_mode |
	    (sb.st_mode & S_IRWXU) >> 3 |
	    (sb.st_mode & S_IRWXU) >> 6) &
	   ~cvsumask &
	   ~(S_IWRITE | S_IWGRP | S_IWOTH);
    if (chmod (rcs, mode) < 0)
    {
	ierrno = errno;
	if (add_logfp != NULL)
	    fperrmsg (add_logfp, 0, ierrno,
		      "WARNING: cannot change mode of file %s", rcs);
	error (0, ierrno, "WARNING: cannot change mode of file %s", rcs);
	err++;
    }
    if (tocvsPath)
	if (unlink_file_dir (tocvsPath) < 0)
		error (0, errno, "cannot remove %s", tocvsPath);
    if (free_opt != NULL)
	free (free_opt);
    return (err);

write_error:
    ierrno = errno;
    if (fclose (fprcs) < 0)
	error (0, errno, "cannot close %s", rcs);
write_error_noclose:
    if (fclose (fpuser) < 0)
	error (0, errno, "cannot close %s", user);
    if (add_logfp != NULL)
	fperrmsg (add_logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
    error (0, ierrno, "ERROR: cannot write file %s", rcs);
    if (ierrno == ENOSPC)
    {
	if (CVS_UNLINK (rcs) < 0)
	    error (0, errno, "cannot remove %s", rcs);
	if (add_logfp != NULL)
	    fperrmsg (add_logfp, 0, 0, "ERROR: out of space - aborting");
	error (1, 0, "ERROR: out of space - aborting");
    }
read_error:
    if (tocvsPath)
	if (unlink_file_dir (tocvsPath) < 0)
	    error (0, errno, "cannot remove %s", tocvsPath);

    if (free_opt != NULL)
	free (free_opt);

    return (err + 1);
}

/*
 * Write SIZE bytes at BUF to FP, expanding @@ signs into double @@
 * signs.  If an error occurs, return a negative value and set errno
 * to indicate the error.  If not, return a nonnegative value.
 */
int
expand_at_signs (buf, size, fp)
    char *buf;
    off_t size;
    FILE *fp;
{
    register char *cp, *next;

    cp = buf;
    while ((next = memchr (cp, '@@', size)) != NULL)
    {
	int len;

	++next;
	len = next - cp;
	if (fwrite (cp, 1, len, fp) != len)
	    return EOF;
	if (putc ('@@', fp) == EOF)
	    return EOF;
	cp = next;
	size -= len;
    }

    if (fwrite (cp, 1, size, fp) != size)
	return EOF;

    return 1;
}

/*
 * Write an update message to (potentially) the screen and the log file.
 */
static void
add_log (ch, fname)
    int ch;
    char *fname;
{
    if (!really_quiet)			/* write to terminal */
    {
	char buf[2];
	buf[0] = ch;
	buf[1] = ' ';
	cvs_output (buf, 2);
	if (repos_len)
	{
	    cvs_output (repository + repos_len + 1, 0);
	    cvs_output ("/", 1);
	}
	else if (repository[0] != '\0')
	{
	    cvs_output (repository, 0);
	    cvs_output ("/", 1);
	}
	cvs_output (fname, 0);
	cvs_output ("\n", 1);
    }

    if (repos_len)			/* write to logfile */
	(void) fprintf (logfp, "%c %s/%s\n", ch,
			repository + repos_len + 1, fname);
    else if (repository[0])
	(void) fprintf (logfp, "%c %s/%s\n", ch, repository, fname);
    else
	(void) fprintf (logfp, "%c %s\n", ch, fname);
}

/*
 * This is the recursive function that walks the argument directory looking
 * for sub-directories that have CVS administration files in them and updates
 * them recursively.
 * 
 * Note that we do not follow symbolic links here, which is a feature!
 */
static int
import_descend_dir (message, dir, vtag, targc, targv)
    char *message;
    char *dir;
    char *vtag;
    int targc;
    char *targv[];
{
    struct saved_cwd cwd;
    char *cp;
    int ierrno, err;
    char *rcs = NULL;

    if (islink (dir))
	return (0);
    if (save_cwd (&cwd))
    {
	fperrmsg (logfp, 0, 0, "ERROR: cannot get working directory");
	return (1);
    }

    /* Concatenate DIR to the end of REPOSITORY.  */
    if (repository[0] == '\0')
    {
	char *new = xstrdup (dir);
	free (repository);
	repository = new;
    }
    else
    {
	char *new = xmalloc (strlen (repository) + strlen (dir) + 10);
	strcpy (new, repository);
	(void) strcat (new, "/");
	(void) strcat (new, dir);
	free (repository);
	repository = new;
    }

#ifdef CLIENT_SUPPORT
    if (!quiet && !current_parsed_root->isremote)
#else
    if (!quiet)
#endif
	error (0, 0, "Importing %s", repository);

    if ( CVS_CHDIR (dir) < 0)
    {
	ierrno = errno;
	fperrmsg (logfp, 0, ierrno, "ERROR: cannot chdir to %s", repository);
	error (0, ierrno, "ERROR: cannot chdir to %s", repository);
	err = 1;
	goto out;
    }
#ifdef CLIENT_SUPPORT
    if (!current_parsed_root->isremote && !isdir (repository))
#else
    if (!isdir (repository))
#endif
    {
	rcs = xmalloc (strlen (repository) + sizeof (RCSEXT) + 5);
	(void) sprintf (rcs, "%s%s", repository, RCSEXT);
	if (isfile (repository) || isfile(rcs))
	{
	    fperrmsg (logfp, 0, 0,
		      "ERROR: %s is a file, should be a directory!",
		      repository);
	    error (0, 0, "ERROR: %s is a file, should be a directory!",
		   repository);
	    err = 1;
	    goto out;
	}
	if (noexec == 0 && CVS_MKDIR (repository, 0777) < 0)
	{
	    ierrno = errno;
	    fperrmsg (logfp, 0, ierrno,
		      "ERROR: cannot mkdir %s -- not added", repository);
	    error (0, ierrno,
		   "ERROR: cannot mkdir %s -- not added", repository);
	    err = 1;
	    goto out;
	}
    }
    err = import_descend (message, vtag, targc, targv);
  out:
    if (rcs != NULL)
	free (rcs);
    if ((cp = strrchr (repository, '/')) != NULL)
	*cp = '\0';
    else
	repository[0] = '\0';
    if (restore_cwd (&cwd, NULL))
	error_exit ();
    free_cwd (&cwd);
    return (err);
}
@


1.7
log
@backport commitid support from newer CVS (with a different random id
generator)

writing a commitid is currently disabled

ok deraadt
@
text
@a1200 1
#ifdef notyet
a1202 1
#endif
d1259 1
a1259 3
		fprintf (fprcs, "next     ;\012") < 0
#ifdef notyet
		||
a1260 1
#endif
@


1.6
log
@handle sparc64 seperately; ok miod
@
text
@d1201 5
d1261 6
a1266 1
		fprintf (fprcs, "next     ;\012") < 0)
@


1.5
log
@Merge local changes; work in progress
@
text
@d902 3
@


1.4
log
@Integrate local changes
@
text
@d174 1
a174 1
	if (CVSroot_directory == NULL)
d180 5
a184 4
	repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0])
			      + 10);
	(void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
	repos_len = strlen (CVSroot_directory);
d211 1
a211 1
    if (client_active)
d240 1
a240 1
    if (client_active)
d294 1
a294 2
    tmpfile = cvs_temp_name ();
    if ((logfp = CVS_FOPEN (tmpfile, "w+")) == NULL)
d428 1
a428 1
	while ((dp = readdir (dirp)) != NULL)
d479 1
a479 1
		if (client_active)
d499 1
a499 1
	(void) closedir (dirp);
d1570 1
a1570 1
    if (!quiet && !client_active)
d1585 1
a1585 1
    if (!client_active && !isdir (repository))
@


1.3
log
@Integrate local changes
@
text
@d269 5
d280 5
d466 4
a469 1
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN &&
d471 1
a471 1
		islink (dp->d_name))
d741 2
a742 2
	    fperror (logfp, 0, status == -1 ? ierrno : 0,
		     "ERROR: Check-in of %s failed", rcs->path);
d781 2
a782 2
	fperror (logfp, 0, retcode == -1 ? ierrno : 0,
		 "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
d805 3
a807 3
	    fperror (logfp, 0, retcode == -1 ? ierrno : 0,
		     "WARNING: Couldn't add tag %s to %s", targv[i],
		     rcs->path);
d1070 8
a1077 1
	error (1, errno, "cannot lstat %s", user);
d1092 2
a1093 2
		fperror (add_logfp, 0, errno,
			 "ERROR: cannot read file %s", userfile);
d1225 1
d1232 5
d1282 1
d1289 5
d1412 2
a1413 2
	    fperror (add_logfp, 0, ierrno,
		     "WARNING: cannot change mode of file %s", rcs);
d1432 1
a1432 1
	fperror (add_logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
d1439 1
a1439 1
	    fperror (add_logfp, 0, 0, "ERROR: out of space - aborting");
d1548 1
a1548 1
	fperror (logfp, 0, 0, "ERROR: cannot get working directory");
d1579 1
a1579 1
	fperror (logfp, 0, ierrno, "ERROR: cannot chdir to %s", repository);
d1594 3
a1596 3
	    fperror (logfp, 0, 0,
		     "ERROR: %s is a file, should be a directory!",
		     repository);
d1605 2
a1606 2
	    fperror (logfp, 0, ierrno,
		     "ERROR: cannot mkdir %s -- not added", repository);
@


1.2
log
@ARCH -> __ARCH_
@
text
@d171 2
a172 1
    if (! isabsolute (argv[0]))
d187 5
a191 3
	repository = xmalloc (strlen (argv[0]) + 5);
	(void) strcpy (repository, argv[0]);
	repos_len = 0;
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS 1.4 kit.
d20 2
a21 8
#include "save-cwd.h"

#ifndef lint
static const char rcsid[] = "$CVSid: @@(#)import.c 1.63 94/09/30 $";
USE(rcsid);
#endif

#define	FILE_HOLDER	".#cvsxxx"
d24 3
a26 5
static int add_rcs_file PROTO((char *message, char *rcs, char *user, char *vtag,
		         int targc, char *targv[]));
static int expand_at_signs PROTO((char *buf, off_t size, FILE *fp));
static int add_rev PROTO((char *message, char *rcs, char *vfile, char *vers));
static int add_tags PROTO((char *rcs, char *vfile, char *vtag, int targc,
d38 2
a39 2
static char vhead[50];
static char vbranch[50];
d41 1
a41 1
static char repository[PATH_MAX];
d56 1
d66 1
a66 1
    char tmpfile[L_tmpnam+1];
d71 1
d79 3
a81 3
    (void) strcpy (vbranch, CVSBRANCH);
    optind = 1;
    while ((c = getopt (argc, argv, "Qqdb:m:I:k:W:")) != -1)
d97 11
d111 2
a112 1
		(void) strcpy (vbranch, optarg);
d116 1
a116 1
		use_editor = TRUE;
d118 1
a118 1
		use_editor = FALSE;
d129 1
a129 1
		free (RCS_check_kflag(optarg));	
d146 14
d161 3
d165 4
d173 1
a173 1
	if (CVSroot == NULL)
d179 4
a182 2
	(void) sprintf (repository, "%s/%s", CVSroot, argv[0]);
	repos_len = strlen (CVSroot);
d186 1
d198 1
a198 1
	if (!isdigit (*cp) && *cp != '.')
d202 1
a202 1
    (void) strcpy (vhead, vbranch);
d209 2
a210 3
	/* Do this now; don't ask for a log message if we can't talk to the
	   server.  But if there is a syntax error in the options, give
	   an error message without connecting.  */
d218 1
a218 1
		   (List *) NULL); 
d220 1
a220 1

d225 1
a239 5
	ign_setup ();

	if (use_file_modtime)
	    send_arg("-d");

d246 9
d266 1
a266 2
	if (fprintf (to_server, "import\n") < 0)
	    error (1, errno, "writing to server");
d276 1
a276 1
    (void) umask (2);
d280 2
a281 1
    if ((logfp = fopen (tmpnam (tmpfile), "w+")) == NULL)
d283 5
a287 1
    (void) unlink (tmpfile);		/* to be sure it goes away */
d300 32
a331 5
	    (void) printf ("\n%d conflicts created by this import.\n",
			   conflicts);
	    (void) printf ("Use the following command to help the merge:\n\n");
	    (void) printf ("\t%s checkout -j%s:yesterday -j%s %s\n\n",
			   program_name, argv[1], argv[1], argv[0]);
d334 5
d343 3
a345 2
	(void) fprintf (logfp, "\t%s checkout -j%s:yesterday -j%s %s\n\n",
			program_name, argv[1], argv[1], argv[0]);
d350 1
a350 1
	    (void) printf ("\nNo conflicts created by this import\n\n");
d362 5
a366 1
    p->data = (char *) T_TITLE;
d368 1
a368 1
    Update_Logfile (repository, message, vbranch, logfp, ulist);
d370 2
a371 1
    (void) fclose (logfp);
d375 3
a377 1
    unlink (tmpfile);
d381 3
d388 3
a390 3
/*
 * process all the files in ".", then descend into other directories.
 */
d407 1
a407 1
    if ((dirp = opendir (".")) == NULL)
d409 1
d414 1
d418 8
a425 1
		continue;
a427 8
#ifdef SERVER_SUPPORT
		/* CVS directories are created by server.c because it doesn't
		   special-case import.  So don't print a message about them.
		   Do print a message about other ignored files (although
		   most of these will get ignored on the client side).  */
		if (server_active && strcmp (dp->d_name, CVSADM) == 0)
		    continue;
#endif
d429 1
a429 1
		continue;
d441 1
a441 1
            {	
d453 1
a453 1
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN && 
d465 5
a469 2
							   vtag, targc, targv,
							   repository);
d475 7
d486 1
a486 1
    if (dirlist != NULL) 
d513 1
a513 2
    char attic_name[PATH_MAX];
    char rcs[PATH_MAX];
d516 2
d521 4
d529 3
d533 1
d539 38
a576 1
	    return (add_rcs_file (message, rcs, vfile, vtag, targc, targv));
d578 1
d582 1
a603 2
    int ierrno;
    char *tmpdir;
d605 1
d607 10
a616 3
    vers = Version_TS (repository, (char *) NULL, vbranch, (char *) NULL, vfile,
		       1, 0, (List *) NULL, (List *) NULL);
#ifdef DEATH_SUPPORT
a618 3
#else
    if (vers->vn_rcs != NULL)
#endif
a619 1
	char xtmpfile[PATH_MAX];
a620 7
	int retcode = 0;

	tmpdir = getenv ("TMPDIR");
	if (tmpdir == NULL || tmpdir[0] == '\0') 
	  tmpdir = "/tmp";

	(void) sprintf (xtmpfile, "%s/cvs-imp%d", tmpdir, getpid());
a630 20
#ifdef HAVE_RCS5
	run_setup ("%s%s -q -f -r%s -p -ko", Rcsbin, RCS_CO, vers->vn_rcs);
#else
	run_setup ("%s%s -q -f -r%s -p", Rcsbin, RCS_CO, vers->vn_rcs);
#endif
	run_arg (vers->srcfile->path);
	if ((retcode = run_exec (RUN_TTY, xtmpfile, RUN_TTY,
				 RUN_NORMAL|RUN_REALLY)) != 0)
	{
	    ierrno = errno;
	    fperror (logfp, 0, retcode == -1 ? ierrno : 0,
		     "ERROR: cannot co revision %s of file %s", vers->vn_rcs,
		     vers->srcfile->path);
	    error (0, retcode == -1 ? ierrno : 0,
		   "ERROR: cannot co revision %s of file %s", vers->vn_rcs,
		   vers->srcfile->path);
	    (void) unlink_file (xtmpfile);
	    return (1);
	}

d632 3
a634 1
	different = xcmp (xtmpfile, vfile);
a638 1
	(void) unlink_file (xtmpfile);
d648 1
a648 1
	    if (add_tags (vers->srcfile->path, vfile, vtag, targc, targv))
d658 2
a659 2
	add_rev (message, vers->srcfile->path, vfile, vers->vn_rcs) ||
	add_tags (vers->srcfile->path, vfile, vtag, targc, targv))
d685 1
a685 1
    char *rcs;
a690 1
    struct stat vfile_stat;
d701 6
a706 5
        if (RCS_lock (rcs, vbranch, 1) != 0)
	{
	    error (0, errno, "fork failed");
	    return (1);
	}
d708 1
d712 4
a715 19
    /* We used to deposit the revision with -r; RCS would delete the
       working file, but we'd keep a hard link to it, and rename it
       back after running RCS (ooh, atomicity).  However, that
       strategy doesn't work on operating systems without hard links
       (like Windows NT).  Instead, let's deposit it using -u, and
       restore its permission bits afterwards.  This also means the
       file always exists under its own name.  */
    if (! tocvsPath)
        stat (vfile, &vfile_stat);

    run_setup ("%s%s -q -f %s%s", Rcsbin, RCS_CI, 
	       (tocvsPath ? "-r" : "-u"),
	       vbranch);
    run_args ("-m%s", make_message_rcslegal (message));
    if (use_file_modtime)
	run_arg ("-d");
    run_arg (tocvsPath == NULL ? vfile : tocvsPath);
    run_arg (rcs);
    status = run_exec (RUN_TTY, RUN_TTY, RUN_TTY, RUN_NORMAL);
d718 2
a719 3
    /* Restore the permissions on vfile.  */
    if (! tocvsPath)
        chmod (vfile, vfile_stat.st_mode);
d725 4
a728 2
	    fperror (logfp, 0, status == -1 ? ierrno : 0, "ERROR: Check-in of %s failed", rcs);
	    error (0, status == -1 ? ierrno : 0, "ERROR: Check-in of %s failed", rcs);
d733 1
d748 1
a748 1
    char *rcs;
d757 1
d765 2
a766 2
	fperror (logfp, 0, retcode == -1 ? ierrno : 0, 
		 "ERROR: Failed to set tag %s in %s", vtag, rcs);
d768 1
a768 1
	       "ERROR: Failed to set tag %s in %s", vtag, rcs);
d771 11
a781 2
    vers = Version_TS (repository, (char *) NULL, vtag, (char *) NULL, vfile,
		       1, 0, (List *) NULL, (List *) NULL);
d784 3
a786 1
	if ((retcode = RCS_settag (rcs, targv[i], vers->vn_rcs)) != 0)
d789 3
a791 2
	    fperror (logfp, 0, retcode == -1 ? ierrno : 0, 
		     "WARNING: Couldn't add tag %s to %s", targv[i], rcs);
d793 2
a794 1
		   "WARNING: Couldn't add tag %s to %s", targv[i], rcs);
d818 4
d828 1
d842 1
d849 1
d859 1
d881 1
d883 1
a883 1
#ifdef sparc
d886 1
a886 1
#ifdef mc68000
d889 1
a889 1
#ifdef pdp11
d892 1
a892 1
#ifdef vax
a905 3
#ifdef SYSTEM_COMMENT_TABLE
    SYSTEM_COMMENT_TABLE
#endif
d916 1
a916 1
    char suffix_path[PATH_MAX];
d918 1
d920 1
d932 1
a932 1
	    if (isupper (*cp))
d940 7
a946 2
	if (comtable[i].suffix == NULL)	/* default */
	    return (comtable[i].comlead);
d948 4
a951 1
	    return (comtable[i].comlead);
d953 2
d957 12
a968 2
static int
add_rcs_file (message, rcs, user, vtag, targc, targv)
d970 1
d972 3
d976 14
d993 9
d1007 2
a1008 5
    char altdate1[50];
#ifndef HAVE_RCS5
    char altdate2[50];
#endif
    char *author, *buf;
d1013 3
d1020 15
a1034 6
#ifdef LINES_CRLF_TERMINATED
    /* There exits a port of RCS to such a system that stores files with
       straight newlines.  If we ever reach this point on such a system,
       we'll need to decide what to do with the open_file call below.  */
    abort ();
#endif
d1037 37
a1073 6
    fpuser = fopen (userfile, "r");
    if (fpuser == NULL) {
	/* not fatal, continue import */
	fperror (logfp, 0, errno, "ERROR: cannot read file %s", userfile);
	error (0, errno, "ERROR: cannot read file %s", userfile);
	goto read_error;
d1075 4
a1078 2
    fprcs = fopen (rcs, "w+");
    if (fprcs == NULL) {
d1086 17
a1102 3
    if (fprintf (fprcs, "head     %s;\n", vhead) < 0 ||
	fprintf (fprcs, "branch   %s;\n", vbranch) < 0 ||
	fprintf (fprcs, "access   ;\n") < 0 ||
d1108 11
a1118 2
    for (i = targc - 1; i >= 0; i--)	/* RCS writes the symbols backwards */
	if (fprintf (fprcs, "%s:%s.1 ", targv[i], vbranch) < 0)
d1120 3
d1124 1
a1124 2
    if (fprintf (fprcs, "%s:%s;\n", vtag, vbranch) < 0 ||
	fprintf (fprcs, "locks    ; strict;\n") < 0 ||
d1126 1
a1126 1
	fprintf (fprcs, "comment  @@%s@@;\n", get_comment (user)) < 0)
d1131 3
a1133 2
    if (keyword_opt != NULL)
      if (fprintf (fprcs, "expand   @@%s@@;\n", keyword_opt) < 0)
d1135 1
a1135 1
	  goto write_error;
d1137 1
d1139 1
a1139 1
    if (fprintf (fprcs, "\n") < 0)
d1142 74
a1215 13
    /*
     * puttree()
     */
    if (fstat (fileno (fpuser), &sb) < 0)
	error (1, errno, "cannot fstat %s", user);
    if (use_file_modtime)
	now = sb.st_mtime;
    else
	(void) time (&now);
#ifdef HAVE_RCS5
    ftm = gmtime (&now);
#else
    ftm = localtime (&now);
d1217 50
a1266 17
    (void) sprintf (altdate1, DATEFORM,
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
#ifdef HAVE_RCS5
#define	altdate2 altdate1
#else
    /*
     * If you don't have RCS V5 or later, you need to lie about the ci
     * time, since RCS V4 and earlier insist that the times differ.
     */
    now++;
    ftm = localtime (&now);
    (void) sprintf (altdate2, DATEFORM,
		    ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
		    ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
		    ftm->tm_min, ftm->tm_sec);
a1267 1
    author = getcaller ();
d1269 10
a1278 22
    if (fprintf (fprcs, "\n%s\n", vhead) < 0 ||
	fprintf (fprcs, "date     %s;  author %s;  state Exp;\n",
		 altdate1, author) < 0 ||
	fprintf (fprcs, "branches %s.1;\n", vbranch) < 0 ||
	fprintf (fprcs, "next     ;\n") < 0 ||
	fprintf (fprcs, "\n%s.1\n", vbranch) < 0 ||
	fprintf (fprcs, "date     %s;  author %s;  state Exp;\n",
		 altdate2, author) < 0 ||
	fprintf (fprcs, "branches ;\n") < 0 ||
	fprintf (fprcs, "next     ;\n\n") < 0 ||
	/*
	 * putdesc()
	 */
	fprintf (fprcs, "\ndesc\n") < 0 ||
	fprintf (fprcs, "@@@@\n\n\n") < 0 ||
	/*
	 * putdelta()
	 */
	fprintf (fprcs, "\n%s\n", vhead) < 0 ||
	fprintf (fprcs, "log\n") < 0 ||
	fprintf (fprcs, "@@Initial revision\n@@\n") < 0 ||
	fprintf (fprcs, "text\n@@") < 0)
d1280 7
a1287 1
    }
d1289 3
a1291 1
    if (sb.st_size > 0)
d1293 21
a1313 1
	off_t size;
d1315 3
a1317 5
	size = sb.st_size;
	buf = xmalloc ((int) size);
	if (fread (buf, (int) size, 1, fpuser) != 1)
	    error (1, errno, "cannot read file %s for copying", user);
	if (expand_at_signs (buf, size, fprcs) < 0)
d1319 18
a1336 1
	    free (buf);
d1338 9
a1347 10
	free (buf);
    }
    if (fprintf (fprcs, "@@\n\n") < 0 ||
	fprintf (fprcs, "\n%s.1\n", vbranch) < 0 ||
	fprintf (fprcs, "log\n@@") < 0 ||
	expand_at_signs (message, (off_t) strlen (message), fprcs) < 0 ||
	fprintf (fprcs, "@@\ntext\n") < 0 ||
	fprintf (fprcs, "@@@@\n") < 0)
    {
	goto write_error;
d1349 1
d1355 6
a1360 1
    (void) fclose (fpuser);
d1363 3
a1365 2
     * Fix the modes on the RCS files.  They must maintain the same modes as
     * the original user file, except that all write permissions must be
d1368 5
a1372 1
    mode = sb.st_mode & ~(S_IWRITE | S_IWGRP | S_IWOTH);
d1376 3
a1378 2
	fperror (logfp, 0, ierrno,
		 "WARNING: cannot change mode of file %s", rcs);
d1385 2
d1391 2
a1392 1
    (void) fclose (fprcs);
d1394 4
a1397 2
    (void) fclose (fpuser);
    fperror (logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
d1401 4
a1404 2
	(void) unlink (rcs);
	fperror (logfp, 0, 0, "ERROR: out of space - aborting");
d1412 3
d1423 1
a1423 1
static int
d1429 1
a1429 1
    char *cp, *end;
d1431 2
a1432 1
    for (cp = buf, end = buf + size; cp < end; cp++)
d1434 10
a1443 7
	if (*cp == '@@')
	{
	    if (putc ('@@', fp) == EOF)
		return EOF;
	}
	if (putc (*cp, fp) == EOF)
	    return (EOF);
d1445 5
a1449 1
    return (1);
d1462 4
d1467 11
a1477 5
	    (void) printf ("%c %s/%s\n", ch, repository + repos_len + 1, fname);
	else if (repository[0])
	    (void) printf ("%c %s/%s\n", ch, repository, fname);
	else
	    (void) printf ("%c %s\n", ch, fname);
d1507 1
d1516 2
d1519 5
a1523 1
	(void) strcpy (repository, dir);
d1526 6
a1531 2
	(void) strcat (repository, "/");
	(void) strcat (repository, dir);
d1533 1
a1538 6
#ifdef SERVER_SUPPORT
	/* Needs to go on stdout, not stderr, to avoid being interspersed
	   with the add_log messages.  */
	printf ("%s %s: Importing %s\n",
		program_name, command_name, repository);
#else
a1539 1
#endif
d1541 1
a1541 1
    if (chdir (dir) < 0)
d1555 3
a1557 1
	if (isfile (repository))
d1559 2
a1560 1
	    fperror (logfp, 0, 0, "ERROR: %s is a file, should be a directory!",
d1580 2
d1587 1
a1587 1
      exit (1);
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d210 2
a220 8
	/* The only ignore processing which takes place on the server side
	   is the CVSROOT/cvsignore file.  But if the user specified -I !,
	   the documented behavior is to not process said file.  */
	if (ign_inhibit_server)
	{
	    send_arg ("-I");
	    send_arg ("!");
	}
d232 2
a233 1
	send_to_server ("import\012", 0);
d243 1
a243 1
    (void) umask (cvsumask);
d336 2
d339 6
a344 5
	    /* CVS directories are created in the temp directory by
	       server.c because it doesn't special-case import.  So
	       don't print a message about them, regardless of -I!.  */
	    if (server_active && strcmp (dp->d_name, CVSADM) == 0)
		continue;
a345 2
	    if (ign_name (dp->d_name))
	    {
d575 1
a593 21
    if (tocvsPath == NULL)
    {
	/* We play with hard links rather than passing -u to ci to avoid
	   expanding RCS keywords (see test 106.5 in sanity.sh).  */
	if (link_file (vfile, FILE_HOLDER) < 0)
	{
	    if (errno == EEXIST)
	    {
		(void) unlink_file (FILE_HOLDER);
		(void) link_file (vfile, FILE_HOLDER);
	    }
	    else
	    {
		ierrno = errno;
		fperror (logfp, 0, ierrno,
			 "ERROR: cannot create link to %s", vfile);
		error (0, ierrno, "ERROR: cannot create link to %s", vfile);
		return (1);
	    }
	}
    }
d595 13
a607 1
    run_setup ("%s%s -q -f -r%s", Rcsbin, RCS_CI, vbranch);
d616 3
a618 5
    if (tocvsPath == NULL)
	rename_file (FILE_HOLDER, vfile);
    else
	if (unlink_file_dir (tocvsPath) < 0)
		error (0, errno, "cannot remove %s", tocvsPath);
d992 2
a993 3
     * Fix the modes on the RCS files.  The user modes of the original
     * user file are propagated to the group and other modes as allowed
     * by the repository umask, except that all write permissions are
d996 1
a996 5
    mode = (sb.st_mode |
	    (sb.st_mode & S_IRWXU) >> 3 |
	    (sb.st_mode & S_IRWXU) >> 6) &
	   ~cvsumask &
	   ~(S_IWRITE | S_IWGRP | S_IWOTH);
a1043 1
    errno = 0;
d1048 1
a1048 1
	    if (putc ('@@', fp) == EOF && errno != 0)
d1051 1
a1051 1
	if (putc (*cp, fp) == EOF && errno != 0)
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d20 6
a25 1
#include "savecwd.h"
d267 5
a271 15
	    char buf[80];
	    sprintf (buf, "\n%d conflicts created by this import.\n",
		     conflicts);
	    cvs_output (buf, 0);
	    cvs_output ("Use the following command to help the merge:\n\n",
			0);
	    cvs_output ("\t", 1);
	    cvs_output (program_name, 0);
	    cvs_output (" checkout -j", 0);
	    cvs_output (argv[1], 0);
	    cvs_output (":yesterday -j", 0);
	    cvs_output (argv[1], 0);
	    cvs_output (" ", 1);
	    cvs_output (argv[0], 0);
	    cvs_output ("\n\n", 0);
d284 1
a284 1
	    cvs_output ("\nNo conflicts created by this import\n\n", 0);
d474 1
d477 3
a499 3
	/* Why is RCS_FLAGS_FORCE here?  I wouldn't think that it would have any
	   effect in conjunction with passing NULL for workfile (i.e. to stdout).  */
	retcode = RCS_checkout (vers->srcfile->path, NULL, vers->vn_rcs,
d501 1
a501 1
	                        "-ko",
d503 1
a503 1
	                        NULL,
d505 3
a507 2
	                        xtmpfile, RCS_FLAGS_FORCE, 0);
	if (retcode != 0)
d619 7
a625 5
    status = RCS_checkin (rcs, tocvsPath == NULL ? vfile : tocvsPath,
			  message, vbranch,
			  (RCS_FLAGS_QUIET
			   | (use_file_modtime ? RCS_FLAGS_MODTIME : 0)),
			  0);
a719 1
    {"bas", "' "},    			/* Visual Basic code */
a732 1
    {"dlg", " * "},   			/* MS Windows dialog file */
a738 1
    {"frm", "' "},    			/* Visual Basic form */
a747 1
    {"mak", "# "},    			/* makefile, e.g. Visual C++ */
a768 1
    {"rc", " * "},			/* Microsoft Windows resource file */
d793 3
a1086 4
	char buf[2];
	buf[0] = ch;
	buf[1] = ' ';
	cvs_output (buf, 2);
d1088 5
a1092 11
	{
	    cvs_output (repository + repos_len + 1, 0);
	    cvs_output ("/", 1);
	}
	else if (repository[0] != '\0')
	{
	    cvs_output (repository, 0);
	    cvs_output ("/", 1);
	}
	cvs_output (fname, 0);
	cvs_output ("\n", 1);
d1142 6
d1149 1
@


1.1.1.4
log
@New CVS release from Cyclic Software
@
text
@d478 1
a478 1
		       1, 0, (List *) NULL, (RCSNode *) NULL);
d490 1
a490 1
	(void) sprintf (xtmpfile, "%s/cvs-imp%ld", tmpdir, (long) getpid());
d682 1
a682 1
		       1, 0, (List *) NULL, (RCSNode *) NULL);
d855 1
a855 1
    char *author;
d864 6
a869 4
    /* FIXME?  We always import files as text files (note that means
       that files get stored with straight linefeeds).  There isn't an
       obvious, clean, way to let people specify which files are binary.
       Maybe based on the file name....  */
d873 1
a873 2
    if (fpuser == NULL)
    {
d879 2
a880 3
    fprcs = fopen (rcs, "w+b");
    if (fprcs == NULL)
    {
d888 3
a890 3
    if (fprintf (fprcs, "head     %s;\012", vhead) < 0 ||
	fprintf (fprcs, "branch   %s;\012", vbranch) < 0 ||
	fprintf (fprcs, "access   ;\012") < 0 ||
d900 2
a901 2
    if (fprintf (fprcs, "%s:%s;\012", vtag, vbranch) < 0 ||
	fprintf (fprcs, "locks    ; strict;\012") < 0 ||
d903 1
a903 1
	fprintf (fprcs, "comment  @@%s@@;\012", get_comment (user)) < 0)
d909 1
a909 1
      if (fprintf (fprcs, "expand   @@%s@@;\012", keyword_opt) < 0)
d914 1
a914 1
    if (fprintf (fprcs, "\012") < 0)
d951 2
a952 2
    if (fprintf (fprcs, "\012%s\012", vhead) < 0 ||
	fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
d954 4
a957 4
	fprintf (fprcs, "branches %s.1;\012", vbranch) < 0 ||
	fprintf (fprcs, "next     ;\012") < 0 ||
	fprintf (fprcs, "\012%s.1\012", vbranch) < 0 ||
	fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
d959 2
a960 2
	fprintf (fprcs, "branches ;\012") < 0 ||
	fprintf (fprcs, "next     ;\012\012") < 0 ||
d964 2
a965 2
	fprintf (fprcs, "\012desc\012") < 0 ||
	fprintf (fprcs, "@@@@\012\012\012") < 0 ||
d969 4
a972 4
	fprintf (fprcs, "\012%s\012", vhead) < 0 ||
	fprintf (fprcs, "log\012") < 0 ||
	fprintf (fprcs, "@@Initial revision\012@@\012") < 0 ||
	fprintf (fprcs, "text\012@@") < 0)
d977 1
a977 1
    /* Now copy over the contents of the file, expanding at signs.  */
d979 1
a979 2
	unsigned char buf[8192];
	unsigned int len;
d981 5
a985 1
	while (1)
d987 2
a988 9
	    len = fread (buf, 1, sizeof buf, fpuser);
	    if (len == 0)
	    {
		if (ferror (fpuser))
		    error (1, errno, "cannot read file %s for copying", user);
		break;
	    }
	    if (expand_at_signs (buf, len, fprcs) < 0)
		goto write_error;
d990 1
d992 3
a994 3
    if (fprintf (fprcs, "@@\012\012") < 0 ||
	fprintf (fprcs, "\012%s.1\012", vbranch) < 0 ||
	fprintf (fprcs, "log\012@@") < 0 ||
d996 2
a997 2
	fprintf (fprcs, "@@\012text\012") < 0 ||
	fprintf (fprcs, "@@@@\012") < 0)
d1171 1
a1171 4
	char rcs[PATH_MAX];

	(void) sprintf (rcs, "%s%s", repository, RCSEXT);
	if (isfile (repository) || isfile(rcs))
d1198 1
a1198 1
      exit (EXIT_FAILURE);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d28 2
a29 3
static int add_rev PROTO((char *message, RCSNode *rcs, char *vfile,
			  char *vers));
static int add_tags PROTO((RCSNode *rcs, char *vfile, char *vtag, int targc,
d68 1
a68 1
    char *tmpfile;
a72 1
    struct logfile_info *li;
d118 1
a118 1
		free (RCS_check_kflag (optarg));
d141 1
a141 1
	if (CVSroot_directory == NULL)
d147 2
a148 2
	(void) sprintf (repository, "%s/%s", CVSroot_directory, argv[0]);
	repos_len = strlen (CVSroot_directory);
d174 3
a176 2
	/* For rationale behind calling start_server before do_editor, see
	   commit.c  */
d184 1
a184 1
		   (List *) NULL);
a221 1
	wrap_send ();
d247 1
a247 2
    tmpfile = cvs_temp_name ();
    if ((logfp = CVS_FOPEN (tmpfile, "w+")) == NULL)
d249 1
a249 1
    (void) CVS_UNLINK (tmpfile);		/* to be sure it goes away */
d301 1
a301 4
    li = (struct logfile_info *) xmalloc (sizeof (struct logfile_info));
    li->type = T_TITLE;
    li->tag = xstrdup (vbranch);
    p->data = (char *) li;
d303 1
a303 1
    Update_Logfile (repository, message, logfp, ulist);
d309 1
a309 2
    CVS_UNLINK (tmpfile);
    free (tmpfile);
d336 1
a336 1
    if ((dirp = CVS_OPENDIR (".")) == NULL)
d368 1
a368 1
	    {
d380 1
a380 1
		dp->d_type == DT_LNK || dp->d_type == DT_UNKNOWN &&
d403 1
a403 1
    if (dirlist != NULL)
d474 1
a475 1
    struct file_info finfo;
d477 2
a478 10
    memset (&finfo, 0, sizeof finfo);
    finfo.file = vfile;
    /* Not used, so don't worry about it.  */
    finfo.update_dir = NULL;
    finfo.fullname = finfo.file;
    finfo.repository = repository;
    finfo.entries = NULL;
    finfo.rcs = NULL;
    vers = Version_TS (&finfo, (char *) NULL, vbranch, (char *) NULL,
		       1, 0);
d486 5
a490 1
	(void) sprintf (xtmpfile, "%s/cvs-imp%ld", Tmpdir, (long) getpid());
d501 3
a503 2
	retcode = RCS_checkout (vers->srcfile, (char *) NULL, vers->vn_rcs,
				(char *) NULL,
d505 1
a505 1
				"-ko",
d507 1
a507 1
				NULL,
d509 1
a509 1
				xtmpfile);
d539 1
a539 1
	    if (add_tags (vers->srcfile, vfile, vtag, targc, targv))
d549 2
a550 2
	add_rev (message, vers->srcfile, vfile, vers->vn_rcs) ||
	add_tags (vers->srcfile, vfile, vtag, targc, targv))
d576 1
a576 1
    RCSNode *rcs;
d622 1
a622 1
    status = RCS_checkin (rcs->path, tocvsPath == NULL ? vfile : tocvsPath,
d625 2
a626 1
			   | (use_file_modtime ? RCS_FLAGS_MODTIME : 0)));
d639 2
a640 4
	    fperror (logfp, 0, status == -1 ? ierrno : 0,
		     "ERROR: Check-in of %s failed", rcs->path);
	    error (0, status == -1 ? ierrno : 0,
		   "ERROR: Check-in of %s failed", rcs->path);
d659 1
a659 1
    RCSNode *rcs;
a667 1
    struct file_info finfo;
d675 2
a676 2
	fperror (logfp, 0, retcode == -1 ? ierrno : 0,
		 "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
d678 1
a678 1
	       "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
d681 2
a682 10

    memset (&finfo, 0, sizeof finfo);
    finfo.file = vfile;
    /* Not used, so don't worry about it.  */
    finfo.update_dir = NULL;
    finfo.fullname = finfo.file;
    finfo.repository = repository;
    finfo.entries = NULL;
    finfo.rcs = NULL;
    vers = Version_TS (&finfo, NULL, vtag, NULL, 1, 0);
d688 2
a689 3
	    fperror (logfp, 0, retcode == -1 ? ierrno : 0,
		     "WARNING: Couldn't add tag %s to %s", targv[i],
		     rcs->path);
d691 1
a691 2
		   "WARNING: Couldn't add tag %s to %s", targv[i],
		   rcs->path);
a714 4
 *
 * I believe that the comment leader is unused if you are using RCS 5.7, which
 * decides what leader to use based on the text surrounding the $Log keyword
 * rather than a specified comment leader.
a859 2
    char *local_opt = keyword_opt;
    char *free_opt = NULL;
d864 4
a867 8
    if (local_opt == NULL)
    {
	if (wrap_name_has (user, WRAP_RCSOPTION))
	{
	    local_opt = free_opt = wrap_rcsoption (user, 0);
	}
    }

d870 1
a870 1
    fpuser = CVS_FOPEN (userfile, "r");
d878 1
a878 1
    fprcs = CVS_FOPEN (rcs, "w+b");
d908 2
a909 3
    if (local_opt != NULL)
    {
	if (fprintf (fprcs, "expand   @@%s@@;\012", local_opt) < 0)
d911 1
a911 1
	    goto write_error;
a912 1
    }
d979 1
a979 1
	char buf[8192];
a1032 2
    if (free_opt != NULL)
	free (free_opt);
d1044 1
a1044 1
	(void) CVS_UNLINK (rcs);
a1052 3
    if (free_opt != NULL)
	free (free_opt);

d1160 1
a1160 1
    if ( CVS_CHDIR (dir) < 0)
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d187 1
a187 1
    do_verify (message, repository);
a306 1
    li->rev_old = li->rev_new = NULL;
d1243 1
a1243 1
	error_exit ();
@


1.1.1.7
log
@New release from Cyclic Software
@
text
@d42 2
a43 2
static char *vhead;
static char *vbranch;
d45 1
a45 1
static char *repository;
d82 1
a82 1
    vbranch = xstrdup (CVSBRANCH);
d103 1
a103 2
		free (vbranch);
		vbranch = xstrdup (optarg);
a137 3
    {
	int j;

a138 4
	for (j = 1; j < i; j++)
	    if (strcmp (argv[j], argv[i]) == 0)
		error (1, 0, "tag `%s' was specified more than once", argv[i]);
    }
a148 2
	repository = xmalloc (strlen (CVSroot_directory) + strlen (argv[0])
			      + 10);
a153 1
	repository = xmalloc (strlen (argv[0]) + 5);
d169 1
a169 1
    vhead = xstrdup (vbranch);
a320 3
    free (repository);
    free (vbranch);
    free (vhead);
d438 2
a439 1
    char *rcs;
a441 2
    rcs = xmalloc (strlen (repository) + strlen (vfile) + sizeof (RCSEXT)
		   + 5);
a444 4
	char *attic_name;

	attic_name = xmalloc (strlen (repository) + strlen (vfile) +
			      sizeof (CVSATTIC) + sizeof (RCSEXT) + 10);
a448 1
	    int retval;
a449 1
	    free (attic_name);
d455 1
a455 3
	    retval = add_rcs_file (message, rcs, vfile, vtag, targc, targv);
	    free (rcs);
	    return retval;
a456 1
	free (attic_name);
a459 1
    free (rcs);
d498 1
a498 1
	char *xtmpfile;
a501 1
	xtmpfile = xmalloc (strlen (Tmpdir) + 40);
a530 1
	    free (xtmpfile);
a540 1
	free (xtmpfile);
d836 1
a836 1
    char *suffix_path;
a837 1
    char *retval;
a838 1
    suffix_path = xmalloc (strlen (user) + 5);
d858 2
a859 7
	if (comtable[i].suffix == NULL)
	{
	    /* Default.  Note we'll always hit this case before we
	       ever return NULL.  */
	    retval = comtable[i].comlead;
	    break;
	}
d861 1
a861 4
	{
	    retval = comtable[i].comlead;
	    break;
	}
a862 2
    free (suffix_path);
    return retval;
d878 1
a878 1
    char altdate1[MAXDATELEN];
d880 1
a880 1
    char altdate2[MAXDATELEN];
a1177 1
    char *rcs = NULL;
a1185 2

    /* Concatenate DIR to the end of REPOSITORY.  */
d1187 1
a1187 5
    {
	char *new = xstrdup (dir);
	free (repository);
	repository = new;
    }
d1190 2
a1191 6
	char *new = xmalloc (strlen (repository) + strlen (dir) + 10);
	strcpy (new, repository);
	(void) strcat (new, "/");
	(void) strcat (new, dir);
	free (repository);
	repository = new;
a1192 1

d1214 2
a1215 1
	rcs = xmalloc (strlen (repository) + sizeof (RCSEXT) + 5);
d1219 1
a1219 2
	    fperror (logfp, 0, 0,
		     "ERROR: %s is a file, should be a directory!",
a1238 2
    if (rcs != NULL)
	free (rcs);
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d84 1
a84 1
    while ((c = getopt (argc, argv, "+Qqdb:m:I:k:W:")) != -1)
d506 1
d523 1
d525 4
d539 22
d562 1
a562 3
	/* FIXME: Why don't we pass tocvsPath to RCS_cmp_file if it is
           not NULL?  */
	different = RCS_cmp_file (vers->srcfile, vers->vn_rcs, "-ko", vfile);
d567 2
@


1.1.1.9
log
@Latest version from Cyclic Software
@
text
@a20 1
#include <assert.h>
d25 2
d83 1
a83 1
    optind = 0;
d414 2
a415 4
                                                       vtag, targc, targv,
                                                       repository,
                                                       keyword_opt != NULL &&
                                                       keyword_opt[0] == 'b');
d476 1
a476 2
	    retval = add_rcs_file (message, rcs, vfile, vhead, vbranch,
				   vtag, targc, targv, logfp);
d877 2
a878 8
/* Create a new RCS file from scratch.

   This probably should be moved to rcs.c now that it is called from
   places outside import.c.  */
int
add_rcs_file (message, rcs, user, add_vhead, add_vbranch, vtag, targc, targv,
	      add_logfp)
    /* Log message for the addition.  */
a879 1
    /* Filename of the RCS file to create.  */
a880 2
    /* Filename of the file to serve as the contents of the initial
       revision.  */
a881 9

    /* Revision number of head that we are adding.  Normally 1.1 but
       could be another revision as long as ADD_VBRANCH is a branch
       from it.  */
    char *add_vhead;

    /* Vendor branch to import to, or NULL if none.  If non-NULL, then
       vtag should also be non-NULL.  */
    char *add_vbranch;
a884 4

    /* Write errors to here as well as via error (), or NULL if we should
       use only error ().  */
    FILE *add_logfp;
d919 1
a919 1
	fperror (add_logfp, 0, errno, "ERROR: cannot read file %s", userfile);
d933 3
a935 8
    if (fprintf (fprcs, "head     %s;\012", add_vhead) < 0)
	goto write_error;
    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "branch   %s;\012", add_vbranch) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, "access   ;\012") < 0 ||
d941 2
a942 5
    for (i = targc - 1; i >= 0; i--)
    {
	/* RCS writes the symbols backwards */
	assert (add_vbranch != NULL);
	if (fprintf (fprcs, "%s:%s.1 ", targv[i], add_vbranch) < 0)
a943 1
    }
d945 2
a946 9
    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "%s:%s", vtag, add_vbranch) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, ";\012") < 0)
	goto write_error;

    if (fprintf (fprcs, "locks    ; strict;\012") < 0 ||
d998 1
a998 1
    if (fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
d1000 8
a1007 25
		 altdate1, author) < 0)
	goto write_error;

    if (fprintf (fprcs, "branches") < 0)
	goto write_error;
    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, " %s.1", add_vbranch) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, ";\012") < 0)
	goto write_error;

    if (fprintf (fprcs, "next     ;\012") < 0)
	goto write_error;
    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
	    fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
		     altdate2, author) < 0 ||
	    fprintf (fprcs, "branches ;\012") < 0 ||
	    fprintf (fprcs, "next     ;\012\012") < 0)
	    goto write_error;
    }
    if (
d1016 3
a1018 17
	fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
	fprintf (fprcs, "log\012@@") < 0)
	goto write_error;
    if (add_vbranch != NULL)
    {
	/* We are going to put the log message in the revision on the
	   branch.  So putting it here too seems kind of redundant, I
	   guess (and that is what CVS has always done, anyway).  */
	if (fprintf (fprcs, "Initial revision\012") < 0)
	    goto write_error;
    }
    else
    {
	if (expand_at_signs (message, (off_t) strlen (message), fprcs) < 0)
	    goto write_error;
    }
    if (fprintf (fprcs, "@@\012") < 0 ||
d1042 7
a1048 1
    if (fprintf (fprcs, "@@\012\012") < 0)
a1049 8
    if (add_vbranch != NULL)
    {
	if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
	    fprintf (fprcs, "log\012@@") < 0 ||
	    expand_at_signs (message, (off_t) strlen (message), fprcs) < 0 ||
	    fprintf (fprcs, "@@\012text\012") < 0 ||
	    fprintf (fprcs, "@@@@\012") < 0)
	    goto write_error;
a1050 1

d1072 1
a1072 1
	fperror (add_logfp, 0, ierrno,
d1089 1
a1089 1
    fperror (add_logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
d1094 1
a1094 1
	fperror (add_logfp, 0, 0, "ERROR: out of space - aborting");
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d6 1
a6 1
 * specified in the README file that comes with the CVS source distribution.
d26 1
a58 1
    "(Specify the --help global option for a list of other help options)\n",
d107 1
a107 1
		use_editor = 1;
d109 1
a109 1
		use_editor = 0;
a201 1
	*nm = '\0';
a469 2
	    char *free_opt = NULL;
	    char *our_opt = keyword_opt;
d477 2
a478 36

#ifdef SERVER_SUPPORT
	    /* The most reliable information on whether the file is binary
	       is what the client told us.  That is because if the client had
	       the wrong idea about binaryness, it corrupted the file, so
	       we might as well believe the client.  */
	    if (server_active)
	    {
		Node *node;
		List *entries;

		/* Reading all the entries for each file is fairly silly, and
		   probably slow.  But I am too lazy at the moment to do
		   anything else.  */
		entries = Entries_Open (0);
		node = findnode_fn (entries, vfile);
		if (node != NULL)
		{
		    Entnode *entdata = (Entnode *) node->data;
		    if (entdata->type == ENT_FILE)
		    {
			assert (entdata->options[0] == '-'
				&& entdata->options[1] == 'k');
			our_opt = xstrdup (entdata->options + 2);
			free_opt = our_opt;
		    }
		}
		Entries_Close (entries);
	    }
#endif

	    retval = add_rcs_file (message, rcs, vfile, vhead, our_opt,
				   vbranch, vtag, targc, targv,
				   NULL, 0, logfp);
	    if (free_opt != NULL)
		free (free_opt);
d605 5
a609 6
	/* Earlier versions of this function printed a `fork failed' error
	   when RCS_lock returned an error code.  That's not appropriate
	   now that RCS_lock is librarified, but should the error text be
	   preserved? */
	if (RCS_lock (rcs, vbranch, 1) != 0)
	    return 1;
a610 1
	RCS_rewrite (rcs, NULL, NULL);
d635 1
a635 1
    status = RCS_checkin (rcs, tocvsPath == NULL ? vfile : tocvsPath,
a658 1
	    RCS_rewrite (rcs, NULL, NULL);
a695 1
    RCS_rewrite (rcs, NULL, NULL);
d708 1
a708 3
	if ((retcode = RCS_settag (rcs, targv[i], vers->vn_rcs)) == 0)
	    RCS_rewrite (rcs, NULL, NULL);
	else
d882 1
a882 4
   places outside import.c.

   Return value is 0 for success, or nonzero for failure (in which
   case an error message will have already been printed).  */
d884 3
a886 4
add_rcs_file (message, rcs, user, add_vhead, key_opt,
	      add_vbranch, vtag, targc, targv,
	      desctext, desclen, add_logfp)
    /* Log message for the addition.  Not used if add_vhead == NULL.  */
d891 1
a891 2
       revision.  Even if add_vhead is NULL, we use this to determine
       the modes to give the new RCS file.  */
d896 1
a896 2
       from it.  If NULL, then just add an empty file without any
       revisions (similar to the one created by "rcs -i").  */
a898 4
    /* Keyword expansion mode, e.g., "b" for binary.  NULL means the
       default behavior.  */
    char *key_opt;

a905 5
    /* If non-NULL, description for the file.  If NULL, the description
       will be empty.  */
    char *desctext;
    size_t desclen;

d915 3
d923 1
a923 1
    char *local_opt = key_opt;
a928 7
    /* Note that as the code stands now, the -k option overrides any
       settings in wrappers (whether CVSROOT/cvswrappers, -W, or
       whatever).  Some have suggested this should be the other way
       around.  As far as I know the documentation doesn't say one way
       or the other.  Before making a change of this sort, should think
       about what is best, document it (in cvs.texinfo and NEWS), &c.  */

d939 1
a939 11

    /* Opening in text mode is probably never the right thing for the
       server (because the protocol encodes text files in a fashion
       which does not depend on what the client or server OS is, as
       documented in cvsclient.texi), but as long as the server just
       runs on unix it is a moot point.  */
    fpuser = CVS_FOPEN (userfile,
			((local_opt != NULL && strcmp (local_opt, "b") == 0)
			 ? "rb"
			 : "r")
			);
d957 2
a958 11
    if (add_vhead != NULL)
    {
	if (fprintf (fprcs, "head     %s;\012", add_vhead) < 0)
	    goto write_error;
    }
    else
    {
	if (fprintf (fprcs, "head     ;\012") < 0)
	    goto write_error;
    }

d1004 3
a1006 1
    /* Get information on modtime and mode.  */
d1009 28
d1038 1
a1038 16
    /* Write the revision(s), with the date and author and so on
       (that is "delta" rather than "deltatext" from rcsfile(5)).  */
    if (add_vhead != NULL)
    {
	if (use_file_modtime)
	    now = sb.st_mtime;
	else
	    (void) time (&now);
	ftm = gmtime (&now);
	(void) sprintf (altdate1, DATEFORM,
			ftm->tm_year + (ftm->tm_year < 100 ? 0 : 1900),
			ftm->tm_mon + 1, ftm->tm_mday, ftm->tm_hour,
			ftm->tm_min, ftm->tm_sec);
	author = getcaller ();

	if (fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
d1043 5
a1047 8
	if (fprintf (fprcs, "branches") < 0)
	    goto write_error;
	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, " %s.1", add_vbranch) < 0)
		goto write_error;
	}
	if (fprintf (fprcs, ";\012") < 0)
d1049 3
d1053 9
a1061 1
	if (fprintf (fprcs, "next     ;\012") < 0)
a1062 9
	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
		fprintf (fprcs, "date     %s;  author %s;  state Exp;\012",
			 altdate1, author) < 0 ||
		fprintf (fprcs, "branches ;\012") < 0 ||
		fprintf (fprcs, "next     ;\012\012") < 0)
		goto write_error;
	}
d1064 11
a1074 4

    /* Now write the description (possibly empty).  */
    if (fprintf (fprcs, "\012desc\012") < 0 ||
	fprintf (fprcs, "@@") < 0)
d1076 1
a1076 1
    if (desctext != NULL)
d1078 4
a1081 4
	/* The use of off_t not size_t for the second argument is very
	   strange, since we are dealing with something which definitely
	   fits in memory.  */
	if (expand_at_signs (desctext, (off_t) desclen, fprcs) < 0)
d1084 8
a1091 1
    if (fprintf (fprcs, "@@\012\012\012") < 0)
d1093 1
d1095 1
a1095 3
    /* Now write the log messages and contents for the revision(s) (that
       is, "deltatext" rather than "delta" from rcsfile(5)).  */
    if (add_vhead != NULL)
d1097 2
a1098 21
	if (fprintf (fprcs, "\012%s\012", add_vhead) < 0 ||
	    fprintf (fprcs, "log\012@@") < 0)
	    goto write_error;
	if (add_vbranch != NULL)
	{
	    /* We are going to put the log message in the revision on the
	       branch.  So putting it here too seems kind of redundant, I
	       guess (and that is what CVS has always done, anyway).  */
	    if (fprintf (fprcs, "Initial revision\012") < 0)
		goto write_error;
	}
	else
	{
	    if (expand_at_signs (message, (off_t) strlen (message), fprcs) < 0)
		goto write_error;
	}
	if (fprintf (fprcs, "@@\012") < 0 ||
	    fprintf (fprcs, "text\012@@") < 0)
	{
	    goto write_error;
	}
d1100 1
a1100 1
	/* Now copy over the contents of the file, expanding at signs.  */
d1102 2
a1103 4
	    char buf[8192];
	    unsigned int len;

	    while (1)
d1105 3
a1107 10
		len = fread (buf, 1, sizeof buf, fpuser);
		if (len == 0)
		{
		    if (ferror (fpuser))
			error (1, errno, "cannot read file %s for copying",
			       user);
		    break;
		}
		if (expand_at_signs (buf, len, fprcs) < 0)
		    goto write_error;
d1109 2
d1112 10
a1121 1
	if (fprintf (fprcs, "@@\012\012") < 0)
a1122 10
	if (add_vbranch != NULL)
	{
	    if (fprintf (fprcs, "\012%s.1\012", add_vbranch) < 0 ||
		fprintf (fprcs, "log\012@@") < 0 ||
		expand_at_signs (message,
				 (off_t) strlen (message), fprcs) < 0 ||
		fprintf (fprcs, "@@\012text\012") < 0 ||
		fprintf (fprcs, "@@@@\012") < 0)
		goto write_error;
	}
d1187 1
a1187 1
int
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@d263 1
a263 5
    /* On systems where we can unlink an open file, do so, so it will go
       away no matter how we exit.  FIXME-maybe: Should be checking for
       errors but I'm not sure which error(s) we get if we are on a system
       where one can't unlink open files.  */
    (void) CVS_UNLINK (tmpfile);
d323 1
a323 2
    if (fclose (logfp) < 0)
	error (0, errno, "error closing %s", tmpfile);
d327 1
a327 2
    if (CVS_UNLINK (tmpfile) < 0 && !existence_error (errno))
	error (0, errno, "cannot remove %s", tmpfile);
d494 1
a494 1
		entries = Entries_Open (0, NULL);
a979 1
    mode_t file_type;
d1007 11
a1017 31

    /* If PreservePermissions is set, then make sure that the file
       is a plain file before trying to open it.  Longstanding (although
       often unpopular) CVS behavior has been to follow symlinks, so we
       maintain that behavior if PreservePermissions is not on.

       NOTE: this error message used to be `cannot fstat', but is now
       `cannot lstat'.  I don't see a way around this, since we must
       stat the file before opening it. -twp */

    if (CVS_LSTAT (userfile, &sb) < 0)
	error (1, errno, "cannot lstat %s", user);
    file_type = sb.st_mode & S_IFMT;

    fpuser = NULL;
    if (!preserve_perms || file_type == S_IFREG)
    {
	fpuser = CVS_FOPEN (userfile,
			    ((local_opt != NULL && strcmp (local_opt, "b") == 0)
			     ? "rb"
			     : "r")
	    );
	if (fpuser == NULL)
	{
	    /* not fatal, continue import */
	    if (add_logfp != NULL)
		fperror (add_logfp, 0, errno,
			 "ERROR: cannot read file %s", userfile);
	    error (0, errno, "ERROR: cannot read file %s", userfile);
	    goto read_error;
	}
a1018 1

d1085 4
a1120 44

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	/* Store initial permissions if necessary. */
	if (preserve_perms)
	{
	    if (file_type == S_IFLNK)
	    {
		char *link = xreadlink (userfile);
		if (fprintf (fprcs, "symlink\t@@") < 0 ||
		    expand_at_signs (link, strlen (link), fprcs) < 0 ||
		    fprintf (fprcs, "@@;\012") < 0)
		    goto write_error;
		free (link);
	    }
	    else
	    {
		if (fprintf (fprcs, "owner\t%u;\012", sb.st_uid) < 0)
		    goto write_error;
		if (fprintf (fprcs, "group\t%u;\012", sb.st_gid) < 0)
		    goto write_error;
		if (fprintf (fprcs, "permissions\t%o;\012",
			     sb.st_mode & 07777) < 0)
		    goto write_error;
		switch (file_type)
		{
		    case S_IFREG: break;
		    case S_IFCHR:
		    case S_IFBLK:
			if (fprintf (fprcs, "special\t%s %lu;\012",
				     (file_type == S_IFCHR
				      ? "character"
				      : "block"),
				     (unsigned long) sb.st_rdev) < 0)
			    goto write_error;
			break;
		    default:
			error (0, 0,
			       "can't import %s: unknown kind of special file",
			       userfile);
		}
	    }
	}
#endif

d1127 1
a1127 46
		fprintf (fprcs, "next     ;\012") < 0)
		goto write_error;

#ifdef PRESERVE_PERMISSIONS_SUPPORT
	    /* Store initial permissions if necessary. */
	    if (preserve_perms)
	    {
		if (file_type == S_IFLNK)
		{
		    char *link = xreadlink (userfile);
		    if (fprintf (fprcs, "symlink\t@@") < 0 ||
			expand_at_signs (link, strlen (link), fprcs) < 0 ||
			fprintf (fprcs, "@@;\012") < 0)
			goto write_error;
		    free (link);
		}
		else
		{
		    if (fprintf (fprcs, "owner\t%u;\012", sb.st_uid) < 0 ||
			fprintf (fprcs, "group\t%u;\012", sb.st_gid) < 0 ||
			fprintf (fprcs, "permissions\t%o;\012",
				 sb.st_mode & 07777) < 0)
			goto write_error;
	    
		    switch (file_type)
		    {
			case S_IFREG: break;
			case S_IFCHR:
			case S_IFBLK:
			    if (fprintf (fprcs, "special\t%s %lu;\012",
					 (file_type == S_IFCHR
					  ? "character"
					  : "block"),
					 (unsigned long) sb.st_rdev) < 0)
				goto write_error;
			    break;
			default:
			    error (0, 0,
			      "cannot import %s: special file of unknown type",
			       userfile);
		    }
		}
	    }
#endif

	    if (fprintf (fprcs, "\012") < 0)
d1173 1
a1173 3
	/* Now copy over the contents of the file, expanding at signs.
	   If preserve_perms is set, do this only for regular files. */
	if (!preserve_perms || file_type == S_IFREG)
d1211 1
a1211 6
    /* Close fpuser only if we opened it to begin with. */
    if (fpuser != NULL)
    {
	if (fclose (fpuser) < 0)
	    error (0, errno, "cannot close %s", user);
    }
d1227 2
a1228 3
	if (add_logfp != NULL)
	    fperror (add_logfp, 0, ierrno,
		     "WARNING: cannot change mode of file %s", rcs);
d1241 1
a1241 2
    if (fclose (fprcs) < 0)
	error (0, errno, "cannot close %s", rcs);
d1243 2
a1244 4
    if (fclose (fpuser) < 0)
	error (0, errno, "cannot close %s", user);
    if (add_logfp != NULL)
	fperror (add_logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
d1248 2
a1249 4
	if (CVS_UNLINK (rcs) < 0)
	    error (0, errno, "cannot remove %s", rcs);
	if (add_logfp != NULL)
	    fperror (add_logfp, 0, 0, "ERROR: out of space - aborting");
d1274 1
a1274 1
    register char *cp, *next;
d1276 2
a1277 2
    cp = buf;
    while ((next = memchr (cp, '@@', size)) != NULL)
d1279 7
a1285 10
	int len;

	++next;
	len = next - cp;
	if (fwrite (cp, 1, len, fp) != len)
	    return EOF;
	if (putc ('@@', fp) == EOF)
	    return EOF;
	cp = next;
	size -= len;
d1287 1
a1287 5

    if (fwrite (cp, 1, size, fp) != size)
	return EOF;

    return 1;
@


1.1.1.12
log
@Latest version from Cyclic
@
text
@d23 2
d658 21
d682 1
a682 1
			  (RCS_FLAGS_QUIET | RCS_FLAGS_KEEPFILE
d686 5
a690 2
    if ((tocvsPath != NULL) && (unlink_file_dir (tocvsPath) < 0))
	error (0, errno, "cannot remove %s", tocvsPath);
@


1.1.1.13
log
@Latest version from Cyclic
@
text
@a96 11
#ifdef SERVER_SUPPORT
		if (server_active)
		{
		    /* CVS 1.10 and older clients will send this, but it
		       doesn't do any good.  So tell the user we can't
		       cope, rather than silently losing.  */
		    error (0, 0,
			   "warning: not setting the time of import from the file");
		    error (0, 0, "due to client limitations");
		}
#endif
a134 14
#ifdef SERVER_SUPPORT
    /* This is for handling the Checkin-time request.  It might seem a
       bit odd to enable the use_file_modtime code even in the case
       where Checkin-time was not sent for a particular file.  The
       effect is that we use the time of upload, rather than the time
       when we call RCS_checkin.  Since those times are both during
       CVS's run, that seems OK, and it is easier to implement than
       putting the "was Checkin-time sent" flag in CVS/Entries or some
       such place.  */

    if (server_active)
	use_file_modtime = 1;
#endif

d173 1
a173 1
	if (!isdigit ((unsigned char) *cp) && *cp != '.')
d215 3
d278 16
a293 2
	    char buf[20];
	    char *buf2;
a294 36
	    cvs_output_tagged ("+importmergecmd", NULL);
	    cvs_output_tagged ("newline", NULL);
	    sprintf (buf, "%d", conflicts);
	    cvs_output_tagged ("conflicts", buf);
	    cvs_output_tagged ("text", " conflicts created by this import.");
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("text",
			       "Use the following command to help the merge:");
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("text", "\t");
	    cvs_output_tagged ("text", program_name);
	    if (CVSroot_cmdline != NULL)
	    {
		cvs_output_tagged ("text", " -d ");
		cvs_output_tagged ("text", CVSroot_cmdline);
	    }
	    cvs_output_tagged ("text", " checkout -j");
	    buf2 = xmalloc (strlen (argv[1]) + 20);
	    sprintf (buf2, "%s:yesterday", argv[1]);
	    cvs_output_tagged ("mergetag1", buf2);
	    free (buf2);
	    cvs_output_tagged ("text", " -j");
	    cvs_output_tagged ("mergetag2", argv[1]);
	    cvs_output_tagged ("text", " ");
	    cvs_output_tagged ("repository", argv[0]);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("newline", NULL);
	    cvs_output_tagged ("-importmergecmd", NULL);
	}

	/* FIXME: I'm not sure whether we need to put this information
           into the loginfo.  If we do, then note that it does not
           report any required -d option.  There is no particularly
           clean way to tell the server about the -d option used by
           the client.  */
d299 2
a300 3
	(void) fprintf (logfp, "\t%s checkout ", program_name);
	(void) fprintf (logfp, "-j%s:yesterday -j%s %s\n\n",
			argv[1], argv[1], argv[0]);
d343 3
a345 3
/* Process all the files in ".", then descend into other directories.
   Returns 0 for success, or >0 on error (in which case a message
   will have been printed).  */
a363 1
	error (0, errno, "cannot open directory");
a367 1
	errno = 0;
d371 1
a371 1
		goto one_more_time_boys;
d377 1
a377 1
		goto one_more_time_boys;
d382 1
a382 1
		goto one_more_time_boys;
d421 1
a421 2
						       keyword_opt[0] == 'b',
						       use_file_modtime);
a426 7
	one_more_time_boys:
	    errno = 0;
	}
	if (errno != 0)
	{
	    error (0, errno, "cannot read directory");
	    ++err;
d877 1
a877 1
	    if (isupper ((unsigned char) *cp))
@


1.1.1.14
log
@Latest version from Cyclic
@
text
@d171 1
a171 2
    if (! isabsolute (argv[0])
	&& pathname_levels (argv[0]) == 0)
d186 3
a188 5
	/* It is somewhere between a security hole and "unexpected" to
	   let the client start mucking around outside the cvsroot
	   (wouldn't get the right CVSROOT configuration, &c).  */
	error (1, 0, "directory %s not relative within the repository",
	       argv[0]);
@


1.1.1.15
log
@Latest from Cyclic Software
@
text
@a268 5
	if (message)
	    free (message);
	free (repository);
	free (vbranch);
	free (vhead);
a274 5
    if (!safe_location ())
    {
	error (1, 0, "attempt to import the repository");
    }

d456 1
a456 4
		     dp->d_type == DT_LNK
		     || (dp->d_type == DT_UNKNOWN && islink (dp->d_name))
#else
		     islink (dp->d_name)
d458 1
a458 1
		     )
d728 2
a729 2
	    fperrmsg (logfp, 0, status == -1 ? ierrno : 0,
		      "ERROR: Check-in of %s failed", rcs->path);
d768 2
a769 2
	fperrmsg (logfp, 0, retcode == -1 ? ierrno : 0,
		  "ERROR: Failed to set tag %s in %s", vtag, rcs->path);
d792 3
a794 3
	    fperrmsg (logfp, 0, retcode == -1 ? ierrno : 0,
		      "WARNING: Couldn't add tag %s to %s", targv[i],
		      rcs->path);
d1057 1
a1057 8
    {
	/* not fatal, continue import */
	if (add_logfp != NULL)
	    fperrmsg (add_logfp, 0, errno,
			  "ERROR: cannot lstat file %s", userfile);
	error (0, errno, "cannot lstat file %s", userfile);
	goto read_error;
    }
d1072 2
a1073 2
		fperrmsg (add_logfp, 0, errno,
			  "ERROR: cannot read file %s", userfile);
a1204 1
#ifdef HAVE_ST_RDEV
a1210 5
#else
			error (0, 0,
"can't import %s: unable to import device files on this system",
userfile);
#endif
a1255 1
#ifdef HAVE_ST_RDEV
a1261 5
#else
			    error (0, 0,
"can't import %s: unable to import device files on this system",
userfile);
#endif
d1380 2
a1381 2
	    fperrmsg (add_logfp, 0, ierrno,
		      "WARNING: cannot change mode of file %s", rcs);
d1400 1
a1400 1
	fperrmsg (add_logfp, 0, ierrno, "ERROR: cannot write file %s", rcs);
d1407 1
a1407 1
	    fperrmsg (add_logfp, 0, 0, "ERROR: out of space - aborting");
d1516 1
a1516 1
	fperrmsg (logfp, 0, 0, "ERROR: cannot get working directory");
d1547 1
a1547 1
	fperrmsg (logfp, 0, ierrno, "ERROR: cannot chdir to %s", repository);
d1562 3
a1564 3
	    fperrmsg (logfp, 0, 0,
		      "ERROR: %s is a file, should be a directory!",
		      repository);
d1573 2
a1574 2
	    fperrmsg (logfp, 0, ierrno,
		      "ERROR: cannot mkdir %s -- not added", repository);
@


1.1.1.16
log
@Latest from Cyclic Software
@
text
@d174 1
a174 1
	if (current_parsed_root == NULL)
d180 4
a183 5
	repository = xmalloc (strlen (current_parsed_root->directory)
			      + strlen (argv[0])
			      + 2);
	(void) sprintf (repository, "%s/%s", current_parsed_root->directory, argv[0]);
	repos_len = strlen (current_parsed_root->directory);
d210 1
a210 1
    if (current_parsed_root->isremote)
d239 1
a239 1
    if (current_parsed_root->isremote)
d293 2
a294 1
    if ((logfp = cvs_temp_file (&tmpfile)) == NULL)
d428 1
a428 1
	while ((dp = CVS_READDIR (dirp)) != NULL)
d479 1
a479 1
		if (current_parsed_root->isremote)
d499 1
a499 1
	(void) CVS_CLOSEDIR (dirp);
d1570 1
a1570 1
    if (!quiet && !current_parsed_root->isremote)
d1585 1
a1585 1
    if (!current_parsed_root->isremote && !isdir (repository))
@


