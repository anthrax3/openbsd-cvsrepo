head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.22
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.9
	OPENBSD_5_1:1.1.1.9.0.46
	OPENBSD_5_0:1.1.1.9.0.44
	OPENBSD_5_0_BASE:1.1.1.9
	OPENBSD_4_9:1.1.1.9.0.42
	OPENBSD_4_9_BASE:1.1.1.9
	OPENBSD_4_8:1.1.1.9.0.40
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.36
	OPENBSD_4_7_BASE:1.1.1.9
	OPENBSD_4_6:1.1.1.9.0.38
	OPENBSD_4_6_BASE:1.1.1.9
	OPENBSD_4_5:1.1.1.9.0.34
	OPENBSD_4_5_BASE:1.1.1.9
	OPENBSD_4_4:1.1.1.9.0.32
	OPENBSD_4_4_BASE:1.1.1.9
	OPENBSD_4_3:1.1.1.9.0.30
	OPENBSD_4_3_BASE:1.1.1.9
	OPENBSD_4_2:1.1.1.9.0.28
	OPENBSD_4_2_BASE:1.1.1.9
	OPENBSD_4_1:1.1.1.9.0.26
	OPENBSD_4_1_BASE:1.1.1.9
	OPENBSD_4_0:1.1.1.9.0.24
	OPENBSD_4_0_BASE:1.1.1.9
	OPENBSD_3_9:1.1.1.9.0.22
	OPENBSD_3_9_BASE:1.1.1.9
	OPENBSD_3_8:1.1.1.9.0.20
	OPENBSD_3_8_BASE:1.1.1.9
	OPENBSD_3_7:1.1.1.9.0.18
	OPENBSD_3_7_BASE:1.1.1.9
	OPENBSD_3_6:1.1.1.9.0.16
	OPENBSD_3_6_BASE:1.1.1.9
	OPENBSD_3_5:1.1.1.9.0.14
	OPENBSD_3_5_BASE:1.1.1.9
	OPENBSD_3_4:1.1.1.9.0.12
	OPENBSD_3_4_BASE:1.1.1.9
	OPENBSD_3_3:1.1.1.9.0.10
	OPENBSD_3_3_BASE:1.1.1.9
	OPENBSD_3_2:1.1.1.9.0.8
	OPENBSD_3_2_BASE:1.1.1.9
	OPENBSD_3_1:1.1.1.9.0.6
	OPENBSD_3_1_BASE:1.1.1.9
	OPENBSD_3_0:1.1.1.9.0.4
	OPENBSD_3_0_BASE:1.1.1.9
	cvs-1-11-1p1:1.1.1.9
	OPENBSD_2_9:1.1.1.9.0.2
	OPENBSD_2_9_BASE:1.1.1.9
	cvs-1-11:1.1.1.9
	OPENBSD_2_8:1.1.1.8.0.10
	OPENBSD_2_8_BASE:1.1.1.8
	OPENBSD_2_7:1.1.1.8.0.8
	OPENBSD_2_7_BASE:1.1.1.8
	OPENBSD_2_6:1.1.1.8.0.6
	OPENBSD_2_6_BASE:1.1.1.8
	cvs-1-10-7:1.1.1.8
	OPENBSD_2_5:1.1.1.8.0.4
	OPENBSD_2_5_BASE:1.1.1.8
	cvs-1-10-5:1.1.1.8
	OPENBSD_2_4:1.1.1.8.0.2
	OPENBSD_2_4_BASE:1.1.1.8
	cvs-1-10:1.1.1.8
	cvs-1-9-28:1.1.1.7
	OPENBSD_2_3:1.1.1.7.0.2
	OPENBSD_2_3_BASE:1.1.1.7
	cvs-1-9-26:1.1.1.7
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.4
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.6.0.2
	OPENBSD_2_1_BASE:1.1.1.6
	cvs-1-9-8:1.1.1.6
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	96.01.30.00.18.06;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.18.06;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.41.51;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.19.32;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.33;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.37.30;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.56.04;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.21.12;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.08.22.20.53.14;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2001.02.10.18.57.40;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/* Implementation for file attribute munging features.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

#include "cvs.h"
#include "getline.h"
#include "fileattr.h"
#include <assert.h>

static void fileattr_read PROTO ((void));
static int writeattr_proc PROTO ((Node *, void *));

/* Where to look for CVSREP_FILEATTR.  */
static char *fileattr_stored_repos;

/* The in-memory attributes.  */
static List *attrlist;
static char *fileattr_default_attrs;
/* We have already tried to read attributes and failed in this directory
   (for example, there is no CVSREP_FILEATTR file).  */
static int attr_read_attempted;

/* Have the in-memory attributes been modified since we read them?  */
static int attrs_modified;

/* More in-memory attributes: linked list of unrecognized
   fileattr lines.  We pass these on unchanged.  */
struct unrecog {
    char *line;
    struct unrecog *next;
};
static struct unrecog *unrecog_head;

/* Note that if noone calls fileattr_get, this is very cheap.  No stat(),
   no open(), no nothing.  */
void
fileattr_startdir (repos)
    char *repos;
{
    assert (fileattr_stored_repos == NULL);
    fileattr_stored_repos = xstrdup (repos);
    assert (attrlist == NULL);
    attr_read_attempted = 0;
    assert (unrecog_head == NULL);
}

static void
fileattr_delproc (node)
    Node *node;
{
    assert (node->data != NULL);
    free (node->data);
    node->data = NULL;
}

/* Read all the attributes for the current directory into memory.  */
static void
fileattr_read ()
{
    char *fname;
    FILE *fp;
    char *line = NULL;
    size_t line_len = 0;

    /* If there are no attributes, don't waste time repeatedly looking
       for the CVSREP_FILEATTR file.  */
    if (attr_read_attempted)
	return;

    /* If NULL was passed to fileattr_startdir, then it isn't kosher to look
       at attributes.  */
    assert (fileattr_stored_repos != NULL);

    fname = xmalloc (strlen (fileattr_stored_repos)
		     + 1
		     + sizeof (CVSREP_FILEATTR)
		     + 1);

    strcpy (fname, fileattr_stored_repos);
    strcat (fname, "/");
    strcat (fname, CVSREP_FILEATTR);

    attr_read_attempted = 1;
    fp = CVS_FOPEN (fname, FOPEN_BINARY_READ);
    if (fp == NULL)
    {
	if (!existence_error (errno))
	    error (0, errno, "cannot read %s", fname);
	free (fname);
	return;
    }
    attrlist = getlist ();
    while (1) {
	int nread;
	nread = get_line (&line, &line_len, fp);
	if (nread < 0)
	    break;
	/* Remove trailing newline.  */
	line[nread - 1] = '\0';
	if (line[0] == 'F')
	{
	    char *p;
	    Node *newnode;

	    p = strchr (line, '\t');
	    if (p == NULL)
		error (1, 0,
		       "file attribute database corruption: tab missing in %s",
		       fname);
	    *p++ = '\0';
	    newnode = getnode ();
	    newnode->type = FILEATTR;
	    newnode->delproc = fileattr_delproc;
	    newnode->key = xstrdup (line + 1);
	    newnode->data = xstrdup (p);
	    if (addnode (attrlist, newnode) != 0)
		/* If the same filename appears twice in the file, discard
		   any line other than the first for that filename.  This
		   is the way that CVS has behaved since file attributes
		   were first introduced.  */
		freenode (newnode);
	}
	else if (line[0] == 'D')
	{
	    char *p;
	    /* Currently nothing to skip here, but for future expansion,
	       ignore anything located here.  */
	    p = strchr (line, '\t');
	    if (p == NULL)
		error (1, 0,
		       "file attribute database corruption: tab missing in %s",
		       fname);
	    ++p;
	    fileattr_default_attrs = xstrdup (p);
	}
	else
	{
	    /* Unrecognized type, we want to just preserve the line without
	       changing it, for future expansion.  */
	    struct unrecog *new;

	    new = (struct unrecog *) xmalloc (sizeof (struct unrecog));
	    new->line = xstrdup (line);
	    new->next = unrecog_head;
	    unrecog_head = new;
	}
    }
    if (ferror (fp))
	error (0, errno, "cannot read %s", fname);
    if (line != NULL)
	free (line);
    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", fname);
    attrs_modified = 0;
    free (fname);
}

char *
fileattr_get (filename, attrname)
    const char *filename;
    const char *attrname;
{
    Node *node;
    size_t attrname_len = strlen (attrname);
    char *p;

    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
	/* Either nothing has any attributes, or fileattr_read already printed
	   an error message.  */
	return NULL;

    if (filename == NULL)
	p = fileattr_default_attrs;
    else
    {
	node = findnode (attrlist, filename);
	if (node == NULL)
	    /* A file not mentioned has no attributes.  */
	    return NULL;
	p = node->data;
    }
    while (p)
    {
	if (strncmp (attrname, p, attrname_len) == 0
	    && p[attrname_len] == '=')
	{
	    /* Found it.  */
	    return p + attrname_len + 1;
	}
	p = strchr (p, ';');
	if (p == NULL)
	    break;
	++p;
    }
    /* The file doesn't have this attribute.  */
    return NULL;
}

char *
fileattr_get0 (filename, attrname)
    const char *filename;
    const char *attrname;
{
    char *cp;
    char *cpend;
    char *retval;

    cp = fileattr_get (filename, attrname);
    if (cp == NULL)
	return NULL;
    cpend = strchr (cp, ';');
    if (cpend == NULL)
	cpend = cp + strlen (cp);
    retval = xmalloc (cpend - cp + 1);
    strncpy (retval, cp, cpend - cp);
    retval[cpend - cp] = '\0';
    return retval;
}

char *
fileattr_modify (list, attrname, attrval, namevalsep, entsep)
    char *list;
    const char *attrname;
    const char *attrval;
    int namevalsep;
    int entsep;
{
    char *retval;
    char *rp;
    size_t attrname_len = strlen (attrname);

    /* Portion of list before the attribute to be replaced.  */
    char *pre;
    char *preend;
    /* Portion of list after the attribute to be replaced.  */
    char *post;

    char *p;
    char *p2;

    p = list;
    pre = list;
    preend = NULL;
    /* post is NULL unless set otherwise.  */
    post = NULL;
    p2 = NULL;
    if (list != NULL)
    {
	while (1) {
	    p2 = strchr (p, entsep);
	    if (p2 == NULL)
	    {
		p2 = p + strlen (p);
		if (preend == NULL)
		    preend = p2;
	    }
	    else
		++p2;
	    if (strncmp (attrname, p, attrname_len) == 0
		&& p[attrname_len] == namevalsep)
	    {
		/* Found it.  */
		preend = p;
		if (preend > list)
		    /* Don't include the preceding entsep.  */
		    --preend;

		post = p2;
	    }
	    if (p2[0] == '\0')
		break;
	    p = p2;
	}
    }
    if (post == NULL)
	post = p2;

    if (preend == pre && attrval == NULL && post == p2)
	return NULL;

    retval = xmalloc ((preend - pre)
		      + 1
		      + (attrval == NULL ? 0 : (attrname_len + 1
						+ strlen (attrval)))
		      + 1
		      + (p2 - post)
		      + 1);
    if (preend != pre)
    {
	strncpy (retval, pre, preend - pre);
	rp = retval + (preend - pre);
	if (attrval != NULL)
	    *rp++ = entsep;
	*rp = '\0';
    }
    else
	retval[0] = '\0';
    if (attrval != NULL)
    {
	strcat (retval, attrname);
	rp = retval + strlen (retval);
	*rp++ = namevalsep;
	strcpy (rp, attrval);
    }
    if (post != p2)
    {
	rp = retval + strlen (retval);
	if (preend != pre || attrval != NULL)
	    *rp++ = entsep;
	strncpy (rp, post, p2 - post);
	rp += p2 - post;
	*rp = '\0';
    }
    return retval;
}

void
fileattr_set (filename, attrname, attrval)
    const char *filename;
    const char *attrname;
    const char *attrval;
{
    Node *node;
    char *p;

    if (filename == NULL)
    {
	p = fileattr_modify (fileattr_default_attrs, attrname, attrval,
			     '=', ';');
	if (fileattr_default_attrs != NULL)
	    free (fileattr_default_attrs);
	fileattr_default_attrs = p;
	attrs_modified = 1;
	return;
    }
    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
    {
	/* Not sure this is a graceful way to handle things
	   in the case where fileattr_read was unable to read the file.  */
        /* No attributes existed previously.  */
	attrlist = getlist ();
    }

    node = findnode (attrlist, filename);
    if (node == NULL)
    {
	if (attrval == NULL)
	    /* Attempt to remove an attribute which wasn't there.  */
	    return;

	/* First attribute for this file.  */
	node = getnode ();
	node->type = FILEATTR;
	node->delproc = fileattr_delproc;
	node->key = xstrdup (filename);
	node->data = xmalloc (strlen (attrname) + 1 + strlen (attrval) + 1);
	strcpy (node->data, attrname);
	strcat (node->data, "=");
	strcat (node->data, attrval);
	addnode (attrlist, node);
    }

    p = fileattr_modify (node->data, attrname, attrval, '=', ';');
    if (p == NULL)
	delnode (node);
    else
    {
	free (node->data);
	node->data = p;
    }

    attrs_modified = 1;
}

char *
fileattr_getall (filename)
    const char *filename;
{
    Node *node;
    char *p;

    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
	/* Either nothing has any attributes, or fileattr_read already printed
	   an error message.  */
	return NULL;

    if (filename == NULL)
	p = fileattr_default_attrs;
    else
    {
	node = findnode (attrlist, filename);
	if (node == NULL)
	    /* A file not mentioned has no attributes.  */
	    return NULL;
	p = node->data;
    }
    return xstrdup (p);
}

void
fileattr_setall (filename, attrs)
    const char *filename;
    const char *attrs;
{
    Node *node;

    if (filename == NULL)
    {
	if (fileattr_default_attrs != NULL)
	    free (fileattr_default_attrs);
	fileattr_default_attrs = xstrdup (attrs);
	attrs_modified = 1;
	return;
    }
    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
    {
	/* Not sure this is a graceful way to handle things
	   in the case where fileattr_read was unable to read the file.  */
        /* No attributes existed previously.  */
	attrlist = getlist ();
    }

    node = findnode (attrlist, filename);
    if (node == NULL)
    {
	/* The file had no attributes.  Add them if we have any to add.  */
	if (attrs != NULL)
	{
	    node = getnode ();
	    node->type = FILEATTR;
	    node->delproc = fileattr_delproc;
	    node->key = xstrdup (filename);
	    node->data = xstrdup (attrs);
	    addnode (attrlist, node);
	}
    }
    else
    {
	if (attrs == NULL)
	    delnode (node);
	else
	{
	    free (node->data);
	    node->data = xstrdup (attrs);
	}
    }

    attrs_modified = 1;
}

void
fileattr_newfile (filename)
    const char *filename;
{
    Node *node;

    if (attrlist == NULL)
	fileattr_read ();

    if (fileattr_default_attrs == NULL)
	return;

    if (attrlist == NULL)
    {
	/* Not sure this is a graceful way to handle things
	   in the case where fileattr_read was unable to read the file.  */
        /* No attributes existed previously.  */
	attrlist = getlist ();
    }

    node = getnode ();
    node->type = FILEATTR;
    node->delproc = fileattr_delproc;
    node->key = xstrdup (filename);
    node->data = xstrdup (fileattr_default_attrs);
    addnode (attrlist, node);
    attrs_modified = 1;
}

static int
writeattr_proc (node, data)
    Node *node;
    void *data;
{
    FILE *fp = (FILE *)data;
    fputs ("F", fp);
    fputs (node->key, fp);
    fputs ("\t", fp);
    fputs (node->data, fp);
    fputs ("\012", fp);
    return 0;
}

void
fileattr_write ()
{
    FILE *fp;
    char *fname;
    mode_t omask;
    struct unrecog *p;

    if (!attrs_modified)
	return;

    if (noexec)
	return;

    /* If NULL was passed to fileattr_startdir, then it isn't kosher to set
       attributes.  */
    assert (fileattr_stored_repos != NULL);

    fname = xmalloc (strlen (fileattr_stored_repos)
		     + 1
		     + sizeof (CVSREP_FILEATTR)
		     + 1);

    strcpy (fname, fileattr_stored_repos);
    strcat (fname, "/");
    strcat (fname, CVSREP_FILEATTR);

    if (list_isempty (attrlist)
	&& fileattr_default_attrs == NULL
	&& unrecog_head == NULL)
    {
	/* There are no attributes.  */
	if (unlink_file (fname) < 0)
	{
	    if (!existence_error (errno))
	    {
		error (0, errno, "cannot remove %s", fname);
	    }
	}

	/* Now remove CVSREP directory, if empty.  The main reason we bother
	   is that CVS 1.6 and earlier will choke if a CVSREP directory
	   exists, so provide the user a graceful way to remove it.  */
	strcpy (fname, fileattr_stored_repos);
	strcat (fname, "/");
	strcat (fname, CVSREP);
	if (CVS_RMDIR (fname) < 0)
	{
	    if (errno != ENOTEMPTY

		/* Don't know why we would be here if there is no CVSREP
		   directory, but it seemed to be happening anyway, so
		   check for it.  */
		&& !existence_error (errno))
		error (0, errno, "cannot remove %s", fname);
	}

	free (fname);
	return;
    }

    omask = umask (cvsumask);
    fp = CVS_FOPEN (fname, FOPEN_BINARY_WRITE);
    if (fp == NULL)
    {
	if (existence_error (errno))
	{
	    /* Maybe the CVSREP directory doesn't exist.  Try creating it.  */
	    char *repname;

	    repname = xmalloc (strlen (fileattr_stored_repos)
			       + 1
			       + sizeof (CVSREP)
			       + 1);
	    strcpy (repname, fileattr_stored_repos);
	    strcat (repname, "/");
	    strcat (repname, CVSREP);

	    if (CVS_MKDIR (repname, 0777) < 0 && errno != EEXIST)
	    {
		error (0, errno, "cannot make directory %s", repname);
		(void) umask (omask);
		free (repname);
		return;
	    }
	    free (repname);

	    fp = CVS_FOPEN (fname, FOPEN_BINARY_WRITE);
	}
	if (fp == NULL)
	{
	    error (0, errno, "cannot write %s", fname);
	    (void) umask (omask);
	    return;
	}
    }
    (void) umask (omask);

    /* First write the "F" attributes.  */
    walklist (attrlist, writeattr_proc, fp);

    /* Then the "D" attribute.  */
    if (fileattr_default_attrs != NULL)
    {
	fputs ("D\t", fp);
	fputs (fileattr_default_attrs, fp);
	fputs ("\012", fp);
    }

    /* Then any other attributes.  */
    for (p = unrecog_head; p != NULL; p = p->next)
    {
	fputs (p->line, fp);
	fputs ("\012", fp);
    }

    if (fclose (fp) < 0)
	error (0, errno, "cannot close %s", fname);
    attrs_modified = 0;
    free (fname);
}

void
fileattr_free ()
{
    /* Note that attrs_modified will ordinarily be zero, but there are
       a few cases in which fileattr_write will fail to zero it (if
       noexec is set, or error conditions).  This probably is the way
       it should be.  */
    dellist (&attrlist);
    if (fileattr_stored_repos != NULL)
	free (fileattr_stored_repos);
    fileattr_stored_repos = NULL;
    if (fileattr_default_attrs != NULL)
	free (fileattr_default_attrs);
    fileattr_default_attrs = NULL;
    while (unrecog_head)
    {
	struct unrecog *p = unrecog_head;
	unrecog_head = p->next;
	free (p->line);
	free (p);
    }
}
@


1.1
log
@Initial revision
@
text
@d11 1
a11 5
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
d34 8
d52 1
d59 1
d61 1
d92 1
a92 1
    fp = fopen (fname, "r");
d103 1
a103 1
	nread = getline (&line, &line_len, fp);
d114 4
d124 6
a129 1
	    addnode (attrlist, newnode);
d137 4
d144 11
a154 1
	/* else just ignore the line, for future expansion.  */
d168 2
a169 2
    char *filename;
    char *attrname;
d182 12
a193 6
    node = findnode (attrlist, filename);
    if (node == NULL)
	/* A file not mentioned has no attributes.  */
	return NULL;
    p = node->data;
    while (1) {
d211 2
a212 2
    char *filename;
    char *attrname;
d233 2
a234 2
    char *attrname;
    char *attrval;
d329 3
a331 3
    char *filename;
    char *attrname;
    char *attrval;
a335 2
    attrs_modified = 1;

d343 1
a375 1
    free (node->data);
d379 2
d382 83
d469 1
a469 1
    char *filename;
d506 1
a506 1
    fputs ("\n", fp);
d516 1
d537 3
a539 1
    if (list_isempty (attrlist) && fileattr_default_attrs == NULL)
d556 1
a556 1
	if (rmdir (fname) < 0)
d572 1
a572 1
    fp = fopen (fname, "w");
d597 1
a597 1
	    fp = fopen (fname, "w");
d607 2
d610 2
d616 8
a623 1
	fputs ("\n", fp);
d625 1
d635 4
d646 7
@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d85 1
a85 1
    fp = fopen (fname, FOPEN_BINARY_READ);
d152 6
a157 12
    if (filename == NULL)
	p = fileattr_default_attrs;
    else
    {
	node = findnode (attrlist, filename);
	if (node == NULL)
	    /* A file not mentioned has no attributes.  */
	    return NULL;
	p = node->data;
    }
    while (1)
    {
d387 1
a387 1
    fputs ("\012", fp);
d450 1
a450 1
    fp = fopen (fname, FOPEN_BINARY_WRITE);
d475 1
a475 1
	    fp = fopen (fname, FOPEN_BINARY_WRITE);
d490 1
a490 1
	fputs ("\012", fp);
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@a53 1
    assert (node->data != NULL);
a54 1
    node->data = NULL;
d162 1
a162 1
    while (p)
a347 1
    node->data = NULL;
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d87 1
a87 1
    fp = CVS_FOPEN (fname, FOPEN_BINARY_READ);
d140 2
a141 2
    const char *filename;
    const char *attrname;
d183 2
a184 2
    const char *filename;
    const char *attrname;
d205 2
a206 2
    const char *attrname;
    const char *attrval;
d301 3
a303 3
    const char *filename;
    const char *attrname;
    const char *attrval;
d349 2
a353 2
    {
	free (node->data);
a354 1
    }
d359 1
a359 1
    const char *filename;
d443 1
a443 1
	if (CVS_RMDIR (fname) < 0)
d459 1
a459 1
    fp = CVS_FOPEN (fname, FOPEN_BINARY_WRITE);
d484 1
a484 1
	    fp = CVS_FOPEN (fname, FOPEN_BINARY_WRITE);
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d11 5
a15 1
   GNU General Public License for more details.  */
d308 2
a316 1
	attrs_modified = 1;
a355 2

    attrs_modified = 1;
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@a33 8
/* More in-memory attributes: linked list of unrecognized
   fileattr lines.  We pass these on unchanged.  */
struct unrecog {
    char *line;
    struct unrecog *next;
};
static struct unrecog *unrecog_head;

a43 1
    assert (unrecog_head == NULL);
d111 1
a111 6
	    if (addnode (attrlist, newnode) != 0)
		/* If the same filename appears twice in the file, discard
		   any line other than the first for that filename.  This
		   is the way that CVS has behaved since file attributes
		   were first introduced.  */
		free (newnode);
d122 1
a122 11
	else
	{
	    /* Unrecognized type, we want to just preserve the line without
	       changing it, for future expansion.  */
	    struct unrecog *new;

	    new = (struct unrecog *) xmalloc (sizeof (struct unrecog));
	    new->line = xstrdup (line);
	    new->next = unrecog_head;
	    unrecog_head = new;
	}
d424 1
a424 3
    if (list_isempty (attrlist)
	&& fileattr_default_attrs == NULL
	&& unrecog_head == NULL)
a491 2

    /* First write the "F" attributes.  */
a492 2

    /* Then the "D" attribute.  */
a498 15

    /* Then any other attributes.  */
    while (unrecog_head != NULL)
    {
	struct unrecog *p;

	p = unrecog_head;
	fputs (p->line, fp);
	fputs ("\012", fp);

	unrecog_head = p->next;
	free (p->line);
	free (p);
    }

@


1.1.1.7
log
@Latest version from Cyclic
@
text
@a378 80
char *
fileattr_getall (filename)
    const char *filename;
{
    Node *node;
    char *p;

    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
	/* Either nothing has any attributes, or fileattr_read already printed
	   an error message.  */
	return NULL;

    if (filename == NULL)
	p = fileattr_default_attrs;
    else
    {
	node = findnode (attrlist, filename);
	if (node == NULL)
	    /* A file not mentioned has no attributes.  */
	    return NULL;
	p = node->data;
    }
    return xstrdup (p);
}

void
fileattr_setall (filename, attrs)
    const char *filename;
    const char *attrs;
{
    Node *node;

    if (filename == NULL)
    {
	if (fileattr_default_attrs != NULL)
	    free (fileattr_default_attrs);
	fileattr_default_attrs = xstrdup (attrs);
	attrs_modified = 1;
	return;
    }
    if (attrlist == NULL)
	fileattr_read ();
    if (attrlist == NULL)
    {
	/* Not sure this is a graceful way to handle things
	   in the case where fileattr_read was unable to read the file.  */
        /* No attributes existed previously.  */
	attrlist = getlist ();
    }

    node = findnode (attrlist, filename);
    if (node == NULL)
    {
	/* The file had no attributes.  Add them if we have any to add.  */
	if (attrs != NULL)
	{
	    node = getnode ();
	    node->type = FILEATTR;
	    node->delproc = fileattr_delproc;
	    node->key = xstrdup (filename);
	    node->data = xstrdup (attrs);
	    addnode (attrlist, node);
	}
    }
    else
    {
	if (attrs == NULL)
	    delnode (node);
	else
	{
	    free (node->data);
	    node->data = xstrdup (attrs);
	}
    }

    attrs_modified = 1;
}

a552 4
    /* Note that attrs_modified will ordinarily be zero, but there are
       a few cases in which fileattr_write will fail to zero it (if
       noexec is set, or error conditions).  This probably is the way
       it should be.  */
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@a113 4
	    if (p == NULL)
		error (1, 0,
		       "file attribute database corruption: tab missing in %s",
		       fname);
a132 4
	    if (p == NULL)
		error (1, 0,
		       "file attribute database corruption: tab missing in %s",
		       fname);
@


1.1.1.9
log
@Latest from Cyclic Software
@
text
@d129 1
a129 1
		freenode (newnode);
a515 1
    struct unrecog *p;
d619 1
a619 1
    for (p = unrecog_head; p != NULL; p = p->next)
d621 3
d626 4
a651 7
    while (unrecog_head)
    {
	struct unrecog *p = unrecog_head;
	unrecog_head = p->next;
	free (p->line);
	free (p);
    }
@


