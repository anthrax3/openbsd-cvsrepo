head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.8.0.66
	OPENBSD_6_2_BASE:1.1.1.8
	OPENBSD_6_1:1.1.1.8.0.68
	OPENBSD_6_1_BASE:1.1.1.8
	OPENBSD_6_0:1.1.1.8.0.64
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.60
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.62
	OPENBSD_5_8_BASE:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.54
	OPENBSD_5_7_BASE:1.1.1.8
	OPENBSD_5_6:1.1.1.8.0.58
	OPENBSD_5_6_BASE:1.1.1.8
	OPENBSD_5_5:1.1.1.8.0.56
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.52
	OPENBSD_5_4_BASE:1.1.1.8
	OPENBSD_5_3:1.1.1.8.0.50
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.48
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.46
	OPENBSD_5_0:1.1.1.8.0.44
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.42
	OPENBSD_4_9_BASE:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.40
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.36
	OPENBSD_4_7_BASE:1.1.1.8
	OPENBSD_4_6:1.1.1.8.0.38
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.34
	OPENBSD_4_5_BASE:1.1.1.8
	OPENBSD_4_4:1.1.1.8.0.32
	OPENBSD_4_4_BASE:1.1.1.8
	OPENBSD_4_3:1.1.1.8.0.30
	OPENBSD_4_3_BASE:1.1.1.8
	OPENBSD_4_2:1.1.1.8.0.28
	OPENBSD_4_2_BASE:1.1.1.8
	OPENBSD_4_1:1.1.1.8.0.26
	OPENBSD_4_1_BASE:1.1.1.8
	OPENBSD_4_0:1.1.1.8.0.24
	OPENBSD_4_0_BASE:1.1.1.8
	OPENBSD_3_9:1.1.1.8.0.22
	OPENBSD_3_9_BASE:1.1.1.8
	OPENBSD_3_8:1.1.1.8.0.20
	OPENBSD_3_8_BASE:1.1.1.8
	OPENBSD_3_7:1.1.1.8.0.18
	OPENBSD_3_7_BASE:1.1.1.8
	OPENBSD_3_6:1.1.1.8.0.16
	OPENBSD_3_6_BASE:1.1.1.8
	OPENBSD_3_5:1.1.1.8.0.14
	OPENBSD_3_5_BASE:1.1.1.8
	OPENBSD_3_4:1.1.1.8.0.12
	OPENBSD_3_4_BASE:1.1.1.8
	OPENBSD_3_3:1.1.1.8.0.10
	OPENBSD_3_3_BASE:1.1.1.8
	OPENBSD_3_2:1.1.1.8.0.8
	OPENBSD_3_2_BASE:1.1.1.8
	OPENBSD_3_1:1.1.1.8.0.6
	OPENBSD_3_1_BASE:1.1.1.8
	OPENBSD_3_0:1.1.1.8.0.4
	OPENBSD_3_0_BASE:1.1.1.8
	cvs-1-11-1p1:1.1.1.8
	OPENBSD_2_9:1.1.1.8.0.2
	OPENBSD_2_9_BASE:1.1.1.8
	cvs-1-11:1.1.1.8
	OPENBSD_2_8:1.1.1.7.0.6
	OPENBSD_2_8_BASE:1.1.1.7
	OPENBSD_2_7:1.1.1.7.0.4
	OPENBSD_2_7_BASE:1.1.1.7
	OPENBSD_2_6:1.1.1.7.0.2
	OPENBSD_2_6_BASE:1.1.1.7
	cvs-1-10-7:1.1.1.7
	OPENBSD_2_5:1.1.1.6.0.2
	OPENBSD_2_5_BASE:1.1.1.6
	cvs-1-10-5:1.1.1.6
	OPENBSD_2_4:1.1.1.5.0.4
	OPENBSD_2_4_BASE:1.1.1.5
	cvs-1-10:1.1.1.5
	cvs-1-9-28:1.1.1.5
	OPENBSD_2_3:1.1.1.5.0.2
	OPENBSD_2_3_BASE:1.1.1.5
	cvs-1-9-26:1.1.1.5
	cvs-1-9-24:1.1.1.5
	OPENBSD_2_2:1.1.1.4.0.4
	OPENBSD_2_2_BASE:1.1.1.4
	cvs-1-9-10:1.1.1.4
	OPENBSD_2_1:1.1.1.4.0.2
	OPENBSD_2_1_BASE:1.1.1.4
	cvs-1-9-8:1.1.1.4
	cvs-1-9-6:1.1.1.4
	cvs-1-9-4:1.1.1.4
	cvs-1-9-2:1.1.1.3
	cvs-1-9:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	cvs-1-8-1:1.1.1.1
	cvs-1-8:1.1.1.1
	cvs-1-7-2:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	96.04.27.19.40.52;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.04.27.19.40.52;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.10.18.03.34.37;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.02.21.06.36.08;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.03.18.01.55.02;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	98.02.22.08.19.58;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.02.28.21.30.36;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.10.05.06.03;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2001.02.10.18.57.19;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@How to write code for CVS

* Compiler options

If you are using GCC, you'll want to configure with -Wall, which can
detect many programming errors.  This is not the default because it
might cause spurious warnings, but at least on some machines, there
should be no spurious warnings.  For example:

	$ CFLAGS="-g -Wall" ./configure

Configure is not very good at remembering this setting; it will get
wiped out whenever you do a ./config.status --recheck, so you'll need
to use:

	$ CFLAGS="-g -Wall" ./config.status --recheck

* Indentation style

CVS mostly uses a consistent indentation style which looks like this:

void
foo (arg)
    char *arg;
{
    if (arg != NULL)
    {
	bar (arg);
	baz (arg);
    }
}

The file cvs-format.el contains settings for emacs and the NEWS file
contains a set of options for the indent program which I haven't tried
but which are correct as far as I know.  You will find some code which
does not conform to this indentation style; the plan is to reindent it
as those sections of the code are changed (one function at a time,
perhaps).

In a submitted patch it is acceptable to refrain from changing the
indentation of large blocks of code to minimize the size of the patch;
the person checking in such a patch should reindent it.

* Portability

If it is in ANSI C and it is in SunOS4 (using /bin/cc), generally it
is OK to use it without ifdefs (for example, assert() and void * as
long as you add more casts to and from void * than ANSI requires.  But
not function prototypes).  Such constructs are generally portable
enough, including to NT, OS/2, VMS, etc.

* Run-time behaviors

Use assert() to check "can't happen" conditions internal to CVS.  We
realize that there are functions in CVS which instead return NULL or
some such value (thus confusing the meaning of such a returned value),
but we want to fix that code.  Of course, bad input data, a corrupt
repository, bad options, etc., should always print a real error
message instead.

* Coding standards in general

Generally speaking the GNU coding standards are mostly used by CVS
(but see the exceptions mentioned above, such as indentation style,
and perhaps an exception or two we haven't mentioned).  This is the
file standards.text at the GNU FTP sites.

* Submitting patches

Please include a ChangeLog entry (see the GNU coding standards for
information on writing one) with patches.  Include a description of
what the patch does (sometimes the ChangeLog entry and/or comments in
the code are appropriate for this, but not always)--patches should not
be checked in unless there is some reason for them, and the
description may be helpful if there is a better way to solve the
problem.  In addition to the ChangeLog entry, there should be a change
to the NEWS file in the case of a new feature.

If you solve several unrelated problems, submit a separate
patch for each one.  Patches should be tested before submission.  Use
context diffs or unidiffs for patches.

Note that all submitted changes may be distributed under the terms of
the GNU Public License, so if you don't like this, don't submit them.
Submit changes to bug-cvs@@prep.ai.mit.edu.

Generally speaking if you follow the guidelines in this file you can
expect a yes or no answer about whether your patch is accepted.  But
even in this case there is no guarantee because wading through a bunch
of submissions can be time consuming, and noone has volunteered to
offer any such guarantee.  If you don't receive an answer one way or
another within a month, feel free to ask what the status is.  You can,
if you wish, distribute your patch on mailing lists or newsgroups, if
you want to make it available before it gets merged.

* What is the schedule for the next release?

There isn't one.  That is, upcoming releases are not announced (or
even hinted at, really) until the feature freeze which is
approximately 2 weeks before the final release (at this time test
releases start appearing and are announced on info-cvs).  This is
intentional, to avoid a last minute rush to get new features in.
@


1.1.1.1
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@@


1.1.1.2
log
@New release from Cyclic Software
@
text
@d46 5
a50 11
The general rule for portability is that it is only worth including
portability cruft for systems on which people are actually testing and
using new CVS releases.  Without testing, CVS will fail to be portable
for any number of unanticipated reasons.

The current consequence of that general rule seems to be that if it
is in ANSI C and it is in SunOS4 (using /bin/cc), generally it is OK
to use it without ifdefs (for example, assert() and void * as long as
you add more casts to and from void * than ANSI requires.  But not
function prototypes).  Such constructs are generally portable enough,
including to NT, OS/2, VMS, etc.
a60 16
We realize that CVS contains many arbitrary limits (such as PATH_MAX).
Do not do this in new code; we are trying to *fix* those arbitrary
limits.  In particular, it should be possible to pass very long
arguments (e.g. from a WWW cgi script) to CVS without having it
overrun any buffers (which might create a security hole in the WWW
example).

Although this is a long-term goal, it also would be nice to move CVS
in the direction of reentrancy.  This reduces the size of the data
segment and will allow a multi-threaded server if that is desirable.
It is also useful to write the code so that it can be easily be made
reentrant later.  For example, if you need to pass data from a
Parse_Info caller to its callproc, you need a static variable.  But
use a single pointer so that when Parse_Info is fixed to pass along a
void * argument, then the code can easily use that argument.

a67 4
Filenames for .c and .h files may contain _ but should not contain -
(the latter causes Visual C++ 2.1 to create makefiles which Visual C++
4.0 cannot use).

d77 1
a77 1
to the NEWS file and cvs.texinfo in the case of a user-visible change.
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@d94 1
a94 34
* Submitting patches (strategy)

Only some kinds of changes are suitable for inclusion in the
"official" CVS.  Bugfixes, where CVS's behavior contradicts the
documentation and/or expectations that everyone agrees on, should be
OK (strategically).  For features, the desirable attributes are that
the need is clear and that they fit nicely into the architecture of
CVS.

However, if there is reason to think that a change would significantly
inconvenience any significant body of CVS users, or would be
controversial for other reasons, then the design should be re-thought.
Go back to the requirements (writing documentation might help, if you
write the documentation to explain why one would use the feature not
just what the feature does).  Think about whether there is a behavior
which works in both your situation and the other situations.  Make a
list of the issues (for example, submit a comment or documentation
change).  Ask your coworkers, a newsgroup, or a mailing list, and see
what other people think.  Distribute some experimental patches outside
the "official" CVS and see what people think.  By this process, the
intention is that once-controversial changes can be refined to the
point where they are relatively uncontroversial before they are
actually checked in to the "official" CVS.  Features like zlib,
encryption, and others have benefitted from this process in the past
by being mentioned in the documentation and/or discussed, before an
implementation was checked in.

If longstanding CVS behavior, that people may be relying on, is
clearly deficient, it can be changed, but only slowly and carefully.
For example, the global -q option was introduced in CVS 1.3 but the
command -q options, which the global -q replaced, were not removed
until CVS 1.6.

* Submitting patches (tactics)
a103 3

It is nice to have a test case (see TESTS), especially for fixes which
involve subtle behaviors or twisted sections of the code.
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d136 1
a136 2
to the NEWS file and cvs.texinfo, if the change is a user-visible
change worth mentioning.
a164 27

* Mailing lists

Anyone can add themselves to the following mailing lists:

    devel-cvs.  Unless you are accepted as a CVS developer as
      described in the DEVEL-CVS file, you will only be able to
      read this list, not send to it.  The charter of the list is
      also in DEVEL-CVS.
    commit-cvs.  The only messages sent to this list are sent
      automatically, via the CVS `loginfo' mechanism, when someone
      checks something in to the master CVS repository.
    test-results.  The only messages sent to this list are sent
      automatically, daily, by a script which runs "make check"
      and "make remotecheck" on the master CVS sources.
To subscribe to devel-cvs, commit-cvs, or test-results, send
a message to "majordomo@@cyclic.com" whose body consists of
"subscribe <list>", where <list> is devel-cvs, commit-cvs or
test-results.

One other list related to CVS development is bug-cvs.  This is the
list which users are requested to send bug reports to.  Anyone can
subscribe; to do so send mail to bug-cvs-request@@prep.ai.mit.edu.

Other CVS discussions take place on the info-cvs mailing list
(send mail to info-cvs-request@@prep.ai.mit.edu to subscribe) or on
the newsgroup comp.software.config-mgmt.
@


1.1.1.5
log
@Latest version from Cyclic
@
text
@a30 6
    switch (c)
    {
	case 'A':
	    aflag = 1;
	    break;
    }
d67 6
a72 7
Do not use arbitrary limits (such as PATH_MAX) except perhaps when the
operating system or some external interface requires it.  We spent a
lot of time getting rid of them, and we don't want to put them back.
If you find any that we missed, please report it as with other bugs.
In most cases such code will create security holes (for example, for
anonymous readonly access via the CVS protocol, or if a WWW cgi script
passes client-supplied arguments to CVS).
d148 1
a148 1
Submit changes to bug-cvs@@gnu.org.
d188 1
a188 1
subscribe; to do so send mail to bug-cvs-request@@gnu.org.
@


1.1.1.6
log
@Latest version from Cyclic
@
text
@d198 1
a198 1
(send mail to info-cvs-request@@gnu.org to subscribe) or on
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d101 1
a101 1
* Writing patches (strategy)
d108 1
a108 2
CVS.  Is it worth the cost (in terms of complexity or any other
tradeoffs involved)?  Are there better solutions?
d110 17
a126 9
If the design is not yet clear (which is true of most features), then
the design is likely to benefit from more work and community input.
Make a list of issues, or write documentation including rationales for
how one would use the feature.  Discuss it with coworkers, a
newsgroup, or a mailing list, and see what other people think.
Distribute some experimental patches and see what people think.  The
intention is arrive at some kind of rough community consensus before
changing the "official" CVS.  Features like zlib, encryption, and
the RCS library have benefitted from this process in the past.
d134 1
a134 1
* Writing patches (tactics)
d136 29
a164 41
When you first distribute a patch it may be suitable to just put forth
a rough patch, or even just an idea.  But before the end of the
process the following should exist:

  - ChangeLog entry (see the GNU coding standards for details).

  - Changes to the NEWS file and cvs.texinfo, if the change is a
    user-visible change worth mentioning.

  - Somewhere, a description of what the patch fixes (often in
    comments in the code, or maybe the ChangeLog or documentation).

  - Most of the time, a test case (see TESTS).  It can be quite
    frustrating to fix a bug only to see it reappear later, and adding
    the case to the testsuite, where feasible, solves this and other
    problems.

If you solve several unrelated problems, it is generally easier to
consider the desirability of the changes if there is a separate patch
for each issue.  Use context diffs or unidiffs for patches.

Include words like "I grant permission to distribute this patch under
the terms of the GNU Public License" with your patch.  By sending a
patch to bug-cvs@@gnu.org, you implicitly grant this permission.

Submitting a patch to bug-cvs is the way to reach the people who have
signed up to receive such submissions (including CVS developers), but
there may or may not be much (or any) response.  If you want to pursue
the matter further, you are probably best off working with the larger
CVS community.  Distribute your patch as widely as desired (mailing
lists, newsgroups, web sites, whatever).  Write a web page or other
information describing what the patch is for.  It is neither practical
nor desirable for all/most contributions to be distributed through the
"official" (whatever that means) mechanisms of CVS releases and CVS
developers.  Now, the "official" mechanisms do try to incorporate
those patches which seem most suitable for widespread usage, together
with test cases and documentation.  So if a patch becomes sufficiently
popular in the CVS community, it is likely that one of the CVS
developers will eventually try to do something with it.  But dealing
with the CVS developers may be the last step of the process rather
than the first.
@


1.1.1.8
log
@Latest from Cyclic Software
@
text
@d194 1
a194 1
a message to "majordomo@@cvshome.org" whose body consists of
@


