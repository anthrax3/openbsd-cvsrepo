head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.80
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.76
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.72
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.74
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.66
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.70
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.68
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.64
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.62
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.60
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.58
	OPENBSD_5_0:1.1.1.3.0.56
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.54
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.52
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.48
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.50
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.46
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.44
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.42
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.40
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.38
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.36
	OPENBSD_4_0_BASE:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.34
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.32
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.30
	OPENBSD_3_7_BASE:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.28
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.26
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.24
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.22
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.20
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.18
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.16
	OPENBSD_3_0_BASE:1.1.1.3
	cvs-1-11-1p1:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.14
	OPENBSD_2_9_BASE:1.1.1.3
	cvs-1-11:1.1.1.3
	OPENBSD_2_8:1.1.1.3.0.12
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.10
	OPENBSD_2_7_BASE:1.1.1.3
	OPENBSD_2_6:1.1.1.3.0.8
	OPENBSD_2_6_BASE:1.1.1.3
	cvs-1-10-7:1.1.1.3
	OPENBSD_2_5:1.1.1.3.0.6
	OPENBSD_2_5_BASE:1.1.1.3
	cvs-1-10-5:1.1.1.3
	OPENBSD_2_4:1.1.1.3.0.4
	OPENBSD_2_4_BASE:1.1.1.3
	cvs-1-10:1.1.1.3
	cvs-1-9-28:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.2
	OPENBSD_2_3_BASE:1.1.1.3
	cvs-1-9-26:1.1.1.3
	cvs-1-9-24:1.1.1.3
	OPENBSD_2_2:1.1.1.2.0.4
	OPENBSD_2_2_BASE:1.1.1.2
	cvs-1-9-10:1.1.1.2
	OPENBSD_2_1:1.1.1.2.0.2
	OPENBSD_2_1_BASE:1.1.1.2
	cvs-1-9-8:1.1.1.2
	cvs-1-9-6:1.1.1.2
	cvs-1-9-4:1.1.1.2
	cvs-1-9-2:1.1.1.2
	cvs-1-9:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	96.10.18.03.37.10;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.18.03.37.10;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.02.21.06.39.09;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.02.22.08.22.55;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * Copyright © 1994 the Free Software Foundation, Inc.
 *
 * Author: Roland B. Roberts (roberts@@nsrl.rochester.edu)
 *
 * This file is a part of GNU VMSLIB, the GNU library for porting GNU
 * software to VMS.
 *
 * GNU VMSLIB is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * GNU VMSLIB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU VMSLIB; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * Miscellaneous utilities used by hackargv().
 * Some of these are useful in their own right.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <lib$routines.h>

/* Print message and force core dump (unix) or traceback (vms)
 * These are taken from other GNU software more-or-less as-is
 */
void fatal (char *s)
{
  int *x;
  printf ("%s\n", s);
  lib$signal(44);
}

/* GNU's lib implementation (alloca.c) is more portable, so I disabled these
   for this distribution (benjamin@@cyclic.com) */
#ifdef USE_VMSLIB_MEMORY_ALLOCATION
void *xmalloc (int size)
{
  register void *val;
  /* Avoid failure if malloc (0) returns 0.  */
  if (size == 0)
    size = 1;
  val = (void *) malloc (size);
  if (!val) fatal ("xmalloc: can't satisfy request");
  return val;
}

void *xrealloc (void *block, int size)
{
  register void *val;
  /* Avoid failure if malloc (0) returns 0.  */
  if (size == 0)
    size = 1;
  val = (void *) realloc (block, size);
  if (!val) fatal ("xrealloc: can't satisfy request");
  return val;
}
#endif

/* See in misc.h why it is done like this.  */
void x_free (void *block)
{
  free (block);
}

/*
 * Some string utilities.
 */
char *downcase (char *s)
{
  register char *t;
  for (t = s ; *t; t++)
    *t = tolower(*t);
  return (s);
}

char *strdup (char *src) {
  char *dst = (char*) xmalloc (strlen(src) + 1);
  strcpy (dst, src);
  return (dst);
}

char *strndup (char *src, int len) {
  char *dst = (char *) xmalloc (len + 1);
  strncpy (dst, src, len);
  dst[len] = 0;
  return (dst);
}

#include <string.h>

/*
 * int fixpath (char *path)
 *
 * Synopsis:
 *   `Fix' VMS pathnames, converting them to canonical form.
 *
 * Description:
 *   The following conversions are performed
 *     x:[y.][000000.z] --> x:[y.z]
 *     x:[y.][z]        --> x:[y.z]
 *     x:[000000.y]     --> x:[y]
 *
 * Author:
 *   Roland B Roberts (roberts@@nsrl.rochester.edu)
 *   March 1994
 */
int fixpath (char *path)
{
  char *s, *d, *t;
  int skip = 0;
  d = s = path;
  if (t = strstr(path ,".][000000"))
    skip = 9;
  else if (t = strstr(path,"]["))
    skip = 2;
  else if (t = strstr(path,"[000000."))
    t++, skip = 7;
  if (t) {
    while (s < t)
      *d++ = *s++;
    s += skip;
    while (*d++ = *s++);
  }
  return 0;
}


#include <ctype.h>
#include <string.h>

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

/*
 * char *argvconcat (int argc, char **argv)
 *
 * Synopsis:
 *   Concatenate all elements of argv into a single string suitable for
 *   use as a command line.
 *
 * Description:
 *   This is intended for use with hackargv() in order to build a command
 *   line for background() or popen().  Each element of argv (except the
 *   first) is surrounded by double quotes to insure the command line is
 *   unaltered when DCL rereads it.
 *
 * Side Effect:
 *   Space for the new string is allocated with xmalloc().
 *
 * Author:
 *   Roland B Roberts (roberts@@nsrl.rochester.edu)
 *   March 1994
 */

char *argvconcat (int argc, char **argv)
{
  int i, j, n, addquotes, flags, pid, status;
  char *cmdline;
  /*
   * Allocate space
   */
  for (j = n = 0; j < argc; j++)
    n += 3 + strlen(argv[j]);	/* Need 3 extra spaces, not 1; see below */
  cmdline = (char *) xmalloc ((n + 1) * sizeof (char));
  sprintf (cmdline, "%s ", argv[0]);
  for (j = 1, addquotes = FALSE; j < argc; j++) {
    /*
     * Add double quotes to arg if it contains uppercase of spaces.
     * Hence, the need to allocate three extra spaces for each argument.
     */
    for (i = 0; i < strlen(argv[j]); i++)
      if (isupper(argv[j][i]) || isspace(argv[j][i])) {
	addquotes = TRUE;
	break;
      }
    if (addquotes) {
      strcat (cmdline, argv[j]);
      strcat (cmdline, " ");
    }
    else {
      strcat (cmdline, "\"");	/* use quotes to preserve case */
      strcat (cmdline, argv[j]);
      strcat (cmdline, "\" ");
    }
  }
  cmdline[strlen(cmdline)-1] = 0;
  return (cmdline);
}
@


1.1.1.1
log
@New release from Cyclic Software
@
text
@@


1.1.1.2
log
@New release from Cyclic Software
@
text
@d18 4
@


1.1.1.3
log
@Latest version from Cyclic
@
text
@d30 36
d81 6
@

