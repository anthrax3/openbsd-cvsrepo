head	1.3;
access;
symbols
	OPENBSD_6_2:1.3.0.68
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.66
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.62
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.58
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.60
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.52
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.56
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.54
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.50
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.48
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.46
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.44
	OPENBSD_5_0:1.3.0.42
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.40
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.38
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.34
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.36
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.32
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.30
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.28
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.26
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.24
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.22
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.20
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.18
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.16
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.14
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.12
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.1.1.17.0.2
	OPENBSD_2_9_BASE:1.1.1.17
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.1.1.16.0.6
	OPENBSD_2_8_BASE:1.1.1.16
	OPENBSD_2_7:1.1.1.16.0.4
	OPENBSD_2_7_BASE:1.1.1.16
	OPENBSD_2_6:1.1.1.16.0.2
	OPENBSD_2_6_BASE:1.1.1.16
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.1.1.15.0.2
	OPENBSD_2_5_BASE:1.1.1.15
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.1.1.14.0.2
	OPENBSD_2_4_BASE:1.1.1.14
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.1.1.12.0.2
	OPENBSD_2_3_BASE:1.1.1.12
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.1.1.10.0.2
	OPENBSD_2_2_BASE:1.1.1.10
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.1.1.9.0.2
	OPENBSD_2_1_BASE:1.1.1.9
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2001.09.30.19.44.54;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.29.00.00.39;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.39;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.41.29;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.20.02.43;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.27.16;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.41.40;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.47.25;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.02.05.54;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.46.01;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.34.12;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.35.15;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.30.49;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.07.05.54;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.04.04.49;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.57.34;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.40.04;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.14.50;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.19.03.14;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.48.51;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Revert to distributed version
@
text
@This is cvs.info, produced by makeinfo version 4.0 from cvs.texinfo.

START-INFO-DIR-ENTRY
* CVS: (cvs).          Concurrent Versions System
END-INFO-DIR-ENTRY

   Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: cvs.info,  Node: Tags,  Next: Tagging the working directory,  Prev: Assigning revisions,  Up: Revisions

Tags-Symbolic revisions
=======================

   The revision numbers live a life of their own.  They need not have
anything at all to do with the release numbers of your software
product.  Depending on how you use CVS the revision numbers might
change several times between two releases.  As an example, some of the
source files that make up RCS 5.6 have the following revision numbers:

     ci.c            5.21
     co.c            5.9
     ident.c         5.3
     rcs.c           5.12
     rcsbase.h       5.11
     rcsdiff.c       5.10
     rcsedit.c       5.11
     rcsfcmp.c       5.9
     rcsgen.c        5.10
     rcslex.c        5.11
     rcsmap.c        5.2
     rcsutil.c       5.10

   You can use the `tag' command to give a symbolic name to a certain
revision of a file.  You can use the `-v' flag to the `status' command
to see all tags that a file has, and which revision numbers they
represent.  Tag names must start with an uppercase or lowercase letter
and can contain uppercase and lowercase letters, digits, `-', and `_'.
The two tag names `BASE' and `HEAD' are reserved for use by CVS.  It is
expected that future names which are special to CVS will be specially
named, for example by starting with `.', rather than being named
analogously to `BASE' and `HEAD', to avoid conflicts with actual tag
names.

   You'll want to choose some convention for naming tags, based on
information such as the name of the program and the version number of
the release.  For example, one might take the name of the program,
immediately followed by the version number with `.' changed to `-', so
that CVS 1.9 would be tagged with the name `cvs1-9'.  If you choose a
consistent convention, then you won't constantly be guessing whether a
tag is `cvs-1-9' or `cvs1_9' or what.  You might even want to consider
enforcing your convention in the taginfo file (*note user-defined
logging::).

   The following example shows how you can add a tag to a file.  The
commands must be issued inside your working directory.  That is, you
should issue the command in the directory where `backend.c' resides.

     $ cvs tag rel-0-4 backend.c
     T backend.c
     $ cvs status -v backend.c
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         (none)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             rel-0-4                     (revision: 1.4)

   For a complete summary of the syntax of `cvs tag', including the
various options, see *Note Invoking CVS::.

   There is seldom reason to tag a file in isolation.  A more common
use is to tag all the files that constitute a module with the same tag
at strategic points in the development life-cycle, such as when a
release is made.

     $ cvs tag rel-1-0 .
     cvs tag: Tagging .
     T Makefile
     T backend.c
     T driver.c
     T frontend.c
     T parser.c

   (When you give CVS a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  *Note Recursive behavior::.)

   The `checkout' command has a flag, `-r', that lets you check out a
certain revision of a module.  This flag makes it easy to retrieve the
sources that make up release 1.0 of the module `tc' at any time in the
future:

     $ cvs checkout -r rel-1-0 tc

This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.

   You can also check out a module as it was at any given date.  *Note
checkout options::.  When specifying `-r' to any of these commands, you
will need beware of sticky tags; see *Note Sticky tags::.

   When you tag more than one file with the same tag you can think
about the tag as "a curve drawn through a matrix of filename vs.
revision number."  Say we have 5 files with the following revisions:

             file1   file2   file3   file4   file5
     
             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6

   At some time in the past, the `*' versions were tagged.  You can
think of the tag as a handle attached to the curve drawn through the
tagged revisions.  When you pull on the handle, you get all the tagged
revisions.  Another way to look at it is that you "sight" through a set
of revisions that is "flat" along the tagged revisions, like this:

             file1   file2   file3   file4   file5
     
                             1.1
                             1.2
                     1.1     1.3                       _
             1.1     1.2     1.4     1.1              /
             1.2*----1.3*----1.5*----1.2*----1.1     (--- <--- Look here
             1.3             1.6     1.3              \_
             1.4                     1.4
                                     1.5


File: cvs.info,  Node: Tagging the working directory,  Next: Tagging by date/tag,  Prev: Tags,  Up: Revisions

Specifying what to tag from the working directory
=================================================

   The example in the previous section demonstrates one of the most
common ways to choose which revisions to tag.  Namely, running the `cvs
tag' command without arguments causes CVS to select the revisions which
are checked out in the current working directory.  For example, if the
copy of `backend.c' in working directory was checked out from revision
1.4, then CVS will tag revision 1.4.  Note that the tag is applied
immediately to revision 1.4 in the repository; tagging is not like
modifying a file, or other operations in which one first modifies the
working directory and then runs `cvs commit' to transfer that
modification to the repository.

   One potentially surprising aspect of the fact that `cvs tag'
operates on the repository is that you are tagging the checked-in
revisions, which may differ from locally modified files in your working
directory.  If you want to avoid doing this by mistake, specify the
`-c' option to `cvs tag'.  If there are any locally modified files, CVS
will abort with an error before it tags any files:

     $ cvs tag -c rel-0-4
     cvs tag: backend.c is locally modified
     cvs [tag aborted]: correct the above errors first!


File: cvs.info,  Node: Tagging by date/tag,  Next: Modifying tags,  Prev: Tagging the working directory,  Up: Revisions

Specifying what to tag by date or revision
==========================================

   The `cvs rtag' command tags the repository as of a certain date or
time (or can be used to tag the latest revision).  `rtag' works
directly on the repository contents (it requires no prior checkout and
does not look for a working directory).

   The following options specify which date or revision to tag.  See
*Note Common options::, for a complete description of them.

`-D DATE'
     Tag the most recent revision no later than DATE.

`-f'
     Only useful with the `-D DATE' or `-r TAG' flags.  If no matching
     revision is found, use the most recent revision (instead of
     ignoring the file).

`-r TAG'
     Only tag those files that contain existing tag TAG.

   The `cvs tag' command also allows one to specify files by revision
or date, using the same `-r', `-D', and `-f' options.  However, this
feature is probably not what you want.  The reason is that `cvs tag'
chooses which files to tag based on the files that exist in the working
directory, rather than the files which existed as of the given tag/date.
Therefore, you are generally better off using `cvs rtag'.  The
exceptions might be cases like:

     cvs tag -r 1.4 backend.c


File: cvs.info,  Node: Modifying tags,  Next: Tagging add/remove,  Prev: Tagging by date/tag,  Up: Revisions

Deleting, moving, and renaming tags
===================================

   Normally one does not modify tags.  They exist in order to record
the history of the repository and so deleting them or changing their
meaning would, generally, not be what you want.

   However, there might be cases in which one uses a tag temporarily or
accidentally puts one in the wrong place.  Therefore, one might delete,
move, or rename a tag.  Warning: the commands in this section are
dangerous; they permanently discard historical information and it can
difficult or impossible to recover from errors.  If you are a CVS
administrator, you may consider restricting these commands with taginfo
(*note user-defined logging::).

   To delete a tag, specify the `-d' option to either `cvs tag' or `cvs
rtag'.  For example:

     cvs rtag -d rel-0-4 tc

   deletes the tag `rel-0-4' from the module `tc'.

   When we say "move" a tag, we mean to make the same name point to
different revisions.  For example, the `stable' tag may currently point
to revision 1.4 of `backend.c' and perhaps we want to make it point to
revision 1.6.  To move a tag, specify the `-F' option to either `cvs
tag' or `cvs rtag'.  For example, the task just mentioned might be
accomplished as:

     cvs tag -r 1.6 -F stable backend.c

   When we say "rename" a tag, we mean to make a different name point
to the same revisions as the old tag.  For example, one may have
misspelled the tag name and want to correct it (hopefully before others
are relying on the old spelling).  To rename a tag, first create a new
tag using the `-r' option to `cvs rtag', and then delete the old name.
This leaves the new tag on exactly the same files as the old tag.  For
example:

     cvs rtag -r old-name-0-4 rel-0-4 tc
     cvs rtag -d old-name-0-4 tc


File: cvs.info,  Node: Tagging add/remove,  Next: Sticky tags,  Prev: Modifying tags,  Up: Revisions

Tagging and adding and removing files
=====================================

   The subject of exactly how tagging interacts with adding and
removing files is somewhat obscure; for the most part CVS will keep
track of whether files exist or not without too much fussing.  By
default, tags are applied to only files which have a revision
corresponding to what is being tagged.  Files which did not exist yet,
or which were already removed, simply omit the tag, and CVS knows to
treat the absence of a tag as meaning that the file didn't exist as of
that tag.

   However, this can lose a small amount of information.  For example,
suppose a file was added and then removed.  Then, if the tag is missing
for that file, there is no way to know whether the tag refers to the
time before the file was added, or the time after it was removed.  If
you specify the `-r' option to `cvs rtag', then CVS tags the files
which have been removed, and thereby avoids this problem.  For example,
one might specify `-r HEAD' to tag the head.

   On the subject of adding and removing files, the `cvs rtag' command
has a `-a' option which means to clear the tag from removed files that
would not otherwise be tagged.  For example, one might specify this
option in conjunction with `-F' when moving a tag.  If one moved a tag
without `-a', then the tag in the removed files might still refer to
the old revision, rather than reflecting the fact that the file had
been removed.  I don't think this is necessary if `-r' is specified, as
noted above.


File: cvs.info,  Node: Sticky tags,  Prev: Tagging add/remove,  Up: Revisions

Sticky tags
===========

   Sometimes a working copy's revision has extra data associated with
it, for example it might be on a branch (*note Branching and
merging::), or restricted to versions prior to a certain date by
`checkout -D' or `update -D'.  Because this data persists - that is, it
applies to subsequent commands in the working copy - we refer to it as
"sticky".

   Most of the time, stickiness is an obscure aspect of CVS that you
don't need to think about.  However, even if you don't want to use the
feature, you may need to know _something_ about sticky tags (for
example, how to avoid them!).

   You can use the `status' command to see if any sticky tags or dates
are set:

     $ cvs status driver.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
         RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)

   The sticky tags will remain on your working files until you delete
them with `cvs update -A'.  The `-A' option retrieves the version of
the file from the head of the trunk, and forgets any sticky tags,
dates, or options.

   The most common use of sticky tags is to identify which branch one
is working on, as described in *Note Accessing branches::.  However,
non-branch sticky tags have uses as well.  For example, suppose that
you want to avoid updating your working directory, to isolate yourself
from possibly destabilizing changes other people are making.  You can,
of course, just refrain from running `cvs update'.  But if you want to
avoid updating only a portion of a larger tree, then sticky tags can
help.  If you check out a certain revision (such as 1.4) it will become
sticky.  Subsequent `cvs update' commands will not retrieve the latest
revision until you reset the tag with `cvs update -A'.  Likewise, use
of the `-D' option to `update' or `checkout' sets a "sticky date",
which, similarly, causes that date to be used for future retrievals.

   People often want to retrieve an old version of a file without
setting a sticky tag.  This can be done with the `-p' option to
`checkout' or `update', which sends the contents of the file to
standard output.  For example:
     $ cvs update -p -r 1.1 file1 >file1
     ===================================================================
     Checking out file1
     RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
     VERS: 1.1
     ***************
     $

   However, this isn't the easiest way, if you are asking how to undo a
previous checkin (in this example, put `file1' back to the way it was
as of revision 1.1).  In that case you are better off using the `-j'
option to `update'; for further discussion see *Note Merging two
revisions::.


File: cvs.info,  Node: Branching and merging,  Next: Recursive behavior,  Prev: Revisions,  Up: Top

Branching and merging
*********************

   CVS allows you to isolate changes onto a separate line of
development, known as a "branch".  When you change files on a branch,
those changes do not appear on the main trunk or other branches.

   Later you can move changes from one branch to another branch (or the
main trunk) by "merging".  Merging involves first running `cvs update
-j', to merge the changes into the working directory.  You can then
commit that revision, and thus effectively copy the changes onto
another branch.

* Menu:

* Branches motivation::         What branches are good for
* Creating a branch::           Creating a branch
* Accessing branches::          Checking out and updating branches
* Branches and revisions::      Branches are reflected in revision numbers
* Magic branch numbers::        Magic branch numbers
* Merging a branch::            Merging an entire branch
* Merging more than once::      Merging from a branch several times
* Merging two revisions::       Merging differences between two revisions
* Merging adds and removals::   What if files are added or removed?
* Merging and keywords::        Avoiding conflicts due to keyword substitution


File: cvs.info,  Node: Branches motivation,  Next: Creating a branch,  Up: Branching and merging

What branches are good for
==========================

   Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.
After a while your customers start to complain about a fatal bug.  You
check out release 1.0 (*note Tags::) and find the bug (which turns out
to have a trivial fix).  However, the current revision of the sources
are in a state of flux and are not expected to be stable for at least
another month.  There is no way to make a bugfix release based on the
newest sources.

   The thing to do in a situation like this is to create a "branch" on
the revision trees for all the files that make up release 1.0 of tc.
You can then make modifications to the branch without disturbing the
main trunk.  When the modifications are finished you can elect to
either incorporate them on the main trunk, or leave them on the branch.


File: cvs.info,  Node: Creating a branch,  Next: Accessing branches,  Prev: Branches motivation,  Up: Branching and merging

Creating a branch
=================

   You can create a branch with `tag -b'; for example, assuming you're
in a working copy:

     $ cvs tag -b rel-1-0-patches

   This splits off a branch based on the current revisions in the
working copy, assigning that branch the name `rel-1-0-patches'.

   It is important to understand that branches get created in the
repository, not in the working copy.  Creating a branch based on
current revisions, as the above example does, will _not_ automatically
switch the working copy to be on the new branch.  For information on how
to do that, see *Note Accessing branches::.

   You can also create a branch without reference to any working copy,
by using `rtag':

     $ cvs rtag -b -r rel-1-0 rel-1-0-patches tc

   `-r rel-1-0' says that this branch should be rooted at the revision
that corresponds to the tag `rel-1-0'.  It need not be the most recent
revision - it's often useful to split a branch off an old revision (for
example, when fixing a bug in a past release otherwise known to be
stable).

   As with `tag', the `-b' flag tells `rtag' to create a branch (rather
than just a symbolic revision name).  Note that the numeric revision
number that matches `rel-1-0' will probably be different from file to
file.

   So, the full effect of the command is to create a new branch - named
`rel-1-0-patches' - in module `tc', rooted in the revision tree at the
point tagged by `rel-1-0'.


File: cvs.info,  Node: Accessing branches,  Next: Branches and revisions,  Prev: Creating a branch,  Up: Branching and merging

Accessing branches
==================

   You can retrieve a branch in one of two ways: by checking it out
fresh from the repository, or by switching an existing working copy
over to the branch.

   To check out a branch from the repository, invoke `checkout' with
the `-r' flag, followed by the tag name of the branch (*note Creating a
branch::):

     $ cvs checkout -r rel-1-0-patches tc

   Or, if you already have a working copy, you can switch it to a given
branch with `update -r':

     $ cvs update -r rel-1-0-patches tc

   or equivalently:

     $ cd tc
     $ cvs update -r rel-1-0-patches

   It does not matter if the working copy was originally on the main
trunk or on some other branch - the above command will switch it to the
named branch.  And similarly to a regular `update' command, `update -r'
merges any changes you have made, notifying you of conflicts where they
occur.

   Once you have a working copy tied to a particular branch, it remains
there until you tell it otherwise.  This means that changes checked in
from the working copy will add new revisions on that branch, while
leaving the main trunk and other branches unaffected.

   To find out what branch a working copy is on, you can use the
`status' command.  In its output, look for the field named `Sticky tag'
(*note Sticky tags::) - that's CVS's way of telling you the branch, if
any, of the current working files:

     $ cvs status -v driver.c backend.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7     Sat Dec  5 18:25:54 1992
         RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             rel-1-0-patches             (branch: 1.7.2)
             rel-1-0                     (revision: 1.7)
     
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             rel-1-0-patches             (branch: 1.4.2)
             rel-1-0                     (revision: 1.4)
             rel-0-4                     (revision: 1.4)

   Don't be confused by the fact that the branch numbers for each file
are different (`1.7.2' and `1.4.2' respectively).  The branch tag is the
same, `rel-1-0-patches', and the files are indeed on the same branch.
The numbers simply reflect the point in each file's revision history at
which the branch was made.  In the above example, one can deduce that
`driver.c' had been through more changes than `backend.c' before this
branch was created.

   See *Note Branches and revisions:: for details about how branch
numbers are constructed.


File: cvs.info,  Node: Branches and revisions,  Next: Magic branch numbers,  Prev: Accessing branches,  Up: Branching and merging

Branches and revisions
======================

   Ordinarily, a file's revision history is a linear series of
increments (*note Revision numbers::):

            +-----+    +-----+    +-----+    +-----+    +-----+
            ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
            +-----+    +-----+    +-----+    +-----+    +-----+

   However, CVS is not limited to linear development.  The "revision
tree" can be split into "branches", where each branch is a
self-maintained line of development.  Changes made on one branch can
easily be moved back to the main trunk.

   Each branch has a "branch number", consisting of an odd number of
period-separated decimal integers.  The branch number is created by
appending an integer to the revision number where the corresponding
branch forked off.  Having branch numbers allows more than one branch
to be forked off from a certain revision.

   All revisions on a branch have revision numbers formed by appending
an ordinal number to the branch number.  The following figure
illustrates branching with an example.

                                                           +-------------+
                                Branch 1.2.2.3.2 ->        ! 1.2.2.3.2.1 !
                                                         / +-------------+
                                                        /
                                                       /
                      +---------+    +---------+    +---------+
     Branch 1.2.2 -> _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    / +---------+    +---------+    +---------+
                   /
                  /
     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+    +---------+
     Branch 1.2.4 -> +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                         +---------+    +---------+    +---------+

   The exact details of how the branch number is constructed is not
something you normally need to be concerned about, but here is how it
works: When CVS creates a branch number it picks the first unused even
integer, starting with 2.  So when you want to create a branch from
revision 6.4 it will be numbered 6.4.2.  All branch numbers ending in a
zero (such as 6.4.0) are used internally by CVS (*note Magic branch
numbers::).  The branch 1.1.1 has a special meaning.  *Note Tracking
sources::.


File: cvs.info,  Node: Magic branch numbers,  Next: Merging a branch,  Prev: Branches and revisions,  Up: Branching and merging

Magic branch numbers
====================

   This section describes a CVS feature called "magic branches".  For
most purposes, you need not worry about magic branches; CVS handles
them for you.  However, they are visible to you in certain
circumstances, so it may be useful to have some idea of how it works.

   Externally, branch numbers consist of an odd number of dot-separated
decimal integers.  *Note Revision numbers::.  That is not the whole
truth, however.  For efficiency reasons CVS sometimes inserts an extra 0
in the second rightmost position (1.2.4 becomes 1.2.0.4, 8.9.10.11.12
becomes 8.9.10.11.0.12 and so on).

   CVS does a pretty good job at hiding these so called magic branches,
but in a few places the hiding is incomplete:

   * The magic branch number appears in the output from `cvs log'.

   * You cannot specify a symbolic branch name to `cvs admin'.


   You can use the `admin' command to reassign a symbolic name to a
branch the way RCS expects it to be.  If `R4patches' is assigned to the
branch 1.4.2 (magic branch number 1.4.0.2) in file `numbers.c' you can
do this:

     $ cvs admin -NR4patches:1.4.2 numbers.c

   It only works if at least one revision is already committed on the
branch.  Be very careful so that you do not assign the tag to the wrong
number.  (There is no way to see how the tag was assigned yesterday).


File: cvs.info,  Node: Merging a branch,  Next: Merging more than once,  Prev: Magic branch numbers,  Up: Branching and merging

Merging an entire branch
========================

   You can merge changes made on a branch into your working copy by
giving the `-j BRANCHNAME' flag to the `update' subcommand.  With one
`-j BRANCHNAME' option it merges the changes made between the point
where the branch forked and newest revision on that branch (into your
working copy).

   The `-j' stands for "join".

   Consider this revision tree:

     +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

The branch 1.2.2 has been given the tag (symbolic name) `R1fix'.  The
following example assumes that the module `mod' contains only one file,
`m.c'.

     $ cvs checkout mod               # Retrieve the latest revision, 1.4
     
     $ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                      # i.e. the changes between revision 1.2
                                      # and 1.2.2.2, into your working copy
                                      # of the file.
     
     $ cvs commit -m "Included R1fix" # Create revision 1.5.

   A conflict can result from a merge operation.  If that happens, you
should resolve it before committing the new revision.  *Note Conflicts
example::.

   If your source files contain keywords (*note Keyword substitution::),
you might be getting more conflicts than strictly necessary.  See *Note
Merging and keywords::, for information on how to avoid this.

   The `checkout' command also supports the `-j BRANCHNAME' flag.  The
same effect as above could be achieved with this:

     $ cvs checkout -j R1fix mod
     $ cvs commit -m "Included R1fix"

   It should be noted that `update -j TAGNAME' will also work but may
not produce the desired result.  *Note Merging adds and removals::, for
more.


File: cvs.info,  Node: Merging more than once,  Next: Merging two revisions,  Prev: Merging a branch,  Up: Branching and merging

Merging from a branch several times
===================================

   Continuing our example, the revision tree now looks like this:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

   where the starred line represents the merge from the `R1fix' branch
to the main trunk, as just discussed.

   Now suppose that development continues on the `R1fix' branch:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                         +---------+    +---------+    +---------+

   and then you want to merge those new changes onto the main trunk.
If you just use the `cvs update -j R1fix m.c' command again, CVS will
attempt to merge again the changes which you have already merged, which
can have undesirable side effects.

   So instead you need to specify that you only want to merge the
changes on the branch which have not yet been merged into the trunk.
To do that you specify two `-j' options, and CVS merges the changes from
the first revision to the second revision.  For example, in this case
the simplest way would be

     cvs update -j 1.2.2.2 -j R1fix m.c    # Merge changes from 1.2.2.2 to the
                                           # head of the R1fix branch

   The problem with this is that you need to specify the 1.2.2.2
revision manually.  A slightly better approach might be to use the date
the last merge was done:

     cvs update -j R1fix:yesterday -j R1fix m.c

   Better yet, tag the R1fix branch after every merge into the trunk,
and then use that tag for subsequent merges:

     cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c


File: cvs.info,  Node: Merging two revisions,  Next: Merging adds and removals,  Prev: Merging more than once,  Up: Branching and merging

Merging differences between any two revisions
=============================================

   With two `-j REVISION' flags, the `update' (and `checkout') command
can merge the differences between any two revisions into your working
file.

     $ cvs update -j 1.5 -j 1.3 backend.c

will undo all changes made between revision 1.3 and 1.5.  Note the
order of the revisions!

   If you try to use this option when operating on multiple files,
remember that the numeric revisions will probably be very different
between the various files.  You almost always use symbolic tags rather
than revision numbers when operating on multiple files.

   Specifying two `-j' options can also undo file removals or
additions.  For example, suppose you have a file named `file1' which
existed as revision 1.1, and you then removed it (thus adding a dead
revision 1.2).  Now suppose you want to add it again, with the same
contents it had previously.  Here is how to do it:

     $ cvs update -j 1.2 -j 1.1 file1
     U file1
     $ cvs commit -m test
     Checking in file1;
     /tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
     new revision: 1.3; previous revision: 1.2
     done
     $


File: cvs.info,  Node: Merging adds and removals,  Next: Merging and keywords,  Prev: Merging two revisions,  Up: Branching and merging

Merging can add or remove files
===============================

   If the changes which you are merging involve removing or adding some
files, `update -j' will reflect such additions or removals.

   For example:
     cvs update -A
     touch a b c
     cvs add a b c ; cvs ci -m "added" a b c
     cvs tag -b branchtag
     cvs update -r branchtag
     touch d ; cvs add d
     rm a ; cvs rm a
     cvs ci -m "added d, removed a"
     cvs update -A
     cvs update -jbranchtag

   After these commands are executed and a `cvs commit' is done, file
`a' will be removed and file `d' added in the main branch.

   Note that using a single static tag (`-j TAGNAME') rather than a
dynamic tag (`-j BRANCHNAME') to merge changes from a branch will
usually not remove files which were removed on the branch since CVS
does not automatically add static tags to dead revisions.  The
exception to this rule occurs when a static tag has been attached to a
dead revision manually.  Use the branch tag to merge all changes from
the branch or use two static tags as merge endpoints to be sure that
all intended changes are propogated in the merge.


File: cvs.info,  Node: Merging and keywords,  Prev: Merging adds and removals,  Up: Branching and merging

Merging and keywords
====================

   If you merge files containing keywords (*note Keyword
substitution::), you will normally get numerous conflicts during the
merge, because the keywords are expanded differently in the revisions
which you are merging.

   Therefore, you will often want to specify the `-kk' (*note
Substitution modes::) switch to the merge command line.  By
substituting just the name of the keyword, not the expanded value of
that keyword, this option ensures that the revisions which you are
merging will be the same as each other, and avoid spurious conflicts.

   For example, suppose you have a file like this:

            +---------+
           _! 1.1.2.1 !   <-  br1
          / +---------+
         /
        /
     +-----+    +-----+
     ! 1.1 !----! 1.2 !
     +-----+    +-----+

   and your working directory is currently on the trunk (revision 1.2).
Then you might get the following results from a merge:

     $ cat file1
     key $Revision: 1.1.1.18 $
     . . .
     $ cvs update -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     rcsmerge: warning: conflicts during merge
     $ cat file1
     <<<<<<< file1
     key $Revision: 1.1.1.18 $
     =======
     key $Revision: 1.1.1.18 $
     >>>>>>> 1.1.2.1
     . . .

   What happened was that the merge tried to merge the differences
between 1.1 and 1.1.2.1 into your working directory.  So, since the
keyword changed from `Revision: 1.1' to `Revision: 1.1.2.1', CVS tried
to merge that change into your working directory, which conflicted with
the fact that your working directory had contained `Revision: 1.2'.

   Here is what happens if you had used `-kk':

     $ cat file1
     key $Revision: 1.1.1.18 $
     . . .
     $ cvs update -kk -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     $ cat file1
     key $Revision: 1.1.1.18 $
     . . .

   What is going on here is that revision 1.1 and 1.1.2.1 both expand
as plain `Revision', and therefore merging the changes between them
into the working directory need not change anything.  Therefore, there
is no conflict.

   There is, however, one major caveat with using `-kk' on merges.
Namely, it overrides whatever keyword expansion mode CVS would normally
have used.  In particular, this is a problem if the mode had been `-kb'
for a binary file.  Therefore, if your repository contains binary
files, you will need to deal with the conflicts rather than using `-kk'.


File: cvs.info,  Node: Recursive behavior,  Next: Adding and removing,  Prev: Branching and merging,  Up: Top

Recursive behavior
******************

   Almost all of the subcommands of CVS work recursively when you
specify a directory as an argument.  For instance, consider this
directory structure:

           `$HOME'
             |
             +--tc
             |   |
                 +--CVS
                 |      (internal CVS files)
                 +--Makefile
                 +--backend.c
                 +--driver.c
                 +--frontend.c
                 +--parser.c
                 +--man
                 |    |
                 |    +--CVS
                 |    |  (internal CVS files)
                 |    +--tc.1
                 |
                 +--testing
                      |
                      +--CVS
                      |  (internal CVS files)
                      +--testpgm.t
                      +--test2.t

If `tc' is the current working directory, the following is true:

   * `cvs update testing' is equivalent to

          cvs update testing/testpgm.t testing/test2.t

   * `cvs update testing man' updates all files in the subdirectories

   * `cvs update .' or just `cvs update' updates all files in the `tc'
     directory

   If no arguments are given to `update' it will update all files in
the current working directory and all its subdirectories.  In other
words, `.' is a default argument to `update'.  This is also true for
most of the CVS subcommands, not only the `update' command.

   The recursive behavior of the CVS subcommands can be turned off with
the `-l' option.  Conversely, the `-R' option can be used to force
recursion if `-l' is specified in `~/.cvsrc' (*note ~/.cvsrc::).

     $ cvs update -l         # Don't update files in subdirectories


File: cvs.info,  Node: Adding and removing,  Next: History browsing,  Prev: Recursive behavior,  Up: Top

Adding, removing, and renaming files and directories
****************************************************

   In the course of a project, one will often add new files.  Likewise
with removing or renaming, or with directories.  The general concept to
keep in mind in all these cases is that instead of making an
irreversible change you want CVS to record the fact that a change has
taken place, just as with modifying an existing file.  The exact
mechanisms to do this in CVS vary depending on the situation.

* Menu:

* Adding files::                Adding files
* Removing files::              Removing files
* Removing directories::        Removing directories
* Moving files::                Moving and renaming files
* Moving directories::          Moving and renaming directories


File: cvs.info,  Node: Adding files,  Next: Removing files,  Up: Adding and removing

Adding files to a directory
===========================

   To add a new file to a directory, follow these steps.

   * You must have a working copy of the directory.  *Note Getting the
     source::.

   * Create the new file inside your working copy of the directory.

   * Use `cvs add FILENAME' to tell CVS that you want to version
     control the file.  If the file contains binary data, specify `-kb'
     (*note Binary files::).

   * Use `cvs commit FILENAME' to actually check in the file into the
     repository.  Other developers cannot see the file until you
     perform this step.

   You can also use the `add' command to add a new directory.

   Unlike most other commands, the `add' command is not recursive.  You
cannot even type `cvs add foo/bar'!  Instead, you have to

     $ cd foo
     $ cvs add bar

 - Command: cvs add [`-k' kflag] [`-m' message] files ...
     Schedule FILES to be added to the repository.  The files or
     directories specified with `add' must already exist in the current
     directory.  To add a whole new directory hierarchy to the source
     repository (for example, files received from a third-party
     vendor), use the `import' command instead.  *Note import::.

     The added files are not placed in the source repository until you
     use `commit' to make the change permanent.  Doing an `add' on a
     file that was removed with the `remove' command will undo the
     effect of the `remove', unless a `commit' command intervened.
     *Note Removing files::, for an example.

     The `-k' option specifies the default way that this file will be
     checked out; for more information see *Note Substitution modes::.

     The `-m' option specifies a description for the file.  This
     description appears in the history log (if it is enabled, *note
     history file::).  It will also be saved in the version history
     inside the repository when the file is committed.  The `log'
     command displays this description.  The description can be changed
     using `admin -t'.  *Note admin::.  If you omit the `-m
     DESCRIPTION' flag, an empty string will be used.  You will not be
     prompted for a description.

   For example, the following commands add the file `backend.c' to the
repository:

     $ cvs add backend.c
     $ cvs commit -m "Early version. Not yet compilable." backend.c

   When you add a file it is added only on the branch which you are
working on (*note Branching and merging::).  You can later merge the
additions to another branch if you want (*note Merging adds and
removals::).


File: cvs.info,  Node: Removing files,  Next: Removing directories,  Prev: Adding files,  Up: Adding and removing

Removing files
==============

   Directories change.  New files are added, and old files disappear.
Still, you want to be able to retrieve an exact copy of old releases.

   Here is what you can do to remove a file, but remain able to
retrieve old revisions:

   * Make sure that you have not made any uncommitted modifications to
     the file.  *Note Viewing differences::, for one way to do that.
     You can also use the `status' or `update' command.  If you remove
     the file without committing your changes, you will of course not
     be able to retrieve the file as it was immediately before you
     deleted it.

   * Remove the file from your working copy of the directory.  You can
     for instance use `rm'.

   * Use `cvs remove FILENAME' to tell CVS that you really want to
     delete the file.

   * Use `cvs commit FILENAME' to actually perform the removal of the
     file from the repository.

   When you commit the removal of the file, CVS records the fact that
the file no longer exists.  It is possible for a file to exist on only
some branches and not on others, or to re-add another file with the same
name later.  CVS will correctly create or not create the file, based on
the `-r' and `-D' options specified to `checkout' or `update'.

 - Command: cvs remove [options] files ...
     Schedule file(s) to be removed from the repository (files which
     have not already been removed from the working directory are not
     processed).  This command does not actually remove the file from
     the repository until you commit the removal.  For a full list of
     options, see *Note Invoking CVS::.

   Here is an example of removing several files:

     $ cd test
     $ rm *.c
     $ cvs remove
     cvs remove: Removing .
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   As a convenience you can remove the file and `cvs remove' it in one
step, by specifying the `-f' option.  For example, the above example
could also be done like this:

     $ cd test
     $ cvs remove -f *.c
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   If you execute `remove' for a file, and then change your mind before
you commit, you can undo the `remove' with an `add' command.

     $ ls
     CVS   ja.h  oj.c
     $ rm oj.c
     $ cvs remove oj.c
     cvs remove: scheduling oj.c for removal
     cvs remove: use 'cvs commit' to remove this file permanently
     $ cvs add oj.c
     U oj.c
     cvs add: oj.c, version 1.1.1.1, resurrected

   If you realize your mistake before you run the `remove' command you
can use `update' to resurrect the file:

     $ rm oj.c
     $ cvs update oj.c
     cvs update: warning: oj.c was lost
     U oj.c

   When you remove a file it is removed only on the branch which you
are working on (*note Branching and merging::).  You can later merge
the removals to another branch if you want (*note Merging adds and
removals::).


File: cvs.info,  Node: Removing directories,  Next: Moving files,  Prev: Removing files,  Up: Adding and removing

Removing directories
====================

   In concept removing directories is somewhat similar to removing
files--you want the directory to not exist in your current working
directories, but you also want to be able to retrieve old releases in
which the directory existed.

   The way that you remove a directory is to remove all the files in
it.  You don't remove the directory itself; there is no way to do that.
Instead you specify the `-P' option to `cvs update' or `cvs checkout',
which will cause CVS to remove empty directories from working
directories.  (Note that `cvs export' always removes empty directories.)
Probably the best way to do this is to always specify `-P'; if you want
an empty directory then put a dummy file (for example `.keepme') in it
to prevent `-P' from removing it.

   Note that `-P' is implied by the `-r' or `-D' options of `checkout'.
This way CVS will be able to correctly create the directory or not
depending on whether the particular version you are checking out
contains any files in that directory.


File: cvs.info,  Node: Moving files,  Next: Moving directories,  Prev: Removing directories,  Up: Adding and removing

Moving and renaming files
=========================

   Moving files to a different directory or renaming them is not
difficult, but some of the ways in which this works may be non-obvious.
(Moving or renaming a directory is even harder.  *Note Moving
directories::.).

   The examples below assume that the file OLD is renamed to NEW.

* Menu:

* Outside::                     The normal way to Rename
* Inside::                      A tricky, alternative way
* Rename by copying::           Another tricky, alternative way


File: cvs.info,  Node: Outside,  Next: Inside,  Up: Moving files

The Normal way to Rename
------------------------

   The normal way to move a file is to copy OLD to NEW, and then issue
the normal CVS commands to remove OLD from the repository, and add NEW
to it.

     $ mv OLD NEW
     $ cvs remove OLD
     $ cvs add NEW
     $ cvs commit -m "Renamed OLD to NEW" OLD NEW

   This is the simplest way to move a file, it is not error-prone, and
it preserves the history of what was done.  Note that to access the
history of the file you must specify the old or the new name, depending
on what portion of the history you are accessing.  For example, `cvs
log OLD' will give the log up until the time of the rename.

   When NEW is committed its revision numbers will start again, usually
at 1.1, so if that bothers you, use the `-r rev' option to commit.  For
more information see *Note Assigning revisions::.


File: cvs.info,  Node: Inside,  Next: Rename by copying,  Prev: Outside,  Up: Moving files

Moving the history file
-----------------------

   This method is more dangerous, since it involves moving files inside
the repository.  Read this entire section before trying it out!

     $ cd $CVSROOT/DIR
     $ mv OLD,v NEW,v

Advantages:

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * Old releases cannot easily be fetched from the repository.  (The
     file will show up as NEW even in revisions from the time before it
     was renamed).

   * There is no log information of when the file was renamed.

   * Nasty things might happen if someone accesses the history file
     while you are moving it.  Make sure no one else runs any of the CVS
     commands while you move it.


File: cvs.info,  Node: Rename by copying,  Prev: Inside,  Up: Moving files

Copying the history file
------------------------

   This way also involves direct modifications to the repository.  It
is safe, but not without drawbacks.

     # Copy the RCS file inside the repository
     $ cd $CVSROOT/DIR
     $ cp OLD,v NEW,v
     # Remove the old file
     $ cd ~/DIR
     $ rm OLD
     $ cvs remove OLD
     $ cvs commit OLD
     # Remove all tags from NEW
     $ cvs update NEW
     $ cvs log NEW             # Remember the non-branch tag names
     $ cvs tag -d TAG1 NEW
     $ cvs tag -d TAG2 NEW
     ...

   By removing the tags you will be able to check out old revisions.

Advantages:

   * Checking out old revisions works correctly, as long as you use
     `-rTAG' and not `-DDATE' to retrieve the revisions.

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * You cannot easily see the history of the file across the rename.


@


1.2
log
@Merge remaining local changes, correct build issues
@
text
@d835 1
a835 1
     key $Revision: 1.2 $
d846 1
a846 1
     key $Revision: 1.2 $
d848 1
a848 1
     key $Revision: 1.1.2.1 $
d861 1
a861 1
     key $Revision: 1.2 $
d870 1
a870 1
     key $Revision$
@


1.1
log
@Initial revision
@
text
@d1 5
a5 2
This is Info file cvs.info, produced by Makeinfo-1.55 from the input
file ./cvs.texinfo.
d16 2
a17 4
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.
d21 2
a22 47
versions, except that the section entitled "GNU General Public License"
and this permission notice may be included in translations approved by
the Free Software Foundation instead of in the original English.


File: cvs.info,  Node: add options,  Next: add examples,  Up: add

add options
-----------

   There are only two options you can give to `add':

`-k KFLAG'
     This option specifies the default way that this file will be
     checked out.  See rcs(1) and co(1).  The KFLAG argument (*note
     Substitution modes::.) is stored in the RCS file and can be
     changed with `admin -k' (*note admin options::.).  Specifying
     `-ko' is useful for checking in binaries that should not have the
     RCS id strings expanded.

     *Warning:* this option is reported to be broken in version 1.3 and
     1.3-s2 of CVS.  Use `admin -k' after the commit instead.  *Note
     admin examples::.

`-m DESCRIPTION'
     Using this option, you can give a description for the file.  This
     description appears in the history log (if it is enabled, *note
     history file::.).  It will also be saved in the RCS history file
     inside the repository when the file is committed.  The `log'
     command displays this description.

     The description can be changed using `admin -t'.  *Note admin::.

     If you omit the `-m DESCRIPTION' flag, an empty string will be
     used.  You will not be prompted for a description.


File: cvs.info,  Node: add examples,  Prev: add options,  Up: add

add examples
------------

   To add the file `backend.c' to the repository, with a description,
the following can be used.

     $ cvs add -m "Optimizer and code generation passes." backend.c
     $ cvs commit -m "Early version. Not yet compilable." backend.c
d25 1
a25 1
File: cvs.info,  Node: admin,  Next: checkout,  Prev: add,  Up: Invoking CVS
d27 2
a28 2
admin--Administration front end for rcs
=======================================
d30 161
a190 1
   * Requires: repository, working directory.
d192 2
a193 301
   * Changes: repository.

   * Synonym: rcs

   This is the CVS interface to assorted administrative RCS facilities,
documented in rcs(1).  `admin' simply passes all its options and
arguments to the `rcs' command; it does no filtering or other
processing.  This command *does* work recursively, however, so extreme
care should be used.

* Menu:

* admin options::               admin options
* admin examples::              admin examples


File: cvs.info,  Node: admin options,  Next: admin examples,  Up: admin

admin options
-------------

   Not all valid `rcs' options are useful together with CVS.  Some even
makes it impossible to use CVS until you undo the effect!

   This description of the available options is based on the `rcs(1)'
man page, but modified to suit readers that are more interrested in CVS
than RCS.

`-AOLDFILE'
     Might not work together with CVS.  Append the access list of
     OLDFILE to the access list of the RCS file.

`-aLOGINS'
     Might not work together with CVS.  Append the login names
     appearing in the comma-separated list LOGINS to the access list of
     the RCS file.

`-b[REV]'
     Breaks CVS.  When used with bare RCS, this option sets the default
     branch to REV.  If REV is omitted, the default branch is reset to
     the (dynamically) highest branch on the trunk.  Use sticky tags
     instead, as in `cvs co -r'.  *Note Sticky tags::.

`-cSTRING'
     Useful with CVS.  Sets the comment leader to STRING.  The comment
     leader is printed before every log message line generated by the
     keyword `$Log$' (*note Keyword substitution::.).  This is useful
     for programming languages without multi-line comments.  RCS
     initially guesses the value of the comment leader from the file
     name extension when the file is first committed.

`-e[LOGINS]'
     Might not work together with CVS.  Erase the login names appearing
     in the comma-separated list LOGINS from the access list of the RCS
     file.  If LOGINS is omitted, erase the entire access list.

`-I'
     Run interactively, even if the standard input is not a terminal.

`-i'
     Useless with CVS.  When using bare RCS, this is used to create and
     initialize a new RCS file, without depositing a revision.

`-kSUBST'
     Useful with CVS.  Set the default keyword substitution to SUBST.
     *Note Keyword substitution::.  Giving an explicit `-k' option to
     `cvs update' or `cvs checkout' overrides this default.  `cvs
     export' always uses `-kv', regardless of which keyword
     substitution is set with `cvs admin'.

`-l[REV]'
     Probably useless with CVS.  With bare RCS, this option can be used
     to lock the revision with number REV.  If a branch is given, lock
     the latest revision on that branch.  If REV is omitted, lock the
     latest revision on the default branch.

`-L'
     Probably useless with CVS.  Used with bare RCS to set locking to
     strict.  Strict locking means that the owner of an RCS file is not
     exempt from locking for checkin.

`-mREV:MSG'
     Replace the log message of revision REV with MSG.

`-NNAME[:[REV]]'
     Act like `-n', except override any previous assignment of NAME.

`-nNAME[:[REV]]'
     Associate the symbolic name NAME with the branch or revision REV.
     It is normally better to use `cvs tag' or `cvs rtag' instead.
     Delete the symbolic name if both `:' and REV are omitted;
     otherwise, print an error message if NAME is already associated
     with another number.  If REV is symbolic, it is expanded before
     association.  A REV consisting of a branch number followed by a
     `.' stands for the current latest revision in the branch.  A `:'
     with an empty REV stands for the current latest revision on the
     default branch, normally the trunk.  For example, `rcs -nNAME:
     RCS/*' associates NAME with the current latest revision of all the
     named RCS files; this contrasts with `rcs -nNAME:$ RCS/*' which
     associates NAME with the revision numbers extracted from keyword
     strings in the corresponding working files.

`-oRANGE'
     Useful, but dangerous, with CVS (see below).  Deletes ("outdates")
     the revisions given by RANGE.  A range consisting of a single
     revision number means that revision.  A range consisting of a
     branch number means the latest revision on that branch.  A range
     of the form `REV1:REV2' means revisions REV1 to REV2 on the same
     branch, `:REV' means from the beginning of the branch containing
     REV up to and including REV, and `REV:' means from revision REV to
     the end of the branch containing REV.  None of the outdated
     revisions may have branches or locks.

     Due to the way CVS handles branches REV cannot be specified
     symbolically if it is a branch.  *Note Magic branch numbers::, for
     an explanation.

     Make sure that no-one has checked out a copy of the revision you
     outdate.  Strange things will happen if he starts to edit it and
     tries to check it back in.  For this reason, you should never use
     this option to take back a bogus commit unless you work alone.
     Instead, you should fix the file and commit a new revision.

`-q'
     Run quietly; do not print diagnostics.

`-sSTATE[:REV]'
     Useful with CVS.  Set the state attribute of the revision REV to
     STATE.  If REV is a branch number, assume the latest revision on
     that branch.  If REV is omitted, assume the latest revision on the
     default branch.  Any identifier is acceptable for STATE.  A useful
     set of states is `Exp' (for experimental), `Stab' (for stable),
     and `Rel' (for released).  By default, the state of a new revision
     is set to `Exp' when it is created.  The state is visible in the
     output from CVS LOG (*note log::.), and in the `$Log$' and
     `$State$' keywords (*note Keyword substitution::.).

`-t[FILE]'
     Useful with CVS.  Write descriptive text from the contents of the
     named FILE into the RCS file, deleting the existing text.  The
     FILE pathname may not begin with `-'.  If FILE is omitted, obtain
     the text from standard input, terminated by end-of-file or by a
     line containing `.' by itself.  Prompt for the text if interaction
     is possible; see `-I'.  The descriptive text can be seen in the
     output from `cvs log' (*note log::.).

`-t-STRING'
     Similar to `-tFILE'. Write descriptive text from the STRING into
     the RCS file, deleting the existing text.

`-U'
     Probably useless with CVS.  Used with bare RCS to set locking to
     non-strict.  Non-strict locking means that the owner of a file
     need not lock a revision for checkin.

`-u[REV]'
     Probably useless with CVS.  With bare RCS, unlock the revision
     with number REV.  If a branch is given, unlock the latest revision
     on that branch.  If REV is omitted, remove the latest lock held by
     the caller.  Normally, only the locker of a revision may unlock
     it.  Somebody else unlocking a revision breaks the lock.  This
     causes a mail message to be sent to the original locker.  The
     message contains a commentary solicited from the breaker.  The
     commentary is terminated by end-of-file or by a line containing
     `.' by itself.

`-VN'
     Emulate RCS version N. Use -VN to make an RCS file acceptable to
     RCS version N by discarding information that would confuse version
     N.

`-xSUFFIXES'
     Useless with CVS. Use SUFFIXES to characterize RCS files.


File: cvs.info,  Node: admin examples,  Prev: admin options,  Up: admin

admin examples
--------------

Outdating is dangerous
......................

   First, an example of how *not* to use the `admin' command.  It is
included to stress the fact that this command can be quite dangerous
unless you know *exactly* what you are doing.

   The `-o' option can be used to "outdate" old revisions from the
history file.  If you are short on disc this option might help you.
But think twice before using it--there is no way short of restoring the
latest backup to undo this command!

   The next line is an example of a command that you would *not* like
to execute.

     $ cvs admin -o:R_1_02 .

   The above command will delete all revisions up to, and including,
the revision that corresponds to the tag R_1_02.  But beware!  If there
are files that have not changed between R_1_02 and R_1_03 the file will
have *the same* numerical revision number assigned to the tags R_1_02
and R_1_03.  So not only will it be impossible to retrieve R_1_02;
R_1_03 will also have to be restored from the tapes!

Handling binary files
.....................

   If you use CVS to store binary files, where keyword strings (*note
Keyword substitution::.) might accidentally appear inside the file, you
should use `cvs admin -ko' to make sure that they are not modified
automatically.  Here is an example of how you can create a new file
using the `-ko' flag:

     $ echo '$Id$' > kotest
     $ cvs add -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest
     $ cvs admin -ko kotest
     $ rm kotest
     $ cvs update kotest

   When you check in the file `kotest' the keywords are expanded.  (Try
the above example, and do a `cat kotest' after every command!)  The `cvs
admin -ko' command sets the default keyword substitution method for
this file, but it does not alter the working copy of the file that you
have.  The easiest way to get the unexpanded version of `kotest' is to
remove it and check it out again.

Comment leaders
...............

   If you use the `$Log$' keyword and you do not agree with the guess
for comment leader that CVS has done, you can enforce your will with
`cvs admin -c'.  This might be suitable for `nroff' source:

     $ cvs admin -c'.\" ' *.man
     $ rm *.man
     $ cvs update

   The two last steps are to make sure that you get the versions with
correct comment leaders in your working files.


File: cvs.info,  Node: checkout,  Next: commit,  Prev: admin,  Up: Invoking CVS

checkout--Check out sources for editing
=======================================

   * Synopsis: checkout [options] modules...

   * Requires: repository.

   * Changes: working directory.

   * Synonyms: co, get

   Make a working directory containing copies of the source files
specified by MODULES.  You must execute `checkout' before using most of
the other CVS commands, since most of them operate on your working
directory.

   The MODULES part of the command are either symbolic names for some
collection of source directories and files, or paths to directories or
files in the repository.  The symbolic names are defined in the
`modules' file.  *Note modules::.

   Depending on the modules you specify, `checkout' may recursively
create directories and populate them with the appropriate source files.
You can then edit these source files at any time (regardless of
whether other software developers are editing their own copies of the
sources); update them to include new changes applied by others to the
source repository; or commit your work as a permanent change to the
source repository.

   Note that `checkout' is used to create directories.  The top-level
directory created is always added to the directory where `checkout' is
invoked, and usually has the same name as the specified module.  In the
case of a module alias, the created sub-directory may have a different
name, but you can be sure that it will be a sub-directory, and that
`checkout' will show the relative path leading to each file as it is
extracted into your private work area (unless you specify the `-Q'
global option).

   Running `checkout' on a directory that was already built by a prior
`checkout' is also permitted, and has the same effect as specifying the
`-d' option to the `update' command, that is, any new directories that
have been created in the repository will appear in your work area.
*Note update::.

* Menu:

* checkout options::            checkout options
* checkout examples::           checkout examples


File: cvs.info,  Node: checkout options,  Next: checkout examples,  Up: checkout

checkout options
----------------

   These standard options are supported by `checkout' (*note Common
options::., for a complete description of them):
d196 1
a196 2
     Use the most recent revision no later than DATE.  This option is
     sticky, and implies `-P'.
d200 1
a200 1
     revision is found, retrieve the most recent revision (instead of
a202 19
`-k KFLAG'
     Process RCS keywords according to KFLAG.  See co(1).  This option
     is sticky; future updates of this file in this working directory
     will use the same KFLAG.  The `status' command can be viewed to
     see the sticky options.  *Note status::.

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any checkout program (as specified with the `-o' option
     in the modules file; *note modules::.).

`-P'
     Prune empty directories.

`-p'
     Pipe files to the standard output.

d204 1
a204 63
     Use revision TAG.  This option is sticky, and implies `-P'.

   In addition to those, you can use these special command options with
`checkout':

`-A'
     Reset any sticky tags, dates, or `-k' options.  (If you get a
     working file using one of the `-r', `-D', or `-k' options, CVS
     remembers the corresponding tag, date, or KFLAG and continues using
     it for future updates; use the `-A' option to make CVS forget
     these specifications, and retrieve the `head' revision of the
     file).

`-c'
     Copy the module file, sorted, to the standard output, instead of
     creating or modifying any files or directories in your working
     directory.

`-d DIR'
     Create a directory called DIR for the working files, instead of
     using the module name.  Unless you also use `-N', the paths
     created under DIR will be as short as possible.

`-j TAG'
     Merge the changes made between the resulting revision and the
     revision that it is based on (e.g., if TAG refers to a branch, CVS
     will merge all changes made on that branch into your working file).

     With two `-j TAG' options, CVS will merge in the changes between
     the two respective revisions.  This can be used to undo changes
     made between two revisions (*note Merging two revisions::.) in
     your working copy, or to move changes between different branches.

     In addition, each -j option can contain an optional date
     specification which, when used with branches, can limit the chosen
     revision to one within a specific date.  An optional date is
     specified by adding a colon (:) to the tag.  An example might be
     what `import' tells you to do when you have just imported sources
     that have conflicts with local changes:

          $ cvs checkout -jTAG:yesterday -jTAG module

`-N'
     Only useful together with `-d DIR'.  With this option, CVS will
     not shorten module paths in your working directory.  (Normally,
     CVS shortens paths as much as possible when you specify an
     explicit target directory).

`-s'
     Like `-c', but include the status of all modules, and sort it by
     the status string.  *Note modules::, for info about the `-s'
     option that is used inside the modules file to set the module
     status.


File: cvs.info,  Node: checkout examples,  Prev: checkout options,  Up: checkout

checkout examples
-----------------

   Get a copy of the module `tc':

     $ cvs checkout tc
d206 169
a374 51
   Get a copy of the module `tc' as it looked one day ago:

     $ cvs checkout -D yesterday tc


File: cvs.info,  Node: commit,  Next: diff,  Prev: checkout,  Up: Invoking CVS

commit--Check files into the repository
=======================================

   * Version 1.3 Synopsis: commit [-lnR] [-m 'log_message' | -f file]
     [-r revision] [files...]

   * Version 1.3.1 Synopsis: commit [-lnRf] [-m 'log_message' | -F
     file] [-r revision] [files...]

   * Requires: working directory, repository.

   * Changes: repository.

   * Synonym: ci

   *Warning:* The `-f FILE' option will probably be renamed to `-F
FILE', and `-f' will be given a new behavior in future releases of CVS.

   Use `commit' when you want to incorporate changes from your working
source files into the source repository.

   If you don't specify particular files to commit, all of the files in
your working current directory are examined.  `commit' is careful to
change in the repository only those files that you have really changed.
By default (or if you explicitly specify the `-R' option), files in
subdirectories are also examined and committed if they have changed;
you can use the `-l' option to limit `commit' to the current directory
only.

   `commit' verifies that the selected files are up to date with the
current revisions in the source repository; it will notify you, and
exit without committing, if any of the specified files must be made
current first with `update' (*note update::.).  `commit' does not call
the `update' command for you, but rather leaves that for you to do when
the time is right.

   When all is well, an editor is invoked to allow you to enter a log
message that will be written to one or more logging programs (*note
modules::., and *note loginfo::.) and placed in the RCS history file
inside the repository.  This log message can be retrieved with the
`log' command; *Note log::.  You can specify the log message on the
command line with the `-m MESSAGE' option, and thus avoid the editor
invocation, or use the `-f FILE' option to specify that the argument
file contains the log message.
d378 574
a951 164
* commit options::              commit options
* commit examples::             commit examples


File: cvs.info,  Node: commit options,  Next: commit examples,  Up: commit

commit options
--------------

   These standard options are supported by `commit' (*note Common
options::., for a complete description of them):

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any module program.

`-R'
     Commit directories recursively.  This is on by default.

`-r REVISION'
     Commit to REVISION.  REVISION must be either a branch, or a
     revision on the main trunk that is higher than any existing
     revision number.  You cannot commit to a specific revision on a
     branch.

   `commit' also supports these options:

`-F FILE'
     This option is present in CVS releases 1.3-s3 and later.  Read the
     log message from FILE, instead of invoking an editor.

`-f'
     This option is present in CVS 1.3-s3 and later releases of CVS.
     Note that this is not the standard behavior of the `-f' option as
     defined in *Note Common options::.

     Force CVS to commit a new revision even if you haven't made any
     changes to the file.  If the current revision of FILE is 1.7, then
     the following two commands are equivalent:

          $ cvs commit -f FILE
          $ cvs commit -r 1.8 FILE

`-f FILE'
     This option is present in CVS releases 1.3, 1.3-s1 and 1.3-s2.
     Note that this is not the standard behavior of the `-f' option as
     defined in *Note Common options::.

     Read the log message from FILE, instead of invoking an editor.

`-m MESSAGE'
     Use MESSAGE as the log message, instead of invoking an editor.


File: cvs.info,  Node: commit examples,  Prev: commit options,  Up: commit

commit examples
---------------

New major release number
........................

   When you make a major release of your product, you might want the
revision numbers to track your major release number.  You should
normally not care about the revision numbers, but this is a thing that
many people want to do, and it can be done without doing any harm.

   To bring all your files up to the RCS revision 3.0 (including those
that haven't changed), you might do:

     $ cvs commit -r 3.0

   Note that it is generally a bad idea to try to make the RCS revision
number equal to the current release number of your product.  You should
think of the revision number as an internal number that the CVS package
maintains, and that you generally never need to care much about.  Using
the `tag' and `rtag' commands you can give symbolic names to the
releases instead.  *Note tag:: and *Note rtag::.

   Note that the number you specify with `-r' must be larger than any
existing revision number.  That is, if revision 3.0 exists, you cannot
`cvs commit -r 1.3'.

Committing to a branch
......................

   You can commit to a branch revision (one that has an even number of
dots) with the `-r' option.  To create a branch revision, use the `-b'
option of the `rtag' or `tag' commands (*note tag::.  or *note
rtag::.).  Then, either `checkout' or `update' can be used to base your
sources on the newly created branch.  From that point on, all `commit'
changes made within these working sources will be automatically added
to a branch revision, thereby not disturbing main-line development in
any way.  For example, if you had to create a patch to the 1.2 version
of the product, even though the 2.0 version is already under
development, you might do:

     $ cvs rtag -b -r FCS1_2 FCS1_2_Patch product_module
     $ cvs checkout -r FCS1_2_Patch product_module
     $ cd product_module
     [[ hack away ]]
     $ cvs commit

This works automatically since the `-r' option is sticky.

Creating the branch after editing
.................................

   Say you have been working on some extremely experimental software,
based on whatever revision you happened to checkout last week.  If
others in your group would like to work on this software with you, but
without disturbing main-line development, you could commit your change
to a new branch.  Others can then checkout your experimental stuff and
utilize the full benefit of CVS conflict resolution.  The scenario might
look like:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs update -r EXPR1
     $ cvs commit

   The `update' command will make the `-r EXPR1' option sticky on all
files.  Note that your changes to the files will never be removed by the
`update' command.  The `commit' will automatically commit to the
correct branch, because the `-r' is sticky.  You could also do like
this:

     [[ hacked sources are present ]]
     $ cvs tag -b EXPR1
     $ cvs commit -r EXPR1

but then, only those files that were changed by you will have the `-r
EXPR1' sticky flag.  If you hack away, and commit without specifying
the `-r EXPR1' flag, some files may accidentally end up on the main
trunk.

   To work with you on the experimental change, others would simply do

     $ cvs checkout -r EXPR1 whatever_module


File: cvs.info,  Node: diff,  Next: export,  Prev: commit,  Up: Invoking CVS

diff--Run diffs between revisions
=================================

   * Synopsis: diff [-l] [rcsdiff_options] [[-r rev1 | -D date1] [-r
     rev2 |  -D date2]] [files...]

   * Requires: working directory, repository.

   * Changes: nothing.

   The `diff' command is used to compare different revisions of files.
The default action is to compare your working files with the revisions
they were based on, and report any differences that are found.

   If any file names are given, only those files are compared.  If any
directories are given, all files under them will be compared.

   The exit status will be 0 if no differences were found, 1 if some
differences were found, and 2 if any error occurred.
d955 5
a959 2
* diff options::                diff options
* diff examples::               diff examples
d962 1
a962 1
File: cvs.info,  Node: diff options,  Next: diff examples,  Up: diff
d964 2
a965 2
diff options
------------
d967 1
a967 2
   These standard options are supported by `diff' (*note Common
options::., for a complete description of them):
d969 2
a970 3
`-D DATE'
     Use the most recent revision no later than DATE.  See `-r' for how
     this affects the comparison.
d972 1
a972 6
     CVS can be configured to pass the `-D' option through to `rcsdiff'
     (which in turn passes it on to `diff'.  GNU diff uses `-D' as a
     way to put `cpp'-style `#define' statements around the output
     differences.  There is no way short of testing to figure out how
     CVS was configured.  In the default configuration CVS will use the
     `-D DATE' option.
d974 3
a976 2
`-k KFLAG'
     Process RCS keywords according to KFLAG.  See co(1).
d978 3
a980 2
`-l'
     Local; run only in current working directory.
d982 1
a982 2
`-R'
     Examine directories recursively.  This option is on by default.
d984 2
a985 7
`-r TAG'
     Compare with revision TAG.  Zero, one or two `-r' options can be
     present.  With no `-r' option, the working file will be compared
     with the revision it was based on.  With one `-r', that revision
     will be compared to your current working file.  With two `-r'
     options those two revisions will be compared (and your working
     file will not affect the outcome in any way).
d987 2
a988 2
     One or both `-r' options can be replaced by a `-D DATE' option,
     described above.
d990 6
a995 5
   Any other options that are found are passed through to `rcsdiff',
which in turn passes them to `diff'.  The exact meaning of the options
depends on which `diff' you are using.  The long options introduced in
GNU diff 2.0 are not yet supported in CVS.  See the documentation for
your `diff' to see which options are supported.
d997 5
a1001 2

File: cvs.info,  Node: diff examples,  Prev: diff options,  Up: diff
d1003 2
a1004 2
diff examples
-------------
d1006 8
a1013 4
   The following line produces a Unidiff (`-u' flag) between revision
1.14 and 1.19 of `backend.c'.  Due to the `-kk' flag no keywords are
substituted, so differences that only depend on keyword substitution
are ignored.
d1015 2
a1016 1
     $ cvs diff -kk -u -r 1.14 -r 1.19 backend.c
d1018 2
a1019 54
   Suppose the experimental branch EXPR1 was based on a set of files
tagged RELEASE_1_0.  To see what has happened on that branch, the
following can be used:

     $ cvs diff -r RELEASE_1_0 -r EXPR1

   A command like this can be used to produce a context diff between
two releases:

     $ cvs diff -c -r RELEASE_1_0 -r RELEASE_1_1 > diffs

   If you are maintaining ChangeLogs, a command like the following just
before you commit your changes may help you write the ChangeLog entry.
All local modifications that have not yet been committed will be
printed.

     $ cvs diff -u | less


File: cvs.info,  Node: export,  Next: history,  Prev: diff,  Up: Invoking CVS

export--Export sources from CVS, similar to checkout
====================================================

   * Synopsis: export [-flNnQq] -r rev|-D date [-d dir] module...

   * Requires: repository.

   * Changes: current directory.

   This command is a variant of `checkout'; use it when you want a copy
of the source for module without the CVS administrative directories.
For example, you might use `export' to prepare source for shipment
off-site.  This command requires that you specify a date or tag (with
`-D' or `-r'), so that you can count on reproducing the source you ship
to others.

   The keyword substitution option `-kv' is always set when export is
used.  This causes any RCS keywords to be expanded such that an import
done at some other site will not lose the keyword revision information.
There is no way to override this.  Note that this breaks the `ident'
command (which is part of the RCS suite--see ident(1)) which looks for
RCS keyword strings.  If you want to be able to use `ident' you must
use `checkout' instead.

* Menu:

* export options::              export options


File: cvs.info,  Node: export options,  Up: export

export options
--------------
d1021 133
a1153 2
   These standard options are supported by `export' (*note Common
options::., for a complete description of them):
d1155 1
a1155 319
`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).

`-l'
     Local; run only in current working directory.

`-n'
     Do not run any checkout program.

`-R'
     Export directories recursively.  This is on by default.

`-r TAG'
     Use revision TAG.

   In addition, these options (that are common to `checkout' and
`export') are also supported:

`-d DIR'
     Create a directory called DIR for the working files, instead of
     using the module name.  Unless you also use `-N', the paths
     created under DIR will be as short as possible.

`-N'
     Only useful together with `-d DIR'.  With this option, CVS will
     not shorten module paths in your working directory.  (Normally,
     CVS shortens paths as much as possible when you specify an
     explicit target directory.)


File: cvs.info,  Node: history,  Next: import,  Prev: export,  Up: Invoking CVS

history--Show status of files and users
=======================================

   * Synopsis:     history [-report] [-flags] [-options args] [files...]

   * Requires: the file `$CVSROOT/CVSROOT/history'

   * Changes: nothing.

   CVS can keep a history file that tracks each use of the `checkout',
`commit', `rtag', `update', and `release' commands.  You can use
`history' to display this information in various formats.

   Logging must be enabled by creating the file
`$CVSROOT/CVSROOT/history'.

   *Warning:* `history' uses `-f', `-l', `-n', and `-p' in ways that
conflict with the normal use inside CVS (*note Common options::.).

* Menu:

* history options::             history options


File: cvs.info,  Node: history options,  Up: history

history options
---------------

   Several options (shown above as `-report')  control  what kind of
report is generated:

`-c'
     Report on each time commit was used (i.e., each time the
     repository was modified).

`-e'
     Everything (all record types); equivalent to specifying
     `-xMACFROGWUT'.

`-m MODULE'
     Report on a particular module.  (You can meaningfully use `-m'
     more than once on the command line.)

`-o'
     Report on checked-out modules.

`-T'
     Report on all tags.

`-x TYPE'
     Extract a particular set of record types TYPE from the CVS
     history.  The types are indicated by single letters, which you may
     specify in combination.

     Certain commands have a single record type:

    `F'
          release

    `O'
          checkout

    `T'
          rtag

     One of four record types may result from an update:

    `C'
          A merge was necessary but collisions were detected (requiring
          manual merging).

    `G'
          A merge was necessary and it succeeded.

    `U'
          A working file was copied from the repository.

    `W'
          The working copy of a file was deleted during update (because
          it was gone from the repository).

     One of three record types results from commit:

    `A'
          A file was added for the first time.

    `M'
          A file was modified.

    `R'
          A file was removed.

   The options shown as `-flags' constrain or expand the report without
requiring option arguments:

`-a'
     Show data for all users (the default is to show data only for the
     user executing `history').

`-l'
     Show last modification only.

`-w'
     Show only the records for modifications done from the same working
     directory where `history' is executing.

   The options shown as `-options ARGS' constrain the report based on
an argument:

`-b STR'
     Show data back to a record containing  the  string STR  in  either
     the module name, the file name, or the repository path.

`-D DATE'
     Show data since DATE.  This is slightly different from the normal
     use of `-D DATE', which selects the newest revision older than
     DATE.

`-p REPOSITORY'
     Show data for a particular source repository  (you can specify
     several `-p' options on the same command line).

`-r REV'
     Show records referring to revisions since the revision or tag
     named REV appears in individual RCS files.  Each RCS file is
     searched for the revision or tag.

`-t TAG'
     Show records since tag TAG was last added to the the history file.
     This differs from the `-r' flag above in that it reads only the
     history file, not the RCS files, and is much faster.

`-u NAME'
     Show records for user NAME.


File: cvs.info,  Node: import,  Next: log,  Prev: history,  Up: Invoking CVS

import--Import sources into CVS, using vendor branches
======================================================

   * Synopsis: import [-options] repository vendortag releasetag...

   * Requires: Repository, source distribution directory.

   * Changes: repository.

   Use `import' to incorporate an entire source distribution from an
outside source (e.g., a source vendor) into your source repository
directory.  You can use this command both for initial creation of a
repository, and for wholesale updates to the module from the outside
source.  *Note Tracking sources::, for a discussion on this subject.

   The REPOSITORY argument gives a directory name (or a path to a
directory) under the CVS root directory for repositories; if the
directory did not exist, import creates it.

   When you use import for updates to source that has been modified in
your source repository (since a prior import), it will notify you of
any files that conflict in the two branches of development; use
`checkout -j' to reconcile the differences, as import instructs you to
do.

   By default, certain file names are ignored during `import': names
associated with CVS administration, or with other common source control
systems; common names for patch files, object files, archive files, and
editor backup files; and other names that are usually artifacts of
assorted utilities.  Currently, the default list of ignored files
includes files matching these names:

             RCSLOG  RCS     SCCS
             CVS*    cvslog.*
             tags    TAGS
             .make.state     .nse_depinfo
             *~      #*      .#*     ,*
             *.old   *.bak   *.BAK   *.orig  *.rej   .del-*
             *.a     *.o     *.so    *.Z     *.elc   *.ln
             core

   If the file `$CVSROOT/CVSROOT/cvsignore' exists, any files whose
names match the specifications in that file will also be ignored.

   If the file `$CVSROOT/CVSROOT/cvswrappers' exists, any file whose
names match the specifications in that file will be treated as packages
and the appropriate filtering will be performed on the file/directory
before being imported, *Note Wrappers::.

   The outside source is saved in a first-level RCS branch, by default
1.1.1.  Updates are leaves of this branch; for example, files from the
first imported collection of source will be revision 1.1.1.1, then
files from the first imported update will be revision 1.1.1.2, and so
on.

   At least three arguments are required.  REPOSITORY is needed to
identify the collection of source.  VENDORTAG is a tag for the entire
branch (e.g., for 1.1.1).  You must also specify at least one
RELEASETAG to identify the files at the leaves created each time you
execute `import'.

* Menu:

* import options::              import options
* import examples::             import examples


File: cvs.info,  Node: import options,  Next: import examples,  Up: import

import options
--------------

   This standard option is supported by `import' (*note Common
options::., for a complete description):

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

   There are three additional special options.

`-b BRANCH'
     Specify a first-level branch other than 1.1.1.  Unless the `-b
     BRANCH' flag is given, revisions will *always* be made to the
     branch 1.1.1--even if a VENDORTAG that matches another branch is
     given!  What happens in that case, is that the tag will be reset
     to 1.1.1.  Warning: This behavior might change in the future.

`-k SUBST'
     Indicate the RCS keyword expansion mode desired.  This setting will
     apply to all files created during the import, but not to any files
     that previously existed in the repository.  See co(1) for a
     complete list of valid `-k' settings.

     If you are checking in sources that contain RCS keywords, and you
     wish those keywords to remain intact, use the `-ko' flag when
     importing the files.  This setting indicates that no keyword
     expansion is to be performed by RCS when checking files out.  It
     is also useful for checking in binaries.

`-I NAME'
     Specify file names that should be ignored during import.  You can
     use this option repeatedly.  To avoid ignoring any files at all
     (even those ignored by default), specify `-I !'.

     NAME can be a file name pattern of the same type that you can
     specify in the `.cvsignore' file.  *Note cvsignore::.

`-W SPEC'
     Specify file names that should be filtered during import.  You can
     use this option repeatedly.

     SPEC can be a file name pattern of the same type that you can
     specify in the `.cvswrappers' file. *Note Wrappers::.


File: cvs.info,  Node: import examples,  Prev: import options,  Up: import

import examples
---------------

   *Note Tracking sources::, and *Note From files::.


File: cvs.info,  Node: log,  Next: rdiff,  Prev: import,  Up: Invoking CVS

log--Print out 'rlog' information for files
===========================================

   * Synopsis: log [-l] rlog-options [files...]

   * Requires: repository, working directory.

   * Changes: nothing.

   * Synonym: rlog

   Display log information for files.  `log' calls the RCS utility
`rlog', which prints all available information about the RCS history
file.  This includes the location of the RCS file, the "head" revision
(the latest revision on the trunk), all symbolic names (tags) and some
other things.  For each revision, the revision number, the author, the
number of lines added/deleted and the log message are printed.  All
times are displayed in Coordinated Universal Time (UTC).  (Other parts
of CVS print times in the local timezone).
d1159 3
a1161 2
* log options::                 log options
* log examples::                log examples
d1164 1
a1164 91
File: cvs.info,  Node: log options,  Next: log examples,  Up: log

log options
-----------

   Only one option is interpreted by CVS and not passed on to `rlog':

`-l'
     Local; run only in current working directory.  (Default is to run
     recursively).

   By default, `rlog' prints all information that is available.  All
other options (including those that normally behave differently) are
passed through to `rlog' and restrict the output.  See rlog(1) for a
complete description of options.  This incomplete list (which is a
slightly edited extract from rlog(1)) lists all options that are useful
in conjunction with CVS.

   *Please note:*  There can be no space between the option and its
argument, since `rlog' parses its options in a different way than CVS.

`-b'
     Print information about the revisions on the default branch,
     normally the highest branch on the trunk.

`-dDATES'
     Print information about revisions with a checkin date/time in the
     range given by the semicolon-separated list of dates.  The
     following table explains the available range formats:

    `D1<D2'
    `D2>D1'
          Select the revisions that were deposited between D1 and D2
          inclusive.

    `<D'
    `D>'
          Select all revisions dated D or earlier.

    `D<'
    `>D'
          Select all revisions dated D or later.

    `D'
          Select the single, latest revision dated D or earlier.

     The date/time strings D, D1, and D2 are in the free format
     explained in co(1).  Quoting is normally necessary, especially for
     < and >.  Note that the separator is a semicolon (;).

`-h'
     Print only the RCS pathname, working pathname, head, default
     branch, access list, locks, symbolic names, and suffix.

`-N'
     Do not print the list of tags for this file.  This option can be
     very useful when your site uses a lot of tags, so rather than
     "more"'ing over 3 pages of tag information, the log information is
     presented without tags at all.

`-R'
     Print only the name of the RCS history file.

`-rREVISIONS'
     Print information about revisions given in the comma-separated
     list REVISIONS of revisions and ranges.  The following table
     explains the available range formats:

    `REV1:REV2'
          Revisions REV1 to REV2 (which must be on the same branch).

    `:REV'
          Revisions from the beginning of the branch up to and
          including REV.

    `REV:'
          Revisions starting with REV to the end of the branch
          containing REV.

    `BRANCH'
          An argument that is a branch means all revisions on that
          branch.  You can unfortunately not specify a symbolic branch
          here.  You must specify the numeric branch number.  *Note
          Magic branch numbers::, for an explanation.

    `BRANCH1:BRANCH2'
          A range of branches means all revisions on the branches in
          that range.

    `BRANCH.'
          The latest revision in BRANCH.
d1166 2
a1167 2
     A bare `-r' with no revisions means the latest revision on the
     default branch, normally the trunk.
d1169 3
a1171 3
`-sSTATES'
     Print information about revisions whose state attributes match one
     of the states given in the comma-separated list STATES.
d1173 4
a1176 2
`-t'
     Print the same as `-h', plus the descriptive text.
d1178 5
a1182 4
`-wLOGINS'
     Print information about revisions checked in by users with login
     names appearing in the comma-separated list LOGINS.  If LOGINS is
     omitted, the user's login is assumed.
d1184 3
a1186 3
   `rlog' prints the intersection of the revisions selected with the
options `-d', `-l', `-s', and `-w', intersected with the union of the
revisions selected by `-b' and `-r'.
d1189 1
a1189 1
File: cvs.info,  Node: log examples,  Prev: log options,  Up: log
d1191 2
a1192 2
log examples
------------
d1194 2
a1195 1
   Contributed examples are gratefully accepted.
d1197 2
a1198 50

File: cvs.info,  Node: rdiff,  Next: release,  Prev: log,  Up: Invoking CVS

rdiff--'patch' format diffs between releases
============================================

   * rdiff [-flags] [-V vn] [-r t|-D d [-r t2|-D d2]] modules...

   * Requires: repository.

   * Changes: nothing.

   * Synonym: patch

   Builds a Larry Wall format patch(1) file between two releases, that
can be fed directly into the patch program to bring an old release
up-to-date with the new release.  (This is one of the few CVS commands
that operates directly from the repository, and doesn't require a prior
checkout.) The diff output is sent to the standard output device.

   You can specify (using the standard `-r' and `-D' options) any
combination of one or two revisions or dates.  If only one revision or
date is specified, the patch file reflects differences between that
revision or date and the current head revisions in the RCS file.

   Note that if the software release affected is contained in more than
one directory, then it may be necessary to specify the `-p' option to
the patch command when patching the old sources, so that patch is able
to find the files that are located in other directories.

* Menu:

* rdiff options::               rdiff options
* rdiff examples::              rdiff examples


File: cvs.info,  Node: rdiff options,  Next: rdiff examples,  Up: rdiff

rdiff options
-------------

   These standard options are supported by `rdiff' (*note Common
options::., for a complete description of them):

`-D DATE'
     Use the most recent revision no later than DATE.

`-f'
     If no matching revision is found, retrieve the most recent
     revision (instead of ignoring the file).
d1200 1
a1200 5
`-l'
     Local; don't descend subdirectories.

`-r TAG'
     Use revision TAG.
d1202 1
a1202 1
   In addition to the above, these options are available:
d1204 1
a1204 2
`-c'
     Use the context diff format.  This is the default format.
d1206 1
a1206 6
`-s'
     Create a summary change report instead of a patch.  The summary
     includes information about files that were changed or added
     between the releases.  It is sent to the standard output device.
     This is useful for finding out, for example, which files have
     changed between two dates or revisions.
d1208 3
a1210 4
`-t'
     A diff of the top two revisions is sent to the standard output
     device.  This is most useful for seeing what the last change to a
     file was.
d1212 1
a1212 6
`-u'
     Use the unidiff format for the context diffs.  This option is not
     available if your diff does not support the unidiff format.
     Remember that old versions of the `patch' program can't handle the
     unidiff format, so if you plan to post this patch to the net you
     should probably not use `-u'.
d1214 3
a1216 3
`-V VN'
     Expand RCS keywords according to the rules current in RCS version
     VN (the expansion format changed with RCS version 5).
d1219 1
a1219 1
File: cvs.info,  Node: rdiff examples,  Prev: rdiff options,  Up: rdiff
d1221 2
a1222 2
rdiff examples
--------------
d1224 2
a1225 3
   Suppose you receive mail from foo@@bar.com asking for an update from
release 1.2 to 1.4 of the tc compiler.  You have no such patches on
hand, but with CVS that can easily be fixed with a command such as this:
d1227 14
a1240 16
     $ cvs rdiff -c -r FOO1_2 -r FOO1_4 tc | \
     $$ Mail -s 'The patches you asked for' foo@@bar.com

   Suppose you have made release 1.3, and forked a branch called
`R_1_3fix' for bugfixes.  `R_1_3_1' corresponds to release 1.3.1, which
was made some time ago.  Now, you want to see how much development has
been done on the branch.  This command can be used:

     $ cvs patch -s -r R_1_3_1 -r R_1_3fix module-name
     cvs rdiff: Diffing module-name
     File ChangeLog,v changed from revision 1.52.2.5 to 1.52.2.6
     File foo.c,v changed from revision 1.52.2.3 to 1.52.2.4
     File bar.h,v changed from revision 1.29.2.1 to 1.2


File: cvs.info,  Node: release,  Next: remove,  Prev: rdiff,  Up: Invoking CVS
d1242 1
a1242 2
release--Indicate that a Module is no longer in use
===================================================
d1244 1
a1244 1
   * release [-dQq] modules...
d1246 2
a1247 1
   * Requires: Working directory.
d1249 1
a1249 27
   * Changes: Working directory, history log.

   This command is meant to safely cancel the effect of `cvs checkout'.
Since CVS doesn't lock files, it isn't strictly necessary to use this
command.  You can always simply delete your working directory, if you
like; but you risk losing changes you may have forgotten, and you leave
no trace in the CVS history file (*note history file::.) that you've
abandoned your checkout.

   Use `cvs release' to avoid these problems.  This command checks that
no uncommitted changes are present; that you are executing it from
immediately above a CVS working directory; and that the repository
recorded for your files is the same as the repository defined in the
module database.

   If all these conditions are true, `cvs release' leaves a record of
its execution (attesting to your intentionally abandoning your
checkout) in the CVS history log.

* Menu:

* release options::             release options
* release output::              release options
* release examples::            release examples


File: cvs.info,  Node: release options,  Next: release output,  Up: release
d1251 1
a1251 2
release options
---------------
d1253 1
a1253 1
   The `release' command supports one command option:
d1255 1
a1255 4
`-d'
     Delete your working copy of the file if the release succeeds.  If
     this flag is not given your files will remain in your working
     directory.
a1256 5
     *Warning:*  The `release' command uses `rm -r `module'' to delete
     your file.  This has the very serious side-effect that any
     directory that you have created inside your checked-out sources,
     and not added to the repository (using the `add' command; *note
     add::.) will be silently deleted--even if it is non-empty!
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Missed files from 1.7.1 import
@
text
@a24 608
File: cvs.info,  Node: Avoiding substitution,  Next: Substitution modes,  Prev: Using keywords,  Up: Keyword substitution

Avoiding substitution
=====================

   Keyword substitution has its disadvantages.  Sometimes you might
want the literal text string `$Author$' to appear inside a file without
RCS interpreting it as a keyword and expanding it into something like
`$Author: ceder $'.

   There is unfortunately no way to selectively turn off keyword
substitution.  You can use `-ko' (*note Substitution modes::.) to turn
off keyword substitution entirely.

   In many cases you can avoid using RCS keywords in the source, even
though they appear in the final product.  For example, the source for
this manual contains `$@@asis{}Author$' whenever the text `$Author$'
should appear.  In `nroff' and `troff' you can embed the null-character
`\&' inside the keyword for a similar effect.


File: cvs.info,  Node: Substitution modes,  Next: Log keyword,  Prev: Avoiding substitution,  Up: Keyword substitution

Substitution modes
==================

   You can control how RCS expands keywords through the use of the `-k'
option (*note Common options::.).  The `-k' option is available with the
`add', `checkout', `diff' and `update' commands.

   The modes available are:

`-kkv'
     Generate keyword strings using the default form, e.g.  `$Revision:
     5.7 $' for the `Revision' keyword.

`-kkvl'
     Like `-kkv', except that a locker's name is always inserted if the
     given revision is currently locked.  This option is normally not
     useful when CVS is used.

`-kk'
     Generate only keyword names in keyword strings; omit their values.
     For example, for the `Revision' keyword, generate the string
     `$Revision$' instead of `$Revision: 5.7 $'.  This option is useful
     to ignore differences due to keyword substitution when comparing
     different revisions of a file.

`-ko'
     Generate the old keyword string, present in the working file just
     before it was checked in.  For example, for the `Revision'
     keyword, generate the string `$Revision: 1.1 $' instead of
     `$Revision: 5.7 $' if that is how the string appeared when the
     file was checked in.

`-kb'
     Like `-ko', but also inhibit conversion of line endings between
     the canonical form in which they are stored in the repository
     (linefeed only), and the form appropriate to the operating system
     in use on the client.  For systems, like unix, which use linefeed
     only to terminate lines, this is the same as `-ko'.  For more
     information on binary files, see *Note Binary files::.

`-kv'
     Generate only keyword values for keyword strings.  For example,
     for the `Revision' keyword, generate the string `5.7' instead of
     `$Revision: 5.7 $'.  This can help generate files in programming
     languages where it is hard to strip keyword delimiters like
     `$Revision: $' from a string.  However, further keyword
     substitution cannot be performed once the keyword names are
     removed, so this option should be used with care.

     One often would like to use `-kv' with `cvs export'--*note
     export::..  But be aware that doesn't handle an export containing
     binary files correctly.


File: cvs.info,  Node: Log keyword,  Prev: Substitution modes,  Up: Keyword substitution

Problems with the $Log$ keyword.
================================

   The `$Log$' keyword is somewhat controversial.  As long as you are
working on your development system the information is easily accessible
even if you do not use the `$Log$' keyword--just do a `cvs log'.  Once
you export the file the history information might be useless anyhow.

   A more serious concern is that RCS is not good at handling `$Log$'
entries when a branch is merged onto the main trunk.  Conflicts often
result from the merging operation.

   People also tend to "fix" the log entries in the file (correcting
spelling mistakes and maybe even factual errors).  If that is done the
information from `cvs log' will not be consistent with the information
inside the file.  This may or may not be a problem in real life.

   It has been suggested that the `$Log$' keyword should be inserted
*last* in the file, and not in the files header, if it is to be used at
all.  That way the long list of change messages will not interfere with
everyday source file browsing.


File: cvs.info,  Node: Binary files,  Next: Revision management,  Prev: Keyword substitution,  Up: Top

Handling binary files
*********************

   There are two issues with using CVS to store binary files.  The
first is that CVS by default convert line endings between the canonical
form in which they are stored in the repository (linefeed only), and
the form appropriate to the operating system in use on the client (for
example, carriage return followed by line feed for Windows NT).

   The second is that a binary file might happen to contain data which
looks like a keyword (*note Keyword substitution::.), so keyword
expansion must be turned off.

   The `-kb' option available with some CVS commands insures that
neither line ending conversion nor keyword expansion will be done.  If
you are using an old version of RCS without this option, and you are
using an operating system, such as unix, which terminates lines with
linefeeds only, you can use `-ko' instead; if you are on another
operating system, upgrade to a version of RCS, such as 5.7 or later,
which supports `-kb'.

   Here is an example of how you can create a new file using the `-kb'
flag:

     $ echo '$Id$' > kotest
     $ cvs add -kb -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest

   If a file accidentally gets added without `-kb', one can use the
`cvs admin' command to recover.  For example:

     $ echo '$Id$' > kotest
     $ cvs add -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest
     $ cvs admin -kb kotest
     $ rm kotest
     $ cvs update kotest

   When you check in the file `kotest' the keywords are expanded.  (Try
the above example, and do a `cat kotest' after every command).  The `cvs
admin -kb' command sets the default keyword substitution method for
this file, but it does not alter the working copy of the file that you
have.  The easiest way to get the unexpanded version of `kotest' is to
remove it and check it out again.


File: cvs.info,  Node: Revision management,  Next: Invoking CVS,  Prev: Binary files,  Up: Top

Revision management
*******************

   If you have read this far, you probably have a pretty good grasp on
what CVS can do for you.  This chapter talks a little about things that
you still have to decide.

   If you are doing development on your own using CVS you could
probably skip this chapter.  The questions this chapter takes up become
more important when more than one person is working in a repository.

* Menu:

* When to commit::              Some discussion on the subject


File: cvs.info,  Node: When to commit,  Up: Revision management

When to commit?
===============

   Your group should decide which policy to use regarding commits.
Several policies are possible, and as your experience with CVS grows
you will probably find out what works for you.

   If you commit files too quickly you might commit files that do not
even compile.  If your partner updates his working sources to include
your buggy file, he will be unable to compile the code.  On the other
hand, other persons will not be able to benefit from the improvements
you make to the code if you commit very seldom, and conflicts will
probably be more common.

   It is common to only commit files after making sure that they can be
compiled.  Some sites require that the files pass a test suite.
Policies like this can be enforced using the commitinfo file (*note
commitinfo::.), but you should think twice before you enforce such a
convention.  By making the development environment too controlled it
might become too regimented and thus counter-productive to the real
goal, which is to get software written.


File: cvs.info,  Node: Invoking CVS,  Next: Administrative files,  Prev: Revision management,  Up: Top

Reference manual for CVS commands
*********************************

   This appendix describes how to invoke CVS, and describes in detail
those subcommands of CVS which are not fully described elsewhere.  To
look up a particular subcommand, see *Note Index::.

* Menu:

* Structure::                   Overall structure of CVS commands
* ~/.cvsrc::                    Default options with the ~/.csvrc file
* Global options::              Options you give to the left of cvs_command
* Common options::              Options you give to the right of cvs_command
* add::                         Add a new file/directory to the repository
* admin::                       Administration front end for rcs
* checkout::                    Checkout sources for editing
* commit::                      Check files into the repository
* diff::                        Run diffs between revisions
* export::                      Export sources from CVS, similar to checkout
* history::                     Show status of files and users
* import::                      Import sources into CVS, using vendor branches
* log::                         Print out 'rlog' information for files
* rdiff::                       'patch' format diffs between releases
* release::                     Indicate that a Module is no longer in use
* remove::                      Remove an entry from the repository
* rtag::                        Add a tag to a module
* status::                      Status info on the revisions
* tag::                         Add a tag to checked out version
* update::                      Bring work tree in sync with repository


File: cvs.info,  Node: Structure,  Next: ~/.cvsrc,  Up: Invoking CVS

Overall structure of CVS commands
=================================

   The first release of CVS consisted of a number of shell-scripts.
Today CVS is implemented as a single program that is a front-end to RCS
and `diff'. The overall format of all CVS commands is:

     cvs [ cvs_options ] cvs_command [ command_options ] [ command_args ]

`cvs'
     The program that is a front-end to RCS.

`cvs_options'
     Some options that affect all sub-commands of CVS.  These are
     described below.

`cvs_command'
     One of several different sub-commands.  Some of the commands have
     aliases that can be used instead; those aliases are noted in the
     reference manual for that command.  There are only two situations
     where you may omit `cvs_command': `cvs -H' elicits a list of
     available commands, and `cvs -v' displays version information on
     CVS itself.

`command_options'
     Options that are specific for the command.

`command_args'
     Arguments to the commands.

   There is unfortunately some confusion between `cvs_options' and
`command_options'.  `-l', when given as a `cvs_option', only affects
some of the commands.  When it is given as a `command_option' is has a
different meaning, and is accepted by more commands.  In other words,
do not take the above categorization too seriously.  Look at the
documentation instead.


File: cvs.info,  Node: ~/.cvsrc,  Next: Global options,  Prev: Structure,  Up: Invoking CVS

Default options and the ~/.cvsrc file
=====================================

   There are some `command_options' that are used so often that you
might have set up an alias or some other means to make sure you always
specify that option.  One example (the one that drove the
implementation of the .cvsrc support, actually) is that many people
find the default output of the `diff' command to be very hard to read,
and that either context diffs or unidiffs are much easier to understand.

   The `~/.cvsrc' file is a way that you can add default options to
`cvs_commands' within cvs, instead of relying on aliases or other shell
scripts.

   The format of the `~/.cvsrc' file is simple.  The file is searched
for a line that begins with the same name as the `cvs_command' being
executed.  If a match is found, then the remainder of the line is split
up (at whitespace characters) into separate options and added to the
command arguments *before* any options from the command line.

   If a command has two names (e.g., `checkout' and `co'), the official
name, not necessarily the one used on the command line, will be used to
match against the file.  So if this is the contents of the user's
`~/.cvsrc' file:

     log -N
     diff -u
     update -P
     co -P

the command `cvs checkout foo' would have the `-P' option added to the
arguments, as well as `cvs co foo'.

   With the example file above, the output from `cvs diff foobar' will
be in unidiff format.  `cvs diff -c foobar' will provide context diffs,
as usual.  Getting "old" format diffs would be slightly more
complicated, because `diff' doesn't have an option to specify use of
the "old" format, so you would need `cvs -f diff foobar'.


File: cvs.info,  Node: Global options,  Next: Common options,  Prev: ~/.cvsrc,  Up: Invoking CVS

Global options
==============

   The available `cvs_options' (that are given to the left of
`cvs_command') are:

`-b BINDIR'
     Use BINDIR as the directory where RCS programs are located.
     Overrides the setting of the `$RCSBIN' environment variable and
     any precompiled directory.  This parameter should be specified as
     an absolute pathname.

`-d CVS_ROOT_DIRECTORY'
     Use CVS_ROOT_DIRECTORY as the root directory pathname of the
     repository.  Overrides the setting of the `$CVSROOT' environment
     variable.  *Note Repository::.

`-e EDITOR'
     Use EDITOR to enter revision log information.  Overrides the
     setting of the `$CVSEDITOR' and `$EDITOR' environment variables.

`-f'
     Do not read the `~/.cvsrc' file.  This option is most often used
     because of the non-orthogonality of the CVS option set.  For
     example, the `cvs log' option `-N' (turn off display of tag names)
     does not have a corresponding option to turn the display on.  So
     if you have `-N' in the `~/.cvsrc' entry for `diff', you may need
     to use `-f' to show the tag names.  (1)

`-H'
     Display usage information about the specified `cvs_command' (but
     do not actually execute the command).  If you don't specify a
     command name, `cvs -H' displays a summary of all the commands
     available.

`-l'
     Do not log the cvs_command in the command history (but execute it
     anyway).  *Note history::, for information on command history.

`-n'
     Do not change any files.  Attempt to execute the `cvs_command',
     but only to issue reports; do not remove, update, or merge any
     existing files, or create any new files.

`-Q'
     Cause the command to be really quiet; the command will only
     generate output for serious problems.

`-q'
     Cause the command to be somewhat quiet; informational messages,
     such as reports of recursion through subdirectories, are
     suppressed.

`-r'
     Make new working files files read-only.  Same effect as if the
     `$CVSREAD' environment variable is set (*note Environment
     variables::.).  The default is to make working files writable.

`-t'
     Trace program execution; display messages showing the steps of CVS
     activity.  Particularly useful with `-n' to explore the potential
     impact of an unfamiliar command.

`-v'
     Display version and copyright information for CVS.

`-w'
     Make new working files read-write.  Overrides the setting of the
     `$CVSREAD' environment variable.  Files are created read-write by
     default, unless `$CVSREAD' is set or `-r' is given.

   ---------- Footnotes ----------

   (1)  Yes, this really should be fixed, and it's being worked on


File: cvs.info,  Node: Common options,  Next: add,  Prev: Global options,  Up: Invoking CVS

Common command options
======================

   This section describes the `command_options' that are available
across several CVS commands.  These options are always given to the
right of `cvs_command'. Not all commands support all of these options;
each option is only supported for commands where it makes sense.
However, when a command has one of these options you can almost always
count on the same behavior of the option as in other commands.  (Other
command options, which are listed with the individual commands, may have
different behavior from one CVS command to the other).

   *Warning:* the `history' command is an exception; it supports many
options that conflict even with these standard options.

`-D DATE_SPEC'
     Use the most recent revision no later than DATE_SPEC.  DATE_SPEC
     is a single argument, a date description specifying a date in the
     past.

     The specification is "sticky" when you use it to make a private
     copy of a source file; that is, when you get a working file using
     `-D', CVS records the date you specified, so that further updates
     in the same directory will use the same date (unless you
     explicitly override it; *note update::.).

     A wide variety of date formats are supported by the underlying RCS
     facilities, similar to those described in co(1), but not exactly
     the same.  The DATE_SPEC is interpreted as being in the local
     timezone, unless a specific timezone is specified.  Examples of
     valid date specifications include:

                              1 month ago
                              2 hours ago
                              400000 seconds ago
                              last year
                              last Monday
                              yesterday
                              a fortnight ago
                              3/31/92 10:00:07 PST
                              January 23, 1987 10:05pm
                              22:00 GMT

     `-D' is available with the `checkout', `diff', `export', `history',
     `rdiff', `rtag', and `update' commands.  (The `history' command
     uses this option in a slightly different way; *note history
     options::.).

     Remember to quote the argument to the `-D' flag so that your shell
     doesn't interpret spaces as argument separators.  A command using
     the `-D' flag can look like this:

          $ cvs diff -D "1 hour ago" cvs.texinfo

`-f'
     When you specify a particular date or tag to CVS commands, they
     normally ignore files that do not contain the tag (or did not
     exist prior to the date) that you specified.  Use the `-f' option
     if you want files retrieved even when there is no match for the
     tag or date.  (The most recent revision of the file will be used).

     `-f' is available with these commands: `checkout', `export',
     `rdiff', `rtag', and `update'.

     *Warning:*  The `commit' command also has a `-f' option, but it
     has a different behavior for that command.  *Note commit options::.

`-H'
     Help; describe the options available for this command.  This is
     the only option supported for all CVS commands.

`-k KFLAG'
     Alter the default RCS processing of keywords.  *Note Keyword
     substitution::, for the meaning of KFLAG.  Your KFLAG
     specification is "sticky" when you use it to create a private copy
     of a source file; that is, when you use this option with the
     `checkout' or `update' commands, CVS associates your selected
     KFLAG with the file, and continues to use it with future update
     commands on the same file until you specify otherwise.

     The `-k' option is available with the `add', `checkout', `diff' and
     `update' commands.

`-l'
     Local; run only in current working directory, rather than
     recursing through subdirectories.

     *Warning:* this is not the same as the overall `cvs -l' option,
     which you can specify to the left of a cvs command!

     Available with the following commands: `checkout', `commit',
     `diff', `export', `log', `remove', `rdiff', `rtag', `status',
     `tag', and `update'.

`-m MESSAGE'
     Use MESSAGE as log information, instead of invoking an editor.

     Available with the following commands: `add', `commit' and
     `import'.

`-n'
     Do not run any checkout/commit/tag program.  (A program can be
     specified to run on each of these activities, in the modules
     database (*note modules::.); this option bypasses it).

     *Warning:* this is not the same as the overall `cvs -n' option,
     which you can specify to the left of a cvs command!

     Available with the `checkout', `commit', `export', and `rtag'
     commands.

`-P'
     Prune (remove) directories that are empty after being updated, on
     `checkout', or `update'.  Normally, an empty directory (one that
     is void of revision-controlled files) is left alone.  Specifying
     `-P' will cause these directories to be silently removed from your
     checked-out sources.  This does not remove the directory from the
     repository, only from your checked out copy.  Note that this
     option is implied by the `-r' or `-D' options of `checkout' and
     `export'.

`-p'
     Pipe the files retrieved from the repository to standard output,
     rather than writing them in the current directory.  Available with
     the `checkout' and `update' commands.

`-W'
     Specify file names that should be filtered.  You can use this
     option repeatedly.  The spec can be a file name pattern of the
     same type that you can specify in the `.cvswrappers' file.
     Avaliable with the following commands: `import', and `update'.

`-r TAG'
     Use the revision specified by the TAG argument instead of the
     default "head" revision.  As well as arbitrary tags defined with
     the `tag' or `rtag' command, two special tags are always
     available: `HEAD' refers to the most recent version available in
     the repository, and `BASE' refers to the revision you last checked
     out into the current working directory.

     The tag specification is sticky when you use this option with
     `checkout' or `update' to make your own copy of a file: CVS
     remembers the tag and continues to use it on future update
     commands, until you specify otherwise.  The tag can be either a
     symbolic or numeric tag.  *Note Tags::.

     Specifying the `-q' global option along with the `-r' command
     option is often useful, to suppress the warning messages when the
     RCS history file does not contain the specified tag.

     *Warning:* this is not the same as the overall `cvs -r' option,
     which you can specify to the left of a cvs command!

     `-r' is available with the `checkout', `commit', `diff',
     `history', `export', `rdiff', `rtag', and `update' commands.


File: cvs.info,  Node: add,  Next: admin,  Prev: Common options,  Up: Invoking CVS

add--Add a new file/directory to the repository
===============================================

   * Synopsis: add [-k kflag] [-m 'message'] files...

   * Requires: repository, working directory.

   * Changes: working directory.

   * Synonym: new

   Use the `add' command to create a new file or directory in the
source repository.  The files or directories specified with `add' must
already exist in the current directory (which must have been created
with the `checkout' command).  To add a whole new directory hierarchy
to the source repository (for example, files received from a
third-party vendor), use the `import' command instead.  *Note import::.

   If the argument to `add' refers to an immediate sub-directory, the
directory is created at the correct place in the source repository, and
the necessary CVS administration files are created in your working
directory.  If the directory already exists in the source repository,
`add' still creates the administration files in your version of the
directory.  This allows you to use `add' to add a particular directory
to your private sources even if someone else created that directory
after your checkout of the sources.  You can do the following:

     $ mkdir new_directory
     $ cvs add new_directory
     $ cvs update new_directory

   An alternate approach using `update' might be:

     $ cvs update -d new_directory

   (To add any available new directories to your working directory,
it's probably simpler to use `checkout' (*note checkout::.) or `update
-d' (*note update::.)).

   The added files are not placed in the source repository until you
use `commit' to make the change permanent.  Doing an `add' on a file
that was removed with the `remove' command will resurrect the file,
unless a `commit' command intervened.  *Note remove examples:: for an
example.

   Unlike most other commands `add' never recurses down directories.
It cannot yet handle relative paths.  Instead of

     $ cvs add foo/bar.c

   you have to do

     $ cd foo
     $ cvs add bar.c

* Menu:

* add options::                 add options
* add examples::                add examples


d34 9
a42 4
     checked out.  The KFLAG argument (*note Substitution modes::.) is
     stored in the RCS file and can be changed with `admin -k' (*note
     admin options::.).  See *Note Binary files::, for information on
     using this option for binary files.
a85 5
   If there is a group whose name matches a compiled in value which
defaults to `cvsadmin', only members of that group can use `cvs admin'.
To disallow `cvs admin' for all users, create a group with no users in
it.

d179 9
a187 9
     Potentially useful, but dangerous, with CVS (see below).  Deletes
     ("outdates") the revisions given by RANGE.  A range consisting of
     a single revision number means that revision.  A range consisting
     of a branch number means the latest revision on that branch.  A
     range of the form `REV1:REV2' means revisions REV1 to REV2 on the
     same branch, `:REV' means from the beginning of the branch
     containing REV up to and including REV, and `REV:' means from
     revision REV to the end of the branch containing REV.  None of the
     outdated revisions may have branches or locks.
d195 3
a197 3
     tries to check it back in.  For this reason, this option is not a
     good way to take back a bogus commit; commit a new revision
     undoing the bogus change instead (*note Merging two revisions::.).
d280 23
a357 5
   The files created by `checkout' are created read-write, unless the
`-r' option to CVS (*note Global options::.) is specified, the
`CVSREAD' environment variable is specified (*note Environment
variables::.), or a watch is in effect for that file (*note Watches::.).

d431 8
a438 9
     With two `-j' options, merge changes from the revision specified
     with the first `-j' option to the revision specified with the
     second `j' option, into the working directory.

     With one `-j' option, merge changes from the ancestor revision to
     the revision specified with the `-j' option, into the working
     directory.  The ancestor revision is the common ancestor of the
     revision which the working directory is based on, and the revision
     specified in the `-j' option.
d443 3
a445 2
     specified by adding a colon (:) to the tag:
     `-jSYMBOLIC_TAG:DATE_SPECIFIER'.
d447 1
a447 1
     *Note Merging::.
d694 725
@


1.1.1.3
log
@Some files missed by initial import
@
text
@d2 1
a2 1
file ../../ccvs/doc/cvs.texinfo.
a24 49
File: cvs.info,  Node: Using keywords,  Next: Avoiding substitution,  Prev: Keyword list,  Up: Keyword substitution

Using keywords
==============

   To include a keyword string you simply include the relevant text
string, such as `$Id$', inside the file, and commit the file.  CVS will
automatically expand the string as part of the commit operation.

   It is common to embed `$Id$' string in the C source code.  This
example shows the first few lines of a typical file, after keyword
substitution has been performed:

     static char *rcsid="$Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";
     /* The following lines will prevent `gcc' version 2.X
        from issuing an "unused variable" warning. */
     #if __GNUC__ == 2
     #define USE(var) static void * use_##var = (&use_##var, (void *) &var)
     USE (rcsid);
     #endif

   Even though a clever optimizing compiler could remove the unused
variable `rcsid', most compilers tend to include the string in the
binary.  Some compilers have a `#pragma' directive to include literal
text in the binary.

   The `ident' command (which is part of the RCS package) can be used
to extract keywords and their values from a file.  This can be handy
for text files, but it is even more useful for extracting keywords from
binary files.

     $ ident samp.c
     samp.c:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $
     $ gcc samp.c
     $ ident a.out
     a.out:
          $Id: samp.c,v 1.5 1993/10/19 14:57:32 ceder Exp $

   SCCS is another popular revision control system.  It has a command,
`what', which is very similar to `ident' and used for the same purpose.
Many sites without RCS have SCCS.  Since `what' looks for the
character sequence `@@(#)' it is easy to include keywords that are
detected by either command.  Simply prefix the RCS keyword with the
magic SCCS phrase, like this:

     static char *id="@@(#) $Id: ab.c,v 1.5 1993/10/19 14:57:32 ceder Exp $";


d244 1
d391 1
a391 5
     variables::.).  The default is to make working files writable,
     unless watches are on (*note Watches::.).

`-s VARIABLE=VALUE'
     Set a user variable (*note Variables::.).
a405 3
`-z GZIP-LEVEL'
     Set the compression level.  Only has an effect on the CVS client.

d436 2
a437 2
     in the same directory will use the same date (for more information
     on sticky tags/dates, *note Sticky tags::.).
d556 1
a556 2
     commands, until you specify otherwise (for more information on
     sticky tags/dates, *note Sticky tags::.).  The tag can be either a
d614 1
a614 1
unless a `commit' command intervened.  *Note Removing files::, for an
d722 4
a725 4
     When used with bare RCS, this option sets the default branch to
     REV; in CVS sticky tags (*note Sticky tags::.) are a better way to
     decide which branch you want to work on.  With CVS, this option
     can be used to control behavior with respect to the vendor branch.
d750 3
a752 2
     `cvs update', `cvs export', or `cvs checkout' overrides this
     default.
d755 3
a757 2
     Lock the revision with number REV.  If a branch is given, lock the
     latest revision on that branch.  If REV is omitted, lock the
a759 8
     This can be used in conjunction with the `rcslock.pl' script in
     the `contrib' directory of the CVS source distribution to provide
     reserved checkouts (where only one user can be editing a given
     file at a time).  See the comments in that file for details (and
     see the `README' file in that directory for disclaimers about the
     unsupported nature of contrib).  According to comments in that
     file, locking must set to strict (which is the default).

d761 3
a763 4
     Set locking to strict.  Strict locking means that the owner of an
     RCS file is not exempt from locking for checkin.  For use with
     CVS, strict locking must be set; see the discussion under the `-l'
     option above.
d835 3
a837 4
     Set locking to non-strict.  Non-strict locking means that the
     owner of a file need not lock a revision for checkin.  For use
     with CVS, strict locking must be set; see the discussion under the
     `-l' option above.
d840 9
a848 9
     See the option `-l' above, for a discussion of using this option
     with CVS.  Unlock the revision with number REV.  If a branch is
     given, unlock the latest revision on that branch.  If REV is
     omitted, remove the latest lock held by the caller.  Normally,
     only the locker of a revision may unlock it.  Somebody else
     unlocking a revision breaks the lock.  This causes a mail message
     to be sent to the original locker.  The message contains a
     commentary solicited from the breaker.  The commentary is
     terminated by end-of-file or by a line containing `.' by itself.
d970 1
a970 2
     sticky, and implies `-P'.  See *Note Sticky tags::, for more
     information on sticky tags/dates.
d997 1
a997 2
     Use revision TAG.  This option is sticky, and implies `-P'.  See
     *Note Sticky tags::, for more information on sticky tags/dates.
d1003 6
a1008 2
     Reset any sticky tags, dates, or `-k' options.  See *Note Sticky
     tags::, for more information on sticky tags/dates.
d1169 115
@


1.1.1.4
log
@Files missed by previous import
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo-1.63 from the input
file ./cvs.texinfo.
a24 132
File: cvs.info,  Node: user-defined logging,  Next: annotate,  Prev: history database,  Up: History browsing

User-defined logging
====================

   You can customize CVS to log various kinds of actions, in whatever
manner you choose.  These mechanisms operate by executing a script at
various times.  The script might append a message to a file listing the
information and the programmer who created it, or send mail to a group
of developers, or, perhaps, post a message to a particular newsgroup.
To log commits, use the `loginfo' file (*note loginfo::.).  To log
commits, checkouts, exports, and tags, respectively, you can also use
the `-i', `-o', `-e', and `-t' options in the modules file.  For a more
flexible way of giving notifications to various users, which requires
less in the way of keeping centralized scripts up to date, use the `cvs
watch add' command (*note Getting Notified::.); this command is useful
even if you are not using `cvs watch on'.

   The `taginfo' file defines programs to execute when someone executes
a `tag' or `rtag' command.  The `taginfo' file has the standard form
for administrative files (*note Administrative files::.), where each
line is a regular expression followed by a command to execute.  The
arguments passed to the command are, in order, the TAGNAME, OPERATION
(`add' for `tag', `mov' for `tag -F', and `del' for `tag -d'),
REPOSITORY, and any remaining are pairs of FILENAME REVISION.  A
non-zero exit of the filter program will cause the tag to be aborted.


File: cvs.info,  Node: annotate,  Prev: user-defined logging,  Up: History browsing

Annotate command
================

 - Command: cvs annotate [`-l'] FILES ...
     For each file in FILES, print the head revision of the trunk,
     together with information on the last modification for each line.
     The `-l' option means to process the local directory only, not to
     recurse (*note Common options::.).  For example:

          $ cvs annotate ssfile
          Annotations for ssfile
          ***************
          1.1          (mary     27-Mar-96): ssfile line 1
          1.2          (joe      28-Mar-96): ssfile line 2

     The file `ssfile' currently contains two lines.  The `ssfile line
     1' line was checked in by `mary' on March 27.  Then, on March 28,
     `joe' added a line `ssfile line 2', without modifying the `ssfile
     line 1' line.  This report doesn't tell you anything about lines
     which have been deleted or replaced; you need to use `cvs diff'
     for that (*note diff::.).



File: cvs.info,  Node: Keyword substitution,  Next: Binary files,  Prev: History browsing,  Up: Top

Keyword substitution
********************

   As long as you edit source files inside your working copy of a
module you can always find out the state of your files via `cvs status'
and `cvs log'.  But as soon as you export the files from your
development environment it becomes harder to identify which revisions
they are.

   RCS uses a mechanism known as "keyword substitution" (or "keyword
expansion") to help identifying the files.  Embedded strings of the form
`$KEYWORD$' and `$KEYWORD:...$' in a file are replaced with strings of
the form `$KEYWORD:VALUE$' whenever you obtain a new revision of the
file.

* Menu:

* Keyword list::                RCS Keywords
* Using keywords::              Using keywords
* Avoiding substitution::       Avoiding substitution
* Substitution modes::          Substitution modes
* Log keyword::                 Problems with the $Log$ keyword.


File: cvs.info,  Node: Keyword list,  Next: Using keywords,  Up: Keyword substitution

RCS Keywords
============

   This is a list of the keywords that RCS currently (in release
5.6.0.1) supports:

`$Author$'
     The login name of the user who checked in the revision.

`$Date$'
     The date and time (UTC) the revision was checked in.

`$Header$'
     A standard header containing the full pathname of the RCS file,
     the revision number, the date (UTC), the author, the state, and
     the locker (if locked).  Files will normally never be locked when
     you use CVS.

`$Id$'
     Same as `$Header$', except that the RCS filename is without a path.

`$Locker$'
     The login name of the user who locked the revision (empty if not
     locked, and thus almost always useless when you are using CVS).

`$Log$'
     The log message supplied during commit, preceded by a header
     containing the RCS filename, the revision number, the author, and
     the date (UTC).  Existing log messages are *not* replaced.
     Instead, the new log message is inserted after `$Log:...$'.  Each
     new line is prefixed with a "comment leader" which RCS guesses
     from the file name extension.  It can be changed with `cvs admin
     -c'.  *Note admin options::.  This keyword is useful for
     accumulating a complete change log in a source file, but for
     several reasons it can be problematic.  *Note Log keyword::.

`$RCSfile$'
     The name of the RCS file without a path.

`$Revision$'
     The revision number assigned to the revision.

`$Source$'
     The full pathname of the RCS file.

`$State$'
     The state assigned to the revision.  States can be assigned with
     `cvs admin -s'--*Note admin options::.


d100 3
a102 5
   Each file has a stored default substitution mode, and each working
directory copy of a file also has a substitution mode.  The former is
set by the `-k' option to `cvs add' and `cvs admin'; the latter is set
by the -k or -A options to `cvs checkout' or `cvs update'.  `cvs diff'
also has a `-k' option.  For some examples, *Note Binary files::.
d213 2
a214 1
     $ cvs update -A kotest
d220 2
a221 2
have.  The easiest way to get the unexpanded version of `kotest' is
`cvs update -A'.
a379 8
   In place of the command name you can use `cvs' to specify global
options (*note Global options::.).  For example the following line in
`.cvsrc'

     cvs -z6

   causes CVS to use compression level 6

d882 1
a882 4
     `$State$' keywords (*note Keyword substitution::.).  Note that CVS
     uses the `dead' state for its own purposes; to take a file to or
     from the `dead' state use commands like `cvs remove' and `cvs
     add', not `cvs admin -s'.
d1126 105
@


1.1.1.5
log
@Missing files from import
@
text
@d1 1
a1 1
This is Info file cvs.info, produced by Makeinfo-1.55 from the input
a24 500
File: cvs.info,  Node: Recursive behavior,  Next: Adding files,  Prev: Merging,  Up: Top

Recursive behavior
******************

   Almost all of the subcommands of CVS work recursively when you
specify a directory as an argument.  For instance, consider this
directory structure:

           `$HOME'
             |
             +--tc
             |   |
                 +--CVS
                 |      (internal CVS files)
                 +--Makefile
                 +--backend.c
                 +--driver.c
                 +--frontend.c
                 +--parser.c
                 +--man
                 |    |
                 |    +--CVS
                 |    |  (internal CVS files)
                 |    +--tc.1
                 |
                 +--testing
                      |
                      +--CVS
                      |  (internal CVS files)
                      +--testpgm.t
                      +--test2.t

If `tc' is the current working directory, the following is true:

   * `cvs update testing' is equivalent to `cvs update
     testing/testpgm.t testing/test2.t'

   * `cvs update testing man' updates all files in the subdirectories

   * `cvs update .' or just `cvs update' updates all files in the `tc'
     module

   If no arguments are given to `update' it will update all files in
the current working directory and all its subdirectories.  In other
words, `.' is a default argument to `update'.  This is also true for
most of the CVS subcommands, not only the `update' command.

   The recursive behavior of the CVS subcommands can be turned off with
the `-l' option.

     $ cvs update -l         # Don't update files in subdirectories


File: cvs.info,  Node: Adding files,  Next: Removing files,  Prev: Recursive behavior,  Up: Top

Adding files to a directory
***************************

   To add a new file to a directory, follow these steps.

   * You must have a working copy of the directory.  *Note Getting the
     source::.

   * Create the new file inside your working copy of the directory.

   * Use `cvs add FILENAME' to tell CVS that you want to version
     control the file.  If the file contains binary data, specify `-kb'
     (*note Binary files::.).

   * Use `cvs commit FILENAME' to actually check in the file into the
     repository.  Other developers cannot see the file until you
     perform this step.

   You can also use the `add' command to add a new directory.

   Unlike most other commands, the `add' command is not recursive.  You
cannot even type `cvs add foo/bar'!  Instead, you have to

     $ cd foo
     $ cvs add bar

 - Command: cvs add [`-k' KFLAG] [`-m' MESSAGE] FILES ...
     Schedule FILES to be added to the repository.  The files or
     directories specified with `add' must already exist in the current
     directory.  To add a whole new directory hierarchy to the source
     repository (for example, files received from a third-party
     vendor), use the `import' command instead.  *Note import::.

     The added files are not placed in the source repository until you
     use `commit' to make the change permanent.  Doing an `add' on a
     file that was removed with the `remove' command will undo the
     effect of the `remove', unless a `commit' command intervened.
     *Note Removing files::, for an example.

     The `-k' option specifies the default way that this file will be
     checked out; for more information see *Note Substitution modes::.

     The `-m' option specifies a description for the file.  This
     description appears in the history log (if it is enabled, *note
     history file::.).  It will also be saved in the version history
     inside the repository when the file is committed.  The `log'
     command displays this description.  The description can be changed
     using `admin -t'.  *Note admin::.  If you omit the `-m
     DESCRIPTION' flag, an empty string will be used.  You will not be
     prompted for a description.

   For example, the following commands add the file `backend.c' to the
repository:

     $ cvs add backend.c
     $ cvs commit -m "Early version. Not yet compilable." backend.c

   When you add a file it is added only on the branch which you are
working on (*note Branches::.).  You can later merge the additions to
another branch if you want (*note Merging adds and removals::.).


File: cvs.info,  Node: Removing files,  Next: Tracking sources,  Prev: Adding files,  Up: Top

Removing files from a module
****************************

   Modules change.  New files are added, and old files disappear.
Still, you want to be able to retrieve an exact copy of old releases of
the module.

   Here is what you can do to remove a file from a module, but remain
able to retrieve old revisions:

   * Make sure that you have not made any uncommitted modifications to
     the file.  *Note Viewing differences::, for one way to do that.
     You can also use the `status' or `update' command.  If you remove
     the file without committing your changes, you will of course not
     be able to retrieve the file as it was immediately before you
     deleted it.

   * Remove the file from your working copy of the module.  You can for
     instance use `rm'.

   * Use `cvs remove FILENAME' to tell CVS that you really want to
     delete the file.

   * Use `cvs commit FILENAME' to actually perform the removal of the
     file from the repository.

   When you commit the removal of the file, CVS records the fact that
the file no longer exists.  It is possible for a file to exist on only
some branches and not on others, or to re-add another file with the same
name later.  CVS will correctly create or not create the file, based on
the `-r' and `-D' options specified to `checkout' or `update'.

 - Command: cvs remove [`-lR'] FILES ...
     Schedule file(s) to be removed from the repository (files which
     have not already been removed from the working directory are not
     processed).  This command does not actually remove the file from
     the repository until you commit the removal.  The `-R' option (the
     default) specifies that it will recurse into subdirectories; `-l'
     specifies that it will not.

   Here is an example of removing several files:

     $ cd test
     $ rm ?.c
     $ cvs remove
     cvs remove: Removing .
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   If you change your mind you can easily resurrect the file before you
commit it, using the `add' command.

     $ ls
     CVS   ja.h  oj.c
     $ rm oj.c
     $ cvs remove oj.c
     cvs remove: scheduling oj.c for removal
     cvs remove: use 'cvs commit' to remove this file permanently
     $ cvs add oj.c
     U oj.c
     cvs add: oj.c, version 1.1.1.1, resurrected

   If you realize your mistake before you run the `remove' command you
can use `update' to resurrect the file:

     $ rm oj.c
     $ cvs update oj.c
     cvs update: warning: oj.c was lost
     U oj.c

   When you remove a file it is added only on the branch which you are
working on (*note Branches::.).  You can later merge the additions to
another branch if you want (*note Merging adds and removals::.).


File: cvs.info,  Node: Tracking sources,  Next: Moving files,  Prev: Removing files,  Up: Top

Tracking third-party sources
****************************

   If you modify a program to better fit your site, you probably want
to include your modifications when the next release of the program
arrives.  CVS can help you with this task.

   In the terminology used in CVS, the supplier of the program is
called a "vendor".  The unmodified distribution from the vendor is
checked in on its own branch, the "vendor branch".  CVS reserves branch
1.1.1 for this use.

   When you modify the source and commit it, your revision will end up
on the main trunk.  When a new release is made by the vendor, you
commit it on the vendor branch and copy the modifications onto the main
trunk.

   Use the `import' command to create and update the vendor branch.
After a successful `import' the vendor branch is made the `head'
revision, so anyone that checks out a copy of the file gets that
revision.  When a local modification is committed it is placed on the
main trunk, and made the `head' revision.

* Menu:

* First import::                Importing a module for the first time
* Update imports::              Updating a module with the import command
* Binary files in imports::     Binary files require special handling


File: cvs.info,  Node: First import,  Next: Update imports,  Up: Tracking sources

Importing a module for the first time
=====================================

   Use the `import' command to check in the sources for the first time.
When you use the `import' command to track third-party sources, the
"vendor tag" and "release tags" are useful.  The "vendor tag" is a
symbolic name for the branch (which is always 1.1.1, unless you use the
`-b BRANCH' flag--*Note import options::).  The "release tags" are
symbolic names for a particular release, such as `FSF_0_04'.

   Suppose you use `wdiff' (a variant of `diff' that ignores changes
that only involve whitespace), and are going to make private
modifications that you want to be able to use even when new releases
are made in the future.  You start by importing the source to your
repository:

     $ tar xfz wdiff-0.04.tar.gz
     $ cd wdiff-0.04
     $ cvs import -m "Import of FSF v. 0.04" fsf/wdiff FSF_DIST WDIFF_0_04

   The vendor tag is named `FSF_DIST' in the above example, and the
only release tag assigned is `WDIFF_0_04'.


File: cvs.info,  Node: Update imports,  Next: Binary files in imports,  Prev: First import,  Up: Tracking sources

Updating a module with the import command
=========================================

   When a new release of the source arrives, you import it into the
repository with the same `import' command that you used to set up the
repository in the first place.  The only difference is that you specify
a different release tag this time.

     $ tar xfz wdiff-0.05.tar.gz
     $ cd wdiff-0.05
     $ cvs import -m "Import of FSF v. 0.05" fsf/wdiff FSF_DIST WDIFF_0_05

   For files that have not been modified locally, the newly created
revision becomes the head revision.  If you have made local changes,
`import' will warn you that you must merge the changes into the main
trunk, and tell you to use `checkout -j' to do so.

     $ cvs checkout -jFSF_DIST:yesterday -jFSF_DIST wdiff

The above command will check out the latest revision of `wdiff',
merging the changes made on the vendor branch `FSF_DIST' since
yesterday into the working copy.  If any conflicts arise during the
merge they should be resolved in the normal way (*note Conflicts
example::.).  Then, the modified files may be committed.

   Using a date, as suggested above, assumes that you do not import
more than one release of a product per day. If you do, you can always
use something like this instead:

     $ cvs checkout -jWDIFF_0_04 -jWDIFF_0_05 wdiff

In this case, the two above commands are equivalent.


File: cvs.info,  Node: Binary files in imports,  Prev: Update imports,  Up: Tracking sources

How to handle binary files with cvs import
==========================================

   Use the `-k' wrapper option to tell import which files are binary.
*Note Wrappers::.


File: cvs.info,  Node: Moving files,  Next: Moving directories,  Prev: Tracking sources,  Up: Top

Moving and renaming files
*************************

   Moving files to a different directory or renaming them is not
difficult, but some of the ways in which this works may be non-obvious.
(Moving or renaming a directory is even harder.  *Note Moving
directories::).

   The examples below assume that the file OLD is renamed to NEW.

* Menu:

* Outside::                     The normal way to Rename
* Inside::                      A tricky, alternative way
* Rename by copying::           Another tricky, alternative way


File: cvs.info,  Node: Outside,  Next: Inside,  Up: Moving files

The Normal way to Rename
========================

   The normal way to move a file is to copy OLD to NEW, and then issue
the normal CVS commands to remove OLD from the repository, and add NEW
to it.  (Both OLD and NEW could contain relative paths, for example
`foo/bar.c').

     $ mv OLD NEW
     $ cvs remove OLD
     $ cvs add NEW
     $ cvs commit -m "Renamed OLD to NEW" OLD NEW

   This is the simplest way to move a file, it is not error-prone, and
it preserves the history of what was done.  Note that to access the
history of the file you must specify the old or the new name, depending
on what portion of the history you are accessing.  For example, `cvs
log OLD' will give the log up until the time of the rename.

   When NEW is committed its revision numbers will start at 1.0 again,
so if that bothers you, use the `-r rev' option to commit (*note commit
options::.)


File: cvs.info,  Node: Inside,  Next: Rename by copying,  Prev: Outside,  Up: Moving files

Moving the history file
=======================

   This method is more dangerous, since it involves moving files inside
the repository.  Read this entire section before trying it out!

     $ cd $CVSROOT/MODULE
     $ mv OLD,v NEW,v

Advantages:

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * Old releases of the module cannot easily be fetched from the
     repository.  (The file will show up as NEW even in revisions from
     the time before it was renamed).

   * There is no log information of when the file was renamed.

   * Nasty things might happen if someone accesses the history file
     while you are moving it.  Make sure no one else runs any of the CVS
     commands while you move it.


File: cvs.info,  Node: Rename by copying,  Prev: Inside,  Up: Moving files

Copying the history file
========================

   This way also involves direct modifications to the repository.  It
is safe, but not without drawbacks.

     # Copy the RCS file inside the repository
     $ cd $CVSROOT/MODULE
     $ cp OLD,v NEW,v
     # Remove the old file
     $ cd ~/MODULE
     $ rm OLD
     $ cvs remove OLD
     $ cvs commit OLD
     # Remove all tags from NEW
     $ cvs update NEW
     $ cvs log NEW             # Remember the non-branch tag names
     $ cvs tag -d TAG1 NEW
     $ cvs tag -d TAG2 NEW
     ...

   By removing the tags you will be able to check out old revisions of
the module.

Advantages:

   * Checking out old revisions works correctly, as long as you use
     `-rTAG' and not `-DDATE' to retrieve the revisions.

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * You cannot easily see the history of the file across the rename.

   * Unless you use the `-r rev' (*note commit options::.) flag when
     NEW is committed its revision numbers will start at 1.0 again.


File: cvs.info,  Node: Moving directories,  Next: History browsing,  Prev: Moving files,  Up: Top

Moving and renaming directories
*******************************

   If you want to be able to retrieve old versions of the module, you
must move each file in the directory with the CVS commands.  *Note
Outside::.  The old, empty directory will remain inside the repository,
but it will not appear in your workspace when you check out the module
in the future.

   If you really want to rename or delete a directory, you can do it
like this:

  1. Inform everyone who has a copy of the module that the directory
     will be renamed.  They should commit all their changes, and remove
     their working copies of the module, before you take the steps
     below.

  2. Rename the directory inside the repository.

          $ cd $CVSROOT/MODULE
          $ mv OLD-DIR NEW-DIR

  3. Fix the CVS administrative files, if necessary (for instance if
     you renamed an entire module).

  4. Tell everyone that they can check out the module and continue
     working.


   If someone had a working copy of the module the CVS commands will
cease to work for him, until he removes the directory that disappeared
inside the repository.

   It is almost always better to move the files in the directory
instead of moving the directory.  If you move the directory you are
unlikely to be able to retrieve old releases correctly, since they
probably depend on the name of the directories.


File: cvs.info,  Node: History browsing,  Next: Keyword substitution,  Prev: Moving directories,  Up: Top

History browsing
****************

   Once you have used CVS to store a version control history--what
files have changed when, how, and by whom, there are a variety of
mechanisms for looking through the history.

* Menu:

* log messages::                Log messages
* history database::            The history database
* user-defined logging::        User-defined logging
* annotate::                    What revision modified each line of a file?


File: cvs.info,  Node: log messages,  Next: history database,  Up: History browsing

Log messages
============

   Whenever you commit a file you specify a log message.

   To look through the log messages which have been specified for every
revision which has been committed, use the `cvs log' command (*note
log::.).


File: cvs.info,  Node: history database,  Next: user-defined logging,  Prev: log messages,  Up: History browsing

The history database
====================

   You can use the history file (*note history file::.) to log various
CVS actions.  To retrieve the information from the history file, use
the `cvs history' command (*note history::.).


d58 1
a58 1
 - Command: cvs annotate [`-lf'] [`-r rev'|`-D date'] FILES ...
d61 2
a62 1
     For example:
a77 18
   These standard options are available with `annotate' (*note Common
options::., for a complete description of them):

`-D DATE'
     Annotate the most recent revision no later than DATE.

`-f'
     Only useful with the `-D DATE' or `-r TAG' flags.  If no matching
     revision is found, annotate the most recent revision (instead of
     ignoring the file).

`-l'
     Local; run only in current working directory.  *Note Recursive
     behavior::.

`-r TAG'
     Annotate revision TAG.

a127 3
`$Name$'
     Tag name used to check out this file.

a347 1
     $ cvs commit -m "make it binary" kotest  # For non-unix systems
d354 1
a354 15
`cvs update -A'.  If you need to cope with line endings (that is, you
are using a CVS client on a non-unix system), then you need to check in
a new copy of the file, as shown by the `cvs commit' command above.

   However, in using `cvs admin -k' to change the keyword expansion, be
aware that the keyword expansion mode is not version controlled.  This
means that, for example, that if you have a text file in old releases,
and a binary file with the same name in new releases, CVS provides no
way to check out the file in text or binary mode depending on what
version you are checking out.  There is no good workaround for this
problem.

   You can also set a default for whether `cvs add' and `cvs import'
treat a file as binary based on its name; for example you could say
that files who names end in `.exe' are binary.  *Note Wrappers::.
d415 1
d437 3
a439 1
   The overall format of all CVS commands is:
d444 1
a444 1
     The name of the CVS program.
a535 6
`-T TEMPDIR'
     Use TEMPDIR as the directory where temporary files are located.
     Overrides the setting of the `$TMPDIR' environment variable and
     any precompiled directory.  This parameter should be specified as
     an absolute pathname.

d550 2
a551 2
     if you have `-N' in the `~/.cvsrc' entry for `log', you may need
     to use `-f' to show the tag names.
a598 8
`-x'
     Encrypt all communication between the client and the server.  Only
     has an effect on the CVS client.  As of this writing, this is only
     implemented when using a Kerberos connection (*note Kerberos
     authenticated::.).  Encryption support is not available by
     default; it must be enabled using a special configure option,
     `--enable-encryption', when you build CVS.

d601 669
@


1.1.1.6
log
@Missed files from new release from Cyclic Software
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo-1.64 from the input
file ../../work/ccvs/doc/cvs.texinfo.
a24 163
File: cvs.info,  Node: Merging,  Next: Recursive behavior,  Prev: Branches,  Up: Top

Merging
*******

   You can include the changes made between any two revisions into your
working copy, by "merging".  You can then commit that revision, and
thus effectively copy the changes onto another branch.

* Menu:

* Merging a branch::            Merging an entire branch
* Merging more than once::      Merging from a branch several times
* Merging two revisions::       Merging differences between two revisions
* Merging adds and removals::   What if files are added or removed?


File: cvs.info,  Node: Merging a branch,  Next: Merging more than once,  Up: Merging

Merging an entire branch
========================

   You can merge changes made on a branch into your working copy by
giving the `-j BRANCH' flag to the `update' command.  With one `-j
BRANCH' option it merges the changes made between the point where the
branch forked and newest revision on that branch (into your working
copy).

   The `-j' stands for "join".

   Consider this revision tree:

     +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

The branch 1.2.2 has been given the tag (symbolic name) `R1fix'.  The
following example assumes that the module `mod' contains only one file,
`m.c'.

     $ cvs checkout mod               # Retrieve the latest revision, 1.4
     
     $ cvs update -j R1fix m.c        # Merge all changes made on the branch,
                                      # i.e. the changes between revision 1.2
                                      # and 1.2.2.2, into your working copy
                                      # of the file.
     
     $ cvs commit -m "Included R1fix" # Create revision 1.5.

   A conflict can result from a merge operation.  If that happens, you
should resolve it before committing the new revision.  *Note Conflicts
example::.

   The `checkout' command also supports the `-j BRANCH' flag.  The same
effect as above could be achieved with this:

     $ cvs checkout -j R1fix mod
     $ cvs commit -m "Included R1fix"


File: cvs.info,  Node: Merging more than once,  Next: Merging two revisions,  Prev: Merging a branch,  Up: Merging

Merging from a branch several times
===================================

   Continuing our example, the revision tree now looks like this:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !
                         +---------+    +---------+

   where the starred line represents the merge from the `R1fix' branch
to the main trunk, as just discussed.

   Now suppose that development continues on the `R1fix' branch:

     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !                           *
                     !                          *
                     !   +---------+    +---------+    +---------+
     Branch R1fix -> +---! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                         +---------+    +---------+    +---------+

   and then you want to merge those new changes onto the main trunk.
If you just use the `cvs update -j R1fix m.c' command again, CVS will
attempt to merge again the changes which you have already merged, which
can have undesirable side effects.

   So instead you need to specify that you only want to merge the
changes on the branch which have not yet been merged into the trunk.
To do that you specify two `-j' options, and CVS merges the changes from
the first revision to the second revision.  For example, in this case
the simplest way would be

     cvs update -j 1.2.2.2 -j R1fix m.c    # Merge changes from 1.2.2.2 to the
                                           # head of the R1fix branch

   The problem with this is that you need to specify the 1.2.2.2
revision manually.  A slightly better approach might be to use the date
the last merge was done:

     cvs update -j R1fix:yesterday -j R1fix m.c

   Better yet, tag the R1fix branch after every merge into the trunk,
and then use that tag for subsequent merges:

     cvs update -j merged_from_R1fix_to_trunk -j R1fix m.c


File: cvs.info,  Node: Merging two revisions,  Next: Merging adds and removals,  Prev: Merging more than once,  Up: Merging

Merging differences between any two revisions
=============================================

   With two `-j REVISION' flags, the `update' (and `checkout') command
can merge the differences between any two revisions into your working
file.

     $ cvs update -j 1.5 -j 1.3 backend.c

will *remove* all changes made between revision 1.3 and 1.5.  Note the
order of the revisions!

   If you try to use this option when operating on multiple files,
remember that the numeric revisions will probably be very different
between the various files that make up a module.  You almost always use
symbolic tags rather than revision numbers when operating on multiple
files.


File: cvs.info,  Node: Merging adds and removals,  Prev: Merging two revisions,  Up: Merging

Merging can add or remove files
===============================

   If the changes which you are merging involve removing or adding some
files, `update -j' will reflect such additions or removals.

   For example:
     cvs update -A
     touch a b c
     cvs add a b c ; cvs ci -m "added" a b c
     cvs tag -b branchtag
     cvs update -r branchtag
     touch d ; cvs add d
     rm a ; cvs rm a
     cvs ci -m "added d, removed a"
     cvs update -A
     cvs update -jbranchtag


d143 1
a143 1
File: cvs.info,  Node: Removing files,  Next: Removing directories,  Prev: Adding files,  Up: Top
d145 2
a146 2
Removing files
**************
d149 2
a150 1
Still, you want to be able to retrieve an exact copy of old releases.
d152 2
a153 2
   Here is what you can do to remove a file, but remain able to
retrieve old revisions:
d162 2
a163 2
   * Remove the file from your working copy of the directory.  You can
     for instance use `rm'.
d219 3
a221 26
   When you remove a file it is removed only on the branch which you
are working on (*note Branches::.).  You can later merge the removals
to another branch if you want (*note Merging adds and removals::.).


File: cvs.info,  Node: Removing directories,  Next: Tracking sources,  Prev: Removing files,  Up: Top

Removing directories
********************

   In concept removing directories is somewhat similar to removing
files--you want the directory to not exist in your current working
directories, but you also want to be able to retrieve old releases in
which the directory existed.

   The way that you remove a directory is to remove all the files in
it.  Then specify the `-P' option to `cvs update', `cvs checkout', or
`cvs export', which will cause CVS to remove empty directories from
working directories.  Probably the best way to do this is to always
specify `-P'; if you want an empty directory then put a dummy file (for
example `.keepme') in it to prevent `-P' from removing it.

   Note that `-P' is implied by the `-r' or `-D' options of `checkout'
and `export'.  This way CVS will be able to correctly create the
directory or not depending on whether the particular version you are
checking out contains any files in that directory.
d224 1
a224 1
File: cvs.info,  Node: Tracking sources,  Next: Moving files,  Prev: Removing directories,  Up: Top
a252 1
* Reverting local changes::     Reverting a module to the latest vendor release
d265 1
a265 1
`-b BRANCH' flag--*Note import options::.).  The "release tags" are
d268 2
a269 8
   Note that `import' does *not* change the directory in which you
invoke it.  In particular, it does not set up that directory as a CVS
working directory; if you want to work with the sources import them
first and then check them out into a different directory (*note Getting
the source::.).

   Suppose you have the sources to a program called `wdiff' in a
directory called `wdiff-0.04', and are going to make private
d274 1
d282 1
a282 1
File: cvs.info,  Node: Update imports,  Next: Reverting local changes,  Prev: First import,  Up: Tracking sources
d318 1
a318 19
File: cvs.info,  Node: Reverting local changes,  Next: Binary files in imports,  Prev: Update imports,  Up: Tracking sources

Reverting to the latest vendor release
======================================

   You can also revert local changes completely and return to the
latest vendor release by changing the `head' revision back to the
vendor branch on all files.  For example, if you have a checked-out
copy of the sources in `~/work.d/wdiff', and you want to revert to the
vendor's version for all the files in that directory, you would type:

     $ cd ~/work.d/wdiff
     $ cvs admin -bWDIFF .

You must specify the `-bWDIFF' without any space after the `-b'.  *Note
admin options::.


File: cvs.info,  Node: Binary files in imports,  Prev: Reverting local changes,  Up: Tracking sources
d335 1
a335 1
directories::.).
d450 5
a454 3
   The normal way to rename or move a directory is to rename or move
each file within it as described in *Note Outside::.  Then check out
with the `-P' option, as described in *Note Removing directories::.
d456 2
a457 2
   If you really want to hack the repository to rename or delete a
directory in the repository, you can do it like this:
d577 17
a593 3
   The options to `cvs annotate' are listed in *Note Invoking CVS::,
and can be used to select the files and revisions to annotate.  The
options are described in more detail in *Note Common options::.
d830 1
a830 1
File: cvs.info,  Node: Binary files,  Next: Builds,  Prev: Keyword substitution,  Up: Top
d892 1
a892 72
File: cvs.info,  Node: Builds,  Next: Compatibility,  Prev: Binary files,  Up: Top

How your build system interacts with CVS
****************************************

   As mentioned in the introduction, CVS does not contain software for
building your software from source code.  This section describes how
various aspects of your build system might interact with CVS.

   One common question, especially from people who are accustomed to
RCS, is how to make their build get an up to date copy of the sources.
The answer to this with CVS is two-fold.  First of all, since CVS
itself can recurse through directories, there is no need to modify your
`Makefile' (or whatever configuration file your build tool uses) to
make sure each file is up to date.  Instead, just use two commands,
first `cvs -q update' and then `make' or whatever the command is to
invoke your build tool.  Secondly, you do not necessarily *want* to get
a copy of a change someone else made until you have finished your own
work.  One suggested approach is to first update your sources, then
implement, build and test the change you were thinking of, and then
commit your sources (updating first if necessary).  By periodically (in
between changes, using the approach just described) updating your
entire tree, you ensure that your sources are sufficiently up to date.

   One common need is to record which versions of which source files
went into a particular build.  This kind of functionality is sometimes
called "bill of materials" or something similar.  The best way to do
this with CVS is to use the `tag' command to record which versions went
into a given build (*note Tags::.).

   Using CVS in the most straightforward manner possible, each
developer will have a copy of the entire source tree which is used in a
particular build.  If the source tree is small, or if developers are
geographically dispersed, this is the preferred solution.  In fact one
approach for larger projects is to break a project down into smaller
separately-compiled subsystems, and arrange a way of releasing them
internally so that each developer need check out only those subsystems
which are they are actively working on.

   Another approach is to set up a structure which allows developers to
have their own copies of some files, and for other files to access
source files from a central location.  Many people have come up with
some such a system using features such as the symbolic link feature
found in many operating systems, or the `VPATH' feature found in many
versions of `make'.  One build tool which is designed to help with this
kind of thing is Odin (see
`ftp://ftp.cs.colorado.edu/pub/distribs/odin').


File: cvs.info,  Node: Compatibility,  Next: Revision management,  Prev: Builds,  Up: Top

Compatibility between CVS Versions
**********************************

   The repository format is compatible going back to CVS 1.3.  But see
*Note Watches Compatibility::, if you have copies of CVS 1.6 or older
and you want to use the optional developer communication features.

   The working directory format is compatible going back to CVS 1.5.
It did change between CVS 1.3 and CVS 1.5.  If you run CVS 1.5 or newer
on a working directory checked out with CVS 1.3, CVS will convert it,
but to go back to CVS 1.3 you need to check out a new working directory
with CVS 1.3.

   The remote protocol is interoperable going back to CVS 1.5, but no
further (1.5 was the first official release with the remote protocol,
but some older versions might still be floating around).  In many cases
you need to upgrade both the client and the server to take advantage of
new features and bugfixes, however.


File: cvs.info,  Node: Revision management,  Next: CVS commands,  Prev: Compatibility,  Up: Top
d935 1
a935 1
File: cvs.info,  Node: CVS commands,  Next: Invoking CVS,  Prev: Revision management,  Up: Top
d937 2
a938 2
Guide to CVS commands
*********************
d940 3
a942 3
   This appendix describes the overall structure of CVS commands, and
describes some commands in detail (others are described elsewhere; for
a quick reference to CVS commands, *note Invoking CVS::.).
d966 1
a966 1
File: cvs.info,  Node: Structure,  Next: ~/.cvsrc,  Up: CVS commands
d1002 145
@


1.1.1.7
log
@Files missed from previous import
@
text
@a24 75
File: cvs.info,  Node: Sticky tags,  Prev: Creating a branch,  Up: Branches

Sticky tags
===========

   The `-r release-1-0-patches' flag that was given to `checkout' in
the previous example is "sticky", that is, it will apply to subsequent
commands in this directory.  If you commit any modifications, they are
committed on the branch.  You can later merge the modifications into
the main trunk.  *Note Merging::.

   You can use the `status' command to see what sticky tags or dates
are set:

     $ vi driver.c   # Fix the bugs
     $ cvs commit -m "Fixed initialization bug" driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7.2.1; previous revision: 1.7
     done
     $ cvs status -v driver.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
         RCS Version:        1.7.2.1 /usr/local/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.7.2)
             release-1-0                     (revision: 1.7)

   The sticky tags will remain on your working files until you delete
them with `cvs update -A'.  The `-A' option retrieves the version of
the file from the head of the trunk, and forgets any sticky tags,
dates, or options.

   Sticky tags are not just for branches.  For example, suppose that
you want to avoid updating your working directory, to isolate yourself
from possibly destabilizing changes other people are making.  You can,
of course, just refrain from running `cvs update'.  But if you want to
avoid updating only a portion of a larger tree, then sticky tags can
help.  If you check out a certain revision (such as 1.4) it will become
sticky.  Subsequent `cvs update' will not retrieve the latest revision
until you reset the tag with `cvs update -A'.  Likewise, use of the
`-D' option to `update' or `checkout' sets a "sticky date", which,
similarly, causes that date to be used for future retrievals.

   Many times you will want to retrieve an old version of a file
without setting a sticky tag.  The way to do that is with the `-p'
option to `checkout' or `update', which sends the contents of the file
to standard output.  For example, suppose you have a file named `file1'
which existed as revision 1.1, and you then removed it (thus adding a
dead revision 1.2).  Now suppose you want to add it again, with the same
contents it had previously.  Here is how to do it:

     $ cvs update -p -r 1.1 file1 >file1
     ===================================================================
     Checking out file1
     RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
     VERS: 1.1
     ***************
     $ cvs add file1
     cvs add: re-adding file file1 (in place of dead revision 1.2)
     cvs add: use 'cvs commit' to add this file permanently
     $ cvs commit -m test
     Checking in file1;
     /tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
     new revision: 1.3; previous revision: 1.2
     done
     $


d1197 69
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d25 1
a25 60
File: cvs.info,  Node: Creating a branch,  Next: Sticky tags,  Prev: Branches motivation,  Up: Revisions and branches

Creating a branch
=================

   The `rtag' command can be used to create a branch.  The `rtag'
command is much like `tag', but it does not require that you have a
working copy of the module.  *Note rtag::.  (You can also use the `tag'
command; *note tag::.).

     $ cvs rtag -b -r release-1-0 release-1-0-patches tc

   The `-b' flag makes `rtag' create a branch (rather than just a
symbolic revision name).  `-r release-1-0' says that this branch should
be rooted at the node (in the revision tree) that corresponds to the tag
`release-1-0'.  Note that the numeric revision number that matches
`release-1-0' will probably be different from file to file.  The name
of the new branch is `release-1-0-patches', and the module affected is
`tc'.

   To fix the problem in release 1.0, you need a working copy of the
branch you just created.

     $ cvs checkout -r release-1-0-patches tc
     $ cvs status -v driver.c backend.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7     Sat Dec  5 18:25:54 1992
         RCS Version:        1.7     /usr/local/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.7.2)
             release-1-0                     (revision: 1.7)
     
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /usr/local/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.4.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.4.2)
             release-1-0                     (revision: 1.4)
             release-0-4                     (revision: 1.4)

   As the output from the `status' command shows the branch number is
created by adding a digit at the tail of the revision number it is
based on.  (If `release-1-0' corresponds to revision 1.4, the branch's
revision number will be 1.4.2.  For obscure reasons CVS always gives
branches even numbers, starting at 2.  *Note Revision numbers::.).


File: cvs.info,  Node: Sticky tags,  Prev: Creating a branch,  Up: Revisions and branches
d100 1
a100 1
File: cvs.info,  Node: Merging,  Next: Recursive behavior,  Prev: Revisions and branches,  Up: Top
d377 2
a378 3
working on (*note Revisions and branches::.).  You can later merge the
additions to another branch if you want (*note Merging adds and
removals::.).
d457 2
a458 3
are working on (*note Revisions and branches::.).  You can later merge
the removals to another branch if you want (*note Merging adds and
removals::.).
d1207 65
@


1.1.1.9
log
@Missing files from import
@
text
@a24 181
File: cvs.info,  Node: Assigning revisions,  Next: Tags,  Prev: Versions revisions releases,  Up: Revisions and branches

Assigning revisions
===================

   By default, CVS will assign numeric revisions by leaving the first
number the same and incrementing the second number.  For example,
`1.1', `1.2', `1.3', etc.

   When adding a new file, the second number will always be one and the
first number will equal the highest first number of any file in that
directory.  For example, the current directory contains files whose
highest numbered revisions are `1.7', `3.1', and `4.12', then an added
file will be given the numeric revision `4.1'.

   Normally there is no reason to care about the revision numbers--it
is easier to treat them as internal numbers that CVS maintains, and tags
provide a better way to distinguish between things like release 1
versus release 2 of your product (*note Tags::.).  However, if you want
to set the numeric revisions, the `-r' option to `cvs commit' can do
that.  The `-r' option implies the `-f' option, in the sense that it
causes the files to be committed even if they are not modified.

   For example, to bring all your files up to revision 3.0 (including
those that haven't changed), you might invoke:

     $ cvs commit -r 3.0

   Note that the number you specify with `-r' must be larger than any
existing revision number.  That is, if revision 3.0 exists, you cannot
`cvs commit -r 1.3'.  If you want to maintain several releases in
parallel, you need to use a branch (*note Revisions and branches::.).


File: cvs.info,  Node: Tags,  Next: Branches motivation,  Prev: Assigning revisions,  Up: Revisions and branches

Tags-Symbolic revisions
=======================

   The revision numbers live a life of their own.  They need not have
anything at all to do with the release numbers of your software
product.  Depending on how you use CVS the revision numbers might
change several times between two releases.  As an example, some of the
source files that make up RCS 5.6 have the following revision numbers:

     ci.c            5.21
     co.c            5.9
     ident.c         5.3
     rcs.c           5.12
     rcsbase.h       5.11
     rcsdiff.c       5.10
     rcsedit.c       5.11
     rcsfcmp.c       5.9
     rcsgen.c        5.10
     rcslex.c        5.11
     rcsmap.c        5.2
     rcsutil.c       5.10

   You can use the `tag' command to give a symbolic name to a certain
revision of a file.  You can use the `-v' flag to the `status' command
to see all tags that a file has, and which revision numbers they
represent.  Tag names must start with an uppercase or lowercase letter
and can contain uppercase and lowercase letters, digits, `-', and `_'.
The two tag names `BASE' and `HEAD' are reserved for use by CVS.  It is
expected that future names which are special to CVS will be specially
named, for example by starting with `.', rather than being named
analogously to `BASE' and `HEAD', to avoid conflicts with actual tag
names.

   You'll want to choose some convention for naming tags, based on
information such as the name of the program and the version number of
the release.  For example, one might take the name of the program,
immediately followed by the version number with `.' changed to `-', so
that CVS 1.9 would be tagged with the name `cvs1-9'.  If you choose a
consistent convention, then you won't constantly be guessing whether a
tag is `cvs-1-9' or `cvs1_9' or what.  You might even want to consider
enforcing your convention in the taginfo file (*note user-defined
logging::.).

   The following example shows how you can add a tag to a file.  The
commands must be issued inside your working copy of the module.  That
is, you should issue the command in the directory where `backend.c'
resides.

     $ cvs tag release-0-4 backend.c
     T backend.c
     $ cvs status -v backend.c
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /usr/local/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         (none)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-0-4                     (revision: 1.4)

   There is seldom reason to tag a file in isolation.  A more common
use is to tag all the files that constitute a module with the same tag
at strategic points in the development life-cycle, such as when a
release is made.

     $ cvs tag release-1-0 .
     cvs tag: Tagging .
     T Makefile
     T backend.c
     T driver.c
     T frontend.c
     T parser.c

   (When you give CVS a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  *Note Recursive behavior::.)

   The `checkout' command has a flag, `-r', that lets you check out a
certain revision of a module.  This flag makes it easy to retrieve the
sources that make up release 1.0 of the module `tc' at any time in the
future:

     $ cvs checkout -r release-1-0 tc

This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.

   You can also check out a module as it was at any given date.  *Note
checkout options::.

   When you tag more than one file with the same tag you can think
about the tag as "a curve drawn through a matrix of filename vs.
revision number."  Say we have 5 files with the following revisions:

             file1   file2   file3   file4   file5
     
             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6

   At some time in the past, the `*' versions were tagged.  You can
think of the tag as a handle attached to the curve drawn through the
tagged revisions.  When you pull on the handle, you get all the tagged
revisions.  Another way to look at it is that you "sight" through a set
of revisions that is "flat" along the tagged revisions, like this:

             file1   file2   file3   file4   file5
     
                             1.1
                             1.2
                     1.1     1.3                       _
             1.1     1.2     1.4     1.1              /
             1.2*----1.3*----1.5*----1.2*----1.1     (--- <--- Look here
             1.3             1.6     1.3              \_
             1.4                     1.4
                                     1.5


File: cvs.info,  Node: Branches motivation,  Next: Creating a branch,  Prev: Tags,  Up: Revisions and branches

What branches are good for
==========================

   Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.
After a while your customers start to complain about a fatal bug.  You
check out release 1.0 (*note Tags::.) and find the bug (which turns out
to have a trivial fix).  However, the current revision of the sources
are in a state of flux and are not expected to be stable for at least
another month.  There is no way to make a bugfix release based on the
newest sources.

   The thing to do in a situation like this is to create a "branch" on
the revision trees for all the files that make up release 1.0 of tc.
You can then make modifications to the branch without disturbing the
main trunk.  When the modifications are finished you can select to
either incorporate them on the main trunk, or leave them on the branch.


d84 1
a84 1
File: cvs.info,  Node: Sticky tags,  Next: Magic branch numbers,  Prev: Creating a branch,  Up: Revisions and branches
a158 35
File: cvs.info,  Node: Magic branch numbers,  Prev: Sticky tags,  Up: Revisions and branches

Magic branch numbers
====================

   This section describes a CVS feature called "magic branches".  For
most purposes, you need not worry about magic branches; CVS handles
them for you.  However, they are visible to you in certain
circumstances, so it may be useful to have some idea of how it works.

   Externally, branch numbers consist of an odd number of dot-separated
decimal integers.  *Note Revision numbers::.  That is not the whole
truth, however.  For efficiency reasons CVS sometimes inserts an extra 0
in the second rightmost position (1.2.3 becomes 1.2.0.3, 8.9.10.11.12
becomes 8.9.10.11.0.12 and so on).

   CVS does a pretty good job at hiding these so called magic branches,
but in a few places the hiding is incomplete:

   * The magic branch number appears in the output from `cvs log'.

   * You cannot specify a symbolic branch name to `cvs admin'.

   You can use the `admin' command to reassign a symbolic name to a
branch the way RCS expects it to be.  If `R4patches' is assigned to the
branch 1.4.2 (magic branch number 1.4.0.2) in file `numbers.c' you can
do this:

     $ cvs admin -NR4patches:1.4.2 numbers.c

   It only works if at least one revision is already committed on the
branch.  Be very careful so that you do not assign the tag to the wrong
number.  (There is no way to see how the tag was assigned yesterday).


d698 2
a699 1
to it.
d712 3
a714 3
   When NEW is committed its revision numbers will start again, usually
at 1.1, so if that bothers you, use the `-r rev' option to commit.  For
more information see *Note Assigning revisions::.
d786 3
d1074 194
@


1.1.1.10
log
@Missing files from initial import
@
text
@a24 178
File: cvs.info,  Node: Watches Compatibility,  Prev: Watch information,  Up: Watches

Using watches with old versions of CVS
--------------------------------------

   If you use the watch features on a repository, it creates `CVS'
directories in the repository and stores the information about watches
in that directory.  If you attempt to use CVS 1.6 or earlier with the
repository, you get an error message such as the following (all on one
line):

     cvs update: cannot open CVS/Entries for reading:
     No such file or directory

   and your operation will likely be aborted.  To use the watch
features, you must upgrade all copies of CVS which use that repository
in local or server mode.  If you cannot upgrade, use the `watch off' and
`watch remove' commands to remove all watches, and that will restore
the repository to a state which CVS 1.6 can cope with.


File: cvs.info,  Node: Choosing a model,  Prev: Watches,  Up: Multiple developers

Choosing between reserved or unreserved checkouts
=================================================

   Reserved and unreserved checkouts each have pros and cons.  Let it
be said that a lot of this is a matter of opinion or what works given
different groups' working styles, but here is a brief description of
some of the issues.  There are many ways to organize a team of
developers.  CVS does not try to enforce a certain organization.  It is
a tool that can be used in several ways.

   Reserved checkouts can be very counter-productive.  If two persons
want to edit different parts of a file, there may be no reason to
prevent either of them from doing so.  Also, it is common for someone
to take out a lock on a file, because they are planning to edit it, but
then forget to release the lock.

   People, especially people who are familiar with reserved checkouts,
often wonder how often conflicts occur if unreserved checkouts are
used, and how difficult they are to resolve.  The experience with many
groups is that they occur rarely and usually are relatively
straightforward to resolve.

   The rarity of serious conflicts may be surprising, until one realizes
that they occur only when two developers disagree on the proper design
for a given section of code; such a disagreement suggests that the team
has not been communicating properly in the first place.  In order to
collaborate under *any* source management regimen, developers must
agree on the general design of the system; given this agreement,
overlapping changes are usually straightforward to merge.

   In some cases unreserved checkouts are clearly inappropriate.  If no
merge tool exists for the kind of file you are managing (for example
word processor files or files edited by Computer Aided Design
programs), and it is not desirable to change to a program which uses a
mergeable data format, then resolving conflicts is going to be
unpleasant enough that you generally will be better off to simply avoid
the conflicts instead, by using reserved checkouts.

   The watches features described above in *Note Watches:: can be
considered to be an intermediate model between reserved checkouts and
unreserved checkouts.  When you go to edit a file, it is possible to
find out who else is editing it.  And rather than having the system
simply forbid both people editing the file, it can tell you what the
situation is and let you figure out whether it is a problem in that
particular case or not.  Therefore, for some groups it can be
considered the best of both the reserved checkout and unreserved
checkout worlds.


File: cvs.info,  Node: Revisions and branches,  Next: Merging,  Prev: Multiple developers,  Up: Top

Revisions and branches
**********************

   For many uses of CVS, one doesn't need to worry too much about
revision numbers; CVS assigns numbers such as `1.1', `1.2', and so on,
and that is all one needs to know.  However, some people prefer to have
more knowledge and control concerning how CVS assigns revision numbers.

   If one wants to keep track of a set of revisions involving more than
one file, such as which revisions went into a particular release, one
uses a "tag", which is a symbolic revision which can be assigned to a
numeric revision in each file.

   Another useful feature, especially when maintaining several releases
of a software product at once, is the ability to make branches on the
revision tree.

* Menu:

* Revision numbers::            The meaning of a revision number
* Versions revisions releases::  Terminology used in this manual
* Assigning revisions::         Assigning revisions
* Tags::                        Tags-Symbolic revisions
* Branches motivation::         What branches are good for
* Creating a branch::           Creating a branch
* Sticky tags::                 Sticky tags
* Magic branch numbers::        Magic branch numbers


File: cvs.info,  Node: Revision numbers,  Next: Versions revisions releases,  Up: Revisions and branches

Revision numbers
================

   Each version of a file has a unique "revision number".  Revision
numbers look like `1.1', `1.2', `1.3.2.2' or even `1.3.2.2.4.5'.  A
revision number always has an even number of period-separated decimal
integers.  By default revision 1.1 is the first revision of a file.
Each successive revision is given a new number by increasing the
rightmost number by one.  The following figure displays a few
revisions, with newer revisions to the right.

            +-----+    +-----+    +-----+    +-----+    +-----+
            ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
            +-----+    +-----+    +-----+    +-----+    +-----+

   CVS is not limited to linear development.  The "revision tree" can
be split into "branches", where each branch is a self-maintained line of
development.  Changes made on one branch can easily be moved back to
the main trunk.

   Each branch has a "branch number", consisting of an odd number of
period-separated decimal integers.  The branch number is created by
appending an integer to the revision number where the corresponding
branch forked off.  Having branch numbers allows more than one branch
to be forked off from a certain revision.

   All revisions on a branch have revision numbers formed by appending
an ordinal number to the branch number.  The following figure
illustrates branching with an example.

                                           +-------------+
                Branch 1.2.2.3.2 ->        ! 1.2.2.3.2.1 !
                                         / +-------------+
                                        /
                                       /
                      +---------+    +---------+    +---------+
     Branch 1.2.2 -> _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !
                    / +---------+    +---------+    +---------+
                   /
                  /
     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !  <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+    +---------+
     Branch 1.2.4 -> +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                         +---------+    +---------+    +---------+

   The exact details of how the branch number is constructed is not
something you normally need to be concerned about, but here is how it
works: When CVS creates a branch number it picks the first unused even
integer, starting with 2.  So when you want to create a branch from
revision 6.4 it will be numbered 6.4.2.  All branch numbers ending in a
zero (such as 6.4.0) are used internally by CVS (*note Magic branch
numbers::.).  The branch 1.1.1 has a special meaning.  *Note Tracking
sources::.


File: cvs.info,  Node: Versions revisions releases,  Next: Assigning revisions,  Prev: Revision numbers,  Up: Revisions and branches

Versions, revisions and releases
================================

   A file can have several versions, as described above.  Likewise, a
software product can have several versions.  A software product is
often given a version number such as `4.1.1'.

   Versions in the first sense are called "revisions" in this document,
and versions in the second sense are called "releases".  To avoid
confusion, the word "version" is almost never used in this document.


d116 1
a116 1
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
d235 1
a235 1
         RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
d248 1
a248 1
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
d290 1
a290 1
         RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
d448 1
a448 1
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
d462 1
a462 1
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !   <- The main trunk
d573 2
a574 3
   * `cvs update testing' is equivalent to

          cvs update testing/testpgm.t testing/test2.t
d587 1
a587 2
the `-l' option.  Conversely, the `-R' option can be used to force
recursion if `-l' is specified in `~/.cvsrc' (*note ~/.cvsrc::.).
d690 1
a690 1
 - Command: cvs remove [OPTIONS] FILES ...
d694 3
a696 2
     the repository until you commit the removal.  For a full list of
     options, see *Note Invoking CVS::.
d701 1
a701 1
     $ rm *.c
d711 2
a712 15
   As a convenience you can remove the file and `cvs remove' it in one
step, by specifying the `-f' option.  For example, the above example
could also be done like this:

     $ cd test
     $ cvs remove -f *.c
     cvs remove: scheduling a.c for removal
     cvs remove: scheduling b.c for removal
     cvs remove: use 'cvs commit' to remove these files permanently
     $ cvs ci -m "Removed unneeded files"
     cvs commit: Examining .
     cvs commit: Committing .

   If you execute `remove' for a file, and then change your mind before
you commit, you can undo the `remove' with an `add' command.
a791 2
* Keywords in imports::         Keyword substitution might be undesirable
* Multiple vendor branches::    What if you get sources from several places?
d803 2
a804 2
`-b BRANCH' flag--*Note Multiple vendor branches::.).  The "release
tags" are symbolic names for a particular release, such as `FSF_0_04'.
d813 4
a816 3
directory `wdiff-0.04', and are going to make private modifications
that you want to be able to use even when new releases are made in the
future.  You start by importing the source to your repository:
d879 1
a879 1
File: cvs.info,  Node: Binary files in imports,  Next: Keywords in imports,  Prev: Reverting local changes,  Up: Tracking sources
a887 59
File: cvs.info,  Node: Keywords in imports,  Next: Multiple vendor branches,  Prev: Binary files in imports,  Up: Tracking sources

How to handle keyword substitution with cvs import
==================================================

   The sources which you are importing may contain keywords (*note
Keyword substitution::.).  For example, the vendor may use CVS or some
other system which uses similar keyword expansion syntax.  If you just
import the files in the default fashion, then the keyword expansions
supplied by the vendor will be replaced by keyword expansions supplied
by your own copy of CVS.  It may be more convenient to maintain the
expansions supplied by the vendor, so that this information can supply
information about the sources that you imported from the vendor.

   To maintain the keyword expansions supplied by the vendor, supply
the `-ko' option to `cvs import' the first time you import the file.
This will turn off keyword expansion for that file entirely, so if you
want to be more selective you'll have to think about what you want and
use the `-k' option to `cvs update' or `cvs admin' as appropriate.


File: cvs.info,  Node: Multiple vendor branches,  Prev: Keywords in imports,  Up: Tracking sources

Multiple vendor branches
========================

   All the examples so far assume that there is only one vendor from
which you are getting sources.  In some situations you might get
sources from a variety of places.  For example, suppose that you are
dealing with a project where many different people and teams are
modifying the software.  There are a variety of ways to handle this,
but in some cases you have a bunch of source trees lying around and
what you want to do more than anything else is just to all put them in
CVS so that you at least have them in one place.

   For handling situations in which there may be more than one vendor,
you may specify the `-b' option to `cvs import'.  It takes as an
argument the vendor branch to import to.  The default is `-b 1.1.1'.

   For example, suppose that there are two teams, the red team and the
blue team, that are sending you sources.  You want to import the red
team's efforts to branch 1.1.1 and use the vendor tag RED.  You want to
import the blue team's efforts to branch 1.1.3 and use the vendor tag
BLUE.  So the commands you might use are:

     $ cvs import dir RED RED_1-0
     $ cvs import -b 1.1.3 dir BLUE BLUE_1-5

   Note that if your vendor tag does not match your `-b' option, CVS
will not detect this case!  For example,

     $ cvs import -b 1.1.3 dir RED RED_1-0

Be careful; this kind of mismatch is sure to sow confusion or worse.  I
can't think of a useful purpose for the ability to specify a mismatch
here, but if you discover such a use, don't.  CVS is likely to make this
an error in some future release.


d960 326
@


1.1.1.11
log
@Latest version from Cyclic; files missed in first run
@
text
@d25 1
a25 1
File: cvs.info,  Node: Creating a branch,  Next: Accessing branches,  Prev: Branches motivation,  Up: Branching and merging
d27 2
a28 2
Creating a branch
=================
d30 85
a114 2
   You can create a branch with `tag -b'; for example, assuming you're
in a working copy:
d116 1
a116 108
     $ cvs tag -b release-1-0-patches

   This splits off a branch based on the current revisions in the
working copy, assigning that branch the name `release-1-0-patches'.

   It is important to understand that branches get created in the
repository, not in the working copy.  Creating a branch based on
current revisions, as the above example does, will *not* automatically
switch the working copy to be on the new branch.  For information on how
to do that, see *Note Accessing branches::.

   You can also create a branch without reference to any working copy,
by using `rtag':

     $ cvs rtag -b -r release-1-0 release-1-0-patches tc

   `-r release-1-0' says that this branch should be rooted at the
revision that corresponds to the tag `release-1-0'.  It need not be the
most recent revision - it's often useful to split a branch off an old
revision (for example, when fixing a bug in a past release otherwise
known to be stable).

   As with `tag', the `-b' flag tells `rtag' to create a branch (rather
than just a symbolic revision name).  Note that the numeric revision
number that matches `release-1-0' will probably be different from file
to file.

   So, the full effect of the command is to create a new branch - named
`release-1-0-patches' - in module `tc', rooted in the revision tree at
the point tagged by `release-1-0'.


File: cvs.info,  Node: Accessing branches,  Next: Branches and revisions,  Prev: Creating a branch,  Up: Branching and merging

Accessing branches
==================

   You can retrieve a branch in one of two ways: by checking it out
fresh from the repository, or by switching an existing working copy
over to the branch.

   To check out a branch from the repository, invoke `checkout' with
the `-r' flag, followed by the tag name of the branch (*note Creating a
branch::.):

     $ cvs checkout -r release-1-0-patches tc

   Or, if you already have a working copy, you can switch it to a given
branch with `update -r':

     $ cvs update -r release-1-0-patches tc

   or equivalently:

     $ cd tc
     $ cvs update -r release-1-0-patches

   It does not matter if the working copy was originally on the main
trunk or on some other branch - the above command will switch it to the
named branch.  And similarly to a regular `update' command, `update -r'
merges any changes you have made, notifying you of conflicts where they
occur.

   Once you have a working copy tied to a particular branch, it remains
there until you tell it otherwise.  This means that changes checked in
from the working copy will add new revisions on that branch, while
leaving the main trunk and other branches unaffected.

   To find out what branch a working copy is on, you can use the
`status' command.  In its output, look for the field named `Sticky tag'
(*note Sticky tags::.) - that's CVS's way of telling you the branch, if
any, of the current working files:

     $ cvs status -v driver.c backend.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7     Sat Dec  5 18:25:54 1992
         RCS Version:        1.7     /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.7.2)
             release-1-0                     (revision: 1.7)
     
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         release-1-0-patches (branch: 1.4.2)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-1-0-patches             (branch: 1.4.2)
             release-1-0                     (revision: 1.4)
             release-0-4                     (revision: 1.4)

   Don't be confused by the fact that the branch numbers for each file
are different (`1.7.2' and `1.4.2' respectively).  The branch tag is the
same, `release-1-0-patches', and the files are indeed on the same
branch.  The numbers simply reflect the point in each file's revision
history at which the branch was made.  In the above example, one can
deduce that `driver.c' had been through more changes than `backend.c'
before this branch was created.
d118 8
a125 2
   See *Note Branches and revisions:: for details about how branch
numbers are constructed.
d128 1
a128 1
File: cvs.info,  Node: Branches and revisions,  Next: Magic branch numbers,  Prev: Accessing branches,  Up: Branching and merging
d130 2
a131 2
Branches and revisions
======================
d133 7
a139 2
   Ordinarily, a file's revision history is a linear series of
increments (*note Revision numbers::.):
d145 4
a148 4
   However, CVS is not limited to linear development.  The "revision
tree" can be split into "branches", where each branch is a
self-maintained line of development.  Changes made on one branch can
easily be moved back to the main trunk.
d189 330
a518 1
File: cvs.info,  Node: Magic branch numbers,  Next: Merging a branch,  Prev: Branches and revisions,  Up: Branching and merging
d531 1
a531 1
in the second rightmost position (1.2.4 becomes 1.2.0.4, 8.9.10.11.12
d553 18
a570 1
File: cvs.info,  Node: Merging a branch,  Next: Merging more than once,  Prev: Magic branch numbers,  Up: Branching and merging
d618 1
a618 1
File: cvs.info,  Node: Merging more than once,  Next: Merging two revisions,  Prev: Merging a branch,  Up: Branching and merging
d674 1
a674 1
File: cvs.info,  Node: Merging two revisions,  Next: Merging adds and removals,  Prev: Merging more than once,  Up: Branching and merging
d695 1
a695 1
File: cvs.info,  Node: Merging adds and removals,  Prev: Merging two revisions,  Up: Branching and merging
a714 3
   After these commands are executed and a `cvs commit' is done, file
`a' will be removed and file `d' added in the main branch.

d716 1
a716 1
File: cvs.info,  Node: Recursive behavior,  Next: Adding and removing,  Prev: Branching and merging,  Up: Top
d772 1
a772 22
File: cvs.info,  Node: Adding and removing,  Next: History browsing,  Prev: Recursive behavior,  Up: Top

Adding, removing, and renaming files and directories
****************************************************

   In the course of a project, one will often add new files.  Likewise
with removing or renaming, or with directories.  The general concept to
keep in mind in all these cases is that instead of making an
irreversible change you want CVS to record the fact that a change has
taken place, just as with modifying an existing file.  The exact
mechanisms to do this in CVS vary depending on the situation.

* Menu:

* Adding files::                Adding files
* Removing files::              Removing files
* Removing directories::        Removing directories
* Moving files::                Moving and renaming files
* Moving directories::          Moving and renaming directories


File: cvs.info,  Node: Adding files,  Next: Removing files,  Up: Adding and removing
d775 1
a775 1
===========================
d832 1
a832 1
working on (*note Branching and merging::.).  You can later merge the
d837 1
a837 1
File: cvs.info,  Node: Removing files,  Next: Removing directories,  Prev: Adding files,  Up: Adding and removing
d840 1
a840 1
==============
d925 1
a925 1
are working on (*note Branching and merging::.).  You can later merge
d930 1
a930 1
File: cvs.info,  Node: Removing directories,  Next: Moving files,  Prev: Removing files,  Up: Adding and removing
d933 1
a933 1
====================
d941 1
a941 2
it.  You don't remove the directory itself; there is no way to do that.
Instead you specify the `-P' option to `cvs update', `cvs checkout', or
d953 1
a953 4
File: cvs.info,  Node: Moving files,  Next: Moving directories,  Prev: Removing directories,  Up: Adding and removing

Moving and renaming files
=========================
d955 2
a956 4
   Moving files to a different directory or renaming them is not
difficult, but some of the ways in which this works may be non-obvious.
(Moving or renaming a directory is even harder.  *Note Moving
directories::.).
d958 19
a976 1
   The examples below assume that the file OLD is renamed to NEW.
d980 6
a985 58
* Outside::                     The normal way to Rename
* Inside::                      A tricky, alternative way
* Rename by copying::           Another tricky, alternative way


File: cvs.info,  Node: Outside,  Next: Inside,  Up: Moving files

The Normal way to Rename
------------------------

   The normal way to move a file is to copy OLD to NEW, and then issue
the normal CVS commands to remove OLD from the repository, and add NEW
to it.

     $ mv OLD NEW
     $ cvs remove OLD
     $ cvs add NEW
     $ cvs commit -m "Renamed OLD to NEW" OLD NEW

   This is the simplest way to move a file, it is not error-prone, and
it preserves the history of what was done.  Note that to access the
history of the file you must specify the old or the new name, depending
on what portion of the history you are accessing.  For example, `cvs
log OLD' will give the log up until the time of the rename.

   When NEW is committed its revision numbers will start again, usually
at 1.1, so if that bothers you, use the `-r rev' option to commit.  For
more information see *Note Assigning revisions::.


File: cvs.info,  Node: Inside,  Next: Rename by copying,  Prev: Outside,  Up: Moving files

Moving the history file
-----------------------

   This method is more dangerous, since it involves moving files inside
the repository.  Read this entire section before trying it out!

     $ cd $CVSROOT/MODULE
     $ mv OLD,v NEW,v

Advantages:

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:

   * Old releases of the module cannot easily be fetched from the
     repository.  (The file will show up as NEW even in revisions from
     the time before it was renamed).

   * There is no log information of when the file was renamed.

   * Nasty things might happen if someone accesses the history file
     while you are moving it.  Make sure no one else runs any of the CVS
     commands while you move it.
d988 1
a988 4
File: cvs.info,  Node: Rename by copying,  Prev: Inside,  Up: Moving files

Copying the history file
------------------------
d990 2
a991 2
   This way also involves direct modifications to the repository.  It
is safe, but not without drawbacks.
d993 6
a998 14
     # Copy the RCS file inside the repository
     $ cd $CVSROOT/MODULE
     $ cp OLD,v NEW,v
     # Remove the old file
     $ cd ~/MODULE
     $ rm OLD
     $ cvs remove OLD
     $ cvs commit OLD
     # Remove all tags from NEW
     $ cvs update NEW
     $ cvs log NEW             # Remember the non-branch tag names
     $ cvs tag -d TAG1 NEW
     $ cvs tag -d TAG2 NEW
     ...
d1000 5
a1004 2
   By removing the tags you will be able to check out old revisions of
the module.
d1006 4
a1009 1
Advantages:
d1011 2
a1012 8
   * Checking out old revisions works correctly, as long as you use
     `-rTAG' and not `-DDATE' to retrieve the revisions.

   * The log of changes is maintained intact.

   * The revision numbers are not affected.

Disadvantages:
d1014 2
a1015 1
   * You cannot easily see the history of the file across the rename.
d1018 1
a1018 1
File: cvs.info,  Node: Moving directories,  Prev: Moving files,  Up: Adding and removing
d1020 2
a1021 9
Moving and renaming directories
===============================

   The normal way to rename or move a directory is to rename or move
each file within it as described in *Note Outside::.  Then check out
with the `-P' option, as described in *Note Removing directories::.

   If you really want to hack the repository to rename or delete a
directory in the repository, you can do it like this:
d1023 4
a1026 4
  1. Inform everyone who has a copy of the module that the directory
     will be renamed.  They should commit all their changes, and remove
     their working copies of the module, before you take the steps
     below.
d1028 3
a1030 1
  2. Rename the directory inside the repository.
d1032 4
a1035 2
          $ cd $CVSROOT/MODULE
          $ mv OLD-DIR NEW-DIR
d1037 1
a1037 2
  3. Fix the CVS administrative files, if necessary (for instance if
     you renamed an entire module).
d1039 5
a1043 2
  4. Tell everyone that they can check out the module and continue
     working.
d1045 3
d1049 1
a1049 3
   If someone had a working copy of the module the CVS commands will
cease to work for him, until he removes the directory that disappeared
inside the repository.
d1051 1
a1051 4
   It is almost always better to move the files in the directory
instead of moving the directory.  If you move the directory you are
unlikely to be able to retrieve old releases correctly, since they
probably depend on the name of the directories.
d1054 1
a1054 1
File: cvs.info,  Node: History browsing,  Next: Binary files,  Prev: Adding and removing,  Up: Top
d1056 2
a1057 2
History browsing
****************
d1059 5
a1063 3
   Once you have used CVS to store a version control history--what
files have changed when, how, and by whom, there are a variety of
mechanisms for looking through the history.
d1065 2
a1066 1
* Menu:
d1068 2
a1069 4
* log messages::                Log messages
* history database::            The history database
* user-defined logging::        User-defined logging
* annotate::                    What revision modified each line of a file?
d1072 1
a1072 4
File: cvs.info,  Node: log messages,  Next: history database,  Up: History browsing

Log messages
============
d1074 2
a1075 1
   Whenever you commit a file you specify a log message.
d1077 2
a1078 3
   To look through the log messages which have been specified for every
revision which has been committed, use the `cvs log' command (*note
log::.).
d1081 1
a1081 1
File: cvs.info,  Node: history database,  Next: user-defined logging,  Prev: log messages,  Up: History browsing
d1083 2
a1084 6
The history database
====================

   You can use the history file (*note history file::.) to log various
CVS actions.  To retrieve the information from the history file, use
the `cvs history' command (*note history::.).
d1086 8
a1093 5

File: cvs.info,  Node: user-defined logging,  Next: annotate,  Prev: history database,  Up: History browsing

User-defined logging
====================
d1095 5
a1099 21
   You can customize CVS to log various kinds of actions, in whatever
manner you choose.  These mechanisms operate by executing a script at
various times.  The script might append a message to a file listing the
information and the programmer who created it, or send mail to a group
of developers, or, perhaps, post a message to a particular newsgroup.
To log commits, use the `loginfo' file (*note loginfo::.).  To log
commits, checkouts, exports, and tags, respectively, you can also use
the `-i', `-o', `-e', and `-t' options in the modules file.  For a more
flexible way of giving notifications to various users, which requires
less in the way of keeping centralized scripts up to date, use the `cvs
watch add' command (*note Getting Notified::.); this command is useful
even if you are not using `cvs watch on'.

   The `taginfo' file defines programs to execute when someone executes
a `tag' or `rtag' command.  The `taginfo' file has the standard form
for administrative files (*note Administrative files::.), where each
line is a regular expression followed by a command to execute.  The
arguments passed to the command are, in order, the TAGNAME, OPERATION
(`add' for `tag', `mov' for `tag -F', and `del' for `tag -d'),
REPOSITORY, and any remaining are pairs of FILENAME REVISION.  A
non-zero exit of the filter program will cause the tag to be aborted.
d1102 1
a1102 1
File: cvs.info,  Node: annotate,  Prev: user-defined logging,  Up: History browsing
d1104 2
a1105 40
Annotate command
================

 - Command: cvs annotate [`-flR'] [`-r rev'|`-D date'] FILES ...
     For each file in FILES, print the head revision of the trunk,
     together with information on the last modification for each line.
     For example:

          $ cvs annotate ssfile
          Annotations for ssfile
          ***************
          1.1          (mary     27-Mar-96): ssfile line 1
          1.2          (joe      28-Mar-96): ssfile line 2

     The file `ssfile' currently contains two lines.  The `ssfile line
     1' line was checked in by `mary' on March 27.  Then, on March 28,
     `joe' added a line `ssfile line 2', without modifying the `ssfile
     line 1' line.  This report doesn't tell you anything about lines
     which have been deleted or replaced; you need to use `cvs diff'
     for that (*note diff::.).


   The options to `cvs annotate' are listed in *Note Invoking CVS::,
and can be used to select the files and revisions to annotate.  The
options are described in more detail in *Note Common options::.


File: cvs.info,  Node: Binary files,  Next: Multiple developers,  Prev: History browsing,  Up: Top

Handling binary files
*********************

   The most common use for CVS is to store text files.  With text
files, CVS can merge revisions, display the differences between
revisions in a human-visible fashion, and other such operations.
However, if you are willing to give up a few of these abilities, CVS
can store binary files.  For example, one might store a web site in CVS
including both text files and binary images.

* Menu:
d1107 31
a1137 2
* Binary why::     More details on issues with binary files
* Binary howto::   How to store them
d1140 1
a1140 1
File: cvs.info,  Node: Binary why,  Next: Binary howto,  Up: Binary files
d1142 2
a1143 2
The issues with binary files
============================
d1145 4
a1148 132
   While the need to manage binary files may seem obvious if the files
that you customarily work with are binary, putting them into version
control does present some additional issues.

   One basic function of version control is to show the differences
between two revisions.  For example, if someone else checked in a new
version of a file, you may wish to look at what they changed and
determine whether their changes are good.  For text files, CVS provides
this functionality via the `cvs diff' command.  For binary files, it
may be possible to extract the two revisions and then compare them with
a tool external to CVS (for example, word processing software often has
such a feature).  If there is no such tool, one must track changes via
other mechanisms, such as urging people to write good log messages, and
hoping that the changes they actually made were the changes that they
intended to make.

   Another ability of a version control system is the ability to merge
two revisions.  For CVS this happens in two contexts.  The first is
when users make changes in separate working directories (*note Multiple
developers::.).  The second is when one merges explicitly with the
`update -j' command (*note Branching and merging::.).

   In the case of text files, CVS can merge changes made independently,
and signal a conflict if the changes conflict.  With binary files, the
best that CVS can do is present the two different copies of the file,
and leave it to the user to resolve the conflict.  The user may choose
one copy or the other, or may run an external merge tool which knows
about that particular file format, if one exists.  Note that having the
user merge relies primarily on the user to not accidentally omit some
changes, and thus is potentially error prone.

   If this process is thought to be undesirable, the best choice may be
to avoid merging.  To avoid the merges that result from separate
working directories, see the discussion of reserved checkouts (file
locking) in *Note Multiple developers::.  To avoid the merges resulting
from branches, restrict use of branches.


File: cvs.info,  Node: Binary howto,  Prev: Binary why,  Up: Binary files

How to store binary files
=========================

   There are two issues with using CVS to store binary files.  The
first is that CVS by default converts line endings between the
canonical form in which they are stored in the repository (linefeed
only), and the form appropriate to the operating system in use on the
client (for example, carriage return followed by line feed for Windows
NT).

   The second is that a binary file might happen to contain data which
looks like a keyword (*note Keyword substitution::.), so keyword
expansion must be turned off.

   The `-kb' option available with some CVS commands insures that
neither line ending conversion nor keyword expansion will be done.

   Here is an example of how you can create a new file using the `-kb'
flag:

     $ echo '$Id$' > kotest
     $ cvs add -kb -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest

   If a file accidentally gets added without `-kb', one can use the
`cvs admin' command to recover.  For example:

     $ echo '$Id$' > kotest
     $ cvs add -m"A test file" kotest
     $ cvs ci -m"First checkin; contains a keyword" kotest
     $ cvs admin -kb kotest
     $ cvs update -A kotest
     # For non-unix systems:
     # Copy in a good copy of the file from outside CVS
     $ cvs commit -m "make it binary" kotest

   When you check in the file `kotest' the file is not preserved as a
binary file, because you did not check it in as a binary file.  The `cvs
admin -kb' command sets the default keyword substitution method for
this file, but it does not alter the working copy of the file that you
have.  If you need to cope with line endings (that is, you are using
CVS on a non-unix system), then you need to check in a new copy of the
file, as shown by the `cvs commit' command above.  On unix, the `cvs
update -A' command suffices.

   However, in using `cvs admin -k' to change the keyword expansion, be
aware that the keyword expansion mode is not version controlled.  This
means that, for example, that if you have a text file in old releases,
and a binary file with the same name in new releases, CVS provides no
way to check out the file in text or binary mode depending on what
version you are checking out.  There is no good workaround for this
problem.

   You can also set a default for whether `cvs add' and `cvs import'
treat a file as binary based on its name; for example you could say
that files who names end in `.exe' are binary.  *Note Wrappers::.
There is currently no way to have CVS detect whether a file is binary
based on its contents.  The main difficulty with designing such a
feature is that it is not clear how to distinguish between binary and
non-binary files, and the rules to apply would vary considerably with
the operating system.


File: cvs.info,  Node: Multiple developers,  Next: Revision management,  Prev: Binary files,  Up: Top

Multiple developers
*******************

   When more than one person works on a software project things often
get complicated.  Often, two people try to edit the same file
simultaneously.  One solution, known as "file locking" or "reserved
checkouts", is to allow only one person to edit each file at a time.
This is the only solution with some version control systems, including
RCS and SCCS.  Currently the usual way to get reserved checkouts with
CVS is the `cvs admin -l' command (*note admin options::.).  This is
not as nicely integrated into CVS as the watch features, described
below, but it seems that most people with a need for reserved checkouts
find it adequate.  It also may be possible to use the watches features
described below, together with suitable procedures (not enforced by
software), to avoid having two people edit at the same time.

   The default model with CVS is known as "unreserved checkouts".  In
this model, developers can edit their own "working copy" of a file
simultaneously.  The first person that commits his changes has no
automatic way of knowing that another has started to edit it.  Others
will get an error message when they try to commit the file.  They must
then use CVS commands to bring their working copy up to date with the
repository revision.  This process is almost automatic.

   CVS also supports mechanisms which facilitate various kinds of
communcation, without actually enforcing rules like reserved checkouts
do.
d1150 1
a1150 2
   The rest of this chapter describes how these various models work,
and some of the issues involved in choosing between them.
d1154 3
a1156 7
* File status::                 A file can be in several states
* Updating a file::             Bringing a file up-to-date
* Conflicts example::           An informative example
* Informing others::            To cooperate you must inform
* Concurrency::                 Simultaneous repository access
* Watches::                     Mechanisms to track who is editing files
* Choosing a model::            Reserved or unreserved checkouts?
d1159 1
a1159 1
File: cvs.info,  Node: File status,  Next: Updating a file,  Up: Multiple developers
d1161 2
a1162 2
File status
===========
d1164 3
a1166 68
   Based on what operations you have performed on a checked out file,
and what operations others have performed to that file in the
repository, one can classify a file in a number of states.  The states,
as reported by the `status' command, are:

Up-to-date
     The file is identical with the latest revision in the repository
     for the branch in use.

Locally Modified
     You have edited the file, and not yet committed your changes.

Locally Added
     You have added the file with `add', and not yet committed your
     changes.

Locally Removed
     You have removed the file with `remove', and not yet committed
     your changes.

Needs Checkout
     Someone else has committed a newer revision to the repository.
     The name is slightly misleading; you will ordinarily use `update'
     rather than `checkout' to get that newer revision.

Needs Patch
     Like Needs Checkout, but the CVS server will send a patch rather
     than the entire file.  Sending a patch or sending an entire file
     accomplishes the same thing.

Needs Merge
     Someone else has committed a newer revision to the repository, and
     you have also made modifications to the file.

File had conflicts on merge
     This is like Locally Modified, except that a previous `update'
     command gave a conflict.  If you have not already done so, you
     need to resolve the conflict as described in *Note Conflicts
     example::.

Unknown
     CVS doesn't know anything about this file.  For example, you have
     created a new file and have not run `add'.

   To help clarify the file status, `status' also reports the `Working
revision' which is the revision that the file in the working directory
derives from, and the `Repository revision' which is the latest
revision in the repository for the branch in use.

   The options to `status' are listed in *Note Invoking CVS::.  For
information on its `Sticky tag' and `Sticky date' output, see *Note
Sticky tags::.  For information on its `Sticky options' output, see the
`-k' option in *Note update options::.

   You can think of the `status' and `update' commands as somewhat
complementary.  You use `update' to bring your files up to date, and you
can use `status' to give you some idea of what an `update' would do (of
course, the state of the repository might change before you actually run
`update').  In fact, if you want a command to display file status in a
more brief format than is displayed by the `status' command, you can
invoke

     $ cvs -n -q update

   The `-n' option means to not actually do the update, but merely to
display statuses; the `-q' option avoids printing the name of each
directory.  For more information on the `update' command, and these
options, see *Note Invoking CVS::.
d1168 4
a1171 2

File: cvs.info,  Node: Updating a file,  Next: Conflicts example,  Prev: File status,  Up: Multiple developers
d1173 5
a1177 2
Bringing a file up to date
==========================
d1179 3
a1181 21
   When you want to update or merge a file, use the `update' command.
For files that are not up to date this is roughly equivalent to a
`checkout' command: the newest revision of the file is extracted from
the repository and put in your working copy of the module.

   Your modifications to a file are never lost when you use `update'.
If no newer revision exists, running `update' has no effect.  If you
have edited the file, and a newer revision is available, CVS will merge
all changes into your working copy.

   For instance, imagine that you checked out revision 1.4 and started
editing it.  In the meantime someone else committed revision 1.5, and
shortly after that revision 1.6.  If you run `update' on the file now,
CVS will incorporate all changes between revision 1.4 and 1.6 into your
file.

   If any of the changes between 1.4 and 1.6 were made too close to any
of the changes you have made, an "overlap" occurs.  In such cases a
warning is printed, and the resulting file includes both versions of
the lines that overlap, delimited by special markers.  *Note update::,
for a complete description of the `update' command.
d1184 1
a1184 1
File: cvs.info,  Node: Conflicts example,  Next: Informing others,  Prev: Updating a file,  Up: Multiple developers
d1186 2
a1187 2
Conflicts example
=================
d1189 2
a1190 1
   Suppose revision 1.4 of `driver.c' contains this:
d1192 2
a1193 11
     #include <stdio.h>
     
     void main()
     {
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? 0 : 1);
     }
d1195 1
a1195 1
Revision 1.6 of `driver.c' contains this:
d1197 1
a1197 17
     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(!!nerr);
     }
d1199 1
a1199 2
Your working copy of `driver.c', based on revision 1.4, contains this
before you run `cvs update':
d1201 1
a1201 28
     #include <stdlib.h>
     #include <stdio.h>
     
     void main()
     {
         init_scanner();
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

You run `cvs update':

     $ cvs update driver.c
     RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
     retrieving revision 1.4
     retrieving revision 1.6
     Merging differences between 1.4 and 1.6 into driver.c
     rcsmerge warning: overlaps during merge
     cvs update: conflicts found in driver.c
     C driver.c

CVS tells you that there were some conflicts.  Your original working
file is saved unmodified in `.#driver.c.1.4'.  The new version of
`driver.c' contains this:
d1203 3
a1205 49
     #include <stdlib.h>
     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
     <<<<<<< driver.c
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     =======
         exit(!!nerr);
     >>>>>>> 1.6
     }

Note how all non-overlapping modifications are incorporated in your
working copy, and that the overlapping section is clearly marked with
`<<<<<<<', `=======' and `>>>>>>>'.

   You resolve the conflict by editing the file, removing the markers
and the erroneous line.  Suppose you end up with this file:
     #include <stdlib.h>
     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }
d1207 1
a1207 1
You can now go ahead and commit this as revision 1.7.
d1209 3
a1211 18
     $ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7; previous revision: 1.6
     done

   For your protection, CVS will refuse to check in a file if a
conflict occurred and you have not resolved the conflict.  Currently to
resolve a conflict, you must change the timestamp on the file.  In
previous versions of CVS, you also needed to insure that the file
contains no conflict markers.  Because your file may legitimately
contain conflict markers (that is, occurrences of `>>>>>>> ' at the
start of a line that don't mark a conflict), the current version of CVS
will print a warning and proceed to check in the file.

   If you use release 1.04 or later of pcl-cvs (a GNU Emacs front-end
for CVS) you can use an Emacs package called emerge to help you resolve
conflicts.  See the documentation for pcl-cvs.
@


1.1.1.12
log
@Latest version from Cyclic; files missed in first run
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo version 1.67 from the
input file ../../work/ccvs/doc/cvs.texinfo.
a862 11

   Here is an example of using taginfo to log tag and rtag commands.
In the taginfo file put:

     ALL /usr/local/cvsroot/CVSROOT/loggit

   Where `/usr/local/cvsroot/CVSROOT/loggit' contains the following
script:

     #!/bin/sh
     echo "$@@" >>/home/kingdon/cvsroot/CVSROOT/taglog
@


1.1.1.13
log
@Latest version from Cyclic; skipped files
@
text
@a3 4
START-INFO-DIR-ENTRY
* CVS: (cvs).          Concurrent Versions System
END-INFO-DIR-ENTRY

d13 4
a16 2
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.
d20 3
a22 2
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
d33 1
a33 1
     $ cvs tag -b rel-1-0-patches
d36 1
a36 1
working copy, assigning that branch the name `rel-1-0-patches'.
d47 1
a47 1
     $ cvs rtag -b -r rel-1-0 rel-1-0-patches tc
d49 5
a53 5
   `-r rel-1-0' says that this branch should be rooted at the revision
that corresponds to the tag `rel-1-0'.  It need not be the most recent
revision - it's often useful to split a branch off an old revision (for
example, when fixing a bug in a past release otherwise known to be
stable).
d57 2
a58 2
number that matches `rel-1-0' will probably be different from file to
file.
d61 2
a62 2
`rel-1-0-patches' - in module `tc', rooted in the revision tree at the
point tagged by `rel-1-0'.
d78 1
a78 1
     $ cvs checkout -r rel-1-0-patches tc
d83 1
a83 1
     $ cvs update -r rel-1-0-patches tc
d88 1
a88 1
     $ cvs update -r rel-1-0-patches
d112 1
a112 1
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
d117 2
a118 2
             rel-1-0-patches             (branch: 1.7.2)
             rel-1-0                     (revision: 1.7)
d125 1
a125 1
         Sticky Tag:         rel-1-0-patches (branch: 1.4.2)
d130 3
a132 3
             rel-1-0-patches             (branch: 1.4.2)
             rel-1-0                     (revision: 1.4)
             rel-0-4                     (revision: 1.4)
d136 5
a140 5
same, `rel-1-0-patches', and the files are indeed on the same branch.
The numbers simply reflect the point in each file's revision history at
which the branch was made.  In the above example, one can deduce that
`driver.c' had been through more changes than `backend.c' before this
branch was created.
@


1.1.1.14
log
@Latest version from Cyclic; skipped files
@
text
@d2 1
a2 1
input file ./cvs.texinfo.
@


1.1.1.15
log
@Latest version from Cyclic; skipped files
@
text
@d2 1
a2 1
input file ../../work/ccvs/doc/cvs.texinfo.
a25 228
File: cvs.info,  Node: Tagging by date/tag,  Next: Modifying tags,  Prev: Tagging the working directory,  Up: Revisions

Specifying what to tag by date or revision
==========================================

   The `cvs rtag' command tags the repository as of a certain date or
time (or can be used to tag the latest revision).  `rtag' works
directly on the repository contents (it requires no prior checkout and
does not look for a working directory).

   The following options specify which date or revision to tag.  See
*Note Common options::, for a complete description of them.

`-D DATE'
     Tag the most recent revision no later than DATE.

`-f'
     Only useful with the `-D DATE' or `-r TAG' flags.  If no matching
     revision is found, use the most recent revision (instead of
     ignoring the file).

`-r TAG'
     Only tag those files that contain existing tag TAG.

   The `cvs tag' command also allows one to specify files by revision
or date, using the same `-r', `-D', and `-f' options.  However, this
feature is probably not what you want.  The reason is that `cvs tag'
chooses which files to tag based on the files that exist in the working
directory, rather than the files which existed as of the given tag/date.
Therefore, you are generally better off using `cvs rtag'.  The
exceptions might be cases like:

     cvs tag -r 1.4 backend.c


File: cvs.info,  Node: Modifying tags,  Next: Tagging add/remove,  Prev: Tagging by date/tag,  Up: Revisions

Deleting, moving, and renaming tags
===================================

   Normally one does not modify tags.  They exist in order to record
the history of the repository and so deleting them or changing their
meaning would, generally, not be what you want.

   However, there might be cases in which one uses a tag temporarily or
accidentally puts one in the wrong place.  Therefore, one might delete,
move, or rename a tag.  Warning: the commands in this section are
dangerous; they permanently discard historical information and it can
difficult or impossible to recover from errors.  If you are a CVS
administrator, you may consider restricting these commands with taginfo
(*note user-defined logging::.).

   To delete a tag, specify the `-d' option to either `cvs tag' or `cvs
rtag'.  For example:

     cvs rtag -d rel-0-4 tc

   deletes the tag `rel-0-4' from the module `tc'.

   When we say "move" a tag, we mean to make the same name point to
different revisions.  For example, the `stable' tag may currently point
to revision 1.4 of `backend.c' and perhaps we want to make it point to
revision 1.6.  To move a tag, specify the `-F' option to either `cvs
tag' or `cvs rtag'.  For example, the task just mentioned might be
accomplished as:

     cvs tag -r 1.6 -F stable backend.c

   When we say "rename" a tag, we mean to make a different name point
to the same revisions as the old tag.  For example, one may have
misspelled the tag name and want to correct it (hopefully before others
are relying on the old spelling).  To rename a tag, first create a new
tag using the `-r' option to `cvs rtag', and then delete the old name.
This leaves the new tag on exactly the same files as the old tag.  For
example:

     cvs rtag -r old-name-0-4 rel-0-4 tc
     cvs rtag -d old-name-0-4 tc


File: cvs.info,  Node: Tagging add/remove,  Next: Sticky tags,  Prev: Modifying tags,  Up: Revisions

Tagging and adding and removing files
=====================================

   The subject of exactly how tagging interacts with adding and
removing files is somewhat obscure; for the most part CVS will keep
track of whether files exist or not without too much fussing.  By
default, tags are applied to only files which have a revision
corresponding to what is being tagged.  Files which did not exist yet,
or which were already removed, simply omit the tag, and CVS knows to
treat the absence of a tag as meaning that the file didn't exist as of
that tag.

   However, this can lose a small amount of information.  For example,
suppose a file was added and then removed.  Then, if the tag is missing
for that file, there is no way to know whether the tag refers to the
time before the file was added, or the time after it was removed.  If
you specify the `-r' option to `cvs rtag', then CVS tags the files
which have been removed, and thereby avoids this problem.  For example,
one might specify `-r HEAD' to tag the head.

   On the subject of adding and removing files, the `cvs rtag' command
has a `-a' option which means to clear the tag from removed files that
would not otherwise be tagged.  For example, one might specify this
option in conjunction with `-F' when moving a tag.  If one moved a tag
without `-a', then the tag in the removed files might still refer to
the old revision, rather than reflecting the fact that the file had
been removed.  I don't think this is necessary if `-r' is specified, as
noted above.


File: cvs.info,  Node: Sticky tags,  Prev: Tagging add/remove,  Up: Revisions

Sticky tags
===========

   Sometimes a working copy's revision has extra data associated with
it, for example it might be on a branch (*note Branching and
merging::.), or restricted to versions prior to a certain date by
`checkout -D' or `update -D'.  Because this data persists - that is, it
applies to subsequent commands in the working copy - we refer to it as
"sticky".

   Most of the time, stickiness is an obscure aspect of CVS that you
don't need to think about.  However, even if you don't want to use the
feature, you may need to know *something* about sticky tags (for
example, how to avoid them!).

   You can use the `status' command to see if any sticky tags or dates
are set:

     $ cvs status driver.c
     ===================================================================
     File: driver.c          Status: Up-to-date
     
         Version:            1.7.2.1 Sat Dec  5 19:35:03 1992
         RCS Version:        1.7.2.1 /u/cvsroot/yoyodyne/tc/driver.c,v
         Sticky Tag:         rel-1-0-patches (branch: 1.7.2)
         Sticky Date:        (none)
         Sticky Options:     (none)

   The sticky tags will remain on your working files until you delete
them with `cvs update -A'.  The `-A' option retrieves the version of
the file from the head of the trunk, and forgets any sticky tags,
dates, or options.

   The most common use of sticky tags is to identify which branch one
is working on, as described in *Note Accessing branches::.  However,
non-branch sticky tags have uses as well.  For example, suppose that
you want to avoid updating your working directory, to isolate yourself
from possibly destabilizing changes other people are making.  You can,
of course, just refrain from running `cvs update'.  But if you want to
avoid updating only a portion of a larger tree, then sticky tags can
help.  If you check out a certain revision (such as 1.4) it will become
sticky.  Subsequent `cvs update' commands will not retrieve the latest
revision until you reset the tag with `cvs update -A'.  Likewise, use
of the `-D' option to `update' or `checkout' sets a "sticky date",
which, similarly, causes that date to be used for future retrievals.

   People often want to retrieve an old version of a file without
setting a sticky tag.  This can be done with the `-p' option to
`checkout' or `update', which sends the contents of the file to
standard output.  For example:
     $ cvs update -p -r 1.1 file1 >file1
     ===================================================================
     Checking out file1
     RCS:  /tmp/cvs-sanity/cvsroot/first-dir/Attic/file1,v
     VERS: 1.1
     ***************
     $

   However, this isn't the easiest way, if you are asking how to undo a
previous checkin (in this example, put `file1' back to the way it was
as of revision 1.1).  In that case you are better off using the `-j'
option to `update'; for further discussion see *Note Merging two
revisions::.


File: cvs.info,  Node: Branching and merging,  Next: Recursive behavior,  Prev: Revisions,  Up: Top

Branching and merging
*********************

   CVS allows you to isolate changes onto a separate line of
development, known as a "branch".  When you change files on a branch,
those changes do not appear on the main trunk or other branches.

   Later you can move changes from one branch to another branch (or the
main trunk) by "merging".  Merging involves first running `cvs update
-j', to merge the changes into the working directory.  You can then
commit that revision, and thus effectively copy the changes onto
another branch.

* Menu:

* Branches motivation::         What branches are good for
* Creating a branch::           Creating a branch
* Accessing branches::          Checking out and updating branches
* Branches and revisions::      Branches are reflected in revision numbers
* Magic branch numbers::        Magic branch numbers
* Merging a branch::            Merging an entire branch
* Merging more than once::      Merging from a branch several times
* Merging two revisions::       Merging differences between two revisions
* Merging adds and removals::   What if files are added or removed?


File: cvs.info,  Node: Branches motivation,  Next: Creating a branch,  Up: Branching and merging

What branches are good for
==========================

   Suppose that release 1.0 of tc has been made.  You are continuing to
develop tc, planning to create release 1.1 in a couple of months.
After a while your customers start to complain about a fatal bug.  You
check out release 1.0 (*note Tags::.) and find the bug (which turns out
to have a trivial fix).  However, the current revision of the sources
are in a state of flux and are not expected to be stable for at least
another month.  There is no way to make a bugfix release based on the
newest sources.

   The thing to do in a situation like this is to create a "branch" on
the revision trees for all the files that make up release 1.0 of tc.
You can then make modifications to the branch without disturbing the
main trunk.  When the modifications are finished you can elect to
either incorporate them on the main trunk, or leave them on the branch.


d174 5
a178 5
                                                           +-------------+
                                Branch 1.2.2.3.2 ->        ! 1.2.2.3.2.1 !
                                                         / +-------------+
                                                        /
                                                       /
d353 1
a353 1
will undo all changes made between revision 1.3 and 1.5.  Note the
d358 3
a360 17
between the various files.  You almost always use symbolic tags rather
than revision numbers when operating on multiple files.

   Specifying two `-j' options can also undo file removals or
additions.  For example, suppose you have a file named `file1' which
existed as revision 1.1, and you then removed it (thus adding a dead
revision 1.2).  Now suppose you want to add it again, with the same
contents it had previously.  Here is how to do it:

     $ cvs update -j 1.2 -j 1.1 file1
     U file1
     $ cvs commit -m test
     Checking in file1;
     /tmp/cvs-sanity/cvsroot/first-dir/file1,v  <--  file1
     new revision: 1.3; previous revision: 1.2
     done
     $
d429 1
a429 1
     directory
d534 1
a534 1
   Directories change.  New files are added, and old files disappear.
d698 1
a698 1
     $ cd $CVSROOT/DIR
d709 3
a711 3
   * Old releases cannot easily be fetched from the repository.  (The
     file will show up as NEW even in revisions from the time before it
     was renamed).
d729 1
a729 1
     $ cd $CVSROOT/DIR
d732 1
a732 1
     $ cd ~/DIR
d743 2
a744 1
   By removing the tags you will be able to check out old revisions.
d772 4
a775 4
  1. Inform everyone who has a checked out copy of the directory that
     the directory will be renamed.  They should commit all their
     changes, and remove their working copies, before you take the
     steps below.
d779 1
a779 1
          $ cd $CVSROOT/PARENT-DIR
d785 2
a786 1
  4. Tell everyone that they can check out again and continue working.
d789 3
a791 3
   If someone had a working copy the CVS commands will cease to work
for him, until he removes the directory that disappeared inside the
repository.
d965 355
@


1.1.1.16
log
@Latest version from Cyclic; skipped files
@
text
@d1 2
a2 1
This is cvs.info, produced by Makeinfo version 3.12f from ./cvs.texinfo.
a25 157
File: cvs.info,  Node: Tags,  Next: Tagging the working directory,  Prev: Assigning revisions,  Up: Revisions

Tags-Symbolic revisions
=======================

   The revision numbers live a life of their own.  They need not have
anything at all to do with the release numbers of your software
product.  Depending on how you use CVS the revision numbers might
change several times between two releases.  As an example, some of the
source files that make up RCS 5.6 have the following revision numbers:

     ci.c            5.21
     co.c            5.9
     ident.c         5.3
     rcs.c           5.12
     rcsbase.h       5.11
     rcsdiff.c       5.10
     rcsedit.c       5.11
     rcsfcmp.c       5.9
     rcsgen.c        5.10
     rcslex.c        5.11
     rcsmap.c        5.2
     rcsutil.c       5.10

   You can use the `tag' command to give a symbolic name to a certain
revision of a file.  You can use the `-v' flag to the `status' command
to see all tags that a file has, and which revision numbers they
represent.  Tag names must start with an uppercase or lowercase letter
and can contain uppercase and lowercase letters, digits, `-', and `_'.
The two tag names `BASE' and `HEAD' are reserved for use by CVS.  It is
expected that future names which are special to CVS will be specially
named, for example by starting with `.', rather than being named
analogously to `BASE' and `HEAD', to avoid conflicts with actual tag
names.

   You'll want to choose some convention for naming tags, based on
information such as the name of the program and the version number of
the release.  For example, one might take the name of the program,
immediately followed by the version number with `.' changed to `-', so
that CVS 1.9 would be tagged with the name `cvs1-9'.  If you choose a
consistent convention, then you won't constantly be guessing whether a
tag is `cvs-1-9' or `cvs1_9' or what.  You might even want to consider
enforcing your convention in the taginfo file (*note user-defined
logging::.).

   The following example shows how you can add a tag to a file.  The
commands must be issued inside your working directory.  That is, you
should issue the command in the directory where `backend.c' resides.

     $ cvs tag rel-0-4 backend.c
     T backend.c
     $ cvs status -v backend.c
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /u/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         (none)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             rel-0-4                     (revision: 1.4)

   For a complete summary of the syntax of `cvs tag', including the
various options, see *Note Invoking CVS::.

   There is seldom reason to tag a file in isolation.  A more common
use is to tag all the files that constitute a module with the same tag
at strategic points in the development life-cycle, such as when a
release is made.

     $ cvs tag rel-1-0 .
     cvs tag: Tagging .
     T Makefile
     T backend.c
     T driver.c
     T frontend.c
     T parser.c

   (When you give CVS a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  *Note Recursive behavior::.)

   The `checkout' command has a flag, `-r', that lets you check out a
certain revision of a module.  This flag makes it easy to retrieve the
sources that make up release 1.0 of the module `tc' at any time in the
future:

     $ cvs checkout -r rel-1-0 tc

This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.

   You can also check out a module as it was at any given date.  *Note
checkout options::.  When specifying `-r' to any of these commands, you
will need beware of sticky tags; see *Note Sticky tags::.

   When you tag more than one file with the same tag you can think
about the tag as "a curve drawn through a matrix of filename vs.
revision number."  Say we have 5 files with the following revisions:

             file1   file2   file3   file4   file5
     
             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6

   At some time in the past, the `*' versions were tagged.  You can
think of the tag as a handle attached to the curve drawn through the
tagged revisions.  When you pull on the handle, you get all the tagged
revisions.  Another way to look at it is that you "sight" through a set
of revisions that is "flat" along the tagged revisions, like this:

             file1   file2   file3   file4   file5
     
                             1.1
                             1.2
                     1.1     1.3                       _
             1.1     1.2     1.4     1.1              /
             1.2*----1.3*----1.5*----1.2*----1.1     (--- <--- Look here
             1.3             1.6     1.3              \_
             1.4                     1.4
                                     1.5


File: cvs.info,  Node: Tagging the working directory,  Next: Tagging by date/tag,  Prev: Tags,  Up: Revisions

Specifying what to tag from the working directory
=================================================

   The example in the previous section demonstrates one of the most
common ways to choose which revisions to tag.  Namely, running the `cvs
tag' command without arguments causes CVS to select the revisions which
are checked out in the current working directory.  For example, if the
copy of `backend.c' in working directory was checked out from revision
1.4, then CVS will tag revision 1.4.  Note that the tag is applied
immediately to revision 1.4 in the repository; tagging is not like
modifying a file, or other operations in which one first modifies the
working directory and then runs `cvs commit' to transfer that
modification to the repository.

   One potentially surprising aspect of the fact that `cvs tag'
operates on the repository is that you are tagging the checked-in
revisions, which may differ from locally modified files in your working
directory.  If you want to avoid doing this by mistake, specify the
`-c' option to `cvs tag'.  If there are any locally modified files, CVS
will abort with an error before it tags any files:

     $ cvs tag -c rel-0-4
     cvs tag: backend.c is locally modified
     cvs [tag aborted]: correct the above errors first!


d152 1
a152 1
feature, you may need to know _something_ about sticky tags (for
a230 1
* Merging and keywords::        Avoiding conflicts due to keyword substitution
d269 1
a269 1
current revisions, as the above example does, will _not_ automatically
d332 1
a332 1
(*note Sticky tags::.)  - that's CVS's way of telling you the branch, if
a453 1

a506 5
   If your source files contain keywords (*note Keyword
substitution::.), you might be getting more conflicts than strictly
necessary.  See *Note Merging and keywords::, for information on how to
avoid this.

d605 1
a605 1
File: cvs.info,  Node: Merging adds and removals,  Next: Merging and keywords,  Prev: Merging two revisions,  Up: Branching and merging
a628 81
File: cvs.info,  Node: Merging and keywords,  Prev: Merging adds and removals,  Up: Branching and merging

Merging and keywords
====================

   If you merge files containing keywords (*note Keyword
substitution::.), you will normally get numerous conflicts during the
merge, because the keywords are expanded differently in the revisions
which you are merging.

   Therefore, you will often want to specify the `-kk' (*note
Substitution modes::.) switch to the merge command line.  By
substituting just the name of the keyword, not the expanded value of
that keyword, this option ensures that the revisions which you are
merging will be the same as each other, and avoid spurious conflicts.

   For example, suppose you have a file like this:

            +---------+
           _! 1.1.2.1 !   <-  br1
          / +---------+
         /
        /
     +-----+    +-----+
     ! 1.1 !----! 1.2 !
     +-----+    +-----+

   and your working directory is currently on the trunk (revision 1.2).
Then you might get the following results from a merge:

     $ cat file1
     key $Revision: 1.2 $
     . . .
     $ cvs update -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     rcsmerge: warning: conflicts during merge
     $ cat file1
     <<<<<<< file1
     key $Revision: 1.2 $
     =======
     key $Revision: 1.1.2.1 $
     >>>>>>> 1.1.2.1
     . . .

   What happened was that the merge tried to merge the differences
between 1.1 and 1.1.2.1 into your working directory.  So, since the
keyword changed from `Revision: 1.1' to `Revision: 1.1.2.1', CVS tried
to merge that change into your working directory, which conflicted with
the fact that your working directory had contained `Revision: 1.2'.

   Here is what happens if you had used `-kk':

     $ cat file1
     key $Revision: 1.2 $
     . . .
     $ cvs update -kk -j br1
     U file1
     RCS file: /cvsroot/first-dir/file1,v
     retrieving revision 1.1
     retrieving revision 1.1.2.1
     Merging differences between 1.1 and 1.1.2.1 into file1
     $ cat file1
     key $Revision$
     . . .

   What is going on here is that revision 1.1 and 1.1.2.1 both expand
as plain `Revision', and therefore merging the changes between them
into the working directory need not change anything.  Therefore, there
is no conflict.

   There is, however, one major caveat with using `-kk' on merges.
Namely, it overrides whatever keyword expansion mode CVS would normally
have used.  In particular, this is a problem if the mode had been `-kb'
for a binary file.  Therefore, if your repository contains binary
files, you will need to deal with the conflicts rather than using `-kk'.


d734 1
a734 1
 - Command: cvs add [`-k' kflag] [`-m' message] files ...
d804 1
a804 1
 - Command: cvs remove [options] files ...
d1000 205
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d1 1
a1 1
This is cvs.info, produced by makeinfo version 4.0 from ./cvs.texinfo.
d68 1
a68 1
logging::).
d232 1
a232 1
(*note user-defined logging::).
d301 1
a301 1
merging::), or restricted to versions prior to a certain date by
d398 1
a398 1
check out release 1.0 (*note Tags::) and find the bug (which turns out
d462 1
a462 1
branch::):
d489 1
a489 1
(*note Sticky tags::) - that's CVS's way of telling you the branch, if
d538 1
a538 1
increments (*note Revision numbers::):
d584 1
a584 1
numbers::).  The branch 1.1.1 has a special meaning.  *Note Tracking
d665 4
a668 3
   If your source files contain keywords (*note Keyword substitution::),
you might be getting more conflicts than strictly necessary.  See *Note
Merging and keywords::, for information on how to avoid this.
d798 1
a798 1
substitution::), you will normally get numerous conflicts during the
d803 1
a803 1
Substitution modes::) switch to the merge command line.  By
d924 1
a924 1
recursion if `-l' is specified in `~/.cvsrc' (*note ~/.cvsrc::).
d964 1
a964 1
     (*note Binary files::).
d996 1
a996 1
     history file::).  It will also be saved in the version history
d1010 1
a1010 1
working on (*note Branching and merging::).  You can later merge the
d1012 1
a1012 1
removals::).
d1103 1
a1103 1
are working on (*note Branching and merging::).  You can later merge
d1105 1
a1105 1
removals::).
d1120 10
a1129 11
Instead you specify the `-P' option to `cvs update' or `cvs checkout',
which will cause CVS to remove empty directories from working
directories.  (Note that `cvs export' always removes empty directories.)
Probably the best way to do this is to always specify `-P'; if you want
an empty directory then put a dummy file (for example `.keepme') in it
to prevent `-P' from removing it.

   Note that `-P' is implied by the `-r' or `-D' options of `checkout'.
This way CVS will be able to correctly create the directory or not
depending on whether the particular version you are checking out
contains any files in that directory.
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@d1 1
a1 1
This is cvs.info, produced by makeinfo version 4.0 from cvs.texinfo.
d630 4
a633 4
giving the `-j BRANCHNAME' flag to the `update' subcommand.  With one
`-j BRANCHNAME' option it merges the changes made between the point
where the branch forked and newest revision on that branch (into your
working copy).
d669 2
a670 2
   The `checkout' command also supports the `-j BRANCHNAME' flag.  The
same effect as above could be achieved with this:
a674 4
   It should be noted that `update -j TAGNAME' will also work but may
not produce the desired result.  *Note Merging adds and removals::, for
more.

a788 9

   Note that using a single static tag (`-j TAGNAME') rather than a
dynamic tag (`-j BRANCHNAME') to merge changes from a branch will
usually not remove files which were removed on the branch since CVS
does not automatically add static tags to dead revisions.  The
exception to this rule occurs when a static tag has been attached to a
dead revision manually.  Use the branch tag to merge all changes from
the branch or use two static tags as merge endpoints to be sure that
all intended changes are propogated in the merge.
@


