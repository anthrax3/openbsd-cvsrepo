head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.18.0.66
	OPENBSD_6_1_BASE:1.1.1.18
	OPENBSD_6_0:1.1.1.18.0.62
	OPENBSD_6_0_BASE:1.1.1.18
	OPENBSD_5_9:1.1.1.18.0.58
	OPENBSD_5_9_BASE:1.1.1.18
	OPENBSD_5_8:1.1.1.18.0.60
	OPENBSD_5_8_BASE:1.1.1.18
	OPENBSD_5_7:1.1.1.18.0.52
	OPENBSD_5_7_BASE:1.1.1.18
	OPENBSD_5_6:1.1.1.18.0.56
	OPENBSD_5_6_BASE:1.1.1.18
	OPENBSD_5_5:1.1.1.18.0.54
	OPENBSD_5_5_BASE:1.1.1.18
	OPENBSD_5_4:1.1.1.18.0.50
	OPENBSD_5_4_BASE:1.1.1.18
	OPENBSD_5_3:1.1.1.18.0.48
	OPENBSD_5_3_BASE:1.1.1.18
	OPENBSD_5_2:1.1.1.18.0.46
	OPENBSD_5_2_BASE:1.1.1.18
	OPENBSD_5_1_BASE:1.1.1.18
	OPENBSD_5_1:1.1.1.18.0.44
	OPENBSD_5_0:1.1.1.18.0.42
	OPENBSD_5_0_BASE:1.1.1.18
	OPENBSD_4_9:1.1.1.18.0.40
	OPENBSD_4_9_BASE:1.1.1.18
	OPENBSD_4_8:1.1.1.18.0.38
	OPENBSD_4_8_BASE:1.1.1.18
	OPENBSD_4_7:1.1.1.18.0.34
	OPENBSD_4_7_BASE:1.1.1.18
	OPENBSD_4_6:1.1.1.18.0.36
	OPENBSD_4_6_BASE:1.1.1.18
	OPENBSD_4_5:1.1.1.18.0.32
	OPENBSD_4_5_BASE:1.1.1.18
	OPENBSD_4_4:1.1.1.18.0.30
	OPENBSD_4_4_BASE:1.1.1.18
	OPENBSD_4_3:1.1.1.18.0.28
	OPENBSD_4_3_BASE:1.1.1.18
	OPENBSD_4_2:1.1.1.18.0.26
	OPENBSD_4_2_BASE:1.1.1.18
	OPENBSD_4_1:1.1.1.18.0.24
	OPENBSD_4_1_BASE:1.1.1.18
	OPENBSD_4_0:1.1.1.18.0.22
	OPENBSD_4_0_BASE:1.1.1.18
	OPENBSD_3_9:1.1.1.18.0.20
	OPENBSD_3_9_BASE:1.1.1.18
	OPENBSD_3_8:1.1.1.18.0.18
	OPENBSD_3_8_BASE:1.1.1.18
	OPENBSD_3_7:1.1.1.18.0.16
	OPENBSD_3_7_BASE:1.1.1.18
	OPENBSD_3_6:1.1.1.18.0.14
	OPENBSD_3_6_BASE:1.1.1.18
	OPENBSD_3_5:1.1.1.18.0.12
	OPENBSD_3_5_BASE:1.1.1.18
	OPENBSD_3_4:1.1.1.18.0.10
	OPENBSD_3_4_BASE:1.1.1.18
	OPENBSD_3_3:1.1.1.18.0.8
	OPENBSD_3_3_BASE:1.1.1.18
	OPENBSD_3_2:1.1.1.18.0.6
	OPENBSD_3_2_BASE:1.1.1.18
	OPENBSD_3_1:1.1.1.18.0.4
	OPENBSD_3_1_BASE:1.1.1.18
	OPENBSD_3_0:1.1.1.18.0.2
	OPENBSD_3_0_BASE:1.1.1.18
	cvs-1-11-1p1:1.1.1.18
	OPENBSD_2_9:1.1.1.17.0.2
	OPENBSD_2_9_BASE:1.1.1.17
	cvs-1-11:1.1.1.17
	OPENBSD_2_8:1.1.1.16.0.6
	OPENBSD_2_8_BASE:1.1.1.16
	OPENBSD_2_7:1.1.1.16.0.4
	OPENBSD_2_7_BASE:1.1.1.16
	OPENBSD_2_6:1.1.1.16.0.2
	OPENBSD_2_6_BASE:1.1.1.16
	cvs-1-10-7:1.1.1.16
	OPENBSD_2_5:1.1.1.15.0.2
	OPENBSD_2_5_BASE:1.1.1.15
	cvs-1-10-5:1.1.1.15
	OPENBSD_2_4:1.1.1.14.0.2
	OPENBSD_2_4_BASE:1.1.1.14
	cvs-1-10:1.1.1.14
	cvs-1-9-28:1.1.1.13
	OPENBSD_2_3:1.1.1.12.0.2
	OPENBSD_2_3_BASE:1.1.1.12
	cvs-1-9-26:1.1.1.12
	cvs-1-9-24:1.1.1.11
	OPENBSD_2_2:1.1.1.10.0.2
	OPENBSD_2_2_BASE:1.1.1.10
	cvs-1-9-10:1.1.1.10
	OPENBSD_2_1:1.1.1.9.0.2
	OPENBSD_2_1_BASE:1.1.1.9
	cvs-1-9-8:1.1.1.9
	cvs-1-9-6:1.1.1.8
	cvs-1-9-4:1.1.1.7
	cvs-1-9-2:1.1.1.6
	cvs-1-9:1.1.1.5
	OPENBSD_2_0:1.1.1.4.0.2
	OPENBSD_2_0_BASE:1.1.1.4
	cvs-1-8-1:1.1.1.4
	cvs-1-8:1.1.1.4
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	95.12.19.09.21.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.38;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.41.26;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.20.02.40;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.05.06.22.27.12;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	96.10.18.03.41.37;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.02.21.06.47.22;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.03.18.02.05.51;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.03.29.04.45.57;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.04.21.04.34.08;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.06.28.03.35.13;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	98.02.22.08.30.44;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.03.12.07.05.50;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.07.13.04.04.44;	author tholo;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.08.22.20.57.29;	author tholo;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	99.02.28.21.39.58;	author tholo;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	99.09.10.05.14.49;	author tholo;	state Exp;
branches;
next	1.1.1.17;

1.1.1.17
date	2001.02.10.19.03.13;	author tholo;	state Exp;
branches;
next	1.1.1.18;

1.1.1.18
date	2001.09.28.22.48.51;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@This is Info file cvs.info, produced by Makeinfo-1.55 from the input
file ./cvs.texinfo.

   Copyright (C) 1992, 1993 Signum Support AB Copyright (C) 1993, 1994
Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
and this permission notice may be included in translations approved by
the Free Software Foundation instead of in the original English.


File: cvs.info,  Node: Top,  Next: Preface,  Prev: (DIR),  Up: (DIR)



   This info manual describes CVS and is updated to release 1.4 or
something similar.

* Menu:

* Preface::                     About this manual
* What is CVS?::                What is CVS?
* Basic concepts::              Basic concepts of revision management
* A sample session::            A tour of basic CVS usage
* Repository::                  Where all your sources are stored
* Starting a new project::      Starting a project with CVS
* Multiple developers::         How CVS helps a group of developers
* Branches::                    Parallel development explained
* Merging::                     How to move changes between branches
* Recursive behavior::          CVS descends directories
* Adding files::                Adding files to a module
* Removing files::              Removing files from a module
* Tracking sources::            Tracking third-party sources
* Moving files::                Moving and renaming files
* Moving directories::          Moving and renaming directories
* Keyword substitution::        CVS can include the revision inside the file
* Revision management::         Policy questions for revision management
* Invoking CVS::                Reference manual for CVS commands
* Administrative files::        Reference manual for the Administrative files
* Environment variables::       All environment variables which affect CVS
* Troubleshooting::             Some tips when nothing works
* Copying::                     GNU GENERAL PUBLIC LICENSE
* Index::                       Index


File: cvs.info,  Node: Preface,  Next: What is CVS?,  Prev: Top,  Up: Top

About this manual
*****************

   Up to this point, one of the weakest parts of CVS has been the
documentation.  CVS is a complex program.  Previous versions of the
manual were written in the manual page format, which is not really well
suited for such a complex program.

   When writing this manual, I had several goals in mind:

   * No knowledge of RCS should be necessary.

   * No previous knowledge of revision control software should be
     necessary.  All terms, such as "revision numbers", "revision
     trees" and "merging" are explained as they are introduced.

   * The manual should concentrate on the things CVS users want to do,
     instead of what the CVS commands can do.  The first part of this
     manual leads you through things you might want to do while doing
     development, and introduces the relevant CVS commands as they are
     needed.

   * Information should be easy to find.  In the reference manual in
     the appendices almost all information about every CVS command is
     gathered together.  There is also an extensive index, and a lot of
     cross references.

   This manual was contributed by Signum Support AB in Sweden.  Signum
is yet another in the growing list of companies that support free
software.  You are free to copy both this manual and the CVS program.
*Note Copying::, for the details.  Signum Support offers support
contracts and binary distribution for many programs, such as CVS, GNU
Emacs, the GNU C compiler and others.  You can also buy hardcopies of
this manual from us.  Write to us for more information.

     Signum Support AB
     Box 2044
     S-580 02  Linkoping
     Sweden
     
     Email: info@@signum.se
     Phone: +46 (0)13 - 21 46 00
     Fax:   +46 (0)13 - 21 47 00

* Menu:

* Checklist::
* Credits::
* BUGS::


File: cvs.info,  Node: Checklist,  Next: Credits,  Up: Preface

Checklist for the impatient reader
==================================

   CVS is a complex system.  You will need to read the manual to be
able to use all of its capabilities.  There are dangers that can easily
be avoided if you know about them, and this manual tries to warn you
about them.  This checklist is intended to help you avoid the dangers
without reading the entire manual.  If you intend to read the entire
manual you can skip this table.

Binary files
     CVS can handle binary files, but you must have RCS release 5.5 or
     later and a release of GNU diff that supports the `-a' flag
     (release 1.15 and later are OK).  You must also configure both RCS
     and CVS to handle binary files when you install them.

     Keword substitution can be a source of trouble with binary files.
     *Note Keyword substitution::, for solutions.

The `admin' command
     Uncareful use of the `admin' command can cause CVS to cease
     working.  *Note admin::, before trying to use it.


File: cvs.info,  Node: Credits,  Next: BUGS,  Prev: Checklist,  Up: Preface

Credits
=======

   Roland Pesch, Cygnus Support <pesch@@cygnus.com> wrote the manual
pages which were distributed with CVS 1.3.  Appendix A and B contain
much text that was extracted from them.  He also read an early draft of
this manual and contributed many ideas and corrections.

   The mailing-list `info-cvs' is sometimes informative. I have
included information from postings made by the following persons: David
G. Grubbs <dgg@@think.com>.

   Some text has been extracted from the man pages for RCS.

   The CVS FAQ (*note What is CVS?::.) by David G. Grubbs has been used
as a check-list to make sure that this manual is as complete as
possible.  (This manual does however not include all of the material in
the FAQ).  The FAQ contains a lot of useful information.

   In addition, the following persons have helped by telling me about
mistakes I've made: Roxanne Brunskill <rbrunski@@datap.ca>, Kathy Dyer
<dyer@@phoenix.ocf.llnl.gov>, Karl Pingle <pingle@@acuson.com>, Thomas A
Peterson <tap@@src.honeywell.com>, Inge Wallin <ingwa@@signum.se>, Dirk
Koschuetzki <koschuet@@fmi.uni-passau.de> and Michael Brown
<brown@@wi.extrel.com>.


File: cvs.info,  Node: BUGS,  Prev: Credits,  Up: Preface

BUGS
====

   This manual is still very new.  Here is a list of known deficiencies
in it:

   * In the examples, the output from CVS is sometimes displayed,
     sometimes not.

   * The input that you are supposed to type in the examples should
     have a different font than the output from the computer.

   * This manual should be clearer about what file permissions you
     should set up in the repository, and about setuid/setgid.

   * Some of the chapters are not yet complete.  They are noted by
     comments in the `cvs.texinfo' file.

   * This list is not complete.  If you notice any error, omission, or
     something that is unclear, please send mail to ceder@@signum.se.

   I hope that you will find this manual useful, despite the
above-mentioned shortcomings.


                                                Linkoping, October 1993
                                                         Per Cederqvist


File: cvs.info,  Node: What is CVS?,  Next: Basic concepts,  Prev: Preface,  Up: Top

What is CVS?
************

   CVS is a version control system.  Using it, you can record the
history of your source files.

   For example, bugs sometimes creep in when software is modified, and
you might not detect the bug until a long time after you make the
modification.  With CVS, you can easily retrieve old versions to see
exactly which change caused the bug.  This can sometimes be a big help.

   You could of course save every version of every file you have ever
created.  This would however waste an enormous amount of disk space.
cVS stores all the versions of a file in a single file in a clever way
that only stores the differences between versions.

   CVS also helps you if you are part of a group of people working on
the same project.  It is all too easy to overwrite each others' changes
unless you are extremely careful.  Some editors, like GNU Emacs, try to
make sure that the same file is never modified by two people at the
same time.  Unfortunately, if someone is using another editor, that
safeguard will not work.  CVS solves this problem by insulating the
different developers from each other.  Every developer works in his own
directory, and CVS merges the work when each developer is done.

   CVS started out as a bunch of shell scripts written by Dick Grune,
posted to `comp.sources.unix' in the volume 6 release of December,
1986.  While no actual code from these shell scripts is present in the
current version of CVS much of the CVS conflict resolution algorithms
come from them.

   In April, 1989, Brian Berliner designed and coded CVS.  Jeff Polk
later helped Brian with the design of the CVS module and vendor branch
support.

   You can get CVS via anonymous ftp from a number of sites, for
instance prep.ai.mit.edu in `pub/gnu'.

   There is a mailing list for CVS where bug reports can be sent,
questions can be asked, an FAQ is posted, and discussion about future
enhancements to CVS take place.  To submit a message to the list, write
to <info-cvs@@prep.ai.mit.edu>.  To subscribe or unsubscribe, write to
<info-cvs-request@@prep.ai.mit.edu>. Please be specific about your email
address.

   Work is in progress on creating a newsgroup for CVS-related topics.
It will appear somewhere under the `gnu.' hierarchy.  Gateways to and
from the mailing list will be set up.

   The FTP site think.com has some CVS material in the `/pub/cvs'
subdirectory.  Currently (late summer 1993) it contains an excellent
FAQ (Frequently Asked Questions, with answers), and an improved (but
unofficial) version of CVS.

CVS is not...
=============

   CVS can do a lot of things for you, but it does not try to be
everything for everyone.

CVS is not a build system.
     Though the structure of your repository and modules file interact
     with your build system (e.g. `Makefile's), they are essentially
     independent.

     CVS does not dictate how you build anything.  It merely stores
     files for retrieval in a tree structure you devise.

     CVS does not dictate how to use disk space in the checked out
     working directories.  If you write your `Makefile's or scripts in
     every directory so they have to know the relative positions of
     everything else, you wind up requiring the entire repository to be
     checked out.  That's simply bad planning.

     If you modularize your work, and construct a build system that
     will share files (via links, mounts, `VPATH' in `Makefile's,
     etc.), you can arrange your disk usage however you like.

     But you have to remember that *any* such system is a lot of work
     to construct and maintain.  CVS does not address the issues
     involved.  You must use your brain and a collection of other tools
     to provide a build scheme to match your plans.

     Of course, you should place the tools created to support such a
     build system (scripts, `Makefile's, etc) under CVS.

CVS is not a substitute for management.
     Your managers and project leaders are expected to talk to you
     frequently enough to make certain you are aware of schedules,
     merge points, branch names and release dates.  If they don't, CVS
     can't help.

     CVS is an instrument for making sources dance to your tune.  But
     you are the piper and the composer.  No instrument plays itself or
     writes its own music.

CVS is not a substitute for developer communication.
     When faced with conflicts within a single file, most developers
     manage to resolve them without too much effort.  But a more
     general definition of "conflict" includes problems too difficult
     to solve without communication between developers.

     CVS cannot determine when simultaneous changes within a single
     file, or across a whole collection of files, will logically
     conflict with one another.  Its concept of a "conflict" is purely
     textual, arising when two changes to the same base file are near
     enough to spook the merge (i.e. `diff3') command.

     CVS does not claim to help at all in figuring out non-textual or
     distributed conflicts in program logic.

     For example: Say you change the arguments to function `X' defined
     in file `A'.  At the same time, someone edits file `B', adding new
     calls to function `X' using the old arguments.  You are outside
     the realm of CVS's competence.

     Acquire the habit of reading specs and talking to your peers.

CVS is not a configuration management system.
     CVS is a source control system.  The phrase "configuration
     management" is a marketing term, not an industry-recognized set of
     functions.

     A true "configuration management system" would contain elements of
     the following:

        * Source control.

        * Dependency tracking.

        * Build systems (i.e. What to build and how to find things
          during a build.  What is shared?  What is local?)

        * Bug tracking.

        * Automated Testing procedures.

        * Release Engineering documentation and procedures.

        * Tape Construction.

        * Customer Installation.

        * A way for users to run different versions of the same
          software on the same host at the same time.

     CVS provides only the first.

   This section is taken from release 2.3 of the CVS FAQ.


File: cvs.info,  Node: Basic concepts,  Next: A sample session,  Prev: What is CVS?,  Up: Top

Basic concepts
**************

   CVS stores all files in a centralized "repository": a directory
(such as `/usr/local/cvsroot' or `user@@remotehost:/usr/local/cvsroot')
which is populated with a hierarchy of files and directories.  (*note
Remote repositories::. for information about keeping the repository on
a remote machine.)

   Normally, you never access any of the files in the repository
directly.  Instead, you use CVS commands to get your own copy of the
files, and then work on that copy.  When you've finished a set of
changes, you check (or "commit") them back into the repository.

   The files in the repository are organized in "modules".  Each module
is made up of one or more files, and can include files from several
directories.  A typical usage is to define one module per project.

* Menu:

* Revision numbers::            The meaning of a revision number
* Versions revisions releases::  Terminology used in this manual


File: cvs.info,  Node: Revision numbers,  Next: Versions revisions releases,  Up: Basic concepts

Revision numbers
================

   Each version of a file has a unique "revision number".  Revision
numbers look like `1.1', `1.2', `1.3.2.2' or even `1.3.2.2.4.5'.  A
revision number always has an even number of period-separated decimal
integers.  By default revision 1.1 is the first revision of a file.
Each successive revision is given a new number by increasing the
rightmost number by one.  The following figure displays a few
revisions, with newer revisions to the right.

            +-----+    +-----+    +-----+    +-----+    +-----+
            ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !
            +-----+    +-----+    +-----+    +-----+    +-----+

   CVS is not limited to linear development.  The "revision tree" can
be split into "branches", where each branch is a self-maintained line of
development.  Changes made on one branch can easily be moved back to
the main trunk.

   Each branch has a "branch number", consisting of an odd number of
period-separated decimal integers.  The branch number is created by
appending an integer to the revision number where the corresponding
branch forked off.  Having branch numbers allows more than one branch
to be forked off from a certain revision.

   All revisions on a branch have revision numbers formed by appending
an ordinal number to the branch number.  The following figure
illustrates branching with an example.

                                                          +-------------+
                               Branch 1.2.2.3.2 ->        ! 1.2.2.3.2.1 !
                                                        / +-------------+
                                                       /
                                                      /
                      +---------+    +---------+    +---------+    +---------+
     Branch 1.2.2 -> _! 1.2.2.1 !----! 1.2.2.2 !----! 1.2.2.3 !----! 1.2.2.4 !
                    / +---------+    +---------+    +---------+    +---------+
                   /
                  /
     +-----+    +-----+    +-----+    +-----+    +-----+
     ! 1.1 !----! 1.2 !----! 1.3 !----! 1.4 !----! 1.5 !      <- The main trunk
     +-----+    +-----+    +-----+    +-----+    +-----+
                     !
                     !
                     !   +---------+    +---------+    +---------+
     Branch 1.2.4 -> +---! 1.2.4.1 !----! 1.2.4.2 !----! 1.2.4.3 !
                         +---------+    +---------+    +---------+

   The exact details of how the branch number is constructed is not
something you normally need to be concerned about, but here is how it
works: When CVS creates a branch number it picks the first unused even
integer, starting with 2.  So when you want to create a branch from
revision 6.4 it will be numbered 6.4.2.  All branch numbers ending in a
zero (such as 6.4.0) are used internally by CVS (*note Magic branch
numbers::.).  The branch 1.1.1 has a special meaning.  *Note Tracking
sources::.


File: cvs.info,  Node: Versions revisions releases,  Prev: Revision numbers,  Up: Basic concepts

Versions, revisions and releases
================================

   A file can have several versions, as described above.  Likewise, a
software product can have several versions.  A software product is
often given a version number such as `4.1.1'.

   Versions in the first sense are called "revisions" in this document,
and versions in the second sense are called "releases".  To avoid
confusion, the word "version" is almost never used in this document.


File: cvs.info,  Node: A sample session,  Next: Repository,  Prev: Basic concepts,  Up: Top

A sample session
****************

   This section describes a typical work-session using CVS.  It assumes
that a repository is set up (*note Repository::.).

   Suppose you are working on a simple compiler.  The source consists
of a handful of C files and a `Makefile'.  The compiler is called `tc'
(Trivial Compiler), and the repository is set up so that there is a
module called `tc'.

* Menu:

* Getting the source::          Creating a workspace
* Committing your changes::     Making your work available to others
* Cleaning up::                 Cleaning up
* Viewing differences::         Viewing differences


File: cvs.info,  Node: Getting the source,  Next: Committing your changes,  Up: A sample session

Getting the source
==================

   The first thing you must do is to get your own working copy of the
source for `tc'.  For this, you use the `checkout' command:

     $ cvs checkout tc

This will create a new directory called `tc' and populate it with the
source files.

     $ cd tc
     $ ls tc
     CVS         Makefile    backend.c   driver.c    frontend.c  parser.c

   The `CVS' directory is used internally by CVS.  Normally, you should
not modify or remove any of the files in it.

   You start your favorite editor, hack away at `backend.c', and a
couple of hours later you have added an optimization pass to the
compiler.  A note to RCS and SCCS users: There is no need to lock the
files that you want to edit.  *Note Multiple developers:: for an
explanation.


File: cvs.info,  Node: Committing your changes,  Next: Cleaning up,  Prev: Getting the source,  Up: A sample session

Committing your changes
=======================

   When you have checked that the compiler is still compilable you
decide to make a new version of `backend.c'.

     $ cvs commit backend.c

CVS starts an editor, to allow you to enter a log message.  You type in
"Added an optimization pass.", save the temporary file, and exit the
editor.

   The environment variable `$CVSEDITOR' determines which editor is
started.  If `$CVSEDITOR' is not set, then if the environment variable
`$EDITOR' is set, it will be used. If both `$CVSEDITOR' and `$EDITOR'
are not set then the editor defaults to `vi'.  If you want to avoid the
overhead of starting an editor you can specify the log message on the
command line using the `-m' flag instead, like this:

     $ cvs commit -m "Added an optimization pass" backend.c


File: cvs.info,  Node: Cleaning up,  Next: Viewing differences,  Prev: Committing your changes,  Up: A sample session

Cleaning up
===========

   Before you turn to other tasks you decide to remove your working
copy of tc.  One acceptable way to do that is of course

     $ cd ..
     $ rm -r tc

but a better way is to use the `release' command (*note release::.):

     $ cd ..
     $ cvs release -d tc
     M driver.c
     ? tc
     You have [1] altered files in this repository.
     Are you sure you want to release (and delete) module `tc': n
     ** `release' aborted by user choice.

   The `release' command checks that all your modifications have been
committed.  If history logging is enabled it also makes a note in the
history file.  *Note history file::.

   When you use the `-d' flag with `release', it also removes your
working copy.

   In the example above, the `release' command wrote a couple of lines
of output.  `? tc' means that the file `tc' is unknown to CVS.  That is
nothing to worry about: `tc' is the executable compiler, and it should
not be stored in the repository.  *Note cvsignore::, for information
about how to make that warning go away.  *Note release output::, for a
complete explanation of all possible output from `release'.

   `M driver.c' is more serious.  It means that the file `driver.c' has
been modified since it was checked out.

   The `release' command always finishes by telling you how many
modified files you have in your working copy of the sources, and then
asks you for confirmation before deleting any files or making any note
in the history file.

   You decide to play it safe and answer `n RET' when `release' asks
for confirmation.


File: cvs.info,  Node: Viewing differences,  Prev: Cleaning up,  Up: A sample session

Viewing differences
===================

   You do not remember modifying `driver.c', so you want to see what
has happened to that file.

     $ cd tc
     $ cvs diff driver.c

   This command runs `diff' to compare the version of `driver.c' that
you checked out with your working copy.  When you see the output you
remember that you added a command line option that enabled the
optimization pass.  You check it in, and release the module.

     $ cvs commit -m "Added an optimization pass" driver.c
     Checking in driver.c;
     /usr/local/cvsroot/tc/driver.c,v  <--  driver.c
     new revision: 1.2; previous revision: 1.1
     done
     $ cd ..
     $ cvs release -d tc
     ? tc
     You have [0] altered files in this repository.
     Are you sure you want to release (and delete) module `tc': y


File: cvs.info,  Node: Repository,  Next: Starting a new project,  Prev: A sample session,  Up: Top

The Repository
**************

   Figure 3 below shows a typical setup of a repository.  Only
directories are shown below.

     /usr
      |
      +--local
      |   |
      |   +--cvsroot
      |   |    |
      |   |    +--CVSROOT
               |      (administrative files)
               |
               +--gnu
               |   |
               |   +--diff
               |   |   (source code to GNU diff)
               |   |
               |   +--rcs
               |   |   (source code to RCS)
               |   |
               |   +--cvs
               |       (source code to CVS)
               |
               +--yoyodyne
                   |
                   +--tc
                   |    |
                   |    +--man
                   |    |
                   |    +--testing
                   |
                   +--(other Yoyodyne software)

   There are a couple of different ways to tell CVS where to find the
repository.  You can name the repository on the command line
explicitly, with the `-d' (for "directory") option:

     cvs -d /usr/local/cvsroot checkout yoyodyne/tc

   Or you can set the `$CVSROOT' environment variable to an absolute
path to the root of the repository, `/usr/local/cvsroot' in this
example.  To set `$CVSROOT', all `csh' and `tcsh' users should have
this line in their `.cshrc' or `.tcshrc' files:

     setenv CVSROOT /usr/local/cvsroot

`sh' and `bash' users should instead have these lines in their
`.profile' or `.bashrc':

     CVSROOT=/usr/local/cvsroot
     export CVSROOT

   A repository specified with `-d' will override the `$CVSROOT'
environment variable.  Once you've checked a working copy out from the
repository, it will remember where its repository is (the information
is recorded in the `CVS/Root' file in the working copy).

   The `-d' option and the `CVS/Root' file both override the `$CVSROOT'
environment variable; however, CVS will complain if the `-d' argument
and the `CVS/Root' file disagree.

   There is nothing magical about the name `/usr/local/cvsroot'.  You
can choose to place the repository anywhere you like.  *Note Remote
repositories:: to learn how the repository can be on a different
machine than your working copy of the sources.

   The repository is split in two parts.  `$CVSROOT/CVSROOT' contains
administrative files for CVS.  The other directories contain the actual
user-defined modules.

* Menu:

* User modules::                The structure of the repository
* Intro administrative files::  Defining modules
* Multiple repositories::       Multiple repositories
* Creating a repository::       Creating a repository
* Remote repositories::         Accessing repositories on remote machines


File: cvs.info,  Node: User modules,  Next: Intro administrative files,  Up: Repository

User modules
============

       `$CVSROOT'
         |
         +--yoyodyne
         |   |
         |   +--tc
         |   |   |
                 +--Makefile,v
                 +--backend.c,v
                 +--driver.c,v
                 +--frontend.c,v
                 +--parser.c,v
                 +--man
                 |    |
                 |    +--tc.1,v
                 |
                 +--testing
                      |
                      +--testpgm.t,v
                      +--test2.t,v

   The figure above shows the contents of the `tc' module inside the
repository.  As you can see all file names end in `,v'.  The files are
"history files".  They contain, among other things, enough information
to recreate any revision of the file, a log of all commit messages and
the user-name of the person who committed the revision.  CVS uses the
facilities of RCS, a simpler version control system, to maintain these
files.  For a full description of the file format, see the `man' page
`rcsfile(5)'.

* Menu:

* File permissions::            File permissions


File: cvs.info,  Node: File permissions,  Up: User modules

File permissions
----------------

   All `,v' files are created read-only, and you should not change the
permission of those files.  The directories inside the repository
should be writable by the persons that have permission to modify the
files in each directory.  This normally means that you must create a
UNIX group (see group(5)) consisting of the persons that are to edit
the files in a project, and set up the repository so that it is that
group that owns the directory.

   This means that you can only control access to files on a
per-directory basis.

   CVS tries to set up reasonable file permissions for new directories
that are added inside the tree, but you must fix the permissions
manually when a new directory should have different permissions than its
parent directory.

   Since CVS was not written to be run setuid, it is unsafe to try to
run it setuid.  You cannot use the setuid features of RCS together with
CVS.


File: cvs.info,  Node: Intro administrative files,  Next: Multiple repositories,  Prev: User modules,  Up: Repository

The administrative files
========================

   The directory `$CVSROOT/CVSROOT' contains some "administrative
files".  *Note Administrative files::, for a complete description.  You
can use CVS without any of these files, but some commands work better
when at least the `modules' file is properly set up.

   The most important of these files is the `modules' file.  It defines
all modules in the repository.  This is a sample `modules' file.

     CVSROOT         -i mkmodules CVSROOT
     modules         -i mkmodules CVSROOT modules
     cvs             gnu/cvs
     rcs             gnu/rcs
     diff            gnu/diff
     tc              yoyodyne/tc

   The `modules' file is line oriented.  In its simplest form each line
contains the name of the module, whitespace, and the directory where
the module resides.  The directory is a path relative to `$CVSROOT'.
The last for lines in the example above are examples of such lines.

   Each module definition can contain options.  The `-i mkmodules' is
an example of an option.  It arranges for CVS to run the `mkmodules'
program whenever any file in the module CVSROOT is committed.  That
program is responsible for checking out read-only copies from the RCS
"history files" of all the administrative files.  These read-only
copies are used internally by CVS.  You should never edit them directly.

   The line that defines the module called `modules' uses features that
are not explained here.  *Note modules::, for a full explanation of all
the available features.

Editing administrative files
----------------------------

   You edit the administrative files in the same way that you would edit
any other module.  Use `cvs checkout CVSROOT' to get a working copy,
edit it, and commit your changes in the normal way.

   It is possible to commit an erroneous administrative file.  You can
often fix the error and check in a new revision, but sometimes a
particularly bad error in the administrative file makes it impossible
to commit new revisions.


File: cvs.info,  Node: Multiple repositories,  Next: Creating a repository,  Prev: Intro administrative files,  Up: Repository

Multiple repositories
=====================

   In some situations it is a good idea to have more than one
repository, for instance if you have two development groups that work
on separate projects without sharing any code.  All you have to do to
have several repositories is to set `$CVSROOT' to the repository you
want to use at the moment.

   There are disadvantages to having more than one repository.  In CVS
1.3 you *must* make sure that `$CVSROOT' always points to the correct
repository.  If the same filename is used in two repositories, and you
mix up the setting of `$CVSROOT', you might lose data.  CVS 1.4 solves
this problem by saving the repository information in the local `CVS'
administration files.  If you try to use the wrong repository, CVS will
warn you of the attempt and then exit.

   Notwithstanding, it can be confusing to have two or more
repositories.

   All examples in this manual assume that you have a single repository.


File: cvs.info,  Node: Creating a repository,  Next: Remote repositories,  Prev: Multiple repositories,  Up: Repository

Creating a repository
=====================

   See the instructions in the `INSTALL' file in the CVS distribution.


File: cvs.info,  Node: Remote repositories,  Prev: Creating a repository,  Up: Repository

Remote repositories
===================

   The repository and your working copy of the sources can be on
different machines.  To access a remote repository, use the following
format for its name:

             user@@hostname:/path/to/repository

   (The `user@@' can be omitted if it's the same on both the local and
remote hosts.)

   CVS uses the `rsh' protocol to perform these operations, so the
remote user host needs to have a `.rhosts' file which grants access to
the local user.

   For example, suppose you are the user `mozart' on the local machine
`anklet.grunge.com'.  You want to access the module `foo' in the
repository `/usr/local/sources/', on machine `chainsaw.brickyard.com'.

   If your username is also `bach' on `chainsaw.brickyard.com', then
you need only type

     cvs -d bach@@chainsaw.brickyard.com:/user/local/sources checkout foo

   Remember, for this to work, `bach''s `.rhosts' file must contain the
line:

     anklet.grunge.com  mozart

   Once the working copy is checked out, it is not necessary to specify
the repository explicitly for every subsequent operation -- the working
copy records it in the `CVS/Root' file.


File: cvs.info,  Node: Starting a new project,  Next: Multiple developers,  Prev: Repository,  Up: Top

Starting a project with CVS
***************************

   Since CVS 1.x is bad at renaming files and moving them between
directories, the first thing you do when you start a new project should
be to think through your file organization.  It is not impossible--just
awkward--to rename or move files in CVS 1.x.  *Note Moving files::.

   What to do next depends on the situation at hand.

* Menu:

* Setting up the files::        Getting the files into the repository
* Defining the module::         How to make a module of the files


File: cvs.info,  Node: Setting up the files,  Next: Defining the module,  Up: Starting a new project

Setting up the files
====================

   The first step is to create the files inside the repository.  This
can be done in a couple of different ways.

* Menu:

* From files::                  This method is useful with old projects
                                where files already exists.

* From scratch::                Creating a module from scratch.


File: cvs.info,  Node: From files,  Next: From scratch,  Up: Setting up the files

Creating a module from a number of files
----------------------------------------

   When you begin using CVS, you will probably already have several
projects that can be put under CVS control.  In these cases the easiest
way is to use the `import' command.  An example is probably the easiest
way to explain how to use it.  If the files you want to install in CVS
reside in `DIR', and you want them to appear in the repository as
`$CVSROOT/yoyodyne/DIR', you can do this:

     $ cd DIR
     $ cvs import -m "Imported sources" yoyodyne/DIR yoyo start

   Unless you supply a log message with the `-m' flag, CVS starts an
editor and prompts for a message.  The string `yoyo' is a "vendor tag",
and `start' is a "release tag".  They may fill no purpose in this
context, but since CVS requires them they must be present.  *Note
Tracking sources::, for more information about them.

   You can now verify that it worked, and remove your original source
directory.

     $ cd ..
     $ mv DIR DIR.orig
     $ cvs checkout yoyodyne/DIR       # Explanation below
     $ ls -R yoyodyne
     $ rm -r DIR.orig

Erasing the original sources is a good idea, to make sure that you do
not accidentally edit them in DIR, bypassing CVS.  Of course, it would
be wise to make sure that you have a backup of the sources before you
remove them.

   The `checkout' command can either take a module name as argument (as
it has done in all previous examples) or a path name relative to
`$CVSROOT', as it did in the example above.

   It is a good idea to check that the permissions CVS sets on the
directories inside `$CVSROOT' are reasonable, and that they belong to
the proper groups.  *Note File permissions::.


File: cvs.info,  Node: From scratch,  Prev: From files,  Up: Setting up the files

Creating a module from scratch
------------------------------

   For a new project, the easiest thing to do is probably to create an
empty directory structure, like this:

     $ mkdir tc
     $ mkdir tc/man
     $ mkdir tc/testing

   After that, you use the `import' command to create the corresponding
(empty) directory structure inside the repository:

     $ cd tc
     $ cvs import -m "Created directory structure" yoyodyne/DIR yoyo start

   Then, use `add' to add files (and new directories) as they appear.

   Check that the permissions CVS sets on the directories inside
`$CVSROOT' are reasonable.


File: cvs.info,  Node: Defining the module,  Prev: Setting up the files,  Up: Starting a new project

Defining the module
===================

   The next step is to define the module in the `modules' file.  Some
CVS commands work without this step, but others (most notably
`release') require that all modules are properly defined in the
`modules' file.

   In simple cases these steps are sufficient to define a module.

  1. Get a working copy of the modules file.

          $ cvs checkout modules
          $ cd modules

  2. Edit the file and insert a line that defines the module.  *Note
     Intro administrative files::, for an introduction.  *Note
     modules::, for a full description of the modules file.  You can
     use the following line to define the module `tc':

          tc   yoyodyne/tc

  3. Commit your changes to the modules file.

          $ cvs commit -m "Added the tc module." modules

  4. Release the modules module.

          $ cd ..
          $ cvs release -d modules


File: cvs.info,  Node: Multiple developers,  Next: Branches,  Prev: Starting a new project,  Up: Top

Multiple developers
*******************

   When more than one person works on a software project things often
get complicated.  Often, two people try to edit the same file
simultaneously.  Some other version control systems (including RCS and
SCCS) try to solve that particular problem by introducing "file
locking", so that only one person can edit each file at a time.
Unfortunately, file locking can be very counter-productive.  If two
persons want to edit different parts of a file, there may be no reason
to prevent either of them from doing so.

   CVS does not use file locking.  Instead, it allows many people to
edit their own "working copy" of a file simultaneously.  The first
person that commits his changes has no automatic way of knowing that
another has started to edit it.  Others will get an error message when
they try to commit the file.  They must then use CVS commands to bring
their working copy up to date with the repository revision.  This
process is almost automatic, and explained in this chapter.

   There are many ways to organize a team of developers.  CVS does not
try to enforce a certain organization.  It is a tool that can be used
in several ways.  It is often useful to inform the group of commits you
have done.  CVS has several ways of automating that process.  *Note
Informing others::.  *Note Revision management::, for more tips on how
to use CVS.

* Menu:

* File status::                 A file can be in several states
* Updating a file::             Bringing a file up-to-date
* Conflicts example::           An informative example
* Informing others::            To cooperate you must inform


File: cvs.info,  Node: File status,  Next: Updating a file,  Up: Multiple developers

File status
===========

   After you have checked out a file out from CVS, it is in one of
these four states:

Up-to-date
     The file is identical with the latest revision in the repository.

Locally modified
     You have edited the file, and not yet committed your changes.

Needing update
     Someone else has committed a newer revision to the repository.

Needing merge
     Someone else have committed a newer revision to the repository,
     and you have also made modifications to the file.

   You can use the `status' command to find out the status of a given
file.  *Note status::.


File: cvs.info,  Node: Updating a file,  Next: Conflicts example,  Prev: File status,  Up: Multiple developers

Bringing a file up to date
==========================

   When you want to update or merge a file, use the `update' command.
For files that are not up to date this is roughly equivalent to a
`checkout' command: the newest revision of the file is extracted from
the repository and put in your working copy of the module.

   Your modifications to a file are never lost when you use `update'.
If no newer revision exists, running `update' has no effect.  If you
have edited the file, and a newer revision is available, CVS will merge
all changes into your working copy.

   For instance, imagine that you checked out revision 1.4 and started
editing it.  In the meantime someone else committed revision 1.5, and
shortly after that revision 1.6.  If you run `update' on the file now,
CVS will incorporate all changes between revision 1.4 and 1.6 into your
file.

   If any of the changes between 1.4 and 1.6 were made too close to any
of the changes you have made, an "overlap" occurs.  In such cases a
warning is printed, and the resulting file includes both versions of
the lines that overlap, delimited by special markers.  *Note update::,
for a complete description of the `update' command.


File: cvs.info,  Node: Conflicts example,  Next: Informing others,  Prev: Updating a file,  Up: Multiple developers

Conflicts example
=================

   Suppose revision 1.4 of `driver.c' contains this:

     #include <stdio.h>
     
     void main()
     {
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? 0 : 1);
     }

Revision 1.6 of `driver.c' contains this:

     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(!!nerr);
     }

Your working copy of `driver.c', based on revision 1.4, contains this
before you run `cvs update':

     #include <stdlib.h>
     #include <stdio.h>
     
     void main()
     {
         init_scanner();
         parse();
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

You run `cvs update':

     $ cvs update driver.c
     RCS file: /usr/local/cvsroot/yoyodyne/tc/driver.c,v
     retrieving revision 1.4
     retrieving revision 1.6
     Merging differences between 1.4 and 1.6 into driver.c
     rcsmerge warning: overlaps during merge
     cvs update: conflicts found in driver.c
     C driver.c

CVS tells you that there were some conflicts.  Your original working
file is saved unmodified in `.#driver.c.1.4'.  The new version of
`driver.c' contains this:

     #include <stdlib.h>
     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
     <<<<<<< driver.c
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     =======
         exit(!!nerr);
     >>>>>>> 1.6
     }

Note how all non-overlapping modifications are incorporated in your
working copy, and that the overlapping section is clearly marked with
`<<<<<<<', `=======' and `>>>>>>>'.

   You resolve the conflict by editing the file, removing the markers
and the erroneous line.  Suppose you end up with this file:
     #include <stdlib.h>
     #include <stdio.h>
     
     int main(int argc,
              char **argv)
     {
         init_scanner();
         parse();
         if (argc != 1)
         {
             fprintf(stderr, "tc: No args expected.\n");
             exit(1);
         }
         if (nerr == 0)
             gencode();
         else
             fprintf(stderr, "No code generated.\n");
         exit(nerr == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
     }

You can now go ahead and commit this as revision 1.7.

     $ cvs commit -m "Initialize scanner. Use symbolic exit values." driver.c
     Checking in driver.c;
     /usr/local/cvsroot/yoyodyne/tc/driver.c,v  <--  driver.c
     new revision: 1.7; previous revision: 1.6
     done

   If you use release 1.04 or later of pcl-cvs (a GNU Emacs front-end
for CVS) you can use an Emacs package called emerge to help you resolve
conflicts.  See the documentation for pcl-cvs.


File: cvs.info,  Node: Informing others,  Prev: Conflicts example,  Up: Multiple developers

Informing others about commits
==============================

   It is often useful to inform others when you commit a new revision
of a file.  The `-i' option of the `modules' file, or the `loginfo'
file, can be used to automate this process.  *Note modules::.  *Note
loginfo::.  You can use these features of CVS to, for instance,
instruct CVS to mail a message to all developers, or post a message to
a local newsgroup.


File: cvs.info,  Node: Branches,  Next: Merging,  Prev: Multiple developers,  Up: Top

Branches
********

   So far, all revisions shown in this manual have been on the "main
trunk" of the revision tree, i.e., all revision numbers have been of
the form X.Y.  One useful feature, especially when maintaining several
releases of a software product at once, is the ability to make branches
on the revision tree.  "Tags", symbolic names for revisions, will also
be introduced in this chapter.

* Menu:

* Tags::                        Tags-Symbolic revisions
* Branches motivation::         What branches are good for
* Creating a branch::           Creating a branch
* Sticky tags::                 Sticky tags


File: cvs.info,  Node: Tags,  Next: Branches motivation,  Up: Branches

Tags-Symbolic revisions
=======================

   The revision numbers live a life of their own.  They need not have
anything at all to do with the release numbers of your software
product.  Depending on how you use CVS the revision numbers might
change several times between two releases.  As an example, some of the
source files that make up RCS 5.6 have the following revision numbers:

     ci.c            5.21
     co.c            5.9
     ident.c         5.3
     rcs.c           5.12
     rcsbase.h       5.11
     rcsdiff.c       5.10
     rcsedit.c       5.11
     rcsfcmp.c       5.9
     rcsgen.c        5.10
     rcslex.c        5.11
     rcsmap.c        5.2
     rcsutil.c       5.10

   You can use the `tag' command to give a symbolic name to a certain
revision of a file.  You can use the `-v' flag to the `status' command
to see all tags that a file has, and which revision numbers they
represent.  (The output of `status' unfortunately uses the word
"version" instead of "revision".)

   The following example shows how you can add a tag to a file.  The
commands must be issued inside your working copy of the module.  That
is, you should issue the command in the directory where `backend.c'
resides.

     $ cvs tag release-0-4 backend.c
     T backend.c
     $ cvs status -v backend.c
     ===================================================================
     File: backend.c         Status: Up-to-date
     
         Version:            1.4     Tue Dec  1 14:39:01 1992
         RCS Version:        1.4     /usr/local/cvsroot/yoyodyne/tc/backend.c,v
         Sticky Tag:         (none)
         Sticky Date:        (none)
         Sticky Options:     (none)
     
         Existing Tags:
             release-0-4                     (revision: 1.4)

   There is seldom reason to tag a file in isolation.  A more common
use is to tag all the files that constitute a module with the same tag
at strategic points in the development life-cycle, such as when a
release is made.

     $ cvs tag release-1-0 .
     cvs tag: Tagging .
     T Makefile
     T backend.c
     T driver.c
     T frontend.c
     T parser.c

   (When you give CVS a directory as argument, it generally applies the
operation to all the files in that directory, and (recursively), to any
subdirectories that it may contain.  *Note Recursive behavior::.)

   The `checkout' command has a flag, `-r', that lets you check out a
certain revision of a module.  This flag makes it easy to retrieve the
sources that make up release 1.0 of the module `tc' at any time in the
future:

     $ cvs checkout -r release-1-0 tc

This is useful, for instance, if someone claims that there is a bug in
that release, but you cannot find the bug in the current working copy.

   You can also check out a module as it was at any given date.  *Note
checkout options::.

   When you tag more than one file with the same tag you can think
about the tag as "a curve drawn through a matrix of filename vs.
revision number."  Say we have 5 files with the following revisions:

             file1   file2   file3   file4   file5
     
             1.1     1.1     1.1     1.1  /--1.1*      <-*-  TAG
             1.2*-   1.2     1.2    -1.2*-
             1.3  \- 1.3*-   1.3   / 1.3
             1.4          \  1.4  /  1.4
                           \-1.5*-   1.5
                             1.6

   At some time in the past, the `*' versions were tagged.  You can
think of the tag as a handle attached to the curve drawn through the
tagged revisions.  When you pull on the handle, you get all the tagged
revisions.  Another way to look at it is that you "sight" through a set
of revisions that is "flat" along the tagged revisions, like this:

             file1   file2   file3   file4   file5
     
                             1.1
                             1.2
                     1.1     1.3                       _
             1.1     1.2     1.4     1.1              /
             1.2*----1.3*----1.5*----1.2*----1.1     (--- <--- Look here
             1.3             1.6     1.3              \_
             1.4                     1.4
                                     1.5

@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Missed files from 1.7.1 import
@
text
@d29 2
a30 2
   This info manual describes how to use and administer CVS and is
updated to release 1.4 or something similar.
a49 1
* Binary files::                CVS can handle binary files
d93 2
a94 1
Emacs, the GNU C compiler and others.  Write to us for more information.
a104 3
   Another company selling support for CVS is Cyclic Software, web:
`http://www.cyclic.com/', email: `info@@cyclic.com'.

d172 2
a173 2
   This manual is known to have room for improvement.  Here is a list
of known deficiencies:
d188 1
a188 2
     something that is unclear, please send mail to
     bug-cvs@@prep.ai.mit.edu.
d805 10
a814 5
have several repositories is to specify the appropriate repository,
using the `CVSROOT' environment variable, the `-d' option to CVS, or
(once you have checked out a working directories) by simply allowing
CVS to use the repository that was used to check out the working
directory (*note Repository::.).
d819 1
a819 1
   None of the examples in this manual show multiple repositories.
d835 3
a837 3
   Your working copy of the sources can be on a different machine than
the repository.  Generally, using a remote repository is just like
using a local one, except that the format of the repository name is:
d841 2
a842 14
   The details of exactly what needs to be set up depend on how you are
connecting to the server.

* Menu:

* Connecting via rsh::          Using the `rsh' program to connect
* Password authenticated::      Direct connections using passwords
* Kerberos authenticated::      Direct connections with kerberos


File: cvs.info,  Node: Connecting via rsh,  Next: Password authenticated,  Up: Remote repositories

Connecting with rsh
-------------------
d849 2
a850 3
`anklet.grunge.com', and the server machine is
`chainsaw.brickyard.com'.  On chainsaw, put the following line into the
file `.rhosts' in `bach''s home directory:
d852 2
a853 1
     anklet.grunge.com  mozart
d855 1
a855 1
   Then test that `rsh' is working with
d857 2
a858 1
     rsh -l bach chainsaw.brickyard.com echo $PATH
d860 1
a860 60
   Next you have to make sure that `rsh' will be able to find the
server.  Make sure that the path which `rsh' printed in the above
example includes the directory containing a program named `cvs' which
is the server.  You need to set the path in `.bashrc', `.cshrc', etc.,
not `.login' or `.profile'.  Alternately, you can set the environment
variable `CVS_SERVER' on the client machine to the filename of the
server you want to use, for example `/usr/local/bin/cvs-1.6'.

   There is no need to edit `inetd.conf' or start a CVS server daemon.

   Continuing our example, supposing you want to access the module
`foo' in the repository `/usr/local/cvsroot/', on machine
`chainsaw.brickyard.com', you are ready to go:

     cvs -d bach@@chainsaw.brickyard.com:/user/local/cvsroot checkout foo

   (The `bach@@' can be omitted if the username is the same on both the
local and remote hosts.)


File: cvs.info,  Node: Password authenticated,  Next: Kerberos authenticated,  Prev: Connecting via rsh,  Up: Remote repositories

Direct connection with password authentication
----------------------------------------------

   The CVS client can also connect to the server using a password
protocol.  This is particularly useful if using `rsh' is not feasible
(for example, the server is behind a firewall), and Kerberos also is
not available.

   To use this method, it is necessary to make some adjustments on both
the server and client sides.

* Menu:

* Password authentication server::     Setting up the server
* Password authentication client::     Using the client
* Password authentication security::   What this method does and does not do


File: cvs.info,  Node: Password authentication server,  Next: Password authentication client,  Up: Password authenticated

Setting up the server for password authentication
.................................................

   On the server side, the file `/etc/inetd.conf' needs to be edited so
`inetd' knows to run the command `cvs pserver' when it receives a
connection on the right port.  By default, the port number is 2401; it
would be different if your client were compiled with `CVS_AUTH_PORT'
defined to something else, though.

   If your `inetd' allows raw port numbers in `/etc/inetd.conf', then
the following (all on a single line in `inetd.conf') should be
sufficient:

     2401  stream  tcp  nowait  root  /usr/local/bin/cvs
     cvs -b /usr/local/bin pserver

   The `-b' option specifies the directory which contains the RCS
binaries on the server.
d862 3
a864 148
   If your `inetd' wants a symbolic service name instead of a raw port
number, then put this in `/etc/services':

     cvspserver      2401/tcp

   and put `cvspserver' instead of `2401' in `inetd.conf'.

   Once the above is taken care of, restart your `inetd', or do
whatever is necessary to force it to reread its initialization files.

   Because the client stores and transmits passwords in cleartext
(almost--see *Note Password authentication security:: for details), a
separate CVS password file may be used, so people don't compromise their
regular passwords when they access the repository.  This file is
`$CVSROOT/CVSROOT/passwd' (*note Intro administrative files::.).  Its
format is similar to `/etc/passwd', except that it only has two fields,
username and password.  For example:

     bach:ULtgRLXo7NRxs
     cwang:1sOp854gDF3DY

   The password is encrypted according to the standard Unix `crypt()'
function, so it is possible to paste in passwords directly from regular
Unix `passwd' files.

   When authenticating a password, the server first checks for the user
in the CVS `passwd' file.  If it finds the user, it compares against
that password.  If it does not find the user, or if the CVS `passwd'
file does not exist, then the server tries the system's `/etc/passwd'
file.  In either case, assuming the password is correct, the server
switches to run as that user immediately after authentication, so that
it will have no privileges which that user would not have.  Therefore
it is necessary that usernames in the CVS `passwd' file be valid
usernames on the system.

   Right now, the only way to put a password in the CVS `passwd' file
is to paste it there from somewhere else.  Someday, there may be a `cvs
passwd' command.


File: cvs.info,  Node: Password authentication client,  Next: Password authentication security,  Prev: Password authentication server,  Up: Password authenticated

Using the client with password authentication
.............................................

   Before connecting to the server, the client must "log in" with the
command `cvs login'.  Logging in verifies a password with the server,
and also records the password for later transactions with the server.
The `cvs login' command needs to know the username, server hostname,
and full repository path, and it gets this information from the
repository argument or the `CVSROOT' environment variable.

   `cvs login' is interactive -- it prompts for a password:

     cvs -d bach@@chainsaw.brickyard.com:/usr/local/cvsroot login
     CVS password:

   The password is checked with the server; if it is correct, the
`login' succeeds, else it fails, complaining that the password was
incorrect.

   Once you have logged in, you can force CVS to connect directly to
the server and authenticate with the stored password by prefixing the
repository with `:pserver:':

     cvs -d :pserver:bach@@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo

   The `:pserver:' is necessary because without it, CVS will assume it
should use `rsh' to connect with the server (*note Connecting via
rsh::.).  (Once you have a working copy checked out and are running CVS
commands from within it, there is no longer any need to specify the
repository explicitly, because CVS records it in the working copy's
`CVS' subdirectory.)

   Passwords are stored by default in the file `$HOME/.cvspass'.  Its
format is human-readable, but don't edit it unless you know what you
are doing.  The passwords are not stored in cleartext, but are
trivially encoded to protect them from "innocent" compromise (i.e.,
inadvertently being seen by a system administrator who happens to look
at that file).

   The `CVS_PASSFILE' environment variable overrides this default.  If
you use this variable, make sure you set it *before* `cvs login' is
run.  If you were to set it after running `cvs login', then later CVS
commands would be unable to look up the password for transmission to
the server.

   The `CVS_PASSWORD' environment variable overrides *all* stored
passwords.  If it is set, CVS will use it for all password-authenticated
connections.


File: cvs.info,  Node: Password authentication security,  Prev: Password authentication client,  Up: Password authenticated

Security considerations with password authentication
....................................................

   The passwords are stored on the client side in a trivial encoding of
the cleartext, and transmitted in the same encoding.  The encoding is
done only to prevent inadvertent password compromises (i.e., a system
administrator accidentally looking at the file), and will not prevent
even a naive attacker from gaining the password.

   The separate CVS password file (*note Password authentication
server::.) allows people to use a different password for repository
access than for login access.  On the other hand, once a user has
access to the repository, she can execute programs on the server system
through a variety of means.  Thus, repository access implies fairly
broad system access as well.  It might be possible to modify CVS to
prevent that, but no one has done so as of this writing.  Furthermore,
there may be other security problems with CVS; it is not a simple
program and determining how people might use it to gain access to a
system is difficult.

   In summary, anyone who gets the password gets repository access, and
some measure of general system access as well.  The password is
available to anyone who can sniff network packets or read a protected
(i.e., user read-only) file.  If you want real security, get Kerberos.


File: cvs.info,  Node: Kerberos authenticated,  Prev: Password authenticated,  Up: Remote repositories

Direct connection with kerberos
-------------------------------

   The main disadvantage of using rsh is that all the data needs to
pass through additional programs, so it may be slower.  So if you have
kerberos installed you can connect via a direct TCP connection,
authenticating with kerberos (note that the data transmitted is *not*
encrypted).

   To do this, CVS needs to be compiled with kerberos support; when
configuring CVS it tries to detect whether kerberos is present or you
can use the `--with-krb4' flag to configure.

   You need to edit `inetd.conf' on the server machine to run `cvs
kserver'.  The client uses port 1999 by default; if you want to use
another port specify it in the `CVS_CLIENT_PORT' environment variable
on the client.  Set `CVS_CLIENT_PORT' to `-1' to force an rsh
connection.

   When you want to use CVS, get a ticket in the usual way (generally
`kinit'); it must be a ticket which allows you to log into the server
machine.  Then you are ready to go:

     cvs -d chainsaw.brickyard.com:/user/local/cvsroot checkout foo

   If CVS fails to connect, it will fall back to trying rsh.
d875 1
a875 1
awkward--to rename or move files.  *Note Moving files::.
d974 4
a977 3
   The next step is to define the module in the `modules' file.  This
is not strictly necessary, but modules can be convenient in grouping
together related files and directories.
a1037 2
* Concurrency::                 Simultaneous repository access
* Watches::                     Mechanisms to track who is editing files
d1063 306
@


1.1.1.3
log
@Some files missed by initial import
@
text
@d2 1
a2 1
file ../../ccvs/doc/cvs.texinfo.
d765 2
a766 2
     CVSROOT         CVSROOT
     modules         CVSROOT modules
d777 7
d959 6
a964 7
file does not exist, then the server tries to match the password using
the system's user-lookup routine.  When using the CVS `passwd' file,
the server runs under as the username specified in the the third
argument in the entry, or as the first argument if there is no third
argument (in this way CVS allows imaginary usernames provided the CVS
`passwd' file indicates corresponding valid system usernames).  In any
case, CVS will have no privileges which the (valid) user would not have.
@


1.1.1.4
log
@Files missed by previous import
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo-1.63 from the input
file ./cvs.texinfo.
d25 1
a25 1
File: cvs.info,  Node: Top,  Next: Preface,  Up: (dir)
d29 2
a30 2
   This info manual describes how to use and administer CVS version
1.8.1.
a48 1
* History browsing::            Viewing the history of files in various ways
d217 1
a217 1
CVS stores all the versions of a file in a single file in a clever way
d249 9
d1035 3
a1037 2
there may be other ways in which having access to CVS allows people to
gain more general access to the system; noone has done a careful audit.
d1105 1
a1105 2
* From other version control systems::  Old projects where you want to
                                        preserve history from another system.
d1109 1
a1109 1
File: cvs.info,  Node: From files,  Next: From other version control systems,  Up: Setting up the files
d1153 1
a1153 37
File: cvs.info,  Node: From other version control systems,  Next: From scratch,  Prev: From files,  Up: Setting up the files

Creating Files From Other Version Control Systems
-------------------------------------------------

   If you have a project which you are maintaining with another version
control system, such as RCS, you may wish to put the files from that
project into CVS, and preserve the revision history of the files.

From RCS
     If you have been using RCS, find the RCS files--usually a file
     named `foo.c' will have its RCS file in `RCS/foo.c,v' (but it
     could be other places; consult the RCS documentation for details).
     Then create the appropriate directories in CVS if they do not
     already exist.  Then copy the files into the appropriate
     directories in the CVS repository (the name in the repository must
     be the name of the source file with `,v' added; the files go
     directly in the appopriate directory of the repository, not in an
     `RCS' subdirectory).  This is one of the few times when it is a
     good idea to access the CVS repository directly, rather than using
     CVS commands.  Then you are ready to check out a new working
     directory.

From another version control system
     Many version control systems have the ability to export RCS files
     in the standard format.  If yours does, export the RCS files and
     then follow the above instructions.

From SCCS
     There is a script in the `contrib' directory of the CVS source
     distribution called `sccs2rcs' which converts SCCS files to RCS
     files.  Note: you must run it on a machine which has both SCCS and
     RCS installed, and like everything else in contrib it is
     unsupported (your mileage may vary).


File: cvs.info,  Node: From scratch,  Prev: From other version control systems,  Up: Setting up the files
d1247 25
@


1.1.1.5
log
@Missing files from import
@
text
@d1 1
a1 1
This is Info file cvs.info, produced by Makeinfo-1.55 from the input
d25 1
a25 1
File: cvs.info,  Node: Top,  Next: Preface,  Prev: (DIR),  Up: (DIR)
d30 1
a30 1
1.9.
d44 2
a45 2
* Adding files::                Adding files
* Removing files::              Removing files
d138 1
a138 1
     Careless use of the `admin' command can cause CVS to cease
d158 4
a161 4
   The CVS FAQ by David G. Grubbs has provided useful material.  The
FAQ is no longer maintained, however, and this manual about the closest
thing there is to a successor (with respect to documenting how to use
CVS, at least).
d218 1
a218 1
cVS stores all the versions of a file in a single file in a clever way
d243 6
a248 8
   There is a mailing list, known as `info-cvs', devoted to CVS.  To
subscribe or unsubscribe send a message to
`info-cvs-request@@prep.ai.mit.edu'.  Please be specific about your
email address.  As of May 1996, subscription requests are handled by a
busy human being, so you cannot expect to be added or removed
immediately.  The usenet group `comp.software.config-mgmt' is also a
suitable place for CVS discussions (along with other configuration
management systems).
d268 1
a268 1
     checked out.
d276 2
a277 1
     involved.
a281 5
     Figuring out what files need to be rebuilt when something changes
     is, again, something to be handled outside the scope of CVS.  One
     traditional approach is to use `make' for building, and use some
     automated tool for generating the depencies which `make' uses.

d314 31
a344 41
CVS does not have change control
     Change control refers to a number of things.  First of all it can
     mean "bug-tracking", that is being able to keep a database of
     reported bugs and the status of each one (is it fixed?  in what
     release?  has the bug submitter agreed that it is fixed?).  For
     interfacing CVS to an external bug-tracking system, see the
     `rcsinfo' and `editinfo' files (*note Administrative files::.).

     Another aspect of change control is keeping track of the fact that
     changes to several files were in fact changed together as one
     logical change.  If you check in several files in a single `cvs
     commit' operation, CVS then forgets that those files were checked
     in together, and the fact that they have the same log message is
     the only thing tying them together.  Keeping a GNU style
     `ChangeLog' can help somewhat.

     Another aspect of change control, in some systems, is the ability
     to keep track of the status of each change.  Some changes have
     been written by a developer, others have been reviewed by a second
     developer, and so on.  Generally, the way to do this with CVS is to
     generate a diff (using `cvs diff' or `diff') and email it to
     someone who can then apply it using the `patch' utility.  This is
     very flexible, but depends on mechanisms outside CVS to make sure
     nothing falls through the cracks.

CVS is not an automated testing program
     It should be possible to enforce mandatory use of a testsuite
     using the `commitinfo' file.  I haven't heard a lot about projects
     trying to do that or whether there are subtle gotchas, however.

CVS does not have a builtin process model
     Some systems provide ways to ensure that changes or releases go
     through various steps, with various approvals as needed.
     Generally, one can accomplish this with CVS but it might be a
     little more work.  In some cases you'll want to use the
     `commitinfo', `loginfo', `rcsinfo', or `editinfo' files, to
     require that certain steps be performed before cvs will allow a
     checkin.  Also consider whether features such as branches and tags
     can be used to perform tasks such as doing work in a development
     tree and then merging certain changes over to a stable tree only
     once they have been proven.
d352 10
a361 2
   CVS stores all files in a centralized "repository" (*note
Repository::.).
d363 3
a365 4
   The repository contains directories and files, in an arbitrary tree.
The "modules" feature can be used to group together a set of
directories or files into a single entity (*note modules::.).  A
typical usage is to define one module per project.
d483 1
a483 1
     $ ls
d600 2
a601 2
   The CVS "repository" stores a complete copy of all the files and
directories which are under version control.
d603 29
a631 44
   Normally, you never access any of the files in the repository
directly.  Instead, you use CVS commands to get your own copy of the
files, and then work on that copy.  When you've finished a set of
changes, you check (or "commit") them back into the repository.  The
repository then contains the changes which you have made, as well as
recording exactly what you changed, when you changed it, and other such
information.

   CVS can access a repository by a variety of means.  It might be on
the local computer, or it might be on a computer across the room or
across the world.  To distinguish various ways to access a repository,
the repository name can start with an "access method".  For example,
the access method `:local:' means to access a repository directory, so
the repository `:local:/usr/local/cvsroot' means that the repository is
in `/usr/local/cvsroot' on the computer running CVS.  For information
on other access methods, see *Note Remote repositories::.

   If the access method is omitted, then if the repository does not
contain `:', then `:local:' is assumed.  If it does contain `:' than
either `:ext:' or `:server:' is assumed.  For example, if you have a
local repository in `/usr/local/cvsroot', you can use
`/usr/local/cvsroot' instead of `:local:/usr/local/cvsroot'.  But if
(under Windows NT, for example) your local repository is
`c:\src\cvsroot', then you must specify the access method, as in
`:local:c:\src\cvsroot'.

   The repository is split in two parts.  `$CVSROOT/CVSROOT' contains
administrative files for CVS.  The other directories contain the actual
user-defined modules.

* Menu:

* Specifying a repository::     Telling CVS where your repository is
* Repository storage::          The structure of the repository
* Intro administrative files::  Defining modules
* Multiple repositories::       Multiple repositories
* Creating a repository::       Creating a repository
* Remote repositories::         Accessing repositories on remote machines


File: cvs.info,  Node: Specifying a repository,  Next: Repository storage,  Up: Repository

Telling CVS where your repository is
====================================
d658 11
a668 20
environment variable.  If `-d' option differs from `CVS/Root', the
former is used (and specifying `-d' will cause `CVS/Root' to be
updated).  Of course, for proper operation they should be two ways of
referring to the same repository.


File: cvs.info,  Node: Repository storage,  Next: Intro administrative files,  Prev: Specifying a repository,  Up: Repository

How data is stored in the repository
====================================

   For most purposes it isn't important *how* CVS stores information in
the repository.  In fact, the format has changed in the past, and is
likely to change in the future.  Since in almost all cases one accesses
the repository via CVS commands; such changes need not be disruptive.

   However, in some cases it may be necessary to understand how CVS
stores data in the repository, for example you might need to track down
CVS locks (*note Concurrency::.) or you might need to deal with the
file permissions appropriate for the repository.
d672 5
a676 2
* Repository files::            What files are stored in the repository
* File permissions::            File permissions
d679 1
a679 39
File: cvs.info,  Node: Repository files,  Next: File permissions,  Up: Repository storage

Where files are stored within the repository
--------------------------------------------

   The overall structure of the repository is a directory tree
corresponding to the directories in the working directory.  For
example, supposing the repository is in `/usr/local/cvsroot', here is a
possible directory tree (showing only the directories):

     /usr
      |
      +--local
      |   |
      |   +--cvsroot
      |   |    |
      |   |    +--CVSROOT
               |      (administrative files)
               |
               +--gnu
               |   |
               |   +--diff
               |   |   (source code to GNU diff)
               |   |
               |   +--rcs
               |   |   (source code to RCS)
               |   |
               |   +--cvs
               |       (source code to CVS)
               |
               +--yoyodyne
                   |
                   +--tc
                   |    |
                   |    +--man
                   |    |
                   |    +--testing
                   |
                   +--(other Yoyodyne software)
d681 2
a682 4
   With the directories are "history files" for each file under version
control.  The name of the history file is the name of the corresponding
file with `,v' appended to the end.  Here is what the repository for
the `yoyodyne/tc' directory might look like:
d704 12
a715 9
   The history files contain, among other things, enough information to
recreate any revision of the file, a log of all commit messages and the
user-name of the person who committed the revision.  The history files
are known as "RCS files", because the first program to store files in
that format was a version control system known as RCS.  For a full
description of the file format, see the `man' page `rcsfile(5)',
distributed with RCS.  This file format has become very common--many
systems other than CVS or RCS can at least import history files in this
format.
d718 1
a718 1
File: cvs.info,  Node: File permissions,  Prev: Repository files,  Up: Repository storage
a733 8
   Note that users must also have write access to check out files,
because CVS needs to create lock files (*note Concurrency::.).

   Also note that users must have write access to the
`CVSROOT/val-tags' file.  CVS uses it to keep track of what tags are
valid tag names (it is sometimes updated when tags are used, as well as
when they are created, though).

d737 1
a737 8
parent directory.  If you set the `CVSUMASK' environment variable that
will control the file permissions which CVS uses in creating directories
and/or files in the repository.  `CVSUMASK' does not affect the file
permissions in the working directory; such files have the permissions
which are typical for newly created files, except that sometimes CVS
creates them read-only (see the sections on watches, *Note Setting a
watch::; -r, *Note Global options::; or CVSREAD, *Note Environment
variables::).
d744 1
a744 1
File: cvs.info,  Node: Intro administrative files,  Next: Multiple repositories,  Prev: Repository storage,  Up: Repository
d767 1
a767 1
The last four lines in the example above are examples of such lines.
d796 6
a801 10
(once you have checked out a working directory) by simply allowing CVS
to use the repository that was used to check out the working directory
(*note Specifying a repository::.).

   The big advantage of having multiple repositories is that they can
reside on different servers.  The big disadvantage is that you cannot
have a single CVS command recurse into directories which comes from
different repositories.  Generally speaking, if you are thinking of
setting up several repositories on the same machine, you might want to
consider using several directories within the same repository.
d811 1
a811 21
   To set up a CVS repository, choose a directory with ample disk space
available for the revision history of the source files.  It should be
accessable (directly or via a networked file system) from all machines
which want to use CVS in server or local mode; the client machines need
not have any access to it other than via the CVS protocol.  It is not
possible to use CVS to read from a repository which one only has read
access to; CVS needs to be able to create lock files (*note
Concurrency::.).

   To create a repository, run the `cvs init' command.  It will set up
an empty repository in the CVS root specified in the usual way (*note
Repository::.).  For example,

     cvs -d /usr/local/cvsroot init

   `cvs init' is careful to never overwrite any existing files in the
repository, so no harm is done if you run `cvs init' on an already
set-up repository.

   `cvs init' will enable history logging; if you don't want that,
remove the history file after running `cvs init'.  *Note history file::.
d823 1
a823 1
     :METHOD:USER@@HOSTNAME:/path/to/repository
a827 4
   If METHOD is not specified, and the repository name contains `:',
then the default is `ext' or `server', depending on your platform; both
are described in *Note Connecting via rsh::.

d853 1
a853 1
     rsh -l bach chainsaw.brickyard.com 'echo $PATH'
a864 16
   There are two access methods that you use in CVSROOT for rsh.
`:server:' specifies an internal rsh client, which is supported only by
some CVS ports.  `:ext:' specifies an external rsh program.  By default
this is `rsh' but you may set the `CVS_RSH' environment variable to
invoke another program which can access the remote server (for example,
`remsh' on HP-UX 9 because `rsh' is something different).  It must be a
program which can transmit data to and from the server without modifying
it; for example the Windows NT `rsh' is not suitable since it by
default translates between CRLF and LF.  The OS/2 CVS port has a hack
to pass `-b' to `rsh' to get around this, but since this could
potentially cause programs for programs other than the standard `rsh',
it may change in the future.  If you set `CVS_RSH' to `SSH' or some
other rsh replacement, the instructions in the rest of this section
concerning `.rhosts' and so on are likely to be incorrect; consult the
documentation for your rsh replacement.

d869 1
a869 1
     cvs -d :ext:bach@@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo
d914 1
a914 2
binaries on the server.  You could also use the `-T' option to specify
a temporary directory.
d971 1
a971 1
     cvs -d :pserver:bach@@chainsaw.brickyard.com:/usr/local/cvsroot login
d979 2
a980 1
the server and authenticate with the stored password:
d1044 2
a1045 1
authenticating with kerberos.
a1050 5
   The data transmitted is *not* encrypted by default.  Encryption
support must be compiled into both the client and server; use the
`--enable-encryption' configure option to turn it on.  You must then
use the `-x' global option to request encryption.

d1054 2
a1055 1
on the client.
d1061 1
a1061 1
     cvs -d :kserver:chainsaw.brickyard.com:/user/local/cvsroot checkout foo
d1063 1
a1063 2
   Previous versions of CVS would fall back to a connection via rsh;
this version will not do so.
d1071 4
a1074 6
   Because renaming files and moving them between directories is
somewhat inconvenient, the first thing you do when you start a new
project should be to think through your file organization.  It is not
impossible to rename or move files, but it does increase the potential
for confusion and CVS does have some quirks particularly in the area of
renaming directories.  *Note Moving files::.
d1082 193
@


1.1.1.6
log
@Missed files from new release from Cyclic Software
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo-1.64 from the input
file ../../work/ccvs/doc/cvs.texinfo.
d25 1
a25 1
File: cvs.info,  Node: Top,  Next: Preface,  Up: (dir)
d30 1
a30 1
1.9.2.
a45 1
* Removing directories::        Removing directories
a51 2
* Builds::                      Issues related to CVS and builds
* Compatibility::               Upgrading CVS versions
d53 1
a53 2
* CVS commands::                CVS commands share some things
* Invoking CVS::                Quick reference to CVS commands
d147 4
a150 4
   Roland Pesch, then of Cygnus Support <roland@@wrs.com> wrote the
manual pages which were distributed with CVS 1.3.  Appendix A and B
contain much text that was extracted from them.  He also read an early
draft of this manual and contributed many ideas and corrections.
d218 1
a218 1
CVS stores all the versions of a file in a single file in a clever way
d240 2
a241 4
   You can get CVS via anonymous FTP from a number of sites; for
example see
     http://www.gnu.ai.mit.edu/order/ftp.html
   for a list of the GNU FTP sites.
d248 3
a250 14
immediately.  If you prefer a usenet group, the right group is
`comp.software.config-mgmt' which is for CVS discussions (along with
other configuration management systems).  In the future, it might be
possible to create a `comp.software.config-mgmt.cvs', but probably only
if there is sufficient CVS traffic on `comp.software.config-mgmt'.

   To report bugs in CVS send mail to `bug-cvs@@prep.ai.mit.edu'.  Do
note that someone may or may not feel like taking care of your bug
report--if you need a response consider a support contract from Cyclic
Software (`http://www.cyclic.com' or `info@@cyclic.com').  This is also
the procedure for submitting suggested changes to CVS (see the file
HACKING in the source distribution for more details).  Note that all
submitted changes may be distributed under the terms of the GNU Public
License, so if you don't like this, don't submit them.
d286 1
a286 4
     automated tool for generating the dependencies which `make' uses.

     See *Note Builds::, for more information on doing builds in
     conjunction with CVS.
d326 1
a326 1
     `rcsinfo' and `verifymsg' files (*note Administrative files::.).
d355 1
a355 1
     `commitinfo', `loginfo', `rcsinfo', or `verifymsg' files, to
d501 1
a501 1
files that you want to edit.  *Note Multiple developers::, for an
a649 1
* Read-only access::            Granting read-only access to the repository
a783 5
   The RCS files used in CVS differ in a few ways from the standard
format.  The biggest difference is magic branches; for more information
see *Note Magic branch numbers::.  Also in CVS the valid tag names are
a subset of what RCS accepts; for CVS's rules see *Note Tags::.

d897 8
a904 23
   To set up a CVS repository, first choose the machine and disk on
which you want to store the revision history of the source files.  CPU
and memory requirements are modest--a server with 32M of memory or even
less can handle a fairly large source tree with a fair amount of
activity.  To estimate disk space requirements, if you are importing
RCS files from another system, the size of those files is the
approximate initial size of your repository, or if you are starting
without any version history, a rule of thumb is to allow for the server
approximately three times the size of the code to be under CVS for the
repository (you will eventually outgrow this, but not for a while).  On
the machines on which the developers will be working, you'll want disk
space for approximately one working directory for each developer
(either the entire tree or a portion of it, depending on what each
developer uses).  Don't worry about CPU and memory requirements for the
clients--any machine with enough capacity to run the operating system in
question should have little trouble.

   The repository should be accessable (directly or via a networked
file system) from all machines which want to use CVS in server or local
mode; the client machines need not have any access to it other than via
the CVS protocol.  It is not possible to use CVS to read from a
repository which one only has read access to; CVS needs to be able to
create lock files (*note Concurrency::.).
d920 1
a920 1
File: cvs.info,  Node: Remote repositories,  Next: Read-only access,  Prev: Creating a repository,  Up: Repository
d926 2
a927 6
the repository.  Using CVS in this manner is known as "client/server"
operation.  You run CVS on a machine which can mount your working
directory, known as the "client", and tell it to communicate to a
machine which can mount the repository, known as the "server".
Generally, using a remote repository is just like using a local one,
except that the format of the repository name is:
d1054 1
a1054 1
(almost--see *Note Password authentication security::, for details), a
a1078 27
   It is possible to "map" cvs-specific usernames onto system usernames
(i.e., onto system login names) in the `$CVSROOT/CVSROOT/passwd' file
by appending a colon and the system username after the password.  For
example:

     cvs:ULtgRLXo7NRxs:kfogel
     generic:1sOp854gDF3DY:spwang
     anyone:1sOp854gDF3DY:spwang

   Thus, someone remotely accessing the repository on
`chainsaw.brickyard.com' with the following command:

     cvs -d :pserver:cvs@@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo

   would end up running the server under the system identity kfogel,
assuming successful authentication.  However, the remote user would not
necessarily need to know kfogel's system password, as the
`$CVSROOT/CVSROOT/passwd' file might contain a different password, used
only for CVS.  And as the example above indicates, it is permissible to
map multiple cvs usernames onto a single system username.

   This feature is designed to allow people repository access without
full system access (in particular, see *Note Read-only access::);
however, also *Note Password authentication security::.  Any sort of
repository access very likely implies a degree of general system access
as well.

d1129 85
@


1.1.1.7
log
@Files missed from previous import
@
text
@d30 1
a30 1
1.9.4.
d138 1
a138 1
     Keyword substitution can be a source of trouble with binary files.
d163 3
a165 3
FAQ is no longer maintained, however, and this manual is about the
closest thing there is to a successor (with respect to documenting how
to use CVS, at least).
a846 8
   Note that using the client/server CVS (*note Remote
repositories::.), there is no good way to set `CVSUMASK'; the setting
on the client machine has no effect.  If you are connecting with `rsh',
you can set `CVSUMASK' in `.bashrc' or `.cshrc', as described in the
documentation for your operating system.  This behavior might change in
future versions of CVS; do not rely on the setting of `CVSUMASK' on the
client having no effect.

a984 1
* Server requirements::         Memory and other resources for servers
d990 1
a990 29
File: cvs.info,  Node: Server requirements,  Next: Connecting via rsh,  Up: Remote repositories

Server requirements
-------------------

   The quick answer to what sort of machine is suitable as a server is
that requirements are modest--a server with 32M of memory or even less
can handle a fairly large source tree with a fair amount of activity.

   The real answer, of course, is more complicated.  The CVS server
consists of two processes for each client that it is serving.  Memory
consumption on the child process should remain fairly small.  Memory
consumption on the parent process, particularly if the network
connection to the client is slow, can be expected to grow to slightly
more than the size of the sources in a single directory, or two
megabytes, whichever is larger.

   Multiplying the size of each CVS server by the number of servers
which you expect to have active at one time should give an idea of
memory requirements for the server.  For the most part, the memory
consumed by the parent process probably can be swap space rather than
physical memory.

   Resource consumption for the client or the non-client/server CVS is
even more modest--any machine with enough capacity to run the operating
system in question should have little trouble.


File: cvs.info,  Node: Connecting via rsh,  Next: Password authenticated,  Prev: Server requirements,  Up: Remote repositories
d1030 1
a1030 1
potentially cause problems for programs other than the standard `rsh',
d1033 2
a1034 2
concerning `.rhosts' and so on are likely to be inapplicable; consult
the documentation for your rsh replacement.
d1154 47
@


1.1.1.8
log
@Latest release from Cyclic Software
@
text
@d30 1
a30 1
1.9.6.
d36 1
d41 1
a41 1
* Revisions and branches::      Numeric, symbolic, and branch revisions
d207 1
a207 1
File: cvs.info,  Node: What is CVS?,  Next: A sample session,  Prev: Preface,  Up: Top
d383 95
a477 1
File: cvs.info,  Node: A sample session,  Next: Repository,  Prev: What is CVS?,  Up: Top
d482 2
a483 4
   As a way of introducing CVS, we'll go through a typical work-session
using CVS.  The first thing to understand is that CVS stores all files
in a centralized "repository" (*note Repository::.); this section
assumes that a repository is set up.
a1190 77


File: cvs.info,  Node: Password authentication client,  Next: Password authentication security,  Prev: Password authentication server,  Up: Password authenticated

Using the client with password authentication
.............................................

   Before connecting to the server, the client must "log in" with the
command `cvs login'.  Logging in verifies a password with the server,
and also records the password for later transactions with the server.
The `cvs login' command needs to know the username, server hostname,
and full repository path, and it gets this information from the
repository argument or the `CVSROOT' environment variable.

   `cvs login' is interactive -- it prompts for a password:

     cvs -d :pserver:bach@@chainsaw.brickyard.com:/usr/local/cvsroot login
     CVS password:

   The password is checked with the server; if it is correct, the
`login' succeeds, else it fails, complaining that the password was
incorrect.

   Once you have logged in, you can force CVS to connect directly to
the server and authenticate with the stored password:

     cvs -d :pserver:bach@@chainsaw.brickyard.com:/usr/local/cvsroot checkout foo

   The `:pserver:' is necessary because without it, CVS will assume it
should use `rsh' to connect with the server (*note Connecting via
rsh::.).  (Once you have a working copy checked out and are running CVS
commands from within it, there is no longer any need to specify the
repository explicitly, because CVS records it in the working copy's
`CVS' subdirectory.)

   Passwords are stored by default in the file `$HOME/.cvspass'.  Its
format is human-readable, but don't edit it unless you know what you
are doing.  The passwords are not stored in cleartext, but are
trivially encoded to protect them from "innocent" compromise (i.e.,
inadvertently being seen by a system administrator who happens to look
at that file).

   The password for the currently choosen remote repository can be
removed from the CVS_PASSFILE by using the `cvs logout' command.

   The `CVS_PASSFILE' environment variable overrides this default.  If
you use this variable, make sure you set it *before* `cvs login' is
run.  If you were to set it after running `cvs login', then later CVS
commands would be unable to look up the password for transmission to
the server.


File: cvs.info,  Node: Password authentication security,  Prev: Password authentication client,  Up: Password authenticated

Security considerations with password authentication
....................................................

   The passwords are stored on the client side in a trivial encoding of
the cleartext, and transmitted in the same encoding.  The encoding is
done only to prevent inadvertent password compromises (i.e., a system
administrator accidentally looking at the file), and will not prevent
even a naive attacker from gaining the password.

   The separate CVS password file (*note Password authentication
server::.) allows people to use a different password for repository
access than for login access.  On the other hand, once a user has
access to the repository, she can execute programs on the server system
through a variety of means.  Thus, repository access implies fairly
broad system access as well.  It might be possible to modify CVS to
prevent that, but no one has done so as of this writing.  Furthermore,
there may be other ways in which having access to CVS allows people to
gain more general access to the system; noone has done a careful audit.

   In summary, anyone who gets the password gets repository access, and
some measure of general system access as well.  The password is
available to anyone who can sniff network packets or read a protected
(i.e., user read-only) file.  If you want real security, get Kerberos.
@


1.1.1.9
log
@Missing files from import
@
text
@d30 1
a30 1
1.9.8.
d196 1
a196 2
     bug-cvs@@prep.ai.mit.edu.  This is also the address for reporting
     bugs in CVS.
d438 1
a438 3
decide to make a new version of `backend.c'.  This will store your new
`backend.c' in the repository and make it available to anyone else who
is using that same repository.
d449 3
a451 17
are not set then there is a default which will vary with your operating
system, for example `vi' for unix or `notepad' for Windows NT/95.

   When CVS starts the editor, it includes a list of files which are
modified.  For the CVS client, this list is based on comparing the
modification time of the file against the modification time that the
file had when it was last gotten or updated.  Therefore, if a file's
modification time has changed but its contents have not, it will show
up as modified.  The simplest way to handle this is simply not to worry
about it--if you proceed with the commit CVS will detect that the
contents are not modified and treat it as an unmodified file.  The next
`update' will clue CVS in to the fact that the file is unmodified, and
it will reset its stored timestamp so that the file will not show up in
future editor sessions.

   If you want to avoid starting an editor you can specify the log
message on the command line using the `-m' flag instead, like this:
a572 1
* Working directory storage::   The structure of working directories
d616 1
a616 1
File: cvs.info,  Node: Repository storage,  Next: Working directory storage,  Prev: Specifying a repository,  Up: Repository
a634 1
* Attic::                       Some files are stored in the Attic
d681 1
d718 1
a718 1
File: cvs.info,  Node: File permissions,  Next: Attic,  Prev: Repository files,  Up: Repository storage
d767 1
a767 178
File: cvs.info,  Node: Attic,  Prev: File permissions,  Up: Repository storage

The attic
---------

   You will notice that sometimes CVS stores an RCS file in the
`Attic'.  For example, if the CVSROOT is `/usr/local/cvsroot' and we are
talking about the file `backend.c' in the directory `yoyodyne/tc', then
the file normally would be in

     /usr/local/cvsroot/yoyodyne/tc/backend.c,v

   but if it goes in the attic, it would be in

     /usr/local/cvsroot/yoyodyne/tc/Attic/backend.c,v

   instead.  It should not matter from a user point of view whether a
file is in the attic; CVS keeps track of this and looks in the attic
when it needs to.  But in case you want to know, the rule is that the
RCS file is stored in the attic if and only if the head revision on the
trunk has state `dead'.  A `dead' state means that file has been
removed, or never added, for that revision.  For example, if you add a
file on a branch, it will have a trunk revision in `dead' state, and a
branch revision in a non-`dead' state.


File: cvs.info,  Node: Working directory storage,  Next: Intro administrative files,  Prev: Repository storage,  Up: Repository

How data is stored in the working directory
===========================================

   While we are discussing CVS internals which may become visible from
time to time, we might as well talk about what CVS puts in the `CVS'
directories in the working directories.  As with the repository, CVS
handles this information and one can usually access it via CVS
commands.  But in some cases it may be useful to look at it, and other
programs, such as the `jCVS' graphical user interface or the `VC'
package for emacs, may need to look at it.  Such programs should follow
the recommendations in this section if they hope to be able to work
with other programs which use those files, including future versions of
the programs just mentioned and the command-line CVS client.

   The `CVS' directory contains several files.  Programs which are
reading this directory should silently ignore files which are in the
directory but which are not documented here, to allow for future
expansion.

`Root'
     This file contains the current CVS root, as described in *Note
     Specifying a repository::.

`Repository'
     This file contains the directory within the repository which the
     current directory corresponds with.  For historical reasons it is
     an absolute pathname, although it would make more sense for it to
     be relative to the root.  For example, after the command

          cvs -d :local:/usr/local/cvsroot checkout yoyodyne/tc

     `Root' will contain

          :local:/usr/local/cvsroot

     and `Repository' will contain

          /usr/local/cvsroot/yoydyne/tc

`Entries'
     This file lists the files and directories in the working
     directory.  It is a text file according to the conventions
     appropriate for the operating system in question.  The first
     character of each line indicates what sort of line it is.  If the
     character is unrecognized, programs reading the file should
     silently skip that line, to allow for future expansion.

     If the first character is `/', then the format is:

          /NAME/REVISION/TIMESTAMP[+CONFLICT]/OPTIONS/TAGDATE

     where `[' and `]' are not part of the entry, but instead indicate
     that the `+' and conflict marker are optional.  NAME is the name
     of the file within the directory.  REVISION is the revision that
     the file in the working derives from, or `0' for an added file, or
     `-' followed by a revision for a removed file.  TIMESTAMP is the
     timestamp of the file at the time that CVS created it; if the
     timestamp differs with the actual modification time of the file it
     means the file has been modified.  CONFLICT indicates that there
     was a conflict; if it is the same as the actual modification time
     of the file it means that the user has obviously not resolved the
     conflict.  OPTIONS contains sticky options (for example `-kb' for a
     binary file).  TAGDATE contains `T' followed by a tag name, or `D'
     for a date, followed by a sticky tag or date.  Note that if
     TIMESTAMP contains a pair of timestamps separated by a space,
     rather than a single timestamp, you are dealing with a version of
     CVS earlier than CVS 1.5 (not documented here).

     If the first character of a line in `Entries' is `D', then it
     indicates a subdirectory.  `D' on a line all by itself indicates
     that the program which wrote the `Entries' file does record
     subdirectories (therefore, if there is such a line and no other
     lines beginning with `D', one knows there are no subdirectories).
     Otherwise, the line looks like:

          D/NAME/FILLER1/FILLER2/FILLER3/FILLER4

     where NAME is the name of the subdirectory, and all the FILLER
     fields should be silently ignored, for future expansion.  Programs
     which modify `Entries' files should preserve these fields.

`Entries.Log'
     This file does not record any information beyond that in
     `Entries', but it does provide a way to update the information
     without having to rewrite the entire `Entries' file, including the
     ability to preserve the information even if the program writing
     `Entries' and `Entries.Log' abruptly aborts.  The format of a line
     in `Entries.Log' is a single character command followed by a space
     followed by a line in the format specified for a line in
     `Entries'.  The single character command is `A' to indicate that
     the entry is being added, `R' to indicate that the entry is being
     removed, or any other character to indicate that the entire line
     in `Entries.Log' should be silently ignored (for future
     expansion).  If the second character of the line in `Entries.Log'
     is not a space, then it was written by an older version of CVS
     (not documented here).

`Entries.Backup'
     This is a temporary file.  Recommended usage is to write a new
     entries file to `Entries.Backup', and then to rename it
     (atomically, where possible) to `Entries'.

`Entries.Static'
     The only relevant thing about this file is whether it exists or
     not.  If it exists, then it means that only part of a directory
     was gotten and CVS will not create additional files in that
     directory.  To clear it, use the `update' command with the `-d'
     option, which will get the additional files and remove
     `Entries.Static'.

`Tag'
     This file contains per-directory sticky tags or dates.  The first
     character is `T' for a branch tag, `N' for a non-branch tag, or
     `D' for a date, or another character to mean the file should be
     silently ignored, for future expansion.  This character is
     followed by the tag or date.  Note that per-directory sticky tags
     or dates are used for things like applying to files which are
     newly added; they might not be the same as the sticky tags or
     dates on individual files.  For general information on sticky tags
     and dates, see *Note Sticky tags::.

`Checkin.prog'
`Update.prog'
     These files store the programs specified by the `-i' and `-u'
     options in the modules file, respectively.

`Notify'
     This file stores notifications (for example, for `edit' or
     `unedit') which have not yet been sent to the server.  Its format
     is not yet documented here.

`Notify.tmp'
     This file is to `Notify' as `Entries.Backup' is to `Entries'.
     That is, to write `Notify', first write the new contents to
     `Notify.tmp' and then (atomically where possible), rename it to
     `Notify'.

`Base'
     If watches are in use, then an `edit' command stores the original
     copy of the file in the `Base' directory.  This allows the
     `unedit' command to operate even if it is unable to communicate
     with the server.

`Template'
     This file contains the template specified by the `rcsinfo' file
     (*note rcsinfo::.).  It is only used by the client; the
     non-client/server CVS consults `rcsinfo' directly.


File: cvs.info,  Node: Intro administrative files,  Next: Multiple repositories,  Prev: Working directory storage,  Up: Repository
d988 187
@


1.1.1.10
log
@Missing files from initial import
@
text
@d30 1
a30 1
1.9.10.
d93 19
d151 3
a153 3
manual pages which were distributed with CVS 1.3.  Much of their text
was copied into this manual.  He also read an early draft of this
manual and contributed many ideas and corrections.
d167 5
a171 13
mistakes I've made:

     Roxanne Brunskill <rbrunski@@datap.ca>,
     Kathy Dyer <dyer@@phoenix.ocf.llnl.gov>,
     Karl Pingle <pingle@@acuson.com>,
     Thomas A Peterson <tap@@src.honeywell.com>,
     Inge Wallin <ingwa@@signum.se>,
     Dirk Koschuetzki <koschuet@@fmi.uni-passau.de>
     and Michael Brown <brown@@wi.extrel.com>.

   The list of contributors here is not comprehensive; for a more
complete list of who has contributed to this manual see the file
`doc/ChangeLog' in the CVS source distribution.
d179 26
a204 76
   Neither CVS nor this manual is perfect, and they probably never will
be.  If you are having trouble using CVS, or think you have found a
bug, there are a number of things you can do about it.  Note that if
the manual is unclear, that can be considered a bug in the manual, so
these problems are often worth doing something about as well as
problems with CVS itself.

   * If you want someone to help you and fix bugs that you report,
     there are companies which will do that for a fee.  Two such
     companies are:

          Signum Support AB
          Box 2044
          S-580 02  Linkoping
          Sweden
          Email: info@@signum.se
          Phone: +46 (0)13 - 21 46 00
          Fax:   +46 (0)13 - 21 47 00
          http://www.signum.se/
          
          Cyclic Software
          United States of America
          http://www.cyclic.com/
          info@@cyclic.com

   * If you got CVS through a distributor, such as an operating system
     vendor or a vendor of freeware CD-ROMs, you may wish to see
     whether the distributor provides support.  Often, they will provide
     no support or minimal support, but this may vary from distributor
     to distributor.

   * If you have the skills and time to do so, you may wish to fix the
     bug yourself.  If you wish to submit your fix for inclusion in
     future releases of CVS, see the file HACKING in the CVS source
     distribution.  It contains much more information on the process of
     submitting fixes.

   * There may be resources on the net which can help.  Two good places
     to start are:

          http://www.cyclic.com
            particularly the Unsupported Resources page
          http://www.loria.fr/~molli/cvs-index.html

     If you are so inspired, increasing the information available on
     the net is likely to be appreciated.  For example, before the
     standard CVS distribution worked on Windows 95, there was a web
     page with some explanation and patches for running CVS on Windows
     95, and various people helped out by mentioning this page on
     mailing lists or newsgroups when the subject came up.

   * It is also possible to report bugs to `bug-cvs'.  Note that
     someone may or may not want to do anything with your bug
     report--if you need a solution consider one of the options
     mentioned above.  People probably do want to hear about bugs which
     are particularly severe in consequences and/or easy to fix,
     however.  You can also increase your odds by being as clear as
     possible about the exact nature of the bug and any other relevant
     information.  The way to report bugs is to send email to
     `bug-cvs@@prep.ai.mit.edu'.  Note that submissions to `bug-cvs' may
     be distributed under the terms of the GNU Public License, so if
     you don't like this, don't submit them.  There is usually no
     justification for sending mail directly to one of the CVS
     maintainers rather than to `bug-cvs'; those maintainers who want
     to hear about such bug reports read `bug-cvs'.  Also note that
     sending a bug report to other mailing lists or newsgroups is *not*
     a substitute for sending it to `bug-cvs'.  It is fine to discuss
     CVS bugs on whatever forum you prefer, but there are not
     necessarily any maintainers reading bug reports sent anywhere
     except `bug-cvs'.

   People often ask if there is a list of known bugs or whether a
particular bug is a known one.  The file BUGS in the CVS source
distribution is one list of known bugs, but it doesn't necessarily try
to be comprehensive.  Perhaps there will never be a comprehensive,
detailed list of known bugs.
d235 4
a238 4
posted to the newsgroup `comp.sources.unix' in the volume 6 release of
December, 1986.  While no actual code from these shell scripts is
present in the current version of CVS much of the CVS conflict
resolution algorithms come from them.
d260 8
a267 3
   You can also subscribe to the bug-cvs mailing list, described in
more detail in *Note BUGS::.  To subscribe send mail to
bug-cvs-request@@prep.ai.mit.edu.
d558 5
a562 7
files into a "working directory", and then work on that copy.  When
you've finished a set of changes, you check (or "commit") them back
into the repository.  The repository then contains the changes which
you have made, as well as recording exactly what you changed, when you
changed it, and other such information.  Note that the repository is
not a subdirectory of the working directory, or vice versa; they should
be in separate locations.
a593 2
* Backing up::                  Backing up a repository
* Moving a repository::         Moving a repository
a595 1
* Server temporary directory::  The server creates temporary directories
d663 2
a664 5
example, supposing the repository is in

     /usr/local/cvsroot

here is a possible directory tree (showing only the directories):
d871 3
a873 10
     means the file has been modified.  It is in Universal Time (UT),
     stored in the format used by the ISO C asctime() function (for
     example, `Sun Apr  7 01:29:26 1996').  One may write a string
     which is not in that format, for example, `Result of merge', to
     indicate that the file should always be considered to be modified.
     This is not a special case; to see whether a file is modified a
     program should take the timestamp of the file and simply do a
     string compare with TIMESTAMP.  CONFLICT indicates that there was
     a conflict; if it is the same as the actual modification time of
     the file it means that the user has obviously not resolved the
d899 10
a908 14
     `Entries' and `Entries.Log' abruptly aborts.  Programs which are
     reading the `Entries' file should also check for `Entries.Log'.
     If the latter exists, they should read `Entries' and then apply
     the changes mentioned in `Entries.Log'.  After applying the
     changes, the recommended practice is to rewrite `Entries' and then
     delete `Entries.Log'.  The format of a line in `Entries.Log' is a
     single character command followed by a space followed by a line in
     the format specified for a line in `Entries'.  The single
     character command is `A' to indicate that the entry is being added,
     `R' to indicate that the entry is being removed, or any other
     character to indicate that the entire line in `Entries.Log' should
     be silently ignored (for future expansion).  If the second
     character of the line in `Entries.Log' is not a space, then it was
     written by an older version of CVS (not documented here).
d1028 1
a1028 1
File: cvs.info,  Node: Creating a repository,  Next: Backing up,  Prev: Multiple repositories,  Up: Repository
d1071 4
a1074 1
File: cvs.info,  Node: Backing up,  Next: Moving a repository,  Prev: Creating a repository,  Up: Repository
d1076 104
a1179 2
Backing up a repository
=======================
d1181 2
a1182 32
   There is nothing particularly magical about the files in the
repository; for the most part it is possible to back them up just like
any other files.  However, there are a few issues to consider.

   The first is that to be paranoid, one should either not use CVS
during the backup, or have the backup program lock CVS while doing the
backup.  To not use CVS, you might forbid logins to machines which can
access the repository, turn off your CVS server, or similar mechanisms.
The details would depend on your operating system and how you have CVS
set up.  To lock CVS, you would create `#cvs.rfl' locks in each
repository directory.  See *Note Concurrency::, for more on CVS locks.
Having said all this, if you just back up without any of these
precautions, the results are unlikely to be particularly dire.
Restoring from backup, the repository might be in an inconsistent
state, but this would not be particularly hard to fix manually.

   When you restore a repository from backup, assuming that changes in
the repository were made after the time of the backup, working
directories which were not affected by the failure may refer to
revisions which no longer exist in the repository.  Trying to run CVS
in such directories will typically produce an error message.  One way
to get those changes back into the repository is as follows:

   * Get a new working directory.

   * Copy the files from the working directory from before the failure
     over to the new working directory (do not copy the contents of the
     `CVS' directories, of course).

   * Working in the new working directory, use commands such as `cvs
     update' and `cvs diff' to figure out what has changed, and then
     when you are ready, commit the changes into the repository.
@


1.1.1.11
log
@Latest version from Cyclic; files missed in first run
@
text
@d25 1
a25 1
File: cvs.info,  Node: Top,  Next: Overview,  Up: (dir)
d30 1
a30 1
1.9.24.
d34 3
a36 1
* Overview::                    An introduction to CVS
d39 3
a41 2
* Revisions::                   Numeric and symbolic names for revisions
* Branching and merging::       Diverging/rejoining branches of development
d43 6
a48 1
* Adding and removing::         Adding/removing/renaming files/directories
d50 1
a50 3

CVS and the Real World.
----------------------
d52 2
a53 1
* Multiple developers::         How CVS helps a group of developers
a54 6
* Keyword substitution::        CVS can include the revision inside the file
* Tracking sources::            Tracking third-party sources
* Builds::                      Issues related to CVS and builds

References.
----------
a58 1
* Compatibility::               Upgrading CVS versions
a59 2
* Credits::                     Some of the contributors to this manual
* BUGS::                        Dealing with bugs in CVS or this manual
d64 1
a64 4
File: cvs.info,  Node: Overview,  Next: Repository,  Prev: Top,  Up: Top

Overview
********
d66 2
a67 2
   This chapter is for people who have never used CVS, and perhaps have
never used version control software before.
d69 23
a91 3
   If you are already familiar with CVS and are just trying to learn a
particular feature or remember a certain command, you can probably skip
everything here.
d95 149
a243 3
* What is CVS?::                What you can do with CVS
* What is CVS not?::            Problems CVS doesn't try to solve
* A sample session::            A tour of basic CVS usage
d246 1
a246 1
File: cvs.info,  Node: What is CVS?,  Next: What is CVS not?,  Up: Overview
d249 1
a249 1
============
d283 4
a286 6
   You can get CVS in a variety of ways, including free download from
the internet.  For more information on downloading CVS and other CVS
topics, see:

     http://www.cyclic.com/
     http://www.loria.fr/~molli/cvs-index.html
d301 1
a301 1
bug-cvs-request@@gnu.org.
d303 2
a304 5

File: cvs.info,  Node: What is CVS not?,  Next: A sample session,  Prev: What is CVS?,  Up: Overview

What is CVS not?
================
d417 1
a417 1
File: cvs.info,  Node: A sample session,  Prev: What is CVS not?,  Up: Overview
d420 1
a420 1
================
d443 1
a443 1
------------------
d470 1
a470 1
-----------------------
d510 1
a510 1
-----------
d557 1
a557 1
-------------------
d582 1
a582 1
File: cvs.info,  Node: Repository,  Next: Starting a new project,  Prev: Overview,  Up: Top
d610 1
a610 1
contain `:', then `:local:' is assumed.  If it does contain `:' then
d642 3
a644 3
   There are several ways to tell CVS where to find the repository.
You can name the repository on the command line explicitly, with the
`-d' (for "directory") option:
d650 2
a651 2
example.  To set `$CVSROOT', `csh' and `tcsh' users should have this
line in their `.cshrc' or `.tcshrc' files:
d681 1
a681 1
the repository via CVS commands, such changes need not be disruptive.
a691 1
* Windows permissions::         Issues specific to Windows
a692 3
* CVS in repository::           Additional information in CVS directory
* Locks::                       CVS locks control concurrent accesses
* CVSROOT storage::             A few things about CVSROOT are different
d768 3
a770 3
distributed with RCS, or the file `doc/RCSFILES' in the CVS source
distribution.  This file format has become very common--many systems
other than CVS or RCS can at least import history files in this format.
d778 1
a778 1
File: cvs.info,  Node: File permissions,  Next: Windows permissions,  Prev: Repository files,  Up: Repository storage
d800 1
a800 5
when they are created).

   Each RCS file will be owned by the user who last checked it in.
This has little significance; what really matters is who owns the
directories.
d822 3
a824 38
   Using pserver, you will generally need stricter permissions on the
CVSROOT directory and directories above it in the tree; see *Note
Password authentication security::.

   Some operating systems have features which allow a particular
program to run with the ability to perform operations which the caller
of the program could not.  For example, the set user ID (setuid) or set
group ID (setgid) features of unix or the installed image feature of
VMS.  CVS was not written to use such features and therefore attempting
to install CVS in this fashion will provide protection against only
accidental lapses; anyone who is trying to circumvent the measure will
be able to do so, and depending on how you have set it up may gain
access to more than just CVS.  You may wish to instead consider
pserver.  It shares some of the same attributes, in terms of possibly
providing a false sense of security or opening security holes wider
than the ones you are trying to fix, so read the documentation on
pserver security carefully if you are considering this option (*Note
Password authentication security::).


File: cvs.info,  Node: Windows permissions,  Next: Attic,  Prev: File permissions,  Up: Repository storage

File Permission issues specific to Windows
------------------------------------------

   Some file permission issues are specific to Windows operating
systems (Windows 95, Windows NT, and presumably future operating
systems in this family.  Some of the following might apply to OS/2 but
I'm not sure).

   If you are using local CVS and the repository is on a networked file
system which is served by the Samba SMB server, some people have
reported problems with permissions.  Enabling WRITE=YES in the samba
configuration is said to fix/workaround it.  Disclaimer: I haven't
investigated enough to know the implications of enabling that option,
nor do I know whether there is something which CVS could be doing
differently in order to avoid the problem.  If you find something out,
please let us know as described in *Note BUGS::.
d827 1
a827 1
File: cvs.info,  Node: Attic,  Next: CVS in repository,  Prev: Windows permissions,  Up: Repository storage
a852 111
File: cvs.info,  Node: CVS in repository,  Next: Locks,  Prev: Attic,  Up: Repository storage

The CVS directory in the repository
-----------------------------------

   The `CVS' directory in each repository directory contains
information such as file attributes (in a file called `CVS/fileattr';
see fileattr.h in the CVS source distribution for more documentation).
In the future additional files may be added to this directory, so
implementations should silently ignore additional files.

   This behavior is implemented only by CVS 1.7 and later; for details
see *Note Watches Compatibility::.


File: cvs.info,  Node: Locks,  Next: CVSROOT storage,  Prev: CVS in repository,  Up: Repository storage

CVS locks in the repository
---------------------------

   For an introduction to CVS locks focusing on user-visible behavior,
see *Note Concurrency::.  The following section is aimed at people who
are writing tools which want to access a CVS repository without
interfering with other tools acessing the same repository.  If you find
yourself confused by concepts described here, like "read lock", "write
lock", and "deadlock", you might consult the literature on operating
systems or databases.

   Any file in the repository with a name starting with `#cvs.rfl' is a
read lock.  Any file in the repository with a name starting with
`#cvs.wfl' is a write lock.  Old versions of CVS (before CVS 1.5) also
created files with names starting with `#cvs.tfl', but they are not
discussed here.  The directory `#cvs.lock' serves as a master lock.
That is, one must obtain this lock first before creating any of the
other locks.

   To obtain a readlock, first create the `#cvs.lock' directory.  This
operation must be atomic (which should be true for creating a directory
under most operating systems).  If it fails because the directory
already existed, wait for a while and try again.  After obtaining the
`#cvs.lock' lock, create a file whose name is `#cvs.rfl' followed by
information of your choice (for example, hostname and process
identification number).  Then remove the `#cvs.lock' directory to
release the master lock.  Then proceed with reading the repository.
When you are done, remove the `#cvs.rfl' file to release the read lock.

   To obtain a writelock, first create the `#cvs.lock' directory, as
with a readlock.  Then check that there are no files whose names start
with `#cvs.rfl'.  If there are, remove `#cvs.lock', wait for a while,
and try again.  If there are no readers, then create a file whose name
is `#cvs.wfl' followed by information of your choice (for example,
hostname and process identification number).  Hang on to the
`#cvs.lock' lock.  Proceed with writing the repository.  When you are
done, first remove the `#cvs.wfl' file and then the `#cvs.lock'
directory. Note that unlike the `#cvs.rfl' file, the `#cvs.wfl' file is
just informational; it has no effect on the locking operation beyond
what is provided by holding on to the `#cvs.lock' lock itself.

   Note that each lock (writelock or readlock) only locks a single
directory in the repository, including `Attic' and `CVS' but not
including subdirectories which represent other directories under
version control.  To lock an entire tree, you need to lock each
directory (note that if you fail to obtain any lock you need, you must
release the whole tree before waiting and trying again, to avoid
deadlocks).

   Note also that CVS expects writelocks to control access to
individual `foo,v' files.  RCS has a scheme where the `,foo,' file
serves as a lock, but CVS does not implement it and so taking out a CVS
writelock is recommended.  See the comments at rcs_internal_lockfile in
the CVS source code for further discussion/rationale.


File: cvs.info,  Node: CVSROOT storage,  Prev: Locks,  Up: Repository storage

How files are stored in the CVSROOT directory
---------------------------------------------

   The `$CVSROOT/CVSROOT' directory contains the various administrative
files.  In some ways this directory is just like any other directory in
the repository; it contains RCS files whose names end in `,v', and many
of the CVS commands operate on it the same way.  However, there are a
few differences.

   For each administrative file, in addition to the RCS file, there is
also a checked out copy of the file.  For example, there is an RCS file
`loginfo,v' and a file `loginfo' which contains the latest revision
contained in `loginfo,v'.  When you check in an administrative file,
CVS should print

     cvs commit: Rebuilding administrative file database

and update the checked out copy in `$CVSROOT/CVSROOT'.  If it does not,
there is something wrong (*note BUGS::.).  To add your own files to the
files to be updated in this fashion, you can add them to the
`checkoutlist' administrative file.

   By default, the `modules' file behaves as described above.  If the
modules file is very large, storing it as a flat text file may make
looking up modules slow (I'm not sure whether this is as much of a
concern now as when CVS first evolved this feature; I haven't seen
benchmarks).  Therefore, by making appropriate edits to the CVS source
code one can store the modules file in a database which implements the
`ndbm' interface, such as Berkeley db or GDBM.  If this option is in
use, then the modules database will be stored in the files `modules.db',
`modules.pag', and/or `modules.dir'.

   For information on the meaning of the various administrative files,
see *Note Administrative files::.


d880 3
a882 7
     current directory corresponds with.  It can be either an absolute
     pathname or a relative pathname; CVS has had the ability to read
     either format since at least version 1.3 or so.  The relative
     pathname is relative to the root, and is the more sensible
     approach, but the absolute pathname is quite common and
     implementations should accept either.  For example, after the
     command
d890 1
a890 1
     and `Repository' will contain either
d892 1
a892 5
          /usr/local/cvsroot/yoyodyne/tc

     or

          yoyodyne/tc
a1008 14
`Baserev'
     The file lists the revision for each of the files in the `Base'
     directory.  The format is:

          BNAME/REV/EXPANSION

     where EXPANSION should be ignored, to allow for future expansion.

`Baserev.tmp'
     This file is to `Baserev' as `Entries.Backup' is to `Entries'.
     That is, to write `Baserev', first write the new contents to
     `Baserev.tmp' and then (atomically where possible), rename it to
     `Baserev'.

d1088 14
a1101 12
and memory requirements are modest, so most machines should be
adequate.  For details see *Note Server requirements::.

   To estimate disk space requirements, if you are importing RCS files
from another system, the size of those files is the approximate initial
size of your repository, or if you are starting without any version
history, a rule of thumb is to allow for the server approximately three
times the size of the code to be under CVS for the repository (you will
eventually outgrow this, but not for a while).  On the machines on
which the developers will be working, you'll want disk space for
approximately one working directory for each developer (either the
entire tree or a portion of it, depending on what each developer uses).
d1122 39
@


1.1.1.12
log
@Latest version from Cyclic; files missed in first run
@
text
@d1 2
a2 2
This is Info file cvs.info, produced by Makeinfo version 1.67 from the
input file ../../work/ccvs/doc/cvs.texinfo.
d30 1
a30 1
1.9.26.
a50 1
* Special Files::		Devices, links and other non-regular files
d394 1
a394 1
   You decide to play it safe and answer `n <RET>' when `release' asks
@


1.1.1.13
log
@Latest version from Cyclic; skipped files
@
text
@a3 4
START-INFO-DIR-ENTRY
* CVS: (cvs).          Concurrent Versions System
END-INFO-DIR-ENTRY

d13 4
a16 2
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.
d20 3
a22 2
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.
d30 1
a30 1
1.9.28.
d63 1
@


1.1.1.14
log
@Latest version from Cyclic; skipped files
@
text
@d2 1
a2 1
input file ./cvs.texinfo.
d31 1
a31 1
1.10.
d131 9
a139 6
subscribe or unsubscribe write to `info-cvs-request@@gnu.org'.  If you
prefer a usenet group, the right group is `comp.software.config-mgmt'
which is for CVS discussions (along with other configuration management
systems).  In the future, it might be possible to create a
`comp.software.config-mgmt.cvs', but probably only if there is
sufficient CVS traffic on `comp.software.config-mgmt'.
@


1.1.1.15
log
@Latest version from Cyclic; skipped files
@
text
@d2 1
a2 1
input file ../../work/ccvs/doc/cvs.texinfo.
d31 1
a31 1
1.10.5.
a330 6
   In addition, CVS checks the `$VISUAL' environment variable.
Opinions vary on whether this behavior is desirable and whether future
releases of CVS should check `$VISUAL' or ignore it.  You will be OK
either way if you make sure that `$VISUAL' is either unset or set to
the same thing as `$EDITOR'.

d367 1
a367 1
     Are you sure you want to release (and delete) directory `tc': n
d421 1
a421 1
     Are you sure you want to release (and delete) directory `tc': y
d510 3
a512 2
former is used.  Of course, for proper operation they should be two
ways of referring to the same repository.
a869 6
   The files are stored according to the text file convention for the
system in question.  This means that working directories are not
portable between systems with differing conventions for storing text
files.  This is intentional, on the theory that the files being managed
by CVS probably will not be portable between such systems either.

a897 4
     If the particular working directory does not correspond to a
     directory in the repository, then `Repository' should contain
     `CVSROOT/Emptydir'.

d899 6
a904 4
     This file lists the files and directories in the working directory.
     The first character of each line indicates what sort of line it
     is.  If the character is unrecognized, programs reading the file
     should silently skip that line, to allow for future expansion.
a946 2
     The lines in the `Entries' file can be in any order.

a966 3
     Programs which are writing rather than reading can safely ignore
     `Entries.Log' if they so choose.

d1090 48
a1137 16
reside on different servers.  With CVS version 1.10, a single command
cannot recurse into directories from different repositories.  With
development versions of CVS, you can check out code from multiple
servers into your working directory.  CVS will recurse and handle all
the details of making connections to as many server machines as
necessary to perform the requested command.  Here is an example of how
to set up a working directory:

     cvs -d server1:/cvs co dir1
     cd dir1
     cvs -d server2:/root co sdir
     cvs update

   The `cvs co' commands set up the working directory, and then the
`cvs update' command will contact server2, to update the dir1/sdir
subdirectory, and server1, to update everything else.
@


1.1.1.16
log
@Latest version from Cyclic; skipped files
@
text
@d1 2
a2 1
This is cvs.info, produced by Makeinfo version 3.12f from ./cvs.texinfo.
d31 1
a31 1
1.10.7.
d45 1
a45 1
-----------------------
d55 1
a55 1
-----------
d169 1
a169 1
     But you have to remember that _any_ such system is a lot of work
d525 1
a525 1
   For most purposes it isn't important _how_ CVS stores information in
d749 2
a750 1
information such as file attributes (in a file called `CVS/fileattr'.
a756 63
   The format of the fileattr file is a series of entries of the
following form (where `{' and `}' means the text between the braces can
be repeated zero or more times):

   ENT-TYPE FILENAME <tab> ATTRNAME = ATTRVAL   {; ATTRNAME = ATTRVAL}
<linefeed>

   ENT-TYPE is `F' for a file, in which case the entry specifies the
attributes for that file.

   ENT-TYPE is `D', and FILENAME empty, to specify default attributes
to be used for newly added files.

   Other ENT-TYPE are reserved for future expansion.  CVS 1.9 and older
will delete them any time it writes file attributes.  CVS 1.10 and
later will preserve them.

   Note that the order of the lines is not significant; a program
writing the fileattr file may rearrange them at its convenience.

   There is currently no way of quoting tabs or linefeeds in the
filename, `=' in ATTRNAME, `;' in ATTRVAL, etc.  Note: some
implementations also don't handle a NUL character in any of the fields,
but implementations are encouraged to allow it.

   By convention, ATTRNAME starting with `_' is for an attribute given
special meaning by CVS; other ATTRNAMEs are for user-defined attributes
(or will be, once implementations start supporting user-defined
attributes).

   Builtin attributes:

`_watched'
     Present means the file is watched and should be checked out
     read-only.

`_watchers'
     Users with watches for this file.  Value is WATCHER > TYPE { ,
     WATCHER > TYPE } where WATCHER is a username, and TYPE is zero or
     more of edit,unedit,commit separated by `+' (that is, nothing if
     none; there is no "none" or "all" keyword).

`_editors'
     Users editing this file.  Value is EDITOR > VAL { , EDITOR > VAL }
     where EDITOR is a username, and VAL is TIME+HOSTNAME+PATHNAME,
     where TIME is when the `cvs edit' command (or equivalent) happened,
     and HOSTNAME and PATHNAME are for the working directory.

   Example:

     Ffile1 _watched=;_watchers=joe>edit,mary>commit
     Ffile2 _watched=;_editors=sue>8 Jan 1975+workstn1+/home/sue/cvs
     D _watched=

   means that the file `file1' should be checked out read-only.
Furthermore, joe is watching for edits and mary is watching for
commits.  The file `file2' should be checked out read-only; sue started
editing it on 8 Jan 1975 in the directory `/home/sue/cvs' on the
machine `workstn1'.  Future files which are added should be checked out
read-only.  To represent this example here, we have shown a space after
`D', `Ffile1', and `Ffile2', but in fact there must be a single tab
character there and no spaces.

d771 2
a772 2
   Any file in the repository with a name starting with `#cvs.rfl.' is
a read lock.  Any file in the repository with a name starting with
d783 1
a783 1
`#cvs.lock' lock, create a file whose name is `#cvs.rfl.' followed by
d791 1
a791 1
with `#cvs.rfl.'.  If there are, remove `#cvs.lock', wait for a while,
d838 1
a838 1
`checkoutlist' administrative file (*note checkoutlist::.).
d930 10
a939 12
     means the file has been modified.  It is stored in the format used
     by the ISO C asctime() function (for example, `Sun Apr  7 01:29:26
     1996').  One may write a string which is not in that format, for
     example, `Result of merge', to indicate that the file should
     always be considered to be modified.  This is not a special case;
     to see whether a file is modified a program should take the
     timestamp of the file and simply do a string compare with
     TIMESTAMP.  If there was a conflict, CONFLICT can be set to the
     modification time of the file after the file has been written with
     conflict markers (*note Conflicts example::.).  Thus if CONFLICT
     is subsequently the same as the actual modification time of the
     file it means that the user has obviously not resolved the
a946 9
     The timezone on the timestamp in CVS/Entries (local or universal)
     should be the same as the operating system stores for the
     timestamp of the file itself.  For example, on Unix the file's
     timestamp is in universal time (UT), so the timestamp in
     CVS/Entries should be too.  On VMS, the file's timestamp is in
     local time, so CVS on VMS should use local time.  This rule is so
     that files do not appear to be modified merely because the
     timezone changed (for example, to or from summer time).

d1049 75
@


1.1.1.17
log
@Latest from Cyclic Software
@
text
@d1 1
a1 1
This is cvs.info, produced by makeinfo version 4.0 from ./cvs.texinfo.
d30 1
a30 1
1.11.
d126 1
a126 1
     http://www.cvshome.org/
d221 1
a221 1
     `rcsinfo' and `verifymsg' files (*note Administrative files::).
d265 1
a265 1
in a centralized "repository" (*note Repository::); this section
d365 1
a365 1
but a better way is to use the `release' command (*note release::):
d531 2
a532 2
CVS locks (*note Concurrency::) or you might need to deal with the file
permissions appropriate for the repository.
d645 1
a645 1
because CVS needs to create lock files (*note Concurrency::).
d665 1
a665 1
watch::; -r, *Note Global options::; or `CVSREAD', *Note Environment
d668 7
a674 7
   Note that using the client/server CVS (*note Remote repositories::),
there is no good way to set `CVSUMASK'; the setting on the client
machine has no effect.  If you are connecting with `rsh', you can set
`CVSUMASK' in `.bashrc' or `.cshrc', as described in the documentation
for your operating system.  This behavior might change in future
versions of CVS; do not rely on the setting of `CVSUMASK' on the client
having no effect.
d897 1
a897 1
there is something wrong (*note BUGS::).  To add your own files to the
d899 1
a899 1
`checkoutlist' administrative file (*note checkoutlist::).
d1000 9
a1008 9
     conflict markers (*note Conflicts example::).  Thus if CONFLICT is
     subsequently the same as the actual modification time of the file
     it means that the user has obviously not resolved the conflict.
     OPTIONS contains sticky options (for example `-kb' for a binary
     file).  TAGDATE contains `T' followed by a tag name, or `D' for a
     date, followed by a sticky tag or date.  Note that if TIMESTAMP
     contains a pair of timestamps separated by a space, rather than a
     single timestamp, you are dealing with a version of CVS earlier
     than CVS 1.5 (not documented here).
d1119 1
a1119 1
     (*note rcsinfo::).  It is only used by the client; the
@


1.1.1.18
log
@Latest from Cyclic Software
@
text
@d1 1
a1 1
This is cvs.info, produced by makeinfo version 4.0 from cvs.texinfo.
d30 1
a30 1
1.11.1p1.
@


