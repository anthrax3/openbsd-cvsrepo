head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.13.0.64
	OPENBSD_6_2_BASE:1.1.1.13
	OPENBSD_6_1:1.1.1.13.0.66
	OPENBSD_6_1_BASE:1.1.1.13
	OPENBSD_6_0:1.1.1.13.0.62
	OPENBSD_6_0_BASE:1.1.1.13
	OPENBSD_5_9:1.1.1.13.0.58
	OPENBSD_5_9_BASE:1.1.1.13
	OPENBSD_5_8:1.1.1.13.0.60
	OPENBSD_5_8_BASE:1.1.1.13
	OPENBSD_5_7:1.1.1.13.0.52
	OPENBSD_5_7_BASE:1.1.1.13
	OPENBSD_5_6:1.1.1.13.0.56
	OPENBSD_5_6_BASE:1.1.1.13
	OPENBSD_5_5:1.1.1.13.0.54
	OPENBSD_5_5_BASE:1.1.1.13
	OPENBSD_5_4:1.1.1.13.0.50
	OPENBSD_5_4_BASE:1.1.1.13
	OPENBSD_5_3:1.1.1.13.0.48
	OPENBSD_5_3_BASE:1.1.1.13
	OPENBSD_5_2:1.1.1.13.0.46
	OPENBSD_5_2_BASE:1.1.1.13
	OPENBSD_5_1_BASE:1.1.1.13
	OPENBSD_5_1:1.1.1.13.0.44
	OPENBSD_5_0:1.1.1.13.0.42
	OPENBSD_5_0_BASE:1.1.1.13
	OPENBSD_4_9:1.1.1.13.0.40
	OPENBSD_4_9_BASE:1.1.1.13
	OPENBSD_4_8:1.1.1.13.0.38
	OPENBSD_4_8_BASE:1.1.1.13
	OPENBSD_4_7:1.1.1.13.0.34
	OPENBSD_4_7_BASE:1.1.1.13
	OPENBSD_4_6:1.1.1.13.0.36
	OPENBSD_4_6_BASE:1.1.1.13
	OPENBSD_4_5:1.1.1.13.0.32
	OPENBSD_4_5_BASE:1.1.1.13
	OPENBSD_4_4:1.1.1.13.0.30
	OPENBSD_4_4_BASE:1.1.1.13
	OPENBSD_4_3:1.1.1.13.0.28
	OPENBSD_4_3_BASE:1.1.1.13
	OPENBSD_4_2:1.1.1.13.0.26
	OPENBSD_4_2_BASE:1.1.1.13
	OPENBSD_4_1:1.1.1.13.0.24
	OPENBSD_4_1_BASE:1.1.1.13
	OPENBSD_4_0:1.1.1.13.0.22
	OPENBSD_4_0_BASE:1.1.1.13
	OPENBSD_3_9:1.1.1.13.0.20
	OPENBSD_3_9_BASE:1.1.1.13
	OPENBSD_3_8:1.1.1.13.0.18
	OPENBSD_3_8_BASE:1.1.1.13
	OPENBSD_3_7:1.1.1.13.0.16
	OPENBSD_3_7_BASE:1.1.1.13
	OPENBSD_3_6:1.1.1.13.0.14
	OPENBSD_3_6_BASE:1.1.1.13
	OPENBSD_3_5:1.1.1.13.0.12
	OPENBSD_3_5_BASE:1.1.1.13
	OPENBSD_3_4:1.1.1.13.0.10
	OPENBSD_3_4_BASE:1.1.1.13
	OPENBSD_3_3:1.1.1.13.0.8
	OPENBSD_3_3_BASE:1.1.1.13
	OPENBSD_3_2:1.1.1.13.0.6
	OPENBSD_3_2_BASE:1.1.1.13
	OPENBSD_3_1:1.1.1.13.0.4
	OPENBSD_3_1_BASE:1.1.1.13
	OPENBSD_3_0:1.1.1.13.0.2
	OPENBSD_3_0_BASE:1.1.1.13
	cvs-1-11-1p1:1.1.1.13
	OPENBSD_2_9:1.1.1.12.0.2
	OPENBSD_2_9_BASE:1.1.1.12
	cvs-1-11:1.1.1.12
	OPENBSD_2_8:1.1.1.11.0.8
	OPENBSD_2_8_BASE:1.1.1.11
	OPENBSD_2_7:1.1.1.11.0.6
	OPENBSD_2_7_BASE:1.1.1.11
	OPENBSD_2_6:1.1.1.11.0.4
	OPENBSD_2_6_BASE:1.1.1.11
	cvs-1-10-7:1.1.1.11
	OPENBSD_2_5:1.1.1.11.0.2
	OPENBSD_2_5_BASE:1.1.1.11
	cvs-1-10-5:1.1.1.11
	OPENBSD_2_4:1.1.1.10.0.4
	OPENBSD_2_4_BASE:1.1.1.10
	cvs-1-10:1.1.1.10
	cvs-1-9-28:1.1.1.10
	OPENBSD_2_3:1.1.1.10.0.2
	OPENBSD_2_3_BASE:1.1.1.10
	cvs-1-9-26:1.1.1.10
	cvs-1-9-24:1.1.1.9
	OPENBSD_2_2:1.1.1.8.0.2
	OPENBSD_2_2_BASE:1.1.1.8
	cvs-1-9-10:1.1.1.8
	OPENBSD_2_1:1.1.1.7.0.2
	OPENBSD_2_1_BASE:1.1.1.7
	cvs-1-9-8:1.1.1.7
	cvs-1-9-6:1.1.1.6
	cvs-1-9-4:1.1.1.6
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.3
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@# @;


1.1
date	95.12.19.09.21.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.26;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.01;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.04.27.19.40.49;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.34.33;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.36.05;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.03.18.01.54.59;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.04.21.04.24.52;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.06.28.03.27.50;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	98.02.22.08.19.51;	author tholo;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	98.03.12.06.57.17;	author tholo;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	99.02.28.21.30.25;	author tholo;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2001.02.10.18.57.18;	author tholo;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2001.09.28.22.45.35;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@$CVSid: @@(#)TODO 1.26 94/09/21 $

14. Pathname stripper, for checkout, as well as for writing the
    Repository file.
    [[ I have a simple one, but need to make sure to call it at all the
       appropriate points ]]
    (I'm not sure what this means -kingdon, Jun 1995).

16. List of current users of a directory needs to be maintained.
    [[ sort of solved by history database ]]

22. Catch signals for cleanup when "add"ing files.

24. Insist on a log message.
    (This should be configurable via commitinfo or some new config file
    -kingdon, Jun 1995).

30. Add "patch" program option to the modules database.

31. Think hard about ^C recovery.

35. Add "admin" command as an interface to "rcs".
    [[ a cheesy version is there, but it should be re-done ]]

38. Think hard about using RCS state information to allow one to checkin
    a new vendor release without having it be accessed until it has been
    integrated into the local changes.

39. Think about allowing parallel source trees that can easily track
    each other.
    [[ sort of solved with the automagic branch support, but I want more ]]

45. Consider enhancing the "patch" and "tag" command support in the module
    database -- they seem hard to use since these commands deal directly
    with the RCS ,v files.

46. Perhaps checkout/checkin/tag/patch commands should be imbedded in the
    file system directly, using special known command names?

49. cvs xxx commands should be able to deal with files in other
    directories.  I want to do a cvs add foo/bar.c.
    [[ most commands now use the generic recursion processor, but not all;
    this note is left here to remind me to fix the others ]]

51. a way to identify what files other people are working on.  Imagine "cvs
    modified", which prints out a table like 

	file	modifiers
	=====	=========
	foo.c
	bar.c	wsd
	baz.c	nrt jda

    I think this would be pretty difficult; I don't know if this
    information is stored anywhere.  Also it's hard to say how one gets a
    user name, maybe a path to their local hierarchy is all you could get.
    [[ the history stuff does some of this, but not all ]]

52. SCCS has a feature that I would *love* to see in CVS, as it is very
    useful.  One may make a private copy of SCCS suid to a particular user,
    so other users in the authentication list may check files in and out of
    a project directory without mucking about with groups.  Is there any
    plan to provide a similar functionality to CVS?  Our site (and, I'd
    imagine, many other sites with large user bases) has decided against
    having the user-groups feature of unix available to the users, due to
    perceived administrative, technical and performance headaches.  A tool
    such as CVS with features that provide group-like functionality would
    be a huge help.

53. I'd suggest a way to notify users if/when a file(s) is being worked on.
    I suggest:
	+ Always checkout/update files a readonly.
	+ To work on a file, the user should do:
		cvs advise filename
	+ This would maintain their email address associated with that
	  file name in the repository and change the file mode to writable.
	+ If other references to that file exist, the registered individuals
	  are notified via email that another user(s) is going to be working
	  on same.
	+ When a committ occurs, the user is automatically 'unadvise'd (the
	  inverse command should be supported as well) and other's are notified
	  that a merge will be necessary before their checkin can be
	  successful.

62. Consider using revision controlled files and directories to handle the
    new module format -- consider a cvs command front-end to
    add/delete/modify module contents, maybe.

63. The "import" and vendor support commands (co -j) need to be documented
    better.

64. Need to greatly increase the performance of an initial checkout.
    [[ it got better, then we added functionality, making it worse again ]]

66. Length of the CVS temporary files must be limited to 14 characters for
    System-V stupid support.  As weel as the length on the CVS.adm files.

67. cvs import should populate the vendor sources with CVS.adm files so
    that one could use the vendor sources directly without having the check
    them out.

69. Consider enhacing import to add a module automatically to the module
    database.  Perhaps with a new option, or perhaps with an editor.

72. Consider re-design of the module -o, -i, -t options to use the file
    system more intuitively.

73. Consider an option (in .cvsrc?) to automatically add files that are new
    and specified to commit.

74. Consider adding a way to remove directories/files that you are done
    with... somehow.
    [[ cvs release sort of does this ]]

76. Consider adding a layer of abstraction so that CVS can work with both
    RCS and SCCS files.  Larry says this should be #ifdef'ed.

79. Might be nice to have some sort of interface to TFS and tagged
    revisions.

82. Maybe the import stuff should allow an arbitrary revision to be
    specified.

84. Improve the documentation about administration of the repository and
    how to add/remove files and the use of symbolic links.

85. Add revision controlled symbolic links to CVS using one of the tag
    fields in the RCS file.

91. Better document the format of the source repository and how one might
    convert their current SCCS or RCS files into CVS format.

92. Look into this:
	After a bit of soul searching via dbx, I realized my sin was that I'd
	specified "echo" as the program to call from loginfo. The commit
	procedure worked fine till it hit my echo, then silently aborted
	leaving the lockfiles intact. Since I needn't use the loginfo
	facility, I simply removed those commands and it all works.

93. Need to think hard about release and development environments.  Think
    about execsets as well.

97. The documentation should describe how to undo a change ("cvs
update -j 1.2 -j 1.1 foo.c" followed by a commit undoes the change
from 1.1 to 1.2).

98. If diff3 bombs out (too many differences) cvs then thinks that the file
    has been updated and is OK to be commited even though the file 
    has not yet been merged.

100. Checked out files should have revision control support.  Maybe.

102. Perhaps directory modes should be propagated on all import check-ins.
     Not necessarily uid/gid changes.

103. setuid/setgid on files is suspect.

104. cvs should recover nicely on unreadable files/directories.

105. cvs should have administrative tools to allow for changing permissions
     and modes and what not.  In particular, this would make cvs a
     more attractive alternative to rdist.

107. It should be possible to specify a list of symbolic revisions to
     checkout such that the list is processed in reverse order looking for
     matches within the RCS file for the symbolic revision.  If there is
     not a match, the next symbolic rev on the list is checked, and so on,
     until all symbolic revs are exhausted.  This would allow one to, say,
     checkout "4.0" + "4.0.3" + "4.0.3Patch1" + "4.0.3Patch2" to get the
     most recent 4.x stuff.  This is usually handled by just specifying the
     right release_tag, but most people forget to do this.

108. If someone creates a whole new directory (i.e. adds it to the cvs
     repository) and you happen to have a directory in your source farm by
     the same name, when you do your cvs update -d it SILENTLY does
     *nothing* to that directory.  At least, I think it was silent;
     certainly, it did *not* abort my cvs update, as it would have if the
     same thing had happened with a file instead of a directory.

109. I had gotten pieces of the sys directory in the past but not a
     complete tree.  I just did something like:

        cvs get *

     Where sys was in * and got the message

        cvs get: Executing 'sys/tools/make_links sys'
        sh: sys/tools/make_links: not found

     I suspect this is because I didn't have the file in question,
     but I do not understand how I could fool it into getting an
     error.  I think a later cvs get sys seemed to work so perhaps
     something is amiss in handling multiple arguments to cvs get?

113. The "cvs update" command should tee its output to a log file in ".".
     (why?  What is wrong with piping stdout to "tee"? -kingdon, Jun 1995)

115. I still think "cvs modules" is a good idea.
   Since everything else is inside cvs, "mkmodules" should be in there too:

   Add a "modules" (synonym "mod") command directly in cvs.
   ("checkout -c" is not really intuitive.  I'd move it into "mod -s".)

   "mod"		Print database as typed. (line count as record id?)
   "mod -s"		Print the sorted database (as "checkout -c" does now)
   "mod -m"		Internal replacement for "mkmodules" command.
   "mod module ..."	Print the raw dbm record for the named modules
   "mod -p module ..."	Print relative filenames contained in modules.(no ",v")
   "mod -l module ..."	Prints more info about relative filenames ("ls -l"?)
   "mod -f file ..."	Tells you what module(s) the filenames are in.

119. Consider an option to have import checkout the RCS or SCCS files
     if necessary.

122. If Name_Repository fails, it currently causes CVS to die completely.  It
     should instead return NULL and have the caller do something reasonable.

123. Add a flag to import to not build vendor branches for local code.

124. Anyway, I thought you might want to add something like the following
     to the cvs and mkmodules man pages:

     BUGS
 	The sum of the sizes of a module key and its contents are
 	limited.  See ndbm(3).

126. Do an analysis to see if CVS is forgetting to close file descriptors.
     Especially when committing many files (more than the open file limit
     for the particular UNIX).

127. Look at *info files; they should all be quiet if the files are not
     there.  Should be able to point at a RCS directory and go.

128. When I tag a file, the message tells me that I'm tagging a directory.

129. Something strange seems to have happened here.  When I check this out,
     the update lines (U CFTS/...) seem to report a bogus leading CFTS
     (e.g. U CFTS/Medusa_TS/...) when the later files are checked out.

     The directory structure doesn't seem to be botched, just the
     messages.  I don't recall seeing this before.

130. cvs diff with no -r arguments does not need to look up the current RCS
     version number since it only cares about what's in the Entries file.
     This should make it much faster.

     It should ParseEntries itself and access the entries list much like
     Version_TS does (sticky tags and sticky options may need to be
     supported here as well).  Then it should only diff the things that
     have the wrong time stamp (the ones that look modified).

134. Make a statement about using hard NFS mounts to your source
     repository.  Look into checking NULL fgets() returns with ferror() to
     see if an error had occurred.

135. The email CVS sends with each checkin, should include the version
     number of each file it is checking in.
     [[ Sort of solved by contrib/log.pl, which does a good job of this ]]

137. Some sites might want CVS to fsync() the RCS ,v file to protect
     against nasty hardware errors.  There is a slight performance hit with
     doing so, though, so it should be configurable in the .cvsrc file.
     Also, along with this, we should look at the places where CVS itself
     could be a little more synchronous so as not to lose data.
     [[ I've done some of this, but it could use much more ]]

138. Some people have suggested that CVS use a VPATH-like environment
     variable to limit the amount of sources that need to be duplicated for
     sites with giant source trees and no disk space.

141. Import should accept modules as its directory argument.

143. Update the documentation to show that the source repository is
     something far away from the files that you work on.

144. Have cvs checkout look for the environment variable CVSPREFIX
     (or CVSMODPREFIX or some such).  If it's set, then when looking
     up an alias in the modules database, first look it up with the
     value of CVSPREFIX attached, and then look for the alias itself.
     This would be useful when you have several projects in a single
     repository.  You could have aliases abc_src and xyz_src and
     tell people working on project abc to put "setenv CVSPREFIX abc_"
     in their .cshrc file (or equivalent for other shells).
     Then they could do "cvs co src" to get a copy of their src
     directory, not xyz's.  (This should create a directory called
     src, not abc_src.)

145. After you create revision 1.1.1.1 in the previous scenario, if
     you do "cvs update -r1 filename" you get revision 1.1, not
     1.1.1.1.  It would be nice to get the later revision.  Again,
     this restriction comes from RCS and is probably hard to
     change in CVS.  Sigh.

     |"cvs update -r1 filename" does not tell RCS to follow any branches.  CVS
     |tries to be consistent with RCS in this fashion, so I would not change
     |this.  Within CVS we do have the flexibility of extending things, like
     |making a revision of the form "-r1HEAD" find the most recent revision
     |(branch or not) with a "1." prefix in the RCS file.  This would get what
     |you want maybe.
      
     This would be very useful.  Though I would prefer an option
     such as "-v1" rather than "-r1HEAD".  This option might be
     used quite often.

146. The merging of files should be controlled via a hook so that programs
     other than "rcsmerge" can be used, like Sun's filemerge or emacs's
     emerge.el.  (but be careful in making this work client/server--it means
     doing the interactive merging at the end after the server is done).

149. On Sun, 2 Feb 92 22:01:38 EST, rouilj@@dl5000.bc.edu (John P. Rouillard)
     said:
     Maybe there should be an option to cvs admin that allows a user to
     change the Repository file with some degree of error checking?
     Something like "cvs admin reposmv /old/path /new/pretty/path".  Before
     it does the replace it check to see that the files
     /new/pretty/path/<dir>/<files> exist.

150. I have a customer request for a way to specify log message per
     file, non-interactively before the commit, such that a single, fully
     recursive commit prompts for one commit message, and concatenates the
     per file messages for each file.  In short, one commit, one editor
     session, log messages allowed to vary across files within the commit.
     Also, the per file messages should be allowed to be written when the
     files are changed, which may predate the commit considerably.

     A new command seems appropriate for this.  The state can be saved in the
     CVS directory.  I.e.,
 
        % cvs msg foo.c
        Enter log message for foo.c
        >> fixed an uninitialized variable
        >> ^D

     The text is saved as CVS/foo.c,m (or some such name) and commit is
     modified to append (prepend?) the text (if found) to the log message
     specified at commit time.  Easy enough.

151. Also, is there a flag I am missing that allows replacing Ulrtx_Build
     by Ultrix_build?  I.E. I would like a tag replacement to be a one step
     operation rather than a two step "cvs rtag -r Ulrtx_Build Ultrix_Build"
     followed by "cvs trag -d Ulrtx_Build"

152. The "cvs -n" option does not work as one would expect for all the
     commands.  In particular, for "commit" and "import", where one would
     also like to see what it would do, without actually doing anything.

153. There should be some command (maybe I just haven't figured
     out which one...) to import a source directory which is already
     RCS-administered without losing all prior RCS gathered data.  Thus, it
     would have to examine the RCS files and choose a starting version and
     branch higher than previous ones used.

154. When committing the modules file, a pre-commit check should be done to
     verify the validity of the new modules file before allowing it to be
     committed.  This could easily be done by adding an option to mkmodules
     to perform the verification.

155. The options for "cvs history" are mutually exclusive, even though
     useful queries can be done if they are not, as in specifying both a
     module and a tag.  A workaround is to specify the module, then run the
     output through grep to only display lines that begin with T, which are
     tag lines.

156. Also, how hard would it be to allow continuation lines in the
     {commit,rcs,log}info files? It would probably be useful with all of
     the various flags that are now available, or if somebody has a lot of
     files to put into a module.

157. The "cvs release" command does not understand about module names with
     the same flexibility that the "checkout" and "rdiff" commands do.
     It should, though, since it's confusing right now.

158. If I do a recursive commit and find that the same RCS file is checked
     out (and modified!) in two different places within my checked-out
     files (but within the realm of a single "commit"), CVS will commit the
     first change, then overwrite that change with the second change.  We
     should catch this (typically unusual) case and issue an appropriate
     diagnostic and die.

159. On "update", when a merge is done, CVS should remember that your file
     was merged into and should keep reminding you of this fact until you
     actually look at the file (change its access time).  Once you do this,
     it should go back to being a normal, unmodified file.  This way, after
     a big update, you can run update again to see which files just got
     merged and may need attention.

160. The checks that the commit command does should be extended to make
     sure that the revision that we will lock is not already locked by
     someone else.  Maybe it should also lock the new revision if the old
     revision was already locked by the user as well, thus moving the lock
     forward after the commit.

161. The date parser included with CVS (lib/getdate.y) does not support
     such RCS-supported dates as "1992/03/07".  It probably should.

163. The rtag/tag commands should have an option that removes the specified
     tag from any file that is in the attic.  This allows one to re-use a
     tag (like "Mon", "Tue", ...) all the time and still have it tag the
     real main-line code.

164. The *info files should allow multiple ocurrences of $CVSROOT and/or
     other cvs variables.  They probably should *not* expand environment
     variables, as their behavior probably should not depend on who is 
     running CVS.

165. The "import" command will create RCS files automatically, but will
     screw-up when trying to create long file names on short file name
     file systems.  Perhaps import should be a bit more cautious.

166. There really needs to be a "Getting Started" document which describes
     some of the new CVS philosophies.  Folks coming straight from SCCS or
     RCS might be confused by "cvs import".  Also need to explain:
		- How one might setup their $CVSROOT
		- What all the tags mean in an "import" command
		- Tags are important; revision numbers are not

167. "cvs log" doesn't understand about CVS magic branch numbers.  As such,
     the command:

		cvs log -r1.63.2
		cvs log -rC2

     where "C2" is a magic branch that resolves to 1.63.2 do not print the
     same things.  Sigh.

169. We are using CVS as the configuration control for a software reuse library.
     What we do is do system calls passing the needed arguments. In the next
     release, it would be nice to see an option to put cvs .o files into a
     archive library with an API. This enhancement would go nicely with the
     notion of being able to integrate tools into a large software engineering
     environment.

170. Is there an "info" file that can be invoked when a file is checked out, or
     updated ?  What I want to do is to advise users, particularly novices, of
     the state of their working source whenever they check something out, as
     a sanity check.
 
     For example, I've written a perl script which tells you what branch you're
     on, if any.  Hopefully this will help guard against mistaken checkins to
     the trunk, or to the wrong branch.  I suppose I can do this in
     "commitinfo", but it'd be nice to advise people before they edit their
     files.
  
     It would also be nice if there was some sort of "verboseness" switch to
     the checkout and update commands that could turn this invocation of the
     script off, for mature users.

173. We have a tagged branch in CVS.  How do we get the version of that branch
     (for an entire directory) that corresponds to the files on that branch on a
     certain day?  I'd like to specify BOTH -r and -D to 'cvs checkout', but I
     can't.  It looks like I can only specify the date for the main line (as
     opposed to any branches).  True?  Any workarounds to get what I need?

174. I would like to see "cvs release" modified so that it only removes files
     which are known to CVS - all the files in the repository, plus those which
     are listed in .cvsignore.  This way, if you do leave something valuable in
     a source tree you can "cvs release -d" the tree and your non-CVS goodies
     are still there.  If a user is going to leave non-CVS files in their source
     trees, they really should have to clean them up by hand.

175. And, in the feature request department, I'd dearly love a command-line
     interface to adding a new module to the CVSROOT/modules file.

176. If you use the -i flag in the modules file, you can control access
     to source code; this is a Good Thing under certain circumstances. I
     just had a nasty thought, and on experiment discovered that the
     filter specified by -i is _not_ run before a cvs admin command; as
     this allows a user to go behind cvs's back and delete information
     (cvs admin -o1.4 file) this seems like a serious problem.

177. We've got some external vendor source that sits under a source code
     hierarchy, and when we do a cvs update, it gets wiped out because
     its tag is different from the "main" distribution. I've tried to
     use "-I" to ignore the directory, as well as .cvsignore, but this
     doesn't work.

179. "cvs admin" does not log its actions with loginfo, nor does it check
     whether the action is allowed with commitinfo.  It should.
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d9 3
d45 14
d70 15
d96 1
a96 1
    System-V stupid support.  As well as the length on the CVS.adm files.
d111 4
d142 4
@


1.1.1.3
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d158 14
d181 1
a181 1
     to the cvs man pages:
d315 2
a316 1
     committed.
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d12 2
a13 2
    (If done, this should be configurable via commitinfo or some new
    config file -kingdon, Jun 1995).
d19 3
d26 10
a35 9
39. Think about a version of "cvs update -j" which remembers what from
    that other branch is already merged.  This has pitfalls--it could
    easily lead to invisible state which could confuse users very
    rapidly--but having to create a tag or some such mechanism to keep
    track of what has been merged is a pain.

45. Consider enhancing the "rdiff" and "tag" (rtag??) command support in
    the module database -- they seem hard to use since these commands
    deal directly with the RCS ,v files.
d66 7
d79 3
d94 3
d159 1
a159 4
     if necessary.  (this is if someone want to import something which is
     in RCS or SCCS without preserving the history, but making sure they
     do get the latest versions.  It isn't clear to me how useful that is
     -kingdon, June 1996).
d162 1
a162 3
     should instead return NULL and have the caller do something reasonable
     (???  -what is reasonable?  I'm not sure there is a real problem here.
     -kingdon, June 1996).
d182 7
d200 1
a200 2
     see if an error had occurred.  (we should be checking for errors, quite
     aside from NFS issues -kingdon, June 1996).
a254 4
     (probably best is to have CVS do the non-interactive part and
     tell the user about where the files are (.#foo.c.working and
     .#foo.c.1.5 or whatever), so they can do the interactive part at
     that point -kingdon, June 1996).
d282 1
a282 3
     specified at commit time.  Easy enough.  (having cvs commit be
     non-interactive takes care of various issues like whether to connect
     to the server before or after prompting for a message -kingdon, June 1996)
d314 4
d325 7
d346 5
d362 9
a423 22

180. "cvs edit" should show you who is already editing the files,
     probably (that is, do "cvs editors" before executing, or some
     similar result).  (But watch out for what happens if the network
     is down!).

181.  Make a "cvs message" command which prompts for a log message and
     stores it in the CVS directory.  Then "cvs ci" would use it.
     This solves the problem with where in the client to prompt for
     the log message (see comment in commit.c at call to
     start_server), allows users more flexibility in specifying
     messages per-directory ("cvs message -l") or per-tree ("cvs
     message") or per-file ("cvs message foo.c"), and fixes the
     incompatibility between client/server (per-tree) and
     non-client/server (per-directory).

182.  There should be a way to show log entries corresponding to
changes from tag "foo" to tag "bar".  "cvs log -rfoo -rbar" doesn't
cut it, because it is inclusive on the bar end.  I'm not sure that is
ever a useful or logical behavior ("cvs diff -r foo -r bar" is not
similarly inclusive), but is compatibility an issue?

@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d1 2
@


1.1.1.6
log
@New release from Cyclic Software
@
text
@d1 6
d182 4
d332 7
a406 10
183.  "cvs status" should report on Entries.Static flag and CVS/Tag (how?
maybe a "cvs status -d" to give directory status?).  There should also
be more documentation of how these get set and how/when to re-set them.

184.  Would be nice to implement the FreeBSD MD5-based password hash
algorithm in pserver.  For more info see "6.1. DES, MD5, and Crypt" in
the FreeBSD Handbook, and src/lib/libcrypt/crypt.c in the FreeBSD
sources.  Certainly in the context of non-unix servers this algorithm
makes more sense than the traditional unix crypt() algorithm, which
suffers from export control problems.
@


1.1.1.7
log
@Latest release from Cyclic Software
@
text
@d248 2
a249 2

        % cvs message foo.c
d254 5
a258 18
     The text is saved as CVS/foo.c,m (or some such name) and commit
     is modified to append (prepend?) the text (if found) to the log
     message specified at commit time.  Easy enough.  (having cvs
     commit be non-interactive takes care of various issues like
     whether to connect to the server before or after prompting for a
     message (see comment in commit.c at call to start_server)
     -kingdon, June 1996)

     I'm not sure about the part above about having commit prompt
     for an overall message--part of the point is having commit
     non-interactive and somehow combining messages seems like (excess?)
     hair.

     Would be nice to do this so it allows users more flexibility in
     specifying messages per-directory ("cvs message -l") or per-tree
     ("cvs message") or per-file ("cvs message foo.c"), and fixes the
     incompatibility between client/server (per-tree) and
     non-client/server (per-directory).
d373 10
@


1.1.1.8
log
@Latest version from Cyclic Software
@
text
@a402 20

185.  A frequent complaint is that keyword expansion causes conflicts
when merging from one branch to another.  The first step is
documenting CVS's existing features in this area--what happens with
various -k options in various places?  The second step is thinking
about whether there should be some new feature and if so how it should
be designed.  For example, here is one thought:

    rcs' co command needs a new -k option.  The new option should expand
    $Log entries without expanding $Revision entries.  This would
    allow cvs to use rcsmerge in such a way that joining branches into
    main lines would neither generate extra collisions on revisions nor
    drop log lines.

The details of this are out of date (CVS no longer invokes "co", and
any changes in this area would be done by bypassing RCS rather than
modifying it), but even as to the general idea, I don't have a clear
idea about whether it would be good (see what I mean about the need
for better documentation?  I work on CVS full-time, and even I don't
understand the state of the art on this subject).
@


1.1.1.9
log
@Latest version from Cyclic
@
text
@a0 2
The "TODO" file!                              -*-Indented-Text-*-

d7 1
a7 3
30. Add "rdiff" program option to the modules database (and "diff"
too?).  (perhaps should think a little harder about what this is
trying to accomplish and what the best way is -kingdon, Jul 1997).
d19 1
a19 3
    track of what has been merged is a pain.  Take a look at PRCS 1.2.
    PRCS 1.0 was particularly bad the way it handled the "invisible
    state", but 1.2 is significantly better.
d48 3
d60 2
a61 2
79. Might be nice to have some sort of interface to Sun's Translucent
    (?) File System and tagged revisions.
d69 2
a70 4
85. Make symbolic links a valid thing to put under version control.
    Perhaps use one of the tag fields in the RCS file?  Note that we
    can only support symlinks that are relative and within the scope of
    the sources being controlled.
d133 5
a137 6
119. When importing a directory tree that is under SCCS/RCS control,
     consider an option to have import checkout the SCCS/RCS files if
     necessary.  (This is if someone wants to import something which
     is in RCS or SCCS without preserving the history, but makes sure
     they do get the latest versions.  It isn't clear to me how useful
     that is -kingdon, June 1996).
a144 1
     (See `importb' tests in src/sanity.sh for more details).
d160 2
d187 1
a187 3
141. Import should accept modules as its directory argument.  If we're
     going to implement this, we should think hard about how modules
     might be expanded and how to handle those cases.
d190 1
a190 3
     something far away from the files that you work on.  (People who
     come from an RCS background are used to their `repository' being
     _very_ close to their working directory.)
d230 4
a233 2
149. Maybe there should be an option to cvs admin that allows a user to
     change the Repository/Root file with some degree of error checking?
a237 30
     The obvious cases are where one moves the repository to another
     machine or directory.  But there are other cases, like where the
     user might want to change from :pserver: to :ext:, use a different
     server (if there are two server machines which share the
     repository using a networked file system), etc.

     The status quo is a bit of a mess (as of, say, CVS 1.9).  It is
     that the -d global option has two moderately different uses.  One
     is to use a totally different repository (in which case we'd
     probably want to give an error if it disagreed with CVS/Root, as
     CVS 1.8 and earlier did).  The other is the "reposmv"
     functionality above (in which the two repositories really are the
     same, and we want to update the CVS/Root files).  A related issue
     is that the fact that CVS only sets and looks at the CVS/Root
     file in the directory where CVS is run; it doesn't do anything
     about CVS/Root files in subdirectories.

     Note also RELATIVE_REPOS in options.h; it needs to be set for
     changing CVS/Root (not CVS/Repository) to be sufficient in the
     case where the directory has changed.

     This whole area is a rather bad pile of individual decisions which
     accumulated over time, some of them probably bad decisions with
     hindsight.  But we didn't get into this mess overnight, and we're
     not going to get out of it overnight (that is, we need to come up
     with a replacement behavior, document what parts of the status
     quo are deprecated, probably circulate some unofficial patches, &c).

     (this item originally added 2 Feb 1992 but revised since).

d259 2
a260 3
     message (see comment in commit.c at call to start_server).  Also
     would clean up the kludge for what to do with the message from
     do_editor if the up-to-date check fails (see commit.c client code).
a272 8
     A few interesting issues with this: (1) if you do a cvs update or
     some other operation which changes the working directory, do you
     need to run "cvs message" again (it would, of course, bring up
     the old message which you could accept)?  Probably yes, after all
     merging in some conflicts might change the situation.  (2) How do
     you change the stored messages if you change your mind before the
     commit (probably run "cvs message" again, as hinted in (1))?

d276 1
a276 1
     followed by "cvs rtag -d Ulrtx_Build"
d282 5
a286 6
153. There should be some command (maybe I just haven't figured out
     which one...) to import a source directory which is already
     RCS-administered without losing all prior RCS gathered data.
     Thus, it would have to examine the RCS files and choose a
     starting version and branch higher than previous ones used.
     (Check out rcs-to-cvs and see if it addresses this issue.)
d293 4
a296 6
     useful queries can be done if they are not, as in specifying both
     a module and a tag.  A workaround is to specify the module, then
     run the output through grep to only display lines that begin with
     T, which are tag lines.  (Better perhaps if we redesign the whole
     "history" business -- check out doc/cvs.texinfo for the entire
     rant.)
d316 3
d388 4
a391 6
changes from tag "foo" to tag "bar".  "cvs log -rfoo:bar" doesn't cut
it, because it erroneously shows the changes associated with the
change from the revision before foo to foo.  I'm not sure that is ever
a useful or logical behavior ("cvs diff -r foo -r bar" gets this
right), but is compatibility an issue?  See
http://www.cyclic.com/cvs/unoff-log.txt for an unofficial patch.
a422 323

186.  There is a frequent discussion of multisite features.

* There may be some overlap with the client/server CVS, which is good
especially when there is a single developer at each location.  But by
"multisite" I mean something in which each site is more autonomous, to
one extent or another.

* Vendor branches are the closest thing that CVS currently has for
multisite features.  They have fixable drawbacks (such as poor
handling of added and removed files), and more fundamental drawbacks
(when you import a vendor branch, you are importing a set of files,
not importing any knowledge of their version history outside the
current repository).

* One approach would be to require checkins (or other modifications to
the repository) to succeed at a write quorum of sites (51%) before
they are allowed to complete.  To work well, the network should be
reliable enough that one can typically get to that many sites.  When a
server which has been out of touch reconnects, it would want to update
its data before doing anything else.  Any of the servers can service
all requests locally, except perhaps for a check that they are
up-to-date.  The way this differs from a run-of-the-mill distributed
database is that if one only allows reversible operations via this
mechanism (exclude "cvs admin -o", "cvs tag -d", &c), then each site
can back up the others, such that failures at one site, including
something like deleting all the sources, can be recovered from.  Thus
the sites need not trust each other as much as for many shared
databases, and the system may be resilient to many types of
organizational failures.  Sometimes I call this design the
"CVScluster" design.

* Another approach is a master/slave one.  Checkins happen at the
master site, and slave sites need to check whether their local
repository is up to date before relying on its information.

* Another approach is to have each site own a particular branch.  This
one is the most tolerant of flaky networks; if checkins happen at each
site independently there is no particular problem.  The big question
is whether merges happen only manually, as with existing CVS branches,
or whether there is a feature whereby there are circumstances in which
merges from one branch to the other happen automatically (for example,
the case in which the branches have not diverged).  This might be a
legitimate question to ask even quite aside from multisite features.

One additional random tidbit is to note that Eric Raymond has some
interest in this sort of thing.  The item "Cooperative distributed
freeware development" on http://www.ccil.org/~esr/ has a very brief
introduction to what he is thinking about.

187.  Might want to separate out usage error messages and help
messages.  The problem now is that if you specify an invalid option,
for example, the error message is lost among all the help text.  In
the new regime, the error message would be followed by a one-line
message directing people to the appropriate help option ("cvs -H
<command>" or "cvs --help-commands" or whatever, according to the
situation).  I'm not sure whether this change would be controversial
(as defined in HACKING), so there might be a need for further
discussion or other actions other than just coding.

188.  Option parsing and .cvsrc has at least one notable limitation.
If you want to set a global option only for some CVS commands, there
is no way to do it (for example, if one wants to set -q only for
"rdiff").  I am told that the "popt" package from RPM
(http://www.rpm.org) could solve this and other problems (for example,
if the syntax of option stuff in .cvsrc is similar to RPM, that would
be great from a user point of view).  It would at least be worth a
look (it also provides a cleaner API than getopt_long).

Another issue which may or may not be related is the issue of
overriding .cvsrc from the command line.  The cleanest solution might
be to have options in mutually exclusive sets (-l/-R being a current
example, but --foo/--no-foo is a better way to name such options).  Or
perhaps there is some better solution.

189.  Renaming files and directories is a frequently discussed topic.

Some of the problems with the status quo:

a.  "cvs annotate" cannot operate on both the old and new files in a
single run.  You need to run it twice, once for the new name and once
for the old name.

b.  "cvs diff" (or "cvs diff -N") shows a rename as a removal of the
old file and an addition of the new one.  Some people would like to
see the differences between the file contents (but then how would we
indicate the fact that the file has been renamed?  Certainly the
notion that "patch(1)" has of renames is as a removal and addition).

c.  "cvs log" should be able to show the changes between two
tags/dates, even in the presence of adds/removes/renames (I'm not sure
what the status quo is on this; see also item #182).

d.  Renaming directories is way too hard.

Implementations:

It is perhaps premature to try to design implementation details
without answering some of the above questions about desired behaviors
but several general implementations get mentioned.

i.  No fundamental changes (for example, a "cvs rename" command which
operated on directories could still implement the current recommended
practice for renaming directories, which is to rename each of the
files contained therein via an add and a remove).  One thing to note
that the status quo gets right is proper merges, even with adds and
removals (Well, mostly right at least.  There are a *LOT* of different
cases; see the testsuite for some of them).

ii.  Rename database.  In this scheme the files in the repository
would have some arbitrary name, and then a separate rename database
would indicate the current correspondence between the filename in the
working directory and the actual storage.  As far as I know this has
never been designed in detail for CVS.

iii.  A modest change in which the RCS files would contain some
information such as "renamed from X" or "renamed to Y".  That is, this
would be generally similar to the log messages which are suggested
when one renames via an add and a removal, but would be
computer-parseable.  I don't think anyone has tried to flesh out any
details here either.

It is interesting to note that in solution ii. version numbers in the
"new file" start where the "old file" left off, while in solutions
i. and iii., version numbers restart from 1.1 each time a file is
renamed.  Except perhaps in the case where we rename a file from foo
to bar and then back to foo.  I'll shut up now.

Regardless of the method we choose, we need to address how renames
affect existing CVS behaviors.  For example, what happens when you
rename a file on a branch but not the trunk and then try to merge the
two?  What happens when you rename a file on one branch and delete it
on another and try to merge the two?

Ideally, we'd come up with a way to parameterize the problem and
simply write up a lookup table to determine the correct behavior.

190.  The meaning of the -q and -Q global options is very ad hoc;
there is no clear definition of which messages are suppressed by them
and which are not.  Here is a classification of the current meanings
of -q; I don't know whether anyone has done a similar investigation of
-Q:

  a.  The "warm fuzzies" printed upon entering each directory (for
  example, "cvs update: Updating sdir").  The need for these messages
  may be decreased now that most of CVS uses ->fullname instead of
  ->file in messages (a project which is *still* not 100% complete,
  alas).  However, the issue of whether CVS can offer status as it
  runs is an important one.  Of course from the command line it is
  hard to do this well and one ends up with options like -q.  But
  think about emacs, jCVS, or other environments which could flash you
  the latest status line so you can see whether the system is working
  or stuck.

  b.  Other cases where the message just offers information (rather
  than an error) and might be considered unnecessarily verbose.  These
  have a certain point to them, although it isn't really clear whether
  it should be the same option as the warm fuzzies or whether it is
  worth the conceptual hair:

    add.c: scheduling %s `%s' for addition (may be an issue)
    modules.c: %s %s: Executing '%s' (I can see how that might be noise,
      but...)
    remove.c: scheduling `%s' for removal (analogous to the add.c one)
    update.c: Checking out %s (hmm, that message is a bit on the noisy side...)
      (but the similar message in annotate is not affected by -q).

  c.  Suppressing various error messages.  This is almost surely
  bogus.

    commit.c: failed to remove tag `%s' from `%s' (Questionable.
      Rationale might be that we already printed another message
      elsewhere but why would it be necessary to avoid
      the extra message in such an uncommon case?)
    commit.c: failed to check out `%s' (likewise; this one seems to be a
      vestige from before RCS_checkout was internal.  Take a look at how
      RCS_checkout handles errors)
    commit.c: failed to commit dead revision for `%s' (likewise)
    remove.c: file `%s' still in working directory (see below about rm
      -f analogy)
    remove.c: nothing known about `%s' (looks dubious to me, especially in
      the case where the user specified it explicitly).
    remove.c: removed `%s' (seems like an obscure enough case that I fail
      to see the appeal of being cryptically concise here).
    remove.c: file `%s' already scheduled for removal (now it is starting
      to look analogous to the infamous rm -f option).
    rtag.c: cannot find tag `%s' in `%s' (more rm -f like behavior)
    rtag.c: failed to remove tag `%s' from `%s' (ditto)
    tag.c: failed to remove tag %s from %s (see above about whether RCS_*
      has already printed an error message).
    tag.c: couldn't tag added but un-commited file `%s' (more rm -f
      like behavior)
    tag.c: skipping removed but un-commited file `%s' (ditto)
    tag.c: cannot find revision control file for `%s' (ditto, but at first
      glance seems even worse, as this would seem to be a "can't happen"
      condition)

191.  Storing RCS files, especially binary files, takes rather more
space than it could, typically.
  - The virtue of the status quo is that it is simple to implement.
    Of course it is also simplest in terms of dealing with compatibility.
  - Just storing the revisions as separate gzipped files is a common 
    technique.  It also is pretty simple (no new algorithms, CVS
    already has zlib around).  Of course for some files (such as files
    which are already compressed) the gzip step won't help, but
    something which can at least sometimes avoid rewriting the entire
    RCS file for each new revision would, I would think, be a big
    speedup for large files.
  - Josh MacDonald has written a tool called xdelta which produces
    differences (that is, sufficient information to transform the old
    to the new) which looks for common sequences of bytes, like RCS
    currently does, but which is not based on lines.  This seems to do
    quite well for some kinds of files (e.g. FrameMaker documents,
    text files), and not as well for others (anything which is already
    compressed, executables).  xdelta 1.10 also is faster than GNU diff.
  - Karl Fogel has thought some about using a difference technique
    analogous to fractal compression (see the comp.compression FAQ for
    more on fractal compression, including at least one patent to
    watch for; I don't know how analogous Karl's ideas are to the
    techniques described there).
  - Quite possibly want some documented interface by which a site can
    plug in their choice of external difference programs (with the
    ability to choose the program based on filename, magic numbers,
    or some such).

192.  "cvs update" using an absolute pathname does not work if the
working directory is not a CVS-controlled directory with the correct
CVSROOT.  For example, the following will fail:

  cd /tmp
  cvs -d /repos co foo
  cd /
  cvs update /tmp/foo

It is possible to read the CVSROOT from the administrative files in
the directory specified by the absolute pathname argument to update.
In that case, the last command above would be equivalent to:

  cd /tmp/foo
  cvs update .

This can be problematic, however, if we ask CVS to update two
directories with different CVSROOTs.  Currently, CVS has no way of
changing CVSROOT mid-stream.  Consider the following:

  cd /tmp
  cvs -d /repos1 co foo
  cvs -d /repos2 co bar
  cd /
  cvs update /tmp/foo /tmp/bar

To make that example work, we need to think hard about:

  - where and when CVSROOT-related variables get set
  - who caches said variables for later use
  - how the remote protocol should be extended to handle sending a new
    repository mid-stream
  - how the client should maintain connections to a variety of servers
    in a single invocation.

Because those issues are hairy, I suspect that having a change in
CVSROOT be an error would be a better move.

193.  The client relies on timestamps to figure out whether a file is
(maybe) modified.  If something goes awry, then it ends up sending
entire files to the server to be checked, and this can be quite slow
especially over a slow network.  A couple of things that can happen:
(a) other programs, like make, use timestamps, so one ends up needing
to do "touch foo" and otherwise messing with timestamps, (b) changing
the timezone offset (e.g. summer vs. winter or moving a machine)
should work on unix, but there may be problems with non-unix.

Possible solutions:

   a.  Store a checksum for each file in CVS/Entries or some such
   place.  What to do about hash collisions is interesting: using a
   checksum, like MD5, large enough to "never" have collisions
   probably works in practice (of course, if there is a collision then
   all hell breaks loose because that code path was not tested, but
   given the tiny, tiny probability of that I suppose this is only an
   aesthetic issue).

   b.  I'm not thinking of others, except storing the whole file in
   CVS/Base, and I'm sure using twice the disk space would be
   unpopular.

194.  CVS does not separate the "metadata" from the actual revision
history; it stores them both in the RCS files.  Metadata means tags
and header information such as the number of the head revision.
Storing the metadata separately could speed up "cvs tag" enormously,
which is a big problem for large repositories.  It could also probably
make CVS's locking much less in the way (see comment in do_recursion
about "two-pass design").

195.  Many people using CVS over a slow link are interested in whether
the remote protocol could be any more efficient with network
bandwidth.  This item is about one aspect of that--how the server
sends a new version of a file the client has a different version of,
or vice versa.

a.  Cases in which the status quo already sends a diff.  For most text
files, this is probably already close to optimal.  For binary files,
and anomalous text files, it might be worth looking into other
difference algorithms (see item #191).

b.  Cases in which the status quo does not send a diff (e.g. "cvs
commit").

b1.  With some frequency, people suggest rsync or a similar algorithm
(see ftp://samba.anu.edu.au/pub/rsync/).  This could speed things up,
and in some ways involves the most minimal changes to the default CVS
paradigm.  There are some downsides though: (1) there is an extra
network turnaround, (2) the algorithm is not as efficient with network
bandwidth as difference type programs (it transmits a fair bit of data
to discover what a difference program discovers locally).

b2.  If one is willing to require that users use "cvs edit" before
editing a file on the client side (in some cases, a development
environment like emacs can make this fairly easy), then the Modified
request in the protocol could be extended to allow the client to just
send differences instead of entire files.  In the degenerate case
(e.g. "cvs diff" without arguments) the required network traffic is
reduced to zero, and the client need not even contact the server.
@


1.1.1.10
log
@Latest version from Cyclic
@
text
@d645 3
@


1.1.1.11
log
@Latest version from Cyclic
@
text
@a13 2
    One particular issue: RCS removes the ,foo.c, file on ^C and CVS
    doesn't.
d257 4
a260 4
     same, and we want to update the CVS/Root files).  In CVS 1.9 and
     1.10, -d rewrites the CVS/Root file (but not in subdirectories).
     This behavior was not particularly popular and has been since
     reverted.
d770 1
a770 2
and anomalous (?) text files (e.g. those in which it would help to do
moves, as well as adds and deletes), it might be worth looking into other
d780 3
a782 3
network turnaround, (2) the algorithm needs to transmit some data to
discover what difference type programs can discover locally (although
this is only about 1% of the size of the files).
a790 4

196.  Using a CVSROOT with a trailing slash will confuse CVS.  I think
we need to add a call to strip_trailing_slashes in root.c
(parse_cvsroot), but I haven't considered all of the ramifications.
@


1.1.1.12
log
@Latest from Cyclic Software
@
text
@d518 5
@


1.1.1.13
log
@Latest from Cyclic Software
@
text
@a792 23

197.  Analyze the difference between CVS_UNLINK & unlink_file.  As far as I
can tell, unlink_file aborts in noexec mode and CVS_UNLINK does not.  I'm not
sure it would be possible to remove even the use of temp files in noexec mode,
but most unlinks should probably be using unlink_file and not CVS_UNLINK.

198.  Remove references to deprecated cvs_temp_name function.

199.  Add test for login & logout functionality, including support for
backwards compatibility with old CVSROOTs.

200.  Make a 'cvs add' without write access a non-fatal error so that the
user's Entries file is updated and future 'cvs diffs' will work properly.  This
should ease patch submission.

201.  cvs_temp_file should be creating temporary files in a privately owned
subdirectory of of temp due to security issues on some systems.

**
202.  Merge most of the diff & rdiff code.  Enable rdiff to accept most diff
options.  Make rdiff output look like diff's.  Make diff garbage go to stderr
and only standard diff output go to stdout.
**  In progress - DRP
@


