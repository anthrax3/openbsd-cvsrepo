head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.9.0.68
	OPENBSD_6_2_BASE:1.1.1.9
	OPENBSD_6_1:1.1.1.9.0.66
	OPENBSD_6_1_BASE:1.1.1.9
	OPENBSD_6_0:1.1.1.9.0.62
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.58
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.60
	OPENBSD_5_8_BASE:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.52
	OPENBSD_5_7_BASE:1.1.1.9
	OPENBSD_5_6:1.1.1.9.0.56
	OPENBSD_5_6_BASE:1.1.1.9
	OPENBSD_5_5:1.1.1.9.0.54
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.50
	OPENBSD_5_4_BASE:1.1.1.9
	OPENBSD_5_3:1.1.1.9.0.48
	OPENBSD_5_3_BASE:1.1.1.9
	OPENBSD_5_2:1.1.1.9.0.46
	OPENBSD_5_2_BASE:1.1.1.9
	OPENBSD_5_1_BASE:1.1.1.9
	OPENBSD_5_1:1.1.1.9.0.44
	OPENBSD_5_0:1.1.1.9.0.42
	OPENBSD_5_0_BASE:1.1.1.9
	OPENBSD_4_9:1.1.1.9.0.40
	OPENBSD_4_9_BASE:1.1.1.9
	OPENBSD_4_8:1.1.1.9.0.38
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.34
	OPENBSD_4_7_BASE:1.1.1.9
	OPENBSD_4_6:1.1.1.9.0.36
	OPENBSD_4_6_BASE:1.1.1.9
	OPENBSD_4_5:1.1.1.9.0.32
	OPENBSD_4_5_BASE:1.1.1.9
	OPENBSD_4_4:1.1.1.9.0.30
	OPENBSD_4_4_BASE:1.1.1.9
	OPENBSD_4_3:1.1.1.9.0.28
	OPENBSD_4_3_BASE:1.1.1.9
	OPENBSD_4_2:1.1.1.9.0.26
	OPENBSD_4_2_BASE:1.1.1.9
	OPENBSD_4_1:1.1.1.9.0.24
	OPENBSD_4_1_BASE:1.1.1.9
	OPENBSD_4_0:1.1.1.9.0.22
	OPENBSD_4_0_BASE:1.1.1.9
	OPENBSD_3_9:1.1.1.9.0.20
	OPENBSD_3_9_BASE:1.1.1.9
	OPENBSD_3_8:1.1.1.9.0.18
	OPENBSD_3_8_BASE:1.1.1.9
	OPENBSD_3_7:1.1.1.9.0.16
	OPENBSD_3_7_BASE:1.1.1.9
	OPENBSD_3_6:1.1.1.9.0.14
	OPENBSD_3_6_BASE:1.1.1.9
	OPENBSD_3_5:1.1.1.9.0.12
	OPENBSD_3_5_BASE:1.1.1.9
	OPENBSD_3_4:1.1.1.9.0.10
	OPENBSD_3_4_BASE:1.1.1.9
	OPENBSD_3_3:1.1.1.9.0.8
	OPENBSD_3_3_BASE:1.1.1.9
	OPENBSD_3_2:1.1.1.9.0.6
	OPENBSD_3_2_BASE:1.1.1.9
	OPENBSD_3_1:1.1.1.9.0.4
	OPENBSD_3_1_BASE:1.1.1.9
	OPENBSD_3_0:1.1.1.9.0.2
	OPENBSD_3_0_BASE:1.1.1.9
	cvs-1-11-1p1:1.1.1.9
	OPENBSD_2_9:1.1.1.8.0.14
	OPENBSD_2_9_BASE:1.1.1.8
	cvs-1-11:1.1.1.8
	OPENBSD_2_8:1.1.1.8.0.12
	OPENBSD_2_8_BASE:1.1.1.8
	OPENBSD_2_7:1.1.1.8.0.10
	OPENBSD_2_7_BASE:1.1.1.8
	OPENBSD_2_6:1.1.1.8.0.8
	OPENBSD_2_6_BASE:1.1.1.8
	cvs-1-10-7:1.1.1.8
	OPENBSD_2_5:1.1.1.8.0.6
	OPENBSD_2_5_BASE:1.1.1.8
	cvs-1-10-5:1.1.1.8
	OPENBSD_2_4:1.1.1.8.0.4
	OPENBSD_2_4_BASE:1.1.1.8
	cvs-1-10:1.1.1.8
	cvs-1-9-28:1.1.1.8
	OPENBSD_2_3:1.1.1.8.0.2
	OPENBSD_2_3_BASE:1.1.1.8
	cvs-1-9-26:1.1.1.8
	cvs-1-9-24:1.1.1.7
	OPENBSD_2_2:1.1.1.6.0.2
	OPENBSD_2_2_BASE:1.1.1.6
	cvs-1-9-10:1.1.1.6
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.5
	cvs-1-9-4:1.1.1.5
	cvs-1-9-2:1.1.1.5
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.30;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.37;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.18.51;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.35.01;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.02.21.06.36.44;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.06.28.03.28.11;	author tholo;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	98.02.22.08.20.28;	author tholo;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	98.03.12.06.57.47;	author tholo;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2001.09.28.22.45.41;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* system-dependent definitions for CVS.
   Copyright (C) 1989-1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* $CVSid: @@(#)system.h 1.18 94/09/25 $ */

#ifdef __GNUC__
#ifndef alloca
#define alloca __builtin_alloca
#endif
#else
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
/* AIX alloca decl has to be the first thing in the file, bletch! */
 #pragma alloca
#else  /* not _AIX */
char *alloca ();
#endif /* not _AIX */
#endif /* not HAVE_ALLOCA_H */
#endif /* not __GNUS__ */

#include <sys/types.h>
#include <sys/stat.h>

#ifdef STAT_MACROS_BROKEN
#undef S_ISBLK
#undef S_ISCHR
#undef S_ISDIR
#undef S_ISREG
#undef S_ISFIFO
#undef S_ISLNK
#undef S_ISSOCK
#undef S_ISMPB
#undef S_ISMPC
#undef S_ISNWK
#endif

#if !defined(S_ISBLK) && defined(S_IFBLK)
#define	S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#endif
#if !defined(S_ISCHR) && defined(S_IFCHR)
#define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISDIR) && defined(S_IFDIR)
#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG) && defined(S_IFREG)
#define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISFIFO) && defined(S_IFIFO)
#define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISLNK) && defined(S_IFLNK)
#define	S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK) && defined(S_IFSOCK)
#define	S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISMPB) && defined(S_IFMPB) /* V7 */
#define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
#define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
#endif
#if !defined(S_ISNWK) && defined(S_IFNWK) /* HP/UX */
#define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
#endif
#if !defined(HAVE_MKFIFO)
#define mkfifo(path, mode) (mknod ((path), (mode) | S_IFIFO, 0))
#endif

#ifndef S_IRUSR
#define	S_IRUSR 0400
#define	S_IWUSR 0200
#define	S_IXUSR 0100
/* Read, write, and execute by owner.  */
#define	S_IRWXU	(S_IRUSR|S_IWUSR|S_IXUSR)

#define	S_IRGRP	(S_IRUSR >> 3)	/* Read by group.  */
#define	S_IWGRP	(S_IWUSR >> 3)	/* Write by group.  */
#define	S_IXGRP	(S_IXUSR >> 3)	/* Execute by group.  */
/* Read, write, and execute by group.  */
#define	S_IRWXG	(S_IRWXU >> 3)

#define	S_IROTH	(S_IRGRP >> 3)	/* Read by others.  */
#define	S_IWOTH	(S_IWGRP >> 3)	/* Write by others.  */
#define	S_IXOTH	(S_IXGRP >> 3)	/* Execute by others.  */
/* Read, write, and execute by others.  */
#define	S_IRWXO	(S_IRWXG >> 3)
#endif

#if defined(POSIX) || defined(HAVE_UNISTD_H)
#include <unistd.h>
#include <limits.h>
#else
off_t lseek ();
#endif

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#ifdef HAVE_IO_H
#include <io.h>
#endif

#ifdef HAVE_DIRECT_H
#include <direct.h>
#endif

#ifdef timezone
#undef timezone /* needed for sgi */
#endif

#ifdef HAVE_SYS_TIMEB_H
#include <sys/timeb.h>
#else
struct timeb {
    time_t		time;		/* Seconds since the epoch	*/
    unsigned short	millitm;	/* Field not used		*/
    short		timezone;
    short		dstflag;	/* Field not used		*/
};
#endif

#if !defined(HAVE_FTIME) && !defined(HAVE_TIMEZONE)
#if !defined(timezone)
extern long timezone;
#endif
#endif


/*
**  MAXPATHLEN and PATH_MAX
**
**     On most systems MAXPATHLEN is defined in sys/param.h to be 1024. Of
**     those that this is not true, again most define PATH_MAX in limits.h
**     or sys/limits.h which usually gets included by limits.h. On the few
**     remaining systems that neither statement is true, _POSIX_PATH_MAX 
**     is defined.
**
**     So:
**         1. If PATH_MAX is defined just use it.
**         2. If MAXPATHLEN is defined but not PATH_MAX, then define
**            PATH_MAX in terms of MAXPATHLEN.
**         3. If neither is defined, include limits.h and check for
**            PATH_MAX again.
**         3.1 If we now have PATHSIZE, define PATH_MAX in terms of that.
**             and ignore the rest.  Since _POSIX_PATH_MAX (checked for
**             next) is the *most* restrictive (smallest) value, if we
**             trust _POSIX_PATH_MAX, several of our buffers are too small.
**         4. If PATH_MAX is still not defined but _POSIX_PATH_MAX is,
**            then define PATH_MAX in terms of _POSIX_PATH_MAX.
**         5. And if even _POSIX_PATH_MAX doesn't exist just put in
**            a reasonable value.
**         *. All in all, this is an excellent argument for using pathconf()
**            when at all possible.  Or better yet, dynamically allocate
**            our buffers and use getcwd() not getwd().
**
**     This works on:
**         Sun Sparc 10        SunOS 4.1.3  &  Solaris 1.2
**         HP 9000/700         HP/UX 8.07   &  HP/UX 9.01
**         Tektronix XD88/10   UTekV 3.2e
**         IBM RS6000          AIX 3.2
**         Dec Alpha           OSF 1 ????
**         Intel 386           BSDI BSD/386
**         Intel 386           SCO OpenServer Release 5
**         Apollo              Domain 10.4
**         NEC                 SVR4
*/

/* On MOST systems this will get you MAXPATHLEN.
   Windows NT doesn't have this file, tho.  */
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif

#ifndef PATH_MAX  
#  ifdef MAXPATHLEN
#    define PATH_MAX                 MAXPATHLEN
#  else
#    include <limits.h>
#    ifndef PATH_MAX
#      ifdef PATHSIZE
#         define PATH_MAX               PATHSIZE
#      else /* no PATHSIZE */
#        ifdef _POSIX_PATH_MAX
#          define PATH_MAX             _POSIX_PATH_MAX
#        else
#          define PATH_MAX             1024
#        endif  /* no _POSIX_PATH_MAX */
#      endif  /* no PATHSIZE */
#    endif /* no PATH_MAX   */
#  endif  /* MAXPATHLEN */
#endif  /* PATH_MAX   */


/* The NeXT (without _POSIX_SOURCE, which we don't want) has a utime.h
   which doesn't define anything.  It would be cleaner to have configure
   check for struct utimbuf, but for now I'm checking NeXT here (so I don't
   have to debug the configure check across all the machines).  */
#if defined (HAVE_UTIME_H) && !defined (NeXT)
#include <utime.h>
#else
#ifndef ALTOS
struct utimbuf
{
  long actime;
  long modtime;
};
#endif
int utime ();
#endif

#if STDC_HEADERS || HAVE_STRING_H
#include <string.h>
/* An ANSI string.h and pre-ANSI memory.h might conflict. */
#if !STDC_HEADERS && HAVE_MEMORY_H
#include <memory.h>
#endif /* not STDC_HEADERS and HAVE_MEMORY_H */

#ifndef index
#define index strchr
#endif /* index */

#ifndef rindex
#define rindex strrchr
#endif /* rindex */

#ifndef bcmp
#define bcmp(s1, s2, n) memcmp ((s1), (s2), (n))
#endif /* bcmp */

#ifndef bzero
#define bzero(s, n) memset ((s), 0, (n))
#endif /* bzero */

#else /* not STDC_HEADERS and not HAVE_STRING_H */
#include <strings.h>
/* memory.h and strings.h conflict on some systems. */
#endif /* not STDC_HEADERS and not HAVE_STRING_H */

#include <errno.h>
#ifdef STDC_HEADERS
#include <stdlib.h>
#else
char *getenv ();
char *malloc ();
char *realloc ();
char *calloc ();
extern int errno;
#endif

#if defined(USG) || defined(POSIX)
char *getcwd ();
#else
char *getwd ();
#endif

#ifdef HAVE_FCNTL_H
#include <fcntl.h>
#else
#include <sys/file.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#endif

#ifndef F_OK
#define F_OK 0
#define X_OK 1
#define W_OK 2
#define R_OK 4
#endif

#if HAVE_DIRENT_H
# include <dirent.h>
# define NAMLEN(dirent) strlen((dirent)->d_name)
#else
# define dirent direct
# define NAMLEN(dirent) (dirent)->d_namlen
# if HAVE_SYS_NDIR_H
#  include <sys/ndir.h>
# endif
# if HAVE_SYS_DIR_H
#  include <sys/dir.h>
# endif
# if HAVE_NDIR_H
#  include <ndir.h>
# endif
#endif

/* Convert B 512-byte blocks to kilobytes if K is nonzero,
   otherwise return it unchanged. */
#define convert_blocks(b, k) ((k) ? ((b) + 1) / 2 : (b))

#ifndef S_ISLNK
#define lstat stat
#endif

/*
 * Some UNIX distributions don't include these in their stat.h Defined here
 * because "config.h" is always included last.
 */
#ifndef S_IWRITE
#define	S_IWRITE	0000200		/* write permission, owner */
#endif
#ifndef S_IWGRP
#define	S_IWGRP		0000020		/* write permission, grougroup */
#endif
#ifndef S_IWOTH
#define	S_IWOTH		0000002		/* write permission, other */
#endif


/* Under MS-DOS and its derivatives (like Windows NT), mkdir takes only one
   argument; permission is handled very differently on those systems than in
   in Unix.  So we leave such systems a hook on which they can hang their
   own definitions.  */
#ifndef CVS_MKDIR
#define CVS_MKDIR mkdir
#endif

/* Some file systems are case-insensitive.  If FOLD_FN_CHAR is
   #defined, it maps the character C onto its "canonical" form.  In a
   case-insensitive system, it would map all alphanumeric characters
   to lower case.  Under Windows NT, / and \ are both path component
   separators, so FOLD_FN_CHAR would map them both to /.  */
#ifndef FOLD_FN_CHAR
#define FOLD_FN_CHAR(c) (c)
#define fnfold(filename) (filename)
#define fncmp strcmp
#endif

/* Different file systems have different path component separators.
   For the VMS port we might need to abstract further back than this.  */
#ifndef ISDIRSEP
#define ISDIRSEP(c) ((c) == '/')
#endif


/* On some systems, lines in text files should be terminated with CRLF,
   not just LF, and the read and write routines do this translation
   for you.  LINES_CRLF_TERMINATED is #defined on such systems.
   - OPEN_BINARY is the flag to pass to the open function for
     untranslated I/O.
   - FOPEN_BINARY_READ is the string to pass to fopen to get
     untranslated reading.
   - FOPEN_BINARY_WRITE is the string to pass to fopen to get
     untranslated writing.  */
#if LINES_CRLF_TERMINATED
#define OPEN_BINARY (O_BINARY)
#define FOPEN_BINARY_READ ("rb")
#define FOPEN_BINARY_WRITE ("wb")
#else
#define OPEN_BINARY (0)
#define FOPEN_BINARY_READ ("r")
#define FOPEN_BINARY_WRITE ("w")
#endif
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a31 3
#ifdef ALLOCA_IN_STDLIB
 /* then we need do nothing */
#else
a32 1
#endif /* not ALLOCA_IN_STDLIB */
a52 3
/* Not all systems have S_IFMT, but we probably want to use it if we
   do.  See ChangeLog for a more detailed discussion. */

d54 1
a54 5
# if defined(S_IFMT)
# define	S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
# else
# define S_ISBLK(m) ((m) & S_IFBLK)
# endif
a55 1

d57 1
a57 5
# if defined(S_IFMT)
# define	S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
# else
# define S_ISCHR(m) ((m) & S_IFCHR)
# endif
a58 1

d60 1
a60 5
# if defined(S_IFMT)
# define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
# else
# define S_ISDIR(m) ((m) & S_IFDIR)
# endif
a61 1

d63 1
a63 5
# if defined(S_IFMT)
# define	S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
# else
# define S_ISREG(m) ((m) & S_IFREG)
# endif
a64 1

d66 1
a66 5
# if defined(S_IFMT)
# define	S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
# else
# define S_ISFIFO(m) ((m) & S_IFIFO)
# endif
a67 1

d69 1
a69 5
# if defined(S_IFMT)
# define	S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
# else
# define S_ISLNK(m) ((m) & S_IFLNK)
# endif
a70 1

d72 1
a72 5
# if defined(S_IFMT)
# define	S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
# else
# define S_ISSOCK(m) ((m) & S_IFSOCK)
# endif
a73 1

d75 2
a76 7
# if defined(S_IFMT)
# define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
# define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
# else
# define S_ISMPB(m) ((m) & S_IFMPB)
# define S_ISMPC(m) ((m) & S_IFMPC)
# endif
a77 1

d79 1
a79 5
# if defined(S_IFMT)
# define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
# else
# define S_ISNWK(m) ((m) & S_IFNWK)
# endif
a80 1

a84 17
#ifdef NEED_DECOY_PERMISSIONS        /* OS/2, really */

#define	S_IRUSR S_IREAD
#define	S_IWUSR S_IWRITE
#define	S_IXUSR S_IEXEC
#define	S_IRWXU	(S_IRUSR | S_IWUSR | S_IXUSR)
#define	S_IRGRP S_IREAD
#define	S_IWGRP S_IWRITE
#define	S_IXGRP S_IEXEC
#define	S_IRWXG	(S_IRGRP | S_IWGRP | S_IXGRP)
#define	S_IROTH S_IREAD
#define	S_IWOTH S_IWRITE
#define	S_IXOTH S_IEXEC
#define	S_IRWXO	(S_IROTH | S_IWOTH | S_IXOTH)

#else /* ! NEED_DECOY_PERMISSIONS */

d103 1
a103 2
#endif /* !def S_IRUSR */
#endif /* NEED_DECOY_PERMISSIONS */
a223 2
#elif defined (HAVE_SYS_UTIME_H)
# include <sys/utime.h>
d236 22
a257 5
#  include <string.h>
   /* An ANSI string.h and pre-ANSI memory.h might conflict. */
#  if !STDC_HEADERS && HAVE_MEMORY_H
#    include <memory.h>
#  endif /* not STDC_HEADERS and HAVE_MEMORY_H */
d259 2
a260 2
#  include <strings.h>
   /* memory.h and strings.h conflict on some systems. */
a263 19

/* Not all systems set the same error code on a non-existent-file
   error.  This tries to ask the question somewhat portably.
   On systems that don't have ENOTEXIST, this should behave just like
   x == ENOENT.  "x" is probably errno, of course. */

#ifdef ENOTEXIST
#  ifdef EOS2ERR
#    define existence_error(x) \
     (((x) == ENOTEXIST) || ((x) == ENOENT) || ((x) == EOS2ERR))
#  else
#    define existence_error(x) \
     (((x) == ENOTEXIST) || ((x) == ENOENT))
#  endif
#else
#    define existence_error(x) ((x) == ENOENT)
#endif


a279 23
/* check for POSIX signals */
#if defined(HAVE_SIGACTION) && defined(HAVE_SIGPROCMASK)
# define POSIX_SIGNALS
#endif

/* MINIX 1.6 doesn't properly support sigaction */
#if defined(_MINIX)
# undef POSIX_SIGNALS
#endif

/* If !POSIX, try for BSD.. Reason: 4.4BSD implements these as wrappers */
#if !defined(POSIX_SIGNALS)
# if defined(HAVE_SIGVEC) && defined(HAVE_SIGSETMASK) && defined(HAVE_SIGBLOCK)
#  define BSD_SIGNALS
# endif
#endif

/* Under OS/2, this must be included _after_ stdio.h; that's why we do
   it here. */
#ifdef USE_OWN_TCPIP_H
#include "tcpip.h"
#endif

d337 1
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@d20 21
a334 4
#  ifdef EVMSERR
#     define existence_error(x) \
((x) == ENOENT || (x) == EINVAL || (x) == EVMSERR)
#  else
a335 1
#  endif
a346 5
#endif

/* SunOS4 apparently does not define this in stdlib.h.  */
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d273 3
a275 1
#  include <utime.h>
d277 1
a277 4
#  if defined (HAVE_SYS_UTIME_H)
#    include <sys/utime.h>
#  else
#    ifndef ALTOS
d283 1
a283 1
#    endif
a284 1
#  endif
a297 1
#ifndef ERRNO_H_MISSING
a298 1
#endif
d425 4
a428 21
/* Under non-UNIX operating systems (MS-DOS, WinNT, MacOS), many filesystem
   calls take  only one argument; permission is handled very differently on
   those systems than in Unix.  So we leave such systems a hook on which they
   can hang their own definitions.  */

#ifndef CVS_ACCESS
#define CVS_ACCESS access
#endif

#ifndef CVS_CHDIR
#define CVS_CHDIR chdir
#endif

#ifndef CVS_CREAT
#define CVS_CREAT creat
#endif

#ifndef CVS_FOPEN
#define CVS_FOPEN fopen
#endif

a430 24
#endif

#ifndef CVS_OPEN
#define CVS_OPEN open
#endif

#ifndef CVS_OPENDIR
#define CVS_OPENDIR opendir
#endif

#ifndef CVS_RENAME
#define CVS_RENAME rename
#endif

#ifndef CVS_RMDIR
#define CVS_RMDIR rmdir
#endif

#ifndef CVS_STAT
#define CVS_STAT stat
#endif

#ifndef CVS_UNLINK
#define CVS_UNLINK unlink
@


1.1.1.5
log
@New release from Cyclic Software
@
text
@d12 7
a18 1
   GNU General Public License for more details.  */
@


1.1.1.6
log
@Latest version from Cyclic Software
@
text
@d107 4
a469 5
#endif

/* Wildcard matcher.  Should be case-insensitive if the system is.  */
#ifndef CVS_FNMATCH
#define CVS_FNMATCH fnmatch
@


1.1.1.7
log
@Latest version from Cyclic
@
text
@d30 2
a31 8
/* Not all systems have S_IFMT, but we want to use it if we have it.
   The S_IFMT code below looks right (it masks and compares).  The
   non-S_IFMT code looks bogus (are there really systems on which
   S_IFBLK, S_IFLNK, &c, each have their own bit?  I suspect it was
   written for OS/2 using the IBM C/C++ Tools 2.01 compiler).

   Of course POSIX systems will have S_IS*, so maybe the issue is
   semi-moot.  */
a149 1
char *getcwd ();
d279 10
a288 1
#include <string.h>
d332 6
a472 25
#if defined (__CYGWIN32__) || defined (WIN32)

/* Under Windows NT, filenames are case-insensitive, and both / and \
   are path component separators.  */

#define FOLD_FN_CHAR(c) (WNT_filename_classes[(unsigned char) (c)])
extern unsigned char WNT_filename_classes[];
#define FILENAMES_CASE_INSENSITIVE 1

/* Is the character C a path name separator?  Under
   Windows NT, you can use either / or \.  */
#define ISDIRSEP(c) (FOLD_FN_CHAR(c) == '/')

/* Like strcmp, but with the appropriate tweaks for file names.
   Under Windows NT, filenames are case-insensitive but case-preserving,
   and both \ and / are path element separators.  */
extern int fncmp (const char *n1, const char *n2);

/* Fold characters in FILENAME to their canonical forms.  
   If FOLD_FN_CHAR is not #defined, the system provides a default
   definition for this.  */
extern void fnfold (char *FILENAME);

#endif /* defined (__CYGWIN32__) || defined (WIN32) */

d491 11
a501 11
/* On some systems, we have to be careful about writing/reading files
   in text or binary mode (so in text mode the system can handle CRLF
   vs. LF, VMS text file conventions, &c).  We decide to just always
   be careful.  That way we don't have to worry about whether text and
   binary differ on this system.  We just have to worry about whether
   the system has O_BINARY and "rb".  The latter is easy; all ANSI C
   libraries have it, SunOS4 has it, and CVS has used it unguarded
   some places for a while now without complaints (e.g. "rb" in
   server.c (server_updated), since CVS 1.8).  The former is just an
   #ifdef.  */

a503 3

#ifdef O_BINARY
#define OPEN_BINARY (O_BINARY)
d506 2
@


1.1.1.8
log
@Latest version from Cyclic
@
text
@a455 7
/* Open question: should CVS_STAT be lstat by default?  We need
   to use lstat in order to handle symbolic links correctly with
   the PreservePermissions option. -twp */
#ifndef CVS_LSTAT
#define CVS_LSTAT lstat
#endif

@


1.1.1.9
log
@Latest from Cyclic Software
@
text
@d159 10
a168 1
#include "xtime.h"
d178 20
a431 4
#ifndef CVS_FDOPEN
#define CVS_FDOPEN fdopen
#endif

a437 8
#endif

#ifndef CVS_READDIR
#define CVS_READDIR readdir
#endif

#ifndef CVS_CLOSEDIR
#define CVS_CLOSEDIR closedir
@


