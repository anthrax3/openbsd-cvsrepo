head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.24
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.22
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.18
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.14
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.16
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.8
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.12
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.46
	OPENBSD_5_0:1.1.1.5.0.44
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.42
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.40
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.36
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.38
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.34
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.32
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.30
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.28
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.26
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.24
	OPENBSD_4_0_BASE:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.22
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.20
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.18
	OPENBSD_3_7_BASE:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.16
	OPENBSD_3_6_BASE:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.14
	OPENBSD_3_5_BASE:1.1.1.5
	OPENBSD_3_4:1.1.1.5.0.12
	OPENBSD_3_4_BASE:1.1.1.5
	OPENBSD_3_3:1.1.1.5.0.10
	OPENBSD_3_3_BASE:1.1.1.5
	OPENBSD_3_2:1.1.1.5.0.8
	OPENBSD_3_2_BASE:1.1.1.5
	OPENBSD_3_1:1.1.1.5.0.6
	OPENBSD_3_1_BASE:1.1.1.5
	OPENBSD_3_0:1.1.1.5.0.4
	OPENBSD_3_0_BASE:1.1.1.5
	cvs-1-11-1p1:1.1.1.5
	OPENBSD_2_9:1.1.1.5.0.2
	OPENBSD_2_9_BASE:1.1.1.5
	cvs-1-11:1.1.1.5
	OPENBSD_2_8:1.1.1.4.0.12
	OPENBSD_2_8_BASE:1.1.1.4
	OPENBSD_2_7:1.1.1.4.0.10
	OPENBSD_2_7_BASE:1.1.1.4
	OPENBSD_2_6:1.1.1.4.0.8
	OPENBSD_2_6_BASE:1.1.1.4
	cvs-1-10-7:1.1.1.4
	OPENBSD_2_5:1.1.1.4.0.6
	OPENBSD_2_5_BASE:1.1.1.4
	cvs-1-10-5:1.1.1.4
	OPENBSD_2_4:1.1.1.4.0.4
	OPENBSD_2_4_BASE:1.1.1.4
	cvs-1-10:1.1.1.4
	cvs-1-9-28:1.1.1.4
	OPENBSD_2_3:1.1.1.4.0.2
	OPENBSD_2_3_BASE:1.1.1.4
	cvs-1-9-26:1.1.1.4
	cvs-1-9-24:1.1.1.4
	OPENBSD_2_2:1.1.1.3.0.4
	OPENBSD_2_2_BASE:1.1.1.3
	cvs-1-9-10:1.1.1.3
	OPENBSD_2_1:1.1.1.3.0.2
	OPENBSD_2_1_BASE:1.1.1.3
	cvs-1-9-8:1.1.1.3
	cvs-1-9-6:1.1.1.3
	cvs-1-9-4:1.1.1.3
	cvs-1-9-2:1.1.1.3
	cvs-1-9:1.1.1.2
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	cvs-1-8-1:1.1.1.2
	cvs-1-8:1.1.1.2
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2012.03.04.04.05.15;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	96.01.30.00.17.26;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.01.30.00.17.26;	author tholo;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.04.27.19.41.08;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.02.21.06.36.28;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	98.02.22.08.20.19;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2001.02.10.18.57.24;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@In preparation for getline and getdelim additions to libc, rename getline()
occurrences to get_line().
Based on a diff from Jan Klemkow <j-dot-klemkow-at-wemelug-dot-de> to tech.
@
text
@/* getline.c -- Replacement for GNU C library function getline

Copyright (C) 1993 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.  */

/* Written by Jan Brittenson, bson@@gnu.ai.mit.edu.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <sys/types.h>
#include <stdio.h>
#include <assert.h>
#include <errno.h>
#include "getline.h"

#if STDC_HEADERS
#include <stdlib.h>
#else
char *malloc (), *realloc ();
#endif

/* Always add at least this many bytes when extending the buffer.  */
#define MIN_CHUNK 64

/* Read up to (and including) a TERMINATOR from STREAM into *LINEPTR
   + OFFSET (and null-terminate it).  If LIMIT is non-negative, then
   read no more than LIMIT chars.

   *LINEPTR is a pointer returned from malloc (or NULL), pointing to
   *N characters of space.  It is realloc'd as necessary.  

   Return the number of characters read (not including the null
   terminator), or -1 on error or EOF.  On a -1 return, the caller
   should check feof(), if not then errno has been set to indicate the
   error.  */

int
getstr (lineptr, n, stream, terminator, offset, limit)
     char **lineptr;
     size_t *n;
     FILE *stream;
     char terminator;
     int offset;
     int limit;
{
  int nchars_avail;		/* Allocated but unused chars in *LINEPTR.  */
  char *read_pos;		/* Where we're reading into *LINEPTR. */
  int ret;

  if (!lineptr || !n || !stream)
    {
      errno = EINVAL;
      return -1;
    }

  if (!*lineptr)
    {
      *n = MIN_CHUNK;
      *lineptr = malloc (*n);
      if (!*lineptr)
	{
	  errno = ENOMEM;
	  return -1;
	}
    }

  nchars_avail = *n - offset;
  read_pos = *lineptr + offset;

  for (;;)
    {
      int save_errno;
      register int c;

      if (limit == 0)
          break;
      else
      {
          c = getc (stream);

          /* If limit is negative, then we shouldn't pay attention to
             it, so decrement only if positive. */
          if (limit > 0)
              limit--;
      }

      save_errno = errno;

      /* We always want at least one char left in the buffer, since we
	 always (unless we get an error while reading the first char)
	 NUL-terminate the line buffer.  */

      assert((*lineptr + *n) == (read_pos + nchars_avail));
      if (nchars_avail < 2)
	{
	  if (*n > MIN_CHUNK)
	    *n *= 2;
	  else
	    *n += MIN_CHUNK;

	  nchars_avail = *n + *lineptr - read_pos;
	  *lineptr = realloc (*lineptr, *n);
	  if (!*lineptr)
	    {
	      errno = ENOMEM;
	      return -1;
	    }
	  read_pos = *n - nchars_avail + *lineptr;
	  assert((*lineptr + *n) == (read_pos + nchars_avail));
	}

      if (ferror (stream))
	{
	  /* Might like to return partial line, but there is no
	     place for us to store errno.  And we don't want to just
	     lose errno.  */
	  errno = save_errno;
	  return -1;
	}

      if (c == EOF)
	{
	  /* Return partial line, if any.  */
	  if (read_pos == *lineptr)
	    return -1;
	  else
	    break;
	}

      *read_pos++ = c;
      nchars_avail--;

      if (c == terminator)
	/* Return the line.  */
	break;
    }

  /* Done - NUL terminate and return the number of chars read.  */
  *read_pos = '\0';

  ret = read_pos - (*lineptr + offset);
  return ret;
}

int
get_line (lineptr, n, stream)
     char **lineptr;
     size_t *n;
     FILE *stream;
{
  return getstr (lineptr, n, stream, '\n', 0, GETLINE_NO_LIMIT);
}

int
getline_safe (lineptr, n, stream, limit)
     char **lineptr;
     size_t *n;
     FILE *stream;
     int limit;
{
  return getstr (lineptr, n, stream, '\n', 0, limit);
}
@


1.1
log
@Initial revision
@
text
@d13 1
a13 5
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
a22 1
#define NDEBUG
d24 2
d37 10
a46 4
   + OFFSET (and null-terminate it). *LINEPTR is a pointer returned from
   malloc (or NULL), pointing to *N characters of space.  It is realloc'd
   as necessary.  Return the number of characters read (not including the
   null terminator), or -1 on error or EOF.  */
d49 1
a49 1
getstr (lineptr, n, stream, terminator, offset)
d55 1
d62 4
a65 1
    return -1;
d72 4
a75 1
	return -1;
d83 16
a98 1
      register int c = getc (stream);
d104 1
a104 1
      assert(*n - nchars_avail == read_pos - *lineptr);
d115 4
a118 1
	    return -1;
d120 1
a120 1
	  assert(*n - nchars_avail == read_pos - *lineptr);
d123 10
a132 1
      if (c == EOF || ferror (stream))
d157 10
a166 1
getline (lineptr, n, stream)
d170 1
d172 1
a172 1
  return getstr (lineptr, n, stream, '\n', 0);
@


1.1.1.1
log
@Upgrade to 1.7.1 snapshot
@
text
@@


1.1.1.2
log
@Latest public release from Cyclic; fixes numerous memory leaks and have
some performance improvements
@
text
@d27 1
d79 1
a79 1
      assert((*lineptr + *n) == (read_pos + nchars_avail));
d92 1
a92 1
	  assert((*lineptr + *n) == (read_pos + nchars_avail));
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@d13 5
a17 1
General Public License for more details.  */
@


1.1.1.4
log
@Latest version from Cyclic
@
text
@a23 1
#include <errno.h>
d38 1
a38 3
   null terminator), or -1 on error or EOF.  On a -1 return, the caller
   should check feof(), if not then errno has been set to indicate
   the error.  */
d53 1
a53 4
    {
      errno = EINVAL;
      return -1;
    }
d60 1
a60 4
	{
	  errno = ENOMEM;
	  return -1;
	}
a67 1
      int save_errno;
a69 2
      save_errno = errno;

d85 1
a85 4
	    {
	      errno = ENOMEM;
	      return -1;
	    }
d90 1
a90 10
      if (ferror (stream))
	{
	  /* Might like to return partial line, but there is no
	     place for us to store errno.  And we don't want to just
	     lose errno.  */
	  errno = save_errno;
	  return -1;
	}

      if (c == EOF)
@


1.1.1.5
log
@Latest from Cyclic Software
@
text
@a24 1
#include "getline.h"
d36 6
a41 10
   + OFFSET (and null-terminate it).  If LIMIT is non-negative, then
   read no more than LIMIT chars.

   *LINEPTR is a pointer returned from malloc (or NULL), pointing to
   *N characters of space.  It is realloc'd as necessary.  

   Return the number of characters read (not including the null
   terminator), or -1 on error or EOF.  On a -1 return, the caller
   should check feof(), if not then errno has been set to indicate the
   error.  */
d44 1
a44 1
getstr (lineptr, n, stream, terminator, offset, limit)
a49 1
     int limit;
d78 1
a78 13
      register int c;

      if (limit == 0)
          break;
      else
      {
          c = getc (stream);

          /* If limit is negative, then we shouldn't pay attention to
             it, so decrement only if positive. */
          if (limit > 0)
              limit--;
      }
d144 1
a144 11
  return getstr (lineptr, n, stream, '\n', 0, GETLINE_NO_LIMIT);
}

int
getline_safe (lineptr, n, stream, limit)
     char **lineptr;
     size_t *n;
     FILE *stream;
     int limit;
{
  return getstr (lineptr, n, stream, '\n', 0, limit);
@


