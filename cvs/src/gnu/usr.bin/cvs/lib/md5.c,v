head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.50
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.48
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.44
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.40
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.42
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.34
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.38
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.36
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.32
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.30
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.28
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.26
	OPENBSD_5_0:1.2.0.24
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.22
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.20
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.16
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.18
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.14
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.12
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.10
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.8
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.6
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.4
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.1.3.0.28
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.26
	OPENBSD_3_7_BASE:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.24
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.22
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.20
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.18
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.16
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.14
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.12
	OPENBSD_3_0_BASE:1.1.1.3
	cvs-1-11-1p1:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.10
	OPENBSD_2_9_BASE:1.1.1.3
	cvs-1-11:1.1.1.3
	OPENBSD_2_8:1.1.1.3.0.8
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.6
	OPENBSD_2_7_BASE:1.1.1.3
	OPENBSD_2_6:1.1.1.3.0.4
	OPENBSD_2_6_BASE:1.1.1.3
	cvs-1-10-7:1.1.1.3
	OPENBSD_2_5:1.1.1.3.0.2
	OPENBSD_2_5_BASE:1.1.1.3
	cvs-1-10-5:1.1.1.3
	OPENBSD_2_4:1.1.1.2.0.8
	OPENBSD_2_4_BASE:1.1.1.2
	cvs-1-10:1.1.1.2
	cvs-1-9-28:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.6
	OPENBSD_2_3_BASE:1.1.1.2
	cvs-1-9-26:1.1.1.2
	cvs-1-9-24:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.4
	OPENBSD_2_2_BASE:1.1.1.2
	cvs-1-9-10:1.1.1.2
	OPENBSD_2_1:1.1.1.2.0.2
	OPENBSD_2_1_BASE:1.1.1.2
	cvs-1-9-8:1.1.1.2
	cvs-1-9-6:1.1.1.2
	cvs-1-9-4:1.1.1.2
	cvs-1-9-2:1.1.1.1
	cvs-1-9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	cvs-1-8-1:1.1.1.1
	cvs-1-8:1.1.1.1
	cvs-1-7-2:1.1.1.1
	cvs-1-7-1:1.1.1.1
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2006.02.19.19.06.30;	author otto;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.29;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.03.18.01.55.18;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.02.28.21.31.06;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.2
log
@memset(p, 0, sizeof(p)) -> memset(p, 0, sizeof(*p)).
From  Alexey Dobriyan
@
text
@/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

/* This code was modified in 1997 by Jim Kingdon of Cyclic Software to
   not require an integer type which is exactly 32 bits.  This work
   draws on the changes for the same purpose by Tatu Ylonen
   <ylo@@cs.hut.fi> as part of SSH, but since I didn't actually use
   that code, there is no copyright issue.  I hereby disclaim
   copyright in any changes I have made; this code remains in the
   public domain.  */

/* Note regarding cvs_* namespace: this avoids potential conflicts
   with libraries such as some versions of Kerberos.  No particular
   need to worry about whether the system supplies an MD5 library, as
   this file is only about 3k of object code.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <string.h>	/* for memcpy() and memset() */

/* Add prototype support.  */
#ifndef PROTO
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#define PROTO(ARGS) ARGS
#else
#define PROTO(ARGS) ()
#endif
#endif

#include "md5.h"

/* Little-endian byte-swapping routines.  Note that these do not
   depend on the size of datatypes such as cvs_uint32, nor do they require
   us to detect the endianness of the machine we are running on.  It
   is possible they should be macros for speed, but I would be
   surprised if they were a performance bottleneck for MD5.  */

static cvs_uint32
getu32 (addr)
     const unsigned char *addr;
{
	return (((((unsigned long)addr[3] << 8) | addr[2]) << 8)
		| addr[1]) << 8 | addr[0];
}

static void
putu32 (data, addr)
     cvs_uint32 data;
     unsigned char *addr;
{
	addr[0] = (unsigned char)data;
	addr[1] = (unsigned char)(data >> 8);
	addr[2] = (unsigned char)(data >> 16);
	addr[3] = (unsigned char)(data >> 24);
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void
cvs_MD5Init (ctx)
     struct cvs_MD5Context *ctx;
{
	ctx->buf[0] = 0x67452301;
	ctx->buf[1] = 0xefcdab89;
	ctx->buf[2] = 0x98badcfe;
	ctx->buf[3] = 0x10325476;

	ctx->bits[0] = 0;
	ctx->bits[1] = 0;
}

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void
cvs_MD5Update (ctx, buf, len)
     struct cvs_MD5Context *ctx;
     unsigned char const *buf;
     unsigned len;
{
	cvs_uint32 t;

	/* Update bitcount */

	t = ctx->bits[0];
	if ((ctx->bits[0] = (t + ((cvs_uint32)len << 3)) & 0xffffffff) < t)
		ctx->bits[1]++;	/* Carry from low to high */
	ctx->bits[1] += len >> 29;

	t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */

	/* Handle any leading odd-sized chunks */

	if ( t ) {
		unsigned char *p = ctx->in + t;

		t = 64-t;
		if (len < t) {
			memcpy(p, buf, len);
			return;
		}
		memcpy(p, buf, t);
		cvs_MD5Transform (ctx->buf, ctx->in);
		buf += t;
		len -= t;
	}

	/* Process data in 64-byte chunks */

	while (len >= 64) {
		memcpy(ctx->in, buf, 64);
		cvs_MD5Transform (ctx->buf, ctx->in);
		buf += 64;
		len -= 64;
	}

	/* Handle any remaining bytes of data. */

	memcpy(ctx->in, buf, len);
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void
cvs_MD5Final (digest, ctx)
     unsigned char digest[16];
     struct cvs_MD5Context *ctx;
{
	unsigned count;
	unsigned char *p;

	/* Compute number of bytes mod 64 */
	count = (ctx->bits[0] >> 3) & 0x3F;

	/* Set the first char of padding to 0x80.  This is safe since there is
	   always at least one byte free */
	p = ctx->in + count;
	*p++ = 0x80;

	/* Bytes of padding needed to make 64 bytes */
	count = 64 - 1 - count;

	/* Pad out to 56 mod 64 */
	if (count < 8) {
		/* Two lots of padding:  Pad the first block to 64 bytes */
		memset(p, 0, count);
		cvs_MD5Transform (ctx->buf, ctx->in);

		/* Now fill the next block with 56 bytes */
		memset(ctx->in, 0, 56);
	} else {
		/* Pad block to 56 bytes */
		memset(p, 0, count-8);
	}

	/* Append length in bits and transform */
	putu32(ctx->bits[0], ctx->in + 56);
	putu32(ctx->bits[1], ctx->in + 60);

	cvs_MD5Transform (ctx->buf, ctx->in);
	putu32(ctx->buf[0], digest);
	putu32(ctx->buf[1], digest + 4);
	putu32(ctx->buf[2], digest + 8);
	putu32(ctx->buf[3], digest + 12);
	memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
}

#ifndef ASM_MD5

/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
	( w += f(x, y, z) + data, w &= 0xffffffff, w = w<<s | w>>(32-s), w += x )

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void
cvs_MD5Transform (buf, inraw)
     cvs_uint32 buf[4];
     const unsigned char inraw[64];
{
	register cvs_uint32 a, b, c, d;
	cvs_uint32 in[16];
	int i;

	for (i = 0; i < 16; ++i)
		in[i] = getu32 (inraw + 4 * i);

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];

	MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);
	MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);
	MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);
	MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);
	MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);
	MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);
	MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);
	MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);
	MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);
	MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);
	MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);
	MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);
	MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);
	MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);
	MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);
	MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);

	MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);
	MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);
	MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);
	MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);
	MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);
	MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);
	MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);
	MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);
	MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);
	MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);
	MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);
	MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);
	MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);
	MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);
	MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);
	MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);

	MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);
	MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);
	MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);
	MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);
	MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);
	MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);
	MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);
	MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);
	MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);
	MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);
	MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);
	MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);
	MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);
	MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);
	MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);
	MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);

	MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);
	MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);
	MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);
	MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);
	MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);
	MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);
	MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);
	MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);
	MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);
	MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);
	MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);
	MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);
	MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);
	MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);
	MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);
	MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);

	buf[0] += a;
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
}
#endif

#ifdef TEST
/* Simple test program.  Can use it to manually run the tests from
   RFC1321 for example.  */
#include <stdio.h>

int
main (int argc, char **argv)
{
	struct cvs_MD5Context context;
	unsigned char checksum[16];
	int i;
	int j;

	if (argc < 2)
	{
		fprintf (stderr, "usage: %s string-to-hash\n", argv[0]);
		exit (1);
	}
	for (j = 1; j < argc; ++j)
	{
		printf ("MD5 (\"%s\") = ", argv[j]);
		cvs_MD5Init (&context);
		cvs_MD5Update (&context, argv[j], strlen (argv[j]));
		cvs_MD5Final (checksum, &context);
		for (i = 0; i < 16; i++)
		{
			printf ("%02x", (unsigned int) checksum[i]);
		}
		printf ("\n");
	}
	return 0;
}
#endif /* TEST */
@


1.1
log
@Initial revision
@
text
@d18 14
d33 1
d35 1
a35 3
#if HAVE_STRING_H || STDC_HEADERS
#include <string.h>	/* for memcpy() */
#endif
d48 13
a60 1
void byteReverse PROTO ((unsigned char *buf, unsigned longs));
d62 4
a65 7
#ifndef ASM_MD5
/*
 * Note: this code is harmless on little-endian machines.
 */
void byteReverse (buf, longs)
     unsigned char *buf;
     unsigned longs;
d67 4
a70 7
	uint32 t;
	do {
		t = (uint32)((unsigned)buf[3]<<8 | buf[2]) << 16 |
		            ((unsigned)buf[1]<<8 | buf[0]);
		*(uint32 *)buf = t;
		buf += 4;
	} while (--longs);
a71 1
#endif
d78 2
a79 2
MD5Init(ctx)
     struct MD5Context *ctx;
d95 2
a96 2
MD5Update(ctx, buf, len)
     struct MD5Context *ctx;
d100 1
a100 1
	uint32 t;
d105 1
a105 1
	if ((ctx->bits[0] = t + ((uint32)len << 3)) < t)
d114 1
a114 1
		unsigned char *p = (unsigned char *)ctx->in + t;
d122 1
a122 2
		byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (uint32 *)ctx->in);
d131 1
a131 2
		byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (uint32 *)ctx->in);
d146 1
a146 1
MD5Final(digest, ctx)
d148 1
a148 1
     struct MD5Context *ctx;
d168 1
a168 2
		byteReverse(ctx->in, 16);
		MD5Transform(ctx->buf, (uint32 *)ctx->in);
a175 1
	byteReverse(ctx->in, 14);
d178 2
a179 2
	((uint32 *)ctx->in)[ 14 ] = ctx->bits[0];
	((uint32 *)ctx->in)[ 15 ] = ctx->bits[1];
d181 6
a186 4
	MD5Transform(ctx->buf, (uint32 *)ctx->in);
	byteReverse((unsigned char *)ctx->buf, 4);
	memcpy(digest, ctx->buf, 16);
	memset(ctx, 0, sizeof(ctx));	/* In case it's sensitive */
d201 1
a201 1
	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
d209 3
a211 3
MD5Transform(buf, in)
     uint32 buf[4];
     uint32 const in[16];
d213 6
a218 1
	register uint32 a, b, c, d;
d299 34
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@New release from Cyclic Software
@
text
@a17 9
/* This code was modified in 1997 by Jim Kingdon of Cyclic Software to
   not require an integer type which is exactly 32 bits.  This work
   draws on the changes for the same purpose by Tatu Ylonen
   <ylo@@cs.hut.fi> as part of SSH, but since I didn't actually use
   that code, there is no copyright issue.  I hereby disclaim
   copyright in any changes I have made; this code remains in the
   public domain.  */

#ifdef HAVE_CONFIG_H
a18 1
#endif
d35 1
a35 13
/* Little-endian byte-swapping routines.  Note that these do not
   depend on the size of datatypes such as uint32, nor do they require
   us to detect the endianness of the machine we are running on.  It
   is possible they should be macros for speed, but I would be
   surprised if they were a performance bottleneck for MD5.  */

static uint32
getu32 (addr)
     const unsigned char *addr;
{
	return (((((unsigned long)addr[3] << 8) | addr[2]) << 8)
		| addr[1]) << 8 | addr[0];
}
d37 7
a43 4
static void
putu32 (data, addr)
     uint32 data;
     unsigned char *addr;
d45 7
a51 4
	addr[0] = (unsigned char)data;
	addr[1] = (unsigned char)(data >> 8);
	addr[2] = (unsigned char)(data >> 16);
	addr[3] = (unsigned char)(data >> 24);
d53 1
d87 1
a87 1
	if ((ctx->bits[0] = (t + ((uint32)len << 3)) & 0xffffffff) < t)
d96 1
a96 1
		unsigned char *p = ctx->in + t;
d104 2
a105 1
		MD5Transform(ctx->buf, ctx->in);
d114 2
a115 1
		MD5Transform(ctx->buf, ctx->in);
d152 2
a153 1
		MD5Transform(ctx->buf, ctx->in);
d161 1
d164 2
a165 2
	putu32(ctx->bits[0], ctx->in + 56);
	putu32(ctx->bits[1], ctx->in + 60);
d167 3
a169 5
	MD5Transform(ctx->buf, ctx->in);
	putu32(ctx->buf[0], digest);
	putu32(ctx->buf[1], digest + 4);
	putu32(ctx->buf[2], digest + 8);
	putu32(ctx->buf[3], digest + 12);
d185 1
a185 1
	( w += f(x, y, z) + data, w &= 0xffffffff, w = w<<s | w>>(32-s), w += x )
d193 1
a193 1
MD5Transform(buf, inraw)
d195 1
a195 1
     const unsigned char inraw[64];
a197 5
	uint32 in[16];
	int i;

	for (i = 0; i < 16; ++i)
		in[i] = getu32 (inraw + 4 * i);
a277 34

#ifdef TEST
/* Simple test program.  Can use it to manually run the tests from
   RFC1321 for example.  */
#include <stdio.h>

int
main (int argc, char **argv)
{
	struct MD5Context context;
	unsigned char checksum[16];
	int i;
	int j;

	if (argc < 2)
	{
		fprintf (stderr, "usage: %s string-to-hash\n", argv[0]);
		exit (1);
	}
	for (j = 1; j < argc; ++j)
	{
		printf ("MD5 (\"%s\") = ", argv[j]);
		MD5Init (&context);
		MD5Update (&context, argv[j], strlen (argv[j]));
		MD5Final (checksum, &context);
		for (i = 0; i < 16; i++)
		{
			printf ("%02x", (unsigned int) checksum[i]);
		}
		printf ("\n");
	}
	return 0;
}
#endif /* TEST */
@


1.1.1.3
log
@Latest version from Cyclic
@
text
@a25 5
/* Note regarding cvs_* namespace: this avoids potential conflicts
   with libraries such as some versions of Kerberos.  No particular
   need to worry about whether the system supplies an MD5 library, as
   this file is only about 3k of object code.  */

d30 3
a32 1
#include <string.h>	/* for memcpy() and memset() */
d46 1
a46 1
   depend on the size of datatypes such as cvs_uint32, nor do they require
d51 1
a51 1
static cvs_uint32
d61 1
a61 1
     cvs_uint32 data;
d75 2
a76 2
cvs_MD5Init (ctx)
     struct cvs_MD5Context *ctx;
d92 2
a93 2
cvs_MD5Update (ctx, buf, len)
     struct cvs_MD5Context *ctx;
d97 1
a97 1
	cvs_uint32 t;
d102 1
a102 1
	if ((ctx->bits[0] = (t + ((cvs_uint32)len << 3)) & 0xffffffff) < t)
d119 1
a119 1
		cvs_MD5Transform (ctx->buf, ctx->in);
d128 1
a128 1
		cvs_MD5Transform (ctx->buf, ctx->in);
d143 1
a143 1
cvs_MD5Final (digest, ctx)
d145 1
a145 1
     struct cvs_MD5Context *ctx;
d165 1
a165 1
		cvs_MD5Transform (ctx->buf, ctx->in);
d178 1
a178 1
	cvs_MD5Transform (ctx->buf, ctx->in);
d206 2
a207 2
cvs_MD5Transform (buf, inraw)
     cvs_uint32 buf[4];
d210 2
a211 2
	register cvs_uint32 a, b, c, d;
	cvs_uint32 in[16];
d305 1
a305 1
	struct cvs_MD5Context context;
d318 3
a320 3
		cvs_MD5Init (&context);
		cvs_MD5Update (&context, argv[j], strlen (argv[j]));
		cvs_MD5Final (checksum, &context);
@


