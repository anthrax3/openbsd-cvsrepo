head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.54
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.56
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.52
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.48
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.50
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.42
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.46
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.44
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.40
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.38
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.36
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.34
	OPENBSD_5_0:1.4.0.32
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.30
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.28
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.24
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.26
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.22
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.12
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.10
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.8
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.6
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	cvs-1-11-1p1:1.1.1.4
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_9_BASE:1.3
	cvs-1-11:1.1.1.4
	OPENBSD_2_8:1.2.0.10
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	cvs-1-10-7:1.1.1.3
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	cvs-1-10-5:1.1.1.3
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	cvs-1-10:1.1.1.3
	cvs-1-9-28:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.6
	OPENBSD_2_3_BASE:1.1.1.3
	cvs-1-9-26:1.1.1.3
	cvs-1-9-24:1.1.1.3
	OPENBSD_2_2:1.1.1.3.0.4
	OPENBSD_2_2_BASE:1.1.1.3
	cvs-1-9-10:1.1.1.3
	OPENBSD_2_1:1.1.1.3.0.2
	OPENBSD_2_1_BASE:1.1.1.3
	cvs-1-9-8:1.1.1.3
	cvs-1-9-6:1.1.1.3
	cvs-1-9-4:1.1.1.3
	cvs-1-9-2:1.1.1.3
	cvs-1-9:1.1.1.2
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	cvs-1-8-1:1.1.1.2
	cvs-1-8:1.1.1.2
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2004.01.13.19.51.44;	author otto;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.10.19.31.34;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	98.06.03.16.20.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.19.09.21.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.30;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.17.31;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.02.21.06.36.36;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.02.10.18.57.26;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Do not evaluate this->next after calling the handler; the handler may
have clobbered it. Resolves core dumps of cvs server on user ^C.

ok millert@@ deraadt@@
@
text
@/* sighandle.c -- Library routines for manipulating chains of signal handlers
   Copyright (C) 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

/* Written by Paul Sander, HaL Computer Systems, Inc. <paul@@hal.com>
   Brian Berliner <berliner@@Sun.COM> added POSIX support */

/*************************************************************************
 *
 * signal.c -- This file contains code that manipulates chains of signal
 *             handlers.
 *
 *             Facilities are provided to register a signal handler for
 *             any specific signal.  When a signal is received, all of the
 *             registered signal handlers are invoked in the reverse order
 *             in which they are registered.  Note that the signal handlers
 *             must not themselves make calls to the signal handling
 *             facilities.
 *
 *************************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#include "system.h"

#include <sys/types.h>
#include <stdio.h>
#include <signal.h>

/* Add prototype support.  */
#ifndef PROTO
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#define PROTO(ARGS) ARGS
#else
#define PROTO(ARGS) ()
#endif
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#else
#if __STDC__
char *calloc(unsigned nelem, unsigned size);
char *malloc(unsigned size);
#else
char *calloc();
char *malloc();
#endif /* __STDC__ */
#endif /* STDC_HEADERS */

/* Define the highest signal number (usually) */
#ifndef SIGMAX
#define	SIGMAX	64
#endif

/* Define linked list of signal handlers structure */
struct SIG_hlist {
	RETSIGTYPE		(*handler)();
	struct SIG_hlist	*next;
};

/*
 * Define array of lists of signal handlers.  Note that this depends on
 * the implementation to initialize each element to a null pointer.
 */

static	struct SIG_hlist	**SIG_handlers;

/* Define array of default signal vectors */

#ifdef POSIX_SIGNALS
static	struct sigaction	*SIG_defaults;
#else
#ifdef BSD_SIGNALS
static	struct sigvec		*SIG_defaults;
#else
static	RETSIGTYPE		(**SIG_defaults) PROTO ((int));
#endif
#endif

/* Critical section housekeeping */
static	int		SIG_crSectNest = 0;	/* Nesting level */
#ifdef POSIX_SIGNALS
static	sigset_t	SIG_crSectMask;		/* Signal mask */
#else
static	int		SIG_crSectMask;		/* Signal mask */
#endif

/*
 * Initialize the signal handler arrays
 */

static int SIG_init()
{
	int i;
#ifdef POSIX_SIGNALS
	sigset_t sigset_test;
#endif

	if (SIG_defaults && SIG_handlers)	/* already allocated */
		return (0);

#ifdef POSIX_SIGNALS
	(void) sigfillset(&sigset_test);
	for (i = 1; i < SIGMAX && sigismember(&sigset_test, i) == 1; i++)
		;
	if (i < SIGMAX)
		i = SIGMAX;
	i++;
	if (!SIG_defaults)
		SIG_defaults = (struct sigaction *)
			calloc(i, sizeof(struct sigaction));
	(void) sigemptyset(&SIG_crSectMask);
#else
	i = SIGMAX+1;
#ifdef BSD_SIGNALS
	if (!SIG_defaults)
		SIG_defaults = (struct sigvec *)
			calloc(i, sizeof(struct sigvec));
#else
	if (!SIG_defaults)
		SIG_defaults = (RETSIGTYPE (**) PROTO ((int)) )
			calloc(i, sizeof(RETSIGTYPE (**) PROTO ((int)) ));
#endif
	SIG_crSectMask = 0;
#endif
	if (!SIG_handlers)
		SIG_handlers = (struct SIG_hlist **)
			calloc(i, sizeof(struct SIG_hlist *));
	return (!SIG_defaults || !SIG_handlers);
}

/*
 * The following invokes each signal handler in the reverse order in which
 * they were registered.
 */
static RETSIGTYPE SIG_handle PROTO ((int));

static RETSIGTYPE SIG_handle(sig)
int			sig;
{
	struct SIG_hlist	*this;

	/* Dispatch signal handlers */
	this = SIG_handlers[sig];
	while (this != (struct SIG_hlist *) NULL)
	{
		/* handler may free this (and thus clobber this->next) */
		struct SIG_hlist *current = this;
		this = this->next;
		(*current->handler)(sig);
	}

	return;
}

/*
 * The following registers a signal handler.  If the handler is already
 * registered, it is not registered twice, nor is the order in which signal
 * handlers are invoked changed.  If this is the first signal handler
 * registered for a given signal, the old sigvec structure is saved for
 * restoration later.
 */

int SIG_register(sig,fn)
int	sig;
RETSIGTYPE	(*fn)();
{
	int			val;
	struct SIG_hlist	*this;
#ifdef POSIX_SIGNALS
	struct sigaction	act;
	sigset_t		sigset_mask, sigset_omask;
#else
#ifdef BSD_SIGNALS
	struct sigvec		vec;
	int			mask;
#endif
#endif

	/* Initialize */
	if (SIG_init() != 0)
		return (-1);
	val = 0;

	/* Block this signal while we look at handler chain */
#ifdef POSIX_SIGNALS
	(void) sigemptyset(&sigset_mask);
	(void) sigaddset(&sigset_mask, sig);
	(void) sigprocmask(SIG_BLOCK, &sigset_mask, &sigset_omask);
#else
#ifdef BSD_SIGNALS
	mask = sigblock(sigmask(sig));
#endif
#endif

	/* See if this handler was already registered */
	this = SIG_handlers[sig];
	while (this != (struct SIG_hlist *) NULL)
	{
		if (this->handler == fn) break;
		this = this->next;
	}

	/* Register the new handler only if it is not already registered. */
	if (this == (struct SIG_hlist *) NULL)
	{

		/*
		 * If this is the first handler registered for this signal,
		 * set up the signal handler dispatcher
		 */

		if (SIG_handlers[sig] == (struct SIG_hlist *) NULL)
		{
#ifdef POSIX_SIGNALS
			memset(&act, 0, sizeof act);
			act.sa_handler = SIG_handle;
			(void) sigemptyset(&act.sa_mask);
			act.sa_flags = 0;
			val = sigaction(sig, &act, &SIG_defaults[sig]);
#else
#ifdef BSD_SIGNALS
			memset (&vec, 0, sizeof (vec));
			vec.sv_handler = SIG_handle;
			val = sigvec(sig, &vec, &SIG_defaults[sig]);
#else
			if ((SIG_defaults[sig] = signal(sig, SIG_handle)) == SIG_ERR)
				val = -1;
#endif
#endif
		}

		/* If not, register it */
		if ((val == 0) && (this == (struct SIG_hlist *) NULL))
		{
			this = (struct SIG_hlist *)
			                      malloc(sizeof(struct SIG_hlist));
			if (this == NULL)
			{
				val = -1;
			}
			else
			{
				this->handler = fn;
				this->next = SIG_handlers[sig];
				SIG_handlers[sig] = this;
			}
		}
	}

	/* Unblock the signal */
#ifdef POSIX_SIGNALS
	(void) sigprocmask(SIG_SETMASK, &sigset_omask, NULL);
#else
#ifdef BSD_SIGNALS
	(void) sigsetmask(mask);
#endif
#endif

	return val;
}

/*
 * The following deregisters a signal handler.  If the last signal handler for
 * a given signal is deregistered, the default sigvec information is restored.
 */

int SIG_deregister(sig,fn)
int	sig;
RETSIGTYPE	(*fn)();
{
	int			val;
	struct SIG_hlist	*this;
	struct SIG_hlist	*last;
#ifdef POSIX_SIGNALS
	sigset_t		sigset_mask, sigset_omask;
#else
#ifdef BSD_SIGNALS
	int			mask;
#endif
#endif

	/* Initialize */
	if (SIG_init() != 0)
		return (-1);
	val = 0;
	last = (struct SIG_hlist *) NULL;

	/* Block this signal while we look at handler chain */
#ifdef POSIX_SIGNALS
	(void) sigemptyset(&sigset_mask);
	(void) sigaddset(&sigset_mask, sig);
	(void) sigprocmask(SIG_BLOCK, &sigset_mask, &sigset_omask);
#else
#ifdef BSD_SIGNALS
	mask = sigblock(sigmask(sig));
#endif
#endif

	/* Search for the signal handler */
	this = SIG_handlers[sig];
	while ((this != (struct SIG_hlist *) NULL) && (this->handler != fn))
	{
		last = this;
		this = this->next;
	}

	/* If it was registered, remove it */
	if (this != (struct SIG_hlist *) NULL)
	{
		if (last == (struct SIG_hlist *) NULL)
		{
			SIG_handlers[sig] = this->next;
		}
		else
		{
			last->next = this->next;
		}
		free((char *) this);
	}

	/* Restore default behavior if there are no registered handlers */
	if (SIG_handlers[sig] == (struct SIG_hlist *) NULL)
	{
#ifdef POSIX_SIGNALS
		val = sigaction(sig, &SIG_defaults[sig],
				(struct sigaction *) NULL);
#else
#ifdef BSD_SIGNALS
		val = sigvec(sig, &SIG_defaults[sig], (struct sigvec *) NULL);
#else
		if (signal(sig, SIG_defaults[sig]) == SIG_ERR)
			val = -1;
#endif
#endif
	}

	/* Unblock the signal */
#ifdef POSIX_SIGNALS
	(void) sigprocmask(SIG_SETMASK, &sigset_omask, NULL);
#else
#ifdef BSD_SIGNALS
	(void) sigsetmask(mask);
#endif
#endif

	return val;
}

/*
 * The following begins a critical section.
 */

void SIG_beginCrSect()
{
	if (SIG_init() == 0)
	{
		if (SIG_crSectNest == 0)
		{
#ifdef POSIX_SIGNALS
			sigset_t sigset_mask;

			(void) sigfillset(&sigset_mask);
			(void) sigprocmask(SIG_SETMASK,
					   &sigset_mask, &SIG_crSectMask);
#else
#ifdef BSD_SIGNALS
			SIG_crSectMask = sigblock(~0);
#else
			/* TBD */
#endif
#endif
		}
		SIG_crSectNest++;
	}
}

/*
 * Return nonzero if currently in a critical section.
 * Otherwise return zero.
 */

int SIG_inCrSect()
{
	return SIG_crSectNest > 0;
}

/*
 * The following ends a critical section.
 */

void SIG_endCrSect()
{
	if (SIG_init() == 0)
	{
		SIG_crSectNest--;
		if (SIG_crSectNest == 0)
		{
#ifdef POSIX_SIGNALS
			(void) sigprocmask(SIG_SETMASK, &SIG_crSectMask, NULL);
#else
#ifdef BSD_SIGNALS
			(void) sigsetmask(SIG_crSectMask);
#else
			/* TBD */
#endif
#endif
		}
	}
}
@


1.3
log
@Integrate local changes
@
text
@d158 2
a159 1
		(*this->handler)(sig);
d161 1
@


1.2
log
@zero sigaction before use
@
text
@d388 10
@


1.1
log
@Initial revision
@
text
@d12 1
a12 5
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
a28 2
 * $CVSid: @@(#)sighandle.c 1.13 94/10/07 $
 *
d34 1
d40 9
a60 4
#ifdef _MINIX
#undef	POSIX		/* Minix 1.6 doesn't support POSIX.1 sigaction yet */
#endif

d81 1
a81 1
#ifdef POSIX
d87 1
a87 1
static	RETSIGTYPE		(**SIG_defaults)();
d93 1
a93 1
#ifdef POSIX
d106 1
a106 1
#ifdef POSIX
d113 1
a113 1
#ifdef POSIX
d132 2
a133 2
		SIG_defaults = (RETSIGTYPE (**)())
			calloc(i, sizeof(RETSIGTYPE (**)()));
d147 1
d179 1
a179 1
#ifdef POSIX
d195 1
a195 1
#ifdef POSIX
d224 2
a225 1
#ifdef POSIX
d232 1
a232 1
			bzero((char *)&vec, sizeof(vec));
d236 1
a236 2
			if ((SIG_defaults[sig] = signal(sig, SIG_handle)) ==
			    (RETSIGTYPE (*)()) -1)
d261 1
a261 1
#ifdef POSIX
d284 1
a284 1
#ifdef POSIX
d299 1
a299 1
#ifdef POSIX
d334 1
a334 1
#ifdef POSIX
d341 1
a341 1
		if (signal(sig, SIG_defaults[sig]) == (RETSIGTYPE (*)()) -1)
d348 1
a348 1
#ifdef POSIX
d369 1
a369 1
#ifdef POSIX
d398 1
a398 1
#ifdef POSIX
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a39 1
#include "system.h"
a44 9
/* Add prototype support.  */
#ifndef PROTO
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#define PROTO(ARGS) ARGS
#else
#define PROTO(ARGS) ()
#endif
#endif

d57 4
d81 1
a81 1
#ifdef POSIX_SIGNALS
d87 1
a87 1
static	RETSIGTYPE		(**SIG_defaults) PROTO ((int));
d93 1
a93 1
#ifdef POSIX_SIGNALS
d106 1
a106 1
#ifdef POSIX_SIGNALS
d113 1
a113 1
#ifdef POSIX_SIGNALS
d132 2
a133 2
		SIG_defaults = (RETSIGTYPE (**) PROTO ((int)) )
			calloc(i, sizeof(RETSIGTYPE (**) PROTO ((int)) ));
a146 1
static RETSIGTYPE SIG_handle PROTO ((int));
d178 1
a178 1
#ifdef POSIX_SIGNALS
d194 1
a194 1
#ifdef POSIX_SIGNALS
d223 1
a223 1
#ifdef POSIX_SIGNALS
d230 1
a230 1
			memset (&vec, 0, sizeof (vec));
d234 2
a235 1
			if ((SIG_defaults[sig] = signal(sig, SIG_handle)) == SIG_ERR)
d260 1
a260 1
#ifdef POSIX_SIGNALS
d283 1
a283 1
#ifdef POSIX_SIGNALS
d298 1
a298 1
#ifdef POSIX_SIGNALS
d333 1
a333 1
#ifdef POSIX_SIGNALS
d340 1
a340 1
		if (signal(sig, SIG_defaults[sig]) == SIG_ERR)
d347 1
a347 1
#ifdef POSIX_SIGNALS
d368 1
a368 1
#ifdef POSIX_SIGNALS
d397 1
a397 1
#ifdef POSIX_SIGNALS
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@d12 5
a16 1
   GNU General Public License for more details.  */
d32 2
@


1.1.1.4
log
@Latest from Cyclic Software
@
text
@a386 10
 * Return nonzero if currently in a critical section.
 * Otherwise return zero.
 */

int SIG_inCrSect()
{
	return SIG_crSectNest > 0;
}

/*
@


