head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.6
	OPENBSD_6_1:1.1.1.6.0.78
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.74
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.70
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.72
	OPENBSD_5_8_BASE:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.64
	OPENBSD_5_7_BASE:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.68
	OPENBSD_5_6_BASE:1.1.1.6
	OPENBSD_5_5:1.1.1.6.0.66
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.62
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.60
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.58
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.56
	OPENBSD_5_0:1.1.1.6.0.54
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.52
	OPENBSD_4_9_BASE:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.50
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.46
	OPENBSD_4_7_BASE:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.48
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.44
	OPENBSD_4_5_BASE:1.1.1.6
	OPENBSD_4_4:1.1.1.6.0.42
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.40
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.38
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.36
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.34
	OPENBSD_4_0_BASE:1.1.1.6
	OPENBSD_3_9:1.1.1.6.0.32
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.30
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.28
	OPENBSD_3_7_BASE:1.1.1.6
	OPENBSD_3_6:1.1.1.6.0.26
	OPENBSD_3_6_BASE:1.1.1.6
	OPENBSD_3_5:1.1.1.6.0.24
	OPENBSD_3_5_BASE:1.1.1.6
	OPENBSD_3_4:1.1.1.6.0.22
	OPENBSD_3_4_BASE:1.1.1.6
	OPENBSD_3_3:1.1.1.6.0.20
	OPENBSD_3_3_BASE:1.1.1.6
	OPENBSD_3_2:1.1.1.6.0.18
	OPENBSD_3_2_BASE:1.1.1.6
	OPENBSD_3_1:1.1.1.6.0.16
	OPENBSD_3_1_BASE:1.1.1.6
	OPENBSD_3_0:1.1.1.6.0.14
	OPENBSD_3_0_BASE:1.1.1.6
	cvs-1-11-1p1:1.1.1.6
	OPENBSD_2_9:1.1.1.6.0.12
	OPENBSD_2_9_BASE:1.1.1.6
	cvs-1-11:1.1.1.6
	OPENBSD_2_8:1.1.1.6.0.10
	OPENBSD_2_8_BASE:1.1.1.6
	OPENBSD_2_7:1.1.1.6.0.8
	OPENBSD_2_7_BASE:1.1.1.6
	OPENBSD_2_6:1.1.1.6.0.6
	OPENBSD_2_6_BASE:1.1.1.6
	cvs-1-10-7:1.1.1.6
	OPENBSD_2_5:1.1.1.6.0.4
	OPENBSD_2_5_BASE:1.1.1.6
	cvs-1-10-5:1.1.1.6
	OPENBSD_2_4:1.1.1.6.0.2
	OPENBSD_2_4_BASE:1.1.1.6
	cvs-1-10:1.1.1.6
	cvs-1-9-28:1.1.1.5
	OPENBSD_2_3:1.1.1.5.0.6
	OPENBSD_2_3_BASE:1.1.1.5
	cvs-1-9-26:1.1.1.5
	cvs-1-9-24:1.1.1.5
	OPENBSD_2_2:1.1.1.5.0.4
	OPENBSD_2_2_BASE:1.1.1.5
	cvs-1-9-10:1.1.1.5
	OPENBSD_2_1:1.1.1.5.0.2
	OPENBSD_2_1_BASE:1.1.1.5
	cvs-1-9-8:1.1.1.5
	cvs-1-9-6:1.1.1.4
	cvs-1-9-4:1.1.1.4
	cvs-1-9-2:1.1.1.4
	cvs-1-9:1.1.1.4
	OPENBSD_2_0:1.1.1.3.0.2
	OPENBSD_2_0_BASE:1.1.1.3
	cvs-1-8-1:1.1.1.3
	cvs-1-8:1.1.1.3
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.44;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.19.33;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.05.06.22.20.56;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	96.10.18.03.36.34;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.04.21.04.29.12;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.08.22.20.55.00;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* startserver.c --- open a connection to the CVS server under Windows NT
   Jim Blandy <jimb@@cyclic.com> --- August 1995  */

#include "cvs.h"
#include "rcmd.h"

#include <stdlib.h>
#include <winsock.h>
#include <malloc.h>
#include <io.h>
#include <errno.h>


/* Apply the Winsock shutdown function to a CRT file descriptor.  */
static void
shutdown_fd (int fd, int how)
{
    SOCKET s;
    
    if ((s = _get_osfhandle (fd)) < 0)
        error (1, errno, "couldn't get socket handle from file descriptor");
    if (shutdown (s, how) == SOCKET_ERROR)
        error (1, 0, "couldn't shut down socket half");
}


void
wnt_start_server (int *tofd, int *fromfd,
		  char *client_user,
		  char *server_user,
		  char *server_host,
		  char *server_cvsroot)
{
    char *cvs_server;
    char *command;
    struct servent *s;
    unsigned short port;
    int read_fd, write_fd;

    if (! (cvs_server = getenv ("CVS_SERVER")))
        cvs_server = "cvs";
    command = alloca (strlen (cvs_server)
    		      + strlen (server_cvsroot)
		      + 50);
    sprintf (command, "%s -d %s server", cvs_server, server_cvsroot);

    if ((s = getservbyname("shell", "tcp")) == NULL)
	port = IPPORT_CMDSERVER;
    else
        port = ntohs (s->s_port);

    read_fd = rcmd (&server_host,
    	            port,
    	            client_user,
	            (server_user ? server_user : client_user),
	            command,
	            0);
    if (read_fd < 0)
	error (1, errno, "cannot start server via rcmd");
    
    /* Split the socket into a reading and a writing half.  */
    if ((write_fd = dup (read_fd)) < 0)
        error (1, errno, "duplicating server connection");
#if 0
    /* This ought to be legal, since I've duped it, but shutting
       down the writing end of read_fd seems to terminate the
       whole connection.  */
    shutdown_fd (read_fd, 1);
    shutdown_fd (write_fd, 0);
#endif
    
    *tofd = write_fd;
    *fromfd = read_fd;
}


void
wnt_shutdown_server (int fd)
{
    SOCKET s;
    
    if ((s = _get_osfhandle (fd)) < 0)
        error (1, errno, "couldn't get handle of server connection");
    if (shutdown (s, 2) == SOCKET_ERROR)
        error (1, 0, "couldn't shutdown server connection");
    if (closesocket (s) == SOCKET_ERROR)
        error (1, 0, "couldn't close server connection");
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@d50 1
a50 1
        port = s->s_port;
@


1.1.1.3
log
@New CVS release from Cyclic Software
@
text
@d36 1
a36 1
    struct servent *sptr;
d39 1
a39 2
    char *portenv;
    
d42 3
a44 3
    command = xmalloc (strlen (cvs_server)
		       + strlen (server_cvsroot)
		       + 50);
d47 2
a48 5
    portenv = getenv("CVS_RCMD_PORT");
    if (portenv)
	port = atoi(portenv);
    else if ((sptr = getservbyname("shell", "tcp")) != NULL)
	port = sptr->s_port;
d50 1
a50 1
	port = IPPORT_CMDSERVER; /* shell/tcp */
a73 1
    free (command);
@


1.1.1.4
log
@New release from Cyclic Software
@
text
@d13 14
d38 1
a38 1
    int read_fd;
d64 13
a76 2

    *tofd = read_fd;
d86 3
a88 2

    s = fd;
@


1.1.1.5
log
@Latest release from Cyclic Software
@
text
@d49 1
a49 2
	error (1, 0, "cannot start server via rcmd: %s",
	       SOCK_STRERROR (SOCK_ERRNO));
d64 1
a64 2
        error (1, 0, "couldn't shutdown server connection: %s",
	       SOCK_STRERROR (SOCK_ERRNO));
d66 1
a66 2
        error (1, 0, "couldn't close server connection: %s",
	       SOCK_STRERROR (SOCK_ERRNO));
@


1.1.1.6
log
@Latest version from Cyclic
@
text
@a12 6
/* Keep track of whether we've opened a socket so that wnt_shutdown_server
   can do the correct thing.  We don't want to call shutdown or
   closesocket on a pipe. */

static int opened_a_socket = 0;

a54 2

    opened_a_socket = 1;
d61 9
a69 17
    if (opened_a_socket)
    {
	SOCKET s;

	s = fd;
	if (shutdown (s, 2) == SOCKET_ERROR)
	    error (1, 0, "couldn't shutdown server connection: %s",
		   SOCK_STRERROR (SOCK_ERRNO));
	if (closesocket (s) == SOCKET_ERROR)
	    error (1, 0, "couldn't close server connection: %s",
		   SOCK_STRERROR (SOCK_ERRNO));
    }
    else
    {
	if (close (fd) < 0)
	    error (1, errno, "cannot close server connection");
    }
@


