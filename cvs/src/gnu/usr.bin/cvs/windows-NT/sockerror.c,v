head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.86
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.84
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.80
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.76
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.78
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.70
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.74
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.72
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.68
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.66
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.64
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.62
	OPENBSD_5_0:1.1.1.1.0.60
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.58
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.56
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.52
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.54
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.50
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.48
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.46
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.44
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.42
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.40
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.38
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.36
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.34
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.32
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.30
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.28
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.26
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.24
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.22
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.20
	OPENBSD_3_0_BASE:1.1.1.1
	cvs-1-11-1p1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.18
	OPENBSD_2_9_BASE:1.1.1.1
	cvs-1-11:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.16
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.14
	OPENBSD_2_7_BASE:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.12
	OPENBSD_2_6_BASE:1.1.1.1
	cvs-1-10-7:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.10
	OPENBSD_2_5_BASE:1.1.1.1
	cvs-1-10-5:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.8
	OPENBSD_2_4_BASE:1.1.1.1
	cvs-1-10:1.1.1.1
	cvs-1-9-28:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.6
	OPENBSD_2_3_BASE:1.1.1.1
	cvs-1-9-26:1.1.1.1
	cvs-1-9-24:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.4
	OPENBSD_2_2_BASE:1.1.1.1
	cvs-1-9-10:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	cvs-1-9-8:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	97.04.21.04.29.11;	author tholo;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.04.21.04.29.11;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* sockerror.c --- convert WinSock error number to string
   Vince Del Vecchio <vdelvecc@@spd.analog.com>

   This file is part of GNU CVS.

   GNU CVS is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.  */

#include <stdio.h>
#include <winsock.h>

struct err_strs {
    char **strs;
    int first;
    int last;
};

static char *errs1[] = {
    /* EINTR		*/ "Interrupted system call"
};

static char *errs2[] = {
    /* EBADF		*/ "Bad file descriptor"
};

static char *errs3[] = {
    /* EACCES		*/ "Permission denied",
    /* EFAULT		*/ "Bad address"
};

static char *errs4[] = {
    /* EINVAL		*/ "Invalid argument"
};

static char *errs5[] = {
    /* EMFILE		*/ "Too many open files",
};

static char *errs6[] = {
    /* EWOULDBLOCK	*/ "Resource temporarily unavailable",
    /* EINPROGRESS	*/ "Operation now in progress",
    /* EALREADY		*/ "Operation already in progress",
    /* ENOTSOCK		*/ "Socket operation on non-socket",
    /* EDESTADDRREQ	*/ "Destination address required",
    /* EMSGSIZE		*/ "Message too long",
    /* EPROTOTYPE	*/ "Protocol wrong type for socket",
    /* ENOPROTOOPT	*/ "Protocol not available",
    /* EPROTONOSUPPORT	*/ "Protocol not supported",
    /* ESOCKTNOSUPPORT	*/ "Socket type not supported",
    /* EOPNOTSUPP	*/ "Operation not supported on socket",
    /* EPFNOSUPPORT	*/ "Protocol family not supported",
    /* EAFNOSUPPORT	*/ "Address family not supported by protocol",
    /* EADDRINUSE	*/ "Address already in use",
    /* EADDRNOTAVAIL	*/ "Can't assign requested address",
    /* ENETDOWN		*/ "Network is down",
    /* ENETUNREACH	*/ "Network is unreachable",
    /* ENETRESET	*/ "Network connection dropped on reset",
    /* ECONNABORTED	*/ "Software caused connection abort",
    /* ECONNRESET	*/ "Connection reset by peer",
    /* ENOBUFS		*/ "No buffer space available",
    /* EISCONN		*/ "Socket is already connected",
    /* ENOTCONN		*/ "Socket is not connected",
    /* ESHUTDOWN	*/ "Can't send after socket shutdown",
    /* ETOOMANYREFS	*/ "Too many references: can't splice",
    /* ETIMEDOUT	*/ "Connection timed out",
    /* ECONNREFUSED	*/ "Connection refused",
    /* ELOOP		*/ "Too many levels of symbolic links",
    /* ENAMETOOLONG	*/ "File name too long",
    /* EHOSTDOWN	*/ "Host is down",
    /* EHOSTUNREACH	*/ "No route to host",
    /* ENOTEMPTY	*/ "Directory not empty",
    /* EPROCLIM		*/ "Too many processes",
    /* EUSERS		*/ "Too many users",
    /* EDQUOT		*/ "Disc quota exceeded",
    /* ESTALE		*/ "Stale NFS file handle",
    /* EREMOTE		*/ "Object is remote"
};

static char *errs7[] = {
    /* SYSNOTREADY	*/ "Network subsystem unavailable",
    /* VERNOTSUPPORTED	*/ "Requested WinSock version not supported",
    /* NOTINITIALISED	*/ "WinSock was not initialized"
};

#ifdef WSAEDISCON
static char *errs8[] = {
    /* EDISCON		*/ "Graceful shutdown in progress"
};
#endif

static char *errs9[] = {
    /* HOST_NOT_FOUND	*/ "Unknown host",
    /* TRY_AGAIN	*/ "Host name lookup failure",
    /* NO_RECOVERY	*/ "Unknown server error",
    /* NO_DATA		*/ "No address associated with name",
};

/* Some of these errors are defined in the winsock.h header file I have,
   but not in the Winsock 1.1 spec.  I include them some of them anyway,
   where it is not too hard to avoid referencing the symbolic constant. */

static struct err_strs sock_errlist[] = {
    { errs1,	WSAEINTR,	WSAEINTR },
    { errs2,	WSAEBADF,	WSAEBADF },
    { errs3,	WSAEACCES,	WSAEFAULT },
    { errs4,	WSAEINVAL,	WSAEINVAL },
    { errs5,	WSAEMFILE,	WSAEMFILE },
    { errs6,	WSAEWOULDBLOCK, WSAEHOSTUNREACH + 6 },
    { errs7,	WSASYSNOTREADY,	WSANOTINITIALISED },
#ifdef WSAEDISCON
    { errs8,	WSAEDISCON,	WSAEDISCON },
#endif
    { errs9,	WSAHOST_NOT_FOUND, WSANO_DATA }
};

char *
sock_strerror (int errnum)
{
    static char buf[40];
    int i;

    for (i = 0; i < (sizeof sock_errlist / sizeof *sock_errlist); i++)
    {
	if (errnum >= sock_errlist[i].first && errnum <= sock_errlist[i].last)
	    return sock_errlist[i].strs[errnum - sock_errlist[i].first];
    }
    sprintf(buf, "Unknown socket error: %d", errnum);
    return buf;
}
@


1.1.1.1
log
@Latest release from Cyclic Software
@
text
@@

