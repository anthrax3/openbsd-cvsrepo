head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.6.0.78
	OPENBSD_6_2_BASE:1.1.1.6
	OPENBSD_6_1:1.1.1.6.0.80
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.76
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.72
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.74
	OPENBSD_5_8_BASE:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.66
	OPENBSD_5_7_BASE:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.70
	OPENBSD_5_6_BASE:1.1.1.6
	OPENBSD_5_5:1.1.1.6.0.68
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.64
	OPENBSD_5_4_BASE:1.1.1.6
	OPENBSD_5_3:1.1.1.6.0.62
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.60
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.58
	OPENBSD_5_0:1.1.1.6.0.56
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.54
	OPENBSD_4_9_BASE:1.1.1.6
	OPENBSD_4_8:1.1.1.6.0.52
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.48
	OPENBSD_4_7_BASE:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.50
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.46
	OPENBSD_4_5_BASE:1.1.1.6
	OPENBSD_4_4:1.1.1.6.0.44
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.42
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.40
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.38
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.36
	OPENBSD_4_0_BASE:1.1.1.6
	OPENBSD_3_9:1.1.1.6.0.34
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.32
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.30
	OPENBSD_3_7_BASE:1.1.1.6
	OPENBSD_3_6:1.1.1.6.0.28
	OPENBSD_3_6_BASE:1.1.1.6
	OPENBSD_3_5:1.1.1.6.0.26
	OPENBSD_3_5_BASE:1.1.1.6
	OPENBSD_3_4:1.1.1.6.0.24
	OPENBSD_3_4_BASE:1.1.1.6
	OPENBSD_3_3:1.1.1.6.0.22
	OPENBSD_3_3_BASE:1.1.1.6
	OPENBSD_3_2:1.1.1.6.0.20
	OPENBSD_3_2_BASE:1.1.1.6
	OPENBSD_3_1:1.1.1.6.0.18
	OPENBSD_3_1_BASE:1.1.1.6
	OPENBSD_3_0:1.1.1.6.0.16
	OPENBSD_3_0_BASE:1.1.1.6
	cvs-1-11-1p1:1.1.1.6
	OPENBSD_2_9:1.1.1.6.0.14
	OPENBSD_2_9_BASE:1.1.1.6
	cvs-1-11:1.1.1.6
	OPENBSD_2_8:1.1.1.6.0.12
	OPENBSD_2_8_BASE:1.1.1.6
	OPENBSD_2_7:1.1.1.6.0.10
	OPENBSD_2_7_BASE:1.1.1.6
	OPENBSD_2_6:1.1.1.6.0.8
	OPENBSD_2_6_BASE:1.1.1.6
	cvs-1-10-7:1.1.1.6
	OPENBSD_2_5:1.1.1.6.0.6
	OPENBSD_2_5_BASE:1.1.1.6
	cvs-1-10-5:1.1.1.6
	OPENBSD_2_4:1.1.1.6.0.4
	OPENBSD_2_4_BASE:1.1.1.6
	cvs-1-10:1.1.1.6
	cvs-1-9-28:1.1.1.6
	OPENBSD_2_3:1.1.1.6.0.2
	OPENBSD_2_3_BASE:1.1.1.6
	cvs-1-9-26:1.1.1.6
	cvs-1-9-24:1.1.1.6
	OPENBSD_2_2:1.1.1.5.0.2
	OPENBSD_2_2_BASE:1.1.1.5
	cvs-1-9-10:1.1.1.5
	OPENBSD_2_1:1.1.1.4.0.2
	OPENBSD_2_1_BASE:1.1.1.4
	cvs-1-9-8:1.1.1.4
	cvs-1-9-6:1.1.1.3
	cvs-1-9-4:1.1.1.3
	cvs-1-9-2:1.1.1.3
	cvs-1-9:1.1.1.3
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	cvs-1-8-1:1.1.1.2
	cvs-1-8:1.1.1.2
	cvs-1-7-2:1.1.1.2
	cvs-1-7-1:1.1.1.2
	cvs-1-6:1.1.1.1
	cyclic:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.19.09.21.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.19.09.21.44;	author deraadt;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.01.30.00.19.31;	author tholo;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.10.18.03.36.33;	author tholo;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.04.21.04.29.09;	author tholo;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.06.28.03.29.38;	author tholo;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	98.02.22.08.22.21;	author tholo;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* rcmd.c --- execute a command on a remote host from Windows NT
   Jim Blandy <jimb@@cyclic.com> --- August 1995  */

#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <errno.h>
#include <winsock.h>
#include <assert.h>

#include "rcmd.h"

static int
init_winsock ()
{
    static char initialized = 0;
    WSADATA data;

    if (initialized)
        return 0;

    if (WSAStartup (MAKEWORD (1, 1), &data))
        return -1;

    {
        int optionValue = SO_SYNCHRONOUS_NONALERT;

        if (setsockopt(INVALID_SOCKET, SOL_SOCKET,
                       SO_OPENTYPE, (char *)&optionValue, sizeof(optionValue))
	    == SOCKET_ERROR)
	    return -1;
    }

    initialized = 1;

    return 0;
}

static int
resolve_address (const char **ahost, struct sockaddr_in *sai)
{
    {
	unsigned long addr = inet_addr (*ahost);

	if (addr != (unsigned long) -1)
	{
	    sai->sin_family = AF_INET;
	    sai->sin_addr.s_addr = addr;
	    return 0;
	}
    }

    {
        struct hostent *e = gethostbyname (*ahost);

	if (e)
	{
	    assert (e->h_addrtype == AF_INET);
	    assert (e->h_addr);
	    *ahost = e->h_name;
	    sai->sin_family = AF_INET;
	    memcpy (&sai->sin_addr, e->h_addr, sizeof (sai->sin_addr));
	    return 0;
	}
    }

    return -1;
}

#if 0
static int
bind_local_end (SOCKET s)
{
    struct sockaddr_in sai;
    int result;
    u_short port;

    sai.sin_family = AF_INET;
    sai.sin_addr.s_addr = htonl (INADDR_ANY);

    for (port = IPPORT_RESERVED - 2; port >= IPPORT_RESERVED/2; port--)
    {
    	int error;
        sai.sin_port = htons (port);
	result = bind (s, (struct sockaddr *) &sai, sizeof (sai));
	error = GetLastError ();
	if (result != SOCKET_ERROR || error != WSAEADDRINUSE)
	    break;
    }

    return result;
}
#endif

static SOCKET
bind_and_connect (struct sockaddr_in *server_sai)
{
    SOCKET s;
    struct sockaddr_in client_sai;
    u_short client_port;

    client_sai.sin_family = AF_INET;
    client_sai.sin_addr.s_addr = htonl (INADDR_ANY);

    for (client_port = IPPORT_RESERVED - 1;
         client_port >= IPPORT_RESERVED/2;
         client_port--)
    {
        int result, error;
	client_sai.sin_port = htons (client_port);

        if ((s = socket (PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
            return INVALID_SOCKET;

	result = bind (s, (struct sockaddr *) &client_sai,
	               sizeof (client_sai));
	error = GetLastError ();
	if (result == SOCKET_ERROR)
	{
	    closesocket (s);
	    if (error == WSAEADDRINUSE)
		continue;
	    else
	        return INVALID_SOCKET;
	}

	result = connect (s, (struct sockaddr *) server_sai,
	                  sizeof (*server_sai));
	error = GetLastError ();
	if (result == SOCKET_ERROR)
	{
	    closesocket (s);
	    if (error == WSAEADDRINUSE)
		continue;
	    else
	        return INVALID_SOCKET;
	}

	return s;
    }

    /* We couldn't find a free port.  */
    return INVALID_SOCKET;
}

static int
rcmd_authenticate (int fd, char *locuser, char *remuser, char *command)
{
    /* Send them a bunch of information, each terminated by '\0':
       - secondary stream port number (we don't use this)
       - username on local machine
       - username on server machine
       - command
       Now, the Ultrix man page says you transmit the username on the
       server first, but that doesn't seem to work.  Transmitting the
       client username first does.  Go figure.  The Linux man pages
       get it right --- hee hee.  */
    if (write (fd, "0\0", 2) < 0
	|| write (fd, locuser, strlen (locuser) + 1) < 0
        || write (fd, remuser, strlen (remuser) + 1) < 0
	|| write (fd, command, strlen (command) + 1) < 0)
	return -1;

    /* They sniff our butt, and send us a '\0' character if they
       like us.  */
    {
        char c;
        if (read (fd, &c, 1) <= 0
	    || c != '\0')
	{
	    errno = EPERM;
	    return -1;
	}
    }

    return 0;
}

int
rcmd (const char **ahost,
      unsigned short inport,
      char *locuser,
      char *remuser,
      char *cmd,
      int *fd2p)
{
    struct sockaddr_in sai;
    SOCKET s;
    int fd;

    assert (fd2p == 0);

    if (init_winsock () < 0)
        return -1;

    if (resolve_address (ahost, &sai) < 0)
        return -1;

    sai.sin_port = htons (inport);

#if 0
    if ((s = socket (PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        return -1;

    if (bind_local_end (s) < 0)
        return -1;

    if (connect (s, (struct sockaddr *) &sai, sizeof (sai))
        == SOCKET_ERROR)
        return -1;
#else
    if ((s = bind_and_connect (&sai)) == INVALID_SOCKET)
        return -1;
#endif

    /* When using WinSock under Windows NT, sockets are low-level Windows
       NT handles.  Turn the socket we've made into a Unix-like file
       descriptor.  */
    if ((fd = _open_osfhandle (s, _O_BINARY)) < 0)
        return -1;

    if (rcmd_authenticate (fd, locuser, remuser, cmd) < 0)
        return -1;

    return fd;
}
@


1.1.1.1
log
@raw import of cvs-1.6
@
text
@@


1.1.1.2
log
@Upgrade to 1.7.1 snapshot
@
text
@a8 1
#include <stdio.h>
d13 1
a13 1
void
d16 1
d18 3
a20 1
    int optionValue = SO_SYNCHRONOUS_NONALERT;
d23 2
d26 6
a31 2
      fprintf (stderr, "cvs: unable to initialize winsock\n");
      exit (1);
d34 3
a36 7
     if (setsockopt(INVALID_SOCKET, SOL_SOCKET,
                    SO_OPENTYPE, (char *)&optionValue, sizeof(optionValue))
         == SOCKET_ERROR)
     {
         fprintf (stderr, "cvs: unable to setup winsock\n");
         exit (1);
     }
d192 3
@


1.1.1.3
log
@New release from Cyclic Software
@
text
@a11 1
#include "cvs.h"
d154 4
a157 4
    if ((send (fd, "0\0", 2, 0) == SOCKET_ERROR)
	|| (send (fd, locuser, strlen (locuser) + 1, 0) == SOCKET_ERROR)
	|| (send (fd, remuser, strlen (remuser) + 1, 0) == SOCKET_ERROR)
	|| (send (fd, command, strlen (command) + 1, 0) == SOCKET_ERROR))
d164 1
a164 1
	if (recv (fd, &c, 1, 0) == SOCKET_ERROR
d185 1
d209 4
a212 1
    if (rcmd_authenticate (s, locuser, remuser, cmd) < 0)
d215 4
a218 1
    return s;
@


1.1.1.4
log
@Latest release from Cyclic Software
@
text
@d19 1
d26 8
a35 7
/* The rest of this file contains the rcmd() code, which is used
   only by START_SERVER.  The idea for a long-term direction is
   that this code can be made portable (by using SOCK_ERRNO and
   so on), and then moved to client.c or someplace it can be
   shared with the VMS port and any other ports which may want it.  */


d64 1
a64 1
    error (1, 0, "no such host %s", *ahost);
d67 25
d106 1
a106 1
	int result, errcode;
d110 1
a110 2
	    error (1, 0, "cannot create socket: %s",
		   SOCK_STRERROR (SOCK_ERRNO));
d114 1
a114 1
	errcode = SOCK_ERRNO;
d118 1
a118 1
	    if (errcode == WSAEADDRINUSE)
d121 1
a121 2
		error (1, 0, "cannot bind to socket: %s",
		       SOCK_STRERROR (errcode));
d126 1
a126 1
	errcode = SOCK_ERRNO;
d130 1
a130 1
	    if (errcode == WSAEADDRINUSE)
d133 1
a133 2
		error (1, 0, "cannot connect to socket: %s",
		       SOCK_STRERROR (errcode));
d139 2
a140 1
    error (1, 0, "cannot find free port");
d159 1
a159 2
	error (1, 0, "cannot send authentication info to rshd: %s",
	       SOCK_STRERROR (SOCK_ERRNO));
d165 2
a166 6
	if (recv (fd, &c, 1, 0) == SOCKET_ERROR)
	{
	    error (1, 0, "cannot receive authentication info from rshd: %s",
		   SOCK_STRERROR (SOCK_ERRNO));
	}
	if (c != '\0')
d168 2
a169 1
	    error (1, 0, "Permission denied by rshd");
d190 1
a190 1
        error (1, 0, "internal error: resolve_address < 0");
d194 11
d206 2
a207 1
	error (1, 0, "internal error: bind_and_connect < 0");
d210 1
a210 1
	error (1, 0, "internal error: rcmd_authenticate < 0");
@


1.1.1.5
log
@Latest version from Cyclic Software
@
text
@a1 11

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

d8 1
a8 20

#ifdef HAVE_WINSOCK_H
  #include <winsock.h>
#else
  #include <sys/types.h>
  #include <sys/socket.h>
  #include <netinet/in.h>
  #include <netdb.h>
  typedef int SOCKET;
  #define closesocket close
  #define SOCK_ERRNO errno
  #define SOCK_STRERROR strerror
  /* Probably would be cleaner to just use EADDRINUSE, as NT has that too.  */
  #define WSAEADDRINUSE EADDRINUSE
  /* Probably would be cleaner to just check for < 0.  Might want to
     double-check that doing so would seem to work on NT.  */
  #define SOCKET_ERROR -1
  #define INVALID_SOCKET -1
#endif

d15 12
a62 2
    /* Shut up gcc -Wall.  */
    return 1;
a115 2
    /* Shut up gcc -Wall.  */
	return s;
@


1.1.1.6
log
@Latest version from Cyclic
@
text
@a14 3
#include "cvs.h"
#include "rcmd.h"

d42 3
a169 5
	    /* All the junk with USER, LOGNAME, GetUserName, &c, is so
	       confusing that we better give some clue as to what sort
	       of user name we decided on.  */
	    error (0, 0, "cannot log in as local user '%s', remote user '%s'",
		   locuser, remuser);
@

