head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.46
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.42
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.38
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.40
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.32
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.36
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.34
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.30
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.28
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.26
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.24
	OPENBSD_5_0:1.3.0.22
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.20
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.18
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.16
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.12
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	TEXINFO_4_8:1.1.1.3
	OPENBSD_3_9:1.2.0.2
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.1.1.2.0.14
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.12
	OPENBSD_3_7_BASE:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.10
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	TEXINFO_4_0:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2006.01.08.18.08.18;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.09.01.25.09;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.09.01.25.09;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.10.13.21.15;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.07.17.16.03.46;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@conflict resolution
@
text
@/* cmds.c -- Texinfo commands.
   $Id: cmds.c,v 1.55 2004/12/14 00:15:36 karl Exp $

   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "system.h"
#include "cmds.h"
#include "defun.h"
#include "files.h"
#include "footnote.h"
#include "html.h"
#include "insertion.h"
#include "lang.h"
#include "macro.h"
#include "makeinfo.h"
#include "node.h"
#include "sectioning.h"
#include "toc.h"
#include "xml.h"

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif

/* Options. */
static void cm_exampleindent (void),
     cm_firstparagraphindent (void),
     cm_paragraphindent (void),
     cm_novalidate (void);

/* Internals. */
static void cm_obsolete (int arg, int start, int end),
     not_fixed_width (int arg);

/* The dispatch table.  */
COMMAND command_table[] = {
  { "\t", insert_space, NO_BRACE_ARGS },
  { "\n", insert_space, NO_BRACE_ARGS },
  { " ", insert_space, NO_BRACE_ARGS },
  { "!", cm_punct, NO_BRACE_ARGS },
  { "\"", cm_accent_umlaut, MAYBE_BRACE_ARGS },
  { "'", cm_accent_acute, MAYBE_BRACE_ARGS },
  { "*", cm_asterisk, NO_BRACE_ARGS },
  { ",", cm_accent_cedilla, MAYBE_BRACE_ARGS },
  { "-", cm_no_op, NO_BRACE_ARGS },
  { ".", cm_punct, NO_BRACE_ARGS },
  { "/", cm_no_op, NO_BRACE_ARGS },
  { ":", cm_colon, NO_BRACE_ARGS },
  { "=", cm_accent, MAYBE_BRACE_ARGS },
  { "?", cm_punct, NO_BRACE_ARGS },
  { "@@", insert_self, NO_BRACE_ARGS },
  { "\\", insert_self, NO_BRACE_ARGS },
  { "^", cm_accent_hat, MAYBE_BRACE_ARGS },
  { "`", cm_accent_grave, MAYBE_BRACE_ARGS },
  { "{", insert_self, NO_BRACE_ARGS },
  { "|", cm_no_op, NO_BRACE_ARGS },
  { "}", insert_self, NO_BRACE_ARGS },
  { "~", cm_accent_tilde, MAYBE_BRACE_ARGS },
  { "AA", cm_special_char, BRACE_ARGS },
  { "AE", cm_special_char, BRACE_ARGS },
  { "H", cm_accent, MAYBE_BRACE_ARGS },
  { "L", cm_special_char, BRACE_ARGS },
  { "LaTeX", cm_LaTeX, BRACE_ARGS },
  { "O", cm_special_char, BRACE_ARGS },
  { "OE", cm_special_char, BRACE_ARGS },
  { "TeX", cm_TeX, BRACE_ARGS },
  { "aa", cm_special_char, BRACE_ARGS },
  { "abbr", cm_abbr, BRACE_ARGS },
  { "acronym", cm_acronym, BRACE_ARGS },
  { "ae", cm_special_char, BRACE_ARGS },
  { "afivepaper", cm_ignore_line, NO_BRACE_ARGS },
  { "afourlatex", cm_ignore_line, NO_BRACE_ARGS },
  { "afourpaper", cm_ignore_line, NO_BRACE_ARGS },
  { "afourwide", cm_ignore_line, NO_BRACE_ARGS },
  { "alias", cm_alias, NO_BRACE_ARGS },
  { "anchor", cm_anchor, BRACE_ARGS },
  { "appendix", cm_appendix, NO_BRACE_ARGS },
  { "appendixsection", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsec", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsubsec", cm_appendixsubsec, NO_BRACE_ARGS },
  { "appendixsubsubsec", cm_appendixsubsubsec, NO_BRACE_ARGS },
  { "asis", cm_no_op, BRACE_ARGS },
  { "author", cm_author, NO_BRACE_ARGS },
  { "b", cm_b, BRACE_ARGS },
  { "bullet", cm_bullet, BRACE_ARGS },
  { "bye", cm_bye, NO_BRACE_ARGS },
  { "c", cm_comment, NO_BRACE_ARGS },
  { "caption", cm_caption, BRACE_ARGS },
  { "cartouche", cm_cartouche, NO_BRACE_ARGS },
  { "center", cm_center, NO_BRACE_ARGS },
  { "centerchap", cm_unnumbered, NO_BRACE_ARGS },
  { "chapheading", cm_chapheading, NO_BRACE_ARGS },
  { "chapter", cm_chapter, NO_BRACE_ARGS },
  { "cindex", cm_cindex, NO_BRACE_ARGS },
  { "cite", cm_cite, BRACE_ARGS },
  { "clear", cm_clear, NO_BRACE_ARGS },
  { "code", cm_code, BRACE_ARGS },
  { "comma", cm_comma, BRACE_ARGS },
  { "command", cm_code, BRACE_ARGS },
  { "comment", cm_comment, NO_BRACE_ARGS },
  { "contents", cm_contents, NO_BRACE_ARGS },
  { "copying", cm_copying, NO_BRACE_ARGS },
  { "copyright", cm_copyright, BRACE_ARGS },
  { "ctrl", cm_obsolete, BRACE_ARGS },
  { "defcodeindex", cm_defcodeindex, NO_BRACE_ARGS },
  { "defcv", cm_defun, NO_BRACE_ARGS },
  { "defcvx", cm_defun, NO_BRACE_ARGS },
  { "deffn", cm_defun, NO_BRACE_ARGS },
  { "deffnx", cm_defun, NO_BRACE_ARGS },
  { "defindex", cm_defindex, NO_BRACE_ARGS },
  { "definfoenclose", cm_definfoenclose, NO_BRACE_ARGS },
  { "defivar", cm_defun, NO_BRACE_ARGS },
  { "defivarx", cm_defun, NO_BRACE_ARGS },
  { "defmac", cm_defun, NO_BRACE_ARGS },
  { "defmacx", cm_defun, NO_BRACE_ARGS },
  { "defmethod", cm_defun, NO_BRACE_ARGS },
  { "defmethodx", cm_defun, NO_BRACE_ARGS },
  { "defop", cm_defun, NO_BRACE_ARGS },
  { "defopt", cm_defun, NO_BRACE_ARGS },
  { "defoptx", cm_defun, NO_BRACE_ARGS },
  { "defopx", cm_defun, NO_BRACE_ARGS },
  { "defspec", cm_defun, NO_BRACE_ARGS },
  { "defspecx", cm_defun, NO_BRACE_ARGS },
  { "deftp", cm_defun, NO_BRACE_ARGS },
  { "deftpx", cm_defun, NO_BRACE_ARGS },
  { "deftypecv", cm_defun, NO_BRACE_ARGS },
  { "deftypecvx", cm_defun, NO_BRACE_ARGS },
  { "deftypefn", cm_defun, NO_BRACE_ARGS },
  { "deftypefnx", cm_defun, NO_BRACE_ARGS },
  { "deftypefun", cm_defun, NO_BRACE_ARGS },
  { "deftypefunx", cm_defun, NO_BRACE_ARGS },
  { "deftypeivar", cm_defun, NO_BRACE_ARGS },
  { "deftypeivarx", cm_defun, NO_BRACE_ARGS },
  { "deftypemethod", cm_defun, NO_BRACE_ARGS },
  { "deftypemethodx", cm_defun, NO_BRACE_ARGS },
  { "deftypeop", cm_defun, NO_BRACE_ARGS },
  { "deftypeopx", cm_defun, NO_BRACE_ARGS },
  { "deftypevar", cm_defun, NO_BRACE_ARGS },
  { "deftypevarx", cm_defun, NO_BRACE_ARGS },
  { "deftypevr", cm_defun, NO_BRACE_ARGS },
  { "deftypevrx", cm_defun, NO_BRACE_ARGS },
  { "defun", cm_defun, NO_BRACE_ARGS },
  { "defunx", cm_defun, NO_BRACE_ARGS },
  { "defvar", cm_defun, NO_BRACE_ARGS },
  { "defvarx", cm_defun, NO_BRACE_ARGS },
  { "defvr", cm_defun, NO_BRACE_ARGS },
  { "defvrx", cm_defun, NO_BRACE_ARGS },
  { "detailmenu", cm_detailmenu, NO_BRACE_ARGS },
  { "dfn", cm_dfn, BRACE_ARGS },
  { "dircategory", cm_dircategory, NO_BRACE_ARGS },
  { "direntry", cm_direntry, NO_BRACE_ARGS },
  { "display", cm_display, NO_BRACE_ARGS },
  { "dmn", cm_dmn, BRACE_ARGS },
  { "docbook", cm_docbook, NO_BRACE_ARGS },
  { "documentdescription", cm_documentdescription, NO_BRACE_ARGS },
  { "documentencoding", cm_documentencoding, NO_BRACE_ARGS },
  { "documentlanguage", cm_documentlanguage, NO_BRACE_ARGS },
  { "dotaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "dotless", cm_dotless, BRACE_ARGS },
  { "dots", cm_dots, BRACE_ARGS },
  { "email", cm_email, BRACE_ARGS },
  { "emph", cm_emph, BRACE_ARGS },
  { "end", cm_end, NO_BRACE_ARGS },
  { "enddots", cm_enddots, BRACE_ARGS },
  { "enumerate", cm_enumerate, NO_BRACE_ARGS },
  { "env", cm_code, BRACE_ARGS },
  { "equiv", cm_equiv, BRACE_ARGS },
  { "error", cm_error, BRACE_ARGS },
  { "euro", cm_special_char, BRACE_ARGS },
  { "evenfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "evenheading", cm_ignore_line, NO_BRACE_ARGS },
  { "everyfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "everyheading", cm_ignore_line, NO_BRACE_ARGS },
  { "example", cm_example, NO_BRACE_ARGS },
  { "exampleindent", cm_exampleindent, NO_BRACE_ARGS },
  { "exclamdown", cm_special_char, BRACE_ARGS },
  { "exdent", cm_exdent, NO_BRACE_ARGS },
  { "expansion", cm_expansion, BRACE_ARGS },
  { "file", cm_code, BRACE_ARGS },
  { "finalout", cm_no_op, NO_BRACE_ARGS },
  { "findex", cm_findex, NO_BRACE_ARGS },
  { "firstparagraphindent", cm_firstparagraphindent, NO_BRACE_ARGS },
  { "float", cm_float, NO_BRACE_ARGS },
  { "flushleft", cm_flushleft, NO_BRACE_ARGS },
  { "flushright", cm_flushright, NO_BRACE_ARGS },
  { "footnote", cm_footnote, NO_BRACE_ARGS}, /* self-arg eater */
  { "footnotestyle", cm_footnotestyle, NO_BRACE_ARGS },
  { "format", cm_format, NO_BRACE_ARGS },
  { "ftable", cm_ftable, NO_BRACE_ARGS },
  { "group", cm_group, NO_BRACE_ARGS },
  { "heading", cm_heading, NO_BRACE_ARGS },
  { "headings", cm_ignore_line, NO_BRACE_ARGS },
  { "headitem", cm_headitem, NO_BRACE_ARGS },
  { "html", cm_html, NO_BRACE_ARGS },
  { "hyphenation", cm_ignore_arg, BRACE_ARGS },
  { "i", cm_i, BRACE_ARGS },
  { "ifclear", cm_ifclear, NO_BRACE_ARGS },
  { "ifeq", cm_ifeq, NO_BRACE_ARGS },
  { "ifdocbook", cm_ifdocbook, NO_BRACE_ARGS },
  { "ifhtml", cm_ifhtml, NO_BRACE_ARGS },
  { "ifinfo", cm_ifinfo, NO_BRACE_ARGS },
  { "ifnotdocbook", cm_ifnotdocbook, NO_BRACE_ARGS },
  { "ifnothtml", cm_ifnothtml, NO_BRACE_ARGS },
  { "ifnotinfo", cm_ifnotinfo, NO_BRACE_ARGS },
  { "ifnotplaintext", cm_ifnotplaintext, NO_BRACE_ARGS },
  { "ifnottex", cm_ifnottex, NO_BRACE_ARGS },
  { "ifnotxml", cm_ifnotxml, NO_BRACE_ARGS },
  { "ifplaintext", cm_ifplaintext, NO_BRACE_ARGS },
  { "ifset", cm_ifset, NO_BRACE_ARGS },
  { "iftex", cm_iftex, NO_BRACE_ARGS },
  { "ifxml", cm_ifxml, NO_BRACE_ARGS },
  { "ignore", command_name_condition, NO_BRACE_ARGS },
  { "image", cm_image, BRACE_ARGS },
  { "include", cm_include, NO_BRACE_ARGS },
  { "indent", cm_indent, NO_BRACE_ARGS },
  { "indicateurl", cm_indicate_url, BRACE_ARGS },
  { "inforef", cm_inforef, BRACE_ARGS },
  { "insertcopying", cm_insert_copying, NO_BRACE_ARGS },
  { "item", cm_item, NO_BRACE_ARGS },
  { "itemize", cm_itemize, NO_BRACE_ARGS },
  { "itemx", cm_itemx, NO_BRACE_ARGS },
  { "kbd", cm_kbd, BRACE_ARGS },
  { "kbdinputstyle", cm_ignore_line, NO_BRACE_ARGS },
  { "key", cm_key, BRACE_ARGS },
  { "kindex", cm_kindex, NO_BRACE_ARGS },
  { "l", cm_special_char, BRACE_ARGS },
  { "lisp", cm_lisp, NO_BRACE_ARGS },
  { "listoffloats", cm_listoffloats, NO_BRACE_ARGS },
  { "lowersections", cm_lowersections, NO_BRACE_ARGS },
  { "macro", cm_macro, NO_BRACE_ARGS },
  { "majorheading", cm_majorheading, NO_BRACE_ARGS },
  { "math", cm_math, BRACE_ARGS },
  { "menu", cm_menu, NO_BRACE_ARGS },
  { "minus", cm_minus, BRACE_ARGS },
  { "multitable", cm_multitable, NO_BRACE_ARGS },
  { "need", cm_ignore_line, NO_BRACE_ARGS },
  { "node", cm_node, NO_BRACE_ARGS },
  { "noindent", cm_noindent_cmd, NO_BRACE_ARGS },
  { "novalidate", cm_novalidate, NO_BRACE_ARGS },
  { "nwnode", cm_node, NO_BRACE_ARGS },
  { "o", cm_special_char, BRACE_ARGS },
  { "oddfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "oddheading", cm_ignore_line, NO_BRACE_ARGS },
  { "oe", cm_special_char, BRACE_ARGS },
  { "option", cm_code, BRACE_ARGS },
  { "ordf", cm_special_char, BRACE_ARGS },
  { "ordm", cm_special_char, BRACE_ARGS },
  { "page", cm_no_op, NO_BRACE_ARGS },
  { "pagesizes", cm_ignore_line, NO_BRACE_ARGS },
  { "paragraphindent", cm_paragraphindent, NO_BRACE_ARGS },
  { "pindex", cm_pindex, NO_BRACE_ARGS },
  { "point", cm_point, BRACE_ARGS },
  { "pounds", cm_special_char, BRACE_ARGS },
  { "print", cm_print, BRACE_ARGS },
  { "printindex", cm_printindex, NO_BRACE_ARGS },
  { "pxref", cm_pxref, BRACE_ARGS },
  { "questiondown", cm_special_char, BRACE_ARGS },
  { "quotation", cm_quotation, NO_BRACE_ARGS },
  { "r", cm_r, BRACE_ARGS },
  { "raisesections", cm_raisesections, NO_BRACE_ARGS },
  { "ref", cm_ref, BRACE_ARGS },
  { "refill", cm_no_op, NO_BRACE_ARGS },
  { "registeredsymbol", cm_registeredsymbol, BRACE_ARGS },
  { "result", cm_result, BRACE_ARGS },
  { "ringaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "rmacro", cm_rmacro, NO_BRACE_ARGS },
  { "samp", cm_code, BRACE_ARGS },
  { "sansserif", cm_sansserif, BRACE_ARGS },
  { "sc", cm_sc, BRACE_ARGS },
  { "section", cm_section, NO_BRACE_ARGS },
  { "set", cm_set, NO_BRACE_ARGS },
  { "setchapternewpage", cm_ignore_line, NO_BRACE_ARGS },
  { "setchapterstyle", cm_obsolete, NO_BRACE_ARGS },
  { "setcontentsaftertitlepage", cm_no_op, NO_BRACE_ARGS },
  { "setfilename", cm_setfilename, NO_BRACE_ARGS },
  { "setshortcontentsaftertitlepage", cm_no_op, NO_BRACE_ARGS },
  { "settitle", cm_settitle, NO_BRACE_ARGS },
  { "shortcaption", cm_caption, BRACE_ARGS },
  { "shortcontents", cm_contents, NO_BRACE_ARGS },
  { "shorttitlepage", cm_ignore_line, NO_BRACE_ARGS },
  { "slanted", cm_slanted, BRACE_ARGS },
  { "smallbook", cm_ignore_line, NO_BRACE_ARGS },
  { "smalldisplay", cm_smalldisplay, NO_BRACE_ARGS },
  { "smallexample", cm_smallexample, NO_BRACE_ARGS },
  { "smallformat", cm_smallformat, NO_BRACE_ARGS },
  { "smalllisp", cm_smalllisp, NO_BRACE_ARGS },
  { "sp", cm_sp, NO_BRACE_ARGS },
  { "ss", cm_special_char, BRACE_ARGS },
  { "strong", cm_strong, BRACE_ARGS },
  { "subheading", cm_subheading, NO_BRACE_ARGS },
  { "subsection", cm_subsection, NO_BRACE_ARGS },
  { "subsubheading", cm_subsubheading, NO_BRACE_ARGS },
  { "subsubsection", cm_subsubsection, NO_BRACE_ARGS },
  { "subtitle", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "summarycontents", cm_contents, NO_BRACE_ARGS },
  { "syncodeindex", cm_synindex, NO_BRACE_ARGS },
  { "synindex", cm_synindex, NO_BRACE_ARGS },
  { "t", cm_tt, BRACE_ARGS },
  { "tab", cm_tab, NO_BRACE_ARGS },
  { "table", cm_table, NO_BRACE_ARGS },
  { "tex", cm_tex, NO_BRACE_ARGS },
  { "tie", cm_tie, BRACE_ARGS },
  { "tieaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "tindex", cm_tindex, NO_BRACE_ARGS },
  { "title", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "titlefont", cm_titlefont, BRACE_ARGS },
  { "titlepage", cm_titlepage, NO_BRACE_ARGS },
  { "today", cm_today, BRACE_ARGS },
  { "top", cm_top, NO_BRACE_ARGS  },
  { "u", cm_accent, MAYBE_BRACE_ARGS },
  { "ubaraccent", cm_accent, MAYBE_BRACE_ARGS },
  { "udotaccent", cm_accent, MAYBE_BRACE_ARGS },
  { "unmacro", cm_unmacro, NO_BRACE_ARGS },
  { "unnumbered", cm_unnumbered, NO_BRACE_ARGS },
  { "unnumberedsec", cm_unnumberedsec, NO_BRACE_ARGS },
  { "unnumberedsubsec", cm_unnumberedsubsec, NO_BRACE_ARGS },
  { "unnumberedsubsubsec", cm_unnumberedsubsubsec, NO_BRACE_ARGS },
  { "uref", cm_uref, BRACE_ARGS },
  { "url", cm_uref, BRACE_ARGS },
  { "v", cm_accent, MAYBE_BRACE_ARGS },
  { "value", cm_value, BRACE_ARGS },
  { "var", cm_var, BRACE_ARGS },
  { "verb", cm_verb, NO_BRACE_ARGS },
  { "verbatim", cm_verbatim, NO_BRACE_ARGS },
  { "verbatiminclude", cm_verbatiminclude, NO_BRACE_ARGS },
  { "vindex", cm_vindex, NO_BRACE_ARGS },
  { "vtable", cm_vtable, NO_BRACE_ARGS },
  { "vskip", cm_ignore_line, NO_BRACE_ARGS },
  { "w", cm_w, BRACE_ARGS },
  { "xml", cm_xml, NO_BRACE_ARGS },
  { "xref", cm_xref, BRACE_ARGS },

  /* Deprecated commands.  These used to be for italics.  */
  { "iappendix", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "ichapter", cm_ideprecated, NO_BRACE_ARGS },
  { "isection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumbered", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsubsec", cm_ideprecated, NO_BRACE_ARGS },

  /* Now @@include does what this was used to. */
  { "infoinclude", cm_obsolete, NO_BRACE_ARGS },
  { "titlespec", cm_obsolete, NO_BRACE_ARGS },

  { NULL, NULL, NO_BRACE_ARGS }
};

/* The bulk of the Texinfo commands. */

/* Commands which insert their own names. */
void
insert_self (int arg)
{
  if (arg == START)
    add_word (command);
}

void
insert_space (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
        xml_insert_entity ("space");
      else
        add_char (' ');
    }
}

/* Insert a comma.  Useful when a literal , would break our parsing of
   multiple arguments.  */
void
cm_comma (int arg)
{
  if (arg == START)
    add_char (',');
}


/* Force a line break in the output. */
void
cm_asterisk (void)
{
  if (html)
    add_word ("<br>");
  else if (xml && !docbook)
    xml_insert_entity ("linebreak");
  else if (docbook) 
    xml_asterisk ();
  else
    {
      close_single_paragraph ();
      cm_noindent ();
    }
}

/* Insert ellipsis. */
void
cm_dots (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
        xml_insert_entity ("dots");
      else if (docbook)
        xml_insert_entity ("hellip");
      else
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"dots\">...</small>");
	else
	  add_word ("...");
    }
}

/* Insert ellipsis for sentence end. */
void
cm_enddots (int arg)
{
  if (arg == START)
    {
      if (xml && !docbook)
	xml_insert_entity ("enddots");
      else if (docbook)
	{
	  xml_insert_entity ("hellip");
	  add_char ('.');
	}
      else
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"enddots\">....</small>");
	else
	  add_word ("....");
    }
}

void
cm_bullet (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&bull;");
      else if (xml && !docbook)
	xml_insert_entity ("bullet");
      else if (docbook)
	xml_insert_entity ("bull");
      else
        add_char ('*');
    }
}

void
cm_minus (int arg)
{
  if (arg == START)
    {
      if (xml)
	xml_insert_entity ("minus");
      else if (html)
        add_word ("&minus;");
      else
	add_char ('-');
    }
}

/* Formatting a dimension unit.  */
void
cm_dmn (int arg)
{
  if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"dmn\"");
  else if (docbook)
    /* No units in docbook yet.  */
    ;
  else if (xml)
    xml_insert_element (DIMENSION, arg);
}

/* Insert "TeX". */
void
cm_TeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
	xml_insert_entity ("tex");
      else
	add_word ("TeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Insert "LaTeX".  */
void
cm_LaTeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
        xml_insert_entity ("latex");
      else
        add_word ("LaTeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Copyright symbol.  */
void
cm_copyright (int arg)
{
  if (arg == START)
    {
    if (html)
      add_word ("&copy;");
    else if (xml && !docbook)
      xml_insert_entity ("copyright");
    else if (docbook)
      xml_insert_entity ("copy");
    else
      add_word ("(C)");
    }
}

/* Registered symbol.  */
void
cm_registeredsymbol (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&reg;");
      else if (docbook)
        xml_insert_entity ("reg");
      else if (xml && !docbook)
        xml_insert_entity ("registered");
      else
        add_word ("(R)");
    }
}

void
cm_today (int arg)
{
  static char *months[12] =
    { N_("January"), N_("February"), N_("March"), N_("April"), N_("May"),
      N_("June"), N_("July"), N_("August"), N_("September"), N_("October"),
      N_("November"), N_("December") };
  if (arg == START)
    {
      time_t timer = time (0);
      struct tm *ts = localtime (&timer);
      add_word_args ("%d %s %d", ts->tm_mday, _(months[ts->tm_mon]),
                     ts->tm_year + 1900);
    }
}

void
cm_comment (void)
{
  /* For HTML, do not output comments before HTML header is written,
     otherwise comments before @@settitle cause an empty <title> in the
     header.  */
  if ((html && html_output_head_p) || xml)
    {
      char *line;
      get_rest_of_line (0, &line);

      if (strlen (line) > 0)
        {
          int save_inhibit_indentation = inhibit_paragraph_indentation;
          int save_paragraph_is_open = paragraph_is_open;
          int save_escape_html = escape_html;
          int save_xml_no_para = xml_no_para;
          int i;

          inhibit_paragraph_indentation = 1;
          escape_html = 0;
          xml_no_para = 1;

          /* @@c and @@comment can appear between @@item and @@itemx,
             @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;

          /* Use insert for HTML, and XML when indentation is enabled.
             For Docbook, use add_char.  */
          if (xml && xml_indentation_increment > 0
              && output_paragraph[output_paragraph_offset-1] != '\n')
            insert ('\n');

          /* Crunch double hyphens in comments.  */
          add_html_block_elt ("<!-- ");
          for (i = 0; i < strlen (line); i++)
            if (line[i] != '-' || (i && line[i-1] != '-'))
              add_char (line[i]);
          add_word (" -->");

          if (html)
            add_char ('\n');

          inhibit_paragraph_indentation = save_inhibit_indentation;
          paragraph_is_open = save_paragraph_is_open;
          escape_html = save_escape_html;
          xml_no_para = save_xml_no_para;
          xml_dont_touch_items_defs--;
        }

      free (line);
    }
  else
    cm_ignore_line ();
}



/* We keep acronyms with two arguments around, to be able to refer to them
   later with only one argument.  */
static ACRONYM_DESC *acronyms_stack = NULL;

static void
cm_acronym_or_abbr (int arg, int is_abbr)
{
  char *aa, *description;
  unsigned len;

  /* We do everything at START.  */
  if (arg == END)
    return;

  get_until_in_braces (",", &aa);
  if (input_text[input_text_offset] == ',')
    input_text_offset++;
  get_until_in_braces ("}", &description);

  canon_white (aa);
  canon_white (description);

  /* If not enclosed in braces, strip after comma to be compatible
     with texinfo.tex.  */
  if (description[0] != '{' && strchr (description, ',') != NULL)
    {
      int i = 0;
      while (description[i] != ',')
        i++;
      /* For now, just terminate the string at comma.  */
      description[i] = 0;
    }

  /* Get description out of braces.  */
  if (description[0] == '{')
    description++;

  len = strlen (description);
  if (len && description[len-1] == '}')
    description[len-1] = 0;

  /* Save new description.  */
  if (strlen (description) > 0)
    {
      ACRONYM_DESC *new = xmalloc (sizeof (ACRONYM_DESC));

      new->acronym = xstrdup (aa);
      new->description = xstrdup (description);
      new->next = acronyms_stack;
      acronyms_stack = new;
    }

  if (html)
    {
      add_word (is_abbr ? "<abbr" : "<acronym");

      if (strlen (description) > 0)
        add_word_args (" title=\"%s\"", text_expansion (description));
      else if (acronyms_stack)
        {
          /* No second argument, get from previous.  Search order is from
             last to first defined, so we get the most recent version of
             the description.  */
          ACRONYM_DESC *temp = acronyms_stack;

          while (temp)
            {
              if (STREQ (aa, temp->acronym)
                  && strlen (temp->description) > 0)
                {
                  add_word_args (" title=\"%s\"",
                                 text_expansion (temp->description));
                  break;
                }
              temp = temp->next;
            }
        }

      add_char ('>');
      execute_string ("%s", aa);
      add_word (is_abbr ? "</abbr>" : "</acronym>");
    }
  else if (docbook)
    {
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
    }
  else if (xml)
    {
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);

      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, END);

      if (strlen (description) > 0)
        {
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, START);
          execute_string ("%s", description);
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, END);
        }

      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
    }
  else
    execute_string ("%s", aa);

  /* Put description into parenthesis after the acronym for all outputs
     except XML.  */
  if (strlen (description) > 0 && (!xml || docbook))
    add_word_args (" (%s)", description);
}

void
cm_acronym (int arg)
{
  cm_acronym_or_abbr (arg, 0);
}

void
cm_abbr (int arg)
{
  cm_acronym_or_abbr (arg, 1);
}

void
cm_tt (int arg)
{
  /* @@t{} is a no-op in Info.  */
  if (html)
    insert_html_tag (arg, "tt");
  else if (xml)
    xml_insert_element (TT, arg);
}

void
cm_code (int arg)
{
  if (arg == START)
    in_fixed_width_font++;

  if (xml)
    {
      if (STREQ (command, "command"))
	xml_insert_element (COMMAND_TAG, arg);
      else if (STREQ (command, "env"))
	xml_insert_element (ENV, arg);
      else if (STREQ (command, "file"))
	xml_insert_element (FILE_TAG, arg);
      else if (STREQ (command, "option"))
	xml_insert_element (OPTION, arg);
      else if (STREQ (command, "samp"))
        {
          if (docbook && arg == START)
            {
              /* Even though @@samp is in_fixed_width_font, it
                 should always start a paragraph.  Unfortunately,
                 in_fixed_width_font inhibits that.  */
              xml_start_para ();
              xml_insert_entity ("lsquo");
            }
          xml_insert_element (SAMP, arg);
          if (docbook && arg == END)
            xml_insert_entity ("rsquo");
        }
      else
	xml_insert_element (CODE, arg);
    }
  else if (html)
    {
      if (STREQ (command, "code"))
        insert_html_tag (arg, "code");
      else
        { /* Use <samp> tag in general to get typewriter.  */
          if (arg == START)
            { /* If @@samp specifically, add quotes a la TeX output.  */
              if (STREQ (command, "samp")) add_char ('`');
              add_word ("<samp>");
            }
          insert_html_tag_with_attribute (arg, "span", "class=\"%s\"",command);
          if (arg == END)
            {
              add_word ("</samp>");
              if (STREQ (command, "samp")) add_char ('\'');
            }
        }
    }
  else
    {
      extern int printing_index;

      if (!printing_index)
        {
          if (arg == START)
            add_char ('`');
          else
            add_meta_char ('\'');
        }
    }
}

void
cm_kbd (int arg)
{
  if (xml)
    xml_insert_element (KBD, arg);
  else if (html)
    { /* Seems like we should increment in_fixed_width_font for Info
         format too, but then the quote-omitting special case gets
         confused.  Punt.  */
      if (arg == START)
        in_fixed_width_font++;
      insert_html_tag (arg, "kbd");
    }
  else
    { /* People use @@kbd in an example to get the "user input" font.
         We don't want quotes in that case.  */
      if (!in_fixed_width_font)
        cm_code (arg);
    }
}

/* Just show a url (http://example.org/..., for example), don't link to it.  */
void
cm_indicate_url (int arg, int start, int end)
{
  if (xml)
    xml_insert_element (URL, arg);
  else if (html)
    {
      if (arg == START)
        add_word ("&lt;");
      insert_html_tag (arg, "code");
      if (arg != START)
        add_word ("&gt;");
    }
  else
    if (arg == START)
      add_word ("<");
    else
      add_word (">");
}

void
cm_key (int arg)
{
  if (xml)
    xml_insert_element (KEY, arg);
  else if (html)
    add_word (arg == START ? "&lt;" : "&gt;");
  else
    add_char (arg == START ? '<' : '>');
}

/* Handle a command that switches to a non-fixed-width font.  */
void
not_fixed_width (int arg)
{
  if (arg == START)
    in_fixed_width_font = 0;
}

/* @@var in makeinfo just uppercases the text. */
void
cm_var (int arg, int start_pos, int end_pos)
{
  if (xml)
    xml_insert_element (VAR, arg);
  else
    {
  not_fixed_width (arg);

  if (html)
    insert_html_tag (arg, "var");
  else if (arg == END)
    {
      while (start_pos < end_pos)
        {
          unsigned char c = output_paragraph[start_pos];
          if (strchr ("[](),", c))
            warning (_("unlikely character %c in @@var"), c);
          output_paragraph[start_pos] = coerce_to_upper (c);
          start_pos++;
        }
    }
    }
}

void
cm_sc (int arg, int start_pos, int end_pos)
{
  if (xml)
    xml_insert_element (SC, arg);
  else
    {
      not_fixed_width (arg);

      if (arg == START)
        {
          if (html)
            insert_html_tag_with_attribute (arg, "span", "class=\"sc\"");
        }
      else
        {
          int all_upper;

          if (html)
            start_pos += sizeof ("<span class=\"sc\">") - 1; /* skip <span> */

          /* Avoid the warning below if there's no text inside @@sc{}, or
             when processing menus under --no-headers.  */
          all_upper = start_pos < end_pos;

          while (start_pos < end_pos)
            {
              unsigned char c = output_paragraph[start_pos];
              if (!isupper (c))
                all_upper = 0;
              if (!html)
                output_paragraph[start_pos] = coerce_to_upper (c);
              start_pos++;
            }
          if (all_upper)
            warning (_("@@sc argument all uppercase, thus no effect"));

          if (html)
            insert_html_tag (arg, "span");
        }
    }
}

void
cm_dfn (int arg, int position)
{
  if (xml)
    xml_insert_element (DFN, arg);
  else
    {
  if (html)
    insert_html_tag (arg, "dfn");
  else if (arg == START)
    add_char ('"');
  else
    add_meta_char ('"');
    }
}

void
cm_emph (int arg)
{
  if (xml)
    xml_insert_element (EMPH, arg);
  else if (html)
    insert_html_tag (arg, "em");
  else
    add_char ('_');
}

void
cm_verb (int arg)
{
  int character;
  int delimiter = 0; /* avoid warning */
  int seen_end = 0;

  in_fixed_width_font++;
  /* are these necessary ? */
  last_char_was_newline = 0;

  if (html)
    add_word ("<tt>");

  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '{')
	input_text_offset++;
      else
	line_error (_("`{' expected, but saw `%c'"), character);
    }
    
  if (input_text_offset < input_text_length)
    {
      delimiter = curchar ();
      input_text_offset++;
    }

  while (input_text_offset < input_text_length)
    {
      character = curchar ();

      if (character == '\n')
        {
          line_number++;
          if (html)
            add_word ("<br>\n");
        }

      else if (html && character == '<')
        add_word ("&lt;");

      else if (html && character == '&')
        add_word ("&amp;");

      else if (character == delimiter && input_text[input_text_offset+1] == '}')
	{ /* Assume no newlines in END_VERBATIM. */
	  seen_end = 1;
	  input_text_offset++;
	  break;
	}

      else
        add_char (character);

      input_text_offset++;
    }

  if (!seen_end)
    warning (_("end of file inside verb block"));
  
  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '}')
	input_text_offset++;
      else
	line_error (_("`}' expected, but saw `%c'"), character);
    }

  if (html)
    add_word ("</tt>");

  in_fixed_width_font--;
}


void
cm_strong (int arg, int start_pos, int end_pos)
{
  if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
    xml_insert_element (STRONG, arg);
  else if (html)
    insert_html_tag (arg, "strong");
  else
    add_char ('*');
  
  if (!xml && !html && !docbook && !no_headers
      && arg == END
      && end_pos - start_pos >= 6
      && (STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note:", 6)
          || STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note ", 6)))
    {
      /* Translators: "Note:" is literal here and should not be
         translated.  @@strong{Nota}, say, does not cause the problem.  */
      warning (_("@@strong{Note...} produces a spurious cross-reference in Info; reword to avoid that"));
      /* Adjust the output to avoid writing the bad xref.  */
      output_paragraph[start_pos + 5] = '_';
    }
}

void
cm_cite (int arg, int position)
{
  if (xml)
    xml_insert_element (CITE, arg);        
  else if (html)
    insert_html_tag (arg, "cite");
  else
    {
      if (arg == START)
        add_char ('`');
      else
        add_char ('\'');
    }
}

/* No highlighting, but argument switches fonts.  */
void
cm_not_fixed_width (int arg, int start, int end)
{
  if (xml)
    xml_insert_element (NOTFIXEDWIDTH, arg);
  not_fixed_width (arg);
}

void
cm_i (int arg)
{
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (I, arg);
  else if (html)
    insert_html_tag (arg, "i");
  else
    not_fixed_width (arg);
}

void
cm_slanted (int arg)
{
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SLANTED, arg);
  else if (html)
    insert_html_tag (arg, "i");
  else
    not_fixed_width (arg);
}

void
cm_b (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
    xml_insert_element (B, arg);
  else if (html)
    insert_html_tag (arg, "b");
  else
    not_fixed_width (arg);
}

void
cm_r (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (R, arg);
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"roman\"");
  else
    not_fixed_width (arg);
}

void
cm_sansserif (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SANSSERIF, arg);
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"sansserif\"");
  else
    not_fixed_width (arg);
}

void
cm_titlefont (int arg)
{
  if (xml)
    xml_insert_element (TITLEFONT, arg);
  else
   {
     not_fixed_width (arg);
     if (html)
	{
	  html_title_written = 1; /* suppress title from @@settitle */
	  if (arg == START)
	    add_word ("<h1 class=\"titlefont\">");
	  else
	    add_word ("</h1>\n");
	}
   }
}


/* Unfortunately, we cannot interpret @@math{} contents like TeX does.  We just
   pass them through.  */
void
cm_math (int arg)
{
  if (xml && !docbook)
    xml_insert_element (MATH, arg);
}

/* Various commands are no-op's. */
void
cm_no_op (void)
{
}


/* For proofing single chapters, etc.  */
void
cm_novalidate (void)
{
  validating = 0;
}


/* Prevent the argument from being split across two lines. */
void
cm_w (int arg)
{
  if (arg == START)
    non_splitting_words++;
  else
    {
      if (docbook || html || xml)
        /* This is so @@w{$}Log$ doesn't end up as <dollar>Log<dollar>
           in the output.  */
        insert_string ("<!-- /@@w -->");
        
      non_splitting_words--;
    }
}


/* An unbreakable word space.  Same as @@w{ } for makeinfo, but different
   for TeX (the space stretches and stretches, and does not inhibit
   hyphenation).  */
void
cm_tie (int arg)
{
  if (arg == START)
    {
      cm_w (START);
      add_char (' ');
    }
  else
    cm_w (END);
}

/* Explain that this command is obsolete, thus the user shouldn't
   do anything with it. */
static void
cm_obsolete (int arg, int start, int end)
{
  if (arg == START)
    warning (_("%c%s is obsolete"), COMMAND_PREFIX, command);
}


/* Inhibit the indentation of the next paragraph, but not of following
   paragraphs.  */
void
cm_noindent (void)
{
  if (!inhibit_paragraph_indentation)
    inhibit_paragraph_indentation = -1;
}

void
cm_noindent_cmd (void)
{
  cm_noindent ();
  xml_no_indent = 1;
  skip_whitespace_and_newlines();

  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"noindent\">");
  else
    {
      paragraph_is_open = 0;
      start_paragraph ();
    }
}

/* Force indentation of the next paragraph. */
void
cm_indent (void)
{
  inhibit_paragraph_indentation = 0;
  xml_no_indent = 0;
  skip_whitespace_and_newlines();
  
  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"indent\">");
  else
    start_paragraph ();
}

/* I don't know exactly what to do with this.  Should I allow
   someone to switch filenames in the middle of output?  Since the
   file could be partially written, this doesn't seem to make sense.
   Another option: ignore it, since they don't really want to
   switch files.  Finally, complain, or at least warn.  It doesn't
   really matter, anyway, since this doesn't get executed.  */
void
cm_setfilename (void)
{
  char *filename;
  get_rest_of_line (1, &filename);
  /* warning ("`@@%s %s' encountered and ignored", command, filename); */
  if (xml)
    add_word_args ("<setfilename>%s</setfilename>", filename);
  free (filename);
}

void
cm_settitle (void)
{
  if (xml)
    {
      xml_begin_document (current_output_filename);
      xml_insert_element (SETTITLE, START);
      xml_in_book_title = 1;
      get_rest_of_line (0, &title);
      execute_string ("%s", title);
      xml_in_book_title = 0;
      xml_insert_element (SETTITLE, END);
    }
  else
    get_rest_of_line (0, &title);
}


/* Ignore argument in braces.  */
void
cm_ignore_arg (int arg, int start_pos, int end_pos)
{
  if (arg == END)
    output_paragraph_offset = start_pos;
}

/* Ignore argument on rest of line.  */
void
cm_ignore_line (void)
{
  discard_until ("\n");
}

/* Insert the number of blank lines passed as argument. */
void
cm_sp (void)
{
  int lines;
  char *line;

  /* Due to tricky stuff in execute_string(), @@value{} can't be expanded.
     So there is really no reason to enable expansion for @@sp parameters.  */
  get_rest_of_line (0, &line);

  if (sscanf (line, "%d", &lines) != 1 || lines <= 0)
    line_error (_("@@sp requires a positive numeric argument, not `%s'"), line);
  else
    {
      if (xml)
	{
          /* @@sp can appear between @@item and @@itemx, @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;
	  xml_insert_element_with_attribute (SP, START, "lines=\"%s\"", line);
	  /*	  insert_string (line);*/
	  xml_insert_element (SP, END);
          xml_dont_touch_items_defs--;
	}
      else
        {
          /* Must disable filling since otherwise multiple newlines is like
             multiple spaces.  Must close paragraph since that's what the
             manual says and that's what TeX does.  */
          int save_filling_enabled = filling_enabled;
          filling_enabled = 0;

          /* close_paragraph generates an extra blank line.  */
          close_single_paragraph ();

          if (lines && html && !executing_string)
            html_output_head ();

          if (html)
            add_html_block_elt ("<pre class=\"sp\">\n");

          while (lines--)
            add_char ('\n');

          if (html)
            add_html_block_elt ("</pre>\n");

          filling_enabled = save_filling_enabled;
        }
    }
  free (line);
}

/* @@dircategory LINE outputs INFO-DIR-SECTION LINE, unless --no-headers.  */ 
void
cm_dircategory (void)
{
  char *line;

  if (html || docbook)
    cm_ignore_line ();
  else if (xml)
    {
      xml_insert_element (DIRCATEGORY, START);
      get_rest_of_line (1, &line);
      insert_string (line);
      free (line);
      xml_insert_element (DIRCATEGORY, END);
    }
  else
    {
      get_rest_of_line (1, &line);

      if (!no_headers && !html)
        {
          kill_self_indent (-1); /* make sure there's no indentation */
          insert_string ("INFO-DIR-SECTION ");
          insert_string (line);
          insert ('\n');
        }

      free (line);
    }
}

/* Start a new line with just this text on it.
   Then center the line of text.
   */
void
cm_center (void)
{
  if (xml)
    {
      char *line;
      xml_insert_element (CENTER, START);
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
      free (line);
      xml_insert_element (CENTER, END);
    }
  else
    {
      int i, start, length;
      char *line;
      int save_indented_fill = indented_fill;
      int save_filling_enabled = filling_enabled;
      int fudge_factor = 1;

      filling_enabled = indented_fill = 0;
      cm_noindent ();
      start = output_paragraph_offset;

      if (html)
        add_html_block_elt ("<div align=\"center\">");

      inhibit_output_flushing ();
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
      free (line);
      uninhibit_output_flushing ();
      if (html)
        add_html_block_elt ("</div>");

       else
         {
           i = output_paragraph_offset - 1;
           while (i > (start - 1) && output_paragraph[i] == '\n')
             i--;

           output_paragraph_offset = ++i;
           length = output_paragraph_offset - start;

           if (length < (fill_column - fudge_factor))
             {
               line = xmalloc (1 + length);
               memcpy (line, (char *)(output_paragraph + start), length);

               i = (fill_column - fudge_factor - length) / 2;
               output_paragraph_offset = start;

               while (i--)
                 insert (' ');

               for (i = 0; i < length; i++)
                 insert (line[i]);

               free (line);
             }
         }

      insert ('\n');
      filling_enabled = save_filling_enabled;
      indented_fill = save_indented_fill;
      close_single_paragraph ();
      if (looking_at("\n"))
        insert ('\n');
    }
}

/* Show what an expression returns. */
void
cm_result (int arg)
{
  if (arg == END)
    add_word (html ? "=&gt;" : "=>");
}

/* What an expression expands to. */
void
cm_expansion (int arg)
{
  if (arg == END)
    add_word (html ? "==&gt;" : "==>");
}

/* Indicates two expressions are equivalent. */
void
cm_equiv (int arg)
{
  if (arg == END)
    add_word ("==");
}

/* What an expression may print. */
void
cm_print (int arg)
{
  if (arg == END)
    add_word ("-|");
}

/* An error signaled. */
void
cm_error (int arg)
{
  if (arg == END)
    add_word (html ? "error--&gt;" : "error-->");
}

/* The location of point in an example of a buffer. */
void
cm_point (int arg)
{
  if (arg == END)
    add_word ("-!-");
}

/* @@exdent: Start a new line with just this text on it.
   The text is outdented one level if possible. */
void
cm_exdent (void)
{
  char *line;
  int save_indent = current_indent;
  int save_in_fixed_width_font = in_fixed_width_font;

  /* Read argument.  */
  get_rest_of_line (0, &line);

  /* Exdent the output.  Actually this may be a no-op.   */
  if (current_indent)
    current_indent -= default_indentation_increment;

  /* @@exdent arg is supposed to be in roman.  */
  in_fixed_width_font = 0;
  
  /* The preceding newline already inserted the `current_indent'.
     Remove one level's worth.  */
  kill_self_indent (default_indentation_increment);

  if (html)
    add_word ("<br>");
  else if (docbook)
    xml_insert_element (LINEANNOTATION, START);
  else if (xml)
    xml_insert_element (EXDENT, START);

  /* Can't close_single_paragraph, then we lose preceding blank lines.  */
  flush_output ();
  execute_string ("%s", line);
  free (line);

  if (html)
    add_word ("<br>");
  else if (xml)
    {
      xml_insert_element (docbook ? LINEANNOTATION : EXDENT, END);
      insert ('\n');
    }

  close_single_paragraph ();

  current_indent = save_indent;
  in_fixed_width_font = save_in_fixed_width_font;
  if (!xml)
    start_paragraph ();
}

/* 
  Read include-filename, process the include-file:
    verbatim_include == 0: process through reader_loop
    verbatim_include != 0: process through handle_verbatim_environment
 */
static void
handle_include (int verbatim_include)
{
  char *arg, *filename;

  if (macro_expansion_output_stream && !executing_string)
    me_append_before_this_command ();

  if (!insertion_stack)
    close_paragraph ();  /* No blank lines etc. if not at outer level.  */
    
  get_rest_of_line (0, &arg);
  /* We really only want to expand @@value, but it's easier to just do
     everything.  TeX will only work with @@value.  */
  filename = text_expansion (arg);
  free (arg);

  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);

  pushfile ();

  /* In verbose mode we print info about including another file. */
  if (verbose_mode)
    {
      int i = 0;
      FSTACK *stack = filestack;

      for (i = 0, stack = filestack; stack; stack = stack->next, i++);

      i *= 2;

      printf ("%*s", i, "");
      printf ("%c%s `%s'\n", COMMAND_PREFIX, command, filename);
      fflush (stdout);
    }

  if (!find_and_load (filename, 1))
    {
      popfile ();
      line_number--;

      /* /wh/bar:5: @@include/@@verbatiminclude `foo': No such file or dir */
      line_error ("%c%s `%s': %s", COMMAND_PREFIX, command, filename,
                  strerror (errno));

      free (filename);
      return;
    }
  else
    {
      if (macro_expansion_output_stream && !executing_string)
	remember_itext (input_text, input_text_offset);

      if (!verbatim_include)
	reader_loop ();
      else
	handle_verbatim_environment (0);
    }
  free (filename);
  popfile ();
}


/* Include file as if put in @@verbatim environment */
void
cm_verbatiminclude (void)
{
  handle_include (1); 
}


/* Remember this file, and move onto the next. */
void
cm_include (void)
{
  handle_include (0); 
}


/* @@bye: Signals end of processing.  Easy to make this happen. */

void
cm_bye (void)
{
  discard_braces (); /* should not have any unclosed braces left */
  input_text_offset = input_text_length;
}

/* @@paragraphindent */

static void
cm_paragraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_paragraph_indent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}


/* @@exampleindent: change indentation of example-like environments.   */
static int
set_example_indentation_increment (char *string)
{
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    ;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    example_indentation_increment = 0;
  else if (sscanf (string, "%d", &example_indentation_increment) != 1)
    return -1;
  return 0;
}

static void
cm_exampleindent (void)
{
  char *arg;
  
  get_rest_of_line (1, &arg);
  if (set_example_indentation_increment (arg) != 0)
    line_error (_("Bad argument to @@%s"), command);

  if (input_text[input_text_offset] == '\n')
    close_single_paragraph ();

  free (arg);
}


/* @@firstparagraphindent: suppress indentation in first paragraphs after
   headings. */
static int
set_firstparagraphindent (char *string)
{
  if (STREQ (string, "insert") || STREQ (string, _("insert")))
    do_first_par_indent = 1;
  else if (STREQ (string, "none") || STREQ (string, _("none")))
    do_first_par_indent = 0;
  else
    return -1;
  return 0;
}

static void
cm_firstparagraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_firstparagraphindent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}

/* For DocBook and XML, produce &period; for `.@@:'. This gives the processing
   software a fighting chance to treat it specially by not adding extra space.
  
   Do this also for ?, !, and :.  */
void
cm_colon (void)
{
  if (xml)
    {
      if (strchr (".?!:", input_text[input_text_offset-3]) != NULL)
        {
          /* Erase literal character that's there, except `>', which is
             part of the XML tag.  */
          if (output_paragraph[output_paragraph_offset-1] != '>')
            output_paragraph_offset--;

          switch (input_text[input_text_offset-3])
            {
            case '.':
              xml_insert_entity ("period");
              break;
            case '?':
              xml_insert_entity ("quest");
              break;
            case '!':
              xml_insert_entity ("excl");
              break;
            case ':':
              xml_insert_entity ("colon");
              break;
            }
        }
    }
}

/* Ending sentences explicitly.  Currently, only outputs entities for XML
   output, for other formats it calls insert_self.  */
void
cm_punct (int arg)
{
  if (xml && !docbook)
    {
      switch (input_text[input_text_offset-1])
        {
        case '.':
          xml_insert_entity ("eosperiod");
          break;
        case '?':
          xml_insert_entity ("eosquest");
          break;
        case '!':
          xml_insert_entity ("eosexcl");
          break;
        }
    }
  else
    {
      insert_self (arg);
    }
}
@


1.2
log
@Allow @@value in @@include.  Backported from texinfo 3.8.
ok deraadt@@, krw@@
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.1.1.2 2002/06/10 13:21:15 espie Exp $
d4 2
a5 1
   Copyright (C) 1998, 99, 2000, 01, 02 Free Software Foundation, Inc.
d26 1
a41 34

void insert_self (), insert_space (), cm_ignore_line (), cm_ignore_arg ();

void
  cm_TeX (), cm_acronym (), cm_asterisk (), cm_b (), cm_bullet (), cm_cite (),
  cm_code (), cm_copyright (), cm_ctrl (), cm_dfn (), cm_dircategory (),
  cm_direntry (), cm_dmn (), cm_dots (), cm_emph (), cm_enddots (), cm_i (),
  cm_image (), cm_kbd (), cm_key (), cm_no_op (), 
  cm_novalidate (), cm_not_fixed_width (), cm_r (),
  cm_strong (), cm_var (), cm_sc (), cm_w (), cm_email (), cm_url (),
  cm_verb (), cm_copying (), cm_insert_copying (),
  cm_documentdescription ();

void
  cm_anchor (), cm_node (), cm_menu (), cm_xref (), cm_ftable (),
  cm_vtable (), cm_pxref (), cm_inforef (), cm_uref (), cm_email (),
  cm_quotation (), cm_display (), cm_smalldisplay (), cm_itemize (),
  cm_enumerate (), cm_tab (), cm_table (), cm_itemx (), cm_noindent (),
  cm_setfilename (), cm_br (), cm_sp (), cm_page (), cm_group (),
  cm_center (), cm_ref (), cm_include (), cm_bye (), cm_item (), cm_end (),
  cm_kindex (), cm_cindex (), cm_findex (), cm_pindex (), cm_vindex (),
  cm_tindex (), cm_synindex (), cm_printindex (), cm_minus (),
  cm_example (), cm_smallexample (), cm_smalllisp (), cm_lisp (),
  cm_format (), cm_smallformat (), cm_exdent (), cm_defindex (),
  cm_defcodeindex (), cm_result (), cm_expansion (), cm_equiv (),
  cm_print (), cm_error (), cm_point (), cm_today (), cm_flushleft (),
  cm_flushright (), cm_finalout (), cm_cartouche (), cm_detailmenu (),
  cm_multitable (), cm_settitle (), cm_titlefont (), cm_tt (),
  cm_verbatim (), cm_verbatiminclude ();

/* Conditionals. */
void cm_set (), cm_clear (), cm_ifset (), cm_ifclear ();
void cm_value (), cm_ifeq ();

d43 4
a46 1
static void cm_paragraphindent (), cm_exampleindent ();
d49 2
a50 4
static void cm_obsolete ();

/* A random string.  */
static const char small_tag[] = "small";
d57 1
a57 1
  { "!", insert_self, NO_BRACE_ARGS },
d63 3
a65 2
  { ".", insert_self, NO_BRACE_ARGS },
  { ":", cm_no_op, NO_BRACE_ARGS },
d67 1
a67 1
  { "?", insert_self, NO_BRACE_ARGS },
d80 1
d85 1
d100 1
d104 2
a105 1
  { "c", cm_ignore_line, NO_BRACE_ARGS },
d115 1
d117 1
a117 1
  { "comment", cm_ignore_line, NO_BRACE_ARGS },
d143 2
d170 2
a171 1
  { "dmn", cm_no_op, BRACE_ARGS },
d186 1
d199 2
d210 1
d216 1
d219 1
d224 1
d228 1
d232 2
d245 1
d249 1
a249 1
  { "math", cm_no_op, BRACE_ARGS },
d255 2
a256 2
  { "noindent", cm_noindent, NO_BRACE_ARGS },
  { "noindent", cm_novalidate, NO_BRACE_ARGS },
d263 2
d280 1
d285 1
d295 2
a296 1
  { "shortcontents", cm_shortcontents, NO_BRACE_ARGS },
d298 1
d311 2
a312 1
  { "summarycontents", cm_shortcontents, NO_BRACE_ARGS },
d319 1
d322 1
d324 1
a324 1
  { "titlepage", command_name_condition, NO_BRACE_ARGS },
d336 1
a336 1
  { "url", cm_url, BRACE_ARGS },
d345 1
d347 1
d376 1
a376 2
insert_self (arg)
    int arg;
d383 1
a383 2
insert_space (arg)
    int arg;
d388 1
a388 1
	xml_insert_entity ("space");
d390 1
a390 1
	add_char (' ');
d394 10
d406 1
a406 1
cm_asterisk ()
d423 1
a423 2
cm_dots (arg)
     int arg;
d428 1
a428 1
	xml_insert_entity ("dots");
d430 1
a430 1
	xml_insert_entity ("hellip");
d432 4
a435 1
	add_word (html ? "<small>...</small>" : "...");
d441 1
a441 2
cm_enddots (arg)
     int arg;
d453 4
a456 1
	add_word (html ? "<small>...</small>." : "....");
d461 1
a461 2
cm_bullet (arg)
     int arg;
d466 1
a466 1
        add_word ("&#149;");
d477 1
a477 2
cm_minus (arg)
     int arg;
d483 2
d490 13
d505 1
a505 2
cm_TeX (arg)
     int arg;
d507 2
d511 1
a511 1
      if (xml && ! docbook)
d515 29
d549 1
a549 2
cm_copyright (arg)
    int arg;
d564 17
d582 1
a582 2
cm_today (arg)
     int arg;
d598 1
a598 2
cm_acronym (arg)
     int arg;
d600 107
d708 35
a742 1
    insert_html_tag (arg, small_tag);
d744 29
a772 1
    xml_insert_element (ACRONYM, arg);
d776 7
a782 2
cm_tt (arg)
     int arg;
d792 1
a792 2
cm_code (arg)
     int arg;
d794 3
a797 2
    xml_insert_element (CODE, arg);
  else
d799 26
a824 3
  extern int printing_index;

  if (arg == START)
d826 1
a826 3
      in_fixed_width_font++;

      if (html)
d828 14
a841 2
      else if (!printing_index)
        add_char ('`');
a842 2
  else if (html)
    insert_html_tag (arg, "code");
d845 2
d848 6
a853 2
        add_meta_char ('\'');
    }
d858 1
a858 2
cm_kbd (arg)
     int arg;
d878 1
d880 1
a880 1
cm_url (arg, start, end)
d887 4
a890 3
        add_word ("&lt;<code>");
      else
	add_word ("</code>&gt;");
d900 1
a900 2
cm_key (arg)
     int arg;
d912 1
a912 2
not_fixed_width (arg)
     int arg;
d920 1
a920 2
cm_var (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d945 1
a945 2
cm_sc (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d951 1
a951 1
  not_fixed_width (arg);
d953 8
a960 8
  if (arg == START)
    {
      if (html)
	insert_html_tag (arg, small_tag);
    }
  else
    {
      int all_upper;
d962 2
a963 2
      if (html)
        start_pos += sizeof (small_tag) + 2 - 1; /* skip <small> */
d965 15
a979 3
      /* Avoid the warning below if there's no text inside @@sc{}, or
         when processing menus under --no-headers.  */
      all_upper = start_pos < end_pos;
d981 2
a982 7
      while (start_pos < end_pos)
        {
          unsigned char c = output_paragraph[start_pos];
          if (!isupper (c))
            all_upper = 0;
          output_paragraph[start_pos] = coerce_to_upper (c);
          start_pos++;
a983 6
      if (all_upper)
        warning (_("@@sc argument all uppercase, thus no effect"));
        
      if (html)
	insert_html_tag (arg, small_tag);
    }
d988 1
a988 2
cm_dfn (arg, position)
     int arg, position;
d1004 1
a1004 2
cm_emph (arg)
     int arg;
d1015 1
a1015 2
cm_verb (arg)
     int arg;
d1018 1
a1018 1
  int delimiter;
d1026 1
a1026 1
    add_word ("<pre>");
d1048 14
a1061 6
        line_number++;
      /*
	Assume no newlines in END_VERBATIM
      */
      else if (character == delimiter)
	{
d1067 3
a1069 1
      add_char (character);
d1086 3
a1088 1
    add_word ("</pre>");
d1091 1
d1093 1
a1093 2
cm_strong (arg, position)
     int arg, position;
d1095 3
a1097 1
  if (xml)
d1103 13
d1119 1
a1119 2
cm_cite (arg, position)
     int arg, position;
d1136 1
a1136 2
cm_not_fixed_width (arg, start, end)
     int arg, start, end;
d1144 1
a1144 2
cm_i (arg)
     int arg;
d1146 6
a1151 1
  if (xml)
d1160 17
a1176 2
cm_b (arg)
     int arg;
d1178 7
a1184 1
  if (xml)
d1193 1
a1193 2
cm_r (arg)
     int arg;
d1195 5
a1199 1
  if (xml)
d1201 2
d1204 2
a1205 2
    {
      extern int printing_index;
d1207 13
a1219 19
      /* People use @@r{} in index entries like this:
	 
      @@findex foo@@r{, some text}
      
      This is supposed to produce output as if the entry were saying
      "@@code{foo}, some text", since the "fn" index is typeset as
      @@code.  The following attempts to do the same in HTML.  Note that
      this relies on the fact that only @@code bumps up the variable
      in_fixed_width_font while processing index entries in HTML mode.  */
      if (html && printing_index)
	{
	  int level = in_fixed_width_font;
	  
	  while (level--)
	    insert_html_tag (arg == START ? END : START, "code");
	}
      
      not_fixed_width (arg);
    }
d1223 1
a1223 2
cm_titlefont (arg)
     int arg;
d1228 21
a1248 1
  not_fixed_width (arg);
d1253 1
a1253 1
cm_no_op ()
d1260 1
a1260 1
cm_novalidate ()
d1268 1
a1268 2
cm_w (arg, start, end)
     int arg, start, end;
d1273 8
a1280 1
    non_splitting_words--;
d1284 15
d1302 1
a1302 2
cm_obsolete (arg, start, end)
     int arg, start, end;
d1309 2
a1310 2
/* This says to inhibit the indentation of the next paragraph, but
   not of following paragraphs.  */
d1312 1
a1312 1
cm_noindent ()
d1318 34
d1355 1
a1355 1
   Another option: ignore it, since they don't *really* want to
d1359 1
a1359 1
cm_setfilename ()
d1370 1
a1370 1
cm_settitle ()
d1376 1
d1379 1
d1389 1
a1389 2
cm_ignore_arg (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d1397 1
a1397 1
cm_ignore_line ()
d1404 1
a1404 1
cm_sp ()
d1409 3
a1411 1
  get_rest_of_line (1, &line);
d1419 2
d1424 1
d1427 15
a1441 9
	{
	  /* Must disable filling since otherwise multiple newlines is like
         multiple spaces.  Must close paragraph since that's what the
         manual says and that's what TeX does.  */
      int save_filling_enabled = filling_enabled;
      filling_enabled = 0;
      
      /* close_paragraph generates an extra blank line.  */
      close_single_paragraph ();
d1443 2
a1444 2
      if (lines && html && !executing_string)
	html_output_head ();
d1446 2
a1447 7
      while (lines--)
	{
	  if (html)
	    insert_string ("<br><p>\n");
	  else
	    add_char ('\n');
	}
d1449 2
a1450 2
      filling_enabled = save_filling_enabled;
    }
d1457 1
a1457 1
cm_dircategory ()
d1491 1
a1491 1
cm_center ()
d1495 1
a1495 1
      unsigned char *line;
d1497 2
a1498 2
      get_rest_of_line (0, (char **)&line);
      execute_string ("%s", (char *)line);
d1504 26
a1529 5
  int i, start, length;
  unsigned char *line;
  int save_indented_fill = indented_fill;
  int save_filling_enabled = filling_enabled;
  int fudge_factor = 1;
d1531 16
a1546 3
  filling_enabled = indented_fill = 0;
  cm_noindent ();
  start = output_paragraph_offset;
d1548 3
a1550 2
  if (html)
    add_word ("<div align=\"center\">");
d1552 6
a1557 38
  inhibit_output_flushing ();
  get_rest_of_line (0, (char **)&line);
  execute_string ("%s", (char *)line);
  free (line);
  uninhibit_output_flushing ();
   if (html)
    add_word ("</div>");

   else
     {
       i = output_paragraph_offset - 1;
       while (i > (start - 1) && output_paragraph[i] == '\n')
	 i--;

       output_paragraph_offset = ++i;
       length = output_paragraph_offset - start;

       if (length < (fill_column - fudge_factor))
	 {
	   line = xmalloc (1 + length);
	   memcpy (line, (char *)(output_paragraph + start), length);

	   i = (fill_column - fudge_factor - length) / 2;
	   output_paragraph_offset = start;

	   while (i--)
	     insert (' ');

	   for (i = 0; i < length; i++)
	     insert (line[i]);

	   free (line);
	 }
     }

  insert ('\n');
  filling_enabled = save_filling_enabled;
  indented_fill = save_indented_fill;
d1563 1
a1563 2
cm_result (arg)
     int arg;
d1571 1
a1571 2
cm_expansion (arg)
     int arg;
d1579 1
a1579 2
cm_equiv (arg)
     int arg;
d1587 1
a1587 2
cm_print (arg)
     int arg;
d1595 1
a1595 2
cm_error (arg)
     int arg;
d1603 1
a1603 2
cm_point (arg)
     int arg;
d1612 1
a1612 1
cm_exdent ()
d1618 1
a1618 1
  /* Read argument  */
d1634 4
d1646 6
d1656 2
d1666 1
a1666 2
handle_include (verbatim_include)
  int verbatim_include;
d1673 3
a1675 1
  close_paragraph ();
d1702 1
a1702 1
  if (!find_and_load (filename))
a1703 2
      extern int errno;

d1731 1
a1731 1
cm_verbatiminclude ()
d1739 1
a1739 1
cm_include ()
d1748 1
a1748 1
cm_bye ()
a1750 1
  flush_output ();
d1757 1
a1757 1
cm_paragraphindent ()
d1768 1
d1771 1
a1771 2
set_default_indentation_increment (string)
     char *string;
d1776 2
a1777 2
    default_indentation_increment = 0;
  else if (sscanf (string, "%d", &default_indentation_increment) != 1)
d1783 1
a1783 1
cm_exampleindent ()
d1788 31
a1818 1
  if (set_default_indentation_increment (arg) != 0)
d1822 61
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.57 1999/09/19 16:39:35 karl Exp $
d4 1
a4 1
   Copyright (C) 1998, 99 Free Software Foundation, Inc.
d32 1
d49 3
a51 1
  cm_strong (), cm_var (), cm_sc (), cm_w (), cm_email (), cm_url ();
d67 2
a68 1
  cm_multitable (), cm_settitle (), cm_titlefont (), cm_tt ();
d87 1
a87 1
  { " ", insert_self, NO_BRACE_ARGS },
d99 1
d116 2
d119 1
d144 1
d194 1
d208 4
d238 1
d240 1
d247 1
d270 2
d316 1
a316 1
  { "summarycontents", cm_no_op, NO_BRACE_ARGS },
d342 3
d388 6
a393 1
    add_char (' ');
d402 4
d419 8
a426 1
    add_word (html ? "<small>...</small>" : "...");
d435 11
a445 1
    add_word (html ? "<small>...</small>." : "....");
d456 4
d470 6
a475 1
    add_char ('-');
d484 6
a489 1
    add_word ("TeX");
d498 1
d501 4
d507 1
d533 2
d544 2
d552 4
d574 1
d581 3
a583 1
  if (html)
d602 3
a604 1
  if (html)
d622 3
a624 1
  if (html)
d644 4
d663 1
d670 4
d683 1
a683 1
      int all_upper = 1;
d688 4
d706 1
d713 4
d723 1
d730 3
a732 1
  if (html)
d739 66
d808 3
a810 1
  if (html)
d820 3
a822 1
  if (html)
d838 2
d847 3
a849 1
  if (html)
d859 3
a861 1
  if (html)
d871 3
a873 12
  extern int printing_index;

  /* People use @@r{} in index entries like this:

     @@findex foo@@r{, some text}

     This is supposed to produce output as if the entry were saying
     "@@code{foo}, some text", since the "fn" index is typeset as
     @@code.  The following attempts to do the same in HTML.  Note that
     this relies on the fact that only @@code bumps up the variable
     in_fixed_width_font while processing index entries in HTML mode.  */
  if (html && printing_index)
d875 1
a875 1
      int level = in_fixed_width_font;
d877 18
a894 2
      while (level--)
	insert_html_tag (arg == START ? END : START, "code");
a895 2
	
  not_fixed_width (arg);
d902 3
d967 2
d975 10
a984 1
  get_rest_of_line (0, &title);
d987 1
d1016 10
a1025 1
    { /* Must disable filling since otherwise multiple newlines is like
d1031 5
a1035 1
      close_paragraph ();
d1047 1
d1057 1
a1057 1
  if (html)
d1059 8
d1085 1
a1085 1
   This always ends the current paragraph. */
d1089 11
a1105 1
  close_paragraph ();
d1111 1
a1111 1
    add_word ("<p align=\"center\">");
d1119 1
a1119 1
    add_word ("</p>");
a1148 1
  close_paragraph ();
d1151 1
d1247 8
a1254 4

/* Remember this file, and move onto the next. */
void
cm_include ()
d1256 1
a1256 1
  char *filename;
d1262 5
a1266 1
  get_rest_of_line (0, &filename);
d1284 1
a1284 1
      printf ("%c%s %s\n", COMMAND_PREFIX, command, filename);
d1295 2
a1296 2
      /* Cannot "@@include foo", in line 5 of "/wh/bar". */
      line_error ("%c%s %s: %s", COMMAND_PREFIX, command, filename,
d1305 6
a1310 2
        remember_itext (input_text, input_text_offset);
      reader_loop ();
d1314 16
@


1.1.1.1
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@@


1.1.1.2
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.79 2002/03/28 16:35:29 karl Exp $
d4 1
a4 1
   Copyright (C) 1998, 99, 2000, 01, 02 Free Software Foundation, Inc.
a31 1
#include "xml.h"
d48 1
a48 3
  cm_strong (), cm_var (), cm_sc (), cm_w (), cm_email (), cm_url (),
  cm_verb (), cm_copying (), cm_insert_copying (),
  cm_documentdescription ();
d64 1
a64 2
  cm_multitable (), cm_settitle (), cm_titlefont (), cm_tt (),
  cm_verbatim (), cm_verbatiminclude ();
d83 1
a83 1
  { " ", insert_space, NO_BRACE_ARGS },
a94 1
  { "\\", insert_self, NO_BRACE_ARGS },
a110 2
  { "afivepaper", cm_ignore_line, NO_BRACE_ARGS },
  { "afourlatex", cm_ignore_line, NO_BRACE_ARGS },
a111 1
  { "afourwide", cm_ignore_line, NO_BRACE_ARGS },
a135 1
  { "copying", cm_copying, NO_BRACE_ARGS },
a184 1
  { "documentdescription", cm_documentdescription, NO_BRACE_ARGS },
a197 4
  { "evenfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "evenheading", cm_ignore_line, NO_BRACE_ARGS },
  { "everyfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "everyheading", cm_ignore_line, NO_BRACE_ARGS },
a223 1
  { "ifnotplaintext", cm_ifnotplaintext, NO_BRACE_ARGS },
a224 1
  { "ifplaintext", cm_ifplaintext, NO_BRACE_ARGS },
a230 1
  { "insertcopying", cm_insert_copying, NO_BRACE_ARGS },
a252 2
  { "oddfooting", cm_ignore_line, NO_BRACE_ARGS },
  { "oddheading", cm_ignore_line, NO_BRACE_ARGS },
d297 1
a297 1
  { "summarycontents", cm_shortcontents, NO_BRACE_ARGS },
a322 3
  { "verb", cm_verb, NO_BRACE_ARGS },
  { "verbatim", cm_verbatim, NO_BRACE_ARGS },
  { "verbatiminclude", cm_verbatiminclude, NO_BRACE_ARGS },
d366 1
a366 6
    {
      if (xml && !docbook)
	xml_insert_entity ("space");
      else
	add_char (' ');
    }
a374 4
  else if (xml && !docbook)
    xml_insert_entity ("linebreak");
  else if (docbook) 
    xml_asterisk ();
d388 1
a388 8
    {
      if (xml && !docbook)
	xml_insert_entity ("dots");
      else if (docbook)
	xml_insert_entity ("hellip");
      else
	add_word (html ? "<small>...</small>" : "...");
    }
d397 1
a397 11
    {
      if (xml && !docbook)
	xml_insert_entity ("enddots");
      else if (docbook)
	{
	  xml_insert_entity ("hellip");
	  add_char ('.');
	}
      else
	add_word (html ? "<small>...</small>." : "....");
    }
a407 4
      else if (xml && !docbook)
	xml_insert_entity ("bullet");
      else if (docbook)
	xml_insert_entity ("bull");
d418 1
a418 6
    {
      if (xml)
	xml_insert_entity ("minus");
      else
	add_char ('-');
    }
d427 1
a427 6
    {
      if (xml && ! docbook)
	xml_insert_entity ("tex");
      else
	add_word ("TeX");
    }
a435 1
    {
a437 4
    else if (xml && !docbook)
      xml_insert_entity ("copyright");
    else if (docbook)
      xml_insert_entity ("copy");
a439 1
    }
a464 2
  else if (xml)
    xml_insert_element (ACRONYM, arg);
a473 2
  else if (xml)
    xml_insert_element (TT, arg);
a479 4
  if (xml)
    xml_insert_element (CODE, arg);
  else
    {
a497 1
    }
d504 1
a504 3
  if (xml)
    xml_insert_element (KBD, arg);
  else if (html)
d523 1
a523 3
  if (xml)
    xml_insert_element (URL, arg);
  else if (html)
d541 1
a541 3
  if (xml)
    xml_insert_element (KEY, arg);
  else if (html)
a560 4
  if (xml)
    xml_insert_element (VAR, arg);
  else
    {
a575 1
    }
a581 4
  if (xml)
    xml_insert_element (SC, arg);
  else
    {
d591 1
a591 1
      int all_upper;
a595 4
      /* Avoid the warning below if there's no text inside @@sc{}, or
         when processing menus under --no-headers.  */
      all_upper = start_pos < end_pos;

a609 1
    }
a615 4
  if (xml)
    xml_insert_element (DFN, arg);
  else
    {
a621 1
    }
d628 1
a628 3
  if (xml)
    xml_insert_element (EMPH, arg);
  else if (html)
a634 66
cm_verb (arg)
     int arg;
{
  int character;
  int delimiter;
  int seen_end = 0;

  in_fixed_width_font++;
  /* are these necessary ? */
  last_char_was_newline = 0;

  if (html)
    add_word ("<pre>");

  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '{')
	input_text_offset++;
      else
	line_error (_("`{' expected, but saw `%c'"), character);
    }
    
  if (input_text_offset < input_text_length)
    {
      delimiter = curchar ();
      input_text_offset++;
    }

  while (input_text_offset < input_text_length)
    {
      character = curchar ();

      if (character == '\n')
        line_number++;
      /*
	Assume no newlines in END_VERBATIM
      */
      else if (character == delimiter)
	{
	  seen_end = 1;
	  input_text_offset++;
	  break;
	}

      add_char (character);
      input_text_offset++;
    }

  if (!seen_end)
    warning (_("end of file inside verb block"));
  
  if (input_text_offset < input_text_length)
    {
      character = curchar ();
      if (character == '}')
	input_text_offset++;
      else
	line_error (_("`}' expected, but saw `%c'"), character);
    }

  if (html)
    add_word ("</pre>");
}

void
d638 1
a638 3
  if (xml)
    xml_insert_element (STRONG, arg);
  else if (html)
d648 1
a648 3
  if (xml)
    xml_insert_element (CITE, arg);        
  else if (html)
a663 2
  if (xml)
    xml_insert_element (NOTFIXEDWIDTH, arg);
d671 1
a671 3
  if (xml)
    xml_insert_element (I, arg);
  else if (html)
d681 1
a681 3
  if (xml)
    xml_insert_element (B, arg);
  else if (html)
d691 12
a702 3
  if (xml)
    xml_insert_element (R, arg);
  else
d704 1
a704 1
      extern int printing_index;
d706 2
a707 18
      /* People use @@r{} in index entries like this:
	 
      @@findex foo@@r{, some text}
      
      This is supposed to produce output as if the entry were saying
      "@@code{foo}, some text", since the "fn" index is typeset as
      @@code.  The following attempts to do the same in HTML.  Note that
      this relies on the fact that only @@code bumps up the variable
      in_fixed_width_font while processing index entries in HTML mode.  */
      if (html && printing_index)
	{
	  int level = in_fixed_width_font;
	  
	  while (level--)
	    insert_html_tag (arg == START ? END : START, "code");
	}
      
      not_fixed_width (arg);
d709 2
a716 3
  if (xml)
    xml_insert_element (TITLEFONT, arg);
  else
a778 2
  if (xml)
    add_word_args ("<setfilename>%s</setfilename>", filename);
d785 1
a785 10
  if (xml)
    {
      xml_begin_document (current_output_filename);
      xml_insert_element (SETTITLE, START);
      get_rest_of_line (0, &title);
      execute_string ("%s", title);
      xml_insert_element (SETTITLE, END);
    }
  else
    get_rest_of_line (0, &title);
a787 1

d816 1
a816 10
    {
      if (xml)
	{
	  xml_insert_element_with_attribute (SP, START, "lines=\"%s\"", line);
	  /*	  insert_string (line);*/
	  xml_insert_element (SP, END);
	}
      else
	{
	  /* Must disable filling since otherwise multiple newlines is like
d822 1
a822 5
      /* close_paragraph generates an extra blank line.  */
      close_single_paragraph ();

      if (lines && html && !executing_string)
	html_output_head ();
a833 1
    }
d843 1
a843 1
  if (html || docbook)
a844 8
  else if (xml)
    {
      xml_insert_element (DIRCATEGORY, START);
      get_rest_of_line (1, &line);
      insert_string (line);
      free (line);
      xml_insert_element (DIRCATEGORY, END);
    }
d863 1
a863 1
   */
a866 11
  if (xml)
    {
      unsigned char *line;
      xml_insert_element (CENTER, START);
      get_rest_of_line (0, (char **)&line);
      execute_string ("%s", (char *)line);
      free (line);
      xml_insert_element (CENTER, END);
    }
  else
    {
d873 1
d879 1
a879 1
    add_word ("<div align=\"center\">");
d887 1
a887 1
    add_word ("</div>");
d917 1
a919 1
    }
d1015 4
a1018 8
/* 
  Read include-filename, process the include-file:
    verbatim_include == 0: process through reader_loop
    verbatim_include != 0: process through handle_verbatim_environment
 */
static void
handle_include (verbatim_include)
  int verbatim_include;
d1044 1
a1044 1
      printf ("%c%s `%s'\n", COMMAND_PREFIX, command, filename);
d1055 2
a1056 2
      /* /wh/bar:5: @@include/@@verbatiminclude `foo': No such file or dir */
      line_error ("%c%s `%s': %s", COMMAND_PREFIX, command, filename,
d1065 2
a1066 6
	remember_itext (input_text, input_text_offset);

      if (!verbatim_include)
	reader_loop ();
      else
	handle_verbatim_environment (0);
a1069 16
}


/* Include file as if put in @@verbatim environment */
void
cm_verbatiminclude ()
{
  handle_include (1); 
}


/* Remember this file, and move onto the next. */
void
cm_include ()
{
  handle_include (0); 
@


1.1.1.3
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: cmds.c,v 1.55 2004/12/14 00:15:36 karl Exp $
d4 1
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a24 1
#include "html.h"
d40 34
d75 1
a75 4
static void cm_exampleindent (void),
     cm_firstparagraphindent (void),
     cm_paragraphindent (void),
     cm_novalidate (void);
d78 4
a81 2
static void cm_obsolete (int arg, int start, int end),
     not_fixed_width (int arg);
d88 1
a88 1
  { "!", cm_punct, NO_BRACE_ARGS },
d94 2
a95 3
  { ".", cm_punct, NO_BRACE_ARGS },
  { "/", cm_no_op, NO_BRACE_ARGS },
  { ":", cm_colon, NO_BRACE_ARGS },
d97 1
a97 1
  { "?", cm_punct, NO_BRACE_ARGS },
a109 1
  { "LaTeX", cm_LaTeX, BRACE_ARGS },
a113 1
  { "abbr", cm_abbr, BRACE_ARGS },
a127 1
  { "author", cm_author, NO_BRACE_ARGS },
d131 1
a131 2
  { "c", cm_comment, NO_BRACE_ARGS },
  { "caption", cm_caption, BRACE_ARGS },
a140 1
  { "comma", cm_comma, BRACE_ARGS },
d142 1
a142 1
  { "comment", cm_comment, NO_BRACE_ARGS },
a167 2
  { "deftypecv", cm_defun, NO_BRACE_ARGS },
  { "deftypecvx", cm_defun, NO_BRACE_ARGS },
d193 1
a193 2
  { "dmn", cm_dmn, BRACE_ARGS },
  { "docbook", cm_docbook, NO_BRACE_ARGS },
a207 1
  { "euro", cm_special_char, BRACE_ARGS },
a219 2
  { "firstparagraphindent", cm_firstparagraphindent, NO_BRACE_ARGS },
  { "float", cm_float, NO_BRACE_ARGS },
a228 1
  { "headitem", cm_headitem, NO_BRACE_ARGS },
a233 1
  { "ifdocbook", cm_ifdocbook, NO_BRACE_ARGS },
a235 1
  { "ifnotdocbook", cm_ifnotdocbook, NO_BRACE_ARGS },
a239 1
  { "ifnotxml", cm_ifnotxml, NO_BRACE_ARGS },
a242 1
  { "ifxml", cm_ifxml, NO_BRACE_ARGS },
a245 2
  { "indent", cm_indent, NO_BRACE_ARGS },
  { "indicateurl", cm_indicate_url, BRACE_ARGS },
a256 1
  { "listoffloats", cm_listoffloats, NO_BRACE_ARGS },
d260 1
a260 1
  { "math", cm_math, BRACE_ARGS },
d266 2
a267 2
  { "noindent", cm_noindent_cmd, NO_BRACE_ARGS },
  { "novalidate", cm_novalidate, NO_BRACE_ARGS },
a273 2
  { "ordf", cm_special_char, BRACE_ARGS },
  { "ordm", cm_special_char, BRACE_ARGS },
a288 1
  { "registeredsymbol", cm_registeredsymbol, BRACE_ARGS },
a292 1
  { "sansserif", cm_sansserif, BRACE_ARGS },
d302 1
a302 2
  { "shortcaption", cm_caption, BRACE_ARGS },
  { "shortcontents", cm_contents, NO_BRACE_ARGS },
a303 1
  { "slanted", cm_slanted, BRACE_ARGS },
d316 1
a316 2
  { "subtitle", cm_titlepage_cmds, NO_BRACE_ARGS },
  { "summarycontents", cm_contents, NO_BRACE_ARGS },
a322 1
  { "tie", cm_tie, BRACE_ARGS },
a324 1
  { "title", cm_titlepage_cmds, NO_BRACE_ARGS },
d326 1
a326 1
  { "titlepage", cm_titlepage, NO_BRACE_ARGS },
d338 1
a338 1
  { "url", cm_uref, BRACE_ARGS },
a346 1
  { "vskip", cm_ignore_line, NO_BRACE_ARGS },
a347 1
  { "xml", cm_xml, NO_BRACE_ARGS },
d376 2
a377 1
insert_self (int arg)
d384 2
a385 1
insert_space (int arg)
d390 1
a390 1
        xml_insert_entity ("space");
d392 1
a392 1
        add_char (' ');
a395 10
/* Insert a comma.  Useful when a literal , would break our parsing of
   multiple arguments.  */
void
cm_comma (int arg)
{
  if (arg == START)
    add_char (',');
}


d398 1
a398 1
cm_asterisk (void)
d415 2
a416 1
cm_dots (int arg)
d421 1
a421 1
        xml_insert_entity ("dots");
d423 1
a423 1
        xml_insert_entity ("hellip");
d425 1
a425 4
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"dots\">...</small>");
	else
	  add_word ("...");
d431 2
a432 1
cm_enddots (int arg)
d444 1
a444 4
	if (html && !in_fixed_width_font)
	  insert_string ("<small class=\"enddots\">....</small>");
	else
	  add_word ("....");
d449 2
a450 1
cm_bullet (int arg)
d455 1
a455 1
        add_word ("&bull;");
d466 2
a467 1
cm_minus (int arg)
a472 2
      else if (html)
        add_word ("&minus;");
a477 13
/* Formatting a dimension unit.  */
void
cm_dmn (int arg)
{
  if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"dmn\"");
  else if (docbook)
    /* No units in docbook yet.  */
    ;
  else if (xml)
    xml_insert_element (DIMENSION, arg);
}

d480 2
a481 1
cm_TeX (int arg)
a482 2
  static int last_position;

d485 1
a485 1
      if (xml)
a488 29

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
    }
}

/* Insert "LaTeX".  */
void
cm_LaTeX (int arg)
{
  static int last_position;

  if (arg == START)
    {
      if (xml)
        xml_insert_entity ("latex");
      else
        add_word ("LaTeX");

      last_position = output_paragraph_offset;
    }
  else if (last_position != output_paragraph_offset)
    {
      warning (_("arguments to @@%s ignored"), command);
      output_paragraph_offset = last_position;
d494 2
a495 1
cm_copyright (int arg)
a509 1
/* Registered symbol.  */
d511 2
a512 17
cm_registeredsymbol (int arg)
{
  if (arg == START)
    {
      if (html)
        add_word ("&reg;");
      else if (docbook)
        xml_insert_entity ("reg");
      else if (xml && !docbook)
        xml_insert_entity ("registered");
      else
        add_word ("(R)");
    }
}

void
cm_today (int arg)
d528 2
a529 1
cm_comment (void)
a530 107
  /* For HTML, do not output comments before HTML header is written,
     otherwise comments before @@settitle cause an empty <title> in the
     header.  */
  if ((html && html_output_head_p) || xml)
    {
      char *line;
      get_rest_of_line (0, &line);

      if (strlen (line) > 0)
        {
          int save_inhibit_indentation = inhibit_paragraph_indentation;
          int save_paragraph_is_open = paragraph_is_open;
          int save_escape_html = escape_html;
          int save_xml_no_para = xml_no_para;
          int i;

          inhibit_paragraph_indentation = 1;
          escape_html = 0;
          xml_no_para = 1;

          /* @@c and @@comment can appear between @@item and @@itemx,
             @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;

          /* Use insert for HTML, and XML when indentation is enabled.
             For Docbook, use add_char.  */
          if (xml && xml_indentation_increment > 0
              && output_paragraph[output_paragraph_offset-1] != '\n')
            insert ('\n');

          /* Crunch double hyphens in comments.  */
          add_html_block_elt ("<!-- ");
          for (i = 0; i < strlen (line); i++)
            if (line[i] != '-' || (i && line[i-1] != '-'))
              add_char (line[i]);
          add_word (" -->");

          if (html)
            add_char ('\n');

          inhibit_paragraph_indentation = save_inhibit_indentation;
          paragraph_is_open = save_paragraph_is_open;
          escape_html = save_escape_html;
          xml_no_para = save_xml_no_para;
          xml_dont_touch_items_defs--;
        }

      free (line);
    }
  else
    cm_ignore_line ();
}



/* We keep acronyms with two arguments around, to be able to refer to them
   later with only one argument.  */
static ACRONYM_DESC *acronyms_stack = NULL;

static void
cm_acronym_or_abbr (int arg, int is_abbr)
{
  char *aa, *description;
  unsigned len;

  /* We do everything at START.  */
  if (arg == END)
    return;

  get_until_in_braces (",", &aa);
  if (input_text[input_text_offset] == ',')
    input_text_offset++;
  get_until_in_braces ("}", &description);

  canon_white (aa);
  canon_white (description);

  /* If not enclosed in braces, strip after comma to be compatible
     with texinfo.tex.  */
  if (description[0] != '{' && strchr (description, ',') != NULL)
    {
      int i = 0;
      while (description[i] != ',')
        i++;
      /* For now, just terminate the string at comma.  */
      description[i] = 0;
    }

  /* Get description out of braces.  */
  if (description[0] == '{')
    description++;

  len = strlen (description);
  if (len && description[len-1] == '}')
    description[len-1] = 0;

  /* Save new description.  */
  if (strlen (description) > 0)
    {
      ACRONYM_DESC *new = xmalloc (sizeof (ACRONYM_DESC));

      new->acronym = xstrdup (aa);
      new->description = xstrdup (description);
      new->next = acronyms_stack;
      acronyms_stack = new;
    }

d532 1
a532 35
    {
      add_word (is_abbr ? "<abbr" : "<acronym");

      if (strlen (description) > 0)
        add_word_args (" title=\"%s\"", text_expansion (description));
      else if (acronyms_stack)
        {
          /* No second argument, get from previous.  Search order is from
             last to first defined, so we get the most recent version of
             the description.  */
          ACRONYM_DESC *temp = acronyms_stack;

          while (temp)
            {
              if (STREQ (aa, temp->acronym)
                  && strlen (temp->description) > 0)
                {
                  add_word_args (" title=\"%s\"",
                                 text_expansion (temp->description));
                  break;
                }
              temp = temp->next;
            }
        }

      add_char ('>');
      execute_string ("%s", aa);
      add_word (is_abbr ? "</abbr>" : "</acronym>");
    }
  else if (docbook)
    {
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
    }
d534 1
a534 35
    {
      xml_insert_element (is_abbr ? ABBREV : ACRONYM, START);

      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, START);
      execute_string ("%s", aa);
      xml_insert_element (is_abbr ? ABBREVWORD : ACRONYMWORD, END);

      if (strlen (description) > 0)
        {
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, START);
          execute_string ("%s", description);
          xml_insert_element (is_abbr ? ABBREVDESC : ACRONYMDESC, END);
        }

      xml_insert_element (is_abbr ? ABBREV : ACRONYM, END);
    }
  else
    execute_string ("%s", aa);

  /* Put description into parenthesis after the acronym for all outputs
     except XML.  */
  if (strlen (description) > 0 && (!xml || docbook))
    add_word_args (" (%s)", description);
}

void
cm_acronym (int arg)
{
  cm_acronym_or_abbr (arg, 0);
}

void
cm_abbr (int arg)
{
  cm_acronym_or_abbr (arg, 1);
d538 2
a539 1
cm_tt (int arg)
d549 2
a550 1
cm_code (int arg)
a551 3
  if (arg == START)
    in_fixed_width_font++;

d553 2
d556 3
a558 26
      if (STREQ (command, "command"))
	xml_insert_element (COMMAND_TAG, arg);
      else if (STREQ (command, "env"))
	xml_insert_element (ENV, arg);
      else if (STREQ (command, "file"))
	xml_insert_element (FILE_TAG, arg);
      else if (STREQ (command, "option"))
	xml_insert_element (OPTION, arg);
      else if (STREQ (command, "samp"))
        {
          if (docbook && arg == START)
            {
              /* Even though @@samp is in_fixed_width_font, it
                 should always start a paragraph.  Unfortunately,
                 in_fixed_width_font inhibits that.  */
              xml_start_para ();
              xml_insert_entity ("lsquo");
            }
          xml_insert_element (SAMP, arg);
          if (docbook && arg == END)
            xml_insert_entity ("rsquo");
        }
      else
	xml_insert_element (CODE, arg);
    }
  else if (html)
d560 3
a562 1
      if (STREQ (command, "code"))
d564 2
a565 14
      else
        { /* Use <samp> tag in general to get typewriter.  */
          if (arg == START)
            { /* If @@samp specifically, add quotes a la TeX output.  */
              if (STREQ (command, "samp")) add_char ('`');
              add_word ("<samp>");
            }
          insert_html_tag_with_attribute (arg, "span", "class=\"%s\"",command);
          if (arg == END)
            {
              add_word ("</samp>");
              if (STREQ (command, "samp")) add_char ('\'');
            }
        }
d567 2
a570 2
      extern int printing_index;

d572 2
a573 6
        {
          if (arg == START)
            add_char ('`');
          else
            add_meta_char ('\'');
        }
d578 2
a579 1
cm_kbd (int arg)
a598 1
/* Just show a url (http://example.org/..., for example), don't link to it.  */
d600 1
a600 1
cm_indicate_url (int arg, int start, int end)
d607 3
a609 4
        add_word ("&lt;");
      insert_html_tag (arg, "code");
      if (arg != START)
        add_word ("&gt;");
d619 2
a620 1
cm_key (int arg)
d632 2
a633 1
not_fixed_width (int arg)
d641 2
a642 1
cm_var (int arg, int start_pos, int end_pos)
d667 2
a668 1
cm_sc (int arg, int start_pos, int end_pos)
d674 1
a674 1
      not_fixed_width (arg);
d676 8
a683 8
      if (arg == START)
        {
          if (html)
            insert_html_tag_with_attribute (arg, "span", "class=\"sc\"");
        }
      else
        {
          int all_upper;
d685 2
a686 2
          if (html)
            start_pos += sizeof ("<span class=\"sc\">") - 1; /* skip <span> */
d688 3
a690 15
          /* Avoid the warning below if there's no text inside @@sc{}, or
             when processing menus under --no-headers.  */
          all_upper = start_pos < end_pos;

          while (start_pos < end_pos)
            {
              unsigned char c = output_paragraph[start_pos];
              if (!isupper (c))
                all_upper = 0;
              if (!html)
                output_paragraph[start_pos] = coerce_to_upper (c);
              start_pos++;
            }
          if (all_upper)
            warning (_("@@sc argument all uppercase, thus no effect"));
d692 7
a698 2
          if (html)
            insert_html_tag (arg, "span");
d700 6
d710 2
a711 1
cm_dfn (int arg, int position)
d727 2
a728 1
cm_emph (int arg)
d739 2
a740 1
cm_verb (int arg)
d743 1
a743 1
  int delimiter = 0; /* avoid warning */
d751 1
a751 1
    add_word ("<tt>");
d773 6
a778 14
        {
          line_number++;
          if (html)
            add_word ("<br>\n");
        }

      else if (html && character == '<')
        add_word ("&lt;");

      else if (html && character == '&')
        add_word ("&amp;");

      else if (character == delimiter && input_text[input_text_offset+1] == '}')
	{ /* Assume no newlines in END_VERBATIM. */
d784 1
a784 3
      else
        add_char (character);

d801 1
a801 3
    add_word ("</tt>");

  in_fixed_width_font--;
a803 1

d805 2
a806 1
cm_strong (int arg, int start_pos, int end_pos)
d808 1
a808 3
  if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
a813 13
  
  if (!xml && !html && !docbook && !no_headers
      && arg == END
      && end_pos - start_pos >= 6
      && (STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note:", 6)
          || STRNCASEEQ ((char *) output_paragraph + start_pos, "*Note ", 6)))
    {
      /* Translators: "Note:" is literal here and should not be
         translated.  @@strong{Nota}, say, does not cause the problem.  */
      warning (_("@@strong{Note...} produces a spurious cross-reference in Info; reword to avoid that"));
      /* Adjust the output to avoid writing the bad xref.  */
      output_paragraph[start_pos + 5] = '_';
    }
d817 2
a818 1
cm_cite (int arg, int position)
d835 2
a836 1
cm_not_fixed_width (int arg, int start, int end)
d844 2
a845 1
cm_i (int arg)
d847 1
a847 6
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
d856 2
a857 1
cm_slanted (int arg)
d859 1
a859 23
  /* Make use of <lineannotation> of Docbook, if we are
     inside an @@example or similar.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SLANTED, arg);
  else if (html)
    insert_html_tag (arg, "i");
  else
    not_fixed_width (arg);
}

void
cm_b (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (docbook && arg == START)
    xml_insert_element_with_attribute (B, arg, "role=\"bold\"");
  else if (xml)
d868 2
a869 1
cm_r (int arg)
d871 1
a871 5
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
a872 2
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"roman\"");
d874 2
a875 2
    not_fixed_width (arg);
}
d877 19
a895 13
void
cm_sansserif (int arg)
{
  /* See cm_i comments.  */
  extern int printing_index;
  if (docbook && !filling_enabled && !printing_index)
    xml_insert_element (LINEANNOTATION, arg);
  else if (xml)
    xml_insert_element (SANSSERIF, arg);
  else if (html)
    insert_html_tag_with_attribute (arg, "span", "class=\"sansserif\"");
  else
    not_fixed_width (arg);
d899 2
a900 1
cm_titlefont (int arg)
d905 1
a905 21
   {
     not_fixed_width (arg);
     if (html)
	{
	  html_title_written = 1; /* suppress title from @@settitle */
	  if (arg == START)
	    add_word ("<h1 class=\"titlefont\">");
	  else
	    add_word ("</h1>\n");
	}
   }
}


/* Unfortunately, we cannot interpret @@math{} contents like TeX does.  We just
   pass them through.  */
void
cm_math (int arg)
{
  if (xml && !docbook)
    xml_insert_element (MATH, arg);
d910 1
a910 1
cm_no_op (void)
d917 1
a917 1
cm_novalidate (void)
d925 2
a926 1
cm_w (int arg)
d931 1
a931 8
    {
      if (docbook || html || xml)
        /* This is so @@w{$}Log$ doesn't end up as <dollar>Log<dollar>
           in the output.  */
        insert_string ("<!-- /@@w -->");
        
      non_splitting_words--;
    }
a934 15
/* An unbreakable word space.  Same as @@w{ } for makeinfo, but different
   for TeX (the space stretches and stretches, and does not inhibit
   hyphenation).  */
void
cm_tie (int arg)
{
  if (arg == START)
    {
      cm_w (START);
      add_char (' ');
    }
  else
    cm_w (END);
}

d938 2
a939 1
cm_obsolete (int arg, int start, int end)
d946 2
a947 2
/* Inhibit the indentation of the next paragraph, but not of following
   paragraphs.  */
d949 1
a949 1
cm_noindent (void)
a954 34
void
cm_noindent_cmd (void)
{
  cm_noindent ();
  xml_no_indent = 1;
  skip_whitespace_and_newlines();

  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"noindent\">");
  else
    {
      paragraph_is_open = 0;
      start_paragraph ();
    }
}

/* Force indentation of the next paragraph. */
void
cm_indent (void)
{
  inhibit_paragraph_indentation = 0;
  xml_no_indent = 0;
  skip_whitespace_and_newlines();
  
  if (xml)
    xml_start_para ();
  else if (html && !paragraph_is_open)
    add_html_block_elt ("<p class=\"indent\">");
  else
    start_paragraph ();
}

d958 1
a958 1
   Another option: ignore it, since they don't really want to
d962 1
a962 1
cm_setfilename (void)
d973 1
a973 1
cm_settitle (void)
a978 1
      xml_in_book_title = 1;
a980 1
      xml_in_book_title = 0;
d990 2
a991 1
cm_ignore_arg (int arg, int start_pos, int end_pos)
d999 1
a999 1
cm_ignore_line (void)
d1006 1
a1006 1
cm_sp (void)
d1011 1
a1011 3
  /* Due to tricky stuff in execute_string(), @@value{} can't be expanded.
     So there is really no reason to enable expansion for @@sp parameters.  */
  get_rest_of_line (0, &line);
a1018 2
          /* @@sp can appear between @@item and @@itemx, @@deffn and @@deffnx.  */
          xml_dont_touch_items_defs++;
a1021 1
          xml_dont_touch_items_defs--;
d1024 9
a1032 6
        {
          /* Must disable filling since otherwise multiple newlines is like
             multiple spaces.  Must close paragraph since that's what the
             manual says and that's what TeX does.  */
          int save_filling_enabled = filling_enabled;
          filling_enabled = 0;
d1034 2
a1035 2
          /* close_paragraph generates an extra blank line.  */
          close_single_paragraph ();
d1037 7
a1043 2
          if (lines && html && !executing_string)
            html_output_head ();
d1045 2
a1046 11
          if (html)
            add_html_block_elt ("<pre class=\"sp\">\n");

          while (lines--)
            add_char ('\n');

          if (html)
            add_html_block_elt ("</pre>\n");

          filling_enabled = save_filling_enabled;
        }
d1053 1
a1053 1
cm_dircategory (void)
d1087 1
a1087 1
cm_center (void)
d1091 1
a1091 1
      char *line;
d1093 2
a1094 2
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
d1100 5
a1104 5
      int i, start, length;
      char *line;
      int save_indented_fill = indented_fill;
      int save_filling_enabled = filling_enabled;
      int fudge_factor = 1;
d1106 3
a1108 3
      filling_enabled = indented_fill = 0;
      cm_noindent ();
      start = output_paragraph_offset;
d1110 2
a1111 2
      if (html)
        add_html_block_elt ("<div align=\"center\">");
d1113 38
a1150 41
      inhibit_output_flushing ();
      get_rest_of_line (0, &line);
      execute_string ("%s", line);
      free (line);
      uninhibit_output_flushing ();
      if (html)
        add_html_block_elt ("</div>");

       else
         {
           i = output_paragraph_offset - 1;
           while (i > (start - 1) && output_paragraph[i] == '\n')
             i--;

           output_paragraph_offset = ++i;
           length = output_paragraph_offset - start;

           if (length < (fill_column - fudge_factor))
             {
               line = xmalloc (1 + length);
               memcpy (line, (char *)(output_paragraph + start), length);

               i = (fill_column - fudge_factor - length) / 2;
               output_paragraph_offset = start;

               while (i--)
                 insert (' ');

               for (i = 0; i < length; i++)
                 insert (line[i]);

               free (line);
             }
         }

      insert ('\n');
      filling_enabled = save_filling_enabled;
      indented_fill = save_indented_fill;
      close_single_paragraph ();
      if (looking_at("\n"))
        insert ('\n');
d1156 2
a1157 1
cm_result (int arg)
d1165 2
a1166 1
cm_expansion (int arg)
d1174 2
a1175 1
cm_equiv (int arg)
d1183 2
a1184 1
cm_print (int arg)
d1192 2
a1193 1
cm_error (int arg)
d1201 2
a1202 1
cm_point (int arg)
d1211 1
a1211 1
cm_exdent (void)
d1217 1
a1217 1
  /* Read argument.  */
a1232 4
  else if (docbook)
    xml_insert_element (LINEANNOTATION, START);
  else if (xml)
    xml_insert_element (EXDENT, START);
a1240 6
  else if (xml)
    {
      xml_insert_element (docbook ? LINEANNOTATION : EXDENT, END);
      insert ('\n');
    }

a1244 2
  if (!xml)
    start_paragraph ();
d1253 2
a1254 1
handle_include (int verbatim_include)
d1256 1
a1256 1
  char *arg, *filename;
d1261 2
a1262 8
  if (!insertion_stack)
    close_paragraph ();  /* No blank lines etc. if not at outer level.  */
    
  get_rest_of_line (0, &arg);
  /* We really only want to expand @@value, but it's easier to just do
     everything.  TeX will only work with @@value.  */
  filename = text_expansion (arg);
  free (arg);
d1284 1
a1284 1
  if (!find_and_load (filename, 1))
d1286 2
d1315 1
a1315 1
cm_verbatiminclude (void)
d1323 1
a1323 1
cm_include (void)
d1332 1
a1332 1
cm_bye (void)
d1335 1
d1342 1
a1342 1
cm_paragraphindent (void)
a1352 1

d1355 2
a1356 1
set_example_indentation_increment (char *string)
d1361 2
a1362 2
    example_indentation_increment = 0;
  else if (sscanf (string, "%d", &example_indentation_increment) != 1)
d1368 1
a1368 1
cm_exampleindent (void)
d1373 1
a1373 31
  if (set_example_indentation_increment (arg) != 0)
    line_error (_("Bad argument to @@%s"), command);

  if (input_text[input_text_offset] == '\n')
    close_single_paragraph ();

  free (arg);
}


/* @@firstparagraphindent: suppress indentation in first paragraphs after
   headings. */
static int
set_firstparagraphindent (char *string)
{
  if (STREQ (string, "insert") || STREQ (string, _("insert")))
    do_first_par_indent = 1;
  else if (STREQ (string, "none") || STREQ (string, _("none")))
    do_first_par_indent = 0;
  else
    return -1;
  return 0;
}

static void
cm_firstparagraphindent (void)
{
  char *arg;

  get_rest_of_line (1, &arg);
  if (set_firstparagraphindent (arg) != 0)
a1376 61
}

/* For DocBook and XML, produce &period; for `.@@:'. This gives the processing
   software a fighting chance to treat it specially by not adding extra space.
  
   Do this also for ?, !, and :.  */
void
cm_colon (void)
{
  if (xml)
    {
      if (strchr (".?!:", input_text[input_text_offset-3]) != NULL)
        {
          /* Erase literal character that's there, except `>', which is
             part of the XML tag.  */
          if (output_paragraph[output_paragraph_offset-1] != '>')
            output_paragraph_offset--;

          switch (input_text[input_text_offset-3])
            {
            case '.':
              xml_insert_entity ("period");
              break;
            case '?':
              xml_insert_entity ("quest");
              break;
            case '!':
              xml_insert_entity ("excl");
              break;
            case ':':
              xml_insert_entity ("colon");
              break;
            }
        }
    }
}

/* Ending sentences explicitly.  Currently, only outputs entities for XML
   output, for other formats it calls insert_self.  */
void
cm_punct (int arg)
{
  if (xml && !docbook)
    {
      switch (input_text[input_text_offset-1])
        {
        case '.':
          xml_insert_entity ("eosperiod");
          break;
        case '?':
          xml_insert_entity ("eosquest");
          break;
        case '!':
          xml_insert_entity ("eosexcl");
          break;
        }
    }
  else
    {
      insert_self (arg);
    }
@


