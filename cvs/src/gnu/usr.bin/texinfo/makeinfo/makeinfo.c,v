head	1.9;
access;
symbols
	OPENBSD_6_2_BASE:1.9
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.40
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.32
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.36
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.34
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.30
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.28
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	TEXINFO_4_8:1.1.1.8
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	TEXINFO_4_2:1.1.1.7
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	TEXINFO_4_0:1.1.1.6
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	TEXINFO_3_12:1.1.1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	TEXINFO_3_11:1.1.1.4
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	TEXINFO_3_9:1.1.1.3
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	TEXINFO_3_7:1.1.1.2
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.11.14.23.06.06;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	3WsuKev3hGnuRYC4;

1.8
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.09.02.18.41;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.01.11.16.38.11;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	97.08.04.15.28.20;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.08.01.22.37.42;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	97.04.02.22.55.36;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.10;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.10;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.07.30.17.34.28;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.12.15.21.39.24;	author downsj;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.08.01.22.00.55;	author kstailey;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.01.11.16.32.36;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.02.09.01.25.28;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.06.10.13.21.20;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.07.17.16.03.48;	author espie;	state Exp;
branches;
next	;


desc
@@


1.9
log
@info - pledge stdio rpath wpath cpath getpw tty proc exec
infokey - stdio rpath wpath cpath tty
makeinfo - stdio rpath wpath cpath getpw
install-info - stdio rpath wpath cpath proc exec
texindex - stdio rpath wpath cpath tmppath
ok schwarze
@
text
@/* makeinfo -- convert Texinfo source into other formats.
   $Id: makeinfo.c,v 1.8 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Original author of makeinfo: Brian Fox (bfox@@ai.mit.edu).  */

#include "system.h"
#include "getopt.h"

#define COMPILING_MAKEINFO
#include "makeinfo.h"
#include "cmds.h"
#include "files.h"
#include "float.h"
#include "footnote.h"
#include "html.h"
#include "index.h"
#include "insertion.h"
#include "lang.h"
#include "macro.h"
#include "node.h"
#include "sectioning.h"
#include "toc.h"
#include "xml.h"

/* You can change some of the behavior of Makeinfo by changing the
   following defines: */

/* Define INDENT_PARAGRAPHS_IN_TABLE if you want the paragraphs which
   appear within an @@table, @@ftable, or @@itemize environment to have
   standard paragraph indentation.  Without this, such paragraphs have
   no starting indentation. */
/* #define INDENT_PARAGRAPHS_IN_TABLE */

/* Define PARAGRAPH_START_INDENT to be the amount of indentation that
   the first lines of paragraphs receive by default, where no other
   value has been specified.  Users can change this value on the command
   line, with the --paragraph-indent option, or within the texinfo file,
   with the @@paragraphindent command. */
#define PARAGRAPH_START_INDENT 3

/* Define DEFAULT_PARAGRAPH_SPACING as the number of blank lines that you
   wish to appear between paragraphs.  A value of 1 creates a single blank
   line between paragraphs.  Paragraphs are defined by 2 or more consecutive
   newlines in the input file (i.e., one or more blank lines). */
#define DEFAULT_PARAGRAPH_SPACING 1

/* Global variables.  */

/* The output file name. */
char *output_filename = NULL;

/* Name of the output file that the user elected to pass on the command line.
   Such a name overrides any name found with the @@setfilename command. */
char *command_output_filename = NULL;
static char *save_command_output_filename = NULL;

#define INITIAL_PARAGRAPH_SPACE 5000
int paragraph_buffer_len = INITIAL_PARAGRAPH_SPACE;

/* The amount of indentation to add at the starts of paragraphs.
   0 means don't change existing indentation at paragraph starts.
   > 0 is amount to indent new paragraphs by.
   < 0 means indent to column zero by removing indentation if necessary.

   This is normally zero, but some people prefer paragraph starts to be
   somewhat more indented than paragraph bodies.  A pretty value for
   this is 3. */
int paragraph_start_indent = PARAGRAPH_START_INDENT;

/* Indentation that is pending insertion.  We have this for hacking lines
   which look blank, but contain whitespace.  We want to treat those as
   blank lines. */
int pending_indent = 0;

/* The index in our internal command table of the currently
   executing command. */
int command_index;

/* A search string which is used to find the first @@setfilename. */
char setfilename_search[] =
  { COMMAND_PREFIX,
      's', 'e', 't', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', 0 };

/* Values for calling handle_variable_internal (). */
#define SET     1
#define CLEAR   2
#define IFSET   3
#define IFCLEAR 4

/* Flags controlling the operation of the program. */

/* Default is to remove output if there were errors.  */
int force = 0;

/* Default is to notify users of bad choices. */
int print_warnings = 1;

/* Number of errors that we tolerate on a given fileset. */
int max_error_level = 100;

/* The actual last inserted character.  Note that this may be something
   other than NEWLINE even if last_char_was_newline is 1. */
int last_inserted_character = 0;

/* Nonzero means that a newline character has already been
   inserted, so close_paragraph () should insert one less. */
int line_already_broken = 0;

/* When nonzero we have finished an insertion (see end_insertion ()) and we
   want to ignore false continued paragraph closings. */
int insertion_paragraph_closed = 0;

/* Nonzero means attempt to make all of the lines have fill_column width. */
int do_justification = 0;

/* Nonzero means don't replace whitespace with &nbsp; in HTML mode.  */
int in_html_elt = 0;

/* Nonzero means we are inserting a block level HTML element that must not be
   enclosed in a <p>, such as <ul>, <ol> and <h?>.  */
int in_html_block_level_elt = 0;

/* True when expanding a macro definition.  */
static int executing_macro = 0;

/* True when we are inside a <li> block of a menu.  */
static int in_menu_item = 0;

typedef struct brace_element
{
  struct brace_element *next;
  COMMAND_FUNCTION *proc;
  char *command;
  int pos, line;
  int in_fixed_width_font;
} BRACE_ELEMENT;

BRACE_ELEMENT *brace_stack = NULL;

static void convert_from_file (char *name);
static void convert_from_loaded_file (char *name);
static void convert_from_stream (FILE *stream, char *name);
static void do_flush_right_indentation (void);
static void handle_variable (int action);
static void handle_variable_internal (int action, char *name);
static void init_brace_stack (void);
static void init_internals (void);
static void pop_and_call_brace (void);
static void remember_brace (COMMAND_FUNCTION (*proc));
static int end_of_sentence_p (void);

void maybe_update_execution_strings (char **text, unsigned int new_len);

/* Error handling.  */

/* Number of errors encountered. */
int errors_printed = 0;

/* Remember that an error has been printed.  If more than
   max_error_level have been printed, then exit the program. */
static void
remember_error (void)
{
  errors_printed++;
  if (max_error_level && (errors_printed > max_error_level))
    {
      fprintf (stderr, _("Too many errors!  Gave up.\n"));
      flush_file_stack ();
      if (errors_printed - max_error_level < 2)
	cm_bye ();
      xexit (1);
    }
}

/* Print the last error gotten from the file system. */
int
fs_error (char *filename)
{
  remember_error ();
  perror (filename);
  return 0;
}

/* Print an error message, and return false. */
void
#if defined (VA_FPRINTF) && __STDC__
error (const char *format, ...)
#else
error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  putc ('\n', stderr);
}

/* Just like error (), but print the input file and line number as well. */
void
#if defined (VA_FPRINTF) && __STDC__
file_line_error (char *infile, int lno, const char *format, ...)
#else
file_line_error (infile, lno, format, va_alist)
   char *infile;
   int lno;
   const char *format;
   va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();
  fprintf (stderr, "%s:%d: ", infile, lno);

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  fprintf (stderr, ".\n");
}

/* Just like file_line_error (), but take the input file and the line
   number from global variables. */
void
#if defined (VA_FPRINTF) && __STDC__
line_error (const char *format, ...)
#else
line_error (format, va_alist)
   const char *format;
   va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();
  fprintf (stderr, "%s:%d: ", input_filename, line_number);

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  fprintf (stderr, ".\n");
}

void
#if defined (VA_FPRINTF) && __STDC__
warning (const char *format, ...)
#else
warning (format, va_alist)
     const char *format;
     va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  if (print_warnings)
    {
      fprintf (stderr, _("%s:%d: warning: "), input_filename, line_number);

      VA_START (ap, format);
#ifdef VA_FPRINTF
      VA_FPRINTF (stderr, format, ap);
#else
      fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
      va_end (ap);

      fprintf (stderr, ".\n");
    }
}


/* The other side of a malformed expression. */
static void
misplaced_brace (void)
{
  line_error (_("Misplaced %c"), '}');
}

/* Main.  */

/* Display the version info of this invocation of Makeinfo. */
static void
print_version_info (void)
{
  printf ("makeinfo (GNU %s) %s\n", PACKAGE, VERSION);
}

/* If EXIT_VALUE is zero, print the full usage message to stdout.
   Otherwise, just say to use --help for more info.
   Then exit with EXIT_VALUE. */
static void
usage (int exit_value)
{
  if (exit_value != 0)
    fprintf (stderr, _("Try `%s --help' for more information.\n"), progname);
  else
  {
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n"), progname);
    puts ("");

    puts (_("\
Translate Texinfo source documentation to various other formats, by default\n\
Info files suitable for reading online with Emacs or standalone GNU Info.\n"));

    printf (_("\
General options:\n\
      --error-limit=NUM       quit after NUM errors (default %d).\n\
      --force                 preserve output even if errors.\n\
      --help                  display this help and exit.\n\
      --no-validate           suppress node cross-reference validation.\n\
      --no-warn               suppress warnings (but not errors).\n\
      --reference-limit=NUM   warn about at most NUM references (default %d).\n\
  -v, --verbose               explain what is being done.\n\
      --version               display version information and exit.\n"),
            max_error_level, reference_warning_limit);
    puts ("");

     /* xgettext: no-wrap */
    puts (_("\
Output format selection (default is to produce Info):\n\
      --docbook             output Docbook XML rather than Info.\n\
      --html                output HTML rather than Info.\n\
      --xml                 output Texinfo XML rather than Info.\n\
      --plaintext           output plain text rather than Info.\n\
"));

    puts (_("\
General output options:\n\
  -E, --macro-expand FILE   output macro-expanded source to FILE.\n\
                            ignoring any @@setfilename.\n\
      --no-headers          suppress node separators, Node: lines, and menus\n\
                              from Info output (thus producing plain text)\n\
                              or from HTML (thus producing shorter output);\n\
                              also, write to standard output by default.\n\
      --no-split            suppress splitting of Info or HTML output,\n\
                            generate only one output file.\n\
      --number-sections     output chapter and sectioning numbers.\n\
  -o, --output=FILE         output to FILE (directory if split HTML),\n\
"));

    printf (_("\
Options for Info and plain text:\n\
      --enable-encoding       output accented and special characters in\n\
                                Info output based on @@documentencoding.\n\
      --fill-column=NUM       break Info lines at NUM characters (default %d).\n\
      --footnote-style=STYLE  output footnotes in Info according to STYLE:\n\
                                `separate' to put them in their own node;\n\
                                `end' to put them at the end of the node\n\
                                  in which they are defined (default).\n\
      --paragraph-indent=VAL  indent Info paragraphs by VAL spaces (default %d).\n\
                                If VAL is `none', do not indent; if VAL is\n\
                                `asis', preserve existing indentation.\n\
      --split-size=NUM        split Info files at size NUM (default %d).\n"),
             fill_column, paragraph_start_indent,
             DEFAULT_SPLIT_SIZE);
    puts ("");

    puts (_("\
Options for HTML:\n\
      --css-include=FILE        include FILE in HTML <style> output;\n\
                                  read stdin if FILE is -.\n\
"));

    printf (_("\
Options for XML and Docbook:\n\
      --output-indent=VAL       indent XML elements by VAL spaces (default %d).\n\
                                  If VAL is 0, ignorable whitespace is dropped.\n\
"), xml_indentation_increment);
    puts ("");

    puts (_("\
Input file options:\n\
      --commands-in-node-names  allow @@ commands in node names.\n\
  -D VAR                        define the variable VAR, as with @@set.\n\
  -I DIR                        append DIR to the @@include search path.\n\
  -P DIR                        prepend DIR to the @@include search path.\n\
  -U VAR                        undefine the variable VAR, as with @@clear.\n\
"));

    puts (_("\
Conditional processing in input:\n\
  --ifdocbook       process @@ifdocbook and @@docbook even if\n\
                      not generating Docbook.\n\
  --ifhtml          process @@ifhtml and @@html even if not generating HTML.\n\
  --ifinfo          process @@ifinfo even if not generating Info.\n\
  --ifplaintext     process @@ifplaintext even if not generating plain text.\n\
  --iftex           process @@iftex and @@tex; implies --no-split.\n\
  --ifxml           process @@ifxml and @@xml.\n\
  --no-ifdocbook    do not process @@ifdocbook and @@docbook text.\n\
  --no-ifhtml       do not process @@ifhtml and @@html text.\n\
  --no-ifinfo       do not process @@ifinfo text.\n\
  --no-ifplaintext  do not process @@ifplaintext text.\n\
  --no-iftex        do not process @@iftex and @@tex text.\n\
  --no-ifxml        do not process @@ifxml and @@xml text.\n\
\n\
  Also, for the --no-ifFORMAT options, do process @@ifnotFORMAT text.\n\
"));

    puts (_("\
  The defaults for the @@if... conditionals depend on the output format:\n\
  if generating HTML, --ifhtml is on and the others are off;\n\
  if generating Info, --ifinfo is on and the others are off;\n\
  if generating plain text, --ifplaintext is on and the others are off;\n\
  if generating XML, --ifxml is on and the others are off.\n\
"));

    fputs (_("\
Examples:\n\
  makeinfo foo.texi                     write Info to foo's @@setfilename\n\
  makeinfo --html foo.texi              write HTML to @@setfilename\n\
  makeinfo --xml foo.texi               write Texinfo XML to @@setfilename\n\
  makeinfo --docbook foo.texi           write DocBook XML to @@setfilename\n\
  makeinfo --no-headers foo.texi        write plain text to standard output\n\
\n\
  makeinfo --html --no-headers foo.texi write html without node lines, menus\n\
  makeinfo --number-sections foo.texi   write Info with numbered sections\n\
  makeinfo --no-split foo.texi          write one Info file however big\n\
"), stdout);

    puts (_("\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
Texinfo home page: http://www.gnu.org/software/texinfo/"));

  } /* end of full help */

  xexit (exit_value);
}

struct option long_options[] =
{
  { "commands-in-node-names", 0, &expensive_validation, 1 },
  { "css-include", 1, 0, 'C' },
  { "docbook", 0, 0, 'd' },
  { "enable-encoding", 0, &enable_encoding, 1 },
  { "error-limit", 1, 0, 'e' },
  { "fill-column", 1, 0, 'f' },
  { "footnote-style", 1, 0, 's' },
  { "force", 0, &force, 1 },
  { "help", 0, 0, 'h' },
  { "html", 0, 0, 'w' },
  { "ifdocbook", 0, &process_docbook, 1 },
  { "ifhtml", 0, &process_html, 1 },
  { "ifinfo", 0, &process_info, 1 },
  { "ifplaintext", 0, &process_plaintext, 1 },
  { "iftex", 0, &process_tex, 1 },
  { "ifxml", 0, &process_xml, 1 },
  { "macro-expand", 1, 0, 'E' },
  { "no-headers", 0, &no_headers, 1 },
  { "no-ifdocbook", 0, &process_docbook, 0 },
  { "no-ifhtml", 0, &process_html, 0 },
  { "no-ifinfo", 0, &process_info, 0 },
  { "no-ifplaintext", 0, &process_plaintext, 0 },
  { "no-iftex", 0, &process_tex, 0 },
  { "no-ifxml", 0, &process_xml, 0 },
  { "no-number-footnotes", 0, &number_footnotes, 0 },
  { "no-number-sections", 0, &number_sections, 0 },
  { "no-pointer-validate", 0, &validating, 0 },
  { "no-split", 0, &splitting, 0 },
  { "no-validate", 0, &validating, 0 },
  { "no-warn", 0, &print_warnings, 0 },
  { "number-footnotes", 0, &number_footnotes, 1 },
  { "number-sections", 0, &number_sections, 1 },
  { "output", 1, 0, 'o' },
  { "output-indent", 1, 0, 'i' },
  { "paragraph-indent", 1, 0, 'p' },
  { "plaintext", 0, 0, 't' },
  { "reference-limit", 1, 0, 'r' },
  { "split-size", 1, 0, 'S'},
  { "verbose", 0, &verbose_mode, 1 },
  { "version", 0, 0, 'V' },
  { "xml", 0, 0, 'x' },
  {NULL, 0, NULL, 0}
};

/* We use handle_variable_internal for -D and -U, and it depends on
   execute_string, which depends on input_filename, which is not defined
   while we are handling options. :-\  So we save these defines in this
   struct, and handle them later.  */
typedef struct command_line_define
{
  struct command_line_define *next;
  int action;
  char *define;
} COMMAND_LINE_DEFINE;

static COMMAND_LINE_DEFINE *command_line_defines = NULL;

/* For each file mentioned in the command line, process it, turning
   Texinfo commands into wonderfully formatted output text. */
int
main (int argc, char **argv)
{
  int c, ind;
  int reading_from_stdin = 0;

#ifdef HAVE_SETLOCALE
  /* Do not use LC_ALL, because LC_NUMERIC screws up the scanf parsing
     of the argument to @@multicolumn.  */
  setlocale (LC_TIME, "");
#ifdef LC_MESSAGES /* ultrix */
  setlocale (LC_MESSAGES, "");
#endif
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
#endif

  if (pledge ("stdio rpath wpath cpath getpw", NULL) == -1) {
    perror ("pledge");
    exit (1);
  }

#ifdef ENABLE_NLS
  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
#endif

  /* If TEXINFO_OUTPUT_FORMAT envvar is set, use it to set default output.
     Can be overridden with one of the output options.  */
  if (getenv ("TEXINFO_OUTPUT_FORMAT") != NULL)
    {
      if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "docbook"))
        {
          splitting = 0;
          html = 0;
          docbook = 1;
          xml = 1;
          process_docbook = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "html"))
        {
          html = 1;
          docbook = 0;
          xml = 0;
          process_html = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "info"))
        {
          html = 0;
          docbook = 0;
          xml = 0;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "plaintext"))
        {
          splitting = 0;
          no_headers = 1;
          html = 0;
          docbook = 0;
          xml = 0;
          process_plaintext = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "xml"))
        {
          splitting = 0;
          html = 0;
          docbook = 0;
          xml = 1;
          process_xml = 1;
        }
      else
        fprintf (stderr,
            _("%s: Ignoring unrecognized TEXINFO_OUTPUT_FORMAT value `%s'.\n"),
                 progname, getenv ("TEXINFO_OUTPUT_FORMAT"));
    }

  /* Parse argument flags from the input line. */
  while ((c = getopt_long (argc, argv, "D:de:E:f:hI:i:o:p:P:r:s:t:U:vV:wx",
                           long_options, &ind)) != EOF)
    {
      if (c == 0 && long_options[ind].flag == 0)
        c = long_options[ind].val;

      switch (c)
        {
        case 'C':  /* --css-include */
          css_include = xstrdup (optarg);
          break;

        case 'D':
        case 'U':
          /* User specified variable to set or clear. */
          if (xml && !docbook)
            {
              COMMAND_LINE_DEFINE *new = xmalloc (sizeof (COMMAND_LINE_DEFINE));
              new->action = (c == 'D') ? SET : CLEAR;
              new->define = xstrdup (optarg);
              new->next = command_line_defines;
              command_line_defines = new;
            }
          else
            handle_variable_internal ((c == 'D' ? SET : CLEAR), optarg);
          break;

        case 'd': /* --docbook */
          splitting = 0;
          xml = 1;
          docbook = 1;
          html = 0;
	  process_docbook = 1;
          break;

        case 'e': /* --error-limit */
          if (sscanf (optarg, "%d", &max_error_level) != 1)
            {
              fprintf (stderr,
                      _("%s: %s arg must be numeric, not `%s'.\n"),
                      progname, "--error-limit", optarg);
              usage (1);
            }
          break;

        case 'E': /* --macro-expand */
          if (!macro_expansion_output_stream)
            {
              macro_expansion_filename = optarg;
              macro_expansion_output_stream
                = strcmp (optarg, "-") == 0 ? stdout : fopen (optarg, "w");
              if (!macro_expansion_output_stream)
                error (_("%s: could not open macro expansion output `%s'"),
                       progname, optarg);
            }
          else
            fprintf (stderr,
                     _("%s: ignoring second macro expansion output `%s'.\n"),
                     progname, optarg);
          break;

        case 'f': /* --fill-column */
          if (sscanf (optarg, "%d", &fill_column) != 1)
            {
              fprintf (stderr,
                       _("%s: %s arg must be numeric, not `%s'.\n"),
                       progname, "--fill-column", optarg);
              usage (1);
            }
          break;

        case 'h': /* --help */
          usage (0);
          break;

        case 'I':
          /* Append user-specified dir to include file path. */
          append_to_include_path (optarg);
          break;

        case 'i':
          if (sscanf (optarg, "%d", &xml_indentation_increment) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"),
                     progname, "--output-indent", optarg);
              usage (1);
            }
          break;

        case 'o': /* --output */
          command_output_filename = xstrdup (optarg);
          save_command_output_filename = command_output_filename;
          break;

        case 'p': /* --paragraph-indent */
          if (set_paragraph_indent (optarg) < 0)
            {
              fprintf (stderr,
   _("%s: --paragraph-indent arg must be numeric/`none'/`asis', not `%s'.\n"),
                       progname, optarg);
              usage (1);
            }
          break;

        case 'P':
          /* Prepend user-specified include dir to include path. */
          prepend_to_include_path (optarg);
          break;

        case 'r': /* --reference-limit */
          if (sscanf (optarg, "%d", &reference_warning_limit) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"),
                     progname, "--reference-limit", optarg);
              usage (1);
            }
          break;

        case 's': /* --footnote-style */
          if (set_footnote_style (optarg) < 0)
            {
              fprintf (stderr,
        _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"),
                       progname, optarg);
              usage (1);
            }
          footnote_style_preset = 1;
          break;

        case 'S': /* --split-size */
          if (sscanf (optarg, "%d", &split_size) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"),
                     progname, "--split-size", optarg);
              usage (1);
            }
          break;

        case 't': /* --plaintext */
          splitting = 0;
          no_headers = 1;
          html = 0;
          docbook = 0;
          xml = 0;
          process_plaintext = 1;
          break;

        case 'v':
          verbose_mode++;
          break;

        case 'V': /* --version */
          print_version_info ();
          puts ("");
          puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
          printf (_("There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.\n"));
          xexit (0);
          break;

        case 'w': /* --html */
          xml = 0;
          docbook = 0;
          html = 1;
          process_html = 1;
          break;

        case 'x': /* --xml */
          splitting = 0;
          html = 0;
          docbook = 0;
          xml = 1;
          process_xml = 1;
          break;

        case '?':
          usage (1);
          break;
        }
    }

  if (macro_expansion_output_stream)
    validating = 0;

  if (!validating)
    expensive_validation = 0;

  if (optind == argc)
    {
      /* Check to see if input is a file.  If so, process that. */
      if (!isatty (fileno (stdin)))
        reading_from_stdin = 1;
      else
        {
          fprintf (stderr, _("%s: missing file argument.\n"), progname);
          usage (1);
        }
    }

  if (no_headers)
    {
      /* If the user did not specify an output file, use stdout. */
      if (!command_output_filename)
        command_output_filename = xstrdup ("-");

      if (html && splitting && !STREQ (command_output_filename, "-"))
        { /* --no-headers --no-split --html indicates confusion. */
          fprintf (stderr,
                  "%s: can't split --html output to `%s' with --no-headers.\n",
                   progname, command_output_filename);
          usage (1);
        }

      /* --no-headers implies --no-split.  */
      splitting = 0;
    }

  if (process_info == -1)
    { /* no explicit --[no-]ifinfo option, so we'll do @@ifinfo
         if we're generating info or (for compatibility) plain text.  */
      process_info = !html && !xml;
    }

  if (process_plaintext == -1)
    { /* no explicit --[no-]ifplaintext option, so we'll do @@ifplaintext
         if we're generating plain text.  */
      process_plaintext = no_headers && !html && !xml;
    }

  if (verbose_mode)
    print_version_info ();

  /* Remaining arguments are file names of texinfo files.
     Convert them, one by one. */
  if (!reading_from_stdin)
    {
      while (optind != argc)
        convert_from_file (argv[optind++]);
    }
  else
    convert_from_stream (stdin, "stdin");

  xexit (errors_printed ? 2 : 0);
  return 0; /* Avoid bogus warnings.  */
}

/* Hacking tokens and strings.  */

/* Return the next token as a string pointer.  We cons the string.  This
   `token' means simply a command name.  */

/* = is so @@alias works.  ^ and _ are so macros can be used in math mode
   without a space following.  Possibly we should simply allow alpha, to
   be compatible with TeX.  */
#define COMMAND_CHAR(c) (!cr_or_whitespace(c) \
                         && (c) != '{' \
                         && (c) != '}' \
                         && (c) != '=' \
                         && (c) != '_' \
                         && (c) != '^' \
                         )

static char *
read_token (void)
{
  int i, character;
  char *result;

  /* If the first character to be read is self-delimiting, then that
     is the command itself. */
  character = curchar ();
  if (self_delimiting (character))
    {
      input_text_offset++;

      if (character == '\n')
        line_number++;

      result = xstrdup (" ");
      *result = character;
      return result;
    }

  for (i = 0; ((input_text_offset != input_text_length)
               && (character = curchar ())
               && COMMAND_CHAR (character));
       i++, input_text_offset++);
  result = xmalloc (i + 1);
  memcpy (result, &input_text[input_text_offset - i], i);
  result[i] = 0;
  return result;
}

/* Return nonzero if CHARACTER is self-delimiting. */
int
self_delimiting (int character)
{
  /* @@; and @@\ are not Texinfo commands, but they are listed here
     anyway.  I don't know why.  --karl, 10aug96.  */
  return strchr ("~{|}`^\\@@?=;:./-,*\'\" !\n\t", character) != NULL;
}

/* Clear whitespace from the front and end of string. */
void
canon_white (char *string)
{
  char *p = string;
  unsigned len;

  if (!*p)
    return;

  do
    {
      if (!cr_or_whitespace (*p))
	break;
      ++p;
    }
  while (*p);

  len = strlen (p);
  while (len && cr_or_whitespace (p[len-1]))
    --len;

  if (p != string)
    memmove (string, p, len);

  string[len] = 0;
}

/* Bash STRING, replacing all whitespace with just one space. */
void
fix_whitespace (char *string)
{
  char *temp = xmalloc (strlen (string) + 1);
  int string_index = 0;
  int temp_index = 0;
  int c;

  canon_white (string);

  while (string[string_index])
    {
      c = temp[temp_index++] = string[string_index++];

      if (c == ' ' || c == '\n' || c == '\t')
        {
          temp[temp_index - 1] = ' ';
          while ((c = string[string_index]) && (c == ' ' ||
                                                c == '\t' ||
                                                c == '\n'))
            string_index++;
        }
    }
  temp[temp_index] = 0;
  strcpy (string, temp);
  free (temp);
}

/* Discard text until the desired string is found.  The string is
   included in the discarded text. */
void
discard_until (char *string)
{
  int temp = search_forward (string, input_text_offset);

  int tt = (temp < 0) ? input_text_length : temp + strlen (string);
  int from = input_text_offset;

  /* Find out what line we are on. */
  while (from != tt)
    if (input_text[from++] == '\n')
      line_number++;

  if (temp < 0)
    {
      /* not found, move current position to end of string */
      input_text_offset = input_text_length;
      if (strcmp (string, "\n") != 0)
        { /* Give a more descriptive feedback, if we are looking for ``@@end ''
             during macro execution.  That means someone used a multiline
             command as an argument to, say, @@section ... style commands.  */
          char *end_block = xmalloc (8);
          sprintf (end_block, "\n%cend ", COMMAND_PREFIX);
          if (executing_string && strstr (string, end_block))
            line_error (_("Multiline command %c%s used improperly"), 
                COMMAND_PREFIX, command);
          else
            line_error (_("Expected `%s'"), string);
          free (end_block);
          return;
        }
    }
  else
    /* found, move current position to after the found string */
    input_text_offset = temp + strlen (string);
}

/* Read characters from the file until we are at MATCH.
   Place the characters read into STRING.
   On exit input_text_offset is after the match string.
   Return the offset where the string starts. */
int
get_until (char *match, char **string)
{
  int len, current_point, x, new_point, tem;

  current_point = x = input_text_offset;
  new_point = search_forward (match, input_text_offset);

  if (new_point < 0)
    new_point = input_text_length;
  len = new_point - current_point;

  /* Keep track of which line number we are at. */
  tem = new_point + (strlen (match) - 1);
  while (x != tem)
    if (input_text[x++] == '\n')
      line_number++;

  *string = xmalloc (len + 1);

  memcpy (*string, &input_text[current_point], len);
  (*string)[len] = 0;

  /* Now leave input_text_offset in a consistent state. */
  input_text_offset = tem;

  if (input_text_offset > input_text_length)
    input_text_offset = input_text_length;

  return new_point;
}

/* Replace input_text[FROM .. TO] with its expansion.  */
void
replace_with_expansion (int from, int *to)
{
  char *xp;
  unsigned xp_len, new_len;
  char *old_input = input_text;
  unsigned raw_len = *to - from;
  char *str;

  /* The rest of the code here moves large buffers, so let's
     not waste time if the input cannot possibly expand
     into anything.  Unfortunately, we cannot avoid expansion
     when we see things like @@code etc., even if they only
     asked for expansion of macros, since any Texinfo command
     can be potentially redefined with a macro.  */
  if (only_macro_expansion &&
      memchr (input_text + from, COMMAND_PREFIX, raw_len) == 0)
    return;

  /* Get original string from input.  */
  str = xmalloc (raw_len + 1);
  memcpy (str, input_text + from, raw_len);
  str[raw_len] = 0;

  /* We are going to relocate input_text, so we had better output
     pending portion of input_text now, before the pointer changes.  */
  if (macro_expansion_output_stream && !executing_string
      && !me_inhibit_expansion)
    append_to_expansion_output (from);

  /* Expand it.  */
  xp = expansion (str, 0);
  xp_len = strlen (xp);
  free (str);

  /* Plunk the expansion into the middle of `input_text' --
     which is terminated by a newline, not a null.  Avoid
     expensive move of the rest of the input if the expansion
     has the same length as the original string.  */
  if (xp_len != raw_len)
    {
      new_len = from + xp_len + input_text_length - *to + 1;
      if (executing_string)
        { /* If we are in execute_string, we might need to update
             the relevant element in the execution_strings[] array,
             since it could have to be relocated from under our
             feet.  (input_text is reallocated here as well, if needed.)  */
          maybe_update_execution_strings (&input_text, new_len);
        }
      else if (new_len > input_text_length + 1)
        /* Don't bother to realloc if we have enough space.  */
        input_text = xrealloc (input_text, new_len);

      memmove (input_text + from + xp_len,
               input_text + *to, input_text_length - *to + 1);

      *to += xp_len - raw_len;
      /* Since we change input_text_length here, the comparison above
         isn't really valid, but it seems the worst that might happen is
         an extra xrealloc or two, so let's not worry.  */
      input_text_length += xp_len - raw_len;
    }
  memcpy (input_text + from, xp, xp_len);
  free (xp);

  /* Synchronize the macro-expansion pointers with our new input_text.  */
  if (input_text != old_input)
    forget_itext (old_input);
  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, from);
}

/* Read characters from the file until we are at MATCH or end of line.
   Place the characters read into STRING.  If EXPAND is nonzero,
   expand the text before looking for MATCH for those cases where
   MATCH might be produced by some macro.  */
void
get_until_in_line (int expand, char *match, char **string)
{
  int real_bottom = input_text_length;
  int limit = search_forward ("\n", input_text_offset);
  if (limit < 0)
    limit = input_text_length;

  /* Replace input_text[input_text_offset .. limit-1] with its expansion.
     This allows the node names and menu entries themselves to be
     constructed via a macro, as in:
        @@macro foo{p, q}
        Together: \p\ & \q\.
        @@end macro

        @@node @@foo{A,B}, next, prev, top

     Otherwise, the `,' separating the macro args A and B is taken as
     the node argument separator, so the node name is `@@foo{A'.  This
     expansion is only necessary on the first call, since we expand the
     whole line then.  */
  if (expand)
    {
      replace_with_expansion (input_text_offset, &limit);
    }

  real_bottom = input_text_length;
  input_text_length = limit;
  get_until (match, string);
  input_text_length = real_bottom;
}

void
get_rest_of_line (int expand, char **string)
{
  xml_no_para ++;
  if (expand)
    {
      char *tem;

      /* Don't expand non-macros in input, since we want them
         intact in the macro-expanded output.  */
      only_macro_expansion++;
      get_until_in_line (1, "\n", &tem);
      only_macro_expansion--;
      *string = expansion (tem, 0);
      free (tem);
    }
  else
    get_until_in_line (0, "\n", string);

  canon_white (*string);

  if (curchar () == '\n')       /* as opposed to the end of the file... */
    {
      line_number++;
      input_text_offset++;
    }
  xml_no_para --;
}

/* Backup the input pointer to the previous character, keeping track
   of the current line number. */
void
backup_input_pointer (void)
{
  if (input_text_offset)
    {
      input_text_offset--;
      if (curchar () == '\n')
        line_number--;
    }
}

/* Read characters from the file until we are at MATCH or closing brace.
   Place the characters read into STRING.  */
void
get_until_in_braces (char *match, char **string)
{
  char *temp;
  int i, brace = 0;
  int match_len = strlen (match);

  for (i = input_text_offset; i < input_text_length; i++)
    {
      if (i < input_text_length - 1 && input_text[i] == '@@')
        {
          i++;                  /* skip commands like @@, and @@{ */
          continue;
        }
      else if (input_text[i] == '{')
        brace++;
      else if (input_text[i] == '}')
        {
          brace--;
          /* If looking for a brace, don't stop at the interior brace,
             like after "baz" in "@@foo{something @@bar{baz} more}".  */
          if (brace == 0)
            continue;
        }
      else if (input_text[i] == '\n')
        line_number++;

      if (brace < 0 ||
          (brace == 0 && strncmp (input_text + i, match, match_len) == 0))
        break;
    }

  match_len = i - input_text_offset;
  temp = xmalloc (2 + match_len);
  memcpy (temp, input_text + input_text_offset, match_len);
  temp[match_len] = 0;
  input_text_offset = i;
  *string = temp;
}



/* Converting a file.  */

/* Convert the file named by NAME.  The output is saved on the file
   named as the argument to the @@setfilename command. */
static char *suffixes[] = {
  /* ".txi" is checked first so that on 8+3 DOS filesystems, if they
     have "texinfo.txi" and "texinfo.tex" in the same directory, the
     former is used rather than the latter, due to file name truncation.  */
  ".txi",
  ".texinfo",
  ".texi",
  ".txinfo",
  "",
  NULL
};

static void
initialize_conversion (void)
{
  init_tag_table ();
  init_indices ();
  init_internals ();
  init_paragraph ();

  /* This is used for splitting the output file and for doing section
     headings.  It was previously initialized in `init_paragraph', but its
     use there loses with the `init_paragraph' calls done by the
     multitable code; the tag indices get reset to zero.  */
  output_position = 0;
}

/* Reverse the chain of structures in LIST.  Output the new head
   of the chain.  You should always assign the output value of this
   function to something, or you will lose the chain. */
GENERIC_LIST *
reverse_list (GENERIC_LIST *list)
{
  GENERIC_LIST *next;
  GENERIC_LIST *prev = NULL;

  while (list)
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return prev;
}

/* We read in multiples of 4k, simply because it is a typical pipe size
   on unix systems. */
#define READ_BUFFER_GROWTH (4 * 4096)

/* Convert the Texinfo file coming from the open stream STREAM.  Assume the
   source of the stream is named NAME. */
static void
convert_from_stream (FILE *stream, char *name)
{
  char *buffer = NULL;
  int buffer_offset = 0, buffer_size = 0;

  initialize_conversion ();

  /* Read until the end of the stream.  This isn't strictly correct, since
     the texinfo input may end before the stream ends, but it is a quick
     working hueristic. */
  while (!feof (stream))
    {
      int count;

      if (buffer_offset + (READ_BUFFER_GROWTH + 1) >= buffer_size)
        buffer = (char *)
          xrealloc (buffer, (buffer_size += READ_BUFFER_GROWTH));

      count = fread (buffer + buffer_offset, 1, READ_BUFFER_GROWTH, stream);

      if (count < 0)
        {
          perror (name);
          xexit (1);
        }

      buffer_offset += count;
      if (count == 0)
        break;
    }

  /* Set the globals to the new file. */
  input_text = buffer;
  input_text_length = buffer_offset;
  input_filename = xstrdup (name);
  node_filename = xstrdup (name);
  input_text_offset = 0;
  line_number = 1;

  /* Not strictly necessary.  This magic prevents read_token () from doing
     extra unnecessary work each time it is called (that is a lot of times).
     The INPUT_TEXT_LENGTH is one past the actual end of the text. */
  input_text[input_text_length] = '\n';

  convert_from_loaded_file (name);
}

static void
convert_from_file (char *name)
{
  int i;
  char *filename = xmalloc (strlen (name) + 50);

  /* Prepend file directory to the search path, so relative links work.  */
  prepend_to_include_path (pathname_part (name));

  initialize_conversion ();

  /* Try to load the file specified by NAME, concatenated with our
     various suffixes.  Prefer files like `makeinfo.texi' to
     `makeinfo'.  */
  for (i = 0; suffixes[i]; i++)
    {
      strcpy (filename, name);
      strcat (filename, suffixes[i]);

      if (find_and_load (filename, 1))
        break;

      if (!suffixes[i][0] && strrchr (filename, '.'))
        {
          fs_error (filename);
          free (filename);
          return;
        }
    }

  if (!suffixes[i])
    {
      fs_error (name);
      free (filename);
      return;
    }

  input_filename = filename;

  convert_from_loaded_file (name);

  /* Pop the prepended path, so multiple filenames in the
     command line do not screw each others include paths.  */
  pop_path_from_include_path ();
}

static int
create_html_directory (char *dir, int can_remove_file)
{
  struct stat st;

  /* Already exists.  */
  if (stat (dir, &st) == 0)
    {
      /* And it's a directory, so silently reuse it.  */
      if (S_ISDIR (st.st_mode))
        return 1;
      /* Not a directory, so move it out of the way if we are allowed.  */
      else if (can_remove_file)
        {
          if (unlink (dir) != 0)
            return 0;
        }
      else
        return 0;
    }

  if (mkdir (dir, 0777) == 0)
    /* Success!  */
    return 1;
  else
    return 0;
}

/* Given OUTPUT_FILENAME == ``/foo/bar/baz.html'', return
   "/foo/bar/baz/baz.html".  This routine is called only if html && splitting.

  Split html output goes into the subdirectory of the toplevel
  filename, without extension.  For example:
      @@setfilename foo.info
  produces output in files foo/index.html, foo/second-node.html, ...

  But if the user said -o foo.whatever on the cmd line, then use
  foo.whatever unchanged.  */

static char *
insert_toplevel_subdirectory (char *output_filename)
{
  static const char index_name[] = "index.html";
  char *dir, *subdir, *base, *basename, *p;
  char buf[PATH_MAX];
  const int index_len = sizeof (index_name) - 1;

  strcpy (buf, output_filename);
  dir = pathname_part (buf);   /* directory of output_filename */
  base = filename_part (buf);  /* strips suffix, too */
  basename = xstrdup (base);   /* remember real @@setfilename name */
  p = dir + strlen (dir) - 1;
  if (p > dir && IS_SLASH (*p))
    *p = 0;
  p = strrchr (base, '.');
  if (p)
    *p = 0;

  /* Split html output goes into subdirectory of toplevel name. */
  if (save_command_output_filename
      && STREQ (output_filename, save_command_output_filename))
    subdir = basename;  /* from user, use unchanged */
  else
    subdir = base;      /* implicit, omit suffix */

  free (output_filename);
  output_filename = xmalloc (strlen (dir) + 1
                             + strlen (basename) + 1
                             + index_len
                             + 1);
  strcpy (output_filename, dir);
  if (strlen (dir))
    strcat (output_filename, "/");
  strcat (output_filename, subdir);

  /* First try, do not remove existing file.  */
  if (!create_html_directory (output_filename, 0))
    {
      /* That failed, try subdir name with .html.
         Remove it if it exists.  */
      strcpy (output_filename, dir);
      if (strlen (dir))
        strcat (output_filename, "/");
      strcat (output_filename, basename);

      if (!create_html_directory (output_filename, 1))
        {
          /* Last try failed too :-\  */
          line_error (_("Can't create directory `%s': %s"),
              output_filename, strerror (errno));
          xexit (1);
        }
    }

  strcat (output_filename, "/");
  strcat (output_filename, index_name);
  return output_filename;
}

/* FIXME: this is way too hairy */
static void
convert_from_loaded_file (char *name)
{
  char *real_output_filename = NULL;

  remember_itext (input_text, 0);

  input_text_offset = 0;

  /* Avoid the `\input texinfo' line in HTML output (assuming it starts
     the file).  */
  if (looking_at ("\\input"))
    discard_until ("\n");

  /* Search this file looking for the special string which starts conversion.
     Once found, we may truly begin. */
  while (input_text_offset >= 0)
    {
      input_text_offset =
        search_forward (setfilename_search, input_text_offset);

      if (input_text_offset == 0
          || (input_text_offset > 0
              && input_text[input_text_offset -1] == '\n'))
        break;
      else if (input_text_offset > 0)
        input_text_offset++;
    }

  if (input_text_offset < 0)
    {
      if (!command_output_filename)
        {
#if defined (REQUIRE_SETFILENAME)
          error (_("No `%s' found in `%s'"), setfilename_search, name);
          goto finished;
#else
          command_output_filename = output_name_from_input_name (name);
#endif /* !REQUIRE_SETFILENAME */
        }

      {
        int i, end_of_first_line;

        /* Find the end of the first line in the file. */
        for (i = 0; i < input_text_length - 1; i++)
          if (input_text[i] == '\n')
            break;

        end_of_first_line = i + 1;

        for (i = 0; i < end_of_first_line; i++)
          {
            if ((input_text[i] == '\\') &&
                (strncmp (input_text + i + 1, "input", 5) == 0))
              {
                input_text_offset = i;
                break;
              }
          }
      }
    }
  else
    input_text_offset += strlen (setfilename_search);

  if (!command_output_filename)
    {
      get_until ("\n", &output_filename); /* read rest of line */
      if (html || xml)
        { /* Change any extension to .html or .xml.  */
          char *html_name, *directory_part, *basename_part, *temp;

          canon_white (output_filename);
          directory_part = pathname_part (output_filename);

          basename_part = filename_part (output_filename);

          /* Zap any existing extension.  */
          temp = strrchr (basename_part, '.');
          if (temp)
            *temp = 0;

          /* Construct new filename.  */
          html_name = xmalloc (strlen (directory_part)
                               + strlen (basename_part) + 6);
          strcpy (html_name, directory_part);
          strcat (html_name, basename_part);
          strcat (html_name, html ? ".html" : ".xml");

          /* Replace name from @@setfilename with the html name.  */
          free (output_filename);
          output_filename = html_name;
        }
    }
  else
    {
      if (input_text_offset != -1)
        discard_until ("\n");
      else
        input_text_offset = 0;

      real_output_filename = output_filename = command_output_filename;
      command_output_filename = NULL;  /* for included files or whatever */
    }

  canon_white (output_filename);
  toplevel_output_filename = xstrdup (output_filename);

  if (real_output_filename && strcmp (real_output_filename, "-") == 0)
    {
      if (macro_expansion_filename
          && strcmp (macro_expansion_filename, "-") == 0)
        {
          fprintf (stderr,
  _("%s: Skipping macro expansion to stdout as Info output is going there.\n"),
                   progname);
          macro_expansion_output_stream = NULL;
        }
      real_output_filename = xstrdup (real_output_filename);
      output_stream = stdout;
      splitting = 0;            /* Cannot split when writing to stdout. */
    }
  else
    {
      if (html && splitting)
        {
          if (FILENAME_CMP (output_filename, NULL_DEVICE) == 0
              || FILENAME_CMP (output_filename, ALSO_NULL_DEVICE) == 0)
            splitting = 0;
          else
            output_filename = insert_toplevel_subdirectory (output_filename);
          real_output_filename = xstrdup (output_filename);
        }
      else if (!real_output_filename)
        real_output_filename = expand_filename (output_filename, name);
      else
        real_output_filename = xstrdup (real_output_filename);

      output_stream = fopen (real_output_filename, "w");
    }

  set_current_output_filename (real_output_filename);

  if (xml && !docbook)
    xml_begin_document (filename_part (output_filename));

  if (verbose_mode)
    printf (_("Making %s file `%s' from `%s'.\n"),
            no_headers ? "text"
            : html ? "HTML"
            : xml ? "XML"
            : "info",
            output_filename, input_filename);

  if (output_stream == NULL)
    {
      fs_error (real_output_filename);
      goto finished;
    }

  /* Make the displayable filename from output_filename.  Only the base
     portion of the filename need be displayed. */
  flush_output ();              /* in case there was no @@bye */
  if (output_stream != stdout)
    pretty_output_filename = filename_part (output_filename);
  else
    pretty_output_filename = xstrdup ("stdout");

  /* For this file only, count the number of newlines from the top of
     the file to here.  This way, we keep track of line numbers for
     error reporting.  Line_number starts at 1, since the user isn't
     zero-based. */
  {
    int temp = 0;
    line_number = 1;
    while (temp != input_text_offset)
      if (input_text[temp++] == '\n')
        line_number++;
  }

  /* html fixxme: should output this as trailer on first page.  */
  if (!no_headers && !html && !xml)
    add_word_args (_("This is %s, produced by makeinfo version %s from %s.\n"),
                   output_filename, VERSION, input_filename);

  close_paragraph ();

  if (xml && !docbook)
    {
      /* Just before the real main loop, let's handle the defines.  */
      COMMAND_LINE_DEFINE *temp;

      for (temp = command_line_defines; temp; temp = temp->next)
        {
          handle_variable_internal (temp->action, temp->define);
          free(temp->define);
        }
    }

  reader_loop ();
  if (xml)
    xml_end_document ();


finished:
  discard_insertions (0);
  close_paragraph ();
  flush_file_stack ();

  if (macro_expansion_output_stream)
    {
      fclose (macro_expansion_output_stream);
      if (errors_printed && !force
          && strcmp (macro_expansion_filename, "-") != 0
          && FILENAME_CMP (macro_expansion_filename, NULL_DEVICE) != 0
          && FILENAME_CMP (macro_expansion_filename, ALSO_NULL_DEVICE) != 0)
        {
          fprintf (stderr,
_("%s: Removing macro output file `%s' due to errors; use --force to preserve.\n"),
                   progname, macro_expansion_filename);
          if (unlink (macro_expansion_filename) < 0)
            perror (macro_expansion_filename);
        }
    }

  if (output_stream)
    {
      output_pending_notes ();

      if (html)
        {
          no_indent = 1;
          start_paragraph ();
          add_word ("</body></html>\n");
          close_paragraph ();
        }

      /* maybe we want local variables in info output.  */
      {
        char *trailer = info_trailer ();
	if (!xml && !docbook && trailer)
          {
            if (html)
              insert_string ("<!--");
            insert_string (trailer);
            free (trailer);
            if (html)
              insert_string ("\n-->\n");
          }
      }

      /* Write stuff makeinfo generates after @@bye, ie. info_trailer.  */
      flush_output ();

      if (output_stream != stdout)
        fclose (output_stream);

      /* If validating, then validate the entire file right now. */
      if (validating)
        validate_file (tag_table);

      handle_delayed_writes ();

      if (tag_table)
        {
          tag_table = (TAG_ENTRY *) reverse_list ((GENERIC_LIST *) tag_table);
          if (!no_headers && !html && !STREQ (current_output_filename, "-"))
            write_tag_table (real_output_filename);
        }

      if (splitting && !html && (!errors_printed || force))
        {
          clean_old_split_files (real_output_filename);
          split_file (real_output_filename, split_size);
        }
      else if (errors_printed
               && !force
               && strcmp (real_output_filename, "-") != 0
               && FILENAME_CMP (real_output_filename, NULL_DEVICE) != 0
               && FILENAME_CMP (real_output_filename, ALSO_NULL_DEVICE) != 0)
        { /* If there were errors, and no --force, remove the output.  */
          fprintf (stderr,
  _("%s: Removing output file `%s' due to errors; use --force to preserve.\n"),
                   progname, real_output_filename);
          if (unlink (real_output_filename) < 0)
            perror (real_output_filename);
        }
    }
  free (real_output_filename);
}

/* If enable_encoding is set and @@documentencoding is used, return a
   Local Variables section (as a malloc-ed string) so that Emacs'
   locale features can work.  Else return NULL.  */
char *
info_trailer (void)
{
  char *encoding;

  if (!enable_encoding)
    return NULL;

  encoding = current_document_encoding ();

  if (encoding && *encoding)
    {
#define LV_FMT "\n\037\nLocal Variables:\ncoding: %s\nEnd:\n"
      char *lv = xmalloc (sizeof (LV_FMT) + strlen (encoding));
      sprintf (lv, LV_FMT, encoding);
      free (encoding);
      return lv;
    }

  free (encoding);
  return NULL;
}

void
free_and_clear (char **pointer)
{
  if (*pointer)
    {
      free (*pointer);
      *pointer = NULL;
    }
}

 /* Initialize some state. */
static void
init_internals (void)
{
  free_and_clear (&output_filename);
  free_and_clear (&command);
  free_and_clear (&input_filename);
  free_node_references ();
  free_node_node_references ();
  toc_free ();
  init_insertion_stack ();
  init_brace_stack ();
  current_node = NULL; /* sometimes already freed */
  command_index = 0;
  in_menu = 0;
  in_detailmenu = 0;
  top_node_seen = 0;
  non_top_node_seen = 0;
  node_number = -1;
}

void
init_paragraph (void)
{
  free (output_paragraph);
  output_paragraph = xmalloc (paragraph_buffer_len);
  output_paragraph[0] = 0;
  output_paragraph_offset = 0;
  output_column = 0;
  paragraph_is_open = 0;
  current_indent = 0;
  meta_char_pos = 0;
}

/* This is called from `reader_loop' when we are at the * beginning a
   menu line.  */

static void
handle_menu_entry (void)
{
  char *tem;

  /* Ugh, glean_node_from_menu wants to read the * itself.  */
  input_text_offset--;

  /* Find node name in menu entry and save it in references list for
     later validation.  Use followed_reference type for detailmenu
     references since we don't want to use them for default node pointers.  */
  tem = glean_node_from_menu (1, in_detailmenu
                                 ? followed_reference : menu_reference);

  if (html && tem)
    { /* Start a menu item with the cleaned-up line.  Put an anchor
         around the start text (before `:' or the node name). */
      char *string;

      discard_until ("* ");

      /* The line number was already incremented in reader_loop when we
         saw the newline, and discard_until has now incremented again.  */
      line_number--;

      if (had_menu_commentary)
        {
          add_html_block_elt ("<ul class=\"menu\">\n");
          had_menu_commentary = 0;
          in_paragraph = 0;
        }

      if (in_paragraph)
        {
          add_html_block_elt ("</p>\n");
          add_html_block_elt ("<ul class=\"menu\">\n");
          in_paragraph = 0;
        }

      in_menu_item = 1;

      add_html_block_elt ("<li><a");
      if (next_menu_item_number <= 9)
        {
          add_word(" accesskey=");
          add_word_args("\"%d\"", next_menu_item_number);
          next_menu_item_number++;
        }
      add_word (" href=\"");
      string = expansion (tem, 0);
      add_anchor_name (string, 1);
      add_word ("\">");
      free (string);

      /* The menu item may use macros, so expand them now.  */
      only_macro_expansion++;
      get_until_in_line (1, ":", &string);
      only_macro_expansion--;
      execute_string ("%s", string); /* get escaping done */
      free (string);

      add_word ("</a>");

      if (looking_at ("::"))
        discard_until (":");
      else
        { /* discard the node name */
          get_until_in_line (0, ".", &string);
          free (string);
        }
      input_text_offset++;      /* discard the second colon or the period */

      /* Insert a colon only if there is a description of this menu item.  */
      {
        int save_input_text_offset = input_text_offset;
        int save_line_number = line_number;
        char *test_string;
        get_rest_of_line (0, &test_string);
        if (strlen (test_string) > 0)
          add_word (": ");
        input_text_offset = save_input_text_offset;
        line_number = save_line_number;
      }
    }
  else if (xml && tem)
    {
      xml_start_menu_entry (tem);
    }
  else if (tem)
    { /* For Info output, we can just use the input and the main case in
         reader_loop where we output what comes in.  Just move off the *
         so the next time through reader_loop we don't end up back here.  */
      add_char ('*');
      input_text_offset += 2; /* undo the pointer back-up above.  */
    }

  if (tem)
    free (tem);
}

/* Find the command corresponding to STRING.  If the command is found,
   return a pointer to the data structure.  Otherwise return -1.  */
static COMMAND *
get_command_entry (char *string)
{
  int i;

  for (i = 0; command_table[i].name; i++)
    if (strcmp (command_table[i].name, string) == 0)
      return &command_table[i];

  /* This command is not in our predefined command table.  Perhaps
     it is a user defined command. */
  for (i = 0; i < user_command_array_len; i++)
    if (user_command_array[i] &&
        (strcmp (user_command_array[i]->name, string) == 0))
      return user_command_array[i];

  /* We never heard of this command. */
  return (COMMAND *) -1;
}

/* input_text_offset is right at the command prefix character.
   Read the next token to determine what to do.  Return zero
   if there's no known command or macro after the prefix character.  */
static int
read_command (void)
{
  COMMAND *entry;
  int old_text_offset = input_text_offset++;

  free_and_clear (&command);
  command = read_token ();

  /* Check to see if this command is a macro.  If so, execute it here. */
  {
    MACRO_DEF *def;

    def = find_macro (command);

    if (def)
      {
        /* We disallow recursive use of a macro call.  Inhibit the expansion
           of this macro during the life of its execution. */
        if (!(def->flags & ME_RECURSE))
          def->inhibited = 1;

        executing_macro++;
        execute_macro (def);
        executing_macro--;

        if (!(def->flags & ME_RECURSE))
          def->inhibited = 0;

        return 1;
      }
  }

  if (only_macro_expansion)
    {
      /* Back up to the place where we were called, so the
         caller will have a chance to process this non-macro.  */
      input_text_offset = old_text_offset;
      return 0;
    }

  /* Perform alias expansion */
  command = alias_expand (command);

  if (enclosure_command (command))
    {
      remember_brace (enclosure_expand);
      enclosure_expand (START, output_paragraph_offset, 0);
      return 0;
    }

  entry = get_command_entry (command);
  if (entry == (COMMAND *)-1)
    {
      line_error (_("Unknown command `%s'"), command);
      return 0;
    }

  if (entry->argument_in_braces == BRACE_ARGS)
    remember_brace (entry->proc);
  else if (entry->argument_in_braces == MAYBE_BRACE_ARGS)
    {
      if (curchar () == '{')
        remember_brace (entry->proc);
      else
        { /* No braces, so arg is next char.  */
          int ch;
          int saved_offset = output_paragraph_offset;
          (*(entry->proc)) (START, output_paragraph_offset, 0);

          /* Possibilities left for the next character: @@ (error), }
             (error), whitespace (skip) anything else (normal char).  */
          skip_whitespace ();
          ch = curchar ();
          if (ch == '@@')
            {
           line_error (_("Use braces to give a command as an argument to @@%s"),
               entry->name);
              return 0;
            }
          else if (ch == '}')
            {
              /* Our caller will give the error message, because this }
                 won't match anything.  */
              return 0;
            }

          add_char (ch);
          input_text_offset++;
          (*(entry->proc)) (END, saved_offset, output_paragraph_offset);
          return 1;
        }
    }

  /* Get here if we have BRACE_ARGS, NO_BRACE_ARGS, or MAYBE_BRACE_ARGS
     with braces.  */
  (*(entry->proc)) (START, output_paragraph_offset, 0);
  return 1;
}

/* Okay, we are ready to start the conversion.  Call the reader on
   some text, and fill the text as it is output.  Handle commands by
   remembering things like open braces and the current file position on a
   stack, and when the corresponding close brace is found, you can call
   the function with the proper arguments.  Although the filling isn't
   necessary for HTML, it should do no harm.  */
void
reader_loop (void)
{
  int character;
  int done = 0;

  while (!done)
    {
      if (input_text_offset >= input_text_length)
        break;

      character = curchar ();

      /* If only_macro_expansion, only handle macros and leave
         everything else intact.  */
      if (!only_macro_expansion && !in_fixed_width_font
          && ((!html && !xml) || escape_html)
          && (character == '\'' || character == '`')
          && input_text[input_text_offset + 1] == character)
        {
          if (html)
            {
              input_text_offset += 2;
              add_word (character == '`' ? "&ldquo;" : "&rdquo;");
              continue;
            }
          else if (xml)
            {
              input_text_offset += 2;
              xml_insert_entity (character == '`' ? "ldquo" : "rdquo");
              continue;
            }
          else
            {
              input_text_offset++;
              character = '"';
            }
        }

      /* Convert --- to --.  */
      if (!only_macro_expansion && character == '-' && !in_fixed_width_font
          && ((!html && !xml) || escape_html))
        {
          int dash_count = 0;

          /* Get the number of consequtive dashes.  */
          while (input_text[input_text_offset] == '-')
            {
              dash_count++;
              input_text_offset++;
            }

          /* Eat one dash.  */
          dash_count--;

          if (html || xml)
            {
              if (dash_count == 0)
                add_char ('-');
              else
                while (dash_count > 0)
                  {
                    if (dash_count >= 2)
                      {
                        if (html)
                          add_word ("&mdash;");
                        else
                          xml_insert_entity ("mdash");
                        dash_count -= 2;
                      }
                    else if (dash_count >= 1)
                      {
                        if (html)
                          add_word ("&ndash;");
                        else
                          xml_insert_entity ("ndash");
                        dash_count--;
                      }
                  }
            }
          else
            {
              add_char ('-');
              while (--dash_count > 0)
                add_char ('-');
            }

          continue;
        }

      /* If this is a whitespace character, then check to see if the line
         is blank.  If so, advance to the carriage return. */
      if (!only_macro_expansion && whitespace (character))
        {
          int i = input_text_offset + 1;

          while (i < input_text_length && whitespace (input_text[i]))
            i++;

          if (i == input_text_length || input_text[i] == '\n')
            {
              if (i == input_text_length)
                i--;

              input_text_offset = i;
              character = curchar ();
            }
        }

      if (character == '\n')
        line_number++;

      switch (character)
        {
        case '*': /* perhaps we are at a menu */
          /* We used to check for this in the \n case but an @@c in a
             menu swallows its newline, so check here instead.  */
          if (!only_macro_expansion && in_menu
              && input_text_offset + 1 < input_text_length
              && input_text[input_text_offset-1] == '\n')
            handle_menu_entry ();
          else
            { /* Duplicate code from below, but not worth twisting the
                 fallthroughs to get down there.  */
              add_char (character);
              input_text_offset++;
            }
          break;

        /* Escapes for HTML unless we're outputting raw HTML.  Do
           this always, even if SGML rules don't require it since
           that's easier and safer for non-conforming browsers. */
        case '&':
          if (html && escape_html)
            add_word ("&amp;");
          else
            add_char (character);
          input_text_offset++;
          break;

        case '<':
          if (html && escape_html)
            add_word ("&lt;");
          else if (xml && escape_html)
            xml_insert_entity ("lt");
          else
            add_char (character);
          input_text_offset++;
          break;

        case '>':
          if (html && escape_html)
            add_word ("&gt;");
          else if (xml && escape_html)
            xml_insert_entity ("gt");
          else
            add_char (character);
          input_text_offset++;
          break;

        case COMMAND_PREFIX: /* @@ */
          if (read_command () || !only_macro_expansion)
            break;

        /* FALLTHROUGH (usually) */
        case '{':
          /* Special case.  We're not supposed to see this character by itself.
             If we do, it means there is a syntax error in the input text.
             Report the error here, but remember this brace on the stack so
             we can ignore its partner. */
          if (!only_macro_expansion)
            {
              if (command && !STREQ (command, "math"))
                {
                  line_error (_("Misplaced %c"), '{');
                  remember_brace (misplaced_brace);
                }
              else
                /* We don't mind `extra' braces inside @@math.  */
                remember_brace (cm_no_op);
              /* remember_brace advances input_text_offset.  */
              break;
            }

        /* FALLTHROUGH (usually) */
        case '}':
          if (!only_macro_expansion)
            {
              pop_and_call_brace ();
              input_text_offset++;
              break;
            }

        /* FALLTHROUGH (usually) */
        default:
          add_char (character);
          input_text_offset++;
        }
    }
  if (macro_expansion_output_stream && !only_macro_expansion)
    maybe_write_itext (input_text, input_text_offset);
}

static void
init_brace_stack (void)
{
  brace_stack = NULL;
}

/* Remember the current output position here.  Save PROC
   along with it so you can call it later. */
static void
remember_brace_1 (COMMAND_FUNCTION (*proc), int position)
{
  BRACE_ELEMENT *new = xmalloc (sizeof (BRACE_ELEMENT));
  new->next = brace_stack;
  new->proc = proc;
  new->command = command ? xstrdup (command) : "";
  new->pos = position;
  new->line = line_number;
  new->in_fixed_width_font = in_fixed_width_font;
  brace_stack = new;
}

static void
remember_brace (COMMAND_FUNCTION (*proc))
{
  if (curchar () != '{')
    line_error (_("%c%s expected braces"), COMMAND_PREFIX, command);
  else
    input_text_offset++;
  remember_brace_1 (proc, output_paragraph_offset);
}

/* Pop the top of the brace stack, and call the associated function
   with the args END and POS. */
static void
pop_and_call_brace (void)
{
  if (brace_stack == NULL)
    {
      line_error (_("Unmatched }"));
      return;
    }

  {
    BRACE_ELEMENT *temp;

    int pos = brace_stack->pos;
    COMMAND_FUNCTION *proc = brace_stack->proc;
    in_fixed_width_font = brace_stack->in_fixed_width_font;

    /* Reset current command, so the proc can know who it is.  This is
       used in cm_accent.  */
    command = brace_stack->command;

    temp = brace_stack->next;
    free (brace_stack);
    brace_stack = temp;

    (*proc) (END, pos, output_paragraph_offset);
  }
}

/* Shift all of the markers in `brace_stack' by AMOUNT. */
static void
adjust_braces_following (int here, int amount)
{
  BRACE_ELEMENT *stack = brace_stack;

  while (stack)
    {
      if (stack->pos >= here)
        stack->pos += amount;
      stack = stack->next;
    }
}

/* Return the string which invokes PROC; a pointer to a function.
   Always returns the first function in the command table if more than
   one matches PROC.  */
static const char *
find_proc_name (COMMAND_FUNCTION (*proc))
{
  int i;

  for (i = 0; command_table[i].name; i++)
    if (proc == command_table[i].proc)
      return command_table[i].name;
  return _("NO_NAME!");
}

/* You call discard_braces () when you shouldn't have any braces on the stack.
   I used to think that this happens for commands that don't take arguments
   in braces, but that was wrong because of things like @@code{foo @@@@}.  So now
   I only detect it at the beginning of nodes. */
void
discard_braces (void)
{
  if (!brace_stack)
    return;

  while (brace_stack)
    {
      if (brace_stack->proc != misplaced_brace)
        {
          const char *proc_name;

          proc_name = find_proc_name (brace_stack->proc);
          file_line_error (input_filename, brace_stack->line,
                           _("%c%s missing close brace"), COMMAND_PREFIX,
                           proc_name);
          pop_and_call_brace ();
        }
      else
        {
          BRACE_ELEMENT *temp;
          temp = brace_stack->next;
          free (brace_stack);
          brace_stack = temp;
        }
    }
}

static int
get_char_len (int character)
{
  /* Return the printed length of the character. */
  int len;

  switch (character)
    {
    case '\t':
      len = (output_column + 8) & 0xf7;
      if (len > fill_column)
        len = fill_column - output_column;
      else
        len = len - output_column;
      break;

    case '\n':
      len = fill_column - output_column;
      break;

    default:
      /* ASCII control characters appear as two characters in the output
         (e.g., ^A).  But characters with the high bit set are just one
         on suitable terminals, so don't count them as two for line
         breaking purposes.  */
      if (0 <= character && character < ' ')
        len = 2;
      else
        len = 1;
    }
  return len;
}

void
#if defined (VA_FPRINTF) && __STDC__
add_word_args (const char *format, ...)
#else
add_word_args (format, va_alist)
    const char *format;
    va_dcl
#endif
{
  char buffer[2000]; /* xx no fixed limits */
#ifdef VA_FPRINTF
  va_list ap;
#endif

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (buffer, format, ap);
#else
  sprintf (buffer, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
  add_word (buffer);
}

/* Add STRING to output_paragraph. */
void
add_word (char *string)
{
  while (*string)
    add_char (*string++);
}

/* Like add_word, but inhibits conversion of whitespace into &nbsp;.
   Use this to output HTML directives with embedded blanks, to make
   them @@w-safe.  */
void
add_html_elt (char *string)
{
  in_html_elt++;
  add_word (string);
  in_html_elt--;
}

/* These two functions below, add_html_block_elt and add_html_block_elt_args,
   are mixtures of add_html_elt and add_word_args.  They inform makeinfo that
   the current HTML element being inserted should not be enclosed in a <p>
   element.  */
void
add_html_block_elt (char *string)
{
  in_html_block_level_elt++;
  add_word (string);
  in_html_block_level_elt--;
}

void
#if defined (VA_FPRINTF) && __STDC__
add_html_block_elt_args (const char *format, ...)
#else
add_html_block_elt_args (format, va_alist)
    const char *format;
    va_dcl
#endif
{
  char buffer[2000]; /* xx no fixed limits */
#ifdef VA_FPRINTF
  va_list ap;
#endif

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (buffer, format, ap);
#else
  sprintf (buffer, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
  add_html_block_elt (buffer);
}

/* Here is another awful kludge, used in add_char.  Ordinarily, macro
   expansions take place in the body of the document, and therefore we
   should html_output_head when we see one.  But there's an exception: a
   macro call might take place within @@copying, and that does not start
   the real output, even though we fully expand the copying text.

   So we need to be able to check if we are defining the @@copying text.
   We do this by looking back through the insertion stack.  */
static int
defining_copying (void)
{
  INSERTION_ELT *i;
  for (i = insertion_stack; i; i = i->next)
    {
      if (i->insertion == copying)
        return 1;
    }
  return 0;
}


/* Add the character to the current paragraph.  If filling_enabled is
   nonzero, then do filling as well. */
void
add_char (int character)
{
  if (xml)
    {
      xml_add_char (character);
      return;
    }

  /* If we are avoiding outputting headers, and we are currently
     in a menu, then simply return.  But if we're only expanding macros,
     then we're being called from glean_node_from_menu to try to
     remember a menu reference, and we need that so we can do defaulting.  */
  if (no_headers && !only_macro_expansion && (in_menu || in_detailmenu))
    return;

  /* If we are adding a character now, then we don't have to
     ignore close_paragraph () calls any more. */
  if (must_start_paragraph && character != '\n')
    {
      must_start_paragraph = 0;
      line_already_broken = 0;  /* The line is no longer broken. */
      if (current_indent > output_column)
        {
          indent (current_indent - output_column);
          output_column = current_indent;
        }
    }

  if (non_splitting_words
      && !(html && in_html_elt)
      && strchr (" \t\n", character))
    {
      if (html || docbook)
        { /* Seems cleaner to use &nbsp; than an 8-bit char.  */
          int saved_escape_html = escape_html;
          escape_html = 0;
          add_word ("&nbsp");
          escape_html = saved_escape_html;
          character = ';';
        }
      else
        character = META (' '); /* unmeta-d in flush_output */
    }

  insertion_paragraph_closed = 0;

  switch (character)
    {
    case '\n':
      if (!filling_enabled && !(html && (in_menu || in_detailmenu)))
        {
          insert ('\n');

          if (force_flush_right)
            {
              close_paragraph ();
              /* Hack to force single blank lines out in this mode. */
              flush_output ();
            }

          output_column = 0;

          if (!no_indent && paragraph_is_open)
            indent (output_column = current_indent);
          break;
        }
      else if (end_of_sentence_p ())
        /* CHARACTER is newline, and filling is enabled. */
        {
          insert (' ');
          output_column++;
          last_inserted_character = character;
        }

      if (last_char_was_newline)
        {
          if (html)
            last_char_was_newline++;
          close_paragraph ();
          pending_indent = 0;
        }
      else
        {
          last_char_was_newline = 1;
          if (html)
            insert ('\n');
          else
            insert (' ');
          output_column++;
        }
      break;

    default: /* not at newline */
      {
        int len = get_char_len (character);
        int suppress_insert = 0;

        if ((character == ' ') && (last_char_was_newline))
          {
            if (!paragraph_is_open)
              {
                pending_indent++;
                return;
              }
          }

        /* This is sad, but it seems desirable to not force any
           particular order on the front matter commands.  This way,
           the document can do @@settitle, @@documentlanguage, etc, in
           any order and with any omissions, and we'll still output
           the html <head> `just in time'.  */
        if ((executing_macro || !executing_string)
            && !only_macro_expansion
            && html && !html_output_head_p && !defining_copying ())
          html_output_head ();

        if (!paragraph_is_open)
          {
            start_paragraph ();
            /* If the paragraph is supposed to be indented a certain
               way, then discard all of the pending whitespace.
               Otherwise, we let the whitespace stay. */
            if (!paragraph_start_indent)
              indent (pending_indent);
            pending_indent = 0;

            /* This check for in_html_block_level_elt prevents <p> from being
               inserted when we already have html markup starting a paragraph,
               as with <ul> and <h1> and the like.  */
            if (html && !in_html_block_level_elt)
              {
                if ((in_menu || in_detailmenu) && in_menu_item)
                  {
                    insert_string ("</li></ul>\n");
                    in_menu_item = 0;
                  }
                insert_string ("<p>");
                in_paragraph = 1;
                adjust_braces_following (0, 3); /* adjust for <p> */
              }
          }

        output_column += len;
        if (output_column > fill_column)
          {
            if (filling_enabled && !html)
              {
                int temp = output_paragraph_offset;
                while (--temp > 0 && output_paragraph[temp] != '\n')
                  {
                    /* If we have found a space, we have the place to break
                       the line. */
                    if (output_paragraph[temp] == ' ')
                      {
                        /* Remove trailing whitespace from output. */
                        while (temp && whitespace (output_paragraph[temp - 1]))
                          temp--;

                        /* If we went back all the way to the newline of the
                           preceding line, it probably means that the word we
                           are adding is itself wider than the space that the
                           indentation and the fill_column let us use.  In
                           that case, do NOT insert another newline, since it
                           won't help.  Just indent to current_indent and
                           leave it alone, since that's the most we can do.  */
                        if (temp && output_paragraph[temp - 1] != '\n')
                          output_paragraph[temp++] = '\n';

                        /* We have correctly broken the line where we want
                           to.  What we don't want is spaces following where
                           we have decided to break the line.  We get rid of
                           them. */
                        {
                          int t1 = temp;

                          for (;; t1++)
                            {
                              if (t1 == output_paragraph_offset)
                                {
                                  if (whitespace (character))
                                    suppress_insert = 1;
                                  break;
                                }
                              if (!whitespace (output_paragraph[t1]))
                                break;
                            }

                          if (t1 != temp)
                            {
                              adjust_braces_following (temp, (- (t1 - temp)));
                              memmove (&output_paragraph[temp],
                                       &output_paragraph[t1],
                                       output_paragraph_offset - t1);
                              output_paragraph_offset -= (t1 - temp);
                            }
                        }

                        /* Filled, but now indent if that is right. */
                        if (indented_fill && current_indent > 0)
                          {
                            int buffer_len = ((output_paragraph_offset - temp)
                                              + current_indent);
                            char *temp_buffer = xmalloc (buffer_len);
                            int indentation = 0;

                            /* We have to shift any markers that are in
                               front of the wrap point. */
                            adjust_braces_following (temp, current_indent);

                            while (current_indent > 0 &&
                                   indentation != current_indent)
                              temp_buffer[indentation++] = ' ';

                            memcpy ((char *) &temp_buffer[current_indent],
                                     (char *) &output_paragraph[temp],
                                     buffer_len - current_indent);

                            if (output_paragraph_offset + buffer_len
                                >= paragraph_buffer_len)
                              {
                                unsigned char *tt = xrealloc
                                  (output_paragraph,
                                   (paragraph_buffer_len += buffer_len));
                                output_paragraph = tt;
                              }
                            memcpy ((char *) &output_paragraph[temp],
                                     temp_buffer, buffer_len);
                            output_paragraph_offset += current_indent;
                            free (temp_buffer);
                          }
                        output_column = 0;
                        while (temp < output_paragraph_offset)
                          output_column +=
                            get_char_len (output_paragraph[temp++]);
                        output_column += len;
                        break;
                      }
                  }
              }
          }

        if (!suppress_insert)
          {
            insert (character);
            last_inserted_character = character;
          }
        last_char_was_newline = 0;
        line_already_broken = 0;
      }
    }
}

/* Add a character and store its position in meta_char_pos.  */
void
add_meta_char (int character)
{
  meta_char_pos = output_paragraph_offset;
  add_char (character);
}

/* Insert CHARACTER into `output_paragraph'. */
void
insert (int character)
{
  /* We don't want to strip trailing whitespace in multitables.  Otherwise
     horizontal separators confuse the font locking in Info mode in Emacs,
     because it looks like a @@subsection.  Adding a trailing space to those
     lines fixes it.  */
  if (character == '\n' && !html && !xml && !multitable_active)
    {
      while (output_paragraph_offset
	     && whitespace (output_paragraph[output_paragraph_offset-1]))
	output_paragraph_offset--;
    }

  output_paragraph[output_paragraph_offset++] = character;
  if (output_paragraph_offset == paragraph_buffer_len)
    {
      output_paragraph =
        xrealloc (output_paragraph, (paragraph_buffer_len += 100));
    }
}

/* Insert the null-terminated string STRING into `output_paragraph'.  */
void
insert_string (const char *string)
{
  while (*string)
    insert (*string++);
}


/* Sentences might have these characters after the period (or whatever).  */
#define POST_SENTENCE(c) ((c) == ')' || (c) == '\'' || (c) == '"' \
                          || (c) == ']')

/* Return true if at an end-of-sentence character, possibly followed by
   post-sentence punctuation to ignore.  */
static int
end_of_sentence_p (void)
{
  int loc = output_paragraph_offset - 1;

  /* If nothing has been output, don't check output_paragraph[-1].  */
  if (loc < 0)
    return 0;

  /* A post-sentence character that is at meta_char_pos is not really
     a post-sentence character; it was produced by a markup such as
     @@samp.  We don't want the period inside @@samp to be treated as a
     sentence ender. */
  while (loc > 0
         && loc != meta_char_pos && POST_SENTENCE (output_paragraph[loc]))
    loc--;
  return loc != meta_char_pos && sentence_ender (output_paragraph[loc]);
}


/* Remove upto COUNT characters of whitespace from the
   the current output line.  If COUNT is less than zero,
   then remove until none left. */
void
kill_self_indent (int count)
{
  /* Handle infinite case first. */
  if (count < 0)
    {
      output_column = 0;
      while (output_paragraph_offset)
        {
          if (whitespace (output_paragraph[output_paragraph_offset - 1]))
            output_paragraph_offset--;
          else
            break;
        }
    }
  else
    {
      while (output_paragraph_offset && count--)
        if (whitespace (output_paragraph[output_paragraph_offset - 1]))
          output_paragraph_offset--;
        else
          break;
    }
}

/* Nonzero means do not honor calls to flush_output (). */
static int flushing_ignored = 0;

/* Prevent calls to flush_output () from having any effect. */
void
inhibit_output_flushing (void)
{
  flushing_ignored++;
}

/* Allow calls to flush_output () to write the paragraph data. */
void
uninhibit_output_flushing (void)
{
  flushing_ignored--;
}

void
flush_output (void)
{
  int i;

  if (!output_paragraph_offset || flushing_ignored)
    return;

  for (i = 0; i < output_paragraph_offset; i++)
    {
      if (output_paragraph[i] == '\n')
        {
          output_line_number++;
          node_line_number++;
        }

      /* If we turned on the 8th bit for a space inside @@w, turn it
         back off for output.  This might be problematic, since the
         0x80 character may be used in 8-bit character sets.  Sigh.
         In any case, don't do this for HTML, since the nbsp character
         is valid input and must be passed along to the browser.  */
      if (!html && (output_paragraph[i] & meta_character_bit))
        {
          int temp = UNMETA (output_paragraph[i]);
          if (temp == ' ')
            output_paragraph[i] &= 0x7f;
        }
    }

  fwrite (output_paragraph, 1, output_paragraph_offset, output_stream);

  output_position += output_paragraph_offset;
  output_paragraph_offset = 0;
  meta_char_pos = 0;
}

/* How to close a paragraph controlling the number of lines between
   this one and the last one. */

/* Paragraph spacing is controlled by this variable.  It is the number of
   blank lines that you wish to appear between paragraphs.  A value of
   1 creates a single blank line between paragraphs. */
int paragraph_spacing = DEFAULT_PARAGRAPH_SPACING;

static void
close_paragraph_with_lines (int lines)
{
  int old_spacing = paragraph_spacing;
  paragraph_spacing = lines;
  close_paragraph ();
  paragraph_spacing = old_spacing;
}

/* Close the current paragraph, leaving no blank lines between them. */
void
close_single_paragraph (void)
{
  close_paragraph_with_lines (0);
}

/* Close a paragraph after an insertion has ended. */
void
close_insertion_paragraph (void)
{
  if (!insertion_paragraph_closed)
    {
      /* Close the current paragraph, breaking the line. */
      close_single_paragraph ();

      /* Start a new paragraph, with the correct indentation for the now
         current insertion level (one above the one that we are ending). */
      start_paragraph ();

      /* Tell `close_paragraph' that the previous line has already been
         broken, so it should insert one less newline. */
      line_already_broken = 1;

      /* Tell functions such as `add_char' we've already found a newline. */
      ignore_blank_line ();
    }
  else
    {
      /* If the insertion paragraph is closed already, then we are seeing
         two `@@end' commands in a row.  Note that the first one we saw was
         handled in the first part of this if-then-else clause, and at that
         time `start_paragraph' was called, partially to handle the proper
         indentation of the current line.  However, the indentation level
         may have just changed again, so we may have to outdent the current
         line to the new indentation level. */
      if (current_indent < output_column)
        kill_self_indent (output_column - current_indent);
    }

  insertion_paragraph_closed = 1;
}

/* Close the currently open paragraph. */
void
close_paragraph (void)
{
  int i;

  /* We don't need these newlines in XML and Docbook outputs for
     paragraph seperation.  We have <para> element for that.  */
  if (xml)
    return;

  /* The insertion paragraph is no longer closed. */
  insertion_paragraph_closed = 0;

  if (paragraph_is_open && !must_start_paragraph)
    {
      int tindex = output_paragraph_offset;

      /* Back up to last non-newline/space character, forcing all such
         subsequent characters to be newlines.  This isn't strictly
         necessary, but a couple of functions use the presence of a newline
         to make decisions. */
      for (tindex = output_paragraph_offset - 1; tindex >= 0; --tindex)
        {
          int c = output_paragraph[tindex];

          if (c == ' '|| c == '\n')
            output_paragraph[tindex] = '\n';
          else
            break;
        }

      /* All trailing whitespace is ignored. */
      output_paragraph_offset = ++tindex;

      /* Break the line if that is appropriate. */
      if (paragraph_spacing >= 0)
        insert ('\n');

      /* Add as many blank lines as is specified in `paragraph_spacing'. */
      if (!force_flush_right)
        {
          for (i = 0; i < (paragraph_spacing - line_already_broken); i++)
            {
              insert ('\n');
              /* Don't need anything extra for HTML in usual case of no
                 extra paragraph spacing.  */
              if (html && i > 0)
                insert_string ("<br>");
            }
        }

      /* If we are doing flush right indentation, then do it now
         on the paragraph (really a single line). */
      if (force_flush_right)
        do_flush_right_indentation ();

      flush_output ();
      paragraph_is_open = 0;
      no_indent = 0;
      output_column = 0;
    }

  ignore_blank_line ();
}

/* Make the last line just read look as if it were only a newline. */
void
ignore_blank_line (void)
{
  last_inserted_character = '\n';
  last_char_was_newline = 1;
}

/* Align the end of the text in output_paragraph with fill_column. */
static void
do_flush_right_indentation (void)
{
  char *temp;
  int temp_len;

  kill_self_indent (-1);

  if (output_paragraph[0] != '\n')
    {
      output_paragraph[output_paragraph_offset] = 0;

      if (output_paragraph_offset < fill_column)
        {
          int i;

          if (fill_column >= paragraph_buffer_len)
            output_paragraph =
              xrealloc (output_paragraph,
                        (paragraph_buffer_len += fill_column));

          temp_len = strlen ((char *)output_paragraph);
          temp = xmalloc (temp_len + 1);
          memcpy (temp, (char *)output_paragraph, temp_len);

          for (i = 0; i < fill_column - output_paragraph_offset; i++)
            output_paragraph[i] = ' ';

          memcpy ((char *)output_paragraph + i, temp, temp_len);
          free (temp);
          output_paragraph_offset = fill_column;
          adjust_braces_following (0, i);
        }
    }
}

/* Begin a new paragraph. */
void
start_paragraph (void)
{
  /* First close existing one. */
  if (paragraph_is_open)
    close_paragraph ();

  /* In either case, the insertion paragraph is no longer closed. */
  insertion_paragraph_closed = 0;

  /* However, the paragraph is open! */
  paragraph_is_open = 1;

  /* If we MUST_START_PARAGRAPH, that simply means that start_paragraph ()
     had to be called before we would allow any other paragraph operations
     to have an effect. */
  if (!must_start_paragraph)
    {
      int amount_to_indent = 0;

      /* If doing indentation, then insert the appropriate amount. */
      if (!no_indent)
        {
          if (inhibit_paragraph_indentation)
            {
              amount_to_indent = current_indent;
              if (inhibit_paragraph_indentation < 0)
                inhibit_paragraph_indentation++;
            }
          else if (paragraph_start_indent < 0)
            amount_to_indent = current_indent;
          else
            amount_to_indent = current_indent + paragraph_start_indent;

          if (amount_to_indent >= output_column)
            {
              amount_to_indent -= output_column;
              indent (amount_to_indent);
              output_column += amount_to_indent;
            }
        }
    }
  else
    must_start_paragraph = 0;
}

/* Insert the indentation specified by AMOUNT. */
void
indent (int amount)
{
  /* For every START_POS saved within the brace stack which will be affected
     by this indentation, bump that start pos forward. */
  adjust_braces_following (output_paragraph_offset, amount);

  while (--amount >= 0)
    insert (' ');
}

/* Search forward for STRING in input_text.
   FROM says where where to start. */
int
search_forward (char *string, int from)
{
  int len = strlen (string);

  while (from < input_text_length)
    {
      if (strncmp (input_text + from, string, len) == 0)
        return from;
      from++;
    }
  return -1;
}

/* search_forward until n characters.  */
int
search_forward_until_pos (char *string, int from, int end_pos)
{
  int save_input_text_length = input_text_length;
  input_text_length = end_pos;

  from = search_forward (string, from);

  input_text_length = save_input_text_length;

  return from;
}

/* Return next non-whitespace and non-cr character.  */
int
next_nonwhitespace_character (void)
{
  /* First check the current input_text.  Start from the next char because
     we already have input_text[input_text_offset] in ``current''.  */
  int pos = input_text_offset + 1;

  while (pos < input_text_length)
    {
      if (!cr_or_whitespace(input_text[pos]))
        return input_text[pos];
      pos++;
    }

  { /* Can't find a valid character, so go through filestack
       in case we are doing @@include or expanding a macro.  */
    FSTACK *tos = filestack;

    while (tos)
      {
        int tmp_input_text_length = filestack->size;
        int tmp_input_text_offset = filestack->offset;
        char *tmp_input_text = filestack->text;

        while (tmp_input_text_offset < tmp_input_text_length)
          {
            if (!cr_or_whitespace(tmp_input_text[tmp_input_text_offset]))
              return tmp_input_text[tmp_input_text_offset];
            tmp_input_text_offset++;
          }

        tos = tos->next;
      }
  }

  return -1;
}

/* An external image is a reference, kind of.  The parsing is (not
   coincidentally) similar, anyway.  */
void
cm_image (int arg)
{
  char *name_arg, *w_arg, *h_arg, *alt_arg, *ext_arg;

  if (arg == END)
    return;

  name_arg = get_xref_token (1); /* expands all macros in image */
  w_arg = get_xref_token (0);
  h_arg = get_xref_token (0);
  alt_arg = get_xref_token (1); /* expands all macros in alt text */
  ext_arg = get_xref_token (0);

  if (*name_arg)
    {
      struct stat file_info;
      char *pathname = NULL;
      char *fullname = xmalloc (strlen (name_arg)
                       + (ext_arg && *ext_arg ? strlen (ext_arg) + 1: 4) + 1);

      if (ext_arg && *ext_arg)
        {
          sprintf (fullname, "%s%s", name_arg, ext_arg);
          if (access (fullname, R_OK) != 0)
            pathname = get_file_info_in_path (fullname, include_files_path,
                                              &file_info);

	  if (pathname == NULL)
	    {
	      /* Backwards compatibility (4.6 <= version < 4.7):
		 try prefixing @@image's EXTENSION parameter with a period. */
	      sprintf (fullname, "%s.%s", name_arg, ext_arg);
	      if (access (fullname, R_OK) != 0)
		pathname = get_file_info_in_path (fullname, include_files_path,
						  &file_info);
	    }
        }
      else
        {
          sprintf (fullname, "%s.png", name_arg);
          if (access (fullname, R_OK) != 0) {
            pathname = get_file_info_in_path (fullname,
                                              include_files_path, &file_info);
            if (pathname == NULL) {
              sprintf (fullname, "%s.jpg", name_arg);
              if (access (fullname, R_OK) != 0) {
                sprintf (fullname, "%s.gif", name_arg);
                if (access (fullname, R_OK) != 0) {
                  pathname = get_file_info_in_path (fullname,
                                               include_files_path, &file_info);
                }
              }
            }
          }
        }

      if (html)
        {
          int image_in_div = 0;

          if (pathname == NULL && access (fullname, R_OK) != 0)
            {
              line_error(_("@@image file `%s' (for HTML) not readable: %s"),
                             fullname, strerror (errno));
              return;
            }
          if (pathname != NULL && access (pathname, R_OK) != 0)
            {
              line_error (_("No such file `%s'"),
                          fullname);
              return;
            }

          if (!paragraph_is_open)
            {
              add_html_block_elt ("<div class=\"block-image\">");
              image_in_div = 1;
            }

          add_html_elt ("<img src=");
          add_word_args ("\"%s\"", fullname);
          add_html_elt (" alt=");
          add_word_args ("\"%s\">", 
              escape_string (*alt_arg ? text_expansion (alt_arg) : fullname));

          if (image_in_div)
            add_html_block_elt ("</div>");
        }
      else if (xml && docbook)
        xml_insert_docbook_image (name_arg);
      else if (xml)
        {
          extern int xml_in_para;
          extern int xml_no_para;
          int elt = xml_in_para ? INLINEIMAGE : IMAGE;

          if (!xml_in_para)
            xml_no_para++;

          xml_insert_element_with_attribute (elt,
              START, "width=\"%s\" height=\"%s\" name=\"%s\" extension=\"%s\"",
              w_arg, h_arg, name_arg, ext_arg);
          xml_insert_element (IMAGEALTTEXT, START);
          execute_string ("%s", alt_arg);
          xml_insert_element (IMAGEALTTEXT, END);
          xml_insert_element (elt, END);

          if (!xml_in_para)
            xml_no_para--;
        }
      else
        { /* Try to open foo.EXT or foo.txt.  */
          FILE *image_file;
          char *txtpath = NULL;
          char *txtname = xmalloc (strlen (name_arg)
                                   + (ext_arg && *ext_arg
                                      ? strlen (ext_arg) : 4) + 1);
          strcpy (txtname, name_arg);
          strcat (txtname, ".txt");
          image_file = fopen (txtname, "r");
          if (image_file == NULL)
            {
              txtpath = get_file_info_in_path (txtname,
                                               include_files_path, &file_info);
              if (txtpath != NULL)
                image_file = fopen (txtpath, "r");
            }

          if (image_file != NULL
              || access (fullname, R_OK) == 0
              || (pathname != NULL && access (pathname, R_OK) == 0))
            {
              int ch;
              int save_inhibit_indentation = inhibit_paragraph_indentation;
              int save_filling_enabled = filling_enabled;
              int image_in_brackets = paragraph_is_open;

              /* Write magic ^@@^H[image ...^@@^H] cookie in the info file, if
                 there's an accompanying bitmap.  Otherwise just include the
                 text image.  In the plaintext output, always include the text
                 image without the magic cookie.  */
              int use_magic_cookie = !no_headers
                && access (fullname, R_OK) == 0 && !STREQ (fullname, txtname);

              inhibit_paragraph_indentation = 1;
              filling_enabled = 0;
              last_char_was_newline = 0;

              if (use_magic_cookie)
                {
                  add_char ('\0');
                  add_word ("\010[image");

                  if (access (fullname, R_OK) == 0
                      || (pathname != NULL && access (pathname, R_OK) == 0))
                    add_word_args (" src=\"%s\"", fullname);

                  if (*alt_arg)
                    add_word_args (" alt=\"%s\"", alt_arg);
                }

              if (image_file != NULL)
                {
                  if (use_magic_cookie)
                    add_word (" text=\"");

                  if (image_in_brackets)
                    add_char ('[');

                  /* Maybe we need to remove the final newline if the image
                     file is only one line to allow in-line images.  On the
                     other hand, they could just make the file without a
                     final newline.  */
                  while ((ch = getc (image_file)) != EOF)
                    {
                      if (use_magic_cookie && (ch == '"' || ch == '\\'))
                        add_char ('\\');
                      add_char (ch);
                    }

                  if (image_in_brackets)
                    add_char (']');
                  
                  if (use_magic_cookie)
                    add_char ('"');

                  if (fclose (image_file) != 0)
                    perror (txtname);
                }

              if (use_magic_cookie)
                {
                  add_char ('\0');
                  add_word ("\010]");
                }

              inhibit_paragraph_indentation = save_inhibit_indentation;
              filling_enabled = save_filling_enabled;
            }
          else
            warning (_("@@image file `%s' (for text) unreadable: %s"),
                        txtname, strerror (errno));
        }

      free (fullname);
      if (pathname)
        free (pathname);
    }
  else
    line_error (_("@@image missing filename argument"));

  if (name_arg)
    free (name_arg);
  if (w_arg)
    free (w_arg);
  if (h_arg)
    free (h_arg);
  if (alt_arg)
    free (alt_arg);
  if (ext_arg)
    free (ext_arg);
}

/* Conditionals.  */

/* A structure which contains `defined' variables. */
typedef struct defines {
  struct defines *next;
  char *name;
  char *value;
} DEFINE;

/* The linked list of `set' defines. */
DEFINE *defines = NULL;

/* Add NAME to the list of `set' defines. */
static void
set (char *name, char *value)
{
  DEFINE *temp;

  for (temp = defines; temp; temp = temp->next)
    if (strcmp (name, temp->name) == 0)
      {
        free (temp->value);
        temp->value = xstrdup (value);
        return;
      }

  temp = xmalloc (sizeof (DEFINE));
  temp->next = defines;
  temp->name = xstrdup (name);
  temp->value = xstrdup (value);
  defines = temp;

  if (xml && !docbook)
    {
      xml_insert_element_with_attribute (SETVALUE, START, "name=\"%s\"", name);
      execute_string ("%s", value);
      xml_insert_element (SETVALUE, END);
    }
}

/* Remove NAME from the list of `set' defines. */
static void
clear (char *name)
{
  DEFINE *temp, *last;

  last = NULL;
  temp = defines;

  while (temp)
    {
      if (strcmp (temp->name, name) == 0)
        {
          if (last)
            last->next = temp->next;
          else
            defines = temp->next;

          free (temp->name);
          free (temp->value);
          free (temp);
          break;
        }
      last = temp;
      temp = temp->next;
    }

  if (xml && !docbook)
    {
      xml_insert_element_with_attribute (CLEARVALUE, START, "name=\"%s\"", name);
      xml_insert_element (CLEARVALUE, END);
    }
}

/* Return the value of NAME.  The return value is NULL if NAME is unset. */
static char *
set_p (char *name)
{
  DEFINE *temp;

  for (temp = defines; temp; temp = temp->next)
    if (strcmp (temp->name, name) == 0)
      return temp->value;

  return NULL;
}

/* Create a variable whose name appears as the first word on this line. */
void
cm_set (void)
{
  handle_variable (SET);
}

/* Remove a variable whose name appears as the first word on this line. */
void
cm_clear (void)
{
  handle_variable (CLEAR);
}

void
cm_ifset (void)
{
  handle_variable (IFSET);
}

void
cm_ifclear (void)
{
  handle_variable (IFCLEAR);
}

/* This command takes braces, but we parse the contents specially, so we
   don't use the standard brace popping code.

   The syntax @@ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands
   if ARG1 and ARG2 caselessly string compare to the same string, otherwise,
   it produces no output. */
void
cm_ifeq (void)
{
  char **arglist;

  arglist = get_brace_args (0);

  if (arglist)
    {
      if (array_len (arglist) > 1)
        {
          if ((strcasecmp (arglist[0], arglist[1]) == 0) &&
              (arglist[2]))
            execute_string ("%s\n", arglist[2]);
        }

      free_array (arglist);
    }
}

void
cm_value (int arg, int start_pos, int end_pos)
{
  static int value_level = 0, saved_meta_pos = -1;

  /* xml_add_char() skips any content inside menus when output format is
     Docbook, so @@value{} is no use there.  Also start_pos and end_pos does not
     get updated, causing name to be empty string.  So just return.  */
   if (docbook && in_menu)
     return;

  /* All the text after @@value{ upto the matching } will eventually
     disappear from output_paragraph, when this function is called
     with ARG == END.  If the text produced until then sets
     meta_char_pos, we will need to restore it to the value it had
     before @@value was seen.  So we need to save the previous value
     of meta_char_pos here.  */
  if (arg == START)
    {
      /* If we are already inside some outer @@value, don't overwrite
         the value saved in saved_meta_pos.  */
      if (!value_level)
        saved_meta_pos = meta_char_pos;
      value_level++;
      /* While the argument of @@value is processed, we need to inhibit
         textual transformations like "--" into "-", since @@set didn't
         do that when it grabbed the name of the variable.  */
      in_fixed_width_font++;
    }
  else
    {
      char *name = (char *) &output_paragraph[start_pos];
      char *value;
      output_paragraph[end_pos] = 0;
      name = xstrdup (name);
      value = set_p (name);
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      /* Restore the previous value of meta_char_pos if the stuff
         inside this @@value{} moved it.  */
      if (saved_meta_pos == -1) /* can't happen inside @@value{} */
        abort ();
      if (value_level == 1
          && meta_char_pos >= start_pos && meta_char_pos < end_pos)
        {
          meta_char_pos = saved_meta_pos;
          saved_meta_pos = -1;
        }
      value_level--;
      /* No need to decrement in_fixed_width_font, since before
         we are called with arg == END, the reader loop already
         popped the brace stack, which restored in_fixed_width_font,
         among other things.  */

      if (value)
	{
	  /* We need to get past the closing brace since the value may
	     expand to a context-sensitive macro (e.g. @@xref) and produce
	     spurious warnings */
	  input_text_offset++; 
	  execute_string ("%s", value);
	  input_text_offset--;
	}
      else
	{
          warning (_("undefined flag: %s"), name);
          add_word_args (_("{No value for `%s'}"), name);
	}

      free (name);
    }
}

/* Set, clear, or conditionalize based on ACTION. */
static void
handle_variable (int action)
{
  char *name;

  get_rest_of_line (0, &name);
  /* If we hit the end of text in get_rest_of_line, backing up
     input pointer will cause the last character of the last line
     be pushed back onto the input, which is wrong.  */
  if (input_text_offset < input_text_length)
    backup_input_pointer ();
  handle_variable_internal (action, name);
  free (name);
}

static void
handle_variable_internal (int action, char *name)
{
  char *temp;
  int delimiter, additional_text_present = 0;

  /* Only the first word of NAME is a valid tag. */
  temp = name;
  delimiter = 0;
  while (*temp && (delimiter || !whitespace (*temp)))
    {
/* #if defined (SET_WITH_EQUAL) */
      if (*temp == '"' || *temp == '\'')
        {
          if (*temp == delimiter)
            delimiter = 0;
          else
            delimiter = *temp;
        }
/* #endif SET_WITH_EQUAL */
      temp++;
    }

  if (*temp)
    additional_text_present++;

  *temp = 0;

  if (!*name)
    line_error (_("%c%s requires a name"), COMMAND_PREFIX, command);
  else
    {
      switch (action)
        {
        case SET:
          {
            char *value;

#if defined (SET_WITH_EQUAL)
            /* Allow a value to be saved along with a variable.  The value is
               the text following an `=' sign in NAME, if any is present. */

            for (value = name; *value && *value != '='; value++);

            if (*value)
              *value++ = 0;

            if (*value == '"' || *value == '\'')
              {
                value++;
                value[strlen (value) - 1] = 0;
              }

#else /* !SET_WITH_EQUAL */
            /* The VALUE of NAME is the remainder of the line sans
               whitespace. */
            if (additional_text_present)
              {
                value = temp + 1;
                canon_white (value);
              }
            else
              value = "";
#endif /* !SET_WITH_VALUE */

            set (name, value);
          }
          break;

        case CLEAR:
          clear (name);
          break;

        case IFSET:
        case IFCLEAR:
          /* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,
             read lines from the the file until we reach a matching
             "@@end CONDITION".  This means that we only take note of
             "@@ifset/clear" and "@@end" commands. */
          {
            char condition[8];
            int condition_len;
            int orig_line_number = line_number;

            if (action == IFSET)
              strcpy (condition, "ifset");
            else
              strcpy (condition, "ifclear");

            condition_len = strlen (condition);

          if ((action == IFSET && !set_p (name))
              || (action == IFCLEAR && set_p (name)))
            {
              int level = 0, done = 0;

              while (!done && input_text_offset < input_text_length)
                {
                  char *freeable_line, *line;

                  get_rest_of_line (0, &freeable_line);

                  for (line = freeable_line; whitespace (*line); line++);

                  if (*line == COMMAND_PREFIX &&
                      (strncmp (line + 1, condition, condition_len) == 0))
                    level++;
                  else if (strncmp (line, "@@end", 4) == 0)
                    {
                      char *cname = line + 4;
                      char *temp;

                      while (*cname && whitespace (*cname))
                        cname++;
                      temp = cname;

                      while (*temp && !whitespace (*temp))
                        temp++;
                      *temp = 0;

                      if (strcmp (cname, condition) == 0)
                        {
                          if (!level)
                            {
                              done = 1;
                            }
                          else
                            level--;
                        }
                    }
                  free (freeable_line);
                }

              if (!done)
                file_line_error (input_filename, orig_line_number,
                                 _("Reached eof before matching @@end %s"),
                                 condition);

              /* We found the end of a false @@ifset/ifclear.  If we are
                 in a menu, back up over the newline that ends the ifset,
                 since that newline may also begin the next menu entry. */
              break;
            }
          else
            {
              if (action == IFSET)
                begin_insertion (ifset);
              else
                begin_insertion (ifclear);
            }
          }
          break;
        }
    }
}

/* Execution of random text not in file. */
typedef struct {
  char *string;                 /* The string buffer. */
  int size;                     /* The size of the buffer. */
  int in_use;                   /* Nonzero means string currently in use. */
} EXECUTION_STRING;

static EXECUTION_STRING **execution_strings = NULL;
static int execution_strings_index = 0;
static int execution_strings_slots = 0;

static EXECUTION_STRING *
get_execution_string (int initial_size)
{
  int i = 0;
  EXECUTION_STRING *es = NULL;

  if (execution_strings)
    {
      for (i = 0; i < execution_strings_index; i++)
        if (execution_strings[i] && (execution_strings[i]->in_use == 0))
          {
            es = execution_strings[i];
            break;
          }
    }

  if (!es)
    {
      if (execution_strings_index + 1 >= execution_strings_slots)
        {
          execution_strings = xrealloc
            (execution_strings,
             (execution_strings_slots += 3) * sizeof (EXECUTION_STRING *));
          for (; i < execution_strings_slots; i++)
            execution_strings[i] = NULL;
        }

      execution_strings[execution_strings_index] =
        xmalloc (sizeof (EXECUTION_STRING));
      es = execution_strings[execution_strings_index];
      execution_strings_index++;

      es->size = 0;
      es->string = NULL;
      es->in_use = 0;
    }

  if (initial_size > es->size)
    {
      es->string = xrealloc (es->string, initial_size);
      es->size = initial_size;
    }
  return es;
}

/* Given a pointer to TEXT and its desired length NEW_LEN, find TEXT's
   entry in the execution_strings[] array and change the .STRING and
   .SIZE members of that entry as appropriate.  */
void
maybe_update_execution_strings (char **text, unsigned int new_len)
{
  int i = 0;

  if (execution_strings)
    {
      for (i = 0; i < execution_strings_index; i++)
        if (execution_strings[i] && (execution_strings[i]->in_use == 1) &&
            execution_strings[i]->string == *text)
          {
            /* Don't ever shrink the string storage in execution_strings[]!
               execute_string assumes that it is always big enough to store
               every possible execution_string, and will break if that's
               not true.  So we only enlarge the string storage if the
               current size isn't big enough.  */
            if (execution_strings[i]->size < new_len)
              {
                execution_strings[i]->string =
                  *text = xrealloc (*text, new_len + 1);
                execution_strings[i]->size = new_len + 1;
              }
            return;
          }
    }
  /* We should *never* end up here, since if we are inside
     execute_string, TEXT is always in execution_strings[].  */
  abort ();
}

/* FIXME: this is an arbitrary limit.  */
#define EXECUTE_STRING_MAX 16*1024

/* Execute the string produced by formatting the ARGs with FORMAT.  This
   is like submitting a new file with @@include. */
void
#if defined (VA_FPRINTF) && __STDC__
execute_string (char *format, ...)
#else
execute_string (format, va_alist)
    char *format;
    va_dcl
#endif
{
  EXECUTION_STRING *es;
  char *temp_string, *temp_input_filename;
#ifdef VA_FPRINTF
  va_list ap;
#endif
  int insertion_level_at_start = insertion_level;

  es = get_execution_string (EXECUTE_STRING_MAX);
  temp_string = es->string;
  es->in_use = 1;

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (temp_string, format, ap);
#else
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);

  pushfile ();
  input_text_offset = 0;
  input_text = temp_string;
  input_text_length = strlen (temp_string);
  input_filename = xstrdup (input_filename);
  temp_input_filename = input_filename;

  executing_string++;
  reader_loop ();

  /* If insertion stack level changes during execution, that means a multiline
     command is used inside braces or @@section ... kind of commands.  */
  if (insertion_level_at_start != insertion_level && !executing_macro)
    {
      line_error (_("Multiline command %c%s used improperly"),
          COMMAND_PREFIX,
          command);
      /* We also need to keep insertion_level intact to make sure warnings are
         issued for @@end ... command.  */
      while (insertion_level > insertion_level_at_start)
        pop_insertion ();
    }

  popfile ();
  executing_string--;
  es->in_use = 0;
  free (temp_input_filename);
}


/* Return what would be output for STR (in newly-malloced memory), i.e.,
   expand Texinfo commands according to the current output format.  If
   IMPLICIT_CODE is set, expand @@code{STR}.  This is generally used for
   short texts; filling, indentation, and html escapes are disabled.  */

char *
expansion (char *str, int implicit_code)
{
  return maybe_escaped_expansion (str, implicit_code, 0);
}


/* Do HTML escapes according to DO_HTML_ESCAPE.  Needed in
   cm_printindex, q.v.  */

char *
maybe_escaped_expansion (char *str, int implicit_code, int do_html_escape)
{
  char *result;

  /* Inhibit indentation and filling, so that extra newlines
     are not added to the expansion.  (This is undesirable if
     we write the expanded text to macro_expansion_output_stream.)  */
  int saved_filling_enabled = filling_enabled;
  int saved_indented_fill = indented_fill;
  int saved_no_indent = no_indent;
  int saved_escape_html = escape_html;

  filling_enabled = 0;
  indented_fill = 0;
  no_indent = 1;
  escape_html = do_html_escape;

  result = full_expansion (str, implicit_code);

  filling_enabled = saved_filling_enabled;
  indented_fill = saved_indented_fill;
  no_indent = saved_no_indent;
  escape_html = saved_escape_html;

  return result;
}


/* Expand STR (or @@code{STR} if IMPLICIT_CODE is nonzero).  No change to
   any formatting parameters -- filling, indentation, html escapes,
   etc., are not reset.  Always returned in new memory.  */

char *
full_expansion (char *str, int implicit_code)
{
  int length;
  char *result;

  /* Inhibit any real output.  */
  int start = output_paragraph_offset;
  int saved_paragraph_is_open = paragraph_is_open;
  int saved_output_column = output_column;

  /* More output state to save.  */
  int saved_meta_pos = meta_char_pos;
  int saved_last_char = last_inserted_character;
  int saved_last_nl = last_char_was_newline;

  /* If we are called in the middle of processing a command, we need
     to dup and save the global variable `command' (which holds the
     name of this command), since the recursive reader loop will free
     it from under our feet if it finds any macros in STR.  */
  char *saved_command = command ? xstrdup (command) : NULL;

  inhibit_output_flushing ();
  paragraph_is_open = 1;
  if (strlen (str) > (implicit_code
                      ? EXECUTE_STRING_MAX - 1 - sizeof("@@code{}")
                      : EXECUTE_STRING_MAX - 1))
    line_error (_("`%.40s...' is too long for expansion; not expanded"), str);
  else
    execute_string (implicit_code ? "@@code{%s}" : "%s", str);
  uninhibit_output_flushing ();

  /* Copy the expansion from the buffer.  */
  length = output_paragraph_offset - start;
  result = xmalloc (1 + length);
  memcpy (result, (char *) (output_paragraph + start), length);
  result[length] = 0;

  /* Pretend it never happened.  */
  free_and_clear (&command);
  command = saved_command;

  output_paragraph_offset = start;
  paragraph_is_open = saved_paragraph_is_open;
  output_column = saved_output_column;

  meta_char_pos = saved_meta_pos;
  last_inserted_character = saved_last_char;
  last_char_was_newline = saved_last_nl;

  return result;
}


/* Return text (info) expansion of STR no matter what the current output
   format is.  */

char *
text_expansion (char *str)
{
  char *ret;
  int save_html = html;
  int save_xml = xml;
  int save_docbook = docbook;

  html = 0;
  xml = 0;
  docbook = 0;
  ret = expansion (str, 0);
  html = save_html;
  xml = save_xml;
  docbook = save_docbook;

  return ret;
}


/* Set the paragraph indentation variable to the value specified in STRING.
   Values can be:
     `asis': Don't change existing indentation.
     `none': Remove existing indentation.
        NUM: Indent NUM spaces at the starts of paragraphs.
             If NUM is zero, we assume `none'.
   Returns 0 if successful, or nonzero if STRING isn't one of the above. */
int
set_paragraph_indent (char *string)
{
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    paragraph_start_indent = 0;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    paragraph_start_indent = -1;
  else
    {
      if (sscanf (string, "%d", &paragraph_start_indent) != 1)
        return -1;
      else
        {
          if (paragraph_start_indent == 0)
            paragraph_start_indent = -1;
        }
    }
  return 0;
}
@


1.8
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.74 2004/12/19 17:15:42 karl Exp $
d552 5
@


1.7
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.205 2002/03/28 16:33:48 karl Exp $
d4 2
a5 2
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc.
d21 1
a21 1
   Makeinfo was authored by Brian Fox (bfox@@ai.mit.edu). */
d30 1
d35 1
d38 1
a73 4
/* Flags which control initial output string for xrefs. */
int px_ref_flag = 0;
int ref_flag = 0;

d136 10
d157 11
a167 1
extern void do_multitable (), end_multitable ();
d169 1
a169 49
void push_node_filename (), pop_node_filename ();
void remember_error ();
void convert_from_stream (), convert_from_file (), convert_from_loaded_file ();
void init_internals (), init_paragraph (), init_brace_stack ();
void init_insertion_stack (), init_indices ();
void init_tag_table (), write_tag_table (), write_tag_table_internal ();
void validate_file (), validate_other_references (), split_file ();
void free_node_references (), handle_variable ();
void handle_variable_internal ();
void normalize_node_name ();
void add_anchor_name ();
void free_node_node_references (), remember_node_node_reference ();

char **get_brace_args ();
int array_len ();
void free_array ();
static int end_of_sentence_p ();
static void isolate_nodename ();
void reader_loop ();
void remember_brace (), remember_brace_1 ();
void pop_and_call_brace (), discard_braces ();
void add_word (), add_char (), insert (), flush_output ();
void insert_string ();
void close_paragraph ();
void ignore_blank_line ();
void do_flush_right_indentation (), discard_insertions ();
void start_paragraph (), indent ();
void inhibit_output_flushing (), uninhibit_output_flushing ();
int set_paragraph_indent ();
int self_delimiting (), search_forward ();
int multitable_item (), number_of_node ();
extern void add_link (), add_escaped_anchor_name ();

void me_execute_string_keep_state ();
void maybe_update_execution_strings ();

extern char *escape_string ();
extern void insert_html_tag ();
extern void sectioning_html ();
extern void add_link ();

#if defined (VA_FPRINTF) && __STDC__
/* Unfortunately we must use prototypes if we are to use <stdarg.h>.  */
void add_word_args (char *, ...);
void execute_string (char *, ...);
#else
void add_word_args ();
void execute_string ();
#endif /* no prototypes */
d176 16
d194 1
a194 2
fs_error (filename)
     char *filename;
d204 1
a204 1
error (char *format, ...)
d207 1
a207 1
     char *format;
d231 1
a231 1
file_line_error (char *infile, int lno, char *format, ...)
d236 1
a236 1
   char *format;
d262 1
a262 1
line_error (char *format, ...)
d265 1
a265 1
   char *format;
d289 1
a289 1
warning (char *format, ...)
d292 1
a292 1
     char *format;
a316 15
/* Remember that an error has been printed.  If more than
   max_error_level have been printed, then exit the program. */
void
remember_error ()
{
  errors_printed++;
  if (max_error_level && (errors_printed > max_error_level))
    {
      fprintf (stderr, _("Too many errors!  Gave up.\n"));
      flush_file_stack ();
      cm_bye ();
      xexit (1);
    }
}

d318 2
a319 2
void
misplaced_brace ()
d328 1
a328 1
print_version_info ()
d337 1
a337 2
usage (exit_value)
     int exit_value;
d344 1
a344 1
    printf ("\n");
d361 1
a361 1
     printf ("\n");
d364 1
a364 1
     puts (_("\
d366 1
a366 1
      --docbook             output DocBook rather than Info.\n\
d368 2
a369 1
      --xml                 output XML (TexinfoML) rather than Info.\n\
d372 1
a372 1
     puts (_("\
d386 1
a386 1
     printf (_("\
d401 14
a414 2
  }
  printf ("\n");
d416 1
a416 1
     puts (_("\
d418 5
a422 5
      --commands-in-node-names   allow @@ commands in node names.\n\
  -D VAR                         define the variable VAR, as with @@set.\n\
  -I DIR                         append DIR to the @@include search path.\n\
  -P DIR                         prepend DIR to the @@include search path.\n\
  -U VAR                         undefine the variable VAR, as with @@clear.\n\
d425 1
a425 1
     puts (_("\
d427 2
d433 2
d439 3
d444 1
a444 1
     puts (_("\
d449 1
d452 1
a452 1
  fputs (_("\
d456 1
a456 1
  makeinfo --xml foo.texi               write XML to @@setfilename\n\
d465 1
a465 1
  puts (_("\n\
d470 2
d478 1
d487 1
d492 1
d495 1
d500 1
d510 1
d512 1
d521 13
d537 1
a537 3
main (argc, argv)
     int argc;
     char **argv;
a538 1
  extern int errors_printed;
d546 1
d548 1
d553 1
d557 49
d608 1
a608 1
  while ((c = getopt_long (argc, argv, "D:de:E:f:hI:o:p:P:r:s:U:vV:wx",
d616 4
d623 10
a632 1
          handle_variable_internal ((c == 'D') ? SET : CLEAR, optarg);
d637 4
a640 2
	  xml = 1;
	  docbook = 1;
d648 1
a648 1
                      "--error-limit", progname, optarg);
d660 2
a661 1
                error (_("Couldn't open macro expansion output `%s'"), optarg);
d664 3
a666 1
            error (_("Cannot specify more than one macro expansion output"));
d674 1
a674 1
                       "--fill-column", progname, optarg);
d685 2
a686 2
          if (!include_files_path)
            include_files_path = xstrdup (".");
d688 8
a695 5
          include_files_path = (char *)
            xrealloc (include_files_path,
                      2 + strlen (include_files_path) + strlen (optarg));
          strcat (include_files_path, PATH_SEP);
          strcat (include_files_path, optarg);
d715 1
a715 17
          if (!include_files_path)
            {
              include_files_path = xstrdup (optarg);
              include_files_path = xrealloc (include_files_path,
                           strlen (include_files_path) + 3); /* 3 for ":.\0" */
              strcat (strcat (include_files_path, PATH_SEP), ".");
            }
          else
            {
              char *tmp = xstrdup (include_files_path);
              include_files_path = xrealloc (include_files_path,
          strlen (include_files_path) + strlen (optarg) + 2); /* 2 for ":\0" */
              strcpy (include_files_path, optarg);
              strcat (include_files_path, ":");
              strcat (include_files_path, tmp);
              free (tmp);
            }
d723 1
a723 1
                     "--reference-limit", progname, optarg);
d732 1
a732 1
          _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"),
d739 1
a739 1
	case 'S': /* --split-size */
d744 1
a744 1
                     "--split-size", progname, optarg);
d747 10
a756 1
	  break;
d765 2
a766 2
          printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
d768 2
a769 3
For more information about these matters, see the files named COPYING.\n"),
                  "2002");
          exit (0);
d773 2
d781 4
a784 1
 	  xml = 1;
d786 1
a786 1
 
d793 3
d813 5
a817 1
      if (html && splitting)
d820 2
a821 2
                   "%s: --no-headers conflicts with --no-split for --html.\n",
                   progname);
d827 1
a828 5
      /* If the user did not specify an output file, use stdout. */
      if (!command_output_filename)
        command_output_filename = xstrdup ("-");
    }
    
d840 1
a840 1
    
d854 2
a855 1
  return errors_printed ? 2 : 0;
a856 1

d860 16
a875 3
/* Return the next token as a string pointer.  We cons the string. */
char *
read_token ()
d897 1
a897 1
               && command_char (character));
d907 1
a907 2
self_delimiting (character)
     int character;
d911 1
a911 1
  return strchr ("~{|}`^\\@@?=;:.-,*\'\" !\n\t", character) != NULL;
d916 1
a916 2
canon_white (string)
     char *string;
d918 2
a919 2
  int len = strlen (string);
  int x;
d921 1
a921 1
  if (!len)
d924 1
a924 1
  for (x = 0; x < len; x++)
d926 3
a928 5
      if (!cr_or_whitespace (string[x]))
        {
          strcpy (string, string + x);
          break;
        }
d930 10
a939 6
  len = strlen (string);
  if (len)
    len--;
  while (len > -1 && cr_or_whitespace (string[len]))
    len--;
  string[len + 1] = 0;
d944 1
a944 2
fix_whitespace (string)
     char *string;
d974 1
a974 2
discard_until (string)
     char *string;
d988 2
a989 2
      input_text_offset = input_text_length - strlen (string);

d991 11
a1001 2
        {
          line_error (_("Expected `%s'"), string);
d1006 2
a1007 3
    input_text_offset = temp;

  input_text_offset += strlen (string);
d1015 1
a1015 2
get_until (match, string)
     char *match, **string;
d1048 1
a1048 2
replace_with_expansion (from, to)
     int from, *to;
d1124 1
a1124 3
get_until_in_line (expand, match, string)
     int expand;
     char *match, **string;
d1156 1
a1156 3
get_rest_of_line (expand, string)
     int expand;
     char **string;
d1164 1
a1164 1
	 intact in the macro-expanded output.  */
d1187 1
a1187 1
backup_input_pointer ()
d1200 1
a1200 2
get_until_in_braces (match, string)
     char *match, **string;
d1210 1
a1210 1
          i++;			/* skip commands like @@, and @@{ */
d1238 2
d1257 2
a1258 2
void
initialize_conversion ()
a1271 4
typedef struct generic_list {
  struct generic_list *next;
} GENERIC_LIST;

d1276 1
a1276 2
reverse_list (list)
     GENERIC_LIST *list;
d1297 2
a1298 4
void
convert_from_stream (stream, name)
     FILE *stream;
     char *name;
d1345 2
a1346 3
void
convert_from_file (name)
     char *name;
d1351 3
d1364 1
a1364 1
      if (find_and_load (filename))
d1385 32
d1421 1
a1421 1
   
d1426 1
a1426 1
  
d1431 1
a1431 2
insert_toplevel_subdirectory (output_filename)
     char *output_filename;
d1433 1
a1435 2
  struct stat st;
  static const char index_name[] = "index.html";
d1439 3
a1441 3
  dir = pathname_part (buf);
  base = filename_part (buf);
  basename = xstrdup (base); /* remember real @@setfilename name */
d1450 5
a1454 9
  subdir = "";
  if (FILENAME_CMP (base, filename_part (dir)) != 0)
    {
      if (save_command_output_filename
          && STREQ (output_filename, save_command_output_filename))
        subdir = basename;  /* from user, use unchanged */
      else
        subdir = base;      /* implicit, omit suffix */
    }
d1458 3
a1460 3
			     + strlen (basename) + 1
			     + index_len
			     + 1);
d1465 6
a1470 4
  if (mkdir (output_filename, 0777) == -1 && errno != EEXIST
      /* output_filename might exist, but be a non-directory.  */
      || (stat (output_filename, &st) == 0 && !S_ISDIR (st.st_mode)))
    { /* that failed, try subdir name with .html */
a1474 3
      if (mkdir (output_filename, 0777) == -1)
	{
	  char *errmsg = strerror (errno);
d1476 3
a1478 7
	  if ((errno == EEXIST
#ifdef __MSDOS__
	       || errno == EACCES
#endif
	       )
	      && (stat (output_filename, &st) == 0 && !S_ISDIR (st.st_mode)))
	    errmsg = _("File exists, but is not a directory");
d1480 2
a1481 2
                      output_filename, errmsg);
          exit (1);
a1482 1
      strcat (output_filename, "/");
d1484 2
a1485 2
  else if (strlen (subdir))
    strcat (output_filename, "/");
d1491 2
a1492 3
void
convert_from_loaded_file (name)
     char *name;
d1531 1
a1531 1
 
a1558 2
      if (xml && !docbook)
	xml_begin_document (output_filename);
d1617 5
a1621 5
	  if (FILENAME_CMP (output_filename, NULL_DEVICE) == 0
	      || FILENAME_CMP (output_filename, ALSO_NULL_DEVICE) == 0)
	    splitting = 0;
	  else
	    output_filename = insert_toplevel_subdirectory (output_filename);
d1634 3
d1653 1
a1653 1
  flush_output ();		/* in case there was no @@bye */
d1677 13
d1693 1
a1693 1
      
d1708 2
a1709 1
          fprintf (stderr, _("%s: Removing macro output file `%s' due to errors; use --force to preserve.\n"),
a1718 6
      if (tag_table)
        {
          tag_table = (TAG_ENTRY *) reverse_list (tag_table);
          if (!no_headers && !html)
            write_tag_table ();
        }
d1722 1
d1728 17
a1744 1
      flush_output ();		/* in case there was no @@bye */
d1752 8
a1759 3
      /* If we need to output the table of contents, do it now.  */
      if (contents_filename || shortcontents_filename)
	toc_update ();
d1762 4
a1765 1
        split_file (real_output_filename, split_size);
d1772 2
a1773 1
          fprintf (stderr, _("%s: Removing output file `%s' due to errors; use --force to preserve.\n"),
d1781 22
d1804 4
d1809 1
a1809 2
free_and_clear (pointer)
     char **pointer;
d1819 2
a1820 2
void
init_internals ()
d1840 1
a1840 1
init_paragraph ()
d1842 1
a1842 1
  free_and_clear (&output_paragraph);
d1856 1
a1856 1
handle_menu_entry ()
d1859 1
a1859 1
  
d1862 1
a1862 1
  
d1882 1
a1882 1
          add_word ("<ul>\n");
d1886 1
a1886 6
      else if (!in_paragraph && !paragraph_is_open)
        {
          add_word ("<p>\n");
          in_paragraph = 1;
        }
      
d1889 2
a1890 1
          add_word ("</p>");
d1894 3
a1896 1
      add_word ("<li><a");
d1898 5
a1902 5
	{
	  add_word(" accesskey=");
	  add_word_args("%d", next_menu_item_number);
	  next_menu_item_number++;
	}
d1925 13
a1937 2
      input_text_offset++;	/* discard the second colon or the period */
      add_word (": ");
d1940 1
a1940 1
    { 
d1958 1
a1958 2
get_command_entry (string)
     char *string;
d1981 1
a1981 1
read_command ()
d2002 1
d2004 1
d2011 1
a2011 1
    }
d2087 1
a2087 1
reader_loop ()
a2090 1
  int dash_count = 0;
d2102 1
d2106 17
a2122 2
          input_text_offset++;
          character = '"'; /* html fixxme */
d2126 2
a2127 1
      if (!only_macro_expansion && character == '-')
d2129 4
a2132 2
          dash_count++;
          if (dash_count == 2 && !in_fixed_width_font)
d2134 1
a2135 1
              continue;
a2136 9
        }
      else if (dash_count > 0)
        dash_count = 0;

      /* If this is a whitespace character, then check to see if the line
         is blank.  If so, advance to the carriage return. */
      if (!only_macro_expansion && whitespace (character))
        {
          int i = input_text_offset + 1;
d2138 2
a2139 2
          while (i < input_text_length && whitespace (input_text[i]))
            i++;
d2141 45
a2185 1
          if (i == input_text_length || input_text[i] == '\n')
d2214 1
a2214 1
        
d2229 2
a2230 2
	  else if (xml)
	    xml_insert_entity ("lt");
d2239 2
a2240 2
	  else if (xml)
	    xml_insert_entity ("gt");
d2258 1
a2258 1
              if (!STREQ (command, "math"))
d2264 2
a2265 4
                { /* We don't mind `extra' braces inside @@math.  */
                  extern void cm_no_op ();
                  remember_brace (cm_no_op);
                }
d2289 2
a2290 2
void
init_brace_stack ()
a2294 11
void
remember_brace (proc)
     COMMAND_FUNCTION *proc;
{
  if (curchar () != '{')
    line_error (_("%c%s expected `{...}'"), COMMAND_PREFIX, command);
  else
    input_text_offset++;
  remember_brace_1 (proc, output_paragraph_offset);
}

d2297 2
a2298 4
void
remember_brace_1 (proc, position)
     COMMAND_FUNCTION *proc;
     int position;
d2310 10
d2322 2
a2323 2
void
pop_and_call_brace ()
d2351 2
a2352 3
void
adjust_braces_following (here, amount)
     int here, amount;
d2367 2
a2368 3
static char *
find_proc_name (proc)
     COMMAND_FUNCTION *proc;
d2383 1
a2383 1
discard_braces ()
d2392 1
a2392 1
          char *proc_name;
d2396 2
a2397 2
			   _("%c%s missing close brace"), COMMAND_PREFIX,
			   proc_name);
d2410 2
a2411 3
int
get_char_len (character)
     int character;
d2445 1
a2445 1
add_word_args (char *format, ...)
d2448 1
a2448 1
    char *format;
d2469 1
a2469 2
add_word (string)
     char *string;
d2479 1
a2479 2
add_html_elt (string)
     char *string;
d2486 57
d2546 1
a2546 2
add_char (character)
     int character;
d2580 2
d2583 1
d2595 1
a2595 1
      if (!filling_enabled && ! (html && (in_menu || in_detailmenu)))
d2652 9
a2660 7
	/* This is sad, but it seems desirable to not force any
	   particular order on the front matter commands.  This way,
	   the document can do @@settitle, @@documentlanguage, etc, in
	   any order and with any omissions, and we'll still output
	   the html <head> `just in time'.  */
	if (!executing_string && html && !html_output_head_p)
	  html_output_head ();
d2672 4
a2675 5
            /* This horrible kludge of checking for a < prevents <p>
               from being inserted when we already have html markup
               starting a paragraph, as with <ul> and <h1> and the like.  */
            if (html && escape_html && character != '<'
                && (!in_fixed_width_font || in_menu || in_detailmenu))
d2677 5
d2736 3
a2738 3
                              strncpy ((char *) &output_paragraph[temp],
                                       (char *) &output_paragraph[t1],
                                       (output_paragraph_offset - t1));
d2800 1
a2800 2
add_meta_char (character)
     int character;
d2808 1
a2808 2
insert (character)
     int character;
d2810 11
d2831 1
a2831 2
insert_string (string)
     char *string;
d2845 1
a2845 1
end_of_sentence_p ()
d2868 1
a2868 2
kill_self_indent (count)
     int count;
d2897 1
a2897 1
inhibit_output_flushing ()
d2904 1
a2904 1
uninhibit_output_flushing ()
d2910 1
a2910 1
flush_output ()
d2919 6
d2954 1
a2954 2
close_paragraph_with_lines (lines)
     int lines;
d2964 1
a2964 1
close_single_paragraph ()
d2971 1
a2971 1
close_insertion_paragraph ()
d3007 1
a3007 1
close_paragraph ()
d3011 5
d3021 1
a3021 3
      int tindex, c;

      tindex = output_paragraph_offset;
d3029 1
a3029 1
          c = output_paragraph[tindex];
d3073 1
a3073 1
ignore_blank_line ()
d3080 2
a3081 2
void
do_flush_right_indentation ()
d3118 1
a3118 1
start_paragraph ()
d3165 1
a3165 2
indent (amount)
     int amount;
a3166 3
  if (html)
    return;

d3178 1
a3178 3
search_forward (string, from)
     char *string;
     int from;
a3189 2

/* Cross references.  */
d3191 3
a3193 7
/* Return next comma-delimited argument, but do not cross a close-brace
   boundary.  Clean up whitespace, too.  If EXPAND is nonzero, replace
   the entire brace-delimited argument list with its expansion before
   looking for the next comma.  */
char *
get_xref_token (expand)
     int expand;
d3195 2
a3196 6
  char *string;

  if (expand)
    {
      int old_offset = input_text_offset;
      int old_lineno = line_number;
d3198 1
a3198 6
      get_until_in_braces ("}", &string);
      if (curchar () == '}')    /* as opposed to end of text */
        input_text_offset++;
      if (input_text_offset > old_offset)
        {
          int limit = input_text_offset;
d3200 1
a3200 8
          input_text_offset = old_offset;
          line_number = old_lineno;
          only_macro_expansion++;
          replace_with_expansion (input_text_offset, &limit);
          only_macro_expansion--;
        }
      free (string);
    }
d3202 1
a3202 5
  get_until_in_braces (",", &string);
  if (curchar () == ',')
    input_text_offset++;
  fix_whitespace (string);
  return string;
d3205 3
a3207 242
/* NOTE: If you wonder why the HTML output is produced with such a
   peculiar mix of calls to add_word and execute_string, here's the
   reason.  get_xref_token (1) expands all macros in a reference, but
   any other commands, like @@value, @@@@, etc., are left intact.  To
   expand them, we need to run the arguments through execute_string.
   However, characters like <, &, > and others cannot be let into
   execute_string, because they will be escaped.  See the mess?  */

/* Make a cross reference. */
void
cm_xref (arg)
{
  if (arg == START)
    {
      char *arg1 = get_xref_token (1); /* expands all macros in xref */
      char *arg2 = get_xref_token (0);
      char *arg3 = get_xref_token (0);
      char *arg4 = get_xref_token (0);
      char *arg5 = get_xref_token (0);
      char *tem;

      /* "@@xref{,Foo,, Bar, Baz} is not valid usage of @@xref.  The
	 first argument must never be blank." --rms.
	 We hereby comply by disallowing such constructs.  */
      if (!*arg1)
	line_error (_("First argument to cross-reference may not be empty"));

      if (xml && docbook)
	{
	  if (!*arg4 && !*arg5)
	    {
	      char *arg1_id = xml_id (arg1);
	      if (*arg2)
		{
		  xml_insert_element_with_attribute (XREFNODENAME, START, 
						     "linkend=\"%s\"", arg1_id);
		  free (arg1_id);
		  if (*arg2)
		    execute_string (arg2);
		  xml_insert_element (XREFNODENAME, END);
		} 
	      else
		{
		  xml_insert_element_with_attribute (XREF, START, 
						     "linkend=\"%s\"", arg1_id);
		  free (arg1_id);
		  xml_pop_current_element ();
		}
	    }
	}
      else if (xml)
	{
	  xml_insert_element (XREF, START);
	  xml_insert_element (XREFNODENAME, START);
	  execute_string (arg1);
	  xml_insert_element (XREFNODENAME, END);
	  if (*arg2)
	    {
	      xml_insert_element (XREFINFONAME, START);
	      execute_string (arg2);
	      xml_insert_element (XREFINFONAME, END);
	    }
	  if (*arg3)
	    {
	      xml_insert_element (XREFPRINTEDDESC, START);
	      execute_string (arg3);
	      xml_insert_element (XREFPRINTEDDESC, END);
	    }
	  if (*arg4)
	    {
	      xml_insert_element (XREFINFOFILE, START);
	      execute_string (arg4);
	      xml_insert_element (XREFINFOFILE, END);
	    }
	  if (*arg5)
	    {
	      xml_insert_element (XREFPRINTEDNAME, START);
	      execute_string (arg5);
	      xml_insert_element (XREFPRINTEDNAME, END);
	    }
	  xml_insert_element (XREF, END);
	}
      else if (html)
        {
          if (!ref_flag)
            add_word_args ("%s", px_ref_flag ? _("see ") : _("See "));
        }
      else
        add_word_args ("%s", px_ref_flag ? "*note " : "*Note ");

      if (!xml)
	{
	  if (*arg5 || *arg4)
	    {
	      /* arg1 - node name
		 arg2 - reference name
		 arg3 - title or topic (and reference name if arg2 is NULL)
		 arg4 - info file name
		 arg5 - printed manual title  */
	      char *ref_name;

	      if (!*arg2)
		{
		  if (*arg3)
		    ref_name = arg3;
		  else
		    ref_name = arg1;
		}
	      else
		ref_name = arg2;

	      if (html)
		{
		  /* html fixxme: revisit this; external node name not
		     much use to us with numbered nodes. */
		  add_html_elt ("<a href=");
		  /* Note that if we are splitting, and the referenced
		     tag is an anchor rather than a node, we will
		     produce a reference to a file whose name is
		     derived from the anchor name.  However, only
		     nodes create files, so we are referencing a
		     non-existent file.  cm_anchor, which see, deals
		     with that problem.  */
		  if (splitting)
		    execute_string ("\"../%s/", arg4);
		  else
		    execute_string ("\"%s.html", arg4);
		  /* Do not collapse -- to -, etc., in references.  */
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0); /* expand @@-commands in node */
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", ref_name);
		  add_word ("</a>");
		}
	      else
		{
		  execute_string ("%s:", ref_name);
		  in_fixed_width_font++;
		  execute_string (" (%s)%s%s", arg4, arg1, px_ref_flag ? "." : "");
		  in_fixed_width_font--;
		}

	      /* Free all of the arguments found. */
	      if (arg1) free (arg1);
	      if (arg2) free (arg2);
	      if (arg3) free (arg3);
	      if (arg4) free (arg4);
	      if (arg5) free (arg5);
	      return;
	    }
	  else
	    remember_node_reference (arg1, line_number, followed_reference);

	  if (*arg3)
	    {
	      if (html)
		{
		  add_html_elt ("<a href=\"");
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0);
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", *arg2 ? arg2 : arg3);
		  add_word ("</a>");
		}
	      else
		{
		  execute_string ("%s:", *arg2 ? arg2 : arg3);
		  in_fixed_width_font++;
		  execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
		  in_fixed_width_font--;
		}
	    }
	  else
	    {
	      if (html)
		{
		  add_html_elt ("<a href=\"");
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0);
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", *arg2 ? arg2 : arg1);
		  add_word ("</a>");
		}
	      else
		{
		  if (*arg2)
		    {
		      execute_string ("%s:", arg2);
		      in_fixed_width_font++;
		      execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
		      in_fixed_width_font--;
		    }
		  else
		    {
		      in_fixed_width_font++;
		      execute_string ("%s::", arg1);
		      in_fixed_width_font--;
		    }
		}
	    }
	}
      /* Free all of the arguments found. */
      if (arg1) free (arg1);
      if (arg2) free (arg2);
      if (arg3) free (arg3);
      if (arg4) free (arg4);
      if (arg5) free (arg5);
    }
  else
    { /* Check to make sure that the next non-whitespace character is
         valid to follow an xref (so info readers can find the node
         names).  `input_text_offset' is pointing at the "}" which ended
         the xref or ref command. */
      int temp;

      for (temp = input_text_offset + 1; temp < input_text_length; )
        {
          if (cr_or_whitespace (input_text[temp]))
            temp++;
          else
            {
              if (input_text[temp] != '.' && input_text[temp] != ',')
                warning (_("`.' or `,' must follow cross reference, not %c"),
                         input_text[temp]);
              break;
            }
        }
    }
}

void
cm_pxref (arg)
     int arg;
d3209 3
a3211 11
  if (arg == START)
    {
      px_ref_flag++;
      cm_xref (arg);
      px_ref_flag--;
    }
  /* Note that cm_xref isn't called with arg == END, which disables
     the code near the end of cm_xref that checks for `.' or `,'
     after the cross-reference.  This is because @@pxref{} generates
     the required character itself, when needed.  */
}
d3213 1
a3213 5
void
cm_ref (arg)
     int arg;
{
  if (arg == START)
d3215 3
a3217 3
      ref_flag++;
      cm_xref (arg);
      ref_flag--;
a3218 1
}
d3220 3
a3222 13
void
cm_inforef (arg)
     int arg;
{
  if (arg == START)
    {
      char *node = get_xref_token (1); /* expands all macros in inforef */
      char *pname = get_xref_token (0);
      char *file = get_xref_token (0);

      /* (see comments at cm_xref).  */
      if (!*node)
	line_error (_("First argument to @@inforef may not be empty"));
d3224 5
a3228 15
      if (xml && !docbook)
	{
	  xml_insert_element (INFOREF, START);
	  xml_insert_element (INFOREFNODENAME, START);
	  execute_string (node);
	  xml_insert_element (INFOREFNODENAME, END);
	  if (*pname)
	    {
	      xml_insert_element (INFOREFREFNAME, START);
	      execute_string (pname);
	      xml_insert_element (INFOREFREFNAME, END);
	    }
	  xml_insert_element (INFOREFINFONAME, START);
	  execute_string (file);
	  xml_insert_element (INFOREFINFONAME, END);
d3230 6
a3235 5
	  xml_insert_element (INFOREF, END);
	}
      else if (html)
        {
	  char *tem;
d3237 3
a3239 21
          add_word (_("see "));
          /* html fixxme: revisit this */
          add_html_elt ("<a href=");
	  if (splitting)
	    execute_string ("\"../%s/", file);
	  else
	    execute_string ("\"%s.html", file);
	  tem = expansion (node, 0);
	  add_anchor_name (tem, 1);
          add_word ("\">");
          execute_string ("%s", *pname ? pname : tem);
          add_word ("</a>");
	  free (tem);
        }
      else
        {
          if (*pname)
            execute_string ("*note %s: (%s)%s", pname, file, node);
          else
            execute_string ("*note (%s)%s::", file, node);
        }
d3241 1
a3241 4
      free (node);
      free (pname);
      free (file);
    }
d3243 1
a3243 129

/* A URL reference.  */
void
cm_uref (arg)
     int arg;
{
  if (arg == START)
    {
      extern int printing_index;
      char *url  = get_xref_token (1); /* expands all macros in uref */
      char *desc = get_xref_token (0);
      char *replacement = get_xref_token (0);

      if (xml)
	{
	  xml_insert_element (UREF, START);
	  xml_insert_element (UREFURL, START);
	  execute_string (url);
	  xml_insert_element (UREFURL, END);
	  if (*desc)
	    {
	      xml_insert_element (UREFDESC, START);
	      execute_string (desc);
	      xml_insert_element (UREFDESC, END);
	    }
	  if (*replacement)
	    {
	      xml_insert_element (UREFREPLACEMENT, START);
	      execute_string (replacement);
	      xml_insert_element (UREFREPLACEMENT, END);
	    }
	  xml_insert_element (UREF, END);	  
	}
      else if (html)
        { /* never need to show the url */
          add_html_elt ("<a href=");
          /* don't collapse `--' etc. in the url */
          in_fixed_width_font++;
          execute_string ("\"%s\"", url);
          in_fixed_width_font--;
          add_word (">");
          execute_string ("%s", *replacement ? replacement
                                : (*desc ? desc : url));
          add_word ("</a>");
        }
      else if (*replacement) /* do not show the url */
        execute_string ("%s", replacement);
      else if (*desc)        /* show both text and url */
        {
          execute_string ("%s ", desc);
          in_fixed_width_font++;
          execute_string ("(%s)", url);
          in_fixed_width_font--;
        }
      else /* no text at all, so have the url to show */
        {
          in_fixed_width_font++;
          execute_string ("%s%s%s",
                          printing_index ? "" : "`",
                          url,
                          printing_index ? "" : "'");
          in_fixed_width_font--;
        }
      if (url)
        free (url);
      if (desc)
        free (desc);
      if (replacement)
        free (replacement);
    }
}

/* An email reference.  */
void
cm_email (arg)
     int arg;
{
  if (arg == START)
    {
      char *addr = get_xref_token (1); /* expands all macros in email */
      char *name = get_xref_token (0);

      if (xml && docbook)
	{
	  xml_insert_element_with_attribute (EMAIL, START, "url=\"mailto:%s\"", addr);
	  if (*name)
	      execute_string (name);
	  xml_insert_element (EMAIL, END);	  	  
	}
      else if (xml)
	{
	  xml_insert_element (EMAIL, START);
	  xml_insert_element (EMAILADDRESS, START);
	  execute_string (addr);
	  xml_insert_element (EMAILADDRESS, END);
	  if (*name)
	    {
	      xml_insert_element (EMAILNAME, START);
	      execute_string (name);
	      xml_insert_element (EMAILNAME, END);
	    }
	  xml_insert_element (EMAIL, END);	  	  
	}
      else if (html)
        {
          add_html_elt ("<a href=");
          /* don't collapse `--' etc. in the address */
          in_fixed_width_font++;
          execute_string ("\"mailto:%s\"", addr);
          in_fixed_width_font--;
          add_word (">");
          execute_string ("%s", *name ? name : addr);
          add_word ("</a>");
        }
      else
        {
          execute_string ("%s%s", name, *name ? " "  : "");
          in_fixed_width_font++;
          execute_string ("<%s>", addr);
          in_fixed_width_font--;
        }

      if (addr)
        free (addr);
      if (name)
        free (name);
    }
}

d3247 1
a3247 2
cm_image (arg)
     int arg;
d3249 1
a3249 1
  char *name_arg, *rest, *alt_arg, *ext_arg;
d3255 2
a3256 8
  /* We don't (yet) care about the next two args, but read them so they
     don't end up in the text.  */
  rest = get_xref_token (0);
  if (rest)
    free (rest);
  rest = get_xref_token (0);
  if (rest)
    free (rest);
d3262 2
d3265 1
a3265 1
                       + (ext_arg && *ext_arg ? strlen (ext_arg) + 1 : 4) + 1);
d3267 1
a3267 1
      if (html)
d3269 6
a3274 1
	  if (ext_arg && *ext_arg)
d3276 2
d3280 2
a3281 5
		{
                  line_error(_("@@image file `%s' (for HTML) not readable: %s"),
		             fullname, strerror (errno));
		  return;
		}
d3283 3
a3285 2
	  else
	    {
d3287 4
a3290 2
          if (access (fullname, R_OK) != 0)
            {
d3292 5
a3296 5
              if (access (fullname, R_OK) != 0)
                {
             line_error (_("No `%s.png' or `.jpg', and no extension supplied"),
                              name_arg);
                  return;
d3298 2
d3301 24
a3324 1
	    }
d3326 1
a3326 1
	  add_html_elt ("<img src=");
d3328 6
a3333 2
	  add_html_elt (" alt=");
	  add_word_args ("\"%s\">", (*alt_arg) ? alt_arg : fullname);
d3336 1
a3336 1
	xml_insert_docbook_image (name_arg);
d3338 19
a3356 5
	{
	  xml_insert_element (IMAGE, START);
	  add_word (name_arg);
	  xml_insert_element (IMAGE, END);
	}
d3358 1
a3358 1
        { /* Try to open foo.txt.  */
d3360 18
a3377 4
          strcpy (fullname, name_arg);
          strcat (fullname, ".txt");
          image_file = fopen (fullname, "r");
          if (image_file)
d3382 8
d3395 47
a3441 6
              /* Maybe we need to remove the final newline if the image
                 file is only one line to allow in-line images.  On the
                 other hand, they could just make the file without a
                 final newline.  */
              while ((ch = getc (image_file)) != EOF)
                add_char (ch);
a3444 3

              if (fclose (image_file) != 0)
                perror (fullname);
d3447 2
a3448 2
            line_error (_("@@image file `%s' (for text) unreadable: %s"),
                        fullname, strerror (errno));
d3452 2
d3460 4
d3483 2
a3484 4
void
set (name, value)
     char *name;
     char *value;
d3501 7
d3511 2
a3512 3
void
clear (name)
     char *name;
d3536 6
d3545 2
a3546 3
char *
set_p (name)
     char *name;
d3559 1
a3559 1
cm_set ()
d3566 1
a3566 1
cm_clear ()
d3572 1
a3572 1
cm_ifset ()
d3578 1
a3578 1
cm_ifclear ()
d3590 1
a3590 1
cm_ifeq ()
d3610 1
a3610 2
cm_value (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d3614 6
d3634 2
a3635 2
	 textual transformations like "--" into "-", since @@set didn't
	 do that when it grabbed the name of the variable.  */
d3660 3
a3662 3
	 we are called with arg == END, the reader loop already
	 popped the brace stack, which restored in_fixed_width_font,
	 among other things.  */
d3665 8
a3672 1
        execute_string ("%s", value);
d3674 4
a3677 1
        add_word_args (_("{No value for `%s'}"), name);
d3684 2
a3685 3
void
handle_variable (action)
     int action;
d3699 2
a3700 4
void
handle_variable_internal (action, name)
     int action;
     char *name;
d3833 3
a3835 3
		file_line_error (input_filename, orig_line_number,
				 _("Reached eof before matching @@end %s"),
				 condition);
a3855 1

d3866 2
a3867 3
EXECUTION_STRING *
get_execution_string (initial_size)
     int initial_size;
d3915 1
a3915 3
maybe_update_execution_strings (text, new_len)
     char **text;
     unsigned new_len;
d3959 1
a3959 1
  char *temp_string;
d3963 1
d3980 1
d3982 1
a3982 1
  input_text_length = strlen (temp_string);
d3986 13
a3998 1
  free (input_filename);
d4003 1
d4008 3
a4010 3
   expand Texinfo commands.  If IMPLICIT_CODE is set, expand @@code{STR}.
   This is generally used for short texts; filling, indentation, and
   html escapes are disabled.  */
d4013 11
a4023 3
expansion (str, implicit_code)
    char *str;
    int implicit_code;
d4026 1
a4026 1
  
d4038 2
a4039 2
  escape_html = 0;
  
d4045 2
a4046 2
  escape_html = saved_escape_html;  
  
d4053 1
a4053 1
   etc., are not reset.  */
d4056 1
a4056 3
full_expansion (str, implicit_code)
    char *str;
    int implicit_code;
d4080 2
a4081 2
		      ? EXECUTE_STRING_MAX - 1 - sizeof("@@code{}")
		      : EXECUTE_STRING_MAX - 1))
d4113 1
a4113 2
text_expansion (str)
    char *str;
d4118 2
a4119 1
  
d4122 1
d4126 2
a4127 1
  
d4140 1
a4140 2
set_paragraph_indent (string)
     char *string;
@


1.6
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.171 1999/09/19 15:24:44 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99
d37 1
a37 28

/* We'd like to take advantage of _doprnt if it's around, a la error.c,
   but then we'd have no VA_SPRINTF.  */
#if HAVE_VPRINTF
# if __STDC__
#  include <stdarg.h>
#  define VA_START(args, lastarg) va_start(args, lastarg)
# else
#  include <varargs.h>
#  define VA_START(args, lastarg) va_start(args)
# endif
# define VA_FPRINTF(file, fmt, ap) vfprintf (file, fmt, ap)
# define VA_SPRINTF(str, fmt, ap) vsprintf (str, fmt, ap)
#else /* not HAVE_VPRINTF */
# define VA_START(args, lastarg)
# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
# define va_end(args)
#endif

/* DJGPP supports /dev/null, which is okay for Unix aficionados,
   shell scripts and Makefiles, but interactive DOS die-hards
   would probably want to have NUL as well.  */
#ifdef __DJGPP__
# define ALSO_NULL_DEVICE  "NUL"
#else
# define ALSO_NULL_DEVICE  ""
#endif
d69 1
d134 3
d242 32
a273 1
/* Just like error (), but print the line number as well. */
d373 7
a379 26
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n\
\n\
Translate Texinfo source documentation to various other formats:\n\
Info files suitable for reading online with Emacs or standalone GNU Info\n\
(by default); plain text (with --no-headers); or HTML (with --html).\n\
\n\
Options:\n\
 --commands-in-node-names  allow @@ commands in node names.\n\
 -D VAR                    define a variable, as with @@set.\n\
 -E, --macro-expand FILE   output macro-expanded source to FILE.\n\
 --error-limit=NUM         quit after NUM errors (default %d).\n\
 --fill-column=NUM         break Info lines at NUM characters (default %d).\n\
 --footnote-style=STYLE    output footnotes according to STYLE:\n\
                            `separate' to place footnotes in their own node,\n\
                            `end' to place the footnotes at the end of the\n\
                             node in which they are defined (the default).\n\
 --force                   preserve output even if errors.\n\
 --help                    display this help and exit.\n\
 --html                    output HTML rather than Info format;\n\
 -I DIR                    append DIR to the @@include search path.\n\
 --ifhtml                  process @@ifhtml and @@html text even when not\n\
                             generating HTML.\n\
 --ifinfo                  process @@ifinfo text even when generating HTML.\n\
 --iftex                   process @@iftex and @@tex text.\n\
                             implies --no-split.\n"),
	    progname, max_error_level, fill_column);
d381 49
a429 21
 --no-headers              suppress Info node separators and Node: lines and\n\
                             write to standard output without --output.\n\
 --no-ifhtml               do not process @@ifhtml and @@html text.\n\
 --no-ifinfo               do not process @@ifinfo text.\n\
 --no-iftex                do not process @@iftex and @@tex text.\n\
 --no-split                suppress splitting of large Info output files or\n\
                           generation of one HTML file per node.\n\
 --no-validate             suppress node cross-reference validation.\n\
 --no-warn                 suppress warnings (but not errors).\n\
 --number-sections         include chapter, section, etc. numbers in output.\n\
 -o, --output=FILE         output to FILE, ignoring any @@setfilename.\n\
 -P DIR                    prepend DIR to the @@include search path.\n\
 --paragraph-indent=VAL    indent Info paragraphs by VAL spaces (default %d).\n\
                             if VAL is `none', do not indent;\n\
                             if VAL is `asis', preserve existing indentation.\n\
 --reference-limit=NUM     warn about at most NUM references (default %d).\n\
 -U VAR                    undefine a variable, as with @@clear.\n\
 -v, --verbose             explain what is being done.\n\
 --version                 display version information and exit.\n\
"),
            paragraph_start_indent, reference_warning_limit);
d431 29
d461 1
a461 5
  puts (_("\n\
The defaults for the @@if... conditionals depend on the output format:\n\
if generating HTML, --ifhtml is on and the others are off;\n\
if generating Info or plain text, --ifinfo is on and the others are off.\n\
\n\
d463 5
a467 5
  makeinfo foo.texi                    write Info to foo's @@setfilename\n\
  makeinfo --html foo.texi             write HTML to foo's @@setfilename\n\
  makeinfo --no-headers -o - foo.texi  write plain text to standard output\n\
  makeinfo --number-sections foo.texi  write Info with numbered sections\n\
  makeinfo --no-split foo.texi         write one Info file however big\n\
d469 6
d476 3
a478 1
general questions and discussion to help-texinfo@@gnu.org."));
d485 2
d495 1
d501 1
d514 1
d517 1
d546 1
a546 1
  while ((c = getopt_long (argc, argv, "D:e:E:f:hI:o:p:P:r:s:U:vV:w",
d560 6
d572 1
a572 1
              usage (stderr, 1);
d617 1
d672 10
d693 1
a693 1
                  "1999");
a699 2
          process_info = 0;
          splitting = 0; /* too complicated for now */
d702 5
d745 6
d752 6
d1062 1
d1085 1
d1113 6
a1118 1
      if (input_text[i] == '{')
d1121 7
a1127 1
        brace--;
d1295 84
d1448 4
a1451 2
      if (html)
        { /* Change any extension to .html.  */
d1456 1
d1469 1
a1469 1
          strcat (html_name, ".html");
d1484 1
a1484 1
      command_output_filename = NULL;
d1488 1
d1495 2
a1496 1
          fprintf (stderr, _("%s: Skipping macro expansion to stdout as Info output is going there.\n"),
d1506 10
a1515 1
      if (!real_output_filename)
d1527 4
a1530 1
            no_headers ? "text" : (html ? "HTML" : "info"),
d1541 1
d1560 1
a1560 1
  if (!no_headers && !html)
d1566 3
d1607 1
d1620 1
a1620 1
        split_file (real_output_filename, 0);
d1727 8
a1734 1
      add_word ("<li><a href=\"");
d1759 4
d1995 2
d2005 2
d2024 10
a2033 2
              line_error (_("Misplaced %c"), '{');
              remember_brace (misplaced_brace);
d2084 1
a2084 1
  new->command = xstrdup (command);
a2165 1
          int temp_line_number = line_number;
a2166 1
          line_number = brace_stack->line;
d2168 3
a2170 2
          line_error (_("%c%s missing close brace"), COMMAND_PREFIX, proc_name);
          line_number = temp_line_number;
d2250 12
d2268 6
d2294 3
a2296 1
  if (non_splitting_words && strchr (" \t\n", character))
d2298 1
a2298 1
      if (html)
d2369 8
a2522 7
  /* This is sad, but it seems desirable to not force any particular
     order on the front matter commands.  This way, the document can do
     @@settitle, @@documentlanguage, etc, in any order and with any
     omissions, and we'll still output the html <head> `just in time'.  */
  if (!executing_string && html && !html_output_head_p)
    html_output_head ();
    
d2954 62
a3015 1
      if (html)
d3023 120
a3142 103
      if (*arg5 || *arg4)
        {
          char *node_name;

          if (!*arg2)
            {
              if (*arg3)
                node_name = arg3;
              else
                node_name = arg1;
            }
          else
            node_name = arg2;

          if (html)
            {
              /* html fixxme: revisit this; external node name not
                 much use to us with numbered nodes. */
              add_word ("<a href=");
              execute_string ("\"%s.html#", arg4);
              /* Do not collapse -- to -, etc., in references.  */
              in_fixed_width_font++;
              tem = expansion (node_name, 0);
              in_fixed_width_font--;
              add_escaped_anchor_name (tem);
              free (tem);
              add_word ("\">");
              execute_string ("%s", arg1);
              add_word ("</a>");
            }
          else
            {
              execute_string ("%s:", node_name);
              in_fixed_width_font++;
              execute_string (" (%s)%s%s", arg4, arg1, px_ref_flag ? "." : "");
              in_fixed_width_font--;
            }

          /* Free all of the arguments found. */
          if (arg1) free (arg1);
          if (arg2) free (arg2);
          if (arg3) free (arg3);
          if (arg4) free (arg4);
          if (arg5) free (arg5);
          return;
        }
      else
        remember_node_reference (arg1, line_number, followed_reference);

      if (*arg3)
        {
          if (html)
            {
              add_word ("<a href=\"");
              in_fixed_width_font++;
              tem = expansion (arg1, 0);
              in_fixed_width_font--;
              add_anchor_name (tem, 1);
              free (tem);
              add_word ("\">");
              execute_string ("%s", *arg2 ? arg2 : arg3);
              add_word ("</a>");
            }
          else
            {
              execute_string ("%s:", *arg2 ? arg2 : arg3);
              in_fixed_width_font++;
              execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
              in_fixed_width_font--;
            }
        }
      else
        {
          if (html)
            {
              add_word ("<a href=\"");
              in_fixed_width_font++;
              tem = expansion (arg1, 0);
              in_fixed_width_font--;
              add_anchor_name (tem, 1);
              free (tem);
              add_word ("\">");
              execute_string ("%s", *arg2 ? arg2 : arg1);
              add_word ("</a>");
            }
          else
            {
              if (*arg2)
                {
                  execute_string ("%s:", arg2);
                  in_fixed_width_font++;
                  execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
                  in_fixed_width_font--;
                }
              else
                {
                  in_fixed_width_font++;
                  execute_string ("%s::", arg1);
                  in_fixed_width_font--;
                }
            }
        }

d3210 23
a3232 1
      if (html)
d3234 2
d3238 9
a3246 4
          add_word ("<a href=");
          execute_string ("\"%s.html\"", file);
          add_word (">");
          execute_string ("%s", pname);
d3248 1
d3276 21
a3296 1
      if (html)
d3298 1
a3298 1
          add_word ("<a href=");
d3345 22
a3366 1
      if (html)
d3368 1
a3368 1
          add_word ("<a href=");
d3398 1
a3398 1
  char *name_arg, *rest;
d3404 1
a3404 1
  /* We don't (yet) care about any other args, but read them so they
d3412 2
d3417 2
a3418 1
      char *fullname = xmalloc (strlen (name_arg) + 4 + 1);
d3421 13
a3433 1
        { /* fixxme It would be nice to insert more useful alt text.  */
d3440 2
a3441 1
                  line_error (_("No .png or .jpg for `%s'"), name_arg);
d3445 1
d3447 13
a3459 2
          add_word_args ("<img src=\"%s\" alt=\"%s\">", fullname, fullname);
        }
d3490 2
a3491 2
            warning (_("@@image file `%s' unreadable: %s"), fullname,
                       strerror (errno));
d3501 4
d3849 3
a3851 7
                {
                  int save = line_number;
                  line_number = orig_line_number;
                  line_error (_("Reached eof before matching @@end %s"),
                              condition);
                  line_number = save;
                }
d3964 3
d3984 1
a3984 1
  es = get_execution_string (4000);
d4013 3
a4015 1
   expand Texinfo commands.  If IMPLICIT_CODE is set, expand @@code{STR}.  */
d4022 35
d4065 1
a4065 7
  /* Inhibit indentation and filling, so that extra newlines
     are not added to the expansion.  (This is undesirable if
     we write the expanded text to macro_expansion_output_stream.)  */
  int saved_filling_enabled = filling_enabled;
  int saved_indented_fill = indented_fill;
  int saved_no_indent = no_indent;
  int saved_escape_html = escape_html;
a4075 5
  filling_enabled = 0;
  indented_fill = 0;
  no_indent = 1;
  escape_html = 0;

d4078 6
a4083 1
  execute_string (implicit_code ? "@@code{%s}" : "%s", str);
d4095 1
d4099 1
a4099 4
  filling_enabled = saved_filling_enabled;
  indented_fill = saved_indented_fill;
  no_indent = saved_no_indent;
  escape_html = saved_escape_html;
d4117 1
d4120 1
d4123 1
@


1.5
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* Makeinfo -- convert Texinfo source files into Info files.
   $Id: makeinfo.c,v 1.60 1998/02/25 20:36:22 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98
a22 8
/* Indent #pragma so that older Cpp's don't try to parse it. */
#ifdef _AIX
 #pragma alloca
#endif /* _AIX */

int major_version = 1;
int minor_version = 68;

d26 11
a36 18
#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif /* !TM_IN_SYS_TIME */

#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
char *alloca ();
#  endif
# endif
#endif
d57 9
a74 5
/* Define DEFAULT_INDENTATION_INCREMENT as an integer which is the amount
   that @@example should increase indentation by.  This incremement is used
   for all insertions which indent the enclosed text. */
#define DEFAULT_INDENTATION_INCREMENT 5

a86 52

/* Define HAVE_MACROS to enable the macro facility of Texinfo.  Using this
   facility, users can create their own command procedures with
   arguments.   Must always be defined.  */
#define HAVE_MACROS


#define COMPILING_MAKEINFO
#include "makeinfo.h"

/* Nonzero means that we are currently hacking the insides of an
   insertion which would use a fixed width font. */
static int in_fixed_width_font = 0;

/* Nonzero means that start_paragraph () MUST be called before we pay
   any attention to close_paragraph () calls. */
int must_start_paragraph = 0;

/* Nonzero means a string is in execution, as opposed to a file. */
static int executing_string = 0;

/* Nonzero means a macro string is in execution, as opposed to a file. */
static int me_executing_string = 0;

#if defined (HAVE_MACROS)
/* If non-NULL, this is an output stream to write the full macro expansion
   of the input text to.  The result is another texinfo file, but
   missing @@include, @@infoinclude, @@macro, and macro invocations.  Instead,
   all of the text is placed within the file. */
FILE *macro_expansion_output_stream = (FILE *)NULL;
char *macro_expansion_filename;

/* Here is a structure used to remember input text strings and offsets
   within them. */
typedef struct {
  char *pointer;                /* Pointer to the input text. */
  int offset;                   /* Offset of the last character output. */
} ITEXT;

static ITEXT **itext_info = (ITEXT **)NULL;
static int itext_size = 0;

/* Nonzero means to inhibit writing macro expansions to the output
   stream, because it has already been written. */
int me_inhibit_expansion = 0;

ITEXT *remember_itext ();
void forget_itext (), me_append_before_this_command ();
void append_to_expansion_output (), write_region_to_macro_output ();
void maybe_write_itext (), me_execute_string ();
#endif /* HAVE_MACROS */

d88 1
a88 15
/* **************************************************************** */
/*                                                                  */
/*                          Global Variables                        */
/*                                                                  */
/* **************************************************************** */

/* Global pointer to argv[0]. */
char *progname;

/* Return nonzero if STRING is the text at input_text + input_text_offset,
   else zero. */
#define looking_at(string) \
  (strncmp (input_text + input_text_offset, string, strlen (string)) == 0)

/* And writing to the output. */
d91 1
a91 2
char *output_filename = (char *)NULL;
char *pretty_output_filename;
d95 1
a95 1
char *command_output_filename = (char *)NULL;
d97 3
a99 6
/* A colon separated list of directories to search for files included
   with @@include.  This can be controlled with the `-I' option to makeinfo. */
char *include_files_path = (char *)NULL;

/* Position in the output file. */
int output_position;
a103 10
/* Nonzero indicates that filling will take place on long lines. */
int filling_enabled = 1;

/* Nonzero means that words are not to be split, even in long lines.  This
   gets changed for cm_w (). */
int non_splitting_words = 0;

/* Nonzero indicates that filling a line also indents the new line. */
int indented_fill = 0;

a113 6
/* Nonzero means that the use of paragraph_start_indent is inhibited.
   @@example uses this to line up the left columns of the example text.
   A negative value for this variable is incremented each time it is used.
   @@noindent uses this to inhibit indentation for a single paragraph.  */
int inhibit_paragraph_indentation = 0;

a118 24
/* The amount that indentation increases/decreases by. */
int default_indentation_increment = DEFAULT_INDENTATION_INCREMENT;

/* Nonzero indicates that indentation is temporarily turned off. */
int no_indent = 1;

/* Nonzero means forcing output text to be flushright. */
int force_flush_right = 0;

/* Nonzero means that the footnote style for this document was set on
   the command line, which overrides any other settings. */
int footnote_style_preset = 0;

/* Nonzero means that we automatically number footnotes that have no
   specified marker. */
int number_footnotes = 1;

/* The current footnote number in this node.  Each time a new node is
   started this is reset to 1. */
int current_footnote_number = 1;

/* Command name in the process of being hacked. */
char *command;

a122 8
/* A search string which is used to find a line defining a node. */
char node_search_string[] =
  { '\n', COMMAND_PREFIX, 'n', 'o', 'd', 'e', ' ', 0 };

/* A search string which is used to find a line defining a menu. */
char menu_search_string[] =
  { '\n', COMMAND_PREFIX, 'm', 'e', 'n', 'u', 0 };

a127 51
/* A stack of file information records.  If a new file is read in with
   "@@input", we remember the old input file state on this stack. */
typedef struct fstack
{
  struct fstack *next;
  char *filename;
  char *text;
  int size;
  int offset;
  int line_number;
} FSTACK;

FSTACK *filestack = (FSTACK *) NULL;

/* Stuff for nodes. */
/* The current nodes node name. */
char *current_node = (char *)NULL;

/* The current nodes section level. */
int current_section = 0;

/* The filename of the current input file.  This is never freed. */
char *node_filename = (char *)NULL;

/* What we remember for each node. */
typedef struct tentry
{
  struct tentry *next_ent;
  char *node;           /* name of this node. */
  char *prev;           /* name of "Prev:" for this node. */
  char *next;           /* name of "Next:" for this node. */
  char *up;             /* name of "Up:" for this node.   */
  int position;         /* output file position of this node. */
  int line_no;          /* defining line in source file. */
  char *filename;       /* The file that this node was found in. */
  int touched;          /* Nonzero means this node has been referenced. */
  int flags;            /* Room for growth.  Right now, contains 1 bit. */
} TAG_ENTRY;

/* If node-a has a "Next" for node-b, but node-b has no "Prev" for node-a,
   we turn on this flag bit in node-b's tag entry.  This means that when
   it is time to validate node-b, we don't report an additional error
   if there was no "Prev" field. */
#define PREV_ERROR 0x1
#define NEXT_ERROR 0x2
#define UP_ERROR   0x4
#define NO_WARN    0x8
#define IS_TOP     0x10

TAG_ENTRY *tag_table = (TAG_ENTRY *) NULL;

a133 55
#if defined (HAVE_MACROS)
#define ME_RECURSE      0x01
#define ME_QUOTE_ARG    0x02

/* Macro definitions for user-defined commands. */
typedef struct {
  char *name;                   /* Name of the macro. */
  char **arglist;               /* Args to replace when executing. */
  char *body;                   /* Macro body. */
  char *source_file;            /* File where this macro is defined. */
  int source_lineno;            /* Line number within FILENAME. */
  int inhibited;                /* Nonzero means make find_macro () fail. */
  int flags;                    /* ME_RECURSE, ME_QUOTE_ARG, etc. */
} MACRO_DEF;

void add_macro (), execute_macro ();
MACRO_DEF *find_macro (), *delete_macro ();
#endif /* HAVE_MACROS */

/* Menu reference, *note reference, and validation hacking. */

/* The various references that we know about. */
enum reftype
{
  menu_reference, followed_reference
};

/* A structure to remember references with.  A reference to a node is
   either an entry in a menu, or a cross-reference made with [px]ref. */
typedef struct node_ref
{
  struct node_ref *next;
  char *node;                   /* Name of node referred to. */
  char *containing_node;        /* Name of node containing this reference. */
  int line_no;                  /* Line number where the reference occurs. */
  int section;                  /* Section level where the reference occurs. */
  char *filename;               /* Name of file where the reference occurs. */
  enum reftype type;            /* Type of reference, either menu or note. */
} NODE_REF;

/* The linked list of such structures. */
NODE_REF *node_references = (NODE_REF *) NULL;

/* Flag which tells us whether to examine menu lines or not. */
int in_menu = 0;

/* Flag which tells us how to examine menu lines. */
int in_detailmenu = 0;

/* Nonzero means that we have seen "@@top" once already. */
int top_node_seen = 0;

/* Nonzero means that we have seen a non-"@@top" node already. */
int non_top_node_seen = 0;

a141 6
/* Default is to check node references. */
int validating = 1;

/* Nonzero means do not output "Node: Foo" for node separations. */
int no_headers = 0;

d145 7
a151 2
/* Maximum number of references to a single node before complaining. */
int reference_warning_limit = 1000;
d153 3
a155 16
/* Nonzero means print out information about what is going on when it
   is going on. */
int verbose_mode = 0;

/* Nonzero means to be relaxed about the input file.  This is useful when
   we can successfully format the input, but it doesn't strictly match our
   somewhat pedantic ideas of correctness.  Right now, it affects what
   @@table and @@itemize do without arguments. */
int allow_lax_format = 0;

/* The list of commands that we hack in texinfo.  Each one
   has an associated function.  When the command is encountered in the
   text, the associated function is called with START as the argument.
   If the function expects arguments in braces, it remembers itself on
   the stack.  When the corresponding close brace is encountered, the
   function is called with END as the argument. */
d157 2
a158 2
#define START 0
#define END 1
d164 1
d169 1
a169 1
BRACE_ELEMENT *brace_stack = (BRACE_ELEMENT *) NULL;
d171 1
a171 1
extern void do_multitable ();
a172 2
void print_version_info ();
void usage ();
d174 1
a174 1
void remember_error (), flush_file_stack ();
d180 1
a180 1
void free_node_references (), do_enumeration (), handle_variable ();
d183 2
a184 3
void undefindex (), top_defindex (), gen_defindex ();
void define_user_command ();
void free_pending_notes (), output_pending_notes ();
a186 1
char *expansion ();
d191 1
a191 1
void reader_loop (), read_command ();
d196 1
a196 1
void close_paragraph_with_lines (), close_paragraph ();
d200 14
d221 1
a221 1
#endif /* will not use prototypes */
d223 1
a223 348
void insert_self (), insert_space (), cm_ignore_line ();

void
  cm_TeX (), cm_asterisk (), cm_bullet (), cm_cite (),
  cm_code (), cm_copyright (), cm_ctrl (), cm_dfn (), cm_dircategory (),
  cm_direntry (), cm_dots (), cm_emph (), cm_enddots (),
  cm_kbd (), cm_key (), cm_no_op (), cm_no_op_line_arg (),
  cm_not_fixed_width (), cm_strong (), cm_var_sc (), cm_w (), cm_image ();

/* Sectioning.  */
void
  cm_chapter (), cm_unnumbered (), cm_appendix (), cm_top (),
  cm_section (), cm_unnumberedsec (), cm_appendixsec (),
  cm_subsection (), cm_unnumberedsubsec (), cm_appendixsubsec (),
  cm_subsubsection (), cm_unnumberedsubsubsec (), cm_appendixsubsubsec (),
  cm_heading (), cm_chapheading (), cm_subheading (), cm_subsubheading (),
  cm_majorheading (), cm_raisesections (), cm_lowersections ();

/* All @@def... commands map to cm_defun, most accent commands map to
   cm_accent, most non-English letters map to cm_special_char.  */
void cm_defun (), cm_accent (), cm_special_char (), cm_dotless ();

void
  cm_node (), cm_menu (), cm_xref (), cm_ftable (), cm_vtable (), cm_pxref (),
  cm_inforef (), cm_uref (), cm_email (), cm_quotation (),
  cm_display (), cm_itemize (),
  cm_enumerate (), cm_tab (), cm_table (), cm_itemx (), cm_noindent (),
  cm_setfilename (), cm_br (), cm_sp (), cm_page (), cm_group (),
  cm_center (), cm_include (), cm_bye (), cm_item (), cm_end (),
  cm_ifinfo (), cm_ifnothtml (), cm_ifnottex (), cm_kindex (), cm_cindex (),
  cm_findex (), cm_pindex (), cm_vindex (), cm_tindex (),
  cm_synindex (), cm_printindex (), cm_minus (), cm_footnote (),
  cm_example (), cm_smallexample (), cm_lisp (), cm_format (), cm_exdent (),
  cm_defindex (), cm_defcodeindex (), cm_result (), cm_expansion (),
  cm_equiv (), cm_print (), cm_error (), cm_point (), cm_today (),
  cm_flushleft (), cm_flushright (), cm_smalllisp (), cm_finalout (),
  cm_cartouche (), cm_detailmenu (), cm_multitable ();

/* Conditionals. */
void cm_set (), cm_clear (), cm_ifset (), cm_ifclear ();
void cm_value (), cm_ifeq ();

#if defined (HAVE_MACROS)
/* Define a user-defined command which is simple substitution. */
void cm_macro (), cm_unmacro ();
#endif /* HAVE_MACROS */

/* Options. */
void cm_paragraphindent (), cm_footnotestyle ();

/* Internals. */
void command_name_condition (), misplaced_brace (), cm_obsolete (),
     cm_ideprecated ();

typedef struct
{
  char *name;
  COMMAND_FUNCTION *proc;
  int argument_in_braces;
} COMMAND;

/* Stuff for defining commands on the fly. */
COMMAND **user_command_array = (COMMAND **) NULL;
int user_command_array_len = 0;

#define NO_BRACE_ARGS 0
#define BRACE_ARGS 1

static COMMAND command_table[] = {
  { "\t", insert_space, NO_BRACE_ARGS },
  { "\n", insert_space, NO_BRACE_ARGS },
  { " ", insert_self, NO_BRACE_ARGS },
  { "!", insert_self, NO_BRACE_ARGS },
  { "\"", insert_self, NO_BRACE_ARGS },
  { "'", insert_self, NO_BRACE_ARGS },
  { "*", cm_asterisk, NO_BRACE_ARGS },
  { ",", cm_accent, BRACE_ARGS },
  { "-", cm_no_op, NO_BRACE_ARGS },
  { ".", insert_self, NO_BRACE_ARGS },
  { ":", cm_no_op, NO_BRACE_ARGS },
  { "=", insert_self, NO_BRACE_ARGS },
  { "?", insert_self, NO_BRACE_ARGS },
  { "@@", insert_self, NO_BRACE_ARGS },
  { "^", insert_self, NO_BRACE_ARGS },
  { "`", insert_self, NO_BRACE_ARGS },
  { "{", insert_self, NO_BRACE_ARGS },
  { "|", cm_no_op, NO_BRACE_ARGS },
  { "}", insert_self, NO_BRACE_ARGS },
  { "~", insert_self, NO_BRACE_ARGS },
  { "AA", insert_self, BRACE_ARGS },
  { "AE", insert_self, BRACE_ARGS },
  { "H", cm_accent, BRACE_ARGS },
  { "L", cm_special_char, BRACE_ARGS },
  { "O", cm_special_char, BRACE_ARGS },
  { "OE", insert_self, BRACE_ARGS },
  { "TeX", cm_TeX, BRACE_ARGS },
  { "aa", insert_self, BRACE_ARGS },
  { "ae", insert_self, BRACE_ARGS },
  { "appendix", cm_appendix, NO_BRACE_ARGS },
  { "appendixsection", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsec", cm_appendixsec, NO_BRACE_ARGS },
  { "appendixsubsec", cm_appendixsubsec, NO_BRACE_ARGS },
  { "appendixsubsubsec", cm_appendixsubsubsec, NO_BRACE_ARGS },
  { "asis", cm_no_op, BRACE_ARGS },
  { "b", cm_not_fixed_width, BRACE_ARGS },
  { "bullet", cm_bullet, BRACE_ARGS },
  { "bye", cm_bye, NO_BRACE_ARGS },
  { "c", cm_ignore_line, NO_BRACE_ARGS },
  { "cartouche", cm_cartouche, NO_BRACE_ARGS },
  { "center", cm_center, NO_BRACE_ARGS },
  { "centerchap", cm_unnumbered, NO_BRACE_ARGS },
  { "chapheading", cm_chapheading, NO_BRACE_ARGS },
  { "chapter", cm_chapter, NO_BRACE_ARGS },
  { "cindex", cm_cindex, NO_BRACE_ARGS },
  { "cite", cm_cite, BRACE_ARGS },
  { "clear", cm_clear, NO_BRACE_ARGS },
  { "code", cm_code, BRACE_ARGS },
  { "comment", cm_ignore_line, NO_BRACE_ARGS },
  { "contents", cm_no_op, NO_BRACE_ARGS },
  { "copyright", cm_copyright, BRACE_ARGS },
  { "ctrl", cm_obsolete, BRACE_ARGS },
  { "defcodeindex", cm_defcodeindex, NO_BRACE_ARGS },
  { "defindex", cm_defindex, NO_BRACE_ARGS },
/* The `def' commands. */
  { "defcv", cm_defun, NO_BRACE_ARGS },
  { "defcvx", cm_defun, NO_BRACE_ARGS },
  { "deffn", cm_defun, NO_BRACE_ARGS },
  { "deffnx", cm_defun, NO_BRACE_ARGS },
  { "defivar", cm_defun, NO_BRACE_ARGS },
  { "defivarx", cm_defun, NO_BRACE_ARGS },
  { "defmac", cm_defun, NO_BRACE_ARGS },
  { "defmacx", cm_defun, NO_BRACE_ARGS },
  { "defmethod", cm_defun, NO_BRACE_ARGS },
  { "defmethodx", cm_defun, NO_BRACE_ARGS },
  { "defop", cm_defun, NO_BRACE_ARGS },
  { "defopt", cm_defun, NO_BRACE_ARGS },
  { "defoptx", cm_defun, NO_BRACE_ARGS },
  { "defopx", cm_defun, NO_BRACE_ARGS },
  { "defspec", cm_defun, NO_BRACE_ARGS },
  { "defspecx", cm_defun, NO_BRACE_ARGS },
  { "deftp", cm_defun, NO_BRACE_ARGS },
  { "deftpx", cm_defun, NO_BRACE_ARGS },
  { "deftypefn", cm_defun, NO_BRACE_ARGS },
  { "deftypefnx", cm_defun, NO_BRACE_ARGS },
  { "deftypefun", cm_defun, NO_BRACE_ARGS },
  { "deftypefunx", cm_defun, NO_BRACE_ARGS },
  { "deftypemethod", cm_defun, NO_BRACE_ARGS },
  { "deftypemethodx", cm_defun, NO_BRACE_ARGS },
  { "deftypevar", cm_defun, NO_BRACE_ARGS },
  { "deftypevarx", cm_defun, NO_BRACE_ARGS },
  { "deftypevr", cm_defun, NO_BRACE_ARGS },
  { "deftypevrx", cm_defun, NO_BRACE_ARGS },
  { "defun", cm_defun, NO_BRACE_ARGS },
  { "defunx", cm_defun, NO_BRACE_ARGS },
  { "defvar", cm_defun, NO_BRACE_ARGS },
  { "defvarx", cm_defun, NO_BRACE_ARGS },
  { "defvr", cm_defun, NO_BRACE_ARGS },
  { "defvrx", cm_defun, NO_BRACE_ARGS },
/* The end of the `def' commands. */
  { "detailmenu", cm_detailmenu, NO_BRACE_ARGS },
  { "dfn", cm_dfn, BRACE_ARGS },
  { "dircategory", cm_dircategory, NO_BRACE_ARGS },
  { "direntry", cm_direntry, NO_BRACE_ARGS },
  { "display", cm_display, NO_BRACE_ARGS },
  { "dmn", cm_no_op, BRACE_ARGS },
  { "dotaccent", cm_accent, BRACE_ARGS },
  { "dotless", cm_dotless, BRACE_ARGS },
  { "dots", cm_dots, BRACE_ARGS },
  { "email", cm_email, BRACE_ARGS },
  { "emph", cm_emph, BRACE_ARGS },
  { "end", cm_end, NO_BRACE_ARGS },
  { "enddots", cm_enddots, BRACE_ARGS },
  { "enumerate", cm_enumerate, NO_BRACE_ARGS },
  { "equiv", cm_equiv, BRACE_ARGS },
  { "error", cm_error, BRACE_ARGS },
  { "example", cm_example, NO_BRACE_ARGS },
  { "exclamdown", cm_special_char, BRACE_ARGS },
  { "exdent", cm_exdent, NO_BRACE_ARGS },
  { "expansion", cm_expansion, BRACE_ARGS },
  { "file", cm_code, BRACE_ARGS },
  { "finalout", cm_no_op, NO_BRACE_ARGS },
  { "findex", cm_findex, NO_BRACE_ARGS },
  { "flushleft", cm_flushleft, NO_BRACE_ARGS },
  { "flushright", cm_flushright, NO_BRACE_ARGS },
  { "footnote", cm_footnote, NO_BRACE_ARGS}, /* self-arg eater */
  { "footnotestyle", cm_footnotestyle, NO_BRACE_ARGS },
  { "format", cm_format, NO_BRACE_ARGS },
  { "ftable", cm_ftable, NO_BRACE_ARGS },
  { "group", cm_group, NO_BRACE_ARGS },
  { "heading", cm_heading, NO_BRACE_ARGS },
  { "headings", cm_ignore_line, NO_BRACE_ARGS },
  { "html", command_name_condition, NO_BRACE_ARGS },
  { "hyphenation", cm_no_op, BRACE_ARGS },
  { "i", cm_not_fixed_width, BRACE_ARGS },
  { "ifclear", cm_ifclear, NO_BRACE_ARGS },
  { "ifeq", cm_ifeq, NO_BRACE_ARGS },
  { "ifhtml", command_name_condition, NO_BRACE_ARGS },
  { "ifinfo", cm_ifinfo, NO_BRACE_ARGS },
  { "ifnothtml", cm_ifnothtml, NO_BRACE_ARGS },
  { "ifnotinfo", command_name_condition, NO_BRACE_ARGS },
  { "ifnottex", cm_ifnottex, NO_BRACE_ARGS },
  { "ifset", cm_ifset, NO_BRACE_ARGS },
  { "iftex", command_name_condition, NO_BRACE_ARGS },
  { "ignore", command_name_condition, NO_BRACE_ARGS },
  { "image", cm_image, BRACE_ARGS },
  { "include", cm_include, NO_BRACE_ARGS },
  { "inforef", cm_inforef, BRACE_ARGS },
  { "item", cm_item, NO_BRACE_ARGS },
  { "itemize", cm_itemize, NO_BRACE_ARGS },
  { "itemx", cm_itemx, NO_BRACE_ARGS },
  { "kbd", cm_kbd, BRACE_ARGS },
  { "kbdinputstyle", cm_no_op_line_arg, NO_BRACE_ARGS },
  { "key", cm_key, BRACE_ARGS },
  { "kindex", cm_kindex, NO_BRACE_ARGS },
  { "l", cm_special_char, BRACE_ARGS },
  { "lisp", cm_lisp, NO_BRACE_ARGS },
  { "lowersections", cm_lowersections, NO_BRACE_ARGS },
  { "macro", cm_macro, NO_BRACE_ARGS },
  { "majorheading", cm_majorheading, NO_BRACE_ARGS },
  { "math", cm_no_op, BRACE_ARGS },
  { "menu", cm_menu, NO_BRACE_ARGS },
  { "minus", cm_minus, BRACE_ARGS },
  { "multitable", cm_multitable, NO_BRACE_ARGS },
  { "need", cm_ignore_line, NO_BRACE_ARGS },
  { "node", cm_node, NO_BRACE_ARGS },
  { "noindent", cm_noindent, NO_BRACE_ARGS },
  { "nwnode", cm_node, NO_BRACE_ARGS },
  { "o", cm_special_char, BRACE_ARGS },
  { "oe", insert_self, BRACE_ARGS },
  { "page", cm_no_op, NO_BRACE_ARGS },
  { "paragraphindent", cm_paragraphindent, NO_BRACE_ARGS },
  { "pindex", cm_pindex, NO_BRACE_ARGS },
  { "point", cm_point, BRACE_ARGS },
  { "pounds", cm_special_char, BRACE_ARGS },
  { "print", cm_print, BRACE_ARGS },
  { "printindex", cm_printindex, NO_BRACE_ARGS },
  { "pxref", cm_pxref, BRACE_ARGS },
  { "questiondown", cm_special_char, BRACE_ARGS },
  { "quotation", cm_quotation, NO_BRACE_ARGS },
  { "r", cm_not_fixed_width, BRACE_ARGS },
  { "raisesections", cm_raisesections, NO_BRACE_ARGS },
  { "ref", cm_xref, BRACE_ARGS },
  { "refill", cm_no_op, NO_BRACE_ARGS },
  { "result", cm_result, BRACE_ARGS },
  { "ringaccent", cm_accent, BRACE_ARGS },
  { "samp", cm_code, BRACE_ARGS },
  { "sc", cm_var_sc, BRACE_ARGS },
  { "section", cm_section, NO_BRACE_ARGS },
  { "set", cm_set, NO_BRACE_ARGS },
  { "setchapternewpage", cm_ignore_line, NO_BRACE_ARGS },
  { "setchapterstyle", cm_obsolete, NO_BRACE_ARGS },
  { "setfilename", cm_setfilename, NO_BRACE_ARGS },
  { "settitle", cm_ignore_line, NO_BRACE_ARGS },
  { "shortcontents", cm_no_op, NO_BRACE_ARGS },
  { "shorttitlepage", cm_ignore_line, NO_BRACE_ARGS },
  { "smallbook", cm_ignore_line, NO_BRACE_ARGS },
  { "smallexample", cm_smallexample, NO_BRACE_ARGS },
  { "smalllisp", cm_smalllisp, NO_BRACE_ARGS },
  { "sp", cm_sp, NO_BRACE_ARGS },
  { "ss", insert_self, BRACE_ARGS },
  { "strong", cm_strong, BRACE_ARGS },
  { "subheading", cm_subheading, NO_BRACE_ARGS },
  { "subsection", cm_subsection, NO_BRACE_ARGS },
  { "subsubheading", cm_subsubheading, NO_BRACE_ARGS },
  { "subsubsection", cm_subsubsection, NO_BRACE_ARGS },
  { "summarycontents", cm_no_op, NO_BRACE_ARGS },
  { "syncodeindex", cm_synindex, NO_BRACE_ARGS },
  { "synindex", cm_synindex, NO_BRACE_ARGS },
  { "t", cm_no_op, BRACE_ARGS },
  { "tab", cm_tab, NO_BRACE_ARGS },
  { "table", cm_table, NO_BRACE_ARGS },
  { "tex", command_name_condition, NO_BRACE_ARGS },
  { "tieaccent", cm_accent, BRACE_ARGS },
  { "tindex", cm_tindex, NO_BRACE_ARGS },
  { "titlefont", cm_not_fixed_width, BRACE_ARGS },
  { "titlepage", command_name_condition, NO_BRACE_ARGS },
  { "today", cm_today, BRACE_ARGS },
  { "top", cm_top, NO_BRACE_ARGS  },
  { "u", cm_accent, BRACE_ARGS },
  { "ubaraccent", cm_accent, BRACE_ARGS },
  { "udotaccent", cm_accent, BRACE_ARGS },
#if defined (HAVE_MACROS)
  { "unmacro", cm_unmacro, NO_BRACE_ARGS },
#endif
  { "unnumbered", cm_unnumbered, NO_BRACE_ARGS },
  { "unnumberedsec", cm_unnumberedsec, NO_BRACE_ARGS },
  { "unnumberedsubsec", cm_unnumberedsubsec, NO_BRACE_ARGS },
  { "unnumberedsubsubsec", cm_unnumberedsubsubsec, NO_BRACE_ARGS },
  { "uref", cm_uref, BRACE_ARGS },
  { "url", cm_code, BRACE_ARGS },
  { "v", cm_accent, BRACE_ARGS },
  { "value", cm_value, BRACE_ARGS },
  { "var", cm_var_sc, BRACE_ARGS },
  { "vindex", cm_vindex, NO_BRACE_ARGS },
  { "vtable", cm_vtable, NO_BRACE_ARGS },
  { "w", cm_w, BRACE_ARGS },
  { "xref", cm_xref, BRACE_ARGS },

  /* Deprecated commands.  These used to be for italics.  */
  { "iappendix", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "ichapter", cm_ideprecated, NO_BRACE_ARGS },
  { "isection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumbered", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsubsec", cm_ideprecated, NO_BRACE_ARGS },

  /* Now @@include does what this was used to. */
  { "infoinclude", cm_obsolete, NO_BRACE_ARGS },
  { "titlespec", cm_obsolete, NO_BRACE_ARGS },

  { NULL, NULL, NO_BRACE_ARGS }
};

struct option long_options[] =
{
  { "error-limit", 1, 0, 'e' },                 /* formerly -el */
  { "fill-column", 1, 0, 'f' },                 /* formerly -fc */
  { "footnote-style", 1, 0, 's' },              /* formerly -ft */
  { "force", 0, 0, 'F' },                       /* do not remove output */
  { "no-headers", 0, &no_headers, 1 },          /* do not output Node: foo */
  { "no-pointer-validate", 0, &validating, 0 }, /* formerly -nv */
  { "no-validate", 0, &validating, 0 },         /* formerly -nv */
  { "no-split", 0, &splitting, 0 },             /* formerly -ns */
  { "no-warn", 0, &print_warnings, 0 },         /* formerly -nw */
  { "macro-expand", 1, 0, 'E' },
  { "number-footnotes", 0, &number_footnotes, 1 },
  { "no-number-footnotes", 0, &number_footnotes, 0 },
  { "output", 1, 0, 'o' },
  { "paragraph-indent", 1, 0, 'p' },            /* formerly -pi */
  { "reference-limit", 1, 0, 'r' },             /* formerly -rl */
  { "verbose", 0, &verbose_mode, 1 },           /* formerly -verbose */
  { "help", 0, 0, 'h' },
  { "version", 0, 0, 'V' },
  {NULL, 0, NULL, 0}
};

/* **************************************************************** */
/*                                                                  */
/*                      Error Handling                              */
/*                                                                  */
/* **************************************************************** */
d235 1
a235 1
  return (0);
d334 1
a334 1
      exit (FATAL);
d337 7
d345 119
a463 5
/* **************************************************************** */
/*                                                                  */
/*                      Main ()  Start of code                      */
/*                                                                  */
/* **************************************************************** */
a472 1
  char *filename_part ();
a475 3
  /* The name of this program is the last filename in argv[0]. */
  progname = filename_part (argv[0]);

d481 2
d490 1
a490 1
  while ((c = getopt_long (argc, argv, "D:e:E:f:I:o:p:P:r:s:U:V",
d504 1
a504 2
        case 'e':
          /* User specified error level. */
d510 1
a510 1
              usage (stderr, FATAL);
d514 1
a514 2
        case 'E':
          /* User specified a macro expansion output file. */
d527 1
a527 2
        case 'f':
          /* User specified fill_column. */
d531 1
a531 1
                       _("%s: %s arg must be numeric, not `%s'.\n"), 
d533 1
a533 1
              usage (FATAL);
d537 2
a538 6
        case 'F':
          force++; /* Do not remove erroneous output.  */
          break;
          
        case 'h':
          usage (NO_ERROR);
d549 1
a549 1
          strcat (include_files_path, ":");
d553 1
a553 2
        case 'o':
          /* User specified output file. */
d557 1
a557 2
        case 'p':
          /* User specified paragraph indent (paragraph_start_index). */
d561 1
a561 1
   _("%s: --paragraph-indent arg must be numeric/`none'/`asis', not `%s'.\n"), 
d563 1
a563 1
              usage (FATAL);
d572 1
a572 1
              include_files_path = (char *) xrealloc (include_files_path,
d574 1
a574 1
              strcat (include_files_path, ":.");
d579 1
a579 1
              include_files_path = (char *) xrealloc (include_files_path,
d587 2
a588 3
 
        case 'r':
          /* User specified reference warning limit. */
d592 1
a592 1
                     _("%s: %s arg must be numeric, not `%s'.\n"), 
d594 1
a594 1
              usage (FATAL);
d598 1
a598 2
        case 's':
          /* User specified footnote style. */
d602 1
a602 1
          _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"), 
d604 1
a604 1
              usage (FATAL);
d609 5
a613 2
        case 'V':
          /* User requested version info. */
d615 2
a616 1
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d620 9
a628 2
		  "1998");
          exit (NO_ERROR);
d632 1
a632 1
          usage (FATAL);
d637 3
d648 1
a648 1
          usage (FATAL);
a651 4
  /* If the user has specified --no-headers, this should imply --no-split.
     Do that here.  I think it might also imply that we should ignore the
     setfilename at the top of the file, but this might break some FSF things,
     so I will hold off on that. */
d654 9
d665 1
a665 1
      /* If the user has not specified an output file, use stdout. */
d683 1
a683 12
  if (errors_printed)
    return (SYNTAX);
  else
    return (NO_ERROR);
}

/* Display the version info of this invocation of Makeinfo. */
void
print_version_info ()
{
  printf ("makeinfo (GNU %s %s) %d.%d\n", PACKAGE, VERSION,
          major_version, minor_version);
a685 47
/* If EXIT_VALUE is zero, print the full usage message to stdout.
   Otherwise, just say to use --help for more info.
   Then exit with EXIT_VALUE. */
void
usage (exit_value)
     int exit_value;
{
  if (exit_value != 0)
    fprintf (stderr, _("Try `%s --help' for more information.\n"), progname);
  else
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n\
\n\
Translate Texinfo source documentation to a format suitable for reading\n\
with GNU Info.\n\
\n\
Options:\n\
-D VAR                 define a variable, as with @@set.\n\
-E MACRO-OFILE         process macros only, output texinfo source.\n\
-I DIR                 append DIR to the @@include directory search path.\n\
-P DIR                 prepend DIR to the @@include directory search path.\n\
-U VAR                 undefine a variable, as with @@clear.\n\
--error-limit NUM      quit after NUM errors (default %d).\n\
--fill-column NUM      break lines at NUM characters (default %d).\n\
--footnote-style STYLE output footnotes according to STYLE:\n\
                         `separate' to place footnotes in their own node,\n\
                         `end' to place the footnotes at the end of\n\
                         the node in which they are defined (the default).\n\
--force                preserve output even if errors.\n\
--help                 display this help and exit.\n\
--no-validate          suppress node cross-reference validation.\n\
--no-warn              suppress warnings (but not errors).\n\
--no-split             suppress splitting of large files.\n\
--no-headers           suppress node separators and Node: Foo headers.\n\
--output FILE, -o FILE output to FILE, and ignore any @@setfilename.\n\
--paragraph-indent VAL indent paragraphs with VAL spaces (default %d).\n\
                         if VAL is `none', do not indent; if VAL is `asis',\n\
                         preserve any existing indentation.\n\
--reference-limit NUM  complain about at most NUM references (default %d).\n\
--verbose              report about what is being done.\n\
--version              display version information and exit.\n\
\n\
Email bug reports to bug-texinfo@@gnu.org.\n\
"),
           progname, max_error_level, fill_column,
           paragraph_start_indent, reference_warning_limit);
  exit (exit_value);
}
d687 1
a687 1
/* Manipulating Lists */
d689 3
a691 10
typedef struct generic_list {
  struct generic_list *next;
} GENERIC_LIST;

/* Reverse the chain of structures in LIST.  Output the new head
   of the chain.  You should always assign the output value of this
   function to something, or you will lose the chain. */
GENERIC_LIST *
reverse_list (list)
     register GENERIC_LIST *list;
d693 2
a694 2
  register GENERIC_LIST *next;
  register GENERIC_LIST *prev = (GENERIC_LIST *) NULL;
d696 4
a699 1
  while (list)
d701 1
a701 9
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return (prev);
}

/* Pushing and Popping Files */
d703 2
a704 51
/* Find and load the file named FILENAME.  Return a pointer to
   the loaded file, or NULL if it can't be loaded. */
char *
find_and_load (filename)
     char *filename;
{
  struct stat fileinfo;
  long file_size;
  int file = -1, count = 0;
  char *fullpath, *result, *get_file_info_in_path ();

  result = fullpath = (char *)NULL;

  fullpath = get_file_info_in_path (filename, include_files_path, &fileinfo);

  if (!fullpath)
    goto error_exit;

  filename = fullpath;
  file_size = (long) fileinfo.st_size;

  file = open (filename, O_RDONLY);
  if (file < 0)
    goto error_exit;

  /* Load the file, with enough room for a newline and a null. */
  result = xmalloc (file_size + 2);

  /* VMS stat lies about the st_size value.  The actual number of
     readable bytes is always less than this value.  The arcane
     mysteries of VMS/RMS are too much to probe, so this hack
    suffices to make things work. */
#if defined (VMS) || defined (WIN32)
#ifdef VMS
  while ((n = read (file, result + count, file_size)) > 0)
#else /* WIN32 */
  while ((n = read (file, result + count, 1)) > 0)
#endif /* WIN32 */
    count += n;
  if (n == -1)
#else /* !VMS && !WIN32 */
    count = file_size;
    if (read (file, result, file_size) != file_size)
#endif /* !VMS && !WIN32 */
  error_exit:
    {
      if (result)
        free (result);

      if (fullpath)
        free (fullpath);
d706 3
a708 4
      if (file != -1)
        close (file);

      return ((char *) NULL);
a709 1
  close (file);
d711 8
a718 14
  /* Set the globals to the new file. */
  input_text = result;
  size_of_input_text = count;
  input_filename = fullpath;
  node_filename = xstrdup (fullpath);
  input_text_offset = 0;
  line_number = 1;
  /* Not strictly necessary.  This magic prevents read_token () from doing
     extra unnecessary work each time it is called (that is a lot of times).
     SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
  input_text[size_of_input_text] = '\n';
  /* This, on the other hand, is always necessary.  */
  input_text[size_of_input_text+1] = 0;
  return (result);
d721 4
a724 3
/* Save the state of the current input file. */
void
pushfile ()
d726 3
a728 10
  FSTACK *newstack = (FSTACK *) xmalloc (sizeof (FSTACK));
  newstack->filename = input_filename;
  newstack->text = input_text;
  newstack->size = size_of_input_text;
  newstack->offset = input_text_offset;
  newstack->line_number = line_number;
  newstack->next = filestack;

  filestack = newstack;
  push_node_filename ();
d731 1
a731 1
/* Make the current file globals be what is on top of the file stack. */
d733 2
a734 1
popfile ()
d736 2
a737 1
  FSTACK *tos = filestack;
d739 2
a740 2
  if (!tos)
    abort ();                   /* My fault.  I wonder what I did? */
d742 1
a742 2
#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream)
d744 5
a748 2
      maybe_write_itext (input_text, input_text_offset);
      forget_itext (input_text);
d750 6
a755 19
#endif /* HAVE_MACROS */

  /* Pop the stack. */
  filestack = filestack->next;

  /* Make sure that commands with braces have been satisfied. */
  if (!executing_string && !me_executing_string)
    discard_braces ();

  /* Get the top of the stack into the globals. */
  input_filename = tos->filename;
  input_text = tos->text;
  size_of_input_text = tos->size;
  input_text_offset = tos->offset;
  line_number = tos->line_number;
  free (tos);

  /* Go back to the (now) current node. */
  pop_node_filename ();
d758 1
a758 1
/* Flush all open files on the file stack. */
d760 2
a761 1
flush_file_stack ()
d763 4
a766 9
  while (filestack)
    {
      char *fname = input_filename;
      char *text = input_text;
      popfile ();
      free (fname);
      free (text);
    }
}
d768 1
a768 335
int node_filename_stack_index = 0;
int node_filename_stack_size = 0;
char **node_filename_stack = (char **)NULL;

void
push_node_filename ()
{
  if (node_filename_stack_index + 1 > node_filename_stack_size)
    node_filename_stack = (char **)xrealloc
    (node_filename_stack, (node_filename_stack_size += 10) * sizeof (char *));

  node_filename_stack[node_filename_stack_index] = node_filename;
  node_filename_stack_index++;
}

void
pop_node_filename ()
{
  node_filename = node_filename_stack[--node_filename_stack_index];
}

/* Return just the simple part of the filename; i.e. the
   filename without the path information, or extensions.
   This conses up a new string. */
char *
filename_part (filename)
     char *filename;
{
  char *basename;

  basename = strrchr (filename, '/');
  if (!basename)
    basename = filename;
  else
    basename++;

  basename = xstrdup (basename);
#if defined (REMOVE_OUTPUT_EXTENSIONS)

  /* See if there is an extension to remove.  If so, remove it. */
  {
    char *temp;

    temp = strrchr (basename, '.');
    if (temp)
      *temp = 0;
  }
#endif /* REMOVE_OUTPUT_EXTENSIONS */
  return (basename);
}

/* Return the pathname part of filename.  This can be NULL. */
char *
pathname_part (filename)
     char *filename;
{
  char *expand_filename ();
  char *result = (char *) NULL;
  register int i;

  filename = expand_filename (filename, "");

  i = strlen (filename) - 1;

  while (i && filename[i] != '/')
    i--;
  if (filename[i] == '/')
    i++;

  if (i)
    {
      result = (char *)xmalloc (1 + i);
      strncpy (result, filename, i);
      result[i] = 0;
    }
  free (filename);
  return (result);
}

char *
filename_non_directory (name)
     char *name;
{
  register int i;

  for (i = strlen (name) - 1; i; i--)
    if (name[i] == '/')
      return (xstrdup (name + i + 1));

  return (xstrdup (name));
}

/* Return the expansion of FILENAME. */
char *
expand_filename (filename, input_name)
     char *filename, *input_name;
{
  register int i;
  char *full_pathname ();

  if (filename)
    filename = full_pathname (filename);
  else
    {
      filename = filename_non_directory (input_name);

      if (!*filename)
        {
          free (filename);
          filename = xstrdup ("noname.texi");
        }

      for (i = strlen (filename) - 1; i; i--)
        if (filename[i] == '.')
          break;

      if (!i)
        i = strlen (filename);

      if (i + 6 > (strlen (filename)))
        filename = (char *)xrealloc (filename, i + 6);
      strcpy (filename + i, ".info");
      return (filename);
    }
        
  if (filename[0] == '.' || filename[0] == '/')
    return (filename);

  if (filename[0] != '/' && input_name[0] == '/')
    {
      /* Make it so that relative names work. */
      char *result;
      
      i = strlen (input_name) - 1;

      result = (char *)xmalloc (1 + strlen (input_name) + strlen (filename));
      strcpy (result, input_name);

      while (result[i] != '/' && i)
        i--;

      if (result[i] == '/')
        i++;

      strcpy (&result[i], filename);
      free (filename);
      return (result);
    }
  return (filename);
}

/* Return the full path to FILENAME. */
char *
full_pathname (filename)
     char *filename;
{
  int initial_character;
  char *result;

  /* No filename given? */
  if (!filename || !(initial_character = *filename))
    return (xstrdup (""));
  
  /* Already absolute? */
  if ((initial_character == '/') ||
      ((strncmp (filename, "./", 2) == 0) ||
       (strncmp (filename, "../", 3) == 0)))
    return (xstrdup (filename));

  if (initial_character != '~')
    {
      char *localdir;

      localdir = (char *)xmalloc (1025);
#if defined (HAVE_GETCWD)
      if (!getcwd (localdir, 1024))
#else  /*  !HAVE_GETCWD */
        if (!getwd (localdir))
#endif /* !HAVE_GETCWD */
          {
            fprintf (stderr, _("%s: getwd: %s, %s\n"),
                     progname, filename, localdir);
            exit (1);
          }

      strcat (localdir, "/");
      strcat (localdir, filename);
      result = xstrdup (localdir);
      free (localdir);
    }
  else
    {
#ifndef WIN32
      if (filename[1] == '/')
        {
          /* Return the concatenation of the environment variable HOME
             and the rest of the string. */
          char *temp_home;

          temp_home = (char *) getenv ("HOME");
          result = (char *)xmalloc (strlen (&filename[1])
                                    + 1
                                    + temp_home ? strlen (temp_home)
                                    : 0);
          *result = 0;

          if (temp_home)
            strcpy (result, temp_home);

          strcat (result, &filename[1]);
        }
      else
        {
          struct passwd *user_entry;
          int i, c;
          char *username = (char *)xmalloc (257);

          for (i = 1; (c = filename[i]); i++)
            {
              if (c == '/')
                break;
              else
                username[i - 1] = c;
            }
          if (c)
            username[i - 1] = 0;

          user_entry = getpwnam (username);

          if (!user_entry)
            return (xstrdup (filename));

          result = (char *)xmalloc (1 + strlen (user_entry->pw_dir)
                                    + strlen (&filename[i]));
          strcpy (result, user_entry->pw_dir);
          strcat (result, &filename[i]);
        }
    }
#endif /* not WIN32 */
  return (result);
}

char *
output_name_from_input_name (name)
     char *name;
{
  return (expand_filename ((char *)NULL, name));
}

/* **************************************************************** */
/*                                                                  */
/*                      Hacking Tokens and Strings                  */
/*                                                                  */
/* **************************************************************** */

/* Return the next token as a string pointer.  We cons the string. */
char *
read_token ()
{
  int i, character;
  char *result;

  /* If the first character to be read is self-delimiting, then that
     is the command itself. */
  character = curchar ();
  if (self_delimiting (character))
    {
      input_text_offset++;

      if (character == '\n')
        line_number++;

      result = xstrdup (" ");
      *result = character;
      return (result);
    }

  for (i = 0; ((input_text_offset != size_of_input_text)
               && (character = curchar ())
               && command_char (character));
       i++, input_text_offset++);
  result = (char *)xmalloc (i + 1);
  memcpy (result, &input_text[input_text_offset - i], i);
  result[i] = 0;
  return (result);
}

/* Return nonzero if CHARACTER is self-delimiting. */
int
self_delimiting (character)
     int character;
{
  /* @@; and @@\ are not Texinfo commands, but they are listed here
     anyway.  I don't know why.  --karl, 10aug96.  */
  return member (character, "~{|}`^\\@@?=;:.-,*\'\" !\n\t");
}

/* Clear whitespace from the front and end of string. */
void
canon_white (string)
     char *string;
{
  int len = strlen (string);
  int x;

  if (!len)
    return;

  for (x = 0; x < len; x++)
    {
      if (!cr_or_whitespace (string[x]))
        {
          strcpy (string, string + x);
          break;
        }
    }
  len = strlen (string);
  if (len)
    len--;
  while (len > -1 && cr_or_whitespace (string[len]))
    len--;
  string[len + 1] = 0;
}

/* Bash STRING, replacing all whitespace with just one space. */
void
fix_whitespace (string)
     char *string;
{
  char *temp = (char *)xmalloc (strlen (string) + 1);
  int string_index = 0;
  int temp_index = 0;
  int c;

  canon_white (string);
d796 1
a796 1
  int tt = (temp < 0) ? size_of_input_text : temp + strlen (string);
d806 1
a806 1
      input_text_offset = size_of_input_text - strlen (string);
d834 1
a834 1
    new_point = size_of_input_text;
d843 1
a843 1
  *string = (char *)xmalloc (len + 1);
d851 2
a852 2
  if (input_text_offset > size_of_input_text)
    input_text_offset = size_of_input_text;
d854 75
a928 1
  return (new_point);
d932 3
a934 1
   Place the characters read into STRING.  */
d940 1
a940 1
  int real_bottom = size_of_input_text;
d943 1
a943 1
    limit = size_of_input_text;
d945 3
a947 3
  /* Replace input_text[input_text_offset .. limit-1] with its macro
     expansion (actually, we expand all commands).  This allows the node
     names themselves to be constructed via a macro, as in:
d953 1
a953 1
     
d957 2
a958 9
     whole line then.
     
     Furthermore, if we're executing a string, don't do it -- we'll end
     up shrinking the execution string which is currently aliased to
     `input_text', so it might get moved, and not updated in the
     `execution_strings' array.  This happens when processing the
     (synthetic) Overview-Footnotes node in the Texinfo manual.  */

  if (expand && !executing_string && !me_executing_string)
d960 1
a960 28
      char *xp;
      unsigned xp_len, new_len;
      
      /* Get original string from input.  */
      unsigned raw_len = limit - input_text_offset;
      char *str = xmalloc (raw_len + 1);
      strncpy (str, input_text + input_text_offset, raw_len);
      str[raw_len] = 0;
      
      /* Expand it.  */
      xp = expansion (str, 0);
      xp_len = strlen (xp);
      free (str);
      
      /* Plunk the expansion into the middle of `input_text' --
         which is terminated by a newline, not a null.  */
      str = xmalloc (real_bottom - limit + 1);
      strncpy (str, input_text + limit, real_bottom - limit + 1);
      new_len = input_text_offset + xp_len + real_bottom - limit + 1;
      input_text = xrealloc (input_text, new_len);
      strcpy (input_text + input_text_offset, xp);
      strncpy (input_text + input_text_offset + xp_len, str,
	       real_bottom - limit + 1);
      free (str);
      free (xp);
      
      limit += xp_len - raw_len;
      real_bottom += xp_len - raw_len;
d963 2
a964 1
  size_of_input_text = limit;
d966 1
a966 1
  size_of_input_text = real_bottom;
d970 2
a971 1
get_rest_of_line (string)
d974 15
a988 1
  get_until ("\n", string);
d1021 1
a1021 1
  for (i = input_text_offset; i < size_of_input_text; i++)
d1036 2
a1037 2
  temp = (char *)xmalloc (2 + match_len);
  strncpy (temp, input_text + input_text_offset, match_len);
d1043 1
a1043 5
/* **************************************************************** */
/*                                                                  */
/*                      Converting the File                         */
/*                                                                  */
/* **************************************************************** */
d1048 4
d1056 1
a1056 1
  (char *)NULL
d1074 24
d1109 1
a1109 1
  char *buffer = (char *)NULL;
d1130 1
a1130 1
          exit (FATAL);
d1140 1
a1140 1
  size_of_input_text = buffer_offset;
d1148 2
a1149 2
     The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
  input_text[size_of_input_text] = '\n';
d1158 2
a1159 2
  register int i;
  char *filename = (char *)xmalloc (strlen (name) + 50);
d1193 1
a1193 1
  
d1198 1
a1198 2
  char *expand_filename (), *filename_part ();
  char *real_output_filename = (char *)NULL;
a1199 1
#if defined (HAVE_MACROS)
d1201 7
a1207 1
#endif /* HAVE_MACROS */
a1210 1
  input_text_offset = 0;
d1216 3
a1218 3
      if ((input_text_offset == 0) ||
          ((input_text_offset > 0) &&
           (input_text[input_text_offset -1] == '\n')))
d1232 6
a1237 1
          register int i, end_of_first_line;
d1239 4
a1242 4
          /* Find the end of the first line in the file. */
          for (i = 0; i < size_of_input_text - 1; i++)
            if (input_text[i] == '\n')
              break;
d1244 1
a1244 1
          end_of_first_line = i + 1;
d1246 10
a1255 14
          input_text_offset = 0;

          for (i = 0; i < end_of_first_line; i++)
            {
              if ((input_text[i] == '\\') &&
                  (strncmp (input_text + i + 1, "include", 7) == 0))
                {
                  input_text_offset = end_of_first_line;
                  break;
                }
            }
          command_output_filename = output_name_from_input_name (name);
#endif /* !REQUIRE_SETFILENAME */
        }
d1261 27
a1287 1
    get_until ("\n", &output_filename);
d1296 1
a1296 1
      command_output_filename = (char *)NULL;
d1324 3
a1326 1
  if (output_stream != stdout)
d1328 2
a1329 1
            no_headers ? "text" : "info", output_filename, input_filename);
d1356 4
a1359 6
  if (!no_headers)
    {
     add_word_args (_("This is Info file %s, produced by Makeinfo version %d.%d"),
                     output_filename, major_version, minor_version);
     add_word_args (_(" from the input file %s.\n"), input_filename);
    }
a1368 1
#if defined (HAVE_MACROS)
d1374 2
a1375 1
          && strcmp (macro_expansion_filename, "/dev/null") != 0)
a1382 1
#endif /* HAVE_MACROS */
d1387 1
a1387 2
      free_pending_notes ();
      if (tag_table != NULL)
d1390 1
a1390 1
          if (!no_headers)
d1394 7
d1408 5
a1412 1
      if (splitting && (!errors_printed || force))
d1414 2
a1415 1
      else if (errors_printed && !force
d1417 2
a1418 1
               && strcmp (real_output_filename, "/dev/null") != 0)
d1436 1
a1436 1
      *pointer = (char *) NULL;
d1448 2
d1458 1
d1465 1
a1465 1
  output_paragraph = (unsigned char *)xmalloc (paragraph_buffer_len);
d1471 1
d1473 3
d1477 2
a1478 7
/* Okay, we are ready to start the conversion.  Call the reader on
   some text, and fill the text as it is output.  Handle commands by
   remembering things like open braces and the current file position on a
   stack, and when the corresponding close brace is found, you can call
   the function with the proper arguments. */
void
reader_loop ()
d1480 15
a1494 3
  int character;
  int done = 0;
  int dash_count = 0;
d1496 1
a1496 4
  while (!done)
    {
      if (input_text_offset >= size_of_input_text)
        break;
d1498 3
a1500 1
      character = curchar ();
d1502 1
a1502 3
      if (!in_fixed_width_font &&
          (character == '\'' || character == '`') &&
          input_text[input_text_offset + 1] == character)
d1504 3
a1506 2
          input_text_offset++;
          character = '"';
d1508 1
a1508 2

      if (character == '-')
d1510 2
a1511 6
          dash_count++;
          if (dash_count == 2 && !in_fixed_width_font)
            {
              input_text_offset++;
              continue;
            }
d1513 2
a1514 1
      else
d1516 2
a1517 1
          dash_count = 0;
d1520 5
a1524 18
      /* If this is a whitespace character, then check to see if the line
         is blank.  If so, advance to the carriage return. */
      if (whitespace (character))
        {
          register int i = input_text_offset + 1;

          while (i < size_of_input_text && whitespace (input_text[i]))
            i++;

          if (i == size_of_input_text || input_text[i] == '\n')
            {
              if (i == size_of_input_text)
                i--;

              input_text_offset = i;
              character = curchar ();
            }
        }
d1526 6
a1531 3
      if (character == '\n')
        {
          line_number++;
d1533 1
a1533 5
          /* Check for a menu entry here, since the "escape sequence"
             that begins menu entries is "\n* ". */
          if (in_menu && input_text_offset + 1 < size_of_input_text)
            {
              char *glean_node_from_menu (), *tem;
d1535 6
a1540 6
              /* Note that the value of TEM is discarded, since it is
                 gauranteed to be NULL when glean_node_from_menu () is
                 called with a Nonzero argument. */
              if (!in_detailmenu)
                tem = glean_node_from_menu (1);
            }
d1542 10
d1553 2
a1554 35
      switch (character)
        {
        case COMMAND_PREFIX:
          read_command ();
          break;

        case '{':
          /* Special case.  I'm not supposed to see this character by itself.
             If I do, it means there is a syntax error in the input text.
             Report the error here, but remember this brace on the stack so
             you can ignore its partner. */

          line_error (_("Misplaced %c"), '{');
          remember_brace (misplaced_brace);

          /* Don't advance input_text_offset since this happens in
             remember_brace ().
             input_text_offset++;
           */
          break;

        case '}':
          pop_and_call_brace ();
          input_text_offset++;
          break;

        default:
          add_char (character);
          input_text_offset++;
        }
    }
#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream)
    maybe_write_itext (input_text, input_text_offset);
#endif /* HAVE_MACROS */
d1556 4
a1559 5

/* Find the command corresponding to STRING.  If the command
   is found, return a pointer to the data structure.  Otherwise
   return (-1). */
COMMAND *
d1563 1
a1563 1
  register int i;
d1567 1
a1567 1
      return (&command_table[i]);
d1574 1
a1574 1
      return (user_command_array[i]);
d1577 1
a1577 1
  return ((COMMAND *) -1);
d1579 1
a1579 1

d1581 3
a1583 2
   Read the next token to determine what to do. */
void
d1587 1
a1588 1
  input_text_offset++;
a1591 1
#if defined (HAVE_MACROS)
d1610 1
a1610 1
        return;
d1613 18
a1630 1
#endif /* HAVE_MACROS */
d1636 1
a1636 1
      return;
d1639 1
a1639 1
  if (entry->argument_in_braces)
d1641 33
d1675 2
d1678 1
d1681 8
a1688 4
/* Return the string which invokes PROC; a pointer to a function. */
char *
find_proc_name (proc)
     COMMAND_FUNCTION *proc;
d1690 91
a1780 1
  register int i;
d1782 43
a1824 4
  for (i = 0; command_table[i].name; i++)
    if (proc == command_table[i].proc)
      return command_table[i].name;
  return _("NO_NAME!");
d1826 1
a1826 1

d1830 1
a1830 1
  brace_stack = (BRACE_ELEMENT *) NULL;
d1851 1
a1851 1
  BRACE_ELEMENT *new = (BRACE_ELEMENT *) xmalloc (sizeof (BRACE_ELEMENT));
d1854 1
d1866 1
a1866 5
  BRACE_ELEMENT *temp;
  COMMAND_FUNCTION *proc;
  int pos;

  if (brace_stack == (BRACE_ELEMENT *) NULL)
d1872 14
a1885 6
  pos = brace_stack->pos;
  proc = brace_stack->proc;
  in_fixed_width_font = brace_stack->in_fixed_width_font;
  temp = brace_stack->next;
  free (brace_stack);
  brace_stack = temp;
d1887 2
a1888 1
  (*proc) (END, pos, output_paragraph_offset);
d1896 1
a1896 1
  register BRACE_ELEMENT *stack = brace_stack;
d1906 15
d1985 1
a1985 1
  return (len);
d1987 1
a1987 1

d1997 1
a1997 1
  char buffer[1000];
d2006 1
a2006 1
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
a2020 18
/* Nonzero if the last character inserted has the syntax class of NEWLINE. */
int last_char_was_newline = 1;

/* The actual last inserted character.  Note that this may be something
   other than NEWLINE even if last_char_was_newline is 1. */
int last_inserted_character = 0;

/* Nonzero means that a newline character has already been
   inserted, so close_paragraph () should insert one less. */
int line_already_broken = 0;

/* When nonzero we have finished an insertion (see `end_insertion') and we
   want to ignore false continued paragraph closings. */
int insertion_paragraph_closed = 0;

/* Nonzero means attempt to make all of the lines have fill_column width. */
int do_justification = 0;

d2028 4
a2031 2
     in a menu, then simply return. */
  if (no_headers && (in_menu || in_detailmenu))
d2047 10
a2056 2
  if (non_splitting_words && member (character, " \t\n"))
    character = ' ' | 0x80;
d2063 1
a2063 1
      if (!filling_enabled)
d2080 2
a2081 1
      else /* CHARACTER is newline, and filling is enabled. */
d2083 3
a2085 6
          if (end_of_sentence_p ())
            {
              insert (' ');
              output_column++;
              last_inserted_character = character;
            }
d2090 2
d2098 4
a2101 1
          insert (' ');
d2106 1
a2106 1
    default:
d2123 3
a2125 4

            /* If the paragraph is supposed to be indented a certain way,
               then discard all of the pending whitespace.  Otherwise, we
               let the whitespace stay. */
d2129 11
d2142 2
a2143 1
        if ((output_column += len) > fill_column)
d2145 1
a2145 1
            if (filling_enabled)
d2158 9
a2166 1
                        output_paragraph[temp++] = '\n';
d2198 1
a2198 1
                        if (indented_fill && current_indent)
d2202 1
a2202 1
                            char *temp_buffer = (char *)xmalloc (buffer_len);
d2213 1
a2213 1
                            strncpy ((char *) &temp_buffer[current_indent],
d2225 1
a2225 1
                            strncpy ((char *) &output_paragraph[temp],
d2252 9
d2266 7
d2292 1
a2292 1
#define post_sentence(c) ((c) == ')' || (c) == '\'' || (c) == '"' \
d2301 11
a2311 1
  while (loc > 0 && post_sentence (output_paragraph[loc]))
d2313 1
a2313 1
  return sentence_ender (output_paragraph[loc]);
d2366 1
a2366 1
  register int i;
d2373 6
a2378 3
      /* If we turned on the 8th bit for a space
         inside @@w, turn it back off for output.  */
      if (output_paragraph[i] & meta_character_bit)
d2390 1
d2401 13
a2413 3
/* Close the current paragraph, leaving no blank lines between them. */
void
close_single_paragraph ()
a2453 10
void
close_paragraph_with_lines (lines)
     int lines;
{
  int old_spacing = paragraph_spacing;
  paragraph_spacing = lines;
  close_paragraph ();
  paragraph_spacing = old_spacing;
}

d2458 1
a2458 1
  register int i;
d2465 1
a2465 1
      register int tindex, c;
d2494 7
a2500 1
            insert ('\n');
d2513 1
d2540 1
a2540 1
          register int i;
d2548 1
a2548 1
          temp = (char *)xmalloc (temp_len + 1);
d2557 1
d2614 2
a2615 1
  register BRACE_ELEMENT *elt = brace_stack;
d2619 1
a2619 6
  while (elt)
    {
      if (elt->pos >= output_paragraph_offset)
        elt->pos += amount;
      elt = elt->next;
    }
d2634 1
a2634 1
  while (from < size_of_input_text)
d2637 1
a2637 1
        return (from);
d2640 1
a2640 1
  return (-1);
d2642 2
d2645 7
a2651 7
/* Whoops, Unix doesn't have strcasecmp. */

/* Case independent string compare. */
#if !defined (HAVE_STRCASECMP)
int
strcasecmp (string1, string2)
     char *string1, *string2;
d2653 1
a2653 1
  char ch1, ch2;
d2655 1
a2655 1
  for (;;)
d2657 2
a2658 2
      ch1 = *string1++;
      ch2 = *string2++;
d2660 6
a2665 2
      if (!(ch1 | ch2))
        return (0);
d2667 8
a2674 2
      ch1 = coerce_to_upper (ch1);
      ch2 = coerce_to_upper (ch2);
d2676 5
a2680 3
      if (ch1 != ch2)
        return (ch1 - ch2);
    }
a2681 1
#endif /* !HAVE_STRCASECMP */
d2683 9
d2693 1
a2693 1
init_insertion_stack ()
d2695 20
a2714 2
  insertion_stack = (INSERTION_ELT *) NULL;
}
d2716 9
a2724 9
/* Return the type of the current insertion. */
enum insertion_type
current_insertion_type ()
{
  if (!insertion_level)
    return (bad_type);
  else
    return (insertion_stack->insertion);
}
d2726 23
a2748 7
/* Return a pointer to the string which is the function to wrap around
   items. */
char *
current_item_function ()
{
  register int level, done;
  register INSERTION_ELT *elt;
d2750 10
a2759 18
  level = insertion_level;
  elt = insertion_stack;
  done = 0;

  /* Skip down through the stack until we find a non-conditional insertion. */
  while (!done && (elt != NULL))
    {
      switch (elt->insertion)
        {
        case ifinfo:
        case ifnothtml:
        case ifnottex:
        case ifset:
        case ifclear:
        case cartouche:
          elt = elt->next;
          level--;
          break;
d2761 52
a2812 2
        default:
          done = 1;
d2814 7
a2821 3

  if (!level)
    return ((char *) NULL);
d2823 5
a2827 2
    return (elt->item_function);
}
d2829 13
a2841 7
char *
get_item_function ()
{
  char *item_function;
  get_rest_of_line (&item_function);
  backup_input_pointer ();
  return (item_function);
a2843 1
 /* Push the state of the current insertion on the stack. */
d2845 2
a2846 3
push_insertion (type, item_function)
     enum insertion_type type;
     char *item_function;
d2848 10
a2857 13
  INSERTION_ELT *new = (INSERTION_ELT *) xmalloc (sizeof (INSERTION_ELT));

  new->item_function = item_function;
  new->filling_enabled = filling_enabled;
  new->indented_fill = indented_fill;
  new->insertion = type;
  new->line_number = line_number;
  new->filename = xstrdup (input_filename);
  new->inhibited = inhibit_paragraph_indentation;
  new->in_fixed_width_font = in_fixed_width_font;
  new->next = insertion_stack;
  insertion_stack = new;
  insertion_level++;
a2859 2
 /* Pop the value on top of the insertion stack into the
    global variables. */
d2861 2
a2862 1
pop_insertion ()
d2864 1
a2864 36
  INSERTION_ELT *temp = insertion_stack;

  if (temp == (INSERTION_ELT *) NULL)
    return;

  in_fixed_width_font = temp->in_fixed_width_font;
  inhibit_paragraph_indentation = temp->inhibited;
  filling_enabled = temp->filling_enabled;
  indented_fill = temp->indented_fill;
  free_and_clear (&(temp->item_function));
  free_and_clear (&(temp->filename));
  insertion_stack = insertion_stack->next;
  free (temp);
  insertion_level--;
}

 /* Return a pointer to the print name of this
    enumerated type. */
char *
insertion_type_pname (type)
     enum insertion_type type;
{
  if ((int) type < (int) bad_type)
    return (insertion_type_names[(int) type]);
  else
    return (_("Broken-Type in insertion_type_pname"));
}

/* Return the insertion_type associated with NAME.
   If the type is not one of the known ones, return BAD_TYPE. */
enum insertion_type
find_type_from_name (name)
     char *name;
{
  int index = 0;
  while (index < (int) bad_type)
d2866 3
a2868 3
      if (strcmp (name, insertion_type_names[index]) == 0)
        return (enum insertion_type) index;
      index++;
a2869 1
  return (bad_type);
d2872 3
a2874 3
int
defun_insertion (type)
     enum insertion_type type;
d2876 5
a2880 30
  return
    ((type == deffn)
     || (type == defun)
     || (type == defmac)
     || (type == defspec)
     || (type == defvr)
     || (type == defvar)
     || (type == defopt)
     || (type == deftypefn)
     || (type == deftypefun)
     || (type == deftypevr)
     || (type == deftypevar)
     || (type == defcv)
     || (type == defivar)
     || (type == defop)
     || (type == defmethod)
     || (type == deftypemethod)
     || (type == deftp));
}

/* MAX_NS is the maximum nesting level for enumerations.  I picked 100
   which seemed reasonable.  This doesn't control the number of items,
   just the number of nested lists. */
#define max_stack_depth 100
#define ENUM_DIGITS 1
#define ENUM_ALPHA  2
typedef struct {
  int enumtype;
  int enumval;
} DIGIT_ALPHA;
d2882 17
a2898 5
DIGIT_ALPHA enumstack[max_stack_depth];
int enumstack_offset = 0;
int current_enumval = 1;
int current_enumtype = ENUM_DIGITS;
char *enumeration_arg = (char *)NULL;
d2900 3
a2902 8
void
start_enumerating (at, type)
     int at, type;
{
  if ((enumstack_offset + 1) == max_stack_depth)
    {
      line_error (_("Enumeration stack overflow"));
      return;
a2903 5
  enumstack[enumstack_offset].enumtype = current_enumtype;
  enumstack[enumstack_offset].enumval = current_enumval;
  enumstack_offset++;
  current_enumval = at;
  current_enumtype = type;
d2906 1
d2908 2
a2909 1
stop_enumerating ()
d2911 44
a2954 6
  --enumstack_offset;
  if (enumstack_offset < 0)
    enumstack_offset = 0;

  current_enumval = enumstack[enumstack_offset].enumval;
  current_enumtype = enumstack[enumstack_offset].enumtype;
d2957 1
a2957 1
/* Place a letter or digits into the output stream. */
d2959 2
a2960 1
enumerate_item ()
d2962 4
a2965 1
  char temp[10];
d2967 12
a2978 3
  if (current_enumtype == ENUM_ALPHA)
    {
      if (current_enumval == ('z' + 1) || current_enumval == ('Z' + 1))
d2980 4
a2983 2
          current_enumval = ((current_enumval - 1) == 'z' ? 'a' : 'A');
          warning (_("lettering overflow, restarting at %c"), current_enumval);
d2985 5
a2989 1
      sprintf (temp, "%c. ", current_enumval);
a2990 6
  else
    sprintf (temp, "%d. ", current_enumval);

  indent (output_column += (current_indent - strlen (temp)));
  add_word (temp);
  current_enumval++;
d2993 2
a2994 3
/* This is where the work for all the "insertion" style
   commands is done.  A huge switch statement handles the
   various setups, and generic code is on both sides. */
d2996 2
a2997 2
begin_insertion (type)
     enum insertion_type type;
d2999 1
a2999 1
  int no_discard = 0;
d3001 2
a3002 7
  if (defun_insertion (type))
    {
      push_insertion (type, xstrdup (""));
      no_discard++;
    }
  else
    push_insertion (type, get_item_function ());
d3004 26
a3029 5
  switch (type)
    {
    case menu:
      if (!no_headers)
        close_paragraph ();
d3031 13
a3043 2
      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;
d3045 3
a3047 2
      if (!no_headers)
        add_word (_("* Menu:\n"));
d3049 6
a3054 3
      in_menu++;
      no_discard++;
      break;
d3056 2
a3057 5
    case detailmenu:
      if (!in_menu)
        {
          if (!no_headers)
            close_paragraph ();
d3059 6
a3064 4
          filling_enabled = no_indent = 0;
          inhibit_paragraph_indentation = 1;

          no_discard++;
d3067 4
a3070 2
      in_detailmenu++;
      break;
d3072 5
a3076 6
    case direntry:
      close_single_paragraph ();
      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      insert_string ("START-INFO-DIR-ENTRY\n");
      break;
d3078 6
a3083 9
      /* I think @@quotation is meant to do filling.
         If you don't want filling, then use @@display. */
    case quotation:
      close_single_paragraph ();
      last_char_was_newline = no_indent = 0;
      indented_fill = filling_enabled = 1;
      inhibit_paragraph_indentation = 1;
      current_indent += default_indentation_increment;
      break;
d3085 2
a3086 15
    case display:
    case example:
    case smallexample:
    case lisp:
    case smalllisp:
      /* Just like @@example, but no indentation. */
    case format:
      close_single_paragraph ();
      inhibit_paragraph_indentation = 1;
      in_fixed_width_font++;
      filling_enabled = 0;
      last_char_was_newline = 0;
      if (type != format)
        current_indent += default_indentation_increment;
      break;
d3088 7
a3094 3
    case multitable:
      do_multitable ();
      break;
d3096 7
a3102 12
    case table:
    case ftable:
    case vtable:
    case itemize:
      close_single_paragraph ();
      current_indent += default_indentation_increment;
      filling_enabled = indented_fill = 1;
#if defined (INDENT_PARAGRAPHS_IN_TABLE)
      inhibit_paragraph_indentation = 0;
#else
      inhibit_paragraph_indentation = 1;
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */
d3104 5
a3108 94
      /* Make things work for losers who forget the itemize syntax. */
      if (allow_lax_format && (type == itemize))
        {
          if (!(*insertion_stack->item_function))
            {
              free (insertion_stack->item_function);
              insertion_stack->item_function = xstrdup ("@@bullet");
              insertion_stack->item_function[0] = COMMAND_PREFIX;
            }
        }

      if (!*insertion_stack->item_function)
        {
          line_error (_("%s requires an argument: the formatter for %citem"),
                      insertion_type_pname (type), COMMAND_PREFIX);
        }
      break;

    case enumerate:
      close_single_paragraph ();
      no_indent = 0;
#if defined (INDENT_PARAGRAPHS_IN_TABLE)
      inhibit_paragraph_indentation = 0;
#else
      inhibit_paragraph_indentation = 1;
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */

      current_indent += default_indentation_increment;
      filling_enabled = indented_fill = 1;

      if (isdigit (*enumeration_arg))
        start_enumerating (atoi (enumeration_arg), ENUM_DIGITS);
      else
        start_enumerating (*enumeration_arg, ENUM_ALPHA);
      break;

      /* Does nothing special in makeinfo. */
    case group:
      /* Only close the paragraph if we are not inside of an @@example. */
      if (!insertion_stack->next ||
          insertion_stack->next->insertion != example)
        close_single_paragraph ();
      break;

      /* Insertions that are no-ops in info, but do something in TeX. */
    case ifinfo:
    case ifnothtml:
    case ifnottex:
    case ifset:
    case ifclear:
    case cartouche:
      if (in_menu)
        no_discard++;
      break;

    case deffn:
    case defun:
    case defmac:
    case defspec:
    case defvr:
    case defvar:
    case defopt:
    case deftypefn:
    case deftypefun:
    case deftypevr:
    case deftypevar:
    case defcv:
    case defivar:
    case defop:
    case defmethod:
    case deftypemethod:
    case deftp:
      inhibit_paragraph_indentation = 1;
      filling_enabled = indented_fill = 1;
      current_indent += default_indentation_increment;
      no_indent = 0;
      break;

    case flushleft:
      close_single_paragraph ();
      inhibit_paragraph_indentation = 1;
      filling_enabled = indented_fill = no_indent = 0;
      break;

    case flushright:
      close_single_paragraph ();
      filling_enabled = indented_fill = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      force_flush_right++;
      break;
    }

  if (!no_discard)
    discard_until ("\n");
d3111 1
a3111 4
/* Try to end the insertion with the specified TYPE.  With a value of
   `bad_type', TYPE gets translated to match the value currently on top
   of the stack.  Otherwise, if TYPE doesn't match the top of the
   insertion stack, give error. */
d3113 2
a3114 2
end_insertion (type)
     enum insertion_type type;
d3116 1
a3116 1
  enum insertion_type temp_type;
d3118 2
a3119 2
  if (!insertion_level)
    return;
d3121 1
a3121 6
  temp_type = current_insertion_type ();

  if (type == bad_type)
    type = temp_type;

  if (type != temp_type)
d3123 1
a3123 26
      line_error
        (_("`%cend' expected `%s', but saw `%s'"), COMMAND_PREFIX,
         insertion_type_pname (temp_type), insertion_type_pname (type));
      return;
    }

  pop_insertion ();

  switch (type)
    {
      /* Insertions which have no effect on paragraph formatting. */
    case ifnothtml:
    case ifnottex:
    case ifinfo:
    case ifset:
    case ifclear:
      break;

    case direntry:
      insert_string ("END-INFO-DIR-ENTRY\n\n");
      close_insertion_paragraph ();
      break;

    case detailmenu:
      in_detailmenu--;          /* No longer hacking menus. */
      if (!in_menu)
d3125 4
a3128 4
          if (!no_headers)
            close_insertion_paragraph ();
        }
      break;
d3130 4
a3133 85
    case menu:
      in_menu--;                /* No longer hacking menus. */
      if (!no_headers)
        close_insertion_paragraph ();
      break;

    case multitable:
      end_multitable ();
      break;

    case enumerate:
      stop_enumerating ();
      close_insertion_paragraph ();
      current_indent -= default_indentation_increment;
      break;

    case flushleft:
    case group:
    case cartouche:
      close_insertion_paragraph ();
      break;

    case format:
    case display:
    case example:
    case smallexample:
    case lisp:
    case smalllisp:
    case quotation:
      /* @@format is the only fixed_width insertion without a change
         in indentation. */
      if (type != format)
        current_indent -= default_indentation_increment;

      /* The ending of one of these insertions always marks the
         start of a new paragraph. */
      close_insertion_paragraph ();
      break;

    case table:
    case ftable:
    case vtable:
    case itemize:
      current_indent -= default_indentation_increment;
      break;

    case flushright:
      force_flush_right--;
      close_insertion_paragraph ();
      break;

      /* Handle the @@defun style insertions with a default clause. */
    default:
      current_indent -= default_indentation_increment;
      close_insertion_paragraph ();
      break;
    }
}

/* Insertions cannot cross certain boundaries, such as node beginnings.  In
   code that creates such boundaries, you should call `discard_insertions'
   before doing anything else.  It prints the errors for you, and cleans up
   the insertion stack.  With nonzero SPECIALS_OK, allows unmatched
   ifinfo, ifset, ifclear, otherwise not.  */
void
discard_insertions (specials_ok)
    int specials_ok;
{
  int real_line_number = line_number;
  while (insertion_stack)
    {
      if (specials_ok && (insertion_stack->insertion == ifinfo
          || insertion_stack->insertion == ifset
          || insertion_stack->insertion == ifclear))
        break;
      else
        {
          char *offender = insertion_type_pname (insertion_stack->insertion);
          char *current_filename = input_filename;
          
          input_filename = insertion_stack->filename;
          line_number = insertion_stack->line_number;
          line_error (_("No matching `%cend %s'"), COMMAND_PREFIX, offender);
          input_filename = current_filename;
          pop_insertion ();
d3135 2
a3137 1
  line_number = real_line_number;
a3138 2

/* The Texinfo commands. */
d3140 4
a3143 4
/* Commands which insert their own names. */
void
insert_self (arg)
    int arg;
d3145 1
a3145 3
  if (arg == START)
    add_word (command);
}
d3147 3
a3149 7
void
insert_space (arg)
    int arg;
{
  if (arg == START)
    add_char (' ');
}
d3151 1
a3151 6
/* Force a line break in the output. */
void
cm_asterisk ()
{
  close_single_paragraph ();
  cm_noindent ();
d3154 1
a3154 1
/* Insert ellipsis. */
d3156 1
a3156 2
cm_dots (arg)
     int arg;
d3158 1
a3158 2
  if (arg == START)
    add_word ("...");
d3161 1
a3161 1
/* Insert ellipsis for sentence end. */
d3163 1
a3163 2
cm_enddots (arg)
     int arg;
d3165 1
a3165 2
  if (arg == START)
    add_word ("....");
d3169 1
a3169 2
cm_bullet (arg)
     int arg;
d3171 1
a3171 2
  if (arg == START)
    add_char ('*');
d3175 1
a3175 2
cm_minus (arg)
     int arg;
d3177 1
a3177 2
  if (arg == START)
    add_char ('-');
d3180 2
a3181 8
/* Insert "TeX". */
void
cm_TeX (arg)
     int arg;
{
  if (arg == START)
    add_word ("TeX");
}
d3183 3
a3185 1
/* Copyright symbol.  */
d3187 1
a3187 2
cm_copyright (arg)
    int arg;
d3189 1
a3189 3
  if (arg == START)
    add_word ("(C)");
}
d3191 1
a3191 30
/* Accent commands that take explicit arguments.  */
void
cm_accent (arg)
    int arg;
{
  if (arg == START)
    {
      if (strcmp (command, "dotaccent") == 0)  /* overdot */
        add_char ('.');
      else if (strcmp (command, "H") == 0)     /* Hungarian umlaut */
        add_word ("''");
      else if (strcmp (command, "ringaccent") == 0)
        add_char ('*');
      else if (strcmp (command, "tieaccent") == 0)
        add_char ('[');
      else if (strcmp (command, "u") == 0)     /* breve */
        add_char ('(');
      else if (strcmp (command, "v") == 0)     /* hacek/check */
        add_char ('<');
    }
  else if (arg == END)
    {
      if (strcmp (command, "ubaraccent") == 0) /* underbar */
        add_char ('_');
      else if (strcmp (command, "udotaccent") == 0) /* underdot */
        add_word ("-.");
      else if (strcmp (command, ",") == 0)     /* cedilla */
        add_word (",");
    }
} 
d3193 1
a3193 5
/* Non-English letters/characters that don't insert themselves.  */
void
cm_special_char (arg)
{
  if (arg == START)
d3195 6
a3200 18
      if ((*command == 'L' || *command == 'l'
           || *command == 'O' || *command == 'o')
          && command[1] == 0)
        {
          /* Lslash lslash Oslash oslash */
          add_char (*command);
          add_char ('/');
        }
      else if (strcmp (command, "exclamdown") == 0)
        add_char ('!');
      else if (strcmp (command, "pounds") == 0)
        add_char ('#');
      else if (strcmp (command, "questiondown") == 0)
        add_char ('?');
      else
        fprintf (stderr, _("How did @@%s end up in cm_special_char?\n"), command);
    }
}
d3202 1
a3202 18
/* Dotless i or j.  */
void
cm_dotless (arg, start, end)
    int arg, start, end;
{
  if (arg == END)
    {
      if (output_paragraph[start] != 'i' && output_paragraph[start] != 'j')
        /* This error message isn't perfect if the argument is multiple
           characters, but it doesn't seem worth getting right.  */
        line_error (_("%c%s expects `i' or `j' as argument, not `%c'"),
                    COMMAND_PREFIX, command, output_paragraph[start]);

      else if (end - start != 1)
        line_error (_("%c%s expects a single character `i' or `j' as argument"),
                    COMMAND_PREFIX, command);

      /* We've already inserted the `i' or `j', so nothing to do.  */
d3207 2
a3208 19
cm_today (arg)
     int arg;
{
  static char *months [12] =
    { N_("January"), N_("February"), N_("March"), N_("April"), N_("May"),
      N_("June"), N_("July"), N_("August"), N_("September"), N_("October"),
      N_("November"), N_("December") };
  if (arg == START)
    {
      time_t timer = time (0);
      struct tm *ts = localtime (&timer);
      add_word_args ("%d %s %d", ts->tm_mday, _(months[ts->tm_mon]),
                     ts->tm_year + 1900);
    }
}

void
cm_code (arg)
     int arg;
d3210 1
a3210 1
  extern int printing_index;
d3212 6
d3220 8
a3228 3

      if (!printing_index)
        add_char ('`');
d3232 7
a3238 14
      if (!printing_index)
        add_char ('\'');
    }
}

void
cm_kbd (arg)
     int arg;
{
  /* People use @@kbd in an example to get the "user input" font.
     We don't want quotes in that case.  */
  if (!in_fixed_width_font)
    cm_code (arg);
}
d3240 15
a3254 6
void
cm_key (arg)
     int arg;
{
  add_char (arg == START ? '<' : '>');
}
d3256 2
a3257 13
/* Convert the character at position into a true control character. */
void
cm_ctrl (arg, start, end)
     int arg, start, end;
{
  /* Should we allow multiple character arguments?  I think yes. */
  if (arg == END)
    {
      register int i, character;
#if defined (NO_MULTIPLE_CTRL)
      if ((end - start) != 1)
        line_error (_("%c%s expects a single character as an argument"),
                    COMMAND_PREFIX, command);
d3259 1
a3259 4
#endif
        for (i = start; i < end; i++)
          {
            character = output_paragraph[i];
d3261 1
a3261 3
            if (isletter (character))
              output_paragraph[i] = CTL (coerce_to_upper (character));
          }
d3265 1
a3265 1
/* Handle a command that switches to a non-fixed-width font.  */
d3267 2
a3268 2
not_fixed_width (arg)
     int arg;
d3270 10
a3279 2
  if (arg == START)
    in_fixed_width_font = 0;
a3281 1
/* Small caps and @@var in makeinfo just uppercase the text. */
d3283 3
a3285 2
cm_var_sc (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d3287 2
a3288 1
  not_fixed_width (arg);
d3290 4
a3293 1
  if (arg == END)
d3295 2
a3296 1
      while (start_pos < end_pos)
d3298 4
a3301 3
          output_paragraph[start_pos] =
            coerce_to_upper (output_paragraph[start_pos]);
          start_pos++;
d3303 2
a3305 1
}
d3307 2
a3308 6
void
cm_dfn (arg, position)
     int arg, position;
{
  add_char ('"');
}
d3310 1
a3310 6
void
cm_emph (arg)
     int arg;
{
  add_char ('*');
}
d3312 2
a3313 4591
void
cm_strong (arg, position)
     int arg, position;
{
  cm_emph (arg);
}

void
cm_cite (arg, position)
     int arg, position;
{
  if (arg == START)
    add_word ("`");
  else
    add_word ("'");
}

/* No highlighting, but argument switches fonts.  */
void
cm_not_fixed_width (arg, start, end)
     int arg, start, end;
{
  not_fixed_width (arg);
}

/* Various commands are no-op's. */
void
cm_no_op ()
{
}

/* No-op that eats its argument on same line.  */
void
cm_no_op_line_arg ()
{
  char *temp;
  get_rest_of_line (&temp);
  free (temp);
}

/* Prevent the argument from being split across two lines. */
void
cm_w (arg, start, end)
     int arg, start, end;
{
  if (arg == START)
    non_splitting_words++;
  else
    non_splitting_words--;
}


/* Explain that this command is obsolete, thus the user shouldn't
   do anything with it. */
void
cm_obsolete (arg, start, end)
     int arg, start, end;
{
  if (arg == START)
    warning (_("%c%s is obsolete"), COMMAND_PREFIX, command);
}

/* Insert the text following input_text_offset up to the end of the line
   in a new, separate paragraph.  Directly underneath it, insert a
   line of WITH_CHAR, the same length of the inserted text. */
void
insert_and_underscore (with_char)
     int with_char;
{
  register int i, len;
  int old_no_indent, starting_pos, ending_pos;
  char *temp;

  close_paragraph ();
  filling_enabled =  indented_fill = 0;
  old_no_indent = no_indent;
  no_indent = 1;

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);
#endif /* HAVE_MACROS */

  get_rest_of_line (&temp);

  starting_pos = output_position + output_paragraph_offset;
#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    {
      char *temp1 = (char *) xmalloc (2 + strlen (temp));
      sprintf (temp1, "%s\n", temp);
      remember_itext (input_text, input_text_offset);
      me_execute_string (temp1);
      free (temp1);
    }
  else
#endif /* HAVE_MACROS */
    execute_string ("%s\n", temp);

  ending_pos = output_position + output_paragraph_offset;
  free (temp);

  len = (ending_pos - starting_pos) - 1;
  for (i = 0; i < len; i++)
    add_char (with_char);
  insert ('\n');
  close_paragraph ();
  filling_enabled = 1;
  no_indent = old_no_indent;
}

/* Here is a structure which associates sectioning commands with
   an integer, hopefully to reflect the `depth' of the current
   section. */
struct {
  char *name;
  int level;
} section_alist[] = {
  { "unnumberedsubsubsec", 5 },
  { "unnumberedsubsec", 4 },
  { "unnumberedsec", 3 },
  { "unnumbered", 2 },
  { "appendixsubsubsec", 5 },
  { "appendixsubsec", 4 },
  { "appendixsec", 3 },
  { "appendixsection", 3 },
  { "appendix", 2 },
  { "subsubsec", 5 },
  { "subsubsection", 5 },
  { "subsection", 4 },
  { "section", 3 },
  { "chapter", 2 },
  { "top", 1 },

  { (char *)NULL, 0 }
};

/* Amount to offset the name of sectioning commands to levels by. */
int section_alist_offset = 0;

/* Shift the meaning of @@section to @@chapter. */
void
cm_raisesections ()
{
  discard_until ("\n");
  section_alist_offset--;
}

/* Shift the meaning of @@chapter to @@section. */
void
cm_lowersections ()
{
  discard_until ("\n");
  section_alist_offset++;
}

/* Return an integer which identifies the type section present in TEXT. */
int
what_section (text)
     char *text;
{
  register int i, j;
  char *t;

 find_section_command:
  for (j = 0; text[j] && cr_or_whitespace (text[j]); j++);
  if (text[j] != COMMAND_PREFIX)
    return (-1);

  text = text + j + 1;

  /* We skip @@c, @@comment, and @@?index commands. */
  if ((strncmp (text, "comment", strlen ("comment")) == 0) ||
      (text[0] == 'c' && cr_or_whitespace (text[1])) ||
      (strcmp (text + 1, "index") == 0))
    {
      while (*text++ != '\n');
      goto find_section_command;
    }

  /* Handle italicized sectioning commands. */
  if (*text == 'i')
    text++;

  for (j = 0; text[j] && !cr_or_whitespace (text[j]); j++);

  for (i = 0; (t = section_alist[i].name); i++)
    {
      if (j == strlen (t) && strncmp (t, text, j) == 0)
        {
          int return_val;

          return_val = (section_alist[i].level + section_alist_offset);

          if (return_val < 0)
            return_val = 0;
          else if (return_val > 5)
            return_val = 5;
          return (return_val);
        }
    }
  return (-1);
}

/* Set the level of @@top to LEVEL.  Return the old level of @@top. */
int
set_top_section_level (level)
     int level;
{
  register int i, result = -1;

  for (i = 0; section_alist[i].name; i++)
    if (strcmp (section_alist[i].name, "top") == 0)
      {
        result = section_alist[i].level;
        section_alist[i].level = level;
        break;
      }
  return (result);
}

/* Treat this just like @@unnumbered.  The only difference is
   in node defaulting. */
void
cm_top ()
{
  /* It is an error to have more than one @@top. */
  if (top_node_seen)
    {
      TAG_ENTRY *tag = tag_table;

      line_error (_("Node with %ctop as a section already exists"),
                  COMMAND_PREFIX);

      while (tag != (TAG_ENTRY *)NULL)
        {
          if ((tag->flags & IS_TOP))
            {
              int old_line_number = line_number;
              char *old_input_filename = input_filename;

              line_number = tag->line_no;
              input_filename = tag->filename;
              line_error (_("Here is the %ctop node"), COMMAND_PREFIX);
              input_filename = old_input_filename;
              line_number = old_line_number;
              return;
            }
          tag = tag->next_ent;
        }
    }
  else
    {
      top_node_seen = 1;

      /* It is an error to use @@top before you have used @@node. */
      if (!tag_table)
        {
          char *top_name;

          get_rest_of_line (&top_name);
          free (top_name);
          line_error (_("%ctop used before %cnode, defaulting to %s"),
                      COMMAND_PREFIX, COMMAND_PREFIX, top_name);
          execute_string ("@@node Top, , (dir), (dir)\n@@top %s\n", top_name);
          return;
        }

      cm_unnumbered ();

      /* The most recently defined node is the top node. */
      tag_table->flags |= IS_TOP;

      /* Now set the logical hierarchical level of the Top node. */
      {
        int orig_offset = input_text_offset;

        input_text_offset = search_forward (node_search_string, orig_offset);

        if (input_text_offset > 0)
          {
            int this_section;

            /* We have encountered a non-top node, so mark that one exists. */
            non_top_node_seen = 1;

            /* Move to the end of this line, and find out what the
               sectioning command is here. */
            while (input_text[input_text_offset] != '\n')
              input_text_offset++;

            if (input_text_offset < size_of_input_text)
              input_text_offset++;

            this_section = what_section (input_text + input_text_offset);

            /* If we found a sectioning command, then give the top section
               a level of this section - 1. */
            if (this_section != -1)
              set_top_section_level (this_section - 1);
          }
        input_text_offset = orig_offset;
      }
    }
}

/* Organized by level commands.  That is, "*" == chapter, "=" == section. */
char *scoring_characters = "*=-.";

void
sectioning_underscore (command)
     char *command;
{
  char character;
  char *temp;
  int level;

  temp = (char *)xmalloc (2 + strlen (command));
  temp[0] = COMMAND_PREFIX;
  strcpy (&temp[1], command);
  level = what_section (temp);
  free (temp);
  level -= 2;

  if (level < 0)
    level = 0;

  character = scoring_characters[level];

  insert_and_underscore (character);
}

/* The command still works, but prints a warning message in addition. */
void
cm_ideprecated (arg, start, end)
     int arg, start, end;
{
  warning (_("%c%s is obsolete; use %c%s instead"),
           COMMAND_PREFIX, command, COMMAND_PREFIX, command + 1);
  sectioning_underscore (command + 1);
}

/* The remainder of the text on this line is a chapter heading. */
void
cm_chapter ()
{
  sectioning_underscore ("chapter");
}

/* The remainder of the text on this line is a section heading. */
void
cm_section ()
{
  sectioning_underscore ("section");
}

/* The remainder of the text on this line is a subsection heading. */
void
cm_subsection ()
{
  sectioning_underscore ("subsection");
}

/* The remainder of the text on this line is a subsubsection heading. */
void
cm_subsubsection ()
{
  sectioning_underscore ("subsubsection");
}

/* The remainder of the text on this line is an unnumbered heading. */
void
cm_unnumbered ()
{
  cm_chapter ();
}

/* The remainder of the text on this line is an unnumbered section heading. */
void
cm_unnumberedsec ()
{
  cm_section ();
}

/* The remainder of the text on this line is an unnumbered
   subsection heading. */
void
cm_unnumberedsubsec ()
{
  cm_subsection ();
}

/* The remainder of the text on this line is an unnumbered
   subsubsection heading. */
void
cm_unnumberedsubsubsec ()
{
  cm_subsubsection ();
}

/* The remainder of the text on this line is an appendix heading. */
void
cm_appendix ()
{
  cm_chapter ();
}

/* The remainder of the text on this line is an appendix section heading. */
void
cm_appendixsec ()
{
  cm_section ();
}

/* The remainder of the text on this line is an appendix subsection heading. */
void
cm_appendixsubsec ()
{
  cm_subsection ();
}

/* The remainder of the text on this line is an appendix
   subsubsection heading. */
void
cm_appendixsubsubsec ()
{
  cm_subsubsection ();
}

/* Compatibility functions substitute for chapter, section, etc. */
void
cm_majorheading ()
{
  cm_chapheading ();
}

void
cm_chapheading ()
{
  cm_chapter ();
}

void
cm_heading ()
{
  cm_section ();
}

void
cm_subheading ()
{
  cm_subsection ();
}

void
cm_subsubheading ()
{
  cm_subsubsection ();
}

/* **************************************************************** */
/*                                                                  */
/*                 Adding nodes, and making tags                    */
/*                                                                  */
/* **************************************************************** */

/* Start a new tag table. */
void
init_tag_table ()
{
  while (tag_table != (TAG_ENTRY *) NULL)
    {
      TAG_ENTRY *temp = tag_table;
      free (temp->node);
      free (temp->prev);
      free (temp->next);
      free (temp->up);
      tag_table = tag_table->next_ent;
      free (temp);
    }
}

void
write_tag_table ()
{
  write_tag_table_internal (0); /* Not indirect. */
}

void
write_tag_table_indirect ()
{
  write_tag_table_internal (1);
}

/* Write out the contents of the existing tag table.
   INDIRECT_P says how to format the output. */
void
write_tag_table_internal (indirect_p)
     int indirect_p;
{
  TAG_ENTRY *node = tag_table;
  int old_indent = no_indent;

  no_indent = 1;
  filling_enabled = 0;
  must_start_paragraph = 0;
  close_paragraph ();

  if (!indirect_p)
    {
      no_indent = 1;
      insert ('\n');
    }

  add_word_args ("\037\nTag Table:\n%s", indirect_p ? "(Indirect)\n" : "");

  while (node != (TAG_ENTRY *) NULL)
    {
      execute_string ("Node: %s", node->node);
      add_word_args ("\177%d\n", node->position);
      node = node->next_ent;
    }

  add_word ("\037\nEnd Tag Table\n");
  flush_output ();
  no_indent = old_indent;
}

char *
get_node_token (expand)
      int expand;
{
  char *string;

  get_until_in_line (expand, ",", &string);

  if (curchar () == ',')
    input_text_offset++;

  canon_white (string);

  /* Force all versions of "top" to be "Top". */
  normalize_node_name (string);

  return (string);
}

/* Convert "top" and friends into "Top". */
void
normalize_node_name (string)
     char *string;
{
  if (strcasecmp (string, "Top") == 0)
    strcpy (string, "Top");
}

/* Look up NAME in the tag table, and return the associated
   tag_entry.  If the node is not in the table return NULL. */
TAG_ENTRY *
find_node (name)
     char *name;
{
  TAG_ENTRY *tag = tag_table;

  while (tag != (TAG_ENTRY *) NULL)
    {
      if (strcmp (tag->node, name) == 0)
        return (tag);
      tag = tag->next_ent;
    }
  return ((TAG_ENTRY *) NULL);
}

/* Remember NODE and associates. */
void
remember_node (node, prev, next, up, position, line_no, no_warn)
     char *node, *prev, *next, *up;
     int position, line_no, no_warn;
{
  /* Check for existence of this tag already. */
  if (validating)
    {
      register TAG_ENTRY *tag = find_node (node);
      if (tag)
        {
          line_error (
                 _("Node `%s' multiply defined (line %d is first definition at)"),
                      node, tag->line_no);
          return;
        }
    }

  /* First, make this the current node. */
  current_node = node;

  /* Now add it to the list. */
  {
    TAG_ENTRY *new = (TAG_ENTRY *) xmalloc (sizeof (TAG_ENTRY));
    new->node = node;
    new->prev = prev;
    new->next = next;
    new->up = up;
    new->position = position;
    new->line_no = line_no;
    new->filename = node_filename;
    new->touched = 0;           /* not yet referenced. */
    new->flags = 0;
    if (no_warn)
      new->flags |= NO_WARN;
    new->next_ent = tag_table;
    tag_table = new;
  }
}

/* The order is: nodename, nextnode, prevnode, upnode.
   If all of the NEXT, PREV, and UP fields are empty, they are defaulted.
   You must follow a node command which has those fields defaulted
   with a sectioning command (e.g. @@chapter) giving the "level" of that node.
   It is an error not to do so.
   The defaults come from the menu in this node's parent. */
void
cm_node ()
{
  char *node, *prev, *next, *up;
  int new_node_pos, defaulting, this_section, no_warn = 0;
  extern int already_outputting_pending_notes;

  if (strcmp (command, "nwnode") == 0)
    no_warn = 1;

  /* Get rid of unmatched brace arguments from previous commands. */
  discard_braces ();

  /* There also might be insertions left lying around that haven't been
     ended yet.  Do that also. */
  discard_insertions (1);

  if (!already_outputting_pending_notes)
    {
      close_paragraph ();
      output_pending_notes ();
      free_pending_notes ();
    }

  filling_enabled = indented_fill = 0;
  new_node_pos = output_position;
  current_footnote_number = 1;

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);
#endif /* HAVE_MACROS */

  node = get_node_token (1);
  next = get_node_token (0);
  prev = get_node_token (0);
  up = get_node_token (0);

  if (verbose_mode)
    printf (_("Formatting node %s...\n"), node);
    
#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);
#endif /* HAVE_MACROS */

  no_indent = 1;
  if (!no_headers)
    {
      add_word_args ("\037\nFile: %s,  Node: ", pretty_output_filename);

#if defined (HAVE_MACROS)
      if (macro_expansion_output_stream && !executing_string)
        me_execute_string (node);
      else
#endif /* HAVE_MACROS */
        execute_string ("%s", node);
      filling_enabled = indented_fill = 0;
    }

  /* Check for defaulting of this node's next, prev, and up fields. */
  defaulting = (*next == 0 && *prev == 0 && *up == 0);

  this_section = what_section (input_text + input_text_offset);

  /* If we are defaulting, then look at the immediately following
     sectioning command (error if none) to determine the node's
     level.  Find the node that contains the menu mentioning this node
     that is one level up (error if not found).  That node is the "Up"
     of this node.  Default the "Next" and "Prev" from the menu. */
  if (defaulting)
    {
      NODE_REF *last_ref = (NODE_REF *)NULL;
      NODE_REF *ref = node_references;

      if ((this_section < 0) && (strcmp (node, "Top") != 0))
        {
          char *polite_section_name = "top";
          int i;

          for (i = 0; section_alist[i].name; i++)
            if (section_alist[i].level == current_section + 1)
              {
                polite_section_name = section_alist[i].name;
                break;
              }

          line_error
            (_("Node `%s' requires a sectioning command (e.g. %c%s)"),
             node, COMMAND_PREFIX, polite_section_name);
        }
      else
        {
          if (strcmp (node, "Top") == 0)
            {
              /* Default the NEXT pointer to be the first menu item in
                 this node, if there is a menu in this node.  We have to
                 try very hard to find the menu, as it may be obscured
                 by execution_strings which are on the filestack.  For
                 every member of the filestack which has a FILENAME
                 member which is identical to the current INPUT_FILENAME,
                 search forward from that offset. */
              int saved_input_text_offset = input_text_offset;
              int saved_size_of_input_text = size_of_input_text;
              char *saved_input_text = input_text;
              FSTACK *next_file = filestack;

              int orig_offset, orig_size;
              char *glean_node_from_menu ();

              /* No matter what, make this file point back at `(dir)'. */
              free (up);   up = xstrdup ("(dir)");

              while (1)
                {
                  orig_offset = input_text_offset;
                  orig_size =
                    search_forward (node_search_string, orig_offset);

                  if (orig_size < 0)
                    orig_size = size_of_input_text;

                  input_text_offset =
                    search_forward (menu_search_string, orig_offset);

                  if (input_text_offset > -1)
                    {
                      char *nodename_from_menu = (char *)NULL;

                      input_text_offset =
                        search_forward ("\n* ", input_text_offset);

                      if (input_text_offset != -1)
                        nodename_from_menu = glean_node_from_menu (0);

                      if (nodename_from_menu)
                        {
                          free (next); next = nodename_from_menu;
                          break;
                        }
                    }

                  /* We got here, so it hasn't been found yet.  Try
                     the next file on the filestack if there is one. */
                  if (next_file &&
                      (strcmp (next_file->filename, input_filename) == 0))
                    {
                      input_text = next_file->text;
                      input_text_offset = next_file->offset;
                      size_of_input_text = next_file->size;
                      next_file = next_file->next;
                    }
                  else
                    {
                      /* No more input files to check. */
                      break;
                    }
                }

              input_text = saved_input_text;
              input_text_offset = saved_input_text_offset;
              size_of_input_text = saved_size_of_input_text;
            }
        }

      /* Fix the level of the menu references in the Top node, iff it
         was declared with @@top, and no subsequent reference was found. */
      if (top_node_seen && !non_top_node_seen)
        {
          /* Then this is the first non-@@top node seen. */
          int level;

          level = set_top_section_level (this_section - 1);
          non_top_node_seen = 1;

          while (ref)
            {
              if (ref->section == level)
                ref->section = this_section - 1;
              ref = ref->next;
            }

          ref = node_references;
        }

      while (ref)
        {
          if (ref->section == (this_section - 1) &&
              ref->type == menu_reference &&
              strcmp (ref->node, node) == 0)
            {
              char *containing_node = ref->containing_node;

              free (up);
              up = xstrdup (containing_node);

              if (last_ref &&
                  last_ref->type == menu_reference &&
                  (strcmp (last_ref->containing_node,
                           containing_node) == 0))
                {
                  free (next);
                  next = xstrdup (last_ref->node);
                }

              while ((ref->section == this_section - 1) &&
                     (ref->next) &&
                     (ref->next->type != menu_reference))
                ref = ref->next;

              if (ref->next && ref->type == menu_reference &&
                  (strcmp (ref->next->containing_node,
                           containing_node) == 0))
                {
                  free (prev);
                  prev = xstrdup (ref->next->node);
                }
              else if (!ref->next &&
                       strcasecmp (ref->containing_node, "Top") == 0)
                {
                  free (prev);
                  prev = xstrdup (ref->containing_node);
                }
              break;
            }
          last_ref = ref;
          ref = ref->next;
        }
    }

#if defined (HAVE_MACROS)
  /* Insert the correct args if we are expanding macros, and the node's
     pointers weren't defaulted. */
  if (macro_expansion_output_stream && !executing_string && !defaulting)
    {
      char *temp;
      int op_orig = output_paragraph_offset;

      temp = (char *)xmalloc (3 + strlen (next));
      sprintf (temp, ", %s", next);
      me_execute_string (temp);
      free (temp);

      temp = (char *)xmalloc (3 + strlen (prev));
      sprintf (temp, ", %s", prev);
      me_execute_string (temp);
      free (temp);

      temp = (char *)xmalloc (4 + strlen (up));
      sprintf (temp, ", %s", up);
      me_execute_string (temp);
      free (temp);

      output_paragraph_offset = op_orig;
    }
#endif /* HAVE_MACROS */

  if (!no_headers)
    {
#if defined (HAVE_MACROS)
      if (macro_expansion_output_stream)
        me_inhibit_expansion++;
#endif /* HAVE_MACROS */

      if (*next)
        {
          execute_string (",  Next: %s", next);
          filling_enabled = indented_fill = 0;
        }

      if (*prev)
        {
          execute_string (",  Prev: %s", prev);
          filling_enabled = indented_fill = 0;
        }

      if (*up)
        {
          execute_string (",  Up: %s", up);
          filling_enabled = indented_fill = 0;
        }
#if defined (HAVE_MACROS)
      if (macro_expansion_output_stream)
        me_inhibit_expansion--;
#endif /* HAVE_MACROS */
    }

  close_paragraph ();
  no_indent = 0;

  if (!*node)
    {
      line_error ("No node name specified for `%c%s' command",
                  COMMAND_PREFIX, command);
      free (node);
      free (next);
      free (prev);
      free (up);
    }
  else
    {
      if (!*next) { free (next); next = (char *)NULL; }
      if (!*prev) { free (prev); prev = (char *)NULL; }
      if (!*up) { free (up); up = (char *)NULL; }
      remember_node (node, prev, next, up, new_node_pos, line_number, no_warn);
    }

  /* Change the section only if there was a sectioning command. */
  if (this_section >= 0)
    current_section = this_section;

  filling_enabled = 1;
}

/* Validation of an info file.
   Scan through the list of tag entries touching the Prev, Next, and Up
   elements of each.  It is an error not to be able to touch one of them,
   except in the case of external node references, such as "(DIR)".

   If the Prev is different from the Up,
   then the Prev node must have a Next pointing at this node.

   Every node except Top must have an Up.
   The Up node must contain some sort of reference, other than a Next,
   to this node.

   If the Next is different from the Next of the Up,
   then the Next node must have a Prev pointing at this node. */
void
validate_file (tag_table)
     TAG_ENTRY *tag_table;
{
  char *old_input_filename = input_filename;
  TAG_ENTRY *tags = tag_table;

  while (tags != (TAG_ENTRY *) NULL)
    {
      register TAG_ENTRY *temp_tag;

      input_filename = tags->filename;
      line_number = tags->line_no;

      /* If this is a "no warn" node, don't validate it in any way. */
      if (tags->flags & NO_WARN)
        {
          tags = tags->next_ent;
          continue;
        }

      /* If this node has a Next, then make sure that the Next exists. */
      if (tags->next)
        {
          validate (tags->next, tags->line_no, "Next");

          /* If the Next node exists, and there is no Up, then make
             sure that the Prev of the Next points back. */
          temp_tag = find_node (tags->next);
          if (temp_tag)
            {
              char *prev;

              if (temp_tag->flags & NO_WARN)
                {
                  /* Do nothing if we aren't supposed to issue warnings
                     about this node. */
                }
              else
                {
                  prev = temp_tag->prev;
                  if (!prev || (strcmp (prev, tags->node) != 0))
                    {
                      line_error (_("Node `%s''s Next field not pointed back to"),
                                  tags->node);
                      line_number = temp_tag->line_no;
                      input_filename = temp_tag->filename;
                      line_error
                        (_("This node (`%s') is the one with the bad `Prev'"),
                         temp_tag->node);
                      input_filename = tags->filename;
                      line_number = tags->line_no;
                      temp_tag->flags |= PREV_ERROR;
                    }
                }
            }
        }

      /* Validate the Prev field if there is one, and we haven't already
         complained about it in some way.  You don't have to have a Prev
         field at this stage. */
      if (!(tags->flags & PREV_ERROR) && tags->prev)
        {
          int valid_p = validate (tags->prev, tags->line_no, "Prev");

          if (!valid_p)
            tags->flags |= PREV_ERROR;
          else
            {
              /* If the Prev field is not the same as the Up field,
                 then the node pointed to by the Prev field must have
                 a Next field which points to this node. */
              if (tags->up && (strcmp (tags->prev, tags->up) != 0))
                {
                  temp_tag = find_node (tags->prev);

                  /* If we aren't supposed to issue warnings about the
                     target node, do nothing. */
                  if (!temp_tag || (temp_tag->flags & NO_WARN))
                    {
                      /* Do nothing. */
                    }
                  else
                    {
                      if (!temp_tag->next ||
                          (strcmp (temp_tag->next, tags->node) != 0))
                        {
                          line_error
                            (_("Node `%s's Prev field not pointed back to"),
                             tags->node);
                          line_number = temp_tag->line_no;
                          input_filename = temp_tag->filename;
                          line_error (_("This node (`%s') has the bad Next"),
                                      temp_tag->node);
                          input_filename = tags->filename;
                          line_number = tags->line_no;
                          temp_tag->flags |= NEXT_ERROR;
                        }
                    }
                }
            }
        }

      if (!tags->up && (strcasecmp (tags->node, _("Top")) != 0))
        line_error (_("Node `%s' missing Up field"), tags->node);
      else if (tags->up)
        {
          int valid_p = validate (tags->up, tags->line_no, "Up");

          /* If node X has Up: Y, then warn if Y fails to have a menu item
             or note pointing at X, if Y isn't of the form "(Y)". */
          if (valid_p && *tags->up != '(')
            {
              NODE_REF *nref, *tref, *list;
              NODE_REF *find_node_reference ();

              tref = (NODE_REF *) NULL;
              list = node_references;

              for (;;)
                {
                  if (!(nref = find_node_reference (tags->node, list)))
                    break;

                  if (strcmp (nref->containing_node, tags->up) == 0)
                    {
                      if (nref->type != menu_reference)
                        {
                          tref = nref;
                          list = nref->next;
                        }
                      else
                        break;
                    }
                  list = nref->next;
                }

              if (!nref)
                {
                  temp_tag = find_node (tags->up);
                  line_number = temp_tag->line_no;
                  input_filename = temp_tag->filename;
                  if (!tref)
                    line_error (
_("`%s' has an Up field of `%s', but `%s' has no menu item for `%s'"),
                                tags->node, tags->up, tags->up, tags->node);
                  line_number = tags->line_no;
                  input_filename = tags->filename;
                }
            }
        }
      tags = tags->next_ent;
    }

  validate_other_references (node_references);
  /* We have told the user about the references which didn't exist.
     Now tell him about the nodes which aren't referenced. */

  tags = tag_table;
  while (tags != (TAG_ENTRY *) NULL)
    {
      /* If this node is a "no warn" node, do nothing. */
      if (tags->flags & NO_WARN)
        {
          tags = tags->next_ent;
          continue;
        }

      /* Special hack.  If the node in question appears to have
         been referenced more than REFERENCE_WARNING_LIMIT times,
         give a warning. */
      if (tags->touched > reference_warning_limit)
        {
          input_filename = tags->filename;
          line_number = tags->line_no;
          warning (_("node `%s' has been referenced %d times"),
                   tags->node, tags->touched);
        }

      if (tags->touched == 0)
        {
          input_filename = tags->filename;
          line_number = tags->line_no;

          /* Notice that the node "Top" is special, and doesn't have to
             be referenced. */
          if (strcasecmp (tags->node, _("Top")) != 0)
            warning (_("unreferenced node `%s'"), tags->node);
        }
      tags = tags->next_ent;
    }
  input_filename = old_input_filename;
}

/* Return 1 if tag correctly validated, or 0 if not. */
int
validate (tag, line, label)
     char *tag;
     int line;
     char *label;
{
  TAG_ENTRY *result;

  /* If there isn't a tag to verify, or if the tag is in another file,
     then it must be okay. */
  if (!tag || !*tag || *tag == '(')
    return (1);

  /* Otherwise, the tag must exist. */
  result = find_node (tag);

  if (!result)
    {
      line_number = line;
      line_error (_("%s reference to nonexistent node `%s'"), label, tag);
      return (0);
    }
  result->touched++;
  return (1);
}

/* Split large output files into a series of smaller files.  Each file
   is pointed to in the tag table, which then gets written out as the
   original file.  The new files have the same name as the original file
   with a "-num" attached.  SIZE is the largest number of bytes to allow
   in any single split file. */
void
split_file (filename, size)
     char *filename;
     int size;
{
  char *root_filename, *root_pathname;
  char *the_file, *filename_part ();
  struct stat fileinfo;
  long file_size;
  char *the_header;
  int header_size;

  /* Can only do this to files with tag tables. */
  if (!tag_table)
    return;

  if (size == 0)
    size = DEFAULT_SPLIT_SIZE;

  if ((stat (filename, &fileinfo) != 0) ||
      (((long) fileinfo.st_size) < SPLIT_SIZE_THRESHOLD))
    return;
  file_size = (long) fileinfo.st_size;

  the_file = find_and_load (filename);
  if (!the_file)
    return;

  root_filename = filename_part (filename);
  root_pathname = pathname_part (filename);

  if (!root_pathname)
    root_pathname = xstrdup ("");

  /* Start splitting the file.  Walk along the tag table
     outputting sections of the file.  When we have written
     all of the nodes in the tag table, make the top-level
     pointer file, which contains indirect pointers and
     tags for the nodes. */
  {
    int which_file = 1;
    TAG_ENTRY *tags = tag_table;
    char *indirect_info = (char *)NULL;

    /* Remember the `header' of this file.  The first tag in the file is
       the bottom of the header; the top of the file is the start. */
    the_header = (char *)xmalloc (1 + (header_size = tags->position));
    memcpy (the_header, the_file, header_size);

    while (tags)
      {
        int file_top, file_bot, limit;

        /* Have to include the Control-_. */
        file_top = file_bot = tags->position;
        limit = file_top + size;

        /* If the rest of this file is only one node, then
           that is the entire subfile. */
        if (!tags->next_ent)
          {
            int i = tags->position + 1;
            char last_char = the_file[i];

            while (i < file_size)
              {
                if ((the_file[i] == '\037') &&
                    ((last_char == '\n') ||
                     (last_char == '\014')))
                  break;
                else
                  last_char = the_file[i];
                i++;
              }
            file_bot = i;
            tags = tags->next_ent;
            goto write_region;
          }

        /* Otherwise, find the largest number of nodes that can fit in
           this subfile. */
        for (; tags; tags = tags->next_ent)
          {
            if (!tags->next_ent)
              {
                /* This entry is the last node.  Search forward for the end
                   of this node, and that is the end of this file. */
                int i = tags->position + 1;
                char last_char = the_file[i];

                while (i < file_size)
                  {
                    if ((the_file[i] == '\037') &&
                        ((last_char == '\n') ||
                         (last_char == '\014')))
                      break;
                    else
                      last_char = the_file[i];
                    i++;
                  }
                file_bot = i;

                if (file_bot < limit)
                  {
                    tags = tags->next_ent;
                    goto write_region;
                  }
                else
                  {
                    /* Here we want to write out everything before the last
                       node, and then write the last node out in a file
                       by itself. */
                    file_bot = tags->position;
                    goto write_region;
                  }
              }

            if (tags->next_ent->position > limit)
              {
                if (tags->position == file_top)
                  tags = tags->next_ent;

                file_bot = tags->position;

              write_region:
                {
                  int fd;
                  char *split_filename;

                  split_filename = (char *) xmalloc
                    (10 + strlen (root_pathname) + strlen (root_filename));
                  sprintf
                    (split_filename,
                     "%s%s-%d", root_pathname, root_filename, which_file);

                  fd = open
                    (split_filename, O_WRONLY | O_TRUNC | O_CREAT, 0666);

                  if ((fd < 0) ||
                      (write (fd, the_header, header_size) != header_size) ||
                      (write (fd, the_file + file_top, file_bot - file_top)
                       != (file_bot - file_top)) ||
                      ((close (fd)) < 0))
                    {
                      perror (split_filename);
                      if (fd != -1)
                        close (fd);
                      exit (FATAL);
                    }

                  if (!indirect_info)
                    {
                      indirect_info = the_file + file_top;
                      sprintf (indirect_info, "\037\nIndirect:\n");
                      indirect_info += strlen (indirect_info);
                    }

                  sprintf (indirect_info, "%s-%d: %d\n",
                           root_filename, which_file, file_top);

                  free (split_filename);
                  indirect_info += strlen (indirect_info);
                  which_file++;
                  break;
                }
              }
          }
      }

    /* We have sucessfully created the subfiles.  Now write out the
       original again.  We must use `output_stream', or
       write_tag_table_indirect () won't know where to place the output. */
    output_stream = fopen (filename, "w");
    if (!output_stream)
      {
        perror (filename);
        exit (FATAL);
      }

    {
      int distance = indirect_info - the_file;
      fwrite (the_file, 1, distance, output_stream);

      /* Inhibit newlines. */
      paragraph_is_open = 0;

      write_tag_table_indirect ();
      fclose (output_stream);
      free (the_header);
      free (the_file);
      return;
    }
  }
}

/* The strings here are followed in the message by `reference to...' in
   the `validate' routine.  */
char *
reftype_type_string (type)
     enum reftype type;
{
  switch (type)
    {
    case menu_reference:
      return ("Menu");
    case followed_reference:
      return ("Cross");
    default:
      return ("Internal-bad-reference-type");
    }
}

/* Remember this node name for later validation use.  This is used to
   remember menu references while reading the input file.  After the
   output file has been written, if validation is on, then we use the
   contents of `node_references' as a list of nodes to validate.  */
void
remember_node_reference (node, line, type)
     char *node;
     int line;
     enum reftype type;
{
  NODE_REF *temp = (NODE_REF *) xmalloc (sizeof (NODE_REF));

  temp->next = node_references;
  temp->node = xstrdup (node);
  temp->line_no = line;
  temp->section = current_section;
  temp->type = type;
  temp->containing_node = xstrdup (current_node ? current_node : "");
  temp->filename = node_filename;

  node_references = temp;
}

void
validate_other_references (ref_list)
     register NODE_REF *ref_list;
{
  char *old_input_filename = input_filename;

  while (ref_list != (NODE_REF *) NULL)
    {
      input_filename = ref_list->filename;
      validate (ref_list->node, ref_list->line_no,
                reftype_type_string (ref_list->type));
      ref_list = ref_list->next;
    }
  input_filename = old_input_filename;
}

/* Find NODE in REF_LIST. */
NODE_REF *
find_node_reference (node, ref_list)
     char *node;
     register NODE_REF *ref_list;
{
  while (ref_list)
    {
      if (strcmp (node, ref_list->node) == 0)
        break;
      ref_list = ref_list->next;
    }
  return (ref_list);
}

void
free_node_references ()
{
  register NODE_REF *list, *temp;

  list = node_references;

  while (list)
    {
      temp = list;
      free (list->node);
      free (list->containing_node);
      list = list->next;
      free (temp);
    }
  node_references = (NODE_REF *) NULL;
}

  /* This function gets called at the start of every line while inside of
     a menu.  It checks to see if the line starts with "* ", and if so,
     remembers the node reference that this menu refers to.
     input_text_offset is at the \n just before the line start. */
#define menu_starter "* "
char *
glean_node_from_menu (remember_reference)
     int remember_reference;
{
  int i, orig_offset = input_text_offset;
  char *nodename;

  if (strncmp (&input_text[input_text_offset + 1],
               menu_starter,
               strlen (menu_starter)) != 0)
    return ((char *)NULL);
  else
    input_text_offset += strlen (menu_starter) + 1;

  get_until_in_line (0, ":", &nodename);
  if (curchar () == ':')
    input_text_offset++;
  canon_white (nodename);

  if (curchar () == ':')
    goto save_node;

  free (nodename);
  get_rest_of_line (&nodename);

  /* Special hack: If the nodename follows the menu item name,
     then we have to read the rest of the line in order to find
     out what the nodename is.  But we still have to read the
     line later, in order to process any formatting commands that
     might be present.  So un-count the carriage return that has just
     been counted. */
  line_number--;

  isolate_nodename (nodename);

save_node:
  input_text_offset = orig_offset;
  normalize_node_name (nodename);
  i = strlen (nodename);
  if (i && nodename[i - 1] == ':')
    nodename[i - 1] = 0;

  if (remember_reference)
    {
      remember_node_reference (nodename, line_number, menu_reference);
      free (nodename);
      return ((char *)NULL);
    }
  else
    return (nodename);
}

static void
isolate_nodename (nodename)
     char *nodename;
{
  register int i, c;
  int paren_seen, paren;

  if (!nodename)
    return;

  canon_white (nodename);
  paren_seen = paren = i = 0;

  if (*nodename == '.' || !*nodename)
    {
      *nodename = 0;
      return;
    }

  if (*nodename == '(')
    {
      paren++;
      paren_seen++;
      i++;
    }

  for (; (c = nodename[i]); i++)
    {
      if (paren)
        {
          if (c == '(')
            paren++;
          else if (c == ')')
            paren--;

          continue;
        }

      /* If the character following the close paren is a space, then this
         node has no more characters associated with it. */
      if (c == '\t' ||
          c == '\n' ||
          c == ','  ||
          ((paren_seen && nodename[i - 1] == ')') &&
           (c == ' ' || c == '.')) ||
          (c == '.' &&
           ((!nodename[i + 1] ||
             (cr_or_whitespace (nodename[i + 1])) ||
             (nodename[i + 1] == ')')))))
        break;
    }
  nodename[i] = 0;
}

void
cm_menu ()
{
  if (current_node == (char *)NULL)
    {
      warning (_("%cmenu seen before first node"), COMMAND_PREFIX);
      warning (_("creating `Top' node"));
      execute_string ("@@node Top");
    }
  begin_insertion (menu);
}

void
cm_detailmenu ()
{
  if (current_node == (char *)NULL)
    {
      warning (_("%cmenu seen before first node"), COMMAND_PREFIX);
      warning (_("creating `Top' node"));
      execute_string ("@@node Top");
    }
  begin_insertion (detailmenu);
}

/* **************************************************************** */
/*                                                                  */
/*                      Cross Reference Hacking                     */
/*                                                                  */
/* **************************************************************** */

/* Return next comma-delimited argument, but do not cross a close-brace
   boundary.  Clean up whitespace, too.  */
char *
get_xref_token ()
{
  char *string;

  get_until_in_braces (",", &string);
  if (curchar () == ',')
    input_text_offset++;
  fix_whitespace (string);
  return (string);
}

int px_ref_flag = 0;            /* Controls initial output string. */

/* Make a cross reference. */
void
cm_xref (arg)
{
  if (arg == START)
    {
      char *arg1, *arg2, *arg3, *arg4, *arg5;

      arg1 = get_xref_token ();
      arg2 = get_xref_token ();
      arg3 = get_xref_token ();
      arg4 = get_xref_token ();
      arg5 = get_xref_token ();

      add_word_args ("%s", px_ref_flag ? "*note " : "*Note ");

      if (*arg5 || *arg4)
        {
          char *node_name;

          if (!*arg2)
            {
              if (*arg3)
                node_name = arg3;
              else
                node_name = arg1;
            }
          else
            node_name = arg2;

          execute_string ("%s: (%s)%s", node_name, arg4, arg1);
          /* Free all of the arguments found. */
          if (arg1) free (arg1);
          if (arg2) free (arg2);
          if (arg3) free (arg3);
          if (arg4) free (arg4);
          if (arg5) free (arg5);
          return;
        }
      else
        remember_node_reference (arg1, line_number, followed_reference);

      if (*arg3)
        {
          if (!*arg2)
            execute_string ("%s: %s", arg3, arg1);
          else
            execute_string ("%s: %s", arg2, arg1);
        }
      else
        {
          if (*arg2)
            execute_string ("%s: %s", arg2, arg1);
          else
            execute_string ("%s::", arg1);
        }

      /* Free all of the arguments found. */
      if (arg1) free (arg1);
      if (arg2) free (arg2);
      if (arg3) free (arg3);
      if (arg4) free (arg4);
      if (arg5) free (arg5);
    }
  else
    {
      /* Check to make sure that the next non-whitespace character is either
         a period or a comma. input_text_offset is pointing at the "}" which
         ended the xref or pxref command. */
      int temp = input_text_offset + 1;

      if (output_paragraph[output_paragraph_offset - 2] == ':' &&
          output_paragraph[output_paragraph_offset - 1] == ':')
        return;
      while (temp < size_of_input_text)
        {
          if (cr_or_whitespace (input_text[temp]))
            temp++;
          else
            {
              if (input_text[temp] != '.'
                  && input_text[temp] != ','
                  && input_text[temp] != '\t')
               {
                 line_error (
                          _("`.' or `,' must follow cross reference, not %c"), 
                             input_text[temp]);
                }
              break;
            }
        }
    }
}

void
cm_pxref (arg)
     int arg;
{
  if (arg == START)
    {
      px_ref_flag++;
      cm_xref (arg);
      px_ref_flag--;
    }
  else
    add_char ('.');
}

void
cm_inforef (arg)
     int arg;
{
  if (arg == START)
    {
      char *node = get_xref_token ();
      char *pname = get_xref_token ();
      char *file = get_xref_token ();

      if (*pname)
        execute_string ("*note %s: (%s)%s", pname, file, node);
      else
        execute_string ("*note (%s)%s::", file, node);

      free (node);
      free (pname);
      free (file);
    }
}

/* A URL reference.  */
void
cm_uref (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  if (arg == END)
    {
      char *comma;
      char *arg = (char *) &output_paragraph[start_pos];

      output_paragraph[end_pos] = 0;
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      arg = xstrdup (arg);
      comma = strchr (arg, ','); /* let's hope for no commas in the url  */
      if (comma)
        {
          *comma = 0;
          /* Ignore spaces at beginning of second arg.  */
          for (comma++; isspace (*comma); comma++)
            ;
          add_word (comma);
          add_char (' ');
          add_char ('(');
          add_word (arg);
          add_char (')');
        }
      else
        {
          extern int printing_index;
          
          if (!printing_index)
            add_char ('`');
            
          add_word (arg);
          
          if (!printing_index)
            add_char ('\'');
        }
      free (arg);
   }
}

/* An email reference.  */
void
cm_email (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  if (arg == END)
    {
      char *comma;
      char *arg = (char *) &output_paragraph[start_pos];

      output_paragraph[end_pos] = 0;
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      arg = xstrdup (arg);
      comma = strchr (arg, ',');
      if (comma)
        {
          *comma = 0;
          for (comma++; isspace (*comma); comma++)
            ;
          add_word (comma);
          add_char (' ');
        }
      add_char ('<');
      add_word (arg);
      add_char ('>');
      free (arg);
    }
}

/* An external image is a reference, kind of.  The parsing is (not
   coincidentally) similar, anyway.  */
void
cm_image (arg)
     int arg;
{
  if (arg == START)
    {
      char *name_arg = get_xref_token ();
      /* We don't yet care about any other args, but read them so they
         don't end up in the text.  */
      char *arg = get_xref_token ();
      if (arg) free (arg);
      arg = get_xref_token ();
      if (arg) free (arg);
      
      if (*name_arg)
        {
          /* Try to open foo.txt.  */
          FILE *image_file;
          char *name = xmalloc (strlen (name_arg) + 4);
          strcpy (name, name_arg);
          strcat (name, ".txt");
          image_file = fopen (name, "r");
          if (image_file)
            {
              int ch;
              int save_inhibit_indentation = inhibit_paragraph_indentation;
              int save_filling_enabled = filling_enabled;
              
              inhibit_paragraph_indentation = 1;
              filling_enabled = 0;
              last_char_was_newline = 0;
              
              /* Maybe we need to remove the final newline if the image
                 file is only one line to allow in-line images.  On the
                 other hand, they could just make the file without a
                 final newline.  */
              while ((ch = getc (image_file)) != EOF)
                add_char (ch);
              
              inhibit_paragraph_indentation = save_inhibit_indentation;
              filling_enabled = save_filling_enabled;
              
              if (fclose (image_file) != 0) {
                perror (name);
              }
            }
          else
            warning (_("@@image file `%s' unreadable: %s"), name,
                     strerror (errno));
        }
      else
        line_error (_("@@image missing filename argument"));

      if (name_arg) free (name_arg);
    }
}

/* **************************************************************** */
/*                                                                  */
/*                      Insertion Command Stubs                     */
/*                                                                  */
/* **************************************************************** */

void
cm_quotation ()
{
  begin_insertion (quotation);
}

void
cm_example ()
{
  begin_insertion (example);
}

void
cm_smallexample ()
{
  begin_insertion (smallexample);
}

void
cm_lisp ()
{
  begin_insertion (lisp);
}

void
cm_smalllisp ()
{
  begin_insertion (smalllisp);
}

/* @@cartouche/@@end cartouche draws box with rounded corners in
   TeX output.  Right now, just a no-op insertion. */
void
cm_cartouche ()
{
  begin_insertion (cartouche);
}

void
cm_format ()
{
  begin_insertion (format);
}

void
cm_display ()
{
  begin_insertion (display);
}

void
cm_direntry ()
{
  if (no_headers)
    command_name_condition ();
  else
    begin_insertion (direntry);
}

void
cm_itemize ()
{
  begin_insertion (itemize);
}

void
cm_enumerate ()
{
  do_enumeration (enumerate, "1");
}

/* Start an enumeration insertion of type TYPE.  If the user supplied
   no argument on the line, then use DEFAULT_STRING as the initial string. */
void
do_enumeration (type, default_string)
     int type;
     char *default_string;
{
  get_until_in_line (0, ".", &enumeration_arg);
  canon_white (enumeration_arg);

  if (!*enumeration_arg)
    {
      free (enumeration_arg);
      enumeration_arg = xstrdup (default_string);
    }

  if (!isdigit (*enumeration_arg) && !isletter (*enumeration_arg))
    {
      warning (_("%s requires letter or digit"), insertion_type_pname (type));

      switch (type)
        {
        case enumerate:
          default_string = "1";
          break;
        }
      enumeration_arg = xstrdup (default_string);
    }
  begin_insertion (type);
}

void
cm_table ()
{
  begin_insertion (table);
}

void
cm_multitable ()
{
  begin_insertion (multitable); /* @@@@ */
}

void
cm_ftable ()
{
  begin_insertion (ftable);
}

void
cm_vtable ()
{
  begin_insertion (vtable);
}

void
cm_group ()
{
  begin_insertion (group);
}

void
cm_ifinfo ()
{
  begin_insertion (ifinfo);
}

void
cm_ifnothtml ()
{
  begin_insertion (ifnothtml);
}

void
cm_ifnottex ()
{
  begin_insertion (ifnottex);
}

/* Begin an insertion where the lines are not filled or indented. */
void
cm_flushleft ()
{
  begin_insertion (flushleft);
}

/* Begin an insertion where the lines are not filled, and each line is
   forced to the right-hand side of the page. */
void
cm_flushright ()
{
  begin_insertion (flushright);
}

/* End existing insertion block. */
void
cm_end ()
{
  char *temp;
  enum insertion_type type;

  if (!insertion_level)
    {
      line_error (_("Unmatched `%c%s'"), COMMAND_PREFIX, command);
      return;
    }

  get_rest_of_line (&temp);

  if (temp[0] == 0)
    line_error (_("`%c%s' needs something after it"), COMMAND_PREFIX, command);

  type = find_type_from_name (temp);

  if (type == bad_type)
    {
      line_error (_("Bad argument to `%s', `%s', using `%s'"),
           command, temp, insertion_type_pname (current_insertion_type ()));
    }
  end_insertion (type);
  free (temp);
}

/* **************************************************************** */
/*                                                                  */
/*                        Conditional Handling                      */
/*                                                                  */
/* **************************************************************** */

/* A structure which contains `defined' variables. */
typedef struct defines {
  struct defines *next;
  char *name;
  char *value;
} DEFINE;

/* The linked list of `set' defines. */
DEFINE *defines = (DEFINE *)NULL;

/* Add NAME to the list of `set' defines. */
void
set (name, value)
     char *name;
     char *value;
{
  DEFINE *temp;

  for (temp = defines; temp; temp = temp->next)
    if (strcmp (name, temp->name) == 0)
      {
        free (temp->value);
        temp->value = xstrdup (value);
        return;
      }

  temp = (DEFINE *)xmalloc (sizeof (DEFINE));
  temp->next = defines;
  temp->name = xstrdup (name);
  temp->value = xstrdup (value);
  defines = temp;
}

/* Remove NAME from the list of `set' defines. */
void
clear (name)
     char *name;
{
  register DEFINE *temp, *last;

  last = (DEFINE *)NULL;
  temp = defines;

  while (temp)
    {
      if (strcmp (temp->name, name) == 0)
        {
          if (last)
            last->next = temp->next;
          else
            defines = temp->next;

          free (temp->name);
          free (temp->value);
          free (temp);
          break;
        }
      last = temp;
      temp = temp->next;
    }
}

/* Return the value of NAME.  The return value is NULL if NAME is unset. */
char *
set_p (name)
     char *name;
{
  register DEFINE *temp;

  for (temp = defines; temp; temp = temp->next)
    if (strcmp (temp->name, name) == 0)
      return (temp->value);

  return ((char *)NULL);
}

/* Conditionally parse based on the current command name. */
void
command_name_condition ()
{
  char *discarder;

  discarder = (char *)xmalloc (8 + strlen (command));

  sprintf (discarder, "\n%cend %s", COMMAND_PREFIX, command);
  discard_until (discarder);
  discard_until ("\n");

  free (discarder);
}

/* Create a variable whose name appears as the first word on this line. */
void
cm_set ()
{
  handle_variable (SET);
}

/* Remove a variable whose name appears as the first word on this line. */
void
cm_clear ()
{
  handle_variable (CLEAR);
}

void
cm_ifset ()
{
  handle_variable (IFSET);
}

void
cm_ifclear ()
{
  handle_variable (IFCLEAR);
}

/* This command takes braces, but we parse the contents specially, so we
   don't use the standard brace popping code.

   The syntax @@ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands
   if ARG1 and ARG2 caselessly string compare to the same string, otherwise,
   it produces no output. */
void
cm_ifeq ()
{
  char **arglist;

  arglist = get_brace_args (0);

  if (arglist)
    {
      if (array_len (arglist) > 1)
        {
          if ((strcasecmp (arglist[0], arglist[1]) == 0) &&
              (arglist[2] != (char *)NULL))
            execute_string ("%s\n", arglist[2]);
        }

      free_array (arglist);
    }
}

void
cm_value (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  if (arg == END)
    {
      char *name = (char *) &output_paragraph[start_pos];
      char *value;
      output_paragraph[end_pos] = 0;
      name = xstrdup (name);
      value = set_p (name);
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      if (value)
        execute_string ("%s", value);
      else
        add_word_args (_("{No Value For \"%s\"}"), name);

      free (name);
    }
}

/* Set, clear, or conditionalize based on ACTION. */
void
handle_variable (action)
     int action;
{
  char *name;

  get_rest_of_line (&name);
  backup_input_pointer ();
  handle_variable_internal (action, name);
  free (name);
}

void
handle_variable_internal (action, name)
     int action;
     char *name;
{
  char *temp;
  int delimiter, additional_text_present = 0;

  /* Only the first word of NAME is a valid tag. */
  temp = name;
  delimiter = 0;
  while (*temp && (delimiter || !whitespace (*temp)))
    {
/* #if defined (SET_WITH_EQUAL) */
      if (*temp == '"' || *temp == '\'')
        {
          if (*temp == delimiter)
            delimiter = 0;
          else
            delimiter = *temp;
        }
/* #endif SET_WITH_EQUAL */
      temp++;
    }

  if (*temp)
    additional_text_present++;

  *temp = 0;

  if (!*name)
    line_error (_("%c%s requires a name"), COMMAND_PREFIX, command);
  else
    {
      switch (action)
        {
        case SET:
          {
            char *value;

#if defined (SET_WITH_EQUAL)
            /* Allow a value to be saved along with a variable.  The value is
               the text following an `=' sign in NAME, if any is present. */

            for (value = name; *value && *value != '='; value++);

            if (*value)
              *value++ = 0;

            if (*value == '"' || *value == '\'')
              {
                value++;
                value[strlen (value) - 1] = 0;
              }

#else /* !SET_WITH_EQUAL */
            /* The VALUE of NAME is the remainder of the line sans
               whitespace. */
            if (additional_text_present)
              {
                value = temp + 1;
                canon_white (value);
              }
            else
              value = "";
#endif /* !SET_WITH_VALUE */

            set (name, value);
          }
          break;

        case CLEAR:
          clear (name);
          break;

        case IFSET:
        case IFCLEAR:
          /* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,
             read lines from the the file until we reach a matching
             "@@end CONDITION".  This means that we only take note of
             "@@ifset/clear" and "@@end" commands. */
          {
            char condition[8];
            int condition_len;
            int orig_line_number = line_number;

            if (action == IFSET)
              strcpy (condition, "ifset");
            else
              strcpy (condition, "ifclear");

            condition_len = strlen (condition);

          if ((action == IFSET && !set_p (name))
              || (action == IFCLEAR && set_p (name)))
            {
              int level = 0, done = 0;

              while (!done && input_text_offset < size_of_input_text)
                {
                  char *freeable_line, *line;

                  get_rest_of_line (&freeable_line);

                  for (line = freeable_line; whitespace (*line); line++);

                  if (*line == COMMAND_PREFIX &&
                      (strncmp (line + 1, condition, condition_len) == 0))
                    level++;
                  else if (strncmp (line, "@@end", 4) == 0)
                    {
                      char *cname = line + 4;
                      char *temp;

                      while (*cname && whitespace (*cname))
                        cname++;
                      temp = cname;

                      while (*temp && !whitespace (*temp))
                        temp++;
                      *temp = 0;

                      if (strcmp (cname, condition) == 0)
                        {
                          if (!level)
                            {
                              done = 1;
                            }
                          else
                            level--;
                        }
                    }
                  free (freeable_line);
                }
              
              if (!done)
                {
                  int save = line_number;
                  line_number = orig_line_number;
                  line_error (_("Reached eof before matching @@end %s"),
                              condition);
                  line_number = save;
                }
                
              /* We found the end of a false @@ifset/ifclear.  If we are
                 in a menu, back up over the newline that ends the ifset,
                 since that newline may also begin the next menu entry. */
              break;
            }
          else
            {
              if (action == IFSET)
                begin_insertion (ifset);
              else
                begin_insertion (ifclear);
            }
          }
          break;
        }
    }
}

/* Execution of random text not in file. */

typedef struct {
  char *string;                 /* The string buffer. */
  int size;                     /* The size of the buffer. */
  int in_use;                   /* Nonzero means string currently in use. */
} EXECUTION_STRING;

static EXECUTION_STRING **execution_strings = (EXECUTION_STRING **)NULL;
static int execution_strings_index = 0;
static int execution_strings_slots = 0;

EXECUTION_STRING *
get_execution_string (initial_size)
     int initial_size;
{
  register int i = 0;
  EXECUTION_STRING *es = (EXECUTION_STRING *)NULL;

  if (execution_strings)
    {
      for (i = 0; i < execution_strings_index; i++)
        if (execution_strings[i] && (execution_strings[i]->in_use == 0))
          {
            es = execution_strings[i];
            break;
          }
    }

  if (!es)
    {
      if (execution_strings_index + 1 >= execution_strings_slots)
        {
          execution_strings = (EXECUTION_STRING **)xrealloc
            (execution_strings,
             (execution_strings_slots += 3) * sizeof (EXECUTION_STRING *));
          for (; i < execution_strings_slots; i++)
            execution_strings[i] = (EXECUTION_STRING *)NULL;
        }

      execution_strings[execution_strings_index] =
        (EXECUTION_STRING *)xmalloc (sizeof (EXECUTION_STRING));
      es = execution_strings[execution_strings_index];
      execution_strings_index++;

      es->size = 0;
      es->string = (char *)NULL;
      es->in_use = 0;
    }

  if (initial_size > es->size)
    {
      es->string = (char *) xrealloc (es->string, initial_size);
      es->size = initial_size;
    }
  return (es);
}

/* Execute the string produced by formatting the ARGs with FORMAT.  This
   is like submitting a new file with @@include. */
void
#if defined (VA_FPRINTF) && __STDC__
execute_string (char *format, ...)
#else
execute_string (format, va_alist)
    char *format;
    va_dcl
#endif
{
  EXECUTION_STRING *es;
  char *temp_string;
#ifdef VA_FPRINTF
  va_list ap;
#endif

  es = get_execution_string (4000);
  temp_string = es->string;
  es->in_use = 1;

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (temp_string, format, ap);
#else
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);

  pushfile ();
  input_text_offset = 0;
  input_text = temp_string;
  input_filename = xstrdup (input_filename);
  size_of_input_text = strlen (temp_string);

  executing_string++;
  reader_loop ();
  free (input_filename);

  popfile ();
  executing_string--;
  es->in_use = 0;
}


/* Return what would be output for STR, i.e., expand Texinfo commands.
   If IMPLICIT_CODE is set, expand @@code{STR}.  */

char *
expansion (str, implicit_code)
    char *str;
    int implicit_code;
{
  int length;
  char *result;

  /* Inhibit any real output.  */
  int start = output_paragraph_offset;
  int saved_paragraph_is_open = paragraph_is_open;

  inhibit_output_flushing ();
  paragraph_is_open = 1;
  execute_string (implicit_code ? "@@code{%s}" : "%s", str);
  uninhibit_output_flushing ();

  /* Copy the expansion from the buffer.  */
  length = output_paragraph_offset - start;
  result = xmalloc (1 + length);
  memcpy (result, (char *) (output_paragraph + start), length);
  result[length] = 0;
  
  /* Pretend it never happened.  */
  output_paragraph_offset = start;
  paragraph_is_open = saved_paragraph_is_open;

  return result;
}

/* @@itemx, @@item. */

static int itemx_flag = 0;

void
cm_itemx ()
{
  itemx_flag++;
  cm_item ();
  itemx_flag--;
}

void
cm_item ()
{
  char *rest_of_line, *item_func;

  /* Can only hack "@@item" while inside of an insertion. */
  if (insertion_level)
    {
      INSERTION_ELT *stack = insertion_stack;
      int original_input_text_offset;

      skip_whitespace ();
      original_input_text_offset = input_text_offset;

      get_rest_of_line (&rest_of_line);
      item_func = current_item_function ();

      /* Okay, do the right thing depending on which insertion function
         is active. */

    switch_top:
      switch (stack->insertion)
        {
        case multitable:
          multitable_item ();
          /* Ultra special hack.  It appears that some people incorrectly
             place text directly after the @@item, instead of on a new line
             by itself.  This happens to work in TeX, so I make it work
             here. */
          if (*rest_of_line)
            {
              line_number--;
              input_text_offset = original_input_text_offset;
            }
          break;

        case ifinfo:
        case ifset:
        case ifclear:
        case cartouche:
          stack = stack->next;
          if (!stack)
            goto no_insertion;
          else
            goto switch_top;
          break;

        case menu:
        case quotation:
        case example:
        case smallexample:
        case lisp:
        case format:
        case display:
        case group:
          line_error (_("The `%c%s' command is meaningless within a `@@%s' block"),
                      COMMAND_PREFIX, command,
                      insertion_type_pname (current_insertion_type ()));
          break;

        case itemize:
        case enumerate:
          if (itemx_flag)
            {
              line_error (_("%citemx is not meaningful inside of a `%s' block"),
                          COMMAND_PREFIX,
                          insertion_type_pname (current_insertion_type ()));
            }
          else
            {
              start_paragraph ();
              kill_self_indent (-1);
              filling_enabled = indented_fill = 1;

              if (current_insertion_type () == itemize)
                {
                  indent (output_column = current_indent - 2);

                  /* I need some way to determine whether this command
                     takes braces or not.  I believe the user can type
                     either "@@bullet" or "@@bullet{}".  Of course, they
                     can also type "o" or "#" or whatever else they want. */
                  if (item_func && *item_func)
                    {
                      if (*item_func == COMMAND_PREFIX)
                        if (item_func[strlen (item_func) - 1] != '}')
                          execute_string ("%s{}", item_func);
                        else
                          execute_string ("%s", item_func);
                      else
                        execute_string ("%s", item_func);
                    }
                  insert (' ');
                  output_column++;
                }
              else
                enumerate_item ();

              /* Special hack.  This makes `close_paragraph' a no-op until
                 `start_paragraph' has been called. */
              must_start_paragraph = 1;

              /* Handle text directly after the @@item.  */
              if (*rest_of_line)
                {
                  line_number--;
                  input_text_offset = original_input_text_offset;
                }
            }
          break;

        case table:
        case ftable:
        case vtable:
          {
            /* We need this to determine if we have two @@item's in a row
               (see test just below).  */
            static int last_item_output_position = 0;
            
            /* Get rid of extra characters. */
            kill_self_indent (-1);

            /* If we have one @@item followed directly by another @@item,
               we need to insert a blank line.  This is not true for
               @@itemx, though.  */
            if (!itemx_flag && last_item_output_position == output_position)
              insert ('\n');
              
            /* `close_paragraph' almost does what we want.  The problem
               is when paragraph_is_open, and last_char_was_newline, and
               the last newline has been turned into a space, because
               filling_enabled. I handle it here. */
            if (last_char_was_newline && filling_enabled && paragraph_is_open)
              insert ('\n');
            close_paragraph ();

#if defined (INDENT_PARAGRAPHS_IN_TABLE)
            /* Indent on a new line, but back up one indentation level. */
            {
              int save = inhibit_paragraph_indentation;
              inhibit_paragraph_indentation = 1;
              /* At this point, inserting any non-whitespace character will
                 force the existing indentation to be output. */
              add_char ('i');
              inhibit_paragraph_indentation = save;
            }
#else /* !INDENT_PARAGRAPHS_IN_TABLE */
            add_char ('i');
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */

            output_paragraph_offset--;
            kill_self_indent (default_indentation_increment + 1);

            /* Add item's argument to the line. */
            filling_enabled = 0;
            if (item_func && *item_func)
              execute_string ("%s{%s}", item_func, rest_of_line);
            else
              execute_string ("%s", rest_of_line);

            if (current_insertion_type () == ftable)
              execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);
            else if (current_insertion_type () == vtable)
              execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

            /* Start a new line, and let start_paragraph ()
               do the indenting of it for you. */
            close_single_paragraph ();
            indented_fill = filling_enabled = 1;
            last_item_output_position = output_position;
          }
        }
      free (rest_of_line);
    }
  else
    {
    no_insertion:
      line_error (_("%c%s found outside of an insertion block"),
                  COMMAND_PREFIX, command);
    }
}

/* **************************************************************** */
/*                                                                  */
/*                      Defun and Friends                           */
/*                                                                  */
/* **************************************************************** */

#define DEFUN_SELF_DELIMITING(c)                                        \
  (((c) == '(')                                                         \
   || ((c) == ')')                                                      \
   || ((c) == '[')                                                      \
   || ((c) == ']'))

struct token_accumulator
{
  unsigned int length;
  unsigned int index;
  char **tokens;
};

void
initialize_token_accumulator (accumulator)
     struct token_accumulator *accumulator;
{
  (accumulator->length) = 0;
  (accumulator->index) = 0;
  (accumulator->tokens) = NULL;
}

void
accumulate_token (accumulator, token)
     struct token_accumulator *accumulator;
     char *token;
{
  if ((accumulator->index) >= (accumulator->length))
    {
      (accumulator->length) += 10;
      (accumulator->tokens) = (char **) xrealloc
        (accumulator->tokens, (accumulator->length * sizeof (char *)));
    }
  accumulator->tokens[accumulator->index] = token;
  accumulator->index += 1;
}

char *
copy_substring (start, end)
     char *start;
     char *end;
{
  char *result, *scan, *scan_result;

  result = (char *) xmalloc ((end - start) + 1);
  scan_result = result;
  scan = start;

  while (scan < end)
    *scan_result++ = *scan++;

  *scan_result = 0;
  return (result);
}

/* Given `string' pointing at an open brace, skip forward and return a
   pointer to just past the matching close brace. */
int
scan_group_in_string (string_pointer)
     char **string_pointer;
{
  register int c;
  register char *scan_string;
  register unsigned int level = 1;

  scan_string = (*string_pointer) + 1;

  while (1)
    {
      if (level == 0)
        {
          (*string_pointer) = scan_string;
          return (1);
        }
      c = (*scan_string++);
      if (c == 0)
        {
          /* Tweak line_number to compensate for fact that
             we gobbled the whole line before coming here. */
          line_number -= 1;
          line_error (_("Missing `}' in %cdef arg"), COMMAND_PREFIX);
          line_number += 1;
          (*string_pointer) = (scan_string - 1);
          return (0);
        }
      if (c == '{')
        level += 1;
      if (c == '}')
        level -= 1;
    }
}

/* Return a list of tokens from the contents of `string'.
   Commands and brace-delimited groups count as single tokens.
   Contiguous whitespace characters are converted to a token
   consisting of a single space. */
char **
args_from_string (string)
     char *string;
{
  struct token_accumulator accumulator;
  register char *scan_string = string;
  char *token_start, *token_end;

  initialize_token_accumulator (&accumulator);

  while ((*scan_string) != 0)
    {
      /* Replace arbitrary whitespace by a single space. */
      if (whitespace (*scan_string))
        {
          scan_string += 1;
          while (whitespace (*scan_string))
            scan_string += 1;
          accumulate_token ((&accumulator), (xstrdup (" ")));
          continue;
        }

      /* Commands count as single tokens. */
      if ((*scan_string) == COMMAND_PREFIX)
        {
          token_start = scan_string;
          scan_string += 1;
          if (self_delimiting (*scan_string))
            scan_string += 1;
          else
            {
              register int c;
              while (1)
                {
                  c = *scan_string++;

                  if ((c == 0) || (c == '{') || (whitespace (c)))
                    {
                      scan_string -= 1;
                      break;
                    }
                }

              if (*scan_string == '{')
                {
                  char *s = scan_string;
                  (void) scan_group_in_string (&s);
                  scan_string = s;
                }
            }
          token_end = scan_string;
        }

      /* Parentheses and brackets are self-delimiting. */
      else if (DEFUN_SELF_DELIMITING (*scan_string))
        {
          token_start = scan_string;
          scan_string += 1;
          token_end = scan_string;
        }

      /* Open brace introduces a group that is a single token. */
      else if (*scan_string == '{')
        {
          char *s = scan_string;
          int balanced = scan_group_in_string (&s);

          token_start = scan_string + 1;
          scan_string = s;
          token_end = balanced ? (scan_string - 1) : scan_string;
        }

      /* Otherwise a token is delimited by whitespace, parentheses,
         brackets, or braces.  A token is also ended by a command. */
      else
        {
          token_start = scan_string;

          while (1)
            {
              register int c;

              c = *scan_string++;

              /* Do not back up if we're looking at a }; since the only
                 valid }'s are those matched with {'s, we want to give
                 an error.  If we back up, we go into an infinite loop.  */
              if (!c || whitespace (c) || DEFUN_SELF_DELIMITING (c)
                  || c == '{')
                {
                  scan_string--;
                  break;
                }

              /* If we encounter a command embedded within a token,
                 then end the token. */
              if (c == COMMAND_PREFIX)
                {
                  scan_string--;
                  break;
                }
            }
          token_end = scan_string;
        }

      accumulate_token
        (&accumulator, copy_substring (token_start, token_end));
    }
  accumulate_token (&accumulator, NULL);
  return (accumulator.tokens);
}

void
process_defun_args (defun_args, auto_var_p)
     char **defun_args;
     int auto_var_p;
{
  int pending_space = 0;

  while (1)
    {
      char *defun_arg = *defun_args++;

      if (defun_arg == NULL)
        break;

      if (defun_arg[0] == ' ')
        {
          pending_space = 1;
          continue;
        }

      if (pending_space)
        {
          add_char (' ');
          pending_space = 0;
        }

      if (DEFUN_SELF_DELIMITING (defun_arg[0]))
        add_char (defun_arg[0]);
      else if (defun_arg[0] == '&')
        add_word (defun_arg);
      else if (defun_arg[0] == COMMAND_PREFIX)
        execute_string ("%s", defun_arg);
      else if (auto_var_p)
        execute_string ("%cvar{%s}", COMMAND_PREFIX, defun_arg);
      else
        add_word (defun_arg);
    }
}

char *
next_nonwhite_defun_arg (arg_pointer)
     char ***arg_pointer;
{
  char **scan = (*arg_pointer);
  char *arg = (*scan++);

  if ((arg != 0) && (*arg == ' '))
    arg = *scan++;

  if (arg == 0)
    scan -= 1;

  *arg_pointer = scan;

  return ((arg == 0) ? "" : arg);
}

/* Make the defun type insertion.
   TYPE says which insertion this is.
   X_P, if nonzero, says not to start a new insertion. */
void
defun_internal (type, x_p)
     enum insertion_type type;
     int x_p;
{
  enum insertion_type base_type;
  char **defun_args, **scan_args;
  char *category, *defined_name, *type_name, *type_name2;

  {
    char *line;
    get_rest_of_line (&line);
    defun_args = (args_from_string (line));
    free (line);
  }

  scan_args = defun_args;

  switch (type)
    {
    case defun:
      category = _("Function");
      base_type = deffn;
      break;
    case defmac:
      category = _("Macro");
      base_type = deffn;
      break;
    case defspec:
      category = _("Special Form");
      base_type = deffn;
      break;
    case defvar:
      category = _("Variable");
      base_type = defvr;
      break;
    case defopt:
      category = _("User Option");
      base_type = defvr;
      break;
    case deftypefun:
      category = _("Function");
      base_type = deftypefn;
      break;
    case deftypevar:
      category = _("Variable");
      base_type = deftypevr;
      break;
    case defivar:
      category = _("Instance Variable");
      base_type = defcv;
      break;
    case defmethod:
      category = _("Method");
      base_type = defop;
      break;
    case deftypemethod:
      category = _("Method");
      base_type = deftypemethod;
      break;
    default:
      category = next_nonwhite_defun_arg (&scan_args);
      base_type = type;
      break;
    }

  if ((base_type == deftypefn)
      || (base_type == deftypevr)
      || (base_type == defcv)
      || (base_type == defop)
      || (base_type == deftypemethod))
    type_name = next_nonwhite_defun_arg (&scan_args);

  if (base_type == deftypemethod)
    type_name2 = next_nonwhite_defun_arg (&scan_args);

  defined_name = next_nonwhite_defun_arg (&scan_args);

  /* This hack exists solely for the purposes of formatting the texinfo
     manual.  I couldn't think of a better way.  The token might be
     a simple @@@@ followed immediately by more text.  If this is the case,
     then the next defun arg is part of this one, and we should concatenate
     them. */
  if (*scan_args && **scan_args && !whitespace (**scan_args) &&
      (strcmp (defined_name, "@@@@") == 0))
    {
      char *tem = (char *)xmalloc (3 + strlen (scan_args[0]));

      sprintf (tem, "@@@@%s", scan_args[0]);

      free (scan_args[0]);
      scan_args[0] = tem;
      scan_args++;
      defined_name = tem;
    }

  if (!x_p)
    begin_insertion (type);

  /* Write the definition header line.
     This should start at the normal indentation.  */
  current_indent -= default_indentation_increment;
  start_paragraph ();

  switch (base_type)
    {
    case deffn:
    case defvr:
    case deftp:
      execute_string (" -- %s: %s", category, defined_name);
      break;
    case deftypefn:
    case deftypevr:
      execute_string (" -- %s: %s %s", category, type_name, defined_name);
      break;
    case defcv:
      execute_string (" -- %s of %s: %s", category, type_name, defined_name);
      break;
    case defop:
      execute_string (" -- %s on %s: %s", category, type_name, defined_name);
      break;
    case deftypemethod:
      execute_string (" -- %s on %s: %s %s", category, type_name, type_name2,
                      defined_name);
      break;
    }
  current_indent += default_indentation_increment;

  /* Now process the function arguments, if any.
     If these carry onto the next line, they should be indented by two
     increments to distinguish them from the body of the definition,
     which is indented by one increment.  */
  current_indent += default_indentation_increment;

  switch (base_type)
    {
    case deffn:
    case defop:
      process_defun_args (scan_args, 1);
      break;

      /* Through Makeinfo 1.67 we processed remaining args only for deftp,
         deftypefn, and deftypemethod.  But the libc manual, for example,
         needs to say:
            @@deftypevar {char *} tzname[2]
         And simply allowing the extra text seems far simpler than trying
         to invent yet more defn commands.  In any case, we should either
         output it or give an error, not silently ignore it.  */
    default:
      process_defun_args (scan_args, 0);
      break;
    }
  current_indent -= default_indentation_increment;
  close_single_paragraph ();

  /* Make an entry in the appropriate index. */
  switch (base_type)
    {
    case deffn:
    case deftypefn:
      execute_string ("%cfindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defvr:
    case deftypevr:
    case defcv:
      execute_string ("%cvindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defop:
    case deftypemethod:
      execute_string ("%cfindex %s on %s\n",
		      COMMAND_PREFIX, defined_name, type_name);
      break;
    case deftp:
      execute_string ("%ctindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    }

  /* Deallocate the token list. */
  scan_args = defun_args;
  while (1)
    {
      char * arg = (*scan_args++);
      if (arg == NULL)
        break;
      free (arg);
    }
  free (defun_args);
}

/* Add an entry for a function, macro, special form, variable, or option.
   If the name of the calling command ends in `x', then this is an extra
   entry included in the body of an insertion of the same type. */
void
cm_defun ()
{
  int x_p;
  enum insertion_type type;
  char *temp = xstrdup (command);

  x_p = (command[strlen (command) - 1] == 'x');

  if (x_p)
    temp[strlen (temp) - 1] = 0;

  type = find_type_from_name (temp);
  free (temp);

  /* If we are adding to an already existing insertion, then make sure
     that we are already in an insertion of type TYPE. */
  if (x_p &&
      (!insertion_level || insertion_stack->insertion != type))
    {
      line_error (_("Must be in a `%s' insertion in order to use `%s'x"),
                  command, command);
      discard_until ("\n");
      return;
    }

  defun_internal (type, x_p);
}

/* **************************************************************** */
/*                                                                  */
/*                      Other Random Commands                       */
/*                                                                  */
/* **************************************************************** */

/* This says to inhibit the indentation of the next paragraph, but
   not of following paragraphs.  */
void
cm_noindent ()
{
  if (!inhibit_paragraph_indentation)
    inhibit_paragraph_indentation = -1;
}

/* I don't know exactly what to do with this.  Should I allow
   someone to switch filenames in the middle of output?  Since the
   file could be partially written, this doesn't seem to make sense.
   Another option: ignore it, since they don't *really* want to
   switch files.  Finally, complain, or at least warn. */
void
cm_setfilename ()
{
  char *filename;
  get_rest_of_line (&filename);
  /* warning ("`@@%s %s' encountered and ignored", command, filename); */
  free (filename);
}

void
cm_ignore_line ()
{
  discard_until ("\n");
}

/* @@br can be immediately followed by `{}', so we have to read those here.
   It should simply close the paragraph. */
void
cm_br ()
{
  if (looking_at ("{}"))
    input_text_offset += 2;

  if (curchar () == '\n')
    {
      input_text_offset++;
      line_number++;
    }

  close_paragraph ();
}

 /* Insert the number of blank lines passed as argument. */
void
cm_sp ()
{
  int lines;
  char *line;

  get_rest_of_line (&line);

  if (sscanf (line, "%d", &lines) != 1)
    {
      line_error (_("%csp requires a positive numeric argument"), COMMAND_PREFIX);
    }
  else
    {
      if (lines < 0)
        lines = 0;

      while (lines--)
        add_char ('\n');
    }
  free (line);
}

/* @@dircategory LINE  outputs  INFO-DIR-SECTION LINE,
   but not if --no-headers.  */

void
cm_dircategory ()
{
  char *line;

  get_rest_of_line (&line);;

  if (!no_headers)
    {
      insert_string ("INFO-DIR-SECTION ");
      insert_string (line);
      insert ('\n');
    }

  free (line);
}

/* Start a new line with just this text on it.
   Then center the line of text.
   This always ends the current paragraph. */
void
cm_center ()
{
  register int i, start, length;
  int fudge_factor = 1;
  unsigned char *line;

  close_paragraph ();
  filling_enabled = indented_fill = 0;
  cm_noindent ();
  start = output_paragraph_offset;
  inhibit_output_flushing ();
  get_rest_of_line ((char **)&line);
  execute_string ("%s", (char *)line);
  free (line);
  uninhibit_output_flushing ();

  i = output_paragraph_offset - 1;
  while (i > (start - 1) && output_paragraph[i] == '\n')
        i--;

  output_paragraph_offset = ++i;
  length = output_paragraph_offset - start;

  if (length < (fill_column - fudge_factor))
    {
      line = (unsigned char *)xmalloc (1 + length);
      memcpy (line, (char *)(output_paragraph + start), length);

      i = (fill_column - fudge_factor - length) / 2;
      output_paragraph_offset = start;

      while (i--)
        insert (' ');

      for (i = 0; i < length; i++)
        insert (line[i]);

      free (line);
    }

  insert ('\n');
  close_paragraph ();
  filling_enabled = 1;
}

/* Show what an expression returns. */
void
cm_result (arg)
     int arg;
{
  if (arg == END)
    add_word ("=>");
}

/* What an expression expands to. */
void
cm_expansion (arg)
     int arg;
{
  if (arg == END)
    add_word ("==>");
}

/* Indicates two expressions are equivalent. */
void
cm_equiv (arg)
     int arg;
{
  if (arg == END)
    add_word ("==");
}

/* What an expression may print. */
void
cm_print (arg)
     int arg;
{
  if (arg == END)
    add_word ("-|");
}

/* An error signaled. */
void
cm_error (arg)
     int arg;
{
  if (arg == END)
    add_word ("error-->");
}

/* The location of point in an example of a buffer. */
void
cm_point (arg)
     int arg;
{
  if (arg == END)
    add_word ("-!-");
}

/* Start a new line with just this text on it.
   The text is outdented one level if possible. */
void
cm_exdent ()
{
  char *line;
  int i = current_indent;

  if (current_indent)
    current_indent -= default_indentation_increment;

  get_rest_of_line (&line);
  close_single_paragraph ();
  execute_string ("%s", line);
  current_indent = i;
  free (line);
  close_single_paragraph ();
}


/* Remember this file, and move onto the next. */
void
cm_include ()
{
  char *filename;

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    me_append_before_this_command ();
#endif /* HAVE_MACROS */

  close_paragraph ();
  get_rest_of_line (&filename);

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);
#endif /* HAVE_MACROS */

  pushfile ();

  /* In verbose mode we print info about including another file. */
  if (verbose_mode)
    {
      register int i = 0;
      register FSTACK *stack = filestack;

      for (i = 0, stack = filestack; stack; stack = stack->next, i++);

      i *= 2;

      printf ("%*s", i, "");
      printf ("%c%s %s\n", COMMAND_PREFIX, command, filename);
      fflush (stdout);
    }

  if (!find_and_load (filename))
    {
      extern int errno;

      popfile ();
      line_number--;

      /* Cannot "@@include foo", in line 5 of "/wh/bar". */
      line_error ("%c%s %s: %s", COMMAND_PREFIX, command, filename,
                  strerror (errno));

      free (filename);
      return;
    }
  else
    {
#if defined (HAVE_MACROS)
      if (macro_expansion_output_stream && !executing_string)
        remember_itext (input_text, input_text_offset);
#endif /* HAVE_MACROS */
      reader_loop ();
    }
  free (filename);
  popfile ();
}

/* The other side of a malformed expression. */
void
misplaced_brace ()
{
  line_error (_("Misplaced %c"), '}');
}

/* Signals end of processing.  Easy to make this happen. */
void
cm_bye ()
{
  input_text_offset = size_of_input_text;
}

/* Set the paragraph indentation variable to the value specified in STRING.
   Values can be:
     `asis': Don't change existing indentation.
     `none': Remove existing indentation.
        NUM: Indent NUM spaces at the starts of paragraphs.
             If NUM is zero, we assume `none'.
   Returns 0 if successful, or nonzero if STRING isn't one of the above. */
int
set_paragraph_indent (string)
     char *string;
{
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    paragraph_start_indent = 0;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    paragraph_start_indent = -1;
  else
    {
      if (sscanf (string, "%d", &paragraph_start_indent) != 1)
        return (-1);
      else
        {
          if (paragraph_start_indent == 0)
            paragraph_start_indent = -1;
        }
    }
  return (0);
}

void
cm_paragraphindent ()
{
  char *arg;

  get_rest_of_line (&arg);
  if (set_paragraph_indent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}

/* **************************************************************** */
/*                                                                  */
/*                      Indexing Stuff                              */
/*                                                                  */
/* **************************************************************** */


/* An index element... */
typedef struct index_elt
{
  struct index_elt *next;
  char *entry;                  /* The index entry itself. */
  char *node;                   /* The node from whence it came. */
  int code;                     /* Nonzero means add `@@code{...}' when
                                   printing this element. */
  int defining_line;            /* Line number where this entry was written. */
  char *defining_file;          /* Source file for defining_line. */
} INDEX_ELT;

/* A list of short-names for each index.

   There are two indices into the the_indices array.

   * read_index is the index that points to the list of index
     entries that we will find if we ask for the list of entries for
     this name.

   * write_index is the index that points to the list of index entries
     that we will add new entries to.

   Initially, read_index and write index are the same, but the
   @@syncodeindex and @@synindex commands can change the list we add
   entries to.

   For example, after the commands

     @@cindex foo
     @@defindex ii
     @@synindex cp ii
     @@cindex bar

   the cp index will contain the entry `foo', and the new ii
   index will contain the entry `bar'.  This is consistent with the
   way texinfo.tex handles the same situation.

   In addition, for each index, it is remembered whether that index is
   a code index or not.  Code indices have @@code{} inserted around the
   first word when they are printed with printindex. */
typedef struct
{
  char *name;
  int read_index;   /* index entries for `name' */
  int write_index;  /* store index entries here, @@synindex can change it */
  int code;
} INDEX_ALIST;

INDEX_ALIST **name_index_alist = (INDEX_ALIST **) NULL;

/* An array of pointers.  Each one is for a different index.  The
   "synindex" command changes which array slot is pointed to by a
   given "index". */
INDEX_ELT **the_indices = (INDEX_ELT **) NULL;

/* The number of defined indices. */
int defined_indices = 0;

void
init_indices ()
{
  int i;

  /* Create the default data structures. */

  /* Initialize data space. */
  if (!the_indices)
    {
      the_indices = (INDEX_ELT **) xmalloc ((1 + defined_indices) *
                                            sizeof (INDEX_ELT *));
      the_indices[defined_indices] = (INDEX_ELT *) NULL;

      name_index_alist = (INDEX_ALIST **) xmalloc ((1 + defined_indices) *
                                                   sizeof (INDEX_ALIST *));
      name_index_alist[defined_indices] = (INDEX_ALIST *) NULL;
    }

  /* If there were existing indices, get rid of them now. */
  for (i = 0; i < defined_indices; i++)
    {
      undefindex (name_index_alist[i]->name);
      if (name_index_alist[i])
        { /* Suppose we're called with two input files, and the first
             does a @@synindex pg cp.  Then, when we get here to start
             the second file, the "pg" element won't get freed by
             undefindex (because it's pointing to "cp").  So free it
             here; otherwise, when we try to define the pg index again
             just below, it will still point to cp.  */
          free (name_index_alist[i]->name);
          free (name_index_alist[i]);
          name_index_alist[i] = (INDEX_ALIST *) NULL;
        }
    }

  /* Add the default indices. */
  top_defindex ("cp", 0);           /* cp is the only non-code index.  */
  top_defindex ("fn", 1);
  top_defindex ("ky", 1);
  top_defindex ("pg", 1);
  top_defindex ("tp", 1);
  top_defindex ("vr", 1);
}

/* Find which element in the known list of indices has this name.
   Returns -1 if NAME isn't found. */
int
find_index_offset (name)
     char *name;
{
  register int i;
  for (i = 0; i < defined_indices; i++)
    if (name_index_alist[i] &&
        strcmp (name, name_index_alist[i]->name) == 0)
      return (i);
  return (-1);
}

/* Return a pointer to the entry of (name . index) for this name.
   Return NULL if the index doesn't exist. */
INDEX_ALIST *
find_index (name)
     char *name;
{
  int offset = find_index_offset (name);
  if (offset > -1)
    return (name_index_alist[offset]);
  else
    return ((INDEX_ALIST *) NULL);
}

/* Given an index name, return the offset in the_indices of this index,
   or -1 if there is no such index. */
int
translate_index (name)
     char *name;
{
  INDEX_ALIST *which = find_index (name);

  if (which)
    return (which->read_index);
  else
    return (-1);
}

/* Return the index list which belongs to NAME. */
INDEX_ELT *
index_list (name)
     char *name;
{
  int which = translate_index (name);
  if (which < 0)
    return ((INDEX_ELT *) -1);
  else
    return (the_indices[which]);
}

/* Please release me, let me go... */
void
free_index (index)
     INDEX_ELT *index;
{
  INDEX_ELT *temp;

  while ((temp = index) != (INDEX_ELT *) NULL)
    {
      free (temp->entry);
      /* Do not free the node, because we already freed the tag table,
         which freed all the node names.  */
      /* free (temp->node); */
      index = index->next;
      free (temp);
    }
}

/* Flush an index by name.  This will delete the list of entries that
   would be written by a @@printindex command for this index. */
void
undefindex (name)
     char *name;
{
  int i;
  int which = find_index_offset (name);

  /* The index might have already been freed if this was the target of
     an @@synindex.  */
  if (which < 0 || !name_index_alist[which])
    return;

  i = name_index_alist[which]->read_index;

  free_index (the_indices[i]);
  the_indices[i] = (INDEX_ELT *) NULL;

  free (name_index_alist[which]->name);
  free (name_index_alist[which]);
  name_index_alist[which] = (INDEX_ALIST *) NULL;
}

/* Define an index known as NAME.  We assign the slot number.
   CODE if Nonzero says to make this a code index. */
void
defindex (name, code)
     char *name;
     int code;
{
  register int i, slot;

  /* If it already exists, flush it. */
  undefindex (name);

  /* Try to find an empty slot. */
  slot = -1;
  for (i = 0; i < defined_indices; i++)
    if (!name_index_alist[i])
      {
        slot = i;
        break;
      }

  if (slot < 0)
    {
      /* No such luck.  Make space for another index. */
      slot = defined_indices;
      defined_indices++;

      name_index_alist = (INDEX_ALIST **)
        xrealloc ((char *)name_index_alist,
                  (1 + defined_indices) * sizeof (INDEX_ALIST *));
      the_indices = (INDEX_ELT **)
        xrealloc ((char *)the_indices,
                  (1 + defined_indices) * sizeof (INDEX_ELT *));
    }

  /* We have a slot.  Start assigning. */
  name_index_alist[slot] = (INDEX_ALIST *) xmalloc (sizeof (INDEX_ALIST));
  name_index_alist[slot]->name = xstrdup (name);
  name_index_alist[slot]->read_index = slot;
  name_index_alist[slot]->write_index = slot;
  name_index_alist[slot]->code = code;

  the_indices[slot] = (INDEX_ELT *) NULL;
}

/* Add the arguments to the current index command to the index NAME. */
void
index_add_arg (name)
     char *name;
{
  int which;
  char *index_entry;
  INDEX_ALIST *tem;

  tem = find_index (name);

  which = tem ? tem->write_index : -1;

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);
#endif /* HAVE_MACROS */

  get_rest_of_line (&index_entry);
  ignore_blank_line ();

#if defined (HAVE_MACROS)
  if (macro_expansion_output_stream && !executing_string)
    {
      int op_orig;

      remember_itext (input_text, input_text_offset);
      op_orig = output_paragraph_offset;
      me_execute_string (index_entry);
      me_execute_string ("\n");
      output_paragraph_offset = op_orig;
    }
#endif /* HAVE_MACROS */

  if (which < 0)
    {
      line_error (_("Unknown index `%s'"), name);
      free (index_entry);
    }
  else
    {
      INDEX_ELT *new = (INDEX_ELT *) xmalloc (sizeof (INDEX_ELT));
      new->next = the_indices[which];
      new->entry = index_entry;
      new->node = current_node;
      new->code = tem->code;
      new->defining_line = line_number - 1;
      new->defining_file = input_filename;
      the_indices[which] = new;
    }
}

#define INDEX_COMMAND_SUFFIX "index"

/* The function which user defined index commands call. */
void
gen_index ()
{
  char *name = xstrdup (command);
  if (strlen (name) >= strlen ("index"))
    name[strlen (name) - strlen ("index")] = 0;
  index_add_arg (name);
  free (name);
}

void
top_defindex (name, code)
     char *name;
     int code;
{
  char *temp;

  temp = (char *) xmalloc (1 + strlen (name) + strlen ("index"));
  sprintf (temp, "%sindex", name);
  define_user_command (temp, gen_index, 0);
  defindex (name, code);
  free (temp);
}

/* Define a new index command.  Arg is name of index. */
void
cm_defindex ()
{
  gen_defindex (0);
}

void
cm_defcodeindex ()
{
  gen_defindex (1);
}

void
gen_defindex (code)
     int code;
{
  char *name;
  get_rest_of_line (&name);

  if (find_index (name))
    {
      line_error (_("Index `%s' already exists"), name);
      free (name);
      return;
    }
  else
    {
      char *temp = (char *) alloca (1 + strlen (name) + strlen ("index"));
      sprintf (temp, "%sindex", name);
      define_user_command (temp, gen_index, 0);
      defindex (name, code);
      free (name);
    }
}

/* Expects 2 args, on the same line.  Both are index abbreviations.
   Make the first one be a synonym for the second one, i.e. make the
   first one have the same index as the second one. */
void
cm_synindex ()
{
  int source, target;
  char *abbrev1, *abbrev2;

  skip_whitespace ();
  get_until_in_line (0, " ", &abbrev1);
  target = find_index_offset (abbrev1);
  skip_whitespace ();
  get_until_in_line (0, " ", &abbrev2);
  source = find_index_offset (abbrev2);
  if (source < 0 || target < 0)
    {
      line_error (_("Unknown index `%s' and/or `%s' in @@synindex"),
                  abbrev1, abbrev2);
    }
  else
    {
      name_index_alist[target]->write_index
        = name_index_alist[source]->write_index;
    }
  
  free (abbrev1);
  free (abbrev2);
}

void
cm_pindex ()                    /* Pinhead index. */
{
  index_add_arg ("pg");
}

void
cm_vindex ()                    /* Variable index. */
{
  index_add_arg ("vr");
}

void
cm_kindex ()                    /* Key index. */
{
  index_add_arg ("ky");
}

void
cm_cindex ()                    /* Concept index. */
{
  index_add_arg ("cp");
}

void
cm_findex ()                    /* Function index. */
{
  index_add_arg ("fn");
}

void
cm_tindex ()                    /* Data Type index. */
{
  index_add_arg ("tp");
}

/* Sorting the index. */
int
index_element_compare (element1, element2)
     INDEX_ELT **element1, **element2;
{
  return (strcasecmp ((*element1)->entry, (*element2)->entry));
}

/* Force all index entries to be unique. */
void
make_index_entries_unique (array, count)
     INDEX_ELT **array;
     int count;
{
  register int i, j;
  INDEX_ELT **copy;
  int counter = 1;

  copy = (INDEX_ELT **)xmalloc ((1 + count) * sizeof (INDEX_ELT *));

  for (i = 0, j = 0; i < count; i++)
    {
      if ((i == (count - 1)) ||
          (array[i]->node != array[i + 1]->node) ||
          (strcmp (array[i]->entry, array[i + 1]->entry) != 0))
        copy[j++] = array[i];
      else
        {
          free (array[i]->entry);
          free (array[i]);
        }
    }
  copy[j] = (INDEX_ELT *)NULL;

  /* Now COPY contains only unique entries.  Duplicated entries in the
     original array have been freed.  Replace the current array with
     the copy, fixing the NEXT pointers. */
  for (i = 0; copy[i] != (INDEX_ELT *)NULL; i++)
    {

      copy[i]->next = copy[i + 1];

      /* Fix entry names which are the same.  They point to different nodes,
         so we make the entry name unique. */
      if ((copy[i + 1] != (INDEX_ELT *)NULL) &&
          (strcmp (copy[i]->entry, copy[i + 1]->entry) == 0))
        {
          char *new_entry_name;

          new_entry_name = (char *)xmalloc (10 + strlen (copy[i]->entry));
          sprintf (new_entry_name, "%s <%d>", copy[i]->entry, counter);
          free (copy[i]->entry);
          copy[i]->entry = new_entry_name;
          counter++;
        }
      else
        counter = 1;

      array[i] = copy[i];
    }
  array[i] = (INDEX_ELT *)NULL;

  /* Free the storage used only by COPY. */
  free (copy);
}

/* Sort the index passed in INDEX, returning an array of
   pointers to elements.  The array is terminated with a NULL
   pointer.  We call qsort because it's supposed to be fast.
   I think this looks bad. */
INDEX_ELT **
sort_index (index)
     INDEX_ELT *index;
{
  INDEX_ELT **array;
  INDEX_ELT *temp = index;
  int count = 0;
  int save_line_number = line_number;
  char *save_input_filename = input_filename;

  while (temp != (INDEX_ELT *) NULL)
    {
      count++;
      temp = temp->next;
    }

  /* We have the length.  Make an array. */

  array = (INDEX_ELT **) xmalloc ((count + 1) * sizeof (INDEX_ELT *));
  count = 0;
  temp = index;

  while (temp != (INDEX_ELT *) NULL)
    {
      array[count++] = temp;

      /* Set line number and input filename to the source line for this
         index entry, as this expansion finds any errors.  */
      line_number = array[count - 1]->defining_line;
      input_filename = array[count - 1]->defining_file;

      /* If this particular entry should be printed as a "code" index,
         then wrap the entry with "@@code{...}". */
      array[count - 1]->entry = expansion (temp->entry, index->code);
      
      temp = temp->next;
    }
  array[count] = (INDEX_ELT *) NULL;    /* terminate the array. */
  line_number = save_line_number;
  input_filename = save_input_filename;

  /* Sort the array. */
  qsort (array, count, sizeof (INDEX_ELT *), index_element_compare);
  make_index_entries_unique (array, count);
  return (array);
}

/* Nonzero means that we are in the middle of printing an index. */
int printing_index = 0;

/* Takes one arg, a short name of an index to print.
   Outputs a menu of the sorted elements of the index. */
void
cm_printindex ()
{
  int item;
  INDEX_ELT *index;
  INDEX_ELT **array;
  char *index_name;
  unsigned line_length;
  char *line;
  int saved_inhibit_paragraph_indentation = inhibit_paragraph_indentation;
  int saved_filling_enabled = filling_enabled;

  close_paragraph ();
  get_rest_of_line (&index_name);

  index = index_list (index_name);
  if (index == (INDEX_ELT *)-1)
    {
      line_error (_("Unknown index `%s' in @@printindex"), index_name);
      free (index_name);
      return;
    }
  else
    free (index_name);

  /* Do this before sorting, so execute_string in index_element_compare
     will give the same results as when we actually print.  */
  printing_index = 1;
  filling_enabled = 0;
  inhibit_paragraph_indentation = 1;
  array = sort_index (index);

  close_paragraph ();
  add_word (_("* Menu:\n\n"));

#if defined (HAVE_MACROS)
  me_inhibit_expansion++;
#endif /* HAVE_MACROS */

  /* This will probably be enough.  */
  line_length = 100;
  line = xmalloc (line_length);
  
  for (item = 0; (index = array[item]); item++)
    {
      /* A pathological document might have an index entry outside of any
         node.  Don't crash.  Perhaps should warn.  */
      char *index_node = index->node ? index->node : "(none)";
      unsigned new_length = strlen (index->entry);

      if (new_length < 37) /* minimum length used below */
        new_length = 37;
      new_length += strlen (index_node) + 7; /* * : .\n\0 */
      
      if (new_length > line_length)
        {
          line_length = new_length;
          line = xrealloc (line, line_length);
        }

      /* Print the entry, nicely formatted.  We've already expanded any
         commands, including any implicit @@code.  Thus, can't call
         execute_string, since @@@@ has turned into @@.  */
      sprintf (line, "* %-37s  %s.\n", index->entry, index_node);
      line[2 + strlen (index->entry)] = ':';
      insert_string (line);

      /* Previous `output_paragraph' from growing to the size of the
         whole index.  */
      flush_output ();
    }

  free (line);
  
#if defined (HAVE_MACROS)
  me_inhibit_expansion--;
#endif /* HAVE_MACROS */

  printing_index = 0;
  free (array);
  close_single_paragraph ();
  filling_enabled = saved_filling_enabled;
  inhibit_paragraph_indentation = saved_inhibit_paragraph_indentation;
}

/* User-defined commands, which happens only from user-defined indexes. */

void
define_user_command (name, proc, needs_braces_p)
     char *name;
     COMMAND_FUNCTION *proc;
     int needs_braces_p;
{
  int slot = user_command_array_len;
  user_command_array_len++;

  if (!user_command_array)
    user_command_array = (COMMAND **) xmalloc (1 * sizeof (COMMAND *));

  user_command_array = (COMMAND **) xrealloc (user_command_array,
                                              (1 + user_command_array_len) *
                                              sizeof (COMMAND *));

  user_command_array[slot] = (COMMAND *) xmalloc (sizeof (COMMAND));
  user_command_array[slot]->name = xstrdup (name);
  user_command_array[slot]->proc = proc;
  user_command_array[slot]->argument_in_braces = needs_braces_p;
}

/* Some support for footnotes. */

/* Footnotes are a new construct in Info.  We don't know the best method
   of implementing them for sure, so we present two possiblities.

   SeparateNode:
        Make them look like followed references, with the reference
        destinations in a makeinfo manufactured node or,

   EndNode:
        Make them appear at the bottom of the node that they originally
        appeared in. */
#define SeparateNode 0
#define EndNode 1

int footnote_style = EndNode;
int first_footnote_this_node = 1;
int footnote_count = 0;

/* Set the footnote style based on he style identifier in STRING. */
int
set_footnote_style (string)
     char *string;
{
  if ((strcasecmp (string, "separate") == 0) ||
      (strcasecmp (string, "MN") == 0))
    footnote_style = SeparateNode;
  else if ((strcasecmp (string, "end") == 0) ||
           (strcasecmp (string, "EN") == 0))
    footnote_style = EndNode;
  else
    return (-1);

 return (0);
}

void
cm_footnotestyle ()
{
  char *arg;

  get_rest_of_line (&arg);

  /* If set on command line, do not change the footnote style.  */
  if (!footnote_style_preset && set_footnote_style (arg) != 0)
    line_error ("Bad argument to %c%s", COMMAND_PREFIX, command);

  free (arg);
}

typedef struct fn
{
  struct fn *next;
  char *marker;
  char *note;
}  FN;

FN *pending_notes = (FN *) NULL;

/* A method for remembering footnotes.  Note that this list gets output
   at the end of the current node. */
void
remember_note (marker, note)
     char *marker, *note;
{
  FN *temp = (FN *) xmalloc (sizeof (FN));

  temp->marker = xstrdup (marker);
  temp->note = xstrdup (note);
  temp->next = pending_notes;
  pending_notes = temp;
  footnote_count++;
}

/* How to get rid of existing footnotes. */
void
free_pending_notes ()
{
  FN *temp;

  while ((temp = pending_notes) != (FN *) NULL)
    {
      free (temp->marker);
      free (temp->note);
      pending_notes = pending_notes->next;
      free (temp);
    }
  first_footnote_this_node = 1;
  footnote_count = 0;
}

/* What to do when you see a @@footnote construct. */

 /* Handle a "footnote".
    footnote *{this is a footnote}
    where "*" is the (optional) marker character for this note. */
void
cm_footnote ()
{
  char *marker;
  char *note;

  get_until ("{", &marker);
  canon_white (marker);

  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1); /* include the { */

  /* Read the argument in braces. */
  if (curchar () != '{')
    {
      line_error (_("`%c%s' needs an argument `{...}', not just `%s'"),
                  COMMAND_PREFIX, command, marker);
      free (marker);
      return;
    }
  else
    {
      int len;
      int braces = 1;
      int loc = ++input_text_offset;

      while (braces)
        {
          if (loc == size_of_input_text)
            {
              line_error (_("No closing brace for footnote `%s'"), marker);
              return;
            }

          if (input_text[loc] == '{')
            braces++;
          else if (input_text[loc] == '}')
            braces--;
          else if (input_text[loc] == '\n')
            line_number++;

          loc++;
        }

      len = (loc - input_text_offset) - 1;
      note = (char *)xmalloc (len + 1);
      strncpy (note, &input_text[input_text_offset], len);
      note[len] = 0;
      input_text_offset = loc;
    }

  /* Must write the macro-expanded argument to the macro expansion
     output stream.  This is like the case in index_add_arg.  */
  if (macro_expansion_output_stream && !executing_string)
    {
      int op_orig;

      remember_itext (input_text, input_text_offset);
      op_orig = output_paragraph_offset;
      me_execute_string (note);
      /* Calling me_execute_string on a lone } provokes an error, since
         as far as the reader knows there is no matching {.  We wrote
         the { above in the call to append_to_expansion_output. */
      write_region_to_macro_output ("}", 0, 1);
      output_paragraph_offset = op_orig;
    }

  if (!current_node || !*current_node)
    {
      line_error (_("Footnote defined without parent node"));
      free (marker);
      free (note);
      return;
    }

  if (!*marker)
    {
      free (marker);

      if (number_footnotes)
        {
          marker = (char *)xmalloc (10);
          sprintf (marker, "%d", current_footnote_number);
          current_footnote_number++;
        }
      else
        marker = xstrdup ("*");
    }

  remember_note (marker, note);

  /* Your method should at least insert MARKER. */
  switch (footnote_style)
    {
    case SeparateNode:
      add_word_args ("(%s)", marker);
      if (first_footnote_this_node)
        {
          char *temp_string;

          temp_string = (char *)
            xmalloc ((strlen (current_node)) + (strlen (_("-Footnotes"))) + 1);

          add_word_args (" (*note %s-Footnotes::)", current_node);
          strcpy (temp_string, current_node);
          strcat (temp_string, "-Footnotes");
          remember_node_reference (temp_string, line_number, followed_reference);
          free (temp_string);
          first_footnote_this_node = 0;
        }
      break;

    case EndNode:
      add_word_args ("(%s)", marker);
      break;

    default:
      break;
    }
  free (marker);
  free (note);
}

/* Nonzero means that we are currently in the process of outputting
   footnotes. */
int already_outputting_pending_notes = 0;

/* Output the footnotes.  We are at the end of the current node. */
void
output_pending_notes ()
{
  FN *footnote = pending_notes;

  if (!pending_notes)
    return;

  switch (footnote_style)
    {
    case SeparateNode:
      {
        char *old_current_node = current_node;
        char *old_command = xstrdup (command);

        already_outputting_pending_notes++;
        execute_string ("%cnode %s-Footnotes,,,%s\n",
                        COMMAND_PREFIX, current_node, current_node);
        already_outputting_pending_notes--;
        current_node = old_current_node;
        free (command);
        command = old_command;
      }
      break;

    case EndNode:
      close_paragraph ();
      in_fixed_width_font++;
      execute_string (_("---------- Footnotes ----------\n\n"));
      in_fixed_width_font--;
      break;
    }

  /* Handle the footnotes in reverse order. */
  {
    FN **array = (FN **) xmalloc ((footnote_count + 1) * sizeof (FN *));

    array[footnote_count] = (FN *) NULL;

    while (--footnote_count > -1)
      {
        array[footnote_count] = footnote;
        footnote = footnote->next;
      }

    filling_enabled = 1;
    indented_fill = 1;

    while ((footnote = array[++footnote_count]))
      {
        execute_string ("(%s) %s", footnote->marker, footnote->note);
        close_paragraph ();
      }
    close_paragraph ();
    free (array);
  }
}

/* **************************************************************** */
/*                                                                  */
/*              User definable Macros (text substitution)           */
/*                                                                  */
/* **************************************************************** */

#if defined (HAVE_MACROS)

/* Array of macros and definitions. */
MACRO_DEF **macro_list = (MACRO_DEF **)NULL;

int macro_list_len = 0;         /* Number of elements. */
int macro_list_size = 0;        /* Number of slots in total. */

/* Return the macro definition of NAME or NULL if NAME is not defined. */
MACRO_DEF *
find_macro (name)
     char *name;
{
  register int i;
  register MACRO_DEF *def;

  def = (MACRO_DEF *)NULL;
  for (i = 0; macro_list && (def = macro_list[i]); i++)
    {
      if ((!def->inhibited) && (strcmp (def->name, name) == 0))
        break;
    }
  return (def);
}

/* Add the macro NAME with ARGLIST and BODY to the list of defined macros.
   SOURCE_FILE is the name of the file where this definition can be found,
   and SOURCE_LINENO is the line number within that file.  If a macro already
   exists with NAME, then a warning is produced, and that previous
   definition is overwritten. */
void
add_macro (name, arglist, body, source_file, source_lineno, flags)
     char *name;
     char **arglist;
     char *body;
     char *source_file;
     int source_lineno, flags;
{
  register MACRO_DEF *def;

  def = find_macro (name);

  if (!def)
    {
      if (macro_list_len + 2 >= macro_list_size)
        macro_list = (MACRO_DEF **)xrealloc
          (macro_list, ((macro_list_size += 10) * sizeof (MACRO_DEF *)));

      macro_list[macro_list_len] = (MACRO_DEF *)xmalloc (sizeof (MACRO_DEF));
      macro_list[macro_list_len + 1] = (MACRO_DEF *)NULL;

      def = macro_list[macro_list_len];
      macro_list_len += 1;
      def->name = name;
    }
d3316 5
a3320 2
      char *temp_filename = input_filename;
      int temp_line = line_number;
d3322 3
a3324 1
      warning (_("macro `%s' previously defined"), name);
d3326 1
a3326 3
      input_filename = def->source_file;
      line_number = def->source_lineno;
      warning (_("here is the previous definition of `%s'"), name);
d3328 2
a3329 2
      input_filename = temp_filename;
      line_number = temp_line;
d3331 5
a3335 3
      if (def->arglist)
        {
          register int i;
d3337 11
a3347 2
          for (i = 0; def->arglist[i]; i++)
            free (def->arglist[i]);
d3349 3
a3351 5
          free (def->arglist);
        }
      free (def->source_file);
      free (def->body);
    }
d3353 3
a3355 7
  def->source_file = xstrdup (source_file);
  def->source_lineno = source_lineno;
  def->body = body;
  def->arglist = arglist;
  def->inhibited = 0;
  def->flags = flags;
}
d3357 10
a3366 9
/* Delete the macro with name NAME.  The macro is deleted from the list,
   but it is also returned.  If there was no macro defined, NULL is
   returned. */
MACRO_DEF *
delete_macro (name)
     char *name;
{
  register int i;
  register MACRO_DEF *def;
d3368 4
a3371 1
  def = (MACRO_DEF *)NULL;
d3373 1
a3373 10
  for (i = 0; macro_list && (def = macro_list[i]); i++)
    if (strcmp (def->name, name) == 0)
      {
        memmove (macro_list + i, macro_list + i + 1,
               ((macro_list_len + 1) - i) * sizeof (MACRO_DEF *));
        macro_list_len--;
        break;
      }
  return (def);
}
d3375 2
a3376 29
/* Return the arglist on the current line.  This can behave in two different
   ways, depending on the variable BRACES_REQUIRED_FOR_MACRO_ARGS. */
int braces_required_for_macro_args = 0;

char **
get_macro_args (def)
    MACRO_DEF *def;
{
  register int i;
  char *word;

  /* Quickly check to see if this macro has been invoked with any arguments.
     If not, then don't skip any of the following whitespace. */
  for (i = input_text_offset; i < size_of_input_text; i++)
    if (!cr_or_whitespace (input_text[i]))
      break;

  if (input_text[i] != '{')
    {
      if (braces_required_for_macro_args)
        {
          return ((char **)NULL);
        }
      else
        {
          /* Braces are not required to fill out the macro arguments.  If
             this macro takes one argument, it is considered to be the
             remainder of the line, sans whitespace. */
          if (def->arglist && def->arglist[0] && !def->arglist[1])
d3378 1
a3378 1
              char **arglist;
d3380 1
a3380 2
              get_rest_of_line (&word);
              if (input_text[input_text_offset - 1] == '\n')
d3382 1
a3382 20
                  input_text_offset--;
                  line_number--;
                }
              /* canon_white (word); */
              arglist = (char **)xmalloc (2 * sizeof (char *));
              arglist[0] = word;
              arglist[1] = (char *)NULL;
              return (arglist);
            }
          else
            {
              /* The macro either took no arguments, or took more than
                 one argument.  In that case, it must be invoked with
                 arguments surrounded by braces. */
              return ((char **)NULL);
            }
        }
    }
  return (get_brace_args (def->flags & ME_QUOTE_ARG));
}
d3384 1
a3384 11
/* Substitute actual parameters for named parameters in body.
   The named parameters which appear in BODY must by surrounded
   reverse slashes, as in \foo\. */
char *
apply (named, actuals, body)
     char **named, **actuals, *body;
{
  register int i;
  int new_body_index, new_body_size;
  char *new_body, *text;
  int length_of_actuals;
d3386 1
a3386 3
  length_of_actuals = array_len (actuals);
  new_body_size = strlen (body);
  new_body = (char *)xmalloc (1 + new_body_size);
d3388 7
a3394 2
  /* Copy chars from BODY into NEW_BODY. */
  i = 0; new_body_index = 0;
d3396 3
a3398 4
  while (1)
    {
      if (!body[i])
        break;
d3400 3
a3402 7
      if (body[i] != '\\')
        new_body[new_body_index++] = body[i++];
      else
        {
          /* Snarf parameter name, check against named parameters. */
          char *param;
          int param_start, which, len;
d3404 9
a3412 190
          param_start = ++i;
          while ((body[i]) && (body[i] != '\\'))
            i++;

          len = i - param_start;
          param = (char *)xmalloc (1 + len);
          memcpy (param, body + param_start, len);
          param[len] = 0;

          if (body[i]) /* move past \ */
            i++;

          /* Now check against named parameters. */
          for (which = 0; named && named[which]; which++)
            if (strcmp (named[which], param) == 0)
              break;

          if (named && named[which])
            {
              if (which < length_of_actuals)
                text = actuals[which];
              else
                text = (char *)NULL;

              if (!text)
                text = "";

              len = strlen (text);
            }
          else
            { /* not a parameter, restore \'s */
              i = body[i] ? (i - 1) : i;
              len++;
              text = xmalloc (1 + len);
              sprintf (text, "\\%s", param);
            }

          if ((2 + strlen (param)) < len)
            {
              new_body_size += len + 1;
              new_body = xrealloc (new_body, new_body_size);
            }

          free (param);

          strcpy (new_body + new_body_index, text);
          new_body_index += len;

          if (!named || !named[which])
            free (text);
        }
    }
  new_body[new_body_index] = 0;
  return (new_body);
}

/* Execute the macro passed in DEF, a pointer to a MACRO_DEF.  */
void
execute_macro (def)
     MACRO_DEF *def;
{
  char **arglist;
  int num_args;
  char *execution_string = (char *)NULL;

  if (macro_expansion_output_stream && !executing_string && !me_inhibit_expansion)
    me_append_before_this_command ();

  /* Find out how many arguments this macro definition takes. */
  num_args = array_len (def->arglist);

  /* Gather the arguments present on the line if there are any. */
  arglist = get_macro_args (def);

  if (num_args < array_len (arglist))
    {
      free_array (arglist);
      line_error (_("Macro `%s' called with too many args"), def->name);
      return;
    }

  if (def->body)
    execution_string = apply (def->arglist, arglist, def->body);

  free_array (arglist);

  if (def->body)
    {
      if (macro_expansion_output_stream && !executing_string && !me_inhibit_expansion)
        {
          remember_itext (input_text, input_text_offset);
          me_execute_string (execution_string);
        }
      else
        execute_string ("%s", execution_string);

      free (execution_string);
    }
}

/* Read and remember the definition of a macro. */
void
cm_macro ()
{
  register int i;
  char *name, **arglist, *body, *line;
  int body_size, body_index;
  int depth = 1;
  int defining_line = line_number;
  int flags = 0;

  arglist = (char **)NULL;
  body = (char *)NULL;
  body_size = 0;
  body_index = 0;

  if (macro_expansion_output_stream && !executing_string)
    me_append_before_this_command ();

  skip_whitespace ();

  /* Get the name of the macro.  This is the set of characters which are
     not whitespace and are not `{' immediately following the @@macro. */
  {
    int start = input_text_offset;
    int len;

    for (i = start;
         (i < size_of_input_text) &&
         (input_text[i] != '{') &&
         (!cr_or_whitespace (input_text[i]));
         i++);

    len = i - start;
    name = (char *)xmalloc (1 + len);
    strncpy (name, input_text + start, len);
    name[len] = 0;
    input_text_offset = i;
  }

  skip_whitespace ();

  /* It is not required that the definition of a macro includes an arglist.
     If not, don't try to get the named parameters, just use a null list. */
  if (curchar () == '{')
    {
      int arglist_index = 0, arglist_size = 0;
      int gathering_words = 1;
      char *word = (char *)NULL;
      int character;

      /* Read the words inside of the braces which determine the arglist.
         These words will be replaced within the body of the macro at
         execution time. */

      input_text_offset++;
      skip_whitespace_and_newlines ();

      while (gathering_words)
        {
          int len;

          for (i = input_text_offset;
               (character = input_text[i]);
               i++)
            {
              switch (character)
                {
                case '\n':
                  line_number++;
                case ' ':
                case '\t':
                case ',':
                case '}':
                  /* Found the end of the current arglist word.  Save it. */
                  len = i - input_text_offset;
                  word = (char *)xmalloc (1 + len);
                  strncpy (word, input_text + input_text_offset, len);
                  word[len] = 0;
                  input_text_offset = i;

                  /* Advance to the comma or close-brace that signified
                     the end of the argument. */
                  while ((character = curchar ())
                         && character != ','
                         && character != '}')
                    {
                      input_text_offset++;
                      if (character == '\n')
                        line_number++;
d3414 1
a3414 74

                  /* Add the word to our list of words. */
                  if ((arglist_index + 2) >= arglist_size)
                    arglist = (char **)xrealloc
                      (arglist, (arglist_size += 10) * sizeof (char *));

                  arglist[arglist_index++] = word;
                  arglist[arglist_index] = (char *)NULL;
                  break;
                }

              if (character == '}')
                {
                  input_text_offset++;
                  gathering_words = 0;
                  break;
                }

              if (character == ',')
                {
                  input_text_offset++;
                  skip_whitespace_and_newlines ();
                  i = input_text_offset - 1;
                }
            }
        }
    }

  /* Read the text carefully until we find an "@@end macro" which
     matches this one.  The text in between is the body of the macro. */
  skip_whitespace_and_newlines ();

  while (depth)
    {
      if ((input_text_offset + 9) > size_of_input_text)
        {
          int temp_line = line_number;
          line_number = defining_line;
          line_error (_("%cend macro not found"), COMMAND_PREFIX);
          line_number = temp_line;
          return;
        }

      get_rest_of_line (&line);

      /* Handle commands only meaningful within a macro. */
      if ((*line == COMMAND_PREFIX) && (depth == 1) &&
          (strncmp (line + 1, "allow-recursion", 15) == 0) &&
          (line[16] == 0 || whitespace (line[16])))
        {
          for (i = 16; whitespace (line[i]); i++);
          strcpy (line, line + i);
          flags |= ME_RECURSE;
          if (!*line)
            {
              free (line);
              continue;
            }
        }

      if ((*line == COMMAND_PREFIX) && (depth == 1) &&
          (strncmp (line + 1, "quote-arg", 9) == 0) &&
          (line[10] == 0 || whitespace (line[10])))
        {
          for (i = 10; whitespace (line[i]); i++);
          strcpy (line, line + i);

          if (arglist && arglist[0] && !arglist[1])
            {
              flags |= ME_QUOTE_ARG;
              if (!*line)
                {
                  free (line);
                  continue;
a3415 79
            }
          else
            {
              line_error (_("%cquote-arg only useful when the macro takes a single argument"),
                          COMMAND_PREFIX);
            }
        }

      if ((*line == COMMAND_PREFIX) &&
          (strncmp (line + 1, "macro ", 6) == 0))
        depth++;

      if ((*line == COMMAND_PREFIX) &&
          (strncmp (line + 1, "end macro", 9) == 0))
        depth--;

      if (depth)
        {
          if ((body_index + strlen (line) + 3) >= body_size)
            body = (char *)xrealloc
              (body, body_size += 3 + strlen (line));
          strcpy (body + body_index, line);
          body_index += strlen (line);
          body[body_index++] = '\n';
          body[body_index] = 0;
        }
      free (line);
    }

  /* If it was an empty macro like
     @@macro foo
     @@end macro
     create an empty body.  (Otherwise, the macro is not expanded.)  */
  if (!body)
    {
      body = (char *)malloc(1);
      *body = 0;
    }

  /* We now have the name, the arglist, and the body.  However, BODY
     includes the final newline which preceded the `@@end macro' text.
     Delete it. */
  if (body && strlen (body))
    body[strlen (body) - 1] = 0;

  add_macro (name, arglist, body, input_filename, defining_line, flags);

  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);
}

void
cm_unmacro ()
{
  register int i;
  char *line, *name;
  MACRO_DEF *def;

  if (macro_expansion_output_stream && !executing_string)
    me_append_before_this_command ();

  get_rest_of_line (&line);

  for (i = 0; line[i] && !whitespace (line[i]); i++);
  name = (char *)xmalloc (i + 1);
  strncpy (name, line, i);
  name[i] = 0;

  def = delete_macro (name);

  if (def)
    {
      free (def->source_file);
      free (def->name);
      free (def->body);

      if (def->arglist)
        {
          register int i;
d3417 8
a3424 2
          for (i = 0; def->arglist[i]; i++)
            free (def->arglist[i]);
d3426 14
a3439 1
          free (def->arglist);
a3440 2

      free (def);
d3442 3
d3446 5
a3450 2
  free (line);
  free (name);
d3452 3
a3454 3
  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, input_text_offset);
}
d3456 3
a3458 7
/* How to output sections of the input file verbatim. */

/* Set the value of POINTER's offset to OFFSET. */
ITEXT *
remember_itext (pointer, offset)
     char *pointer;
     int offset;
d3460 2
a3461 2
  register int i;
  ITEXT *itext = (ITEXT *)NULL;
d3463 1
a3463 2
  /* If we have no info, initialize a blank list. */
  if (!itext_info)
d3465 6
a3470 3
      itext_info = (ITEXT **)xmalloc ((itext_size = 10) * sizeof (ITEXT *));
      for (i = 0; i < itext_size; i++)
        itext_info[i] = (ITEXT *)NULL;
d3473 1
a3473 11
  /* If the pointer is already present in the list, then set the offset. */
  for (i = 0; i < itext_size; i++)
    if ((itext_info[i] != (ITEXT *)NULL) &&
        (itext_info[i]->pointer == pointer))
      {
        itext = itext_info[i];
        itext_info[i]->offset = offset;
        break;
      }

  if (i == itext_size)
d3475 1
a3475 8
      /* Find a blank slot (or create a new one), and remember the
         pointer and offset. */
      for (i = 0; i < itext_size; i++)
        if (itext_info[i] == (ITEXT *)NULL)
          break;

      /* If not found, then add some slots. */
      if (i == itext_size)
d3477 6
a3482 1
          register int j;
d3484 4
a3487 2
          itext_info = (ITEXT **)xrealloc
            (itext_info, (itext_size += 10) * sizeof (ITEXT *));
d3489 4
a3492 3
          for (j = i; j < itext_size; j++)
            itext_info[j] = (ITEXT *)NULL;
        }
d3494 4
a3497 5
      /* Now add the pointer and the offset. */
      itext_info[i] = (ITEXT *)xmalloc (sizeof (ITEXT));
      itext_info[i]->pointer = pointer;
      itext_info[i]->offset = offset;
      itext = itext_info[i];
d3499 1
a3499 1
  return (itext);
d3502 3
a3504 1
/* Forget the input text associated with POINTER. */
d3506 3
a3508 2
forget_itext (pointer)
     char *pointer;
d3510 1
a3510 1
  register int i;
d3512 23
a3534 7
  for (i = 0; i < itext_size; i++)
    if (itext_info[i] && (itext_info[i]->pointer == pointer))
      {
        free (itext_info[i]);
        itext_info[i] = (ITEXT *)NULL;
        break;
      }
d3537 2
a3538 2
/* Append the text which appeared in input_text from the last offset to
   the character just before the command that we are currently executing. */
d3540 7
a3546 1
me_append_before_this_command ()
d3548 9
a3556 1
  register int i;
d3558 7
a3564 3
  for (i = input_text_offset; i && (input_text[i] != COMMAND_PREFIX); i--);
  maybe_write_itext (input_text, i);
}
a3565 6
/* Similar to execute_string (), but only takes a single string argument,
   and remembers the input text location, etc. */
void
me_execute_string (execution_string)
     char *execution_string;
{
d3568 1
a3568 1
  input_text = execution_string;
d3570 1
a3570 1
  size_of_input_text = strlen (execution_string);
d3572 3
a3574 1
  remember_itext (execution_string, 0);
a3575 2
  me_executing_string++;
  reader_loop ();
d3577 2
a3578 1
  me_executing_string--;
a3580 15
/* Append the text which appears in input_text from the last offset to
   the current OFFSET. */
void
append_to_expansion_output (offset)
     int offset;
{
  register int i;
  ITEXT *itext = (ITEXT *)NULL;

  for (i = 0; i < itext_size; i++)
    if (itext_info[i] && itext_info[i]->pointer == input_text)
      {
        itext = itext_info[i];
        break;
      }
d3582 2
a3583 2
  if (!itext)
    return;
d3585 4
a3588 13
  if (offset > itext->offset)
    {
      write_region_to_macro_output
        (input_text, itext->offset, offset);
      remember_itext (input_text, offset);
    }
}

/* Only write this input text iff it appears in our itext list. */
void
maybe_write_itext (pointer, offset)
     char *pointer;
     int offset;
d3590 2
a3591 2
  register int i;
  ITEXT *itext = (ITEXT *)NULL;
d3593 4
a3596 6
  for (i = 0; i < itext_size; i++)
    if (itext_info[i] && (itext_info[i]->pointer == pointer))
      {
        itext = itext_info[i];
        break;
      }
d3598 16
a3613 6
  if (itext && (itext->offset < offset))
    {
      write_region_to_macro_output (itext->pointer, itext->offset, offset);
      remember_itext (pointer, offset);
    }
}
d3615 4
a3618 8
void
write_region_to_macro_output (string, start, end)
     char *string;
     int start, end;
{
  if (macro_expansion_output_stream)
    fwrite (string + start, 1, end - start, macro_expansion_output_stream);
}
d3620 4
a3623 1
#endif /* HAVE_MACROS */
d3625 5
a3629 6
/* Return the length of the array in ARRAY. */
int
array_len (array)
     char **array;
{
  register int i = 0;
d3631 13
a3643 2
  if (array)
    for (i = 0; array[i] != (char *)NULL; i++);
d3645 1
a3645 1
  return (i);
a3647 7
void
free_array (array)
     char **array;
{
  if (array)
    {
      register int i;
d3649 2
a3650 2
      for (i = 0; array[i] != (char *)NULL; i++)
        free (array[i]);
d3652 12
a3663 2
      free (array);
    }
a3665 84
/* Function is used even when we don't have macros.  Although, I have
   to admit, it is unlikely that you would have a use for it if you
   aren't using macros. */
char **
get_brace_args (quote_single)
     int quote_single;
{
  char **arglist, *word;
  int arglist_index, arglist_size;
  int character, escape_seen, start;
  int depth = 1;

  /* There is an arglist in braces here, so gather the args inside of it. */
  skip_whitespace_and_newlines ();
  input_text_offset++;
  arglist = (char **)NULL;
  arglist_index = arglist_size = 0;

 get_arg:
  skip_whitespace_and_newlines ();
  start = input_text_offset;
  escape_seen = 0;

  while ((character = curchar ()))
    {
      if (character == '\\')
        {
          input_text_offset += 2;
          escape_seen = 1;
        }
      else if (character == '{')
        {
          depth++;
          input_text_offset++;
        }
      else if ((character == ',' && !quote_single) ||
               ((character == '}') && depth == 1))
        {
          int len = input_text_offset - start;

          if (len || (character != '}'))
            {
              word = (char *)xmalloc (1 + len);
              strncpy (word, input_text + start, len);
              word[len] = 0;

              /* Clean up escaped characters. */
              if (escape_seen)
                {
                  register int i;

                  for (i = 0; word[i]; i++)
                    if (word[i] == '\\')
                      memmove (word + i, word + i + 1,
                               1 + strlen (word + i + 1));
                }

              if (arglist_index + 2 >= arglist_size)
                arglist = (char **)xrealloc
                  (arglist, (arglist_size += 10) * sizeof (char *));

              arglist[arglist_index++] = word;
              arglist[arglist_index] = (char *)NULL;
            }

          input_text_offset++;
          if (character == '}')
            break;
          else
            goto get_arg;
        }
      else if (character == '}')
        {
          depth--;
          input_text_offset++;
        }
      else
        {
          input_text_offset++;
          if (character == '\n') line_number++;
        }
    }
  return (arglist);
}
d3667 9
a3675 11
/* **************************************************************** */
/*                                                                  */
/*                  Looking For Include Files                       */
/*                                                                  */
/* **************************************************************** */

/* Given a string containing units of information separated by colons,
   return the next one pointed to by INDEX, or NULL if there are no more.
   Advance INDEX to the character after the colon. */
char *
extract_colon_unit (string, index)
a3676 1
     int *index;
d3678 4
a3681 29
  int i, start;

  i = *index;

  if (!string || (i >= strlen (string)))
    return ((char *)NULL);

  /* Each call to this routine leaves the index pointing at a colon if
     there is more to the path.  If I is > 0, then increment past the
     `:'.  If I is 0, then the path has a leading colon.  Trailing colons
     are handled OK by the `else' part of the if statement; an empty
     string is returned in that case. */
  if (i && string[i] == ':')
    i++;

  start = i;

  while (string[i] && string[i] != ':') i++;

  *index = i;

  if (i == start)
    {
      if (string[i])
        (*index)++;

      /* Return "" in the case of a trailing `:'. */
      return (xstrdup (""));
    }
d3684 2
a3685 39
      char *value;

      value = (char *)xmalloc (1 + (i - start));
      strncpy (value, &string[start], (i - start));
      value [i - start] = 0;

      return (value);
    }
}

/* Return the full pathname for FILENAME by searching along PATH.
   When found, return the stat () info for FILENAME in FINFO.
   If PATH is NULL, only the current directory is searched.
   If the file could not be found, return a NULL pointer. */
char *
get_file_info_in_path (filename, path, finfo)
     char *filename, *path;
     struct stat *finfo;
{
  char *dir;
  int result, index = 0;

  if (path == (char *)NULL)
    path = ".";

  /* Handle absolute pathnames. "./foo", "/foo", "../foo". */
  if (*filename == '/' ||
      (*filename == '.' &&
       (filename[1] == '/' ||
        (filename[1] == '.' && filename[2] == '/')))
#ifdef WIN32
      /* Handle names that look like "d:/foo/bar" */
      || (isalpha (*filename) && filename [1] == ':' 
          && (filename [2] == '/' || filename [2] == '\\'))
#endif
     )
    {
      if (stat (filename, finfo) == 0)
        return (xstrdup (filename));
a3686 8
        return ((char *)NULL);
    }

  while ((dir = extract_colon_unit (path, &index)))
    {
      char *fullpath;

      if (!*dir)
d3688 2
a3689 2
          free (dir);
          dir = xstrdup (".");
a3690 11

      fullpath = (char *)xmalloc (2 + strlen (dir) + strlen (filename));
      sprintf (fullpath, "%s/%s", dir, filename);
      free (dir);

      result = stat (fullpath, finfo);

      if (result == 0)
        return (fullpath);
      else
        free (fullpath);
d3692 1
a3692 1
  return NULL;
@


1.4
log
@null terminate input
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.3 1997/08/01 22:37:42 kstailey Exp $
d4 2
a5 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
d119 3
d1089 1
a1089 1
          puts (_("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d1092 2
a1093 1
For more information about these matters, see the files named COPYING."));
d1151 1
a1151 1
  printf (_("makeinfo (GNU %s %s) %d.%d\n"), PACKAGE, VERSION,
d1196 1
a1196 1
Email bug reports to bug-texinfo@@prep.ai.mit.edu.\n\
d1198 2
a1199 2
           progname, paragraph_start_indent,
           fill_column, max_error_level, reference_warning_limit);
d1256 2
a1257 2
  /* Load the file. */
  result = (char *)xmalloc (1 + file_size);
d1299 1
a1299 1
     The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
d1301 2
a1302 2
  /* Strictly necessary. */
  input_text[size_of_input_text+1] = '\0';
d1343 1
a1343 1
  if (!executing_string)
d1827 1
a1827 1
  if (expand && !executing_string)
d1843 5
a1847 3
      /* Plunk the expansion into the middle of input_text.  */
      str = xstrdup (input_text + limit);
      new_len = input_text_offset + xp_len + strlen (str) + 1;
d1850 2
a1851 1
      strcat (input_text, str);
d3986 1
a3986 1
      add_word_args (_("%d %s %d"), ts->tm_mday, _(months[ts->tm_mon]),
d4173 1
a4173 1
  if (macro_expansion_output_stream)
d4181 1
a4181 1
  if (macro_expansion_output_stream)
d4325 1
a4325 1
      line_error (_("There already is a node having %ctop as a section"),
d4743 1
a4743 1
  if (macro_expansion_output_stream)
d4756 1
a4756 1
  if (macro_expansion_output_stream)
d4766 1
a4766 1
      if (macro_expansion_output_stream)
d4947 1
a4947 1
  if (macro_expansion_output_stream && !defaulting)
d5846 1
a5846 1
      char *arg = &output_paragraph[start_pos];
d5890 1
a5890 1
      char *arg = &output_paragraph[start_pos];
d6327 2
a6328 2
      char *name, *value;
      name = &output_paragraph[start_pos];
a6635 1
  FILE *saved_macro_expansion_output_stream = macro_expansion_output_stream;
a6637 1
  macro_expansion_output_stream = NULL;
a6639 1
  macro_expansion_output_stream = saved_macro_expansion_output_stream;
d7278 21
a7298 23
  if (!macro_expansion_output_stream)
    /* Make an entry in the appropriate index unless we are just
       expanding macros. */
    switch (base_type)
      {
      case deffn:
      case deftypefn:
        execute_string ("%cfindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      case defvr:
      case deftypevr:
      case defcv:
        execute_string ("%cvindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      case defop:
      case deftypemethod:
        execute_string ("%cfindex %s on %s\n",
                        COMMAND_PREFIX, defined_name, type_name);
        break;
      case deftp:
        execute_string ("%ctindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      }
d7570 1
a7570 1
  if (macro_expansion_output_stream)
d7578 1
a7578 1
  if (macro_expansion_output_stream)
d7616 1
a7616 1
      if (macro_expansion_output_stream)
d7944 1
a7944 1
  if (macro_expansion_output_stream)
d7952 1
a7952 1
  if (macro_expansion_output_stream)
a8443 3
  if (macro_expansion_output_stream)
    append_to_expansion_output (input_text_offset + 1); /* include the { */

d8447 3
d8491 1
a8491 1
  if (macro_expansion_output_stream)
d8862 4
a8865 4
              char *trailer = body[i] ? "/" : "";
              len += 1 + strlen (trailer);
              text = (char *)xmalloc (1 + len);
              sprintf (text, "\\%s%s", param, trailer);
d8896 1
a8896 1
  if (macro_expansion_output_stream && !me_inhibit_expansion)
d8919 1
a8919 1
      if (macro_expansion_output_stream && !me_inhibit_expansion)
d8947 1
a8947 1
  if (macro_expansion_output_stream)
d9144 1
a9144 1
  if (macro_expansion_output_stream)
d9155 1
a9155 1
  if (macro_expansion_output_stream)
d9189 1
a9189 1
  if (macro_expansion_output_stream)
d9292 1
a9292 1
  executing_string++;
d9295 1
a9295 1
  executing_string--;
d9315 1
a9315 1
    itext = remember_itext (input_text, 0);
@


1.3
log
@fix conflicts
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.47 1997/07/31 21:36:27 karl Exp $
d1296 2
@


1.2
log
@Add "-P dir" option to prepend a dir to the include path.
This is driven by g77 using install.texi which collides with gcc install.texi.
This has been submitted to bug-texinfo@@prep.ai.mit.edu.

*** You must rebuild/reinstall makeinfo before building gcc! ***
@
text
@d1 2
a2 2
/* Makeinfo -- convert texinfo format files into info files.
   $Id: makeinfo.c,v 1.1.1.3 1996/12/15 21:39:24 downsj Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96 Free Software Foundation, Inc.
d20 6
a25 1
   Makeinfo is authored by Brian Fox (bfox@@ai.mit.edu). */
d28 1
a28 1
int minor_version = 67;
d30 42
a71 1
/* You can change some of the behaviour of Makeinfo by changing the
d99 2
a100 1
   facility, users can create their own command procedures with arguments. */
a103 69
/* Indent #pragma so that older Cpp's don't try to parse it. */
#if defined (_AIX)
 # pragma alloca
#endif /* _AIX */

#include <stdio.h>
#include <sys/types.h>
#include <ctype.h>
#include <sys/stat.h>
#include <pwd.h>
#include <errno.h>

#if defined (HAVE_VARARGS_H)
#include <varargs.h>
#endif /* HAVE_VARARGS_H */
#include "getopt.h"

#if defined (HAVE_UNISTD_H)
#include <unistd.h>
#endif /* HAVE_UNISTD_H */

#if defined (VMS)
#include <perror.h>
#endif

#if defined (HAVE_STRING_H)
#include <string.h>
#else
#include <strings.h>
#endif /* !HAVE_STRING_H */

#if defined (TM_IN_SYS_TIME)
#include <sys/time.h>
#else
#include <time.h>
#endif /* !TM_IN_SYS_TIME */

#if defined (HAVE_SYS_FCNTL_H)
#include <sys/fcntl.h>
#else
#include <fcntl.h>
#endif /* !HAVE_SYS_FCNTL_H */

#if defined (HAVE_SYS_FILE_H)
#include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */

#if defined (__GNUC__)
#define alloca __builtin_alloca
#else
#if defined(HAVE_ALLOCA_H)
#include <alloca.h>
#else /* !HAVE_ALLOCA_H */
#if !defined (_AIX)
extern char *alloca ();
#endif /* !_AIX */
#endif /* !HAVE_ALLOCA_H */
#endif /* !__GNUC__ */

void *xmalloc (), *xrealloc ();
#if defined (__osf__)
extern void *malloc (), *realloc ();
#endif /* __osf__ */

char **get_brace_args ();
int array_len ();
void free_array ();
static void isolate_nodename ();

d107 1
a107 1
/* Non-zero means that we are currently hacking the insides of an
d111 1
a111 1
/* Non-zero means that start_paragraph () MUST be called before we pay
d115 1
a115 1
/* Non-zero means a string is in execution, as opposed to a file. */
d120 1
a120 1
   of the input text to.  The resultant file is another texinfo file, but
d124 1
d129 2
a130 2
  char *pointer;		/* Pointer to the input text. */
  int offset;			/* Offset of the last character output. */
d136 2
a137 3
/* Non-zero means to inhibit the writing of macro expansions to the output
   stream.  This is used in special cases where the output has already been
   written. */
a145 2
/* Some systems don't declare this function in pwd.h. */
struct passwd *getpwnam ();
d148 3
a150 3
/*								    */
/*			    Global Variables			    */
/*								    */
d156 1
a156 1
/* Return non-zero if STRING is the text at input_text + input_text_offset,
a174 3
/* Current output stream. */
FILE *output_stream;

d181 1
a181 2
/* Filling.. */
/* Non-zero indicates that filling will take place on long lines. */
d184 1
a184 1
/* Non-zero means that words are not to be split, even in long lines.  This
d188 1
a188 1
/* Non-zero indicates that filling a line also indents the new line. */
d201 1
a201 1
/* Non-zero means that the use of paragraph_start_indent is inhibited.
d215 1
a215 1
/* Non-zero indicates that indentation is temporarily turned off. */
d218 1
a218 1
/* Non-zero means forcing output text to be flushright. */
d221 1
a221 1
/* Non-zero means that the footnote style for this document was set on
d225 1
a225 1
/* Non-zero means that we automatically number footnotes that have no
d242 1
a242 1
  { '\n', COMMAND_PREFIX, 'n', 'o', 'd', 'e', ' ', '\0' };
d246 1
a246 1
  { '\n', COMMAND_PREFIX, 'm', 'e', 'n', 'u', '\0' };
d251 1
a251 1
      's', 'e', 't', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', '\0' };
d281 9
a289 9
  char *node;		/* name of this node. */
  char *prev;		/* name of "Prev:" for this node. */
  char *next;		/* name of "Next:" for this node. */
  char *up;		/* name of "Up:" for this node.   */
  int position;		/* output file position of this node. */
  int line_no;		/* defining line in source file. */
  char *filename;	/* The file that this node was found in. */
  int touched;		/* non-zero means this node has been referenced. */
  int flags;		/* Room for growth.  Right now, contains 1 bit. */
d299 2
a300 2
#define NO_WARN	   0x8
#define IS_TOP 	   0x10
d304 6
d311 2
a312 2
#define ME_RECURSE	0x01
#define ME_QUOTE_ARG	0x02
d316 7
a322 7
  char *name;			/* Name of the macro. */
  char **arglist;		/* Args to replace when executing. */
  char *body;			/* Macro body. */
  char *source_file;		/* File where this macro is defined. */
  int source_lineno;		/* Line number within FILENAME. */
  int inhibited;		/* Non-zero means make find_macro () fail. */
  int flags;			/* ME_RECURSE, ME_QUOTE_ARG, etc. */
d342 6
a347 6
  char *node;			/* Name of node referred to. */
  char *containing_node;	/* Name of node containing this reference. */
  int line_no;			/* Line number where the reference occurs. */
  int section;			/* Section level where the reference occurs. */
  char *filename;		/* Name of file where the reference occurs. */
  enum reftype type;		/* Type of reference, either menu or note. */
d359 1
a359 1
/* Non-zero means that we have seen "@@top" once already. */
d362 1
a362 1
/* Non-zero means that we have seen a non-"@@top" node already. */
d367 3
d376 1
a376 1
/* Non-zero means do not output "Node: Foo" for node separations. */
d385 1
a385 1
/* Non-zero means print out information about what is going on when it
d389 1
a389 1
/* Non-zero means to be relaxed about the input file.  This is useful when
a414 5
/* Forward declarations. */
#if !defined (HAVE_STRDUP)
extern char *strdup ();
#endif /* HAVE_STRDUP */

d420 1
a420 1
void remember_error ();
a427 1
void execute_string ();
d433 6
d442 1
a442 1
void add_word_args (), add_word (), add_char (), insert (), flush_output ();
d446 1
a446 1
void do_flush_right_indentation ();
d448 8
d463 2
a464 2
  cm_kbd (), cm_angle_brackets (), cm_no_op (), cm_not_fixed_width (),
  cm_strong (), cm_var (), cm_w ();
d475 1
a475 1
/* All @@defxxx commands map to cm_defun, most accent commands map to
d481 2
a482 1
  cm_inforef (), cm_quotation (), cm_display (), cm_itemize (),
d486 1
a486 1
  cm_ifinfo (), cm_kindex (), cm_cindex (),
d490 1
a490 1
  cm_defindex (), cm_defcodeindex (), cm_sc (), cm_result (), cm_expansion (),
d525 1
a525 1
static COMMAND CommandTable[] = {
d625 1
a625 1
  { "email", cm_angle_brackets, BRACE_ARGS },
d648 1
d655 3
d661 1
d668 2
a669 1
  { "key", cm_angle_brackets, BRACE_ARGS },
a673 1
#if defined (HAVE_MACROS)
a674 1
#endif
d703 1
a703 1
  { "sc", cm_sc, BRACE_ARGS },
d745 1
d749 1
a749 1
  { "var", cm_var, BRACE_ARGS },
d770 1
a770 1
  /* Now @@include does what this was supposed to. */
d774 2
a775 1
  {(char *) NULL, (COMMAND_FUNCTION *) NULL}, NO_BRACE_ARGS};
d779 5
a783 4
  { "error-limit", 1, 0, 'e' },			/* formerly -el */
  { "fill-column", 1, 0, 'f' },			/* formerly -fc */
  { "footnote-style", 1, 0, 's' },		/* formerly -ft */
  { "no-headers", 0, &no_headers, 1 },		/* Do not output Node: foo */
d785 3
a787 4
  { "no-validate", 0, &validating, 0 },		/* formerly -nv */
  { "no-split", 0, &splitting, 0 },		/* formerly -ns */
  { "no-warn", 0, &print_warnings, 0 },		/* formerly -nw */
#if defined (HAVE_MACROS)
a788 1
#endif /* HAVE_MACROS */
d792 3
a794 3
  { "paragraph-indent", 1, 0, 'p' },		/* formerly -pi */
  { "reference-limit", 1, 0, 'r' },		/* formerly -rl */
  { "verbose", 0, &verbose_mode, 1 },		/* formerly -verbose */
d800 103
a902 5
/* Values for calling handle_variable_internal (). */
#define SET	1
#define CLEAR	2
#define IFSET	3
#define IFCLEAR	4
d904 15
d920 3
a922 3
/*								    */
/*			Main ()  Start of code  		    */
/*					        		    */
d940 11
d952 2
a953 9
  while ((c = getopt_long
	  (argc, argv,
#if defined (HAVE_MACROS)
	   "D:E:U:I:P:f:o:p:e:r:s:V",
#else
	   "D:U:I:P:f:o:p:e:r:s:V",
#endif /* !HAVE_MACROS */
	   long_options, &ind))
	 != EOF)
d956 1
a956 1
	c = long_options[ind].val;
d959 74
a1032 98
	{
	  /* User specified variable to set or clear? */
	case 'D':
	case 'U':
	  handle_variable_internal ((c == 'D') ? SET : CLEAR, optarg);
	  break;

#if defined (HAVE_MACROS)
	  /* Use specified a macro expansion output file? */
	case 'E':
	  if (!macro_expansion_output_stream)
	    {
	      macro_expansion_output_stream = fopen (optarg, "w");
	      if (!macro_expansion_output_stream)
		error ("Couldn't open macro expansion output \"%s\"", optarg);
	    }
	  else
	    error ("Cannot specify more than one macro expansion output");
	  break;
#endif /* HAVE_MACROS */

	  /* User specified include file path? */
	case 'I':
	  if (!include_files_path)
	    include_files_path = strdup (".");

	  include_files_path = (char *)
	    xrealloc (include_files_path,
		      2 + strlen (include_files_path) + strlen (optarg));
	  strcat (include_files_path, ":");
	  strcat (include_files_path, optarg);
	  break;

	  /* Prepend User specified include dir to include path? */
	case 'P':
	  if (!include_files_path) {
	    include_files_path = strdup (optarg);
	    include_files_path = (char *)
	      xrealloc (include_files_path,
			strlen (include_files_path) + 3); /* 3 for ":." & NULL */
	    strcat (include_files_path, ":.");
	  } else {
	    char *tmp = strdup (include_files_path);

	    include_files_path = (char *)
	      xrealloc (include_files_path,		/* 2 for ":" & NULL */
			strlen (include_files_path) + strlen (optarg) + 2);
	    strcpy (include_files_path, optarg);
	    strcat (include_files_path, ":");
	    strcat (include_files_path, tmp);
	    free (tmp);
	  }
	  break;

	  /* User specified fill_column? */
	case 'f':
	  if (sscanf (optarg, "%d", &fill_column) != 1)
	    {
	      fprintf (stderr,
                       "%s: --fill-column arg must be numeric, not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
	  break;

	  /* User specified output file? */
	case 'o':
	  command_output_filename = strdup (optarg);
	  break;

	  /* User specified paragraph indent (paragraph_start_index)? */
	case 'p':
	  if (set_paragraph_indent (optarg) < 0)
	    {
	      fprintf (stderr,
          "%s: --paragraph-indent arg must be numeric/none/asis, not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
	  break;

	  /* User specified error level? */
	case 'e':
	  if (sscanf (optarg, "%d", &max_error_level) != 1)
	    {
	      fprintf (stderr,
                       "%s: --error-limit arg must be numeric, not `%s'.\n", 
                       progname, optarg);
	    }
	    usage (stderr, FATAL);
	  break;

	  /* User specified reference warning limit? */
	case 'r':
	  if (sscanf (optarg, "%d", &reference_warning_limit) != 1)
	    {
	      fprintf (stderr,
                     "%s: --reference-limit arg must be numeric, not `%s'.\n", 
d1034 42
a1075 10
	      usage (FATAL);
	    }
	  break;

	  /* User specified footnote style? */
	case 's':
	  if (set_footnote_style (optarg) < 0)
	    {
	      fprintf (stderr,
          "%s: --footnote-style arg must be `separate' or `end', not `%s'.\n", 
d1077 9
a1085 13
	      usage (FATAL);
	    }
	  footnote_style_preset = 1;
	  break;

	case 'h':
	  usage (NO_ERROR);
	  break;

	  /* User requested version info? */
	case 'V':
	  print_version_info ();
          puts ("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d1088 8
a1095 8
For more information about these matters, see the files named COPYING.");
	  exit (NO_ERROR);
	  break;

	case '?':
	  usage (FATAL);
	  break;
	}
d1102 1
a1102 1
	reading_from_stdin = 1;
d1105 2
a1106 2
          fprintf (stderr, "%s: missing file argument.\n", progname);
	  usage (FATAL);
d1118 1
a1118 2
      /* If the user has not specified an output file, then use stdout by
	 default. */
d1120 1
a1120 1
	command_output_filename = strdup ("-");
d1131 1
a1131 1
	convert_from_file (argv[optind++]);
d1146 2
a1147 54
  printf ("GNU Makeinfo (Texinfo 3.9) %d.%d\n", major_version, minor_version);
}

/* **************************************************************** */
/*								    */
/*			Generic Utilities			    */
/*								    */
/* **************************************************************** */

static void
memory_error (callers_name, bytes_wanted)
     char *callers_name;
     int bytes_wanted;
{
  char printable_string[80];

  sprintf (printable_string,
	   "Virtual memory exhausted in %s ()!  Needed %d bytes.",
	   callers_name, bytes_wanted);

  error (printable_string);
  abort ();
}

/* Just like malloc, but kills the program in case of fatal error. */
void *
xmalloc (nbytes)
     unsigned int nbytes;
{
  void *temp = (void *) malloc (nbytes);

  if (nbytes && temp == (void *)NULL)
    memory_error ("xmalloc", nbytes);

  return (temp);
}

/* Like realloc (), but barfs if there isn't enough memory. */
void *
xrealloc (pointer, nbytes)
     void *pointer;
     unsigned int nbytes;
{
  void *temp;

  if (!pointer)
    temp = (void *)xmalloc (nbytes);
  else
    temp = (void *)realloc (pointer, nbytes);

  if (nbytes && !temp)
    memory_error ("xrealloc", nbytes);

  return (temp);
d1158 1
a1158 1
    fprintf (stderr, "Try `%s --help' for more information.\n", progname);
d1160 1
a1160 1
    printf ("Usage: %s [OPTION]... TEXINFO-FILE...\n\
d1167 3
a1169 2
-E MACRO-OFILE	       process macros only, output texinfo source.\n\
-I DIR                 add DIR to the directory search list for @@include.\n\
d1177 1
d1184 3
a1186 1
--paragraph-indent NUM indent paragraphs with NUM spaces (default %d).\n\
d1192 3
a1194 3
",
	   progname, paragraph_start_indent,
	   fill_column, max_error_level, reference_warning_limit);
d1234 1
a1234 1
  int file = -1, n, i, count = 0;
d1258 2
a1259 1
#if defined (VMS)
d1261 3
d1266 1
a1266 1
#else /* !VMS */
d1269 1
a1269 1
#endif /* !VMS */
d1273 1
a1273 1
	free (result);
d1276 1
a1276 1
	free (fullpath);
d1279 1
a1279 1
	close (file);
d1289 1
a1289 1
  node_filename = strdup (fullpath);
d1322 1
a1322 1
    abort ();			/* My fault.  I wonder what I did? */
d1401 1
a1401 1
  basename = strdup (basename);
d1410 1
a1410 1
      *temp = '\0';
d1438 1
a1438 1
      result[i] = '\0';
d1452 1
a1452 1
      return (strdup (name + i + 1));
d1454 1
a1454 1
  return (strdup (name));
d1472 4
a1475 4
	{
	  free (filename);
	  filename = strdup ("noname.texi");
	}
d1478 2
a1479 2
	if (filename[i] == '.')
	  break;
d1482 1
a1482 1
	i = strlen (filename);
d1485 1
a1485 1
	filename = (char *)xrealloc (filename, i + 6);
d1489 1
a1489 1
	
d1504 1
a1504 1
	i--;
d1507 1
a1507 1
	i++;
d1526 1
a1526 1
    return (strdup (""));
d1532 1
a1532 1
    return (strdup (filename));
d1542 1
a1542 1
	if (!getwd (localdir))
d1544 5
a1548 5
	  {
	    fprintf (stderr, "%s: getwd: %s, %s\n",
		     progname, filename, localdir);
	    exit (1);
	  }
d1552 1
a1552 1
      result = strdup (localdir);
d1557 1
d1559 11
a1569 11
	{
	  /* Return the concatenation of the environment variable HOME
	     and the rest of the string. */
	  char *temp_home;

	  temp_home = (char *) getenv ("HOME");
	  result = (char *)xmalloc (strlen (&filename[1])
				    + 1
				    + temp_home ? strlen (temp_home)
				    : 0);
	  *result = '\0';
d1571 2
a1572 2
	  if (temp_home)
	    strcpy (result, temp_home);
d1574 2
a1575 2
	  strcat (result, &filename[1]);
	}
d1577 25
a1601 25
	{
	  struct passwd *user_entry;
	  int i, c;
	  char *username = (char *)xmalloc (257);

	  for (i = 1; c = filename[i]; i++)
	    {
	      if (c == '/')
		break;
	      else
		username[i - 1] = c;
	    }
	  if (c)
	    username[i - 1] = '\0';

	  user_entry = getpwnam (username);

	  if (!user_entry)
	    return (strdup (filename));

	  result = (char *)xmalloc (1 + strlen (user_entry->pw_dir)
				    + strlen (&filename[i]));
	  strcpy (result, user_entry->pw_dir);
	  strcat (result, &filename[i]);
	}
d1603 1
d1615 3
a1617 133
/*								    */
/*			Error Handling				    */
/*								    */
/* **************************************************************** */

/* Number of errors encountered. */
int errors_printed = 0;

/* Print the last error gotten from the file system. */
int
fs_error (filename)
     char *filename;
{
  remember_error ();
  perror (filename);
  return (0);
}

/* Print an error message, and return false. */
#if defined (HAVE_VARARGS_H) && defined (HAVE_VFPRINTF)

int
error (va_alist)
     va_dcl
{
  char *format;
  va_list args;

  remember_error ();
  va_start (args);
  format = va_arg (args, char *);
  vfprintf (stderr, format, args);
  va_end (args);
  putc ('\n', stderr);
}

/* Just like error (), but print the line number as well. */
int
line_error (va_alist)
     va_dcl
{
  char *format;
  va_list args;

  remember_error ();
  va_start (args);
  format = va_arg (args, char *);
  fprintf (stderr, "%s:%d: ", input_filename, line_number);
  vfprintf (stderr, format, args);
  fprintf (stderr, ".\n");
  va_end (args);
  return ((int) 0);
}

int
warning (va_alist)
     va_dcl
{
  char *format;
  va_list args;

  va_start (args);
  format = va_arg (args, char *);
  if (print_warnings)
    {
      fprintf (stderr, "%s:%d: Warning: ", input_filename, line_number);
      vfprintf (stderr, format, args);
      fprintf (stderr, ".\n");
    }
  va_end (args);
  return ((int) 0);
}

#else /* !(HAVE_VARARGS_H && HAVE_VFPRINTF) */

int
error (format, arg1, arg2, arg3, arg4, arg5)
     char *format;
{
  remember_error ();
  fprintf (stderr, format, arg1, arg2, arg3, arg4, arg5);
  putc ('\n', stderr);
  return ((int) 0);
}

/* Just like error (), but print the line number as well. */
int
line_error (format, arg1, arg2, arg3, arg4, arg5)
     char *format;
{
  remember_error ();
  fprintf (stderr, "%s:%d: ", input_filename, line_number);
  fprintf (stderr, format, arg1, arg2, arg3, arg4, arg5);
  fprintf (stderr, ".\n");
  return ((int) 0);
}

int
warning (format, arg1, arg2, arg3, arg4, arg5)
     char *format;
{
  if (print_warnings)
    {
      fprintf (stderr, "%s:%d: Warning: ", input_filename, line_number);
      fprintf (stderr, format, arg1, arg2, arg3, arg4, arg5);
      fprintf (stderr, ".\n");
    }
  return ((int) 0);
}

#endif /* !(HAVE_VARARGS_H && HAVE_VFPRINTF) */

/* Remember that an error has been printed.  If this is the first
   error printed, then tell them which program is printing them.
   If more than max_error_level have been printed, then exit the
   program. */
void
remember_error ()
{
  errors_printed++;
  if (max_error_level && (errors_printed > max_error_level))
    {
      fprintf (stderr, "Too many errors!  Gave up.\n");
      flush_file_stack ();
      cm_bye ();
      exit (1);
    }
}

/* **************************************************************** */
/*								    */
/*			Hacking Tokens and Strings		    */
/*								    */
d1635 1
a1635 1
	line_number++;
d1637 1
a1637 1
      result = strdup (" ");
d1643 2
a1644 2
	       && (character = curchar ())
	       && command_char (character));
d1648 1
a1648 1
  result[i] = '\0';
d1652 1
a1652 1
/* Return non-zero if CHARACTER is self-delimiting. */
d1676 4
a1679 4
	{
	  strcpy (string, string + x);
	  break;
	}
d1686 1
a1686 1
  string[len + 1] = '\0';
d1706 7
a1712 7
	{
	  temp[temp_index - 1] = ' ';
	  while ((c = string[string_index]) && (c == ' ' ||
						c == '\t' ||
						c == '\n'))
	    string_index++;
	}
d1714 1
a1714 1
  temp[temp_index] = '\0';
d1740 4
a1743 4
	{
	  line_error ("Expected `%s'", string);
	  return;
	}
d1777 1
a1777 1
  (*string)[len] = '\0';
d1791 2
a1792 1
get_until_in_line (match, string)
d1795 24
a1818 1
  int real_bottom, temp;
d1820 28
a1847 2
  real_bottom = size_of_input_text;
  temp = search_forward ("\n", input_text_offset);
d1849 1
a1849 4
  if (temp < 0)
    temp = size_of_input_text;

  size_of_input_text = temp;
d1861 1
a1861 1
  if (curchar () == '\n')	/* as opposed to the end of the file... */
d1877 1
a1877 1
	line_number--;
d1887 1
a1889 1
  char *temp;
d1894 1
a1894 1
	brace++;
d1896 1
a1896 1
	brace--;
d1898 1
a1898 1
	line_number++;
d1901 2
a1902 2
	  (brace == 0 && strncmp (input_text + i, match, match_len) == 0))
	break;
d1908 1
a1908 1
  temp[match_len] = '\0';
d1914 3
a1916 3
/*								    */
/*			Converting the File     		    */
/*								    */
d1948 1
a1948 1
/* Convert the texinfo file coming from the open stream STREAM.  Assume the
d1968 2
a1969 2
	buffer = (char *)
	  xrealloc (buffer, (buffer_size += READ_BUFFER_GROWTH));
d1974 4
a1977 4
	{
	  perror (name);
	  exit (FATAL);
	}
d1981 1
a1981 1
	break;
d1987 2
a1988 2
  input_filename = strdup (name);
  node_filename = strdup (name);
d2018 1
a2018 1
	break;
d2021 5
a2025 5
	{
	  fs_error (filename);
	  free (filename);
	  return;
	}
d2057 1
a2057 1
	search_forward (setfilename_search, input_text_offset);
d2060 3
a2062 3
	  ((input_text_offset > 0) &&
	   (input_text[input_text_offset -1] == '\n')))
	break;
d2064 1
a2064 1
	input_text_offset++;
d2070 1
a2070 1
	{
d2072 2
a2073 2
	  error ("No `%s' found in `%s'", setfilename_search, name);
	  goto finished;
d2075 1
a2075 1
	  register int i, end_of_first_line;
d2077 19
a2095 19
	  /* Find the end of the first line in the file. */
	  for (i = 0; i < size_of_input_text - 1; i++)
	    if (input_text[i] == '\n')
	      break;

	  end_of_first_line = i + 1;

	  input_text_offset = 0;

	  for (i = 0; i < end_of_first_line; i++)
	    {
	      if ((input_text[i] == '\\') &&
		  (strncmp (input_text + i + 1, "include", 7) == 0))
		{
		  input_text_offset = end_of_first_line;
		  break;
		}
	    }
	  command_output_filename = output_name_from_input_name (name);
d2097 1
a2097 1
	}
d2107 1
a2107 1
	discard_until ("\n");
d2109 1
a2109 1
	input_text_offset = 0;
d2117 1
a2117 2
  if (real_output_filename &&
      strcmp (real_output_filename, "-") == 0)
d2119 8
a2126 1
      real_output_filename = strdup (real_output_filename);
d2128 1
a2128 1
      splitting = 0;		/* Cannot split when writing to stdout. */
d2133 1
a2133 1
	real_output_filename = expand_filename (output_filename, name);
d2135 1
a2135 1
	real_output_filename = strdup (real_output_filename);
d2141 1
a2141 1
    printf ("Making %s file `%s' from `%s'.\n",
d2155 1
a2155 1
    pretty_output_filename = strdup ("stdout");
d2166 1
a2166 1
	line_number++;
d2171 3
a2173 3
     add_word_args ("This is Info file %s, produced by Makeinfo version %d.%d",
		     output_filename, major_version, minor_version);
     add_word_args (" from the input file %s.\n", input_filename);
d2180 1
d2186 12
a2197 1
    fclose (macro_expansion_output_stream);
d2200 1
a2200 1
  if (output_stream != NULL)
d2205 5
a2209 5
	{
	  tag_table = (TAG_ENTRY *) reverse_list (tag_table);
	  if (!no_headers)
	    write_tag_table ();
	}
d2212 1
a2212 1
	fclose (output_stream);
d2216 1
a2216 1
	validate_file (tag_table);
d2218 11
a2228 4
      /* This used to test  && !errors_printed.
	 But some files might have legit warnings.  So split anyway.  */
      if (splitting)
	split_file (real_output_filename, 0);
d2237 1
a2237 1
  if ((*pointer) != (char *) NULL)
a2247 1
  free_and_clear (&current_node);
d2254 1
d2267 1
a2267 1
  output_paragraph[0] = '\0';
d2289 1
a2289 1
	break;
d2294 6
a2299 6
	  (character == '\'' || character == '`') &&
	  input_text[input_text_offset + 1] == character)
	{
	  input_text_offset++;
	  character = '"';
	}
d2302 8
a2309 8
	{
	  dash_count++;
	  if (dash_count == 2 && !in_fixed_width_font)
	    {
	      input_text_offset++;
	      continue;
	    }
	}
d2311 3
a2313 3
	{
	  dash_count = 0;
	}
d2316 1
a2316 1
	 is blank.  If so, advance to the carriage return. */
d2318 2
a2319 2
	{
	  register int i = input_text_offset + 1;
d2321 2
a2322 2
	  while (i < size_of_input_text && whitespace (input_text[i]))
	    i++;
d2324 9
a2332 9
	  if (i == size_of_input_text || input_text[i] == '\n')
	    {
	      if (i == size_of_input_text)
		i--;

	      input_text_offset = i;
	      character = curchar ();
	    }
	}
d2335 2
a2336 2
	{
	  line_number++;
d2338 13
a2350 13
	  /* Check for a menu entry here, since the "escape sequence"
	     that begins menu entries is "\n* ". */
	  if (in_menu && input_text_offset + 1 < size_of_input_text)
	    {
	      char *glean_node_from_menu (), *tem;

	      /* Note that the value of TEM is discarded, since it is
		 gauranteed to be NULL when glean_node_from_menu () is
		 called with a non-zero argument. */
	      if (!in_detailmenu)
		tem = glean_node_from_menu (1);
	    }
	}
d2353 17
a2369 18
	{
	case COMMAND_PREFIX:
	  read_command ();
	  break;

	case '{':

	  /* Special case.  I'm not supposed to see this character by itself.
	     If I do, it means there is a syntax error in the input text.
	     Report the error here, but remember this brace on the stack so
	     you can ignore its partner. */

	  line_error ("Misplaced `{'");
	  remember_brace (misplaced_brace);

	  /* Don't advance input_text_offset since this happens in
	     remember_brace ().
	     input_text_offset++;
d2371 1
a2371 1
	  break;
d2373 9
a2381 9
	case '}':
	  pop_and_call_brace ();
	  input_text_offset++;
	  break;

	default:
	  add_char (character);
	  input_text_offset++;
	}
d2398 3
a2400 3
  for (i = 0; CommandTable[i].name; i++)
    if (strcmp (CommandTable[i].name, string) == 0)
      return (&CommandTable[i]);
d2406 1
a2406 1
	(strcmp (user_command_array[i]->name, string) == 0))
d2409 1
a2409 1
  /* Nope, we never heard of this command. */
d2433 4
a2436 4
	/* We disallow recursive use of a macro call.  Inhibit the expansion
	   of this macro during the life of its execution. */
	if (!(def->flags & ME_RECURSE))
	  def->inhibited = 1;
d2438 1
a2438 1
	execute_macro (def);
d2440 2
a2441 2
	if (!(def->flags & ME_RECURSE))
	  def->inhibited = 0;
d2443 1
a2443 1
	return;
a2448 1

d2451 1
a2451 1
      line_error ("Unknown command `%s'", command);
d2468 4
a2471 4
  for (i = 0; CommandTable[i].name; i++)
    if (proc == CommandTable[i].proc)
      return (CommandTable[i].name);
  return ("NO_NAME!");
d2485 1
a2485 1
    line_error ("%c%s expected `{..}'", COMMAND_PREFIX, command);
d2518 1
a2518 1
      line_error ("Unmatched }");
d2542 1
a2542 1
	stack->pos += amount;
d2560 10
a2569 10
	{
	  char *proc_name;
	  int temp_line_number = line_number;

	  line_number = brace_stack->line;
	  proc_name = find_proc_name (brace_stack->proc);
	  line_error ("%c%s missing close brace", COMMAND_PREFIX, proc_name);
	  line_number = temp_line_number;
	  pop_and_call_brace ();
	}
d2571 6
a2576 6
	{
	  BRACE_ELEMENT *temp;
	  temp = brace_stack->next;
	  free (brace_stack);
	  brace_stack = temp;
	}
d2592 1
a2592 1
	len = fill_column - output_column;
d2594 1
a2594 1
	len = len - output_column;
d2601 11
a2611 24
    default:
      if (character < ' ')
	len = 2;
      else
	len = 1;
    }
  return (len);
}

#if defined (HAVE_VARARGS_H) && defined (HAVE_VSPRINTF)

void
add_word_args (va_alist)
     va_dcl
{
  char buffer[1000];
  char *format;
  va_list args;

  va_start (args);
  format = va_arg (args, char *);
  vsprintf (buffer, format, args);
  va_end (args);
  add_word (buffer);
a2613 2
#else /* !(HAVE_VARARGS_H && HAVE_VSPRINTF) */

d2615 7
a2621 2
add_word_args (format, arg1, arg2, arg3, arg4, arg5)
     char *format;
d2624 11
a2634 1
  sprintf (buffer, format, arg1, arg2, arg3, arg4, arg5);
a2637 2
#endif /* !(HAVE_VARARGS_H && HAVE_VSPRINTF) */

d2647 1
a2647 1
/* Non-zero if the last character inserted has the syntax class of NEWLINE. */
d2654 1
a2654 1
/* Non-zero means that a newline character has already been
d2658 1
a2658 1
/* When non-zero we have finished an insertion (see end_insertion ()) and we
d2662 1
a2662 1
/* Non-zero means attempt to make all of the lines have fill_column width. */
d2666 1
a2666 1
   non-zero, then do filling as well. */
d2681 1
a2681 1
      line_already_broken = 0;	/* The line is no longer broken. */
d2683 4
a2686 4
	{
	  indent (current_indent - output_column);
	  output_column = current_indent;
	}
d2698 2
a2699 2
	{
	  insert ('\n');
d2701 13
a2713 13
	  if (force_flush_right)
	    {
	      close_paragraph ();
	      /* Hack to force single blank lines out in this mode. */
	      flush_output ();
	    }

	  output_column = 0;

	  if (!no_indent && paragraph_is_open)
	    indent (output_column = current_indent);
	  break;
	}
d2715 8
a2722 8
	{
	  if (sentence_ender (last_inserted_character))
	    {
	      insert (' ');
	      output_column++;
	      last_inserted_character = character;
	    }
	}
d2725 4
a2728 4
	{
	  close_paragraph ();
	  pending_indent = 0;
	}
d2730 5
a2734 5
	{
	  last_char_was_newline = 1;
	  insert (' ');
	  output_column++;
	}
d2739 2
a2740 2
	int len = get_char_len (character);
	int suppress_insert = 0;
d2742 118
a2859 118
	if ((character == ' ') && (last_char_was_newline))
	  {
	    if (!paragraph_is_open)
	      {
		pending_indent++;
		return;
	      }
	  }

	if (!paragraph_is_open)
	  {
	    start_paragraph ();

	    /* If the paragraph is supposed to be indented a certain way,
	       then discard all of the pending whitespace.  Otherwise, we
	       let the whitespace stay. */
	    if (!paragraph_start_indent)
	      indent (pending_indent);
	    pending_indent = 0;
	  }

	if ((output_column += len) > fill_column)
	  {
	    if (filling_enabled)
	      {
		int temp = output_paragraph_offset;
		while (--temp > 0 && output_paragraph[temp] != '\n')
		  {
		    /* If we have found a space, we have the place to break
		       the line. */
		    if (output_paragraph[temp] == ' ')
		      {
			/* Remove trailing whitespace from output. */
			while (temp && whitespace (output_paragraph[temp - 1]))
			  temp--;

			output_paragraph[temp++] = '\n';

			/* We have correctly broken the line where we want
			   to.  What we don't want is spaces following where
			   we have decided to break the line.  We get rid of
			   them. */
			{
			  int t1 = temp;

			  for (;; t1++)
			    {
			      if (t1 == output_paragraph_offset)
				{
				  if (whitespace (character))
				    suppress_insert = 1;
				  break;
				}
			      if (!whitespace (output_paragraph[t1]))
				break;
			    }

			  if (t1 != temp)
			    {
			      adjust_braces_following (temp, (- (t1 - temp)));
			      strncpy ((char *) &output_paragraph[temp],
				       (char *) &output_paragraph[t1],
				       (output_paragraph_offset - t1));
			      output_paragraph_offset -= (t1 - temp);
			    }
			}

			/* Filled, but now indent if that is right. */
			if (indented_fill && current_indent)
			  {
			    int buffer_len = ((output_paragraph_offset - temp)
					      + current_indent);
			    char *temp_buffer = (char *)xmalloc (buffer_len);
			    int indentation = 0;

			    /* We have to shift any markers that are in
			       front of the wrap point. */
			    adjust_braces_following (temp, current_indent);

			    while (current_indent > 0 &&
				   indentation != current_indent)
			      temp_buffer[indentation++] = ' ';

			    strncpy ((char *) &temp_buffer[current_indent],
				     (char *) &output_paragraph[temp],
				     buffer_len - current_indent);

			    if (output_paragraph_offset + buffer_len
				>= paragraph_buffer_len)
			      {
				unsigned char *tt = xrealloc
				  (output_paragraph,
				   (paragraph_buffer_len += buffer_len));
				output_paragraph = tt;
			      }
			    strncpy ((char *) &output_paragraph[temp],
				     temp_buffer, buffer_len);
			    output_paragraph_offset += current_indent;
			    free (temp_buffer);
			  }
			output_column = 0;
			while (temp < output_paragraph_offset)
			  output_column +=
			    get_char_len (output_paragraph[temp++]);
			output_column += len;
			break;
		      }
		  }
	      }
	  }

	if (!suppress_insert)
	  {
	    insert (character);
	    last_inserted_character = character;
	  }
	last_char_was_newline = 0;
	line_already_broken = 0;
d2873 1
a2873 1
	xrealloc (output_paragraph, (paragraph_buffer_len += 100));
d2886 17
d2915 6
a2920 6
	{
	  if (whitespace (output_paragraph[output_paragraph_offset - 1]))
	    output_paragraph_offset--;
	  else
	    break;
	}
d2925 4
a2928 4
	if (whitespace (output_paragraph[output_paragraph_offset - 1]))
	  output_paragraph_offset--;
	else
	  break;
d2932 1
a2932 1
/* Non-zero means do not honor calls to flush_output (). */
d2965 1
a2965 1
  	    output_paragraph[i] &= 0x7f;
d2999 2
a3000 3
      /* Start a new paragraph here, inserting whatever indention is correct
	 for the now current insertion level (one above the one that we are
	 ending). */
d3003 2
a3004 2
      /* Tell close_paragraph () that the previous line has already been
	 broken, so it should insert one less newline. */
d3007 1
a3007 2
      /* Let functions such as add_char () know that we have already found a
	 newline. */
d3013 6
a3018 6
	 two `@@end' commands in a row.  Note that the first one we saw was
	 handled in the first part of this if-then-else clause, and at that
	 time start_paragraph () was called, partially to handle the proper
	 indentation of the current line.  However, the indentation level
	 may have just changed again, so we may have to outdent the current
	 line to the new indentation level. */
d3020 1
a3020 1
	kill_self_indent (output_column - current_indent);
d3052 3
a3054 3
	 subsequent characters to be newlines.  This isn't strictly
	 necessary, but a couple of functions use the presence of a newline
	 to make decisions. */
d3056 2
a3057 2
	{
	  c = output_paragraph[tindex];
d3059 5
a3063 5
	  if (c == ' '|| c == '\n')
	    output_paragraph[tindex] = '\n';
	  else
	    break;
	}
d3070 1
a3070 1
	insert ('\n');
d3072 1
a3072 1
      /* Add as many blank lines as is specified in PARAGRAPH_SPACING. */
d3074 4
a3077 4
	{
	  for (i = 0; i < (paragraph_spacing - line_already_broken); i++)
	    insert ('\n');
	}
d3080 1
a3080 1
	 on the paragraph (really a single line). */
d3082 1
a3082 1
	do_flush_right_indentation ();
d3111 1
a3111 1
      output_paragraph[output_paragraph_offset] = '\0';
d3114 2
a3115 2
	{
	  register int i;
d3117 16
a3132 16
	  if (fill_column >= paragraph_buffer_len)
	    output_paragraph =
	      xrealloc (output_paragraph,
			(paragraph_buffer_len += fill_column));

	  temp_len = strlen ((char *)output_paragraph);
	  temp = (char *)xmalloc (temp_len + 1);
	  memcpy (temp, (char *)output_paragraph, temp_len);

	  for (i = 0; i < fill_column - output_paragraph_offset; i++)
	    output_paragraph[i] = ' ';

	  memcpy ((char *)output_paragraph + i, temp, temp_len);
	  free (temp);
	  output_paragraph_offset = fill_column;
	}
d3159 19
a3177 19
	{
	  if (inhibit_paragraph_indentation)
	    {
	      amount_to_indent = current_indent;
	      if (inhibit_paragraph_indentation < 0)
		inhibit_paragraph_indentation++;
	    }
	  else if (paragraph_start_indent < 0)
	    amount_to_indent = current_indent;
	  else
	    amount_to_indent = current_indent + paragraph_start_indent;

	  if (amount_to_indent >= output_column)
	    {
	      amount_to_indent -= output_column;
	      indent (amount_to_indent);
	      output_column += amount_to_indent;
	    }
	}
d3195 1
a3195 1
	elt->pos += amount;
d3215 1
a3215 1
	return (from);
d3237 1
a3237 1
	return (0);
d3243 1
a3243 1
	return (ch1 - ch2);
d3280 14
a3293 12
	{
	case ifinfo:
	case ifset:
	case ifclear:
	case cartouche:
	  elt = elt->next;
	  level--;
	  break;

	default:
	  done = 1;
	}
a3307 1
  canon_white (item_function);
d3324 1
a3324 1
  new->filename = strdup (input_filename);
d3362 1
a3362 1
    return ("Broken-Type in insertion_type_pname");
d3375 1
a3375 1
	return (enum insertion_type) index;
d3428 1
a3428 1
      line_error ("Enumeration stack overflow");
d3458 4
a3461 4
	{
	  current_enumval = ((current_enumval - 1) == 'z' ? 'a' : 'A');
	  warning ("Lettering overflow, restarting at %c", current_enumval);
	}
d3483 1
a3483 1
      push_insertion (type, strdup (""));
d3493 1
a3493 1
	close_paragraph ();
d3499 1
a3499 1
	add_word ("* Menu:\n");
a3505 1

d3507 3
a3509 3
	{
	  if (!no_headers)
	    close_paragraph ();
d3511 2
a3512 2
	  filling_enabled = no_indent = 0;
	  inhibit_paragraph_indentation = 1;
d3514 2
a3515 2
	  no_discard++;
	}
d3528 1
a3528 1
	 If you don't want filling, then use @@display. */
a3543 1

a3548 1

d3550 1
a3550 2
	current_indent += default_indentation_increment;

d3572 8
a3579 8
	{
	  if (!(*insertion_stack->item_function))
	    {
	      free (insertion_stack->item_function);
	      insertion_stack->item_function = strdup ("@@bullet");
	      insertion_stack->item_function[0] = COMMAND_PREFIX;
	    }
	}
d3582 4
a3585 4
	{
	  line_error ("%s requires an argument: the formatter for %citem",
		      insertion_type_pname (type), COMMAND_PREFIX);
	}
d3601 1
a3601 1
	start_enumerating (atoi (enumeration_arg), ENUM_DIGITS);
d3603 1
a3603 1
	start_enumerating (*enumeration_arg, ENUM_ALPHA);
d3610 2
a3611 2
	  insertion_stack->next->insertion != example)
	close_single_paragraph ();
d3616 2
d3622 1
a3622 1
	no_discard++;
d3666 4
a3669 5
/* Try to end the insertion with the specified TYPE.
   TYPE, with a value of bad_type,  gets translated to match
   the value currently on top of the stack.
   Otherwise, if TYPE doesn't match the top of the insertion stack,
   give error. */
d3687 2
a3688 2
	("`%cend' expected `%s', but saw `%s'", COMMAND_PREFIX,
	 insertion_type_pname (temp_type), insertion_type_pname (type));
d3697 2
d3710 1
a3710 1
      in_detailmenu--;		/* No longer hacking menus. */
d3712 4
a3715 4
	{
	  if (!no_headers)
	    close_insertion_paragraph ();
	}
d3719 1
a3719 1
      in_menu--;		/* No longer hacking menus. */
d3721 1
a3721 1
	close_insertion_paragraph ();
a3746 1

d3748 1
a3748 1
	 in indentation. */
d3750 1
a3750 1
	current_indent -= default_indentation_increment;
d3753 1
a3753 1
	 start of a new paragraph. */
d3778 1
a3778 1
   code that creates such boundaries, you should call discard_insertions ()
d3780 2
a3781 1
   the insertion stack. */
d3783 2
a3784 1
discard_insertions ()
d3789 4
a3792 4
      if (insertion_stack->insertion == ifinfo ||
	  insertion_stack->insertion == ifset ||
	  insertion_stack->insertion == ifclear)
	break;
d3794 10
a3803 13
	{
	  char *offender;
	  char *current_filename;

	  current_filename = input_filename;
	  offender = (char *)insertion_type_pname (insertion_stack->insertion);
	  input_filename = insertion_stack->filename;
	  line_number = insertion_stack->line_number;
	  line_error ("This `%s' doesn't have a matching `%cend %s'", offender,
		      COMMAND_PREFIX, offender);
	  input_filename = current_filename;
	  pop_insertion ();
	}
a3831 1
#if !defined (ASTERISK_NEW_PARAGRAPH)
a3832 1
#endif /* ASTERISK_NEW_PARAGRAPH */
d3939 1
a3939 1
        fprintf (stderr, "How did @@%s end up in cm_special_char?\n", command);
d3953 1
a3953 1
        line_error ("%c%s expects `i' or `j' as argument, not `%c'",
d3957 2
a3958 2
        line_error ("%c%s expects a single character `i' or `j' as argument",
		    COMMAND_PREFIX, command);
a3963 6
#if defined (__osf__)
#define LOCALTIME_CAST(x) (time_t *)(x)
#else
#define LOCALTIME_CAST(x) (x)
#endif

d3968 4
a3971 3
  static char * months [12] =
    { "January", "February", "March", "April", "May", "June", "July",
	"August", "September", "October", "November", "December" };
d3974 4
a3977 7
      long timer = time (0);
      struct tm *ts = localtime (LOCALTIME_CAST (&timer));
      add_word_args
	("%d %s %d",
	 (ts -> tm_mday),
	 (months [ts -> tm_mon]),
	 ((ts -> tm_year) + 1900));
d3992 1
a3992 1
	add_char ('`');
d3997 1
a3997 1
	add_char ('\'');
d4012 1
a4012 1
cm_angle_brackets (arg)
d4029 2
a4030 2
	line_error ("%c%s expects a single character as an argument",
		    COMMAND_PREFIX, command);
d4033 7
a4039 7
	for (i = start; i < end; i++)
	  {
	    character = output_paragraph[i];

	    if (isletter (character))
	      output_paragraph[i] = CTL (coerce_to_upper (character));
	  }
d4052 1
a4052 1
/* Small caps in makeinfo has to do just all caps. */
d4054 1
a4054 1
cm_sc (arg, start_pos, end_pos)
d4062 5
a4066 23
	{
	  output_paragraph[start_pos] =
	    coerce_to_upper (output_paragraph[start_pos]);
	  start_pos++;
	}
    }
}

/* @@var in makeinfo just uppercases the text. */
void
cm_var (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  not_fixed_width (arg);

  if (arg == END)
    {
      while (start_pos < end_pos)
	{
	  output_paragraph[start_pos] =
	    coerce_to_upper (output_paragraph[start_pos]);
	  start_pos++;
	}
d4109 1
a4109 1
/* Various commands are NOP's. */
d4115 9
d4143 1
a4143 1
    warning ("The command `%c%s' is obsolete", COMMAND_PREFIX, command);
d4173 1
a4173 3
      char *temp1;

      temp1 = (char *)xmalloc (2 + strlen (temp));
d4181 1
a4181 1
  execute_string ("%s\n", temp);
d4270 1
a4270 1
  for (i = 0; t = section_alist[i].name; i++)
d4273 2
a4274 2
	{
	  int return_val;
d4276 1
a4276 1
	  return_val = (section_alist[i].level + section_alist_offset);
d4278 6
a4283 6
	  if (return_val < 0)
	    return_val = 0;
	  else if (return_val > 5)
	    return_val = 5;
	  return (return_val);
	}
d4298 3
a4300 3
	result = section_alist[i].level;
	section_alist[i].level = level;
	break;
d4315 2
a4316 2
      line_error ("There already is a node having %ctop as a section",
		  COMMAND_PREFIX);
d4319 15
a4333 15
	{
	  if ((tag->flags & IS_TOP))
	    {
	      int old_line_number = line_number;
	      char *old_input_filename = input_filename;

	      line_number = tag->line_no;
	      input_filename = tag->filename;
	      line_error ("Here is the %ctop node", COMMAND_PREFIX);
	      input_filename = old_input_filename;
	      line_number = old_line_number;
	      return;
	    }
	  tag = tag->next_ent;
	}
d4341 2
a4342 2
	{
	  char *top_name;
d4344 7
a4350 7
	  get_rest_of_line (&top_name);
	  free (top_name);
	  line_error ("%ctop used before %cnode, defaulting to %s",
		      COMMAND_PREFIX, COMMAND_PREFIX, top_name);
	  execute_string ("@@node Top, , (dir), (dir)\n@@top %s\n", top_name);
	  return;
	}
d4359 1
a4359 1
	int orig_offset = input_text_offset;
d4361 1
a4361 1
	input_text_offset = search_forward (node_search_string, orig_offset);
d4363 3
a4365 3
	if (input_text_offset > 0)
	  {
	    int this_section;
d4367 2
a4368 2
	    /* We have encountered a non-top node, so mark that one exists. */
	    non_top_node_seen = 1;
d4370 4
a4373 4
	    /* Move to the end of this line, and find out what the
	       sectioning command is here. */
	    while (input_text[input_text_offset] != '\n')
	      input_text_offset++;
d4375 2
a4376 2
	    if (input_text_offset < size_of_input_text)
	      input_text_offset++;
d4378 1
a4378 1
	    this_section = what_section (input_text + input_text_offset);
d4380 6
a4385 6
	    /* If we found a sectioning command, then give the top section
	       a level of this section - 1. */
	    if (this_section != -1)
	      set_top_section_level (this_section - 1);
	  }
	input_text_offset = orig_offset;
d4421 2
a4422 2
  warning ("The command `%c%s' is obsolete; use `%c%s' instead",
	   COMMAND_PREFIX, command, COMMAND_PREFIX, command + 1);
d4545 3
a4547 3
/*								    */
/*		   Adding nodes, and making tags		    */
/*								    */
d4569 1
a4569 1
  write_tag_table_internal (0);	/* Not indirect. */
d4613 2
a4614 1
get_node_token ()
d4618 1
a4618 1
  get_until_in_line (",", &string);
d4651 1
a4651 1
	return (tag);
d4668 6
a4673 5
	{
	  line_error ("Node `%s' multiply defined (%d is first definition)",
		      node, tag->line_no);
	  return;
	}
d4689 1
a4689 1
    new->touched = 0;		/* not yet referenced. */
d4719 1
a4719 1
  discard_insertions ();
d4737 4
a4740 4
  node = get_node_token ();
  next = get_node_token ();
  prev = get_node_token ();
  up = get_node_token ();
d4742 3
d4757 1
a4757 1
	me_execute_string (node);
d4760 1
a4760 1
      execute_string ("%s", node);
d4765 1
a4765 3
  defaulting = ((strlen (next) == 0) &&
		(strlen (prev) == 0) &&
		(strlen (up) == 0));
d4780 15
a4794 15
	{
	  char *polite_section_name = "top";
	  int i;

	  for (i = 0; section_alist[i].name; i++)
	    if (section_alist[i].level == current_section + 1)
	      {
		polite_section_name = section_alist[i].name;
		break;
	      }

	  line_error
	    ("Node `%s' requires a sectioning command (e.g. %c%s)",
	     node, COMMAND_PREFIX, polite_section_name);
	}
d4796 72
a4867 72
	{
	  if (strcmp (node, "Top") == 0)
	    {
	      /* Default the NEXT pointer to be the first menu item in
		 this node, if there is a menu in this node.  We have to
		 try very hard to find the menu, as it may be obscured
		 by execution_strings which are on the filestack.  For
		 every member of the filestack which has a FILENAME
		 member which is identical to the current INPUT_FILENAME,
		 search forward from that offset. */
	      int saved_input_text_offset = input_text_offset;
	      int saved_size_of_input_text = size_of_input_text;
	      char *saved_input_text = input_text;
	      FSTACK *next_file = filestack;

	      int orig_offset, orig_size;
	      char *glean_node_from_menu ();

	      /* No matter what, make this file point back at `(dir)'. */
	      free (up);   up = strdup ("(dir)");

	      while (1)
		{
		  orig_offset = input_text_offset;
		  orig_size =
		    search_forward (node_search_string, orig_offset);

		  if (orig_size < 0)
		    orig_size = size_of_input_text;

		  input_text_offset =
		    search_forward (menu_search_string, orig_offset);

		  if (input_text_offset > -1)
		    {
		      char *nodename_from_menu = (char *)NULL;

		      input_text_offset =
			search_forward ("\n* ", input_text_offset);

		      if (input_text_offset != -1)
			nodename_from_menu = glean_node_from_menu (0);

		      if (nodename_from_menu)
			{
			  free (next); next = nodename_from_menu;
			  break;
			}
		    }

		  /* We got here, so it hasn't been found yet.  Try
		     the next file on the filestack if there is one. */
		  if (next_file &&
		      (strcmp (next_file->filename, input_filename) == 0))
		    {
		      input_text = next_file->text;
		      input_text_offset = next_file->offset;
		      size_of_input_text = next_file->size;
		      next_file = next_file->next;
		    }
		  else
		    {
		      /* No more input files to check. */
		      break;
		    }
		}

	      input_text = saved_input_text;
	      input_text_offset = saved_input_text_offset;
	      size_of_input_text = saved_size_of_input_text;
	    }
	}
d4870 1
a4870 1
	 was declared with @@top, and no subsequent reference was found. */
d4872 3
a4874 13
	{
	  /* Then this is the first non-@@top node seen. */
	  int level;

	  level = set_top_section_level (this_section - 1);
	  non_top_node_seen = 1;

	  while (ref)
	    {
	      if (ref->section == level)
		ref->section = this_section - 1;
	      ref = ref->next;
	    }
d4876 12
a4887 2
	  ref = node_references;
	}
d4890 42
a4931 42
	{
	  if (ref->section == (this_section - 1) &&
	      ref->type == menu_reference &&
	      strcmp (ref->node, node) == 0)
	    {
	      char *containing_node = ref->containing_node;

	      free (up);
	      up = strdup (containing_node);

	      if (last_ref &&
		  last_ref->type == menu_reference &&
		  (strcmp (last_ref->containing_node,
			   containing_node) == 0))
		{
		  free (next);
		  next = strdup (last_ref->node);
		}

	      while ((ref->section == this_section - 1) &&
		     (ref->next) &&
		     (ref->next->type != menu_reference))
		ref = ref->next;

	      if (ref->next && ref->type == menu_reference &&
		  (strcmp (ref->next->containing_node,
			   containing_node) == 0))
		{
		  free (prev);
		  prev = strdup (ref->next->node);
		}
	      else if (!ref->next &&
		       strcasecmp (ref->containing_node, "Top") == 0)
		{
		  free (prev);
		  prev = strdup (ref->containing_node);
		}
	      break;
	    }
	  last_ref = ref;
	  ref = ref->next;
	}
d4965 1
a4965 1
	me_inhibit_expansion++;
d4969 4
a4972 4
	{
	  execute_string (",  Next: %s", next);
	  filling_enabled = indented_fill = 0;
	}
d4975 4
a4978 4
	{
	  execute_string (",  Prev: %s", prev);
	  filling_enabled = indented_fill = 0;
	}
d4981 4
a4984 4
	{
	  execute_string (",  Up: %s", up);
	  filling_enabled = indented_fill = 0;
	}
d4987 1
a4987 1
	me_inhibit_expansion--;
d4997 1
a4997 1
		  COMMAND_PREFIX, command);
d5048 4
a5051 4
	{
	  tags = tags->next_ent;
	  continue;
	}
d5055 2
a5056 2
	{
	  validate (tags->next, tags->line_no, "Next");
d5058 31
a5088 30
	  /* If the Next node exists, and there is no Up, then make
	     sure that the Prev of the Next points back. */
	  if (temp_tag = find_node (tags->next))
	    {
	      char *prev;

	      if (temp_tag->flags & NO_WARN)
		{
		  /* Do nothing if we aren't supposed to issue warnings
		     about this node. */
		}
	      else
		{
		  prev = temp_tag->prev;
		  if (!prev || (strcmp (prev, tags->node) != 0))
		    {
		      line_error ("Node `%s''s Next field not pointed back to",
				  tags->node);
		      line_number = temp_tag->line_no;
		      input_filename = temp_tag->filename;
		      line_error
			("This node (`%s') is the one with the bad `Prev'",
			 temp_tag->node);
		      input_filename = tags->filename;
		      line_number = tags->line_no;
		      temp_tag->flags |= PREV_ERROR;
		    }
		}
	    }
	}
d5091 2
a5092 2
	 complained about it in some way.  You don't have to have a Prev
	 field at this stage. */
d5094 2
a5095 2
	{
	  int valid = validate (tags->prev, tags->line_no, "Prev");
d5097 37
a5133 38
	  if (!valid)
	    tags->flags |= PREV_ERROR;
	  else
	    {
	      /* If the Prev field is not the same as the Up field,
		 then the node pointed to by the Prev field must have
		 a Next field which points to this node. */
	      if (tags->up && (strcmp (tags->prev, tags->up) != 0))
		{
		  temp_tag = find_node (tags->prev);

		  /* If we aren't supposed to issue warnings about the
		     target node, do nothing. */
		  if (!temp_tag || (temp_tag->flags & NO_WARN))
		    {
		      /* Do nothing. */
		    }
		  else
		    {
		      if (!temp_tag->next ||
			  (strcmp (temp_tag->next, tags->node) != 0))
			{
			  line_error
			    ("Node `%s''s Prev field not pointed back to",
			     tags->node);
			  line_number = temp_tag->line_no;
			  input_filename = temp_tag->filename;
			  line_error
			    ("This node (`%s') is the one with the bad `Next'",
			     temp_tag->node);
			  input_filename = tags->filename;
			  line_number = tags->line_no;
			  temp_tag->flags |= NEXT_ERROR;
			}
		    }
		}
	    }
	}
d5135 2
a5136 2
      if (!tags->up && (strcasecmp (tags->node, "Top") != 0))
	line_error ("Node `%s' is missing an \"Up\" field", tags->node);
d5138 2
a5139 2
	{
	  int valid = validate (tags->up, tags->line_no, "Up");
d5141 42
a5182 42
	  /* If node X has Up: Y, then warn if Y fails to have a menu item
	     or note pointing at X, if Y isn't of the form "(Y)". */
	  if (valid && *tags->up != '(')
	    {
	      NODE_REF *nref, *tref, *list;
	      NODE_REF *find_node_reference ();

	      tref = (NODE_REF *) NULL;
	      list = node_references;

	      for (;;)
		{
		  if (!(nref = find_node_reference (tags->node, list)))
		    break;

		  if (strcmp (nref->containing_node, tags->up) == 0)
		    {
		      if (nref->type != menu_reference)
			{
			  tref = nref;
			  list = nref->next;
			}
		      else
			break;
		    }
		  list = nref->next;
		}

	      if (!nref)
		{
		  temp_tag = find_node (tags->up);
		  line_number = temp_tag->line_no;
		  input_filename = temp_tag->filename;
		  if (!tref)
		    line_error (
"`%s' has an Up field of `%s', but `%s' has no menu item for `%s'",
				tags->node, tags->up, tags->up, tags->node);
		  line_number = tags->line_no;
		  input_filename = tags->filename;
		}
	    }
	}
d5195 4
a5198 4
	{
	  tags = tags->next_ent;
	  continue;
	}
d5204 6
a5209 6
	{
	  input_filename = tags->filename;
	  line_number = tags->line_no;
	  warning ("Node `%s' has been referenced %d times",
		   tags->node, tags->touched);
	}
d5212 9
a5220 9
	{
	  input_filename = tags->filename;
	  line_number = tags->line_no;

	  /* Notice that the node "Top" is special, and doesn't have to
	     be referenced. */
	  if (strcasecmp (tags->node, "Top") != 0)
	    warning ("Unreferenced node `%s'", tags->node);
	}
d5246 1
a5246 3
      line_error (
"Validation error.  `%s' field points to node `%s', which doesn't exist",
		  label, tag);
d5290 1
a5290 1
    root_pathname = strdup ("");
d5309 1
a5309 1
	int file_top, file_bot, limit;
d5311 114
a5424 114
	/* Have to include the Control-_. */
	file_top = file_bot = tags->position;
	limit = file_top + size;

	/* If the rest of this file is only one node, then
	   that is the entire subfile. */
	if (!tags->next_ent)
	  {
	    int i = tags->position + 1;
	    char last_char = the_file[i];

	    while (i < file_size)
	      {
		if ((the_file[i] == '\037') &&
		    ((last_char == '\n') ||
		     (last_char == '\014')))
		  break;
		else
		  last_char = the_file[i];
		i++;
	      }
	    file_bot = i;
	    tags = tags->next_ent;
	    goto write_region;
	  }

	/* Otherwise, find the largest number of nodes that can fit in
	   this subfile. */
	for (; tags; tags = tags->next_ent)
	  {
	    if (!tags->next_ent)
	      {
		/* This entry is the last node.  Search forward for the end
	           of this node, and that is the end of this file. */
		int i = tags->position + 1;
		char last_char = the_file[i];

		while (i < file_size)
		  {
		    if ((the_file[i] == '\037') &&
			((last_char == '\n') ||
			 (last_char == '\014')))
		      break;
		    else
		      last_char = the_file[i];
		    i++;
		  }
		file_bot = i;

		if (file_bot < limit)
		  {
		    tags = tags->next_ent;
		    goto write_region;
		  }
		else
		  {
		    /* Here we want to write out everything before the last
		       node, and then write the last node out in a file
		       by itself. */
		    file_bot = tags->position;
		    goto write_region;
		  }
	      }

	    if (tags->next_ent->position > limit)
	      {
		if (tags->position == file_top)
		  tags = tags->next_ent;

		file_bot = tags->position;

	      write_region:
		{
		  int fd;
		  char *split_filename;

		  split_filename = (char *) xmalloc
		    (10 + strlen (root_pathname) + strlen (root_filename));
		  sprintf
		    (split_filename,
		     "%s%s-%d", root_pathname, root_filename, which_file);

		  fd = open
		    (split_filename, O_WRONLY | O_TRUNC | O_CREAT, 0666);

		  if ((fd < 0) ||
		      (write (fd, the_header, header_size) != header_size) ||
		      (write (fd, the_file + file_top, file_bot - file_top)
		       != (file_bot - file_top)) ||
		      ((close (fd)) < 0))
		    {
		      perror (split_filename);
		      if (fd != -1)
			close (fd);
		      exit (FATAL);
		    }

		  if (!indirect_info)
		    {
		      indirect_info = the_file + file_top;
		      sprintf (indirect_info, "\037\nIndirect:\n");
		      indirect_info += strlen (indirect_info);
		    }

		  sprintf (indirect_info, "%s-%d: %d\n",
			   root_filename, which_file, file_top);

		  free (split_filename);
		  indirect_info += strlen (indirect_info);
		  which_file++;
		  break;
		}
	      }
	  }
d5433 2
a5434 2
	perror (filename);
	exit (FATAL);
d5453 2
a5454 4
/* Some menu hacking.  This is used to remember menu references while
   reading the input file.  After the output file has been written, if
   validation is on, then we use the contents of NODE_REFERENCES as a
   list of nodes to validate. */
d5464 1
a5464 1
      return ("Followed-Reference");
d5470 4
a5473 1
/* Remember this node name for later validation use. */
d5483 1
a5483 1
  temp->node = strdup (node);
d5487 1
a5487 1
  temp->containing_node = strdup (current_node ? current_node : "");
d5503 1
a5503 1
		reftype_type_string (ref_list->type));
d5518 1
a5518 1
	break;
d5555 2
a5556 2
	       menu_starter,
	       strlen (menu_starter)) != 0)
d5561 1
a5561 1
  get_until_in_line (":", &nodename);
d5587 1
a5587 1
    nodename[i - 1] = '\0';
d5614 1
a5614 1
      *nodename = '\0';
d5625 1
a5625 1
  for (; c = nodename[i]; i++)
d5628 5
a5632 5
	{
	  if (c == '(')
	    paren++;
	  else if (c == ')')
	    paren--;
d5634 2
a5635 2
	  continue;
	}
d5638 1
a5638 1
	 node has no more characters associated with it. */
d5640 9
a5648 9
	  c == '\n' ||
	  c == ','  ||
	  ((paren_seen && nodename[i - 1] == ')') &&
	   (c == ' ' || c == '.')) ||
	  (c == '.' &&
	   ((!nodename[i + 1] ||
	     (cr_or_whitespace (nodename[i + 1])) ||
	     (nodename[i + 1] == ')')))))
	break;
d5650 1
a5650 1
  nodename[i] = '\0';
d5658 2
a5659 2
      warning ("%cmenu seen before a node has been defined", COMMAND_PREFIX);
      warning ("Creating `TOP' node.");
d5670 2
a5671 2
      warning ("%cmenu seen before a node has been defined", COMMAND_PREFIX);
      warning ("Creating `TOP' node.");
d5678 3
a5680 3
/*								    */
/*			Cross Reference Hacking			    */
/*								    */
d5683 2
d5697 1
a5697 1
int px_ref_flag = 0;		/* Controls initial output string. */
d5716 2
a5717 2
	{
	  char *node_name;
d5719 19
a5737 19
	  if (!*arg2)
	    {
	      if (*arg3)
		node_name = arg3;
	      else
		node_name = arg1;
	    }
	  else
	    node_name = arg2;

	  execute_string ("%s: (%s)%s", node_name, arg4, arg1);
	  /* Free all of the arguments found. */
	  if (arg1) free (arg1);
	  if (arg2) free (arg2);
	  if (arg3) free (arg3);
	  if (arg4) free (arg4);
	  if (arg5) free (arg5);
	  return;
	}
d5739 1
a5739 1
	remember_node_reference (arg1, line_number, followed_reference);
d5742 6
a5747 6
	{
	  if (!*arg2)
	    execute_string ("%s: %s", arg3, arg1);
	  else
	    execute_string ("%s: %s", arg2, arg1);
	}
d5749 6
a5754 6
	{
	  if (*arg2)
	    execute_string ("%s: %s", arg2, arg1);
	  else
	    execute_string ("%s::", arg1);
	}
d5771 2
a5772 2
	  output_paragraph[output_paragraph_offset - 1] == ':')
	return;
d5774 16
a5789 17
	{
	  if (cr_or_whitespace (input_text[temp]))
	    temp++;
	  else
	    {
	      if (input_text[temp] == '.' ||
		  input_text[temp] == ',' ||
		  input_text[temp] == '\t')
		return;
	      else
		{
		  line_error (
		"Cross-reference must be terminated with a period or a comma");
		  return;
		}
	    }
	}
d5813 89
a5901 1
      char *node, *pname, *file;
d5903 54
a5956 3
      node = get_xref_token ();
      pname = get_xref_token ();
      file = get_xref_token ();
d5958 1
a5958 1
      execute_string ("*note %s: (%s)%s", pname, file, node);
d5963 3
a5965 3
/*								    */
/*			Insertion Command Stubs			    */
/*								    */
d5999 1
a5999 1
   TeX output.  Right now, just a NOP insertion. */
d6046 1
a6046 1
  get_until_in_line (".", &enumeration_arg);
d6052 1
a6052 1
      enumeration_arg = strdup (default_string);
d6057 1
a6057 1
      warning ("%s requires a letter or a digit", insertion_type_pname (type));
d6060 6
a6065 6
	{
	case enumerate:
	  default_string = "1";
	  break;
	}
      enumeration_arg = strdup (default_string);
d6079 1
a6079 1
  begin_insertion (multitable);	/* @@@@ */
d6106 12
d6132 29
d6163 3
a6165 3
/*								    */
/*			  Conditional Handling			    */
/*								    */
d6189 3
a6191 3
	free (temp->value);
	temp->value = strdup (value);
	return;
d6196 2
a6197 2
  temp->name = strdup (name);
  temp->value = strdup (value);
d6214 11
a6224 11
	{
	  if (last)
	    last->next = temp->next;
	  else
	    defines = temp->next;

	  free (temp->name);
	  free (temp->value);
	  free (temp);
	  break;
	}
a6293 1
  register int i;
d6301 5
a6305 5
	{
	  if ((strcasecmp (arglist[0], arglist[1]) == 0) &&
	      (arglist[2] != (char *)NULL))
	    execute_string ("%s\n", arglist[2]);
	}
d6318 3
a6320 3
      name = (char *)&output_paragraph[start_pos];
      output_paragraph[end_pos] = '\0';
      name = strdup (name);
d6328 1
a6328 1
	add_word_args ("{No Value For \"%s\"}", name);
a6342 1
  canon_white (name);
d6362 6
a6367 6
	{
	  if (*temp == delimiter)
	    delimiter = 0;
	  else
	    delimiter = *temp;
	}
d6375 1
a6375 1
  *temp = '\0';
d6378 1
a6378 1
    line_error ("%c%s requires a name", COMMAND_PREFIX, command);
d6382 4
a6385 4
	{
	case SET:
	  {
	    char *value;
d6388 2
a6389 2
	    /* Allow a value to be saved along with a variable.  The value is
	       the text following an `=' sign in NAME, if any is present. */
d6391 1
a6391 1
	    for (value = name; *value && *value != '='; value++);
d6393 2
a6394 2
	    if (*value)
	      *value++ = '\0';
d6396 5
a6400 5
	    if (*value == '"' || *value == '\'')
	      {
		value++;
		value[strlen (value) - 1] = '\0';
	      }
d6403 9
a6411 9
	    /* The VALUE of NAME is the remainder of the line sans
	       whitespace. */
	    if (additional_text_present)
	      {
		value = temp + 1;
		canon_white (value);
	      }
	    else
	      value = "";
d6414 92
a6505 81
	    set (name, value);
	  }
	  break;

	case CLEAR:
	  clear (name);
	  break;

	case IFSET:
	case IFCLEAR:
	  /* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,
	     read lines from the the file until we reach a matching
	     "@@end CONDITION".  This means that we only take note of
	     "@@ifset/clear" and "@@end" commands. */
	  {
	    char condition[8];
	    int condition_len;

	    if (action == IFSET)
	      strcpy (condition, "ifset");
	    else
	      strcpy (condition, "ifclear");

	    condition_len = strlen (condition);

	  if ((action == IFSET && !set_p (name)) ||
	      (action == IFCLEAR && set_p (name)))
	    {
	      int level = 0, done = 0;

	      while (!done)
		{
		  char *freeable_line, *line;

		  get_rest_of_line (&freeable_line);

		  for (line = freeable_line; whitespace (*line); line++);

		  if (*line == COMMAND_PREFIX &&
		      (strncmp (line + 1, condition, condition_len) == 0))
		    level++;
		  else if (strncmp (line, "@@end", 4) == 0)
		    {
		      char *cname = line + 4;
		      char *temp;

		      while (*cname && whitespace (*cname))
			cname++;
		      temp = cname;

		      while (*temp && !whitespace (*temp))
			temp++;
		      *temp = '\0';

		      if (strcmp (cname, condition) == 0)
			{
			  if (!level)
			    {
			      done = 1;
			    }
			  else
			    level--;
			}
		    }
		  free (freeable_line);
		}
	      /* We found the end of a false @@ifset/ifclear.  If we are
		 in a menu, back up over the newline that ends the ifset,
		 since that newline may also begin the next menu entry. */
	      break;
	    }
	  else
	    {
	      if (action == IFSET)
		begin_insertion (ifset);
	      else
		begin_insertion (ifclear);
	    }
	  }
	  break;
	}
d6512 3
a6514 3
  char *string;			/* The string buffer. */
  int size;			/* The size of the buffer. */
  int in_use;			/* Non-zero means string currently in use. */
d6531 5
a6535 5
	if (execution_strings[i] && (execution_strings[i]->in_use == 0))
	  {
	    es = execution_strings[i];
	    break;
	  }
d6541 7
a6547 7
	{
	  execution_strings = (EXECUTION_STRING **)xrealloc
	    (execution_strings,
	     (execution_strings_slots += 3) * sizeof (EXECUTION_STRING *));
	  for (; i < execution_strings_slots; i++)
	    execution_strings[i] = (EXECUTION_STRING *)NULL;
	}
d6550 1
a6550 1
	(EXECUTION_STRING *)xmalloc (sizeof (EXECUTION_STRING));
d6559 7
a6565 30
  if (initial_size > es->size)
    {
      es->string = (char *) xrealloc (es->string, initial_size);
      es->size = initial_size;
    }
  return (es);
}

/* Execute the string produced by formatting the ARGs with FORMAT.  This
   is like submitting a new file with @@include. */
#if defined (HAVE_VARARGS_H) && defined (HAVE_VSPRINTF)
void
execute_string (va_alist)
     va_dcl
{
  EXECUTION_STRING *es;
  char *temp_string;
  char *format;
  va_list args;

  es = get_execution_string (4000);
  temp_string = es->string;
  es->in_use = 1;

  va_start (args);
  format = va_arg (args, char *);
  vsprintf (temp_string, format, args);
  va_end (args);

#else /* !(HAVE_VARARGS_H && HAVE_VSPRINTF) */
d6567 2
d6570 7
a6576 2
execute_string (format, arg1, arg2, arg3, arg4, arg5)
     char *format;
d6580 3
d6588 7
a6594 3
  sprintf (temp_string, format, arg1, arg2, arg3, arg4, arg5);

#endif /* !(HAVE_VARARGS_H && HAVE_VSPRINTF) */
d6599 1
a6599 1
  input_filename = strdup (input_filename);
d6626 1
d6629 2
d6632 1
a6674 1
      canon_white (rest_of_line);
d6678 1
a6678 1
	 is active. */
d6682 113
a6794 106
	{
	case multitable:
	  multitable_item ();
	  /* Ultra special hack.  It appears that some people incorrectly
	     place text directly after the @@item, instead of on a new line
	     by itself.  This happens to work in TeX, so I make it work
	     here. */
	  if (*rest_of_line)
	    {
	      line_number--;
	      input_text_offset = original_input_text_offset;
	    }
	  break;

	case ifinfo:
	case ifset:
	case ifclear:
	case cartouche:
	  stack = stack->next;
	  if (!stack)
	    goto no_insertion;
	  else
	    goto switch_top;
	  break;

	case menu:
	case quotation:
	case example:
	case smallexample:
	case lisp:
	case format:
	case display:
	case group:
	  line_error ("The `%c%s' command is meaningless within a `@@%s' block",
		      COMMAND_PREFIX, command,
		      insertion_type_pname (current_insertion_type ()));
	  break;

	case itemize:
	case enumerate:
	  if (itemx_flag)
	    {
	      line_error ("%citemx is not meaningful inside of a `%s' block",
			  COMMAND_PREFIX,
			  insertion_type_pname (current_insertion_type ()));
	    }
	  else
	    {
	      start_paragraph ();
	      kill_self_indent (-1);
	      filling_enabled = indented_fill = 1;

	      if (current_insertion_type () == itemize)
		{
		  indent (output_column = current_indent - 2);

		  /* I need some way to determine whether this command
		     takes braces or not.  I believe the user can type
		     either "@@bullet" or "@@bullet{}".  Of course, they
		     can also type "o" or "#" or whatever else they want. */
		  if (item_func && *item_func)
		    {
		      if (*item_func == COMMAND_PREFIX)
			if (item_func[strlen (item_func) - 1] != '}')
			  execute_string ("%s{}", item_func);
			else
			  execute_string ("%s", item_func);
		      else
			execute_string ("%s", item_func);
		    }
		  insert (' ');
		  output_column++;
		}
	      else
		enumerate_item ();

	      /* Special hack.  This makes close paragraph ignore you until
		 the start_paragraph () function has been called. */
	      must_start_paragraph = 1;

	      /* Ultra special hack.  It appears that some people incorrectly
		 place text directly after the @@item, instead of on a new line
		 by itself.  This happens to work in TeX, so I make it work
		 here. */
	      if (*rest_of_line)
		{
		  line_number--;
		  input_text_offset = original_input_text_offset;
		}
	    }
	  break;

	case table:
	case ftable:
	case vtable:
	  {
	    /* Get rid of extra characters. */
	    kill_self_indent (-1);

	    /* close_paragraph () almost does what we want.  The problem
	       is when paragraph_is_open, and last_char_was_newline, and
	       the last newline has been turned into a space, because
	       filling_enabled. I handle it here. */
	    if (last_char_was_newline && filling_enabled && paragraph_is_open)
	      insert ('\n');
	    close_paragraph ();
d6797 9
a6805 11
	    /* Indent on a new line, but back up one indentation level. */
	    {
	      int t;

	      t = inhibit_paragraph_indentation;
	      inhibit_paragraph_indentation = 1;
	      /* At this point, inserting any non-whitespace character will
		 force the existing indentation to be output. */
	      add_char ('i');
	      inhibit_paragraph_indentation = t;
	    }
d6807 1
a6807 1
	    add_char ('i');
d6810 2
a6811 2
	    output_paragraph_offset--;
	    kill_self_indent (default_indentation_increment + 1);
d6813 19
a6831 19
	    /* Add item's argument to the line. */
	    filling_enabled = 0;
	    if (item_func && *item_func)
 	      execute_string ("%s{%s}", item_func, rest_of_line);
 	    else
 	      execute_string ("%s", rest_of_line);

	    if (current_insertion_type () == ftable)
	      execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);

	    if (current_insertion_type () == vtable)
	      execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

	    /* Start a new line, and let start_paragraph ()
	       do the indenting of it for you. */
	    close_single_paragraph ();
	    indented_fill = filling_enabled = 1;
	  }
	}
d6837 2
a6838 2
      line_error ("%c%s found outside of an insertion block",
		  COMMAND_PREFIX, command);
d6843 3
a6845 3
/*								    */
/*			Defun and Friends       		    */
/*								    */
d6848 4
a6851 4
#define DEFUN_SELF_DELIMITING(c)					\
  (((c) == '(')								\
   || ((c) == ')')							\
   || ((c) == '[')							\
d6879 1
a6879 1
	(accumulator->tokens, (accumulator->length * sizeof (char *)));
d6899 1
a6899 1
  *scan_result = '\0';
d6918 4
a6921 4
	{
	  (*string_pointer) = scan_string;
	  return (1);
	}
d6923 10
a6932 10
      if (c == '\0')
	{
	  /* Tweak line_number to compensate for fact that
	     we gobbled the whole line before coming here. */
	  line_number -= 1;
	  line_error ("Missing `}' in %cdef arg", COMMAND_PREFIX);
	  line_number += 1;
	  (*string_pointer) = (scan_string - 1);
	  return (0);
	}
d6934 1
a6934 1
	level += 1;
d6936 1
a6936 1
	level -= 1;
d6954 1
a6954 1
  while ((*scan_string) != '\0')
d6958 7
a6964 7
	{
	  scan_string += 1;
	  while (whitespace (*scan_string))
	    scan_string += 1;
	  accumulate_token ((&accumulator), (strdup (" ")));
	  continue;
	}
d6968 28
a6995 28
	{
	  token_start = scan_string;
	  scan_string += 1;
	  if (self_delimiting (*scan_string))
	    scan_string += 1;
	  else
	    {
	      register int c;
	      while (1)
		{
		  c = *scan_string++;

 		  if ((c == '\0') || (c == '{') || (whitespace (c)))
		    {
		      scan_string -= 1;
		      break;
		    }
		}

	      if (*scan_string == '{')
		{
		  char *s = scan_string;
		  (void) scan_group_in_string (&s);
		  scan_string = s;
		}
	    }
	  token_end = scan_string;
	}
d6999 5
a7003 5
	{
	  token_start = scan_string;
	  scan_string += 1;
	  token_end = scan_string;
	}
d7007 8
a7014 8
	{
	  char *s = scan_string;
	  int balanced = scan_group_in_string (&s);

	  token_start = scan_string + 1;
	  scan_string = s;
	  token_end = balanced ? (scan_string - 1) : scan_string;
	}
d7017 1
a7017 1
	 brackets, or braces.  A token is also ended by a command. */
d7019 2
a7020 2
	{
	  token_start = scan_string;
d7022 3
a7024 3
	  while (1)
	    {
	      register int c;
d7026 1
a7026 1
	      c = *scan_string++;
d7031 17
a7047 17
	      if (!c || whitespace (c) || DEFUN_SELF_DELIMITING (c)
	          || c == '{')
		{
		  scan_string--;
		  break;
		}

	      /* If we encounter a command embedded within a token,
		 then end the token. */
	      if (c == COMMAND_PREFIX)
		{
		  scan_string--;
		  break;
		}
	    }
	  token_end = scan_string;
	}
d7050 1
a7050 1
	(&accumulator, copy_substring (token_start, token_end));
d7068 1
a7068 1
	break;
d7071 4
a7074 4
	{
	  pending_space = 1;
	  continue;
	}
d7077 4
a7080 4
	{
	  add_char (' ');
	  pending_space = 0;
	}
d7083 1
a7083 1
	add_char (defun_arg[0]);
d7085 1
a7085 1
	add_word (defun_arg);
d7087 1
a7087 1
	execute_string ("%s", defun_arg);
d7089 1
a7089 1
	execute_string ("%cvar{%s}", COMMAND_PREFIX, defun_arg);
d7091 1
a7091 1
	add_word (defun_arg);
d7115 1
a7115 1
   X_P says not to start a new insertion if non-zero. */
d7137 1
a7137 1
      category = "Function";
d7141 1
a7141 1
      category = "Macro";
d7145 1
a7145 1
      category = "Special Form";
d7149 1
a7149 1
      category = "Variable";
d7153 1
a7153 1
      category = "User Option";
d7157 1
a7157 1
      category = "Function";
d7161 1
a7161 1
      category = "Variable";
d7165 1
a7165 1
      category = "Instance Variable";
d7169 1
a7169 1
      category = "Method";
d7173 1
a7173 1
      category = "Method";
d7239 1
a7239 1
		      defined_name);
d7256 9
a7264 3
    case deftp:
    case deftypefn:
    case deftypemethod:
d7301 1
a7301 1
	break;
d7315 1
a7315 1
  char *temp = strdup (command);
d7320 1
a7320 1
    temp[strlen (temp) - 1] = '\0';
d7330 2
a7331 2
      line_error ("Must be in a `%s' insertion in order to use `%s'x",
		  command, command);
a7338 30
/* End existing insertion block. */
void
cm_end ()
{
  char *temp;
  enum insertion_type type;

  if (!insertion_level)
    {
      line_error ("Unmatched `%c%s'", COMMAND_PREFIX, command);
      return;
    }

  get_rest_of_line (&temp);
  canon_white (temp);

  if (strlen (temp) == 0)
    line_error ("`%c%s' needs something after it", COMMAND_PREFIX, command);

  type = find_type_from_name (temp);

  if (type == bad_type)
    {
      line_error ("Bad argument to `%s', `%s', using `%s'",
	   command, temp, insertion_type_pname (current_insertion_type ()));
    }
  end_insertion (type);
  free (temp);
}

d7340 3
a7342 3
/*								    */
/*			Other Random Commands		   	    */
/*								    */
d7402 1
a7402 1
      line_error ("%csp requires a positive numeric argument", COMMAND_PREFIX);
d7407 1
a7407 1
	lines = 0;
d7410 1
a7410 1
	add_char ('\n');
d7421 1
a7421 1
  char *line, *p;
d7425 1
a7425 1
  if (! no_headers)
d7457 1
a7457 1
	i--;
d7471 1
a7471 1
	insert (' ');
d7474 1
a7474 1
	insert (line[i]);
a7556 14
#if !defined (HAVE_STRERROR)
extern char *sys_errlist[];
extern int sys_nerr;

char *
strerror (num)
     int num;
{
  if (num >= sys_nerr)
    return ("Unknown file system error");
  else
    return (sys_errlist[num]);
}
#endif /* !HAVE_STRERROR */
d7602 2
a7603 2
      line_error ("`%c%s %s': %s", COMMAND_PREFIX, command, filename,
		  strerror (errno));
d7612 1
a7612 1
	remember_itext (input_text, input_text_offset);
d7624 1
a7624 1
  line_error ("Misplaced `}'");
d7633 40
d7675 3
a7677 3
/*								    */
/*			Indexing Stuff				    */
/*								    */
d7685 6
a7690 5
  char *entry;			/* The index entry itself. */
  char *node;			/* The node from whence it came. */
  int code;			/* Non-zero means add `@@code{...}' when
				   printing this element. */
  int defining_line;		/* Line number where this entry was written. */
d7693 29
a7721 4
/* A list of short-names for each index, and the index to that index in our
   index array, the_indices.  In addition, for each index, it is remembered
   whether that index is a code index or not.  Code indices have @@code{}
   inserted around the first word when they are printed with printindex. */
d7725 2
a7726 1
  int index;
a7739 8
/* We predefine these. */
#define program_index 0
#define function_index 1
#define concept_index 2
#define variable_index 3
#define datatype_index 4
#define key_index 5

d7751 1
a7751 1
					    sizeof (INDEX_ELT *));
d7755 1
a7755 1
						   sizeof (INDEX_ALIST *));
d7761 14
a7774 1
    undefindex (name_index_alist[i]->name);
d7777 6
a7782 7
  top_defindex ("pg", 0);
  top_defindex ("fn", 1);		/* "fn" is a code index.  */
  top_defindex ("cp", 0);
  top_defindex ("vr", 0);
  top_defindex ("tp", 0);
  top_defindex ("ky", 0);

d7794 2
a7795 2
	strcmp (name, name_index_alist[i]->name) == 0)
      return (name_index_alist[i]->index);
d7821 1
a7821 1
    return (which->index);
d7848 3
a7850 1
      free (temp->node);
d7856 2
a7857 1
/* Flush an index by name. */
d7865 3
a7867 1
  if (which < 0)
d7870 1
a7870 1
  i = name_index_alist[which]->index;
d7881 1
a7881 1
   CODE if non-zero says to make this a code index. */
d7897 2
a7898 2
	slot = i;
	break;
d7908 2
a7909 2
	xrealloc ((char *)name_index_alist,
		  (1 + defined_indices) * sizeof (INDEX_ALIST *));
d7911 2
a7912 2
	xrealloc ((char *)the_indices,
		  (1 + defined_indices) * sizeof (INDEX_ELT *));
d7917 3
a7919 2
  name_index_alist[slot]->name = strdup (name);
  name_index_alist[slot]->index = slot;
d7936 1
a7936 1
  which = tem ? tem->index : -1;
d7961 1
a7961 1
      line_error ("Unknown index reference `%s'", name);
d7972 1
d7983 1
a7983 1
  char *name = strdup (command);
d7985 1
a7985 1
    name[strlen (name) - strlen ("index")] = '\0';
d8026 1
a8026 1
      line_error ("Index `%s' already exists", name);
a8039 16
/* Append LIST2 to LIST1.  Return the head of the list. */
INDEX_ELT *
index_append (head, tail)
     INDEX_ELT *head, *tail;
{
  register INDEX_ELT *t_head = head;

  if (!t_head)
    return (tail);

  while (t_head->next)
    t_head = t_head->next;
  t_head->next = tail;
  return (head);
}

d8046 2
a8047 2
  int redirector, redirectee;
  char *temp;
d8050 2
a8051 2
  get_until_in_line (" ", &temp);
  redirectee = find_index_offset (temp);
d8053 3
a8055 5
  free_and_clear (&temp);
  get_until_in_line (" ", &temp);
  redirector = find_index_offset (temp);
  free (temp);
  if (redirector < 0 || redirectee < 0)
d8057 2
a8058 1
      line_error ("Unknown index reference");
d8062 2
a8063 16
      /* I think that we should let the user make indices synonymous to
         each other without any lossage of info.  This means that one can
         say @@synindex cp dt anywhere in the file, and things that used to
         be in cp will go into dt. */
      INDEX_ELT *i1 = the_indices[redirectee], *i2 = the_indices[redirector];

      if (i1 || i2)
	{
	  if (i1)
	    the_indices[redirectee] = index_append (i1, i2);
	  else
	    the_indices[redirectee] = index_append (i2, i1);
	}

      name_index_alist[redirectee]->index =
	name_index_alist[redirector]->index;
d8065 3
d8071 1
a8071 1
cm_pindex ()			/* Pinhead index. */
d8077 1
a8077 1
cm_vindex ()			/* Variable index. */
d8083 1
a8083 1
cm_kindex ()			/* Key index. */
d8089 1
a8089 1
cm_cindex ()			/* Concept index. */
d8095 1
a8095 1
cm_findex ()			/* Function index. */
d8101 1
a8101 1
cm_tindex ()			/* Data Type index. */
d8129 3
a8131 3
	  (array[i]->node != array[i + 1]->node) ||
	  (strcmp (array[i]->entry, array[i + 1]->entry) != 0))
	copy[j++] = array[i];
d8133 4
a8136 4
	{
	  free (array[i]->entry);
	  free (array[i]);
	}
d8149 1
a8149 1
	 so we make the entry name unique. */
d8151 10
a8160 10
	  (strcmp (copy[i]->entry, copy[i + 1]->entry) == 0))
	{
	  char *new_entry_name;

	  new_entry_name = (char *)xmalloc (10 + strlen (copy[i]->entry));
	  sprintf (new_entry_name, "%s <%d>", copy[i]->entry, counter);
	  free (copy[i]->entry);
	  copy[i]->entry = new_entry_name;
	  counter++;
	}
d8162 1
a8162 1
	counter = 1;
d8180 1
a8181 1
  INDEX_ELT **array;
d8183 2
d8202 4
a8205 2
      /* Maybe should set line number to the defining_line?  Any errors
         have already been given, though, I think.  */
d8208 1
a8208 1
	 then wrap the entry with "@@code{...}". */
d8213 3
a8215 1
  array[count] = (INDEX_ELT *) NULL;	/* terminate the array. */
d8223 1
a8223 1
/* Non-zero means that we are in the middle of printing an index. */
d8246 1
a8246 1
      line_error ("Unknown index name `%s'", index_name);
d8261 1
a8261 1
  add_word ("* Menu:\n\n");
d8276 5
a8280 1
      unsigned new_length = strlen (index->entry) + strlen (index_node);
d8284 1
a8284 1
          line_length = new_length + 6; /* * : .\0 */
d8312 2
a8313 2

/* User-defined commands. */
d8328 2
a8329 2
					      (1 + user_command_array_len) *
					      sizeof (COMMAND *));
d8332 1
a8332 1
  user_command_array[slot]->name = strdup (name);
d8336 1
a8336 42

/* Set the paragraph indentation variable to the value specified in STRING.
   Values can be:
   `asis': Don't change existing indentation.
   `none': Remove existing indentation.
      NUM: Indent NUM spaces at the starts of paragraphs.
           Note that if NUM is zero, we assume `none'.

   Returns 0 if successful, or non-zero if STRING isn't one of the above. */
int
set_paragraph_indent (string)
     char *string;
{
  if (strcmp (string, "asis") == 0)
    paragraph_start_indent = 0;
  else if (strcmp (string, "none") == 0)
    paragraph_start_indent = -1;
  else
    {
      if (sscanf (string, "%d", &paragraph_start_indent) != 1)
	return (-1);
      else
	{
	  if (paragraph_start_indent == 0)
	    paragraph_start_indent = -1;
	}
    }
  return (0);
}

void
cm_paragraphindent ()
{
  char *arg;

  get_rest_of_line (&arg);
  if (set_paragraph_indent (arg) != 0)
    line_error ("Bad argument to %c%s", COMMAND_PREFIX, command);

  free (arg);
}

d8343 2
a8344 2
	Make them look like followed references, with the reference
	destinations in a makeinfo manufactured node or,
d8347 2
a8348 2
	Make them appear at the bottom of the node that they originally
	appeared in. */
d8365 1
a8365 1
	   (strcasecmp (string, "EN") == 0))
d8404 2
a8405 2
  temp->marker = strdup (marker);
  temp->note = strdup (note);
d8432 1
a8432 1
    where "*" is the marker character for this note. */
d8439 3
d8448 2
a8449 2
      line_error ("`%c%s' expected more than just `%s'.  It needs something in `{...}'",
		  COMMAND_PREFIX, command, marker);
d8455 1
d8457 1
a8457 2
      int temp = ++input_text_offset;
      int len;
d8460 13
a8472 13
	{
	  if (temp == size_of_input_text)
	    {
	      line_error ("No closing brace for footnote `%s'", marker);
	      return;
	    }

	  if (input_text[temp] == '{')
	    braces++;
	  else if (input_text[temp] == '}')
	    braces--;
	  else if (input_text[temp] == '\n')
	    line_number ++;
d8474 2
a8475 2
	  temp++;
	}
d8477 1
a8477 1
      len = (temp - input_text_offset) - 1;
d8480 18
a8497 2
      note[len] = '\0';
      input_text_offset = temp;
d8502 1
a8502 1
      line_error ("Footnote defined without parent node");
d8513 5
a8517 5
	{
	  marker = (char *)xmalloc (10);
	  sprintf (marker, "%d", current_footnote_number);
	  current_footnote_number++;
	}
d8519 1
a8519 1
	marker = strdup ("*");
d8530 2
a8531 2
	{
	  char *temp_string;
d8533 2
a8534 2
	  temp_string = (char *)
	    xmalloc ((strlen (current_node)) + (strlen ("-Footnotes")) + 1);
d8536 7
a8542 7
	  add_word_args (" (*note %s-Footnotes::)", current_node);
	  strcpy (temp_string, current_node);
	  strcat (temp_string, "-Footnotes");
	  remember_node_reference (temp_string, line_number, followed_reference);
	  free (temp_string);
	  first_footnote_this_node = 0;
	}
d8556 1
a8556 1
/* Non-zero means that we are currently in the process of outputting
d8573 2
a8574 2
	char *old_current_node = current_node;
	char *old_command = strdup (command);
d8576 7
a8582 7
	already_outputting_pending_notes++;
	execute_string ("%cnode %s-Footnotes,,,%s\n",
			COMMAND_PREFIX, current_node, current_node);
	already_outputting_pending_notes--;
	current_node = old_current_node;
	free (command);
	command = old_command;
d8589 1
a8589 1
      execute_string ("---------- Footnotes ----------\n\n");
d8602 2
a8603 2
	array[footnote_count] = footnote;
	footnote = footnote->next;
d8609 1
a8609 1
    while (footnote = array[++footnote_count])
d8611 2
a8612 9

	switch (footnote_style)
	  {
	  case SeparateNode:
	  case EndNode:
	    execute_string ("(%s)  %s", footnote->marker, footnote->note);
	    close_paragraph ();
	    break;
	  }
d8621 1
a8621 1
/*              User definable Macros (text substitution)	    */
d8630 2
a8631 2
int macro_list_len = 0;		/* Number of elements. */
int macro_list_size = 0;	/* Number of slots in total. */
d8645 1
a8645 1
	break;
d8670 2
a8671 2
	macro_list = (MACRO_DEF **)xrealloc
	  (macro_list, ((macro_list_size += 10) * sizeof (MACRO_DEF *)));
d8685 1
a8685 1
      warning ("The macro `%s' is previously defined", name);
d8689 1
a8689 2

      warning ("Here is the previous definition of `%s'", name);
d8695 2
a8696 2
	{
	  register int i;
d8698 2
a8699 2
	  for (i = 0; def->arglist[i]; i++)
	    free (def->arglist[i]);
d8701 2
a8702 2
	  free (def->arglist);
	}
d8707 1
a8707 1
  def->source_file = strdup (source_file);
d8730 4
a8733 3
	memmove (macro_list + i, macro_list + i + 1,
	       ((macro_list_len + 1) - i) * sizeof (MACRO_DEF *));
	break;
d8744 1
a8744 1
     MACRO_DEF *def;
d8758 3
a8760 3
	{
	  return ((char **)NULL);
	}
d8762 28
a8789 25
	{
	  /* Braces are not required to fill out the macro arguments.  If
	     this macro takes one argument, it is considered to be the
	     remainder of the line, sans whitespace. */
	  if (def->arglist && def->arglist[0] && !def->arglist[1])
	    {
	      char **arglist;

	      get_rest_of_line (&word);
	      if (input_text[input_text_offset - 1] == '\n')
		input_text_offset--;
	      /* canon_white (word); */
	      arglist = (char **)xmalloc (2 * sizeof (char *));
	      arglist[0] = word;
	      arglist[1] = (char *)NULL;
	      return (arglist);
	    }
	  else
	    {
	      /* The macro either took no arguments, or took more than
		 one argument.  In that case, it must be invoked with
		 arguments surrounded by braces. */
	      return ((char **)NULL);
	    }
	}
d8816 1
a8816 1
	break;
d8819 1
a8819 1
	new_body[new_body_index++] = body[i++];
d8821 56
a8876 53
	{
	  /* Snarf parameter name, check against named parameters. */
	  char *param;
	  int param_start, which, len;

	  param_start = ++i;
	  while ((body[i]) && (body[i] != '\\'))
	    i++;

	  len = i - param_start;
	  param = (char *)xmalloc (1 + len);
	  memcpy (param, body + param_start, len);
	  param[len] = '\0';

	  if (body[i])
	    i++;

	  /* Now check against named parameters. */
	  for (which = 0; named && named[which]; which++)
	    if (strcmp (named[which], param) == 0)
	      break;

	  if (named[which])
	    {
	      if (which < length_of_actuals)
		text = actuals[which];
	      else
		text = (char *)NULL;

	      if (!text)
		text = "";

	      len = strlen (text);
	    }
	  else
	    {
	      len += 2;
	      text = (char *)xmalloc (1 + len);
	      sprintf (text, "\\%s\\", param);
	    }

	  if ((2 + strlen (param)) < len)
	    new_body = (char *)xrealloc
	      (new_body, new_body_size += (1 + len));

	  free (param);

	  strcpy (new_body + new_body_index, text);
	  new_body_index += len;

	  if (!named[which])
	    free (text);
	}
d8878 1
a8878 1
  new_body[new_body_index] = '\0';
a8886 1
  register int i;
d8903 1
a8903 1
      line_error ("Macro `%s' called with too many args", def->name);
d8915 4
a8918 4
	{
	  remember_itext (input_text, input_text_offset);
	  me_execute_string (execution_string);
	}
d8920 1
a8920 1
	execute_string ("%s", execution_string);
d8954 4
a8957 4
	 (i < size_of_input_text) &&
	 (input_text[i] != '{') &&
	 (!cr_or_whitespace (input_text[i]));
	 i++);
d8962 1
a8962 1
    name[len] = '\0';
d8978 2
a8979 2
	 These words will be replaced within the body of the macro at
	 execution time. */
d8985 2
a8986 2
	{
	  int len;
d8988 55
a9042 55
	  for (i = input_text_offset;
	       character = input_text[i];
	       i++)
	    {
	      switch (character)
		{
		case '\n':
		  line_number++;
		case ' ':
		case '\t':
		case ',':
		case '}':
		  /* Found the end of the current arglist word.  Save it. */
		  len = i - input_text_offset;
		  word = (char *)xmalloc (1 + len);
		  strncpy (word, input_text + input_text_offset, len);
		  word[len] = '\0';
		  input_text_offset = i;

		  /* Advance to the comma or close-brace that signified
		     the end of the argument. */
		  while ((character = curchar ())
			 && character != ','
			 && character != '}')
		    {
		      input_text_offset++;
		      if (character == '\n')
			line_number++;
		    }

		  /* Add the word to our list of words. */
		  if ((arglist_index + 2) >= arglist_size)
		    arglist = (char **)xrealloc
		      (arglist, (arglist_size += 10) * sizeof (char *));

		  arglist[arglist_index++] = word;
		  arglist[arglist_index] = (char *)NULL;
		  break;
		}

	      if (character == '}')
		{
		  input_text_offset++;
		  gathering_words = 0;
		  break;
		}

	      if (character == ',')
		{
		  input_text_offset++;
		  skip_whitespace_and_newlines ();
		  i = input_text_offset - 1;
		}
	    }
	}
d9052 7
a9058 7
	{
	  int temp_line = line_number;
	  line_number = defining_line;
	  line_error ("%cend macro not found", COMMAND_PREFIX);
	  line_number = temp_line;
	  return;
	}
d9064 12
a9075 12
	  (strncmp (line + 1, "allow-recursion", 15) == 0) &&
	  (line[16] == '\0' || whitespace (line[16])))
	{
	  for (i = 16; whitespace (line[i]); i++);
	  strcpy (line, line + i);
	  flags |= ME_RECURSE;
	  if (!*line)
	    {
	      free (line);
	      continue;
	    }
	}
d9078 21
a9098 21
	  (strncmp (line + 1, "quote-arg", 9) == 0) &&
	  (line[10] == '\0' || whitespace (line[10])))
	{
	  for (i = 10; whitespace (line[i]); i++);
	  strcpy (line, line + i);

	  if (arglist && arglist[0] && !arglist[1])
	    {
	      flags |= ME_QUOTE_ARG;
	      if (!*line)
		{
		  free (line);
		  continue;
		}
	    }
	  else
	    {
	      line_error ("%cquote-arg only useful when the macro takes a single argument",
			  COMMAND_PREFIX);
	    }
	}
d9101 2
a9102 2
	  (strncmp (line + 1, "macro ", 6) == 0))
	depth++;
d9105 2
a9106 2
	  (strncmp (line + 1, "end macro", 9) == 0))
	depth--;
d9109 9
a9117 9
	{
	  if ((body_index + strlen (line) + 3) >= body_size)
	    body = (char *)xrealloc
	      (body, body_size += 3 + strlen (line));
	  strcpy (body + body_index, line);
	  body_index += strlen (line);
	  body[body_index++] = '\n';
	  body[body_index] = '\0';
	}
d9121 10
d9135 1
a9135 1
    body[strlen (body) - 1] = '\0';
a9153 1
  canon_white (line);
d9156 1
a9156 1
  name = (char *)xmalloc (i);
d9158 1
a9158 1
  name[i] = '\0';
d9169 2
a9170 2
	{
	  register int i;
d9172 2
a9173 2
	  for (i = 0; def->arglist[i]; i++)
	    free (def->arglist[i]);
d9175 2
a9176 2
	  free (def->arglist);
	}
d9204 1
a9204 1
	itext_info[i] = (ITEXT *)NULL;
d9210 1
a9210 1
	(itext_info[i]->pointer == pointer))
d9212 3
a9214 3
	itext = itext_info[i];
	itext_info[i]->offset = offset;
	break;
d9219 2
a9220 2
      /* Find a blank slot, (or create a new one), and remember the
	 pointer and offset. */
d9222 2
a9223 2
	if (itext_info[i] == (ITEXT *)NULL)
	  break;
d9227 2
a9228 2
	{
	  register int j;
d9230 2
a9231 2
	  itext_info = (ITEXT **)xrealloc
	    (itext_info, (itext_size += 10) * sizeof (ITEXT *));
d9233 3
a9235 3
	  for (j = i; j < itext_size; j++)
	    itext_info[j] = (ITEXT *)NULL;
	}
d9256 3
a9258 3
	free (itext_info[i]);
	itext_info[i] = (ITEXT *)NULL;
	break;
d9282 1
a9282 1
  input_filename = strdup (input_filename);
d9305 2
a9306 2
	itext = itext_info[i];
	break;
d9315 1
a9315 1
	(input_text, itext->offset, offset);
d9332 2
a9333 2
	itext = itext_info[i];
	break;
d9376 1
a9376 1
	free (array[i]);
d9405 1
a9405 1
  while (character = curchar ())
d9408 4
a9411 4
	{
	  input_text_offset += 2;
	  escape_seen = 1;
	}
d9413 4
a9416 4
	{
	  depth++;
	  input_text_offset++;
	}
d9418 35
a9452 35
	       ((character == '}') && depth == 1))
	{
	  int len = input_text_offset - start;

	  if (len || (character != '}'))
	    {
	      word = (char *)xmalloc (1 + len);
	      strncpy (word, input_text + start, len);
	      word[len] = '\0';

	      /* Clean up escaped characters. */
	      if (escape_seen)
		{
		  register int i;

		  for (i = 0; word[i]; i++)
		    if (word[i] == '\\')
		      memmove (word + i, word + i + 1,
			       1 + strlen (word + i + 1));
		}

	      if (arglist_index + 2 >= arglist_size)
		arglist = (char **)xrealloc
		  (arglist, (arglist_size += 10) * sizeof (char *));

	      arglist[arglist_index++] = word;
	      arglist[arglist_index] = (char *)NULL;
	    }

	  input_text_offset++;
	  if (character == '}')
	    break;
	  else
	    goto get_arg;
	}
d9454 4
a9457 4
	{
	  depth--;
	  input_text_offset++;
	}
d9459 4
a9462 4
	{
	  input_text_offset++;
	  if (character == '\n') line_number++;
	}
d9505 1
a9505 1
	(*index)++;
d9508 1
a9508 1
      return (strdup (""));
d9516 1
a9516 1
      value [i - start] = '\0';
d9541 7
a9547 1
	(filename[1] == '.' && filename[2] == '/'))))
d9550 1
a9550 1
	return (strdup (filename));
d9552 1
a9552 1
	return ((char *)NULL);
d9555 1
a9555 1
  while (dir = extract_colon_unit (path, &index))
d9560 4
a9563 4
	{
	  free (dir);
	  dir = strdup (".");
	}
d9572 1
a9572 1
	return (fullpath);
d9574 1
a9574 1
	free (fullpath);
d9576 1
a9576 1
  return ((char *)NULL);
@


1.1
log
@Initial revision
@
text
@d2 1
d4 1
a4 1
   Copyright (C) 1987, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
d6 13
a18 1
   This file is part of GNU Info.
d20 1
a20 17
   Makeinfo is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY.  No author or distributor accepts
   responsibility to anyone for the consequences of using it or for
   whether it serves any particular purpose or works at all, unless he
   says so in writing.  Refer to the GNU Emacs General Public License
   for full details.

   Everyone is granted permission to copy, modify and redistribute
   Makeinfo, but only under the conditions described in the GNU Emacs
   General Public License.   A copy of this license is supposed to
   have been given to you along with GNU Emacs so you can know your
   rights and responsibilities.  It should be in a file named COPYING.
   Among other things, the copyright notice and this notice must be
   preserved on all copies.  */

/* This is Makeinfo version 1.63.  If you change the version number of
   Makeinfo, please change it here and at the lines reading:
d22 2
a23 6
    int major_version = 1;
    int minor_version = 63;

   in the code below.

   Makeinfo is authored by Brian Fox (bfox@@ai.mit.edu). */
d52 1
a52 1
/* Define HAVE_MACROS to enable the macro facility of TeXinfo.  Using this
a55 5
/* **************************************************************** */
/*								    */
/*			Include File Declarations       	    */
/*								    */
/* **************************************************************** */
d126 3
a169 63


/* **************************************************************** */
/*								    */
/*			      Global Defines  			    */
/*								    */
/* **************************************************************** */

/* Error levels */
#define NO_ERROR 0
#define SYNTAX	 2
#define FATAL	 4

/* C's standard macros don't check to make sure that the characters being
   changed are within range.  So I have to check explicitly. */

/* GNU Library doesn't have toupper().  Until GNU gets this fixed, I will
   have to do it. */
#ifndef toupper
#define toupper(c) ((c) - 32)
#endif

#define coerce_to_upper(c) ((islower(c) ? toupper(c) : (c)))
#define coerce_to_lower(c) ((isupper(c) ? tolower(c) : (c)))

#define control_character_bit 0x40 /* %01000000, must be off. */
#define meta_character_bit 0x080/* %10000000, must be on.  */
#define CTL(c) ((c) & (~control_character_bit))
#define UNCTL(c) coerce_to_upper(((c)|control_character_bit))
#define META(c) ((c) | (meta_character_bit))
#define UNMETA(c) ((c) & (~meta_character_bit))

#define whitespace(c) (((c) == '\t') || ((c) == ' '))
#define sentence_ender(c) ((c) == '.' || (c) == '?' || (c) == '!')
#define cr_or_whitespace(c) (((c) == '\t') || ((c) == ' ') || ((c) == '\n'))

#ifndef isletter
#define isletter(c) (((c) >= 'A' && (c) <= 'Z') || ((c) >= 'a' && (c) <= 'z'))
#endif

#ifndef isupper
#define isupper(c) ((c) >= 'A' && (c) <= 'Z')
#endif

#ifndef isdigit
#define isdigit(c)  ((c) >= '0' && (c) <= '9')
#endif

#ifndef digit_value
#define digit_value(c) ((c) - '0')
#endif

#define member(c, s) (strchr (s, c) != NULL)

#define COMMAND_PREFIX '@@'

/* Stuff for splitting large files. */
#define SPLIT_SIZE_THRESHOLD 70000  /* What's good enough for Stallman... */
#define DEFAULT_SPLIT_SIZE 50000    /* Is probably good enough for me. */
int splitting = 1;		    /* Always true for now. */

typedef void COMMAND_FUNCTION (); /* So I can say COMMAND_FUNCTION *foo; */

a179 31
/* The current input file state. */
char *input_filename;
char *input_text;
int size_of_input_text;
int input_text_offset;
int line_number;

#define curchar() input_text[input_text_offset]

#define command_char(c) ((!whitespace(c)) && \
			 ((c) != '\n') && \
			 ((c) != '{') && \
			 ((c) != '}') && \
			 ((c) != '='))

#define skip_whitespace() while (input_text_offset != size_of_input_text \
				 && whitespace(curchar()))\
  input_text_offset++

#define skip_whitespace_and_newlines() \
  do { \
   while (input_text_offset != size_of_input_text \
	  && (whitespace (curchar ()) \
	      || (curchar () == '\n'))) \
      { \
	 if (curchar () == '\n') \
	   line_number++; \
	 input_text_offset++; \
      } \
   } while (0)

a204 12
/* Output paragraph buffer. */
unsigned char *output_paragraph;

/* Offset into OUTPUT_PARAGRAPH. */
int output_paragraph_offset;

/* The output paragraph "cursor" horizontal position. */
int output_column = 0;

/* Non-zero means output_paragraph contains text. */
int paragraph_is_open = 0;

a218 6
/* The column at which long lines are broken. */
int fill_column = 72;

/* The amount of indentation to apply at the start of each line. */
int current_indent = 0;

d378 3
d429 1
d439 2
d462 1
d467 2
a468 2

void insert_self (), cm_ignore_line ();
d471 5
a475 5
  cm_asterisk (), cm_dots (), cm_bullet (), cm_TeX (),
  cm_copyright (), cm_code (), cm_samp (), cm_file (), cm_kbd (),
  cm_key (), cm_ctrl (), cm_var (), cm_dfn (), cm_emph (), cm_strong (),
  cm_cite (), cm_italic (), cm_bold (), cm_roman (), cm_title (), cm_w (),
  cm_refill (), cm_titlefont ();
d477 1
d486 3
a488 2
/* All @@defxxx commands map to cm_defun (). */
void cm_defun ();
d493 11
a503 11
  cm_enumerate (), cm_table (), cm_itemx (), cm_noindent (), cm_setfilename (),
  cm_br (), cm_sp (), cm_page (), cm_group (), cm_center (), cm_include (),
  cm_bye (), cm_item (), cm_end (), cm_infoinclude (), cm_ifinfo (),
  cm_kindex (), cm_cindex (), cm_findex (), cm_pindex (), cm_vindex (),
  cm_tindex (), cm_asis (), cm_synindex (), cm_printindex (), cm_minus (),
  cm_footnote (), cm_force_abbreviated_whitespace (), cm_example (),
  cm_smallexample (), cm_lisp (), cm_format (), cm_exdent (), cm_defindex (),
  cm_defcodeindex (), cm_sc (), cm_result (), cm_expansion (), cm_equiv (),
  cm_print (), cm_error (), cm_point (), cm_today (), cm_flushleft (),
  cm_flushright (), cm_smalllisp (), cm_finalout (), cm_math (),
  cm_cartouche (), cm_ignore_sentence_ender ();
d518 2
a519 2
void do_nothing (), command_name_condition ();
void misplaced_brace (), cm_obsolete ();
d536 5
a540 1
  { "!", cm_ignore_sentence_ender, NO_BRACE_ARGS },
d543 6
a548 4
  { ".", cm_ignore_sentence_ender, NO_BRACE_ARGS },
  { ":", cm_force_abbreviated_whitespace, NO_BRACE_ARGS },
  { "?", cm_ignore_sentence_ender, NO_BRACE_ARGS },
  { "|", do_nothing, NO_BRACE_ARGS },
d550 12
a561 2
  { " ", insert_self, NO_BRACE_ARGS },
  { "\n", insert_self, NO_BRACE_ARGS },
d563 2
a564 1
  { "`", insert_self, NO_BRACE_ARGS },
d570 2
a571 3
  { "asis", cm_asis, BRACE_ARGS },
  { "b", cm_bold, BRACE_ARGS },
  { "br", cm_br, NO_BRACE_ARGS },
d577 1
d585 1
a585 1
  { "contents", do_nothing, NO_BRACE_ARGS },
d587 1
a587 1
  { "ctrl", cm_ctrl, BRACE_ARGS },
a589 2
  { "dfn", cm_dfn, BRACE_ARGS },

d591 2
d595 2
a596 2
  { "defun", cm_defun, NO_BRACE_ARGS },
  { "defunx", cm_defun, NO_BRACE_ARGS },
d599 6
d607 2
a608 6
  { "defvr", cm_defun, NO_BRACE_ARGS },
  { "defvrx", cm_defun, NO_BRACE_ARGS },
  { "defvar", cm_defun, NO_BRACE_ARGS },
  { "defvarx", cm_defun, NO_BRACE_ARGS },
  { "defopt", cm_defun, NO_BRACE_ARGS },
  { "defoptx", cm_defun, NO_BRACE_ARGS },
d613 4
d619 6
a624 14
  { "deftypevar", cm_defun, NO_BRACE_ARGS },
  { "deftypevarx", cm_defun, NO_BRACE_ARGS },
  { "defcv", cm_defun, NO_BRACE_ARGS },
  { "defcvx", cm_defun, NO_BRACE_ARGS },
  { "defivar", cm_defun, NO_BRACE_ARGS },
  { "defivarx", cm_defun, NO_BRACE_ARGS },
  { "defop", cm_defun, NO_BRACE_ARGS },
  { "defopx", cm_defun, NO_BRACE_ARGS },
  { "defmethod", cm_defun, NO_BRACE_ARGS },
  { "defmethodx", cm_defun, NO_BRACE_ARGS },
  { "deftypemethod", cm_defun, NO_BRACE_ARGS },
  { "deftypemethodx", cm_defun, NO_BRACE_ARGS },
  { "deftp", cm_defun, NO_BRACE_ARGS },
  { "deftpx", cm_defun, NO_BRACE_ARGS },
d626 4
a629 1

d631 3
d635 1
a635 1
  { "dmn", do_nothing, BRACE_ARGS },
d638 1
d643 1
d646 2
a647 1
  { "file", cm_file, BRACE_ARGS },
a648 1
  { "finalout", do_nothing, NO_BRACE_ARGS },
d651 2
d658 2
a659 7
  { "i", cm_italic, BRACE_ARGS },
  { "iappendix", cm_appendix, NO_BRACE_ARGS },
  { "iappendixsection", cm_appendixsec, NO_BRACE_ARGS },
  { "iappendixsec", cm_appendixsec, NO_BRACE_ARGS },
  { "iappendixsubsec", cm_appendixsubsec, NO_BRACE_ARGS },
  { "iappendixsubsubsec", cm_appendixsubsubsec, NO_BRACE_ARGS },
  { "ichapter", cm_chapter, NO_BRACE_ARGS },
a668 4
  { "input", cm_include, NO_BRACE_ARGS },
  { "isection", cm_section, NO_BRACE_ARGS },
  { "isubsection", cm_subsection, NO_BRACE_ARGS },
  { "isubsubsection", cm_subsubsection, NO_BRACE_ARGS },
a671 4
  { "iunnumbered", cm_unnumbered, NO_BRACE_ARGS },
  { "iunnumberedsec", cm_unnumberedsec, NO_BRACE_ARGS },
  { "iunnumberedsubsec", cm_unnumberedsubsec, NO_BRACE_ARGS },
  { "iunnumberedsubsubsec", cm_unnumberedsubsubsec, NO_BRACE_ARGS },
d673 1
a673 1
  { "key", cm_key, BRACE_ARGS },
d675 2
a677 1
  { "lisp", cm_lisp, NO_BRACE_ARGS },
d682 1
a682 2
  { "math", cm_math, BRACE_ARGS },
  { "medbreak", cm_br, NO_BRACE_ARGS },
d685 1
d690 4
a693 2
  { "overfullrule", cm_ignore_line, NO_BRACE_ARGS },
  { "page", do_nothing, NO_BRACE_ARGS },
d696 1
d700 1
d702 1
a702 1
  { "r", cm_roman, BRACE_ARGS },
d705 1
a705 1
  { "refill", cm_refill, NO_BRACE_ARGS },
d707 2
a708 1
  { "samp", cm_samp, BRACE_ARGS },
d713 1
a713 1
  { "setchapterstyle", cm_ignore_line, NO_BRACE_ARGS },
d716 1
a716 1
  { "shortcontents", do_nothing, NO_BRACE_ARGS },
a718 1
  { "smallbreak", cm_br, NO_BRACE_ARGS },
d722 1
d728 1
a728 1
  { "summarycontents", do_nothing, NO_BRACE_ARGS },
d731 2
a732 1
  { "t", cm_title, BRACE_ARGS },
d735 1
d737 1
a737 1
  { "titlefont", cm_titlefont, BRACE_ARGS },
a738 1
  { "titlespec", command_name_condition, NO_BRACE_ARGS },
d741 3
d751 2
a758 2
  { "{", insert_self, NO_BRACE_ARGS },
  { "}", insert_self, NO_BRACE_ARGS },
d760 14
a773 14
  /* Some obsoleted commands. */
  { "infotop", cm_obsolete, NO_BRACE_ARGS },
  { "infounnumbered", cm_obsolete, NO_BRACE_ARGS },
  { "infounnumberedsec", cm_obsolete, NO_BRACE_ARGS },
  { "infounnumberedsubsec", cm_obsolete, NO_BRACE_ARGS },
  { "infounnumberedsubsubsec", cm_obsolete, NO_BRACE_ARGS },
  { "infoappendix", cm_obsolete, NO_BRACE_ARGS },
  { "infoappendixsec", cm_obsolete, NO_BRACE_ARGS },
  { "infoappendixsubsec", cm_obsolete, NO_BRACE_ARGS },
  { "infoappendixsubsubsec", cm_obsolete, NO_BRACE_ARGS },
  { "infochapter", cm_obsolete, NO_BRACE_ARGS },
  { "infosection", cm_obsolete, NO_BRACE_ARGS },
  { "infosubsection", cm_obsolete, NO_BRACE_ARGS },
  { "infosubsubsection", cm_obsolete, NO_BRACE_ARGS },
d776 2
a777 4
  { "infoinclude", cm_infoinclude, NO_BRACE_ARGS },
  { "footnote", cm_footnote, NO_BRACE_ARGS}, /* self-arg eater */
  { "footnotestyle", cm_footnotestyle, NO_BRACE_ARGS },
  { "paragraphindent", cm_paragraphindent, NO_BRACE_ARGS },
a780 3
int major_version = 1;
int minor_version = 63;

d804 1
a804 1

d818 1
a818 1
   texinfo commands into wonderfully formatted output text. */
d836 1
a836 1
	   "D:E:U:I:f:o:p:e:r:s:V",
d838 1
a838 1
	   "D:U:I:f:o:p:e:r:s:V",
d880 21
d904 6
a909 1
	    usage (stderr, FATAL);
d920 6
a925 1
	    usage (stderr, FATAL);
d931 5
d942 6
a947 1
	    usage (stderr, FATAL);
d953 6
a958 1
	    usage (stderr, FATAL);
d963 1
a963 1
	  usage (stdout, NO_ERROR);
d969 4
d977 1
a977 1
	  usage (stderr, FATAL);
d988 4
a991 1
	usage (stderr, FATAL);
d1031 1
a1031 2
  printf ("This is GNU Makeinfo version %d.%d.\n",
	  major_version, minor_version);
d1033 1
a1033 1

a1039 14
#if !defined (HAVE_STRDUP)
char *
strdup (string)
     char *string;
{
  char *result;

  result = (char *)xmalloc (1 + strlen (string));
  strcpy (result, string);

  return (result);
}
#endif /* !HAVE_STRDUP */

d1087 3
a1089 2
/* Tell the user how to use this program.
   Print the message to STREAM, and then exit with EXIT_VALUE. */
d1091 1
a1091 2
usage (stream, exit_value)
     FILE *stream;
d1094 4
a1097 1
  fprintf (stream, "Usage: %s [options] texinfo-file...\n\
d1099 2
a1100 2
This program accepts as input files of texinfo commands and text\n\
and outputs a file suitable for reading with GNU Info.\n\
d1103 23
a1125 27
`-I DIR'              add DIR to the directory search list for including\n\
                      files with the `@@include' command.\n\
-D VAR                define a variable, as with `@@set'.\n\
-U VAR                undefine a variable, as with `@@clear'.\n\
-E MACRO-OFILE	    process macros, and output texinfo source code for TeX.\n\
--no-validate         suppress node cross reference validation.\n\
--no-warn             suppress warning messages (errors are still output).\n\
--no-split            suppress the splitting of large files.\n\
--no-headers          suppress the output of Node: Foo headers.\n\
--verbose             print information about what is being done.\n\
--version             print the version number of Makeinfo.\n\
--output FILE or -o FILE\n\
                      specify the output file.  When you specify the\n\
                      output file in this way, any `@@setfilename' in the\n\
                      input file is ignored.\n\
--paragraph-indent NUM\n\
                      set the paragraph indent to NUM (default %d).\n\
--fill-column NUM     set the filling column to NUM (default %d).\n\
--error-limit NUM     set the error limit to NUM (default %d).\n\
--reference-limit NUM\n\
                      set the reference warning limit to NUM (default %d).\n\
--footnote-style STYLE\n\
                      set the footnote style to STYLE.  STYLE should\n\
                      either be `separate' to place footnotes in their own\n\
                      node, or `end', to place the footnotes at the end of\n\
                      the node in which they are defined (the default).\n\
--help                print this message and exit.\n\n",
d1130 2
a1131 6

/* **************************************************************** */
/*								    */
/*			Manipulating Lists      		    */
/*					        		    */
/* **************************************************************** */
d1156 2
a1157 7


/* **************************************************************** */
/*								    */
/*			Pushing and Popping Files       	    */
/*								    */
/* **************************************************************** */
d1217 1
a1217 1
  input_filename = strdup (fullpath);
d1302 2
a1303 11
    {
      if (!node_filename_stack)
	node_filename_stack =
	  (char **)xmalloc ((node_filename_stack_size += 10)
			    * sizeof (char *));
      else
	node_filename_stack =
	  (char **)xrealloc (node_filename_stack,
			     (node_filename_stack_size + 10)
			     * sizeof (char *));
    }
d1540 1
a1540 1

d1575 1
a1575 1
  fprintf (stderr, "\n");
d1623 1
a1623 1
  fprintf (stderr, "\n");
d1677 1
a1677 2
/* Return the next token as a string pointer.  We cons the
   string. */
d1690 4
d1714 3
a1716 1
  return (member (character, "{}:.@@*'`,!?; \n\t"));
d1922 1
a1922 1

a1931 1
  "",
d1935 1
d1946 6
d1954 3
a1956 3
  /* We read in multiples of 4k, simply because it is a typical pipe size
     on unix systems. */
#define _READ_BUFFER_GROWTH (4 * 4096)
d1977 1
a1977 1
      if (buffer_offset + (_READ_BUFFER_GROWTH + 1) >= buffer_size)
d1979 1
a1979 1
	  xrealloc (buffer, (buffer_size += _READ_BUFFER_GROWTH));
d1981 1
a1981 1
      count = fread (buffer + buffer_offset, 1, _READ_BUFFER_GROWTH, stream);
d2019 3
a2021 2
  /* Try to load the file specified by NAME.  If the file isn't found, and
     there is no suffix in NAME, then try NAME.texinfo, and NAME.texi. */
d2145 2
a2146 1
    printf ("Making info file `%s' from `%s'.\n", output_filename, name);
d2175 1
a2175 1
      add_word_args ("This is Info file %s, produced by Makeinfo-%d.%d from ",
d2177 1
a2177 1
      add_word_args ("the input file %s.\n", input_filename);
d2242 1
a2251 1
  output_position = 0;
d2324 1
a2324 1
	     that begins menu entrys is "\n* ". */
d2332 2
a2333 1
	      tem = glean_node_from_menu (1);
d2438 1
a2438 1
      line_error ("Unknown info command `%s'", command);
d2490 1
d2505 1
a2505 1
      line_error ("Unmatched close brace");
d2511 1
d2662 1
a2662 1
  if (no_headers && in_menu)
d2853 1
a2853 1
/* Insert CHARACTER into OUTPUT_PARAGRAPH. */
d2866 9
d2931 8
a2938 5
      if (output_paragraph[i] == (unsigned char)(' ' | 0x80) ||
	  output_paragraph[i] == (unsigned char)('\t' | 0x80) ||
	  output_paragraph[i] == (unsigned char)('\n' | 0x80) ||
	  sentence_ender (UNMETA (output_paragraph[i])))
	output_paragraph[i] &= 0x7f;
a3221 31
enum insertion_type { menu, quotation, lisp, smalllisp, example,
  smallexample, display, itemize, format, enumerate, cartouche, table,
  ftable, vtable, group, ifinfo, flushleft, flushright, ifset, ifclear, deffn,
  defun, defmac, defspec, defvr, defvar, defopt, deftypefn,
  deftypefun, deftypevr, deftypevar, defcv, defivar, defop, defmethod,
  deftypemethod, deftp, bad_type };

char *insertion_type_names[] = { "menu", "quotation", "lisp",
  "smalllisp", "example", "smallexample", "display", "itemize",
  "format", "enumerate", "cartouche", "table", "ftable", "vtable", "group",
  "ifinfo", "flushleft", "flushright", "ifset", "ifclear", "deffn",
  "defun", "defmac", "defspec", "defvr", "defvar", "defopt",
  "deftypefn", "deftypefun", "deftypevr", "deftypevar", "defcv",
  "defivar", "defop", "defmethod", "deftypemethod", "deftp",
  "bad_type" };

int insertion_level = 0;
typedef struct istack_elt
{
  struct istack_elt *next;
  char *item_function;
  char *filename;
  int line_number;
  int filling_enabled;
  int indented_fill;
  enum insertion_type insertion;
  int inhibited;
} INSERTION_ELT;

INSERTION_ELT *insertion_stack = (INSERTION_ELT *) NULL;

d3299 1
d3315 1
a3353 5
void
do_nothing ()
{
}

d3478 23
d3502 1
a3502 1
	 If you don't want filling, then use @@example. */
d3530 4
d3678 14
d3698 4
a3721 5
      /* @@quotation is the only one of the above without a fixed width
	 font. */
      if (type != quotation)
	in_fixed_width_font--;

d3764 1
a3764 2
	  insertion_stack->insertion == ifclear ||
	  insertion_stack->insertion == cartouche)
d3783 2
d3786 8
a3793 1
/* The actual commands themselves. */
a3794 1
/* Commands which insert themselves. */
d3796 2
a3797 1
insert_self ()
d3799 2
a3800 1
  add_word (command);
d3822 9
d3856 1
d3859 1
a3859 1
     int arg;
d3865 77
a3972 3
  if (printing_index)
    return;

d3976 3
a3978 1
      add_char ('`');
d3982 2
a3983 2
      add_word ("'");
      in_fixed_width_font--;
a3987 14
cm_samp (arg)
     int arg;
{
  cm_code (arg);
}

void
cm_file (arg)
     int arg;
{
  cm_code (arg);
}

void
d3991 4
a3994 1
  cm_code (arg);
d3998 1
a3998 1
cm_key (arg)
d4001 1
d4004 1
a4004 1
/* Convert the character at position into CTL. */
d4029 10
a4038 1
/* Small Caps in makeinfo just does all caps. */
d4043 2
d4061 2
d4105 1
a4105 30
/* Current text is italicized. */
void
cm_italic (arg, start, end)
     int arg, start, end;
{
}

/* Current text is highlighted. */
void
cm_bold (arg, start, end)
     int arg, start, end;
{
  cm_italic (arg);
}

/* Current text is in roman font. */
void
cm_roman (arg, start, end)
     int arg, start, end;
{
}

/* Current text is in roman font. */
void
cm_titlefont (arg, start, end)
     int arg, start, end;
{
}

/* Italicize titles. */
d4107 1
a4107 1
cm_title (arg, start, end)
d4110 1
a4110 1
  cm_italic (arg);
d4113 1
a4113 1
/* @@refill is a NOP. */
d4115 1
a4115 1
cm_refill ()
d4413 10
d4540 1
a4540 2


d5013 1
a5013 1
   Scan through the list of tag entrys touching the Prev, Next, and Up
d5482 1
a5482 1
  temp->containing_node = strdup (current_node);
d5651 6
d5660 12
a5671 1

d5723 6
d5816 1
a5816 1

d5874 9
d5932 6
d5975 1
a5975 2


d5983 2
a5984 2
typedef struct _defines {
  struct _defines *next;
d6102 1
a6102 1
   The syntax @@ifeq{arg1, arg2, texinfo commands} performs texinfo commands
d6313 2
a6314 7


/* **************************************************************** */
/*								    */
/*		    Execution of Random Text not in file	    */
/*								    */
/* **************************************************************** */
d6425 34
a6458 5
/* **************************************************************** */
/*								    */
/*			@@itemx, @@item				    */
/*								    */
/* **************************************************************** */
d6494 13
a6646 1

d6834 5
a6838 3
	      if (!c ||
		  (whitespace (c) || DEFUN_SELF_DELIMITING (c) ||
		   c == '{' || c == '}'))
d6844 1
a6844 1
	      /* If we encounter a command imbedded within a token,
d7071 23
a7093 21
  /* Make an entry in the appropriate index. */
  switch (base_type)
    {
    case deffn:
    case deftypefn:
      execute_string ("%cfindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defvr:
    case deftypevr:
    case defcv:
      execute_string ("%cvindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defop:
    case deftypemethod:
      execute_string ("%cfindex %s on %s\n",
		      COMMAND_PREFIX, defined_name, type_name);
      break;
    case deftp:
      execute_string ("%ctindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    }
a7167 1

d7245 20
d7281 1
a7281 1
  execute_string ((char *)line);
a7386 6
void
cm_include ()
{
  cm_infoinclude ();
}

d7404 1
a7404 1
cm_infoinclude ()
a7470 15
/* Don't let the filling algorithm insert extra whitespace here. */
void
cm_force_abbreviated_whitespace ()
{
}

/* Do not let this character signify the end of a sentence, though
   if it was seen without the command prefix it normally would.  We
   do this by turning on the 8th bit of the character. */
void
cm_ignore_sentence_ender ()
{
  add_char (META ((*command)));
}

d7477 1
a7477 12

void
cm_asis ()
{
}

void
cm_math ()
{
}


a7904 1
  /* This needs to ignore leading non-text characters. */
d7916 1
d7924 1
a7924 1
	  (strcasecmp (array[i]->entry, array[i + 1]->entry) != 0))
d7939 1
a7939 1
      int counter = 1;
d7993 8
d8023 4
a8026 2
  int old_inhibitions = inhibit_paragraph_indentation;
  int previous_filling_enabled_value = filling_enabled;
d8041 5
a8047 2
  filling_enabled = 0;
  inhibit_paragraph_indentation = 1;
a8050 2
  printing_index = 1;

d8055 4
d8061 17
a8077 1
      int real_line_number = line_number;
d8079 2
a8080 19
      /* Let errors generated while making the index entry point back
	 at the line which contains the entry. */
      line_number = index->defining_line;

      /* If this particular entry should be printed as a "code" index,
	 then wrap the entry with "@@code{...}". */
      if (index->code)
	execute_string ("* %ccode{%s}: ", COMMAND_PREFIX, index->entry);
      else
	execute_string ("* %s: ", index->entry);

      /* Pad the front of the destination nodename so that
	 the output looks nice. */
      if (fill_column > 40 && output_column < 40)
	indent (40 - output_column);

      execute_string ("%s.\n", index->node);

      line_number = real_line_number;
d8084 2
d8087 1
a8087 1
      me_inhibit_expansion--;
d8093 2
a8094 2
  filling_enabled = previous_filling_enabled_value;
  inhibit_paragraph_indentation = old_inhibitions;
a8095 1

d8097 1
a8097 5
/* **************************************************************** */
/*								    */
/*		    Making User Defined Commands		    */
/*								    */
/* **************************************************************** */
a8120 7
/* Make ALIAS run the named FUNCTION.  Copies properties from FUNCTION. */
void
define_alias (alias, function)
     char *alias, *function;
{
}

d8205 2
a8206 1
  if (set_footnote_style (arg) != 0)
a8376 1

d8431 1
a8431 2


d8544 1
a8544 1
	memcpy (macro_list + i, macro_list + i + 1,
d8584 3
a8586 2
	      input_text_offset--;
	      canon_white (word);
d8728 1
a8728 1
	execute_string (execution_string);
d8820 5
a8824 1
		    input_text_offset++;
d8889 1
a8889 1
	  for (i = 16; whitespace (line[i]); i++);
d9111 1
a9111 1
  if (offset > itext_info[i]->offset)
d9114 1
a9114 1
	(input_text, itext_info[i]->offset, offset);
d9234 2
a9235 1
		      memcpy (word + i, word + i + 1, strlen (word + i + 1));
d9258 4
a9261 1
	input_text_offset++;
d9265 1
a9265 1

@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@import of texinfo 3.7
@
text
@d22 1
a22 1
/* This is Makeinfo version 1.64.  If you change the version number of
d26 1
a26 1
    int minor_version = 64;
a137 4
#if !defined (HAVE_MEMMOVE)
#  define memmove(dst, src, len) bcopy (src, dst, len)
#endif

d874 1
a874 1
int minor_version = 64;
d1073 1
a1073 1
  printf ("This is GNU Makeinfo version %d.%d, from texinfo-3.7.\n",
d1284 1
a1284 1
  input_filename = fullpath;
a1766 4

      if (character == '\n')
	line_number++;

d2982 4
a2985 1
      if (output_paragraph[i] == (unsigned char)(' ' | 0x80))
d3806 2
a3807 1
	  insertion_stack->insertion == ifclear)
a5614 6
  if (current_node == (char *)NULL)
    {
      warning ("%cmenu seen before a node has been defined", COMMAND_PREFIX);
      warning ("Creating `TOP' node.");
      execute_string ("@@node Top");
    }
d5618 1
a5669 6
	  /* Free all of the arguments found. */
	  if (arg1) free (arg1);
	  if (arg2) free (arg2);
	  if (arg3) free (arg3);
	  if (arg4) free (arg4);
	  if (arg5) free (arg5);
d7149 1
a7149 1
  execute_string ("%s", (char *)line);
a7816 1
  int counter = 1;
d7839 1
a7839 1

d8441 1
a8441 1
	memmove (macro_list + i, macro_list + i + 1,
d8481 2
a8482 3
	      if (input_text[input_text_offset - 1] == '\n')
		input_text_offset--;
	      /* canon_white (word); */
d8624 1
a8624 1
	execute_string ("%s", execution_string);
d8716 1
a8716 5
		    {
		      input_text_offset++;
		      if (character == '\n')
			line_number++;
		    }
d8781 1
a8781 1
	  for (i = 10; whitespace (line[i]); i++);
d9003 1
a9003 1
  if (offset > itext->offset)
d9006 1
a9006 1
	(input_text, itext->offset, offset);
d9126 1
a9126 2
		      memmove (word + i, word + i + 1,
			       1 + strlen (word + i + 1));
d9149 1
a9149 4
	{
	  input_text_offset++;
	  if (character == '\n') line_number++;
	}
@


1.1.1.3
log
@Import of texinfo-3.9.
@
text
@a1 1
   $Id: makeinfo.c,v 1.37 1996/10/04 18:20:52 karl Exp $
d3 1
a3 1
   Copyright (C) 1987, 92, 93, 94, 95, 96 Free Software Foundation, Inc.
d5 24
a28 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
a31 3
int major_version = 1;
int minor_version = 67;

d59 1
a59 1
/* Define HAVE_MACROS to enable the macro facility of Texinfo.  Using this
d63 5
d138 3
a140 2
#define COMPILING_MAKEINFO
#include "makeinfo.h"
d183 63
d256 31
d312 12
d338 6
a502 3
/* Flag which tells us how to examine menu lines. */
int in_detailmenu = 0;

a550 1
  int in_fixed_width_font;
a559 2
extern void do_multitable ();

a580 1
void insert_string ();
d585 2
a586 2

void insert_self (), insert_space (), cm_ignore_line ();
d589 5
a593 5
  cm_TeX (), cm_asterisk (), cm_bullet (), cm_cite (),
  cm_code (), cm_copyright (), cm_ctrl (), cm_dfn (), cm_dircategory (),
  cm_direntry (), cm_dots (), cm_emph (), cm_enddots (),
  cm_kbd (), cm_angle_brackets (), cm_no_op (), cm_not_fixed_width (),
  cm_strong (), cm_var (), cm_w ();
a594 1
/* Sectioning.  */
d603 2
a604 3
/* All @@defxxx commands map to cm_defun, most accent commands map to
   cm_accent, most non-English letters map to cm_special_char.  */
void cm_defun (), cm_accent (), cm_special_char (), cm_dotless ();
d609 11
a619 11
  cm_enumerate (), cm_tab (), cm_table (), cm_itemx (), cm_noindent (),
  cm_setfilename (), cm_br (), cm_sp (), cm_page (), cm_group (),
  cm_center (), cm_include (), cm_bye (), cm_item (), cm_end (),
  cm_ifinfo (), cm_kindex (), cm_cindex (),
  cm_findex (), cm_pindex (), cm_vindex (), cm_tindex (),
  cm_synindex (), cm_printindex (), cm_minus (), cm_footnote (),
  cm_example (), cm_smallexample (), cm_lisp (), cm_format (), cm_exdent (),
  cm_defindex (), cm_defcodeindex (), cm_sc (), cm_result (), cm_expansion (),
  cm_equiv (), cm_print (), cm_error (), cm_point (), cm_today (),
  cm_flushleft (), cm_flushright (), cm_smalllisp (), cm_finalout (),
  cm_cartouche (), cm_detailmenu (), cm_multitable ();
d634 2
a635 2
void command_name_condition (), misplaced_brace (), cm_obsolete (),
     cm_ideprecated ();
d652 1
a652 5
  { "\t", insert_space, NO_BRACE_ARGS },
  { "\n", insert_space, NO_BRACE_ARGS },
  { " ", insert_self, NO_BRACE_ARGS },
  { "!", insert_self, NO_BRACE_ARGS },
  { "\"", insert_self, NO_BRACE_ARGS },
d655 4
a658 6
  { ",", cm_accent, BRACE_ARGS },
  { "-", cm_no_op, NO_BRACE_ARGS },
  { ".", insert_self, NO_BRACE_ARGS },
  { ":", cm_no_op, NO_BRACE_ARGS },
  { "=", insert_self, NO_BRACE_ARGS },
  { "?", insert_self, NO_BRACE_ARGS },
d660 3
a662 1
  { "^", insert_self, NO_BRACE_ARGS },
a663 13
  { "{", insert_self, NO_BRACE_ARGS },
  { "|", cm_no_op, NO_BRACE_ARGS },
  { "}", insert_self, NO_BRACE_ARGS },
  { "~", insert_self, NO_BRACE_ARGS },
  { "AA", insert_self, BRACE_ARGS },
  { "AE", insert_self, BRACE_ARGS },
  { "H", cm_accent, BRACE_ARGS },
  { "L", cm_special_char, BRACE_ARGS },
  { "O", cm_special_char, BRACE_ARGS },
  { "OE", insert_self, BRACE_ARGS },
  { "TeX", cm_TeX, BRACE_ARGS },
  { "aa", insert_self, BRACE_ARGS },
  { "ae", insert_self, BRACE_ARGS },
d669 3
a671 2
  { "asis", cm_no_op, BRACE_ARGS },
  { "b", cm_not_fixed_width, BRACE_ARGS },
a676 1
  { "centerchap", cm_unnumbered, NO_BRACE_ARGS },
d684 1
a684 1
  { "contents", cm_no_op, NO_BRACE_ARGS },
d686 1
a686 1
  { "ctrl", cm_obsolete, BRACE_ARGS },
d689 2
a691 2
  { "defcv", cm_defun, NO_BRACE_ARGS },
  { "defcvx", cm_defun, NO_BRACE_ARGS },
d694 2
a695 2
  { "defivar", cm_defun, NO_BRACE_ARGS },
  { "defivarx", cm_defun, NO_BRACE_ARGS },
d698 6
a703 3
  { "defmethod", cm_defun, NO_BRACE_ARGS },
  { "defmethodx", cm_defun, NO_BRACE_ARGS },
  { "defop", cm_defun, NO_BRACE_ARGS },
a705 5
  { "defopx", cm_defun, NO_BRACE_ARGS },
  { "defspec", cm_defun, NO_BRACE_ARGS },
  { "defspecx", cm_defun, NO_BRACE_ARGS },
  { "deftp", cm_defun, NO_BRACE_ARGS },
  { "deftpx", cm_defun, NO_BRACE_ARGS },
d710 12
d724 2
a725 10
  { "deftypevar", cm_defun, NO_BRACE_ARGS },
  { "deftypevarx", cm_defun, NO_BRACE_ARGS },
  { "deftypevr", cm_defun, NO_BRACE_ARGS },
  { "deftypevrx", cm_defun, NO_BRACE_ARGS },
  { "defun", cm_defun, NO_BRACE_ARGS },
  { "defunx", cm_defun, NO_BRACE_ARGS },
  { "defvar", cm_defun, NO_BRACE_ARGS },
  { "defvarx", cm_defun, NO_BRACE_ARGS },
  { "defvr", cm_defun, NO_BRACE_ARGS },
  { "defvrx", cm_defun, NO_BRACE_ARGS },
d727 1
a727 4
  { "detailmenu", cm_detailmenu, NO_BRACE_ARGS },
  { "dfn", cm_dfn, BRACE_ARGS },
  { "dircategory", cm_dircategory, NO_BRACE_ARGS },
  { "direntry", cm_direntry, NO_BRACE_ARGS },
a728 3
  { "dmn", cm_no_op, BRACE_ARGS },
  { "dotaccent", cm_accent, BRACE_ARGS },
  { "dotless", cm_dotless, BRACE_ARGS },
d730 1
a730 1
  { "email", cm_angle_brackets, BRACE_ARGS },
a732 1
  { "enddots", cm_enddots, BRACE_ARGS },
a736 1
  { "exclamdown", cm_special_char, BRACE_ARGS },
d739 1
a739 2
  { "file", cm_code, BRACE_ARGS },
  { "finalout", cm_no_op, NO_BRACE_ARGS },
d741 1
a743 2
  { "footnote", cm_footnote, NO_BRACE_ARGS}, /* self-arg eater */
  { "footnotestyle", cm_footnotestyle, NO_BRACE_ARGS },
d749 7
a755 2
  { "hyphenation", cm_no_op, BRACE_ARGS },
  { "i", cm_not_fixed_width, BRACE_ARGS },
d765 4
d772 4
d777 1
a777 1
  { "key", cm_angle_brackets, BRACE_ARGS },
d779 1
a779 1
  { "l", cm_special_char, BRACE_ARGS },
a780 1
  { "lowersections", cm_lowersections, NO_BRACE_ARGS },
d785 2
a786 1
  { "math", cm_no_op, BRACE_ARGS },
a788 1
  { "multitable", cm_multitable, NO_BRACE_ARGS },
d793 2
a794 4
  { "o", cm_special_char, BRACE_ARGS },
  { "oe", insert_self, BRACE_ARGS },
  { "page", cm_no_op, NO_BRACE_ARGS },
  { "paragraphindent", cm_paragraphindent, NO_BRACE_ARGS },
a796 1
  { "pounds", cm_special_char, BRACE_ARGS },
a799 1
  { "questiondown", cm_special_char, BRACE_ARGS },
d801 1
a801 1
  { "r", cm_not_fixed_width, BRACE_ARGS },
d804 1
a804 1
  { "refill", cm_no_op, NO_BRACE_ARGS },
d806 1
a806 2
  { "ringaccent", cm_accent, BRACE_ARGS },
  { "samp", cm_code, BRACE_ARGS },
d811 1
a811 1
  { "setchapterstyle", cm_obsolete, NO_BRACE_ARGS },
d814 1
a814 1
  { "shortcontents", cm_no_op, NO_BRACE_ARGS },
d817 1
a820 1
  { "ss", insert_self, BRACE_ARGS },
d826 1
a826 1
  { "summarycontents", cm_no_op, NO_BRACE_ARGS },
d829 1
a829 2
  { "t", cm_no_op, BRACE_ARGS },
  { "tab", cm_tab, NO_BRACE_ARGS },
a831 1
  { "tieaccent", cm_accent, BRACE_ARGS },
d833 1
a833 1
  { "titlefont", cm_not_fixed_width, BRACE_ARGS },
d835 1
a837 3
  { "u", cm_accent, BRACE_ARGS },
  { "ubaraccent", cm_accent, BRACE_ARGS },
  { "udotaccent", cm_accent, BRACE_ARGS },
a844 2
  { "url", cm_code, BRACE_ARGS },
  { "v", cm_accent, BRACE_ARGS },
d851 2
d854 14
a867 14
  /* Deprecated commands.  These used to be for italics.  */
  { "iappendix", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iappendixsubsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "ichapter", cm_ideprecated, NO_BRACE_ARGS },
  { "isection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "isubsubsection", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumbered", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsec", cm_ideprecated, NO_BRACE_ARGS },
  { "iunnumberedsubsubsec", cm_ideprecated, NO_BRACE_ARGS },
d870 4
a873 2
  { "infoinclude", cm_obsolete, NO_BRACE_ARGS },
  { "titlespec", cm_obsolete, NO_BRACE_ARGS },
d877 3
d903 1
a903 1

d917 1
a917 1
   Texinfo commands into wonderfully formatted output text. */
d982 1
a982 6
	    {
	      fprintf (stderr,
                       "%s: --fill-column arg must be numeric, not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
d993 1
a993 6
	    {
	      fprintf (stderr,
          "%s: --paragraph-indent arg must be numeric/none/asis, not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
a998 5
	    {
	      fprintf (stderr,
                       "%s: --error-limit arg must be numeric, not `%s'.\n", 
                       progname, optarg);
	    }
d1005 1
a1005 6
	    {
	      fprintf (stderr,
                     "%s: --reference-limit arg must be numeric, not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
d1011 1
a1011 6
	    {
	      fprintf (stderr,
          "%s: --footnote-style arg must be `separate' or `end', not `%s'.\n", 
                       progname, optarg);
	      usage (FATAL);
	    }
d1016 1
a1016 1
	  usage (NO_ERROR);
a1021 4
          puts ("Copyright (C) 1996 Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.");
d1026 1
a1026 1
	  usage (FATAL);
d1037 1
a1037 4
        {
          fprintf (stderr, "%s: missing file argument.\n", progname);
	  usage (FATAL);
        }
d1077 2
a1078 1
  printf ("GNU Makeinfo (Texinfo 3.9) %d.%d\n", major_version, minor_version);
d1080 1
a1080 1

d1087 14
d1148 2
a1149 3
/* If EXIT_VALUE is zero, print the full usage message to stdout.
   Otherwise, just say to use --help for more info.
   Then exit with EXIT_VALUE. */
d1151 2
a1152 1
usage (exit_value)
d1155 1
a1155 4
  if (exit_value != 0)
    fprintf (stderr, "Try `%s --help' for more information.\n", progname);
  else
    printf ("Usage: %s [OPTION]... TEXINFO-FILE...\n\
d1157 2
a1158 2
Translate Texinfo source documentation to a format suitable for reading\n\
with GNU Info.\n\
d1161 27
a1187 23
-D VAR                 define a variable, as with @@set.\n\
-E MACRO-OFILE	       process macros only, output texinfo source.\n\
-I DIR                 add DIR to the directory search list for @@include.\n\
-U VAR                 undefine a variable, as with @@clear.\n\
--error-limit NUM      quit after NUM errors (default %d).\n\
--fill-column NUM      break lines at NUM characters (default %d).\n\
--footnote-style STYLE output footnotes according to STYLE:\n\
                         `separate' to place footnotes in their own node,\n\
                         `end' to place the footnotes at the end of\n\
                         the node in which they are defined (the default).\n\
--help                 display this help and exit.\n\
--no-validate          suppress node cross-reference validation.\n\
--no-warn              suppress warnings (but not errors).\n\
--no-split             suppress splitting of large files.\n\
--no-headers           suppress node separators and Node: Foo headers.\n\
--output FILE, -o FILE output to FILE, and ignore any @@setfilename.\n\
--paragraph-indent NUM indent paragraphs with NUM spaces (default %d).\n\
--reference-limit NUM  complain about at most NUM references (default %d).\n\
--verbose              report about what is being done.\n\
--version              display version information and exit.\n\
\n\
Email bug reports to bug-texinfo@@prep.ai.mit.edu.\n\
",
d1192 6
a1197 2

/* Manipulating Lists */
d1222 7
a1228 2

/* Pushing and Popping Files */
d1373 11
a1383 2
    node_filename_stack = (char **)xrealloc
    (node_filename_stack, (node_filename_stack_size += 10) * sizeof (char *));
d1620 1
a1620 1

d1655 1
a1655 1
  putc ('\n', stderr);
d1703 1
a1703 1
  putc ('\n', stderr);
d1757 2
a1758 1
/* Return the next token as a string pointer.  We cons the string. */
d1795 1
a1795 3
  /* @@; and @@\ are not Texinfo commands, but they are listed here
     anyway.  I don't know why.  --karl, 10aug96.  */
  return member (character, "~{|}`^\\@@?=;:.-,*\'\" !\n\t");
d2001 1
a2001 1

d2011 1
a2014 1
  "",
a2024 6

  /* This is used for splitting the output file and for doing section
     headings.  It was previously initialized in `init_paragraph', but its
     use there loses with the `init_paragraph' calls done by the
     multitable code; the tag indices get reset to zero.  */
  output_position = 0;
d2027 3
a2029 3
/* We read in multiples of 4k, simply because it is a typical pipe size
   on unix systems. */
#define READ_BUFFER_GROWTH (4 * 4096)
d2050 1
a2050 1
      if (buffer_offset + (READ_BUFFER_GROWTH + 1) >= buffer_size)
d2052 1
a2052 1
	  xrealloc (buffer, (buffer_size += READ_BUFFER_GROWTH));
d2054 1
a2054 1
      count = fread (buffer + buffer_offset, 1, READ_BUFFER_GROWTH, stream);
d2092 2
a2093 3
  /* Try to load the file specified by NAME, concatenated with our
     various suffixes.  Prefer files like `makeinfo.texi' to
     `makeinfo'.  */
d2217 1
a2217 2
    printf ("Making %s file `%s' from `%s'.\n",
            no_headers ? "text" : "info", output_filename, input_filename);
d2246 1
a2246 1
     add_word_args ("This is Info file %s, produced by Makeinfo version %d.%d",
d2248 1
a2248 1
     add_word_args (" from the input file %s.\n", input_filename);
a2312 1
  in_detailmenu = 0;
d2322 1
d2395 1
a2395 1
	     that begins menu entries is "\n* ". */
d2403 1
a2403 2
	      if (!in_detailmenu)
		tem = glean_node_from_menu (1);
d2508 1
a2508 1
      line_error ("Unknown command `%s'", command);
a2559 1
  new->in_fixed_width_font = in_fixed_width_font;
d2574 1
a2574 1
      line_error ("Unmatched }");
a2579 1
  in_fixed_width_font = brace_stack->in_fixed_width_font;
d2730 1
a2730 1
  if (no_headers && (in_menu || in_detailmenu))
d2921 1
a2921 1
/* Insert CHARACTER into `output_paragraph'. */
a2933 9
/* Insert the null-terminated string STRING into `output_paragraph'.  */
void
insert_string (string)
     char *string;
{
  while (*string)
    insert (*string++);
}

d2990 2
a2991 8
      /* If we turned on the 8th bit for a space
         inside @@w, turn it back off for output.  */
      if (output_paragraph[i] & meta_character_bit)
        {
          int temp = UNMETA (output_paragraph[i]);
          if (temp == ' ')
  	    output_paragraph[i] &= 0x7f;
        }
d3275 31
a3382 1
  new->in_fixed_width_font = in_fixed_width_font;
a3397 1
  in_fixed_width_font = temp->in_fixed_width_font;
d3436 5
a3564 23
    case detailmenu:

      if (!in_menu)
	{
	  if (!no_headers)
	    close_paragraph ();

	  filling_enabled = no_indent = 0;
	  inhibit_paragraph_indentation = 1;

	  no_discard++;
	}

      in_detailmenu++;
      break;

    case direntry:
      close_single_paragraph ();
      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      insert_string ("START-INFO-DIR-ENTRY\n");
      break;

d3566 1
a3566 1
	 If you don't want filling, then use @@display. */
a3593 4
    case multitable:
      do_multitable ();
      break;

a3737 14
    case direntry:
      insert_string ("END-INFO-DIR-ENTRY\n\n");
      close_insertion_paragraph ();
      break;

    case detailmenu:
      in_detailmenu--;		/* No longer hacking menus. */
      if (!in_menu)
	{
	  if (!no_headers)
	    close_insertion_paragraph ();
	}
      break;

a3743 4
    case multitable:
      end_multitable ();
      break;

d3764 5
a3829 2

/* The Texinfo commands. */
d3831 1
a3831 8
/* Commands which insert their own names. */
void
insert_self (arg)
    int arg;
{
  if (arg == START)
    add_word (command);
}
d3833 1
d3835 1
a3835 2
insert_space (arg)
    int arg;
d3837 1
a3837 2
  if (arg == START)
    add_char (' ');
a3858 9
/* Insert ellipsis for sentence end. */
void
cm_enddots (arg)
     int arg;
{
  if (arg == START)
    add_word ("....");
}

a3883 1
/* Copyright symbol.  */
d3886 1
a3886 1
    int arg;
a3891 77
/* Accent commands that take explicit arguments.  */
void
cm_accent (arg)
    int arg;
{
  if (arg == START)
    {
      if (strcmp (command, "dotaccent") == 0)  /* overdot */
        add_char ('.');
      else if (strcmp (command, "H") == 0)     /* Hungarian umlaut */
        add_word ("''");
      else if (strcmp (command, "ringaccent") == 0)
        add_char ('*');
      else if (strcmp (command, "tieaccent") == 0)
        add_char ('[');
      else if (strcmp (command, "u") == 0)     /* breve */
        add_char ('(');
      else if (strcmp (command, "v") == 0)     /* hacek/check */
        add_char ('<');
    }
  else if (arg == END)
    {
      if (strcmp (command, "ubaraccent") == 0) /* underbar */
        add_char ('_');
      else if (strcmp (command, "udotaccent") == 0) /* underdot */
        add_word ("-.");
      else if (strcmp (command, ",") == 0)     /* cedilla */
        add_word (",");
    }
} 

/* Non-English letters/characters that don't insert themselves.  */
void
cm_special_char (arg)
{
  if (arg == START)
    {
      if ((*command == 'L' || *command == 'l'
           || *command == 'O' || *command == 'o')
          && command[1] == 0)
        {
          /* Lslash lslash Oslash oslash */
          add_char (*command);
          add_char ('/');
        }
      else if (strcmp (command, "exclamdown") == 0)
        add_char ('!');
      else if (strcmp (command, "pounds") == 0)
        add_char ('#');
      else if (strcmp (command, "questiondown") == 0)
        add_char ('?');
      else
        fprintf (stderr, "How did @@%s end up in cm_special_char?\n", command);
    }
}

/* Dotless i or j.  */
void
cm_dotless (arg, start, end)
    int arg, start, end;
{
  if (arg == END)
    {
      if (output_paragraph[start] != 'i' && output_paragraph[start] != 'j')
        /* This error message isn't perfect if the argument is multiple
           characters, but it doesn't seem worth getting right.  */
        line_error ("%c%s expects `i' or `j' as argument, not `%c'",
                    COMMAND_PREFIX, command, output_paragraph[start]);

      else if (end - start != 1)
        line_error ("%c%s expects a single character `i' or `j' as argument",
		    COMMAND_PREFIX, command);

      /* We've already inserted the `i' or `j', so nothing to do.  */
    }
}

d3923 3
d3929 1
a3929 3

      if (!printing_index)
	add_char ('`');
d3933 2
a3934 2
      if (!printing_index)
	add_char ('\'');
d3939 14
d3956 1
a3956 4
  /* People use @@kbd in an example to get the "user input" font.
     We don't want quotes in that case.  */
  if (!in_fixed_width_font)
    cm_code (arg);
d3960 1
a3960 1
cm_angle_brackets (arg)
a3962 1
  add_char (arg == START ? '<' : '>');
d3965 1
a3965 1
/* Convert the character at position into a true control character. */
d3990 1
a3990 10
/* Handle a command that switches to a non-fixed-width font.  */
void
not_fixed_width (arg)
     int arg;
{
  if (arg == START)
    in_fixed_width_font = 0;
}

/* Small caps in makeinfo has to do just all caps. */
a3994 2
  not_fixed_width (arg);

a4010 2
  not_fixed_width (arg);

d4053 16
a4068 1
/* No highlighting, but argument switches fonts.  */
d4070 1
a4070 1
cm_not_fixed_width (arg, start, end)
a4072 1
  not_fixed_width (arg);
d4075 1
a4075 1
/* Various commands are NOP's. */
d4077 16
a4092 1
cm_no_op ()
a4389 10
/* The command still works, but prints a warning message in addition. */
void
cm_ideprecated (arg, start, end)
     int arg, start, end;
{
  warning ("The command `%c%s' is obsolete; use `%c%s' instead",
	   COMMAND_PREFIX, command, COMMAND_PREFIX, command + 1);
  sectioning_underscore (command + 1);
}

d4507 2
a4508 1

d4981 1
a4981 1
   Scan through the list of tag entries touching the Prev, Next, and Up
d5450 1
a5450 1
  temp->containing_node = strdup (current_node ? current_node : "");
a5627 12
void
cm_detailmenu ()
{
  if (current_node == (char *)NULL)
    {
      warning ("%cmenu seen before a node has been defined", COMMAND_PREFIX);
      warning ("Creating `TOP' node.");
      execute_string ("@@node Top");
    }
  begin_insertion (detailmenu);
}

d5772 1
a5772 1

a5829 9
cm_direntry ()
{
  if (no_headers)
    command_name_condition ();
  else
    begin_insertion (direntry);
}

void
a5878 6
cm_multitable ()
{
  begin_insertion (multitable);	/* @@@@ */
}

void
d5916 2
a5917 1

d5925 2
a5926 2
typedef struct defines {
  struct defines *next;
d6044 1
a6044 1
   The syntax @@ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands
d6255 7
a6261 2

/* Execution of random text not in file. */
d6372 5
a6376 34

/* Return what would be output for STR, i.e., expand Texinfo commands.
   If IMPLICIT_CODE is set, expand @@code{STR}.  */

char *
expansion (str, implicit_code)
    char *str;
    int implicit_code;
{
  int length;
  char *result;

  /* Inhibit any real output.  */
  int start = output_paragraph_offset;
  int saved_paragraph_is_open = paragraph_is_open;

  inhibit_output_flushing ();
  execute_string (implicit_code ? "@@code{%s}" : "%s", str);
  uninhibit_output_flushing ();

  /* Copy the expansion from the buffer.  */
  length = output_paragraph_offset - start;
  result = xmalloc (1 + length);
  memcpy (result, (char *) (output_paragraph + start), length);
  result[length] = 0;
  
  /* Pretend it never happened.  */
  output_paragraph_offset = start;
  paragraph_is_open = saved_paragraph_is_open;

  return result;
}

/* @@itemx, @@item. */
a6411 13
	case multitable:
	  multitable_item ();
	  /* Ultra special hack.  It appears that some people incorrectly
	     place text directly after the @@item, instead of on a new line
	     by itself.  This happens to work in TeX, so I make it work
	     here. */
	  if (*rest_of_line)
	    {
	      line_number--;
	      input_text_offset = original_input_text_offset;
	    }
	  break;

d6552 1
d6740 3
a6742 5
              /* Do not back up if we're looking at a }; since the only
                 valid }'s are those matched with {'s, we want to give
                 an error.  If we back up, we go into an infinite loop.  */
	      if (!c || whitespace (c) || DEFUN_SELF_DELIMITING (c)
	          || c == '{')
d6748 1
a6748 1
	      /* If we encounter a command embedded within a token,
d6975 21
a6995 23
  if (!macro_expansion_output_stream)
    /* Make an entry in the appropriate index unless we are just
       expanding macros. */
    switch (base_type)
      {
      case deffn:
      case deftypefn:
        execute_string ("%cfindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      case defvr:
      case deftypevr:
      case defcv:
        execute_string ("%cvindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      case defop:
      case deftypemethod:
        execute_string ("%cfindex %s on %s\n",
                        COMMAND_PREFIX, defined_name, type_name);
        break;
      case deftp:
        execute_string ("%ctindex %s\n", COMMAND_PREFIX, defined_name);
        break;
      }
d7070 1
a7147 20
/* @@dircategory LINE  outputs  INFO-DIR-SECTION LINE,
   but not if --no-headers.  */

void
cm_dircategory ()
{
  char *line, *p;

  get_rest_of_line (&line);;

  if (! no_headers)
    {
      insert_string ("INFO-DIR-SECTION ");
      insert_string (line);
      insert ('\n');
    }

  free (line);
}

d7270 6
d7293 1
a7293 1
cm_include ()
d7360 15
d7381 12
a7392 1

d7820 1
d7840 1
a7840 1
	  (strcmp (array[i]->entry, array[i + 1]->entry) != 0))
a7908 8

      /* Maybe should set line number to the defining_line?  Any errors
         have already been given, though, I think.  */

      /* If this particular entry should be printed as a "code" index,
	 then wrap the entry with "@@code{...}". */
      array[count - 1]->entry = expansion (temp->entry, index->code);
      
d7931 2
a7932 4
  unsigned line_length;
  char *line;
  int saved_inhibit_paragraph_indentation = inhibit_paragraph_indentation;
  int saved_filling_enabled = filling_enabled;
d7947 2
a7948 3
  /* Do this before sorting, so execute_string in index_element_compare
     will give the same results as when we actually print.  */
  printing_index = 1;
a7950 2
  array = sort_index (index);

d7954 2
a7959 4
  /* This will probably be enough.  */
  line_length = 100;
  line = xmalloc (line_length);
  
d7962 19
a7980 17
      /* A pathological document might have an index entry outside of any
         node.  Don't crash.  Perhaps should warn.  */
      char *index_node = index->node ? index->node : "(none)";
      unsigned new_length = strlen (index->entry) + strlen (index_node);
      
      if (new_length > line_length)
        {
          line_length = new_length + 6; /* * : .\0 */
          line = xrealloc (line, line_length);
        }

      /* Print the entry, nicely formatted.  We've already expanded any
         commands, including any implicit @@code.  Thus, can't call
         execute_string, since @@@@ has turned into @@.  */
      sprintf (line, "* %-37s  %s.\n", index->entry, index_node);
      line[2 + strlen (index->entry)] = ':';
      insert_string (line);
d7982 1
a7982 2
      /* Previous `output_paragraph' from growing to the size of the
         whole index.  */
a7985 2
  free (line);
  
d7987 1
a7987 1
  me_inhibit_expansion--;
d7993 2
a7994 2
  filling_enabled = saved_filling_enabled;
  inhibit_paragraph_indentation = saved_inhibit_paragraph_indentation;
d7996 1
d7998 5
a8002 1
/* User-defined commands. */
d8026 7
d8117 1
a8117 2
  /* If set on command line, do not change the footnote style.  */
  if (!footnote_style_preset && set_footnote_style (arg) != 0)
d8288 1
d8343 2
a8344 1

d9178 1
a9178 1

@


1.1.1.4
log
@Import of FSF texinfo 3.11
@
text
@d1 2
a2 2
/* Makeinfo -- convert Texinfo source files into Info files.
   $Id: makeinfo.c,v 1.47 1997/07/31 21:36:27 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
d20 1
a20 6
   Makeinfo was authored by Brian Fox (bfox@@ai.mit.edu). */

/* Indent #pragma so that older Cpp's don't try to parse it. */
#ifdef _AIX
 #pragma alloca
#endif /* _AIX */
d23 1
a23 1
int minor_version = 68;
d25 1
a25 42
#include "system.h"
#include "getopt.h"

#ifdef TM_IN_SYS_TIME
#include <sys/time.h>
#else
#include <time.h>
#endif /* !TM_IN_SYS_TIME */

#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
char *alloca ();
#  endif
# endif
#endif

/* We'd like to take advantage of _doprnt if it's around, a la error.c,
   but then we'd have no VA_SPRINTF.  */
#if HAVE_VPRINTF
# if __STDC__
#  include <stdarg.h>
#  define VA_START(args, lastarg) va_start(args, lastarg)
# else
#  include <varargs.h>
#  define VA_START(args, lastarg) va_start(args)
# endif
# define VA_FPRINTF(file, fmt, ap) vfprintf (file, fmt, ap)
# define VA_SPRINTF(str, fmt, ap) vsprintf (str, fmt, ap)
#else /* not HAVE_VPRINTF */
# define VA_START(args, lastarg)
# define va_alist a1, a2, a3, a4, a5, a6, a7, a8
# define va_dcl char *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;
# define va_end(args)
#endif

/* You can change some of the behavior of Makeinfo by changing the
d53 1
a53 2
   facility, users can create their own command procedures with
   arguments.   Must always be defined.  */
d57 69
d129 1
a129 1
/* Nonzero means that we are currently hacking the insides of an
d133 1
a133 1
/* Nonzero means that start_paragraph () MUST be called before we pay
d137 1
a137 1
/* Nonzero means a string is in execution, as opposed to a file. */
d142 1
a142 1
   of the input text to.  The result is another texinfo file, but
a145 1
char *macro_expansion_filename;
d150 2
a151 2
  char *pointer;                /* Pointer to the input text. */
  int offset;                   /* Offset of the last character output. */
d157 3
a159 2
/* Nonzero means to inhibit writing macro expansions to the output
   stream, because it has already been written. */
d168 2
d172 3
a174 3
/*                                                                  */
/*                          Global Variables                        */
/*                                                                  */
d180 1
a180 1
/* Return nonzero if STRING is the text at input_text + input_text_offset,
d199 3
d208 2
a209 1
/* Nonzero indicates that filling will take place on long lines. */
d212 1
a212 1
/* Nonzero means that words are not to be split, even in long lines.  This
d216 1
a216 1
/* Nonzero indicates that filling a line also indents the new line. */
d229 1
a229 1
/* Nonzero means that the use of paragraph_start_indent is inhibited.
d243 1
a243 1
/* Nonzero indicates that indentation is temporarily turned off. */
d246 1
a246 1
/* Nonzero means forcing output text to be flushright. */
d249 1
a249 1
/* Nonzero means that the footnote style for this document was set on
d253 1
a253 1
/* Nonzero means that we automatically number footnotes that have no
d270 1
a270 1
  { '\n', COMMAND_PREFIX, 'n', 'o', 'd', 'e', ' ', 0 };
d274 1
a274 1
  { '\n', COMMAND_PREFIX, 'm', 'e', 'n', 'u', 0 };
d279 1
a279 1
      's', 'e', 't', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', 0 };
d309 9
a317 9
  char *node;           /* name of this node. */
  char *prev;           /* name of "Prev:" for this node. */
  char *next;           /* name of "Next:" for this node. */
  char *up;             /* name of "Up:" for this node.   */
  int position;         /* output file position of this node. */
  int line_no;          /* defining line in source file. */
  char *filename;       /* The file that this node was found in. */
  int touched;          /* Nonzero means this node has been referenced. */
  int flags;            /* Room for growth.  Right now, contains 1 bit. */
d327 2
a328 2
#define NO_WARN    0x8
#define IS_TOP     0x10
a331 6
/* Values for calling handle_variable_internal (). */
#define SET     1
#define CLEAR   2
#define IFSET   3
#define IFCLEAR 4

d333 2
a334 2
#define ME_RECURSE      0x01
#define ME_QUOTE_ARG    0x02
d338 7
a344 7
  char *name;                   /* Name of the macro. */
  char **arglist;               /* Args to replace when executing. */
  char *body;                   /* Macro body. */
  char *source_file;            /* File where this macro is defined. */
  int source_lineno;            /* Line number within FILENAME. */
  int inhibited;                /* Nonzero means make find_macro () fail. */
  int flags;                    /* ME_RECURSE, ME_QUOTE_ARG, etc. */
d364 6
a369 6
  char *node;                   /* Name of node referred to. */
  char *containing_node;        /* Name of node containing this reference. */
  int line_no;                  /* Line number where the reference occurs. */
  int section;                  /* Section level where the reference occurs. */
  char *filename;               /* Name of file where the reference occurs. */
  enum reftype type;            /* Type of reference, either menu or note. */
d381 1
a381 1
/* Nonzero means that we have seen "@@top" once already. */
d384 1
a384 1
/* Nonzero means that we have seen a non-"@@top" node already. */
a388 3
/* Default is to remove output if there were errors.  */
int force = 0;

d395 1
a395 1
/* Nonzero means do not output "Node: Foo" for node separations. */
d404 1
a404 1
/* Nonzero means print out information about what is going on when it
d408 1
a408 1
/* Nonzero means to be relaxed about the input file.  This is useful when
d434 5
d444 1
a444 1
void remember_error (), flush_file_stack ();
d452 1
a457 6
char **get_brace_args ();
char *expansion ();
int array_len ();
void free_array ();
static int end_of_sentence_p ();
static void isolate_nodename ();
d461 1
a461 1
void add_word (), add_char (), insert (), flush_output ();
d465 1
a465 1
void do_flush_right_indentation (), discard_insertions ();
a466 8
#if defined (VA_FPRINTF) && __STDC__
/* Unfortunately we must use prototypes if we are to use <stdarg.h>.  */
void add_word_args (char *, ...);
void execute_string (char *, ...);
#else
void add_word_args ();
void execute_string ();
#endif /* will not use prototypes */
d474 2
a475 2
  cm_kbd (), cm_key (), cm_no_op (), cm_no_op_line_arg (),
  cm_not_fixed_width (), cm_strong (), cm_var_sc (), cm_w (), cm_image ();
d486 1
a486 1
/* All @@def... commands map to cm_defun, most accent commands map to
d492 1
a492 2
  cm_inforef (), cm_uref (), cm_email (), cm_quotation (),
  cm_display (), cm_itemize (),
d496 1
a496 1
  cm_ifinfo (), cm_ifnothtml (), cm_ifnottex (), cm_kindex (), cm_cindex (),
d500 1
a500 1
  cm_defindex (), cm_defcodeindex (), cm_result (), cm_expansion (),
d535 1
a535 1
static COMMAND command_table[] = {
d635 1
a635 1
  { "email", cm_email, BRACE_ARGS },
a657 1
  { "html", command_name_condition, NO_BRACE_ARGS },
a663 3
  { "ifnothtml", cm_ifnothtml, NO_BRACE_ARGS },
  { "ifnotinfo", command_name_condition, NO_BRACE_ARGS },
  { "ifnottex", cm_ifnottex, NO_BRACE_ARGS },
a666 1
  { "image", cm_image, BRACE_ARGS },
d673 1
a673 2
  { "kbdinputstyle", cm_no_op_line_arg, NO_BRACE_ARGS },
  { "key", cm_key, BRACE_ARGS },
d678 1
d680 1
d709 1
a709 1
  { "sc", cm_var_sc, BRACE_ARGS },
a750 1
  { "uref", cm_uref, BRACE_ARGS },
d754 1
a754 1
  { "var", cm_var_sc, BRACE_ARGS },
d775 1
a775 1
  /* Now @@include does what this was used to. */
d779 1
a779 2
  { NULL, NULL, NO_BRACE_ARGS }
};
d783 4
a786 5
  { "error-limit", 1, 0, 'e' },                 /* formerly -el */
  { "fill-column", 1, 0, 'f' },                 /* formerly -fc */
  { "footnote-style", 1, 0, 's' },              /* formerly -ft */
  { "force", 0, 0, 'F' },                       /* do not remove output */
  { "no-headers", 0, &no_headers, 1 },          /* do not output Node: foo */
d788 4
a791 3
  { "no-validate", 0, &validating, 0 },         /* formerly -nv */
  { "no-split", 0, &splitting, 0 },             /* formerly -ns */
  { "no-warn", 0, &print_warnings, 0 },         /* formerly -nw */
d793 1
d797 3
a799 3
  { "paragraph-indent", 1, 0, 'p' },            /* formerly -pi */
  { "reference-limit", 1, 0, 'r' },             /* formerly -rl */
  { "verbose", 0, &verbose_mode, 1 },           /* formerly -verbose */
d805 5
a809 8
/* **************************************************************** */
/*                                                                  */
/*                      Error Handling                              */
/*                                                                  */
/* **************************************************************** */

/* Number of errors encountered. */
int errors_printed = 0;
a810 110
/* Print the last error gotten from the file system. */
int
fs_error (filename)
     char *filename;
{
  remember_error ();
  perror (filename);
  return (0);
}

/* Print an error message, and return false. */
void
#if defined (VA_FPRINTF) && __STDC__
error (char *format, ...)
#else
error (format, va_alist)
     char *format;
     va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  putc ('\n', stderr);
}

/* Just like error (), but print the line number as well. */
void
#if defined (VA_FPRINTF) && __STDC__
line_error (char *format, ...)
#else
line_error (format, va_alist)
   char *format;
   va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();
  fprintf (stderr, "%s:%d: ", input_filename, line_number);

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  fprintf (stderr, ".\n");
}

void
#if defined (VA_FPRINTF) && __STDC__
warning (char *format, ...)
#else
warning (format, va_alist)
     char *format;
     va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  if (print_warnings)
    {
      fprintf (stderr, _("%s:%d: warning: "), input_filename, line_number);

      VA_START (ap, format);
#ifdef VA_FPRINTF
      VA_FPRINTF (stderr, format, ap);
#else
      fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
      va_end (ap);

      fprintf (stderr, ".\n");
    }
}


/* Remember that an error has been printed.  If more than
   max_error_level have been printed, then exit the program. */
void
remember_error ()
{
  errors_printed++;
  if (max_error_level && (errors_printed > max_error_level))
    {
      fprintf (stderr, _("Too many errors!  Gave up.\n"));
      flush_file_stack ();
      cm_bye ();
      exit (FATAL);
    }
}

d812 3
a814 3
/*                                                                  */
/*                      Main ()  Start of code                      */
/*                                                                  */
a831 11
#ifdef HAVE_SETLOCALE
  /* Do not use LC_ALL, because LC_NUMERIC screws up the scanf parsing
     of the argument to @@multicolumn.  */
  setlocale (LC_TIME, "");
  setlocale (LC_MESSAGES, "");
#endif

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d833 9
a841 2
  while ((c = getopt_long (argc, argv, "D:e:E:f:I:o:p:P:r:s:U:V",
                           long_options, &ind)) != EOF)
d844 1
a844 1
        c = long_options[ind].val;
d847 77
a923 74
        {
        case 'D':
        case 'U':
          /* User specified variable to set or clear. */
          handle_variable_internal ((c == 'D') ? SET : CLEAR, optarg);
          break;

        case 'e':
          /* User specified error level. */
          if (sscanf (optarg, "%d", &max_error_level) != 1)
            {
              fprintf (stderr,
                      _("%s: %s arg must be numeric, not `%s'.\n"),
                      "--error-limit", progname, optarg);
              usage (stderr, FATAL);
            }
          break;

        case 'E':
          /* User specified a macro expansion output file. */
          if (!macro_expansion_output_stream)
            {
              macro_expansion_filename = optarg;
              macro_expansion_output_stream
                = strcmp (optarg, "-") == 0 ? stdout : fopen (optarg, "w");
              if (!macro_expansion_output_stream)
                error (_("Couldn't open macro expansion output `%s'"), optarg);
            }
          else
            error (_("Cannot specify more than one macro expansion output"));
          break;

        case 'f':
          /* User specified fill_column. */
          if (sscanf (optarg, "%d", &fill_column) != 1)
            {
              fprintf (stderr,
                       _("%s: %s arg must be numeric, not `%s'.\n"), 
                       "--fill-column", progname, optarg);
              usage (FATAL);
            }
          break;

        case 'F':
          force++; /* Do not remove erroneous output.  */
          break;
          
        case 'h':
          usage (NO_ERROR);
          break;

        case 'I':
          /* Append user-specified dir to include file path. */
          if (!include_files_path)
            include_files_path = xstrdup (".");

          include_files_path = (char *)
            xrealloc (include_files_path,
                      2 + strlen (include_files_path) + strlen (optarg));
          strcat (include_files_path, ":");
          strcat (include_files_path, optarg);
          break;

        case 'o':
          /* User specified output file. */
          command_output_filename = xstrdup (optarg);
          break;

        case 'p':
          /* User specified paragraph indent (paragraph_start_index). */
          if (set_paragraph_indent (optarg) < 0)
            {
              fprintf (stderr,
   _("%s: --paragraph-indent arg must be numeric/`none'/`asis', not `%s'.\n"), 
d925 10
a934 42
              usage (FATAL);
            }
          break;

        case 'P':
          /* Prepend user-specified include dir to include path. */
          if (!include_files_path)
            {
              include_files_path = xstrdup (optarg);
              include_files_path = (char *) xrealloc (include_files_path,
                           strlen (include_files_path) + 3); /* 3 for ":.\0" */
              strcat (include_files_path, ":.");
            }
          else
            {
              char *tmp = xstrdup (include_files_path);
              include_files_path = (char *) xrealloc (include_files_path,
          strlen (include_files_path) + strlen (optarg) + 2); /* 2 for ":\0" */
              strcpy (include_files_path, optarg);
              strcat (include_files_path, ":");
              strcat (include_files_path, tmp);
              free (tmp);
            }
          break;
 
        case 'r':
          /* User specified reference warning limit. */
          if (sscanf (optarg, "%d", &reference_warning_limit) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"), 
                     "--reference-limit", progname, optarg);
              usage (FATAL);
            }
          break;

        case 's':
          /* User specified footnote style. */
          if (set_footnote_style (optarg) < 0)
            {
              fprintf (stderr,
          _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"), 
d936 13
a948 9
              usage (FATAL);
            }
          footnote_style_preset = 1;
          break;

        case 'V':
          /* User requested version info. */
          print_version_info ();
          puts (_("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d951 8
a958 8
For more information about these matters, see the files named COPYING."));
          exit (NO_ERROR);
          break;

        case '?':
          usage (FATAL);
          break;
        }
d965 1
a965 1
        reading_from_stdin = 1;
d968 2
a969 2
          fprintf (stderr, _("%s: missing file argument.\n"), progname);
          usage (FATAL);
d981 2
a982 1
      /* If the user has not specified an output file, use stdout. */
d984 1
a984 1
        command_output_filename = xstrdup ("-");
d995 1
a995 1
        convert_from_file (argv[optind++]);
d1010 54
a1063 2
  printf (_("makeinfo (GNU %s %s) %d.%d\n"), PACKAGE, VERSION,
          major_version, minor_version);
d1074 1
a1074 1
    fprintf (stderr, _("Try `%s --help' for more information.\n"), progname);
d1076 1
a1076 1
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n\
d1083 2
a1084 3
-E MACRO-OFILE         process macros only, output texinfo source.\n\
-I DIR                 append DIR to the @@include directory search path.\n\
-P DIR                 prepend DIR to the @@include directory search path.\n\
a1091 1
--force                preserve output even if errors.\n\
d1098 1
a1098 3
--paragraph-indent VAL indent paragraphs with VAL spaces (default %d).\n\
                         if VAL is `none', do not indent; if VAL is `asis',\n\
                         preserve any existing indentation.\n\
d1104 3
a1106 3
"),
           progname, paragraph_start_indent,
           fill_column, max_error_level, reference_warning_limit);
d1146 1
a1146 1
  int file = -1, count = 0;
d1170 1
a1170 2
#if defined (VMS) || defined (WIN32)
#ifdef VMS
a1171 3
#else /* WIN32 */
  while ((n = read (file, result + count, 1)) > 0)
#endif /* WIN32 */
d1174 1
a1174 1
#else /* !VMS && !WIN32 */
d1177 1
a1177 1
#endif /* !VMS && !WIN32 */
d1181 1
a1181 1
        free (result);
d1184 1
a1184 1
        free (fullpath);
d1187 1
a1187 1
        close (file);
d1197 1
a1197 1
  node_filename = xstrdup (fullpath);
d1230 1
a1230 1
    abort ();                   /* My fault.  I wonder what I did? */
d1309 1
a1309 1
  basename = xstrdup (basename);
d1318 1
a1318 1
      *temp = 0;
d1346 1
a1346 1
      result[i] = 0;
d1360 1
a1360 1
      return (xstrdup (name + i + 1));
d1362 1
a1362 1
  return (xstrdup (name));
d1380 4
a1383 4
        {
          free (filename);
          filename = xstrdup ("noname.texi");
        }
d1386 2
a1387 2
        if (filename[i] == '.')
          break;
d1390 1
a1390 1
        i = strlen (filename);
d1393 1
a1393 1
        filename = (char *)xrealloc (filename, i + 6);
d1397 1
a1397 1
        
d1412 1
a1412 1
        i--;
d1415 1
a1415 1
        i++;
d1434 1
a1434 1
    return (xstrdup (""));
d1440 1
a1440 1
    return (xstrdup (filename));
d1450 1
a1450 1
        if (!getwd (localdir))
d1452 5
a1456 5
          {
            fprintf (stderr, _("%s: getwd: %s, %s\n"),
                     progname, filename, localdir);
            exit (1);
          }
d1460 1
a1460 1
      result = xstrdup (localdir);
a1464 1
#ifndef WIN32
d1466 11
a1476 11
        {
          /* Return the concatenation of the environment variable HOME
             and the rest of the string. */
          char *temp_home;

          temp_home = (char *) getenv ("HOME");
          result = (char *)xmalloc (strlen (&filename[1])
                                    + 1
                                    + temp_home ? strlen (temp_home)
                                    : 0);
          *result = 0;
d1478 2
a1479 2
          if (temp_home)
            strcpy (result, temp_home);
d1481 2
a1482 2
          strcat (result, &filename[1]);
        }
d1484 25
a1508 25
        {
          struct passwd *user_entry;
          int i, c;
          char *username = (char *)xmalloc (257);

          for (i = 1; (c = filename[i]); i++)
            {
              if (c == '/')
                break;
              else
                username[i - 1] = c;
            }
          if (c)
            username[i - 1] = 0;

          user_entry = getpwnam (username);

          if (!user_entry)
            return (xstrdup (filename));

          result = (char *)xmalloc (1 + strlen (user_entry->pw_dir)
                                    + strlen (&filename[i]));
          strcpy (result, user_entry->pw_dir);
          strcat (result, &filename[i]);
        }
a1509 1
#endif /* not WIN32 */
d1521 133
a1653 3
/*                                                                  */
/*                      Hacking Tokens and Strings                  */
/*                                                                  */
d1671 1
a1671 1
        line_number++;
d1673 1
a1673 1
      result = xstrdup (" ");
d1679 2
a1680 2
               && (character = curchar ())
               && command_char (character));
d1684 1
a1684 1
  result[i] = 0;
d1688 1
a1688 1
/* Return nonzero if CHARACTER is self-delimiting. */
d1712 4
a1715 4
        {
          strcpy (string, string + x);
          break;
        }
d1722 1
a1722 1
  string[len + 1] = 0;
d1742 7
a1748 7
        {
          temp[temp_index - 1] = ' ';
          while ((c = string[string_index]) && (c == ' ' ||
                                                c == '\t' ||
                                                c == '\n'))
            string_index++;
        }
d1750 1
a1750 1
  temp[temp_index] = 0;
d1776 4
a1779 4
        {
          line_error (_("Expected `%s'"), string);
          return;
        }
d1813 1
a1813 1
  (*string)[len] = 0;
d1827 1
a1827 2
get_until_in_line (expand, match, string)
     int expand;
d1830 1
a1830 24
  int real_bottom = size_of_input_text;
  int limit = search_forward ("\n", input_text_offset);
  if (limit < 0)
    limit = size_of_input_text;

  /* Replace input_text[input_text_offset .. limit-1] with its macro
     expansion (actually, we expand all commands).  This allows the node
     names themselves to be constructed via a macro, as in:
        @@macro foo{p, q}
        Together: \p\ & \q\.
        @@end macro

        @@node @@foo{A,B}, next, prev, top
     
     Otherwise, the `,' separating the macro args A and B is taken as
     the node argument separator, so the node name is `@@foo{A'.  This
     expansion is only necessary on the first call, since we expand the
     whole line then.
     
     Furthermore, if we're executing a string, don't do it -- we'll end
     up shrinking the execution string which is currently aliased to
     `input_text', so it might get moved, and not updated in the
     `execution_strings' array.  This happens when processing the
     (synthetic) Overview-Footnotes node in the Texinfo manual.  */
d1832 5
a1836 28
  if (expand && !executing_string)
    {
      char *xp;
      unsigned xp_len, new_len;
      
      /* Get original string from input.  */
      unsigned raw_len = limit - input_text_offset;
      char *str = xmalloc (raw_len + 1);
      strncpy (str, input_text + input_text_offset, raw_len);
      str[raw_len] = 0;
      
      /* Expand it.  */
      xp = expansion (str, 0);
      xp_len = strlen (xp);
      free (str);
      
      /* Plunk the expansion into the middle of input_text.  */
      str = xstrdup (input_text + limit);
      new_len = input_text_offset + xp_len + strlen (str) + 1;
      input_text = xrealloc (input_text, new_len);
      strcpy (input_text + input_text_offset, xp);
      strcat (input_text, str);
      free (str);
      free (xp);
      
      limit += xp_len - raw_len;
      real_bottom += xp_len - raw_len;
    }
d1838 1
a1838 1
  size_of_input_text = limit;
d1850 1
a1850 1
  if (curchar () == '\n')       /* as opposed to the end of the file... */
d1866 1
a1866 1
        line_number--;
a1875 1
  char *temp;
d1878 1
d1883 1
a1883 1
        brace++;
d1885 1
a1885 1
        brace--;
d1887 1
a1887 1
        line_number++;
d1890 2
a1891 2
          (brace == 0 && strncmp (input_text + i, match, match_len) == 0))
        break;
d1897 1
a1897 1
  temp[match_len] = 0;
d1903 3
a1905 3
/*                                                                  */
/*                      Converting the File                         */
/*                                                                  */
d1937 1
a1937 1
/* Convert the Texinfo file coming from the open stream STREAM.  Assume the
d1957 2
a1958 2
        buffer = (char *)
          xrealloc (buffer, (buffer_size += READ_BUFFER_GROWTH));
d1963 4
a1966 4
        {
          perror (name);
          exit (FATAL);
        }
d1970 1
a1970 1
        break;
d1976 2
a1977 2
  input_filename = xstrdup (name);
  node_filename = xstrdup (name);
d2007 1
a2007 1
        break;
d2010 5
a2014 5
        {
          fs_error (filename);
          free (filename);
          return;
        }
d2046 1
a2046 1
        search_forward (setfilename_search, input_text_offset);
d2049 3
a2051 3
          ((input_text_offset > 0) &&
           (input_text[input_text_offset -1] == '\n')))
        break;
d2053 1
a2053 1
        input_text_offset++;
d2059 1
a2059 1
        {
d2061 2
a2062 2
          error (_("No `%s' found in `%s'"), setfilename_search, name);
          goto finished;
d2064 1
a2064 1
          register int i, end_of_first_line;
d2066 19
a2084 19
          /* Find the end of the first line in the file. */
          for (i = 0; i < size_of_input_text - 1; i++)
            if (input_text[i] == '\n')
              break;

          end_of_first_line = i + 1;

          input_text_offset = 0;

          for (i = 0; i < end_of_first_line; i++)
            {
              if ((input_text[i] == '\\') &&
                  (strncmp (input_text + i + 1, "include", 7) == 0))
                {
                  input_text_offset = end_of_first_line;
                  break;
                }
            }
          command_output_filename = output_name_from_input_name (name);
d2086 1
a2086 1
        }
d2096 1
a2096 1
        discard_until ("\n");
d2098 1
a2098 1
        input_text_offset = 0;
d2106 2
a2107 1
  if (real_output_filename && strcmp (real_output_filename, "-") == 0)
d2109 1
a2109 8
      if (macro_expansion_filename
          && strcmp (macro_expansion_filename, "-") == 0)
        {
          fprintf (stderr, _("%s: Skipping macro expansion to stdout as Info output is going there.\n"),
                   progname);
          macro_expansion_output_stream = NULL;
        }
      real_output_filename = xstrdup (real_output_filename);
d2111 1
a2111 1
      splitting = 0;            /* Cannot split when writing to stdout. */
d2116 1
a2116 1
        real_output_filename = expand_filename (output_filename, name);
d2118 1
a2118 1
        real_output_filename = xstrdup (real_output_filename);
d2124 1
a2124 1
    printf (_("Making %s file `%s' from `%s'.\n"),
d2138 1
a2138 1
    pretty_output_filename = xstrdup ("stdout");
d2149 1
a2149 1
        line_number++;
d2154 3
a2156 3
     add_word_args (_("This is Info file %s, produced by Makeinfo version %d.%d"),
                     output_filename, major_version, minor_version);
     add_word_args (_(" from the input file %s.\n"), input_filename);
a2162 1
  discard_insertions (0);
d2168 1
a2168 12
    {
      fclose (macro_expansion_output_stream);
      if (errors_printed && !force
          && strcmp (macro_expansion_filename, "-") != 0
          && strcmp (macro_expansion_filename, "/dev/null") != 0)
        {
          fprintf (stderr, _("%s: Removing macro output file `%s' due to errors; use --force to preserve.\n"),
                   progname, macro_expansion_filename);
          if (unlink (macro_expansion_filename) < 0)
            perror (macro_expansion_filename);
        }
    }
d2171 1
a2171 1
  if (output_stream)
d2176 5
a2180 5
        {
          tag_table = (TAG_ENTRY *) reverse_list (tag_table);
          if (!no_headers)
            write_tag_table ();
        }
d2183 1
a2183 1
        fclose (output_stream);
d2187 1
a2187 1
        validate_file (tag_table);
d2189 4
a2192 11
      if (splitting && (!errors_printed || force))
        split_file (real_output_filename, 0);
      else if (errors_printed && !force
               && strcmp (real_output_filename, "-") != 0
               && strcmp (real_output_filename, "/dev/null") != 0)
        { /* If there were errors, and no --force, remove the output.  */
          fprintf (stderr, _("%s: Removing output file `%s' due to errors; use --force to preserve.\n"),
                   progname, real_output_filename);
          if (unlink (real_output_filename) < 0)
            perror (real_output_filename);
        }
d2201 1
a2201 1
  if (*pointer)
d2212 1
a2218 1
  current_node = NULL; /* sometimes already freed */
d2231 1
a2231 1
  output_paragraph[0] = 0;
d2253 1
a2253 1
        break;
d2258 6
a2263 6
          (character == '\'' || character == '`') &&
          input_text[input_text_offset + 1] == character)
        {
          input_text_offset++;
          character = '"';
        }
d2266 8
a2273 8
        {
          dash_count++;
          if (dash_count == 2 && !in_fixed_width_font)
            {
              input_text_offset++;
              continue;
            }
        }
d2275 3
a2277 3
        {
          dash_count = 0;
        }
d2280 1
a2280 1
         is blank.  If so, advance to the carriage return. */
d2282 2
a2283 2
        {
          register int i = input_text_offset + 1;
d2285 2
a2286 2
          while (i < size_of_input_text && whitespace (input_text[i]))
            i++;
d2288 9
a2296 9
          if (i == size_of_input_text || input_text[i] == '\n')
            {
              if (i == size_of_input_text)
                i--;

              input_text_offset = i;
              character = curchar ();
            }
        }
d2299 2
a2300 2
        {
          line_number++;
d2302 13
a2314 13
          /* Check for a menu entry here, since the "escape sequence"
             that begins menu entries is "\n* ". */
          if (in_menu && input_text_offset + 1 < size_of_input_text)
            {
              char *glean_node_from_menu (), *tem;

              /* Note that the value of TEM is discarded, since it is
                 gauranteed to be NULL when glean_node_from_menu () is
                 called with a Nonzero argument. */
              if (!in_detailmenu)
                tem = glean_node_from_menu (1);
            }
        }
d2317 18
a2334 17
        {
        case COMMAND_PREFIX:
          read_command ();
          break;

        case '{':
          /* Special case.  I'm not supposed to see this character by itself.
             If I do, it means there is a syntax error in the input text.
             Report the error here, but remember this brace on the stack so
             you can ignore its partner. */

          line_error (_("Misplaced %c"), '{');
          remember_brace (misplaced_brace);

          /* Don't advance input_text_offset since this happens in
             remember_brace ().
             input_text_offset++;
d2336 1
a2336 1
          break;
d2338 9
a2346 9
        case '}':
          pop_and_call_brace ();
          input_text_offset++;
          break;

        default:
          add_char (character);
          input_text_offset++;
        }
d2363 3
a2365 3
  for (i = 0; command_table[i].name; i++)
    if (strcmp (command_table[i].name, string) == 0)
      return (&command_table[i]);
d2371 1
a2371 1
        (strcmp (user_command_array[i]->name, string) == 0))
d2374 1
a2374 1
  /* We never heard of this command. */
d2398 4
a2401 4
        /* We disallow recursive use of a macro call.  Inhibit the expansion
           of this macro during the life of its execution. */
        if (!(def->flags & ME_RECURSE))
          def->inhibited = 1;
d2403 1
a2403 1
        execute_macro (def);
d2405 2
a2406 2
        if (!(def->flags & ME_RECURSE))
          def->inhibited = 0;
d2408 1
a2408 1
        return;
d2414 1
d2417 1
a2417 1
      line_error (_("Unknown command `%s'"), command);
d2434 4
a2437 4
  for (i = 0; command_table[i].name; i++)
    if (proc == command_table[i].proc)
      return command_table[i].name;
  return _("NO_NAME!");
d2451 1
a2451 1
    line_error (_("%c%s expected `{...}'"), COMMAND_PREFIX, command);
d2484 1
a2484 1
      line_error (_("Unmatched }"));
d2508 1
a2508 1
        stack->pos += amount;
d2526 10
a2535 10
        {
          char *proc_name;
          int temp_line_number = line_number;

          line_number = brace_stack->line;
          proc_name = find_proc_name (brace_stack->proc);
          line_error (_("%c%s missing close brace"), COMMAND_PREFIX, proc_name);
          line_number = temp_line_number;
          pop_and_call_brace ();
        }
d2537 6
a2542 6
        {
          BRACE_ELEMENT *temp;
          temp = brace_stack->next;
          free (brace_stack);
          brace_stack = temp;
        }
d2558 1
a2558 1
        len = fill_column - output_column;
d2560 1
a2560 1
        len = len - output_column;
d2568 23
a2590 10
      /* ASCII control characters appear as two characters in the output
         (e.g., ^A).  But characters with the high bit set are just one
         on suitable terminals, so don't count them as two for line
         breaking purposes.  */
      if (0 <= character && character < ' ')
        len = 2;
      else
        len = 1;
    }
  return (len);
d2593 2
d2596 2
a2597 7
#if defined (VA_FPRINTF) && __STDC__
add_word_args (char *format, ...)
#else
add_word_args (format, va_alist)
    char *format;
    va_dcl
#endif
d2600 1
a2600 11
#ifdef VA_FPRINTF
  va_list ap;
#endif

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (buffer, format, ap);
#else
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
d2604 2
d2615 1
a2615 1
/* Nonzero if the last character inserted has the syntax class of NEWLINE. */
d2622 1
a2622 1
/* Nonzero means that a newline character has already been
d2626 1
a2626 1
/* When nonzero we have finished an insertion (see `end_insertion') and we
d2630 1
a2630 1
/* Nonzero means attempt to make all of the lines have fill_column width. */
d2634 1
a2634 1
   nonzero, then do filling as well. */
d2649 1
a2649 1
      line_already_broken = 0;  /* The line is no longer broken. */
d2651 4
a2654 4
        {
          indent (current_indent - output_column);
          output_column = current_indent;
        }
d2666 2
a2667 2
        {
          insert ('\n');
d2669 13
a2681 13
          if (force_flush_right)
            {
              close_paragraph ();
              /* Hack to force single blank lines out in this mode. */
              flush_output ();
            }

          output_column = 0;

          if (!no_indent && paragraph_is_open)
            indent (output_column = current_indent);
          break;
        }
d2683 8
a2690 8
        {
          if (end_of_sentence_p ())
            {
              insert (' ');
              output_column++;
              last_inserted_character = character;
            }
        }
d2693 4
a2696 4
        {
          close_paragraph ();
          pending_indent = 0;
        }
d2698 5
a2702 5
        {
          last_char_was_newline = 1;
          insert (' ');
          output_column++;
        }
d2707 2
a2708 2
        int len = get_char_len (character);
        int suppress_insert = 0;
d2710 118
a2827 118
        if ((character == ' ') && (last_char_was_newline))
          {
            if (!paragraph_is_open)
              {
                pending_indent++;
                return;
              }
          }

        if (!paragraph_is_open)
          {
            start_paragraph ();

            /* If the paragraph is supposed to be indented a certain way,
               then discard all of the pending whitespace.  Otherwise, we
               let the whitespace stay. */
            if (!paragraph_start_indent)
              indent (pending_indent);
            pending_indent = 0;
          }

        if ((output_column += len) > fill_column)
          {
            if (filling_enabled)
              {
                int temp = output_paragraph_offset;
                while (--temp > 0 && output_paragraph[temp] != '\n')
                  {
                    /* If we have found a space, we have the place to break
                       the line. */
                    if (output_paragraph[temp] == ' ')
                      {
                        /* Remove trailing whitespace from output. */
                        while (temp && whitespace (output_paragraph[temp - 1]))
                          temp--;

                        output_paragraph[temp++] = '\n';

                        /* We have correctly broken the line where we want
                           to.  What we don't want is spaces following where
                           we have decided to break the line.  We get rid of
                           them. */
                        {
                          int t1 = temp;

                          for (;; t1++)
                            {
                              if (t1 == output_paragraph_offset)
                                {
                                  if (whitespace (character))
                                    suppress_insert = 1;
                                  break;
                                }
                              if (!whitespace (output_paragraph[t1]))
                                break;
                            }

                          if (t1 != temp)
                            {
                              adjust_braces_following (temp, (- (t1 - temp)));
                              strncpy ((char *) &output_paragraph[temp],
                                       (char *) &output_paragraph[t1],
                                       (output_paragraph_offset - t1));
                              output_paragraph_offset -= (t1 - temp);
                            }
                        }

                        /* Filled, but now indent if that is right. */
                        if (indented_fill && current_indent)
                          {
                            int buffer_len = ((output_paragraph_offset - temp)
                                              + current_indent);
                            char *temp_buffer = (char *)xmalloc (buffer_len);
                            int indentation = 0;

                            /* We have to shift any markers that are in
                               front of the wrap point. */
                            adjust_braces_following (temp, current_indent);

                            while (current_indent > 0 &&
                                   indentation != current_indent)
                              temp_buffer[indentation++] = ' ';

                            strncpy ((char *) &temp_buffer[current_indent],
                                     (char *) &output_paragraph[temp],
                                     buffer_len - current_indent);

                            if (output_paragraph_offset + buffer_len
                                >= paragraph_buffer_len)
                              {
                                unsigned char *tt = xrealloc
                                  (output_paragraph,
                                   (paragraph_buffer_len += buffer_len));
                                output_paragraph = tt;
                              }
                            strncpy ((char *) &output_paragraph[temp],
                                     temp_buffer, buffer_len);
                            output_paragraph_offset += current_indent;
                            free (temp_buffer);
                          }
                        output_column = 0;
                        while (temp < output_paragraph_offset)
                          output_column +=
                            get_char_len (output_paragraph[temp++]);
                        output_column += len;
                        break;
                      }
                  }
              }
          }

        if (!suppress_insert)
          {
            insert (character);
            last_inserted_character = character;
          }
        last_char_was_newline = 0;
        line_already_broken = 0;
d2841 1
a2841 1
        xrealloc (output_paragraph, (paragraph_buffer_len += 100));
a2853 17

/* Sentences might have these characters after the period (or whatever).  */
#define post_sentence(c) ((c) == ')' || (c) == '\'' || (c) == '"' \
                          || (c) == ']')

/* Return true if at an end-of-sentence character, possibly followed by
   post-sentence punctuation to ignore.  */
static int
end_of_sentence_p ()
{
  int loc = output_paragraph_offset - 1;
  while (loc > 0 && post_sentence (output_paragraph[loc]))
    loc--;
  return sentence_ender (output_paragraph[loc]);
}


d2866 6
a2871 6
        {
          if (whitespace (output_paragraph[output_paragraph_offset - 1]))
            output_paragraph_offset--;
          else
            break;
        }
d2876 4
a2879 4
        if (whitespace (output_paragraph[output_paragraph_offset - 1]))
          output_paragraph_offset--;
        else
          break;
d2883 1
a2883 1
/* Nonzero means do not honor calls to flush_output (). */
d2916 1
a2916 1
            output_paragraph[i] &= 0x7f;
d2950 3
a2952 2
      /* Start a new paragraph, with the correct indentation for the now
         current insertion level (one above the one that we are ending). */
d2955 2
a2956 2
      /* Tell `close_paragraph' that the previous line has already been
         broken, so it should insert one less newline. */
d2959 2
a2960 1
      /* Tell functions such as `add_char' we've already found a newline. */
d2966 6
a2971 6
         two `@@end' commands in a row.  Note that the first one we saw was
         handled in the first part of this if-then-else clause, and at that
         time `start_paragraph' was called, partially to handle the proper
         indentation of the current line.  However, the indentation level
         may have just changed again, so we may have to outdent the current
         line to the new indentation level. */
d2973 1
a2973 1
        kill_self_indent (output_column - current_indent);
d3005 3
a3007 3
         subsequent characters to be newlines.  This isn't strictly
         necessary, but a couple of functions use the presence of a newline
         to make decisions. */
d3009 2
a3010 2
        {
          c = output_paragraph[tindex];
d3012 5
a3016 5
          if (c == ' '|| c == '\n')
            output_paragraph[tindex] = '\n';
          else
            break;
        }
d3023 1
a3023 1
        insert ('\n');
d3025 1
a3025 1
      /* Add as many blank lines as is specified in `paragraph_spacing'. */
d3027 4
a3030 4
        {
          for (i = 0; i < (paragraph_spacing - line_already_broken); i++)
            insert ('\n');
        }
d3033 1
a3033 1
         on the paragraph (really a single line). */
d3035 1
a3035 1
        do_flush_right_indentation ();
d3064 1
a3064 1
      output_paragraph[output_paragraph_offset] = 0;
d3067 2
a3068 2
        {
          register int i;
d3070 16
a3085 16
          if (fill_column >= paragraph_buffer_len)
            output_paragraph =
              xrealloc (output_paragraph,
                        (paragraph_buffer_len += fill_column));

          temp_len = strlen ((char *)output_paragraph);
          temp = (char *)xmalloc (temp_len + 1);
          memcpy (temp, (char *)output_paragraph, temp_len);

          for (i = 0; i < fill_column - output_paragraph_offset; i++)
            output_paragraph[i] = ' ';

          memcpy ((char *)output_paragraph + i, temp, temp_len);
          free (temp);
          output_paragraph_offset = fill_column;
        }
d3112 19
a3130 19
        {
          if (inhibit_paragraph_indentation)
            {
              amount_to_indent = current_indent;
              if (inhibit_paragraph_indentation < 0)
                inhibit_paragraph_indentation++;
            }
          else if (paragraph_start_indent < 0)
            amount_to_indent = current_indent;
          else
            amount_to_indent = current_indent + paragraph_start_indent;

          if (amount_to_indent >= output_column)
            {
              amount_to_indent -= output_column;
              indent (amount_to_indent);
              output_column += amount_to_indent;
            }
        }
d3148 1
a3148 1
        elt->pos += amount;
d3168 1
a3168 1
        return (from);
d3190 1
a3190 1
        return (0);
d3196 1
a3196 1
        return (ch1 - ch2);
d3233 12
a3244 14
        {
        case ifinfo:
        case ifnothtml:
        case ifnottex:
        case ifset:
        case ifclear:
        case cartouche:
          elt = elt->next;
          level--;
          break;

        default:
          done = 1;
        }
d3259 1
d3276 1
a3276 1
  new->filename = xstrdup (input_filename);
d3314 1
a3314 1
    return (_("Broken-Type in insertion_type_pname"));
d3327 1
a3327 1
        return (enum insertion_type) index;
d3380 1
a3380 1
      line_error (_("Enumeration stack overflow"));
d3410 4
a3413 4
        {
          current_enumval = ((current_enumval - 1) == 'z' ? 'a' : 'A');
          warning (_("lettering overflow, restarting at %c"), current_enumval);
        }
d3435 1
a3435 1
      push_insertion (type, xstrdup (""));
d3445 1
a3445 1
        close_paragraph ();
d3451 1
a3451 1
        add_word (_("* Menu:\n"));
d3458 1
d3460 3
a3462 3
        {
          if (!no_headers)
            close_paragraph ();
d3464 2
a3465 2
          filling_enabled = no_indent = 0;
          inhibit_paragraph_indentation = 1;
d3467 2
a3468 2
          no_discard++;
        }
d3481 1
a3481 1
         If you don't want filling, then use @@display. */
d3497 1
d3503 1
d3505 2
a3506 1
        current_indent += default_indentation_increment;
d3528 8
a3535 8
        {
          if (!(*insertion_stack->item_function))
            {
              free (insertion_stack->item_function);
              insertion_stack->item_function = xstrdup ("@@bullet");
              insertion_stack->item_function[0] = COMMAND_PREFIX;
            }
        }
d3538 4
a3541 4
        {
          line_error (_("%s requires an argument: the formatter for %citem"),
                      insertion_type_pname (type), COMMAND_PREFIX);
        }
d3557 1
a3557 1
        start_enumerating (atoi (enumeration_arg), ENUM_DIGITS);
d3559 1
a3559 1
        start_enumerating (*enumeration_arg, ENUM_ALPHA);
d3566 2
a3567 2
          insertion_stack->next->insertion != example)
        close_single_paragraph ();
a3571 2
    case ifnothtml:
    case ifnottex:
d3576 1
a3576 1
        no_discard++;
d3620 5
a3624 4
/* Try to end the insertion with the specified TYPE.  With a value of
   `bad_type', TYPE gets translated to match the value currently on top
   of the stack.  Otherwise, if TYPE doesn't match the top of the
   insertion stack, give error. */
d3642 2
a3643 2
        (_("`%cend' expected `%s', but saw `%s'"), COMMAND_PREFIX,
         insertion_type_pname (temp_type), insertion_type_pname (type));
a3651 2
    case ifnothtml:
    case ifnottex:
d3663 1
a3663 1
      in_detailmenu--;          /* No longer hacking menus. */
d3665 4
a3668 4
        {
          if (!no_headers)
            close_insertion_paragraph ();
        }
d3672 1
a3672 1
      in_menu--;                /* No longer hacking menus. */
d3674 1
a3674 1
        close_insertion_paragraph ();
d3700 1
d3702 1
a3702 1
         in indentation. */
d3704 1
a3704 1
        current_indent -= default_indentation_increment;
d3707 1
a3707 1
         start of a new paragraph. */
d3732 1
a3732 1
   code that creates such boundaries, you should call `discard_insertions'
d3734 1
a3734 2
   the insertion stack.  With nonzero SPECIALS_OK, allows unmatched
   ifinfo, ifset, ifclear, otherwise not.  */
d3736 1
a3736 2
discard_insertions (specials_ok)
    int specials_ok;
d3741 4
a3744 4
      if (specials_ok && (insertion_stack->insertion == ifinfo
          || insertion_stack->insertion == ifset
          || insertion_stack->insertion == ifclear))
        break;
d3746 13
a3758 10
        {
          char *offender = insertion_type_pname (insertion_stack->insertion);
          char *current_filename = input_filename;
          
          input_filename = insertion_stack->filename;
          line_number = insertion_stack->line_number;
          line_error (_("No matching `%cend %s'"), COMMAND_PREFIX, offender);
          input_filename = current_filename;
          pop_insertion ();
        }
d3787 1
d3789 1
d3896 1
a3896 1
        fprintf (stderr, _("How did @@%s end up in cm_special_char?\n"), command);
d3910 1
a3910 1
        line_error (_("%c%s expects `i' or `j' as argument, not `%c'"),
d3914 2
a3915 2
        line_error (_("%c%s expects a single character `i' or `j' as argument"),
                    COMMAND_PREFIX, command);
d3921 6
d3931 3
a3933 4
  static char *months [12] =
    { N_("January"), N_("February"), N_("March"), N_("April"), N_("May"),
      N_("June"), N_("July"), N_("August"), N_("September"), N_("October"),
      N_("November"), N_("December") };
d3936 7
a3942 4
      time_t timer = time (0);
      struct tm *ts = localtime (&timer);
      add_word_args (_("%d %s %d"), ts->tm_mday, _(months[ts->tm_mon]),
                     ts->tm_year + 1900);
d3957 1
a3957 1
        add_char ('`');
d3962 1
a3962 1
        add_char ('\'');
d3977 1
a3977 1
cm_key (arg)
d3994 2
a3995 2
        line_error (_("%c%s expects a single character as an argument"),
                    COMMAND_PREFIX, command);
d3998 7
a4004 7
        for (i = start; i < end; i++)
          {
            character = output_paragraph[i];

            if (isletter (character))
              output_paragraph[i] = CTL (coerce_to_upper (character));
          }
d4017 19
a4035 1
/* Small caps and @@var in makeinfo just uppercase the text. */
d4037 1
a4037 1
cm_var_sc (arg, start_pos, end_pos)
d4045 5
a4049 5
        {
          output_paragraph[start_pos] =
            coerce_to_upper (output_paragraph[start_pos]);
          start_pos++;
        }
d4092 1
a4092 1
/* Various commands are no-op's. */
a4097 9
/* No-op that eats its argument on same line.  */
void
cm_no_op_line_arg ()
{
  char *temp;
  get_rest_of_line (&temp);
  free (temp);
}

d4117 1
a4117 1
    warning (_("%c%s is obsolete"), COMMAND_PREFIX, command);
d4147 3
a4149 1
      char *temp1 = (char *) xmalloc (2 + strlen (temp));
d4157 1
a4157 1
    execute_string ("%s\n", temp);
d4246 1
a4246 1
  for (i = 0; (t = section_alist[i].name); i++)
d4249 2
a4250 2
        {
          int return_val;
d4252 1
a4252 1
          return_val = (section_alist[i].level + section_alist_offset);
d4254 6
a4259 6
          if (return_val < 0)
            return_val = 0;
          else if (return_val > 5)
            return_val = 5;
          return (return_val);
        }
d4274 3
a4276 3
        result = section_alist[i].level;
        section_alist[i].level = level;
        break;
d4291 2
a4292 2
      line_error (_("There already is a node having %ctop as a section"),
                  COMMAND_PREFIX);
d4295 15
a4309 15
        {
          if ((tag->flags & IS_TOP))
            {
              int old_line_number = line_number;
              char *old_input_filename = input_filename;

              line_number = tag->line_no;
              input_filename = tag->filename;
              line_error (_("Here is the %ctop node"), COMMAND_PREFIX);
              input_filename = old_input_filename;
              line_number = old_line_number;
              return;
            }
          tag = tag->next_ent;
        }
d4317 2
a4318 2
        {
          char *top_name;
d4320 7
a4326 7
          get_rest_of_line (&top_name);
          free (top_name);
          line_error (_("%ctop used before %cnode, defaulting to %s"),
                      COMMAND_PREFIX, COMMAND_PREFIX, top_name);
          execute_string ("@@node Top, , (dir), (dir)\n@@top %s\n", top_name);
          return;
        }
d4335 1
a4335 1
        int orig_offset = input_text_offset;
d4337 1
a4337 1
        input_text_offset = search_forward (node_search_string, orig_offset);
d4339 3
a4341 3
        if (input_text_offset > 0)
          {
            int this_section;
d4343 2
a4344 2
            /* We have encountered a non-top node, so mark that one exists. */
            non_top_node_seen = 1;
d4346 4
a4349 4
            /* Move to the end of this line, and find out what the
               sectioning command is here. */
            while (input_text[input_text_offset] != '\n')
              input_text_offset++;
d4351 2
a4352 2
            if (input_text_offset < size_of_input_text)
              input_text_offset++;
d4354 1
a4354 1
            this_section = what_section (input_text + input_text_offset);
d4356 6
a4361 6
            /* If we found a sectioning command, then give the top section
               a level of this section - 1. */
            if (this_section != -1)
              set_top_section_level (this_section - 1);
          }
        input_text_offset = orig_offset;
d4397 2
a4398 2
  warning (_("%c%s is obsolete; use %c%s instead"),
           COMMAND_PREFIX, command, COMMAND_PREFIX, command + 1);
d4521 3
a4523 3
/*                                                                  */
/*                 Adding nodes, and making tags                    */
/*                                                                  */
d4545 1
a4545 1
  write_tag_table_internal (0); /* Not indirect. */
d4589 1
a4589 2
get_node_token (expand)
      int expand;
d4593 1
a4593 1
  get_until_in_line (expand, ",", &string);
d4626 1
a4626 1
        return (tag);
d4643 5
a4647 6
        {
          line_error (
                 _("Node `%s' multiply defined (line %d is first definition at)"),
                      node, tag->line_no);
          return;
        }
d4663 1
a4663 1
    new->touched = 0;           /* not yet referenced. */
d4693 1
a4693 1
  discard_insertions (1);
d4711 4
a4714 4
  node = get_node_token (1);
  next = get_node_token (0);
  prev = get_node_token (0);
  up = get_node_token (0);
a4715 3
  if (verbose_mode)
    printf (_("Formatting node %s...\n"), node);
    
d4728 1
a4728 1
        me_execute_string (node);
d4731 1
a4731 1
        execute_string ("%s", node);
d4736 3
a4738 1
  defaulting = (*next == 0 && *prev == 0 && *up == 0);
d4753 15
a4767 15
        {
          char *polite_section_name = "top";
          int i;

          for (i = 0; section_alist[i].name; i++)
            if (section_alist[i].level == current_section + 1)
              {
                polite_section_name = section_alist[i].name;
                break;
              }

          line_error
            (_("Node `%s' requires a sectioning command (e.g. %c%s)"),
             node, COMMAND_PREFIX, polite_section_name);
        }
d4769 72
a4840 72
        {
          if (strcmp (node, "Top") == 0)
            {
              /* Default the NEXT pointer to be the first menu item in
                 this node, if there is a menu in this node.  We have to
                 try very hard to find the menu, as it may be obscured
                 by execution_strings which are on the filestack.  For
                 every member of the filestack which has a FILENAME
                 member which is identical to the current INPUT_FILENAME,
                 search forward from that offset. */
              int saved_input_text_offset = input_text_offset;
              int saved_size_of_input_text = size_of_input_text;
              char *saved_input_text = input_text;
              FSTACK *next_file = filestack;

              int orig_offset, orig_size;
              char *glean_node_from_menu ();

              /* No matter what, make this file point back at `(dir)'. */
              free (up);   up = xstrdup ("(dir)");

              while (1)
                {
                  orig_offset = input_text_offset;
                  orig_size =
                    search_forward (node_search_string, orig_offset);

                  if (orig_size < 0)
                    orig_size = size_of_input_text;

                  input_text_offset =
                    search_forward (menu_search_string, orig_offset);

                  if (input_text_offset > -1)
                    {
                      char *nodename_from_menu = (char *)NULL;

                      input_text_offset =
                        search_forward ("\n* ", input_text_offset);

                      if (input_text_offset != -1)
                        nodename_from_menu = glean_node_from_menu (0);

                      if (nodename_from_menu)
                        {
                          free (next); next = nodename_from_menu;
                          break;
                        }
                    }

                  /* We got here, so it hasn't been found yet.  Try
                     the next file on the filestack if there is one. */
                  if (next_file &&
                      (strcmp (next_file->filename, input_filename) == 0))
                    {
                      input_text = next_file->text;
                      input_text_offset = next_file->offset;
                      size_of_input_text = next_file->size;
                      next_file = next_file->next;
                    }
                  else
                    {
                      /* No more input files to check. */
                      break;
                    }
                }

              input_text = saved_input_text;
              input_text_offset = saved_input_text_offset;
              size_of_input_text = saved_size_of_input_text;
            }
        }
d4843 1
a4843 1
         was declared with @@top, and no subsequent reference was found. */
d4845 13
a4857 13
        {
          /* Then this is the first non-@@top node seen. */
          int level;

          level = set_top_section_level (this_section - 1);
          non_top_node_seen = 1;

          while (ref)
            {
              if (ref->section == level)
                ref->section = this_section - 1;
              ref = ref->next;
            }
d4859 2
a4860 2
          ref = node_references;
        }
d4863 42
a4904 42
        {
          if (ref->section == (this_section - 1) &&
              ref->type == menu_reference &&
              strcmp (ref->node, node) == 0)
            {
              char *containing_node = ref->containing_node;

              free (up);
              up = xstrdup (containing_node);

              if (last_ref &&
                  last_ref->type == menu_reference &&
                  (strcmp (last_ref->containing_node,
                           containing_node) == 0))
                {
                  free (next);
                  next = xstrdup (last_ref->node);
                }

              while ((ref->section == this_section - 1) &&
                     (ref->next) &&
                     (ref->next->type != menu_reference))
                ref = ref->next;

              if (ref->next && ref->type == menu_reference &&
                  (strcmp (ref->next->containing_node,
                           containing_node) == 0))
                {
                  free (prev);
                  prev = xstrdup (ref->next->node);
                }
              else if (!ref->next &&
                       strcasecmp (ref->containing_node, "Top") == 0)
                {
                  free (prev);
                  prev = xstrdup (ref->containing_node);
                }
              break;
            }
          last_ref = ref;
          ref = ref->next;
        }
d4938 1
a4938 1
        me_inhibit_expansion++;
d4942 4
a4945 4
        {
          execute_string (",  Next: %s", next);
          filling_enabled = indented_fill = 0;
        }
d4948 4
a4951 4
        {
          execute_string (",  Prev: %s", prev);
          filling_enabled = indented_fill = 0;
        }
d4954 4
a4957 4
        {
          execute_string (",  Up: %s", up);
          filling_enabled = indented_fill = 0;
        }
d4960 1
a4960 1
        me_inhibit_expansion--;
d4970 1
a4970 1
                  COMMAND_PREFIX, command);
d5021 4
a5024 4
        {
          tags = tags->next_ent;
          continue;
        }
d5028 2
a5029 2
        {
          validate (tags->next, tags->line_no, "Next");
d5031 30
a5060 31
          /* If the Next node exists, and there is no Up, then make
             sure that the Prev of the Next points back. */
          temp_tag = find_node (tags->next);
          if (temp_tag)
            {
              char *prev;

              if (temp_tag->flags & NO_WARN)
                {
                  /* Do nothing if we aren't supposed to issue warnings
                     about this node. */
                }
              else
                {
                  prev = temp_tag->prev;
                  if (!prev || (strcmp (prev, tags->node) != 0))
                    {
                      line_error (_("Node `%s''s Next field not pointed back to"),
                                  tags->node);
                      line_number = temp_tag->line_no;
                      input_filename = temp_tag->filename;
                      line_error
                        (_("This node (`%s') is the one with the bad `Prev'"),
                         temp_tag->node);
                      input_filename = tags->filename;
                      line_number = tags->line_no;
                      temp_tag->flags |= PREV_ERROR;
                    }
                }
            }
        }
d5063 2
a5064 2
         complained about it in some way.  You don't have to have a Prev
         field at this stage. */
d5066 2
a5067 2
        {
          int valid_p = validate (tags->prev, tags->line_no, "Prev");
d5069 38
a5106 37
          if (!valid_p)
            tags->flags |= PREV_ERROR;
          else
            {
              /* If the Prev field is not the same as the Up field,
                 then the node pointed to by the Prev field must have
                 a Next field which points to this node. */
              if (tags->up && (strcmp (tags->prev, tags->up) != 0))
                {
                  temp_tag = find_node (tags->prev);

                  /* If we aren't supposed to issue warnings about the
                     target node, do nothing. */
                  if (!temp_tag || (temp_tag->flags & NO_WARN))
                    {
                      /* Do nothing. */
                    }
                  else
                    {
                      if (!temp_tag->next ||
                          (strcmp (temp_tag->next, tags->node) != 0))
                        {
                          line_error
                            (_("Node `%s's Prev field not pointed back to"),
                             tags->node);
                          line_number = temp_tag->line_no;
                          input_filename = temp_tag->filename;
                          line_error (_("This node (`%s') has the bad Next"),
                                      temp_tag->node);
                          input_filename = tags->filename;
                          line_number = tags->line_no;
                          temp_tag->flags |= NEXT_ERROR;
                        }
                    }
                }
            }
        }
d5108 2
a5109 2
      if (!tags->up && (strcasecmp (tags->node, _("Top")) != 0))
        line_error (_("Node `%s' missing Up field"), tags->node);
d5111 2
a5112 2
        {
          int valid_p = validate (tags->up, tags->line_no, "Up");
d5114 42
a5155 42
          /* If node X has Up: Y, then warn if Y fails to have a menu item
             or note pointing at X, if Y isn't of the form "(Y)". */
          if (valid_p && *tags->up != '(')
            {
              NODE_REF *nref, *tref, *list;
              NODE_REF *find_node_reference ();

              tref = (NODE_REF *) NULL;
              list = node_references;

              for (;;)
                {
                  if (!(nref = find_node_reference (tags->node, list)))
                    break;

                  if (strcmp (nref->containing_node, tags->up) == 0)
                    {
                      if (nref->type != menu_reference)
                        {
                          tref = nref;
                          list = nref->next;
                        }
                      else
                        break;
                    }
                  list = nref->next;
                }

              if (!nref)
                {
                  temp_tag = find_node (tags->up);
                  line_number = temp_tag->line_no;
                  input_filename = temp_tag->filename;
                  if (!tref)
                    line_error (
_("`%s' has an Up field of `%s', but `%s' has no menu item for `%s'"),
                                tags->node, tags->up, tags->up, tags->node);
                  line_number = tags->line_no;
                  input_filename = tags->filename;
                }
            }
        }
d5168 4
a5171 4
        {
          tags = tags->next_ent;
          continue;
        }
d5177 6
a5182 6
        {
          input_filename = tags->filename;
          line_number = tags->line_no;
          warning (_("node `%s' has been referenced %d times"),
                   tags->node, tags->touched);
        }
d5185 9
a5193 9
        {
          input_filename = tags->filename;
          line_number = tags->line_no;

          /* Notice that the node "Top" is special, and doesn't have to
             be referenced. */
          if (strcasecmp (tags->node, _("Top")) != 0)
            warning (_("unreferenced node `%s'"), tags->node);
        }
d5219 3
a5221 1
      line_error (_("%s reference to nonexistent node `%s'"), label, tag);
d5265 1
a5265 1
    root_pathname = xstrdup ("");
d5284 1
a5284 1
        int file_top, file_bot, limit;
d5286 114
a5399 114
        /* Have to include the Control-_. */
        file_top = file_bot = tags->position;
        limit = file_top + size;

        /* If the rest of this file is only one node, then
           that is the entire subfile. */
        if (!tags->next_ent)
          {
            int i = tags->position + 1;
            char last_char = the_file[i];

            while (i < file_size)
              {
                if ((the_file[i] == '\037') &&
                    ((last_char == '\n') ||
                     (last_char == '\014')))
                  break;
                else
                  last_char = the_file[i];
                i++;
              }
            file_bot = i;
            tags = tags->next_ent;
            goto write_region;
          }

        /* Otherwise, find the largest number of nodes that can fit in
           this subfile. */
        for (; tags; tags = tags->next_ent)
          {
            if (!tags->next_ent)
              {
                /* This entry is the last node.  Search forward for the end
                   of this node, and that is the end of this file. */
                int i = tags->position + 1;
                char last_char = the_file[i];

                while (i < file_size)
                  {
                    if ((the_file[i] == '\037') &&
                        ((last_char == '\n') ||
                         (last_char == '\014')))
                      break;
                    else
                      last_char = the_file[i];
                    i++;
                  }
                file_bot = i;

                if (file_bot < limit)
                  {
                    tags = tags->next_ent;
                    goto write_region;
                  }
                else
                  {
                    /* Here we want to write out everything before the last
                       node, and then write the last node out in a file
                       by itself. */
                    file_bot = tags->position;
                    goto write_region;
                  }
              }

            if (tags->next_ent->position > limit)
              {
                if (tags->position == file_top)
                  tags = tags->next_ent;

                file_bot = tags->position;

              write_region:
                {
                  int fd;
                  char *split_filename;

                  split_filename = (char *) xmalloc
                    (10 + strlen (root_pathname) + strlen (root_filename));
                  sprintf
                    (split_filename,
                     "%s%s-%d", root_pathname, root_filename, which_file);

                  fd = open
                    (split_filename, O_WRONLY | O_TRUNC | O_CREAT, 0666);

                  if ((fd < 0) ||
                      (write (fd, the_header, header_size) != header_size) ||
                      (write (fd, the_file + file_top, file_bot - file_top)
                       != (file_bot - file_top)) ||
                      ((close (fd)) < 0))
                    {
                      perror (split_filename);
                      if (fd != -1)
                        close (fd);
                      exit (FATAL);
                    }

                  if (!indirect_info)
                    {
                      indirect_info = the_file + file_top;
                      sprintf (indirect_info, "\037\nIndirect:\n");
                      indirect_info += strlen (indirect_info);
                    }

                  sprintf (indirect_info, "%s-%d: %d\n",
                           root_filename, which_file, file_top);

                  free (split_filename);
                  indirect_info += strlen (indirect_info);
                  which_file++;
                  break;
                }
              }
          }
d5408 2
a5409 2
        perror (filename);
        exit (FATAL);
d5428 4
a5431 2
/* The strings here are followed in the message by `reference to...' in
   the `validate' routine.  */
d5441 1
a5441 1
      return ("Cross");
d5447 1
a5447 4
/* Remember this node name for later validation use.  This is used to
   remember menu references while reading the input file.  After the
   output file has been written, if validation is on, then we use the
   contents of `node_references' as a list of nodes to validate.  */
d5457 1
a5457 1
  temp->node = xstrdup (node);
d5461 1
a5461 1
  temp->containing_node = xstrdup (current_node ? current_node : "");
d5477 1
a5477 1
                reftype_type_string (ref_list->type));
d5492 1
a5492 1
        break;
d5529 2
a5530 2
               menu_starter,
               strlen (menu_starter)) != 0)
d5535 1
a5535 1
  get_until_in_line (0, ":", &nodename);
d5561 1
a5561 1
    nodename[i - 1] = 0;
d5588 1
a5588 1
      *nodename = 0;
d5599 1
a5599 1
  for (; (c = nodename[i]); i++)
d5602 5
a5606 5
        {
          if (c == '(')
            paren++;
          else if (c == ')')
            paren--;
d5608 2
a5609 2
          continue;
        }
d5612 1
a5612 1
         node has no more characters associated with it. */
d5614 9
a5622 9
          c == '\n' ||
          c == ','  ||
          ((paren_seen && nodename[i - 1] == ')') &&
           (c == ' ' || c == '.')) ||
          (c == '.' &&
           ((!nodename[i + 1] ||
             (cr_or_whitespace (nodename[i + 1])) ||
             (nodename[i + 1] == ')')))))
        break;
d5624 1
a5624 1
  nodename[i] = 0;
d5632 2
a5633 2
      warning (_("%cmenu seen before first node"), COMMAND_PREFIX);
      warning (_("creating `Top' node"));
d5644 2
a5645 2
      warning (_("%cmenu seen before first node"), COMMAND_PREFIX);
      warning (_("creating `Top' node"));
d5652 3
a5654 3
/*                                                                  */
/*                      Cross Reference Hacking                     */
/*                                                                  */
a5656 2
/* Return next comma-delimited argument, but do not cross a close-brace
   boundary.  Clean up whitespace, too.  */
d5669 1
a5669 1
int px_ref_flag = 0;            /* Controls initial output string. */
d5688 2
a5689 2
        {
          char *node_name;
d5691 19
a5709 19
          if (!*arg2)
            {
              if (*arg3)
                node_name = arg3;
              else
                node_name = arg1;
            }
          else
            node_name = arg2;

          execute_string ("%s: (%s)%s", node_name, arg4, arg1);
          /* Free all of the arguments found. */
          if (arg1) free (arg1);
          if (arg2) free (arg2);
          if (arg3) free (arg3);
          if (arg4) free (arg4);
          if (arg5) free (arg5);
          return;
        }
d5711 1
a5711 1
        remember_node_reference (arg1, line_number, followed_reference);
d5714 6
a5719 6
        {
          if (!*arg2)
            execute_string ("%s: %s", arg3, arg1);
          else
            execute_string ("%s: %s", arg2, arg1);
        }
d5721 6
a5726 6
        {
          if (*arg2)
            execute_string ("%s: %s", arg2, arg1);
          else
            execute_string ("%s::", arg1);
        }
d5743 2
a5744 2
          output_paragraph[output_paragraph_offset - 1] == ':')
        return;
d5746 17
a5762 16
        {
          if (cr_or_whitespace (input_text[temp]))
            temp++;
          else
            {
              if (input_text[temp] != '.'
                  && input_text[temp] != ','
                  && input_text[temp] != '\t')
               {
                 line_error (
                          _("`.' or `,' must follow cross reference, not %c"), 
                             input_text[temp]);
                }
              break;
            }
        }
d5786 1
a5786 89
      char *node = get_xref_token ();
      char *pname = get_xref_token ();
      char *file = get_xref_token ();

      if (*pname)
        execute_string ("*note %s: (%s)%s", pname, file, node);
      else
        execute_string ("*note (%s)%s::", file, node);

      free (node);
      free (pname);
      free (file);
    }
}

/* A URL reference.  */
void
cm_uref (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  if (arg == END)
    {
      char *comma;
      char *arg = &output_paragraph[start_pos];

      output_paragraph[end_pos] = 0;
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      arg = xstrdup (arg);
      comma = strchr (arg, ','); /* let's hope for no commas in the url  */
      if (comma)
        {
          *comma = 0;
          /* Ignore spaces at beginning of second arg.  */
          for (comma++; isspace (*comma); comma++)
            ;
          add_word (comma);
          add_char (' ');
          add_char ('(');
          add_word (arg);
          add_char (')');
        }
      else
        {
          extern int printing_index;
          
          if (!printing_index)
            add_char ('`');
            
          add_word (arg);
          
          if (!printing_index)
            add_char ('\'');
        }
      free (arg);
   }
}

/* An email reference.  */
void
cm_email (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
{
  if (arg == END)
    {
      char *comma;
      char *arg = &output_paragraph[start_pos];

      output_paragraph[end_pos] = 0;
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;

      arg = xstrdup (arg);
      comma = strchr (arg, ',');
      if (comma)
        {
          *comma = 0;
          for (comma++; isspace (*comma); comma++)
            ;
          add_word (comma);
          add_char (' ');
        }
      add_char ('<');
      add_word (arg);
      add_char ('>');
      free (arg);
    }
}
d5788 3
a5790 54
/* An external image is a reference, kind of.  The parsing is (not
   coincidentally) similar, anyway.  */
void
cm_image (arg)
     int arg;
{
  if (arg == START)
    {
      char *name_arg = get_xref_token ();
      /* We don't yet care about any other args, but read them so they
         don't end up in the text.  */
      char *arg = get_xref_token ();
      if (arg) free (arg);
      arg = get_xref_token ();
      if (arg) free (arg);
      
      if (*name_arg)
        {
          /* Try to open foo.txt.  */
          FILE *image_file;
          char *name = xmalloc (strlen (name_arg) + 4);
          strcpy (name, name_arg);
          strcat (name, ".txt");
          image_file = fopen (name, "r");
          if (image_file)
            {
              int ch;
              int save_inhibit_indentation = inhibit_paragraph_indentation;
              int save_filling_enabled = filling_enabled;
              
              inhibit_paragraph_indentation = 1;
              filling_enabled = 0;
              last_char_was_newline = 0;
              
              /* Maybe we need to remove the final newline if the image
                 file is only one line to allow in-line images.  On the
                 other hand, they could just make the file without a
                 final newline.  */
              while ((ch = getc (image_file)) != EOF)
                add_char (ch);
              
              inhibit_paragraph_indentation = save_inhibit_indentation;
              filling_enabled = save_filling_enabled;
              
              if (fclose (image_file) != 0) {
                perror (name);
              }
            }
          else
            warning (_("@@image file `%s' unreadable: %s"), name,
                     strerror (errno));
        }
      else
        line_error (_("@@image missing filename argument"));
d5792 1
a5792 1
      if (name_arg) free (name_arg);
d5797 3
a5799 3
/*                                                                  */
/*                      Insertion Command Stubs                     */
/*                                                                  */
d5833 1
a5833 1
   TeX output.  Right now, just a no-op insertion. */
d5880 1
a5880 1
  get_until_in_line (0, ".", &enumeration_arg);
d5886 1
a5886 1
      enumeration_arg = xstrdup (default_string);
d5891 1
a5891 1
      warning (_("%s requires letter or digit"), insertion_type_pname (type));
d5894 6
a5899 6
        {
        case enumerate:
          default_string = "1";
          break;
        }
      enumeration_arg = xstrdup (default_string);
d5913 1
a5913 1
  begin_insertion (multitable); /* @@@@ */
a5939 12
void
cm_ifnothtml ()
{
  begin_insertion (ifnothtml);
}

void
cm_ifnottex ()
{
  begin_insertion (ifnottex);
}

a5953 29

/* End existing insertion block. */
void
cm_end ()
{
  char *temp;
  enum insertion_type type;

  if (!insertion_level)
    {
      line_error (_("Unmatched `%c%s'"), COMMAND_PREFIX, command);
      return;
    }

  get_rest_of_line (&temp);

  if (temp[0] == 0)
    line_error (_("`%c%s' needs something after it"), COMMAND_PREFIX, command);

  type = find_type_from_name (temp);

  if (type == bad_type)
    {
      line_error (_("Bad argument to `%s', `%s', using `%s'"),
           command, temp, insertion_type_pname (current_insertion_type ()));
    }
  end_insertion (type);
  free (temp);
}
d5956 3
a5958 3
/*                                                                  */
/*                        Conditional Handling                      */
/*                                                                  */
d5982 3
a5984 3
        free (temp->value);
        temp->value = xstrdup (value);
        return;
d5989 2
a5990 2
  temp->name = xstrdup (name);
  temp->value = xstrdup (value);
d6007 11
a6017 11
        {
          if (last)
            last->next = temp->next;
          else
            defines = temp->next;

          free (temp->name);
          free (temp->value);
          free (temp);
          break;
        }
d6087 1
d6095 5
a6099 5
        {
          if ((strcasecmp (arglist[0], arglist[1]) == 0) &&
              (arglist[2] != (char *)NULL))
            execute_string ("%s\n", arglist[2]);
        }
d6112 3
a6114 3
      name = &output_paragraph[start_pos];
      output_paragraph[end_pos] = 0;
      name = xstrdup (name);
d6122 1
a6122 1
        add_word_args (_("{No Value For \"%s\"}"), name);
d6137 1
d6157 6
a6162 6
        {
          if (*temp == delimiter)
            delimiter = 0;
          else
            delimiter = *temp;
        }
d6170 1
a6170 1
  *temp = 0;
d6173 1
a6173 1
    line_error (_("%c%s requires a name"), COMMAND_PREFIX, command);
d6177 4
a6180 4
        {
        case SET:
          {
            char *value;
d6183 2
a6184 2
            /* Allow a value to be saved along with a variable.  The value is
               the text following an `=' sign in NAME, if any is present. */
d6186 1
a6186 1
            for (value = name; *value && *value != '='; value++);
d6188 2
a6189 2
            if (*value)
              *value++ = 0;
d6191 5
a6195 5
            if (*value == '"' || *value == '\'')
              {
                value++;
                value[strlen (value) - 1] = 0;
              }
d6198 9
a6206 9
            /* The VALUE of NAME is the remainder of the line sans
               whitespace. */
            if (additional_text_present)
              {
                value = temp + 1;
                canon_white (value);
              }
            else
              value = "";
d6209 81
a6289 92
            set (name, value);
          }
          break;

        case CLEAR:
          clear (name);
          break;

        case IFSET:
        case IFCLEAR:
          /* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,
             read lines from the the file until we reach a matching
             "@@end CONDITION".  This means that we only take note of
             "@@ifset/clear" and "@@end" commands. */
          {
            char condition[8];
            int condition_len;
            int orig_line_number = line_number;

            if (action == IFSET)
              strcpy (condition, "ifset");
            else
              strcpy (condition, "ifclear");

            condition_len = strlen (condition);

          if ((action == IFSET && !set_p (name))
              || (action == IFCLEAR && set_p (name)))
            {
              int level = 0, done = 0;

              while (!done && input_text_offset < size_of_input_text)
                {
                  char *freeable_line, *line;

                  get_rest_of_line (&freeable_line);

                  for (line = freeable_line; whitespace (*line); line++);

                  if (*line == COMMAND_PREFIX &&
                      (strncmp (line + 1, condition, condition_len) == 0))
                    level++;
                  else if (strncmp (line, "@@end", 4) == 0)
                    {
                      char *cname = line + 4;
                      char *temp;

                      while (*cname && whitespace (*cname))
                        cname++;
                      temp = cname;

                      while (*temp && !whitespace (*temp))
                        temp++;
                      *temp = 0;

                      if (strcmp (cname, condition) == 0)
                        {
                          if (!level)
                            {
                              done = 1;
                            }
                          else
                            level--;
                        }
                    }
                  free (freeable_line);
                }
              
              if (!done)
                {
                  int save = line_number;
                  line_number = orig_line_number;
                  line_error (_("Reached eof before matching @@end %s"),
                              condition);
                  line_number = save;
                }
                
              /* We found the end of a false @@ifset/ifclear.  If we are
                 in a menu, back up over the newline that ends the ifset,
                 since that newline may also begin the next menu entry. */
              break;
            }
          else
            {
              if (action == IFSET)
                begin_insertion (ifset);
              else
                begin_insertion (ifclear);
            }
          }
          break;
        }
d6296 3
a6298 3
  char *string;                 /* The string buffer. */
  int size;                     /* The size of the buffer. */
  int in_use;                   /* Nonzero means string currently in use. */
d6315 5
a6319 5
        if (execution_strings[i] && (execution_strings[i]->in_use == 0))
          {
            es = execution_strings[i];
            break;
          }
d6325 7
a6331 7
        {
          execution_strings = (EXECUTION_STRING **)xrealloc
            (execution_strings,
             (execution_strings_slots += 3) * sizeof (EXECUTION_STRING *));
          for (; i < execution_strings_slots; i++)
            execution_strings[i] = (EXECUTION_STRING *)NULL;
        }
d6334 1
a6334 1
        (EXECUTION_STRING *)xmalloc (sizeof (EXECUTION_STRING));
d6341 30
a6370 1
    }
d6372 1
a6372 7
  if (initial_size > es->size)
    {
      es->string = (char *) xrealloc (es->string, initial_size);
      es->size = initial_size;
    }
  return (es);
}
a6373 2
/* Execute the string produced by formatting the ARGs with FORMAT.  This
   is like submitting a new file with @@include. */
d6375 2
a6376 7
#if defined (VA_FPRINTF) && __STDC__
execute_string (char *format, ...)
#else
execute_string (format, va_alist)
    char *format;
    va_dcl
#endif
a6379 3
#ifdef VA_FPRINTF
  va_list ap;
#endif
d6385 3
a6387 7
  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (temp_string, format, ap);
#else
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
d6392 1
a6392 1
  input_filename = xstrdup (input_filename);
a6418 1
  FILE *saved_macro_expansion_output_stream = macro_expansion_output_stream;
a6420 2
  macro_expansion_output_stream = NULL;
  paragraph_is_open = 1;
a6421 1
  macro_expansion_output_stream = saved_macro_expansion_output_stream;
d6464 1
d6468 1
a6468 1
         is active. */
d6472 106
a6577 113
        {
        case multitable:
          multitable_item ();
          /* Ultra special hack.  It appears that some people incorrectly
             place text directly after the @@item, instead of on a new line
             by itself.  This happens to work in TeX, so I make it work
             here. */
          if (*rest_of_line)
            {
              line_number--;
              input_text_offset = original_input_text_offset;
            }
          break;

        case ifinfo:
        case ifset:
        case ifclear:
        case cartouche:
          stack = stack->next;
          if (!stack)
            goto no_insertion;
          else
            goto switch_top;
          break;

        case menu:
        case quotation:
        case example:
        case smallexample:
        case lisp:
        case format:
        case display:
        case group:
          line_error (_("The `%c%s' command is meaningless within a `@@%s' block"),
                      COMMAND_PREFIX, command,
                      insertion_type_pname (current_insertion_type ()));
          break;

        case itemize:
        case enumerate:
          if (itemx_flag)
            {
              line_error (_("%citemx is not meaningful inside of a `%s' block"),
                          COMMAND_PREFIX,
                          insertion_type_pname (current_insertion_type ()));
            }
          else
            {
              start_paragraph ();
              kill_self_indent (-1);
              filling_enabled = indented_fill = 1;

              if (current_insertion_type () == itemize)
                {
                  indent (output_column = current_indent - 2);

                  /* I need some way to determine whether this command
                     takes braces or not.  I believe the user can type
                     either "@@bullet" or "@@bullet{}".  Of course, they
                     can also type "o" or "#" or whatever else they want. */
                  if (item_func && *item_func)
                    {
                      if (*item_func == COMMAND_PREFIX)
                        if (item_func[strlen (item_func) - 1] != '}')
                          execute_string ("%s{}", item_func);
                        else
                          execute_string ("%s", item_func);
                      else
                        execute_string ("%s", item_func);
                    }
                  insert (' ');
                  output_column++;
                }
              else
                enumerate_item ();

              /* Special hack.  This makes `close_paragraph' a no-op until
                 `start_paragraph' has been called. */
              must_start_paragraph = 1;

              /* Handle text directly after the @@item.  */
              if (*rest_of_line)
                {
                  line_number--;
                  input_text_offset = original_input_text_offset;
                }
            }
          break;

        case table:
        case ftable:
        case vtable:
          {
            /* We need this to determine if we have two @@item's in a row
               (see test just below).  */
            static int last_item_output_position = 0;
            
            /* Get rid of extra characters. */
            kill_self_indent (-1);

            /* If we have one @@item followed directly by another @@item,
               we need to insert a blank line.  This is not true for
               @@itemx, though.  */
            if (!itemx_flag && last_item_output_position == output_position)
              insert ('\n');
              
            /* `close_paragraph' almost does what we want.  The problem
               is when paragraph_is_open, and last_char_was_newline, and
               the last newline has been turned into a space, because
               filling_enabled. I handle it here. */
            if (last_char_was_newline && filling_enabled && paragraph_is_open)
              insert ('\n');
            close_paragraph ();
d6580 11
a6590 9
            /* Indent on a new line, but back up one indentation level. */
            {
              int save = inhibit_paragraph_indentation;
              inhibit_paragraph_indentation = 1;
              /* At this point, inserting any non-whitespace character will
                 force the existing indentation to be output. */
              add_char ('i');
              inhibit_paragraph_indentation = save;
            }
d6592 1
a6592 1
            add_char ('i');
d6595 2
a6596 2
            output_paragraph_offset--;
            kill_self_indent (default_indentation_increment + 1);
d6598 19
a6616 19
            /* Add item's argument to the line. */
            filling_enabled = 0;
            if (item_func && *item_func)
              execute_string ("%s{%s}", item_func, rest_of_line);
            else
              execute_string ("%s", rest_of_line);

            if (current_insertion_type () == ftable)
              execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);
            else if (current_insertion_type () == vtable)
              execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

            /* Start a new line, and let start_paragraph ()
               do the indenting of it for you. */
            close_single_paragraph ();
            indented_fill = filling_enabled = 1;
            last_item_output_position = output_position;
          }
        }
d6622 2
a6623 2
      line_error (_("%c%s found outside of an insertion block"),
                  COMMAND_PREFIX, command);
d6628 3
a6630 3
/*                                                                  */
/*                      Defun and Friends                           */
/*                                                                  */
d6633 4
a6636 4
#define DEFUN_SELF_DELIMITING(c)                                        \
  (((c) == '(')                                                         \
   || ((c) == ')')                                                      \
   || ((c) == '[')                                                      \
d6664 1
a6664 1
        (accumulator->tokens, (accumulator->length * sizeof (char *)));
d6684 1
a6684 1
  *scan_result = 0;
d6703 4
a6706 4
        {
          (*string_pointer) = scan_string;
          return (1);
        }
d6708 10
a6717 10
      if (c == 0)
        {
          /* Tweak line_number to compensate for fact that
             we gobbled the whole line before coming here. */
          line_number -= 1;
          line_error (_("Missing `}' in %cdef arg"), COMMAND_PREFIX);
          line_number += 1;
          (*string_pointer) = (scan_string - 1);
          return (0);
        }
d6719 1
a6719 1
        level += 1;
d6721 1
a6721 1
        level -= 1;
d6739 1
a6739 1
  while ((*scan_string) != 0)
d6743 7
a6749 7
        {
          scan_string += 1;
          while (whitespace (*scan_string))
            scan_string += 1;
          accumulate_token ((&accumulator), (xstrdup (" ")));
          continue;
        }
d6753 28
a6780 28
        {
          token_start = scan_string;
          scan_string += 1;
          if (self_delimiting (*scan_string))
            scan_string += 1;
          else
            {
              register int c;
              while (1)
                {
                  c = *scan_string++;

                  if ((c == 0) || (c == '{') || (whitespace (c)))
                    {
                      scan_string -= 1;
                      break;
                    }
                }

              if (*scan_string == '{')
                {
                  char *s = scan_string;
                  (void) scan_group_in_string (&s);
                  scan_string = s;
                }
            }
          token_end = scan_string;
        }
d6784 5
a6788 5
        {
          token_start = scan_string;
          scan_string += 1;
          token_end = scan_string;
        }
d6792 8
a6799 8
        {
          char *s = scan_string;
          int balanced = scan_group_in_string (&s);

          token_start = scan_string + 1;
          scan_string = s;
          token_end = balanced ? (scan_string - 1) : scan_string;
        }
d6802 1
a6802 1
         brackets, or braces.  A token is also ended by a command. */
d6804 2
a6805 2
        {
          token_start = scan_string;
d6807 3
a6809 3
          while (1)
            {
              register int c;
d6811 1
a6811 1
              c = *scan_string++;
d6816 17
a6832 17
              if (!c || whitespace (c) || DEFUN_SELF_DELIMITING (c)
                  || c == '{')
                {
                  scan_string--;
                  break;
                }

              /* If we encounter a command embedded within a token,
                 then end the token. */
              if (c == COMMAND_PREFIX)
                {
                  scan_string--;
                  break;
                }
            }
          token_end = scan_string;
        }
d6835 1
a6835 1
        (&accumulator, copy_substring (token_start, token_end));
d6853 1
a6853 1
        break;
d6856 4
a6859 4
        {
          pending_space = 1;
          continue;
        }
d6862 4
a6865 4
        {
          add_char (' ');
          pending_space = 0;
        }
d6868 1
a6868 1
        add_char (defun_arg[0]);
d6870 1
a6870 1
        add_word (defun_arg);
d6872 1
a6872 1
        execute_string ("%s", defun_arg);
d6874 1
a6874 1
        execute_string ("%cvar{%s}", COMMAND_PREFIX, defun_arg);
d6876 1
a6876 1
        add_word (defun_arg);
d6900 1
a6900 1
   X_P, if nonzero, says not to start a new insertion. */
d6922 1
a6922 1
      category = _("Function");
d6926 1
a6926 1
      category = _("Macro");
d6930 1
a6930 1
      category = _("Special Form");
d6934 1
a6934 1
      category = _("Variable");
d6938 1
a6938 1
      category = _("User Option");
d6942 1
a6942 1
      category = _("Function");
d6946 1
a6946 1
      category = _("Variable");
d6950 1
a6950 1
      category = _("Instance Variable");
d6954 1
a6954 1
      category = _("Method");
d6958 1
a6958 1
      category = _("Method");
d7024 1
a7024 1
                      defined_name);
d7041 3
a7043 9

      /* Through Makeinfo 1.67 we processed remaining args only for deftp,
         deftypefn, and deftypemethod.  But the libc manual, for example,
         needs to say:
            @@deftypevar {char *} tzname[2]
         And simply allowing the extra text seems far simpler than trying
         to invent yet more defn commands.  In any case, we should either
         output it or give an error, not silently ignore it.  */
    default:
d7080 1
a7080 1
        break;
d7094 1
a7094 1
  char *temp = xstrdup (command);
d7099 1
a7099 1
    temp[strlen (temp) - 1] = 0;
d7109 2
a7110 2
      line_error (_("Must be in a `%s' insertion in order to use `%s'x"),
                  command, command);
d7118 30
d7149 3
a7151 3
/*                                                                  */
/*                      Other Random Commands                       */
/*                                                                  */
d7211 1
a7211 1
      line_error (_("%csp requires a positive numeric argument"), COMMAND_PREFIX);
d7216 1
a7216 1
        lines = 0;
d7219 1
a7219 1
        add_char ('\n');
d7230 1
a7230 1
  char *line;
d7234 1
a7234 1
  if (!no_headers)
d7266 1
a7266 1
        i--;
d7280 1
a7280 1
        insert (' ');
d7283 1
a7283 1
        insert (line[i]);
d7366 14
d7425 2
a7426 2
      line_error ("%c%s %s: %s", COMMAND_PREFIX, command, filename,
                  strerror (errno));
d7435 1
a7435 1
        remember_itext (input_text, input_text_offset);
d7447 1
a7447 1
  line_error (_("Misplaced %c"), '}');
a7455 40

/* Set the paragraph indentation variable to the value specified in STRING.
   Values can be:
     `asis': Don't change existing indentation.
     `none': Remove existing indentation.
        NUM: Indent NUM spaces at the starts of paragraphs.
             If NUM is zero, we assume `none'.
   Returns 0 if successful, or nonzero if STRING isn't one of the above. */
int
set_paragraph_indent (string)
     char *string;
{
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    paragraph_start_indent = 0;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    paragraph_start_indent = -1;
  else
    {
      if (sscanf (string, "%d", &paragraph_start_indent) != 1)
        return (-1);
      else
        {
          if (paragraph_start_indent == 0)
            paragraph_start_indent = -1;
        }
    }
  return (0);
}

void
cm_paragraphindent ()
{
  char *arg;

  get_rest_of_line (&arg);
  if (set_paragraph_indent (arg) != 0)
    line_error (_("Bad argument to %c%s"), COMMAND_PREFIX, command);

  free (arg);
}
d7458 3
a7460 3
/*                                                                  */
/*                      Indexing Stuff                              */
/*                                                                  */
d7468 5
a7472 6
  char *entry;                  /* The index entry itself. */
  char *node;                   /* The node from whence it came. */
  int code;                     /* Nonzero means add `@@code{...}' when
                                   printing this element. */
  int defining_line;            /* Line number where this entry was written. */
  char *defining_file;          /* Source file for defining_line. */
d7475 4
a7478 29
/* A list of short-names for each index.

   There are two indices into the the_indices array.

   * read_index is the index that points to the list of index
     entries that we will find if we ask for the list of entries for
     this name.

   * write_index is the index that points to the list of index entries
     that we will add new entries to.

   Initially, read_index and write index are the same, but the
   @@syncodeindex and @@synindex commands can change the list we add
   entries to.

   For example, after the commands

     @@cindex foo
     @@defindex ii
     @@synindex cp ii
     @@cindex bar

   the cp index will contain the entry `foo', and the new ii
   index will contain the entry `bar'.  This is consistent with the
   way texinfo.tex handles the same situation.

   In addition, for each index, it is remembered whether that index is
   a code index or not.  Code indices have @@code{} inserted around the
   first word when they are printed with printindex. */
d7482 1
a7482 2
  int read_index;   /* index entries for `name' */
  int write_index;  /* store index entries here, @@synindex can change it */
d7496 8
d7515 1
a7515 1
                                            sizeof (INDEX_ELT *));
d7519 1
a7519 1
                                                   sizeof (INDEX_ALIST *));
d7525 1
a7525 14
    {
      undefindex (name_index_alist[i]->name);
      if (name_index_alist[i])
        { /* Suppose we're called with two input files, and the first
             does a @@synindex pg cp.  Then, when we get here to start
             the second file, the "pg" element won't get freed by
             undefindex (because it's pointing to "cp").  So free it
             here; otherwise, when we try to define the pg index again
             just below, it will still point to cp.  */
          free (name_index_alist[i]->name);
          free (name_index_alist[i]);
          name_index_alist[i] = (INDEX_ALIST *) NULL;
        }
    }
d7528 7
a7534 6
  top_defindex ("cp", 0);           /* cp is the only non-code index.  */
  top_defindex ("fn", 1);
  top_defindex ("ky", 1);
  top_defindex ("pg", 1);
  top_defindex ("tp", 1);
  top_defindex ("vr", 1);
d7546 2
a7547 2
        strcmp (name, name_index_alist[i]->name) == 0)
      return (i);
d7573 1
a7573 1
    return (which->read_index);
d7600 1
a7600 3
      /* Do not free the node, because we already freed the tag table,
         which freed all the node names.  */
      /* free (temp->node); */
d7606 1
a7606 2
/* Flush an index by name.  This will delete the list of entries that
   would be written by a @@printindex command for this index. */
d7614 1
a7614 3
  /* The index might have already been freed if this was the target of
     an @@synindex.  */
  if (which < 0 || !name_index_alist[which])
d7617 1
a7617 1
  i = name_index_alist[which]->read_index;
d7628 1
a7628 1
   CODE if Nonzero says to make this a code index. */
d7644 2
a7645 2
        slot = i;
        break;
d7655 2
a7656 2
        xrealloc ((char *)name_index_alist,
                  (1 + defined_indices) * sizeof (INDEX_ALIST *));
d7658 2
a7659 2
        xrealloc ((char *)the_indices,
                  (1 + defined_indices) * sizeof (INDEX_ELT *));
d7664 2
a7665 3
  name_index_alist[slot]->name = xstrdup (name);
  name_index_alist[slot]->read_index = slot;
  name_index_alist[slot]->write_index = slot;
d7682 1
a7682 1
  which = tem ? tem->write_index : -1;
d7707 1
a7707 1
      line_error (_("Unknown index `%s'"), name);
a7717 1
      new->defining_file = input_filename;
d7728 1
a7728 1
  char *name = xstrdup (command);
d7730 1
a7730 1
    name[strlen (name) - strlen ("index")] = 0;
d7771 1
a7771 1
      line_error (_("Index `%s' already exists"), name);
d7785 16
d7807 2
a7808 2
  int source, target;
  char *abbrev1, *abbrev2;
d7811 2
a7812 2
  get_until_in_line (0, " ", &abbrev1);
  target = find_index_offset (abbrev1);
d7814 5
a7818 3
  get_until_in_line (0, " ", &abbrev2);
  source = find_index_offset (abbrev2);
  if (source < 0 || target < 0)
d7820 1
a7820 2
      line_error (_("Unknown index `%s' and/or `%s' in @@synindex"),
                  abbrev1, abbrev2);
d7824 16
a7839 2
      name_index_alist[target]->write_index
        = name_index_alist[source]->write_index;
a7840 3
  
  free (abbrev1);
  free (abbrev2);
d7844 1
a7844 1
cm_pindex ()                    /* Pinhead index. */
d7850 1
a7850 1
cm_vindex ()                    /* Variable index. */
d7856 1
a7856 1
cm_kindex ()                    /* Key index. */
d7862 1
a7862 1
cm_cindex ()                    /* Concept index. */
d7868 1
a7868 1
cm_findex ()                    /* Function index. */
d7874 1
a7874 1
cm_tindex ()                    /* Data Type index. */
d7902 3
a7904 3
          (array[i]->node != array[i + 1]->node) ||
          (strcmp (array[i]->entry, array[i + 1]->entry) != 0))
        copy[j++] = array[i];
d7906 4
a7909 4
        {
          free (array[i]->entry);
          free (array[i]);
        }
d7922 1
a7922 1
         so we make the entry name unique. */
d7924 10
a7933 10
          (strcmp (copy[i]->entry, copy[i + 1]->entry) == 0))
        {
          char *new_entry_name;

          new_entry_name = (char *)xmalloc (10 + strlen (copy[i]->entry));
          sprintf (new_entry_name, "%s <%d>", copy[i]->entry, counter);
          free (copy[i]->entry);
          copy[i]->entry = new_entry_name;
          counter++;
        }
d7935 1
a7935 1
        counter = 1;
d7953 1
a7954 1
  INDEX_ELT *temp = index;
a7955 2
  int save_line_number = line_number;
  char *save_input_filename = input_filename;
d7973 2
a7974 4
      /* Set line number and input filename to the source line for this
         index entry, as this expansion finds any errors.  */
      line_number = array[count - 1]->defining_line;
      input_filename = array[count - 1]->defining_file;
d7977 1
a7977 1
         then wrap the entry with "@@code{...}". */
d7982 1
a7982 3
  array[count] = (INDEX_ELT *) NULL;    /* terminate the array. */
  line_number = save_line_number;
  input_filename = save_input_filename;
d7990 1
a7990 1
/* Nonzero means that we are in the middle of printing an index. */
d8013 1
a8013 1
      line_error (_("Unknown index `%s' in @@printindex"), index_name);
d8028 1
a8028 1
  add_word (_("* Menu:\n\n"));
d8043 1
a8043 5
      unsigned new_length = strlen (index->entry);

      if (new_length < 37) /* minimum length used below */
        new_length = 37;
      new_length += strlen (index_node) + 7; /* * : .\n\0 */
d8047 1
a8047 1
          line_length = new_length;
d8075 2
a8076 2

/* User-defined commands, which happens only from user-defined indexes. */
d8091 2
a8092 2
                                              (1 + user_command_array_len) *
                                              sizeof (COMMAND *));
d8095 1
a8095 1
  user_command_array[slot]->name = xstrdup (name);
d8099 42
a8140 1

d8147 2
a8148 2
        Make them look like followed references, with the reference
        destinations in a makeinfo manufactured node or,
d8151 2
a8152 2
        Make them appear at the bottom of the node that they originally
        appeared in. */
d8169 1
a8169 1
           (strcasecmp (string, "EN") == 0))
d8208 2
a8209 2
  temp->marker = xstrdup (marker);
  temp->note = xstrdup (note);
d8236 1
a8236 1
    where "*" is the (optional) marker character for this note. */
a8242 3
  if (macro_expansion_output_stream)
    append_to_expansion_output (input_text_offset + 1); /* include the { */

d8249 2
a8250 2
      line_error (_("`%c%s' needs an argument `{...}', not just `%s'"),
                  COMMAND_PREFIX, command, marker);
d8256 2
a8258 2
      int braces = 1;
      int loc = ++input_text_offset;
d8261 13
a8273 13
        {
          if (loc == size_of_input_text)
            {
              line_error (_("No closing brace for footnote `%s'"), marker);
              return;
            }

          if (input_text[loc] == '{')
            braces++;
          else if (input_text[loc] == '}')
            braces--;
          else if (input_text[loc] == '\n')
            line_number++;
d8275 2
a8276 2
          loc++;
        }
d8278 1
a8278 1
      len = (loc - input_text_offset) - 1;
d8281 2
a8282 18
      note[len] = 0;
      input_text_offset = loc;
    }

  /* Must write the macro-expanded argument to the macro expansion
     output stream.  This is like the case in index_add_arg.  */
  if (macro_expansion_output_stream)
    {
      int op_orig;

      remember_itext (input_text, input_text_offset);
      op_orig = output_paragraph_offset;
      me_execute_string (note);
      /* Calling me_execute_string on a lone } provokes an error, since
         as far as the reader knows there is no matching {.  We wrote
         the { above in the call to append_to_expansion_output. */
      write_region_to_macro_output ("}", 0, 1);
      output_paragraph_offset = op_orig;
d8287 1
a8287 1
      line_error (_("Footnote defined without parent node"));
d8298 5
a8302 5
        {
          marker = (char *)xmalloc (10);
          sprintf (marker, "%d", current_footnote_number);
          current_footnote_number++;
        }
d8304 1
a8304 1
        marker = xstrdup ("*");
d8315 2
a8316 2
        {
          char *temp_string;
d8318 2
a8319 2
          temp_string = (char *)
            xmalloc ((strlen (current_node)) + (strlen (_("-Footnotes"))) + 1);
d8321 7
a8327 7
          add_word_args (" (*note %s-Footnotes::)", current_node);
          strcpy (temp_string, current_node);
          strcat (temp_string, "-Footnotes");
          remember_node_reference (temp_string, line_number, followed_reference);
          free (temp_string);
          first_footnote_this_node = 0;
        }
d8341 1
a8341 1
/* Nonzero means that we are currently in the process of outputting
d8358 2
a8359 2
        char *old_current_node = current_node;
        char *old_command = xstrdup (command);
d8361 7
a8367 7
        already_outputting_pending_notes++;
        execute_string ("%cnode %s-Footnotes,,,%s\n",
                        COMMAND_PREFIX, current_node, current_node);
        already_outputting_pending_notes--;
        current_node = old_current_node;
        free (command);
        command = old_command;
d8374 1
a8374 1
      execute_string (_("---------- Footnotes ----------\n\n"));
d8387 2
a8388 2
        array[footnote_count] = footnote;
        footnote = footnote->next;
d8394 1
a8394 1
    while ((footnote = array[++footnote_count]))
d8396 9
a8404 2
        execute_string ("(%s) %s", footnote->marker, footnote->note);
        close_paragraph ();
d8413 1
a8413 1
/*              User definable Macros (text substitution)           */
d8422 2
a8423 2
int macro_list_len = 0;         /* Number of elements. */
int macro_list_size = 0;        /* Number of slots in total. */
d8437 1
a8437 1
        break;
d8462 2
a8463 2
        macro_list = (MACRO_DEF **)xrealloc
          (macro_list, ((macro_list_size += 10) * sizeof (MACRO_DEF *)));
d8477 1
a8477 1
      warning (_("macro `%s' previously defined"), name);
d8481 2
a8482 1
      warning (_("here is the previous definition of `%s'"), name);
d8488 2
a8489 2
        {
          register int i;
d8491 2
a8492 2
          for (i = 0; def->arglist[i]; i++)
            free (def->arglist[i]);
d8494 2
a8495 2
          free (def->arglist);
        }
d8500 1
a8500 1
  def->source_file = xstrdup (source_file);
d8523 3
a8525 4
        memmove (macro_list + i, macro_list + i + 1,
               ((macro_list_len + 1) - i) * sizeof (MACRO_DEF *));
        macro_list_len--;
        break;
d8536 1
a8536 1
    MACRO_DEF *def;
d8550 3
a8552 3
        {
          return ((char **)NULL);
        }
d8554 25
a8578 28
        {
          /* Braces are not required to fill out the macro arguments.  If
             this macro takes one argument, it is considered to be the
             remainder of the line, sans whitespace. */
          if (def->arglist && def->arglist[0] && !def->arglist[1])
            {
              char **arglist;

              get_rest_of_line (&word);
              if (input_text[input_text_offset - 1] == '\n')
                {
                  input_text_offset--;
                  line_number--;
                }
              /* canon_white (word); */
              arglist = (char **)xmalloc (2 * sizeof (char *));
              arglist[0] = word;
              arglist[1] = (char *)NULL;
              return (arglist);
            }
          else
            {
              /* The macro either took no arguments, or took more than
                 one argument.  In that case, it must be invoked with
                 arguments surrounded by braces. */
              return ((char **)NULL);
            }
        }
d8605 1
a8605 1
        break;
d8608 1
a8608 1
        new_body[new_body_index++] = body[i++];
d8610 53
a8662 56
        {
          /* Snarf parameter name, check against named parameters. */
          char *param;
          int param_start, which, len;

          param_start = ++i;
          while ((body[i]) && (body[i] != '\\'))
            i++;

          len = i - param_start;
          param = (char *)xmalloc (1 + len);
          memcpy (param, body + param_start, len);
          param[len] = 0;

          if (body[i]) /* move past \ */
            i++;

          /* Now check against named parameters. */
          for (which = 0; named && named[which]; which++)
            if (strcmp (named[which], param) == 0)
              break;

          if (named && named[which])
            {
              if (which < length_of_actuals)
                text = actuals[which];
              else
                text = (char *)NULL;

              if (!text)
                text = "";

              len = strlen (text);
            }
          else
            { /* not a parameter, restore \'s */
              char *trailer = body[i] ? "/" : "";
              len += 1 + strlen (trailer);
              text = (char *)xmalloc (1 + len);
              sprintf (text, "\\%s%s", param, trailer);
            }

          if ((2 + strlen (param)) < len)
            {
              new_body_size += len + 1;
              new_body = xrealloc (new_body, new_body_size);
            }

          free (param);

          strcpy (new_body + new_body_index, text);
          new_body_index += len;

          if (!named || !named[which])
            free (text);
        }
d8664 1
a8664 1
  new_body[new_body_index] = 0;
d8673 1
d8690 1
a8690 1
      line_error (_("Macro `%s' called with too many args"), def->name);
d8702 4
a8705 4
        {
          remember_itext (input_text, input_text_offset);
          me_execute_string (execution_string);
        }
d8707 1
a8707 1
        execute_string ("%s", execution_string);
d8741 4
a8744 4
         (i < size_of_input_text) &&
         (input_text[i] != '{') &&
         (!cr_or_whitespace (input_text[i]));
         i++);
d8749 1
a8749 1
    name[len] = 0;
d8765 2
a8766 2
         These words will be replaced within the body of the macro at
         execution time. */
d8772 2
a8773 2
        {
          int len;
d8775 55
a8829 55
          for (i = input_text_offset;
               (character = input_text[i]);
               i++)
            {
              switch (character)
                {
                case '\n':
                  line_number++;
                case ' ':
                case '\t':
                case ',':
                case '}':
                  /* Found the end of the current arglist word.  Save it. */
                  len = i - input_text_offset;
                  word = (char *)xmalloc (1 + len);
                  strncpy (word, input_text + input_text_offset, len);
                  word[len] = 0;
                  input_text_offset = i;

                  /* Advance to the comma or close-brace that signified
                     the end of the argument. */
                  while ((character = curchar ())
                         && character != ','
                         && character != '}')
                    {
                      input_text_offset++;
                      if (character == '\n')
                        line_number++;
                    }

                  /* Add the word to our list of words. */
                  if ((arglist_index + 2) >= arglist_size)
                    arglist = (char **)xrealloc
                      (arglist, (arglist_size += 10) * sizeof (char *));

                  arglist[arglist_index++] = word;
                  arglist[arglist_index] = (char *)NULL;
                  break;
                }

              if (character == '}')
                {
                  input_text_offset++;
                  gathering_words = 0;
                  break;
                }

              if (character == ',')
                {
                  input_text_offset++;
                  skip_whitespace_and_newlines ();
                  i = input_text_offset - 1;
                }
            }
        }
d8839 7
a8845 7
        {
          int temp_line = line_number;
          line_number = defining_line;
          line_error (_("%cend macro not found"), COMMAND_PREFIX);
          line_number = temp_line;
          return;
        }
d8851 12
a8862 12
          (strncmp (line + 1, "allow-recursion", 15) == 0) &&
          (line[16] == 0 || whitespace (line[16])))
        {
          for (i = 16; whitespace (line[i]); i++);
          strcpy (line, line + i);
          flags |= ME_RECURSE;
          if (!*line)
            {
              free (line);
              continue;
            }
        }
d8865 21
a8885 21
          (strncmp (line + 1, "quote-arg", 9) == 0) &&
          (line[10] == 0 || whitespace (line[10])))
        {
          for (i = 10; whitespace (line[i]); i++);
          strcpy (line, line + i);

          if (arglist && arglist[0] && !arglist[1])
            {
              flags |= ME_QUOTE_ARG;
              if (!*line)
                {
                  free (line);
                  continue;
                }
            }
          else
            {
              line_error (_("%cquote-arg only useful when the macro takes a single argument"),
                          COMMAND_PREFIX);
            }
        }
d8888 2
a8889 2
          (strncmp (line + 1, "macro ", 6) == 0))
        depth++;
d8892 2
a8893 2
          (strncmp (line + 1, "end macro", 9) == 0))
        depth--;
d8896 9
a8904 9
        {
          if ((body_index + strlen (line) + 3) >= body_size)
            body = (char *)xrealloc
              (body, body_size += 3 + strlen (line));
          strcpy (body + body_index, line);
          body_index += strlen (line);
          body[body_index++] = '\n';
          body[body_index] = 0;
        }
a8907 10
  /* If it was an empty macro like
     @@macro foo
     @@end macro
     create an empty body.  (Otherwise, the macro is not expanded.)  */
  if (!body)
    {
      body = (char *)malloc(1);
      *body = 0;
    }

d8912 1
a8912 1
    body[strlen (body) - 1] = 0;
d8931 1
d8934 1
a8934 1
  name = (char *)xmalloc (i + 1);
d8936 1
a8936 1
  name[i] = 0;
d8947 2
a8948 2
        {
          register int i;
d8950 2
a8951 2
          for (i = 0; def->arglist[i]; i++)
            free (def->arglist[i]);
d8953 2
a8954 2
          free (def->arglist);
        }
d8982 1
a8982 1
        itext_info[i] = (ITEXT *)NULL;
d8988 1
a8988 1
        (itext_info[i]->pointer == pointer))
d8990 3
a8992 3
        itext = itext_info[i];
        itext_info[i]->offset = offset;
        break;
d8997 2
a8998 2
      /* Find a blank slot (or create a new one), and remember the
         pointer and offset. */
d9000 2
a9001 2
        if (itext_info[i] == (ITEXT *)NULL)
          break;
d9005 2
a9006 2
        {
          register int j;
d9008 2
a9009 2
          itext_info = (ITEXT **)xrealloc
            (itext_info, (itext_size += 10) * sizeof (ITEXT *));
d9011 3
a9013 3
          for (j = i; j < itext_size; j++)
            itext_info[j] = (ITEXT *)NULL;
        }
d9034 3
a9036 3
        free (itext_info[i]);
        itext_info[i] = (ITEXT *)NULL;
        break;
d9060 1
a9060 1
  input_filename = xstrdup (input_filename);
d9083 2
a9084 2
        itext = itext_info[i];
        break;
d9093 1
a9093 1
        (input_text, itext->offset, offset);
d9110 2
a9111 2
        itext = itext_info[i];
        break;
d9154 1
a9154 1
        free (array[i]);
d9183 1
a9183 1
  while ((character = curchar ()))
d9186 4
a9189 4
        {
          input_text_offset += 2;
          escape_seen = 1;
        }
d9191 4
a9194 4
        {
          depth++;
          input_text_offset++;
        }
d9196 35
a9230 35
               ((character == '}') && depth == 1))
        {
          int len = input_text_offset - start;

          if (len || (character != '}'))
            {
              word = (char *)xmalloc (1 + len);
              strncpy (word, input_text + start, len);
              word[len] = 0;

              /* Clean up escaped characters. */
              if (escape_seen)
                {
                  register int i;

                  for (i = 0; word[i]; i++)
                    if (word[i] == '\\')
                      memmove (word + i, word + i + 1,
                               1 + strlen (word + i + 1));
                }

              if (arglist_index + 2 >= arglist_size)
                arglist = (char **)xrealloc
                  (arglist, (arglist_size += 10) * sizeof (char *));

              arglist[arglist_index++] = word;
              arglist[arglist_index] = (char *)NULL;
            }

          input_text_offset++;
          if (character == '}')
            break;
          else
            goto get_arg;
        }
d9232 4
a9235 4
        {
          depth--;
          input_text_offset++;
        }
d9237 4
a9240 4
        {
          input_text_offset++;
          if (character == '\n') line_number++;
        }
d9283 1
a9283 1
        (*index)++;
d9286 1
a9286 1
      return (xstrdup (""));
d9294 1
a9294 1
      value [i - start] = 0;
d9319 1
a9319 7
        (filename[1] == '.' && filename[2] == '/')))
#ifdef WIN32
      /* Handle names that look like "d:/foo/bar" */
      || (isalpha (*filename) && filename [1] == ':' 
          && (filename [2] == '/' || filename [2] == '\\'))
#endif
     )
d9322 1
a9322 1
        return (xstrdup (filename));
d9324 1
a9324 1
        return ((char *)NULL);
d9327 1
a9327 1
  while ((dir = extract_colon_unit (path, &index)))
d9332 4
a9335 4
        {
          free (dir);
          dir = xstrdup (".");
        }
d9344 1
a9344 1
        return (fullpath);
d9346 1
a9346 1
        free (fullpath);
d9348 1
a9348 1
  return NULL;
@


1.1.1.5
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.60 1998/02/25 20:36:22 karl Exp $
d4 1
a4 2
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98
   Free Software Foundation, Inc.
a117 3
/* Nonzero means a macro string is in execution, as opposed to a file. */
static int me_executing_string = 0;

d1085 1
a1085 1
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d1088 1
a1088 2
For more information about these matters, see the files named COPYING.\n"),
		  "1998");
d1146 1
a1146 1
  printf ("makeinfo (GNU %s %s) %d.%d\n", PACKAGE, VERSION,
d1191 1
a1191 1
Email bug reports to bug-texinfo@@gnu.org.\n\
d1193 2
a1194 2
           progname, max_error_level, fill_column,
           paragraph_start_indent, reference_warning_limit);
d1251 2
a1252 2
  /* Load the file, with enough room for a newline and a null. */
  result = xmalloc (file_size + 2);
d1294 1
a1294 1
     SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
a1295 2
  /* This, on the other hand, is always necessary.  */
  input_text[size_of_input_text+1] = 0;
d1336 1
a1336 1
  if (!executing_string && !me_executing_string)
d1820 1
a1820 1
  if (expand && !executing_string && !me_executing_string)
d1836 3
a1838 5
      /* Plunk the expansion into the middle of `input_text' --
         which is terminated by a newline, not a null.  */
      str = xmalloc (real_bottom - limit + 1);
      strncpy (str, input_text + limit, real_bottom - limit + 1);
      new_len = input_text_offset + xp_len + real_bottom - limit + 1;
d1841 1
a1841 2
      strncpy (input_text + input_text_offset + xp_len, str,
	       real_bottom - limit + 1);
d3976 1
a3976 1
      add_word_args ("%d %s %d", ts->tm_mday, _(months[ts->tm_mon]),
d4163 1
a4163 1
  if (macro_expansion_output_stream && !executing_string)
d4171 1
a4171 1
  if (macro_expansion_output_stream && !executing_string)
d4315 1
a4315 1
      line_error (_("Node with %ctop as a section already exists"),
d4733 1
a4733 1
  if (macro_expansion_output_stream && !executing_string)
d4746 1
a4746 1
  if (macro_expansion_output_stream && !executing_string)
d4756 1
a4756 1
      if (macro_expansion_output_stream && !executing_string)
d4937 1
a4937 1
  if (macro_expansion_output_stream && !executing_string && !defaulting)
d5836 1
a5836 1
      char *arg = (char *) &output_paragraph[start_pos];
d5880 1
a5880 1
      char *arg = (char *) &output_paragraph[start_pos];
d6317 2
a6318 2
      char *name = (char *) &output_paragraph[start_pos];
      char *value;
d6626 1
d6629 1
d6632 1
d7271 23
a7293 21
  /* Make an entry in the appropriate index. */
  switch (base_type)
    {
    case deffn:
    case deftypefn:
      execute_string ("%cfindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defvr:
    case deftypevr:
    case defcv:
      execute_string ("%cvindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    case defop:
    case deftypemethod:
      execute_string ("%cfindex %s on %s\n",
		      COMMAND_PREFIX, defined_name, type_name);
      break;
    case deftp:
      execute_string ("%ctindex %s\n", COMMAND_PREFIX, defined_name);
      break;
    }
d7565 1
a7565 1
  if (macro_expansion_output_stream && !executing_string)
d7573 1
a7573 1
  if (macro_expansion_output_stream && !executing_string)
d7611 1
a7611 1
      if (macro_expansion_output_stream && !executing_string)
d7939 1
a7939 1
  if (macro_expansion_output_stream && !executing_string)
d7947 1
a7947 1
  if (macro_expansion_output_stream && !executing_string)
d8439 3
a8444 3
  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1); /* include the { */

d8486 1
a8486 1
  if (macro_expansion_output_stream && !executing_string)
d8857 4
a8860 4
              i = body[i] ? (i - 1) : i;
              len++;
              text = xmalloc (1 + len);
              sprintf (text, "\\%s", param);
d8891 1
a8891 1
  if (macro_expansion_output_stream && !executing_string && !me_inhibit_expansion)
d8914 1
a8914 1
      if (macro_expansion_output_stream && !executing_string && !me_inhibit_expansion)
d8942 1
a8942 1
  if (macro_expansion_output_stream && !executing_string)
d9139 1
a9139 1
  if (macro_expansion_output_stream && !executing_string)
d9150 1
a9150 1
  if (macro_expansion_output_stream && !executing_string)
d9184 1
a9184 1
  if (macro_expansion_output_stream && !executing_string)
d9287 1
a9287 1
  me_executing_string++;
d9290 1
a9290 1
  me_executing_string--;
d9310 1
a9310 1
    return;
@


1.1.1.6
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* makeinfo -- convert Texinfo source into other formats.
   $Id: makeinfo.c,v 1.171 1999/09/19 15:24:44 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99
d23 8
d34 18
a51 11
#define COMPILING_MAKEINFO
#include "makeinfo.h"
#include "cmds.h"
#include "files.h"
#include "footnote.h"
#include "html.h"
#include "index.h"
#include "insertion.h"
#include "macro.h"
#include "node.h"
#include "toc.h"
a71 9
/* DJGPP supports /dev/null, which is okay for Unix aficionados,
   shell scripts and Makefiles, but interactive DOS die-hards
   would probably want to have NUL as well.  */
#ifdef __DJGPP__
# define ALSO_NULL_DEVICE  "NUL"
#else
# define ALSO_NULL_DEVICE  ""
#endif

d81 5
d98 52
d151 15
a165 1
/* Global variables.  */
d168 2
a169 1
char *output_filename = NULL;
d173 1
a173 1
char *command_output_filename = NULL;
d175 6
a180 3
/* Flags which control initial output string for xrefs. */
int px_ref_flag = 0;
int ref_flag = 0;
d185 10
d205 6
d216 24
d244 8
d257 51
d314 55
d377 6
d386 2
a387 7
/* The actual last inserted character.  Note that this may be something
   other than NEWLINE even if last_char_was_newline is 1. */
int last_inserted_character = 0;

/* Nonzero means that a newline character has already been
   inserted, so close_paragraph () should insert one less. */
int line_already_broken = 0;
d389 16
a404 3
/* When nonzero we have finished an insertion (see end_insertion ()) and we
   want to ignore false continued paragraph closings. */
int insertion_paragraph_closed = 0;
d406 2
a407 2
/* Nonzero means attempt to make all of the lines have fill_column width. */
int do_justification = 0;
a412 1
  char *command;
d417 1
a417 1
BRACE_ELEMENT *brace_stack = NULL;
d419 1
a419 1
extern void do_multitable (), end_multitable ();
d421 2
d424 1
a424 1
void remember_error ();
d430 1
a430 1
void free_node_references (), handle_variable ();
d433 3
a435 2
void add_anchor_name ();
void free_node_node_references (), remember_node_node_reference ();
d438 1
d443 1
a443 1
void reader_loop ();
d448 1
a448 1
void close_paragraph ();
a451 14
void inhibit_output_flushing (), uninhibit_output_flushing ();
int set_paragraph_indent ();
int self_delimiting (), search_forward ();
int multitable_item (), number_of_node ();
extern void add_link (), add_escaped_anchor_name ();

void me_execute_string_keep_state ();
void maybe_update_execution_strings ();

extern char *escape_string ();
extern void insert_html_tag ();
extern void sectioning_html ();
extern void add_link ();

d459 1
a459 1
#endif /* no prototypes */
d461 348
a808 1
/* Error handling.  */
d820 1
a820 1
  return 0;
d919 1
a919 1
      xexit (1);
a921 7

/* The other side of a malformed expression. */
void
misplaced_brace ()
{
  line_error (_("Misplaced %c"), '}');
}
d923 5
a927 119
/* Main.  */

/* Display the version info of this invocation of Makeinfo. */
static void
print_version_info ()
{
  printf ("makeinfo (GNU %s) %s\n", PACKAGE, VERSION);
}

/* If EXIT_VALUE is zero, print the full usage message to stdout.
   Otherwise, just say to use --help for more info.
   Then exit with EXIT_VALUE. */
static void
usage (exit_value)
     int exit_value;
{
  if (exit_value != 0)
    fprintf (stderr, _("Try `%s --help' for more information.\n"), progname);
  else
  {
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n\
\n\
Translate Texinfo source documentation to various other formats:\n\
Info files suitable for reading online with Emacs or standalone GNU Info\n\
(by default); plain text (with --no-headers); or HTML (with --html).\n\
\n\
Options:\n\
 --commands-in-node-names  allow @@ commands in node names.\n\
 -D VAR                    define a variable, as with @@set.\n\
 -E, --macro-expand FILE   output macro-expanded source to FILE.\n\
 --error-limit=NUM         quit after NUM errors (default %d).\n\
 --fill-column=NUM         break Info lines at NUM characters (default %d).\n\
 --footnote-style=STYLE    output footnotes according to STYLE:\n\
                            `separate' to place footnotes in their own node,\n\
                            `end' to place the footnotes at the end of the\n\
                             node in which they are defined (the default).\n\
 --force                   preserve output even if errors.\n\
 --help                    display this help and exit.\n\
 --html                    output HTML rather than Info format;\n\
 -I DIR                    append DIR to the @@include search path.\n\
 --ifhtml                  process @@ifhtml and @@html text even when not\n\
                             generating HTML.\n\
 --ifinfo                  process @@ifinfo text even when generating HTML.\n\
 --iftex                   process @@iftex and @@tex text.\n\
                             implies --no-split.\n"),
	    progname, max_error_level, fill_column);
    printf (_("\
 --no-headers              suppress Info node separators and Node: lines and\n\
                             write to standard output without --output.\n\
 --no-ifhtml               do not process @@ifhtml and @@html text.\n\
 --no-ifinfo               do not process @@ifinfo text.\n\
 --no-iftex                do not process @@iftex and @@tex text.\n\
 --no-split                suppress splitting of large Info output files or\n\
                           generation of one HTML file per node.\n\
 --no-validate             suppress node cross-reference validation.\n\
 --no-warn                 suppress warnings (but not errors).\n\
 --number-sections         include chapter, section, etc. numbers in output.\n\
 -o, --output=FILE         output to FILE, ignoring any @@setfilename.\n\
 -P DIR                    prepend DIR to the @@include search path.\n\
 --paragraph-indent=VAL    indent Info paragraphs by VAL spaces (default %d).\n\
                             if VAL is `none', do not indent;\n\
                             if VAL is `asis', preserve existing indentation.\n\
 --reference-limit=NUM     warn about at most NUM references (default %d).\n\
 -U VAR                    undefine a variable, as with @@clear.\n\
 -v, --verbose             explain what is being done.\n\
 --version                 display version information and exit.\n\
"),
            paragraph_start_indent, reference_warning_limit);
  }

  puts (_("\n\
The defaults for the @@if... conditionals depend on the output format:\n\
if generating HTML, --ifhtml is on and the others are off;\n\
if generating Info or plain text, --ifinfo is on and the others are off.\n\
\n\
Examples:\n\
  makeinfo foo.texi                    write Info to foo's @@setfilename\n\
  makeinfo --html foo.texi             write HTML to foo's @@setfilename\n\
  makeinfo --no-headers -o - foo.texi  write plain text to standard output\n\
  makeinfo --number-sections foo.texi  write Info with numbered sections\n\
  makeinfo --no-split foo.texi         write one Info file however big\n\
\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org."));
  xexit (exit_value);
}

struct option long_options[] =
{
  { "commands-in-node-names", 0, &expensive_validation, 1 },
  { "error-limit", 1, 0, 'e' },
  { "fill-column", 1, 0, 'f' },
  { "footnote-style", 1, 0, 's' },
  { "force", 0, &force, 1 },
  { "help", 0, 0, 'h' },
  { "html", 0, 0, 'w' },
  { "ifhtml", 0, &process_html, 1 },
  { "ifinfo", 0, &process_info, 1 },
  { "iftex", 0, &process_tex, 1 },
  { "macro-expand", 1, 0, 'E' },
  { "no-headers", 0, &no_headers, 1 },
  { "no-ifhtml", 0, &process_html, 0 },
  { "no-ifinfo", 0, &process_info, 0 },
  { "no-iftex", 0, &process_tex, 0 },
  { "no-number-footnotes", 0, &number_footnotes, 0 },
  { "no-number-sections", 0, &number_sections, 0 },
  { "no-pointer-validate", 0, &validating, 0 },
  { "no-split", 0, &splitting, 0 },
  { "no-validate", 0, &validating, 0 },
  { "no-warn", 0, &print_warnings, 0 },
  { "number-footnotes", 0, &number_footnotes, 1 },
  { "number-sections", 0, &number_sections, 1 },
  { "output", 1, 0, 'o' },
  { "paragraph-indent", 1, 0, 'p' },
  { "reference-limit", 1, 0, 'r' },
  { "verbose", 0, &verbose_mode, 1 },
  { "version", 0, 0, 'V' },
  {NULL, 0, NULL, 0}
};
d937 1
d941 3
a948 2
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
d956 1
a956 1
  while ((c = getopt_long (argc, argv, "D:e:E:f:hI:o:p:P:r:s:U:vV:w",
d970 2
a971 1
        case 'e': /* --error-limit */
d977 1
a977 1
              usage (stderr, 1);
d981 2
a982 1
        case 'E': /* --macro-expand */
d995 2
a996 1
        case 'f': /* --fill-column */
d1000 1
a1000 1
                       _("%s: %s arg must be numeric, not `%s'.\n"),
d1002 1
a1002 1
              usage (1);
d1006 6
a1011 2
        case 'h': /* --help */
          usage (0);
d1022 1
a1022 1
          strcat (include_files_path, PATH_SEP);
d1026 2
a1027 1
        case 'o': /* --output */
d1031 2
a1032 1
        case 'p': /* --paragraph-indent */
d1036 1
a1036 1
   _("%s: --paragraph-indent arg must be numeric/`none'/`asis', not `%s'.\n"),
d1038 1
a1038 1
              usage (1);
d1047 1
a1047 1
              include_files_path = xrealloc (include_files_path,
d1049 1
a1049 1
              strcat (strcat (include_files_path, PATH_SEP), ".");
d1054 1
a1054 1
              include_files_path = xrealloc (include_files_path,
d1062 3
a1064 2

        case 'r': /* --reference-limit */
d1068 1
a1068 1
                     _("%s: %s arg must be numeric, not `%s'.\n"),
d1070 1
a1070 1
              usage (1);
d1074 2
a1075 1
        case 's': /* --footnote-style */
d1079 1
a1079 1
          _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"),
d1081 1
a1081 1
              usage (1);
d1086 2
a1087 5
        case 'v':
          verbose_mode++;
          break;

        case 'V': /* --version */
d1089 1
a1089 2
          puts ("");
          printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d1093 2
a1094 9
                  "1999");
          exit (0);
          break;

        case 'w': /* --html */
          html = 1;
          process_html = 1;
          process_info = 0;
          splitting = 0; /* too complicated for now */
d1098 1
a1098 1
          usage (1);
a1102 3
  if (!validating)
    expensive_validation = 0;

d1111 1
a1111 1
          usage (1);
d1115 4
a1120 9
      if (html && splitting)
        { /* --no-headers --no-split --html indicates confusion. */
          fprintf (stderr,
                   "%s: --no-headers conflicts with --no-split for --html.\n",
                   progname);
          usage (1);
        }

      /* --no-headers implies --no-split.  */
d1123 1
a1123 1
      /* If the user did not specify an output file, use stdout. */
d1141 12
a1152 1
  return errors_printed ? 2 : 0;
d1155 47
d1203 1
a1203 1
/* Hacking tokens and strings.  */
d1205 10
a1214 3
/* Return the next token as a string pointer.  We cons the string. */
char *
read_token ()
d1216 2
a1217 2
  int i, character;
  char *result;
d1219 1
a1219 4
  /* If the first character to be read is self-delimiting, then that
     is the command itself. */
  character = curchar ();
  if (self_delimiting (character))
d1221 61
a1281 1
      input_text_offset++;
d1283 2
a1284 2
      if (character == '\n')
        line_number++;
d1286 1
a1286 3
      result = xstrdup (" ");
      *result = character;
      return result;
d1288 1
d1290 14
a1303 8
  for (i = 0; ((input_text_offset != input_text_length)
               && (character = curchar ())
               && command_char (character));
       i++, input_text_offset++);
  result = xmalloc (i + 1);
  memcpy (result, &input_text[input_text_offset - i], i);
  result[i] = 0;
  return result;
d1306 3
a1308 4
/* Return nonzero if CHARACTER is self-delimiting. */
int
self_delimiting (character)
     int character;
d1310 10
a1319 3
  /* @@; and @@\ are not Texinfo commands, but they are listed here
     anyway.  I don't know why.  --karl, 10aug96.  */
  return strchr ("~{|}`^\\@@?=;:.-,*\'\" !\n\t", character) != NULL;
d1322 1
a1322 1
/* Clear whitespace from the front and end of string. */
d1324 1
a1324 2
canon_white (string)
     char *string;
d1326 1
a1326 2
  int len = strlen (string);
  int x;
d1328 2
a1329 2
  if (!len)
    return;
d1331 2
a1332 1
  for (x = 0; x < len; x++)
d1334 2
a1335 5
      if (!cr_or_whitespace (string[x]))
        {
          strcpy (string, string + x);
          break;
        }
d1337 19
a1355 6
  len = strlen (string);
  if (len)
    len--;
  while (len > -1 && cr_or_whitespace (string[len]))
    len--;
  string[len + 1] = 0;
d1358 1
a1358 1
/* Bash STRING, replacing all whitespace with just one space. */
d1360 1
a1360 2
fix_whitespace (string)
     char *string;
d1362 9
a1370 4
  char *temp = xmalloc (strlen (string) + 1);
  int string_index = 0;
  int temp_index = 0;
  int c;
d1372 335
a1706 1
  canon_white (string);
d1734 1
a1734 1
  int tt = (temp < 0) ? input_text_length : temp + strlen (string);
d1744 1
a1744 1
      input_text_offset = input_text_length - strlen (string);
d1772 1
a1772 1
    new_point = input_text_length;
d1781 1
a1781 1
  *string = xmalloc (len + 1);
d1789 2
a1790 2
  if (input_text_offset > input_text_length)
    input_text_offset = input_text_length;
d1792 1
a1792 75
  return new_point;
}

/* Replace input_text[FROM .. TO] with its expansion.  */
void
replace_with_expansion (from, to)
     int from, *to;
{
  char *xp;
  unsigned xp_len, new_len;
  char *old_input = input_text;
  unsigned raw_len = *to - from;
  char *str;

  /* The rest of the code here moves large buffers, so let's
     not waste time if the input cannot possibly expand
     into anything.  Unfortunately, we cannot avoid expansion
     when we see things like @@code etc., even if they only
     asked for expansion of macros, since any Texinfo command
     can be potentially redefined with a macro.  */
  if (only_macro_expansion &&
      memchr (input_text + from, COMMAND_PREFIX, raw_len) == 0)
    return;

  /* Get original string from input.  */
  str = xmalloc (raw_len + 1);
  memcpy (str, input_text + from, raw_len);
  str[raw_len] = 0;

  /* We are going to relocate input_text, so we had better output
     pending portion of input_text now, before the pointer changes.  */
  if (macro_expansion_output_stream && !executing_string
      && !me_inhibit_expansion)
    append_to_expansion_output (from);

  /* Expand it.  */
  xp = expansion (str, 0);
  xp_len = strlen (xp);
  free (str);

  /* Plunk the expansion into the middle of `input_text' --
     which is terminated by a newline, not a null.  Avoid
     expensive move of the rest of the input if the expansion
     has the same length as the original string.  */
  if (xp_len != raw_len)
    {
      new_len = from + xp_len + input_text_length - *to + 1;
      if (executing_string)
        { /* If we are in execute_string, we might need to update
             the relevant element in the execution_strings[] array,
             since it could have to be relocated from under our
             feet.  (input_text is reallocated here as well, if needed.)  */
          maybe_update_execution_strings (&input_text, new_len);
        }
      else if (new_len > input_text_length + 1)
        /* Don't bother to realloc if we have enough space.  */
        input_text = xrealloc (input_text, new_len);

      memmove (input_text + from + xp_len,
               input_text + *to, input_text_length - *to + 1);

      *to += xp_len - raw_len;
      /* Since we change input_text_length here, the comparison above
         isn't really valid, but it seems the worst that might happen is
         an extra xrealloc or two, so let's not worry.  */
      input_text_length += xp_len - raw_len;
    }
  memcpy (input_text + from, xp, xp_len);
  free (xp);

  /* Synchronize the macro-expansion pointers with our new input_text.  */
  if (input_text != old_input)
    forget_itext (old_input);
  if (macro_expansion_output_stream && !executing_string)
    remember_itext (input_text, from);
d1796 1
a1796 3
   Place the characters read into STRING.  If EXPAND is nonzero,
   expand the text before looking for MATCH for those cases where
   MATCH might be produced by some macro.  */
d1802 1
a1802 1
  int real_bottom = input_text_length;
d1805 1
a1805 1
    limit = input_text_length;
d1807 3
a1809 3
  /* Replace input_text[input_text_offset .. limit-1] with its expansion.
     This allows the node names and menu entries themselves to be
     constructed via a macro, as in:
d1815 1
a1815 1

d1819 9
a1827 2
     whole line then.  */
  if (expand)
d1829 28
a1856 1
      replace_with_expansion (input_text_offset, &limit);
d1859 1
a1859 2
  real_bottom = input_text_length;
  input_text_length = limit;
d1861 1
a1861 1
  input_text_length = real_bottom;
d1865 1
a1865 2
get_rest_of_line (expand, string)
     int expand;
d1868 1
a1868 15
  if (expand)
    {
      char *tem;

      /* Don't expand non-macros in input, since we want them
	 intact in the macro-expanded output.  */
      only_macro_expansion++;
      get_until_in_line (1, "\n", &tem);
      only_macro_expansion--;
      *string = expansion (tem, 0);
      free (tem);
    }
  else
    get_until_in_line (0, "\n", string);

d1901 1
a1901 1
  for (i = input_text_offset; i < input_text_length; i++)
d1916 2
a1917 2
  temp = xmalloc (2 + match_len);
  memcpy (temp, input_text + input_text_offset, match_len);
d1923 5
a1927 1
/* Converting a file.  */
a1931 4
  /* ".txi" is checked first so that on 8+3 DOS filesystems, if they
     have "texinfo.txi" and "texinfo.tex" in the same directory, the
     former is used rather than the latter, due to file name truncation.  */
  ".txi",
d1936 1
a1936 1
  NULL
a1953 24
typedef struct generic_list {
  struct generic_list *next;
} GENERIC_LIST;

/* Reverse the chain of structures in LIST.  Output the new head
   of the chain.  You should always assign the output value of this
   function to something, or you will lose the chain. */
GENERIC_LIST *
reverse_list (list)
     GENERIC_LIST *list;
{
  GENERIC_LIST *next;
  GENERIC_LIST *prev = NULL;

  while (list)
    {
      next = list->next;
      list->next = prev;
      prev = list;
      list = next;
    }
  return prev;
}

d1965 1
a1965 1
  char *buffer = NULL;
d1986 1
a1986 1
          xexit (1);
d1996 1
a1996 1
  input_text_length = buffer_offset;
d2004 2
a2005 2
     The INPUT_TEXT_LENGTH is one past the actual end of the text. */
  input_text[input_text_length] = '\n';
d2014 2
a2015 2
  int i;
  char *filename = xmalloc (strlen (name) + 50);
d2049 1
a2049 1

d2054 2
a2055 1
  char *real_output_filename = NULL;
d2057 1
d2059 1
a2059 7

  input_text_offset = 0;

  /* Avoid the `\input texinfo' line in HTML output (assuming it starts
     the file).  */
  if (looking_at ("\\input"))
    discard_until ("\n");
d2063 1
d2069 3
a2071 3
      if (input_text_offset == 0
          || (input_text_offset > 0
              && input_text[input_text_offset -1] == '\n'))
d2085 20
a2107 21
 
      {
        int i, end_of_first_line;

        /* Find the end of the first line in the file. */
        for (i = 0; i < input_text_length - 1; i++)
          if (input_text[i] == '\n')
            break;

        end_of_first_line = i + 1;

        for (i = 0; i < end_of_first_line; i++)
          {
            if ((input_text[i] == '\\') &&
                (strncmp (input_text + i + 1, "input", 5) == 0))
              {
                input_text_offset = i;
                break;
              }
          }
      }
d2113 1
a2113 27
    {
      get_until ("\n", &output_filename); /* read rest of line */
      if (html)
        { /* Change any extension to .html.  */
          char *html_name, *directory_part, *basename_part, *temp;

          canon_white (output_filename);
          directory_part = pathname_part (output_filename);
          basename_part = filename_part (output_filename);

          /* Zap any existing extension.  */
          temp = strrchr (basename_part, '.');
          if (temp)
            *temp = 0;

          /* Construct new filename.  */
          html_name = xmalloc (strlen (directory_part)
                               + strlen (basename_part) + 6);
          strcpy (html_name, directory_part);
          strcat (html_name, basename_part);
          strcat (html_name, ".html");

          /* Replace name from @@setfilename with the html name.  */
          free (output_filename);
          output_filename = html_name;
        }
    }
d2122 1
a2122 1
      command_output_filename = NULL;
d2150 1
a2150 3
  set_current_output_filename (real_output_filename);

  if (verbose_mode)
d2152 1
a2152 2
            no_headers ? "text" : (html ? "HTML" : "info"),
            output_filename, input_filename);
d2179 6
a2184 4
  /* html fixxme: should output this as trailer on first page.  */
  if (!no_headers && !html)
    add_word_args (_("This is %s, produced by makeinfo version %s from %s.\n"),
                   output_filename, VERSION, input_filename);
d2194 1
d2200 1
a2200 2
          && FILENAME_CMP (macro_expansion_filename, NULL_DEVICE) != 0
          && FILENAME_CMP (macro_expansion_filename, ALSO_NULL_DEVICE) != 0)
d2208 1
d2213 2
a2214 1
      if (tag_table)
d2217 1
a2217 1
          if (!no_headers && !html)
a2220 7
      if (html)
        {
          start_paragraph ();
          add_word ("</body></html>\n");
          close_paragraph ();
        }

d2228 1
a2228 5
      /* If we need to output the table of contents, do it now.  */
      if (contents_filename || shortcontents_filename)
	toc_update ();

      if (splitting && !html && (!errors_printed || force))
d2230 1
a2230 2
      else if (errors_printed
               && !force
d2232 1
a2232 2
               && FILENAME_CMP (real_output_filename, NULL_DEVICE) != 0
               && FILENAME_CMP (real_output_filename, ALSO_NULL_DEVICE) != 0)
d2250 1
a2250 1
      *pointer = NULL;
a2261 2
  free_node_node_references ();
  toc_free ();
a2269 1
  node_number = -1;
d2276 1
a2276 1
  output_paragraph = xmalloc (paragraph_buffer_len);
a2281 1
  meta_char_pos = 0;
a2282 3

/* This is called from `reader_loop' when we are at the * beginning a
   menu line.  */
d2284 7
a2290 2
static void
handle_menu_entry ()
d2292 8
a2299 15
  char *tem;
  
  /* Ugh, glean_node_from_menu wants to read the * itself.  */
  input_text_offset--;
  
  /* Find node name in menu entry and save it in references list for
     later validation.  Use followed_reference type for detailmenu
     references since we don't want to use them for default node pointers.  */
  tem = glean_node_from_menu (1, in_detailmenu
                                 ? followed_reference : menu_reference);

  if (html && tem)
    { /* Start a menu item with the cleaned-up line.  Put an anchor
         around the start text (before `:' or the node name). */
      char *string;
d2301 1
a2301 1
      discard_until ("* ");
d2303 7
a2309 3
      /* The line number was already incremented in reader_loop when we
         saw the newline, and discard_until has now incremented again.  */
      line_number--;
d2311 10
a2320 1
      if (had_menu_commentary)
d2322 1
a2322 3
          add_word ("<ul>\n");
          had_menu_commentary = 0;
          in_paragraph = 0;
d2324 4
a2327 1
      else if (!in_paragraph && !paragraph_is_open)
d2329 13
a2341 2
          add_word ("<p>\n");
          in_paragraph = 1;
d2343 2
a2344 2
      
      if (in_paragraph)
d2346 14
a2359 2
          add_word ("</p>");
          in_paragraph = 0;
d2362 14
a2375 5
      add_word ("<li><a href=\"");
      string = expansion (tem, 0);
      add_anchor_name (string, 1);
      add_word ("\">");
      free (string);
d2377 5
a2381 6
      /* The menu item may use macros, so expand them now.  */
      only_macro_expansion++;
      get_until_in_line (1, ":", &string);
      only_macro_expansion--;
      execute_string ("%s", string); /* get escaping done */
      free (string);
d2383 4
a2386 1
      add_word ("</a>");
d2388 3
a2390 6
      if (looking_at ("::"))
        discard_until (":");
      else
        { /* discard the node name */
          get_until_in_line (0, ".", &string);
          free (string);
a2391 9
      input_text_offset++;	/* discard the second colon or the period */
      add_word (": ");
    }
  else if (tem)
    { /* For Info output, we can just use the input and the main case in
         reader_loop where we output what comes in.  Just move off the *
         so the next time through reader_loop we don't end up back here.  */
      add_char ('*');
      input_text_offset += 2; /* undo the pointer back-up above.  */
d2393 5
d2399 4
a2402 7
  if (tem)
    free (tem);
}

/* Find the command corresponding to STRING.  If the command is found,
   return a pointer to the data structure.  Otherwise return -1.  */
static COMMAND *
d2406 1
a2406 1
  int i;
d2410 1
a2410 1
      return &command_table[i];
d2417 1
a2417 1
      return user_command_array[i];
d2420 1
a2420 1
  return (COMMAND *) -1;
d2422 1
a2422 1

d2424 2
a2425 3
   Read the next token to determine what to do.  Return zero
   if there's no known command or macro after the prefix character.  */
static int
a2428 1
  int old_text_offset = input_text_offset++;
d2430 1
d2434 1
d2453 1
a2453 1
        return 1;
d2456 1
a2456 18

  if (only_macro_expansion)
    {
      /* Back up to the place where we were called, so the
         caller will have a chance to process this non-macro.  */
      input_text_offset = old_text_offset;
      return 0;
    }

  /* Perform alias expansion */
  command = alias_expand (command);

  if (enclosure_command (command))
    {
      remember_brace (enclosure_expand);
      enclosure_expand (START, output_paragraph_offset, 0);
      return 0;
    }
d2462 1
a2462 1
      return 0;
d2465 1
a2465 1
  if (entry->argument_in_braces == BRACE_ARGS)
a2466 33
  else if (entry->argument_in_braces == MAYBE_BRACE_ARGS)
    {
      if (curchar () == '{')
        remember_brace (entry->proc);
      else
        { /* No braces, so arg is next char.  */
          int ch;
          int saved_offset = output_paragraph_offset;
          (*(entry->proc)) (START, output_paragraph_offset, 0);

          /* Possibilities left for the next character: @@ (error), }
             (error), whitespace (skip) anything else (normal char).  */
          skip_whitespace ();
          ch = curchar ();
          if (ch == '@@')
            {
           line_error (_("Use braces to give a command as an argument to @@%s"),
               entry->name);
              return 0;
            }
          else if (ch == '}')
            {
              /* Our caller will give the error message, because this }
                 won't match anything.  */
              return 0;
            }

          add_char (ch);
          input_text_offset++;
          (*(entry->proc)) (END, saved_offset, output_paragraph_offset);
          return 1;
        }
    }
a2467 2
  /* Get here if we have BRACE_ARGS, NO_BRACE_ARGS, or MAYBE_BRACE_ARGS
     with braces.  */
a2468 1
  return 1;
d2471 4
a2474 8
/* Okay, we are ready to start the conversion.  Call the reader on
   some text, and fill the text as it is output.  Handle commands by
   remembering things like open braces and the current file position on a
   stack, and when the corresponding close brace is found, you can call
   the function with the proper arguments.  Although the filling isn't
   necessary for HTML, it should do no harm.  */
void
reader_loop ()
d2476 1
a2476 3
  int character;
  int done = 0;
  int dash_count = 0;
d2478 5
a2482 79
  while (!done)
    {
      if (input_text_offset >= input_text_length)
        break;

      character = curchar ();

      /* If only_macro_expansion, only handle macros and leave
         everything else intact.  */
      if (!only_macro_expansion && !in_fixed_width_font
          && (character == '\'' || character == '`')
          && input_text[input_text_offset + 1] == character)
        {
          input_text_offset++;
          character = '"'; /* html fixxme */
        }

      /* Convert --- to --.  */
      if (!only_macro_expansion && character == '-')
        {
          dash_count++;
          if (dash_count == 2 && !in_fixed_width_font)
            {
              input_text_offset++;
              continue;
            }
        }
      else if (dash_count > 0)
        dash_count = 0;

      /* If this is a whitespace character, then check to see if the line
         is blank.  If so, advance to the carriage return. */
      if (!only_macro_expansion && whitespace (character))
        {
          int i = input_text_offset + 1;

          while (i < input_text_length && whitespace (input_text[i]))
            i++;

          if (i == input_text_length || input_text[i] == '\n')
            {
              if (i == input_text_length)
                i--;

              input_text_offset = i;
              character = curchar ();
            }
        }

      if (character == '\n')
        line_number++;

      switch (character)
        {
        case '*': /* perhaps we are at a menu */
          /* We used to check for this in the \n case but an @@c in a
             menu swallows its newline, so check here instead.  */
          if (!only_macro_expansion && in_menu
              && input_text_offset + 1 < input_text_length
              && input_text[input_text_offset-1] == '\n')
            handle_menu_entry ();
          else
            { /* Duplicate code from below, but not worth twisting the
                 fallthroughs to get down there.  */
              add_char (character);
              input_text_offset++;
            }
          break;
        
        /* Escapes for HTML unless we're outputting raw HTML.  Do
           this always, even if SGML rules don't require it since
           that's easier and safer for non-conforming browsers. */
        case '&':
          if (html && escape_html)
            add_word ("&amp;");
          else
            add_char (character);
          input_text_offset++;
          break;
a2483 53
        case '<':
          if (html && escape_html)
            add_word ("&lt;");
          else
            add_char (character);
          input_text_offset++;
          break;

        case '>':
          if (html && escape_html)
            add_word ("&gt;");
          else
            add_char (character);
          input_text_offset++;
          break;

        case COMMAND_PREFIX: /* @@ */
          if (read_command () || !only_macro_expansion)
            break;

        /* FALLTHROUGH (usually) */
        case '{':
          /* Special case.  We're not supposed to see this character by itself.
             If we do, it means there is a syntax error in the input text.
             Report the error here, but remember this brace on the stack so
             we can ignore its partner. */
          if (!only_macro_expansion)
            {
              line_error (_("Misplaced %c"), '{');
              remember_brace (misplaced_brace);
              /* remember_brace advances input_text_offset.  */
              break;
            }

        /* FALLTHROUGH (usually) */
        case '}':
          if (!only_macro_expansion)
            {
              pop_and_call_brace ();
              input_text_offset++;
              break;
            }

        /* FALLTHROUGH (usually) */
        default:
          add_char (character);
          input_text_offset++;
        }
    }
  if (macro_expansion_output_stream && !only_macro_expansion)
    maybe_write_itext (input_text, input_text_offset);
}

d2487 1
a2487 1
  brace_stack = NULL;
d2508 1
a2508 1
  BRACE_ELEMENT *new = xmalloc (sizeof (BRACE_ELEMENT));
a2510 1
  new->command = xstrdup (command);
d2522 5
a2526 1
  if (brace_stack == NULL)
d2532 6
a2537 14
  {
    BRACE_ELEMENT *temp;

    int pos = brace_stack->pos;
    COMMAND_FUNCTION *proc = brace_stack->proc;
    in_fixed_width_font = brace_stack->in_fixed_width_font;

    /* Reset current command, so the proc can know who it is.  This is
       used in cm_accent.  */
    command = brace_stack->command;

    temp = brace_stack->next;
    free (brace_stack);
    brace_stack = temp;
d2539 1
a2539 2
    (*proc) (END, pos, output_paragraph_offset);
  }
d2547 1
a2547 1
  BRACE_ELEMENT *stack = brace_stack;
a2556 15
/* Return the string which invokes PROC; a pointer to a function.
   Always returns the first function in the command table if more than
   one matches PROC.  */
static char *
find_proc_name (proc)
     COMMAND_FUNCTION *proc;
{
  int i;

  for (i = 0; command_table[i].name; i++)
    if (proc == command_table[i].proc)
      return command_table[i].name;
  return _("NO_NAME!");
}

d2621 1
a2621 1
  return len;
d2623 1
a2623 1

d2633 1
a2633 1
  char buffer[2000]; /* xx no fixed limits */
d2642 1
a2642 1
  sprintf (buffer, format, a1, a2, a3, a4, a5, a6, a7, a8);
d2657 18
d2682 2
a2683 4
     in a menu, then simply return.  But if we're only expanding macros,
     then we're being called from glean_node_from_menu to try to
     remember a menu reference, and we need that so we can do defaulting.  */
  if (no_headers && !only_macro_expansion && (in_menu || in_detailmenu))
d2699 2
a2700 10
  if (non_splitting_words && strchr (" \t\n", character))
    {
      if (html)
        { /* Seems cleaner to use &nbsp; than an 8-bit char.  */
          add_word ("&nbsp");
          character = ';';
        }
      else
        character = META (' '); /* unmeta-d in flush_output */
    }
d2707 1
a2707 1
      if (!filling_enabled && ! (html && (in_menu || in_detailmenu)))
d2724 1
a2724 2
      else if (end_of_sentence_p ())
        /* CHARACTER is newline, and filling is enabled. */
d2726 6
a2731 3
          insert (' ');
          output_column++;
          last_inserted_character = character;
a2735 2
          if (html)
            last_char_was_newline++;
d2742 1
a2742 4
          if (html)
            insert ('\n');
          else
            insert (' ');
d2747 1
a2747 1
    default: /* not at newline */
d2764 4
a2767 3
            /* If the paragraph is supposed to be indented a certain
               way, then discard all of the pending whitespace.
               Otherwise, we let the whitespace stay. */
a2770 11

            /* This horrible kludge of checking for a < prevents <p>
               from being inserted when we already have html markup
               starting a paragraph, as with <ul> and <h1> and the like.  */
            if (html && escape_html && character != '<'
                && (!in_fixed_width_font || in_menu || in_detailmenu))
              {
                insert_string ("<p>");
                in_paragraph = 1;
                adjust_braces_following (0, 3); /* adjust for <p> */
              }
d2773 1
a2773 2
        output_column += len;
        if (output_column > fill_column)
d2775 1
a2775 1
            if (filling_enabled && !html)
d2788 1
a2788 9
                        /* If we went back all the way to the newline of the
                           preceding line, it probably means that the word we
                           are adding is itself wider than the space that the
                           indentation and the fill_column let us use.  In
                           that case, do NOT insert another newline, since it
                           won't help.  Just indent to current_indent and
                           leave it alone, since that's the most we can do.  */
                        if (temp && output_paragraph[temp - 1] != '\n')
                          output_paragraph[temp++] = '\n';
d2820 1
a2820 1
                        if (indented_fill && current_indent > 0)
d2824 1
a2824 1
                            char *temp_buffer = xmalloc (buffer_len);
d2835 1
a2835 1
                            memcpy ((char *) &temp_buffer[current_indent],
d2847 1
a2847 1
                            memcpy ((char *) &output_paragraph[temp],
a2873 9
/* Add a character and store its position in meta_char_pos.  */
void
add_meta_char (character)
     int character;
{
  meta_char_pos = output_paragraph_offset;
  add_char (character);
}

a2878 7
  /* This is sad, but it seems desirable to not force any particular
     order on the front matter commands.  This way, the document can do
     @@settitle, @@documentlanguage, etc, in any order and with any
     omissions, and we'll still output the html <head> `just in time'.  */
  if (!executing_string && html && !html_output_head_p)
    html_output_head ();
    
d2898 1
a2898 1
#define POST_SENTENCE(c) ((c) == ')' || (c) == '\'' || (c) == '"' \
d2907 1
a2907 11

  /* If nothing has been output, don't check output_paragraph[-1].  */
  if (loc < 0)
    return 0;

  /* A post-sentence character that is at meta_char_pos is not really
     a post-sentence character; it was produced by a markup such as
     @@samp.  We don't want the period inside @@samp to be treated as a
     sentence ender. */
  while (loc > 0
         && loc != meta_char_pos && POST_SENTENCE (output_paragraph[loc]))
d2909 1
a2909 1
  return loc != meta_char_pos && sentence_ender (output_paragraph[loc]);
d2962 1
a2962 1
  int i;
d2969 3
a2971 6
      /* If we turned on the 8th bit for a space inside @@w, turn it
         back off for output.  This might be problematic, since the
         0x80 character may be used in 8-bit character sets.  Sigh.
         In any case, don't do this for HTML, since the nbsp character
         is valid input and must be passed along to the browser.  */
      if (!html && (output_paragraph[i] & meta_character_bit))
a2982 1
  meta_char_pos = 0;
d2993 3
a2995 13
static void
close_paragraph_with_lines (lines)
     int lines;
{
  int old_spacing = paragraph_spacing;
  paragraph_spacing = lines;
  close_paragraph ();
  paragraph_spacing = old_spacing;
}

/* Close the current paragraph, leaving no blank lines between them. */
void
close_single_paragraph ()
d3036 10
d3050 1
a3050 1
  int i;
d3057 1
a3057 1
      int tindex, c;
d3086 1
a3086 7
            {
              insert ('\n');
              /* Don't need anything extra for HTML in usual case of no
                 extra paragraph spacing.  */
              if (html && i > 0)
                insert_string ("<br>");
            }
a3098 1

d3125 1
a3125 1
          int i;
d3133 1
a3133 1
          temp = xmalloc (temp_len + 1);
a3141 1
          adjust_braces_following (0, i);
d3198 1
a3198 2
  if (html)
    return;
d3202 6
a3207 1
  adjust_braces_following (output_paragraph_offset, amount);
d3222 1
a3222 1
  while (from < input_text_length)
d3225 1
a3225 1
        return from;
d3228 1
a3228 1
  return -1;
a3229 2

/* Cross references.  */
d3231 7
a3237 7
/* Return next comma-delimited argument, but do not cross a close-brace
   boundary.  Clean up whitespace, too.  If EXPAND is nonzero, replace
   the entire brace-delimited argument list with its expansion before
   looking for the next comma.  */
char *
get_xref_token (expand)
     int expand;
d3239 1
a3239 1
  char *string;
d3241 1
a3241 1
  if (expand)
d3243 5
a3247 2
      int old_offset = input_text_offset;
      int old_lineno = line_number;
d3249 2
a3250 6
      get_until_in_braces ("}", &string);
      if (curchar () == '}')    /* as opposed to end of text */
        input_text_offset++;
      if (input_text_offset > old_offset)
        {
          int limit = input_text_offset;
d3252 2
a3253 7
          input_text_offset = old_offset;
          line_number = old_lineno;
          only_macro_expansion++;
          replace_with_expansion (input_text_offset, &limit);
          only_macro_expansion--;
        }
      free (string);
d3255 2
d3258 4
a3261 5
  get_until_in_braces (",", &string);
  if (curchar () == ',')
    input_text_offset++;
  fix_whitespace (string);
  return string;
d3264 9
a3272 7
/* NOTE: If you wonder why the HTML output is produced with such a
   peculiar mix of calls to add_word and execute_string, here's the
   reason.  get_xref_token (1) expands all macros in a reference, but
   any other commands, like @@value, @@@@, etc., are left intact.  To
   expand them, we need to run the arguments through execute_string.
   However, characters like <, &, > and others cannot be let into
   execute_string, because they will be escaped.  See the mess?  */
d3274 4
a3277 3
/* Make a cross reference. */
void
cm_xref (arg)
d3279 21
a3299 8
  if (arg == START)
    {
      char *arg1 = get_xref_token (1); /* expands all macros in xref */
      char *arg2 = get_xref_token (0);
      char *arg3 = get_xref_token (0);
      char *arg4 = get_xref_token (0);
      char *arg5 = get_xref_token (0);
      char *tem;
d3301 2
a3302 4
      if (html)
        {
          if (!ref_flag)
            add_word_args ("%s", px_ref_flag ? _("see ") : _("See "));
d3304 16
a3319 2
      else
        add_word_args ("%s", px_ref_flag ? "*note " : "*Note ");
d3321 7
a3327 3
      if (*arg5 || *arg4)
        {
          char *node_name;
d3329 12
a3340 9
          if (!*arg2)
            {
              if (*arg3)
                node_name = arg3;
              else
                node_name = arg1;
            }
          else
            node_name = arg2;
d3342 6
a3347 23
          if (html)
            {
              /* html fixxme: revisit this; external node name not
                 much use to us with numbered nodes. */
              add_word ("<a href=");
              execute_string ("\"%s.html#", arg4);
              /* Do not collapse -- to -, etc., in references.  */
              in_fixed_width_font++;
              tem = expansion (node_name, 0);
              in_fixed_width_font--;
              add_escaped_anchor_name (tem);
              free (tem);
              add_word ("\">");
              execute_string ("%s", arg1);
              add_word ("</a>");
            }
          else
            {
              execute_string ("%s:", node_name);
              in_fixed_width_font++;
              execute_string (" (%s)%s%s", arg4, arg1, px_ref_flag ? "." : "");
              in_fixed_width_font--;
            }
d3349 2
a3350 10
          /* Free all of the arguments found. */
          if (arg1) free (arg1);
          if (arg2) free (arg2);
          if (arg3) free (arg3);
          if (arg4) free (arg4);
          if (arg5) free (arg5);
          return;
        }
      else
        remember_node_reference (arg1, line_number, followed_reference);
d3352 10
a3361 53
      if (*arg3)
        {
          if (html)
            {
              add_word ("<a href=\"");
              in_fixed_width_font++;
              tem = expansion (arg1, 0);
              in_fixed_width_font--;
              add_anchor_name (tem, 1);
              free (tem);
              add_word ("\">");
              execute_string ("%s", *arg2 ? arg2 : arg3);
              add_word ("</a>");
            }
          else
            {
              execute_string ("%s:", *arg2 ? arg2 : arg3);
              in_fixed_width_font++;
              execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
              in_fixed_width_font--;
            }
        }
      else
        {
          if (html)
            {
              add_word ("<a href=\"");
              in_fixed_width_font++;
              tem = expansion (arg1, 0);
              in_fixed_width_font--;
              add_anchor_name (tem, 1);
              free (tem);
              add_word ("\">");
              execute_string ("%s", *arg2 ? arg2 : arg1);
              add_word ("</a>");
            }
          else
            {
              if (*arg2)
                {
                  execute_string ("%s:", arg2);
                  in_fixed_width_font++;
                  execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
                  in_fixed_width_font--;
                }
              else
                {
                  in_fixed_width_font++;
                  execute_string ("%s::", arg1);
                  in_fixed_width_font--;
                }
            }
        }
d3363 8
a3370 7
      /* Free all of the arguments found. */
      if (arg1) free (arg1);
      if (arg2) free (arg2);
      if (arg3) free (arg3);
      if (arg4) free (arg4);
      if (arg5) free (arg5);
    }
d3372 2
a3373 5
    { /* Check to make sure that the next non-whitespace character is
         valid to follow an xref (so info readers can find the node
         names).  `input_text_offset' is pointing at the "}" which ended
         the xref or ref command. */
      int temp;
d3375 12
a3386 12
      for (temp = input_text_offset + 1; temp < input_text_length; )
        {
          if (cr_or_whitespace (input_text[temp]))
            temp++;
          else
            {
              if (input_text[temp] != '.' && input_text[temp] != ',')
                warning (_("`.' or `,' must follow cross reference, not %c"),
                         input_text[temp]);
              break;
            }
        }
d3388 1
d3391 41
d3433 2
a3434 2
cm_pxref (arg)
     int arg;
d3436 1
a3436 1
  if (arg == START)
d3438 2
a3439 3
      px_ref_flag++;
      cm_xref (arg);
      px_ref_flag--;
d3441 5
a3445 4
  /* Note that cm_xref isn't called with arg == END, which disables
     the code near the end of cm_xref that checks for `.' or `,'
     after the cross-reference.  This is because @@pxref{} generates
     the required character itself, when needed.  */
d3449 1
a3449 2
cm_ref (arg)
     int arg;
d3451 6
a3456 6
  if (arg == START)
    {
      ref_flag++;
      cm_xref (arg);
      ref_flag--;
    }
d3459 1
d3461 1
a3461 2
cm_inforef (arg)
     int arg;
d3463 3
a3465 1
  if (arg == START)
d3467 1
a3467 5
      char *node = get_xref_token (1); /* expands all macros in inforef */
      char *pname = get_xref_token (0);
      char *file = get_xref_token (0);

      if (html)
d3469 2
a3470 14
          add_word (_("see "));
          /* html fixxme: revisit this */
          add_word ("<a href=");
          execute_string ("\"%s.html\"", file);
          add_word (">");
          execute_string ("%s", pname);
          add_word ("</a>");
        }
      else
        {
          if (*pname)
            execute_string ("*note %s: (%s)%s", pname, file, node);
          else
            execute_string ("*note (%s)%s::", file, node);
d3472 4
d3477 3
a3479 4
      free (node);
      free (pname);
      free (file);
    }
d3482 3
a3484 1
/* A URL reference.  */
d3486 2
a3487 2
cm_uref (arg)
     int arg;
d3489 3
a3491 1
  if (arg == START)
d3493 2
a3494 41
      extern int printing_index;
      char *url  = get_xref_token (1); /* expands all macros in uref */
      char *desc = get_xref_token (0);
      char *replacement = get_xref_token (0);

      if (html)
        { /* never need to show the url */
          add_word ("<a href=");
          /* don't collapse `--' etc. in the url */
          in_fixed_width_font++;
          execute_string ("\"%s\"", url);
          in_fixed_width_font--;
          add_word (">");
          execute_string ("%s", *replacement ? replacement
                                : (*desc ? desc : url));
          add_word ("</a>");
        }
      else if (*replacement) /* do not show the url */
        execute_string ("%s", replacement);
      else if (*desc)        /* show both text and url */
        {
          execute_string ("%s ", desc);
          in_fixed_width_font++;
          execute_string ("(%s)", url);
          in_fixed_width_font--;
        }
      else /* no text at all, so have the url to show */
        {
          in_fixed_width_font++;
          execute_string ("%s%s%s",
                          printing_index ? "" : "`",
                          url,
                          printing_index ? "" : "'");
          in_fixed_width_font--;
        }
      if (url)
        free (url);
      if (desc)
        free (desc);
      if (replacement)
        free (replacement);
d3496 2
a3497 1
}
d3499 1
a3499 6
/* An email reference.  */
void
cm_email (arg)
     int arg;
{
  if (arg == START)
d3501 3
a3503 2
      char *addr = get_xref_token (1); /* expands all macros in email */
      char *name = get_xref_token (0);
d3505 77
a3581 1
      if (html)
d3583 6
a3588 8
          add_word ("<a href=");
          /* don't collapse `--' etc. in the address */
          in_fixed_width_font++;
          execute_string ("\"mailto:%s\"", addr);
          in_fixed_width_font--;
          add_word (">");
          execute_string ("%s", *name ? name : addr);
          add_word ("</a>");
d3590 2
a3591 1
      else
d3593 2
a3594 4
          execute_string ("%s%s", name, *name ? " "  : "");
          in_fixed_width_font++;
          execute_string ("<%s>", addr);
          in_fixed_width_font--;
d3596 67
d3664 6
a3669 4
      if (addr)
        free (addr);
      if (name)
        free (name);
d3671 3
d3676 4
a3679 2
/* An external image is a reference, kind of.  The parsing is (not
   coincidentally) similar, anyway.  */
d3681 2
a3682 2
cm_image (arg)
     int arg;
d3684 1
a3684 1
  char *name_arg, *rest;
d3686 1
a3686 1
  if (arg == END)
d3689 4
a3692 26
  name_arg = get_xref_token (1); /* expands all macros in image */
  /* We don't (yet) care about any other args, but read them so they
     don't end up in the text.  */
  rest = get_xref_token (0);
  if (rest)
    free (rest);
  rest = get_xref_token (0);
  if (rest)
    free (rest);

  if (*name_arg)
    {
      char *fullname = xmalloc (strlen (name_arg) + 4 + 1);

      if (html)
        { /* fixxme It would be nice to insert more useful alt text.  */
          sprintf (fullname, "%s.png", name_arg);
          if (access (fullname, R_OK) != 0)
            {
              sprintf (fullname, "%s.jpg", name_arg);
              if (access (fullname, R_OK) != 0)
                {
                  line_error (_("No .png or .jpg for `%s'"), name_arg);
                  return;
                }
          }
d3694 7
a3700 13
          add_word_args ("<img src=\"%s\" alt=\"%s\">", fullname, fullname);
        }
      else
        { /* Try to open foo.txt.  */
          FILE *image_file;
          strcpy (fullname, name_arg);
          strcat (fullname, ".txt");
          image_file = fopen (fullname, "r");
          if (image_file)
            {
              int ch;
              int save_inhibit_indentation = inhibit_paragraph_indentation;
              int save_filling_enabled = filling_enabled;
d3702 1
a3702 3
              inhibit_paragraph_indentation = 1;
              filling_enabled = 0;
              last_char_was_newline = 0;
d3704 9
a3712 6
              /* Maybe we need to remove the final newline if the image
                 file is only one line to allow in-line images.  On the
                 other hand, they could just make the file without a
                 final newline.  */
              while ((ch = getc (image_file)) != EOF)
                add_char (ch);
d3714 4
a3717 2
              inhibit_paragraph_indentation = save_inhibit_indentation;
              filling_enabled = save_filling_enabled;
d3719 6
a3724 6
              if (fclose (image_file) != 0)
                perror (fullname);
            }
          else
            warning (_("@@image file `%s' unreadable: %s"), fullname,
                       strerror (errno));
d3726 1
d3728 9
a3736 4
      free (fullname);
    }
  else
    line_error (_("@@image missing filename argument"));
d3738 5
a3742 5
  if (name_arg)
    free (name_arg);
}

/* Conditionals.  */
d3744 5
a3748 6
/* A structure which contains `defined' variables. */
typedef struct defines {
  struct defines *next;
  char *name;
  char *value;
} DEFINE;
d3750 16
a3765 2
/* The linked list of `set' defines. */
DEFINE *defines = NULL;
d3767 6
a3772 7
/* Add NAME to the list of `set' defines. */
void
set (name, value)
     char *name;
     char *value;
{
  DEFINE *temp;
d3774 4
a3777 7
  for (temp = defines; temp; temp = temp->next)
    if (strcmp (name, temp->name) == 0)
      {
        free (temp->value);
        temp->value = xstrdup (value);
        return;
      }
d3779 6
a3784 5
  temp = xmalloc (sizeof (DEFINE));
  temp->next = defines;
  temp->name = xstrdup (name);
  temp->value = xstrdup (value);
  defines = temp;
d3787 17
a3803 13
/* Remove NAME from the list of `set' defines. */
void
clear (name)
     char *name;
{
  DEFINE *temp, *last;

  last = NULL;
  temp = defines;

  while (temp)
    {
      if (strcmp (temp->name, name) == 0)
d3805 8
a3812 9
          if (last)
            last->next = temp->next;
          else
            defines = temp->next;

          free (temp->name);
          free (temp->value);
          free (temp);
          break;
a3813 2
      last = temp;
      temp = temp->next;
d3815 12
d3829 3
a3831 4
/* Return the value of NAME.  The return value is NULL if NAME is unset. */
char *
set_p (name)
     char *name;
d3833 3
a3835 1
  DEFINE *temp;
d3837 7
a3843 3
  for (temp = defines; temp; temp = temp->next)
    if (strcmp (temp->name, name) == 0)
      return temp->value;
d3845 7
a3851 1
  return NULL;
d3854 1
a3854 1
/* Create a variable whose name appears as the first word on this line. */
d3856 2
a3857 1
cm_set ()
d3859 2
a3860 1
  handle_variable (SET);
a3862 1
/* Remove a variable whose name appears as the first word on this line. */
d3864 2
a3865 1
cm_clear ()
d3867 2
a3868 1
  handle_variable (CLEAR);
d3872 2
a3873 1
cm_ifset ()
d3875 2
a3876 1
  handle_variable (IFSET);
d3879 1
d3881 2
a3882 1
cm_ifclear ()
d3884 2
a3885 1
  handle_variable (IFCLEAR);
d3888 8
a3895 2
/* This command takes braces, but we parse the contents specially, so we
   don't use the standard brace popping code.
d3897 1
a3897 3
   The syntax @@ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands
   if ARG1 and ARG2 caselessly string compare to the same string, otherwise,
   it produces no output. */
d3899 2
a3900 1
cm_ifeq ()
d3902 25
a3926 1
  char **arglist;
d3928 24
a3951 1
  arglist = get_brace_args (0);
d3953 6
a3958 1
  if (arglist)
d3960 13
a3972 6
      if (array_len (arglist) > 1)
        {
          if ((strcasecmp (arglist[0], arglist[1]) == 0) &&
              (arglist[2]))
            execute_string ("%s\n", arglist[2]);
        }
d3974 14
a3987 1
      free_array (arglist);
d3992 2
a3993 2
cm_value (arg, start_pos, end_pos)
     int arg, start_pos, end_pos;
d3995 1
a3995 1
  static int value_level = 0, saved_meta_pos = -1;
a3996 6
  /* All the text after @@value{ upto the matching } will eventually
     disappear from output_paragraph, when this function is called
     with ARG == END.  If the text produced until then sets
     meta_char_pos, we will need to restore it to the value it had
     before @@value was seen.  So we need to save the previous value
     of meta_char_pos here.  */
a3998 8
      /* If we are already inside some outer @@value, don't overwrite
         the value saved in saved_meta_pos.  */
      if (!value_level)
        saved_meta_pos = meta_char_pos;
      value_level++;
      /* While the argument of @@value is processed, we need to inhibit
	 textual transformations like "--" into "-", since @@set didn't
	 do that when it grabbed the name of the variable.  */
d4000 3
d4006 14
a4019 7
      char *name = (char *) &output_paragraph[start_pos];
      char *value;
      output_paragraph[end_pos] = 0;
      name = xstrdup (name);
      value = set_p (name);
      output_column -= end_pos - start_pos;
      output_paragraph_offset = start_pos;
d4021 6
a4026 15
      /* Restore the previous value of meta_char_pos if the stuff
         inside this @@value{} moved it.  */
      if (saved_meta_pos == -1) /* can't happen inside @@value{} */
        abort ();
      if (value_level == 1
          && meta_char_pos >= start_pos && meta_char_pos < end_pos)
        {
          meta_char_pos = saved_meta_pos;
          saved_meta_pos = -1;
        }
      value_level--;
      /* No need to decrement in_fixed_width_font, since before
	 we are called with arg == END, the reader loop already
	 popped the brace stack, which restored in_fixed_width_font,
	 among other things.  */
d4028 13
a4040 2
      if (value)
        execute_string ("%s", value);
d4042 4
a4045 1
        add_word_args (_("{No value for `%s'}"), name);
d4047 3
a4049 1
      free (name);
d4053 1
a4053 1
/* Set, clear, or conditionalize based on ACTION. */
d4055 2
a4056 2
handle_variable (action)
     int action;
d4058 2
a4059 10
  char *name;

  get_rest_of_line (0, &name);
  /* If we hit the end of text in get_rest_of_line, backing up
     input pointer will cause the last character of the last line
     be pushed back onto the input, which is wrong.  */
  if (input_text_offset < input_text_length)
    backup_input_pointer ();
  handle_variable_internal (action, name);
  free (name);
d4062 1
d4064 2
a4065 3
handle_variable_internal (action, name)
     int action;
     char *name;
d4067 1
a4067 2
  char *temp;
  int delimiter, additional_text_present = 0;
d4069 1
a4069 4
  /* Only the first word of NAME is a valid tag. */
  temp = name;
  delimiter = 0;
  while (*temp && (delimiter || !whitespace (*temp)))
d4071 1
a4071 2
/* #if defined (SET_WITH_EQUAL) */
      if (*temp == '"' || *temp == '\'')
d4073 3
a4075 4
          if (*temp == delimiter)
            delimiter = 0;
          else
            delimiter = *temp;
a4076 2
/* #endif SET_WITH_EQUAL */
      temp++;
d4078 8
d4087 6
a4092 2
  if (*temp)
    additional_text_present++;
d4094 6
a4099 1
  *temp = 0;
d4101 6
a4106 2
  if (!*name)
    line_error (_("%c%s requires a name"), COMMAND_PREFIX, command);
d4108 4810
d8919 1
a8919 1
      switch (action)
d8921 49
a8969 3
        case SET:
          {
            char *value;
d8971 1
a8971 3
#if defined (SET_WITH_EQUAL)
            /* Allow a value to be saved along with a variable.  The value is
               the text following an `=' sign in NAME, if any is present. */
d8973 12
a8984 1
            for (value = name; *value && *value != '='; value++);
d8986 2
a8987 2
            if (*value)
              *value++ = 0;
d8989 3
a8991 5
            if (*value == '"' || *value == '\'')
              {
                value++;
                value[strlen (value) - 1] = 0;
              }
d8993 29
a9021 11
#else /* !SET_WITH_EQUAL */
            /* The VALUE of NAME is the remainder of the line sans
               whitespace. */
            if (additional_text_present)
              {
                value = temp + 1;
                canon_white (value);
              }
            else
              value = "";
#endif /* !SET_WITH_VALUE */
d9023 9
a9031 3
            set (name, value);
          }
          break;
d9033 6
a9038 3
        case CLEAR:
          clear (name);
          break;
d9040 9
a9048 10
        case IFSET:
        case IFCLEAR:
          /* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,
             read lines from the the file until we reach a matching
             "@@end CONDITION".  This means that we only take note of
             "@@ifset/clear" and "@@end" commands. */
          {
            char condition[8];
            int condition_len;
            int orig_line_number = line_number;
d9050 14
a9063 4
            if (action == IFSET)
              strcpy (condition, "ifset");
            else
              strcpy (condition, "ifclear");
d9065 1
a9065 1
            condition_len = strlen (condition);
d9067 9
a9075 2
          if ((action == IFSET && !set_p (name))
              || (action == IFCLEAR && set_p (name)))
d9077 11
a9087 1
              int level = 0, done = 0;
d9089 4
a9092 1
              while (!done && input_text_offset < input_text_length)
d9094 60
a9153 1
                  char *freeable_line, *line;
d9155 2
a9156 1
                  get_rest_of_line (0, &freeable_line);
d9158 1
a9158 1
                  for (line = freeable_line; whitespace (*line); line++);
d9160 4
a9163 7
                  if (*line == COMMAND_PREFIX &&
                      (strncmp (line + 1, condition, condition_len) == 0))
                    level++;
                  else if (strncmp (line, "@@end", 4) == 0)
                    {
                      char *cname = line + 4;
                      char *temp;
d9165 1
a9165 3
                      while (*cname && whitespace (*cname))
                        cname++;
                      temp = cname;
d9167 5
a9171 3
                      while (*temp && !whitespace (*temp))
                        temp++;
                      *temp = 0;
d9173 3
a9175 12
                      if (strcmp (cname, condition) == 0)
                        {
                          if (!level)
                            {
                              done = 1;
                            }
                          else
                            level--;
                        }
                    }
                  free (freeable_line);
                }
d9177 2
a9178 8
              if (!done)
                {
                  int save = line_number;
                  line_number = orig_line_number;
                  line_error (_("Reached eof before matching @@end %s"),
                              condition);
                  line_number = save;
                }
d9180 1
a9180 14
              /* We found the end of a false @@ifset/ifclear.  If we are
                 in a menu, back up over the newline that ends the ifset,
                 since that newline may also begin the next menu entry. */
              break;
            }
          else
            {
              if (action == IFSET)
                begin_insertion (ifset);
              else
                begin_insertion (ifclear);
            }
          }
          break;
d9182 2
d9185 6
a9191 8

/* Execution of random text not in file. */

typedef struct {
  char *string;                 /* The string buffer. */
  int size;                     /* The size of the buffer. */
  int in_use;                   /* Nonzero means string currently in use. */
} EXECUTION_STRING;
d9193 1
a9193 3
static EXECUTION_STRING **execution_strings = NULL;
static int execution_strings_index = 0;
static int execution_strings_slots = 0;
d9195 5
a9199 3
EXECUTION_STRING *
get_execution_string (initial_size)
     int initial_size;
d9201 2
a9202 2
  int i = 0;
  EXECUTION_STRING *es = NULL;
d9204 2
a9205 1
  if (execution_strings)
d9207 3
a9209 6
      for (i = 0; i < execution_strings_index; i++)
        if (execution_strings[i] && (execution_strings[i]->in_use == 0))
          {
            es = execution_strings[i];
            break;
          }
d9212 11
a9222 1
  if (!es)
d9224 8
a9231 1
      if (execution_strings_index + 1 >= execution_strings_slots)
d9233 1
a9233 6
          execution_strings = xrealloc
            (execution_strings,
             (execution_strings_slots += 3) * sizeof (EXECUTION_STRING *));
          for (; i < execution_strings_slots; i++)
            execution_strings[i] = NULL;
        }
d9235 2
a9236 4
      execution_strings[execution_strings_index] =
        xmalloc (sizeof (EXECUTION_STRING));
      es = execution_strings[execution_strings_index];
      execution_strings_index++;
d9238 3
a9240 4
      es->size = 0;
      es->string = NULL;
      es->in_use = 0;
    }
d9242 5
a9246 4
  if (initial_size > es->size)
    {
      es->string = xrealloc (es->string, initial_size);
      es->size = initial_size;
d9248 1
a9248 1
  return es;
d9251 1
a9251 3
/* Given a pointer to TEXT and its desired length NEW_LEN, find TEXT's
   entry in the execution_strings[] array and change the .STRING and
   .SIZE members of that entry as appropriate.  */
d9253 2
a9254 3
maybe_update_execution_strings (text, new_len)
     char **text;
     unsigned new_len;
d9256 1
a9256 1
  int i = 0;
d9258 7
a9264 23
  if (execution_strings)
    {
      for (i = 0; i < execution_strings_index; i++)
        if (execution_strings[i] && (execution_strings[i]->in_use == 1) &&
            execution_strings[i]->string == *text)
          {
            /* Don't ever shrink the string storage in execution_strings[]!
               execute_string assumes that it is always big enough to store
               every possible execution_string, and will break if that's
               not true.  So we only enlarge the string storage if the
               current size isn't big enough.  */
            if (execution_strings[i]->size < new_len)
              {
                execution_strings[i]->string =
                  *text = xrealloc (*text, new_len + 1);
                execution_strings[i]->size = new_len + 1;
              }
            return;
          }
    }
  /* We should *never* end up here, since if we are inside
     execute_string, TEXT is always in execution_strings[].  */
  abort ();
d9267 2
a9268 2
/* Execute the string produced by formatting the ARGs with FORMAT.  This
   is like submitting a new file with @@include. */
d9270 1
a9270 7
#if defined (VA_FPRINTF) && __STDC__
execute_string (char *format, ...)
#else
execute_string (format, va_alist)
    char *format;
    va_dcl
#endif
d9272 1
a9272 5
  EXECUTION_STRING *es;
  char *temp_string;
#ifdef VA_FPRINTF
  va_list ap;
#endif
d9274 3
a9276 11
  es = get_execution_string (4000);
  temp_string = es->string;
  es->in_use = 1;

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (temp_string, format, ap);
#else
  sprintf (temp_string, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
d9278 6
d9286 1
a9286 1
  input_text = temp_string;
d9288 1
a9288 1
  input_text_length = strlen (temp_string);
d9290 3
a9292 1
  executing_string++;
a9293 2
  free (input_filename);

d9295 1
a9295 2
  executing_string--;
  es->in_use = 0;
d9298 18
d9317 7
a9323 2
/* Return what would be output for STR (in newly-malloced memory), i.e.,
   expand Texinfo commands.  If IMPLICIT_CODE is set, expand @@code{STR}.  */
d9325 5
a9329 4
char *
expansion (str, implicit_code)
    char *str;
    int implicit_code;
d9331 2
a9332 2
  int length;
  char *result;
d9334 6
a9339 4
  /* Inhibit any real output.  */
  int start = output_paragraph_offset;
  int saved_paragraph_is_open = paragraph_is_open;
  int saved_output_column = output_column;
d9341 6
a9346 16
  /* Inhibit indentation and filling, so that extra newlines
     are not added to the expansion.  (This is undesirable if
     we write the expanded text to macro_expansion_output_stream.)  */
  int saved_filling_enabled = filling_enabled;
  int saved_indented_fill = indented_fill;
  int saved_no_indent = no_indent;
  int saved_escape_html = escape_html;
  int saved_meta_pos = meta_char_pos;
  int saved_last_char = last_inserted_character;
  int saved_last_nl = last_char_was_newline;

  /* If we are called in the middle of processing a command, we need
     to dup and save the global variable `command' (which holds the
     name of this command), since the recursive reader loop will free
     it from under our feet if it finds any macros in STR.  */
  char *saved_command = command ? xstrdup (command) : NULL;
d9348 8
a9355 4
  filling_enabled = 0;
  indented_fill = 0;
  no_indent = 1;
  escape_html = 0;
d9357 1
a9357 4
  inhibit_output_flushing ();
  paragraph_is_open = 1;
  execute_string (implicit_code ? "@@code{%s}" : "%s", str);
  uninhibit_output_flushing ();
d9359 6
a9364 5
  /* Copy the expansion from the buffer.  */
  length = output_paragraph_offset - start;
  result = xmalloc (1 + length);
  memcpy (result, (char *) (output_paragraph + start), length);
  result[length] = 0;
d9366 2
a9367 13
  /* Pretend it never happened.  */
  free_and_clear (&command);
  command = saved_command;
  output_paragraph_offset = start;
  paragraph_is_open = saved_paragraph_is_open;
  output_column = saved_output_column;
  filling_enabled = saved_filling_enabled;
  indented_fill = saved_indented_fill;
  no_indent = saved_no_indent;
  escape_html = saved_escape_html;
  meta_char_pos = saved_meta_pos;
  last_inserted_character = saved_last_char;
  last_char_was_newline = saved_last_nl;
d9369 1
a9369 1
  return result;
d9372 10
d9383 3
a9385 2
/* Return text (info) expansion of STR no matter what the current output
   format is.  */
d9387 6
a9392 3
char *
text_expansion (str)
    char *str;
d9394 76
a9469 8
  char *ret;
  int save_html = html;
  
  html = 0;
  ret = expansion (str, 0);
  html = save_html;
  
  return ret;
a9470 1

d9472 11
a9482 9
/* Set the paragraph indentation variable to the value specified in STRING.
   Values can be:
     `asis': Don't change existing indentation.
     `none': Remove existing indentation.
        NUM: Indent NUM spaces at the starts of paragraphs.
             If NUM is zero, we assume `none'.
   Returns 0 if successful, or nonzero if STRING isn't one of the above. */
int
set_paragraph_indent (string)
d9484 1
d9486 29
a9514 4
  if (strcmp (string, "asis") == 0 || strcmp (string, _("asis")) == 0)
    paragraph_start_indent = 0;
  else if (strcmp (string, "none") == 0 || strcmp (string, _("none")) == 0)
    paragraph_start_indent = -1;
d9517 39
a9555 2
      if (sscanf (string, "%d", &paragraph_start_indent) != 1)
        return -1;
d9557 8
d9566 2
a9567 2
          if (paragraph_start_indent == 0)
            paragraph_start_indent = -1;
d9569 11
d9581 1
a9581 1
  return 0;
@


1.1.1.7
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.205 2002/03/28 16:33:48 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 01, 02
d37 28
a64 1
#include "xml.h"
a95 1
static char *save_command_output_filename = NULL;
a159 3
/* Nonzero means don't replace whitespace with &nbsp; in HTML mode.  */
int in_html_elt = 0;

d265 1
a265 32
/* Just like error (), but print the input file and line number as well. */
void
#if defined (VA_FPRINTF) && __STDC__
file_line_error (char *infile, int lno, char *format, ...)
#else
file_line_error (infile, lno, format, va_alist)
   char *infile;
   int lno;
   char *format;
   va_dcl
#endif
{
#ifdef VA_FPRINTF
  va_list ap;
#endif

  remember_error ();
  fprintf (stderr, "%s:%d: ", infile, lno);

  VA_START (ap, format);
#ifdef VA_FPRINTF
  VA_FPRINTF (stderr, format, ap);
#else
  fprintf (stderr, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_FPRINTF */
  va_end (ap);

  fprintf (stderr, ".\n");
}

/* Just like file_line_error (), but take the input file and the line
   number from global variables. */
d365 26
a390 7
    printf (_("Usage: %s [OPTION]... TEXINFO-FILE...\n"), progname);
    printf ("\n");

    puts (_("\
Translate Texinfo source documentation to various other formats, by default\n\
Info files suitable for reading online with Emacs or standalone GNU Info.\n"));

d392 21
a412 49
General options:\n\
      --error-limit=NUM       quit after NUM errors (default %d).\n\
      --force                 preserve output even if errors.\n\
      --help                  display this help and exit.\n\
      --no-validate           suppress node cross-reference validation.\n\
      --no-warn               suppress warnings (but not errors).\n\
      --reference-limit=NUM   warn about at most NUM references (default %d).\n\
  -v, --verbose               explain what is being done.\n\
      --version               display version information and exit.\n"),
            max_error_level, reference_warning_limit);
     printf ("\n");

     /* xgettext: no-wrap */
     puts (_("\
Output format selection (default is to produce Info):\n\
      --docbook             output DocBook rather than Info.\n\
      --html                output HTML rather than Info.\n\
      --xml                 output XML (TexinfoML) rather than Info.\n\
"));

     puts (_("\
General output options:\n\
  -E, --macro-expand FILE   output macro-expanded source to FILE.\n\
                            ignoring any @@setfilename.\n\
      --no-headers          suppress node separators, Node: lines, and menus\n\
                              from Info output (thus producing plain text)\n\
                              or from HTML (thus producing shorter output);\n\
                              also, write to standard output by default.\n\
      --no-split            suppress splitting of Info or HTML output,\n\
                            generate only one output file.\n\
      --number-sections     output chapter and sectioning numbers.\n\
  -o, --output=FILE         output to FILE (directory if split HTML),\n\
"));

     printf (_("\
Options for Info and plain text:\n\
      --enable-encoding       output accented and special characters in\n\
                                Info output based on @@documentencoding.\n\
      --fill-column=NUM       break Info lines at NUM characters (default %d).\n\
      --footnote-style=STYLE  output footnotes in Info according to STYLE:\n\
                                `separate' to put them in their own node;\n\
                                `end' to put them at the end of the node\n\
                                  in which they are defined (default).\n\
      --paragraph-indent=VAL  indent Info paragraphs by VAL spaces (default %d).\n\
                                If VAL is `none', do not indent; if VAL is\n\
                                `asis', preserve existing indentation.\n\
      --split-size=NUM        split Info files at size NUM (default %d).\n"),
             fill_column, paragraph_start_indent,
             DEFAULT_SPLIT_SIZE);
a413 1
  printf ("\n");
d415 5
a419 29
     puts (_("\
Input file options:\n\
      --commands-in-node-names   allow @@ commands in node names.\n\
  -D VAR                         define the variable VAR, as with @@set.\n\
  -I DIR                         append DIR to the @@include search path.\n\
  -P DIR                         prepend DIR to the @@include search path.\n\
  -U VAR                         undefine the variable VAR, as with @@clear.\n\
"));

     puts (_("\
Conditional processing in input:\n\
  --ifhtml          process @@ifhtml and @@html even if not generating HTML.\n\
  --ifinfo          process @@ifinfo even if not generating Info.\n\
  --ifplaintext     process @@ifplaintext even if not generating plain text.\n\
  --iftex           process @@iftex and @@tex; implies --no-split.\n\
  --no-ifhtml       do not process @@ifhtml and @@html text.\n\
  --no-ifinfo       do not process @@ifinfo text.\n\
  --no-ifplaintext  do not process @@ifplaintext text.\n\
  --no-iftex        do not process @@iftex and @@tex text.\n\
"));

     puts (_("\
  The defaults for the @@if... conditionals depend on the output format:\n\
  if generating HTML, --ifhtml is on and the others are off;\n\
  if generating Info, --ifinfo is on and the others are off;\n\
  if generating plain text, --ifplaintext is on and the others are off;\n\
"));

  fputs (_("\
d421 5
a425 5
  makeinfo foo.texi                     write Info to foo's @@setfilename\n\
  makeinfo --html foo.texi              write HTML to @@setfilename\n\
  makeinfo --xml foo.texi               write XML to @@setfilename\n\
  makeinfo --docbook foo.texi           write DocBook XML to @@setfilename\n\
  makeinfo --no-headers foo.texi        write plain text to standard output\n\
a426 6
  makeinfo --html --no-headers foo.texi write html without node lines, menus\n\
  makeinfo --number-sections foo.texi   write Info with numbered sections\n\
  makeinfo --no-split foo.texi          write one Info file however big\n\
"), stdout);

  puts (_("\n\
d428 1
a428 3
general questions and discussion to help-texinfo@@gnu.org.\n\
Texinfo home page: http://www.gnu.org/software/texinfo/"));

a434 2
  { "docbook", 0, 0, 'd' },
  { "enable-encoding", 0, &enable_encoding, 1 },
a442 1
  { "ifplaintext", 0, &process_plaintext, 1 },
a447 1
  { "no-ifplaintext", 0, &process_plaintext, 0 },
a459 1
  { "split-size", 1, 0, 'S'},
a461 1
  { "xml", 0, 0, 'x' },
d490 1
a490 1
  while ((c = getopt_long (argc, argv, "D:de:E:f:hI:o:p:P:r:s:U:vV:wx",
a503 6
        case 'd': /* --docbook */
          splitting = 0;
	  xml = 1;
	  docbook = 1;
          break;

d510 1
a510 1
              usage (1);
a554 1
          save_command_output_filename = command_output_filename;
a608 10
	case 'S': /* --split-size */
          if (sscanf (optarg, "%d", &split_size) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"),
                     "--split-size", progname, optarg);
              usage (1);
            }
	  break;

d620 1
a620 1
                  "2002");
d627 2
a630 5
        case 'x': /* --xml */
          splitting = 0;
 	  xml = 1;
          break;
 
a668 6
    
  if (process_info == -1)
    { /* no explicit --[no-]ifinfo option, so we'll do @@ifinfo
         if we're generating info or (for compatibility) plain text.  */
      process_info = !html && !xml;
    }
a669 6
  if (process_plaintext == -1)
    { /* no explicit --[no-]ifplaintext option, so we'll do @@ifplaintext
         if we're generating plain text.  */
      process_plaintext = no_headers && !html && !xml;
    }
    
a973 1
  xml_no_para ++;
a995 1
  xml_no_para --;
d1023 1
a1023 6
      if (i < input_text_length - 1 && input_text[i] == '@@')
        {
          i++;			/* skip commands like @@, and @@{ */
          continue;
        }
      else if (input_text[i] == '{')
d1026 1
a1026 7
        {
          brace--;
          /* If looking for a brace, don't stop at the interior brace,
             like after "baz" in "@@foo{something @@bar{baz} more}".  */
          if (brace == 0)
            continue;
        }
a1193 84
/* Given OUTPUT_FILENAME == ``/foo/bar/baz.html'', return
   "/foo/bar/baz/baz.html".  This routine is called only if html && splitting.
   
  Split html output goes into the subdirectory of the toplevel
  filename, without extension.  For example:
      @@setfilename foo.info
  produces output in files foo/index.html, foo/second-node.html, ...
  
  But if the user said -o foo.whatever on the cmd line, then use
  foo.whatever unchanged.  */

static char *
insert_toplevel_subdirectory (output_filename)
     char *output_filename;
{
  char *dir, *subdir, *base, *basename, *p;
  char buf[PATH_MAX];
  struct stat st;
  static const char index_name[] = "index.html";
  const int index_len = sizeof (index_name) - 1;

  strcpy (buf, output_filename);
  dir = pathname_part (buf);
  base = filename_part (buf);
  basename = xstrdup (base); /* remember real @@setfilename name */
  p = dir + strlen (dir) - 1;
  if (p > dir && IS_SLASH (*p))
    *p = 0;
  p = strrchr (base, '.');
  if (p)
    *p = 0;

  /* Split html output goes into subdirectory of toplevel name. */
  subdir = "";
  if (FILENAME_CMP (base, filename_part (dir)) != 0)
    {
      if (save_command_output_filename
          && STREQ (output_filename, save_command_output_filename))
        subdir = basename;  /* from user, use unchanged */
      else
        subdir = base;      /* implicit, omit suffix */
    }

  free (output_filename);
  output_filename = xmalloc (strlen (dir) + 1
			     + strlen (basename) + 1
			     + index_len
			     + 1);
  strcpy (output_filename, dir);
  if (strlen (dir))
    strcat (output_filename, "/");
  strcat (output_filename, subdir);
  if (mkdir (output_filename, 0777) == -1 && errno != EEXIST
      /* output_filename might exist, but be a non-directory.  */
      || (stat (output_filename, &st) == 0 && !S_ISDIR (st.st_mode)))
    { /* that failed, try subdir name with .html */
      strcpy (output_filename, dir);
      if (strlen (dir))
        strcat (output_filename, "/");
      strcat (output_filename, basename);
      if (mkdir (output_filename, 0777) == -1)
	{
	  char *errmsg = strerror (errno);

	  if ((errno == EEXIST
#ifdef __MSDOS__
	       || errno == EACCES
#endif
	       )
	      && (stat (output_filename, &st) == 0 && !S_ISDIR (st.st_mode)))
	    errmsg = _("File exists, but is not a directory");
          line_error (_("Can't create directory `%s': %s"),
                      output_filename, errmsg);
          exit (1);
        }
      strcat (output_filename, "/");
    }
  else if (strlen (subdir))
    strcat (output_filename, "/");
  strcat (output_filename, index_name);
  return output_filename;
}

/* FIXME: this is way too hairy */
d1263 2
a1264 4
      if (xml && !docbook)
	xml_begin_document (output_filename);
      if (html || xml)
        { /* Change any extension to .html or .xml.  */
a1268 1

d1281 1
a1281 1
          strcat (html_name, html ? ".html" : ".xml");
d1296 1
a1296 1
      command_output_filename = NULL;  /* for included files or whatever */
a1299 1
  toplevel_output_filename = xstrdup (output_filename);
d1306 1
a1306 2
          fprintf (stderr,
  _("%s: Skipping macro expansion to stdout as Info output is going there.\n"),
d1316 1
a1316 10
      if (html && splitting)
        {
	  if (FILENAME_CMP (output_filename, NULL_DEVICE) == 0
	      || FILENAME_CMP (output_filename, ALSO_NULL_DEVICE) == 0)
	    splitting = 0;
	  else
	    output_filename = insert_toplevel_subdirectory (output_filename);
          real_output_filename = xstrdup (output_filename);
        }
      else if (!real_output_filename)
d1328 1
a1328 4
            no_headers ? "text"
            : html ? "HTML"
            : xml ? "XML"
            : "info",
a1338 1
  flush_output ();		/* in case there was no @@bye */
d1357 1
a1357 1
  if (!no_headers && !html && !xml)
a1362 3
  if (xml)
    xml_end_document ();
      
a1400 1
      flush_output ();		/* in case there was no @@bye */
d1413 1
a1413 1
        split_file (real_output_filename, split_size);
d1520 1
a1520 8
      add_word ("<li><a");
      if (next_menu_item_number <= 9)
	{
	  add_word(" accesskey=");
	  add_word_args("%d", next_menu_item_number);
	  next_menu_item_number++;
	}
      add_word (" href=\"");
a1544 4
  else if (xml && tem)
    { 
      xml_start_menu_entry (tem);
    }
a1776 2
	  else if (xml)
	    xml_insert_entity ("lt");
a1784 2
	  else if (xml)
	    xml_insert_entity ("gt");
d1802 2
a1803 10
              if (!STREQ (command, "math"))
                {
                  line_error (_("Misplaced %c"), '{');
                  remember_brace (misplaced_brace);
                }
              else
                { /* We don't mind `extra' braces inside @@math.  */
                  extern void cm_no_op ();
                  remember_brace (cm_no_op);
                }
d1854 1
a1854 1
  new->command = command ? xstrdup (command) : "";
d1936 1
d1938 1
d1940 2
a1941 3
          file_line_error (input_filename, brace_stack->line,
			   _("%c%s missing close brace"), COMMAND_PREFIX,
			   proc_name);
a2020 12
/* Like add_word, but inhibits conversion of whitespace into &nbsp;.
   Use this to output HTML directives with embedded blanks, to make
   them @@w-safe.  */
void
add_html_elt (string)
     char *string;
{
  in_html_elt++;
  add_word (string);
  in_html_elt--;
}

a2026 6
  if (xml)
    {
      xml_add_char (character);
      return;
    }

d2047 1
a2047 3
  if (non_splitting_words
      && !(html && in_html_elt)
      && strchr (" \t\n", character))
d2049 1
a2049 1
      if (html || docbook)
a2119 8
	/* This is sad, but it seems desirable to not force any
	   particular order on the front matter commands.  This way,
	   the document can do @@settitle, @@documentlanguage, etc, in
	   any order and with any omissions, and we'll still output
	   the html <head> `just in time'.  */
	if (!executing_string && html && !html_output_head_p)
	  html_output_head ();

d2266 7
d2704 1
a2704 62
      /* "@@xref{,Foo,, Bar, Baz} is not valid usage of @@xref.  The
	 first argument must never be blank." --rms.
	 We hereby comply by disallowing such constructs.  */
      if (!*arg1)
	line_error (_("First argument to cross-reference may not be empty"));

      if (xml && docbook)
	{
	  if (!*arg4 && !*arg5)
	    {
	      char *arg1_id = xml_id (arg1);
	      if (*arg2)
		{
		  xml_insert_element_with_attribute (XREFNODENAME, START, 
						     "linkend=\"%s\"", arg1_id);
		  free (arg1_id);
		  if (*arg2)
		    execute_string (arg2);
		  xml_insert_element (XREFNODENAME, END);
		} 
	      else
		{
		  xml_insert_element_with_attribute (XREF, START, 
						     "linkend=\"%s\"", arg1_id);
		  free (arg1_id);
		  xml_pop_current_element ();
		}
	    }
	}
      else if (xml)
	{
	  xml_insert_element (XREF, START);
	  xml_insert_element (XREFNODENAME, START);
	  execute_string (arg1);
	  xml_insert_element (XREFNODENAME, END);
	  if (*arg2)
	    {
	      xml_insert_element (XREFINFONAME, START);
	      execute_string (arg2);
	      xml_insert_element (XREFINFONAME, END);
	    }
	  if (*arg3)
	    {
	      xml_insert_element (XREFPRINTEDDESC, START);
	      execute_string (arg3);
	      xml_insert_element (XREFPRINTEDDESC, END);
	    }
	  if (*arg4)
	    {
	      xml_insert_element (XREFINFOFILE, START);
	      execute_string (arg4);
	      xml_insert_element (XREFINFOFILE, END);
	    }
	  if (*arg5)
	    {
	      xml_insert_element (XREFPRINTEDNAME, START);
	      execute_string (arg5);
	      xml_insert_element (XREFPRINTEDNAME, END);
	    }
	  xml_insert_element (XREF, END);
	}
      else if (html)
d2712 103
a2814 120
      if (!xml)
	{
	  if (*arg5 || *arg4)
	    {
	      /* arg1 - node name
		 arg2 - reference name
		 arg3 - title or topic (and reference name if arg2 is NULL)
		 arg4 - info file name
		 arg5 - printed manual title  */
	      char *ref_name;

	      if (!*arg2)
		{
		  if (*arg3)
		    ref_name = arg3;
		  else
		    ref_name = arg1;
		}
	      else
		ref_name = arg2;

	      if (html)
		{
		  /* html fixxme: revisit this; external node name not
		     much use to us with numbered nodes. */
		  add_html_elt ("<a href=");
		  /* Note that if we are splitting, and the referenced
		     tag is an anchor rather than a node, we will
		     produce a reference to a file whose name is
		     derived from the anchor name.  However, only
		     nodes create files, so we are referencing a
		     non-existent file.  cm_anchor, which see, deals
		     with that problem.  */
		  if (splitting)
		    execute_string ("\"../%s/", arg4);
		  else
		    execute_string ("\"%s.html", arg4);
		  /* Do not collapse -- to -, etc., in references.  */
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0); /* expand @@-commands in node */
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", ref_name);
		  add_word ("</a>");
		}
	      else
		{
		  execute_string ("%s:", ref_name);
		  in_fixed_width_font++;
		  execute_string (" (%s)%s%s", arg4, arg1, px_ref_flag ? "." : "");
		  in_fixed_width_font--;
		}

	      /* Free all of the arguments found. */
	      if (arg1) free (arg1);
	      if (arg2) free (arg2);
	      if (arg3) free (arg3);
	      if (arg4) free (arg4);
	      if (arg5) free (arg5);
	      return;
	    }
	  else
	    remember_node_reference (arg1, line_number, followed_reference);

	  if (*arg3)
	    {
	      if (html)
		{
		  add_html_elt ("<a href=\"");
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0);
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", *arg2 ? arg2 : arg3);
		  add_word ("</a>");
		}
	      else
		{
		  execute_string ("%s:", *arg2 ? arg2 : arg3);
		  in_fixed_width_font++;
		  execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
		  in_fixed_width_font--;
		}
	    }
	  else
	    {
	      if (html)
		{
		  add_html_elt ("<a href=\"");
		  in_fixed_width_font++;
		  tem = expansion (arg1, 0);
		  in_fixed_width_font--;
		  add_anchor_name (tem, 1);
		  free (tem);
		  add_word ("\">");
		  execute_string ("%s", *arg2 ? arg2 : arg1);
		  add_word ("</a>");
		}
	      else
		{
		  if (*arg2)
		    {
		      execute_string ("%s:", arg2);
		      in_fixed_width_font++;
		      execute_string (" %s%s", arg1, px_ref_flag ? "." : "");
		      in_fixed_width_font--;
		    }
		  else
		    {
		      in_fixed_width_font++;
		      execute_string ("%s::", arg1);
		      in_fixed_width_font--;
		    }
		}
	    }
	}
d2882 1
a2882 23
      /* (see comments at cm_xref).  */
      if (!*node)
	line_error (_("First argument to @@inforef may not be empty"));

      if (xml && !docbook)
	{
	  xml_insert_element (INFOREF, START);
	  xml_insert_element (INFOREFNODENAME, START);
	  execute_string (node);
	  xml_insert_element (INFOREFNODENAME, END);
	  if (*pname)
	    {
	      xml_insert_element (INFOREFREFNAME, START);
	      execute_string (pname);
	      xml_insert_element (INFOREFREFNAME, END);
	    }
	  xml_insert_element (INFOREFINFONAME, START);
	  execute_string (file);
	  xml_insert_element (INFOREFINFONAME, END);

	  xml_insert_element (INFOREF, END);
	}
      else if (html)
a2883 2
	  char *tem;

d2886 4
a2889 9
          add_html_elt ("<a href=");
	  if (splitting)
	    execute_string ("\"../%s/", file);
	  else
	    execute_string ("\"%s.html", file);
	  tem = expansion (node, 0);
	  add_anchor_name (tem, 1);
          add_word ("\">");
          execute_string ("%s", *pname ? pname : tem);
a2890 1
	  free (tem);
d2918 1
a2918 21
      if (xml)
	{
	  xml_insert_element (UREF, START);
	  xml_insert_element (UREFURL, START);
	  execute_string (url);
	  xml_insert_element (UREFURL, END);
	  if (*desc)
	    {
	      xml_insert_element (UREFDESC, START);
	      execute_string (desc);
	      xml_insert_element (UREFDESC, END);
	    }
	  if (*replacement)
	    {
	      xml_insert_element (UREFREPLACEMENT, START);
	      execute_string (replacement);
	      xml_insert_element (UREFREPLACEMENT, END);
	    }
	  xml_insert_element (UREF, END);	  
	}
      else if (html)
d2920 1
a2920 1
          add_html_elt ("<a href=");
d2967 1
a2967 22
      if (xml && docbook)
	{
	  xml_insert_element_with_attribute (EMAIL, START, "url=\"mailto:%s\"", addr);
	  if (*name)
	      execute_string (name);
	  xml_insert_element (EMAIL, END);	  	  
	}
      else if (xml)
	{
	  xml_insert_element (EMAIL, START);
	  xml_insert_element (EMAILADDRESS, START);
	  execute_string (addr);
	  xml_insert_element (EMAILADDRESS, END);
	  if (*name)
	    {
	      xml_insert_element (EMAILNAME, START);
	      execute_string (name);
	      xml_insert_element (EMAILNAME, END);
	    }
	  xml_insert_element (EMAIL, END);	  	  
	}
      else if (html)
d2969 1
a2969 1
          add_html_elt ("<a href=");
d2999 1
a2999 1
  char *name_arg, *rest, *alt_arg, *ext_arg;
d3005 1
a3005 1
  /* We don't (yet) care about the next two args, but read them so they
a3012 2
  alt_arg = get_xref_token (1); /* expands all macros in alt text */
  ext_arg = get_xref_token (0);
d3016 1
a3016 2
      char *fullname = xmalloc (strlen (name_arg)
                       + (ext_arg && *ext_arg ? strlen (ext_arg) + 1 : 4) + 1);
d3019 1
a3019 13
        {
	  if (ext_arg && *ext_arg)
	    {
	      sprintf (fullname, "%s.%s", name_arg, ext_arg);
	      if (access (fullname, R_OK) != 0)
		{
                  line_error(_("@@image file `%s' (for HTML) not readable: %s"),
		             fullname, strerror (errno));
		  return;
		}
	    }
	  else
	    {
d3026 1
a3026 2
             line_error (_("No `%s.png' or `.jpg', and no extension supplied"),
                              name_arg);
a3029 1
	    }
d3031 2
a3032 13
	  add_html_elt ("<img src=");
          add_word_args ("\"%s\"", fullname);
	  add_html_elt (" alt=");
	  add_word_args ("\"%s\">", (*alt_arg) ? alt_arg : fullname);
        }
      else if (xml && docbook)
	xml_insert_docbook_image (name_arg);
      else if (xml)
	{
	  xml_insert_element (IMAGE, START);
	  add_word (name_arg);
	  xml_insert_element (IMAGE, END);
	}
d3063 2
a3064 2
            line_error (_("@@image file `%s' (for text) unreadable: %s"),
                        fullname, strerror (errno));
a3073 4
  if (alt_arg)
    free (alt_arg);
  if (ext_arg)
    free (ext_arg);
d3418 7
a3424 3
		file_line_error (input_filename, orig_line_number,
				 _("Reached eof before matching @@end %s"),
				 condition);
a3536 3
/* FIXME: this is an arbitrary limit.  */
#define EXECUTE_STRING_MAX 16*1024

d3554 1
a3554 1
  es = get_execution_string (EXECUTE_STRING_MAX);
d3583 1
a3583 3
   expand Texinfo commands.  If IMPLICIT_CODE is set, expand @@code{STR}.
   This is generally used for short texts; filling, indentation, and
   html escapes are disabled.  */
d3590 1
d3592 6
a3597 1
  
a3604 35

  filling_enabled = 0;
  indented_fill = 0;
  no_indent = 1;
  escape_html = 0;
  
  result = full_expansion (str, implicit_code);

  filling_enabled = saved_filling_enabled;
  indented_fill = saved_indented_fill;
  no_indent = saved_no_indent;
  escape_html = saved_escape_html;  
  
  return result;
}


/* Expand STR (or @@code{STR} if IMPLICIT_CODE is nonzero).  No change to
   any formatting parameters -- filling, indentation, html escapes,
   etc., are not reset.  */

char *
full_expansion (str, implicit_code)
    char *str;
    int implicit_code;
{
  int length;
  char *result;

  /* Inhibit any real output.  */
  int start = output_paragraph_offset;
  int saved_paragraph_is_open = paragraph_is_open;
  int saved_output_column = output_column;

  /* More output state to save.  */
d3615 5
d3622 1
a3622 6
  if (strlen (str) > (implicit_code
		      ? EXECUTE_STRING_MAX - 1 - sizeof("@@code{}")
		      : EXECUTE_STRING_MAX - 1))
    line_error (_("`%.40s...' is too long for expansion; not expanded"), str);
  else
    execute_string (implicit_code ? "@@code{%s}" : "%s", str);
a3633 1

d3637 4
a3640 1

a3657 1
  int save_xml = xml;
a3659 1
  xml = 0;
a3661 1
  xml = save_xml;
@


1.1.1.8
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: makeinfo.c,v 1.74 2004/12/19 17:15:42 karl Exp $
d4 2
a5 2
   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d21 1
a21 1
   Original author of makeinfo: Brian Fox (bfox@@ai.mit.edu).  */
a29 1
#include "float.h"
a33 1
#include "lang.h"
a35 1
#include "sectioning.h"
d71 4
a136 10
/* Nonzero means we are inserting a block level HTML element that must not be
   enclosed in a <p>, such as <ul>, <ol> and <h?>.  */
int in_html_block_level_elt = 0;

/* True when expanding a macro definition.  */
static int executing_macro = 0;

/* True when we are inside a <li> block of a menu.  */
static int in_menu_item = 0;

d148 1
a148 11
static void convert_from_file (char *name);
static void convert_from_loaded_file (char *name);
static void convert_from_stream (FILE *stream, char *name);
static void do_flush_right_indentation (void);
static void handle_variable (int action);
static void handle_variable_internal (int action, char *name);
static void init_brace_stack (void);
static void init_internals (void);
static void pop_and_call_brace (void);
static void remember_brace (COMMAND_FUNCTION (*proc));
static int end_of_sentence_p (void);
d150 49
a198 1
void maybe_update_execution_strings (char **text, unsigned int new_len);
a204 16
/* Remember that an error has been printed.  If more than
   max_error_level have been printed, then exit the program. */
static void
remember_error (void)
{
  errors_printed++;
  if (max_error_level && (errors_printed > max_error_level))
    {
      fprintf (stderr, _("Too many errors!  Gave up.\n"));
      flush_file_stack ();
      if (errors_printed - max_error_level < 2)
	cm_bye ();
      xexit (1);
    }
}

d207 2
a208 1
fs_error (char *filename)
d218 1
a218 1
error (const char *format, ...)
d221 1
a221 1
     const char *format;
d245 1
a245 1
file_line_error (char *infile, int lno, const char *format, ...)
d250 1
a250 1
   const char *format;
d276 1
a276 1
line_error (const char *format, ...)
d279 1
a279 1
   const char *format;
d303 1
a303 1
warning (const char *format, ...)
d306 1
a306 1
     const char *format;
d331 15
d347 2
a348 2
static void
misplaced_brace (void)
d357 1
a357 1
print_version_info (void)
d366 2
a367 1
usage (int exit_value)
d374 1
a374 1
    puts ("");
d391 1
a391 1
    puts ("");
d394 1
a394 1
    puts (_("\
d396 1
a396 1
      --docbook             output Docbook XML rather than Info.\n\
d398 1
a398 2
      --xml                 output Texinfo XML rather than Info.\n\
      --plaintext           output plain text rather than Info.\n\
d401 1
a401 1
    puts (_("\
d415 1
a415 1
    printf (_("\
d430 2
a431 14
    puts ("");

    puts (_("\
Options for HTML:\n\
      --css-include=FILE        include FILE in HTML <style> output;\n\
                                  read stdin if FILE is -.\n\
"));

    printf (_("\
Options for XML and Docbook:\n\
      --output-indent=VAL       indent XML elements by VAL spaces (default %d).\n\
                                  If VAL is 0, ignorable whitespace is dropped.\n\
"), xml_indentation_increment);
    puts ("");
d433 1
a433 1
    puts (_("\
d435 5
a439 5
      --commands-in-node-names  allow @@ commands in node names.\n\
  -D VAR                        define the variable VAR, as with @@set.\n\
  -I DIR                        append DIR to the @@include search path.\n\
  -P DIR                        prepend DIR to the @@include search path.\n\
  -U VAR                        undefine the variable VAR, as with @@clear.\n\
d442 1
a442 1
    puts (_("\
a443 2
  --ifdocbook       process @@ifdocbook and @@docbook even if\n\
                      not generating Docbook.\n\
a447 2
  --ifxml           process @@ifxml and @@xml.\n\
  --no-ifdocbook    do not process @@ifdocbook and @@docbook text.\n\
a451 3
  --no-ifxml        do not process @@ifxml and @@xml text.\n\
\n\
  Also, for the --no-ifFORMAT options, do process @@ifnotFORMAT text.\n\
d454 1
a454 1
    puts (_("\
a458 1
  if generating XML, --ifxml is on and the others are off.\n\
d461 1
a461 1
    fputs (_("\
d465 1
a465 1
  makeinfo --xml foo.texi               write Texinfo XML to @@setfilename\n\
d474 1
a474 1
    puts (_("\n\
a478 2
  } /* end of full help */

a484 1
  { "css-include", 1, 0, 'C' },
a492 1
  { "ifdocbook", 0, &process_docbook, 1 },
a496 1
  { "ifxml", 0, &process_xml, 1 },
a498 1
  { "no-ifdocbook", 0, &process_docbook, 0 },
a502 1
  { "no-ifxml", 0, &process_xml, 0 },
a511 1
  { "output-indent", 1, 0, 'i' },
a512 1
  { "plaintext", 0, 0, 't' },
a520 13
/* We use handle_variable_internal for -D and -U, and it depends on
   execute_string, which depends on input_filename, which is not defined
   while we are handling options. :-\  So we save these defines in this
   struct, and handle them later.  */
typedef struct command_line_define
{
  struct command_line_define *next;
  int action;
  char *define;
} COMMAND_LINE_DEFINE;

static COMMAND_LINE_DEFINE *command_line_defines = NULL;

d524 3
a526 1
main (int argc, char **argv)
d528 1
a535 1
#ifdef LC_MESSAGES /* ultrix */
a536 1
#endif
a540 1
#ifdef ENABLE_NLS
a543 49
#endif

  /* If TEXINFO_OUTPUT_FORMAT envvar is set, use it to set default output.
     Can be overridden with one of the output options.  */
  if (getenv ("TEXINFO_OUTPUT_FORMAT") != NULL)
    {
      if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "docbook"))
        {
          splitting = 0;
          html = 0;
          docbook = 1;
          xml = 1;
          process_docbook = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "html"))
        {
          html = 1;
          docbook = 0;
          xml = 0;
          process_html = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "info"))
        {
          html = 0;
          docbook = 0;
          xml = 0;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "plaintext"))
        {
          splitting = 0;
          no_headers = 1;
          html = 0;
          docbook = 0;
          xml = 0;
          process_plaintext = 1;
        }
      else if (STREQ (getenv ("TEXINFO_OUTPUT_FORMAT"), "xml"))
        {
          splitting = 0;
          html = 0;
          docbook = 0;
          xml = 1;
          process_xml = 1;
        }
      else
        fprintf (stderr,
            _("%s: Ignoring unrecognized TEXINFO_OUTPUT_FORMAT value `%s'.\n"),
                 progname, getenv ("TEXINFO_OUTPUT_FORMAT"));
    }
d546 1
a546 1
  while ((c = getopt_long (argc, argv, "D:de:E:f:hI:i:o:p:P:r:s:t:U:vV:wx",
a553 4
        case 'C':  /* --css-include */
          css_include = xstrdup (optarg);
          break;

d557 1
a557 10
          if (xml && !docbook)
            {
              COMMAND_LINE_DEFINE *new = xmalloc (sizeof (COMMAND_LINE_DEFINE));
              new->action = (c == 'D') ? SET : CLEAR;
              new->define = xstrdup (optarg);
              new->next = command_line_defines;
              command_line_defines = new;
            }
          else
            handle_variable_internal ((c == 'D' ? SET : CLEAR), optarg);
d562 2
a563 4
          xml = 1;
          docbook = 1;
          html = 0;
	  process_docbook = 1;
d571 1
a571 1
                      progname, "--error-limit", optarg);
d583 1
a583 2
                error (_("%s: could not open macro expansion output `%s'"),
                       progname, optarg);
d586 1
a586 3
            fprintf (stderr,
                     _("%s: ignoring second macro expansion output `%s'.\n"),
                     progname, optarg);
d594 1
a594 1
                       progname, "--fill-column", optarg);
d605 2
a606 2
          append_to_include_path (optarg);
          break;
d608 5
a612 8
        case 'i':
          if (sscanf (optarg, "%d", &xml_indentation_increment) != 1)
            {
              fprintf (stderr,
                     _("%s: %s arg must be numeric, not `%s'.\n"),
                     progname, "--output-indent", optarg);
              usage (1);
            }
d632 17
a648 1
          prepend_to_include_path (optarg);
d656 1
a656 1
                     progname, "--reference-limit", optarg);
d665 1
a665 1
        _("%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"),
d672 1
a672 1
        case 'S': /* --split-size */
d677 1
a677 1
                     progname, "--split-size", optarg);
d680 1
a680 10
          break;

        case 't': /* --plaintext */
          splitting = 0;
          no_headers = 1;
          html = 0;
          docbook = 0;
          xml = 0;
          process_plaintext = 1;
          break;
d689 2
a690 2
          puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
          printf (_("There is NO warranty.  You may redistribute this software\n\
d692 3
a694 2
For more information about these matters, see the files named COPYING.\n"));
          xexit (0);
a697 2
          xml = 0;
          docbook = 0;
d704 1
a704 4
          html = 0;
          docbook = 0;
          xml = 1;
          process_xml = 1;
d706 1
a706 1

a712 3
  if (macro_expansion_output_stream)
    validating = 0;

d730 1
a730 5
      /* If the user did not specify an output file, use stdout. */
      if (!command_output_filename)
        command_output_filename = xstrdup ("-");

      if (html && splitting && !STREQ (command_output_filename, "-"))
d733 2
a734 2
                  "%s: can't split --html output to `%s' with --no-headers.\n",
                   progname, command_output_filename);
d740 4
d745 1
a745 1

d757 1
a757 1

d771 1
a771 2
  xexit (errors_printed ? 2 : 0);
  return 0; /* Avoid bogus warnings.  */
d773 1
d777 3
a779 16
/* Return the next token as a string pointer.  We cons the string.  This
   `token' means simply a command name.  */

/* = is so @@alias works.  ^ and _ are so macros can be used in math mode
   without a space following.  Possibly we should simply allow alpha, to
   be compatible with TeX.  */
#define COMMAND_CHAR(c) (!cr_or_whitespace(c) \
                         && (c) != '{' \
                         && (c) != '}' \
                         && (c) != '=' \
                         && (c) != '_' \
                         && (c) != '^' \
                         )

static char *
read_token (void)
d801 1
a801 1
               && COMMAND_CHAR (character));
d811 2
a812 1
self_delimiting (int character)
d816 1
a816 1
  return strchr ("~{|}`^\\@@?=;:./-,*\'\" !\n\t", character) != NULL;
d821 2
a822 1
canon_white (char *string)
d824 2
a825 2
  char *p = string;
  unsigned len;
d827 1
a827 1
  if (!*p)
d830 1
a830 1
  do
d832 5
a836 3
      if (!cr_or_whitespace (*p))
	break;
      ++p;
d838 6
a843 10
  while (*p);

  len = strlen (p);
  while (len && cr_or_whitespace (p[len-1]))
    --len;

  if (p != string)
    memmove (string, p, len);

  string[len] = 0;
d848 2
a849 1
fix_whitespace (char *string)
d879 2
a880 1
discard_until (char *string)
d894 2
a895 2
      /* not found, move current position to end of string */
      input_text_offset = input_text_length;
d897 2
a898 11
        { /* Give a more descriptive feedback, if we are looking for ``@@end ''
             during macro execution.  That means someone used a multiline
             command as an argument to, say, @@section ... style commands.  */
          char *end_block = xmalloc (8);
          sprintf (end_block, "\n%cend ", COMMAND_PREFIX);
          if (executing_string && strstr (string, end_block))
            line_error (_("Multiline command %c%s used improperly"), 
                COMMAND_PREFIX, command);
          else
            line_error (_("Expected `%s'"), string);
          free (end_block);
d903 3
a905 2
    /* found, move current position to after the found string */
    input_text_offset = temp + strlen (string);
d913 2
a914 1
get_until (char *match, char **string)
d947 2
a948 1
replace_with_expansion (int from, int *to)
d1024 3
a1026 1
get_until_in_line (int expand, char *match, char **string)
d1058 3
a1060 1
get_rest_of_line (int expand, char **string)
d1068 1
a1068 1
         intact in the macro-expanded output.  */
d1091 1
a1091 1
backup_input_pointer (void)
d1104 2
a1105 1
get_until_in_braces (char *match, char **string)
d1115 1
a1115 1
          i++;                  /* skip commands like @@, and @@{ */
a1142 2


d1160 2
a1161 2
static void
initialize_conversion (void)
d1175 4
d1183 2
a1184 1
reverse_list (GENERIC_LIST *list)
d1205 4
a1208 2
static void
convert_from_stream (FILE *stream, char *name)
d1255 3
a1257 2
static void
convert_from_file (char *name)
a1261 3
  /* Prepend file directory to the search path, so relative links work.  */
  prepend_to_include_path (pathname_part (name));

d1272 1
a1272 1
      if (find_and_load (filename, 1))
a1292 32

  /* Pop the prepended path, so multiple filenames in the
     command line do not screw each others include paths.  */
  pop_path_from_include_path ();
}

static int
create_html_directory (char *dir, int can_remove_file)
{
  struct stat st;

  /* Already exists.  */
  if (stat (dir, &st) == 0)
    {
      /* And it's a directory, so silently reuse it.  */
      if (S_ISDIR (st.st_mode))
        return 1;
      /* Not a directory, so move it out of the way if we are allowed.  */
      else if (can_remove_file)
        {
          if (unlink (dir) != 0)
            return 0;
        }
      else
        return 0;
    }

  if (mkdir (dir, 0777) == 0)
    /* Success!  */
    return 1;
  else
    return 0;
d1297 1
a1297 1

d1302 1
a1302 1

d1307 2
a1308 1
insert_toplevel_subdirectory (char *output_filename)
a1309 1
  static const char index_name[] = "index.html";
d1312 2
d1317 3
a1319 3
  dir = pathname_part (buf);   /* directory of output_filename */
  base = filename_part (buf);  /* strips suffix, too */
  basename = xstrdup (base);   /* remember real @@setfilename name */
d1328 9
a1336 5
  if (save_command_output_filename
      && STREQ (output_filename, save_command_output_filename))
    subdir = basename;  /* from user, use unchanged */
  else
    subdir = base;      /* implicit, omit suffix */
d1340 3
a1342 3
                             + strlen (basename) + 1
                             + index_len
                             + 1);
d1347 4
a1350 6

  /* First try, do not remove existing file.  */
  if (!create_html_directory (output_filename, 0))
    {
      /* That failed, try subdir name with .html.
         Remove it if it exists.  */
d1355 3
d1359 7
a1365 3
      if (!create_html_directory (output_filename, 1))
        {
          /* Last try failed too :-\  */
d1367 2
a1368 2
              output_filename, strerror (errno));
          xexit (1);
d1370 1
d1372 2
a1373 2

  strcat (output_filename, "/");
d1379 3
a1381 2
static void
convert_from_loaded_file (char *name)
d1420 1
a1420 1

d1448 2
d1508 5
a1512 5
          if (FILENAME_CMP (output_filename, NULL_DEVICE) == 0
              || FILENAME_CMP (output_filename, ALSO_NULL_DEVICE) == 0)
            splitting = 0;
          else
            output_filename = insert_toplevel_subdirectory (output_filename);
a1524 3
  if (xml && !docbook)
    xml_begin_document (filename_part (output_filename));

d1541 1
a1541 1
  flush_output ();              /* in case there was no @@bye */
a1564 13

  if (xml && !docbook)
    {
      /* Just before the real main loop, let's handle the defines.  */
      COMMAND_LINE_DEFINE *temp;

      for (temp = command_line_defines; temp; temp = temp->next)
        {
          handle_variable_internal (temp->action, temp->define);
          free(temp->define);
        }
    }

d1568 1
a1568 1

d1583 1
a1583 2
          fprintf (stderr,
_("%s: Removing macro output file `%s' due to errors; use --force to preserve.\n"),
d1593 6
a1601 1
          no_indent = 1;
d1607 1
a1607 17
      /* maybe we want local variables in info output.  */
      {
        char *trailer = info_trailer ();
	if (!xml && !docbook && trailer)
          {
            if (html)
              insert_string ("<!--");
            insert_string (trailer);
            free (trailer);
            if (html)
              insert_string ("\n-->\n");
          }
      }

      /* Write stuff makeinfo generates after @@bye, ie. info_trailer.  */
      flush_output ();

d1615 3
a1617 8
      handle_delayed_writes ();

      if (tag_table)
        {
          tag_table = (TAG_ENTRY *) reverse_list ((GENERIC_LIST *) tag_table);
          if (!no_headers && !html && !STREQ (current_output_filename, "-"))
            write_tag_table (real_output_filename);
        }
d1620 1
a1620 4
        {
          clean_old_split_files (real_output_filename);
          split_file (real_output_filename, split_size);
        }
d1627 1
a1627 2
          fprintf (stderr,
  _("%s: Removing output file `%s' due to errors; use --force to preserve.\n"),
a1634 22

/* If enable_encoding is set and @@documentencoding is used, return a
   Local Variables section (as a malloc-ed string) so that Emacs'
   locale features can work.  Else return NULL.  */
char *
info_trailer (void)
{
  char *encoding;

  if (!enable_encoding)
    return NULL;

  encoding = current_document_encoding ();

  if (encoding && *encoding)
    {
#define LV_FMT "\n\037\nLocal Variables:\ncoding: %s\nEnd:\n"
      char *lv = xmalloc (sizeof (LV_FMT) + strlen (encoding));
      sprintf (lv, LV_FMT, encoding);
      free (encoding);
      return lv;
    }
a1635 4
  free (encoding);
  return NULL;
}

d1637 2
a1638 1
free_and_clear (char **pointer)
d1648 2
a1649 2
static void
init_internals (void)
d1669 1
a1669 1
init_paragraph (void)
d1671 1
a1671 1
  free (output_paragraph);
d1685 1
a1685 1
handle_menu_entry (void)
d1688 1
a1688 1

d1691 1
a1691 1

d1711 1
a1711 1
          add_html_block_elt ("<ul class=\"menu\">\n");
d1715 6
a1720 1

d1723 1
a1723 2
          add_html_block_elt ("</p>\n");
          add_html_block_elt ("<ul class=\"menu\">\n");
d1727 1
a1727 3
      in_menu_item = 1;

      add_html_block_elt ("<li><a");
d1729 5
a1733 5
        {
          add_word(" accesskey=");
          add_word_args("\"%d\"", next_menu_item_number);
          next_menu_item_number++;
        }
d1756 2
a1757 13
      input_text_offset++;      /* discard the second colon or the period */

      /* Insert a colon only if there is a description of this menu item.  */
      {
        int save_input_text_offset = input_text_offset;
        int save_line_number = line_number;
        char *test_string;
        get_rest_of_line (0, &test_string);
        if (strlen (test_string) > 0)
          add_word (": ");
        input_text_offset = save_input_text_offset;
        line_number = save_line_number;
      }
d1760 1
a1760 1
    {
d1778 2
a1779 1
get_command_entry (char *string)
d1802 1
a1802 1
read_command (void)
a1822 1
        executing_macro++;
a1823 1
        executing_macro--;
d1830 1
a1830 1
  }
d1906 1
a1906 1
reader_loop (void)
d1910 1
a1921 1
          && ((!html && !xml) || escape_html)
d1925 2
a1926 17
          if (html)
            {
              input_text_offset += 2;
              add_word (character == '`' ? "&ldquo;" : "&rdquo;");
              continue;
            }
          else if (xml)
            {
              input_text_offset += 2;
              xml_insert_entity (character == '`' ? "ldquo" : "rdquo");
              continue;
            }
          else
            {
              input_text_offset++;
              character = '"';
            }
d1930 1
a1930 2
      if (!only_macro_expansion && character == '-' && !in_fixed_width_font
          && ((!html && !xml) || escape_html))
d1932 2
a1933 4
          int dash_count = 0;

          /* Get the number of consequtive dashes.  */
          while (input_text[input_text_offset] == '-')
a1934 1
              dash_count++;
d1936 1
d1938 9
d1948 2
a1949 2
          /* Eat one dash.  */
          dash_count--;
d1951 1
a1951 1
          if (html || xml)
d1953 5
a1957 49
              if (dash_count == 0)
                add_char ('-');
              else
                while (dash_count > 0)
                  {
                    if (dash_count >= 2)
                      {
                        if (html)
                          add_word ("&mdash;");
                        else
                          xml_insert_entity ("mdash");
                        dash_count -= 2;
                      }
                    else if (dash_count >= 1)
                      {
                        if (html)
                          add_word ("&ndash;");
                        else
                          xml_insert_entity ("ndash");
                        dash_count--;
                      }
                  }
            }
          else
            {
              add_char ('-');
              while (--dash_count > 0)
                add_char ('-');
            }

          continue;
        }

      /* If this is a whitespace character, then check to see if the line
         is blank.  If so, advance to the carriage return. */
      if (!only_macro_expansion && whitespace (character))
        {
          int i = input_text_offset + 1;

          while (i < input_text_length && whitespace (input_text[i]))
            i++;

          if (i == input_text_length || input_text[i] == '\n')
            {
              if (i == input_text_length)
                i--;

              input_text_offset = i;
              character = curchar ();
d1980 1
a1980 1

d1995 2
a1996 2
          else if (xml && escape_html)
            xml_insert_entity ("lt");
d2005 2
a2006 2
          else if (xml && escape_html)
            xml_insert_entity ("gt");
d2024 1
a2024 1
              if (command && !STREQ (command, "math"))
d2030 4
a2033 2
                /* We don't mind `extra' braces inside @@math.  */
                remember_brace (cm_no_op);
d2057 2
a2058 2
static void
init_brace_stack (void)
d2063 11
d2076 4
a2079 2
static void
remember_brace_1 (COMMAND_FUNCTION (*proc), int position)
a2090 10
static void
remember_brace (COMMAND_FUNCTION (*proc))
{
  if (curchar () != '{')
    line_error (_("%c%s expected braces"), COMMAND_PREFIX, command);
  else
    input_text_offset++;
  remember_brace_1 (proc, output_paragraph_offset);
}

d2093 2
a2094 2
static void
pop_and_call_brace (void)
d2122 3
a2124 2
static void
adjust_braces_following (int here, int amount)
d2139 3
a2141 2
static const char *
find_proc_name (COMMAND_FUNCTION (*proc))
d2156 1
a2156 1
discard_braces (void)
d2165 1
a2165 1
          const char *proc_name;
d2169 2
a2170 2
                           _("%c%s missing close brace"), COMMAND_PREFIX,
                           proc_name);
d2183 3
a2185 2
static int
get_char_len (int character)
d2219 1
a2219 1
add_word_args (const char *format, ...)
d2222 1
a2222 1
    const char *format;
d2243 2
a2244 1
add_word (char *string)
d2254 2
a2255 1
add_html_elt (char *string)
a2261 57
/* These two functions below, add_html_block_elt and add_html_block_elt_args,
   are mixtures of add_html_elt and add_word_args.  They inform makeinfo that
   the current HTML element being inserted should not be enclosed in a <p>
   element.  */
void
add_html_block_elt (char *string)
{
  in_html_block_level_elt++;
  add_word (string);
  in_html_block_level_elt--;
}

void
#if defined (VA_FPRINTF) && __STDC__
add_html_block_elt_args (const char *format, ...)
#else
add_html_block_elt_args (format, va_alist)
    const char *format;
    va_dcl
#endif
{
  char buffer[2000]; /* xx no fixed limits */
#ifdef VA_FPRINTF
  va_list ap;
#endif

  VA_START (ap, format);
#ifdef VA_SPRINTF
  VA_SPRINTF (buffer, format, ap);
#else
  sprintf (buffer, format, a1, a2, a3, a4, a5, a6, a7, a8);
#endif /* not VA_SPRINTF */
  va_end (ap);
  add_html_block_elt (buffer);
}

/* Here is another awful kludge, used in add_char.  Ordinarily, macro
   expansions take place in the body of the document, and therefore we
   should html_output_head when we see one.  But there's an exception: a
   macro call might take place within @@copying, and that does not start
   the real output, even though we fully expand the copying text.

   So we need to be able to check if we are defining the @@copying text.
   We do this by looking back through the insertion stack.  */
static int
defining_copying (void)
{
  INSERTION_ELT *i;
  for (i = insertion_stack; i; i = i->next)
    {
      if (i->insertion == copying)
        return 1;
    }
  return 0;
}


d2265 2
a2266 1
add_char (int character)
a2299 2
          int saved_escape_html = escape_html;
          escape_html = 0;
a2300 1
          escape_html = saved_escape_html;
d2312 1
a2312 1
      if (!filling_enabled && !(html && (in_menu || in_detailmenu)))
d2369 7
a2375 9
        /* This is sad, but it seems desirable to not force any
           particular order on the front matter commands.  This way,
           the document can do @@settitle, @@documentlanguage, etc, in
           any order and with any omissions, and we'll still output
           the html <head> `just in time'.  */
        if ((executing_macro || !executing_string)
            && !only_macro_expansion
            && html && !html_output_head_p && !defining_copying ())
          html_output_head ();
d2387 5
a2391 4
            /* This check for in_html_block_level_elt prevents <p> from being
               inserted when we already have html markup starting a paragraph,
               as with <ul> and <h1> and the like.  */
            if (html && !in_html_block_level_elt)
a2392 5
                if ((in_menu || in_detailmenu) && in_menu_item)
                  {
                    insert_string ("</li></ul>\n");
                    in_menu_item = 0;
                  }
d2447 3
a2449 3
                              memmove (&output_paragraph[temp],
                                       &output_paragraph[t1],
                                       output_paragraph_offset - t1);
d2511 2
a2512 1
add_meta_char (int character)
d2520 2
a2521 1
insert (int character)
a2522 11
  /* We don't want to strip trailing whitespace in multitables.  Otherwise
     horizontal separators confuse the font locking in Info mode in Emacs,
     because it looks like a @@subsection.  Adding a trailing space to those
     lines fixes it.  */
  if (character == '\n' && !html && !xml && !multitable_active)
    {
      while (output_paragraph_offset
	     && whitespace (output_paragraph[output_paragraph_offset-1]))
	output_paragraph_offset--;
    }

d2533 2
a2534 1
insert_string (const char *string)
d2548 1
a2548 1
end_of_sentence_p (void)
d2571 2
a2572 1
kill_self_indent (int count)
d2601 1
a2601 1
inhibit_output_flushing (void)
d2608 1
a2608 1
uninhibit_output_flushing (void)
d2614 1
a2614 1
flush_output (void)
a2622 6
      if (output_paragraph[i] == '\n')
        {
          output_line_number++;
          node_line_number++;
        }

d2652 2
a2653 1
close_paragraph_with_lines (int lines)
d2663 1
a2663 1
close_single_paragraph (void)
d2670 1
a2670 1
close_insertion_paragraph (void)
d2706 1
a2706 1
close_paragraph (void)
a2709 5
  /* We don't need these newlines in XML and Docbook outputs for
     paragraph seperation.  We have <para> element for that.  */
  if (xml)
    return;

d2715 3
a2717 1
      int tindex = output_paragraph_offset;
d2725 1
a2725 1
          int c = output_paragraph[tindex];
d2769 1
a2769 1
ignore_blank_line (void)
d2776 2
a2777 2
static void
do_flush_right_indentation (void)
d2814 1
a2814 1
start_paragraph (void)
d2861 2
a2862 1
indent (int amount)
d2864 3
d2878 3
a2880 1
search_forward (char *string, int from)
d2892 48
d2941 3
a2943 3
/* search_forward until n characters.  */
int
search_forward_until_pos (char *string, int from, int end_pos)
d2945 8
a2952 2
  int save_input_text_length = input_text_length;
  input_text_length = end_pos;
d2954 202
a3155 1
  from = search_forward (string, from);
d3157 14
a3170 1
  input_text_length = save_input_text_length;
d3172 14
a3185 1
  return from;
d3188 3
a3190 3
/* Return next non-whitespace and non-cr character.  */
int
next_nonwhitespace_character (void)
d3192 7
a3198 3
  /* First check the current input_text.  Start from the next char because
     we already have input_text[input_text_offset] in ``current''.  */
  int pos = input_text_offset + 1;
d3200 5
a3204 1
  while (pos < input_text_length)
d3206 55
a3260 3
      if (!cr_or_whitespace(input_text[pos]))
        return input_text[pos];
      pos++;
d3262 1
d3264 11
a3274 3
  { /* Can't find a valid character, so go through filestack
       in case we are doing @@include or expanding a macro.  */
    FSTACK *tos = filestack;
d3276 58
a3333 5
    while (tos)
      {
        int tmp_input_text_length = filestack->size;
        int tmp_input_text_offset = filestack->offset;
        char *tmp_input_text = filestack->text;
d3335 9
a3343 6
        while (tmp_input_text_offset < tmp_input_text_length)
          {
            if (!cr_or_whitespace(tmp_input_text[tmp_input_text_offset]))
              return tmp_input_text[tmp_input_text_offset];
            tmp_input_text_offset++;
          }
d3345 39
a3383 3
        tos = tos->next;
      }
  }
d3385 5
a3389 1
  return -1;
d3391 1
a3391 1

d3395 2
a3396 1
cm_image (int arg)
d3398 1
a3398 1
  char *name_arg, *w_arg, *h_arg, *alt_arg, *ext_arg;
d3404 8
a3411 2
  w_arg = get_xref_token (0);
  h_arg = get_xref_token (0);
a3416 2
      struct stat file_info;
      char *pathname = NULL;
d3418 1
a3418 1
                       + (ext_arg && *ext_arg ? strlen (ext_arg) + 1: 4) + 1);
d3420 1
a3420 1
      if (ext_arg && *ext_arg)
d3422 1
a3422 6
          sprintf (fullname, "%s%s", name_arg, ext_arg);
          if (access (fullname, R_OK) != 0)
            pathname = get_file_info_in_path (fullname, include_files_path,
                                              &file_info);

	  if (pathname == NULL)
a3423 2
	      /* Backwards compatibility (4.6 <= version < 4.7):
		 try prefixing @@image's EXTENSION parameter with a period. */
d3426 5
a3430 2
		pathname = get_file_info_in_path (fullname, include_files_path,
						  &file_info);
d3432 2
a3433 3
        }
      else
        {
d3435 2
a3436 4
          if (access (fullname, R_OK) != 0) {
            pathname = get_file_info_in_path (fullname,
                                              include_files_path, &file_info);
            if (pathname == NULL) {
d3438 5
a3442 5
              if (access (fullname, R_OK) != 0) {
                sprintf (fullname, "%s.gif", name_arg);
                if (access (fullname, R_OK) != 0) {
                  pathname = get_file_info_in_path (fullname,
                                               include_files_path, &file_info);
a3443 2
              }
            }
d3445 1
a3445 1
        }
d3447 1
a3447 24
      if (html)
        {
          int image_in_div = 0;

          if (pathname == NULL && access (fullname, R_OK) != 0)
            {
              line_error(_("@@image file `%s' (for HTML) not readable: %s"),
                             fullname, strerror (errno));
              return;
            }
          if (pathname != NULL && access (pathname, R_OK) != 0)
            {
              line_error (_("No such file `%s'"),
                          fullname);
              return;
            }

          if (!paragraph_is_open)
            {
              add_html_block_elt ("<div class=\"block-image\">");
              image_in_div = 1;
            }

          add_html_elt ("<img src=");
d3449 2
a3450 6
          add_html_elt (" alt=");
          add_word_args ("\"%s\">", 
              escape_string (*alt_arg ? text_expansion (alt_arg) : fullname));

          if (image_in_div)
            add_html_block_elt ("</div>");
d3453 1
a3453 1
        xml_insert_docbook_image (name_arg);
d3455 5
a3459 19
        {
          extern int xml_in_para;
          extern int xml_no_para;
          int elt = xml_in_para ? INLINEIMAGE : IMAGE;

          if (!xml_in_para)
            xml_no_para++;

          xml_insert_element_with_attribute (elt,
              START, "width=\"%s\" height=\"%s\" name=\"%s\" extension=\"%s\"",
              w_arg, h_arg, name_arg, ext_arg);
          xml_insert_element (IMAGEALTTEXT, START);
          execute_string ("%s", alt_arg);
          xml_insert_element (IMAGEALTTEXT, END);
          xml_insert_element (elt, END);

          if (!xml_in_para)
            xml_no_para--;
        }
d3461 1
a3461 1
        { /* Try to open foo.EXT or foo.txt.  */
d3463 4
a3466 18
          char *txtpath = NULL;
          char *txtname = xmalloc (strlen (name_arg)
                                   + (ext_arg && *ext_arg
                                      ? strlen (ext_arg) : 4) + 1);
          strcpy (txtname, name_arg);
          strcat (txtname, ".txt");
          image_file = fopen (txtname, "r");
          if (image_file == NULL)
            {
              txtpath = get_file_info_in_path (txtname,
                                               include_files_path, &file_info);
              if (txtpath != NULL)
                image_file = fopen (txtpath, "r");
            }

          if (image_file != NULL
              || access (fullname, R_OK) == 0
              || (pathname != NULL && access (pathname, R_OK) == 0))
a3470 8
              int image_in_brackets = paragraph_is_open;

              /* Write magic ^@@^H[image ...^@@^H] cookie in the info file, if
                 there's an accompanying bitmap.  Otherwise just include the
                 text image.  In the plaintext output, always include the text
                 image without the magic cookie.  */
              int use_magic_cookie = !no_headers
                && access (fullname, R_OK) == 0 && !STREQ (fullname, txtname);
d3476 6
a3481 47
              if (use_magic_cookie)
                {
                  add_char ('\0');
                  add_word ("\010[image");

                  if (access (fullname, R_OK) == 0
                      || (pathname != NULL && access (pathname, R_OK) == 0))
                    add_word_args (" src=\"%s\"", fullname);

                  if (*alt_arg)
                    add_word_args (" alt=\"%s\"", alt_arg);
                }

              if (image_file != NULL)
                {
                  if (use_magic_cookie)
                    add_word (" text=\"");

                  if (image_in_brackets)
                    add_char ('[');

                  /* Maybe we need to remove the final newline if the image
                     file is only one line to allow in-line images.  On the
                     other hand, they could just make the file without a
                     final newline.  */
                  while ((ch = getc (image_file)) != EOF)
                    {
                      if (use_magic_cookie && (ch == '"' || ch == '\\'))
                        add_char ('\\');
                      add_char (ch);
                    }

                  if (image_in_brackets)
                    add_char (']');
                  
                  if (use_magic_cookie)
                    add_char ('"');

                  if (fclose (image_file) != 0)
                    perror (txtname);
                }

              if (use_magic_cookie)
                {
                  add_char ('\0');
                  add_word ("\010]");
                }
d3485 3
d3490 2
a3491 2
            warning (_("@@image file `%s' (for text) unreadable: %s"),
                        txtname, strerror (errno));
a3494 2
      if (pathname)
        free (pathname);
a3500 4
  if (w_arg)
    free (w_arg);
  if (h_arg)
    free (h_arg);
d3520 4
a3523 2
static void
set (char *name, char *value)
a3539 7

  if (xml && !docbook)
    {
      xml_insert_element_with_attribute (SETVALUE, START, "name=\"%s\"", name);
      execute_string ("%s", value);
      xml_insert_element (SETVALUE, END);
    }
d3543 3
a3545 2
static void
clear (char *name)
a3568 6

  if (xml && !docbook)
    {
      xml_insert_element_with_attribute (CLEARVALUE, START, "name=\"%s\"", name);
      xml_insert_element (CLEARVALUE, END);
    }
d3572 3
a3574 2
static char *
set_p (char *name)
d3587 1
a3587 1
cm_set (void)
d3594 1
a3594 1
cm_clear (void)
d3600 1
a3600 1
cm_ifset (void)
d3606 1
a3606 1
cm_ifclear (void)
d3618 1
a3618 1
cm_ifeq (void)
d3638 2
a3639 1
cm_value (int arg, int start_pos, int end_pos)
a3642 6
  /* xml_add_char() skips any content inside menus when output format is
     Docbook, so @@value{} is no use there.  Also start_pos and end_pos does not
     get updated, causing name to be empty string.  So just return.  */
   if (docbook && in_menu)
     return;

d3657 2
a3658 2
         textual transformations like "--" into "-", since @@set didn't
         do that when it grabbed the name of the variable.  */
d3683 3
a3685 3
         we are called with arg == END, the reader loop already
         popped the brace stack, which restored in_fixed_width_font,
         among other things.  */
d3688 1
a3688 8
	{
	  /* We need to get past the closing brace since the value may
	     expand to a context-sensitive macro (e.g. @@xref) and produce
	     spurious warnings */
	  input_text_offset++; 
	  execute_string ("%s", value);
	  input_text_offset--;
	}
d3690 1
a3690 4
	{
          warning (_("undefined flag: %s"), name);
          add_word_args (_("{No value for `%s'}"), name);
	}
d3697 3
a3699 2
static void
handle_variable (int action)
d3713 4
a3716 2
static void
handle_variable_internal (int action, char *name)
d3849 3
a3851 3
                file_line_error (input_filename, orig_line_number,
                                 _("Reached eof before matching @@end %s"),
                                 condition);
d3872 1
d3883 3
a3885 2
static EXECUTION_STRING *
get_execution_string (int initial_size)
d3933 3
a3935 1
maybe_update_execution_strings (char **text, unsigned int new_len)
d3979 1
a3979 1
  char *temp_string, *temp_input_filename;
a3982 1
  int insertion_level_at_start = insertion_level;
d3999 1
a4000 2
  input_filename = xstrdup (input_filename);
  temp_input_filename = input_filename;
d4004 1
a4004 13

  /* If insertion stack level changes during execution, that means a multiline
     command is used inside braces or @@section ... kind of commands.  */
  if (insertion_level_at_start != insertion_level && !executing_macro)
    {
      line_error (_("Multiline command %c%s used improperly"),
          COMMAND_PREFIX,
          command);
      /* We also need to keep insertion_level intact to make sure warnings are
         issued for @@end ... command.  */
      while (insertion_level > insertion_level_at_start)
        pop_insertion ();
    }
a4008 1
  free (temp_input_filename);
d4013 3
a4015 13
   expand Texinfo commands according to the current output format.  If
   IMPLICIT_CODE is set, expand @@code{STR}.  This is generally used for
   short texts; filling, indentation, and html escapes are disabled.  */

char *
expansion (char *str, int implicit_code)
{
  return maybe_escaped_expansion (str, implicit_code, 0);
}


/* Do HTML escapes according to DO_HTML_ESCAPE.  Needed in
   cm_printindex, q.v.  */
d4018 3
a4020 1
maybe_escaped_expansion (char *str, int implicit_code, int do_html_escape)
d4023 1
a4023 1

d4035 2
a4036 2
  escape_html = do_html_escape;

d4042 2
a4043 2
  escape_html = saved_escape_html;

d4050 1
a4050 1
   etc., are not reset.  Always returned in new memory.  */
d4053 3
a4055 1
full_expansion (char *str, int implicit_code)
d4079 2
a4080 2
                      ? EXECUTE_STRING_MAX - 1 - sizeof("@@code{}")
                      : EXECUTE_STRING_MAX - 1))
d4112 2
a4113 1
text_expansion (char *str)
d4118 1
a4118 2
  int save_docbook = docbook;

a4120 1
  docbook = 0;
d4124 1
a4124 2
  docbook = save_docbook;

d4137 2
a4138 1
set_paragraph_indent (char *string)
@


