head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.46
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.42
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.38
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.40
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.32
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.36
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.34
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.30
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.28
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.26
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.24
	OPENBSD_5_0:1.1.1.3.0.22
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.20
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.18
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.14
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.16
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.12
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	TEXINFO_4_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.16
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.14
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.12
	OPENBSD_3_7_BASE:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.10
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	TEXINFO_4_0:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.02.09.01.25.30;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.09.01.25.30;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.10.13.21.22;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.07.17.16.03.48;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* node.h -- declarations for Node.
   $Id: node.h,v 1.5 1999/07/11 16:50:19 karl Exp $

   Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#ifndef NODE_H
#define NODE_H

/* The various references that we know about. */
/* What we remember for each node. */
typedef struct tentry
{
  struct tentry *next_ent;
  char *node;           /* Name of this node. */
  char *prev;           /* Name of "Prev:" for this node. */
  char *next;           /* Name of "Next:" for this node. */
  char *up;             /* Name of "Up:" for this node.   */
  int position;         /* Output file position of this node. */
  int line_no;          /* Defining line in source file. */
  char *filename;       /* The file that this node was found in. */
  int touched;          /* Nonzero means this node has been referenced. */
  int flags;
  int number;           /* Number for this node, relevant for HTML
                           splitting -- from use+define order, not just
                           define. */
} TAG_ENTRY;

/* If node-a has a "Next" for node-b, but node-b has no "Prev" for node-a,
   we turn on this flag bit in node-b's tag entry.  This means that when
   it is time to validate node-b, we don't report an additional error
   if there was no "Prev" field. */
#define TAG_FLAG_PREV_ERROR  1
#define TAG_FLAG_NEXT_ERROR  2
#define TAG_FLAG_UP_ERROR    4
#define TAG_FLAG_NO_WARN     8
#define TAG_FLAG_IS_TOP     16
#define TAG_FLAG_ANCHOR     32

/* Menu reference, *note reference, and validation hacking. */

/* A structure to remember references with.  A reference to a node is
   either an entry in a menu, or a cross-reference made with [px]ref. */
typedef struct node_ref
{
  struct node_ref *next;
  char *node;                   /* Name of node referred to. */
  char *containing_node;        /* Name of node containing this reference. */
  int line_no;                  /* Line number where the reference occurs. */
  int section;                  /* Section level where the reference occurs. */
  char *filename;               /* Name of file where the reference occurs. */
  enum reftype type;            /* Type of reference, either menu or note. */
  int number;                   /* Number for this node, relevant for
                                   HTML splitting -- from use+define
                                   order, not just define. */
} NODE_REF;

/* The linked list of such structures. */
extern NODE_REF *node_references;

/* A similar list for references occuring in @@node next
   and similar references, needed for HTML. */
extern NODE_REF *node_node_references;

/* List of all nodes.  */
extern TAG_ENTRY *tag_table;

/* Counter for setting node_ref.number; zero is Top. */
extern int node_number;

/* The current node's section level. */
extern int current_section;

/* Nonzero when the next sectioning command should generate an anchor
   corresponding to the current node in HTML mode. */
extern int outstanding_node;

extern TAG_ENTRY *find_node ();

/* A search string which is used to find a line defining a node. */
DECLARE (char *, node_search_string, "\n@@node ");

/* Extract node name from a menu item. */
extern char *glean_node_from_menu ();

/* Remember a node for later validation.  */
extern void remember_node_reference ();

/* Remember the name of the current output file.  */
extern void set_current_output_filename ();

/* Expand macros and commands in the node name and canonicalize
   whitespace in the resulting expansion.  */
extern char *expand_node_name ();

#endif /* NODE_H */
@


1.1.1.1
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@@


1.1.1.2
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: node.h,v 1.6 2002/01/16 15:52:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99, 2002 Free Software Foundation, Inc.
a41 2
  char *html_fname;	/* The HTML file to which this node is written
			   (non-NULL only for HTML splitting).  */
@


1.1.1.3
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: node.h,v 1.2 2004/04/11 17:56:47 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
a24 2
#include "xref.h"

a41 1
  int order;            /* The order of the tag, starting from zero.  */
a87 3
/* Node order counter.  */
extern int node_order;

d95 1
a95 1
extern TAG_ENTRY *find_node (char *name);
d101 1
a101 1
extern char *glean_node_from_menu (int remember_ref, enum reftype ref_type);
d104 1
a104 1
extern void remember_node_reference (char *node, int line, enum reftype type);
d107 1
a107 1
extern void set_current_output_filename (const char *fname);
d111 1
a111 11
extern char *expand_node_name (char *node);

extern int number_of_node (char *node);

extern void init_tag_table (void);
extern void write_tag_table (char *filename);
extern void free_node_references (void);
extern void free_node_node_references (void);
extern void validate_file (TAG_ENTRY *tag_table);
extern void split_file (char *filename, int size);
extern void clean_old_split_files (char *filename);
@


