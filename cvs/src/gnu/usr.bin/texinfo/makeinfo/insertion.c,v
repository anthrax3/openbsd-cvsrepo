head	1.3;
access;
symbols
	OPENBSD_6_2_BASE:1.3
	OPENBSD_6_1:1.3.0.46
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.42
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.38
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.40
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.32
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.36
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.34
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.30
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.28
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.26
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.24
	OPENBSD_5_0:1.3.0.22
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.20
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.18
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.14
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.16
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.12
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.10
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.8
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.6
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.4
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.2
	OPENBSD_4_0_BASE:1.3
	TEXINFO_4_8:1.1.1.3
	OPENBSD_3_9:1.2.0.8
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.6
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.4
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	TEXINFO_4_0:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.17.00.28.03;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.09.01.25.19;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.09.01.25.19;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.10.13.21.17;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.07.17.16.03.47;	author espie;	state Exp;
branches;
next	;


desc
@@


1.3
log
@conflict resolution
@
text
@/* insertion.c -- insertions for Texinfo.
   $Id: insertion.c,v 1.55 2004/11/11 18:34:28 karl Exp $

   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "system.h"
#include "cmds.h"
#include "defun.h"
#include "float.h"
#include "html.h"
#include "insertion.h"
#include "macro.h"
#include "makeinfo.h"
#include "multi.h"
#include "xml.h"

/* Must match list in insertion.h.  */
static char *insertion_type_names[] =
{ 
  "cartouche", "copying", "defcv", "deffn", "defivar", "defmac",
  "defmethod", "defop", "defopt", "defspec", "deftp", "deftypecv",
  "deftypefn", "deftypefun", "deftypeivar", "deftypemethod",
  "deftypeop", "deftypevar", "deftypevr", "defun", "defvar", "defvr",
  "detailmenu", "direntry", "display", "documentdescription",
  "enumerate", "example", "float", "flushleft", "flushright", "format",
  "ftable", "group", "ifclear", "ifdocbook", "ifhtml", "ifinfo",
  "ifnotdocbook", "ifnothtml", "ifnotinfo", "ifnotplaintext", "ifnottex",
  "ifnotxml", "ifplaintext", "ifset", "iftex", "ifxml", "itemize", "lisp",
  "menu", "multitable", "quotation", "rawdocbook", "rawhtml", "rawtex",
  "rawxml", "smalldisplay", "smallexample", "smallformat", "smalllisp",
  "verbatim", "table", "tex", "vtable", "titlepage", "bad_type"
};

/* All nested environments.  */
INSERTION_ELT *insertion_stack = NULL;

/* How deeply we're nested.  */
int insertion_level = 0;

/* Set to 1 if we've processed (commentary) text in a @@menu that
   wasn't part of a menu item.  */
int had_menu_commentary;

/* How to examine menu lines.  */
int in_detailmenu = 0;

/* Whether to examine menu lines.  */
int in_menu = 0;

/* Set to 1 if <p> is written in normal context. 
   Used for menu and itemize. */
int in_paragraph = 0;

/* Since an insertion is already in the stack before we reach the switch
   statement, we cannot use is_in_insertion_of_type (always returns true.) Also
   making it return the level found, and comparing it with the current level is
   no use, due to the order of stack.  */
static int float_active = 0;

/* Unsetting escape_html blindly causes text inside @@html/etc. to be escaped if
   used within a rmacro.  */
static int raw_output_block = 0;

/* Non-zero if a <dl> element has a <dt> element in it.  We use this when
   deciding whether to insert a <br> or not.  */
static int html_deflist_has_term = 0;

void
init_insertion_stack (void)
{
  insertion_stack = NULL;
}

/* Return the type of the current insertion. */
static enum insertion_type
current_insertion_type (void)
{
  return insertion_level ? insertion_stack->insertion : bad_type;
}

/* Return the string which is the function to wrap around items, or NULL
   if we're not in an environment where @@item is ok.  */
static char *
current_item_function (void)
{
  int done = 0;
  INSERTION_ELT *elt = insertion_stack;

  /* Skip down through the stack until we find an insertion with an
     itemize function defined, i.e., skip conditionals, @@cartouche, etc.  */
  while (!done && elt)
    {
      switch (elt->insertion)
        {
        /* This list should match the one in cm_item.  */
        case ifclear:
        case ifhtml:
        case ifinfo:
        case ifnothtml:
        case ifnotinfo:
        case ifnotplaintext:
        case ifnottex:
	case ifnotxml:
        case ifplaintext:
        case ifset:
        case iftex:
	case ifxml:
        case rawdocbook:
        case rawhtml:
        case rawxml:
        case rawtex:
        case tex:
        case cartouche:
          elt = elt->next;
          break;
      
        default:
          done = 1;
        }
    }

  /* item_function usually gets assigned the empty string.  */
  return done && (*elt->item_function) ? elt->item_function : NULL;
}

/* Parse the item marker function off the input.  If result is just "@@",
   change it to "@@ ", since "@@" by itself is not a command.  This makes
   "@@ ", "@@\t", and "@@\n" all the same, but their default meanings are
   the same anyway, and let's not worry about supporting redefining them.  */
static char *
get_item_function (void)
{
  char *item_function;
  char *item_loc;
  
  get_rest_of_line (0, &item_function);

  /* If the document erroneously says
       @@itemize @@bullet @@item foobar
     it's nicer to give an error up front than repeat `@@bullet expected
     braces' until we get a segmentation fault.  */
  item_loc = strstr (item_function, "@@item");
  if (item_loc)
    {
      line_error (_("@@item not allowed in argument to @@itemize"));
      *item_loc = 0;
    }

  /* If we hit the end of text in get_rest_of_line, backing up
     input pointer will cause the last character of the last line
     be pushed back onto the input, which is wrong.  */
  if (input_text_offset < input_text_length)
    backup_input_pointer ();

  if (STREQ (item_function, "@@"))
    {
      free (item_function);
      item_function = xstrdup ("@@ ");
    }

  return item_function;
}

 /* Push the state of the current insertion on the stack. */
static void
push_insertion (enum insertion_type type, char *item_function)
{
  INSERTION_ELT *new = xmalloc (sizeof (INSERTION_ELT));

  new->item_function = item_function;
  new->filling_enabled = filling_enabled;
  new->indented_fill = indented_fill;
  new->insertion = type;
  new->line_number = line_number;
  new->filename = xstrdup (input_filename);
  new->inhibited = inhibit_paragraph_indentation;
  new->in_fixed_width_font = in_fixed_width_font;
  new->next = insertion_stack;
  insertion_stack = new;
  insertion_level++;
}

 /* Pop the value on top of the insertion stack into the
    global variables. */
void
pop_insertion (void)
{
  INSERTION_ELT *temp = insertion_stack;

  if (temp == NULL)
    return;

  in_fixed_width_font = temp->in_fixed_width_font;
  inhibit_paragraph_indentation = temp->inhibited;
  filling_enabled = temp->filling_enabled;
  indented_fill = temp->indented_fill;
  free_and_clear (&(temp->item_function));
  free_and_clear (&(temp->filename));
  insertion_stack = insertion_stack->next;
  free (temp);
  insertion_level--;
}

 /* Return a pointer to the print name of this
    enumerated type. */
static const char *
insertion_type_pname (enum insertion_type type)
{
  if ((int) type < (int) bad_type)
  {
    if (type == rawdocbook)
      return "docbook";
    else if (type == rawhtml)
      return "html";
    else if (type == rawxml)
      return "xml";
    else if (type == rawtex)
      return "tex";
    else
      return insertion_type_names[(int) type];
  }
  else
    return _("Broken-Type in insertion_type_pname");
}

/* Return the insertion_type associated with NAME.
   If the type is not one of the known ones, return BAD_TYPE. */
enum insertion_type
find_type_from_name (char *name)
{
  int index = 0;
  while (index < (int) bad_type)
    {
      if (STREQ (name, insertion_type_names[index]))
        return (enum insertion_type) index;
      if (index == rawdocbook && STREQ (name, "docbook"))
        return rawdocbook;
      if (index == rawhtml && STREQ (name, "html"))
        return rawhtml;
      if (index == rawxml && STREQ (name, "xml"))
        return rawxml;
      if (index == rawtex && STREQ (name, "tex"))
        return rawtex;
      index++;
    }
  return bad_type;
}

/* Simple function to query insertion_stack to see if we are inside a given
   insertion type. */
int
is_in_insertion_of_type (int type)
{
  INSERTION_ELT *temp = insertion_stack;

  if (!insertion_level)
    return 0;

  while (temp)
    {
      if (temp->insertion == type)
        return 1;
      temp = temp->next;
    }

  return 0;
}


static int
defun_insertion (enum insertion_type type)
{
  return 0
     || (type == defcv)
     || (type == deffn)
     || (type == defivar)
     || (type == defmac)
     || (type == defmethod)
     || (type == defop)
     || (type == defopt)
     || (type == defspec)
     || (type == deftp)
     || (type == deftypecv)
     || (type == deftypefn)
     || (type == deftypefun)
     || (type == deftypeivar)
     || (type == deftypemethod)
     || (type == deftypeop)
     || (type == deftypevar)
     || (type == deftypevr)
     || (type == defun)
     || (type == defvar)
     || (type == defvr)
  ;
}

/* MAX_NS is the maximum nesting level for enumerations.  I picked 100
   which seemed reasonable.  This doesn't control the number of items,
   just the number of nested lists. */
#define max_stack_depth 100
#define ENUM_DIGITS 1
#define ENUM_ALPHA  2
typedef struct {
  int enumtype;
  int enumval;
} DIGIT_ALPHA;

DIGIT_ALPHA enumstack[max_stack_depth];
int enumstack_offset = 0;
int current_enumval = 1;
int current_enumtype = ENUM_DIGITS;
char *enumeration_arg = NULL;

static void
start_enumerating (int at, int type)
{
  if ((enumstack_offset + 1) == max_stack_depth)
    {
      line_error (_("Enumeration stack overflow"));
      return;
    }
  enumstack[enumstack_offset].enumtype = current_enumtype;
  enumstack[enumstack_offset].enumval = current_enumval;
  enumstack_offset++;
  current_enumval = at;
  current_enumtype = type;
}

static void
stop_enumerating (void)
{
  --enumstack_offset;
  if (enumstack_offset < 0)
    enumstack_offset = 0;

  current_enumval = enumstack[enumstack_offset].enumval;
  current_enumtype = enumstack[enumstack_offset].enumtype;
}

/* Place a letter or digits into the output stream. */
static void
enumerate_item (void)
{
  char temp[10];

  if (current_enumtype == ENUM_ALPHA)
    {
      if (current_enumval == ('z' + 1) || current_enumval == ('Z' + 1))
        {
          current_enumval = ((current_enumval - 1) == 'z' ? 'a' : 'A');
          warning (_("lettering overflow, restarting at %c"), current_enumval);
        }
      sprintf (temp, "%c. ", current_enumval);
    }
  else
    sprintf (temp, "%d. ", current_enumval);

  indent (output_column += (current_indent - strlen (temp)));
  add_word (temp);
  current_enumval++;
}

static void
enum_html (void)
{
  char type;
  int start;

  if (isdigit (*enumeration_arg))
    {
      type = '1';
      start = atoi (enumeration_arg);
    }
  else if (isupper (*enumeration_arg))
    {
      type = 'A';
      start = *enumeration_arg - 'A' + 1;
    }
  else
    {
      type = 'a';
      start = *enumeration_arg - 'a' + 1;
    }

  add_html_block_elt_args ("<ol type=%c start=%d>\n", type, start);
}

/* Conditionally parse based on the current command name. */
void
command_name_condition (void)
{
  char *discarder = xmalloc (8 + strlen (command));

  sprintf (discarder, "\n%cend %s", COMMAND_PREFIX, command);
  discard_until (discarder);
  discard_until ("\n");

  free (discarder);
}

/* This is where the work for all the "insertion" style
   commands is done.  A huge switch statement handles the
   various setups, and generic code is on both sides. */
void
begin_insertion (enum insertion_type type)
{
  int no_discard = 0;

  if (defun_insertion (type))
    {
      push_insertion (type, xstrdup (""));
      no_discard++;
    }
  else
    {
      push_insertion (type, get_item_function ());
    }

  switch (type)
    {
    case menu:
      if (!no_headers)
        close_paragraph ();

      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;

      if (html)
        {
          had_menu_commentary = 1;
        }
      else if (!no_headers && !xml)
        add_word ("* Menu:\n");

      if (xml)
        xml_insert_element (MENU, START);
      else
        in_fixed_width_font++;

      next_menu_item_number = 1;
      in_menu++;
      no_discard++;
      break;

    case detailmenu:
      if (!in_menu)
        {
          if (!no_headers)
            close_paragraph ();

          filling_enabled = no_indent = 0;
          inhibit_paragraph_indentation = 1;

          no_discard++;
        }

      if (xml)
        {
          xml_insert_element (DETAILMENU, START);
          skip_whitespace_and_newlines();
        }
      else
        in_fixed_width_font++;

      in_detailmenu++;
      break;

    case direntry:
      close_single_paragraph ();
      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      insert_string ("START-INFO-DIR-ENTRY\n");
      break;

    case documentdescription:
      {
        char *desc;
        int start_of_end;
        int save_fixed_width;

        discard_until ("\n"); /* ignore the @@documentdescription line */
        start_of_end = get_until ("\n@@end documentdescription", &desc);
        save_fixed_width = in_fixed_width_font;

        in_fixed_width_font = 0;
        document_description = expansion (desc, 0);
        free (desc);

        in_fixed_width_font = save_fixed_width;
        input_text_offset = start_of_end; /* go back to the @@end to match */
      }
      break;

    case copying:
        /* Save the copying text away for @@insertcopying,
           typically used on the back of the @@titlepage (for TeX) and
           the Top node (for info/html).  */
      if (input_text[input_text_offset] != '\n')
        discard_until ("\n"); /* ignore remainder of @@copying line */

        input_text_offset = get_until ("\n@@end copying", &copying_text);
        canon_white (copying_text);

      /* For info, output the copying text right away, so it will end up
         in the header of the Info file, before the first node, and thus
         get copied automatically to all the split files.  For xml, also
         output it right away since xml output is never split.
         For html, we output it specifically in html_output_head. 
         For plain text, there's no way to hide it, so the author must
          use @@insertcopying in the desired location.  */
      if (docbook)
	{
	  if (!xml_in_bookinfo)
	    {
	      xml_insert_element (BOOKINFO, START);
	      xml_in_bookinfo = 1;
	    }
          xml_insert_element (LEGALNOTICE, START);
	}

      if (!html && !no_headers)
        cm_insert_copying ();

      if (docbook)
        xml_insert_element (LEGALNOTICE, END);

      break;

    case quotation:
      /* @@quotation does filling (@@display doesn't).  */
      if (html)
        add_html_block_elt ("<blockquote>\n");
      else
        {
          /* with close_single_paragraph, we get no blank line above
             within @@copying.  */
          close_paragraph ();
          last_char_was_newline = no_indent = 0;
          indented_fill = filling_enabled = 1;
          inhibit_paragraph_indentation = 1;
        }
      current_indent += default_indentation_increment;
      if (xml)
        xml_insert_quotation (insertion_stack->item_function, START);
      else if (strlen(insertion_stack->item_function))
        execute_string ("@@b{%s:} ", insertion_stack->item_function);
      break;

    case example:
    case smallexample:
    case lisp:
    case smalllisp:
      in_fixed_width_font++;
      /* fall through */

      /* Like @@example but no fixed width font. */
    case display:
    case smalldisplay:
      /* Like @@display but without indentation. */
    case smallformat:
    case format:
      close_single_paragraph ();
      inhibit_paragraph_indentation = 1;
      filling_enabled = 0;
      last_char_was_newline = 0;

      if (html)
        /* Kludge alert: if <pre> is followed by a newline, IE3,
           mozilla, maybe others render an extra blank line before the
           pre-formatted block.  So don't output a newline.  */
        add_html_block_elt_args ("<pre class=\"%s\">", command);

      if (type != format && type != smallformat)
        {
          current_indent += example_indentation_increment;
          if (html)
            {
              /* Since we didn't put \n after <pre>, we need to insert
                 the indentation by hand.  */
              int i;
              for (i = current_indent; i > 0; i--)
                add_char (' ');
            }
        }
      break;

    case multitable:
      do_multitable ();
      break;

    case table:
    case ftable:
    case vtable:
    case itemize:
      close_single_paragraph ();
      current_indent += default_indentation_increment;
      filling_enabled = indented_fill = 1;
#if defined (INDENT_PARAGRAPHS_IN_TABLE)
      inhibit_paragraph_indentation = 0;
#else
      inhibit_paragraph_indentation = 1;
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */

      /* Make things work for losers who forget the itemize syntax. */
      if (type == itemize)
        {
          if (!(*insertion_stack->item_function))
            {
              free (insertion_stack->item_function);
              insertion_stack->item_function = xstrdup ("@@bullet");
            }
        }

      if (!*insertion_stack->item_function)
        {
          line_error (_("%s requires an argument: the formatter for %citem"),
                      insertion_type_pname (type), COMMAND_PREFIX);
        }

      if (html)
        {
          if (type == itemize)
            {
              add_html_block_elt ("<ul>\n");
              in_paragraph = 0;
            }
          else
            { /* We are just starting, so this <dl>
                 has no <dt> children yet.  */
              html_deflist_has_term = 0;
              add_html_block_elt ("<dl>\n");
            }
        }
      if (xml)
        xml_begin_table (type, insertion_stack->item_function);

      while (input_text[input_text_offset] == '\n'
          && input_text[input_text_offset+1] == '\n')
        {
          line_number++;
          input_text_offset++;
        }

      break;

    case enumerate:
      close_single_paragraph ();
      no_indent = 0;
#if defined (INDENT_PARAGRAPHS_IN_TABLE)
      inhibit_paragraph_indentation = 0;
#else
      inhibit_paragraph_indentation = 1;
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */

      current_indent += default_indentation_increment;
      filling_enabled = indented_fill = 1;

      if (html)
        {
          enum_html ();
          in_paragraph = 0;
        }

      if (xml)
        xml_begin_enumerate (enumeration_arg);
      
      if (isdigit (*enumeration_arg))
        start_enumerating (atoi (enumeration_arg), ENUM_DIGITS);
      else
        start_enumerating (*enumeration_arg, ENUM_ALPHA);
      break;

      /* @@group produces no output in info. */
    case group:
      /* Only close the paragraph if we are not inside of an
         @@example-like environment. */
      if (xml)
        xml_insert_element (GROUP, START);
      else if (!insertion_stack->next
          || (insertion_stack->next->insertion != display
              && insertion_stack->next->insertion != smalldisplay
              && insertion_stack->next->insertion != example
              && insertion_stack->next->insertion != smallexample
              && insertion_stack->next->insertion != lisp
              && insertion_stack->next->insertion != smalllisp
              && insertion_stack->next->insertion != format
              && insertion_stack->next->insertion != smallformat
              && insertion_stack->next->insertion != flushleft
              && insertion_stack->next->insertion != flushright))
        close_single_paragraph ();
      break;

    case cartouche:
      if (html)
	add_html_block_elt ("<p><table class=\"cartouche\" summary=\"cartouche\" border=\"1\"><tr><td>\n");
      if (in_menu)
        no_discard++;
      break;

    case floatenv:
      /* Cannot nest floats, so complain.  */
      if (float_active)
        {
          line_error (_("%cfloat environments cannot be nested"), COMMAND_PREFIX);
          pop_insertion ();
          break;
        }

      float_active++;

      { /* Collect data about this float.  */
        /* Example: @@float [FLOATTYPE][,XREFLABEL][,POSITION] */
        char floattype[200] = "";
        char xreflabel[200] = "";
        char position[200]  = "";
        char *text;
        char *caption;
        char *shortcaption;
        int start_of_end;
        int save_line_number = line_number;
        int save_input_text_offset = input_text_offset;
        int i;

        if (strlen (insertion_stack->item_function) > 0)
          {
            int i = 0, t = 0, c = 0;
            while (insertion_stack->item_function[i])
              {
                if (insertion_stack->item_function[i] == ',')
                  {
                    switch (t)
                      {
                      case 0:
                        floattype[c] = '\0';
                        break;
                      case 1:
                        xreflabel[c] = '\0';
                        break;
                      case 2:
                        position[c] = '\0';
                        break;
                      }
                    c = 0;
                    t++;
                    i++;
                    continue;
                  }

                switch (t)
                  {
                  case 0:
                    floattype[c] = insertion_stack->item_function[i];
                    break;
                  case 1:
                    xreflabel[c] = insertion_stack->item_function[i];
                    break;
                  case 2:
                    position[c] = insertion_stack->item_function[i];
                    break;
                  }
                c++;
                i++;
              }
          }

        skip_whitespace_and_newlines ();

        start_of_end = get_until ("\n@@end float", &text);

        /* Get also the @@caption.  */
        i = search_forward_until_pos ("\n@@caption{",
            save_input_text_offset, start_of_end);
        if (i > -1)
          {
            input_text_offset = i + sizeof ("\n@@caption{") - 1;
            get_until_in_braces ("\n@@end float", &caption);
            input_text_offset = save_input_text_offset;
          }
        else
          caption = "";

        /* ... and the @@shortcaption.  */
        i = search_forward_until_pos ("\n@@shortcaption{",
            save_input_text_offset, start_of_end);
        if (i > -1)
          {
            input_text_offset = i + sizeof ("\n@@shortcaption{") - 1;
            get_until_in_braces ("\n@@end float", &shortcaption);
            input_text_offset = save_input_text_offset;
          }
        else
          shortcaption = "";

        canon_white (xreflabel);
        canon_white (floattype);
        canon_white (position);
        canon_white (caption);
        canon_white (shortcaption);

        add_new_float (xstrdup (xreflabel),
            xstrdup (caption), xstrdup (shortcaption),
            xstrdup (floattype), xstrdup (position));

        /* Move to the start of the @@float so the contents get processed as
           usual.  */
        input_text_offset = save_input_text_offset;
        line_number = save_line_number;
      }

      if (html)
        add_html_block_elt ("<div class=\"float\">\n");
      else if (docbook)
        xml_insert_element (FLOAT, START);
      else if (xml)
        {
          xml_insert_element_with_attribute (FLOAT, START,
              "name=\"%s\"", current_float_id ());

          xml_insert_element (FLOATTYPE, START);
          execute_string ("%s", current_float_type ());
          xml_insert_element (FLOATTYPE, END);

          xml_insert_element (FLOATPOS, START);
          execute_string ("%s", current_float_position ());
          xml_insert_element (FLOATPOS, END);
        }
      else
        { /* Info */
          close_single_paragraph ();
          inhibit_paragraph_indentation = 1;
        }

      /* Anchor now.  Note that XML documents get their
         anchors with <float name="anchor"> tag.  */
      if ((!xml || docbook) && strlen (current_float_id ()) > 0)
        execute_string ("@@anchor{%s}", current_float_id ());

      break;

      /* Insertions that are no-ops in info, but do something in TeX. */
    case ifclear:
    case ifdocbook:
    case ifhtml:
    case ifinfo:
    case ifnotdocbook:
    case ifnothtml:
    case ifnotinfo:
    case ifnotplaintext:
    case ifnottex:
    case ifnotxml:
    case ifplaintext:
    case ifset:
    case iftex:
    case ifxml:
    case rawtex:
      if (in_menu)
        no_discard++;
      break;

    case rawdocbook:
    case rawhtml:
    case rawxml:
      raw_output_block++;

      if (raw_output_block > 0)
        {
          xml_no_para = 1;
          escape_html = 0;
          xml_keep_space++;
        }

      {
        /* Some deuglification for improved readability.  */
        extern int xml_in_para;
        if (xml && !xml_in_para && xml_indentation_increment > 0)
          add_char ('\n');
      }

      break;

    case defcv:
    case deffn:
    case defivar:
    case defmac:
    case defmethod:
    case defop:
    case defopt:
    case defspec:
    case deftp:
    case deftypecv:
    case deftypefn:
    case deftypefun:
    case deftypeivar:
    case deftypemethod:
    case deftypeop:
    case deftypevar:
    case deftypevr:
    case defun:
    case defvar:
    case defvr:
      inhibit_paragraph_indentation = 1;
      filling_enabled = indented_fill = 1;
      current_indent += default_indentation_increment;
      no_indent = 0;
      if (xml)
	xml_begin_definition ();
      break;

    case flushleft:
      close_single_paragraph ();
      inhibit_paragraph_indentation = 1;
      filling_enabled = indented_fill = no_indent = 0;
      if (html)
        add_html_block_elt ("<div align=\"left\">");
      break;

    case flushright:
      close_single_paragraph ();
      filling_enabled = indented_fill = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      force_flush_right++;
      if (html)
        add_html_block_elt ("<div align=\"right\">");
      break;

    case titlepage:
      xml_insert_element (TITLEPAGE, START);
      break;

    default:
      line_error ("begin_insertion internal error: type=%d", type);
    }

  if (!no_discard)
    discard_until ("\n");
}

/* Try to end the insertion with the specified TYPE.  With a value of
   `bad_type', TYPE gets translated to match the value currently on top
   of the stack.  Otherwise, if TYPE doesn't match the top of the
   insertion stack, give error. */
static void
end_insertion (int type)
{
  int temp_type;

  if (!insertion_level)
    return;

  temp_type = current_insertion_type ();

  if (type == bad_type)
    type = temp_type;

  if (type != temp_type)
    {
      line_error
        (_("`@@end' expected `%s', but saw `%s'"),
         insertion_type_pname (temp_type), insertion_type_pname (type));
      return;
    }

  pop_insertion ();

  if (xml)
    {
      switch (type)
        {
        case ifinfo:
        case documentdescription:       
          break;
        case quotation:
          xml_insert_quotation ("", END);
          break;
        case example:
          xml_insert_element (EXAMPLE, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case smallexample:
          xml_insert_element (SMALLEXAMPLE, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case lisp:
          xml_insert_element (LISP, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case smalllisp:
          xml_insert_element (SMALLLISP, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case cartouche:
          xml_insert_element (CARTOUCHE, END);
          break;
        case format:
	  if (docbook && xml_in_bookinfo && xml_in_abstract)
	    {
	      xml_insert_element (ABSTRACT, END);
	      xml_in_abstract = 0;
	    }
	  else
	    xml_insert_element (FORMAT, END);
          break;
        case smallformat:
          xml_insert_element (SMALLFORMAT, END);
          break;
        case display:
          xml_insert_element (DISPLAY, END);
          break;
        case smalldisplay:
          xml_insert_element (SMALLDISPLAY, END);
          break;
        case table:
        case ftable:
        case vtable:      
        case itemize:
          xml_end_table (type);
          break;
        case enumerate:
          xml_end_enumerate ();
          break;
        case group:
          xml_insert_element (GROUP, END);
          break;
	case titlepage:
	  xml_insert_element (TITLEPAGE, END);
	  break;
        }
    }
  switch (type)
    {
      /* Insertions which have no effect on paragraph formatting. */
    case copying:
      line_number--;
      break;

    case ifclear:
    case ifdocbook:
    case ifinfo:
    case ifhtml:
    case ifnotdocbook:
    case ifnothtml:
    case ifnotinfo:
    case ifnotplaintext:
    case ifnottex:
    case ifnotxml:
    case ifplaintext:
    case ifset:
    case iftex:
    case ifxml:
    case rawtex:
    case titlepage:
      break;

    case rawdocbook:
    case rawhtml:
    case rawxml:
      raw_output_block--;

      if (raw_output_block <= 0)
        {
          xml_no_para = 0;
          escape_html = 1;
          xml_keep_space--;
        }

      if ((xml || html) && output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      break;

    case detailmenu:
      if (xml)
        xml_insert_element (DETAILMENU, END);

      in_detailmenu--;          /* No longer hacking menus. */
      if (!in_menu)
        {
          if (!no_headers)
            close_insertion_paragraph ();
        }
      break;

    case direntry:              /* Eaten if html. */
      insert_string ("END-INFO-DIR-ENTRY\n\n");
      close_insertion_paragraph ();
      break;

    case documentdescription:
      if (xml)
        insert_string (document_description);
        xml_insert_element (DOCUMENTDESCRIPTION, END);
      break;
      
    case menu:
      in_menu--;                /* No longer hacking menus. */
      if (html && !no_headers)
        add_html_block_elt ("</ul>\n");
      else if (!no_headers && !xml)
        close_insertion_paragraph ();
      break;

    case multitable:
      end_multitable ();
      break;

    case enumerate:
      stop_enumerating ();
      close_insertion_paragraph ();
      current_indent -= default_indentation_increment;
      if (html)
        add_html_block_elt ("</ol>\n");
      break;

    case flushleft:
      if (html)
        add_html_block_elt ("</div>\n");
      close_insertion_paragraph ();
      break;

    case cartouche:
      if (html)
	add_html_block_elt ("</td></tr></table>\n");
      close_insertion_paragraph ();
      break;

    case group:
      if (!xml || docbook)
        close_insertion_paragraph ();
      break;

    case floatenv:
      if (xml)
        xml_insert_element (FLOAT, END);
      else
        {
          if (html)
            add_html_block_elt ("<p><strong class=\"float-caption\">");
          else
            close_paragraph ();

          no_indent = 1;

          /* Legend:
               1) @@float Foo,lbl & no caption:    Foo 1.1
               2) @@float Foo & no caption:        Foo
               3) @@float ,lbl & no caption:       1.1
               4) @@float & no caption:                    */

          if (!xml && !html)
            indent (current_indent);

          if (strlen (current_float_type ()))
            execute_string ("%s", current_float_type ());

          if (strlen (current_float_id ()) > 0)
            {
              if (strlen (current_float_type ()) > 0)
                add_char (' ');

              add_word (current_float_number ());
            }

          if (strlen (current_float_title ()) > 0)
            {
              if (strlen (current_float_type ()) > 0
                  || strlen (current_float_id ()) > 0)
                insert_string (": ");

              execute_string ("%s", current_float_title ());
            }

          /* Indent the following paragraph. */
          inhibit_paragraph_indentation = 0;

          if (html)
            add_word ("</strong></p></div>\n");
          else
            close_paragraph ();
        }
      float_active--;
      break;

    case format:
    case smallformat:
    case display:
    case smalldisplay:
    case example:
    case smallexample:
    case lisp:
    case smalllisp:
    case quotation:
      /* @@format and @@smallformat are the only fixed_width insertion
         without a change in indentation. */
      if (type != format && type != smallformat && type != quotation)
        current_indent -= example_indentation_increment;
      else if (type == quotation)
        current_indent -= default_indentation_increment;

      if (html)
        { /* The complex code in close_paragraph that kills whitespace
             does not function here, since we've inserted non-whitespace
             (the </whatever>) before it.  The indentation already got
             inserted at the end of the last example line, so we have to
             delete it, or browsers wind up showing an extra blank line.  */
          kill_self_indent (default_indentation_increment);
          add_html_block_elt (type == quotation
              ? "</blockquote>\n" : "</pre>\n");
        }

      /* The ending of one of these insertions always marks the
         start of a new paragraph, except for the XML output. */
      if (!xml || docbook)
        close_insertion_paragraph ();

      /* </pre> closes paragraph without messing with </p>.  */
      if (html && type != quotation)
          paragraph_is_open = 0;
      break;

    case table:
    case ftable:
    case vtable:
      current_indent -= default_indentation_increment;
      if (html)
        add_html_block_elt ("</dl>\n");
      close_insertion_paragraph ();
      break;

    case itemize:
      current_indent -= default_indentation_increment;
      if (html)
        add_html_block_elt ("</ul>\n");
      close_insertion_paragraph ();
      break;

    case flushright:
      force_flush_right--;
      if (html)
        add_html_block_elt ("</div>\n");
      close_insertion_paragraph ();
      break;

    /* Handle the @@defun insertions with this default clause. */
    default:
      {
        int base_type;

        if (type < defcv || type > defvr)
          line_error ("end_insertion internal error: type=%d", type);
  
        base_type = get_base_type (type);
        switch (base_type)
          {
          case deffn:
          case defvr:
          case deftp:
          case deftypecv:
          case deftypefn:
          case deftypevr:
          case defcv:
          case defop:
          case deftypemethod:
          case deftypeop:
          case deftypeivar:
            if (html)
              {
                if (paragraph_is_open)
                  add_html_block_elt ("</p>");
                /* close the div and blockquote which has been opened in defun.c */
                if (!rollback_empty_tag ("blockquote"))
                  add_html_block_elt ("</blockquote>");
                add_html_block_elt ("</div>\n");
              }
	    if (xml)
	      xml_end_definition ();
            break;
          } /* switch (base_type)... */
  
        current_indent -= default_indentation_increment;
        close_insertion_paragraph ();
      }
      break;
      
    }

  if (current_indent < 0)
    line_error ("end_insertion internal error: current indent=%d",
                current_indent);
}

/* Insertions cannot cross certain boundaries, such as node beginnings.  In
   code that creates such boundaries, you should call `discard_insertions'
   before doing anything else.  It prints the errors for you, and cleans up
   the insertion stack.

   With nonzero SPECIALS_OK argument, allows unmatched
   @@if... conditionals, otherwise not.  This is because conditionals can
   cross node boundaries.  Always happens with the @@top node, for example.  */
void
discard_insertions (int specials_ok)
{
  int real_line_number = line_number;
  while (insertion_stack)
    {
      if (specials_ok
          && ((ifclear <= insertion_stack->insertion
               && insertion_stack->insertion <= iftex)
              || insertion_stack->insertion == rawdocbook
              || insertion_stack->insertion == rawhtml
              || insertion_stack->insertion == rawxml
              || insertion_stack->insertion == rawtex))
        break;
      else
        {
          const char *offender = insertion_type_pname (insertion_stack->insertion);

          file_line_error (insertion_stack->filename,
                           insertion_stack->line_number,
                           _("No matching `%cend %s'"), COMMAND_PREFIX,
                           offender);
          pop_insertion ();
        }
    }
  line_number = real_line_number;
}

/* Insertion (environment) commands.  */

void
cm_quotation (void)
{
  /* We start the blockquote element in the insertion.  */
  begin_insertion (quotation);
}

void
cm_example (void)
{
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

  if (xml)
    {
      /* Rollback previous newlines.  These occur between
         </para> and <example>.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;

      xml_insert_element (EXAMPLE, START);

      /* Make sure example text is starting on a new line
         for improved readability.  */
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (example);
}

void
cm_smallexample (void)
{
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLEXAMPLE, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (smallexample);
}

void
cm_lisp (void)
{
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (LISP, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (lisp);
}

void
cm_smalllisp (void)
{
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLLISP, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (smalllisp);
}

void
cm_cartouche (void)
{
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (CARTOUCHE);

  if (xml)
    xml_insert_element (CARTOUCHE, START);
  begin_insertion (cartouche);
}

void
cm_copying (void)
{
  begin_insertion (copying);
}

/* Not an insertion, despite the name, but it goes with cm_copying.  */
void
cm_insert_copying (void)
{
  if (!copying_text)
    {
      warning ("@@copying not used before %s", command);
      return;
    }

  execute_string ("%s", copying_text);

  if (!xml && !html)
    {
      add_word ("\n\n");
      /* Update output_position so that the node positions in the tag
         tables will take account of the copying text.  */
      flush_output ();
    }
}

void
cm_format (void)
{
  if (xml)
    {
      if (docbook && xml_in_bookinfo)
	{
	  xml_insert_element (ABSTRACT, START);
	  xml_in_abstract = 1;
	}
      else
        {
          /* See cm_example comments about newlines.  */
          if (output_paragraph[output_paragraph_offset-1] == '\n')
            output_paragraph_offset--;
          xml_insert_element (FORMAT, START);
          if (docbook)
            add_char ('\n');
        }
    }
  begin_insertion (format);
}

void
cm_smallformat (void)
{
  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLFORMAT, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (smallformat);
}

void
cm_display (void)
{
  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (DISPLAY, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (display);
}

void
cm_smalldisplay (void)
{
  if (xml)
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLDISPLAY, START);
      if (docbook)
        add_char ('\n');
    }

  begin_insertion (smalldisplay);
}

void
cm_direntry (void)
{
  if (html || xml || no_headers)
    command_name_condition ();
  else
    begin_insertion (direntry);
}

void
cm_documentdescription (void)
{
  if (html)
    begin_insertion (documentdescription);

  else if (xml)
    {
      xml_insert_element (DOCUMENTDESCRIPTION, START);
      begin_insertion (documentdescription);
    }

  else
    command_name_condition ();
}


void
cm_itemize (void)
{
  begin_insertion (itemize);
}

/* Start an enumeration insertion of type TYPE.  If the user supplied
   no argument on the line, then use DEFAULT_STRING as the initial string. */
static void
do_enumeration (int type, char *default_string)
{
  get_until_in_line (0, ".", &enumeration_arg);
  canon_white (enumeration_arg);

  if (!*enumeration_arg)
    {
      free (enumeration_arg);
      enumeration_arg = xstrdup (default_string);
    }

  if (!isdigit (*enumeration_arg) && !isletter (*enumeration_arg))
    {
      warning (_("%s requires letter or digit"), insertion_type_pname (type));

      switch (type)
        {
        case enumerate:
          default_string = "1";
          break;
        }
      enumeration_arg = xstrdup (default_string);
    }
  begin_insertion (type);
}

void
cm_enumerate (void)
{
  do_enumeration (enumerate, "1");
}

/*  Handle verbatim environment:
    find_end_verbatim == 0:  process until end of file
    find_end_verbatim != 0:  process until 'COMMAND_PREFIXend verbatim'
                             or end of file

  We cannot simply copy input stream onto output stream; as the
  verbatim environment may be encapsulated in an @@example environment,
  for example. */
void
handle_verbatim_environment (int find_end_verbatim)
{
  int character;
  int seen_end = 0;
  int save_filling_enabled = filling_enabled;
  int save_inhibit_paragraph_indentation = inhibit_paragraph_indentation;
  int save_escape_html = escape_html;

  if (!insertion_stack)
    close_single_paragraph (); /* no blank lines if not at outer level */
  inhibit_paragraph_indentation = 1;
  filling_enabled = 0;
  in_fixed_width_font++;
  last_char_was_newline = 0;

  /* No indentation: this is verbatim after all
     If you want indent, enclose @@verbatim in @@example
       current_indent += default_indentation_increment;
   */

  if (html)
    { /* If inside @@example, we'll be preceded by the indentation
         already.  Browsers will ignore those spaces because we're about
         to start another <pre> (don't ask me).  So, wipe them out for
         cleanliness, and re-insert.  */
      int i;
      kill_self_indent (default_indentation_increment);
      add_html_block_elt ("<pre class=\"verbatim\">");
      for (i = current_indent; i > 0; i--)
        add_char (' ');
    }
  else if (xml)
    {
      xml_insert_element (VERBATIM, START);
      escape_html = 0;
      add_word ("<![CDATA[");
    }

  while (input_text_offset < input_text_length)
    {
      character = curchar ();

      if (character == '\n')
        line_number++;

      /* Assume no newlines in END_VERBATIM. */
      else if (find_end_verbatim && (character == COMMAND_PREFIX) /* @@ */
          && (input_text_length - input_text_offset > sizeof (END_VERBATIM))
          && !strncmp (&input_text[input_text_offset+1], END_VERBATIM,
                       sizeof (END_VERBATIM)-1))
        {
          input_text_offset += sizeof (END_VERBATIM);
          seen_end = 1;
          break;
        }

      if (html && character == '&' && escape_html)
        add_word ("&amp;");
      else if (html && character == '<' && escape_html)
        add_word ("&lt;");
      else
        add_char (character);

      input_text_offset++;
    }

  if (find_end_verbatim && !seen_end)
    warning (_("end of file inside verbatim block"));

  if (html)
    { /* See comments in example case above.  */
      kill_self_indent (default_indentation_increment);
      add_word ("</pre>");
    }
  else if (xml)
    {
      add_word ("]]>");
      xml_insert_element (VERBATIM, END);
      escape_html = save_escape_html;
    }
  
  in_fixed_width_font--;
  filling_enabled = save_filling_enabled;
  inhibit_paragraph_indentation = save_inhibit_paragraph_indentation;
}

void
cm_verbatim (void)
{
  handle_verbatim_environment (1);
}

void
cm_table (void)
{
  begin_insertion (table);
}

void
cm_multitable (void)
{
  begin_insertion (multitable); /* @@@@ */
}

void
cm_ftable (void)
{
  begin_insertion (ftable);
}

void
cm_vtable (void)
{
  begin_insertion (vtable);
}

void
cm_group (void)
{
  begin_insertion (group);
}

/* Insert raw HTML (no escaping of `<' etc.). */
void
cm_html (int arg)
{
  if (process_html)
    begin_insertion (rawhtml);
  else
    command_name_condition ();
}

void
cm_xml (int arg)
{
  if (process_xml)
    begin_insertion (rawxml);
  else
    command_name_condition ();
}

void
cm_docbook (int arg)
{
  if (process_docbook)
    begin_insertion (rawdocbook);
  else
    command_name_condition ();
}

void
cm_ifdocbook (void)
{
  if (process_docbook)
    begin_insertion (ifdocbook);
  else
    command_name_condition ();
}

void
cm_ifnotdocbook (void)
{
  if (!process_docbook)
    begin_insertion (ifnotdocbook);
  else
    command_name_condition ();
}

void
cm_ifhtml (void)
{
  if (process_html)
    begin_insertion (ifhtml);
  else
    command_name_condition ();
}

void
cm_ifnothtml (void)
{
  if (!process_html)
    begin_insertion (ifnothtml);
  else
    command_name_condition ();
}


void
cm_ifinfo (void)
{
  if (process_info)
    begin_insertion (ifinfo);
  else
    command_name_condition ();
}

void
cm_ifnotinfo (void)
{
  if (!process_info)
    begin_insertion (ifnotinfo);
  else
    command_name_condition ();
}


void
cm_ifplaintext (void)
{
  if (process_plaintext)
    begin_insertion (ifplaintext);
  else
    command_name_condition ();
}

void
cm_ifnotplaintext (void)
{
  if (!process_plaintext)
    begin_insertion (ifnotplaintext);
  else
    command_name_condition ();
}


void
cm_tex (void)
{
  if (process_tex)
    begin_insertion (rawtex);
  else
    command_name_condition ();
}

void
cm_iftex (void)
{
  if (process_tex)
    begin_insertion (iftex);
  else
    command_name_condition ();
}

void
cm_ifnottex (void)
{
  if (!process_tex)
    begin_insertion (ifnottex);
  else
    command_name_condition ();
}

void
cm_ifxml (void)
{
  if (process_xml)
    begin_insertion (ifxml);
  else
    command_name_condition ();
}

void
cm_ifnotxml (void)
{
  if (!process_xml)
    begin_insertion (ifnotxml);
  else
    command_name_condition ();
}


/* Generic xrefable block with a caption.  */
void
cm_float (void)
{
  begin_insertion (floatenv);
}

void
cm_caption (int arg)
{
  char *temp;

  /* This is a no_op command for most formats, as we handle it during @@float
     insertion.  For XML though, we handle it here to keep document structure
     as close as possible, to the Texinfo source.  */

  /* Everything is already handled at START.  */
  if (arg == END)
    return;

  /* Check if it's mislocated.  */
  if (current_insertion_type () != floatenv)
    line_error (_("@@%s not meaningful outside `@@float' environment"), command);

  get_until_in_braces ("\n@@end float", &temp);

  if (xml)
    {
      int elt = STREQ (command, "shortcaption") ? SHORTCAPTION : CAPTION;
      xml_insert_element (elt, START);
      if (!docbook)
        execute_string ("%s", temp);
      xml_insert_element (elt, END);
    }

  free (temp);
}

/* Begin an insertion where the lines are not filled or indented. */
void
cm_flushleft (void)
{
  begin_insertion (flushleft);
}

/* Begin an insertion where the lines are not filled, and each line is
   forced to the right-hand side of the page. */
void
cm_flushright (void)
{
  begin_insertion (flushright);
}

void
cm_menu (void)
{
  if (current_node == NULL && !macro_expansion_output_stream)
    {
      warning (_("@@menu seen before first @@node, creating `Top' node"));
      warning (_("perhaps your @@top node should be wrapped in @@ifnottex rather than @@ifinfo?"));
      /* Include @@top command so we can construct the implicit node tree.  */
      execute_string ("@@node top\n@@top Top\n");
    }
  begin_insertion (menu);
}

void
cm_detailmenu (void)
{
  if (current_node == NULL && !macro_expansion_output_stream)
    { /* Problems anyway, @@detailmenu should always be inside @@menu.  */
      warning (_("@@detailmenu seen before first node, creating `Top' node"));
      execute_string ("@@node top\n@@top Top\n");
    }
  begin_insertion (detailmenu);
}

/* Title page commands. */

void
cm_titlepage (void)
{
  titlepage_cmd_present = 1;
  if (xml && !docbook)
    begin_insertion (titlepage);
  else
    command_name_condition ();
}

void
cm_author (void)
{
  char *rest;
  get_rest_of_line (1, &rest);

  if (is_in_insertion_of_type (quotation))
    {
      if (html)
        add_word_args ("&mdash; %s", rest);
      else if (docbook)
        {
          /* FIXME Ideally, we should use an attribution element,
             but they are supposed to be at the start of quotation
             blocks.  So to avoid looking ahead mess, let's just
             use mdash like HTML for now.  */
          xml_insert_entity ("mdash");
          add_word (rest);
        }
      else if (xml)
        {
          xml_insert_element (AUTHOR, START);
          add_word (rest);
          xml_insert_element (AUTHOR, END);
        }
      else
        add_word_args ("-- %s", rest);
    }
  else if (is_in_insertion_of_type (titlepage))
    {
      if (xml && !docbook)
        {
          xml_insert_element (AUTHOR, START);
          add_word (rest);
          xml_insert_element (AUTHOR, END);
        }
    }
  else
    line_error (_("@@%s not meaningful outside `@@titlepage' and `@@quotation' environments"),
        command);

  free (rest);
}

void
cm_titlepage_cmds (void)
{
  char *rest;

  get_rest_of_line (1, &rest);

  if (!is_in_insertion_of_type (titlepage))
    line_error (_("@@%s not meaningful outside `@@titlepage' environment"),
        command);

  if (xml && !docbook)
    {
      int elt = 0;

      if (STREQ (command, "title"))
        elt = BOOKTITLE;
      else if (STREQ (command, "subtitle"))
        elt = BOOKSUBTITLE;

      xml_insert_element (elt, START);
      add_word (rest);
      xml_insert_element (elt, END);
    }

    free (rest);
}

/* End existing insertion block. */
void
cm_end (void)
{
  char *temp;
  int type;

  get_rest_of_line (0, &temp);

  if (!insertion_level)
    {
      line_error (_("Unmatched `%c%s'"), COMMAND_PREFIX, command);
      return;
    }

  if (temp[0] == 0)
    line_error (_("`%c%s' needs something after it"), COMMAND_PREFIX, command);

  type = find_type_from_name (temp);

  if (type == bad_type)
    {
      line_error (_("Bad argument `%s' to `@@%s', using `%s'"),
           temp, command, insertion_type_pname (current_insertion_type ()));
    }
  if (xml && type == menu) /* fixme */
    {
      xml_end_menu ();
    }
  end_insertion (type);
  free (temp);
}

/* @@itemx, @@item. */

static int itemx_flag = 0;

/* Return whether CMD takes a brace-delimited {arg}.  */
int
command_needs_braces (char *cmd)
{
  int i;
  for (i = 0; command_table[i].name; i++)
    {
      if (STREQ (command_table[i].name, cmd))
        return command_table[i].argument_in_braces == BRACE_ARGS;
    }

  return 0; /* macro or alias */
}


void
cm_item (void)
{
  char *rest_of_line, *item_func;

  /* Can only hack "@@item" while inside of an insertion. */
  if (insertion_level)
    {
      INSERTION_ELT *stack = insertion_stack;
      int original_input_text_offset;

      skip_whitespace ();
      original_input_text_offset = input_text_offset;

      get_rest_of_line (0, &rest_of_line);
      item_func = current_item_function ();

    /* Do the right thing depending on which insertion function is active. */
    switch_top:
      switch (stack->insertion)
        {
        case multitable:
          multitable_item ();
          /* Support text directly after the @@item.  */
          if (*rest_of_line)
            {
              line_number--;
              input_text_offset = original_input_text_offset;
            }
          break;

        case ifclear:
        case ifhtml:
        case ifinfo:
        case ifnothtml:
        case ifnotinfo:
        case ifnotplaintext:
        case ifnottex:
	case ifnotxml:
        case ifplaintext:
        case ifset:
        case iftex:
	case ifxml:
        case rawdocbook:
        case rawhtml:
        case rawxml:
        case rawtex:
        case tex:
        case cartouche:
          stack = stack->next;
          if (!stack)
            goto no_insertion;
          else
            goto switch_top;
          break;

        case menu:
        case quotation:
        case example:
        case smallexample:
        case lisp:
        case smalllisp:
        case format:
        case smallformat:
        case display:
        case smalldisplay:
        case group:
          line_error (_("@@%s not meaningful inside `@@%s' block"),
                      command,
                      insertion_type_pname (current_insertion_type ()));
          break;

        case itemize:
        case enumerate:
          if (itemx_flag)
            {
              line_error (_("@@itemx not meaningful inside `%s' block"),
                          insertion_type_pname (current_insertion_type ()));
            }
          else
            {
              if (html)
                add_html_block_elt ("<li>");
              else if (xml)
                xml_begin_item ();
              else
                {
                  start_paragraph ();
                  kill_self_indent (-1);
                  filling_enabled = indented_fill = 1;

                  if (current_item_function ())
                    {
                      output_column = current_indent - 2;
                      indent (output_column);

                      /* The item marker can be given with or without
                         braces -- @@bullet and @@bullet{} are both ok.
                         Or it might be something that doesn't take
                         braces at all, such as "o" or "#" or "@@ ".
                         Thus, only supply braces if the item marker is
                         a command, they haven't supplied braces
                         themselves, and we know it needs them.  */
                      if (item_func && *item_func)
                        {
                          if (*item_func == COMMAND_PREFIX
                              && item_func[strlen (item_func) - 1] != '}'
                              && command_needs_braces (item_func + 1))
                            execute_string ("%s{}", item_func);
                          else
                            execute_string ("%s", item_func);
                        }
                      insert (' ');
                      output_column++;
                    }
                  else
                    enumerate_item ();

                  /* Special hack.  This makes `close_paragraph' a no-op until
                     `start_paragraph' has been called. */
                  must_start_paragraph = 1;
                }

              /* Handle text directly after the @@item.  */
              if (*rest_of_line)
                {
                  line_number--;
                  input_text_offset = original_input_text_offset;
                }
            }
          break;

        case table:
        case ftable:
        case vtable:
          if (html)
            { /* If nothing has been output since the last <dd>,
                 remove the empty <dd> element.  Some browsers render
                 an extra empty line for <dd><dt>, which makes @@itemx
                 conversion look ugly.  */
              rollback_empty_tag ("dd");

              /* Force the browser to render one blank line before
                 each new @@item in a table.  But don't do that if
                 this is the first <dt> after the <dl>, or if we are
                 converting @@itemx.

                 Note that there are some browsers which ignore <br>
                 in this context, but I cannot find any way to force
                 them all render exactly one blank line.  */
              if (!itemx_flag && html_deflist_has_term)
                add_html_block_elt ("<br>");

              /* We are about to insert a <dt>, so this <dl> has a term.
                 Feel free to insert a <br> next time. :)  */
              html_deflist_has_term = 1;
   
              add_html_block_elt ("<dt>");
              if (item_func && *item_func)
                execute_string ("%s{%s}", item_func, rest_of_line);
              else
                execute_string ("%s", rest_of_line);

              if (current_insertion_type () == ftable)
                execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);

              if (current_insertion_type () == vtable)
                execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

              add_html_block_elt ("<dd>");
            }
          else if (xml) /* && docbook)*/ /* 05-08 */
            {
              xml_begin_table_item ();

              if (!docbook && current_insertion_type () == ftable)
                execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);

              if (!docbook && current_insertion_type () == vtable)
                execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

              if (item_func && *item_func)
                execute_string ("%s{%s}", item_func, rest_of_line);
              else
                execute_string ("%s", rest_of_line);
              xml_continue_table_item ();
            }
          else
            {
              /* We need this to determine if we have two @@item's in a row
                 (see test just below).  */
              static int last_item_output_position = 0;

              /* Get rid of extra characters. */
              kill_self_indent (-1);

              /* If we have one @@item followed directly by another @@item,
                 we need to insert a blank line.  This is not true for
                 @@itemx, though.  */
              if (!itemx_flag && last_item_output_position == output_position)
                insert ('\n');

              /* `close_paragraph' almost does what we want.  The problem
                 is when paragraph_is_open, and last_char_was_newline, and
                 the last newline has been turned into a space, because
                 filling_enabled. I handle it here. */
              if (last_char_was_newline && filling_enabled &&
                  paragraph_is_open)
                insert ('\n');
              close_paragraph ();

#if defined (INDENT_PARAGRAPHS_IN_TABLE)
              /* Indent on a new line, but back up one indentation level. */
              {
                int save = inhibit_paragraph_indentation;
                inhibit_paragraph_indentation = 1;
                /* At this point, inserting any non-whitespace character will
                   force the existing indentation to be output. */
                add_char ('i');
                inhibit_paragraph_indentation = save;
              }
#else /* !INDENT_PARAGRAPHS_IN_TABLE */
              add_char ('i');
#endif /* !INDENT_PARAGRAPHS_IN_TABLE */

              output_paragraph_offset--;
              kill_self_indent (default_indentation_increment + 1);

              /* Add item's argument to the line. */
              filling_enabled = 0;
              if (item_func && *item_func)
                execute_string ("%s{%s}", item_func, rest_of_line);
              else
                execute_string ("%s", rest_of_line);

              if (current_insertion_type () == ftable)
                execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);
              else if (current_insertion_type () == vtable)
                execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

              /* Start a new line, and let start_paragraph ()
                 do the indenting of it for you. */
              close_single_paragraph ();
              indented_fill = filling_enabled = 1;
              last_item_output_position = output_position;
            }
        }
      free (rest_of_line);
    }
  else
    {
    no_insertion:
      line_error (_("%c%s found outside of an insertion block"),
                  COMMAND_PREFIX, command);
    }
}

void
cm_itemx (void)
{
  itemx_flag++;
  cm_item ();
  itemx_flag--;
}

int headitem_flag = 0;

void
cm_headitem (void)
{
  headitem_flag = 1;
  cm_item ();
}
@


1.2
log
@strncmp works only if starting after start of buffer.
found thx to mmap malloc.

okay millert@@ deraadt@@
@
text
@d2 1
a2 1
   $Id: insertion.c,v 1.1.1.2 2002/06/10 13:21:17 espie Exp $
d4 2
a5 1
   Copyright (C) 1998, 99, 2000, 01, 02 Free Software Foundation, Inc.
d24 2
d29 1
d36 11
a46 10
  "defmethod", "defop", "defopt", "defspec", "deftp", "deftypefn",
  "deftypefun", "deftypeivar", "deftypemethod", "deftypeop",
  "deftypevar", "deftypevr", "defun", "defvar", "defvr", "detailmenu",
  "direntry", "display", "documentdescription", "enumerate", "example",
  "flushleft", "flushright", "format", "ftable", "group", "ifclear",
  "ifhtml", "ifinfo", "ifnothtml", "ifnotinfo", "ifnotplaintext", "ifnottex",
  "ifplaintext", "ifset", "iftex", "itemize", "lisp", "menu",
  "multitable", "quotation", "rawhtml", "rawtex", "smalldisplay",
  "smallexample", "smallformat", "smalllisp", "verbatim", "table",
  "tex", "vtable", "bad_type"
d69 13
a81 3
static const char dl_tag[] = "<dl>\n";
extern void cm_insert_copying ();

d84 1
a84 1
init_insertion_stack ()
d91 1
a91 1
current_insertion_type ()
d99 1
a99 1
current_item_function ()
d118 1
d122 2
d125 1
d129 2
a130 2
	  elt = elt->next;
	  break;
d145 2
a146 2
char *
get_item_function ()
d149 2
d153 11
d180 2
a181 4
void
push_insertion (type, item_function)
     enum insertion_type type;
     char *item_function;
d201 1
a201 1
pop_insertion ()
d221 2
a222 3
char *
insertion_type_pname (type)
     enum insertion_type type;
d225 12
a236 1
    return insertion_type_names[(int) type];
d244 1
a244 2
find_type_from_name (name)
     char *name;
d251 2
d255 2
d264 2
d267 20
a286 2
defun_insertion (type)
     enum insertion_type type;
d298 1
d329 2
a330 3
void
start_enumerating (at, type)
     int at, type;
d344 2
a345 2
void
stop_enumerating ()
d356 2
a357 2
void
enumerate_item ()
d379 1
a379 1
enum_html ()
d400 1
a400 1
  add_word_args ("<ol type=%c start=%d>\n", type, start);
d405 1
a405 1
command_name_condition ()
d420 1
a420 2
begin_insertion (type)
     enum insertion_type type;
d451 3
a453 1
	xml_insert_element (MENU, START);
a456 1
      in_fixed_width_font++;
d472 8
a479 1
      in_fixed_width_font++;
a509 1
      {
d513 1
a513 3
        char *text;
        int start_of_end;

a514 1
        start_of_end = get_until ("\n@@end copying", &text);
d516 2
a517 3
        /* include all the output-format-specific markup.  */
        copying_text = full_expansion (text, 0);
        free (text);
a518 3
        input_text_offset = start_of_end; /* go back to the @@end to match */
      }
      
d526 10
d538 4
d543 1
a543 1
      
d547 1
a547 1
        add_word ("<blockquote>\n");
d558 4
a563 2
    case display:
    case smalldisplay:
d568 6
a578 1
      in_fixed_width_font++;
d583 4
a586 4
        /* Kludge alert: if <pre> is followed by a newline, IE3
           renders an extra blank line before the pre-formatted block.
           Other browsers seem to not mind one way or the other.  */
        add_word ("<br><pre>");
d589 11
a599 1
        current_indent += default_indentation_increment;
d638 4
a641 4
	    {
	      add_word ("<ul>\n");
	      in_paragraph = 0;
	    }
d643 5
a647 1
            add_word (dl_tag);
d650 9
a658 1
	xml_begin_table (type, insertion_stack->item_function);
d674 4
a677 1
        enum_html ();
d680 1
a680 1
	xml_begin_enumerate (enumeration_arg);
d688 1
a688 1
      /* @@group does nothing special in makeinfo. */
d693 1
a693 1
	xml_insert_element (GROUP, START);
d708 147
a855 1
    case cartouche:
d857 1
d860 1
d865 1
d869 1
d875 1
d877 17
a893 1
      escape_html = 0;
d905 1
d920 2
d929 1
a929 1
	add_word ("<div align=\"left\">");
d938 5
a942 1
	add_word ("<div align=\"right\">");
a946 1

d957 2
a958 3
void
end_insertion (type)
     enum insertion_type type;
d960 1
a960 1
  enum insertion_type temp_type;
d983 62
a1044 3
	{
	case ifinfo:
	case documentdescription:	
d1046 1
a1046 46
	case copying:
	  xml_insert_element (COPYING, END);
	  break;
	case quotation:
	  xml_insert_element (QUOTATION, END);
	  break;
	case example:
	  xml_insert_element (EXAMPLE, END);
	  break;
	case smallexample:
	  xml_insert_element (SMALLEXAMPLE, END);
	  break;
	case lisp:
	  xml_insert_element (LISP, END);
	  break;
	case smalllisp:
	  xml_insert_element (SMALLLISP, END);
	  break;
	case cartouche:
	  xml_insert_element (CARTOUCHE, END);
	  break;
	case format:
	  xml_insert_element (FORMAT, END);
	  break;
	case smallformat:
	  xml_insert_element (SMALLFORMAT, END);
	  break;
	case display:
	  xml_insert_element (DISPLAY, END);
	  break;
	case smalldisplay:
	  xml_insert_element (SMALLDISPLAY, END);
	  break;
	case table:
	case ftable:
	case vtable:	  
	case itemize:
	  xml_end_table (type);
	  break;
	case enumerate:
	  xml_end_enumerate (type);
	  break;
	case group:
	  xml_insert_element (GROUP, END);
	  break;
	}
d1052 3
a1054 1
    case documentdescription:
d1056 1
d1059 1
d1064 1
d1068 1
d1070 1
d1073 1
d1075 12
a1086 1
      escape_html = 1;
d1090 3
d1106 6
d1114 3
a1116 3
      if (html)
        add_word ("</ul>\n");
      else if (!no_headers)
d1129 1
a1129 1
        add_word ("</ol>\n");
d1134 1
a1134 1
	add_word ("</div>\n");
a1137 1
    case group:
d1139 2
d1144 57
d1212 3
a1214 1
      if (type != format && type != smallformat)
d1218 9
a1226 1
        add_word (type == quotation ? "</blockquote>\n" : "</pre>\n");
d1229 7
a1235 2
         start of a new paragraph. */
      close_insertion_paragraph ();
d1243 2
a1244 1
        add_word ("</dl>\n");
d1250 1
a1250 1
        add_word ("</ul>\n");
d1257 1
a1257 1
	add_word ("</div>\n");
d1264 1
a1264 1
	enum insertion_type base_type;
d1275 1
d1280 14
a1293 6
	  case deftypemethod:
	  case deftypeop:
	  case deftypeivar:
	    if (html)
	      /* close the tables which has been opened in defun.c */
              add_word ("</td></tr>\n</table>\n");
d1318 1
a1318 2
discard_insertions (specials_ok)
    int specials_ok;
d1326 1
d1328 1
d1333 1
a1333 1
          char *offender = insertion_type_pname (insertion_stack->insertion);
d1336 3
a1338 3
			   insertion_stack->line_number,
			   _("No matching `%cend %s'"), COMMAND_PREFIX,
			   offender);
d1348 1
a1348 1
cm_quotation ()
d1350 1
a1350 2
  if (xml)
    xml_insert_element (QUOTATION, START);
d1355 1
a1355 1
cm_example ()
d1357 3
d1361 14
a1374 1
    xml_insert_element (EXAMPLE, START);
d1379 1
a1379 1
cm_smallexample ()
d1381 3
d1385 9
a1393 1
    xml_insert_element (SMALLEXAMPLE, START);
d1398 1
a1398 1
cm_lisp ()
d1400 3
d1404 9
a1412 1
    xml_insert_element (LISP, START);
d1417 1
a1417 1
cm_smalllisp ()
d1419 3
d1423 9
a1431 1
    xml_insert_element (SMALLLISP, START);
d1436 1
a1436 1
cm_cartouche ()
d1438 3
d1447 1
a1447 1
cm_copying ()
a1448 2
  if (xml)
    xml_insert_element (COPYING, START);
d1454 1
a1454 1
cm_insert_copying ()
d1456 14
a1469 5
  if (copying_text)
    { /* insert_string rather than add_word because we've already done
         full expansion on copying_text when we saved it.  */
      insert_string (copying_text);
      insert ('\n');
d1474 1
a1474 1
cm_format ()
d1477 16
a1492 1
    xml_insert_element (FORMAT, START);
d1497 1
a1497 1
cm_smallformat ()
d1500 9
a1508 1
    xml_insert_element (SMALLFORMAT, START);
d1513 1
a1513 1
cm_display ()
d1516 9
a1524 1
    xml_insert_element (DISPLAY, START);
d1529 1
a1529 1
cm_smalldisplay ()
d1532 9
a1540 1
    xml_insert_element (SMALLDISPLAY, START);
d1545 1
a1545 1
cm_direntry ()
d1547 1
a1547 1
  if (html || xml)
d1554 1
a1554 1
cm_documentdescription ()
d1556 1
a1556 1
  if (html || xml)
d1558 7
d1571 1
a1571 1
cm_itemize ()
d1579 1
a1579 3
do_enumeration (type, default_string)
     int type;
     char *default_string;
d1606 1
a1606 1
cm_enumerate ()
d1620 1
a1620 2
handle_verbatim_environment (find_end_verbatim)
  int find_end_verbatim;
d1626 1
d1628 2
a1629 1
  close_single_paragraph ();
d1641 16
a1656 1
    add_word ("<pre>");
d1664 2
a1665 3
      /*
	Assume no newlines in END_VERBATIM
      */
d1667 15
a1681 8
	  && (input_text_length - input_text_offset > sizeof (END_VERBATIM))
	  && !strncmp (&input_text[input_text_offset+1], END_VERBATIM,
		       sizeof (END_VERBATIM)-1))
	{
	  input_text_offset += sizeof (END_VERBATIM);
	  seen_end = 1;
	  break;
	}
a1682 1
      add_char (character);
d1690 10
a1699 1
    add_word ("</pre>");
d1707 1
a1707 1
cm_verbatim ()
d1713 1
a1713 1
cm_table ()
d1719 1
a1719 1
cm_multitable ()
d1725 1
a1725 1
cm_ftable ()
d1731 1
a1731 1
cm_vtable ()
d1737 1
a1737 1
cm_group ()
d1744 1
a1744 1
cm_html ()
d1753 37
a1789 1
cm_ifhtml ()
d1798 1
a1798 1
cm_ifnothtml ()
d1808 1
a1808 1
cm_ifinfo ()
d1817 1
a1817 1
cm_ifnotinfo ()
d1827 1
a1827 1
cm_ifplaintext ()
d1836 1
a1836 1
cm_ifnotplaintext ()
d1846 1
a1846 1
cm_tex ()
d1855 1
a1855 1
cm_iftex ()
d1864 1
a1864 1
cm_ifnottex ()
d1871 19
d1891 38
d1931 1
a1931 1
cm_flushleft ()
d1939 1
a1939 1
cm_flushright ()
d1945 1
a1945 1
cm_menu ()
d1947 1
a1947 1
  if (current_node == NULL)
d1958 1
a1958 1
cm_detailmenu ()
d1960 1
a1960 1
  if (current_node == NULL)
d1967 84
d2054 1
a2054 1
cm_end ()
d2057 3
a2059 1
  enum insertion_type type;
a2066 2
  get_rest_of_line (0, &temp);

d2074 2
a2075 2
      line_error (_("Bad argument to `%s', `%s', using `%s'"),
           command, temp, insertion_type_pname (current_insertion_type ()));
d2090 2
a2091 3
/*static */int
command_needs_braces (cmd)
     char *cmd;
d2105 1
a2105 1
cm_item ()
d2142 1
d2146 2
d2149 1
d2186 3
a2188 10
		{
		  if (in_paragraph)
		    {
		      add_word ("</p>");
		      in_paragraph = 0;
		    }
		  add_word ("<li>");
		}
	      else if (xml)
		xml_begin_item ();
d2227 6
a2232 6
	      /* Handle text directly after the @@item.  */
	      if (*rest_of_line)
		{
		  line_number--;
		  input_text_offset = original_input_text_offset;
		}
d2240 1
a2240 4
            {
              static int last_html_output_position = 0;

              /* If nothing has been output since the last <dd>,
d2244 1
a2244 4
              if (last_html_output_position == output_position
                  && strncmp ((char *) output_paragraph, "<dd>",
                                output_paragraph_offset) == 0)
                output_paragraph_offset = 0;
d2247 1
a2247 1
                 each new @@item in a table.  But don't do that unless
d2254 6
a2259 6
              if (!itemx_flag
                  && (output_paragraph_offset + 1 < sizeof (dl_tag) ||
		      (strncmp ((char *) output_paragraph
                              + output_paragraph_offset - sizeof (dl_tag) + 1, 
                              dl_tag, sizeof (dl_tag) - 1) != 0)))
                add_word ("<br>");
d2261 1
a2261 1
              add_word ("<dt>");
d2272 2
a2273 5
              /* Make sure output_position is updated, so we could
                 remember it.  */
              close_single_paragraph ();
              last_html_output_position = output_position;
              add_word ("<dd>");
d2275 10
a2284 3
	  else if (xml) /* && docbook)*/ /* 05-08 */
	    {
	      xml_begin_table_item ();
d2289 2
a2290 2
	      xml_continue_table_item ();
	    }
d2362 1
a2362 1
cm_itemx ()
d2367 9
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   $Id: insertion.c,v 1.27 1999/07/06 23:12:53 karl Exp $
d4 1
a4 1
   Copyright (C) 1998, 99 Free Software Foundation, Inc.
d26 1
d30 11
a40 10
{
  "cartouche", "defcv", "deffn", "defivar", "defmac", "defmethod",
  "defop", "defopt", "defspec", "deftp", "deftypefn", "deftypefun",
  "deftypeivar", "deftypemethod", "deftypeop", "deftypevar",
  "deftypevr", "defun", "defvar", "defvr", "detailmenu", "direntry",
  "display", "enumerate", "example", "flushleft", "flushright",
  "format", "ftable", "group", "ifclear", "ifhtml", "ifinfo",
  "ifnothtml", "ifnotinfo", "ifnottex", "ifset", "iftex", "itemize",
  "lisp", "menu", "multitable", "quotation", "rawhtml", "rawtex",
  "smalldisplay", "smallexample", "smallformat", "smalllisp", "table",
d50 3
a52 2
/* Whether to examine menu lines.  */
int in_menu = 0;
d57 2
a58 3
/* Set to 1 if we've processed (commentary) text in a @@menu that
   wasn't part of a menu item.  */
int had_menu_commentary;
d65 2
d101 1
d103 1
d368 3
a370 1
    push_insertion (type, get_item_function ());
d385 1
a385 1
      else if (!no_headers)
d388 4
d414 23
a436 9
      if (html)
        command_name_condition ();
      else
        {
          close_single_paragraph ();
          filling_enabled = no_indent = 0;
          inhibit_paragraph_indentation = 1;
          insert_string ("START-INFO-DIR-ENTRY\n");
        }
d439 29
d474 3
a476 1
          close_single_paragraph ();
d503 1
a503 1
        add_word ("<pre>");
d552 2
d571 3
d584 3
a586 1
      if (!insertion_stack->next
d607 1
d609 1
d650 2
d659 2
d700 54
d757 2
d760 1
a761 1
    case ifinfo:
d764 1
d766 1
a775 5
    case direntry:              /* Eaten if html. */
      insert_string ("END-INFO-DIR-ENTRY\n\n");
      close_insertion_paragraph ();
      break;

d785 5
d811 5
d860 2
d888 1
a888 1
              add_word ("</TD></TR>\n</TABLE>\n");
a927 1
          char *current_filename = input_filename;
d929 4
a932 4
          input_filename = insertion_stack->filename;
          line_number = insertion_stack->line_number;
          line_error (_("No matching `%cend %s'"), COMMAND_PREFIX, offender);
          input_filename = current_filename;
d944 2
d952 2
d960 2
d968 2
d976 2
a980 2
/* @@cartouche/@@end cartouche draws box with rounded corners in
   TeX output.  Right now, just a no-op insertion. */
d984 2
d990 20
d1012 2
d1020 2
d1028 2
d1036 2
d1044 1
a1044 1
  if (no_headers || html)
d1051 10
d1103 71
d1204 29
a1251 1
/* Insert raw HTML (no escaping of `<' etc.). */
d1253 1
a1253 1
cm_html ()
d1255 2
a1256 2
  if (process_html)
    begin_insertion (rawhtml);
d1262 1
a1262 1
cm_ifhtml ()
d1264 2
a1265 11
  if (process_html)
    begin_insertion (ifhtml);
  else
    command_name_condition ();
}

void
cm_ifnothtml ()
{
  if (!process_html)
    begin_insertion (ifnothtml);
d1362 4
d1375 1
a1375 1
static int
d1426 1
d1428 1
d1476 2
d1550 2
a1551 1
                  && strncmp ((char *) output_paragraph
d1553 1
a1553 1
                              dl_tag, sizeof (dl_tag) - 1) != 0)
d1573 9
@


1.1.1.1
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@@


1.1.1.2
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: insertion.c,v 1.47 2002/04/01 14:01:36 karl Exp $
d4 1
a4 1
   Copyright (C) 1998, 99, 2000, 01, 02 Free Software Foundation, Inc.
a25 1
#include "xml.h"
d29 10
a38 11
{ 
  "cartouche", "copying", "defcv", "deffn", "defivar", "defmac",
  "defmethod", "defop", "defopt", "defspec", "deftp", "deftypefn",
  "deftypefun", "deftypeivar", "deftypemethod", "deftypeop",
  "deftypevar", "deftypevr", "defun", "defvar", "defvr", "detailmenu",
  "direntry", "display", "documentdescription", "enumerate", "example",
  "flushleft", "flushright", "format", "ftable", "group", "ifclear",
  "ifhtml", "ifinfo", "ifnothtml", "ifnotinfo", "ifnotplaintext", "ifnottex",
  "ifplaintext", "ifset", "iftex", "itemize", "lisp", "menu",
  "multitable", "quotation", "rawhtml", "rawtex", "smalldisplay",
  "smallexample", "smallformat", "smalllisp", "verbatim", "table",
d48 2
a49 3
/* Set to 1 if we've processed (commentary) text in a @@menu that
   wasn't part of a menu item.  */
int had_menu_commentary;
d54 3
a56 2
/* Whether to examine menu lines.  */
int in_menu = 0;
a62 2
extern void cm_insert_copying ();

a96 1
        case ifnotplaintext:
a97 1
        case ifplaintext:
d362 1
a362 3
    {
      push_insertion (type, get_item_function ());
    }
d377 1
a377 1
      else if (!no_headers && !xml)
a379 4
      if (xml)
	xml_insert_element (MENU, START);

      next_menu_item_number = 1;
d402 9
a410 23
      close_single_paragraph ();
      filling_enabled = no_indent = 0;
      inhibit_paragraph_indentation = 1;
      insert_string ("START-INFO-DIR-ENTRY\n");
      break;

    case documentdescription:
      {
        char *desc;
        int start_of_end;
        int save_fixed_width;

        discard_until ("\n"); /* ignore the @@documentdescription line */
        start_of_end = get_until ("\n@@end documentdescription", &desc);
        save_fixed_width = in_fixed_width_font;

        in_fixed_width_font = 0;
        document_description = expansion (desc, 0);
        free (desc);

        in_fixed_width_font = save_fixed_width;
        input_text_offset = start_of_end; /* go back to the @@end to match */
      }
a412 29
    case copying:
      {
        /* Save the copying text away for @@insertcopying,
           typically used on the back of the @@titlepage (for TeX) and
           the Top node (for info/html).  */
        char *text;
        int start_of_end;

        discard_until ("\n"); /* ignore remainder of @@copying line */
        start_of_end = get_until ("\n@@end copying", &text);

        /* include all the output-format-specific markup.  */
        copying_text = full_expansion (text, 0);
        free (text);

        input_text_offset = start_of_end; /* go back to the @@end to match */
      }
      
      /* For info, output the copying text right away, so it will end up
         in the header of the Info file, before the first node, and thus
         get copied automatically to all the split files.  For xml, also
         output it right away since xml output is never split.
         For html, we output it specifically in html_output_head. 
         For plain text, there's no way to hide it, so the author must
          use @@insertcopying in the desired location.  */
      if (!html && !no_headers)
        cm_insert_copying ();
      break;
      
d419 1
a419 3
          /* with close_single_paragraph, we get no blank line above
             within @@copying.  */
          close_paragraph ();
d446 1
a446 1
        add_word ("<br><pre>");
a494 2
      if (xml)
	xml_begin_table (type, insertion_stack->item_function);
a511 3
      if (xml)
	xml_begin_enumerate (enumeration_arg);
      
d522 1
a522 3
      if (xml)
	xml_insert_element (GROUP, START);
      else if (!insertion_stack->next
a542 1
    case ifnotplaintext:
a543 1
    case ifplaintext:
a583 2
      if (html)
	add_word ("<div align=\"left\">");
a590 2
      if (html)
	add_word ("<div align=\"right\">");
a629 54
  if (xml)
    {
      switch (type)
	{
	case ifinfo:
	case documentdescription:	
	  break;
	case copying:
	  xml_insert_element (COPYING, END);
	  break;
	case quotation:
	  xml_insert_element (QUOTATION, END);
	  break;
	case example:
	  xml_insert_element (EXAMPLE, END);
	  break;
	case smallexample:
	  xml_insert_element (SMALLEXAMPLE, END);
	  break;
	case lisp:
	  xml_insert_element (LISP, END);
	  break;
	case smalllisp:
	  xml_insert_element (SMALLLISP, END);
	  break;
	case cartouche:
	  xml_insert_element (CARTOUCHE, END);
	  break;
	case format:
	  xml_insert_element (FORMAT, END);
	  break;
	case smallformat:
	  xml_insert_element (SMALLFORMAT, END);
	  break;
	case display:
	  xml_insert_element (DISPLAY, END);
	  break;
	case smalldisplay:
	  xml_insert_element (SMALLDISPLAY, END);
	  break;
	case table:
	case ftable:
	case vtable:	  
	case itemize:
	  xml_end_table (type);
	  break;
	case enumerate:
	  xml_end_enumerate (type);
	  break;
	case group:
	  xml_insert_element (GROUP, END);
	  break;
	}
    }
a632 2
    case copying:
    case documentdescription:
d634 1
a635 1
    case ifhtml:
a637 1
    case ifnotplaintext:
a638 1
    case ifplaintext:
d648 5
a661 5
    case direntry:              /* Eaten if html. */
      insert_string ("END-INFO-DIR-ENTRY\n\n");
      close_insertion_paragraph ();
      break;

a682 5
      if (html)
	add_word ("</div>\n");
      close_insertion_paragraph ();
      break;

a726 2
      if (html)
	add_word ("</div>\n");
d753 1
a753 1
              add_word ("</td></tr>\n</table>\n");
d793 1
d795 4
a798 4
          file_line_error (insertion_stack->filename,
			   insertion_stack->line_number,
			   _("No matching `%cend %s'"), COMMAND_PREFIX,
			   offender);
a809 2
  if (xml)
    xml_insert_element (QUOTATION, START);
a815 2
  if (xml)
    xml_insert_element (EXAMPLE, START);
a821 2
  if (xml)
    xml_insert_element (SMALLEXAMPLE, START);
a827 2
  if (xml)
    xml_insert_element (LISP, START);
a833 2
  if (xml)
    xml_insert_element (SMALLLISP, START);
d837 2
a841 2
  if (xml)
    xml_insert_element (CARTOUCHE, START);
a845 20
cm_copying ()
{
  if (xml)
    xml_insert_element (COPYING, START);
  begin_insertion (copying);
}

/* Not an insertion, despite the name, but it goes with cm_copying.  */
void
cm_insert_copying ()
{
  if (copying_text)
    { /* insert_string rather than add_word because we've already done
         full expansion on copying_text when we saved it.  */
      insert_string (copying_text);
      insert ('\n');
    }
}

void
a847 2
  if (xml)
    xml_insert_element (FORMAT, START);
a853 2
  if (xml)
    xml_insert_element (SMALLFORMAT, START);
a859 2
  if (xml)
    xml_insert_element (DISPLAY, START);
a865 2
  if (xml)
    xml_insert_element (SMALLDISPLAY, START);
d872 1
a872 1
  if (html || xml)
a878 10
cm_documentdescription ()
{
  if (html || xml)
    begin_insertion (documentdescription);
  else
    command_name_condition ();
}


void
a920 71
/*  Handle verbatim environment:
    find_end_verbatim == 0:  process until end of file
    find_end_verbatim != 0:  process until 'COMMAND_PREFIXend verbatim'
                             or end of file

  We cannot simply copy input stream onto output stream; as the
  verbatim environment may be encapsulated in an @@example environment,
  for example. */
void
handle_verbatim_environment (find_end_verbatim)
  int find_end_verbatim;
{
  int character;
  int seen_end = 0;
  int save_filling_enabled = filling_enabled;
  int save_inhibit_paragraph_indentation = inhibit_paragraph_indentation;

  close_single_paragraph ();
  inhibit_paragraph_indentation = 1;
  filling_enabled = 0;
  in_fixed_width_font++;
  last_char_was_newline = 0;

  /* No indentation: this is verbatim after all
     If you want indent, enclose @@verbatim in @@example
       current_indent += default_indentation_increment;
   */

  if (html)
    add_word ("<pre>");

  while (input_text_offset < input_text_length)
    {
      character = curchar ();

      if (character == '\n')
        line_number++;
      /*
	Assume no newlines in END_VERBATIM
      */
      else if (find_end_verbatim && (character == COMMAND_PREFIX) /* @@ */
	  && (input_text_length - input_text_offset > sizeof (END_VERBATIM))
	  && !strncmp (&input_text[input_text_offset+1], END_VERBATIM,
		       sizeof (END_VERBATIM)-1))
	{
	  input_text_offset += sizeof (END_VERBATIM);
	  seen_end = 1;
	  break;
	}

      add_char (character);
      input_text_offset++;
    }

  if (find_end_verbatim && !seen_end)
    warning (_("end of file inside verbatim block"));

  if (html)
    add_word ("</pre>");
  
  in_fixed_width_font--;
  filling_enabled = save_filling_enabled;
  inhibit_paragraph_indentation = save_inhibit_paragraph_indentation;
}

void
cm_verbatim ()
{
  handle_verbatim_environment (1);
}

a950 1
/* Insert raw HTML (no escaping of `<' etc.). */
d952 1
a952 1
cm_html ()
d954 2
a955 2
  if (process_html)
    begin_insertion (rawhtml);
d961 1
a961 1
cm_ifhtml ()
d963 2
a964 11
  if (process_html)
    begin_insertion (ifhtml);
  else
    command_name_condition ();
}

void
cm_ifnothtml ()
{
  if (!process_html)
    begin_insertion (ifnothtml);
d970 1
d972 1
a972 1
cm_ifinfo ()
d974 2
a975 2
  if (process_info)
    begin_insertion (ifinfo);
d981 1
a981 1
cm_ifnotinfo ()
d983 2
a984 2
  if (!process_info)
    begin_insertion (ifnotinfo);
a988 1

d990 1
a990 1
cm_ifplaintext ()
d992 2
a993 11
  if (process_plaintext)
    begin_insertion (ifplaintext);
  else
    command_name_condition ();
}

void
cm_ifnotplaintext ()
{
  if (!process_plaintext)
    begin_insertion (ifnotplaintext);
a1089 4
  if (xml && type == menu) /* fixme */
    {
      xml_end_menu ();
    }
d1099 1
a1099 1
/*static */int
a1149 1
        case ifnotplaintext:
a1150 1
        case ifplaintext:
a1197 2
	      else if (xml)
		xml_begin_item ();
a1291 9
	  else if (xml) /* && docbook)*/ /* 05-08 */
	    {
	      xml_begin_table_item ();
              if (item_func && *item_func)
                execute_string ("%s{%s}", item_func, rest_of_line);
              else
                execute_string ("%s", rest_of_line);
	      xml_continue_table_item ();
	    }
@


1.1.1.3
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: insertion.c,v 1.55 2004/11/11 18:34:28 karl Exp $
d4 1
a4 2
   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a22 2
#include "float.h"
#include "html.h"
a25 1
#include "multi.h"
d32 10
a41 11
  "defmethod", "defop", "defopt", "defspec", "deftp", "deftypecv",
  "deftypefn", "deftypefun", "deftypeivar", "deftypemethod",
  "deftypeop", "deftypevar", "deftypevr", "defun", "defvar", "defvr",
  "detailmenu", "direntry", "display", "documentdescription",
  "enumerate", "example", "float", "flushleft", "flushright", "format",
  "ftable", "group", "ifclear", "ifdocbook", "ifhtml", "ifinfo",
  "ifnotdocbook", "ifnothtml", "ifnotinfo", "ifnotplaintext", "ifnottex",
  "ifnotxml", "ifplaintext", "ifset", "iftex", "ifxml", "itemize", "lisp",
  "menu", "multitable", "quotation", "rawdocbook", "rawhtml", "rawtex",
  "rawxml", "smalldisplay", "smallexample", "smallformat", "smalllisp",
  "verbatim", "table", "tex", "vtable", "titlepage", "bad_type"
d64 3
a66 13
/* Since an insertion is already in the stack before we reach the switch
   statement, we cannot use is_in_insertion_of_type (always returns true.) Also
   making it return the level found, and comparing it with the current level is
   no use, due to the order of stack.  */
static int float_active = 0;

/* Unsetting escape_html blindly causes text inside @@html/etc. to be escaped if
   used within a rmacro.  */
static int raw_output_block = 0;

/* Non-zero if a <dl> element has a <dt> element in it.  We use this when
   deciding whether to insert a <br> or not.  */
static int html_deflist_has_term = 0;
d69 1
a69 1
init_insertion_stack (void)
d76 1
a76 1
current_insertion_type (void)
d84 1
a84 1
current_item_function (void)
a102 1
	case ifnotxml:
a105 2
	case ifxml:
        case rawdocbook:
a106 1
        case rawxml:
d110 2
a111 2
          elt = elt->next;
          break;
d126 2
a127 2
static char *
get_item_function (void)
a129 2
  char *item_loc;
  
a131 11
  /* If the document erroneously says
       @@itemize @@bullet @@item foobar
     it's nicer to give an error up front than repeat `@@bullet expected
     braces' until we get a segmentation fault.  */
  item_loc = strstr (item_function, "@@item");
  if (item_loc)
    {
      line_error (_("@@item not allowed in argument to @@itemize"));
      *item_loc = 0;
    }

d148 4
a151 2
static void
push_insertion (enum insertion_type type, char *item_function)
d171 1
a171 1
pop_insertion (void)
d191 3
a193 2
static const char *
insertion_type_pname (enum insertion_type type)
d196 1
a196 12
  {
    if (type == rawdocbook)
      return "docbook";
    else if (type == rawhtml)
      return "html";
    else if (type == rawxml)
      return "xml";
    else if (type == rawtex)
      return "tex";
    else
      return insertion_type_names[(int) type];
  }
d204 2
a205 1
find_type_from_name (char *name)
a211 2
      if (index == rawdocbook && STREQ (name, "docbook"))
        return rawdocbook;
a213 2
      if (index == rawxml && STREQ (name, "xml"))
        return rawxml;
a220 2
/* Simple function to query insertion_stack to see if we are inside a given
   insertion type. */
d222 2
a223 20
is_in_insertion_of_type (int type)
{
  INSERTION_ELT *temp = insertion_stack;

  if (!insertion_level)
    return 0;

  while (temp)
    {
      if (temp->insertion == type)
        return 1;
      temp = temp->next;
    }

  return 0;
}


static int
defun_insertion (enum insertion_type type)
a234 1
     || (type == deftypecv)
d265 3
a267 2
static void
start_enumerating (int at, int type)
d281 2
a282 2
static void
stop_enumerating (void)
d293 2
a294 2
static void
enumerate_item (void)
d316 1
a316 1
enum_html (void)
d337 1
a337 1
  add_html_block_elt_args ("<ol type=%c start=%d>\n", type, start);
d342 1
a342 1
command_name_condition (void)
d357 2
a358 1
begin_insertion (enum insertion_type type)
d389 1
a389 3
        xml_insert_element (MENU, START);
      else
        in_fixed_width_font++;
d393 1
d409 1
a409 8
      if (xml)
        {
          xml_insert_element (DETAILMENU, START);
          skip_whitespace_and_newlines();
        }
      else
        in_fixed_width_font++;

d440 1
d444 3
a446 1
      if (input_text[input_text_offset] != '\n')
d448 1
d450 3
a452 2
        input_text_offset = get_until ("\n@@end copying", &copying_text);
        canon_white (copying_text);
d454 3
a463 10
      if (docbook)
	{
	  if (!xml_in_bookinfo)
	    {
	      xml_insert_element (BOOKINFO, START);
	      xml_in_bookinfo = 1;
	    }
          xml_insert_element (LEGALNOTICE, START);
	}

a465 4

      if (docbook)
        xml_insert_element (LEGALNOTICE, END);

d467 1
a467 1

d471 1
a471 1
        add_html_block_elt ("<blockquote>\n");
a481 4
      if (xml)
        xml_insert_quotation (insertion_stack->item_function, START);
      else if (strlen(insertion_stack->item_function))
        execute_string ("@@b{%s:} ", insertion_stack->item_function);
d484 2
a489 6
      in_fixed_width_font++;
      /* fall through */

      /* Like @@example but no fixed width font. */
    case display:
    case smalldisplay:
d495 1
d500 4
a503 4
        /* Kludge alert: if <pre> is followed by a newline, IE3,
           mozilla, maybe others render an extra blank line before the
           pre-formatted block.  So don't output a newline.  */
        add_html_block_elt_args ("<pre class=\"%s\">", command);
d506 1
a506 11
        {
          current_indent += example_indentation_increment;
          if (html)
            {
              /* Since we didn't put \n after <pre>, we need to insert
                 the indentation by hand.  */
              int i;
              for (i = current_indent; i > 0; i--)
                add_char (' ');
            }
        }
d545 4
a548 4
            {
              add_html_block_elt ("<ul>\n");
              in_paragraph = 0;
            }
d550 1
a550 5
            { /* We are just starting, so this <dl>
                 has no <dt> children yet.  */
              html_deflist_has_term = 0;
              add_html_block_elt ("<dl>\n");
            }
d553 1
a553 9
        xml_begin_table (type, insertion_stack->item_function);

      while (input_text[input_text_offset] == '\n'
          && input_text[input_text_offset+1] == '\n')
        {
          line_number++;
          input_text_offset++;
        }

d569 1
a569 4
        {
          enum_html ();
          in_paragraph = 0;
        }
d572 1
a572 1
        xml_begin_enumerate (enumeration_arg);
d580 1
a580 1
      /* @@group produces no output in info. */
d585 1
a585 1
        xml_insert_element (GROUP, START);
d600 1
a601 147
      if (html)
	add_html_block_elt ("<p><table class=\"cartouche\" summary=\"cartouche\" border=\"1\"><tr><td>\n");
      if (in_menu)
        no_discard++;
      break;

    case floatenv:
      /* Cannot nest floats, so complain.  */
      if (float_active)
        {
          line_error (_("%cfloat environments cannot be nested"), COMMAND_PREFIX);
          pop_insertion ();
          break;
        }

      float_active++;

      { /* Collect data about this float.  */
        /* Example: @@float [FLOATTYPE][,XREFLABEL][,POSITION] */
        char floattype[200] = "";
        char xreflabel[200] = "";
        char position[200]  = "";
        char *text;
        char *caption;
        char *shortcaption;
        int start_of_end;
        int save_line_number = line_number;
        int save_input_text_offset = input_text_offset;
        int i;

        if (strlen (insertion_stack->item_function) > 0)
          {
            int i = 0, t = 0, c = 0;
            while (insertion_stack->item_function[i])
              {
                if (insertion_stack->item_function[i] == ',')
                  {
                    switch (t)
                      {
                      case 0:
                        floattype[c] = '\0';
                        break;
                      case 1:
                        xreflabel[c] = '\0';
                        break;
                      case 2:
                        position[c] = '\0';
                        break;
                      }
                    c = 0;
                    t++;
                    i++;
                    continue;
                  }

                switch (t)
                  {
                  case 0:
                    floattype[c] = insertion_stack->item_function[i];
                    break;
                  case 1:
                    xreflabel[c] = insertion_stack->item_function[i];
                    break;
                  case 2:
                    position[c] = insertion_stack->item_function[i];
                    break;
                  }
                c++;
                i++;
              }
          }

        skip_whitespace_and_newlines ();

        start_of_end = get_until ("\n@@end float", &text);

        /* Get also the @@caption.  */
        i = search_forward_until_pos ("\n@@caption{",
            save_input_text_offset, start_of_end);
        if (i > -1)
          {
            input_text_offset = i + sizeof ("\n@@caption{") - 1;
            get_until_in_braces ("\n@@end float", &caption);
            input_text_offset = save_input_text_offset;
          }
        else
          caption = "";

        /* ... and the @@shortcaption.  */
        i = search_forward_until_pos ("\n@@shortcaption{",
            save_input_text_offset, start_of_end);
        if (i > -1)
          {
            input_text_offset = i + sizeof ("\n@@shortcaption{") - 1;
            get_until_in_braces ("\n@@end float", &shortcaption);
            input_text_offset = save_input_text_offset;
          }
        else
          shortcaption = "";

        canon_white (xreflabel);
        canon_white (floattype);
        canon_white (position);
        canon_white (caption);
        canon_white (shortcaption);

        add_new_float (xstrdup (xreflabel),
            xstrdup (caption), xstrdup (shortcaption),
            xstrdup (floattype), xstrdup (position));

        /* Move to the start of the @@float so the contents get processed as
           usual.  */
        input_text_offset = save_input_text_offset;
        line_number = save_line_number;
      }

      if (html)
        add_html_block_elt ("<div class=\"float\">\n");
      else if (docbook)
        xml_insert_element (FLOAT, START);
      else if (xml)
        {
          xml_insert_element_with_attribute (FLOAT, START,
              "name=\"%s\"", current_float_id ());

          xml_insert_element (FLOATTYPE, START);
          execute_string ("%s", current_float_type ());
          xml_insert_element (FLOATTYPE, END);

          xml_insert_element (FLOATPOS, START);
          execute_string ("%s", current_float_position ());
          xml_insert_element (FLOATPOS, END);
        }
      else
        { /* Info */
          close_single_paragraph ();
          inhibit_paragraph_indentation = 1;
        }

      /* Anchor now.  Note that XML documents get their
         anchors with <float name="anchor"> tag.  */
      if ((!xml || docbook) && strlen (current_float_id ()) > 0)
        execute_string ("@@anchor{%s}", current_float_id ());

      break;

      /* Insertions that are no-ops in info, but do something in TeX. */
a602 1
    case ifdocbook:
a604 1
    case ifnotdocbook:
a608 1
    case ifnotxml:
a611 1
    case ifxml:
a616 1
    case rawdocbook:
d618 1
a618 17
    case rawxml:
      raw_output_block++;

      if (raw_output_block > 0)
        {
          xml_no_para = 1;
          escape_html = 0;
          xml_keep_space++;
        }

      {
        /* Some deuglification for improved readability.  */
        extern int xml_in_para;
        if (xml && !xml_in_para && xml_indentation_increment > 0)
          add_char ('\n');
      }

a629 1
    case deftypecv:
a643 2
      if (xml)
	xml_begin_definition ();
d651 1
a651 1
        add_html_block_elt ("<div align=\"left\">");
d660 1
a660 5
        add_html_block_elt ("<div align=\"right\">");
      break;

    case titlepage:
      xml_insert_element (TITLEPAGE, START);
d665 1
d676 3
a678 2
static void
end_insertion (int type)
d680 1
a680 1
  int temp_type;
d703 48
a750 62
        {
        case ifinfo:
        case documentdescription:       
          break;
        case quotation:
          xml_insert_quotation ("", END);
          break;
        case example:
          xml_insert_element (EXAMPLE, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case smallexample:
          xml_insert_element (SMALLEXAMPLE, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case lisp:
          xml_insert_element (LISP, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case smalllisp:
          xml_insert_element (SMALLLISP, END);
          if (docbook && current_insertion_type () == floatenv)
            xml_insert_element (FLOATEXAMPLE, END);
          break;
        case cartouche:
          xml_insert_element (CARTOUCHE, END);
          break;
        case format:
	  if (docbook && xml_in_bookinfo && xml_in_abstract)
	    {
	      xml_insert_element (ABSTRACT, END);
	      xml_in_abstract = 0;
	    }
	  else
	    xml_insert_element (FORMAT, END);
          break;
        case smallformat:
          xml_insert_element (SMALLFORMAT, END);
          break;
        case display:
          xml_insert_element (DISPLAY, END);
          break;
        case smalldisplay:
          xml_insert_element (SMALLDISPLAY, END);
          break;
        case table:
        case ftable:
        case vtable:      
        case itemize:
          xml_end_table (type);
          break;
        case enumerate:
          xml_end_enumerate ();
          break;
        case group:
          xml_insert_element (GROUP, END);
          break;
	case titlepage:
	  xml_insert_element (TITLEPAGE, END);
d752 1
a752 1
        }
d758 1
a758 3
      line_number--;
      break;

a759 1
    case ifdocbook:
a761 1
    case ifnotdocbook:
a765 1
    case ifnotxml:
a768 1
    case ifxml:
a769 1
    case titlepage:
a771 1
    case rawdocbook:
d773 1
a773 12
    case rawxml:
      raw_output_block--;

      if (raw_output_block <= 0)
        {
          xml_no_para = 0;
          escape_html = 1;
          xml_keep_space--;
        }

      if ((xml || html) && output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
a776 3
      if (xml)
        xml_insert_element (DETAILMENU, END);

a789 6
    case documentdescription:
      if (xml)
        insert_string (document_description);
        xml_insert_element (DOCUMENTDESCRIPTION, END);
      break;
      
d792 3
a794 3
      if (html && !no_headers)
        add_html_block_elt ("</ul>\n");
      else if (!no_headers && !xml)
d807 1
a807 1
        add_html_block_elt ("</ol>\n");
d812 1
a812 1
        add_html_block_elt ("</div>\n");
d816 1
a817 2
      if (html)
	add_html_block_elt ("</td></tr></table>\n");
a820 57
    case group:
      if (!xml || docbook)
        close_insertion_paragraph ();
      break;

    case floatenv:
      if (xml)
        xml_insert_element (FLOAT, END);
      else
        {
          if (html)
            add_html_block_elt ("<p><strong class=\"float-caption\">");
          else
            close_paragraph ();

          no_indent = 1;

          /* Legend:
               1) @@float Foo,lbl & no caption:    Foo 1.1
               2) @@float Foo & no caption:        Foo
               3) @@float ,lbl & no caption:       1.1
               4) @@float & no caption:                    */

          if (!xml && !html)
            indent (current_indent);

          if (strlen (current_float_type ()))
            execute_string ("%s", current_float_type ());

          if (strlen (current_float_id ()) > 0)
            {
              if (strlen (current_float_type ()) > 0)
                add_char (' ');

              add_word (current_float_number ());
            }

          if (strlen (current_float_title ()) > 0)
            {
              if (strlen (current_float_type ()) > 0
                  || strlen (current_float_id ()) > 0)
                insert_string (": ");

              execute_string ("%s", current_float_title ());
            }

          /* Indent the following paragraph. */
          inhibit_paragraph_indentation = 0;

          if (html)
            add_word ("</strong></p></div>\n");
          else
            close_paragraph ();
        }
      float_active--;
      break;

d832 1
a832 3
      if (type != format && type != smallformat && type != quotation)
        current_indent -= example_indentation_increment;
      else if (type == quotation)
d836 1
a836 9
        { /* The complex code in close_paragraph that kills whitespace
             does not function here, since we've inserted non-whitespace
             (the </whatever>) before it.  The indentation already got
             inserted at the end of the last example line, so we have to
             delete it, or browsers wind up showing an extra blank line.  */
          kill_self_indent (default_indentation_increment);
          add_html_block_elt (type == quotation
              ? "</blockquote>\n" : "</pre>\n");
        }
d839 2
a840 7
         start of a new paragraph, except for the XML output. */
      if (!xml || docbook)
        close_insertion_paragraph ();

      /* </pre> closes paragraph without messing with </p>.  */
      if (html && type != quotation)
          paragraph_is_open = 0;
d848 1
a848 2
        add_html_block_elt ("</dl>\n");
      close_insertion_paragraph ();
d854 1
a854 1
        add_html_block_elt ("</ul>\n");
d861 1
a861 1
        add_html_block_elt ("</div>\n");
d868 1
a868 1
        int base_type;
a878 1
          case deftypecv:
d883 6
a888 14
          case deftypemethod:
          case deftypeop:
          case deftypeivar:
            if (html)
              {
                if (paragraph_is_open)
                  add_html_block_elt ("</p>");
                /* close the div and blockquote which has been opened in defun.c */
                if (!rollback_empty_tag ("blockquote"))
                  add_html_block_elt ("</blockquote>");
                add_html_block_elt ("</div>\n");
              }
	    if (xml)
	      xml_end_definition ();
d913 2
a914 1
discard_insertions (int specials_ok)
a921 1
              || insertion_stack->insertion == rawdocbook
a922 1
              || insertion_stack->insertion == rawxml
d927 1
a927 1
          const char *offender = insertion_type_pname (insertion_stack->insertion);
d930 3
a932 3
                           insertion_stack->line_number,
                           _("No matching `%cend %s'"), COMMAND_PREFIX,
                           offender);
d942 1
a942 1
cm_quotation (void)
d944 2
a945 1
  /* We start the blockquote element in the insertion.  */
d950 1
a950 1
cm_example (void)
a951 3
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

d953 1
a953 14
    {
      /* Rollback previous newlines.  These occur between
         </para> and <example>.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;

      xml_insert_element (EXAMPLE, START);

      /* Make sure example text is starting on a new line
         for improved readability.  */
      if (docbook)
        add_char ('\n');
    }

d958 1
a958 1
cm_smallexample (void)
a959 3
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

d961 1
a961 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLEXAMPLE, START);
      if (docbook)
        add_char ('\n');
    }

d966 1
a966 1
cm_lisp (void)
a967 3
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

d969 1
a969 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (LISP, START);
      if (docbook)
        add_char ('\n');
    }

d974 1
a974 1
cm_smalllisp (void)
a975 3
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (FLOATEXAMPLE);

d977 1
a977 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLLISP, START);
      if (docbook)
        add_char ('\n');
    }

d982 1
a982 1
cm_cartouche (void)
a983 3
  if (docbook && current_insertion_type () == floatenv)
    xml_begin_docbook_float (CARTOUCHE);

d990 1
a990 1
cm_copying (void)
d992 2
d999 1
a999 1
cm_insert_copying (void)
d1001 5
a1005 14
  if (!copying_text)
    {
      warning ("@@copying not used before %s", command);
      return;
    }

  execute_string ("%s", copying_text);

  if (!xml && !html)
    {
      add_word ("\n\n");
      /* Update output_position so that the node positions in the tag
         tables will take account of the copying text.  */
      flush_output ();
d1010 1
a1010 1
cm_format (void)
d1013 1
a1013 16
    {
      if (docbook && xml_in_bookinfo)
	{
	  xml_insert_element (ABSTRACT, START);
	  xml_in_abstract = 1;
	}
      else
        {
          /* See cm_example comments about newlines.  */
          if (output_paragraph[output_paragraph_offset-1] == '\n')
            output_paragraph_offset--;
          xml_insert_element (FORMAT, START);
          if (docbook)
            add_char ('\n');
        }
    }
d1018 1
a1018 1
cm_smallformat (void)
d1021 1
a1021 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLFORMAT, START);
      if (docbook)
        add_char ('\n');
    }

d1026 1
a1026 1
cm_display (void)
d1029 1
a1029 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (DISPLAY, START);
      if (docbook)
        add_char ('\n');
    }

d1034 1
a1034 1
cm_smalldisplay (void)
d1037 1
a1037 9
    {
      /* See cm_example comments about newlines.  */
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
      xml_insert_element (SMALLDISPLAY, START);
      if (docbook)
        add_char ('\n');
    }

d1042 1
a1042 1
cm_direntry (void)
d1044 1
a1044 1
  if (html || xml || no_headers)
d1051 1
a1051 1
cm_documentdescription (void)
d1053 1
a1053 1
  if (html)
a1054 7

  else if (xml)
    {
      xml_insert_element (DOCUMENTDESCRIPTION, START);
      begin_insertion (documentdescription);
    }

d1061 1
a1061 1
cm_itemize (void)
d1069 3
a1071 1
do_enumeration (int type, char *default_string)
d1098 1
a1098 1
cm_enumerate (void)
d1112 2
a1113 1
handle_verbatim_environment (int find_end_verbatim)
a1118 1
  int save_escape_html = escape_html;
d1120 1
a1120 2
  if (!insertion_stack)
    close_single_paragraph (); /* no blank lines if not at outer level */
d1132 1
a1132 16
    { /* If inside @@example, we'll be preceded by the indentation
         already.  Browsers will ignore those spaces because we're about
         to start another <pre> (don't ask me).  So, wipe them out for
         cleanliness, and re-insert.  */
      int i;
      kill_self_indent (default_indentation_increment);
      add_html_block_elt ("<pre class=\"verbatim\">");
      for (i = current_indent; i > 0; i--)
        add_char (' ');
    }
  else if (xml)
    {
      xml_insert_element (VERBATIM, START);
      escape_html = 0;
      add_word ("<![CDATA[");
    }
d1140 3
a1142 2

      /* Assume no newlines in END_VERBATIM. */
d1144 8
a1151 15
          && (input_text_length - input_text_offset > sizeof (END_VERBATIM))
          && !strncmp (&input_text[input_text_offset+1], END_VERBATIM,
                       sizeof (END_VERBATIM)-1))
        {
          input_text_offset += sizeof (END_VERBATIM);
          seen_end = 1;
          break;
        }

      if (html && character == '&' && escape_html)
        add_word ("&amp;");
      else if (html && character == '<' && escape_html)
        add_word ("&lt;");
      else
        add_char (character);
d1153 1
d1161 1
a1161 10
    { /* See comments in example case above.  */
      kill_self_indent (default_indentation_increment);
      add_word ("</pre>");
    }
  else if (xml)
    {
      add_word ("]]>");
      xml_insert_element (VERBATIM, END);
      escape_html = save_escape_html;
    }
d1169 1
a1169 1
cm_verbatim (void)
d1175 1
a1175 1
cm_table (void)
d1181 1
a1181 1
cm_multitable (void)
d1187 1
a1187 1
cm_ftable (void)
d1193 1
a1193 1
cm_vtable (void)
d1199 1
a1199 1
cm_group (void)
d1206 1
a1206 1
cm_html (int arg)
d1215 1
a1215 37
cm_xml (int arg)
{
  if (process_xml)
    begin_insertion (rawxml);
  else
    command_name_condition ();
}

void
cm_docbook (int arg)
{
  if (process_docbook)
    begin_insertion (rawdocbook);
  else
    command_name_condition ();
}

void
cm_ifdocbook (void)
{
  if (process_docbook)
    begin_insertion (ifdocbook);
  else
    command_name_condition ();
}

void
cm_ifnotdocbook (void)
{
  if (!process_docbook)
    begin_insertion (ifnotdocbook);
  else
    command_name_condition ();
}

void
cm_ifhtml (void)
d1224 1
a1224 1
cm_ifnothtml (void)
d1234 1
a1234 1
cm_ifinfo (void)
d1243 1
a1243 1
cm_ifnotinfo (void)
d1253 1
a1253 1
cm_ifplaintext (void)
d1262 1
a1262 1
cm_ifnotplaintext (void)
d1272 1
a1272 1
cm_tex (void)
d1281 1
a1281 1
cm_iftex (void)
d1290 1
a1290 1
cm_ifnottex (void)
a1296 19

void
cm_ifxml (void)
{
  if (process_xml)
    begin_insertion (ifxml);
  else
    command_name_condition ();
}

void
cm_ifnotxml (void)
{
  if (!process_xml)
    begin_insertion (ifnotxml);
  else
    command_name_condition ();
}

a1297 38
/* Generic xrefable block with a caption.  */
void
cm_float (void)
{
  begin_insertion (floatenv);
}

void
cm_caption (int arg)
{
  char *temp;

  /* This is a no_op command for most formats, as we handle it during @@float
     insertion.  For XML though, we handle it here to keep document structure
     as close as possible, to the Texinfo source.  */

  /* Everything is already handled at START.  */
  if (arg == END)
    return;

  /* Check if it's mislocated.  */
  if (current_insertion_type () != floatenv)
    line_error (_("@@%s not meaningful outside `@@float' environment"), command);

  get_until_in_braces ("\n@@end float", &temp);

  if (xml)
    {
      int elt = STREQ (command, "shortcaption") ? SHORTCAPTION : CAPTION;
      xml_insert_element (elt, START);
      if (!docbook)
        execute_string ("%s", temp);
      xml_insert_element (elt, END);
    }

  free (temp);
}

d1300 1
a1300 1
cm_flushleft (void)
d1308 1
a1308 1
cm_flushright (void)
d1314 1
a1314 1
cm_menu (void)
d1316 1
a1316 1
  if (current_node == NULL && !macro_expansion_output_stream)
d1327 1
a1327 1
cm_detailmenu (void)
d1329 1
a1329 1
  if (current_node == NULL && !macro_expansion_output_stream)
a1335 84

/* Title page commands. */

void
cm_titlepage (void)
{
  titlepage_cmd_present = 1;
  if (xml && !docbook)
    begin_insertion (titlepage);
  else
    command_name_condition ();
}

void
cm_author (void)
{
  char *rest;
  get_rest_of_line (1, &rest);

  if (is_in_insertion_of_type (quotation))
    {
      if (html)
        add_word_args ("&mdash; %s", rest);
      else if (docbook)
        {
          /* FIXME Ideally, we should use an attribution element,
             but they are supposed to be at the start of quotation
             blocks.  So to avoid looking ahead mess, let's just
             use mdash like HTML for now.  */
          xml_insert_entity ("mdash");
          add_word (rest);
        }
      else if (xml)
        {
          xml_insert_element (AUTHOR, START);
          add_word (rest);
          xml_insert_element (AUTHOR, END);
        }
      else
        add_word_args ("-- %s", rest);
    }
  else if (is_in_insertion_of_type (titlepage))
    {
      if (xml && !docbook)
        {
          xml_insert_element (AUTHOR, START);
          add_word (rest);
          xml_insert_element (AUTHOR, END);
        }
    }
  else
    line_error (_("@@%s not meaningful outside `@@titlepage' and `@@quotation' environments"),
        command);

  free (rest);
}

void
cm_titlepage_cmds (void)
{
  char *rest;

  get_rest_of_line (1, &rest);

  if (!is_in_insertion_of_type (titlepage))
    line_error (_("@@%s not meaningful outside `@@titlepage' environment"),
        command);

  if (xml && !docbook)
    {
      int elt = 0;

      if (STREQ (command, "title"))
        elt = BOOKTITLE;
      else if (STREQ (command, "subtitle"))
        elt = BOOKSUBTITLE;

      xml_insert_element (elt, START);
      add_word (rest);
      xml_insert_element (elt, END);
    }

    free (rest);
}
d1339 1
a1339 1
cm_end (void)
d1342 1
a1342 3
  int type;

  get_rest_of_line (0, &temp);
d1350 2
d1359 2
a1360 2
      line_error (_("Bad argument `%s' to `@@%s', using `%s'"),
           temp, command, insertion_type_pname (current_insertion_type ()));
d1375 3
a1377 2
int
command_needs_braces (char *cmd)
d1391 1
a1391 1
cm_item (void)
a1427 1
	case ifnotxml:
a1430 2
	case ifxml:
        case rawdocbook:
a1431 1
        case rawxml:
d1468 10
a1477 3
                add_html_block_elt ("<li>");
              else if (xml)
                xml_begin_item ();
d1516 6
a1521 6
              /* Handle text directly after the @@item.  */
              if (*rest_of_line)
                {
                  line_number--;
                  input_text_offset = original_input_text_offset;
                }
d1529 4
a1532 1
            { /* If nothing has been output since the last <dd>,
d1536 4
a1539 1
              rollback_empty_tag ("dd");
d1542 1
a1542 1
                 each new @@item in a table.  But don't do that if
d1549 5
a1553 6
              if (!itemx_flag && html_deflist_has_term)
                add_html_block_elt ("<br>");

              /* We are about to insert a <dt>, so this <dl> has a term.
                 Feel free to insert a <br> next time. :)  */
              html_deflist_has_term = 1;
d1555 1
a1555 1
              add_html_block_elt ("<dt>");
d1566 5
a1570 2

              add_html_block_elt ("<dd>");
d1572 3
a1574 10
          else if (xml) /* && docbook)*/ /* 05-08 */
            {
              xml_begin_table_item ();

              if (!docbook && current_insertion_type () == ftable)
                execute_string ("%cfindex %s\n", COMMAND_PREFIX, rest_of_line);

              if (!docbook && current_insertion_type () == vtable)
                execute_string ("%cvindex %s\n", COMMAND_PREFIX, rest_of_line);

d1579 2
a1580 2
              xml_continue_table_item ();
            }
d1652 1
a1652 1
cm_itemx (void)
a1656 9
}

int headitem_flag = 0;

void
cm_headitem (void)
{
  headitem_flag = 1;
  cm_item ();
@


