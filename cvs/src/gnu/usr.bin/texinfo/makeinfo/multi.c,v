head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.48
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.46
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.42
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.38
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.40
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.32
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.36
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.34
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.30
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.6.0.4
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.2
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.01.17.45.27;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.05.22.19.16;	author avsm;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.42;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.13;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	96.12.15.21.39.29;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.15.21.39.29;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.59;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.25.29;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.21;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.48;	author espie;	state Exp;
branches;
next	;


desc
@@


1.7
log
@conflict resolution
@
text
@/* multi.c -- multiple-column tables (@@multitable) for makeinfo.
   $Id: multi.c,v 1.8 2004/04/11 17:56:47 karl Exp $

   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
   
   Originally written by phr@@gnu.org (Paul Rubin).  */

#include "system.h"
#include "cmds.h"
#include "insertion.h"
#include "makeinfo.h"
#include "multi.h"
#include "xml.h"

#define MAXCOLS 100             /* remove this limit later @@@@ */


/*
 * Output environments.  This is a hack grafted onto existing
 * structure.  The "output environment" used to consist of the
 * global variables `output_paragraph', `fill_column', etc.
 * Routines like add_char would manipulate these variables.
 *
 * Now, when formatting a multitable, we maintain separate environments
 * for each column.  That way we can build up the columns separately
 * and write them all out at once.  The "current" output environment"
 * is still kept in those global variables, so that the old output
 * routines don't have to change.  But we provide routines to save
 * and restore these variables in an "environment table".  The
 * `select_output_environment' function switches from one output
 * environment to another.
 *
 * Environment #0 (i.e., element #0 of the table) is the regular
 * environment that is used when we're not formatting a multitable.
 *
 * Environment #N (where N = 1,2,3,...) is the env. for column #N of
 * the table, when a multitable is active.
 */

/* contents of an output environment */
/* some more vars may end up being needed here later @@@@ */
struct env
{
  unsigned char *output_paragraph;
  int output_paragraph_offset;
  int meta_char_pos;
  int output_column;
  int paragraph_is_open;
  int current_indent;
  int fill_column;
} envs[MAXCOLS];                /* the environment table */

/* index in environment table of currently selected environment */
static int current_env_no;

/* current column number */
static int current_column_no;

/* We need to make a difference between template based widths and
   @@columnfractions for HTML tables' sake.  Sigh.  */
static int seen_column_fractions;

/* column number of last column in current multitable */
static int last_column;

/* flags indicating whether horizontal and vertical separators need
   to be drawn, separating rows and columns in the current multitable. */
static int hsep, vsep;

/* whether this is the first row. */
static int first_row;

/* Called to handle a {...} template on the @@multitable line.
   We're at the { and our first job is to find the matching }; as a side
   effect, we change *PARAMS to point to after it.  Our other job is to
   expand the template text and return the width of that string.  */
static unsigned
find_template_width (char **params)
{
  char *template, *xtemplate;
  unsigned len;
  char *start = *params;
  int brace_level = 0;

  /* The first character should be a {.  */
  if (!params || !*params || **params != '{')
    {
      line_error ("find_template width internal error: passed %s",
                  params ? *params : "null");
      return 0;
    }

  do
    {
      if (**params == '{' && (*params == start || (*params)[-1] != '@@'))
        brace_level++;
      else if (**params == '}' && (*params)[-1] != '@@')
        brace_level--;
      else if (**params == 0)
        {
          line_error (_("Missing } in @@multitable template"));
          return 0;
        }
      (*params)++;
    }
  while (brace_level > 0);
  
  template = substring (start + 1, *params - 1); /* omit braces */
  xtemplate = expansion (template, 0);
  len = strlen (xtemplate);
  
  free (template);
  free (xtemplate);
  
  return len;
}

/* Direct current output to environment number N.  Used when
   switching work from one column of a multitable to the next.
   Returns previous environment number. */
static int 
select_output_environment (int n)
{
  struct env *e = &envs[current_env_no];
  int old_env_no = current_env_no;

  /* stash current env info from global vars into the old environment */
  e->output_paragraph = output_paragraph;
  e->output_paragraph_offset = output_paragraph_offset;
  e->meta_char_pos = meta_char_pos;
  e->output_column = output_column;
  e->paragraph_is_open = paragraph_is_open;
  e->current_indent = current_indent;
  e->fill_column = fill_column;

  /* now copy new environment into global vars */
  current_env_no = n;
  e = &envs[current_env_no];
  output_paragraph = e->output_paragraph;
  output_paragraph_offset = e->output_paragraph_offset;
  meta_char_pos = e->meta_char_pos;
  output_column = e->output_column;
  paragraph_is_open = e->paragraph_is_open;
  current_indent = e->current_indent;
  fill_column = e->fill_column;
  return old_env_no;
}

/* Initialize environment number ENV_NO, of width WIDTH.
   The idea is that we're going to use one environment for each column of
   a multitable, so we can build them up separately and print them
   all out at the end. */
static int
setup_output_environment (int env_no, int width)
{
  int old_env = select_output_environment (env_no);

  /* clobber old environment and set width of new one */
  init_paragraph ();

  /* make our change */
  fill_column = width;

  /* Save new environment and restore previous one. */
  select_output_environment (old_env);

  return env_no;
}

/* Read the parameters for a multitable from the current command
   line, save the parameters away, and return the
   number of columns. */
static int
setup_multitable_parameters (void)
{
  char *params = insertion_stack->item_function;
  int nchars;
  float columnfrac;
  char command[200]; /* xx no fixed limits */
  int i = 1;

  /* We implement @@hsep and @@vsep even though TeX doesn't.
     We don't get mixing of @@columnfractions and templates right,
     but TeX doesn't either.  */
  hsep = vsep = 0;

  /* Assume no @@columnfractions per default.  */
  seen_column_fractions = 0;

  while (*params) {
    while (whitespace (*params))
      params++;

    if (*params == '@@') {
      sscanf (params, "%199s", command);
      nchars = strlen (command);
      params += nchars;
      if (strcmp (command, "@@hsep") == 0)
        hsep++;
      else if (strcmp (command, "@@vsep") == 0)
        vsep++;
      else if (strcmp (command, "@@columnfractions") == 0) {
        seen_column_fractions = 1;
        /* Clobber old environments and create new ones, starting at #1.
           Environment #0 is the normal output, so don't mess with it. */
        for ( ; i <= MAXCOLS; i++) {
          if (sscanf (params, "%f", &columnfrac) < 1)
            goto done;
          /* Unfortunately, can't use %n since m68k-hp-bsd libc (at least)
             doesn't support it.  So skip whitespace (preceding the
             number) and then non-whitespace (the number).  */
          while (*params && (*params == ' ' || *params == '\t'))
            params++;
          /* Hmm, but what about @@columnfractions 3foo.  Oh well, 
             it's invalid input anyway.  */
          while (*params && *params != ' ' && *params != '\t'
                 && *params != '\n' && *params != '@@')
            params++;

          {
            /* For html/xml/docbook, translate fractions into integer
               percentages, adding .005 to avoid rounding problems.  For
               info, we want the character width.  */
            int width = xml || html ? (columnfrac + .005) * 100
                        : (columnfrac * (fill_column - current_indent) + .5);
            setup_output_environment (i, width);
          }
        }
      }

    } else if (*params == '{') {
      unsigned template_width = find_template_width (&params);

      /* This gives us two spaces between columns.  Seems reasonable.
         How to take into account current_indent here?  */
      setup_output_environment (i++, template_width + 2);
      
    } else {
      warning (_("ignoring stray text `%s' after @@multitable"), params);
      break;
    }
  }

done:
  flush_output ();
  inhibit_output_flushing ();

  last_column = i - 1;
  return last_column;
}

/* Output a row.  Calls insert, but also flushes the buffered output
   when we see a newline, since in multitable every line is a separate
   paragraph.  */
static void
out_char (int ch)
{
  if (html || xml)
    add_char (ch);
  else
    {
      int env = select_output_environment (0);
      insert (ch);
      if (ch == '\n')
	{
	  uninhibit_output_flushing ();
	  flush_output ();
	  inhibit_output_flushing ();
	}
      select_output_environment (env);
    }
}


static void
draw_horizontal_separator (void)
{
  int i, j, s;

  if (html)
    {
      add_word ("<hr>");
      return;
    }
  if (xml)
    return;

  for (s = 0; s < envs[0].current_indent; s++)
    out_char (' ');
  if (vsep)
    out_char ('+');
  for (i = 1; i <= last_column; i++) {
    for (j = 0; j <= envs[i].fill_column; j++)
      out_char ('-');
    if (vsep)
      out_char ('+');
  }
  out_char (' ');
  out_char ('\n');
}


/* multitable strategy:
    for each item {
       for each column in an item {
        initialize a new paragraph
        do ordinary formatting into the new paragraph
        save the paragraph away
        repeat if there are more paragraphs in the column
      }
      dump out the saved paragraphs and free the storage
    }

   For HTML we construct a simple HTML 3.2 table with <br>s inserted
   to help non-tables browsers.  `@@item' inserts a <tr> and `@@tab'
   inserts <td>; we also try to close <tr>.  The only real
   alternative is to rely on the info formatting engine and present
   preformatted text.  */

void
do_multitable (void)
{
  int ncolumns;

  if (multitable_active)
    {
      line_error ("Multitables cannot be nested");
      return;
    }

  close_single_paragraph ();

  if (xml)
    {
      xml_no_para = 1;
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
    }

  /* scan the current item function to get the field widths
     and number of columns, and set up the output environment list
     accordingly. */
  ncolumns = setup_multitable_parameters ();
  first_row = 1;

  /* <p> for non-tables browsers.  @@multitable implicitly ends the
     current paragraph, so this is ok.  */
  if (html)
    add_html_block_elt ("<p><table summary=\"\">");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      int *widths = xmalloc (ncolumns * sizeof (int));
      int i;
      for (i=0; i<ncolumns; i++)
	widths[i] = envs[i+1].fill_column;
      xml_begin_multitable (ncolumns, widths);
      free (widths);
    }

  if (hsep)
    draw_horizontal_separator ();

  /* The next @@item command will direct stdout into the first column
     and start processing.  @@tab will then switch to the next column,
     and @@item will flush out the saved output and return to the first
     column.  Environment #1 is the first column.  (Environment #0 is
     the normal output) */

  ++multitable_active;
}

/* advance to the next environment number */
static void
nselect_next_environment (void)
{
  if (current_env_no >= last_column) {
    line_error (_("Too many columns in multitable item (max %d)"), last_column);
    return;
  }
  select_output_environment (current_env_no + 1);
}


/* do anything needed at the beginning of processing a
   multitable column. */
static void
init_column (void)
{
  /* don't indent 1st paragraph in the item */
  cm_noindent ();

  /* throw away possible whitespace after @@item or @@tab command */
  skip_whitespace ();
}

static void
output_multitable_row (void)
{
  /* offset in the output paragraph of the next char needing
     to be output for that column. */
  int offset[MAXCOLS];
  int i, j, s, remaining;
  int had_newline = 0;

  for (i = 0; i <= last_column; i++)
    offset[i] = 0;

  /* select the current environment, to make sure the env variables
     get updated */
  select_output_environment (current_env_no);

#define CHAR_ADDR(n) (offset[i] + (n))
#define CHAR_AT(n) (envs[i].output_paragraph[CHAR_ADDR(n)])

  /* remove trailing whitespace from each column */
  for (i = 1; i <= last_column; i++) {
      while (envs[i].output_paragraph_offset &&
             cr_or_whitespace (CHAR_AT (envs[i].output_paragraph_offset - 1)))
        envs[i].output_paragraph_offset--;

    if (i == current_env_no)
      output_paragraph_offset = envs[i].output_paragraph_offset;
  }

  /* read the current line from each column, outputting them all
     pasted together.  Do this til all lines are output from all
     columns.  */
  for (;;) {
    remaining = 0;
    /* first, see if there is any work to do */
    for (i = 1; i <= last_column; i++) {
      if (CHAR_ADDR (0) < envs[i].output_paragraph_offset) {
        remaining = 1;
        break;
      }
    }
    if (!remaining)
      break;
    
    for (s = 0; s < envs[0].current_indent; s++)
      out_char (' ');
    
    if (vsep)
      out_char ('|');

    for (i = 1; i <= last_column; i++) {
      for (s = 0; s < envs[i].current_indent; s++)
        out_char (' ');
      for (j = 0; CHAR_ADDR (j) < envs[i].output_paragraph_offset; j++) {
        if (CHAR_AT (j) == '\n')
          break;
        out_char (CHAR_AT (j));
      }
      offset[i] += j + 1;       /* skip last text plus skip the newline */
      
      /* Do not output trailing blanks if we're in the last column and
         there will be no trailing |.  */
      if (i < last_column && !vsep)
        for (; j <= envs[i].fill_column; j++)
          out_char (' ');
      if (vsep)
        out_char ('|'); /* draw column separator */
    }
    out_char ('\n');    /* end of line */
    had_newline = 1;
  }
  
  /* If completely blank item, get blank line despite no other output.  */
  if (!had_newline)
    out_char ('\n');    /* end of line */

  if (hsep)
    draw_horizontal_separator ();

  /* Now dispose of the buffered output. */
  for (i = 1; i <= last_column; i++) {
    select_output_environment (i);
    init_paragraph ();
  }
}

int after_headitem = 0;
int headitem_row = 0;

/* start a new item (row) of a multitable */
int
multitable_item (void)
{
  if (!multitable_active) {
    line_error ("multitable_item internal error: no active multitable");
    xexit (1);
  }

  current_column_no = 1;

  if (html)
    {
      if (!first_row)
        /* <br> for non-tables browsers. */
	add_word_args ("<br></%s></tr>", after_headitem ? "th" : "td");

      if (seen_column_fractions)
        add_word_args ("<tr align=\"left\"><%s valign=\"top\" width=\"%d%%\">",
            headitem_flag ? "th" : "td",
            envs[current_column_no].fill_column);
      else
        add_word_args ("<tr align=\"left\"><%s valign=\"top\">",
            headitem_flag ? "th" : "td");

      if (headitem_flag)
        after_headitem = 1;
      else
        after_headitem = 0;
      first_row = 0;
      headitem_row = headitem_flag;
      headitem_flag = 0;
      return 0;
    }
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      xml_end_multitable_row (first_row);
      if (headitem_flag)
        after_headitem = 1;
      else
        after_headitem = 0;
      first_row = 0;
      headitem_flag = 0;
      return 0;
    }
  first_row = 0;

  if (current_env_no > 0) {
    output_multitable_row ();
  }
  /* start at column 1 */
  select_output_environment (1);
  if (!output_paragraph) {
    line_error (_("[unexpected] cannot select column #%d in multitable"),
                current_env_no);
    xexit (1);
  }

  init_column ();

  if (headitem_flag)
    hsep = 1;
  else
    hsep = 0;

  if (headitem_flag)
    after_headitem = 1;
  else
    after_headitem = 0;
  headitem_flag = 0;

  return 0;
}

#undef CHAR_AT
#undef CHAR_ADDR

/* select a new column in current row of multitable */
void
cm_tab (void)
{
  if (!multitable_active)
    error (_("ignoring @@tab outside of multitable"));

  current_column_no++;
  
  if (html)
    {
      if (seen_column_fractions)
        add_word_args ("</%s><%s valign=\"top\" width=\"%d%%\">",
            headitem_row ? "th" : "td",
            headitem_row ? "th" : "td",
            envs[current_column_no].fill_column);
      else
        add_word_args ("</%s><%s valign=\"top\">",
            headitem_row ? "th" : "td",
            headitem_row ? "th" : "td");
    }
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    xml_end_multitable_column ();
  else
    nselect_next_environment ();

  init_column ();
}

/* close a multitable, flushing its output and resetting
   whatever needs resetting */
void
end_multitable (void)
{
  if (!html && !docbook) 
    output_multitable_row ();

  /* Multitables cannot be nested.  Otherwise, we'd have to save the
     previous output environment number on a stack somewhere, and then
     restore to that environment.  */
  select_output_environment (0);
  multitable_active = 0;
  uninhibit_output_flushing ();
  close_insertion_paragraph ();

  if (html)
    add_word_args ("<br></%s></tr></table>\n", headitem_row ? "th" : "td");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    xml_end_multitable ();

#if 0
  printf (_("** Multicolumn output from last row:\n"));
  for (i = 1; i <= last_column; i++) {
    select_output_environment (i);
    printf (_("* column #%d: output = %s\n"), i, output_paragraph);
  }
#endif
}
@


1.6
log
@Avoid out of bounds access; Andreas Vogele" <voegelas at gmx dot net>
@
text
@d1 2
a2 2
/* multi.c -- multitable stuff for makeinfo.
   $Id: multi.c,v 1.5 2003/05/05 22:19:16 avsm Exp $
d4 2
a5 1
   Copyright (C) 1996, 97, 98, 99, 2000, 01, 02 Free Software Foundation, Inc.
d21 1
a21 1
   Written by phr@@gnu.org (Paul Rubin).  */
d24 1
d27 1
d71 7
a86 53

static void output_multitable_row ();

/* Output a row.  Calls insert, but also flushes the buffered output
   when we see a newline, since in multitable every line is a separate
   paragraph.  */
static void
out_char (ch)
    int ch;
{
  if (html)
    add_char (ch);
  else
    {
      int env = select_output_environment (0);
      insert (ch);
      if (ch == '\n')
	{
	  uninhibit_output_flushing ();
	  flush_output ();
	  inhibit_output_flushing ();
	}
      select_output_environment (env);
    }
}


void
draw_horizontal_separator ()
{
  int i, j, s;

  if (html)
    {
      add_word ("<hr>");
      return;
    }
  if (xml)
    return;

  for (s = 0; s < envs[0].current_indent; s++)
    out_char (' ');
  if (vsep)
    out_char ('+');
  for (i = 1; i <= last_column; i++) {
    for (j = 0; j <= envs[i].fill_column; j++)
      out_char ('-');
    if (vsep)
      out_char ('+');
  }
  out_char ('\n');
}

a87 66
/* multitable strategy:
    for each item {
       for each column in an item {
        initialize a new paragraph
        do ordinary formatting into the new paragraph
        save the paragraph away
        repeat if there are more paragraphs in the column
      }
      dump out the saved paragraphs and free the storage
    }

   For HTML we construct a simple HTML 3.2 table with <br>s inserted
   to help non-tables browsers.  `@@item' inserts a <tr> and `@@tab'
   inserts <td>; we also try to close <tr>.  The only real
   alternative is to rely on the info formatting engine and present
   preformatted text.  */

void
do_multitable ()
{
  int ncolumns;

  if (multitable_active)
    {
      line_error ("Multitables cannot be nested");
      return;
    }

  close_single_paragraph ();

  /* scan the current item function to get the field widths
     and number of columns, and set up the output environment list
     accordingly. */
  /*  if (docbook)*/ /* 05-08 */
  if (xml)
    xml_no_para = 1;
  ncolumns = setup_multitable_parameters ();
  first_row = 1;

  /* <p> for non-tables browsers.  @@multitable implicitly ends the
     current paragraph, so this is ok.  */
  if (html)
    add_word ("<p><table>");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      int *widths = xmalloc (ncolumns * sizeof (int));
      int i;
      for (i=0; i<ncolumns; i++)
	widths[i] = envs[i+1].fill_column;
      xml_begin_multitable (ncolumns, widths);
      free (widths);
    }

  if (hsep)
    draw_horizontal_separator ();

  /* The next @@item command will direct stdout into the first column
     and start processing.  @@tab will then switch to the next column,
     and @@item will flush out the saved output and return to the first
     column.  Environment #1 is the first column.  (Environment #0 is
     the normal output) */

  ++multitable_active;
}

d93 1
a93 2
find_template_width (params)
     char **params;
d133 51
d188 2
a189 2
int
setup_multitable_parameters ()
d202 3
d218 1
d229 1
a229 1
          /* Hmm, but what about @@columnfractions 3foo.  Well, I suppose
d234 9
a242 2
          setup_output_environment (i,
                     (int) (columnfrac * (fill_column - current_indent) + .5));
d248 1
a248 1
      
d267 5
a271 8
/* Initialize environment number ENV_NO, of width WIDTH.
   The idea is that we're going to use one environment for each column of
   a multitable, so we can build them up separately and print them
   all out at the end. */
int
setup_output_environment (env_no, width)
    int env_no;
    int width;
d273 15
a287 1
  int old_env = select_output_environment (env_no);
a288 2
  /* clobber old environment and set width of new one */
  init_paragraph ();
d290 4
a293 2
  /* make our change */
  fill_column = width;
d295 7
a301 2
  /* Save new environment and restore previous one. */
  select_output_environment (old_env);
d303 12
a314 1
  return env_no;
d317 20
a336 6
/* Direct current output to environment number N.  Used when
   switching work from one column of a multitable to the next.
   Returns previous environment number. */
int 
select_output_environment (n)
    int n;
d338 40
a377 2
  struct env *e = &envs[current_env_no];
  int old_env_no = current_env_no;
d379 5
a383 8
  /* stash current env info from global vars into the old environment */
  e->output_paragraph = output_paragraph;
  e->output_paragraph_offset = output_paragraph_offset;
  e->meta_char_pos = meta_char_pos;
  e->output_column = output_column;
  e->paragraph_is_open = paragraph_is_open;
  e->current_indent = current_indent;
  e->fill_column = fill_column;
d385 1
a385 11
  /* now copy new environment into global vars */
  current_env_no = n;
  e = &envs[current_env_no];
  output_paragraph = e->output_paragraph;
  output_paragraph_offset = e->output_paragraph_offset;
  meta_char_pos = e->meta_char_pos;
  output_column = e->output_column;
  paragraph_is_open = e->paragraph_is_open;
  current_indent = e->current_indent;
  fill_column = e->fill_column;
  return old_env_no;
d389 2
a390 2
void
nselect_next_environment ()
d402 2
a403 2
void
init_column ()
a411 41
/* start a new item (row) of a multitable */
int
multitable_item ()
{
  if (!multitable_active) {
    line_error ("multitable_item internal error: no active multitable");
    xexit (1);
  }

  if (html)
    {
      if (!first_row)
	add_word ("<br></td></tr>");	/* <br> for non-tables browsers. */
      add_word ("<tr align=\"left\"><td valign=\"top\">");
      first_row = 0;
      return 0;
    }
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      xml_end_multitable_row (first_row);
      first_row = 0;
      return 0;
    }
  first_row = 0;

  if (current_env_no > 0) {
    output_multitable_row ();
  }
  /* start at column 1 */
  select_output_environment (1);
  if (!output_paragraph) {
    line_error (_("Cannot select column #%d in multitable"), current_env_no);
    exit (1);
  }

  init_column ();

  return 0;
}

d413 1
a413 1
output_multitable_row ()
d498 78
d581 1
a581 1
cm_tab ()
d585 2
d589 11
a599 1
    add_word ("</td><td valign=\"top\">");
d612 1
a612 1
end_multitable ()
d626 1
a626 1
    add_word ("<br></td></tr></table>\n");
@


1.5
log
@correct incorrect off-by-one sscanf bound
millert@@ ok
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.4 2002/06/10 13:51:03 espie Exp $
d456 2
a457 2
    if (envs[i].output_paragraph_offset)
      while (cr_or_whitespace (CHAR_AT (envs[i].output_paragraph_offset - 1)))
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.23 2002/01/19 01:09:08 karl Exp $
d266 1
a266 1
      sscanf (params, "%200s", command);
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.18 1999/08/17 21:06:56 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.
d18 3
a20 1
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
d114 2
d164 3
d174 10
d220 1
a220 1
      if (**params == '{' && (*params)[-1] != '@@')
d406 2
a407 2
	add_word ("<br></tr>");	/* <br> for non-tables browsers. */
      add_word ("<tr align=\"left\"><td>");
d409 8
a416 1
      return;
d532 4
a535 1
    add_word ("<td>");
d547 1
a547 1
  if (!html) 
d559 4
a562 1
    add_word ("<br></tr></table>\n");
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.9 1997/07/24 22:01:00 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97 Free Software Foundation, Inc.
d21 1
d55 1
d71 5
d77 3
a79 6
/* Output a row.  Have to keep `output_position' up-to-date for each
   character we output, or the tags table will be off, leading to
   chopped-off output files and undefined nodes (because they're in the
   wrong file, etc.).  Perhaps it would be better to accumulate this
   value somewhere and add it once at the end of the table, or return it
   as the value, but this seems simplest.  */
d84 14
a97 3
  extern int output_position;
  putc (ch, output_stream);
  output_position++;
d106 6
d125 18
a147 13
  /*
   *  multitable strategy:
   *  for each item {
   *     for each column in an item {
   *      initialize a new paragraph
   *      do ordinary formatting into the new paragraph
   *      save the paragraph away
   *      repeat if there are more paragraphs in the column
   *    }
   *    dump out the saved paragraphs and free the storage
   *  }
   */

d154 2
d160 7
d179 47
d235 1
a235 1
  char command[200]; /* naughty, should be no fixed limits */
d261 1
a261 1
          /* Unfortunately, can't use %n since some m68k-hp-bsd libc
d266 1
a266 1
          /* Hmm, but what what @@columnfractions 3foo.  Well, I suppose
d277 2
a278 4
      char *start = params;
      while ((*params != '}' || params[-1] == '@@') && *params) {
        params++;
      }
d280 2
a281 4
         Really should expand the text, though, so a template of
         `@@code{foo}' has a width of five, not ten.  Also have to match
         braces, then.  How to take into account current_indent here?  */
      setup_output_environment (i++, params++ - start);
d333 1
d344 1
a363 2
static void output_multitable_row ();

d381 2
a382 3
    /* impossible, I think. */
    error (_("multitable item not in active multitable"));
    exit (1);
d384 11
d402 1
a402 1
    exit (FATAL);
a412 2
  int i, j, s, remaining;

d416 2
d431 6
a436 3
    while (cr_or_whitespace (CHAR_AT (envs[i].output_paragraph_offset - 1))) {
      envs[i].output_paragraph_offset--;
    }
d461 1
a461 1
      for (s = 0; i < envs[i].current_indent; s++)
d469 6
a474 2
      for (; j <= envs[i].fill_column; j++)
        out_char (' ');
d479 1
d481 4
d506 5
a510 1
  nselect_next_environment ();
d519 2
a520 1
  output_multitable_row ();
a525 3
  close_paragraph ();
  insert ('\n'); /* we swallow newlines, so insert one of our own */
  
d528 4
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* multi.c -- Multitable stuff for makeinfo.
   $Id: multi.c,v 1.7 1996/10/01 21:42:20 karl Exp $
d4 1
a4 1
   Copyright (C) 1996 Free Software Foundation, Inc.
d20 1
a20 1
#include <stdio.h>
d23 1
a23 1
#define MAXCOLS 100		/* remove this limit later @@@@ */
d41 1
a41 1
 * Environment #0 (i.e. element #0 of the table) is the regular
d58 1
a58 1
} envs[MAXCOLS];		/* the environment table */
d70 34
d153 1
a153 1
  char command[200];
d166 2
a167 1
      sscanf (params, "%s%n", command, &nchars);
d170 1
a170 1
	hsep++;
d172 1
a172 1
	vsep++;
d174 18
a191 9
	/* Clobber old environments and create new ones,
	   starting at #1.  Environment #0 is the normal standard output,
	   so we don't mess with it. */
	for ( ; i <= MAXCOLS; i++) {
	  if (sscanf (params, "%f%n", &columnfrac, &nchars) < 1)
	    goto done;
	  params += nchars;
	  setup_output_environment (i, (int) (columnfrac * fill_column + .5));
	}
d201 2
a202 2
         `@@code{foo}' has a width of three, not ten.  Also have to match
         braces, then.  */
d206 1
a206 1
      warning ("ignoring stray text `%s' after @@multitable", params);
a211 1

d273 1
a273 1
int
d277 2
a278 2
    line_error ("Too many columns in multitable item (max %d)", last_column);
    return 1;
d286 12
d299 1
d304 1
a304 1
    error ("multitable item not in active multitable");
d313 1
a313 1
    line_error ("Cannot select column #%d in multitable", current_env_no);
a321 28
/* do anything needed at the beginning of processing a
   multitable column. */
init_column ()
{
  /* don't indent 1st paragraph in the item */
  cm_noindent ();

  /* throw away possible whitespace after @@item or @@tab command */
  skip_whitespace ();
}

/* Output a row.  Have to keep `output_position' up-to-date for each
   character we output, or the tags table will be off, leading to
   chopped-off output files and undefined nodes (because they're in the
   wrong file, etc.).  Perhaps it would be better to accumulate this
   value somewhere and add it once at the end of the table, or return it
   as the value, but this seems simplest.  */

static void
out_char (ch)
    int ch;
{
  extern int output_position;
  putc (ch, output_stream);
  output_position++;
}


d325 1
a325 1
  int i, j, remaining;
d356 2
a357 2
	remaining = 1;
	break;
d362 4
a365 1

d370 2
d373 3
a375 3
	if (CHAR_AT (j) == '\n')
	  break;
	out_char (CHAR_AT (j));
d377 1
a377 1
      offset[i] += j + 1;	/* skip last text plus skip the newline */
d379 1
a379 1
	out_char (' ');
d381 1
a381 1
	out_char ('|');	/* draw column separator */
d383 1
a383 1
    out_char ('\n');	/* end of line */
a398 15
int
draw_horizontal_separator ()
{
  int i, j;
  if (vsep)
    out_char ('+');
  for (i = 1; i <= last_column; i++) {
    for (j = 0; j <= envs[i].fill_column; j++)
      out_char ('-');
    if (vsep)
      out_char ('+');
  }
  out_char ('\n');
}

d404 1
a404 1
    error ("ignoring @@tab outside of multitable");
a414 2
  int i;

d428 1
a428 1
  printf ("** Multicolumn output from last row:\n");
d431 1
a431 1
    printf ("* column #%d: output = %s\n", i, output_paragraph);
@


1.1.1.1
log
@Import of texinfo-3.9.
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 2
a2 2
/* multi.c -- multitable stuff for makeinfo.
   $Id: multi.c,v 1.9 1997/07/24 22:01:00 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97 Free Software Foundation, Inc.
d20 1
a20 1
#include "system.h"
d23 1
a23 1
#define MAXCOLS 100             /* remove this limit later @@@@ */
d41 1
a41 1
 * Environment #0 (i.e., element #0 of the table) is the regular
d58 1
a58 1
} envs[MAXCOLS];                /* the environment table */
a69 34
/* Output a row.  Have to keep `output_position' up-to-date for each
   character we output, or the tags table will be off, leading to
   chopped-off output files and undefined nodes (because they're in the
   wrong file, etc.).  Perhaps it would be better to accumulate this
   value somewhere and add it once at the end of the table, or return it
   as the value, but this seems simplest.  */
static void
out_char (ch)
    int ch;
{
  extern int output_position;
  putc (ch, output_stream);
  output_position++;
}


void
draw_horizontal_separator ()
{
  int i, j, s;

  for (s = 0; s < envs[0].current_indent; s++)
    out_char (' ');
  if (vsep)
    out_char ('+');
  for (i = 1; i <= last_column; i++) {
    for (j = 0; j <= envs[i].fill_column; j++)
      out_char ('-');
    if (vsep)
      out_char ('+');
  }
  out_char ('\n');
}

d119 1
a119 1
  char command[200]; /* naughty, should be no fixed limits */
d132 1
a132 2
      sscanf (params, "%200s", command);
      nchars = strlen (command);
d135 1
a135 1
        hsep++;
d137 1
a137 1
        vsep++;
d139 9
a147 18
        /* Clobber old environments and create new ones, starting at #1.
           Environment #0 is the normal output, so don't mess with it. */
        for ( ; i <= MAXCOLS; i++) {
          if (sscanf (params, "%f", &columnfrac) < 1)
            goto done;
          /* Unfortunately, can't use %n since some m68k-hp-bsd libc
             doesn't support it.  So skip whitespace (preceding the
             number) and then non-whitespace (the number).  */
          while (*params && (*params == ' ' || *params == '\t'))
            params++;
          /* Hmm, but what what @@columnfractions 3foo.  Well, I suppose
             it's invalid input anyway.  */
          while (*params && *params != ' ' && *params != '\t'
                 && *params != '\n' && *params != '@@')
            params++;
          setup_output_environment (i,
                     (int) (columnfrac * (fill_column - current_indent) + .5));
        }
d157 2
a158 2
         `@@code{foo}' has a width of five, not ten.  Also have to match
         braces, then.  How to take into account current_indent here?  */
d162 1
a162 1
      warning (_("ignoring stray text `%s' after @@multitable"), params);
d168 1
d230 1
a230 1
void
d234 2
a235 2
    line_error (_("Too many columns in multitable item (max %d)"), last_column);
    return;
a242 12
/* do anything needed at the beginning of processing a
   multitable column. */
void
init_column ()
{
  /* don't indent 1st paragraph in the item */
  cm_noindent ();

  /* throw away possible whitespace after @@item or @@tab command */
  skip_whitespace ();
}

a243 1
int
d248 1
a248 1
    error (_("multitable item not in active multitable"));
d257 1
a257 1
    line_error (_("Cannot select column #%d in multitable"), current_env_no);
d266 28
d297 1
a297 1
  int i, j, s, remaining;
d328 2
a329 2
        remaining = 1;
        break;
d334 1
a334 4
    
    for (s = 0; s < envs[0].current_indent; s++)
      out_char (' ');
    
a338 2
      for (s = 0; i < envs[i].current_indent; s++)
        out_char (' ');
d340 3
a342 3
        if (CHAR_AT (j) == '\n')
          break;
        out_char (CHAR_AT (j));
d344 1
a344 1
      offset[i] += j + 1;       /* skip last text plus skip the newline */
d346 1
a346 1
        out_char (' ');
d348 1
a348 1
        out_char ('|'); /* draw column separator */
d350 1
a350 1
    out_char ('\n');    /* end of line */
d366 15
d386 1
a386 1
    error (_("ignoring @@tab outside of multitable"));
d397 2
d412 1
a412 1
  printf (_("** Multicolumn output from last row:\n"));
d415 1
a415 1
    printf (_("* column #%d: output = %s\n"), i, output_paragraph);
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.18 1999/08/17 21:06:56 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.
a20 1
#include "insertion.h"
a53 1
  int meta_char_pos;
a68 5

/* whether this is the first row. */
static int first_row;

static void output_multitable_row ();
d70 6
a75 3
/* Output a row.  Calls insert, but also flushes the buffered output
   when we see a newline, since in multitable every line is a separate
   paragraph.  */
d80 3
a82 14
  if (html)
    add_char (ch);
  else
    {
      int env = select_output_environment (0);
      insert (ch);
      if (ch == '\n')
	{
	  uninhibit_output_flushing ();
	  flush_output ();
	  inhibit_output_flushing ();
	}
      select_output_environment (env);
    }
a90 6
  if (html)
    {
      add_word ("<hr>");
      return;
    }

a103 18

/* multitable strategy:
    for each item {
       for each column in an item {
        initialize a new paragraph
        do ordinary formatting into the new paragraph
        save the paragraph away
        repeat if there are more paragraphs in the column
      }
      dump out the saved paragraphs and free the storage
    }

   For HTML we construct a simple HTML 3.2 table with <br>s inserted
   to help non-tables browsers.  `@@item' inserts a <tr> and `@@tab'
   inserts <td>; we also try to close <tr>.  The only real
   alternative is to rely on the info formatting engine and present
   preformatted text.  */

d109 13
a127 2
  close_single_paragraph ();

a131 7
  first_row = 1;

  /* <p> for non-tables browsers.  @@multitable implicitly ends the
     current paragraph, so this is ok.  */
  if (html)
    add_word ("<p><table>");

a143 47
/* Called to handle a {...} template on the @@multitable line.
   We're at the { and our first job is to find the matching }; as a side
   effect, we change *PARAMS to point to after it.  Our other job is to
   expand the template text and return the width of that string.  */
static unsigned
find_template_width (params)
     char **params;
{
  char *template, *xtemplate;
  unsigned len;
  char *start = *params;
  int brace_level = 0;

  /* The first character should be a {.  */
  if (!params || !*params || **params != '{')
    {
      line_error ("find_template width internal error: passed %s",
                  params ? *params : "null");
      return 0;
    }

  do
    {
      if (**params == '{' && (*params)[-1] != '@@')
        brace_level++;
      else if (**params == '}' && (*params)[-1] != '@@')
        brace_level--;
      else if (**params == 0)
        {
          line_error (_("Missing } in @@multitable template"));
          return 0;
        }
      (*params)++;
    }
  while (brace_level > 0);
  
  template = substring (start + 1, *params - 1); /* omit braces */
  xtemplate = expansion (template, 0);
  len = strlen (xtemplate);
  
  free (template);
  free (xtemplate);
  
  return len;
}


d153 1
a153 1
  char command[200]; /* xx no fixed limits */
d179 1
a179 1
          /* Unfortunately, can't use %n since m68k-hp-bsd libc (at least)
d184 1
a184 1
          /* Hmm, but what about @@columnfractions 3foo.  Well, I suppose
d195 4
a198 2
      unsigned template_width = find_template_width (&params);
      
d200 4
a203 2
         How to take into account current_indent here?  */
      setup_output_environment (i++, template_width + 2);
a254 1
  e->meta_char_pos = meta_char_pos;
a264 1
  meta_char_pos = e->meta_char_pos;
d284 2
d303 3
a305 2
    line_error ("multitable_item internal error: no active multitable");
    xexit (1);
a306 11

  if (html)
    {
      if (!first_row)
	add_word ("<br></tr>");	/* <br> for non-tables browsers. */
      add_word ("<tr align=\"left\"><td>");
      first_row = 0;
      return;
    }
  first_row = 0;

d314 1
a314 1
    exit (1);
d325 2
a329 2
  int i, j, s, remaining;
  int had_newline = 0;
d343 3
a345 6
    if (envs[i].output_paragraph_offset)
      while (cr_or_whitespace (CHAR_AT (envs[i].output_paragraph_offset - 1)))
        envs[i].output_paragraph_offset--;

    if (i == current_env_no)
      output_paragraph_offset = envs[i].output_paragraph_offset;
d370 1
a370 1
      for (s = 0; s < envs[i].current_indent; s++)
d378 2
a379 6
      
      /* Do not output trailing blanks if we're in the last column and
         there will be no trailing |.  */
      if (i < last_column && !vsep)
        for (; j <= envs[i].fill_column; j++)
          out_char (' ');
a383 1
    had_newline = 1;
a384 4
  
  /* If completely blank item, get blank line despite no other output.  */
  if (!had_newline)
    out_char ('\n');    /* end of line */
d406 1
a406 5
  if (html)
    add_word ("<td>");
  else
    nselect_next_environment ();

d415 1
a415 2
  if (!html) 
    output_multitable_row ();
d421 3
a425 4
  close_insertion_paragraph ();

  if (html)
    add_word ("<br></tr></table>\n");
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: multi.c,v 1.23 2002/01/19 01:09:08 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99, 2000, 01, 02 Free Software Foundation, Inc.
d18 1
a18 3
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
   
   Written by phr@@gnu.org (Paul Rubin).  */
a22 1
#include "xml.h"
a110 2
  if (xml)
    return;
a158 3
  /*  if (docbook)*/ /* 05-08 */
  if (xml)
    xml_no_para = 1;
a165 10
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      int *widths = xmalloc (ncolumns * sizeof (int));
      int i;
      for (i=0; i<ncolumns; i++)
	widths[i] = envs[i+1].fill_column;
      xml_begin_multitable (ncolumns, widths);
      free (widths);
    }
d202 1
a202 1
      if (**params == '{' && (*params == start || (*params)[-1] != '@@'))
d388 2
a389 2
	add_word ("<br></td></tr>");	/* <br> for non-tables browsers. */
      add_word ("<tr align=\"left\"><td valign=\"top\">");
d391 1
a391 8
      return 0;
    }
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      xml_end_multitable_row (first_row);
      first_row = 0;
      return 0;
d507 1
a507 4
    add_word ("</td><td valign=\"top\">");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    xml_end_multitable_column ();
d519 1
a519 1
  if (!html && !docbook) 
d531 1
a531 4
    add_word ("<br></td></tr></table>\n");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    xml_end_multitable ();
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* multi.c -- multiple-column tables (@@multitable) for makeinfo.
   $Id: multi.c,v 1.8 2004/04/11 17:56:47 karl Exp $
d4 1
a4 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free Software
   Foundation, Inc.
d20 1
a20 1
   Originally written by phr@@gnu.org (Paul Rubin).  */
a22 1
#include "cmds.h"
a24 1
#include "multi.h"
a67 7
/* current column number */
static int current_column_no;

/* We need to make a difference between template based widths and
   @@columnfractions for HTML tables' sake.  Sigh.  */
static int seen_column_fractions;

d77 53
d131 66
d202 2
a203 1
find_template_width (char **params)
a242 51
/* Direct current output to environment number N.  Used when
   switching work from one column of a multitable to the next.
   Returns previous environment number. */
static int 
select_output_environment (int n)
{
  struct env *e = &envs[current_env_no];
  int old_env_no = current_env_no;

  /* stash current env info from global vars into the old environment */
  e->output_paragraph = output_paragraph;
  e->output_paragraph_offset = output_paragraph_offset;
  e->meta_char_pos = meta_char_pos;
  e->output_column = output_column;
  e->paragraph_is_open = paragraph_is_open;
  e->current_indent = current_indent;
  e->fill_column = fill_column;

  /* now copy new environment into global vars */
  current_env_no = n;
  e = &envs[current_env_no];
  output_paragraph = e->output_paragraph;
  output_paragraph_offset = e->output_paragraph_offset;
  meta_char_pos = e->meta_char_pos;
  output_column = e->output_column;
  paragraph_is_open = e->paragraph_is_open;
  current_indent = e->current_indent;
  fill_column = e->fill_column;
  return old_env_no;
}

/* Initialize environment number ENV_NO, of width WIDTH.
   The idea is that we're going to use one environment for each column of
   a multitable, so we can build them up separately and print them
   all out at the end. */
static int
setup_output_environment (int env_no, int width)
{
  int old_env = select_output_environment (env_no);

  /* clobber old environment and set width of new one */
  init_paragraph ();

  /* make our change */
  fill_column = width;

  /* Save new environment and restore previous one. */
  select_output_environment (old_env);

  return env_no;
}
d247 2
a248 2
static int
setup_multitable_parameters (void)
a260 3
  /* Assume no @@columnfractions per default.  */
  seen_column_fractions = 0;

a273 1
        seen_column_fractions = 1;
d284 1
a284 1
          /* Hmm, but what about @@columnfractions 3foo.  Oh well, 
d289 2
a290 9

          {
            /* For html/xml/docbook, translate fractions into integer
               percentages, adding .005 to avoid rounding problems.  For
               info, we want the character width.  */
            int width = xml || html ? (columnfrac + .005) * 100
                        : (columnfrac * (fill_column - current_indent) + .5);
            setup_output_environment (i, width);
          }
d296 1
a296 1

d315 8
a322 5
/* Output a row.  Calls insert, but also flushes the buffered output
   when we see a newline, since in multitable every line is a separate
   paragraph.  */
static void
out_char (int ch)
d324 1
a324 15
  if (html || xml)
    add_char (ch);
  else
    {
      int env = select_output_environment (0);
      insert (ch);
      if (ch == '\n')
	{
	  uninhibit_output_flushing ();
	  flush_output ();
	  inhibit_output_flushing ();
	}
      select_output_environment (env);
    }
}
d326 2
d329 2
a330 4
static void
draw_horizontal_separator (void)
{
  int i, j, s;
d332 2
a333 7
  if (html)
    {
      add_word ("<hr>");
      return;
    }
  if (xml)
    return;
d335 1
a335 12
  for (s = 0; s < envs[0].current_indent; s++)
    out_char (' ');
  if (vsep)
    out_char ('+');
  for (i = 1; i <= last_column; i++) {
    for (j = 0; j <= envs[i].fill_column; j++)
      out_char ('-');
    if (vsep)
      out_char ('+');
  }
  out_char (' ');
  out_char ('\n');
d338 6
a343 20

/* multitable strategy:
    for each item {
       for each column in an item {
        initialize a new paragraph
        do ordinary formatting into the new paragraph
        save the paragraph away
        repeat if there are more paragraphs in the column
      }
      dump out the saved paragraphs and free the storage
    }

   For HTML we construct a simple HTML 3.2 table with <br>s inserted
   to help non-tables browsers.  `@@item' inserts a <tr> and `@@tab'
   inserts <td>; we also try to close <tr>.  The only real
   alternative is to rely on the info formatting engine and present
   preformatted text.  */

void
do_multitable (void)
d345 2
a346 1
  int ncolumns;
d348 8
a355 5
  if (multitable_active)
    {
      line_error ("Multitables cannot be nested");
      return;
    }
d357 11
a367 40
  close_single_paragraph ();

  if (xml)
    {
      xml_no_para = 1;
      if (output_paragraph[output_paragraph_offset-1] == '\n')
        output_paragraph_offset--;
    }

  /* scan the current item function to get the field widths
     and number of columns, and set up the output environment list
     accordingly. */
  ncolumns = setup_multitable_parameters ();
  first_row = 1;

  /* <p> for non-tables browsers.  @@multitable implicitly ends the
     current paragraph, so this is ok.  */
  if (html)
    add_html_block_elt ("<p><table summary=\"\">");
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      int *widths = xmalloc (ncolumns * sizeof (int));
      int i;
      for (i=0; i<ncolumns; i++)
	widths[i] = envs[i+1].fill_column;
      xml_begin_multitable (ncolumns, widths);
      free (widths);
    }

  if (hsep)
    draw_horizontal_separator ();

  /* The next @@item command will direct stdout into the first column
     and start processing.  @@tab will then switch to the next column,
     and @@item will flush out the saved output and return to the first
     column.  Environment #1 is the first column.  (Environment #0 is
     the normal output) */

  ++multitable_active;
d371 2
a372 2
static void
nselect_next_environment (void)
d384 2
a385 2
static void
init_column (void)
d394 41
d436 1
a436 1
output_multitable_row (void)
a520 78
int after_headitem = 0;
int headitem_row = 0;

/* start a new item (row) of a multitable */
int
multitable_item (void)
{
  if (!multitable_active) {
    line_error ("multitable_item internal error: no active multitable");
    xexit (1);
  }

  current_column_no = 1;

  if (html)
    {
      if (!first_row)
        /* <br> for non-tables browsers. */
	add_word_args ("<br></%s></tr>", after_headitem ? "th" : "td");

      if (seen_column_fractions)
        add_word_args ("<tr align=\"left\"><%s valign=\"top\" width=\"%d%%\">",
            headitem_flag ? "th" : "td",
            envs[current_column_no].fill_column);
      else
        add_word_args ("<tr align=\"left\"><%s valign=\"top\">",
            headitem_flag ? "th" : "td");

      if (headitem_flag)
        after_headitem = 1;
      else
        after_headitem = 0;
      first_row = 0;
      headitem_row = headitem_flag;
      headitem_flag = 0;
      return 0;
    }
  /*  else if (docbook)*/ /* 05-08 */
  else if (xml)
    {
      xml_end_multitable_row (first_row);
      if (headitem_flag)
        after_headitem = 1;
      else
        after_headitem = 0;
      first_row = 0;
      headitem_flag = 0;
      return 0;
    }
  first_row = 0;

  if (current_env_no > 0) {
    output_multitable_row ();
  }
  /* start at column 1 */
  select_output_environment (1);
  if (!output_paragraph) {
    line_error (_("[unexpected] cannot select column #%d in multitable"),
                current_env_no);
    xexit (1);
  }

  init_column ();

  if (headitem_flag)
    hsep = 1;
  else
    hsep = 0;

  if (headitem_flag)
    after_headitem = 1;
  else
    after_headitem = 0;
  headitem_flag = 0;

  return 0;
}

d526 1
a526 1
cm_tab (void)
a529 2

  current_column_no++;
d532 1
a532 11
    {
      if (seen_column_fractions)
        add_word_args ("</%s><%s valign=\"top\" width=\"%d%%\">",
            headitem_row ? "th" : "td",
            headitem_row ? "th" : "td",
            envs[current_column_no].fill_column);
      else
        add_word_args ("</%s><%s valign=\"top\">",
            headitem_row ? "th" : "td",
            headitem_row ? "th" : "td");
    }
d545 1
a545 1
end_multitable (void)
d559 1
a559 1
    add_word_args ("<br></%s></tr></table>\n", headitem_row ? "th" : "td");
@


