head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.3.0.46
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.42
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.38
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.40
	OPENBSD_5_8_BASE:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.32
	OPENBSD_5_7_BASE:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.36
	OPENBSD_5_6_BASE:1.1.1.3
	OPENBSD_5_5:1.1.1.3.0.34
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.30
	OPENBSD_5_4_BASE:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.28
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.26
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.24
	OPENBSD_5_0:1.1.1.3.0.22
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.20
	OPENBSD_4_9_BASE:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.18
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.14
	OPENBSD_4_7_BASE:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.16
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.12
	OPENBSD_4_5_BASE:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	TEXINFO_4_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.16
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.14
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.12
	OPENBSD_3_7_BASE:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.10
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.8
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.6
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.4
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	TEXINFO_4_0:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2000.02.09.01.25.31;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.09.01.25.31;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.10.13.21.22;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.07.17.16.03.48;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* sectioning.c -- all related stuff @@chapter, @@section... @@contents
   $Id: sectioning.c,v 1.12 1999/08/17 21:06:50 karl Exp $

   Copyright (C) 1999 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Karl Heinz Marbaise <kama@@hippo.fido.de>.  */

#include "system.h"
#include "cmds.h"
#include "macro.h"
#include "makeinfo.h"
#include "node.h"
#include "toc.h"
#include "sectioning.h"

/* See comment in sectioning.h.  */
section_alist_type section_alist[] = {
  { "unnumberedsubsubsec", 5, ENUM_SECT_NO,  TOC_YES },
  { "unnumberedsubsec",    4, ENUM_SECT_NO,  TOC_YES },
  { "unnumberedsec",       3, ENUM_SECT_NO,  TOC_YES },
  { "unnumbered",          2, ENUM_SECT_NO,  TOC_YES },

  { "appendixsubsubsec",   5, ENUM_SECT_APP, TOC_YES },  /* numbered like A.X.X.X */
  { "appendixsubsec",      4, ENUM_SECT_APP, TOC_YES },
  { "appendixsec",         3, ENUM_SECT_APP, TOC_YES },
  { "appendixsection",     3, ENUM_SECT_APP, TOC_YES },
  { "appendix",            2, ENUM_SECT_APP, TOC_YES },

  { "subsubsec",           5, ENUM_SECT_YES, TOC_YES },
  { "subsubsection",       5, ENUM_SECT_YES, TOC_YES },
  { "subsection",          4, ENUM_SECT_YES, TOC_YES },
  { "section",             3, ENUM_SECT_YES, TOC_YES },
  { "chapter",             2, ENUM_SECT_YES, TOC_YES },

  { "subsubheading",       5, ENUM_SECT_NO,  TOC_NO },
  { "subheading",          4, ENUM_SECT_NO,  TOC_NO },
  { "heading",             3, ENUM_SECT_NO,  TOC_NO },
  { "chapheading",         2, ENUM_SECT_NO,  TOC_NO },
  { "majorheading",        2, ENUM_SECT_NO,  TOC_NO },
  
  { "top",                 1, ENUM_SECT_NO,  TOC_YES },
  { NULL,                  0, 0, 0 }
};

/* The argument of @@settitle, used for HTML. */
char *title = NULL;


#define APPENDIX_MAGIC   1024
#define UNNUMBERED_MAGIC 2048

/* Number memory for every level @@chapter, @@section,
   @@subsection, @@subsubsection. */
static int numbers [] = { 0, 0, 0, 0 };

/* enum_marker == APPENDIX_MAGIC then we are counting appendencies
   enum_marker == UNNUMBERED_MAGIC then we are within unnumbered area.
   Handling situations like this:
   @@unnumbered ..
   @@section ...   */
static int enum_marker = 0;

/* Organized by level commands.  That is, "*" == chapter, "=" == section. */
static char *scoring_characters = "*=-.";

/* Amount to offset the name of sectioning commands to levels by. */
static int section_alist_offset = 0;


/* num == ENUM_SECT_NO  means unnumbered (should never call this)
   num == ENUM_SECT_YES means numbered
   num == ENUM_SECT_APP means numbered like A.1 and so on */
char *
get_sectioning_number (level, num)
      int level;
      int num;
{
  static char s[100]; /* should ever be enough for 99.99.99.99
                         Appendix A.1 */

  char *p;
  int i;

  s[0] = 0;

  /* create enumeration in front of chapter, section, subsection and so on. */
  for (i = 0; i < level; i++)
    {
      p = s + strlen (s);
      if ((i == 0) && (enum_marker == APPENDIX_MAGIC))
	sprintf (p, "%c.", numbers[i] + 64); /* Should be changed to
                                                be more portable */
      else
	sprintf (p, "%d.", numbers[i]);
    }

  /* the last number is never followed by a dot */
  p = s + strlen (s);
  if ((num == ENUM_SECT_APP)
      && (i == 0)
      && (enum_marker == APPENDIX_MAGIC))
    sprintf (p, _("Appendix %c "), numbers[i] + 64);
  else
    sprintf (p, "%d ", numbers[i]);

  return s;
}


/* Set the level of @@top to LEVEL.  Return the old level of @@top. */
int
set_top_section_level (level)
     int level;
{
  int i, result = -1;

  for (i = 0; section_alist[i].name; i++)
    if (strcmp (section_alist[i].name, "top") == 0)
      {
        result = section_alist[i].level;
        section_alist[i].level = level;
        break;
      }
  return result;
}


/* return the index of the given sectioning command in section_alist */
int
search_sectioning (text)
     char *text;
{
  int i;
  char *t;

  /* ignore the optional command prefix */
  if (text[0] == COMMAND_PREFIX)
    text++;
  
  for (i = 0; (t = section_alist[i].name); i++)
    {
      if (strcmp (t, text) == 0)
        {
          return i;
        }
    }
  return -1;
}
    
/* Return an integer which identifies the type section present in TEXT. */
int
what_section (text)
     char *text;
{
  int index, j;
  char *temp;
  int return_val;

 find_section_command:
  for (j = 0; text[j] && cr_or_whitespace (text[j]); j++);
  if (text[j] != COMMAND_PREFIX)
    return -1;

  text = text + j + 1;

  /* We skip @@c, @@comment, and @@?index commands. */
  if ((strncmp (text, "comment", strlen ("comment")) == 0) ||
      (text[0] == 'c' && cr_or_whitespace (text[1])) ||
      (strcmp (text + 1, "index") == 0))
    {
      while (*text++ != '\n');
      goto find_section_command;
    }

  /* Handle italicized sectioning commands. */
  if (*text == 'i')
    text++;

  for (j = 0; text[j] && !cr_or_whitespace (text[j]); j++);

  temp = xmalloc (1 + j);
  strncpy (temp, text, j);
  temp[j] = 0;

  index = search_sectioning (temp);
  free (temp);
  if (index >= 0)
    {
      return_val = section_alist[index].level + section_alist_offset;
      if (return_val < 0)
	return_val = 0;
      else if (return_val > 5)
          return_val = 5;
      return return_val;
    }
  return -1;
}


void
sectioning_underscore (cmd)
     char *cmd;
{
  char character;
  char *temp;
  int level;

  temp = xmalloc (2 + strlen (cmd));
  temp[0] = COMMAND_PREFIX;
  strcpy (&temp[1], cmd);
  level = what_section (temp);
  free (temp);
  level -= 2;

  if (level < 0)
    level = 0;

  if (html)
    sectioning_html (level, cmd);
  else
    {
      character = scoring_characters[level];
      insert_and_underscore (level, character, cmd);
    }
}

/* insert_and_underscore and sectioning_html are the
   only functions which call this.
   I have created this, because it was exactly the same
   code in both functions. */
static char *
handle_enum_increment (level, index)
     int level;
     int index;
{
  /* special for unnumbered */
  if (number_sections && section_alist[index].num == ENUM_SECT_NO)
    {
      if (level == 0
	  && enum_marker != UNNUMBERED_MAGIC)
	enum_marker = UNNUMBERED_MAGIC;
    }
  /* enumerate only things which are allowed */
  if (number_sections && section_alist[index].num)
    {
      /* reset the marker if we get into enumerated areas */
      if (section_alist[index].num == ENUM_SECT_YES
	  && level == 0
	  && enum_marker == UNNUMBERED_MAGIC)
	enum_marker = 0;
      /* This is special for appendix; if we got the first
         time an appendix command then we are entering appendix.
         Thats the point we have to start countint with A, B and so on. */
      if (section_alist[index].num == ENUM_SECT_APP
	  && level == 0
	  && enum_marker != APPENDIX_MAGIC)
	{
	  enum_marker = APPENDIX_MAGIC;
	  numbers [0] = 0; /* this means we start with Appendix A */
	}
  
      /* only increment counters if we are not in unnumbered
         area. This handles situations like this:
         @@unnumbered ....   This sets enum_marker to UNNUMBERED_MAGIC
         @@section ....   */
      if (enum_marker != UNNUMBERED_MAGIC)
	{
	  int i;

	  /* reset all counters which are one level deeper */
	  for (i = level; i < 3; i++)
	    numbers [i + 1] = 0;
  
	  numbers[level]++;
	  return xstrdup
	    (get_sectioning_number (level, section_alist[index].num));
	}
    } /* if (number_sections)... */

  return xstrdup ("");
}


/* Insert the text following input_text_offset up to the end of the line
   in a new, separate paragraph.  Directly underneath it, insert a
   line of WITH_CHAR, the same length of the inserted text. */
void
insert_and_underscore (level, with_char, cmd)
     int level;
     int with_char;
     char *cmd;
{
  int i, len;
  int index;
  int old_no_indent;
  unsigned char *starting_pos, *ending_pos;
  char *temp;

  close_paragraph ();
  filling_enabled =  indented_fill = 0;
  old_no_indent = no_indent;
  no_indent = 1;

  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);

  get_rest_of_line (0, &temp);
  starting_pos = output_paragraph + output_paragraph_offset;

  index = search_sectioning (cmd);
  if (index < 0)
    {
      /* should never happen, but a poor guy, named Murphy ... */
      warning (_("Internal error (search_sectioning) \"%s\"!"), cmd);
      return;
    }

  /* This is a bit tricky: we must produce "X.Y SECTION-NAME" in the
     Info output and in TOC, but only SECTION-NAME in the macro-expanded
     output.  */

  /* Step 1: produce "X.Y" and add it to Info output.  */
  add_word (handle_enum_increment (level, index));

  /* Step 2: add "SECTION-NAME" to both Info and macro-expanded output.  */
  if (macro_expansion_output_stream && !executing_string)
    {
      char *temp1 = xmalloc (2 + strlen (temp));
      sprintf (temp1, "%s\n", temp);
      remember_itext (input_text, input_text_offset);
      me_execute_string (temp1);
      free (temp1);
    }
  else
    execute_string ("%s\n", temp);

  /* Step 3: pluck "X.Y SECTION-NAME" from the output buffer and
     insert it into the TOC.  */
  ending_pos = output_paragraph + output_paragraph_offset;
  if (section_alist[index].toc == TOC_YES)
    toc_add_entry (substring (starting_pos, ending_pos - 1),
                   level, current_node, NULL);

  free (temp);

  len = (ending_pos - starting_pos) - 1;
  for (i = 0; i < len; i++)
    add_char (with_char);
  insert ('\n');
  close_paragraph ();
  filling_enabled = 1;
  no_indent = old_no_indent;
}

/* Insert the text following input_text_offset up to the end of the
   line as an HTML heading element of the appropriate `level' and
   tagged as an anchor for the current node.. */
void
sectioning_html (level, cmd)
     int level;
     char *cmd;
{
  static int toc_ref_count = 0;
  int index;
  int old_no_indent;
  unsigned char *starting_pos, *ending_pos;
  char *temp, *toc_anchor = NULL;

  close_paragraph ();
  filling_enabled =  indented_fill = 0;
  old_no_indent = no_indent;
  no_indent = 1;

  add_word_args ("<h%d>", level + 1); /* level 0 is <h1> */

  /* If we are outside of any node, produce an anchor that
     the TOC could refer to.  */
  if (!current_node || !*current_node)
    {
      starting_pos = output_paragraph + output_paragraph_offset;
      add_word_args ("<a name=\"TOC%d\">", toc_ref_count++);
      toc_anchor = substring (starting_pos + 9,
                              output_paragraph + output_paragraph_offset);
    }
  starting_pos = output_paragraph + output_paragraph_offset;

  if (macro_expansion_output_stream && !executing_string)
    append_to_expansion_output (input_text_offset + 1);

  get_rest_of_line (0, &temp);

  index = search_sectioning (cmd);
  if (index < 0)
    {
      /* should never happen, but a poor guy, named Murphy ... */
      warning (_("Internal error (search_sectioning) \"%s\"!"), cmd);
      return;
    }

  /* Produce "X.Y" and add it to HTML output.  */
  add_word (handle_enum_increment (level, index));

  /* add the section name to both HTML and macro-expanded output.  */
  if (macro_expansion_output_stream && !executing_string)
    {
      remember_itext (input_text, input_text_offset);
      me_execute_string (temp);
      write_region_to_macro_output ("\n", 0, 1);
    }
  else
    execute_string ("%s", temp);

  ending_pos = output_paragraph + output_paragraph_offset;

  /* Pluck ``X.Y SECTION-NAME'' from the output buffer and insert it
     into the TOC.  */
  if (section_alist[index].toc == TOC_YES)
    toc_add_entry (substring (starting_pos, ending_pos),
                   level, current_node, toc_anchor);
  
  free (temp);

  if (outstanding_node)
    outstanding_node = 0;

  add_word_args ("</h%d>", level+1);
  close_paragraph();
  filling_enabled = 1;
  no_indent = old_no_indent;
}


/* Shift the meaning of @@section to @@chapter. */
void
cm_raisesections ()
{
  discard_until ("\n");
  section_alist_offset--;
}

/* Shift the meaning of @@chapter to @@section. */
void
cm_lowersections ()
{
  discard_until ("\n");
  section_alist_offset++;
}

/* The command still works, but prints a warning message in addition. */
void
cm_ideprecated (arg, start, end)
     int arg, start, end;
{
  warning (_("%c%s is obsolete; use %c%s instead"),
           COMMAND_PREFIX, command, COMMAND_PREFIX, command + 1);
  sectioning_underscore (command + 1);
}


/* Treat this just like @@unnumbered.  The only difference is
   in node defaulting. */
void
cm_top ()
{
  /* It is an error to have more than one @@top. */
  if (top_node_seen && strcmp (current_node, "Top") != 0)
    {
      TAG_ENTRY *tag = tag_table;

      line_error (_("Node with %ctop as a section already exists"),
                  COMMAND_PREFIX);

      while (tag)
        {
          if (tag->flags & TAG_FLAG_IS_TOP)
            {
              int old_line_number = line_number;
              char *old_input_filename = input_filename;

              line_number = tag->line_no;
              input_filename = tag->filename;
              line_error (_("Here is the %ctop node"), COMMAND_PREFIX);
              input_filename = old_input_filename;
              line_number = old_line_number;
              return;
            }
          tag = tag->next_ent;
        }
    }
  else
    {
      TAG_ENTRY *top_node = find_node ("Top");
      top_node_seen = 1;

      /* It is an error to use @@top before you have used @@node. */
      if (!tag_table)
        {
          char *top_name;

          get_rest_of_line (0, &top_name);
          line_error (_("%ctop used before %cnode, defaulting to %s"),
                      COMMAND_PREFIX, COMMAND_PREFIX, top_name);
          execute_string ("@@node Top, , (dir), (dir)\n@@top %s\n", top_name);
          free (top_name);
          return;
        }
      else if (html && splitting)
        {
          char *next = top_node ? top_node->next : NULL;

          add_word ("<p>");
          if (next)
            {
              add_word (_("Next:"));
              add_word ("<a rel=next href=\"");
              add_anchor_name (next, 1);
              add_word ("\">");
              execute_string (next);
              add_word ("</a>\n");
            }
        }

      cm_unnumbered ();

      /* The most recently defined node is the top node. */
      tag_table->flags |= TAG_FLAG_IS_TOP;

      /* Now set the logical hierarchical level of the Top node. */
      {
        int orig_offset = input_text_offset;

        input_text_offset = search_forward (node_search_string, orig_offset);

        if (input_text_offset > 0)
          {
            int this_section;

            /* We have encountered a non-top node, so mark that one exists. */
            non_top_node_seen = 1;

            /* Move to the end of this line, and find out what the
               sectioning command is here. */
            while (input_text[input_text_offset] != '\n')
              input_text_offset++;

            if (input_text_offset < input_text_length)
              input_text_offset++;

            this_section = what_section (input_text + input_text_offset);

            /* If we found a sectioning command, then give the top section
               a level of this section - 1. */
            if (this_section != -1)
              set_top_section_level (this_section - 1);
          }
        input_text_offset = orig_offset;
      }
    }
}

/* The remainder of the text on this line is a chapter heading. */
void
cm_chapter ()
{
  sectioning_underscore ("chapter");
}

/* The remainder of the text on this line is a section heading. */
void
cm_section ()
{
  sectioning_underscore ("section");
}

/* The remainder of the text on this line is a subsection heading. */
void
cm_subsection ()
{
  sectioning_underscore ("subsection");
}

/* The remainder of the text on this line is a subsubsection heading. */
void
cm_subsubsection ()
{
  sectioning_underscore ("subsubsection");
}

/* The remainder of the text on this line is an unnumbered heading. */
void
cm_unnumbered ()
{
  sectioning_underscore ("unnumbered");
}

/* The remainder of the text on this line is an unnumbered section heading. */
void
cm_unnumberedsec ()
{
  sectioning_underscore ("unnumberedsec");
}

/* The remainder of the text on this line is an unnumbered
   subsection heading. */
void
cm_unnumberedsubsec ()
{
  sectioning_underscore ("unnumberedsubsec");
}

/* The remainder of the text on this line is an unnumbered
   subsubsection heading. */
void
cm_unnumberedsubsubsec ()
{
  sectioning_underscore ("unnumberedsubsubsec");
}

/* The remainder of the text on this line is an appendix heading. */
void
cm_appendix ()
{
  sectioning_underscore ("appendix");
}

/* The remainder of the text on this line is an appendix section heading. */
void
cm_appendixsec ()
{
  sectioning_underscore ("appendixsec");
}

/* The remainder of the text on this line is an appendix subsection heading. */
void
cm_appendixsubsec ()
{
  sectioning_underscore ("appendixsubsec");
}

/* The remainder of the text on this line is an appendix
   subsubsection heading. */
void
cm_appendixsubsubsec ()
{
  sectioning_underscore ("appendixsubsubsec");
}

/* Compatibility functions substitute for chapter, section, etc. */
void
cm_majorheading ()
{
  sectioning_underscore ("majorheading");
}

void
cm_chapheading ()
{
  sectioning_underscore ("chapheading");
}

void
cm_heading ()
{
  sectioning_underscore ("heading");
}

void
cm_subheading ()
{
  sectioning_underscore ("subheading");
}

void
cm_subsubheading ()
{
  sectioning_underscore ("subsubheading");
}
@


1.1.1.1
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@@


1.1.1.2
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: sectioning.c,v 1.17 2002/02/09 00:54:51 karl Exp $
d4 1
a4 1
   Copyright (C) 1999, 2001, 02 Free Software Foundation, Inc.
a28 1
#include "xml.h"
d213 1
a217 27
  if (xml)
    {
      char *temp;
      int level;
      temp = xmalloc (2 + strlen (cmd));
      temp[0] = COMMAND_PREFIX;
      strcpy (&temp[1], cmd);
      level = what_section (temp);
      level -= 2;
      free (temp);
      xml_close_sections (level);
      /* Mark the beginning of the section
	 If the next command is printindex, we will remove
	 the section and put an Index instead */
      flush_output ();
      xml_last_section_output_position = output_paragraph_offset;
      
      xml_insert_element (xml_element (cmd), START);
      xml_insert_element (TITLE, START);
      xml_open_section (level, cmd);
      get_rest_of_line (0, &temp);
      execute_string ("%s\n", temp);
      free (temp);
      xml_insert_element (TITLE, END);
    } 
  else 
    {
a237 1
	}
d388 1
a388 1
  add_word_args ("<h%d>", level + 2); /* level 0 (chapter) is <h2> */
a393 2
      static const char a_name[] = "<a name=\"";

d395 2
a396 2
      add_word_args ("%sTOC%d\">", a_name, toc_ref_count++);
      toc_anchor = substring (starting_pos + sizeof (a_name) - 1,
a397 4
      /* This must be added after toc_anchor is extracted, since
	 toc_anchor cannot include the closing </a>.  For details,
	 see toc.c:toc_add_entry and toc.c:contents_update_html.  */
      add_word ("</a>");
d434 1
a434 1

d440 1
a440 1
  add_word_args ("</h%d>", level + 2);
d491 8
a498 2
              file_line_error (tag->filename, tag->line_no,
			       _("Here is the %ctop node"), COMMAND_PREFIX);
d509 1
a509 1
      /* It is an error to use @@top before using @@node. */
d520 15
@


1.1.1.3
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* sectioning.c -- for @@chapter, @@section, ..., @@contents ...
   $Id: sectioning.c,v 1.25 2004/07/05 22:23:23 karl Exp $
d4 1
a4 1
   Copyright (C) 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d20 1
a20 1
   Originally written by Karl Heinz Marbaise <kama@@hippo.fido.de>.  */
a36 1
  { "centerchap",          2, ENUM_SECT_NO,  TOC_YES },
d55 1
a55 1

a83 6
/* These two variables are for @@float, @@cindex like commands that need to know
   in which section they are used.  */
/* Last value returned by get_sectioning_number.  */
static char *last_sectioning_number = "";
/* Last title used by sectioning_underscore, etc.  */
static char *last_sectioning_title = "";
d88 4
a91 2
static char *
get_sectioning_number (int level, int num)
d106 1
a106 1
        sprintf (p, "%c.", numbers[i] + 64); /* Should be changed to
d109 1
a109 1
        sprintf (p, "%d.", numbers[i]);
d117 1
a117 1
    sprintf (p, _("Appendix %c"), numbers[i] + 64);
d119 1
a119 6
    sprintf (p, "%d", numbers[i]);

  /* Poor man's cache :-)  */
  if (strlen (last_sectioning_number))
    free (last_sectioning_number);
  last_sectioning_number = xstrdup (s);
d127 2
a128 1
set_top_section_level (int level)
d144 3
a146 2
static int
search_sectioning (char *text)
d154 1
a154 1

d164 2
a165 6

/* Return an integer which identifies the type of section present in
   TEXT -- 1 for @@top, 2 for chapters, ..., 5 for subsubsections (as
   specified in section_alist).  We take into account any @@lowersections
   and @@raisesections.  If SECNAME is non-NULL, also return the
   corresponding section name.  */
d167 2
a168 1
what_section (char *text, char **secname)
d206 1
a206 1
        return_val = 0;
d208 1
a208 24
        return_val = 5;

      if (secname)
        {
          int i;
          int alist_size = sizeof (section_alist) / sizeof(section_alist_type);
          /* Find location of offset sectioning entry, but don't go off
             either end of the array.  */
          int index_offset = MAX (index - section_alist_offset, 0);
          index_offset = MIN (index_offset, alist_size - 1);

          /* Also make sure we don't go into the next "group" of
             sectioning changes, e.g., change from an @@appendix to an
             @@heading or some such.  */
#define SIGN(expr) ((expr) < 0 ? -1 : 1)
          for (i = index; i != index_offset; i -= SIGN (section_alist_offset))
            {
              /* As it happens, each group has unique .num/.toc values.  */
              if (section_alist[i].num != section_alist[index_offset].num
                  || section_alist[i].toc != section_alist[index_offset].toc)
                break;
            }
          *secname = section_alist[i].name;
        }
d214 3
a216 6
/* Returns current top level division (ie. chapter, unnumbered) number.
   - For chapters, returns the number.
   - For unnumbered sections, returns empty string.
   - For appendices, returns A, B, etc. */
char *
current_chapter_number (void)
d218 26
a243 9
  if (enum_marker == UNNUMBERED_MAGIC)
    return xstrdup ("");
  else if (enum_marker == APPENDIX_MAGIC)
    {
      char s[1];
      sprintf (s, "%c", numbers[0] + 64);
      return xstrdup (s);
    }
  else
d245 2
a246 58
      char s[5];
      sprintf (s, "%d", numbers[0]);
      return xstrdup (s);
    }
}

/* Returns number of the last sectioning command used.  */
char *
current_sectioning_number (void)
{
  if (enum_marker == UNNUMBERED_MAGIC || !number_sections)
    return xstrdup ("");
  else
    return xstrdup (last_sectioning_number);
}

/* Returns arguments of the last sectioning command used.  */
char *
current_sectioning_name (void)
{
  return xstrdup (last_sectioning_title);
}

/* insert_and_underscore, sectioning_underscore and sectioning_html call this.  */

static char *
handle_enum_increment (int level, int index)
{
  /* Here is how TeX handles enumeration:
     - Anything starting with @@unnumbered is not enumerated.
     - @@majorheading and the like are not enumberated.  */
  int i;

  /* First constraint above.  */
  if (enum_marker == UNNUMBERED_MAGIC && level == 0)
    return xstrdup ("");

  /* Second constraint.  */
  if (section_alist[index].num == ENUM_SECT_NO)
    return xstrdup ("");

  /* reset all counters which are one level deeper */
  for (i = level; i < 3; i++)
    numbers [i + 1] = 0;

  numbers[level]++;
  if (section_alist[index].num == ENUM_SECT_NO || enum_marker == UNNUMBERED_MAGIC
      || !number_sections)
    return xstrdup ("");
  else
    return xstrdup (get_sectioning_number (level, section_alist[index].num));
}


void
sectioning_underscore (char *cmd)
{
  char *temp, *secname;
a247 5
  
  /* If we're not indenting the first paragraph, we shall make it behave
     like @@noindent is called directly after the section heading. */
  if (! do_first_par_indent)
    cm_noindent ();
d252 2
a253 1
  level = what_section (temp, &secname);
d255 1
a257 1
  free (temp);
d259 3
a261 3
  /* If the argument to @@top is empty, we try using the one from @@settitle.
     Warn if both are unusable.  */
  if (STREQ (command, "top"))
d263 3
a265 11
      int save_input_text_offset = input_text_offset;

      get_rest_of_line (0, &temp);

      /* Due to get_rest_of_line ... */
      line_number--;

      if (strlen (temp) == 0 && (!title || strlen (title) == 0))
        warning ("Must specify a title with least one of @@settitle or @@top");

      input_text_offset = save_input_text_offset;
d267 1
d269 40
a308 5
  if (xml)
    {
      /* If the section appears in the toc, it means it's a real section
	 unlike majorheading, chapheading etc. */
      if (section_alist[search_sectioning (cmd)].toc == TOC_YES)
d310 1
a310 31
	  xml_close_sections (level);
	  /* Mark the beginning of the section
	     If the next command is printindex, we will remove
	     the section and put an Index instead */
	  flush_output ();
	  xml_last_section_output_position = output_paragraph_offset;

	  get_rest_of_line (0, &temp);

          /* Use @@settitle value if @@top parameter is empty.  */
          if (STREQ (command, "top") && strlen(temp) == 0)
            temp = xstrdup (title ? title : "");

          /* Docbook does not support @@unnumbered at all.  So we provide numbers
             that other formats use.  @@appendix seems to be fine though, so we let
             Docbook handle that as usual.  */
          if (docbook && enum_marker != APPENDIX_MAGIC)
            {
              if (section_alist[search_sectioning (cmd)].num == ENUM_SECT_NO
                  && section_alist[search_sectioning (cmd)].toc == TOC_YES)
                xml_insert_element_with_attribute (xml_element (secname),
                    START, "label=\"%s\" xreflabel=\"%s\"",
                    handle_enum_increment (level, search_sectioning (cmd)),
                    text_expansion (temp));
              else
                xml_insert_element_with_attribute (xml_element (secname),
                    START, "label=\"%s\"",
                    handle_enum_increment (level, search_sectioning (cmd)));
            }
          else
            xml_insert_element (xml_element (secname), START);
d312 7
a318 6
	  xml_insert_element (TITLE, START);
	  xml_open_section (level, secname);
	  execute_string ("%s", temp);
	  xml_insert_element (TITLE, END);

	  free (temp);
d320 1
a320 17
      else
        {
          if (docbook)
            {
              if (level > 0)
                xml_insert_element_with_attribute (xml_element (secname), START,
                    "renderas=\"sect%d\"", level);
              else
                xml_insert_element_with_attribute (xml_element (secname), START,
                    "renderas=\"other\"");
            }
          else
            xml_insert_element (xml_element (secname), START);

          get_rest_of_line (0, &temp);
          execute_string ("%s", temp);
          free (temp);
d322 1
a322 7
          xml_insert_element (xml_element (secname), END);
        }
    }
  else if (html)
    sectioning_html (level, secname);
  else
    insert_and_underscore (level, secname);
d330 4
a333 1
insert_and_underscore (int level, char *cmd)
a339 1
  char with_char = scoring_characters[level];
a349 5

  /* Use @@settitle value if @@top parameter is empty.  */
  if (STREQ (command, "top") && strlen(temp) == 0)
    temp = xstrdup (title ? title : "");

a351 5
  /* Poor man's cache for section title.  */
  if (strlen (last_sectioning_title))
    free (last_sectioning_title);
  last_sectioning_title = xstrdup (temp);

d356 1
a356 1
      warning (_("Internal error (search_sectioning) `%s'!"), cmd);
d365 1
a365 1
  add_word_args ("%s ", handle_enum_increment (level, index));
a399 1

d401 3
a403 1
sectioning_html (int level, char *cmd)
d416 1
a416 2
  /* level 0 (chapter) is <h2>, and we go down from there.  */
  add_html_block_elt_args ("<h%d class=\"%s\">", level + 2, cmd);
d429 2
a430 5
         toc_anchor cannot include the closing </a>.  For details,
         see toc.c:toc_add_entry and toc.c:contents_update_html.

         Also, the anchor close must be output before the section name
         in case the name itself contains an anchor. */
a439 4
  /* Use @@settitle value if @@top parameter is empty.  */
  if (STREQ (command, "top") && strlen(temp) == 0)
    temp = xstrdup (title ? title : "");

d449 1
a449 5
  {
    char *title_number = handle_enum_increment (level, index);
    if (strlen (title_number) > 0)
      add_word_args ("%s ", title_number);
  }
d483 1
a483 1
cm_raisesections (void)
d491 1
a491 1
cm_lowersections (void)
d499 2
a500 1
cm_ideprecated (int arg, int start, int end)
d511 1
a511 1
cm_top (void)
d526 1
a526 1
                               _("Here is the %ctop node"), COMMAND_PREFIX);
d534 1
d576 1
a576 2
            this_section = what_section (input_text + input_text_offset,
                                         NULL);
d590 1
a590 1
cm_chapter (void)
a591 1
  enum_marker = 0;
d597 1
a597 1
cm_section (void)
d604 1
a604 1
cm_subsection (void)
d611 1
a611 1
cm_subsubsection (void)
d618 1
a618 1
cm_unnumbered (void)
a619 1
  enum_marker = UNNUMBERED_MAGIC;
d625 1
a625 1
cm_unnumberedsec (void)
d633 1
a633 1
cm_unnumberedsubsec (void)
d641 1
a641 1
cm_unnumberedsubsubsec (void)
d648 1
a648 1
cm_appendix (void)
a649 4
  /* Reset top level number so we start from Appendix A */
  if (enum_marker != APPENDIX_MAGIC)
    numbers [0] = 0;
  enum_marker = APPENDIX_MAGIC;
d655 1
a655 1
cm_appendixsec (void)
d662 1
a662 1
cm_appendixsubsec (void)
d670 1
a670 1
cm_appendixsubsubsec (void)
d677 1
a677 1
cm_majorheading (void)
d683 1
a683 1
cm_chapheading (void)
d689 1
a689 1
cm_heading (void)
d695 1
a695 1
cm_subheading (void)
d701 1
a701 1
cm_subsubheading (void)
@


