head	1.6;
access;
symbols
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.4
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.7
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.6
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.5
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.4
	OPENBSD_2_4:1.1.1.3.0.6
	OPENBSD_2_4_BASE:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.4
	OPENBSD_2_3_BASE:1.1.1.3
	OPENBSD_2_2:1.1.1.3.0.2
	OPENBSD_2_2_BASE:1.1.1.3
	TEXINFO_3_11:1.1.1.3
	OPENBSD_2_1:1.1.1.2.0.2
	OPENBSD_2_1_BASE:1.1.1.2
	TEXINFO_3_9:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2015.11.14.23.06.06;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	3WsuKev3hGnuRYC4;

1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.04;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.43;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.15;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.17;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.17;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.12.15.21.39.35;	author downsj;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.08.01.22.01.05;	author kstailey;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.01.11.16.32.44;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.09.01.26.21;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.06.10.13.21.25;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.07.17.16.03.50;	author espie;	state Exp;
branches;
next	;


desc
@@


1.6
log
@info - pledge stdio rpath wpath cpath getpw tty proc exec
infokey - stdio rpath wpath cpath tty
makeinfo - stdio rpath wpath cpath getpw
install-info - stdio rpath wpath cpath proc exec
texindex - stdio rpath wpath cpath tmppath
ok schwarze
@
text
@/* texindex -- sort TeX index dribble output into an actual index.
   $Id: texindex.c,v 1.5 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1987, 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307. */

#include "system.h"
#include <getopt.h>

static char *program_name = "texindex";

#if defined (emacs)
#  include "../src/config.h"
/* Some s/os.h files redefine these. */
#  undef read
#  undef close
#  undef write
#  undef open
#endif

#if !defined (HAVE_MEMSET)
#undef memset
#define memset(ptr, ignore, count) bzero (ptr, count)
#endif

char *mktemp (char *);

#if !defined (SEEK_SET)
#  define SEEK_SET 0
#  define SEEK_CUR 1
#  define SEEK_END 2
#endif /* !SEEK_SET */

struct linebuffer;

/* When sorting in core, this structure describes one line
   and the position and length of its first keyfield.  */
struct lineinfo
{
  char *text;           /* The actual text of the line. */
  union {
    char *text;         /* The start of the key (for textual comparison). */
    long number;        /* The numeric value (for numeric comparison). */
  } key;
  long keylen;          /* Length of KEY field. */
};

/* This structure describes a field to use as a sort key. */
struct keyfield
{
  int startwords;       /* Number of words to skip. */
  int startchars;       /* Number of additional chars to skip. */
  int endwords;         /* Number of words to ignore at end. */
  int endchars;         /* Ditto for characters of last word. */
  char ignore_blanks;   /* Non-zero means ignore spaces and tabs. */
  char fold_case;       /* Non-zero means case doesn't matter. */
  char reverse;         /* Non-zero means compare in reverse order. */
  char numeric;         /* Non-zeros means field is ASCII numeric. */
  char positional;      /* Sort according to file position. */
  char braced;          /* Count balanced-braced groupings as fields. */
};

/* Vector of keyfields to use. */
struct keyfield keyfields[3];

/* Number of keyfields stored in that vector.  */
int num_keyfields = 3;

/* Vector of input file names, terminated with a null pointer. */
char **infiles;

/* Vector of corresponding output file names, or NULL, meaning default it
   (add an `s' to the end). */
char **outfiles;

/* Length of `infiles'. */
int num_infiles;

/* Pointer to the array of pointers to lines being sorted. */
char **linearray;

/* The allocated length of `linearray'. */
long nlines;

/* Directory to use for temporary files.  On Unix, it ends with a slash.  */
char *tempdir;

/* Number of last temporary file.  */
int tempcount;

/* Number of last temporary file already deleted.
   Temporary files are deleted by `flush_tempfiles' in order of creation.  */
int last_deleted_tempcount;

/* During in-core sort, this points to the base of the data block
   which contains all the lines of data.  */
char *text_base;

/* Initially 0; changed to 1 if we want initials in this index.  */
int need_initials;

/* Remembers the first initial letter seen in this index, so we can
   determine whether we need initials in the sorted form.  */
char first_initial;

/* Additional command switches .*/

/* Nonzero means do not delete tempfiles -- for debugging. */
int keep_tempfiles;

/* Forward declarations of functions in this file. */
void decode_command (int argc, char **argv);
void sort_in_core (char *infile, int total, char *outfile);
void sort_offline (char *infile, off_t total, char *outfile);
char **parsefile (char *filename, char **nextline, char *data, long int size);
char *find_field (struct keyfield *keyfield, char *str, long int *lengthptr);
char *find_pos (char *str, int words, int chars, int ignore_blanks);
long find_value (char *start, long int length);
char *find_braced_pos (char *str, int words, int chars, int ignore_blanks);
char *find_braced_end (char *str);
void writelines (char **linearray, int nlines, FILE *ostream);
int compare_field (struct keyfield *keyfield, char *start1,
                   long int length1, long int pos1, char *start2,
                   long int length2, long int pos2);
int compare_full (const void *, const void *);
long readline (struct linebuffer *linebuffer, FILE *stream);
int merge_files (char **infiles, int nfiles, char *outfile);
int merge_direct (char **infiles, int nfiles, char *outfile);
void pfatal_with_name (const char *name);
void fatal (const char *format, const char *arg);
void error (const char *format, const char *arg);
void *xmalloc (), *xrealloc ();
char *concat (char *s1, char *s2);
void flush_tempfiles (int to_count);

#define MAX_IN_CORE_SORT 500000

int
main (int argc, char **argv)
{
  int i;

  tempcount = 0;
  last_deleted_tempcount = 0;

#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  if (pledge ("stdio rpath wpath cpath tmppath", NULL) == -1)
    pfatal_with_name ("pledge");

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  /* In case we write to a redirected stdout that fails.  */
  /* not ready atexit (close_stdout); */

  /* Describe the kind of sorting to do. */
  /* The first keyfield uses the first braced field and folds case. */
  keyfields[0].braced = 1;
  keyfields[0].fold_case = 1;
  keyfields[0].endwords = -1;
  keyfields[0].endchars = -1;

  /* The second keyfield uses the second braced field, numerically. */
  keyfields[1].braced = 1;
  keyfields[1].numeric = 1;
  keyfields[1].startwords = 1;
  keyfields[1].endwords = -1;
  keyfields[1].endchars = -1;

  /* The third keyfield (which is ignored while discarding duplicates)
     compares the whole line. */
  keyfields[2].endwords = -1;
  keyfields[2].endchars = -1;

  decode_command (argc, argv);

  /* Process input files completely, one by one.  */

  for (i = 0; i < num_infiles; i++)
    {
      int desc;
      off_t ptr;
      char *outfile;
      struct stat instat;

      desc = open (infiles[i], O_RDONLY, 0);
      if (desc < 0)
        pfatal_with_name (infiles[i]);

      if (stat (infiles[i], &instat))
        pfatal_with_name (infiles[i]);
      if (S_ISDIR (instat.st_mode))
        {
#ifdef EISDIR
          errno = EISDIR;
#endif
          pfatal_with_name (infiles[i]);
        }

      lseek (desc, (off_t) 0, SEEK_END);
      ptr = (off_t) lseek (desc, (off_t) 0, SEEK_CUR);

      close (desc);

      outfile = outfiles[i];
      if (!outfile)
        outfile = concat (infiles[i], "s");

      need_initials = 0;
      first_initial = '\0';

      if (ptr < MAX_IN_CORE_SORT)
        /* Sort a small amount of data. */
        sort_in_core (infiles[i], (int)ptr, outfile);
      else
        sort_offline (infiles[i], ptr, outfile);
    }

  flush_tempfiles (tempcount);
  xexit (0);
  return 0; /* Avoid bogus warnings.  */
}

typedef struct
{
  char *long_name;
  char *short_name;
  int *variable_ref;
  int variable_value;
  char *arg_name;
  char *doc_string;
} TEXINDEX_OPTION;

TEXINDEX_OPTION texindex_options[] = {
  { "--help", "-h", (int *)NULL, 0, (char *)NULL,
      N_("display this help and exit") },
  { "--keep", "-k", &keep_tempfiles, 1, (char *)NULL,
      N_("keep temporary files around after processing") },
  { "--no-keep", 0, &keep_tempfiles, 0, (char *)NULL,
      N_("do not keep temporary files around after processing (default)") },
  { "--output", "-o", (int *)NULL, 0, "FILE",
      N_("send output to FILE") },
  { "--version", (char *)NULL, (int *)NULL, 0, (char *)NULL,
      N_("display version information and exit") },
  { (char *)NULL, (char *)NULL, (int *)NULL, 0, (char *)NULL }
};

void
usage (int result_value)
{
  register int i;
  FILE *f = result_value ? stderr : stdout;

  fprintf (f, _("Usage: %s [OPTION]... FILE...\n"), program_name);
  fprintf (f, _("Generate a sorted index for each TeX output FILE.\n"));
  /* Avoid trigraph nonsense.  */
  fprintf (f,
_("Usually FILE... is specified as `foo.%c%c\' for a document `foo.texi'.\n"),
           '?', '?'); /* avoid trigraph in cat-id-tbl.c */
  fprintf (f, _("\nOptions:\n"));

  for (i = 0; texindex_options[i].long_name; i++)
    {
      putc (' ', f);

      if (texindex_options[i].short_name)
        fprintf (f, "%s, ", texindex_options[i].short_name);

      fprintf (f, "%s %s",
               texindex_options[i].long_name,
               texindex_options[i].arg_name
               ? texindex_options[i].arg_name : "");

      fprintf (f, "\t%s\n", _(texindex_options[i].doc_string));
    }
  fputs (_("\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
Texinfo home page: http://www.gnu.org/software/texinfo/"), f);
  fputs ("\n", f);

  xexit (result_value);
}

/* Decode the command line arguments to set the parameter variables
   and set up the vector of keyfields and the vector of input files. */

void
decode_command (int argc, char **argv)
{
  int arg_index = 1;
  char **ip;
  char **op;

  /* Store default values into parameter variables. */

  tempdir = getenv ("TMPDIR");
  if (tempdir == NULL)
    tempdir = getenv ("TEMP");
  if (tempdir == NULL)
    tempdir = getenv ("TMP");
  if (tempdir == NULL)
    tempdir = DEFAULT_TMPDIR;
  else
    tempdir = concat (tempdir, "/");

  keep_tempfiles = 0;

  /* Allocate ARGC input files, which must be enough.  */

  infiles = (char **) xmalloc (argc * sizeof (char *));
  outfiles = (char **) xmalloc (argc * sizeof (char *));
  ip = infiles;
  op = outfiles;

  while (arg_index < argc)
    {
      char *arg = argv[arg_index++];

      if (*arg == '-')
        {
          if (strcmp (arg, "--version") == 0)
            {
              printf ("texindex (GNU %s) %s\n", PACKAGE, VERSION);
              puts ("");
              puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
              printf (_("There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.\n"));
              xexit (0);
            }
          else if ((strcmp (arg, "--keep") == 0) ||
                   (strcmp (arg, "-k") == 0))
            {
              keep_tempfiles = 1;
            }
          else if ((strcmp (arg, "--help") == 0) ||
                   (strcmp (arg, "-h") == 0))
            {
              usage (0);
            }
          else if ((strcmp (arg, "--output") == 0) ||
                   (strcmp (arg, "-o") == 0))
            {
              if (argv[arg_index] != (char *)NULL)
                {
                  arg_index++;
                  if (op > outfiles)
                    *(op - 1) = argv[arg_index];
                }
              else
                usage (1);
            }
          else
            usage (1);
        }
      else
        {
          *ip++ = arg;
          *op++ = (char *)NULL;
        }
    }

  /* Record number of keyfields and terminate list of filenames. */
  num_infiles = ip - infiles;
  *ip = (char *)NULL;
  if (num_infiles == 0)
    usage (1);
}

/* Return a name for temporary file COUNT. */

static char *
maketempname (int count)
{
  static char *tempbase = NULL;
  char tempsuffix[10];
  char *name;
  int fd;

  if (!tempbase)
    {
      int fd;
      tempbase = concat (tempdir, "txidxXXXXXX");

      fd = mkstemp (tempbase);
      if (fd == -1)
        pfatal_with_name (tempbase);
    }

  sprintf (tempsuffix, ".%d", count);
  name =  concat (tempbase, tempsuffix);

  fd = open (name, O_CREAT|O_EXCL|O_WRONLY, 0666);
  if (fd == -1)
    return NULL;
  else
    {
      close(fd);
      return name;
    }
}


/* Delete all temporary files up to TO_COUNT. */

void
flush_tempfiles (int to_count)
{
  if (keep_tempfiles)
    return;
  while (last_deleted_tempcount < to_count)
    unlink (maketempname (++last_deleted_tempcount));
}


/* Compare LINE1 and LINE2 according to the specified set of keyfields. */

int
compare_full (const void *p1, const void *p2)
{
  char **line1 = (char **) p1;
  char **line2 = (char **) p2;
  int i;

  /* Compare using the first keyfield;
     if that does not distinguish the lines, try the second keyfield;
     and so on. */

  for (i = 0; i < num_keyfields; i++)
    {
      long length1, length2;
      char *start1 = find_field (&keyfields[i], *line1, &length1);
      char *start2 = find_field (&keyfields[i], *line2, &length2);
      int tem = compare_field (&keyfields[i], start1, length1,
                               *line1 - text_base,
                               start2, length2, *line2 - text_base);
      if (tem)
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
    }

  return 0;                     /* Lines match exactly. */
}

/* Compare LINE1 and LINE2, described by structures
   in which the first keyfield is identified in advance.
   For positional sorting, assumes that the order of the lines in core
   reflects their nominal order.  */
int
compare_prepared (const void *p1, const void *p2)
{
  struct lineinfo *line1 = (struct lineinfo *) p1;
  struct lineinfo *line2 = (struct lineinfo *) p2;
  int i;
  int tem;
  char *text1, *text2;

  /* Compare using the first keyfield, which has been found for us already. */
  if (keyfields->positional)
    {
      if (line1->text - text_base > line2->text - text_base)
        tem = 1;
      else
        tem = -1;
    }
  else if (keyfields->numeric)
    tem = line1->key.number - line2->key.number;
  else
    tem = compare_field (keyfields, line1->key.text, line1->keylen, 0,
                         line2->key.text, line2->keylen, 0);
  if (tem)
    {
      if (keyfields->reverse)
        return -tem;
      return tem;
    }

  text1 = line1->text;
  text2 = line2->text;

  /* Compare using the second keyfield;
     if that does not distinguish the lines, try the third keyfield;
     and so on. */

  for (i = 1; i < num_keyfields; i++)
    {
      long length1, length2;
      char *start1 = find_field (&keyfields[i], text1, &length1);
      char *start2 = find_field (&keyfields[i], text2, &length2);
      int tem = compare_field (&keyfields[i], start1, length1,
                               text1 - text_base,
                               start2, length2, text2 - text_base);
      if (tem)
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
    }

  return 0;                     /* Lines match exactly. */
}

/* Like compare_full but more general.
   You can pass any strings, and you can say how many keyfields to use.
   POS1 and POS2 should indicate the nominal positional ordering of
   the two lines in the input.  */

int
compare_general (char *str1, char *str2, long int pos1, long int pos2, int use_keyfields)
{
  int i;

  /* Compare using the first keyfield;
     if that does not distinguish the lines, try the second keyfield;
     and so on. */

  for (i = 0; i < use_keyfields; i++)
    {
      long length1, length2;
      char *start1 = find_field (&keyfields[i], str1, &length1);
      char *start2 = find_field (&keyfields[i], str2, &length2);
      int tem = compare_field (&keyfields[i], start1, length1, pos1,
                               start2, length2, pos2);
      if (tem)
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
    }

  return 0;                     /* Lines match exactly. */
}

/* Find the start and length of a field in STR according to KEYFIELD.
   A pointer to the starting character is returned, and the length
   is stored into the int that LENGTHPTR points to.  */

char *
find_field (struct keyfield *keyfield, char *str, long int *lengthptr)
{
  char *start;
  char *end;
  char *(*fun) ();

  if (keyfield->braced)
    fun = find_braced_pos;
  else
    fun = find_pos;

  start = (*fun) (str, keyfield->startwords, keyfield->startchars,
                  keyfield->ignore_blanks);
  if (keyfield->endwords < 0)
    {
      if (keyfield->braced)
        end = find_braced_end (start);
      else
        {
          end = start;
          while (*end && *end != '\n')
            end++;
        }
    }
  else
    {
      end = (*fun) (str, keyfield->endwords, keyfield->endchars, 0);
      if (end - str < start - str)
        end = start;
    }
  *lengthptr = end - start;
  return start;
}

/* Return a pointer to a specified place within STR,
   skipping (from the beginning) WORDS words and then CHARS chars.
   If IGNORE_BLANKS is nonzero, we skip all blanks
   after finding the specified word.  */

char *
find_pos (char *str, int words, int chars, int ignore_blanks)
{
  int i;
  char *p = str;

  for (i = 0; i < words; i++)
    {
      char c;
      /* Find next bunch of nonblanks and skip them. */
      while ((c = *p) == ' ' || c == '\t')
        p++;
      while ((c = *p) && c != '\n' && !(c == ' ' || c == '\t'))
        p++;
      if (!*p || *p == '\n')
        return p;
    }

  while (*p == ' ' || *p == '\t')
    p++;

  for (i = 0; i < chars; i++)
    {
      if (!*p || *p == '\n')
        break;
      p++;
    }
  return p;
}

/* Like find_pos but assumes that each field is surrounded by braces
   and that braces within fields are balanced. */

char *
find_braced_pos (char *str, int words, int chars, int ignore_blanks)
{
  int i;
  int bracelevel;
  char *p = str;
  char c;

  for (i = 0; i < words; i++)
    {
      bracelevel = 1;
      while ((c = *p++) != '{' && c != '\n' && c)
        /* Do nothing. */ ;
      if (c != '{')
        return p - 1;
      while (bracelevel)
        {
          c = *p++;
          if (c == '{')
            bracelevel++;
          if (c == '}')
            bracelevel--;
          if (c == 0 || c == '\n')
            return p - 1;
        }
    }

  while ((c = *p++) != '{' && c != '\n' && c)
    /* Do nothing. */ ;

  if (c != '{')
    return p - 1;

  if (ignore_blanks)
    while ((c = *p) == ' ' || c == '\t')
      p++;

  for (i = 0; i < chars; i++)
    {
      if (!*p || *p == '\n')
        break;
      p++;
    }
  return p;
}

/* Find the end of the balanced-brace field which starts at STR.
   The position returned is just before the closing brace. */

char *
find_braced_end (char *str)
{
  int bracelevel;
  char *p = str;
  char c;

  bracelevel = 1;
  while (bracelevel)
    {
      c = *p++;
      if (c == '{')
        bracelevel++;
      if (c == '}')
        bracelevel--;
      if (c == 0 || c == '\n')
        return p - 1;
    }
  return p - 1;
}

long
find_value (char *start, long int length)
{
  while (length != 0L)
    {
      if (isdigit (*start))
        return atol (start);
      length--;
      start++;
    }
  return 0l;
}

/* Vector used to translate characters for comparison.
   This is how we make all alphanumerics follow all else,
   and ignore case in the first sorting.  */
int char_order[256];

void
init_char_order (void)
{
  int i;
  for (i = 1; i < 256; i++)
    char_order[i] = i;

  for (i = '0'; i <= '9'; i++)
    char_order[i] += 512;

  for (i = 'a'; i <= 'z'; i++)
    {
      char_order[i] = 512 + i;
      char_order[i + 'A' - 'a'] = 512 + i;
    }
}

/* Compare two fields (each specified as a start pointer and a character count)
   according to KEYFIELD.
   The sign of the value reports the relation between the fields. */

int
compare_field (struct keyfield *keyfield, char *start1, long int length1,
               long int pos1, char *start2, long int length2, long int pos2)
{
  if (keyfields->positional)
    {
      if (pos1 > pos2)
        return 1;
      else
        return -1;
    }
  if (keyfield->numeric)
    {
      long value = find_value (start1, length1) - find_value (start2, length2);
      if (value > 0)
        return 1;
      if (value < 0)
        return -1;
      return 0;
    }
  else
    {
      char *p1 = start1;
      char *p2 = start2;
      char *e1 = start1 + length1;
      char *e2 = start2 + length2;

      while (1)
        {
          int c1, c2;

          if (p1 == e1)
            c1 = 0;
          else
            c1 = *p1++;
          if (p2 == e2)
            c2 = 0;
          else
            c2 = *p2++;

          if (char_order[c1] != char_order[c2])
            return char_order[c1] - char_order[c2];
          if (!c1)
            break;
        }

      /* Strings are equal except possibly for case.  */
      p1 = start1;
      p2 = start2;
      while (1)
        {
          int c1, c2;

          if (p1 == e1)
            c1 = 0;
          else
            c1 = *p1++;
          if (p2 == e2)
            c2 = 0;
          else
            c2 = *p2++;

          if (c1 != c2)
            /* Reverse sign here so upper case comes out last.  */
            return c2 - c1;
          if (!c1)
            break;
        }

      return 0;
    }
}

/* A `struct linebuffer' is a structure which holds a line of text.
   `readline' reads a line from a stream into a linebuffer
   and works regardless of the length of the line.  */

struct linebuffer
{
  long size;
  char *buffer;
};

/* Initialize LINEBUFFER for use. */

void
initbuffer (struct linebuffer *linebuffer)
{
  linebuffer->size = 200;
  linebuffer->buffer = (char *) xmalloc (200);
}

/* Read a line of text from STREAM into LINEBUFFER.
   Return the length of the line.  */

long
readline (struct linebuffer *linebuffer, FILE *stream)
{
  char *buffer = linebuffer->buffer;
  char *p = linebuffer->buffer;
  char *end = p + linebuffer->size;

  while (1)
    {
      int c = getc (stream);
      if (p == end)
        {
          buffer = (char *) xrealloc (buffer, linebuffer->size *= 2);
          p += buffer - linebuffer->buffer;
          end += buffer - linebuffer->buffer;
          linebuffer->buffer = buffer;
        }
      if (c < 0 || c == '\n')
        {
          *p = 0;
          break;
        }
      *p++ = c;
    }

  return p - buffer;
}

/* Sort an input file too big to sort in core.  */

void
sort_offline (char *infile, off_t total, char *outfile)
{
  /* More than enough. */
  int ntemps = 2 * (total + MAX_IN_CORE_SORT - 1) / MAX_IN_CORE_SORT;
  char **tempfiles = (char **) xmalloc (ntemps * sizeof (char *));
  FILE *istream = fopen (infile, "r");
  int i;
  struct linebuffer lb;
  long linelength;
  int failure = 0;

  initbuffer (&lb);

  /* Read in one line of input data.  */

  linelength = readline (&lb, istream);

  if (lb.buffer[0] != '\\' && lb.buffer[0] != '@@')
    {
      error (_("%s: not a texinfo index file"), infile);
      return;
    }

  /* Split up the input into `ntemps' temporary files, or maybe fewer,
     and put the new files' names into `tempfiles' */

  for (i = 0; i < ntemps; i++)
    {
      char *outname = maketempname (++tempcount);
      FILE *ostream;
      long tempsize = 0;

      if (!outname)
        pfatal_with_name("temporary file");
      ostream = fopen (outname, "w");
      if (!outname || !ostream)
        pfatal_with_name (outname);
      tempfiles[i] = outname;

      /* Copy lines into this temp file as long as it does not make file
         "too big" or until there are no more lines.  */

      while (tempsize + linelength + 1 <= MAX_IN_CORE_SORT)
        {
          tempsize += linelength + 1;
          fputs (lb.buffer, ostream);
          putc ('\n', ostream);

          /* Read another line of input data.  */

          linelength = readline (&lb, istream);
          if (!linelength && feof (istream))
            break;

          if (lb.buffer[0] != '\\' && lb.buffer[0] != '@@')
            {
              error (_("%s: not a texinfo index file"), infile);
              failure = 1;
              goto fail;
            }
        }
      fclose (ostream);
      if (feof (istream))
        break;
    }

  free (lb.buffer);

fail:
  /* Record number of temp files we actually needed.  */

  ntemps = i;

  /* Sort each tempfile into another tempfile.
    Delete the first set of tempfiles and put the names of the second
    into `tempfiles'. */

  for (i = 0; i < ntemps; i++)
    {
      char *newtemp = maketempname (++tempcount);
      sort_in_core (tempfiles[i], MAX_IN_CORE_SORT, newtemp);
      if (!keep_tempfiles)
        unlink (tempfiles[i]);
      tempfiles[i] = newtemp;
    }

  if (failure)
    return;

  /* Merge the tempfiles together and indexify. */

  merge_files (tempfiles, ntemps, outfile);
}

/* Sort INFILE, whose size is TOTAL,
   assuming that is small enough to be done in-core,
   then indexify it and send the output to OUTFILE (or to stdout).  */

void
sort_in_core (char *infile, int total, char *outfile)
{
  char **nextline;
  char *data = (char *) xmalloc (total + 1);
  char *file_data;
  long file_size;
  int i;
  FILE *ostream = stdout;
  struct lineinfo *lineinfo;

  /* Read the contents of the file into the moby array `data'. */

  int desc = open (infile, O_RDONLY, 0);

  if (desc < 0)
    fatal (_("failure reopening %s"), infile);
  for (file_size = 0;;)
    {
      i = read (desc, data + file_size, total - file_size);
      if (i <= 0)
        break;
      file_size += i;
    }
  file_data = data;
  data[file_size] = 0;

  close (desc);

  if (file_size > 0 && data[0] != '\\' && data[0] != '@@')
    {
      error (_("%s: not a texinfo index file"), infile);
      return;
    }

  init_char_order ();

  /* Sort routines want to know this address. */

  text_base = data;

  /* Create the array of pointers to lines, with a default size
     frequently enough.  */

  nlines = total / 50;
  if (!nlines)
    nlines = 2;
  linearray = (char **) xmalloc (nlines * sizeof (char *));

  /* `nextline' points to the next free slot in this array.
     `nlines' is the allocated size.  */

  nextline = linearray;

  /* Parse the input file's data, and make entries for the lines.  */

  nextline = parsefile (infile, nextline, file_data, file_size);
  if (nextline == 0)
    {
      error (_("%s: not a texinfo index file"), infile);
      return;
    }

  /* Sort the lines. */

  /* If we have enough space, find the first keyfield of each line in advance.
     Make a `struct lineinfo' for each line, which records the keyfield
     as well as the line, and sort them.  */

  lineinfo = malloc ((nextline - linearray) * sizeof (struct lineinfo));

  if (lineinfo)
    {
      struct lineinfo *lp;
      char **p;

      for (lp = lineinfo, p = linearray; p != nextline; lp++, p++)
        {
          lp->text = *p;
          lp->key.text = find_field (keyfields, *p, &lp->keylen);
          if (keyfields->numeric)
            lp->key.number = find_value (lp->key.text, lp->keylen);
        }

      qsort (lineinfo, nextline - linearray, sizeof (struct lineinfo),
             compare_prepared);

      for (lp = lineinfo, p = linearray; p != nextline; lp++, p++)
        *p = lp->text;

      free (lineinfo);
    }
  else
    qsort (linearray, nextline - linearray, sizeof (char *), compare_full);

  /* Open the output file. */

  if (outfile)
    {
      ostream = fopen (outfile, "w");
      if (!ostream)
        pfatal_with_name (outfile);
    }

  writelines (linearray, nextline - linearray, ostream);
  if (outfile)
    fclose (ostream);

  free (linearray);
  free (data);
}

/* Parse an input string in core into lines.
   DATA is the input string, and SIZE is its length.
   Data goes in LINEARRAY starting at NEXTLINE.
   The value returned is the first entry in LINEARRAY still unused.
   Value 0 means input file contents are invalid.  */

char **
parsefile (char *filename, char **nextline, char *data, long int size)
{
  char *p, *end;
  char **line = nextline;

  p = data;
  end = p + size;
  *end = 0;

  while (p != end)
    {
      if (p[0] != '\\' && p[0] != '@@')
        return 0;

      *line = p;

      /* Find the first letter of the first field of this line.  If it
         is different from the first letter of the first field of the
         first line, we need initial headers in the output index.  */
      while (*p && *p != '{')
        p++;
      if (p == end)
        return 0;
      p++;
      if (first_initial)
        {
          if (first_initial != toupper (*p))
            need_initials = 1;
        }
      else
        first_initial = toupper (*p);

      while (*p && *p != '\n')
        p++;
      if (p != end)
        p++;

      line++;
      if (line == linearray + nlines)
        {
          char **old = linearray;
          linearray = xrealloc (linearray, sizeof (char *) * (nlines *= 4));
          line += linearray - old;
        }
    }

  return line;
}

/* Indexification is a filter applied to the sorted lines
   as they are being written to the output file.
   Multiple entries for the same name, with different page numbers,
   get combined into a single entry with multiple page numbers.
   The first braced field, which is used for sorting, is discarded.
   However, its first character is examined, folded to lower case,
   and if it is different from that in the previous line fed to us
   a \initial line is written with one argument, the new initial.

   If an entry has four braced fields, then the second and third
   constitute primary and secondary names.
   In this case, each change of primary name
   generates a \primary line which contains only the primary name,
   and in between these are \secondary lines which contain
   just a secondary name and page numbers. */

/* The last primary name we wrote a \primary entry for.
   If only one level of indexing is being done, this is the last name seen. */
char *lastprimary;
/* Length of storage allocated for lastprimary. */
int lastprimarylength;

/* Similar, for the secondary name. */
char *lastsecondary;
int lastsecondarylength;

/* Zero if we are not in the middle of writing an entry.
   One if we have written the beginning of an entry but have not
   yet written any page numbers into it.
   Greater than one if we have written the beginning of an entry
   plus at least one page number. */
int pending;

/* The initial (for sorting purposes) of the last primary entry written.
   When this changes, a \initial {c} line is written */

char *lastinitial;

int lastinitiallength;

/* When we need a string of length 1 for the value of lastinitial,
   store it here.  */

char lastinitial1[2];

/* Initialize static storage for writing an index. */

void
init_index (void)
{
  pending = 0;
  lastinitial = lastinitial1;
  lastinitial1[0] = 0;
  lastinitial1[1] = 0;
  lastinitiallength = 0;
  lastprimarylength = 100;
  lastprimary = (char *) xmalloc (lastprimarylength + 1);
  memset (lastprimary, '\0', lastprimarylength + 1);
  lastsecondarylength = 100;
  lastsecondary = (char *) xmalloc (lastsecondarylength + 1);
  memset (lastsecondary, '\0', lastsecondarylength + 1);
}

/* Indexify.  Merge entries for the same name,
   insert headers for each initial character, etc.  */

void
indexify (char *line, FILE *ostream)
{
  char *primary, *secondary, *pagenumber;
  int primarylength, secondarylength = 0, pagelength;
  int nosecondary;
  int initiallength;
  char *initial;
  char initial1[2];
  register char *p;

  /* First, analyze the parts of the entry fed to us this time. */

  p = find_braced_pos (line, 0, 0, 0);
  if (*p == '{')
    {
      initial = p;
      /* Get length of inner pair of braces starting at `p',
         including that inner pair of braces.  */
      initiallength = find_braced_end (p + 1) + 1 - p;
    }
  else
    {
      initial = initial1;
      initial1[0] = toupper (*p);
      initial1[1] = 0;
      initiallength = 1;
    }

  pagenumber = find_braced_pos (line, 1, 0, 0);
  pagelength = find_braced_end (pagenumber) - pagenumber;
  if (pagelength == 0)
    fatal (_("No page number in %s"), line);

  primary = find_braced_pos (line, 2, 0, 0);
  primarylength = find_braced_end (primary) - primary;

  secondary = find_braced_pos (line, 3, 0, 0);
  nosecondary = !*secondary;
  if (!nosecondary)
    secondarylength = find_braced_end (secondary) - secondary;

  /* If the primary is different from before, make a new primary entry. */
  if (strncmp (primary, lastprimary, primarylength))
    {
      /* Close off current secondary entry first, if one is open. */
      if (pending)
        {
          fputs ("}\n", ostream);
          pending = 0;
        }

      /* If this primary has a different initial, include an entry for
         the initial. */
      if (need_initials &&
          (initiallength != lastinitiallength ||
           strncmp (initial, lastinitial, initiallength)))
        {
          fprintf (ostream, "\\initial {");
          fwrite (initial, 1, initiallength, ostream);
          fputs ("}\n", ostream);
          if (initial == initial1)
            {
              lastinitial = lastinitial1;
              *lastinitial1 = *initial1;
            }
          else
            {
              lastinitial = initial;
            }
          lastinitiallength = initiallength;
        }

      /* Make the entry for the primary.  */
      if (nosecondary)
        fputs ("\\entry {", ostream);
      else
        fputs ("\\primary {", ostream);
      fwrite (primary, primarylength, 1, ostream);
      if (nosecondary)
        {
          fputs ("}{", ostream);
          pending = 1;
        }
      else
        fputs ("}\n", ostream);

      /* Record name of most recent primary. */
      if (lastprimarylength < primarylength)
        {
          lastprimarylength = primarylength + 100;
          lastprimary = (char *) xrealloc (lastprimary,
                                           1 + lastprimarylength);
        }
      strncpy (lastprimary, primary, primarylength);
      lastprimary[primarylength] = 0;

      /* There is no current secondary within this primary, now. */
      lastsecondary[0] = 0;
    }

  /* Should not have an entry with no subtopic following one with a
     subtopic. */

  if (nosecondary && *lastsecondary)
    error (_("entry %s follows an entry with a secondary name"), line);

  /* Start a new secondary entry if necessary. */
  if (!nosecondary && strncmp (secondary, lastsecondary, secondarylength))
    {
      if (pending)
        {
          fputs ("}\n", ostream);
          pending = 0;
        }

      /* Write the entry for the secondary.  */
      fputs ("\\secondary {", ostream);
      fwrite (secondary, secondarylength, 1, ostream);
      fputs ("}{", ostream);
      pending = 1;

      /* Record name of most recent secondary. */
      if (lastsecondarylength < secondarylength)
        {
          lastsecondarylength = secondarylength + 100;
          lastsecondary = (char *) xrealloc (lastsecondary,
                                             1 + lastsecondarylength);
        }
      strncpy (lastsecondary, secondary, secondarylength);
      lastsecondary[secondarylength] = 0;
    }

  /* Here to add one more page number to the current entry. */
  if (pending++ != 1)
    fputs (", ", ostream);  /* Punctuate first, if this is not the first. */
  fwrite (pagenumber, pagelength, 1, ostream);
}

/* Close out any unfinished output entry. */

void
finish_index (FILE *ostream)
{
  if (pending)
    fputs ("}\n", ostream);
  free (lastprimary);
  free (lastsecondary);
}

/* Copy the lines in the sorted order.
   Each line is copied out of the input file it was found in. */

void
writelines (char **linearray, int nlines, FILE *ostream)
{
  char **stop_line = linearray + nlines;
  char **next_line;

  init_index ();

  /* Output the text of the lines, and free the buffer space. */

  for (next_line = linearray; next_line != stop_line; next_line++)
    {
      /* If -u was specified, output the line only if distinct from
         previous one.  */
      if (next_line == linearray
      /* Compare previous line with this one, using only the
         explicitly specd keyfields. */
          || compare_general (*(next_line - 1), *next_line, 0L, 0L,
                              num_keyfields - 1))
        {
          char *p = *next_line;
          char c;

          while ((c = *p++) && c != '\n')
            /* Do nothing. */ ;
          *(p - 1) = 0;
          indexify (*next_line, ostream);
        }
    }

  finish_index (ostream);
}

/* Assume (and optionally verify) that each input file is sorted;
   merge them and output the result.
   Returns nonzero if any input file fails to be sorted.

   This is the high-level interface that can handle an unlimited
   number of files.  */

#define MAX_DIRECT_MERGE 10

int
merge_files (char **infiles, int nfiles, char *outfile)
{
  char **tempfiles;
  int ntemps;
  int i;
  int value = 0;
  int start_tempcount = tempcount;

  if (nfiles <= MAX_DIRECT_MERGE)
    return merge_direct (infiles, nfiles, outfile);

  /* Merge groups of MAX_DIRECT_MERGE input files at a time,
     making a temporary file to hold each group's result.  */

  ntemps = (nfiles + MAX_DIRECT_MERGE - 1) / MAX_DIRECT_MERGE;
  tempfiles = (char **) xmalloc (ntemps * sizeof (char *));
  for (i = 0; i < ntemps; i++)
    {
      int nf = MAX_DIRECT_MERGE;
      if (i + 1 == ntemps)
        nf = nfiles - i * MAX_DIRECT_MERGE;
      tempfiles[i] = maketempname (++tempcount);
      if (!tempfiles[i])
        pfatal_with_name("temp file");
      value |= merge_direct (&infiles[i * MAX_DIRECT_MERGE], nf, tempfiles[i]);
    }

  /* All temporary files that existed before are no longer needed
     since their contents have been merged into our new tempfiles.
     So delete them.  */
  flush_tempfiles (start_tempcount);

  /* Now merge the temporary files we created.  */

  merge_files (tempfiles, ntemps, outfile);

  free (tempfiles);

  return value;
}

/* Assume (and optionally verify) that each input file is sorted;
   merge them and output the result.
   Returns nonzero if any input file fails to be sorted.

   This version of merging will not work if the number of
   input files gets too high.  Higher level functions
   use it only with a bounded number of input files.  */

int
merge_direct (char **infiles, int nfiles, char *outfile)
{
  struct linebuffer *lb1, *lb2;
  struct linebuffer **thisline, **prevline;
  FILE **streams;
  int i;
  int nleft;
  int lossage = 0;
  int *file_lossage;
  struct linebuffer *prev_out = 0;
  FILE *ostream = stdout;

  if (outfile)
    {
      ostream = fopen (outfile, "w");
    }
  if (!ostream)
    pfatal_with_name (outfile);

  init_index ();

  if (nfiles == 0)
    {
      if (outfile)
        fclose (ostream);
      return 0;
    }

  /* For each file, make two line buffers.  Also, for each file, there
     is an element of `thisline' which points at any time to one of the
     file's two buffers, and an element of `prevline' which points to
     the other buffer.  `thisline' is supposed to point to the next
     available line from the file, while `prevline' holds the last file
     line used, which is remembered so that we can verify that the file
     is properly sorted. */

  /* lb1 and lb2 contain one buffer each per file. */
  lb1 = (struct linebuffer *) xmalloc (nfiles * sizeof (struct linebuffer));
  lb2 = (struct linebuffer *) xmalloc (nfiles * sizeof (struct linebuffer));

  /* thisline[i] points to the linebuffer holding the next available
     line in file i, or is zero if there are no lines left in that file.  */
  thisline = (struct linebuffer **)
    xmalloc (nfiles * sizeof (struct linebuffer *));
  /* prevline[i] points to the linebuffer holding the last used line
     from file i.  This is just for verifying that file i is properly
     sorted.  */
  prevline = (struct linebuffer **)
    xmalloc (nfiles * sizeof (struct linebuffer *));
  /* streams[i] holds the input stream for file i.  */
  streams = (FILE **) xmalloc (nfiles * sizeof (FILE *));
  /* file_lossage[i] is nonzero if we already know file i is not
     properly sorted.  */
  file_lossage = (int *) xmalloc (nfiles * sizeof (int));

  /* Allocate and initialize all that storage. */

  for (i = 0; i < nfiles; i++)
    {
      initbuffer (&lb1[i]);
      initbuffer (&lb2[i]);
      thisline[i] = &lb1[i];
      prevline[i] = &lb2[i];
      file_lossage[i] = 0;
      streams[i] = fopen (infiles[i], "r");
      if (!streams[i])
        pfatal_with_name (infiles[i]);

      readline (thisline[i], streams[i]);
    }

  /* Keep count of number of files not at eof. */
  nleft = nfiles;

  while (nleft)
    {
      struct linebuffer *best = 0;
      struct linebuffer *exch;
      int bestfile = -1;
      int i;

      /* Look at the next avail line of each file; choose the least one.  */

      for (i = 0; i < nfiles; i++)
        {
          if (thisline[i] &&
              (!best ||
               0 < compare_general (best->buffer, thisline[i]->buffer,
                                 (long) bestfile, (long) i, num_keyfields)))
            {
              best = thisline[i];
              bestfile = i;
            }
        }

      /* Output that line, unless it matches the previous one and we
         don't want duplicates. */

      if (!(prev_out &&
            !compare_general (prev_out->buffer,
                              best->buffer, 0L, 1L, num_keyfields - 1)))
        indexify (best->buffer, ostream);
      prev_out = best;

      /* Now make the line the previous of its file, and fetch a new
         line from that file.  */

      exch = prevline[bestfile];
      prevline[bestfile] = thisline[bestfile];
      thisline[bestfile] = exch;

      while (1)
        {
          /* If the file has no more, mark it empty. */

          if (feof (streams[bestfile]))
            {
              thisline[bestfile] = 0;
              /* Update the number of files still not empty. */
              nleft--;
              break;
            }
          readline (thisline[bestfile], streams[bestfile]);
          if (thisline[bestfile]->buffer[0] || !feof (streams[bestfile]))
            break;
        }
    }

  finish_index (ostream);

  /* Free all storage and close all input streams. */

  for (i = 0; i < nfiles; i++)
    {
      fclose (streams[i]);
      free (lb1[i].buffer);
      free (lb2[i].buffer);
    }
  free (file_lossage);
  free (lb1);
  free (lb2);
  free (thisline);
  free (prevline);
  free (streams);

  if (outfile)
    fclose (ostream);

  return lossage;
}

/* Print error message and exit.  */

void
fatal (const char *format, const char *arg)
{
  error (format, arg);
  xexit (1);
}

/* Print error message.  FORMAT is printf control string, ARG is arg for it. */
void
error (const char *format, const char *arg)
{
  printf ("%s: ", program_name);
  printf (format, arg);
  if (format[strlen (format) -1] != '\n')
    printf ("\n");
}

void
perror_with_name (const char *name)
{
  fprintf (stderr, "%s: ", program_name);
  perror (name);
}

void
pfatal_with_name (const char *name)
{
  perror_with_name (name);
  xexit (1);
}


/* Return a newly-allocated string concatenating S1 and S2.  */

char *
concat (char *s1, char *s2)
{
  int len1 = strlen (s1), len2 = strlen (s2);
  char *result = (char *) xmalloc (len1 + len2 + 1);

  strcpy (result, s1);
  strcpy (result + len1, s2);
  *(result + len1 + len2) = 0;

  return result;
}
@


1.5
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: texindex.c,v 1.11 2004/04/11 17:56:47 karl Exp $
d164 3
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d1 2
a2 2
/* Process TeX index dribble output into an actual index.
   $Id: texindex.c,v 1.41 2002/03/11 19:55:46 karl Exp $
d4 2
a5 2
   Copyright (C) 1987, 91, 92, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc. 
d40 1
a40 1
char *mktemp ();
d48 2
a101 3
/* Start of filename to use for temporary files.  */
char *tempbase;

d113 7
d126 20
a145 18
void decode_command ();
void sort_in_core ();
void sort_offline ();
char **parsefile ();
char *find_field ();
char *find_pos ();
long find_value ();
char *find_braced_pos ();
char *find_braced_end ();
void writelines ();
int compare_field ();
int compare_full ();
long readline ();
int merge_files ();
int merge_direct ();
void pfatal_with_name ();
void fatal ();
void error ();
d147 2
a148 2
char *concat ();
void flush_tempfiles ();
d153 1
a153 3
main (argc, argv)
     int argc;
     char **argv;
d169 3
a192 5
  /* XXX mkstemp not appropriate, as we need to have somewhat predictable
   * names. But race condition was fixed, see maketempname. 
   */
  tempbase = mktemp (concat ("txiXXXXXX", "", ""));

d223 4
a226 3
        {
          outfile = concat (infiles[i], "s", "");
        }
d230 1
a230 1
        sort_in_core (infiles[i], ptr, outfile);
a236 1

d265 1
a265 2
usage (result_value)
     int result_value;
d305 1
a305 3
decode_command (argc, argv)
     int argc;
     char **argv;
d321 1
a321 1
    tempdir = concat (tempdir, "/", "");
d342 2
a343 2
              printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
d345 1
a345 2
For more information about these matters, see the files named COPYING.\n"),
                  "2002");
d387 1
a387 1
/* Return a name for a temporary file. */
d390 1
a390 2
maketempname (count)
     int count;
d392 1
d397 10
d408 1
a408 1
  name =  concat (tempdir, tempbase, tempsuffix);
d420 1
d424 1
a424 2
flush_tempfiles (to_count)
     int to_count;
d436 1
a436 2
compare_full (line1, line2)
     char **line1, **line2;
d438 2
d451 2
a452 1
      int tem = compare_field (&keyfields[i], start1, length1, *line1 - text_base,
a468 1

d470 1
a470 2
compare_prepared (line1, line2)
     struct lineinfo *line1, *line2;
d472 2
d510 2
a511 1
      int tem = compare_field (&keyfields[i], start1, length1, text1 - text_base,
d530 1
a530 4
compare_general (str1, str2, pos1, pos2, use_keyfields)
     char *str1, *str2;
     long pos1, pos2;
     int use_keyfields;
d561 1
a561 4
find_field (keyfield, str, lengthptr)
     struct keyfield *keyfield;
     char *str;
     long *lengthptr;
d601 1
a601 4
find_pos (str, words, chars, ignore_blanks)
     char *str;
     int words, chars;
     int ignore_blanks;
d634 1
a634 4
find_braced_pos (str, words, chars, ignore_blanks)
     char *str;
     int words, chars;
     int ignore_blanks;
d683 1
a683 2
find_braced_end (str)
     char *str;
d704 1
a704 3
find_value (start, length)
     char *start;
     long length;
d722 1
a722 1
init_char_order ()
d743 2
a744 8
compare_field (keyfield, start1, length1, pos1, start2, length2, pos2)
     struct keyfield *keyfield;
     char *start1;
     long length1;
     long pos1;
     char *start2;
     long length2;
     long pos2;
d828 1
a828 2
initbuffer (linebuffer)
     struct linebuffer *linebuffer;
d838 1
a838 3
readline (linebuffer, stream)
     struct linebuffer *linebuffer;
     FILE *stream;
d868 1
a868 5
sort_offline (infile, nfiles, total, outfile)
     char *infile;
     int nfiles;
     off_t total;
     char *outfile;
d948 1
a948 1
      sort_in_core (&tempfiles[i], MAX_IN_CORE_SORT, newtemp);
d967 1
a967 4
sort_in_core (infile, total, outfile)
     char *infile;
     off_t total;
     char *outfile;
d1035 1
a1035 1
  lineinfo = (struct lineinfo *) malloc ((nextline - linearray) * sizeof (struct lineinfo));
d1085 1
a1085 5
parsefile (filename, nextline, data, size)
     char *filename;
     char **nextline;
     char *data;
     long size;
d1100 17
d1126 1
a1126 1
          linearray = (char **) xrealloc (linearray, sizeof (char *) * (nlines *= 4));
d1182 1
a1182 1
init_index ()
d1201 1
a1201 3
indexify (line, ostream)
     char *line;
     FILE *ostream;
d1224 1
a1224 1
      initial1[0] = *p;
a1226 3

      if (initial1[0] >= 'a' && initial1[0] <= 'z')
        initial1[0] -= 040;
d1254 3
a1256 2
      if (initiallength != lastinitiallength ||
          strncmp (initial, lastinitial, initiallength))
d1301 2
a1302 1
  /* Should not have an entry with no subtopic following one with a subtopic. */
d1335 1
a1335 1
    fputs (", ", ostream);      /* Punctuate first, if this is not the first. */
d1342 1
a1342 2
finish_index (ostream)
     FILE *ostream;
d1354 1
a1354 4
writelines (linearray, nlines, ostream)
     char **linearray;
     int nlines;
     FILE *ostream;
d1365 2
a1366 1
      /* If -u was specified, output the line only if distinct from previous one.  */
d1370 2
a1371 1
          || compare_general (*(next_line - 1), *next_line, 0L, 0L, num_keyfields - 1))
d1396 1
a1396 4
merge_files (infiles, nfiles, outfile)
     char **infiles;
     int nfiles;
     char *outfile;
d1446 1
a1446 4
merge_direct (infiles, nfiles, outfile)
     char **infiles;
     int nfiles;
     char *outfile;
d1474 7
a1480 7
  /* For each file, make two line buffers.
     Also, for each file, there is an element of `thisline'
     which points at any time to one of the file's two buffers,
     and an element of `prevline' which points to the other buffer.
     `thisline' is supposed to point to the next available line from the file,
     while `prevline' holds the last file line used,
     which is remembered so that we can verify that the file is properly sorted. */
d1486 2
a1487 2
  /* thisline[i] points to the linebuffer holding the next available line in file i,
     or is zero if there are no lines left in that file.  */
d1600 1
a1600 2
fatal (format, arg)
     char *format, *arg;
d1608 1
a1608 2
error (format, arg)
     char *format, *arg;
d1617 1
a1617 2
perror_with_name (name)
     char *name;
d1619 2
a1620 5
  char *s;

  s = strerror (errno);
  printf ("%s: ", program_name);
  printf ("%s; for file `%s'.\n", s, name);
d1624 1
a1624 2
pfatal_with_name (name)
     char *name;
d1626 1
a1626 5
  char *s;

  s = strerror (errno);
  printf ("%s: ", program_name);
  printf (_("%s; for file `%s'.\n"), s, name);
d1630 2
a1631 2
/* Return a newly-allocated string whose contents concatenate those of
   S1, S2, S3.  */
d1634 1
a1634 2
concat (s1, s2, s3)
     char *s1, *s2, *s3;
d1636 2
a1637 2
  int len1 = strlen (s1), len2 = strlen (s2), len3 = strlen (s3);
  char *result = (char *) xmalloc (len1 + len2 + len3 + 1);
d1641 1
a1641 2
  strcpy (result + len1 + len2, s3);
  *(result + len1 + len2 + len3) = 0;
a1644 16

#if !defined (HAVE_STRCHR)
char *
strrchr (string, character)
     char *string;
     int character;
{
  register int i;

  for (i = strlen (string) - 1; i > -1; i--)
    if (string[i] == character)
      return (string + i);

  return ((char *)NULL);
}
#endif /* HAVE_STRCHR */
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: texindex.c,v 1.34 1999/08/06 17:03:14 karl Exp $
d4 2
a5 1
   Copyright (C) 1987, 91, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
d292 2
a293 1
"), f);
d345 1
a345 1
                  "1999");
d398 2
a399 2
  name = concat (tempdir, tempbase, tempsuffix);
  
a962 2
      if (!newtemp)
        pfatal_with_name("temp file");
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* Prepare TeX index dribble output into an actual index.
   $Id: texindex.c,v 1.22 1998/02/22 23:00:09 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 91, 92, 96, 97, 98 Free Software Foundation, Inc.
d23 2
a38 1

a40 10
#if defined (VMS)
#  include <file.h>
#  define TI_NO_ERROR ((1 << 28) | 1)
#  define TI_FATAL_ERROR ((1 << 28) | 4)
#  define unlink delete
#else /* !VMS */
#  define TI_NO_ERROR 0
#  define TI_FATAL_ERROR 1
#endif /* !VMS */

a117 3
/* The name this program was run with. */
char *program_name;

a118 1

a138 1
char *maketempname ();
a139 1
char *tempcopy ();
a152 6
  program_name = strrchr (argv[0], '/');
  if (program_name != (char *)NULL)
    program_name++;
  else
    program_name = argv[0];

d183 3
d193 1
a193 1
      long ptr;
d195 1
d200 11
d212 1
a212 1
      ptr = (long) lseek (desc, (off_t) 0, SEEK_CUR);
d230 2
a231 2
  exit (TI_NO_ERROR);
  
d246 2
a255 2
  { "--help", "-h", (int *)NULL, 0, (char *)NULL,
      N_("display this help and exit") },
d269 3
a271 1
  fprintf (f, _("Usually FILE... is `foo.??\' for a document `foo.texi'.\n"));
d276 2
d288 4
a291 1
  puts (_("\nEmail bug reports to bug-texinfo@@gnu.org."));
d293 1
a293 1
  exit (result_value);
a310 1
#ifdef VMS
d312 1
a312 2
    tempdir = "sys$scratch:";
#else
d314 3
a316 1
    tempdir = "/tmp/";
a318 1
#endif
d338 2
a339 1
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d343 2
a344 2
		  "1998");
              exit (0);
d387 1
a387 1
char *
d392 14
a405 2
  sprintf (tempsuffix, "%d", count);
  return concat (tempdir, tempbase, tempsuffix);
a419 30
/* Copy the input file open on IDESC into a temporary file
   and return the temporary file name. */

#define BUFSIZE 1024

char *
tempcopy (idesc)
     int idesc;
{
  char *outfile = maketempname (++tempcount);
  int odesc;
  char buffer[BUFSIZE];

  odesc = open (outfile, O_WRONLY | O_CREAT, 0666);

  if (odesc < 0)
    pfatal_with_name (outfile);

  while (1)
    {
      int nread = read (idesc, buffer, BUFSIZE);
      write (odesc, buffer, nread);
      if (!nread)
        break;
    }

  close (odesc);

  return outfile;
}
d880 1
a880 1
     long total;
d910 1
a910 1
      FILE *ostream = fopen (outname, "w");
d913 4
a916 1
      if (!ostream)
d961 2
d984 1
a984 1
     long total;
d1242 1
a1242 1
    abort ();
d1431 2
d1620 1
a1620 1
  exit (TI_FATAL_ERROR);
d1654 1
a1654 1
  exit (TI_FATAL_ERROR);
a1674 15
#if !defined (HAVE_STRERROR)
extern char *sys_errlist[];
extern int sys_nerr;

char *
strerror (num)
     int num;
{
  if (num >= sys_nerr)
    return ("");
  else
    return (sys_errlist[num]);
}
#endif /* !HAVE_STRERROR */

a1689 47

void
memory_error (callers_name, bytes_wanted)
     char *callers_name;
     int bytes_wanted;
{
  char printable_string[80];

  sprintf (printable_string,
           _("Virtual memory exhausted in %s ()!  Needed %d bytes."),
           callers_name, bytes_wanted);

  error (printable_string);
  abort ();
}

/* Just like malloc, but kills the program in case of fatal error. */
void *
xmalloc (nbytes)
     int nbytes;
{
  void *temp = (void *) malloc (nbytes);

  if (nbytes && temp == (void *)NULL)
    memory_error ("xmalloc", nbytes);

  return (temp);
}

/* Like realloc (), but barfs if there isn't enough memory. */
void *
xrealloc (pointer, nbytes)
     void *pointer;
     int nbytes;
{
  void *temp;

  if (!pointer)
    temp = (void *)xmalloc (nbytes);
  else
    temp = (void *)realloc (pointer, nbytes);

  if (nbytes && !temp)
    memory_error ("xrealloc", nbytes);

  return (temp);
}
@


1.1
log
@Initial revision
@
text
@d2 1
d4 1
a4 3
   Version 1.45

   Copyright (C) 1987, 1991, 1992 Free Software Foundation, Inc.
a18 6


#include <stdio.h>
#include <ctype.h>
#include <errno.h>
#include "getopt.h"
d20 2
a21 1
#define TEXINDEX_VERSION_STRING "GNU Texindex 2.0 for Texinfo release 3.4"
a31 20
#if defined (HAVE_STRING_H)
#  include <string.h>
#endif /* HAVE_STRING_H */

#if !defined (HAVE_STRCHR)
char *strrchr ();
#endif /* !HAVE_STRCHR */

#if defined (STDC_HEADERS)
#  include <stdlib.h>
#else /* !STDC_HEADERS */
char *getenv (), *malloc (), *realloc ();
#endif /* !STDC_HEADERS */

#if defined (HAVE_UNISTD_H)
#  include <unistd.h>
#else /* !HAVE_UNISTD_H */
off_t lseek ();
#endif /* !HAVE_UNISTD_H */

a45 12
#  if defined (HAVE_SYS_FCNTL_H)
#    include <sys/types.h>
#    include <sys/fcntl.h>
#  endif /* HAVE_SYS_FCNTL_H */

#  if defined (_AIX) || !defined (_POSIX_VERSION)
#    include <sys/file.h>
#  else /* !AIX && _POSIX_VERSION */
#    if !defined (HAVE_SYS_FCNTL_H)
#      include <fcntl.h>
#    endif /* !HAVE_FCNTL_H */
#  endif /* !_AIX && _POSIX_VERSION */
a55 5
#if !defined (errno)
extern int errno;
#endif
char *strerror ();

d60 1
a60 1
  char *text;		/* The actual text of the line. */
d62 2
a63 2
    char *text;		/* The start of the key (for textual comparison). */
    long number;	/* The numeric value (for numeric comparison). */
d65 1
a65 1
  long keylen;		/* Length of KEY field. */
d71 10
a80 10
  int startwords;	/* Number of words to skip. */
  int startchars;	/* Number of additional chars to skip. */
  int endwords;		/* Number of words to ignore at end. */
  int endchars;		/* Ditto for characters of last word. */
  char ignore_blanks;	/* Non-zero means ignore spaces and tabs. */
  char fold_case;	/* Non-zero means case doesn't matter. */
  char reverse;		/* Non-zero means compare in reverse order. */
  char numeric;		/* Non-zeros means field is ASCII numeric. */
  char positional;	/* Sort according to file position. */
  char braced;		/* Count balanced-braced groupings as fields. */
d158 1
a158 1
void
d174 9
d216 1
a216 1
	pfatal_with_name (infiles[i]);
d224 3
a226 3
	{
	  outfile = concat (infiles[i], "s", "");
	}
d229 2
a230 2
	/* Sort a small amount of data. */
	sort_in_core (infiles[i], ptr, outfile);
d232 1
a232 1
	sort_offline (infiles[i], ptr, outfile);
d237 2
d253 1
a253 1
      "Keep temporary files around after processing" },
d255 1
a255 1
      "Do not keep temporary files around after processing (default)" },
d257 1
a257 1
      "Send output to FILE" },
d259 3
a261 2
      "Show version information" },
  { "--help", "-h", (int *)NULL, 0, (char *)NULL, "Produce this listing" },
d270 1
d272 5
a276 4
  fprintf (stderr, "Usage: %s [OPTIONS] FILE...\n", program_name);
  fprintf (stderr, "  Generate a permuted index for the TeX files given.\n");
  fprintf (stderr, "  Usually FILE... is `foo.??' for the source file `foo.tex'.\n");
  fprintf (stderr, "  The OPTIONS are:\n");
d280 2
a281 4
      fprintf (stderr, "    %s %s",
	       texindex_options[i].long_name,
	       texindex_options[i].arg_name ?
	       texindex_options[i].arg_name : "");
d283 6
a288 6
      if (texindex_options[i].short_name)
	fprintf (stderr, " \n    or %s %s",
		 texindex_options[i].short_name,
		 texindex_options[i].arg_name ?
		 texindex_options[i].arg_name : "");
      fprintf (stderr, "\t%s\n", texindex_options[i].doc_string);
d290 2
a303 1
  int optc;
d334 36
a369 31
	{
	  if (strcmp (arg, "--version") == 0)
	    {
	      fprintf (stderr, "%s\n", TEXINDEX_VERSION_STRING);
	      exit (0);
	    }
	  else if ((strcmp (arg, "--keep") == 0) ||
		   (strcmp (arg, "-k") == 0))
	    {
	      keep_tempfiles = 1;
	    }
	  else if ((strcmp (arg, "--help") == 0) ||
		   (strcmp (arg, "-h") == 0))
	    {
	      usage (0);
	    }
	  else if ((strcmp (arg, "--output") == 0) ||
		   (strcmp (arg, "-o") == 0))
	    {
	      if (argv[arg_index] != (char *)NULL)
		{
		  arg_index++;
		  if (op > outfiles)
		    *(op - 1) = argv[arg_index];
		}
	      else
		usage (1);
	    }
	  else
	    usage (1);
	}
d371 4
a374 4
	{
	  *ip++ = arg;
	  *op++ = (char *)NULL;
	}
d430 1
a430 1
	break;
d456 1
a456 1
			       start2, length2, *line2 - text_base);
d458 5
a462 5
	{
	  if (keyfields[i].reverse)
	    return -tem;
	  return tem;
	}
d465 1
a465 1
  return 0;			/* Lines match exactly. */
d485 1
a485 1
	tem = 1;
d487 1
a487 1
	tem = -1;
d493 1
a493 1
			 line2->key.text, line2->keylen, 0);
d497 1
a497 1
	return -tem;
d514 1
a514 1
			       start2, length2, text2 - text_base);
d516 5
a520 5
	{
	  if (keyfields[i].reverse)
	    return -tem;
	  return tem;
	}
d523 1
a523 1
  return 0;			/* Lines match exactly. */
d549 1
a549 1
			       start2, length2, pos2);
d551 5
a555 5
	{
	  if (keyfields[i].reverse)
	    return -tem;
	  return tem;
	}
d558 1
a558 1
  return 0;			/* Lines match exactly. */
d581 1
a581 1
		  keyfield->ignore_blanks);
d585 1
a585 1
	end = find_braced_end (start);
d587 5
a591 5
	{
	  end = start;
	  while (*end && *end != '\n')
	    end++;
	}
d597 1
a597 1
	end = start;
d622 1
a622 1
	p++;
d624 1
a624 1
	p++;
d626 1
a626 1
	return p;
d635 1
a635 1
	break;
d659 1
a659 1
	/* Do nothing. */ ;
d661 1
a661 1
	return p - 1;
d663 9
a671 9
	{
	  c = *p++;
	  if (c == '{')
	    bracelevel++;
	  if (c == '}')
	    bracelevel--;
	  if (c == 0 || c == '\n')
	    return p - 1;
	}
d687 1
a687 1
	break;
d709 1
a709 1
	bracelevel++;
d711 1
a711 1
	bracelevel--;
d713 1
a713 1
	return p - 1;
d726 1
a726 1
	return atol (start);
d772 1
a772 1
	return 1;
d774 1
a774 1
	return -1;
d780 1
a780 1
	return 1;
d782 1
a782 1
	return -1;
d793 2
a794 2
	{
	  int c1, c2;
d796 14
a809 14
	  if (p1 == e1)
	    c1 = 0;
	  else
	    c1 = *p1++;
	  if (p2 == e2)
	    c2 = 0;
	  else
	    c2 = *p2++;

	  if (char_order[c1] != char_order[c2])
	    return char_order[c1] - char_order[c2];
	  if (!c1)
	    break;
	}
d815 2
a816 2
	{
	  int c1, c2;
d818 15
a832 15
	  if (p1 == e1)
	    c1 = 0;
	  else
	    c1 = *p1++;
	  if (p2 == e2)
	    c2 = 0;
	  else
	    c2 = *p2++;

	  if (c1 != c2)
	    /* Reverse sign here so upper case comes out last.  */
	    return c2 - c1;
	  if (!c1)
	    break;
	}
d874 6
a879 6
	{
	  buffer = (char *) xrealloc (buffer, linebuffer->size *= 2);
	  p += buffer - linebuffer->buffer;
	  end += buffer - linebuffer->buffer;
	  linebuffer->buffer = buffer;
	}
d881 4
a884 4
	{
	  *p = 0;
	  break;
	}
d917 1
a917 1
      error ("%s: not a texinfo index file", infile);
d931 1
a931 1
	pfatal_with_name (outname);
d935 1
a935 1
	 "too big" or until there are no more lines.  */
d938 18
a955 18
	{
	  tempsize += linelength + 1;
	  fputs (lb.buffer, ostream);
	  putc ('\n', ostream);

	  /* Read another line of input data.  */

	  linelength = readline (&lb, istream);
	  if (!linelength && feof (istream))
	    break;

	  if (lb.buffer[0] != '\\' && lb.buffer[0] != '@@')
	    {
	      error ("%s: not a texinfo index file", infile);
	      failure = 1;
	      goto fail;
	    }
	}
d958 1
a958 1
	break;
d977 1
a977 1
	unlink (tempfiles[i]);
d1012 1
a1012 1
    fatal ("failure reopening %s", infile);
d1017 1
a1017 1
	break;
d1027 1
a1027 1
      error ("%s: not a texinfo index file", infile);
d1055 1
a1055 1
      error ("%s: not a texinfo index file", infile);
d1073 6
a1078 6
	{
	  lp->text = *p;
	  lp->key.text = find_field (keyfields, *p, &lp->keylen);
	  if (keyfields->numeric)
	    lp->key.number = find_value (lp->key.text, lp->keylen);
	}
d1080 2
a1081 1
      qsort (lineinfo, nextline - linearray, sizeof (struct lineinfo), compare_prepared);
d1084 1
a1084 1
	*p = lp->text;
d1097 1
a1097 1
	pfatal_with_name (outfile);
d1131 1
a1131 1
	return 0;
d1135 1
a1135 1
	p++;
d1137 1
a1137 1
	p++;
d1141 5
a1145 5
	{
	  char **old = linearray;
	  linearray = (char **) xrealloc (linearray, sizeof (char *) * (nlines *= 4));
	  line += linearray - old;
	}
d1237 1
a1237 1
	 including that inner pair of braces.  */
d1248 1
a1248 1
	initial1[0] -= 040;
d1269 4
a1272 4
	{
	  fputs ("}\n", ostream);
	  pending = 0;
	}
d1275 1
a1275 1
	 the initial. */
d1277 16
a1292 16
	  strncmp (initial, lastinitial, initiallength))
	{
	  fprintf (ostream, "\\initial {");
	  fwrite (initial, 1, initiallength, ostream);
	  fprintf (ostream, "}\n", initial);
	  if (initial == initial1)
	    {
	      lastinitial = lastinitial1;
	      *lastinitial1 = *initial1;
	    }
	  else
	    {
	      lastinitial = initial;
	    }
	  lastinitiallength = initiallength;
	}
d1296 1
a1296 1
	fputs ("\\entry {", ostream);
d1298 1
a1298 1
	fputs ("\\primary {", ostream);
d1301 4
a1304 4
	{
	  fputs ("}{", ostream);
	  pending = 1;
	}
d1306 1
a1306 1
	fputs ("}\n", ostream);
d1310 5
a1314 5
	{
	  lastprimarylength = primarylength + 100;
	  lastprimary = (char *) xrealloc (lastprimary,
					   1 + lastprimarylength);
	}
d1325 1
a1325 1
    error ("entry %s follows an entry with a secondary name", line);
d1331 4
a1334 4
	{
	  fputs ("}\n", ostream);
	  pending = 0;
	}
d1344 5
a1348 5
	{
	  lastsecondarylength = secondarylength + 100;
	  lastsecondary = (char *) xrealloc (lastsecondary,
					     1 + lastsecondarylength);
	}
d1355 1
a1355 1
    fputs (", ", ostream);	/* Punctuate first, if this is not the first. */
d1393 10
a1402 10
	  || compare_general (*(next_line - 1), *next_line, 0L, 0L, num_keyfields - 1))
	{
	  char *p = *next_line;
	  char c;

	  while ((c = *p++) && c != '\n')
	    /* Do nothing. */ ;
	  *(p - 1) = 0;
	  indexify (*next_line, ostream);
	}
d1441 1
a1441 1
	nf = nfiles - i * MAX_DIRECT_MERGE;
d1496 1
a1496 1
	fclose (ostream);
d1538 1
a1538 1
	pfatal_with_name (infiles[i]);
d1556 10
a1565 10
	{
	  if (thisline[i] &&
	      (!best ||
	       0 < compare_general (best->buffer, thisline[i]->buffer,
				 (long) bestfile, (long) i, num_keyfields)))
	    {
	      best = thisline[i];
	      bestfile = i;
	    }
	}
d1568 1
a1568 1
	 don't want duplicates. */
d1571 3
a1573 3
	    !compare_general (prev_out->buffer,
			      best->buffer, 0L, 1L, num_keyfields - 1)))
	indexify (best->buffer, ostream);
d1577 1
a1577 1
	 line from that file.  */
d1584 2
a1585 2
	{
	  /* If the file has no more, mark it empty. */
d1587 11
a1597 11
	  if (feof (streams[bestfile]))
	    {
	      thisline[bestfile] = 0;
	      /* Update the number of files still not empty. */
	      nleft--;
	      break;
	    }
	  readline (thisline[bestfile], streams[bestfile]);
	  if (thisline[bestfile]->buffer[0] || !feof (streams[bestfile]))
	    break;
	}
d1663 1
a1663 1
  printf ("%s; for file `%s'.\n", s, name);
d1716 15
a1761 15

memory_error (callers_name, bytes_wanted)
     char *callers_name;
     int bytes_wanted;
{
  char printable_string[80];

  sprintf (printable_string,
	   "Virtual memory exhausted in %s ()!  Needed %d bytes.",
	   callers_name, bytes_wanted);

  error (printable_string);
  abort ();
}

@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of texinfo-3.9.
@
text
@a1 1
   $Id: texindex.c,v 1.6 1996/10/04 18:21:30 karl Exp $
d3 3
a5 1
   Copyright (C) 1987, 91, 92, 96 Free Software Foundation, Inc.
d20 1
d27 1
a27 1
#define TEXINDEX_VERSION_STRING "GNU Texindex (Texinfo 3.9) 2.1"
d94 1
a94 1
#ifndef errno
d97 1
a97 3
#ifndef strerror
extern char *strerror ();
#endif
d285 1
a285 1
      "keep temporary files around after processing" },
d287 1
a287 1
      "do not keep temporary files around after processing (default)" },
d289 1
a289 1
      "send output to FILE" },
d291 2
a292 3
      "display version information and exit" },
  { "--help", "-h", (int *)NULL, 0, (char *)NULL,
      "display this help and exit" },
a300 1
  FILE *f = result_value ? stderr : stdout;
d302 4
a305 5
  fprintf (f, "Usage: %s [OPTION]... FILE...\n", program_name);
  fprintf (f, "Generate a sorted index for each TeX output FILE.\n");
  /* Avoid trigraph nonsense.  */
  fprintf (f, "Usually FILE... is `foo.??\' for a document `foo.texi'.\n");
  fprintf (f, "\nOptions:\n");
d309 1
a309 4
      if (texindex_options[i].short_name)
	fprintf (f, "%s, ", texindex_options[i].short_name);

      fprintf (f, "%s %s",
d311 2
a312 2
	       texindex_options[i].arg_name
               ? texindex_options[i].arg_name : "");
d314 6
a319 1
      fprintf (f, "\t%s\n", texindex_options[i].doc_string);
a320 2
  puts ("\nEmail bug reports to bug-texinfo@@prep.ai.mit.edu.");

d367 1
a367 5
	      puts (TEXINDEX_VERSION_STRING);
puts ("Copyright (C) 1996 Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.");
d1105 1
a1105 2
      qsort (lineinfo, nextline - linearray, sizeof (struct lineinfo),
             compare_prepared);
@


1.1.1.3
log
@Import of FSF texinfo 3.11
@
text
@d2 1
a2 1
   $Id: texindex.c,v 1.17 1997/07/24 23:34:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 91, 92, 96, 97 Free Software Foundation, Inc.
d20 6
a25 2
#include "system.h"
#include <getopt.h>
d36 20
d92 7
d103 1
a103 1
  char *text;           /* The actual text of the line. */
d105 2
a106 2
    char *text;         /* The start of the key (for textual comparison). */
    long number;        /* The numeric value (for numeric comparison). */
d108 1
a108 1
  long keylen;          /* Length of KEY field. */
d114 10
a123 10
  int startwords;       /* Number of words to skip. */
  int startchars;       /* Number of additional chars to skip. */
  int endwords;         /* Number of words to ignore at end. */
  int endchars;         /* Ditto for characters of last word. */
  char ignore_blanks;   /* Non-zero means ignore spaces and tabs. */
  char fold_case;       /* Non-zero means case doesn't matter. */
  char reverse;         /* Non-zero means compare in reverse order. */
  char numeric;         /* Non-zeros means field is ASCII numeric. */
  char positional;      /* Sort according to file position. */
  char braced;          /* Count balanced-braced groupings as fields. */
a216 9
#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d250 1
a250 1
        pfatal_with_name (infiles[i]);
d258 3
a260 3
        {
          outfile = concat (infiles[i], "s", "");
        }
d263 2
a264 2
        /* Sort a small amount of data. */
        sort_in_core (infiles[i], ptr, outfile);
d266 1
a266 1
        sort_offline (infiles[i], ptr, outfile);
d285 1
a285 1
      N_("keep temporary files around after processing") },
d287 1
a287 1
      N_("do not keep temporary files around after processing (default)") },
d289 1
a289 1
      N_("send output to FILE") },
d291 1
a291 1
      N_("display version information and exit") },
d293 1
a293 1
      N_("display this help and exit") },
d304 2
a305 2
  fprintf (f, _("Usage: %s [OPTION]... FILE...\n"), program_name);
  fprintf (f, _("Generate a sorted index for each TeX output FILE.\n"));
d307 2
a308 2
  fprintf (f, _("Usually FILE... is `foo.??\' for a document `foo.texi'.\n"));
  fprintf (f, _("\nOptions:\n"));
d313 1
a313 1
        fprintf (f, "%s, ", texindex_options[i].short_name);
d316 2
a317 2
               texindex_options[i].long_name,
               texindex_options[i].arg_name
d320 1
a320 1
      fprintf (f, "\t%s\n", _(texindex_options[i].doc_string));
d322 1
a322 1
  puts (_("\nEmail bug reports to bug-texinfo@@prep.ai.mit.edu."));
d336 1
d367 5
a371 5
        {
          if (strcmp (arg, "--version") == 0)
            {
              printf (_("texindex (GNU %s %s) 2.1\n"), PACKAGE, VERSION);
puts (_("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d374 28
a401 28
For more information about these matters, see the files named COPYING."));
              exit (0);
            }
          else if ((strcmp (arg, "--keep") == 0) ||
                   (strcmp (arg, "-k") == 0))
            {
              keep_tempfiles = 1;
            }
          else if ((strcmp (arg, "--help") == 0) ||
                   (strcmp (arg, "-h") == 0))
            {
              usage (0);
            }
          else if ((strcmp (arg, "--output") == 0) ||
                   (strcmp (arg, "-o") == 0))
            {
              if (argv[arg_index] != (char *)NULL)
                {
                  arg_index++;
                  if (op > outfiles)
                    *(op - 1) = argv[arg_index];
                }
              else
                usage (1);
            }
          else
            usage (1);
        }
d403 4
a406 4
        {
          *ip++ = arg;
          *op++ = (char *)NULL;
        }
d462 1
a462 1
        break;
d488 1
a488 1
                               start2, length2, *line2 - text_base);
d490 5
a494 5
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
d497 1
a497 1
  return 0;                     /* Lines match exactly. */
d517 1
a517 1
        tem = 1;
d519 1
a519 1
        tem = -1;
d525 1
a525 1
                         line2->key.text, line2->keylen, 0);
d529 1
a529 1
        return -tem;
d546 1
a546 1
                               start2, length2, text2 - text_base);
d548 5
a552 5
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
d555 1
a555 1
  return 0;                     /* Lines match exactly. */
d581 1
a581 1
                               start2, length2, pos2);
d583 5
a587 5
        {
          if (keyfields[i].reverse)
            return -tem;
          return tem;
        }
d590 1
a590 1
  return 0;                     /* Lines match exactly. */
d613 1
a613 1
                  keyfield->ignore_blanks);
d617 1
a617 1
        end = find_braced_end (start);
d619 5
a623 5
        {
          end = start;
          while (*end && *end != '\n')
            end++;
        }
d629 1
a629 1
        end = start;
d654 1
a654 1
        p++;
d656 1
a656 1
        p++;
d658 1
a658 1
        return p;
d667 1
a667 1
        break;
d691 1
a691 1
        /* Do nothing. */ ;
d693 1
a693 1
        return p - 1;
d695 9
a703 9
        {
          c = *p++;
          if (c == '{')
            bracelevel++;
          if (c == '}')
            bracelevel--;
          if (c == 0 || c == '\n')
            return p - 1;
        }
d719 1
a719 1
        break;
d741 1
a741 1
        bracelevel++;
d743 1
a743 1
        bracelevel--;
d745 1
a745 1
        return p - 1;
d758 1
a758 1
        return atol (start);
d804 1
a804 1
        return 1;
d806 1
a806 1
        return -1;
d812 1
a812 1
        return 1;
d814 1
a814 1
        return -1;
d825 2
a826 2
        {
          int c1, c2;
d828 14
a841 14
          if (p1 == e1)
            c1 = 0;
          else
            c1 = *p1++;
          if (p2 == e2)
            c2 = 0;
          else
            c2 = *p2++;

          if (char_order[c1] != char_order[c2])
            return char_order[c1] - char_order[c2];
          if (!c1)
            break;
        }
d847 2
a848 2
        {
          int c1, c2;
d850 15
a864 15
          if (p1 == e1)
            c1 = 0;
          else
            c1 = *p1++;
          if (p2 == e2)
            c2 = 0;
          else
            c2 = *p2++;

          if (c1 != c2)
            /* Reverse sign here so upper case comes out last.  */
            return c2 - c1;
          if (!c1)
            break;
        }
d906 6
a911 6
        {
          buffer = (char *) xrealloc (buffer, linebuffer->size *= 2);
          p += buffer - linebuffer->buffer;
          end += buffer - linebuffer->buffer;
          linebuffer->buffer = buffer;
        }
d913 4
a916 4
        {
          *p = 0;
          break;
        }
d949 1
a949 1
      error (_("%s: not a texinfo index file"), infile);
d963 1
a963 1
        pfatal_with_name (outname);
d967 1
a967 1
         "too big" or until there are no more lines.  */
d970 18
a987 18
        {
          tempsize += linelength + 1;
          fputs (lb.buffer, ostream);
          putc ('\n', ostream);

          /* Read another line of input data.  */

          linelength = readline (&lb, istream);
          if (!linelength && feof (istream))
            break;

          if (lb.buffer[0] != '\\' && lb.buffer[0] != '@@')
            {
              error (_("%s: not a texinfo index file"), infile);
              failure = 1;
              goto fail;
            }
        }
d990 1
a990 1
        break;
d1009 1
a1009 1
        unlink (tempfiles[i]);
d1044 1
a1044 1
    fatal (_("failure reopening %s"), infile);
d1049 1
a1049 1
        break;
d1059 1
a1059 1
      error (_("%s: not a texinfo index file"), infile);
d1087 1
a1087 1
      error (_("%s: not a texinfo index file"), infile);
d1105 6
a1110 6
        {
          lp->text = *p;
          lp->key.text = find_field (keyfields, *p, &lp->keylen);
          if (keyfields->numeric)
            lp->key.number = find_value (lp->key.text, lp->keylen);
        }
d1116 1
a1116 1
        *p = lp->text;
d1129 1
a1129 1
        pfatal_with_name (outfile);
d1163 1
a1163 1
        return 0;
d1167 1
a1167 1
        p++;
d1169 1
a1169 1
        p++;
d1173 5
a1177 5
        {
          char **old = linearray;
          linearray = (char **) xrealloc (linearray, sizeof (char *) * (nlines *= 4));
          line += linearray - old;
        }
d1269 1
a1269 1
         including that inner pair of braces.  */
d1280 1
a1280 1
        initial1[0] -= 040;
d1301 4
a1304 4
        {
          fputs ("}\n", ostream);
          pending = 0;
        }
d1307 1
a1307 1
         the initial. */
d1309 16
a1324 16
          strncmp (initial, lastinitial, initiallength))
        {
          fprintf (ostream, "\\initial {");
          fwrite (initial, 1, initiallength, ostream);
          fputs ("}\n", ostream);
          if (initial == initial1)
            {
              lastinitial = lastinitial1;
              *lastinitial1 = *initial1;
            }
          else
            {
              lastinitial = initial;
            }
          lastinitiallength = initiallength;
        }
d1328 1
a1328 1
        fputs ("\\entry {", ostream);
d1330 1
a1330 1
        fputs ("\\primary {", ostream);
d1333 4
a1336 4
        {
          fputs ("}{", ostream);
          pending = 1;
        }
d1338 1
a1338 1
        fputs ("}\n", ostream);
d1342 5
a1346 5
        {
          lastprimarylength = primarylength + 100;
          lastprimary = (char *) xrealloc (lastprimary,
                                           1 + lastprimarylength);
        }
d1357 1
a1357 1
    error (_("entry %s follows an entry with a secondary name"), line);
d1363 4
a1366 4
        {
          fputs ("}\n", ostream);
          pending = 0;
        }
d1376 5
a1380 5
        {
          lastsecondarylength = secondarylength + 100;
          lastsecondary = (char *) xrealloc (lastsecondary,
                                             1 + lastsecondarylength);
        }
d1387 1
a1387 1
    fputs (", ", ostream);      /* Punctuate first, if this is not the first. */
d1425 10
a1434 10
          || compare_general (*(next_line - 1), *next_line, 0L, 0L, num_keyfields - 1))
        {
          char *p = *next_line;
          char c;

          while ((c = *p++) && c != '\n')
            /* Do nothing. */ ;
          *(p - 1) = 0;
          indexify (*next_line, ostream);
        }
d1473 1
a1473 1
        nf = nfiles - i * MAX_DIRECT_MERGE;
d1528 1
a1528 1
        fclose (ostream);
d1570 1
a1570 1
        pfatal_with_name (infiles[i]);
d1588 10
a1597 10
        {
          if (thisline[i] &&
              (!best ||
               0 < compare_general (best->buffer, thisline[i]->buffer,
                                 (long) bestfile, (long) i, num_keyfields)))
            {
              best = thisline[i];
              bestfile = i;
            }
        }
d1600 1
a1600 1
         don't want duplicates. */
d1603 3
a1605 3
            !compare_general (prev_out->buffer,
                              best->buffer, 0L, 1L, num_keyfields - 1)))
        indexify (best->buffer, ostream);
d1609 1
a1609 1
         line from that file.  */
d1616 2
a1617 2
        {
          /* If the file has no more, mark it empty. */
d1619 11
a1629 11
          if (feof (streams[bestfile]))
            {
              thisline[bestfile] = 0;
              /* Update the number of files still not empty. */
              nleft--;
              break;
            }
          readline (thisline[bestfile], streams[bestfile]);
          if (thisline[bestfile]->buffer[0] || !feof (streams[bestfile]))
            break;
        }
d1695 1
a1695 1
  printf (_("%s; for file `%s'.\n"), s, name);
a1747 15
void
memory_error (callers_name, bytes_wanted)
     char *callers_name;
     int bytes_wanted;
{
  char printable_string[80];

  sprintf (printable_string,
           _("Virtual memory exhausted in %s ()!  Needed %d bytes."),
           callers_name, bytes_wanted);

  error (printable_string);
  abort ();
}

d1779 15
@


1.1.1.4
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: texindex.c,v 1.22 1998/02/22 23:00:09 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 91, 92, 96, 97, 98 Free Software Foundation, Inc.
d46 12
d170 1
a170 1
int
a248 2
  
  return 0; /* Avoid bogus warnings.  */
d300 1
a300 1
  puts (_("\nEmail bug reports to bug-texinfo@@gnu.org."));
d347 2
a348 2
              printf ("texindex (GNU %s) %s\n", PACKAGE, VERSION);
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d351 1
a351 2
For more information about these matters, see the files named COPYING.\n"),
		  "1998");
@


1.1.1.5
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* Process TeX index dribble output into an actual index.
   $Id: texindex.c,v 1.34 1999/08/06 17:03:14 karl Exp $
d4 1
a4 1
   Copyright (C) 1987, 91, 92, 96, 97, 98, 99 Free Software Foundation, Inc.
a22 2
static char *program_name = "texindex";

d37 1
d40 10
d127 3
d131 1
d152 1
d154 1
d168 6
d211 1
a211 1
      off_t ptr;
a212 1
      struct stat instat;
a216 11

      if (stat (infiles[i], &instat))
        pfatal_with_name (infiles[i]);
      if (S_ISDIR (instat.st_mode))
        {
#ifdef EISDIR
          errno = EISDIR;
#endif
          pfatal_with_name (infiles[i]);
        }

d218 1
a218 1
      ptr = (off_t) lseek (desc, (off_t) 0, SEEK_CUR);
d236 2
a237 2
  xexit (0);

a251 2
  { "--help", "-h", (int *)NULL, 0, (char *)NULL,
      N_("display this help and exit") },
d260 2
d275 1
a275 3
  fprintf (f,
_("Usually FILE... is specified as `foo.%c%c\' for a document `foo.texi'.\n"),
           '?', '?'); /* avoid trigraph in cat-id-tbl.c */
a279 2
      putc (' ', f);

d290 1
a290 4
  fputs (_("\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
"), f);
d292 1
a292 1
  xexit (result_value);
d310 1
d312 2
a313 3
    tempdir = getenv ("TEMP");
  if (tempdir == NULL)
    tempdir = getenv ("TMP");
d315 1
a315 1
    tempdir = DEFAULT_TMPDIR;
d318 1
d338 1
a338 2
              puts ("");
              printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d342 2
a343 2
                  "1999");
              xexit (0);
d386 1
a386 1
static char *
d391 1
a391 1
  sprintf (tempsuffix, ".%d", count);
d407 30
d897 1
a897 1
     off_t total;
d996 1
a996 1
     off_t total;
d1254 1
a1254 1
    fatal (_("No page number in %s"), line);
d1630 1
a1630 1
  xexit (1);
d1664 1
a1664 1
  xexit (1);
d1685 15
d1715 47
@


1.1.1.6
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: texindex.c,v 1.41 2002/03/11 19:55:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1987, 91, 92, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc. 
d288 1
a288 2
Texinfo home page: http://www.gnu.org/software/texinfo/"), f);
  fputs ("\n", f);
d340 1
a340 1
                  "2002");
@


1.1.1.7
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* texindex -- sort TeX index dribble output into an actual index.
   $Id: texindex.c,v 1.11 2004/04/11 17:56:47 karl Exp $
d4 2
a5 2
   Copyright (C) 1987, 1991, 1992, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
d40 1
a40 1
char *mktemp (char *);
a47 2
struct linebuffer;

d100 3
a113 7
/* Initially 0; changed to 1 if we want initials in this index.  */
int need_initials;

/* Remembers the first initial letter seen in this index, so we can
   determine whether we need initials in the sorted form.  */
char first_initial;

d120 18
a137 20
void decode_command (int argc, char **argv);
void sort_in_core (char *infile, int total, char *outfile);
void sort_offline (char *infile, off_t total, char *outfile);
char **parsefile (char *filename, char **nextline, char *data, long int size);
char *find_field (struct keyfield *keyfield, char *str, long int *lengthptr);
char *find_pos (char *str, int words, int chars, int ignore_blanks);
long find_value (char *start, long int length);
char *find_braced_pos (char *str, int words, int chars, int ignore_blanks);
char *find_braced_end (char *str);
void writelines (char **linearray, int nlines, FILE *ostream);
int compare_field (struct keyfield *keyfield, char *start1,
                   long int length1, long int pos1, char *start2,
                   long int length2, long int pos2);
int compare_full (const void *, const void *);
long readline (struct linebuffer *linebuffer, FILE *stream);
int merge_files (char **infiles, int nfiles, char *outfile);
int merge_direct (char **infiles, int nfiles, char *outfile);
void pfatal_with_name (const char *name);
void fatal (const char *format, const char *arg);
void error (const char *format, const char *arg);
d139 2
a140 2
char *concat (char *s1, char *s2);
void flush_tempfiles (int to_count);
d145 3
a147 1
main (int argc, char **argv)
a162 3
  /* In case we write to a redirected stdout that fails.  */
  /* not ready atexit (close_stdout); */

d184 2
d216 3
a218 4
        outfile = concat (infiles[i], "s");

      need_initials = 0;
      first_initial = '\0';
d222 1
a222 1
        sort_in_core (infiles[i], (int)ptr, outfile);
d229 1
d258 2
a259 1
usage (int result_value)
d299 3
a301 1
decode_command (int argc, char **argv)
d317 1
a317 1
    tempdir = concat (tempdir, "/");
d338 2
a339 2
              puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
              printf (_("There is NO warranty.  You may redistribute this software\n\
d341 2
a342 1
For more information about these matters, see the files named COPYING.\n"));
d384 1
a384 1
/* Return a name for temporary file COUNT. */
d387 2
a388 1
maketempname (int count)
a389 1
  static char *tempbase = NULL;
a390 11

  if (!tempbase)
    {
      int fd;
      tempbase = concat (tempdir, "txidxXXXXXX");

      fd = mkstemp (tempbase);
      if (fd == -1)
        pfatal_with_name (tempbase);
    }

d392 1
a392 1
  return concat (tempbase, tempsuffix);
a394 1

d398 2
a399 1
flush_tempfiles (int to_count)
d411 2
a412 1
compare_full (const void *p1, const void *p2)
a413 2
  char **line1 = (char **) p1;
  char **line2 = (char **) p2;
d425 1
a425 2
      int tem = compare_field (&keyfields[i], start1, length1,
                               *line1 - text_base,
d442 1
d444 2
a445 1
compare_prepared (const void *p1, const void *p2)
a446 2
  struct lineinfo *line1 = (struct lineinfo *) p1;
  struct lineinfo *line2 = (struct lineinfo *) p2;
d483 1
a483 2
      int tem = compare_field (&keyfields[i], start1, length1,
                               text1 - text_base,
d502 4
a505 1
compare_general (char *str1, char *str2, long int pos1, long int pos2, int use_keyfields)
d536 4
a539 1
find_field (struct keyfield *keyfield, char *str, long int *lengthptr)
d579 4
a582 1
find_pos (char *str, int words, int chars, int ignore_blanks)
d615 4
a618 1
find_braced_pos (char *str, int words, int chars, int ignore_blanks)
d667 2
a668 1
find_braced_end (char *str)
d689 3
a691 1
find_value (char *start, long int length)
d709 1
a709 1
init_char_order (void)
d730 8
a737 2
compare_field (struct keyfield *keyfield, char *start1, long int length1,
               long int pos1, char *start2, long int length2, long int pos2)
d821 2
a822 1
initbuffer (struct linebuffer *linebuffer)
d832 3
a834 1
readline (struct linebuffer *linebuffer, FILE *stream)
d864 5
a868 1
sort_offline (char *infile, off_t total, char *outfile)
d945 1
a945 1
      sort_in_core (tempfiles[i], MAX_IN_CORE_SORT, newtemp);
d964 4
a967 1
sort_in_core (char *infile, int total, char *outfile)
d1035 1
a1035 1
  lineinfo = malloc ((nextline - linearray) * sizeof (struct lineinfo));
d1085 5
a1089 1
parsefile (char *filename, char **nextline, char *data, long int size)
a1103 17

      /* Find the first letter of the first field of this line.  If it
         is different from the first letter of the first field of the
         first line, we need initial headers in the output index.  */
      while (*p && *p != '{')
        p++;
      if (p == end)
        return 0;
      p++;
      if (first_initial)
        {
          if (first_initial != toupper (*p))
            need_initials = 1;
        }
      else
        first_initial = toupper (*p);

d1113 1
a1113 1
          linearray = xrealloc (linearray, sizeof (char *) * (nlines *= 4));
d1169 1
a1169 1
init_index (void)
d1188 3
a1190 1
indexify (char *line, FILE *ostream)
d1213 1
a1213 1
      initial1[0] = toupper (*p);
d1216 3
d1246 2
a1247 3
      if (need_initials &&
          (initiallength != lastinitiallength ||
           strncmp (initial, lastinitial, initiallength)))
d1292 1
a1292 2
  /* Should not have an entry with no subtopic following one with a
     subtopic. */
d1325 1
a1325 1
    fputs (", ", ostream);  /* Punctuate first, if this is not the first. */
d1332 2
a1333 1
finish_index (FILE *ostream)
d1345 4
a1348 1
writelines (char **linearray, int nlines, FILE *ostream)
d1359 1
a1359 2
      /* If -u was specified, output the line only if distinct from
         previous one.  */
d1363 1
a1363 2
          || compare_general (*(next_line - 1), *next_line, 0L, 0L,
                              num_keyfields - 1))
d1388 4
a1391 1
merge_files (char **infiles, int nfiles, char *outfile)
d1439 4
a1442 1
merge_direct (char **infiles, int nfiles, char *outfile)
d1470 7
a1476 7
  /* For each file, make two line buffers.  Also, for each file, there
     is an element of `thisline' which points at any time to one of the
     file's two buffers, and an element of `prevline' which points to
     the other buffer.  `thisline' is supposed to point to the next
     available line from the file, while `prevline' holds the last file
     line used, which is remembered so that we can verify that the file
     is properly sorted. */
d1482 2
a1483 2
  /* thisline[i] points to the linebuffer holding the next available
     line in file i, or is zero if there are no lines left in that file.  */
d1596 2
a1597 1
fatal (const char *format, const char *arg)
d1605 2
a1606 1
error (const char *format, const char *arg)
d1615 2
a1616 1
perror_with_name (const char *name)
d1618 5
a1622 2
  fprintf (stderr, "%s: ", program_name);
  perror (name);
d1626 2
a1627 1
pfatal_with_name (const char *name)
d1629 5
a1633 1
  perror_with_name (name);
d1637 2
a1638 2

/* Return a newly-allocated string concatenating S1 and S2.  */
d1641 2
a1642 1
concat (char *s1, char *s2)
d1644 2
a1645 2
  int len1 = strlen (s1), len2 = strlen (s2);
  char *result = (char *) xmalloc (len1 + len2 + 1);
d1649 2
a1650 1
  *(result + len1 + len2) = 0;
d1654 16
@


