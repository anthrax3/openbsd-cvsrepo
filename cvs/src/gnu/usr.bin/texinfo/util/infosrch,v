head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.44
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.42
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.38
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.40
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.32
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.36
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.34
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.30
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.28
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.26
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.24
	OPENBSD_5_0:1.1.1.1.0.22
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.20
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.18
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.14
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.16
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.12
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.10
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.8
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.6
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.4
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.2
	OPENBSD_4_0_BASE:1.1.1.1
	TEXINFO_4_8:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2006.07.17.16.03.50;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2006.07.17.16.03.50;	author espie;	state Exp;
branches;
next	;


desc
@@



1.1
log
@Initial revision
@
text
@#!/usr/local/bin/perl -w
# $Id: infosrch,v 1.2 2004/04/11 17:56:47 karl Exp $
# infosrch does a regex search on an info manual.
# By Harry Putnam <reader@@newsguy.com>.

($myscript = $0) =~ s:^.*/::; 
$six = '';

if($ARGV[0] eq "help"){
   &usage;
   exit;
}
if($ARGV[0] eq "-e"){
   shift;
   $six = "true";
}
if(!$ARGV[1]){
   &usage;
   exit;
}

$target = shift;
$regex  = shift;

$shell_proc  =  "info --output - --subnodes 2>/dev/null $target";

open(SHELL_PROC," $shell_proc|");
while(<SHELL_PROC>){
  chomp;
  push @@lines,$_;
} 
close(SHELL_PROC);
$cnt = 0;
for(@@lines){
   if(/$regex/ && !$six){
      print "$target\n   $lines[($cnt-1)]\n<$cnt> $lines[$cnt]\n   $lines[($cnt+1)]\n";
      print "-- \n";
   }elsif(/$regex/ && $six){
        print "$target\n";
        if($lines[($cnt-6)]){
           print "    $lines[($cnt-6)]\n";
        }
        if($lines[($cnt-5)]){
           print "    $lines[($cnt-5)]\n";
        }
        if($lines[($cnt-4)]){
           print "    $lines[($cnt-4)]\n";
        }
        if($lines[($cnt-3)]){
           print "    $lines[($cnt-3)]\n";
        }
        if($lines[($cnt-2)]){
           print "    $lines[($cnt-2)]\n";
        }
        if($lines[($cnt-1)]){
           print "    $lines[($cnt-1)]\n";
        }
        if($lines[$cnt]){
           print "$cnt $lines[$cnt]\n";
        }
        if($lines[($cnt+1)]){
           print "    $lines[($cnt+1)]\n";
        }
        if($lines[($cnt+2)]){
           print "    $lines[($cnt+2)]\n";
        }
        if($lines[($cnt+3)]){
           print "    $lines[($cnt+3)]\n";
        }
        if($lines[($cnt+4)]){
           print "    $lines[($cnt+4)]\n";
        }
        if($lines[($cnt+5)]){
           print "    $lines[($cnt+5)]\n";
        }
        if($lines[($cnt+6)]){
           print "    $lines[($cnt+6)]\n";
        }
        print "-- \n";
     }
     $cnt++;
}        

sub usage {
  print <<EOM;

Purpose: Extract full text from info node and search it by regex
Usage: $myscript [-e] TARGET REGEX

Where TARGET is an info node such as `emacs', `bash' etc, and
REGEX is what you want to find in it.

The -e flag is not required but if used then 6 lines preceding and six
lines following any hits will be printed.  The default (with no -e flag)
is to print one line before and after.

The output has the line number prepended to the line containing the
actual regex.

Info command used:
  info --output - --subnodes 2>/dev/null TARGET

EOM
}
@


1.1.1.1
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@@
