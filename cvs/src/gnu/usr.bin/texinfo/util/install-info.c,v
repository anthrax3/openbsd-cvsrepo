head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.40
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.32
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.36
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.34
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.30
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.28
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.26
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.24
	OPENBSD_5_0:1.8.0.22
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.20
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.18
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.14
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	TEXINFO_4_8:1.1.1.6
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	TEXINFO_4_2:1.1.1.5
	OPENBSD_3_1:1.6.0.10
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.8
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9:1.6.0.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	TEXINFO_4_0:1.1.1.4
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	TEXINFO_3_12:1.1.1.3
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	TEXINFO_3_9:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2015.11.14.23.06.06;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	3WsuKev3hGnuRYC4;

1.8
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.10.13.51.04;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.09.02.18.42;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	99.01.11.16.38.15;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	97.08.01.22.37.47;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	97.06.22.14.46.53;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	97.01.04.20.31.05;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	96.12.15.21.39.32;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.12.15.21.39.32;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.01.04;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.01.11.16.32.44;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.09.01.26.19;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.06.10.13.21.25;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.07.17.16.03.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.9
log
@info - pledge stdio rpath wpath cpath getpw tty proc exec
infokey - stdio rpath wpath cpath tty
makeinfo - stdio rpath wpath cpath getpw
install-info - stdio rpath wpath cpath proc exec
texindex - stdio rpath wpath cpath tmppath
ok schwarze
@
text
@/* install-info -- create Info directory entry(ies) for an Info file.
   $Id: install-info.c,v 1.8 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/

#include "system.h"
#include <getopt.h>

static char *progname = "install-info";

struct spec_entry;
struct spec_section;

struct line_data *findlines (char *data, int size, int *nlinesp);
void insert_entry_here (struct spec_entry *entry, int line_number,
                        struct line_data *dir_lines, int n_entries); 
int compare_section_names (const void *s1, const void *s2);
int compare_entries_text (const void *e1, const void *e2); 

/* Data structures.  */


/* Record info about a single line from a file as read into core.  */
struct line_data
{
  /* The start of the line.  */
  char *start;
  /* The number of characters in the line,
     excluding the terminating newline.  */
  int size;
  /* Vector containing pointers to the entries to add before this line.
     The vector is null-terminated.  */
  struct spec_entry **add_entries_before;
  /* 1 means output any needed new sections before this line.  */
  int add_sections_before;
  /* 1 means don't output this line.  */
  int delete;
};


/* This is used for a list of the specified menu section names
   in which entries should be added.  */
struct spec_section
{
  struct spec_section *next;
  char *name;
  /* 1 means we have not yet found an existing section with this name
     in the dir file--so we will need to add a new section.  */
  int missing;
};


/* This is used for a list of the entries specified to be added.  */
struct spec_entry
{
  struct spec_entry *next;
  char *text;
  int text_len;
  /* A pointer to the list of sections to which this entry should be
     added.  */
  struct spec_section *entry_sections;
  /* A pointer to a section that is beyond the end of the chain whose
     head is pointed to by entry_sections.  */
  struct spec_section *entry_sections_tail;
};


/* This is used for a list of nodes found by parsing the dir file.  */
struct node
{
  struct node *next;
  /* The node name.  */
  char *name;
  /* The line number of the line where the node starts.
     This is the line that contains control-underscore.  */
  int start_line;
  /* The line number of the line where the node ends,
     which is the end of the file or where the next line starts.  */
  int end_line;
  /* Start of first line in this node's menu
     (the line after the * Menu: line).  */
  char *menu_start;
  /* The start of the chain of sections in this node's menu.  */
  struct menu_section *sections;
  /* The last menu section in the chain.  */
  struct menu_section *last_section;
};


/* This is used for a list of sections found in a node's menu.
   Each  struct node  has such a list in the  sections  field.  */
struct menu_section
{
  struct menu_section *next;
  char *name;
  /* Line number of start of section.  */
  int start_line;
  /* Line number of end of section.  */
  int end_line;
};

/* This table defines all the long-named options, says whether they
   use an argument, and maps them into equivalent single-letter options.  */

struct option longopts[] =
{
  { "delete",    no_argument, NULL, 'r' },
  { "dir-file",  required_argument, NULL, 'd' },
  { "entry",     required_argument, NULL, 'e' },
  { "help",      no_argument, NULL, 'h' },
  { "infodir",   required_argument, NULL, 'D' },
  { "info-dir",  required_argument, NULL, 'D' },
  { "info-file", required_argument, NULL, 'i' },
  { "item",      required_argument, NULL, 'e' },
  { "quiet",     no_argument, NULL, 'q' },
  { "remove",    no_argument, NULL, 'r' },
  { "section",   required_argument, NULL, 's' },
  { "version",   no_argument, NULL, 'V' },
  { 0 }
};

/* Error message functions.  */

/* Print error message.  S1 is printf control string, S2 and S3 args for it. */

/* VARARGS1 */
void
error (const char *s1, const char *s2, const char *s3)
{
  fprintf (stderr, "%s: ", progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* VARARGS1 */
void
warning (const char *s1, const char *s2, const char *s3)
{
  fprintf (stderr, _("%s: warning: "), progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* Print error message and exit.  */

void
fatal (const char *s1, const char *s2, const char *s3)
{
  error (s1, s2, s3);
  xexit (1);
}

/* Return a newly-allocated string
   whose contents concatenate those of S1, S2, S3.  */
char *
concat (const char *s1, const char *s2, const char *s3)
{
  int len1 = strlen (s1), len2 = strlen (s2), len3 = strlen (s3);
  char *result = (char *) xmalloc (len1 + len2 + len3 + 1);

  strcpy (result, s1);
  strcpy (result + len1, s2);
  strcpy (result + len1 + len2, s3);
  *(result + len1 + len2 + len3) = 0;

  return result;
}

/* Return a string containing SIZE characters
   copied from starting at STRING.  */

char *
copy_string (const char *string, int size)
{
  int i;
  char *copy = (char *) xmalloc (size + 1);
  for (i = 0; i < size; i++)
    copy[i] = string[i];
  copy[size] = 0;
  return copy;
}

/* Print fatal error message based on errno, with file name NAME.  */

void
pfatal_with_name (const char *name)
{
  char *s = concat ("", strerror (errno), _(" for %s"));
  fatal (s, name, 0);
}

/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item name
   in LINE1 is less, 0 otherwise.  */

static int
menu_line_lessp (char *line1, int len1, char *line2, int len2)
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If one item name is a prefix of the other,
         the former one is less.  */
      if (line1[i] == ':' && line2[i] != ':')
        return 1;
      if (line2[i] == ':' && line1[i] != ':')
        return 0;
      /* If they both continue and differ, one is less.  */
      if (line1[i] < line2[i])
        return 1;
      if (line1[i] > line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 0;
}

/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item names are equal,
   0 otherwise.  */

static int
menu_line_equal (char *line1, int len1, char *line2, int len2)
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If both item names end here, they are equal.  */
      if (line1[i] == ':' && line2[i] == ':')
        return 1;
      /* If they both continue and differ, one is less.  */
      if (line1[i] != line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 1;
}


/* Given the full text of a menu entry, null terminated,
   return just the menu item name (copied).  */

char *
extract_menu_item_name (char *item_text)
{
  char *p;

  if (*item_text == '*')
    item_text++;
  while (*item_text == ' ')
    item_text++;

  p = item_text;
  while (*p && *p != ':') p++;
  return copy_string (item_text, p - item_text);
}

/* Given the full text of a menu entry, terminated by null or newline,
   return just the menu item file (copied).  */

char *
extract_menu_file_name (char *item_text)
{
  char *p = item_text;

  /* If we have text that looks like * ITEM: (FILE)NODE...,
     extract just FILE.  Otherwise return "(none)".  */

  if (*p == '*')
    p++;
  while (*p == ' ')
    p++;

  /* Skip to and past the colon.  */
  while (*p && *p != '\n' && *p != ':') p++;
  if (*p == ':') p++;

  /* Skip past the open-paren.  */
  while (1)
    {
      if (*p == '(')
        break;
      else if (*p == ' ' || *p == '\t')
        p++;
      else
        return "(none)";
    }
  p++;

  item_text = p;

  /* File name ends just before the close-paren.  */
  while (*p && *p != '\n' && *p != ')') p++;
  if (*p != ')')
    return "(none)";

  return copy_string (item_text, p - item_text);
}



/* Return FNAME with any [.info][.gz] suffix removed.  */

static char *
strip_info_suffix (char *fname)
{
  char *ret = xstrdup (fname);
  unsigned len = strlen (ret);

  if (len > 3 && FILENAME_CMP (ret + len - 3, ".gz") == 0)
    {
      len -= 3;
      ret[len] = 0;
    }
  else if (len > 4 && FILENAME_CMP (ret + len - 4, ".bz2") == 0)
    {
      len -= 4;
      ret[len] = 0;
    }

  if (len > 5 && FILENAME_CMP (ret + len - 5, ".info") == 0)
    {
      len -= 5;
      ret[len] = 0;
    }
  else if (len > 4 && FILENAME_CMP (ret + len - 4, ".inf") == 0)
    {
      len -= 4;
      ret[len] = 0;
    }
#ifdef __MSDOS__
  else if (len > 4 && (FILENAME_CMP (ret + len - 4, ".inz") == 0
                       || FILENAME_CMP (ret + len - 4, ".igz") == 0))
    {
      len -= 4;
      ret[len] = 0;
    }
#endif /* __MSDOS__ */

  return ret;
}


/* Return true if ITEM matches NAME and is followed by TERM_CHAR.  ITEM
   can also be followed by `.gz', `.info.gz', or `.info' (and then
   TERM_CHAR) and still match.  */

static int
menu_item_equal (const char *item, char term_char, const char *name)
{
  int ret;
  const char *item_basename = item;
  unsigned name_len = strlen (name);

  /* We must compare the basename in ITEM, since we are passed the
     basename of the original info file.  Otherwise, a new entry like
     "lilypond/lilypond" won't match "lilypond".
     
     Actually, it seems to me that we should really compare the whole
     name, and not just the basename.  Couldn't there be dir1/foo.info
     and dir2/foo.info?  Also, it seems like we should be using the
     filename from the new dir entries, not the filename on the command
     line.  Not worrying about those things right now, though.  --karl,
     26mar04.  */
  while (*item_basename && !IS_SLASH (*item_basename)
	 && *item_basename != term_char)
    item_basename++;
  if (! *item_basename || *item_basename == term_char)
    item_basename = item;  /* no /, use original */
  else
    item_basename++;       /* have /, move past it */
    
  /* First, ITEM must actually match NAME (usually it won't).  */
  ret = strncasecmp (item_basename, name, name_len) == 0;
  if (ret)
    {
      /* Then, `foobar' doesn't match `foo', so be sure we've got all of
         ITEM.  The various suffixes should never actually appear in the
         dir file, but sometimes people put them in.  */
      static char *suffixes[]
        = { "", ".info.gz", ".info", ".inf", ".gz",
#ifdef __MSDOS__
            ".inz", ".igz",
#endif
            NULL };
      unsigned i;
      ret = 0;
      for (i = 0; !ret && suffixes[i]; i++)
        {
          char *suffix = suffixes[i];
          unsigned suffix_len = strlen (suffix);
          ret = strncasecmp (item_basename + name_len, suffix, suffix_len) == 0
                && item_basename[name_len + suffix_len] == term_char;
        }
    }

  return ret;
}



void
suggest_asking_for_help (void)
{
  fprintf (stderr, _("\tTry `%s --help' for a complete list of options.\n"),
           progname);
  xexit (1);
}

void
print_help (void)
{
  printf (_("Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n\
\n\
Install or delete dir entries from INFO-FILE in the Info directory file\n\
DIR-FILE.\n\
\n\
Options:\n\
 --delete          delete existing entries for INFO-FILE from DIR-FILE;\n\
                     don't insert any new entries.\n\
 --dir-file=NAME   specify file name of Info directory file.\n\
                     This is equivalent to using the DIR-FILE argument.\n\
 --entry=TEXT      insert TEXT as an Info directory entry.\n\
                     TEXT should have the form of an Info menu item line\n\
                     plus zero or more extra lines starting with whitespace.\n\
                     If you specify more than one entry, they are all added.\n\
                     If you don't specify any entries, they are determined\n\
                     from information in the Info file itself.\n\
 --help            display this help and exit.\n\
 --info-file=FILE  specify Info file to install in the directory.\n\
                     This is equivalent to using the INFO-FILE argument.\n\
 --info-dir=DIR    same as --dir-file=DIR/dir.\n\
 --item=TEXT       same as --entry TEXT.\n\
                     An Info directory entry is actually a menu item.\n\
 --quiet           suppress warnings.\n\
 --remove          same as --delete.\n\
 --section=SEC     put this file's entries in section SEC of the directory.\n\
                     If you specify more than one section, all the entries\n\
                     are added in each of the sections.\n\
                     If you don't specify any sections, they are determined\n\
                     from information in the Info file itself.\n\
 --version         display version information and exit.\n\
"), progname);

  puts (_("\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
Texinfo home page: http://www.gnu.org/software/texinfo/"));
}


/* If DIRFILE does not exist, create a minimal one (or abort).  If it
   already exists, do nothing.  */

void
ensure_dirfile_exists (char *dirfile)
{
  int desc = open (dirfile, O_RDONLY);
  if (desc < 0 && errno == ENOENT)
    {
      FILE *f;
      char *readerr = strerror (errno);
      close (desc);
      f = fopen (dirfile, "w");
      if (f)
        {
          fprintf (f, _("This is the file .../info/dir, which contains the\n\
topmost node of the Info hierarchy, called (dir)Top.\n\
The first time you invoke Info you start off looking at this node.\n\
\x1f\n\
%s\tThis is the top of the INFO tree\n\
\n\
  This (the Directory node) gives a menu of major topics.\n\
  Typing \"q\" exits, \"?\" lists all Info commands, \"d\" returns here,\n\
  \"h\" gives a primer for first-timers,\n\
  \"mEmacs<Return>\" visits the Emacs manual, etc.\n\
\n\
  In Emacs, you can click mouse button 2 on a menu item or cross reference\n\
  to select it.\n\
\n\
%s\n\
"), "File: dir,\tNode: Top",  /* These keywords must not be translated.  */
    "* Menu:"
);
          if (fclose (f) < 0)
            pfatal_with_name (dirfile);
        }
      else
        {
          /* Didn't exist, but couldn't open for writing.  */
          fprintf (stderr,
                   _("%s: could not read (%s) and could not create (%s)\n"),
                   dirfile, readerr, strerror (errno));
          xexit (1);
        }
    }
  else
    close (desc); /* It already existed, so fine.  */
}

/* Open FILENAME and return the resulting stream pointer.  If it doesn't
   exist, try FILENAME.gz.  If that doesn't exist either, call
   CREATE_CALLBACK (with FILENAME as arg) to create it, if that is
   non-NULL.  If still no luck, fatal error.

   If we do open it, return the actual name of the file opened in
   OPENED_FILENAME and the compress program to use to (de)compress it in
   COMPRESSION_PROGRAM.  The compression program is determined by the
   magic number, not the filename.  */

FILE *
open_possibly_compressed_file (char *filename,
    void (*create_callback) (char *),
    char **opened_filename, char **compression_program, int *is_pipe) 
{
  char *local_opened_filename, *local_compression_program;
  int nread;
  char data[4];
  FILE *f;

  /* We let them pass NULL if they don't want this info, but it's easier
     to always determine it.  */
  if (!opened_filename)
    opened_filename = &local_opened_filename;

  *opened_filename = filename;
  f = fopen (*opened_filename, FOPEN_RBIN);
  if (!f)
    {
      *opened_filename = concat (filename, ".gz", "");
      f = fopen (*opened_filename, FOPEN_RBIN);
  if (!f)
    {
      free (*opened_filename);
      *opened_filename = concat (filename, ".bz2", "");
      f = fopen (*opened_filename, FOPEN_RBIN);
    }

#ifdef __MSDOS__
      if (!f)
        {
          free (*opened_filename);
          *opened_filename = concat (filename, ".igz", "");
          f = fopen (*opened_filename, FOPEN_RBIN);
        }
      if (!f)
        {
          free (*opened_filename);
          *opened_filename = concat (filename, ".inz", "");
          f = fopen (*opened_filename, FOPEN_RBIN);
        }
#endif
      if (!f)
        {
          if (create_callback)
            { /* That didn't work either.  Create the file if we can.  */
              (*create_callback) (filename);

              /* And try opening it again.  */
              free (*opened_filename);
              *opened_filename = filename;
              f = fopen (*opened_filename, FOPEN_RBIN);
              if (!f)
                pfatal_with_name (filename);
            }
          else
            pfatal_with_name (filename);
        }
    }

  /* Read first few bytes of file rather than relying on the filename.
     If the file is shorter than this it can't be usable anyway.  */
  nread = fread (data, sizeof (data), 1, f);
  if (nread != 1)
    {
      /* Empty files don't set errno, so we get something like
         "install-info: No error for foo", which is confusing.  */
      if (nread == 0)
        fatal (_("%s: empty file"), *opened_filename, 0);
      pfatal_with_name (*opened_filename);
    }

  if (!compression_program)
    compression_program = &local_compression_program;

  if (data[0] == '\x1f' && data[1] == '\x8b')
#if STRIP_DOT_EXE
    /* An explicit .exe yields a better diagnostics from popen below
       if they don't have gzip installed.  */
    *compression_program = "gzip.exe";
#else
    *compression_program = "gzip";
#endif
  else if(data[0] == 'B' && data[1] == 'Z' && data[2] == 'h')
#ifndef STRIP_DOT_EXE
    *compression_program = "bzip2.exe";
#else
    *compression_program = "bzip2";
#endif
  else if(data[0] == 'B' && data[1] == 'Z' && data[2] == '0')
#ifndef STRIP_DOT_EXE
    *compression_program = "bzip.exe";
#else
    *compression_program = "bzip";
#endif
  else
    *compression_program = NULL;

  if (*compression_program)
    { /* It's compressed, so fclose the file and then open a pipe.  */
      char *command = concat (*compression_program," -cd <", *opened_filename);
      if (fclose (f) < 0)
        pfatal_with_name (*opened_filename);
      f = popen (command, "r");
      if (f)
        *is_pipe = 1;
      else
        pfatal_with_name (command);
    }
  else
    { /* It's a plain file, seek back over the magic bytes.  */
      if (fseek (f, 0, 0) < 0)
        pfatal_with_name (*opened_filename);
#if O_BINARY
      /* Since this is a text file, and we opened it in binary mode,
         switch back to text mode.  */
      f = freopen (*opened_filename, "r", f);
#endif
      *is_pipe = 0;
    }

  return f;
}

/* Read all of file FILENAME into memory and return the address of the
   data.  Store the size of the data into SIZEP.  If need be, uncompress
   (i.e., try FILENAME.gz et al. if FILENAME does not exist) and store
   the actual file name that was opened into OPENED_FILENAME (if it is
   non-NULL), and the companion compression program (if any, else NULL)
   into COMPRESSION_PROGRAM (if that is non-NULL).  If trouble, do
   a fatal error.  */

char *
readfile (char *filename, int *sizep,
    void (*create_callback) (char *), char **opened_filename,
    char **compression_program)
{
  char *real_name;
  FILE *f;
  int pipe_p;
  int filled = 0;
  int data_size = 8192;
  char *data = xmalloc (data_size);

  /* If they passed the space for the file name to return, use it.  */
  f = open_possibly_compressed_file (filename, create_callback,
                                     opened_filename ? opened_filename
                                                     : &real_name,
                                     compression_program, &pipe_p);

  for (;;)
    {
      int nread = fread (data + filled, 1, data_size - filled, f);
      if (nread < 0)
        pfatal_with_name (real_name);
      if (nread == 0)
        break;

      filled += nread;
      if (filled == data_size)
        {
          data_size += 65536;
          data = xrealloc (data, data_size);
        }
    }

  /* We'll end up wasting space if we're not passing the filename back
     and it is not just FILENAME, but so what.  */
  /* We need to close the stream, since on some systems the pipe created
     by popen is simulated by a temporary file which only gets removed
     inside pclose.  */
  if (pipe_p)
    pclose (f);
  else
    fclose (f);

  *sizep = filled;
  return data;
}

/* Output the old dir file, interpolating the new sections
   and/or new entries where appropriate.  If COMPRESSION_PROGRAM is not
   null, pipe to it to create DIRFILE.  Thus if we read dir.gz on input,
   we'll write dir.gz on output.  */

static void
output_dirfile (char *dirfile, int dir_nlines, struct line_data *dir_lines,
                int n_entries_to_add, struct spec_entry *entries_to_add,
                struct spec_section *input_sections, char *compression_program)
{
  int i;
  FILE *output;

  if (compression_program)
    {
      char *command = concat (compression_program, ">", dirfile);
      output = popen (command, "w");
    }
  else
    output = fopen (dirfile, "w");

  if (!output)
    {
      perror (dirfile);
      xexit (1);
    }

  for (i = 0; i <= dir_nlines; i++)
    {
      int j;

      /* If we decided to output some new entries before this line,
         output them now.  */
      if (dir_lines[i].add_entries_before)
        for (j = 0; j < n_entries_to_add; j++)
          {
            struct spec_entry *this = dir_lines[i].add_entries_before[j];
            if (this == 0)
              break;
            fputs (this->text, output);
          }
      /* If we decided to add some sections here
         because there are no such sections in the file,
         output them now.  */
      if (dir_lines[i].add_sections_before)
        {
          struct spec_section *spec;
          struct spec_section **sections;
          int n_sections = 0;
          struct spec_entry *entry;
          struct spec_entry **entries;
          int n_entries = 0;

          /* Count the sections and allocate a vector for all of them.  */
          for (spec = input_sections; spec; spec = spec->next)
            n_sections++;
          sections = ((struct spec_section **)
                      xmalloc (n_sections * sizeof (struct spec_section *)));

          /* Fill the vector SECTIONS with pointers to all the sections,
             and sort them.  */
          j = 0;
          for (spec = input_sections; spec; spec = spec->next)
            sections[j++] = spec;
          qsort (sections, n_sections, sizeof (struct spec_section *),
                 compare_section_names);

          /* Count the entries and allocate a vector for all of them.  */
          for (entry = entries_to_add; entry; entry = entry->next)
            n_entries++;
          entries = ((struct spec_entry **)
                     xmalloc (n_entries * sizeof (struct spec_entry *)));

          /* Fill the vector ENTRIES with pointers to all the sections,
             and sort them.  */
          j = 0;
          for (entry = entries_to_add; entry; entry = entry->next)
            entries[j++] = entry;
          qsort (entries, n_entries, sizeof (struct spec_entry *),
                 compare_entries_text);

          /* Generate the new sections in alphabetical order.  In each
             new section, output all of the entries that belong to that
             section, in alphabetical order.  */
          for (j = 0; j < n_sections; j++)
            {
              spec = sections[j];
              if (spec->missing)
                {
                  int k;

                  putc ('\n', output);
                  fputs (spec->name, output);
                  putc ('\n', output);
                  for (k = 0; k < n_entries; k++)
                    {
                      struct spec_section *spec1;
                      /* Did they at all want this entry to be put into
                         this section?  */
                      entry = entries[k];
                      for (spec1 = entry->entry_sections;
                           spec1 && spec1 != entry->entry_sections_tail;
                           spec1 = spec1->next)
                        {
                          if (!strcmp (spec1->name, spec->name))
                            break;
                        }
                      if (spec1 && spec1 != entry->entry_sections_tail)
                        fputs (entry->text, output);
                    }
                }
            }

          free (entries);
          free (sections);
        }

      /* Output the original dir lines unless marked for deletion.  */
      if (i < dir_nlines && !dir_lines[i].delete)
        {
          fwrite (dir_lines[i].start, 1, dir_lines[i].size, output);
          putc ('\n', output);
        }
    }

  /* Some systems, such as MS-DOS, simulate pipes with temporary files.
     On those systems, the compressor actually gets run inside pclose,
     so we must call pclose.  */
  if (compression_program)
    pclose (output);
  else
    fclose (output);
}

/* Parse the input to find the section names and the entry names it
   specifies.  Return the number of entries to add from this file.  */
int
parse_input (const struct line_data *lines, int nlines,
             struct spec_section **sections, struct spec_entry **entries) 
{
  int n_entries = 0;
  int prefix_length = strlen ("INFO-DIR-SECTION ");
  struct spec_section *head = *sections, *tail = NULL;
  int reset_tail = 0;
  char *start_of_this_entry = 0;
  int ignore_sections = *sections != 0;
  int ignore_entries  = *entries  != 0;

  int i;

  if (ignore_sections && ignore_entries)
    return 0;

  /* Loop here processing lines from the input file.  Each
     INFO-DIR-SECTION entry is added to the SECTIONS linked list.
     Each START-INFO-DIR-ENTRY block is added to the ENTRIES linked
     list, and all its entries inherit the chain of SECTION entries
     defined by the last group of INFO-DIR-SECTION entries we have
     seen until that point.  */
  for (i = 0; i < nlines; i++)
    {
      if (!ignore_sections
          && !strncmp ("INFO-DIR-SECTION ", lines[i].start, prefix_length))
        {
          struct spec_section *next
            = (struct spec_section *) xmalloc (sizeof (struct spec_section));
          next->name = copy_string (lines[i].start + prefix_length,
                                    lines[i].size - prefix_length);
          next->next = *sections;
          next->missing = 1;
          if (reset_tail)
            {
              tail = *sections;
              reset_tail = 0;
            }
          *sections = next;
          head = *sections;
        }
      /* If entries were specified explicitly with command options,
         ignore the entries in the input file.  */
      else if (!ignore_entries)
        {
          if (!strncmp ("START-INFO-DIR-ENTRY", lines[i].start, lines[i].size)
              && sizeof ("START-INFO-DIR-ENTRY") - 1 == lines[i].size)
            {
              if (!*sections)
                {
                  /* We found an entry, but didn't yet see any sections
                     specified.  Default to section "Miscellaneous".  */
                  *sections = (struct spec_section *)
                    xmalloc (sizeof (struct spec_section));
                  (*sections)->name = "Miscellaneous";
                  (*sections)->next = 0;
                  (*sections)->missing = 1;
                  head = *sections;
                }
              /* Next time we see INFO-DIR-SECTION, we will reset the
                 tail pointer.  */
              reset_tail = 1;

              if (start_of_this_entry != 0)
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"), 0, 0);
              start_of_this_entry = lines[i + 1].start;
            }
          else if (start_of_this_entry)
            {
              if ((!strncmp ("* ", lines[i].start, 2)
                   && lines[i].start > start_of_this_entry)
                  || (!strncmp ("END-INFO-DIR-ENTRY",
                                lines[i].start, lines[i].size)
                      && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size))
                {
                  /* We found an end of this entry.  Allocate another
                     entry, fill its data, and add it to the linked
                     list.  */
                  struct spec_entry *next
                    = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));
                  next->text
                    = copy_string (start_of_this_entry,
                                   lines[i].start - start_of_this_entry);
                  next->text_len = lines[i].start - start_of_this_entry;
                  next->entry_sections = head;
                  next->entry_sections_tail = tail;
                  next->next = *entries;
                  *entries = next;
                  n_entries++;
                  if (!strncmp ("END-INFO-DIR-ENTRY",
                                lines[i].start, lines[i].size)
                      && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size)
                    start_of_this_entry = 0;
                  else
                    start_of_this_entry = lines[i].start;
                }
              else if (!strncmp ("END-INFO-DIR-ENTRY",
                                 lines[i].start, lines[i].size)
                       && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size)
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"), 0, 0);
            }
        }
    }
  if (start_of_this_entry != 0)
    fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"),
           0, 0);

  /* If we ignored the INFO-DIR-ENTRY directives, we need now go back
     and plug the names of all the sections we found into every
     element of the ENTRIES list.  */
  if (ignore_entries && *entries)
    {
      struct spec_entry *entry;

      for (entry = *entries; entry; entry = entry->next)
        {
          entry->entry_sections = head;
          entry->entry_sections_tail = tail;
        }
    }

  return n_entries;
}

/* Parse the dir file whose basename is BASE_NAME.  Find all the
   nodes, and their menus, and the sections of their menus.  */
int
parse_dir_file (struct line_data *lines, int nlines, struct node **nodes,
                const char *base_name)
{
  int node_header_flag = 0;
  int something_deleted = 0;
  int i;

  *nodes = 0;
  for (i = 0; i < nlines; i++)
    {
      /* Parse node header lines.  */
      if (node_header_flag)
        {
          int j, end;
          for (j = 0; j < lines[i].size; j++)
            /* Find the node name and store it in the `struct node'.  */
            if (!strncmp ("Node:", lines[i].start + j, 5))
              {
                char *line = lines[i].start;
                /* Find the start of the node name.  */
                j += 5;
                while (line[j] == ' ' || line[j] == '\t')
                  j++;
                /* Find the end of the node name.  */
                end = j;
                while (line[end] != 0 && line[end] != ',' && line[end] != '\n'
                       && line[end] != '\t')
                  end++;
                (*nodes)->name = copy_string (line + j, end - j);
              }
          node_header_flag = 0;
        }

      /* Notice the start of a node.  */
      if (*lines[i].start == 037)
        {
          struct node *next = (struct node *) xmalloc (sizeof (struct node));

          next->next = *nodes;
          next->name = NULL;
          next->start_line = i;
          next->end_line = 0;
          next->menu_start = NULL;
          next->sections = NULL;
          next->last_section = NULL;

          if (*nodes != 0)
            (*nodes)->end_line = i;
          /* Fill in the end of the last menu section
             of the previous node.  */
          if (*nodes != 0 && (*nodes)->last_section != 0)
            (*nodes)->last_section->end_line = i;

          *nodes = next;

          /* The following line is the header of this node;
             parse it.  */
          node_header_flag = 1;
        }

      /* Notice the lines that start menus.  */
      if (*nodes != 0 && !strncmp ("* Menu:", lines[i].start, 7))
        (*nodes)->menu_start = lines[i + 1].start;

      /* Notice sections in menus.  */
      if (*nodes != 0
          && (*nodes)->menu_start != 0
          && *lines[i].start != '\n'
          && *lines[i].start != '*'
          && *lines[i].start != ' '
          && *lines[i].start != '\t')
        {
          /* Add this menu section to the node's list.
             This list grows in forward order.  */
          struct menu_section *next
            = (struct menu_section *) xmalloc (sizeof (struct menu_section));

          next->start_line = i + 1;
          next->next = 0;
          next->end_line = 0;
          next->name = copy_string (lines[i].start, lines[i].size);
          if ((*nodes)->sections)
            {
              (*nodes)->last_section->next = next;
              (*nodes)->last_section->end_line = i;
            }
          else
            (*nodes)->sections = next;
          (*nodes)->last_section = next;
        }

      /* Check for an existing entry that should be deleted.
         Delete all entries which specify this file name.  */
      if (*lines[i].start == '*')
        {
          char *q;
          char *p = lines[i].start;

          p++; /* skip * */
          while (*p == ' ') p++; /* ignore following spaces */
          q = p; /* remember this, it's the beginning of the menu item.  */

          /* Read menu item.  */
          while (*p != 0 && *p != ':')
            p++;
          p++; /* skip : */

          if (*p == ':')
            { /* XEmacs-style entry, as in * Mew::Messaging.  */
              if (menu_item_equal (q, ':', base_name))
                {
                  lines[i].delete = 1;
                  something_deleted = 1;
                }
            }
          else
            { /* Emacs-style entry, as in * Emacs: (emacs).  */
              while (*p == ' ') p++; /* skip spaces after : */
              if (*p == '(')         /* if at parenthesized (FILENAME) */
                {
                  p++;
                  if (menu_item_equal (p, ')', base_name))
                    {
                      lines[i].delete = 1;
                      something_deleted = 1;
                    }
                }
            }
        }

      /* Treat lines that start with whitespace
         as continuations; if we are deleting an entry,
         delete all its continuations as well.  */
      else if (i > 0 && (*lines[i].start == ' ' || *lines[i].start == '\t'))
        {
          lines[i].delete = lines[i - 1].delete;
        }
    }

  /* Finish the info about the end of the last node.  */
  if (*nodes != 0)
    {
      (*nodes)->end_line = nlines;
      if ((*nodes)->last_section != 0)
        (*nodes)->last_section->end_line = nlines;
    }

  return something_deleted;
}

int
main (int argc, char **argv)
{
  char *opened_dirfilename;
  char *compression_program;
  char *infile_sans_info;
  char *infile = 0, *dirfile = 0;

  /* Record the text of the Info file, as a sequence of characters
     and as a sequence of lines.  */
  char *input_data = NULL;
  int input_size = 0;
  struct line_data *input_lines = NULL;
  int input_nlines = 0;

  /* Record here the specified section names and directory entries.  */
  struct spec_section *input_sections = NULL;
  struct spec_entry *entries_to_add = NULL;
  int n_entries_to_add = 0;

  /* Record the old text of the dir file, as plain characters,
     as lines, and as nodes.  */
  char *dir_data;
  int dir_size;
  int dir_nlines;
  struct line_data *dir_lines;
  struct node *dir_nodes;

  /* Nonzero means --delete was specified (just delete existing entries).  */
  int delete_flag = 0;
  int something_deleted = 0;
  /* Nonzero means -q was specified.  */
  int quiet_flag = 0;

  int i;

#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  if (pledge ("stdio rpath wpath cpath proc exec", NULL) == -1)
    pfatal_with_name ("pledge");

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  while (1)
    {
      int opt = getopt_long (argc, argv, "i:d:e:s:hHr", longopts, 0);

      if (opt == EOF)
        break;

      switch (opt)
        {
        case 0:
          /* If getopt returns 0, then it has already processed a
             long-named option.  We should do nothing.  */
          break;

        case 1:
          abort ();

        case 'd':
          if (dirfile)
            {
              fprintf (stderr, _("%s: already have dir file: %s\n"),
                       progname, dirfile);
              suggest_asking_for_help ();
            }
          dirfile = optarg;
          break;

        case 'D':
          if (dirfile)
            {
              fprintf (stderr, _("%s: already have dir file: %s\n"),
                       progname, dirfile);
              suggest_asking_for_help ();
            }
          dirfile = concat (optarg, "", "/dir");
          break;

        case 'e':
          {
            struct spec_entry *next
              = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));
            int olen = strlen (optarg);
            if (! (*optarg != 0 && optarg[olen - 1] == '\n'))
              {
                optarg = concat (optarg, "\n", "");
                olen++;
              }
            next->text = optarg;
            next->text_len = olen;
            next->entry_sections = NULL;
            next->entry_sections_tail = NULL;
            next->next = entries_to_add;
            entries_to_add = next;
            n_entries_to_add++;
          }
          break;

        case 'h':
        case 'H':
          print_help ();
          xexit (0);

        case 'i':
          if (infile)
            {
              fprintf (stderr, _("%s: Specify the Info file only once.\n"),
                       progname);
              suggest_asking_for_help ();
            }
          infile = optarg;
          break;

        case 'q':
          quiet_flag = 1;
          break;

        case 'r':
          delete_flag = 1;
          break;

        case 's':
          {
            struct spec_section *next
              = (struct spec_section *) xmalloc (sizeof (struct spec_section));
            next->name = optarg;
            next->next = input_sections;
            next->missing = 1;
            input_sections = next;
          }
          break;

        case 'V':
          printf ("install-info (GNU %s) %s\n", PACKAGE, VERSION);
          puts ("");
          puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
          printf (_("There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.\n"));
          xexit (0);

        default:
          suggest_asking_for_help ();
        }
    }

  /* Interpret the non-option arguments as file names.  */
  for (; optind < argc; ++optind)
    {
      if (infile == 0)
        infile = argv[optind];
      else if (dirfile == 0)
        dirfile = argv[optind];
      else
        error (_("excess command line argument `%s'"), argv[optind], 0);
    }

  if (!infile)
    fatal (_("No input file specified; try --help for more information."),
           0, 0);
  if (!dirfile)
    fatal (_("No dir file specified; try --help for more information."), 0, 0);

  /* Read the Info file and parse it into lines, unless we're deleting.  */
  if (!delete_flag)
    {
      input_data = readfile (infile, &input_size, NULL, NULL, NULL);
      input_lines = findlines (input_data, input_size, &input_nlines);
    }

  i = parse_input (input_lines, input_nlines,
                   &input_sections, &entries_to_add);
  if (i > n_entries_to_add)
    n_entries_to_add = i;

  if (!delete_flag)
    {
      if (entries_to_add == 0)
        { /* No need to abort here, the original info file may not
             have the requisite Texinfo commands.  This is not
             something an installer should have to correct (it's a
             problem for the maintainer), and there's no need to cause
             subsequent parts of `make install' to fail.  */
          warning (_("no info dir entry in `%s'"), infile, 0);
          xexit (0);
        }

      /* If the entries came from the command-line arguments, their
         entry_sections pointers are not yet set.  Walk the chain of
         the entries and for each entry update entry_sections to point
         to the head of the list of sections where this entry should
         be put.  Note that all the entries specified on the command
         line get put into ALL the sections we've got, either from the
         Info file, or (under --section) from the command line,
         because in the loop below every entry inherits the entire
         chain of sections.  */
      if (n_entries_to_add > 0 && entries_to_add->entry_sections == NULL)
        {
          struct spec_entry *ep;

          /* If we got no sections, default to "Miscellaneous".  */
          if (input_sections == NULL)
            {
              input_sections = (struct spec_section *)
                xmalloc (sizeof (struct spec_section));
              input_sections->name = "Miscellaneous";
              input_sections->next = NULL;
              input_sections->missing = 1;
            }
          for (ep = entries_to_add; ep; ep = ep->next)
            ep->entry_sections = input_sections;
        }
    }

  /* Now read in the Info dir file.  */
  dir_data = readfile (dirfile, &dir_size, ensure_dirfile_exists,
                       &opened_dirfilename, &compression_program);
  dir_lines = findlines (dir_data, dir_size, &dir_nlines);

  /* We will be comparing the entries in the dir file against the
     current filename, so need to strip off any directory prefix and/or
     [.info][.gz] suffix.  */
  {
    char *infile_basename = infile + strlen (infile);

    if (HAVE_DRIVE (infile))
      infile += 2;      /* get past the drive spec X: */

    while (infile_basename > infile && !IS_SLASH (infile_basename[-1]))
      infile_basename--;

    infile_sans_info = strip_info_suffix (infile_basename);
  }

  something_deleted
    = parse_dir_file (dir_lines, dir_nlines, &dir_nodes, infile_sans_info);

  /* Decide where to add the new entries (unless --delete was used).
     Find the menu sections to add them in.
     In each section, find the proper alphabetical place to add
     each of the entries.  */
  if (!delete_flag)
    {
      struct node *node;
      struct menu_section *section;
      struct spec_section *spec;

      for (node = dir_nodes; node; node = node->next)
        for (section = node->sections; section; section = section->next)
          {
            for (i = section->end_line; i > section->start_line; i--)
              if (dir_lines[i - 1].size != 0)
                break;
            section->end_line = i;

            for (spec = input_sections; spec; spec = spec->next)
              if (!strcmp (spec->name, section->name))
                break;
            if (spec)
              {
                int add_at_line = section->end_line;
                struct spec_entry *entry;
                /* Say we have found at least one section with this name,
                   so we need not add such a section.  */
                spec->missing = 0;
                /* For each entry, find the right place in this section
                   to add it.  */
                for (entry = entries_to_add; entry; entry = entry->next)
                  {
                    /* Did they at all want this entry to be put into
                       this section?  */
                    for (spec = entry->entry_sections;
                         spec && spec != entry->entry_sections_tail;
                         spec = spec->next)
                      {
                        if (!strcmp (spec->name, section->name))
                          break;
                      }
                    if (!spec || spec == entry->entry_sections_tail)
                      continue;

                    /* Subtract one because dir_lines is zero-based,
                       but the `end_line' and `start_line' members are
                       one-based.  */
                    for (i = section->end_line - 1;
                         i >= section->start_line - 1; i--)
                      {
                        /* If an entry exists with the same name,
                           and was not marked for deletion
                           (which means it is for some other file),
                           we are in trouble.  */
                        if (dir_lines[i].start[0] == '*'
                            && menu_line_equal (entry->text, entry->text_len,
                                                dir_lines[i].start,
                                                dir_lines[i].size)
                            && !dir_lines[i].delete)
                          fatal (_("menu item `%s' already exists, for file `%s'"),
                                 extract_menu_item_name (entry->text),
                                 extract_menu_file_name (dir_lines[i].start));
                        if (dir_lines[i].start[0] == '*'
                            && menu_line_lessp (entry->text, entry->text_len,
                                                dir_lines[i].start,
                                                dir_lines[i].size))
                          add_at_line = i;
                      }
                    insert_entry_here (entry, add_at_line,
                                       dir_lines, n_entries_to_add);
                  }
              }
          }

      /* Mark the end of the Top node as the place to add any
         new sections that are needed.  */
      for (node = dir_nodes; node; node = node->next)
        if (node->name && strcmp (node->name, "Top") == 0)
          dir_lines[node->end_line].add_sections_before = 1;
    }

  if (delete_flag && !something_deleted && !quiet_flag)
    warning (_("no entries found for `%s'; nothing deleted"), infile, 0);

  output_dirfile (opened_dirfilename, dir_nlines, dir_lines, n_entries_to_add,
                  entries_to_add, input_sections, compression_program);

  xexit (0);
  return 0; /* Avoid bogus warnings.  */
}

/* Divide the text at DATA (of SIZE bytes) into lines.
   Return a vector of struct line_data describing the lines.
   Store the length of that vector into *NLINESP.  */

struct line_data *
findlines (char *data, int size, int *nlinesp)
{
  int i;
  int lineflag = 1;
  int lines_allocated = 511;
  int filled = 0;
  struct line_data *lines
    = xmalloc ((lines_allocated + 1) * sizeof (struct line_data));

  for (i = 0; i < size; i++)
    {
      if (lineflag)
        {
          if (filled == lines_allocated)
            {
              /* try to keep things somewhat page-aligned */
              lines_allocated = ((lines_allocated + 1) * 2) - 1;
              lines = xrealloc (lines, (lines_allocated + 1)
                                       * sizeof (struct line_data));
            }
          lines[filled].start = &data[i];
          lines[filled].add_entries_before = 0;
          lines[filled].add_sections_before = 0;
          lines[filled].delete = 0;
          if (filled > 0)
            lines[filled - 1].size
              = lines[filled].start - lines[filled - 1].start - 1;
          filled++;
        }
      lineflag = (data[i] == '\n');
    }
  if (filled > 0)
    lines[filled - 1].size = &data[i] - lines[filled - 1].start - lineflag;

  /* Do not leave garbage in the last element.  */
  lines[filled].start = NULL;
  lines[filled].add_entries_before = NULL;
  lines[filled].add_sections_before = 0;
  lines[filled].delete = 0;
  lines[filled].size = 0;

  *nlinesp = filled;
  return lines;
}

/* This is the comparison function for qsort for a vector of pointers to
   struct spec_section.  (Have to use const void * as the parameter type
   to avoid incompatible-with-qsort warnings.)
   Compare the section names.  */

int
compare_section_names (const void *p1, const void *p2)
{
  struct spec_section **sec1 = (struct spec_section **) p1;
  struct spec_section **sec2 = (struct spec_section **) p2;
  char *name1 = (*sec1)->name;
  char *name2 = (*sec2)->name;
  return strcmp (name1, name2);
}

/* This is the comparison function for qsort
   for a vector of pointers to struct spec_entry.
   Compare the entries' text.  */

int
compare_entries_text (const void *p1, const void *p2)
{
  struct spec_entry **entry1 = (struct spec_entry **) p1;
  struct spec_entry **entry2 = (struct spec_entry **) p2;
  char *text1 = (*entry1)->text;
  char *text2 = (*entry2)->text;
  char *colon1 = strchr (text1, ':');
  char *colon2 = strchr (text2, ':');
  int len1, len2;

  if (!colon1)
    len1 = strlen (text1);
  else
    len1 = colon1 - text1;
  if (!colon2)
    len2 = strlen (text2);
  else
    len2 = colon2 - text2;
  return strncmp (text1, text2, len1 <= len2 ? len1 : len2);
}

/* Insert ENTRY into the add_entries_before vector
   for line number LINE_NUMBER of the dir file.
   DIR_LINES and N_ENTRIES carry information from like-named variables
   in main.  */

void
insert_entry_here (struct spec_entry *entry, int line_number,
                   struct line_data *dir_lines, int n_entries)
{
  int i, j;

  if (dir_lines[line_number].add_entries_before == 0)
    {
      dir_lines[line_number].add_entries_before
        = (struct spec_entry **) xmalloc (n_entries * sizeof (struct spec_entry *));
      for (i = 0; i < n_entries; i++)
        dir_lines[line_number].add_entries_before[i] = 0;
    }

  /* Find the place where this entry belongs.  If there are already
     several entries to add before LINE_NUMBER, make sure they are in
     alphabetical order.  */
  for (i = 0; i < n_entries; i++)
    if (dir_lines[line_number].add_entries_before[i] == 0
        || menu_line_lessp (entry->text, strlen (entry->text),
                            dir_lines[line_number].add_entries_before[i]->text,
                            strlen (dir_lines[line_number].add_entries_before[i]->text)))
      break;

  if (i == n_entries)
    abort ();

  /* If we need to plug ENTRY into the middle of the
     ADD_ENTRIES_BEFORE array, move the entries which should be output
     after this one down one notch, before adding a new one.  */
  if (dir_lines[line_number].add_entries_before[i] != 0)
    for (j = n_entries - 1; j > i; j--)
      dir_lines[line_number].add_entries_before[j]
        = dir_lines[line_number].add_entries_before[j - 1];

  dir_lines[line_number].add_entries_before[i] = entry;
}
@


1.8
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.12 2004/04/11 17:56:47 karl Exp $
d1166 3
@


1.7
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.55 2002/03/11 19:55:23 karl Exp $
d4 2
a5 1
   Copyright (C) 1996, 97, 98, 99, 2000, 01, 02 Free Software Foundation, Inc.
d26 2
a27 3
struct line_data *findlines ();
void insert_entry_here ();
int compare_section_names (), compare_entries_text ();
d29 5
a33 1
struct spec_entry;
d126 1
d143 1
a143 2
error (s1, s2, s3)
     char *s1, *s2, *s3;
d152 1
a152 2
warning (s1, s2, s3)
     char *s1, *s2, *s3;
d162 1
a162 2
fatal (s1, s2, s3)
     char *s1, *s2, *s3;
a167 27
/* Memory allocation and string operations.  */

/* Like malloc but get fatal error if memory is exhausted.  */
void *
xmalloc (size)
     unsigned int size;
{
  extern void *malloc ();
  void *result = malloc (size);
  if (result == NULL)
    fatal (_("virtual memory exhausted"), 0, 0);
  return result;
}

/* Like realloc but get fatal error if memory is exhausted.  */
void *
xrealloc (obj, size)
     void *obj;
     unsigned int size;
{
  extern void *realloc ();
  void *result = realloc (obj, size);
  if (result == NULL)
    fatal (_("virtual memory exhausted"), 0, 0);
  return result;
}

d171 1
a171 2
concat (s1, s2, s3)
     char *s1, *s2, *s3;
d188 1
a188 3
copy_string (string, size)
     char *string;
     int size;
d201 1
a201 2
pfatal_with_name (name)
     char *name;
d207 54
d265 1
a265 2
extract_menu_item_name (item_text)
     char *item_text;
d283 1
a283 2
extract_menu_file_name (item_text)
     char *item_text;
d326 1
a326 2
strip_info_suffix (fname)
     char *fname;
d336 5
d370 1
a370 4
menu_item_equal (item, term_char, name)
     char *item;
     char term_char;
     char *name;
d372 2
d375 19
d395 1
a395 1
  int ret = strncasecmp (item, name, name_len) == 0;
d413 2
a414 2
          ret = strncasecmp (item + name_len, suffix, suffix_len) == 0
                && item[name_len + suffix_len] == term_char;
d424 1
a424 1
suggest_asking_for_help ()
d432 1
a432 1
print_help ()
d477 1
a477 2
ensure_dirfile_exists (dirfile)
     char *dirfile;
d491 1
a491 1
\n\
d502 4
a505 2
* Menu:\n\
"), "File: dir,\tNode: Top"); /* This part must not be translated.  */
d533 3
a535 7
open_possibly_compressed_file (filename, create_callback,
                               opened_filename, compression_program, is_pipe)
     char *filename;
     void (*create_callback) ();
     char **opened_filename;
     char **compression_program;
     int  *is_pipe;
d553 7
d615 12
d665 3
a667 7
readfile (filename, sizep, create_callback,
          opened_filename, compression_program)
     char *filename;
     int *sizep;
     void (*create_callback) ();
     char **opened_filename;
     char **compression_program;
d718 3
a720 10
output_dirfile (dirfile, dir_nlines, dir_lines,
                n_entries_to_add, entries_to_add, input_sections,
                compression_program)
      char *dirfile;
      int dir_nlines;
      struct line_data *dir_lines;
      int n_entries_to_add;
      struct spec_entry *entries_to_add;
      struct spec_section *input_sections;
      char *compression_program;
d849 2
a850 5
parse_input (lines, nlines, sections, entries)
     const struct line_data *lines;
     int nlines;
     struct spec_section **sections;
     struct spec_entry **entries;
d954 1
a954 1
	   0, 0);
d976 2
a977 5
parse_dir_file (lines, nlines, nodes, base_name)
     struct line_data *lines;
     int nlines;
     struct node **nodes;
     const char *base_name;
d1127 1
a1127 3
main (argc, argv)
     int argc;
     char **argv;
a1132 1
  unsigned infilelen_sans_info;
d1191 2
a1192 2
              fprintf (stderr, _("%s: Specify the Info directory only once.\n"),
                       progname);
d1201 2
a1202 2
              fprintf (stderr, _("%s: Specify the Info directory only once.\n"),
                       progname);
d1265 2
a1266 2
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
d1268 1
a1268 2
For more information about these matters, see the files named COPYING.\n"),
		  "2002");
d1289 1
a1289 1
	   0, 0);
d1356 1
a1356 1
      infile += 2;	/* get past the drive spec X: */
a1361 1
    infilelen_sans_info = strlen (infile_sans_info);
a1370 1

d1410 1
a1410 1
                    
d1455 1
d1463 1
a1463 4
findlines (data, size, nlinesp)
     char *data;
     int size;
     int *nlinesp;
d1508 3
a1510 63
/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item name
   in LINE1 is less, 0 otherwise.  */

int
menu_line_lessp (line1, len1, line2, len2)
     char *line1;
     int len1;
     char *line2;
     int len2;
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If one item name is a prefix of the other,
         the former one is less.  */
      if (line1[i] == ':' && line2[i] != ':')
        return 1;
      if (line2[i] == ':' && line1[i] != ':')
        return 0;
      /* If they both continue and differ, one is less.  */
      if (line1[i] < line2[i])
        return 1;
      if (line1[i] > line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 0;
}

/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item names are equal,
   0 otherwise.  */

int
menu_line_equal (line1, len1, line2, len2)
     char *line1;
     int len1;
     char *line2;
     int len2;
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If both item names end here, they are equal.  */
      if (line1[i] == ':' && line2[i] == ':')
        return 1;
      /* If they both continue and differ, one is less.  */
      if (line1[i] != line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 1;
}

/* This is the comparison function for qsort
   for a vector of pointers to struct spec_section.
d1514 1
a1514 2
compare_section_names (sec1, sec2)
     struct spec_section **sec1, **sec2;
d1516 2
d1528 1
a1528 2
compare_entries_text (entry1, entry2)
     struct spec_entry **entry1, **entry2;
d1530 2
d1555 2
a1556 5
insert_entry_here (entry, line_number, dir_lines, n_entries)
     struct spec_entry *entry;
     int line_number;
     struct line_data *dir_lines;
     int n_entries;
@


1.6
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.48 1999/08/06 18:13:32 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.
d176 1
a176 1
    fatal (_("virtual memory exhausted"), 0);
d189 1
a189 1
    fatal (_("virtual memory exhausted"), 0);
d233 1
a233 1
  fatal (s, name);
d419 3
a421 1
\n\
d424 1
a424 1
"), progname);
d551 1
a551 1
        fatal (_("%s: empty file"), *opened_filename);
d866 1
a866 1
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
d901 1
a901 1
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"));
d906 2
a907 1
    fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
d1228 1
a1228 1
		  "1999");
d1244 1
a1244 1
        error (_("excess command line argument `%s'"), argv[optind]);
d1248 2
a1249 1
    fatal (_("No input file specified; try --help for more information."));
d1251 1
a1251 1
    fatal (_("No dir file specified; try --help for more information."));
d1273 1
a1273 1
          warning (_("no info dir entry in `%s'"), infile);
d1411 1
a1411 1
    warning (_("no entries found for `%s'; nothing deleted"), infile);
@


1.5
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.21 1998/03/01 15:38:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98 Free Software Foundation, Inc.
d23 1
a23 6
#ifdef HAVE_LIBZ
#include <zlib.h>
#endif

/* Name this program was invoked with.  */
char *progname;
a24 1
char *readfile ();
a25 1
void fatal ();
d27 1
a27 1
int compare_section_names ();
d69 7
d113 53
a224 34

/* Error message functions.  */

/* Print error message.  S1 is printf control string, S2 and S3 args for it. */

/* VARARGS1 */
void
error (s1, s2, s3)
     char *s1, *s2, *s3;
{
  fprintf (stderr, "%s: ", progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* VARARGS1 */
void
warning (s1, s2, s3)
     char *s1, *s2, *s3;
{
  fprintf (stderr, _("%s: warning: "), progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* Print error message and exit.  */

void
fatal (s1, s2, s3)
     char *s1, *s2, *s3;
{
  error (s1, s2, s3);
  exit (1);
}
d297 80
d383 1
a383 1
  exit (1);
d391 2
a392 1
Install INFO-FILE in the Info directory file DIR-FILE.\n\
d395 24
a418 24
--delete          Delete existing entries in INFO-FILE;\n\
                    don't insert any new entries.\n\
--dir-file=NAME   Specify file name of Info directory file.\n\
                    This is equivalent to using the DIR-FILE argument.\n\
--entry=TEXT      Insert TEXT as an Info directory entry.\n\
                    TEXT should have the form of an Info menu item line\n\
                    plus zero or more extra lines starting with whitespace.\n\
                    If you specify more than one entry, they are all added.\n\
                    If you don't specify any entries, they are determined\n\
                    from information in the Info file itself.\n\
--help            Display this help and exit.\n\
--info-file=FILE  Specify Info file to install in the directory.\n\
                    This is equivalent to using the INFO-FILE argument.\n\
--info-dir=DIR    Same as --dir-file=DIR/dir.\n\
--item=TEXT       Same as --entry TEXT.\n\
                    An Info directory entry is actually a menu item.\n\
--quiet           Suppress warnings.\n\
--remove          Same as --delete.\n\
--section=SEC     Put this file's entries in section SEC of the directory.\n\
                    If you specify more than one section, all the entries\n\
                    are added in each of the sections.\n\
                    If you don't specify any sections, they are determined\n\
                    from information in the Info file itself.\n\
--version         Display version information and exit.\n\
d420 2
a421 1
Email bug reports to bug-texinfo@@gnu.org.\n\
d442 1
a442 1
          fputs (_("This is the file .../info/dir, which contains the\n\
d446 1
a446 1
File: dir,\tNode: Top,\tThis is the top of the INFO tree\n\
d457 1
a457 1
"), f);
d465 609
a1073 4
                   _("%s: could not read (%s) and could not create (%s)\n"),
                   dirfile, readerr, strerror (errno));
          exit (1);
        }
d1075 2
a1076 2
  else
    close (desc); /* It already existed, so fine.  */
a1077 19

/* This table defines all the long-named options, says whether they
   use an argument, and maps them into equivalent single-letter options.  */

struct option longopts[] =
{
  { "delete",    no_argument, NULL, 'r' },
  { "dir-file",  required_argument, NULL, 'd' },
  { "entry",     required_argument, NULL, 'e' },
  { "help",      no_argument, NULL, 'h' },
  { "info-dir",  required_argument, NULL, 'D' },
  { "info-file", required_argument, NULL, 'i' },
  { "item",      required_argument, NULL, 'e' },
  { "quiet",     no_argument, NULL, 'q' },
  { "remove",    no_argument, NULL, 'r' },
  { "section",   required_argument, NULL, 's' },
  { "version",   no_argument, NULL, 'V' },
  { 0 }
};
a1078 1

d1084 3
a1087 1
  char *infile_sans_info;
a1088 1
  FILE *output;
d1092 4
a1095 4
  char *input_data;
  int input_size;
  struct line_data *input_lines;
  int input_nlines;
a1115 2
  int node_header_flag;
  int prefix_length;
a1117 2
  progname = argv[0];

d1168 6
a1173 2
            if (! (*optarg != 0 && optarg[strlen (optarg) - 1] == '\n'))
              optarg = concat (optarg, "\n", "");
d1175 3
d1187 1
a1187 1
          exit (0);
d1220 1
d1225 2
a1226 2
		  "1998");
          exit (0);
d1249 6
a1254 1
  /* Read the Info file and parse it into lines.  */
d1256 4
a1259 2
  input_data = readfile (infile, &input_size);
  input_lines = findlines (input_data, input_size, &input_nlines);
d1261 1
a1261 3
  /* Parse the input file to find the section names it specifies.  */

  if (input_sections == 0)
d1263 8
a1270 14
      prefix_length = strlen ("INFO-DIR-SECTION ");
      for (i = 0; i < input_nlines; i++)
        {
          if (!strncmp ("INFO-DIR-SECTION ", input_lines[i].start,
                        prefix_length))
            {
              struct spec_section *next
                = (struct spec_section *) xmalloc (sizeof (struct spec_section));
              next->name = copy_string (input_lines[i].start + prefix_length,
                                        input_lines[i].size - prefix_length);
              next->next = input_sections;
              next->missing = 1;
              input_sections = next;
            }
a1271 1
    }
d1273 12
a1284 9
  /* Default to section "Miscellaneous" if no sections specified.  */
  if (input_sections == 0)
    {
      input_sections
        = (struct spec_section *) xmalloc (sizeof (struct spec_section));
      input_sections->name = "Miscellaneous";
      input_sections->next = 0;
      input_sections->missing = 1;
    }
d1286 2
a1287 20
  /* Now find the directory entries specified in the file
     and put them on entries_to_add.  But not if entries
     were specified explicitly with command options.  */

  if (entries_to_add == 0)
    {
      char *start_of_this_entry = 0;
      for (i = 0; i < input_nlines; i++)
        {
          if (!strncmp ("START-INFO-DIR-ENTRY", input_lines[i].start,
                        input_lines[i].size)
              && sizeof ("START-INFO-DIR-ENTRY") - 1 == input_lines[i].size)
            {
              if (start_of_this_entry != 0)
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
              start_of_this_entry = input_lines[i + 1].start;
            }
          if (!strncmp ("END-INFO-DIR-ENTRY", input_lines[i].start,
                        input_lines[i].size)
              && sizeof ("END-INFO-DIR-ENTRY") - 1 == input_lines[i].size)
d1289 5
a1293 13
              if (start_of_this_entry != 0)
                {
                  struct spec_entry *next
                    = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));
                  next->text = copy_string (start_of_this_entry,
                                            input_lines[i].start - start_of_this_entry);
                  next->next = entries_to_add;
                  entries_to_add = next;
                  n_entries_to_add++;
                  start_of_this_entry = 0;
                }
              else
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"));
d1295 2
a1297 2
      if (start_of_this_entry != 0)
        fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
a1299 11
  if (!delete_flag)
    if (entries_to_add == 0)
      { /* No need to abort here, the original info file may not have
           the requisite Texinfo commands.  This is not something an
           installer should have to correct (it's a problem for the
           maintainer), and there's no need to cause subsequent parts of
           `make install' to fail.  */
        warning (_("no info dir entry in `%s'"), infile);
        exit (0);
      }

d1301 2
a1302 2
  ensure_dirfile_exists (dirfile);
  dir_data = readfile (dirfile, &dir_size);
d1306 2
a1307 2
     current filename, so need to strip off any directory prefix and any
     .info suffix.  */
d1309 4
a1312 13
    unsigned basename_len;
    char *infile_basename = strrchr (infile, '/');
    if (infile_basename)
      infile_basename++;
    else
      infile_basename = infile;
    
    basename_len = strlen (infile_basename);
    infile_sans_info
      = (strlen (infile_basename) > 5
         && strcmp (infile_basename + basename_len - 5, ".info") == 0)
        ? copy_string (infile_basename, basename_len - 5)
        : infile_basename;
d1314 4
a1319 124
  
  /* Parse the dir file.  Find all the nodes, and their menus,
     and the sections of their menus.  */

  dir_nodes = 0;
  node_header_flag = 0;
  for (i = 0; i < dir_nlines; i++)
    {
      /* Parse node header lines.  */
      if (node_header_flag)
        {
          int j, end;
          for (j = 0; j < dir_lines[i].size; j++)
            /* Find the node name and store it in the `struct node'.  */
            if (!strncmp ("Node:", dir_lines[i].start + j, 5))
              {
                char *line = dir_lines[i].start;
                /* Find the start of the node name.  */
                j += 5;
                while (line[j] == ' ' || line[j] == '\t')
                  j++;
                /* Find the end of the node name.  */
                end = j;
                while (line[end] != 0 && line[end] != ',' && line[end] != '\n'
                       && line[end] != '\t')
                  end++;
                dir_nodes->name = copy_string (line + j, end - j);
              }
          node_header_flag = 0;
        }

      /* Notice the start of a node.  */
      if (*dir_lines[i].start == 037)
        {
          struct node *next
            = (struct node *) xmalloc (sizeof (struct node));
          next->next = dir_nodes;
          next->name = NULL;
          next->start_line = i;
          next->end_line = 0;
          next->menu_start = NULL;
          next->sections = NULL;
          next->last_section = NULL;

          if (dir_nodes != 0)
            dir_nodes->end_line = i;
          /* Fill in the end of the last menu section
             of the previous node.  */
          if (dir_nodes != 0 && dir_nodes->last_section != 0)
            dir_nodes->last_section->end_line = i;

          dir_nodes = next;

          /* The following line is the header of this node;
             parse it.  */
          node_header_flag = 1;
        }

      /* Notice the lines that start menus.  */
      if (dir_nodes != 0
          && !strncmp ("* Menu:", dir_lines[i].start, 7))
        dir_nodes->menu_start = dir_lines[i + 1].start;

      /* Notice sections in menus.  */
      if (dir_nodes != 0
          && dir_nodes->menu_start != 0
          && *dir_lines[i].start != '\n'
          && *dir_lines[i].start != '*'
          && *dir_lines[i].start != ' '
          && *dir_lines[i].start != '\t')
        {
          /* Add this menu section to the node's list.
             This list grows in forward order.  */
          struct menu_section *next
            = (struct menu_section *) xmalloc (sizeof (struct menu_section));
          next->start_line = i + 1;
          next->next = 0;
          next->end_line = 0;
          next->name = copy_string (dir_lines[i].start, dir_lines[i].size);
          if (dir_nodes->sections)
            {
              dir_nodes->last_section->next = next;
              dir_nodes->last_section->end_line = i;
            }
          else
            dir_nodes->sections = next;
          dir_nodes->last_section = next;
        }

      /* Check for an existing entry that should be deleted.
         Delete all entries which specify this file name.  */
      if (*dir_lines[i].start == '*')
        {
          char *p = dir_lines[i].start;

          while (*p != 0 && *p != ':')
            p++;
          p++;
          while (*p == ' ') p++;
          if (*p == '(')
            {
              p++;
              if ((dir_lines[i].size
                   > (p - dir_lines[i].start + infilelen_sans_info))
                  && !strncmp (p, infile_sans_info, infilelen_sans_info)
                  && (p[infilelen_sans_info] == ')'
                      || !strncmp (p + infilelen_sans_info, ".info)", 6)))
                {
                  dir_lines[i].delete = 1;
                  something_deleted = 1;
                }
            }
        }
      /* Treat lines that start with whitespace
         as continuations; if we are deleting an entry,
         delete all its continuations as well.  */
      else if (i > 0
               && (*dir_lines[i].start == ' '
                   || *dir_lines[i].start == '\t'))
        {
          dir_lines[i].delete = dir_lines[i - 1].delete;
          something_deleted = 1;
        }
    }
d1321 2
a1322 7
  /* Finish the info about the end of the last node.  */
  if (dir_nodes != 0)
    {
      dir_nodes->end_line = dir_nlines;
      if (dir_nodes->last_section != 0)
        dir_nodes->last_section->end_line = dir_nlines;
    }
d1357 12
a1368 1
                    int textlen = strlen (entry->text);
d1380 1
a1380 1
                            && menu_line_equal (entry->text, textlen,
d1388 1
a1388 1
                            && menu_line_lessp (entry->text, textlen,
d1409 2
a1410 154
  /* Output the old dir file, interpolating the new sections
     and/or new entries where appropriate.  */

  output = fopen (dirfile, "w");
  if (!output)
    {
      perror (dirfile);
      exit (1);
    }

  for (i = 0; i <= dir_nlines; i++)
    {
      int j;

      /* If we decided to output some new entries before this line,
         output them now.  */
      if (dir_lines[i].add_entries_before)
        for (j = 0; j < n_entries_to_add; j++)
          {
            struct spec_entry *this = dir_lines[i].add_entries_before[j];
            if (this == 0)
              break;
            fputs (this->text, output);
          }
      /* If we decided to add some sections here
         because there are no such sections in the file,
         output them now.  */
      if (dir_lines[i].add_sections_before)
        {
          struct spec_section *spec;
          struct spec_section **sections;
          int n_sections = 0;

          /* Count the sections and allocate a vector for all of them.  */
          for (spec = input_sections; spec; spec = spec->next)
            n_sections++;
          sections = ((struct spec_section **)
                      xmalloc (n_sections * sizeof (struct spec_section *)));

          /* Fill the vector SECTIONS with pointers to all the sections,
             and sort them.  */
          j = 0;
          for (spec = input_sections; spec; spec = spec->next)
            sections[j++] = spec;
          qsort (sections, n_sections, sizeof (struct spec_section *),
                 compare_section_names);

          /* Generate the new sections in alphabetical order.
             In each new section, output all of our entries.  */
          for (j = 0; j < n_sections; j++)
            {
              spec = sections[j];
              if (spec->missing)
                {
                  struct spec_entry *entry;

                  putc ('\n', output);
                  fputs (spec->name, output);
                  putc ('\n', output);
                  for (entry = entries_to_add; entry; entry = entry->next)
                    fputs (entry->text, output);
                }
            }

          free (sections);
        }

      /* Output the original dir lines unless marked for deletion.  */
      if (i < dir_nlines && !dir_lines[i].delete)
        {
          fwrite (dir_lines[i].start, 1, dir_lines[i].size, output);
          putc ('\n', output);
        }
    }

  fclose (output);

  exit (0);
}

/* Read all of file FILNAME into memory
   and return the address of the data.
   Store the size into SIZEP.
   If there is trouble, do a fatal error.  */

char *
readfile (filename, sizep)
     char *filename;
     int *sizep;
{
  int desc;
  int data_size = 1024;
  char *data = (char *) xmalloc (data_size);
  int filled = 0;
  int nread = 0;
#ifdef HAVE_LIBZ
  int isGZ = 0;
  gzFile zdesc;
#endif

  desc = open (filename, O_RDONLY);
  if (desc < 0)
    pfatal_with_name (filename);

#ifdef HAVE_LIBZ
  /* The file should always be two bytes long.  */
  if (read (desc, data, 2) != 2)
    pfatal_with_name (filename);

  /* Undo that read.  */
  lseek (desc, 0, SEEK_SET);

  /* If we see gzip magic, use gzdopen. */
  if (data[0] == '\x1f' && data[1] == '\x8b')
    {
      isGZ = 1;
      zdesc = gzdopen (desc, "r");
      if (zdesc == NULL) {
        close (desc);
        pfatal_with_name (filename);
      }
    }
#endif /* HAVE_LIBZ */

  while (1)
    {
#ifdef HAVE_LIBZ
      if (isGZ)
	nread = gzread (zdesc, data + filled, data_size - filled);
      else
#endif
        nread = read (desc, data + filled, data_size - filled);

      if (nread < 0)
        pfatal_with_name (filename);
      if (nread == 0)
        break;

      filled += nread;
      if (filled == data_size)
        {
          data_size *= 2;
          data = (char *) xrealloc (data, data_size);
        }
    }

  *sizep = filled;

#ifdef HAVE_LIBZ
  if (isGZ)
    gzclose (zdesc);
  else
#endif
    close(desc);
d1412 1
a1412 1
  return data;
d1425 3
a1427 2
  struct line_data *lines;
  int lines_allocated = 512;
d1429 2
a1430 2
  int i = 0;
  int lineflag;
a1431 3
  lines = (struct line_data *) xmalloc (lines_allocated * sizeof (struct line_data));

  lineflag = 1;
d1438 4
a1441 2
              lines_allocated *= 2;
              lines = (struct line_data *) xrealloc (lines, lines_allocated * sizeof (struct line_data));
d1481 1
a1481 1
  
d1514 1
a1514 1
  
d1542 25
d1579 1
a1579 1
  int i;
d1589 3
d1593 4
a1596 1
    if (dir_lines[line_number].add_entries_before[i] == 0)
d1601 8
@


1.4
log
@fix conflicts
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.14 1997/07/25 18:09:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97 Free Software Foundation, Inc.
d23 4
d290 3
a292 2
  printf (_("%s [OPTION]... [INFO-FILE [DIR-FILE]]\n\
  Install INFO-FILE in the Info directory file DIR-FILE.\n\
d320 1
a320 1
Email bug reports to bug-texinfo@@prep.ai.mit.edu.\n\
d323 1
d327 1
d345 1
a345 1
File: dir       Node: Top       This is the top of the INFO tree\n\
d378 11
a388 11
  { "delete",                   no_argument, NULL, 'r' },
  { "dir-file",                 required_argument, NULL, 'd' },
  { "entry",                    required_argument, NULL, 'e' },
  { "help",                     no_argument, NULL, 'h' },
  { "info-dir",                 required_argument, NULL, 'D' },
  { "info-file",                required_argument, NULL, 'i' },
  { "item",                     required_argument, NULL, 'e' },
  { "quiet",                    no_argument, NULL, 'q' },
  { "remove",                   no_argument, NULL, 'r' },
  { "section",                  required_argument, NULL, 's' },
  { "version",                  no_argument, NULL, 'V' },
d391 1
d529 2
a530 2
          printf (_("install-info (GNU %s) %s\n"), PACKAGE, VERSION);
puts (_("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d533 2
a534 1
For more information about these matters, see the files named COPYING."));
d967 1
d972 4
d977 1
a977 1
  int desc = open (filename, O_RDONLY);
d981 20
d1003 7
a1009 1
      nread = read (desc, data + filled, data_size - filled);
d1024 8
@


1.3
log
@make --delete work
@
text
@d2 1
a2 1
   Copyright (C) 1996 Free Software Foundation, Inc.
d4 1
a4 1
$Id: install-info.c,v 1.2 1997/01/04 20:31:05 kstailey Exp $
d6 4
a9 4
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d11 4
a14 4
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d16 3
a18 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d20 1
a20 4
#define INSTALL_INFO_VERSION_STRING "GNU install-info (Texinfo 3.9) 1.2"

#include <stdio.h>
#include <errno.h>
a21 11
#include <sys/types.h>

/* Get O_RDONLY.  */
#ifdef HAVE_SYS_FCNTL_H
#include <sys/fcntl.h>
#else
#include <fcntl.h>
#endif /* !HAVE_SYS_FCNTL_H */
#ifdef HAVE_SYS_FILE_H
#include <sys/file.h>
#endif
a27 1
char *my_strerror ();
a35 2
/* Record info about a single line from a file
   as read into core.  */
d37 1
d54 1
a56 1

d66 1
a67 1

d73 2
a74 1

a75 1

d96 1
a98 1

a111 1

d119 1
a119 1
    fatal ("virtual memory exhausted", 0);
d123 1
a123 2
/* Like malloc but get fatal error if memory is exhausted.  */

d132 1
a132 1
    fatal ("virtual memory exhausted", 0);
d136 2
a137 2
/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */

d171 1
a171 1
/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
d180 1
a180 1
  fprintf (stderr, "\n");
d188 1
a188 1
  fprintf (stderr, "%s: Warning: ", progname);
d190 1
a190 1
  fprintf (stderr, "\n");
d209 1
a209 1
  char *s = concat ("", my_strerror (errno), " for %s");
d278 1
a278 1
  fprintf (stderr, "\tTry `%s --help' for a complete list of options.\n",
d286 1
a286 1
  printf ("%s [OPTION]... [INFO-FILE [DIR-FILE]]\n\
d316 1
a316 1
", progname);
d318 6
a323 8

/* Convert an errno value into a string describing the error.
   We define this function here rather than using strerror
   because not all systems have strerror.  */

char *
my_strerror (errnum)
     int errnum;
d325 39
a363 6
  extern char *sys_errlist[];
  extern int sys_nerr;

  if (errnum >= 0 && errnum < sys_nerr)
    return sys_errlist[errnum];
  return (char *) "Unknown error";
d385 1
d427 9
d438 1
a438 1
      int opt = getopt_long (argc, argv, "i:d:e:s:hHrD", longopts, 0);
d456 1
a456 1
              fprintf (stderr, "%s: Specify the Info directory only once.\n",
d466 1
a466 1
              fprintf (stderr, "%s: Specify the Info directory only once.\n",
d494 1
a494 1
              fprintf (stderr, "%s: Specify the Info file only once.\n",
d521 2
a522 2
          puts (INSTALL_INFO_VERSION_STRING);
puts ("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d525 2
a526 2
For more information about these matters, see the files named COPYING.");
              exit (0);
d541 1
a541 1
        error ("excess command line argument `%s'", argv[optind]);
d545 1
a545 1
    fatal ("No input file specified");
d547 1
a547 1
    fatal ("No dir file specified");
d599 1
a599 1
                fatal ("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY");
d618 1
a618 1
                fatal ("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY");
d622 1
a622 1
        fatal ("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY");
d627 8
a634 1
      fatal ("no info dir entry in `%s'", infile);
d637 1
a645 1
    extern char *strrchr ();
d766 6
a771 6
                  && (p[infilelen_sans_info] == ')' || 
		      p[infilelen_sans_info] == '.' )) 
		{
		  dir_lines[i].delete = 1;
		  something_deleted = 1;
		}
d780 1
d782 2
d843 1
a843 1
                          fatal ("menu item `%s' already exists, for file `%s'",
d866 1
a866 1
    warning ("no entries found for `%s'; nothing deleted", infile);
a963 1

@


1.2
log
@added D to getopt() string
@
text
@d4 1
a4 1
$Id: install-info.c,v 1.1.1.1 1996/12/15 21:39:32 downsj Exp $
d736 6
a741 2
                  && p[infilelen_sans_info] == ')')
                dir_lines[i].delete = 1;
a749 1
        {
a750 2
          something_deleted = 1;
        }
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
$Id: install-info.c,v 1.12 1996/10/03 23:13:36 karl Exp $
d415 1
a415 1
      int opt = getopt_long (argc, argv, "i:d:e:s:hHr", longopts, 0);
@


1.1.1.1
log
@Import of texinfo-3.9.
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.14 1997/07/25 18:09:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97 Free Software Foundation, Inc.
d6 4
a9 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d11 4
a14 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d16 3
a18 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
d20 4
a23 1
#include "system.h"
d25 11
d42 1
d51 2
a53 1
/* Record info about a single line from a file as read into core.  */
a69 1

d72 1
d82 1
a83 1
/* This is used for a list of the entries specified to be added.  */
d89 2
a91 2

/* This is used for a list of nodes found by parsing the dir file.  */
a111 1

d114 1
d128 1
d136 1
a136 1
    fatal (_("virtual memory exhausted"), 0);
d140 2
a141 1
/* Like realloc but get fatal error if memory is exhausted.  */
d150 1
a150 1
    fatal (_("virtual memory exhausted"), 0);
d154 2
a155 2
/* Return a newly-allocated string
   whose contents concatenate those of S1, S2, S3.  */
d189 1
a189 1
/* Print error message.  S1 is printf control string, S2 and S3 args for it. */
d198 1
a198 1
  putc ('\n', stderr);
d206 1
a206 1
  fprintf (stderr, _("%s: warning: "), progname);
d208 1
a208 1
  putc ('\n', stderr);
d227 1
a227 1
  char *s = concat ("", strerror (errno), _(" for %s"));
d296 1
a296 1
  fprintf (stderr, _("\tTry `%s --help' for a complete list of options.\n"),
d304 1
a304 1
  printf (_("%s [OPTION]... [INFO-FILE [DIR-FILE]]\n\
d334 1
a334 1
"), progname);
d336 8
a343 6

/* If DIRFILE does not exist, create a minimal one (or abort).  If it
   already exists, do nothing.  */
void
ensure_dirfile_exists (dirfile)
     char *dirfile;
d345 6
a350 39
  int desc = open (dirfile, O_RDONLY);
  if (desc < 0 && errno == ENOENT)
    {
      FILE *f;
      char *readerr = strerror (errno);
      close (desc);
      f = fopen (dirfile, "w");
      if (f)
        {
          fputs (_("This is the file .../info/dir, which contains the\n\
topmost node of the Info hierarchy, called (dir)Top.\n\
The first time you invoke Info you start off looking at this node.\n\
\n\
File: dir       Node: Top       This is the top of the INFO tree\n\
\n\
  This (the Directory node) gives a menu of major topics.\n\
  Typing \"q\" exits, \"?\" lists all Info commands, \"d\" returns here,\n\
  \"h\" gives a primer for first-timers,\n\
  \"mEmacs<Return>\" visits the Emacs manual, etc.\n\
\n\
  In Emacs, you can click mouse button 2 on a menu item or cross reference\n\
  to select it.\n\
\n\
* Menu:\n\
"), f);
          if (fclose (f) < 0)
            pfatal_with_name (dirfile);
        }
      else
        {
          /* Didn't exist, but couldn't open for writing.  */
          fprintf (stderr,
                   _("%s: could not read (%s) and could not create (%s)\n"),
                   dirfile, readerr, strerror (errno));
          exit (1);
        }
    }
  else
    close (desc); /* It already existed, so fine.  */
a371 1
int
a412 9
#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d433 1
a433 1
              fprintf (stderr, _("%s: Specify the Info directory only once.\n"),
d443 1
a443 1
              fprintf (stderr, _("%s: Specify the Info directory only once.\n"),
d471 1
a471 1
              fprintf (stderr, _("%s: Specify the Info file only once.\n"),
d498 2
a499 2
          printf (_("install-info (GNU %s) %s\n"), PACKAGE, VERSION);
puts (_("Copyright (C) 1996 Free Software Foundation, Inc.\n\
d502 2
a503 2
For more information about these matters, see the files named COPYING."));
          exit (0);
d518 1
a518 1
        error (_("excess command line argument `%s'"), argv[optind]);
d522 1
a522 1
    fatal (_("No input file specified; try --help for more information."));
d524 1
a524 1
    fatal (_("No dir file specified; try --help for more information."));
d576 1
a576 1
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
d595 1
a595 1
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"));
d599 1
a599 1
        fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
d604 1
a604 8
      { /* No need to abort here, the original info file may not have
           the requisite Texinfo commands.  This is not something an
           installer should have to correct (it's a problem for the
           maintainer), and there's no need to cause subsequent parts of
           `make install' to fail.  */
        warning (_("no info dir entry in `%s'"), infile);
        exit (0);
      }
a606 1
  ensure_dirfile_exists (dirfile);
d615 1
d736 2
a737 6
                  && (p[infilelen_sans_info] == ')'
                      || !strncmp (p + infilelen_sans_info, ".info)", 6)))
                {
                  dir_lines[i].delete = 1;
                  something_deleted = 1;
                }
d809 1
a809 1
                          fatal (_("menu item `%s' already exists, for file `%s'"),
d832 1
a832 1
    warning (_("no entries found for `%s'; nothing deleted"), infile);
d930 1
@


1.1.1.3
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.21 1998/03/01 15:38:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98 Free Software Foundation, Inc.
a22 4
#ifdef HAVE_LIBZ
#include <zlib.h>
#endif

d286 2
a287 3
  printf (_("Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n\
\n\
Install INFO-FILE in the Info directory file DIR-FILE.\n\
d315 1
a315 1
Email bug reports to bug-texinfo@@gnu.org.\n\
a317 1

a320 1

d338 1
a338 1
File: dir,\tNode: Top,\tThis is the top of the INFO tree\n\
d371 11
a381 11
  { "delete",    no_argument, NULL, 'r' },
  { "dir-file",  required_argument, NULL, 'd' },
  { "entry",     required_argument, NULL, 'e' },
  { "help",      no_argument, NULL, 'h' },
  { "info-dir",  required_argument, NULL, 'D' },
  { "info-file", required_argument, NULL, 'i' },
  { "item",      required_argument, NULL, 'e' },
  { "quiet",     no_argument, NULL, 'q' },
  { "remove",    no_argument, NULL, 'r' },
  { "section",   required_argument, NULL, 's' },
  { "version",   no_argument, NULL, 'V' },
a383 1

d521 2
a522 2
          printf ("install-info (GNU %s) %s\n", PACKAGE, VERSION);
	  printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d525 1
a525 2
For more information about these matters, see the files named COPYING.\n"),
		  "1998");
a957 1
  int desc;
a961 4
#ifdef HAVE_LIBZ
  int isGZ = 0;
  gzFile zdesc;
#endif
d963 1
a963 1
  desc = open (filename, O_RDONLY);
a966 20
#ifdef HAVE_LIBZ
  /* The file should always be two bytes long.  */
  if (read (desc, data, 2) != 2)
    pfatal_with_name (filename);

  /* Undo that read.  */
  lseek (desc, 0, SEEK_SET);

  /* If we see gzip magic, use gzdopen. */
  if (data[0] == '\x1f' && data[1] == '\x8b')
    {
      isGZ = 1;
      zdesc = gzdopen (desc, "r");
      if (zdesc == NULL) {
        close (desc);
        pfatal_with_name (filename);
      }
    }
#endif /* HAVE_LIBZ */

d969 1
a969 7
#ifdef HAVE_LIBZ
      if (isGZ)
	nread = gzread (zdesc, data + filled, data_size - filled);
      else
#endif
        nread = read (desc, data + filled, data_size - filled);

a983 8

#ifdef HAVE_LIBZ
  if (isGZ)
    gzclose (zdesc);
  else
#endif
    close(desc);

@


1.1.1.4
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.48 1999/08/06 18:13:32 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.
d23 6
a28 1
static char *progname = "install-info";
d30 1
d32 1
d34 1
a34 1
int compare_section_names (), compare_entries_text ();
a75 7
  int text_len;
  /* A pointer to the list of sections to which this entry should be
     added.  */
  struct spec_section *entry_sections;
  /* A pointer to a section that is beyond the end of the chain whose
     head is pointed to by entry_sections.  */
  struct spec_section *entry_sections_tail;
a112 53
/* This table defines all the long-named options, says whether they
   use an argument, and maps them into equivalent single-letter options.  */

struct option longopts[] =
{
  { "delete",    no_argument, NULL, 'r' },
  { "dir-file",  required_argument, NULL, 'd' },
  { "entry",     required_argument, NULL, 'e' },
  { "help",      no_argument, NULL, 'h' },
  { "info-dir",  required_argument, NULL, 'D' },
  { "info-file", required_argument, NULL, 'i' },
  { "item",      required_argument, NULL, 'e' },
  { "quiet",     no_argument, NULL, 'q' },
  { "remove",    no_argument, NULL, 'r' },
  { "section",   required_argument, NULL, 's' },
  { "version",   no_argument, NULL, 'V' },
  { 0 }
};

/* Error message functions.  */

/* Print error message.  S1 is printf control string, S2 and S3 args for it. */

/* VARARGS1 */
void
error (s1, s2, s3)
     char *s1, *s2, *s3;
{
  fprintf (stderr, "%s: ", progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* VARARGS1 */
void
warning (s1, s2, s3)
     char *s1, *s2, *s3;
{
  fprintf (stderr, _("%s: warning: "), progname);
  fprintf (stderr, s1, s2, s3);
  putc ('\n', stderr);
}

/* Print error message and exit.  */

void
fatal (s1, s2, s3)
     char *s1, *s2, *s3;
{
  error (s1, s2, s3);
  xexit (1);
}

d172 34
a277 80



/* Return FNAME with any [.info][.gz] suffix removed.  */

static char *
strip_info_suffix (fname)
     char *fname;
{
  char *ret = xstrdup (fname);
  unsigned len = strlen (ret);

  if (len > 3 && FILENAME_CMP (ret + len - 3, ".gz") == 0)
    {
      len -= 3;
      ret[len] = 0;
    }

  if (len > 5 && FILENAME_CMP (ret + len - 5, ".info") == 0)
    {
      len -= 5;
      ret[len] = 0;
    }
  else if (len > 4 && FILENAME_CMP (ret + len - 4, ".inf") == 0)
    {
      len -= 4;
      ret[len] = 0;
    }
#ifdef __MSDOS__
  else if (len > 4 && (FILENAME_CMP (ret + len - 4, ".inz") == 0
                       || FILENAME_CMP (ret + len - 4, ".igz") == 0))
    {
      len -= 4;
      ret[len] = 0;
    }
#endif /* __MSDOS__ */

  return ret;
}


/* Return true if ITEM matches NAME and is followed by TERM_CHAR.  ITEM
   can also be followed by `.gz', `.info.gz', or `.info' (and then
   TERM_CHAR) and still match.  */

static int
menu_item_equal (item, term_char, name)
     char *item;
     char term_char;
     char *name;
{
  unsigned name_len = strlen (name);
  /* First, ITEM must actually match NAME (usually it won't).  */
  int ret = strncasecmp (item, name, name_len) == 0;
  if (ret)
    {
      /* Then, `foobar' doesn't match `foo', so be sure we've got all of
         ITEM.  The various suffixes should never actually appear in the
         dir file, but sometimes people put them in.  */
      static char *suffixes[]
        = { "", ".info.gz", ".info", ".inf", ".gz",
#ifdef __MSDOS__
            ".inz", ".igz",
#endif
            NULL };
      unsigned i;
      ret = 0;
      for (i = 0; !ret && suffixes[i]; i++)
        {
          char *suffix = suffixes[i];
          unsigned suffix_len = strlen (suffix);
          ret = strncasecmp (item + name_len, suffix, suffix_len) == 0
                && item[name_len + suffix_len] == term_char;
        }
    }

  return ret;
}


d284 1
a284 1
  xexit (1);
d292 1
a292 2
Install or delete dir entries from INFO-FILE in the Info directory file\n\
DIR-FILE.\n\
d295 24
a318 24
 --delete          delete existing entries for INFO-FILE from DIR-FILE;\n\
                     don't insert any new entries.\n\
 --dir-file=NAME   specify file name of Info directory file.\n\
                     This is equivalent to using the DIR-FILE argument.\n\
 --entry=TEXT      insert TEXT as an Info directory entry.\n\
                     TEXT should have the form of an Info menu item line\n\
                     plus zero or more extra lines starting with whitespace.\n\
                     If you specify more than one entry, they are all added.\n\
                     If you don't specify any entries, they are determined\n\
                     from information in the Info file itself.\n\
 --help            display this help and exit.\n\
 --info-file=FILE  specify Info file to install in the directory.\n\
                     This is equivalent to using the INFO-FILE argument.\n\
 --info-dir=DIR    same as --dir-file=DIR/dir.\n\
 --item=TEXT       same as --entry TEXT.\n\
                     An Info directory entry is actually a menu item.\n\
 --quiet           suppress warnings.\n\
 --remove          same as --delete.\n\
 --section=SEC     put this file's entries in section SEC of the directory.\n\
                     If you specify more than one section, all the entries\n\
                     are added in each of the sections.\n\
                     If you don't specify any sections, they are determined\n\
                     from information in the Info file itself.\n\
 --version         display version information and exit.\n\
d320 1
a320 2
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
d341 1
a341 1
          fprintf (f, _("This is the file .../info/dir, which contains the\n\
d345 1
a345 1
%s\tThis is the top of the INFO tree\n\
d356 1
a356 1
"), "File: dir,\tNode: Top"); /* This part must not be translated.  */
d366 1
a366 169
          xexit (1);
        }
    }
  else
    close (desc); /* It already existed, so fine.  */
}

/* Open FILENAME and return the resulting stream pointer.  If it doesn't
   exist, try FILENAME.gz.  If that doesn't exist either, call
   CREATE_CALLBACK (with FILENAME as arg) to create it, if that is
   non-NULL.  If still no luck, fatal error.

   If we do open it, return the actual name of the file opened in
   OPENED_FILENAME and the compress program to use to (de)compress it in
   COMPRESSION_PROGRAM.  The compression program is determined by the
   magic number, not the filename.  */

FILE *
open_possibly_compressed_file (filename, create_callback,
                               opened_filename, compression_program, is_pipe)
     char *filename;
     void (*create_callback) ();
     char **opened_filename;
     char **compression_program;
     int  *is_pipe;
{
  char *local_opened_filename, *local_compression_program;
  int nread;
  char data[4];
  FILE *f;

  /* We let them pass NULL if they don't want this info, but it's easier
     to always determine it.  */
  if (!opened_filename)
    opened_filename = &local_opened_filename;

  *opened_filename = filename;
  f = fopen (*opened_filename, FOPEN_RBIN);
  if (!f)
    {
      *opened_filename = concat (filename, ".gz", "");
      f = fopen (*opened_filename, FOPEN_RBIN);
#ifdef __MSDOS__
      if (!f)
        {
          free (*opened_filename);
          *opened_filename = concat (filename, ".igz", "");
          f = fopen (*opened_filename, FOPEN_RBIN);
        }
      if (!f)
        {
          free (*opened_filename);
          *opened_filename = concat (filename, ".inz", "");
          f = fopen (*opened_filename, FOPEN_RBIN);
        }
#endif
      if (!f)
        {
          if (create_callback)
            { /* That didn't work either.  Create the file if we can.  */
              (*create_callback) (filename);

              /* And try opening it again.  */
              free (*opened_filename);
              *opened_filename = filename;
              f = fopen (*opened_filename, FOPEN_RBIN);
              if (!f)
                pfatal_with_name (filename);
            }
          else
            pfatal_with_name (filename);
        }
    }

  /* Read first few bytes of file rather than relying on the filename.
     If the file is shorter than this it can't be usable anyway.  */
  nread = fread (data, sizeof (data), 1, f);
  if (nread != 1)
    {
      /* Empty files don't set errno, so we get something like
         "install-info: No error for foo", which is confusing.  */
      if (nread == 0)
        fatal (_("%s: empty file"), *opened_filename);
      pfatal_with_name (*opened_filename);
    }

  if (!compression_program)
    compression_program = &local_compression_program;

  if (data[0] == '\x1f' && data[1] == '\x8b')
#if STRIP_DOT_EXE
    /* An explicit .exe yields a better diagnostics from popen below
       if they don't have gzip installed.  */
    *compression_program = "gzip.exe";
#else
    *compression_program = "gzip";
#endif
  else
    *compression_program = NULL;

  if (*compression_program)
    { /* It's compressed, so fclose the file and then open a pipe.  */
      char *command = concat (*compression_program," -cd <", *opened_filename);
      if (fclose (f) < 0)
        pfatal_with_name (*opened_filename);
      f = popen (command, "r");
      if (f)
        *is_pipe = 1;
      else
        pfatal_with_name (command);
    }
  else
    { /* It's a plain file, seek back over the magic bytes.  */
      if (fseek (f, 0, 0) < 0)
        pfatal_with_name (*opened_filename);
#if O_BINARY
      /* Since this is a text file, and we opened it in binary mode,
         switch back to text mode.  */
      f = freopen (*opened_filename, "r", f);
#endif
      *is_pipe = 0;
    }

  return f;
}

/* Read all of file FILENAME into memory and return the address of the
   data.  Store the size of the data into SIZEP.  If need be, uncompress
   (i.e., try FILENAME.gz et al. if FILENAME does not exist) and store
   the actual file name that was opened into OPENED_FILENAME (if it is
   non-NULL), and the companion compression program (if any, else NULL)
   into COMPRESSION_PROGRAM (if that is non-NULL).  If trouble, do
   a fatal error.  */

char *
readfile (filename, sizep, create_callback,
          opened_filename, compression_program)
     char *filename;
     int *sizep;
     void (*create_callback) ();
     char **opened_filename;
     char **compression_program;
{
  char *real_name;
  FILE *f;
  int pipe_p;
  int filled = 0;
  int data_size = 8192;
  char *data = xmalloc (data_size);

  /* If they passed the space for the file name to return, use it.  */
  f = open_possibly_compressed_file (filename, create_callback,
                                     opened_filename ? opened_filename
                                                     : &real_name,
                                     compression_program, &pipe_p);

  for (;;)
    {
      int nread = fread (data + filled, 1, data_size - filled, f);
      if (nread < 0)
        pfatal_with_name (real_name);
      if (nread == 0)
        break;

      filled += nread;
      if (filled == data_size)
        {
          data_size += 65536;
          data = xrealloc (data, data_size);
d369 6
d376 15
a390 439
  /* We'll end up wasting space if we're not passing the filename back
     and it is not just FILENAME, but so what.  */
  /* We need to close the stream, since on some systems the pipe created
     by popen is simulated by a temporary file which only gets removed
     inside pclose.  */
  if (pipe_p)
    pclose (f);
  else
    fclose (f);

  *sizep = filled;
  return data;
}

/* Output the old dir file, interpolating the new sections
   and/or new entries where appropriate.  If COMPRESSION_PROGRAM is not
   null, pipe to it to create DIRFILE.  Thus if we read dir.gz on input,
   we'll write dir.gz on output.  */

static void
output_dirfile (dirfile, dir_nlines, dir_lines,
                n_entries_to_add, entries_to_add, input_sections,
                compression_program)
      char *dirfile;
      int dir_nlines;
      struct line_data *dir_lines;
      int n_entries_to_add;
      struct spec_entry *entries_to_add;
      struct spec_section *input_sections;
      char *compression_program;
{
  int i;
  FILE *output;

  if (compression_program)
    {
      char *command = concat (compression_program, ">", dirfile);
      output = popen (command, "w");
    }
  else
    output = fopen (dirfile, "w");

  if (!output)
    {
      perror (dirfile);
      xexit (1);
    }

  for (i = 0; i <= dir_nlines; i++)
    {
      int j;

      /* If we decided to output some new entries before this line,
         output them now.  */
      if (dir_lines[i].add_entries_before)
        for (j = 0; j < n_entries_to_add; j++)
          {
            struct spec_entry *this = dir_lines[i].add_entries_before[j];
            if (this == 0)
              break;
            fputs (this->text, output);
          }
      /* If we decided to add some sections here
         because there are no such sections in the file,
         output them now.  */
      if (dir_lines[i].add_sections_before)
        {
          struct spec_section *spec;
          struct spec_section **sections;
          int n_sections = 0;
          struct spec_entry *entry;
          struct spec_entry **entries;
          int n_entries = 0;

          /* Count the sections and allocate a vector for all of them.  */
          for (spec = input_sections; spec; spec = spec->next)
            n_sections++;
          sections = ((struct spec_section **)
                      xmalloc (n_sections * sizeof (struct spec_section *)));

          /* Fill the vector SECTIONS with pointers to all the sections,
             and sort them.  */
          j = 0;
          for (spec = input_sections; spec; spec = spec->next)
            sections[j++] = spec;
          qsort (sections, n_sections, sizeof (struct spec_section *),
                 compare_section_names);

          /* Count the entries and allocate a vector for all of them.  */
          for (entry = entries_to_add; entry; entry = entry->next)
            n_entries++;
          entries = ((struct spec_entry **)
                     xmalloc (n_entries * sizeof (struct spec_entry *)));

          /* Fill the vector ENTRIES with pointers to all the sections,
             and sort them.  */
          j = 0;
          for (entry = entries_to_add; entry; entry = entry->next)
            entries[j++] = entry;
          qsort (entries, n_entries, sizeof (struct spec_entry *),
                 compare_entries_text);

          /* Generate the new sections in alphabetical order.  In each
             new section, output all of the entries that belong to that
             section, in alphabetical order.  */
          for (j = 0; j < n_sections; j++)
            {
              spec = sections[j];
              if (spec->missing)
                {
                  int k;

                  putc ('\n', output);
                  fputs (spec->name, output);
                  putc ('\n', output);
                  for (k = 0; k < n_entries; k++)
                    {
                      struct spec_section *spec1;
                      /* Did they at all want this entry to be put into
                         this section?  */
                      entry = entries[k];
                      for (spec1 = entry->entry_sections;
                           spec1 && spec1 != entry->entry_sections_tail;
                           spec1 = spec1->next)
                        {
                          if (!strcmp (spec1->name, spec->name))
                            break;
                        }
                      if (spec1 && spec1 != entry->entry_sections_tail)
                        fputs (entry->text, output);
                    }
                }
            }

          free (entries);
          free (sections);
        }

      /* Output the original dir lines unless marked for deletion.  */
      if (i < dir_nlines && !dir_lines[i].delete)
        {
          fwrite (dir_lines[i].start, 1, dir_lines[i].size, output);
          putc ('\n', output);
        }
    }

  /* Some systems, such as MS-DOS, simulate pipes with temporary files.
     On those systems, the compressor actually gets run inside pclose,
     so we must call pclose.  */
  if (compression_program)
    pclose (output);
  else
    fclose (output);
}

/* Parse the input to find the section names and the entry names it
   specifies.  Return the number of entries to add from this file.  */
int
parse_input (lines, nlines, sections, entries)
     const struct line_data *lines;
     int nlines;
     struct spec_section **sections;
     struct spec_entry **entries;
{
  int n_entries = 0;
  int prefix_length = strlen ("INFO-DIR-SECTION ");
  struct spec_section *head = *sections, *tail = NULL;
  int reset_tail = 0;
  char *start_of_this_entry = 0;
  int ignore_sections = *sections != 0;
  int ignore_entries  = *entries  != 0;

  int i;

  if (ignore_sections && ignore_entries)
    return 0;

  /* Loop here processing lines from the input file.  Each
     INFO-DIR-SECTION entry is added to the SECTIONS linked list.
     Each START-INFO-DIR-ENTRY block is added to the ENTRIES linked
     list, and all its entries inherit the chain of SECTION entries
     defined by the last group of INFO-DIR-SECTION entries we have
     seen until that point.  */
  for (i = 0; i < nlines; i++)
    {
      if (!ignore_sections
          && !strncmp ("INFO-DIR-SECTION ", lines[i].start, prefix_length))
        {
          struct spec_section *next
            = (struct spec_section *) xmalloc (sizeof (struct spec_section));
          next->name = copy_string (lines[i].start + prefix_length,
                                    lines[i].size - prefix_length);
          next->next = *sections;
          next->missing = 1;
          if (reset_tail)
            {
              tail = *sections;
              reset_tail = 0;
            }
          *sections = next;
          head = *sections;
        }
      /* If entries were specified explicitly with command options,
         ignore the entries in the input file.  */
      else if (!ignore_entries)
        {
          if (!strncmp ("START-INFO-DIR-ENTRY", lines[i].start, lines[i].size)
              && sizeof ("START-INFO-DIR-ENTRY") - 1 == lines[i].size)
            {
              if (!*sections)
                {
                  /* We found an entry, but didn't yet see any sections
                     specified.  Default to section "Miscellaneous".  */
                  *sections = (struct spec_section *)
                    xmalloc (sizeof (struct spec_section));
                  (*sections)->name = "Miscellaneous";
                  (*sections)->next = 0;
                  (*sections)->missing = 1;
                  head = *sections;
                }
              /* Next time we see INFO-DIR-SECTION, we will reset the
                 tail pointer.  */
              reset_tail = 1;

              if (start_of_this_entry != 0)
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));
              start_of_this_entry = lines[i + 1].start;
            }
          else if (start_of_this_entry)
            {
              if ((!strncmp ("* ", lines[i].start, 2)
                   && lines[i].start > start_of_this_entry)
                  || (!strncmp ("END-INFO-DIR-ENTRY",
                                lines[i].start, lines[i].size)
                      && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size))
                {
                  /* We found an end of this entry.  Allocate another
                     entry, fill its data, and add it to the linked
                     list.  */
                  struct spec_entry *next
                    = (struct spec_entry *) xmalloc (sizeof (struct spec_entry));
                  next->text
                    = copy_string (start_of_this_entry,
                                   lines[i].start - start_of_this_entry);
                  next->text_len = lines[i].start - start_of_this_entry;
                  next->entry_sections = head;
                  next->entry_sections_tail = tail;
                  next->next = *entries;
                  *entries = next;
                  n_entries++;
                  if (!strncmp ("END-INFO-DIR-ENTRY",
                                lines[i].start, lines[i].size)
                      && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size)
                    start_of_this_entry = 0;
                  else
                    start_of_this_entry = lines[i].start;
                }
              else if (!strncmp ("END-INFO-DIR-ENTRY",
                                 lines[i].start, lines[i].size)
                       && sizeof ("END-INFO-DIR-ENTRY") - 1 == lines[i].size)
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"));
            }
        }
    }
  if (start_of_this_entry != 0)
    fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"));

  /* If we ignored the INFO-DIR-ENTRY directives, we need now go back
     and plug the names of all the sections we found into every
     element of the ENTRIES list.  */
  if (ignore_entries && *entries)
    {
      struct spec_entry *entry;

      for (entry = *entries; entry; entry = entry->next)
        {
          entry->entry_sections = head;
          entry->entry_sections_tail = tail;
        }
    }

  return n_entries;
}

/* Parse the dir file whose basename is BASE_NAME.  Find all the
   nodes, and their menus, and the sections of their menus.  */
int
parse_dir_file (lines, nlines, nodes, base_name)
     struct line_data *lines;
     int nlines;
     struct node **nodes;
     const char *base_name;
{
  int node_header_flag = 0;
  int something_deleted = 0;
  int i;

  *nodes = 0;
  for (i = 0; i < nlines; i++)
    {
      /* Parse node header lines.  */
      if (node_header_flag)
        {
          int j, end;
          for (j = 0; j < lines[i].size; j++)
            /* Find the node name and store it in the `struct node'.  */
            if (!strncmp ("Node:", lines[i].start + j, 5))
              {
                char *line = lines[i].start;
                /* Find the start of the node name.  */
                j += 5;
                while (line[j] == ' ' || line[j] == '\t')
                  j++;
                /* Find the end of the node name.  */
                end = j;
                while (line[end] != 0 && line[end] != ',' && line[end] != '\n'
                       && line[end] != '\t')
                  end++;
                (*nodes)->name = copy_string (line + j, end - j);
              }
          node_header_flag = 0;
        }

      /* Notice the start of a node.  */
      if (*lines[i].start == 037)
        {
          struct node *next = (struct node *) xmalloc (sizeof (struct node));

          next->next = *nodes;
          next->name = NULL;
          next->start_line = i;
          next->end_line = 0;
          next->menu_start = NULL;
          next->sections = NULL;
          next->last_section = NULL;

          if (*nodes != 0)
            (*nodes)->end_line = i;
          /* Fill in the end of the last menu section
             of the previous node.  */
          if (*nodes != 0 && (*nodes)->last_section != 0)
            (*nodes)->last_section->end_line = i;

          *nodes = next;

          /* The following line is the header of this node;
             parse it.  */
          node_header_flag = 1;
        }

      /* Notice the lines that start menus.  */
      if (*nodes != 0 && !strncmp ("* Menu:", lines[i].start, 7))
        (*nodes)->menu_start = lines[i + 1].start;

      /* Notice sections in menus.  */
      if (*nodes != 0
          && (*nodes)->menu_start != 0
          && *lines[i].start != '\n'
          && *lines[i].start != '*'
          && *lines[i].start != ' '
          && *lines[i].start != '\t')
        {
          /* Add this menu section to the node's list.
             This list grows in forward order.  */
          struct menu_section *next
            = (struct menu_section *) xmalloc (sizeof (struct menu_section));

          next->start_line = i + 1;
          next->next = 0;
          next->end_line = 0;
          next->name = copy_string (lines[i].start, lines[i].size);
          if ((*nodes)->sections)
            {
              (*nodes)->last_section->next = next;
              (*nodes)->last_section->end_line = i;
            }
          else
            (*nodes)->sections = next;
          (*nodes)->last_section = next;
        }

      /* Check for an existing entry that should be deleted.
         Delete all entries which specify this file name.  */
      if (*lines[i].start == '*')
        {
          char *q;
          char *p = lines[i].start;

          p++; /* skip * */
          while (*p == ' ') p++; /* ignore following spaces */
          q = p; /* remember this, it's the beginning of the menu item.  */

          /* Read menu item.  */
          while (*p != 0 && *p != ':')
            p++;
          p++; /* skip : */

          if (*p == ':')
            { /* XEmacs-style entry, as in * Mew::Messaging.  */
              if (menu_item_equal (q, ':', base_name))
                {
                  lines[i].delete = 1;
                  something_deleted = 1;
                }
            }
          else
            { /* Emacs-style entry, as in * Emacs: (emacs).  */
              while (*p == ' ') p++; /* skip spaces after : */
              if (*p == '(')         /* if at parenthesized (FILENAME) */
                {
                  p++;
                  if (menu_item_equal (p, ')', base_name))
                    {
                      lines[i].delete = 1;
                      something_deleted = 1;
                    }
                }
            }
        }

      /* Treat lines that start with whitespace
         as continuations; if we are deleting an entry,
         delete all its continuations as well.  */
      else if (i > 0 && (*lines[i].start == ' ' || *lines[i].start == '\t'))
        {
          lines[i].delete = lines[i - 1].delete;
        }
    }

  /* Finish the info about the end of the last node.  */
  if (*nodes != 0)
    {
      (*nodes)->end_line = nlines;
      if ((*nodes)->last_section != 0)
        (*nodes)->last_section->end_line = nlines;
    }

  return something_deleted;
}
d392 1
d398 1
a398 2
  char *opened_dirfilename;
  char *compression_program;
a399 1
  char *infile = 0, *dirfile = 0;
d401 1
d405 4
a408 4
  char *input_data = NULL;
  int input_size = 0;
  struct line_data *input_lines = NULL;
  int input_nlines = 0;
d429 2
d433 2
d485 2
a486 6
            int olen = strlen (optarg);
            if (! (*optarg != 0 && optarg[olen - 1] == '\n'))
              {
                optarg = concat (optarg, "\n", "");
                olen++;
              }
a487 3
            next->text_len = olen;
            next->entry_sections = NULL;
            next->entry_sections_tail = NULL;
d497 1
a497 1
          xexit (0);
a529 1
          puts ("");
d534 2
a535 2
		  "1999");
          xexit (0);
d558 28
a585 2
  /* Read the Info file and parse it into lines, unless we're deleting.  */
  if (!delete_flag)
d587 5
a591 2
      input_data = readfile (infile, &input_size, NULL, NULL, NULL);
      input_lines = findlines (input_data, input_size, &input_nlines);
d594 3
a596 4
  i = parse_input (input_lines, input_nlines,
                   &input_sections, &entries_to_add);
  if (i > n_entries_to_add)
    n_entries_to_add = i;
d598 1
a598 1
  if (!delete_flag)
d600 2
a601 20
      if (entries_to_add == 0)
        { /* No need to abort here, the original info file may not
             have the requisite Texinfo commands.  This is not
             something an installer should have to correct (it's a
             problem for the maintainer), and there's no need to cause
             subsequent parts of `make install' to fail.  */
          warning (_("no info dir entry in `%s'"), infile);
          xexit (0);
        }

      /* If the entries came from the command-line arguments, their
         entry_sections pointers are not yet set.  Walk the chain of
         the entries and for each entry update entry_sections to point
         to the head of the list of sections where this entry should
         be put.  Note that all the entries specified on the command
         line get put into ALL the sections we've got, either from the
         Info file, or (under --section) from the command line,
         because in the loop below every entry inherits the entire
         chain of sections.  */
      if (n_entries_to_add > 0 && entries_to_add->entry_sections == NULL)
d603 11
a613 4
          struct spec_entry *ep;

          /* If we got no sections, default to "Miscellaneous".  */
          if (input_sections == NULL)
d615 13
a627 5
              input_sections = (struct spec_section *)
                xmalloc (sizeof (struct spec_section));
              input_sections->name = "Miscellaneous";
              input_sections->next = NULL;
              input_sections->missing = 1;
a628 2
          for (ep = entries_to_add; ep; ep = ep->next)
            ep->entry_sections = input_sections;
d630 2
d634 11
d646 2
a647 2
  dir_data = readfile (dirfile, &dir_size, ensure_dirfile_exists,
                       &opened_dirfilename, &compression_program);
d651 2
a652 2
     current filename, so need to strip off any directory prefix and/or
     [.info][.gz] suffix.  */
d654 78
a731 1
    char *infile_basename = infile + strlen (infile);
d733 25
a757 2
    if (HAVE_DRIVE (infile))
      infile += 2;	/* get past the drive spec X: */
d759 5
a763 2
    while (infile_basename > infile && !IS_SLASH (infile_basename[-1]))
      infile_basename--;
d765 29
a793 3
    infile_sans_info = strip_info_suffix (infile_basename);
    infilelen_sans_info = strlen (infile_sans_info);
  }
d795 7
a801 2
  something_deleted
    = parse_dir_file (dir_lines, dir_nlines, &dir_nodes, infile_sans_info);
d836 1
a836 12
                    /* Did they at all want this entry to be put into
                       this section?  */
                    for (spec = entry->entry_sections;
                         spec && spec != entry->entry_sections_tail;
                         spec = spec->next)
                      {
                        if (!strcmp (spec->name, section->name))
                          break;
                      }
                    if (!spec || spec == entry->entry_sections_tail)
                      continue;
                    
d848 1
a848 1
                            && menu_line_equal (entry->text, entry->text_len,
d856 1
a856 1
                            && menu_line_lessp (entry->text, entry->text_len,
d877 154
a1030 2
  output_dirfile (opened_dirfilename, dir_nlines, dir_lines, n_entries_to_add,
                  entries_to_add, input_sections, compression_program);
d1032 1
a1032 1
  xexit (0);
d1045 2
a1046 3
  int i;
  int lineflag = 1;
  int lines_allocated = 511;
d1048 2
a1049 2
  struct line_data *lines
    = xmalloc ((lines_allocated + 1) * sizeof (struct line_data));
d1051 3
d1060 2
a1061 4
              /* try to keep things somewhat page-aligned */
              lines_allocated = ((lines_allocated + 1) * 2) - 1;
              lines = xrealloc (lines, (lines_allocated + 1)
                                       * sizeof (struct line_data));
d1101 1
a1101 1

d1134 1
a1134 1

a1161 25
/* This is the comparison function for qsort
   for a vector of pointers to struct spec_entry.
   Compare the entries' text.  */

int
compare_entries_text (entry1, entry2)
     struct spec_entry **entry1, **entry2;
{
  char *text1 = (*entry1)->text;
  char *text2 = (*entry2)->text;
  char *colon1 = strchr (text1, ':');
  char *colon2 = strchr (text2, ':');
  int len1, len2;

  if (!colon1)
    len1 = strlen (text1);
  else
    len1 = colon1 - text1;
  if (!colon2)
    len2 = strlen (text2);
  else
    len2 = colon2 - text2;
  return strncmp (text1, text2, len1 <= len2 ? len1 : len2);
}

d1174 1
a1174 1
  int i, j;
a1183 3
  /* Find the place where this entry belongs.  If there are already
     several entries to add before LINE_NUMBER, make sure they are in
     alphabetical order.  */
d1185 1
a1185 4
    if (dir_lines[line_number].add_entries_before[i] == 0
        || menu_line_lessp (entry->text, strlen (entry->text),
                            dir_lines[line_number].add_entries_before[i]->text,
                            strlen (dir_lines[line_number].add_entries_before[i]->text)))
a1189 8

  /* If we need to plug ENTRY into the middle of the
     ADD_ENTRIES_BEFORE array, move the entries which should be output
     after this one down one notch, before adding a new one.  */
  if (dir_lines[line_number].add_entries_before[i] != 0)
    for (j = n_entries - 1; j > i; j--)
      dir_lines[line_number].add_entries_before[j]
        = dir_lines[line_number].add_entries_before[j - 1];
@


1.1.1.5
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.55 2002/03/11 19:55:23 karl Exp $
d4 1
a4 1
   Copyright (C) 1996, 97, 98, 99, 2000, 01, 02 Free Software Foundation, Inc.
d176 1
a176 1
    fatal (_("virtual memory exhausted"), 0, 0);
d189 1
a189 1
    fatal (_("virtual memory exhausted"), 0, 0);
d233 1
a233 1
  fatal (s, name, 0);
d419 1
a419 3
"), progname);

  puts (_("\n\
d422 1
a422 1
Texinfo home page: http://www.gnu.org/software/texinfo/"));
d549 1
a549 1
        fatal (_("%s: empty file"), *opened_filename, 0);
d864 1
a864 1
                fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"), 0, 0);
d899 1
a899 1
                fatal (_("END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"), 0, 0);
d904 1
a904 2
    fatal (_("START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"),
	   0, 0);
d1225 1
a1225 1
		  "2002");
d1241 1
a1241 1
        error (_("excess command line argument `%s'"), argv[optind], 0);
d1245 1
a1245 2
    fatal (_("No input file specified; try --help for more information."),
	   0, 0);
d1247 1
a1247 1
    fatal (_("No dir file specified; try --help for more information."), 0, 0);
d1269 1
a1269 1
          warning (_("no info dir entry in `%s'"), infile, 0);
d1407 1
a1407 1
    warning (_("no entries found for `%s'; nothing deleted"), infile, 0);
@


1.1.1.6
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: install-info.c,v 1.12 2004/04/11 17:56:47 karl Exp $
d4 1
a4 2
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d25 4
a29 7
struct spec_section;

struct line_data *findlines (char *data, int size, int *nlinesp);
void insert_entry_here (struct spec_entry *entry, int line_number,
                        struct line_data *dir_lines, int n_entries); 
int compare_section_names (const void *s1, const void *s2);
int compare_entries_text (const void *e1, const void *e2); 
a121 1
  { "infodir",   required_argument, NULL, 'D' },
d138 2
a139 1
error (const char *s1, const char *s2, const char *s3)
d148 2
a149 1
warning (const char *s1, const char *s2, const char *s3)
d159 2
a160 1
fatal (const char *s1, const char *s2, const char *s3)
d166 27
d196 2
a197 1
concat (const char *s1, const char *s2, const char *s3)
d214 3
a216 1
copy_string (const char *string, int size)
d229 2
a230 1
pfatal_with_name (const char *name)
a235 54
/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item name
   in LINE1 is less, 0 otherwise.  */

static int
menu_line_lessp (char *line1, int len1, char *line2, int len2)
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If one item name is a prefix of the other,
         the former one is less.  */
      if (line1[i] == ':' && line2[i] != ':')
        return 1;
      if (line2[i] == ':' && line1[i] != ':')
        return 0;
      /* If they both continue and differ, one is less.  */
      if (line1[i] < line2[i])
        return 1;
      if (line1[i] > line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 0;
}

/* Compare the menu item names in LINE1 (line length LEN1)
   and LINE2 (line length LEN2).  Return 1 if the item names are equal,
   0 otherwise.  */

static int
menu_line_equal (char *line1, int len1, char *line2, int len2)
{
  int minlen = (len1 < len2 ? len1 : len2);
  int i;

  for (i = 0; i < minlen; i++)
    {
      /* If both item names end here, they are equal.  */
      if (line1[i] == ':' && line2[i] == ':')
        return 1;
      /* If they both continue and differ, one is less.  */
      if (line1[i] != line2[i])
        return 0;
    }
  /* With a properly formatted dir file,
     we can only get here if the item names are equal.  */
  return 1;
}


d240 2
a241 1
extract_menu_item_name (char *item_text)
d259 2
a260 1
extract_menu_file_name (char *item_text)
d303 2
a304 1
strip_info_suffix (char *fname)
a313 5
  else if (len > 4 && FILENAME_CMP (ret + len - 4, ".bz2") == 0)
    {
      len -= 4;
      ret[len] = 0;
    }
d343 4
a346 1
menu_item_equal (const char *item, char term_char, const char *name)
a347 2
  int ret;
  const char *item_basename = item;
a348 19

  /* We must compare the basename in ITEM, since we are passed the
     basename of the original info file.  Otherwise, a new entry like
     "lilypond/lilypond" won't match "lilypond".
     
     Actually, it seems to me that we should really compare the whole
     name, and not just the basename.  Couldn't there be dir1/foo.info
     and dir2/foo.info?  Also, it seems like we should be using the
     filename from the new dir entries, not the filename on the command
     line.  Not worrying about those things right now, though.  --karl,
     26mar04.  */
  while (*item_basename && !IS_SLASH (*item_basename)
	 && *item_basename != term_char)
    item_basename++;
  if (! *item_basename || *item_basename == term_char)
    item_basename = item;  /* no /, use original */
  else
    item_basename++;       /* have /, move past it */
    
d350 1
a350 1
  ret = strncasecmp (item_basename, name, name_len) == 0;
d368 2
a369 2
          ret = strncasecmp (item_basename + name_len, suffix, suffix_len) == 0
                && item_basename[name_len + suffix_len] == term_char;
d379 1
a379 1
suggest_asking_for_help (void)
d387 1
a387 1
print_help (void)
d432 2
a433 1
ensure_dirfile_exists (char *dirfile)
d447 1
a447 1
\x1f\n\
d458 2
a459 4
%s\n\
"), "File: dir,\tNode: Top",  /* These keywords must not be translated.  */
    "* Menu:"
);
d487 7
a493 3
open_possibly_compressed_file (char *filename,
    void (*create_callback) (char *),
    char **opened_filename, char **compression_program, int *is_pipe) 
a510 7
  if (!f)
    {
      free (*opened_filename);
      *opened_filename = concat (filename, ".bz2", "");
      f = fopen (*opened_filename, FOPEN_RBIN);
    }

a565 12
  else if(data[0] == 'B' && data[1] == 'Z' && data[2] == 'h')
#ifndef STRIP_DOT_EXE
    *compression_program = "bzip2.exe";
#else
    *compression_program = "bzip2";
#endif
  else if(data[0] == 'B' && data[1] == 'Z' && data[2] == '0')
#ifndef STRIP_DOT_EXE
    *compression_program = "bzip.exe";
#else
    *compression_program = "bzip";
#endif
d604 7
a610 3
readfile (char *filename, int *sizep,
    void (*create_callback) (char *), char **opened_filename,
    char **compression_program)
d661 10
a670 3
output_dirfile (char *dirfile, int dir_nlines, struct line_data *dir_lines,
                int n_entries_to_add, struct spec_entry *entries_to_add,
                struct spec_section *input_sections, char *compression_program)
d799 5
a803 2
parse_input (const struct line_data *lines, int nlines,
             struct spec_section **sections, struct spec_entry **entries) 
d907 1
a907 1
           0, 0);
d929 5
a933 2
parse_dir_file (struct line_data *lines, int nlines, struct node **nodes,
                const char *base_name)
d1083 3
a1085 1
main (int argc, char **argv)
d1091 1
d1150 2
a1151 2
              fprintf (stderr, _("%s: already have dir file: %s\n"),
                       progname, dirfile);
d1160 2
a1161 2
              fprintf (stderr, _("%s: already have dir file: %s\n"),
                       progname, dirfile);
d1224 2
a1225 2
          puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
          printf (_("There is NO warranty.  You may redistribute this software\n\
d1227 2
a1228 1
For more information about these matters, see the files named COPYING.\n"));
d1249 1
a1249 1
           0, 0);
d1316 1
a1316 1
      infile += 2;      /* get past the drive spec X: */
d1322 1
d1332 1
d1372 1
a1372 1

a1416 1
  return 0; /* Avoid bogus warnings.  */
d1424 4
a1427 1
findlines (char *data, int size, int *nlinesp)
d1472 63
a1534 3
/* This is the comparison function for qsort for a vector of pointers to
   struct spec_section.  (Have to use const void * as the parameter type
   to avoid incompatible-with-qsort warnings.)
d1538 2
a1539 1
compare_section_names (const void *p1, const void *p2)
a1540 2
  struct spec_section **sec1 = (struct spec_section **) p1;
  struct spec_section **sec2 = (struct spec_section **) p2;
d1551 2
a1552 1
compare_entries_text (const void *p1, const void *p2)
a1553 2
  struct spec_entry **entry1 = (struct spec_entry **) p1;
  struct spec_entry **entry2 = (struct spec_entry **) p2;
d1577 5
a1581 2
insert_entry_here (struct spec_entry *entry, int line_number,
                   struct line_data *dir_lines, int n_entries)
@


