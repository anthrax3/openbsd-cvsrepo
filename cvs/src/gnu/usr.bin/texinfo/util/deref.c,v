head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.72
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.68
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.64
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.66
	OPENBSD_5_8_BASE:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.58
	OPENBSD_5_7_BASE:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.62
	OPENBSD_5_6_BASE:1.1.1.2
	OPENBSD_5_5:1.1.1.2.0.60
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.56
	OPENBSD_5_4_BASE:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.54
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.52
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.50
	OPENBSD_5_0:1.1.1.2.0.48
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.46
	OPENBSD_4_9_BASE:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.44
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.40
	OPENBSD_4_7_BASE:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.42
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.38
	OPENBSD_4_5_BASE:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.36
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.34
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.32
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.30
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.28
	OPENBSD_4_0_BASE:1.1.1.2
	TEXINFO_4_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.26
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.24
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.22
	OPENBSD_3_7_BASE:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.20
	OPENBSD_3_6_BASE:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.18
	OPENBSD_3_5_BASE:1.1.1.2
	OPENBSD_3_4:1.1.1.2.0.16
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.14
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	TEXINFO_4_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	TEXINFO_3_12:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	TEXINFO_3_11:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.22.16.47.17;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.17;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.09.01.26.22;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/*
 * deref.c

 *  compile command:  gcc -g -o deref deref.c

 *  execute command:  deref filename.texi > newfile.texi

 * To: bob@@gnu.ai.mit.edu
 * Subject: another tool
 * Date: 18 Dec 91 16:03:13 EST (Wed)
 * From: gatech!skeeve!arnold@@eddie.mit.edu (Arnold D. Robbins)
 *
 * Here is deref.c.  It turns texinfo cross references back into the
 * one argument form. It has the same limitations as fixref; one xref per
 * line and can't cross lines.  You can use it to find references that do
 * cross a line boundary this way:
 *
 * 	deref < manual > /dev/null 2>errs
 *
 * (This assumes bash or /bin/sh.)  The file errs will have list of lines
 * where deref could not find matching braces.
 *
 * A gawk manual processed by deref goes through makeinfo without complaint.
 * Compile with gcc and you should be set.
 *
 * Enjoy,
 *
 * Arnold
 * -----------
 */

/*
 * deref.c
 *
 * Make all texinfo references into the one argument form.
 *
 * Arnold Robbins
 * arnold@@skeeve.atl.ga.us
 * December, 1991
 *
 * Copyright, 1991, Arnold Robbins
 */

/*
 * LIMITATIONS:
 *	One texinfo cross reference per line.
 *	Cross references may not cross newlines.
 *	Use of fgets for input (to be fixed).
 */

#include <stdio.h>
#include <ctype.h>
#include <errno.h>

/* for gcc on the 3B1, delete if this gives you grief */
extern int fclose (FILE * fp);
extern int fprintf (FILE * fp, const char *str,...);

extern char *strerror (int errno);
extern char *strchr (char *cp, int ch);
extern int strncmp (const char *s1, const char *s2, int count);

extern int errno;

void process (FILE * fp);
void repair (char *line, char *ref, int toffset);

int Errs = 0;
char *Name = "stdin";
int Line = 0;
char *Me;

/* main --- handle arguments, global vars for errors */

int
main (int argc, char **argv)
{
  FILE *fp;

  Me = argv[0];

  if (argc == 1)
    process (stdin);
  else
    for (argc--, argv++; *argv != NULL; argc--, argv++)
      {
	if (argv[0][0] == '-' && argv[0][1] == '\0')
	  {
	    Name = "stdin";
	    Line = 0;
	    process (stdin);
	  }
	else if ((fp = fopen (*argv, "r")) != NULL)
	  {
	    Name = *argv;
	    Line = 0;
	    process (fp);
	    fclose (fp);
	  }
	else
	  {
	    fprintf (stderr, "%s: can not open: %s\n",
		     *argv, strerror (errno));
	    Errs++;
	  }
      }
  return Errs != 0;
}

/* isref --- decide if we've seen a texinfo cross reference */

int
isref (char *cp)
{
  if (strncmp (cp, "@@ref{", 5) == 0)
    return 5;
  if (strncmp (cp, "@@xref{", 6) == 0)
    return 6;
  if (strncmp (cp, "@@pxref{", 7) == 0)
    return 7;
  return 0;
}

/* process --- read files, look for references, fix them up */

void
process (FILE * fp)
{
  char buf[BUFSIZ];
  char *cp;
  int count;

  while (fgets (buf, sizeof buf, fp) != NULL)
    {
      Line++;
      cp = strchr (buf, '@@');
      if (cp == NULL)
	{
	  fputs (buf, stdout);
	  continue;
	}
      do
	{
	  count = isref (cp);
	  if (count == 0)
	    {
	      cp++;
	      cp = strchr (cp, '@@');
	      if (cp == NULL)
		{
		  fputs (buf, stdout);
		  goto next;
		}
	      continue;
	    }
	  /* got one */
	  repair (buf, cp, count);
	  break;
	}
      while (cp != NULL);
    next:;
    }
}

/* repair --- turn all texinfo cross references into the one argument form */

void
repair (char *line, char *ref, int toffset)
{
  int braces = 1;		/* have seen first left brace */
  char *cp;

  ref += toffset;

  /* output line up to and including left brace in reference */
  for (cp = line; cp <= ref; cp++)
    putchar (*cp);

  /* output node name */
  for (; *cp && *cp != '}' && *cp != ',' && *cp != '\n'; cp++)
    putchar (*cp);

  if (*cp != '}')
    {				/* could have been one arg xref */
      /* skip to matching right brace */
      for (; braces > 0; cp++)
	{
	  switch (*cp)
	    {
	    case '@@':
	      cp++;		/* blindly skip next character */
	      break;
	    case '{':
	      braces++;
	      break;
	    case '}':
	      braces--;
	      break;
	    case '\n':
	    case '\0':
	      Errs++;
	      fprintf (stderr,
		       "%s: %s: %d: mismatched braces\n",
		       Me, Name, Line);
	      goto out;
	    default:
	      break;
	    }
	}
    out:
      ;
    }

  putchar ('}');
  if (*cp == '}')
    cp++;

  /* now the rest of the line */
  for (; *cp; cp++)
    putchar (*cp);
  return;
}

/* strerror --- return error string, delete if in your library */

char *
strerror (int errno)
{
  static char buf[100];
  extern int sys_nerr;
  extern char *sys_errlist[];

  if (errno < sys_nerr && errno >= 0)
    return sys_errlist[errno];

  sprintf (buf, "unknown error %d", errno);
  return buf;
}
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d3 31
d36 1
a36 1
 * 
d38 4
a41 19
 * arnold@@gnu.org
 * Written: December, 1991
 * Released: November, 1998
 *
 * Copyright, 1991, 1998 Arnold David Robbins
 *
 * DEREF is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * DEREF is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
d56 6
a61 8
extern int fclose(FILE *fp);
extern int fprintf(FILE *fp, const char *str, ...);
/* extern int sprintf(char *str, const char *fmt, ...); */
extern int fputs(char *buf, FILE *fp);

extern char *strerror(int errno);
extern char *strchr(char *cp, int ch);
extern int strncmp(const char *s1, const char *s2, int count);
d65 2
a66 2
void process(FILE *fp);
void repair(char *line, char *ref, int toffset);
d76 1
a76 1
main(int argc, char **argv)
d78 1
a78 1
	FILE *fp;
d80 1
a80 1
	Me = argv[0];
d82 18
a99 2
	if (argc == 1)
		process(stdin);
d101 7
a107 17
		for (argc--, argv++; *argv != NULL; argc--, argv++) {
			if (argv[0][0] == '-' && argv[0][1] == '\0') {
				Name = "stdin";
				Line = 0;
				process(stdin);
			} else if ((fp = fopen(*argv, "r")) != NULL) {
				Name = *argv;
				Line = 0;
				process(fp);
				fclose(fp);
			} else {
				fprintf(stderr, "%s: can not open: %s\n",
					*argv, strerror(errno));
				Errs++;
			}
		}
	return Errs != 0;
d113 1
a113 1
isref(char *cp)
d115 7
a121 7
	if (strncmp(cp, "@@ref{", 5) == 0)
		return 5;
	if (strncmp(cp, "@@xref{", 6) == 0)
		return 6;
	if (strncmp(cp, "@@pxref{", 7) == 0)
		return 7;
	return 0;
d127 1
a127 1
process(FILE *fp)
d129 24
a152 10
	char buf[BUFSIZ];
	char *cp;
	int count;

	while (fgets(buf, sizeof buf, fp) != NULL) {
		Line++;
		cp = strchr(buf, '@@');
		if (cp == NULL) {
			fputs(buf, stdout);
			continue;
d154 5
a158 16
		do {
			count = isref(cp);
			if (count == 0) {
				cp++;
				cp = strchr(cp, '@@');
				if (cp == NULL) {
					fputs(buf, stdout);
					goto next;
				}
				continue;
			}
			/* got one */
			repair(buf, cp, count);
			break;
		} while (cp != NULL);
	next: ;
d160 3
d168 1
a168 1
repair(char *line, char *ref, int toffset)
d170 2
a171 2
	int braces = 1;		/* have seen first left brace */
	char *cp;
d173 1
a173 1
	ref += toffset;
d175 34
a208 34
	/* output line up to and including left brace in reference */
	for (cp = line; cp <= ref; cp++)
		putchar(*cp);

	/* output node name */
	for (; *cp && *cp != '}' && *cp != ',' && *cp != '\n'; cp++)
		putchar(*cp);

	if (*cp != '}')	{	/* could have been one arg xref */
		/* skip to matching right brace */
		for (; braces > 0; cp++) {
			switch (*cp) {
			case '@@':
				cp++;	/* blindly skip next character */
				break;
			case '{':
				braces++;
				break;
			case '}':
				braces--;
				break;
			case '\n':
			case '\0':
				Errs++;
				fprintf(stderr,
					"%s: %s: %d: mismatched braces\n",
					Me, Name, Line);
				goto out;
			default:
				break;
			}
		}
	out:
		;
d210 12
a221 9

	putchar('}');
	if (*cp == '}')
		cp++;

	/* now the rest of the line */
	for (; *cp; cp++)
		putchar(*cp);
	return;
d227 1
a227 1
strerror(int errno)
d229 3
a231 3
	static char buf[100];
	extern int sys_nerr;
	extern char *sys_errlist[];
d233 2
a234 2
	if (errno < sys_nerr && errno >= 0)
		return sys_errlist[errno];
d236 2
a237 2
	sprintf(buf, "unknown error %d", errno);
	return buf;
@

