head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.62
	OPENBSD_6_2_BASE:1.2
	OPENBSD_6_1:1.2.0.60
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.56
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.52
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.54
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.46
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.50
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.48
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.44
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.42
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.40
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.38
	OPENBSD_5_0:1.2.0.36
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.34
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.32
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.28
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.30
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.26
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.24
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.22
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.20
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.18
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.16
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.14
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.12
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.10
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.1.2.0.2
	OPENBSD_3_2_BASE:1.1.1.2
	TEXINFO_4_2:1.1.1.2
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	TEXINFO_4_0:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2003.01.04.22.36.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.09.01.27.24;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.02.09.01.27.24;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.06.10.13.21.49;	author espie;	state Exp;
branches;
next	;


desc
@@


1.2
log
@spelling
@
text
@#!/usr/local/bin/perl -w

# Generate a short man page from --help and --version output.
# Copyright © 1997, 1998, 1999, 2000 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

# Written by Brendan O'Dea <bod@@compusol.com.au>
# Available from ftp://ftp.gnu.org/gnu/help2man/

use 5.004;
use strict;
use Getopt::Long;
use Text::Tabs qw(expand);
use POSIX qw(strftime setlocale LC_TIME);

my $this_program = 'help2man';
my $this_version = '1.24';
my $version_info = <<EOT;
GNU $this_program $this_version

Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

Written by Brendan O'Dea <bod\@@compusol.com.au>
EOT

my $help_info = <<EOT;
`$this_program' generates a man page out of `--help' and `--version' output.

Usage: $this_program [OPTION]... EXECUTABLE

 -n, --name=STRING       use `STRING' as the description for the NAME paragraph
 -s, --section=SECTION   use `SECTION' as the section for the man page
 -i, --include=FILE      include material from `FILE'
 -I, --opt-include=FILE  include material from `FILE' if it exists
 -o, --output=FILE       send output to `FILE'
 -N, --no-info           suppress pointer to Texinfo manual
     --help              print this help, then exit
     --version           print version number, then exit

EXECUTABLE should accept `--help' and `--version' options.

Report bugs to <bug-help2man\@@gnu.org>.
EOT

my $section = 1;
my ($opt_name, @@opt_include, $opt_output, $opt_no_info);
my %opt_def = (
    'n|name=s'		=> \$opt_name,
    's|section=s'	=> \$section,
    'i|include=s'	=> sub { push @@opt_include, [ pop, 1 ] },
    'I|opt-include=s'	=> sub { push @@opt_include, [ pop, 0 ] },
    'o|output=s'	=> \$opt_output,
    'N|no-info'		=> \$opt_no_info,
);

# Parse options.
Getopt::Long::config('bundling');
GetOptions (%opt_def,
    help    => sub { print $help_info; exit },
    version => sub { print $version_info; exit },
) or die $help_info;

die $help_info unless @@ARGV == 1;

my %include = ();
my %append = ();
my @@include = (); # retain order given in include file

# Provide replacement `quote-regex' operator for pre-5.005.
BEGIN { eval q(sub qr { '' =~ $_[0]; $_[0] }) if $] < 5.005 }

# Process include file (if given).  Format is:
#
#   [section name]
#   verbatim text
#
# or
#
#   /pattern/
#   verbatim text
#

while (@@opt_include)
{
    my ($inc, $required) = @@{shift @@opt_include};

    next unless -f $inc or $required;
    die "$this_program: can't open `$inc' ($!)\n"
	unless open INC, $inc;

    my $key;
    my $hash = \%include;

    while (<INC>)
    {
	# [section]
	if (/^\[([^]]+)\]/)
	{
	    $key = uc $1;
	    $key =~ s/^\s+//;
	    $key =~ s/\s+$//;
	    $hash = \%include;
	    push @@include, $key unless $include{$key};
	    next;
	}

	# /pattern/
	if (m!^/(.*)/([ims]*)!)
	{
	    my $pat = $2 ? "(?$2)$1" : $1;

	    # Check pattern.
	    eval { $key = qr($pat) };
	    if ($@@)
	    {
		$@@ =~ s/ at .*? line \d.*//;
		die "$inc:$.:$@@";
	    }

	    $hash = \%append;
	    next;
	}

	# Check for options before the first section--anything else is
	# silently ignored, allowing the first for comments and
	# revision info.
	unless ($key)
	{
	    # handle options
	    if (/^-/)
	    {
		local @@ARGV = split;
		GetOptions %opt_def;
	    }

	    next;
	}

	$hash->{$key} ||= '';
	$hash->{$key} .= $_;
    }

    close INC;

    die "$this_program: no valid information found in `$inc'\n"
	unless $key;
}

# Compress trailing blank lines.
for my $hash (\(%include, %append))
{
    for (keys %$hash) { $hash->{$_} =~ s/\n+$/\n/ }
}

# Turn off localisation of executable's output.
@@ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;

# Turn off localisation of date (for strftime).
setlocale LC_TIME, 'C';

# Grab help and version info from executable.
my ($help_text, $version_text) = map {
    join '', map { s/ +$//; expand $_ } `$ARGV[0] --$_ 2>/dev/null`
	or die "$this_program: can't get `--$_' info from $ARGV[0]\n"
} qw(help version);

my $date = strftime "%B %Y", localtime;
(my $program = $ARGV[0]) =~ s!.*/!!;
my $package = $program;
my $version;

if ($opt_output)
{
    unlink $opt_output
	or die "$this_program: can't unlink $opt_output ($!)\n"
	if -e $opt_output;

    open STDOUT, ">$opt_output"
	or die "$this_program: can't create $opt_output ($!)\n";
}

# The first line of the --version information is assumed to be in one
# of the following formats:
#
#   <version>
#   <program> <version>
#   {GNU,Free} <program> <version>
#   <program> ({GNU,Free} <package>) <version>
#   <program> - {GNU,Free} <package> <version>
#
# and seperated from any copyright/author details by a blank line.

($_, $version_text) = split /\n+/, $version_text, 2;

if (/^(\S+) +\(((?:GNU|Free) +[^)]+)\) +(.*)/ or
    /^(\S+) +- *((?:GNU|Free) +\S+) +(.*)/)
{
    $program = $1;
    $package = $2;
    $version = $3;
}
elsif (/^((?:GNU|Free) +)?(\S+) +(.*)/)
{
    $program = $2;
    $package = $1 ? "$1$2" : $2;
    $version = $3;
}
else
{
    $version = $_;
}

$program =~ s!.*/!!;

# No info for `info' itself.
$opt_no_info = 1 if $program eq 'info';

# --name overrides --include contents.
$include{NAME} = "$program \\- $opt_name\n" if $opt_name;

# Default (useless) NAME paragraph.
$include{NAME} ||= "$program \\- manual page for $program $version\n";

# Man pages traditionally have the page title in caps.
my $PROGRAM = uc $program;

# Extract usage clause(s) [if any] for SYNOPSIS.
if ($help_text =~ s/^Usage:( +(\S+))(.*)((?:\n(?: {6}\1| *or: +\S).*)*)//m)
{
    my @@syn = $2 . $3;

    if ($_ = $4)
    {
	s/^\n//;
	for (split /\n/) { s/^ *(or: +)?//; push @@syn, $_ }
    }

    my $synopsis = '';
    for (@@syn)
    {
	$synopsis .= ".br\n" if $synopsis;
	s!^\S*/!!;
	s/^(\S+) *//;
	$synopsis .= ".B $1\n";
	s/\s+$//;
	s/(([][]|\.\.+)+)/\\fR$1\\fI/g;
	s/^/\\fI/ unless s/^\\fR//;
	$_ .= '\fR';
	s/(\\fI)( *)/$2$1/g;
	s/\\fI\\fR//g;
	s/^\\fR//;
	s/\\fI$//;
	s/^\./\\&./;

	$synopsis .= "$_\n";
    }

    $include{SYNOPSIS} ||= $synopsis;
}

# Process text, initial section is DESCRIPTION.
my $sect = 'DESCRIPTION';
$_ = "$help_text\n\n$version_text";

# Normalise paragraph breaks.
s/^\n+//;
s/\n*$/\n/;
s/\n\n+/\n\n/g;

# Temporarily exchange leading dots, apostrophes and backslashes for
# tokens.
s/^\./\x80/mg;
s/^'/\x81/mg;
s/\\/\x82/g;

# Start a new paragraph (if required) for these.
s/([^\n])\n(Report +bugs|Email +bug +reports +to|Written +by)/$1\n\n$2/g;

sub convert_option;

while (length)
{
    # Convert some standard paragraph names.
    if (s/^(Options|Examples): *\n//)
    {
	$sect = uc $1;
	next;
    }

    # Copyright section
    if (/^Copyright +[(\xa9]/)
    {
	$sect = 'COPYRIGHT';
	$include{$sect} ||= '';
	$include{$sect} .= ".PP\n" if $include{$sect};

	my $copy;
	($copy, $_) = split /\n\n/, $_, 2;

	for ($copy)
	{
	    # Add back newline
	    s/\n*$/\n/;

	    # Convert iso9959-1 copyright symbol or (c) to nroff
	    # character.
	    s/^Copyright +(?:\xa9|\([Cc]\))/Copyright \\(co/mg;

	    # Insert line breaks before additional copyright messages
	    # and the disclaimer.
	    s/(.)\n(Copyright |This +is +free +software)/$1\n.br\n$2/g;

	    # Join hyphenated lines.
	    s/([A-Za-z])-\n */$1/g;
	}

	$include{$sect} .= $copy;
	$_ ||= '';
	next;
    }

    # Catch bug report text.
    if (/^(Report +bugs|Email +bug +reports +to) /)
    {
	$sect = 'REPORTING BUGS';
    }

    # Author section.
    elsif (/^Written +by/)
    {
	$sect = 'AUTHOR';
    }

    # Examples, indicated by an indented leading $, % or > are
    # rendered in a constant width font.
    if (/^( +)([\$\%>] )\S/)
    {
	my $indent = $1;
	my $prefix = $2;
	my $break = '.IP';
	$include{$sect} ||= '';
	while (s/^$indent\Q$prefix\E(\S.*)\n*//)
	{
	    $include{$sect} .= "$break\n\\f(CW$prefix$1\\fR\n";
	    $break = '.br';
	}

	next;
    }

    my $matched = '';
    $include{$sect} ||= '';

    # Sub-sections have a trailing colon and the second line indented.
    if (s/^(\S.*:) *\n / /)
    {
	$matched .= $& if %append;
	$include{$sect} .= qq(.SS "$1"\n);
    }

    my $indent = 0;
    my $content = '';

    # Option with description.
    if (s/^( {1,10}([+-]\S.*?))(?:(  +)|\n( {20,}))(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length ($4 || "$1$3");
	$content = ".TP\n\x83$2\n\x83$5\n";
	unless ($4)
	{
	    # Indent may be different on second line.
	    $indent = length $& if /^ {20,}/;
	}
    }

    # Option without description.
    elsif (s/^ {1,10}([+-]\S.*)\n//)
    {
	$matched .= $& if %append;
	$content = ".HP\n\x83$1\n";
	$indent = 80; # not continued
    }

    # Indented paragraph with tag.
    elsif (s/^( +(\S.*?)  +)(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length $1;
	$content = ".TP\n\x83$2\n\x83$3\n";
    }

    # Indented paragraph.
    elsif (s/^( +)(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length $1;
	$content = ".IP\n\x83$2\n";
    }

    # Left justified paragraph.
    else
    {
	s/(.*)\n//;
	$matched .= $& if %append;
	$content = ".PP\n" if $include{$sect};
	$content .= "$1\n";
    }

    # Append continuations.
    while (s/^ {$indent}(\S.*)\n//)
    {
	$matched .= $& if %append;
	$content .= "\x83$1\n"
    }

    # Move to next paragraph.
    s/^\n+//;

    for ($content)
    {
	# Leading dot and apostrophe protection.
	s/\x83\./\x80/g;
	s/\x83'/\x81/g;
	s/\x83//g;

	# Convert options.
	s/(^| )(-[][\w=-]+)/$1 . convert_option $2/mge;
    }

    # Check if matched paragraph contains /pat/.
    if (%append)
    {
	for my $pat (keys %append)
	{
	    if ($matched =~ $pat)
	    {
		$content .= ".PP\n" unless $append{$pat} =~ /^\./;
		$content .= $append{$pat};
	    }
	}
    }

    $include{$sect} .= $content;
}

# Refer to the real documentation.
unless ($opt_no_info)
{
    $sect = 'SEE ALSO';
    $include{$sect} ||= '';
    $include{$sect} .= ".PP\n" if $include{$sect};
    $include{$sect} .= <<EOT;
The full documentation for
.B $program
is maintained as a Texinfo manual.  If the
.B info
and
.B $program
programs are properly installed at your site, the command
.IP
.B info $program
.PP
should give you access to the complete manual.
EOT
}

# Output header.
print <<EOT;
.\\" DO NOT MODIFY THIS FILE!  It was generated by $this_program $this_version.
.TH $PROGRAM "$section" "$date" "$package $version" FSF
EOT

# Section ordering.
my @@pre = qw(NAME SYNOPSIS DESCRIPTION OPTIONS EXAMPLES);
my @@post = ('AUTHOR', 'REPORTING BUGS', 'COPYRIGHT', 'SEE ALSO');
my $filter = join '|', @@pre, @@post;

# Output content.
for (@@pre, (grep ! /^($filter)$/o, @@include), @@post)
{
    if ($include{$_})
    {
	my $quote = /\W/ ? '"' : '';
	print ".SH $quote$_$quote\n";
	
	for ($include{$_})
	{
	    # Replace leading dot, apostrophe and backslash tokens.
	    s/\x80/\\&./g;
	    s/\x81/\\&'/g;
	    s/\x82/\\e/g;
	    print;
	}
    }
}

exit;

# Convert option dashes to \- to stop nroff from hyphenating 'em, and
# embolden.  Option arguments get italicised.
sub convert_option
{
    local $_ = '\fB' . shift;

    s/-/\\-/g;
    unless (s/\[=(.*)\]$/\\fR[=\\fI$1\\fR]/)
    {
	s/=(.)/\\fR=\\fI$1/;
	s/ (.)/ \\fI$1/;
	$_ .= '\fR';
    }

    $_;
}
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
# Copyright © 1997, 98, 99 Free Software Foundation, Inc.
d21 1
d30 1
a30 1
my $this_version = '1.013';
d32 1
a32 1
$this_program $this_version
d34 1
a34 1
Copyright (C) 1997, 98, 99 Free Software Foundation, Inc.
d53 1
a53 1
     --version           print $this_program program version number, then exit
d56 2
d61 2
a62 5
my ($include, $opt_name, $opt_include, $opt_output, $opt_no_info);

# Parse options.
Getopt::Long::config('bundling');
GetOptions (
d65 2
a66 2
    'i|include=s'	=> \$include,
    'I|opt-include=s'	=> \$opt_include,
d69 7
a75 2
    help		=> sub { print $help_info; exit },
    version		=> sub { print $version_info; exit },
d81 5
a85 1
my @@include = (); # to retain order
d89 8
a96 2
# [section name]
# verbatim text
d98 1
a98 1
if ($include or $opt_include)
d100 10
a109 1
    if (open INC, $include || $opt_include)
d111 10
a120 1
	my $sect;
d122 2
a123 1
	while (<INC>)
d125 5
a129 1
	    if (/^\[([^]]+)\]/)
d131 2
a132 4
		$sect = uc $1;
		$sect =~ s/^\s+//;
		$sect =~ s/\s+$//;
		next;
d135 2
a136 7
	    # Silently ignore anything before the first
	    # section--allows for comments and revision info.
	    next unless $sect;

	    push @@include, $sect unless $include{$sect};
	    $include{$sect} ||= '';
	    $include{$sect} .= $_;
d139 11
a149 1
	close INC;
d151 2
a152 2
	die "$this_program: no valid information found in `$include'\n"
	    unless %include;
d154 2
a155 10
	# Compress trailing blank lines.
	for (keys %include)
	{
	    $include{$_} =~ s/\n+$//;
	    $include{$_} .= "\n" unless /^NAME$/;
	}
    }
    else
    {
	die "$this_program: can't open `$include' ($!)\n" if $include;
d157 11
d170 1
a170 1
# Turn off localisation of executable's ouput.
d173 1
a173 1
# Turn off localisation of date (for strftime)
d176 5
a180 9
# Expand tabs, strip trailing spaces and break into paragraphs
sub paragraphs { split /\n\n+/, join '', expand @@_ }

# Grab help and version paragraphs from executable
my @@help = paragraphs `$ARGV[0] --help 2>/dev/null`
    or die "$this_program: can't get `--help' info from $ARGV[0]\n";

my @@version = paragraphs `$ARGV[0] --version 2>/dev/null`
    or die "$this_program: can't get `--version' info from $ARGV[0]\n";
d208 1
a208 1
$_ = shift @@version;
d230 1
a230 1
# no info for `info' itself
d233 2
a234 2
# --name overrides --include contents
$include{NAME} = "$program \\- $opt_name" if $opt_name;
d236 2
a237 2
# Default (useless) NAME paragraph
$include{NAME} ||= "$program \\- manual page for $program $version";
d242 48
a289 7
# Header.
print <<EOT;
.\\" DO NOT MODIFY THIS FILE!  It was generated by $this_program $this_version.
.TH $PROGRAM "$section" "$date" "$package $version" FSF
.SH NAME
$include{NAME}
EOT
d291 2
a292 3
my $break;
my $accumulate = 1;
my @@description = ();
d296 1
a296 2
# Output converted --help information.
for (@@help)
d298 6
a303 1
    chomp;
d305 2
a306 1
    if (s/^Usage: +\S+ +(.*)\n?//)
d308 6
a313 22
	# Turn the usage clause into a synopsis.
	my $synopsis = '';

	do {
	    my $syn = $1;
	    $syn =~ s/(([][]|\.\.+)+)/\\fR$1\\fI/g;
	    $syn =~ s/^/\\fI/ unless $syn =~ s/^\\fR//;
	    $syn .= '\fR';
	    $syn =~ s/\\fI( *)\\fR/$1/g;

	    $synopsis .= ".br\n" unless $accumulate;
	    $synopsis .= ".B $program\n";
	    $synopsis .= "$syn\n";
	    $accumulate = 0;
	} while s/^(?:Usage| *or): +\S+ +(.*)\n?//;

	# Include file overrides SYNOPSIS.
	print ".SH SYNOPSIS\n", $include{SYNOPSIS} || $synopsis;

	# Dump any accumulated description text.
	print ".SH DESCRIPTION\n";
	print @@description;
d315 1
a315 2
	# Add additional description text from include file.
	if ($include{DESCRIPTION})
d317 13
a329 2
	    print ".PP\n" unless $include{DESCRIPTION} =~ /^\..P/;
	    print $include{DESCRIPTION};
d332 3
a334 2
	$break = 1;
	next unless $_;
d337 2
a338 2
    # Accumulate text if the synopsis has not been produced yet.
    if ($accumulate)
d340 1
a340 3
	push @@description, ".PP\n" if @@description;
	push @@description, "$_\n";
	next;
d343 2
a344 2
    # Convert some standard paragraph names
    if (s/^(Options|Examples): *\n//)
d346 1
a346 3
	print qq(.SH \U$1\n);
	$break = '';
	next unless length;
d349 3
a351 2
    # Catch bug report text.
    if (/^Report bugs |^Email bug reports to /)
d353 10
a362 2
	print qq(.SH "REPORTING BUGS"\n$_\n);
	$break = '';
d366 5
a370 2
    # Option subsections have second line indented.
    if (s/^(\S.*)\n / /)
d372 2
a373 2
	print qq(.SS "$1"\n);
	$break = '';
d376 5
a380 2
    my $output = '';
    while (length)
d382 4
a385 4
	my $indent = 0;

	# Tagged paragraph
	if (s/^( +(\S.*?)  +)(\S.*)\n?//)
d387 2
a388 3
	    $indent = length $1;
	    $output .= ".TP\n$2\n$3\n";
	    $break = 1;
d390 1
d392 23
a414 7
	# Indented paragraph
	elsif (s/^( +)(\S.*)\n?//)
	{
	    $indent = length $1;
	    $output .= ".IP\n$2\n";
	    $break = 1;
	}
d416 8
a423 8
	# Left justified paragraph
	else
	{
	    s/(.*)\n?//;
	    $output .= ".PP\n" if $break;
	    $output .= "$1\n";
	    $break = 1;
	}
d425 5
a429 2
	# Continuations
	$output .= "$1\n" while s/^ {$indent}(\S.*)\n?//;
d432 2
a433 1
    $_ = $output;
d435 6
a440 2
    # Escape backslashes.
    s/\\/\\e/g;
d442 16
a457 4
    # Convert options.
    s/(^| )(-[][\w=-]+)/$1 . convert_option $2/mge;
    print;
}
d459 1
a459 6
# Print any include items other than the ones we have already dealt
# with.
for (@@include)
{
    print qq(.SH "$_"\n$include{$_})
	unless /^(NAME|SYNOPSIS|DESCRIPTION|SEE ALSO)$/;
d463 1
a463 1
if ($include{'SEE ALSO'} or !$opt_no_info)
d465 4
a468 4
    print qq(.SH "SEE ALSO"\n);
    print $include{'SEE ALSO'}, ".PP\n" if $include{'SEE ALSO'};

    print <<EOT unless $opt_no_info;
d483 5
a487 4
# Output converted --version information.
for (@@version)
{
    chomp;
d489 4
a492 2
    # Join hyphenated lines.
    s/([A-Za-z])-\n */$1/g;
d494 17
a510 13
    # Convert copyright symbol or (c) to nroff character.
    s/Copyright +(?:\xa9|\([Cc]\))/Copyright \\(co/g;

    # Insert appropriate headings for copyright and author.
    if    (/^Copyright \\/) { print ".SH COPYRIGHT\n" }
    elsif (/^Written +by/)  { print ".SH AUTHOR\n" }
    else		    { print ".PP\n"; }

    # Insert line breaks before additional copyright messages and the
    # disclaimer.
    s/(.)\n(Copyright |This is free software)/$1\n.br\n$2/g;

    print "$_\n";
d519 1
a519 1
    my $option = '\fB' . shift;
d521 2
a522 2
    $option =~ s/-/\\-/g;
    unless ($option =~ s/\[=(.*)\]$/\\fR[=\\fI$1\\fR]/)
d524 3
a526 3
	$option =~ s/=(.)/\\fR=\\fI$1/;
	$option =~ s/ (.)/ \\fI$1/;
	$option .= '\fR';
d529 1
a529 1
    $option;
@


1.1.1.1
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@@


1.1.1.2
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d4 1
a4 1
# Copyright © 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
a20 1
# Available from ftp://ftp.gnu.org/gnu/help2man/
d29 1
a29 1
my $this_version = '1.24';
d31 1
a31 1
GNU $this_program $this_version
d33 1
a33 1
Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d52 1
a52 1
     --version           print version number, then exit
a54 2

Report bugs to <bug-help2man\@@gnu.org>.
d58 5
a62 2
my ($opt_name, @@opt_include, $opt_output, $opt_no_info);
my %opt_def = (
d65 2
a66 2
    'i|include=s'	=> sub { push @@opt_include, [ pop, 1 ] },
    'I|opt-include=s'	=> sub { push @@opt_include, [ pop, 0 ] },
d69 2
a70 7
);

# Parse options.
Getopt::Long::config('bundling');
GetOptions (%opt_def,
    help    => sub { print $help_info; exit },
    version => sub { print $version_info; exit },
d76 1
a76 5
my %append = ();
my @@include = (); # retain order given in include file

# Provide replacement `quote-regex' operator for pre-5.005.
BEGIN { eval q(sub qr { '' =~ $_[0]; $_[0] }) if $] < 5.005 }
d80 2
a81 8
#   [section name]
#   verbatim text
#
# or
#
#   /pattern/
#   verbatim text
#
d83 1
a83 1
while (@@opt_include)
d85 1
a85 10
    my ($inc, $required) = @@{shift @@opt_include};

    next unless -f $inc or $required;
    die "$this_program: can't open `$inc' ($!)\n"
	unless open INC, $inc;

    my $key;
    my $hash = \%include;

    while (<INC>)
d87 1
a87 10
	# [section]
	if (/^\[([^]]+)\]/)
	{
	    $key = uc $1;
	    $key =~ s/^\s+//;
	    $key =~ s/\s+$//;
	    $hash = \%include;
	    push @@include, $key unless $include{$key};
	    next;
	}
d89 1
a89 2
	# /pattern/
	if (m!^/(.*)/([ims]*)!)
d91 1
a91 5
	    my $pat = $2 ? "(?$2)$1" : $1;

	    # Check pattern.
	    eval { $key = qr($pat) };
	    if ($@@)
d93 4
a96 2
		$@@ =~ s/ at .*? line \d.*//;
		die "$inc:$.:$@@";
d99 7
a105 2
	    $hash = \%append;
	    next;
d108 7
a114 4
	# Check for options before the first section--anything else is
	# silently ignored, allowing the first for comments and
	# revision info.
	unless ($key)
d116 2
a117 8
	    # handle options
	    if (/^-/)
	    {
		local @@ARGV = split;
		GetOptions %opt_def;
	    }

	    next;
a118 3

	$hash->{$key} ||= '';
	$hash->{$key} .= $_;
d120 4
a123 11

    close INC;

    die "$this_program: no valid information found in `$inc'\n"
	unless $key;
}

# Compress trailing blank lines.
for my $hash (\(%include, %append))
{
    for (keys %$hash) { $hash->{$_} =~ s/\n+$/\n/ }
d129 1
a129 1
# Turn off localisation of date (for strftime).
d132 9
a140 5
# Grab help and version info from executable.
my ($help_text, $version_text) = map {
    join '', map { s/ +$//; expand $_ } `$ARGV[0] --$_ 2>/dev/null`
	or die "$this_program: can't get `--$_' info from $ARGV[0]\n"
} qw(help version);
d168 1
a168 1
($_, $version_text) = split /\n+/, $version_text, 2;
d190 1
a190 1
# No info for `info' itself.
d193 2
a194 2
# --name overrides --include contents.
$include{NAME} = "$program \\- $opt_name\n" if $opt_name;
d196 2
a197 2
# Default (useless) NAME paragraph.
$include{NAME} ||= "$program \\- manual page for $program $version\n";
d202 7
a208 4
# Extract usage clause(s) [if any] for SYNOPSIS.
if ($help_text =~ s/^Usage:( +(\S+))(.*)((?:\n(?: {6}\1| *or: +\S).*)*)//m)
{
    my @@syn = $2 . $3;
d210 3
a212 46
    if ($_ = $4)
    {
	s/^\n//;
	for (split /\n/) { s/^ *(or: +)?//; push @@syn, $_ }
    }

    my $synopsis = '';
    for (@@syn)
    {
	$synopsis .= ".br\n" if $synopsis;
	s!^\S*/!!;
	s/^(\S+) *//;
	$synopsis .= ".B $1\n";
	s/\s+$//;
	s/(([][]|\.\.+)+)/\\fR$1\\fI/g;
	s/^/\\fI/ unless s/^\\fR//;
	$_ .= '\fR';
	s/(\\fI)( *)/$2$1/g;
	s/\\fI\\fR//g;
	s/^\\fR//;
	s/\\fI$//;
	s/^\./\\&./;

	$synopsis .= "$_\n";
    }

    $include{SYNOPSIS} ||= $synopsis;
}

# Process text, initial section is DESCRIPTION.
my $sect = 'DESCRIPTION';
$_ = "$help_text\n\n$version_text";

# Normalise paragraph breaks.
s/^\n+//;
s/\n*$/\n/;
s/\n\n+/\n\n/g;

# Temporarily exchange leading dots, apostrophes and backslashes for
# tokens.
s/^\./\x80/mg;
s/^'/\x81/mg;
s/\\/\x82/g;

# Start a new paragraph (if required) for these.
s/([^\n])\n(Report +bugs|Email +bug +reports +to|Written +by)/$1\n\n$2/g;
d216 2
a217 1
while (length)
d219 1
a219 6
    # Convert some standard paragraph names.
    if (s/^(Options|Examples): *\n//)
    {
	$sect = uc $1;
	next;
    }
d221 1
a221 2
    # Copyright section
    if (/^Copyright +[(\xa9]/)
d223 22
a244 6
	$sect = 'COPYRIGHT';
	$include{$sect} ||= '';
	$include{$sect} .= ".PP\n" if $include{$sect};

	my $copy;
	($copy, $_) = split /\n\n/, $_, 2;
d246 2
a247 1
	for ($copy)
d249 2
a250 13
	    # Add back newline
	    s/\n*$/\n/;

	    # Convert iso9959-1 copyright symbol or (c) to nroff
	    # character.
	    s/^Copyright +(?:\xa9|\([Cc]\))/Copyright \\(co/mg;

	    # Insert line breaks before additional copyright messages
	    # and the disclaimer.
	    s/(.)\n(Copyright |This +is +free +software)/$1\n.br\n$2/g;

	    # Join hyphenated lines.
	    s/([A-Za-z])-\n */$1/g;
d253 2
a254 3
	$include{$sect} .= $copy;
	$_ ||= '';
	next;
d257 2
a258 2
    # Catch bug report text.
    if (/^(Report +bugs|Email +bug +reports +to) /)
d260 3
a262 1
	$sect = 'REPORTING BUGS';
d265 2
a266 2
    # Author section.
    elsif (/^Written +by/)
d268 3
a270 1
	$sect = 'AUTHOR';
d273 2
a274 3
    # Examples, indicated by an indented leading $, % or > are
    # rendered in a constant width font.
    if (/^( +)([\$\%>] )\S/)
d276 2
a277 10
	my $indent = $1;
	my $prefix = $2;
	my $break = '.IP';
	$include{$sect} ||= '';
	while (s/^$indent\Q$prefix\E(\S.*)\n*//)
	{
	    $include{$sect} .= "$break\n\\f(CW$prefix$1\\fR\n";
	    $break = '.br';
	}

d281 2
a282 5
    my $matched = '';
    $include{$sect} ||= '';

    # Sub-sections have a trailing colon and the second line indented.
    if (s/^(\S.*:) *\n / /)
d284 2
a285 2
	$matched .= $& if %append;
	$include{$sect} .= qq(.SS "$1"\n);
d288 4
a291 2
    my $indent = 0;
    my $content = '';
d293 2
a294 7
    # Option with description.
    if (s/^( {1,10}([+-]\S.*?))(?:(  +)|\n( {20,}))(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length ($4 || "$1$3");
	$content = ".TP\n\x83$2\n\x83$5\n";
	unless ($4)
d296 3
a298 2
	    # Indent may be different on second line.
	    $indent = length $& if /^ {20,}/;
a299 1
    }
d301 7
a307 7
    # Option without description.
    elsif (s/^ {1,10}([+-]\S.*)\n//)
    {
	$matched .= $& if %append;
	$content = ".HP\n\x83$1\n";
	$indent = 80; # not continued
    }
d309 8
a316 24
    # Indented paragraph with tag.
    elsif (s/^( +(\S.*?)  +)(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length $1;
	$content = ".TP\n\x83$2\n\x83$3\n";
    }

    # Indented paragraph.
    elsif (s/^( +)(\S.*)\n//)
    {
	$matched .= $& if %append;
	$indent = length $1;
	$content = ".IP\n\x83$2\n";
    }

    # Left justified paragraph.
    else
    {
	s/(.*)\n//;
	$matched .= $& if %append;
	$content = ".PP\n" if $include{$sect};
	$content .= "$1\n";
    }
d318 2
a319 5
    # Append continuations.
    while (s/^ {$indent}(\S.*)\n//)
    {
	$matched .= $& if %append;
	$content .= "\x83$1\n"
d322 1
a322 2
    # Move to next paragraph.
    s/^\n+//;
d324 2
a325 6
    for ($content)
    {
	# Leading dot and apostrophe protection.
	s/\x83\./\x80/g;
	s/\x83'/\x81/g;
	s/\x83//g;
d327 4
a330 3
	# Convert options.
	s/(^| )(-[][\w=-]+)/$1 . convert_option $2/mge;
    }
d332 6
a337 14
    # Check if matched paragraph contains /pat/.
    if (%append)
    {
	for my $pat (keys %append)
	{
	    if ($matched =~ $pat)
	    {
		$content .= ".PP\n" unless $append{$pat} =~ /^\./;
		$content .= $append{$pat};
	    }
	}
    }

    $include{$sect} .= $content;
d341 1
a341 1
unless ($opt_no_info)
d343 4
a346 4
    $sect = 'SEE ALSO';
    $include{$sect} ||= '';
    $include{$sect} .= ".PP\n" if $include{$sect};
    $include{$sect} .= <<EOT;
d361 15
a375 5
# Output header.
print <<EOT;
.\\" DO NOT MODIFY THIS FILE!  It was generated by $this_program $this_version.
.TH $PROGRAM "$section" "$date" "$package $version" FSF
EOT
d377 3
a379 4
# Section ordering.
my @@pre = qw(NAME SYNOPSIS DESCRIPTION OPTIONS EXAMPLES);
my @@post = ('AUTHOR', 'REPORTING BUGS', 'COPYRIGHT', 'SEE ALSO');
my $filter = join '|', @@pre, @@post;
d381 1
a381 17
# Output content.
for (@@pre, (grep ! /^($filter)$/o, @@include), @@post)
{
    if ($include{$_})
    {
	my $quote = /\W/ ? '"' : '';
	print ".SH $quote$_$quote\n";
	
	for ($include{$_})
	{
	    # Replace leading dot, apostrophe and backslash tokens.
	    s/\x80/\\&./g;
	    s/\x81/\\&'/g;
	    s/\x82/\\e/g;
	    print;
	}
    }
d390 1
a390 1
    local $_ = '\fB' . shift;
d392 2
a393 2
    s/-/\\-/g;
    unless (s/\[=(.*)\]$/\\fR[=\\fI$1\\fR]/)
d395 3
a397 3
	s/=(.)/\\fR=\\fI$1/;
	s/ (.)/ \\fI$1/;
	$_ .= '\fR';
d400 1
a400 1
    $_;
@

