head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.48
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.6
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.5
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.3
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.39;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.07;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.12;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.12;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.08;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.01.11.16.32.14;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.09.01.24.40;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.06.10.13.21.03;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.07.17.16.03.42;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* filesys.c -- filesystem specific functions.
   $Id: filesys.c,v 1.6 2004/07/30 17:17:40 karl Exp $

   Copyright (C) 1993, 1997, 1998, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"

#include "tilde.h"
#include "filesys.h"

/* Local to this file. */
static char *info_file_in_path (char *filename, char *path);
static char *lookup_info_filename (char *filename);
static char *info_absolute_file (char *fname);

static void remember_info_filename (char *filename, char *expansion);
static void maybe_initialize_infopath (void);

typedef struct
{
  char *suffix;
  char *decompressor;
} COMPRESSION_ALIST;

static char *info_suffixes[] = {
  ".info",
  "-info",
  "/index",
  ".inf",       /* 8+3 file on filesystem which supports long file names */
#ifdef __MSDOS__
  /* 8+3 file names strike again...  */
  ".in",        /* for .inz, .igz etc. */
  ".i",
#endif
  "",
  NULL
};

static COMPRESSION_ALIST compress_suffixes[] = {
  { ".gz", "gunzip" },
  { ".bz2", "bunzip2" },
  { ".z", "gunzip" },
  { ".Z", "uncompress" },
  { ".Y", "unyabba" },
#ifdef __MSDOS__
  { "gz", "gunzip" },
  { "z", "gunzip" },
#endif
  { (char *)NULL, (char *)NULL }
};

/* The path on which we look for info files.  You can initialize this
   from the environment variable INFOPATH if there is one, or you can
   call info_add_path () to add paths to the beginning or end of it.
   You can call zap_infopath () to make the path go away. */
char *infopath = (char *)NULL;
static int infopath_size = 0;

/* Expand the filename in PARTIAL to make a real name for this operating
   system.  This looks in INFO_PATHS in order to find the correct file.
   If it can't find the file, it returns NULL. */
static char *local_temp_filename = (char *)NULL;
static int local_temp_filename_size = 0;

char *
info_find_fullpath (char *partial)
{
  int initial_character;
  char *temp;

  filesys_error_number = 0;

  maybe_initialize_infopath ();

  if (partial && (initial_character = *partial))
    {
      char *expansion;

      expansion = lookup_info_filename (partial);

      if (expansion)
        return (expansion);

      /* If we have the full path to this file, we still may have to add
         various extensions to it.  I guess we have to stat this file
         after all. */
      if (IS_ABSOLUTE (partial))
	temp = info_absolute_file (partial);
      else if (initial_character == '~')
        {
          expansion = tilde_expand_word (partial);
          if (IS_ABSOLUTE (expansion))
            {
              temp = info_absolute_file (expansion);
              free (expansion);
            }
          else
            temp = expansion;
        }
      else if (initial_character == '.' &&
               (IS_SLASH (partial[1]) ||
		(partial[1] == '.' && IS_SLASH (partial[2]))))
        {
          if (local_temp_filename_size < 1024)
            local_temp_filename = (char *)xrealloc
              (local_temp_filename, (local_temp_filename_size = 1024));
#if defined (HAVE_GETCWD)
          if (!getcwd (local_temp_filename, local_temp_filename_size))
#else /*  !HAVE_GETCWD */
          if (!getwd (local_temp_filename))
#endif /* !HAVE_GETCWD */
            {
              filesys_error_number = errno;
              return (partial);
            }

          strcat (local_temp_filename, "/");
          strcat (local_temp_filename, partial);
	  temp = info_absolute_file (local_temp_filename); /* try extensions */
	  if (!temp)
	    partial = local_temp_filename;
        }
      else
        temp = info_file_in_path (partial, infopath);

      if (temp)
        {
          remember_info_filename (partial, temp);
          if (strlen (temp) > (unsigned int) local_temp_filename_size)
            local_temp_filename = (char *) xrealloc
              (local_temp_filename,
               (local_temp_filename_size = (50 + strlen (temp))));
          strcpy (local_temp_filename, temp);
          free (temp);
          return (local_temp_filename);
        }
    }
  return (partial);
}

/* Scan the list of directories in PATH looking for FILENAME.  If we find
   one that is a regular file, return it as a new string.  Otherwise, return
   a NULL pointer. */
static char *
info_file_in_path (char *filename, char *path)
{
  struct stat finfo;
  char *temp_dirname;
  int statable, dirname_index;

  /* Reject ridiculous cases up front, to prevent infinite recursion
     later on.  E.g., someone might say "info '(.)foo'"...  */
  if (!*filename || STREQ (filename, ".") || STREQ (filename, ".."))
    return NULL;

  dirname_index = 0;

  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))
    {
      register int i, pre_suffix_length;
      char *temp;

      /* Expand a leading tilde if one is present. */
      if (*temp_dirname == '~')
        {
          char *expanded_dirname;

          expanded_dirname = tilde_expand_word (temp_dirname);
          free (temp_dirname);
          temp_dirname = expanded_dirname;
        }

      temp = (char *)xmalloc (30 + strlen (temp_dirname) + strlen (filename));
      strcpy (temp, temp_dirname);
      if (!IS_SLASH (temp[(strlen (temp)) - 1]))
        strcat (temp, "/");
      strcat (temp, filename);

      pre_suffix_length = strlen (temp);

      free (temp_dirname);

      for (i = 0; info_suffixes[i]; i++)
        {
          strcpy (temp + pre_suffix_length, info_suffixes[i]);

          statable = (stat (temp, &finfo) == 0);

          /* If we have found a regular file, then use that.  Else, if we
             have found a directory, look in that directory for this file. */
          if (statable)
            {
              if (S_ISREG (finfo.st_mode))
                {
                  return (temp);
                }
              else if (S_ISDIR (finfo.st_mode))
                {
                  char *newpath, *filename_only, *newtemp;

                  newpath = xstrdup (temp);
                  filename_only = filename_non_directory (filename);
                  newtemp = info_file_in_path (filename_only, newpath);

                  free (newpath);
                  if (newtemp)
                    {
                      free (temp);
                      return (newtemp);
                    }
                }
            }
          else
            {
              /* Add various compression suffixes to the name to see if
                 the file is present in compressed format. */
              register int j, pre_compress_suffix_length;

              pre_compress_suffix_length = strlen (temp);

              for (j = 0; compress_suffixes[j].suffix; j++)
                {
                  strcpy (temp + pre_compress_suffix_length,
                          compress_suffixes[j].suffix);

                  statable = (stat (temp, &finfo) == 0);
                  if (statable && (S_ISREG (finfo.st_mode)))
                    return (temp);
                }
            }
        }
      free (temp);
    }
  return ((char *)NULL);
}

/* Assume FNAME is an absolute file name, and check whether it is
   a regular file.  If it is, return it as a new string; otherwise
   return a NULL pointer.  We do it by taking the file name apart
   into its directory and basename parts, and calling info_file_in_path.*/
static char *
info_absolute_file (char *fname)
{
  char *containing_dir = xstrdup (fname);
  char *base = filename_non_directory (containing_dir);

  if (base > containing_dir)
    base[-1] = '\0';

  return info_file_in_path (filename_non_directory (fname), containing_dir);
}


/* Given a string containing units of information separated by the
   PATH_SEP character, return the next one after IDX, or NULL if there
   are no more.  Advance IDX to the character after the colon. */

char *
extract_colon_unit (char *string, int *idx)
{
  unsigned int i = (unsigned int) *idx;
  unsigned int start = i;

  if (!string || i >= strlen (string))
    return NULL;

  if (!string[i]) /* end of string */
    return NULL;

  /* Advance to next PATH_SEP.  */
  while (string[i] && string[i] != PATH_SEP[0])
    i++;

  {
    char *value = xmalloc ((i - start) + 1);
    strncpy (value, &string[start], (i - start));
    value[i - start] = 0;

    i++; /* move past PATH_SEP */
    *idx = i;
    return value;
  }
}

/* A structure which associates a filename with its expansion. */
typedef struct
{
  char *filename;
  char *expansion;
} FILENAME_LIST;

/* An array of remembered arguments and results. */
static FILENAME_LIST **names_and_files = (FILENAME_LIST **)NULL;
static int names_and_files_index = 0;
static int names_and_files_slots = 0;

/* Find the result for having already called info_find_fullpath () with
   FILENAME. */
static char *
lookup_info_filename (char *filename)
{
  if (filename && names_and_files)
    {
      register int i;
      for (i = 0; names_and_files[i]; i++)
        {
          if (FILENAME_CMP (names_and_files[i]->filename, filename) == 0)
            return (names_and_files[i]->expansion);
        }
    }
  return (char *)NULL;;
}

/* Add a filename and its expansion to our list. */
static void
remember_info_filename (char *filename, char *expansion)
{
  FILENAME_LIST *new;

  if (names_and_files_index + 2 > names_and_files_slots)
    {
      int alloc_size;
      names_and_files_slots += 10;

      alloc_size = names_and_files_slots * sizeof (FILENAME_LIST *);

      names_and_files =
        (FILENAME_LIST **) xrealloc (names_and_files, alloc_size);
    }

  new = (FILENAME_LIST *)xmalloc (sizeof (FILENAME_LIST));
  new->filename = xstrdup (filename);
  new->expansion = expansion ? xstrdup (expansion) : (char *)NULL;

  names_and_files[names_and_files_index++] = new;
  names_and_files[names_and_files_index] = (FILENAME_LIST *)NULL;
}

static void
maybe_initialize_infopath (void)
{
  if (!infopath_size)
    {
      infopath = (char *)
        xmalloc (infopath_size = (1 + strlen (DEFAULT_INFOPATH)));

      strcpy (infopath, DEFAULT_INFOPATH);
    }
}

/* Add PATH to the list of paths found in INFOPATH.  2nd argument says
   whether to put PATH at the front or end of INFOPATH. */
void
info_add_path (char *path, int where)
{
  int len;

  if (!infopath)
    {
      infopath = (char *)xmalloc (infopath_size = 200 + strlen (path));
      infopath[0] = '\0';
    }

  len = strlen (path) + strlen (infopath);

  if (len + 2 >= infopath_size)
    infopath = (char *)xrealloc (infopath, (infopath_size += (2 * len) + 2));

  if (!*infopath)
    strcpy (infopath, path);
  else if (where == INFOPATH_APPEND)
    {
      strcat (infopath, PATH_SEP);
      strcat (infopath, path);
    }
  else if (where == INFOPATH_PREPEND)
    {
      char *temp = xstrdup (infopath);
      strcpy (infopath, path);
      strcat (infopath, PATH_SEP);
      strcat (infopath, temp);
      free (temp);
    }
}

/* Make INFOPATH have absolutely nothing in it. */
void
zap_infopath (void)
{
  if (infopath)
    free (infopath);

  infopath = (char *)NULL;
  infopath_size = 0;
}

/* Given a chunk of text and its length, convert all CRLF pairs at every
   end-of-line into a single Newline character.  Return the length of
   produced text.

   This is required because the rest of code is too entrenched in having
   a single newline at each EOL; in particular, searching for various
   Info headers and cookies can become extremely tricky if that assumption
   breaks.

   FIXME: this could also support Mac-style text files with a single CR
   at the EOL, but what about random CR characters in non-Mac files?  Can
   we afford converting them into newlines as well?  Maybe implement some
   heuristics here, like in Emacs 20.

   FIXME: is it a good idea to show the EOL type on the modeline?  */
long
convert_eols (char *text, long int textlen)
{
  register char *s = text;
  register char *d = text;

  while (textlen--)
    {
      if (*s == '\r' && textlen && s[1] == '\n')
	{
	  s++;
	  textlen--;
	}
      *d++ = *s++;
    }

  return (long)(d - text);
}

/* Read the contents of PATHNAME, returning a buffer with the contents of
   that file in it, and returning the size of that buffer in FILESIZE.
   FINFO is a stat struct which has already been filled in by the caller.
   If the file turns out to be compressed, set IS_COMPRESSED to non-zero.
   If the file cannot be read, return a NULL pointer. */
char *
filesys_read_info_file (char *pathname, long int *filesize,
    struct stat *finfo, int *is_compressed)
{
  long st_size;

  *filesize = filesys_error_number = 0;

  if (compressed_filename_p (pathname))
    {
      *is_compressed = 1;
      return (filesys_read_compressed (pathname, filesize));
    }
  else
    {
      int descriptor;
      char *contents;

      *is_compressed = 0;
      descriptor = open (pathname, O_RDONLY | O_BINARY, 0666);

      /* If the file couldn't be opened, give up. */
      if (descriptor < 0)
        {
          filesys_error_number = errno;
          return ((char *)NULL);
        }

      /* Try to read the contents of this file. */
      st_size = (long) finfo->st_size;
      contents = (char *)xmalloc (1 + st_size);
      if ((read (descriptor, contents, st_size)) != st_size)
        {
	  filesys_error_number = errno;
	  close (descriptor);
	  free (contents);
	  return ((char *)NULL);
        }

      close (descriptor);

      /* Convert any DOS-style CRLF EOLs into Unix-style NL.
	 Seems like a good idea to have even on Unix, in case the Info
	 files are coming from some Windows system across a network.  */
      *filesize = convert_eols (contents, st_size);

      /* EOL conversion can shrink the text quite a bit.  We don't
	 want to waste storage.  */
      if (*filesize < st_size)
	contents = (char *)xrealloc (contents, 1 + *filesize);
      contents[*filesize] = '\0';

      return (contents);
    }
}

/* Typically, pipe buffers are 4k. */
#define BASIC_PIPE_BUFFER (4 * 1024)

/* We use some large multiple of that. */
#define FILESYS_PIPE_BUFFER_SIZE (16 * BASIC_PIPE_BUFFER)

char *
filesys_read_compressed (char *pathname, long int *filesize)
{
  FILE *stream;
  char *command, *decompressor;
  char *contents = (char *)NULL;

  *filesize = filesys_error_number = 0;

  decompressor = filesys_decompressor_for_file (pathname);

  if (!decompressor)
    return ((char *)NULL);

  command = (char *)xmalloc (15 + strlen (pathname) + strlen (decompressor));
  /* Explicit .exe suffix makes the diagnostics of `popen'
     better on systems where COMMAND.COM is the stock shell.  */
  sprintf (command, "%s%s < %s",
	   decompressor, STRIP_DOT_EXE ? ".exe" : "", pathname);

#if !defined (BUILDING_LIBRARY)
  if (info_windows_initialized_p)
    {
      char *temp;

      temp = (char *)xmalloc (5 + strlen (command));
      sprintf (temp, "%s...", command);
      message_in_echo_area ("%s", temp, NULL);
      free (temp);
    }
#endif /* !BUILDING_LIBRARY */

  stream = popen (command, FOPEN_RBIN);
  free (command);

  /* Read chunks from this file until there are none left to read. */
  if (stream)
    {
      long offset, size;
      char *chunk;
    
      offset = size = 0;
      chunk = (char *)xmalloc (FILESYS_PIPE_BUFFER_SIZE);

      while (1)
        {
          int bytes_read;

          bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);

          if (bytes_read + offset >= size)
            contents = (char *)xrealloc
              (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));

          memcpy (contents + offset, chunk, bytes_read);
          offset += bytes_read;
          if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)
            break;
        }

      free (chunk);
      if (pclose (stream) == -1)
	{
	  if (contents)
	    free (contents);
	  contents = (char *)NULL;
	  filesys_error_number = errno;
	}
      else
	{
	  *filesize = convert_eols (contents, offset);
	  contents = (char *)xrealloc (contents, 1 + *filesize);
	  contents[*filesize] = '\0';
	}
    }
  else
    {
      filesys_error_number = errno;
    }

#if !defined (BUILDING_LIBARARY)
  if (info_windows_initialized_p)
    unmessage_in_echo_area ();
#endif /* !BUILDING_LIBRARY */
  return (contents);
}

/* Return non-zero if FILENAME belongs to a compressed file. */
int
compressed_filename_p (char *filename)
{
  char *decompressor;

  /* Find the final extension of this filename, and see if it matches one
     of our known ones. */
  decompressor = filesys_decompressor_for_file (filename);

  if (decompressor)
    return (1);
  else
    return (0);
}

/* Return the command string that would be used to decompress FILENAME. */
char *
filesys_decompressor_for_file (char *filename)
{
  register int i;
  char *extension = (char *)NULL;

  /* Find the final extension of FILENAME, and see if it appears in our
     list of known compression extensions. */
  for (i = strlen (filename) - 1; i > 0; i--)
    if (filename[i] == '.')
      {
        extension = filename + i;
        break;
      }

  if (!extension)
    return ((char *)NULL);

  for (i = 0; compress_suffixes[i].suffix; i++)
    if (FILENAME_CMP (extension, compress_suffixes[i].suffix) == 0)
      return (compress_suffixes[i].decompressor);

#if defined (__MSDOS__)
  /* If no other suffix matched, allow any extension which ends
     with `z' to be decompressed by gunzip.  Due to limited 8+3 DOS
     file namespace, we can expect many such cases, and supporting
     every weird suffix thus produced would be a pain.  */
  if (extension[strlen (extension) - 1] == 'z' ||
      extension[strlen (extension) - 1] == 'Z')
    return "gunzip";
#endif

  return ((char *)NULL);
}

/* The number of the most recent file system error. */
int filesys_error_number = 0;

/* A function which returns a pointer to a static buffer containing
   an error message for FILENAME and ERROR_NUM. */
static char *errmsg_buf = (char *)NULL;
static int errmsg_buf_size = 0;

char *
filesys_error_string (char *filename, int error_num)
{
  int len;
  char *result;

  if (error_num == 0)
    return ((char *)NULL);

  result = strerror (error_num);

  len = 4 + strlen (filename) + strlen (result);
  if (len >= errmsg_buf_size)
    errmsg_buf = (char *)xrealloc (errmsg_buf, (errmsg_buf_size = 2 + len));

  sprintf (errmsg_buf, "%s: %s", filename, result);
  return (errmsg_buf);
}


/* Check for "dir" with all the possible info and compression suffixes,
   in combination.  */

int
is_dir_name (char *filename)
{
  unsigned i;

  for (i = 0; info_suffixes[i]; i++)
    {
      unsigned c;
      char trydir[50];
      strcpy (trydir, "dir");
      strcat (trydir, info_suffixes[i]);
      
      if (strcasecmp (filename, trydir) == 0)
        return 1;

      for (c = 0; compress_suffixes[c].suffix; c++)
        {
          char dir_compressed[50]; /* can be short */
          strcpy (dir_compressed, trydir); 
          strcat (dir_compressed, compress_suffixes[c].suffix);
          if (strcasecmp (filename, dir_compressed) == 0)
            return 1;
        }
    }  

  return 0;
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: filesys.c,v 1.15 2002/03/23 20:45:24 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 2000 Free Software Foundation, Inc.
d29 6
a34 3
static char *info_file_in_path (), *lookup_info_filename ();
static char *info_absolute_file ();
static void remember_info_filename (), maybe_initialize_infopath ();
d83 1
a83 2
info_find_fullpath (partial)
     char *partial;
d146 1
a146 1
          if (strlen (temp) > local_temp_filename_size)
d162 1
a162 2
info_file_in_path (filename, path)
     char *filename, *path;
d259 1
a259 2
info_absolute_file (fname)
     char *fname;
d270 5
a274 4
/* Given a string containing units of information separated by
   the PATH_SEP character, return the next one pointed to by
   IDX, or NULL if there are no more.
   Advance IDX to the character after the colon. */
d276 10
a285 9
extract_colon_unit (string, idx)
     char *string;
     int *idx;
{
  register int i, start;

  i = start = *idx;
  if ((i >= strlen (string)) || !string)
    return ((char *) NULL);
d287 1
a289 7
  if (i == start)
    {
      return ((char *) NULL);
    }
  else
    {
      char *value;
d291 9
a299 8
      value = (char *) xmalloc (1 + (i - start));
      strncpy (value, &string[start], (i - start));
      value[i - start] = '\0';
      if (string[i])
        ++i;
      *idx = i;
      return (value);
    }
d303 2
a304 1
typedef struct {
d317 1
a317 2
lookup_info_filename (filename)
     char *filename;
d333 1
a333 2
remember_info_filename (filename, expansion)
     char *filename, *expansion;
d357 1
a357 1
maybe_initialize_infopath ()
d371 1
a371 3
info_add_path (path, where)
     char *path;
     int where;
d405 1
a405 1
zap_infopath ()
d430 1
a430 3
convert_eols (text, textlen)
     char *text;
     long textlen;
d454 2
a455 5
filesys_read_info_file (pathname, filesize, finfo, is_compressed)
     char *pathname;
     long *filesize;
     struct stat *finfo;
     int *is_compressed;
d464 1
a464 1
      return (filesys_read_compressed (pathname, filesize, finfo));
d516 1
a516 4
filesys_read_compressed (pathname, filesize, finfo)
     char *pathname;
     long *filesize;
     struct stat *finfo;
d542 1
a542 1
      message_in_echo_area ("%s", temp);
d604 1
a604 2
compressed_filename_p (filename)
     char *filename;
d620 1
a620 2
filesys_decompressor_for_file (filename)
     char *filename;
d663 1
a663 3
filesys_error_string (filename, error_num)
     char *filename;
     int error_num;
d686 1
a686 2
is_dir_name (filename)
    char *filename;
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: filesys.c,v 1.10 1998/12/06 21:58:30 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d166 5
d513 1
d566 1
a566 1
      int offset, size;
d600 1
d699 2
a700 2
/* Check for FILENAME eq "dir" first, then all the compression
   suffixes.  */
d707 2
a708 4
  if (strcasecmp (filename, "dir") == 0)
    return 1;
  
  for (i = 0; compress_suffixes[i].suffix; i++)
d710 6
a715 4
      char dir_compressed[50]; /* can be short */
      strcpy (dir_compressed, "dir"); 
      strcat (dir_compressed, compress_suffixes[i].suffix);
      if (strcasecmp (filename, dir_compressed) == 0)
d717 11
a727 2
    }
  
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* filesys.c -- File system specific functions for hacking this system.
   $Id: filesys.c,v 1.6 1998/02/21 22:52:46 karl Exp $
d29 1
a38 1
  "",
d42 8
a49 1
  (char *)NULL
d53 3
d58 4
a61 2
  { ".z", "gunzip" },
  { ".gz", "gunzip" },
d101 2
a102 2
      if (initial_character == '/')
        temp = info_file_in_path (partial + 1, "/");
d106 1
a106 1
          if (*expansion == '/')
d108 1
a108 1
              temp = info_file_in_path (expansion + 1, "/");
d115 2
a116 1
               (partial[1] == '/' || (partial[1] == '.' && partial[2] == '/')))
d133 3
a135 1
          return (local_temp_filename);
d185 1
a185 1
      if (temp[(strlen (temp)) - 1] != '/')
d247 20
a266 2
/* Given a string containing units of information separated by colons,
   return the next one pointed to by IDX, or NULL if there are no more.
d279 1
a279 1
  while (string[i] && string[i] != ':')
d321 1
a321 1
          if (strcmp (names_and_files[i]->filename, filename) == 0)
d390 1
a390 1
      strcat (infopath, ":");
d397 1
a397 1
      strcat (infopath, ":");
d414 36
d453 1
d456 1
a456 1
filesys_read_info_file (pathname, filesize, finfo)
d460 1
d467 4
a470 1
    return (filesys_read_compressed (pathname, filesize, finfo));
d476 2
a477 1
      descriptor = open (pathname, O_RDONLY, 0666);
d491 4
a494 4
          filesys_error_number = errno;
          close (descriptor);
          free (contents);
          return ((char *)NULL);
d499 10
a508 1
      *filesize = st_size;
d536 5
a540 2
  command = (char *)xmalloc (10 + strlen (pathname) + strlen (decompressor));
  sprintf (command, "%s < %s", decompressor, pathname);
d554 1
a554 1
  stream = popen (command, "r");
d583 12
a594 3
      pclose (stream);
      contents = (char *)xrealloc (contents, offset + 1);
      *filesize = offset;
d646 1
a646 1
    if (strcmp (extension, compress_suffixes[i].suffix) == 0)
d649 10
d691 23
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* filesys.c -- File system specific functions for hacking this system. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d22 2
a23 8
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#if defined (HAVE_SYS_FILE_H)
#include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */
#include <sys/errno.h>
#include "general.h"
a26 23
#if !defined (O_RDONLY)
#if defined (HAVE_SYS_FCNTL_H)
#include <sys/fcntl.h>
#else /* !HAVE_SYS_FCNTL_H */
#include <fcntl.h>
#endif /* !HAVE_SYS_FCNTL_H */
#endif /* !O_RDONLY */

#if !defined (errno)
extern int errno;
#endif /* !errno */

/* Found in info-utils.c. */
extern char *filename_non_directory ();

#if !defined (BUILDING_LIBRARY)
/* Found in session.c */
extern int info_windows_initialized_p;

/* Found in window.c. */
extern void message_in_echo_area (), unmessage_in_echo_area ();
#endif /* !BUILDING_LIBRARY */

d31 2
a32 5
#if !defined (NULL)
#  define NULL 0x0
#endif /* !NULL */

typedef struct {
d41 1
d84 1
a84 1
	return (expansion);
d87 2
a88 2
	 various extensions to it.  I guess we have to stat this file
	 after all. */
d90 1
a90 1
	temp = info_file_in_path (partial + 1, "/");
d92 10
a101 10
	{
	  expansion = tilde_expand_word (partial);
	  if (*expansion == '/')
	    {
	      temp = info_file_in_path (expansion + 1, "/");
	      free (expansion);
	    }
	  else
	    temp = expansion;
	}
d103 5
a107 5
	       (partial[1] == '/' || (partial[1] == '.' && partial[2] == '/')))
	{
	  if (local_temp_filename_size < 1024)
	    local_temp_filename = (char *)xrealloc
	      (local_temp_filename, (local_temp_filename_size = 1024));
d109 1
a109 1
	  if (!getcwd (local_temp_filename, local_temp_filename_size))
d111 1
a111 1
	  if (!getwd (local_temp_filename))
d113 9
a121 9
	    {
	      filesys_error_number = errno;
	      return (partial);
	    }

	  strcat (local_temp_filename, "/");
	  strcat (local_temp_filename, partial);
	  return (local_temp_filename);
	}
d123 1
a123 1
	temp = info_file_in_path (partial, infopath);
d126 10
a135 10
	{
	  remember_info_filename (partial, temp);
	  if (strlen (temp) > local_temp_filename_size)
	    local_temp_filename = (char *) xrealloc
	      (local_temp_filename,
	       (local_temp_filename_size = (50 + strlen (temp))));
	  strcpy (local_temp_filename, temp);
	  free (temp);
	  return (local_temp_filename);
	}
d153 1
a153 1
  while (temp_dirname = extract_colon_unit (path, &dirname_index))
d160 2
a161 2
	{
	  char *expanded_dirname;
d163 4
a166 4
	  expanded_dirname = tilde_expand_word (temp_dirname);
	  free (temp_dirname);
	  temp_dirname = expanded_dirname;
	}
d171 1
a171 1
	strcat (temp, "/");
d179 2
a180 2
	{
	  strcpy (temp + pre_suffix_length, info_suffixes[i]);
d182 1
a182 1
	  statable = (stat (temp, &finfo) == 0);
d184 43
a226 43
	  /* If we have found a regular file, then use that.  Else, if we
	     have found a directory, look in that directory for this file. */
	  if (statable)
	    {
	      if (S_ISREG (finfo.st_mode))
		{
		  return (temp);
		}
	      else if (S_ISDIR (finfo.st_mode))
		{
		  char *newpath, *filename_only, *newtemp;

		  newpath = strdup (temp);
		  filename_only = filename_non_directory (filename);
		  newtemp = info_file_in_path (filename_only, newpath);

		  free (newpath);
		  if (newtemp)
		    {
		      free (temp);
		      return (newtemp);
		    }
		}
	    }
	  else
	    {
	      /* Add various compression suffixes to the name to see if
		 the file is present in compressed format. */
	      register int j, pre_compress_suffix_length;

	      pre_compress_suffix_length = strlen (temp);

	      for (j = 0; compress_suffixes[j].suffix; j++)
		{
		  strcpy (temp + pre_compress_suffix_length,
			  compress_suffixes[j].suffix);

		  statable = (stat (temp, &finfo) == 0);
		  if (statable && (S_ISREG (finfo.st_mode)))
		    return (temp);
		}
	    }
	}
d260 1
a260 1
	++i;
d287 4
a290 4
	{
	  if (strcmp (names_and_files[i]->filename, filename) == 0)
	    return (names_and_files[i]->expansion);
	}
d310 1
a310 1
	(FILENAME_LIST **) xrealloc (names_and_files, alloc_size);
d314 2
a315 2
  new->filename = strdup (filename);
  new->expansion = expansion ? strdup (expansion) : (char *)NULL;
d327 1
a327 1
	xmalloc (infopath_size = (1 + strlen (DEFAULT_INFOPATH)));
d362 1
a362 1
      char *temp = strdup (infopath);
d406 4
a409 4
	{
	  filesys_error_number = errno;
	  return ((char *)NULL);
	}
d415 6
a420 6
	{
	  filesys_error_number = errno;
	  close (descriptor);
	  free (contents);
	  return ((char *)NULL);
	}
d480 2
a481 2
	{
	  int bytes_read;
d483 1
a483 1
	  bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);
d485 9
a493 9
	  if (bytes_read + offset >= size)
	    contents = (char *)xrealloc
	      (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));

	  memcpy (contents + offset, chunk, bytes_read);
	  offset += bytes_read;
	  if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)
	    break;
	}
d542 2
a543 2
	extension = filename + i;
	break;
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* filesys.c -- File system specific functions for hacking this system.
   $Id: filesys.c,v 1.4 1997/07/24 21:23:07 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d24 8
a31 2
#include "info.h"

d35 23
d62 5
a66 2
typedef struct
{
d117 1
a117 1
        return (expansion);
d120 2
a121 2
         various extensions to it.  I guess we have to stat this file
         after all. */
d123 1
a123 1
        temp = info_file_in_path (partial + 1, "/");
d125 10
a134 10
        {
          expansion = tilde_expand_word (partial);
          if (*expansion == '/')
            {
              temp = info_file_in_path (expansion + 1, "/");
              free (expansion);
            }
          else
            temp = expansion;
        }
d136 5
a140 5
               (partial[1] == '/' || (partial[1] == '.' && partial[2] == '/')))
        {
          if (local_temp_filename_size < 1024)
            local_temp_filename = (char *)xrealloc
              (local_temp_filename, (local_temp_filename_size = 1024));
d142 1
a142 1
          if (!getcwd (local_temp_filename, local_temp_filename_size))
d144 1
a144 1
          if (!getwd (local_temp_filename))
d146 9
a154 9
            {
              filesys_error_number = errno;
              return (partial);
            }

          strcat (local_temp_filename, "/");
          strcat (local_temp_filename, partial);
          return (local_temp_filename);
        }
d156 1
a156 1
        temp = info_file_in_path (partial, infopath);
d159 10
a168 10
        {
          remember_info_filename (partial, temp);
          if (strlen (temp) > local_temp_filename_size)
            local_temp_filename = (char *) xrealloc
              (local_temp_filename,
               (local_temp_filename_size = (50 + strlen (temp))));
          strcpy (local_temp_filename, temp);
          free (temp);
          return (local_temp_filename);
        }
d186 1
a186 1
  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))
d193 2
a194 2
        {
          char *expanded_dirname;
d196 4
a199 4
          expanded_dirname = tilde_expand_word (temp_dirname);
          free (temp_dirname);
          temp_dirname = expanded_dirname;
        }
d204 1
a204 1
        strcat (temp, "/");
d212 2
a213 2
        {
          strcpy (temp + pre_suffix_length, info_suffixes[i]);
d215 1
a215 1
          statable = (stat (temp, &finfo) == 0);
d217 43
a259 43
          /* If we have found a regular file, then use that.  Else, if we
             have found a directory, look in that directory for this file. */
          if (statable)
            {
              if (S_ISREG (finfo.st_mode))
                {
                  return (temp);
                }
              else if (S_ISDIR (finfo.st_mode))
                {
                  char *newpath, *filename_only, *newtemp;

                  newpath = xstrdup (temp);
                  filename_only = filename_non_directory (filename);
                  newtemp = info_file_in_path (filename_only, newpath);

                  free (newpath);
                  if (newtemp)
                    {
                      free (temp);
                      return (newtemp);
                    }
                }
            }
          else
            {
              /* Add various compression suffixes to the name to see if
                 the file is present in compressed format. */
              register int j, pre_compress_suffix_length;

              pre_compress_suffix_length = strlen (temp);

              for (j = 0; compress_suffixes[j].suffix; j++)
                {
                  strcpy (temp + pre_compress_suffix_length,
                          compress_suffixes[j].suffix);

                  statable = (stat (temp, &finfo) == 0);
                  if (statable && (S_ISREG (finfo.st_mode)))
                    return (temp);
                }
            }
        }
d293 1
a293 1
        ++i;
d320 4
a323 4
        {
          if (strcmp (names_and_files[i]->filename, filename) == 0)
            return (names_and_files[i]->expansion);
        }
d343 1
a343 1
        (FILENAME_LIST **) xrealloc (names_and_files, alloc_size);
d347 2
a348 2
  new->filename = xstrdup (filename);
  new->expansion = expansion ? xstrdup (expansion) : (char *)NULL;
d360 1
a360 1
        xmalloc (infopath_size = (1 + strlen (DEFAULT_INFOPATH)));
d395 1
a395 1
      char *temp = xstrdup (infopath);
d439 4
a442 4
        {
          filesys_error_number = errno;
          return ((char *)NULL);
        }
d448 6
a453 6
        {
          filesys_error_number = errno;
          close (descriptor);
          free (contents);
          return ((char *)NULL);
        }
d513 2
a514 2
        {
          int bytes_read;
d516 1
a516 1
          bytes_read = fread (chunk, 1, FILESYS_PIPE_BUFFER_SIZE, stream);
d518 9
a526 9
          if (bytes_read + offset >= size)
            contents = (char *)xrealloc
              (contents, size += (2 * FILESYS_PIPE_BUFFER_SIZE));

          memcpy (contents + offset, chunk, bytes_read);
          offset += bytes_read;
          if (bytes_read != FILESYS_PIPE_BUFFER_SIZE)
            break;
        }
d575 2
a576 2
        extension = filename + i;
        break;
@


1.1.1.3
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: filesys.c,v 1.6 1998/02/21 22:52:46 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
a40 1
  "/index",
@


1.1.1.4
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* filesys.c -- filesystem specific functions.
   $Id: filesys.c,v 1.10 1998/12/06 21:58:30 karl Exp $
a28 1
static char *info_absolute_file ();
d38 1
d42 1
a42 8
  ".inf",       /* 8+3 file on filesystem which supports long file names */
#ifdef __MSDOS__
  /* 8+3 file names strike again...  */
  ".in",        /* for .inz, .igz etc. */
  ".i",
#endif
  "",
  NULL
a45 3
  { ".gz", "gunzip" },
  { ".bz2", "bunzip2" },
  { ".z", "gunzip" },
d48 2
a49 4
#ifdef __MSDOS__
  { "gz", "gunzip" },
  { "z", "gunzip" },
#endif
d89 2
a90 2
      if (IS_ABSOLUTE (partial))
	temp = info_absolute_file (partial);
d94 1
a94 1
          if (IS_ABSOLUTE (expansion))
d96 1
a96 1
              temp = info_absolute_file (expansion);
d103 1
a103 2
               (IS_SLASH (partial[1]) ||
		(partial[1] == '.' && IS_SLASH (partial[2]))))
d120 1
a120 3
	  temp = info_absolute_file (local_temp_filename); /* try extensions */
	  if (!temp)
	    partial = local_temp_filename;
d170 1
a170 1
      if (!IS_SLASH (temp[(strlen (temp)) - 1]))
d232 2
a233 20
/* Assume FNAME is an absolute file name, and check whether it is
   a regular file.  If it is, return it as a new string; otherwise
   return a NULL pointer.  We do it by taking the file name apart
   into its directory and basename parts, and calling info_file_in_path.*/
static char *
info_absolute_file (fname)
     char *fname;
{
  char *containing_dir = xstrdup (fname);
  char *base = filename_non_directory (containing_dir);

  if (base > containing_dir)
    base[-1] = '\0';

  return info_file_in_path (filename_non_directory (fname), containing_dir);
}

/* Given a string containing units of information separated by
   the PATH_SEP character, return the next one pointed to by
   IDX, or NULL if there are no more.
d246 1
a246 1
  while (string[i] && string[i] != PATH_SEP[0])
d288 1
a288 1
          if (FILENAME_CMP (names_and_files[i]->filename, filename) == 0)
d357 1
a357 1
      strcat (infopath, PATH_SEP);
d364 1
a364 1
      strcat (infopath, PATH_SEP);
a380 36
/* Given a chunk of text and its length, convert all CRLF pairs at every
   end-of-line into a single Newline character.  Return the length of
   produced text.

   This is required because the rest of code is too entrenched in having
   a single newline at each EOL; in particular, searching for various
   Info headers and cookies can become extremely tricky if that assumption
   breaks.

   FIXME: this could also support Mac-style text files with a single CR
   at the EOL, but what about random CR characters in non-Mac files?  Can
   we afford converting them into newlines as well?  Maybe implement some
   heuristics here, like in Emacs 20.

   FIXME: is it a good idea to show the EOL type on the modeline?  */
long
convert_eols (text, textlen)
     char *text;
     long textlen;
{
  register char *s = text;
  register char *d = text;

  while (textlen--)
    {
      if (*s == '\r' && textlen && s[1] == '\n')
	{
	  s++;
	  textlen--;
	}
      *d++ = *s++;
    }

  return (long)(d - text);
}

a383 1
   If the file turns out to be compressed, set IS_COMPRESSED to non-zero.
d386 1
a386 1
filesys_read_info_file (pathname, filesize, finfo, is_compressed)
a389 1
     int *is_compressed;
d396 1
a396 4
    {
      *is_compressed = 1;
      return (filesys_read_compressed (pathname, filesize, finfo));
    }
d402 1
a402 2
      *is_compressed = 0;
      descriptor = open (pathname, O_RDONLY | O_BINARY, 0666);
d416 4
a419 4
	  filesys_error_number = errno;
	  close (descriptor);
	  free (contents);
	  return ((char *)NULL);
d424 1
a424 10
      /* Convert any DOS-style CRLF EOLs into Unix-style NL.
	 Seems like a good idea to have even on Unix, in case the Info
	 files are coming from some Windows system across a network.  */
      *filesize = convert_eols (contents, st_size);

      /* EOL conversion can shrink the text quite a bit.  We don't
	 want to waste storage.  */
      if (*filesize < st_size)
	contents = (char *)xrealloc (contents, 1 + *filesize);

d452 2
a453 5
  command = (char *)xmalloc (15 + strlen (pathname) + strlen (decompressor));
  /* Explicit .exe suffix makes the diagnostics of `popen'
     better on systems where COMMAND.COM is the stock shell.  */
  sprintf (command, "%s%s < %s",
	   decompressor, STRIP_DOT_EXE ? ".exe" : "", pathname);
d467 1
a467 1
  stream = popen (command, FOPEN_RBIN);
d496 3
a498 12
      if (pclose (stream) == -1)
	{
	  if (contents)
	    free (contents);
	  contents = (char *)NULL;
	  filesys_error_number = errno;
	}
      else
	{
	  *filesize = convert_eols (contents, offset);
	  contents = (char *)xrealloc (contents, 1 + *filesize);
	}
d550 1
a550 1
    if (FILENAME_CMP (extension, compress_suffixes[i].suffix) == 0)
a552 10
#if defined (__MSDOS__)
  /* If no other suffix matched, allow any extension which ends
     with `z' to be decompressed by gunzip.  Due to limited 8+3 DOS
     file namespace, we can expect many such cases, and supporting
     every weird suffix thus produced would be a pain.  */
  if (extension[strlen (extension) - 1] == 'z' ||
      extension[strlen (extension) - 1] == 'Z')
    return "gunzip";
#endif

a584 23

/* Check for FILENAME eq "dir" first, then all the compression
   suffixes.  */

int
is_dir_name (filename)
    char *filename;
{
  unsigned i;
  if (strcasecmp (filename, "dir") == 0)
    return 1;
  
  for (i = 0; compress_suffixes[i].suffix; i++)
    {
      char dir_compressed[50]; /* can be short */
      strcpy (dir_compressed, "dir"); 
      strcat (dir_compressed, compress_suffixes[i].suffix);
      if (strcasecmp (filename, dir_compressed) == 0)
        return 1;
    }
  
  return 0;
}
@


1.1.1.5
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: filesys.c,v 1.15 2002/03/23 20:45:24 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 2000 Free Software Foundation, Inc.
a165 5
  /* Reject ridiculous cases up front, to prevent infinite recursion
     later on.  E.g., someone might say "info '(.)foo'"...  */
  if (!*filename || STREQ (filename, ".") || STREQ (filename, ".."))
    return NULL;

a507 1
      contents[*filesize] = '\0';
d560 1
a560 1
      long offset, size;
a593 1
	  contents[*filesize] = '\0';
d692 2
a693 2
/* Check for "dir" with all the possible info and compression suffixes,
   in combination.  */
d700 4
a703 2

  for (i = 0; info_suffixes[i]; i++)
d705 4
a708 6
      unsigned c;
      char trydir[50];
      strcpy (trydir, "dir");
      strcat (trydir, info_suffixes[i]);
      
      if (strcasecmp (filename, trydir) == 0)
d710 2
a711 11

      for (c = 0; compress_suffixes[c].suffix; c++)
        {
          char dir_compressed[50]; /* can be short */
          strcpy (dir_compressed, trydir); 
          strcat (dir_compressed, compress_suffixes[c].suffix);
          if (strcasecmp (filename, dir_compressed) == 0)
            return 1;
        }
    }  

@


1.1.1.6
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: filesys.c,v 1.6 2004/07/30 17:17:40 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d28 3
a30 6
static char *info_file_in_path (char *filename, char *path);
static char *lookup_info_filename (char *filename);
static char *info_absolute_file (char *fname);

static void remember_info_filename (char *filename, char *expansion);
static void maybe_initialize_infopath (void);
d79 2
a80 1
info_find_fullpath (char *partial)
d143 1
a143 1
          if (strlen (temp) > (unsigned int) local_temp_filename_size)
d159 2
a160 1
info_file_in_path (char *filename, char *path)
d257 2
a258 1
info_absolute_file (char *fname)
d269 4
a272 5

/* Given a string containing units of information separated by the
   PATH_SEP character, return the next one after IDX, or NULL if there
   are no more.  Advance IDX to the character after the colon. */

d274 9
a282 10
extract_colon_unit (char *string, int *idx)
{
  unsigned int i = (unsigned int) *idx;
  unsigned int start = i;

  if (!string || i >= strlen (string))
    return NULL;

  if (!string[i]) /* end of string */
    return NULL;
a283 1
  /* Advance to next PATH_SEP.  */
d286 7
d294 8
a301 9
  {
    char *value = xmalloc ((i - start) + 1);
    strncpy (value, &string[start], (i - start));
    value[i - start] = 0;

    i++; /* move past PATH_SEP */
    *idx = i;
    return value;
  }
d305 1
a305 2
typedef struct
{
d318 2
a319 1
lookup_info_filename (char *filename)
d335 2
a336 1
remember_info_filename (char *filename, char *expansion)
d360 1
a360 1
maybe_initialize_infopath (void)
d374 3
a376 1
info_add_path (char *path, int where)
d410 1
a410 1
zap_infopath (void)
d435 3
a437 1
convert_eols (char *text, long int textlen)
d461 5
a465 2
filesys_read_info_file (char *pathname, long int *filesize,
    struct stat *finfo, int *is_compressed)
d474 1
a474 1
      return (filesys_read_compressed (pathname, filesize));
d526 4
a529 1
filesys_read_compressed (char *pathname, long int *filesize)
d555 1
a555 1
      message_in_echo_area ("%s", temp, NULL);
d617 2
a618 1
compressed_filename_p (char *filename)
d634 2
a635 1
filesys_decompressor_for_file (char *filename)
d678 3
a680 1
filesys_error_string (char *filename, int error_num)
d703 2
a704 1
is_dir_name (char *filename)
@


