head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.48
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.6
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.5
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.3
	OPENBSD_2_4:1.1.1.3.0.6
	OPENBSD_2_4_BASE:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.4
	OPENBSD_2_3_BASE:1.1.1.3
	OPENBSD_2_2:1.1.1.3.0.2
	OPENBSD_2_2_BASE:1.1.1.3
	TEXINFO_3_11:1.1.1.3
	OPENBSD_2_1:1.1.1.2.0.4
	OPENBSD_2_1_BASE:1.1.1.2
	TEXINFO_3_9:1.1.1.2
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	TEXINFO_3_7:1.1.1.2
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.07.30.17.34.47;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.08.01.22.00.27;	author kstailey;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.09.01.24.50;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.06.10.13.21.07;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/*  man.c: How to read and format man files.
    $Id: man.c,v 1.4 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox Thu May  4 09:17:52 1995 (bfox@@ai.mit.edu). */

#include "info.h"
#include <sys/ioctl.h>
#include "signals.h"
#if defined (HAVE_SYS_TIME_H)
#include <sys/time.h>
#endif
#if defined (HAVE_SYS_WAIT_H)
#include <sys/wait.h>
#endif

#include "tilde.h"
#include "man.h"

#if !defined (_POSIX_VERSION)
#define pid_t int
#endif

#if defined (FD_SET)
#  if defined (hpux)
#    define fd_set_cast(x) (int *)(x)
#  else
#    define fd_set_cast(x) (fd_set *)(x)
#  endif /* !hpux */
#endif /* FD_SET */

#if STRIP_DOT_EXE
static char const * const exec_extensions[] = {
  ".exe", ".com", ".bat", ".btm", ".sh", ".ksh", ".pl", ".sed", "", NULL
};
#else
static char const * const exec_extensions[] = { "", NULL };
#endif

static char *read_from_fd (int fd);
static void clean_manpage (char *manpage);
static NODE *manpage_node_of_file_buffer (FILE_BUFFER *file_buffer,
    char *pagename);
static char *get_manpage_contents (char *pagename);

NODE *
make_manpage_node (char *pagename)
{
  return (info_get_node (MANPAGE_FILE_BUFFER_NAME, pagename));
}

NODE *
get_manpage_node (FILE_BUFFER *file_buffer, char *pagename)
{
  NODE *node;

  node = manpage_node_of_file_buffer (file_buffer, pagename);

  if (!node)
    {
      char *page;

      page = get_manpage_contents (pagename);

      if (page)
        {
          char header[1024];
          long oldsize, newsize;
          int hlen, plen;
	  char *old_contents = file_buffer->contents;

          sprintf (header, "\n\n%c\n%s %s,  %s %s,  %s (dir)\n\n",
                   INFO_COOKIE,
                   INFO_FILE_LABEL, file_buffer->filename,
                   INFO_NODE_LABEL, pagename,
                   INFO_UP_LABEL);
          oldsize = file_buffer->filesize;
          hlen = strlen (header);
          plen = strlen (page);
          newsize = (oldsize + hlen + plen);
          file_buffer->contents =
            (char *)xrealloc (file_buffer->contents, 1 + newsize);
          memcpy (file_buffer->contents + oldsize, header, hlen);
          memcpy (file_buffer->contents + oldsize + hlen, page, plen);
          file_buffer->contents[newsize] = '\0';
          file_buffer->filesize = newsize;
          file_buffer->finfo.st_size = newsize;
          build_tags_and_nodes (file_buffer);
          free (page);
	  /* We have just relocated file_buffer->contents from under
	     the feet of info_windows[] array.  Therefore, all the
	     nodes on that list which are showing man pages have their
	     contents member pointing into the blue.  Undo that harm.  */
	  if (old_contents && oldsize && old_contents != file_buffer->contents)
	    {
	      int iw;
	      INFO_WINDOW *info_win;
	      char *old_contents_end = old_contents + oldsize;

	      for (iw = 0; (info_win = info_windows[iw]); iw++)
		{
		  int in;

		  for (in = 0; in < info_win->nodes_index; in++)
		    {
		      NODE *tmp_node = info_win->nodes[in];

		      /* It really only suffices to see that node->filename
			 is "*manpages*".  But after several hours of
			 debugging this, would you blame me for being a bit
			 paranoid?  */
		      if (tmp_node && tmp_node->filename
                          && tmp_node->contents
                          && strcmp (tmp_node->filename,
				  MANPAGE_FILE_BUFFER_NAME) == 0
                          && tmp_node->contents >= old_contents
                          && tmp_node->contents + tmp_node->nodelen
                                <= old_contents_end)
			{
			  info_win->nodes[in] =
			    manpage_node_of_file_buffer (file_buffer,
                                tmp_node->nodename);
			  free (tmp_node->nodename);
			  free (tmp_node);
			}
		    }
		}
	    }
        }

      node = manpage_node_of_file_buffer (file_buffer, pagename);
    }

  return (node);
}

FILE_BUFFER *
create_manpage_file_buffer (void)
{
  FILE_BUFFER *file_buffer = make_file_buffer ();
  file_buffer->filename = xstrdup (MANPAGE_FILE_BUFFER_NAME);
  file_buffer->fullpath = xstrdup (MANPAGE_FILE_BUFFER_NAME);
  file_buffer->finfo.st_size = 0;
  file_buffer->filesize = 0;
  file_buffer->contents = (char *)NULL;
  file_buffer->flags = (N_IsInternal | N_CannotGC | N_IsManPage);

  return (file_buffer);
}

/* Scan the list of directories in PATH looking for FILENAME.  If we find
   one that is an executable file, return it as a new string.  Otherwise,
   return a NULL pointer. */
static char *
executable_file_in_path (char *filename, char *path)
{
  struct stat finfo;
  char *temp_dirname;
  int statable, dirname_index;

  dirname_index = 0;

  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))
    {
      char *temp;
      char *temp_end;
      int i;

      /* Expand a leading tilde if one is present. */
      if (*temp_dirname == '~')
        {
          char *expanded_dirname;

          expanded_dirname = tilde_expand_word (temp_dirname);
          free (temp_dirname);
          temp_dirname = expanded_dirname;
        }

      temp = (char *)xmalloc (34 + strlen (temp_dirname) + strlen (filename));
      strcpy (temp, temp_dirname);
      if (!IS_SLASH (temp[(strlen (temp)) - 1]))
        strcat (temp, "/");
      strcat (temp, filename);
      temp_end = temp + strlen (temp);

      free (temp_dirname);

      /* Look for FILENAME, possibly with any of the extensions
	 in EXEC_EXTENSIONS[].  */
      for (i = 0; exec_extensions[i]; i++)
	{
	  if (exec_extensions[i][0])
	    strcpy (temp_end, exec_extensions[i]);
	  statable = (stat (temp, &finfo) == 0);

	  /* If we have found a regular executable file, then use it. */
	  if ((statable) && (S_ISREG (finfo.st_mode)) &&
	      (access (temp, X_OK) == 0))
	    return (temp);
	}

      free (temp);
    }
  return ((char *)NULL);
}

/* Return the full pathname of the system man page formatter. */
static char *
find_man_formatter (void)
{
  return (executable_file_in_path ("man", (char *)getenv ("PATH")));
}

static char *manpage_pagename = (char *)NULL;
static char *manpage_section  = (char *)NULL;

static void
get_page_and_section (char *pagename)
{
  register int i;

  if (manpage_pagename)
    free (manpage_pagename);

  if (manpage_section)
    free (manpage_section);

  manpage_pagename = (char *)NULL;
  manpage_section  = (char *)NULL;

  for (i = 0; pagename[i] != '\0' && pagename[i] != '('; i++);

  manpage_pagename = (char *)xmalloc (1 + i);
  strncpy (manpage_pagename, pagename, i);
  manpage_pagename[i] = '\0';

  if (pagename[i] == '(')
    {
      int start;

      start = i + 1;

      for (i = start; pagename[i] != '\0' && pagename[i] != ')'; i++);

      manpage_section = (char *)xmalloc (1 + (i - start));
      strncpy (manpage_section, pagename + start, (i - start));
      manpage_section[i - start] = '\0';
    }
}

#if PIPE_USE_FORK
static void
reap_children (int sig)
{
  wait (NULL);
}
#endif

static char *
get_manpage_contents (char *pagename)
{
  static char *formatter_args[4] = { (char *)NULL };
  int pipes[2];
  pid_t child;
  RETSIGTYPE (*sigsave) (int signum);
  char *formatted_page = NULL;
  int arg_index = 1;

  if (formatter_args[0] == (char *)NULL)
    formatter_args[0] = find_man_formatter ();

  if (formatter_args[0] == (char *)NULL)
    return ((char *)NULL);

  get_page_and_section (pagename);

  if (manpage_section != (char *)NULL)
    formatter_args[arg_index++] = manpage_section;

  formatter_args[arg_index++] = manpage_pagename;
  formatter_args[arg_index] = (char *)NULL;

  /* Open a pipe to this program, read the output, and save it away
     in FORMATTED_PAGE.  The reader end of the pipe is pipes[0]; the
     writer end is pipes[1]. */
#if PIPE_USE_FORK
  pipe (pipes);

  sigsave = signal (SIGCHLD, reap_children);

  child = fork ();
  if (child == -1)
    return ((char *)NULL);

  if (child != 0)
    {
      /* In the parent, close the writing end of the pipe, and read from
         the exec'd child. */
      close (pipes[1]);
      formatted_page = read_from_fd (pipes[0]);
      close (pipes[0]);
      signal (SIGCHLD, sigsave);
    }
  else
    { /* In the child, close the read end of the pipe, make the write end
         of the pipe be stdout, and execute the man page formatter. */
      close (pipes[0]);
      freopen (NULL_DEVICE, "w", stderr);
      freopen (NULL_DEVICE, "r", stdin);
      dup2 (pipes[1], fileno (stdout));

      execv (formatter_args[0], formatter_args);

      /* If we get here, we couldn't exec, so close out the pipe and
         exit. */
      close (pipes[1]);
      xexit (0);
    }
#else  /* !PIPE_USE_FORK */
  /* Cannot fork/exec, but can popen/pclose.  */
  {
    FILE *fpipe;
    char *cmdline = xmalloc (strlen (formatter_args[0])
			     + strlen (manpage_pagename)
			     + (arg_index > 2 ? strlen (manpage_section) : 0)
 			     + 3);
    int save_stderr = dup (fileno (stderr));
    int fd_err = open (NULL_DEVICE, O_WRONLY, 0666);

    if (fd_err > 2)
      dup2 (fd_err, fileno (stderr)); /* Don't print errors. */
    sprintf (cmdline, "%s %s %s", formatter_args[0], manpage_pagename,
				  arg_index > 2 ? manpage_section : "");
    fpipe = popen (cmdline, "r");
    free (cmdline);
    if (fd_err > 2)
      close (fd_err);
    dup2 (save_stderr, fileno (stderr));
    if (fpipe == 0)
      return ((char *)NULL);
    formatted_page = read_from_fd (fileno (fpipe));
    if (pclose (fpipe) == -1)
      {
	if (formatted_page)
	  free (formatted_page);
	return ((char *)NULL);
      }
  }
#endif /* !PIPE_USE_FORK */

  /* If we have the page, then clean it up. */
  if (formatted_page)
    clean_manpage (formatted_page);

  return (formatted_page);
}

static void
clean_manpage (char *manpage)
{
  register int i, j;
  int newline_count = 0;
  char *newpage;

  newpage = (char *)xmalloc (1 + strlen (manpage));

  for (i = 0, j = 0; (newpage[j] = manpage[i]); i++, j++)
    {
      if (manpage[i] == '\n')
        newline_count++;
      else
        newline_count = 0;

      if (newline_count == 3)
        {
          j--;
          newline_count--;
        }

      /* A malformed man page could have a \b as its first character,
         in which case decrementing j by 2 will cause us to write into
         newpage[-1], smashing the hidden info stored there by malloc.  */
      if (manpage[i] == '\b' || (manpage[i] == '\f' && j > 0))
        j -= 2;
      else if (!raw_escapes_p)
	{
	  /* Remove the ANSI escape sequences for color, boldface,
	     underlining, and italics, generated by some versions of
	     Groff.  */
	  if (manpage[i] == '\033' && manpage[i + 1] == '['
	      && isdigit (manpage[i + 2]))
	    {
	      if (isdigit (manpage[i + 3]) && manpage[i + 4] == 'm')
		{
		  i += 4;
		  j--;
		}
	      else if (manpage[i + 3] == 'm')
		{
		  i += 3;
		  j--;
		}
	      /* Else do nothing: it's some unknown escape sequence,
		 so let's leave it alone.  */
	    }
	}
    }

  newpage[j++] = 0;

  strcpy (manpage, newpage);
  free (newpage);
}

static NODE *
manpage_node_of_file_buffer (FILE_BUFFER *file_buffer, char *pagename)
{
  NODE *node = (NODE *)NULL;
  TAG *tag = (TAG *)NULL;

  if (file_buffer->contents)
    {
      register int i;

      for (i = 0; (tag = file_buffer->tags[i]); i++)
        {
          if (strcasecmp (pagename, tag->nodename) == 0)
            break;
        }
    }

  if (tag)
    {
      node = (NODE *)xmalloc (sizeof (NODE));
      node->filename = file_buffer->filename;
      node->nodename = xstrdup (tag->nodename);
      node->contents = file_buffer->contents + tag->nodestart;
      node->nodelen = tag->nodelen;
      node->flags    = 0;
      node->display_pos = 0;
      node->parent   = (char *)NULL;
      node->flags = (N_HasTagsTable | N_IsManPage);
      node->contents += skip_node_separator (node->contents);
    }

  return (node);
}

static char *
read_from_fd (int fd)
{
  struct timeval timeout;
  char *buffer = (char *)NULL;
  int bsize = 0;
  int bindex = 0;
  int select_result;
#if defined (FD_SET)
  fd_set read_fds;

  timeout.tv_sec = 15;
  timeout.tv_usec = 0;

  FD_ZERO (&read_fds);
  FD_SET (fd, &read_fds);

  select_result = select (fd + 1, fd_set_cast (&read_fds), 0, 0, &timeout);
#else /* !FD_SET */
  select_result = 1;
#endif /* !FD_SET */

  switch (select_result)
    {
    case 0:
    case -1:
      break;

    default:
      {
        int amount_read;
        int done = 0;

        while (!done)
          {
            while ((bindex + 1024) > (bsize))
              buffer = (char *)xrealloc (buffer, (bsize += 1024));
            buffer[bindex] = '\0';

            amount_read = read (fd, buffer + bindex, 1023);

            if (amount_read < 0)
              {
                done = 1;
              }
            else
              {
                bindex += amount_read;
                buffer[bindex] = '\0';
                if (amount_read == 0)
                  done = 1;
              }
          }
      }
    }

  if ((buffer != (char *)NULL) && (*buffer == '\0'))
    {
      free (buffer);
      buffer = (char *)NULL;
    }

  return (buffer);
}

static char *reference_section_starters[] =
{
  "\nRELATED INFORMATION",
  "\nRELATED\tINFORMATION",
  "RELATED INFORMATION\n",
  "RELATED\tINFORMATION\n",
  "\nSEE ALSO",
  "\nSEE\tALSO",
  "SEE ALSO\n",
  "SEE\tALSO\n",
  (char *)NULL
};

static SEARCH_BINDING frs_binding;

static SEARCH_BINDING *
find_reference_section (NODE *node)
{
  register int i;
  long position = -1;

  frs_binding.buffer = node->contents;
  frs_binding.start = 0;
  frs_binding.end = node->nodelen;
  frs_binding.flags = S_SkipDest;

  for (i = 0; reference_section_starters[i] != (char *)NULL; i++)
    {
      position = search_forward (reference_section_starters[i], &frs_binding);
      if (position != -1)
        break;
    }

  if (position == -1)
    return ((SEARCH_BINDING *)NULL);

  /* We found the start of the reference section, and point is right after
     the string which starts it.  The text from here to the next header
     (or end of buffer) contains the only references in this manpage. */
  frs_binding.start = position;

  for (i = frs_binding.start; i < frs_binding.end - 2; i++)
    {
      if ((frs_binding.buffer[i] == '\n') &&
          (!whitespace (frs_binding.buffer[i + 1])))
        {
          frs_binding.end = i;
          break;
        }
    }

  return (&frs_binding);
}

REFERENCE **
xrefs_of_manpage (NODE *node)
{
  SEARCH_BINDING *reference_section;
  REFERENCE **refs = (REFERENCE **)NULL;
  int refs_index = 0;
  int refs_slots = 0;
  long position;

  reference_section = find_reference_section (node);

  if (reference_section == (SEARCH_BINDING *)NULL)
    return ((REFERENCE **)NULL);

  /* Grovel the reference section building a list of references found there.
     A reference is alphabetic characters followed by non-whitespace text
     within parenthesis. */
  reference_section->flags = 0;

  while ((position = search_forward ("(", reference_section)) != -1)
    {
      register int start, end;

      for (start = position; start > reference_section->start; start--)
        if (whitespace (reference_section->buffer[start]))
          break;

      start++;

      for (end = position; end < reference_section->end; end++)
        {
          if (whitespace (reference_section->buffer[end]))
            {
              end = start;
              break;
            }

          if (reference_section->buffer[end] == ')')
            {
              end++;
              break;
            }
        }

      if (end != start)
        {
          REFERENCE *entry;
          int len = end - start;

          entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
          entry->label = (char *)xmalloc (1 + len);
          strncpy (entry->label, (reference_section->buffer) + start, len);
          entry->label[len] = '\0';
          entry->filename = xstrdup (node->filename);
          entry->nodename = xstrdup (entry->label);
          entry->start = start;
          entry->end = end;

          add_pointer_to_array
            (entry, refs_index, refs, refs_slots, 10, REFERENCE *);
        }

      reference_section->start = position + 1;
    }

  return (refs);
}

long
locate_manpage_xref (NODE *node, long int start, int dir)
{
  REFERENCE **refs;
  long position = -1;

  refs = xrefs_of_manpage (node);

  if (refs)
    {
      register int i, count;
      REFERENCE *entry;

      for (i = 0; refs[i]; i++);
      count = i;

      if (dir > 0)
        {
          for (i = 0; (entry = refs[i]); i++)
            if (entry->start > start)
              {
                position = entry->start;
                break;
              }
        }
      else
        {
          for (i = count - 1; i > -1; i--)
            {
              entry = refs[i];

              if (entry->start < start)
                {
                  position = entry->start;
                  break;
                }
            }
        }

      info_free_references (refs);
    }
  return (position);
}

/* This one was a little tricky.  The binding buffer that is passed in has
   a START and END value of 0 -- strlen (window-line-containing-point).
   The BUFFER is a pointer to the start of that line. */
REFERENCE **
manpage_xrefs_in_binding (NODE *node, SEARCH_BINDING *binding)
{
  register int i;
  REFERENCE **all_refs = xrefs_of_manpage (node);
  REFERENCE **brefs = (REFERENCE **)NULL;
  REFERENCE *entry;
  int brefs_index = 0;
  int brefs_slots = 0;
  int start, end;

  if (!all_refs)
    return ((REFERENCE **)NULL);

  start = binding->start + (binding->buffer - node->contents);
  end = binding->end + (binding->buffer - node->contents);

  for (i = 0; (entry = all_refs[i]); i++)
    {
      if ((entry->start > start) && (entry->end < end))
        {
          add_pointer_to_array
            (entry, brefs_index, brefs, brefs_slots, 10, REFERENCE *);
        }
      else
        {
          maybe_free (entry->label);
          maybe_free (entry->filename);
          maybe_free (entry->nodename);
          free (entry);
        }
    }

  free (all_refs);
  return (brefs);
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
    $Id: man.c,v 1.16 2002/02/23 19:12:02 karl Exp $
d4 2
a5 1
   Copyright (C) 1995, 97, 98, 99, 2000 Free Software Foundation, Inc.
d56 5
a60 4
static char *read_from_fd ();
static void clean_manpage ();
static NODE *manpage_node_of_file_buffer ();
static char *get_manpage_contents ();
d63 1
a63 2
make_manpage_node (pagename)
     char *pagename;
d69 1
a69 3
get_manpage_node (file_buffer, pagename)
     FILE_BUFFER *file_buffer;
     char *pagename;
d122 1
a122 1
		      NODE *node = info_win->nodes[in];
d128 7
a134 5
		      if (node && node->filename && node->contents &&
			  strcmp (node->filename,
				  MANPAGE_FILE_BUFFER_NAME) == 0 &&
			  node->contents >= old_contents &&
			  node->contents + node->nodelen <= old_contents_end)
d138 3
a140 3
							 node->nodename);
			  free (node->nodename);
			  free (node);
d154 1
a154 1
create_manpage_file_buffer ()
d163 1
a163 1
  
d171 1
a171 2
executable_file_in_path (filename, path)
     char *filename, *path;
d225 1
a225 1
find_man_formatter ()
d234 1
a234 2
get_page_and_section (pagename)
     char *pagename;
d269 1
a269 2
reap_children (sig)
     int sig;
d276 1
a276 2
get_manpage_contents (pagename)
     char *pagename;
d281 1
a281 1
  RETSIGTYPE (*sigsave) ();
d375 1
a375 2
clean_manpage (manpage)
     char *manpage;
d399 1
a399 1
      if (manpage[i] == '\b' || manpage[i] == '\f' && j > 0)
d432 1
a432 3
manpage_node_of_file_buffer (file_buffer, pagename)
     FILE_BUFFER *file_buffer;
     char *pagename;
d466 1
a466 2
read_from_fd (fd)
     int fd;
d546 1
a546 2
find_reference_section (node)
     NODE *node;
d585 1
a585 2
xrefs_of_manpage (node)
     NODE *node;
d653 1
a653 4
locate_manpage_xref (node, start, dir)
     NODE *node;
     long start;
     int dir;
d700 1
a700 3
manpage_xrefs_in_binding (node, binding)
     NODE *node;
     SEARCH_BINDING *binding;
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
    $Id: man.c,v 1.13 1999/07/05 20:43:23 karl Exp $
d4 1
a4 1
   Copyright (C) 1995, 97, 98, 99 Free Software Foundation, Inc.
d400 4
a403 1
      if (manpage[i] == '\b' || manpage[i] == '\f')
d405 22
d429 1
a429 1
  newpage[j++] = '\0';
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
    $Id: man.c,v 1.6 1997/07/31 23:49:59 karl Exp $
d4 1
a4 1
   Copyright (C) 1995, 97 Free Software Foundation, Inc.
d47 8
d87 1
d101 1
a101 2
          oldsize += hlen;
          memcpy (file_buffer->contents + oldsize, page, plen);
d107 37
d182 2
d195 1
a195 1
      temp = (char *)xmalloc (30 + strlen (temp_dirname) + strlen (filename));
d197 1
a197 1
      if (temp[(strlen (temp)) - 1] != '/')
d200 1
d204 13
a216 1
      statable = (stat (temp, &finfo) == 0);
d218 1
a218 6
      /* If we have found a regular executable file, then use it. */
      if ((statable) && (S_ISREG (finfo.st_mode)) &&
          (access (temp, X_OK) == 0))
        return (temp);
      else
        free (temp);
d268 1
d273 1
a273 2
  int status;
  wait (&status);
d275 1
d284 2
a285 1
  char *formatted_page = (char *)NULL;
d305 1
d308 1
a308 1
  signal (SIGCHLD, reap_children);
a310 1

d321 1
d324 1
a324 2
    {
      /* In the child, close the read end of the pipe, make the write end
d327 2
a328 2
      close (fileno (stderr));
      close (fileno (stdin));   /* Don't print errors. */
d336 1
a336 1
      exit (0);
d338 31
d433 1
a433 1
      node->nodename = tag->nodename;
d437 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*  man.c: How to read and format man files. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1995 Free Software Foundation, Inc.
a23 1
#include <sys/file.h>
d31 1
a32 1

d75 25
a99 25
	{
	  char header[1024];
	  long oldsize, newsize;
	  int hlen, plen;

	  sprintf (header, "\n\n%c\n%s %s,  %s %s,  %s (dir)\n\n",
		   INFO_COOKIE,
		   INFO_FILE_LABEL, file_buffer->filename,
		   INFO_NODE_LABEL, pagename,
		   INFO_UP_LABEL);
	  oldsize = file_buffer->filesize;
	  hlen = strlen (header);
	  plen = strlen (page);
	  newsize = (oldsize + hlen + plen);
	  file_buffer->contents =
	    (char *)xrealloc (file_buffer->contents, 1 + newsize);
	  memcpy (file_buffer->contents + oldsize, header, hlen);
	  oldsize += hlen;
	  memcpy (file_buffer->contents + oldsize, page, plen);
	  file_buffer->contents[newsize] = '\0';
	  file_buffer->filesize = newsize;
	  file_buffer->finfo.st_size = newsize;
	  build_tags_and_nodes (file_buffer);
	  free (page);
	}
d110 3
a112 6
  FILE_BUFFER *file_buffer;
  struct stat *finfo;

  file_buffer = make_file_buffer ();
  file_buffer->filename = strdup (MANPAGE_FILE_BUFFER_NAME);
  file_buffer->fullpath = strdup (MANPAGE_FILE_BUFFER_NAME);
d134 1
a134 1
  while (temp_dirname = extract_colon_unit (path, &dirname_index))
a135 1
      register int i;
d140 2
a141 2
	{
	  char *expanded_dirname;
d143 4
a146 4
	  expanded_dirname = tilde_expand_word (temp_dirname);
	  free (temp_dirname);
	  temp_dirname = expanded_dirname;
	}
d151 1
a151 1
	strcat (temp, "/");
d160 2
a161 2
	  (access (temp, X_OK) == 0))
	return (temp);
d163 1
a163 1
	free (temp);
d217 1
a217 1
  unsigned int status;
a228 1
  char *section = (char *)NULL;
d256 1
a256 1
  
d260 1
a260 1
	 the exec'd child. */
d268 1
a268 1
	 of the pipe be stdout, and execute the man page formatter. */
d271 1
a271 1
      close (fileno (stdin));	/* Don't print errors. */
d277 1
a277 1
	 exit. */
d299 1
a299 1
  for (i = 0, j = 0; newpage[j] = manpage[i]; i++, j++)
d302 1
a302 1
	newline_count++;
d304 1
a304 1
	newline_count = 0;
d307 4
a310 4
	{
	  j--;
	  newline_count--;
	}
d312 2
a313 2
      if (manpage[i] == '\b')
	j -= 2;
d334 5
a338 5
      for (i = 0; tag = file_buffer->tags[i]; i++)
	{
	  if (strcasecmp (pagename, tag->nodename) == 0)
	    break;
	}
d454 1
a454 1
	break;
d468 5
a472 5
	  (!whitespace (frs_binding.buffer[i + 1])))
	{
	  frs_binding.end = i;
	  break;
	}
d503 2
a504 2
	if (whitespace (reference_section->buffer[start]))
	  break;
d509 13
a521 13
	{
	  if (whitespace (reference_section->buffer[end]))
	    {
	      end = start;
	      break;
	    }

	  if (reference_section->buffer[end] == ')')
	    {
	      end++;
	      break;
	    }
	}
d524 16
a539 16
	{
	  REFERENCE *entry;
	  int len = end - start;

	  entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
	  entry->label = (char *)xmalloc (1 + len);
	  strncpy (entry->label, (reference_section->buffer) + start, len);
	  entry->label[len] = '\0';
	  entry->filename = strdup (node->filename);
	  entry->nodename = strdup (entry->label);
	  entry->start = start;
	  entry->end = end;

	  add_pointer_to_array
	    (entry, refs_index, refs, refs_slots, 10, REFERENCE *);
	}
a552 1
  register int i, count;
d567 8
a574 8
	{
	  for (i = 0; entry = refs[i]; i++)
	    if (entry->start > start)
	      {
		position = entry->start;
		break;
	      }
	}
d576 12
a587 12
	{
	  for (i = count - 1; i > 0; i--)
	    {
	      entry = refs[i];

	      if (entry->start < start)
		{
		  position = entry->start;
		  break;
		}
	    }
	}
d616 1
a616 1
  for (i = 0; entry = all_refs[i]; i++)
d619 4
a622 4
	{
	  add_pointer_to_array
	    (entry, brefs_index, brefs, brefs_slots, 10, REFERENCE *);
	}
d624 6
a629 6
	{
	  maybe_free (entry->label);
	  maybe_free (entry->filename);
	  maybe_free (entry->nodename);
	  free (entry);
	}
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@import of texinfo 3.7
@
text
@d264 1
a264 1

d320 1
a320 1
      if (manpage[i] == '\b' || manpage[i] == '\f')
d586 1
a586 1
	  for (i = count - 1; i > -1; i--)
@


1.1.1.3
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/*  man.c: How to read and format man files.
    $Id: man.c,v 1.6 1997/07/31 23:49:59 karl Exp $
d3 4
a6 1
   Copyright (C) 1995, 97 Free Software Foundation, Inc.
d26 1
d34 1
a35 1
#include "tilde.h"
d78 25
a102 25
        {
          char header[1024];
          long oldsize, newsize;
          int hlen, plen;

          sprintf (header, "\n\n%c\n%s %s,  %s %s,  %s (dir)\n\n",
                   INFO_COOKIE,
                   INFO_FILE_LABEL, file_buffer->filename,
                   INFO_NODE_LABEL, pagename,
                   INFO_UP_LABEL);
          oldsize = file_buffer->filesize;
          hlen = strlen (header);
          plen = strlen (page);
          newsize = (oldsize + hlen + plen);
          file_buffer->contents =
            (char *)xrealloc (file_buffer->contents, 1 + newsize);
          memcpy (file_buffer->contents + oldsize, header, hlen);
          oldsize += hlen;
          memcpy (file_buffer->contents + oldsize, page, plen);
          file_buffer->contents[newsize] = '\0';
          file_buffer->filesize = newsize;
          file_buffer->finfo.st_size = newsize;
          build_tags_and_nodes (file_buffer);
          free (page);
        }
d113 6
a118 3
  FILE_BUFFER *file_buffer = make_file_buffer ();
  file_buffer->filename = xstrdup (MANPAGE_FILE_BUFFER_NAME);
  file_buffer->fullpath = xstrdup (MANPAGE_FILE_BUFFER_NAME);
d140 1
a140 1
  while ((temp_dirname = extract_colon_unit (path, &dirname_index)))
d142 1
d147 2
a148 2
        {
          char *expanded_dirname;
d150 4
a153 4
          expanded_dirname = tilde_expand_word (temp_dirname);
          free (temp_dirname);
          temp_dirname = expanded_dirname;
        }
d158 1
a158 1
        strcat (temp, "/");
d167 2
a168 2
          (access (temp, X_OK) == 0))
        return (temp);
d170 1
a170 1
        free (temp);
d224 1
a224 1
  int status;
d236 1
d268 1
a268 1
         the exec'd child. */
d276 1
a276 1
         of the pipe be stdout, and execute the man page formatter. */
d279 1
a279 1
      close (fileno (stdin));   /* Don't print errors. */
d285 1
a285 1
         exit. */
d307 1
a307 1
  for (i = 0, j = 0; (newpage[j] = manpage[i]); i++, j++)
d310 1
a310 1
        newline_count++;
d312 1
a312 1
        newline_count = 0;
d315 4
a318 4
        {
          j--;
          newline_count--;
        }
d321 1
a321 1
        j -= 2;
d342 5
a346 5
      for (i = 0; (tag = file_buffer->tags[i]); i++)
        {
          if (strcasecmp (pagename, tag->nodename) == 0)
            break;
        }
d462 1
a462 1
        break;
d476 5
a480 5
          (!whitespace (frs_binding.buffer[i + 1])))
        {
          frs_binding.end = i;
          break;
        }
d511 2
a512 2
        if (whitespace (reference_section->buffer[start]))
          break;
d517 13
a529 13
        {
          if (whitespace (reference_section->buffer[end]))
            {
              end = start;
              break;
            }

          if (reference_section->buffer[end] == ')')
            {
              end++;
              break;
            }
        }
d532 16
a547 16
        {
          REFERENCE *entry;
          int len = end - start;

          entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
          entry->label = (char *)xmalloc (1 + len);
          strncpy (entry->label, (reference_section->buffer) + start, len);
          entry->label[len] = '\0';
          entry->filename = xstrdup (node->filename);
          entry->nodename = xstrdup (entry->label);
          entry->start = start;
          entry->end = end;

          add_pointer_to_array
            (entry, refs_index, refs, refs_slots, 10, REFERENCE *);
        }
d561 1
d576 8
a583 8
        {
          for (i = 0; (entry = refs[i]); i++)
            if (entry->start > start)
              {
                position = entry->start;
                break;
              }
        }
d585 12
a596 12
        {
          for (i = count - 1; i > -1; i--)
            {
              entry = refs[i];

              if (entry->start < start)
                {
                  position = entry->start;
                  break;
                }
            }
        }
d625 1
a625 1
  for (i = 0; (entry = all_refs[i]); i++)
d628 4
a631 4
        {
          add_pointer_to_array
            (entry, brefs_index, brefs, brefs_slots, 10, REFERENCE *);
        }
d633 6
a638 6
        {
          maybe_free (entry->label);
          maybe_free (entry->filename);
          maybe_free (entry->nodename);
          free (entry);
        }
@


1.1.1.4
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
    $Id: man.c,v 1.13 1999/07/05 20:43:23 karl Exp $
d4 1
a4 1
   Copyright (C) 1995, 97, 98, 99 Free Software Foundation, Inc.
a46 8
#if STRIP_DOT_EXE
static char const * const exec_extensions[] = {
  ".exe", ".com", ".bat", ".btm", ".sh", ".ksh", ".pl", ".sed", "", NULL
};
#else
static char const * const exec_extensions[] = { "", NULL };
#endif

a78 1
	  char *old_contents = file_buffer->contents;
d92 2
a93 1
          memcpy (file_buffer->contents + oldsize + hlen, page, plen);
a98 37
	  /* We have just relocated file_buffer->contents from under
	     the feet of info_windows[] array.  Therefore, all the
	     nodes on that list which are showing man pages have their
	     contents member pointing into the blue.  Undo that harm.  */
	  if (old_contents && oldsize && old_contents != file_buffer->contents)
	    {
	      int iw;
	      INFO_WINDOW *info_win;
	      char *old_contents_end = old_contents + oldsize;

	      for (iw = 0; (info_win = info_windows[iw]); iw++)
		{
		  int in;

		  for (in = 0; in < info_win->nodes_index; in++)
		    {
		      NODE *node = info_win->nodes[in];

		      /* It really only suffices to see that node->filename
			 is "*manpages*".  But after several hours of
			 debugging this, would you blame me for being a bit
			 paranoid?  */
		      if (node && node->filename && node->contents &&
			  strcmp (node->filename,
				  MANPAGE_FILE_BUFFER_NAME) == 0 &&
			  node->contents >= old_contents &&
			  node->contents + node->nodelen <= old_contents_end)
			{
			  info_win->nodes[in] =
			    manpage_node_of_file_buffer (file_buffer,
							 node->nodename);
			  free (node->nodename);
			  free (node);
			}
		    }
		}
	    }
a136 2
      char *temp_end;
      int i;
d148 1
a148 1
      temp = (char *)xmalloc (34 + strlen (temp_dirname) + strlen (filename));
d150 1
a150 1
      if (!IS_SLASH (temp[(strlen (temp)) - 1]))
a152 1
      temp_end = temp + strlen (temp);
d156 1
a156 13
      /* Look for FILENAME, possibly with any of the extensions
	 in EXEC_EXTENSIONS[].  */
      for (i = 0; exec_extensions[i]; i++)
	{
	  if (exec_extensions[i][0])
	    strcpy (temp_end, exec_extensions[i]);
	  statable = (stat (temp, &finfo) == 0);

	  /* If we have found a regular executable file, then use it. */
	  if ((statable) && (S_ISREG (finfo.st_mode)) &&
	      (access (temp, X_OK) == 0))
	    return (temp);
	}
d158 6
a163 1
      free (temp);
a212 1
#if PIPE_USE_FORK
d217 2
a218 1
  wait (NULL);
a219 1
#endif
d228 1
a228 2
  RETSIGTYPE (*sigsave) ();
  char *formatted_page = NULL;
a247 1
#if PIPE_USE_FORK
d250 1
a250 1
  sigsave = signal (SIGCHLD, reap_children);
d253 1
a263 1
      signal (SIGCHLD, sigsave);
d266 2
a267 1
    { /* In the child, close the read end of the pipe, make the write end
d270 2
a271 2
      freopen (NULL_DEVICE, "w", stderr);
      freopen (NULL_DEVICE, "r", stdin);
d279 1
a279 1
      xexit (0);
a280 31
#else  /* !PIPE_USE_FORK */
  /* Cannot fork/exec, but can popen/pclose.  */
  {
    FILE *fpipe;
    char *cmdline = xmalloc (strlen (formatter_args[0])
			     + strlen (manpage_pagename)
			     + (arg_index > 2 ? strlen (manpage_section) : 0)
 			     + 3);
    int save_stderr = dup (fileno (stderr));
    int fd_err = open (NULL_DEVICE, O_WRONLY, 0666);

    if (fd_err > 2)
      dup2 (fd_err, fileno (stderr)); /* Don't print errors. */
    sprintf (cmdline, "%s %s %s", formatter_args[0], manpage_pagename,
				  arg_index > 2 ? manpage_section : "");
    fpipe = popen (cmdline, "r");
    free (cmdline);
    if (fd_err > 2)
      close (fd_err);
    dup2 (save_stderr, fileno (stderr));
    if (fpipe == 0)
      return ((char *)NULL);
    formatted_page = read_from_fd (fileno (fpipe));
    if (pclose (fpipe) == -1)
      {
	if (formatted_page)
	  free (formatted_page);
	return ((char *)NULL);
      }
  }
#endif /* !PIPE_USE_FORK */
d345 1
a345 1
      node->nodename = xstrdup (tag->nodename);
a348 1
      node->display_pos = 0;
@


1.1.1.5
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
    $Id: man.c,v 1.16 2002/02/23 19:12:02 karl Exp $
d4 1
a4 1
   Copyright (C) 1995, 97, 98, 99, 2000 Free Software Foundation, Inc.
d400 1
a400 4
      /* A malformed man page could have a \b as its first character,
         in which case decrementing j by 2 will cause us to write into
         newpage[-1], smashing the hidden info stored there by malloc.  */
      if (manpage[i] == '\b' || manpage[i] == '\f' && j > 0)
a401 22
      else if (!raw_escapes_p)
	{
	  /* Remove the ANSI escape sequences for color, boldface,
	     underlining, and italics, generated by some versions of
	     Groff.  */
	  if (manpage[i] == '\033' && manpage[i + 1] == '['
	      && isdigit (manpage[i + 2]))
	    {
	      if (isdigit (manpage[i + 3]) && manpage[i + 4] == 'm')
		{
		  i += 4;
		  j--;
		}
	      else if (manpage[i + 3] == 'm')
		{
		  i += 3;
		  j--;
		}
	      /* Else do nothing: it's some unknown escape sequence,
		 so let's leave it alone.  */
	    }
	}
d404 1
a404 1
  newpage[j++] = 0;
@


1.1.1.6
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
    $Id: man.c,v 1.4 2004/04/11 17:56:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d55 4
a58 5
static char *read_from_fd (int fd);
static void clean_manpage (char *manpage);
static NODE *manpage_node_of_file_buffer (FILE_BUFFER *file_buffer,
    char *pagename);
static char *get_manpage_contents (char *pagename);
d61 2
a62 1
make_manpage_node (char *pagename)
d68 3
a70 1
get_manpage_node (FILE_BUFFER *file_buffer, char *pagename)
d123 1
a123 1
		      NODE *tmp_node = info_win->nodes[in];
d129 5
a133 7
		      if (tmp_node && tmp_node->filename
                          && tmp_node->contents
                          && strcmp (tmp_node->filename,
				  MANPAGE_FILE_BUFFER_NAME) == 0
                          && tmp_node->contents >= old_contents
                          && tmp_node->contents + tmp_node->nodelen
                                <= old_contents_end)
d137 3
a139 3
                                tmp_node->nodename);
			  free (tmp_node->nodename);
			  free (tmp_node);
d153 1
a153 1
create_manpage_file_buffer (void)
d162 1
a162 1

d170 2
a171 1
executable_file_in_path (char *filename, char *path)
d225 1
a225 1
find_man_formatter (void)
d234 2
a235 1
get_page_and_section (char *pagename)
d270 2
a271 1
reap_children (int sig)
d278 2
a279 1
get_manpage_contents (char *pagename)
d284 1
a284 1
  RETSIGTYPE (*sigsave) (int signum);
d378 2
a379 1
clean_manpage (char *manpage)
d403 1
a403 1
      if (manpage[i] == '\b' || (manpage[i] == '\f' && j > 0))
d436 3
a438 1
manpage_node_of_file_buffer (FILE_BUFFER *file_buffer, char *pagename)
d472 2
a473 1
read_from_fd (int fd)
d553 2
a554 1
find_reference_section (NODE *node)
d593 2
a594 1
xrefs_of_manpage (NODE *node)
d662 4
a665 1
locate_manpage_xref (NODE *node, long int start, int dir)
d712 3
a714 1
manpage_xrefs_in_binding (NODE *node, SEARCH_BINDING *binding)
@


