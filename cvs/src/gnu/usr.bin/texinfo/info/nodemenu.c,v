head	1.4;
access;
symbols
	OPENBSD_6_2:1.4.0.48
	OPENBSD_6_2_BASE:1.4
	OPENBSD_6_1:1.4.0.46
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.42
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.38
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.40
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.32
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.36
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.34
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.30
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	TEXINFO_4_8:1.1.1.4
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	TEXINFO_4_2:1.1.1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.29;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.50;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@conflict resolution
@
text
@/* nodemenu.c -- produce a menu of all visited nodes.
   $Id: nodemenu.c,v 1.5 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1993, 1997, 1998, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"

NODE * get_visited_nodes (Function *filter_func);

/* Return a line describing the format of a node information line. */
static const char *
nodemenu_format_info (void)
{
  return (_("\n\
* Menu:\n\
  (File)Node                        Lines   Size   Containing File\n\
  ----------                        -----   ----   ---------------"));
}

/* Produce a formatted line of information about NODE.  Here is what we want
   the output listing to look like:

* Menu:
  (File)Node                        Lines   Size   Containing File
  ----------                        -----   ----   ---------------
* (emacs)Buffers::                  48      2230   /usr/gnu/info/emacs/emacs-1
* (autoconf)Writing configure.in::  123     58789  /usr/gnu/info/autoconf/autoconf-1
* (dir)Top::                        40      589    /usr/gnu/info/dir
*/
static char *
format_node_info (NODE *node)
{
  register int i, len;
  char *parent, *containing_file;
  static char *line_buffer = (char *)NULL;

  if (!line_buffer)
    line_buffer = (char *)xmalloc (1000);

  if (node->parent)
    {
      parent = filename_non_directory (node->parent);
      if (!parent)
        parent = node->parent;
    }
  else
    parent = (char *)NULL;

  containing_file = node->filename;

  if (!parent && !*containing_file)
    sprintf (line_buffer, "* %s::", node->nodename);
  else
    {
      char *file = (char *)NULL;

      if (parent)
        file = parent;
      else
        file = filename_non_directory (containing_file);

      if (!file)
        file = containing_file;

      if (!*file)
        file = "dir";

      sprintf (line_buffer, "* (%s)%s::", file, node->nodename);
    }

  len = pad_to (36, line_buffer);

  {
    int lines = 1;

    for (i = 0; i < node->nodelen; i++)
      if (node->contents[i] == '\n')
        lines++;

    sprintf (line_buffer + len, "%d", lines);
  }

  len = pad_to (44, line_buffer);
  sprintf (line_buffer + len, "%ld", node->nodelen);

  if (node->filename && *(node->filename))
    {
      len = pad_to (51, line_buffer);
      strcpy (line_buffer + len, node->filename);
    }

  return xstrdup (line_buffer);
}

/* Little string comparison routine for qsort (). */
static int
compare_strings (const void *entry1, const void *entry2)
{
  char **e1 = (char **) entry1;
  char **e2 = (char **) entry2;

  return (strcasecmp (*e1, *e2));
}

/* The name of the nodemenu node. */
static char *nodemenu_nodename = "*Node Menu*";

/* Produce an informative listing of all the visited nodes, and return it
   in a node.  If FILTER_FUNC is non-null, it is a function which filters
   which nodes will appear in the listing.  FILTER_FUNC takes an argument
   of NODE, and returns non-zero if the node should appear in the listing. */
NODE *
get_visited_nodes (Function *filter_func)
{
  register int i, iw_index;
  INFO_WINDOW *info_win;
  NODE *node;
  char **lines = (char **)NULL;
  int lines_index = 0, lines_slots = 0;

  if (!info_windows)
    return ((NODE *)NULL);

  for (iw_index = 0; (info_win = info_windows[iw_index]); iw_index++)
    {
      for (i = 0; i < info_win->nodes_index; i++)
        {
          node = info_win->nodes[i];

          /* We skip mentioning "*Node Menu*" nodes. */
          if (internal_info_node_p (node) &&
              (strcmp (node->nodename, nodemenu_nodename) == 0))
            continue;

          if (node && (!filter_func || (*filter_func) (node)))
            {
              char *line;

              line = format_node_info (node);
              add_pointer_to_array
                (line, lines_index, lines, lines_slots, 20, char *);
            }
        }
    }

  /* Sort the array of information lines, if there are any. */
  if (lines)
    {
      register int j, newlen;
      char **temp;

      qsort (lines, lines_index, sizeof (char *), compare_strings);

      /* Delete duplicates. */
      for (i = 0, newlen = 1; i < lines_index - 1; i++)
        {
	  /* Use FILENAME_CMP here, since the most important piece
	     of info in each line is the file name of the node.  */
          if (FILENAME_CMP (lines[i], lines[i + 1]) == 0)
            {
              free (lines[i]);
              lines[i] = (char *)NULL;
            }
          else
            newlen++;
        }

      /* We have free ()'d and marked all of the duplicate slots.
         Copy the live slots rather than pruning the dead slots. */
      temp = (char **)xmalloc ((1 + newlen) * sizeof (char *));
      for (i = 0, j = 0; i < lines_index; i++)
        if (lines[i])
          temp[j++] = lines[i];

      temp[j] = (char *)NULL;
      free (lines);
      lines = temp;
      lines_index = newlen;
    }

  initialize_message_buffer ();

  printf_to_message_buffer
    ("%s", replace_in_documentation
     ((char *) _("Here is the menu of nodes you have recently visited.\n\
Select one from this menu, or use `\\[history-node]' in another window.\n"), 0),
     NULL, NULL);

  printf_to_message_buffer ("%s\n", (char *) nodemenu_format_info (),
      NULL, NULL);

  for (i = 0; (lines != (char **)NULL) && (i < lines_index); i++)
    {
      printf_to_message_buffer ("%s\n", lines[i], NULL, NULL);
      free (lines[i]);
    }

  if (lines)
    free (lines);

  node = message_buffer_to_node ();
  add_gcable_pointer (node->contents);
  return (node);
}

DECLARE_INFO_COMMAND (list_visited_nodes,
   _("Make a window containing a menu of all of the currently visited nodes"))
{
  WINDOW *new;
  NODE *node;

  set_remembered_pagetop_and_point (window);

  /* If a window is visible and showing the buffer list already, re-use it. */
  for (new = windows; new; new = new->next)
    {
      node = new->node;

      if (internal_info_node_p (node) &&
          (strcmp (node->nodename, nodemenu_nodename) == 0))
        break;
    }

  /* If we couldn't find an existing window, try to use the next window
     in the chain. */
  if (!new)
    {
      if (window->next)
        new = window->next;
      /* If there is more than one window, wrap around. */
      else if (window != windows)
        new = windows;
    }

  /* If we still don't have a window, make a new one to contain the list. */
  if (!new)
    {
      WINDOW *old_active;

      old_active = active_window;
      active_window = window;
      new = window_make_window ((NODE *)NULL);
      active_window = old_active;
    }

  /* If we couldn't make a new window, use this one. */
  if (!new)
    new = window;

  /* Lines do not wrap in this window. */
  new->flags |= W_NoWrap;
  node = get_visited_nodes ((Function *)NULL);
  name_internal_node (node, nodemenu_nodename);

#if 0
  /* Even if this is an internal node, we don't want the window
     system to treat it specially.  So we turn off the internalness
     of it here. */
  /* Why?  We depend on internal_info_node_p returning true, so we must
     not remove the flag.  Otherwise, the *Node Menu* nodes themselves
     appear in the node menu.  --Andreas Schwab
     <schwab@@issan.informatik.uni-dortmund.de>.  */
  node->flags &= ~N_IsInternal;
#endif

  /* If this window is already showing a node menu, reuse the existing node
     slot. */
  {
    int remember_me = 1;

#if defined (NOTDEF)
    if (internal_info_node_p (new->node) &&
        (strcmp (new->node->nodename, nodemenu_nodename) == 0))
      remember_me = 0;
#endif /* NOTDEF */

    window_set_node_of_window (new, node);

    if (remember_me)
      remember_window_and_node (new, node);
  }

  active_window = new;
}

DECLARE_INFO_COMMAND (select_visited_node,
      _("Select a node which has been previously visited in a visible window"))
{
  char *line;
  NODE *node;
  REFERENCE **menu;

  node = get_visited_nodes ((Function *)NULL);

  menu = info_menu_of_node (node);
  free (node);

  line =
    info_read_completing_in_echo_area (window,
        (char *) _("Select visited node: "), menu);

  window = active_window;

  /* User aborts, just quit. */
  if (!line)
    {
      info_abort_key (window, 0, 0);
      info_free_references (menu);
      return;
    }

  if (*line)
    {
      REFERENCE *entry;

      /* Find the selected label in the references. */
      entry = info_get_labeled_reference (line, menu);

      if (!entry)
        info_error ((char *) _("The reference disappeared! (%s)."), line, NULL);
      else
        info_select_reference (window, entry);
    }

  free (line);
  info_free_references (menu);

  if (!info_error_was_printed)
    window_clear_echo_area ();
}
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: nodemenu.c,v 1.8 1998/06/28 19:54:27 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d25 2
d28 2
a29 2
static char *
nodemenu_format_info ()
d48 1
a48 2
format_node_info (node)
     NODE *node;
d106 1
a106 1
      sprintf (line_buffer + len, node->filename);
d114 1
a114 2
compare_strings (string1, string2)
     char **string1, **string2;
d116 4
a119 1
  return (strcasecmp (*string1, *string2));
d130 1
a130 2
get_visited_nodes (filter_func)
     Function *filter_func;
d202 3
a204 2
     (_("Here is the menu of nodes you have recently visited.\n\
Select one from this menu, or use `\\[history-node]' in another window.\n")));
d206 2
a207 1
  printf_to_message_buffer ("%s\n", nodemenu_format_info ());
d211 1
a211 1
      printf_to_message_buffer ("%s\n", lines[i]);
d316 2
a317 1
    info_read_completing_in_echo_area (window, _("Select visited node: "), menu);
d337 1
a337 1
        info_error (_("The reference disappeared! (%s)."), line);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* nodemenu.c -- Produce a menu of all visited nodes.
   $Id: nodemenu.c,v 1.7 1997/07/24 21:30:30 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d171 3
a173 1
          if (strcmp (lines[i], lines[i + 1]) == 0)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* nodemenu.c -- Produce a menu of all visited nodes. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d28 1
a28 1
  return ("\n\
d31 1
a31 1
  ----------                        -----   ----   ---------------");
d42 1
a42 1
* (dir)Top::			    40      589    /usr/gnu/info/dir
d59 1
a59 1
	parent = node->parent;
d73 1
a73 1
	file = parent;
d75 1
a75 1
	file = filename_non_directory (containing_file);
d78 1
a78 1
	file = containing_file;
d81 1
a81 1
	file = "dir";
d93 1
a93 1
	lines++;
d99 1
a99 1
  sprintf (line_buffer + len, "%d", node->nodelen);
d107 1
a107 1
  return (strdup (line_buffer));
d138 1
a138 1
  for (iw_index = 0; info_win = info_windows[iw_index]; iw_index++)
d141 2
a142 2
	{
	  node = info_win->nodes[i];
d144 14
a157 14
	  /* We skip mentioning "*Node Menu*" nodes. */
	  if (internal_info_node_p (node) &&
	      (strcmp (node->nodename, nodemenu_nodename) == 0))
	    continue;

	  if (node && (!filter_func || (*filter_func) (node)))
	    {
	      char *line;

	      line = format_node_info (node);
	      add_pointer_to_array
		(line, lines_index, lines, lines_slots, 20, char *);
	    }
	}
d170 9
a178 9
	{
	  if (strcmp (lines[i], lines[i + 1]) == 0)
	    {
	      free (lines[i]);
	      lines[i] = (char *)NULL;
	    }
	  else
	    newlen++;
	}
d181 1
a181 1
	 Copy the live slots rather than pruning the dead slots. */
d184 2
a185 2
	if (lines[i])
	  temp[j++] = lines[i];
d197 2
a198 2
     ("Here is the menu of nodes you have recently visited.\n\
Select one from this menu, or use `\\[history-node]' in another window.\n"));
d217 1
a217 1
   "Make a window containing a menu of all of the currently visited nodes")
d230 2
a231 2
	  (strcmp (node->nodename, nodemenu_nodename) == 0))
	break;
d236 8
a243 2
  if (!new && window->next)
    new = window->next;
d265 1
d269 4
d274 1
d283 1
a283 1
	(strcmp (new->node->nodename, nodemenu_nodename) == 0))
d297 1
a297 1
      "Select a node which has been previously visited in a visible window")
d309 1
a309 1
    info_read_completing_in_echo_area (window, "Select visited node: ", menu);
d329 1
a329 1
	info_error ("The reference disappeared! (%s).", line);
d331 1
a331 1
	info_select_reference (window, entry);
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* nodemenu.c -- Produce a menu of all visited nodes.
   $Id: nodemenu.c,v 1.7 1997/07/24 21:30:30 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d30 1
a30 1
  return (_("\n\
d33 1
a33 1
  ----------                        -----   ----   ---------------"));
d44 1
a44 1
* (dir)Top::                        40      589    /usr/gnu/info/dir
d61 1
a61 1
        parent = node->parent;
d75 1
a75 1
        file = parent;
d77 1
a77 1
        file = filename_non_directory (containing_file);
d80 1
a80 1
        file = containing_file;
d83 1
a83 1
        file = "dir";
d95 1
a95 1
        lines++;
d101 1
a101 1
  sprintf (line_buffer + len, "%ld", node->nodelen);
d109 1
a109 1
  return xstrdup (line_buffer);
d140 1
a140 1
  for (iw_index = 0; (info_win = info_windows[iw_index]); iw_index++)
d143 2
a144 2
        {
          node = info_win->nodes[i];
d146 14
a159 14
          /* We skip mentioning "*Node Menu*" nodes. */
          if (internal_info_node_p (node) &&
              (strcmp (node->nodename, nodemenu_nodename) == 0))
            continue;

          if (node && (!filter_func || (*filter_func) (node)))
            {
              char *line;

              line = format_node_info (node);
              add_pointer_to_array
                (line, lines_index, lines, lines_slots, 20, char *);
            }
        }
d172 9
a180 9
        {
          if (strcmp (lines[i], lines[i + 1]) == 0)
            {
              free (lines[i]);
              lines[i] = (char *)NULL;
            }
          else
            newlen++;
        }
d183 1
a183 1
         Copy the live slots rather than pruning the dead slots. */
d186 2
a187 2
        if (lines[i])
          temp[j++] = lines[i];
d199 2
a200 2
     (_("Here is the menu of nodes you have recently visited.\n\
Select one from this menu, or use `\\[history-node]' in another window.\n")));
d219 1
a219 1
   _("Make a window containing a menu of all of the currently visited nodes"))
d232 2
a233 2
          (strcmp (node->nodename, nodemenu_nodename) == 0))
        break;
d238 2
a239 8
  if (!new)
    {
      if (window->next)
        new = window->next;
      /* If there is more than one window, wrap around. */
      else if (window != windows)
        new = windows;
    }
a260 1
#if 0
a263 4
  /* Why?  We depend on internal_info_node_p returning true, so we must
     not remove the flag.  Otherwise, the *Node Menu* nodes themselves
     appear in the node menu.  --Andreas Schwab
     <schwab@@issan.informatik.uni-dortmund.de>.  */
a264 1
#endif
d273 1
a273 1
        (strcmp (new->node->nodename, nodemenu_nodename) == 0))
d287 1
a287 1
      _("Select a node which has been previously visited in a visible window"))
d299 1
a299 1
    info_read_completing_in_echo_area (window, _("Select visited node: "), menu);
d319 1
a319 1
        info_error (_("The reference disappeared! (%s)."), line);
d321 1
a321 1
        info_select_reference (window, entry);
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* nodemenu.c -- produce a menu of all visited nodes.
   $Id: nodemenu.c,v 1.8 1998/06/28 19:54:27 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d171 1
a171 3
	  /* Use FILENAME_CMP here, since the most important piece
	     of info in each line is the file name of the node.  */
          if (FILENAME_CMP (lines[i], lines[i + 1]) == 0)
@


1.1.1.4
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: nodemenu.c,v 1.5 2004/04/11 17:56:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 2002, 2003, 2004 Free Software
   Foundation, Inc.
a23 2
NODE * get_visited_nodes (Function *filter_func);

d25 2
a26 2
static const char *
nodemenu_format_info (void)
d45 2
a46 1
format_node_info (NODE *node)
d104 1
a104 1
      strcpy (line_buffer + len, node->filename);
d112 2
a113 1
compare_strings (const void *entry1, const void *entry2)
d115 1
a115 4
  char **e1 = (char **) entry1;
  char **e2 = (char **) entry2;

  return (strcasecmp (*e1, *e2));
d126 2
a127 1
get_visited_nodes (Function *filter_func)
d199 2
a200 3
     ((char *) _("Here is the menu of nodes you have recently visited.\n\
Select one from this menu, or use `\\[history-node]' in another window.\n"), 0),
     NULL, NULL);
d202 1
a202 2
  printf_to_message_buffer ("%s\n", (char *) nodemenu_format_info (),
      NULL, NULL);
d206 1
a206 1
      printf_to_message_buffer ("%s\n", lines[i], NULL, NULL);
d311 1
a311 2
    info_read_completing_in_echo_area (window,
        (char *) _("Select visited node: "), menu);
d331 1
a331 1
        info_error ((char *) _("The reference disappeared! (%s)."), line, NULL);
@


