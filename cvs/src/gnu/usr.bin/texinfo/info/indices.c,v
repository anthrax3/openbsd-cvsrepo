head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.44
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.39;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.15;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.43;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.04;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.42;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* indices.c -- deal with an Info file index.
   $Id: indices.c,v 1.5 2004/04/11 17:56:45 karl Exp $

   Copyright (C) 1993, 1997, 1998, 1999, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Originally written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "indices.h"

/* User-visible variable controls the output of info-index-next. */
int show_index_match = 1;

/* In the Info sense, an index is a menu.  This variable holds the last
   parsed index. */
static REFERENCE **index_index = (REFERENCE **)NULL;

/* The offset of the most recently selected index element. */
static int index_offset = 0;

/* Variable which holds the last string searched for. */
static char *index_search = (char *)NULL;

/* A couple of "globals" describing where the initial index was found. */
static char *initial_index_filename = (char *)NULL;
static char *initial_index_nodename = (char *)NULL;

/* A structure associating index names with index offset ranges. */
typedef struct {
  char *name;                   /* The nodename of this index. */
  int first;                    /* The index in our list of the first entry. */
  int last;                     /* The index in our list of the last entry. */
} INDEX_NAME_ASSOC;

/* An array associating index nodenames with index offset ranges. */
static INDEX_NAME_ASSOC **index_nodenames = (INDEX_NAME_ASSOC **)NULL;
static int index_nodenames_index = 0;
static int index_nodenames_slots = 0;

/* Add the name of NODE, and the range of the associated index elements
   (passed in ARRAY) to index_nodenames. */
static void
add_index_to_index_nodenames (REFERENCE **array, NODE *node)
{
  register int i, last;
  INDEX_NAME_ASSOC *assoc;

  for (last = 0; array[last + 1]; last++);
  assoc = (INDEX_NAME_ASSOC *)xmalloc (sizeof (INDEX_NAME_ASSOC));
  assoc->name = xstrdup (node->nodename);

  if (!index_nodenames_index)
    {
      assoc->first = 0;
      assoc->last = last;
    }
  else
    {
      for (i = 0; index_nodenames[i + 1]; i++);
      assoc->first = 1 + index_nodenames[i]->last;
      assoc->last = assoc->first + last;
    }
  add_pointer_to_array
    (assoc, index_nodenames_index, index_nodenames, index_nodenames_slots,
     10, INDEX_NAME_ASSOC *);
}

/* Find and return the indices of WINDOW's file.  The indices are defined
   as the first node in the file containing the word "Index" and any
   immediately following nodes whose names also contain "Index".  All such
   indices are concatenated and the result returned.  If WINDOW's info file
   doesn't have any indices, a NULL pointer is returned. */
REFERENCE **
info_indices_of_window (WINDOW *window)
{
  FILE_BUFFER *fb;

  fb = file_buffer_of_window (window);

  return (info_indices_of_file_buffer (fb));
}

REFERENCE **
info_indices_of_file_buffer (FILE_BUFFER *file_buffer)
{
  register int i;
  REFERENCE **result = (REFERENCE **)NULL;

  /* No file buffer, no indices. */
  if (!file_buffer)
    return ((REFERENCE **)NULL);

  /* Reset globals describing where the index was found. */
  maybe_free (initial_index_filename);
  maybe_free (initial_index_nodename);
  initial_index_filename = (char *)NULL;
  initial_index_nodename = (char *)NULL;

  if (index_nodenames)
    {
      for (i = 0; index_nodenames[i]; i++)
        {
          free (index_nodenames[i]->name);
          free (index_nodenames[i]);
        }

      index_nodenames_index = 0;
      index_nodenames[0] = (INDEX_NAME_ASSOC *)NULL;
    }

  /* Grovel the names of the nodes found in this file. */
  if (file_buffer->tags)
    {
      TAG *tag;

      for (i = 0; (tag = file_buffer->tags[i]); i++)
        {
          if (string_in_line ("Index", tag->nodename) != -1)
            {
              NODE *node;
              REFERENCE **menu;

              /* Found one.  Get its menu. */
              node = info_get_node (tag->filename, tag->nodename);
              if (!node)
                continue;

              /* Remember the filename and nodename of this index. */
              initial_index_filename = xstrdup (file_buffer->filename);
              initial_index_nodename = xstrdup (tag->nodename);

              menu = info_menu_of_node (node);

              /* If we have a menu, add this index's nodename and range
                 to our list of index_nodenames. */
              if (menu)
                {
                  add_index_to_index_nodenames (menu, node);

                  /* Concatenate the references found so far. */
                  result = info_concatenate_references (result, menu);
                }
              free (node);
            }
        }
    }

  /* If there is a result, clean it up so that every entry has a filename. */
  for (i = 0; result && result[i]; i++)
    if (!result[i]->filename)
      result[i]->filename = xstrdup (file_buffer->filename);

  return (result);
}

DECLARE_INFO_COMMAND (info_index_search,
   _("Look up a string in the index for this file"))
{
  do_info_index_search (window, count, 0);
}

/* Look up SEARCH_STRING in the index for this file.  If SEARCH_STRING
   is NULL, prompt user for input.  */ 
void
do_info_index_search (WINDOW *window, int count, char *search_string)
{
  FILE_BUFFER *fb;
  char *line;

  /* Reset the index offset, since this is not the info-index-next command. */
  index_offset = 0;

  /* The user is selecting a new search string, so flush the old one. */
  maybe_free (index_search);
  index_search = (char *)NULL;

  /* If this window's file is not the same as the one that we last built an
     index for, build and remember an index now. */
  fb = file_buffer_of_window (window);
  if (!initial_index_filename ||
      (FILENAME_CMP (initial_index_filename, fb->filename) != 0))
    {
      info_free_references (index_index);
      window_message_in_echo_area ((char *) _("Finding index entries..."),
          NULL, NULL);
      index_index = info_indices_of_file_buffer (fb);
    }

  /* If there is no index, quit now. */
  if (!index_index)
    {
      info_error ((char *) _("No indices found."), NULL, NULL);
      return;
    }

  /* Okay, there is an index.  Look for SEARCH_STRING, or, if it is
     empty, prompt for one.  */
  if (search_string && *search_string)
    line = xstrdup (search_string);
  else
    {
      line = info_read_maybe_completing (window, (char *) _("Index entry: "),
                                         index_index);
      window = active_window;

      /* User aborted? */
      if (!line)
        {
          info_abort_key (active_window, 1, 0);
          return;
        }

      /* Empty line means move to the Index node. */
      if (!*line)
        {
          free (line);

          if (initial_index_filename && initial_index_nodename)
            {
              NODE *node;

              node = info_get_node (initial_index_filename,
                                    initial_index_nodename);
              set_remembered_pagetop_and_point (window);
              window_set_node_of_window (window, node);
              remember_window_and_node (window, node);
              window_clear_echo_area ();
              return;
            }
        }
    }

  /* The user typed either a completed index label, or a partial string.
     Find an exact match, or, failing that, the first index entry containing
     the partial string.  So, we just call info_next_index_match () with minor
     manipulation of INDEX_OFFSET. */
  {
    int old_offset;

    /* Start the search right after/before this index. */
    if (count < 0)
      {
        register int i;
        for (i = 0; index_index[i]; i++);
        index_offset = i;
      }
    else
      index_offset = -1;

    old_offset = index_offset;

    /* The "last" string searched for is this one. */
    index_search = line;

    /* Find it, or error. */
    info_next_index_match (window, count, 0);

    /* If the search failed, return the index offset to where it belongs. */
    if (index_offset == old_offset)
      index_offset = 0;
  }
}

int
index_entry_exists (WINDOW *window, char *string)
{
  register int i;
  FILE_BUFFER *fb;

  /* If there is no previous search string, the user hasn't built an index
     yet. */
  if (!string)
    return 0;

  fb = file_buffer_of_window (window);
  if (!initial_index_filename
      || (FILENAME_CMP (initial_index_filename, fb->filename) != 0))
    {
      info_free_references (index_index);
      index_index = info_indices_of_file_buffer (fb);
    }

  /* If there is no index, that is an error. */
  if (!index_index)
    return 0;

  for (i = 0; (i > -1) && (index_index[i]); i++)
    if (strcmp (string, index_index[i]->label) == 0)
      break;

  /* If that failed, look for the next substring match. */
  if ((i < 0) || (!index_index[i]))
    {
      for (i = 0; (i > -1) && (index_index[i]); i++)
        if (string_in_line (string, index_index[i]->label) != -1)
          break;

      if ((i > -1) && (index_index[i]))
        string_in_line (string, index_index[i]->label);
    }

  /* If that failed, return 0. */
  if ((i < 0) || (!index_index[i]))
    return 0;

  return 1;
}

DECLARE_INFO_COMMAND (info_next_index_match,
 _("Go to the next matching index item from the last `\\[index-search]' command"))
{
  register int i;
  int partial, dir;
  NODE *node;

  /* If there is no previous search string, the user hasn't built an index
     yet. */
  if (!index_search)
    {
      info_error ((char *) _("No previous index search string."), NULL, NULL);
      return;
    }

  /* If there is no index, that is an error. */
  if (!index_index)
    {
      info_error ((char *) _("No index entries."), NULL, NULL);
      return;
    }

  /* The direction of this search is controlled by the value of the
     numeric argument. */
  if (count < 0)
    dir = -1;
  else
    dir = 1;

  /* Search for the next occurence of index_search.  First try to find
     an exact match. */
  partial = 0;

  for (i = index_offset + dir; (i > -1) && (index_index[i]); i += dir)
    if (strcmp (index_search, index_index[i]->label) == 0)
      break;

  /* If that failed, look for the next substring match. */
  if ((i < 0) || (!index_index[i]))
    {
      for (i = index_offset + dir; (i > -1) && (index_index[i]); i += dir)
        if (string_in_line (index_search, index_index[i]->label) != -1)
          break;

      if ((i > -1) && (index_index[i]))
        partial = string_in_line (index_search, index_index[i]->label);
    }

  /* If that failed, print an error. */
  if ((i < 0) || (!index_index[i]))
    {
      info_error ((char *) _("No %sindex entries containing `%s'."),
                  index_offset > 0 ? (char *) _("more ") : "", index_search);
      return;
    }

  /* Okay, we found the next one.  Move the offset to the current entry. */
  index_offset = i;

  /* Report to the user on what we have found. */
  {
    register int j;
    const char *name = _("CAN'T SEE THIS");
    char *match;

    for (j = 0; index_nodenames[j]; j++)
      {
        if ((i >= index_nodenames[j]->first) &&
            (i <= index_nodenames[j]->last))
          {
            name = index_nodenames[j]->name;
            break;
          }
      }

    /* If we had a partial match, indicate to the user which part of the
       string matched. */
    match = xstrdup (index_index[i]->label);

    if (partial && show_index_match)
      {
        int k, ls, start, upper;

        ls = strlen (index_search);
        start = partial - ls;
        upper = isupper (match[start]) ? 1 : 0;

        for (k = 0; k < ls; k++)
          if (upper)
            match[k + start] = info_tolower (match[k + start]);
          else
            match[k + start] = info_toupper (match[k + start]);
      }

    {
      char *format;

      format = replace_in_documentation
        ((char *) _("Found `%s' in %s. (`\\[next-index-match]' tries to find next.)"),
         0);

      window_message_in_echo_area (format, match, (char *) name);
    }

    free (match);
  }

  /* Select the node corresponding to this index entry. */
  node = info_get_node (index_index[i]->filename, index_index[i]->nodename);

  if (!node)
    {
      info_error ((char *) msg_cant_file_node,
                  index_index[i]->filename, index_index[i]->nodename);
      return;
    }

  info_set_node_of_window (1, window, node);

  /* Try to find an occurence of LABEL in this node. */
  {
    long start, loc;

    start = window->line_starts[1] - window->node->contents;
    loc = info_target_search_node (node, index_index[i]->label, start);

    if (loc != -1)
      {
        window->point = loc;
        window_adjust_pagetop (window);
      }
  }
}

/* **************************************************************** */
/*                                                                  */
/*                 Info APROPOS: Search every known index.          */
/*                                                                  */
/* **************************************************************** */

/* For every menu item in DIR, search the indices of that file for
   SEARCH_STRING. */
REFERENCE **
apropos_in_all_indices (char *search_string, int inform)
{
  register int i, dir_index;
  REFERENCE **all_indices = (REFERENCE **)NULL;
  REFERENCE **dir_menu = (REFERENCE **)NULL;
  NODE *dir_node;

  dir_node = info_get_node ("dir", "Top");
  if (dir_node)
    dir_menu = info_menu_of_node (dir_node);

  if (!dir_menu)
    return NULL;

  /* For every menu item in DIR, get the associated node's file buffer and
     read the indices of that file buffer.  Gather all of the indices into
     one large one. */
  for (dir_index = 0; dir_menu[dir_index]; dir_index++)
    {
      REFERENCE **this_index, *this_item;
      NODE *this_node;
      FILE_BUFFER *this_fb;
      int dir_node_duplicated = 0;

      this_item = dir_menu[dir_index];

      if (!this_item->filename)
        {
	  dir_node_duplicated = 1;
          if (dir_node->parent)
            this_item->filename = xstrdup (dir_node->parent);
          else
            this_item->filename = xstrdup (dir_node->filename);
        }

      /* Find this node.  If we cannot find it, try using the label of the
         entry as a file (i.e., "(LABEL)Top"). */
      this_node = info_get_node (this_item->filename, this_item->nodename);

      if (!this_node && this_item->nodename &&
          (strcmp (this_item->label, this_item->nodename) == 0))
        this_node = info_get_node (this_item->label, "Top");

      if (!this_node)
	{
	  if (dir_node_duplicated)
	    free (this_item->filename);
	  continue;
	}

      /* Get the file buffer associated with this node. */
      {
        char *files_name;

        files_name = this_node->parent;
        if (!files_name)
          files_name = this_node->filename;

        this_fb = info_find_file (files_name);

	/* If we already scanned this file, don't do that again.
	   In addition to being faster, this also avoids having
	   multiple identical entries in the *Apropos* menu.  */
	for (i = 0; i < dir_index; i++)
	  if (FILENAME_CMP (this_fb->filename, dir_menu[i]->filename) == 0)
	    break;
	if (i < dir_index)
	  {
	    if (dir_node_duplicated)
	      free (this_item->filename);
	    continue;
	  }

        if (this_fb && inform)
          message_in_echo_area ((char *) _("Scanning indices of `%s'..."),
              files_name, NULL);

        this_index = info_indices_of_file_buffer (this_fb);
        free (this_node);

        if (this_fb && inform)
          unmessage_in_echo_area ();
      }

      if (this_index)
        {
          /* Remember the filename which contains this set of references. */
          for (i = 0; this_index && this_index[i]; i++)
            if (!this_index[i]->filename)
              this_index[i]->filename = xstrdup (this_fb->filename);

          /* Concatenate with the other indices.  */
          all_indices = info_concatenate_references (all_indices, this_index);
        }
    }

  info_free_references (dir_menu);

  /* Build a list of the references which contain SEARCH_STRING. */
  if (all_indices)
    {
      REFERENCE *entry, **apropos_list = (REFERENCE **)NULL;
      int apropos_list_index = 0;
      int apropos_list_slots = 0;

      for (i = 0; (entry = all_indices[i]); i++)
        {
          if (string_in_line (search_string, entry->label) != -1)
            {
              add_pointer_to_array
                (entry, apropos_list_index, apropos_list, apropos_list_slots,
                 100, REFERENCE *);
            }
          else
            {
              maybe_free (entry->label);
              maybe_free (entry->filename);
              maybe_free (entry->nodename);
              free (entry);
            }
        }

      free (all_indices);
      all_indices = apropos_list;
    }
  return (all_indices);
}

#define APROPOS_NONE \
   N_("No available info files have `%s' in their indices.")

void
info_apropos (char *string)
{
  REFERENCE **apropos_list;

  apropos_list = apropos_in_all_indices (string, 0);

  if (!apropos_list)
    info_error ((char *) _(APROPOS_NONE), string, NULL);
  else
    {
      register int i;
      REFERENCE *entry;

      for (i = 0; (entry = apropos_list[i]); i++)
        fprintf (stdout, "\"(%s)%s\" -- %s\n",
                 entry->filename, entry->nodename, entry->label);
    }
  info_free_references (apropos_list);
}

static char *apropos_list_nodename = "*Apropos*";

DECLARE_INFO_COMMAND (info_index_apropos,
   _("Grovel all known info file's indices for a string and build a menu"))
{
  char *line;

  line = info_read_in_echo_area (window, (char *) _("Index apropos: "));

  window = active_window;

  /* User aborted? */
  if (!line)
    {
      info_abort_key (window, 1, 1);
      return;
    }

  /* User typed something? */
  if (*line)
    {
      REFERENCE **apropos_list;
      NODE *apropos_node;

      apropos_list = apropos_in_all_indices (line, 1);

      if (!apropos_list)
        info_error ((char *) _(APROPOS_NONE), line, NULL);
      else
        {
          register int i;
          char *line_buffer;

          initialize_message_buffer ();
          printf_to_message_buffer
            ((char *) _("\n* Menu: Nodes whose indices contain `%s':\n"),
             line, NULL, NULL);
          line_buffer = (char *)xmalloc (500);

          for (i = 0; apropos_list[i]; i++)
            {
              int len;
	      /* The label might be identical to that of another index
		 entry in another Info file.  Therefore, we make the file
		 name part of the menu entry, to make them all distinct.  */
              sprintf (line_buffer, "* %s [%s]: ",
		       apropos_list[i]->label, apropos_list[i]->filename);
              len = pad_to (40, line_buffer);
              sprintf (line_buffer + len, "(%s)%s.",
                       apropos_list[i]->filename, apropos_list[i]->nodename);
              printf_to_message_buffer ("%s\n", line_buffer, NULL, NULL);
            }
          free (line_buffer);
        }

      apropos_node = message_buffer_to_node ();
      add_gcable_pointer (apropos_node->contents);
      name_internal_node (apropos_node, apropos_list_nodename);

      /* Even though this is an internal node, we don't want the window
         system to treat it specially.  So we turn off the internalness
         of it here. */
      apropos_node->flags &= ~N_IsInternal;

      /* Find/Create a window to contain this node. */
      {
        WINDOW *new;
        NODE *node;

        set_remembered_pagetop_and_point (window);

        /* If a window is visible and showing an apropos list already,
           re-use it. */
        for (new = windows; new; new = new->next)
          {
            node = new->node;

            if (internal_info_node_p (node) &&
                (strcmp (node->nodename, apropos_list_nodename) == 0))
              break;
          }

        /* If we couldn't find an existing window, try to use the next window
           in the chain. */
        if (!new && window->next)
          new = window->next;

        /* If we still don't have a window, make a new one to contain
           the list. */
        if (!new)
          {
            WINDOW *old_active;

            old_active = active_window;
            active_window = window;
            new = window_make_window ((NODE *)NULL);
            active_window = old_active;
          }

        /* If we couldn't make a new window, use this one. */
        if (!new)
          new = window;

        /* Lines do not wrap in this window. */
        new->flags |= W_NoWrap;

        window_set_node_of_window (new, apropos_node);
        remember_window_and_node (new, apropos_node);
        active_window = new;
      }
      info_free_references (apropos_list);
    }
  free (line);

  if (!info_error_was_printed)
    window_clear_echo_area ();
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: indices.c,v 1.15 2002/03/11 13:43:52 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 99, 2002 Free Software Foundation, Inc.
d21 1
a21 1
   Written by Brian Fox (bfox@@ai.mit.edu). */
d58 1
a58 3
add_index_to_index_nodenames (array, node)
     REFERENCE **array;
     NODE *node;
d89 1
a89 2
info_indices_of_window (window)
     WINDOW *window;
d99 1
a99 2
info_indices_of_file_buffer (file_buffer)
     FILE_BUFFER *file_buffer;
d180 1
a180 4
do_info_index_search (window, count, search_string)
     WINDOW *window;
     int count;
     char *search_string;
d199 2
a200 1
      window_message_in_echo_area (_("Finding index entries..."));
d207 1
a207 1
      info_error (_("No indices found."));
d217 1
a217 1
      line = info_read_maybe_completing (window, _("Index entry: "),
d280 1
a280 3
index_entry_exists (window, string)
     WINDOW *window;
     char *string;
d335 1
a335 1
      info_error (_("No previous index search string."));
d342 1
a342 1
      info_error (_("No index entries."));
d375 2
a376 2
      info_error (_("No %sindex entries containing \"%s\"."),
                  index_offset > 0 ? _("more ") : "", index_search);
d386 1
a386 1
    char *name = _("CAN'T SEE THIS");
d405 1
a405 1
        int j, ls, start, upper;
d411 1
a411 1
        for (j = 0; j < ls; j++)
d413 1
a413 1
            match[j + start] = info_tolower (match[j + start]);
d415 1
a415 1
            match[j + start] = info_toupper (match[j + start]);
d422 2
a423 1
        (_("Found \"%s\" in %s. (`\\[next-index-match]' tries to find next.)"));
d425 1
a425 1
      window_message_in_echo_area (format, match, name);
d436 1
a436 1
      info_error (msg_cant_file_node,
d467 1
a467 3
apropos_in_all_indices (search_string, inform)
     char *search_string;
     int inform;
d541 2
a542 1
          message_in_echo_area (_("Scanning indices of \"%s\"..."), files_name);
d596 1
a596 1
   N_("No available info files have \"%s\" in their indices.")
d599 1
a599 2
info_apropos (string)
     char *string;
d606 1
a606 3
    {
      info_error (_(APROPOS_NONE), string);
    }
d626 1
a626 1
  line = info_read_in_echo_area (window, _("Index apropos: "));
d646 1
a646 3
        {
          info_error (_(APROPOS_NONE), line);
        }
d654 2
a655 1
            (_("\n* Menu: Nodes whoses indices contain \"%s\":\n"), line);
d669 1
a669 1
              printf_to_message_buffer ("%s\n", line_buffer);
a735 1

@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: indices.c,v 1.14 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d64 1
a64 1
  for (last = 0; array[last]; last++);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* indices.c -- Commands for dealing with an Info file Index.
   $Id: indices.c,v 1.6 1997/07/24 21:25:53 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d202 1
a202 1
      (strcmp (initial_index_filename, fb->filename) != 0))
d299 1
a299 1
      || (strcmp (initial_index_filename, fb->filename) != 0))
d442 1
a442 1
      info_error (CANT_FILE_NODE,
d447 1
a447 4
  set_remembered_pagetop_and_point (window);
  window_set_node_of_window (window, node);
  remember_window_and_node (window, node);

d497 1
d503 1
d519 5
a523 1
        continue;
d535 13
d603 1
a603 1
   _("No available info files reference \"%s\" in their indices.")
d615 1
a615 1
      info_error (APROPOS_NONE, string);
d623 1
a623 1
        fprintf (stderr, "\"(%s)%s\" -- %s\n",
d657 1
a657 1
          info_error (APROPOS_NONE, line);
d672 7
a678 1
              sprintf (line_buffer, "* (%s)%s::",
a679 2
              len = pad_to (36, line_buffer);
              sprintf (line_buffer + len, "%s", apropos_list[i]->label);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* indices.c -- Commands for dealing with an Info file Index. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d44 3
a46 3
  char *name;			/* The nodename of this index. */
  int first;			/* The index in our list of the first entry. */
  int last;			/* The index in our list of the last entry. */
d66 1
a66 1
  assoc->name = strdup (node->nodename);
d120 4
a123 4
	{
	  free (index_nodenames[i]->name);
	  free (index_nodenames[i]);
	}
d134 30
a163 30
      for (i = 0; tag = file_buffer->tags[i]; i++)
	{
	  if (string_in_line ("Index", tag->nodename) != -1)
	    {
	      NODE *node;
	      REFERENCE **menu;

	      /* Found one.  Get its menu. */
	      node = info_get_node (tag->filename, tag->nodename);
	      if (!node)
		continue;

	      /* Remember the filename and nodename of this index. */
	      initial_index_filename = strdup (file_buffer->filename);
	      initial_index_nodename = strdup (tag->nodename);

	      menu = info_menu_of_node (node);

	      /* If we have a menu, add this index's nodename and range
		 to our list of index_nodenames. */
	      if (menu)
		{
		  add_index_to_index_nodenames (menu, node);

		  /* Concatenate the references found so far. */
		  result = info_concatenate_references (result, menu);
		}
	      free (node);
	    }
	}
d169 1
a169 1
      result[i]->filename = strdup (file_buffer->filename);
d175 12
a186 1
   "Look up a string in the index for this file")
d205 1
a205 1
      window_message_in_echo_area ("Finding index entries...");
d212 1
a212 1
      info_error ("No indices found.");
d216 5
a220 8
  /* Okay, there is an index.  Let the user select one of the members of it. */
  line =
    info_read_maybe_completing (window, "Index entry: ", index_index);

  window = active_window;

  /* User aborted? */
  if (!line)
d222 29
a250 21
      info_abort_key (active_window, 1, 0);
      return;
    }

  /* Empty line means move to the Index node. */
  if (!*line)
    {
      free (line);

      if (initial_index_filename && initial_index_nodename)
	{
	  NODE *node;

	  node =
	    info_get_node (initial_index_filename, initial_index_nodename);
	  set_remembered_pagetop_and_point (window);
	  window_set_node_of_window (window, node);
	  remember_window_and_node (window, node);
	  window_clear_echo_area ();
	  return;
	}
d263 3
a265 3
	register int i;
	for (i = 0; index_index[i]; i++);
	index_offset = i;
d284 47
d332 1
a332 1
 "Go to the next matching index item from the last `\\[index-search]' command")
d342 1
a342 1
      info_error ("No previous index search string.");
d349 1
a349 1
      info_error ("No index entries.");
d372 2
a373 2
	if (string_in_line (index_search, index_index[i]->label) != -1)
	  break;
d376 1
a376 1
	partial = string_in_line (index_search, index_index[i]->label);
d382 2
a383 2
      info_error ("No %sindex entries containing \"%s\".",
		  index_offset > 0 ? "more " : "", index_search);
d393 1
a393 1
    char *name = "CAN'T SEE THIS";
d398 6
a403 6
	if ((i >= index_nodenames[j]->first) &&
	    (i <= index_nodenames[j]->last))
	  {
	    name = index_nodenames[j]->name;
	    break;
	  }
d408 1
a408 1
    match = strdup (index_index[i]->label);
d412 1
a412 1
	int j, ls, start, upper;
d414 9
a422 9
	ls = strlen (index_search);
	start = partial - ls;
	upper = isupper (match[start]) ? 1 : 0;

	for (j = 0; j < ls; j++)
	  if (upper)
	    match[j + start] = info_tolower (match[j + start]);
	  else
	    match[j + start] = info_toupper (match[j + start]);
d429 1
a429 1
	("Found \"%s\" in %s. (`\\[next-index-match]' tries to find next.)");
d443 1
a443 1
		  index_index[i]->filename, index_index[i]->nodename);
d461 2
a462 2
	window->point = loc;
	window_adjust_pagetop (window);
d468 3
a470 3
/*								    */
/*		   Info APROPOS: Search every known index.	    */
/*								    */
a483 1
  int printed = 0;
d490 1
a490 1
    return;
d504 6
a509 6
	{
	  if (dir_node->parent)
	    this_item->filename = strdup (dir_node->parent);
	  else
	    this_item->filename = strdup (dir_node->filename);
	}
d512 1
a512 1
	 entry as a file (i.e., "(LABEL)Top"). */
d516 2
a517 2
	  (strcmp (this_item->label, this_item->nodename) == 0))
	this_node = info_get_node (this_item->label, "Top");
d520 1
a520 1
	continue;
d524 1
a524 1
	char *files_name;
d526 3
a528 3
	files_name = this_node->parent;
	if (!files_name)
	  files_name = this_node->filename;
d530 1
a530 1
	this_fb = info_find_file (files_name);
d532 2
a533 2
	if (this_fb && inform)
	  message_in_echo_area ("Scanning indices of \"%s\"...", files_name);
d535 2
a536 2
	this_index = info_indices_of_file_buffer (this_fb);
	free (this_node);
d538 2
a539 2
	if (this_fb && inform)
	  unmessage_in_echo_area ();
d543 9
a551 9
	{
	  /* Remember the filename which contains this set of references. */
	  for (i = 0; this_index && this_index[i]; i++)
	    if (!this_index[i]->filename)
	      this_index[i]->filename = strdup (this_fb->filename);

	  /* Concatenate with the other indices.  */
	  all_indices = info_concatenate_references (all_indices, this_index);
	}
d564 15
a578 15
	{
	  if (string_in_line (search_string, entry->label) != -1)
	    {
	      add_pointer_to_array
		(entry, apropos_list_index, apropos_list, apropos_list_slots,
		 100, REFERENCE *);
	    }
	  else
	    {
	      maybe_free (entry->label);
	      maybe_free (entry->filename);
	      maybe_free (entry->nodename);
	      free (entry);
	    }
	}
d587 1
a587 1
   "No available info files reference \"%s\" in their indices."
d607 2
a608 2
	fprintf (stderr, "\"(%s)%s\" -- %s\n",
		 entry->filename, entry->nodename, entry->label);
d616 1
a616 1
   "Grovel all known info file's indices for a string and build a menu")
d620 1
a620 1
  line = info_read_in_echo_area (window, "Index apropos: ");
d640 3
a642 3
	{
	  info_error (APROPOS_NONE, line);
	}
d644 20
a663 20
	{
	  register int i;
	  char *line_buffer;

	  initialize_message_buffer ();
	  printf_to_message_buffer
	    ("\n* Menu: Nodes whoses indices contain \"%s\":\n", line);
	  line_buffer = (char *)xmalloc (500);

	  for (i = 0; apropos_list[i]; i++)
	    {
	      int len;
	      sprintf (line_buffer, "* (%s)%s::",
		       apropos_list[i]->filename, apropos_list[i]->nodename);
	      len = pad_to (36, line_buffer);
	      sprintf (line_buffer + len, "%s", apropos_list[i]->label);
	      printf_to_message_buffer ("%s\n", line_buffer);
	    }
	  free (line_buffer);
	}
d670 2
a671 2
	 system to treat it specially.  So we turn off the internalness
	 of it here. */
d676 2
a677 2
	WINDOW *new;
	NODE *node;
d679 1
a679 1
	set_remembered_pagetop_and_point (window);
d681 38
a718 38
	/* If a window is visible and showing an apropos list already,
	   re-use it. */
	for (new = windows; new; new = new->next)
	  {
	    node = new->node;

	    if (internal_info_node_p (node) &&
		(strcmp (node->nodename, apropos_list_nodename) == 0))
	      break;
	  }

	/* If we couldn't find an existing window, try to use the next window
	   in the chain. */
	if (!new && window->next)
	  new = window->next;

	/* If we still don't have a window, make a new one to contain
	   the list. */
	if (!new)
	  {
	    WINDOW *old_active;

	    old_active = active_window;
	    active_window = window;
	    new = window_make_window ((NODE *)NULL);
	    active_window = old_active;
	  }

	/* If we couldn't make a new window, use this one. */
	if (!new)
	  new = window;

	/* Lines do not wrap in this window. */
	new->flags |= W_NoWrap;

	window_set_node_of_window (new, apropos_node);
	remember_window_and_node (new, apropos_node);
	active_window = new;
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* indices.c -- Commands for dealing with an Info file Index.
   $Id: indices.c,v 1.6 1997/07/24 21:25:53 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d46 3
a48 3
  char *name;                   /* The nodename of this index. */
  int first;                    /* The index in our list of the first entry. */
  int last;                     /* The index in our list of the last entry. */
d68 1
a68 1
  assoc->name = xstrdup (node->nodename);
d122 4
a125 4
        {
          free (index_nodenames[i]->name);
          free (index_nodenames[i]);
        }
d136 30
a165 30
      for (i = 0; (tag = file_buffer->tags[i]); i++)
        {
          if (string_in_line ("Index", tag->nodename) != -1)
            {
              NODE *node;
              REFERENCE **menu;

              /* Found one.  Get its menu. */
              node = info_get_node (tag->filename, tag->nodename);
              if (!node)
                continue;

              /* Remember the filename and nodename of this index. */
              initial_index_filename = xstrdup (file_buffer->filename);
              initial_index_nodename = xstrdup (tag->nodename);

              menu = info_menu_of_node (node);

              /* If we have a menu, add this index's nodename and range
                 to our list of index_nodenames. */
              if (menu)
                {
                  add_index_to_index_nodenames (menu, node);

                  /* Concatenate the references found so far. */
                  result = info_concatenate_references (result, menu);
                }
              free (node);
            }
        }
d171 1
a171 1
      result[i]->filename = xstrdup (file_buffer->filename);
d177 1
a177 12
   _("Look up a string in the index for this file"))
{
  do_info_index_search (window, count, 0);
}

/* Look up SEARCH_STRING in the index for this file.  If SEARCH_STRING
   is NULL, prompt user for input.  */ 
void
do_info_index_search (window, count, search_string)
     WINDOW *window;
     int count;
     char *search_string;
d196 1
a196 1
      window_message_in_echo_area (_("Finding index entries..."));
d203 1
a203 1
      info_error (_("No indices found."));
d207 15
a221 5
  /* Okay, there is an index.  Look for SEARCH_STRING, or, if it is
     empty, prompt for one.  */
  if (search_string && *search_string)
    line = xstrdup (search_string);
  else
d223 14
a236 29
      line = info_read_maybe_completing (window, _("Index entry: "),
                                         index_index);
      window = active_window;

      /* User aborted? */
      if (!line)
        {
          info_abort_key (active_window, 1, 0);
          return;
        }

      /* Empty line means move to the Index node. */
      if (!*line)
        {
          free (line);

          if (initial_index_filename && initial_index_nodename)
            {
              NODE *node;

              node = info_get_node (initial_index_filename,
                                    initial_index_nodename);
              set_remembered_pagetop_and_point (window);
              window_set_node_of_window (window, node);
              remember_window_and_node (window, node);
              window_clear_echo_area ();
              return;
            }
        }
d249 3
a251 3
        register int i;
        for (i = 0; index_index[i]; i++);
        index_offset = i;
a269 47
int
index_entry_exists (window, string)
     WINDOW *window;
     char *string;
{
  register int i;
  FILE_BUFFER *fb;

  /* If there is no previous search string, the user hasn't built an index
     yet. */
  if (!string)
    return 0;

  fb = file_buffer_of_window (window);
  if (!initial_index_filename
      || (strcmp (initial_index_filename, fb->filename) != 0))
    {
      info_free_references (index_index);
      index_index = info_indices_of_file_buffer (fb);
    }

  /* If there is no index, that is an error. */
  if (!index_index)
    return 0;

  for (i = 0; (i > -1) && (index_index[i]); i++)
    if (strcmp (string, index_index[i]->label) == 0)
      break;

  /* If that failed, look for the next substring match. */
  if ((i < 0) || (!index_index[i]))
    {
      for (i = 0; (i > -1) && (index_index[i]); i++)
        if (string_in_line (string, index_index[i]->label) != -1)
          break;

      if ((i > -1) && (index_index[i]))
        string_in_line (string, index_index[i]->label);
    }

  /* If that failed, return 0. */
  if ((i < 0) || (!index_index[i]))
    return 0;

  return 1;
}

d271 1
a271 1
 _("Go to the next matching index item from the last `\\[index-search]' command"))
d281 1
a281 1
      info_error (_("No previous index search string."));
d288 1
a288 1
      info_error (_("No index entries."));
d311 2
a312 2
        if (string_in_line (index_search, index_index[i]->label) != -1)
          break;
d315 1
a315 1
        partial = string_in_line (index_search, index_index[i]->label);
d321 2
a322 2
      info_error (_("No %sindex entries containing \"%s\"."),
                  index_offset > 0 ? _("more ") : "", index_search);
d332 1
a332 1
    char *name = _("CAN'T SEE THIS");
d337 6
a342 6
        if ((i >= index_nodenames[j]->first) &&
            (i <= index_nodenames[j]->last))
          {
            name = index_nodenames[j]->name;
            break;
          }
d347 1
a347 1
    match = xstrdup (index_index[i]->label);
d351 1
a351 1
        int j, ls, start, upper;
d353 9
a361 9
        ls = strlen (index_search);
        start = partial - ls;
        upper = isupper (match[start]) ? 1 : 0;

        for (j = 0; j < ls; j++)
          if (upper)
            match[j + start] = info_tolower (match[j + start]);
          else
            match[j + start] = info_toupper (match[j + start]);
d368 1
a368 1
        (_("Found \"%s\" in %s. (`\\[next-index-match]' tries to find next.)"));
d382 1
a382 1
                  index_index[i]->filename, index_index[i]->nodename);
d400 2
a401 2
        window->point = loc;
        window_adjust_pagetop (window);
d407 3
a409 3
/*                                                                  */
/*                 Info APROPOS: Search every known index.          */
/*                                                                  */
d423 1
d430 1
a430 1
    return NULL;
d444 6
a449 6
        {
          if (dir_node->parent)
            this_item->filename = xstrdup (dir_node->parent);
          else
            this_item->filename = xstrdup (dir_node->filename);
        }
d452 1
a452 1
         entry as a file (i.e., "(LABEL)Top"). */
d456 2
a457 2
          (strcmp (this_item->label, this_item->nodename) == 0))
        this_node = info_get_node (this_item->label, "Top");
d460 1
a460 1
        continue;
d464 1
a464 1
        char *files_name;
d466 3
a468 3
        files_name = this_node->parent;
        if (!files_name)
          files_name = this_node->filename;
d470 1
a470 1
        this_fb = info_find_file (files_name);
d472 2
a473 2
        if (this_fb && inform)
          message_in_echo_area (_("Scanning indices of \"%s\"..."), files_name);
d475 2
a476 2
        this_index = info_indices_of_file_buffer (this_fb);
        free (this_node);
d478 2
a479 2
        if (this_fb && inform)
          unmessage_in_echo_area ();
d483 9
a491 9
        {
          /* Remember the filename which contains this set of references. */
          for (i = 0; this_index && this_index[i]; i++)
            if (!this_index[i]->filename)
              this_index[i]->filename = xstrdup (this_fb->filename);

          /* Concatenate with the other indices.  */
          all_indices = info_concatenate_references (all_indices, this_index);
        }
d504 15
a518 15
        {
          if (string_in_line (search_string, entry->label) != -1)
            {
              add_pointer_to_array
                (entry, apropos_list_index, apropos_list, apropos_list_slots,
                 100, REFERENCE *);
            }
          else
            {
              maybe_free (entry->label);
              maybe_free (entry->filename);
              maybe_free (entry->nodename);
              free (entry);
            }
        }
d527 1
a527 1
   _("No available info files reference \"%s\" in their indices.")
d547 2
a548 2
        fprintf (stderr, "\"(%s)%s\" -- %s\n",
                 entry->filename, entry->nodename, entry->label);
d556 1
a556 1
   _("Grovel all known info file's indices for a string and build a menu"))
d560 1
a560 1
  line = info_read_in_echo_area (window, _("Index apropos: "));
d580 3
a582 3
        {
          info_error (APROPOS_NONE, line);
        }
d584 20
a603 20
        {
          register int i;
          char *line_buffer;

          initialize_message_buffer ();
          printf_to_message_buffer
            (_("\n* Menu: Nodes whoses indices contain \"%s\":\n"), line);
          line_buffer = (char *)xmalloc (500);

          for (i = 0; apropos_list[i]; i++)
            {
              int len;
              sprintf (line_buffer, "* (%s)%s::",
                       apropos_list[i]->filename, apropos_list[i]->nodename);
              len = pad_to (36, line_buffer);
              sprintf (line_buffer + len, "%s", apropos_list[i]->label);
              printf_to_message_buffer ("%s\n", line_buffer);
            }
          free (line_buffer);
        }
d610 2
a611 2
         system to treat it specially.  So we turn off the internalness
         of it here. */
d616 2
a617 2
        WINDOW *new;
        NODE *node;
d619 1
a619 1
        set_remembered_pagetop_and_point (window);
d621 38
a658 38
        /* If a window is visible and showing an apropos list already,
           re-use it. */
        for (new = windows; new; new = new->next)
          {
            node = new->node;

            if (internal_info_node_p (node) &&
                (strcmp (node->nodename, apropos_list_nodename) == 0))
              break;
          }

        /* If we couldn't find an existing window, try to use the next window
           in the chain. */
        if (!new && window->next)
          new = window->next;

        /* If we still don't have a window, make a new one to contain
           the list. */
        if (!new)
          {
            WINDOW *old_active;

            old_active = active_window;
            active_window = window;
            new = window_make_window ((NODE *)NULL);
            active_window = old_active;
          }

        /* If we couldn't make a new window, use this one. */
        if (!new)
          new = window;

        /* Lines do not wrap in this window. */
        new->flags |= W_NoWrap;

        window_set_node_of_window (new, apropos_node);
        remember_window_and_node (new, apropos_node);
        active_window = new;
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* indices.c -- deal with an Info file index.
   $Id: indices.c,v 1.14 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d202 1
a202 1
      (FILENAME_CMP (initial_index_filename, fb->filename) != 0))
d299 1
a299 1
      || (FILENAME_CMP (initial_index_filename, fb->filename) != 0))
d442 1
a442 1
      info_error (msg_cant_file_node,
d447 4
a450 1
  info_set_node_of_window (1, window, node);
a499 1
      int dir_node_duplicated = 0;
a504 1
	  dir_node_duplicated = 1;
d520 1
a520 5
	{
	  if (dir_node_duplicated)
	    free (this_item->filename);
	  continue;
	}
a531 13
	/* If we already scanned this file, don't do that again.
	   In addition to being faster, this also avoids having
	   multiple identical entries in the *Apropos* menu.  */
	for (i = 0; i < dir_index; i++)
	  if (FILENAME_CMP (this_fb->filename, dir_menu[i]->filename) == 0)
	    break;
	if (i < dir_index)
	  {
	    if (dir_node_duplicated)
	      free (this_item->filename);
	    continue;
	  }

d587 1
a587 1
   N_("No available info files have \"%s\" in their indices.")
d599 1
a599 1
      info_error (_(APROPOS_NONE), string);
d607 1
a607 1
        fprintf (stdout, "\"(%s)%s\" -- %s\n",
d641 1
a641 1
          info_error (_(APROPOS_NONE), line);
d656 1
a656 7
	      /* The label might be identical to that of another index
		 entry in another Info file.  Therefore, we make the file
		 name part of the menu entry, to make them all distinct.  */
              sprintf (line_buffer, "* %s [%s]: ",
		       apropos_list[i]->label, apropos_list[i]->filename);
              len = pad_to (40, line_buffer);
              sprintf (line_buffer + len, "(%s)%s.",
d658 2
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: indices.c,v 1.15 2002/03/11 13:43:52 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99, 2002 Free Software Foundation, Inc.
d64 1
a64 1
  for (last = 0; array[last + 1]; last++);
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: indices.c,v 1.5 2004/04/11 17:56:45 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 1999, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d20 1
a20 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
d57 3
a59 1
add_index_to_index_nodenames (REFERENCE **array, NODE *node)
d90 2
a91 1
info_indices_of_window (WINDOW *window)
d101 2
a102 1
info_indices_of_file_buffer (FILE_BUFFER *file_buffer)
d183 4
a186 1
do_info_index_search (WINDOW *window, int count, char *search_string)
d205 1
a205 2
      window_message_in_echo_area ((char *) _("Finding index entries..."),
          NULL, NULL);
d212 1
a212 1
      info_error ((char *) _("No indices found."), NULL, NULL);
d222 1
a222 1
      line = info_read_maybe_completing (window, (char *) _("Index entry: "),
d285 3
a287 1
index_entry_exists (WINDOW *window, char *string)
d342 1
a342 1
      info_error ((char *) _("No previous index search string."), NULL, NULL);
d349 1
a349 1
      info_error ((char *) _("No index entries."), NULL, NULL);
d382 2
a383 2
      info_error ((char *) _("No %sindex entries containing `%s'."),
                  index_offset > 0 ? (char *) _("more ") : "", index_search);
d393 1
a393 1
    const char *name = _("CAN'T SEE THIS");
d412 1
a412 1
        int k, ls, start, upper;
d418 1
a418 1
        for (k = 0; k < ls; k++)
d420 1
a420 1
            match[k + start] = info_tolower (match[k + start]);
d422 1
a422 1
            match[k + start] = info_toupper (match[k + start]);
d429 1
a429 2
        ((char *) _("Found `%s' in %s. (`\\[next-index-match]' tries to find next.)"),
         0);
d431 1
a431 1
      window_message_in_echo_area (format, match, (char *) name);
d442 1
a442 1
      info_error ((char *) msg_cant_file_node,
d473 3
a475 1
apropos_in_all_indices (char *search_string, int inform)
d549 1
a549 2
          message_in_echo_area ((char *) _("Scanning indices of `%s'..."),
              files_name, NULL);
d603 1
a603 1
   N_("No available info files have `%s' in their indices.")
d606 2
a607 1
info_apropos (char *string)
d614 3
a616 1
    info_error ((char *) _(APROPOS_NONE), string, NULL);
d636 1
a636 1
  line = info_read_in_echo_area (window, (char *) _("Index apropos: "));
d656 3
a658 1
        info_error ((char *) _(APROPOS_NONE), line, NULL);
d666 1
a666 2
            ((char *) _("\n* Menu: Nodes whose indices contain `%s':\n"),
             line, NULL, NULL);
d680 1
a680 1
              printf_to_message_buffer ("%s\n", line_buffer, NULL, NULL);
d747 1
@


