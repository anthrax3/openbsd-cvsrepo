head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.44
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.24;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.47;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.05;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* infodoc.c -- functions which build documentation nodes.
   $Id: infodoc.c,v 1.8 2004/04/11 17:56:45 karl Exp $

   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "funs.h"

/* HELP_NODE_GETS_REGENERATED is always defined now that keys may get
   rebound, or other changes in the help text may occur.  */
#define HELP_NODE_GETS_REGENERATED 1

/* The name of the node used in the help window. */
static char *info_help_nodename = "*Info Help*";

/* A node containing printed key bindings and their documentation. */
static NODE *internal_info_help_node = (NODE *)NULL;

/* A pointer to the contents of the help node. */
static char *internal_info_help_node_contents = (char *)NULL;

/* The (more or less) static text which appears in the internal info
   help node.  The actual key bindings are inserted.  Keep the
   underlines (****, etc.) in the same N_ call as  the text lines they
   refer to, so translations can make the number of *'s or -'s match.  */
#if defined(INFOKEY)

static char *info_internal_help_text[] = {
  N_("Basic Commands in Info Windows\n\
******************************\n"),
  "\n",
  N_("\\%-10[quit-help]  Quit this help.\n"),
  N_("\\%-10[quit]  Quit Info altogether.\n"),
  N_("\\%-10[get-info-help-node]  Invoke the Info tutorial.\n"),
  "\n",
  N_("Selecting other nodes:\n\
----------------------\n"),
  N_("\\%-10[next-node]  Move to the \"next\" node of this node.\n"),
  N_("\\%-10[prev-node]  Move to the \"previous\" node of this node.\n"),
  N_("\\%-10[up-node]  Move \"up\" from this node.\n"),
  N_("\\%-10[menu-item]  Pick menu item specified by name.\n\
              Picking a menu item causes another node to be selected.\n"),
  N_("\\%-10[xref-item]  Follow a cross reference.  Reads name of reference.\n"),
  N_("\\%-10[history-node]  Move to the last node seen in this window.\n"),
  N_("\\%-10[move-to-next-xref]  Skip to next hypertext link within this node.\n"),
  N_("\\%-10[move-to-prev-xref]  Skip to previous hypertext link within this node.\n"),
  N_("\\%-10[select-reference-this-line]  Follow the hypertext link under cursor.\n"),
  N_("\\%-10[dir-node]  Move to the `directory' node.  Equivalent to `\\[goto-node] (DIR)'.\n"),
  N_("\\%-10[top-node]  Move to the Top node.  Equivalent to `\\[goto-node] Top'.\n"),
  "\n",
  N_("Moving within a node:\n\
---------------------\n"),
  N_("\\%-10[beginning-of-node]  Go to the beginning of this node.\n"),
  N_("\\%-10[end-of-node]  Go to the end of this node.\n"),
  N_("\\%-10[next-line]  Scroll forward 1 line.\n"),
  N_("\\%-10[prev-line]  Scroll backward 1 line.\n"),
  N_("\\%-10[scroll-forward]  Scroll forward a page.\n"),
  N_("\\%-10[scroll-backward]  Scroll backward a page.\n"),
  "\n",
  N_("Other commands:\n\
---------------\n"),
  N_("\\%-10[menu-digit]  Pick first ... ninth item in node's menu.\n"),
  N_("\\%-10[last-menu-item]  Pick last item in node's menu.\n"),
  N_("\\%-10[index-search]  Search for a specified string in the index entries of this Info\n\
              file, and select the node referenced by the first entry found.\n"),
  N_("\\%-10[goto-node]  Move to node specified by name.\n\
              You may include a filename as well, as in (FILENAME)NODENAME.\n"),
  N_("\\%-10[search]  Search forward for a specified string\n\
              and select the node in which the next occurrence is found.\n"),
  N_("\\%-10[search-backward]  Search backward for a specified string\n\
              and select the node in which the previous occurrence is found.\n"),
  NULL
};

#else /* !INFOKEY */

static char *info_internal_help_text[] = {
  N_("Basic Commands in Info Windows\n\
******************************\n"),
  "\n",
  N_("  %-10s  Quit this help.\n"),
  N_("  %-10s  Quit Info altogether.\n"),
  N_("  %-10s  Invoke the Info tutorial.\n"),
  "\n",
  N_("Selecting other nodes:\n\
----------------------\n",
  N_("  %-10s  Move to the `next' node of this node.\n"),
  N_("  %-10s  Move to the `previous' node of this node.\n"),
  N_("  %-10s  Move `up' from this node.\n"),
  N_("  %-10s  Pick menu item specified by name.\n"),
  N_("              Picking a menu item causes another node to be selected.\n"),
  N_("  %-10s  Follow a cross reference.  Reads name of reference.\n"),
  N_("  %-10s  Move to the last node seen in this window.\n"),
  N_("  %-10s  Skip to next hypertext link within this node.\n"),
  N_("  %-10s  Follow the hypertext link under cursor.\n"),
  N_("  %-10s  Move to the `directory' node.  Equivalent to `g (DIR)'.\n"),
  N_("  %-10s  Move to the Top node.  Equivalent to `g Top'.\n"),
  "\n",
  N_("Moving within a node:\n\
---------------------\n"),
  N_("  %-10s  Scroll forward a page.\n"),
  N_("  %-10s  Scroll backward a page.\n"),
  N_("  %-10s  Go to the beginning of this node.\n"),
  N_("  %-10s  Go to the end of this node.\n"),
  N_("  %-10s  Scroll forward 1 line.\n"),
  N_("  %-10s  Scroll backward 1 line.\n"),
  "\n",
  N_("Other commands:\n\
---------------\n"),
  N_("  %-10s  Pick first ... ninth item in node's menu.\n"),
  N_("  %-10s  Pick last item in node's menu.\n"),
  N_("  %-10s  Search for a specified string in the index entries of this Info\n"),
  N_("              file, and select the node referenced by the first entry found.\n"),
  N_("  %-10s  Move to node specified by name.\n"),
  N_("              You may include a filename as well, as in (FILENAME)NODENAME.\n"),
  N_("  %-10s  Search forward for a specified string,\n"),
  N_("              and select the node in which the next occurrence is found.\n"),
  N_("  %-10s  Search backward for a specified string\n"),
  N_("              and select the node in which the next occurrence is found.\n"),
  NULL
};

static char *info_help_keys_text[][2] = {
  { "", "" },
  { "", "" },
  { "", "" },
  { "CTRL-x 0", "CTRL-x 0" },
  { "q", "q" },
  { "h", "ESC h" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "SPC", "SPC" },
  { "DEL", "b" },
  { "b", "ESC b" },
  { "e", "ESC e" },
  { "ESC 1 SPC", "RET" },
  { "ESC 1 DEL", "y" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "n", "CTRL-x n" },
  { "p", "CTRL-x p" },
  { "u", "CTRL-x u" },
  { "m", "ESC m" },
  { "", "" },
  { "f", "ESC f" },
  { "l", "l" },
  { "TAB", "TAB" },
  { "RET", "CTRL-x RET" },
  { "d", "ESC d" },
  { "t", "ESC t" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "1-9", "ESC 1-9" },
  { "0", "ESC 0" },
  { "i", "CTRL-x i" },
  { "", "" },
  { "g", "CTRL-x g" },
  { "", "" },
  { "s", "/" },
  { "", "" },
  { "ESC - s", "?" },
  { "", "" },
  NULL
};

#endif /* !INFOKEY */

static char *where_is_internal (Keymap map, InfoCommand *cmd);

void
dump_map_to_message_buffer (char *prefix, Keymap map)
{
  register int i;
  unsigned prefix_len = strlen (prefix);
  char *new_prefix = (char *)xmalloc (prefix_len + 2);

  strncpy (new_prefix, prefix, prefix_len);
  new_prefix[prefix_len + 1] = '\0';

  for (i = 0; i < 256; i++)
    {
      new_prefix[prefix_len] = i;
      if (map[i].type == ISKMAP)
        {
          dump_map_to_message_buffer (new_prefix, (Keymap)map[i].function);
        }
      else if (map[i].function)
        {
          register int last;
          char *doc, *name;

          doc = function_documentation (map[i].function);
          name = function_name (map[i].function);

          if (!*doc)
            continue;

          /* Find out if there is a series of identical functions, as in
             ea_insert (). */
          for (last = i + 1; last < 256; last++)
            if ((map[last].type != ISFUNC) ||
                (map[last].function != map[i].function))
              break;

          if (last - 1 != i)
            {
              printf_to_message_buffer ("%s .. ", pretty_keyseq (new_prefix),
                  NULL, NULL);
              new_prefix[prefix_len] = last - 1;
              printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix),
                  NULL, NULL);
              i = last - 1;
            }
          else
            printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix),
                NULL, NULL);

#if defined (NAMED_FUNCTIONS)
          /* Print the name of the function, and some padding before the
             documentation string is printed. */
          {
            int length_so_far;
            int desired_doc_start = 40; /* Must be multiple of 8. */

            printf_to_message_buffer ("(%s)", name, NULL, NULL);
            length_so_far = message_buffer_length_this_line ();

            if ((desired_doc_start + strlen (doc))
                >= (unsigned int) the_screen->width)
              printf_to_message_buffer ("\n     ", NULL, NULL, NULL);
            else
              {
                while (length_so_far < desired_doc_start)
                  {
                    printf_to_message_buffer ("\t", NULL, NULL, NULL);
                    length_so_far += character_width ('\t', length_so_far);
                  }
              }
          }
#endif /* NAMED_FUNCTIONS */
          printf_to_message_buffer ("%s\n", doc, NULL, NULL);
        }
    }
  free (new_prefix);
}

/* How to create internal_info_help_node.  HELP_IS_ONLY_WINDOW_P says
   whether we're going to end up in a second (or more) window of our
   own, or whether there's only one window and we're going to usurp it.
   This determines how to quit the help window.  Maybe we should just
   make q do the right thing in both cases.  */

static void
create_internal_info_help_node (int help_is_only_window_p)
{
  register int i;
  NODE *node;
  char *contents = NULL;
  char *exec_keys;

#ifndef HELP_NODE_GETS_REGENERATED
  if (internal_info_help_node_contents)
    contents = internal_info_help_node_contents;
#endif /* !HELP_NODE_GETS_REGENERATED */

  if (!contents)
    {
      int printed_one_mx = 0;

      initialize_message_buffer ();

      for (i = 0; info_internal_help_text[i]; i++)
        {
#ifdef INFOKEY
          printf_to_message_buffer (replace_in_documentation
              ((char *) _(info_internal_help_text[i]), help_is_only_window_p),
              NULL, NULL, NULL);
#else
          /* Don't translate blank lines, gettext outputs the po file
             header in that case.  We want a blank line.  */
          char *msg = *(info_internal_help_text[i])
                      ? _(info_internal_help_text[i])
                      : info_internal_help_text[i];
          char *key = info_help_keys_text[i][vi_keys_p];

          /* If we have only one window (because the window size was too
             small to split it), CTRL-x 0 doesn't work to `quit' help.  */
          if (STREQ (key, "CTRL-x 0") && help_is_only_window_p)
            key = "l";

          printf_to_message_buffer (msg, key, NULL, NULL);
#endif /* !INFOKEY */
        }

      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("The current search path is:\n"),
          NULL, NULL, NULL);
      printf_to_message_buffer ("  %s\n", infopath, NULL, NULL);
      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("Commands available in Info windows:\n\n"),
          NULL, NULL, NULL);
      dump_map_to_message_buffer ("", info_keymap);
      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("Commands available in the echo area:\n\n"),
          NULL, NULL, NULL);
      dump_map_to_message_buffer ("", echo_area_keymap);

#if defined (NAMED_FUNCTIONS)
      /* Get a list of commands which have no keystroke equivs. */
      exec_keys = where_is (info_keymap, InfoCmd(info_execute_command));
      if (exec_keys)
        exec_keys = xstrdup (exec_keys);
      for (i = 0; function_doc_array[i].func; i++)
        {
          InfoCommand *cmd = DocInfoCmd(&function_doc_array[i]);

          if (InfoFunction(cmd) != (VFunction *) info_do_lowercase_version
              && !where_is_internal (info_keymap, cmd)
              && !where_is_internal (echo_area_keymap, cmd))
            {
              if (!printed_one_mx)
                {
                  printf_to_message_buffer ("---------------------\n\n",
                      NULL, NULL, NULL);
                  if (exec_keys && exec_keys[0])
                      printf_to_message_buffer
                        ((char *) _("The following commands can only be invoked via %s:\n\n"),
                         exec_keys, NULL, NULL);
                  else
                      printf_to_message_buffer
                        ((char *) _("The following commands cannot be invoked at all:\n\n"),
                         NULL, NULL, NULL);
                  printed_one_mx = 1;
                }

              printf_to_message_buffer
                ("%s %s\n     %s\n",
                 exec_keys,
                 function_doc_array[i].func_name,
                 replace_in_documentation (strlen (function_doc_array[i].doc)
                   ? (char *) _(function_doc_array[i].doc) : "", 0)
                );

            }
        }

      if (printed_one_mx)
        printf_to_message_buffer ("\n", NULL, NULL, NULL);

      maybe_free (exec_keys);
#endif /* NAMED_FUNCTIONS */

      printf_to_message_buffer
        ("%s", replace_in_documentation
         ((char *) _("--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n"), 0),
         NULL, NULL);
      node = message_buffer_to_node ();
      internal_info_help_node_contents = node->contents;
    }
  else
    {
      /* We already had the right contents, so simply use them. */
      node = build_message_node ("", 0, 0);
      free (node->contents);
      node->contents = contents;
      node->nodelen = 1 + strlen (contents);
    }

  internal_info_help_node = node;

  /* Do not GC this node's contents.  It never changes, and we never need
     to delete it once it is made.  If you change some things (such as
     placing information about dynamic variables in the help text) then
     you will need to allow the contents to be gc'd, and you will have to
     arrange to always regenerate the help node. */
#if defined (HELP_NODE_GETS_REGENERATED)
  add_gcable_pointer (internal_info_help_node->contents);
#endif

  name_internal_node (internal_info_help_node, info_help_nodename);

  /* Even though this is an internal node, we don't want the window
     system to treat it specially.  So we turn off the internalness
     of it here. */
  internal_info_help_node->flags &= ~N_IsInternal;
}

/* Return a window which is the window showing help in this Info. */

/* If the eligible window's height is >= this, split it to make the help
   window.  Otherwise display the help window in the current window.  */
#define HELP_SPLIT_SIZE 24

static WINDOW *
info_find_or_create_help_window (void)
{
  int help_is_only_window_p;
  WINDOW *eligible = NULL;
  WINDOW *help_window = get_window_of_node (internal_info_help_node);

  /* If we couldn't find the help window, then make it. */
  if (!help_window)
    {
      WINDOW *window;
      int max = 0;

      for (window = windows; window; window = window->next)
        {
          if (window->height > max)
            {
              max = window->height;
              eligible = window;
            }
        }

      if (!eligible)
        return NULL;
    }
#ifndef HELP_NODE_GETS_REGENERATED
  else
    /* help window is static, just return it.  */
    return help_window;
#endif /* not HELP_NODE_GETS_REGENERATED */

  /* Make sure that we have a node containing the help text.  The
     argument is false if help will be the only window (so l must be used
     to quit help), true if help will be one of several visible windows
     (so CTRL-x 0 must be used to quit help).  */
  help_is_only_window_p = ((help_window && !windows->next)
        || (!help_window && eligible->height < HELP_SPLIT_SIZE));
  create_internal_info_help_node (help_is_only_window_p);

  /* Either use the existing window to display the help node, or create
     a new window if there was no existing help window. */
  if (!help_window)
    { /* Split the largest window into 2 windows, and show the help text
         in that window. */
      if (eligible->height >= HELP_SPLIT_SIZE)
        {
          active_window = eligible;
          help_window = window_make_window (internal_info_help_node);
        }
      else
        {
          set_remembered_pagetop_and_point (active_window);
          window_set_node_of_window (active_window, internal_info_help_node);
          help_window = active_window;
        }
    }
  else
    { /* Case where help node always gets regenerated, and we have an
         existing window in which to place the node. */
      if (active_window != help_window)
        {
          set_remembered_pagetop_and_point (active_window);
          active_window = help_window;
        }
      window_set_node_of_window (active_window, internal_info_help_node);
    }
  remember_window_and_node (help_window, help_window->node);
  return help_window;
}

/* Create or move to the help window. */
DECLARE_INFO_COMMAND (info_get_help_window, _("Display help message"))
{
  WINDOW *help_window;

  help_window = info_find_or_create_help_window ();
  if (help_window)
    {
      active_window = help_window;
      active_window->flags |= W_UpdateWindow;
    }
  else
    {
      info_error ((char *) msg_cant_make_help, NULL, NULL);
    }
}

/* Show the Info help node.  This means that the "info" file is installed
   where it can easily be found on your system. */
DECLARE_INFO_COMMAND (info_get_info_help_node, _("Visit Info node `(info)Help'"))
{
  NODE *node;
  char *nodename;

  /* If there is a window on the screen showing the node "(info)Help" or
     the node "(info)Help-Small-Screen", simply select that window. */
  {
    WINDOW *win;

    for (win = windows; win; win = win->next)
      {
        if (win->node && win->node->filename &&
            (strcasecmp
             (filename_non_directory (win->node->filename), "info") == 0) &&
            ((strcmp (win->node->nodename, "Help") == 0) ||
             (strcmp (win->node->nodename, "Help-Small-Screen") == 0)))
          {
            active_window = win;
            return;
          }
      }
  }

  /* If the current window is small, show the small screen help. */
  if (active_window->height < 24)
    nodename = "Help-Small-Screen";
  else
    nodename = "Help";

  /* Try to get the info file for Info. */
  node = info_get_node ("Info", nodename);

  if (!node)
    {
      if (info_recent_file_error)
        info_error (info_recent_file_error, NULL, NULL);
      else
        info_error ((char *) msg_cant_file_node, "Info", nodename);
    }
  else
    {
      /* If the current window is very large (greater than 45 lines),
         then split it and show the help node in another window.
         Otherwise, use the current window. */

      if (active_window->height > 45)
        active_window = window_make_window (node);
      else
        {
          set_remembered_pagetop_and_point (active_window);
          window_set_node_of_window (active_window, node);
        }

      remember_window_and_node (active_window, node);
    }
}

/* **************************************************************** */
/*                                                                  */
/*                   Groveling Info Keymaps and Docs                */
/*                                                                  */
/* **************************************************************** */

/* Return the documentation associated with the Info command FUNCTION. */
char *
function_documentation (InfoCommand *cmd)
{
  char *doc;

#if defined (INFOKEY)

  doc = cmd->doc;

#else /* !INFOKEY */

  register int i;

  for (i = 0; function_doc_array[i].func; i++)
    if (InfoFunction(cmd) == function_doc_array[i].func)
      break;

  doc = function_doc_array[i].func ? function_doc_array[i].doc : "";

#endif /* !INFOKEY */

  return replace_in_documentation ((strlen (doc) == 0) ? doc : (char *) _(doc), 0);
}

#if defined (NAMED_FUNCTIONS)
/* Return the user-visible name of the function associated with the
   Info command FUNCTION. */
char *
function_name (InfoCommand *cmd)
{
#if defined (INFOKEY)

  return cmd->func_name;

#else /* !INFOKEY */

  register int i;

  for (i = 0; function_doc_array[i].func; i++)
    if (InfoFunction(cmd) == function_doc_array[i].func)
      break;

  return (function_doc_array[i].func_name);

#endif /* !INFOKEY */
}

/* Return a pointer to the info command for function NAME. */
InfoCommand *
named_function (char *name)
{
  register int i;

  for (i = 0; function_doc_array[i].func; i++)
    if (strcmp (function_doc_array[i].func_name, name) == 0)
      break;

  return (DocInfoCmd(&function_doc_array[i]));
}
#endif /* NAMED_FUNCTIONS */

/* Return the documentation associated with KEY in MAP. */
char *
key_documentation (char key, Keymap map)
{
  InfoCommand *function = map[key].function;

  if (function)
    return (function_documentation (function));
  else
    return ((char *)NULL);
}

DECLARE_INFO_COMMAND (describe_key, _("Print documentation for KEY"))
{
  char keys[50];
  unsigned char keystroke;
  char *k = keys;
  Keymap map;

  *k = '\0';
  map = window->keymap;

  for (;;)
    {
      message_in_echo_area ((char *) _("Describe key: %s"),
          pretty_keyseq (keys), NULL);
      keystroke = info_get_input_char ();
      unmessage_in_echo_area ();

#if !defined (INFOKEY)
      if (Meta_p (keystroke))
        {
          if (map[ESC].type != ISKMAP)
            {
              window_message_in_echo_area
              (_("ESC %s is undefined."), pretty_keyname (UnMeta (keystroke)));
              return;
            }

          *k++ = '\e';
          keystroke = UnMeta (keystroke);
          map = (Keymap)map[ESC].function;
        }
#endif /* !INFOKEY */

      /* Add the KEYSTROKE to our list. */
      *k++ = keystroke;
      *k = '\0';

      if (map[keystroke].function == (InfoCommand *)NULL)
        {
          message_in_echo_area ((char *) _("%s is undefined."),
              pretty_keyseq (keys), NULL);
          return;
        }
      else if (map[keystroke].type == ISKMAP)
        {
          map = (Keymap)map[keystroke].function;
          continue;
        }
      else
        {
          char *keyname, *message, *fundoc, *funname = "";

#if defined (INFOKEY)
          /* If the key is bound to do-lowercase-version, but its
             lower-case variant is undefined, say that this key is
             also undefined.  This is especially important for unbound
             edit keys that emit an escape sequence: it's terribly
             confusing to see a message "Home (do-lowercase-version)"
             or some such when Home is unbound.  */
          if (InfoFunction(map[keystroke].function)
              == (VFunction *) info_do_lowercase_version)
            {
              unsigned char lowerkey = Meta_p(keystroke)
                                       ? Meta (tolower (UnMeta (keystroke)))
                                       : tolower (keystroke);

              if (map[lowerkey].function == (InfoCommand *)NULL)
                {
                  message_in_echo_area ((char *) _("%s is undefined."),
                                        pretty_keyseq (keys), NULL);
                  return;
                }
            }
#endif

          keyname = pretty_keyseq (keys);

#if defined (NAMED_FUNCTIONS)
          funname = function_name (map[keystroke].function);
#endif /* NAMED_FUNCTIONS */

          fundoc = function_documentation (map[keystroke].function);

          message = (char *)xmalloc
            (10 + strlen (keyname) + strlen (fundoc) + strlen (funname));

#if defined (NAMED_FUNCTIONS)
          sprintf (message, "%s (%s): %s.", keyname, funname, fundoc);
#else
          sprintf (message, _("%s is defined to %s."), keyname, fundoc);
#endif /* !NAMED_FUNCTIONS */

          window_message_in_echo_area ("%s", message, NULL);
          free (message);
          break;
        }
    }
}

/* Return the pretty printable name of a single character. */
char *
pretty_keyname (unsigned char key)
{
  static char rep_buffer[30];
  char *rep;

  if (Meta_p (key))
    {
      char temp[20];

      rep = pretty_keyname (UnMeta (key));

#if defined (INFOKEY)
      sprintf (temp, "M-%s", rep);
#else /* !INFOKEY */
      sprintf (temp, "ESC %s", rep);
#endif /* !INFOKEY */
      strcpy (rep_buffer, temp);
      rep = rep_buffer;
    }
  else if (Control_p (key))
    {
      switch (key)
        {
        case '\n': rep = "LFD"; break;
        case '\t': rep = "TAB"; break;
        case '\r': rep = "RET"; break;
        case ESC:  rep = "ESC"; break;

        default:
          sprintf (rep_buffer, "C-%c", UnControl (key));
          rep = rep_buffer;
        }
    }
  else
    {
      switch (key)
        {
        case ' ': rep = "SPC"; break;
        case DEL: rep = "DEL"; break;
        default:
          rep_buffer[0] = key;
          rep_buffer[1] = '\0';
          rep = rep_buffer;
        }
    }
  return (rep);
}

/* Return the pretty printable string which represents KEYSEQ. */

static void pretty_keyseq_internal (char *keyseq, char *rep);

char *
pretty_keyseq (char *keyseq)
{
  static char keyseq_rep[200];

  keyseq_rep[0] = '\0';
  if (*keyseq)
    pretty_keyseq_internal (keyseq, keyseq_rep);
  return (keyseq_rep);
}

static void
pretty_keyseq_internal (char *keyseq, char *rep)
{
  if (term_kP && strncmp(keyseq, term_kP, strlen(term_kP)) == 0)
    {
      strcpy(rep, "PgUp");
      keyseq += strlen(term_kP);
    }
  else if (term_kN && strncmp(keyseq, term_kN, strlen(term_kN)) == 0)
    {
      strcpy(rep, "PgDn");
      keyseq += strlen(term_kN);
    }
#if defined(INFOKEY)
  else if (term_kh && strncmp(keyseq, term_kh, strlen(term_kh)) == 0)
    {
      strcpy(rep, "Home");
      keyseq += strlen(term_kh);
    }
  else if (term_ke && strncmp(keyseq, term_ke, strlen(term_ke)) == 0)
    {
      strcpy(rep, "End");
      keyseq += strlen(term_ke);
    }
  else if (term_ki && strncmp(keyseq, term_ki, strlen(term_ki)) == 0)
    {
      strcpy(rep, "INS");
      keyseq += strlen(term_ki);
    }
  else if (term_kx && strncmp(keyseq, term_kx, strlen(term_kx)) == 0)
    {
      strcpy(rep, "DEL");
      keyseq += strlen(term_kx);
    }
#endif /* INFOKEY */
  else if (term_ku && strncmp(keyseq, term_ku, strlen(term_ku)) == 0)
    {
      strcpy(rep, "Up");
      keyseq += strlen(term_ku);
    }
  else if (term_kd && strncmp(keyseq, term_kd, strlen(term_kd)) == 0)
    {
      strcpy(rep, "Down");
      keyseq += strlen(term_kd);
    }
  else if (term_kl && strncmp(keyseq, term_kl, strlen(term_kl)) == 0)
    {
      strcpy(rep, "Left");
      keyseq += strlen(term_kl);
    }
  else if (term_kr && strncmp(keyseq, term_kr, strlen(term_kr)) == 0)
    {
      strcpy(rep, "Right");
      keyseq += strlen(term_kr);
    }
  else
    {
      strcpy (rep, pretty_keyname (keyseq[0]));
      keyseq++;
    }
  if (*keyseq)
    {
      strcat (rep, " ");
      pretty_keyseq_internal (keyseq, rep + strlen(rep));
    }
}

/* Return a pointer to the last character in s that is found in f. */
static char *
strrpbrk (const char *s, const char *f)
{
  register const char *e = s + strlen(s);
  register const char *t;

  while (e-- != s)
    {
      for (t = f; *t; t++)
        if (*e == *t)
          return (char *)e;
    }
  return NULL;
}

/* Replace the names of functions with the key that invokes them. */
char *
replace_in_documentation (char *string, int help_is_only_window_p)
{
  unsigned reslen = strlen (string);
  register int i, start, next;
  static char *result = (char *)NULL;

  maybe_free (result);
  result = (char *)xmalloc (1 + reslen);

  i = next = start = 0;

  /* Skip to the beginning of a replaceable function. */
  for (i = start; string[i]; i++)
    {
      int j = i + 1;

      /* Is this the start of a replaceable function name? */
      if (string[i] == '\\')
        {
          char *fmt = NULL;
          unsigned min = 0;
          unsigned max = 0;

          if(string[j] == '%')
            {
              if (string[++j] == '-')
                j++;
              if (isdigit(string[j]))
                {
                  min = atoi(string + j);
                  while (isdigit(string[j]))
                    j++;
                  if (string[j] == '.' && isdigit(string[j + 1]))
                    {
                      j += 1;
                      max = atoi(string + j);
                      while (isdigit(string[j]))
                        j++;
                    }
                  fmt = (char *)xmalloc (j - i + 2);
                  strncpy (fmt, string + i + 1, j - i);
                  fmt[j - i - 1] = 's';
                  fmt[j - i] = '\0';
                }
              else
                j = i + 1;
            }
          if (string[j] == '[')
            {
              unsigned arg = 0;
              char *argstr = NULL;
              char *rep_name, *fun_name, *rep;
              InfoCommand *command;
              char *repstr = NULL;
              unsigned replen;

              /* Copy in the old text. */
              strncpy (result + next, string + start, i - start);
              next += (i - start);
              start = j + 1;

              /* Look for an optional numeric arg. */
              i = start;
              if (isdigit(string[i])
                  || (string[i] == '-' && isdigit(string[i + 1])) )
                {
                  arg = atoi(string + i);
                  if (string[i] == '-')
                    i++;
                  while (isdigit(string[i]))
                    i++;
                }
              start = i;

              /* Move to the end of the function name. */
              for (i = start; string[i] && (string[i] != ']'); i++);

              rep_name = (char *)xmalloc (1 + i - start);
              strncpy (rep_name, string + start, i - start);
              rep_name[i - start] = '\0';

            /* If we have only one window (because the window size was too
               small to split it), we have to quit help by going back one
               noew in the history list, not deleting the window.  */
              if (strcmp (rep_name, "quit-help") == 0)
                fun_name = help_is_only_window_p ? "history-node"
                                                 : "delete-window";
              else
                fun_name = rep_name;

              /* Find a key which invokes this function in the info_keymap. */
              command = named_function (fun_name);

              free (rep_name);

              /* If the internal documentation string fails, there is a
                 serious problem with the associated command's documentation.
                 We croak so that it can be fixed immediately. */
              if (!command)
                abort ();

              if (arg)
                {
                  char *argrep, *p;

                  argrep = where_is (info_keymap, InfoCmd(info_add_digit_to_numeric_arg));
                  p = argrep ? strrpbrk (argrep, "0123456789-") : NULL;
                  if (p)
                    {
                      argstr = (char *)xmalloc (p - argrep + 21);
                      strncpy (argstr, argrep, p - argrep);
                      sprintf (argstr + (p - argrep), "%d", arg);
                    }
                  else
                    command = NULL;
                }
              rep = command ? where_is (info_keymap, command) : NULL;
              if (!rep)
                rep = "N/A";
              replen = (argstr ? strlen (argstr) : 0) + strlen (rep) + 1;
              repstr = (char *)xmalloc (replen);
              repstr[0] = '\0';
              if (argstr)
                {
                  strcat(repstr, argstr);
                  strcat(repstr, " ");
                  free (argstr);
                }
              strcat(repstr, rep);

              if (fmt)
                {
                  if (replen > max)
                    replen = max;
                  if (replen < min)
                    replen = min;
                }
              if (next + replen > reslen)
                {
                  reslen = next + replen + 1;
                  result = (char *)xrealloc (result, reslen + 1);
                }

              if (fmt)
                  sprintf (result + next, fmt, repstr);
              else
                  strcpy (result + next, repstr);

              next = strlen (result);
              free (repstr);

              start = i;
              if (string[i])
                start++;
            }

          maybe_free (fmt);
        }
    }
  strcpy (result + next, string + start);
  return (result);
}

/* Return a string of characters which could be typed from the keymap
   MAP to invoke FUNCTION. */
static char *where_is_rep = (char *)NULL;
static int where_is_rep_index = 0;
static int where_is_rep_size = 0;

char *
where_is (Keymap map, InfoCommand *cmd)
{
  char *rep;

  if (!where_is_rep_size)
    where_is_rep = (char *)xmalloc (where_is_rep_size = 100);
  where_is_rep_index = 0;

  rep = where_is_internal (map, cmd);

  /* If it couldn't be found, return "M-x Foo" (or equivalent). */
  if (!rep)
    {
      char *name;

      name = function_name (cmd);
      if (!name)
        return NULL; /* no such function */

      rep = where_is_internal (map, InfoCmd(info_execute_command));
      if (!rep)
        return ""; /* function exists but can't be got to by user */

      sprintf (where_is_rep, "%s %s", rep, name);

      rep = where_is_rep;
    }
  return (rep);
}

/* Return the printed rep of the keystrokes that invoke FUNCTION,
   as found in MAP, or NULL. */
static char *
where_is_internal (Keymap map, InfoCommand *cmd)
{
#if defined(INFOKEY)

  register FUNCTION_KEYSEQ *k;

  for (k = cmd->keys; k; k = k->next)
    if (k->map == map)
      return pretty_keyseq (k->keyseq);

  return NULL;

#else /* !INFOKEY */
  /* There is a bug in that create_internal_info_help_node calls
     where_is_internal without setting where_is_rep_index to zero.  This
     was found by Mandrake and reported by Thierry Vignaud
     <tvignaud@@mandrakesoft.com> around April 24, 2002.

     I think the best fix is to make where_is_rep_index another
     parameter to this recursively-called function, instead of a static
     variable.  But this [!INFOKEY] branch of the code is not enabled
     any more, so let's just skip the whole thing.  --karl, 28sep02.  */
  register int i;

  /* If the function is directly invokable in MAP, return the representation
     of that keystroke. */
  for (i = 0; i < 256; i++)
    if ((map[i].type == ISFUNC) && map[i].function == cmd)
      {
        sprintf (where_is_rep + where_is_rep_index, "%s", pretty_keyname (i));
        return (where_is_rep);
      }

  /* Okay, search subsequent maps for this function. */
  for (i = 0; i < 256; i++)
    {
      if (map[i].type == ISKMAP)
        {
          int saved_index = where_is_rep_index;
          char *rep;

          sprintf (where_is_rep + where_is_rep_index, "%s ",
                   pretty_keyname (i));

          where_is_rep_index = strlen (where_is_rep);
          rep = where_is_internal ((Keymap)map[i].function, cmd);

          if (rep)
            return (where_is_rep);

          where_is_rep_index = saved_index;
        }
    }

  return NULL;

#endif /* INFOKEY */
}

DECLARE_INFO_COMMAND (info_where_is,
   _("Show what to type to execute a given command"))
{
  char *command_name;

  command_name = read_function_name ((char *) _("Where is command: "), window);

  if (!command_name)
    {
      info_abort_key (active_window, count, key);
      return;
    }

  if (*command_name)
    {
      InfoCommand *command;

      command = named_function (command_name);

      if (command)
        {
          char *location;

          location = where_is (active_window->keymap, command);

          if (!location || !location[0])
            {
              info_error ((char *) _("`%s' is not on any keys"),
                  command_name, NULL);
            }
          else
            {
              if (strstr (location, function_name (command)))
                window_message_in_echo_area
                  ((char *) _("%s can only be invoked via %s."),
                   command_name, location);
              else
                window_message_in_echo_area
                  ((char *) _("%s can be invoked via %s."),
                   command_name, location);
            }
        }
      else
        info_error ((char *) _("There is no function named `%s'"),
            command_name, NULL);
    }

  free (command_name);
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d1 2
a2 2
/* infodoc.c -- Functions which build documentation nodes.
   $Id: infodoc.c,v 1.28 2002/02/27 13:37:33 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 99, 2001, 02 Free Software Foundation, Inc.
d40 1
a40 1
   help node.  The actual key bindings are inserted.  Keep the 
d70 4
a75 4
  N_("\\%-10[beginning-of-node]  Go to the beginning of this node.\n"),
  N_("\\%-10[end-of-node]  Go to the end of this node.\n"),
  N_("\\%-10[scroll-forward]  Scroll forward 1 line.\n"),
  N_("\\%-10[scroll-backward]  Scroll backward 1 line.\n"),
d188 1
a188 1
static char *where_is_internal ();
d191 1
a191 3
dump_map_to_message_buffer (prefix, map)
     char *prefix;
     Keymap map;
d227 5
a231 3
              printf_to_message_buffer ("%s .. ", pretty_keyseq (new_prefix));
	      new_prefix[prefix_len] = last - 1;
              printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix));
d235 2
a236 1
            printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix));
d245 1
a245 1
            printf_to_message_buffer ("(%s)", name);
d248 3
a250 2
            if ((desired_doc_start + strlen (doc)) >= the_screen->width)
              printf_to_message_buffer ("\n     ");
d255 1
a255 1
                    printf_to_message_buffer ("\t");
d261 1
a261 1
          printf_to_message_buffer ("%s\n", doc);
d274 1
a274 2
create_internal_info_help_node (help_is_only_window_p)
     int help_is_only_window_p;
d295 3
a297 2
          printf_to_message_buffer (replace_in_documentation (
           _(info_internal_help_text[i]), help_is_only_window_p));
d305 1
a305 1
          
d311 1
a311 1
          printf_to_message_buffer (msg, key);
d315 7
a321 5
      printf_to_message_buffer ("---------------------\n\n");
      printf_to_message_buffer (_("The current search path is:\n"));
      printf_to_message_buffer ("  %s\n", infopath);
      printf_to_message_buffer ("---------------------\n\n");
      printf_to_message_buffer (_("Commands available in Info windows:\n\n"));
d323 3
a325 2
      printf_to_message_buffer ("---------------------\n\n");
      printf_to_message_buffer (_("Commands available in the echo area:\n\n"));
d337 2
a338 2
          if (InfoFunction(cmd) != info_do_lowercase_version
	      && !where_is_internal (info_keymap, cmd)
d343 10
a352 7
                  printf_to_message_buffer ("---------------------\n\n");
		  if (exec_keys && exec_keys[0])
		      printf_to_message_buffer
			(_("The following commands can only be invoked via %s:\n\n"), exec_keys);
		  else
		      printf_to_message_buffer
			(_("The following commands cannot be invoked at all:\n\n"));
d358 1
a358 1
		 exec_keys,
d361 2
a362 3
					   ? _(function_doc_array[i].doc)
					   : "")
		);
d368 1
a368 1
        printf_to_message_buffer ("\n");
d375 2
a376 1
         (_("--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n")));
d415 1
a415 1
info_find_or_create_help_window ()
d449 2
a450 3
  help_is_only_window_p
     = (help_window && !windows->next
        || !help_window && eligible->height < HELP_SPLIT_SIZE);
d497 1
a497 1
      info_error (msg_cant_make_help);
d539 1
a539 1
        info_error (info_recent_file_error);
d541 1
a541 1
        info_error (msg_cant_file_node, "Info", nodename);
d569 1
a569 2
function_documentation (cmd)
     InfoCommand *cmd;
d589 1
a589 1
  return replace_in_documentation ((strlen (doc) == 0) ? doc : _(doc));
d596 1
a596 2
function_name (cmd)
     InfoCommand *cmd;
d617 1
a617 2
named_function (name)
     char *name;
d631 1
a631 3
key_documentation (key, map)
     char key;
     Keymap map;
d653 2
a654 1
      message_in_echo_area (_("Describe key: %s"), pretty_keyseq (keys));
d668 1
a668 1
	  *k++ = '\e';
d680 2
a681 1
          message_in_echo_area (_("%s is undefined."), pretty_keyseq (keys));
d694 20
a713 19
	  /* If the key is bound to do-lowercase-version, but its
	     lower-case variant is undefined, say that this key is
	     also undefined.  This is especially important for unbound
	     edit keys that emit an escape sequence: it's terribly
	     confusing to see a message "Home (do-lowercase-version)"
	     or some such when Home is unbound.  */
	  if (InfoFunction(map[keystroke].function) == info_do_lowercase_version)
	    {
	      unsigned char lowerkey = Meta_p(keystroke)
				       ? Meta (tolower (UnMeta (keystroke)))
				       : tolower (keystroke);

	      if (map[lowerkey].function == (InfoCommand *)NULL)
		{
		  message_in_echo_area (_("%s is undefined."),
					pretty_keyseq (keys));
		  return;
		}
	    }
d716 1
a716 1
	  keyname = pretty_keyseq (keys);
d733 1
a733 1
          window_message_in_echo_area ("%s", message);
d742 1
a742 2
pretty_keyname (key)
     unsigned char key;
d792 1
a792 1
static void pretty_keyseq_internal ();
d795 1
a795 2
pretty_keyseq (keyseq)
     char *keyseq;
d806 1
a806 2
pretty_keyseq_internal (keyseq, rep)
     char *keyseq, *rep;
d874 1
a874 2
strrpbrk (s, f)
     const char *s, *f;
d883 1
a883 1
	  return (char *)e;
d890 1
a890 3
replace_in_documentation (string, help_is_only_window_p)
     char *string;
     int help_is_only_window_p;
d908 71
a978 137
      	{
	  char *fmt = NULL;
	  unsigned min = 0;
	  unsigned max = 0;

	  if(string[j] == '%')
	    {
	      if (string[++j] == '-')
		j++;
	      if (isdigit(string[j]))
		{
		  min = atoi(string + j);
		  while (isdigit(string[j]))
		    j++;
		  if (string[j] == '.' && isdigit(string[j + 1]))
		    {
		      j += 1;
		      max = atoi(string + j);
		      while (isdigit(string[j]))
			j++;
		    }
		  fmt = (char *)xmalloc (j - i + 2);
		  strncpy (fmt, string + i + 1, j - i);
		  fmt[j - i - 1] = 's';
		  fmt[j - i] = '\0';
		}
	      else
		j = i + 1;
	    }
	  if (string[j] == '[')
	    {
	      unsigned arg = 0;
	      char *argstr = NULL;
	      char *rep_name, *fun_name, *rep;
	      InfoCommand *command;
	      char *repstr = NULL;
	      unsigned replen;

	      /* Copy in the old text. */
	      strncpy (result + next, string + start, i - start);
	      next += (i - start);
	      start = j + 1;

	      /* Look for an optional numeric arg. */
	      i = start;
	      if (isdigit(string[i])
		  || (string[i] == '-' && isdigit(string[i + 1])) )
		{
		  arg = atoi(string + i);
		  if (string[i] == '-')
		    i++;
		  while (isdigit(string[i]))
		    i++;
		}
	      start = i;

	      /* Move to the end of the function name. */
	      for (i = start; string[i] && (string[i] != ']'); i++);

	      rep_name = (char *)xmalloc (1 + i - start);
	      strncpy (rep_name, string + start, i - start);
	      rep_name[i - start] = '\0';

	    /* If we have only one window (because the window size was too
	       small to split it), we have to quit help by going back one
	       noew in the history list, not deleting the window.  */
	      if (strcmp (rep_name, "quit-help") == 0)
		fun_name = help_is_only_window_p ? "history-node"
						 : "delete-window";
	      else
	        fun_name = rep_name;

	      /* Find a key which invokes this function in the info_keymap. */
	      command = named_function (fun_name);

	      free (rep_name);

	      /* If the internal documentation string fails, there is a
		 serious problem with the associated command's documentation.
		 We croak so that it can be fixed immediately. */
	      if (!command)
		abort ();

	      if (arg)
	      	{
		  char *argrep, *p;

		  argrep = where_is (info_keymap, InfoCmd(info_add_digit_to_numeric_arg));
		  p = argrep ? strrpbrk (argrep, "0123456789-") : NULL;
		  if (p)
		    {
		      argstr = (char *)xmalloc (p - argrep + 21);
		      strncpy (argstr, argrep, p - argrep);
		      sprintf (argstr + (p - argrep), "%d", arg);
		    }
		  else
		    command = NULL;
		}
	      rep = command ? where_is (info_keymap, command) : NULL;
	      if (!rep)
	        rep = "N/A";
	      replen = (argstr ? strlen (argstr) + 1 : 0) + strlen (rep);
	      repstr = (char *)xmalloc (replen);
	      repstr[0] = '\0';
	      if (argstr)
		{
		  strcat(repstr, argstr);
		  strcat(repstr, " ");
		  free (argstr);
		}
	      strcat(repstr, rep);

	      if (fmt)
		{
		  if (replen > max)
		    replen = max;
		  if (replen < min)
		    replen = min;
		}
	      if (next + replen > reslen)
		{
		  reslen = next + replen + 1;
		  result = (char *)xrealloc (result, reslen + 1);
		}

	      if (fmt)
		  sprintf (result + next, fmt, repstr);
	      else
		  strcpy (result + next, repstr);

	      next = strlen (result);
	      free (repstr);

	      start = i;
	      if (string[i])
		start++;
	    }
d980 68
a1047 2
	  maybe_free (fmt);
	}
d1060 1
a1060 3
where_is (map, cmd)
     Keymap map;
     InfoCommand *cmd;
d1077 1
a1077 1
      	return NULL; /* no such function */
d1093 1
a1093 3
where_is_internal (map, cmd)
     Keymap map;
     InfoCommand *cmd;
d1106 9
a1114 1

a1151 2
extern char *read_function_name ();

d1157 1
a1157 1
  command_name = read_function_name (_("Where is command: "), window);
d1179 2
a1180 1
              info_error (_("`%s' is not on any keys"), command_name);
d1186 2
a1187 1
                  (_("%s can only be invoked via %s."), command_name, location);
d1190 2
a1191 1
                  (_("%s can be invoked via %s."), command_name, location);
d1195 2
a1196 1
        info_error (_("There is no function named `%s'"), command_name);
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: infodoc.c,v 1.23 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d23 1
a28 6
/* **************************************************************** */
/*                                                                  */
/*                        Info Help Windows                         */
/*                                                                  */
/* **************************************************************** */

d38 55
a92 1
/* The static text which appears in the internal info help node. */
d94 2
a95 2
  N_("Basic Commands in Info Windows\n"),
  N_("******************************\n"),
d101 2
a102 11
  N_("Moving within a node:\n"),
  N_("---------------------\n"),
  N_("  %-10s  Scroll forward a page.\n"),
  N_("  %-10s  Scroll backward a page.\n"),
  N_("  %-10s  Go to the beginning of this node.\n"),
  N_("  %-10s  Go to the end of this node.\n"),
  N_("  %-10s  Scroll forward 1 line.\n"),
  N_("  %-10s  Scroll backward 1 line.\n"),
  "\n",
  N_("Selecting other nodes:\n"),
  N_("----------------------\n"),
d115 11
a125 2
  N_("Other commands:\n"),
  N_("---------------\n"),
d132 1
a132 1
  N_("  %-10s  Search forward through this Info file for a specified string,\n"),
d134 1
a134 1
  N_("  %-10s  Search backward in this Info file for a specified string,\n"),
d185 3
a187 1
static char *where_is (), *where_is_internal ();
d195 5
d203 1
a205 7
          char *new_prefix, *keyname;

          keyname = pretty_keyname (i);
          new_prefix = (char *)
            xmalloc (3 + strlen (prefix) + strlen (keyname));
          sprintf (new_prefix, "%s%s%s ", prefix, *prefix ? " " : "", keyname);

a206 1
          free (new_prefix);
d228 3
a230 4
              printf_to_message_buffer
                ("%s%s .. ", prefix, pretty_keyname (i));
              printf_to_message_buffer
                ("%s%s\t", prefix, pretty_keyname (last - 1));
d234 1
a234 1
            printf_to_message_buffer ("%s%s\t", prefix, pretty_keyname (i));
d261 1
d277 1
d292 4
d309 1
d323 4
a326 1
      /* Get a list of the M-x commands which have no keystroke equivs. */
d329 1
a329 1
          VFunction *func = function_doc_array[i].func;
d331 3
a333 2
          if ((!where_is_internal (info_keymap, func)) &&
              (!where_is_internal (echo_area_keymap, func)))
d338 6
a343 2
                  printf_to_message_buffer
                    (_("The following commands can only be invoked via M-x:\n\n"));
d348 2
a349 1
                ("M-x %s\n     %s\n",
d352 3
a354 3
                                           == 0
					   ? function_doc_array[i].doc
					   : _(function_doc_array[i].doc)));
d361 2
d561 2
a562 2
function_documentation (function)
     VFunction *function;
d564 8
d575 1
a575 1
    if (function == function_doc_array[i].func)
d578 5
a582 3
  return replace_in_documentation ((strlen (function_doc_array[i].doc) == 0)
                                   ? function_doc_array[i].doc
                                   : _(function_doc_array[i].doc));
d589 8
a596 1
function_name (function)
a597 2
     VFunction *function;
{
d601 1
a601 1
    if (function == function_doc_array[i].func)
d605 2
d609 2
a610 2
/* Return a pointer to the function named NAME. */
VFunction *
d620 1
a620 1
  return (function_doc_array[i].func);
d630 1
a630 1
  VFunction *function = map[key].function;
d640 1
a640 2
  char keyname[50];
  int keyname_index = 0;
d642 1
a642 1
  char *rep;
d645 1
a645 1
  keyname[0] = 0;
d650 1
a650 1
      message_in_echo_area (_("Describe key: %s"), keyname);
d654 1
d664 1
a664 2
          strcpy (keyname + keyname_index, "ESC ");
          keyname_index = strlen (keyname);
d668 1
d670 3
a672 4
      /* Add the printed representation of KEYSTROKE to our keyname. */
      rep = pretty_keyname (keystroke);
      strcpy (keyname + keyname_index, rep);
      keyname_index = strlen (keyname);
d674 1
a674 1
      if (map[keystroke].function == (VFunction *)NULL)
d676 1
a676 1
          message_in_echo_area (_("%s is undefined."), keyname);
a681 2
          strcat (keyname, " ");
          keyname_index = strlen (keyname);
d686 25
a710 1
          char *message, *fundoc, *funname = "";
d734 1
a734 3
/* How to get the pretty printable name of a character. */
static char rep_buffer[30];

d739 1
d748 3
d752 1
d785 101
d888 1
a888 1
replace_in_documentation (string)
d890 1
d892 1
d897 1
a897 1
  result = (char *)xmalloc (1 + strlen (string));
d904 2
d907 138
a1044 4
      if (string[i] == '\\' && string[i + 1] == '[')
        {
          char *fun_name, *rep;
          VFunction *function;
d1046 2
a1047 29
          /* Copy in the old text. */
          strncpy (result + next, string + start, i - start);
          next += (i - start);
          start = i + 2;

          /* Move to the end of the function name. */
          for (i = start; string[i] && (string[i] != ']'); i++);

          fun_name = (char *)xmalloc (1 + i - start);
          strncpy (fun_name, string + start, i - start);
          fun_name[i - start] = '\0';

          /* Find a key which invokes this function in the info_keymap. */
          function = named_function (fun_name);

          /* If the internal documentation string fails, there is a
             serious problem with the associated command's documentation.
             We croak so that it can be fixed immediately. */
          if (!function)
            abort ();

          rep = where_is (info_keymap, function);
          strcpy (result + next, rep);
          next = strlen (result);

          start = i;
          if (string[i])
            start++;
        }
d1059 2
a1060 2
static char *
where_is (map, function)
d1062 1
a1062 1
     VFunction *function;
d1070 1
a1070 1
  rep = where_is_internal (map, function);
d1072 1
a1072 1
  /* If it couldn't be found, return "M-x Foo". */
d1077 7
a1083 1
      name = function_name (function);
d1085 1
a1085 2
      if (name)
        sprintf (where_is_rep, "M-x %s", name);
d1092 2
a1093 1
/* Return the printed rep of FUNCTION as found in MAP, or NULL. */
d1095 1
a1095 1
where_is_internal (map, function)
d1097 1
a1097 1
     VFunction *function;
d1099 12
d1116 1
a1116 1
    if ((map[i].type == ISFUNC) && map[i].function == function)
d1134 1
a1134 1
          rep = where_is_internal ((Keymap)map[i].function, function);
d1144 2
d1165 1
a1165 1
      VFunction *function;
d1167 1
a1167 1
      function = named_function (command_name);
d1169 1
a1169 1
      if (function)
d1173 1
a1173 1
          location = where_is (active_window->keymap, function);
d1175 1
a1175 1
          if (!location)
d1181 1
a1181 1
              if (strncmp (location, "M-x ", 4) == 0)
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: infodoc.c,v 1.4 1997/07/25 21:08:40 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d24 3
a26 8
/* Normally we do not define HELP_NODE_GETS_REGENERATED because the
   contents of the help node currently can never change once an info
   session has been started.   You should consider defining this in
   the case that you place information about dynamic variables in the
   help text.  When that happens, the contents of the help node will
   change dependent on the value of those variables, and the user will
   expect to see those changes. */
/* #define HELP_NODE_GETS_REGENERATED 1 */
d45 88
a132 34
  N_ ("Basic Commands in Info Windows"),
  "******************************",
  "",
  "  h          Invoke the Info tutorial.",
  "  CTRL-x 0   Quit this help.",
  "  q          Quit Info altogether.",
  "",
  "Selecting other nodes:",
  "----------------------",
  "  n   Move to the \"next\" node of this node.",
  "  p   Move to the \"previous\" node of this node.",
  "  u   Move \"up\" from this node.",
  "  m   Pick menu item specified by name.",
  "      Picking a menu item causes another node to be selected.",
  "  f   Follow a cross reference.  Reads name of reference.",
  "  l   Move to the last node seen in this window.",
  "  d   Move to the `directory' node.  Equivalent to `g(DIR)'.",
  "",
  "Moving within a node:",
  "---------------------",
  "  SPC Scroll forward a page.",
  "  DEL Scroll backward a page.",
  "  b   Go to the beginning of this node.",
  "  e   Go to the end of this node.",
  "",
  "Other commands:",
  "--------------------",
  "  1   Pick first item in node's menu.",
  "  2-9 Pick second ... ninth item in node's menu.",
  "  0   Pick last item in node's menu.",
  "  g   Move to node specified by name.",
  "      You may include a filename as well, as in (FILENAME)NODENAME.",
  "  s   Search through this Info file for a specified string,",
  "      and select the node in which the next occurrence is found.",
d215 6
a220 1
/* How to create internal_info_help_node. */
d222 2
a223 1
create_internal_info_help_node ()
a225 1
  char *contents = (char *)NULL;
d227 1
d229 1
a229 1
#if !defined (HELP_NODE_GETS_REGENERATED)
d241 15
a255 1
        printf_to_message_buffer ("%s\n", info_internal_help_text[i]);
d258 2
a259 2
      printf_to_message_buffer ("The current search path is:\n");
      printf_to_message_buffer ("  \"%s\"\n", infopath);
d261 1
a261 1
      printf_to_message_buffer ("Commands available in Info windows:\n\n");
d264 1
a264 1
      printf_to_message_buffer ("Commands available in the echo area:\n\n");
d287 5
a291 1
                 replace_in_documentation (function_doc_array[i].doc));
d334 5
d342 3
a344 4
  WINDOW *help_window, *eligible, *window;

  eligible = (WINDOW *)NULL;
  help_window = get_internal_info_window (info_help_nodename);
d349 1
d362 1
a362 1
        return ((WINDOW *)NULL);
d364 1
a364 1
#if !defined (HELP_NODE_GETS_REGENERATED)
d366 12
a377 5
    return (help_window);
#endif /* !HELP_NODE_GETS_REGENERATED */

  /* Make sure that we have a node containing the help text. */
  create_internal_info_help_node ();
d382 1
a382 2
    {
      /* Split the largest window into 2 windows, and show the help text
d384 1
a384 1
      if (eligible->height > 30)
d397 1
a397 2
    {
      /* Case where help node always gets regenerated, and we have an
d407 1
a407 1
  return (help_window);
d423 1
a423 1
      info_error (CANT_MAKE_HELP);
d467 1
a467 1
        info_error (CANT_FILE_NODE, "Info", nodename);
d504 3
a506 1
  return (replace_in_documentation (function_doc_array[i].doc));
d563 1
a563 1
  keyname[0] = '\0';
d566 1
a566 1
  while (1)
d572 1
a572 1
      if (Meta_p (keystroke) && (!ISO_Latin_p || key < 160))
d577 1
a577 1
                (_("ESC %s is undefined."), pretty_keyname (UnMeta (keystroke)));
d715 1
a715 1
          /* If the internal documentation string fails, there is a 
d775 1
a775 1
  
d806 1
a806 1
  return ((char *)NULL);
d812 1
a812 1
   "Show what to type to execute a given command")
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* infodoc.c -- Functions which build documentation nodes. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d34 3
a36 3
/*								    */
/*			  Info Help Windows			    */
/*								    */
d50 1
a50 1
  "Basic Commands in Info Windows",
d53 3
a55 1
  "  h   Invoke the Info tutorial.",
d75 1
a75 1
  "\"Advanced\" commands:",
a76 1
  "  q   Quit Info.",
d84 1
a84 1
  (char *)NULL
d99 2
a100 2
	{
	  char *new_prefix, *keyname;
d102 8
a109 8
	  keyname = pretty_keyname (i);
	  new_prefix = (char *)
	    xmalloc (3 + strlen (prefix) + strlen (keyname));
	  sprintf (new_prefix, "%s%s%s ", prefix, *prefix ? " " : "", keyname);

	  dump_map_to_message_buffer (new_prefix, (Keymap)map[i].function);
	  free (new_prefix);
	}
d111 27
a137 27
	{
	  register int last;
	  char *doc, *name;

	  doc = function_documentation (map[i].function);
	  name = function_name (map[i].function);

	  if (!*doc)
	    continue;

	  /* Find out if there is a series of identical functions, as in
	     ea_insert (). */
	  for (last = i + 1; last < 256; last++)
	    if ((map[last].type != ISFUNC) ||
		(map[last].function != map[i].function))
	      break;

	  if (last - 1 != i)
	    {
	      printf_to_message_buffer
		("%s%s .. ", prefix, pretty_keyname (i));
	      printf_to_message_buffer
		("%s%s\t", prefix, pretty_keyname (last - 1));
	      i = last - 1;
	    }
	  else
	    printf_to_message_buffer ("%s%s\t", prefix, pretty_keyname (i));
d140 20
a159 20
	  /* Print the name of the function, and some padding before the
	     documentation string is printed. */
	  {
	    int length_so_far;
	    int desired_doc_start = 40;	/* Must be multiple of 8. */

	    printf_to_message_buffer ("(%s)", name);
	    length_so_far = message_buffer_length_this_line ();

	    if ((desired_doc_start + strlen (doc)) >= the_screen->width)
	      printf_to_message_buffer ("\n     ");
	    else
	      {
		while (length_so_far < desired_doc_start)
		  {
		    printf_to_message_buffer ("\t");
		    length_so_far += character_width ('\t', length_so_far);
		  }
	      }
	  }
d161 2
a162 2
	  printf_to_message_buffer ("%s\n", doc);
	}
d186 1
a186 1
	printf_to_message_buffer ("%s\n", info_internal_help_text[i]);
d201 2
a202 2
	{
	  VFunction *func = function_doc_array[i].func;
d204 17
a220 17
	  if ((!where_is_internal (info_keymap, func)) &&
	      (!where_is_internal (echo_area_keymap, func)))
	    {
	      if (!printed_one_mx)
		{
		  printf_to_message_buffer ("---------------------\n\n");
		  printf_to_message_buffer
		    ("The following commands can only be invoked via M-x:\n\n");
		  printed_one_mx = 1;
		}

	      printf_to_message_buffer
		("M-x %s\n     %s\n",
		 function_doc_array[i].func_name,
		 replace_in_documentation (function_doc_array[i].doc));
	    }
	}
d223 1
a223 1
	printf_to_message_buffer ("\n");
d227 2
a228 2
	("%s", replace_in_documentation
	 ("--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n"));
d275 7
a281 7
	{
	  if (window->height > max)
	    {
	      max = window->height;
	      eligible = window;
	    }
	}
d284 1
a284 1
	return ((WINDOW *)NULL);
d299 1
a299 1
	 in that window. */
d301 4
a304 4
	{
	  active_window = eligible;
	  help_window = window_make_window (internal_info_help_node);
	}
d306 5
a310 5
	{
	  set_remembered_pagetop_and_point (active_window);
	  window_set_node_of_window (active_window, internal_info_help_node);
	  help_window = active_window;
	}
d315 1
a315 1
	 existing window in which to place the node. */
d317 4
a320 4
	{
	  set_remembered_pagetop_and_point (active_window);
	  active_window = help_window;
	}
d328 1
a328 1
DECLARE_INFO_COMMAND (info_get_help_window, "Display help message")
d346 1
a346 1
DECLARE_INFO_COMMAND (info_get_info_help_node, "Visit Info node `(info)Help'")
d358 9
a366 9
	if (win->node && win->node->filename &&
	    (strcasecmp
	     (filename_non_directory (win->node->filename), "info") == 0) &&
	    ((strcmp (win->node->nodename, "Help") == 0) ||
	     (strcmp (win->node->nodename, "Help-Small-Screen") == 0)))
	  {
	    active_window = win;
	    return;
	  }
d382 1
a382 1
	info_error (info_recent_file_error);
d384 1
a384 1
	info_error (CANT_FILE_NODE, "Info", nodename);
d389 2
a390 2
	 then split it and show the help node in another window.
	 Otherwise, use the current window. */
d393 1
a393 1
	active_window = window_make_window (node);
d395 4
a398 4
	{
	  set_remembered_pagetop_and_point (active_window);
	  window_set_node_of_window (active_window, node);
	}
d405 3
a407 3
/*								    */
/*		     Groveling Info Keymaps and Docs		    */
/*								    */
d470 1
a470 1
DECLARE_INFO_COMMAND (describe_key, "Print documentation for KEY")
d483 1
a483 1
      message_in_echo_area ("Describe key: %s", keyname);
d488 13
a500 13
	{
	  if (map[ESC].type != ISKMAP)
	    {
	      window_message_in_echo_area
		("ESC %s is undefined.", pretty_keyname (UnMeta (keystroke)));
	      return;
	    }

	  strcpy (keyname + keyname_index, "ESC ");
	  keyname_index = strlen (keyname);
	  keystroke = UnMeta (keystroke);
	  map = (Keymap)map[ESC].function;
	}
d508 4
a511 4
	{
	  message_in_echo_area ("%s is undefined.", keyname);
	  return;
	}
d513 6
a518 6
	{
	  map = (Keymap)map[keystroke].function;
	  strcat (keyname, " ");
	  keyname_index = strlen (keyname);
	  continue;
	}
d520 2
a521 2
	{
	  char *message, *fundoc, *funname = "";
d524 1
a524 1
	  funname = function_name (map[keystroke].function);
d527 1
a527 1
	  fundoc = function_documentation (map[keystroke].function);
d529 2
a530 2
	  message = (char *)xmalloc
	    (10 + strlen (keyname) + strlen (fundoc) + strlen (funname));
d533 1
a533 1
	  sprintf (message, "%s (%s): %s.", keyname, funname, fundoc);
d535 1
a535 1
	  sprintf (message, "%s is defined to %s.", keyname, fundoc);
d538 4
a541 4
	  window_message_in_echo_area ("%s", message);
	  free (message);
	  break;
	}
d567 10
a576 10
	{
	case '\n': rep = "LFD"; break;
	case '\t': rep = "TAB"; break;
	case '\r': rep = "RET"; break;
	case ESC:  rep = "ESC"; break;

	default:
	  sprintf (rep_buffer, "C-%c", UnControl (key));
	  rep = rep_buffer;
	}
d581 8
a588 8
	{
	case ' ': rep = "SPC"; break;
	case DEL: rep = "DEL"; break;
	default:
	  rep_buffer[0] = key;
	  rep_buffer[1] = '\0';
	  rep = rep_buffer;
	}
d611 33
a643 33
	{
	  char *fun_name, *rep;
	  VFunction *function;

	  /* Copy in the old text. */
	  strncpy (result + next, string + start, i - start);
	  next += (i - start);
	  start = i + 2;

	  /* Move to the end of the function name. */
	  for (i = start; string[i] && (string[i] != ']'); i++);

	  fun_name = (char *)xmalloc (1 + i - start);
	  strncpy (fun_name, string + start, i - start);
	  fun_name[i - start] = '\0';

	  /* Find a key which invokes this function in the info_keymap. */
	  function = named_function (fun_name);

	  /* If the internal documentation string fails, there is a 
	     serious problem with the associated command's documentation.
	     We croak so that it can be fixed immediately. */
	  if (!function)
	    abort ();

	  rep = where_is (info_keymap, function);
	  strcpy (result + next, rep);
	  next = strlen (result);

	  start = i;
	  if (string[i])
	    start++;
	}
d676 1
a676 1
	sprintf (where_is_rep, "M-x %s", name);
d696 2
a697 2
	sprintf (where_is_rep + where_is_rep_index, "%s", pretty_keyname (i));
	return (where_is_rep);
d704 3
a706 3
	{
	  int saved_index = where_is_rep_index;
	  char *rep;
d708 2
a709 2
	  sprintf (where_is_rep + where_is_rep_index, "%s ",
		   pretty_keyname (i));
d711 2
a712 2
	  where_is_rep_index = strlen (where_is_rep);
	  rep = where_is_internal ((Keymap)map[i].function, function);
d714 2
a715 2
	  if (rep)
	    return (where_is_rep);
d717 2
a718 2
	  where_is_rep_index = saved_index;
	}
d731 1
a731 1
  command_name = read_function_name ("Where is command: ", window);
d746 2
a747 2
	{
	  char *location;
d749 1
a749 1
	  location = where_is (active_window->keymap, function);
d751 14
a764 14
	  if (!location)
	    {
	      info_error ("`%s' is not on any keys", command_name);
	    }
	  else
	    {
	      if (strncmp (location, "M-x ", 4) == 0)
		window_message_in_echo_area
		  ("%s can only be invoked via %s.", command_name, location);
	      else
		window_message_in_echo_area
		  ("%s can be invoked via %s.", command_name, location);
	    }
	}
d766 1
a766 1
	info_error ("There is no function named `%s'", command_name);
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* infodoc.c -- Functions which build documentation nodes.
   $Id: infodoc.c,v 1.4 1997/07/25 21:08:40 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d36 3
a38 3
/*                                                                  */
/*                        Info Help Windows                         */
/*                                                                  */
d52 1
a52 1
  N_ ("Basic Commands in Info Windows"),
d55 1
a55 3
  "  h          Invoke the Info tutorial.",
  "  CTRL-x 0   Quit this help.",
  "  q          Quit Info altogether.",
d75 1
a75 1
  "Other commands:",
d77 1
d85 1
a85 1
  NULL
d100 2
a101 2
        {
          char *new_prefix, *keyname;
d103 8
a110 8
          keyname = pretty_keyname (i);
          new_prefix = (char *)
            xmalloc (3 + strlen (prefix) + strlen (keyname));
          sprintf (new_prefix, "%s%s%s ", prefix, *prefix ? " " : "", keyname);

          dump_map_to_message_buffer (new_prefix, (Keymap)map[i].function);
          free (new_prefix);
        }
d112 27
a138 27
        {
          register int last;
          char *doc, *name;

          doc = function_documentation (map[i].function);
          name = function_name (map[i].function);

          if (!*doc)
            continue;

          /* Find out if there is a series of identical functions, as in
             ea_insert (). */
          for (last = i + 1; last < 256; last++)
            if ((map[last].type != ISFUNC) ||
                (map[last].function != map[i].function))
              break;

          if (last - 1 != i)
            {
              printf_to_message_buffer
                ("%s%s .. ", prefix, pretty_keyname (i));
              printf_to_message_buffer
                ("%s%s\t", prefix, pretty_keyname (last - 1));
              i = last - 1;
            }
          else
            printf_to_message_buffer ("%s%s\t", prefix, pretty_keyname (i));
d141 20
a160 20
          /* Print the name of the function, and some padding before the
             documentation string is printed. */
          {
            int length_so_far;
            int desired_doc_start = 40; /* Must be multiple of 8. */

            printf_to_message_buffer ("(%s)", name);
            length_so_far = message_buffer_length_this_line ();

            if ((desired_doc_start + strlen (doc)) >= the_screen->width)
              printf_to_message_buffer ("\n     ");
            else
              {
                while (length_so_far < desired_doc_start)
                  {
                    printf_to_message_buffer ("\t");
                    length_so_far += character_width ('\t', length_so_far);
                  }
              }
          }
d162 2
a163 2
          printf_to_message_buffer ("%s\n", doc);
        }
d187 1
a187 1
        printf_to_message_buffer ("%s\n", info_internal_help_text[i]);
d202 2
a203 2
        {
          VFunction *func = function_doc_array[i].func;
d205 17
a221 17
          if ((!where_is_internal (info_keymap, func)) &&
              (!where_is_internal (echo_area_keymap, func)))
            {
              if (!printed_one_mx)
                {
                  printf_to_message_buffer ("---------------------\n\n");
                  printf_to_message_buffer
                    (_("The following commands can only be invoked via M-x:\n\n"));
                  printed_one_mx = 1;
                }

              printf_to_message_buffer
                ("M-x %s\n     %s\n",
                 function_doc_array[i].func_name,
                 replace_in_documentation (function_doc_array[i].doc));
            }
        }
d224 1
a224 1
        printf_to_message_buffer ("\n");
d228 2
a229 2
        ("%s", replace_in_documentation
         (_("--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n")));
d276 7
a282 7
        {
          if (window->height > max)
            {
              max = window->height;
              eligible = window;
            }
        }
d285 1
a285 1
        return ((WINDOW *)NULL);
d300 1
a300 1
         in that window. */
d302 4
a305 4
        {
          active_window = eligible;
          help_window = window_make_window (internal_info_help_node);
        }
d307 5
a311 5
        {
          set_remembered_pagetop_and_point (active_window);
          window_set_node_of_window (active_window, internal_info_help_node);
          help_window = active_window;
        }
d316 1
a316 1
         existing window in which to place the node. */
d318 4
a321 4
        {
          set_remembered_pagetop_and_point (active_window);
          active_window = help_window;
        }
d329 1
a329 1
DECLARE_INFO_COMMAND (info_get_help_window, _("Display help message"))
d347 1
a347 1
DECLARE_INFO_COMMAND (info_get_info_help_node, _("Visit Info node `(info)Help'"))
d359 9
a367 9
        if (win->node && win->node->filename &&
            (strcasecmp
             (filename_non_directory (win->node->filename), "info") == 0) &&
            ((strcmp (win->node->nodename, "Help") == 0) ||
             (strcmp (win->node->nodename, "Help-Small-Screen") == 0)))
          {
            active_window = win;
            return;
          }
d383 1
a383 1
        info_error (info_recent_file_error);
d385 1
a385 1
        info_error (CANT_FILE_NODE, "Info", nodename);
d390 2
a391 2
         then split it and show the help node in another window.
         Otherwise, use the current window. */
d394 1
a394 1
        active_window = window_make_window (node);
d396 4
a399 4
        {
          set_remembered_pagetop_and_point (active_window);
          window_set_node_of_window (active_window, node);
        }
d406 3
a408 3
/*                                                                  */
/*                   Groveling Info Keymaps and Docs                */
/*                                                                  */
d471 1
a471 1
DECLARE_INFO_COMMAND (describe_key, _("Print documentation for KEY"))
d484 1
a484 1
      message_in_echo_area (_("Describe key: %s"), keyname);
d489 13
a501 13
        {
          if (map[ESC].type != ISKMAP)
            {
              window_message_in_echo_area
                (_("ESC %s is undefined."), pretty_keyname (UnMeta (keystroke)));
              return;
            }

          strcpy (keyname + keyname_index, "ESC ");
          keyname_index = strlen (keyname);
          keystroke = UnMeta (keystroke);
          map = (Keymap)map[ESC].function;
        }
d509 4
a512 4
        {
          message_in_echo_area (_("%s is undefined."), keyname);
          return;
        }
d514 6
a519 6
        {
          map = (Keymap)map[keystroke].function;
          strcat (keyname, " ");
          keyname_index = strlen (keyname);
          continue;
        }
d521 2
a522 2
        {
          char *message, *fundoc, *funname = "";
d525 1
a525 1
          funname = function_name (map[keystroke].function);
d528 1
a528 1
          fundoc = function_documentation (map[keystroke].function);
d530 2
a531 2
          message = (char *)xmalloc
            (10 + strlen (keyname) + strlen (fundoc) + strlen (funname));
d534 1
a534 1
          sprintf (message, "%s (%s): %s.", keyname, funname, fundoc);
d536 1
a536 1
          sprintf (message, _("%s is defined to %s."), keyname, fundoc);
d539 4
a542 4
          window_message_in_echo_area ("%s", message);
          free (message);
          break;
        }
d568 10
a577 10
        {
        case '\n': rep = "LFD"; break;
        case '\t': rep = "TAB"; break;
        case '\r': rep = "RET"; break;
        case ESC:  rep = "ESC"; break;

        default:
          sprintf (rep_buffer, "C-%c", UnControl (key));
          rep = rep_buffer;
        }
d582 8
a589 8
        {
        case ' ': rep = "SPC"; break;
        case DEL: rep = "DEL"; break;
        default:
          rep_buffer[0] = key;
          rep_buffer[1] = '\0';
          rep = rep_buffer;
        }
d612 33
a644 33
        {
          char *fun_name, *rep;
          VFunction *function;

          /* Copy in the old text. */
          strncpy (result + next, string + start, i - start);
          next += (i - start);
          start = i + 2;

          /* Move to the end of the function name. */
          for (i = start; string[i] && (string[i] != ']'); i++);

          fun_name = (char *)xmalloc (1 + i - start);
          strncpy (fun_name, string + start, i - start);
          fun_name[i - start] = '\0';

          /* Find a key which invokes this function in the info_keymap. */
          function = named_function (fun_name);

          /* If the internal documentation string fails, there is a 
             serious problem with the associated command's documentation.
             We croak so that it can be fixed immediately. */
          if (!function)
            abort ();

          rep = where_is (info_keymap, function);
          strcpy (result + next, rep);
          next = strlen (result);

          start = i;
          if (string[i])
            start++;
        }
d677 1
a677 1
        sprintf (where_is_rep, "M-x %s", name);
d697 2
a698 2
        sprintf (where_is_rep + where_is_rep_index, "%s", pretty_keyname (i));
        return (where_is_rep);
d705 3
a707 3
        {
          int saved_index = where_is_rep_index;
          char *rep;
d709 2
a710 2
          sprintf (where_is_rep + where_is_rep_index, "%s ",
                   pretty_keyname (i));
d712 2
a713 2
          where_is_rep_index = strlen (where_is_rep);
          rep = where_is_internal ((Keymap)map[i].function, function);
d715 2
a716 2
          if (rep)
            return (where_is_rep);
d718 2
a719 2
          where_is_rep_index = saved_index;
        }
d732 1
a732 1
  command_name = read_function_name (_("Where is command: "), window);
d747 2
a748 2
        {
          char *location;
d750 1
a750 1
          location = where_is (active_window->keymap, function);
d752 14
a765 14
          if (!location)
            {
              info_error (_("`%s' is not on any keys"), command_name);
            }
          else
            {
              if (strncmp (location, "M-x ", 4) == 0)
                window_message_in_echo_area
                  (_("%s can only be invoked via %s."), command_name, location);
              else
                window_message_in_echo_area
                  (_("%s can be invoked via %s."), command_name, location);
            }
        }
d767 1
a767 1
        info_error (_("There is no function named `%s'"), command_name);
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: infodoc.c,v 1.23 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d24 8
a31 3
/* HELP_NODE_GETS_REGENERATED is always defined now that keys may get
   rebound, or other changes in the help text may occur.  */
#define HELP_NODE_GETS_REGENERATED 1
d50 34
a83 88
  N_("Basic Commands in Info Windows\n"),
  N_("******************************\n"),
  "\n",
  N_("  %-10s  Quit this help.\n"),
  N_("  %-10s  Quit Info altogether.\n"),
  N_("  %-10s  Invoke the Info tutorial.\n"),
  "\n",
  N_("Moving within a node:\n"),
  N_("---------------------\n"),
  N_("  %-10s  Scroll forward a page.\n"),
  N_("  %-10s  Scroll backward a page.\n"),
  N_("  %-10s  Go to the beginning of this node.\n"),
  N_("  %-10s  Go to the end of this node.\n"),
  N_("  %-10s  Scroll forward 1 line.\n"),
  N_("  %-10s  Scroll backward 1 line.\n"),
  "\n",
  N_("Selecting other nodes:\n"),
  N_("----------------------\n"),
  N_("  %-10s  Move to the `next' node of this node.\n"),
  N_("  %-10s  Move to the `previous' node of this node.\n"),
  N_("  %-10s  Move `up' from this node.\n"),
  N_("  %-10s  Pick menu item specified by name.\n"),
  N_("              Picking a menu item causes another node to be selected.\n"),
  N_("  %-10s  Follow a cross reference.  Reads name of reference.\n"),
  N_("  %-10s  Move to the last node seen in this window.\n"),
  N_("  %-10s  Skip to next hypertext link within this node.\n"),
  N_("  %-10s  Follow the hypertext link under cursor.\n"),
  N_("  %-10s  Move to the `directory' node.  Equivalent to `g (DIR)'.\n"),
  N_("  %-10s  Move to the Top node.  Equivalent to `g Top'.\n"),
  "\n",
  N_("Other commands:\n"),
  N_("---------------\n"),
  N_("  %-10s  Pick first ... ninth item in node's menu.\n"),
  N_("  %-10s  Pick last item in node's menu.\n"),
  N_("  %-10s  Search for a specified string in the index entries of this Info\n"),
  N_("              file, and select the node referenced by the first entry found.\n"),
  N_("  %-10s  Move to node specified by name.\n"),
  N_("              You may include a filename as well, as in (FILENAME)NODENAME.\n"),
  N_("  %-10s  Search forward through this Info file for a specified string,\n"),
  N_("              and select the node in which the next occurrence is found.\n"),
  N_("  %-10s  Search backward in this Info file for a specified string,\n"),
  N_("              and select the node in which the next occurrence is found.\n"),
  NULL
};

static char *info_help_keys_text[][2] = {
  { "", "" },
  { "", "" },
  { "", "" },
  { "CTRL-x 0", "CTRL-x 0" },
  { "q", "q" },
  { "h", "ESC h" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "SPC", "SPC" },
  { "DEL", "b" },
  { "b", "ESC b" },
  { "e", "ESC e" },
  { "ESC 1 SPC", "RET" },
  { "ESC 1 DEL", "y" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "n", "CTRL-x n" },
  { "p", "CTRL-x p" },
  { "u", "CTRL-x u" },
  { "m", "ESC m" },
  { "", "" },
  { "f", "ESC f" },
  { "l", "l" },
  { "TAB", "TAB" },
  { "RET", "CTRL-x RET" },
  { "d", "ESC d" },
  { "t", "ESC t" },
  { "", "" },
  { "", "" },
  { "", "" },
  { "1-9", "ESC 1-9" },
  { "0", "ESC 0" },
  { "i", "CTRL-x i" },
  { "", "" },
  { "g", "CTRL-x g" },
  { "", "" },
  { "s", "/" },
  { "", "" },
  { "ESC - s", "?" },
  { "", "" },
d166 1
a166 6
/* How to create internal_info_help_node.  HELP_IS_ONLY_WINDOW_P says
   whether we're going to end up in a second (or more) window of our
   own, or whether there's only one window and we're going to usurp it.
   This determines how to quit the help window.  Maybe we should just
   make q do the right thing in both cases.  */

d168 1
a168 2
create_internal_info_help_node (help_is_only_window_p)
     int help_is_only_window_p;
d171 1
a172 1
  char *contents = NULL;
d174 1
a174 1
#ifndef HELP_NODE_GETS_REGENERATED
d186 1
a186 15
        {
          /* Don't translate blank lines, gettext outputs the po file
             header in that case.  We want a blank line.  */
          char *msg = *(info_internal_help_text[i])
                      ? _(info_internal_help_text[i])
                      : info_internal_help_text[i];
          char *key = info_help_keys_text[i][vi_keys_p];
          
          /* If we have only one window (because the window size was too
             small to split it), CTRL-x 0 doesn't work to `quit' help.  */
          if (STREQ (key, "CTRL-x 0") && help_is_only_window_p)
            key = "l";

          printf_to_message_buffer (msg, key);
        }
d189 2
a190 2
      printf_to_message_buffer (_("The current search path is:\n"));
      printf_to_message_buffer ("  %s\n", infopath);
d192 1
a192 1
      printf_to_message_buffer (_("Commands available in Info windows:\n\n"));
d195 1
a195 1
      printf_to_message_buffer (_("Commands available in the echo area:\n\n"));
d218 1
a218 5
                 replace_in_documentation (strlen (function_doc_array[i].doc)
                                           == 0
					   ? function_doc_array[i].doc
					   : _(function_doc_array[i].doc)));

a260 5

/* If the eligible window's height is >= this, split it to make the help
   window.  Otherwise display the help window in the current window.  */
#define HELP_SPLIT_SIZE 24

d264 4
a267 3
  int help_is_only_window_p;
  WINDOW *eligible = NULL;
  WINDOW *help_window = get_window_of_node (internal_info_help_node);
a271 1
      WINDOW *window;
d284 1
a284 1
        return NULL;
d286 1
a286 1
#ifndef HELP_NODE_GETS_REGENERATED
d288 5
a292 12
    /* help window is static, just return it.  */
    return help_window;
#endif /* not HELP_NODE_GETS_REGENERATED */

  /* Make sure that we have a node containing the help text.  The
     argument is false if help will be the only window (so l must be used
     to quit help), true if help will be one of several visible windows
     (so CTRL-x 0 must be used to quit help).  */
  help_is_only_window_p
     = (help_window && !windows->next
        || !help_window && eligible->height < HELP_SPLIT_SIZE);
  create_internal_info_help_node (help_is_only_window_p);
d297 2
a298 1
    { /* Split the largest window into 2 windows, and show the help text
d300 1
a300 1
      if (eligible->height >= HELP_SPLIT_SIZE)
d313 2
a314 1
    { /* Case where help node always gets regenerated, and we have an
d324 1
a324 1
  return help_window;
d340 1
a340 1
      info_error (msg_cant_make_help);
d384 1
a384 1
        info_error (msg_cant_file_node, "Info", nodename);
d421 1
a421 3
  return replace_in_documentation ((strlen (function_doc_array[i].doc) == 0)
                                   ? function_doc_array[i].doc
                                   : _(function_doc_array[i].doc));
d478 1
a478 1
  keyname[0] = 0;
d481 1
a481 1
  for (;;)
d487 1
a487 1
      if (Meta_p (keystroke))
d492 1
a492 1
              (_("ESC %s is undefined."), pretty_keyname (UnMeta (keystroke)));
d630 1
a630 1
          /* If the internal documentation string fails, there is a
d690 1
a690 1

d721 1
a721 1
  return NULL;
d727 1
a727 1
   _("Show what to type to execute a given command"))
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: infodoc.c,v 1.28 2002/02/27 13:37:33 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99, 2001, 02 Free Software Foundation, Inc.
a22 1
#include "funs.h"
d28 6
d43 1
a43 55
/* The (more or less) static text which appears in the internal info
   help node.  The actual key bindings are inserted.  Keep the 
   underlines (****, etc.) in the same N_ call as  the text lines they
   refer to, so translations can make the number of *'s or -'s match.  */
#if defined(INFOKEY)

static char *info_internal_help_text[] = {
  N_("Basic Commands in Info Windows\n\
******************************\n"),
  "\n",
  N_("\\%-10[quit-help]  Quit this help.\n"),
  N_("\\%-10[quit]  Quit Info altogether.\n"),
  N_("\\%-10[get-info-help-node]  Invoke the Info tutorial.\n"),
  "\n",
  N_("Selecting other nodes:\n\
----------------------\n"),
  N_("\\%-10[next-node]  Move to the \"next\" node of this node.\n"),
  N_("\\%-10[prev-node]  Move to the \"previous\" node of this node.\n"),
  N_("\\%-10[up-node]  Move \"up\" from this node.\n"),
  N_("\\%-10[menu-item]  Pick menu item specified by name.\n\
              Picking a menu item causes another node to be selected.\n"),
  N_("\\%-10[xref-item]  Follow a cross reference.  Reads name of reference.\n"),
  N_("\\%-10[history-node]  Move to the last node seen in this window.\n"),
  N_("\\%-10[move-to-next-xref]  Skip to next hypertext link within this node.\n"),
  N_("\\%-10[move-to-prev-xref]  Skip to previous hypertext link within this node.\n"),
  N_("\\%-10[select-reference-this-line]  Follow the hypertext link under cursor.\n"),
  N_("\\%-10[dir-node]  Move to the `directory' node.  Equivalent to `\\[goto-node] (DIR)'.\n"),
  N_("\\%-10[top-node]  Move to the Top node.  Equivalent to `\\[goto-node] Top'.\n"),
  "\n",
  N_("Moving within a node:\n\
---------------------\n"),
  N_("\\%-10[scroll-forward]  Scroll forward a page.\n"),
  N_("\\%-10[scroll-backward]  Scroll backward a page.\n"),
  N_("\\%-10[beginning-of-node]  Go to the beginning of this node.\n"),
  N_("\\%-10[end-of-node]  Go to the end of this node.\n"),
  N_("\\%-10[scroll-forward]  Scroll forward 1 line.\n"),
  N_("\\%-10[scroll-backward]  Scroll backward 1 line.\n"),
  "\n",
  N_("Other commands:\n\
---------------\n"),
  N_("\\%-10[menu-digit]  Pick first ... ninth item in node's menu.\n"),
  N_("\\%-10[last-menu-item]  Pick last item in node's menu.\n"),
  N_("\\%-10[index-search]  Search for a specified string in the index entries of this Info\n\
              file, and select the node referenced by the first entry found.\n"),
  N_("\\%-10[goto-node]  Move to node specified by name.\n\
              You may include a filename as well, as in (FILENAME)NODENAME.\n"),
  N_("\\%-10[search]  Search forward for a specified string\n\
              and select the node in which the next occurrence is found.\n"),
  N_("\\%-10[search-backward]  Search backward for a specified string\n\
              and select the node in which the previous occurrence is found.\n"),
  NULL
};

#else /* !INFOKEY */

d45 2
a46 2
  N_("Basic Commands in Info Windows\n\
******************************\n"),
d52 11
a62 2
  N_("Selecting other nodes:\n\
----------------------\n",
d75 2
a76 11
  N_("Moving within a node:\n\
---------------------\n"),
  N_("  %-10s  Scroll forward a page.\n"),
  N_("  %-10s  Scroll backward a page.\n"),
  N_("  %-10s  Go to the beginning of this node.\n"),
  N_("  %-10s  Go to the end of this node.\n"),
  N_("  %-10s  Scroll forward 1 line.\n"),
  N_("  %-10s  Scroll backward 1 line.\n"),
  "\n",
  N_("Other commands:\n\
---------------\n"),
d83 1
a83 1
  N_("  %-10s  Search forward for a specified string,\n"),
d85 1
a85 1
  N_("  %-10s  Search backward for a specified string\n"),
d136 1
a136 3
#endif /* !INFOKEY */

static char *where_is_internal ();
a143 5
  unsigned prefix_len = strlen (prefix);
  char *new_prefix = (char *)xmalloc (prefix_len + 2);

  strncpy (new_prefix, prefix, prefix_len);
  new_prefix[prefix_len + 1] = '\0';
a146 1
      new_prefix[prefix_len] = i;
d149 7
d157 1
d179 4
a182 3
              printf_to_message_buffer ("%s .. ", pretty_keyseq (new_prefix));
	      new_prefix[prefix_len] = last - 1;
              printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix));
d186 1
a186 1
            printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix));
a212 1
  free (new_prefix);
a227 1
  char *exec_keys;
a241 4
#ifdef INFOKEY
          printf_to_message_buffer (replace_in_documentation (
           _(info_internal_help_text[i]), help_is_only_window_p));
#else
a254 1
#endif /* !INFOKEY */
d268 1
a268 4
      /* Get a list of commands which have no keystroke equivs. */
      exec_keys = where_is (info_keymap, InfoCmd(info_execute_command));
      if (exec_keys)
        exec_keys = xstrdup (exec_keys);
d271 1
a271 1
          InfoCommand *cmd = DocInfoCmd(&function_doc_array[i]);
d273 2
a274 3
          if (InfoFunction(cmd) != info_do_lowercase_version
	      && !where_is_internal (info_keymap, cmd)
              && !where_is_internal (echo_area_keymap, cmd))
d279 2
a280 6
		  if (exec_keys && exec_keys[0])
		      printf_to_message_buffer
			(_("The following commands can only be invoked via %s:\n\n"), exec_keys);
		  else
		      printf_to_message_buffer
			(_("The following commands cannot be invoked at all:\n\n"));
d285 1
a285 2
                ("%s %s\n     %s\n",
		 exec_keys,
d288 3
a290 3
					   ? _(function_doc_array[i].doc)
					   : "")
		);
a296 2

      maybe_free (exec_keys);
d495 2
a496 2
function_documentation (cmd)
     InfoCommand *cmd;
a497 8
  char *doc;

#if defined (INFOKEY)

  doc = cmd->doc;

#else /* !INFOKEY */

d501 1
a501 1
    if (InfoFunction(cmd) == function_doc_array[i].func)
d504 3
a506 5
  doc = function_doc_array[i].func ? function_doc_array[i].doc : "";

#endif /* !INFOKEY */

  return replace_in_documentation ((strlen (doc) == 0) ? doc : _(doc));
d513 3
a515 2
function_name (cmd)
     InfoCommand *cmd;
a516 6
#if defined (INFOKEY)

  return cmd->func_name;

#else /* !INFOKEY */

d520 1
a520 1
    if (InfoFunction(cmd) == function_doc_array[i].func)
a523 2

#endif /* !INFOKEY */
d526 2
a527 2
/* Return a pointer to the info command for function NAME. */
InfoCommand *
d537 1
a537 1
  return (DocInfoCmd(&function_doc_array[i]));
d547 1
a547 1
  InfoCommand *function = map[key].function;
d557 2
a558 1
  char keys[50];
d560 1
a560 1
  char *k = keys;
d563 1
a563 1
  *k = '\0';
d568 1
a568 1
      message_in_echo_area (_("Describe key: %s"), pretty_keyseq (keys));
a571 1
#if !defined (INFOKEY)
d581 2
a582 1
	  *k++ = '\e';
a585 1
#endif /* !INFOKEY */
d587 4
a590 3
      /* Add the KEYSTROKE to our list. */
      *k++ = keystroke;
      *k = '\0';
d592 1
a592 1
      if (map[keystroke].function == (InfoCommand *)NULL)
d594 1
a594 1
          message_in_echo_area (_("%s is undefined."), pretty_keyseq (keys));
d600 2
d606 1
a606 25
          char *keyname, *message, *fundoc, *funname = "";

#if defined (INFOKEY)
	  /* If the key is bound to do-lowercase-version, but its
	     lower-case variant is undefined, say that this key is
	     also undefined.  This is especially important for unbound
	     edit keys that emit an escape sequence: it's terribly
	     confusing to see a message "Home (do-lowercase-version)"
	     or some such when Home is unbound.  */
	  if (InfoFunction(map[keystroke].function) == info_do_lowercase_version)
	    {
	      unsigned char lowerkey = Meta_p(keystroke)
				       ? Meta (tolower (UnMeta (keystroke)))
				       : tolower (keystroke);

	      if (map[lowerkey].function == (InfoCommand *)NULL)
		{
		  message_in_echo_area (_("%s is undefined."),
					pretty_keyseq (keys));
		  return;
		}
	    }
#endif

	  keyname = pretty_keyseq (keys);
d630 3
a632 1
/* Return the pretty printable name of a single character. */
a636 1
  static char rep_buffer[30];
a644 3
#if defined (INFOKEY)
      sprintf (temp, "M-%s", rep);
#else /* !INFOKEY */
a645 1
#endif /* !INFOKEY */
a677 101
/* Return the pretty printable string which represents KEYSEQ. */

static void pretty_keyseq_internal ();

char *
pretty_keyseq (keyseq)
     char *keyseq;
{
  static char keyseq_rep[200];

  keyseq_rep[0] = '\0';
  if (*keyseq)
    pretty_keyseq_internal (keyseq, keyseq_rep);
  return (keyseq_rep);
}

static void
pretty_keyseq_internal (keyseq, rep)
     char *keyseq, *rep;
{
  if (term_kP && strncmp(keyseq, term_kP, strlen(term_kP)) == 0)
    {
      strcpy(rep, "PgUp");
      keyseq += strlen(term_kP);
    }
  else if (term_kN && strncmp(keyseq, term_kN, strlen(term_kN)) == 0)
    {
      strcpy(rep, "PgDn");
      keyseq += strlen(term_kN);
    }
#if defined(INFOKEY)
  else if (term_kh && strncmp(keyseq, term_kh, strlen(term_kh)) == 0)
    {
      strcpy(rep, "Home");
      keyseq += strlen(term_kh);
    }
  else if (term_ke && strncmp(keyseq, term_ke, strlen(term_ke)) == 0)
    {
      strcpy(rep, "End");
      keyseq += strlen(term_ke);
    }
  else if (term_ki && strncmp(keyseq, term_ki, strlen(term_ki)) == 0)
    {
      strcpy(rep, "INS");
      keyseq += strlen(term_ki);
    }
  else if (term_kx && strncmp(keyseq, term_kx, strlen(term_kx)) == 0)
    {
      strcpy(rep, "DEL");
      keyseq += strlen(term_kx);
    }
#endif /* INFOKEY */
  else if (term_ku && strncmp(keyseq, term_ku, strlen(term_ku)) == 0)
    {
      strcpy(rep, "Up");
      keyseq += strlen(term_ku);
    }
  else if (term_kd && strncmp(keyseq, term_kd, strlen(term_kd)) == 0)
    {
      strcpy(rep, "Down");
      keyseq += strlen(term_kd);
    }
  else if (term_kl && strncmp(keyseq, term_kl, strlen(term_kl)) == 0)
    {
      strcpy(rep, "Left");
      keyseq += strlen(term_kl);
    }
  else if (term_kr && strncmp(keyseq, term_kr, strlen(term_kr)) == 0)
    {
      strcpy(rep, "Right");
      keyseq += strlen(term_kr);
    }
  else
    {
      strcpy (rep, pretty_keyname (keyseq[0]));
      keyseq++;
    }
  if (*keyseq)
    {
      strcat (rep, " ");
      pretty_keyseq_internal (keyseq, rep + strlen(rep));
    }
}

/* Return a pointer to the last character in s that is found in f. */
static char *
strrpbrk (s, f)
     const char *s, *f;
{
  register const char *e = s + strlen(s);
  register const char *t;

  while (e-- != s)
    {
      for (t = f; *t; t++)
        if (*e == *t)
	  return (char *)e;
    }
  return NULL;
}

d680 1
a680 1
replace_in_documentation (string, help_is_only_window_p)
a681 1
     int help_is_only_window_p;
a682 1
  unsigned reslen = strlen (string);
d687 1
a687 1
  result = (char *)xmalloc (1 + reslen);
a693 2
      int j = i + 1;

d695 4
a698 138
      if (string[i] == '\\')
      	{
	  char *fmt = NULL;
	  unsigned min = 0;
	  unsigned max = 0;

	  if(string[j] == '%')
	    {
	      if (string[++j] == '-')
		j++;
	      if (isdigit(string[j]))
		{
		  min = atoi(string + j);
		  while (isdigit(string[j]))
		    j++;
		  if (string[j] == '.' && isdigit(string[j + 1]))
		    {
		      j += 1;
		      max = atoi(string + j);
		      while (isdigit(string[j]))
			j++;
		    }
		  fmt = (char *)xmalloc (j - i + 2);
		  strncpy (fmt, string + i + 1, j - i);
		  fmt[j - i - 1] = 's';
		  fmt[j - i] = '\0';
		}
	      else
		j = i + 1;
	    }
	  if (string[j] == '[')
	    {
	      unsigned arg = 0;
	      char *argstr = NULL;
	      char *rep_name, *fun_name, *rep;
	      InfoCommand *command;
	      char *repstr = NULL;
	      unsigned replen;

	      /* Copy in the old text. */
	      strncpy (result + next, string + start, i - start);
	      next += (i - start);
	      start = j + 1;

	      /* Look for an optional numeric arg. */
	      i = start;
	      if (isdigit(string[i])
		  || (string[i] == '-' && isdigit(string[i + 1])) )
		{
		  arg = atoi(string + i);
		  if (string[i] == '-')
		    i++;
		  while (isdigit(string[i]))
		    i++;
		}
	      start = i;

	      /* Move to the end of the function name. */
	      for (i = start; string[i] && (string[i] != ']'); i++);

	      rep_name = (char *)xmalloc (1 + i - start);
	      strncpy (rep_name, string + start, i - start);
	      rep_name[i - start] = '\0';

	    /* If we have only one window (because the window size was too
	       small to split it), we have to quit help by going back one
	       noew in the history list, not deleting the window.  */
	      if (strcmp (rep_name, "quit-help") == 0)
		fun_name = help_is_only_window_p ? "history-node"
						 : "delete-window";
	      else
	        fun_name = rep_name;

	      /* Find a key which invokes this function in the info_keymap. */
	      command = named_function (fun_name);

	      free (rep_name);

	      /* If the internal documentation string fails, there is a
		 serious problem with the associated command's documentation.
		 We croak so that it can be fixed immediately. */
	      if (!command)
		abort ();

	      if (arg)
	      	{
		  char *argrep, *p;

		  argrep = where_is (info_keymap, InfoCmd(info_add_digit_to_numeric_arg));
		  p = argrep ? strrpbrk (argrep, "0123456789-") : NULL;
		  if (p)
		    {
		      argstr = (char *)xmalloc (p - argrep + 21);
		      strncpy (argstr, argrep, p - argrep);
		      sprintf (argstr + (p - argrep), "%d", arg);
		    }
		  else
		    command = NULL;
		}
	      rep = command ? where_is (info_keymap, command) : NULL;
	      if (!rep)
	        rep = "N/A";
	      replen = (argstr ? strlen (argstr) + 1 : 0) + strlen (rep);
	      repstr = (char *)xmalloc (replen);
	      repstr[0] = '\0';
	      if (argstr)
		{
		  strcat(repstr, argstr);
		  strcat(repstr, " ");
		  free (argstr);
		}
	      strcat(repstr, rep);

	      if (fmt)
		{
		  if (replen > max)
		    replen = max;
		  if (replen < min)
		    replen = min;
		}
	      if (next + replen > reslen)
		{
		  reslen = next + replen + 1;
		  result = (char *)xrealloc (result, reslen + 1);
		}

	      if (fmt)
		  sprintf (result + next, fmt, repstr);
	      else
		  strcpy (result + next, repstr);

	      next = strlen (result);
	      free (repstr);

	      start = i;
	      if (string[i])
		start++;
	    }
d700 29
a728 2
	  maybe_free (fmt);
	}
d740 2
a741 2
char *
where_is (map, cmd)
d743 1
a743 1
     InfoCommand *cmd;
d751 1
a751 1
  rep = where_is_internal (map, cmd);
d753 1
a753 1
  /* If it couldn't be found, return "M-x Foo" (or equivalent). */
d758 1
a758 7
      name = function_name (cmd);
      if (!name)
      	return NULL; /* no such function */

      rep = where_is_internal (map, InfoCmd(info_execute_command));
      if (!rep)
        return ""; /* function exists but can't be got to by user */
d760 2
a761 1
      sprintf (where_is_rep, "%s %s", rep, name);
d768 1
a768 2
/* Return the printed rep of the keystrokes that invoke FUNCTION,
   as found in MAP, or NULL. */
d770 1
a770 1
where_is_internal (map, cmd)
d772 1
a772 1
     InfoCommand *cmd;
a773 12
#if defined(INFOKEY)

  register FUNCTION_KEYSEQ *k;

  for (k = cmd->keys; k; k = k->next)
    if (k->map == map)
      return pretty_keyseq (k->keyseq);

  return NULL;

#else /* !INFOKEY */

d779 1
a779 1
    if ((map[i].type == ISFUNC) && map[i].function == cmd)
d797 1
a797 1
          rep = where_is_internal ((Keymap)map[i].function, cmd);
a806 2

#endif /* INFOKEY */
d826 1
a826 1
      InfoCommand *command;
d828 1
a828 1
      command = named_function (command_name);
d830 1
a830 1
      if (command)
d834 1
a834 1
          location = where_is (active_window->keymap, command);
d836 1
a836 1
          if (!location || !location[0])
d842 1
a842 1
              if (strstr (location, function_name (command)))
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* infodoc.c -- functions which build documentation nodes.
   $Id: infodoc.c,v 1.8 2004/04/11 17:56:45 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d39 1
a39 1
   help node.  The actual key bindings are inserted.  Keep the
d69 2
d73 2
a74 4
  N_("\\%-10[next-line]  Scroll forward 1 line.\n"),
  N_("\\%-10[prev-line]  Scroll backward 1 line.\n"),
  N_("\\%-10[scroll-forward]  Scroll forward a page.\n"),
  N_("\\%-10[scroll-backward]  Scroll backward a page.\n"),
d187 1
a187 1
static char *where_is_internal (Keymap map, InfoCommand *cmd);
d190 3
a192 1
dump_map_to_message_buffer (char *prefix, Keymap map)
d228 3
a230 5
              printf_to_message_buffer ("%s .. ", pretty_keyseq (new_prefix),
                  NULL, NULL);
              new_prefix[prefix_len] = last - 1;
              printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix),
                  NULL, NULL);
d234 1
a234 2
            printf_to_message_buffer ("%s\t", pretty_keyseq (new_prefix),
                NULL, NULL);
d243 1
a243 1
            printf_to_message_buffer ("(%s)", name, NULL, NULL);
d246 2
a247 3
            if ((desired_doc_start + strlen (doc))
                >= (unsigned int) the_screen->width)
              printf_to_message_buffer ("\n     ", NULL, NULL, NULL);
d252 1
a252 1
                    printf_to_message_buffer ("\t", NULL, NULL, NULL);
d258 1
a258 1
          printf_to_message_buffer ("%s\n", doc, NULL, NULL);
d271 2
a272 1
create_internal_info_help_node (int help_is_only_window_p)
d293 2
a294 3
          printf_to_message_buffer (replace_in_documentation
              ((char *) _(info_internal_help_text[i]), help_is_only_window_p),
              NULL, NULL, NULL);
d302 1
a302 1

d308 1
a308 1
          printf_to_message_buffer (msg, key, NULL, NULL);
d312 5
a316 7
      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("The current search path is:\n"),
          NULL, NULL, NULL);
      printf_to_message_buffer ("  %s\n", infopath, NULL, NULL);
      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("Commands available in Info windows:\n\n"),
          NULL, NULL, NULL);
d318 2
a319 3
      printf_to_message_buffer ("---------------------\n\n", NULL, NULL, NULL);
      printf_to_message_buffer ((char *) _("Commands available in the echo area:\n\n"),
          NULL, NULL, NULL);
d331 2
a332 2
          if (InfoFunction(cmd) != (VFunction *) info_do_lowercase_version
              && !where_is_internal (info_keymap, cmd)
d337 7
a343 10
                  printf_to_message_buffer ("---------------------\n\n",
                      NULL, NULL, NULL);
                  if (exec_keys && exec_keys[0])
                      printf_to_message_buffer
                        ((char *) _("The following commands can only be invoked via %s:\n\n"),
                         exec_keys, NULL, NULL);
                  else
                      printf_to_message_buffer
                        ((char *) _("The following commands cannot be invoked at all:\n\n"),
                         NULL, NULL, NULL);
d349 1
a349 1
                 exec_keys,
d352 3
a354 2
                   ? (char *) _(function_doc_array[i].doc) : "", 0)
                );
d360 1
a360 1
        printf_to_message_buffer ("\n", NULL, NULL, NULL);
d367 1
a367 2
         ((char *) _("--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n"), 0),
         NULL, NULL);
d406 1
a406 1
info_find_or_create_help_window (void)
d440 3
a442 2
  help_is_only_window_p = ((help_window && !windows->next)
        || (!help_window && eligible->height < HELP_SPLIT_SIZE));
d489 1
a489 1
      info_error ((char *) msg_cant_make_help, NULL, NULL);
d531 1
a531 1
        info_error (info_recent_file_error, NULL, NULL);
d533 1
a533 1
        info_error ((char *) msg_cant_file_node, "Info", nodename);
d561 2
a562 1
function_documentation (InfoCommand *cmd)
d582 1
a582 1
  return replace_in_documentation ((strlen (doc) == 0) ? doc : (char *) _(doc), 0);
d589 2
a590 1
function_name (InfoCommand *cmd)
d611 2
a612 1
named_function (char *name)
d626 3
a628 1
key_documentation (char key, Keymap map)
d650 1
a650 2
      message_in_echo_area ((char *) _("Describe key: %s"),
          pretty_keyseq (keys), NULL);
d664 1
a664 1
          *k++ = '\e';
d676 1
a676 2
          message_in_echo_area ((char *) _("%s is undefined."),
              pretty_keyseq (keys), NULL);
d689 19
a707 20
          /* If the key is bound to do-lowercase-version, but its
             lower-case variant is undefined, say that this key is
             also undefined.  This is especially important for unbound
             edit keys that emit an escape sequence: it's terribly
             confusing to see a message "Home (do-lowercase-version)"
             or some such when Home is unbound.  */
          if (InfoFunction(map[keystroke].function)
              == (VFunction *) info_do_lowercase_version)
            {
              unsigned char lowerkey = Meta_p(keystroke)
                                       ? Meta (tolower (UnMeta (keystroke)))
                                       : tolower (keystroke);

              if (map[lowerkey].function == (InfoCommand *)NULL)
                {
                  message_in_echo_area ((char *) _("%s is undefined."),
                                        pretty_keyseq (keys), NULL);
                  return;
                }
            }
d710 1
a710 1
          keyname = pretty_keyseq (keys);
d727 1
a727 1
          window_message_in_echo_area ("%s", message, NULL);
d736 2
a737 1
pretty_keyname (unsigned char key)
d787 1
a787 1
static void pretty_keyseq_internal (char *keyseq, char *rep);
d790 2
a791 1
pretty_keyseq (char *keyseq)
d802 2
a803 1
pretty_keyseq_internal (char *keyseq, char *rep)
d871 2
a872 1
strrpbrk (const char *s, const char *f)
d881 1
a881 1
          return (char *)e;
d888 3
a890 1
replace_in_documentation (char *string, int help_is_only_window_p)
d908 137
a1044 71
        {
          char *fmt = NULL;
          unsigned min = 0;
          unsigned max = 0;

          if(string[j] == '%')
            {
              if (string[++j] == '-')
                j++;
              if (isdigit(string[j]))
                {
                  min = atoi(string + j);
                  while (isdigit(string[j]))
                    j++;
                  if (string[j] == '.' && isdigit(string[j + 1]))
                    {
                      j += 1;
                      max = atoi(string + j);
                      while (isdigit(string[j]))
                        j++;
                    }
                  fmt = (char *)xmalloc (j - i + 2);
                  strncpy (fmt, string + i + 1, j - i);
                  fmt[j - i - 1] = 's';
                  fmt[j - i] = '\0';
                }
              else
                j = i + 1;
            }
          if (string[j] == '[')
            {
              unsigned arg = 0;
              char *argstr = NULL;
              char *rep_name, *fun_name, *rep;
              InfoCommand *command;
              char *repstr = NULL;
              unsigned replen;

              /* Copy in the old text. */
              strncpy (result + next, string + start, i - start);
              next += (i - start);
              start = j + 1;

              /* Look for an optional numeric arg. */
              i = start;
              if (isdigit(string[i])
                  || (string[i] == '-' && isdigit(string[i + 1])) )
                {
                  arg = atoi(string + i);
                  if (string[i] == '-')
                    i++;
                  while (isdigit(string[i]))
                    i++;
                }
              start = i;

              /* Move to the end of the function name. */
              for (i = start; string[i] && (string[i] != ']'); i++);

              rep_name = (char *)xmalloc (1 + i - start);
              strncpy (rep_name, string + start, i - start);
              rep_name[i - start] = '\0';

            /* If we have only one window (because the window size was too
               small to split it), we have to quit help by going back one
               noew in the history list, not deleting the window.  */
              if (strcmp (rep_name, "quit-help") == 0)
                fun_name = help_is_only_window_p ? "history-node"
                                                 : "delete-window";
              else
                fun_name = rep_name;
d1046 2
a1047 68
              /* Find a key which invokes this function in the info_keymap. */
              command = named_function (fun_name);

              free (rep_name);

              /* If the internal documentation string fails, there is a
                 serious problem with the associated command's documentation.
                 We croak so that it can be fixed immediately. */
              if (!command)
                abort ();

              if (arg)
                {
                  char *argrep, *p;

                  argrep = where_is (info_keymap, InfoCmd(info_add_digit_to_numeric_arg));
                  p = argrep ? strrpbrk (argrep, "0123456789-") : NULL;
                  if (p)
                    {
                      argstr = (char *)xmalloc (p - argrep + 21);
                      strncpy (argstr, argrep, p - argrep);
                      sprintf (argstr + (p - argrep), "%d", arg);
                    }
                  else
                    command = NULL;
                }
              rep = command ? where_is (info_keymap, command) : NULL;
              if (!rep)
                rep = "N/A";
              replen = (argstr ? strlen (argstr) : 0) + strlen (rep) + 1;
              repstr = (char *)xmalloc (replen);
              repstr[0] = '\0';
              if (argstr)
                {
                  strcat(repstr, argstr);
                  strcat(repstr, " ");
                  free (argstr);
                }
              strcat(repstr, rep);

              if (fmt)
                {
                  if (replen > max)
                    replen = max;
                  if (replen < min)
                    replen = min;
                }
              if (next + replen > reslen)
                {
                  reslen = next + replen + 1;
                  result = (char *)xrealloc (result, reslen + 1);
                }

              if (fmt)
                  sprintf (result + next, fmt, repstr);
              else
                  strcpy (result + next, repstr);

              next = strlen (result);
              free (repstr);

              start = i;
              if (string[i])
                start++;
            }

          maybe_free (fmt);
        }
d1060 3
a1062 1
where_is (Keymap map, InfoCommand *cmd)
d1079 1
a1079 1
        return NULL; /* no such function */
d1095 3
a1097 1
where_is_internal (Keymap map, InfoCommand *cmd)
d1110 1
a1110 9
  /* There is a bug in that create_internal_info_help_node calls
     where_is_internal without setting where_is_rep_index to zero.  This
     was found by Mandrake and reported by Thierry Vignaud
     <tvignaud@@mandrakesoft.com> around April 24, 2002.

     I think the best fix is to make where_is_rep_index another
     parameter to this recursively-called function, instead of a static
     variable.  But this [!INFOKEY] branch of the code is not enabled
     any more, so let's just skip the whole thing.  --karl, 28sep02.  */
d1148 2
d1155 1
a1155 1
  command_name = read_function_name ((char *) _("Where is command: "), window);
d1177 1
a1177 2
              info_error ((char *) _("`%s' is not on any keys"),
                  command_name, NULL);
d1183 1
a1183 2
                  ((char *) _("%s can only be invoked via %s."),
                   command_name, location);
d1186 1
a1186 2
                  ((char *) _("%s can be invoked via %s."),
                   command_name, location);
d1190 1
a1190 2
        info_error ((char *) _("There is no function named `%s'"),
            command_name, NULL);
@


