head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.42
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.38
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.40
	OPENBSD_5_8_BASE:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.32
	OPENBSD_5_7_BASE:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.36
	OPENBSD_5_6_BASE:1.1.1.4
	OPENBSD_5_5:1.1.1.4.0.34
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.30
	OPENBSD_5_4_BASE:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.28
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.26
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.24
	OPENBSD_5_0:1.1.1.4.0.22
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.20
	OPENBSD_4_9_BASE:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.18
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.14
	OPENBSD_4_7_BASE:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.16
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.12
	OPENBSD_4_5_BASE:1.1.1.4
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	TEXINFO_4_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.26
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.24
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.22
	OPENBSD_3_7_BASE:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.20
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.18
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.16
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.14
	OPENBSD_3_3_BASE:1.1.1.3
	OPENBSD_3_2:1.1.1.3.0.12
	OPENBSD_3_2_BASE:1.1.1.3
	TEXINFO_4_2:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.10
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.8
	OPENBSD_3_0_BASE:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.6
	OPENBSD_2_9_BASE:1.1.1.3
	OPENBSD_2_8:1.1.1.3.0.4
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.2
	OPENBSD_2_7_BASE:1.1.1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.1.1.2.0.10
	OPENBSD_2_6_BASE:1.1.1.2
	OPENBSD_2_5:1.1.1.2.0.8
	OPENBSD_2_5_BASE:1.1.1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.39;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.25.00;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.07.17.16.03.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* signals.c -- Install and maintain Info signal handlers. */

/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "signals.h"

/* **************************************************************** */
/*								    */
/*		Pretending That We Have POSIX Signals		    */
/*								    */
/* **************************************************************** */

#if !defined (HAVE_SIGPROCMASK) && defined (HAVE_SIGSETMASK)
/* Perform OPERATION on NEWSET, perhaps leaving information in OLDSET. */
static void
sigprocmask (operation, newset, oldset)
     int operation, *newset, *oldset;
{
  switch (operation)
    {
    case SIG_UNBLOCK:
      sigsetmask (sigblock (0) & ~(*newset));
      break;

    case SIG_BLOCK:
      *oldset = sigblock (*newset);
      break;

    case SIG_SETMASK:
      sigsetmask (*newset);
      break;

    default:
      abort ();
    }
}
#endif /* !HAVE_SIGPROCMASK && HAVE_SIGSETMASK */

/* **************************************************************** */
/*								    */
/*		    Signal Handling for Info			    */
/*								    */
/* **************************************************************** */

typedef void SigHandlerType;
typedef SigHandlerType SigHandler ();

static SigHandlerType info_signal_handler ();
static SigHandler *old_TSTP, *old_TTOU, *old_TTIN;
static SigHandler *old_WINCH, *old_INT;

void
initialize_info_signal_handler ()
{
#if defined (SIGTSTP)
  old_TSTP = (SigHandler *) signal (SIGTSTP, info_signal_handler);
  old_TTOU = (SigHandler *) signal (SIGTTOU, info_signal_handler);
  old_TTIN = (SigHandler *) signal (SIGTTIN, info_signal_handler);
#endif /* SIGTSTP */

#if defined (SIGWINCH)
  old_WINCH = (SigHandler *) signal (SIGWINCH, info_signal_handler);
#endif

#if defined (SIGINT)
  old_INT = (SigHandler *) signal (SIGINT, info_signal_handler);
#endif
}

static void
redisplay_after_signal ()
{
  terminal_clear_screen ();
  display_clear_display (the_display);
  window_mark_chain (windows, W_UpdateWindow);
  display_update_display (windows);
  display_cursor_at_point (active_window);
  fflush (stdout);
}

static SigHandlerType
info_signal_handler (sig)
     int sig;
{
  SigHandler **old_signal_handler;

  switch (sig)
    {
#if defined (SIGTSTP)
    case SIGTSTP:
    case SIGTTOU:
    case SIGTTIN:
#endif
#if defined (SIGINT)
    case SIGINT:
#endif
      {
#if defined (SIGTSTP)
	if (sig == SIGTSTP)
	  old_signal_handler = &old_TSTP;
	if (sig == SIGTTOU)
	  old_signal_handler = &old_TTOU;
	if (sig == SIGTTIN)
	  old_signal_handler = &old_TTIN;
#endif /* SIGTSTP */
	if (sig == SIGINT)
	  old_signal_handler = &old_INT;

	/* For stop signals, restore the terminal IO, leave the cursor
	   at the bottom of the window, and stop us. */
	terminal_goto_xy (0, screenheight - 1);
	terminal_clear_to_eol ();
	fflush (stdout);
	terminal_unprep_terminal ();
	signal (sig, *old_signal_handler);
 	UNBLOCK_SIGNAL (sig);
	kill (getpid (), sig);

	/* The program is returning now.  Restore our signal handler,
	   turn on terminal handling, redraw the screen, and place the
	   cursor where it belongs. */
	terminal_prep_terminal ();
	*old_signal_handler = (SigHandler *) signal (sig, info_signal_handler);
	redisplay_after_signal ();
	fflush (stdout);
      }
      break;

#if defined (SIGWINCH)
    case SIGWINCH:
      {
	/* Turn off terminal IO, tell our parent that the window has changed,
	   then reinitialize the terminal and rebuild our windows. */
	old_signal_handler = &old_WINCH;
	terminal_goto_xy (0, 0);
	fflush (stdout);
	terminal_unprep_terminal ();
	signal (sig, *old_signal_handler);
 	UNBLOCK_SIGNAL (sig);
	kill (getpid (), sig);

	/* After our old signal handler returns... */
	terminal_get_screen_size ();
	terminal_prep_terminal ();
	display_initialize_display (screenwidth, screenheight);
	window_new_screen_size (screenwidth, screenheight, (VFunction *)NULL);
	*old_signal_handler = (SigHandler *) signal (sig, info_signal_handler);
	redisplay_after_signal ();
      }
      break;
#endif /* SIGWINCH */
    }
}
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d28 3
a30 3
/*                                                                  */
/*              Pretending That We Have POSIX Signals               */
/*                                                                  */
d60 3
a62 3
/*                                                                  */
/*                  Signal Handling for Info                        */
/*                                                                  */
d65 2
a66 1
typedef RETSIGTYPE signal_handler ();
d68 3
a70 3
static RETSIGTYPE info_signal_handler ();
static signal_handler *old_TSTP, *old_TTOU, *old_TTIN;
static signal_handler *old_WINCH, *old_INT;
d76 3
a78 3
  old_TSTP = (signal_handler *) signal (SIGTSTP, info_signal_handler);
  old_TTOU = (signal_handler *) signal (SIGTTOU, info_signal_handler);
  old_TTIN = (signal_handler *) signal (SIGTTIN, info_signal_handler);
d82 1
a82 1
  old_WINCH = (signal_handler *) signal (SIGWINCH, info_signal_handler);
d86 1
a86 1
  old_INT = (signal_handler *) signal (SIGINT, info_signal_handler);
d101 1
a101 1
static RETSIGTYPE
d105 1
a105 1
  signal_handler **old_signal_handler;
d119 6
a124 6
        if (sig == SIGTSTP)
          old_signal_handler = &old_TSTP;
        if (sig == SIGTTOU)
          old_signal_handler = &old_TTOU;
        if (sig == SIGTTIN)
          old_signal_handler = &old_TTIN;
d126 2
a127 2
        if (sig == SIGINT)
          old_signal_handler = &old_INT;
d129 17
a145 17
        /* For stop signals, restore the terminal IO, leave the cursor
           at the bottom of the window, and stop us. */
        terminal_goto_xy (0, screenheight - 1);
        terminal_clear_to_eol ();
        fflush (stdout);
        terminal_unprep_terminal ();
        signal (sig, *old_signal_handler);
        UNBLOCK_SIGNAL (sig);
        kill (getpid (), sig);

        /* The program is returning now.  Restore our signal handler,
           turn on terminal handling, redraw the screen, and place the
           cursor where it belongs. */
        terminal_prep_terminal ();
        *old_signal_handler = (signal_handler *) signal (sig, info_signal_handler);
        redisplay_after_signal ();
        fflush (stdout);
d152 17
a168 17
        /* Turn off terminal IO, tell our parent that the window has changed,
           then reinitialize the terminal and rebuild our windows. */
        old_signal_handler = &old_WINCH;
        terminal_goto_xy (0, 0);
        fflush (stdout);
        terminal_unprep_terminal ();
        signal (sig, *old_signal_handler);
        UNBLOCK_SIGNAL (sig);
        kill (getpid (), sig);

        /* After our old signal handler returns... */
        terminal_get_screen_size ();
        terminal_prep_terminal ();
        display_initialize_display (screenwidth, screenheight);
        window_new_screen_size (screenwidth, screenheight, (VFunction *)NULL);
        *old_signal_handler = (signal_handler *) signal (sig, info_signal_handler);
        redisplay_after_signal ();
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 1
a1 2
/* signals.c -- install and maintain Info signal handlers.
   $Id: signals.c,v 1.6 1998/12/06 22:00:04 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 94, 95, 98 Free Software Foundation, Inc.
a32 3
/* Non-zero when our signal handler has been called to handle SIGWINCH. */
static int in_sigwinch = 0;

d69 1
a69 1
static signal_handler *old_WINCH, *old_INT, *old_USR1;
a86 5

#if defined (SIGUSR1)
  /* Used by DJGPP to simulate SIGTSTP on Ctrl-Z.  */
  old_USR1 = (signal_handler *) signal (SIGUSR1, info_signal_handler);
#endif
a99 13
static void
reset_info_window_sizes ()
{
  terminal_goto_xy (0, 0);
  fflush (stdout);
  terminal_unprep_terminal ();
  terminal_get_screen_size ();
  terminal_prep_terminal ();
  display_initialize_display (screenwidth, screenheight);
  window_new_screen_size (screenwidth, screenheight, NULL);
  redisplay_after_signal ();
}

d148 1
a148 2
#if defined (SIGWINCH) || defined (SIGUSR1)
#ifdef SIGWINCH
a149 4
#endif
#ifdef SIGUSR1
    case SIGUSR1:
#endif
d151 17
a167 27
        if (!in_sigwinch) {
          in_sigwinch++;
          
          /* Turn off terminal IO, tell our parent that the window has changed,
             then reinitialize the terminal and rebuild our windows. */
#ifdef SIGWINCH
          if (sig == SIGWINCH)
            old_signal_handler = &old_WINCH;
#endif
#ifdef SIGUSR1
          if (sig == SIGUSR1)
            old_signal_handler = &old_USR1;
#endif
          terminal_goto_xy (0, 0);
          fflush (stdout);
          terminal_unprep_terminal ();
          signal (sig, *old_signal_handler);
          UNBLOCK_SIGNAL (sig);
          kill (getpid (), sig);

          /* After our old signal handler returns... */
          *old_signal_handler
            = (signal_handler *) signal (sig, info_signal_handler);
          terminal_prep_terminal ();
          reset_info_window_sizes ();
          in_sigwinch--;
        }
d170 1
a170 1
#endif /* SIGWINCH || SIGUSR1 */
@


1.1.1.4
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* signals.c -- install and maintain signal handlers.
   $Id: signals.c,v 1.7 2004/04/11 17:56:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1994, 1995, 1998, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d20 1
a20 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
a24 2
void initialize_info_signal_handler (void);

d31 3
d37 2
a38 1
sigprocmask (int operation, int *newset, int *oldset)
d66 1
a66 35
#if defined (HAVE_SIGACTION) || defined (HAVE_SIGPROCMASK) ||\
  defined (HAVE_SIGSETMASK)
static void
mask_termsig (sigset_t *set)
{
# if defined (SIGTSTP)
  sigaddset (set, SIGTSTP);
  sigaddset (set, SIGTTOU);
  sigaddset (set, SIGTTIN);
# endif
# if defined (SIGWINCH)
  sigaddset (set, SIGWINCH);
# endif
#if defined (SIGQUIT)
  sigaddset (set, SIGQUIT);
#endif
#if defined (SIGINT)
  sigaddset (set, SIGINT);
#endif
# if defined (SIGUSR1)
  sigaddset (set, SIGUSR1);
# endif
}
#endif /* HAVE_SIGACTION || HAVE_SIGPROCMASK || HAVE_SIGSETMASK */

static RETSIGTYPE info_signal_proc (int sig);
#if defined (HAVE_SIGACTION)
typedef struct sigaction signal_info;
signal_info info_signal_handler;

static void
set_termsig (int sig, signal_info *old)
{
  sigaction (sig, &info_signal_handler, old);
}
d68 3
a70 16
static void
restore_termsig (int sig, const signal_info *saved)
{
  sigaction (sig, saved, NULL);
}
#else /* !HAVE_SIGACTION */
typedef RETSIGTYPE (*signal_info) ();
#define set_termsig(sig, old) (void)(*(old) = signal (sig, info_signal_proc))
#define restore_termsig(sig, saved) (void)signal (sig, *(saved))
#define info_signal_handler info_signal_proc
static int term_conf_busy = 0;
#endif /* !HAVE_SIGACTION */

static signal_info old_TSTP, old_TTOU, old_TTIN;
static signal_info old_WINCH, old_INT, old_USR1;
static signal_info old_QUIT;
d73 1
a73 1
initialize_info_signal_handler (void)
a74 10
#ifdef SA_NOCLDSTOP
  /* (Based on info from Paul Eggert found in coreutils.)  Don't use
     HAVE_SIGACTION to decide whether to use the sa_handler, sa_flags,
     sa_mask members, as some systems (Solaris 7+) don't define them.  Use
     SA_NOCLDSTOP instead; it's been part of POSIX.1 since day 1 (in 1988).  */
  info_signal_handler.sa_handler = info_signal_proc;
  info_signal_handler.sa_flags = 0;
  mask_termsig (&info_signal_handler.sa_mask);
#endif /* SA_NOCLDSTOP */

d76 3
a78 3
  set_termsig (SIGTSTP, &old_TSTP);
  set_termsig (SIGTTOU, &old_TTOU);
  set_termsig (SIGTTIN, &old_TTIN);
d82 1
a82 5
  set_termsig (SIGWINCH, &old_WINCH);
#endif

#if defined (SIGQUIT)
  set_termsig (SIGQUIT, &old_QUIT);
d86 1
a86 1
  set_termsig (SIGINT, &old_INT);
d91 1
a91 1
  set_termsig (SIGUSR1, &old_USR1);
d96 1
a96 1
redisplay_after_signal (void)
d107 1
a107 1
reset_info_window_sizes (void)
d115 1
a115 1
  window_new_screen_size (screenwidth, screenheight);
d120 2
a121 1
info_signal_proc (int sig)
d123 1
a123 1
  signal_info *old_signal_handler = NULL;
a124 14
#if !defined (HAVE_SIGACTION)
  /* best effort: first increment this counter and later block signals */
  if (term_conf_busy)
    return;
  term_conf_busy++;
#if defined (HAVE_SIGPROCMASK) || defined (HAVE_SIGSETMASK)
    {
      sigset_t nvar, ovar;
      sigemptyset (&nvar);
      mask_termsig (&nvar);
      sigprocmask (SIG_BLOCK, &nvar, &ovar);
    }
#endif /* HAVE_SIGPROCMASK || HAVE_SIGSETMASK */
#endif /* !HAVE_SIGACTION */
a131 3
#if defined (SIGQUIT)
    case SIGQUIT:
#endif
a143 5
#if defined (SIGQUIT)
        if (sig == SIGQUIT)
          old_signal_handler = &old_QUIT;
#endif /* SIGQUIT */
#if defined (SIGINT)
a145 1
#endif /* SIGINT */
d153 3
a155 3
	restore_termsig (sig, old_signal_handler);
	UNBLOCK_SIGNAL (sig);
	kill (getpid (), sig);
d161 3
a163 3
	set_termsig (sig, old_signal_handler);
	/* window size might be changed while sleeping */
	reset_info_window_sizes ();
d175 5
a179 2
	/* Turn off terminal IO, tell our parent that the window has changed,
	   then reinitialize the terminal and rebuild our windows. */
d181 2
a182 2
	if (sig == SIGWINCH)
	  old_signal_handler = &old_WINCH;
d185 2
a186 2
	if (sig == SIGUSR1)
	  old_signal_handler = &old_USR1;
d188 14
a201 11
	terminal_goto_xy (0, 0);
	fflush (stdout);
	terminal_unprep_terminal (); /* needless? */
	restore_termsig (sig, old_signal_handler);
	UNBLOCK_SIGNAL (sig);
	kill (getpid (), sig);

	/* After our old signal handler returns... */
	set_termsig (sig, old_signal_handler); /* needless? */
	terminal_prep_terminal ();
	reset_info_window_sizes ();
a205 12
#if !defined (HAVE_SIGACTION)
  /* at this time it is safer to perform unblock after decrement */
  term_conf_busy--;
#if defined (HAVE_SIGPROCMASK) || defined (HAVE_SIGSETMASK)
    {
      sigset_t nvar, ovar;
      sigemptyset (&nvar);
      mask_termsig (&nvar);
      sigprocmask (SIG_UNBLOCK, &nvar, &ovar);
    }
#endif /* HAVE_SIGPROCMASK || HAVE_SIGSETMASK */
#endif /* !HAVE_SIGACTION */
a206 1
/* vim: set sw=2 cino={1s>2sn-s^-se-s: */
@


