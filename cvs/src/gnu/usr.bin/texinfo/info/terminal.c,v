head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.7.0.40
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.32
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.36
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.34
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.30
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.28
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	TEXINFO_4_8:1.1.1.7
	OPENBSD_3_9:1.6.0.16
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.14
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	TEXINFO_4_2:1.1.1.6
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	TEXINFO_4_0:1.1.1.5
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	TEXINFO_3_12:1.1.1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	TEXINFO_3_11:1.1.1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	TEXINFO_3_9:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2015.11.20.12.14.34;	author jca;	state Exp;
branches;
next	1.7;
commitid	3D9flEacwb23woGn;

1.7
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.16.38.09;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	97.08.01.22.37.40;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.15.22.33.56;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.12.15.21.39.07;	author downsj;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.08.01.22.00.42;	author kstailey;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.01.11.16.32.28;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.09.01.25.01;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2002.06.10.13.21.11;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.07.17.16.03.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Unbreak, tcflow and its underlying ioctls aren't allowed by pledge(2).

Just delete the tcflow(3) calls, the use case for tcflow(3) here is
a bit far-fetched.

looks good to deraadt@@, ok espie@@
@
text
@/* terminal.c -- how to handle the physical terminal for Info.
   $Id: terminal.c,v 1.7 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1996, 1997, 1998,
   1999, 2001, 2002, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Originally written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "terminal.h"
#include "termdep.h"

#include <sys/types.h>
#include <signal.h>

/* The Unix termcap interface code. */
#ifdef HAVE_NCURSES_TERMCAP_H
#include <ncurses/termcap.h>
#else
#ifdef HAVE_TERMCAP_H
#include <termcap.h>
#else
/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.
   Unfortunately, PC is a global variable used by the termcap library. */
#undef PC

/* Termcap requires these variables, whether we access them or not. */
char *BC, *UP;
char PC;      /* Pad character */
short ospeed; /* Terminal output baud rate */
extern int tgetnum (), tgetflag (), tgetent ();
extern char *tgetstr (), *tgoto ();
extern void tputs ();
#endif /* not HAVE_TERMCAP_H */
#endif /* not HAVE_NCURSES_TERMCAP_H */

/* Function "hooks".  If you make one of these point to a function, that
   function is called when appropriate instead of its namesake.  Your
   function is called with exactly the same arguments that were passed
   to the namesake function. */
VFunction *terminal_begin_inverse_hook = (VFunction *)NULL;
VFunction *terminal_end_inverse_hook = (VFunction *)NULL;
VFunction *terminal_prep_terminal_hook = (VFunction *)NULL;
VFunction *terminal_unprep_terminal_hook = (VFunction *)NULL;
VFunction *terminal_up_line_hook = (VFunction *)NULL;
VFunction *terminal_down_line_hook = (VFunction *)NULL;
VFunction *terminal_clear_screen_hook = (VFunction *)NULL;
VFunction *terminal_clear_to_eol_hook = (VFunction *)NULL;
VFunction *terminal_get_screen_size_hook = (VFunction *)NULL;
VFunction *terminal_goto_xy_hook = (VFunction *)NULL;
VFunction *terminal_initialize_terminal_hook = (VFunction *)NULL;
VFunction *terminal_new_terminal_hook = (VFunction *)NULL;
VFunction *terminal_put_text_hook = (VFunction *)NULL;
VFunction *terminal_ring_bell_hook = (VFunction *)NULL;
VFunction *terminal_write_chars_hook = (VFunction *)NULL;
VFunction *terminal_scroll_terminal_hook = (VFunction *)NULL;

/* **************************************************************** */
/*                                                                  */
/*                      Terminal and Termcap                        */
/*                                                                  */
/* **************************************************************** */

/* A buffer which holds onto the current terminal description, and a pointer
   used to float within it.  And the name of the terminal.  */
static char *term_buffer = NULL;
static char *term_string_buffer = NULL;
static char *term_name;

/* Some strings to control terminal actions.  These are output by tputs (). */
static char *term_goto, *term_clreol, *term_cr, *term_clrpag;
static char *term_begin_use, *term_end_use;
static char *term_AL, *term_DL, *term_al, *term_dl;

static char *term_keypad_on, *term_keypad_off;

/* How to go up a line. */
static char *term_up;

/* How to go down a line. */
static char *term_dn;

/* An audible bell, if the terminal can be made to make noise. */
static char *audible_bell;

/* A visible bell, if the terminal can be made to flash the screen. */
static char *visible_bell;

/* The string to write to turn on the meta key, if this term has one. */
static char *term_mm;

/* The string to turn on inverse mode, if this term has one. */
static char *term_invbeg;

/* The string to turn off inverse mode, if this term has one. */
static char *term_invend;

/* Although I can't find any documentation that says this is supposed to
   return its argument, all the code I've looked at (termutils, less)
   does so, so fine.  */
static int
output_character_function (int c)
{
  putc (c, stdout);
  return c;
}

/* Macro to send STRING to the terminal. */
#define send_to_terminal(string) \
  do { \
    if (string) \
      tputs (string, 1, output_character_function); \
     } while (0)

/* Tell the terminal that we will be doing cursor addressable motion.  */
static void
terminal_begin_using_terminal (void)
{
  RETSIGTYPE (*sigsave) (int signum);

  if (term_keypad_on)
      send_to_terminal (term_keypad_on);
  
  if (!term_begin_use || !*term_begin_use)
    return;

#ifdef SIGWINCH
  sigsave = signal (SIGWINCH, SIG_IGN); 
#endif

  send_to_terminal (term_begin_use);
  fflush (stdout);
  if (STREQ (term_name, "sun-cmd"))
    /* Without this fflush and sleep, running info in a shelltool or
       cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are
       not restored properly.
       From: strube@@physik3.gwdg.de (Hans Werner Strube).  */
    sleep (1);

#ifdef SIGWINCH
  signal (SIGWINCH, sigsave);
#endif
}

/* Tell the terminal that we will not be doing any more cursor
   addressable motion. */
static void
terminal_end_using_terminal (void)
{
  RETSIGTYPE (*sigsave) (int signum);

  if (term_keypad_off)
      send_to_terminal (term_keypad_off);
  
  if (!term_end_use || !*term_end_use)
    return;

#ifdef SIGWINCH
  sigsave = signal (SIGWINCH, SIG_IGN);
#endif

  send_to_terminal (term_end_use);
  fflush (stdout);
  if (STREQ (term_name, "sun-cmd"))
    /* See comments at other sleep.  */
    sleep (1);

#ifdef SIGWINCH
  signal (SIGWINCH, sigsave);
#endif
}

/* **************************************************************** */
/*                                                                  */
/*                   Necessary Terminal Functions                   */
/*                                                                  */
/* **************************************************************** */

/* The functions and variables on this page implement the user visible
   portion of the terminal interface. */

/* The width and height of the terminal. */
int screenwidth, screenheight;

/* Non-zero means this terminal can't really do anything. */
int terminal_is_dumb_p = 0;

/* Non-zero means that this terminal has a meta key. */
int terminal_has_meta_p = 0;

/* Non-zero means that this terminal can produce a visible bell. */
int terminal_has_visible_bell_p = 0;

/* Non-zero means to use that visible bell if at all possible. */
int terminal_use_visible_bell_p = 0;

/* Non-zero means that the terminal can do scrolling. */
int terminal_can_scroll = 0;

/* The key sequences output by the arrow keys, if this terminal has any. */
char *term_ku = NULL;
char *term_kd = NULL;
char *term_kr = NULL;
char *term_kl = NULL;
char *term_kP = NULL;   /* page-up */
char *term_kN = NULL;   /* page-down */
char *term_kh = NULL;	/* home */
char *term_ke = NULL;	/* end */
char *term_kD = NULL;	/* delete */
char *term_ki = NULL;	/* ins */
char *term_kx = NULL;	/* del */

/* Move the cursor to the terminal location of X and Y. */
void
terminal_goto_xy (int x, int y)
{
  if (terminal_goto_xy_hook)
    (*terminal_goto_xy_hook) (x, y);
  else
    {
      if (term_goto)
        tputs (tgoto (term_goto, x, y), 1, output_character_function);
    }
}

/* Print STRING to the terminal at the current position. */
void
terminal_put_text (char *string)
{
  if (terminal_put_text_hook)
    (*terminal_put_text_hook) (string);
  else
    {
      printf ("%s", string);
    }
}

/* Print NCHARS from STRING to the terminal at the current position. */
void
terminal_write_chars (char *string, int nchars)
{
  if (terminal_write_chars_hook)
    (*terminal_write_chars_hook) (string, nchars);
  else
    {
      if (nchars)
        fwrite (string, 1, nchars, stdout);
    }
}

/* Clear from the current position of the cursor to the end of the line. */
void
terminal_clear_to_eol (void)
{
  if (terminal_clear_to_eol_hook)
    (*terminal_clear_to_eol_hook) ();
  else
    {
      send_to_terminal (term_clreol);
    }
}

/* Clear the entire terminal screen. */
void
terminal_clear_screen (void)
{
  if (terminal_clear_screen_hook)
    (*terminal_clear_screen_hook) ();
  else
    {
      send_to_terminal (term_clrpag);
    }
}

/* Move the cursor up one line. */
void
terminal_up_line (void)
{
  if (terminal_up_line_hook)
    (*terminal_up_line_hook) ();
  else
    {
      send_to_terminal (term_up);
    }
}

/* Move the cursor down one line. */
void
terminal_down_line (void)
{
  if (terminal_down_line_hook)
    (*terminal_down_line_hook) ();
  else
    {
      send_to_terminal (term_dn);
    }
}

/* Turn on reverse video if possible. */
void
terminal_begin_inverse (void)
{
  if (terminal_begin_inverse_hook)
    (*terminal_begin_inverse_hook) ();
  else
    {
      send_to_terminal (term_invbeg);
    }
}

/* Turn off reverse video if possible. */
void
terminal_end_inverse (void)
{
  if (terminal_end_inverse_hook)
    (*terminal_end_inverse_hook) ();
  else
    {
      send_to_terminal (term_invend);
    }
}

/* Ring the terminal bell.  The bell is run visibly if it both has one and
   terminal_use_visible_bell_p is non-zero. */
void
terminal_ring_bell (void)
{
  if (terminal_ring_bell_hook)
    (*terminal_ring_bell_hook) ();
  else
    {
      if (terminal_has_visible_bell_p && terminal_use_visible_bell_p)
        send_to_terminal (visible_bell);
      else
        send_to_terminal (audible_bell);
    }
}

/* At the line START, delete COUNT lines from the terminal display. */
static void
terminal_delete_lines (int start, int count)
{
  int lines;

  /* Normalize arguments. */
  if (start < 0)
    start = 0;

  lines = screenheight - start;
  terminal_goto_xy (0, start);
  if (term_DL)
    tputs (tgoto (term_DL, 0, count), lines, output_character_function);
  else
    {
      while (count--)
        tputs (term_dl, lines, output_character_function);
    }

  fflush (stdout);
}

/* At the line START, insert COUNT lines in the terminal display. */
static void
terminal_insert_lines (int start, int count)
{
  int lines;

  /* Normalize arguments. */
  if (start < 0)
    start = 0;

  lines = screenheight - start;
  terminal_goto_xy (0, start);

  if (term_AL)
    tputs (tgoto (term_AL, 0, count), lines, output_character_function);
  else
    {
      while (count--)
        tputs (term_al, lines, output_character_function);
    }

  fflush (stdout);
}

/* Scroll an area of the terminal, starting with the region from START
   to END, AMOUNT lines.  If AMOUNT is negative, the lines are scrolled
   towards the top of the screen, else they are scrolled towards the
   bottom of the screen. */
void
terminal_scroll_terminal (int start, int end, int amount)
{
  if (!terminal_can_scroll)
    return;

  /* Any scrolling at all? */
  if (amount == 0)
    return;

  if (terminal_scroll_terminal_hook)
    (*terminal_scroll_terminal_hook) (start, end, amount);
  else
    {
      /* If we are scrolling down, delete AMOUNT lines at END.  Then insert
         AMOUNT lines at START. */
      if (amount > 0)
        {
          terminal_delete_lines (end, amount);
          terminal_insert_lines (start, amount);
        }

      /* If we are scrolling up, delete AMOUNT lines before START.  This
         actually does the upwards scroll.  Then, insert AMOUNT lines
         after the already scrolled region (i.e., END - AMOUNT). */
      if (amount < 0)
        {
          int abs_amount = -amount;
          terminal_delete_lines (start - abs_amount, abs_amount);
          terminal_insert_lines (end - abs_amount, abs_amount);
        }
    }
}

/* Re-initialize the terminal considering that the TERM/TERMCAP variable
   has changed. */
void
terminal_new_terminal (char *terminal_name)
{
  if (terminal_new_terminal_hook)
    (*terminal_new_terminal_hook) (terminal_name);
  else
    {
      terminal_initialize_terminal (terminal_name);
    }
}

/* Set the global variables SCREENWIDTH and SCREENHEIGHT. */
void
terminal_get_screen_size (void)
{
  if (terminal_get_screen_size_hook)
    (*terminal_get_screen_size_hook) ();
  else
    {
      screenwidth = screenheight = 0;

#if defined (TIOCGWINSZ)
      {
        struct winsize window_size;

        if (ioctl (fileno (stdout), TIOCGWINSZ, &window_size) == 0)
          {
            screenwidth = (int) window_size.ws_col;
            screenheight = (int) window_size.ws_row;
          }
      }
#endif                          /* TIOCGWINSZ */

      /* Environment variable COLUMNS overrides setting of "co". */
      if (screenwidth <= 0)
        {
          char *sw = getenv ("COLUMNS");

          if (sw)
            screenwidth = atoi (sw);

          if (screenwidth <= 0)
            screenwidth = tgetnum ("co");
        }

      /* Environment variable LINES overrides setting of "li". */
      if (screenheight <= 0)
        {
          char *sh = getenv ("LINES");

          if (sh)
            screenheight = atoi (sh);

          if (screenheight <= 0)
            screenheight = tgetnum ("li");
        }

      /* If all else fails, default to 80x24 terminal. */
      if (screenwidth <= 0)
        screenwidth = 80;

      if (screenheight <= 0)
        screenheight = 24;
    }
}

/* Initialize the terminal which is known as TERMINAL_NAME.  If this
   terminal doesn't have cursor addressability, `terminal_is_dumb_p'
   becomes nonzero.  The variables SCREENHEIGHT and SCREENWIDTH are set
   to the dimensions that this terminal actually has.  The variable
   TERMINAL_HAS_META_P becomes nonzero if this terminal supports a Meta
   key.  Finally, the terminal screen is cleared. */
void
terminal_initialize_terminal (char *terminal_name)
{
  char *buffer;

  terminal_is_dumb_p = 0;

  if (terminal_initialize_terminal_hook)
    {
      (*terminal_initialize_terminal_hook) (terminal_name);
      return;
    }

  term_name = terminal_name ? terminal_name : getenv ("TERM");
  if (!term_name)
    term_name = "dumb";

  if (!term_string_buffer)
    term_string_buffer = xmalloc (2048);

  if (!term_buffer)
    term_buffer = xmalloc (2048);

  buffer = term_string_buffer;

  term_clrpag = term_cr = term_clreol = NULL;

  /* HP-UX 11.x returns 0 for OK --jeff.hull@@state.co.us.  */
  if (tgetent (term_buffer, term_name) < 0)
    {
      terminal_is_dumb_p = 1;
      screenwidth = 80;
      screenheight = 24;
      term_cr = "\r";
      term_up = term_dn = audible_bell = visible_bell = NULL;
      term_ku = term_kd = term_kl = term_kr = NULL;
      term_kP = term_kN = NULL;
      term_kh = term_ke = NULL;
      term_kD = NULL;
      return;
    }

  BC = tgetstr ("pc", &buffer);
  PC = BC ? *BC : 0;

#if defined (HAVE_TERMIOS_H)
  {
    struct termios ti;
    if (tcgetattr (fileno(stdout), &ti) != -1)
      ospeed = cfgetospeed (&ti);
    else
      ospeed = B9600;
  }
#else
# if defined (TIOCGETP)
  {
    struct sgttyb sg;

    if (ioctl (fileno (stdout), TIOCGETP, &sg) != -1)
      ospeed = sg.sg_ospeed;
    else
      ospeed = B9600;
  }
# else
  ospeed = B9600;
# endif /* !TIOCGETP */
#endif

  term_cr = tgetstr ("cr", &buffer);
  term_clreol = tgetstr ("ce", &buffer);
  term_clrpag = tgetstr ("cl", &buffer);
  term_goto = tgetstr ("cm", &buffer);

  /* Find out about this terminal's scrolling capability. */
  term_AL = tgetstr ("AL", &buffer);
  term_DL = tgetstr ("DL", &buffer);
  term_al = tgetstr ("al", &buffer);
  term_dl = tgetstr ("dl", &buffer);

  terminal_can_scroll = ((term_AL || term_al) && (term_DL || term_dl));

  term_invbeg = tgetstr ("mr", &buffer);
  if (term_invbeg)
    term_invend = tgetstr ("me", &buffer);
  else
    term_invend = NULL;

  if (!term_cr)
    term_cr =  "\r";

  terminal_get_screen_size ();

  term_up = tgetstr ("up", &buffer);
  term_dn = tgetstr ("dn", &buffer);
  visible_bell = tgetstr ("vb", &buffer);
  terminal_has_visible_bell_p = (visible_bell != NULL);
  audible_bell = tgetstr ("bl", &buffer);
  if (!audible_bell)
    audible_bell = "\007";
  term_begin_use = tgetstr ("ti", &buffer);
  term_end_use = tgetstr ("te", &buffer);

  term_keypad_on = tgetstr ("ks", &buffer);
  term_keypad_off = tgetstr ("ke", &buffer);

  /* Check to see if this terminal has a meta key. */
  terminal_has_meta_p = (tgetflag ("km") || tgetflag ("MT"));
  if (terminal_has_meta_p)
    {
      term_mm = tgetstr ("mm", &buffer);
    }
  else
    {
      term_mm = NULL;
    }

  /* Attempt to find the arrow keys.  */
  term_ku = tgetstr ("ku", &buffer);
  term_kd = tgetstr ("kd", &buffer);
  term_kr = tgetstr ("kr", &buffer);
  term_kl = tgetstr ("kl", &buffer);

  term_kP = tgetstr ("kP", &buffer);
  term_kN = tgetstr ("kN", &buffer);

#if defined(INFOKEY)
  term_kh = tgetstr ("kh", &buffer);
  term_ke = tgetstr ("@@7", &buffer);
  term_ki = tgetstr ("kI", &buffer);
  term_kx = tgetstr ("kD", &buffer);
#endif /* defined(INFOKEY) */

  /* Home and end keys. */
  term_kh = tgetstr ("kh", &buffer);
  term_ke = tgetstr ("@@7", &buffer);

  term_kD = tgetstr ("kD", &buffer);

  /* If this terminal is not cursor addressable, then it is really dumb. */
  if (!term_goto)
    terminal_is_dumb_p = 1;
}

/* How to read characters from the terminal.  */

#if defined (HAVE_TERMIOS_H)
struct termios original_termios, ttybuff;
#else
#  if defined (HAVE_TERMIO_H)
/* A buffer containing the terminal mode flags upon entry to info. */
struct termio original_termio, ttybuff;
#  else /* !HAVE_TERMIO_H */
/* Buffers containing the terminal mode flags upon entry to info. */
int original_tty_flags = 0;
int original_lmode;
struct sgttyb ttybuff;

#    if defined(TIOCGETC) && defined(M_XENIX)
/* SCO 3.2v5.0.2 defines but does not support TIOCGETC.  Gak.  Maybe
   better fix would be to use Posix termios in preference.  --gildea,
   1jul99.  */
#      undef TIOCGETC
#    endif

#    if defined (TIOCGETC)
/* A buffer containing the terminal interrupt characters upon entry
   to Info. */
struct tchars original_tchars;
#    endif

#    if defined (TIOCGLTC)
/* A buffer containing the local terminal mode characters upon entry
   to Info. */
struct ltchars original_ltchars;
#    endif
#  endif /* !HAVE_TERMIO_H */
#endif /* !HAVE_TERMIOS_H */

/* Prepare to start using the terminal to read characters singly. */
void
terminal_prep_terminal (void)
{
  int tty;

  if (terminal_prep_terminal_hook)
    {
      (*terminal_prep_terminal_hook) ();
      return;
    }

  terminal_begin_using_terminal ();

  tty = fileno (stdin);

#if defined (HAVE_TERMIOS_H)
  tcgetattr (tty, &original_termios);
  tcgetattr (tty, &ttybuff);
#else
#  if defined (HAVE_TERMIO_H)
  ioctl (tty, TCGETA, &original_termio);
  ioctl (tty, TCGETA, &ttybuff);
#  endif
#endif

#if defined (HAVE_TERMIOS_H) || defined (HAVE_TERMIO_H)
  ttybuff.c_iflag &= (~ISTRIP & ~INLCR & ~IGNCR & ~ICRNL & ~IXON);
/* These output flags are not part of POSIX, so only use them if they
   are defined.  */
#ifdef ONLCR
  ttybuff.c_oflag &= ~ONLCR ;
#endif
#ifdef OCRNL
  ttybuff.c_oflag &= ~OCRNL;
#endif
  ttybuff.c_lflag &= (~ICANON & ~ECHO);

  ttybuff.c_cc[VMIN] = 1;
  ttybuff.c_cc[VTIME] = 0;

  if (ttybuff.c_cc[VINTR] == '\177')
    ttybuff.c_cc[VINTR] = -1;

  if (ttybuff.c_cc[VQUIT] == '\177')
    ttybuff.c_cc[VQUIT] = -1;

#ifdef VLNEXT
  if (ttybuff.c_cc[VLNEXT] == '\026')
    ttybuff.c_cc[VLNEXT] = -1;
#endif /* VLNEXT */
#endif /* TERMIOS or TERMIO */

/* cf. emacs/src/sysdep.c for being sure output is on. */
#if defined (HAVE_TERMIOS_H)
  tcsetattr (tty, TCSANOW, &ttybuff);
#else
#  if defined (HAVE_TERMIO_H)
  ioctl (tty, TCSETA, &ttybuff);
#  endif
#endif

#if !defined (HAVE_TERMIOS_H) && !defined (HAVE_TERMIO_H)
  ioctl (tty, TIOCGETP, &ttybuff);

  if (!original_tty_flags)
    original_tty_flags = ttybuff.sg_flags;

  /* Make this terminal pass 8 bits around while we are using it. */
#  if defined (PASS8)
  ttybuff.sg_flags |= PASS8;
#  endif /* PASS8 */

#  if defined (TIOCLGET) && defined (LPASS8)
  {
    int flags;
    ioctl (tty, TIOCLGET, &flags);
    original_lmode = flags;
    flags |= LPASS8;
    ioctl (tty, TIOCLSET, &flags);
  }
#  endif /* TIOCLGET && LPASS8 */

#  if defined (TIOCGETC)
  {
    struct tchars temp;

    ioctl (tty, TIOCGETC, &original_tchars);
    temp = original_tchars;

    /* C-s and C-q. */
    temp.t_startc = temp.t_stopc = -1;

    /* Often set to C-d. */
    temp.t_eofc = -1;

    /* If the a quit or interrupt character conflicts with one of our
       commands, then make it go away. */
    if (temp.t_intrc == '\177')
      temp.t_intrc = -1;

    if (temp.t_quitc == '\177')
      temp.t_quitc = -1;

    ioctl (tty, TIOCSETC, &temp);
  }
#  endif /* TIOCGETC */

#  if defined (TIOCGLTC)
  {
    struct ltchars temp;

    ioctl (tty, TIOCGLTC, &original_ltchars);
    temp = original_ltchars;

    /* Make the interrupt keys go away.  Just enough to make people happy. */
    temp.t_lnextc = -1;         /* C-v. */
    temp.t_dsuspc = -1;         /* C-y. */
    temp.t_flushc = -1;         /* C-o. */
    ioctl (tty, TIOCSLTC, &temp);
  }
#  endif /* TIOCGLTC */

  ttybuff.sg_flags &= ~ECHO;
  ttybuff.sg_flags |= CBREAK;
  ioctl (tty, TIOCSETN, &ttybuff);
#endif /* !HAVE_TERMIOS_H && !HAVE_TERMIO_H */
}

/* Restore the tty settings back to what they were before we started using
   this terminal. */
void
terminal_unprep_terminal (void)
{
  int tty;

  if (terminal_unprep_terminal_hook)
    {
      (*terminal_unprep_terminal_hook) ();
      return;
    }

  tty = fileno (stdin);

#if defined (HAVE_TERMIOS_H)
  tcsetattr (tty, TCSANOW, &original_termios);
#else
#  if defined (HAVE_TERMIO_H)
  ioctl (tty, TCSETA, &original_termio);
#  else /* !HAVE_TERMIO_H */
  ioctl (tty, TIOCGETP, &ttybuff);
  ttybuff.sg_flags = original_tty_flags;
  ioctl (tty, TIOCSETN, &ttybuff);

#  if defined (TIOCGETC)
  ioctl (tty, TIOCSETC, &original_tchars);
#  endif /* TIOCGETC */

#  if defined (TIOCGLTC)
  ioctl (tty, TIOCSLTC, &original_ltchars);
#  endif /* TIOCGLTC */

#  if defined (TIOCLGET) && defined (LPASS8)
  ioctl (tty, TIOCLSET, &original_lmode);
#  endif /* TIOCLGET && LPASS8 */

#  endif /* !HAVE_TERMIO_H */
#endif /* !HAVE_TERMIOS_H */
  terminal_end_using_terminal ();
}

#ifdef __MSDOS__
# include "pcterm.c"
#endif
@


1.7
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.3 2004/04/11 17:56:46 karl Exp $
a744 3
  /* linux kernel 2.2.x needs a TCOFF followed by a TCOON to turn output
     back on if the user presses ^S at the very beginning; just a TCOON
     doesn't work.  --Kevin Ryde <user42@@zip.com.au>, 16jun2000.  */
a745 4
#  ifdef TCOON
  tcflow (tty, TCOOFF);
  tcflow (tty, TCOON);
#  endif
a748 3
#    ifdef TCXONC
  ioctl (tty, TCXONC, 1);
#    endif
@


1.6
log
@brain-dead cvs conflict merge
@
text
@d1 2
a2 2
/* terminal.c -- How to handle the physical terminal for Info.
   $Id: terminal.c,v 1.23 2001/11/16 23:16:04 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98, 99, 2001
   Free Software Foundation, Inc.
d21 1
a21 1
   Written by Brian Fox (bfox@@ai.mit.edu). */
a105 3
/* The string to write to turn off the meta key, if this term has one. */
static char *term_mo;

d116 1
a116 2
output_character_function (c)
     int c;
d131 1
a131 1
terminal_begin_using_terminal ()
d133 1
a133 1
  RETSIGTYPE (*sigsave) ();
d162 1
a162 1
terminal_end_using_terminal ()
d164 1
a164 1
  RETSIGTYPE (*sigsave) ();
d229 1
a229 2
terminal_goto_xy (x, y)
     int x, y;
d242 1
a242 2
terminal_put_text (string)
     char *string;
d254 1
a254 3
terminal_write_chars (string, nchars)
     char *string;
     int nchars;
d267 1
a267 1
terminal_clear_to_eol ()
d279 1
a279 1
terminal_clear_screen ()
d291 1
a291 1
terminal_up_line ()
d303 1
a303 1
terminal_down_line ()
d315 1
a315 1
terminal_begin_inverse ()
d327 1
a327 1
terminal_end_inverse ()
d340 1
a340 1
terminal_ring_bell ()
d355 1
a355 2
terminal_delete_lines (start, count)
     int start, count;
d378 1
a378 2
terminal_insert_lines (start, count)
     int start, count;
d405 1
a405 2
terminal_scroll_terminal (start, end, amount)
     int start, end, amount;
d441 1
a441 2
terminal_new_terminal (terminal_name)
     char *terminal_name;
d453 1
a453 1
terminal_get_screen_size ()
d513 1
a513 2
terminal_initialize_terminal (terminal_name)
     char *terminal_name;
a621 1
      term_mo = tgetstr ("mo", &buffer);
a625 1
      term_mo = NULL;
d692 1
a692 1
terminal_prep_terminal ()
d832 1
a832 1
terminal_unprep_terminal ()
@


1.5
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.19 1999/09/20 12:28:54 karl Exp $
d4 1
a4 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98, 99
a28 1
#include <sys/ioctl.h> /* TIOCGWINSZ on LynxOS, at least */
d219 11
a229 6
char *term_ku = (char *)NULL;
char *term_kd = (char *)NULL;
char *term_kr = (char *)NULL;
char *term_kl = (char *)NULL;
char *term_kP = (char *)NULL;   /* page-up */
char *term_kN = (char *)NULL;   /* page-down */
d562 2
d610 1
a610 1
    term_invend = (char *)NULL;
d620 1
a620 1
  terminal_has_visible_bell_p = (visible_bell != (char *)NULL);
d639 2
a640 2
      term_mm = (char *)NULL;
      term_mo = (char *)NULL;
d652 13
d758 1
d760 3
d764 4
d771 3
@


1.4
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.9 1998/02/22 00:05:15 karl Exp $
d4 1
a4 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98
d29 1
d80 4
a83 3
   used to float within it. */
static char *term_buffer = (char *)NULL;
static char *term_string_buffer = (char *)NULL;
a150 4
  /* Without this fflush and sleep, running info in a shelltool or
     cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are
     not restored properly.
     From: strube@@physik3.gwdg.de (Hans Werner Strube).  */
d152 6
a157 1
  sleep (1);
d183 3
a185 1
  sleep (1);
d524 1
a524 1
  char *term, *buffer;
d534 3
a536 1
  term = terminal_name ? terminal_name : getenv ("TERM");
d539 1
a539 1
    term_string_buffer = (char *)xmalloc (2048);
d542 1
a542 1
    term_buffer = (char *)xmalloc (2048);
d546 1
a546 1
  term_clrpag = term_cr = term_clreol = (char *)NULL;
d548 2
a549 4
  if (!term)
    term = "dumb";

  if (tgetent (term_buffer, term) <= 0)
d555 3
a557 3
      term_up = term_dn = audible_bell = visible_bell = (char *)NULL;
      term_ku = term_kd = term_kl = term_kr = (char *)NULL;
      term_kP = term_kN = (char *)NULL;
d564 10
a573 1
#if defined (TIOCGETP)
d582 1
a582 1
#else
d584 2
a585 1
#endif                          /* !TIOCGETP */
d592 1
a592 1
  /* Find out about this terminals scrolling capability. */
d651 1
a651 17
/* **************************************************************** */
/*                                                                  */
/*               How to Read Characters From the Terminal           */
/*                                                                  */
/* **************************************************************** */

#if defined (TIOCGETC)
/* A buffer containing the terminal interrupt characters upon entry
   to Info. */
struct tchars original_tchars;
#endif

#if defined (TIOCGLTC)
/* A buffer containing the local terminal mode characters upon entry
   to Info. */
struct ltchars original_ltchars;
#endif
d664 19
d856 3
@


1.3
log
@fix conflicts
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.8 1997/07/29 21:42:05 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97 Free Software
   Foundation, Inc.
d144 1
d146 2
d155 2
d158 1
d174 1
d176 2
d181 2
d184 1
@


1.2
log
@Compile
@
text
@d1 2
a2 1
/* terminal.c -- How to handle the physical terminal for Info. */
d4 2
a5 7
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   This file has appeared in prior works by the Free Software Foundation;
   thus it carries copyright dates from 1988 through 1993.

   Copyright (C) 1988, 89, 90, 91, 92, 93, 96 Free Software Foundation, Inc.
d23 1
a23 2
#include <stdio.h>
#include <sys/types.h>
d27 2
a28 1
extern void *xmalloc (), *xrealloc ();
d31 9
d41 4
a46 1
extern char *getenv ();
d48 2
d73 3
a75 3
/*								    */
/*			Terminal and Termcap			    */
/*								    */
a77 9
/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.
   Unfortunately, PC is a global variable used by the termcap library. */
#undef PC

/* TERMCAP requires these variables, whether we access them or not. */
char PC;
char *BC, *UP;
short ospeed;

d88 2
d114 4
a117 1
static void
d122 1
d132 1
a132 1
/* Tell the terminal that we will be doing cursor addressable motion. */
d136 9
d146 7
d155 2
a156 2
/* Tell the terminal that we will not be doing any more cursor addressable
   motion. */
d160 9
d170 3
d176 3
a178 3
/*								    */
/*		     Necessary Terminal Functions		    */
/*								    */
d207 2
d220 1
a220 1
	tputs (tgoto (term_goto, x, y), 1, output_character_function);
d248 1
a248 1
	fwrite (string, 1, nchars, stdout);
d334 1
a334 1
	send_to_terminal (visible_bell);
d336 1
a336 1
	send_to_terminal (audible_bell);
d358 1
a358 1
	tputs (term_dl, lines, output_character_function);
d383 1
a383 1
	tputs (term_al, lines, output_character_function);
d409 1
a409 1
	 AMOUNT lines at START. */
d411 4
a414 4
	{
	  terminal_delete_lines (end, amount);
	  terminal_insert_lines (start, amount);
	}
d417 2
a418 2
	 actually does the upwards scroll.  Then, insert AMOUNT lines
	 after the already scrolled region (i.e., END - AMOUNT). */
d420 5
a424 5
	{
	  int abs_amount = -amount;
	  terminal_delete_lines (start - abs_amount, abs_amount);
	  terminal_insert_lines (end - abs_amount, abs_amount);
	}
d454 1
a454 1
	struct winsize window_size;
d456 5
a460 5
	if (ioctl (fileno (stdout), TIOCGWINSZ, &window_size) == 0)
	  {
	    screenwidth = (int) window_size.ws_col;
	    screenheight = (int) window_size.ws_row;
	  }
d462 1
a462 1
#endif				/* TIOCGWINSZ */
d466 2
a467 2
	{
	  char *sw = getenv ("COLUMNS");
d469 2
a470 2
	  if (sw)
	    screenwidth = atoi (sw);
d472 3
a474 3
	  if (screenwidth <= 0)
	    screenwidth = tgetnum ("co");
	}
d478 2
a479 2
	{
	  char *sh = getenv ("LINES");
d481 2
a482 2
	  if (sh)
	    screenheight = atoi (sh);
d484 3
a486 3
	  if (screenheight <= 0)
	    screenheight = tgetnum ("li");
	}
d490 1
a490 1
	screenwidth = 80;
d493 1
a493 1
	screenheight = 24;
d497 6
a502 6
/* Initialize the terminal which is known as TERMINAL_NAME.  If this terminal
   doesn't have cursor addressability, TERMINAL_IS_DUMB_P becomes non-zero.
   The variables SCREENHEIGHT and SCREENWIDTH are set to the dimensions that
   this terminal actually has.  The variable TERMINAL_HAS_META_P becomes non-
   zero if this terminal supports a Meta key.  Finally, the terminal screen is
   cleared. */
d540 1
d558 1
a558 1
#endif				/* !TIOCGETP */
d594 3
d616 3
a621 2

  terminal_begin_using_terminal ();
d625 3
a627 3
/*								    */
/*		 How to Read Characters From the Terminal	    */
/*								    */
d668 2
d684 7
a690 4
#if defined(OCRNL)
  ttybuff.c_oflag &= (~ONLCR & ~OCRNL);
#else
  ttybuff.c_oflag &= ~ONLCR;
d702 6
a707 1
#endif
d771 3
a773 3
    temp.t_lnextc = -1;		/* C-v. */
    temp.t_dsuspc = -1;		/* C-y. */
    temp.t_flushc = -1;		/* C-o. */
@


1.1
log
@Initial revision
@
text
@d9 1
a9 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993 Free Software
   Foundation, Inc.
d168 4
a171 1
char *term_ku, *term_kd, *term_kr, *term_kl;
d600 4
a603 1
#if defined (HAVE_TERMIO_H)
d606 1
a606 1
#else /* !HAVE_TERMIO_H */
d611 2
a612 1
#endif /* !HAVE_TERMIO_H */
d628 5
a632 1
#if defined (HAVE_TERMIO_H)
d635 4
d640 1
d642 3
d655 1
d657 4
d662 2
d665 1
a665 2
#else /* !HAVE_TERMIO_H */

d672 1
a672 1
#if defined (PASS8)
d674 1
a674 1
#endif /* PASS8 */
d676 1
a676 1
#if defined (TIOCLGET) && defined (LPASS8)
d684 1
a684 1
#endif /* TIOCLGET && LPASS8 */
d686 1
a686 1
#if defined (TIOCGETC)
d709 1
a709 1
#endif /* TIOCGETC */
d711 1
a711 1
#if defined (TIOCGLTC)
d724 1
a724 1
#endif /* TIOCGLTC */
d729 1
a729 1
#endif /* !HAVE_TERMIO_H */
d747 4
a750 1
#if defined (HAVE_TERMIO_H)
d752 1
a752 1
#else /* !HAVE_TERMIO_H */
d757 1
a757 1
#if defined (TIOCGETC)
d759 1
a759 1
#endif /* TIOCGETC */
d761 1
a761 1
#if defined (TIOCGLTC)
d763 1
a763 1
#endif /* TIOCGLTC */
d765 1
a765 1
#if defined (TIOCLGET) && defined (LPASS8)
d767 1
a767 1
#endif /* TIOCLGET && LPASS8 */
d769 2
a770 1
#endif /* !HAVE_TERMIO_H */
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of texinfo-3.9.
@
text
@d9 2
a10 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96 Free Software Foundation, Inc.
d169 1
a169 4
char *term_ku = (char *)NULL;
char *term_kd = (char *)NULL;
char *term_kr = (char *)NULL;
char *term_kl = (char *)NULL;
d598 1
a598 4
#if defined (HAVE_TERMIOS_H)
struct termios original_termios, ttybuff;
#else
#  if defined (HAVE_TERMIO_H)
d601 1
a601 1
#  else /* !HAVE_TERMIO_H */
d606 1
a606 2
#  endif /* !HAVE_TERMIO_H */
#endif /* !HAVE_TERMIOS_H */
d622 1
a622 5
#if defined (HAVE_TERMIOS_H)
  tcgetattr (tty, &original_termios);
  tcgetattr (tty, &ttybuff);
#else
#  if defined (HAVE_TERMIO_H)
a624 4
#  endif
#endif

#if defined (HAVE_TERMIOS_H) || defined (HAVE_TERMIO_H)
a636 1
#endif
a637 4
#if defined (HAVE_TERMIOS_H)
  tcsetattr (tty, TCSANOW, &ttybuff);
#else
#  if defined (HAVE_TERMIO_H)
a638 2
#  endif
#endif
d640 2
a641 1
#if !defined (HAVE_TERMIOS_H) && !defined (HAVE_TERMIO_H)
d648 1
a648 1
#  if defined (PASS8)
d650 1
a650 1
#  endif /* PASS8 */
d652 1
a652 1
#  if defined (TIOCLGET) && defined (LPASS8)
d660 1
a660 1
#  endif /* TIOCLGET && LPASS8 */
d662 1
a662 1
#  if defined (TIOCGETC)
d685 1
a685 1
#  endif /* TIOCGETC */
d687 1
a687 1
#  if defined (TIOCGLTC)
d700 1
a700 1
#  endif /* TIOCGLTC */
d705 1
a705 1
#endif /* !HAVE_TERMIOS_H && !HAVE_TERMIO_H */
d723 1
a723 4
#if defined (HAVE_TERMIOS_H)
  tcsetattr (tty, TCSANOW, &original_termios);
#else
#  if defined (HAVE_TERMIO_H)
d725 1
a725 1
#  else /* !HAVE_TERMIO_H */
d730 1
a730 1
#  if defined (TIOCGETC)
d732 1
a732 1
#  endif /* TIOCGETC */
d734 1
a734 1
#  if defined (TIOCGLTC)
d736 1
a736 1
#  endif /* TIOCGLTC */
d738 1
a738 1
#  if defined (TIOCLGET) && defined (LPASS8)
d740 1
a740 1
#  endif /* TIOCLGET && LPASS8 */
d742 1
a742 2
#  endif /* !HAVE_TERMIO_H */
#endif /* !HAVE_TERMIOS_H */
@


1.1.1.3
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* terminal.c -- How to handle the physical terminal for Info.
   $Id: terminal.c,v 1.8 1997/07/29 21:42:05 karl Exp $
d3 7
a9 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97 Free Software
   Foundation, Inc.
d27 2
a28 1
#include "info.h"
d32 1
a32 2
#include <sys/types.h>
#include <signal.h>
a34 9
#ifdef HAVE_NCURSES_TERMCAP_H
#include <ncurses/termcap.h>
#else
#ifdef HAVE_TERMCAP_H
#include <termcap.h>
#else
/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.
   Unfortunately, PC is a global variable used by the termcap library. */
#undef PC
a35 4
/* Termcap requires these variables, whether we access them or not. */
char *BC, *UP;
char PC;      /* Pad character */
short ospeed; /* Terminal output baud rate */
d38 1
a39 2
#endif /* not HAVE_TERMCAP_H */
#endif /* not HAVE_NCURSES_TERMCAP_H */
d63 3
a65 3
/*                                                                  */
/*                      Terminal and Termcap                        */
/*                                                                  */
d68 9
a86 2
static char *term_keypad_on, *term_keypad_off;

d111 1
a111 4
/* Although I can't find any documentation that says this is supposed to
   return its argument, all the code I've looked at (termutils, less)
   does so, so fine.  */
static int
a115 1
  return c;
d125 1
a125 1
/* Tell the terminal that we will be doing cursor addressable motion.  */
a128 9
  RETSIGTYPE (*sigsave) ();

  if (term_keypad_on)
      send_to_terminal (term_keypad_on);
  
  if (!term_begin_use || !*term_begin_use)
    return;

  sigsave = signal (SIGWINCH, SIG_IGN); 
a129 7
  /* Without this fflush and sleep, running info in a shelltool or
     cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are
     not restored properly.
     From: strube@@physik3.gwdg.de (Hans Werner Strube).  */
  fflush (stdout);
  sleep (1);
  signal (SIGWINCH, sigsave);
d132 2
a133 2
/* Tell the terminal that we will not be doing any more cursor
   addressable motion. */
a136 9
  RETSIGTYPE (*sigsave) ();

  if (term_keypad_off)
      send_to_terminal (term_keypad_off);
  
  if (!term_end_use || !*term_end_use)
    return;

  sigsave = signal (SIGWINCH, SIG_IGN);
a137 3
  fflush (stdout);
  sleep (1);
  signal (SIGWINCH, sigsave);
d141 3
a143 3
/*                                                                  */
/*                   Necessary Terminal Functions                   */
/*                                                                  */
a171 2
char *term_kP = (char *)NULL;   /* page-up */
char *term_kN = (char *)NULL;   /* page-down */
d183 1
a183 1
        tputs (tgoto (term_goto, x, y), 1, output_character_function);
d211 1
a211 1
        fwrite (string, 1, nchars, stdout);
d297 1
a297 1
        send_to_terminal (visible_bell);
d299 1
a299 1
        send_to_terminal (audible_bell);
d321 1
a321 1
        tputs (term_dl, lines, output_character_function);
d346 1
a346 1
        tputs (term_al, lines, output_character_function);
d372 1
a372 1
         AMOUNT lines at START. */
d374 4
a377 4
        {
          terminal_delete_lines (end, amount);
          terminal_insert_lines (start, amount);
        }
d380 2
a381 2
         actually does the upwards scroll.  Then, insert AMOUNT lines
         after the already scrolled region (i.e., END - AMOUNT). */
d383 5
a387 5
        {
          int abs_amount = -amount;
          terminal_delete_lines (start - abs_amount, abs_amount);
          terminal_insert_lines (end - abs_amount, abs_amount);
        }
d417 1
a417 1
        struct winsize window_size;
d419 5
a423 5
        if (ioctl (fileno (stdout), TIOCGWINSZ, &window_size) == 0)
          {
            screenwidth = (int) window_size.ws_col;
            screenheight = (int) window_size.ws_row;
          }
d425 1
a425 1
#endif                          /* TIOCGWINSZ */
d429 2
a430 2
        {
          char *sw = getenv ("COLUMNS");
d432 2
a433 2
          if (sw)
            screenwidth = atoi (sw);
d435 3
a437 3
          if (screenwidth <= 0)
            screenwidth = tgetnum ("co");
        }
d441 2
a442 2
        {
          char *sh = getenv ("LINES");
d444 2
a445 2
          if (sh)
            screenheight = atoi (sh);
d447 3
a449 3
          if (screenheight <= 0)
            screenheight = tgetnum ("li");
        }
d453 1
a453 1
        screenwidth = 80;
d456 1
a456 1
        screenheight = 24;
d460 6
a465 6
/* Initialize the terminal which is known as TERMINAL_NAME.  If this
   terminal doesn't have cursor addressability, `terminal_is_dumb_p'
   becomes nonzero.  The variables SCREENHEIGHT and SCREENWIDTH are set
   to the dimensions that this terminal actually has.  The variable
   TERMINAL_HAS_META_P becomes nonzero if this terminal supports a Meta
   key.  Finally, the terminal screen is cleared. */
a502 1
      term_kP = term_kN = (char *)NULL;
d520 1
a520 1
#endif                          /* !TIOCGETP */
a555 3
  term_keypad_on = tgetstr ("ks", &buffer);
  term_keypad_off = tgetstr ("ke", &buffer);

a574 3
  term_kP = tgetstr ("kP", &buffer);
  term_kN = tgetstr ("kN", &buffer);

d578 2
d583 3
a585 3
/*                                                                  */
/*               How to Read Characters From the Terminal           */
/*                                                                  */
a625 2
  terminal_begin_using_terminal ();

d640 1
a640 8
/* These output flags are not part of POSIX, so only use them if they
   are defined.  */
#ifdef ONLCR
  ttybuff.c_oflag &= ~ONLCR ;
#endif
#ifdef OCRNL
  ttybuff.c_oflag &= ~OCRNL;
#endif
d651 1
a651 6

#ifdef VLNEXT
  if (ttybuff.c_cc[VLNEXT] == '\026')
    ttybuff.c_cc[VLNEXT] = -1;
#endif /* VLNEXT */
#endif /* TERMIOS or TERMIO */
d715 3
a717 3
    temp.t_lnextc = -1;         /* C-v. */
    temp.t_dsuspc = -1;         /* C-y. */
    temp.t_flushc = -1;         /* C-o. */
@


1.1.1.4
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.9 1998/02/22 00:05:15 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98
   Free Software Foundation, Inc.
a143 1
#ifdef SIGWINCH
a144 2
#endif

a151 2

#ifdef SIGWINCH
a152 1
#endif
a167 1
#ifdef SIGWINCH
a168 2
#endif

a171 2

#ifdef SIGWINCH
a172 1
#endif
@


1.1.1.5
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.19 1999/09/20 12:28:54 karl Exp $
d4 1
a4 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98, 99
a28 1
#include <sys/ioctl.h> /* TIOCGWINSZ on LynxOS, at least */
d79 3
a81 4
   used to float within it.  And the name of the terminal.  */
static char *term_buffer = NULL;
static char *term_string_buffer = NULL;
static char *term_name;
d149 4
d154 1
a154 6
  if (STREQ (term_name, "sun-cmd"))
    /* Without this fflush and sleep, running info in a shelltool or
       cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are
       not restored properly.
       From: strube@@physik3.gwdg.de (Hans Werner Strube).  */
    sleep (1);
d180 1
a180 3
  if (STREQ (term_name, "sun-cmd"))
    /* See comments at other sleep.  */
    sleep (1);
d519 1
a519 1
  char *buffer;
d529 1
a529 3
  term_name = terminal_name ? terminal_name : getenv ("TERM");
  if (!term_name)
    term_name = "dumb";
d532 1
a532 1
    term_string_buffer = xmalloc (2048);
d535 1
a535 1
    term_buffer = xmalloc (2048);
d539 1
a539 1
  term_clrpag = term_cr = term_clreol = NULL;
d541 4
a544 2
  /* HP-UX 11.x returns 0 for OK --jeff.hull@@state.co.us.  */
  if (tgetent (term_buffer, term_name) < 0)
d550 3
a552 3
      term_up = term_dn = audible_bell = visible_bell = NULL;
      term_ku = term_kd = term_kl = term_kr = NULL;
      term_kP = term_kN = NULL;
d559 1
a559 10
#if defined (HAVE_TERMIOS_H)
  {
    struct termios ti;
    if (tcgetattr (fileno(stdout), &ti) != -1)
      ospeed = cfgetospeed (&ti);
    else
      ospeed = B9600;
  }
#else
# if defined (TIOCGETP)
d568 1
a568 1
# else
d570 1
a570 2
# endif /* !TIOCGETP */
#endif
d577 1
a577 1
  /* Find out about this terminal's scrolling capability. */
d636 17
a652 1
/* How to read characters from the terminal.  */
a664 19

#    if defined(TIOCGETC) && defined(M_XENIX)
/* SCO 3.2v5.0.2 defines but does not support TIOCGETC.  Gak.  Maybe
   better fix would be to use Posix termios in preference.  --gildea,
   1jul99.  */
#      undef TIOCGETC
#    endif

#    if defined (TIOCGETC)
/* A buffer containing the terminal interrupt characters upon entry
   to Info. */
struct tchars original_tchars;
#    endif

#    if defined (TIOCGLTC)
/* A buffer containing the local terminal mode characters upon entry
   to Info. */
struct ltchars original_ltchars;
#    endif
a837 3
#ifdef __MSDOS__
# include "pcterm.c"
#endif
@


1.1.1.6
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: terminal.c,v 1.23 2001/11/16 23:16:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98, 99, 2001
d29 1
d220 6
a225 11
char *term_ku = NULL;
char *term_kd = NULL;
char *term_kr = NULL;
char *term_kl = NULL;
char *term_kP = NULL;   /* page-up */
char *term_kN = NULL;   /* page-down */
char *term_kh = NULL;	/* home */
char *term_ke = NULL;	/* end */
char *term_kD = NULL;	/* delete */
char *term_ki = NULL;	/* ins */
char *term_kx = NULL;	/* del */
a557 2
      term_kh = term_ke = NULL;
      term_kD = NULL;
d604 1
a604 1
    term_invend = NULL;
d614 1
a614 1
  terminal_has_visible_bell_p = (visible_bell != NULL);
d633 2
a634 2
      term_mm = NULL;
      term_mo = NULL;
a645 13
#if defined(INFOKEY)
  term_kh = tgetstr ("kh", &buffer);
  term_ke = tgetstr ("@@7", &buffer);
  term_ki = tgetstr ("kI", &buffer);
  term_kx = tgetstr ("kD", &buffer);
#endif /* defined(INFOKEY) */

  /* Home and end keys. */
  term_kh = tgetstr ("kh", &buffer);
  term_ke = tgetstr ("@@7", &buffer);

  term_kD = tgetstr ("kD", &buffer);

a738 1
/* cf. emacs/src/sysdep.c for being sure output is on. */
a739 3
  /* linux kernel 2.2.x needs a TCOFF followed by a TCOON to turn output
     back on if the user presses ^S at the very beginning; just a TCOON
     doesn't work.  --Kevin Ryde <user42@@zip.com.au>, 16jun2000.  */
a740 4
#  ifdef TCOON
  tcflow (tty, TCOOFF);
  tcflow (tty, TCOON);
#  endif
a743 3
#    ifdef TCXONC
  ioctl (tty, TCXONC, 1);
#    endif
@


1.1.1.7
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* terminal.c -- how to handle the physical terminal for Info.
   $Id: terminal.c,v 1.3 2004/04/11 17:56:46 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1996, 1997, 1998,
   1999, 2001, 2002, 2004 Free Software Foundation, Inc.
d21 1
a21 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
d106 3
d119 2
a120 1
output_character_function (int c)
d135 1
a135 1
terminal_begin_using_terminal (void)
d137 1
a137 1
  RETSIGTYPE (*sigsave) (int signum);
d166 1
a166 1
terminal_end_using_terminal (void)
d168 1
a168 1
  RETSIGTYPE (*sigsave) (int signum);
d233 2
a234 1
terminal_goto_xy (int x, int y)
d247 2
a248 1
terminal_put_text (char *string)
d260 3
a262 1
terminal_write_chars (char *string, int nchars)
d275 1
a275 1
terminal_clear_to_eol (void)
d287 1
a287 1
terminal_clear_screen (void)
d299 1
a299 1
terminal_up_line (void)
d311 1
a311 1
terminal_down_line (void)
d323 1
a323 1
terminal_begin_inverse (void)
d335 1
a335 1
terminal_end_inverse (void)
d348 1
a348 1
terminal_ring_bell (void)
d363 2
a364 1
terminal_delete_lines (int start, int count)
d387 2
a388 1
terminal_insert_lines (int start, int count)
d415 2
a416 1
terminal_scroll_terminal (int start, int end, int amount)
d452 2
a453 1
terminal_new_terminal (char *terminal_name)
d465 1
a465 1
terminal_get_screen_size (void)
d525 2
a526 1
terminal_initialize_terminal (char *terminal_name)
d635 1
d640 1
d707 1
a707 1
terminal_prep_terminal (void)
d847 1
a847 1
terminal_unprep_terminal (void)
@


