head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.44
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.42
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.38
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.40
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.32
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.36
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.34
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.30
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	TEXINFO_4_8:1.1.1.6
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	TEXINFO_4_2:1.1.1.5
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.5
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.4
	OPENBSD_2_4:1.1.1.3.0.6
	OPENBSD_2_4_BASE:1.1.1.3
	OPENBSD_2_3:1.1.1.3.0.4
	OPENBSD_2_3_BASE:1.1.1.3
	OPENBSD_2_2:1.1.1.3.0.2
	OPENBSD_2_2_BASE:1.1.1.3
	TEXINFO_3_11:1.1.1.3
	OPENBSD_2_1:1.1.1.2.0.2
	OPENBSD_2_1_BASE:1.1.1.2
	TEXINFO_3_9:1.1.1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.10;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.12.15.21.39.09;	author downsj;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.08.01.22.00.45;	author kstailey;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.01.11.16.32.29;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2000.02.09.01.25.02;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.07.17.16.03.45;	author espie;	state Exp;
branches;
next	;


desc
@@


1.4
log
@conflict resolution
@
text
@/* tilde.c -- tilde expansion code (~/foo := $HOME/foo).
   $Id: tilde.c,v 1.3 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1996, 1998, 1999,
   2002, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

/* Include config.h before doing alloca.  */
#include "info.h"
#include "tilde.h"

#if defined (TEST) || defined (STATIC_MALLOC)
static void *xmalloc (), *xrealloc ();
#endif /* TEST || STATIC_MALLOC */

/* The default value of tilde_additional_prefixes.  This is set to
   whitespace preceding a tilde so that simple programs which do not
   perform any word separation get desired behaviour. */
static char *default_prefixes[] =
  { " ~", "\t~", (char *)NULL };

/* The default value of tilde_additional_suffixes.  This is set to
   whitespace or newline so that simple programs which do not
   perform any word separation get desired behaviour. */
static char *default_suffixes[] =
  { " ", "\n", (char *)NULL };

/* If non-null, this contains the address of a function to call if the
   standard meaning for expanding a tilde fails.  The function is called
   with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
   which is the expansion, or a NULL pointer if there is no expansion. */
CFunction *tilde_expansion_failure_hook = (CFunction *)NULL;

/* When non-null, this is a NULL terminated array of strings which
   are duplicates for a tilde prefix.  Bash uses this to expand
   `=~' and `:~'. */
char **tilde_additional_prefixes = default_prefixes;

/* When non-null, this is a NULL terminated array of strings which match
   the end of a username, instead of just "/".  Bash sets this to
   `:' and `=~'. */
char **tilde_additional_suffixes = default_suffixes;

/* Find the start of a tilde expansion in STRING, and return the index of
   the tilde which starts the expansion.  Place the length of the text
   which identified this tilde starter in LEN, excluding the tilde itself. */
static int
tilde_find_prefix (char *string, int *len)
{
  register int i, j, string_len;
  register char **prefixes = tilde_additional_prefixes;

  string_len = strlen (string);
  *len = 0;

  if (!*string || *string == '~')
    return (0);

  if (prefixes)
    {
      for (i = 0; i < string_len; i++)
        {
          for (j = 0; prefixes[j]; j++)
            {
              if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
                {
                  *len = strlen (prefixes[j]) - 1;
                  return (i + *len);
                }
            }
        }
    }
  return (string_len);
}

/* Find the end of a tilde expansion in STRING, and return the index of
   the character which ends the tilde definition.  */
static int
tilde_find_suffix (char *string)
{
  register int i, j, string_len;
  register char **suffixes = tilde_additional_suffixes;

  string_len = strlen (string);

  for (i = 0; i < string_len; i++)
    {
      if (IS_SLASH (string[i]) || !string[i])
        break;

      for (j = 0; suffixes && suffixes[j]; j++)
        {
          if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
            return (i);
        }
    }
  return (i);
}

/* Return a new string which is the result of tilde expanding STRING. */
char *
tilde_expand (char *string)
{
  char *result;
  int result_size, result_index;

  result_size = result_index = 0;
  result = (char *)NULL;

  /* Scan through STRING expanding tildes as we come to them. */
  while (1)
    {
      register int start, end;
      char *tilde_word, *expansion;
      int len;

      /* Make START point to the tilde which starts the expansion. */
      start = tilde_find_prefix (string, &len);

      /* Copy the skipped text into the result. */
      if ((result_index + start + 1) > result_size)
        result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));

      strncpy (result + result_index, string, start);
      result_index += start;

      /* Advance STRING to the starting tilde. */
      string += start;

      /* Make END be the index of one after the last character of the
         username. */
      end = tilde_find_suffix (string);

      /* If both START and END are zero, we are all done. */
      if (!start && !end)
        break;

      /* Expand the entire tilde word, and copy it into RESULT. */
      tilde_word = (char *)xmalloc (1 + end);
      strncpy (tilde_word, string, end);
      tilde_word[end] = '\0';
      string += end;

      expansion = tilde_expand_word (tilde_word);
      free (tilde_word);

      len = strlen (expansion);
      if ((result_index + len + 1) > result_size)
        result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

      strcpy (result + result_index, expansion);
      result_index += len;
      free (expansion);
    }

  result[result_index] = '\0';

  return (result);
}

/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
   tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
char *
tilde_expand_word (char *filename)
{
  char *dirname = filename ? xstrdup (filename) : NULL;

  if (dirname && *dirname == '~')
    {
      char *temp_name;
      if (!dirname[1] || IS_SLASH (dirname[1]))
        {
          /* Prepend $HOME to the rest of the string. */
          char *temp_home = getenv ("HOME");

          /* If there is no HOME variable, look up the directory in
             the password database. */
          if (!temp_home)
            {
              struct passwd *entry;

              entry = (struct passwd *) getpwuid (getuid ());
              if (entry)
                temp_home = entry->pw_dir;
            }

          temp_name = xmalloc (1 + strlen (&dirname[1])
                               + (temp_home ? strlen (temp_home) : 0));
          if (temp_home)
            strcpy (temp_name, temp_home);
          else
            temp_name[0] = 0;
          strcat (temp_name, &dirname[1]);
          free (dirname);
          dirname = xstrdup (temp_name);
          free (temp_name);
        }
      else
        {
          struct passwd *user_entry;
          char *username = xmalloc (257);
          int i, c;

          for (i = 1; (c = dirname[i]); i++)
            {
              if (IS_SLASH (c))
                break;
              else
                username[i - 1] = c;
            }
          username[i - 1] = 0;

          if (!(user_entry = (struct passwd *) getpwnam (username)))
            {
              /* If the calling program has a special syntax for
                 expanding tildes, and we couldn't find a standard
                 expansion, then let them try. */
              if (tilde_expansion_failure_hook)
                {
                  char *expansion = (*tilde_expansion_failure_hook) (username);

                  if (expansion)
                    {
                      temp_name = xmalloc (1 + strlen (expansion)
                                           + strlen (&dirname[i])); 
                      strcpy (temp_name, expansion);
                      strcat (temp_name, &dirname[i]);
                      free (expansion);
                      goto return_name;
                    }
                }
              /* We shouldn't report errors. */
            }
          else
            {
              temp_name = xmalloc (1 + strlen (user_entry->pw_dir)
                                   + strlen (&dirname[i])); 
              strcpy (temp_name, user_entry->pw_dir);
              strcat (temp_name, &dirname[i]);

            return_name:
              free (dirname);
              dirname = xstrdup (temp_name);
              free (temp_name);
            }

          endpwent ();
          free (username);
        }
    }
  return dirname;
}


#if defined (TEST)
#undef NULL
#include <stdio.h>

main (argc, argv)
     int argc;
     char **argv;
{
  char *result, line[512];
  int done = 0;

  while (!done)
    {
      printf ("~expand: ");
      fflush (stdout);

      if (!gets (line))
        strcpy (line, "done");

      if ((strcmp (line, "done") == 0) ||
          (strcmp (line, "quit") == 0) ||
          (strcmp (line, "exit") == 0))
        {
          done = 1;
          break;
        }

      result = tilde_expand (line);
      printf ("  --> %s\n", result);
      free (result);
    }
  xexit (0);
}

static void memory_error_and_abort ();

static void *
xmalloc (bytes)
     int bytes;
{
  void *temp = (void *)malloc (bytes);

  if (!temp)
    memory_error_and_abort ();
  return (temp);
}

static void *
xrealloc (pointer, bytes)
     void *pointer;
     int bytes;
{
  void *temp;

  if (!pointer)
    temp = (char *)malloc (bytes);
  else
    temp = (char *)realloc (pointer, bytes);

  if (!temp)
    memory_error_and_abort ();

  return (temp);
}

static void
memory_error_and_abort ()
{
  fprintf (stderr, _("readline: Out of virtual memory!\n"));
  abort ();
}
#endif /* TEST */

@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: tilde.c,v 1.13 1999/03/03 22:42:21 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 98, 99
   Free Software Foundation, Inc.
d25 1
d63 1
a63 3
tilde_find_prefix (string, len)
     char *string;
     int *len;
d94 1
a94 2
tilde_find_suffix (string)
     char *string;
d117 1
a117 2
tilde_expand (string)
     char *string;
d119 1
a119 1
  char *result, *tilde_expand_word ();
d179 1
a179 2
tilde_expand_word (filename)
     char *filename;
d235 1
a235 3
                  char *expansion;

                  expansion = (*tilde_expansion_failure_hook) (username);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo).
   $Id: tilde.c,v 1.9 1998/02/22 23:03:21 karl Exp $
d4 1
a4 4
   This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 98
a22 5
/* Indent #pragma so that older Cpp's don't try to parse it. */
#ifdef _AIX
 #pragma alloca
#endif /* _AIX */

a25 13
#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
char *alloca ();
#  endif
# endif
#endif

d105 1
a105 1
      if (string[i] == '/' || !string[i])
d185 1
a185 3
  char *dirname;

  dirname = filename ? xstrdup (filename) : (char *)NULL;
d190 1
a190 1
      if (!dirname[1] || dirname[1] == '/')
d206 2
a207 4
          temp_name = (char *)
            alloca (1 + strlen (&dirname[1])
                    + (temp_home ? strlen (temp_home) : 0));
          temp_name[0] = '\0';
d210 2
d215 1
d220 1
a220 1
          char *username = (char *)alloca (257);
d225 1
a225 1
              if (c == '/')
d230 1
a230 1
          username[i - 1] = '\0';
d245 2
a246 2
                      temp_name = (char *)alloca
                        (1 + strlen (expansion) + strlen (&dirname[i]));
d257 2
a258 2
              temp_name = (char *)alloca
                (1 + strlen (user_entry->pw_dir) + strlen (&dirname[i]));
d261 1
d265 1
d267 3
a269 1
            endpwent ();
d272 1
a272 1
  return (dirname);
d307 1
a307 1
  exit (0);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo). */
d4 1
a4 1
/* This file is part of GNU Info, a program for reading online documentation
d7 2
a8 5
   This file has appeared in prior works by the Free Software Foundation;
   thus it carries copyright dates from 1988 through 1993.

   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993 Free Software
   Foundation, Inc.
d26 2
a27 4
#if defined (__GNUC__)
#  define alloca __builtin_alloca
#else /* !__GNUC__ */
#  if defined (_AIX)
d29 1
a29 10
#  else /* !_AIX */
#    if defined (HAVE_ALLOCA_H)
#      include <alloca.h>
#    endif /* HAVE_ALLOCA_H */
#  endif /* !AIX */
#endif /* !__GNUC__ */

#if defined (HAVE_STDLIB_H)
#include <stdlib.h>
#endif
d31 2
a32 2
#include "tilde.h"
#include <pwd.h>
d34 11
a44 8
#if defined (HAVE_STRING_H)
#include <string.h>
#endif

#include "clib.h"

#if !defined (NULL)
#  define NULL 0x0
a48 2
#else
extern void *xmalloc (), *xrealloc ();
d99 10
a108 10
	{
	  for (j = 0; prefixes[j]; j++)
	    {
	      if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
		{
		  *len = strlen (prefixes[j]) - 1;
		  return (i + *len);
		}
	    }
	}
d127 1
a127 1
	break;
d130 4
a133 4
	{
	  if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
	    return (i);
	}
d161 1
a161 1
	result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d170 1
a170 1
	 username. */
d175 1
a175 1
	break;
d188 1
a188 1
	result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d208 1
a208 1
  dirname = filename ? strdup (filename) : (char *)NULL;
d214 25
a238 25
	{
	  /* Prepend $HOME to the rest of the string. */
	  char *temp_home = (char *)getenv ("HOME");

	  /* If there is no HOME variable, look up the directory in
	     the password database. */
	  if (!temp_home)
	    {
	      struct passwd *entry;

	      entry = (struct passwd *) getpwuid (getuid ());
	      if (entry)
		temp_home = entry->pw_dir;
	    }

	  temp_name = (char *)
	    alloca (1 + strlen (&dirname[1])
		    + (temp_home ? strlen (temp_home) : 0));
	  temp_name[0] = '\0';
	  if (temp_home)
	    strcpy (temp_name, temp_home);
	  strcat (temp_name, &dirname[1]);
	  free (dirname);
	  dirname = strdup (temp_name);
	}
d240 49
a288 49
	{
	  struct passwd *user_entry;
	  char *username = (char *)alloca (257);
	  int i, c;

	  for (i = 1; c = dirname[i]; i++)
	    {
	      if (c == '/')
		break;
	      else
		username[i - 1] = c;
	    }
	  username[i - 1] = '\0';

	  if (!(user_entry = (struct passwd *) getpwnam (username)))
	    {
	      /* If the calling program has a special syntax for
		 expanding tildes, and we couldn't find a standard
		 expansion, then let them try. */
	      if (tilde_expansion_failure_hook)
		{
		  char *expansion;

		  expansion = (*tilde_expansion_failure_hook) (username);

		  if (expansion)
		    {
		      temp_name = (char *)alloca
			(1 + strlen (expansion) + strlen (&dirname[i]));
		      strcpy (temp_name, expansion);
		      strcat (temp_name, &dirname[i]);
		      free (expansion);
		      goto return_name;
		    }
		}
	      /* We shouldn't report errors. */
	    }
	  else
	    {
	      temp_name = (char *)alloca
		(1 + strlen (user_entry->pw_dir) + strlen (&dirname[i]));
	      strcpy (temp_name, user_entry->pw_dir);
	      strcat (temp_name, &dirname[i]);
	    return_name:
	      free (dirname);
	      dirname = strdup (temp_name);
	    }
	    endpwent ();
	}
d311 1
a311 1
	strcpy (line, "done");
d314 6
a319 6
	  (strcmp (line, "quit") == 0) ||
	  (strcmp (line, "exit") == 0))
	{
	  done = 1;
	  break;
	}
d362 1
a362 1
  fprintf (stderr, "readline: Out of virtual memory!\n");
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of texinfo-3.9.
@
text
@d1 1
a1 2
/* tilde.c -- Tilde expansion code (~/foo := $HOME/foo).
   $Id: tilde.c,v 1.3 1996/09/29 23:12:30 karl Exp $
d3 1
a3 1
   This file is part of GNU Info, a program for reading online documentation
d6 5
a10 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96 Free Software Foundation, Inc.
d228 1
a228 2
	  extern char *getenv ();
	  char *temp_home = getenv ("HOME");
@


1.1.1.3
log
@Import of FSF texinfo 3.11
@
text
@d2 1
a2 1
   $Id: tilde.c,v 1.8 1997/07/24 21:49:03 karl Exp $
a24 3
/* Include config.h before doing alloca.  */
#include "info.h"

d37 17
d56 2
d108 10
a117 10
        {
          for (j = 0; prefixes[j]; j++)
            {
              if (strncmp (string + i, prefixes[j], strlen (prefixes[j])) == 0)
                {
                  *len = strlen (prefixes[j]) - 1;
                  return (i + *len);
                }
            }
        }
d136 1
a136 1
        break;
d139 4
a142 4
        {
          if (strncmp (string + i, suffixes[j], strlen (suffixes[j])) == 0)
            return (i);
        }
d170 1
a170 1
        result = (char *)xrealloc (result, 1 + (result_size += (start + 20)));
d179 1
a179 1
         username. */
d184 1
a184 1
        break;
d197 1
a197 1
        result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));
d217 1
a217 1
  dirname = filename ? xstrdup (filename) : (char *)NULL;
d223 26
a248 25
        {
          /* Prepend $HOME to the rest of the string. */
          char *temp_home = getenv ("HOME");

          /* If there is no HOME variable, look up the directory in
             the password database. */
          if (!temp_home)
            {
              struct passwd *entry;

              entry = (struct passwd *) getpwuid (getuid ());
              if (entry)
                temp_home = entry->pw_dir;
            }

          temp_name = (char *)
            alloca (1 + strlen (&dirname[1])
                    + (temp_home ? strlen (temp_home) : 0));
          temp_name[0] = '\0';
          if (temp_home)
            strcpy (temp_name, temp_home);
          strcat (temp_name, &dirname[1]);
          free (dirname);
          dirname = xstrdup (temp_name);
        }
d250 49
a298 49
        {
          struct passwd *user_entry;
          char *username = (char *)alloca (257);
          int i, c;

          for (i = 1; (c = dirname[i]); i++)
            {
              if (c == '/')
                break;
              else
                username[i - 1] = c;
            }
          username[i - 1] = '\0';

          if (!(user_entry = (struct passwd *) getpwnam (username)))
            {
              /* If the calling program has a special syntax for
                 expanding tildes, and we couldn't find a standard
                 expansion, then let them try. */
              if (tilde_expansion_failure_hook)
                {
                  char *expansion;

                  expansion = (*tilde_expansion_failure_hook) (username);

                  if (expansion)
                    {
                      temp_name = (char *)alloca
                        (1 + strlen (expansion) + strlen (&dirname[i]));
                      strcpy (temp_name, expansion);
                      strcat (temp_name, &dirname[i]);
                      free (expansion);
                      goto return_name;
                    }
                }
              /* We shouldn't report errors. */
            }
          else
            {
              temp_name = (char *)alloca
                (1 + strlen (user_entry->pw_dir) + strlen (&dirname[i]));
              strcpy (temp_name, user_entry->pw_dir);
              strcat (temp_name, &dirname[i]);
            return_name:
              free (dirname);
              dirname = xstrdup (temp_name);
            }
            endpwent ();
        }
d321 1
a321 1
        strcpy (line, "done");
d324 6
a329 6
          (strcmp (line, "quit") == 0) ||
          (strcmp (line, "exit") == 0))
        {
          done = 1;
          break;
        }
d372 1
a372 1
  fprintf (stderr, _("readline: Out of virtual memory!\n"));
@


1.1.1.4
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: tilde.c,v 1.9 1998/02/22 23:03:21 karl Exp $
d7 1
a7 2
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 98
   Free Software Foundation, Inc.
a24 5
/* Indent #pragma so that older Cpp's don't try to parse it. */
#ifdef _AIX
 #pragma alloca
#endif /* _AIX */

d28 11
a38 12
#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
#else
# ifdef HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifndef _AIX
char *alloca ();
#  endif
# endif
#endif
@


1.1.1.5
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* tilde.c -- tilde expansion code (~/foo := $HOME/foo).
   $Id: tilde.c,v 1.13 1999/03/03 22:42:21 karl Exp $
d4 4
a7 1
   Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 98, 99
d26 5
d34 13
d126 1
a126 1
      if (IS_SLASH (string[i]) || !string[i])
d206 3
a208 1
  char *dirname = filename ? xstrdup (filename) : NULL;
d213 1
a213 1
      if (!dirname[1] || IS_SLASH (dirname[1]))
d229 4
a232 2
          temp_name = xmalloc (1 + strlen (&dirname[1])
                               + (temp_home ? strlen (temp_home) : 0));
a234 2
          else
            temp_name[0] = 0;
a237 1
          free (temp_name);
d242 1
a242 1
          char *username = xmalloc (257);
d247 1
a247 1
              if (IS_SLASH (c))
d252 1
a252 1
          username[i - 1] = 0;
d267 2
a268 2
                      temp_name = xmalloc (1 + strlen (expansion)
                                           + strlen (&dirname[i])); 
d279 2
a280 2
              temp_name = xmalloc (1 + strlen (user_entry->pw_dir)
                                   + strlen (&dirname[i])); 
a282 1

a285 1
              free (temp_name);
d287 1
a287 3

          endpwent ();
          free (username);
d290 1
a290 1
  return dirname;
d325 1
a325 1
  xexit (0);
@


1.1.1.6
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: tilde.c,v 1.3 2004/04/11 17:56:46 karl Exp $
d4 2
a5 2
   Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1996, 1998, 1999,
   2002, 2004 Free Software Foundation, Inc.
a24 1
#include "tilde.h"
d62 3
a64 1
tilde_find_prefix (char *string, int *len)
d95 2
a96 1
tilde_find_suffix (char *string)
d119 2
a120 1
tilde_expand (char *string)
d122 1
a122 1
  char *result;
d182 2
a183 1
tilde_expand_word (char *filename)
d239 3
a241 1
                  char *expansion = (*tilde_expansion_failure_hook) (username);
@


