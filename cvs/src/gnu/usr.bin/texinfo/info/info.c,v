head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.6
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.40
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.32
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.36
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.34
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.30
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.28
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.26
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.24
	OPENBSD_5_0:1.9.0.22
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	TEXINFO_4_8:1.1.1.8
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	TEXINFO_4_2:1.1.1.7
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	TEXINFO_4_0:1.1.1.6
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	TEXINFO_3_12:1.1.1.5
	OPENBSD_2_4:1.1.1.4.0.6
	OPENBSD_2_4_BASE:1.1.1.4
	OPENBSD_2_3:1.1.1.4.0.4
	OPENBSD_2_3_BASE:1.1.1.4
	OPENBSD_2_2:1.1.1.4.0.2
	OPENBSD_2_2_BASE:1.1.1.4
	TEXINFO_3_11:1.1.1.4
	OPENBSD_2_1:1.1.1.3.0.2
	OPENBSD_2_1_BASE:1.1.1.3
	TEXINFO_3_9:1.1.1.3
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	TEXINFO_3_7:1.1.1.2
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.11.14.23.06.06;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	3WsuKev3hGnuRYC4;

1.9
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.03.23.39.58;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.15.19.16.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.09.02.18.39;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	99.11.22.05.00.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.02.11.19.44.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.07.30.17.34.42;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.12.15.21.38.51;	author downsj;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.08.01.22.00.20;	author kstailey;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.01.11.16.32.18;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.02.09.01.24.45;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.06.10.13.21.05;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.10
log
@info - pledge stdio rpath wpath cpath getpw tty proc exec
infokey - stdio rpath wpath cpath tty
makeinfo - stdio rpath wpath cpath getpw
install-info - stdio rpath wpath cpath proc exec
texindex - stdio rpath wpath cpath tmppath
ok schwarze
@
text
@/* info.c -- Display nodes of Info files in multiple windows.
   $Id: info.c,v 1.9 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "indices.h"
#include "dribble.h"
#include "getopt.h"
#if defined (HANDLE_MAN_PAGES)
#  include "man.h"
#endif /* HANDLE_MAN_PAGES */

static char *program_name = "info";

/* Non-zero means search all indices for APROPOS_SEARCH_STRING. */
static int apropos_p = 0;

/* Variable containing the string to search for when apropos_p is non-zero. */
static char *apropos_search_string = (char *)NULL;

/* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike
   apropos, this puts the user at the node, running info. */
static int index_search_p = 0;

/* Non-zero means look for the node which describes the invocation
   and command-line options of the program, and start the info
   session at that node.  */
static int goto_invocation_p = 0;

/* Variable containing the string to search for when index_search_p is
   non-zero. */
static char *index_search_string = (char *)NULL;

/* Non-zero means print version info only. */
static int print_version_p = 0;

/* Non-zero means print a short description of the options. */
static int print_help_p = 0;

/* Array of the names of nodes that the user specified with "--node" on the
   command line. */
static char **user_nodenames = (char **)NULL;
static int user_nodenames_index = 0;
static int user_nodenames_slots = 0;

/* String specifying the first file to load.  This string can only be set
   by the user specifying "--file" on the command line. */
static char *user_filename = (char *)NULL;

/* String specifying the name of the file to dump nodes to.  This value is
   filled if the user speficies "--output" on the command line. */
static char *user_output_filename = (char *)NULL;

/* Non-zero indicates that when "--output" is specified, all of the menu
   items of the specified nodes (and their subnodes as well) should be
   dumped in the order encountered.  This basically can print a book. */
int dump_subnodes = 0;

/* Non-zero means make default keybindings be loosely modeled on vi(1).  */
int vi_keys_p = 0;

/* Non-zero means don't remove ANSI escape sequences.  */
int raw_escapes_p = 1;

/* Non-zero means print the absolute location of the file to be loaded.  */
static int print_where_p = 0;

#ifdef __MSDOS__
/* Non-zero indicates that screen output should be made 'speech-friendly'.
   Since on MSDOS the usual behavior is to write directly to the video
   memory, speech synthesizer software cannot grab the output.  Therefore,
   we provide a user option which tells us to avoid direct screen output
   and use stdout instead (which loses the color output).  */
int speech_friendly = 0;
#endif

/* Structure describing the options that Info accepts.  We pass this structure
   to getopt_long ().  If you add or otherwise change this structure, you must
   also change the string which follows it. */
#define APROPOS_OPTION 1
#define DRIBBLE_OPTION 2
#define RESTORE_OPTION 3
#define IDXSRCH_OPTION 4
static struct option long_options[] = {
  { "apropos", 1, 0, APROPOS_OPTION },
  { "directory", 1, 0, 'd' },
  { "dribble", 1, 0, DRIBBLE_OPTION },
  { "file", 1, 0, 'f' },
  { "help", 0, &print_help_p, 1 },
  { "index-search", 1, 0, IDXSRCH_OPTION },
  { "location", 0, &print_where_p, 1 },
  { "node", 1, 0, 'n' },
  { "output", 1, 0, 'o' },
  { "raw-escapes", 0, &raw_escapes_p, 1 },
  { "no-raw-escapes", 0, &raw_escapes_p, 0 },
  { "restore", 1, 0, RESTORE_OPTION },
  { "show-options", 0, 0, 'O' },
  { "subnodes", 0, &dump_subnodes, 1 },
  { "usage", 0, 0, 'O' },
  { "version", 0, &print_version_p, 1 },
  { "vi-keys", 0, &vi_keys_p, 1 },
  { "where", 0, &print_where_p, 1 },
#ifdef __MSDOS__
  { "speech-friendly", 0, &speech_friendly, 1 },
#endif
  {NULL, 0, NULL, 0}
};

/* String describing the shorthand versions of the long options found above. */
#ifdef __MSDOS__
static char *short_options = "d:n:f:ho:ORswb";
#else
static char *short_options = "d:n:f:ho:ORws";
#endif

/* When non-zero, the Info window system has been initialized. */
int info_windows_initialized_p = 0;

/* Some "forward" declarations. */
static void info_short_help (void);
static void init_messages (void);


/* **************************************************************** */
/*                                                                  */
/*                Main Entry Point to the Info Program              */
/*                                                                  */
/* **************************************************************** */

int
main (int argc, char **argv)
{
  int getopt_long_index;        /* Index returned by getopt_long (). */
  NODE *initial_node;           /* First node loaded by Info. */

#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  if (pledge ("stdio rpath wpath getpw cpath tty proc exec", NULL) == -1) {
    fprintf (stderr, _("%s: pledge\n"), program_name);
    exit (1);
  }

#ifdef ENABLE_NLS
  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);
#endif

  init_messages ();

  while (1)
    {
      int option_character;

      option_character = getopt_long
        (argc, argv, short_options, long_options, &getopt_long_index);

      /* getopt_long returns EOF when there are no more long options. */
      if (option_character == EOF)
        break;

      /* If this is a long option, then get the short version of it. */
      if (option_character == 0 && long_options[getopt_long_index].flag == 0)
        option_character = long_options[getopt_long_index].val;

      /* Case on the option that we have received. */
      switch (option_character)
        {
        case 0:
          break;

          /* User wants to add a directory. */
        case 'd':
          info_add_path (optarg, INFOPATH_PREPEND);
          break;

          /* User is specifying a particular node. */
        case 'n':
          add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,
                                user_nodenames_slots, 10, char *);
          break;

          /* User is specifying a particular Info file. */
        case 'f':
          if (user_filename)
            free (user_filename);

          user_filename = xstrdup (optarg);
          break;

          /* Treat -h like --help. */
        case 'h':
          print_help_p = 1;
          break;

          /* User is specifying the name of a file to output to. */
        case 'o':
          if (user_output_filename)
            free (user_output_filename);
          user_output_filename = xstrdup (optarg);
          break;

         /* User has specified that she wants to find the "Options"
             or "Invocation" node for the program.  */
        case 'O':
          goto_invocation_p = 1;
          break;

	  /* User has specified that she wants the escape sequences
	     in man pages to be passed thru unaltered.  */
        case 'R':
          raw_escapes_p = 1;
          break;

          /* User is specifying that she wishes to dump the subnodes of
             the node that she is dumping. */
        case 's':
          dump_subnodes = 1;
          break;

          /* For compatibility with man, -w is --where.  */
        case 'w':
          print_where_p = 1;
          break;

#ifdef __MSDOS__
	  /* User wants speech-friendly output.  */
	case 'b':
	  speech_friendly = 1;
	  break;
#endif /* __MSDOS__ */

          /* User has specified a string to search all indices for. */
        case APROPOS_OPTION:
          apropos_p = 1;
          maybe_free (apropos_search_string);
          apropos_search_string = xstrdup (optarg);
          break;

          /* User has specified a dribble file to receive keystrokes. */
        case DRIBBLE_OPTION:
          close_dribble_file ();
          open_dribble_file (optarg);
          break;

          /* User has specified an alternate input stream. */
        case RESTORE_OPTION:
          info_set_input_from_file (optarg);
          break;

          /* User has specified a string to search all indices for. */
        case IDXSRCH_OPTION:
          index_search_p = 1;
          maybe_free (index_search_string);
          index_search_string = xstrdup (optarg);
          break;

        default:
          fprintf (stderr, _("Try --help for more information.\n"));
          xexit (1);
        }
    }

  /* If the output device is not a terminal, and no output filename has been
     specified, make user_output_filename be "-", so that the info is written
     to stdout, and turn on the dumping of subnodes. */
  if ((!isatty (fileno (stdout))) && (user_output_filename == (char *)NULL))
    {
      user_output_filename = xstrdup ("-");
      dump_subnodes = 1;
    }

  /* If the user specified --version, then show the version and exit. */
  if (print_version_p)
    {
      printf ("%s (GNU %s) %s\n", program_name, PACKAGE, VERSION);
      puts ("");
      puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
      printf (_("There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.\n"));
      xexit (0);
    }

  /* If the `--help' option was present, show the help and exit. */
  if (print_help_p)
    {
      info_short_help ();
      xexit (0);
    }

  /* If the user hasn't specified a path for Info files, default it.
     Lowest priority is our messy hardwired list in filesys.h.
     Then comes the user's INFODIR from the Makefile.
     Highest priority is the environment variable, if set.  */
  if (!infopath)
    {
      char *path_from_env = getenv ("INFOPATH");

      if (path_from_env)
        {
          unsigned len = strlen (path_from_env);
          /* Trailing : on INFOPATH means insert the default path.  */
          if (len && path_from_env[len - 1] == PATH_SEP[0])
            {
              path_from_env[len - 1] = 0;
              info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
            }
#ifdef INFODIR /* from the Makefile */
          info_add_path (INFODIR, INFOPATH_PREPEND);
#endif
          info_add_path (path_from_env, INFOPATH_PREPEND);
        }
      else
        {
          info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
#ifdef INFODIR /* from the Makefile */
          info_add_path (INFODIR, INFOPATH_PREPEND);
#endif
#ifdef INFODIR2 /* from the Makefile, too */
#  ifdef INFODIR
          if (!STREQ (INFODIR, INFODIR2))
#  endif
            info_add_path (INFODIR2, INFOPATH_PREPEND);
#endif
        }
    }

  /* If the user specified a particular filename, add the path of that
     file to the contents of INFOPATH. */
  if (user_filename)
    add_file_directory_to_path (user_filename);

  /* If the user wants to search every known index for a given string,
     do that now, and report the results. */
  if (apropos_p)
    {
      info_apropos (apropos_search_string);
      xexit (0);
    }

  /* Get the initial Info node.  It is either "(dir)Top", or what the user
     specified with values in user_filename and user_nodenames. */
  initial_node = info_get_node (user_filename,
                                user_nodenames ? user_nodenames[0] : 0);

  /* If we couldn't get the initial node, this user is in trouble. */
  if (!initial_node)
    {
      if (info_recent_file_error)
        info_error (info_recent_file_error, NULL, NULL);
      else
        info_error ((char *) msg_cant_find_node,
                    user_nodenames ? user_nodenames[0] : "Top", NULL);
      xexit (1);
    }

  /* Special cases for when the user specifies multiple nodes.  If we
     are dumping to an output file, dump all of the nodes specified.
     Otherwise, attempt to create enough windows to handle the nodes
     that this user wants displayed. */
  if (user_nodenames_index > 1)
    {
      free (initial_node);

      if (print_where_p)
        printf ("%s\n", user_filename ? user_filename : "unknown?!");
      else if (user_output_filename)
        dump_nodes_to_file
          (user_filename, user_nodenames, user_output_filename, dump_subnodes);
      else
        begin_multiple_window_info_session (user_filename, user_nodenames);

      xexit (0);
    }

  /* If there are arguments remaining, they are the names of menu items
     in sequential info files starting from the first one loaded.  That
     file name is either "dir", or the contents of user_filename if one
     was specified. */
  {
    const char *errstr;
    char *errarg1, *errarg2;

    NODE *new_initial_node = info_follow_menus (initial_node, argv + optind,
        &errstr, &errarg1, &errarg2);

    if (new_initial_node && new_initial_node != initial_node)
      initial_node = new_initial_node;

    if (print_where_p)
      {
        if (initial_node->parent)
          printf ("%s\n", initial_node->parent);
        else if (initial_node->filename
            && !is_dir_name (filename_non_directory (initial_node->filename)))
          printf ("%s\n", initial_node->filename);
        else
          xexit (1);
        xexit (0);
      }

    /* If the user specified that this node should be output, then do that
       now.  Otherwise, start the Info session with this node.  Or act
       accordingly if the initial node was not found.  */
    if (user_output_filename && !goto_invocation_p)
      {
        if (!errstr)
          dump_node_to_file (initial_node, user_output_filename,
                             dump_subnodes);
        else
          info_error ((char *) errstr, errarg1, errarg2);
      }
    else
      {

        if (errstr)
          begin_info_session_with_error (initial_node, (char *) errstr,
              errarg1, errarg2);
        /* If the user specified `--index-search=STRING' or
           --show-options, start the info session in the node
           corresponding to what they want. */
        else if (index_search_p || goto_invocation_p)
          {
            int status = 0;

            initialize_info_session (initial_node, 0);

            if (goto_invocation_p
                || index_entry_exists (windows, index_search_string))
              {
                terminal_prep_terminal ();
                terminal_clear_screen ();
                info_last_executed_command = (VFunction *)NULL;

                if (index_search_p)
                  do_info_index_search (windows, 0, index_search_string);
                else
                  {
                    /* If they said "info --show-options foo bar baz",
                       the last of the arguments is the program whose
                       options they want to see.  */
                    char **p = argv + optind;
                    char *program;

                    if (*p)
                      {
                        while (p[1])
                          p++;
                        program = xstrdup (*p);
                      }
                    else if (user_filename)
		      /* If there's no command-line arguments to
			 supply the program name, use the Info file
			 name (sans extension and leading directories)
			 instead.  */
		      program = program_name_from_file_name (user_filename);
		    else
		      program = xstrdup ("");

                    info_intuit_options_node (windows, initial_node, program);
                    free (program);
                  }

		if (user_output_filename)
		  {
		    dump_node_to_file (windows->node, user_output_filename,
				       dump_subnodes);
		  }
		else
		  info_read_and_dispatch ();

                /* On program exit, leave the cursor at the bottom of the
                   window, and restore the terminal IO. */
                terminal_goto_xy (0, screenheight - 1);
                terminal_clear_to_eol ();
                fflush (stdout);
                terminal_unprep_terminal ();
              }
            else
              {
                fprintf (stderr, _("no index entries found for `%s'\n"),
                         index_search_string);
                status = 2;
              }

            close_dribble_file ();
            xexit (status);
          }
        else
          begin_info_session (initial_node);
      }

    xexit (0);
  }

  return 0; /* Avoid bogus warnings.  */
}

void
add_file_directory_to_path (char *filename)
{
  char *directory_name = xstrdup (filename);
  char *temp = filename_non_directory (directory_name);

  if (temp != directory_name)
    {
      if (HAVE_DRIVE (directory_name) && temp == directory_name + 2)
	{
	  /* The directory of "d:foo" is stored as "d:.", to avoid
	     mixing it with "d:/" when a slash is appended.  */
	  *temp = '.';
	  temp += 2;
	}
      temp[-1] = 0;
      info_add_path (directory_name, INFOPATH_PREPEND);
    }

  free (directory_name);
}


/* Error handling.  */

/* Non-zero if an error has been signalled. */
int info_error_was_printed = 0;

/* Non-zero means ring terminal bell on errors. */
int info_error_rings_bell_p = 1;

/* Print FORMAT with ARG1 and ARG2.  If the window system was initialized,
   then the message is printed in the echo area.  Otherwise, a message is
   output to stderr. */
void
info_error (char *format, void *arg1, void *arg2)
{
  info_error_was_printed = 1;

  if (!info_windows_initialized_p || display_inhibited)
    {
      fprintf (stderr, "%s: ", program_name);
      fprintf (stderr, format, arg1, arg2);
      fprintf (stderr, "\n");
      fflush (stderr);
    }
  else
    {
      if (!echo_area_is_active)
        {
          if (info_error_rings_bell_p)
            terminal_ring_bell ();
          window_message_in_echo_area (format, arg1, arg2);
        }
      else
        {
          NODE *temp;

          temp = build_message_node (format, arg1, arg2);
          if (info_error_rings_bell_p)
            terminal_ring_bell ();
          inform_in_echo_area (temp->contents);
          free (temp->contents);
          free (temp);
        }
    }
}


/* Produce a scaled down description of the available options to Info. */
static void
info_short_help (void)
{
#ifdef __MSDOS__
  static const char speech_friendly_string[] = N_("\
  -b, --speech-friendly        be friendly to speech synthesizers.\n");
#else
  static const char speech_friendly_string[] = "";
#endif


  printf (_("\
Usage: %s [OPTION]... [MENU-ITEM...]\n\
\n\
Read documentation in Info format.\n\
\n\
Options:\n\
      --apropos=STRING         look up STRING in all indices of all manuals.\n\
  -d, --directory=DIR          add DIR to INFOPATH.\n\
      --dribble=FILENAME       remember user keystrokes in FILENAME.\n\
  -f, --file=FILENAME          specify Info file to visit.\n\
  -h, --help                   display this help and exit.\n\
      --index-search=STRING    go to node pointed by index entry STRING.\n\
  -n, --node=NODENAME          specify nodes in first visited Info file.\n\
  -o, --output=FILENAME        output selected nodes to FILENAME.\n\
  -R, --raw-escapes            output \"raw\" ANSI escapes (default).\n\
      --no-raw-escapes         output escapes as literal text.\n\
      --restore=FILENAME       read initial keystrokes from FILENAME.\n\
  -O, --show-options, --usage  go to command-line options node.\n%s\
      --subnodes               recursively output menu items.\n\
  -w, --where, --location      print physical location of Info file.\n\
      --vi-keys                use vi-like and less-like key bindings.\n\
      --version                display version information and exit.\n\
\n\
The first non-option argument, if present, is the menu entry to start from;\n\
it is searched for in all `dir' files along INFOPATH.\n\
If it is not present, info merges all `dir' files and shows the result.\n\
Any remaining arguments are treated as the names of menu\n\
items relative to the initial node visited.\n\
\n\
Examples:\n\
  info                       show top-level dir menu\n\
  info emacs                 start at emacs node from top-level dir\n\
  info emacs buffers         start at buffers node within emacs manual\n\
  info --show-options emacs  start at node with emacs' command line options\n\
  info -f ./foo.info         show file ./foo.info, not searching dir\n\
"),
  program_name, speech_friendly_string);

  puts (_("\n\
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
Texinfo home page: http://www.gnu.org/software/texinfo/"));

  xexit (0);
}


/* Initialize strings for gettext.  Because gettext doesn't handle N_ or
   _ within macro definitions, we put shared messages into variables and
   use them that way.  This also has the advantage that there's only one
   copy of the strings.  */

const char *msg_cant_find_node;
const char *msg_cant_file_node;
const char *msg_cant_find_window;
const char *msg_cant_find_point;
const char *msg_cant_kill_last;
const char *msg_no_menu_node;
const char *msg_no_foot_node;
const char *msg_no_xref_node;
const char *msg_no_pointer;
const char *msg_unknown_command;
const char *msg_term_too_dumb;
const char *msg_at_node_bottom;
const char *msg_at_node_top;
const char *msg_one_window;
const char *msg_win_too_small;
const char *msg_cant_make_help;

static void
init_messages (void)
{
  msg_cant_find_node   = _("Cannot find node `%s'.");
  msg_cant_file_node   = _("Cannot find node `(%s)%s'.");
  msg_cant_find_window = _("Cannot find a window!");
  msg_cant_find_point  = _("Point doesn't appear within this window's node!");
  msg_cant_kill_last   = _("Cannot delete the last window.");
  msg_no_menu_node     = _("No menu in this node.");
  msg_no_foot_node     = _("No footnotes in this node.");
  msg_no_xref_node     = _("No cross references in this node.");
  msg_no_pointer       = _("No `%s' pointer for this node.");
  msg_unknown_command  = _("Unknown Info command `%c'; try `?' for help.");
  msg_term_too_dumb    = _("Terminal type `%s' is not smart enough to run Info.");
  msg_at_node_bottom   = _("You are already at the last page of this node.");
  msg_at_node_top      = _("You are already at the first page of this node.");
  msg_one_window       = _("Only one window.");
  msg_win_too_small    = _("Resulting window would be too small.");
  msg_cant_make_help   = _("Not enough room for a help window, please delete a window.");
}
@


1.9
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: info.c,v 1.11 2004/04/11 17:56:45 karl Exp $
d158 5
@


1.8
log
@missing -h support; jeffi@@rcn.com
@
text
@d2 1
a2 1
   $Id: info.c,v 1.7 2003/03/15 19:16:10 deraadt Exp $
d4 2
a5 2
   Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc.
d80 5
a84 2
/* Non-zero means don't remove ANSI escape sequences from man pages.  */
int raw_escapes_p = 0;
d109 1
d113 1
d120 1
d129 1
a129 1
static char *short_options = "d:n:f:ho:ORsb";
d131 1
a131 1
static char *short_options = "d:n:f:ho:ORs";
d138 2
a139 3
static void info_short_help (), remember_info_program_name ();
static void init_messages ();
extern void add_file_directory_to_path ();
d149 1
a149 3
main (argc, argv)
     int argc;
     char **argv;
d159 1
d163 1
d166 1
a166 1
  
d174 1
a174 1
      /* getopt_long () returns EOF when there are no more long options. */
d207 1
d237 5
d294 2
a295 2
      printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
d297 1
a297 2
For more information about these matters, see the files named COPYING.\n"),
		  "2002");
d334 7
a340 1
         info_add_path (INFODIR, INFOPATH_PREPEND);
d367 1
a367 1
        info_error (info_recent_file_error);
d369 2
a370 2
        info_error (msg_cant_find_node,
                    user_nodenames ? user_nodenames[0] : "Top");
d382 3
a384 1
      if (user_output_filename)
d398 3
a400 1
    char *errstr, *errarg1, *errarg2;
d402 1
a402 1
                                                &errstr, &errarg1, &errarg2);
d407 12
d428 1
a428 1
          info_error (errstr, errarg1, errarg2);
d434 2
a435 2
          begin_info_session_with_error (initial_node, errstr,
                                         errarg1, errarg2);
d512 2
d517 1
a517 2
add_file_directory_to_path (filename)
     char *filename;
d551 1
a551 3
info_error (format, arg1, arg2)
     char *format;
     void *arg1, *arg2;
d587 1
a587 1
info_short_help ()
d596 1
a596 1
    
d611 2
a612 1
  -R, --raw-escapes            don't remove ANSI escapes from man pages.\n\
d616 1
d649 16
a664 16
char *msg_cant_find_node;
char *msg_cant_file_node;
char *msg_cant_find_window;
char *msg_cant_find_point;
char *msg_cant_kill_last;
char *msg_no_menu_node;
char *msg_no_foot_node;
char *msg_no_xref_node;
char *msg_no_pointer;
char *msg_unknown_command;
char *msg_term_too_dumb;
char *msg_at_node_bottom;
char *msg_at_node_top;
char *msg_one_window;
char *msg_win_too_small;
char *msg_cant_make_help;
d667 1
a667 1
init_messages ()
@


1.7
log
@specifed -> specified
@
text
@d2 1
a2 1
   $Id: info.c,v 1.6 2002/06/10 13:51:03 espie Exp $
d123 1
a123 1
static char *short_options = "d:n:f:o:ORsb";
d125 1
a125 1
static char *short_options = "d:n:f:o:ORs";
d200 4
@


1.6
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: info.c,v 1.60 2002/03/11 19:54:29 karl Exp $
d339 1
a339 1
     specifed with values in user_filename and user_nodenames. */
@


1.5
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: info.c,v 1.41 1999/09/25 16:10:04 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 96, 97, 98, 99 Free Software Foundation, Inc.
d80 3
d102 4
a106 2
  { "file", 1, 0, 'f' },
  { "subnodes", 0, &dump_subnodes, 1 },
d108 2
d111 1
d113 1
a114 4
  { "help", 0, &print_help_p, 1 },
  { "version", 0, &print_version_p, 1 },
  { "dribble", 1, 0, DRIBBLE_OPTION },
  { "restore", 1, 0, RESTORE_OPTION },
a117 1
  { "index-search", 1, 0, IDXSRCH_OPTION },
d123 1
a123 1
static char *short_options = "d:n:f:o:Osb";
d125 1
a125 1
static char *short_options = "d:n:f:o:Os";
d134 1
d215 6
d228 1
a228 1
	  /* User specifies that she wants speech-friendly output.  */
d283 1
a283 1
		  "1999");
d328 1
a328 19
    {
      char *directory_name = xstrdup (user_filename);
      char *temp = filename_non_directory (directory_name);

      if (temp != directory_name)
        {
	  if (HAVE_DRIVE (directory_name) && temp == directory_name + 2)
	    {
	      /* The directory of "d:foo" is stored as "d:.", to avoid
		 mixing it with "d:/" when a slash is appended.  */
	      *temp = '.';
	      temp += 2;
	    }
          temp[-1] = 0;
          info_add_path (directory_name, INFOPATH_PREPEND);
        }

      free (directory_name);
    }
d379 1
d386 1
a386 1
    if (user_output_filename)
d445 7
a451 1
                info_read_and_dispatch ();
d478 23
d554 8
d568 14
a581 13
 --apropos=SUBJECT        look up SUBJECT in all indices of all manuals.\n\
 --directory=DIR          add DIR to INFOPATH.\n\
 --dribble=FILENAME       remember user keystrokes in FILENAME.\n\
 --file=FILENAME          specify Info file to visit.\n\
 --help                   display this help and exit.\n\
 --index-search=STRING    go to node pointed by index entry STRING.\n\
 --node=NODENAME          specify nodes in first visited Info file.\n\
 --output=FILENAME        output selected nodes to FILENAME.\n\
 --restore=FILENAME       read initial keystrokes from FILENAME.\n\
 --show-options, --usage  go to command-line options node.\n\
 --subnodes               recursively output menu items.\n%s\
 --vi-keys                use vi-like and less-like key bindings.\n\
 --version                display version information and exit.\n\
d595 4
a598 1
\n\
d601 1
a601 9
"),
  program_name,
#ifdef __MSDOS__
"\
 --speech-friendly        be friendly to speech synthesizers.\n"
#else
""
#endif
	  );
@


1.4
log
@missing newline
@
text
@d2 1
a2 1
   $Id: info.c,v 1.3 1999/02/11 19:44:09 deraadt Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97, 98 Free Software Foundation, Inc.
d30 1
a30 6
/* The version numbers of this version of Info. */
int info_major_version = 2;
int info_minor_version = 18;

/* basename (argv[0]) */
static char *program_name = NULL;
d42 5
d48 1
a48 1
   non-zero. */ 
d76 12
d102 3
d109 3
d117 5
a121 1
static char *short_options = "d:n:f:o:s";
d128 1
a144 2
  remember_info_program_name (argv[0]);

d154 2
d203 6
d215 7
d249 1
a249 1
          exit (1);
d265 2
a266 2
      printf ("%s (GNU %s %s) %s\n", program_name, PACKAGE, VERSION, 
              version_string ());
d271 2
a272 2
		  "1998");
      exit (0);
d279 1
a279 1
      exit (0);
d281 1
a281 1
  
d294 1
a294 1
          if (len && path_from_env[len - 1] == ':')
d322 8
a329 1
          *temp = 0;
d341 1
a341 1
      exit (0);
d347 1
a347 1
                                user_nodenames ? user_nodenames[0] : NULL);
d355 3
a357 3
        info_error
          (CANT_FIND_NODE, user_nodenames ? user_nodenames[0] : "Top");
      exit (1);
d374 1
a374 38
      exit (0);
    }

  /* If the user specified `--index-search=STRING', start the info
     session in the node corresponding to the first match. */
  if (index_search_p)
    {
      int status = 0;

      initialize_info_session (initial_node, 0);

      if (index_entry_exists (windows, index_search_string))
        {
          terminal_clear_screen ();
          terminal_prep_terminal ();
          display_update_display (windows);
          info_last_executed_command = (VFunction *)NULL;

          do_info_index_search (windows, 0, index_search_string);

          info_read_and_dispatch ();

          terminal_unprep_terminal ();

          /* On program exit, leave the cursor at the bottom of the
             window, and restore the terminal IO. */
          terminal_goto_xy (0, screenheight - 1);
          terminal_clear_to_eol ();
          fflush (stdout);
        }
      else
        {
          fputs (_("no entries found\n"), stderr);
          status = 2;
        }

      close_dribble_file (); 
      exit (status);
d381 91
a471 74
  while (optind != argc)
    {
      REFERENCE **menu;
      REFERENCE *entry;
      NODE *node;
      char *arg;
      static char *first_arg = (char *)NULL;

      /* Remember the name of the menu entry we want. */
      arg = argv[optind++];

      if (!first_arg)
        first_arg = arg;

      /* Build and return a list of the menu items in this node. */
      menu = info_menu_of_node (initial_node);

      /* If there wasn't a menu item in this node, stop here, but let
         the user continue to use Info.  Perhaps they wanted this node
         and didn't realize it. */
      if (!menu)
        {
#if defined (HANDLE_MAN_PAGES)
          if (first_arg == arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
#endif /* HANDLE_MAN_PAGES */
          begin_info_session_with_error
            (initial_node, _("There is no menu in this node."));
          exit (0);
        }

      /* Find the specified menu item. */
      entry = info_get_labeled_reference (arg, menu);

      /* If the item wasn't found, search the list sloppily.  Perhaps this
         user typed "buffer" when they really meant "Buffers". */
      if (!entry)
        {
          register int i;
          int best_guess = -1;

          for (i = 0; (entry = menu[i]); i++)
            {
              if (strcasecmp (entry->label, arg) == 0)
                break;
              else
                if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
                  best_guess = i;
            }

          if (!entry && best_guess != -1)
            entry = menu[best_guess];
        }

      /* If we failed to find the reference, start Info with the current
         node anyway.  It is probably a misspelling. */
      if (!entry)
        {
          char *error_message = _("There is no menu item \"%s\" in this node.");

#if defined (HANDLE_MAN_PAGES)
          if (first_arg == arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
#endif /* HANDLE_MAN_PAGES */

          info_free_references (menu);
d473 2
a474 88
          /* If we were supposed to dump this node, complain. */
          if (user_output_filename)
            info_error (error_message, arg);
          else
            begin_info_session_with_error (initial_node, error_message, arg);

          exit (0);
        }

      /* We have found the reference that the user specified.  Clean it
         up a little bit. */
      if (!entry->filename)
        {
          if (initial_node->parent)
            entry->filename = xstrdup (initial_node->parent);
          else
            entry->filename = xstrdup (initial_node->filename);
        }

      /* Find this node.  If we can find it, then turn the initial_node
         into this one.  If we cannot find it, try using the label of the
         entry as a file (i.e., "(LABEL)Top").  Otherwise the Info file is
         malformed in some way, and we will just use the current value of
         initial node. */
      node = info_get_node (entry->filename, entry->nodename);

#if defined (HANDLE_MAN_PAGES)
          if ((first_arg == arg) && !node)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
#endif /* HANDLE_MAN_PAGES */

      if (!node && entry->nodename &&
          (strcmp (entry->label, entry->nodename) == 0))
        node = info_get_node (entry->label, "Top");

    maybe_got_node:
      if (node)
        {
          free (initial_node);
          initial_node = node;
          info_free_references (menu);
        }
      else
        {
          char *temp = xstrdup (entry->label);
          char *error_message;

          error_message = _("Unable to find the node referenced by \"%s\".");

          info_free_references (menu);

          /* If we were trying to dump the node, then give up.  Otherwise,
             start the session with an error message. */
          if (user_output_filename)
            info_error (error_message, temp);
          else
            begin_info_session_with_error (initial_node, error_message, temp);

          exit (0);
        }
    }

  /* If the user specified that this node should be output, then do that
     now.  Otherwise, start the Info session with this node. */
  if (user_output_filename)
    dump_node_to_file (initial_node, user_output_filename, dump_subnodes);
  else
    begin_info_session (initial_node);

  exit (0);
}

/* Return a string describing the current version of Info. */
char *
version_string ()
{
  static char *vstring = (char *)NULL;

  if (!vstring)
    {
      vstring = (char *)xmalloc (50);
      sprintf (vstring, "%d.%d", info_major_version, info_minor_version);
    }
  return (vstring);
a479 10
static void
remember_info_program_name (fullpath)
     char *fullpath;
{
  char *filename;

  filename = filename_non_directory (fullpath);
  program_name = xstrdup (filename);
}

d525 1
d531 1
a531 1
Usage: %s [OPTION]... [INFO-FILE [MENU-ITEM...]]\n\
a533 1
For more complete documentation on how to use Info, run `info info options'.\n\
d536 13
a548 9
--directory DIR              add DIR to INFOPATH.\n\
--dribble FILENAME           remember user keystrokes in FILENAME.\n\
--file FILENAME              specify Info file to visit.\n\
--node NODENAME              specify nodes in first visited Info file.\n\
--output FILENAME            output selected nodes to FILENAME.\n\
--restore FILENAME           read initial keystrokes from FILENAME.\n\
--subnodes                   recursively output menu items.\n\
--help                       display this help and exit.\n\
--version                    display version information and exit.\n\
d550 3
a552 1
The first argument, if present, is the name of the Info file to read.\n\
d554 8
a561 2
items in the initial node visited.  For example, `info emacs buffers'\n\
moves to the node `buffers' in the info file `emacs'.\n\
d563 11
a573 1
Email bug reports to bug-texinfo@@gnu.org.\n"), program_name);
d575 45
a619 1
  exit (0);
@


1.3
log
@newline at end of usage; tv@@netbsd
@
text
@d2 1
a2 1
   $Id: info.c,v 1.2 1999/01/11 16:38:08 espie Exp $
d624 1
a624 1
Email bug reports to bug-texinfo@@gnu.org."), program_name);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: info.c,v 1.18 1998/02/27 21:37:27 karl Exp $
d212 1
a212 1
          fprintf (stderr, _("Try --help for more information."));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* info.c -- Display nodes of Info files in multiple windows. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d23 1
d32 4
a35 2
int info_minor_version = 14;
int info_patch_level = 0;
d43 8
d82 1
d94 1
d105 1
a105 1
static void usage (), info_short_help (), remember_info_program_name ();
d109 3
a111 3
/*								    */
/*		  Main Entry Point to the Info Program		    */
/*								    */
d119 2
a120 2
  int getopt_long_index;	/* Index returned by getopt_long (). */
  NODE *initial_node;		/* First node loaded by Info. */
d124 9
d138 1
a138 1
	(argc, argv, short_options, long_options, &getopt_long_index);
d142 1
a142 1
	break;
d146 1
a146 1
	option_character = long_options[getopt_long_index].val;
d150 65
a214 57
	{
	case 0:
	  break;

	  /* User wants to add a directory. */
	case 'd':
	  info_add_path (optarg, INFOPATH_PREPEND);
	  break;

	  /* User is specifying a particular node. */
	case 'n':
	  add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,
				user_nodenames_slots, 10, char *);
	  break;

	  /* User is specifying a particular Info file. */
	case 'f':
	  if (user_filename)
	    free (user_filename);

	  user_filename = strdup (optarg);
	  break;

	  /* User is specifying the name of a file to output to. */
	case 'o':
	  if (user_output_filename)
	    free (user_output_filename);
	  user_output_filename = strdup (optarg);
	  break;

	  /* User is specifying that she wishes to dump the subnodes of
	     the node that she is dumping. */
	case 's':
	  dump_subnodes = 1;
	  break;

	  /* User has specified a string to search all indices for. */
	case APROPOS_OPTION:
	  apropos_p = 1;
	  maybe_free (apropos_search_string);
	  apropos_search_string = strdup (optarg);
	  break;

	  /* User has specified a dribble file to receive keystrokes. */
	case DRIBBLE_OPTION:
	  close_dribble_file ();
	  open_dribble_file (optarg);
	  break;

	  /* User has specified an alternate input stream. */
	case RESTORE_OPTION:
	  info_set_input_from_file (optarg);
	  break;

	default:
	  usage ();
	}
d222 1
a222 1
      user_output_filename = strdup ("-");
d229 7
a235 1
      printf ("GNU Info, Version %s.\n", version_string ());
d246 4
a249 2
  /* If the user hasn't specified a path for Info files, default that path
     now. */
d252 1
a252 3
      char *path_from_env, *getenv ();

      path_from_env = getenv ("INFOPATH");
d255 13
a267 1
	info_add_path (path_from_env, INFOPATH_PREPEND);
d269 6
a274 1
	info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
d281 2
a282 4
      char *directory_name, *temp;

      directory_name = strdup (user_filename);
      temp = filename_non_directory (directory_name);
d285 4
a288 4
	{
	  *temp = 0;
	  info_add_path (directory_name, INFOPATH_PREPEND);
	}
d303 2
a304 4
  if (user_nodenames)
    initial_node = info_get_node (user_filename, user_nodenames[0]);
  else
    initial_node = info_get_node (user_filename, (char *)NULL);
d310 1
a310 1
	info_error (info_recent_file_error);
d312 2
a313 2
	info_error
	  (CANT_FIND_NODE, user_nodenames ? user_nodenames[0] : "Top");
d317 4
a320 4
  /* Special cases for when the user specifies multiple nodes.  If we are
     dumping to an output file, dump all of the nodes specified.  Otherwise,
     attempt to create enough windows to handle the nodes that this user wants
     displayed. */
d326 2
a327 2
	dump_nodes_to_file
	  (user_filename, user_nodenames, user_output_filename, dump_subnodes);
d329 1
a329 1
	begin_multiple_window_info_session (user_filename, user_nodenames);
d334 37
d386 2
a387 2
      if (first_arg == (char *)NULL)
	first_arg = arg;
d393 2
a394 2
	 the user continue to use Info.  Perhaps they wanted this node
	 and didn't realize it. */
d396 1
a396 1
	{
d398 6
a403 6
	  if (first_arg == arg)
	    {
	      node = make_manpage_node (first_arg);
	      if (node)
		goto maybe_got_node;
	    }
d405 4
a408 4
	  begin_info_session_with_error
	    (initial_node, "There is no menu in this node.");
	  exit (0);
	}
d414 1
a414 1
	 user typed "buffer" when they really meant "Buffers". */
d416 16
a431 7
	{
	  register int i;

	  for (i = 0; entry = menu[i]; i++)
	    if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
	      break;
	}
d434 1
a434 1
	 node anyway.  It is probably a misspelling. */
d436 2
a437 2
	{
	  char *error_message = "There is no menu item \"%s\" in this node.";
d440 6
a445 6
	  if (first_arg == arg)
	    {
	      node = make_manpage_node (first_arg);
	      if (node)
		goto maybe_got_node;
	    }
d448 1
a448 1
	  info_free_references (menu);
d450 5
a454 5
	  /* If we were supposed to dump this node, complain. */
	  if (user_output_filename)
	    info_error (error_message, arg);
	  else
	    begin_info_session_with_error (initial_node, error_message, arg);
d456 2
a457 2
	  exit (0);
	}
d460 1
a460 1
	 up a little bit. */
d462 6
a467 6
	{
	  if (initial_node->parent)
	    entry->filename = strdup (initial_node->parent);
	  else
	    entry->filename = strdup (initial_node->filename);
	}
d470 4
a473 4
	 into this one.  If we cannot find it, try using the label of the
	 entry as a file (i.e., "(LABEL)Top").  Otherwise the Info file is
	 malformed in some way, and we will just use the current value of
	 initial node. */
d477 6
a482 6
	  if ((first_arg == arg) && !node)
	    {
	      node = make_manpage_node (first_arg);
	      if (node)
		goto maybe_got_node;
	    }
d486 2
a487 2
	  (strcmp (entry->label, entry->nodename) == 0))
	node = info_get_node (entry->label, "Top");
d491 5
a495 5
	{
	  free (initial_node);
	  initial_node = node;
	  info_free_references (menu);
	}
d497 14
a510 14
	{
	  char *temp = strdup (entry->label);
	  char *error_message;

	  error_message = "Unable to find the node referenced by \"%s\".";

	  info_free_references (menu);

	  /* If we were trying to dump the node, then give up.  Otherwise,
	     start the session with an error message. */
	  if (user_output_filename)
	    info_error (error_message, temp);
	  else
	    begin_info_session_with_error (initial_node, error_message, temp);
d512 2
a513 2
	  exit (0);
	}
a535 2
      if (info_patch_level)
	sprintf (vstring + strlen (vstring), "-p%d", info_patch_level);
d539 1
d541 1
a541 7
/* **************************************************************** */
/*								    */
/*		   Error Handling for Info			    */
/*								    */
/* **************************************************************** */

static char *program_name = (char *)NULL;
d550 1
a550 1
  program_name = strdup (filename);
d579 5
a583 5
	{
	  if (info_error_rings_bell_p)
	    terminal_ring_bell ();
	  window_message_in_echo_area (format, arg1, arg2);
	}
d585 2
a586 2
	{
	  NODE *temp;
d588 7
a594 7
	  temp = build_message_node (format, arg1, arg2);
	  if (info_error_rings_bell_p)
	    terminal_ring_bell ();
	  inform_in_echo_area (temp->contents);
	  free (temp->contents);
	  free (temp);
	}
a597 14
/* Produce a very brief descripton of the available options and exit with
   an error. */
static void
usage ()
{
  fprintf (stderr,"%s\n%s\n%s\n%s\n%s\n",
"Usage: info [-d dir-path] [-f info-file] [-o output-file] [-n node-name]...",
"            [--directory dir-path] [--file info-file] [--node node-name]...",
"            [--help] [--output output-file] [--subnodes] [--version]",
"            [--dribble dribble-file] [--restore from-file]",
"            [menu-selection ...]");
  exit (1);
}

d602 16
a617 3
  printf ("%s", "\
Here is a quick description of Info's options.  For a more complete\n\
description of how to use Info, type `info info options'.\n\
d619 4
a622 9
   --directory DIR		Add DIR to INFOPATH.\n\
   --file FILENAME		Specify Info file to visit.\n\
   --node NODENAME		Specify nodes in first visited Info file.\n\
   --output FILENAME		Output selected nodes to FILENAME.\n\
   --dribble FILENAME		Remember user keystrokes in FILENAME.\n\
   --restore FILENAME		Read initial keystrokes from FILENAME.\n\
   --subnodes			Recursively output menu items.\n\
   --help			Get this help message.\n\
   --version			Display Info's version information.\n\
d624 1
a624 4
Remaining arguments to Info are treated as the names of menu\n\
items in the initial node visited.  You can easily move to the\n\
node of your choice by specifying the menu names which describe\n\
the path to that node.  For example, `info emacs buffers'.\n");
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@import of texinfo 3.7
@
text
@d34 1
a34 1
int info_patch_level = 1;
d201 1
a201 1
      printf ("GNU Info, Version %s, from texinfo-3.7.\n", version_string ());
a333 1
	  int best_guess = -1;
d336 2
a337 10
	    {
	      if (strcasecmp (entry->label, arg) == 0)
		break;
	      else
		if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
		  best_guess = i;
	    }

	  if (!entry && best_guess != -1)
	    entry = menu[best_guess];
@


1.1.1.3
log
@Import of texinfo-3.9.
@
text
@d6 1
a6 1
   Copyright (C) 1993, 96 Free Software Foundation, Inc.
d33 2
a34 2
int info_minor_version = 16;
int info_patch_level = 0;
d201 1
a201 5
      printf ("GNU Info (Texinfo 3.9) %s\n", version_string ());
      puts ("Copyright (C) 1996 Free Software Foundation, Inc.\n\
There is NO warranty.  You may redistribute this software\n\
under the terms of the GNU General Public License.\n\
For more information about these matters, see the files named COPYING.");
d539 1
a539 1
  puts ("\
a543 1
   --dribble FILENAME		Remember user keystrokes in FILENAME.\n\
d547 1
d556 1
a556 3
the path to that node.  For example, `info emacs buffers'.\n\
\n\
Email bug reports to bug-texinfo@@prep.ai.mit.edu.");
@


1.1.1.4
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* info.c -- Display nodes of Info files in multiple windows.
   $Id: info.c,v 1.10 1997/07/30 15:21:44 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 96, 97 Free Software Foundation, Inc.
a24 1
#include "indices.h"
d33 1
a33 1
int info_minor_version = 17;
a41 8
/* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike
   apropos, this puts the user at the node, running info. */
static int index_search_p = 0;

/* Variable containing the string to search for when index_search_p is
   non-zero. */ 
static char *index_search_string = (char *)NULL;

a72 1
#define IDXSRCH_OPTION 4
a83 1
  { "index-search", 1, 0, IDXSRCH_OPTION },
d98 3
a100 3
/*                                                                  */
/*                Main Entry Point to the Info Program              */
/*                                                                  */
d108 2
a109 2
  int getopt_long_index;        /* Index returned by getopt_long (). */
  NODE *initial_node;           /* First node loaded by Info. */
a112 9
#ifdef HAVE_SETLOCALE
  /* Set locale via LC_ALL.  */
  setlocale (LC_ALL, "");
#endif

  /* Set the text message domain.  */
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

d118 1
a118 1
        (argc, argv, short_options, long_options, &getopt_long_index);
d122 1
a122 1
        break;
d126 1
a126 1
        option_character = long_options[getopt_long_index].val;
d130 57
a186 64
        {
        case 0:
          break;

          /* User wants to add a directory. */
        case 'd':
          info_add_path (optarg, INFOPATH_PREPEND);
          break;

          /* User is specifying a particular node. */
        case 'n':
          add_pointer_to_array (optarg, user_nodenames_index, user_nodenames,
                                user_nodenames_slots, 10, char *);
          break;

          /* User is specifying a particular Info file. */
        case 'f':
          if (user_filename)
            free (user_filename);

          user_filename = xstrdup (optarg);
          break;

          /* User is specifying the name of a file to output to. */
        case 'o':
          if (user_output_filename)
            free (user_output_filename);
          user_output_filename = xstrdup (optarg);
          break;

          /* User is specifying that she wishes to dump the subnodes of
             the node that she is dumping. */
        case 's':
          dump_subnodes = 1;
          break;

          /* User has specified a string to search all indices for. */
        case APROPOS_OPTION:
          apropos_p = 1;
          maybe_free (apropos_search_string);
          apropos_search_string = xstrdup (optarg);
          break;

          /* User has specified a dribble file to receive keystrokes. */
        case DRIBBLE_OPTION:
          close_dribble_file ();
          open_dribble_file (optarg);
          break;

          /* User has specified an alternate input stream. */
        case RESTORE_OPTION:
          info_set_input_from_file (optarg);
          break;

          /* User has specified a string to search all indices for. */
        case IDXSRCH_OPTION:
          index_search_p = 1;
          maybe_free (index_search_string);
          index_search_string = xstrdup (optarg);
          break;

        default:
          usage ();
        }
d194 1
a194 1
      user_output_filename = xstrdup ("-");
d201 2
a202 2
      printf ("info (GNU %s %s) %s\n", PACKAGE, VERSION, version_string ());
      puts ("Copyright (C) 1997 Free Software Foundation, Inc.\n\
d216 2
a217 1
  /* If the user hasn't specified a path for Info files, default it.  */
d220 3
a222 1
      char *path_from_env = getenv ("INFOPATH");
d225 1
a225 10
        {
          unsigned len = strlen (path_from_env);
          /* Trailing : on INFOPATH means insert the default path.  */
          if (len && path_from_env[len - 1] == ':')
            {
              path_from_env[len - 1] = 0;
              info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
            }
          info_add_path (path_from_env, INFOPATH_PREPEND);
        }
d227 1
a227 1
        info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
d234 4
a237 2
      char *directory_name = xstrdup (user_filename);
      char *temp = filename_non_directory (directory_name);
d240 4
a243 4
        {
          *temp = 0;
          info_add_path (directory_name, INFOPATH_PREPEND);
        }
d258 4
a261 2
  initial_node = info_get_node (user_filename,
                                user_nodenames ? user_nodenames[0] : NULL);
d267 1
a267 1
        info_error (info_recent_file_error);
d269 2
a270 2
        info_error
          (CANT_FIND_NODE, user_nodenames ? user_nodenames[0] : "Top");
d274 4
a277 4
  /* Special cases for when the user specifies multiple nodes.  If we
     are dumping to an output file, dump all of the nodes specified.
     Otherwise, attempt to create enough windows to handle the nodes
     that this user wants displayed. */
d283 2
a284 2
        dump_nodes_to_file
          (user_filename, user_nodenames, user_output_filename, dump_subnodes);
d286 1
a286 1
        begin_multiple_window_info_session (user_filename, user_nodenames);
a290 37
  /* If the user specified `--index-search=STRING', start the info
     session in the node corresponding to the first match. */
  if (index_search_p)
    {
      int status = 0;

      initialize_info_session (initial_node, 0);

      if (index_entry_exists (windows, index_search_string))
        {
          terminal_clear_screen ();
          terminal_prep_terminal ();
          display_update_display (windows);
          info_last_executed_command = (VFunction *)NULL;

          do_info_index_search (windows, 0, index_search_string);

          info_read_and_dispatch ();

          terminal_unprep_terminal ();

          /* On program exit, leave the cursor at the bottom of the
             window, and restore the terminal IO. */
          terminal_goto_xy (0, screenheight - 1);
          terminal_clear_to_eol ();
          fflush (stdout);
        }
      else
        {
          fputs (_("no entries found\n"), stderr);
          status = 2;
        }

      close_dribble_file (); 
      exit (status);
    }

d306 2
a307 2
      if (!first_arg)
        first_arg = arg;
d313 2
a314 2
         the user continue to use Info.  Perhaps they wanted this node
         and didn't realize it. */
d316 1
a316 1
        {
d318 6
a323 6
          if (first_arg == arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
d325 4
a328 4
          begin_info_session_with_error
            (initial_node, _("There is no menu in this node."));
          exit (0);
        }
d334 1
a334 1
         user typed "buffer" when they really meant "Buffers". */
d336 16
a351 16
        {
          register int i;
          int best_guess = -1;

          for (i = 0; (entry = menu[i]); i++)
            {
              if (strcasecmp (entry->label, arg) == 0)
                break;
              else
                if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
                  best_guess = i;
            }

          if (!entry && best_guess != -1)
            entry = menu[best_guess];
        }
d354 1
a354 1
         node anyway.  It is probably a misspelling. */
d356 2
a357 2
        {
          char *error_message = _("There is no menu item \"%s\" in this node.");
d360 6
a365 6
          if (first_arg == arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
d368 1
a368 1
          info_free_references (menu);
d370 5
a374 5
          /* If we were supposed to dump this node, complain. */
          if (user_output_filename)
            info_error (error_message, arg);
          else
            begin_info_session_with_error (initial_node, error_message, arg);
d376 2
a377 2
          exit (0);
        }
d380 1
a380 1
         up a little bit. */
d382 6
a387 6
        {
          if (initial_node->parent)
            entry->filename = xstrdup (initial_node->parent);
          else
            entry->filename = xstrdup (initial_node->filename);
        }
d390 4
a393 4
         into this one.  If we cannot find it, try using the label of the
         entry as a file (i.e., "(LABEL)Top").  Otherwise the Info file is
         malformed in some way, and we will just use the current value of
         initial node. */
d397 6
a402 6
          if ((first_arg == arg) && !node)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
d406 2
a407 2
          (strcmp (entry->label, entry->nodename) == 0))
        node = info_get_node (entry->label, "Top");
d411 5
a415 5
        {
          free (initial_node);
          initial_node = node;
          info_free_references (menu);
        }
d417 14
a430 14
        {
          char *temp = xstrdup (entry->label);
          char *error_message;

          error_message = _("Unable to find the node referenced by \"%s\".");

          info_free_references (menu);

          /* If we were trying to dump the node, then give up.  Otherwise,
             start the session with an error message. */
          if (user_output_filename)
            info_error (error_message, temp);
          else
            begin_info_session_with_error (initial_node, error_message, temp);
d432 2
a433 2
          exit (0);
        }
d457 1
a457 1
        sprintf (vstring + strlen (vstring), "-p%d", info_patch_level);
d463 3
a465 3
/*                                                                  */
/*                 Error Handling for Info                          */
/*                                                                  */
d477 1
a477 1
  program_name = xstrdup (filename);
d506 5
a510 5
        {
          if (info_error_rings_bell_p)
            terminal_ring_bell ();
          window_message_in_echo_area (format, arg1, arg2);
        }
d512 2
a513 2
        {
          NODE *temp;
d515 7
a521 7
          temp = build_message_node (format, arg1, arg2);
          if (info_error_rings_bell_p)
            terminal_ring_bell ();
          inform_in_echo_area (temp->contents);
          free (temp->contents);
          free (temp);
        }
d531 5
a535 5
_("Usage: info [-d dir-path] [-f info-file] [-o output-file] [-n node-name]..."),
_("            [--directory dir-path] [--file info-file] [--node node-name]..."),
_("            [--help] [--output output-file] [--subnodes] [--version]"),
_("            [--dribble dribble-file] [--restore from-file]"),
_("            [menu-selection ...]"));
d543 1
a543 1
  puts (_("\
d547 9
a555 9
   --directory DIR              Add DIR to INFOPATH.\n\
   --dribble FILENAME           Remember user keystrokes in FILENAME.\n\
   --file FILENAME              Specify Info file to visit.\n\
   --node NODENAME              Specify nodes in first visited Info file.\n\
   --output FILENAME            Output selected nodes to FILENAME.\n\
   --restore FILENAME           Read initial keystrokes from FILENAME.\n\
   --subnodes                   Recursively output menu items.\n\
   --help                       Get this help message.\n\
   --version                    Display Info's version information.\n\
d562 1
a562 1
Email bug reports to bug-texinfo@@prep.ai.mit.edu."));
@


1.1.1.5
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: info.c,v 1.18 1998/02/27 21:37:27 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97, 98 Free Software Foundation, Inc.
d32 2
a33 4
int info_minor_version = 18;

/* basename (argv[0]) */
static char *program_name = NULL;
d103 1
a103 1
static void info_short_help (), remember_info_program_name ();
d210 1
a210 2
          fprintf (stderr, _("Try --help for more information."));
          exit (1);
d226 2
a227 3
      printf ("%s (GNU %s %s) %s\n", program_name, PACKAGE, VERSION, 
              version_string ());
      printf (_("Copyright (C) %s Free Software Foundation, Inc.\n\
d230 1
a230 2
For more information about these matters, see the files named COPYING.\n"),
		  "1998");
d241 1
a241 4
  /* If the user hasn't specified a path for Info files, default it.
     Lowest priority is our messy hardwired list in filesys.h.
     Then comes the user's INFODIR from the Makefile.
     Highest priority is the environment variable, if set.  */
a254 3
#ifdef INFODIR /* from the Makefile */
          info_add_path (INFODIR, INFOPATH_PREPEND);
#endif
d258 1
a258 6
        {
          info_add_path (DEFAULT_INFOPATH, INFOPATH_PREPEND);
#ifdef INFODIR /* from the Makefile */
         info_add_path (INFODIR, INFOPATH_PREPEND);
#endif
        }
d520 2
d525 6
d532 1
a532 2

/* Error handling.  */
d589 14
d607 3
a609 5
  printf (_("\
Usage: %s [OPTION]... [INFO-FILE [MENU-ITEM...]]\n\
\n\
Read documentation in Info format.\n\
For more complete documentation on how to use Info, run `info info options'.\n\
d611 9
a619 10
Options:\n\
--directory DIR              add DIR to INFOPATH.\n\
--dribble FILENAME           remember user keystrokes in FILENAME.\n\
--file FILENAME              specify Info file to visit.\n\
--node NODENAME              specify nodes in first visited Info file.\n\
--output FILENAME            output selected nodes to FILENAME.\n\
--restore FILENAME           read initial keystrokes from FILENAME.\n\
--subnodes                   recursively output menu items.\n\
--help                       display this help and exit.\n\
--version                    display version information and exit.\n\
d621 4
a624 4
The first argument, if present, is the name of the Info file to read.\n\
Any remaining arguments are treated as the names of menu\n\
items in the initial node visited.  For example, `info emacs buffers'\n\
moves to the node `buffers' in the info file `emacs'.\n\
d626 1
a626 1
Email bug reports to bug-texinfo@@gnu.org."), program_name);
@


1.1.1.6
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: info.c,v 1.41 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97, 98, 99 Free Software Foundation, Inc.
d30 6
a35 1
static char *program_name = "info";
a46 5
/* Non-zero means look for the node which describes the invocation
   and command-line options of the program, and start the info
   session at that node.  */
static int goto_invocation_p = 0;

d48 1
a48 1
   non-zero. */
a75 12
/* Non-zero means make default keybindings be loosely modeled on vi(1).  */
int vi_keys_p = 0;

#ifdef __MSDOS__
/* Non-zero indicates that screen output should be made 'speech-friendly'.
   Since on MSDOS the usual behavior is to write directly to the video
   memory, speech synthesizer software cannot grab the output.  Therefore,
   we provide a user option which tells us to avoid direct screen output
   and use stdout instead (which loses the color output).  */
int speech_friendly = 0;
#endif

a89 3
  { "show-options", 0, 0, 'O' },
  { "usage", 0, 0, 'O' },
  { "vi-keys", 0, &vi_keys_p, 1 },
a93 3
#ifdef __MSDOS__
  { "speech-friendly", 0, &speech_friendly, 1 },
#endif
d99 1
a99 5
#ifdef __MSDOS__
static char *short_options = "d:n:f:o:Osb";
#else
static char *short_options = "d:n:f:o:Os";
#endif
a105 1
static void init_messages ();
d122 2
a132 2
  init_messages ();
  
a179 6
         /* User has specified that she wants to find the "Options"
             or "Invocation" node for the program.  */
        case 'O':
          goto_invocation_p = 1;
          break;

a185 7
#ifdef __MSDOS__
	  /* User specifies that she wants speech-friendly output.  */
	case 'b':
	  speech_friendly = 1;
	  break;
#endif /* __MSDOS__ */

d212 2
a213 2
          fprintf (stderr, _("Try --help for more information.\n"));
          xexit (1);
d229 2
a230 2
      printf ("%s (GNU %s) %s\n", program_name, PACKAGE, VERSION);
      puts ("");
d235 2
a236 2
		  "1999");
      xexit (0);
d243 1
a243 1
      xexit (0);
d245 1
a245 1

d258 1
a258 1
          if (len && path_from_env[len - 1] == PATH_SEP[0])
d286 1
a286 8
	  if (HAVE_DRIVE (directory_name) && temp == directory_name + 2)
	    {
	      /* The directory of "d:foo" is stored as "d:.", to avoid
		 mixing it with "d:/" when a slash is appended.  */
	      *temp = '.';
	      temp += 2;
	    }
          temp[-1] = 0;
d298 1
a298 1
      xexit (0);
d304 1
a304 1
                                user_nodenames ? user_nodenames[0] : 0);
d312 3
a314 3
        info_error (msg_cant_find_node,
                    user_nodenames ? user_nodenames[0] : "Top");
      xexit (1);
d331 38
a368 1
      xexit (0);
d375 74
a448 91
  {
    char *errstr, *errarg1, *errarg2;
    NODE *new_initial_node = info_follow_menus (initial_node, argv + optind,
                                                &errstr, &errarg1, &errarg2);
    if (new_initial_node && new_initial_node != initial_node)
      initial_node = new_initial_node;

    /* If the user specified that this node should be output, then do that
       now.  Otherwise, start the Info session with this node.  Or act
       accordingly if the initial node was not found.  */
    if (user_output_filename)
      {
        if (!errstr)
          dump_node_to_file (initial_node, user_output_filename,
                             dump_subnodes);
        else
          info_error (errstr, errarg1, errarg2);
      }
    else
      {

        if (errstr)
          begin_info_session_with_error (initial_node, errstr,
                                         errarg1, errarg2);
        /* If the user specified `--index-search=STRING' or
           --show-options, start the info session in the node
           corresponding to what they want. */
        else if (index_search_p || goto_invocation_p)
          {
            int status = 0;

            initialize_info_session (initial_node, 0);

            if (goto_invocation_p
                || index_entry_exists (windows, index_search_string))
              {
                terminal_prep_terminal ();
                terminal_clear_screen ();
                info_last_executed_command = (VFunction *)NULL;

                if (index_search_p)
                  do_info_index_search (windows, 0, index_search_string);
                else
                  {
                    /* If they said "info --show-options foo bar baz",
                       the last of the arguments is the program whose
                       options they want to see.  */
                    char **p = argv + optind;
                    char *program;

                    if (*p)
                      {
                        while (p[1])
                          p++;
                        program = xstrdup (*p);
                      }
                    else if (user_filename)
		      /* If there's no command-line arguments to
			 supply the program name, use the Info file
			 name (sans extension and leading directories)
			 instead.  */
		      program = program_name_from_file_name (user_filename);
		    else
		      program = xstrdup ("");

                    info_intuit_options_node (windows, initial_node, program);
                    free (program);
                  }

                info_read_and_dispatch ();

                /* On program exit, leave the cursor at the bottom of the
                   window, and restore the terminal IO. */
                terminal_goto_xy (0, screenheight - 1);
                terminal_clear_to_eol ();
                fflush (stdout);
                terminal_unprep_terminal ();
              }
            else
              {
                fprintf (stderr, _("no index entries found for `%s'\n"),
                         index_search_string);
                status = 2;
              }

            close_dribble_file ();
            xexit (status);
          }
        else
          begin_info_session (initial_node);
      }
d450 88
a537 2
    xexit (0);
  }
d543 10
a597 1

d603 1
a603 1
Usage: %s [OPTION]... [MENU-ITEM...]\n\
d606 1
d609 9
a617 13
 --apropos=SUBJECT        look up SUBJECT in all indices of all manuals.\n\
 --directory=DIR          add DIR to INFOPATH.\n\
 --dribble=FILENAME       remember user keystrokes in FILENAME.\n\
 --file=FILENAME          specify Info file to visit.\n\
 --help                   display this help and exit.\n\
 --index-search=STRING    go to node pointed by index entry STRING.\n\
 --node=NODENAME          specify nodes in first visited Info file.\n\
 --output=FILENAME        output selected nodes to FILENAME.\n\
 --restore=FILENAME       read initial keystrokes from FILENAME.\n\
 --show-options, --usage  go to command-line options node.\n\
 --subnodes               recursively output menu items.\n%s\
 --vi-keys                use vi-like and less-like key bindings.\n\
 --version                display version information and exit.\n\
d619 1
a619 3
The first non-option argument, if present, is the menu entry to start from;\n\
it is searched for in all `dir' files along INFOPATH.\n\
If it is not present, info merges all `dir' files and shows the result.\n\
d621 2
a622 8
items relative to the initial node visited.\n\
\n\
Examples:\n\
  info                       show top-level dir menu\n\
  info emacs                 start at emacs node from top-level dir\n\
  info emacs buffers         start at buffers node within emacs manual\n\
  info --show-options emacs  start at node with emacs' command line options\n\
  info -f ./foo.info         show file ./foo.info, not searching dir\n\
d624 1
a624 11
Email bug reports to bug-texinfo@@gnu.org,\n\
general questions and discussion to help-texinfo@@gnu.org.\n\
"),
  program_name,
#ifdef __MSDOS__
"\
 --speech-friendly        be friendly to speech synthesizers.\n"
#else
""
#endif
	  );
d626 1
a626 45
  xexit (0);
}


/* Initialize strings for gettext.  Because gettext doesn't handle N_ or
   _ within macro definitions, we put shared messages into variables and
   use them that way.  This also has the advantage that there's only one
   copy of the strings.  */

char *msg_cant_find_node;
char *msg_cant_file_node;
char *msg_cant_find_window;
char *msg_cant_find_point;
char *msg_cant_kill_last;
char *msg_no_menu_node;
char *msg_no_foot_node;
char *msg_no_xref_node;
char *msg_no_pointer;
char *msg_unknown_command;
char *msg_term_too_dumb;
char *msg_at_node_bottom;
char *msg_at_node_top;
char *msg_one_window;
char *msg_win_too_small;
char *msg_cant_make_help;

static void
init_messages ()
{
  msg_cant_find_node   = _("Cannot find node `%s'.");
  msg_cant_file_node   = _("Cannot find node `(%s)%s'.");
  msg_cant_find_window = _("Cannot find a window!");
  msg_cant_find_point  = _("Point doesn't appear within this window's node!");
  msg_cant_kill_last   = _("Cannot delete the last window.");
  msg_no_menu_node     = _("No menu in this node.");
  msg_no_foot_node     = _("No footnotes in this node.");
  msg_no_xref_node     = _("No cross references in this node.");
  msg_no_pointer       = _("No `%s' pointer for this node.");
  msg_unknown_command  = _("Unknown Info command `%c'; try `?' for help.");
  msg_term_too_dumb    = _("Terminal type `%s' is not smart enough to run Info.");
  msg_at_node_bottom   = _("You are already at the last page of this node.");
  msg_at_node_top      = _("You are already at the first page of this node.");
  msg_one_window       = _("Only one window.");
  msg_win_too_small    = _("Resulting window would be too small.");
  msg_cant_make_help   = _("Not enough room for a help window, please delete a window.");
@


1.1.1.7
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: info.c,v 1.60 2002/03/11 19:54:29 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc.
a78 3
/* Non-zero means don't remove ANSI escape sequences from man pages.  */
int raw_escapes_p = 0;

d98 1
a98 1
  { "dribble", 1, 0, DRIBBLE_OPTION },
d100 1
a100 3
  { "help", 0, &print_help_p, 1 },
  { "index-search", 1, 0, IDXSRCH_OPTION },
  { "node", 1, 0, 'n' },
a101 2
  { "raw-escapes", 0, &raw_escapes_p, 1 },
  { "restore", 1, 0, RESTORE_OPTION },
a102 1
  { "subnodes", 0, &dump_subnodes, 1 },
d104 2
d107 2
a108 1
  { "vi-keys", 0, &vi_keys_p, 1 },
d112 1
d118 1
a118 1
static char *short_options = "d:n:f:o:ORsb";
d120 1
a120 1
static char *short_options = "d:n:f:o:ORs";
a128 1
extern void add_file_directory_to_path ();
a208 6
	  /* User has specified that she wants the escape sequences
	     in man pages to be passed thru unaltered.  */
        case 'R':
          raw_escapes_p = 1;
          break;

d216 1
a216 1
	  /* User wants speech-friendly output.  */
d271 1
a271 1
		  "2002");
d316 19
a334 1
    add_file_directory_to_path (user_filename);
a384 1

d391 1
a391 1
    if (user_output_filename && !goto_invocation_p)
d450 1
a450 7
		if (user_output_filename)
		  {
		    dump_node_to_file (windows->node, user_output_filename,
				       dump_subnodes);
		  }
		else
		  info_read_and_dispatch ();
a476 23
void
add_file_directory_to_path (filename)
     char *filename;
{
  char *directory_name = xstrdup (filename);
  char *temp = filename_non_directory (directory_name);

  if (temp != directory_name)
    {
      if (HAVE_DRIVE (directory_name) && temp == directory_name + 2)
	{
	  /* The directory of "d:foo" is stored as "d:.", to avoid
	     mixing it with "d:/" when a slash is appended.  */
	  *temp = '.';
	  temp += 2;
	}
      temp[-1] = 0;
      info_add_path (directory_name, INFOPATH_PREPEND);
    }

  free (directory_name);
}

a529 8
#ifdef __MSDOS__
  static const char speech_friendly_string[] = N_("\
  -b, --speech-friendly        be friendly to speech synthesizers.\n");
#else
  static const char speech_friendly_string[] = "";
#endif

    
d536 13
a548 14
      --apropos=STRING         look up STRING in all indices of all manuals.\n\
  -d, --directory=DIR          add DIR to INFOPATH.\n\
      --dribble=FILENAME       remember user keystrokes in FILENAME.\n\
  -f, --file=FILENAME          specify Info file to visit.\n\
  -h, --help                   display this help and exit.\n\
      --index-search=STRING    go to node pointed by index entry STRING.\n\
  -n, --node=NODENAME          specify nodes in first visited Info file.\n\
  -o, --output=FILENAME        output selected nodes to FILENAME.\n\
  -R, --raw-escapes            don't remove ANSI escapes from man pages.\n\
      --restore=FILENAME       read initial keystrokes from FILENAME.\n\
  -O, --show-options, --usage  go to command-line options node.\n%s\
      --subnodes               recursively output menu items.\n\
      --vi-keys                use vi-like and less-like key bindings.\n\
      --version                display version information and exit.\n\
d562 1
a562 4
"),
  program_name, speech_friendly_string);

  puts (_("\n\
d565 9
a573 1
Texinfo home page: http://www.gnu.org/software/texinfo/"));
@


1.1.1.8
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: info.c,v 1.11 2004/04/11 17:56:45 karl Exp $
d4 2
a5 2
   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d80 2
a81 5
/* Non-zero means don't remove ANSI escape sequences.  */
int raw_escapes_p = 1;

/* Non-zero means print the absolute location of the file to be loaded.  */
static int print_where_p = 0;
a105 1
  { "location", 0, &print_where_p, 1 },
a108 1
  { "no-raw-escapes", 0, &raw_escapes_p, 0 },
a114 1
  { "where", 0, &print_where_p, 1 },
d123 1
a123 1
static char *short_options = "d:n:f:ho:ORswb";
d125 1
a125 1
static char *short_options = "d:n:f:ho:ORws";
d132 3
a134 2
static void info_short_help (void);
static void init_messages (void);
d144 3
a146 1
main (int argc, char **argv)
a155 1
#ifdef ENABLE_NLS
a158 1
#endif
d161 1
a161 1

d169 1
a169 1
      /* getopt_long returns EOF when there are no more long options. */
a201 5
          /* Treat -h like --help. */
        case 'h':
          print_help_p = 1;
          break;

a226 5
          /* For compatibility with man, -w is --where.  */
        case 'w':
          print_where_p = 1;
          break;

d279 2
a280 2
      puts ("Copyright (C) 2004 Free Software Foundation, Inc.");
      printf (_("There is NO warranty.  You may redistribute this software\n\
d282 2
a283 1
For more information about these matters, see the files named COPYING.\n"));
d320 1
a320 7
          info_add_path (INFODIR, INFOPATH_PREPEND);
#endif
#ifdef INFODIR2 /* from the Makefile, too */
#  ifdef INFODIR
          if (!STREQ (INFODIR, INFODIR2))
#  endif
            info_add_path (INFODIR2, INFOPATH_PREPEND);
d347 1
a347 1
        info_error (info_recent_file_error, NULL, NULL);
d349 2
a350 2
        info_error ((char *) msg_cant_find_node,
                    user_nodenames ? user_nodenames[0] : "Top", NULL);
d362 1
a362 3
      if (print_where_p)
        printf ("%s\n", user_filename ? user_filename : "unknown?!");
      else if (user_output_filename)
d376 1
a376 3
    const char *errstr;
    char *errarg1, *errarg2;

d378 1
a378 1
        &errstr, &errarg1, &errarg2);
a382 12
    if (print_where_p)
      {
        if (initial_node->parent)
          printf ("%s\n", initial_node->parent);
        else if (initial_node->filename
            && !is_dir_name (filename_non_directory (initial_node->filename)))
          printf ("%s\n", initial_node->filename);
        else
          xexit (1);
        xexit (0);
      }

d392 1
a392 1
          info_error ((char *) errstr, errarg1, errarg2);
d398 2
a399 2
          begin_info_session_with_error (initial_node, (char *) errstr,
              errarg1, errarg2);
a475 2

  return 0; /* Avoid bogus warnings.  */
d479 2
a480 1
add_file_directory_to_path (char *filename)
d514 3
a516 1
info_error (char *format, void *arg1, void *arg2)
d552 1
a552 1
info_short_help (void)
d561 1
a561 1

d576 1
a576 2
  -R, --raw-escapes            output \"raw\" ANSI escapes (default).\n\
      --no-raw-escapes         output escapes as literal text.\n\
a579 1
  -w, --where, --location      print physical location of Info file.\n\
d612 16
a627 16
const char *msg_cant_find_node;
const char *msg_cant_file_node;
const char *msg_cant_find_window;
const char *msg_cant_find_point;
const char *msg_cant_kill_last;
const char *msg_no_menu_node;
const char *msg_no_foot_node;
const char *msg_no_xref_node;
const char *msg_no_pointer;
const char *msg_unknown_command;
const char *msg_term_too_dumb;
const char *msg_at_node_bottom;
const char *msg_at_node_top;
const char *msg_one_window;
const char *msg_win_too_small;
const char *msg_cant_make_help;
d630 1
a630 1
init_messages (void)
@


