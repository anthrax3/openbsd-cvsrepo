head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.52;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.25.06;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.13;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.45;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* makedoc.c -- make doc.c and funs.h from input files.
   $Id: makedoc.c,v 1.4 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Originally written by Brian Fox (bfox@@ai.mit.edu). */

/* This program grovels the contents of the source files passed as arguments
   and writes out a file of function pointers and documentation strings, and
   a header file which describes the contents.  This only does the functions
   declared with DECLARE_INFO_COMMAND. */

#include "info.h"
#include "infokey.h"

static void fatal_file_error (char *filename);

/* Name of the header file which receives the declarations of functions. */
static char *funs_filename = "funs.h";

/* Name of the documentation to function pointer file. */
static char *doc_filename = "doc.c";
static char *key_filename = "key.c";

static char *doc_header[] = {
  "/* doc.c -- Generated structure containing function names and doc strings.",
  "",
  "   This file was automatically made from various source files with the",
  "   command `%s'.  DO NOT EDIT THIS FILE, only `%s.c'.",
  (char *)NULL
};

static char *doc_header_1[] = {
  "   An entry in the array FUNCTION_DOC_ARRAY is made for each command",
  "   found in the above files; each entry consists of a function pointer,",
#if defined (NAMED_FUNCTIONS)
  "   a string which is the user-visible name of the function,",
#endif /* NAMED_FUNCTIONS */
  "   and a string which documents its purpose. */",
  "",
  "#include \"info.h\"",
  "#include \"funs.h\"",
  "",
  "FUNCTION_DOC function_doc_array[] = {",
  "",
  (char *)NULL
};

static char *key_header[] = {
  "/* key.c -- Generated array containing function names.",
  "",
  "   This file was automatically made from various source files with the",
  "   command \"%s\".  DO NOT EDIT THIS FILE, only \"%s.c\".",
  "",
  (char *)NULL
};

static char *key_header_1[] = {
  "   An entry in the array FUNCTION_KEY_ARRAY is made for each command",
  "   found in the above files; each entry consists of",
  "   a string which is the user-visible name of the function.  */",
  "",
  "#include \"key.h\"",
  "#include \"funs.h\"",
  "",
  "FUNCTION_KEY function_key_array[] = {",
  "",
  (char *)NULL
};

/* How to remember the locations of the functions found so that Emacs
   can use the information in a tag table. */
typedef struct {
  char *name;                   /* Name of the tag. */
  int line;                     /* Line number at which it appears. */
  long char_offset;             /* Character offset at which it appears. */
} EMACS_TAG;

typedef struct {
  char *filename;               /* Name of the file containing entries. */
  long entrylen;                /* Total number of characters in tag block. */
  EMACS_TAG **entries;          /* Entries found in FILENAME. */
  int entries_index;
  int entries_slots;
} EMACS_TAG_BLOCK;

EMACS_TAG_BLOCK **emacs_tags = (EMACS_TAG_BLOCK **)NULL;
int emacs_tags_index = 0;
int emacs_tags_slots = 0;

#define DECLARATION_STRING "\nDECLARE_INFO_COMMAND"

static void process_one_file (char *filename, FILE *doc_stream,
    FILE *key_stream, FILE *funs_stream);
static void maybe_dump_tags (FILE *stream);
static FILE *must_fopen (char *filename, char *mode);
static void init_func_key (unsigned int val);
static unsigned int next_func_key (void);

int
main (int argc, char **argv)
{
  register int i;
  int tags_only = 0;
  FILE *funs_stream, *doc_stream;
  FILE *key_stream;

#if STRIP_DOT_EXE
  {
    char *dot = strrchr (argv[0], '.');

    if (dot && FILENAME_CMP (dot, ".exe") == 0)
      *dot = 0;
  }
#endif

  for (i = 1; i < argc; i++)
    if (strcmp (argv[i], "-tags") == 0)
      {
        tags_only++;
        break;
      }

  if (tags_only)
    {
      funs_filename = NULL_DEVICE;
      doc_filename = NULL_DEVICE;
      key_filename = NULL_DEVICE;
    }

  funs_stream = must_fopen (funs_filename, "w");
  doc_stream = must_fopen (doc_filename, "w");
  key_stream = must_fopen (key_filename, "w");

  fprintf (funs_stream,
      "/* %s -- Generated declarations for Info commands. */\n\n\
#include \"info.h\"\n",
      funs_filename);

  for (i = 0; doc_header[i]; i++)
    {
      fprintf (doc_stream, doc_header[i], argv[0], argv[0]);
      fprintf (doc_stream, "\n");
    }

  fprintf (doc_stream,
           _("   Source files groveled to make this file include:\n\n"));

  for (i = 0; key_header[i]; i++)
    {
      fprintf (key_stream, key_header[i], argv[0], argv[0]);
      fprintf (key_stream, "\n");
    }
  fprintf (key_stream,
           _("   Source files groveled to make this file include:\n\n"));

  for (i = 1; i < argc; i++)
    {
      fprintf (doc_stream, "\t%s\n", argv[i]);
      fprintf (key_stream, "\t%s\n", argv[i]);
    }

  fprintf (doc_stream, "\n");
  for (i = 0; doc_header_1[i]; i++)
    fprintf (doc_stream, "%s\n", doc_header_1[i]);

  fprintf (key_stream, "\n");
  for (i = 0; key_header_1[i]; i++)
    fprintf (key_stream, "%s\n", key_header_1[i]);

  init_func_key(0);

  for (i = 1; i < argc; i++)
    {
      char *curfile;
      curfile = argv[i];

      if (*curfile == '-')
        continue;

      fprintf (doc_stream, "/* Commands found in \"%s\". */\n", curfile);
      fprintf (key_stream, "/* Commands found in \"%s\". */\n", curfile);
      fprintf (funs_stream, "\n/* Functions declared in \"%s\". */\n",
               curfile);

      process_one_file (curfile, doc_stream, key_stream, funs_stream);
    }

#if defined (INFOKEY)

#if defined (NAMED_FUNCTIONS)
  fprintf (doc_stream,
           "   { (VFunction *)NULL, (char *)NULL, (FUNCTION_KEYSEQ *)NULL, (char *)NULL }\n};\n");
#else /* !NAMED_FUNCTIONS */
  fprintf (doc_stream, "   { (VFunction *)NULL, (FUNCTION_KEYSEQ *)NULL, (char *)NULL }\n};\n");
#endif /* !NAMED_FUNCTIONS */

#else /* !INFOKEY */

#if defined (NAMED_FUNCTIONS)
  fprintf (doc_stream,
           "   { (VFunction *)NULL, (char *)NULL, (char *)NULL }\n};\n");
#else /* !NAMED_FUNCTIONS */
  fprintf (doc_stream, "   { (VFunction *)NULL, (char *)NULL }\n};\n");
#endif /* !NAMED_FUNCTIONS */

#endif /* !INFOKEY */

  fprintf (key_stream, "   { (char *)NULL, 0 }\n};\n");
  fprintf (funs_stream, "\n#define A_NCOMMANDS %u\n", next_func_key());

  fclose (funs_stream);
  fclose (doc_stream);
  fclose (key_stream);

  if (tags_only)
    maybe_dump_tags (stdout);
  return 0;
}

/* Dumping out the contents of an Emacs tags table. */
static void
maybe_dump_tags (FILE *stream)
{
  register int i;

  /* Emacs needs its TAGS file to be in Unix text format (i.e., only
     newline at end of every line, no CR), so when we generate a
     TAGS table, we must switch the output stream to binary mode.
     (If the table is written to a terminal, this is obviously not needed.) */
  SET_BINARY (fileno (stream));

  /* Print out the information for each block. */
  for (i = 0; i < emacs_tags_index; i++)
    {
      register int j;
      register EMACS_TAG_BLOCK *block;
      register EMACS_TAG *etag;
      long block_len;

      block_len = 0;
      block = emacs_tags[i];

      /* Calculate the length of the dumped block first. */
      for (j = 0; j < block->entries_index; j++)
        {
          char digits[30];
          etag = block->entries[j];
          block_len += 3 + strlen (etag->name);
          sprintf (digits, "%d,%ld", etag->line, etag->char_offset);
          block_len += strlen (digits);
        }

      /* Print out the defining line. */
      fprintf (stream, "\f\n%s,%ld\n", block->filename, block_len);

      /* Print out the individual tags. */
      for (j = 0; j < block->entries_index; j++)
        {
          etag = block->entries[j];

          fprintf (stream, "%s,\177%d,%ld\n",
                   etag->name, etag->line, etag->char_offset);
        }
    }
}

/* Keeping track of names, line numbers and character offsets of functions
   found in source files. */
static EMACS_TAG_BLOCK *
make_emacs_tag_block (char *filename)
{
  EMACS_TAG_BLOCK *block;

  block = (EMACS_TAG_BLOCK *)xmalloc (sizeof (EMACS_TAG_BLOCK));
  block->filename = xstrdup (filename);
  block->entrylen = 0;
  block->entries = (EMACS_TAG **)NULL;
  block->entries_index = 0;
  block->entries_slots = 0;
  return (block);
}

static void
add_tag_to_block (EMACS_TAG_BLOCK *block,
    char *name, int line, long int char_offset)
{
  EMACS_TAG *tag;

  tag = (EMACS_TAG *)xmalloc (sizeof (EMACS_TAG));
  tag->name = name;
  tag->line = line;
  tag->char_offset = char_offset;
  add_pointer_to_array (tag, block->entries_index, block->entries,
                        block->entries_slots, 50, EMACS_TAG *);
}

/* Read the file represented by FILENAME into core, and search it for Info
   function declarations.  Output the declarations in various forms to the
   DOC_STREAM, KEY_STREAM, and FUNS_STREAM. */
static void
process_one_file (char *filename, FILE *doc_stream,
    FILE *key_stream, FILE *funs_stream)
{
  int descriptor, decl_len;
  char *buffer, *decl_str;
  struct stat finfo;
  long offset;
  long file_size;
  EMACS_TAG_BLOCK *block;

  if (stat (filename, &finfo) == -1)
    fatal_file_error (filename);

  descriptor = open (filename, O_RDONLY, 0666);

  if (descriptor == -1)
    fatal_file_error (filename);

  file_size = (long) finfo.st_size;
  buffer = (char *)xmalloc (1 + file_size);
  /* On some systems, the buffer will actually contain
     less characters than the full file's size, because
     the CR characters are removed from line endings.  */
  file_size = read (descriptor, buffer, file_size);
  close (descriptor);

  offset = 0;
  decl_str = DECLARATION_STRING;
  decl_len = strlen (decl_str);

  block = make_emacs_tag_block (filename);

  while (1)
    {
      long point = 0;
      long line_start = 0;
      int line_number = 0;

      char *func, *doc;
#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
      char *func_name;
#endif /* INFOKEY || NAMED_FUNCTIONS */

      for (; offset < (file_size - decl_len); offset++)
        {
          if (buffer[offset] == '\n')
            {
              line_number++;
              line_start = offset + 1;
            }

          if (strncmp (buffer + offset, decl_str, decl_len) == 0)
            {
              offset += decl_len;
              point = offset;
              break;
            }
        }

      if (!point)
        break;

      /* Skip forward until we find the open paren. */
      while (point < file_size)
        {
          if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }
          else if (buffer[point] == '(')
            break;

          point++;
        }

      while (point++ < file_size)
        {
          if (!whitespace_or_newline (buffer[point]))
            break;
          else if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }
        }

      if (point >= file_size)
        break;

      /* Now looking at name of function.  Get it. */
      for (offset = point; buffer[offset] != ','; offset++);
      func = (char *)xmalloc (1 + (offset - point));
      strncpy (func, buffer + point, offset - point);
      func[offset - point] = '\0';

      /* Remember this tag in the current block. */
      {
        char *tag_name;

        tag_name = (char *)xmalloc (1 + (offset - line_start));
        strncpy (tag_name, buffer + line_start, offset - line_start);
        tag_name[offset - line_start] = '\0';
        add_tag_to_block (block, tag_name, line_number, point);
      }

#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
      /* Generate the user-visible function name from the function's name. */
      {
        register int i;
        char *name_start;

        name_start = func;

        if (strncmp (name_start, "info_", 5) == 0)
          name_start += 5;

        func_name = xstrdup (name_start);

        /* Fix up "ea" commands. */
        if (strncmp (func_name, "ea_", 3) == 0)
          {
            char *temp_func_name;

            temp_func_name = (char *)xmalloc (10 + strlen (func_name));
            strcpy (temp_func_name, "echo_area_");
            strcat (temp_func_name, func_name + 3);
            free (func_name);
            func_name = temp_func_name;
          }

        for (i = 0; func_name[i]; i++)
          if (func_name[i] == '_')
            func_name[i] = '-';
      }
#endif /* INFOKEY || NAMED_FUNCTIONS */

      /* Find doc string. */
      point = offset + 1;

      while (point < file_size)
        {
          if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }

          if (buffer[point] == '"')
            break;
          else
            point++;
        }

      offset = point + 1;

      while (offset < file_size)
        {
          if (buffer[offset] == '\n')
            {
              line_number++;
              line_start = offset + 1;
            }

          if (buffer[offset] == '\\')
            offset += 2;
          else if (buffer[offset] == '"')
            break;
          else
            offset++;
        }

      offset++;
      if (offset >= file_size)
        break;

      doc = (char *)xmalloc (1 + (offset - point));
      strncpy (doc, buffer + point, offset - point);
      doc[offset - point] = '\0';

#if defined (INFOKEY)

#if defined (NAMED_FUNCTIONS)
      fprintf (doc_stream,
          "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },\n",
          func, func_name, doc);
#else /* !NAMED_FUNCTIONS */
      fprintf (doc_stream,
          "   { (VFunction *) %s, (FUNCTION_KEYSEQ *)0, %s },\n", func, doc);
#endif /* !NAMED_FUNCTIONS */

      fprintf (key_stream, "   { \"%s\", A_%s },\n", func_name, func);

#else /* !INFOKEY */

#if defined (NAMED_FUNCTIONS)
      fprintf (doc_stream, "   { %s, \"%s\", %s },\n", func, func_name, doc);
#else /* !NAMED_FUNCTIONS */
      fprintf (doc_stream, "   { %s, %s },\n", func, doc);
#endif /* !NAMED_FUNCTIONS */

#endif /* !INFOKEY */

#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
      free (func_name);
#endif /* INFOKEY || NAMED_FUNCTIONS */

#if defined (INFOKEY)
      fprintf (funs_stream, "#define A_%s %u\n", func, next_func_key());
#endif /* INFOKEY */
      fprintf (funs_stream,
          "extern void %s (WINDOW *window, int count, unsigned char key);\n",
          func);
      free (func);
      free (doc);
    }
  free (buffer);

  /* If we created any tags, remember this file on our global list.  Otherwise,
     free the memory already allocated to it. */
  if (block->entries)
    add_pointer_to_array (block, emacs_tags_index, emacs_tags,
                          emacs_tags_slots, 10, EMACS_TAG_BLOCK *);
  else
    {
      free (block->filename);
      free (block);
    }
}

static void
fatal_file_error (char *filename)
{
  fprintf (stderr, _("Couldn't manipulate the file %s.\n"), filename);
  xexit (2);
}

static FILE *
must_fopen (char *filename, char *mode)
{
  FILE *stream;

  stream = fopen (filename, mode);
  if (!stream)
    fatal_file_error (filename);

  return (stream);
}

static unsigned int func_key;

static void
init_func_key(unsigned int val)
{
	func_key = val;
}

static unsigned int
next_func_key(void)
{
	return func_key++;
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: makedoc.c,v 1.10 2001/11/16 23:15:21 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 99, 2001 Free Software Foundation, Inc.
d21 1
a21 1
   Written by Brian Fox (bfox@@ai.mit.edu). */
d31 1
a31 1
static void fatal_file_error ();
d44 1
a44 1
  "   command \"%s\".  DO NOT EDIT THIS FILE, only \"%s.c\".",
d108 6
a113 5
static void process_one_file ();
static void maybe_dump_tags ();
static FILE *must_fopen ();
static void init_func_key ();
static unsigned int next_func_key ();
d116 1
a116 3
main (argc, argv)
     int argc;
     char **argv;
d145 1
a145 1
  
d151 3
a153 2
           "/* %s -- Generated declarations for Info commands. */\n",
           funs_filename);
d224 1
a224 1
  fprintf (key_stream, "   (char *)0\n};\n");
d233 1
a233 1
  xexit (0);
d238 1
a238 2
maybe_dump_tags (stream)
     FILE *stream;
d286 1
a286 2
make_emacs_tag_block (filename)
     char *filename;
d300 2
a301 5
add_tag_to_block (block, name, line, char_offset)
     EMACS_TAG_BLOCK *block;
     char *name;
     int line;
     long char_offset;
d317 2
a318 5
process_one_file (filename, doc_stream, key_stream, funs_stream)
     char *filename;
     FILE *doc_stream;
     FILE *key_stream;
     FILE *funs_stream;
d500 3
a502 1
      fprintf (doc_stream, "   { %s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },\n", func, func_name, doc);
d504 2
a505 1
      fprintf (doc_stream, "   { %s, (FUNCTION_KEYSEQ *)0, %s },\n", func, doc);
d527 3
a529 1
      fprintf (funs_stream, "extern void %s ();\n", func);
d548 1
a548 2
fatal_file_error (filename)
     char *filename;
d555 1
a555 2
must_fopen (filename, mode)
     char *filename, *mode;
d569 1
a569 2
init_func_key(val)
	unsigned int val;
d575 1
a575 1
next_func_key()
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: makedoc.c,v 1.9 1999/06/25 21:57:40 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d28 1
d37 1
d55 1
a55 1
  "#include \"doc.h\"",
d63 22
d110 2
d121 1
d143 1
d148 1
d163 8
d172 4
a175 1
    fprintf (doc_stream, "\t%s\n", argv[i]);
a177 1

d181 5
d196 1
d200 1
a200 1
      process_one_file (curfile, doc_stream, funs_stream);
d203 12
d217 8
d228 1
d319 1
a319 1
   DOC_STREAM and FUNS_STREAM. */
d321 1
a321 1
process_one_file (filename, doc_stream, funs_stream)
d323 3
a325 1
     FILE *doc_stream, *funs_stream;
d363 1
a363 1
#if defined (NAMED_FUNCTIONS)
d365 1
a365 1
#endif /* NAMED_FUNCTIONS */
d430 1
a430 1
#if defined (NAMED_FUNCTIONS)
d459 1
a459 1
#endif /* NAMED_FUNCTIONS */
d504 12
a517 1
      free (func_name);
d522 9
d570 14
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* makedoc.c -- Make doc.c and funs.h from input files.
   $Id: makedoc.c,v 1.4 1997/07/15 18:35:59 karl Exp $
d4 1
a4 4
   This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d96 9
d114 2
a115 2
      funs_filename = "/dev/null";
      doc_filename = "/dev/null";
d166 1
a166 1
  exit (0);
d176 6
d276 4
a279 1
  read (descriptor, buffer, file_size);
d466 1
a466 1
  exit (2);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* makedoc.c -- Make DOC.C and FUNS.H from input files. */
d4 1
a4 1
/* This file is part of GNU Info, a program for reading online documentation
d7 1
a7 1
   Copyright (C) 1993 Free Software Foundation, Inc.
d30 1
a30 16
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#if defined (HAVE_SYS_FILE_H)
#include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */
#include <sys/stat.h>
#include "general.h"

#if !defined (O_RDONLY)
#if defined (HAVE_SYS_FCNTL_H)
#include <sys/fcntl.h>
#else /* !HAVE_SYS_FCNTL_H */
#include <fcntl.h>
#endif /* !HAVE_SYS_FCNTL_H */
#endif /* !O_RDONLY */
a31 1
extern void *xmalloc (), *xrealloc ();
d67 3
a69 3
  char *name;			/* Name of the tag. */
  int line;			/* Line number at which it appears. */
  long char_offset;		/* Character offset at which it appears. */
d73 3
a75 3
  char *filename;		/* Name of the file containing entries. */
  long entrylen;		/* Total number of characters in tag block. */
  EMACS_TAG **entries;		/* Entries found in FILENAME. */
d102 2
a103 2
	tags_only++;
	break;
d116 2
a117 2
	   "/* %s -- Generated declarations for Info commands. */\n",
	   funs_filename);
d126 1
a126 1
	   "   Source files groveled to make this file include:\n\n");
d143 1
a143 1
	continue;
d147 1
a147 1
	       curfile);
d153 1
a153 1
	   "   { (VFunction *)NULL, (char *)NULL, (char *)NULL }\n};\n");
d183 7
a189 7
	{
	  char digits[30];
	  etag = block->entries[j];
	  block_len += 3 + strlen (etag->name);
	  sprintf (digits, "%d,%d", etag->line, etag->char_offset);
	  block_len += strlen (digits);
	}
d192 1
a192 1
      fprintf (stream, "\f\n%s,%d\n", block->filename, block_len);
d196 2
a197 2
	{
	  etag = block->entries[j];
d199 3
a201 3
	  fprintf (stream, "%s,\177%d,%d\n",
		   etag->name, etag->line, etag->char_offset);
	}
d214 1
a214 1
  block->filename = strdup (filename);
d236 1
a236 1
			block->entries_slots, 50, EMACS_TAG *);
d285 14
a298 14
	{
	  if (buffer[offset] == '\n')
	    {
	      line_number++;
	      line_start = offset + 1;
	    }

	  if (strncmp (buffer + offset, decl_str, decl_len) == 0)
	    {
	      offset += decl_len;
	      point = offset;
	      break;
	    }
	}
d301 1
a301 1
	break;
d305 8
a312 8
	{
	  if (buffer[point] == '\n')
	    {
	      line_number++;
	      line_start = point + 1;
	    }
	  else if (buffer[point] == '(')
	    break;
d314 2
a315 2
	  point++;
	}
d318 9
a326 9
	{
	  if (!whitespace_or_newline (buffer[point]))
	    break;
	  else if (buffer[point] == '\n')
	    {
	      line_number++;
	      line_start = point + 1;
	    }
	}
d329 1
a329 1
	break;
d339 1
a339 1
	char *tag_name;
d341 4
a344 4
	tag_name = (char *)xmalloc (1 + (offset - line_start));
	strncpy (tag_name, buffer + line_start, offset - line_start);
	tag_name[offset - line_start] = '\0';
	add_tag_to_block (block, tag_name, line_number, point);
d350 2
a351 2
	register int i;
	char *name_start;
d353 1
a353 1
	name_start = func;
d355 2
a356 2
	if (strncmp (name_start, "info_", 5) == 0)
	  name_start += 5;
d358 17
a374 17
	func_name = strdup (name_start);

	/* Fix up "ea" commands. */
	if (strncmp (func_name, "ea_", 3) == 0)
	  {
	    char *temp_func_name;

	    temp_func_name = (char *)xmalloc (10 + strlen (func_name));
	    strcpy (temp_func_name, "echo_area_");
	    strcat (temp_func_name, func_name + 3);
	    free (func_name);
	    func_name = temp_func_name;
	  }

	for (i = 0; func_name[i]; i++)
	  if (func_name[i] == '_')
	    func_name[i] = '-';
d382 12
a393 12
	{
	  if (buffer[point] == '\n')
	    {
	      line_number++;
	      line_start = point + 1;
	    }

	  if (buffer[point] == '"')
	    break;
	  else
	    point++;
	}
d398 14
a411 14
	{
	  if (buffer[offset] == '\n')
	    {
	      line_number++;
	      line_start = offset + 1;
	    }

	  if (buffer[offset] == '\\')
	    offset += 2;
	  else if (buffer[offset] == '"')
	    break;
	  else
	    offset++;
	}
d415 1
a415 1
	break;
d438 1
a438 1
			  emacs_tags_slots, 10, EMACS_TAG_BLOCK *);
d450 1
a450 1
  fprintf (stderr, "Couldn't manipulate the file %s.\n", filename);
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* makedoc.c -- Make doc.c and funs.h from input files.
   $Id: makedoc.c,v 1.4 1997/07/15 18:35:59 karl Exp $
d3 1
a3 1
   This file is part of GNU Info, a program for reading online documentation
d6 1
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d29 16
a44 1
#include "info.h"
d46 1
d82 3
a84 3
  char *name;                   /* Name of the tag. */
  int line;                     /* Line number at which it appears. */
  long char_offset;             /* Character offset at which it appears. */
d88 3
a90 3
  char *filename;               /* Name of the file containing entries. */
  long entrylen;                /* Total number of characters in tag block. */
  EMACS_TAG **entries;          /* Entries found in FILENAME. */
d117 2
a118 2
        tags_only++;
        break;
d131 2
a132 2
           "/* %s -- Generated declarations for Info commands. */\n",
           funs_filename);
d141 1
a141 1
           _("   Source files groveled to make this file include:\n\n"));
d158 1
a158 1
        continue;
d162 1
a162 1
               curfile);
d168 1
a168 1
           "   { (VFunction *)NULL, (char *)NULL, (char *)NULL }\n};\n");
d198 7
a204 7
        {
          char digits[30];
          etag = block->entries[j];
          block_len += 3 + strlen (etag->name);
          sprintf (digits, "%d,%ld", etag->line, etag->char_offset);
          block_len += strlen (digits);
        }
d207 1
a207 1
      fprintf (stream, "\f\n%s,%ld\n", block->filename, block_len);
d211 2
a212 2
        {
          etag = block->entries[j];
d214 3
a216 3
          fprintf (stream, "%s,\177%d,%ld\n",
                   etag->name, etag->line, etag->char_offset);
        }
d229 1
a229 1
  block->filename = xstrdup (filename);
d251 1
a251 1
                        block->entries_slots, 50, EMACS_TAG *);
d300 14
a313 14
        {
          if (buffer[offset] == '\n')
            {
              line_number++;
              line_start = offset + 1;
            }

          if (strncmp (buffer + offset, decl_str, decl_len) == 0)
            {
              offset += decl_len;
              point = offset;
              break;
            }
        }
d316 1
a316 1
        break;
d320 8
a327 8
        {
          if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }
          else if (buffer[point] == '(')
            break;
d329 2
a330 2
          point++;
        }
d333 9
a341 9
        {
          if (!whitespace_or_newline (buffer[point]))
            break;
          else if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }
        }
d344 1
a344 1
        break;
d354 1
a354 1
        char *tag_name;
d356 4
a359 4
        tag_name = (char *)xmalloc (1 + (offset - line_start));
        strncpy (tag_name, buffer + line_start, offset - line_start);
        tag_name[offset - line_start] = '\0';
        add_tag_to_block (block, tag_name, line_number, point);
d365 2
a366 2
        register int i;
        char *name_start;
d368 1
a368 1
        name_start = func;
d370 2
a371 2
        if (strncmp (name_start, "info_", 5) == 0)
          name_start += 5;
d373 17
a389 17
        func_name = xstrdup (name_start);

        /* Fix up "ea" commands. */
        if (strncmp (func_name, "ea_", 3) == 0)
          {
            char *temp_func_name;

            temp_func_name = (char *)xmalloc (10 + strlen (func_name));
            strcpy (temp_func_name, "echo_area_");
            strcat (temp_func_name, func_name + 3);
            free (func_name);
            func_name = temp_func_name;
          }

        for (i = 0; func_name[i]; i++)
          if (func_name[i] == '_')
            func_name[i] = '-';
d397 12
a408 12
        {
          if (buffer[point] == '\n')
            {
              line_number++;
              line_start = point + 1;
            }

          if (buffer[point] == '"')
            break;
          else
            point++;
        }
d413 14
a426 14
        {
          if (buffer[offset] == '\n')
            {
              line_number++;
              line_start = offset + 1;
            }

          if (buffer[offset] == '\\')
            offset += 2;
          else if (buffer[offset] == '"')
            break;
          else
            offset++;
        }
d430 1
a430 1
        break;
d453 1
a453 1
                          emacs_tags_slots, 10, EMACS_TAG_BLOCK *);
d465 1
a465 1
  fprintf (stderr, _("Couldn't manipulate the file %s.\n"), filename);
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* makedoc.c -- make doc.c and funs.h from input files.
   $Id: makedoc.c,v 1.9 1999/06/25 21:57:40 karl Exp $
d4 4
a7 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
a98 9
#if STRIP_DOT_EXE
  {
    char *dot = strrchr (argv[0], '.');

    if (dot && FILENAME_CMP (dot, ".exe") == 0)
      *dot = 0;
  }
#endif

d108 2
a109 2
      funs_filename = NULL_DEVICE;
      doc_filename = NULL_DEVICE;
d160 1
a160 1
  xexit (0);
a169 6
  /* Emacs needs its TAGS file to be in Unix text format (i.e., only
     newline at end of every line, no CR), so when we generate a
     TAGS table, we must switch the output stream to binary mode.
     (If the table is written to a terminal, this is obviously not needed.) */
  SET_BINARY (fileno (stream));

d264 1
a264 4
  /* On some systems, the buffer will actually contain
     less characters than the full file's size, because
     the CR characters are removed from line endings.  */
  file_size = read (descriptor, buffer, file_size);
d451 1
a451 1
  xexit (2);
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: makedoc.c,v 1.10 2001/11/16 23:15:21 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99, 2001 Free Software Foundation, Inc.
a27 1
#include "infokey.h"
a35 1
static char *key_filename = "key.c";
d53 1
a53 1
  "#include \"info.h\"",
a60 22
static char *key_header[] = {
  "/* key.c -- Generated array containing function names.",
  "",
  "   This file was automatically made from various source files with the",
  "   command \"%s\".  DO NOT EDIT THIS FILE, only \"%s.c\".",
  "",
  (char *)NULL
};

static char *key_header_1[] = {
  "   An entry in the array FUNCTION_KEY_ARRAY is made for each command",
  "   found in the above files; each entry consists of",
  "   a string which is the user-visible name of the function.  */",
  "",
  "#include \"key.h\"",
  "#include \"funs.h\"",
  "",
  "FUNCTION_KEY function_key_array[] = {",
  "",
  (char *)NULL
};

a85 2
static void init_func_key ();
static unsigned int next_func_key ();
a94 1
  FILE *key_stream;
a115 1
      key_filename = NULL_DEVICE;
a119 1
  key_stream = must_fopen (key_filename, "w");
a133 8
  for (i = 0; key_header[i]; i++)
    {
      fprintf (key_stream, key_header[i], argv[0], argv[0]);
      fprintf (key_stream, "\n");
    }
  fprintf (key_stream,
           _("   Source files groveled to make this file include:\n\n"));

d135 1
a135 4
    {
      fprintf (doc_stream, "\t%s\n", argv[i]);
      fprintf (key_stream, "\t%s\n", argv[i]);
    }
d138 1
a141 5
  fprintf (key_stream, "\n");
  for (i = 0; key_header_1[i]; i++)
    fprintf (key_stream, "%s\n", key_header_1[i]);

  init_func_key(0);
a151 1
      fprintf (key_stream, "/* Commands found in \"%s\". */\n", curfile);
d155 1
a155 1
      process_one_file (curfile, doc_stream, key_stream, funs_stream);
a157 12
#if defined (INFOKEY)

#if defined (NAMED_FUNCTIONS)
  fprintf (doc_stream,
           "   { (VFunction *)NULL, (char *)NULL, (FUNCTION_KEYSEQ *)NULL, (char *)NULL }\n};\n");
#else /* !NAMED_FUNCTIONS */
  fprintf (doc_stream, "   { (VFunction *)NULL, (FUNCTION_KEYSEQ *)NULL, (char *)NULL }\n};\n");
#endif /* !NAMED_FUNCTIONS */

#else /* !INFOKEY */

#if defined (NAMED_FUNCTIONS)
a159 8
#else /* !NAMED_FUNCTIONS */
  fprintf (doc_stream, "   { (VFunction *)NULL, (char *)NULL }\n};\n");
#endif /* !NAMED_FUNCTIONS */

#endif /* !INFOKEY */

  fprintf (key_stream, "   (char *)0\n};\n");
  fprintf (funs_stream, "\n#define A_NCOMMANDS %u\n", next_func_key());
a162 1
  fclose (key_stream);
d253 1
a253 1
   DOC_STREAM, KEY_STREAM, and FUNS_STREAM. */
d255 1
a255 1
process_one_file (filename, doc_stream, key_stream, funs_stream)
d257 1
a257 3
     FILE *doc_stream;
     FILE *key_stream;
     FILE *funs_stream;
d295 1
a295 1
#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
d297 1
a297 1
#endif /* INFOKEY || NAMED_FUNCTIONS */
d362 1
a362 1
#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
d391 1
a391 1
#endif /* INFOKEY || NAMED_FUNCTIONS */
a435 12
#if defined (INFOKEY)

#if defined (NAMED_FUNCTIONS)
      fprintf (doc_stream, "   { %s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },\n", func, func_name, doc);
#else /* !NAMED_FUNCTIONS */
      fprintf (doc_stream, "   { %s, (FUNCTION_KEYSEQ *)0, %s },\n", func, doc);
#endif /* !NAMED_FUNCTIONS */

      fprintf (key_stream, "   { \"%s\", A_%s },\n", func_name, func);

#else /* !INFOKEY */

d438 1
a442 9
#endif /* !INFOKEY */

#if defined (INFOKEY) || defined (NAMED_FUNCTIONS)
      free (func_name);
#endif /* INFOKEY || NAMED_FUNCTIONS */

#if defined (INFOKEY)
      fprintf (funs_stream, "#define A_%s %u\n", func, next_func_key());
#endif /* INFOKEY */
a481 14
static unsigned int func_key;

static void
init_func_key(val)
	unsigned int val;
{
	func_key = val;
}

static unsigned int
next_func_key()
{
	return func_key++;
}
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: makedoc.c,v 1.4 2004/04/11 17:56:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d20 1
a20 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
d30 1
a30 1
static void fatal_file_error (char *filename);
d43 1
a43 1
  "   command `%s'.  DO NOT EDIT THIS FILE, only `%s.c'.",
d107 5
a111 6
static void process_one_file (char *filename, FILE *doc_stream,
    FILE *key_stream, FILE *funs_stream);
static void maybe_dump_tags (FILE *stream);
static FILE *must_fopen (char *filename, char *mode);
static void init_func_key (unsigned int val);
static unsigned int next_func_key (void);
d114 3
a116 1
main (int argc, char **argv)
d145 1
a145 1

d151 2
a152 3
      "/* %s -- Generated declarations for Info commands. */\n\n\
#include \"info.h\"\n",
      funs_filename);
d223 1
a223 1
  fprintf (key_stream, "   { (char *)NULL, 0 }\n};\n");
d232 1
a232 1
  return 0;
d237 2
a238 1
maybe_dump_tags (FILE *stream)
d286 2
a287 1
make_emacs_tag_block (char *filename)
d301 5
a305 2
add_tag_to_block (EMACS_TAG_BLOCK *block,
    char *name, int line, long int char_offset)
d321 5
a325 2
process_one_file (char *filename, FILE *doc_stream,
    FILE *key_stream, FILE *funs_stream)
d507 1
a507 3
      fprintf (doc_stream,
          "   { (VFunction *)%s, \"%s\", (FUNCTION_KEYSEQ *)0, %s },\n",
          func, func_name, doc);
d509 1
a509 2
      fprintf (doc_stream,
          "   { (VFunction *) %s, (FUNCTION_KEYSEQ *)0, %s },\n", func, doc);
d531 1
a531 3
      fprintf (funs_stream,
          "extern void %s (WINDOW *window, int count, unsigned char key);\n",
          func);
d550 2
a551 1
fatal_file_error (char *filename)
d558 2
a559 1
must_fopen (char *filename, char *mode)
d573 2
a574 1
init_func_key(unsigned int val)
d580 1
a580 1
next_func_key(void)
@


