head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.48
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.22;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.49;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.06;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* m-x.c -- Meta-x minibuffer reader.
   $Id: m-x.c,v 1.3 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1993, 1997, 1998, 2001, 2002, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Originally written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "funs.h"

/* **************************************************************** */
/*                                                                  */
/*                     Reading Named Commands                       */
/*                                                                  */
/* **************************************************************** */

/* Read the name of an Info function in the echo area and return the
   name.  A return value of NULL indicates that no function name could
   be read. */
char *
read_function_name (char *prompt, WINDOW *window)
{
  register int i;
  char *line;
  REFERENCE **array = (REFERENCE **)NULL;
  int array_index = 0, array_slots = 0;

  /* Make an array of REFERENCE which actually contains the names of
     the functions available in Info. */
  for (i = 0; function_doc_array[i].func; i++)
    {
      REFERENCE *entry;

      entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
      entry->label = xstrdup (function_doc_array[i].func_name);
      entry->nodename = (char *)NULL;
      entry->filename = (char *)NULL;

      add_pointer_to_array
        (entry, array_index, array, array_slots, 200, REFERENCE *);
    }

  line = info_read_completing_in_echo_area (window, prompt, array);

  info_free_references (array);

  if (!echo_area_is_active)
    window_clear_echo_area ();

  return (line);
}

DECLARE_INFO_COMMAND (describe_command,
   _("Read the name of an Info command and describe it"))
{
  char *line;

  line = read_function_name ((char *) _("Describe command: "), window);

  if (!line)
    {
      info_abort_key (active_window, count, key);
      return;
    }

  /* Describe the function named in "LINE". */
  if (*line)
    {
      InfoCommand *cmd = named_function (line);

      if (!cmd)
        return;

      window_message_in_echo_area ("%s: %s.",
                                   line, function_documentation (cmd));
    }
  free (line);
}

DECLARE_INFO_COMMAND (info_execute_command,
   _("Read a command name in the echo area and execute it"))
{
  char *line;
  char *keys;
  char *prompt;

  prompt = (char *)xmalloc (20);

  keys = where_is (info_keymap, InfoCmd(info_execute_command));
  /* If the where_is () function thinks that this command doesn't exist,
     there's something very wrong!  */
  if (!keys)
    abort();

  if (info_explicit_arg || count != 1)
    sprintf (prompt, "%d %s ", count, keys);
  else
    sprintf (prompt, "%s ", keys);

  /* Ask the completer to read a reference for us. */
  line = read_function_name (prompt, window);

  /* User aborted? */
  if (!line)
    {
      info_abort_key (active_window, count, key);
      return;
    }

  /* User accepted "default"?  (There is none.) */
  if (!*line)
    {
      free (line);
      return;
    }

  /* User wants to execute a named command.  Do it. */
  {
    InfoCommand *command;

    if ((active_window != the_echo_area) &&
        (strncmp (line, "echo-area-", 10) == 0))
      {
        free (line);
        info_error ((char *) _("Cannot execute an `echo-area' command here."),
            NULL, NULL);
        return;
      }

    command = named_function (line);
    free (line);

    if (!command)
      return;

    if (InfoFunction(command))
      (*InfoFunction(command)) (active_window, count, 0);
    else
      info_error ((char *) _("Undefined command: %s"), line, NULL);
  }
}

/* Okay, now that we have M-x, let the user set the screen height. */
DECLARE_INFO_COMMAND (set_screen_height,
  _("Set the height of the displayed window"))
{
  int new_height, old_height = screenheight;

  if (info_explicit_arg || count != 1)
    new_height = count;
  else
    {
      char prompt[80];
      char *line;

      new_height = screenheight;

      sprintf (prompt, _("Set screen height to (%d): "), new_height);

      line = info_read_in_echo_area (window, prompt);

      /* If the user aborted, do that now. */
      if (!line)
        {
          info_abort_key (active_window, count, 0);
          return;
        }

      /* Find out what the new height is supposed to be. */
      if (*line)
        new_height = atoi (line);

      /* Clear the echo area if it isn't active. */
      if (!echo_area_is_active)
        window_clear_echo_area ();

      free (line);
    }

  terminal_clear_screen ();
  display_clear_display (the_display);
  screenheight = new_height;
#ifdef SET_SCREEN_SIZE_HELPER
  SET_SCREEN_SIZE_HELPER;
#endif
  if (screenheight == old_height)
    {
      /* Display dimensions didn't actually change, so
	 window_new_screen_size won't do anything, but we've
	 already cleared the display above.  Undo the damage.  */
      window_mark_chain (windows, W_UpdateWindow);
      display_update_display (windows);
    }
  else
    {
      display_initialize_display (screenwidth, screenheight);
      window_new_screen_size (screenwidth, screenheight);
    }
}
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: m-x.c,v 1.9 2001/11/16 23:14:33 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 2001 Free Software Foundation, Inc.
d21 1
a21 1
   Written by Brian Fox (bfox@@ai.mit.edu). */
d36 1
a36 3
read_function_name (prompt, window)
     char *prompt;
     WINDOW *window;
d73 1
a73 1
  line = read_function_name (_("Describe command: "), window);
d140 2
a141 1
        info_error (_("Cannot execute an `echo-area' command here."));
d151 4
a154 1
    (*InfoFunction(command)) (active_window, count, 0);
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: m-x.c,v 1.8 1999/06/25 21:57:40 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d23 1
d85 1
a85 1
      VFunction *fun = named_function (line);
d87 1
a87 1
      if (!fun)
d91 1
a91 1
                                   line, function_documentation (fun));
d100 10
a110 1
  /* Ask the completer to read a reference for us. */
d112 3
a114 2
    {
      char *prompt;
d116 2
a117 6
      prompt = (char *)xmalloc (20);
      sprintf (prompt, "%d M-x ", count);
      line = read_function_name (prompt, window);
    }
  else
    line = read_function_name ("M-x ", window);
d135 1
a135 1
    VFunction *function;
d145 1
a145 1
    function = named_function (line);
d148 1
a148 1
    if (!function)
d151 1
a151 1
    (*function) (active_window, count, 0);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* m-x.c -- Meta-X minibuffer reader.
   $Id: m-x.c,v 1.5 1997/07/24 21:28:00 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d152 1
a152 1
  int new_height;
d188 16
a203 2
  display_initialize_display (screenwidth, screenheight);
  window_new_screen_size (screenwidth, screenheight);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* m-x.c -- Meta-X minibuffer reader. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d25 3
a27 3
/*								    */
/*		       Reading Named Commands			    */
/*								    */
d50 1
a50 1
      entry->label = strdup (function_doc_array[i].func_name);
d55 1
a55 1
	(entry, array_index, array, array_slots, 200, REFERENCE *);
d69 1
a69 1
   "Read the name of an Info command and describe it")
d73 1
a73 1
  line = read_function_name ("Describe command: ", window);
d84 1
a84 4
      char *fundoc;
      VFunction *fun;

      fun = named_function (line);
d87 1
a87 1
	return;
d90 1
a90 1
				   line, function_documentation (fun));
d96 1
a96 1
   "Read a command name in the echo area and execute it")
d131 1
a131 1
	(strncmp (line, "echo-area-", 10) == 0))
d133 3
a135 3
	free (line);
	info_error ("Cannot execute an `echo-area' command here.");
	return;
d150 1
a150 1
  "Set the height of the displayed window")
d163 1
a163 1
      sprintf (prompt, "Set screen height to (%d): ", new_height);
d169 4
a172 4
	{
	  info_abort_key (active_window, count, 0);
	  return;
	}
d176 1
a176 1
	new_height = atoi (line);
d180 1
a180 1
	window_clear_echo_area ();
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* m-x.c -- Meta-X minibuffer reader.
   $Id: m-x.c,v 1.5 1997/07/24 21:28:00 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d27 3
a29 3
/*                                                                  */
/*                     Reading Named Commands                       */
/*                                                                  */
d52 1
a52 1
      entry->label = xstrdup (function_doc_array[i].func_name);
d57 1
a57 1
        (entry, array_index, array, array_slots, 200, REFERENCE *);
d71 1
a71 1
   _("Read the name of an Info command and describe it"))
d75 1
a75 1
  line = read_function_name (_("Describe command: "), window);
d86 4
a89 1
      VFunction *fun = named_function (line);
d92 1
a92 1
        return;
d95 1
a95 1
                                   line, function_documentation (fun));
d101 1
a101 1
   _("Read a command name in the echo area and execute it"))
d136 1
a136 1
        (strncmp (line, "echo-area-", 10) == 0))
d138 3
a140 3
        free (line);
        info_error (_("Cannot execute an `echo-area' command here."));
        return;
d155 1
a155 1
  _("Set the height of the displayed window"))
d168 1
a168 1
      sprintf (prompt, _("Set screen height to (%d): "), new_height);
d174 4
a177 4
        {
          info_abort_key (active_window, count, 0);
          return;
        }
d181 1
a181 1
        new_height = atoi (line);
d185 1
a185 1
        window_clear_echo_area ();
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* m-x.c -- Meta-x minibuffer reader.
   $Id: m-x.c,v 1.8 1999/06/25 21:57:40 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d152 1
a152 1
  int new_height, old_height = screenheight;
d188 2
a189 16
#ifdef SET_SCREEN_SIZE_HELPER
  SET_SCREEN_SIZE_HELPER;
#endif
  if (screenheight == old_height)
    {
      /* Display dimensions didn't actually change, so
	 window_new_screen_size won't do anything, but we've
	 already cleared the display above.  Undo the damage.  */
      window_mark_chain (windows, W_UpdateWindow);
      display_update_display (windows);
    }
  else
    {
      display_initialize_display (screenwidth, screenheight);
      window_new_screen_size (screenwidth, screenheight);
    }
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: m-x.c,v 1.9 2001/11/16 23:14:33 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 2001 Free Software Foundation, Inc.
a22 1
#include "funs.h"
d84 1
a84 1
      InfoCommand *cmd = named_function (line);
d86 1
a86 1
      if (!cmd)
d90 1
a90 1
                                   line, function_documentation (cmd));
a98 2
  char *keys;
  char *prompt;
d100 4
a103 1
  prompt = (char *)xmalloc (20);
d105 4
a108 8
  keys = where_is (info_keymap, InfoCmd(info_execute_command));
  /* If the where_is () function thinks that this command doesn't exist,
     there's something very wrong!  */
  if (!keys)
    abort();

  if (info_explicit_arg || count != 1)
    sprintf (prompt, "%d %s ", count, keys);
d110 1
a110 4
    sprintf (prompt, "%s ", keys);

  /* Ask the completer to read a reference for us. */
  line = read_function_name (prompt, window);
d128 1
a128 1
    InfoCommand *command;
d138 1
a138 1
    command = named_function (line);
d141 1
a141 1
    if (!command)
d144 1
a144 1
    (*InfoFunction(command)) (active_window, count, 0);
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: m-x.c,v 1.3 2004/04/11 17:56:46 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 2001, 2002, 2004 Free Software
   Foundation, Inc.
d20 1
a20 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
d35 3
a37 1
read_function_name (char *prompt, WINDOW *window)
d74 1
a74 1
  line = read_function_name ((char *) _("Describe command: "), window);
d141 1
a141 2
        info_error ((char *) _("Cannot execute an `echo-area' command here."),
            NULL, NULL);
d151 1
a151 4
    if (InfoFunction(command))
      (*InfoFunction(command)) (active_window, count, 0);
    else
      info_error ((char *) _("Undefined command: %s"), line, NULL);
@


