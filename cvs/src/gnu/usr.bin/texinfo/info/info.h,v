head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.48
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.6
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.5
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.4
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.3
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.08;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.14;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.21;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.01.11.16.32.19;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2000.02.09.01.24.45;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.06.10.13.21.05;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* info.h -- Header file which includes all of the other headers.
   $Id: info.h,v 1.4 2004/04/11 17:56:45 karl Exp $

   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#ifndef INFO_H
#define INFO_H

/* We always want these, so why clutter up the compile command?  */
#define HANDLE_MAN_PAGES
#define NAMED_FUNCTIONS
#define INFOKEY

/* System dependencies.  */
#include "system.h"

/* Some of our other include files use these.  */
typedef int Function ();
typedef void VFunction ();
typedef char *CFunction ();

#include "filesys.h"
#include "doc.h"
#include "display.h"
#include "session.h"
#include "echo-area.h"
#include "footnotes.h"
#include "gc.h"

#define info_toupper(x) (islower (x) ? toupper (x) : x)
#define info_tolower(x) (isupper (x) ? tolower (x) : x)

#if !defined (whitespace)
#  define whitespace(c) ((c == ' ') || (c == '\t'))
#endif /* !whitespace */

#if !defined (whitespace_or_newline)
#  define whitespace_or_newline(c) (whitespace (c) || (c == '\n'))
#endif /* !whitespace_or_newline */

/* Add POINTER to the list of pointers found in ARRAY.  SLOTS is the number
   of slots that have already been allocated.  INDEX is the index into the
   array where POINTER should be added.  GROW is the number of slots to grow
   ARRAY by, in the case that it needs growing.  TYPE is a cast of the type
   of object stored in ARRAY (e.g., NODE_ENTRY *. */
#define add_pointer_to_array(pointer, idx, array, slots, grow, type) \
  do { \
    if (idx + 2 >= slots) \
      array = (type *)(xrealloc (array, (slots += grow) * sizeof (type))); \
    array[idx++] = (type)pointer; \
    array[idx] = (type)NULL; \
  } while (0)

#define maybe_free(x) do { if (x) free (x); } while (0)

#if !defined (zero_mem) && defined (HAVE_MEMSET)
#  define zero_mem(mem, length) memset (mem, 0, length)
#endif /* !zero_mem && HAVE_MEMSET */

#if !defined (zero_mem) && defined (HAVE_BZERO)
#  define zero_mem(mem, length) bzero (mem, length)
#endif /* !zero_mem && HAVE_BZERO */

#if !defined (zero_mem)
#  define zero_mem(mem, length) \
  do {                                  \
        register int zi;                \
        register unsigned char *place;  \
                                        \
        place = (unsigned char *)mem;   \
        for (zi = 0; zi < length; zi++) \
          place[zi] = 0;                \
      } while (0)
#endif /* !zero_mem */


/* A structure associating the nodes visited in a particular window. */
typedef struct {
  WINDOW *window;               /* The window that this list is attached to. */
  NODE **nodes;                 /* Array of nodes visited in this window. */
  int *pagetops;                /* For each node in NODES, the pagetop. */
  long *points;                 /* For each node in NODES, the point. */
  int current;                  /* Index in NODES of the current node. */
  int nodes_index;              /* Index where to add the next node. */
  int nodes_slots;              /* Number of slots allocated to NODES. */
} INFO_WINDOW;

/* Array of structures describing for each window which nodes have been
   visited in that window. */
extern INFO_WINDOW **info_windows;

/* For handling errors.  If you initialize the window system, you should
   also set info_windows_initialized_p to non-zero.  It is used by the
   info_error () function to determine how to format and output errors. */
extern int info_windows_initialized_p;

/* Non-zero if an error message has been printed. */
extern int info_error_was_printed;

/* Non-zero means ring terminal bell on errors. */
extern int info_error_rings_bell_p;

/* Non-zero means default keybindings are loosely modeled on vi(1).  */
extern int vi_keys_p;

/* Non-zero means don't remove ANSI escape sequences from man pages.  */
extern int raw_escapes_p;

/* Print FORMAT with ARG1 and ARG2.  If the window system was initialized,
   then the message is printed in the echo area.  Otherwise, a message is
   output to stderr. */
extern void info_error (char *format, void *arg1, void *arg2);

extern void add_file_directory_to_path (char *filename);

/* Error message defines. */
extern const char *msg_cant_find_node;
extern const char *msg_cant_file_node;
extern const char *msg_cant_find_window;
extern const char *msg_cant_find_point;
extern const char *msg_cant_kill_last;
extern const char *msg_no_menu_node;
extern const char *msg_no_foot_node;
extern const char *msg_no_xref_node;
extern const char *msg_no_pointer;
extern const char *msg_unknown_command;
extern const char *msg_term_too_dumb;
extern const char *msg_at_node_bottom;
extern const char *msg_at_node_top;
extern const char *msg_one_window;
extern const char *msg_win_too_small;
extern const char *msg_cant_make_help;


#if defined(INFOKEY)
/* Found in variables.c. */
extern void set_variable_to_value (char *name, char *value);
#endif /* INFOKEY */

/* Found in m-x.c.  */
extern char *read_function_name (char *prompt, WINDOW *window);

#endif /* !INFO_H */
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: info.h,v 1.16 2002/02/23 19:12:02 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 97, 98, 99, 2001 Free Software Foundation, Inc.
d129 3
a131 1
extern void info_error ();
d134 16
a149 16
extern char *msg_cant_find_node;
extern char *msg_cant_file_node;
extern char *msg_cant_find_window;
extern char *msg_cant_find_point;
extern char *msg_cant_kill_last;
extern char *msg_no_menu_node;
extern char *msg_no_foot_node;
extern char *msg_no_xref_node;
extern char *msg_no_pointer;
extern char *msg_unknown_command;
extern char *msg_term_too_dumb;
extern char *msg_at_node_bottom;
extern char *msg_at_node_top;
extern char *msg_one_window;
extern char *msg_win_too_small;
extern char *msg_cant_make_help;
a151 2
extern char *filename_non_directory ();	/* Found in info-utils.c. */

d153 2
a154 1
extern void set_variable_to_value ();	/* Found in variables.c. */
d157 2
a158 5
#if !defined (BUILDING_LIBRARY)
extern int info_windows_initialized_p;	/* Found in session.c */
/* Found in window.c. */
extern void message_in_echo_area (), unmessage_in_echo_area ();
#endif /* !BUILDING_LIBRARY */
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: info.h,v 1.14 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d28 1
a37 1

d39 1
a42 1
#include "doc.h"
d122 3
a129 3
/* The version numbers of Info. */
extern int info_major_version, info_minor_version;

d149 5
a153 2
/* Found in info-utils.c. */
extern char *filename_non_directory ();
d156 1
a156 3
/* Found in session.c */
extern int info_windows_initialized_p;

@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: info.h,v 1.7 1998/02/27 21:36:04 karl Exp $
d4 1
a4 4
   This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d22 1
a22 1
#if !defined (INFO_H)
d119 3
a129 4
/* How to get the version string for this version of Info.  Returns
   something similar to "2.11". */
extern char *version_string ();

d131 16
a146 17
#define CANT_FIND_NODE  _("Cannot find the node \"%s\".")
#define CANT_FILE_NODE  _("Cannot find the node \"(%s)%s\".")
#define CANT_FIND_WIND  _("Cannot find a window!")
#define CANT_FIND_POINT _("Point doesn't appear within this window's node!")
#define CANT_KILL_LAST  _("Cannot delete the last window.")
#define NO_MENU_NODE    _("No menu in this node.")
#define NO_FOOT_NODE    _("No footnotes in this node.")
#define NO_XREF_NODE    _("No cross references in this node.")
#define NO_POINTER      _("No \"%s\" pointer for this node.")
#define UNKNOWN_COMMAND _("Unknown Info command `%c'.  `?' for help.")
#define TERM_TOO_DUMB   _("Terminal type \"%s\" is not smart enough to run Info.")
#define AT_NODE_BOTTOM  _("You are already at the last page of this node.")
#define AT_NODE_TOP     _("You are already at the first page of this node.")
#define ONE_WINDOW      _("Only one window.")
#define WIN_TOO_SMALL   _("Resulting window would be too small.")
#define CANT_MAKE_HELP  \
_("There isn't enough room to make a help window.  Please delete a window.")
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* info.h -- Header file which includes all of the other headers. */
d4 1
a4 1
/* This file is part of GNU Info, a program for reading online documentation
d7 1
a7 1
   Copyright (C) 1993 Free Software Foundation, Inc.
d25 15
a39 2
#if !defined (_INFO_H_)
#define _INFO_H_
a40 7
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#if defined (HAVE_STRING_H)
#include <string.h>
#endif /* HAVE_STRING_H */
d44 1
a44 1
#include "echo_area.h"
d49 47
d98 7
a104 7
  WINDOW *window;		/* The window that this list is attached to. */
  NODE **nodes;			/* Array of nodes visited in this window. */
  int *pagetops;		/* For each node in NODES, the pagetop. */
  long *points;			/* For each node in NODES, the point. */
  int current;			/* Index in NODES of the current node. */
  int nodes_index;		/* Index where to add the next node. */
  int nodes_slots;		/* Number of slots allocated to NODES. */
d128 1
a128 1
extern int info_major_version, info_minor_version, info_patch_level;
d135 25
a159 17
#define CANT_FIND_NODE	"Cannot find the node \"%s\"."
#define CANT_FILE_NODE	"Cannot find the node \"(%s)%s\"."
#define CANT_FIND_WIND	"Cannot find a window!"
#define CANT_FIND_POINT	"Point doesn't appear within this window's node!"
#define CANT_KILL_LAST	"Cannot delete the last window."
#define NO_MENU_NODE	"No menu in this node."
#define NO_FOOT_NODE	"No footnotes in this node."
#define NO_XREF_NODE	"No cross references in this node."
#define NO_POINTER	"No \"%s\" pointer for this node."
#define UNKNOWN_COMMAND	"Unknown Info command `%c'.  `?' for help."
#define TERM_TOO_DUMB	"Terminal type \"%s\" is not smart enough to run Info."
#define AT_NODE_BOTTOM	"You are already at the last page of this node."
#define AT_NODE_TOP	"You are already at the first page of this node."
#define ONE_WINDOW	"Only one window."
#define WIN_TOO_SMALL	"Resulting window would be too small."
#define CANT_MAKE_HELP	\
"There isn't enough room to make a help window.  Please delete a window."
d161 3
a163 1
#endif /* !_INFO_H_ */
d165 1
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* info.h -- Header file which includes all of the other headers.
   $Id: info.h,v 1.6 1997/07/15 18:34:15 karl Exp $
d3 1
a3 1
   This file is part of GNU Info, a program for reading online documentation
d6 1
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d24 2
a25 15
#if !defined (INFO_H)
#define INFO_H

/* We always want these, so why clutter up the compile command?  */
#define HANDLE_MAN_PAGES
#define NAMED_FUNCTIONS

/* System dependencies.  */
#include "system.h"

/* Some of our other include files use these.  */
typedef int Function ();
typedef void VFunction ();
typedef char *CFunction ();

d27 7
d37 1
a37 1
#include "echo-area.h"
a41 47
#define info_toupper(x) (islower (x) ? toupper (x) : x)
#define info_tolower(x) (isupper (x) ? tolower (x) : x)

#if !defined (whitespace)
#  define whitespace(c) ((c == ' ') || (c == '\t'))
#endif /* !whitespace */

#if !defined (whitespace_or_newline)
#  define whitespace_or_newline(c) (whitespace (c) || (c == '\n'))
#endif /* !whitespace_or_newline */

/* Add POINTER to the list of pointers found in ARRAY.  SLOTS is the number
   of slots that have already been allocated.  INDEX is the index into the
   array where POINTER should be added.  GROW is the number of slots to grow
   ARRAY by, in the case that it needs growing.  TYPE is a cast of the type
   of object stored in ARRAY (e.g., NODE_ENTRY *. */
#define add_pointer_to_array(pointer, idx, array, slots, grow, type) \
  do { \
    if (idx + 2 >= slots) \
      array = (type *)(xrealloc (array, (slots += grow) * sizeof (type))); \
    array[idx++] = (type)pointer; \
    array[idx] = (type)NULL; \
  } while (0)

#define maybe_free(x) do { if (x) free (x); } while (0)

#if !defined (zero_mem) && defined (HAVE_MEMSET)
#  define zero_mem(mem, length) memset (mem, 0, length)
#endif /* !zero_mem && HAVE_MEMSET */

#if !defined (zero_mem) && defined (HAVE_BZERO)
#  define zero_mem(mem, length) bzero (mem, length)
#endif /* !zero_mem && HAVE_BZERO */

#if !defined (zero_mem)
#  define zero_mem(mem, length) \
  do {                                  \
        register int zi;                \
        register unsigned char *place;  \
                                        \
        place = (unsigned char *)mem;   \
        for (zi = 0; zi < length; zi++) \
          place[zi] = 0;                \
      } while (0)
#endif /* !zero_mem */


d44 7
a50 7
  WINDOW *window;               /* The window that this list is attached to. */
  NODE **nodes;                 /* Array of nodes visited in this window. */
  int *pagetops;                /* For each node in NODES, the pagetop. */
  long *points;                 /* For each node in NODES, the point. */
  int current;                  /* Index in NODES of the current node. */
  int nodes_index;              /* Index where to add the next node. */
  int nodes_slots;              /* Number of slots allocated to NODES. */
d81 17
a97 25
#define CANT_FIND_NODE  _("Cannot find the node \"%s\".")
#define CANT_FILE_NODE  _("Cannot find the node \"(%s)%s\".")
#define CANT_FIND_WIND  _("Cannot find a window!")
#define CANT_FIND_POINT _("Point doesn't appear within this window's node!")
#define CANT_KILL_LAST  _("Cannot delete the last window.")
#define NO_MENU_NODE    _("No menu in this node.")
#define NO_FOOT_NODE    _("No footnotes in this node.")
#define NO_XREF_NODE    _("No cross references in this node.")
#define NO_POINTER      _("No \"%s\" pointer for this node.")
#define UNKNOWN_COMMAND _("Unknown Info command `%c'.  `?' for help.")
#define TERM_TOO_DUMB   _("Terminal type \"%s\" is not smart enough to run Info.")
#define AT_NODE_BOTTOM  _("You are already at the last page of this node.")
#define AT_NODE_TOP     _("You are already at the first page of this node.")
#define ONE_WINDOW      _("Only one window.")
#define WIN_TOO_SMALL   _("Resulting window would be too small.")
#define CANT_MAKE_HELP  \
_("There isn't enough room to make a help window.  Please delete a window.")


/* Found in info-utils.c. */
extern char *filename_non_directory ();

#if !defined (BUILDING_LIBRARY)
/* Found in session.c */
extern int info_windows_initialized_p;
d99 1
a99 3
/* Found in window.c. */
extern void message_in_echo_area (), unmessage_in_echo_area ();
#endif /* !BUILDING_LIBRARY */
a100 1
#endif /* !INFO_H */
@


1.1.1.3
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: info.h,v 1.7 1998/02/27 21:36:04 karl Exp $
d7 1
a7 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d128 1
a128 1
extern int info_major_version, info_minor_version;
@


1.1.1.4
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: info.h,v 1.14 1999/09/25 16:10:04 karl Exp $
d4 4
a7 1
   Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.
d25 1
a25 1
#ifndef INFO_H
a121 3
/* Non-zero means default keybindings are loosely modeled on vi(1).  */
extern int vi_keys_p;

d130 4
d135 17
a151 16
extern char *msg_cant_find_node;
extern char *msg_cant_file_node;
extern char *msg_cant_find_window;
extern char *msg_cant_find_point;
extern char *msg_cant_kill_last;
extern char *msg_no_menu_node;
extern char *msg_no_foot_node;
extern char *msg_no_xref_node;
extern char *msg_no_pointer;
extern char *msg_unknown_command;
extern char *msg_term_too_dumb;
extern char *msg_at_node_bottom;
extern char *msg_at_node_top;
extern char *msg_one_window;
extern char *msg_win_too_small;
extern char *msg_cant_make_help;
@


1.1.1.5
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: info.h,v 1.16 2002/02/23 19:12:02 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98, 99, 2001 Free Software Foundation, Inc.
a27 1
#define INFOKEY
d37 1
a38 1
#include "doc.h"
d42 1
a121 3
/* Non-zero means don't remove ANSI escape sequences from man pages.  */
extern int raw_escapes_p;

d127 3
d149 2
a150 1
extern char *filename_non_directory ();	/* Found in info-utils.c. */
d152 3
a154 3
#if defined(INFOKEY)
extern void set_variable_to_value ();	/* Found in variables.c. */
#endif /* INFOKEY */
a155 2
#if !defined (BUILDING_LIBRARY)
extern int info_windows_initialized_p;	/* Found in session.c */
@


1.1.1.6
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: info.h,v 1.4 2004/04/11 17:56:45 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 1997, 1998, 1999, 2001, 2002, 2003, 2004 Free Software
   Foundation, Inc.
d128 1
a128 3
extern void info_error (char *format, void *arg1, void *arg2);

extern void add_file_directory_to_path (char *filename);
d131 16
a146 16
extern const char *msg_cant_find_node;
extern const char *msg_cant_file_node;
extern const char *msg_cant_find_window;
extern const char *msg_cant_find_point;
extern const char *msg_cant_kill_last;
extern const char *msg_no_menu_node;
extern const char *msg_no_foot_node;
extern const char *msg_no_xref_node;
extern const char *msg_no_pointer;
extern const char *msg_unknown_command;
extern const char *msg_term_too_dumb;
extern const char *msg_at_node_bottom;
extern const char *msg_at_node_top;
extern const char *msg_one_window;
extern const char *msg_win_too_small;
extern const char *msg_cant_make_help;
d149 2
d152 1
a152 2
/* Found in variables.c. */
extern void set_variable_to_value (char *name, char *value);
d155 5
a159 2
/* Found in m-x.c.  */
extern char *read_function_name (char *prompt, WINDOW *window);
@


