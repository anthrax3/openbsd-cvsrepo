head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.42
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.38
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.40
	OPENBSD_5_8_BASE:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.32
	OPENBSD_5_7_BASE:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.36
	OPENBSD_5_6_BASE:1.1.1.5
	OPENBSD_5_5:1.1.1.5.0.34
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.30
	OPENBSD_5_4_BASE:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.28
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.26
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.24
	OPENBSD_5_0:1.1.1.5.0.22
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.20
	OPENBSD_4_9_BASE:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.18
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.14
	OPENBSD_4_7_BASE:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.16
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.14
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.12
	OPENBSD_3_7_BASE:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.10
	OPENBSD_3_6_BASE:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.8
	OPENBSD_3_5_BASE:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.6
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.4
	OPENBSD_3_3_BASE:1.1.1.4
	OPENBSD_3_2:1.1.1.4.0.2
	OPENBSD_3_2_BASE:1.1.1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.1.1.3.0.10
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.8
	OPENBSD_3_0_BASE:1.1.1.3
	OPENBSD_2_9:1.1.1.3.0.6
	OPENBSD_2_9_BASE:1.1.1.3
	OPENBSD_2_8:1.1.1.3.0.4
	OPENBSD_2_8_BASE:1.1.1.3
	OPENBSD_2_7:1.1.1.3.0.2
	OPENBSD_2_7_BASE:1.1.1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.1.1.2.0.10
	OPENBSD_2_6_BASE:1.1.1.2
	OPENBSD_2_5:1.1.1.2.0.8
	OPENBSD_2_5_BASE:1.1.1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	95.12.22.16.47.13;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.13;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.17;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.44;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.04;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.43;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* info-utils.c -- Useful functions for manipulating Info file quirks. */

/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include <stdio.h>		/* For "NULL".  Yechhh! */
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#if defined (HAVE_STRING_H)
#  include <string.h>
#endif /* HAVE_STRING_H */
#include "info-utils.h"

#if defined (HANDLE_MAN_PAGES)
#  include "man.h"
#endif /* HANDLE_MAN_PAGES */

/* When non-zero, various display and input functions handle ISO Latin
   character sets correctly. */
int ISO_Latin_p = 0;

/* Variable which holds the most recent filename parsed as a result of
   calling info_parse_xxx (). */
char *info_parsed_filename = (char *)NULL;

/* Variable which holds the most recent nodename parsed as a result of
   calling info_parse_xxx (). */
char *info_parsed_nodename = (char *)NULL;

/* Functions to remember a filename or nodename for later return. */
static void save_filename (), saven_filename ();
static void save_nodename (), saven_nodename ();

/* How to get a reference (either menu or cross). */
static REFERENCE **info_references_internal ();

/* Parse the filename and nodename out of STRING.  If STRING doesn't
   contain a filename (i.e., it is NOT (FILENAME)NODENAME) then set
   INFO_PARSED_FILENAME to NULL.  If second argument NEWLINES_OKAY is
   non-zero, it says to allow the nodename specification to cross a
   newline boundary (i.e., only `,', `.', or `TAB' can end the spec). */
void
info_parse_node (string, newlines_okay)
     char *string;
     int newlines_okay;
{
  register int i = 0;

  /* Default the answer. */
  save_filename ((char *)NULL);
  save_nodename ((char *)NULL);

  /* Special case of nothing passed.  Return nothing. */
  if (!string || !*string)
    return;

  string += skip_whitespace (string);

  /* Check for (FILENAME)NODENAME. */
  if (*string == '(')
    {
      i = 0;
      /* Advance past the opening paren. */
      string++;

      /* Find the closing paren. */
      while (string[i] && string[i] != ')')
	i++;

      /* Remember parsed filename. */
      saven_filename (string, i);

      /* Point directly at the nodename. */
      string += i;

      if (*string)
	string++;
    }

  /* Parse out nodename. */
  i = skip_node_characters (string, newlines_okay);
  saven_nodename (string, i);
  canonicalize_whitespace (info_parsed_nodename);
  if (info_parsed_nodename && !*info_parsed_nodename)
    {
      free (info_parsed_nodename);
      info_parsed_nodename = (char *)NULL;
    }
}

/* Return the node addressed by LABEL in NODE (usually one of "Prev:",
   "Next:", "Up:", "File:", or "Node:".  After a call to this function,
   the global INFO_PARSED_NODENAME and INFO_PARSED_FILENAME contain
   the information. */
void
info_parse_label (label, node)
     char *label;
     NODE *node;
{
  register int i;
  char *nodeline;

  /* Default answer to failure. */
  save_nodename ((char *)NULL);
  save_filename ((char *)NULL);

  /* Find the label in the first line of this node. */
  nodeline = node->contents;
  i = string_in_line (label, nodeline);

  if (i == -1)
    return;

  nodeline += i;
  nodeline += skip_whitespace (nodeline);
  info_parse_node (nodeline, DONT_SKIP_NEWLINES);
}

/* **************************************************************** */
/*								    */
/*		    Finding and Building Menus			    */
/*								    */
/* **************************************************************** */

/* Return a NULL terminated array of REFERENCE * which represents the menu
   found in NODE.  If there is no menu in NODE, just return a NULL pointer. */
REFERENCE **
info_menu_of_node (node)
     NODE *node;
{
  long position;
  SEARCH_BINDING search;
  REFERENCE **menu = (REFERENCE **)NULL;

  search.buffer = node->contents;
  search.start = 0;
  search.end = node->nodelen;
  search.flags = S_FoldCase;

  /* Find the start of the menu. */
  position = search_forward (INFO_MENU_LABEL, &search);

  if (position == -1)
    return ((REFERENCE **) NULL);

  /* We have the start of the menu now.  Glean menu items from the rest
     of the node. */
  search.start = position + strlen (INFO_MENU_LABEL);
  search.start += skip_line (search.buffer + search.start);
  search.start--;
  menu = info_menu_items (&search);
  return (menu);
}

/* Return a NULL terminated array of REFERENCE * which represents the cross
   refrences found in NODE.  If there are no cross references in NODE, just
   return a NULL pointer. */
REFERENCE **
info_xrefs_of_node (node)
     NODE *node;
{
  SEARCH_BINDING search;

#if defined (HANDLE_MAN_PAGES)
  if (node->flags & N_IsManPage)
    return (xrefs_of_manpage (node));
#endif

  search.buffer = node->contents;
  search.start = 0;
  search.end = node->nodelen;
  search.flags = S_FoldCase;

  return (info_xrefs (&search));
}

/* Glean menu entries from BINDING->buffer + BINDING->start until we
   have looked at the entire contents of BINDING.  Return an array
   of REFERENCE * that represents each menu item in this range. */
REFERENCE **
info_menu_items (binding)
     SEARCH_BINDING *binding;
{
  return (info_references_internal (INFO_MENU_ENTRY_LABEL, binding));
}

/* Glean cross references from BINDING->buffer + BINDING->start until
   BINDING->end.  Return an array of REFERENCE * that represents each
   cross reference in this range. */
REFERENCE **
info_xrefs (binding)
     SEARCH_BINDING *binding;
{
  return (info_references_internal (INFO_XREF_LABEL, binding));
}

/* Glean cross references or menu items from BINDING.  Return an array
   of REFERENCE * that represents the items found. */
static REFERENCE **
info_references_internal (label, binding)
     char *label;
     SEARCH_BINDING *binding;
{
  SEARCH_BINDING search;
  REFERENCE **refs = (REFERENCE **)NULL;
  int refs_index = 0, refs_slots = 0;
  int searching_for_menu_items = 0;
  long position;

  search.buffer = binding->buffer;
  search.start = binding->start;
  search.end = binding->end;
  search.flags = S_FoldCase | S_SkipDest;

  searching_for_menu_items = (strcasecmp (label, INFO_MENU_ENTRY_LABEL) == 0);

  while ((position = search_forward (label, &search)) != -1)
    {
      int offset, start;
      char *refdef;
      REFERENCE *entry;

      search.start = position;
      search.start += skip_whitespace (search.buffer + search.start);
      start = search.start - binding->start;
      refdef = search.buffer + search.start;
      offset = string_in_line (":", refdef);

      /* When searching for menu items, if no colon, there is no
	 menu item on this line. */
      if (offset == -1)
	{
	  if (searching_for_menu_items)
	    continue;
	  else
	    {
	      int temp;

	      temp = skip_line (refdef);
	      offset = string_in_line (":", refdef + temp);
	      if (offset == -1)
		continue;	/* Give up? */
	      else
		offset += temp;
	    }
	}

      entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
      entry->filename = (char *)NULL;
      entry->nodename = (char *)NULL;
      entry->label = (char *)xmalloc (offset);
      strncpy (entry->label, refdef, offset - 1);
      entry->label[offset - 1] = '\0';
      canonicalize_whitespace (entry->label);

      refdef += offset;
      entry->start = start;
      entry->end = refdef - binding->buffer;

      /* If this reference entry continues with another ':' then the
	 nodename is the same as the label. */
      if (*refdef == ':')
	{
	  entry->nodename = strdup (entry->label);
	}
      else
	{
	  /* This entry continues with a specific nodename.  Parse the
	     nodename from the specification. */

	  refdef += skip_whitespace_and_newlines (refdef);

	  if (searching_for_menu_items)
	    info_parse_node (refdef, DONT_SKIP_NEWLINES);
	  else
	    info_parse_node (refdef, SKIP_NEWLINES);

	  if (info_parsed_filename)
	    entry->filename = strdup (info_parsed_filename);

	  if (info_parsed_nodename)
	    entry->nodename = strdup (info_parsed_nodename);
	}

      add_pointer_to_array
	(entry, refs_index, refs, refs_slots, 50, REFERENCE *);
    }
  return (refs);
}

/* Get the entry associated with LABEL in MENU.  Return a pointer to the
   REFERENCE if found, or NULL. */
REFERENCE *
info_get_labeled_reference (label, references)
     char *label;
     REFERENCE **references;
{
  register int i;
  REFERENCE *entry;

  for (i = 0; references && (entry = references[i]); i++)
    {
      if (strcmp (label, entry->label) == 0)
	return (entry);
    }
  return ((REFERENCE *)NULL);
}

/* A utility function for concatenating REFERENCE **.  Returns a new
   REFERENCE ** which is the concatenation of REF1 and REF2.  The REF1
   and REF2 arrays are freed, but their contents are not. */
REFERENCE **
info_concatenate_references (ref1, ref2)
     REFERENCE **ref1, **ref2;
{
  register int i, j;
  REFERENCE **result;
  int size;

  /* With one argument passed as NULL, simply return the other arg. */
  if (!ref1)
    return (ref2);
  else if (!ref2)
    return (ref1);

  /* Get the total size of the slots that we will need. */
  for (i = 0; ref1[i]; i++);
  size = i;
  for (i = 0; ref2[i]; i++);
  size += i;

  result = (REFERENCE **)xmalloc ((1 + size) * sizeof (REFERENCE *));

  /* Copy the contents over. */
  for (i = 0; ref1[i]; i++)
    result[i] = ref1[i];

  j = i;
  for (i = 0; ref2[i]; i++)
    result[j++] = ref2[i];

  result[j] = (REFERENCE *)NULL;
  free (ref1);
  free (ref2);
  return (result);
}

/* Free the data associated with REFERENCES. */
void
info_free_references (references)
     REFERENCE **references;
{
  register int i;
  REFERENCE *entry;

  if (references)
    {
      for (i = 0; references && (entry = references[i]); i++)
	{
	  maybe_free (entry->label);
	  maybe_free (entry->filename);
	  maybe_free (entry->nodename);

	  free (entry);
	}

      free (references);
    }
}

/* Search for sequences of whitespace or newlines in STRING, replacing
   all such sequences with just a single space.  Remove whitespace from
   start and end of string. */
void
canonicalize_whitespace (string)
     char *string;
{
  register int i, j;
  int len, whitespace_found, whitespace_loc;
  char *temp;

  if (!string)
    return;

  len = strlen (string);
  temp = (char *)xmalloc (1 + len);

  /* Search for sequences of whitespace or newlines.  Replace all such
     sequences in the string with just a single space. */

  whitespace_found = 0;
  for (i = 0, j = 0; string[i]; i++)
    {
      if (whitespace_or_newline (string[i]))
	{
	  whitespace_found++;
	  whitespace_loc = i;
	  continue;
	}
      else
	{
	  if (whitespace_found && whitespace_loc)
	    {
	      whitespace_found = 0;

	      /* Suppress whitespace at start of string. */
	      if (j)
		temp[j++] = ' ';
	    }

	  temp[j++] = string[i];
	}
    }

  /* Kill trailing whitespace. */
  if (j && whitespace (temp[j - 1]))
    j--;

  temp[j] = '\0';
  strcpy (string, temp);
  free (temp);
}

/* String representation of a char returned by printed_representation (). */
static char the_rep[10];

/* Return a pointer to a string which is the printed representation
   of CHARACTER if it were printed at HPOS. */
char *
printed_representation (character, hpos)
     unsigned char character;
     int hpos;
{
  register int i = 0;
  int printable_limit;

  if (ISO_Latin_p)
    printable_limit = 160;
  else
    printable_limit = 127;

  if (character == '\177')
    {
      the_rep[i++] = '^';
      the_rep[i++] = '?';
    }
  else if (iscntrl (character))
    {
      switch (character)
	{
	case '\r':
	case '\n':
	  the_rep[i++] = character;
	  break;

	case '\t':
	  {
	    int tw;

	    tw = ((hpos + 8) & 0xf8) - hpos;
	    while (i < tw)
	      the_rep[i++] = ' ';
	  }
	  break;

	default:
	  the_rep[i++] = '^';
	  the_rep[i++] = (character | 0x40);
	}
    }
  else if (character > printable_limit)
    {
      sprintf (the_rep + i, "\\%0o", character);
      i = strlen (the_rep);
    }
  else
    the_rep[i++] = character;

  the_rep[i] = '\0';

  return (the_rep);
}


/* **************************************************************** */
/*								    */
/*		    Functions Static To This File		    */
/*								    */
/* **************************************************************** */

/* Amount of space allocated to INFO_PARSED_FILENAME via xmalloc (). */
static int parsed_filename_size = 0;

/* Amount of space allocated to INFO_PARSED_NODENAME via xmalloc (). */
static int parsed_nodename_size = 0;

static void save_string (), saven_string ();

/* Remember FILENAME in PARSED_FILENAME.  An empty FILENAME is translated
   to a NULL pointer in PARSED_FILENAME. */
static void
save_filename (filename)
     char *filename;
{
  save_string (filename, &info_parsed_filename, &parsed_filename_size);
}

/* Just like save_filename (), but you pass the length of the string. */
static void
saven_filename (filename, len)
     char *filename;
     int len;
{
  saven_string (filename, len,
		&info_parsed_filename, &parsed_filename_size);
}

/* Remember NODENAME in PARSED_NODENAME.  An empty NODENAME is translated
   to a NULL pointer in PARSED_NODENAME. */
static void
save_nodename (nodename)
     char *nodename;
{
  save_string (nodename, &info_parsed_nodename, &parsed_nodename_size);
}

/* Just like save_nodename (), but you pass the length of the string. */
static void
saven_nodename (nodename, len)
     char *nodename;
     int len;
{
  saven_string (nodename, len,
		&info_parsed_nodename, &parsed_nodename_size);
}

/* Remember STRING in STRING_P.  STRING_P should currently have STRING_SIZE_P
   bytes allocated to it.  An empty STRING is translated to a NULL pointer
   in STRING_P. */
static void
save_string (string, string_p, string_size_p)
     char *string;
     char **string_p;
     int *string_size_p;
{
  if (!string || !*string)
    {
      if (*string_p)
	free (*string_p);

      *string_p = (char *)NULL;
      *string_size_p = 0;
    }
  else
    {
      if (strlen (string) >= *string_size_p)
	*string_p = (char *)xrealloc
	  (*string_p, (*string_size_p = 1 + strlen (string)));

      strcpy (*string_p, string);
    }
}

/* Just like save_string (), but you also pass the length of STRING. */
static void
saven_string (string, len, string_p, string_size_p)
     char *string;
     int len;
     char **string_p;
     int *string_size_p;
{
  if (!string)
    {
      if (*string_p)
	free (*string_p);

      *string_p = (char *)NULL;
      *string_size_p = 0;
    }
  else
    {
      if (len >= *string_size_p)
	*string_p = (char *)xrealloc (*string_p, (*string_size_p = 1 + len));

      strncpy (*string_p, string, len);
      (*string_p)[len] = '\0';
    }
}

/* Return a pointer to the part of PATHNAME that simply defines the file. */
char *
filename_non_directory (pathname)
     char *pathname;
{
  char *filename;

  filename = (char *) strrchr (pathname, '/');

  if (filename)
    filename++;
  else
    filename = pathname;

  return (filename);
}

/* Return non-zero if NODE is one especially created by Info. */
int
internal_info_node_p (node)
     NODE *node;
{
#if defined (NEVER)
  if (node &&
      (node->filename && !*node->filename) &&
      !node->parent && node->nodename)
    return (1);
  else
    return (0);
#else
  return ((node != (NODE *)NULL) && ((node->flags & N_IsInternal) != 0));
#endif /* !NEVER */
}

/* Make NODE appear to be one especially created by Info. */
void
name_internal_node (node, name)
     NODE *node;
     char *name;
{
  if (!node)
    return;

  node->filename = "";
  node->parent = (char *)NULL;
  node->nodename = name;
  node->flags |= N_IsInternal;
}

/* Return the window displaying NAME, the name of an internally created
   Info window. */
WINDOW *
get_internal_info_window (name)
     char *name;
{
  WINDOW *win;

  for (win = windows; win; win = win->next)
    if (internal_info_node_p (win->node) &&
	(strcmp (win->node->nodename, name) == 0))
      break;

  return (win);
}
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d24 7
a30 1
#include "info.h"
d32 1
d87 1
a87 1
        i++;
d96 1
a96 1
        string++;
d139 3
a141 3
/*                                                                  */
/*                  Finding and Building Menus                      */
/*                                                                  */
d249 1
a249 1
         menu item on this line. */
d251 15
a265 15
        {
          if (searching_for_menu_items)
            continue;
          else
            {
              int temp;

              temp = skip_line (refdef);
              offset = string_in_line (":", refdef + temp);
              if (offset == -1)
                continue;       /* Give up? */
              else
                offset += temp;
            }
        }
d280 1
a280 1
         nodename is the same as the label. */
d282 3
a284 3
        {
          entry->nodename = xstrdup (entry->label);
        }
d286 17
a302 17
        {
          /* This entry continues with a specific nodename.  Parse the
             nodename from the specification. */

          refdef += skip_whitespace_and_newlines (refdef);

          if (searching_for_menu_items)
            info_parse_node (refdef, DONT_SKIP_NEWLINES);
          else
            info_parse_node (refdef, SKIP_NEWLINES);

          if (info_parsed_filename)
            entry->filename = xstrdup (info_parsed_filename);

          if (info_parsed_nodename)
            entry->nodename = xstrdup (info_parsed_nodename);
        }
d305 1
a305 1
        (entry, refs_index, refs, refs_slots, 50, REFERENCE *);
d323 1
a323 1
        return (entry);
d378 4
a381 4
        {
          maybe_free (entry->label);
          maybe_free (entry->filename);
          maybe_free (entry->nodename);
d383 2
a384 2
          free (entry);
        }
d414 5
a418 5
        {
          whitespace_found++;
          whitespace_loc = i;
          continue;
        }
d420 9
a428 9
        {
          if (whitespace_found && whitespace_loc)
            {
              whitespace_found = 0;

              /* Suppress whitespace at start of string. */
              if (j)
                temp[j++] = ' ';
            }
d430 2
a431 2
          temp[j++] = string[i];
        }
d469 20
a488 20
        {
        case '\r':
        case '\n':
          the_rep[i++] = character;
          break;

        case '\t':
          {
            int tw;

            tw = ((hpos + 8) & 0xf8) - hpos;
            while (i < tw)
              the_rep[i++] = ' ';
          }
          break;

        default:
          the_rep[i++] = '^';
          the_rep[i++] = (character | 0x40);
        }
d505 3
a507 3
/*                                                                  */
/*                  Functions Static To This File                   */
/*                                                                  */
d534 1
a534 1
                &info_parsed_filename, &parsed_filename_size);
d553 1
a553 1
                &info_parsed_nodename, &parsed_nodename_size);
d568 1
a568 1
        free (*string_p);
d576 2
a577 2
        *string_p = (char *)xrealloc
          (*string_p, (*string_size_p = 1 + strlen (string)));
d594 1
a594 1
        free (*string_p);
d602 1
a602 1
        *string_p = (char *)xrealloc (*string_p, (*string_size_p = 1 + len));
d668 1
a668 1
        (strcmp (win->node->nodename, name) == 0))
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 1
a1 2
/* info-utils.c -- miscellanous.
   $Id: info-utils.c,v 1.7 1998/08/10 18:07:47 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 98 Free Software Foundation, Inc.
d32 1
a32 1
int ISO_Latin_p = 1;
d303 2
a304 2
/* Get the entry associated with LABEL in REFERENCES.  Return a pointer
   to the ENTRY if found, or NULL. */
d447 13
a459 4
  int printable_limit = ISO_Latin_p ? 255 : 127;
    
  /* Show CTRL-x as ^X.  */
  if (iscntrl (character) && character < 127)
a482 1
  /* Show META-x as 0370.  */
a487 5
  else if (character == DEL)
    {
      the_rep[i++] = '^';
      the_rep[i++] = '?';
    }
d491 1
a491 1
  the_rep[i] = 0;
d493 1
a493 1
  return the_rep;
d607 1
a607 1
  register char *filename = pathname + strlen (pathname);
d609 1
a609 2
  if (HAVE_DRIVE (pathname))
    pathname += 2;
d611 4
a614 2
  while (filename > pathname && !IS_SLASH (filename[-1]))
    filename--;
a661 14
      break;

  return (win);
}

/* Return a window displaying the node NODE. */
WINDOW *
get_window_of_node (node)
     NODE *node;
{
  WINDOW *win = (WINDOW *)NULL;

  for (win = windows; win; win = win->next)
    if (win->node == node)
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: info-utils.c,v 1.8 2002/03/08 21:41:44 karl Exp $
d446 1
a446 3

  if (raw_escapes_p && character == '\033')
    the_rep[i++] = character;
d448 1
a448 1
  else if (iscntrl (character) && character < 127)
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: info-utils.c,v 1.4 2004/04/11 17:56:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 1998, 2003, 2004 Free Software Foundation, Inc.
d20 1
a20 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
a39 4
/* Variable which holds the most recent line number parsed as a result of
   calling info_parse_xxx (). */
int info_parsed_line_number = 0;

d41 2
a42 4
static void save_filename (char *filename);
static void saven_filename (char *filename, int len);
static void save_nodename (char *nodename);
static void saven_nodename (char *nodename, int len);
d45 1
a45 2
static REFERENCE **info_references_internal (char *label,
    SEARCH_BINDING *binding);
d53 3
a55 1
info_parse_node (char *string, int newlines_okay)
a98 31

  /* Parse ``(line ...)'' part of menus, if any.  */
  {
    char *rest = string + i;

    /* Advance only if it's not already at end of string.  */
    if (*rest)
      rest++;

    /* Skip any whitespace first, and then a newline in case the item
       was so long to contain the ``(line ...)'' string in the same
       physical line.  */
    while (whitespace(*rest))
      rest++;
    if (*rest == '\n')
      {
        rest++;
        while (whitespace(*rest))
          rest++;
      }

    /* Are we looking at an opening parenthesis?  That can only mean
       we have a winner. :)  */
    if (strncmp (rest, "(line ", strlen ("(line ")) == 0)
      {
        rest += strlen ("(line ");
        info_parsed_line_number = strtol (rest, NULL, 0);
      }
    else
      info_parsed_line_number = 0;
  }
d106 3
a108 1
info_parse_label (char *label, NODE *node)
d138 2
a139 1
info_menu_of_node (NODE *node)
d142 1
a142 1
  SEARCH_BINDING tmp_search;
d145 4
a148 4
  tmp_search.buffer = node->contents;
  tmp_search.start = 0;
  tmp_search.end = node->nodelen;
  tmp_search.flags = S_FoldCase;
d151 1
a151 1
  position = search_forward (INFO_MENU_LABEL, &tmp_search);
d158 4
a161 4
  tmp_search.start = position + strlen (INFO_MENU_LABEL);
  tmp_search.start += skip_line (tmp_search.buffer + tmp_search.start);
  tmp_search.start--;
  menu = info_menu_items (&tmp_search);
d169 2
a170 1
info_xrefs_of_node (NODE *node)
d172 1
a172 1
  SEARCH_BINDING tmp_search;
d179 4
a182 4
  tmp_search.buffer = node->contents;
  tmp_search.start = 0;
  tmp_search.end = node->nodelen;
  tmp_search.flags = S_FoldCase;
d184 1
a184 1
  return (info_xrefs (&tmp_search));
d191 2
a192 1
info_menu_items (SEARCH_BINDING *binding)
d201 2
a202 1
info_xrefs (SEARCH_BINDING *binding)
d210 3
a212 1
info_references_internal (char *label, SEARCH_BINDING *binding)
d214 1
a214 1
  SEARCH_BINDING tmp_search;
d220 4
a223 4
  tmp_search.buffer = binding->buffer;
  tmp_search.start = binding->start;
  tmp_search.end = binding->end;
  tmp_search.flags = S_FoldCase | S_SkipDest;
d227 1
a227 1
  while ((position = search_forward (label, &tmp_search)) != -1)
d233 4
a236 4
      tmp_search.start = position;
      tmp_search.start += skip_whitespace (tmp_search.buffer + tmp_search.start);
      start = tmp_search.start - binding->start;
      refdef = tmp_search.buffer + tmp_search.start;
a292 2

          entry->line_number = info_parsed_line_number;
d304 3
a306 1
info_get_labeled_reference (char *label, REFERENCE **references)
d323 2
a324 1
info_concatenate_references (REFERENCE **ref1, REFERENCE **ref2)
a357 20


/* Copy a reference structure.  Since we tend to free everything at
   every opportunity, we don't share any points, but copy everything into
   new memory.  */
REFERENCE *
info_copy_reference (REFERENCE *src)
{
  REFERENCE *dest = xmalloc (sizeof (REFERENCE));
  dest->label = src->label ? xstrdup (src->label) : NULL;
  dest->filename = src->filename ? xstrdup (src->filename) : NULL;
  dest->nodename = src->nodename ? xstrdup (src->nodename) : NULL;
  dest->start = src->start;
  dest->end = src->end;
  
  return dest;
}



d360 2
a361 1
info_free_references (REFERENCE **references)
d385 2
a386 1
canonicalize_whitespace (char *string)
d389 1
a389 1
  int len, whitespace_found, whitespace_loc = 0;
d440 3
a442 1
printed_representation (unsigned char character, int hpos)
d506 1
a506 3
static void save_string (char *string, char **string_p, int *string_size_p);
static void saven_string (char *string, int len, char **string_p,
    int *string_size_p);
d511 2
a512 1
save_filename (char *filename)
d519 3
a521 1
saven_filename (char *filename, int len)
d530 2
a531 1
save_nodename (char *nodename)
d538 3
a540 1
saven_nodename (char *nodename, int len)
d550 4
a553 1
save_string (char *string, char **string_p, int *string_size_p)
d565 1
a565 1
      if (strlen (string) >= (unsigned int) *string_size_p)
d575 5
a579 1
saven_string (char *string, int len, char **string_p, int *string_size_p)
d601 2
a602 1
filename_non_directory (char *pathname)
d617 2
a618 1
internal_info_node_p (NODE *node)
d634 3
a636 1
name_internal_node (NODE *node, char *name)
d650 2
a651 1
get_internal_info_window (char *name)
d665 2
a666 1
get_window_of_node (NODE *node)
@


