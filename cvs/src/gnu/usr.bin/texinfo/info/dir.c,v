head	1.5;
access;
symbols
	OPENBSD_6_2:1.5.0.14
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.16
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.12
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.8
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.10
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.6
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.4.0.30
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.28
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.26
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.24
	OPENBSD_5_0:1.4.0.22
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.20
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.18
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	TEXINFO_4_8:1.1.1.4
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	TEXINFO_4_2:1.1.1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2013.08.05.17.02.24;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.39;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.06;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.12;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.12;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.21.59.59;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.24.26;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.07.17.16.03.42;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Use proper types for device and inode numbers

ok kettenis@@
@
text
@/* dir.c -- how to build a special "dir" node from "localdir" files.
   $Id: dir.c,v 1.4 2006/07/17 16:12:36 espie Exp $

   Copyright (C) 1993, 1997, 1998, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "info-utils.h"
#include "filesys.h"
#include "tilde.h"

/* The "dir" node can be built from the contents of a file called "dir",
   with the addition of the menus of every file named in the array
   dirs_to_add which are found in INFOPATH. */

static void add_menu_to_file_buffer (char *contents, long int size,
    FILE_BUFFER *fb);
static void insert_text_into_fb_at_binding (FILE_BUFFER *fb,
    SEARCH_BINDING *binding, char *text, int textlen);
void maybe_build_dir_node (char *dirname);

static char *dirs_to_add[] = {
  "dir", "localdir", (char *)NULL
};


/* Return zero if the file represented in the stat structure TEST has
   already been seen, nonzero else.  */

typedef struct
{
  dev_t device;
  ino_t inode;
} dir_file_list_entry_type;

static int
new_dir_file_p (struct stat *test)
{
  static unsigned dir_file_list_len = 0;
  static dir_file_list_entry_type *dir_file_list = NULL;
  unsigned i;
  
  for (i = 0; i < dir_file_list_len; i++)
    {
      dir_file_list_entry_type entry;
      entry = dir_file_list[i];
      if (entry.device == test->st_dev && entry.inode == test->st_ino)
        return 0;
    }
  
  dir_file_list_len++;
  dir_file_list = xrealloc (dir_file_list, 
                        dir_file_list_len * sizeof (dir_file_list_entry_type));
  dir_file_list[dir_file_list_len - 1].device = test->st_dev;
  dir_file_list[dir_file_list_len - 1].inode = test->st_ino;
  return 1;
}


void
maybe_build_dir_node (char *dirname)
{
  int path_index, update_tags;
  char *this_dir;
  FILE_BUFFER *dir_buffer = info_find_file (dirname);

  /* If there is no "dir" in the current info path, we cannot build one
     from nothing. */
  if (!dir_buffer)
    return;

  /* If this directory has already been built, return now. */
  if (dir_buffer->flags & N_CannotGC)
    return;

  /* Initialize the list we use to avoid reading the same dir file twice
     with the dir file just found.  */
  new_dir_file_p (&dir_buffer->finfo);
  
  path_index = update_tags = 0;

  /* Using each element of the path, check for one of the files in
     DIRS_TO_ADD.  Do not check for "localdir.info.Z" or anything else.
     Only files explictly named are eligible.  This is a design decision.
     There can be an info file name "localdir.info" which contains
     information on the setting up of "localdir" files. */
  while ((this_dir = extract_colon_unit (infopath, &path_index)))
    {
      register int da_index;
      char *from_file;

      /* Expand a leading tilde if one is present. */
      if (*this_dir == '~')
        {
          char *tilde_expanded_dirname;

          tilde_expanded_dirname = tilde_expand_word (this_dir);
          if (tilde_expanded_dirname != this_dir)
            {
              free (this_dir);
              this_dir = tilde_expanded_dirname;
            }
        }

      /* For every different file named in DIRS_TO_ADD found in the
         search path, add that file's menu to our "dir" node. */
      for (da_index = 0; (from_file = dirs_to_add[da_index]); da_index++)
        {
          struct stat finfo;
          int statable;
          int namelen = strlen (from_file);
          char *fullpath = xmalloc (3 + strlen (this_dir) + namelen);
          
          strcpy (fullpath, this_dir);
          if (!IS_SLASH (fullpath[strlen (fullpath) - 1]))
            strcat (fullpath, "/");
          strcat (fullpath, from_file);

          statable = (stat (fullpath, &finfo) == 0);

          /* Only add this file if we have not seen it before.  */
          if (statable && S_ISREG (finfo.st_mode) && new_dir_file_p (&finfo))
            {
              long filesize;
	      int compressed;
              char *contents = filesys_read_info_file (fullpath, &filesize,
                                                       &finfo, &compressed);
              if (contents)
                {
                  update_tags++;
                  add_menu_to_file_buffer (contents, filesize, dir_buffer);
                  free (contents);
                }
            }

          free (fullpath);
        }
      free (this_dir);
    }

  if (update_tags)
    build_tags_and_nodes (dir_buffer);

  /* Flag that the dir buffer has been built. */
  dir_buffer->flags |= N_CannotGC;
}

/* Given CONTENTS and FB (a file buffer), add the menu found in CONTENTS
   to the menu found in FB->contents.  Second argument SIZE is the total
   size of CONTENTS. */
static void
add_menu_to_file_buffer (char *contents, long int size, FILE_BUFFER *fb)
{
  SEARCH_BINDING contents_binding, fb_binding;
  long contents_offset, fb_offset;

  contents_binding.buffer = contents;
  contents_binding.start = 0;
  contents_binding.end = size;
  contents_binding.flags = S_FoldCase | S_SkipDest;

  fb_binding.buffer = fb->contents;
  fb_binding.start = 0;
  fb_binding.end = fb->filesize;
  fb_binding.flags = S_FoldCase | S_SkipDest;

  /* Move to the start of the menus in CONTENTS and FB. */
  contents_offset = search_forward (INFO_MENU_LABEL, &contents_binding);
  fb_offset = search_forward (INFO_MENU_LABEL, &fb_binding);

  /* If there is no menu in CONTENTS, quit now. */
  if (contents_offset == -1)
    return;

  /* There is a menu in CONTENTS, and contents_offset points to the first
     character following the menu starter string.  Skip all whitespace
     and newline characters. */
  contents_offset += skip_whitespace_and_newlines (contents + contents_offset);

  /* If there is no menu in FB, make one. */
  if (fb_offset == -1)
    {
      /* Find the start of the second node in this file buffer.  If there
         is only one node, we will be adding the contents to the end of
         this node. */
      fb_offset = find_node_separator (&fb_binding);

      /* If not even a single node separator, give up. */
      if (fb_offset == -1)
        return;

      fb_binding.start = fb_offset;
      fb_binding.start +=
        skip_node_separator (fb_binding.buffer + fb_binding.start);

      /* Try to find the next node separator. */
      fb_offset = find_node_separator (&fb_binding);

      /* If found one, consider that the start of the menu.  Otherwise, the
         start of this menu is the end of the file buffer (i.e., fb->size). */
      if (fb_offset != -1)
        fb_binding.start = fb_offset;
      else
        fb_binding.start = fb_binding.end;

      insert_text_into_fb_at_binding
        (fb, &fb_binding, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));

      fb_binding.buffer = fb->contents;
      fb_binding.start = 0;
      fb_binding.end = fb->filesize;
      fb_offset = search_forward (INFO_MENU_LABEL, &fb_binding);
      if (fb_offset == -1)
        abort ();
    }

  /* CONTENTS_OFFSET and FB_OFFSET point to the starts of the menus that
     appear in their respective buffers.  Add the remainder of CONTENTS
     to the end of FB's menu. */
  fb_binding.start = fb_offset;
  fb_offset = find_node_separator (&fb_binding);
  if (fb_offset != -1)
    fb_binding.start = fb_offset;
  else
    fb_binding.start = fb_binding.end;

  /* Leave exactly one blank line between directory entries. */
  {
    int num_found = 0;

    while ((fb_binding.start > 0) &&
           (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))
      {
        num_found++;
        fb_binding.start--;
      }

    /* Optimize if possible. */
    if (num_found >= 2)
      {
        fb_binding.buffer[fb_binding.start++] = '\n';
        fb_binding.buffer[fb_binding.start++] = '\n';
      }
    else
      {
        /* Do it the hard way. */
        insert_text_into_fb_at_binding (fb, &fb_binding, "\n\n", 2);
        fb_binding.start += 2;
      }
  }

  /* Insert the new menu. */
  insert_text_into_fb_at_binding
    (fb, &fb_binding, contents + contents_offset, size - contents_offset);
}

static void
insert_text_into_fb_at_binding (FILE_BUFFER *fb,
    SEARCH_BINDING *binding, char *text, int textlen)
{
  char *contents;
  long start, end;

  start = binding->start;
  end = fb->filesize;

  contents = (char *)xmalloc (fb->filesize + textlen + 1);
  memcpy (contents, fb->contents, start);
  memcpy (contents + start, text, textlen);
  memcpy (contents + start + textlen, fb->contents + start, end - start);
  free (fb->contents);
  fb->contents = contents;
  fb->filesize += textlen;
  fb->finfo.st_size = fb->filesize;
}
@


1.4
log
@conflict resolution
@
text
@d2 1
a2 1
   $Id: dir.c,v 1.3 2004/04/11 17:56:45 karl Exp $
d47 2
a48 2
  unsigned long device;
  unsigned long inode;
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: dir.c,v 1.7 1998/06/28 19:51:36 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d31 5
a35 1
static void add_menu_to_file_buffer (), insert_text_into_fb_at_binding ();
d52 1
a52 2
new_dir_file_p (test)
    struct stat *test;
d76 1
a76 2
maybe_build_dir_node (dirname)
     char *dirname;
d167 1
a167 4
add_menu_to_file_buffer (contents, size, fb)
     char *contents;
     long size;
     FILE_BUFFER *fb;
d273 2
a274 5
insert_text_into_fb_at_binding (fb, binding, text, textlen)
     FILE_BUFFER *fb;
     SEARCH_BINDING *binding;
     char *text;
     int textlen;
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d1 2
a2 2
/* dir.c -- How to build a special "dir" node from "localdir" files.
   $Id: dir.c,v 1.6 1997/07/27 21:09:20 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d128 1
a128 1
          if (fullpath[strlen (fullpath) - 1] != '/')
d138 1
d140 1
a140 1
                                                       &finfo);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* dir.c -- How to build a special "dir" node from "localdir" files. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
d22 1
a22 7
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#if defined (HAVE_SYS_FILE_H)
#include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */
#include <sys/errno.h>
a31 1
static void build_dir_node_internal ();
d37 35
a75 1
  FILE_BUFFER *dir_buffer;
d78 1
a78 4

  /* Check to see if the file has already been built.  If so, then
     do not build it again. */
  dir_buffer = info_find_file (dirname);
d89 4
d100 1
a100 1
  while (this_dir = extract_colon_unit (infopath, &path_index))
d107 2
a108 2
	{
	  char *tilde_expanded_dirname;
d110 37
a146 43
	  tilde_expanded_dirname = tilde_expand_word (this_dir);
	  if (tilde_expanded_dirname != this_dir)
	    {
	      free (this_dir);
	      this_dir = tilde_expanded_dirname;
	    }
	}

      /* For every file named in DIRS_TO_ADD found in the search path,
	 add the contents of that file's menu to our "dir" node. */
      for (da_index = 0; from_file = dirs_to_add[da_index]; da_index++)
	{
	  struct stat finfo;
	  char *fullpath;
	  int namelen, statable;

	  namelen = strlen (from_file);

	  fullpath = (char *)xmalloc (3 + strlen (this_dir) + namelen);
	  strcpy (fullpath, this_dir);
	  if (fullpath[strlen (fullpath) - 1] != '/')
	    strcat (fullpath, "/");
	  strcat (fullpath, from_file);

	  statable = (stat (fullpath, &finfo) == 0);

	  /* Only add the contents of this file if it is not identical to the
	     file of the DIR buffer. */
	  if ((statable && S_ISREG (finfo.st_mode)) &&
	      (strcmp (dir_buffer->fullpath, fullpath) != 0))
	    {
	      long filesize;
	      char *contents;

	      contents = filesys_read_info_file (fullpath, &filesize, &finfo);

	      if (contents)
		{
		  update_tags++;
		  add_menu_to_file_buffer (contents, filesize, dir_buffer);
		  free (contents);
		}
	    }
d148 2
a149 2
	  free (fullpath);
	}
d199 2
a200 2
	 is only one node, we will be adding the contents to the end of
	 this node. */
d205 1
a205 1
	return;
d209 1
a209 1
	skip_node_separator (fb_binding.buffer + fb_binding.start);
d215 1
a215 1
	 start of this menu is the end of the file buffer (i.e., fb->size). */
d217 1
a217 1
	fb_binding.start = fb_offset;
d219 1
a219 1
	fb_binding.start = fb_binding.end;
d222 1
a222 1
	(fb, &fb_binding, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));
d229 1
a229 1
	abort ();
d247 1
a247 1
	   (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))
d249 2
a250 2
	num_found++;
	fb_binding.start--;
d256 2
a257 2
	fb_binding.buffer[fb_binding.start++] = '\n';
	fb_binding.buffer[fb_binding.start++] = '\n';
d261 3
a263 3
	/* Do it the hard way. */
	insert_text_into_fb_at_binding (fb, &fb_binding, "\n\n", 2);
	fb_binding.start += 2;
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* dir.c -- How to build a special "dir" node from "localdir" files.
   $Id: dir.c,v 1.6 1997/07/27 21:09:20 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d24 7
a30 1
#include "info.h"
d40 1
a45 35

/* Return zero if the file represented in the stat structure TEST has
   already been seen, nonzero else.  */

typedef struct
{
  unsigned long device;
  unsigned long inode;
} dir_file_list_entry_type;

static int
new_dir_file_p (test)
    struct stat *test;
{
  static unsigned dir_file_list_len = 0;
  static dir_file_list_entry_type *dir_file_list = NULL;
  unsigned i;
  
  for (i = 0; i < dir_file_list_len; i++)
    {
      dir_file_list_entry_type entry;
      entry = dir_file_list[i];
      if (entry.device == test->st_dev && entry.inode == test->st_ino)
        return 0;
    }
  
  dir_file_list_len++;
  dir_file_list = xrealloc (dir_file_list, 
                        dir_file_list_len * sizeof (dir_file_list_entry_type));
  dir_file_list[dir_file_list_len - 1].device = test->st_dev;
  dir_file_list[dir_file_list_len - 1].inode = test->st_ino;
  return 1;
}


d50 1
d53 4
a56 1
  FILE_BUFFER *dir_buffer = info_find_file (dirname);
a66 4
  /* Initialize the list we use to avoid reading the same dir file twice
     with the dir file just found.  */
  new_dir_file_p (&dir_buffer->finfo);
  
d74 1
a74 1
  while ((this_dir = extract_colon_unit (infopath, &path_index)))
d81 2
a82 2
        {
          char *tilde_expanded_dirname;
d84 43
a126 37
          tilde_expanded_dirname = tilde_expand_word (this_dir);
          if (tilde_expanded_dirname != this_dir)
            {
              free (this_dir);
              this_dir = tilde_expanded_dirname;
            }
        }

      /* For every different file named in DIRS_TO_ADD found in the
         search path, add that file's menu to our "dir" node. */
      for (da_index = 0; (from_file = dirs_to_add[da_index]); da_index++)
        {
          struct stat finfo;
          int statable;
          int namelen = strlen (from_file);
          char *fullpath = xmalloc (3 + strlen (this_dir) + namelen);
          
          strcpy (fullpath, this_dir);
          if (fullpath[strlen (fullpath) - 1] != '/')
            strcat (fullpath, "/");
          strcat (fullpath, from_file);

          statable = (stat (fullpath, &finfo) == 0);

          /* Only add this file if we have not seen it before.  */
          if (statable && S_ISREG (finfo.st_mode) && new_dir_file_p (&finfo))
            {
              long filesize;
              char *contents = filesys_read_info_file (fullpath, &filesize,
                                                       &finfo);
              if (contents)
                {
                  update_tags++;
                  add_menu_to_file_buffer (contents, filesize, dir_buffer);
                  free (contents);
                }
            }
d128 2
a129 2
          free (fullpath);
        }
d179 2
a180 2
         is only one node, we will be adding the contents to the end of
         this node. */
d185 1
a185 1
        return;
d189 1
a189 1
        skip_node_separator (fb_binding.buffer + fb_binding.start);
d195 1
a195 1
         start of this menu is the end of the file buffer (i.e., fb->size). */
d197 1
a197 1
        fb_binding.start = fb_offset;
d199 1
a199 1
        fb_binding.start = fb_binding.end;
d202 1
a202 1
        (fb, &fb_binding, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL));
d209 1
a209 1
        abort ();
d227 1
a227 1
           (whitespace_or_newline (fb_binding.buffer[fb_binding.start - 1])))
d229 2
a230 2
        num_found++;
        fb_binding.start--;
d236 2
a237 2
        fb_binding.buffer[fb_binding.start++] = '\n';
        fb_binding.buffer[fb_binding.start++] = '\n';
d241 3
a243 3
        /* Do it the hard way. */
        insert_text_into_fb_at_binding (fb, &fb_binding, "\n\n", 2);
        fb_binding.start += 2;
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* dir.c -- how to build a special "dir" node from "localdir" files.
   $Id: dir.c,v 1.7 1998/06/28 19:51:36 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 98 Free Software Foundation, Inc.
d128 1
a128 1
          if (!IS_SLASH (fullpath[strlen (fullpath) - 1]))
a137 1
	      int compressed;
d139 1
a139 1
                                                       &finfo, &compressed);
@


1.1.1.4
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: dir.c,v 1.3 2004/04/11 17:56:45 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 1997, 1998, 2004 Free Software Foundation, Inc.
d31 1
a31 5
static void add_menu_to_file_buffer (char *contents, long int size,
    FILE_BUFFER *fb);
static void insert_text_into_fb_at_binding (FILE_BUFFER *fb,
    SEARCH_BINDING *binding, char *text, int textlen);
void maybe_build_dir_node (char *dirname);
d48 2
a49 1
new_dir_file_p (struct stat *test)
d73 2
a74 1
maybe_build_dir_node (char *dirname)
d165 4
a168 1
add_menu_to_file_buffer (char *contents, long int size, FILE_BUFFER *fb)
d274 5
a278 2
insert_text_into_fb_at_binding (FILE_BUFFER *fb,
    SEARCH_BINDING *binding, char *text, int textlen)
@


