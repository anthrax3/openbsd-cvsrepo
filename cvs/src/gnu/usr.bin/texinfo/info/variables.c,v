head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.46
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.42
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.38
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.40
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.32
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.36
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.34
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.30
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.28
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.26
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.24
	OPENBSD_5_0:1.5.0.22
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.20
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	TEXINFO_4_8:1.1.1.5
	OPENBSD_3_9:1.4.0.16
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.14
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.12
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.10
	OPENBSD_3_6_BASE:1.4
	OPENBSD_3_5:1.4.0.8
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	TEXINFO_4_2:1.1.1.4
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	TEXINFO_4_0:1.1.1.3
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.2
	OPENBSD_2_4:1.1.1.2.0.6
	OPENBSD_2_4_BASE:1.1.1.2
	OPENBSD_2_3:1.1.1.2.0.4
	OPENBSD_2_3_BASE:1.1.1.2
	OPENBSD_2_2:1.1.1.2.0.2
	OPENBSD_2_2_BASE:1.1.1.2
	TEXINFO_3_11:1.1.1.2
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	TEXINFO_3_9:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	TEXINFO_3_7:1.1.1.1
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.10;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.16;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.16;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.08.01.22.00.47;	author kstailey;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.02.09.01.25.02;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.06.10.13.21.11;	author espie;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.07.17.16.03.45;	author espie;	state Exp;
branches;
next	;


desc
@@


1.5
log
@conflict resolution
@
text
@/* variables.c -- how to manipulate user visible variables in Info.
   $Id: variables.c,v 1.3 2004/04/11 17:56:46 karl Exp $

   Copyright (C) 1993, 1997, 2001, 2002, 2004 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "variables.h"

/* **************************************************************** */
/*                                                                  */
/*                  User Visible Variables in Info                  */
/*                                                                  */
/* **************************************************************** */

/* Choices used by the completer when reading a zero/non-zero value for
   a variable. */
static char *on_off_choices[] = { "Off", "On", (char *)NULL };

VARIABLE_ALIST info_variables[] = {
  { "automatic-footnotes",
      N_("When \"On\", footnotes appear and disappear automatically"),
      &auto_footnotes_p, (char **)on_off_choices },

  { "automatic-tiling",
      N_("When \"On\", creating or deleting a window resizes other windows"),
      &auto_tiling_p, (char **)on_off_choices },

  { "visible-bell",
      N_("When \"On\", flash the screen instead of ringing the bell"),
      &terminal_use_visible_bell_p, (char **)on_off_choices },

  { "errors-ring-bell",
      N_("When \"On\", errors cause the bell to ring"),
      &info_error_rings_bell_p, (char **)on_off_choices },

  { "gc-compressed-files",
      N_("When \"On\", Info garbage collects files which had to be uncompressed"),
      &gc_compressed_files, (char **)on_off_choices },
  { "show-index-match",
      N_("When \"On\", the portion of the matched search string is highlighted"),
      &show_index_match, (char **)on_off_choices },

  { "scroll-behaviour",
      N_("Controls what happens when scrolling is requested at the end of a node"),
      &info_scroll_behaviour, (char **)info_scroll_choices },

  { "scroll-step",
      N_("The number lines to scroll when the cursor moves out of the window"),
      &window_scroll_step, (char **)NULL },

  { "ISO-Latin",
      N_("When \"On\", Info accepts and displays ISO Latin characters"),
      &ISO_Latin_p, (char **)on_off_choices },

  { (char *)NULL, (char *)NULL, (int *)NULL, (char **)NULL }
};

DECLARE_INFO_COMMAND (describe_variable, _("Explain the use of a variable"))
{
  VARIABLE_ALIST *var;
  char *description;

  /* Get the variable's name. */
  var = read_variable_name ((char *) _("Describe variable: "), window);

  if (!var)
    return;

  description = (char *)xmalloc (20 + strlen (var->name)
				 + strlen (_(var->doc)));

  if (var->choices)
    sprintf (description, "%s (%s): %s.",
             var->name, var->choices[*(var->value)], _(var->doc));
  else
    sprintf (description, "%s (%d): %s.",
	     var->name, *(var->value), _(var->doc));

  window_message_in_echo_area ("%s", description, NULL);
  free (description);
}

DECLARE_INFO_COMMAND (set_variable, _("Set the value of an Info variable"))
{
  VARIABLE_ALIST *var;
  char *line;

  /* Get the variable's name and value. */
  var = read_variable_name ((char *) _("Set variable: "), window);

  if (!var)
    return;

  /* Read a new value for this variable. */
  {
    char prompt[100];

    if (!var->choices)
      {
        int potential_value;

        if (info_explicit_arg || count != 1)
          potential_value = count;
        else
          potential_value = *(var->value);

        sprintf (prompt, _("Set %s to value (%d): "),
                 var->name, potential_value);
        line = info_read_in_echo_area (active_window, prompt);

        /* If no error was printed, clear the echo area. */
        if (!info_error_was_printed)
          window_clear_echo_area ();

        /* User aborted? */
        if (!line)
          return;

        /* If the user specified a value, get that, otherwise, we are done. */
        canonicalize_whitespace (line);
        if (*line)
          *(var->value) = atoi (line);
        else
          *(var->value) = potential_value;

        free (line);
      }
    else
      {
        register int i;
        REFERENCE **array = (REFERENCE **)NULL;
        int array_index = 0;
        int array_slots = 0;

        for (i = 0; var->choices[i]; i++)
          {
            REFERENCE *entry;

            entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
            entry->label = xstrdup (var->choices[i]);
            entry->nodename = (char *)NULL;
            entry->filename = (char *)NULL;

            add_pointer_to_array
              (entry, array_index, array, array_slots, 10, REFERENCE *);
          }

        sprintf (prompt, _("Set %s to value (%s): "),
                 var->name, var->choices[*(var->value)]);

        /* Ask the completer to read a variable value for us. */
        line = info_read_completing_in_echo_area (window, prompt, array);

        info_free_references (array);

        if (!echo_area_is_active)
          window_clear_echo_area ();

        /* User aborted? */
        if (!line)
          {
            info_abort_key (active_window, 0, 0);
            return;
          }

        /* User accepted default choice?  If so, no change. */
        if (!*line)
          {
            free (line);
            return;
          }

        /* Find the choice in our list of choices. */
        for (i = 0; var->choices[i]; i++)
          if (strcmp (var->choices[i], line) == 0)
            break;

        if (var->choices[i])
          *(var->value) = i;
      }
  }
}

/* Read the name of an Info variable in the echo area and return the
   address of a VARIABLE_ALIST member.  A return value of NULL indicates
   that no variable could be read. */
VARIABLE_ALIST *
read_variable_name (char *prompt, WINDOW *window)
{
  register int i;
  char *line;
  REFERENCE **variables;

  /* Get the completion array of variable names. */
  variables = make_variable_completions_array ();

  /* Ask the completer to read a variable for us. */
  line =
    info_read_completing_in_echo_area (window, prompt, variables);

  info_free_references (variables);

  if (!echo_area_is_active)
    window_clear_echo_area ();

  /* User aborted? */
  if (!line)
    {
      info_abort_key (active_window, 0, 0);
      return ((VARIABLE_ALIST *)NULL);
    }

  /* User accepted "default"?  (There is none.) */
  if (!*line)
    {
      free (line);
      return ((VARIABLE_ALIST *)NULL);
    }

  /* Find the variable in our list of variables. */
  for (i = 0; info_variables[i].name; i++)
    if (strcmp (info_variables[i].name, line) == 0)
      break;

  if (!info_variables[i].name)
    return ((VARIABLE_ALIST *)NULL);
  else
    return (&(info_variables[i]));
}

/* Make an array of REFERENCE which actually contains the names of the
   variables available in Info. */
REFERENCE **
make_variable_completions_array (void)
{
  register int i;
  REFERENCE **array = (REFERENCE **)NULL;
  int array_index = 0, array_slots = 0;

  for (i = 0; info_variables[i].name; i++)
    {
      REFERENCE *entry;

      entry = (REFERENCE *) xmalloc (sizeof (REFERENCE));
      entry->label = xstrdup (info_variables[i].name);
      entry->nodename = (char *)NULL;
      entry->filename = (char *)NULL;

      add_pointer_to_array
        (entry, array_index, array, array_slots, 200, REFERENCE *);
    }

  return (array);
}

#if defined(INFOKEY)

void
set_variable_to_value(char *name, char *value)
{
	register int i;

	/* Find the variable in our list of variables. */
	for (i = 0; info_variables[i].name; i++)
		if (strcmp(info_variables[i].name, name) == 0)
			break;

	if (!info_variables[i].name)
		return;

	if (info_variables[i].choices)
	{
		register int j;

		/* Find the choice in our list of choices. */
		for (j = 0; info_variables[i].choices[j]; j++)
			if (strcmp (info_variables[i].choices[j], value) == 0)
				break;

		if (info_variables[i].choices[j])
			*info_variables[i].value = j;
	}
	else
	{
		*info_variables[i].value = atoi(value);
	}
}

#endif /* INFOKEY */
@


1.4
log
@brain-dead cvs conflict merge
@
text
@d1 2
a2 2
/* variables.c -- How to manipulate user visible variables in Info.
   $Id: variables.c,v 1.8 2001/11/16 23:16:19 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 97, 2001 Free Software Foundation, Inc.
d80 1
a80 1
  var = read_variable_name (_("Describe variable: "), window);
d95 1
a95 1
  window_message_in_echo_area ("%s", description);
d105 1
a105 1
  var = read_variable_name (_("Set variable: "), window);
d204 1
a204 3
read_variable_name (prompt, window)
     char *prompt;
     WINDOW *window;
d250 1
a250 1
make_variable_completions_array ()
d275 1
a275 3
set_variable_to_value(name, value)
	char *name;
	char *value;
@


1.3
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: variables.c,v 1.7 1999/06/25 21:57:40 karl Exp $
d4 1
a4 4
   This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d273 37
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: variables.c,v 1.5 1997/07/18 14:34:23 karl Exp $
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* variables.c -- How to manipulate user visible variables in Info. */
d4 1
a4 1
/* This file is part of GNU Info, a program for reading online documentation
d7 1
a7 1
   Copyright (C) 1993 Free Software Foundation, Inc.
d29 3
a31 3
/*								    */
/*		    User Visible Variables in Info		    */
/*								    */
d40 1
a40 1
      "When \"On\", footnotes appear and disappear automatically",
d44 1
a44 1
      "When \"On\", creating or deleting a window resizes other windows",
d48 1
a48 1
      "When \"On\", flash the screen instead of ringing the bell",
d52 1
a52 1
      "When \"On\", errors cause the bell to ring",
d56 1
a56 1
      "When \"On\", Info garbage collects files which had to be uncompressed",
d59 1
a59 1
      "When \"On\", the portion of the matched search string is highlighted",
d63 1
a63 1
      "Controls what happens when scrolling is requested at the end of a node",
d67 1
a67 1
      "The number lines to scroll when the cursor moves out of the window",
d71 1
a71 1
      "When \"On\", Info accepts and displays ISO Latin characters",
d77 1
a77 1
DECLARE_INFO_COMMAND (describe_variable, "Explain the use of a variable")
d83 1
a83 1
  var = read_variable_name ("Describe variable: ", window);
d88 2
a89 1
  description = (char *)xmalloc (20 + strlen (var->name) + strlen (var->doc));
d93 1
a93 1
	     var->name, var->choices[*(var->value)], var->doc);
d95 2
a96 1
    sprintf (description, "%s (%d): %s.", var->name, *(var->value), var->doc);
d102 1
a102 1
DECLARE_INFO_COMMAND (set_variable, "Set the value of an Info variable")
d108 1
a108 1
  var = read_variable_name ("Set variable: ", window);
d119 1
a119 1
	int potential_value;
d121 23
a143 23
	if (info_explicit_arg || count != 1)
	  potential_value = count;
	else
	  potential_value = *(var->value);

	sprintf (prompt, "Set %s to value (%d): ",
		 var->name, potential_value);
	line = info_read_in_echo_area (active_window, prompt);

	/* If no error was printed, clear the echo area. */
	if (!info_error_was_printed)
	  window_clear_echo_area ();

	/* User aborted? */
	if (!line)
	  return;

	/* If the user specified a value, get that, otherwise, we are done. */
	canonicalize_whitespace (line);
	if (*line)
	  *(var->value) = atoi (line);
	else
	  *(var->value) = potential_value;
d145 1
a145 1
	free (line);
d149 47
a195 47
	register int i;
	REFERENCE **array = (REFERENCE **)NULL;
	int array_index = 0;
	int array_slots = 0;

	for (i = 0; var->choices[i]; i++)
	  {
	    REFERENCE *entry;

	    entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
	    entry->label = strdup (var->choices[i]);
	    entry->nodename = (char *)NULL;
	    entry->filename = (char *)NULL;

	    add_pointer_to_array
	      (entry, array_index, array, array_slots, 10, REFERENCE *);
	  }

	sprintf (prompt, "Set %s to value (%s): ",
		 var->name, var->choices[*(var->value)]);

	/* Ask the completer to read a variable value for us. */
	line = info_read_completing_in_echo_area (window, prompt, array);

	info_free_references (array);

	if (!echo_area_is_active)
	  window_clear_echo_area ();

	/* User aborted? */
	if (!line)
	  {
	    info_abort_key (active_window, 0, 0);
	    return;
	  }

	/* User accepted default choice?  If so, no change. */
	if (!*line)
	  {
	    free (line);
	    return;
	  }

	/* Find the choice in our list of choices. */
	for (i = 0; var->choices[i]; i++)
	  if (strcmp (var->choices[i], line) == 0)
	    break;
d197 2
a198 2
	if (var->choices[i])
	  *(var->value) = i;
d265 2
a266 2
      entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
      entry->label = strdup (info_variables[i].name);
d271 1
a271 1
	(entry, array_index, array, array_slots, 200, REFERENCE *);
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* variables.c -- How to manipulate user visible variables in Info.
   $Id: variables.c,v 1.5 1997/07/18 14:34:23 karl Exp $
d3 1
a3 1
   This file is part of GNU Info, a program for reading online documentation
d6 1
a6 1
   Copyright (C) 1993, 97 Free Software Foundation, Inc.
d28 3
a30 3
/*                                                                  */
/*                  User Visible Variables in Info                  */
/*                                                                  */
d39 1
a39 1
      N_("When \"On\", footnotes appear and disappear automatically"),
d43 1
a43 1
      N_("When \"On\", creating or deleting a window resizes other windows"),
d47 1
a47 1
      N_("When \"On\", flash the screen instead of ringing the bell"),
d51 1
a51 1
      N_("When \"On\", errors cause the bell to ring"),
d55 1
a55 1
      N_("When \"On\", Info garbage collects files which had to be uncompressed"),
d58 1
a58 1
      N_("When \"On\", the portion of the matched search string is highlighted"),
d62 1
a62 1
      N_("Controls what happens when scrolling is requested at the end of a node"),
d66 1
a66 1
      N_("The number lines to scroll when the cursor moves out of the window"),
d70 1
a70 1
      N_("When \"On\", Info accepts and displays ISO Latin characters"),
d76 1
a76 1
DECLARE_INFO_COMMAND (describe_variable, _("Explain the use of a variable"))
d82 1
a82 1
  var = read_variable_name (_("Describe variable: "), window);
d87 1
a87 2
  description = (char *)xmalloc (20 + strlen (var->name)
				 + strlen (_(var->doc)));
d91 1
a91 1
             var->name, var->choices[*(var->value)], _(var->doc));
d93 1
a93 2
    sprintf (description, "%s (%d): %s.",
	     var->name, *(var->value), _(var->doc));
d99 1
a99 1
DECLARE_INFO_COMMAND (set_variable, _("Set the value of an Info variable"))
d105 1
a105 1
  var = read_variable_name (_("Set variable: "), window);
d116 1
a116 1
        int potential_value;
d118 23
a140 23
        if (info_explicit_arg || count != 1)
          potential_value = count;
        else
          potential_value = *(var->value);

        sprintf (prompt, _("Set %s to value (%d): "),
                 var->name, potential_value);
        line = info_read_in_echo_area (active_window, prompt);

        /* If no error was printed, clear the echo area. */
        if (!info_error_was_printed)
          window_clear_echo_area ();

        /* User aborted? */
        if (!line)
          return;

        /* If the user specified a value, get that, otherwise, we are done. */
        canonicalize_whitespace (line);
        if (*line)
          *(var->value) = atoi (line);
        else
          *(var->value) = potential_value;
d142 1
a142 1
        free (line);
d146 47
a192 47
        register int i;
        REFERENCE **array = (REFERENCE **)NULL;
        int array_index = 0;
        int array_slots = 0;

        for (i = 0; var->choices[i]; i++)
          {
            REFERENCE *entry;

            entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
            entry->label = xstrdup (var->choices[i]);
            entry->nodename = (char *)NULL;
            entry->filename = (char *)NULL;

            add_pointer_to_array
              (entry, array_index, array, array_slots, 10, REFERENCE *);
          }

        sprintf (prompt, _("Set %s to value (%s): "),
                 var->name, var->choices[*(var->value)]);

        /* Ask the completer to read a variable value for us. */
        line = info_read_completing_in_echo_area (window, prompt, array);

        info_free_references (array);

        if (!echo_area_is_active)
          window_clear_echo_area ();

        /* User aborted? */
        if (!line)
          {
            info_abort_key (active_window, 0, 0);
            return;
          }

        /* User accepted default choice?  If so, no change. */
        if (!*line)
          {
            free (line);
            return;
          }

        /* Find the choice in our list of choices. */
        for (i = 0; var->choices[i]; i++)
          if (strcmp (var->choices[i], line) == 0)
            break;
d194 2
a195 2
        if (var->choices[i])
          *(var->value) = i;
d262 2
a263 2
      entry = (REFERENCE *) xmalloc (sizeof (REFERENCE));
      entry->label = xstrdup (info_variables[i].name);
d268 1
a268 1
        (entry, array_index, array, array_slots, 200, REFERENCE *);
@


1.1.1.3
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d2 1
a2 1
   $Id: variables.c,v 1.7 1999/06/25 21:57:40 karl Exp $
@


1.1.1.4
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: variables.c,v 1.8 2001/11/16 23:16:19 karl Exp $
d4 4
a7 1
   Copyright (C) 1993, 97, 2001 Free Software Foundation, Inc.
a275 37

#if defined(INFOKEY)

void
set_variable_to_value(name, value)
	char *name;
	char *value;
{
	register int i;

	/* Find the variable in our list of variables. */
	for (i = 0; info_variables[i].name; i++)
		if (strcmp(info_variables[i].name, name) == 0)
			break;

	if (!info_variables[i].name)
		return;

	if (info_variables[i].choices)
	{
		register int j;

		/* Find the choice in our list of choices. */
		for (j = 0; info_variables[i].choices[j]; j++)
			if (strcmp (info_variables[i].choices[j], value) == 0)
				break;

		if (info_variables[i].choices[j])
			*info_variables[i].value = j;
	}
	else
	{
		*info_variables[i].value = atoi(value);
	}
}

#endif /* INFOKEY */
@


1.1.1.5
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d1 2
a2 2
/* variables.c -- how to manipulate user visible variables in Info.
   $Id: variables.c,v 1.3 2004/04/11 17:56:46 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 1997, 2001, 2002, 2004 Free Software Foundation, Inc.
d80 1
a80 1
  var = read_variable_name ((char *) _("Describe variable: "), window);
d95 1
a95 1
  window_message_in_echo_area ("%s", description, NULL);
d105 1
a105 1
  var = read_variable_name ((char *) _("Set variable: "), window);
d204 3
a206 1
read_variable_name (char *prompt, WINDOW *window)
d252 1
a252 1
make_variable_completions_array (void)
d277 3
a279 1
set_variable_to_value(char *name, char *value)
@


