head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.48
	OPENBSD_6_2_BASE:1.6
	OPENBSD_6_1:1.6.0.46
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.42
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.38
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.40
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.32
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.36
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.34
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.30
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.28
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.26
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.24
	OPENBSD_5_0:1.6.0.22
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.20
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.18
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.14
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.16
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.12
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	TEXINFO_4_8:1.1.1.8
	OPENBSD_3_9:1.5.0.16
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.14
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.12
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.10
	OPENBSD_3_6_BASE:1.5
	OPENBSD_3_5:1.5.0.8
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.6
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.4
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	TEXINFO_4_2:1.1.1.7
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	TEXINFO_4_0:1.1.1.6
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	TEXINFO_3_12:1.1.1.5
	OPENBSD_2_4:1.1.1.4.0.6
	OPENBSD_2_4_BASE:1.1.1.4
	OPENBSD_2_3:1.1.1.4.0.4
	OPENBSD_2_3_BASE:1.1.1.4
	OPENBSD_2_2:1.1.1.4.0.2
	OPENBSD_2_2_BASE:1.1.1.4
	TEXINFO_3_11:1.1.1.4
	OPENBSD_2_1:1.1.1.3.0.2
	OPENBSD_2_1_BASE:1.1.1.3
	TEXINFO_3_9:1.1.1.3
	OPENBSD_2_0:1.1.1.2.0.2
	OPENBSD_2_0_BASE:1.1.1.2
	TEXINFO_3_7:1.1.1.2
	TEXINFO_3_6:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2006.07.17.16.12.36;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.10.13.51.03;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.09.02.18.40;	author espie;	state Exp;
branches;
next	1.3;

1.3
date	99.11.22.05.13.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.01.11.16.38.09;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.22.16.47.15;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.07.30.17.34.52;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	96.12.15.21.39.03;	author downsj;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.08.01.22.00.35;	author kstailey;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.01.11.16.32.24;	author espie;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2000.02.09.01.24.58;	author espie;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2002.06.10.13.21.10;	author espie;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.07.17.16.03.44;	author espie;	state Exp;
branches;
next	;


desc
@@


1.6
log
@conflict resolution
@
text
@/* session.c -- user windowing interface to Info.
   $Id: session.c,v 1.16 2004/12/14 00:15:36 karl Exp $

   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Originally written by Brian Fox (bfox@@ai.mit.edu). */

#include "info.h"
#include "search.h"
#include <sys/ioctl.h>

#if defined (HAVE_SYS_TIME_H)
#  include <sys/time.h>
#  define HAVE_STRUCT_TIMEVAL
#endif /* HAVE_SYS_TIME_H */

#if defined (HANDLE_MAN_PAGES)
#  include "man.h"
#endif

static void info_clear_pending_input (void);
static void info_set_pending_input (unsigned char key);
static void info_handle_pointer (char *label, WINDOW *window);
static void display_info_keyseq (int expecting_future_input);
char *node_printed_rep (NODE *node);

/* **************************************************************** */
/*                                                                  */
/*                   Running an Info Session                        */
/*                                                                  */
/* **************************************************************** */

/* The place that we are reading input from. */
static FILE *info_input_stream = NULL;

/* The last executed command. */
VFunction *info_last_executed_command = NULL;

/* Becomes non-zero when 'q' is typed to an Info window. */
int quit_info_immediately = 0;

/* Array of structures describing for each window which nodes have been
   visited in that window. */
INFO_WINDOW **info_windows = NULL;

/* Where to add the next window, if we need to add one. */
static int info_windows_index = 0;

/* Number of slots allocated to `info_windows'. */
static int info_windows_slots = 0;

void remember_window_and_node (WINDOW *window, NODE *node);
void forget_window_and_nodes (WINDOW *window);
void display_startup_message_and_start (void);

/* Begin an info session finding the nodes specified by FILENAME and NODENAMES.
   For each loaded node, create a new window.  Always split the largest of the
   available windows. */
void
begin_multiple_window_info_session (char *filename, char **nodenames)
{
  register int i;
  WINDOW *window = (WINDOW *)NULL;

  for (i = 0; nodenames[i]; i++)
    {
      NODE *node;

      node = info_get_node (filename, nodenames[i]);

      if (!node)
        break;

      /* If this is the first node, initialize the info session. */
      if (!window)
        {
          initialize_info_session (node, 1);
          window = active_window;
        }
      else
        {
          /* Find the largest window in WINDOWS, and make that be the active
             one.  Then split it and add our window and node to the list
             of remembered windows and nodes.  Then tile the windows. */
          WINDOW *win, *largest = NULL;
          int max_height = 0;

          for (win = windows; win; win = win->next)
            if (win->height > max_height)
              {
                max_height = win->height;
                largest = win;
              }

          if (!largest)
            {
              display_update_display (windows);
              info_error ((char *) msg_cant_find_window, NULL, NULL);
              info_session ();
              xexit (0);
            }

          active_window = largest;
          window = window_make_window (node);
          if (window)
            {
              window_tile_windows (TILE_INTERNALS);
              remember_window_and_node (window, node);
            }
          else
            {
              display_update_display (windows);
              info_error ((char *) msg_win_too_small, NULL, NULL);
              info_session ();
              xexit (0);
            }
        }
    }
  display_startup_message_and_start ();
}

/* Start an info session with INITIAL_NODE, and an error message in the echo
   area made from FORMAT and ARG. */
void
begin_info_session_with_error (NODE *initial_node, char *format,
    void *arg1, void *arg2)
{
  initialize_info_session (initial_node, 1);
  info_error (format, arg1, arg2);
  info_session ();
}

/* Start an info session with INITIAL_NODE. */
void
begin_info_session (NODE *initial_node)
{
  initialize_info_session (initial_node, 1);
  display_startup_message_and_start ();
}

void
display_startup_message_and_start (void)
{
  char *format;

  format = replace_in_documentation
    ((char *) _("Welcome to Info version %s. Type \\[get-help-window] for help, \\[menu-item] for menu item."),
     0);

  window_message_in_echo_area (format, VERSION, NULL);
  info_session ();
}

/* Run an info session with an already initialized window and node. */
void
info_session (void)
{
  display_update_display (windows);
  info_last_executed_command = NULL;
  info_read_and_dispatch ();
  /* On program exit, leave the cursor at the bottom of the window, and
     restore the terminal I/O. */
  terminal_goto_xy (0, screenheight - 1);
  terminal_clear_to_eol ();
  fflush (stdout);
  terminal_unprep_terminal ();
  close_dribble_file ();
}

/* Here is a window-location dependent event loop.  Called from the
   functions info_session (), and from read_xxx_in_echo_area (). */
void
info_read_and_dispatch (void)
{
  unsigned char key;
  int done;
  done = 0;

  while (!done && !quit_info_immediately)
    {
      int lk = 0;

      /* If we haven't just gone up or down a line, there is no
         goal column for this window. */
      if ((info_last_executed_command != (VFunction *) info_next_line) &&
          (info_last_executed_command != (VFunction *) info_prev_line))
        active_window->goal_column = -1;

      if (echo_area_is_active)
        {
          lk = echo_area_last_command_was_kill;
          echo_area_prep_read ();
        }

      if (!info_any_buffered_input_p ())
        display_update_display (windows);

      display_cursor_at_point (active_window);
      info_initialize_numeric_arg ();

      initialize_keyseq ();
      key = info_get_input_char ();

      /* No errors yet.  We just read a character, that's all.  Only clear
         the echo_area if it is not currently active. */
      if (!echo_area_is_active)
        window_clear_echo_area ();

      info_error_was_printed = 0;

      /* Do the selected command. */
      info_dispatch_on_key (key, active_window->keymap);

      if (echo_area_is_active)
        {
          /* Echo area commands that do killing increment the value of
             ECHO_AREA_LAST_COMMAND_WAS_KILL.  Thus, if there is no
             change in the value of this variable, the last command
             executed was not a kill command. */
          if (lk == echo_area_last_command_was_kill)
            echo_area_last_command_was_kill = 0;

          if (ea_last_executed_command == (VFunction *) ea_newline ||
              info_aborted_echo_area)
            {
              ea_last_executed_command = (VFunction *)NULL;
              done = 1;
            }

          if (info_last_executed_command == (VFunction *) info_quit)
            quit_info_immediately = 1;
        }
      else if (info_last_executed_command == (VFunction *) info_quit)
        done = 1;
    }
}

/* Found in signals.c */
extern void initialize_info_signal_handler (void );

/* Initialize the first info session by starting the terminal, window,
   and display systems.  If CLEAR_SCREEN is 0, don't clear the screen.  */
void
initialize_info_session (NODE *node, int clear_screen)
{
  char *term_name = getenv ("TERM");
  terminal_initialize_terminal (term_name);

  if (terminal_is_dumb_p)
    {
      if (!term_name)
        term_name = "dumb";

      info_error ((char *) msg_term_too_dumb, term_name, NULL);
      xexit (1);
    }

  if (clear_screen)
    {
      terminal_prep_terminal ();
      terminal_clear_screen ();
    }

  initialize_info_keymaps ();
  window_initialize_windows (screenwidth, screenheight);
  initialize_info_signal_handler ();
  display_initialize_display (screenwidth, screenheight);
  info_set_node_of_window (0, active_window, node);

  /* Tell the window system how to notify us when a window needs to be
     asynchronously deleted (e.g., user resizes window very small). */
  window_deletion_notifier = (VFunction *) forget_window_and_nodes;

  /* If input has not been redirected yet, make it come from unbuffered
     standard input. */
  if (!info_input_stream)
    {
      setbuf (stdin, NULL);
      info_input_stream = stdin;
    }

  info_windows_initialized_p = 1;
}

/* Tell Info that input is coming from the file FILENAME. */
void
info_set_input_from_file (char *filename)
{
  FILE *stream;

  /* Input may include binary characters.  */
  stream = fopen (filename, FOPEN_RBIN);

  if (!stream)
    return;

  if ((info_input_stream != (FILE *)NULL) &&
      (info_input_stream != stdin))
    fclose (info_input_stream);

  info_input_stream = stream;

  if (stream != stdin)
    display_inhibited = 1;
}

/* Return the INFO_WINDOW containing WINDOW, or NULL if there isn't one. */
static INFO_WINDOW *
get_info_window_of_window (WINDOW *window)
{
  register int i;
  INFO_WINDOW *info_win = (INFO_WINDOW *)NULL;

  for (i = 0; info_windows && (info_win = info_windows[i]); i++)
    if (info_win->window == window)
      break;

  return (info_win);
}

/* Reset the remembered pagetop and point of WINDOW to WINDOW's current
   values if the window and node are the same as the current one being
   displayed. */
void
set_remembered_pagetop_and_point (WINDOW *window)
{
  INFO_WINDOW *info_win;

  info_win = get_info_window_of_window (window);

  if (!info_win)
    return;

  if (info_win->nodes_index &&
      (info_win->nodes[info_win->current] == window->node))
    {
      info_win->pagetops[info_win->current] = window->pagetop;
      info_win->points[info_win->current] = window->point;
    }
}

void
remember_window_and_node (WINDOW *window, NODE *node)
{
  /* See if we already have this window in our list. */
  INFO_WINDOW *info_win = get_info_window_of_window (window);

  /* If the window wasn't already on our list, then make a new entry. */
  if (!info_win)
    {
      info_win = (INFO_WINDOW *)xmalloc (sizeof (INFO_WINDOW));
      info_win->window = window;
      info_win->nodes = (NODE **)NULL;
      info_win->pagetops = (int *)NULL;
      info_win->points = (long *)NULL;
      info_win->current = 0;
      info_win->nodes_index = 0;
      info_win->nodes_slots = 0;

      add_pointer_to_array (info_win, info_windows_index, info_windows,
                            info_windows_slots, 10, INFO_WINDOW *);
    }

  /* If this node, the current pagetop, and the current point are the
     same as the current saved node and pagetop, don't really add this to
     the list of history nodes.  This may happen only at the very
     beginning of the program, I'm not sure.  --karl  */
  if (info_win->nodes
      && info_win->current >= 0
      && info_win->nodes[info_win->current]->contents == node->contents
      && info_win->pagetops[info_win->current] == window->pagetop
      && info_win->points[info_win->current] == window->point)
  return;

  /* Remember this node, the currently displayed pagetop, and the current
     location of point in this window.  Because we are updating pagetops
     and points as well as nodes, it is more efficient to avoid the
     add_pointer_to_array macro here. */
  if (info_win->nodes_index + 2 >= info_win->nodes_slots)
    {
      info_win->nodes_slots += 20;
      info_win->nodes = (NODE **) xrealloc (info_win->nodes,
                                      info_win->nodes_slots * sizeof (NODE *));
      info_win->pagetops = (int *) xrealloc (info_win->pagetops,
                                      info_win->nodes_slots * sizeof (int));
      info_win->points = (long *) xrealloc (info_win->points,
                                      info_win->nodes_slots * sizeof (long));
    }

  info_win->nodes[info_win->nodes_index] = node;
  info_win->pagetops[info_win->nodes_index] = window->pagetop;
  info_win->points[info_win->nodes_index] = window->point;
  info_win->current = info_win->nodes_index++;
  info_win->nodes[info_win->nodes_index] = NULL;
  info_win->pagetops[info_win->nodes_index] = 0;
  info_win->points[info_win->nodes_index] = 0;
}

#define DEBUG_FORGET_WINDOW_AND_NODES
#if defined (DEBUG_FORGET_WINDOW_AND_NODES)
static void
consistency_check_info_windows (void)
{
  register int i;

  for (i = 0; i < info_windows_index; i++)
    {
      WINDOW *win;

      for (win = windows; win; win = win->next)
        if (win == info_windows[i]->window)
          break;

      if (!win)
        abort ();
    }
}
#endif /* DEBUG_FORGET_WINDOW_AND_NODES */

/* Remove WINDOW and its associated list of nodes from INFO_WINDOWS. */
void
forget_window_and_nodes (WINDOW *window)
{
  register int i;
  INFO_WINDOW *info_win = (INFO_WINDOW *)NULL;

  for (i = 0; info_windows && (info_win = info_windows[i]); i++)
    if (info_win->window == window)
      break;

  /* If we found the window to forget, then do so. */
  if (info_win)
    {
      while (i < info_windows_index)
        {
          info_windows[i] = info_windows[i + 1];
          i++;
        }

      info_windows_index--;
      info_windows[info_windows_index] = (INFO_WINDOW *)NULL;

      if (info_win->nodes)
        {
          /* Free the node structures which held onto internal node contents
             here.  This doesn't free the contents; we have a garbage collector
             which does that. */
          for (i = 0; info_win->nodes[i]; i++)
            if (internal_info_node_p (info_win->nodes[i]))
              free (info_win->nodes[i]);
          free (info_win->nodes);

          maybe_free (info_win->pagetops);
          maybe_free (info_win->points);
        }

      free (info_win);
    }
#if defined (DEBUG_FORGET_WINDOW_AND_NODES)
  consistency_check_info_windows ();
#endif /* DEBUG_FORGET_WINDOW_AND_NODES */
}

/* Set WINDOW to show NODE.  Remember the new window in our list of Info
   windows.  If we are doing automatic footnote display, also try to display
   the footnotes for this window.  If REMEMBER is nonzero, first call
   set_remembered_pagetop_and_point.  */
void
info_set_node_of_window (int remember, WINDOW *window, NODE *node)
{
  if (remember)
    set_remembered_pagetop_and_point (window);

  /* Put this node into the window. */
  window_set_node_of_window (window, node);

  /* Remember this node and window in our list of info windows. */
  remember_window_and_node (window, node);

  /* If doing auto-footnote display/undisplay, show the footnotes belonging
     to this window's node. */
  if (auto_footnotes_p)
    info_get_or_remove_footnotes (window);
}


/* **************************************************************** */
/*                                                                  */
/*                     Info Movement Commands                       */
/*                                                                  */
/* **************************************************************** */

/* Change the pagetop of WINDOW to DESIRED_TOP, perhaps scrolling the screen
   to do so. */
void
set_window_pagetop (WINDOW *window, int desired_top)
{
  int point_line, old_pagetop;

  if (desired_top < 0)
    desired_top = 0;
  else if (desired_top > window->line_count)
    desired_top = window->line_count - 1;

  if (window->pagetop == desired_top)
    return;

  old_pagetop = window->pagetop;
  window->pagetop = desired_top;

  /* Make sure that point appears in this window. */
  point_line = window_line_of_point (window);
  if ((point_line < window->pagetop) ||
      ((point_line - window->pagetop) > window->height - 1))
    window->point =
      window->line_starts[window->pagetop] - window->node->contents;

  window->flags |= W_UpdateWindow;

  /* Find out which direction to scroll, and scroll the window in that
     direction.  Do this only if there would be a savings in redisplay
     time.  This is true if the amount to scroll is less than the height
     of the window, and if the number of lines scrolled would be greater
     than 10 % of the window's height. */
  if (old_pagetop < desired_top)
    {
      int start, end, amount;

      amount = desired_top - old_pagetop;

      if ((amount >= window->height) ||
          (((window->height - amount) * 10) < window->height))
        return;

      start = amount + window->first_row;
      end = window->height + window->first_row;

      display_scroll_display (start, end, -amount);
    }
  else
    {
      int start, end, amount;

      amount = old_pagetop - desired_top;

      if ((amount >= window->height) ||
          (((window->height - amount) * 10) < window->height))
        return;

      start = window->first_row;
      end = (window->first_row + window->height) - amount;
      display_scroll_display (start, end, amount);
    }
}

/* Immediately make WINDOW->point visible on the screen, and move the
   terminal cursor there. */
static void
info_show_point (WINDOW *window)
{
  int old_pagetop;

  old_pagetop = window->pagetop;
  window_adjust_pagetop (window);
  if (old_pagetop != window->pagetop)
    {
      int new_pagetop;

      new_pagetop = window->pagetop;
      window->pagetop = old_pagetop;
      set_window_pagetop (window, new_pagetop);
    }

  if (window->flags & W_UpdateWindow)
    display_update_one_window (window);

  display_cursor_at_point (window);
}

/* Move WINDOW->point from OLD line index to NEW line index. */
static void
move_to_new_line (int old, int new, WINDOW *window)
{
  if (old == -1)
    {
      info_error ((char *) msg_cant_find_point, NULL, NULL);
    }
  else
    {
      int goal;

      if (new >= window->line_count || new < 0)
        return;

      goal = window_get_goal_column (window);
      window->goal_column = goal;

      window->point = window->line_starts[new] - window->node->contents;
      window->point += window_chars_to_goal (window->line_starts[new], goal);
      info_show_point (window);
    }
}

/* Move WINDOW's point down to the next line if possible. */
DECLARE_INFO_COMMAND (info_next_line, _("Move down to the next line"))
{
  int old_line, new_line;

  if (count < 0)
    info_prev_line (window, -count, key);
  else
    {
      old_line = window_line_of_point (window);
      new_line = old_line + count;
      move_to_new_line (old_line, new_line, window);
    }
}

/* Move WINDOW's point up to the previous line if possible. */
DECLARE_INFO_COMMAND (info_prev_line, _("Move up to the previous line"))
{
  int old_line, new_line;

  if (count < 0)
    info_next_line (window, -count, key);
  else
    {
      old_line = window_line_of_point (window);
      new_line = old_line - count;
      move_to_new_line (old_line, new_line, window);
    }
}

/* Move WINDOW's point to the end of the true line. */
DECLARE_INFO_COMMAND (info_end_of_line, _("Move to the end of the line"))
{
  register int point, len;
  register char *buffer;

  buffer = window->node->contents;
  len = window->node->nodelen;

  for (point = window->point;
       (point < len) && (buffer[point] != '\n');
       point++);

  if (point != window->point)
    {
      window->point = point;
      info_show_point (window);
    }
}

/* Move WINDOW's point to the beginning of the true line. */
DECLARE_INFO_COMMAND (info_beginning_of_line, _("Move to the start of the line"))
{
  register int point;
  register char *buffer;

  buffer = window->node->contents;
  point = window->point;

  for (; (point) && (buffer[point - 1] != '\n'); point--);

  /* If at a line start already, do nothing. */
  if (point != window->point)
    {
      window->point = point;
      info_show_point (window);
    }
}

/* Move point forward in the node. */
DECLARE_INFO_COMMAND (info_forward_char, _("Move forward a character"))
{
  if (count < 0)
    info_backward_char (window, -count, key);
  else
    {
      window->point += count;

      if (window->point >= window->node->nodelen)
        window->point = window->node->nodelen - 1;

      info_show_point (window);
    }
}

/* Move point backward in the node. */
DECLARE_INFO_COMMAND (info_backward_char, _("Move backward a character"))
{
  if (count < 0)
    info_forward_char (window, -count, key);
  else
    {
      window->point -= count;

      if (window->point < 0)
        window->point = 0;

      info_show_point (window);
    }
}

#define alphabetic(c) (islower (c) || isupper (c) || isdigit (c))

/* Move forward a word in this node. */
DECLARE_INFO_COMMAND (info_forward_word, _("Move forward a word"))
{
  long point;
  char *buffer;
  int end, c;

  if (count < 0)
    {
      info_backward_word (window, -count, key);
      return;
    }

  point = window->point;
  buffer = window->node->contents;
  end = window->node->nodelen;

  while (count)
    {
      if (point + 1 >= end)
        return;

      /* If we are not in a word, move forward until we are in one.
         Then, move forward until we hit a non-alphabetic character. */
      c = buffer[point];

      if (!alphabetic (c))
        {
          while (++point < end)
            {
              c = buffer[point];
              if (alphabetic (c))
                break;
            }
        }

      if (point >= end) return;

      while (++point < end)
        {
          c = buffer[point];
          if (!alphabetic (c))
            break;
        }
      --count;
    }
  window->point = point;
  info_show_point (window);
}

DECLARE_INFO_COMMAND (info_backward_word, _("Move backward a word"))
{
  long point;
  char *buffer;
  int c;

  if (count < 0)
    {
      info_forward_word (window, -count, key);
      return;
    }

  buffer = window->node->contents;
  point = window->point;

  while (count)
    {
      if (point == 0)
        break;

      /* Like info_forward_word (), except that we look at the
         characters just before point. */

      c = buffer[point - 1];

      if (!alphabetic (c))
        {
          while (--point)
            {
              c = buffer[point - 1];
              if (alphabetic (c))
                break;
            }
        }

      while (point)
        {
          c = buffer[point - 1];
          if (!alphabetic (c))
            break;
          else
            --point;
        }
      --count;
    }
  window->point = point;
  info_show_point (window);
}

/* Variable controlling the behaviour of default scrolling when you are
   already at the bottom of a node.  Possible values are defined in session.h.
   The meanings are:

   IS_Continuous        Try to get first menu item, or failing that, the
                        "Next:" pointer, or failing that, the "Up:" and
                        "Next:" of the up.
   IS_NextOnly          Try to get "Next:" menu item.
   IS_PageOnly          Simply give up at the bottom of a node. */

int info_scroll_behaviour = IS_Continuous;

/* Choices used by the completer when reading a value for the user-visible
   variable "scroll-behaviour". */
char *info_scroll_choices[] = {
  "Continuous", "Next Only", "Page Only", (char *)NULL
};

/* Default window sizes for scrolling commands.  */
int default_window_size = -1;	/* meaning 1 window-full */
int default_scroll_size = -1;	/* meaning half screen size */

#define INFO_LABEL_FOUND() \
  (info_parsed_nodename || (info_parsed_filename \
                            && !is_dir_name (info_parsed_filename)))

/* Move to 1st menu item, Next, Up/Next, or error in this window. */
static void
forward_move_node_structure (WINDOW *window, int behaviour)
{
  switch (behaviour)
    {
    case IS_PageOnly:
      info_error ((char *) msg_at_node_bottom, NULL, NULL);
      break;

    case IS_NextOnly:
      info_next_label_of_node (window->node);
      if (!info_parsed_nodename && !info_parsed_filename)
        info_error ((char *) msg_no_pointer, (char *) _("Next"), NULL);
      else
        {
          window_message_in_echo_area ((char *) _("Following Next node..."),
              NULL, NULL);
          info_handle_pointer ("Next", window);
        }
      break;

    case IS_Continuous:
      {
        /* First things first.  If this node contains a menu, move down
           into the menu. */
        {
          REFERENCE **menu;

          menu = info_menu_of_node (window->node);

          if (menu)
            {
              info_free_references (menu);
              window_message_in_echo_area ((char *) _("Selecting first menu item..."),
                  NULL, NULL);
              info_menu_digit (window, 1, '1');
              return;
            }
        }

        /* Okay, this node does not contain a menu.  If it contains a
           "Next:" pointer, use that. */
        info_next_label_of_node (window->node);
        if (INFO_LABEL_FOUND ())
          {
            window_message_in_echo_area ((char *) _("Selecting Next node..."),
                NULL, NULL);
            info_handle_pointer ("Next", window);
            return;
          }

        /* Okay, there wasn't a "Next:" for this node.  Move "Up:" until we
           can move "Next:".  If that isn't possible, complain that there
           are no more nodes. */
        {
          int up_counter, old_current;
          INFO_WINDOW *info_win;

          /* Remember the current node and location. */
          info_win = get_info_window_of_window (window);
          old_current = info_win->current;

          /* Back up through the "Up:" pointers until we have found a "Next:"
             that isn't the same as the first menu item found in that node. */
          up_counter = 0;
          while (!info_error_was_printed)
            {
              info_up_label_of_node (window->node);
              if (INFO_LABEL_FOUND ())
                {
                  info_handle_pointer ("Up", window);
                  if (info_error_was_printed)
                    continue;

                  up_counter++;

                  info_next_label_of_node (window->node);

                  /* If no "Next" pointer, keep backing up. */
                  if (!INFO_LABEL_FOUND ())
                    continue;

                  /* If this node's first menu item is the same as this node's
                     Next pointer, keep backing up. */
                  if (!info_parsed_filename)
                    {
                      REFERENCE **menu;
                      char *next_nodename;

                      /* Remember the name of the Next node, since reading
                         the menu can overwrite the contents of the
                         info_parsed_xxx strings. */
                      next_nodename = xstrdup (info_parsed_nodename);

                      menu = info_menu_of_node (window->node);
                      if (menu &&
                          (strcmp
                           (menu[0]->nodename, next_nodename) == 0))
                        {
                          info_free_references (menu);
                          free (next_nodename);
                          continue;
                        }
                      else
                        {
                          /* Restore the world to where it was before
                             reading the menu contents. */
                          info_free_references (menu);
                          free (next_nodename);
                          info_next_label_of_node (window->node);
                        }
                    }

                  /* This node has a "Next" pointer, and it is not the
                     same as the first menu item found in this node. */
                  window_message_in_echo_area
                    ((char *) _("Moving Up %d time(s), then Next."),
                     (void *) (long) up_counter, NULL);

                  info_handle_pointer ("Next", window);
                  return;
                }
              else
                {
                  /* No more "Up" pointers.  Print an error, and call it
                     quits. */
                  register int i;

                  for (i = 0; i < up_counter; i++)
                    {
                      info_win->nodes_index--;
                      free (info_win->nodes[info_win->nodes_index]);
                      info_win->nodes[info_win->nodes_index] = (NODE *)NULL;
                    }
                  info_win->current = old_current;
                  window->node = info_win->nodes[old_current];
                  window->pagetop = info_win->pagetops[old_current];
                  window->point = info_win->points[old_current];
                  recalculate_line_starts (window);
                  window->flags |= W_UpdateWindow;
                  info_error ((char *) _("No more nodes within this document."),
                      NULL, NULL);
                }
            }
        }
        break;
      }
    }
}

/* Move Prev, Up or error in WINDOW depending on BEHAVIOUR. */
static void
backward_move_node_structure (WINDOW *window, int behaviour)
{
  switch (behaviour)
    {
    case IS_PageOnly:
      info_error ((char *) msg_at_node_top, NULL, NULL);
      break;

    case IS_NextOnly:
      info_prev_label_of_node (window->node);
      if (!info_parsed_nodename && !info_parsed_filename)
        info_error ((char *) _("No `Prev' for this node."), NULL, NULL);
      else
        {
          window_message_in_echo_area ((char *) _("Moving Prev in this window."),
              NULL, NULL);
          info_handle_pointer ("Prev", window);
        }
      break;

    case IS_Continuous:
      info_prev_label_of_node (window->node);

      if (!info_parsed_nodename && (!info_parsed_filename
                                    || is_dir_name (info_parsed_filename)))
        {
          info_up_label_of_node (window->node);
          if (!info_parsed_nodename && (!info_parsed_filename
                                        || is_dir_name (info_parsed_filename)))
            info_error ((char *)
                _("No `Prev' or `Up' for this node within this document."),
                NULL, NULL);
          else
            {
              window_message_in_echo_area ((char *) _("Moving Up in this window."),
                  NULL, NULL);
              info_handle_pointer ("Up", window);
            }
        }
      else
        {
          REFERENCE **menu;
          int inhibit_menu_traversing = 0;

          /* Watch out!  If this node's Prev is the same as the Up, then
             move Up.  Otherwise, we could move Prev, and then to the last
             menu item in the Prev.  This would cause the user to loop
             through a subsection of the info file. */
          if (!info_parsed_filename && info_parsed_nodename)
            {
              char *pnode;

              pnode = xstrdup (info_parsed_nodename);
              info_up_label_of_node (window->node);

              if (!info_parsed_filename && info_parsed_nodename &&
                  strcmp (info_parsed_nodename, pnode) == 0)
                {
                  /* The nodes are the same.  Inhibit moving to the last
                     menu item. */
                  free (pnode);
                  inhibit_menu_traversing = 1;
                }
              else
                {
                  free (pnode);
                  info_prev_label_of_node (window->node);
                }
            }

          /* Move to the previous node.  If this node now contains a menu,
             and we have not inhibited movement to it, move to the node
             corresponding to the last menu item. */
          window_message_in_echo_area ((char *) _("Moving Prev in this window."),
              NULL, NULL);
          info_handle_pointer ("Prev", window);

          if (!inhibit_menu_traversing)
            {
              while (!info_error_was_printed &&
                     (menu = info_menu_of_node (window->node)))
                {
                  info_free_references (menu);
                  window_message_in_echo_area
                    ((char *) _("Moving to `Prev's last menu item."), NULL, NULL);
                  info_menu_digit (window, 1, '0');
                }
            }
        }
      break;
    }
}

/* Move continuously forward through the node structure of this info file. */
DECLARE_INFO_COMMAND (info_global_next_node,
                      _("Move forwards or down through node structure"))
{
  if (count < 0)
    info_global_prev_node (window, -count, key);
  else
    {
      while (count && !info_error_was_printed)
        {
          forward_move_node_structure (window, IS_Continuous);
          count--;
        }
    }
}

/* Move continuously backward through the node structure of this info file. */
DECLARE_INFO_COMMAND (info_global_prev_node,
                      _("Move backwards or up through node structure"))
{
  if (count < 0)
    info_global_next_node (window, -count, key);
  else
    {
      while (count && !info_error_was_printed)
        {
          backward_move_node_structure (window, IS_Continuous);
          count--;
        }
    }
}

static void _scroll_forward(WINDOW *window, int count,
    unsigned char key, int behaviour);
static void _scroll_backward(WINDOW *window, int count,
    unsigned char key, int behaviour);

static void
_scroll_forward(WINDOW *window, int count, unsigned char key, int behaviour)
{
  if (count < 0)
    _scroll_backward (window, -count, key, behaviour);
  else
    {
      int desired_top;

      /* Without an explicit numeric argument, scroll the bottom two
         lines to the top of this window,  Or, if at bottom of window,
         and the chosen behaviour is to scroll through nodes get the
	 "Next" node for this window. */
      if (default_window_size > 0)
        desired_top = window->pagetop + default_window_size;
      else if (!info_explicit_arg && count == 1)
        {
          desired_top = window->pagetop + (window->height - 2);

          /* If there are no more lines to scroll here, error, or get
             another node, depending on BEHAVIOUR. */
          if (desired_top > window->line_count)
            {
              forward_move_node_structure (window, behaviour);
              return;
            }
        }
      else
        desired_top = window->pagetop + count;

      if (desired_top >= window->line_count)
        desired_top = window->line_count - 2;

      if (window->pagetop > desired_top)
        return;
      else
        set_window_pagetop (window, desired_top);
    }
}

static void
_scroll_backward(WINDOW *window, int count, unsigned char key, int behaviour)
{
  if (count < 0)
    _scroll_forward (window, -count, key, behaviour);
  else
    {
      int desired_top;

      /* Without an explicit numeric argument, scroll the top two lines
         to the bottom of this window, or, depending on the selected
	 behaviour, move to the previous, or Up'th node. */
      if (default_window_size > 0)
        desired_top = window->pagetop - default_window_size;
      else if (!info_explicit_arg && count == 1)
        {
          desired_top = window->pagetop - (window->height - 2);

          if ((desired_top < 0) && (window->pagetop == 0))
            {
              backward_move_node_structure (window, behaviour);
              return;
            }
        }
      else
        desired_top = window->pagetop - count;

      if (desired_top < 0)
        desired_top = 0;

      set_window_pagetop (window, desired_top);
    }
}

/* Show the next screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_forward, _("Scroll forward in this window"))
{
  _scroll_forward (window, count, key, info_scroll_behaviour);
}

/* Like info_scroll_forward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_set_window,
		      _("Scroll forward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_forward (window, count, key, info_scroll_behaviour);
}

/* Show the next screen of WINDOW's node but never advance to next node. */
DECLARE_INFO_COMMAND (info_scroll_forward_page_only, _("Scroll forward in this window staying within node"))
{
  _scroll_forward (window, count, key, IS_PageOnly);
}

/* Like info_scroll_forward_page_only, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_page_only_set_window,
		      _("Scroll forward in this window staying within node and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_forward (window, count, key, IS_PageOnly);
}

/* Show the previous screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_backward, _("Scroll backward in this window"))
{
  _scroll_backward (window, count, key, info_scroll_behaviour);
}

/* Like info_scroll_backward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_backward_set_window,
		      _("Scroll backward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_backward (window, count, key, info_scroll_behaviour);
}

/* Show the previous screen of WINDOW's node but never move to previous
   node. */
DECLARE_INFO_COMMAND (info_scroll_backward_page_only, _("Scroll backward in this window staying within node"))
{
  _scroll_backward (window, count, key, IS_PageOnly);
}

/* Like info_scroll_backward_page_only, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_backward_page_only_set_window,
		      _("Scroll backward in this window staying within node and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_backward (window, count, key, IS_PageOnly);
}

/* Move to the beginning of the node. */
DECLARE_INFO_COMMAND (info_beginning_of_node, _("Move to the start of this node"))
{
  window->pagetop = window->point = 0;
  window->flags |= W_UpdateWindow;
}

/* Move to the end of the node. */
DECLARE_INFO_COMMAND (info_end_of_node, _("Move to the end of this node"))
{
  window->point = window->node->nodelen - 1;
  info_show_point (window);
}

/* Scroll the window forward by N lines.  */
DECLARE_INFO_COMMAND (info_down_line, _("Scroll down by lines"))
{
  if (count < 0)
    info_up_line (window, -count, key);
  else
    {
      int desired_top = window->pagetop + count;

      if (desired_top >= window->line_count)
	desired_top = window->line_count - 2;

      if (window->pagetop <= desired_top)
	set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window backward by N lines.  */
DECLARE_INFO_COMMAND (info_up_line, _("Scroll up by lines"))
{
  if (count < 0)
    info_down_line (window, -count, key);
  else
    {
      int desired_top = window->pagetop - count;

      if (desired_top < 0)
	desired_top = 0;

      set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window forward by N lines and remember N as default for
   subsequent commands.  */
DECLARE_INFO_COMMAND (info_scroll_half_screen_down,
		      _("Scroll down by half screen size"))
{
  if (count < 0)
    info_scroll_half_screen_up (window, -count, key);
  else
    {
      int scroll_size = (the_screen->height + 1) / 2;
      int desired_top;

      if (info_explicit_arg)
	default_scroll_size = count;
      if (default_scroll_size > 0)
	scroll_size = default_scroll_size;

      desired_top = window->pagetop + scroll_size;
      if (desired_top >= window->line_count)
	desired_top = window->line_count - 2;

      if (window->pagetop <= desired_top)
	set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window backward by N lines and remember N as default for
   subsequent commands.  */
DECLARE_INFO_COMMAND (info_scroll_half_screen_up,
		      _("Scroll up by half screen size"))
{
  if (count < 0)
    info_scroll_half_screen_down (window, -count, key);
  else
    {
      int scroll_size = (the_screen->height + 1) / 2;
      int desired_top;

      if (info_explicit_arg)
	default_scroll_size = count;
      if (default_scroll_size > 0)
	scroll_size = default_scroll_size;

      desired_top = window->pagetop - scroll_size;
      if (desired_top < 0)
	desired_top = 0;

      set_window_pagetop (window, desired_top);
    }
}

/* **************************************************************** */
/*                                                                  */
/*                 Commands for Manipulating Windows                */
/*                                                                  */
/* **************************************************************** */

/* Make the next window in the chain be the active window. */
DECLARE_INFO_COMMAND (info_next_window, _("Select the next window"))
{
  if (count < 0)
    {
      info_prev_window (window, -count, key);
      return;
    }

  /* If no other window, error now. */
  if (!windows->next && !echo_area_is_active)
    {
      info_error ((char *) msg_one_window, NULL, NULL);
      return;
    }

  while (count--)
    {
      if (window->next)
        window = window->next;
      else
        {
          if (window == the_echo_area || !echo_area_is_active)
            window = windows;
          else
            window = the_echo_area;
        }
    }

  if (active_window != window)
    {
      if (auto_footnotes_p)
        info_get_or_remove_footnotes (window);

      window->flags |= W_UpdateWindow;
      active_window = window;
    }
}

/* Make the previous window in the chain be the active window. */
DECLARE_INFO_COMMAND (info_prev_window, _("Select the previous window"))
{
  if (count < 0)
    {
      info_next_window (window, -count, key);
      return;
    }

  /* Only one window? */

  if (!windows->next && !echo_area_is_active)
    {
      info_error ((char *) msg_one_window, NULL, NULL);
      return;
    }

  while (count--)
    {
      /* If we are in the echo area, or if the echo area isn't active and we
         are in the first window, find the last window in the chain. */
      if (window == the_echo_area ||
          (window == windows && !echo_area_is_active))
        {
          register WINDOW *win, *last = NULL;

          for (win = windows; win; win = win->next)
            last = win;

          window = last;
        }
      else
        {
          if (window == windows)
            window = the_echo_area;
          else
            window = window->prev;
        }
    }

  if (active_window != window)
    {
      if (auto_footnotes_p)
        info_get_or_remove_footnotes (window);

      window->flags |= W_UpdateWindow;
      active_window = window;
    }
}

/* Split WINDOW into two windows, both showing the same node.  If we
   are automatically tiling windows, re-tile after the split. */
DECLARE_INFO_COMMAND (info_split_window, _("Split the current window"))
{
  WINDOW *split, *old_active;
  int pagetop;

  /* Remember the current pagetop of the window being split.  If it doesn't
     change, we can scroll its contents around after the split. */
  pagetop = window->pagetop;

  /* Make the new window. */
  old_active = active_window;
  active_window = window;
  split = window_make_window (window->node);
  active_window = old_active;

  if (!split)
    {
      info_error ((char *) msg_win_too_small, NULL, NULL);
    }
  else
    {
#if defined (SPLIT_BEFORE_ACTIVE)
      /* Try to scroll the old window into its new postion. */
      if (pagetop == window->pagetop)
        {
          int start, end, amount;

          start = split->first_row;
          end = start + window->height;
          amount = split->height + 1;
          display_scroll_display (start, end, amount);
        }
#else /* !SPLIT_BEFORE_ACTIVE */
      /* Make sure point still appears in the active window. */
      info_show_point (window);
#endif /* !SPLIT_BEFORE_ACTIVE */

      /* If the window just split was one internal to Info, try to display
         something else in it. */
      if (internal_info_node_p (split->node))
        {
          register int i, j;
          INFO_WINDOW *iw;
          NODE *node = (NODE *)NULL;
          char *filename;

          for (i = 0; (iw = info_windows[i]); i++)
            {
              for (j = 0; j < iw->nodes_index; j++)
                if (!internal_info_node_p (iw->nodes[j]))
                  {
                    if (iw->nodes[j]->parent)
                      filename = iw->nodes[j]->parent;
                    else
                      filename = iw->nodes[j]->filename;

                    node = info_get_node (filename, iw->nodes[j]->nodename);
                    if (node)
                      {
                        window_set_node_of_window (split, node);
                        i = info_windows_index - 1;
                        break;
                      }
                  }
            }
        }
      split->pagetop = window->pagetop;

      if (auto_tiling_p)
        window_tile_windows (DONT_TILE_INTERNALS);
      else
        window_adjust_pagetop (split);

      remember_window_and_node (split, split->node);
    }
}

/* Delete WINDOW, forgetting the list of last visited nodes.  If we are
   automatically displaying footnotes, show or remove the footnotes
   window.  If we are automatically tiling windows, re-tile after the
   deletion. */
DECLARE_INFO_COMMAND (info_delete_window, _("Delete the current window"))
{
  if (!windows->next)
    {
      info_error ((char *) msg_cant_kill_last, NULL, NULL);
    }
  else if (window->flags & W_WindowIsPerm)
    {
      info_error ((char *) _("Cannot delete a permanent window"), NULL, NULL);
    }
  else
    {
      info_delete_window_internal (window);

      if (auto_footnotes_p)
        info_get_or_remove_footnotes (active_window);

      if (auto_tiling_p)
        window_tile_windows (DONT_TILE_INTERNALS);
    }
}

/* Do the physical deletion of WINDOW, and forget this window and
   associated nodes. */
void
info_delete_window_internal (WINDOW *window)
{
  if (windows->next && ((window->flags & W_WindowIsPerm) == 0))
    {
      /* We not only delete the window from the display, we forget it from
         our list of remembered windows. */
      forget_window_and_nodes (window);
      window_delete_window (window);

      if (echo_area_is_active)
        echo_area_inform_of_deleted_window (window);
    }
}

/* Just keep WINDOW, deleting all others. */
DECLARE_INFO_COMMAND (info_keep_one_window, _("Delete all other windows"))
{
  int num_deleted;              /* The number of windows we deleted. */
  int pagetop, start, end;

  /* Remember a few things about this window.  We may be able to speed up
     redisplay later by scrolling its contents. */
  pagetop = window->pagetop;
  start = window->first_row;
  end = start + window->height;

  num_deleted = 0;

  while (1)
    {
      WINDOW *win;

      /* Find an eligible window and delete it.  If no eligible windows
         are found, we are done.  A window is eligible for deletion if
         is it not permanent, and it is not WINDOW. */
      for (win = windows; win; win = win->next)
        if (win != window && ((win->flags & W_WindowIsPerm) == 0))
          break;

      if (!win)
        break;

      info_delete_window_internal (win);
      num_deleted++;
    }

  /* Scroll the contents of this window into the right place so that the
     user doesn't have to wait any longer than necessary for redisplay. */
  if (num_deleted)
    {
      int amount;

      amount = (window->first_row - start);
      amount -= (window->pagetop - pagetop);
      display_scroll_display (start, end, amount);
    }

  window->flags |= W_UpdateWindow;
}

/* Scroll the "other" window of WINDOW. */
DECLARE_INFO_COMMAND (info_scroll_other_window, _("Scroll the other window"))
{
  WINDOW *other;

  /* If only one window, give up. */
  if (!windows->next)
    {
      info_error ((char *) msg_one_window, NULL, NULL);
      return;
    }

  other = window->next;

  if (!other)
    other = window->prev;

  info_scroll_forward (other, count, key);
}

/* Scroll the "other" window of WINDOW. */
DECLARE_INFO_COMMAND (info_scroll_other_window_backward,
                      _("Scroll the other window backward"))
{
  info_scroll_other_window (window, -count, key);
}

/* Change the size of WINDOW by AMOUNT. */
DECLARE_INFO_COMMAND (info_grow_window, _("Grow (or shrink) this window"))
{
  window_change_window_height (window, count);
}

/* When non-zero, tiling takes place automatically when info_split_window
   is called. */
int auto_tiling_p = 0;

/* Tile all of the visible windows. */
DECLARE_INFO_COMMAND (info_tile_windows,
    _("Divide the available screen space among the visible windows"))
{
  window_tile_windows (TILE_INTERNALS);
}

/* Toggle the state of this window's wrapping of lines. */
DECLARE_INFO_COMMAND (info_toggle_wrap,
              _("Toggle the state of line wrapping in the current window"))
{
  window_toggle_wrap (window);
}

/* **************************************************************** */
/*                                                                  */
/*                      Info Node Commands                          */
/*                                                                  */
/* **************************************************************** */

/* Return (FILENAME)NODENAME for NODE, or just NODENAME if NODE's
   filename is not set. */
char *
node_printed_rep (NODE *node)
{
  char *rep;

  if (node->filename)
    {
      char *filename
       = filename_non_directory (node->parent ? node->parent : node->filename);
      rep = xmalloc (1 + strlen (filename) + 1 + strlen (node->nodename) + 1);
      sprintf (rep, "(%s)%s", filename, node->nodename);
    }
  else
    rep = node->nodename;

  return rep;
}


/* Using WINDOW for various defaults, select the node referenced by ENTRY
   in it.  If the node is selected, the window and node are remembered. */
void
info_select_reference (WINDOW *window, REFERENCE *entry)
{
  NODE *node;
  char *filename, *nodename, *file_system_error;

  file_system_error = (char *)NULL;

  filename = entry->filename;
  if (!filename)
    filename = window->node->parent;
  if (!filename)
    filename = window->node->filename;

  if (filename)
    filename = xstrdup (filename);

  if (entry->nodename)
    nodename = xstrdup (entry->nodename);
  else
    nodename = xstrdup ("Top");

  node = info_get_node (filename, nodename);

  /* Try something a little weird.  If the node couldn't be found, and the
     reference was of the form "foo::", see if the entry->label can be found
     as a file, with a node of "Top". */
  if (!node)
    {
      if (info_recent_file_error)
        file_system_error = xstrdup (info_recent_file_error);

      if (entry->nodename && (strcmp (entry->nodename, entry->label) == 0))
        {
          node = info_get_node (entry->label, "Top");
          if (!node && info_recent_file_error)
            {
              maybe_free (file_system_error);
              file_system_error = xstrdup (info_recent_file_error);
            }
        }
    }

  if (!node)
    {
      if (file_system_error)
        info_error (file_system_error, NULL, NULL);
      else
        info_error ((char *) msg_cant_find_node, nodename, NULL);
    }

  maybe_free (file_system_error);
  maybe_free (filename);
  maybe_free (nodename);

  if (node)
    info_set_node_of_window (1, window, node);
}

/* Parse the node specification in LINE using WINDOW to default the filename.
   Select the parsed node in WINDOW and remember it, or error if the node
   couldn't be found. */
static void
info_parse_and_select (char *line, WINDOW *window)
{
  REFERENCE entry;

  info_parse_node (line, DONT_SKIP_NEWLINES);

  entry.nodename = info_parsed_nodename;
  entry.filename = info_parsed_filename;
  entry.label = "*info-parse-and-select*";

  info_select_reference (window, &entry);
}

/* Given that the values of INFO_PARSED_FILENAME and INFO_PARSED_NODENAME
   are previously filled, try to get the node represented by them into
   WINDOW.  The node should have been pointed to by the LABEL pointer of
   WINDOW->node. */
static void
info_handle_pointer (char *label, WINDOW *window)
{
  if (info_parsed_filename || info_parsed_nodename)
    {
      char *filename, *nodename;
      NODE *node;

      filename = nodename = (char *)NULL;

      if (info_parsed_filename)
        filename = xstrdup (info_parsed_filename);
      else
        {
          if (window->node->parent)
            filename = xstrdup (window->node->parent);
          else if (window->node->filename)
            filename = xstrdup (window->node->filename);
        }

      if (info_parsed_nodename)
        nodename = xstrdup (info_parsed_nodename);
      else
        nodename = xstrdup ("Top");

      node = info_get_node (filename, nodename);

      if (node)
        {
          INFO_WINDOW *info_win;

          info_win = get_info_window_of_window (window);
          if (info_win)
            {
              info_win->pagetops[info_win->current] = window->pagetop;
              info_win->points[info_win->current] = window->point;
            }
          info_set_node_of_window (1, window, node);
        }
      else
        {
          if (info_recent_file_error)
            info_error (info_recent_file_error, NULL, NULL);
          else
            info_error ((char *) msg_cant_file_node, filename, nodename);
        }

      free (filename);
      free (nodename);
    }
  else
    {
      info_error ((char *) msg_no_pointer, label, NULL);
    }
}

/* Make WINDOW display the "Next:" node of the node currently being
   displayed. */
DECLARE_INFO_COMMAND (info_next_node, _("Select the Next node"))
{
  info_next_label_of_node (window->node);
  info_handle_pointer ("Next", window);
}

/* Make WINDOW display the "Prev:" node of the node currently being
   displayed. */
DECLARE_INFO_COMMAND (info_prev_node, _("Select the Prev node"))
{
  info_prev_label_of_node (window->node);
  info_handle_pointer ("Prev", window);
}

/* Make WINDOW display the "Up:" node of the node currently being
   displayed. */
DECLARE_INFO_COMMAND (info_up_node, _("Select the Up node"))
{
  info_up_label_of_node (window->node);
  info_handle_pointer ("Up", window);
}

/* Make WINDOW display the last node of this info file. */
DECLARE_INFO_COMMAND (info_last_node, _("Select the last node in this file"))
{
  register int i;
  FILE_BUFFER *fb = file_buffer_of_window (window);
  NODE *node = (NODE *)NULL;

  if (fb && fb->tags)
    {
      int last_node_tag_idx = -1;

      /* If no explicit argument, or argument of zero, default to the
         last node.  */
      if (count == 0 || (count == 1 && !info_explicit_arg))
        count = -1;
      for (i = 0; count && fb->tags[i]; i++)
        if (fb->tags[i]->nodelen != 0) /* don't count anchor tags */
          {
            count--;
            last_node_tag_idx = i;
          }
      if (count > 0)
        i = last_node_tag_idx + 1;
      if (i > 0)
        node = info_get_node (fb->filename, fb->tags[i - 1]->nodename);
    }

  if (!node)
    info_error ((char *) _("This window has no additional nodes"), NULL, NULL);
  else
    info_set_node_of_window (1, window, node);
}

/* Make WINDOW display the first node of this info file. */
DECLARE_INFO_COMMAND (info_first_node, _("Select the first node in this file"))
{
  FILE_BUFFER *fb = file_buffer_of_window (window);
  NODE *node = (NODE *)NULL;

  /* If no explicit argument, or argument of zero, default to the
     first node.  */
  if (count == 0)
    count = 1;
  if (fb && fb->tags)
    {
      register int i;
      int last_node_tag_idx = -1;

      for (i = 0; count && fb->tags[i]; i++)
        if (fb->tags[i]->nodelen != 0) /* don't count anchor tags */
          {
            count--;
            last_node_tag_idx = i;
          }
      if (count > 0)
        i = last_node_tag_idx + 1;
      if (i > 0)
        node = info_get_node (fb->filename, fb->tags[i - 1]->nodename);
    }

  if (!node)
    info_error ((char *) _("This window has no additional nodes"), NULL, NULL);
  else
    info_set_node_of_window (1, window, node);
}

/* Select the last menu item in WINDOW->node. */
DECLARE_INFO_COMMAND (info_last_menu_item,
   _("Select the last item in this node's menu"))
{
  info_menu_digit (window, 1, '0');
}

/* Use KEY (a digit) to select the Nth menu item in WINDOW->node. */
DECLARE_INFO_COMMAND (info_menu_digit, _("Select this menu item"))
{
  register int i, item;
  register REFERENCE **menu;

  menu = info_menu_of_node (window->node);

  if (!menu)
    {
      info_error ((char *) msg_no_menu_node, NULL, NULL);
      return;
    }

  /* We have the menu.  See if there are this many items in it. */
  item = key - '0';

  /* Special case.  Item "0" is the last item in this menu. */
  if (item == 0)
    for (i = 0; menu[i + 1]; i++);
  else
    {
      for (i = 0; menu[i]; i++)
        if (i == item - 1)
          break;
    }

  if (menu[i])
    {
      info_select_reference (window, menu[i]);
      if (menu[i]->line_number > 0)
        info_next_line (window, menu[i]->line_number - 1, key);
    }
  else
    info_error ((char *) _("There aren't %d items in this menu."),
                (void *) (long) item, NULL);

  info_free_references (menu);
  return;
}



/* Return a pointer to the xref in XREF_LIST that is nearest to POS, or
   NULL if XREF_LIST is empty.  That is, if POS is within any of the
   given xrefs, return that one.  Otherwise, return the one with the
   nearest beginning or end.  If there are two that are equidistant,
   prefer the one forward.  The return is in newly-allocated memory,
   since the caller frees it.
   
   This is called from info_menu_or_ref_item with XREF_LIST being all
   the xrefs in the node, and POS being point.  The ui function that
   starts it all off is select-reference-this-line.

   This is not the same logic as in info.el.  Info-get-token prefers
   searching backwards to searching forwards, and has a hardwired search
   limit of 200 chars (in Emacs 21.2).  */

static REFERENCE **
nearest_xref (REFERENCE **xref_list, long int pos)
{
  int this_xref;
  int nearest = -1;
  long best_delta = -1;
  
  for (this_xref = 0; xref_list[this_xref]; this_xref++)
    {
      long delta;
      REFERENCE *xref = xref_list[this_xref];
      if (xref->start <= pos && pos <= xref->end)
        { /* POS is within this xref, we're done */
          nearest = this_xref;
          break;
        }
      
      /* See how far POS is from this xref.  Take into account the
         `*Note' that begins the xref, since as far as the user is
         concerned, that's where it starts.  */
      delta = MIN (labs (pos - (xref->start - strlen (INFO_XREF_LABEL))),
                   labs (pos - xref->end));
      
      /* It's the <= instead of < that makes us choose the forward xref
         of POS if two are equidistant.  Of course, because of all the
         punctuation surrounding xrefs, it's not necessarily obvious
         where one ends.  */
      if (delta <= best_delta || best_delta < 0)
        {
          nearest = this_xref;
          best_delta = delta;
        }
    }
  
  /* Maybe there was no list to search through.  */
  if (nearest < 0)
    return NULL;
  
  /* Ok, we have a nearest xref, make a list of it.  */
  {
    REFERENCE **ret = xmalloc (sizeof (REFERENCE *) * 2);
    ret[0] = info_copy_reference (xref_list[nearest]);
    ret[1] = NULL;
    return ret;
  }
}


/* Read a menu or followed reference from the user defaulting to the
   reference found on the current line, and select that node.  The
   reading is done with completion.  BUILDER is the function used
   to build the list of references.  ASK_P is non-zero if the user
   should be prompted, or zero to select the default item. */
static void
info_menu_or_ref_item (WINDOW *window, int count,
    unsigned char key, REFERENCE **(*builder) (NODE *node), int ask_p)
{
  char *line;
  REFERENCE *entry;
  REFERENCE *defentry = NULL;
  REFERENCE **menu = (*builder) (window->node);

  if (!menu)
    {
      if (builder == info_menu_of_node)
        info_error ((char *) msg_no_menu_node, NULL, NULL);
      else
        info_error ((char *) msg_no_xref_node, NULL, NULL);
      return;
    }

  /* Default the selected reference to the one which is on the line that
     point is in.  */
  {
    REFERENCE **refs = NULL;
    int point_line = window_line_of_point (window);

    if (point_line != -1)
      {
        SEARCH_BINDING binding;

        binding.buffer = window->node->contents;
        binding.start = window->line_starts[point_line] - binding.buffer;
        if (window->line_starts[point_line + 1])
          binding.end = window->line_starts[point_line + 1] - binding.buffer;
        else
          binding.end = window->node->nodelen;
        binding.flags = 0;

        if (builder == info_menu_of_node)
          {
            if (point_line)
              {
                binding.start--;
                refs = info_menu_items (&binding);
              }
          }
        else
          {
#if defined (HANDLE_MAN_PAGES)
            if (window->node->flags & N_IsManPage)
              refs = manpage_xrefs_in_binding (window->node, &binding);
            else
#endif /* HANDLE_MAN_PAGES */
              refs = nearest_xref (menu, window->point);
          }

        if (refs && refs[0])
          {
            if (strcmp (refs[0]->label, "Menu") != 0
                || builder == info_xrefs_of_node)
              {
                int which = 0;

                /* For xrefs, find the closest reference to point,
                   unless we only have one reference (as we will if
                   we've called nearest_xref above).  It would be better
                   to have only one piece of code, but the conditions
                   when we call this are tangled.  */
                if (builder == info_xrefs_of_node && refs[1])
                  {
                    int closest = -1;

                    for (; refs[which]; which++)
                      {
                        if (window->point >= refs[which]->start
                            && window->point <= refs[which]->end)
                          {
                            closest = which;
                            break;
                          }
                        else if (window->point < refs[which]->start)
                          break;
                      }
		    if (which > 0)
		      {
			if (closest == -1)
			  which--;
			else
			  which = closest;
		      }
                  }

		if (which < 0)
		  which = 0;
                defentry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                defentry->label = xstrdup (refs[which]->label);
                defentry->filename = refs[which]->filename;
                defentry->nodename = refs[which]->nodename;
                defentry->line_number = refs[which]->line_number;

                if (defentry->filename)
                  defentry->filename = xstrdup (defentry->filename);
                if (defentry->nodename)
                  defentry->nodename = xstrdup (defentry->nodename);
              }
            info_free_references (refs);
          }
      }
  }

  /* If we are going to ask the user a question, do it now. */
  if (ask_p)
    {
      char *prompt;

      /* Build the prompt string. */
      if (builder == info_menu_of_node)
        {
          if (defentry)
	    {
	      prompt = xmalloc (strlen (defentry->label)
				+ strlen (_("Menu item (%s): ")));
	      sprintf (prompt, _("Menu item (%s): "), defentry->label);
	    }
          else
	    prompt = xstrdup (_("Menu item: "));
        }
      else
        {
          if (defentry)
	    {
	      prompt = xmalloc (strlen (defentry->label)
				+ strlen (_("Follow xref (%s): ")));
	      sprintf (prompt, _("Follow xref (%s): "), defentry->label);
	    }
          else
	    prompt = xstrdup (_("Follow xref: "));
        }

      line = info_read_completing_in_echo_area (window, prompt, menu);
      free (prompt);

      window = active_window;

      /* User aborts, just quit. */
      if (!line)
        {
          maybe_free (defentry);
          info_free_references (menu);
          info_abort_key (window, 0, 0);
          return;
        }

      /* If we had a default and the user accepted it, use that. */
      if (!*line)
        {
          free (line);
          if (defentry)
            line = xstrdup (defentry->label);
          else
            line = (char *)NULL;
        }
    }
  else
    {
      /* Not going to ask any questions.  If we have a default entry, use
         that, otherwise return. */
      if (!defentry)
        return;
      else
        line = xstrdup (defentry->label);
    }

  if (line)
    {
      /* It is possible that the references have more than a single
         entry with the same label, and also LINE is down-cased, which
         complicates matters even more.  Try to be as accurate as we
         can: if they've chosen the default, use defentry directly. */
      if (defentry && strcmp (line, defentry->label) == 0)
        entry = defentry;
      else
        /* Find the selected label in the references.  If there are
           more than one label which matches, find the one that's
           closest to point.  */
        {
          register int i;
          int best = -1, min_dist = window->node->nodelen;
          REFERENCE *ref;

          for (i = 0; menu && (ref = menu[i]); i++)
            {
              /* Need to use strcasecmp because LINE is downcased
                 inside info_read_completing_in_echo_area.  */
              if (strcasecmp (line, ref->label) == 0)
                {
                  /* ref->end is more accurate estimate of position
                     for menus than ref->start.  Go figure.  */
                  int dist = abs (window->point - ref->end);

                  if (dist < min_dist)
                    {
                      min_dist = dist;
                      best = i;
                    }
                }
            }
          if (best != -1)
            entry = menu[best];
          else
            entry = (REFERENCE *)NULL;
        }

      if (!entry && defentry)
        info_error ((char *) _("The reference disappeared! (%s)."), line, NULL);
      else
        {
          NODE *orig = window->node;
          info_select_reference (window, entry);

          if (builder == info_xrefs_of_node && window->node != orig
              && !(window->node->flags & N_FromAnchor))
            { /* Search for this reference in the node.  */
              long offset;
              long start;

              if (window->line_count > 0)
                start = window->line_starts[1] - window->node->contents;
              else
                start = 0;

              offset =
                info_target_search_node (window->node, entry->label, start);

              if (offset != -1)
                {
                  window->point = offset;
                  window_adjust_pagetop (window);
                }
            }

            if (entry->line_number > 0)
              /* next_line starts at line 1?  Anyway, the -1 makes it
                 move to the right line.  */
              info_next_line (window, entry->line_number - 1, key);
        }

      free (line);
      if (defentry)
        {
          free (defentry->label);
          maybe_free (defentry->filename);
          maybe_free (defentry->nodename);
          free (defentry);
        }
    }

  info_free_references (menu);

  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Read a line (with completion) which is the name of a menu item,
   and select that item. */
DECLARE_INFO_COMMAND (info_menu_item, _("Read a menu item and select its node"))
{
  info_menu_or_ref_item (window, count, key, info_menu_of_node, 1);
}

/* Read a line (with completion) which is the name of a reference to
   follow, and select the node. */
DECLARE_INFO_COMMAND
  (info_xref_item, _("Read a footnote or cross reference and select its node"))
{
  info_menu_or_ref_item (window, count, key, info_xrefs_of_node, 1);
}

/* Position the cursor at the start of this node's menu. */
DECLARE_INFO_COMMAND (info_find_menu, _("Move to the start of this node's menu"))
{
  SEARCH_BINDING binding;
  long position;

  binding.buffer = window->node->contents;
  binding.start  = 0;
  binding.end = window->node->nodelen;
  binding.flags = S_FoldCase | S_SkipDest;

  position = search (INFO_MENU_LABEL, &binding);

  if (position == -1)
    info_error ((char *) msg_no_menu_node, NULL, NULL);
  else
    {
      window->point = position;
      window_adjust_pagetop (window);
      window->flags |= W_UpdateWindow;
    }
}

/* Visit as many menu items as is possible, each in a separate window. */
DECLARE_INFO_COMMAND (info_visit_menu,
  _("Visit as many menu items at once as possible"))
{
  register int i;
  REFERENCE *entry, **menu;

  menu = info_menu_of_node (window->node);

  if (!menu)
    info_error ((char *) msg_no_menu_node, NULL, NULL);

  for (i = 0; (!info_error_was_printed) && (entry = menu[i]); i++)
    {
      WINDOW *new;

      new = window_make_window (window->node);
      window_tile_windows (TILE_INTERNALS);

      if (!new)
        info_error ((char *) msg_win_too_small, NULL, NULL);
      else
        {
          active_window = new;
          info_select_reference (new, entry);
        }
    }
}

/* Read a line of input which is a node name, and go to that node. */
DECLARE_INFO_COMMAND (info_goto_node, _("Read a node name and select it"))
{
  char *line;

#define GOTO_COMPLETES
#if defined (GOTO_COMPLETES)
  /* Build a completion list of all of the known nodes. */
  {
    register int fbi, i;
    FILE_BUFFER *current;
    REFERENCE **items = (REFERENCE **)NULL;
    int items_index = 0;
    int items_slots = 0;

    current = file_buffer_of_window (window);

    for (fbi = 0; info_loaded_files && info_loaded_files[fbi]; fbi++)
      {
        FILE_BUFFER *fb;
        REFERENCE *entry;
        int this_is_the_current_fb;

        fb = info_loaded_files[fbi];
        this_is_the_current_fb = (current == fb);

        entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
        entry->filename = entry->nodename = (char *)NULL;
        entry->label = (char *)xmalloc (4 + strlen (fb->filename));
        sprintf (entry->label, "(%s)*", fb->filename);

        add_pointer_to_array
          (entry, items_index, items, items_slots, 10, REFERENCE *);

        if (fb->tags)
          {
            for (i = 0; fb->tags[i]; i++)
              {
                entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                entry->filename = entry->nodename = (char *)NULL;
		if (this_is_the_current_fb)
		  entry->label = xstrdup (fb->tags[i]->nodename);
		else
		  {
		    entry->label = (char *) xmalloc
		      (4 + strlen (fb->filename) +
		       strlen (fb->tags[i]->nodename));
		    sprintf (entry->label, "(%s)%s",
			     fb->filename, fb->tags[i]->nodename);
		  }

                add_pointer_to_array
                  (entry, items_index, items, items_slots, 100, REFERENCE *);
              }
          }
      }
    line = info_read_maybe_completing (window, (char *) _("Goto node: "),
        items);
    info_free_references (items);
  }
#else /* !GOTO_COMPLETES */
  line = info_read_in_echo_area (window, (char *) _("Goto node: "));
#endif /* !GOTO_COMPLETES */

  /* If the user aborted, quit now. */
  if (!line)
    {
      info_abort_key (window, 0, 0);
      return;
    }

  canonicalize_whitespace (line);

  if (*line)
    info_parse_and_select (line, window);

  free (line);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Follow the menu list in MENUS (list of strings terminated by a NULL
   entry) from INITIAL_NODE.  If can't continue at any point (no menu or
   no menu entry for the next item), return the node so far -- that
   might be INITIAL_NODE itself.  If error, *ERRSTR and *ERRARG[12] will
   be set to the error message and argument for message, otherwise they
   will be NULL.  */

NODE *
info_follow_menus (NODE *initial_node, char **menus,
    const char **errstr, char **errarg1, char **errarg2)
{
  NODE *node = NULL;
  *errstr = *errarg1 = *errarg2 = NULL;

  for (; *menus; menus++)
    {
      static char *first_arg = NULL;
      REFERENCE **menu;
      REFERENCE *entry;
      char *arg = *menus; /* Remember the name of the menu entry we want. */

      /* A leading space is certainly NOT part of a node name.  Most
	 probably, they typed a space after the separating comma.  The
	 strings in menus[] have their whitespace canonicalized, so
	 there's at most one space to ignore.  */
      if (*arg == ' ')
	arg++;
      if (!first_arg)
        first_arg = arg;

      /* Build and return a list of the menu items in this node. */
      menu = info_menu_of_node (initial_node);

      /* If no menu item in this node, stop here, but let the user
         continue to use Info.  Perhaps they wanted this node and didn't
         realize it. */
      if (!menu)
        {
          if (arg == first_arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
          *errstr = _("No menu in node `%s'.");
          *errarg1 = node_printed_rep (initial_node);
          return initial_node;
        }

      /* Find the specified menu item. */
      entry = info_get_labeled_reference (arg, menu);

      /* If the item wasn't found, search the list sloppily.  Perhaps this
         user typed "buffer" when they really meant "Buffers". */
      if (!entry)
        {
          int i;
          int best_guess = -1;

          for (i = 0; (entry = menu[i]); i++)
            {
              if (strcasecmp (entry->label, arg) == 0)
                break;
              else
                if ((best_guess == -1)
                    && (strncasecmp (entry->label, arg, strlen (arg)) == 0))
                  best_guess = i;
            }

          if (!entry && best_guess != -1)
            entry = menu[best_guess];
        }

      /* If we still failed to find the reference, start Info with the current
         node anyway.  It is probably a misspelling. */
      if (!entry)
        {
          if (arg == first_arg)
            {
	      /* Maybe they typed "info foo" instead of "info -f foo".  */
	      node = info_get_node (first_arg, 0);
	      if (node)
		add_file_directory_to_path (first_arg);
	      else
		node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }

          info_free_references (menu);
          *errstr = _("No menu item `%s' in node `%s'.");
          *errarg1 = arg;
          *errarg2 = node_printed_rep (initial_node);
          return initial_node;
        }

      /* We have found the reference that the user specified.  If no
         filename in this reference, define it. */
      if (!entry->filename)
        entry->filename = xstrdup (initial_node->parent ? initial_node->parent
                                                     : initial_node->filename);

      /* Try to find this node.  */
      node = info_get_node (entry->filename, entry->nodename);
      if (!node && arg == first_arg)
	{
	  node = make_manpage_node (first_arg);
	  if (node)
	    goto maybe_got_node;
	}

      /* Since we cannot find it, try using the label of the entry as a
         file, i.e., "(LABEL)Top".  */
      if (!node && entry->nodename
          && strcmp (entry->label, entry->nodename) == 0)
        node = info_get_node (entry->label, "Top");

    maybe_got_node:
      if (!node)
        {
          *errstr = _("Unable to find node referenced by `%s' in `%s'.");
          *errarg1 = xstrdup (entry->label);
          *errarg2 = node_printed_rep (initial_node);
          info_free_references (menu);
          return initial_node;
        }

      info_free_references (menu);

      /* Success.  Go round the loop again.  */
      free (initial_node);
      initial_node = node;
    }

  return initial_node;
}

/* Split STR into individual node names by writing null bytes in wherever
   there are commas and constructing a list of the resulting pointers.
   (We can do this since STR has had canonicalize_whitespace called on it.)
   Return array terminated with NULL.  */

static char **
split_list_of_nodenames (char *str)
{
  unsigned len = 2;
  char **nodes = xmalloc (len * sizeof (char *));

  nodes[len - 2] = str;

  while (*str++)
    {
      if (*str == ',')
        {
          *str++ = 0;		/* get past the null byte */
          len++;
          nodes = xrealloc (nodes, len * sizeof (char *));
          nodes[len - 2] = str;
        }
    }

  nodes[len - 1] = NULL;

  return nodes;
}


/* Read a line of input which is a sequence of menus (starting from
   dir), and follow them.  */
DECLARE_INFO_COMMAND (info_menu_sequence,
   _("Read a list of menus starting from dir and follow them"))
{
  char *line = info_read_in_echo_area (window, (char *) _("Follow menus: "));

  /* If the user aborted, quit now. */
  if (!line)
    {
      info_abort_key (window, 0, 0);
      return;
    }

  canonicalize_whitespace (line);

  if (*line)
    {
      const char *errstr;
      char *errarg1, *errarg2;
      NODE *dir_node = info_get_node (NULL, NULL);
      char **nodes = split_list_of_nodenames (line);
      NODE *node = NULL;

      /* If DIR_NODE is NULL, they might be reading a file directly,
	 like in "info -d . -f ./foo".  Try using "Top" instead.  */
      if (!dir_node)
	{
	  char *file_name = window->node->parent;

	  if (!file_name)
	    file_name = window->node->filename;
	  dir_node = info_get_node (file_name, NULL);
	}

      /* If we still cannot find the starting point, give up.
	 We cannot allow a NULL pointer inside info_follow_menus.  */
      if (!dir_node)
	info_error ((char *) msg_cant_find_node, "Top", NULL);
      else
	node = info_follow_menus (dir_node, nodes, &errstr, &errarg1, &errarg2);

      free (nodes);
      if (!errstr)
        info_set_node_of_window (1, window, node);
      else
        info_error ((char *) errstr, errarg1, errarg2);
    }

  free (line);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Search the menu MENU for a (possibly mis-spelled) entry ARG.
   Return the menu entry, or the best guess for what they meant by ARG,
   or NULL if there's nothing in this menu seems to fit the bill.
   If EXACT is non-zero, allow only exact matches.  */
static REFERENCE *
entry_in_menu (char *arg, REFERENCE **menu, int exact)
{
  REFERENCE *entry;

  /* First, try to find the specified menu item verbatim.  */
  entry = info_get_labeled_reference (arg, menu);

  /* If the item wasn't found, search the list sloppily.  Perhaps we
     have "Option Summary", but ARG is "option".  */
  if (!entry && !exact)
    {
      int i;
      int best_guess = -1;

      for (i = 0; (entry = menu[i]); i++)
	{
	  if (strcasecmp (entry->label, arg) == 0)
	    break;
	  else
	    if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
	      best_guess = i;
	}

      if (!entry && best_guess != -1)
	entry = menu[best_guess];
    }

  return entry;
}

/* Find the node that is the best candidate to list the PROGRAM's
   invocation info and its command-line options, by looking for menu
   items and chains of menu items with characteristic names.  */
void
info_intuit_options_node (WINDOW *window, NODE *initial_node, char *program)
{
  /* The list of node names typical for GNU manuals where the program
     usage and specifically the command-line arguments are described.
     This is pure heuristics.  I gathered these node names by looking
     at all the Info files I could put my hands on.  If you are
     looking for evidence to complain to the GNU project about
     non-uniform style of documentation, here you have your case!  */
  static const char *invocation_nodes[] = {
    "%s invocation",
    "Invoking %s",
    "Preliminaries",	/* m4 has Invoking under Preliminaries! */
    "Invocation",
    "Command Arguments",/* Emacs */
    "Invoking `%s'",
    "%s options",
    "Options",
    "Option ",		/* e.g. "Option Summary" */
    "Invoking",
    "All options",	/* tar, paxutils */
    "Arguments",
    "%s cmdline",	/* ar */
    "%s",		/* last resort */
    (const char *)0
  };
  NODE *node = NULL;
  REFERENCE **menu;
  const char **try_node;

  /* We keep looking deeper and deeper in the menu structure until
     there are no more menus or no menu items from the above list.
     Some manuals have the invocation node sitting 3 or 4 levels deep
     in the menu hierarchy...  */
  for (node = initial_node; node; initial_node = node)
    {
      REFERENCE *entry = NULL;

      /* Build and return a list of the menu items in this node. */
      menu = info_menu_of_node (initial_node);

      /* If no menu item in this node, stop here.  Perhaps this node
	 is the one they need.  */
      if (!menu)
	break;

      /* Look for node names typical for usage nodes in this menu.  */
      for (try_node = invocation_nodes; *try_node; try_node++)
	{
	  char *nodename;

	  nodename = xmalloc (strlen (program) + strlen (*try_node));
	  sprintf (nodename, *try_node, program);
	  /* The last resort "%s" is dangerous, so we restrict it
             to exact matches here.  */
	  entry = entry_in_menu (nodename, menu,
				 strcmp (*try_node, "%s") == 0);
	  free (nodename);
	  if (entry)
	    break;
	}

      if (!entry)
	break;

      if (!entry->filename)
	entry->filename = xstrdup (initial_node->parent ? initial_node->parent
				   : initial_node->filename);
      /* Try to find this node.  */
      node = info_get_node (entry->filename, entry->nodename);
      info_free_references (menu);
      if (!node)
	break;
    }

  /* We've got our best shot at the invocation node.  Now select it.  */
  if (initial_node)
    info_set_node_of_window (1, window, initial_node);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Given a name of an Info file, find the name of the package it
   describes by removing the leading directories and extensions.  */
char *
program_name_from_file_name (char *file_name)
{
  int i;
  char *program_name = xstrdup (filename_non_directory (file_name));

  for (i = strlen (program_name) - 1; i > 0; i--)
    if (program_name[i] == '.'
	&& (FILENAME_CMPN (program_name + i, ".info", 5) == 0
	    || FILENAME_CMPN (program_name + i, ".inf", 4) == 0
#ifdef __MSDOS__
	    || FILENAME_CMPN (program_name + i, ".i", 2) == 0
#endif
	    || isdigit (program_name[i + 1]))) /* a man page foo.1 */
      {
	program_name[i] = 0;
	break;
      }
  return program_name;
}

DECLARE_INFO_COMMAND (info_goto_invocation_node,
		      _("Find the node describing program invocation"))
{
  const char *invocation_prompt = _("Find Invocation node of [%s]: ");
  char *program_name, *line;
  char *default_program_name, *prompt, *file_name;
  NODE *top_node;

  /* Intuit the name of the program they are likely to want.
     We use the file name of the current Info file as a hint.  */
  file_name = window->node->parent ? window->node->parent
				   : window->node->filename;
  default_program_name = program_name_from_file_name (file_name);

  prompt = (char *)xmalloc (strlen (default_program_name) +
			    strlen (invocation_prompt));
  sprintf (prompt, invocation_prompt, default_program_name);
  line = info_read_in_echo_area (window, prompt);
  free (prompt);
  if (!line)
    {
      info_abort_key (window, 0, 0);
      return;
    }
  if (*line)
    program_name = line;
  else
    program_name = default_program_name;

  /* In interactive usage they'd probably expect us to begin looking
     from the Top node.  */
  top_node = info_get_node (file_name, NULL);
  if (!top_node)
    info_error ((char *) msg_cant_find_node, "Top", NULL);

  info_intuit_options_node (window, top_node, program_name);
  free (line);
  free (default_program_name);
}

#if defined (HANDLE_MAN_PAGES)
DECLARE_INFO_COMMAND (info_man, _("Read a manpage reference and select it"))
{
  char *line;

  line = info_read_in_echo_area (window, (char *) _("Get Manpage: "));

  if (!line)
    {
      info_abort_key (window, 0, 0);
      return;
    }

  canonicalize_whitespace (line);

  if (*line)
    {
      char *goto_command;

      goto_command = (char *)xmalloc
        (4 + strlen (MANPAGE_FILE_BUFFER_NAME) + strlen (line));

      sprintf (goto_command, "(%s)%s", MANPAGE_FILE_BUFFER_NAME, line);

      info_parse_and_select (goto_command, window);
      free (goto_command);
    }

  free (line);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}
#endif /* HANDLE_MAN_PAGES */

/* Move to the "Top" node in this file. */
DECLARE_INFO_COMMAND (info_top_node, _("Select the node `Top' in this file"))
{
  info_parse_and_select ("Top", window);
}

/* Move to the node "(dir)Top". */
DECLARE_INFO_COMMAND (info_dir_node, _("Select the node `(dir)'"))
{
  info_parse_and_select ("(dir)Top", window);
}


/* Read the name of a node to kill.  The list of available nodes comes
   from the nodes appearing in the current window configuration. */
static char *
read_nodename_to_kill (WINDOW *window)
{
  int iw;
  char *nodename;
  INFO_WINDOW *info_win;
  REFERENCE **menu = NULL;
  int menu_index = 0, menu_slots = 0;
  char *default_nodename = xstrdup (active_window->node->nodename);
  char *prompt = xmalloc (strlen (_("Kill node (%s): ")) + strlen (default_nodename));

  sprintf (prompt, _("Kill node (%s): "), default_nodename);

  for (iw = 0; (info_win = info_windows[iw]); iw++)
    {
      REFERENCE *entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
      entry->label = xstrdup (info_win->window->node->nodename);
      entry->filename = entry->nodename = (char *)NULL;

      add_pointer_to_array (entry, menu_index, menu, menu_slots, 10,
                            REFERENCE *);
    }

  nodename = info_read_completing_in_echo_area (window, prompt, menu);
  free (prompt);
  info_free_references (menu);
  if (nodename && !*nodename)
    {
      free (nodename);
      nodename = default_nodename;
    }
  else
    free (default_nodename);

  return nodename;
}


/* Delete NODENAME from this window, showing the most
   recently selected node in this window. */
static void
kill_node (WINDOW *window, char *nodename)
{
  int iw, i;
  INFO_WINDOW *info_win;
  NODE *temp;

  /* If there is no nodename to kill, quit now. */
  if (!nodename)
    {
      info_abort_key (window, 0, 0);
      return;
    }

  /* If there is a nodename, find it in our window list. */
  for (iw = 0; (info_win = info_windows[iw]); iw++)
    if (strcmp (nodename, info_win->nodes[info_win->current]->nodename) == 0
	&& info_win->window == window)
      break;

  if (!info_win)
    {
      if (*nodename)
        info_error ((char *) _("Cannot kill node `%s'"), nodename, NULL);
      else
        window_clear_echo_area ();

      return;
    }

  /* If there are no more nodes left anywhere to view, complain and exit. */
  if (info_windows_index == 1 && info_windows[0]->nodes_index == 1)
    {
      info_error ((char *) _("Cannot kill the last node"), NULL, NULL);
      return;
    }

  /* INFO_WIN contains the node that the user wants to stop viewing.  Delete
     this node from the list of nodes previously shown in this window. */
  for (i = info_win->current; i < info_win->nodes_index; i++)
    info_win->nodes[i] = info_win->nodes[i + 1];

  /* There is one less node in this window's history list. */
  info_win->nodes_index--;

  /* Make this window show the most recent history node. */
  info_win->current = info_win->nodes_index - 1;

  /* If there aren't any nodes left in this window, steal one from the
     next window. */
  if (info_win->current < 0)
    {
      INFO_WINDOW *stealer;
      int which, pagetop;
      long point;

      if (info_windows[iw + 1])
        stealer = info_windows[iw + 1];
      else
        stealer = info_windows[0];

      /* If the node being displayed in the next window is not the most
         recently loaded one, get the most recently loaded one. */
      if ((stealer->nodes_index - 1) != stealer->current)
        which = stealer->nodes_index - 1;

      /* Else, if there is another node behind the stealers current node,
         use that one. */
      else if (stealer->current > 0)
        which = stealer->current - 1;

      /* Else, just use the node appearing in STEALER's window. */
      else
        which = stealer->current;

      /* Copy this node. */
      {
        NODE *copy = xmalloc (sizeof (NODE));

        temp = stealer->nodes[which];
        point = stealer->points[which];
        pagetop = stealer->pagetops[which];

        copy->filename = temp->filename;
        copy->parent = temp->parent;
        copy->nodename = temp->nodename;
        copy->contents = temp->contents;
        copy->nodelen = temp->nodelen;
        copy->flags = temp->flags;
        copy->display_pos = temp->display_pos;

        temp = copy;
      }

      window_set_node_of_window (info_win->window, temp);
      window->point = point;
      window->pagetop = pagetop;
      remember_window_and_node (info_win->window, temp);
    }
  else
    {
      temp = info_win->nodes[info_win->current];
      temp->display_pos = info_win->points[info_win->current];
      window_set_node_of_window (info_win->window, temp);
    }

  if (!info_error_was_printed)
    window_clear_echo_area ();

  if (auto_footnotes_p)
    info_get_or_remove_footnotes (window);
}

/* Kill current node, thus going back one in the node history.  I (karl)
   do not think this is completely correct yet, because of the
   window-changing stuff in kill_node, but it's a lot better than the
   previous implementation, which did not account for nodes being
   visited twice at all.  */
DECLARE_INFO_COMMAND (info_history_node,
                      _("Select the most recently selected node"))
{
  kill_node (window, active_window->node->nodename);
}

/* Kill named node.  */
DECLARE_INFO_COMMAND (info_kill_node, _("Kill this node"))
{
  char *nodename = read_nodename_to_kill (window);
  kill_node (window, nodename);
}


/* Read the name of a file and select the entire file. */
DECLARE_INFO_COMMAND (info_view_file, _("Read the name of a file and select it"))
{
  char *line;

  line = info_read_in_echo_area (window, (char *) _("Find file: "));
  if (!line)
    {
      info_abort_key (active_window, 1, 0);
      return;
    }

  if (*line)
    {
      NODE *node;

      node = info_get_node (line, "*");
      if (!node)
        {
          if (info_recent_file_error)
            info_error (info_recent_file_error, NULL, NULL);
          else
            info_error ((char *) _("Cannot find `%s'."), line, NULL);
        }
      else
        info_set_node_of_window (1, window, node);

      free (line);
    }

  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* **************************************************************** */
/*                                                                  */
/*                 Dumping and Printing Nodes                       */
/*                                                                  */
/* **************************************************************** */

#define VERBOSE_NODE_DUMPING
static void write_node_to_stream (NODE *node, FILE *stream);
static void dump_node_to_stream (char *filename, char *nodename,
    FILE *stream, int dump_subnodes);
static void initialize_dumping (void);

/* Dump the nodes specified by FILENAME and NODENAMES to the file named
   in OUTPUT_FILENAME.  If DUMP_SUBNODES is non-zero, recursively dump
   the nodes which appear in the menu of each node dumped. */
void
dump_nodes_to_file (char *filename, char **nodenames,
    char *output_filename, int dump_subnodes)
{
  register int i;
  FILE *output_stream;

  /* Get the stream to print the nodes to.  Special case of an output
     filename of "-" means to dump the nodes to stdout. */
  if (strcmp (output_filename, "-") == 0)
    output_stream = stdout;
  else
    output_stream = fopen (output_filename, "w");

  if (!output_stream)
    {
      info_error ((char *) _("Could not create output file `%s'."),
          output_filename, NULL);
      return;
    }

  /* Print each node to stream. */
  initialize_dumping ();
  for (i = 0; nodenames[i]; i++)
    dump_node_to_stream (filename, nodenames[i], output_stream, dump_subnodes);

  if (output_stream != stdout)
    fclose (output_stream);

#if defined (VERBOSE_NODE_DUMPING)
  info_error ((char *) _("Done."), NULL, NULL);
#endif /* VERBOSE_NODE_DUMPING */
}

/* A place to remember already dumped nodes. */
static char **dumped_already = (char **)NULL;
static int dumped_already_index = 0;
static int dumped_already_slots = 0;

static void
initialize_dumping (void)
{
  dumped_already_index = 0;
}

/* Get and print the node specified by FILENAME and NODENAME to STREAM.
   If DUMP_SUBNODES is non-zero, recursively dump the nodes which appear
   in the menu of each node dumped. */
static void
dump_node_to_stream (char *filename, char *nodename,
    FILE *stream, int dump_subnodes)
{
  register int i;
  NODE *node;

  node = info_get_node (filename, nodename);

  if (!node)
    {
      if (info_recent_file_error)
        info_error (info_recent_file_error, NULL, NULL);
      else
        {
          if (filename && *nodename != '(')
            info_error ((char *) msg_cant_file_node,
                filename_non_directory (filename),
                nodename);
          else
            info_error ((char *) msg_cant_find_node, nodename, NULL);
        }
      return;
    }

  /* If we have already dumped this node, don't dump it again. */
  for (i = 0; i < dumped_already_index; i++)
    if (strcmp (node->nodename, dumped_already[i]) == 0)
      {
        free (node);
        return;
      }
  add_pointer_to_array (node->nodename, dumped_already_index, dumped_already,
                        dumped_already_slots, 50, char *);

#if defined (VERBOSE_NODE_DUMPING)
  /* Maybe we should print some information about the node being output. */
  info_error ((char *) _("Writing node %s..."), node_printed_rep (node), NULL);
#endif /* VERBOSE_NODE_DUMPING */

  write_node_to_stream (node, stream);

  /* If we are dumping subnodes, get the list of menu items in this node,
     and dump each one recursively. */
  if (dump_subnodes)
    {
      REFERENCE **menu = (REFERENCE **)NULL;

      /* If this node is an Index, do not dump the menu references. */
      if (string_in_line ("Index", node->nodename) == -1)
        menu = info_menu_of_node (node);

      if (menu)
        {
          for (i = 0; menu[i]; i++)
            {
              /* We don't dump Info files which are different than the
                 current one. */
              if (!menu[i]->filename)
                dump_node_to_stream
                  (filename, menu[i]->nodename, stream, dump_subnodes);
            }
          info_free_references (menu);
        }
    }

  free (node);
}

/* Dump NODE to FILENAME.  If DUMP_SUBNODES is non-zero, recursively dump
   the nodes which appear in the menu of each node dumped. */
void
dump_node_to_file (NODE *node, char *filename, int dump_subnodes)
{
  FILE *output_stream;
  char *nodes_filename;

  /* Get the stream to print this node to.  Special case of an output
     filename of "-" means to dump the nodes to stdout. */
  if (strcmp (filename, "-") == 0)
    output_stream = stdout;
  else
    output_stream = fopen (filename, "w");

  if (!output_stream)
    {
      info_error ((char *) _("Could not create output file `%s'."), filename,
          NULL);
      return;
    }

  if (node->parent)
    nodes_filename = node->parent;
  else
    nodes_filename = node->filename;

  initialize_dumping ();
  dump_node_to_stream
    (nodes_filename, node->nodename, output_stream, dump_subnodes);

  if (output_stream != stdout)
    fclose (output_stream);

#if defined (VERBOSE_NODE_DUMPING)
  info_error ((char *) _("Done."), NULL, NULL);
#endif /* VERBOSE_NODE_DUMPING */
}

#if !defined (DEFAULT_INFO_PRINT_COMMAND)
#  define DEFAULT_INFO_PRINT_COMMAND "lpr"
#endif /* !DEFAULT_INFO_PRINT_COMMAND */

DECLARE_INFO_COMMAND (info_print_node,
 _("Pipe the contents of this node through INFO_PRINT_COMMAND"))
{
  print_node (window->node);
}

/* Print NODE on a printer piping it into INFO_PRINT_COMMAND. */
void
print_node (NODE *node)
{
  FILE *printer_pipe;
  char *print_command = getenv ("INFO_PRINT_COMMAND");
  int piping = 0;

  if (!print_command || !*print_command)
    print_command = DEFAULT_INFO_PRINT_COMMAND;

  /* Note that on MS-DOS/MS-Windows, this MUST open the pipe in the
     (default) text mode, since the printer drivers there need to see
     DOS-style CRLF pairs at the end of each line.

     FIXME: if we are to support Mac-style text files, we might need
     to convert the text here.  */

  /* INFO_PRINT_COMMAND which says ">file" means write to that file.
     Presumably, the name of the file is the local printer device.  */
  if (*print_command == '>')
    printer_pipe = fopen (++print_command, "w");
  else
    {
      printer_pipe = popen (print_command, "w");
      piping = 1;
    }

  if (!printer_pipe)
    {
      info_error ((char *) _("Cannot open pipe to `%s'."), print_command, NULL);
      return;
    }

#if defined (VERBOSE_NODE_DUMPING)
  /* Maybe we should print some information about the node being output. */
  info_error ((char *) _("Printing node %s..."), node_printed_rep (node), NULL);
#endif /* VERBOSE_NODE_DUMPING */

  write_node_to_stream (node, printer_pipe);
  if (piping)
    pclose (printer_pipe);
  else
    fclose (printer_pipe);

#if defined (VERBOSE_NODE_DUMPING)
  info_error ((char *) _("Done."), NULL, NULL);
#endif /* VERBOSE_NODE_DUMPING */
}

static void
write_node_to_stream (NODE *node, FILE *stream)
{
  fwrite (node->contents, 1, node->nodelen, stream);
}

/* **************************************************************** */
/*                                                                  */
/*                    Info Searching Commands                       */
/*                                                                  */
/* **************************************************************** */

/* Variable controlling the garbage collection of files briefly visited
   during searches.  Such files are normally gc'ed, unless they were
   compressed to begin with.  If this variable is non-zero, it says
   to gc even those file buffer contents which had to be uncompressed. */
int gc_compressed_files = 0;

static void info_gc_file_buffers (void);
static void info_search_1 (WINDOW *window, int count,
    unsigned char key, int case_sensitive, int ask_for_string);

static char *search_string = (char *)NULL;
static int search_string_size = 0;
static int isearch_is_active = 0;

static int last_search_direction = 0;
static int last_search_case_sensitive = 0;

/* Return the file buffer which belongs to WINDOW's node. */
FILE_BUFFER *
file_buffer_of_window (WINDOW *window)
{
  /* If this window has no node, then it has no file buffer. */
  if (!window->node)
    return ((FILE_BUFFER *)NULL);

  if (window->node->parent)
    return (info_find_file (window->node->parent));

  if (window->node->filename)
    return (info_find_file (window->node->filename));

  return ((FILE_BUFFER *)NULL);
}

/* Search for STRING in NODE starting at START.  Return -1 if the string
   was not found, or the location of the string if it was.  If WINDOW is
   passed as non-null, set the window's node to be NODE, its point to be
   the found string, and readjust the window's pagetop.  Final argument
   DIR says which direction to search in.  If it is positive, search
   forward, else backwards. */
long
info_search_in_node (char *string, NODE *node, long int start,
    WINDOW *window, int dir, int case_sensitive)
{
  SEARCH_BINDING binding;
  long offset;

  binding.buffer = node->contents;
  binding.start = start;
  binding.end = node->nodelen;
  binding.flags = 0;
  if (!case_sensitive)
    binding.flags |= S_FoldCase;

  if (dir < 0)
    {
      binding.end = 0;
      binding.flags |= S_SkipDest;
    }

  if (binding.start < 0)
    return (-1);

  /* For incremental searches, we always wish to skip past the string. */
  if (isearch_is_active)
    binding.flags |= S_SkipDest;

  offset = search (string, &binding);

  if (offset != -1 && window)
    {
      set_remembered_pagetop_and_point (window);
      if (window->node != node)
        window_set_node_of_window (window, node);
      window->point = offset;
      window_adjust_pagetop (window);
    }
  return (offset);
}

/* Search NODE, looking for the largest possible match of STRING.  Start the
   search at START.  Return the absolute position of the match, or -1, if
   no part of the string could be found. */
long
info_target_search_node (NODE *node, char *string, long int start)
{
  register int i;
  long offset = 0;
  char *target;

  target = xstrdup (string);
  i = strlen (target);

  /* Try repeatedly searching for this string while removing words from
     the end of it. */
  while (i)
    {
      target[i] = '\0';
      offset = info_search_in_node (target, node, start, (WINDOW *)NULL, 1, 0);

      if (offset != -1)
        break;

      /* Delete the last word from TARGET. */
      for (; i && (!whitespace (target[i]) && (target[i] != ',')); i--);
    }
  free (target);
  return (offset);
}

/* Search for STRING starting in WINDOW at point.  If the string is found
   in this node, set point to that position.  Otherwise, get the file buffer
   associated with WINDOW's node, and search through each node in that file.
   If the search fails, return non-zero, else zero.  Side-effect window
   leaving the node and point where the string was found current. */
static int
info_search_internal (char *string, WINDOW *window,
    int dir, int case_sensitive)
{
  register int i;
  FILE_BUFFER *file_buffer;
  char *initial_nodename;
  long ret, start = 0;

  file_buffer = file_buffer_of_window (window);
  initial_nodename = window->node->nodename;

  /* This used to begin from window->point, unless this was a repeated
     search command.  But invoking search with an argument loses with
     that logic, since info_last_executed_command is then set to
     info_add_digit_to_numeric_arg.  I think there's no sense in
     ``finding'' a string that is already under the cursor, anyway.  */
  ret = info_search_in_node
        (string, window->node, window->point + dir, window, dir,
         case_sensitive);

  if (ret != -1)
    {
      /* We won! */
      if (!echo_area_is_active && !isearch_is_active)
        window_clear_echo_area ();
      return (0);
    }

  /* The string wasn't found in the current node.  Search through the
     window's file buffer, iff the current node is not "*". */
  if (!file_buffer || (strcmp (initial_nodename, "*") == 0))
    return (-1);

  /* If this file has tags, search through every subfile, starting at
     this node's subfile and node.  Otherwise, search through the
     file's node list. */
  if (file_buffer->tags)
    {
      register int current_tag = 0, number_of_tags;
      char *last_subfile;
      TAG *tag;

      /* Find number of tags and current tag. */
      last_subfile = (char *)NULL;
      for (i = 0; file_buffer->tags[i]; i++)
        if (strcmp (initial_nodename, file_buffer->tags[i]->nodename) == 0)
          {
            current_tag = i;
            last_subfile = file_buffer->tags[i]->filename;
          }

      number_of_tags = i;

      /* If there is no last_subfile, our tag wasn't found. */
      if (!last_subfile)
        return (-1);

      /* Search through subsequent nodes, wrapping around to the top
         of the info file until we find the string or return to this
         window's node and point. */
      while (1)
        {
          NODE *node;

          /* Allow C-g to quit the search, failing it if pressed. */
          return_if_control_g (-1);

          /* Find the next tag that isn't an anchor.  */
          for (i = current_tag + dir; i != current_tag; i += dir)
            {
              if (i < 0)
                i = number_of_tags - 1;
              else if (i == number_of_tags)
                i = 0;

              tag = file_buffer->tags[i];
              if (tag->nodelen != 0)
                break;
            }

          /* If we got past out starting point, bail out.  */
          if (i == current_tag)
            return (-1);
          current_tag = i;

          if (!echo_area_is_active && (last_subfile != tag->filename))
            {
              window_message_in_echo_area
                ((char *) _("Searching subfile %s ..."),
                 filename_non_directory (tag->filename), NULL);

              last_subfile = tag->filename;
            }

          node = info_get_node (file_buffer->filename, tag->nodename);

          if (!node)
            {
              /* If not doing i-search... */
              if (!echo_area_is_active)
                {
                  if (info_recent_file_error)
                    info_error (info_recent_file_error, NULL, NULL);
                  else
                    info_error ((char *) msg_cant_file_node,
                                filename_non_directory (file_buffer->filename),
                                tag->nodename);
                }
              return (-1);
            }

          if (dir < 0)
            start = tag->nodelen;

          ret =
            info_search_in_node (string, node, start, window, dir,
                                 case_sensitive);

          /* Did we find the string in this node? */
          if (ret != -1)
            {
              /* Yes!  We win. */
              remember_window_and_node (window, node);
              if (!echo_area_is_active)
                window_clear_echo_area ();
              return (0);
            }

          /* No.  Free this node, and make sure that we haven't passed
             our starting point. */
          free (node);

          if (strcmp (initial_nodename, tag->nodename) == 0)
            return (-1);
        }
    }
  return (-1);
}

DECLARE_INFO_COMMAND (info_search_case_sensitively,
                      _("Read a string and search for it case-sensitively"))
{
  last_search_direction = count > 0 ? 1 : -1;
  last_search_case_sensitive = 1;
  info_search_1 (window, count, key, 1, 1);
}

DECLARE_INFO_COMMAND (info_search, _("Read a string and search for it"))
{
  last_search_direction = count > 0 ? 1 : -1;
  last_search_case_sensitive = 0;
  info_search_1 (window, count, key, 0, 1);
}

DECLARE_INFO_COMMAND (info_search_backward,
		      _("Read a string and search backward for it"))
{
  last_search_direction = count > 0 ? -1 : 1;
  last_search_case_sensitive = 0;
  info_search_1 (window, -count, key, 0, 1);
}

static void
info_search_1 (WINDOW *window, int count, unsigned char key,
    int case_sensitive, int ask_for_string)
{
  char *line, *prompt;
  int result, old_pagetop;
  int direction;

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    {
      direction = 1;
      if (count == 0)
        count = 1;	/* for backward compatibility */
    }

  /* Read a string from the user, defaulting the search to SEARCH_STRING. */
  if (!search_string)
    {
      search_string = (char *)xmalloc (search_string_size = 100);
      search_string[0] = '\0';
    }

  if (ask_for_string)
    {
      prompt = (char *)xmalloc (strlen (_("%s%sfor string [%s]: "))
				+ strlen (_("Search backward"))
				+ strlen (_("Search"))
				+ strlen (_(" case-sensitively "))
				+ strlen (_(" "))
				+ strlen (search_string));

      sprintf (prompt, _("%s%sfor string [%s]: "),
               direction < 0 ? _("Search backward") : _("Search"),
               case_sensitive ? _(" case-sensitively ") : _(" "),
               search_string);

      line = info_read_in_echo_area (window, prompt);
      free (prompt);

      if (!line)
        {
          info_abort_key (window, 0, 0);
          return;
        }

      if (*line)
        {
          if (strlen (line) + 1 > (unsigned int) search_string_size)
            search_string = (char *) xrealloc
              (search_string, (search_string_size += 50 + strlen (line)));

          strcpy (search_string, line);
          free (line);
        }
    }

  /* If the search string includes upper-case letters, make the search
     case-sensitive.  */
  if (case_sensitive == 0)
    for (line = search_string; *line; line++)
      if (isupper (*line))
        {
          case_sensitive = 1;
          break;
        }

  old_pagetop = active_window->pagetop;
  for (result = 0; result == 0 && count--; )
    result = info_search_internal (search_string,
                                   active_window, direction, case_sensitive);

  if (result != 0 && !info_error_was_printed)
    info_error ((char *) _("Search failed."), NULL, NULL);
  else if (old_pagetop != active_window->pagetop)
    {
      int new_pagetop;

      new_pagetop = active_window->pagetop;
      active_window->pagetop = old_pagetop;
      set_window_pagetop (active_window, new_pagetop);
      if (auto_footnotes_p)
        info_get_or_remove_footnotes (active_window);
    }

  /* Perhaps free the unreferenced file buffers that were searched, but
     not retained. */
  info_gc_file_buffers ();
}

DECLARE_INFO_COMMAND (info_search_next,
		      _("Repeat last search in the same direction"))
{
  if (!last_search_direction)
    info_error ((char *) _("No previous search string"), NULL, NULL);
  else
    info_search_1 (window, last_search_direction * count,
		   key, last_search_case_sensitive, 0);
}

DECLARE_INFO_COMMAND (info_search_previous,
		      _("Repeat last search in the reverse direction"))
{
  if (!last_search_direction)
    info_error ((char *) _("No previous search string"), NULL, NULL);
  else
    info_search_1 (window, -last_search_direction * count,
		   key, last_search_case_sensitive, 0);
}

/* **************************************************************** */
/*                                                                  */
/*                      Incremental Searching                       */
/*                                                                  */
/* **************************************************************** */

static void incremental_search (WINDOW *window, int count,
    unsigned char ignore);

DECLARE_INFO_COMMAND (isearch_forward,
                      _("Search interactively for a string as you type it"))
{
  incremental_search (window, count, key);
}

DECLARE_INFO_COMMAND (isearch_backward,
                      _("Search interactively for a string as you type it"))
{
  incremental_search (window, -count, key);
}

/* Incrementally search for a string as it is typed. */
/* The last accepted incremental search string. */
static char *last_isearch_accepted = (char *)NULL;

/* The current incremental search string. */
static char *isearch_string = (char *)NULL;
static int isearch_string_index = 0;
static int isearch_string_size = 0;
static unsigned char isearch_terminate_search_key = ESC;

/* Array of search states. */
static SEARCH_STATE **isearch_states = (SEARCH_STATE **)NULL;
static int isearch_states_index = 0;
static int isearch_states_slots = 0;

/* Push the state of this search. */
static void
push_isearch (WINDOW *window, int search_index, int direction, int failing)
{
  SEARCH_STATE *state;

  state = (SEARCH_STATE *)xmalloc (sizeof (SEARCH_STATE));
  window_get_state (window, state);
  state->search_index = search_index;
  state->direction = direction;
  state->failing = failing;

  add_pointer_to_array (state, isearch_states_index, isearch_states,
                        isearch_states_slots, 20, SEARCH_STATE *);
}

/* Pop the state of this search to WINDOW, SEARCH_INDEX, and DIRECTION. */
static void
pop_isearch (WINDOW *window, int *search_index, int *direction, int *failing)
{
  SEARCH_STATE *state;

  if (isearch_states_index)
    {
      isearch_states_index--;
      state = isearch_states[isearch_states_index];
      window_set_state (window, state);
      *search_index = state->search_index;
      *direction = state->direction;
      *failing = state->failing;

      free (state);
      isearch_states[isearch_states_index] = (SEARCH_STATE *)NULL;
    }
}

/* Free the memory used by isearch_states. */
static void
free_isearch_states (void)
{
  register int i;

  for (i = 0; i < isearch_states_index; i++)
    {
      free (isearch_states[i]);
      isearch_states[i] = (SEARCH_STATE *)NULL;
    }
  isearch_states_index = 0;
}

/* Display the current search in the echo area. */
static void
show_isearch_prompt (int dir, unsigned char *string, int failing_p)
{
  register int i;
  const char *prefix;
  char *prompt, *p_rep;
  unsigned int prompt_len, p_rep_index, p_rep_size;

  if (dir < 0)
    prefix = _("I-search backward: ");
  else
    prefix = _("I-search: ");

  p_rep_index = p_rep_size = 0;
  p_rep = (char *)NULL;
  for (i = 0; string[i]; i++)
    {
      char *rep;

      switch (string[i])
        {
        case ' ': rep = " "; break;
        case LFD: rep = "\\n"; break;
        case TAB: rep = "\\t"; break;
        default:
          rep = pretty_keyname (string[i]);
        }
      if ((p_rep_index + strlen (rep) + 1) >= p_rep_size)
        p_rep = (char *)xrealloc (p_rep, p_rep_size += 100);

      strcpy (p_rep + p_rep_index, rep);
      p_rep_index += strlen (rep);
    }

  prompt_len = strlen (prefix) + p_rep_index + 1;
  if (failing_p)
    prompt_len += strlen (_("Failing "));
  prompt = xmalloc (prompt_len);
  sprintf (prompt, "%s%s%s", failing_p ? _("Failing ") : "", prefix,
           p_rep ? p_rep : "");

  window_message_in_echo_area ("%s", prompt, NULL);
  maybe_free (p_rep);
  free (prompt);
  display_cursor_at_point (active_window);
}

static void
incremental_search (WINDOW *window, int count, unsigned char ignore)
{
  unsigned char key;
  int last_search_result, search_result, dir;
  SEARCH_STATE mystate, orig_state;
  char *p;
  int case_sensitive = 0;

  if (count < 0)
    dir = -1;
  else
    dir = 1;

  last_search_result = search_result = 0;

  window_get_state (window, &orig_state);

  isearch_string_index = 0;
  if (!isearch_string_size)
    isearch_string = (char *)xmalloc (isearch_string_size = 50);

  /* Show the search string in the echo area. */
  isearch_string[isearch_string_index] = '\0';
  show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);

  isearch_is_active = 1;

  while (isearch_is_active)
    {
      VFunction *func = (VFunction *)NULL;
      int quoted = 0;

      /* If a recent display was interrupted, then do the redisplay now if
         it is convenient. */
      if (!info_any_buffered_input_p () && display_was_interrupted_p)
        {
          display_update_one_window (window);
          display_cursor_at_point (active_window);
        }

      /* Read a character and dispatch on it. */
      key = info_get_input_char ();
      window_get_state (window, &mystate);

      if (key == DEL || key == Control ('h'))
        {
          /* User wants to delete one level of search? */
          if (!isearch_states_index)
            {
              terminal_ring_bell ();
              continue;
            }
          else
            {
              pop_isearch
                (window, &isearch_string_index, &dir, &search_result);
              isearch_string[isearch_string_index] = '\0';
              show_isearch_prompt (dir, (unsigned char *) isearch_string,
                  search_result);
              goto after_search;
            }
        }
      else if (key == Control ('q'))
        {
          key = info_get_input_char ();
          quoted = 1;
        }

      /* We are about to search again, or quit.  Save the current search. */
      push_isearch (window, isearch_string_index, dir, search_result);

      if (quoted)
        goto insert_and_search;

      if (!Meta_p (key) || key > 32)
        {
          /* If this key is not a keymap, get its associated function,
             if any.  If it is a keymap, then it's probably ESC from an
             arrow key, and we handle that case below.  */
          char type = window->keymap[key].type;
          func = type == ISFUNC
                 ? InfoFunction(window->keymap[key].function)
                 : NULL;  /* function member is a Keymap if ISKMAP */

          if (isprint (key) || (type == ISFUNC && func == NULL))
            {
            insert_and_search:

              if (isearch_string_index + 2 >= isearch_string_size)
                isearch_string = (char *)xrealloc
                  (isearch_string, isearch_string_size += 100);

              isearch_string[isearch_string_index++] = key;
              isearch_string[isearch_string_index] = '\0';
              goto search_now;
            }
          else if (func == (VFunction *) isearch_forward
              || func == (VFunction *) isearch_backward)
            {
	      /* If this key invokes an incremental search, then this
		 means that we will either search again in the same
		 direction, search again in the reverse direction, or
		 insert the last search string that was accepted through
		 incremental searching. */
              if ((func == (VFunction *) isearch_forward && dir > 0) ||
                  (func == (VFunction *) isearch_backward && dir < 0))
                {
                  /* If the user has typed no characters, then insert the
                     last successful search into the current search string. */
                  if (isearch_string_index == 0)
                    {
                      /* Of course, there must be something to insert. */
                      if (last_isearch_accepted)
                        {
                          if (strlen ((char *) last_isearch_accepted) + 1
                              >= (unsigned int) isearch_string_size)
                            isearch_string = (char *)
                              xrealloc (isearch_string,
                                        isearch_string_size += 10 +
                                        strlen (last_isearch_accepted));
                          strcpy (isearch_string, last_isearch_accepted);
                          isearch_string_index = strlen (isearch_string);
                          goto search_now;
                        }
                      else
                        continue;
                    }
                  else
                    {
                      /* Search again in the same direction.  This means start
                         from a new place if the last search was successful. */
                      if (search_result == 0)
                        window->point += dir;
                    }
                }
              else
                {
                  /* Reverse the direction of the search. */
                  dir = -dir;
                }
            }
          else if (func == (VFunction *) info_abort_key)
            {
              /* If C-g pressed, and the search is failing, pop the search
                 stack back to the last unfailed search. */
              if (isearch_states_index && (search_result != 0))
                {
                  terminal_ring_bell ();
                  while (isearch_states_index && (search_result != 0))
                    pop_isearch
                      (window, &isearch_string_index, &dir, &search_result);
                  isearch_string[isearch_string_index] = '\0';
                  show_isearch_prompt (dir, (unsigned char *) isearch_string,
                      search_result);
                  continue;
                }
              else
                goto exit_search;
            }
          else
            goto exit_search;
        }
      else
        {
        exit_search:
          /* The character is not printable, or it has a function which is
             non-null.  Exit the search, remembering the search string.  If
             the key is not the same as the isearch_terminate_search_key,
             then push it into pending input. */
          if (isearch_string_index && func != (VFunction *) info_abort_key)
            {
              maybe_free (last_isearch_accepted);
              last_isearch_accepted = xstrdup (isearch_string);
            }

	  /* If the key is the isearch_terminate_search_key, but some buffered
	     input is pending, it is almost invariably because the ESC key is
	     actually the beginning of an escape sequence, like in case they
	     pressed an arrow key.  So don't gobble the ESC key, push it back
	     into pending input.  */
	  /* FIXME: this seems like a kludge!  We need a more reliable
	     mechanism to know when ESC is a separate key and when it is
	     part of an escape sequence.  */
          if (key != RET  /* Emacs addicts want RET to get lost */
	      && (key != isearch_terminate_search_key
		  || info_any_buffered_input_p ()))
            info_set_pending_input (key);

          if (func == (VFunction *) info_abort_key)
            {
              if (isearch_states_index)
                window_set_state (window, &orig_state);
            }

          if (!echo_area_is_active)
            window_clear_echo_area ();

          if (auto_footnotes_p)
            info_get_or_remove_footnotes (active_window);

          isearch_is_active = 0;
          continue;
        }

      /* Search for the contents of isearch_string. */
    search_now:
      show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);

      /* If the search string includes upper-case letters, make the
         search case-sensitive.  */
      for (p = isearch_string; *p; p++)
        if (isupper (*p))
          {
            case_sensitive = 1;
            break;
          }
      

      if (search_result == 0)
        {
          /* Check to see if the current search string is right here.  If
             we are looking at it, then don't bother calling the search
             function. */
          if (((dir < 0) &&
	       ((case_sensitive ? strncmp : strncasecmp)
                            (window->node->contents + window->point,
                             isearch_string, isearch_string_index) == 0)) ||
              ((dir > 0) &&
               ((window->point - isearch_string_index) >= 0) &&
	       ((case_sensitive ? strncmp : strncasecmp)
                            (window->node->contents +
                             (window->point - (isearch_string_index - 1)),
                             isearch_string, isearch_string_index) == 0)))
            {
              if (dir > 0)
                window->point++;
            }
          else
            search_result = info_search_internal (isearch_string,
						  window, dir, case_sensitive);
        }

      /* If this search failed, and we didn't already have a failed search,
         then ring the terminal bell. */
      if (search_result != 0 && last_search_result == 0)
        terminal_ring_bell ();

    after_search:
      show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);

      if (search_result == 0)
        {
          if ((mystate.node == window->node) &&
              (mystate.pagetop != window->pagetop))
            {
              int newtop = window->pagetop;
              window->pagetop = mystate.pagetop;
              set_window_pagetop (window, newtop);
            }
          display_update_one_window (window);
          display_cursor_at_point (window);
        }

      last_search_result = search_result;
    }

  /* Free the memory used to remember each search state. */
  free_isearch_states ();

  /* Perhaps GC some file buffers. */
  info_gc_file_buffers ();

  /* After searching, leave the window in the correct state. */
  if (!echo_area_is_active)
    window_clear_echo_area ();
}

/* GC some file buffers.  A file buffer can be gc-ed if there we have
   no nodes in INFO_WINDOWS that reference this file buffer's contents.
   Garbage collecting a file buffer means to free the file buffers
   contents. */
static void
info_gc_file_buffers (void)
{
  register int fb_index, iw_index, i;
  register FILE_BUFFER *fb;
  register INFO_WINDOW *iw;

  if (!info_loaded_files)
    return;

  for (fb_index = 0; (fb = info_loaded_files[fb_index]); fb_index++)
    {
      int fb_referenced_p = 0;

      /* If already gc-ed, do nothing. */
      if (!fb->contents)
        continue;

      /* If this file had to be uncompressed, check to see if we should
         gc it.  This means that the user-variable "gc-compressed-files"
         is non-zero. */
      if ((fb->flags & N_IsCompressed) && !gc_compressed_files)
        continue;

      /* If this file's contents are not gc-able, move on. */
      if (fb->flags & N_CannotGC)
        continue;

      /* Check each INFO_WINDOW to see if it has any nodes which reference
         this file. */
      for (iw_index = 0; (iw = info_windows[iw_index]); iw_index++)
        {
          for (i = 0; iw->nodes && iw->nodes[i]; i++)
            {
              if ((FILENAME_CMP (fb->fullpath, iw->nodes[i]->filename) == 0) ||
                  (FILENAME_CMP (fb->filename, iw->nodes[i]->filename) == 0))
                {
                  fb_referenced_p = 1;
                  break;
                }
            }
        }

      /* If this file buffer wasn't referenced, free its contents. */
      if (!fb_referenced_p)
        {
          free (fb->contents);
          fb->contents = (char *)NULL;
        }
    }
}

/* **************************************************************** */
/*                                                                  */
/*                Traversing and Selecting References               */
/*                                                                  */
/* **************************************************************** */

/* Move to the next or previous cross reference in this node. */
static void
info_move_to_xref (WINDOW *window, int count, unsigned char key, int dir)
{
  long firstmenu, firstxref;
  long nextmenu, nextxref;
  long placement = -1;
  long start = 0;
  NODE *node = window->node;

  if (dir < 0)
    start = node->nodelen;

  /* This search is only allowed to fail if there is no menu or cross
     reference in the current node.  Otherwise, the first menu or xref
     found is moved to. */

  firstmenu = info_search_in_node
    (INFO_MENU_ENTRY_LABEL, node, start, (WINDOW *)NULL, dir, 0);

  /* FIRSTMENU may point directly to the line defining the menu.  Skip that
     and go directly to the first item. */

  if (firstmenu != -1)
    {
      char *text = node->contents + firstmenu;

      if (strncmp (text, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL)) == 0)
        firstmenu = info_search_in_node
          (INFO_MENU_ENTRY_LABEL, node, firstmenu + dir, (WINDOW *)NULL, dir, 0);
    }

  firstxref =
    info_search_in_node (INFO_XREF_LABEL, node, start, (WINDOW *)NULL, dir, 0);

#if defined (HANDLE_MAN_PAGES)
  if ((firstxref == -1) && (node->flags & N_IsManPage))
    {
      firstxref = locate_manpage_xref (node, start, dir);
    }
#endif /* HANDLE_MAN_PAGES */

  if (firstmenu == -1 && firstxref == -1)
    {
      info_error ((char *) msg_no_xref_node, NULL, NULL);
      return;
    }

  /* There is at least one cross reference or menu entry in this node.
     Try hard to find the next available one. */

  nextmenu = info_search_in_node
    (INFO_MENU_ENTRY_LABEL, node, window->point + dir, (WINDOW *)NULL, dir, 0);

  nextxref = info_search_in_node
    (INFO_XREF_LABEL, node, window->point + dir, (WINDOW *)NULL, dir, 0);

#if defined (HANDLE_MAN_PAGES)
  if ((nextxref == -1) && (node->flags & N_IsManPage) && (firstxref != -1))
    nextxref = locate_manpage_xref (node, window->point + dir, dir);
#endif /* HANDLE_MAN_PAGES */

  /* Ignore "Menu:" as a menu item. */
  if (nextmenu != -1)
    {
      char *text = node->contents + nextmenu;

      if (strncmp (text, INFO_MENU_LABEL, strlen (INFO_MENU_LABEL)) == 0)
        nextmenu = info_search_in_node
          (INFO_MENU_ENTRY_LABEL, node, nextmenu + dir, (WINDOW *)NULL, dir, 0);
    }

  /* If there is both a next menu entry, and a next xref entry, choose the
     one which occurs first.  Otherwise, select the one which actually
     appears in this node following point. */
  if (nextmenu != -1 && nextxref != -1)
    {
      if (((dir == 1) && (nextmenu < nextxref)) ||
          ((dir == -1) && (nextmenu > nextxref)))
        placement = nextmenu + 1;
      else
        placement = nextxref;
    }
  else if (nextmenu != -1)
    placement = nextmenu + 1;
  else if (nextxref != -1)
    placement = nextxref;

  /* If there was neither a menu or xref entry appearing in this node after
     point, choose the first menu or xref entry appearing in this node. */
  if (placement == -1)
    {
      if (firstmenu != -1 && firstxref != -1)
        {
          if (((dir == 1) && (firstmenu < firstxref)) ||
              ((dir == -1) && (firstmenu > firstxref)))
            placement = firstmenu + 1;
          else
            placement = firstxref;
        }
      else if (firstmenu != -1)
        placement = firstmenu + 1;
      else
        placement = firstxref;
    }
  window->point = placement;
  window_adjust_pagetop (window);
  window->flags |= W_UpdateWindow;
}

DECLARE_INFO_COMMAND (info_move_to_prev_xref,
                      _("Move to the previous cross reference"))
{
  if (count < 0)
    info_move_to_prev_xref (window, -count, key);
  else
    info_move_to_xref (window, count, key, -1);
}

DECLARE_INFO_COMMAND (info_move_to_next_xref,
                      _("Move to the next cross reference"))
{
  if (count < 0)
    info_move_to_next_xref (window, -count, key);
  else
    info_move_to_xref (window, count, key, 1);
}

/* Select the menu item or reference that appears on this line. */
DECLARE_INFO_COMMAND (info_select_reference_this_line,
                      _("Select reference or menu item appearing on this line"))
{
  char *line;

  if (window->line_starts)
    line = window->line_starts[window_line_of_point (window)];
  else
    line = "";

  /* If this line contains a menu item, select that one. */
  if (strncmp ("* ", line, 2) == 0)
    info_menu_or_ref_item (window, count, key, info_menu_of_node, 0);
  else
    info_menu_or_ref_item (window, count, key, info_xrefs_of_node, 0);
}

/* **************************************************************** */
/*                                                                  */
/*                  Miscellaneous Info Commands                     */
/*                                                                  */
/* **************************************************************** */

/* What to do when C-g is pressed in a window. */
DECLARE_INFO_COMMAND (info_abort_key, _("Cancel current operation"))
{
  /* If error printing doesn't oridinarily ring the bell, do it now,
     since C-g always rings the bell.  Otherwise, let the error printer
     do it. */
  if (!info_error_rings_bell_p)
    terminal_ring_bell ();
  info_error ((char *) _("Quit"), NULL, NULL);

  info_initialize_numeric_arg ();
  info_clear_pending_input ();
  info_last_executed_command = (VFunction *)NULL;
}

/* Move the cursor to the desired line of the window. */
DECLARE_INFO_COMMAND (info_move_to_window_line,
   _("Move the cursor to a specific line of the window"))
{
  int line;

  /* With no numeric argument of any kind, default to the center line. */
  if (!info_explicit_arg && count == 1)
    line = (window->height / 2) + window->pagetop;
  else
    {
      if (count < 0)
        line = (window->height + count) + window->pagetop;
      else
        line = window->pagetop + count;
    }

  /* If the line doesn't appear in this window, make it do so. */
  if ((line - window->pagetop) >= window->height)
    line = window->pagetop + (window->height - 1);

  /* If the line is too small, make it fit. */
  if (line < window->pagetop)
    line = window->pagetop;

  /* If the selected line is past the bottom of the node, force it back. */
  if (line >= window->line_count)
    line = window->line_count - 1;

  window->point = (window->line_starts[line] - window->node->contents);
}

/* Clear the screen and redraw its contents.  Given a numeric argument,
   move the line the cursor is on to the COUNT'th line of the window. */
DECLARE_INFO_COMMAND (info_redraw_display, _("Redraw the display"))
{
  if ((!info_explicit_arg && count == 1) || echo_area_is_active)
    {
      terminal_clear_screen ();
      display_clear_display (the_display);
      window_mark_chain (windows, W_UpdateWindow);
      display_update_display (windows);
    }
  else
    {
      int desired_line, point_line;
      int new_pagetop;

      point_line = window_line_of_point (window) - window->pagetop;

      if (count < 0)
        desired_line = window->height + count;
      else
        desired_line = count;

      if (desired_line < 0)
        desired_line = 0;

      if (desired_line >= window->height)
        desired_line = window->height - 1;

      if (desired_line == point_line)
        return;

      new_pagetop = window->pagetop + (point_line - desired_line);

      set_window_pagetop (window, new_pagetop);
    }
}
/* This command does nothing.  It is the fact that a key is bound to it
   that has meaning.  See the code at the top of info_session (). */
DECLARE_INFO_COMMAND (info_quit, _("Quit using Info"))
{}


/* **************************************************************** */
/*                                                                  */
/*               Reading Keys and Dispatching on Them               */
/*                                                                  */
/* **************************************************************** */

/* Declaration only.  Special cased in info_dispatch_on_key ().
   Doc string is to avoid ugly results with describe_key etc.  */
DECLARE_INFO_COMMAND (info_do_lowercase_version,
		      _("Run command bound to this key's lowercase variant"))
{}

static void
dispatch_error (char *keyseq)
{
  char *rep;

  rep = pretty_keyseq (keyseq);

  if (!echo_area_is_active)
    info_error ((char *) _("Unknown command (%s)."), rep, NULL);
  else
    {
      char *temp = xmalloc (1 + strlen (rep) + strlen (_("\"%s\" is invalid")));
      sprintf (temp, _("`%s' is invalid"), rep);
      terminal_ring_bell ();
      inform_in_echo_area (temp);
      free (temp);
    }
}

/* Keeping track of key sequences. */
static char *info_keyseq = (char *)NULL;
static int info_keyseq_index = 0;
static int info_keyseq_size = 0;
static int info_keyseq_displayed_p = 0;

/* Initialize the length of the current key sequence. */
void
initialize_keyseq (void)
{
  info_keyseq_index = 0;
  info_keyseq_displayed_p = 0;
}

/* Add CHARACTER to the current key sequence. */
void
add_char_to_keyseq (char character)
{
  if (info_keyseq_index + 2 >= info_keyseq_size)
    info_keyseq = (char *)xrealloc (info_keyseq, info_keyseq_size += 10);

  info_keyseq[info_keyseq_index++] = character;
  info_keyseq[info_keyseq_index] = '\0';
}

/* Display the current value of info_keyseq.  If argument EXPECTING is
   non-zero, input is expected to be read after the key sequence is
   displayed, so add an additional prompting character to the sequence. */
static void
display_info_keyseq (int expecting_future_input)
{
  char *rep;

  rep = pretty_keyseq (info_keyseq);
  if (expecting_future_input)
    strcat (rep, "-");

  if (echo_area_is_active)
    inform_in_echo_area (rep);
  else
    {
      window_message_in_echo_area (rep, NULL, NULL);
      display_cursor_at_point (active_window);
    }
  info_keyseq_displayed_p = 1;
}

/* Called by interactive commands to read a keystroke. */
unsigned char
info_get_another_input_char (void)
{
  int ready = !info_keyseq_displayed_p; /* ready if new and pending key */

  /* If there isn't any input currently available, then wait a
     moment looking for input.  If we don't get it fast enough,
     prompt a little bit with the current key sequence. */
  if (!info_keyseq_displayed_p)
    {
      ready = 1;
      if (!info_any_buffered_input_p () &&
          !info_input_pending_p ())
        {
#if defined (FD_SET)
          struct timeval timer;
          fd_set readfds;

          FD_ZERO (&readfds);
          FD_SET (fileno (info_input_stream), &readfds);
          timer.tv_sec = 1;
          timer.tv_usec = 750;
          ready = select (fileno(info_input_stream)+1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
#else
          ready = 0;
#endif /* FD_SET */
      }
    }

  if (!ready)
    display_info_keyseq (1);

  return (info_get_input_char ());
}

/* Do the command associated with KEY in MAP.  If the associated command is
   really a keymap, then read another key, and dispatch into that map. */
void
info_dispatch_on_key (unsigned char key, Keymap map)
{
#if !defined(INFOKEY)
  if (Meta_p (key) && (!ISO_Latin_p || map[key].function != ea_insert))
    {
      if (map[ESC].type == ISKMAP)
        {
          map = (Keymap)map[ESC].function;
          add_char_to_keyseq (ESC);
          key = UnMeta (key);
          info_dispatch_on_key (key, map);
        }
      else
        {
          dispatch_error (info_keyseq);
        }
      return;
    }
#endif /* INFOKEY */

  switch (map[key].type)
    {
    case ISFUNC:
      {
        VFunction *func;

        func = InfoFunction(map[key].function);
        if (func != (VFunction *)NULL)
          {
            /* Special case info_do_lowercase_version (). */
            if (func == (VFunction *) info_do_lowercase_version)
              {
#if defined(INFOKEY)
		unsigned char lowerkey;

		lowerkey = Meta_p(key) ? Meta (tolower (UnMeta (key))) : tolower (key);
		if (lowerkey == key)
		  {
		    add_char_to_keyseq (key);
		    dispatch_error (info_keyseq);
		    return;
		  }
                info_dispatch_on_key (lowerkey, map);
#else /* !INFOKEY */
                info_dispatch_on_key (tolower (key), map);
#endif /* INFOKEY */
                return;
              }

            add_char_to_keyseq (key);

            if (info_keyseq_displayed_p)
              display_info_keyseq (0);

            {
              WINDOW *where;

              where = active_window;
              (*InfoFunction(map[key].function))
                (active_window, info_numeric_arg * info_numeric_arg_sign, key);

              /* If we have input pending, then the last command was a prefix
                 command.  Don't change the value of the last function vars.
                 Otherwise, remember the last command executed in the var
                 appropriate to the window in which it was executed. */
              if (!info_input_pending_p ())
                {
                  if (where == the_echo_area)
                    ea_last_executed_command = InfoFunction(map[key].function);
                  else
                    info_last_executed_command = InfoFunction(map[key].function);
                }
            }
          }
        else
          {
            add_char_to_keyseq (key);
            dispatch_error (info_keyseq);
            return;
          }
      }
      break;

    case ISKMAP:
      add_char_to_keyseq (key);
      if (map[key].function != (InfoCommand *)NULL)
        {
          unsigned char newkey;

          newkey = info_get_another_input_char ();
          info_dispatch_on_key (newkey, (Keymap)map[key].function);
        }
      else
        {
          dispatch_error (info_keyseq);
          return;
        }
      break;
    }
}

/* **************************************************************** */
/*                                                                  */
/*                      Numeric Arguments                           */
/*                                                                  */
/* **************************************************************** */

/* Handle C-u style numeric args, as well as M--, and M-digits. */

/* Non-zero means that an explicit argument has been passed to this
   command, as in C-u C-v. */
int info_explicit_arg = 0;

/* The sign of the numeric argument. */
int info_numeric_arg_sign = 1;

/* The value of the argument itself. */
int info_numeric_arg = 1;

/* Add the current digit to the argument in progress. */
DECLARE_INFO_COMMAND (info_add_digit_to_numeric_arg,
                      _("Add this digit to the current numeric argument"))
{
  info_numeric_arg_digit_loop (window, 0, key);
}

/* C-u, universal argument.  Multiply the current argument by 4.
   Read a key.  If the key has nothing to do with arguments, then
   dispatch on it.  If the key is the abort character then abort. */
DECLARE_INFO_COMMAND (info_universal_argument,
                      _("Start (or multiply by 4) the current numeric argument"))
{
  info_numeric_arg *= 4;
  info_numeric_arg_digit_loop (window, 0, 0);
}

/* Create a default argument. */
void
info_initialize_numeric_arg (void)
{
  info_numeric_arg = info_numeric_arg_sign = 1;
  info_explicit_arg = 0;
}

DECLARE_INFO_COMMAND (info_numeric_arg_digit_loop,
                      _("Internally used by \\[universal-argument]"))
{
  unsigned char pure_key;
  Keymap keymap = window->keymap;

  while (1)
    {
      if (key)
        pure_key = key;
      else
        {
          if (display_was_interrupted_p && !info_any_buffered_input_p ())
            display_update_display (windows);

          if (active_window != the_echo_area)
            display_cursor_at_point (active_window);

          pure_key = key = info_get_another_input_char ();

#if !defined(INFOKEY)
          if (Meta_p (key))
            add_char_to_keyseq (ESC);

          add_char_to_keyseq (UnMeta (key));
#else /* defined(INFOKEY) */
          add_char_to_keyseq (key);
#endif /* defined(INFOKEY) */
        }

#if !defined(INFOKEY)
      if (Meta_p (key))
        key = UnMeta (key);
#endif /* !defined(INFOKEY) */

      if (keymap[key].type == ISFUNC
          && InfoFunction(keymap[key].function)
              == (VFunction *) info_universal_argument)
        {
          info_numeric_arg *= 4;
          key = 0;
          continue;
        }

#if defined(INFOKEY)
      if (Meta_p (key))
        key = UnMeta (key);
#endif /* !defined(INFOKEY) */


      if (isdigit (key))
        {
          if (info_explicit_arg)
            info_numeric_arg = (info_numeric_arg * 10) + (key - '0');
          else
            info_numeric_arg = (key - '0');
          info_explicit_arg = 1;
        }
      else
        {
          if (key == '-' && !info_explicit_arg)
            {
              info_numeric_arg_sign = -1;
              info_numeric_arg = 1;
            }
          else
            {
              info_keyseq_index--;
              info_dispatch_on_key (pure_key, keymap);
              return;
            }
        }
      key = 0;
    }
}

/* **************************************************************** */
/*                                                                  */
/*                      Input Character Buffering                   */
/*                                                                  */
/* **************************************************************** */

/* Character waiting to be read next. */
static int pending_input_character = 0;

/* How to make there be no pending input. */
static void
info_clear_pending_input (void)
{
  pending_input_character = 0;
}

/* How to set the pending input character. */
static void
info_set_pending_input (unsigned char key)
{
  pending_input_character = key;
}

/* How to see if there is any pending input. */
unsigned char
info_input_pending_p (void)
{
  return (pending_input_character);
}

/* Largest number of characters that we can read in advance. */
#define MAX_INFO_INPUT_BUFFERING 512

static int pop_index = 0, push_index = 0;
static unsigned char info_input_buffer[MAX_INFO_INPUT_BUFFERING];

/* Add KEY to the buffer of characters to be read. */
static void
info_push_typeahead (unsigned char key)
{
  /* Flush all pending input in the case of C-g pressed. */
  if (key == Control ('g'))
    {
      push_index = pop_index;
      info_set_pending_input (Control ('g'));
    }
  else
    {
      info_input_buffer[push_index++] = key;
      if ((unsigned int) push_index >= sizeof (info_input_buffer))
        push_index = 0;
    }
}

/* Return the amount of space available in INFO_INPUT_BUFFER for new chars. */
static int
info_input_buffer_space_available (void)
{
  if (pop_index > push_index)
    return (pop_index - push_index);
  else
    return (sizeof (info_input_buffer) - (push_index - pop_index));
}

/* Get a key from the buffer of characters to be read.
   Return the key in KEY.
   Result is non-zero if there was a key, or 0 if there wasn't. */
static int
info_get_key_from_typeahead (unsigned char *key)
{
  if (push_index == pop_index)
    return (0);

  *key = info_input_buffer[pop_index++];

  if ((unsigned int) pop_index >= sizeof (info_input_buffer))
    pop_index = 0;

  return (1);
}

int
info_any_buffered_input_p (void)
{
  info_gather_typeahead ();
  return (push_index != pop_index);
}

/* If characters are available to be read, then read them and stuff them into
   info_input_buffer.  Otherwise, do nothing. */
void
info_gather_typeahead (void)
{
  register int i = 0;
  int tty, space_avail;
  long chars_avail;
  unsigned char input[MAX_INFO_INPUT_BUFFERING];

  tty = fileno (info_input_stream);
  chars_avail = 0;

  space_avail = info_input_buffer_space_available ();

  /* If we can just find out how many characters there are to read, do so. */
#if defined (FIONREAD)
  {
    ioctl (tty, FIONREAD, &chars_avail);

    if (chars_avail > space_avail)
      chars_avail = space_avail;

    if (chars_avail)
      chars_avail = read (tty, &input[0], chars_avail);
  }
#else /* !FIONREAD */
#  if defined (O_NDELAY)
  {
    int flags;

    flags = fcntl (tty, F_GETFL, 0);

    fcntl (tty, F_SETFL, (flags | O_NDELAY));
      chars_avail = read (tty, &input[0], space_avail);
    fcntl (tty, F_SETFL, flags);

    if (chars_avail == -1)
      chars_avail = 0;
  }
#  else  /* !O_NDELAY */
#   ifdef __DJGPP__
  {
    extern long pc_term_chars_avail (void);

    if (isatty (tty))
      chars_avail = pc_term_chars_avail ();
    else
      {
	/* We could be more accurate by calling ltell, but we have no idea
	   whether tty is buffered by stdio functions, and if so, how many
	   characters are already waiting in the buffer.  So we punt.  */
	struct stat st;

	if (fstat (tty, &st) < 0)
	  chars_avail = 1;
	else
	  chars_avail = st.st_size;
      }
    if (chars_avail > space_avail)
      chars_avail = space_avail;
    if (chars_avail)
      chars_avail = read (tty, &input[0], chars_avail);
  }
#   endif/* __DJGPP__ */
#  endif /* O_NDELAY */
#endif /* !FIONREAD */

  while (i < chars_avail)
    {
      info_push_typeahead (input[i]);
      i++;
    }
}

/* How to read a single character. */
unsigned char
info_get_input_char (void)
{
  unsigned char keystroke;

  info_gather_typeahead ();

  if (pending_input_character)
    {
      keystroke = pending_input_character;
      pending_input_character = 0;
    }
  else if (info_get_key_from_typeahead (&keystroke) == 0)
    {
      int rawkey;
      unsigned char c;
      int tty = fileno (info_input_stream);

      /* Using stream I/O causes FIONREAD etc to fail to work
         so unless someone can find a portable way of finding
         out how many characters are currently buffered, we
         should stay with away from stream I/O.
         --Egil Kvaleberg <egilk@@sn.no>, January 1997.  */
#ifdef EINTR
      /* Keep reading if we got EINTR, so that we don't just exit.
         --Andreas Schwab <schwab@@issan.informatik.uni-dortmund.de>,
         22 Dec 1997.  */
      {
        int n;
        do
	  n = read (tty, &c, 1);
        while (n == -1 && errno == EINTR);
        rawkey = n == 1 ? c : EOF;
      }
#else
      rawkey = (read (tty, &c, 1) == 1) ? c : EOF;
#endif

      keystroke = rawkey;

      if (rawkey == EOF)
        {
          if (info_input_stream != stdin)
            {
              fclose (info_input_stream);
              info_input_stream = stdin;
	      tty = fileno (info_input_stream);
              display_inhibited = 0;
              display_update_display (windows);
              display_cursor_at_point (active_window);
              rawkey = (read (tty, &c, 1) == 1) ? c : EOF;
              keystroke = rawkey;
            }

          if (rawkey == EOF)
            {
              terminal_unprep_terminal ();
              close_dribble_file ();
              xexit (0);
            }
        }
    }

  if (info_dribble_file)
    dribble (keystroke);

  return keystroke;
}
@


1.5
log
@brain-dead cvs conflict merge
@
text
@d2 1
a2 1
   $Id: session.c,v 1.45 2002/03/02 15:05:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02
d21 1
a21 1
   Written by Brian Fox (bfox@@ai.mit.edu). */
d24 1
d36 5
a40 8
#ifdef M_XENIX
/* SCO 3.2v5.0.2 defines but does not correctly declare strncasecmp.
   Since we use it as a symbol, have to get it right.  --gildea, 1jul99.  */
extern int strncasecmp (const char *, const char *, size_t);
#endif

static void info_clear_pending_input (), info_set_pending_input ();
static void info_handle_pointer ();
d67 3
a69 3
void remember_window_and_node (), forget_window_and_nodes ();
void initialize_info_session (), info_session ();
void display_startup_message_and_start ();
d75 1
a75 3
begin_multiple_window_info_session (filename, nodenames)
     char *filename;
     char **nodenames;
d113 1
a113 1
              info_error (msg_cant_find_window);
d128 1
a128 1
              info_error (msg_win_too_small);
d140 2
a141 5
begin_info_session_with_error (initial_node, format, arg1, arg2)
     NODE *initial_node;
     char *format;
     void *arg1;
     void *arg2;
d150 1
a150 2
begin_info_session (initial_node)
     NODE *initial_node;
d157 1
a157 1
display_startup_message_and_start ()
d162 2
a163 1
    (_("Welcome to Info version %s. Type \\[get-help-window] for help, \\[menu-item] for menu item."));
d165 1
a165 1
  window_message_in_echo_area (format, VERSION);
d171 1
a171 1
info_session ()
d188 1
a188 1
info_read_and_dispatch ()
d196 1
a196 1
      int lk;
d200 2
a201 2
      if ((info_last_executed_command != info_next_line) &&
          (info_last_executed_command != info_prev_line))
d238 1
a238 1
          if (ea_last_executed_command == ea_newline ||
d245 1
a245 1
          if (info_last_executed_command == info_quit)
d248 1
a248 1
      else if (info_last_executed_command == info_quit)
d254 1
a254 1
extern void initialize_info_signal_handler ();
d259 1
a259 3
initialize_info_session (node, clear_screen)
     NODE *node;
     int clear_screen;
d269 1
a269 1
      info_error (msg_term_too_dumb, term_name);
d287 1
a287 1
  window_deletion_notifier = forget_window_and_nodes;
d302 1
a302 2
info_set_input_from_file (filename)
     char *filename;
d324 1
a324 2
get_info_window_of_window (window)
     WINDOW *window;
d340 1
a340 2
set_remembered_pagetop_and_point (window)
     WINDOW *window;
d358 1
a358 3
remember_window_and_node (window, node)
     WINDOW *window;
     NODE *node;
d417 1
a417 1
consistency_check_info_windows ()
d437 1
a437 2
forget_window_and_nodes (window)
     WINDOW *window;
d484 1
a484 4
info_set_node_of_window (remember, window, node)
     int remember;
     WINDOW *window;
     NODE *node;
d511 1
a511 3
set_window_pagetop (window, desired_top)
     WINDOW *window;
     int desired_top;
d574 1
a574 2
info_show_point (window)
     WINDOW *window;
d597 1
a597 3
move_to_new_line (old, new, window)
     int old, new;
     WINDOW *window;
d601 1
a601 1
      info_error (msg_cant_find_point);
d849 1
a849 3
forward_move_node_structure (window, behaviour)
     WINDOW *window;
     int behaviour;
d854 1
a854 1
      info_error (msg_at_node_bottom);
d860 1
a860 1
        info_error (msg_no_pointer, _("Next"));
d863 2
a864 1
          window_message_in_echo_area (_("Following Next node..."));
d881 2
a882 1
              window_message_in_echo_area (_("Selecting first menu item..."));
d893 2
a894 1
            window_message_in_echo_area (_("Selecting Next node..."));
d964 2
a965 2
                    (_("Moving Up %d time(s), then Next."),
                     up_counter);
d988 2
a989 1
                  info_error (_("No more nodes within this document."));
d1000 1
a1000 3
backward_move_node_structure (window, behaviour)
     WINDOW *window;
     int behaviour;
d1005 1
a1005 1
      info_error (msg_at_node_top);
d1011 1
a1011 1
        info_error (_("No `Prev' for this node."));
d1014 2
a1015 1
          window_message_in_echo_area (_("Moving Prev in this window."));
d1029 3
a1031 1
            info_error (_("No `Prev' or `Up' for this node within this document."));
d1034 2
a1035 1
              window_message_in_echo_area (_("Moving Up in this window."));
d1073 2
a1074 1
          window_message_in_echo_area (_("Moving Prev in this window."));
d1084 1
a1084 1
                    (_("Moving to `Prev's last menu item."));
d1125 4
a1128 2
static void _scroll_forward();
static void _scroll_backward();
d1131 1
a1131 5
_scroll_forward(window, count, key, behaviour)
  WINDOW *window;
  int count;
  unsigned char key;
  int behaviour;
d1171 1
a1171 5
_scroll_backward(window, count, key, behaviour)
  WINDOW *window;
  int count;
  unsigned char key;
  int behaviour;
d1385 1
a1385 1
      info_error (msg_one_window);
d1425 1
a1425 1
      info_error (msg_one_window);
d1436 1
a1436 1
          register WINDOW *win, *last;
d1481 1
a1481 1
      info_error (msg_win_too_small);
d1549 1
a1549 1
      info_error (msg_cant_kill_last);
d1553 1
a1553 1
      info_error (_("Cannot delete a permanent window"));
d1570 1
a1570 2
info_delete_window_internal (window)
     WINDOW *window;
d1638 1
a1638 1
      info_error (msg_one_window);
d1690 1
a1690 2
node_printed_rep (node)
     NODE *node;
d1711 1
a1711 3
info_select_reference (window, entry)
     WINDOW *window;
     REFERENCE *entry;
d1756 1
a1756 1
        info_error (file_system_error);
d1758 1
a1758 1
        info_error (msg_cant_find_node, nodename);
d1773 1
a1773 3
info_parse_and_select (line, window)
     char *line;
     WINDOW *window;
d1791 1
a1791 3
info_handle_pointer (label, window)
     char *label;
     WINDOW *window;
d1832 1
a1832 1
            info_error (info_recent_file_error);
d1834 1
a1834 1
            info_error (msg_cant_file_node, filename, nodename);
d1842 1
a1842 1
      info_error (msg_no_pointer, label);
d1898 1
a1898 1
    info_error (_("This window has no additional nodes"));
d1931 1
a1931 1
    info_error (_("This window has no additional nodes"));
d1947 1
a1947 1
  register REFERENCE *entry, **menu;
d1953 1
a1953 1
      info_error (msg_no_menu_node);
d1965 1
a1965 1
      for (i = 0; (entry = menu[i]); i++)
d1971 5
a1975 1
    info_select_reference (window, menu[i]);
d1977 2
a1978 1
    info_error (_("There aren't %d items in this menu."), item);
d1984 65
d2055 2
a2056 6
info_menu_or_ref_item (window, count, key, builder, ask_p)
     WINDOW *window;
     int count;
     unsigned char key;
     REFERENCE **(*builder) ();
     int ask_p;
a2057 1
  REFERENCE **menu, *entry, *defentry = (REFERENCE *)NULL;
d2059 3
a2061 2

  menu = (*builder) (window->node);
d2066 1
a2066 1
        info_error (msg_no_menu_node);
d2068 1
a2068 1
        info_error (msg_no_xref_node);
d2075 2
a2076 4
    REFERENCE **refs = (REFERENCE **)NULL;
    int point_line;

    point_line = window_line_of_point (window);
d2105 1
a2105 13
	    {
	      refs = info_xrefs (&binding);
	      if (!refs && point_line > 0)
		{
		  /* People get annoyed that Info cannot find an xref
		     which starts on a previous line and ends on this
		     one.  So if we fail to find a reference on this
		     line, let's try the one before.  */
		  binding.start =
		    window->line_starts[point_line - 1] - binding.buffer;
		  refs = info_xrefs (&binding);
		}
	    }
d2108 1
a2108 1
        if (refs)
d2110 2
a2111 2
            if ((strcmp (refs[0]->label, "Menu") != 0) ||
                (builder == info_xrefs_of_node))
d2115 6
a2120 2
                /* Find the closest reference to point. */
                if (builder == info_xrefs_of_node)
d2126 2
a2127 2
                        if ((window->point >= refs[which]->start) &&
                            (window->point <= refs[which]->end))
d2133 1
a2133 3
                          {
                            break;
                          }
d2135 7
a2141 4
                    if (closest == -1)
                      which--;
                    else
                      which = closest;
d2150 1
a2167 5
      if (defentry)
        prompt = (char *)xmalloc (20 + strlen (defentry->label));
      else
        prompt = (char *)xmalloc (20);

d2171 5
a2175 1
            sprintf (prompt, _("Menu item (%s): "), defentry->label);
d2177 1
a2177 1
            sprintf (prompt, _("Menu item: "));
d2182 5
a2186 1
            sprintf (prompt, _("Follow xref (%s): "), defentry->label);
d2188 1
a2188 1
            sprintf (prompt, _("Follow xref: "));
d2266 1
a2266 1
        info_error (_("The reference disappeared! (%s)."), line);
d2271 1
d2292 5
d2344 1
a2344 1
    info_error (msg_no_menu_node);
d2363 1
a2363 1
    info_error (msg_no_menu_node);
d2373 1
a2373 1
        info_error (msg_win_too_small);
d2438 2
a2439 1
    line = info_read_maybe_completing (window, _("Goto node: "), items);
d2443 1
a2443 1
  line = info_read_in_echo_area (window, _("Goto node: "));
d2471 2
a2472 4
info_follow_menus (initial_node, menus, errstr, errarg1, errarg2)
     NODE *initial_node;
     char **menus;
     char **errstr, **errarg1, **errarg2;
d2527 2
a2528 1
                if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
d2606 1
a2606 2
split_list_of_nodenames (str)
     char *str;
d2635 1
a2635 1
  char *line = info_read_in_echo_area (window, _("Follow menus: "));
d2648 2
a2649 1
      char *errstr, *errarg1, *errarg2;
d2652 1
a2652 1
      NODE *node;
d2668 1
a2668 1
	info_error (msg_cant_find_node, "Top");
d2670 1
a2670 2
	node
	  = info_follow_menus (dir_node, nodes, &errstr, &errarg1, &errarg2);
d2676 1
a2676 1
        info_error (errstr, errarg1, errarg2);
d2689 1
a2689 4
entry_in_menu (arg, menu, exact)
     char *arg;
     REFERENCE **menu;
     int exact;
d2723 1
a2723 4
info_intuit_options_node (window, initial_node, program)
     WINDOW *window;
     NODE *initial_node;
     char *program;
d2758 1
a2758 1
      REFERENCE *entry;
d2771 1
a2771 1
	  char nodename[200];
d2773 1
d2779 1
d2807 1
a2807 2
program_name_from_file_name (file_name)
     char *file_name;
d2830 1
a2830 1
  char *invocation_prompt = _("Find Invocation node of [%s]: ");
d2848 1
a2848 1
      info_abort_key ();
d2860 1
a2860 1
    info_error (msg_cant_find_node, "Top");
d2872 1
a2872 1
  line = info_read_in_echo_area (window, _("Get Manpage: "));
d2917 1
a2917 2
read_nodename_to_kill (window)
     WINDOW *window;
d2925 1
a2925 1
  char *prompt = xmalloc (40 + strlen (default_nodename));
d2957 1
a2957 3
kill_node (window, nodename)
     WINDOW *window;
     char *nodename;
d2979 1
a2979 1
        info_error (_("Cannot kill node `%s'"), nodename);
d2989 1
a2989 1
      info_error (_("Cannot kill the last node"));
d3093 1
a3093 1
  line = info_read_in_echo_area (window, _("Find file: "));
d3108 1
a3108 1
            info_error (info_recent_file_error);
d3110 1
a3110 1
            info_error (_("Cannot find `%s'."), line);
d3129 4
a3132 3
static void write_node_to_stream ();
static void dump_node_to_stream ();
static void initialize_dumping ();
d3138 2
a3139 5
dump_nodes_to_file (filename, nodenames, output_filename, dump_subnodes)
     char *filename;
     char **nodenames;
     char *output_filename;
     int dump_subnodes;
d3153 2
a3154 1
      info_error (_("Could not create output file `%s'."), output_filename);
d3167 1
a3167 1
  info_error (_("Done."));
d3177 1
a3177 1
initialize_dumping ()
d3186 2
a3187 4
dump_node_to_stream (filename, nodename, stream, dump_subnodes)
     char *filename, *nodename;
     FILE *stream;
     int dump_subnodes;
d3197 1
a3197 1
        info_error (info_recent_file_error);
d3201 3
a3203 2
            info_error (msg_cant_file_node, filename_non_directory (filename),
                        nodename);
d3205 1
a3205 1
            info_error (msg_cant_find_node, nodename);
d3222 1
a3222 1
  info_error (_("Writing node %s..."), node_printed_rep (node));
d3257 1
a3257 4
dump_node_to_file (node, filename, dump_subnodes)
     NODE *node;
     char *filename;
     int dump_subnodes;
d3271 2
a3272 1
      info_error (_("Could not create output file `%s'."), filename);
d3289 1
a3289 1
  info_error (_("Done."));
d3305 1
a3305 2
print_node (node)
     NODE *node;
d3333 1
a3333 1
      info_error (_("Cannot open pipe to `%s'."), print_command);
d3339 1
a3339 1
  info_error (_("Printing node %s..."), node_printed_rep (node));
d3349 1
a3349 1
  info_error (_("Done."));
d3354 1
a3354 3
write_node_to_stream (node, stream)
     NODE *node;
     FILE *stream;
d3371 3
a3373 2
static void info_gc_file_buffers ();
static void info_search_1 ();
a3375 1
static int search_string_index = 0;
d3384 1
a3384 2
file_buffer_of_window (window)
     WINDOW *window;
d3406 2
a3407 6
info_search_in_node (string, node, start, window, dir, case_sensitive)
     char *string;
     NODE *node;
     long start;
     WINDOW *window;
     int dir, case_sensitive;
d3449 1
a3449 4
info_target_search_node (node, string, start)
     NODE *node;
     char *string;
     long start;
d3452 1
a3452 1
  long offset;
d3481 2
a3482 4
info_search_internal (string, window, dir, case_sensitive)
     char *string;
     WINDOW *window;
     int dir, case_sensitive;
d3519 1
a3519 1
      register int current_tag, number_of_tags;
d3569 2
a3570 2
                (_("Searching subfile %s ..."),
                 filename_non_directory (tag->filename));
d3583 1
a3583 1
                    info_error (info_recent_file_error);
d3585 1
a3585 1
                    info_error (msg_cant_file_node,
d3644 2
a3645 6
info_search_1 (window, count, key, case_sensitive, ask_for_string)
     WINDOW *window;
     int count;
     unsigned char key;
     int case_sensitive;
     int ask_for_string;
d3672 6
a3677 1
      prompt = (char *)xmalloc (50 + strlen (search_string));
d3689 1
a3689 1
          info_abort_key ();
d3695 1
a3695 1
          if (strlen (line) + 1 > search_string_size)
a3699 1
          search_string_index = strlen (line);
d3720 1
a3720 1
    info_error (_("Search failed."));
d3741 1
a3741 1
    info_error (_("No previous search string"));
d3751 1
a3751 1
    info_error (_("No previous search string"));
d3763 2
a3764 1
static void incremental_search ();
a3787 8
/* Structure defining the current state of an incremental search. */
typedef struct {
  WINDOW_STATE_DECL;    /* The node, pagetop and point. */
  int search_index;     /* Offset of the last char in the search string. */
  int direction;        /* The direction that this search is heading in. */
  int failing;          /* Whether or not this search failed. */
} SEARCH_STATE;

d3795 1
a3795 3
push_isearch (window, search_index, direction, failing)
     WINDOW *window;
     int search_index, direction, failing;
d3811 1
a3811 3
pop_isearch (window, search_index, direction, failing)
     WINDOW *window;
     int *search_index, *direction, *failing;
d3831 1
a3831 1
free_isearch_states ()
d3845 1
a3845 4
show_isearch_prompt (dir, string, failing_p)
     int dir;
     unsigned char *string;
     int failing_p;
d3848 3
a3850 2
  char *prefix, *prompt, *p_rep;
  int prompt_len, p_rep_index, p_rep_size;
d3878 4
a3881 2
  prompt_len = strlen (prefix) + p_rep_index + 20;
  prompt = (char *)xmalloc (prompt_len);
d3885 1
a3885 1
  window_message_in_echo_area ("%s", prompt);
d3892 1
a3892 4
incremental_search (window, count, ignore)
     WINDOW *window;
     int count;
     unsigned char ignore;
d3915 1
a3915 1
  show_isearch_prompt (dir, isearch_string, search_result);
d3936 1
a3936 1
      if (key == DEL)
d3949 2
a3950 1
              show_isearch_prompt (dir, isearch_string, search_result);
d3968 7
a3974 1
          func = InfoFunction(window->keymap[key].function);
d3976 1
a3976 1
          if (isprint (key) || func == (VFunction *)NULL)
d3988 2
a3989 1
          else if (func == isearch_forward || func == isearch_backward)
d3996 2
a3997 2
              if ((func == isearch_forward && dir > 0) ||
                  (func == isearch_backward && dir < 0))
d4006 2
a4007 2
                          if (strlen (last_isearch_accepted) + 1 >=
                              isearch_string_size)
d4033 1
a4033 1
          else if (func == info_abort_key)
d4044 2
a4045 1
                  show_isearch_prompt (dir, isearch_string, search_result);
d4061 1
a4061 1
          if (isearch_string_index && func != info_abort_key)
d4080 1
a4080 1
          if (func == info_abort_key)
d4098 1
a4098 1
      show_isearch_prompt (dir, isearch_string, search_result);
d4140 1
a4140 1
      show_isearch_prompt (dir, isearch_string, search_result);
d4174 1
a4174 1
info_gc_file_buffers ()
d4233 1
a4233 5
info_move_to_xref (window, count, key, dir)
     WINDOW *window;
     int count;
     unsigned char key;
     int dir;
d4275 1
a4275 1
      info_error (msg_no_xref_node);
a4363 1
  NODE *orig;
d4365 4
a4368 2
  line = window->line_starts[window_line_of_point (window)];
  orig = window->node;
d4391 1
a4391 1
  info_error (_("Quit"));
d4486 1
a4486 2
dispatch_error (keyseq)
     char *keyseq;
d4493 1
a4493 1
    info_error (_("Unknown command (%s)."), rep);
d4496 2
a4497 2
      char *temp = xmalloc (1 + strlen (rep) + strlen (_("\"\" is invalid")));
      sprintf (temp, _("\"%s\" is invalid"), rep);
d4512 1
a4512 1
initialize_keyseq ()
d4520 1
a4520 2
add_char_to_keyseq (character)
     char character;
d4532 2
a4533 3
void
display_info_keyseq (expecting_future_input)
     int expecting_future_input;
d4545 1
a4545 1
      window_message_in_echo_area (rep);
d4553 1
a4553 1
info_get_another_input_char ()
d4590 1
a4590 3
info_dispatch_on_key (key, map)
     unsigned char key;
     Keymap map;
d4620 1
a4620 1
            if (func == info_do_lowercase_version)
d4728 1
a4728 1
info_initialize_numeric_arg ()
d4769 3
a4771 2
      if (keymap[key].type == ISFUNC &&
          InfoFunction(keymap[key].function) == info_universal_argument)
d4821 1
a4821 1
info_clear_pending_input ()
d4828 1
a4828 2
info_set_pending_input (key)
     unsigned char key;
d4835 1
a4835 1
info_input_pending_p ()
d4848 1
a4848 2
info_push_typeahead (key)
     unsigned char key;
d4859 1
a4859 1
      if (push_index >= sizeof (info_input_buffer))
d4866 1
a4866 1
info_input_buffer_space_available ()
d4878 1
a4878 2
info_get_key_from_typeahead (key)
     unsigned char *key;
d4885 1
a4885 1
  if (pop_index >= sizeof (info_input_buffer))
d4892 1
a4892 1
info_any_buffered_input_p ()
d4901 1
a4901 1
info_gather_typeahead ()
d4975 1
a4975 1
info_get_input_char ()
@


1.4
log
@Merge conflicts, and a few details:
- Makefile.bsd-wrapper: man pages, disable NLS for now.
- doc/Makefile.in: install man pages manually, remove buggy targets that
would break `make clean'.
- makeinfo/Makefile.in: shell failure ??? rework problematic line.
- util/texindex.c: let maketempname create the file, remove race condition.
@
text
@d2 1
a2 1
   $Id: session.c,v 1.38 1999/09/25 16:10:04 karl Exp $
d4 2
a5 1
   Copyright (C) 1993, 96, 97, 98, 99 Free Software Foundation, Inc.
d1143 9
a1151 2
/* Show the next screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_forward, _("Scroll forward in this window"))
d1154 1
a1154 1
    info_scroll_backward (window, -count, key);
d1161 2
a1162 2
         and the user wishes to scroll through nodes get the "Next" node
         for this window. */
d1170 1
a1170 1
             another node, depending on INFO_SCROLL_BEHAVIOUR. */
a1172 7
              int behaviour = info_scroll_behaviour;

              /* Here is a hack.  If the key being used is not SPC, do the
                 PageOnly behaviour. */
              if (key != SPC && key != DEL)
                behaviour = IS_PageOnly;

d1190 6
a1195 12
/* Like info_scroll_forward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_set_window,
		      _("Scroll forward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  info_scroll_forward (window, count, key);
}

/* Show the previous screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_backward, _("Scroll backward in this window"))
d1198 1
a1198 1
    info_scroll_forward (window, -count, key);
d1204 2
a1205 2
         to the bottom of this window, or move to the previous, or Up'th
         node. */
a1213 8
              int behaviour = info_scroll_behaviour;

              /* Same kind of hack as in info_scroll_forward.  If the key
                 used to invoke this command is not DEL, do only the PageOnly
                 behaviour. */
              if (key != DEL && key != SPC)
                behaviour = IS_PageOnly;

d1228 38
d1273 18
a1290 1
  info_scroll_backward (window, count, key);
d1346 1
a1346 1
    info_scroll_half_screen_up (window -count, key);
d1372 1
a1372 1
    info_scroll_half_screen_down (window -count, key);
d2073 13
a2085 1
            refs = info_xrefs (&binding);
d2119 2
a2120 2
                if (which < 0)
                  which = 0;
d2198 37
a2234 2
      /* Find the selected label in the references. */
      entry = info_get_labeled_reference (line, menu);
d2507 6
a2512 1
              node = make_manpage_node (first_arg);
d3972 9
a3980 1
          func = window->keymap[key].function;
d3982 5
a3986 5
          /* If this key invokes an incremental search, then this means that
             we will either search again in the same direction, search
             again in the reverse direction, or insert the last search
             string that was accepted through incremental searching. */
          if (func == isearch_forward || func == isearch_backward)
d3988 5
a4029 12
          else if (isprint (key) || func == (VFunction *)NULL)
            {
            insert_and_search:

              if (isearch_string_index + 2 >= isearch_string_size)
                isearch_string = (char *)xrealloc
                  (isearch_string, isearch_string_size += 100);

              isearch_string[isearch_string_index++] = key;
              isearch_string[isearch_string_index] = '\0';
              goto search_now;
            }
d4071 3
a4073 2
          if (key != isearch_terminate_search_key ||
	      info_any_buffered_input_p ())
d4478 4
a4481 2
/* Declaration only.  Special cased in info_dispatch_on_key (). */
DECLARE_INFO_COMMAND (info_do_lowercase_version, "")
a4505 1
static char keyseq_rep[100];
a4529 19
/* Return the pretty printable string which represents KEYSEQ. */
char *
pretty_keyseq (keyseq)
     char *keyseq;
{
  register int i;

  keyseq_rep[0] = '\0';

  for (i = 0; keyseq[i]; i++)
    {
      sprintf (keyseq_rep + strlen (keyseq_rep), "%s%s",
               strlen (keyseq_rep) ? " " : "",
               pretty_keyname (keyseq[i]));
    }

  return (keyseq_rep);
}

d4596 1
d4612 1
d4620 1
a4620 1
        func = map[key].function;
d4626 12
d4639 1
d4652 1
a4652 1
              (*map[key].function)
d4662 1
a4662 1
                    ea_last_executed_command = map[key].function;
d4664 1
a4664 1
                    info_last_executed_command = map[key].function;
d4679 1
a4679 1
      if (map[key].function != (VFunction *)NULL)
d4758 1
d4763 3
d4768 1
d4771 1
d4774 1
a4774 1
          keymap[key].function == info_universal_argument)
d4780 6
@


1.3
log
@when following SEE-ALSO in man mode, would SIGSEGV when cursor is at
start of line
@
text
@d1 2
a2 2
/* session.c -- The user windowing interface to Info.
   $Id: session.c,v 1.2 1999/01/11 16:38:09 espie Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97 Free Software Foundation, Inc.
d34 6
d103 1
a103 1
          register WINDOW *win, *largest = (WINDOW *)NULL;
d116 1
a116 1
              info_error (CANT_FIND_WIND);
d118 1
a118 1
              exit (0);
d131 1
a131 1
              info_error (WIN_TOO_SMALL);
d133 1
a133 1
              exit (0);
d143 1
a143 1
begin_info_session_with_error (initial_node, format, arg)
d146 2
a147 1
     void *arg;
d150 1
a150 1
  info_error (format, arg, (void *)NULL);
d169 1
a169 1
    (_("Welcome to Info version %s. \"\\[get-help-window]\" for help, \"\\[menu-item]\" for menu item."));
d171 1
a171 1
  window_message_in_echo_area (format, version_string ());
d277 2
a278 2
      info_error (TERM_TOO_DUMB, term_name);
      exit (1);
d291 1
a291 1
  info_set_node_of_window (active_window, node);
d301 1
a301 1
      setbuf(stdin, NULL); 
d315 2
a316 1
  stream = fopen (filename, "r");
d495 2
a496 1
   the footnotes for this window. */
d498 2
a499 1
info_set_node_of_window (window, node)
d503 3
d623 1
a623 1
      info_error (CANT_FIND_POINT);
d702 1
a702 1
  /* If at a line start alreay, do nothing. */
a842 32
/* Here is a list of time counter names which correspond to ordinal numbers.
   It is used to print "once" instead of "1". */
static char *counter_names[] = {
  "not at all", "once", "twice", "three", "four", "five", "six",
  (char *)NULL
};

/* Buffer used to return values from times_description (). */
static char td_buffer[50];

/* Function returns a static string fully describing the number of times
   present in COUNT. */
static char *
times_description (count)
     int count;
{
  register int i;

  td_buffer[0] = '\0';

  for (i = 0; counter_names[i]; i++)
    if (count == i)
      break;

  if (counter_names[i])
    sprintf (td_buffer, "%s%s", counter_names[i], count > 2 ? _(" times") : "");
  else
    sprintf (td_buffer, _("%d times"), count);

  return (td_buffer);
}

d861 8
d878 1
a878 1
      info_error (AT_NODE_BOTTOM);
d884 1
a884 1
        info_error (_("No \"Next\" pointer for this node."));
d887 2
a888 2
          window_message_in_echo_area (_("Following \"Next\" node..."));
          info_handle_pointer (_("Next"), window);
d913 1
a913 1
        if (info_label_was_found)
d915 2
a916 2
            window_message_in_echo_area (_("Selecting \"Next\" node..."));
            info_handle_pointer (_("Next"), window);
d937 1
a937 1
              if (info_label_was_found)
d939 1
a939 1
                  info_handle_pointer (_("Up"), window);
d948 1
a948 1
                  if (!info_label_was_found)
d985 2
a986 2
                    ("Moving \"Up\" %s, then \"Next\".",
                     times_description (up_counter));
d988 1
a988 1
                  info_handle_pointer (_("Next"), window);
d1009 1
a1009 1
                  info_error (_("No more nodes."));
d1027 1
a1027 1
      info_error (AT_NODE_TOP);
d1033 1
a1033 1
        info_error (_("No \"Prev\" for this node."));
d1036 2
a1037 2
          window_message_in_echo_area (_("Moving \"Prev\" in this window."));
          info_handle_pointer (_("Prev"), window);
d1044 2
a1045 1
      if (!info_parsed_nodename && !info_parsed_filename)
d1048 3
a1050 2
          if (!info_parsed_nodename && !info_parsed_filename)
            info_error (_("No \"Prev\" or \"Up\" for this node."));
d1053 2
a1054 2
              window_message_in_echo_area (_("Moving \"Up\" in this window."));
              info_handle_pointer (_("Up"), window);
d1091 2
a1092 2
          window_message_in_echo_area (_("Moving \"Prev\" in this window."));
          info_handle_pointer (_("Prev"), window);
d1101 1
a1101 1
                    (_("Moving to \"Prev\"'s last menu item."));
d1155 3
a1157 1
      if (!info_explicit_arg && count == 1)
d1189 10
d1211 3
a1213 1
      if (!info_explicit_arg && count == 1)
d1241 10
d1264 84
d1367 1
a1367 1
      info_error (ONE_WINDOW);
d1407 1
a1407 1
      info_error (ONE_WINDOW);
d1463 1
a1463 1
      info_error (WIN_TOO_SMALL);
d1531 1
a1531 1
      info_error (CANT_KILL_LAST);
d1621 1
a1621 1
      info_error (ONE_WINDOW);
d1633 7
d1670 22
d1744 1
a1744 1
        info_error (CANT_FIND_NODE, nodename);
d1752 1
a1752 4
    {
      set_remembered_pagetop_and_point (window);
      info_set_node_of_window (window, node);
    }
d1817 1
a1817 2
          set_remembered_pagetop_and_point (window);
          info_set_node_of_window (window, node);
d1824 1
a1824 1
            info_error (CANT_FILE_NODE, filename, nodename);
d1832 1
a1832 1
      info_error (NO_POINTER, label);
d1838 1
a1838 1
DECLARE_INFO_COMMAND (info_next_node, _("Select the `Next' node"))
d1841 1
a1841 1
  info_handle_pointer (_("Next"), window);
d1846 1
a1846 1
DECLARE_INFO_COMMAND (info_prev_node, _("Select the `Prev' node"))
d1849 1
a1849 1
  info_handle_pointer (_("Prev"), window);
d1854 1
a1854 1
DECLARE_INFO_COMMAND (info_up_node, _("Select the `Up' node"))
d1857 1
a1857 1
  info_handle_pointer (_("Up"), window);
d1869 16
a1884 2
      for (i = 0; fb->tags[i]; i++);
      node = info_get_node (fb->filename, fb->tags[i - 1]->nodename);
d1890 1
a1890 4
    {
      set_remembered_pagetop_and_point (window);
      info_set_node_of_window (window, node);
    }
d1899 4
d1904 15
a1918 1
    node = info_get_node (fb->filename, fb->tags[0]->nodename);
d1923 1
a1923 4
    {
      set_remembered_pagetop_and_point (window);
      info_set_node_of_window (window, node);
    }
d1943 1
a1943 1
      info_error (NO_MENU_NODE);
d1990 1
a1990 1
        info_error (NO_MENU_NODE);
d1992 1
a1992 1
        info_error (NO_XREF_NODE);
d2151 1
a2151 3
          NODE *orig;

          orig = window->node;
d2153 3
a2155 2
          if ((builder == info_xrefs_of_node) && (window->node != orig))
            {
d2220 1
a2220 1
    info_error (NO_MENU_NODE);
d2239 1
a2239 1
    info_error (NO_MENU_NODE);
d2249 1
a2249 1
        info_error (WIN_TOO_SMALL);
d2298 10
a2307 4
                entry->label = (char *) xmalloc
                  (4 + strlen (fb->filename) + strlen (fb->tags[i]->nodename));
                sprintf (entry->label, "(%s)%s",
                         fb->filename, fb->tags[i]->nodename);
a2310 12
              }         

            if (this_is_the_current_fb)
              {
                for (i = 0; fb->tags[i]; i++)
                  {
                    entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                    entry->filename = entry->nodename = (char *)NULL;
                    entry->label = xstrdup (fb->tags[i]->nodename);
                    add_pointer_to_array (entry, items_index, items,
                                          items_slots, 100, REFERENCE *);
                  }
d2314 1
a2314 1
    line = info_read_maybe_completing (window, _("Goto Node: "), items);
d2318 1
a2318 1
  line = info_read_in_echo_area (window, _("Goto Node: "));
d2337 164
d2502 242
d2781 1
a2781 1
  info_parse_and_select (_("Top"), window);
d2842 1
a2842 1
  
d2852 2
a2853 1
    if (strcmp (nodename, info_win->nodes[info_win->current]->nodename) == 0)
d2876 1
a2876 1
    info_win->nodes[i] = info_win->nodes[i++];
d2914 1
a2914 1
        
d2925 1
d2938 1
d2990 1
a2990 1
            info_error (_("Cannot find \"%s\"."), line);
d2993 2
a2994 4
        {
          set_remembered_pagetop_and_point (active_window);
          info_set_node_of_window (window, node);
        }
d3035 1
a3035 1
      info_error (_("Could not create output file \"%s\"."), output_filename);
d3084 2
a3085 2
            info_error
              (CANT_FILE_NODE, filename_non_directory (filename), nodename);
d3087 1
a3087 1
            info_error (CANT_FIND_NODE, nodename);
d3104 1
a3104 5
  if (node->filename)
    info_error (_("Writing node \"(%s)%s\"..."),
                filename_non_directory (node->filename), node->nodename);
  else
    info_error (_("Writing node \"%s\"..."), node->nodename);
d3156 1
a3156 1
      info_error (_("Could not create output file \"%s\"."), filename);
d3194 1
d3199 16
a3214 1
  printer_pipe = popen (print_command, "w");
d3218 1
a3218 1
      info_error (_("Cannot open pipe to \"%s\"."), print_command);
d3224 1
a3224 5
  if (node->filename)
    info_error (_("Printing node \"(%s)%s\"..."),
                filename_non_directory (node->filename), node->nodename);
  else
    info_error (_("Printing node \"%s\"..."), node->nodename);
d3228 4
a3231 1
  pclose (printer_pipe);
d3259 1
d3266 3
d3294 1
a3294 1
info_search_in_node (string, node, start, window, dir)
d3299 1
a3299 1
     int dir;
d3307 3
a3309 1
  binding.flags = S_FoldCase;
d3358 1
a3358 1
      offset = info_search_in_node (target, node, start, (WINDOW *)NULL, 1);
a3374 1
static char *last_searched_for_string = (char *)NULL;
d3376 1
a3376 1
info_search_internal (string, window, dir)
d3379 1
a3379 1
     int dir;
d3389 8
a3396 15
  if ((info_last_executed_command == info_search) &&
      (last_searched_for_string) &&
      (strcmp (last_searched_for_string, string) == 0))
    {
      ret = info_search_in_node
        (string, window->node, window->point + dir, window, dir);
    }
  else
    {
      ret = info_search_in_node
        (string, window->node, window->point, window, dir);
    }

  maybe_free (last_searched_for_string);
  last_searched_for_string = xstrdup (string);
d3445 7
a3451 1
          current_tag += dir;
d3453 4
a3456 4
          if (current_tag < 0)
            current_tag = number_of_tags - 1;
          else if (current_tag == number_of_tags)
            current_tag = 0;
d3458 4
a3461 1
          tag = file_buffer->tags[current_tag];
d3466 1
a3466 1
                (_("Searching subfile \"%s\"..."),
d3482 1
a3482 1
                    info_error (CANT_FILE_NODE,
d3493 2
a3494 1
            info_search_in_node (string, node, start, window, dir);
d3517 8
d3527 21
d3553 4
a3556 1
    direction = -1;
d3558 5
a3562 1
    direction = 1;
d3571 3
a3573 1
  prompt = (char *)xmalloc (50 + strlen (search_string));
d3575 4
a3578 3
  sprintf (prompt, _("%s for string [%s]: "),
           direction < 0 ? _("Search backward") : _("Search"),
           search_string);
d3580 2
a3581 2
  line = info_read_in_echo_area (window, prompt);
  free (prompt);
d3583 5
a3587 5
  if (!line)
    {
      info_abort_key ();
      return;
    }
d3589 5
a3593 5
  if (*line)
    {
      if (strlen (line) + 1 > search_string_size)
        search_string = (char *)
          xrealloc (search_string, (search_string_size += 50 + strlen (line)));
d3595 4
a3598 3
      strcpy (search_string, line);
      search_string_index = strlen (line);
      free (line);
d3601 10
d3612 3
a3614 1
  result = info_search_internal (search_string, active_window, direction);
d3634 20
d3808 2
d3876 1
a3876 1
      if (!Meta_p (key) || (ISO_Latin_p && key < 160))
d3968 10
a3977 1
          if (key != isearch_terminate_search_key)
d4000 10
d4016 2
a4017 1
               (strncasecmp (window->node->contents + window->point,
d4021 2
a4022 1
               (strncasecmp (window->node->contents +
d4030 2
a4031 1
            search_result = info_search_internal (isearch_string, window, dir);
d4107 2
a4108 2
              if ((strcmp (fb->fullpath, iw->nodes[i]->filename) == 0) ||
                  (strcmp (fb->filename, iw->nodes[i]->filename) == 0))
d4153 1
a4153 1
    (INFO_MENU_ENTRY_LABEL, node, start, (WINDOW *)NULL, dir);
d4164 1
a4164 1
          (INFO_MENU_ENTRY_LABEL, node, firstmenu + dir, (WINDOW *)NULL, dir);
d4168 1
a4168 1
    info_search_in_node (INFO_XREF_LABEL, node, start, (WINDOW *)NULL, dir);
d4179 1
a4179 1
      info_error (_("No cross references in this node."));
d4187 1
a4187 1
    (INFO_MENU_ENTRY_LABEL, node, window->point + dir, (WINDOW *)NULL, dir);
d4190 1
a4190 1
    (INFO_XREF_LABEL, node, window->point + dir, (WINDOW *)NULL, dir);
d4204 1
a4204 1
          (INFO_MENU_ENTRY_LABEL, node, nextmenu + dir, (WINDOW *)NULL, dir);
d4303 1
a4303 1
   _("Move to the cursor to a specific line of the window"))
d4398 1
a4398 4
      char *temp;

      temp = (char *)xmalloc (1 + strlen (rep) + strlen (_("\"\" is invalid")));

d4839 25
d4921 1
d4933 1
a4933 1
              exit (0);
@


1.2
log
@Upgrade to 3.12, merge with OpenBSD changes.
@
text
@d2 1
a2 1
   $Id: session.c,v 1.13 1998/02/22 22:38:30 karl Exp $
d1915 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/* session.c -- The user windowing interface to Info. */
d4 1
a4 4
/* This file is part of GNU Info, a program for reading online documentation
   stored in Info format.

   Copyright (C) 1993 Free Software Foundation, Inc.
a22 3
#if defined (HAVE_SYS_FILE_H)
#include <sys/file.h>
#endif /* HAVE_SYS_FILE_H */
a23 1
#include <fcntl.h>
d38 3
a40 3
/*								    */
/*		     Running an Info Session			    */
/*								    */
d44 1
a44 1
static FILE *info_input_stream = (FILE *)NULL;
d47 1
a47 1
VFunction *info_last_executed_command = (VFunction *)NULL;
d54 1
a54 1
INFO_WINDOW **info_windows = (INFO_WINDOW **)NULL;
d59 1
a59 1
/* Number of slots allocated to INFO_WINDOWS. */
d84 1
a84 1
	break;
d88 4
a91 4
	{
	  initialize_info_session (node);
	  window = active_window;
	}
d93 37
a129 37
	{
	  /* Find the largest window in WINDOWS, and make that be the active
	     one.  Then split it and add our window and node to the list
	     of remembered windows and nodes.  Then tile the windows. */
	  register WINDOW *win, *largest = (WINDOW *)NULL;
	  int max_height = 0;

	  for (win = windows; win; win = win->next)
	    if (win->height > max_height)
	      {
		max_height = win->height;
		largest = win;
	      }

	  if (!largest)
	    {
	      display_update_display (windows);
	      info_error (CANT_FIND_WIND);
	      info_session ();
	      exit (0);
	    }

	  active_window = largest;
	  window = window_make_window (node);
	  if (window)
	    {
	      window_tile_windows (TILE_INTERNALS);
	      remember_window_and_node (window, node);
	    }
	  else
	    {
	      display_update_display (windows);
	      info_error (WIN_TOO_SMALL);
	      info_session ();
	      exit (0);
	    }
	}
d142 1
a142 1
  initialize_info_session (initial_node);
d152 1
a152 1
  initialize_info_session (initial_node);
d162 1
a162 1
    ("Welcome to Info version %s. \"\\[get-help-window]\" for help, \"\\[menu-item]\" for menu item.");
a171 1
  terminal_prep_terminal ();
d173 1
a173 1
  info_last_executed_command = (VFunction *)NULL;
d198 1
a198 1
	 goal column for this window. */
d200 2
a201 2
	  (info_last_executed_command != info_prev_line))
	active_window->goal_column = -1;
d204 4
a207 4
	{
	  lk = echo_area_last_command_was_kill;
	  echo_area_prep_read ();
	}
d210 1
a210 1
	display_update_display (windows);
d219 1
a219 1
	 the echo_area if it is not currently active. */
d221 1
a221 1
	window_clear_echo_area ();
d229 18
a246 18
	{
	  /* Echo area commands that do killing increment the value of
	     ECHO_AREA_LAST_COMMAND_WAS_KILL.  Thus, if there is no
	     change in the value of this variable, the last command
	     executed was not a kill command. */
	  if (lk == echo_area_last_command_was_kill)
	    echo_area_last_command_was_kill = 0;

	  if (ea_last_executed_command == ea_newline ||
	      info_aborted_echo_area)
	    {
	      ea_last_executed_command = (VFunction *)NULL;
	      done = 1;
	    }

	  if (info_last_executed_command == info_quit)
	    quit_info_immediately = 1;
	}
d248 1
a248 1
	done = 1;
d256 1
a256 1
   and display systems. */
d258 1
a258 1
initialize_info_session (node)
d260 1
d262 1
a262 3
  char *getenv (), *term_name;

  term_name = getenv ("TERM");
d268 1
a268 1
	term_name = "dumb";
d273 7
a279 1
  terminal_clear_screen ();
d290 2
a291 1
  /* If input has not been redirected yet, make it come from STDIN. */
d293 4
a296 1
    info_input_stream = stdin;
a364 2
  INFO_WINDOW *info_win;

d366 1
a366 1
  info_win = get_info_window_of_window (window);
d381 1
a381 1
			    info_windows_slots, 10, INFO_WINDOW *);
d385 9
a393 11
     same as the last saved node and pagetop, don't really add this to
     the list of history nodes. */
  {
    int ni = info_win->nodes_index - 1;

    if ((ni != -1) &&
	(info_win->nodes[ni]->contents == node->contents) &&
	(info_win->pagetops[ni] == window->pagetop) &&
	(info_win->points[ni] == window->point))
    return;
  }
d401 7
a407 9
      info_win->nodes = (NODE **)
	xrealloc (info_win->nodes,
		  (info_win->nodes_slots += 20) * sizeof (NODE *));

      info_win->pagetops = (int *)
	xrealloc (info_win->pagetops, info_win->nodes_slots * sizeof (int));

      info_win->points = (long *)
	xrealloc (info_win->points, info_win->nodes_slots * sizeof (long));
d414 1
a414 1
  info_win->nodes[info_win->nodes_index] = (NODE *)NULL;
a424 1
  INFO_WINDOW *info_win;
d431 2
a432 2
	if (win == info_windows[i]->window)
	  break;
d435 1
a435 1
	abort ();
d456 4
a459 4
	{
	  info_windows[i] = info_windows[i + 1];
	  i++;
	}
d465 12
a476 12
	{
	  /* Free the node structures which held onto internal node contents
	     here.  This doesn't free the contents; we have a garbage collector
	     which does that. */
	  for (i = 0; info_win->nodes[i]; i++)
	    if (internal_info_node_p (info_win->nodes[i]))
	      free (info_win->nodes[i]);
	  free (info_win->nodes);

	  maybe_free (info_win->pagetops);
	  maybe_free (info_win->points);
	}
d507 3
a509 3
/*								    */
/*		       Info Movement Commands			    */
/*								    */
d553 2
a554 2
	  (((window->height - amount) * 10) < window->height))
	return;
d568 2
a569 2
	  (((window->height - amount) * 10) < window->height))
	return;
d617 1
a617 1
	return;
d629 1
a629 1
DECLARE_INFO_COMMAND (info_next_line, "Move down to the next line")
d644 1
a644 1
DECLARE_INFO_COMMAND (info_prev_line, "Move up to the previous line")
d659 1
a659 1
DECLARE_INFO_COMMAND (info_end_of_line, "Move to the end of the line")
d679 1
a679 1
DECLARE_INFO_COMMAND (info_beginning_of_line, "Move to the start of the line")
d698 1
a698 1
DECLARE_INFO_COMMAND (info_forward_char, "Move forward a character")
d707 1
a707 1
	window->point = window->node->nodelen - 1;
d714 1
a714 1
DECLARE_INFO_COMMAND (info_backward_char, "Move backward a character")
d723 1
a723 1
	window->point = 0;
d732 1
a732 1
DECLARE_INFO_COMMAND (info_forward_word, "Move forward a word")
d751 1
a751 1
	return;
d754 1
a754 1
	 Then, move forward until we hit a non-alphabetic character. */
d758 8
a765 8
	{
	  while (++point < end)
	    {
	      c = buffer[point];
	      if (alphabetic (c))
		break;
	    }
	}
d770 5
a774 5
	{
	  c = buffer[point];
	  if (!alphabetic (c))
	    break;
	}
d781 1
a781 1
DECLARE_INFO_COMMAND (info_backward_word, "Move backward a word")
d799 1
a799 1
	break;
d802 1
a802 1
	 characters just before point. */
d807 8
a814 8
	{
	  while (--point)
	    {
	      c = buffer[point - 1];
	      if (alphabetic (c))
		break;
	    }
	}
d817 7
a823 7
	{
	  c = buffer[point - 1];
	  if (!alphabetic (c))
	    break;
	  else
	    --point;
	}
d855 1
a855 1
    sprintf (td_buffer, "%s%s", counter_names[i], count > 2 ? " times" : "");
d857 1
a857 1
    sprintf (td_buffer, "%d times", count);
d866 5
a870 5
   IS_Continuous	Try to get first menu item, or failing that, the
			"Next:" pointer, or failing that, the "Up:" and
			"Next:" of the up.
   IS_NextOnly		Try to get "Next:" menu item.
   IS_PageOnly		Simply give up at the bottom of a node. */
d895 1
a895 1
	info_error ("No \"Next\" pointer for this node.");
d897 4
a900 4
	{
	  window_message_in_echo_area ("Following \"Next\" node...");
	  info_handle_pointer ("Next", window);
	}
d905 120
a1024 120
	/* First things first.  If this node contains a menu, move down
	   into the menu. */
	{
	  REFERENCE **menu;

	  menu = info_menu_of_node (window->node);

	  if (menu)
	    {
	      info_free_references (menu);
	      window_message_in_echo_area ("Selecting first menu item...");
	      info_menu_digit (window, 1, '1');
	      return;
	    }
	}

	/* Okay, this node does not contain a menu.  If it contains a
	   "Next:" pointer, use that. */
	info_next_label_of_node (window->node);
	if (info_label_was_found)
	  {
	    window_message_in_echo_area ("Selecting \"Next\" node...");
	    info_handle_pointer ("Next", window);
	    return;
	  }

	/* Okay, there wasn't a "Next:" for this node.  Move "Up:" until we
	   can move "Next:".  If that isn't possible, complain that there
	   are no more nodes. */
	{
	  int up_counter, old_current;
	  INFO_WINDOW *info_win;

	  /* Remember the current node and location. */
	  info_win = get_info_window_of_window (window);
	  old_current = info_win->current;

	  /* Back up through the "Up:" pointers until we have found a "Next:"
	     that isn't the same as the first menu item found in that node. */
	  up_counter = 0;
	  while (!info_error_was_printed)
	    {
	      info_up_label_of_node (window->node);
	      if (info_label_was_found)
		{
		  info_handle_pointer ("Up", window);
		  if (info_error_was_printed)
		    continue;

		  up_counter++;

		  info_next_label_of_node (window->node);

		  /* If no "Next" pointer, keep backing up. */
		  if (!info_label_was_found)
		    continue;

		  /* If this node's first menu item is the same as this node's
		     Next pointer, keep backing up. */
		  if (!info_parsed_filename)
		    {
		      REFERENCE **menu;
		      char *next_nodename;

		      /* Remember the name of the Next node, since reading
			 the menu can overwrite the contents of the
			 info_parsed_xxx strings. */
		      next_nodename = strdup (info_parsed_nodename);

		      menu = info_menu_of_node (window->node);
		      if (menu &&
			  (strcmp
			   (menu[0]->nodename, next_nodename) == 0))
			{
			  info_free_references (menu);
			  free (next_nodename);
			  continue;
			}
		      else
			{
			  /* Restore the world to where it was before
			     reading the menu contents. */
			  info_free_references (menu);
			  free (next_nodename);
			  info_next_label_of_node (window->node);
			}
		    }

		  /* This node has a "Next" pointer, and it is not the
		     same as the first menu item found in this node. */
		  window_message_in_echo_area
		    ("Moving \"Up\" %s, then \"Next\".",
		     times_description (up_counter));

		  info_handle_pointer ("Next", window);
		  return;
		}
	      else
		{
		  /* No more "Up" pointers.  Print an error, and call it
		     quits. */
		  register int i;

		  for (i = 0; i < up_counter; i++)
		    {
		      info_win->nodes_index--;
		      free (info_win->nodes[info_win->nodes_index]);
		      info_win->nodes[info_win->nodes_index] = (NODE *)NULL;
		    }
		  info_win->current = old_current;
		  window->node = info_win->nodes[old_current];
		  window->pagetop = info_win->pagetops[old_current];
		  window->point = info_win->points[old_current];
		  recalculate_line_starts (window);
		  window->flags |= W_UpdateWindow;
		  info_error ("No more nodes.");
		}
	    }
	}
	break;
d1044 1
a1044 1
	info_error ("No \"Prev\" for this node.");
d1046 4
a1049 4
	{
	  window_message_in_echo_area ("Moving \"Prev\" in this window.");
	  info_handle_pointer ("Prev", window);
	}
d1056 10
a1065 10
	{
	  info_up_label_of_node (window->node);
	  if (!info_parsed_nodename && !info_parsed_filename)
	    info_error ("No \"Prev\" or \"Up\" for this node.");
	  else
	    {
	      window_message_in_echo_area ("Moving \"Up\" in this window.");
	      info_handle_pointer ("Up", window);
	    }
	}
d1067 48
a1114 48
	{
	  REFERENCE **menu;
	  int inhibit_menu_traversing = 0;

	  /* Watch out!  If this node's Prev is the same as the Up, then
	     move Up.  Otherwise, we could move Prev, and then to the last
	     menu item in the Prev.  This would cause the user to loop
	     through a subsection of the info file. */
	  if (!info_parsed_filename && info_parsed_nodename)
	    {
	      char *pnode;

	      pnode = strdup (info_parsed_nodename);
	      info_up_label_of_node (window->node);

	      if (!info_parsed_filename && info_parsed_nodename &&
		  strcmp (info_parsed_nodename, pnode) == 0)
		{
		  /* The nodes are the same.  Inhibit moving to the last
		     menu item. */
		  free (pnode);
		  inhibit_menu_traversing = 1;
		}
	      else
		{
		  free (pnode);
		  info_prev_label_of_node (window->node);
		}
	    }

	  /* Move to the previous node.  If this node now contains a menu,
	     and we have not inhibited movement to it, move to the node
	     corresponding to the last menu item. */
	  window_message_in_echo_area ("Moving \"Prev\" in this window.");
	  info_handle_pointer ("Prev", window);

	  if (!inhibit_menu_traversing)
	    {
	      while (!info_error_was_printed &&
		     (menu = info_menu_of_node (window->node)))
		{
		  info_free_references (menu);
		  window_message_in_echo_area
		    ("Moving to \"Prev\"'s last menu item.");
		  info_menu_digit (window, 1, '0');
		}
	    }
	}
d1121 1
a1121 1
		      "Move forwards or down through node structure")
d1128 4
a1131 4
	{
	  forward_move_node_structure (window, IS_Continuous);
	  count--;
	}
d1137 1
a1137 1
		      "Move backwards or up through node structure")
d1144 4
a1147 4
	{
	  backward_move_node_structure (window, IS_Continuous);
	  count--;
	}
d1152 1
a1152 1
DECLARE_INFO_COMMAND (info_scroll_forward, "Scroll forward in this window")
d1161 3
a1163 3
	 lines to the top of this window,  Or, if at bottom of window,
	 and the user wishes to scroll through nodes get the "Next" node
	 for this window. */
d1165 2
a1166 2
	{
	  desired_top = window->pagetop + (window->height - 2);
d1168 15
a1182 15
	  /* If there are no more lines to scroll here, error, or get
	     another node, depending on INFO_SCROLL_BEHAVIOUR. */
	  if (desired_top > window->line_count)
	    {
	      int behaviour = info_scroll_behaviour;

	      /* Here is a hack.  If the key being used is not SPC, do the
		 PageOnly behaviour. */
	      if (key != SPC && key != DEL)
		behaviour = IS_PageOnly;

	      forward_move_node_structure (window, behaviour);
	      return;
	    }
	}
d1184 1
a1184 1
	desired_top = window->pagetop + count;
d1187 1
a1187 1
	desired_top = window->line_count - 2;
d1190 1
a1190 1
	return;
d1192 1
a1192 1
	set_window_pagetop (window, desired_top);
d1197 1
a1197 1
DECLARE_INFO_COMMAND (info_scroll_backward, "Scroll backward in this window")
d1206 2
a1207 2
	 to the bottom of this window, or move to the previous, or Up'th
	 node. */
d1209 2
a1210 2
	{
	  desired_top = window->pagetop - (window->height - 2);
d1212 14
a1225 14
	  if ((desired_top < 0) && (window->pagetop == 0))
	    {
	      int behaviour = info_scroll_behaviour;

	      /* Same kind of hack as in info_scroll_forward.  If the key
		 used to invoke this command is not DEL, do only the PageOnly
		 behaviour. */
	      if (key != DEL && key != SPC)
		behaviour = IS_PageOnly;

	      backward_move_node_structure (window, behaviour);
	      return;
	    }
	}
d1227 1
a1227 1
	desired_top = window->pagetop - count;
d1230 1
a1230 1
	desired_top = 0;
d1237 1
a1237 1
DECLARE_INFO_COMMAND (info_beginning_of_node, "Move to the start of this node")
d1244 1
a1244 1
DECLARE_INFO_COMMAND (info_end_of_node, "Move to the end of this node")
d1251 3
a1253 3
/*								    */
/*		   Commands for Manipulating Windows		    */
/*								    */
d1257 1
a1257 1
DECLARE_INFO_COMMAND (info_next_window, "Select the next window")
d1275 1
a1275 1
	window = window->next;
d1277 6
a1282 6
	{
	  if (window == the_echo_area || !echo_area_is_active)
	    window = windows;
	  else
	    window = the_echo_area;
	}
d1288 1
a1288 1
	info_get_or_remove_footnotes (window);
d1296 1
a1296 1
DECLARE_INFO_COMMAND (info_prev_window, "Select the previous window")
d1315 1
a1315 1
	 are in the first window, find the last window in the chain. */
d1317 3
a1319 3
	  (window == windows && !echo_area_is_active))
	{
	  register WINDOW *win, *last;
d1321 2
a1322 2
	  for (win = windows; win; win = win->next)
	    last = win;
d1324 2
a1325 2
	  window = last;
	}
d1327 6
a1332 6
	{
	  if (window == windows)
	    window = the_echo_area;
	  else
	    window = window->prev;
	}
d1338 1
a1338 1
	info_get_or_remove_footnotes (window);
d1347 1
a1347 1
DECLARE_INFO_COMMAND (info_split_window, "Split the current window")
d1371 2
a1372 2
	{
	  int start, end, amount;
d1374 5
a1378 5
	  start = split->first_row;
	  end = start + window->height;
	  amount = split->height + 1;
	  display_scroll_display (start, end, amount);
	}
d1385 1
a1385 1
	 something else in it. */
d1387 26
a1412 26
	{
	  register int i, j;
	  INFO_WINDOW *iw;
	  NODE *node = (NODE *)NULL;
	  char *filename;

	  for (i = 0; iw = info_windows[i]; i++)
	    {
	      for (j = 0; j < iw->nodes_index; j++)
		if (!internal_info_node_p (iw->nodes[j]))
		  {
		    if (iw->nodes[j]->parent)
		      filename = iw->nodes[j]->parent;
		    else
		      filename = iw->nodes[j]->filename;

		    node = info_get_node (filename, iw->nodes[j]->nodename);
		    if (node)
		      {
			window_set_node_of_window (split, node);
			i = info_windows_index - 1;
			break;
		      }
		  }
	    }
	}
d1416 1
a1416 1
	window_tile_windows (DONT_TILE_INTERNALS);
d1418 1
a1418 1
	window_adjust_pagetop (split);
d1428 1
a1428 1
DECLARE_INFO_COMMAND (info_delete_window, "Delete the current window")
d1436 1
a1436 1
      info_error ("Cannot delete a permanent window");
d1443 1
a1443 1
	info_get_or_remove_footnotes (active_window);
d1446 1
a1446 1
	window_tile_windows (DONT_TILE_INTERNALS);
d1459 1
a1459 1
	 our list of remembered windows. */
d1464 1
a1464 1
	echo_area_inform_of_deleted_window (window);
d1469 1
a1469 1
DECLARE_INFO_COMMAND (info_keep_one_window, "Delete all other windows")
d1471 1
a1471 1
  int num_deleted;		/* The number of windows we deleted. */
d1487 2
a1488 2
	 are found, we are done.  A window is eligible for deletion if
	 is it not permanent, and it is not WINDOW. */
d1490 2
a1491 2
	if (win != window && ((win->flags & W_WindowIsPerm) == 0))
	  break;
d1494 1
a1494 1
	break;
d1515 1
a1515 1
DECLARE_INFO_COMMAND (info_scroll_other_window, "Scroll the other window")
d1535 1
a1535 1
DECLARE_INFO_COMMAND (info_grow_window, "Grow (or shrink) this window")
d1546 1
a1546 1
    "Divide the available screen space among the visible windows")
d1553 1
a1553 1
	      "Toggle the state of line wrapping in the current window")
d1559 3
a1561 3
/*								    */
/*			Info Node Commands			    */
/*								    */
d1583 1
a1583 1
    filename = strdup (filename);
d1586 1
a1586 1
    nodename = strdup (entry->nodename);
d1588 1
a1588 1
    nodename = strdup ("Top");
d1598 1
a1598 1
	file_system_error = strdup (info_recent_file_error);
d1601 8
a1608 8
	{
	  node = info_get_node (entry->label, "Top");
	  if (!node && info_recent_file_error)
	    {
	      maybe_free (file_system_error);
	      file_system_error = strdup (info_recent_file_error);
	    }
	}
d1614 1
a1614 1
	info_error (file_system_error);
d1616 1
a1616 1
	info_error (CANT_FIND_NODE, nodename);
d1666 1
a1666 1
	filename = strdup (info_parsed_filename);
d1668 6
a1673 6
	{
	  if (window->node->parent)
	    filename = strdup (window->node->parent);
	  else if (window->node->filename)
	    filename = strdup (window->node->filename);
	}
d1676 1
a1676 1
	nodename = strdup (info_parsed_nodename);
d1678 1
a1678 1
	nodename = strdup ("Top");
d1683 2
a1684 2
	{
	  INFO_WINDOW *info_win;
d1686 9
a1694 9
	  info_win = get_info_window_of_window (window);
	  if (info_win)
	    {
	      info_win->pagetops[info_win->current] = window->pagetop;
	      info_win->points[info_win->current] = window->point;
	    }
	  set_remembered_pagetop_and_point (window);
	  info_set_node_of_window (window, node);
	}
d1696 6
a1701 6
	{
	  if (info_recent_file_error)
	    info_error (info_recent_file_error);
	  else
	    info_error (CANT_FILE_NODE, filename, nodename);
	}
d1714 1
a1714 1
DECLARE_INFO_COMMAND (info_next_node, "Select the `Next' node")
d1717 1
a1717 1
  info_handle_pointer ("Next", window);
d1722 1
a1722 1
DECLARE_INFO_COMMAND (info_prev_node, "Select the `Prev' node")
d1725 1
a1725 1
  info_handle_pointer ("Prev", window);
d1730 1
a1730 1
DECLARE_INFO_COMMAND (info_up_node, "Select the `Up' node")
d1733 1
a1733 1
  info_handle_pointer ("Up", window);
d1737 1
a1737 1
DECLARE_INFO_COMMAND (info_last_node, "Select the last node in this file")
d1750 1
a1750 1
    info_error ("This window has no additional nodes");
d1759 1
a1759 1
DECLARE_INFO_COMMAND (info_first_node, "Select the first node in this file")
d1768 1
a1768 1
    info_error ("This window has no additional nodes");
a1775 40
/* Make WINDOW display the previous node displayed in this window. */
DECLARE_INFO_COMMAND (info_history_node,
		      "Select the most recently selected node")
{
  INFO_WINDOW *info_win;

  /* Find the INFO_WINDOW which contains WINDOW. */
  info_win = get_info_window_of_window (window);

  if (!info_win)
    {
      info_error ("Requested window is not present!");
      return;
    }

  set_remembered_pagetop_and_point (window);
  if (!info_win->current)
    {
      if (info_win->nodes_index > 1)
	{
	  window_message_in_echo_area
	    ("Now wrapped around to beginning of history.");
	  info_win->current = info_win->nodes_index;
	}
      else
	{
	  info_error ("No earlier nodes in this window.");
	  return;
	}
    }

  info_win->current--;
  window_set_node_of_window (window, info_win->nodes[info_win->current]);
  window->pagetop = info_win->pagetops[info_win->current];
  window->point   = info_win->points[info_win->current];
  window->flags |= W_UpdateWindow;
  if (auto_footnotes_p)
    info_get_or_remove_footnotes (window);
}

d1778 1
a1778 1
   "Select the last item in this node's menu")
d1784 1
a1784 1
DECLARE_INFO_COMMAND (info_menu_digit, "Select this menu item")
d1805 3
a1807 3
      for (i = 0; entry = menu[i]; i++)
	if (i == item - 1)
	  break;
d1813 1
a1813 1
    info_error ("There aren't %d items in this menu.", item);
d1840 1
a1840 1
	info_error (NO_MENU_NODE);
d1842 1
a1842 1
	info_error (NO_XREF_NODE);
d1856 1
a1856 1
	SEARCH_BINDING binding;
d1858 18
a1875 21
	binding.start = 0;
	binding.buffer = window->line_starts[point_line];
	if (window->line_starts[point_line + 1])
	  binding.end = window->line_starts[point_line + 1] - binding.buffer;
	else
	  binding.end =
	    (window->node->contents + window->node->nodelen) - binding.buffer;
	binding.flags = 0;

	if (builder == info_menu_of_node)
	  {
	    if (point_line)
	      {
		binding.buffer--;
		binding.end++;

		refs = info_menu_items (&binding);
	      }
	  }
	else
	  {
d1877 3
a1879 3
	    if (window->node->flags & N_IsManPage)
	      refs = manpage_xrefs_in_binding (window->node, &binding);
	    else
d1881 2
a1882 2
	    refs = info_xrefs (&binding);
	  }
d1884 43
a1926 43
	if (refs)
	  {
	    if ((strcmp (refs[0]->label, "Menu") != 0) ||
		(builder == info_xrefs_of_node))
	      {
		int which = 0;

		/* Find the closest reference to point. */
		if (builder == info_xrefs_of_node)
		  {
		    int closest = -1;

		    for (; refs[which]; which++)
		      {
			if ((window->point >= refs[which]->start) &&
			    (window->point <= refs[which]->end))
			  {
			    closest = which;
			    break;
			  }
			else if (window->point < refs[which]->start)
			  {
			    break;
			  }
		      }
		    if (closest == -1)
		      which--;
		    else
		      which = closest;
		  }

		defentry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
		defentry->label = strdup (refs[which]->label);
		defentry->filename = refs[which]->filename;
		defentry->nodename = refs[which]->nodename;

		if (defentry->filename)
		  defentry->filename = strdup (defentry->filename);
		if (defentry->nodename)
		  defentry->nodename = strdup (defentry->nodename);
	      }
	    info_free_references (refs);
	  }
d1937 1
a1937 1
	prompt = (char *)xmalloc (20 + strlen (defentry->label));
d1939 1
a1939 1
	prompt = (char *)xmalloc (20);
d1942 6
a1947 6
	{
	  if (defentry)
	    sprintf (prompt, "Menu item (%s): ", defentry->label);
	  else
	    sprintf (prompt, "Menu item: ");
	}
d1949 6
a1954 6
	{
	  if (defentry)
	    sprintf (prompt, "Follow xref (%s): ", defentry->label);
	  else
	    sprintf (prompt, "Follow xref: ");
	}
d1963 6
a1968 6
	{
	  maybe_free (defentry);
	  info_free_references (menu);
	  info_abort_key (window, 0, 0);
	  return;
	}
d1972 7
a1978 7
	{
	  free (line);
	  if (defentry)
	    line = strdup (defentry->label);
	  else
	    line = (char *)NULL;
	}
d1983 1
a1983 1
	 that, otherwise return. */
d1985 1
a1985 1
	return;
d1987 1
a1987 1
	line = strdup (defentry->label);
d1996 1
a1996 1
	info_error ("The reference disappeared! (%s).", line);
d1998 2
a1999 2
	{
	  NODE *orig;
d2001 22
a2022 22
	  orig = window->node;
	  info_select_reference (window, entry);
	  if ((builder == info_xrefs_of_node) && (window->node != orig))
	    {
	      long offset;
	      long start;

	      if (window->line_count > 0)
		start = window->line_starts[1] - window->node->contents;
	      else
		start = 0;

	      offset =
		info_target_search_node (window->node, entry->label, start);

	      if (offset != -1)
		{
		  window->point = offset;
		  window_adjust_pagetop (window);
		}
	    }
	}
d2026 6
a2031 6
	{
	  free (defentry->label);
	  maybe_free (defentry->filename);
	  maybe_free (defentry->nodename);
	  free (defentry);
	}
d2042 1
a2042 1
DECLARE_INFO_COMMAND (info_menu_item, "Read a menu item and select its node")
d2050 1
a2050 1
  (info_xref_item, "Read a footnote or cross reference and select its node")
d2056 1
a2056 1
DECLARE_INFO_COMMAND (info_find_menu, "Move to the start of this node's menu")
d2080 1
a2080 1
  "Visit as many menu items at once as possible")
d2098 1
a2098 1
	info_error (WIN_TOO_SMALL);
d2100 4
a2103 4
	{
	  active_window = new;
	  info_select_reference (new, entry);
	}
d2108 1
a2108 1
DECLARE_INFO_COMMAND (info_goto_node, "Read a node name and select it")
a2110 1
  NODE *node;
d2126 42
a2167 42
	FILE_BUFFER *fb;
	REFERENCE *entry;
	int this_is_the_current_fb;

	fb = info_loaded_files[fbi];
	this_is_the_current_fb = (current == fb);

	entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
	entry->filename = entry->nodename = (char *)NULL;
	entry->label = (char *)xmalloc (4 + strlen (fb->filename));
	sprintf (entry->label, "(%s)*", fb->filename);

	add_pointer_to_array
	  (entry, items_index, items, items_slots, 10, REFERENCE *);

	if (fb->tags)
	  {
	    for (i = 0; fb->tags[i]; i++)
	      {
		entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
		entry->filename = entry->nodename = (char *)NULL;
		entry->label = (char *) xmalloc
		  (4 + strlen (fb->filename) + strlen (fb->tags[i]->nodename));
		sprintf (entry->label, "(%s)%s",
			 fb->filename, fb->tags[i]->nodename);

		add_pointer_to_array
		  (entry, items_index, items, items_slots, 100, REFERENCE *);
	      }		

	    if (this_is_the_current_fb)
	      {
		for (i = 0; fb->tags[i]; i++)
		  {
		    entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
		    entry->filename = entry->nodename = (char *)NULL;
		    entry->label = strdup (fb->tags[i]->nodename);
		    add_pointer_to_array (entry, items_index, items,
					  items_slots, 100, REFERENCE *);
		  }
	      }
	  }
d2169 1
a2169 1
    line = info_read_maybe_completing (window, "Goto Node: ", items);
d2173 1
a2173 1
  line = info_read_in_echo_area (window, "Goto Node: ");
d2194 1
a2194 1
DECLARE_INFO_COMMAND (info_man, "Read a manpage reference and select it")
a2196 1
  NODE *node;
d2198 1
a2198 1
  line = info_read_in_echo_area (window, "Get Manpage: ");
d2213 1
a2213 1
	(4 + strlen (MANPAGE_FILE_BUFFER_NAME) + strlen (line));
d2228 1
a2228 1
DECLARE_INFO_COMMAND (info_top_node, "Select the node `Top' in this file")
d2230 1
a2230 1
  info_parse_and_select ("Top", window);
d2234 1
a2234 1
DECLARE_INFO_COMMAND (info_dir_node, "Select the node `(dir)'")
d2239 6
a2244 3
/* Try to delete the current node appearing in this window, showing the most
   recently selected node in this window. */
DECLARE_INFO_COMMAND (info_kill_node, "Kill this node")
d2246 9
a2254 4
  register int iw, i;
  register INFO_WINDOW *info_win;
  char *nodename = (char *)NULL;
  NODE *temp = (NODE *)NULL;
d2256 5
a2260 6
  /* Read the name of a node to kill.  The list of available nodes comes
     from the nodes appearing in the current window configuration. */
  {
    REFERENCE **menu = (REFERENCE **)NULL;
    int menu_index = 0, menu_slots = 0;
    char *default_nodename, *prompt;
d2262 3
a2264 3
    for (iw = 0; info_win = info_windows[iw]; iw++)
      {
	REFERENCE *entry;
d2266 10
a2275 3
	entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
	entry->label = strdup (info_win->window->node->nodename);
	entry->filename = entry->nodename = (char *)NULL;
d2277 2
a2278 3
	add_pointer_to_array
	  (entry, menu_index, menu, menu_slots, 10, REFERENCE *);
      }
a2279 15
    default_nodename = strdup (active_window->node->nodename);
    prompt = (char *)xmalloc (40 + strlen (default_nodename));
    sprintf (prompt, "Kill node (%s): ", default_nodename);

    nodename = info_read_completing_in_echo_area (window, prompt, menu);
    free (prompt);
    info_free_references (menu);
    if (nodename && !*nodename)
      {
	free (nodename);
	nodename = default_nodename;
      }
    else
      free (default_nodename);
  }
d2281 11
d2300 1
a2300 1
  for (iw = 0; info_win = info_windows[iw]; iw++)
d2307 1
a2307 1
	info_error ("Cannot kill the node `%s'", nodename);
d2309 1
a2309 1
	window_clear_echo_area ();
d2317 1
a2317 1
      info_error ("Cannot kill the last node");
d2321 2
a2322 3
  /* INFO_WIN contains the node that the user wants to stop viewing.
     Delete this node from the list of nodes previously shown in this
     window. */
d2341 1
a2341 1
	stealer = info_windows[iw + 1];
d2343 1
a2343 1
	stealer = info_windows[0];
d2346 1
a2346 1
	 recently loaded one, get the most recently loaded one. */
d2348 1
a2348 1
	which = stealer->nodes_index - 1;
d2351 1
a2351 1
	 use that one. */
d2353 1
a2353 1
	which = stealer->current - 1;
d2357 1
a2357 1
	which = stealer->current;
d2361 12
a2372 1
	NODE *copy;
d2374 1
a2374 13
	temp = stealer->nodes[which];
	point = stealer->points[which];
	pagetop = stealer->pagetops[which];

	copy = (NODE *)xmalloc (sizeof (NODE));
	copy->filename = temp->filename;
	copy->parent = temp->parent;
	copy->nodename = temp->nodename;
	copy->contents = temp->contents;
	copy->nodelen = temp->nodelen;
	copy->flags = temp->flags;

	temp = copy;
d2387 1
d2390 14
d2406 8
d2415 1
a2415 1
DECLARE_INFO_COMMAND (info_view_file, "Read the name of a file and select it")
d2419 1
a2419 1
  line = info_read_in_echo_area (window, "Find file: ");
d2432 6
a2437 6
	{
	  if (info_recent_file_error)
	    info_error (info_recent_file_error);
	  else
	    info_error ("Cannot find \"%s\".", line);
	}
d2439 4
a2442 4
	{
	  set_remembered_pagetop_and_point (active_window);
	  info_set_node_of_window (window, node);
	}
d2451 3
a2453 3
/*								    */
/*		   Dumping and Printing Nodes			    */
/*								    */
d2483 1
a2483 1
      info_error ("Could not create output file \"%s\".", output_filename);
d2496 1
a2496 1
  info_error ("Done.");
d2528 1
a2528 1
	info_error (info_recent_file_error);
d2530 7
a2536 7
	{
	  if (filename && *nodename != '(')
	    info_error
	      (CANT_FILE_NODE, filename_non_directory (filename), nodename);
	  else
	    info_error (CANT_FIND_NODE, nodename);
	}
d2544 2
a2545 2
	free (node);
	return;
d2548 1
a2548 1
			dumped_already_slots, 50, char *);
d2553 2
a2554 2
    info_error ("Writing node \"(%s)%s\"...",
		filename_non_directory (node->filename), node->nodename);
d2556 1
a2556 1
    info_error ("Writing node \"%s\"...", node->nodename);
d2569 1
a2569 1
	menu = info_menu_of_node (node);
d2572 11
a2582 11
	{
	  for (i = 0; menu[i]; i++)
	    {
	      /* We don't dump Info files which are different than the
		 current one. */
	      if (!menu[i]->filename)
		dump_node_to_stream
		  (filename, menu[i]->nodename, stream, dump_subnodes);
	    }
	  info_free_references (menu);
	}
d2608 1
a2608 1
      info_error ("Could not create output file \"%s\".", filename);
d2625 1
a2625 1
  info_error ("Done.");
d2634 1
a2634 1
 "Pipe the contents of this node through INFO_PRINT_COMMAND")
a2643 1
  char *print_command, *getenv ();
d2645 1
a2645 2

  print_command = getenv ("INFO_PRINT_COMMAND");
d2654 1
a2654 1
      info_error ("Cannot open pipe to \"%s\".", print_command);
d2661 2
a2662 2
    info_error ("Printing node \"(%s)%s\"...",
		filename_non_directory (node->filename), node->nodename);
d2664 1
a2664 1
    info_error ("Printing node \"%s\"...", node->nodename);
d2671 1
a2671 1
  info_error ("Done.");
d2684 3
a2686 3
/*								    */
/*		      Info Searching Commands			    */
/*								    */
d2761 1
a2761 1
	window_set_node_of_window (window, node);
d2781 1
a2781 1
  target = strdup (string);
d2792 1
a2792 1
	break;
d2826 1
a2826 1
	(string, window->node, window->point + dir, window, dir);
d2831 1
a2831 1
	(string, window->node, window->point, window, dir);
d2835 1
a2835 1
  last_searched_for_string = strdup (string);
d2841 1
a2841 1
	window_clear_echo_area ();
d2862 5
a2866 5
	if (strcmp (initial_nodename, file_buffer->tags[i]->nodename) == 0)
	  {
	    current_tag = i;
	    last_subfile = file_buffer->tags[i]->filename;
	  }
d2872 1
a2872 1
	return (-1);
d2875 2
a2876 2
	 of the info file until we find the string or return to this
	 window's node and point. */
d2878 2
a2879 2
	{
	  NODE *node;
d2881 2
a2882 2
	  /* Allow C-g to quit the search, failing it if pressed. */
	  return_if_control_g (-1);
d2884 1
a2884 1
	  current_tag += dir;
d2886 56
a2941 56
	  if (current_tag < 0)
	    current_tag = number_of_tags - 1;
	  else if (current_tag == number_of_tags)
	    current_tag = 0;

	  tag = file_buffer->tags[current_tag];

	  if (!echo_area_is_active && (last_subfile != tag->filename))
	    {
	      window_message_in_echo_area
		("Searching subfile \"%s\"...",
		 filename_non_directory (tag->filename));

	      last_subfile = tag->filename;
	    }

	  node = info_get_node (file_buffer->filename, tag->nodename);

	  if (!node)
	    {
	      /* If not doing i-search... */
	      if (!echo_area_is_active)
		{
		  if (info_recent_file_error)
		    info_error (info_recent_file_error);
		  else
		    info_error (CANT_FILE_NODE,
				filename_non_directory (file_buffer->filename),
				tag->nodename);
		}
	      return (-1);
	    }

	  if (dir < 0)
	    start = tag->nodelen;

	  ret =
	    info_search_in_node (string, node, start, window, dir);

	  /* Did we find the string in this node? */
	  if (ret != -1)
	    {
	      /* Yes!  We win. */
	      remember_window_and_node (window, node);
	      if (!echo_area_is_active)
		window_clear_echo_area ();
	      return (0);
	    }

	  /* No.  Free this node, and make sure that we haven't passed
	     our starting point. */
	  free (node);

	  if (strcmp (initial_nodename, tag->nodename) == 0)
	    return (-1);
	}
d2946 1
a2946 1
DECLARE_INFO_COMMAND (info_search, "Read a string and search for it")
d2966 3
a2968 3
  sprintf (prompt, "%s for string [%s]: ",
	   direction < 0 ? "Search backward" : "Search",
	   search_string);
d2982 2
a2983 2
	search_string = (char *)
	  xrealloc (search_string, (search_string_size += 50 + strlen (line)));
d2994 1
a2994 1
    info_error ("Search failed.");
d3003 1
a3003 1
	info_get_or_remove_footnotes (active_window);
d3012 3
a3014 3
/*								    */
/*			Incremental Searching			    */
/*								    */
d3020 1
a3020 1
		      "Search interactively for a string as you type it")
d3026 1
a3026 1
		      "Search interactively for a string as you type it")
d3043 4
a3046 4
  WINDOW_STATE_DECL;	/* The node, pagetop and point. */
  int search_index;	/* Offset of the last char in the search string. */
  int direction;	/* The direction that this search is heading in. */
  int failing;		/* Whether or not this search failed. */
d3069 1
a3069 1
			isearch_states_slots, 20, SEARCH_STATE *);
d3120 1
a3120 1
    prefix = "I-search backward: ";
d3122 1
a3122 1
    prefix = "I-search: ";
d3131 7
a3137 7
	{
	case ' ': rep = " "; break;
	case LFD: rep = "\\n"; break;
	case TAB: rep = "\\t"; break;
	default:
	  rep = pretty_keyname (string[i]);
	}
d3139 1
a3139 1
	p_rep = (char *)xrealloc (p_rep, p_rep_size += 100);
d3147 2
a3148 2
  sprintf (prompt, "%s%s%s", failing_p ? "Failing " : "", prefix,
	   p_rep ? p_rep : "");
d3191 1
a3191 1
	 it is convenient. */
d3193 4
a3196 4
	{
	  display_update_one_window (window);
	  display_cursor_at_point (active_window);
	}
d3203 16
a3218 16
	{
	  /* User wants to delete one level of search? */
	  if (!isearch_states_index)
	    {
	      terminal_ring_bell ();
	      continue;
	    }
	  else
	    {
	      pop_isearch
		(window, &isearch_string_index, &dir, &search_result);
	      isearch_string[isearch_string_index] = '\0';
	      show_isearch_prompt (dir, isearch_string, search_result);
	      goto after_search;
	    }
	}
d3220 4
a3223 4
	{
	  key = info_get_input_char ();
	  quoted = 1;
	}
d3229 1
a3229 1
	goto insert_and_search;
d3232 2
a3233 2
	{
	  func = window->keymap[key].function;
d3235 75
a3309 75
	  /* If this key invokes an incremental search, then this means that
	     we will either search again in the same direction, search
	     again in the reverse direction, or insert the last search
	     string that was accepted through incremental searching. */
	  if (func == isearch_forward || func == isearch_backward)
	    {
	      if ((func == isearch_forward && dir > 0) ||
		  (func == isearch_backward && dir < 0))
		{
		  /* If the user has typed no characters, then insert the
		     last successful search into the current search string. */
		  if (isearch_string_index == 0)
		    {
		      /* Of course, there must be something to insert. */
		      if (last_isearch_accepted)
			{
			  if (strlen (last_isearch_accepted) + 1 >=
			      isearch_string_size)
			    isearch_string = (char *)
			      xrealloc (isearch_string,
					isearch_string_size += 10 +
					strlen (last_isearch_accepted));
			  strcpy (isearch_string, last_isearch_accepted);
			  isearch_string_index = strlen (isearch_string);
			  goto search_now;
			}
		      else
			continue;
		    }
		  else
		    {
		      /* Search again in the same direction.  This means start
			 from a new place if the last search was successful. */
		      if (search_result == 0)
			window->point += dir;
		    }
		}
	      else
		{
		  /* Reverse the direction of the search. */
		  dir = -dir;
		}
	    }
	  else if (isprint (key) || func == (VFunction *)NULL)
	    {
	    insert_and_search:

	      if (isearch_string_index + 2 >= isearch_string_size)
		isearch_string = (char *)xrealloc
		  (isearch_string, isearch_string_size += 100);

	      isearch_string[isearch_string_index++] = key;
	      isearch_string[isearch_string_index] = '\0';
	      goto search_now;
	    }
	  else if (func == info_abort_key)
	    {
	      /* If C-g pressed, and the search is failing, pop the search
		 stack back to the last unfailed search. */
	      if (isearch_states_index && (search_result != 0))
		{
		  terminal_ring_bell ();
		  while (isearch_states_index && (search_result != 0))
		    pop_isearch
		      (window, &isearch_string_index, &dir, &search_result);
		  isearch_string[isearch_string_index] = '\0';
		  show_isearch_prompt (dir, isearch_string, search_result);
		  continue;
		}
	      else
		goto exit_search;
	    }
	  else
	    goto exit_search;
	}
d3311 30
a3340 30
	{
	exit_search:
	  /* The character is not printable, or it has a function which is
	     non-null.  Exit the search, remembering the search string.  If
	     the key is not the same as the isearch_terminate_search_key,
	     then push it into pending input. */
	  if (isearch_string_index && func != info_abort_key)
	    {
	      maybe_free (last_isearch_accepted);
	      last_isearch_accepted = strdup (isearch_string);
	    }

	  if (key != isearch_terminate_search_key)
	    info_set_pending_input (key);

	  if (func == info_abort_key)
	    {
	      if (isearch_states_index)
		window_set_state (window, &orig_state);
	    }

	  if (!echo_area_is_active)
	    window_clear_echo_area ();

	  if (auto_footnotes_p)
	    info_get_or_remove_footnotes (active_window);

	  isearch_is_active = 0;
	  continue;
	}
d3347 19
a3365 19
	{
	  /* Check to see if the current search string is right here.  If
	     we are looking at it, then don't bother calling the search
	     function. */
	  if (((dir < 0) &&
	       (strncasecmp (window->node->contents + window->point,
			     isearch_string, isearch_string_index) == 0)) ||
	      ((dir > 0) &&
	       ((window->point - isearch_string_index) >= 0) &&
	       (strncasecmp (window->node->contents +
			     (window->point - (isearch_string_index - 1)),
			     isearch_string, isearch_string_index) == 0)))
	    {
	      if (dir > 0)
		window->point++;
	    }
	  else
	    search_result = info_search_internal (isearch_string, window, dir);
	}
d3368 1
a3368 1
	 then ring the terminal bell. */
d3370 1
a3370 1
	terminal_ring_bell ();
d3376 11
a3386 11
	{
	  if ((mystate.node == window->node) &&
	      (mystate.pagetop != window->pagetop))
	    {
	      int newtop = window->pagetop;
	      window->pagetop = mystate.pagetop;
	      set_window_pagetop (window, newtop);
	    }
	  display_update_one_window (window);
	  display_cursor_at_point (window);
	}
d3416 1
a3416 1
  for (fb_index = 0; fb = info_loaded_files[fb_index]; fb_index++)
d3422 1
a3422 1
	continue;
d3425 2
a3426 2
	 gc it.  This means that the user-variable "gc-compressed-files"
	 is non-zero. */
d3428 1
a3428 1
	continue;
d3432 1
a3432 1
	continue;
d3435 13
a3447 13
	 this file. */
      for (iw_index = 0; iw = info_windows[iw_index]; iw_index++)
	{
	  for (i = 0; iw->nodes && iw->nodes[i]; i++)
	    {
	      if ((strcmp (fb->fullpath, iw->nodes[i]->filename) == 0) ||
		  (strcmp (fb->filename, iw->nodes[i]->filename) == 0))
		{
		  fb_referenced_p = 1;
		  break;
		}
	    }
	}
d3451 4
a3454 4
	{
	  free (fb->contents);
	  fb->contents = (char *)NULL;
	}
d3459 3
a3461 3
/*								    */
/*		  Traversing and Selecting References		    */
/*								    */
d3496 2
a3497 2
	firstmenu = info_search_in_node
	  (INFO_MENU_ENTRY_LABEL, node, firstmenu + dir, (WINDOW *)NULL, dir);
d3512 1
a3512 1
      info_error ("No cross references in this node.");
d3536 2
a3537 2
	nextmenu = info_search_in_node
	  (INFO_MENU_ENTRY_LABEL, node, nextmenu + dir, (WINDOW *)NULL, dir);
d3546 2
a3547 2
	  ((dir == -1) && (nextmenu > nextxref)))
	placement = nextmenu + 1;
d3549 1
a3549 1
	placement = nextxref;
d3561 7
a3567 7
	{
	  if (((dir == 1) && (firstmenu < firstxref)) ||
	      ((dir == -1) && (firstmenu > firstxref)))
	    placement = firstmenu + 1;
	  else
	    placement = firstxref;
	}
d3569 1
a3569 1
	placement = firstmenu + 1;
d3571 1
a3571 1
	placement = firstxref;
d3579 1
a3579 1
		      "Move to the previous cross reference")
d3588 1
a3588 1
		      "Move to the next cross reference")
d3598 1
a3598 1
		      "Select reference or menu item appearing on this line")
d3614 3
a3616 3
/*								    */
/*		    Miscellaneous Info Commands			    */
/*								    */
d3620 1
a3620 1
DECLARE_INFO_COMMAND (info_abort_key, "Cancel current operation")
d3627 1
a3627 1
  info_error ("Quit");
d3636 1
a3636 1
   "Move to the cursor to a specific line of the window")
d3646 1
a3646 1
	line = (window->height + count) + window->pagetop;
d3648 1
a3648 1
	line = window->pagetop + count;
d3668 1
a3668 1
DECLARE_INFO_COMMAND (info_redraw_display, "Redraw the display")
d3685 1
a3685 1
	desired_line = window->height + count;
d3687 1
a3687 1
	desired_line = count;
d3690 1
a3690 1
	desired_line = 0;
d3693 1
a3693 1
	desired_line = window->height - 1;
d3696 1
a3696 1
	return;
d3705 1
a3705 1
DECLARE_INFO_COMMAND (info_quit, "Quit using Info")
d3710 3
a3712 3
/*								    */
/*		 Reading Keys and Dispatching on Them		    */
/*								    */
d3728 1
a3728 1
    info_error ("Unknown command (%s).", rep);
d3733 1
a3733 1
      temp = (char *)xmalloc (1 + strlen (rep) + strlen ("\"\" is invalid"));
d3735 1
a3735 1
      sprintf (temp, "\"%s\" is invalid", rep);
d3781 2
a3782 2
	       strlen (keyseq_rep) ? " " : "",
	       pretty_keyname (keyseq[i]));
d3815 1
a3815 1
  int ready = 0;
d3820 1
a3820 3
  if (!info_keyseq_displayed_p &&
      !info_any_buffered_input_p () &&
      !info_input_pending_p ())
d3822 4
d3827 2
a3828 2
      struct timeval timer;
      fd_set readfds;
d3830 7
a3836 5
      FD_ZERO (&readfds);
      FD_SET (fileno (info_input_stream), &readfds);
      timer.tv_sec = 1;
      timer.tv_usec = 750;
      ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
d3838 1
d3857 6
a3862 6
	{
	  map = (Keymap)map[ESC].function;
	  add_char_to_keyseq (ESC);
	  key = UnMeta (key);
	  info_dispatch_on_key (key, map);
	}
d3864 3
a3866 3
	{
	  dispatch_error (info_keyseq);
	}
d3874 1
a3874 1
	VFunction *func;
d3876 41
a3916 41
	func = map[key].function;
	if (func != (VFunction *)NULL)
	  {
	    /* Special case info_do_lowercase_version (). */
	    if (func == info_do_lowercase_version)
	      {
		info_dispatch_on_key (tolower (key), map);
		return;
	      }

	    add_char_to_keyseq (key);

	    if (info_keyseq_displayed_p)
	      display_info_keyseq (0);

	    {
	      WINDOW *where;

	      where = active_window;
	      (*map[key].function)
		(active_window, info_numeric_arg * info_numeric_arg_sign, key);

	      /* If we have input pending, then the last command was a prefix
		 command.  Don't change the value of the last function vars.
		 Otherwise, remember the last command executed in the var
		 appropriate to the window in which it was executed. */
	      if (!info_input_pending_p ())
		{
		  if (where == the_echo_area)
		    ea_last_executed_command = map[key].function;
		  else
		    info_last_executed_command = map[key].function;
		}
	    }
	  }
	else
	  {
	    add_char_to_keyseq (key);
	    dispatch_error (info_keyseq);
	    return;
	  }
d3923 2
a3924 2
	{
	  unsigned char newkey;
d3926 3
a3928 3
	  newkey = info_get_another_input_char ();
	  info_dispatch_on_key (newkey, (Keymap)map[key].function);
	}
d3930 4
a3933 4
	{
	  dispatch_error (info_keyseq);
	  return;
	}
d3939 3
a3941 3
/*								    */
/*			Numeric Arguments			    */
/*								    */
d3958 1
a3958 1
		      "Add this digit to the current numeric argument")
d3967 1
a3967 1
		      "Start (or multiply by 4) the current numeric argument")
d3982 1
a3982 1
		      "Internally used by \\[universal-argument]")
d3990 1
a3990 1
	pure_key = key;
d3992 3
a3994 3
	{
	  if (display_was_interrupted_p && !info_any_buffered_input_p ())
	    display_update_display (windows);
d3996 2
a3997 2
	  if (active_window != the_echo_area)
	    display_cursor_at_point (active_window);
d3999 1
a3999 1
	  pure_key = key = info_get_another_input_char ();
d4001 2
a4002 2
	  if (Meta_p (key))
	    add_char_to_keyseq (ESC);
d4004 2
a4005 2
	  add_char_to_keyseq (UnMeta (key));
	}
d4008 1
a4008 1
	key = UnMeta (key);
d4011 6
a4016 6
	  keymap[key].function == info_universal_argument)
	{
	  info_numeric_arg *= 4;
	  key = 0;
	  continue;
	}
d4019 7
a4025 7
	{
	  if (info_explicit_arg)
	    info_numeric_arg = (info_numeric_arg * 10) + (key - '0');
	  else
	    info_numeric_arg = (key - '0');
	  info_explicit_arg = 1;
	}
d4027 13
a4039 13
	{
	  if (key == '-' && !info_explicit_arg)
	    {
	      info_numeric_arg_sign = -1;
	      info_numeric_arg = 1;
	    }
	  else
	    {
	      info_keyseq_index--;
	      info_dispatch_on_key (pure_key, keymap);
	      return;
	    }
	}
d4045 3
a4047 3
/*								    */
/*			Input Character Buffering       	    */
/*								    */
d4096 1
a4096 1
	push_index = 0;
d4107 1
a4107 1
    return (sizeof (info_input_buffer - (push_index - pop_index)));
a4134 17
/* Push KEY into the *front* of the input buffer.  Returns non-zero if
   successful, zero if there is no space left in the buffer. */
static int
info_replace_key_to_typeahead (key)
     unsigned char key;
{
  if (info_input_buffer_space_available ())
    {
      pop_index--;
      if (pop_index < 0)
	pop_index = sizeof (info_input_buffer) - 1;
      info_input_buffer[pop_index] = key;
      return (1);
    }
  return (0);
}

d4140 1
d4159 1
a4159 1
      read (tty, &input[0], chars_avail);
d4178 2
a4179 5
  /* Store the input characters just read into our input buffer. */
  {
    register int i;

    for (i = 0; i < chars_avail; i++)
d4181 2
a4182 1
  }
d4201 22
a4223 1
      rawkey = getc (info_input_stream);
d4227 19
a4245 19
	{
	  if (info_input_stream != stdin)
	    {
	      fclose (info_input_stream);
	      info_input_stream = stdin;
	      display_inhibited = 0;
	      display_update_display (windows);
	      display_cursor_at_point (active_window);
	      rawkey = getc (info_input_stream);
	      keystroke = rawkey;
	    }

	  if (rawkey == EOF)
	    {
	      terminal_unprep_terminal ();
	      close_dribble_file ();
	      exit (0);
	    }
	}
d4251 1
a4251 1
  return (keystroke);
@


1.1.1.1
log
@Import of texinfo-3.6 from FSF
@
text
@@


1.1.1.2
log
@import of texinfo 3.7
@
text
@d1903 2
a1904 2
	binding.buffer = window->node->contents;
	binding.start = window->line_starts[point_line] - binding.buffer;
d1908 2
a1909 1
	  binding.end = window->node->nodelen;
d1916 3
a1918 1
		binding.start--;
@


1.1.1.3
log
@Import of texinfo-3.9.
@
text
@d6 1
a6 1
   Copyright (C) 1993, 96 Free Software Foundation, Inc.
a280 1

d4121 1
a4121 1
    return (sizeof (info_input_buffer) - (push_index - pop_index));
a4170 1
  register int i = 0;
d4208 5
a4212 2
  while (i < chars_avail)
    {
d4214 1
a4214 2
      i++;
    }
@


1.1.1.4
log
@Import of FSF texinfo 3.11
@
text
@d1 1
a1 2
/* session.c -- The user windowing interface to Info.
   $Id: session.c,v 1.12 1997/07/24 21:34:00 karl Exp $
d3 4
a6 1
   Copyright (C) 1993, 96, 97 Free Software Foundation, Inc.
d25 3
d29 1
d44 3
a46 3
/*                                                                  */
/*                   Running an Info Session                        */
/*                                                                  */
d50 1
a50 1
static FILE *info_input_stream = NULL;
d53 1
a53 1
VFunction *info_last_executed_command = NULL;
d60 1
a60 1
INFO_WINDOW **info_windows = NULL;
d65 1
a65 1
/* Number of slots allocated to `info_windows'. */
d90 1
a90 1
        break;
d94 4
a97 4
        {
          initialize_info_session (node, 1);
          window = active_window;
        }
d99 37
a135 37
        {
          /* Find the largest window in WINDOWS, and make that be the active
             one.  Then split it and add our window and node to the list
             of remembered windows and nodes.  Then tile the windows. */
          register WINDOW *win, *largest = (WINDOW *)NULL;
          int max_height = 0;

          for (win = windows; win; win = win->next)
            if (win->height > max_height)
              {
                max_height = win->height;
                largest = win;
              }

          if (!largest)
            {
              display_update_display (windows);
              info_error (CANT_FIND_WIND);
              info_session ();
              exit (0);
            }

          active_window = largest;
          window = window_make_window (node);
          if (window)
            {
              window_tile_windows (TILE_INTERNALS);
              remember_window_and_node (window, node);
            }
          else
            {
              display_update_display (windows);
              info_error (WIN_TOO_SMALL);
              info_session ();
              exit (0);
            }
        }
d148 1
a148 1
  initialize_info_session (initial_node, 1);
d158 1
a158 1
  initialize_info_session (initial_node, 1);
d168 1
a168 1
    (_("Welcome to Info version %s. \"\\[get-help-window]\" for help, \"\\[menu-item]\" for menu item."));
d178 1
d180 1
a180 1
  info_last_executed_command = NULL;
d205 1
a205 1
         goal column for this window. */
d207 2
a208 2
          (info_last_executed_command != info_prev_line))
        active_window->goal_column = -1;
d211 4
a214 4
        {
          lk = echo_area_last_command_was_kill;
          echo_area_prep_read ();
        }
d217 1
a217 1
        display_update_display (windows);
d226 1
a226 1
         the echo_area if it is not currently active. */
d228 1
a228 1
        window_clear_echo_area ();
d236 18
a253 18
        {
          /* Echo area commands that do killing increment the value of
             ECHO_AREA_LAST_COMMAND_WAS_KILL.  Thus, if there is no
             change in the value of this variable, the last command
             executed was not a kill command. */
          if (lk == echo_area_last_command_was_kill)
            echo_area_last_command_was_kill = 0;

          if (ea_last_executed_command == ea_newline ||
              info_aborted_echo_area)
            {
              ea_last_executed_command = (VFunction *)NULL;
              done = 1;
            }

          if (info_last_executed_command == info_quit)
            quit_info_immediately = 1;
        }
d255 1
a255 1
        done = 1;
d263 1
a263 1
   and display systems.  If CLEAR_SCREEN is 0, don't clear the screen.  */
d265 1
a265 1
initialize_info_session (node, clear_screen)
a266 1
     int clear_screen;
d268 3
a270 1
  char *term_name = getenv ("TERM");
d276 1
a276 1
        term_name = "dumb";
d282 1
a282 6
  if (clear_screen)
    {
      terminal_prep_terminal ();
      terminal_clear_screen ();
    }

d293 1
a293 2
  /* If input has not been redirected yet, make it come from unbuffered
     standard input. */
d295 1
a295 4
    {
      setbuf(stdin, NULL); 
      info_input_stream = stdin;
    }
d364 2
d367 1
a367 1
  INFO_WINDOW *info_win = get_info_window_of_window (window);
d382 1
a382 1
                            info_windows_slots, 10, INFO_WINDOW *);
d386 11
a396 9
     same as the current saved node and pagetop, don't really add this to
     the list of history nodes.  This may happen only at the very
     beginning of the program, I'm not sure.  --karl  */
  if (info_win->nodes
      && info_win->current >= 0
      && info_win->nodes[info_win->current]->contents == node->contents
      && info_win->pagetops[info_win->current] == window->pagetop
      && info_win->points[info_win->current] == window->point)
  return;
d404 9
a412 7
      info_win->nodes_slots += 20;
      info_win->nodes = (NODE **) xrealloc (info_win->nodes,
                                      info_win->nodes_slots * sizeof (NODE *));
      info_win->pagetops = (int *) xrealloc (info_win->pagetops,
                                      info_win->nodes_slots * sizeof (int));
      info_win->points = (long *) xrealloc (info_win->points,
                                      info_win->nodes_slots * sizeof (long));
d419 1
a419 1
  info_win->nodes[info_win->nodes_index] = NULL;
d430 1
d437 2
a438 2
        if (win == info_windows[i]->window)
          break;
d441 1
a441 1
        abort ();
d462 4
a465 4
        {
          info_windows[i] = info_windows[i + 1];
          i++;
        }
d471 12
a482 12
        {
          /* Free the node structures which held onto internal node contents
             here.  This doesn't free the contents; we have a garbage collector
             which does that. */
          for (i = 0; info_win->nodes[i]; i++)
            if (internal_info_node_p (info_win->nodes[i]))
              free (info_win->nodes[i]);
          free (info_win->nodes);

          maybe_free (info_win->pagetops);
          maybe_free (info_win->points);
        }
d513 3
a515 3
/*                                                                  */
/*                     Info Movement Commands                       */
/*                                                                  */
d559 2
a560 2
          (((window->height - amount) * 10) < window->height))
        return;
d574 2
a575 2
          (((window->height - amount) * 10) < window->height))
        return;
d623 1
a623 1
        return;
d635 1
a635 1
DECLARE_INFO_COMMAND (info_next_line, _("Move down to the next line"))
d650 1
a650 1
DECLARE_INFO_COMMAND (info_prev_line, _("Move up to the previous line"))
d665 1
a665 1
DECLARE_INFO_COMMAND (info_end_of_line, _("Move to the end of the line"))
d685 1
a685 1
DECLARE_INFO_COMMAND (info_beginning_of_line, _("Move to the start of the line"))
d704 1
a704 1
DECLARE_INFO_COMMAND (info_forward_char, _("Move forward a character"))
d713 1
a713 1
        window->point = window->node->nodelen - 1;
d720 1
a720 1
DECLARE_INFO_COMMAND (info_backward_char, _("Move backward a character"))
d729 1
a729 1
        window->point = 0;
d738 1
a738 1
DECLARE_INFO_COMMAND (info_forward_word, _("Move forward a word"))
d757 1
a757 1
        return;
d760 1
a760 1
         Then, move forward until we hit a non-alphabetic character. */
d764 8
a771 8
        {
          while (++point < end)
            {
              c = buffer[point];
              if (alphabetic (c))
                break;
            }
        }
d776 5
a780 5
        {
          c = buffer[point];
          if (!alphabetic (c))
            break;
        }
d787 1
a787 1
DECLARE_INFO_COMMAND (info_backward_word, _("Move backward a word"))
d805 1
a805 1
        break;
d808 1
a808 1
         characters just before point. */
d813 8
a820 8
        {
          while (--point)
            {
              c = buffer[point - 1];
              if (alphabetic (c))
                break;
            }
        }
d823 7
a829 7
        {
          c = buffer[point - 1];
          if (!alphabetic (c))
            break;
          else
            --point;
        }
d861 1
a861 1
    sprintf (td_buffer, "%s%s", counter_names[i], count > 2 ? _(" times") : "");
d863 1
a863 1
    sprintf (td_buffer, _("%d times"), count);
d872 5
a876 5
   IS_Continuous        Try to get first menu item, or failing that, the
                        "Next:" pointer, or failing that, the "Up:" and
                        "Next:" of the up.
   IS_NextOnly          Try to get "Next:" menu item.
   IS_PageOnly          Simply give up at the bottom of a node. */
d901 1
a901 1
        info_error (_("No \"Next\" pointer for this node."));
d903 4
a906 4
        {
          window_message_in_echo_area (_("Following \"Next\" node..."));
          info_handle_pointer (_("Next"), window);
        }
d911 120
a1030 120
        /* First things first.  If this node contains a menu, move down
           into the menu. */
        {
          REFERENCE **menu;

          menu = info_menu_of_node (window->node);

          if (menu)
            {
              info_free_references (menu);
              window_message_in_echo_area (_("Selecting first menu item..."));
              info_menu_digit (window, 1, '1');
              return;
            }
        }

        /* Okay, this node does not contain a menu.  If it contains a
           "Next:" pointer, use that. */
        info_next_label_of_node (window->node);
        if (info_label_was_found)
          {
            window_message_in_echo_area (_("Selecting \"Next\" node..."));
            info_handle_pointer (_("Next"), window);
            return;
          }

        /* Okay, there wasn't a "Next:" for this node.  Move "Up:" until we
           can move "Next:".  If that isn't possible, complain that there
           are no more nodes. */
        {
          int up_counter, old_current;
          INFO_WINDOW *info_win;

          /* Remember the current node and location. */
          info_win = get_info_window_of_window (window);
          old_current = info_win->current;

          /* Back up through the "Up:" pointers until we have found a "Next:"
             that isn't the same as the first menu item found in that node. */
          up_counter = 0;
          while (!info_error_was_printed)
            {
              info_up_label_of_node (window->node);
              if (info_label_was_found)
                {
                  info_handle_pointer (_("Up"), window);
                  if (info_error_was_printed)
                    continue;

                  up_counter++;

                  info_next_label_of_node (window->node);

                  /* If no "Next" pointer, keep backing up. */
                  if (!info_label_was_found)
                    continue;

                  /* If this node's first menu item is the same as this node's
                     Next pointer, keep backing up. */
                  if (!info_parsed_filename)
                    {
                      REFERENCE **menu;
                      char *next_nodename;

                      /* Remember the name of the Next node, since reading
                         the menu can overwrite the contents of the
                         info_parsed_xxx strings. */
                      next_nodename = xstrdup (info_parsed_nodename);

                      menu = info_menu_of_node (window->node);
                      if (menu &&
                          (strcmp
                           (menu[0]->nodename, next_nodename) == 0))
                        {
                          info_free_references (menu);
                          free (next_nodename);
                          continue;
                        }
                      else
                        {
                          /* Restore the world to where it was before
                             reading the menu contents. */
                          info_free_references (menu);
                          free (next_nodename);
                          info_next_label_of_node (window->node);
                        }
                    }

                  /* This node has a "Next" pointer, and it is not the
                     same as the first menu item found in this node. */
                  window_message_in_echo_area
                    ("Moving \"Up\" %s, then \"Next\".",
                     times_description (up_counter));

                  info_handle_pointer (_("Next"), window);
                  return;
                }
              else
                {
                  /* No more "Up" pointers.  Print an error, and call it
                     quits. */
                  register int i;

                  for (i = 0; i < up_counter; i++)
                    {
                      info_win->nodes_index--;
                      free (info_win->nodes[info_win->nodes_index]);
                      info_win->nodes[info_win->nodes_index] = (NODE *)NULL;
                    }
                  info_win->current = old_current;
                  window->node = info_win->nodes[old_current];
                  window->pagetop = info_win->pagetops[old_current];
                  window->point = info_win->points[old_current];
                  recalculate_line_starts (window);
                  window->flags |= W_UpdateWindow;
                  info_error (_("No more nodes."));
                }
            }
        }
        break;
d1050 1
a1050 1
        info_error (_("No \"Prev\" for this node."));
d1052 4
a1055 4
        {
          window_message_in_echo_area (_("Moving \"Prev\" in this window."));
          info_handle_pointer (_("Prev"), window);
        }
d1062 10
a1071 10
        {
          info_up_label_of_node (window->node);
          if (!info_parsed_nodename && !info_parsed_filename)
            info_error (_("No \"Prev\" or \"Up\" for this node."));
          else
            {
              window_message_in_echo_area (_("Moving \"Up\" in this window."));
              info_handle_pointer (_("Up"), window);
            }
        }
d1073 48
a1120 48
        {
          REFERENCE **menu;
          int inhibit_menu_traversing = 0;

          /* Watch out!  If this node's Prev is the same as the Up, then
             move Up.  Otherwise, we could move Prev, and then to the last
             menu item in the Prev.  This would cause the user to loop
             through a subsection of the info file. */
          if (!info_parsed_filename && info_parsed_nodename)
            {
              char *pnode;

              pnode = xstrdup (info_parsed_nodename);
              info_up_label_of_node (window->node);

              if (!info_parsed_filename && info_parsed_nodename &&
                  strcmp (info_parsed_nodename, pnode) == 0)
                {
                  /* The nodes are the same.  Inhibit moving to the last
                     menu item. */
                  free (pnode);
                  inhibit_menu_traversing = 1;
                }
              else
                {
                  free (pnode);
                  info_prev_label_of_node (window->node);
                }
            }

          /* Move to the previous node.  If this node now contains a menu,
             and we have not inhibited movement to it, move to the node
             corresponding to the last menu item. */
          window_message_in_echo_area (_("Moving \"Prev\" in this window."));
          info_handle_pointer (_("Prev"), window);

          if (!inhibit_menu_traversing)
            {
              while (!info_error_was_printed &&
                     (menu = info_menu_of_node (window->node)))
                {
                  info_free_references (menu);
                  window_message_in_echo_area
                    (_("Moving to \"Prev\"'s last menu item."));
                  info_menu_digit (window, 1, '0');
                }
            }
        }
d1127 1
a1127 1
                      _("Move forwards or down through node structure"))
d1134 4
a1137 4
        {
          forward_move_node_structure (window, IS_Continuous);
          count--;
        }
d1143 1
a1143 1
                      _("Move backwards or up through node structure"))
d1150 4
a1153 4
        {
          backward_move_node_structure (window, IS_Continuous);
          count--;
        }
d1158 1
a1158 1
DECLARE_INFO_COMMAND (info_scroll_forward, _("Scroll forward in this window"))
d1167 3
a1169 3
         lines to the top of this window,  Or, if at bottom of window,
         and the user wishes to scroll through nodes get the "Next" node
         for this window. */
d1171 2
a1172 2
        {
          desired_top = window->pagetop + (window->height - 2);
d1174 15
a1188 15
          /* If there are no more lines to scroll here, error, or get
             another node, depending on INFO_SCROLL_BEHAVIOUR. */
          if (desired_top > window->line_count)
            {
              int behaviour = info_scroll_behaviour;

              /* Here is a hack.  If the key being used is not SPC, do the
                 PageOnly behaviour. */
              if (key != SPC && key != DEL)
                behaviour = IS_PageOnly;

              forward_move_node_structure (window, behaviour);
              return;
            }
        }
d1190 1
a1190 1
        desired_top = window->pagetop + count;
d1193 1
a1193 1
        desired_top = window->line_count - 2;
d1196 1
a1196 1
        return;
d1198 1
a1198 1
        set_window_pagetop (window, desired_top);
d1203 1
a1203 1
DECLARE_INFO_COMMAND (info_scroll_backward, _("Scroll backward in this window"))
d1212 2
a1213 2
         to the bottom of this window, or move to the previous, or Up'th
         node. */
d1215 2
a1216 2
        {
          desired_top = window->pagetop - (window->height - 2);
d1218 14
a1231 14
          if ((desired_top < 0) && (window->pagetop == 0))
            {
              int behaviour = info_scroll_behaviour;

              /* Same kind of hack as in info_scroll_forward.  If the key
                 used to invoke this command is not DEL, do only the PageOnly
                 behaviour. */
              if (key != DEL && key != SPC)
                behaviour = IS_PageOnly;

              backward_move_node_structure (window, behaviour);
              return;
            }
        }
d1233 1
a1233 1
        desired_top = window->pagetop - count;
d1236 1
a1236 1
        desired_top = 0;
d1243 1
a1243 1
DECLARE_INFO_COMMAND (info_beginning_of_node, _("Move to the start of this node"))
d1250 1
a1250 1
DECLARE_INFO_COMMAND (info_end_of_node, _("Move to the end of this node"))
d1257 3
a1259 3
/*                                                                  */
/*                 Commands for Manipulating Windows                */
/*                                                                  */
d1263 1
a1263 1
DECLARE_INFO_COMMAND (info_next_window, _("Select the next window"))
d1281 1
a1281 1
        window = window->next;
d1283 6
a1288 6
        {
          if (window == the_echo_area || !echo_area_is_active)
            window = windows;
          else
            window = the_echo_area;
        }
d1294 1
a1294 1
        info_get_or_remove_footnotes (window);
d1302 1
a1302 1
DECLARE_INFO_COMMAND (info_prev_window, _("Select the previous window"))
d1321 1
a1321 1
         are in the first window, find the last window in the chain. */
d1323 3
a1325 3
          (window == windows && !echo_area_is_active))
        {
          register WINDOW *win, *last;
d1327 2
a1328 2
          for (win = windows; win; win = win->next)
            last = win;
d1330 2
a1331 2
          window = last;
        }
d1333 6
a1338 6
        {
          if (window == windows)
            window = the_echo_area;
          else
            window = window->prev;
        }
d1344 1
a1344 1
        info_get_or_remove_footnotes (window);
d1353 1
a1353 1
DECLARE_INFO_COMMAND (info_split_window, _("Split the current window"))
d1377 2
a1378 2
        {
          int start, end, amount;
d1380 5
a1384 5
          start = split->first_row;
          end = start + window->height;
          amount = split->height + 1;
          display_scroll_display (start, end, amount);
        }
d1391 1
a1391 1
         something else in it. */
d1393 26
a1418 26
        {
          register int i, j;
          INFO_WINDOW *iw;
          NODE *node = (NODE *)NULL;
          char *filename;

          for (i = 0; (iw = info_windows[i]); i++)
            {
              for (j = 0; j < iw->nodes_index; j++)
                if (!internal_info_node_p (iw->nodes[j]))
                  {
                    if (iw->nodes[j]->parent)
                      filename = iw->nodes[j]->parent;
                    else
                      filename = iw->nodes[j]->filename;

                    node = info_get_node (filename, iw->nodes[j]->nodename);
                    if (node)
                      {
                        window_set_node_of_window (split, node);
                        i = info_windows_index - 1;
                        break;
                      }
                  }
            }
        }
d1422 1
a1422 1
        window_tile_windows (DONT_TILE_INTERNALS);
d1424 1
a1424 1
        window_adjust_pagetop (split);
d1434 1
a1434 1
DECLARE_INFO_COMMAND (info_delete_window, _("Delete the current window"))
d1442 1
a1442 1
      info_error (_("Cannot delete a permanent window"));
d1449 1
a1449 1
        info_get_or_remove_footnotes (active_window);
d1452 1
a1452 1
        window_tile_windows (DONT_TILE_INTERNALS);
d1465 1
a1465 1
         our list of remembered windows. */
d1470 1
a1470 1
        echo_area_inform_of_deleted_window (window);
d1475 1
a1475 1
DECLARE_INFO_COMMAND (info_keep_one_window, _("Delete all other windows"))
d1477 1
a1477 1
  int num_deleted;              /* The number of windows we deleted. */
d1493 2
a1494 2
         are found, we are done.  A window is eligible for deletion if
         is it not permanent, and it is not WINDOW. */
d1496 2
a1497 2
        if (win != window && ((win->flags & W_WindowIsPerm) == 0))
          break;
d1500 1
a1500 1
        break;
d1521 1
a1521 1
DECLARE_INFO_COMMAND (info_scroll_other_window, _("Scroll the other window"))
d1541 1
a1541 1
DECLARE_INFO_COMMAND (info_grow_window, _("Grow (or shrink) this window"))
d1552 1
a1552 1
    _("Divide the available screen space among the visible windows"))
d1559 1
a1559 1
              _("Toggle the state of line wrapping in the current window"))
d1565 3
a1567 3
/*                                                                  */
/*                      Info Node Commands                          */
/*                                                                  */
d1589 1
a1589 1
    filename = xstrdup (filename);
d1592 1
a1592 1
    nodename = xstrdup (entry->nodename);
d1594 1
a1594 1
    nodename = xstrdup ("Top");
d1604 1
a1604 1
        file_system_error = xstrdup (info_recent_file_error);
d1607 8
a1614 8
        {
          node = info_get_node (entry->label, "Top");
          if (!node && info_recent_file_error)
            {
              maybe_free (file_system_error);
              file_system_error = xstrdup (info_recent_file_error);
            }
        }
d1620 1
a1620 1
        info_error (file_system_error);
d1622 1
a1622 1
        info_error (CANT_FIND_NODE, nodename);
d1672 1
a1672 1
        filename = xstrdup (info_parsed_filename);
d1674 6
a1679 6
        {
          if (window->node->parent)
            filename = xstrdup (window->node->parent);
          else if (window->node->filename)
            filename = xstrdup (window->node->filename);
        }
d1682 1
a1682 1
        nodename = xstrdup (info_parsed_nodename);
d1684 1
a1684 1
        nodename = xstrdup ("Top");
d1689 2
a1690 2
        {
          INFO_WINDOW *info_win;
d1692 9
a1700 9
          info_win = get_info_window_of_window (window);
          if (info_win)
            {
              info_win->pagetops[info_win->current] = window->pagetop;
              info_win->points[info_win->current] = window->point;
            }
          set_remembered_pagetop_and_point (window);
          info_set_node_of_window (window, node);
        }
d1702 6
a1707 6
        {
          if (info_recent_file_error)
            info_error (info_recent_file_error);
          else
            info_error (CANT_FILE_NODE, filename, nodename);
        }
d1720 1
a1720 1
DECLARE_INFO_COMMAND (info_next_node, _("Select the `Next' node"))
d1723 1
a1723 1
  info_handle_pointer (_("Next"), window);
d1728 1
a1728 1
DECLARE_INFO_COMMAND (info_prev_node, _("Select the `Prev' node"))
d1731 1
a1731 1
  info_handle_pointer (_("Prev"), window);
d1736 1
a1736 1
DECLARE_INFO_COMMAND (info_up_node, _("Select the `Up' node"))
d1739 1
a1739 1
  info_handle_pointer (_("Up"), window);
d1743 1
a1743 1
DECLARE_INFO_COMMAND (info_last_node, _("Select the last node in this file"))
d1756 1
a1756 1
    info_error (_("This window has no additional nodes"));
d1765 1
a1765 1
DECLARE_INFO_COMMAND (info_first_node, _("Select the first node in this file"))
d1774 1
a1774 1
    info_error (_("This window has no additional nodes"));
d1782 40
d1824 1
a1824 1
   _("Select the last item in this node's menu"))
d1830 1
a1830 1
DECLARE_INFO_COMMAND (info_menu_digit, _("Select this menu item"))
d1851 3
a1853 3
      for (i = 0; (entry = menu[i]); i++)
        if (i == item - 1)
          break;
d1859 1
a1859 1
    info_error (_("There aren't %d items in this menu."), item);
d1886 1
a1886 1
        info_error (NO_MENU_NODE);
d1888 1
a1888 1
        info_error (NO_XREF_NODE);
d1902 1
a1902 1
        SEARCH_BINDING binding;
d1904 18
a1921 18
        binding.buffer = window->node->contents;
        binding.start = window->line_starts[point_line] - binding.buffer;
        if (window->line_starts[point_line + 1])
          binding.end = window->line_starts[point_line + 1] - binding.buffer;
        else
          binding.end = window->node->nodelen;
        binding.flags = 0;

        if (builder == info_menu_of_node)
          {
            if (point_line)
              {
                binding.start--;
                refs = info_menu_items (&binding);
              }
          }
        else
          {
d1923 3
a1925 3
            if (window->node->flags & N_IsManPage)
              refs = manpage_xrefs_in_binding (window->node, &binding);
            else
d1927 2
a1928 2
            refs = info_xrefs (&binding);
          }
d1930 43
a1972 43
        if (refs)
          {
            if ((strcmp (refs[0]->label, "Menu") != 0) ||
                (builder == info_xrefs_of_node))
              {
                int which = 0;

                /* Find the closest reference to point. */
                if (builder == info_xrefs_of_node)
                  {
                    int closest = -1;

                    for (; refs[which]; which++)
                      {
                        if ((window->point >= refs[which]->start) &&
                            (window->point <= refs[which]->end))
                          {
                            closest = which;
                            break;
                          }
                        else if (window->point < refs[which]->start)
                          {
                            break;
                          }
                      }
                    if (closest == -1)
                      which--;
                    else
                      which = closest;
                  }

                defentry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                defentry->label = xstrdup (refs[which]->label);
                defentry->filename = refs[which]->filename;
                defentry->nodename = refs[which]->nodename;

                if (defentry->filename)
                  defentry->filename = xstrdup (defentry->filename);
                if (defentry->nodename)
                  defentry->nodename = xstrdup (defentry->nodename);
              }
            info_free_references (refs);
          }
d1983 1
a1983 1
        prompt = (char *)xmalloc (20 + strlen (defentry->label));
d1985 1
a1985 1
        prompt = (char *)xmalloc (20);
d1988 6
a1993 6
        {
          if (defentry)
            sprintf (prompt, _("Menu item (%s): "), defentry->label);
          else
            sprintf (prompt, _("Menu item: "));
        }
d1995 6
a2000 6
        {
          if (defentry)
            sprintf (prompt, _("Follow xref (%s): "), defentry->label);
          else
            sprintf (prompt, _("Follow xref: "));
        }
d2009 6
a2014 6
        {
          maybe_free (defentry);
          info_free_references (menu);
          info_abort_key (window, 0, 0);
          return;
        }
d2018 7
a2024 7
        {
          free (line);
          if (defentry)
            line = xstrdup (defentry->label);
          else
            line = (char *)NULL;
        }
d2029 1
a2029 1
         that, otherwise return. */
d2031 1
a2031 1
        return;
d2033 1
a2033 1
        line = xstrdup (defentry->label);
d2042 1
a2042 1
        info_error (_("The reference disappeared! (%s)."), line);
d2044 2
a2045 2
        {
          NODE *orig;
d2047 22
a2068 22
          orig = window->node;
          info_select_reference (window, entry);
          if ((builder == info_xrefs_of_node) && (window->node != orig))
            {
              long offset;
              long start;

              if (window->line_count > 0)
                start = window->line_starts[1] - window->node->contents;
              else
                start = 0;

              offset =
                info_target_search_node (window->node, entry->label, start);

              if (offset != -1)
                {
                  window->point = offset;
                  window_adjust_pagetop (window);
                }
            }
        }
d2072 6
a2077 6
        {
          free (defentry->label);
          maybe_free (defentry->filename);
          maybe_free (defentry->nodename);
          free (defentry);
        }
d2088 1
a2088 1
DECLARE_INFO_COMMAND (info_menu_item, _("Read a menu item and select its node"))
d2096 1
a2096 1
  (info_xref_item, _("Read a footnote or cross reference and select its node"))
d2102 1
a2102 1
DECLARE_INFO_COMMAND (info_find_menu, _("Move to the start of this node's menu"))
d2126 1
a2126 1
  _("Visit as many menu items at once as possible"))
d2144 1
a2144 1
        info_error (WIN_TOO_SMALL);
d2146 4
a2149 4
        {
          active_window = new;
          info_select_reference (new, entry);
        }
d2154 1
a2154 1
DECLARE_INFO_COMMAND (info_goto_node, _("Read a node name and select it"))
d2157 1
d2173 42
a2214 42
        FILE_BUFFER *fb;
        REFERENCE *entry;
        int this_is_the_current_fb;

        fb = info_loaded_files[fbi];
        this_is_the_current_fb = (current == fb);

        entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
        entry->filename = entry->nodename = (char *)NULL;
        entry->label = (char *)xmalloc (4 + strlen (fb->filename));
        sprintf (entry->label, "(%s)*", fb->filename);

        add_pointer_to_array
          (entry, items_index, items, items_slots, 10, REFERENCE *);

        if (fb->tags)
          {
            for (i = 0; fb->tags[i]; i++)
              {
                entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                entry->filename = entry->nodename = (char *)NULL;
                entry->label = (char *) xmalloc
                  (4 + strlen (fb->filename) + strlen (fb->tags[i]->nodename));
                sprintf (entry->label, "(%s)%s",
                         fb->filename, fb->tags[i]->nodename);

                add_pointer_to_array
                  (entry, items_index, items, items_slots, 100, REFERENCE *);
              }         

            if (this_is_the_current_fb)
              {
                for (i = 0; fb->tags[i]; i++)
                  {
                    entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
                    entry->filename = entry->nodename = (char *)NULL;
                    entry->label = xstrdup (fb->tags[i]->nodename);
                    add_pointer_to_array (entry, items_index, items,
                                          items_slots, 100, REFERENCE *);
                  }
              }
          }
d2216 1
a2216 1
    line = info_read_maybe_completing (window, _("Goto Node: "), items);
d2220 1
a2220 1
  line = info_read_in_echo_area (window, _("Goto Node: "));
d2241 1
a2241 1
DECLARE_INFO_COMMAND (info_man, _("Read a manpage reference and select it"))
d2244 1
d2246 1
a2246 1
  line = info_read_in_echo_area (window, _("Get Manpage: "));
d2261 1
a2261 1
        (4 + strlen (MANPAGE_FILE_BUFFER_NAME) + strlen (line));
d2276 1
a2276 1
DECLARE_INFO_COMMAND (info_top_node, _("Select the node `Top' in this file"))
d2278 1
a2278 1
  info_parse_and_select (_("Top"), window);
d2282 1
a2282 1
DECLARE_INFO_COMMAND (info_dir_node, _("Select the node `(dir)'"))
d2287 3
a2289 6

/* Read the name of a node to kill.  The list of available nodes comes
   from the nodes appearing in the current window configuration. */
static char *
read_nodename_to_kill (window)
     WINDOW *window;
d2291 4
a2294 7
  int iw;
  char *nodename;
  INFO_WINDOW *info_win;
  REFERENCE **menu = NULL;
  int menu_index = 0, menu_slots = 0;
  char *default_nodename = xstrdup (active_window->node->nodename);
  char *prompt = xmalloc (40 + strlen (default_nodename));
d2296 6
a2301 1
  sprintf (prompt, _("Kill node (%s): "), default_nodename);
d2303 3
a2305 5
  for (iw = 0; (info_win = info_windows[iw]); iw++)
    {
      REFERENCE *entry = (REFERENCE *)xmalloc (sizeof (REFERENCE));
      entry->label = xstrdup (info_win->window->node->nodename);
      entry->filename = entry->nodename = (char *)NULL;
d2307 3
a2309 3
      add_pointer_to_array (entry, menu_index, menu, menu_slots, 10,
                            REFERENCE *);
    }
d2311 3
a2313 13
  nodename = info_read_completing_in_echo_area (window, prompt, menu);
  free (prompt);
  info_free_references (menu);
  if (nodename && !*nodename)
    {
      free (nodename);
      nodename = default_nodename;
    }
  else
    free (default_nodename);

  return nodename;
}
d2315 15
a2330 11
/* Delete NODENAME from this window, showing the most
   recently selected node in this window. */
static void
kill_node (window, nodename)
     WINDOW *window;
     char *nodename;
{
  int iw, i;
  INFO_WINDOW *info_win;
  NODE *temp;
  
d2339 1
a2339 1
  for (iw = 0; (info_win = info_windows[iw]); iw++)
d2346 1
a2346 1
        info_error (_("Cannot kill node `%s'"), nodename);
d2348 1
a2348 1
        window_clear_echo_area ();
d2356 1
a2356 1
      info_error (_("Cannot kill the last node"));
d2360 3
a2362 2
  /* INFO_WIN contains the node that the user wants to stop viewing.  Delete
     this node from the list of nodes previously shown in this window. */
d2381 1
a2381 1
        stealer = info_windows[iw + 1];
d2383 1
a2383 1
        stealer = info_windows[0];
d2386 1
a2386 1
         recently loaded one, get the most recently loaded one. */
d2388 1
a2388 1
        which = stealer->nodes_index - 1;
d2391 1
a2391 1
         use that one. */
d2393 1
a2393 1
        which = stealer->current - 1;
d2397 1
a2397 1
        which = stealer->current;
d2401 13
a2413 12
        NODE *copy = xmalloc (sizeof (NODE));
        
        temp = stealer->nodes[which];
        point = stealer->points[which];
        pagetop = stealer->pagetops[which];

        copy->filename = temp->filename;
        copy->parent = temp->parent;
        copy->nodename = temp->nodename;
        copy->contents = temp->contents;
        copy->nodelen = temp->nodelen;
        copy->flags = temp->flags;
d2415 1
a2415 1
        temp = copy;
a2427 1

a2429 21

  if (auto_footnotes_p)
    info_get_or_remove_footnotes (window);
}

/* Kill current node, thus going back one in the node history.  I (karl)
   do not think this is completely correct yet, because of the
   window-changing stuff in kill_node, but it's a lot better than the
   previous implementation, which did not account for nodes being
   visited twice at all.  */
DECLARE_INFO_COMMAND (info_history_node,
                      _("Select the most recently selected node"))
{
  kill_node (window, active_window->node->nodename);
}

/* Kill named node.  */
DECLARE_INFO_COMMAND (info_kill_node, _("Kill this node"))
{
  char *nodename = read_nodename_to_kill (window);
  kill_node (window, nodename);
a2431 1

d2433 1
a2433 1
DECLARE_INFO_COMMAND (info_view_file, _("Read the name of a file and select it"))
d2437 1
a2437 1
  line = info_read_in_echo_area (window, _("Find file: "));
d2450 6
a2455 6
        {
          if (info_recent_file_error)
            info_error (info_recent_file_error);
          else
            info_error (_("Cannot find \"%s\"."), line);
        }
d2457 4
a2460 4
        {
          set_remembered_pagetop_and_point (active_window);
          info_set_node_of_window (window, node);
        }
d2469 3
a2471 3
/*                                                                  */
/*                 Dumping and Printing Nodes                       */
/*                                                                  */
d2501 1
a2501 1
      info_error (_("Could not create output file \"%s\"."), output_filename);
d2514 1
a2514 1
  info_error (_("Done."));
d2546 1
a2546 1
        info_error (info_recent_file_error);
d2548 7
a2554 7
        {
          if (filename && *nodename != '(')
            info_error
              (CANT_FILE_NODE, filename_non_directory (filename), nodename);
          else
            info_error (CANT_FIND_NODE, nodename);
        }
d2562 2
a2563 2
        free (node);
        return;
d2566 1
a2566 1
                        dumped_already_slots, 50, char *);
d2571 2
a2572 2
    info_error (_("Writing node \"(%s)%s\"..."),
                filename_non_directory (node->filename), node->nodename);
d2574 1
a2574 1
    info_error (_("Writing node \"%s\"..."), node->nodename);
d2587 1
a2587 1
        menu = info_menu_of_node (node);
d2590 11
a2600 11
        {
          for (i = 0; menu[i]; i++)
            {
              /* We don't dump Info files which are different than the
                 current one. */
              if (!menu[i]->filename)
                dump_node_to_stream
                  (filename, menu[i]->nodename, stream, dump_subnodes);
            }
          info_free_references (menu);
        }
d2626 1
a2626 1
      info_error (_("Could not create output file \"%s\"."), filename);
d2643 1
a2643 1
  info_error (_("Done."));
d2652 1
a2652 1
 _("Pipe the contents of this node through INFO_PRINT_COMMAND"))
d2662 1
d2664 2
a2665 1
  char *print_command = getenv ("INFO_PRINT_COMMAND");
d2674 1
a2674 1
      info_error (_("Cannot open pipe to \"%s\"."), print_command);
d2681 2
a2682 2
    info_error (_("Printing node \"(%s)%s\"..."),
                filename_non_directory (node->filename), node->nodename);
d2684 1
a2684 1
    info_error (_("Printing node \"%s\"..."), node->nodename);
d2691 1
a2691 1
  info_error (_("Done."));
d2704 3
a2706 3
/*                                                                  */
/*                    Info Searching Commands                       */
/*                                                                  */
d2781 1
a2781 1
        window_set_node_of_window (window, node);
d2801 1
a2801 1
  target = xstrdup (string);
d2812 1
a2812 1
        break;
d2846 1
a2846 1
        (string, window->node, window->point + dir, window, dir);
d2851 1
a2851 1
        (string, window->node, window->point, window, dir);
d2855 1
a2855 1
  last_searched_for_string = xstrdup (string);
d2861 1
a2861 1
        window_clear_echo_area ();
d2882 5
a2886 5
        if (strcmp (initial_nodename, file_buffer->tags[i]->nodename) == 0)
          {
            current_tag = i;
            last_subfile = file_buffer->tags[i]->filename;
          }
d2892 1
a2892 1
        return (-1);
d2895 2
a2896 2
         of the info file until we find the string or return to this
         window's node and point. */
d2898 2
a2899 2
        {
          NODE *node;
d2901 2
a2902 2
          /* Allow C-g to quit the search, failing it if pressed. */
          return_if_control_g (-1);
d2904 1
a2904 1
          current_tag += dir;
d2906 56
a2961 56
          if (current_tag < 0)
            current_tag = number_of_tags - 1;
          else if (current_tag == number_of_tags)
            current_tag = 0;

          tag = file_buffer->tags[current_tag];

          if (!echo_area_is_active && (last_subfile != tag->filename))
            {
              window_message_in_echo_area
                (_("Searching subfile \"%s\"..."),
                 filename_non_directory (tag->filename));

              last_subfile = tag->filename;
            }

          node = info_get_node (file_buffer->filename, tag->nodename);

          if (!node)
            {
              /* If not doing i-search... */
              if (!echo_area_is_active)
                {
                  if (info_recent_file_error)
                    info_error (info_recent_file_error);
                  else
                    info_error (CANT_FILE_NODE,
                                filename_non_directory (file_buffer->filename),
                                tag->nodename);
                }
              return (-1);
            }

          if (dir < 0)
            start = tag->nodelen;

          ret =
            info_search_in_node (string, node, start, window, dir);

          /* Did we find the string in this node? */
          if (ret != -1)
            {
              /* Yes!  We win. */
              remember_window_and_node (window, node);
              if (!echo_area_is_active)
                window_clear_echo_area ();
              return (0);
            }

          /* No.  Free this node, and make sure that we haven't passed
             our starting point. */
          free (node);

          if (strcmp (initial_nodename, tag->nodename) == 0)
            return (-1);
        }
d2966 1
a2966 1
DECLARE_INFO_COMMAND (info_search, _("Read a string and search for it"))
d2986 3
a2988 3
  sprintf (prompt, _("%s for string [%s]: "),
           direction < 0 ? _("Search backward") : _("Search"),
           search_string);
d3002 2
a3003 2
        search_string = (char *)
          xrealloc (search_string, (search_string_size += 50 + strlen (line)));
d3014 1
a3014 1
    info_error (_("Search failed."));
d3023 1
a3023 1
        info_get_or_remove_footnotes (active_window);
d3032 3
a3034 3
/*                                                                  */
/*                      Incremental Searching                       */
/*                                                                  */
d3040 1
a3040 1
                      _("Search interactively for a string as you type it"))
d3046 1
a3046 1
                      _("Search interactively for a string as you type it"))
d3063 4
a3066 4
  WINDOW_STATE_DECL;    /* The node, pagetop and point. */
  int search_index;     /* Offset of the last char in the search string. */
  int direction;        /* The direction that this search is heading in. */
  int failing;          /* Whether or not this search failed. */
d3089 1
a3089 1
                        isearch_states_slots, 20, SEARCH_STATE *);
d3140 1
a3140 1
    prefix = _("I-search backward: ");
d3142 1
a3142 1
    prefix = _("I-search: ");
d3151 7
a3157 7
        {
        case ' ': rep = " "; break;
        case LFD: rep = "\\n"; break;
        case TAB: rep = "\\t"; break;
        default:
          rep = pretty_keyname (string[i]);
        }
d3159 1
a3159 1
        p_rep = (char *)xrealloc (p_rep, p_rep_size += 100);
d3167 2
a3168 2
  sprintf (prompt, "%s%s%s", failing_p ? _("Failing ") : "", prefix,
           p_rep ? p_rep : "");
d3211 1
a3211 1
         it is convenient. */
d3213 4
a3216 4
        {
          display_update_one_window (window);
          display_cursor_at_point (active_window);
        }
d3223 16
a3238 16
        {
          /* User wants to delete one level of search? */
          if (!isearch_states_index)
            {
              terminal_ring_bell ();
              continue;
            }
          else
            {
              pop_isearch
                (window, &isearch_string_index, &dir, &search_result);
              isearch_string[isearch_string_index] = '\0';
              show_isearch_prompt (dir, isearch_string, search_result);
              goto after_search;
            }
        }
d3240 4
a3243 4
        {
          key = info_get_input_char ();
          quoted = 1;
        }
d3249 1
a3249 1
        goto insert_and_search;
d3252 2
a3253 2
        {
          func = window->keymap[key].function;
d3255 75
a3329 75
          /* If this key invokes an incremental search, then this means that
             we will either search again in the same direction, search
             again in the reverse direction, or insert the last search
             string that was accepted through incremental searching. */
          if (func == isearch_forward || func == isearch_backward)
            {
              if ((func == isearch_forward && dir > 0) ||
                  (func == isearch_backward && dir < 0))
                {
                  /* If the user has typed no characters, then insert the
                     last successful search into the current search string. */
                  if (isearch_string_index == 0)
                    {
                      /* Of course, there must be something to insert. */
                      if (last_isearch_accepted)
                        {
                          if (strlen (last_isearch_accepted) + 1 >=
                              isearch_string_size)
                            isearch_string = (char *)
                              xrealloc (isearch_string,
                                        isearch_string_size += 10 +
                                        strlen (last_isearch_accepted));
                          strcpy (isearch_string, last_isearch_accepted);
                          isearch_string_index = strlen (isearch_string);
                          goto search_now;
                        }
                      else
                        continue;
                    }
                  else
                    {
                      /* Search again in the same direction.  This means start
                         from a new place if the last search was successful. */
                      if (search_result == 0)
                        window->point += dir;
                    }
                }
              else
                {
                  /* Reverse the direction of the search. */
                  dir = -dir;
                }
            }
          else if (isprint (key) || func == (VFunction *)NULL)
            {
            insert_and_search:

              if (isearch_string_index + 2 >= isearch_string_size)
                isearch_string = (char *)xrealloc
                  (isearch_string, isearch_string_size += 100);

              isearch_string[isearch_string_index++] = key;
              isearch_string[isearch_string_index] = '\0';
              goto search_now;
            }
          else if (func == info_abort_key)
            {
              /* If C-g pressed, and the search is failing, pop the search
                 stack back to the last unfailed search. */
              if (isearch_states_index && (search_result != 0))
                {
                  terminal_ring_bell ();
                  while (isearch_states_index && (search_result != 0))
                    pop_isearch
                      (window, &isearch_string_index, &dir, &search_result);
                  isearch_string[isearch_string_index] = '\0';
                  show_isearch_prompt (dir, isearch_string, search_result);
                  continue;
                }
              else
                goto exit_search;
            }
          else
            goto exit_search;
        }
d3331 30
a3360 30
        {
        exit_search:
          /* The character is not printable, or it has a function which is
             non-null.  Exit the search, remembering the search string.  If
             the key is not the same as the isearch_terminate_search_key,
             then push it into pending input. */
          if (isearch_string_index && func != info_abort_key)
            {
              maybe_free (last_isearch_accepted);
              last_isearch_accepted = xstrdup (isearch_string);
            }

          if (key != isearch_terminate_search_key)
            info_set_pending_input (key);

          if (func == info_abort_key)
            {
              if (isearch_states_index)
                window_set_state (window, &orig_state);
            }

          if (!echo_area_is_active)
            window_clear_echo_area ();

          if (auto_footnotes_p)
            info_get_or_remove_footnotes (active_window);

          isearch_is_active = 0;
          continue;
        }
d3367 19
a3385 19
        {
          /* Check to see if the current search string is right here.  If
             we are looking at it, then don't bother calling the search
             function. */
          if (((dir < 0) &&
               (strncasecmp (window->node->contents + window->point,
                             isearch_string, isearch_string_index) == 0)) ||
              ((dir > 0) &&
               ((window->point - isearch_string_index) >= 0) &&
               (strncasecmp (window->node->contents +
                             (window->point - (isearch_string_index - 1)),
                             isearch_string, isearch_string_index) == 0)))
            {
              if (dir > 0)
                window->point++;
            }
          else
            search_result = info_search_internal (isearch_string, window, dir);
        }
d3388 1
a3388 1
         then ring the terminal bell. */
d3390 1
a3390 1
        terminal_ring_bell ();
d3396 11
a3406 11
        {
          if ((mystate.node == window->node) &&
              (mystate.pagetop != window->pagetop))
            {
              int newtop = window->pagetop;
              window->pagetop = mystate.pagetop;
              set_window_pagetop (window, newtop);
            }
          display_update_one_window (window);
          display_cursor_at_point (window);
        }
d3436 1
a3436 1
  for (fb_index = 0; (fb = info_loaded_files[fb_index]); fb_index++)
d3442 1
a3442 1
        continue;
d3445 2
a3446 2
         gc it.  This means that the user-variable "gc-compressed-files"
         is non-zero. */
d3448 1
a3448 1
        continue;
d3452 1
a3452 1
        continue;
d3455 13
a3467 13
         this file. */
      for (iw_index = 0; (iw = info_windows[iw_index]); iw_index++)
        {
          for (i = 0; iw->nodes && iw->nodes[i]; i++)
            {
              if ((strcmp (fb->fullpath, iw->nodes[i]->filename) == 0) ||
                  (strcmp (fb->filename, iw->nodes[i]->filename) == 0))
                {
                  fb_referenced_p = 1;
                  break;
                }
            }
        }
d3471 4
a3474 4
        {
          free (fb->contents);
          fb->contents = (char *)NULL;
        }
d3479 3
a3481 3
/*                                                                  */
/*                Traversing and Selecting References               */
/*                                                                  */
d3516 2
a3517 2
        firstmenu = info_search_in_node
          (INFO_MENU_ENTRY_LABEL, node, firstmenu + dir, (WINDOW *)NULL, dir);
d3532 1
a3532 1
      info_error (_("No cross references in this node."));
d3556 2
a3557 2
        nextmenu = info_search_in_node
          (INFO_MENU_ENTRY_LABEL, node, nextmenu + dir, (WINDOW *)NULL, dir);
d3566 2
a3567 2
          ((dir == -1) && (nextmenu > nextxref)))
        placement = nextmenu + 1;
d3569 1
a3569 1
        placement = nextxref;
d3581 7
a3587 7
        {
          if (((dir == 1) && (firstmenu < firstxref)) ||
              ((dir == -1) && (firstmenu > firstxref)))
            placement = firstmenu + 1;
          else
            placement = firstxref;
        }
d3589 1
a3589 1
        placement = firstmenu + 1;
d3591 1
a3591 1
        placement = firstxref;
d3599 1
a3599 1
                      _("Move to the previous cross reference"))
d3608 1
a3608 1
                      _("Move to the next cross reference"))
d3618 1
a3618 1
                      _("Select reference or menu item appearing on this line"))
d3634 3
a3636 3
/*                                                                  */
/*                  Miscellaneous Info Commands                     */
/*                                                                  */
d3640 1
a3640 1
DECLARE_INFO_COMMAND (info_abort_key, _("Cancel current operation"))
d3647 1
a3647 1
  info_error (_("Quit"));
d3656 1
a3656 1
   _("Move to the cursor to a specific line of the window"))
d3666 1
a3666 1
        line = (window->height + count) + window->pagetop;
d3668 1
a3668 1
        line = window->pagetop + count;
d3688 1
a3688 1
DECLARE_INFO_COMMAND (info_redraw_display, _("Redraw the display"))
d3705 1
a3705 1
        desired_line = window->height + count;
d3707 1
a3707 1
        desired_line = count;
d3710 1
a3710 1
        desired_line = 0;
d3713 1
a3713 1
        desired_line = window->height - 1;
d3716 1
a3716 1
        return;
d3725 1
a3725 1
DECLARE_INFO_COMMAND (info_quit, _("Quit using Info"))
d3730 3
a3732 3
/*                                                                  */
/*               Reading Keys and Dispatching on Them               */
/*                                                                  */
d3748 1
a3748 1
    info_error (_("Unknown command (%s)."), rep);
d3753 1
a3753 1
      temp = (char *)xmalloc (1 + strlen (rep) + strlen (_("\"\" is invalid")));
d3755 1
a3755 1
      sprintf (temp, _("\"%s\" is invalid"), rep);
d3801 2
a3802 2
               strlen (keyseq_rep) ? " " : "",
               pretty_keyname (keyseq[i]));
d3835 1
a3835 1
  int ready = !info_keyseq_displayed_p; /* ready if new and pending key */
d3840 3
a3842 1
  if (!info_keyseq_displayed_p)
a3843 4
      ready = 1;
      if (!info_any_buffered_input_p () &&
          !info_input_pending_p ())
        {
d3845 2
a3846 2
          struct timeval timer;
          fd_set readfds;
d3848 5
a3852 7
          FD_ZERO (&readfds);
          FD_SET (fileno (info_input_stream), &readfds);
          timer.tv_sec = 1;
          timer.tv_usec = 750;
          ready = select (fileno(info_input_stream)+1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
#else
          ready = 0;
a3853 1
      }
d3872 6
a3877 6
        {
          map = (Keymap)map[ESC].function;
          add_char_to_keyseq (ESC);
          key = UnMeta (key);
          info_dispatch_on_key (key, map);
        }
d3879 3
a3881 3
        {
          dispatch_error (info_keyseq);
        }
d3889 1
a3889 1
        VFunction *func;
d3891 41
a3931 41
        func = map[key].function;
        if (func != (VFunction *)NULL)
          {
            /* Special case info_do_lowercase_version (). */
            if (func == info_do_lowercase_version)
              {
                info_dispatch_on_key (tolower (key), map);
                return;
              }

            add_char_to_keyseq (key);

            if (info_keyseq_displayed_p)
              display_info_keyseq (0);

            {
              WINDOW *where;

              where = active_window;
              (*map[key].function)
                (active_window, info_numeric_arg * info_numeric_arg_sign, key);

              /* If we have input pending, then the last command was a prefix
                 command.  Don't change the value of the last function vars.
                 Otherwise, remember the last command executed in the var
                 appropriate to the window in which it was executed. */
              if (!info_input_pending_p ())
                {
                  if (where == the_echo_area)
                    ea_last_executed_command = map[key].function;
                  else
                    info_last_executed_command = map[key].function;
                }
            }
          }
        else
          {
            add_char_to_keyseq (key);
            dispatch_error (info_keyseq);
            return;
          }
d3938 2
a3939 2
        {
          unsigned char newkey;
d3941 3
a3943 3
          newkey = info_get_another_input_char ();
          info_dispatch_on_key (newkey, (Keymap)map[key].function);
        }
d3945 4
a3948 4
        {
          dispatch_error (info_keyseq);
          return;
        }
d3954 3
a3956 3
/*                                                                  */
/*                      Numeric Arguments                           */
/*                                                                  */
d3973 1
a3973 1
                      _("Add this digit to the current numeric argument"))
d3982 1
a3982 1
                      _("Start (or multiply by 4) the current numeric argument"))
d3997 1
a3997 1
                      _("Internally used by \\[universal-argument]"))
d4005 1
a4005 1
        pure_key = key;
d4007 3
a4009 3
        {
          if (display_was_interrupted_p && !info_any_buffered_input_p ())
            display_update_display (windows);
d4011 2
a4012 2
          if (active_window != the_echo_area)
            display_cursor_at_point (active_window);
d4014 1
a4014 1
          pure_key = key = info_get_another_input_char ();
d4016 2
a4017 2
          if (Meta_p (key))
            add_char_to_keyseq (ESC);
d4019 2
a4020 2
          add_char_to_keyseq (UnMeta (key));
        }
d4023 1
a4023 1
        key = UnMeta (key);
d4026 6
a4031 6
          keymap[key].function == info_universal_argument)
        {
          info_numeric_arg *= 4;
          key = 0;
          continue;
        }
d4034 7
a4040 7
        {
          if (info_explicit_arg)
            info_numeric_arg = (info_numeric_arg * 10) + (key - '0');
          else
            info_numeric_arg = (key - '0');
          info_explicit_arg = 1;
        }
d4042 13
a4054 13
        {
          if (key == '-' && !info_explicit_arg)
            {
              info_numeric_arg_sign = -1;
              info_numeric_arg = 1;
            }
          else
            {
              info_keyseq_index--;
              info_dispatch_on_key (pure_key, keymap);
              return;
            }
        }
d4060 3
a4062 3
/*                                                                  */
/*                      Input Character Buffering                   */
/*                                                                  */
d4111 1
a4111 1
        push_index = 0;
d4150 17
d4191 1
a4191 1
      chars_avail = read (tty, &input[0], chars_avail);
a4232 9
      unsigned char c;
      int tty = fileno (info_input_stream);

      /* Using stream I/O causes FIONREAD etc to fail to work
         so unless someone can find a portable way of finding
         out how many characters are currently buffered, we
         should stay with away from stream I/O.
         --Egil Kvaleberg <egilk@@sn.no>, January 1997.  */
      rawkey = (read (tty, &c, 1) == 1) ? c : EOF;
d4234 1
d4238 19
a4256 19
        {
          if (info_input_stream != stdin)
            {
              fclose (info_input_stream);
              info_input_stream = stdin;
              display_inhibited = 0;
              display_update_display (windows);
              display_cursor_at_point (active_window);
              rawkey = (read (tty, &c, 1) == 1) ? c : EOF;
              keystroke = rawkey;
            }

          if (rawkey == EOF)
            {
              terminal_unprep_terminal ();
              close_dribble_file ();
              exit (0);
            }
        }
d4262 1
a4262 1
  return keystroke;
@


1.1.1.5
log
@Import of FSF texinfo 3.12. This version creates empty info-dirs correctly.
@
text
@d2 1
a2 1
   $Id: session.c,v 1.13 1998/02/22 22:38:30 karl Exp $
a4208 12
#ifdef EINTR
      /* Keep reading if we got EINTR, so that we don't just exit.
         --Andreas Schwab <schwab@@issan.informatik.uni-dortmund.de>,
         22 Dec 1997.  */
      {
        int n;
        do
	  n = read (tty, &c, 1);
        while (n == -1 && errno == EINTR);
        rawkey = n == 1 ? c : EOF;
      }
#else
a4209 1
#endif
@


1.1.1.6
log
@TexInfo 4.0. New manpages, can create html.
A bit more grumpy about bad texinfo, though.
@
text
@d1 2
a2 2
/* session.c -- user windowing interface to Info.
   $Id: session.c,v 1.38 1999/09/25 16:10:04 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 96, 97, 98, 99 Free Software Foundation, Inc.
a33 6
#ifdef M_XENIX
/* SCO 3.2v5.0.2 defines but does not correctly declare strncasecmp.
   Since we use it as a symbol, have to get it right.  --gildea, 1jul99.  */
extern int strncasecmp (const char *, const char *, size_t);
#endif

d97 1
a97 1
          WINDOW *win, *largest = NULL;
d110 1
a110 1
              info_error (msg_cant_find_window);
d112 1
a112 1
              xexit (0);
d125 1
a125 1
              info_error (msg_win_too_small);
d127 1
a127 1
              xexit (0);
d137 1
a137 1
begin_info_session_with_error (initial_node, format, arg1, arg2)
d140 1
a140 2
     void *arg1;
     void *arg2;
d143 1
a143 1
  info_error (format, arg1, arg2);
d162 1
a162 1
    (_("Welcome to Info version %s. Type \\[get-help-window] for help, \\[menu-item] for menu item."));
d164 1
a164 1
  window_message_in_echo_area (format, VERSION);
d270 2
a271 2
      info_error (msg_term_too_dumb, term_name);
      xexit (1);
d284 1
a284 1
  info_set_node_of_window (0, active_window, node);
d294 1
a294 1
      setbuf (stdin, NULL);
d308 1
a308 2
  /* Input may include binary characters.  */
  stream = fopen (filename, FOPEN_RBIN);
d487 1
a487 2
   the footnotes for this window.  If REMEMBER is nonzero, first call
   set_remembered_pagetop_and_point.  */
d489 1
a489 2
info_set_node_of_window (remember, window, node)
     int remember;
a492 3
  if (remember)
    set_remembered_pagetop_and_point (window);

d610 1
a610 1
      info_error (msg_cant_find_point);
d689 1
a689 1
  /* If at a line start already, do nothing. */
d830 32
a879 8
/* Default window sizes for scrolling commands.  */
int default_window_size = -1;	/* meaning 1 window-full */
int default_scroll_size = -1;	/* meaning half screen size */

#define INFO_LABEL_FOUND() \
  (info_parsed_nodename || (info_parsed_filename \
                            && !is_dir_name (info_parsed_filename)))

d889 1
a889 1
      info_error (msg_at_node_bottom);
d895 1
a895 1
        info_error (msg_no_pointer, _("Next"));
d898 2
a899 2
          window_message_in_echo_area (_("Following Next node..."));
          info_handle_pointer ("Next", window);
d924 1
a924 1
        if (INFO_LABEL_FOUND ())
d926 2
a927 2
            window_message_in_echo_area (_("Selecting Next node..."));
            info_handle_pointer ("Next", window);
d948 1
a948 1
              if (INFO_LABEL_FOUND ())
d950 1
a950 1
                  info_handle_pointer ("Up", window);
d959 1
a959 1
                  if (!INFO_LABEL_FOUND ())
d996 2
a997 2
                    (_("Moving Up %d time(s), then Next."),
                     up_counter);
d999 1
a999 1
                  info_handle_pointer ("Next", window);
d1020 1
a1020 1
                  info_error (_("No more nodes within this document."));
d1038 1
a1038 1
      info_error (msg_at_node_top);
d1044 1
a1044 1
        info_error (_("No `Prev' for this node."));
d1047 2
a1048 2
          window_message_in_echo_area (_("Moving Prev in this window."));
          info_handle_pointer ("Prev", window);
d1055 1
a1055 2
      if (!info_parsed_nodename && (!info_parsed_filename
                                    || is_dir_name (info_parsed_filename)))
d1058 2
a1059 3
          if (!info_parsed_nodename && (!info_parsed_filename
                                        || is_dir_name (info_parsed_filename)))
            info_error (_("No `Prev' or `Up' for this node within this document."));
d1062 2
a1063 2
              window_message_in_echo_area (_("Moving Up in this window."));
              info_handle_pointer ("Up", window);
d1100 2
a1101 2
          window_message_in_echo_area (_("Moving Prev in this window."));
          info_handle_pointer ("Prev", window);
d1110 1
a1110 1
                    (_("Moving to `Prev's last menu item."));
d1164 1
a1164 3
      if (default_window_size > 0)
        desired_top = window->pagetop + default_window_size;
      else if (!info_explicit_arg && count == 1)
a1195 10
/* Like info_scroll_forward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_set_window,
		      _("Scroll forward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  info_scroll_forward (window, count, key);
}

d1208 1
a1208 3
      if (default_window_size > 0)
        desired_top = window->pagetop - default_window_size;
      else if (!info_explicit_arg && count == 1)
a1235 10
/* Like info_scroll_backward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_backward_set_window,
		      _("Scroll backward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  info_scroll_backward (window, count, key);
}

a1248 84

/* Scroll the window forward by N lines.  */
DECLARE_INFO_COMMAND (info_down_line, _("Scroll down by lines"))
{
  if (count < 0)
    info_up_line (window, -count, key);
  else
    {
      int desired_top = window->pagetop + count;

      if (desired_top >= window->line_count)
	desired_top = window->line_count - 2;

      if (window->pagetop <= desired_top)
	set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window backward by N lines.  */
DECLARE_INFO_COMMAND (info_up_line, _("Scroll up by lines"))
{
  if (count < 0)
    info_down_line (window, -count, key);
  else
    {
      int desired_top = window->pagetop - count;

      if (desired_top < 0)
	desired_top = 0;

      set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window forward by N lines and remember N as default for
   subsequent commands.  */
DECLARE_INFO_COMMAND (info_scroll_half_screen_down,
		      _("Scroll down by half screen size"))
{
  if (count < 0)
    info_scroll_half_screen_up (window -count, key);
  else
    {
      int scroll_size = (the_screen->height + 1) / 2;
      int desired_top;

      if (info_explicit_arg)
	default_scroll_size = count;
      if (default_scroll_size > 0)
	scroll_size = default_scroll_size;

      desired_top = window->pagetop + scroll_size;
      if (desired_top >= window->line_count)
	desired_top = window->line_count - 2;

      if (window->pagetop <= desired_top)
	set_window_pagetop (window, desired_top);
    }
}

/* Scroll the window backward by N lines and remember N as default for
   subsequent commands.  */
DECLARE_INFO_COMMAND (info_scroll_half_screen_up,
		      _("Scroll up by half screen size"))
{
  if (count < 0)
    info_scroll_half_screen_down (window -count, key);
  else
    {
      int scroll_size = (the_screen->height + 1) / 2;
      int desired_top;

      if (info_explicit_arg)
	default_scroll_size = count;
      if (default_scroll_size > 0)
	scroll_size = default_scroll_size;

      desired_top = window->pagetop - scroll_size;
      if (desired_top < 0)
	desired_top = 0;

      set_window_pagetop (window, desired_top);
    }
}
d1268 1
a1268 1
      info_error (msg_one_window);
d1308 1
a1308 1
      info_error (msg_one_window);
d1364 1
a1364 1
      info_error (msg_win_too_small);
d1432 1
a1432 1
      info_error (msg_cant_kill_last);
d1522 1
a1522 1
      info_error (msg_one_window);
a1533 7
/* Scroll the "other" window of WINDOW. */
DECLARE_INFO_COMMAND (info_scroll_other_window_backward,
                      _("Scroll the other window backward"))
{
  info_scroll_other_window (window, -count, key);
}

a1563 22
/* Return (FILENAME)NODENAME for NODE, or just NODENAME if NODE's
   filename is not set. */
char *
node_printed_rep (node)
     NODE *node;
{
  char *rep;

  if (node->filename)
    {
      char *filename
       = filename_non_directory (node->parent ? node->parent : node->filename);
      rep = xmalloc (1 + strlen (filename) + 1 + strlen (node->nodename) + 1);
      sprintf (rep, "(%s)%s", filename, node->nodename);
    }
  else
    rep = node->nodename;

  return rep;
}


d1616 1
a1616 1
        info_error (msg_cant_find_node, nodename);
d1624 4
a1627 1
    info_set_node_of_window (1, window, node);
d1692 2
a1693 1
          info_set_node_of_window (1, window, node);
d1700 1
a1700 1
            info_error (msg_cant_file_node, filename, nodename);
d1708 1
a1708 1
      info_error (msg_no_pointer, label);
d1714 1
a1714 1
DECLARE_INFO_COMMAND (info_next_node, _("Select the Next node"))
d1717 1
a1717 1
  info_handle_pointer ("Next", window);
d1722 1
a1722 1
DECLARE_INFO_COMMAND (info_prev_node, _("Select the Prev node"))
d1725 1
a1725 1
  info_handle_pointer ("Prev", window);
d1730 1
a1730 1
DECLARE_INFO_COMMAND (info_up_node, _("Select the Up node"))
d1733 1
a1733 1
  info_handle_pointer ("Up", window);
d1745 2
a1746 16
      int last_node_tag_idx = -1;

      /* If no explicit argument, or argument of zero, default to the
         last node.  */
      if (count == 0 || (count == 1 && !info_explicit_arg))
        count = -1;
      for (i = 0; count && fb->tags[i]; i++)
        if (fb->tags[i]->nodelen != 0) /* don't count anchor tags */
          {
            count--;
            last_node_tag_idx = i;
          }
      if (count > 0)
        i = last_node_tag_idx + 1;
      if (i > 0)
        node = info_get_node (fb->filename, fb->tags[i - 1]->nodename);
d1752 4
a1755 1
    info_set_node_of_window (1, window, node);
a1763 4
  /* If no explicit argument, or argument of zero, default to the
     first node.  */
  if (count == 0)
    count = 1;
d1765 1
a1765 15
    {
      register int i;
      int last_node_tag_idx = -1;

      for (i = 0; count && fb->tags[i]; i++)
        if (fb->tags[i]->nodelen != 0) /* don't count anchor tags */
          {
            count--;
            last_node_tag_idx = i;
          }
      if (count > 0)
        i = last_node_tag_idx + 1;
      if (i > 0)
        node = info_get_node (fb->filename, fb->tags[i - 1]->nodename);
    }
d1770 4
a1773 1
    info_set_node_of_window (1, window, node);
d1793 1
a1793 1
      info_error (msg_no_menu_node);
d1840 1
a1840 1
        info_error (msg_no_menu_node);
d1842 1
a1842 1
        info_error (msg_no_xref_node);
d1999 3
a2001 1
          NODE *orig = window->node;
d2003 2
a2004 3
          if (builder == info_xrefs_of_node && window->node != orig
              && !(window->node->flags & N_FromAnchor))
            { /* Search for this reference in the node.  */
d2069 1
a2069 1
    info_error (msg_no_menu_node);
d2088 1
a2088 1
    info_error (msg_no_menu_node);
d2098 1
a2098 1
        info_error (msg_win_too_small);
d2147 4
a2150 10
		if (this_is_the_current_fb)
		  entry->label = xstrdup (fb->tags[i]->nodename);
		else
		  {
		    entry->label = (char *) xmalloc
		      (4 + strlen (fb->filename) +
		       strlen (fb->tags[i]->nodename));
		    sprintf (entry->label, "(%s)%s",
			     fb->filename, fb->tags[i]->nodename);
		  }
d2154 12
d2169 1
a2169 1
    line = info_read_maybe_completing (window, _("Goto node: "), items);
d2173 1
a2173 1
  line = info_read_in_echo_area (window, _("Goto node: "));
a2191 164

/* Follow the menu list in MENUS (list of strings terminated by a NULL
   entry) from INITIAL_NODE.  If can't continue at any point (no menu or
   no menu entry for the next item), return the node so far -- that
   might be INITIAL_NODE itself.  If error, *ERRSTR and *ERRARG[12] will
   be set to the error message and argument for message, otherwise they
   will be NULL.  */

NODE *
info_follow_menus (initial_node, menus, errstr, errarg1, errarg2)
     NODE *initial_node;
     char **menus;
     char **errstr, **errarg1, **errarg2;
{
  NODE *node = NULL;
  *errstr = *errarg1 = *errarg2 = NULL;

  for (; *menus; menus++)
    {
      static char *first_arg = NULL;
      REFERENCE **menu;
      REFERENCE *entry;
      char *arg = *menus; /* Remember the name of the menu entry we want. */

      /* A leading space is certainly NOT part of a node name.  Most
	 probably, they typed a space after the separating comma.  The
	 strings in menus[] have their whitespace canonicalized, so
	 there's at most one space to ignore.  */
      if (*arg == ' ')
	arg++;
      if (!first_arg)
        first_arg = arg;

      /* Build and return a list of the menu items in this node. */
      menu = info_menu_of_node (initial_node);

      /* If no menu item in this node, stop here, but let the user
         continue to use Info.  Perhaps they wanted this node and didn't
         realize it. */
      if (!menu)
        {
          if (arg == first_arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }
          *errstr = _("No menu in node `%s'.");
          *errarg1 = node_printed_rep (initial_node);
          return initial_node;
        }

      /* Find the specified menu item. */
      entry = info_get_labeled_reference (arg, menu);

      /* If the item wasn't found, search the list sloppily.  Perhaps this
         user typed "buffer" when they really meant "Buffers". */
      if (!entry)
        {
          int i;
          int best_guess = -1;

          for (i = 0; (entry = menu[i]); i++)
            {
              if (strcasecmp (entry->label, arg) == 0)
                break;
              else
                if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
                  best_guess = i;
            }

          if (!entry && best_guess != -1)
            entry = menu[best_guess];
        }

      /* If we still failed to find the reference, start Info with the current
         node anyway.  It is probably a misspelling. */
      if (!entry)
        {
          if (arg == first_arg)
            {
              node = make_manpage_node (first_arg);
              if (node)
                goto maybe_got_node;
            }

          info_free_references (menu);
          *errstr = _("No menu item `%s' in node `%s'.");
          *errarg1 = arg;
          *errarg2 = node_printed_rep (initial_node);
          return initial_node;
        }

      /* We have found the reference that the user specified.  If no
         filename in this reference, define it. */
      if (!entry->filename)
        entry->filename = xstrdup (initial_node->parent ? initial_node->parent
                                                     : initial_node->filename);

      /* Try to find this node.  */
      node = info_get_node (entry->filename, entry->nodename);
      if (!node && arg == first_arg)
	{
	  node = make_manpage_node (first_arg);
	  if (node)
	    goto maybe_got_node;
	}

      /* Since we cannot find it, try using the label of the entry as a
         file, i.e., "(LABEL)Top".  */
      if (!node && entry->nodename
          && strcmp (entry->label, entry->nodename) == 0)
        node = info_get_node (entry->label, "Top");

    maybe_got_node:
      if (!node)
        {
          *errstr = _("Unable to find node referenced by `%s' in `%s'.");
          *errarg1 = xstrdup (entry->label);
          *errarg2 = node_printed_rep (initial_node);
          info_free_references (menu);
          return initial_node;
        }

      info_free_references (menu);

      /* Success.  Go round the loop again.  */
      free (initial_node);
      initial_node = node;
    }

  return initial_node;
}

/* Split STR into individual node names by writing null bytes in wherever
   there are commas and constructing a list of the resulting pointers.
   (We can do this since STR has had canonicalize_whitespace called on it.)
   Return array terminated with NULL.  */

static char **
split_list_of_nodenames (str)
     char *str;
{
  unsigned len = 2;
  char **nodes = xmalloc (len * sizeof (char *));

  nodes[len - 2] = str;

  while (*str++)
    {
      if (*str == ',')
        {
          *str++ = 0;		/* get past the null byte */
          len++;
          nodes = xrealloc (nodes, len * sizeof (char *));
          nodes[len - 2] = str;
        }
    }

  nodes[len - 1] = NULL;

  return nodes;
}

a2192 242
/* Read a line of input which is a sequence of menus (starting from
   dir), and follow them.  */
DECLARE_INFO_COMMAND (info_menu_sequence,
   _("Read a list of menus starting from dir and follow them"))
{
  char *line = info_read_in_echo_area (window, _("Follow menus: "));

  /* If the user aborted, quit now. */
  if (!line)
    {
      info_abort_key (window, 0, 0);
      return;
    }

  canonicalize_whitespace (line);

  if (*line)
    {
      char *errstr, *errarg1, *errarg2;
      NODE *dir_node = info_get_node (NULL, NULL);
      char **nodes = split_list_of_nodenames (line);
      NODE *node;

      /* If DIR_NODE is NULL, they might be reading a file directly,
	 like in "info -d . -f ./foo".  Try using "Top" instead.  */
      if (!dir_node)
	{
	  char *file_name = window->node->parent;

	  if (!file_name)
	    file_name = window->node->filename;
	  dir_node = info_get_node (file_name, NULL);
	}

      /* If we still cannot find the starting point, give up.
	 We cannot allow a NULL pointer inside info_follow_menus.  */
      if (!dir_node)
	info_error (msg_cant_find_node, "Top");
      else
	node
	  = info_follow_menus (dir_node, nodes, &errstr, &errarg1, &errarg2);

      free (nodes);
      if (!errstr)
        info_set_node_of_window (1, window, node);
      else
        info_error (errstr, errarg1, errarg2);
    }

  free (line);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Search the menu MENU for a (possibly mis-spelled) entry ARG.
   Return the menu entry, or the best guess for what they meant by ARG,
   or NULL if there's nothing in this menu seems to fit the bill.
   If EXACT is non-zero, allow only exact matches.  */
static REFERENCE *
entry_in_menu (arg, menu, exact)
     char *arg;
     REFERENCE **menu;
     int exact;
{
  REFERENCE *entry;

  /* First, try to find the specified menu item verbatim.  */
  entry = info_get_labeled_reference (arg, menu);

  /* If the item wasn't found, search the list sloppily.  Perhaps we
     have "Option Summary", but ARG is "option".  */
  if (!entry && !exact)
    {
      int i;
      int best_guess = -1;

      for (i = 0; (entry = menu[i]); i++)
	{
	  if (strcasecmp (entry->label, arg) == 0)
	    break;
	  else
	    if (strncasecmp (entry->label, arg, strlen (arg)) == 0)
	      best_guess = i;
	}

      if (!entry && best_guess != -1)
	entry = menu[best_guess];
    }

  return entry;
}

/* Find the node that is the best candidate to list the PROGRAM's
   invocation info and its command-line options, by looking for menu
   items and chains of menu items with characteristic names.  */
void
info_intuit_options_node (window, initial_node, program)
     WINDOW *window;
     NODE *initial_node;
     char *program;
{
  /* The list of node names typical for GNU manuals where the program
     usage and specifically the command-line arguments are described.
     This is pure heuristics.  I gathered these node names by looking
     at all the Info files I could put my hands on.  If you are
     looking for evidence to complain to the GNU project about
     non-uniform style of documentation, here you have your case!  */
  static const char *invocation_nodes[] = {
    "%s invocation",
    "Invoking %s",
    "Preliminaries",	/* m4 has Invoking under Preliminaries! */
    "Invocation",
    "Command Arguments",/* Emacs */
    "Invoking `%s'",
    "%s options",
    "Options",
    "Option ",		/* e.g. "Option Summary" */
    "Invoking",
    "All options",	/* tar, paxutils */
    "Arguments",
    "%s cmdline",	/* ar */
    "%s",		/* last resort */
    (const char *)0
  };
  NODE *node = NULL;
  REFERENCE **menu;
  const char **try_node;

  /* We keep looking deeper and deeper in the menu structure until
     there are no more menus or no menu items from the above list.
     Some manuals have the invocation node sitting 3 or 4 levels deep
     in the menu hierarchy...  */
  for (node = initial_node; node; initial_node = node)
    {
      REFERENCE *entry;

      /* Build and return a list of the menu items in this node. */
      menu = info_menu_of_node (initial_node);

      /* If no menu item in this node, stop here.  Perhaps this node
	 is the one they need.  */
      if (!menu)
	break;

      /* Look for node names typical for usage nodes in this menu.  */
      for (try_node = invocation_nodes; *try_node; try_node++)
	{
	  char nodename[200];

	  sprintf (nodename, *try_node, program);
	  /* The last resort "%s" is dangerous, so we restrict it
             to exact matches here.  */
	  entry = entry_in_menu (nodename, menu,
				 strcmp (*try_node, "%s") == 0);
	  if (entry)
	    break;
	}

      if (!entry)
	break;

      if (!entry->filename)
	entry->filename = xstrdup (initial_node->parent ? initial_node->parent
				   : initial_node->filename);
      /* Try to find this node.  */
      node = info_get_node (entry->filename, entry->nodename);
      info_free_references (menu);
      if (!node)
	break;
    }

  /* We've got our best shot at the invocation node.  Now select it.  */
  if (initial_node)
    info_set_node_of_window (1, window, initial_node);
  if (!info_error_was_printed)
    window_clear_echo_area ();
}

/* Given a name of an Info file, find the name of the package it
   describes by removing the leading directories and extensions.  */
char *
program_name_from_file_name (file_name)
     char *file_name;
{
  int i;
  char *program_name = xstrdup (filename_non_directory (file_name));

  for (i = strlen (program_name) - 1; i > 0; i--)
    if (program_name[i] == '.'
	&& (FILENAME_CMPN (program_name + i, ".info", 5) == 0
	    || FILENAME_CMPN (program_name + i, ".inf", 4) == 0
#ifdef __MSDOS__
	    || FILENAME_CMPN (program_name + i, ".i", 2) == 0
#endif
	    || isdigit (program_name[i + 1]))) /* a man page foo.1 */
      {
	program_name[i] = 0;
	break;
      }
  return program_name;
}

DECLARE_INFO_COMMAND (info_goto_invocation_node,
		      _("Find the node describing program invocation"))
{
  char *invocation_prompt = _("Find Invocation node of [%s]: ");
  char *program_name, *line;
  char *default_program_name, *prompt, *file_name;
  NODE *top_node;

  /* Intuit the name of the program they are likely to want.
     We use the file name of the current Info file as a hint.  */
  file_name = window->node->parent ? window->node->parent
				   : window->node->filename;
  default_program_name = program_name_from_file_name (file_name);

  prompt = (char *)xmalloc (strlen (default_program_name) +
			    strlen (invocation_prompt));
  sprintf (prompt, invocation_prompt, default_program_name);
  line = info_read_in_echo_area (window, prompt);
  free (prompt);
  if (!line)
    {
      info_abort_key ();
      return;
    }
  if (*line)
    program_name = line;
  else
    program_name = default_program_name;

  /* In interactive usage they'd probably expect us to begin looking
     from the Top node.  */
  top_node = info_get_node (file_name, NULL);
  if (!top_node)
    info_error (msg_cant_find_node, "Top");

  info_intuit_options_node (window, top_node, program_name);
  free (line);
  free (default_program_name);
}

d2230 1
a2230 1
  info_parse_and_select ("Top", window);
d2291 1
a2291 1

d2301 1
a2301 2
    if (strcmp (nodename, info_win->nodes[info_win->current]->nodename) == 0
	&& info_win->window == window)
d2324 1
a2324 1
    info_win->nodes[i] = info_win->nodes[i + 1];
d2362 1
a2362 1

a2372 1
        copy->display_pos = temp->display_pos;
a2384 1
      temp->display_pos = info_win->points[info_win->current];
d2436 1
a2436 1
            info_error (_("Cannot find `%s'."), line);
d2439 4
a2442 2
        info_set_node_of_window (1, window, node);

d2483 1
a2483 1
      info_error (_("Could not create output file `%s'."), output_filename);
d2532 2
a2533 2
            info_error (msg_cant_file_node, filename_non_directory (filename),
                        nodename);
d2535 1
a2535 1
            info_error (msg_cant_find_node, nodename);
d2552 5
a2556 1
  info_error (_("Writing node %s..."), node_printed_rep (node));
d2608 1
a2608 1
      info_error (_("Could not create output file `%s'."), filename);
a2645 1
  int piping = 0;
d2650 1
a2650 16
  /* Note that on MS-DOS/MS-Windows, this MUST open the pipe in the
     (default) text mode, since the printer drivers there need to see
     DOS-style CRLF pairs at the end of each line.

     FIXME: if we are to support Mac-style text files, we might need
     to convert the text here.  */

  /* INFO_PRINT_COMMAND which says ">file" means write to that file.
     Presumably, the name of the file is the local printer device.  */
  if (*print_command == '>')
    printer_pipe = fopen (++print_command, "w");
  else
    {
      printer_pipe = popen (print_command, "w");
      piping = 1;
    }
d2654 1
a2654 1
      info_error (_("Cannot open pipe to `%s'."), print_command);
d2660 5
a2664 1
  info_error (_("Printing node %s..."), node_printed_rep (node));
d2668 1
a2668 4
  if (piping)
    pclose (printer_pipe);
  else
    fclose (printer_pipe);
a2695 1
static void info_search_1 ();
a2701 3
static int last_search_direction = 0;
static int last_search_case_sensitive = 0;

d2727 1
a2727 1
info_search_in_node (string, node, start, window, dir, case_sensitive)
d2732 1
a2732 1
     int dir, case_sensitive;
d2740 1
a2740 3
  binding.flags = 0;
  if (!case_sensitive)
    binding.flags |= S_FoldCase;
d2789 1
a2789 1
      offset = info_search_in_node (target, node, start, (WINDOW *)NULL, 1, 0);
d2806 1
d2808 1
a2808 1
info_search_internal (string, window, dir, case_sensitive)
d2811 1
a2811 1
     int dir, case_sensitive;
d2821 15
a2835 8
  /* This used to begin from window->point, unless this was a repeated
     search command.  But invoking search with an argument loses with
     that logic, since info_last_executed_command is then set to
     info_add_digit_to_numeric_arg.  I think there's no sense in
     ``finding'' a string that is already under the cursor, anyway.  */
  ret = info_search_in_node
        (string, window->node, window->point + dir, window, dir,
         case_sensitive);
d2884 1
a2884 7
          /* Find the next tag that isn't an anchor.  */
          for (i = current_tag + dir; i != current_tag; i += dir)
            {
              if (i < 0)
                i = number_of_tags - 1;
              else if (i == number_of_tags)
                i = 0;
d2886 4
a2889 4
              tag = file_buffer->tags[i];
              if (tag->nodelen != 0)
                break;
            }
d2891 1
a2891 4
          /* If we got past out starting point, bail out.  */
          if (i == current_tag)
            return (-1);
          current_tag = i;
d2896 1
a2896 1
                (_("Searching subfile %s ..."),
d2912 1
a2912 1
                    info_error (msg_cant_file_node,
d2923 1
a2923 2
            info_search_in_node (string, node, start, window, dir,
                                 case_sensitive);
a2945 8
DECLARE_INFO_COMMAND (info_search_case_sensitively,
                      _("Read a string and search for it case-sensitively"))
{
  last_search_direction = count > 0 ? 1 : -1;
  last_search_case_sensitive = 1;
  info_search_1 (window, count, key, 1, 1);
}

a2947 21
  last_search_direction = count > 0 ? 1 : -1;
  last_search_case_sensitive = 0;
  info_search_1 (window, count, key, 0, 1);
}

DECLARE_INFO_COMMAND (info_search_backward,
		      _("Read a string and search backward for it"))
{
  last_search_direction = count > 0 ? -1 : 1;
  last_search_case_sensitive = 0;
  info_search_1 (window, -count, key, 0, 1);
}

static void
info_search_1 (window, count, key, case_sensitive, ask_for_string)
     WINDOW *window;
     int count;
     unsigned char key;
     int case_sensitive;
     int ask_for_string;
{
d2953 1
a2953 4
    {
      direction = -1;
      count = -count;
    }
d2955 1
a2955 5
    {
      direction = 1;
      if (count == 0)
        count = 1;	/* for backward compatibility */
    }
d2964 1
a2964 3
  if (ask_for_string)
    {
      prompt = (char *)xmalloc (50 + strlen (search_string));
d2966 3
a2968 4
      sprintf (prompt, _("%s%sfor string [%s]: "),
               direction < 0 ? _("Search backward") : _("Search"),
               case_sensitive ? _(" case-sensitively ") : _(" "),
               search_string);
d2970 2
a2971 2
      line = info_read_in_echo_area (window, prompt);
      free (prompt);
d2973 5
a2977 5
      if (!line)
        {
          info_abort_key ();
          return;
        }
d2979 5
a2983 5
      if (*line)
        {
          if (strlen (line) + 1 > search_string_size)
            search_string = (char *) xrealloc
              (search_string, (search_string_size += 50 + strlen (line)));
d2985 3
a2987 4
          strcpy (search_string, line);
          search_string_index = strlen (line);
          free (line);
        }
a2989 10
  /* If the search string includes upper-case letters, make the search
     case-sensitive.  */
  if (case_sensitive == 0)
    for (line = search_string; *line; line++)
      if (isupper (*line))
        {
          case_sensitive = 1;
          break;
        }

d2991 1
a2991 3
  for (result = 0; result == 0 && count--; )
    result = info_search_internal (search_string,
                                   active_window, direction, case_sensitive);
a3010 20
DECLARE_INFO_COMMAND (info_search_next,
		      _("Repeat last search in the same direction"))
{
  if (!last_search_direction)
    info_error (_("No previous search string"));
  else
    info_search_1 (window, last_search_direction * count,
		   key, last_search_case_sensitive, 0);
}

DECLARE_INFO_COMMAND (info_search_previous,
		      _("Repeat last search in the reverse direction"))
{
  if (!last_search_direction)
    info_error (_("No previous search string"));
  else
    info_search_1 (window, -last_search_direction * count,
		   key, last_search_case_sensitive, 0);
}

a3164 2
  char *p;
  int case_sensitive = 0;
d3231 1
a3231 1
      if (!Meta_p (key) || key > 32)
d3323 1
a3323 10
	  /* If the key is the isearch_terminate_search_key, but some buffered
	     input is pending, it is almost invariably because the ESC key is
	     actually the beginning of an escape sequence, like in case they
	     pressed an arrow key.  So don't gobble the ESC key, push it back
	     into pending input.  */
	  /* FIXME: this seems like a kludge!  We need a more reliable
	     mechanism to know when ESC is a separate key and when it is
	     part of an escape sequence.  */
          if (key != isearch_terminate_search_key ||
	      info_any_buffered_input_p ())
a3345 10
      /* If the search string includes upper-case letters, make the
         search case-sensitive.  */
      for (p = isearch_string; *p; p++)
        if (isupper (*p))
          {
            case_sensitive = 1;
            break;
          }
      

d3352 1
a3352 2
	       ((case_sensitive ? strncmp : strncasecmp)
                            (window->node->contents + window->point,
d3356 1
a3356 2
	       ((case_sensitive ? strncmp : strncasecmp)
                            (window->node->contents +
d3364 1
a3364 2
            search_result = info_search_internal (isearch_string,
						  window, dir, case_sensitive);
d3440 2
a3441 2
              if ((FILENAME_CMP (fb->fullpath, iw->nodes[i]->filename) == 0) ||
                  (FILENAME_CMP (fb->filename, iw->nodes[i]->filename) == 0))
d3486 1
a3486 1
    (INFO_MENU_ENTRY_LABEL, node, start, (WINDOW *)NULL, dir, 0);
d3497 1
a3497 1
          (INFO_MENU_ENTRY_LABEL, node, firstmenu + dir, (WINDOW *)NULL, dir, 0);
d3501 1
a3501 1
    info_search_in_node (INFO_XREF_LABEL, node, start, (WINDOW *)NULL, dir, 0);
d3512 1
a3512 1
      info_error (msg_no_xref_node);
d3520 1
a3520 1
    (INFO_MENU_ENTRY_LABEL, node, window->point + dir, (WINDOW *)NULL, dir, 0);
d3523 1
a3523 1
    (INFO_XREF_LABEL, node, window->point + dir, (WINDOW *)NULL, dir, 0);
d3537 1
a3537 1
          (INFO_MENU_ENTRY_LABEL, node, nextmenu + dir, (WINDOW *)NULL, dir, 0);
d3636 1
a3636 1
   _("Move the cursor to a specific line of the window"))
d3731 4
a3734 1
      char *temp = xmalloc (1 + strlen (rep) + strlen (_("\"\" is invalid")));
a4174 25
#  else  /* !O_NDELAY */
#   ifdef __DJGPP__
  {
    extern long pc_term_chars_avail (void);

    if (isatty (tty))
      chars_avail = pc_term_chars_avail ();
    else
      {
	/* We could be more accurate by calling ltell, but we have no idea
	   whether tty is buffered by stdio functions, and if so, how many
	   characters are already waiting in the buffer.  So we punt.  */
	struct stat st;

	if (fstat (tty, &st) < 0)
	  chars_avail = 1;
	else
	  chars_avail = st.st_size;
      }
    if (chars_avail > space_avail)
      chars_avail = space_avail;
    if (chars_avail)
      chars_avail = read (tty, &input[0], chars_avail);
  }
#   endif/* __DJGPP__ */
a4231 1
	      tty = fileno (info_input_stream);
d4243 1
a4243 1
              xexit (0);
@


1.1.1.7
log
@TeXinfo 4.2, much more robust html (and other formats) output, and a few
features that new FSF programs will need (e.g., gcc snapshots).

looked at by fgs@@, thanks.
@
text
@d2 1
a2 1
   $Id: session.c,v 1.45 2002/03/02 15:05:04 karl Exp $
d4 1
a4 2
   Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02
   Free Software Foundation, Inc.
d1142 2
a1143 9
static void _scroll_forward();
static void _scroll_backward();

static void
_scroll_forward(window, count, key, behaviour)
  WINDOW *window;
  int count;
  unsigned char key;
  int behaviour;
d1146 1
a1146 1
    _scroll_backward (window, -count, key, behaviour);
d1153 2
a1154 2
         and the chosen behaviour is to scroll through nodes get the
	 "Next" node for this window. */
d1162 1
a1162 1
             another node, depending on BEHAVIOUR. */
d1165 7
d1189 12
a1200 6
static void
_scroll_backward(window, count, key, behaviour)
  WINDOW *window;
  int count;
  unsigned char key;
  int behaviour;
d1203 1
a1203 1
    _scroll_forward (window, -count, key, behaviour);
d1209 2
a1210 2
         to the bottom of this window, or, depending on the selected
	 behaviour, move to the previous, or Up'th node. */
d1219 8
a1240 38
/* Show the next screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_forward, _("Scroll forward in this window"))
{
  _scroll_forward (window, count, key, info_scroll_behaviour);
}

/* Like info_scroll_forward, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_set_window,
		      _("Scroll forward in this window and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_forward (window, count, key, info_scroll_behaviour);
}

/* Show the next screen of WINDOW's node but never advance to next node. */
DECLARE_INFO_COMMAND (info_scroll_forward_page_only, _("Scroll forward in this window staying within node"))
{
  _scroll_forward (window, count, key, IS_PageOnly);
}

/* Like info_scroll_forward_page_only, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_forward_page_only_set_window,
		      _("Scroll forward in this window staying within node and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_forward (window, count, key, IS_PageOnly);
}

/* Show the previous screen of WINDOW's node. */
DECLARE_INFO_COMMAND (info_scroll_backward, _("Scroll backward in this window"))
{
  _scroll_backward (window, count, key, info_scroll_behaviour);
}

d1248 1
a1248 18
  _scroll_backward (window, count, key, info_scroll_behaviour);
}

/* Show the previous screen of WINDOW's node but never move to previous
   node. */
DECLARE_INFO_COMMAND (info_scroll_backward_page_only, _("Scroll backward in this window staying within node"))
{
  _scroll_backward (window, count, key, IS_PageOnly);
}

/* Like info_scroll_backward_page_only, but sets default_window_size as a side
   effect.  */
DECLARE_INFO_COMMAND (info_scroll_backward_page_only_set_window,
		      _("Scroll backward in this window staying within node and set default window size"))
{
  if (info_explicit_arg)
    default_window_size = count;
  _scroll_backward (window, count, key, IS_PageOnly);
d1304 1
a1304 1
    info_scroll_half_screen_up (window, -count, key);
d1330 1
a1330 1
    info_scroll_half_screen_down (window, -count, key);
d2031 1
a2031 13
	    {
	      refs = info_xrefs (&binding);
	      if (!refs && point_line > 0)
		{
		  /* People get annoyed that Info cannot find an xref
		     which starts on a previous line and ends on this
		     one.  So if we fail to find a reference on this
		     line, let's try the one before.  */
		  binding.start =
		    window->line_starts[point_line - 1] - binding.buffer;
		  refs = info_xrefs (&binding);
		}
	    }
d2142 2
a2143 37
      /* It is possible that the references have more than a single
         entry with the same label, and also LINE is down-cased, which
         complicates matters even more.  Try to be as accurate as we
         can: if they've chosen the default, use defentry directly. */
      if (defentry && strcmp (line, defentry->label) == 0)
        entry = defentry;
      else
        /* Find the selected label in the references.  If there are
           more than one label which matches, find the one that's
           closest to point.  */
        {
          register int i;
          int best = -1, min_dist = window->node->nodelen;
          REFERENCE *ref;

          for (i = 0; menu && (ref = menu[i]); i++)
            {
              /* Need to use strcasecmp because LINE is downcased
                 inside info_read_completing_in_echo_area.  */
              if (strcasecmp (line, ref->label) == 0)
                {
                  /* ref->end is more accurate estimate of position
                     for menus than ref->start.  Go figure.  */
                  int dist = abs (window->point - ref->end);

                  if (dist < min_dist)
                    {
                      min_dist = dist;
                      best = i;
                    }
                }
            }
          if (best != -1)
            entry = menu[best];
          else
            entry = (REFERENCE *)NULL;
        }
d2416 1
a2416 6
	      /* Maybe they typed "info foo" instead of "info -f foo".  */
	      node = info_get_node (first_arg, 0);
	      if (node)
		add_file_directory_to_path (first_arg);
	      else
		node = make_manpage_node (first_arg);
d3876 1
a3876 9
          func = InfoFunction(window->keymap[key].function);

          if (isprint (key) || func == (VFunction *)NULL)
            {
            insert_and_search:

              if (isearch_string_index + 2 >= isearch_string_size)
                isearch_string = (char *)xrealloc
                  (isearch_string, isearch_string_size += 100);
d3878 5
a3882 5
              isearch_string[isearch_string_index++] = key;
              isearch_string[isearch_string_index] = '\0';
              goto search_now;
            }
          else if (func == isearch_forward || func == isearch_backward)
a3883 5
	      /* If this key invokes an incremental search, then this
		 means that we will either search again in the same
		 direction, search again in the reverse direction, or
		 insert the last search string that was accepted through
		 incremental searching. */
d3921 12
d3974 2
a3975 3
          if (key != RET  /* Emacs addicts want RET to get lost */
	      && (key != isearch_terminate_search_key
		  || info_any_buffered_input_p ()))
d4380 2
a4381 4
/* Declaration only.  Special cased in info_dispatch_on_key ().
   Doc string is to avoid ugly results with describe_key etc.  */
DECLARE_INFO_COMMAND (info_do_lowercase_version,
		      _("Run command bound to this key's lowercase variant"))
d4406 1
d4431 19
a4515 1
#if !defined(INFOKEY)
a4530 1
#endif /* INFOKEY */
d4538 1
a4538 1
        func = InfoFunction(map[key].function);
a4543 12
#if defined(INFOKEY)
		unsigned char lowerkey;

		lowerkey = Meta_p(key) ? Meta (tolower (UnMeta (key))) : tolower (key);
		if (lowerkey == key)
		  {
		    add_char_to_keyseq (key);
		    dispatch_error (info_keyseq);
		    return;
		  }
                info_dispatch_on_key (lowerkey, map);
#else /* !INFOKEY */
a4544 1
#endif /* INFOKEY */
d4557 1
a4557 1
              (*InfoFunction(map[key].function))
d4567 1
a4567 1
                    ea_last_executed_command = InfoFunction(map[key].function);
d4569 1
a4569 1
                    info_last_executed_command = InfoFunction(map[key].function);
d4584 1
a4584 1
      if (map[key].function != (InfoCommand *)NULL)
a4662 1
#if !defined(INFOKEY)
a4666 3
#else /* defined(INFOKEY) */
          add_char_to_keyseq (key);
#endif /* defined(INFOKEY) */
a4668 1
#if !defined(INFOKEY)
a4670 1
#endif /* !defined(INFOKEY) */
d4673 1
a4673 1
          InfoFunction(keymap[key].function) == info_universal_argument)
a4678 6

#if defined(INFOKEY)
      if (Meta_p (key))
        key = UnMeta (key);
#endif /* !defined(INFOKEY) */

@


1.1.1.8
log
@import texinfo 4.8 into the tree.
(okay theo, kettenis)
@
text
@d2 1
a2 1
   $Id: session.c,v 1.16 2004/12/14 00:15:36 karl Exp $
d4 1
a4 1
   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d21 1
a21 1
   Originally written by Brian Fox (bfox@@ai.mit.edu). */
a23 1
#include "search.h"
d35 8
a42 5
static void info_clear_pending_input (void);
static void info_set_pending_input (unsigned char key);
static void info_handle_pointer (char *label, WINDOW *window);
static void display_info_keyseq (int expecting_future_input);
char *node_printed_rep (NODE *node);
d69 3
a71 3
void remember_window_and_node (WINDOW *window, NODE *node);
void forget_window_and_nodes (WINDOW *window);
void display_startup_message_and_start (void);
d77 3
a79 1
begin_multiple_window_info_session (char *filename, char **nodenames)
d117 1
a117 1
              info_error ((char *) msg_cant_find_window, NULL, NULL);
d132 1
a132 1
              info_error ((char *) msg_win_too_small, NULL, NULL);
d144 5
a148 2
begin_info_session_with_error (NODE *initial_node, char *format,
    void *arg1, void *arg2)
d157 2
a158 1
begin_info_session (NODE *initial_node)
d165 1
a165 1
display_startup_message_and_start (void)
d170 1
a170 2
    ((char *) _("Welcome to Info version %s. Type \\[get-help-window] for help, \\[menu-item] for menu item."),
     0);
d172 1
a172 1
  window_message_in_echo_area (format, VERSION, NULL);
d178 1
a178 1
info_session (void)
d195 1
a195 1
info_read_and_dispatch (void)
d203 1
a203 1
      int lk = 0;
d207 2
a208 2
      if ((info_last_executed_command != (VFunction *) info_next_line) &&
          (info_last_executed_command != (VFunction *) info_prev_line))
d245 1
a245 1
          if (ea_last_executed_command == (VFunction *) ea_newline ||
d252 1
a252 1
          if (info_last_executed_command == (VFunction *) info_quit)
d255 1
a255 1
      else if (info_last_executed_command == (VFunction *) info_quit)
d261 1
a261 1
extern void initialize_info_signal_handler (void );
d266 3
a268 1
initialize_info_session (NODE *node, int clear_screen)
d278 1
a278 1
      info_error ((char *) msg_term_too_dumb, term_name, NULL);
d296 1
a296 1
  window_deletion_notifier = (VFunction *) forget_window_and_nodes;
d311 2
a312 1
info_set_input_from_file (char *filename)
d334 2
a335 1
get_info_window_of_window (WINDOW *window)
d351 2
a352 1
set_remembered_pagetop_and_point (WINDOW *window)
d370 3
a372 1
remember_window_and_node (WINDOW *window, NODE *node)
d431 1
a431 1
consistency_check_info_windows (void)
d451 2
a452 1
forget_window_and_nodes (WINDOW *window)
d499 4
a502 1
info_set_node_of_window (int remember, WINDOW *window, NODE *node)
d529 3
a531 1
set_window_pagetop (WINDOW *window, int desired_top)
d594 2
a595 1
info_show_point (WINDOW *window)
d618 3
a620 1
move_to_new_line (int old, int new, WINDOW *window)
d624 1
a624 1
      info_error ((char *) msg_cant_find_point, NULL, NULL);
d872 3
a874 1
forward_move_node_structure (WINDOW *window, int behaviour)
d879 1
a879 1
      info_error ((char *) msg_at_node_bottom, NULL, NULL);
d885 1
a885 1
        info_error ((char *) msg_no_pointer, (char *) _("Next"), NULL);
d888 1
a888 2
          window_message_in_echo_area ((char *) _("Following Next node..."),
              NULL, NULL);
d905 1
a905 2
              window_message_in_echo_area ((char *) _("Selecting first menu item..."),
                  NULL, NULL);
d916 1
a916 2
            window_message_in_echo_area ((char *) _("Selecting Next node..."),
                NULL, NULL);
d986 2
a987 2
                    ((char *) _("Moving Up %d time(s), then Next."),
                     (void *) (long) up_counter, NULL);
d1010 1
a1010 2
                  info_error ((char *) _("No more nodes within this document."),
                      NULL, NULL);
d1021 3
a1023 1
backward_move_node_structure (WINDOW *window, int behaviour)
d1028 1
a1028 1
      info_error ((char *) msg_at_node_top, NULL, NULL);
d1034 1
a1034 1
        info_error ((char *) _("No `Prev' for this node."), NULL, NULL);
d1037 1
a1037 2
          window_message_in_echo_area ((char *) _("Moving Prev in this window."),
              NULL, NULL);
d1051 1
a1051 3
            info_error ((char *)
                _("No `Prev' or `Up' for this node within this document."),
                NULL, NULL);
d1054 1
a1054 2
              window_message_in_echo_area ((char *) _("Moving Up in this window."),
                  NULL, NULL);
d1092 1
a1092 2
          window_message_in_echo_area ((char *) _("Moving Prev in this window."),
              NULL, NULL);
d1102 1
a1102 1
                    ((char *) _("Moving to `Prev's last menu item."), NULL, NULL);
d1143 2
a1144 4
static void _scroll_forward(WINDOW *window, int count,
    unsigned char key, int behaviour);
static void _scroll_backward(WINDOW *window, int count,
    unsigned char key, int behaviour);
d1147 5
a1151 1
_scroll_forward(WINDOW *window, int count, unsigned char key, int behaviour)
d1191 5
a1195 1
_scroll_backward(WINDOW *window, int count, unsigned char key, int behaviour)
d1409 1
a1409 1
      info_error ((char *) msg_one_window, NULL, NULL);
d1449 1
a1449 1
      info_error ((char *) msg_one_window, NULL, NULL);
d1460 1
a1460 1
          register WINDOW *win, *last = NULL;
d1505 1
a1505 1
      info_error ((char *) msg_win_too_small, NULL, NULL);
d1573 1
a1573 1
      info_error ((char *) msg_cant_kill_last, NULL, NULL);
d1577 1
a1577 1
      info_error ((char *) _("Cannot delete a permanent window"), NULL, NULL);
d1594 2
a1595 1
info_delete_window_internal (WINDOW *window)
d1663 1
a1663 1
      info_error ((char *) msg_one_window, NULL, NULL);
d1715 2
a1716 1
node_printed_rep (NODE *node)
d1737 3
a1739 1
info_select_reference (WINDOW *window, REFERENCE *entry)
d1784 1
a1784 1
        info_error (file_system_error, NULL, NULL);
d1786 1
a1786 1
        info_error ((char *) msg_cant_find_node, nodename, NULL);
d1801 3
a1803 1
info_parse_and_select (char *line, WINDOW *window)
d1821 3
a1823 1
info_handle_pointer (char *label, WINDOW *window)
d1864 1
a1864 1
            info_error (info_recent_file_error, NULL, NULL);
d1866 1
a1866 1
            info_error ((char *) msg_cant_file_node, filename, nodename);
d1874 1
a1874 1
      info_error ((char *) msg_no_pointer, label, NULL);
d1930 1
a1930 1
    info_error ((char *) _("This window has no additional nodes"), NULL, NULL);
d1963 1
a1963 1
    info_error ((char *) _("This window has no additional nodes"), NULL, NULL);
d1979 1
a1979 1
  register REFERENCE **menu;
d1985 1
a1985 1
      info_error ((char *) msg_no_menu_node, NULL, NULL);
d1997 1
a1997 1
      for (i = 0; menu[i]; i++)
d2003 1
a2003 5
    {
      info_select_reference (window, menu[i]);
      if (menu[i]->line_number > 0)
        info_next_line (window, menu[i]->line_number - 1, key);
    }
d2005 1
a2005 2
    info_error ((char *) _("There aren't %d items in this menu."),
                (void *) (long) item, NULL);
a2010 65


/* Return a pointer to the xref in XREF_LIST that is nearest to POS, or
   NULL if XREF_LIST is empty.  That is, if POS is within any of the
   given xrefs, return that one.  Otherwise, return the one with the
   nearest beginning or end.  If there are two that are equidistant,
   prefer the one forward.  The return is in newly-allocated memory,
   since the caller frees it.
   
   This is called from info_menu_or_ref_item with XREF_LIST being all
   the xrefs in the node, and POS being point.  The ui function that
   starts it all off is select-reference-this-line.

   This is not the same logic as in info.el.  Info-get-token prefers
   searching backwards to searching forwards, and has a hardwired search
   limit of 200 chars (in Emacs 21.2).  */

static REFERENCE **
nearest_xref (REFERENCE **xref_list, long int pos)
{
  int this_xref;
  int nearest = -1;
  long best_delta = -1;
  
  for (this_xref = 0; xref_list[this_xref]; this_xref++)
    {
      long delta;
      REFERENCE *xref = xref_list[this_xref];
      if (xref->start <= pos && pos <= xref->end)
        { /* POS is within this xref, we're done */
          nearest = this_xref;
          break;
        }
      
      /* See how far POS is from this xref.  Take into account the
         `*Note' that begins the xref, since as far as the user is
         concerned, that's where it starts.  */
      delta = MIN (labs (pos - (xref->start - strlen (INFO_XREF_LABEL))),
                   labs (pos - xref->end));
      
      /* It's the <= instead of < that makes us choose the forward xref
         of POS if two are equidistant.  Of course, because of all the
         punctuation surrounding xrefs, it's not necessarily obvious
         where one ends.  */
      if (delta <= best_delta || best_delta < 0)
        {
          nearest = this_xref;
          best_delta = delta;
        }
    }
  
  /* Maybe there was no list to search through.  */
  if (nearest < 0)
    return NULL;
  
  /* Ok, we have a nearest xref, make a list of it.  */
  {
    REFERENCE **ret = xmalloc (sizeof (REFERENCE *) * 2);
    ret[0] = info_copy_reference (xref_list[nearest]);
    ret[1] = NULL;
    return ret;
  }
}


d2017 6
a2022 2
info_menu_or_ref_item (WINDOW *window, int count,
    unsigned char key, REFERENCE **(*builder) (NODE *node), int ask_p)
d2024 1
d2026 2
a2027 3
  REFERENCE *entry;
  REFERENCE *defentry = NULL;
  REFERENCE **menu = (*builder) (window->node);
d2032 1
a2032 1
        info_error ((char *) msg_no_menu_node, NULL, NULL);
d2034 1
a2034 1
        info_error ((char *) msg_no_xref_node, NULL, NULL);
d2041 4
a2044 2
    REFERENCE **refs = NULL;
    int point_line = window_line_of_point (window);
d2073 13
a2085 1
              refs = nearest_xref (menu, window->point);
d2088 1
a2088 1
        if (refs && refs[0])
d2090 2
a2091 2
            if (strcmp (refs[0]->label, "Menu") != 0
                || builder == info_xrefs_of_node)
d2095 2
a2096 6
                /* For xrefs, find the closest reference to point,
                   unless we only have one reference (as we will if
                   we've called nearest_xref above).  It would be better
                   to have only one piece of code, but the conditions
                   when we call this are tangled.  */
                if (builder == info_xrefs_of_node && refs[1])
d2102 2
a2103 2
                        if (window->point >= refs[which]->start
                            && window->point <= refs[which]->end)
d2109 3
a2111 1
                          break;
d2113 4
a2116 7
		    if (which > 0)
		      {
			if (closest == -1)
			  which--;
			else
			  which = closest;
		      }
a2122 1
                defentry->line_number = refs[which]->line_number;
d2140 5
d2148 1
a2148 5
	    {
	      prompt = xmalloc (strlen (defentry->label)
				+ strlen (_("Menu item (%s): ")));
	      sprintf (prompt, _("Menu item (%s): "), defentry->label);
	    }
d2150 1
a2150 1
	    prompt = xstrdup (_("Menu item: "));
d2155 1
a2155 5
	    {
	      prompt = xmalloc (strlen (defentry->label)
				+ strlen (_("Follow xref (%s): ")));
	      sprintf (prompt, _("Follow xref (%s): "), defentry->label);
	    }
d2157 1
a2157 1
	    prompt = xstrdup (_("Follow xref: "));
d2235 1
a2235 1
        info_error ((char *) _("The reference disappeared! (%s)."), line, NULL);
a2239 1

a2259 5

            if (entry->line_number > 0)
              /* next_line starts at line 1?  Anyway, the -1 makes it
                 move to the right line.  */
              info_next_line (window, entry->line_number - 1, key);
d2307 1
a2307 1
    info_error ((char *) msg_no_menu_node, NULL, NULL);
d2326 1
a2326 1
    info_error ((char *) msg_no_menu_node, NULL, NULL);
d2336 1
a2336 1
        info_error ((char *) msg_win_too_small, NULL, NULL);
d2401 1
a2401 2
    line = info_read_maybe_completing (window, (char *) _("Goto node: "),
        items);
d2405 1
a2405 1
  line = info_read_in_echo_area (window, (char *) _("Goto node: "));
d2433 4
a2436 2
info_follow_menus (NODE *initial_node, char **menus,
    const char **errstr, char **errarg1, char **errarg2)
d2491 1
a2491 2
                if ((best_guess == -1)
                    && (strncasecmp (entry->label, arg, strlen (arg)) == 0))
d2569 2
a2570 1
split_list_of_nodenames (char *str)
d2599 1
a2599 1
  char *line = info_read_in_echo_area (window, (char *) _("Follow menus: "));
d2612 1
a2612 2
      const char *errstr;
      char *errarg1, *errarg2;
d2615 1
a2615 1
      NODE *node = NULL;
d2631 1
a2631 1
	info_error ((char *) msg_cant_find_node, "Top", NULL);
d2633 2
a2634 1
	node = info_follow_menus (dir_node, nodes, &errstr, &errarg1, &errarg2);
d2640 1
a2640 1
        info_error ((char *) errstr, errarg1, errarg2);
d2653 4
a2656 1
entry_in_menu (char *arg, REFERENCE **menu, int exact)
d2690 4
a2693 1
info_intuit_options_node (WINDOW *window, NODE *initial_node, char *program)
d2728 1
a2728 1
      REFERENCE *entry = NULL;
d2741 1
a2741 1
	  char *nodename;
a2742 1
	  nodename = xmalloc (strlen (program) + strlen (*try_node));
a2747 1
	  free (nodename);
d2775 2
a2776 1
program_name_from_file_name (char *file_name)
d2799 1
a2799 1
  const char *invocation_prompt = _("Find Invocation node of [%s]: ");
d2817 1
a2817 1
      info_abort_key (window, 0, 0);
d2829 1
a2829 1
    info_error ((char *) msg_cant_find_node, "Top", NULL);
d2841 1
a2841 1
  line = info_read_in_echo_area (window, (char *) _("Get Manpage: "));
d2886 2
a2887 1
read_nodename_to_kill (WINDOW *window)
d2895 1
a2895 1
  char *prompt = xmalloc (strlen (_("Kill node (%s): ")) + strlen (default_nodename));
d2927 3
a2929 1
kill_node (WINDOW *window, char *nodename)
d2951 1
a2951 1
        info_error ((char *) _("Cannot kill node `%s'"), nodename, NULL);
d2961 1
a2961 1
      info_error ((char *) _("Cannot kill the last node"), NULL, NULL);
d3065 1
a3065 1
  line = info_read_in_echo_area (window, (char *) _("Find file: "));
d3080 1
a3080 1
            info_error (info_recent_file_error, NULL, NULL);
d3082 1
a3082 1
            info_error ((char *) _("Cannot find `%s'."), line, NULL);
d3101 3
a3103 4
static void write_node_to_stream (NODE *node, FILE *stream);
static void dump_node_to_stream (char *filename, char *nodename,
    FILE *stream, int dump_subnodes);
static void initialize_dumping (void);
d3109 5
a3113 2
dump_nodes_to_file (char *filename, char **nodenames,
    char *output_filename, int dump_subnodes)
d3127 1
a3127 2
      info_error ((char *) _("Could not create output file `%s'."),
          output_filename, NULL);
d3140 1
a3140 1
  info_error ((char *) _("Done."), NULL, NULL);
d3150 1
a3150 1
initialize_dumping (void)
d3159 4
a3162 2
dump_node_to_stream (char *filename, char *nodename,
    FILE *stream, int dump_subnodes)
d3172 1
a3172 1
        info_error (info_recent_file_error, NULL, NULL);
d3176 2
a3177 3
            info_error ((char *) msg_cant_file_node,
                filename_non_directory (filename),
                nodename);
d3179 1
a3179 1
            info_error ((char *) msg_cant_find_node, nodename, NULL);
d3196 1
a3196 1
  info_error ((char *) _("Writing node %s..."), node_printed_rep (node), NULL);
d3231 4
a3234 1
dump_node_to_file (NODE *node, char *filename, int dump_subnodes)
d3248 1
a3248 2
      info_error ((char *) _("Could not create output file `%s'."), filename,
          NULL);
d3265 1
a3265 1
  info_error ((char *) _("Done."), NULL, NULL);
d3281 2
a3282 1
print_node (NODE *node)
d3310 1
a3310 1
      info_error ((char *) _("Cannot open pipe to `%s'."), print_command, NULL);
d3316 1
a3316 1
  info_error ((char *) _("Printing node %s..."), node_printed_rep (node), NULL);
d3326 1
a3326 1
  info_error ((char *) _("Done."), NULL, NULL);
d3331 3
a3333 1
write_node_to_stream (NODE *node, FILE *stream)
d3350 2
a3351 3
static void info_gc_file_buffers (void);
static void info_search_1 (WINDOW *window, int count,
    unsigned char key, int case_sensitive, int ask_for_string);
d3354 1
d3363 2
a3364 1
file_buffer_of_window (WINDOW *window)
d3386 6
a3391 2
info_search_in_node (char *string, NODE *node, long int start,
    WINDOW *window, int dir, int case_sensitive)
d3433 4
a3436 1
info_target_search_node (NODE *node, char *string, long int start)
d3439 1
a3439 1
  long offset = 0;
d3468 4
a3471 2
info_search_internal (char *string, WINDOW *window,
    int dir, int case_sensitive)
d3508 1
a3508 1
      register int current_tag = 0, number_of_tags;
d3558 2
a3559 2
                ((char *) _("Searching subfile %s ..."),
                 filename_non_directory (tag->filename), NULL);
d3572 1
a3572 1
                    info_error (info_recent_file_error, NULL, NULL);
d3574 1
a3574 1
                    info_error ((char *) msg_cant_file_node,
d3633 6
a3638 2
info_search_1 (WINDOW *window, int count, unsigned char key,
    int case_sensitive, int ask_for_string)
d3665 1
a3665 6
      prompt = (char *)xmalloc (strlen (_("%s%sfor string [%s]: "))
				+ strlen (_("Search backward"))
				+ strlen (_("Search"))
				+ strlen (_(" case-sensitively "))
				+ strlen (_(" "))
				+ strlen (search_string));
d3677 1
a3677 1
          info_abort_key (window, 0, 0);
d3683 1
a3683 1
          if (strlen (line) + 1 > (unsigned int) search_string_size)
d3688 1
d3709 1
a3709 1
    info_error ((char *) _("Search failed."), NULL, NULL);
d3730 1
a3730 1
    info_error ((char *) _("No previous search string"), NULL, NULL);
d3740 1
a3740 1
    info_error ((char *) _("No previous search string"), NULL, NULL);
d3752 1
a3752 2
static void incremental_search (WINDOW *window, int count,
    unsigned char ignore);
d3776 8
d3791 3
a3793 1
push_isearch (WINDOW *window, int search_index, int direction, int failing)
d3809 3
a3811 1
pop_isearch (WINDOW *window, int *search_index, int *direction, int *failing)
d3831 1
a3831 1
free_isearch_states (void)
d3845 4
a3848 1
show_isearch_prompt (int dir, unsigned char *string, int failing_p)
d3851 2
a3852 3
  const char *prefix;
  char *prompt, *p_rep;
  unsigned int prompt_len, p_rep_index, p_rep_size;
d3880 2
a3881 4
  prompt_len = strlen (prefix) + p_rep_index + 1;
  if (failing_p)
    prompt_len += strlen (_("Failing "));
  prompt = xmalloc (prompt_len);
d3885 1
a3885 1
  window_message_in_echo_area ("%s", prompt, NULL);
d3892 4
a3895 1
incremental_search (WINDOW *window, int count, unsigned char ignore)
d3918 1
a3918 1
  show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);
d3939 1
a3939 1
      if (key == DEL || key == Control ('h'))
d3952 1
a3952 2
              show_isearch_prompt (dir, (unsigned char *) isearch_string,
                  search_result);
d3970 1
a3970 7
          /* If this key is not a keymap, get its associated function,
             if any.  If it is a keymap, then it's probably ESC from an
             arrow key, and we handle that case below.  */
          char type = window->keymap[key].type;
          func = type == ISFUNC
                 ? InfoFunction(window->keymap[key].function)
                 : NULL;  /* function member is a Keymap if ISKMAP */
d3972 1
a3972 1
          if (isprint (key) || (type == ISFUNC && func == NULL))
d3984 1
a3984 2
          else if (func == (VFunction *) isearch_forward
              || func == (VFunction *) isearch_backward)
d3991 2
a3992 2
              if ((func == (VFunction *) isearch_forward && dir > 0) ||
                  (func == (VFunction *) isearch_backward && dir < 0))
d4001 2
a4002 2
                          if (strlen ((char *) last_isearch_accepted) + 1
                              >= (unsigned int) isearch_string_size)
d4028 1
a4028 1
          else if (func == (VFunction *) info_abort_key)
d4039 1
a4039 2
                  show_isearch_prompt (dir, (unsigned char *) isearch_string,
                      search_result);
d4055 1
a4055 1
          if (isearch_string_index && func != (VFunction *) info_abort_key)
d4074 1
a4074 1
          if (func == (VFunction *) info_abort_key)
d4092 1
a4092 1
      show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);
d4134 1
a4134 1
      show_isearch_prompt (dir, (unsigned char *) isearch_string, search_result);
d4168 1
a4168 1
info_gc_file_buffers (void)
d4227 5
a4231 1
info_move_to_xref (WINDOW *window, int count, unsigned char key, int dir)
d4273 1
a4273 1
      info_error ((char *) msg_no_xref_node, NULL, NULL);
d4362 1
d4364 2
a4365 4
  if (window->line_starts)
    line = window->line_starts[window_line_of_point (window)];
  else
    line = "";
d4388 1
a4388 1
  info_error ((char *) _("Quit"), NULL, NULL);
d4483 2
a4484 1
dispatch_error (char *keyseq)
d4491 1
a4491 1
    info_error ((char *) _("Unknown command (%s)."), rep, NULL);
d4494 2
a4495 2
      char *temp = xmalloc (1 + strlen (rep) + strlen (_("\"%s\" is invalid")));
      sprintf (temp, _("`%s' is invalid"), rep);
d4510 1
a4510 1
initialize_keyseq (void)
d4518 2
a4519 1
add_char_to_keyseq (char character)
d4531 3
a4533 2
static void
display_info_keyseq (int expecting_future_input)
d4545 1
a4545 1
      window_message_in_echo_area (rep, NULL, NULL);
d4553 1
a4553 1
info_get_another_input_char (void)
d4590 3
a4592 1
info_dispatch_on_key (unsigned char key, Keymap map)
d4622 1
a4622 1
            if (func == (VFunction *) info_do_lowercase_version)
d4730 1
a4730 1
info_initialize_numeric_arg (void)
d4771 2
a4772 3
      if (keymap[key].type == ISFUNC
          && InfoFunction(keymap[key].function)
              == (VFunction *) info_universal_argument)
d4822 1
a4822 1
info_clear_pending_input (void)
d4829 2
a4830 1
info_set_pending_input (unsigned char key)
d4837 1
a4837 1
info_input_pending_p (void)
d4850 2
a4851 1
info_push_typeahead (unsigned char key)
d4862 1
a4862 1
      if ((unsigned int) push_index >= sizeof (info_input_buffer))
d4869 1
a4869 1
info_input_buffer_space_available (void)
d4881 2
a4882 1
info_get_key_from_typeahead (unsigned char *key)
d4889 1
a4889 1
  if ((unsigned int) pop_index >= sizeof (info_input_buffer))
d4896 1
a4896 1
info_any_buffered_input_p (void)
d4905 1
a4905 1
info_gather_typeahead (void)
d4979 1
a4979 1
info_get_input_char (void)
@


