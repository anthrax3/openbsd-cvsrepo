head	1.5;
access;
symbols
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.5
date	99.05.26.16.30.20;	author espie;	state dead;
branches;
next	1.4;

1.4
date	97.04.09.13.44.46;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.04.04.13.21.29;	author graichen;	state Exp;
branches;
next	1.2;

1.2
date	96.12.15.23.37.08;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.07.27.02.52.28;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.5
log
@So long, and thanks for all the bugs.
@
text
@#include <stdio.h>
#include <errno.h>
#ifndef NULL
/* ANSI C */
#include <stddef.h>
#endif

#ifndef SEEK_SET
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2
#endif

#if defined (MSDOS) && !defined (GO32)
#ifndef NON_UNIX_STDIO
#define NON_UNIX_STDIO
#endif
#endif

#ifdef UIOLEN_int
typedef int uiolen;
#else
typedef long uiolen;
#endif

/*units*/
typedef struct
{	FILE *ufd;	/*0=unconnected*/
	char *ufnm;
#if !(defined (MSDOS) && !defined (GO32))
	long uinode;
	int udev;
#endif
	int url;	/*0=sequential*/
	flag useek;	/*true=can backspace, use dir, ...*/
	flag ufmt;
	flag uprnt;
	flag ublnk;
	flag uend;
	flag uwrt;	/*last io was write*/
	flag uscrtch;
} unit;

extern flag f__init;
extern cilist *f__elist;	/*active external io list*/
extern flag f__reading,f__external,f__sequential,f__formatted;
#undef Void
#ifdef KR_headers
#define Void /*void*/
extern int (*f__getn)(),(*f__putn)();	/*for formatted io*/
extern long f__inode();
extern VOID sig_die();
extern int (*f__donewrec)(), t_putc(), x_wSL();
extern int c_sfe(), err__fl(), xrd_SL();
#else
#define Void void
#ifdef __cplusplus
extern "C" {
#endif
extern int (*f__getn)(void),(*f__putn)(int);	/*for formatted io*/
extern long f__inode(char*,int*);
extern void sig_die(char*,int);
extern void f__fatal(int,char*);
extern int t_runc(alist*);
extern int f__nowreading(unit*), f__nowwriting(unit*);
extern int fk_open(int,int,ftnint);
extern int en_fio(void);
extern void f_init(void);
extern int (*f__donewrec)(void), t_putc(int), x_wSL(void);
extern void b_char(char*,char*,ftnlen), g_char(char*,ftnlen,char*);
extern int c_sfe(cilist*), z_rnew(void);
extern int isatty(int);
extern int err__fl(int,int,char*);
extern int xrd_SL(void);
#ifdef __cplusplus
	}
#endif
#endif
extern int (*f__doend)(Void);
extern FILE *f__cf;	/*current file*/
extern unit *f__curunit;	/*current unit*/
extern unit f__units[];
#define err(f,m,s) {if(f) errno= m; else f__fatal(m,s); return(m);}
#define errfl(f,m,s) return err__fl((int)f,m,s)

/*Table sizes*/
#define MXUNIT 100

extern int f__recpos;	/*position in current record*/
extern int f__cursor;	/* offset to move to */
extern int f__hiwater;	/* so TL doesn't confuse us */

#define WRITE	1
#define READ	2
#define SEQ	3
#define DIR	4
#define FMT	5
#define UNF	6
#define EXT	7
#define INT	8

#define buf_end(x) (x->_flag & _IONBF ? x->_ptr : x->_base + BUFSIZ)
@


1.4
log
@Revert to older (working) version of gcc, plus recent changes.
@
text
@@


1.3
log
@sync g77 to version 0.5.20 - i hope i got everything right because there
is no patch from 0.5.19 to 0.5.20 - so i did it by diffing two gcc trees
looking carefully at the results

what does the new g77 give us:
* now it completely works on the alpha (64bit)
* faster
* less bugs :-)
@
text
@d83 2
a84 2
#define err(f,m,s) do {if(f) errno= m; else f__fatal(m,s); return(m);} while(0)
#define errfl(f,m,s) do {return err__fl((int)f,m,s);} while(0)
@


1.2
log
@Update to g77 0.5.19
@
text
@d83 2
a84 2
#define err(f,m,s) {if(f) errno= m; else f__fatal(m,s); return(m);}
#define errfl(f,m,s) return err__fl((int)f,m,s)
@


1.1
log
@Initial integration of G77.

Please do a make cleandir before rebuilding gcc!
@
text
@d1 2
a2 2
#include "stdio.h"
#include "errno.h"
d5 1
a5 1
#include "stddef.h"
@
