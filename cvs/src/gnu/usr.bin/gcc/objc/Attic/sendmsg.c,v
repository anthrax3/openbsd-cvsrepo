head	1.3;
access;
symbols
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	FSF_2_8_1:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	99.05.26.16.30.47;	author espie;	state dead;
branches;
next	1.2;

1.2
date	98.03.03.21.37.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.06.03;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.06.03;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.27.14;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@So long, and thanks for all the bugs.
@
text
@/* GNU Objective C Runtime message lookup 
   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
   Contributed by Kresten Krab Thorup

This file is part of GNU CC.

GNU CC is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation; either version 2, or (at your option) any later version.

GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
GNU CC; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

/* As a special exception, if you link this library with files compiled with
   GCC to produce an executable, this does not cause the resulting executable
   to be covered by the GNU General Public License. This exception does not
   however invalidate any other reasons why the executable file might be
   covered by the GNU General Public License.  */

#include "../tconfig.h"
#include "runtime.h"
#include "sarray.h"
#include "encoding.h"
#include "runtime-info.h"

/* this is how we hack STRUCT_VALUE to be 1 or 0 */
#define gen_rtx(args...) 1
#define rtx int

#if !defined(STRUCT_VALUE) || STRUCT_VALUE == 0
#define INVISIBLE_STRUCT_RETURN 1
#else
#define INVISIBLE_STRUCT_RETURN 0
#endif

/* The uninstalled dispatch table */
struct sarray* __objc_uninstalled_dtable = 0;   /* !T:MUTEX */

/* Send +initialize to class */
static void __objc_send_initialize(Class);

static void __objc_install_dispatch_table_for_class (Class);

/* Forward declare some functions */
static void __objc_init_install_dtable(id, SEL);

/* Various forwarding functions that are used based upon the
   return type for the selector.
   __objc_block_forward for structures.
   __objc_double_forward for floats/doubles.
   __objc_word_forward for pointers or types that fit in registers.
   */
static double __objc_double_forward(id, SEL, ...);
static id __objc_word_forward(id, SEL, ...);
typedef struct { id many[8]; } __big;
#if INVISIBLE_STRUCT_RETURN 
static __big 
#else
static id
#endif
__objc_block_forward(id, SEL, ...);
static Method_t search_for_method_in_hierarchy (Class class, SEL sel);
Method_t search_for_method_in_list(MethodList_t list, SEL op);
id nil_method(id, SEL, ...);

/* Given a selector, return the proper forwarding implementation. */
__inline__
IMP
__objc_get_forward_imp (SEL sel)
{
  const char *t = sel->sel_types;

  if (t && (*t == '[' || *t == '(' || *t == '{')
#ifdef OBJC_MAX_STRUCT_BY_VALUE
    && objc_sizeof_type(t) > OBJC_MAX_STRUCT_BY_VALUE
#endif
      )
    return (IMP)__objc_block_forward;
  else if (t && (*t == 'f' || *t == 'd'))
    return (IMP)__objc_double_forward;
  else
    return (IMP)__objc_word_forward;
}

/* Given a class and selector, return the selector's implementation.  */
__inline__
IMP
get_imp (Class class, SEL sel)
{
  void* res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);
  if (res == 0)
    {
      /* Not a valid method */
      if(class->dtable == __objc_uninstalled_dtable)
	{
	  /* The dispatch table needs to be installed. */
	  objc_mutex_lock(__objc_runtime_mutex);
	  __objc_install_dispatch_table_for_class (class);
	  objc_mutex_unlock(__objc_runtime_mutex);
	  /* Call ourselves with the installed dispatch table
	     and get the real method */
	  res = get_imp(class, sel);
	}
      else
	{
	  /* The dispatch table has been installed so the
	     method just doesn't exist for the class.
	     Return the forwarding implementation. */
	  res = __objc_get_forward_imp(sel);
	}
    }
  return res;
}

/* Query if an object can respond to a selector, returns YES if the
object implements the selector otherwise NO.  Does not check if the
method can be forwarded. */
__inline__
BOOL
__objc_responds_to (id object, SEL sel)
{
  void* res;

  /* Install dispatch table if need be */
  if (object->class_pointer->dtable == __objc_uninstalled_dtable)
    {
      objc_mutex_lock(__objc_runtime_mutex);
      __objc_install_dispatch_table_for_class (object->class_pointer);
      objc_mutex_unlock(__objc_runtime_mutex);
    }

  /* Get the method from the dispatch table */
  res = sarray_get_safe (object->class_pointer->dtable, (size_t) sel->sel_id);
  return (res != 0);
}

/* This is the lookup function.  All entries in the table are either a 
   valid method *or* zero.  If zero then either the dispatch table
   needs to be installed or it doesn't exist and forwarding is attempted. */
__inline__
IMP
objc_msg_lookup(id receiver, SEL op)
{
  IMP result;
  if(receiver)
    {
      result = sarray_get_safe (receiver->class_pointer->dtable, 
				(sidx)op->sel_id);
      if (result == 0)
	{
	  /* Not a valid method */
	  if(receiver->class_pointer->dtable == __objc_uninstalled_dtable)
	    {
	      /* The dispatch table needs to be installed.
		 This happens on the very first method call to the class. */
	      __objc_init_install_dtable(receiver, op);

	      /* Get real method for this in newly installed dtable */
	      result = get_imp(receiver->class_pointer, op);
	    }
	  else
	    {
	      /* The dispatch table has been installed so the
		 method just doesn't exist for the class.
		 Attempt to forward the method. */
	      result = __objc_get_forward_imp(op);
	    }
	}
      return result;
    }
  else
    return nil_method;
}

IMP
objc_msg_lookup_super (Super_t super, SEL sel)
{
  if (super->self)
    return get_imp (super->class, sel);
  else
    return nil_method;
}

int method_get_sizeof_arguments (Method*);

retval_t
objc_msg_sendv(id object, SEL op, arglist_t arg_frame)
{
  Method* m = class_get_instance_method(object->class_pointer, op);
  const char *type;
  *((id*)method_get_first_argument (m, arg_frame, &type)) = object;
  *((SEL*)method_get_next_argument (arg_frame, &type)) = op;
  return __builtin_apply((apply_t)m->method_imp, 
			 arg_frame,
			 method_get_sizeof_arguments (m));
}

void
__objc_init_dispatch_tables()
{
  __objc_uninstalled_dtable
    = sarray_new(200, 0);
}

/* This function is called by objc_msg_lookup when the
   dispatch table needs to be installed; thus it is called once
   for each class, namely when the very first message is sent to it. */
static void
__objc_init_install_dtable(id receiver, SEL op)
{
  /* This may happen, if the programmer has taken the address of a 
     method before the dtable was initialized... too bad for him! */
  if(receiver->class_pointer->dtable != __objc_uninstalled_dtable)
    return;

  objc_mutex_lock(__objc_runtime_mutex);

  if(CLS_ISCLASS(receiver->class_pointer))
    {
      /* receiver is an ordinary object */
      assert(CLS_ISCLASS(receiver->class_pointer));

      /* install instance methods table */
      __objc_install_dispatch_table_for_class (receiver->class_pointer);

      /* call +initialize -- this will in turn install the factory 
	 dispatch table if not already done :-) */
      __objc_send_initialize(receiver->class_pointer);
    }
  else
    {
      /* receiver is a class object */
      assert(CLS_ISCLASS((Class)receiver));
      assert(CLS_ISMETA(receiver->class_pointer));

      /* Install real dtable for factory methods */
      __objc_install_dispatch_table_for_class (receiver->class_pointer);

      if (strcmp (sel_get_name (op), "initialize"))
	__objc_send_initialize((Class)receiver);
      else
	CLS_SETINITIALIZED((Class)receiver);
    }
  objc_mutex_unlock(__objc_runtime_mutex);
}

/* Install dummy table for class which causes the first message to
   that class (or instances hereof) to be initialized properly */
void
__objc_install_premature_dtable(Class class)
{
  assert(__objc_uninstalled_dtable);
  class->dtable = __objc_uninstalled_dtable;
}   

/* Send +initialize to class if not already done */
static void
__objc_send_initialize(Class class)
{
  /* This *must* be a class object */
  assert(CLS_ISCLASS(class));
  assert(!CLS_ISMETA(class));

  if (!CLS_ISINITIALIZED(class))
    {
      CLS_SETINITIALIZED(class);
      CLS_SETINITIALIZED(class->class_pointer);
      
      if(class->super_class)
	__objc_send_initialize(class->super_class);

      {
	SEL 	op = sel_register_name ("initialize");
	Class	tmpclass = class;
	IMP	imp = 0;

	while (!imp && tmpclass) {
	  MethodList_t method_list = tmpclass->class_pointer->methods;

	  while(!imp && method_list) {
	    int i;
	    Method_t method;

	    for (i=0;i<method_list->method_count;i++) {
	      method = &(method_list->method_list[i]);
	      if (method->method_name
		  && method->method_name->sel_id == op->sel_id) {
	        imp = method->method_imp;
	        break;
	      }
	    }

	    method_list = method_list->method_next;

	  }

	  tmpclass = tmpclass->super_class;
	}
	if (imp)
	    (*imp)((id)class, op);
		
      }
    }
}

/* Walk on the methods list of class and install the methods in the reverse
   order of the lists. Since methods added by categories are before the methods
   of class in the methods list, this allows categories to substitute methods
   declared in class. However if more than one category replaces the same
   method nothing is guaranteed about what method will be used.
   Assumes that __objc_runtime_mutex is locked down. */
static void
__objc_install_methods_in_dtable (Class class, MethodList_t method_list)
{
  int i;

  if (!method_list)
    return;

  if (method_list->method_next)
    __objc_install_methods_in_dtable (class, method_list->method_next);

  for (i = 0; i < method_list->method_count; i++)
    {
      Method_t method = &(method_list->method_list[i]);
      sarray_at_put_safe (class->dtable,
			  (sidx) method->method_name->sel_id,
			  method->method_imp);
    }
}

/* Assumes that __objc_runtime_mutex is locked down. */
static void
__objc_install_dispatch_table_for_class (Class class)
{
  Class super;

  /* If the class has not yet had it's class links resolved, we must 
     re-compute all class links */
  if(!CLS_ISRESOLV(class))
    __objc_resolve_class_links();

  super = class->super_class;

  if (super != 0 && (super->dtable == __objc_uninstalled_dtable))
    __objc_install_dispatch_table_for_class (super);

  /* Allocate dtable if necessary */
  if (super == 0)
    {
      objc_mutex_lock(__objc_runtime_mutex);
      class->dtable = sarray_new (__objc_selector_max_index, 0);
      objc_mutex_unlock(__objc_runtime_mutex);
    }
  else
    class->dtable = sarray_lazy_copy (super->dtable);

  __objc_install_methods_in_dtable (class, class->methods);
}

void
__objc_update_dispatch_table_for_class (Class class)
{
  Class next;
  struct sarray *arr;

  /* not yet installed -- skip it */
  if (class->dtable == __objc_uninstalled_dtable) 
    return;

  objc_mutex_lock(__objc_runtime_mutex);

  arr = class->dtable;
  __objc_install_premature_dtable (class); /* someone might require it... */
  sarray_free (arr);			   /* release memory */

  /* could have been lazy... */
  __objc_install_dispatch_table_for_class (class); 

  if (class->subclass_list)	/* Traverse subclasses */
    for (next = class->subclass_list; next; next = next->sibling_class)
      __objc_update_dispatch_table_for_class (next);

  objc_mutex_unlock(__objc_runtime_mutex);
}


/* This function adds a method list to a class.  This function is
   typically called by another function specific to the run-time.  As
   such this function does not worry about thread safe issues.

   This one is only called for categories. Class objects have their
   methods installed right away, and their selectors are made into
   SEL's by the function __objc_register_selectors_from_class. */ 
void
class_add_method_list (Class class, MethodList_t list)
{
  int i;

  /* Passing of a linked list is not allowed.  Do multiple calls.  */
  assert (!list->method_next);

  /* Check for duplicates.  */
  for (i = 0; i < list->method_count; ++i)
    {
      Method_t method = &list->method_list[i];

      if (method->method_name)  /* Sometimes these are NULL */
	{
	  /* This is where selector names are transmogrified to SEL's */
	  method->method_name = 
	    sel_register_typed_name ((const char*)method->method_name,
				     method->method_types);
	}
    }

  /* Add the methods to the class's method list.  */
  list->method_next = class->methods;
  class->methods = list;

  /* Update the dispatch table of class */
  __objc_update_dispatch_table_for_class (class);
}

Method_t
class_get_instance_method(Class class, SEL op)
{
  return search_for_method_in_hierarchy(class, op);
}

Method_t
class_get_class_method(MetaClass class, SEL op)
{
  return search_for_method_in_hierarchy(class, op);
}


/* Search for a method starting from the current class up its hierarchy.
   Return a pointer to the method's method structure if found.  NULL
   otherwise. */   

static Method_t
search_for_method_in_hierarchy (Class cls, SEL sel)
{
  Method_t method = NULL;
  Class class;

  if (! sel_is_mapped (sel))
    return NULL;

  /* Scan the method list of the class.  If the method isn't found in the
     list then step to its super class. */
  for (class = cls; ((! method) && class); class = class->super_class)
    method = search_for_method_in_list (class->methods, sel);

  return method;
}



/* Given a linked list of method and a method's name.  Search for the named
   method's method structure.  Return a pointer to the method's method
   structure if found.  NULL otherwise. */  
Method_t
search_for_method_in_list (MethodList_t list, SEL op)
{
  MethodList_t method_list = list;

  if (! sel_is_mapped (op))
    return NULL;

  /* If not found then we'll search the list.  */
  while (method_list)
    {
      int i;

      /* Search the method list.  */
      for (i = 0; i < method_list->method_count; ++i)
        {
          Method_t method = &method_list->method_list[i];

          if (method->method_name)
            if (method->method_name->sel_id == op->sel_id)
              return method;
        }

      /* The method wasn't found.  Follow the link to the next list of
         methods.  */
      method_list = method_list->method_next;
    }

  return NULL;
}

static retval_t __objc_forward (id object, SEL sel, arglist_t args);

/* Forwarding pointers/integers through the normal registers */
static id
__objc_word_forward (id rcv, SEL op, ...)
{
  void *args, *res;

  args = __builtin_apply_args ();
  res = __objc_forward (rcv, op, args);
  if (res)
    __builtin_return (res);
  else
    return res;
}

/* Specific routine for forwarding floats/double because of
   architectural differences on some processors.  i386s for
   example which uses a floating point stack versus general
   registers for floating point numbers.  This forward routine 
   makes sure that GCC restores the proper return values */
static double
__objc_double_forward (id rcv, SEL op, ...)
{
  void *args, *res;

  args = __builtin_apply_args ();
  res = __objc_forward (rcv, op, args);
  __builtin_return (res);
}

#if INVISIBLE_STRUCT_RETURN
static __big
#else
static id
#endif
__objc_block_forward (id rcv, SEL op, ...)
{
  void *args, *res;

  args = __builtin_apply_args ();
  res = __objc_forward (rcv, op, args);
  if (res)
    __builtin_return (res);
  else
#if INVISIBLE_STRUCT_RETURN
    return (__big) {0};
#else
    return nil;
#endif
}


/* This function is installed in the dispatch table for all methods which are
   not implemented.  Thus, it is called when a selector is not recognized. */
static retval_t
__objc_forward (id object, SEL sel, arglist_t args)
{
  IMP imp;
  static SEL frwd_sel = 0;                      /* !T:SAFE2 */
  SEL err_sel;

  /* first try if the object understands forward:: */
  if (!frwd_sel)
    frwd_sel = sel_get_any_uid("forward::");

  if (__objc_responds_to (object, frwd_sel))
    {
      imp = get_imp(object->class_pointer, frwd_sel);
      return (*imp)(object, frwd_sel, sel, args);
    }

  /* If the object recognizes the doesNotRecognize: method then we're going
     to send it. */
  err_sel = sel_get_any_uid ("doesNotRecognize:");
  if (__objc_responds_to (object, err_sel))
    {
      imp = get_imp (object->class_pointer, err_sel);
      return (*imp) (object, err_sel, sel);
    }
  
  /* The object doesn't recognize the method.  Check for responding to
     error:.  If it does then sent it. */
  {
    size_t strlen (const char*);
    char msg[256 + strlen ((const char*)sel_get_name (sel))
             + strlen ((const char*)object->class_pointer->name)];

    sprintf (msg, "(%s) %s does not recognize %s",
	     (CLS_ISMETA(object->class_pointer)
	      ? "class"
	      : "instance" ),
             object->class_pointer->name, sel_get_name (sel));

    err_sel = sel_get_any_uid ("error:");
    if (__objc_responds_to (object, err_sel))
      {
	imp = get_imp (object->class_pointer, err_sel);
	return (*imp) (object, sel_get_any_uid ("error:"), msg);
      }

    /* The object doesn't respond to doesNotRecognize: or error:;  Therefore,
       a default action is taken. */
    objc_error (object, OBJC_ERR_UNIMPLEMENTED, "%s\n", msg);

    return 0;
  }
}

void
__objc_print_dtable_stats()
{
  int total = 0;

  objc_mutex_lock(__objc_runtime_mutex);

  printf("memory usage: (%s)\n",
#ifdef OBJC_SPARSE2
	 "2-level sparse arrays"
#else
	 "3-level sparse arrays"
#endif
	 );

  printf("arrays: %d = %ld bytes\n", narrays, 
	 (long)narrays*sizeof(struct sarray));
  total += narrays*sizeof(struct sarray);
  printf("buckets: %d = %ld bytes\n", nbuckets, 
	 (long)nbuckets*sizeof(struct sbucket));
  total += nbuckets*sizeof(struct sbucket);

  printf("idxtables: %d = %ld bytes\n", idxsize, (long)idxsize*sizeof(void*));
  total += idxsize*sizeof(void*);
  printf("-----------------------------------\n");
  printf("total: %d bytes\n", total);
  printf("===================================\n");

  objc_mutex_unlock(__objc_runtime_mutex);
}

/* Returns the uninstalled dispatch table indicator.
 If a class' dispatch table points to __objc_uninstalled_dtable
 then that means it needs its dispatch table to be installed. */
__inline__
struct sarray* 
objc_get_uninstalled_dtable()
{
  return __objc_uninstalled_dtable;
}
@


1.2
log
@GCC 2.8.0 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1995 Free Software Foundation, Inc.
d31 1
d37 1
a37 1
#if STRUCT_VALUE == 0
d44 1
a44 1
struct sarray* __objc_uninstalled_dtable = 0;
d53 8
d70 1
a70 1
static Method_t search_for_method_in_list(MethodList_t list, SEL op);
d73 4
a76 2
id
nil_method(id receiver, SEL op, ...)
d78 12
a89 1
  return receiver;
d97 1
a97 7
  IMP impl;
  void* res = sarray_get (class->dtable, (size_t) sel->sel_id);
  if(res == __objc_init_install_dtable)
    {
      __objc_install_dispatch_table_for_class (class);
      res = sarray_get (class->dtable, (size_t) sel->sel_id);
    }
d100 11
a110 3
      const char *t = sel->sel_types;
      if (t && (*t == '[' || *t == '(' || *t == '{'))
	res = (IMP)__objc_block_forward;
d112 6
a117 1
	res = (IMP)__objc_word_forward;
d122 5
a126 1
__inline__ BOOL
d129 4
a132 2
  void* res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);
  if(res == __objc_init_install_dtable)
d134 1
d136 1
a136 1
      res = sarray_get (object->class_pointer->dtable, (size_t) sel->sel_id);
d138 3
d145 4
a148 4
   valid method *or* one of `__objc_missing_method' which calls
   forward:: etc, or `__objc_init_install_dtable' which installs the
   real dtable */
__inline__ IMP
d154 2
a155 1
      result = sarray_get(receiver->class_pointer->dtable, (sidx)op->sel_id);
d158 10
a167 3
	  const char *t = op->sel_types;
	  if (t && (*t == '[' || *t == '(' || *t == '{'))
	    result = (IMP)__objc_block_forward;
d169 6
a174 1
	    result = (IMP)__objc_word_forward;
d205 2
a206 1
void __objc_init_dispatch_tables()
d209 1
a209 1
    = sarray_new(200, __objc_init_install_dtable);
d212 5
a216 5
/* This one is a bit hairy.  This function is installed in the 
   premature dispatch table, and thus called once for each class,
   namely when the very first message is send to it.  */

static void __objc_init_install_dtable(id receiver, SEL op)
a217 5
  __label__ already_initialized;
  IMP imp;
  void* args;
  void* result;

d221 3
a223 1
    goto already_initialized;
d251 1
a251 13

already_initialized:
  
  /* Get real method for this in newly installed dtable */
  imp = get_imp(receiver->class_pointer, op);

  args = __builtin_apply_args();
  result = __builtin_apply((apply_t)imp, args, 96);
  if (result)
    __builtin_return (result);
  else
    return;
  
d256 2
a257 1
void __objc_install_premature_dtable(Class class)
d264 2
a265 1
static void __objc_send_initialize(Class class)
d293 2
a294 1
	      if (method->method_name->sel_id == op->sel_id) {
d311 27
a337 1
}  
d339 1
a343 2
  MethodList_t mlist;
  int counter;
d358 1
d360 1
d365 1
a365 12
  for (mlist = class->methods; mlist; mlist = mlist->method_next)
    {
      counter = mlist->method_count - 1;
      while (counter >= 0)
        {
          Method_t method = &(mlist->method_list[counter]);
	  sarray_at_put_safe (class->dtable,
			      (sidx) method->method_name->sel_id,
			      method->method_imp);
          counter -= 1;
        }
    }
d368 2
a369 1
void __objc_update_dispatch_table_for_class (Class class)
d372 1
d378 3
a380 1
  sarray_free (class->dtable);	/* release memory */
d382 4
a385 1
  __objc_install_dispatch_table_for_class (class); /* could have been lazy... */
d391 1
d397 1
a397 1
   such this function does not worry about thread safe issued.
a405 3
  static SEL initialize_sel = 0;
  if (!initialize_sel)
    initialize_sel = sel_register_name ("initialize");
a420 10

	  if (search_for_method_in_list (class->methods, method->method_name)
	      && method->method_name->sel_id != initialize_sel->sel_id)
	    {
	      /* Duplication. Print a error message an change the method name
		 to NULL. */
	      fprintf (stderr, "attempt to add a existing method: %s\n",
		       sel_get_name(method->method_name));
	      method->method_name = 0;
	    }
d427 3
a431 1

d471 1
a471 1
static Method_t
d504 1
d518 15
d546 6
d561 1
a561 1
  static SEL frwd_sel = 0;
d605 3
a607 2
    fprintf (stderr, "fatal: %s\n", msg);
    abort ();
d611 2
a612 1
void __objc_print_dtable_stats()
d615 3
d626 2
a627 1
  printf("arrays: %d = %ld bytes\n", narrays, (int)narrays*sizeof(struct sarray));
d629 2
a630 1
  printf("buckets: %d = %ld bytes\n", nbuckets, (int)nbuckets*sizeof(struct sbucket));
d633 1
a633 1
  printf("idxtables: %d = %ld bytes\n", idxsize, (int)idxsize*sizeof(void*));
d638 2
d642 9
a650 2


@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.
a30 1
#include "runtime-info.h"
d36 1
a36 1
#if !defined(STRUCT_VALUE) || STRUCT_VALUE == 0
d43 1
a43 1
struct sarray* __objc_uninstalled_dtable = 0;   /* !T:MUTEX */
a51 8

/* Various forwarding functions that are used based upon the
   return type for the selector.
   __objc_block_forward for structures.
   __objc_double_forward for floats/doubles.
   __objc_word_forward for pointers or types that fit in registers.
   */
static double __objc_double_forward(id, SEL, ...);
d61 1
a61 1
Method_t search_for_method_in_list(MethodList_t list, SEL op);
d64 2
a65 4
/* Given a selector, return the proper forwarding implementation. */
__inline__
IMP
__objc_get_forward_imp (SEL sel)
d67 1
a67 12
  const char *t = sel->sel_types;

  if (t && (*t == '[' || *t == '(' || *t == '{')
#ifdef OBJC_MAX_STRUCT_BY_VALUE
    && objc_sizeof_type(t) > OBJC_MAX_STRUCT_BY_VALUE
#endif
      )
    return (IMP)__objc_block_forward;
  else if (t && (*t == 'f' || *t == 'd'))
    return (IMP)__objc_double_forward;
  else
    return (IMP)__objc_word_forward;
d75 7
a81 1
  void* res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);
d84 3
a86 11
      /* Not a valid method */
      if(class->dtable == __objc_uninstalled_dtable)
	{
	  /* The dispatch table needs to be installed. */
	  objc_mutex_lock(__objc_runtime_mutex);
	  __objc_install_dispatch_table_for_class (class);
	  objc_mutex_unlock(__objc_runtime_mutex);
	  /* Call ourselves with the installed dispatch table
	     and get the real method */
	  res = get_imp(class, sel);
	}
d88 1
a88 6
	{
	  /* The dispatch table has been installed so the
	     method just doesn't exist for the class.
	     Return the forwarding implementation. */
	  res = __objc_get_forward_imp(sel);
	}
d93 1
a93 5
/* Query if an object can respond to a selector, returns YES if the
object implements the selector otherwise NO.  Does not check if the
method can be forwarded. */
__inline__
BOOL
d96 2
a97 4
  void* res;

  /* Install dispatch table if need be */
  if (object->class_pointer->dtable == __objc_uninstalled_dtable)
a98 1
      objc_mutex_lock(__objc_runtime_mutex);
d100 1
a100 1
      objc_mutex_unlock(__objc_runtime_mutex);
a101 3

  /* Get the method from the dispatch table */
  res = sarray_get_safe (object->class_pointer->dtable, (size_t) sel->sel_id);
d106 4
a109 4
   valid method *or* zero.  If zero then either the dispatch table
   needs to be installed or it doesn't exist and forwarding is attempted. */
__inline__
IMP
d115 1
a115 2
      result = sarray_get_safe (receiver->class_pointer->dtable, 
				(sidx)op->sel_id);
d118 3
a120 10
	  /* Not a valid method */
	  if(receiver->class_pointer->dtable == __objc_uninstalled_dtable)
	    {
	      /* The dispatch table needs to be installed.
		 This happens on the very first method call to the class. */
	      __objc_init_install_dtable(receiver, op);

	      /* Get real method for this in newly installed dtable */
	      result = get_imp(receiver->class_pointer, op);
	    }
d122 1
a122 6
	    {
	      /* The dispatch table has been installed so the
		 method just doesn't exist for the class.
		 Attempt to forward the method. */
	      result = __objc_get_forward_imp(op);
	    }
d153 1
a153 2
void
__objc_init_dispatch_tables()
d156 1
a156 1
    = sarray_new(200, 0);
d159 5
a163 5
/* This function is called by objc_msg_lookup when the
   dispatch table needs to be installed; thus it is called once
   for each class, namely when the very first message is sent to it. */
static void
__objc_init_install_dtable(id receiver, SEL op)
d165 5
d173 1
a173 3
    return;

  objc_mutex_lock(__objc_runtime_mutex);
d201 13
a213 1
  objc_mutex_unlock(__objc_runtime_mutex);
d218 1
a218 2
void
__objc_install_premature_dtable(Class class)
d225 1
a225 2
static void
__objc_send_initialize(Class class)
d253 1
a253 2
	      if (method->method_name
		  && method->method_name->sel_id == op->sel_id) {
d270 1
a270 27
}

/* Walk on the methods list of class and install the methods in the reverse
   order of the lists. Since methods added by categories are before the methods
   of class in the methods list, this allows categories to substitute methods
   declared in class. However if more than one category replaces the same
   method nothing is guaranteed about what method will be used.
   Assumes that __objc_runtime_mutex is locked down. */
static void
__objc_install_methods_in_dtable (Class class, MethodList_t method_list)
{
  int i;

  if (!method_list)
    return;

  if (method_list->method_next)
    __objc_install_methods_in_dtable (class, method_list->method_next);

  for (i = 0; i < method_list->method_count; i++)
    {
      Method_t method = &(method_list->method_list[i]);
      sarray_at_put_safe (class->dtable,
			  (sidx) method->method_name->sel_id,
			  method->method_imp);
    }
}
a271 1
/* Assumes that __objc_runtime_mutex is locked down. */
d276 2
a291 1
      objc_mutex_lock(__objc_runtime_mutex);
a292 1
      objc_mutex_unlock(__objc_runtime_mutex);
d297 12
a308 1
  __objc_install_methods_in_dtable (class, class->methods);
d311 1
a311 2
void
__objc_update_dispatch_table_for_class (Class class)
a313 1
  struct sarray *arr;
d319 1
a319 3
  objc_mutex_lock(__objc_runtime_mutex);

  arr = class->dtable;
d321 1
a321 4
  sarray_free (arr);			   /* release memory */

  /* could have been lazy... */
  __objc_install_dispatch_table_for_class (class); 
a326 1
  objc_mutex_unlock(__objc_runtime_mutex);
d332 1
a332 1
   such this function does not worry about thread safe issues.
d341 3
d359 10
d375 1
a376 3
  /* Update the dispatch table of class */
  __objc_update_dispatch_table_for_class (class);
}
d417 1
a417 1
Method_t
a449 1
/* Forwarding pointers/integers through the normal registers */
a462 15
/* Specific routine for forwarding floats/double because of
   architectural differences on some processors.  i386s for
   example which uses a floating point stack versus general
   registers for floating point numbers.  This forward routine 
   makes sure that GCC restores the proper return values */
static double
__objc_double_forward (id rcv, SEL op, ...)
{
  void *args, *res;

  args = __builtin_apply_args ();
  res = __objc_forward (rcv, op, args);
  __builtin_return (res);
}

a475 6
  else
#if INVISIBLE_STRUCT_RETURN
    return (__big) {0};
#else
    return nil;
#endif
d485 1
a485 1
  static SEL frwd_sel = 0;                      /* !T:SAFE2 */
d529 2
a530 3
    objc_error (object, OBJC_ERR_UNIMPLEMENTED, "%s\n", msg);

    return 0;
d534 1
a534 2
void
__objc_print_dtable_stats()
a536 3

  objc_mutex_lock(__objc_runtime_mutex);

d545 1
a545 2
  printf("arrays: %d = %ld bytes\n", narrays, 
	 (long)narrays*sizeof(struct sarray));
d547 1
a547 2
  printf("buckets: %d = %ld bytes\n", nbuckets, 
	 (long)nbuckets*sizeof(struct sbucket));
d550 1
a550 1
  printf("idxtables: %d = %ld bytes\n", idxsize, (long)idxsize*sizeof(void*));
d555 2
a557 2
  objc_mutex_unlock(__objc_runtime_mutex);
}
a558 9
/* Returns the uninstalled dispatch table indicator.
 If a class' dispatch table points to __objc_uninstalled_dtable
 then that means it needs its dispatch table to be installed. */
__inline__
struct sarray* 
objc_get_uninstalled_dtable()
{
  return __objc_uninstalled_dtable;
}
@

