head	1.3;
access;
symbols
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	FSF_2_8_1:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.3
date	99.05.26.16.24.27;	author espie;	state dead;
branches;
next	1.2;

1.2
date	98.03.03.21.23.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.04.05;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.04.05;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.16.18;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@So long, and thanks for all the bugs.
@
text
@;; GCC machine description for Hitachi H8/300
;; Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.

;;   Contributed by Steve Chamberlain (sac@@cygnus.com),
;;   Jim Wilson (wilson@@cygnus.com), and Doug Evans (dje@@cygnus.com).

;; This file is part of GNU CC.

;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; The original PO technology requires these to be ordered by speed,
;; so that assigner will pick the fastest.

;; See file "rtl.def" for documentation on define_insn, match_*, et. al.

(define_attr "cpu" "h8300,h8300h"
  (const (symbol_ref "cpu_type")))

;; Many logical operations should have "bit" variants if only one
;; bit is going to be operated on.

;; (and (logical op) (const_int X))
;; If const_int only specifies a few bits (like a single byte in a 4 byte
;; operation, then it's more efficient to only apply the and and logical_op
;; to the bits we care about.

;; Some of the extend instructions accept a general_operand_src, which
;; allows all the normal memory addressing modes.  The length computations
;; don't take this into account.  The lengths in the MD file should be
;; "worst case" and then be adjusted to their correct values by
;; h8300_adjust_insn_length.

;; On the h8300h, adds/subs operate on the 32bit "er" registers.  Right
;; now GCC doesn't expose the "e" half to the compiler, so using add/subs
;; for addhi and subhi is safe.
;; Long term, we want to expose the "e" half to the compiler (gives us
;; 8 more 16bit registers).  At that point addhi and subhi can't use adds/subs.

;; There's currently no way to have a insv/extzv expander for the h8/300h
;; because word_mode is different for the h8/300 and h8/300h.

;; Shifts/rotates by small constants should be handled by special
;; patterns so we get the length and cc status correct.

;; Bitfield operations no longer accept memory operands.  We need
;; to add variants which operate on memory back to the MD.

;; ??? Implement remaining bit ops available on the h8300

(define_attr "type" "branch,arith"
  (const_string "arith"))

;; The size of instructions in bytes.

(define_attr "length" "" 
  (cond [(eq_attr "type" "branch")
	 (if_then_else (and (ge (minus (pc) (match_dup 0))
				(const_int -120))
			    (le (minus (pc) (match_dup 0))
				(const_int 120)))
		       (const_int 2)
		       (if_then_else (and (eq_attr "cpu" "h8300h")
					  (and (ge (minus (pc) (match_dup 0))
						   (const_int -32000))
					       (le (minus (pc) (match_dup 0))
						   (const_int 32000))))
				     (const_int 4)
				     (const_int 6)))]
	(const_int 200)))

;; Condition code settings.
;; none - insn does not affect cc
;; none_0hit - insn does not affect cc but it does modify operand 0
;;	This attribute is used to keep track of when operand 0 changes.
;; 	See the description of NOTICE_UPDATE_CC for more info.
;; set_znv - insn sets z,n,v to usable values (like a tst insn); c is unknown.
;; set_zn  - insn sets z,n to usable values; v,c are unknown.
;; compare - compare instruction
;; clobber - value of cc is unknown
(define_attr "cc" "none,none_0hit,set_znv,set_zn,compare,clobber"
  (const_string "clobber"))

;; ----------------------------------------------------------------------
;; MOVE INSTRUCTIONS
;; ----------------------------------------------------------------------

;; movqi

(define_insn "movqi_push"
  [(set (match_operand:QI 0 "push_operand" "=<")
	(match_operand:QI 1 "register_operand" "r"))]
  ""
  "*
{
  if (TARGET_H8300)
    return \"push.w	%T1\";
  else
    return \"push.l	%S1\";
}"
  [(set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set_znv")])

(define_insn ""
  [(set (match_operand:QI 0 "general_operand_dst" "=r,r,<,r,r,m")
	(match_operand:QI 1 "general_operand_src" "I,r>,r,n,m,r"))]
  "register_operand (operands[0],QImode)
   || register_operand (operands[1], QImode)"
  "@@
   sub.b	%X0,%X0
   mov.b	%R1,%X0
   mov.b	%X1,%R0
   mov.b	%R1,%X0
   mov.b	%R1,%X0
   mov.b	%X1,%R0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2) (const_int 2)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])

(define_expand "movqi"
  [(set (match_operand:QI 0 "general_operand_dst" "")
	(match_operand:QI 1 "general_operand_src" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand(operand0, QImode)
      && !register_operand(operand1, QImode))
    {
      operands[1] = copy_to_mode_reg(QImode, operand1);
    }
}")

(define_insn "movstrictqi"
  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "=r,r,r,r"))
			 (match_operand:QI 1 "general_operand_src" "I,r,n,m"))]
  ""
  "@@
   sub.b	%X0,%X0
   mov.b	%X1,%X0
   mov.b	%R1,%X0
   mov.b	%R1,%X0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv")])
   
;; movhi

;; ??? We use push.l on the h8300h to push a 16bit value?!?  We have
;; 16bit push insns!
(define_insn "movhi_push"
  [(set (match_operand:HI 0 "push_operand" "=<")
	(match_operand:HI 1 "register_operand" "r"))]
  ""
  "*
{
  if (TARGET_H8300)
    return \"push.w	%T1\";
  else
    return \"push.l	%S1\";
}"
  [(set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set_znv")])

(define_insn ""
  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,<,r,r,m")
	(match_operand:HI 1 "general_operand_src" "I,r>,r,i,m,r"))]
  "register_operand (operands[0],HImode)
   || register_operand (operands[1], HImode)"
  "@@
   sub.w	%T0,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2) (const_int 4)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])

(define_expand "movhi"
  [(set (match_operand:HI 0 "general_operand_dst" "")
	(match_operand:HI 1 "general_operand_src" ""))]
  ""
  "
{
  /* One of the ops has to be in a register */
  if (!register_operand(operand1, HImode)
      && !register_operand(operand0, HImode))
    {
      operands[1] = copy_to_mode_reg(HImode, operand1);
    }
}")

(define_insn "movstricthi"
  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "=r,r,r,r"))
			 (match_operand:HI 1 "general_operand_src" "I,r,i,m"))]
  ""
  "@@
   sub.w	%T0,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0
   mov.w	%T1,%T0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 4)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv")])

;; movsi

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand_dst" "")
	(match_operand:SI 1 "general_operand_src" ""))]
  ""
  "
{
  if (TARGET_H8300)
    {
      if (do_movsi (operands))
	DONE;
    }
  else
    {
      /* One of the ops has to be in a register.  */
      if (!register_operand (operand1, SImode)
	  && !register_operand (operand0, SImode))
	{
	  operands[1] = copy_to_mode_reg (SImode, operand1);
	}
    }
}")

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand_dst" "")
	(match_operand:SF 1 "general_operand_src" ""))]
  ""
  "
{
  if (TARGET_H8300)
    {
      if (do_movsi (operands))
	DONE;
    }
  else
    {
      /* One of the ops has to be in a register.  */
      if (!register_operand (operand1, SFmode)
	  && !register_operand (operand0, SFmode))
	{
	  operands[1] = copy_to_mode_reg (SFmode, operand1);
	}
    }
}")

(define_insn "movsi_h8300"
  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,o,<,r")
	(match_operand:SI 1 "general_operand_src" "I,r,io,r,r,>"))]
  "TARGET_H8300
   && (register_operand (operands[0], SImode)
       || register_operand (operands[1], SImode))"
  "*
{
  int rn = -1;
  switch (which_alternative)
    {
    case 0:
      return \"sub.w	%e0,%e0\;sub.w	%f0,%f0\";
    case 1:
      if (REGNO(operands[0]) < REGNO(operands[1]))
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
      else 
	return \"mov.w	%f1,%f0\;mov.w	%e1,%e0\";
    case 2:
      /* Make sure we don't trample the register we index with.  */
    
      if (GET_CODE(operands[1]) == MEM) 
	{
	  rtx inside = XEXP (operands[1],0);
	  if  (REG_P (inside)) 
	    {
	      rn = REGNO(inside);
	    }
	  else if (GET_CODE (inside) == PLUS) 
	    {
	      rtx lhs = XEXP (inside,0);
	      rtx rhs = XEXP (inside,1);
	      if (REG_P (lhs)) rn = REGNO (lhs);
	      if (REG_P (rhs)) rn = REGNO (rhs);
	    }
	}
      if (rn == REGNO (operands[0])) 	
	{
	  /* Move the second word first.  */
	  return \"mov.w	%f1,%f0\;mov.w	%e1,%e0\";
	}
      else 
	{
	  /* See if either half is zero.  If so, use sub.w to clear
	     that half.  */
	if (GET_CODE (operands[1]) == CONST_INT)
	  {
	    if ((INTVAL (operands[1]) & 0xffff) == 0)
	      return \"mov.w	%e1,%e0\;sub.w	%f0,%f0\";
	    if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)
	      return \"sub.w	%e0,%e0\;mov.w	%f1,%f0\";
	  }
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
	}
    case 3:
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
    case 4:
      return \"mov.w	%f1,%T0\;mov.w	%e1,%T0\";
    case 5:
      return \"mov.w	%T1,%e0\;mov.w	%T1,%f0\";
    }
}"
  [(set_attr "length" "4,4,8,8,4,4")
   (set_attr "cc" "clobber")])

(define_insn "movsf_h8300"
  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,o,<,r")
	(match_operand:SF 1 "general_operand_src" "I,r,io,r,r,>"))]
  "TARGET_H8300
   && (register_operand (operands[0], SFmode)
       || register_operand (operands[1], SFmode))"
  "*
{
  /* Copy of the movsi stuff */
  int rn = -1;
  switch (which_alternative)
    {
    case 0:
      return \"sub.w	%e0,%e0\;sub.w	%f0,%f0\";
    case 1:
      if (REGNO(operands[0]) < REGNO(operands[1]))
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
      else 
	return \"mov.w	%f1,%f0\;mov.w	%e1,%e0\";
    case 2:
      /* Make sure we don't trample the register we index with.  */
    
      if (GET_CODE (operands[1]) == MEM) 
	{
	  rtx inside = XEXP (operands[1],0);
	  if (REG_P (inside))
	    {
	      rn = REGNO (inside);
	    }
	  else if (GET_CODE (inside) == PLUS) 
	    {
	      rtx lhs = XEXP (inside,0);
	      rtx rhs = XEXP (inside,1);
	      if (REG_P (lhs)) rn = REGNO (lhs);
	      if (REG_P (rhs)) rn = REGNO (rhs);
	    }
	}
      if (rn == REGNO (operands[0]))
	{
	  /* move the second word first */
	  return \"mov.w	%f1,%f0\;mov.w	%e1,%e0\";
	}
      else 
	{
	  return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
	}
    
    case 3:
      return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
    case 4:
      return \"mov.w	%f1,%T0\;mov.w	%e1,%T0\";
    case 5:
      return \"mov.w	%T1,%e0\;mov.w	%T1,%f0\";

    }
}"
  [(set_attr "length" "4,4,8,8,4,4")
   (set_attr "cc" "clobber")])

(define_insn "movsi_h8300hs"
  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,m,<,r,*a,*a,r")
	(match_operand:SI 1 "general_operand_src" "I,r,im,r,r,>,I,r,*a"))]
  "(TARGET_H8300S || TARGET_H8300H)
   && (register_operand (operands[0], SImode)
       || register_operand (operands[1], SImode))"
  "*
{
  if (which_alternative == 0)
    return \"sub.l	%S0,%S0\";
  if (which_alternative == 6)
    return \"clrmac\";
  if (which_alternative == 7)
    return \"clrmac\;ldmac %1,macl\";
  if (which_alternative == 8)
    return \"stmac macl,%0\";
  if (GET_CODE (operands[1]) == CONST_INT)
    {
      int val = INTVAL (operands[1]);

      /* Look for constants which can be made by adding an 8-bit
	 number to zero in one of the two low bytes.  */
      if (val == (val & 0xff))
	{
	  operands[1] = GEN_INT ((char)val & 0xff);
	  return \"sub.l %S0,%S0\;add.b %1,%w0\";
	}
     
      if (val == (val & 0xff00))
	{
	  operands[1] = GEN_INT ((char)(val >> 8) & 0xff);
	  return \"sub.l %S0,%S0\;add.b %1,%x0\";
	}

      /* Now look for small negative numbers.  We can subtract them
	 from zero to get the desired constant.  */
      if (val == -4 || val == -2 || val == -1)
	{
	  operands[1] = GEN_INT (-INTVAL (operands[1]));
	  return \"sub.l %S0,%S0\;subs %1,%S0\";
	}
    }
   return \"mov.l	%S1,%S0\";
}"
  [(set_attr "length" "2,2,10,10,4,4,2,6,4")
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv")])

(define_insn "movsf_h8300h"
  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,m,<,r")
	(match_operand:SF 1 "general_operand_src" "I,r,im,r,r,>"))]
  "(TARGET_H8300H || TARGET_H8300S)
   && (register_operand (operands[0], SFmode)
       || register_operand (operands[1], SFmode))"
  "@@
   sub.l	%S0,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0"
  [(set_attr "length" "2,2,10,10,4,4")
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])

;; ----------------------------------------------------------------------
;; TEST INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn ""
  [(set (cc0) (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%R0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:HI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:SI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:QI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%R0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
  
(define_insn ""
  [(set (cc0) (zero_extract:HI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:SI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn "tstqi"
  [(set (cc0) (match_operand:QI 0 "register_operand" "r"))]
  ""
  "mov.b	%X0,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_insn "tsthi"
  [(set (cc0) (match_operand:HI 0 "register_operand" "r"))]
  ""
  "mov.w	%T0,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_insn "tstsi"
  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
  "TARGET_H8300H || TARGET_H8300S"
  "mov.l	%S0,%S0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_insn "cmpqi"
  [(set (cc0)
	(compare:QI (match_operand:QI 0 "register_operand" "r")
		    (match_operand:QI 1 "nonmemory_operand" "rn")))]
  ""
  "cmp.b	%X1,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "compare")])

(define_expand "cmphi"
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "register_operand" "")
		    (match_operand:HI 1 "nonmemory_operand" "")))]
  ""
  "
{
  /* Force operand1 into a register if we're compiling
     for the h8/300.  */
  if (GET_CODE (operands[1]) != REG && TARGET_H8300)
    operands[1] = force_reg (HImode, operands[1]);
}")

(define_insn ""
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "register_operand" "r")
		    (match_operand:HI 1 "register_operand" "r")))]
  "TARGET_H8300"
  "cmp.w	%T1,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "compare")])

(define_insn ""
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "register_operand" "r,r")
		    (match_operand:HI 1 "nonmemory_operand" "r,n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "cmp.w	%T1,%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "compare,compare")])

(define_insn "cmpsi"
  [(set (cc0)
	(compare:SI (match_operand:SI 0 "register_operand" "r,r")
		    (match_operand:SI 1 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H || TARGET_H8300S"
  "cmp.l	%S1,%S0"
  [(set_attr "length" "2,6")
   (set_attr "cc" "compare,compare")])

;; ----------------------------------------------------------------------
;; ADD INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(plus:QI (match_operand:QI 1 "register_operand" "%0")
		 (match_operand:QI 2 "nonmemory_operand" "rn")))]
  ""
  "add.b	%X2,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_expand "addhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(plus:HI (match_operand:HI 1 "register_operand" "")
		 (match_operand:HI 2 "nonmemory_operand" "")))]
  ""
  "")

;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0")
		 (match_operand:HI 2 "adds_subs_operand" "n")))]
  ""
  "* return output_adds_subs (operands);"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r,r,&r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,g")
		 (match_operand:HI 2 "nonmemory_operand" "n,r,r")))]
  "TARGET_H8300"
  "@@
   add.b	%s2,%s0\;addx	%t2,%t0 
   add.w	%T2,%T0
   mov.w        %T1,%T0\;add.w  %T2,%T0"
  [(set_attr "length" "4,2,6")
   (set_attr "cc" "clobber,set_zn,set_zn")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0")
		 (match_operand:HI 2 "nonmemory_operand" "n,r")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   add.w	%T2,%T0
   add.w	%T2,%T0"
  [(set_attr "length" "4,2")
   (set_attr "cc" "set_zn,set_zn")])

(define_expand "addsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(plus:SI (match_operand:SI 1 "register_operand" "")
		 (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "")

;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0")
		 (match_operand:SI 2 "adds_subs_operand" "n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "* return output_adds_subs (operands);"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn "addsi_h8300"
  [(set (match_operand:SI 0 "register_operand" "=r,r,&r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,r")
		 (match_operand:SI 2 "nonmemory_operand" "n,r,r")))]
  "TARGET_H8300"
  "@@
   add	%w2,%w0\;addx	%x2,%x0\;addx	%y2,%y0\;addx	%z2,%z0
   add.w	%f2,%f0\;addx	%y2,%y0\;addx	%z2,%z0
   mov.w	%f1,%f0\;mov.w	%e1,%e0\;add.w	%f2,%f0\;addx	%y2,%y0\;addx	%z2,%z0"
  [(set_attr "length" "8,6,10")
   (set_attr "cc" "clobber")])

(define_insn "addsi_h8300h"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0,0")
		 (match_operand:SI 2 "nonmemory_operand" "i,r")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   add.l	%S2,%S0
   add.l	%S2,%S0"
  [(set_attr "length" "6,2")
   (set_attr "cc" "set_zn,set_zn")])

;; ----------------------------------------------------------------------
;; SUBTRACT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(minus:QI (match_operand:QI 1 "register_operand" "0,0")
		  (match_operand:QI 2 "nonmemory_operand" "r,n")))]
  ""
  "@@
   sub.b	%X2,%X0
   add.b	%G2,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_expand "subhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(minus:HI (match_operand:HI 1 "general_operand" "")
		  (match_operand:HI 2 "nonmemory_operand" "")))]
  ""
  "")

;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.  This may not be needed
;; due to instruction canonicalization.
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "register_operand" "r")
		  (match_operand:HI 2 "adds_subs_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT (-INTVAL (operands[2]));
  return output_adds_subs (operands);
}"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,&r")
	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
		  (match_operand:HI 2 "nonmemory_operand" "r,n")))]
  "TARGET_H8300"
  "@@
   sub.w	%T2,%T0
   add.b	%E2,%s0\;addx	%F2,%t0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_zn,clobber")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,&r")
	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
		  (match_operand:HI 2 "nonmemory_operand" "r,n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   sub.w	%T2,%T0
   sub.w	%T2,%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_zn,set_zn")])

(define_expand "subsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(minus:SI (match_operand:SI 1 "register_operand" "")
		  (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "")

(define_insn "subsi3_h8300"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(minus:SI (match_operand:SI 1 "register_operand" "0")
		  (match_operand:SI 2 "register_operand" "r")))]
  "TARGET_H8300"
  "sub.w	%f2,%f0\;subx	%y2,%y0\;subx	%z2,%z0"
  [(set_attr "length" "6")
   (set_attr "cc" "clobber")])

;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.  This may not be needed
;; due to instruction canonicalization.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r")
	(minus:SI (match_operand:SI 1 "general_operand" "0")
		  (match_operand:SI 2 "adds_subs_operand" "n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "*
{
  operands[2] = GEN_INT (-INTVAL (operands[2]));
  return output_adds_subs (operands);
}"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn "subsi3_h8300h"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(minus:SI (match_operand:SI 1 "general_operand" "0,0")
		  (match_operand:SI 2 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   sub.l	%S2,%S0
   sub.l	%S2,%S0"
  [(set_attr "length" "2,6")
   (set_attr "cc" "set_zn,set_zn")])

;; ----------------------------------------------------------------------
;; MULTIPLY INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Note that the h8/300 can only handle umulqihi3.

(define_insn "mulqihi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(mult:HI (sign_extend:HI (match_operand:QI 1 "general_operand" "%0"))
		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
  "TARGET_H8300H || TARGET_H8300S"
  "mulxs.b	%X2,%T0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "mulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI (sign_extend:SI (match_operand:HI 1 "general_operand" "%0"))
		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
  "TARGET_H8300H || TARGET_H8300S"
  "mulxs.w	%T2,%S0"
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])

(define_insn "umulqihi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(mult:HI (zero_extend:HI (match_operand:QI 1 "general_operand" "%0"))
		 (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
  ""
  "mulxu	%X2,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "none_0hit")])

(define_insn "umulhisi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(mult:SI (zero_extend:SI (match_operand:HI 1 "general_operand" "%0"))
		 (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
  "TARGET_H8300H || TARGET_H8300S"
  "mulxu.w	%T2,%S0"
  [(set_attr "length" "2")
   (set_attr "cc" "none_0hit")])

;; This is a "bridge" instruction.  Combine can't cram enough insns
;; together to crate a MAC instruction directly, but it can create
;; this instruction, which then allows combine to create the real
;; MAC insn.
;;
;; Unfortunately, if combine doesn't create a MAC instruction, this
;; insn must generate reasonably correct code.  Egad.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=a")
	(mult:SI
	  (sign_extend:SI
	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
	  (sign_extend:SI
	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))]
  "TARGET_H8300S"
  "clrmac\;mac	%2,%1"
  [(set_attr "length" "6")
   (set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=a")
	(plus (mult:SI
	  (sign_extend:SI (mem:HI
	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
	  (sign_extend:SI (mem:HI
	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
	      (match_operand:SI 3 "register_operand" "0")))]
  "TARGET_H8300S"
  "mac	%2,%1"
  [(set_attr "length" "4")
   (set_attr "cc" "none_0hit")])

;; ----------------------------------------------------------------------
;; DIVIDE INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "udivqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI
	  (udiv:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
  ""
  "divxu	%X2,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "clobber")])

;; ??? Will divxu always work here?

(define_insn "divqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI
	  (div:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
  ""
  "divxu	%X2,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "clobber")])

(define_insn "udivhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI
	  (udiv:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
  "divxu.w	%T2,%S0"
  [(set_attr "length" "2")
   (set_attr "cc" "clobber")])

(define_insn "divhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI
	  (div:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
  "divxs.w	%T2,%S0"
  [(set_attr "length" "4")
   (set_attr "cc" "clobber")])

;; ----------------------------------------------------------------------
;; MOD INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "umodqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI
	  (umod:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
  ""
  "divxu	%X2,%T0\;mov %t0,%s0"
  [(set_attr "length" "4")
   (set_attr "cc" "clobber")])

(define_insn "modqi3"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(truncate:QI
	  (mod:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
  "divxs.b	%X2,%T0\;mov %t0,%s0"
  [(set_attr "length" "6")
   (set_attr "cc" "clobber")])

(define_insn "umodhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI
	  (umod:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
  "divxu.w	%T2,%S0\;mov %e0,%f0"
  [(set_attr "length" "4")
   (set_attr "cc" "clobber")])

(define_insn "modhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(truncate:HI
	  (mod:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
  "divxs.w	%T2,%S0\;mov %e0,%f0"
  [(set_attr "length" "6")
   (set_attr "cc" "clobber")])

;; ----------------------------------------------------------------------
;; AND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn ""
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(and:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,O")))]
  "register_operand (operands[0], QImode) || o_operand (operands[2], QImode)"
  "@@
   and	%X2,%X0
   bclr	%W2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])

(define_expand "andqi3"
  [(set (match_operand:QI 0 "bit_operand" "")
	(and:QI (match_operand:QI 1 "bit_operand" "")
		(match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "
{
  if (fix_bit_operand (operands, 'O', AND))
    DONE;
}")

(define_insn "andhi3"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(and:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "nonmemory_operand" "rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);

      if ((i & 0x00ff) != 0x00ff) 
	output_asm_insn (\"and	%s2,%s0\", operands);
      if ((i & 0xff00) != 0xff00) 
	output_asm_insn (\"and	%t2,%t0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"and.w %T2,%T0\";
  return \"and	%s2,%s0\;and	%t2,%t0;\";
}"
  [(set_attr "length" "4")
   (set_attr "cc" "clobber")])

(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(and:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "nonmemory_operand" "rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);
      int upper_cleared, lower_cleared;

      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, or they're
	 going to be zero'd out, then we can work on the
	 low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && ((i & 0xffff0000) != 0xffff0000
	      || (i & 0xffff0000) == 0x00000000))
        return \"and.l	%S2,%S0\";

      lower_cleared = 0;
      if ((i & 0x0000ffff) == 0x00000000)
	{
	  output_asm_insn (\"sub.w	%f0,%f0\", operands);
	  lower_cleared = 1;
	}

      upper_cleared = 0;
      if ((i & 0xffff0000) == 0x00000000)
	{
	  output_asm_insn (\"sub.w	%e0,%e0\", operands);
	  upper_cleared = 1;
	}

      if ((i & 0x000000ff) != 0x000000ff && !lower_cleared)
	output_asm_insn (\"and	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0x0000ff00 && !lower_cleared)
	output_asm_insn (\"and	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared) 
	output_asm_insn (\"and	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0xff000000 && !upper_cleared) 
	output_asm_insn (\"and	%z2,%z0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"and.l	%S2,%S0\";
  return \"and	%w2,%w0\;and	%x2,%x0\;and	%y2,%y0\;and	%z2,%z0\;\";
}"
  [(set_attr "length" "8")
   (set_attr "cc" "clobber")])


;; ----------------------------------------------------------------------
;; OR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn ""
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(ior:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,P")))]
  "register_operand (operands[0], QImode) || p_operand (operands[2], QImode)"
  "@@
   or	%X2,%X0
   bset	%V2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])

(define_expand "iorqi3"
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(ior:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,P")))]
  ""
  "
{
  if (fix_bit_operand (operands, 'P', IOR))
    DONE;
}")

(define_insn "iorhi3"
  [(set (match_operand:HI 0 "general_operand" "=r,r")
	(ior:HI (match_operand:HI 1 "general_operand" "%0,0")
		(match_operand:HI 2 "general_operand" "J,rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);

      if ((i & 0x00ff) != 0) 
	output_asm_insn (\"or	%s2,%s0\", operands);
      if ((i & 0xff00) != 0) 
	output_asm_insn (\"or	%t2,%t0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"or.w	%T2,%T0\";
  return \"or	%s2,%s0\;or	%t2,%t0; %2 or2\";
}"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ior:SI (match_operand:SI 1 "register_operand" "%0,0")
		(match_operand:SI 2 "nonmemory_operand" "J,rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);

      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, then we can
	 work on the low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && (i & 0xffff0000) != 0x00000000)
        return \"or.l	%S2,%S0\";
	
      if ((i & 0x000000ff) != 0) 
	output_asm_insn (\"or	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0) 
	output_asm_insn (\"or	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0) 
	output_asm_insn (\"or	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0) 
	output_asm_insn (\"or	%z2,%z0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"or.l	%S2,%S0\";
  return \"or	%w2,%w0\;or	%x2,%x0\;or	%y2,%y0\;or	%z2,%z0\;\";
}"
  [(set_attr "length" "2,8")
   (set_attr "cc" "clobber,clobber")])

;; ----------------------------------------------------------------------
;; XOR INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn ""
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(xor:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,P")))]
  "register_operand (operands[0], QImode) || p_operand (operands[2], QImode)"
  "@@
   xor	%X2,%X0
   bnot	%V2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])

(define_expand "xorqi3"
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(xor:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,O")))]
  ""
  "
{
  if (fix_bit_operand (operands, 'O', XOR))
    DONE;
}")

(define_insn "xorhi3"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "general_operand" "%0,0")
		(match_operand:HI 2 "nonmemory_operand" "J,rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);

      if ((i & 0x00ff) != 0) 
	output_asm_insn (\"xor	%s2,%s0\", operands);
      if ((i & 0xff00) != 0) 
	output_asm_insn (\"xor	%t2,%t0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"xor.w	%T2,%T0\";
  return \"xor	%s2,%s0\;xor	%t2,%t0\";
}"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(xor:SI (match_operand:SI 1 "register_operand" "%0,0")
		(match_operand:SI 2 "nonmemory_operand" "J,rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);

      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, then we can
	 work on the low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && (i & 0xffff0000) != 0x00000000)
        return \"xor.l	%S2,%S0\";

      if ((i & 0x000000ff) != 0) 
	output_asm_insn (\"xor	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0) 
	output_asm_insn (\"xor	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0) 
	output_asm_insn (\"xor	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0) 
	output_asm_insn (\"xor	%z2,%z0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"xor.l	%S2,%S0\";
  return \"xor	%w2,%w0\;xor	%x2,%x0\;xor	%y2,%y0\;xor	%z2,%z0\;\";
}"
  [(set_attr "length" "2,8")
   (set_attr "cc" "clobber,clobber")])

;; ----------------------------------------------------------------------
;; NEGATION INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "negqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(neg:QI (match_operand:QI 1 "general_operand" "0")))]
  ""
  "neg	%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_expand "neghi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(neg:HI (match_operand:HI 1 "general_operand" "0")))]
  ""
  "
{
  if (TARGET_H8300)
    {
      emit_insn (gen_neghi2_h8300 (operands[0], operands[1]));
      DONE;
    }
}")

(define_expand "neghi2_h8300"
  [(set (match_dup 2)
	(not:HI (match_operand:HI 1 "register_operand" "r")))
   (set (match_dup 2) (plus:HI (match_dup 2) (const_int 1)))
   (set (match_operand:HI 0 "register_operand" "=r")
	(match_dup 2))]
  ""
  "{ operands[2] = gen_reg_rtx (HImode); }")

(define_insn "neghi2_h8300h"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(neg:HI (match_operand:HI 1 "general_operand" "0")))]
  "TARGET_H8300H || TARGET_H8300S"
  "neg	%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_expand "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(neg:SI (match_operand:SI 1 "general_operand" "0")))]
  ""
  "
{
  if (TARGET_H8300)
    {
      emit_insn (gen_negsi2_h8300 (operands[0], operands[1]));
      DONE;
    }
}")

(define_expand "negsi2_h8300"
  [(set (match_dup 2)
	(not:SI (match_operand:SI 1 "register_operand" "r")))
   (set (match_dup 2) (plus:SI (match_dup 2) (const_int 1)))
   (set (match_operand:SI 0 "register_operand" "=r")
	(match_dup 2))]
  ""
  "{ operands[2] = gen_reg_rtx(SImode); }")

(define_insn "negsi2_h8300h"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(neg:SI (match_operand:SI 1 "general_operand" "0")))]
  "TARGET_H8300H || TARGET_H8300S"
  "neg	%S0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

;; ----------------------------------------------------------------------
;; NOT INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "register_operand" "=r")
	(not:QI (match_operand:QI 1 "general_operand" "0")))]
  ""
  "not	%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(not:HI (match_operand:HI 1 "general_operand" "0")))]
  ""
  "*
{
  if (TARGET_H8300)
    return \"not	%s0\;not	%t0\";
  else
    return \"not	%T0\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 4)
		      (const_int 2)))])

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(not:SI (match_operand:SI 1 "general_operand" "0")))]
  ""
  "*
{
  if (TARGET_H8300)
    return \"not	%w0\;not	%x0\;not	%y0\;not	%z0\";
  else
    return \"not	%S0\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 8)
		      (const_int 2)))])
			

;; ----------------------------------------------------------------------
;; JUMP INSTRUCTIONS
;; ----------------------------------------------------------------------

;; Conditional jump instructions

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "")

(define_insn "branch_true"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    {
      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
      return 0;
    }

  if (get_attr_length (insn) == 2) 
    return \"b%j1	%l0\";
  else if (get_attr_length (insn) == 4) 
    return \"b%j1	%l0:16\";
  else
    return \"b%k1	%L0\;jmp	@@%l0\;%L0:\";
}" 
 [(set_attr "type" "branch")
   (set_attr "cc" "none")])

(define_insn "branch_false"
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
{
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    {
      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
      return 0;
    }

  if (get_attr_length (insn) == 2) 
    return \"b%k1	%l0\";
  else if (get_attr_length (insn) == 4) 
    return \"b%k1	%l0:16\";
  else
    return \"b%j1	%L0\;jmp	@@%l0\;%L0:\";
}"
  [(set_attr "type" "branch")
   (set_attr "cc" "none")])

;; Unconditional and other jump instructions.

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"bra	%l0\";
  else if (get_attr_length (insn) == 4)
    return \"bra	%l0:16\";
  else
    return \"jmp	@@%l0\";
}"
  [(set_attr "type" "branch")
   (set_attr "cc" "none")])

;; This is a define expand, because pointers may be either 16 or 32 bits.

(define_expand "tablejump"
  [(parallel [(set (pc) (match_operand 0 "register_operand" "r"))
	      (use (label_ref (match_operand 1 "" "")))])]
  ""
  "")

(define_insn "tablejump_h8300"
  [(set (pc) (match_operand:HI 0 "register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  "TARGET_H8300"
  "jmp	@@%0"
  [(set_attr "cc" "none")
   (set_attr "length" "2")])

(define_insn "tablejump_h8300h"
  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
   (use (label_ref (match_operand 1 "" "")))]
  "TARGET_H8300H || TARGET_H8300S"
  "jmp	@@%0"
  [(set_attr "cc" "none")
   (set_attr "length" "2")])

;; This is a define expand, because pointers may be either 16 or 32 bits.

(define_expand "indirect_jump"
  [(set (pc) (match_operand 0 "jump_address_operand" ""))]
  ""
  "")

(define_insn "indirect_jump_h8300"
  [(set (pc) (match_operand:HI 0 "jump_address_operand" "Vr"))]
  "TARGET_H8300"
  "jmp	@@%0"
  [(set_attr "cc" "none")
   (set_attr "length" "2")])

(define_insn "indirect_jump_h8300h"
  [(set (pc) (match_operand:SI 0 "jump_address_operand" "Vr"))]
  "TARGET_H8300H || TARGET_H8300S"
  "jmp @@%0"
  [(set_attr "cc" "none")
   (set_attr "length" "2")])

;; Call subroutine with no return value.

;; ??? Even though we use HImode here, this works for the 300h.

(define_insn "call"
  [(call (match_operand:QI 0 "call_insn_operand" "or")
	 (match_operand:HI 1 "general_operand" "g"))]
  ""
  "*
{
  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF
      && SYMBOL_REF_FLAG (XEXP (operands[0], 0)))
    return \"jsr\\t\@@%0:8\";
  else
    return \"jsr\\t%0\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
     (if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
		   (const_int 4)
		   (const_int 8)))])

;; Call subroutine, returning value in operand 0
;; (which must be a hard register).

;; ??? Even though we use HImode here, this works on the 300h.

(define_insn "call_value"
  [(set (match_operand 0 "" "=r")
	(call (match_operand:QI 1 "call_insn_operand" "or")
	      (match_operand:HI 2 "general_operand" "g")))]
  ""
  "*
{
  if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
      && SYMBOL_REF_FLAG (XEXP (operands[1], 0)))
    return \"jsr\\t\@@%1:8\";
  else
    return \"jsr\\t%1\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
     (if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
		   (const_int 4)
		   (const_int 8)))])

(define_insn "nop"
  [(const_int 0)]
  ""
  "nop"
  [(set_attr "cc" "none")
   (set_attr "length" "2")])

;; ----------------------------------------------------------------------
;; EXTEND INSTRUCTIONS
;; ----------------------------------------------------------------------

(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  ""
  "@@
  mov.b	#0,%t0
  mov.b	%R1,%s0\;mov.b	#0,%t0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])

;; The compiler can synthesize a 300H variant of this which is
;; just as efficient as one that we'd create
(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  mov.b	#0,%x0\;sub.w %e0,%e0
  mov.b	%R1,%w0\;mov.b	#0,%x0\;sub.w %e0,%e0"
  [(set_attr "length" "4,6")
   (set_attr "cc" "clobber,clobber")])

(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "")))]
  ""
  "
{
  if (TARGET_H8300
      && GET_CODE (operands[1]) != CONST_INT
      && !optimize)
    {
      emit_insn (gen_zero_extendhisi2_h8300 (operands[0], operands[1]));
      DONE;
    }
}")

;; This is used when not optimizing.  It avoids severe code explosion
;; due to poor register allocation.
(define_expand "zero_extendhisi2_h8300"
  [(set (reg:HI 1) (match_operand:HI 1 "general_operand" ""))
   (set (reg:SI 0) (zero_extend:SI (reg:HI 1)))
   (set (match_operand:SI 0 "general_operand" "" ) (reg:SI 0))]
  "TARGET_H8300"
  "")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  sub.w	%e0,%e0
  mov.w %e1,%f0\;sub.w %e0,%e0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  extu.l	%S0
  mov.w	%T1,%T0\;extu.l	%S0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

(define_expand "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI (match_operand:QI 1 "general_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  bld	#7,%s0\;subx	%t0,%t0
  mov.b	%R1,%s0\;bld	#7,%s0\;subx	%t0,%t0"
  [(set_attr "length" "4,6")
   (set_attr "cc" "clobber,clobber")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  exts.w	%T0
  mov.b	%R1,%s0\;exts.w	%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

;; The compiler can synthesize a 300H variant of this which is
;; just as efficient as one that we'd create
(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0
  mov.b %R1,%w0\;bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
  [(set_attr "length" "8,10")
   (set_attr "cc" "clobber,clobber")])

(define_expand "extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "")))]
  ""
  "
{
  if (TARGET_H8300
      && GET_CODE (operands[1]) != CONST_INT
      && !optimize)
    {
      emit_insn (gen_extendhisi2_h8300 (operands[0], operands[1]));
      DONE;
    }
}")

;; This is used when not optimizing.  It avoids severe code explosion
;; due to poor register allocation.
(define_expand "extendhisi2_h8300"
  [(set (reg:HI 1) (match_operand:HI 1 "general_operand" ""))
   (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))
   (set (match_operand:SI 0 "general_operand" "" ) (reg:SI 0))]
  "TARGET_H8300"
  "")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0
  mov.w	%T1,%f0\;bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
  [(set_attr "length" "6,8")
   (set_attr "cc" "clobber,clobber")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  exts.l	%S0
  mov.w	%T1,%T0\;exts.l	%S0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

;; ----------------------------------------------------------------------
;; SHIFTS
;; ----------------------------------------------------------------------
;;
;; We make some attempt to provide real efficient shifting.  One example is
;; doing an 8 bit shift of a 16 bit value by moving a byte reg into the other
;; reg and moving 0 into the former reg.
;;
;; We also try to achieve this in a uniform way.  IE: We don't try to achieve
;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would
;; give the optimizer more cracks at the code.  However, we wish to do things
;; like optimizing shifting the sign bit to bit 0 by rotating the other way.
;; There is rtl to handle this (rotate + and), but the h8/300 doesn't handle
;; 16 bit rotates.  Also, if we emit complicated rtl, combine may not be able
;; to detect cases it can optimize.
;;
;; For these and other fuzzy reasons, I've decided to go the less pretty but
;; easier "do it at insn emit time" route.

;; QI BIT SHIFTS

(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "")
	(ashift:QI (match_operand:QI 1 "register_operand" "")
		   (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (QImode, ASHIFT, operands)) DONE;else FAIL;")

(define_expand "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "")
		     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (QImode, ASHIFTRT, operands)) DONE;else FAIL;")

(define_expand "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "")
		     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (QImode, LSHIFTRT, operands)) DONE;else FAIL;")

(define_insn ""
  [(set (match_operand:QI 0 "register_operand" "=r,r")
	(match_operator:QI 3 "nshift_operator" 
			[ (match_operand:QI 1 "register_operand" "0,0")
			  (match_operand:QI 2 "nonmemory_operand" "KM,rn")]))
   (clobber (match_scratch:QI 4 "=X,&r"))]
  ""
  "* return emit_a_shift (insn, operands);"
  [(set_attr "length" "20")
   (set_attr "cc" "clobber")])

;; HI BIT SHIFTS

(define_expand "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(ashift:HI (match_operand:HI 1 "nonmemory_operand" "")
		   (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (HImode, ASHIFT, operands)) DONE;else FAIL;")

(define_expand "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(lshiftrt:HI (match_operand:HI 1 "general_operand" "")
		     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (HImode, LSHIFTRT, operands)) DONE;else FAIL;")

(define_expand "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "")
		     (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (HImode, ASHIFTRT, operands)) DONE;else FAIL;")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(match_operator:HI 3 "nshift_operator" 
			[ (match_operand:HI 1 "register_operand" "0,0")
			  (match_operand:QI 2 "nonmemory_operand" "KM,rn")]))
   (clobber (match_scratch:QI 4 "=X,&r"))]
  ""
  "* return emit_a_shift (insn, operands);"
  [(set_attr "length" "20")
   (set_attr "cc" "clobber")])

;;  SI BIT SHIFTS

(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashift:SI
	 (match_operand:SI 1 "general_operand" "")
	 (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ASHIFT, operands)) DONE;else FAIL;")

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(lshiftrt:SI
	 (match_operand:SI 1 "general_operand" "")
	 (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;else FAIL;")

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashiftrt:SI
	 (match_operand:SI 1 "general_operand" "")
	 (match_operand:QI 2 "nonmemory_operand" "")))]
  ""
  "if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(match_operator:SI 3 "nshift_operator" 
			[ (match_operand:SI 1 "register_operand" "0,0")
			  (match_operand:QI 2 "nonmemory_operand" "K,rn")]))
   (clobber (match_scratch:QI 4 "=X,&r"))]
  ""
  "* return emit_a_shift (insn, operands);"
  [(set_attr "length" "20")
   (set_attr "cc" "clobber")])

;; -----------------------------------------------------------------
;; BIT FIELDS
;; -----------------------------------------------------------------
;; The H8/300 has given 1/8th of its opcode space to bitfield
;; instructions so let's use them as well as we can.

;; You'll never believe all these patterns perform one basic action --
;; load a bit from the source, optionally invert the bit, then store it
;; in the destination (which is known to be zero)..  
;;
;; Combine obviously need some work to better identify this situation and
;; canonicalize the form better.

;; 
;; Normal loads with a 16bit destination.
;; 
;; Yes, both cases are needed.
;;
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
			 (const_int 1)
			 (match_operand:HI 2 "immediate_operand" "n")))]
  ""
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(subreg:HI (zero_extract:SI
		     (match_operand:HI 1 "register_operand" "r")
		     (const_int 1)
		     (match_operand:HI 2 "immediate_operand" "n")) 1))]
  ""
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])

;; 
;; Inverted loads with a 16bit destination.
;; 
;; Yes, all four cases are needed.
;;

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(zero_extract:HI (xor:HI (match_operand:HI 1 "register_operand" "r")
				 (match_operand:HI 3 "p_operand" "P"))
			 (const_int 1)
			 (match_operand:HI 2 "const_int_operand" "n")))]
  "(1 << INTVAL (operands[2])) == INTVAL (operands[3])"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (lshiftrt:HI
		    (match_operand:HI 1 "bit_operand" "Ur")
		    (match_operand:HI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (subreg:HI 
		    (lshiftrt:SI
		      (match_operand:SI 1 "register_operand" "Ur")
		      (match_operand:SI 2 "const_int_operand" "n")) 1))
		(const_int 1)))]
  "INTVAL (operands[2]) < 16"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (subreg:HI 
		    (lshiftrt:SI
		      (match_operand:SI 1 "bit_operand" "Ur")
		      (match_operand:SI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "(TARGET_H8300H || TARGET_H8300S)
   && INTVAL (operands[2]) < 16"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

;; 
;; Normal loads with a 32bit destination.
;; 
;; Yes, all three cases are needed.
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(zero_extract:SI (match_operand:HI 1 "register_operand" "r")
			 (const_int 1)
			 (match_operand:HI 2 "const_int_operand" "n")))]
  ""
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (zero_extend:SI 
		   (lshiftrt:QI
		     (match_operand:QI 1 "bit_operand" "Ur")
		     (match_operand:QI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (zero_extend:SI 
		   (lshiftrt:HI
		      (match_operand:HI 1 "bit_operand" "Ur")
		      (match_operand:HI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

;; 
;; Inverted loads with a 32bit destination.
;; 
;; Yes, all seven cases are needed.
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI (match_operand:HI 1 "register_operand" "r")))
		(match_operand:SI 2 "p_operand" "P")))]
  ""
  "* return output_simode_bld (1, 1, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI
		    (lshiftrt:HI (match_operand:HI 1 "bit_operand" "Ur")
				 (match_operand:HI 2 "const_int_operand" "n"))))
		(const_int 1)))]
  ""
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI (match_operand:QI 1 "register_operand" "r")))
		(match_operand:SI 2 "p_operand" "P")))]
  ""
  "* return output_simode_bld (1, 1, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI
		    (lshiftrt:QI (match_operand:QI 1 "bit_operand" "Ur")
				 (match_operand:QI 2 "const_int_operand" "n"))))
		(const_int 1)))]
  ""
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (subreg:SI 
		     (lshiftrt:HI
			(match_operand:HI 1 "bit_operand" "Ur")
			(match_operand:HI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "1"
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (subreg:SI 
		     (lshiftrt:QI
			(match_operand:QI 1 "bit_operand" "Ur")
			(match_operand:QI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "1"
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(zero_extract:SI (xor:HI (match_operand:HI 1 "register_operand" "r")
				 (match_operand:HI 3 "p_operand" "P"))
			 (const_int 1)
			 (match_operand:HI 2 "const_int_operand" "n")))]
  "(1 << INTVAL (operands[2])) == INTVAL (operands[3])"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

(define_expand "insv"
  [(set (zero_extract:HI (match_operand:HI 0 "general_operand" "")
			 (match_operand:HI 1 "general_operand" "")
			 (match_operand:HI 2 "general_operand" ""))
	(match_operand:HI 3 "general_operand" ""))]
  "TARGET_H8300"
  "
{
  /* We only have single bit bitfield instructions.  */
  if (INTVAL (operands[1]) != 1)
    FAIL;

  /* For now, we don't allow memory operands.  */
  if (GET_CODE (operands[0]) == MEM
      || GET_CODE (operands[3]) == MEM)
    FAIL;
}")

(define_insn ""
  [(set (zero_extract:HI (match_operand:HI 0 "register_operand" "+r")
			 (const_int 1)
			 (match_operand:HI 1 "immediate_operand" "n"))
	(match_operand:HI 2 "register_operand" "r"))]
  ""
  "bld	#0,%R2\;bst	%Z1,%Y0 ; i1"
  [(set_attr "cc" "clobber")
   (set_attr "length" "4")])

(define_expand "extzv"
  [(set (match_operand:HI 0 "register_operand" "") 
	(zero_extract:HI (match_operand:HI 1 "bit_operand" "")
			 (match_operand:HI 2 "general_operand" "")
			 (match_operand:HI 3 "general_operand" "")))]
  "TARGET_H8300"
  "
{
  /* We only have single bit bitfield instructions.  */
  if (INTVAL (operands[2]) != 1)
    FAIL;

  /* For now, we don't allow memory operands.  */
  if (GET_CODE (operands[1]) == MEM)
    FAIL;
}")

;; BAND, BOR, and BXOR patterns

(define_insn ""
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 4 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "n"))
	    (match_operand:HI 3 "bit_operand" "0")]))]
  ""
  "bld	%Z2,%Y1\;%b4	#0,%R0\;bst	#0,%R0; bl1"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])

(define_insn ""
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 5 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "n"))
	    (zero_extract:HI (match_operand:HI 3 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 4 "immediate_operand" "n"))]))]
  ""
  "bld	%Z2,%Y1\;%b5	%Z4,%Y3\;bst	#0,%R0; bl3"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])


;; ----------------------------------------------
;; Peepholes go at the end.
;; ----------------------------------------------

;; Notice when two byte moves in a row could be a word move.

(define_peephole
  [(set (match_operand:QI 0 "register_operand" "=r")
	(mem:QI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "n"))))
   (set (match_operand:QI 3 "register_operand" "=r")
	(mem:QI (plus:HI (match_dup 1)
			 (match_operand:HI 4 "immediate_operand" "n"))))]
  "(INTVAL(operands[2]) == INTVAL(operands[4])+1) && REGNO(operands[0]) +1 == REGNO(operands[3])"
  "mov.w	@@(%u4,%T1),%T0"
  [(set_attr "length" "6")
   (set_attr "cc" "set_znv")])

(define_peephole
  [(set (mem:QI (plus:HI (match_operand:HI 1 "register_operand" "r")
			 (match_operand:HI 2 "immediate_operand" "n")))
	(match_operand:QI 0 "register_operand" "r"))
   (set (mem:QI (plus:HI (match_dup 1)
			 (match_operand:HI 4 "immediate_operand" "n")))
	(match_operand:QI 3 "register_operand" "r"))]
  "(INTVAL(operands[2]) == INTVAL(operands[4])+1) && REGNO(operands[0]) +1 == REGNO(operands[3])"
  "mov.w	%T0,@@(%u4,%T1)"
  [(set_attr "length" "6")
   (set_attr "cc" "set_znv")])

;; Notice a move which could be post incremented.

(define_peephole 
  [(set (match_operand:QI 0 "register_operand" "")
	(mem:QI (match_operand:HI 1 "register_operand" "")))
   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]
  "REGNO(operands[1]) != REGNO(operands[0])"
  "mov.b	@@%T1+,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_peephole 
  [(set (match_operand:HI 0 "register_operand" "")
	(mem:HI (match_operand:HI 1 "register_operand" "")))
   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]
  "REGNO(operands[1]) != REGNO(operands[0])"
  "mov.w	@@%T1+,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

;; Notice a move which could be predecremented.

(define_peephole 
  [(set (match_operand:HI 1 "register_operand" "")
	(plus:HI (match_dup 1) (const_int -1)))
   (set (mem:QI (match_dup 1))
		(match_operand:QI 0 "register_operand" ""))]
  "REGNO(operands[1]) != REGNO(operands[0])"
  "mov.b	%X0,@@-%T1"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

(define_peephole 
  [(set (match_operand:HI 1 "register_operand" "")
	(plus:HI (match_dup 1) (const_int -1)))
   (set (mem:HI (match_dup 1))
		(match_operand:HI 0 "register_operand" ""))]
  "REGNO(operands[1]) != REGNO(operands[0])"
  "mov.w	%T0,@@-%T1"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])

@


1.2
log
@GCC 2.8.0 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
;; Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
a23 1

d32 30
a61 2
;; ??? If we can remove the operand type on all the insns, do it.
;; ??? Otherwise, try to have the operand type on all the insns.
d63 1
a63 1
(define_attr "type" "branch,return,call,arith,move,float,multi"
d81 1
a81 5
				     (const_int 6)))
	 (eq_attr "type" "move")	(const_int 4)
	 (eq_attr "type" "return")	(const_int 2)
	 (eq_attr "type" "float")	(const_int 12)
	 (eq_attr "type" "call")	(const_int 4)]
d84 12
a95 3
(define_attr "cc" "none,clobber,none_0hit,set,compare,whoops,cbit" 
  (const_string "whoops"))

d113 8
a120 8
  [(set_attr "type" "move")
   (set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set")])

(define_insn "movqi_internal"
  [(set (match_operand:QI 0 "general_operand_dst" "=r,r,r,o,<,r")
	(match_operand:QI 1 "general_operand_src" "I,r>,io,r,r,c"))]
  "register_operand (operands[0],QImode) || register_operand (operands[1], QImode)"
d123 7
a129 8
   mov.b	%X1,%X0
   mov.b	%X1,%X0
   mov.b	%X1,%X0
   mov.b	%X1,%X0
   xor		%X0,%X0\;bst	#0,%X0"
  [(set_attr "type" "move")
   (set_attr_alternative "length"
     [(const_int 2) (const_int 2)
d131 2
a132 4
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4))
      (const_int 4)])
   (set_attr "cc" "set,set,set,set,set,none")])
d149 2
a150 2
  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "=r,r,r,o,<"))
			 (match_operand:QI 1 "general_operand_src" "I,r,io,r,r"))]
d155 6
a160 10
   mov.b	%X1,%X0
   mov.b	%X1,%X0
   mov.b	%X1,%X0"
  [(set_attr "type" "move")
   (set_attr_alternative "length"
     [(const_int 2) (const_int 2)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4))])
   (set_attr "cc" "set")])
d164 2
d168 1
a168 1
	(match_operand:HI 1 "register_operand" "ra"))]
d177 8
a184 8
  [(set_attr "type" "move")
   (set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set")])

(define_insn "movhi_internal"
  [(set (match_operand:HI 0 "general_operand_dst" "=ra,ra,ra,o,<")
	(match_operand:HI 1 "general_operand_src" "I,ra>,ion,ra,ra"))]
  ""
d190 1
d192 2
a193 3
  [(set_attr "type" "move")
   (set_attr_alternative "length"
     [(const_int 2) (const_int 2)
d195 2
a196 3
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4))])
   (set_attr "cc" "set")])
d213 2
a214 2
  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "=r,r,r,o,<"))
			 (match_operand:HI 1 "general_operand_src" "I,r,io,r,r"))]
a219 1
   mov.w	%T1,%T0
d221 4
a224 7
  [(set_attr "type" "move")
   (set_attr_alternative "length"
     [(const_int 2) (const_int 2)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))
      (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4))])
   (set_attr "cc" "set")])
d239 1
a239 1
  else /* TARGET_H8300H */
d261 1
a261 1
  else /* TARGET_H8300H */
d274 1
a274 1
	(match_operand:SI 1 "general_operand_src" "I,r,ion,r,r,>"))]
d315 10
a324 1
	  return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
a325 1
    
d327 1
a327 1
      return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
d334 1
a334 2
  [(set_attr "type" "move")
   (set_attr "length" "4,4,8,8,4,4")
d339 1
a339 1
	(match_operand:SF 1 "general_operand_src" "I,r,ion,r,r,>"))]
d393 1
a393 2
  [(set_attr "type" "move")
   (set_attr "length" "4,4,8,8,4,4")
d396 4
a399 4
(define_insn "movsi_h8300h"
  [(set (match_operand:SI 0 "general_operand_dst" "=ra,ra,ra,o,<,ra")
	(match_operand:SI 1 "general_operand_src" "I,ra,ion,ra,ra,>"))]
  "TARGET_H8300H
d402 40
a441 10
  "@@
   sub.l	%S0,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0
   mov.l	%S1,%S0"
  [(set_attr "type" "move")
   (set_attr "length" "2,2,8,8,4,4")
   (set_attr "cc" "set")])
d444 3
a446 3
  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,o,<,r")
	(match_operand:SF 1 "general_operand_src" "I,r,ion,r,r,>"))]
  "TARGET_H8300H
d456 3
a458 4
  [(set_attr "type" "move")
   (set_attr "length" "2,2,8,8,4,4")
   (set_attr "cc" "set")])

d463 54
d518 1
a518 1
  [(set (cc0) (match_operand:QI 0 "register_operand" "ra"))]
d520 3
a522 11
  "*
{
  /* ??? I don't think this is right.  --Jim */
  if (cc_prev_status.flags & CC_DONE_CBIT)
    return \"btst	#0,%X0\";
  else
    return \"cmp.b	#0,%X0\";
}"
  [(set_attr "type" "arith")
   (set_attr "length" "4")
   (set_attr "cc" "set")])
d525 1
a525 1
  [(set (cc0) (match_operand:HI 0 "general_operand" "ra"))]
d527 3
a529 11
  "*
{
  /* ??? I don't think this is right.  --Jim */
  if (cc_prev_status.flags & CC_DONE_CBIT)
    return \"btst	#0,%0l\";
  else
    return \"mov.w	%T0,%T0\";
}"
  [(set_attr "type" "arith")
   (set_attr "length" "4")
   (set_attr "cc" "set")])
d532 5
a536 13
  [(set (cc0) (match_operand:SI 0 "general_operand" "ra"))]
  "TARGET_H8300H"
  "*
{
  /* ??? I don't think this is right.  --Jim */
  if (cc_prev_status.flags & CC_DONE_CBIT)
    return \"btst	#0,%0l\";
  else
    return \"mov.l	%S0,%S0\";
}"
  [(set_attr "type" "arith")
   (set_attr "length" "4")
   (set_attr "cc" "set")])
d540 2
a541 2
	(compare:QI (match_operand:QI 0 "register_operand" "ra")
		    (match_operand:QI 1 "nonmemory_operand" "rai")))]
d544 1
a544 2
  [(set_attr "type" "arith")
   (set_attr "length" "2")
d547 12
a558 1
;; ??? 300h can have an immediate operand here.
d560 1
a560 1
(define_insn "cmphi"
d562 3
a564 3
	(compare:HI (match_operand:HI 0 "register_operand" "ra")
		    (match_operand:HI 1 "register_operand" "ra")))]
  ""
d566 1
a566 2
  [(set_attr "type" "arith")
   (set_attr "length" "2")
d569 8
a576 1
;; ??? 300h can have an immediate operand here.
d580 3
a582 3
	(compare:SI (match_operand:SI 0 "register_operand" "ra")
		    (match_operand:SI 1 "register_operand" "ra")))]
  "TARGET_H8300H"
d584 3
a586 4
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "compare")])

d594 1
a594 1
		 (match_operand:QI 2 "nonmemory_operand" "ri")))]
d597 2
a598 23
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "set")])

;; ??? adds operates on the 32bit register.  We can use it because we don't
;; use the e0-7 registers.
;; ??? 4 can be handled in one insn on the 300h.

(define_insn "addhi3_internal"
  [(set (match_operand:HI 0 "register_operand" "=ra,ra,ra,ra,r,ra")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,0,0")
		 (match_operand:HI 2 "nonmemory_operand" "K,M,L,N,n,ra")))]
  ""
  "@@
   adds	%T2,%A0
   adds	#2,%A0\;adds	%C2,%A0
   subs	%M2,%A0
   subs	#2,%A0\;subs	%M2,%A0
   add.b	%s2,%s0\;addx	%t2,%t0 
   add.w	%T2,%T0"
  [(set_attr "type" "arith,multi,arith,multi,multi,arith")
   (set_attr "length" "2,4,2,4,4,2")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,clobber,set")])
a599 1
;; ??? Why is this here?
d607 38
d652 15
d675 2
a676 3
   mov	%f1,%f0\;mov	%e1,%e0\;add.w	%f2,%f0\;addx	%y2,%y0\;addx	%z2,%z0"
  [(set_attr "type" "arith")
   (set_attr "length" "8,6,20")
a678 4
;; ??? 4 can be handled in one insn on the 300h.
;; ??? Should the 'n' constraint be 'i' here?
;; ??? We don't handle (reg + symbol_ref) which the 300h can handle.

d680 5
a684 9
  [(set (match_operand:SI 0 "register_operand" "=ra,ra,ra,ra,r,ra")
	(plus:SI (match_operand:SI 1 "register_operand" "%0,0,0,0,0,0")
		 (match_operand:SI 2 "nonmemory_operand" "K,M,L,N,n,ra")))]
  "TARGET_H8300H"
  "@@
   adds	%S2,%S0
   adds	#2,%S0\;adds	%C2,%S0
   subs	%M2,%S0
   subs	#2,%S0\;subs	%M2,%S0
d687 2
a688 3
  [(set_attr "type" "multi,multi,multi,multi,arith,arith")
   (set_attr "length" "2,4,2,4,6,2")
   (set_attr "cc" "none_0hit,none_0hit,none_0hit,none_0hit,clobber,clobber")])
d697 1
a697 1
		  (match_operand:QI 2 "nonmemory_operand" "r,i")))]
d702 2
a703 23
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "set")])

;; ??? subs operates on the 32bit register.  We can use it because we don't
;; use the e0-7 registers.
;; ??? 4 can be handled in one insn on the 300h.
;; ??? The fourth alternative can use sub.w on the 300h.
;; ??? Should the 'n' constraint be an 'i' here?

(define_insn "subhi3_internal"
  [(set (match_operand:HI 0 "register_operand" "=ra,ra,ra,r")
	(minus:HI (match_operand:HI 1 "general_operand" "0,0,0,0")
		  (match_operand:HI 2 "nonmemory_operand" "K,M,ra,n")))]
  ""
  "@@
   subs	%T2,%T0
   subs	#2,%T0\;subs	%M2,%T0
   sub.w	%T2,%T0
   add.b	%E2,%s0\;addx	%F2,%t0 ; -%0"
  [(set_attr "type" "multi")
   (set_attr "length" "2,4,2,4")
   (set_attr "cc" "none_0hit,none_0hit,set,clobber")])
a704 1
;; ??? Why is this here?
d707 1
a707 1
	(minus:HI (match_operand:HI 1 "register_operand" "")
d712 42
d767 1
a767 2
  [(set_attr "type" "arith")
   (set_attr "length" "6")
d770 19
a788 1
;; ??? 4 can be handled in one insn on the 300h.
d791 4
a794 4
  [(set (match_operand:SI 0 "register_operand" "=ra,ra,ra,r")
	(minus:SI (match_operand:SI 1 "general_operand" "0,0,0,0")
		  (match_operand:SI 2 "nonmemory_operand" "K,M,ra,n")))]
  "TARGET_H8300H"
a795 2
   subs	%T2,%T0
   subs	#2,%T0\;subs	%E2,%T0
d798 3
a800 4
  [(set_attr "type" "multi")
   (set_attr "length" "2,4,2,6")
   (set_attr "cc" "none_0hit,none_0hit,set,set")])

d811 1
a811 1
  "TARGET_H8300H"
d813 2
a814 3
  [(set_attr "type" "multi")
   (set_attr "length" "4")
   (set_attr "cc" "set")])
d820 1
a820 1
  "TARGET_H8300H"
d822 2
a823 3
  [(set_attr "type" "multi")
   (set_attr "length" "4")
   (set_attr "cc" "set")])
d831 1
a831 2
  [(set_attr "type" "multi")
   (set_attr "length" "2")
d838 1
a838 1
  "TARGET_H8300H"
d840 33
a872 2
  [(set_attr "type" "multi")
   (set_attr "length" "2")
d881 4
a884 2
	(udiv:QI (match_operand:HI 1 "general_operand" "0")
		 (match_operand:QI 2 "register_operand" "r")))]
d887 1
a887 2
  [(set_attr "type" "multi")
   (set_attr "length" "2")
d894 4
a897 2
	(div:QI (match_operand:HI 1 "general_operand" "0")
		(match_operand:QI 2 "register_operand" "r")))]
d900 1
a900 2
  [(set_attr "type" "multi")
   (set_attr "length" "2")
d905 5
a909 3
	(udiv:HI (match_operand:SI 1 "general_operand" "0")
		 (match_operand:HI 2 "register_operand" "r")))]
  "TARGET_H8300H"
d911 1
a911 2
  [(set_attr "type" "multi")
   (set_attr "length" "2")
d916 5
a920 3
	(div:HI (match_operand:SI 1 "general_operand" "0")
		(match_operand:HI 2 "register_operand" "r")))]
  "TARGET_H8300H"
d922 1
a922 2
  [(set_attr "type" "multi")
   (set_attr "length" "4")
d931 4
a934 2
	(umod:QI (match_operand:HI 1 "general_operand" "0")
		 (match_operand:QI 2 "register_operand" "r")))]
d937 1
a937 2
  [(set_attr "type" "multi")
   (set_attr "length" "4")
d942 5
a946 3
	(mod:QI (match_operand:HI 1 "general_operand" "0")
		(match_operand:QI 2 "register_operand" "r")))]
  "TARGET_H8300H"
d948 1
a948 2
  [(set_attr "type" "multi")
   (set_attr "length" "6")
d953 5
a957 3
	(umod:HI (match_operand:SI 1 "general_operand" "0")
		 (match_operand:HI 2 "register_operand" "r")))]
  "TARGET_H8300H"
d959 1
a959 2
  [(set_attr "type" "multi")
   (set_attr "length" "4")
d964 5
a968 3
	(mod:HI (match_operand:SI 1 "general_operand" "0")
		(match_operand:HI 2 "register_operand" "r")))]
  "TARGET_H8300H"
d970 1
a970 2
  [(set_attr "type" "multi")
   (set_attr "length" "6")
d972 1
a972 1

d977 1
a977 1
(define_insn "andqi3_internal"
d984 3
a986 4
   bclr	%W2,%X0"
  [(set_attr "type" "arith")
   (set_attr "length" "2,4")
   (set_attr "cc" "set,none_0hit")])
d989 3
a991 3
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
	(and:QI (match_operand:QI 1 "bit_operand" "%0,0")
		(match_operand:QI 2 "nonmemory_operand" "rn,O")))]
a998 2
;; ??? Should have a bclr case here also.

d1009 1
d1016 2
d1020 1
a1020 2
  [(set_attr "type" "multi")
   (set_attr "length" "4")
d1023 28
a1050 1
;; ??? There is an iorsi3 for TARGET_H8300.  Should we have andsi3?
d1052 22
a1073 10
(define_insn "andsi3"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(and:SI (match_operand:SI 1 "register_operand" "%0,0")
		(match_operand:SI 2 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H"
  "@@
   and	%S2,%S0
   and	%S2,%S0"
  [(set_attr "type" "arith")
   (set_attr "length" "4,6")
d1076 1
d1081 2
a1082 2
(define_insn "iorqi3_internal"
  [(set (match_operand:QI 0 "bit_operand" "=U,r")
d1084 1
a1084 1
		(match_operand:QI 2 "nonmemory_operand" "P,rn")))]
d1087 4
a1090 5
   bset	%V2,%X0
   or	%X2,%X0"
  [(set_attr "type" "arith")
   (set_attr "length" "4,2")
   (set_attr "cc" "none_0hit,set")])
a1102 2
;; ??? Should have a bset case here also.

d1110 1
a1110 1
  if (TARGET_H8300)
d1112 7
a1118 14
      if (GET_CODE (operands[2]) == CONST_INT)
	{
	  int i = INTVAL (operands[2]);
	  if ((i & 0x00ff) != 0) 
	    output_asm_insn (\"or	%s2,%s0\", operands);
	  if ((i & 0xff00) != 0) 
	    output_asm_insn (\"or	%t2,%t0\", operands);
	  return \"\";
	}
      return \"or	%s2,%s0\;or	%t2,%t0; %2 or2\";
    }
  else
    {
      return \"or	%S2,%S0\";
d1120 3
d1124 1
a1124 2
  [(set_attr "type" "multi")
   (set_attr "length" "2,4")
d1128 3
a1130 3
  [(set (match_operand:SI 0 "register_operand" "=r")
	(ior:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "nonmemory_operand" "ri")))]
d1134 1
a1134 1
  if (TARGET_H8300)
d1136 19
a1154 18
      if (GET_CODE (operands[2]) == CONST_INT)
	{
	  int i = INTVAL (operands[2]);
	  if ((i & 0x000000ff) != 0) 
	    output_asm_insn (\"or	%w2,%w0\", operands);
	  if ((i & 0x0000ff00) != 0) 
	    output_asm_insn (\"or	%x2,%x0\", operands);
	  if ((i & 0x00ff0000) != 0) 
	    output_asm_insn (\"or	%y2,%y0\", operands);
	  if ((i & 0xff000000) != 0) 
	    output_asm_insn (\"or	%z2,%z0\", operands);
	  return \"\";
	}
      return \"or	%w2,%w0\;or	%x2,%x0\;or	%y2,%y0\;or	%z2,%z0\;\";
    }
  else
    {
      return \"or	%S2,%S0\";
d1156 3
d1160 2
a1161 3
  [(set_attr "type" "multi")
   (set_attr "length" "8")
   (set_attr "cc" "clobber")])
d1167 1
a1167 1
(define_insn "xorqi3_internal"
d1174 3
a1176 4
   bnot	%V2,%X0"
  [(set_attr "type" "arith")
   (set_attr "length" "2,4")
   (set_attr "cc" "set,none_0hit")])
d1190 3
a1192 3
  [(set (match_operand:HI 0 "register_operand" "=r")
	(xor:HI (match_operand:HI 1 "general_operand" "%0")
		(match_operand:HI 2 "nonmemory_operand" "rn")))]
d1196 13
a1208 4
  if (TARGET_H8300)
    return \"xor	%s2,%s0\;xor	%t2,%t0\";
  else
    return \"xor	%S2,%S0\";
d1210 2
a1211 5
  [(set_attr "type" "multi")
   (set_attr "length" "4")
   (set_attr "cc" "clobber")])

;; ??? There is an iorsi3 for TARGET_H8300.  Should we have xorsi3?
d1216 7
a1222 8
		(match_operand:SI 2 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H"
  "@@
   xor	%S2,%S0
   xor	%S2,%S0"
  [(set_attr "type" "arith")
   (set_attr "length" "4,6")
   (set_attr "cc" "clobber")])
d1224 25
d1258 2
a1259 3
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "clobber")])
d1286 1
a1286 1
  "TARGET_H8300H"
d1288 2
a1289 3
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "clobber")])
d1316 1
a1316 1
  "TARGET_H8300H"
d1318 2
a1319 3
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "clobber")])
d1330 2
a1331 3
  [(set_attr "type" "arith")
   (set_attr "length" "2")
   (set_attr "cc" "set")])
d1344 6
a1349 3
  [(set_attr "type" "arith")
   (set_attr "length" "4")
   (set_attr "cc" "clobber")])
d1362 8
a1369 5
  [(set_attr "type" "arith")
;; ??? length is wrong for 300h
   (set_attr "length" "8")
   (set_attr "cc" "clobber")])

d1475 10
a1501 1
;; ??? We don't take advantage of 16 bit relative jumps in the 300h.
d1504 10
d1555 1
a1555 2
  [(set_attr "type" "branch")
   (set_attr "cc" "none")
d1561 1
a1561 1
  "TARGET_H8300H"
d1563 1
a1563 2
  [(set_attr "type" "branch")
   (set_attr "cc" "none")
a1567 8
;(define_insn "indirect_jump"
;  [(set (pc) (match_operand:HI 0 "register_operand" "r"))]
;  ""
;  "jmp	@@%0"
;  [(set_attr "type" "branch")
;   (set_attr "cc" "none")
;   (set_attr "length" "2")])

d1569 1
a1569 1
  [(set (pc) (match_operand 0 "jump_address_operand" "Vr"))]
d1574 1
a1574 1
  [(set (pc) (match_operand:HI 0 "jump_address_operand" "V,r"))]
d1576 2
a1577 5
  "@@
   jmp	@@%0
   jmp	@@%0"
  [(set_attr "type" "branch")
   (set_attr "cc" "none")
d1581 4
a1584 7
  [(set (pc) (match_operand:SI 0 "jump_address_operand" "V,r"))]
  "TARGET_H8300H"
  "@@
   jmp @@%0
   jmp @@%0"
  [(set_attr "type" "branch")
   (set_attr "cc" "none")
d1595 13
a1607 4
  "jsr	%0"
  [(set_attr "type" "call")
   (set_attr "cc" "clobber")
   (set_attr "length" "4")])
d1619 13
a1631 4
  "jsr	%1"
  [(set_attr "type" "call")
   (set_attr "cc" "clobber")
   (set_attr "length" "4")])
d1637 1
a1637 2
  [(set_attr "type" "multi")
   (set_attr "cc" "none")
d1639 1
a1639 1

d1646 23
a1668 1
	(zero_extend:HI (match_operand:QI 1 "general_operand" "0,g")))]
d1670 1
a1670 1
  "*
d1672 3
a1674 6
  if (which_alternative==0)
    return \"mov.b	#0,%t0\";

  if (TARGET_H8300)
    return \"mov.b	%X1,%s0\;mov.b	#0,%t0\";
  else
d1676 2
a1677 5
      /* ??? See how often this gets optimized.  */
      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))
	return \"extu.w	%T0\";
      else
	return \"mov.b	%X1,%s0\;extu.w	%T0\";
d1679 20
a1698 5
}"
  [(set_attr "type" "multi")
;; ??? This length is wrong for one case.
   (set_attr "length" "4")
   (set_attr "cc" "clobber")])
d1700 9
a1708 16
(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "g")))]
  "TARGET_H8300H"
  "*
{
  /* ??? See how often this gets optimized.  */
  if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))
    return \"extu.l	%S0\";
  else
    return \"mov.w	%T1,%T0\;extu.l	%S0\";
}"
  [(set_attr "type" "multi")
;; ??? This length is wrong for one case.
   (set_attr "length" "4")
   (set_attr "cc" "clobber")])
d1710 3
a1712 3
(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "general_operand" "g")))]
d1714 33
a1746 23
  "*
{
  if (TARGET_H8300)
    {
      /* ??? See how often this gets optimized.  */
      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))
	return \"bld	#7,%s0\;subx	%t0,%t0\";
      else
	return \"mov.b	%X1,%s0\;bld	#7,%s0\;subx	%t0,%t0\";
    }
  else
    {
      /* ??? See how often this gets optimized.  */
      if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))
	return \"exts.w	%T0\";
      else
	return \"mov.b	%X1,%s0\;exts.w	%T0\";
    }
}"
  [(set_attr "type" "multi")
;; ??? Length is wrong in some cases.
   (set_attr "length" "6")
   (set_attr "cc" "clobber")])
d1754 7
a1760 5
  if (TARGET_H8300)
    emit_insn (gen_extendhisi2_h8300 (operands[0], operands[1]));
  else
    emit_insn (gen_extendhisi2_h8300h (operands[0], operands[1]));
  DONE;
d1763 2
d1772 3
a1774 9
(define_expand "extendhisi2_h8300h"
  [(set (match_operand:SI 0 "register_operand" "")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "")))]
  "TARGET_H8300H"
  "")

(define_insn "extendhisi2_h8300_internal"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:HI 1 "register_operand" "0")))]
d1776 5
a1780 18
  "mov.w	%T1,%f0\;bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
  [(set_attr "length" "10")
   (set_attr "cc" "clobber")])

(define_insn "extendhisi2_h8300h_internal"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:HI 1 "general_operand" "g")))]
  "TARGET_H8300H"
  "*
{
  /* ??? See how often this gets optimized.  */
  if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))
    return \"exts.l	%S0\";
  else
    return \"mov.w	%T1,%T0\;exts.l	%S0\";
}"
  [(set_attr "length" "10")
   (set_attr "cc" "clobber")])
d1782 10
d1834 1
a1834 4
;; WARNING: The constraints on the scratch register say one is not needed
;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.

(define_insn "shiftbyn_QI"
d1838 1
a1838 1
			  (match_operand:QI 2 "nonmemory_operand" "IKM,rn")]))
d1842 1
a1842 5
  [(set_attr "type" "arith")
   (set_attr "length" "20")
;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.
;; However, for cases that loop or are done in pieces, cc does not contain
;; what we want.  Emit_a_shift is free to tweak cc_status as desired.
d1856 1
a1856 1
	(lshiftrt:HI (match_operand:HI 1 "general_operand_src" "")
d1868 1
a1868 4
;; WARNING: The constraints on the scratch register say one is not needed
;; for constant shifts of 1,2,3,4.  Emit_a_shift() must know this.

(define_insn "shiftbyn_HI"
d1872 1
a1872 1
			  (match_operand:QI 2 "nonmemory_operand" "IKM,rn")]))
d1876 1
a1876 5
  [(set_attr "type" "arith")
   (set_attr "length" "20")
;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.
;; However, for cases that loop or are done in pieces, cc does not contain
;; what we want.  Emit_a_shift is free to tweak cc_status as desired.
d1884 1
a1884 1
	 (match_operand:SI 1 "general_operand_src" "")
d1892 1
a1892 1
	 (match_operand:SI 1 "general_operand_src" "")
d1900 1
a1900 1
	 (match_operand:SI 1 "general_operand_src" "")
d1905 1
a1905 4
;; WARNING: The constraints on the scratch register say one is not needed
;; for constant shifts of 1,2.  Emit_a_shift() must know this.

(define_insn "shiftbyn_SI"
d1909 1
a1909 1
			  (match_operand:QI 2 "nonmemory_operand" "IK,rn")]))
d1913 1
a1913 5
  [(set_attr "type" "arith")
   (set_attr "length" "20")
;; ??? We'd like to indicate that cc is set here, and it is for simple shifts.
;; However, for cases that loop or are done in pieces, cc does not contain
;; what we want.  Emit_a_shift is free to tweak cc_status as desired.
d1915 1
a1915 1

d1920 1
a1920 1
;; instructions so let's use them as well as we can
d1922 6
a1927 1
;; BCC and BCS patterns.
d1929 10
a1938 10
(define_insn "bcs_qiqi"
  [(set (pc)
	(if_then_else 
	 (match_operator 1 "eq_operator"
			 [(zero_extract:QI (match_operand:QI 2 "bit_operand" "Ur")
					   (const_int 1)
					   (match_operand:HI 3 "immediate_operand" "i"))
			  (const_int 0)])
	 (label_ref (match_operand 0 "" ""))
	 (pc)))]
d1940 3
a1942 12
  "*
{
  output_asm_insn(\"bld	%Z3,%Y2\", operands);
  if (get_attr_length (insn) == 2) 
    return \"b%d1	%l0\";
  else if (get_attr_length (insn) == 4) 
    return \"b%d1	%l0:16\";
  else
    return \"b%g1	%L0\;jmp	@@%l0\;%L0:\";
}" 
  [(set_attr "type" "branch")
   (set_attr "cc" "clobber")])
d1944 16
a1959 23
(define_insn "bcs_hihi"
  [(set (pc)
	(if_then_else 
	 (match_operator 1 "eq_operator"
			 [(zero_extract:HI (match_operand:HI 2 "bit_operand" "Ur")
					   (const_int 1)
					   (match_operand:HI 3 "immediate_operand" "i"))
			  (const_int 0)])
	 (label_ref (match_operand 0 "" ""))
	 (pc)))]
  ""
  "*
{
  output_asm_insn(\"bld	%Z3,%Y2\", operands);
  if (get_attr_length (insn) == 2) 
    return \"%d1	%l0\";
  else if (get_attr_length (insn) == 4) 
    return \"%d1	%l0:16\";
  else
    return \"%g1	%L0\;jmp	@@%l0\;%L0:\";
}" 
  [(set_attr "type" "branch")
   (set_attr "cc" "clobber")])
d1961 10
a1970 23
(define_insn "bcs_hiqi"
  [(set (pc)
	(if_then_else 
	 (match_operator 1 "eq_operator"
			 [(zero_extract:HI (match_operand:QI 2 "bit_operand" "Ur")
					   (const_int 1)
					   (match_operand:HI 3 "immediate_operand" "i"))
			  (const_int 0)])
	 (label_ref (match_operand 0 "" ""))
	 (pc)))]
  ""
  "*
{
  output_asm_insn(\"bld	%Z3,%Y2\", operands);
  if (get_attr_length (insn) == 2) 
    return \"%d1	%l0\";
  else if (get_attr_length (insn) == 4) 
    return \"%d1	%l0:16\";
  else
    return \"%g1	%L0\;jmp	@@%l0\;%L0:\";
}" 
  [(set_attr "type" "branch")
   (set_attr "cc" "clobber")])
d1972 11
a1982 1
;; BLD and BST patterns
d1984 1
a1984 1
(define_insn "extract_1"
d1986 10
a1995 5
	(zero_extract:HI (match_operand:QI 1 "bit_operand" "Ur")
			 (const_int 1)
			 (match_operand:HI 2 "immediate_operand" "i")))]
  ""
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0")
d1997 1
a1997 1
(define_insn "extract_1_hi"
d1999 20
a2018 1
	(zero_extract:HI (match_operand:HI 1 "bit_operand" "Ur")
d2020 1
a2020 1
			 (match_operand:HI 2 "immediate_operand" "i")))]
d2022 7
a2028 1
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0")
d2030 15
a2044 9
(define_insn "insert_1"
  [(set (zero_extract:HI (match_operand:QI 0 "bit_operand" "+Ur")
			 (const_int 1)
			 (match_operand:HI 1 "immediate_operand" "i"))
	(zero_extract:HI (match_operand:QI 2 "bit_operand" "Ur")
			 (const_int 1)
			 (const_int 0)))]
  ""
  "bld	#0,%X2\;bst	%Z1,%Y0 ; i1")
d2046 15
a2060 10
;; This is how combine canonicalizes this pattern.  This is perhaps a bug
;; in combine.c, but there is no problem with writing it this way so we do.
(define_insn "extract_insert_1"
  [(set (zero_extract:QI (match_operand:QI 0 "bit_operand" "+Ur")
			 (const_int 1)
			 (match_operand:HI 1 "immediate_operand" "i"))
	(lshiftrt:QI (match_operand:QI 2 "bit_operand" "Ur")
		     (match_operand:HI 3 "immediate_operand" "i")))]
 ""
 "bld	%Z3,%Y2\;bst	%Z1,%Y0; ei1")
d2062 33
a2094 1
;; BAND, BOR, and BXOR patterns
d2096 28
a2123 9
(define_insn "bitlogical_1"
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 4 "bit_operator"
	   [(zero_extract:HI (match_operand:QI 1 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "i"))
	    (match_operand:HI 3 "bit_operand" "0")]))]
  ""
  "bld	%Z2,%Y1\;%b4	#0,%X0\;bst	#0,%X0; bl1")
d2125 16
a2140 9
(define_insn "bitlogical_1_hi"
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 4 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "i"))
	    (match_operand:HI 3 "bit_operand" "0")]))]
  ""
  "bld	%Z2,%Y1\;%b4	#0,%X0\;bst	#0,%X0; bl2")
d2142 16
a2157 11
(define_insn "bitlogical_2"
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 5 "bit_operator"
	   [(zero_extract:HI (match_operand:QI 1 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "i"))
	    (zero_extract:HI (match_operand:QI 3 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 4 "immediate_operand" "i"))]))]
  ""
  "bld	%Z2,%Y1\;%b5	%Z4,%Y3\;bst	#0,%X0; bl3")
d2159 4
a2162 30
(define_insn "bitlogical_2_hi"
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 5 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "i"))
	    (zero_extract:HI (match_operand:HI 3 "bit_operand" "Ur")
			     (const_int 1)
			     (match_operand:HI 4 "immediate_operand" "i"))]))]
  ""
  "bld	%Z2,%Y1\;%b5	%Z4,%Y3\;bst	#0,%X0; bl3")

;; This is how combine canonicalizes this pattern.  This is perhaps a bug
;; in combine.c, but there is no problem with writing it this way so we do.
(define_insn "bitlogical_3"
  [(set (zero_extract:QI (match_operand:QI 0 "bit_operand" "+Ur")
			 (const_int 1)
			 (match_operand:HI 1 "immediate_operand" "i"))
	(match_operator:QI 6 "bit_operator"
	   [(lshiftrt:QI (match_operand:QI 2 "bit_operand" "Ur")
			 (match_operand:HI 3 "immediate_operand" "i"))
	    (lshiftrt:QI (match_operand:QI 4 "bit_operand" "Ur")
			 (match_operand:HI 5 "immediate_operand" "i"))]))]
  ""
  "bld	%Z3,%Y2\;%b6	%Z5,%Y4\;bst	%Z1,%Y0; bl5")
						     
;; This is how combine canonicalizes this pattern.  This is perhaps a bug
;; in combine.c, but there is no problem with writing it this way so we do.
(define_insn "bitnot_1"
  [(set (zero_extract:QI (match_operand:QI 0 "bit_operand" "=Ur")
d2164 5
a2168 14
			 (match_operand:HI 1 "immediate_operand" "i"))
	(lshiftrt:QI (xor:QI (match_operand:QI 2 "bit_operand" "0")
			     (match_operand:HI 3 "immediate_operand" "i"))
		     (match_operand:HI 4 "immediate_operand" "1")))]
  "GET_CODE (operands[3]) == CONST_INT && GET_CODE (operands[1]) == CONST_INT
   && exact_log2 (INTVAL (operands[3])) == INTVAL (operands[1])"
  "bnot	%Z1,%Y0")

;; ??? Implement BIAND, BIOR, BIXOR

;; ??? Implement BILD, BIST

;; ??? Apparently general_operand for the 1st and 2nd operands is useful,
;; but I don't know why.  --Jim
d2171 4
a2174 7
  [(set (zero_extract:HI (match_operand:QI 0 "bit_operand" "Ur")
			 (match_operand:HI 1 "general_operand" "g")
			 (match_operand:HI 2 "general_operand" "g"))
	(zero_extract:HI (match_operand:QI 3 "bit_operand" "Ur")
			 (const_int 1)
			 (const_int 0)))]
;; ??? This should have word mode which is SImode for the h8/300h.
d2178 1
d2182 3
a2184 11
  /* ??? HACK ???
     This INSV pattern is wrong.  It should use HImode for operand 3.
     Also, the zero_extract around operand 3 is superfluous and should be
     deleted.  Fixing this is more work than we care to do for the moment,
     because it means most of the above patterns would need to be rewritten,
     and we also need more combine.c patches to make this work.

     So, for now, we work around this bug by simply not accepting any bitfield
     inserts that have a position greater than fits in QImode.  */

  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) >= 8)
a2185 28

  /* The bit_operand predicate accepts any memory during RTL generation, but
     only 'U' memory afterwards, so if this is a MEM operand, we must force
     it to be valid for 'U' by reloading the address.  */

  if (GET_CODE (operands[0]) == MEM && ! EXTRA_CONSTRAINT (operands[0], 'U'))
    {
      rtx mem;
      mem = gen_rtx (MEM, GET_MODE (operands[0]),
		     copy_to_mode_reg (Pmode, XEXP (operands[0], 0)));
      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[0]);
      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[0]);
      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[0]);
      operands[0] = mem;
    }

  /* Likewise for operands[3].  */

  if (GET_CODE (operands[3]) == MEM && ! EXTRA_CONSTRAINT (operands[3], 'U'))
    {
      rtx mem;
      mem = gen_rtx (MEM, GET_MODE (operands[3]),
		     copy_to_mode_reg (Pmode, XEXP (operands[3], 0)));
      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[3]);
      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[3]);
      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[3]);
      operands[3] = mem;
    }
d2188 9
a2196 2
;; ??? Apparently general_operand for the 2nd and 3rd operands is useful,
;; but I don't know why.  --Jim
d2200 3
a2202 4
	(zero_extract:HI (match_operand:QI 1 "bit_operand" "")
			 (match_operand:HI 2 "general_operand" "g")
			 (match_operand:HI 3 "general_operand" "g")))]
;; ??? This should have word mode which is SImode for the h8/300h.
d2206 1
d2210 3
a2212 14
  /* The bit_operand predicate accepts any memory during RTL generation, but
     only 'U' memory afterwards, so if this is a MEM operand, we must force
     it to be valid for 'U' by reloading the address.  */

  if (GET_CODE (operands[1]) == MEM && ! EXTRA_CONSTRAINT (operands[1], 'U'))
    {
      rtx mem;
      mem = gen_rtx (MEM, GET_MODE (operands[1]),
		     copy_to_mode_reg (Pmode, XEXP (operands[1], 0)));
      RTX_UNCHANGING_P (mem) = RTX_UNCHANGING_P (operands[1]);
      MEM_IN_STRUCT_P (mem) = MEM_IN_STRUCT_P (operands[1]);
      MEM_VOLATILE_P (mem) = MEM_VOLATILE_P (operands[1]);
      operands[1] = mem;
    }
d2215 1
a2215 3
;; -----------------------------------------------------------------
;; STACK POINTER MANIPULATIONS
;; -----------------------------------------------------------------
d2217 7
a2223 28
;; This pattern is needed because there is no way on the H8/300
;; to add a 16 bit immediate value to the stack pointer in one 
;; instruction, which could leave an invalid instruction if interrupted
;; half way through.  Here we add to the stack pointer from a
;; register.

(define_insn "stack_pointer_manip"
  [(set (match_operand:HI 0 "register_operand" "=&ra")
	(plus:HI (match_operand:HI 1 "general_operand_src" "g")
		 (match_operand:HI 2 "register_operand" "ra")))]
  "TARGET_H8300"
  "mov.w	%T1,%T0\;add.w	%T2,%T0"
  [(set_attr "type" "arith")
   (set_attr "length" "6")
   (set_attr "cc" "set")])


;; -------------------------------------------
;; BLK moves
;; -------------------------------------------

(define_expand "movstrhi"
  [(parallel [(set (mem:BLK (match_operand:BLK 0 "general_operand" ""))
		   (mem:BLK (match_operand:BLK 1 "general_operand" "")))
	     (use (match_operand:HI 2 "general_operand" ""))
	     (use (match_operand:HI 3 "immediate_operand" ""))
	     (clobber (match_dup 3))
  ])]
d2225 3
a2227 32
  "
{
	rtx src_ptr = copy_to_mode_reg (Pmode, XEXP(operands[1], 0));
	rtx dst_ptr = copy_to_mode_reg (Pmode, XEXP(operands[0], 0));
	
        int max = GET_CODE (operands[2]) == CONST_INT
	  ? MIN (INTVAL (operands[2]), INTVAL (operands[3])) : 1;
	enum machine_mode mode = max >= 2 ? HImode : QImode;
	rtx tmpreg = gen_reg_rtx (mode);
	rtx increment = mode == QImode ? const1_rtx : const2_rtx;
	rtx length = operands[2];
	rtx label = gen_label_rtx ();
	rtx end_src_ptr = gen_reg_rtx (Pmode);

/*	emit_move_insn (length, gen_rtx(MINUS, HImode, length, increment));*/
	FAIL;
	if (Pmode == HImode)
	  emit_insn (gen_addhi3 (end_src_ptr, src_ptr, length));
	else
	  emit_insn (gen_addsi3 (end_src_ptr, src_ptr, length));

	emit_label (label);
	emit_move_insn (tmpreg, gen_rtx (MEM, mode, src_ptr));
	emit_move_insn (gen_rtx (MEM, mode, dst_ptr), tmpreg);
	emit_insn (gen_rtx (SET, VOIDmode, src_ptr,
			    gen_rtx (PLUS, Pmode, src_ptr, increment)));
	emit_insn (gen_rtx (SET, VOIDmode, dst_ptr,
			    gen_rtx (PLUS, Pmode, dst_ptr, increment)));

	emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,
			    gen_rtx (COMPARE, Pmode, src_ptr, end_src_ptr)));
	emit_jump_insn (gen_bne (label));
d2229 13
a2241 2
	DONE;	
}")
d2243 1
d2252 1
a2252 1
	(mem:QI (plus:HI (match_operand:HI 1 "register_operand" "ra")
d2260 1
a2260 1
   (set_attr "cc" "set")])
d2263 1
a2263 1
  [(set (mem:QI (plus:HI (match_operand:HI 1 "register_operand" "ra")
d2272 1
a2272 1
   (set_attr "cc" "set")])
d2283 1
a2283 1
   (set_attr "cc" "set")])
d2292 1
a2292 1
   (set_attr "cc" "set")])
d2304 1
a2304 1
   (set_attr "cc" "set")])
d2314 1
a2314 133
   (set_attr "cc" "set")])

;(define_insn ""
;  [(set (match_operand:HI 0 "register_operand" "=r")
;	(MEM:HI (match_operand:HI 1 "register_operand" "r")))
;   (set (match_operand:HI 3 "register_operand" "=r")
;	(zero_extract:HI (match_dup 0)
;			 (const_int 1)
;			 (match_operand:HI 2 "general_operand" "g")))
;   (set (MEM:HI (match_dup 1) (match_dup 3)))]
;  ""
;  "bld	#0,%3l\;bst	%Z2,%0%Y1"
;  [(set_attr "type" "multi")
;   (set_attr "length" "4")
;   (set_attr "cc" "clobber")])

(define_insn "fancybset1"
  [(set (match_operand:QI 0 "bit_operand" "=Ur")
	(ior:QI (subreg:QI 
		 (ashift:HI (const_int 1)
			    (subreg:QI (match_operand:HI 1 "register_operand" "ri") 0)) 0)
		(match_dup 0)))]
  ""
  "bset	%X1,%X0")	

(define_insn "fancybset"
  [(set (match_operand:QI 0 "bit_operand" "=Ur")
	(ior:QI (subreg:QI 
		 (ashift:HI (const_int 1)
			    (match_operand:HI 1 "nonmemory_operand" "ri") ) 0)
		(match_operand:QI 2 "general_operand" "Ur")))]
  ""
  "mov.b	%X2,%X0\;bset	%X1,%X0")	


(define_insn "fancybclr4"
  [(set (match_operand:QI 0 "general_operand" "=Ur,Ur")
	(and:QI 
	 (subreg:QI 
	  (rotate:HI (const_int -2)
		     (match_operand:HI 2 "nonmemory_operand" "ri,ri") ) 0)
	 (match_operand:QI 1 "general_operand" "0,Ur")))
   (clobber (match_scratch:HI 3 "=X,&r"))]
  ""
  "@@
   bclr	%X2,%X0; l1
   mov.b	%X1,%X3\;mov.b	%3,%0\;bclr	%X2,%X0; l3")

(define_insn "fancybclr5"
  [(set (match_operand:QI 0 "general_operand" "=Ur,Ur")
	(and:QI 
	 (subreg:QI 
	  (rotate:HI (const_int -2)
		     (match_operand:QI 2 "nonmemory_operand" "ri,ri")) 0)
	 (match_operand:QI 1 "general_operand" "0,Ur")))
   (clobber (match_scratch:HI 3 "=X,&r"))]
  ""
  "@@
   bclr	%X2,%X0; l1
   mov.b	%X1,%X3\;mov.b	%3,%0\;bclr	%X2,%X0;l2")

(define_insn "fancybclr2"
  [(set (match_operand:QI 0 "general_operand" "=U,r")
	(and:QI 
	 (subreg:QI 
	  (rotate:HI (const_int -2)
		     (match_operand:HI 2 "nonmemory_operand" "ri,ri") ) 0)
	 (match_operand:QI 1 "general_operand" "0,0")))]
  ""
  "bclr	%X2,%X0")

(define_insn "fancybclr3"
  [(set (match_operand:QI 0 "general_operand" "=U,r")
	(and:QI 
	 (subreg:QI 
	  (rotate:HI (const_int -2)
		     (match_operand:QI 2 "nonmemory_operand" "ri,ri")) 0)
	 (match_operand:QI 1 "general_operand" "0,0")))]
  ""
  "bclr	%X2,%X0")

(define_insn "fancybclr"
  [(set (match_operand:QI 0 "general_operand" "=r")
	(and:QI (not:QI (match_operand:QI 1 "general_operand" "0"))
		(match_operand:QI 2 "general_operand" "r")))]
  ""
  "not	%X0\;and	%X2,%X0")

(define_insn "fancybsetp3"
  [(set (match_operand:QI 0 "bit_operand" "=Ur")
	(ior:QI (subreg:QI (ashift:HI (const_int 1)
				      (match_operand:QI 1 "register_operand" "r")) 0)
		(match_operand:QI 2 "bit_operand" "0")))]
  ""
  "bset	%X1,%X0")

(define_insn "fancybsetp2"
  [(set (match_operand:QI 0 "general_operand" "=r,U")
	(ior:QI (subreg:QI (ashift:HI (const_int 1)
				      (match_operand:QI 1 "register_operand" "r,r")) 0)
		(match_operand:QI 2 "general_operand" "U,r")))]
  ""
  "mov.b	%X2,%X0\;bset	%X1,%X0")
	
(define_insn "fancybnot"
  [(set (match_operand:QI 0 "bit_operand" "=Ur")
	(xor:QI (subreg:QI (ashift:HI (const_int 1)
				      (match_operand:QI 1 "register_operand" "r")) 0)
		(match_operand:QI 2 "bit_operand" "0")))]

  ""
  "bnot	%X1,%X0")

(define_insn "fancy_btst"
  [(set (pc)
	(if_then_else (eq (zero_extract:HI (zero_extend:HI (match_operand:QI 1 "general_operand" "Ur"))
					   (const_int 1)
					   (match_operand:HI 2 "nonmemory_operand" "rn"))
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"btst	%X2,%X1\;beq	%l0\";
  else if (get_attr_length (insn) == 4)
    return \"btst	%X2,%X1\;beq	%l0:16\";
  else
    return \"btst	%X2,%X1\;bne	%L1\;jmp	@@%l0\;%L1:\";
}"
  [(set_attr "type" "branch")
   (set_attr "cc" "clobber")])
a2315 32
(define_insn "fancy_btst1"
  [(set (pc)
	(if_then_else (ne (zero_extract:HI (zero_extend:HI (match_operand:QI 1 "general_operand" "Ur"))
					   (const_int 1)
					   (match_operand:HI 2 "nonmemory_operand" "rn"))
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
  if (get_attr_length (insn) == 2)
    return \"btst	%X2,%X1\;bne	%l0\";
  else if (get_attr_length (insn) == 4)
    return \"btst	%X2,%X1\;bne	%l0:16\";
  else
    return \"btst	%X2,%X1\;beq	%L1\;jmp	@@%l0\;%L1:\";
}"
  [(set_attr "type" "branch")
   (set_attr "cc" "clobber")])

(define_insn "pxor"
  [(set (zero_extract:QI (match_operand:QI 0 "bit_operand" "=r,U")
			 (const_int 1)
			 (match_operand 1 "immediate_operand" "n,n"))
	(and:QI (not:QI (match_operand:QI 2 "bit_operand" "r,U"))
			(const_int 1)))]
  ""
  "bld	#0,%X2\;bist	%1,%0"
  [(set_attr "type" "arith")
   (set_attr "length" "4")
   (set_attr "cc" "clobber")])
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
;; Copyright (C) 1992, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
d24 1
d33 2
a34 30
;; Many logical operations should have "bit" variants if only one
;; bit is going to be operated on.

;; (and (logical op) (const_int X))
;; If const_int only specifies a few bits (like a single byte in a 4 byte
;; operation, then it's more efficient to only apply the and and logical_op
;; to the bits we care about.

;; Some of the extend instructions accept a general_operand_src, which
;; allows all the normal memory addressing modes.  The length computations
;; don't take this into account.  The lengths in the MD file should be
;; "worst case" and then be adjusted to their correct values by
;; h8300_adjust_insn_length.

;; On the h8300h, adds/subs operate on the 32bit "er" registers.  Right
;; now GCC doesn't expose the "e" half to the compiler, so using add/subs
;; for addhi and subhi is safe.
;; Long term, we want to expose the "e" half to the compiler (gives us
;; 8 more 16bit registers).  At that point addhi and subhi can't use adds/subs.

;; There's currently no way to have a insv/extzv expander for the h8/300h
;; because word_mode is different for the h8/300 and h8/300h.

;; Shifts/rotates by small constants should be handled by special
;; patterns so we get the length and cc status correct.

;; Bitfield operations no longer accept memory operands.  We need
;; to add variants which operate on memory back to the MD.

;; ??? Implement remaining bit ops available on the h8300
d36 1
a36 1
(define_attr "type" "branch,arith"
d54 5
a58 1
				     (const_int 6)))]
d61 3
a63 12
;; Condition code settings.
;; none - insn does not affect cc
;; none_0hit - insn does not affect cc but it does modify operand 0
;;	This attribute is used to keep track of when operand 0 changes.
;; 	See the description of NOTICE_UPDATE_CC for more info.
;; set_znv - insn sets z,n,v to usable values (like a tst insn); c is unknown.
;; set_zn  - insn sets z,n to usable values; v,c are unknown.
;; compare - compare instruction
;; clobber - value of cc is unknown
(define_attr "cc" "none,none_0hit,set_znv,set_zn,compare,clobber"
  (const_string "clobber"))

d81 8
a88 8
  [(set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set_znv")])

(define_insn ""
  [(set (match_operand:QI 0 "general_operand_dst" "=r,r,<,r,r,m")
	(match_operand:QI 1 "general_operand_src" "I,r>,r,n,m,r"))]
  "register_operand (operands[0],QImode)
   || register_operand (operands[1], QImode)"
d91 8
a98 7
   mov.b	%R1,%X0
   mov.b	%X1,%R0
   mov.b	%R1,%X0
   mov.b	%R1,%X0
   mov.b	%X1,%R0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2) (const_int 2)
d100 4
a103 2
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])
d120 2
a121 2
  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "=r,r,r,r"))
			 (match_operand:QI 1 "general_operand_src" "I,r,n,m"))]
d126 10
a135 6
   mov.b	%R1,%X0
   mov.b	%R1,%X0"
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv")])
a138 2
;; ??? We use push.l on the h8300h to push a 16bit value?!?  We have
;; 16bit push insns!
d141 1
a141 1
	(match_operand:HI 1 "register_operand" "r"))]
d150 8
a157 8
  [(set (attr "length") (if_then_else (eq_attr "cpu" "h8300") (const_int 2) (const_int 4)))
   (set_attr "cc" "set_znv")])

(define_insn ""
  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,<,r,r,m")
	(match_operand:HI 1 "general_operand_src" "I,r>,r,i,m,r"))]
  "register_operand (operands[0],HImode)
   || register_operand (operands[1], HImode)"
a162 1
   mov.w	%T1,%T0
d164 3
a166 2
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 2) (const_int 4)
d168 3
a170 2
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])
d187 2
a188 2
  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "=r,r,r,r"))
			 (match_operand:HI 1 "general_operand_src" "I,r,i,m"))]
d194 1
d196 7
a202 4
  [(set_attr_alternative "length"
     [(const_int 2) (const_int 2) (const_int 4)
      (if_then_else (eq_attr "cpu" "h8300") (const_int 4) (const_int 8))])
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv")])
d217 1
a217 1
  else
d239 1
a239 1
  else
d252 1
a252 1
	(match_operand:SI 1 "general_operand_src" "I,r,io,r,r,>"))]
d293 1
a293 10
	  /* See if either half is zero.  If so, use sub.w to clear
	     that half.  */
	if (GET_CODE (operands[1]) == CONST_INT)
	  {
	    if ((INTVAL (operands[1]) & 0xffff) == 0)
	      return \"mov.w	%e1,%e0\;sub.w	%f0,%f0\";
	    if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)
	      return \"sub.w	%e0,%e0\;mov.w	%f1,%f0\";
	  }
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
d295 1
d297 1
a297 1
	return \"mov.w	%e1,%e0\;mov.w	%f1,%f0\";
d304 2
a305 1
  [(set_attr "length" "4,4,8,8,4,4")
d310 1
a310 1
	(match_operand:SF 1 "general_operand_src" "I,r,io,r,r,>"))]
d364 2
a365 1
  [(set_attr "length" "4,4,8,8,4,4")
d368 4
a371 4
(define_insn "movsi_h8300hs"
  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,m,<,r,*a,*a,r")
	(match_operand:SI 1 "general_operand_src" "I,r,im,r,r,>,I,r,*a"))]
  "(TARGET_H8300S || TARGET_H8300H)
d374 10
a383 40
  "*
{
  if (which_alternative == 0)
    return \"sub.l	%S0,%S0\";
  if (which_alternative == 6)
    return \"clrmac\";
  if (which_alternative == 7)
    return \"clrmac\;ldmac %1,macl\";
  if (which_alternative == 8)
    return \"stmac macl,%0\";
  if (GET_CODE (operands[1]) == CONST_INT)
    {
      int val = INTVAL (operands[1]);

      /* Look for constants which can be made by adding an 8-bit
	 number to zero in one of the two low bytes.  */
      if (val == (val & 0xff))
	{
	  operands[1] = GEN_INT ((char)val & 0xff);
	  return \"sub.l %S0,%S0\;add.b %1,%w0\";
	}
     
      if (val == (val & 0xff00))
	{
	  operands[1] = GEN_INT ((char)(val >> 8) & 0xff);
	  return \"sub.l %S0,%S0\;add.b %1,%x0\";
	}

      /* Now look for small negative numbers.  We can subtract them
	 from zero to get the desired constant.  */
      if (val == -4 || val == -2 || val == -1)
	{
	  operands[1] = GEN_INT (-INTVAL (operands[1]));
	  return \"sub.l %S0,%S0\;subs %1,%S0\";
	}
    }
   return \"mov.l	%S1,%S0\";
}"
  [(set_attr "length" "2,2,10,10,4,4,2,6,4")
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv")])
d386 3
a388 3
  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,m,<,r")
	(match_operand:SF 1 "general_operand_src" "I,r,im,r,r,>"))]
  "(TARGET_H8300H || TARGET_H8300S)
d398 4
a401 3
  [(set_attr "length" "2,2,10,10,4,4")
   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])

a405 54
(define_insn ""
  [(set (cc0) (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%R0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:HI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:SI (match_operand:QI 0 "bit_memory_operand" "rU")
			       (const_int 1)
			       (match_operand:QI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:QI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%R0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
  
(define_insn ""
  [(set (cc0) (zero_extract:HI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

(define_insn ""
  [(set (cc0) (zero_extract:SI (match_operand:HI 0 "register_operand" "r")
			       (const_int 1)
			       (match_operand:HI 1 "const_int_operand" "n")))]
  ""
  "btst	%Z1,%Y0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])

d407 1
a407 1
  [(set (cc0) (match_operand:QI 0 "register_operand" "r"))]
d409 11
a419 3
  "mov.b	%X0,%X0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])
d422 1
a422 1
  [(set (cc0) (match_operand:HI 0 "register_operand" "r"))]
d424 11
a434 3
  "mov.w	%T0,%T0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])
d437 13
a449 5
  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
  "TARGET_H8300H || TARGET_H8300S"
  "mov.l	%S0,%S0"
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])
d453 2
a454 2
	(compare:QI (match_operand:QI 0 "register_operand" "r")
		    (match_operand:QI 1 "nonmemory_operand" "rn")))]
d457 2
a458 1
  [(set_attr "length" "2")
d461 3
a463 1
(define_expand "cmphi"
d465 2
a466 2
	(compare:HI (match_operand:HI 0 "register_operand" "")
		    (match_operand:HI 1 "nonmemory_operand" "")))]
a467 13
  "
{
  /* Force operand1 into a register if we're compiling
     for the h8/300.  */
  if (GET_CODE (operands[1]) != REG && TARGET_H8300)
    operands[1] = force_reg (HImode, operands[1]);
}")

(define_insn ""
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "register_operand" "r")
		    (match_operand:HI 1 "register_operand" "r")))]
  "TARGET_H8300"
d469 2
a470 1
  [(set_attr "length" "2")
d473 1
a473 8
(define_insn ""
  [(set (cc0)
	(compare:HI (match_operand:HI 0 "register_operand" "r,r")
		    (match_operand:HI 1 "nonmemory_operand" "r,n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "cmp.w	%T1,%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "compare,compare")])
d477 3
a479 3
	(compare:SI (match_operand:SI 0 "register_operand" "r,r")
		    (match_operand:SI 1 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H || TARGET_H8300S"
d481 4
a484 3
  [(set_attr "length" "2,6")
   (set_attr "cc" "compare,compare")])

d492 1
a492 1
		 (match_operand:QI 2 "nonmemory_operand" "rn")))]
d495 23
a517 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
d519 1
a526 38
;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0")
		 (match_operand:HI 2 "adds_subs_operand" "n")))]
  ""
  "* return output_adds_subs (operands);"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r,r,&r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,g")
		 (match_operand:HI 2 "nonmemory_operand" "n,r,r")))]
  "TARGET_H8300"
  "@@
   add.b	%s2,%s0\;addx	%t2,%t0 
   add.w	%T2,%T0
   mov.w        %T1,%T0\;add.w  %T2,%T0"
  [(set_attr "length" "4,2,6")
   (set_attr "cc" "clobber,set_zn,set_zn")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0")
		 (match_operand:HI 2 "nonmemory_operand" "n,r")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   add.w	%T2,%T0
   add.w	%T2,%T0"
  [(set_attr "length" "4,2")
   (set_attr "cc" "set_zn,set_zn")])

a533 15
;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0")
		 (match_operand:SI 2 "adds_subs_operand" "n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "* return output_adds_subs (operands);"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

d542 3
a544 2
   mov.w	%f1,%f0\;mov.w	%e1,%e0\;add.w	%f2,%f0\;addx	%y2,%y0\;addx	%z2,%z0"
  [(set_attr "length" "8,6,10")
d547 4
d552 9
a560 5
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(plus:SI (match_operand:SI 1 "register_operand" "%0,0")
		 (match_operand:SI 2 "nonmemory_operand" "i,r")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
d563 3
a565 2
  [(set_attr "length" "6,2")
   (set_attr "cc" "set_zn,set_zn")])
d574 1
a574 1
		  (match_operand:QI 2 "nonmemory_operand" "r,n")))]
d579 23
a601 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
d603 1
d606 1
a606 1
	(minus:HI (match_operand:HI 1 "general_operand" "")
a610 42
;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.  This may not be needed
;; due to instruction canonicalization.
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r")
	(minus:HI (match_operand:HI 1 "register_operand" "r")
		  (match_operand:HI 2 "adds_subs_operand" "n")))]
  ""
  "*
{
  operands[2] = GEN_INT (-INTVAL (operands[2]));
  return output_adds_subs (operands);
}"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,&r")
	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
		  (match_operand:HI 2 "nonmemory_operand" "r,n")))]
  "TARGET_H8300"
  "@@
   sub.w	%T2,%T0
   add.b	%E2,%s0\;addx	%F2,%t0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_zn,clobber")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,&r")
	(minus:HI (match_operand:HI 1 "general_operand" "0,0")
		  (match_operand:HI 2 "nonmemory_operand" "r,n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
   sub.w	%T2,%T0
   sub.w	%T2,%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_zn,set_zn")])

d624 2
a625 1
  [(set_attr "length" "6")
d628 1
a628 19
;; Specialized version using adds/subs.  This must come before
;; the more general patterns below.  This may not be needed
;; due to instruction canonicalization.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r")
	(minus:SI (match_operand:SI 1 "general_operand" "0")
		  (match_operand:SI 2 "adds_subs_operand" "n")))]
  "TARGET_H8300H || TARGET_H8300S"
  "*
{
  operands[2] = GEN_INT (-INTVAL (operands[2]));
  return output_adds_subs (operands);
}"
  [(set_attr "cc" "none_0hit")
   (set (attr "length")
        (if_then_else (ne (match_operand:HI 2 "one_insn_adds_subs_operand" "")
			  (const_int 0))
		      (const_int 2)
		      (const_int 4)))])
d631 4
a634 4
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(minus:SI (match_operand:SI 1 "general_operand" "0,0")
		  (match_operand:SI 2 "nonmemory_operand" "r,i")))]
  "TARGET_H8300H || TARGET_H8300S"
d636 2
d640 4
a643 3
  [(set_attr "length" "2,6")
   (set_attr "cc" "set_zn,set_zn")])

d654 1
a654 1
  "TARGET_H8300H || TARGET_H8300S"
d656 3
a658 2
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])
d664 1
a664 1
  "TARGET_H8300H || TARGET_H8300S"
d666 3
a668 2
  [(set_attr "length" "4")
   (set_attr "cc" "set_zn")])
d676 2
a677 1
  [(set_attr "length" "2")
d684 1
a684 1
  "TARGET_H8300H || TARGET_H8300S"
d686 2
a687 33
  [(set_attr "length" "2")
   (set_attr "cc" "none_0hit")])

;; This is a "bridge" instruction.  Combine can't cram enough insns
;; together to crate a MAC instruction directly, but it can create
;; this instruction, which then allows combine to create the real
;; MAC insn.
;;
;; Unfortunately, if combine doesn't create a MAC instruction, this
;; insn must generate reasonably correct code.  Egad.
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=a")
	(mult:SI
	  (sign_extend:SI
	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
	  (sign_extend:SI
	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))]
  "TARGET_H8300S"
  "clrmac\;mac	%2,%1"
  [(set_attr "length" "6")
   (set_attr "cc" "none_0hit")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=a")
	(plus (mult:SI
	  (sign_extend:SI (mem:HI
	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
	  (sign_extend:SI (mem:HI
	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
	      (match_operand:SI 3 "register_operand" "0")))]
  "TARGET_H8300S"
  "mac	%2,%1"
  [(set_attr "length" "4")
d696 2
a697 4
	(truncate:QI
	  (udiv:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
d700 2
a701 1
  [(set_attr "length" "2")
d708 2
a709 4
	(truncate:QI
	  (div:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
d712 2
a713 1
  [(set_attr "length" "2")
d718 3
a720 5
	(truncate:HI
	  (udiv:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
d722 2
a723 1
  [(set_attr "length" "2")
d728 3
a730 5
	(truncate:HI
	  (div:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
d732 2
a733 1
  [(set_attr "length" "4")
d742 2
a743 4
	(truncate:QI
	  (umod:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
d746 2
a747 1
  [(set_attr "length" "4")
d752 3
a754 5
	(truncate:QI
	  (mod:HI
	    (match_operand:HI 1 "general_operand" "0")
	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
d756 2
a757 1
  [(set_attr "length" "6")
d762 3
a764 5
	(truncate:HI
	  (umod:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
d766 2
a767 1
  [(set_attr "length" "4")
d772 3
a774 5
	(truncate:HI
	  (mod:SI
	    (match_operand:SI 1 "general_operand" "0")
	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))]
  "TARGET_H8300H || TARGET_H8300S"
d776 2
a777 1
  [(set_attr "length" "6")
d779 1
a779 1

d784 1
a784 1
(define_insn ""
d791 4
a794 3
   bclr	%W2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])
d797 3
a799 3
  [(set (match_operand:QI 0 "bit_operand" "")
	(and:QI (match_operand:QI 1 "bit_operand" "")
		(match_operand:QI 2 "nonmemory_operand" "")))]
d807 2
a818 1

a824 2
  if (TARGET_H8300H || TARGET_H8300S)
    return \"and.w %T2,%T0\";
d827 2
a828 1
  [(set_attr "length" "4")
d831 2
d834 9
a842 50
  [(set (match_operand:SI 0 "register_operand" "=r")
	(and:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "nonmemory_operand" "rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);
      int upper_cleared, lower_cleared;

      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, or they're
	 going to be zero'd out, then we can work on the
	 low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && ((i & 0xffff0000) != 0xffff0000
	      || (i & 0xffff0000) == 0x00000000))
        return \"and.l	%S2,%S0\";

      lower_cleared = 0;
      if ((i & 0x0000ffff) == 0x00000000)
	{
	  output_asm_insn (\"sub.w	%f0,%f0\", operands);
	  lower_cleared = 1;
	}

      upper_cleared = 0;
      if ((i & 0xffff0000) == 0x00000000)
	{
	  output_asm_insn (\"sub.w	%e0,%e0\", operands);
	  upper_cleared = 1;
	}

      if ((i & 0x000000ff) != 0x000000ff && !lower_cleared)
	output_asm_insn (\"and	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0x0000ff00 && !lower_cleared)
	output_asm_insn (\"and	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0x00ff0000 && !upper_cleared) 
	output_asm_insn (\"and	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0xff000000 && !upper_cleared) 
	output_asm_insn (\"and	%z2,%z0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"and.l	%S2,%S0\";
  return \"and	%w2,%w0\;and	%x2,%x0\;and	%y2,%y0\;and	%z2,%z0\;\";
}"
  [(set_attr "length" "8")
a844 1

d849 2
a850 2
(define_insn ""
  [(set (match_operand:QI 0 "bit_operand" "=r,U")
d852 1
a852 1
		(match_operand:QI 2 "nonmemory_operand" "rn,P")))]
d855 5
a859 4
   or	%X2,%X0
   bset	%V2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])
d872 2
d881 14
a894 1
  if (GET_CODE (operands[2]) == CONST_INT)
d896 1
a896 7
      int i = INTVAL (operands[2]);

      if ((i & 0x00ff) != 0) 
	output_asm_insn (\"or	%s2,%s0\", operands);
      if ((i & 0xff00) != 0) 
	output_asm_insn (\"or	%t2,%t0\", operands);
      return \"\";
a897 3
  if (TARGET_H8300H || TARGET_H8300S)
    return \"or.w	%T2,%T0\";
  return \"or	%s2,%s0\;or	%t2,%t0; %2 or2\";
d899 2
a900 1
  [(set_attr "length" "2,4")
d904 3
a906 3
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(ior:SI (match_operand:SI 1 "register_operand" "%0,0")
		(match_operand:SI 2 "nonmemory_operand" "J,rn")))]
d910 18
a927 1
  if (GET_CODE (operands[2]) == CONST_INT)
d929 1
a929 19
      int i = INTVAL (operands[2]);

      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, then we can
	 work on the low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && (i & 0xffff0000) != 0x00000000)
        return \"or.l	%S2,%S0\";
	
      if ((i & 0x000000ff) != 0) 
	output_asm_insn (\"or	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0) 
	output_asm_insn (\"or	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0) 
	output_asm_insn (\"or	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0) 
	output_asm_insn (\"or	%z2,%z0\", operands);
      return \"\";
a930 3
  if (TARGET_H8300H || TARGET_H8300S)
    return \"or.l	%S2,%S0\";
  return \"or	%w2,%w0\;or	%x2,%x0\;or	%y2,%y0\;or	%z2,%z0\;\";
d932 3
a934 2
  [(set_attr "length" "2,8")
   (set_attr "cc" "clobber,clobber")])
d940 1
a940 1
(define_insn ""
d947 4
a950 3
   bnot	%V2,%R0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,none_0hit")])
d964 3
a966 3
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(xor:HI (match_operand:HI 1 "general_operand" "%0,0")
		(match_operand:HI 2 "nonmemory_operand" "J,rn")))]
d970 8
a977 3
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);
d979 1
a979 12
      if ((i & 0x00ff) != 0) 
	output_asm_insn (\"xor	%s2,%s0\", operands);
      if ((i & 0xff00) != 0) 
	output_asm_insn (\"xor	%t2,%t0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"xor.w	%T2,%T0\";
  return \"xor	%s2,%s0\;xor	%t2,%t0\";
}"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])
d984 8
a991 7
		(match_operand:SI 2 "nonmemory_operand" "J,rn")))]
  ""
  "*
{
  if (GET_CODE (operands[2]) == CONST_INT)
    {
      int i = INTVAL (operands[2]);
a992 25
      /* The h8300h can't do byte-wise operations on the
	 upper 16bits of 32bit registers.  However, if
	 those bits aren't going to change, then we can
	 work on the low-order bits.  */
      if ((TARGET_H8300H || TARGET_H8300S)
	  && (i & 0xffff0000) != 0x00000000)
        return \"xor.l	%S2,%S0\";

      if ((i & 0x000000ff) != 0) 
	output_asm_insn (\"xor	%w2,%w0\", operands);
      if ((i & 0x0000ff00) != 0) 
	output_asm_insn (\"xor	%x2,%x0\", operands);
      if ((i & 0x00ff0000) != 0) 
	output_asm_insn (\"xor	%y2,%y0\", operands);
      if ((i & 0xff000000) != 0) 
	output_asm_insn (\"xor	%z2,%z0\", operands);
      return \"\";
    }
  if (TARGET_H8300H || TARGET_H8300S)
    return \"xor.l	%S2,%S0\";
  return \"xor	%w2,%w0\;xor	%x2,%x0\;xor	%y2,%y0\;xor	%z2,%z0\;\";
}"
  [(set_attr "length" "2,8")
   (set_attr "cc" "clobber,clobber")])

d1002 3
a1004 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
d1031 1
a1031 1
  "TARGET_H8300H || TARGET_H8300S"
d1033 3
a1035 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
d1062 1
a1062 1
  "TARGET_H8300H || TARGET_H8300S"
d1064 3
a1066 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_zn")])
d1077 3
a1079 2
  [(set_attr "length" "2")
   (set_attr "cc" "set_znv")])
d1092 3
a1094 6
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 4)
		      (const_int 2)))])
d1107 5
a1111 8
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 8)
		      (const_int 2)))])
			

a1216 10
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    {
      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
      return 0;
    }

d1234 1
a1236 10
  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
      && (GET_CODE (operands[1]) == GT
          || GET_CODE (operands[1]) == GE
          || GET_CODE (operands[1]) == LE
          || GET_CODE (operands[1]) == LT))
    {
      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
      return 0;
    }

d1278 2
a1279 1
  [(set_attr "cc" "none")
d1285 1
a1285 1
  "TARGET_H8300H || TARGET_H8300S"
d1287 2
a1288 1
  [(set_attr "cc" "none")
d1293 8
d1302 1
a1302 1
  [(set (pc) (match_operand 0 "jump_address_operand" ""))]
d1307 1
a1307 1
  [(set (pc) (match_operand:HI 0 "jump_address_operand" "Vr"))]
d1309 5
a1313 2
  "jmp	@@%0"
  [(set_attr "cc" "none")
d1317 7
a1323 4
  [(set (pc) (match_operand:SI 0 "jump_address_operand" "Vr"))]
  "TARGET_H8300H || TARGET_H8300S"
  "jmp @@%0"
  [(set_attr "cc" "none")
d1334 4
a1337 13
  "*
{
  if (GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF
      && SYMBOL_REF_FLAG (XEXP (operands[0], 0)))
    return \"jsr\\t\@@%0:8\";
  else
    return \"jsr\\t%0\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
     (if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
		   (const_int 4)
		   (const_int 8)))])
d1349 4
a1352 13
  "*
{
  if (GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF
      && SYMBOL_REF_FLAG (XEXP (operands[1], 0)))
    return \"jsr\\t\@@%1:8\";
  else
    return \"jsr\\t%1\";
}"
  [(set_attr "cc" "clobber")
   (set (attr "length")
     (if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
		   (const_int 4)
		   (const_int 8)))])
d1358 2
a1359 1
  [(set_attr "cc" "none")
d1361 1
a1361 1

d1368 1
a1368 1
	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
d1370 20
a1389 5
  "@@
  mov.b	#0,%t0
  mov.b	%R1,%s0\;mov.b	#0,%t0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])
d1391 16
a1406 11
;; The compiler can synthesize a 300H variant of this which is
;; just as efficient as one that we'd create
(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  mov.b	#0,%x0\;sub.w %e0,%e0
  mov.b	%R1,%w0\;mov.b	#0,%x0\;sub.w %e0,%e0"
  [(set_attr "length" "4,6")
   (set_attr "cc" "clobber,clobber")])
d1408 3
a1410 3
(define_expand "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "")
	(zero_extend:SI (match_operand:HI 1 "general_operand" "")))]
d1412 1
a1412 1
  "
d1414 9
a1422 3
  if (TARGET_H8300
      && GET_CODE (operands[1]) != CONST_INT
      && !optimize)
d1424 5
a1428 2
      emit_insn (gen_zero_extendhisi2_h8300 (operands[0], operands[1]));
      DONE;
d1430 5
a1434 68
}")

;; This is used when not optimizing.  It avoids severe code explosion
;; due to poor register allocation.
(define_expand "zero_extendhisi2_h8300"
  [(set (reg:HI 1) (match_operand:HI 1 "general_operand" ""))
   (set (reg:SI 0) (zero_extend:SI (reg:HI 1)))
   (set (match_operand:SI 0 "general_operand" "" ) (reg:SI 0))]
  "TARGET_H8300"
  "")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  sub.w	%e0,%e0
  mov.w %e1,%f0\;sub.w %e0,%e0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "clobber,clobber")])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(zero_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  extu.l	%S0
  mov.w	%T1,%T0\;extu.l	%S0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

(define_expand "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "")
	(sign_extend:HI (match_operand:QI 1 "general_operand" "")))]
  ""
  "")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  bld	#7,%s0\;subx	%t0,%t0
  mov.b	%R1,%s0\;bld	#7,%s0\;subx	%t0,%t0"
  [(set_attr "length" "4,6")
   (set_attr "cc" "clobber,clobber")])

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=r,r")
	(sign_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  exts.w	%T0
  mov.b	%R1,%s0\;exts.w	%T0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

;; The compiler can synthesize a 300H variant of this which is
;; just as efficient as one that we'd create
(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300"
  "@@
  bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0
  mov.b %R1,%w0\;bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
  [(set_attr "length" "8,10")
   (set_attr "cc" "clobber,clobber")])
d1442 5
a1446 7
  if (TARGET_H8300
      && GET_CODE (operands[1]) != CONST_INT
      && !optimize)
    {
      emit_insn (gen_extendhisi2_h8300 (operands[0], operands[1]));
      DONE;
    }
a1448 2
;; This is used when not optimizing.  It avoids severe code explosion
;; due to poor register allocation.
d1456 9
a1464 3
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
d1466 18
a1483 5
  "@@
  bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0
  mov.w	%T1,%f0\;bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
  [(set_attr "length" "6,8")
   (set_attr "cc" "clobber,clobber")])
a1484 10
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=r,r")
	(sign_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
  "TARGET_H8300H || TARGET_H8300S"
  "@@
  exts.l	%S0
  mov.w	%T1,%T0\;exts.l	%S0"
  [(set_attr "length" "2,4")
   (set_attr "cc" "set_znv,set_znv")])

d1527 4
a1530 1
(define_insn ""
d1534 1
a1534 1
			  (match_operand:QI 2 "nonmemory_operand" "KM,rn")]))
d1538 5
a1542 1
  [(set_attr "length" "20")
d1556 1
a1556 1
	(lshiftrt:HI (match_operand:HI 1 "general_operand" "")
d1568 4
a1571 1
(define_insn ""
d1575 1
a1575 1
			  (match_operand:QI 2 "nonmemory_operand" "KM,rn")]))
d1579 5
a1583 1
  [(set_attr "length" "20")
d1591 1
a1591 1
	 (match_operand:SI 1 "general_operand" "")
d1599 1
a1599 1
	 (match_operand:SI 1 "general_operand" "")
d1607 1
a1607 1
	 (match_operand:SI 1 "general_operand" "")
d1612 4
a1615 1
(define_insn ""
d1619 1
a1619 1
			  (match_operand:QI 2 "nonmemory_operand" "K,rn")]))
d1623 5
a1627 1
  [(set_attr "length" "20")
d1629 1
a1629 1

d1634 1
a1634 1
;; instructions so let's use them as well as we can.
d1636 75
a1710 6
;; You'll never believe all these patterns perform one basic action --
;; load a bit from the source, optionally invert the bit, then store it
;; in the destination (which is known to be zero)..  
;;
;; Combine obviously need some work to better identify this situation and
;; canonicalize the form better.
d1712 1
a1712 6
;; 
;; Normal loads with a 16bit destination.
;; 
;; Yes, both cases are needed.
;;
(define_insn ""
d1714 1
a1714 1
	(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
d1716 1
a1716 1
			 (match_operand:HI 2 "immediate_operand" "n")))]
d1718 1
a1718 3
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])
d1720 1
a1720 1
(define_insn ""
d1722 5
a1726 14
	(subreg:HI (zero_extract:SI
		     (match_operand:HI 1 "register_operand" "r")
		     (const_int 1)
		     (match_operand:HI 2 "immediate_operand" "n")) 1))]
  ""
  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])

;; 
;; Inverted loads with a 16bit destination.
;; 
;; Yes, all four cases are needed.
;;
d1728 5
a1732 4
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(zero_extract:HI (xor:HI (match_operand:HI 1 "register_operand" "r")
				 (match_operand:HI 3 "p_operand" "P"))
d1734 3
a1736 5
			 (match_operand:HI 2 "const_int_operand" "n")))]
  "(1 << INTVAL (operands[2])) == INTVAL (operands[3])"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])
d1738 10
a1747 11
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (lshiftrt:HI
		    (match_operand:HI 1 "bit_operand" "Ur")
		    (match_operand:HI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])
d1749 1
a1749 12
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (subreg:HI 
		    (lshiftrt:SI
		      (match_operand:SI 1 "register_operand" "Ur")
		      (match_operand:SI 2 "const_int_operand" "n")) 1))
		(const_int 1)))]
  "INTVAL (operands[2]) < 16"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])
d1751 7
a1757 24
(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=&r")
	(and:HI (not:HI 
		  (subreg:HI 
		    (lshiftrt:SI
		      (match_operand:SI 1 "bit_operand" "Ur")
		      (match_operand:SI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "(TARGET_H8300H || TARGET_H8300S)
   && INTVAL (operands[2]) < 16"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])

;; 
;; Normal loads with a 32bit destination.
;; 
;; Yes, all three cases are needed.
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(zero_extract:SI (match_operand:HI 1 "register_operand" "r")
			 (const_int 1)
			 (match_operand:HI 2 "const_int_operand" "n")))]
d1759 1
a1759 7
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1761 9
a1769 15
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (zero_extend:SI 
		   (lshiftrt:QI
		     (match_operand:QI 1 "bit_operand" "Ur")
		     (match_operand:QI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1771 11
a1781 15
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (zero_extend:SI 
		   (lshiftrt:HI
		      (match_operand:HI 1 "bit_operand" "Ur")
		      (match_operand:HI 2 "const_int_operand" "n")))
		(const_int 1)))]
  ""
  "* return output_simode_bld (0, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1783 11
a1793 33
;; 
;; Inverted loads with a 32bit destination.
;; 
;; Yes, all seven cases are needed.
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI (match_operand:HI 1 "register_operand" "r")))
		(match_operand:SI 2 "p_operand" "P")))]
  ""
  "* return output_simode_bld (1, 1, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI
		    (lshiftrt:HI (match_operand:HI 1 "bit_operand" "Ur")
				 (match_operand:HI 2 "const_int_operand" "n"))))
		(const_int 1)))]
  ""
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1795 26
a1820 28
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI (match_operand:QI 1 "register_operand" "r")))
		(match_operand:SI 2 "p_operand" "P")))]
  ""
  "* return output_simode_bld (1, 1, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (zero_extend:SI
		    (lshiftrt:QI (match_operand:QI 1 "bit_operand" "Ur")
				 (match_operand:QI 2 "const_int_operand" "n"))))
		(const_int 1)))]
  ""
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1822 1
a1822 16
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (subreg:SI 
		     (lshiftrt:HI
			(match_operand:HI 1 "bit_operand" "Ur")
			(match_operand:HI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "1"
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1824 1
a1824 16
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(and:SI (not:SI
		  (subreg:SI 
		     (lshiftrt:QI
			(match_operand:QI 1 "bit_operand" "Ur")
			(match_operand:QI 2 "const_int_operand" "n")) 0))
		(const_int 1)))]
  "1"
  "* return output_simode_bld (1, 0, operands);"
  [(set_attr "cc" "clobber")
   (set (attr "length")
	(if_then_else (eq (symbol_ref "TARGET_H8300H || TARGET_H8300S")
			  (const_int 0))
		      (const_int 10)
		      (const_int 8)))])
d1826 2
a1827 10
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=&r")
	(zero_extract:SI (xor:HI (match_operand:HI 1 "register_operand" "r")
				 (match_operand:HI 3 "p_operand" "P"))
			 (const_int 1)
			 (match_operand:HI 2 "const_int_operand" "n")))]
  "(1 << INTVAL (operands[2])) == INTVAL (operands[3])"
  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
  [(set_attr "cc" "clobber")
   (set_attr "length" "8")])
d1830 7
a1836 4
  [(set (zero_extract:HI (match_operand:HI 0 "general_operand" "")
			 (match_operand:HI 1 "general_operand" "")
			 (match_operand:HI 2 "general_operand" ""))
	(match_operand:HI 3 "general_operand" ""))]
a1839 1
  /* We only have single bit bitfield instructions.  */
d1843 11
a1853 3
  /* For now, we don't allow memory operands.  */
  if (GET_CODE (operands[0]) == MEM
      || GET_CODE (operands[3]) == MEM)
d1855 28
d1885 2
a1886 9
(define_insn ""
  [(set (zero_extract:HI (match_operand:HI 0 "register_operand" "+r")
			 (const_int 1)
			 (match_operand:HI 1 "immediate_operand" "n"))
	(match_operand:HI 2 "register_operand" "r"))]
  ""
  "bld	#0,%R2\;bst	%Z1,%Y0 ; i1"
  [(set_attr "cc" "clobber")
   (set_attr "length" "4")])
d1890 4
a1893 3
	(zero_extract:HI (match_operand:HI 1 "bit_operand" "")
			 (match_operand:HI 2 "general_operand" "")
			 (match_operand:HI 3 "general_operand" "")))]
a1896 1
  /* We only have single bit bitfield instructions.  */
d1900 14
a1913 3
  /* For now, we don't allow memory operands.  */
  if (GET_CODE (operands[1]) == MEM)
    FAIL;
d1916 3
a1918 1
;; BAND, BOR, and BXOR patterns
d1920 28
a1947 7
(define_insn ""
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 4 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "n"))
	    (match_operand:HI 3 "bit_operand" "0")]))]
d1949 32
a1980 3
  "bld	%Z2,%Y1\;%b4	#0,%R0\;bst	#0,%R0; bl1"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])
d1982 2
a1983 13
(define_insn ""
  [(set (match_operand:HI 0 "bit_operand" "=Ur")
	(match_operator:HI 5 "bit_operator"
	   [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 2 "immediate_operand" "n"))
	    (zero_extract:HI (match_operand:HI 3 "register_operand" "r")
			     (const_int 1)
			     (match_operand:HI 4 "immediate_operand" "n"))]))]
  ""
  "bld	%Z2,%Y1\;%b5	%Z4,%Y3\;bst	#0,%R0; bl3"
  [(set_attr "cc" "clobber")
   (set_attr "length" "6")])
a1984 1

d1993 1
a1993 1
	(mem:QI (plus:HI (match_operand:HI 1 "register_operand" "r")
d2001 1
a2001 1
   (set_attr "cc" "set_znv")])
d2004 1
a2004 1
  [(set (mem:QI (plus:HI (match_operand:HI 1 "register_operand" "r")
d2013 1
a2013 1
   (set_attr "cc" "set_znv")])
d2024 1
a2024 1
   (set_attr "cc" "set_znv")])
d2033 1
a2033 1
   (set_attr "cc" "set_znv")])
d2045 1
a2045 1
   (set_attr "cc" "set_znv")])
d2055 133
a2187 1
   (set_attr "cc" "set_znv")])
d2189 32
@

