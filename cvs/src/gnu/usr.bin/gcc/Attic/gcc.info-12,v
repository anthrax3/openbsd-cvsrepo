head	1.2;
access;
symbols
	FSF_2_8_1:1.1.1.3
	FSF_2_8_0:1.1.1.2
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	95.12.21.01.16.27;	author niklas;	state dead;
branches;
next	1.1;

1.1
date	95.12.20.01.02.38;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.02.38;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.11.24;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.03.08.18.06.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@First cut at making a minimal intrusive munge of gcc to fit in a BSD
framework.  This means, provide a Makefile.bsd-wrapper.  Remove
intermediate files from the source dir.  Build them in the obj-dir.
Add some Makefile hooks so we can tune the std Makefile for our
purpose but still have it behave normal for out-of-tree
configurations.  Only i386 is supported for now.  The other archs will
follow soon.   This checkin requires an existing makeinfo and a yacc
that accepts -o.
@
text
@This is Info file gcc.info, produced by Makeinfo-1.63 from the input
file gcc.texi.

   This file documents the use and the internals of the GNU compiler.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.


File: gcc.info,  Node: Temporaries,  Prev: Static Definitions,  Up: C++ Misunderstandings

Temporaries May Vanish Before You Expect
----------------------------------------

   It is dangerous to use pointers or references to *portions* of a
temporary object.  The compiler may very well delete the object before
you expect it to, leaving a pointer to garbage.  The most common place
where this problem crops up is in classes like the libg++ `String'
class, that define a conversion function to type `char *' or `const
char *'.  However, any class that returns a pointer to some internal
structure is potentially subject to this problem.

   For example, a program may use a function `strfunc' that returns
`String' objects, and another function `charfunc' that operates on
pointers to `char':

     String strfunc ();
     void charfunc (const char *);

In this situation, it may seem natural to write
`charfunc (strfunc ());' based on the knowledge that class `String' has
an explicit conversion to `char' pointers.  However, what really
happens is akin to `charfunc (strfunc ().convert ());', where the
`convert' method is a function to do the same data conversion normally
performed by a cast.  Since the last use of the temporary `String'
object is the call to the conversion function, the compiler may delete
that object before actually calling `charfunc'.  The compiler has no
way of knowing that deleting the `String' object will invalidate the
pointer.  The pointer then points to garbage, so that by the time
`charfunc' is called, it gets an invalid argument.

   Code like this may run successfully under some other compilers,
especially those that delete temporaries relatively late.  However, the
GNU C++ behavior is also standard-conforming, so if your program depends
on late destruction of temporaries it is not portable.

   If you think this is surprising, you should be aware that the ANSI
C++ committee continues to debate the lifetime-of-temporaries problem.

   For now, at least, the safe way to write such code is to give the
temporary a name, which forces it to remain until the end of the scope
of the name.  For example:

     String& tmp = strfunc ();
     charfunc (tmp);


File: gcc.info,  Node: Protoize Caveats,  Next: Non-bugs,  Prev: C++ Misunderstandings,  Up: Trouble

Caveats of using `protoize'
===========================

   The conversion programs `protoize' and `unprotoize' can sometimes
change a source file in a way that won't work unless you rearrange it.

   * `protoize' can insert references to a type name or type tag before
     the definition, or in a file where they are not defined.

     If this happens, compiler error messages should show you where the
     new references are, so fixing the file by hand is straightforward.

   * There are some C constructs which `protoize' cannot figure out.
     For example, it can't determine argument types for declaring a
     pointer-to-function variable; this you must do by hand.  `protoize'
     inserts a comment containing `???' each time it finds such a
     variable; so you can find all such variables by searching for this
     string.  ANSI C does not require declaring the argument types of
     pointer-to-function types.

   * Using `unprotoize' can easily introduce bugs.  If the program
     relied on prototypes to bring about conversion of arguments, these
     conversions will not take place in the program without prototypes.
     One case in which you can be sure `unprotoize' is safe is when you
     are removing prototypes that were made with `protoize'; if the
     program worked before without any prototypes, it will work again
     without them.

     You can find all the places where this problem might occur by
     compiling the program with the `-Wconversion' option.  It prints a
     warning whenever an argument is converted.

   * Both conversion programs can be confused if there are macro calls
     in and around the text to be converted.  In other words, the
     standard syntax for a declaration or definition must not result
     from expanding a macro.  This problem is inherent in the design of
     C and cannot be fixed.  If only a few functions have confusing
     macro calls, you can easily convert them manually.

   * `protoize' cannot get the argument types for a function whose
     definition was not actually compiled due to preprocessing
     conditionals.  When this happens, `protoize' changes nothing in
     regard to such a function.  `protoize' tries to detect such
     instances and warn about them.

     You can generally work around this problem by using `protoize' step
     by step, each time specifying a different set of `-D' options for
     compilation, until all of the functions have been converted.
     There is no automatic way to verify that you have got them all,
     however.

   * Confusion may result if there is an occasion to convert a function
     declaration or definition in a region of source code where there
     is more than one formal parameter list present.  Thus, attempts to
     convert code containing multiple (conditionally compiled) versions
     of a single function header (in the same vicinity) may not produce
     the desired (or expected) results.

     If you plan on converting source files which contain such code, it
     is recommended that you first make sure that each conditionally
     compiled region of source code which contains an alternative
     function header also contains at least one additional follower
     token (past the final right parenthesis of the function header).
     This should circumvent the problem.

   * `unprotoize' can become confused when trying to convert a function
     definition or declaration which contains a declaration for a
     pointer-to-function formal argument which has the same name as the
     function being defined or declared.  We recommand you avoid such
     choices of formal parameter names.

   * You might also want to correct some of the indentation by hand and
     break long lines.  (The conversion programs don't write lines
     longer than eighty characters in any case.)


File: gcc.info,  Node: Non-bugs,  Next: Warnings and Errors,  Prev: Protoize Caveats,  Up: Trouble

Certain Changes We Don't Want to Make
=====================================

   This section lists changes that people frequently request, but which
we do not make because we think GNU CC is better without them.

   * Checking the number and type of arguments to a function which has
     an old-fashioned definition and no prototype.

     Such a feature would work only occasionally--only for calls that
     appear in the same file as the called function, following the
     definition.  The only way to check all calls reliably is to add a
     prototype for the function.  But adding a prototype eliminates the
     motivation for this feature.  So the feature is not worthwhile.

   * Warning about using an expression whose type is signed as a shift
     count.

     Shift count operands are probably signed more often than unsigned.
     Warning about this would cause far more annoyance than good.

   * Warning about assigning a signed value to an unsigned variable.

     Such assignments must be very common; warning about them would
     cause more annoyance than good.

   * Warning about unreachable code.

     It's very common to have unreachable code in machine-generated
     programs.  For example, this happens normally in some files of GNU
     C itself.

   * Warning when a non-void function value is ignored.

     Coming as I do from a Lisp background, I balk at the idea that
     there is something dangerous about discarding a value.  There are
     functions that return values which some callers may find useful;
     it makes no sense to clutter the program with a cast to `void'
     whenever the value isn't useful.

   * Assuming (for optimization) that the address of an external symbol
     is never zero.

     This assumption is false on certain systems when `#pragma weak' is
     used.

   * Making `-fshort-enums' the default.

     This would cause storage layout to be incompatible with most other
     C compilers.  And it doesn't seem very important, given that you
     can get the same result in other ways.  The case where it matters
     most is when the enumeration-valued object is inside a structure,
     and in that case you can specify a field width explicitly.

   * Making bitfields unsigned by default on particular machines where
     "the ABI standard" says to do so.

     The ANSI C standard leaves it up to the implementation whether a
     bitfield declared plain `int' is signed or not.  This in effect
     creates two alternative dialects of C.

     The GNU C compiler supports both dialects; you can specify the
     signed dialect with `-fsigned-bitfields' and the unsigned dialect
     with `-funsigned-bitfields'.  However, this leaves open the
     question of which dialect to use by default.

     Currently, the preferred dialect makes plain bitfields signed,
     because this is simplest.  Since `int' is the same as `signed int'
     in every other context, it is cleanest for them to be the same in
     bitfields as well.

     Some computer manufacturers have published Application Binary
     Interface standards which specify that plain bitfields should be
     unsigned.  It is a mistake, however, to say anything about this
     issue in an ABI.  This is because the handling of plain bitfields
     distinguishes two dialects of C.  Both dialects are meaningful on
     every type of machine.  Whether a particular object file was
     compiled using signed bitfields or unsigned is of no concern to
     other object files, even if they access the same bitfields in the
     same data structures.

     A given program is written in one or the other of these two
     dialects.  The program stands a chance to work on most any machine
     if it is compiled with the proper dialect.  It is unlikely to work
     at all if compiled with the wrong dialect.

     Many users appreciate the GNU C compiler because it provides an
     environment that is uniform across machines.  These users would be
     inconvenienced if the compiler treated plain bitfields differently
     on certain machines.

     Occasionally users write programs intended only for a particular
     machine type.  On these occasions, the users would benefit if the
     GNU C compiler were to support by default the same dialect as the
     other compilers on that machine.  But such applications are rare.
     And users writing a program to run on more than one type of
     machine cannot possibly benefit from this kind of compatibility.

     This is why GNU CC does and will treat plain bitfields in the same
     fashion on all types of machines (by default).

     There are some arguments for making bitfields unsigned by default
     on all machines.  If, for example, this becomes a universal de
     facto standard, it would make sense for GNU CC to go along with
     it.  This is something to be considered in the future.

     (Of course, users strongly concerned about portability should
     indicate explicitly in each bitfield whether it is signed or not.
     In this way, they write programs which have the same meaning in
     both C dialects.)

   * Undefining `__STDC__' when `-ansi' is not used.

     Currently, GNU CC defines `__STDC__' as long as you don't use
     `-traditional'.  This provides good results in practice.

     Programmers normally use conditionals on `__STDC__' to ask whether
     it is safe to use certain features of ANSI C, such as function
     prototypes or ANSI token concatenation.  Since plain `gcc' supports
     all the features of ANSI C, the correct answer to these questions
     is "yes".

     Some users try to use `__STDC__' to check for the availability of
     certain library facilities.  This is actually incorrect usage in
     an ANSI C program, because the ANSI C standard says that a
     conforming freestanding implementation should define `__STDC__'
     even though it does not have the library facilities.  `gcc -ansi
     -pedantic' is a conforming freestanding implementation, and it is
     therefore required to define `__STDC__', even though it does not
     come with an ANSI C library.

     Sometimes people say that defining `__STDC__' in a compiler that
     does not completely conform to the ANSI C standard somehow
     violates the standard.  This is illogical.  The standard is a
     standard for compilers that claim to support ANSI C, such as `gcc
     -ansi'--not for other compilers such as plain `gcc'.  Whatever the
     ANSI C standard says is relevant to the design of plain `gcc'
     without `-ansi' only for pragmatic reasons, not as a requirement.

   * Undefining `__STDC__' in C++.

     Programs written to compile with C++-to-C translators get the
     value of `__STDC__' that goes with the C compiler that is
     subsequently used.  These programs must test `__STDC__' to
     determine what kind of C preprocessor that compiler uses: whether
     they should concatenate tokens in the ANSI C fashion or in the
     traditional fashion.

     These programs work properly with GNU C++ if `__STDC__' is defined.
     They would not work otherwise.

     In addition, many header files are written to provide prototypes
     in ANSI C but not in traditional C.  Many of these header files
     can work without change in C++ provided `__STDC__' is defined.  If
     `__STDC__' is not defined, they will all fail, and will all need
     to be changed to test explicitly for C++ as well.

   * Deleting "empty" loops.

     GNU CC does not delete "empty" loops because the most likely reason
     you would put one in a program is to have a delay.  Deleting them
     will not make real programs run any faster, so it would be
     pointless.

     It would be different if optimization of a nonempty loop could
     produce an empty one.  But this generally can't happen.

   * Making side effects happen in the same order as in some other
     compiler.

     It is never safe to depend on the order of evaluation of side
     effects.  For example, a function call like this may very well
     behave differently from one compiler to another:

          void func (int, int);
          
          int i = 2;
          func (i++, i++);

     There is no guarantee (in either the C or the C++ standard language
     definitions) that the increments will be evaluated in any
     particular order.  Either increment might happen first.  `func'
     might get the arguments `2, 3', or it might get `3, 2', or even
     `2, 2'.

   * Not allowing structures with volatile fields in registers.

     Strictly speaking, there is no prohibition in the ANSI C standard
     against allowing structures with volatile fields in registers, but
     it does not seem to make any sense and is probably not what you
     wanted to do.  So the compiler will give an error message in this
     case.


File: gcc.info,  Node: Warnings and Errors,  Prev: Non-bugs,  Up: Trouble

Warning Messages and Error Messages
===================================

   The GNU compiler can produce two kinds of diagnostics: errors and
warnings.  Each kind has a different purpose:

     *Errors* report problems that make it impossible to compile your
     program.  GNU CC reports errors with the source file name and line
     number where the problem is apparent.

     *Warnings* report other unusual conditions in your code that *may*
     indicate a problem, although compilation can (and does) proceed.
     Warning messages also report the source file name and line number,
     but include the text `warning:' to distinguish them from error
     messages.

   Warnings may indicate danger points where you should check to make
sure that your program really does what you intend; or the use of
obsolete features; or the use of nonstandard features of GNU C or C++.
Many warnings are issued only if you ask for them, with one of the `-W'
options (for instance, `-Wall' requests a variety of useful warnings).

   GNU CC always tries to compile your program if possible; it never
gratuitously rejects a program whose meaning is clear merely because
(for instance) it fails to conform to a standard.  In some cases,
however, the C and C++ standards specify that certain extensions are
forbidden, and a diagnostic *must* be issued by a conforming compiler.
The `-pedantic' option tells GNU CC to issue warnings in such cases;
`-pedantic-errors' says to make them errors instead.  This does not
mean that *all* non-ANSI constructs get warnings or errors.

   *Note Options to Request or Suppress Warnings: Warning Options, for
more detail on these and related command-line options.


File: gcc.info,  Node: Bugs,  Next: Service,  Prev: Trouble,  Up: Top

Reporting Bugs
**************

   Your bug reports play an essential role in making GNU CC reliable.

   When you encounter a problem, the first thing to do is to see if it
is already known.  *Note Trouble::.  If it isn't known, then you should
report the problem.

   Reporting a bug may help you by bringing a solution to your problem,
or it may not.  (If it does not, look in the service directory; see
*Note Service::.)  In any case, the principal function of a bug report
is to help the entire community by making the next version of GNU CC
work better.  Bug reports are your contribution to the maintenance of
GNU CC.

   Since the maintainers are very overloaded, we cannot respond to every
bug report.  However, if the bug has not been fixed, we are likely to
send you a patch and ask you to tell us whether it works.

   In order for a bug report to serve its purpose, you must include the
information that makes for fixing the bug.

* Menu:

* Criteria:  Bug Criteria.   Have you really found a bug?
* Where: Bug Lists.	     Where to send your bug report.
* Reporting: Bug Reporting.  How to report a bug effectively.
* Patches: Sending Patches.  How to send a patch for GNU CC.
* Known: Trouble.            Known problems.
* Help: Service.             Where to ask for help.


File: gcc.info,  Node: Bug Criteria,  Next: Bug Lists,  Up: Bugs

Have You Found a Bug?
=====================

   If you are not sure whether you have found a bug, here are some
guidelines:

   * If the compiler gets a fatal signal, for any input whatever, that
     is a compiler bug.  Reliable compilers never crash.

   * If the compiler produces invalid assembly code, for any input
     whatever (except an `asm' statement), that is a compiler bug,
     unless the compiler reports errors (not just warnings) which would
     ordinarily prevent the assembler from being run.

   * If the compiler produces valid assembly code that does not
     correctly execute the input source code, that is a compiler bug.

     However, you must double-check to make sure, because you may have
     run into an incompatibility between GNU C and traditional C (*note
     Incompatibilities::.).  These incompatibilities might be considered
     bugs, but they are inescapable consequences of valuable features.

     Or you may have a program whose behavior is undefined, which
     happened by chance to give the desired results with another C or
     C++ compiler.

     For example, in many nonoptimizing compilers, you can write `x;'
     at the end of a function instead of `return x;', with the same
     results.  But the value of the function is undefined if `return'
     is omitted; it is not a bug when GNU CC produces different results.

     Problems often result from expressions with two increment
     operators, as in `f (*p++, *p++)'.  Your previous compiler might
     have interpreted that expression the way you intended; GNU CC might
     interpret it another way.  Neither compiler is wrong.  The bug is
     in your code.

     After you have localized the error to a single source line, it
     should be easy to check for these things.  If your program is
     correct and well defined, you have found a compiler bug.

   * If the compiler produces an error message for valid input, that is
     a compiler bug.

   * If the compiler does not produce an error message for invalid
     input, that is a compiler bug.  However, you should note that your
     idea of "invalid input" might be my idea of "an extension" or
     "support for traditional practice".

   * If you are an experienced user of C or C++ compilers, your
     suggestions for improvement of GNU CC or GNU C++ are welcome in
     any case.


File: gcc.info,  Node: Bug Lists,  Next: Bug Reporting,  Prev: Bug Criteria,  Up: Bugs

Where to Report Bugs
====================

   Send bug reports for GNU C to `bug-gcc@@prep.ai.mit.edu'.

   Send bug reports for GNU C++ to `bug-g++@@prep.ai.mit.edu'.  If your
bug involves the C++ class library libg++, send mail to
`bug-lib-g++@@prep.ai.mit.edu'.  If you're not sure, you can send the
bug report to both lists.

   *Do not send bug reports to `help-gcc@@prep.ai.mit.edu' or to the
newsgroup `gnu.gcc.help'.* Most users of GNU CC do not want to receive
bug reports.  Those that do, have asked to be on `bug-gcc' and/or
`bug-g++'.

   The mailing lists `bug-gcc' and `bug-g++' both have newsgroups which
serve as repeaters: `gnu.gcc.bug' and `gnu.g++.bug'.  Each mailing list
and its newsgroup carry exactly the same messages.

   Often people think of posting bug reports to the newsgroup instead of
mailing them.  This appears to work, but it has one problem which can be
crucial: a newsgroup posting does not contain a mail path back to the
sender.  Thus, if maintainers need more information, they may be unable
to reach you.  For this reason, you should always send bug reports by
mail to the proper mailing list.

   As a last resort, send bug reports on paper to:

     GNU Compiler Bugs
     Free Software Foundation
     59 Temple Place - Suite 330
     Boston, MA 02111-1307, USA


File: gcc.info,  Node: Bug Reporting,  Next: Sending Patches,  Prev: Bug Lists,  Up: Bugs

How to Report Bugs
==================

   The fundamental principle of reporting bugs usefully is this:
*report all the facts*.  If you are not sure whether to state a fact or
leave it out, state it!

   Often people omit facts because they think they know what causes the
problem and they conclude that some details don't matter.  Thus, you
might assume that the name of the variable you use in an example does
not matter.  Well, probably it doesn't, but one cannot be sure.
Perhaps the bug is a stray memory reference which happens to fetch from
the location where that name is stored in memory; perhaps, if the name
were different, the contents of that location would fool the compiler
into doing the right thing despite the bug.  Play it safe and give a
specific, complete example.  That is the easiest thing for you to do,
and the most helpful.

   Keep in mind that the purpose of a bug report is to enable someone to
fix the bug if it is not known.  It isn't very important what happens if
the bug is already known.  Therefore, always write your bug reports on
the assumption that the bug is not known.

   Sometimes people give a few sketchy facts and ask, "Does this ring a
bell?"  This cannot help us fix a bug, so it is basically useless.  We
respond by asking for enough details to enable us to investigate.  You
might as well expedite matters by sending them to begin with.

   Try to make your bug report self-contained.  If we have to ask you
for more information, it is best if you include all the previous
information in your response, as well as the information that was
missing.

   Please report each bug in a separate message.  This makes it easier
for us to track which bugs have been fixed and to forward your bugs
reports to the appropriate maintainer.

   Do not compress and encode any part of your bug report using programs
such as `uuencode'.  If you do so it will slow down the processing of
your bug.  If you must submit multiple large files, use `shar', which
allows us to read your message without having to run any decompression
programs.

   To enable someone to investigate the bug, you should include all
these things:

   * The version of GNU CC.  You can get this by running it with the
     `-v' option.

     Without this, we won't know whether there is any point in looking
     for the bug in the current version of GNU CC.

   * A complete input file that will reproduce the bug.  If the bug is
     in the C preprocessor, send a source file and any header files
     that it requires.  If the bug is in the compiler proper (`cc1'),
     run your source file through the C preprocessor by doing `gcc -E
     SOURCEFILE > OUTFILE', then include the contents of OUTFILE in the
     bug report.  (When you do this, use the same `-I', `-D' or `-U'
     options that you used in actual compilation.)

     A single statement is not enough of an example.  In order to
     compile it, it must be embedded in a complete file of compiler
     input; and the bug might depend on the details of how this is done.

     Without a real example one can compile, all anyone can do about
     your bug report is wish you luck.  It would be futile to try to
     guess how to provoke the bug.  For example, bugs in register
     allocation and reloading frequently depend on every little detail
     of the function they happen in.

     Even if the input file that fails comes from a GNU program, you
     should still send the complete test case.  Don't ask the GNU CC
     maintainers to do the extra work of obtaining the program in
     question--they are all overworked as it is.  Also, the problem may
     depend on what is in the header files on your system; it is
     unreliable for the GNU CC maintainers to try the problem with the
     header files available to them.  By sending CPP output, you can
     eliminate this source of uncertainty and save us a certain
     percentage of wild goose chases.

   * The command arguments you gave GNU CC or GNU C++ to compile that
     example and observe the bug.  For example, did you use `-O'?  To
     guarantee you won't omit something important, list all the options.

     If we were to try to guess the arguments, we would probably guess
     wrong and then we would not encounter the bug.

   * The type of machine you are using, and the operating system name
     and version number.

   * The operands you gave to the `configure' command when you installed
     the compiler.

   * A complete list of any modifications you have made to the compiler
     source.  (We don't promise to investigate the bug unless it
     happens in an unmodified compiler.  But if you've made
     modifications and don't tell us, then you are sending us on a wild
     goose chase.)

     Be precise about these changes.  A description in English is not
     enough--send a context diff for them.

     Adding files of your own (such as a machine description for a
     machine we don't support) is a modification of the compiler source.

   * Details of any other deviations from the standard procedure for
     installing GNU CC.

   * A description of what behavior you observe that you believe is
     incorrect.  For example, "The compiler gets a fatal signal," or,
     "The assembler instruction at line 208 in the output is incorrect."

     Of course, if the bug is that the compiler gets a fatal signal,
     then one can't miss it.  But if the bug is incorrect output, the
     maintainer might not notice unless it is glaringly wrong.  None of
     us has time to study all the assembler code from a 50-line C
     program just on the chance that one instruction might be wrong.
     We need *you* to do this part!

     Even if the problem you experience is a fatal signal, you should
     still say so explicitly.  Suppose something strange is going on,
     such as, your copy of the compiler is out of synch, or you have
     encountered a bug in the C library on your system.  (This has
     happened!)  Your copy might crash and the copy here would not.  If
     you said to expect a crash, then when the compiler here fails to
     crash, we would know that the bug was not happening.  If you don't
     say to expect a crash, then we would not know whether the bug was
     happening.  We would not be able to draw any conclusion from our
     observations.

     If the problem is a diagnostic when compiling GNU CC with some
     other compiler, say whether it is a warning or an error.

     Often the observed symptom is incorrect output when your program
     is run.  Sad to say, this is not enough information unless the
     program is short and simple.  None of us has time to study a large
     program to figure out how it would work if compiled correctly,
     much less which line of it was compiled wrong.  So you will have
     to do that.  Tell us which source line it is, and what incorrect
     result happens when that line is executed.  A person who
     understands the program can find this as easily as finding a bug
     in the program itself.

   * If you send examples of assembler code output from GNU CC or GNU
     C++, please use `-g' when you make them.  The debugging information
     includes source line numbers which are essential for correlating
     the output with the input.

   * If you wish to mention something in the GNU CC source, refer to it
     by context, not by line number.

     The line numbers in the development sources don't match those in
     your sources.  Your line numbers would convey no useful
     information to the maintainers.

   * Additional information from a debugger might enable someone to
     find a problem on a machine which he does not have available.
     However, you need to think when you collect this information if
     you want it to have any chance of being useful.

     For example, many people send just a backtrace, but that is never
     useful by itself.  A simple backtrace with arguments conveys little
     about GNU CC because the compiler is largely data-driven; the same
     functions are called over and over for different RTL insns, doing
     different things depending on the details of the insn.

     Most of the arguments listed in the backtrace are useless because
     they are pointers to RTL list structure.  The numeric values of the
     pointers, which the debugger prints in the backtrace, have no
     significance whatever; all that matters is the contents of the
     objects they point to (and most of the contents are other such
     pointers).

     In addition, most compiler passes consist of one or more loops that
     scan the RTL insn sequence.  The most vital piece of information
     about such a loop--which insn it has reached--is usually in a
     local variable, not in an argument.

     What you need to provide in addition to a backtrace are the values
     of the local variables for several stack frames up.  When a local
     variable or an argument is an RTX, first print its value and then
     use the GDB command `pr' to print the RTL expression that it points
     to.  (If GDB doesn't run on your machine, use your debugger to call
     the function `debug_rtx' with the RTX as an argument.)  In
     general, whenever a variable is a pointer, its value is no use
     without the data it points to.

   Here are some things that are not necessary:

   * A description of the envelope of the bug.

     Often people who encounter a bug spend a lot of time investigating
     which changes to the input file will make the bug go away and which
     changes will not affect it.

     This is often time consuming and not very useful, because the way
     we will find the bug is by running a single example under the
     debugger with breakpoints, not by pure deduction from a series of
     examples.  You might as well save your time for something else.

     Of course, if you can find a simpler example to report *instead* of
     the original one, that is a convenience.  Errors in the output
     will be easier to spot, running under the debugger will take less
     time, etc.  Most GNU CC bugs involve just one function, so the
     most straightforward way to simplify an example is to delete all
     the function definitions except the one where the bug occurs.
     Those earlier in the file may be replaced by external declarations
     if the crucial function depends on them.  (Exception: inline
     functions may affect compilation of functions defined later in the
     file.)

     However, simplification is not vital; if you don't want to do this,
     report the bug anyway and send the entire test case you used.

   * In particular, some people insert conditionals `#ifdef BUG' around
     a statement which, if removed, makes the bug not happen.  These
     are just clutter; we won't pay any attention to them anyway.
     Besides, you should send us cpp output, and that can't have
     conditionals.

   * A patch for the bug.

     A patch for the bug is useful if it is a good one.  But don't omit
     the necessary information, such as the test case, on the
     assumption that a patch is all we need.  We might see problems
     with your patch and decide to fix the problem another way, or we
     might not understand it at all.

     Sometimes with a program as complicated as GNU CC it is very hard
     to construct an example that will make the program follow a
     certain path through the code.  If you don't send the example, we
     won't be able to construct one, so we won't be able to verify that
     the bug is fixed.

     And if we can't understand what bug you are trying to fix, or why
     your patch should be an improvement, we won't install it.  A test
     case will help us to understand.

     *Note Sending Patches::, for guidelines on how to make it easy for
     us to understand and install your patches.

   * A guess about what the bug is or what it depends on.

     Such guesses are usually wrong.  Even I can't guess right about
     such things without first using the debugger to find the facts.

   * A core dump file.

     We have no way of examining a core dump for your type of machine
     unless we have an identical system--and if we do have one, we
     should be able to reproduce the crash ourselves.


File: gcc.info,  Node: Sending Patches,  Prev: Bug Reporting,  Up: Bugs

Sending Patches for GNU CC
==========================

   If you would like to write bug fixes or improvements for the GNU C
compiler, that is very helpful.  Send suggested fixes to the bug report
mailing list, `bug-gcc@@prep.ai.mit.edu'.

   Please follow these guidelines so we can study your patches
efficiently.  If you don't follow these guidelines, your information
might still be useful, but using it will take extra work.  Maintaining
GNU C is a lot of work in the best of circumstances, and we can't keep
up unless you do your best to help.

   * Send an explanation with your changes of what problem they fix or
     what improvement they bring about.  For a bug fix, just include a
     copy of the bug report, and explain why the change fixes the bug.

     (Referring to a bug report is not as good as including it, because
     then we will have to look it up, and we have probably already
     deleted it if we've already fixed the bug.)

   * Always include a proper bug report for the problem you think you
     have fixed.  We need to convince ourselves that the change is
     right before installing it.  Even if it is right, we might have
     trouble judging it if we don't have a way to reproduce the problem.

   * Include all the comments that are appropriate to help people
     reading the source in the future understand why this change was
     needed.

   * Don't mix together changes made for different reasons.  Send them
     *individually*.

     If you make two changes for separate reasons, then we might not
     want to install them both.  We might want to install just one.  If
     you send them all jumbled together in a single set of diffs, we
     have to do extra work to disentangle them--to figure out which
     parts of the change serve which purpose.  If we don't have time
     for this, we might have to ignore your changes entirely.

     If you send each change as soon as you have written it, with its
     own explanation, then the two changes never get tangled up, and we
     can consider each one properly without any extra work to
     disentangle them.

     Ideally, each change you send should be impossible to subdivide
     into parts that we might want to consider separately, because each
     of its parts gets its motivation from the other parts.

   * Send each change as soon as that change is finished.  Sometimes
     people think they are helping us by accumulating many changes to
     send them all together.  As explained above, this is absolutely
     the worst thing you could do.

     Since you should send each change separately, you might as well
     send it right away.  That gives us the option of installing it
     immediately if it is important.

   * Use `diff -c' to make your diffs.  Diffs without context are hard
     for us to install reliably.  More than that, they make it hard for
     us to study the diffs to decide whether we want to install them.
     Unidiff format is better than contextless diffs, but not as easy
     to read as `-c' format.

     If you have GNU diff, use `diff -cp', which shows the name of the
     function that each change occurs in.

   * Write the change log entries for your changes.  We get lots of
     changes, and we don't have time to do all the change log writing
     ourselves.

     Read the `ChangeLog' file to see what sorts of information to put
     in, and to learn the style that we use.  The purpose of the change
     log is to show people where to find what was changed.  So you need
     to be specific about what functions you changed; in large
     functions, it's often helpful to indicate where within the
     function the change was.

     On the other hand, once you have shown people where to find the
     change, you need not explain its purpose.  Thus, if you add a new
     function, all you need to say about it is that it is new.  If you
     feel that the purpose needs explaining, it probably does--but the
     explanation will be much more useful if you put it in comments in
     the code.

     If you would like your name to appear in the header line for who
     made the change, send us the header line.

   * When you write the fix, keep in mind that we can't install a
     change that would break other systems.

     People often suggest fixing a problem by changing
     machine-independent files such as `toplev.c' to do something
     special that a particular system needs.  Sometimes it is totally
     obvious that such changes would break GNU CC for almost all users.
     We can't possibly make a change like that.  At best it might tell
     us how to write another patch that would solve the problem
     acceptably.

     Sometimes people send fixes that *might* be an improvement in
     general--but it is hard to be sure of this.  It's hard to install
     such changes because we have to study them very carefully.  Of
     course, a good explanation of the reasoning by which you concluded
     the change was correct can help convince us.

     The safest changes are changes to the configuration files for a
     particular machine.  These are safe because they can't create new
     bugs on other machines.

     Please help us keep up with the workload by designing the patch in
     a form that is good to install.


File: gcc.info,  Node: Service,  Next: VMS,  Prev: Bugs,  Up: Top

How To Get Help with GNU CC
***************************

   If you need help installing, using or changing GNU CC, there are two
ways to find it:

   * Send a message to a suitable network mailing list.  First try
     `bug-gcc@@prep.ai.mit.edu', and if that brings no response, try
     `help-gcc@@prep.ai.mit.edu'.

   * Look in the service directory for someone who might help you for a
     fee.  The service directory is found in the file named `SERVICE'
     in the GNU CC distribution.


File: gcc.info,  Node: VMS,  Next: Portability,  Prev: Service,  Up: Top

Using GNU CC on VMS
*******************

   Here is how to use GNU CC on VMS.

* Menu:

* Include Files and VMS::  Where the preprocessor looks for the include files.
* Global Declarations::    How to do globaldef, globalref and globalvalue with
                           GNU CC.
* VMS Misc::		   Misc information.


File: gcc.info,  Node: Include Files and VMS,  Next: Global Declarations,  Up: VMS

Include Files and VMS
=====================

   Due to the differences between the filesystems of Unix and VMS, GNU
CC attempts to translate file names in `#include' into names that VMS
will understand.  The basic strategy is to prepend a prefix to the
specification of the include file, convert the whole filename to a VMS
filename, and then try to open the file.  GNU CC tries various prefixes
one by one until one of them succeeds:

  1. The first prefix is the `GNU_CC_INCLUDE:' logical name: this is
     where GNU C header files are traditionally stored.  If you wish to
     store header files in non-standard locations, then you can assign
     the logical `GNU_CC_INCLUDE' to be a search list, where each
     element of the list is suitable for use with a rooted logical.

  2. The next prefix tried is `SYS$SYSROOT:[SYSLIB.]'.  This is where
     VAX-C header files are traditionally stored.

  3. If the include file specification by itself is a valid VMS
     filename, the preprocessor then uses this name with no prefix in
     an attempt to open the include file.

  4. If the file specification is not a valid VMS filename (i.e. does
     not contain a device or a directory specifier, and contains a `/'
     character), the preprocessor tries to convert it from Unix syntax
     to VMS syntax.

     Conversion works like this: the first directory name becomes a
     device, and the rest of the directories are converted into
     VMS-format directory names.  For example, the name `X11/foobar.h'
     is translated to `X11:[000000]foobar.h' or `X11:foobar.h',
     whichever one can be opened.  This strategy allows you to assign a
     logical name to point to the actual location of the header files.

  5. If none of these strategies succeeds, the `#include' fails.

   Include directives of the form:

     #include foobar

are a common source of incompatibility between VAX-C and GNU CC.  VAX-C
treats this much like a standard `#include <foobar.h>' directive.  That
is incompatible with the ANSI C behavior implemented by GNU CC: to
expand the name `foobar' as a macro.  Macro expansion should eventually
yield one of the two standard formats for `#include':

     #include "FILE"
     #include <FILE>

   If you have this problem, the best solution is to modify the source
to convert the `#include' directives to one of the two standard forms.
That will work with either compiler.  If you want a quick and dirty fix,
define the file names as macros with the proper expansion, like this:

     #define stdio <stdio.h>

This will work, as long as the name doesn't conflict with anything else
in the program.

   Another source of incompatibility is that VAX-C assumes that:

     #include "foobar"

is actually asking for the file `foobar.h'.  GNU CC does not make this
assumption, and instead takes what you ask for literally; it tries to
read the file `foobar'.  The best way to avoid this problem is to
always specify the desired file extension in your include directives.

   GNU CC for VMS is distributed with a set of include files that is
sufficient to compile most general purpose programs.  Even though the
GNU CC distribution does not contain header files to define constants
and structures for some VMS system-specific functions, there is no
reason why you cannot use GNU CC with any of these functions.  You first
may have to generate or create header files, either by using the public
domain utility `UNSDL' (which can be found on a DECUS tape), or by
extracting the relevant modules from one of the system macro libraries,
and using an editor to construct a C header file.

   A `#include' file name cannot contain a DECNET node name.  The
preprocessor reports an I/O error if you attempt to use a node name,
whether explicitly, or implicitly via a logical name.


File: gcc.info,  Node: Global Declarations,  Next: VMS Misc,  Prev: Include Files and VMS,  Up: VMS

Global Declarations and VMS
===========================

   GNU CC does not provide the `globalref', `globaldef' and
`globalvalue' keywords of VAX-C.  You can get the same effect with an
obscure feature of GAS, the GNU assembler.  (This requires GAS version
1.39 or later.)  The following macros allow you to use this feature in
a fairly natural way:

     #ifdef __GNUC__
     #define GLOBALREF(TYPE,NAME)                      \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME)
     #define GLOBALDEF(TYPE,NAME,VALUE)                \
       TYPE NAME                                       \
       asm ("_$$PsectAttributes_GLOBALSYMBOL$$" #NAME) \
         = VALUE
     #define GLOBALVALUEREF(TYPE,NAME)                 \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE)           \
       const TYPE NAME[1]                              \
       asm ("_$$PsectAttributes_GLOBALVALUE$$" #NAME)  \
         = {VALUE}
     #else
     #define GLOBALREF(TYPE,NAME) \
       globalref TYPE NAME
     #define GLOBALDEF(TYPE,NAME,VALUE) \
       globaldef TYPE NAME = VALUE
     #define GLOBALVALUEDEF(TYPE,NAME,VALUE) \
       globalvalue TYPE NAME = VALUE
     #define GLOBALVALUEREF(TYPE,NAME) \
       globalvalue TYPE NAME
     #endif

(The `_$$PsectAttributes_GLOBALSYMBOL' prefix at the start of the name
is removed by the assembler, after it has modified the attributes of
the symbol).  These macros are provided in the VMS binaries
distribution in a header file `GNU_HACKS.H'.  An example of the usage
is:

     GLOBALREF (int, ijk);
     GLOBALDEF (int, jkl, 0);

   The macros `GLOBALREF' and `GLOBALDEF' cannot be used
straightforwardly for arrays, since there is no way to insert the array
dimension into the declaration at the right place.  However, you can
declare an array with these macros if you first define a typedef for the
array type, like this:

     typedef int intvector[10];
     GLOBALREF (intvector, foo);

   Array and structure initializers will also break the macros; you can
define the initializer to be a macro of its own, or you can expand the
`GLOBALDEF' macro by hand.  You may find a case where you wish to use
the `GLOBALDEF' macro with a large array, but you are not interested in
explicitly initializing each element of the array.  In such cases you
can use an initializer like: `{0,}', which will initialize the entire
array to `0'.

   A shortcoming of this implementation is that a variable declared with
`GLOBALVALUEREF' or `GLOBALVALUEDEF' is always an array.  For example,
the declaration:

     GLOBALVALUEREF(int, ijk);

declares the variable `ijk' as an array of type `int [1]'.  This is
done because a globalvalue is actually a constant; its "value" is what
the linker would normally consider an address.  That is not how an
integer value works in C, but it is how an array works.  So treating
the symbol as an array name gives consistent results--with the
exception that the value seems to have the wrong type.  *Don't try to
access an element of the array.*  It doesn't have any elements.  The
array "address" may not be the address of actual storage.

   The fact that the symbol is an array may lead to warnings where the
variable is used.  Insert type casts to avoid the warnings.  Here is an
example; it takes advantage of the ANSI C feature allowing macros that
expand to use the same name as the macro itself.

     GLOBALVALUEREF (int, ss$_normal);
     GLOBALVALUEDEF (int, xyzzy,123);
     #ifdef __GNUC__
     #define ss$_normal ((int) ss$_normal)
     #define xyzzy ((int) xyzzy)
     #endif

   Don't use `globaldef' or `globalref' with a variable whose type is
an enumeration type; this is not implemented.  Instead, make the
variable an integer, and use a `globalvaluedef' for each of the
enumeration values.  An example of this would be:

     #ifdef __GNUC__
     GLOBALDEF (int, color, 0);
     GLOBALVALUEDEF (int, RED, 0);
     GLOBALVALUEDEF (int, BLUE, 1);
     GLOBALVALUEDEF (int, GREEN, 3);
     #else
     enum globaldef color {RED, BLUE, GREEN = 3};
     #endif

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d1 2
a2 2
This is Info file gcc.info, produced by Makeinfo version 1.68 from the
input file gcc.texi.
d9 2
a10 2
   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.
a32 474
File: gcc.info,  Node: External Bugs,  Next: Incompatibilities,  Prev: Interoperation,  Up: Trouble

Problems Compiling Certain Programs
===================================

   Certain programs have problems compiling.

   * Parse errors may occur compiling X11 on a Decstation running
     Ultrix 4.2 because of problems in DEC's versions of the X11 header
     files `X11/Xlib.h' and `X11/Xutil.h'.  People recommend adding
     `-I/usr/include/mit' to use the MIT versions of the header files,
     using the `-traditional' switch to turn off ANSI C, or fixing the
     header files by adding this:

          #ifdef __STDC__
          #define NeedFunctionPrototypes 0
          #endif

   * If you have trouble compiling Perl on a SunOS 4 system, it may be
     because Perl specifies `-I/usr/ucbinclude'.  This accesses the
     unfixed header files.  Perl specifies the options

          -traditional -Dvolatile=__volatile__
          -I/usr/include/sun -I/usr/ucbinclude
          -fpcc-struct-return

     most of which are unnecessary with GCC 2.4.5 and newer versions.
     You can make a properly working Perl by setting `ccflags' to
     `-fwritable-strings' (implied by the `-traditional' in the
     original options) and `cppflags' to empty in `config.sh', then
     typing `./doSH; make depend; make'.

   * On various 386 Unix systems derived from System V, including SCO,
     ISC, and ESIX, you may get error messages about running out of
     virtual memory while compiling certain programs.

     You can prevent this problem by linking GNU CC with the GNU malloc
     (which thus replaces the malloc that comes with the system).  GNU
     malloc is available as a separate package, and also in the file
     `src/gmalloc.c' in the GNU Emacs 19 distribution.

     If you have installed GNU malloc as a separate library package,
     use this option when you relink GNU CC:

          MALLOC=/usr/local/lib/libgmalloc.a

     Alternatively, if you have compiled `gmalloc.c' from Emacs 19, copy
     the object file to `gmalloc.o' and use this option when you relink
     GNU CC:

          MALLOC=gmalloc.o


File: gcc.info,  Node: Incompatibilities,  Next: Fixed Headers,  Prev: External Bugs,  Up: Trouble

Incompatibilities of GNU CC
===========================

   There are several noteworthy incompatibilities between GNU C and most
existing (non-ANSI) versions of C.  The `-traditional' option
eliminates many of these incompatibilities, *but not all*, by telling
GNU C to behave like the other C compilers.

   * GNU CC normally makes string constants read-only.  If several
     identical-looking string constants are used, GNU CC stores only one
     copy of the string.

     One consequence is that you cannot call `mktemp' with a string
     constant argument.  The function `mktemp' always alters the string
     its argument points to.

     Another consequence is that `sscanf' does not work on some systems
     when passed a string constant as its format control string or
     input.  This is because `sscanf' incorrectly tries to write into
     the string constant.  Likewise `fscanf' and `scanf'.

     The best solution to these problems is to change the program to use
     `char'-array variables with initialization strings for these
     purposes instead of string constants.  But if this is not possible,
     you can use the `-fwritable-strings' flag, which directs GNU CC to
     handle string constants the same way most C compilers do.
     `-traditional' also has this effect, among others.

   * `-2147483648' is positive.

     This is because 2147483648 cannot fit in the type `int', so
     (following the ANSI C rules) its data type is `unsigned long int'.
     Negating this value yields 2147483648 again.

   * GNU CC does not substitute macro arguments when they appear inside
     of string constants.  For example, the following macro in GNU CC

          #define foo(a) "a"

     will produce output `"a"' regardless of what the argument A is.

     The `-traditional' option directs GNU CC to handle such cases
     (among others) in the old-fashioned (non-ANSI) fashion.

   * When you use `setjmp' and `longjmp', the only automatic variables
     guaranteed to remain valid are those declared `volatile'.  This is
     a consequence of automatic register allocation.  Consider this
     function:

          jmp_buf j;
          
          foo ()
          {
            int a, b;
          
            a = fun1 ();
            if (setjmp (j))
              return a;
          
            a = fun2 ();
            /* `longjmp (j)' may occur in `fun3'. */
            return a + fun3 ();
          }

     Here `a' may or may not be restored to its first value when the
     `longjmp' occurs.  If `a' is allocated in a register, then its
     first value is restored; otherwise, it keeps the last value stored
     in it.

     If you use the `-W' option with the `-O' option, you will get a
     warning when GNU CC thinks such a problem might be possible.

     The `-traditional' option directs GNU C to put variables in the
     stack by default, rather than in registers, in functions that call
     `setjmp'.  This results in the behavior found in traditional C
     compilers.

   * Programs that use preprocessing directives in the middle of macro
     arguments do not work with GNU CC.  For example, a program like
     this will not work:

          foobar (
          #define luser
                  hack)

     ANSI C does not permit such a construct.  It would make sense to
     support it when `-traditional' is used, but it is too much work to
     implement.

   * Declarations of external variables and functions within a block
     apply only to the block containing the declaration.  In other
     words, they have the same scope as any other declaration in the
     same place.

     In some other C compilers, a `extern' declaration affects all the
     rest of the file even if it happens within a block.

     The `-traditional' option directs GNU C to treat all `extern'
     declarations as global, like traditional compilers.

   * In traditional C, you can combine `long', etc., with a typedef
     name, as shown here:

          typedef int foo;
          typedef long foo bar;

     In ANSI C, this is not allowed: `long' and other type modifiers
     require an explicit `int'.  Because this criterion is expressed by
     Bison grammar rules rather than C code, the `-traditional' flag
     cannot alter it.

   * PCC allows typedef names to be used as function parameters.  The
     difficulty described immediately above applies here too.

   * PCC allows whitespace in the middle of compound assignment
     operators such as `+='.  GNU CC, following the ANSI standard, does
     not allow this.  The difficulty described immediately above
     applies here too.

   * GNU CC complains about unterminated character constants inside of
     preprocessing conditionals that fail.  Some programs have English
     comments enclosed in conditionals that are guaranteed to fail; if
     these comments contain apostrophes, GNU CC will probably report an
     error.  For example, this code would produce an error:

          #if 0
          You can't expect this to work.
          #endif

     The best solution to such a problem is to put the text into an
     actual C comment delimited by `/*...*/'.  However, `-traditional'
     suppresses these error messages.

   * Many user programs contain the declaration `long time ();'.  In the
     past, the system header files on many systems did not actually
     declare `time', so it did not matter what type your program
     declared it to return.  But in systems with ANSI C headers, `time'
     is declared to return `time_t', and if that is not the same as
     `long', then `long time ();' is erroneous.

     The solution is to change your program to use `time_t' as the
     return type of `time'.

   * When compiling functions that return `float', PCC converts it to a
     double.  GNU CC actually returns a `float'.  If you are concerned
     with PCC compatibility, you should declare your functions to return
     `double'; you might as well say what you mean.

   * When compiling functions that return structures or unions, GNU CC
     output code normally uses a method different from that used on most
     versions of Unix.  As a result, code compiled with GNU CC cannot
     call a structure-returning function compiled with PCC, and vice
     versa.

     The method used by GNU CC is as follows: a structure or union
     which is 1, 2, 4 or 8 bytes long is returned like a scalar.  A
     structure or union with any other size is stored into an address
     supplied by the caller (usually in a special, fixed register, but
     on some machines it is passed on the stack).  The
     machine-description macros `STRUCT_VALUE' and
     `STRUCT_INCOMING_VALUE' tell GNU CC where to pass this address.

     By contrast, PCC on most target machines returns structures and
     unions of any size by copying the data into an area of static
     storage, and then returning the address of that storage as if it
     were a pointer value.  The caller must copy the data from that
     memory area to the place where the value is wanted.  GNU CC does
     not use this method because it is slower and nonreentrant.

     On some newer machines, PCC uses a reentrant convention for all
     structure and union returning.  GNU CC on most of these machines
     uses a compatible convention when returning structures and unions
     in memory, but still returns small structures and unions in
     registers.

     You can tell GNU CC to use a compatible convention for all
     structure and union returning with the option
     `-fpcc-struct-return'.

   * GNU C complains about program fragments such as `0x74ae-0x4000'
     which appear to be two hexadecimal constants separated by the minus
     operator.  Actually, this string is a single "preprocessing token".
     Each such token must correspond to one token in C.  Since this
     does not, GNU C prints an error message.  Although it may appear
     obvious that what is meant is an operator and two values, the ANSI
     C standard specifically requires that this be treated as erroneous.

     A "preprocessing token" is a "preprocessing number" if it begins
     with a digit and is followed by letters, underscores, digits,
     periods and `e+', `e-', `E+', or `E-' character sequences.

     To make the above program fragment valid, place whitespace in
     front of the minus sign.  This whitespace will end the
     preprocessing number.


File: gcc.info,  Node: Fixed Headers,  Next: Standard Libraries,  Prev: Incompatibilities,  Up: Trouble

Fixed Header Files
==================

   GNU CC needs to install corrected versions of some system header
files.  This is because most target systems have some header files that
won't work with GNU CC unless they are changed.  Some have bugs, some
are incompatible with ANSI C, and some depend on special features of
other compilers.

   Installing GNU CC automatically creates and installs the fixed header
files, by running a program called `fixincludes' (or for certain
targets an alternative such as `fixinc.svr4').  Normally, you don't
need to pay attention to this.  But there are cases where it doesn't do
the right thing automatically.

   * If you update the system's header files, such as by installing a
     new system version, the fixed header files of GNU CC are not
     automatically updated.  The easiest way to update them is to
     reinstall GNU CC.  (If you want to be clever, look in the makefile
     and you can find a shortcut.)

   * On some systems, in particular SunOS 4, header file directories
     contain machine-specific symbolic links in certain places.  This
     makes it possible to share most of the header files among hosts
     running the same version of SunOS 4 on different machine models.

     The programs that fix the header files do not understand this
     special way of using symbolic links; therefore, the directory of
     fixed header files is good only for the machine model used to
     build it.

     In SunOS 4, only programs that look inside the kernel will notice
     the difference between machine models.  Therefore, for most
     purposes, you need not be concerned about this.

     It is possible to make separate sets of fixed header files for the
     different machine models, and arrange a structure of symbolic
     links so as to use the proper set, but you'll have to do this by
     hand.

   * On Lynxos, GNU CC by default does not fix the header files.  This
     is because bugs in the shell cause the `fixincludes' script to
     fail.

     This means you will encounter problems due to bugs in the system
     header files.  It may be no comfort that they aren't GNU CC's
     fault, but it does mean that there's nothing for us to do about
     them.


File: gcc.info,  Node: Standard Libraries,  Next: Disappointments,  Prev: Fixed Headers,  Up: Trouble

Standard Libraries
==================

   GNU CC by itself attempts to be what the ISO/ANSI C standard calls a
"conforming freestanding implementation".  This means all ANSI C
language features are available, as well as the contents of `float.h',
`limits.h', `stdarg.h', and `stddef.h'.  The rest of the C library is
supplied by the vendor of the operating system.  If that C library
doesn't conform to the C standards, then your programs might get
warnings (especially when using `-Wall') that you don't expect.

   For example, the `sprintf' function on SunOS 4.1.3 returns `char *'
while the C standard says that `sprintf' returns an `int'.  The
`fixincludes' program could make the prototype for this function match
the Standard, but that would be wrong, since the function will still
return `char *'.

   If you need a Standard compliant library, then you need to find one,
as GNU CC does not provide one.  The GNU C library (called `glibc') has
been ported to a number of operating systems, and provides ANSI/ISO,
POSIX, BSD and SystemV compatibility.  You could also ask your operating
system vendor if newer libraries are available.


File: gcc.info,  Node: Disappointments,  Next: C++ Misunderstandings,  Prev: Standard Libraries,  Up: Trouble

Disappointments and Misunderstandings
=====================================

   These problems are perhaps regrettable, but we don't know any
practical way around them.

   * Certain local variables aren't recognized by debuggers when you
     compile with optimization.

     This occurs because sometimes GNU CC optimizes the variable out of
     existence.  There is no way to tell the debugger how to compute the
     value such a variable "would have had", and it is not clear that
     would be desirable anyway.  So GNU CC simply does not mention the
     eliminated variable when it writes debugging information.

     You have to expect a certain amount of disagreement between the
     executable and your source code, when you use optimization.

   * Users often think it is a bug when GNU CC reports an error for code
     like this:

          int foo (struct mumble *);
          
          struct mumble { ... };
          
          int foo (struct mumble *x)
          { ... }

     This code really is erroneous, because the scope of `struct
     mumble' in the prototype is limited to the argument list
     containing it.  It does not refer to the `struct mumble' defined
     with file scope immediately below--they are two unrelated types
     with similar names in different scopes.

     But in the definition of `foo', the file-scope type is used
     because that is available to be inherited.  Thus, the definition
     and the prototype do not match, and you get an error.

     This behavior may seem silly, but it's what the ANSI standard
     specifies.  It is easy enough for you to make your code work by
     moving the definition of `struct mumble' above the prototype.
     It's not worth being incompatible with ANSI C just to avoid an
     error for the example shown above.

   * Accesses to bitfields even in volatile objects works by accessing
     larger objects, such as a byte or a word.  You cannot rely on what
     size of object is accessed in order to read or write the bitfield;
     it may even vary for a given bitfield according to the precise
     usage.

     If you care about controlling the amount of memory that is
     accessed, use volatile but do not use bitfields.

   * GNU CC comes with shell scripts to fix certain known problems in
     system header files.  They install corrected copies of various
     header files in a special directory where only GNU CC will
     normally look for them.  The scripts adapt to various systems by
     searching all the system header files for the problem cases that
     we know about.

     If new system header files are installed, nothing automatically
     arranges to update the corrected header files.  You will have to
     reinstall GNU CC to fix the new header files.  More specifically,
     go to the build directory and delete the files `stmp-fixinc' and
     `stmp-headers', and the subdirectory `include'; then do `make
     install' again.

   * On 68000 and x86 systems, for instance, you can get paradoxical
     results if you test the precise values of floating point numbers.
     For example, you can find that a floating point value which is not
     a NaN is not equal to itself.  This results from the fact that the
     floating point registers hold a few more bits of precision than
     fit in a `double' in memory.  Compiled code moves values between
     memory and floating point registers at its convenience, and moving
     them into memory truncates them.

     You can partially avoid this problem by using the `-ffloat-store'
     option (*note Optimize Options::.).

   * On the MIPS, variable argument functions using `varargs.h' cannot
     have a floating point value for the first argument.  The reason
     for this is that in the absence of a prototype in scope, if the
     first argument is a floating point, it is passed in a floating
     point register, rather than an integer register.

     If the code is rewritten to use the ANSI standard `stdarg.h'
     method of variable arguments, and the prototype is in scope at the
     time of the call, everything will work fine.

   * On the H8/300 and H8/300H, variable argument functions must be
     implemented using the ANSI standard `stdarg.h' method of variable
     arguments.  Furthermore, calls to functions using `stdarg.h'
     variable arguments must have a prototype for the called function
     in scope at the time of the call.


File: gcc.info,  Node: C++ Misunderstandings,  Next: Protoize Caveats,  Prev: Disappointments,  Up: Trouble

Common Misunderstandings with GNU C++
=====================================

   C++ is a complex language and an evolving one, and its standard
definition (the ANSI C++ draft standard) is also evolving.  As a result,
your C++ compiler may occasionally surprise you, even when its behavior
is correct.  This section discusses some areas that frequently give
rise to questions of this sort.

* Menu:

* Static Definitions::  Static member declarations are not definitions
* Temporaries::         Temporaries may vanish before you expect


File: gcc.info,  Node: Static Definitions,  Next: Temporaries,  Up: C++ Misunderstandings

Declare *and* Define Static Members
-----------------------------------

   When a class has static data members, it is not enough to *declare*
the static member; you must also *define* it.  For example:

     class Foo
     {
       ...
       void method();
       static int bar;
     };

   This declaration only establishes that the class `Foo' has an `int'
named `Foo::bar', and a member function named `Foo::method'.  But you
still need to define *both* `method' and `bar' elsewhere.  According to
the draft ANSI standard, you must supply an initializer in one (and
only one) source file, such as:

     int Foo::bar = 0;

   Other C++ compilers may not correctly implement the standard
behavior.  As a result, when you switch to `g++' from one of these
compilers, you may discover that a program that appeared to work
correctly in fact does not conform to the standard: `g++' reports as
undefined symbols any static data members that lack definitions.


a299 8
     GNU CC normally defines `__STDC__' to be 1, and in addition
     defines `__STRICT_ANSI__' if you specify the `-ansi' option.  On
     some hosts, system include files use a different convention, where
     `__STDC__' is normally 0, but is 1 if the user specifies strict
     conformance to the C Standard.  GNU CC follows the host convention
     when processing system include files, but when processing user
     files it follows the usual GNU C convention.

d491 3
a493 3
bug involves the C++ class library libg++, send mail instead to the
address `bug-lib-g++@@prep.ai.mit.edu'.  If you're not sure, you can
send the bug report to both lists.
d517 593
@


1.1.1.3
log
@FSF gcc 2.8.1
@
text
@d1 1
a1 1
This is Info file gcc.info, produced by Makeinfo version 1.67 from the
@

