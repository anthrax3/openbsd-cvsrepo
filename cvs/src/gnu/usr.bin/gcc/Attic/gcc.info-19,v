head	1.2;
access;
symbols
	FSF_2_8_1:1.1.1.3
	FSF_2_8_0:1.1.1.2
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.2
date	95.12.21.01.16.36;	author niklas;	state dead;
branches;
next	1.1;

1.1
date	95.12.20.01.02.40;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.02.40;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.11.34;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.03.08.18.07.08;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@First cut at making a minimal intrusive munge of gcc to fit in a BSD
framework.  This means, provide a Makefile.bsd-wrapper.  Remove
intermediate files from the source dir.  Build them in the obj-dir.
Add some Makefile hooks so we can tune the std Makefile for our
purpose but still have it behave normal for out-of-tree
configurations.  Only i386 is supported for now.  The other archs will
follow soon.   This checkin requires an existing makeinfo and a yacc
that accepts -o.
@
text
@This is Info file gcc.info, produced by Makeinfo-1.63 from the input
file gcc.texi.

   This file documents the use and the internals of the GNU compiler.

   Published by the Free Software Foundation 59 Temple Place - Suite 330
Boston, MA 02111-1307 USA

   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License," "Funding for
Free Software," and "Protect Your Freedom--Fight `Look And Feel'" are
included exactly as in the original, and provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License," "Funding for Free Software," and "Protect Your Freedom--Fight
`Look And Feel'", and this permission notice, may be included in
translations approved by the Free Software Foundation instead of in the
original English.


File: gcc.info,  Node: Driver,  Next: Run-time Target,  Up: Target Macros

Controlling the Compilation Driver, `gcc'
=========================================

   You can control the compilation driver.

`SWITCH_TAKES_ARG (CHAR)'
     A C expression which determines whether the option `-CHAR' takes
     arguments.  The value should be the number of arguments that
     option takes-zero, for many options.

     By default, this macro is defined to handle the standard options
     properly.  You need not define it unless you wish to add additional
     options which take arguments.

`WORD_SWITCH_TAKES_ARG (NAME)'
     A C expression which determines whether the option `-NAME' takes
     arguments.  The value should be the number of arguments that
     option takes-zero, for many options.  This macro rather than
     `SWITCH_TAKES_ARG' is used for multi-character option names.

     By default, this macro is defined as
     `DEFAULT_WORD_SWITCH_TAKES_ARG', which handles the standard options
     properly.  You need not define `WORD_SWITCH_TAKES_ARG' unless you
     wish to add additional options which take arguments.  Any
     redefinition should call `DEFAULT_WORD_SWITCH_TAKES_ARG' and then
     check for additional options.

`SWITCHES_NEED_SPACES'
     A string-valued C expression which is nonempty if the linker needs
     a space between the `-L' or `-o' option and its argument.

     If this macro is not defined, the default value is 0.

`CPP_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to CPP.  It can also specify how to translate options you
     give to GNU CC into options for GNU CC to pass to the CPP.

     Do not define this macro if it does not need to do anything.

`NO_BUILTIN_SIZE_TYPE'
     If this macro is defined, the preprocessor will not define the
     builtin macro `__SIZE_TYPE__'.  The macro `__SIZE_TYPE__' must
     then be defined by `CPP_SPEC' instead.

     This should be defined if `SIZE_TYPE' depends on target dependent
     flags which are not accessible to the preprocessor.  Otherwise, it
     should not be defined.

`NO_BUILTIN_PTRDIFF_TYPE'
     If this macro is defined, the preprocessor will not define the
     builtin macro `__PTRDIFF_TYPE__'.  The macro `__PTRDIFF_TYPE__'
     must then be defined by `CPP_SPEC' instead.

     This should be defined if `PTRDIFF_TYPE' depends on target
     dependent flags which are not accessible to the preprocessor.
     Otherwise, it should not be defined.

`SIGNED_CHAR_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to CPP.  By default, this macro is defined to pass the option
     `-D__CHAR_UNSIGNED__' to CPP if `char' will be treated as
     `unsigned char' by `cc1'.

     Do not define this macro unless you need to override the default
     definition.

`CC1_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to `cc1'.  It can also specify how to translate options you
     give to GNU CC into options for GNU CC to pass to the `cc1'.

     Do not define this macro if it does not need to do anything.

`CC1PLUS_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to `cc1plus'.  It can also specify how to translate options
     you give to GNU CC into options for GNU CC to pass to the
     `cc1plus'.

     Do not define this macro if it does not need to do anything.

`ASM_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to the assembler.  It can also specify how to translate
     options you give to GNU CC into options for GNU CC to pass to the
     assembler.  See the file `sun3.h' for an example of this.

     Do not define this macro if it does not need to do anything.

`ASM_FINAL_SPEC'
     A C string constant that tells the GNU CC driver program how to
     run any programs which cleanup after the normal assembler.
     Normally, this is not needed.  See the file `mips.h' for an
     example of this.

     Do not define this macro if it does not need to do anything.

`LINK_SPEC'
     A C string constant that tells the GNU CC driver program options to
     pass to the linker.  It can also specify how to translate options
     you give to GNU CC into options for GNU CC to pass to the linker.

     Do not define this macro if it does not need to do anything.

`LIB_SPEC'
     Another C string constant used much like `LINK_SPEC'.  The
     difference between the two is that `LIB_SPEC' is used at the end
     of the command given to the linker.

     If this macro is not defined, a default is provided that loads the
     standard C library from the usual place.  See `gcc.c'.

`LIBGCC_SPEC'
     Another C string constant that tells the GNU CC driver program how
     and when to place a reference to `libgcc.a' into the linker
     command line.  This constant is placed both before and after the
     value of `LIB_SPEC'.

     If this macro is not defined, the GNU CC driver provides a default
     that passes the string `-lgcc' to the linker unless the `-shared'
     option is specified.

`STARTFILE_SPEC'
     Another C string constant used much like `LINK_SPEC'.  The
     difference between the two is that `STARTFILE_SPEC' is used at the
     very beginning of the command given to the linker.

     If this macro is not defined, a default is provided that loads the
     standard C startup file from the usual place.  See `gcc.c'.

`ENDFILE_SPEC'
     Another C string constant used much like `LINK_SPEC'.  The
     difference between the two is that `ENDFILE_SPEC' is used at the
     very end of the command given to the linker.

     Do not define this macro if it does not need to do anything.

`LINK_LIBGCC_SPECIAL'
     Define this macro if the driver program should find the library
     `libgcc.a' itself and should not pass `-L' options to the linker.
     If you do not define this macro, the driver program will pass the
     argument `-lgcc' to tell the linker to do the search and will pass
     `-L' options to it.

`LINK_LIBGCC_SPECIAL_1'
     Define this macro if the driver program should find the library
     `libgcc.a'.  If you do not define this macro, the driver program
     will pass the argument `-lgcc' to tell the linker to do the search.
     This macro is similar to `LINK_LIBGCC_SPECIAL', except that it does
     not affect `-L' options.

`MULTILIB_DEFAULTS'
     Define this macro as a C expression for the initializer of an
     array of string to tell the driver program which options are
     defaults for this target and thus do not need to be handled
     specially when using `MULTILIB_OPTIONS'.

     Do not define this macro if `MULTILIB_OPTIONS' is not defined in
     the target makefile fragment or if none of the options listed in
     `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.

`RELATIVE_PREFIX_NOT_LINKDIR'
     Define this macro to tell `gcc' that it should only translate a
     `-B' prefix into a `-L' linker option if the prefix indicates an
     absolute file name.

`STANDARD_EXEC_PREFIX'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/local/lib/gcc-lib/' as the default
     prefix to try when searching for the executable files of the
     compiler.

`MD_EXEC_PREFIX'
     If defined, this macro is an additional prefix to try after
     `STANDARD_EXEC_PREFIX'.  `MD_EXEC_PREFIX' is not searched when the
     `-b' option is used, or the compiler is built as a cross compiler.

`STANDARD_STARTFILE_PREFIX'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/local/lib/' as the default prefix to
     try when searching for startup files such as `crt0.o'.

`MD_STARTFILE_PREFIX'
     If defined, this macro supplies an additional prefix to try after
     the standard prefixes.  `MD_EXEC_PREFIX' is not searched when the
     `-b' option is used, or when the compiler is built as a cross
     compiler.

`MD_STARTFILE_PREFIX_1'
     If defined, this macro supplies yet another prefix to try after the
     standard prefixes.  It is not searched when the `-b' option is
     used, or when the compiler is built as a cross compiler.

`INIT_ENVIRONMENT'
     Define this macro as a C string constant if you with to set
     environment variables for programs called by the driver, such as
     the assembler and loader.  The driver passes the value of this
     macro to `putenv' to initialize the necessary environment
     variables.

`LOCAL_INCLUDE_DIR'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/local/include' as the default prefix
     to try when searching for local header files.  `LOCAL_INCLUDE_DIR'
     comes before `SYSTEM_INCLUDE_DIR' in the search order.

     Cross compilers do not use this macro and do not search either
     `/usr/local/include' or its replacement.

`SYSTEM_INCLUDE_DIR'
     Define this macro as a C string constant if you wish to specify a
     system-specific directory to search for header files before the
     standard directory.  `SYSTEM_INCLUDE_DIR' comes before
     `STANDARD_INCLUDE_DIR' in the search order.

     Cross compilers do not use this macro and do not search the
     directory specified.

`STANDARD_INCLUDE_DIR'
     Define this macro as a C string constant if you wish to override
     the standard choice of `/usr/include' as the default prefix to try
     when searching for header files.

     Cross compilers do not use this macro and do not search either
     `/usr/include' or its replacement.

`INCLUDE_DEFAULTS'
     Define this macro if you wish to override the entire default
     search path for include files.  The default search path includes
     `GCC_INCLUDE_DIR', `LOCAL_INCLUDE_DIR', `SYSTEM_INCLUDE_DIR',
     `GPLUSPLUS_INCLUDE_DIR', and `STANDARD_INCLUDE_DIR'.  In addition,
     `GPLUSPLUS_INCLUDE_DIR' and `GCC_INCLUDE_DIR' are defined
     automatically by `Makefile', and specify private search areas for
     GCC.  The directory `GPLUSPLUS_INCLUDE_DIR' is used only for C++
     programs.

     The definition should be an initializer for an array of structures.
     Each array element should have two elements: the directory name (a
     string constant) and a flag for C++-only directories.  Mark the
     end of the array with a null element.  For example, here is the
     definition used for VMS:

          #define INCLUDE_DEFAULTS \
          {                                       \
            { "GNU_GXX_INCLUDE:", 1},             \
            { "GNU_CC_INCLUDE:", 0},              \
            { "SYS$SYSROOT:[SYSLIB.]", 0},        \
            { ".", 0},                            \
            { 0, 0}                               \
          }

   Here is the order of prefixes tried for exec files:

  1. Any prefixes specified by the user with `-B'.

  2. The environment variable `GCC_EXEC_PREFIX', if any.

  3. The directories specified by the environment variable
     `COMPILER_PATH'.

  4. The macro `STANDARD_EXEC_PREFIX'.

  5. `/usr/lib/gcc/'.

  6. The macro `MD_EXEC_PREFIX', if any.

   Here is the order of prefixes tried for startfiles:

  1. Any prefixes specified by the user with `-B'.

  2. The environment variable `GCC_EXEC_PREFIX', if any.

  3. The directories specified by the environment variable
     `LIBRARY_PATH' (native only, cross compilers do not use this).

  4. The macro `STANDARD_EXEC_PREFIX'.

  5. `/usr/lib/gcc/'.

  6. The macro `MD_EXEC_PREFIX', if any.

  7. The macro `MD_STARTFILE_PREFIX', if any.

  8. The macro `STANDARD_STARTFILE_PREFIX'.

  9. `/lib/'.

 10. `/usr/lib/'.


File: gcc.info,  Node: Run-time Target,  Next: Storage Layout,  Prev: Driver,  Up: Target Macros

Run-time Target Specification
=============================

   Here are run-time target specifications.

`CPP_PREDEFINES'
     Define this to be a string constant containing `-D' options to
     define the predefined macros that identify this machine and system.
     These macros will be predefined unless the `-ansi' option is
     specified.

     In addition, a parallel set of macros are predefined, whose names
     are made by appending `__' at the beginning and at the end.  These
     `__' macros are permitted by the ANSI standard, so they are
     predefined regardless of whether `-ansi' is specified.

     For example, on the Sun, one can use the following value:

          "-Dmc68000 -Dsun -Dunix"

     The result is to define the macros `__mc68000__', `__sun__' and
     `__unix__' unconditionally, and the macros `mc68000', `sun' and
     `unix' provided `-ansi' is not specified.

`extern int target_flags;'
     This declaration should be present.

`TARGET_...'
     This series of macros is to allow compiler command arguments to
     enable or disable the use of optional features of the target
     machine.  For example, one machine description serves both the
     68000 and the 68020; a command argument tells the compiler whether
     it should use 68020-only instructions or not.  This command
     argument works by means of a macro `TARGET_68020' that tests a bit
     in `target_flags'.

     Define a macro `TARGET_FEATURENAME' for each such option.  Its
     definition should test a bit in `target_flags'; for example:

          #define TARGET_68020 (target_flags & 1)

     One place where these macros are used is in the
     condition-expressions of instruction patterns.  Note how
     `TARGET_68020' appears frequently in the 68000 machine description
     file, `m68k.md'.  Another place they are used is in the
     definitions of the other macros in the `MACHINE.h' file.

`TARGET_SWITCHES'
     This macro defines names of command options to set and clear bits
     in `target_flags'.  Its definition is an initializer with a
     subgrouping for each command option.

     Each subgrouping contains a string constant, that defines the
     option name, and a number, which contains the bits to set in
     `target_flags'.  A negative number says to clear bits instead; the
     negative of the number is which bits to clear.  The actual option
     name is made by appending `-m' to the specified name.

     One of the subgroupings should have a null string.  The number in
     this grouping is the default value for `target_flags'.  Any target
     options act starting with that value.

     Here is an example which defines `-m68000' and `-m68020' with
     opposite meanings, and picks the latter as the default:

          #define TARGET_SWITCHES \
            { { "68020", 1},      \
              { "68000", -1},     \
              { "", 1}}

`TARGET_OPTIONS'
     This macro is similar to `TARGET_SWITCHES' but defines names of
     command options that have values.  Its definition is an
     initializer with a subgrouping for each command option.

     Each subgrouping contains a string constant, that defines the
     fixed part of the option name, and the address of a variable.  The
     variable, type `char *', is set to the variable part of the given
     option if the fixed part matches.  The actual option name is made
     by appending `-m' to the specified name.

     Here is an example which defines `-mshort-data-NUMBER'.  If the
     given option is `-mshort-data-512', the variable `m88k_short_data'
     will be set to the string `"512"'.

          extern char *m88k_short_data;
          #define TARGET_OPTIONS \
           { { "short-data-", &m88k_short_data } }

`TARGET_VERSION'
     This macro is a C statement to print on `stderr' a string
     describing the particular machine description choice.  Every
     machine description should define `TARGET_VERSION'.  For example:

          #ifdef MOTOROLA
          #define TARGET_VERSION \
            fprintf (stderr, " (68k, Motorola syntax)");
          #else
          #define TARGET_VERSION \
            fprintf (stderr, " (68k, MIT syntax)");
          #endif

`OVERRIDE_OPTIONS'
     Sometimes certain combinations of command options do not make
     sense on a particular target machine.  You can define a macro
     `OVERRIDE_OPTIONS' to take account of this.  This macro, if
     defined, is executed once just after all the command options have
     been parsed.

     Don't use this macro to turn on various extra optimizations for
     `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.

`OPTIMIZATION_OPTIONS (LEVEL)'
     Some machines may desire to change what optimizations are
     performed for various optimization levels.   This macro, if
     defined, is executed once just after the optimization level is
     determined and before the remainder of the command options have
     been parsed.  Values set in this macro are used as the default
     values for the other command line options.

     LEVEL is the optimization level specified; 2 if `-O2' is
     specified, 1 if `-O' is specified, and 0 if neither is specified.

     You should not use this macro to change options that are not
     machine-specific.  These should uniformly selected by the same
     optimization level on all supported machines.  Use this macro to
     enable machbine-specific optimizations.

     *Do not examine `write_symbols' in this macro!* The debugging
     options are not supposed to alter the generated code.

`CAN_DEBUG_WITHOUT_FP'
     Define this macro if debugging can be performed even without a
     frame pointer.  If this macro is defined, GNU CC will turn on the
     `-fomit-frame-pointer' option whenever `-O' is specified.


File: gcc.info,  Node: Storage Layout,  Next: Type Layout,  Prev: Run-time Target,  Up: Target Macros

Storage Layout
==============

   Note that the definitions of the macros in this table which are
sizes or alignments measured in bits do not need to be constant.  They
can be C expressions that refer to static variables, such as the
`target_flags'.  *Note Run-time Target::.

`BITS_BIG_ENDIAN'
     Define this macro to have the value 1 if the most significant bit
     in a byte has the lowest number; otherwise define it to have the
     value zero.  This means that bit-field instructions count from the
     most significant bit.  If the machine has no bit-field
     instructions, then this must still be defined, but it doesn't
     matter which value it is defined to.  This macro need not be a
     constant.

     This macro does not affect the way structure fields are packed into
     bytes or words; that is controlled by `BYTES_BIG_ENDIAN'.

`BYTES_BIG_ENDIAN'
     Define this macro to have the value 1 if the most significant byte
     in a word has the lowest number.  This macro need not be a
     constant.

`WORDS_BIG_ENDIAN'
     Define this macro to have the value 1 if, in a multiword object,
     the most significant word has the lowest number.  This applies to
     both memory locations and registers; GNU CC fundamentally assumes
     that the order of words in memory is the same as the order in
     registers.  This macro need not be a constant.

`LIBGCC2_WORDS_BIG_ENDIAN'
     Define this macro if WORDS_BIG_ENDIAN is not constant.  This must
     be a constant value with the same meaning as WORDS_BIG_ENDIAN,
     which will be used only when compiling libgcc2.c.  Typically the
     value will be set based on preprocessor defines.

`FLOAT_WORDS_BIG_ENDIAN'
     Define this macro to have the value 1 if `DFmode', `XFmode' or
     `TFmode' floating point numbers are stored in memory with the word
     containing the sign bit at the lowest address; otherwise define it
     to have the value 0.  This macro need not be a constant.

     You need not define this macro if the ordering is the same as for
     multi-word integers.

`BITS_PER_UNIT'
     Define this macro to be the number of bits in an addressable
     storage unit (byte); normally 8.

`BITS_PER_WORD'
     Number of bits in a word; normally 32.

`MAX_BITS_PER_WORD'
     Maximum number of bits in a word.  If this is undefined, the
     default is `BITS_PER_WORD'.  Otherwise, it is the constant value
     that is the largest value that `BITS_PER_WORD' can have at
     run-time.

`UNITS_PER_WORD'
     Number of storage units in a word; normally 4.

`MIN_UNITS_PER_WORD'
     Minimum number of units in a word.  If this is undefined, the
     default is `UNITS_PER_WORD'.  Otherwise, it is the constant value
     that is the smallest value that `UNITS_PER_WORD' can have at
     run-time.

`POINTER_SIZE'
     Width of a pointer, in bits.  You must specify a value no wider
     than the width of `Pmode'.  If it is not equal to the width of
     `Pmode', you must define `POINTERS_EXTEND_UNSIGNED'.

`POINTERS_EXTEND_UNSIGNED'
     A C expression whose value is nonzero if pointers that need to be
     extended from being `POINTER_SIZE' bits wide to `Pmode' are
     sign-extended and zero if they are zero-extended.

     You need not define this macro if the `POINTER_SIZE' is equal to
     the width of `Pmode'.

`PROMOTE_MODE (M, UNSIGNEDP, TYPE)'
     A macro to update M and UNSIGNEDP when an object whose type is
     TYPE and which has the specified mode and signedness is to be
     stored in a register.  This macro is only called when TYPE is a
     scalar type.

     On most RISC machines, which only have operations that operate on
     a full register, define this macro to set M to `word_mode' if M is
     an integer mode narrower than `BITS_PER_WORD'.  In most cases,
     only integer modes should be widened because wider-precision
     floating-point operations are usually more expensive than their
     narrower counterparts.

     For most machines, the macro definition does not change UNSIGNEDP.
     However, some machines, have instructions that preferentially
     handle either signed or unsigned quantities of certain modes.  For
     example, on the DEC Alpha, 32-bit loads from memory and 32-bit add
     instructions sign-extend the result to 64 bits.  On such machines,
     set UNSIGNEDP according to which kind of extension is more
     efficient.

     Do not define this macro if it would never modify M.

`PROMOTE_FUNCTION_ARGS'
     Define this macro if the promotion described by `PROMOTE_MODE'
     should also be done for outgoing function arguments.

`PROMOTE_FUNCTION_RETURN'
     Define this macro if the promotion described by `PROMOTE_MODE'
     should also be done for the return value of functions.

     If this macro is defined, `FUNCTION_VALUE' must perform the same
     promotions done by `PROMOTE_MODE'.

`PROMOTE_FOR_CALL_ONLY'
     Define this macro if the promotion described by `PROMOTE_MODE'
     should *only* be performed for outgoing function arguments or
     function return values, as specified by `PROMOTE_FUNCTION_ARGS'
     and `PROMOTE_FUNCTION_RETURN', respectively.

`PARM_BOUNDARY'
     Normal alignment required for function parameters on the stack, in
     bits.  All stack parameters receive at least this much alignment
     regardless of data type.  On most machines, this is the same as the
     size of an integer.

`STACK_BOUNDARY'
     Define this macro if you wish to preserve a certain alignment for
     the stack pointer.  The definition is a C expression for the
     desired alignment (measured in bits).

     If `PUSH_ROUNDING' is not defined, the stack will always be aligned
     to the specified boundary.  If `PUSH_ROUNDING' is defined and
     specifies a less strict alignment than `STACK_BOUNDARY', the stack
     may be momentarily unaligned while pushing arguments.

`FUNCTION_BOUNDARY'
     Alignment required for a function entry point, in bits.

`BIGGEST_ALIGNMENT'
     Biggest alignment that any data type can require on this machine,
     in bits.

`BIGGEST_FIELD_ALIGNMENT'
     Biggest alignment that any structure field can require on this
     machine, in bits.  If defined, this overrides `BIGGEST_ALIGNMENT'
     for structure fields only.

`MAX_OFILE_ALIGNMENT'
     Biggest alignment supported by the object file format of this
     machine.  Use this macro to limit the alignment which can be
     specified using the `__attribute__ ((aligned (N)))' construct.  If
     not defined, the default value is `BIGGEST_ALIGNMENT'.

`DATA_ALIGNMENT (TYPE, BASIC-ALIGN)'
     If defined, a C expression to compute the alignment for a static
     variable.  TYPE is the data type, and BASIC-ALIGN is the alignment
     that the object would ordinarily have.  The value of this macro is
     used instead of that alignment to align the object.

     If this macro is not defined, then BASIC-ALIGN is used.

     One use of this macro is to increase alignment of medium-size data
     to make it all fit in fewer cache lines.  Another is to cause
     character arrays to be word-aligned so that `strcpy' calls that
     copy constants to character arrays can be done inline.

`CONSTANT_ALIGNMENT (CONSTANT, BASIC-ALIGN)'
     If defined, a C expression to compute the alignment given to a
     constant that is being placed in memory.  CONSTANT is the constant
     and BASIC-ALIGN is the alignment that the object would ordinarily
     have.  The value of this macro is used instead of that alignment to
     align the object.

     If this macro is not defined, then BASIC-ALIGN is used.

     The typical use of this macro is to increase alignment for string
     constants to be word aligned so that `strcpy' calls that copy
     constants can be done inline.

`EMPTY_FIELD_BOUNDARY'
     Alignment in bits to be given to a structure bit field that
     follows an empty field such as `int : 0;'.

     Note that `PCC_BITFIELD_TYPE_MATTERS' also affects the alignment
     that results from an empty field.

`STRUCTURE_SIZE_BOUNDARY'
     Number of bits which any structure or union's size must be a
     multiple of.  Each structure or union's size is rounded up to a
     multiple of this.

     If you do not define this macro, the default is the same as
     `BITS_PER_UNIT'.

`STRICT_ALIGNMENT'
     Define this macro to be the value 1 if instructions will fail to
     work if given data not on the nominal alignment.  If instructions
     will merely go slower in that case, define this macro as 0.

`PCC_BITFIELD_TYPE_MATTERS'
     Define this if you wish to imitate the way many other C compilers
     handle alignment of bitfields and the structures that contain them.

     The behavior is that the type written for a bitfield (`int',
     `short', or other integer type) imposes an alignment for the
     entire structure, as if the structure really did contain an
     ordinary field of that type.  In addition, the bitfield is placed
     within the structure so that it would fit within such a field, not
     crossing a boundary for it.

     Thus, on most machines, a bitfield whose type is written as `int'
     would not cross a four-byte boundary, and would force four-byte
     alignment for the whole structure.  (The alignment used may not be
     four bytes; it is controlled by the other alignment parameters.)

     If the macro is defined, its definition should be a C expression;
     a nonzero value for the expression enables this behavior.

     Note that if this macro is not defined, or its value is zero, some
     bitfields may cross more than one alignment boundary.  The
     compiler can support such references if there are `insv', `extv',
     and `extzv' insns that can directly reference memory.

     The other known way of making bitfields work is to define
     `STRUCTURE_SIZE_BOUNDARY' as large as `BIGGEST_ALIGNMENT'.  Then
     every structure can be accessed with fullwords.

     Unless the machine has bitfield instructions or you define
     `STRUCTURE_SIZE_BOUNDARY' that way, you must define
     `PCC_BITFIELD_TYPE_MATTERS' to have a nonzero value.

     If your aim is to make GNU CC use the same conventions for laying
     out bitfields as are used by another compiler, here is how to
     investigate what the other compiler does.  Compile and run this
     program:

          struct foo1
          {
            char x;
            char :0;
            char y;
          };
          
          struct foo2
          {
            char x;
            int :0;
            char y;
          };
          
          main ()
          {
            printf ("Size of foo1 is %d\n",
                    sizeof (struct foo1));
            printf ("Size of foo2 is %d\n",
                    sizeof (struct foo2));
            exit (0);
          }

     If this prints 2 and 5, then the compiler's behavior is what you
     would get from `PCC_BITFIELD_TYPE_MATTERS'.

`BITFIELD_NBYTES_LIMITED'
     Like PCC_BITFIELD_TYPE_MATTERS except that its effect is limited to
     aligning a bitfield within the structure.

`ROUND_TYPE_SIZE (STRUCT, SIZE, ALIGN)'
     Define this macro as an expression for the overall size of a
     structure (given by STRUCT as a tree node) when the size computed
     from the fields is SIZE and the alignment is ALIGN.

     The default is to round SIZE up to a multiple of ALIGN.

`ROUND_TYPE_ALIGN (STRUCT, COMPUTED, SPECIFIED)'
     Define this macro as an expression for the alignment of a structure
     (given by STRUCT as a tree node) if the alignment computed in the
     usual way is COMPUTED and the alignment explicitly specified was
     SPECIFIED.

     The default is to use SPECIFIED if it is larger; otherwise, use
     the smaller of COMPUTED and `BIGGEST_ALIGNMENT'

`MAX_FIXED_MODE_SIZE'
     An integer expression for the size in bits of the largest integer
     machine mode that should actually be used.  All integer machine
     modes of this size or smaller can be used for structures and
     unions with the appropriate sizes.  If this macro is undefined,
     `GET_MODE_BITSIZE (DImode)' is assumed.

`CHECK_FLOAT_VALUE (MODE, VALUE, OVERFLOW)'
     A C statement to validate the value VALUE (of type `double') for
     mode MODE.  This means that you check whether VALUE fits within
     the possible range of values for mode MODE on this target machine.
     The mode MODE is always a mode of class `MODE_FLOAT'.  OVERFLOW
     is nonzero if the value is already known to be out of range.

     If VALUE is not valid or if OVERFLOW is nonzero, you should set
     OVERFLOW to 1 and then assign some valid value to VALUE.  Allowing
     an invalid value to go through the compiler can produce incorrect
     assembler code which may even cause Unix assemblers to crash.

     This macro need not be defined if there is no work for it to do.

`TARGET_FLOAT_FORMAT'
     A code distinguishing the floating point format of the target
     machine.  There are three defined values:

    `IEEE_FLOAT_FORMAT'
          This code indicates IEEE floating point.  It is the default;
          there is no need to define this macro when the format is IEEE.

    `VAX_FLOAT_FORMAT'
          This code indicates the peculiar format used on the Vax.

    `UNKNOWN_FLOAT_FORMAT'
          This code indicates any other format.

     The value of this macro is compared with `HOST_FLOAT_FORMAT'
     (*note Config::.) to determine whether the target machine has the
     same format as the host machine.  If any other formats are
     actually in use on supported machines, new codes should be defined
     for them.

     The ordering of the component words of floating point values
     stored in memory is controlled by `FLOAT_WORDS_BIG_ENDIAN' for the
     target machine and `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.


File: gcc.info,  Node: Type Layout,  Next: Registers,  Prev: Storage Layout,  Up: Target Macros

Layout of Source Language Data Types
====================================

   These macros define the sizes and other characteristics of the
standard basic data types used in programs being compiled.  Unlike the
macros in the previous section, these apply to specific features of C
and related languages, rather than to fundamental aspects of storage
layout.

`INT_TYPE_SIZE'
     A C expression for the size in bits of the type `int' on the
     target machine.  If you don't define this, the default is one word.

`MAX_INT_TYPE_SIZE'
     Maximum number for the size in bits of the type `int' on the target
     machine.  If this is undefined, the default is `INT_TYPE_SIZE'.
     Otherwise, it is the constant value that is the largest value that
     `INT_TYPE_SIZE' can have at run-time.  This is used in `cpp'.

`SHORT_TYPE_SIZE'
     A C expression for the size in bits of the type `short' on the
     target machine.  If you don't define this, the default is half a
     word.  (If this would be less than one storage unit, it is rounded
     up to one unit.)

`LONG_TYPE_SIZE'
     A C expression for the size in bits of the type `long' on the
     target machine.  If you don't define this, the default is one word.

`MAX_LONG_TYPE_SIZE'
     Maximum number for the size in bits of the type `long' on the
     target machine.  If this is undefined, the default is
     `LONG_TYPE_SIZE'.  Otherwise, it is the constant value that is the
     largest value that `LONG_TYPE_SIZE' can have at run-time.  This is
     used in `cpp'.

`LONG_LONG_TYPE_SIZE'
     A C expression for the size in bits of the type `long long' on the
     target machine.  If you don't define this, the default is two
     words.  If you want to support GNU Ada on your machine, the value
     of macro must be at least 64.

`CHAR_TYPE_SIZE'
     A C expression for the size in bits of the type `char' on the
     target machine.  If you don't define this, the default is one
     quarter of a word.  (If this would be less than one storage unit,
     it is rounded up to one unit.)

`MAX_CHAR_TYPE_SIZE'
     Maximum number for the size in bits of the type `char' on the
     target machine.  If this is undefined, the default is
     `CHAR_TYPE_SIZE'.  Otherwise, it is the constant value that is the
     largest value that `CHAR_TYPE_SIZE' can have at run-time.  This is
     used in `cpp'.

`FLOAT_TYPE_SIZE'
     A C expression for the size in bits of the type `float' on the
     target machine.  If you don't define this, the default is one word.

`DOUBLE_TYPE_SIZE'
     A C expression for the size in bits of the type `double' on the
     target machine.  If you don't define this, the default is two
     words.

`LONG_DOUBLE_TYPE_SIZE'
     A C expression for the size in bits of the type `long double' on
     the target machine.  If you don't define this, the default is two
     words.

`DEFAULT_SIGNED_CHAR'
     An expression whose value is 1 or 0, according to whether the type
     `char' should be signed or unsigned by default.  The user can
     always override this default with the options `-fsigned-char' and
     `-funsigned-char'.

`DEFAULT_SHORT_ENUMS'
     A C expression to determine whether to give an `enum' type only as
     many bytes as it takes to represent the range of possible values
     of that type.  A nonzero value means to do that; a zero value
     means all `enum' types should be allocated like `int'.

     If you don't define the macro, the default is 0.

`SIZE_TYPE'
     A C expression for a string describing the name of the data type
     to use for size values.  The typedef name `size_t' is defined
     using the contents of the string.

     The string can contain more than one keyword.  If so, separate
     them with spaces, and write first any length keyword, then
     `unsigned' if appropriate, and finally `int'.  The string must
     exactly match one of the data type names defined in the function
     `init_decl_processing' in the file `c-decl.c'.  You may not omit
     `int' or change the order--that would cause the compiler to crash
     on startup.

     If you don't define this macro, the default is `"long unsigned
     int"'.

`PTRDIFF_TYPE'
     A C expression for a string describing the name of the data type
     to use for the result of subtracting two pointers.  The typedef
     name `ptrdiff_t' is defined using the contents of the string.  See
     `SIZE_TYPE' above for more information.

     If you don't define this macro, the default is `"long int"'.

`WCHAR_TYPE'
     A C expression for a string describing the name of the data type
     to use for wide characters.  The typedef name `wchar_t' is defined
     using the contents of the string.  See `SIZE_TYPE' above for more
     information.

     If you don't define this macro, the default is `"int"'.

`WCHAR_TYPE_SIZE'
     A C expression for the size in bits of the data type for wide
     characters.  This is used in `cpp', which cannot make use of
     `WCHAR_TYPE'.

`MAX_WCHAR_TYPE_SIZE'
     Maximum number for the size in bits of the data type for wide
     characters.  If this is undefined, the default is
     `WCHAR_TYPE_SIZE'.  Otherwise, it is the constant value that is the
     largest value that `WCHAR_TYPE_SIZE' can have at run-time.  This is
     used in `cpp'.

`OBJC_INT_SELECTORS'
     Define this macro if the type of Objective C selectors should be
     `int'.

     If this macro is not defined, then selectors should have the type
     `struct objc_selector *'.

`OBJC_SELECTORS_WITHOUT_LABELS'
     Define this macro if the compiler can group all the selectors
     together into a vector and use just one label at the beginning of
     the vector.  Otherwise, the compiler must give each selector its
     own assembler label.

     On certain machines, it is important to have a separate label for
     each selector because this enables the linker to eliminate
     duplicate selectors.

`TARGET_BELL'
     A C constant expression for the integer value for escape sequence
     `\a'.

`TARGET_BS'
`TARGET_TAB'
`TARGET_NEWLINE'
     C constant expressions for the integer values for escape sequences
     `\b', `\t' and `\n'.

`TARGET_VT'
`TARGET_FF'
`TARGET_CR'
     C constant expressions for the integer values for escape sequences
     `\v', `\f' and `\r'.


File: gcc.info,  Node: Registers,  Next: Register Classes,  Prev: Type Layout,  Up: Target Macros

Register Usage
==============

   This section explains how to describe what registers the target
machine has, and how (in general) they can be used.

   The description of which registers a specific instruction can use is
done with register classes; see *Note Register Classes::.  For
information on using registers to access a stack frame, see *Note Frame
Registers::.  For passing values in registers, see *Note Register
Arguments::.  For returning values in registers, see *Note Scalar
Return::.

* Menu:

* Register Basics::		Number and kinds of registers.
* Allocation Order::		Order in which registers are allocated.
* Values in Registers::		What kinds of values each reg can hold.
* Leaf Functions::		Renumbering registers for leaf functions.
* Stack Registers::		Handling a register stack such as 80387.
* Obsolete Register Macros::	Macros formerly used for the 80387.


File: gcc.info,  Node: Register Basics,  Next: Allocation Order,  Up: Registers

Basic Characteristics of Registers
----------------------------------

   Registers have various characteristics.

`FIRST_PSEUDO_REGISTER'
     Number of hardware registers known to the compiler.  They receive
     numbers 0 through `FIRST_PSEUDO_REGISTER-1'; thus, the first
     pseudo register's number really is assigned the number
     `FIRST_PSEUDO_REGISTER'.

`FIXED_REGISTERS'
     An initializer that says which registers are used for fixed
     purposes all throughout the compiled code and are therefore not
     available for general allocation.  These would include the stack
     pointer, the frame pointer (except on machines where that can be
     used as a general register when no frame pointer is needed), the
     program counter on machines where that is considered one of the
     addressable registers, and any other numbered register with a
     standard use.

     This information is expressed as a sequence of numbers, separated
     by commas and surrounded by braces.  The Nth number is 1 if
     register N is fixed, 0 otherwise.

     The table initialized from this macro, and the table initialized by
     the following one, may be overridden at run time either
     automatically, by the actions of the macro
     `CONDITIONAL_REGISTER_USAGE', or by the user with the command
     options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.

`CALL_USED_REGISTERS'
     Like `FIXED_REGISTERS' but has 1 for each register that is
     clobbered (in general) by function calls as well as for fixed
     registers.  This macro therefore identifies the registers that are
     not available for general allocation of values that must live
     across function calls.

     If a register has 0 in `CALL_USED_REGISTERS', the compiler
     automatically saves it on function entry and restores it on
     function exit, if the register is used within the function.

`CONDITIONAL_REGISTER_USAGE'
     Zero or more C statements that may conditionally modify two
     variables `fixed_regs' and `call_used_regs' (both of type `char
     []') after they have been initialized from the two preceding
     macros.

     This is necessary in case the fixed or call-clobbered registers
     depend on target flags.

     You need not define this macro if it has no work to do.

     If the usage of an entire class of registers depends on the target
     flags, you may indicate this to GCC by using this macro to modify
     `fixed_regs' and `call_used_regs' to 1 for each of the registers
     in the classes which should not be used by GCC.  Also define the
     macro `REG_CLASS_FROM_LETTER' to return `NO_REGS' if it is called
     with a letter for a class that shouldn't be used.

     (However, if this class is not included in `GENERAL_REGS' and all
     of the insn patterns whose constraints permit this class are
     controlled by target switches, then GCC will automatically avoid
     using these registers when the target switches are opposed to
     them.)

`NON_SAVING_SETJMP'
     If this macro is defined and has a nonzero value, it means that
     `setjmp' and related functions fail to save the registers, or that
     `longjmp' fails to restore them.  To compensate, the compiler
     avoids putting variables in registers in functions that use
     `setjmp'.

`INCOMING_REGNO (OUT)'
     Define this macro if the target machine has register windows.
     This C expression returns the register number as seen by the
     called function corresponding to the register number OUT as seen
     by the calling function.  Return OUT if register number OUT is not
     an outbound register.

`OUTGOING_REGNO (IN)'
     Define this macro if the target machine has register windows.
     This C expression returns the register number as seen by the
     calling function corresponding to the register number IN as seen
     by the called function.  Return IN if register number IN is not an
     inbound register.


File: gcc.info,  Node: Allocation Order,  Next: Values in Registers,  Prev: Register Basics,  Up: Registers

Order of Allocation of Registers
--------------------------------

   Registers are allocated in order.

`REG_ALLOC_ORDER'
     If defined, an initializer for a vector of integers, containing the
     numbers of hard registers in the order in which GNU CC should
     prefer to use them (from most preferred to least).

     If this macro is not defined, registers are used lowest numbered
     first (all else being equal).

     One use of this macro is on machines where the highest numbered
     registers must always be saved and the save-multiple-registers
     instruction supports only sequences of consecutive registers.  On
     such machines, define `REG_ALLOC_ORDER' to be an initializer that
     lists the highest numbered allocatable register first.

`ORDER_REGS_FOR_LOCAL_ALLOC'
     A C statement (sans semicolon) to choose the order in which to
     allocate hard registers for pseudo-registers local to a basic
     block.

     Store the desired register order in the array `reg_alloc_order'.
     Element 0 should be the register to allocate first; element 1, the
     next register; and so on.

     The macro body should not assume anything about the contents of
     `reg_alloc_order' before execution of the macro.

     On most machines, it is not necessary to define this macro.


File: gcc.info,  Node: Values in Registers,  Next: Leaf Functions,  Prev: Allocation Order,  Up: Registers

How Values Fit in Registers
---------------------------

   This section discusses the macros that describe which kinds of values
(specifically, which machine modes) each register can hold, and how many
consecutive registers are needed for a given mode.

`HARD_REGNO_NREGS (REGNO, MODE)'
     A C expression for the number of consecutive hard registers,
     starting at register number REGNO, required to hold a value of mode
     MODE.

     On a machine where all registers are exactly one word, a suitable
     definition of this macro is

          #define HARD_REGNO_NREGS(REGNO, MODE)            \
             ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
              / UNITS_PER_WORD))

`HARD_REGNO_MODE_OK (REGNO, MODE)'
     A C expression that is nonzero if it is permissible to store a
     value of mode MODE in hard register number REGNO (or in several
     registers starting with that one).  For a machine where all
     registers are equivalent, a suitable definition is

          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1

     It is not necessary for this macro to check for the numbers of
     fixed registers, because the allocation mechanism considers them
     to be always occupied.

     On some machines, double-precision values must be kept in even/odd
     register pairs.  The way to implement that is to define this macro
     to reject odd register numbers for such modes.

     The minimum requirement for a mode to be OK in a register is that
     the `movMODE' instruction pattern support moves between the
     register and any other hard register for which the mode is OK; and
     that moving a value into the register and back out not alter it.

     Since the same instruction used to move `SImode' will work for all
     narrower integer modes, it is not necessary on any machine for
     `HARD_REGNO_MODE_OK' to distinguish between these modes, provided
     you define patterns `movhi', etc., to take advantage of this.  This
     is useful because of the interaction between `HARD_REGNO_MODE_OK'
     and `MODES_TIEABLE_P'; it is very desirable for all integer modes
     to be tieable.

     Many machines have special registers for floating point arithmetic.
     Often people assume that floating point machine modes are allowed
     only in floating point registers.  This is not true.  Any
     registers that can hold integers can safely *hold* a floating
     point machine mode, whether or not floating arithmetic can be done
     on it in those registers.  Integer move instructions can be used
     to move the values.

     On some machines, though, the converse is true: fixed-point machine
     modes may not go in floating registers.  This is true if the
     floating registers normalize any value stored in them, because
     storing a non-floating value there would garble it.  In this case,
     `HARD_REGNO_MODE_OK' should reject fixed-point machine modes in
     floating registers.  But if the floating registers do not
     automatically normalize, if you can store any bit pattern in one
     and retrieve it unchanged without a trap, then any machine mode
     may go in a floating register, so you can define this macro to say
     so.

     The primary significance of special floating registers is rather
     that they are the registers acceptable in floating point arithmetic
     instructions.  However, this is of no concern to
     `HARD_REGNO_MODE_OK'.  You handle it by writing the proper
     constraints for those instructions.

     On some machines, the floating registers are especially slow to
     access, so that it is better to store a value in a stack frame
     than in such a register if floating point arithmetic is not being
     done.  As long as the floating registers are not in class
     `GENERAL_REGS', they will not be used unless some pattern's
     constraint asks for one.

`MODES_TIEABLE_P (MODE1, MODE2)'
     A C expression that is nonzero if it is desirable to choose
     register allocation so as to avoid move instructions between a
     value of mode MODE1 and a value of mode MODE2.

     If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,
     MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,
     MODE2)' must be zero.

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d1 2
a2 2
This is Info file gcc.info, produced by Makeinfo version 1.68 from the
input file gcc.texi.
d9 2
a10 2
   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998
Free Software Foundation, Inc.
d33 1
a33 1
File: gcc.info,  Node: Peephole Definitions,  Next: Expander Definitions,  Prev: Insn Canonicalizations,  Up: Machine Desc
d35 2
a36 5
Machine-Specific Peephole Optimizers
====================================

   In addition to instruction patterns the `md' file may contain
definitions of machine-specific peephole optimizations.
d38 1
a38 157
   The combiner does not notice certain peephole optimizations when the
data flow in the program does not suggest that it should try them.  For
example, sometimes two consecutive insns related in purpose can be
combined even though the second one does not appear to use a register
computed in the first one.  A machine-specific peephole optimizer can
detect such opportunities.

   A definition looks like this:

     (define_peephole
       [INSN-PATTERN-1
        INSN-PATTERN-2
        ...]
       "CONDITION"
       "TEMPLATE"
       "OPTIONAL INSN-ATTRIBUTES")

The last string operand may be omitted if you are not using any
machine-specific information in this machine description.  If present,
it must obey the same rules as in a `define_insn'.

   In this skeleton, INSN-PATTERN-1 and so on are patterns to match
consecutive insns.  The optimization applies to a sequence of insns when
INSN-PATTERN-1 matches the first one, INSN-PATTERN-2 matches the next,
and so on.

   Each of the insns matched by a peephole must also match a
`define_insn'.  Peepholes are checked only at the last stage just
before code generation, and only optionally.  Therefore, any insn which
would match a peephole but no `define_insn' will cause a crash in code
generation in an unoptimized compilation, or at various optimization
stages.

   The operands of the insns are matched with `match_operands',
`match_operator', and `match_dup', as usual.  What is not usual is that
the operand numbers apply to all the insn patterns in the definition.
So, you can check for identical operands in two insns by using
`match_operand' in one insn and `match_dup' in the other.

   The operand constraints used in `match_operand' patterns do not have
any direct effect on the applicability of the peephole, but they will
be validated afterward, so make sure your constraints are general enough
to apply whenever the peephole matches.  If the peephole matches but
the constraints are not satisfied, the compiler will crash.

   It is safe to omit constraints in all the operands of the peephole;
or you can write constraints which serve as a double-check on the
criteria previously tested.

   Once a sequence of insns matches the patterns, the CONDITION is
checked.  This is a C expression which makes the final decision whether
to perform the optimization (we do so if the expression is nonzero).  If
CONDITION is omitted (in other words, the string is empty) then the
optimization is applied to every sequence of insns that matches the
patterns.

   The defined peephole optimizations are applied after register
allocation is complete.  Therefore, the peephole definition can check
which operands have ended up in which kinds of registers, just by
looking at the operands.

   The way to refer to the operands in CONDITION is to write
`operands[I]' for operand number I (as matched by `(match_operand I
...)').  Use the variable `insn' to refer to the last of the insns
being matched; use `prev_active_insn' to find the preceding insns.

   When optimizing computations with intermediate results, you can use
CONDITION to match only when the intermediate results are not used
elsewhere.  Use the C expression `dead_or_set_p (INSN, OP)', where INSN
is the insn in which you expect the value to be used for the last time
(from the value of `insn', together with use of `prev_nonnote_insn'),
and OP is the intermediate value (from `operands[I]').

   Applying the optimization means replacing the sequence of insns with
one new insn.  The TEMPLATE controls ultimate output of assembler code
for this combined insn.  It works exactly like the template of a
`define_insn'.  Operand numbers in this template are the same ones used
in matching the original sequence of insns.

   The result of a defined peephole optimizer does not need to match
any of the insn patterns in the machine description; it does not even
have an opportunity to match them.  The peephole optimizer definition
itself serves as the insn pattern to control how the insn is output.

   Defined peephole optimizers are run as assembler code is being
output, so the insns they produce are never combined or rearranged in
any way.

   Here is an example, taken from the 68000 machine description:

     (define_peephole
       [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))
        (set (match_operand:DF 0 "register_operand" "=f")
             (match_operand:DF 1 "register_operand" "ad"))]
       "FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])"
       "*
     {
       rtx xoperands[2];
       xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);
     #ifdef MOTOROLA
       output_asm_insn (\"move.l %1,(sp)\", xoperands);
       output_asm_insn (\"move.l %1,-(sp)\", operands);
       return \"fmove.d (sp)+,%0\";
     #else
       output_asm_insn (\"movel %1,sp@@\", xoperands);
       output_asm_insn (\"movel %1,sp@@-\", operands);
       return \"fmoved sp@@+,%0\";
     #endif
     }
     ")

   The effect of this optimization is to change

     jbsr _foobar
     addql #4,sp
     movel d1,sp@@-
     movel d0,sp@@-
     fmoved sp@@+,fp0

into

     jbsr _foobar
     movel d1,sp@@
     movel d0,sp@@-
     fmoved sp@@+,fp0

   INSN-PATTERN-1 and so on look *almost* like the second operand of
`define_insn'.  There is one important difference: the second operand
of `define_insn' consists of one or more RTX's enclosed in square
brackets.  Usually, there is only one: then the same action can be
written as an element of a `define_peephole'.  But when there are
multiple actions in a `define_insn', they are implicitly enclosed in a
`parallel'.  Then you must explicitly write the `parallel', and the
square brackets within it, in the `define_peephole'.  Thus, if an insn
pattern looks like this,

     (define_insn "divmodsi4"
       [(set (match_operand:SI 0 "general_operand" "=d")
             (div:SI (match_operand:SI 1 "general_operand" "0")
                     (match_operand:SI 2 "general_operand" "dmsK")))
        (set (match_operand:SI 3 "general_operand" "=d")
             (mod:SI (match_dup 1) (match_dup 2)))]
       "TARGET_68020"
       "divsl%.l %2,%3:%0")

then the way to mention this insn in a peephole is as follows:

     (define_peephole
       [...
        (parallel
         [(set (match_operand:SI 0 "general_operand" "=d")
               (div:SI (match_operand:SI 1 "general_operand" "0")
                       (match_operand:SI 2 "general_operand" "dmsK")))
          (set (match_operand:SI 3 "general_operand" "=d")
               (mod:SI (match_dup 1) (match_dup 2)))])
        ...]
       ...)
d40 276
a315 2

File: gcc.info,  Node: Expander Definitions,  Next: Insn Splitting,  Prev: Peephole Definitions,  Up: Machine Desc
d317 1
a317 2
Defining RTL Sequences for Code Generation
==========================================
d319 1
a319 159
   On some target machines, some standard pattern names for RTL
generation cannot be handled with single insn, but a sequence of RTL
insns can represent them.  For these target machines, you can write a
`define_expand' to specify how to generate the sequence of RTL.

   A `define_expand' is an RTL expression that looks almost like a
`define_insn'; but, unlike the latter, a `define_expand' is used only
for RTL generation and it can produce more than one RTL insn.

   A `define_expand' RTX has four operands:

   * The name.  Each `define_expand' must have a name, since the only
     use for it is to refer to it by name.

   * The RTL template.  This is just like the RTL template for a
     `define_peephole' in that it is a vector of RTL expressions each
     being one insn.

   * The condition, a string containing a C expression.  This
     expression is used to express how the availability of this pattern
     depends on subclasses of target machine, selected by command-line
     options when GNU CC is run.  This is just like the condition of a
     `define_insn' that has a standard name.  Therefore, the condition
     (if present) may not depend on the data in the insn being matched,
     but only the target-machine-type flags.  The compiler needs to
     test these conditions during initialization in order to learn
     exactly which named instructions are available in a particular run.

   * The preparation statements, a string containing zero or more C
     statements which are to be executed before RTL code is generated
     from the RTL template.

     Usually these statements prepare temporary registers for use as
     internal operands in the RTL template, but they can also generate
     RTL insns directly by calling routines such as `emit_insn', etc.
     Any such insns precede the ones that come from the RTL template.

   Every RTL insn emitted by a `define_expand' must match some
`define_insn' in the machine description.  Otherwise, the compiler will
crash when trying to generate code for the insn or trying to optimize
it.

   The RTL template, in addition to controlling generation of RTL insns,
also describes the operands that need to be specified when this pattern
is used.  In particular, it gives a predicate for each operand.

   A true operand, which needs to be specified in order to generate RTL
from the pattern, should be described with a `match_operand' in its
first occurrence in the RTL template.  This enters information on the
operand's predicate into the tables that record such things.  GNU CC
uses the information to preload the operand into a register if that is
required for valid RTL code.  If the operand is referred to more than
once, subsequent references should use `match_dup'.

   The RTL template may also refer to internal "operands" which are
temporary registers or labels used only within the sequence made by the
`define_expand'.  Internal operands are substituted into the RTL
template with `match_dup', never with `match_operand'.  The values of
the internal operands are not passed in as arguments by the compiler
when it requests use of this pattern.  Instead, they are computed
within the pattern, in the preparation statements.  These statements
compute the values and store them into the appropriate elements of
`operands' so that `match_dup' can find them.

   There are two special macros defined for use in the preparation
statements: `DONE' and `FAIL'.  Use them with a following semicolon, as
a statement.

`DONE'
     Use the `DONE' macro to end RTL generation for the pattern.  The
     only RTL insns resulting from the pattern on this occasion will be
     those already emitted by explicit calls to `emit_insn' within the
     preparation statements; the RTL template will not be generated.

`FAIL'
     Make the pattern fail on this occasion.  When a pattern fails, it
     means that the pattern was not truly available.  The calling
     routines in the compiler will try other strategies for code
     generation using other patterns.

     Failure is currently supported only for binary (addition,
     multiplication, shifting, etc.) and bitfield (`extv', `extzv', and
     `insv') operations.

   Here is an example, the definition of left-shift for the SPUR chip:

     (define_expand "ashlsi3"
       [(set (match_operand:SI 0 "register_operand" "")
             (ashift:SI

     (match_operand:SI 1 "register_operand" "")
               (match_operand:SI 2 "nonmemory_operand" "")))]
       ""
       "

     {
       if (GET_CODE (operands[2]) != CONST_INT
           || (unsigned) INTVAL (operands[2]) > 3)
         FAIL;
     }")

This example uses `define_expand' so that it can generate an RTL insn
for shifting when the shift-count is in the supported range of 0 to 3
but fail in other cases where machine insns aren't available.  When it
fails, the compiler tries another strategy using different patterns
(such as, a library call).

   If the compiler were able to handle nontrivial condition-strings in
patterns with names, then it would be possible to use a `define_insn'
in that case.  Here is another case (zero-extension on the 68000) which
makes more use of the power of `define_expand':

     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "general_operand" "")
             (const_int 0))
        (set (strict_low_part
               (subreg:HI
                 (match_dup 0)
                 0))
             (match_operand:HI 1 "general_operand" ""))]
       ""
       "operands[1] = make_safe_from (operands[1], operands[0]);")

Here two RTL insns are generated, one to clear the entire output operand
and the other to copy the input operand into its low half.  This
sequence is incorrect if the input operand refers to [the old value of]
the output operand, so the preparation statement makes sure this isn't
so.  The function `make_safe_from' copies the `operands[1]' into a
temporary register if it refers to `operands[0]'.  It does this by
emitting another RTL insn.

   Finally, a third example shows the use of an internal operand.
Zero-extension on the SPUR chip is done by `and'-ing the result against
a halfword mask.  But this mask cannot be represented by a `const_int'
because the constant value is too large to be legitimate on this
machine.  So it must be copied into a register with `force_reg' and
then the register used in the `and'.

     (define_expand "zero_extendhisi2"
       [(set (match_operand:SI 0 "register_operand" "")
             (and:SI (subreg:SI
                       (match_operand:HI 1 "register_operand" "")
                       0)
                     (match_dup 2)))]
       ""
       "operands[2]
          = force_reg (SImode, gen_rtx (CONST_INT,
                                        VOIDmode, 65535)); ")

   *Note:* If the `define_expand' is used to serve a standard binary or
unary arithmetic operation or a bitfield operation, then the last insn
it generates must not be a `code_label', `barrier' or `note'.  It must
be an `insn', `jump_insn' or `call_insn'.  If you don't need a real insn
at the end, emit an insn to copy the result of the operation into
itself.  Such an insn will generate no code, but it can avoid problems
in the compiler.


File: gcc.info,  Node: Insn Splitting,  Next: Insn Attributes,  Prev: Expander Definitions,  Up: Machine Desc
d321 1
a321 2
Defining How to Split Instructions
==================================
d323 1
a323 146
   There are two cases where you should specify how to split a pattern
into multiple insns.  On machines that have instructions requiring delay
slots (*note Delay Slots::.) or that have instructions whose output is
not available for multiple cycles (*note Function Units::.), the
compiler phases that optimize these cases need to be able to move insns
into one-instruction delay slots.  However, some insns may generate
more than one machine instruction.  These insns cannot be placed into a
delay slot.

   Often you can rewrite the single insn as a list of individual insns,
each corresponding to one machine instruction.  The disadvantage of
doing so is that it will cause the compilation to be slower and require
more space.  If the resulting insns are too complex, it may also
suppress some optimizations.  The compiler splits the insn if there is a
reason to believe that it might improve instruction or delay slot
scheduling.

   The insn combiner phase also splits putative insns.  If three insns
are merged into one insn with a complex expression that cannot be
matched by some `define_insn' pattern, the combiner phase attempts to
split the complex pattern into two insns that are recognized.  Usually
it can break the complex pattern into two patterns by splitting out some
subexpression.  However, in some other cases, such as performing an
addition of a large constant in two insns on a RISC machine, the way to
split the addition into two insns is machine-dependent.

   The `define_split' definition tells the compiler how to split a
complex insn into several simpler insns.  It looks like this:

     (define_split
       [INSN-PATTERN]
       "CONDITION"
       [NEW-INSN-PATTERN-1
        NEW-INSN-PATTERN-2
        ...]
       "PREPARATION STATEMENTS")

   INSN-PATTERN is a pattern that needs to be split and CONDITION is
the final condition to be tested, as in a `define_insn'.  When an insn
matching INSN-PATTERN and satisfying CONDITION is found, it is replaced
in the insn list with the insns given by NEW-INSN-PATTERN-1,
NEW-INSN-PATTERN-2, etc.

   The PREPARATION STATEMENTS are similar to those statements that are
specified for `define_expand' (*note Expander Definitions::.)  and are
executed before the new RTL is generated to prepare for the generated
code or emit some insns whose pattern is not fixed.  Unlike those in
`define_expand', however, these statements must not generate any new
pseudo-registers.  Once reload has completed, they also must not
allocate any space in the stack frame.

   Patterns are matched against INSN-PATTERN in two different
circumstances.  If an insn needs to be split for delay slot scheduling
or insn scheduling, the insn is already known to be valid, which means
that it must have been matched by some `define_insn' and, if
`reload_completed' is non-zero, is known to satisfy the constraints of
that `define_insn'.  In that case, the new insn patterns must also be
insns that are matched by some `define_insn' and, if `reload_completed'
is non-zero, must also satisfy the constraints of those definitions.

   As an example of this usage of `define_split', consider the following
example from `a29k.md', which splits a `sign_extend' from `HImode' to
`SImode' into a pair of shift insns:

     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (sign_extend:SI (match_operand:HI 1 "gen_reg_operand" "")))]
       ""
       [(set (match_dup 0)
             (ashift:SI (match_dup 1)
                        (const_int 16)))
        (set (match_dup 0)
             (ashiftrt:SI (match_dup 0)
                          (const_int 16)))]
       "
     { operands[1] = gen_lowpart (SImode, operands[1]); }")

   When the combiner phase tries to split an insn pattern, it is always
the case that the pattern is *not* matched by any `define_insn'.  The
combiner pass first tries to split a single `set' expression and then
the same `set' expression inside a `parallel', but followed by a
`clobber' of a pseudo-reg to use as a scratch register.  In these
cases, the combiner expects exactly two new insn patterns to be
generated.  It will verify that these patterns match some `define_insn'
definitions, so you need not do this test in the `define_split' (of
course, there is no point in writing a `define_split' that will never
produce insns that match).

   Here is an example of this use of `define_split', taken from
`rs6000.md':

     (define_split
       [(set (match_operand:SI 0 "gen_reg_operand" "")
             (plus:SI (match_operand:SI 1 "gen_reg_operand" "")
                      (match_operand:SI 2 "non_add_cint_operand" "")))]
       ""
       [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))
        (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 4)))]
     "
     {
       int low = INTVAL (operands[2]) & 0xffff;
       int high = (unsigned) INTVAL (operands[2]) >> 16;
     
       if (low & 0x8000)
         high++, low |= 0xffff0000;
     
       operands[3] = gen_rtx (CONST_INT, VOIDmode, high << 16);
       operands[4] = gen_rtx (CONST_INT, VOIDmode, low);
     }")

   Here the predicate `non_add_cint_operand' matches any `const_int'
that is *not* a valid operand of a single add insn.  The add with the
smaller displacement is written so that it can be substituted into the
address of a subsequent operation.

   An example that uses a scratch register, from the same file,
generates an equality comparison of a register and a large constant:

     (define_split
       [(set (match_operand:CC 0 "cc_reg_operand" "")
             (compare:CC (match_operand:SI 1 "gen_reg_operand" "")
                         (match_operand:SI 2 "non_short_cint_operand" "")))
        (clobber (match_operand:SI 3 "gen_reg_operand" ""))]
       "find_single_use (operands[0], insn, 0)
        && (GET_CODE (*find_single_use (operands[0], insn, 0)) == EQ
            || GET_CODE (*find_single_use (operands[0], insn, 0)) == NE)"
       [(set (match_dup 3) (xor:SI (match_dup 1) (match_dup 4)))
        (set (match_dup 0) (compare:CC (match_dup 3) (match_dup 5)))]
       "
     {
       /* Get the constant we are comparing against, C, and see what it
          looks like sign-extended to 16 bits.  Then see what constant
          could be XOR'ed with C to get the sign-extended value.  */
     
       int c = INTVAL (operands[2]);
       int sextc = (c << 16) >> 16;
       int xorv = c ^ sextc;
     
       operands[4] = gen_rtx (CONST_INT, VOIDmode, xorv);
       operands[5] = gen_rtx (CONST_INT, VOIDmode, sextc);
     }")

   To avoid confusion, don't write a single `define_split' that accepts
some insns that match some `define_insn' as well as some insns that
don't.  Instead, write two separate `define_split' definitions, one for
the insns that are valid and one for the insns that are not valid.
d326 1
a326 1
File: gcc.info,  Node: Insn Attributes,  Prev: Insn Splitting,  Up: Machine Desc
d328 2
a329 2
Instruction Attributes
======================
d331 1
a331 6
   In addition to describing the instruction supported by the target
machine, the `md' file also defines a group of "attributes" and a set of
values for each.  Every generated insn is assigned a value for each
attribute.  One possible attribute would be the effect that the insn
has on the machine's condition code.  This attribute can then be used
by `NOTICE_UPDATE_CC' to track the condition codes.
d333 130
a462 10
* Menu:

* Defining Attributes:: Specifying attributes and their values.
* Expressions::         Valid expressions for attribute values.
* Tagging Insns::       Assigning attribute values to insns.
* Attr Example::        An example of assigning attributes.
* Insn Lengths::        Computing the length of insns.
* Constant Attributes:: Defining attributes that are constant.
* Delay Slots::         Defining delay slots required for a machine.
* Function Units::      Specifying information for insn scheduling.
d465 1
a465 1
File: gcc.info,  Node: Defining Attributes,  Next: Expressions,  Up: Insn Attributes
d467 2
a468 2
Defining Attributes and their Values
------------------------------------
d470 326
a795 2
   The `define_attr' expression is used to define each attribute
required by the target machine.  It looks like:
d797 2
a798 1
     (define_attr NAME LIST-OF-VALUES DEFAULT)
d800 2
a801 1
   NAME is a string specifying the name of the attribute being defined.
d803 156
a958 3
   LIST-OF-VALUES is either a string that specifies a comma-separated
list of values that can be assigned to the attribute, or a null string
to indicate that the attribute takes numeric values.
d960 2
a961 6
   DEFAULT is an attribute expression that gives the value of this
attribute for insns that match patterns whose definition does not
include an explicit value for this attribute.  *Note Attr Example::,
for more information on the handling of defaults.  *Note Constant
Attributes::, for information on attributes that do not depend on any
particular insn.
d963 2
a964 3
   For each defined attribute, a number of definitions are written to
the `insn-attr.h' file.  For cases where an explicit set of values is
specified for an attribute, the following are defined:
d966 2
a967 1
   * A `#define' is written for the symbol `HAVE_ATTR_NAME'.
d969 6
a974 3
   * An enumeral class is defined for `attr_NAME' with elements of the
     form `UPPER-NAME_UPPER-VALUE' where the attribute name and value
     are first converted to upper case.
d976 1
a976 13
   * A function `get_attr_NAME' is defined that is passed an insn and
     returns the attribute value for that insn.

   For example, if the following is present in the `md' file:

     (define_attr "type" "branch,fp,load,store,arith" ...)

the following lines will be written to the file `insn-attr.h'.

     #define HAVE_ATTR_type
     enum attr_type {TYPE_BRANCH, TYPE_FP, TYPE_LOAD,
                      TYPE_STORE, TYPE_ARITH};
     extern enum attr_type get_attr_type ();
d978 6
a983 3
   If the attribute takes numeric values, no `enum' type will be
defined and the function to obtain the attribute's value will return
`int'.
d986 1
a986 1
File: gcc.info,  Node: Expressions,  Next: Tagging Insns,  Prev: Defining Attributes,  Up: Insn Attributes
d988 2
a989 2
Attribute Expressions
---------------------
d991 1
a991 144
   RTL expressions used to define attributes use the codes described
above plus a few specific to attribute definitions, to be discussed
below.  Attribute value expressions must have one of the following
forms:

`(const_int I)'
     The integer I specifies the value of a numeric attribute.  I must
     be non-negative.

     The value of a numeric attribute can be specified either with a
     `const_int' or as an integer represented as a string in
     `const_string', `eq_attr' (see below), and `set_attr' (*note
     Tagging Insns::.) expressions.

`(const_string VALUE)'
     The string VALUE specifies a constant attribute value.  If VALUE
     is specified as `"*"', it means that the default value of the
     attribute is to be used for the insn containing this expression.
     `"*"' obviously cannot be used in the DEFAULT expression of a
     `define_attr'.

     If the attribute whose value is being specified is numeric, VALUE
     must be a string containing a non-negative integer (normally
     `const_int' would be used in this case).  Otherwise, it must
     contain one of the valid values for the attribute.

`(if_then_else TEST TRUE-VALUE FALSE-VALUE)'
     TEST specifies an attribute test, whose format is defined below.
     The value of this expression is TRUE-VALUE if TEST is true,
     otherwise it is FALSE-VALUE.

`(cond [TEST1 VALUE1 ...] DEFAULT)'
     The first operand of this expression is a vector containing an even
     number of expressions and consisting of pairs of TEST and VALUE
     expressions.  The value of the `cond' expression is that of the
     VALUE corresponding to the first true TEST expression.  If none of
     the TEST expressions are true, the value of the `cond' expression
     is that of the DEFAULT expression.

   TEST expressions can have one of the following forms:

`(const_int I)'
     This test is true if I is non-zero and false otherwise.

`(not TEST)'
`(ior TEST1 TEST2)'
`(and TEST1 TEST2)'
     These tests are true if the indicated logical function is true.

`(match_operand:M N PRED CONSTRAINTS)'
     This test is true if operand N of the insn whose attribute value
     is being determined has mode M (this part of the test is ignored
     if M is `VOIDmode') and the function specified by the string PRED
     returns a non-zero value when passed operand N and mode M (this
     part of the test is ignored if PRED is the null string).

     The CONSTRAINTS operand is ignored and should be the null string.

`(le ARITH1 ARITH2)'
`(leu ARITH1 ARITH2)'
`(lt ARITH1 ARITH2)'
`(ltu ARITH1 ARITH2)'
`(gt ARITH1 ARITH2)'
`(gtu ARITH1 ARITH2)'
`(ge ARITH1 ARITH2)'
`(geu ARITH1 ARITH2)'
`(ne ARITH1 ARITH2)'
`(eq ARITH1 ARITH2)'
     These tests are true if the indicated comparison of the two
     arithmetic expressions is true.  Arithmetic expressions are formed
     with `plus', `minus', `mult', `div', `mod', `abs', `neg', `and',
     `ior', `xor', `not', `ashift', `lshiftrt', and `ashiftrt'
     expressions.

     `const_int' and `symbol_ref' are always valid terms (*note Insn
     Lengths::.,for additional forms).  `symbol_ref' is a string
     denoting a C expression that yields an `int' when evaluated by the
     `get_attr_...' routine.  It should normally be a global variable.

`(eq_attr NAME VALUE)'
     NAME is a string specifying the name of an attribute.

     VALUE is a string that is either a valid value for attribute NAME,
     a comma-separated list of values, or `!' followed by a value or
     list.  If VALUE does not begin with a `!', this test is true if
     the value of the NAME attribute of the current insn is in the list
     specified by VALUE.  If VALUE begins with a `!', this test is true
     if the attribute's value is *not* in the specified list.

     For example,

          (eq_attr "type" "load,store")

     is equivalent to

          (ior (eq_attr "type" "load") (eq_attr "type" "store"))

     If NAME specifies an attribute of `alternative', it refers to the
     value of the compiler variable `which_alternative' (*note Output
     Statement::.) and the values must be small integers.  For example,

          (eq_attr "alternative" "2,3")

     is equivalent to

          (ior (eq (symbol_ref "which_alternative") (const_int 2))
               (eq (symbol_ref "which_alternative") (const_int 3)))

     Note that, for most attributes, an `eq_attr' test is simplified in
     cases where the value of the attribute being tested is known for
     all insns matching a particular pattern.  This is by far the most
     common case.

`(attr_flag NAME)'
     The value of an `attr_flag' expression is true if the flag
     specified by NAME is true for the `insn' currently being scheduled.

     NAME is a string specifying one of a fixed set of flags to test.
     Test the flags `forward' and `backward' to determine the direction
     of a conditional branch.  Test the flags `very_likely', `likely',
     `very_unlikely', and `unlikely' to determine if a conditional
     branch is expected to be taken.

     If the `very_likely' flag is true, then the `likely' flag is also
     true.  Likewise for the `very_unlikely' and `unlikely' flags.

     This example describes a conditional branch delay slot which can
     be nullified for forward branches that are taken (annul-true) or
     for backward branches which are not taken (annul-false).

          (define_delay (eq_attr "type" "cbranch")
            [(eq_attr "in_branch_delay" "true")
             (and (eq_attr "in_branch_delay" "true")
                  (attr_flag "forward"))
             (and (eq_attr "in_branch_delay" "true")
                  (attr_flag "backward"))])

     The `forward' and `backward' flags are false if the current `insn'
     being scheduled is not a conditional branch.

     The `very_likely' and `likely' flags are true if the `insn' being
     scheduled is not a conditional branch.  The `very_unlikely' and
     `unlikely' flags are false if the `insn' being scheduled is not a
     conditional branch.
d993 81
a1073 2
     `attr_flag' is only used during delay slot scheduling and has no
     meaning to other passes of the compiler.
d1076 1
a1076 1
File: gcc.info,  Node: Tagging Insns,  Next: Attr Example,  Prev: Expressions,  Up: Insn Attributes
d1078 2
a1079 2
Assigning Attribute Values to Insns
-----------------------------------
d1081 1
a1081 88
   The value assigned to an attribute of an insn is primarily
determined by which pattern is matched by that insn (or which
`define_peephole' generated it).  Every `define_insn' and
`define_peephole' can have an optional last argument to specify the
values of attributes for matching insns.  The value of any attribute
not specified in a particular insn is set to the default value for that
attribute, as specified in its `define_attr'.  Extensive use of default
values for attributes permits the specification of the values for only
one or two attributes in the definition of most insn patterns, as seen
in the example in the next section.

   The optional last argument of `define_insn' and `define_peephole' is
a vector of expressions, each of which defines the value for a single
attribute.  The most general way of assigning an attribute's value is
to use a `set' expression whose first operand is an `attr' expression
giving the name of the attribute being set.  The second operand of the
`set' is an attribute expression (*note Expressions::.) giving the
value of the attribute.

   When the attribute value depends on the `alternative' attribute
(i.e., which is the applicable alternative in the constraint of the
insn), the `set_attr_alternative' expression can be used.  It allows
the specification of a vector of attribute expressions, one for each
alternative.

   When the generality of arbitrary attribute expressions is not
required, the simpler `set_attr' expression can be used, which allows
specifying a string giving either a single attribute value or a list of
attribute values, one for each alternative.

   The form of each of the above specifications is shown below.  In
each case, NAME is a string specifying the attribute to be set.

`(set_attr NAME VALUE-STRING)'
     VALUE-STRING is either a string giving the desired attribute value,
     or a string containing a comma-separated list giving the values for
     succeeding alternatives.  The number of elements must match the
     number of alternatives in the constraint of the insn pattern.

     Note that it may be useful to specify `*' for some alternative, in
     which case the attribute will assume its default value for insns
     matching that alternative.

`(set_attr_alternative NAME [VALUE1 VALUE2 ...])'
     Depending on the alternative of the insn, the value will be one of
     the specified values.  This is a shorthand for using a `cond' with
     tests on the `alternative' attribute.

`(set (attr NAME) VALUE)'
     The first operand of this `set' must be the special RTL expression
     `attr', whose sole operand is a string giving the name of the
     attribute being set.  VALUE is the value of the attribute.

   The following shows three different ways of representing the same
attribute value specification:

     (set_attr "type" "load,store,arith")
     
     (set_attr_alternative "type"
                           [(const_string "load") (const_string "store")
                            (const_string "arith")])
     
     (set (attr "type")
          (cond [(eq_attr "alternative" "1") (const_string "load")
                 (eq_attr "alternative" "2") (const_string "store")]
                (const_string "arith")))

   The `define_asm_attributes' expression provides a mechanism to
specify the attributes assigned to insns produced from an `asm'
statement.  It has the form:

     (define_asm_attributes [ATTR-SETS])

where ATTR-SETS is specified the same as for both the `define_insn' and
the `define_peephole' expressions.

   These values will typically be the "worst case" attribute values.
For example, they might indicate that the condition code will be
clobbered.

   A specification for a `length' attribute is handled specially.  The
way to compute the length of an `asm' insn is to multiply the length
specified in the expression `define_asm_attributes' by the number of
machine instructions specified in the `asm' statement, determined by
counting the number of semicolons and newlines in the string.
Therefore, the value of the `length' attribute specified in a
`define_asm_attributes' should be the maximum possible length of a
single machine instruction.
d1083 4
a1086 5

File: gcc.info,  Node: Attr Example,  Next: Insn Lengths,  Prev: Tagging Insns,  Up: Insn Attributes

Example of Attribute Specifications
-----------------------------------
d1088 2
a1089 47
   The judicious use of defaulting is important in the efficient use of
insn attributes.  Typically, insns are divided into "types" and an
attribute, customarily called `type', is used to represent this value.
This attribute is normally used only to define the default value for
other attributes.  An example will clarify this usage.

   Assume we have a RISC machine with a condition code and in which only
full-word operations are performed in registers.  Let us assume that we
can divide all insns into loads, stores, (integer) arithmetic
operations, floating point operations, and branches.

   Here we will concern ourselves with determining the effect of an
insn on the condition code and will limit ourselves to the following
possible effects:  The condition code can be set unpredictably
(clobbered), not be changed, be set to agree with the results of the
operation, or only changed if the item previously set into the
condition code has been modified.

   Here is part of a sample `md' file for such a machine:

     (define_attr "type" "load,store,arith,fp,branch" (const_string "arith"))
     
     (define_attr "cc" "clobber,unchanged,set,change0"
                  (cond [(eq_attr "type" "load")
                             (const_string "change0")
                         (eq_attr "type" "store,branch")
                             (const_string "unchanged")
                         (eq_attr "type" "arith")
                             (if_then_else (match_operand:SI 0 "" "")
                                           (const_string "set")
                                           (const_string "clobber"))]
                        (const_string "clobber")))
     
     (define_insn ""
       [(set (match_operand:SI 0 "general_operand" "=r,r,m")
             (match_operand:SI 1 "general_operand" "r,m,r"))]
       ""
       "@@
        move %0,%1
        load %0,%1
        store %0,%1"
       [(set_attr "type" "arith,load,store")])

   Note that we assume in the above example that arithmetic operations
performed on quantities smaller than a machine word clobber the
condition code since they will set the condition code to a value
corresponding to the full-word result.
d1091 5
a1095 2

File: gcc.info,  Node: Insn Lengths,  Next: Constant Attributes,  Prev: Attr Example,  Up: Insn Attributes
d1097 4
a1100 2
Computing the Length of an Insn
-------------------------------
d1102 3
a1104 77
   For many machines, multiple types of branch instructions are
provided, each for different length branch displacements.  In most
cases, the assembler will choose the correct instruction to use.
However, when the assembler cannot do so, GCC can when a special
attribute, the `length' attribute, is defined.  This attribute must be
defined to have numeric values by specifying a null string in its
`define_attr'.

   In the case of the `length' attribute, two additional forms of
arithmetic terms are allowed in test expressions:

`(match_dup N)'
     This refers to the address of operand N of the current insn, which
     must be a `label_ref'.

`(pc)'
     This refers to the address of the *current* insn.  It might have
     been more consistent with other usage to make this the address of
     the *next* insn but this would be confusing because the length of
     the current insn is to be computed.

   For normal insns, the length will be determined by value of the
`length' attribute.  In the case of `addr_vec' and `addr_diff_vec' insn
patterns, the length is computed as the number of vectors multiplied by
the size of each vector.

   Lengths are measured in addressable storage units (bytes).

   The following macros can be used to refine the length computation:

`FIRST_INSN_ADDRESS'
     When the `length' insn attribute is used, this macro specifies the
     value to be assigned to the address of the first insn in a
     function.  If not specified, 0 is used.

`ADJUST_INSN_LENGTH (INSN, LENGTH)'
     If defined, modifies the length assigned to instruction INSN as a
     function of the context in which it is used.  LENGTH is an lvalue
     that contains the initially computed length of the insn and should
     be updated with the correct length of the insn.  If updating is
     required, INSN must not be a varying-length insn.

     This macro will normally not be required.  A case in which it is
     required is the ROMP.  On this machine, the size of an `addr_vec'
     insn must be increased by two to compensate for the fact that
     alignment may be required.

   The routine that returns `get_attr_length' (the value of the
`length' attribute) can be used by the output routine to determine the
form of the branch instruction to be written, as the example below
illustrates.

   As an example of the specification of variable-length branches,
consider the IBM 360.  If we adopt the convention that a register will
be set to the starting address of a function, we can jump to labels
within 4k of the start using a four-byte instruction.  Otherwise, we
need a six-byte sequence to load the address from memory and then
branch to it.

   On such a machine, a pattern for a branch instruction might be
specified as follows:

     (define_insn "jump"
       [(set (pc)
             (label_ref (match_operand 0 "" "")))]
       ""
       "*
     {
        return (get_attr_length (insn) == 4
                ? \"b %l0\" : \"l r15,=a(%l0); br r15\");
     }"
       [(set (attr "length") (if_then_else (lt (match_dup 0) (const_int 4096))
                                           (const_int 4)
                                           (const_int 6)))])


File: gcc.info,  Node: Constant Attributes,  Next: Delay Slots,  Prev: Insn Lengths,  Up: Insn Attributes
d1106 2
a1107 2
Constant Attributes
-------------------
d1109 1
a1109 22
   A special form of `define_attr', where the expression for the
default value is a `const' expression, indicates an attribute that is
constant for a given run of the compiler.  Constant attributes may be
used to specify which variety of processor is used.  For example,

     (define_attr "cpu" "m88100,m88110,m88000"
      (const
       (cond [(symbol_ref "TARGET_88100") (const_string "m88100")
              (symbol_ref "TARGET_88110") (const_string "m88110")]
             (const_string "m88000"))))
     
     (define_attr "memory" "fast,slow"
      (const
       (if_then_else (symbol_ref "TARGET_FAST_MEM")
                     (const_string "fast")
                     (const_string "slow"))))

   The routine generated for constant attributes has no parameters as it
does not depend on any particular insn.  RTL expressions used to define
the value of a constant attribute may use the `symbol_ref' form, but
may not use either the `match_operand' form or `eq_attr' forms
involving insn attributes.
d1112 1
a1112 1
File: gcc.info,  Node: Delay Slots,  Next: Function Units,  Prev: Constant Attributes,  Up: Insn Attributes
d1114 2
a1115 2
Delay Slot Scheduling
---------------------
d1117 85
a1201 62
   The insn attribute mechanism can be used to specify the requirements
for delay slots, if any, on a target machine.  An instruction is said to
require a "delay slot" if some instructions that are physically after
the instruction are executed as if they were located before it.
Classic examples are branch and call instructions, which often execute
the following instruction before the branch or call is performed.

   On some machines, conditional branch instructions can optionally
"annul" instructions in the delay slot.  This means that the
instruction will not be executed for certain branch outcomes.  Both
instructions that annul if the branch is true and instructions that
annul if the branch is false are supported.

   Delay slot scheduling differs from instruction scheduling in that
determining whether an instruction needs a delay slot is dependent only
on the type of instruction being generated, not on data flow between the
instructions.  See the next section for a discussion of data-dependent
instruction scheduling.

   The requirement of an insn needing one or more delay slots is
indicated via the `define_delay' expression.  It has the following form:

     (define_delay TEST
                   [DELAY-1 ANNUL-TRUE-1 ANNUL-FALSE-1
                    DELAY-2 ANNUL-TRUE-2 ANNUL-FALSE-2
                    ...])

   TEST is an attribute test that indicates whether this `define_delay'
applies to a particular insn.  If so, the number of required delay
slots is determined by the length of the vector specified as the second
argument.  An insn placed in delay slot N must satisfy attribute test
DELAY-N.  ANNUL-TRUE-N is an attribute test that specifies which insns
may be annulled if the branch is true.  Similarly, ANNUL-FALSE-N
specifies which insns in the delay slot may be annulled if the branch
is false.  If annulling is not supported for that delay slot, `(nil)'
should be coded.

   For example, in the common case where branch and call insns require
a single delay slot, which may contain any insn other than a branch or
call, the following would be placed in the `md' file:

     (define_delay (eq_attr "type" "branch,call")
                   [(eq_attr "type" "!branch,call") (nil) (nil)])

   Multiple `define_delay' expressions may be specified.  In this case,
each such expression specifies different delay slot requirements and
there must be no insn for which tests in two `define_delay' expressions
are both true.

   For example, if we have a machine that requires one delay slot for
branches but two for calls,  no delay slot can contain a branch or call
insn, and any valid insn in the delay slot for the branch can be
annulled if the branch is true, we might represent this as follows:

     (define_delay (eq_attr "type" "branch")
        [(eq_attr "type" "!branch,call")
         (eq_attr "type" "!branch,call")
         (nil)])
     
     (define_delay (eq_attr "type" "call")
                   [(eq_attr "type" "!branch,call") (nil) (nil)
                    (eq_attr "type" "!branch,call") (nil) (nil)])
@


1.1.1.3
log
@FSF gcc 2.8.1
@
text
@d1 1
a1 1
This is Info file gcc.info, produced by Makeinfo version 1.67 from the
d412 1
a412 1
specified for `define_expand' (*note Expander Definitions::.) and are
@

