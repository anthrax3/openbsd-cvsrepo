head	1.3;
access;
symbols
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	FSF_2_8_1:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	99.05.26.16.21.05;	author espie;	state dead;
branches;
next	1.2;

1.2
date	98.03.03.21.15.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.02.11;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.02.11;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.09.52;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@So long, and thanks for all the bugs.
@
text
@/* Parse C expressions for CCCP.
   Copyright (C) 1987, 1992, 1994, 1995, 1996, 1997 Free Software Foundation.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

 In other words, you are welcome to use, share and improve this program.
 You are forbidden to forbid anyone else to use, share and improve
 what you give them.   Help stamp out software-hoarding!

 Adapted from expread.y of GDB by Paul Rubin, July 1986.  */

/* Parse a C expression from text in a string  */
   
%{
#include "config.h"
#include <setjmp.h>
/* #define YYDEBUG 1 */


#ifdef HAVE_STRING_H
# include <string.h>
#endif

#ifdef HAVE_STDLIB_H
# include <stdlib.h>
#endif

#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif

#ifdef MULTIBYTE_CHARS
#include <locale.h>
#endif

#include <stdio.h>

typedef unsigned char U_CHAR;

/* This is used for communicating lists of keywords with cccp.c.  */
struct arglist {
  struct arglist *next;
  U_CHAR *name;
  int length;
  int argno;
};

/* Define a generic NULL if one hasn't already been defined.  */

#ifndef NULL
#define NULL 0
#endif

#ifndef GENERIC_PTR
#if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#define GENERIC_PTR void *
#else
#define GENERIC_PTR char *
#endif
#endif

#ifndef NULL_PTR
#define NULL_PTR ((GENERIC_PTR) 0)
#endif

/* Find the largest host integer type and set its size and type.
   Watch out: on some crazy hosts `long' is shorter than `int'.  */

#ifndef HOST_WIDE_INT
# if HAVE_INTTYPES_H
#  include <inttypes.h>
#  define HOST_WIDE_INT intmax_t
#  define unsigned_HOST_WIDE_INT uintmax_t
# else
#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)
#   define HOST_WIDE_INT int
#  else
#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))
#   define HOST_WIDE_INT long
#  else
#   define HOST_WIDE_INT long long
#  endif
#  endif
# endif
#endif

#ifndef unsigned_HOST_WIDE_INT
#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT
#endif

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif

#ifndef HOST_BITS_PER_WIDE_INT
#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))
#endif

#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
# define __attribute__(x)
#endif

#ifndef PROTO
# if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#  define PROTO(ARGS) ARGS
# else
#  define PROTO(ARGS) ()
# endif
#endif

#if defined (__STDC__) && defined (HAVE_VPRINTF)
# include <stdarg.h>
# define VA_START(va_list, var) va_start (va_list, var)
# define PRINTF_ALIST(msg) char *msg, ...
# define PRINTF_DCL(msg)
# define PRINTF_PROTO(ARGS, m, n) PROTO (ARGS) __attribute__ ((format (__printf__, m, n)))
#else
# include <varargs.h>
# define VA_START(va_list, var) va_start (va_list)
# define PRINTF_ALIST(msg) msg, va_alist
# define PRINTF_DCL(msg) char *msg; va_dcl
# define PRINTF_PROTO(ARGS, m, n) () __attribute__ ((format (__printf__, m, n)))
# define vfprintf(file, msg, args) \
    { \
      char *a0 = va_arg(args, char *); \
      char *a1 = va_arg(args, char *); \
      char *a2 = va_arg(args, char *); \
      char *a3 = va_arg(args, char *); \
      fprintf (file, msg, a0, a1, a2, a3); \
    }
#endif

#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)

HOST_WIDE_INT parse_c_expression PROTO((char *, int));

static int yylex PROTO((void));
static void yyerror PROTO((char *)) __attribute__ ((noreturn));
static HOST_WIDE_INT expression_value;
#ifdef TEST_EXP_READER
static int expression_signedp;
#endif

static jmp_buf parse_return_error;

/* Nonzero means count most punctuation as part of a name.  */
static int keyword_parsing = 0;

/* Nonzero means do not evaluate this expression.
   This is a count, since unevaluated expressions can nest.  */
static int skip_evaluation;

/* Nonzero means warn if undefined identifiers are evaluated.  */
static int warn_undef;

/* some external tables of character types */
extern unsigned char is_idstart[], is_idchar[], is_space[];

/* Flag for -pedantic.  */
extern int pedantic;

/* Flag for -traditional.  */
extern int traditional;

/* Flag for -lang-c89.  */
extern int c89;

#ifndef CHAR_TYPE_SIZE
#define CHAR_TYPE_SIZE BITS_PER_UNIT
#endif

#ifndef INT_TYPE_SIZE
#define INT_TYPE_SIZE BITS_PER_WORD
#endif

#ifndef LONG_TYPE_SIZE
#define LONG_TYPE_SIZE BITS_PER_WORD
#endif

#ifndef WCHAR_TYPE_SIZE
#define WCHAR_TYPE_SIZE INT_TYPE_SIZE
#endif

#ifndef MAX_CHAR_TYPE_SIZE
#define MAX_CHAR_TYPE_SIZE CHAR_TYPE_SIZE
#endif

#ifndef MAX_INT_TYPE_SIZE
#define MAX_INT_TYPE_SIZE INT_TYPE_SIZE
#endif

#ifndef MAX_LONG_TYPE_SIZE
#define MAX_LONG_TYPE_SIZE LONG_TYPE_SIZE
#endif

#ifndef MAX_WCHAR_TYPE_SIZE
#define MAX_WCHAR_TYPE_SIZE WCHAR_TYPE_SIZE
#endif

#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \
			    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \
			    : ~ (HOST_WIDE_INT) 0)

#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \
			     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \
			     : ~ (HOST_WIDE_INT) 0)

/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.
   Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.
   Suppose SIGNEDP is negative if the result is signed, zero if unsigned.
   Then this yields nonzero if overflow occurred during the addition.
   Overflow occurs if A and B have the same sign, but A and SUM differ in sign,
   and SIGNEDP is negative.
   Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */
#define overflow_sum_sign(a, b, sum, signedp) \
	((~((a) ^ (b)) & ((a) ^ (sum)) & (signedp)) < 0)

struct constant;

GENERIC_PTR xmalloc PROTO((size_t));
HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));
int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));
struct hashnode *lookup PROTO((U_CHAR *, int, int));
void error PRINTF_PROTO_1((char *, ...));
void pedwarn PRINTF_PROTO_1((char *, ...));
void warning PRINTF_PROTO_1((char *, ...));

static int parse_number PROTO((int));
static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));
static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));
static void integer_overflow PROTO((void));

/* `signedp' values */
#define SIGNED (~0)
#define UNSIGNED 0
%}

%union {
  struct constant {HOST_WIDE_INT value; int signedp;} integer;
  struct name {U_CHAR *address; int length;} name;
  struct arglist *keywords;
}

%type <integer> exp exp1 start
%type <keywords> keywords
%token <integer> INT CHAR
%token <name> NAME
%token <integer> ERROR

%right '?' ':'
%left ','
%left OR
%left AND
%left '|'
%left '^'
%left '&'
%left EQUAL NOTEQUAL
%left '<' '>' LEQ GEQ
%left LSH RSH
%left '+' '-'
%left '*' '/' '%'
%right UNARY

/* %expect 40 */

%%

start   :	exp1
		{
		  expression_value = $1.value;
#ifdef TEST_EXP_READER
		  expression_signedp = $1.signedp;
#endif
		}
	;

/* Expressions, including the comma operator.  */
exp1	:	exp
	|	exp1 ',' exp
			{ if (pedantic)
			    pedwarn ("comma operator in operand of `#if'");
			  $$ = $3; }
	;

/* Expressions, not including the comma operator.  */
exp	:	'-' exp    %prec UNARY
			{ $$.value = - $2.value;
			  $$.signedp = $2.signedp;
			  if (($$.value & $2.value & $$.signedp) < 0)
			    integer_overflow (); }
	|	'!' exp    %prec UNARY
			{ $$.value = ! $2.value;
			  $$.signedp = SIGNED; }
	|	'+' exp    %prec UNARY
			{ $$ = $2; }
	|	'~' exp    %prec UNARY
			{ $$.value = ~ $2.value;
			  $$.signedp = $2.signedp; }
	|	'#' NAME
  			{ $$.value = check_assertion ($2.address, $2.length,
						      0, NULL_PTR);
			  $$.signedp = SIGNED; }
	|	'#' NAME
			{ keyword_parsing = 1; }
		'(' keywords ')'
  			{ $$.value = check_assertion ($2.address, $2.length,
						      1, $5);
			  keyword_parsing = 0;
			  $$.signedp = SIGNED; }
	|	'(' exp1 ')'
			{ $$ = $2; }
	;

/* Binary operators in order of decreasing precedence.  */
exp	:	exp '*' exp
			{ $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
			    {
			      $$.value = $1.value * $3.value;
			      if ($1.value
				  && ($$.value / $1.value != $3.value
				      || ($$.value & $1.value & $3.value) < 0))
				integer_overflow ();
			    }
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					* $3.value); }
	|	exp '/' exp
			{ if ($3.value == 0)
			    {
			      if (!skip_evaluation)
				error ("division by zero in #if");
			      $3.value = 1;
			    }
			  $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
			    {
			      $$.value = $1.value / $3.value;
			      if (($$.value & $1.value & $3.value) < 0)
				integer_overflow ();
			    }
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					/ $3.value); }
	|	exp '%' exp
			{ if ($3.value == 0)
			    {
			      if (!skip_evaluation)
				error ("division by zero in #if");
			      $3.value = 1;
			    }
			  $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
			    $$.value = $1.value % $3.value;
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					% $3.value); }
	|	exp '+' exp
			{ $$.value = $1.value + $3.value;
			  $$.signedp = $1.signedp & $3.signedp;
			  if (overflow_sum_sign ($1.value, $3.value,
						 $$.value, $$.signedp))
			    integer_overflow (); }
	|	exp '-' exp
			{ $$.value = $1.value - $3.value;
			  $$.signedp = $1.signedp & $3.signedp;
			  if (overflow_sum_sign ($$.value, $3.value,
						 $1.value, $$.signedp))
			    integer_overflow (); }
	|	exp LSH exp
			{ $$.signedp = $1.signedp;
			  if (($3.value & $3.signedp) < 0)
			    $$.value = right_shift (&$1, -$3.value);
			  else
			    $$.value = left_shift (&$1, $3.value); }
	|	exp RSH exp
			{ $$.signedp = $1.signedp;
			  if (($3.value & $3.signedp) < 0)
			    $$.value = left_shift (&$1, -$3.value);
			  else
			    $$.value = right_shift (&$1, $3.value); }
	|	exp EQUAL exp
			{ $$.value = ($1.value == $3.value);
			  $$.signedp = SIGNED; }
	|	exp NOTEQUAL exp
			{ $$.value = ($1.value != $3.value);
			  $$.signedp = SIGNED; }
	|	exp LEQ exp
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value <= $3.value;
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					<= $3.value); }
	|	exp GEQ exp
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value >= $3.value;
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					>= $3.value); }
	|	exp '<' exp
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value < $3.value;
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					< $3.value); }
	|	exp '>' exp
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value > $3.value;
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					> $3.value); }
	|	exp '&' exp
			{ $$.value = $1.value & $3.value;
			  $$.signedp = $1.signedp & $3.signedp; }
	|	exp '^' exp
			{ $$.value = $1.value ^ $3.value;
			  $$.signedp = $1.signedp & $3.signedp; }
	|	exp '|' exp
			{ $$.value = $1.value | $3.value;
			  $$.signedp = $1.signedp & $3.signedp; }
	|	exp AND
			{ skip_evaluation += !$1.value; }
		exp
			{ skip_evaluation -= !$1.value;
			  $$.value = ($1.value && $4.value);
			  $$.signedp = SIGNED; }
	|	exp OR
			{ skip_evaluation += !!$1.value; }
		exp
			{ skip_evaluation -= !!$1.value;
			  $$.value = ($1.value || $4.value);
			  $$.signedp = SIGNED; }
	|	exp '?'
			{ skip_evaluation += !$1.value; }
	        exp ':'
			{ skip_evaluation += !!$1.value - !$1.value; }
		exp
			{ skip_evaluation -= !!$1.value;
			  $$.value = $1.value ? $4.value : $7.value;
			  $$.signedp = $4.signedp & $7.signedp; }
	|	INT
			{ $$ = yylval.integer; }
	|	CHAR
			{ $$ = yylval.integer; }
	|	NAME
			{ if (warn_undef && !skip_evaluation)
			    warning ("`%.*s' is not defined",
				     $1.length, $1.address);
			  $$.value = 0;
			  $$.signedp = SIGNED; }
	;

keywords :
			{ $$ = 0; } 
	|	'(' keywords ')' keywords
			{ struct arglist *temp;
			  $$ = (struct arglist *) xmalloc (sizeof (struct arglist));
			  $$->next = $2;
			  $$->name = (U_CHAR *) "(";
			  $$->length = 1;
			  temp = $$;
			  while (temp != 0 && temp->next != 0)
			    temp = temp->next;
			  temp->next = (struct arglist *) xmalloc (sizeof (struct arglist));
			  temp->next->next = $4;
			  temp->next->name = (U_CHAR *) ")";
			  temp->next->length = 1; }
	|	NAME keywords
			{ $$ = (struct arglist *) xmalloc (sizeof (struct arglist));
			  $$->name = $1.address;
			  $$->length = $1.length;
			  $$->next = $2; } 
	;
%%

/* During parsing of a C expression, the pointer to the next character
   is in this variable.  */

static char *lexptr;

/* Take care of parsing a number (anything that starts with a digit).
   Set yylval and return the token type; update lexptr.
   LEN is the number of characters in it.  */

/* maybe needs to actually deal with floating point numbers */

static int
parse_number (olen)
     int olen;
{
  register char *p = lexptr;
  register int c;
  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;
  register int base = 10;
  register int len = olen;
  register int overflow = 0;
  register int digit, largest_digit = 0;
  int spec_long = 0;

  yylval.integer.signedp = SIGNED;

  if (*p == '0') {
    base = 8;
    if (len >= 3 && (p[1] == 'x' || p[1] == 'X')) {
      p += 2;
      base = 16;
      len -= 2;
    }
  }

  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;

  for (; len > 0; len--) {
    c = *p++;

    if (c >= '0' && c <= '9')
      digit = c - '0';
    else if (base == 16 && c >= 'a' && c <= 'f')
      digit = c - 'a' + 10;
    else if (base == 16 && c >= 'A' && c <= 'F')
      digit = c - 'A' + 10;
    else {
      /* `l' means long, and `u' means unsigned.  */
      while (1) {
	if (c == 'l' || c == 'L')
	  {
	    if (!pedantic < spec_long)
	      yyerror ("too many `l's in integer constant");
	    spec_long++;
	  }
	else if (c == 'u' || c == 'U')
	  {
	    if (! yylval.integer.signedp)
	      yyerror ("two `u's in integer constant");
	    yylval.integer.signedp = UNSIGNED;
	  }
	else {
	  if (c == '.' || c == 'e' || c == 'E' || c == 'p' || c == 'P')
	    yyerror ("Floating point numbers not allowed in #if expressions");
	  else {
	    char *buf = (char *) alloca (p - lexptr + 40);
	    sprintf (buf, "missing white space after number `%.*s'",
		     (int) (p - lexptr - 1), lexptr);
	    yyerror (buf);
	  }
	}

	if (--len == 0)
	  break;
	c = *p++;
      }
      /* Don't look for any more digits after the suffixes.  */
      break;
    }
    if (largest_digit < digit)
      largest_digit = digit;
    nd = n * base + digit;
    overflow |= (max_over_base < n) | (nd < n);
    n = nd;
  }

  if (base <= largest_digit)
    pedwarn ("integer constant contains digits beyond the radix");

  if (overflow)
    pedwarn ("integer constant out of range");

  /* If too big to be signed, consider it unsigned.  */
  if (((HOST_WIDE_INT) n & yylval.integer.signedp) < 0)
    {
      if (base == 10)
	warning ("integer constant is so large that it is unsigned");
      yylval.integer.signedp = UNSIGNED;
    }

  lexptr = p;
  yylval.integer.value = n;
  return INT;
}

struct token {
  char *operator;
  int token;
};

static struct token tokentab2[] = {
  {"&&", AND},
  {"||", OR},
  {"<<", LSH},
  {">>", RSH},
  {"==", EQUAL},
  {"!=", NOTEQUAL},
  {"<=", LEQ},
  {">=", GEQ},
  {"++", ERROR},
  {"--", ERROR},
  {NULL, ERROR}
};

/* Read one token, getting characters through lexptr.  */

static int
yylex ()
{
  register int c;
  register int namelen;
  register unsigned char *tokstart;
  register struct token *toktab;
  int wide_flag;
  HOST_WIDE_INT mask;

 retry:

  tokstart = (unsigned char *) lexptr;
  c = *tokstart;
  /* See if it is a special token of length 2.  */
  if (! keyword_parsing)
    for (toktab = tokentab2; toktab->operator != NULL; toktab++)
      if (c == *toktab->operator && tokstart[1] == toktab->operator[1]) {
	lexptr += 2;
	if (toktab->token == ERROR)
	  {
	    char *buf = (char *) alloca (40);
	    sprintf (buf, "`%s' not allowed in operand of `#if'", toktab->operator);
	    yyerror (buf);
	  }
	return toktab->token;
      }

  switch (c) {
  case '\n':
    return 0;
    
  case ' ':
  case '\t':
  case '\r':
    lexptr++;
    goto retry;
    
  case 'L':
    /* Capital L may start a wide-string or wide-character constant.  */
    if (lexptr[1] == '\'')
      {
	lexptr++;
	wide_flag = 1;
	mask = MAX_WCHAR_TYPE_MASK;
	goto char_constant;
      }
    if (lexptr[1] == '"')
      {
	lexptr++;
	wide_flag = 1;
	mask = MAX_WCHAR_TYPE_MASK;
	goto string_constant;
      }
    break;

  case '\'':
    wide_flag = 0;
    mask = MAX_CHAR_TYPE_MASK;
  char_constant:
    lexptr++;
    if (keyword_parsing) {
      char *start_ptr = lexptr - 1;
      while (1) {
	c = *lexptr++;
	if (c == '\\')
	  c = parse_escape (&lexptr, mask);
	else if (c == '\'')
	  break;
      }
      yylval.name.address = tokstart;
      yylval.name.length = lexptr - start_ptr;
      return NAME;
    }

    /* This code for reading a character constant
       handles multicharacter constants and wide characters.
       It is mostly copied from c-lex.c.  */
    {
      register HOST_WIDE_INT result = 0;
      register int num_chars = 0;
      unsigned width = MAX_CHAR_TYPE_SIZE;
      int max_chars;
      char *token_buffer;

      if (wide_flag)
	{
	  width = MAX_WCHAR_TYPE_SIZE;
#ifdef MULTIBYTE_CHARS
	  max_chars = MB_CUR_MAX;
#else
	  max_chars = 1;
#endif
	}
      else
	max_chars = MAX_LONG_TYPE_SIZE / width;

      token_buffer = (char *) alloca (max_chars + 1);

      while (1)
	{
	  c = *lexptr++;

	  if (c == '\'' || c == EOF)
	    break;

	  if (c == '\\')
	    {
	      c = parse_escape (&lexptr, mask);
	    }

	  num_chars++;

	  /* Merge character into result; ignore excess chars.  */
	  if (num_chars <= max_chars)
	    {
	      if (width < HOST_BITS_PER_WIDE_INT)
		result = (result << width) | c;
	      else
		result = c;
	      token_buffer[num_chars - 1] = c;
	    }
	}

      token_buffer[num_chars] = 0;

      if (c != '\'')
	error ("malformatted character constant");
      else if (num_chars == 0)
	error ("empty character constant");
      else if (num_chars > max_chars)
	{
	  num_chars = max_chars;
	  error ("character constant too long");
	}
      else if (num_chars != 1 && ! traditional)
	warning ("multi-character character constant");

      /* If char type is signed, sign-extend the constant.  */
      if (! wide_flag)
	{
	  int num_bits = num_chars * width;

	  if (lookup ((U_CHAR *) "__CHAR_UNSIGNED__",
		      sizeof ("__CHAR_UNSIGNED__") - 1, -1)
	      || ((result >> (num_bits - 1)) & 1) == 0)
	    yylval.integer.value
	      = result & (~ (unsigned_HOST_WIDE_INT) 0
			  >> (HOST_BITS_PER_WIDE_INT - num_bits));
	  else
	    yylval.integer.value
	      = result | ~(~ (unsigned_HOST_WIDE_INT) 0
			   >> (HOST_BITS_PER_WIDE_INT - num_bits));
	}
      else
	{
#ifdef MULTIBYTE_CHARS
	  /* Set the initial shift state and convert the next sequence.  */
	  result = 0;
	  /* In all locales L'\0' is zero and mbtowc will return zero,
	     so don't use it.  */
	  if (num_chars > 1
	      || (num_chars == 1 && token_buffer[0] != '\0'))
	    {
	      wchar_t wc;
	      (void) mbtowc (NULL_PTR, NULL_PTR, 0);
	      if (mbtowc (& wc, token_buffer, num_chars) == num_chars)
		result = wc;
	      else
		pedwarn ("Ignoring invalid multibyte character");
	    }
#endif
	  yylval.integer.value = result;
	}
    }

    /* This is always a signed type.  */
    yylval.integer.signedp = SIGNED;
    
    return CHAR;

    /* some of these chars are invalid in constant expressions;
       maybe do something about them later */
  case '/':
  case '+':
  case '-':
  case '*':
  case '%':
  case '|':
  case '&':
  case '^':
  case '~':
  case '!':
  case '@@':
  case '<':
  case '>':
  case '[':
  case ']':
  case '.':
  case '?':
  case ':':
  case '=':
  case '{':
  case '}':
  case ',':
  case '#':
    if (keyword_parsing)
      break;
  case '(':
  case ')':
    lexptr++;
    return c;

  case '"':
    mask = MAX_CHAR_TYPE_MASK;
  string_constant:
    if (keyword_parsing) {
      char *start_ptr = lexptr;
      lexptr++;
      while (1) {
	c = *lexptr++;
	if (c == '\\')
	  c = parse_escape (&lexptr, mask);
	else if (c == '"')
	  break;
      }
      yylval.name.address = tokstart;
      yylval.name.length = lexptr - start_ptr;
      return NAME;
    }
    yyerror ("string constants not allowed in #if expressions");
    return ERROR;
  }

  if (c >= '0' && c <= '9' && !keyword_parsing) {
    /* It's a number */
    for (namelen = 1; ; namelen++) {
      int d = tokstart[namelen];
      if (! ((is_idchar[d] || d == '.')
	     || ((d == '-' || d == '+')
		 && (c == 'e' || c == 'E'
		     || ((c == 'p' || c == 'P') && ! c89))
		 && ! traditional)))
	break;
      c = d;
    }
    return parse_number (namelen);
  }

  /* It is a name.  See how long it is.  */

  if (keyword_parsing) {
    for (namelen = 0;; namelen++) {
      if (is_space[tokstart[namelen]])
	break;
      if (tokstart[namelen] == '(' || tokstart[namelen] == ')')
	break;
      if (tokstart[namelen] == '"' || tokstart[namelen] == '\'')
	break;
    }
  } else {
    if (!is_idstart[c]) {
      yyerror ("Invalid token in expression");
      return ERROR;
    }

    for (namelen = 0; is_idchar[tokstart[namelen]]; namelen++)
      ;
  }
  
  lexptr += namelen;
  yylval.name.address = tokstart;
  yylval.name.length = namelen;
  return NAME;
}


/* Parse a C escape sequence.  STRING_PTR points to a variable
   containing a pointer to the string to parse.  That pointer
   is updated past the characters we use.  The value of the
   escape sequence is returned.

   RESULT_MASK is used to mask out the result;
   an error is reported if bits are lost thereby.

   A negative value means the sequence \ newline was seen,
   which is supposed to be equivalent to nothing at all.

   If \ is followed by a null character, we return a negative
   value and leave the string pointer pointing at the null character.

   If \ is followed by 000, we return 0 and leave the string pointer
   after the zeros.  A value of 0 does not mean end of string.  */

HOST_WIDE_INT
parse_escape (string_ptr, result_mask)
     char **string_ptr;
     HOST_WIDE_INT result_mask;
{
  register int c = *(*string_ptr)++;
  switch (c)
    {
    case 'a':
      return TARGET_BELL;
    case 'b':
      return TARGET_BS;
    case 'e':
    case 'E':
      if (pedantic)
	pedwarn ("non-ANSI-standard escape sequence, `\\%c'", c);
      return 033;
    case 'f':
      return TARGET_FF;
    case 'n':
      return TARGET_NEWLINE;
    case 'r':
      return TARGET_CR;
    case 't':
      return TARGET_TAB;
    case 'v':
      return TARGET_VT;
    case '\n':
      return -2;
    case 0:
      (*string_ptr)--;
      return 0;
      
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
      {
	register HOST_WIDE_INT i = c - '0';
	register int count = 0;
	while (++count < 3)
	  {
	    c = *(*string_ptr)++;
	    if (c >= '0' && c <= '7')
	      i = (i << 3) + c - '0';
	    else
	      {
		(*string_ptr)--;
		break;
	      }
	  }
	if (i != (i & result_mask))
	  {
	    i &= result_mask;
	    pedwarn ("octal escape sequence out of range");
	  }
	return i;
      }
    case 'x':
      {
	register unsigned_HOST_WIDE_INT i = 0, overflow = 0;
	register int digits_found = 0, digit;
	for (;;)
	  {
	    c = *(*string_ptr)++;
	    if (c >= '0' && c <= '9')
	      digit = c - '0';
	    else if (c >= 'a' && c <= 'f')
	      digit = c - 'a' + 10;
	    else if (c >= 'A' && c <= 'F')
	      digit = c - 'A' + 10;
	    else
	      {
		(*string_ptr)--;
		break;
	      }
	    overflow |= i ^ (i << 4 >> 4);
	    i = (i << 4) + digit;
	    digits_found = 1;
	  }
	if (!digits_found)
	  yyerror ("\\x used with no following hex digits");
	if (overflow | (i != (i & result_mask)))
	  {
	    i &= result_mask;
	    pedwarn ("hex escape sequence out of range");
	  }
	return i;
      }
    default:
      return c;
    }
}

static void
yyerror (s)
     char *s;
{
  error ("%s", s);
  skip_evaluation = 0;
  longjmp (parse_return_error, 1);
}

static void
integer_overflow ()
{
  if (!skip_evaluation && pedantic)
    pedwarn ("integer overflow in preprocessor expression");
}

static HOST_WIDE_INT
left_shift (a, b)
     struct constant *a;
     unsigned_HOST_WIDE_INT b;
{
   /* It's unclear from the C standard whether shifts can overflow.
      The following code ignores overflow; perhaps a C standard
      interpretation ruling is needed.  */
  if (b >= HOST_BITS_PER_WIDE_INT)
    return 0;
  else
    return (unsigned_HOST_WIDE_INT) a->value << b;
}

static HOST_WIDE_INT
right_shift (a, b)
     struct constant *a;
     unsigned_HOST_WIDE_INT b;
{
  if (b >= HOST_BITS_PER_WIDE_INT)
    return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;
  else if (a->signedp)
    return a->value >> b;
  else
    return (unsigned_HOST_WIDE_INT) a->value >> b;
}

/* This page contains the entry point to this file.  */

/* Parse STRING as an expression, and complain if this fails
   to use up all of the contents of STRING.
   STRING may contain '\0' bytes; it is terminated by the first '\n'
   outside a string constant, so that we can diagnose '\0' properly.
   If WARN_UNDEFINED is nonzero, warn if undefined identifiers are evaluated.
   We do not support C comments.  They should be removed before
   this function is called.  */

HOST_WIDE_INT
parse_c_expression (string, warn_undefined)
     char *string;
     int warn_undefined;
{
  lexptr = string;
  warn_undef = warn_undefined;

  /* if there is some sort of scanning error, just return 0 and assume
     the parsing routine has printed an error message somewhere.
     there is surely a better thing to do than this.     */
  if (setjmp (parse_return_error))
    return 0;

  if (yyparse () != 0)
    abort ();

  if (*lexptr != '\n')
    error ("Junk after end of expression.");

  return expression_value;	/* set by yyparse () */
}

#ifdef TEST_EXP_READER

#if YYDEBUG
extern int yydebug;
#endif

int pedantic;
int traditional;

int main PROTO((int, char **));
static void initialize_random_junk PROTO((void));
static void print_unsigned_host_wide_int PROTO((unsigned_HOST_WIDE_INT));

/* Main program for testing purposes.  */
int
main (argc, argv)
     int argc;
     char **argv;
{
  int n, c;
  char buf[1024];
  unsigned_HOST_WIDE_INT u;

  pedantic = 1 < argc;
  traditional = 2 < argc;
#if YYDEBUG
  yydebug = 3 < argc;
#endif
  initialize_random_junk ();

  for (;;) {
    printf ("enter expression: ");
    n = 0;
    while ((buf[n] = c = getchar ()) != '\n' && c != EOF)
      n++;
    if (c == EOF)
      break;
    parse_c_expression (buf, 1);
    printf ("parser returned ");
    u = (unsigned_HOST_WIDE_INT) expression_value;
    if (expression_value < 0 && expression_signedp) {
      u = -u;
      printf ("-");
    }
    if (u == 0)
      printf ("0");
    else
      print_unsigned_host_wide_int (u);
    if (! expression_signedp)
      printf("u");
    printf ("\n");
  }

  return 0;
}

static void
print_unsigned_host_wide_int (u)
     unsigned_HOST_WIDE_INT u;
{
  if (u) {
    print_unsigned_host_wide_int (u / 10);
    putchar ('0' + (int) (u % 10));
  }
}

/* table to tell if char can be part of a C identifier. */
unsigned char is_idchar[256];
/* table to tell if char can be first char of a c identifier. */
unsigned char is_idstart[256];
/* table to tell if c is horizontal or vertical space.  */
unsigned char is_space[256];

/*
 * initialize random junk in the hash table and maybe other places
 */
static void
initialize_random_junk ()
{
  register int i;

  /*
   * Set up is_idchar and is_idstart tables.  These should be
   * faster than saying (is_alpha (c) || c == '_'), etc.
   * Must do set up these things before calling any routines tthat
   * refer to them.
   */
  for (i = 'a'; i <= 'z'; i++) {
    ++is_idchar[i - 'a' + 'A'];
    ++is_idchar[i];
    ++is_idstart[i - 'a' + 'A'];
    ++is_idstart[i];
  }
  for (i = '0'; i <= '9'; i++)
    ++is_idchar[i];
  ++is_idchar['_'];
  ++is_idstart['_'];
  ++is_idchar['$'];
  ++is_idstart['$'];

  ++is_space[' '];
  ++is_space['\t'];
  ++is_space['\v'];
  ++is_space['\f'];
  ++is_space['\n'];
  ++is_space['\r'];
}

void
error (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
{
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "error: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
}

void
pedwarn (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
{
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "pedwarn: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
}

void
warning (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
{
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "warning: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
}

int
check_assertion (name, sym_length, tokens_specified, tokens)
     U_CHAR *name;
     int sym_length;
     int tokens_specified;
     struct arglist *tokens;
{
  return 0;
}

struct hashnode *
lookup (name, len, hash)
     U_CHAR *name;
     int len;
     int hash;
{
  return (DEFAULT_SIGNED_CHAR) ? 0 : ((struct hashnode *) -1);
}

GENERIC_PTR
xmalloc (size)
     size_t size;
{
  return (GENERIC_PTR) malloc (size);
}
#endif
@


1.2
log
@GCC 2.8.0 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1992, 1994, 1995 Free Software Foundation.
d32 13
a45 1
#include <stdlib.h>
d75 32
a106 1
/* Find the largest host integer type and set its size and type.  */
d109 2
d112 2
a113 6
#if HOST_BITS_PER_LONG > HOST_BITS_PER_INT
#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_LONG
#define HOST_WIDE_INT long
#else
#define HOST_BITS_PER_WIDE_INT HOST_BITS_PER_INT
#define HOST_WIDE_INT int
d116 6
d124 20
a143 2
#ifndef NULL_PTR
#define NULL_PTR ((GENERIC_PTR)0)
d146 10
a155 3
int yylex ();
void yyerror ();
HOST_WIDE_INT expression_value;
d166 3
d170 1
a170 3
extern unsigned char is_idstart[], is_idchar[], is_hor_space[];

extern char *xmalloc ();
d178 3
d213 36
a248 7
/* Yield nonzero if adding two numbers with A's and B's signs can yield a
   number with SUM's sign, where A, B, and SUM are all C integers.  */
#define possible_sum_sign(a, b, sum) ((((a) ^ (b)) | ~ ((a) ^ (sum))) < 0)

static void integer_overflow ();
static long left_shift ();
static long right_shift ();
d252 1
a252 1
  struct constant {long value; int unsignedp;} integer;
d282 6
a287 1
		{ expression_value = $1.value; }
d301 3
a303 3
			  if (($$.value & $2.value) < 0 && ! $2.unsignedp)
			    integer_overflow ();
			  $$.unsignedp = $2.unsignedp; }
d306 1
a306 1
			  $$.unsignedp = 0; }
d311 1
a311 1
			  $$.unsignedp = $2.unsignedp; }
d315 1
a315 1
			  $$.unsignedp = 0; }
d322 1
a322 1
			  $$.unsignedp = 0; }
d329 2
a330 4
			{ $$.unsignedp = $1.unsignedp || $3.unsignedp;
			  if ($$.unsignedp)
			    $$.value = (unsigned long) $1.value * $3.value;
			  else
d337 4
a340 1
			    } }
d348 2
a349 4
			  $$.unsignedp = $1.unsignedp || $3.unsignedp;
			  if ($$.unsignedp)
			    $$.value = (unsigned long) $1.value / $3.value;
			  else
d354 4
a357 1
			    } }
d365 3
a367 3
			  $$.unsignedp = $1.unsignedp || $3.unsignedp;
			  if ($$.unsignedp)
			    $$.value = (unsigned long) $1.value % $3.value;
d369 2
a370 1
			    $$.value = $1.value % $3.value; }
d373 3
a375 4
			  $$.unsignedp = $1.unsignedp || $3.unsignedp;
			  if (! $$.unsignedp
			      && ! possible_sum_sign ($1.value, $3.value,
						      $$.value))
d379 3
a381 4
			  $$.unsignedp = $1.unsignedp || $3.unsignedp;
			  if (! $$.unsignedp
			      && ! possible_sum_sign ($$.value, $3.value,
						      $1.value))
d384 2
a385 2
			{ $$.unsignedp = $1.unsignedp;
			  if ($3.value < 0 && ! $3.unsignedp)
d390 2
a391 2
			{ $$.unsignedp = $1.unsignedp;
			  if ($3.value < 0 && ! $3.unsignedp)
d397 1
a397 1
			  $$.unsignedp = 0; }
d400 1
a400 1
			  $$.unsignedp = 0; }
d402 3
a404 3
			{ $$.unsignedp = 0;
			  if ($1.unsignedp || $3.unsignedp)
			    $$.value = (unsigned long) $1.value <= $3.value;
d406 2
a407 1
			    $$.value = $1.value <= $3.value; }
d409 3
a411 3
			{ $$.unsignedp = 0;
			  if ($1.unsignedp || $3.unsignedp)
			    $$.value = (unsigned long) $1.value >= $3.value;
d413 2
a414 1
			    $$.value = $1.value >= $3.value; }
d416 3
a418 3
			{ $$.unsignedp = 0;
			  if ($1.unsignedp || $3.unsignedp)
			    $$.value = (unsigned long) $1.value < $3.value;
d420 2
a421 1
			    $$.value = $1.value < $3.value; }
d423 3
a425 3
			{ $$.unsignedp = 0;
			  if ($1.unsignedp || $3.unsignedp)
			    $$.value = (unsigned long) $1.value > $3.value;
d427 2
a428 1
			    $$.value = $1.value > $3.value; }
d431 1
a431 1
			  $$.unsignedp = $1.unsignedp || $3.unsignedp; }
d434 1
a434 1
			  $$.unsignedp = $1.unsignedp || $3.unsignedp; }
d437 1
a437 1
			  $$.unsignedp = $1.unsignedp || $3.unsignedp; }
d443 1
a443 1
			  $$.unsignedp = 0; }
d449 1
a449 1
			  $$.unsignedp = 0; }
d457 1
a457 1
			  $$.unsignedp = $4.unsignedp || $7.unsignedp; }
d463 5
a467 2
			{ $$.value = 0;
			  $$.unsignedp = 0; }
d504 1
a504 1
int
d510 1
a510 1
  register unsigned long n = 0, nd, ULONG_MAX_over_base;
d517 8
a524 5
  for (c = 0; c < len; c++)
    if (p[c] == '.') {
      /* It's a float since it contains a point.  */
      yyerror ("floating point numbers not allowed in #if expressions");
      return ERROR;
a525 7

  yylval.integer.unsignedp = 0;

  if (len >= 3 && (!strncmp (p, "0x", 2) || !strncmp (p, "0X", 2))) {
    p += 2;
    base = 16;
    len -= 2;
a526 2
  else if (*p == '0')
    base = 8;
d528 1
a528 1
  ULONG_MAX_over_base = (unsigned long) -1 / base;
d544 3
a546 3
	    if (spec_long)
	      yyerror ("two `l's in integer constant");
	    spec_long = 1;
d550 1
a550 1
	    if (yylval.integer.unsignedp)
d552 10
a561 1
	    yylval.integer.unsignedp = 1;
d563 1
a563 2
	else
	  break;
d575 1
a575 1
    overflow |= ULONG_MAX_over_base < n | nd < n;
a578 5
  if (len != 0) {
    yyerror ("Invalid number in #if expression");
    return ERROR;
  }

d580 1
a580 1
    warning ("integer constant contains digits beyond the radix");
d583 1
a583 1
    warning ("integer constant out of range");
d586 1
a586 1
  if ((long) n < 0 && ! yylval.integer.unsignedp)
d590 1
a590 1
      yylval.integer.unsignedp = 1;
d619 1
a619 1
int
d627 1
d648 1
a648 1
  case 0:
a653 1
  case '\n':
d663 1
d670 1
d677 1
d685 1
a685 1
	  c = parse_escape (&lexptr);
d698 2
a699 2
      register int result = 0;
      register num_chars = 0;
d727 1
a727 4
	      c = parse_escape (&lexptr);
	      if (width < HOST_BITS_PER_INT
		  && (unsigned) c >= (1 << width))
		pedwarn ("escape sequence out of range for character");
d733 1
a733 1
	  if (num_chars < max_chars + 1)
d735 2
a736 2
	      if (width < HOST_BITS_PER_INT)
		result = (result << width) | (c & ((1 << width) - 1));
d762 2
a763 1
	  if (lookup ("__CHAR_UNSIGNED__", sizeof ("__CHAR_UNSIGNED__")-1, -1)
d766 2
a767 1
	      = result & ((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));
d770 2
a771 1
	      = result | ~((unsigned long) ~0 >> (HOST_BITS_PER_LONG - num_bits));
d788 1
a788 1
		warning ("Ignoring invalid multibyte character");
d796 1
a796 1
    yylval.integer.unsignedp = 0;
d833 1
d841 1
a841 1
	  c = parse_escape (&lexptr);
d855 10
a864 4
    for (namelen = 0;
	 c = tokstart[namelen], is_idchar[c] || c == '.'; 
	 namelen++)
      ;
d872 1
a872 1
      if (is_hor_space[tokstart[namelen]])
d901 3
d913 2
a914 2
int
parse_escape (string_ptr)
d916 1
d955 1
a955 1
	register int i = c - '0';
d968 1
a968 1
	if ((i & ~((1 << MAX_CHAR_TYPE_SIZE) - 1)) != 0)
d970 2
a971 2
	    i &= (1 << MAX_CHAR_TYPE_SIZE) - 1;
	    warning ("octal character constant does not fit in a byte");
d977 2
a978 1
	register unsigned i = 0, overflow = 0, digits_found = 0, digit;
d999 1
a999 1
	if (overflow | (i & ~((1 << BITS_PER_UNIT) - 1)))
d1001 2
a1002 2
	    i &= (1 << BITS_PER_UNIT) - 1;
	    warning ("hex character constant does not fit in a byte");
d1011 1
a1011 1
void
d1015 1
a1015 1
  error (s);
d1027 1
a1027 1
static long
d1030 1
a1030 1
     unsigned long b;
d1035 1
a1035 1
  if (b >= HOST_BITS_PER_LONG)
a1036 2
  else if (a->unsignedp)
    return (unsigned long) a->value << b;
d1038 1
a1038 1
    return a->value << b;
d1041 1
a1041 1
static long
d1044 1
a1044 1
     unsigned long b;
d1046 4
a1049 4
  if (b >= HOST_BITS_PER_LONG)
    return a->unsignedp ? 0 : a->value >> (HOST_BITS_PER_LONG - 1);
  else if (a->unsignedp)
    return (unsigned long) a->value >> b;
d1051 1
a1051 1
    return a->value >> b;
d1057 5
a1061 2
   to use up all of the contents of STRING.  */
/* We do not support C comments.  They should be removed before
d1065 1
a1065 1
parse_c_expression (string)
d1067 1
d1070 1
a1070 5
  
  if (lexptr == 0 || *lexptr == 0) {
    error ("empty #if expression");
    return 0;			/* don't include the #if group */
  }
d1078 4
a1081 4
  if (yyparse ())
    return 0;			/* actually this is never reached
				   the way things stand. */
  if (*lexptr)
d1088 2
d1091 8
d1102 3
a1104 1
main ()
d1108 1
d1110 5
a1114 3
/*
  yydebug = 1;
*/
d1120 1
a1120 1
    while ((buf[n] = getchar ()) != '\n' && buf[n] != EOF)
d1122 1
a1122 1
    if (buf[n] == EOF)
d1124 14
a1137 2
    buf[n] = '\0';
    printf ("parser returned %ld\n", parse_c_expression (buf));
d1143 10
d1157 2
a1158 3
/* table to tell if c is horizontal space.  isspace () thinks that
   newline is space; this is not a good idea for this program. */
char is_hor_space[256];
d1163 1
a1183 1
#if DOLLARS_IN_IDENTIFIERS
a1185 1
#endif
d1187 32
a1218 3
  /* horizontal space table */
  ++is_hor_space[' '];
  ++is_hor_space['\t'];
d1221 3
a1223 1
error (msg)
d1225 7
a1231 1
  printf ("error: %s\n", msg);
d1234 6
a1239 1
warning (msg)
d1241 1
a1241 1
  printf ("warning: %s\n", msg);
d1246 1
a1246 1
     char *name;
d1251 7
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1987, 1992, 1994, 1995, 1996, 1997 Free Software Foundation.
a31 13

#ifdef HAVE_STRING_H
# include <string.h>
#endif

#ifdef HAVE_STDLIB_H
# include <stdlib.h>
#endif

#ifdef HAVE_LIMITS_H
# include <limits.h>
#endif

d33 1
d63 1
a63 32
#ifndef NULL_PTR
#define NULL_PTR ((GENERIC_PTR) 0)
#endif

/* Find the largest host integer type and set its size and type.
   Watch out: on some crazy hosts `long' is shorter than `int'.  */

#ifndef HOST_WIDE_INT
# if HAVE_INTTYPES_H
#  include <inttypes.h>
#  define HOST_WIDE_INT intmax_t
#  define unsigned_HOST_WIDE_INT uintmax_t
# else
#  if (HOST_BITS_PER_LONG <= HOST_BITS_PER_INT && HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_INT)
#   define HOST_WIDE_INT int
#  else
#  if (HOST_BITS_PER_LONGLONG <= HOST_BITS_PER_LONG || ! (defined LONG_LONG_MAX || defined LLONG_MAX))
#   define HOST_WIDE_INT long
#  else
#   define HOST_WIDE_INT long long
#  endif
#  endif
# endif
#endif

#ifndef unsigned_HOST_WIDE_INT
#define unsigned_HOST_WIDE_INT unsigned HOST_WIDE_INT
#endif

#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif
a65 2
#define HOST_BITS_PER_WIDE_INT (CHAR_BIT * sizeof (HOST_WIDE_INT))
#endif
d67 6
a72 2
#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
# define __attribute__(x)
a74 6
#ifndef PROTO
# if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
#  define PROTO(ARGS) ARGS
# else
#  define PROTO(ARGS) ()
# endif
d77 2
a78 20
#if defined (__STDC__) && defined (HAVE_VPRINTF)
# include <stdarg.h>
# define VA_START(va_list, var) va_start (va_list, var)
# define PRINTF_ALIST(msg) char *msg, ...
# define PRINTF_DCL(msg)
# define PRINTF_PROTO(ARGS, m, n) PROTO (ARGS) __attribute__ ((format (__printf__, m, n)))
#else
# include <varargs.h>
# define VA_START(va_list, var) va_start (va_list)
# define PRINTF_ALIST(msg) msg, va_alist
# define PRINTF_DCL(msg) char *msg; va_dcl
# define PRINTF_PROTO(ARGS, m, n) () __attribute__ ((format (__printf__, m, n)))
# define vfprintf(file, msg, args) \
    { \
      char *a0 = va_arg(args, char *); \
      char *a1 = va_arg(args, char *); \
      char *a2 = va_arg(args, char *); \
      char *a3 = va_arg(args, char *); \
      fprintf (file, msg, a0, a1, a2, a3); \
    }
d81 3
a83 10
#define PRINTF_PROTO_1(ARGS) PRINTF_PROTO(ARGS, 1, 2)

HOST_WIDE_INT parse_c_expression PROTO((char *, int));

static int yylex PROTO((void));
static void yyerror PROTO((char *)) __attribute__ ((noreturn));
static HOST_WIDE_INT expression_value;
#ifdef TEST_EXP_READER
static int expression_signedp;
#endif
d94 2
a95 2
/* Nonzero means warn if undefined identifiers are evaluated.  */
static int warn_undef;
d97 1
a97 2
/* some external tables of character types */
extern unsigned char is_idstart[], is_idchar[], is_space[];
a104 3
/* Flag for -lang-c89.  */
extern int c89;

d137 7
a143 36
#define MAX_CHAR_TYPE_MASK (MAX_CHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \
			    ? (~ (~ (HOST_WIDE_INT) 0 << MAX_CHAR_TYPE_SIZE)) \
			    : ~ (HOST_WIDE_INT) 0)

#define MAX_WCHAR_TYPE_MASK (MAX_WCHAR_TYPE_SIZE < HOST_BITS_PER_WIDE_INT \
			     ? ~ (~ (HOST_WIDE_INT) 0 << MAX_WCHAR_TYPE_SIZE) \
			     : ~ (HOST_WIDE_INT) 0)

/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.
   Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.
   Suppose SIGNEDP is negative if the result is signed, zero if unsigned.
   Then this yields nonzero if overflow occurred during the addition.
   Overflow occurs if A and B have the same sign, but A and SUM differ in sign,
   and SIGNEDP is negative.
   Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */
#define overflow_sum_sign(a, b, sum, signedp) \
	((~((a) ^ (b)) & ((a) ^ (sum)) & (signedp)) < 0)

struct constant;

GENERIC_PTR xmalloc PROTO((size_t));
HOST_WIDE_INT parse_escape PROTO((char **, HOST_WIDE_INT));
int check_assertion PROTO((U_CHAR *, int, int, struct arglist *));
struct hashnode *lookup PROTO((U_CHAR *, int, int));
void error PRINTF_PROTO_1((char *, ...));
void pedwarn PRINTF_PROTO_1((char *, ...));
void warning PRINTF_PROTO_1((char *, ...));

static int parse_number PROTO((int));
static HOST_WIDE_INT left_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));
static HOST_WIDE_INT right_shift PROTO((struct constant *, unsigned_HOST_WIDE_INT));
static void integer_overflow PROTO((void));

/* `signedp' values */
#define SIGNED (~0)
#define UNSIGNED 0
d147 1
a147 1
  struct constant {HOST_WIDE_INT value; int signedp;} integer;
d177 1
a177 6
		{
		  expression_value = $1.value;
#ifdef TEST_EXP_READER
		  expression_signedp = $1.signedp;
#endif
		}
d191 3
a193 3
			  $$.signedp = $2.signedp;
			  if (($$.value & $2.value & $$.signedp) < 0)
			    integer_overflow (); }
d196 1
a196 1
			  $$.signedp = SIGNED; }
d201 1
a201 1
			  $$.signedp = $2.signedp; }
d205 1
a205 1
			  $$.signedp = SIGNED; }
d212 1
a212 1
			  $$.signedp = SIGNED; }
d219 4
a222 2
			{ $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
d229 1
a229 4
			    }
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					* $3.value); }
d237 4
a240 2
			  $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
d245 1
a245 4
			    }
			  else
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					/ $3.value); }
d253 3
a255 3
			  $$.signedp = $1.signedp & $3.signedp;
			  if ($$.signedp)
			    $$.value = $1.value % $3.value;
d257 1
a257 2
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					% $3.value); }
d260 4
a263 3
			  $$.signedp = $1.signedp & $3.signedp;
			  if (overflow_sum_sign ($1.value, $3.value,
						 $$.value, $$.signedp))
d267 4
a270 3
			  $$.signedp = $1.signedp & $3.signedp;
			  if (overflow_sum_sign ($$.value, $3.value,
						 $1.value, $$.signedp))
d273 2
a274 2
			{ $$.signedp = $1.signedp;
			  if (($3.value & $3.signedp) < 0)
d279 2
a280 2
			{ $$.signedp = $1.signedp;
			  if (($3.value & $3.signedp) < 0)
d286 1
a286 1
			  $$.signedp = SIGNED; }
d289 1
a289 1
			  $$.signedp = SIGNED; }
d291 3
a293 3
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value <= $3.value;
d295 1
a295 2
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					<= $3.value); }
d297 3
a299 3
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value >= $3.value;
d301 1
a301 2
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					>= $3.value); }
d303 3
a305 3
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value < $3.value;
d307 1
a307 2
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					< $3.value); }
d309 3
a311 3
			{ $$.signedp = SIGNED;
			  if ($1.signedp & $3.signedp)
			    $$.value = $1.value > $3.value;
d313 1
a313 2
			    $$.value = ((unsigned_HOST_WIDE_INT) $1.value
					> $3.value); }
d316 1
a316 1
			  $$.signedp = $1.signedp & $3.signedp; }
d319 1
a319 1
			  $$.signedp = $1.signedp & $3.signedp; }
d322 1
a322 1
			  $$.signedp = $1.signedp & $3.signedp; }
d328 1
a328 1
			  $$.signedp = SIGNED; }
d334 1
a334 1
			  $$.signedp = SIGNED; }
d342 1
a342 1
			  $$.signedp = $4.signedp & $7.signedp; }
d348 2
a349 5
			{ if (warn_undef && !skip_evaluation)
			    warning ("`%.*s' is not defined",
				     $1.length, $1.address);
			  $$.value = 0;
			  $$.signedp = SIGNED; }
d386 1
a386 1
static int
d392 1
a392 1
  register unsigned_HOST_WIDE_INT n = 0, nd, max_over_base;
d399 8
a406 1
  yylval.integer.signedp = SIGNED;
d408 6
a413 1
  if (*p == '0') {
a414 6
    if (len >= 3 && (p[1] == 'x' || p[1] == 'X')) {
      p += 2;
      base = 16;
      len -= 2;
    }
  }
d416 1
a416 1
  max_over_base = (unsigned_HOST_WIDE_INT) -1 / base;
d432 3
a434 3
	    if (!pedantic < spec_long)
	      yyerror ("too many `l's in integer constant");
	    spec_long++;
d438 1
a438 1
	    if (! yylval.integer.signedp)
d440 1
a440 1
	    yylval.integer.signedp = UNSIGNED;
d442 2
a443 10
	else {
	  if (c == '.' || c == 'e' || c == 'E' || c == 'p' || c == 'P')
	    yyerror ("Floating point numbers not allowed in #if expressions");
	  else {
	    char *buf = (char *) alloca (p - lexptr + 40);
	    sprintf (buf, "missing white space after number `%.*s'",
		     (int) (p - lexptr - 1), lexptr);
	    yyerror (buf);
	  }
	}
d455 1
a455 1
    overflow |= (max_over_base < n) | (nd < n);
d459 5
d465 1
a465 1
    pedwarn ("integer constant contains digits beyond the radix");
d468 1
a468 1
    pedwarn ("integer constant out of range");
d471 1
a471 1
  if (((HOST_WIDE_INT) n & yylval.integer.signedp) < 0)
d475 1
a475 1
      yylval.integer.signedp = UNSIGNED;
d504 1
a504 1
static int
a511 1
  HOST_WIDE_INT mask;
d532 1
a532 1
  case '\n':
d538 1
a547 1
	mask = MAX_WCHAR_TYPE_MASK;
a553 1
	mask = MAX_WCHAR_TYPE_MASK;
a559 1
    mask = MAX_CHAR_TYPE_MASK;
d567 1
a567 1
	  c = parse_escape (&lexptr, mask);
d580 2
a581 2
      register HOST_WIDE_INT result = 0;
      register int num_chars = 0;
d609 4
a612 1
	      c = parse_escape (&lexptr, mask);
d618 1
a618 1
	  if (num_chars <= max_chars)
d620 2
a621 2
	      if (width < HOST_BITS_PER_WIDE_INT)
		result = (result << width) | c;
d647 1
a647 2
	  if (lookup ((U_CHAR *) "__CHAR_UNSIGNED__",
		      sizeof ("__CHAR_UNSIGNED__") - 1, -1)
d650 1
a650 2
	      = result & (~ (unsigned_HOST_WIDE_INT) 0
			  >> (HOST_BITS_PER_WIDE_INT - num_bits));
d653 1
a653 2
	      = result | ~(~ (unsigned_HOST_WIDE_INT) 0
			   >> (HOST_BITS_PER_WIDE_INT - num_bits));
d670 1
a670 1
		pedwarn ("Ignoring invalid multibyte character");
d678 1
a678 1
    yylval.integer.signedp = SIGNED;
a714 1
    mask = MAX_CHAR_TYPE_MASK;
d722 1
a722 1
	  c = parse_escape (&lexptr, mask);
d736 4
a739 10
    for (namelen = 1; ; namelen++) {
      int d = tokstart[namelen];
      if (! ((is_idchar[d] || d == '.')
	     || ((d == '-' || d == '+')
		 && (c == 'e' || c == 'E'
		     || ((c == 'p' || c == 'P') && ! c89))
		 && ! traditional)))
	break;
      c = d;
    }
d747 1
a747 1
      if (is_space[tokstart[namelen]])
a775 3
   RESULT_MASK is used to mask out the result;
   an error is reported if bits are lost thereby.

d785 2
a786 2
HOST_WIDE_INT
parse_escape (string_ptr, result_mask)
a787 1
     HOST_WIDE_INT result_mask;
d826 1
a826 1
	register HOST_WIDE_INT i = c - '0';
d839 1
a839 1
	if (i != (i & result_mask))
d841 2
a842 2
	    i &= result_mask;
	    pedwarn ("octal escape sequence out of range");
d848 1
a848 2
	register unsigned_HOST_WIDE_INT i = 0, overflow = 0;
	register int digits_found = 0, digit;
d869 1
a869 1
	if (overflow | (i != (i & result_mask)))
d871 2
a872 2
	    i &= result_mask;
	    pedwarn ("hex escape sequence out of range");
d881 1
a881 1
static void
d885 1
a885 1
  error ("%s", s);
d897 1
a897 1
static HOST_WIDE_INT
d900 1
a900 1
     unsigned_HOST_WIDE_INT b;
d905 1
a905 1
  if (b >= HOST_BITS_PER_WIDE_INT)
d907 2
d910 1
a910 1
    return (unsigned_HOST_WIDE_INT) a->value << b;
d913 1
a913 1
static HOST_WIDE_INT
d916 1
a916 1
     unsigned_HOST_WIDE_INT b;
d918 5
a922 3
  if (b >= HOST_BITS_PER_WIDE_INT)
    return a->signedp ? a->value >> (HOST_BITS_PER_WIDE_INT - 1) : 0;
  else if (a->signedp)
a923 2
  else
    return (unsigned_HOST_WIDE_INT) a->value >> b;
d929 2
a930 5
   to use up all of the contents of STRING.
   STRING may contain '\0' bytes; it is terminated by the first '\n'
   outside a string constant, so that we can diagnose '\0' properly.
   If WARN_UNDEFINED is nonzero, warn if undefined identifiers are evaluated.
   We do not support C comments.  They should be removed before
d934 1
a934 1
parse_c_expression (string, warn_undefined)
a935 1
     int warn_undefined;
d938 5
a942 1
  warn_undef = warn_undefined;
d950 4
a953 4
  if (yyparse () != 0)
    abort ();

  if (*lexptr != '\n')
a959 2

#if YYDEBUG
a960 8
#endif

int pedantic;
int traditional;

int main PROTO((int, char **));
static void initialize_random_junk PROTO((void));
static void print_unsigned_host_wide_int PROTO((unsigned_HOST_WIDE_INT));
d964 1
a964 3
main (argc, argv)
     int argc;
     char **argv;
a967 1
  unsigned_HOST_WIDE_INT u;
d969 3
a971 5
  pedantic = 1 < argc;
  traditional = 2 < argc;
#if YYDEBUG
  yydebug = 3 < argc;
#endif
d977 1
a977 1
    while ((buf[n] = c = getchar ()) != '\n' && c != EOF)
d979 1
a979 1
    if (c == EOF)
d981 2
a982 14
    parse_c_expression (buf, 1);
    printf ("parser returned ");
    u = (unsigned_HOST_WIDE_INT) expression_value;
    if (expression_value < 0 && expression_signedp) {
      u = -u;
      printf ("-");
    }
    if (u == 0)
      printf ("0");
    else
      print_unsigned_host_wide_int (u);
    if (! expression_signedp)
      printf("u");
    printf ("\n");
a987 10
static void
print_unsigned_host_wide_int (u)
     unsigned_HOST_WIDE_INT u;
{
  if (u) {
    print_unsigned_host_wide_int (u / 10);
    putchar ('0' + (int) (u % 10));
  }
}

d992 3
a994 2
/* table to tell if c is horizontal or vertical space.  */
unsigned char is_space[256];
a998 1
static void
d1019 1
d1022 1
d1024 3
a1026 19
  ++is_space[' '];
  ++is_space['\t'];
  ++is_space['\v'];
  ++is_space['\f'];
  ++is_space['\n'];
  ++is_space['\r'];
}

void
error (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
{
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "error: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
d1029 1
a1029 16
void
pedwarn (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
{
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "pedwarn: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
}

void
warning (PRINTF_ALIST (msg))
     PRINTF_DCL (msg)
d1031 1
a1031 7
  va_list args;

  VA_START (args, msg);
  fprintf (stderr, "warning: ");
  vfprintf (stderr, msg, args);
  fprintf (stderr, "\n");
  va_end (args);
d1034 1
a1034 6
int
check_assertion (name, sym_length, tokens_specified, tokens)
     U_CHAR *name;
     int sym_length;
     int tokens_specified;
     struct arglist *tokens;
d1036 1
a1036 1
  return 0;
d1041 1
a1041 1
     U_CHAR *name;
a1045 7
}

GENERIC_PTR
xmalloc (size)
     size_t size;
{
  return (GENERIC_PTR) malloc (size);
@

