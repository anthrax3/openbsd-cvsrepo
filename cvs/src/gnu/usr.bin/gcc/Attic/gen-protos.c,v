head	1.3;
access;
symbols
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	FSF_2_8_1:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	99.05.26.16.22.05;	author espie;	state dead;
branches;
next	1.2;

1.2
date	98.03.03.21.17.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.02.50;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.02.50;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.11.59;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@So long, and thanks for all the bugs.
@
text
@/* gen-protos.c - massages a list of prototypes, for use by fixproto.
   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include <stdio.h>
#include <ctype.h>
#include "hconfig.h"
#include "scan.h"
#include "cpplib.h"
#include "cpphash.h"

int verbose = 0;
char *progname;

#define HASH_SIZE 2503 /* a prime */
int hash_tab[HASH_SIZE];
int next_index;

static int
hashf (name, len, hashsize)
     register U_CHAR *name;
     register int len;
     int hashsize;
{
  register int r = 0;

  while (len--)
    r = HASHSTEP (r, *name++);

  return MAKE_POS (r) % hashsize;
}

static void
add_hash (fname)
     char *fname;
{
  int i, i0;

  /* NOTE:  If you edit this, also edit lookup_std_proto in fix-header.c !! */
  i = hashf (fname, strlen (fname), HASH_SIZE);
  i0 = i;
  if (hash_tab[i] != 0)
    {
      for (;;)
	{
	  i = (i+1) % HASH_SIZE;
	  if (i == i0)
	    abort ();
	  if (hash_tab[i] == 0)
	    break;
	}
    }
  hash_tab[i] = next_index;

  next_index++;
}

/* Given a function prototype, fill in the fields of FN.
   The result is a boolean indicating if a function prototype was found.

   The input string is modified (trailing NULs are inserted).
   The fields of FN point to the input string.  */

static int
parse_fn_proto (start, end, fn)
     char *start, *end;
     struct fn_decl *fn;
{
  register char *ptr;
  int param_nesting = 1;
  char *param_start, *param_end, *decl_start, *name_start, *name_end;

  ptr = end - 1;
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  if (*ptr-- != ';')
    {
      fprintf (stderr, "Funny input line: %s\n", start);
      return 0;
    }
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  if (*ptr != ')')
    {
      fprintf (stderr, "Funny input line: %s\n", start);
      return 0;
    }
  param_end = ptr;
  for (;;)
    {
      int c = *--ptr;
      if (c == '(' && --param_nesting == 0)
	break;
      else if (c == ')')
	param_nesting++;
    }
  param_start = ptr+1;

  ptr--;
  while (*ptr == ' ' || *ptr == '\t') ptr--;

  if (!isalnum (*ptr))
    {
      if (verbose)
	fprintf (stderr, "%s: Can't handle this complex prototype: %s\n",
		 progname, start);
      return 0;
    }
  name_end = ptr+1;

  while (isalnum (*ptr) || *ptr == '_') --ptr;
  name_start = ptr+1;
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  ptr[1] = 0;
  *param_end = 0;
  *name_end = 0;

  decl_start = start;
  if (strncmp (decl_start, "typedef ", 8) == 0)
    return 0;
  if (strncmp (decl_start, "extern ", 7) == 0)
    decl_start += 7;

  fn->fname = name_start;
  fn->rtype = decl_start;
  fn->params = param_start;
  return 1;
}

int
main (argc, argv)
     int argc;
     char **argv;
{
  FILE *inf = stdin;
  FILE *outf = stdout;
  int i;
  sstring linebuf;
  char **optr;
  struct fn_decl fn_decl;

  i = strlen (argv[0]);
  while (i > 0 && argv[0][i-1] != '/') --i;
  progname = &argv[0][i];

  INIT_SSTRING (&linebuf);

  fprintf (outf, "struct fn_decl std_protos[] = {\n");

  /* A hash table entry of 0 means "unused" so reserve it.  */
  fprintf (outf, "  {\"\", \"\", \"\"},\n");
  next_index = 1;
  
  for (;;)
    {
      int c = skip_spaces (inf, ' ');

      if (c == EOF)
	break;
      linebuf.ptr = linebuf.base;
      ungetc (c, inf);
      c = read_upto (inf, &linebuf, '\n');
      if (linebuf.base[0] == '#') /* skip cpp command */
	continue;
      if (linebuf.base[0] == '\0') /* skip empty line */
	continue;

      if (! parse_fn_proto (linebuf.base, linebuf.ptr, &fn_decl))
	continue;

      add_hash (fn_decl.fname);

      fprintf (outf, "  {\"%s\", \"%s\", \"%s\"},\n",
	       fn_decl.fname, fn_decl.rtype, fn_decl.params);

      if (c == EOF)
	break;
    }
  fprintf (outf, "  {0, 0, 0}\n};\n");


  fprintf (outf, "#define HASH_SIZE %d\n", HASH_SIZE);
  fprintf (outf, "short hash_tab[HASH_SIZE] = {\n");
  for (i = 0; i < HASH_SIZE; i++)
    fprintf (outf, "  %d,\n", hash_tab[i]);
  fprintf (outf, "};\n");

  return 0;
}

/* Avoid error if config defines abort as fancy_abort.
   It's not worth "really" implementing this because ordinary
   compiler users never run fix-header.  */

void
fancy_abort ()
{
  abort ();
}

void
fatal (s)
     char *s;
{
  fprintf (stderr, "%s: %s\n", "gen-protos", s);
  exit (FATAL_EXIT_CODE);
}
@


1.2
log
@GCC 2.8.0 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994, 1995 Free Software Foundation, Inc.
d25 3
d29 2
d32 1
a32 1
int
d46 24
a69 2
int hash_tab[HASH_SIZE];
int verbose = 0;
d71 2
a72 1
sstring linebuf;
d74 2
a75 3
/* Avoid error if config defines abort as fancy_abort.
   It's not worth "really" implementing this because ordinary
   compiler users never run fix-header.  */
d77 4
a80 2
void
fancy_abort ()
d82 57
a138 1
  abort ();
d144 1
a144 1
     char** argv;
d148 10
a157 2
  int next_index = 0;
  int i, i0;
d161 4
d168 1
a168 4
      int param_nesting = 1;
      char *param_start, *param_end, *decl_start,
      *name_start, *name_end;
      register char *ptr;
d179 1
a179 46
      ptr = linebuf.ptr - 1;
      while (*ptr == ' ' || *ptr == '\t') ptr--;
      if (*ptr-- != ';')
	{
	  fprintf (stderr, "Funny input line: %s\n", linebuf.base);
	  continue;
	}
      while (*ptr == ' ' || *ptr == '\t') ptr--;
      if (*ptr != ')')
	{
	  fprintf (stderr, "Funny input line: %s\n", linebuf.base);
	  continue;
	}
      param_end = ptr;
      for (;;)
	{
	  int c = *--ptr;
	  if (c == '(' && --param_nesting == 0)
	    break;
	  else if (c == ')')
	    param_nesting++;
	}
      param_start = ptr+1;

      ptr--;
      while (*ptr == ' ' || *ptr == '\t') ptr--;

      if (!isalnum (*ptr))
	{
	  if (verbose)
	    fprintf (stderr, "%s: Can't handle this complex prototype: %s\n",
		     argv[0], linebuf.base);
	  continue;
	}
      name_end = ptr+1;

      while (isalnum (*ptr) || *ptr == '_') --ptr;
      name_start = ptr+1;
      while (*ptr == ' ' || *ptr == '\t') ptr--;
      ptr[1] = 0;
      *name_end = 0;
      *param_end = 0;
      *name_end = 0;

      decl_start = linebuf.base;
      if (strncmp (decl_start, "typedef ", 8) == 0)
a180 20
      if (strncmp (decl_start, "extern ", 7) == 0)
	decl_start += 7;


      /* NOTE:  If you edit this,
	 also edit lookup_std_proto in fix-header.c !! */
      i = hashf (name_start, name_end - name_start, HASH_SIZE);
      i0 = i;
      if (hash_tab[i] != 0)
	{
	  for (;;)
	    {
	      i = (i+1) % HASH_SIZE;
	      if (i == i0)
		abort ();
	      if (hash_tab[i] == 0)
		break;
	    }
	}
      hash_tab[i] = next_index;
d182 1
a182 2
      fprintf (outf, "  {\"%s\", \"%s\", \"%s\" },\n",
	       name_start, decl_start, param_start);
d184 2
a185 1
      next_index++;
d190 1
a190 1
  fprintf (outf, "{0, 0, 0}\n};\n");
d200 10
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
a24 3
int verbose = 0;
char *progname;

a25 2
int hash_tab[HASH_SIZE];
int next_index;
d27 1
a27 1
static int
d41 2
a42 5
static void
add_hash (fname)
     char *fname;
{
  int i, i0;
d44 1
a44 15
  /* NOTE:  If you edit this, also edit lookup_std_proto in fix-header.c !! */
  i = hashf (fname, strlen (fname), HASH_SIZE);
  i0 = i;
  if (hash_tab[i] != 0)
    {
      for (;;)
	{
	  i = (i+1) % HASH_SIZE;
	  if (i == i0)
	    abort ();
	  if (hash_tab[i] == 0)
	    break;
	}
    }
  hash_tab[i] = next_index;
d46 3
a48 2
  next_index++;
}
d50 2
a51 10
/* Given a function prototype, fill in the fields of FN.
   The result is a boolean indicating if a function prototype was found.

   The input string is modified (trailing NULs are inserted).
   The fields of FN point to the input string.  */

static int
parse_fn_proto (start, end, fn)
     char *start, *end;
     struct fn_decl *fn;
d53 1
a53 57
  register char *ptr;
  int param_nesting = 1;
  char *param_start, *param_end, *decl_start, *name_start, *name_end;

  ptr = end - 1;
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  if (*ptr-- != ';')
    {
      fprintf (stderr, "Funny input line: %s\n", start);
      return 0;
    }
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  if (*ptr != ')')
    {
      fprintf (stderr, "Funny input line: %s\n", start);
      return 0;
    }
  param_end = ptr;
  for (;;)
    {
      int c = *--ptr;
      if (c == '(' && --param_nesting == 0)
	break;
      else if (c == ')')
	param_nesting++;
    }
  param_start = ptr+1;

  ptr--;
  while (*ptr == ' ' || *ptr == '\t') ptr--;

  if (!isalnum (*ptr))
    {
      if (verbose)
	fprintf (stderr, "%s: Can't handle this complex prototype: %s\n",
		 progname, start);
      return 0;
    }
  name_end = ptr+1;

  while (isalnum (*ptr) || *ptr == '_') --ptr;
  name_start = ptr+1;
  while (*ptr == ' ' || *ptr == '\t') ptr--;
  ptr[1] = 0;
  *param_end = 0;
  *name_end = 0;

  decl_start = start;
  if (strncmp (decl_start, "typedef ", 8) == 0)
    return 0;
  if (strncmp (decl_start, "extern ", 7) == 0)
    decl_start += 7;

  fn->fname = name_start;
  fn->rtype = decl_start;
  fn->params = param_start;
  return 1;
d59 1
a59 1
     char **argv;
d63 2
a64 10
  int i;
  sstring linebuf;
  char **optr;
  struct fn_decl fn_decl;

  i = strlen (argv[0]);
  while (i > 0 && argv[0][i-1] != '/') --i;
  progname = &argv[0][i];

  INIT_SSTRING (&linebuf);
a67 4
  /* A hash table entry of 0 means "unused" so reserve it.  */
  fprintf (outf, "  {\"\", \"\", \"\"},\n");
  next_index = 1;
  
d71 4
a74 1

d85 46
a130 1
      if (! parse_fn_proto (linebuf.base, linebuf.ptr, &fn_decl))
d132 20
d153 2
a154 1
      add_hash (fn_decl.fname);
d156 1
a156 2
      fprintf (outf, "  {\"%s\", \"%s\", \"%s\"},\n",
	       fn_decl.fname, fn_decl.rtype, fn_decl.params);
d161 1
a161 1
  fprintf (outf, "  {0, 0, 0}\n};\n");
a170 10
}

/* Avoid error if config defines abort as fancy_abort.
   It's not worth "really" implementing this because ordinary
   compiler users never run fix-header.  */

void
fancy_abort ()
{
  abort ();
@

