head	1.4;
access;
symbols
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	FSF_2_8_1:1.1.1.3
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	99.05.26.16.28.12;	author espie;	state dead;
branches;
next	1.3;

1.3
date	98.03.08.18.31.19;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.03.03.21.34.45;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.06.12;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.06.12;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.25.47;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.03.08.18.10.03;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@So long, and thanks for all the bugs.
@
text
@/* Handle exceptional things in C++.
   Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.
   Contributed by Michael Tiemann <tiemann@@cygnus.com>
   Rewritten by Mike Stump <mrs@@cygnus.com>, based upon an
   initial re-implementation courtesy Tad Hunt.

This file is part of GNU CC.

GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */


#include "config.h"
#include <stdio.h>
#include "tree.h"
#include "rtl.h"
#include "cp-tree.h"
#include "flags.h"
#include "obstack.h"
#include "expr.h"
#include "output.h"
#include "except.h"
#include "function.h"
#include "defaults.h"

rtx expand_builtin_return_addr	PROTO((enum built_in_function, int, rtx));

/* Holds the fndecl for __builtin_return_address.  */
tree builtin_return_address_fndecl;

/* A couple of backend routines from m88k.c */

/* Used to cache a call to __builtin_return_address.  */
static tree BuiltinReturnAddress;
     
static void easy_expand_asm PROTO((char *));
static void push_eh_cleanup PROTO((void));
static void do_unwind PROTO((rtx));
static rtx do_function_call PROTO((tree, tree, tree));
static tree build_eh_type_type PROTO((tree));
static tree build_eh_type PROTO((tree));
static void expand_end_eh_spec PROTO((tree));

static void
easy_expand_asm (str)
     char *str;
{
  expand_asm (build_string (strlen (str)+1, str));
}


#if 0
/* This is the startup, and finish stuff per exception table.  */

/* XXX - Tad: exception handling section */
#ifndef EXCEPT_SECTION_ASM_OP
#define EXCEPT_SECTION_ASM_OP	"section\t.gcc_except_table,\"a\",@@progbits"
#endif

#ifdef EXCEPT_SECTION_ASM_OP
typedef struct {
    void *start_region;
    void *end_region;
    void *exception_handler;
 } exception_table;
#endif /* EXCEPT_SECTION_ASM_OP */

#ifdef EXCEPT_SECTION_ASM_OP

 /* on machines which support it, the exception table lives in another section,
	but it needs a label so we can reference it...  This sets up that
    label! */
asm (EXCEPT_SECTION_ASM_OP);
exception_table __EXCEPTION_TABLE__[1] = { (void*)0, (void*)0, (void*)0 };
asm (TEXT_SECTION_ASM_OP);

#endif /* EXCEPT_SECTION_ASM_OP */

#ifdef EXCEPT_SECTION_ASM_OP

 /* we need to know where the end of the exception table is... so this
    is how we do it! */

asm (EXCEPT_SECTION_ASM_OP);
exception_table __EXCEPTION_END__[1] = { (void*)-1, (void*)-1, (void*)-1 };
asm (TEXT_SECTION_ASM_OP);

#endif /* EXCEPT_SECTION_ASM_OP */

#endif

#include "decl.h"
#include "insn-flags.h"
#include "obstack.h"

/* ======================================================================
   Briefly the algorithm works like this:

     When a constructor or start of a try block is encountered,
     push_eh_entry (&eh_stack) is called.  Push_eh_entry () creates a
     new entry in the unwind protection stack and returns a label to
     output to start the protection for that block.

     When a destructor or end try block is encountered, pop_eh_entry
     (&eh_stack) is called.  Pop_eh_entry () returns the eh_entry it
     created when push_eh_entry () was called.  The eh_entry structure
     contains three things at this point.  The start protect label,
     the end protect label, and the exception handler label.  The end
     protect label should be output before the call to the destructor
     (if any). If it was a destructor, then its parse tree is stored
     in the finalization variable in the eh_entry structure.  Otherwise
     the finalization variable is set to NULL to reflect the fact that
     is the the end of a try block.  Next, this modified eh_entry node
     is enqueued in the finalizations queue by calling
     enqueue_eh_entry (&queue,entry).

	+---------------------------------------------------------------+
	|XXX: Will need modification to deal with partially		|
	|			constructed arrays of objects		|
	|								|
	|	Basically, this consists of keeping track of how many	|
	|	of the objects have been constructed already (this	|
	|	should be in a register though, so that shouldn't be a	|
	|	problem.						|
	+---------------------------------------------------------------+

     When a catch block is encountered, there is a lot of work to be
     done.

     Since we don't want to generate the catch block inline with the
     regular flow of the function, we need to have some way of doing
     so.  Luckily, we can use sequences to defer the catch sections.
     When the start of a catch block is encountered, we start the
     sequence.  After the catch block is generated, we end the
     sequence.

     Next we must insure that when the catch block is executed, all
     finalizations for the matching try block have been completed.  If
     any of those finalizations throw an exception, we must call
     terminate according to the ARM (section r.15.6.1).  What this
     means is that we need to dequeue and emit finalizations for each
     entry in the eh_queue until we get to an entry with a NULL
     finalization field.  For any of the finalization entries, if it
     is not a call to terminate (), we must protect it by giving it
     another start label, end label, and exception handler label,
     setting its finalization tree to be a call to terminate (), and
     enqueue'ing this new eh_entry to be output at an outer level.
     Finally, after all that is done, we can get around to outputting
     the catch block which basically wraps all the "catch (...) {...}"
     statements in a big if/then/else construct that matches the
     correct block to call.
     
     ===================================================================== */

/* local globals for function calls
   ====================================================================== */

/* Used to cache "terminate", "unexpected", "set_terminate", and
   "set_unexpected" after default_conversion. (lib-except.c)  */
static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch;

/* Used to cache __find_first_exception_table_match for throw.  */
static tree FirstExceptionMatch;

/* Used to cache a call to __unwind_function.  */
static tree Unwind;

/* ====================================================================== */


/* ========================================================================= */



/* local globals - these local globals are for storing data necessary for
   generating the exception table and code in the correct order.

   ========================================================================= */

/* Holds the pc for doing "throw" */
static tree saved_pc;

extern int throw_used;
extern rtx catch_clauses;

/* ========================================================================= */

/* Cheesyness to save some typing.  Returns the return value rtx.  */

static rtx
do_function_call (func, params, return_type)
     tree func, params, return_type;
{
  tree func_call;
  func_call = build_function_call (func, params);
  expand_call (func_call, NULL_RTX, 0);
  if (return_type != NULL_TREE)
    return hard_function_value (return_type, func_call);
  return NULL_RTX;
}

/* ========================================================================= */

/* sets up all the global eh stuff that needs to be initialized at the
   start of compilation.

   This includes:
		- Setting up all the function call trees.  */

void
init_exception_processing ()
{
  tree unexpected_fndecl, terminate_fndecl;
  tree set_unexpected_fndecl, set_terminate_fndecl;
  tree catch_match_fndecl;
  tree find_first_exception_match_fndecl;
  tree unwind_fndecl;
  tree declspecs;
  tree d;

  /* void vtype () */
  tree vtype = build_function_type (void_type_node, void_list_node);
  
  /* void (*)() */
  tree PFV = build_pointer_type (vtype);

  /* Arg list for the build_function_type call for set_terminate and
     set_unexpected.  */
  tree pfvlist = tree_cons (NULL_TREE, PFV, void_list_node);

  /* void (*pfvtype (void (*) ()))() */
  tree pfvtype = build_function_type (PFV, pfvlist);

  set_terminate_fndecl = auto_function (get_identifier ("set_terminate"),
					pfvtype, NOT_BUILT_IN);
  set_unexpected_fndecl = auto_function (get_identifier ("set_unexpected"),
					 pfvtype, NOT_BUILT_IN);
  unexpected_fndecl = auto_function (get_identifier ("unexpected"),
				     vtype, NOT_BUILT_IN);
  terminate_fndecl = auto_function (get_identifier ("terminate"),
				    vtype, NOT_BUILT_IN);
  TREE_THIS_VOLATILE (terminate_fndecl) = 1;

  push_lang_context (lang_name_c);

  catch_match_fndecl
    = builtin_function (flag_rtti
			? "__throw_type_match_rtti"
			: "__throw_type_match",
			build_function_type (ptr_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							tree_cons (NULL_TREE, ptr_type_node,
								   tree_cons (NULL_TREE, ptr_type_node,
									      void_list_node)))),
			NOT_BUILT_IN, NULL_PTR);
  find_first_exception_match_fndecl
    = builtin_function ("__find_first_exception_table_match",
			build_function_type (ptr_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							void_list_node)),
			NOT_BUILT_IN, NULL_PTR);
  unwind_fndecl
    = builtin_function ("__unwind_function",
			build_function_type (void_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							void_list_node)),
			NOT_BUILT_IN, NULL_PTR);

  Unexpected = default_conversion (unexpected_fndecl);
  Terminate = terminate_fndecl;
  SetTerminate = default_conversion (set_terminate_fndecl);
  SetUnexpected = default_conversion (set_unexpected_fndecl);
  CatchMatch = default_conversion (catch_match_fndecl);
  FirstExceptionMatch = default_conversion (find_first_exception_match_fndecl);
  Unwind = default_conversion (unwind_fndecl);
  BuiltinReturnAddress = default_conversion (builtin_return_address_fndecl);

  pop_lang_context ();

  d = build_decl (VAR_DECL, get_identifier ("__eh_pc"), ptr_type_node);
  TREE_PUBLIC (d) = 1;
  DECL_EXTERNAL (d) = 1;
  DECL_ARTIFICIAL (d) = 1;
  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
  saved_pc = d;

  /* If we use setjmp/longjmp EH, arrange for all cleanup actions to
     be protected with __terminate.  */
  protect_cleanup_actions_with_terminate = 1;
}

/* Retrieve a pointer to the cp_eh_info node for the current exception.  */

static tree
call_eh_info ()
{
  tree fn;

  fn = get_identifier ("__cp_exception_info");
  if (IDENTIFIER_GLOBAL_VALUE (fn))
    fn = IDENTIFIER_GLOBAL_VALUE (fn);
  else
    {
      tree t, fields[6];

      /* Declare cp_eh_info * __cp_exception_info (void),
	 as defined in exception.cc. */
      push_obstacks_nochange ();
      end_temporary_allocation ();

      /* struct cp_eh_info.  This must match exception.cc.  Note that this
	 type is not pushed anywhere.  */
      t = make_lang_type (RECORD_TYPE);
      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier ("value"),
					 ptr_type_node);
      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier ("type"),
					 ptr_type_node);
      fields[2] = build_lang_field_decl
	(FIELD_DECL, get_identifier ("cleanup"),
	 build_pointer_type (build_function_type
			     (ptr_type_node, tree_cons
			      (NULL_TREE, ptr_type_node, void_list_node))));
      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier ("caught"),
					 boolean_type_node);
      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier ("next"),
					 build_pointer_type (t));
      fields[5] = build_lang_field_decl
	(FIELD_DECL, get_identifier ("handlers"), long_integer_type_node);
      /* N.B.: The fourth field LEN is expected to be
	 the number of fields - 1, not the total number of fields.  */
      finish_builtin_type (t, "cp_eh_info", fields, 5, ptr_type_node);
      t = build_pointer_type (t);

      /* And now the function.  */
      fn = build_lang_decl (FUNCTION_DECL, fn,
			    build_function_type (t, void_list_node));
      DECL_EXTERNAL (fn) = 1;
      TREE_PUBLIC (fn) = 1;
      DECL_ARTIFICIAL (fn) = 1;
      pushdecl_top_level (fn);
      make_function_rtl (fn);
      assemble_external (fn);
      pop_obstacks ();
    }
  return build_function_call (fn, NULL_TREE);
}

/* Retrieve a pointer to the cp_eh_info node for the current exception
   and save it in the current binding level.  */

static void
push_eh_info ()
{
  tree decl, fn = call_eh_info ();

  /* Remember the pointer to the current exception info; it won't change
     during this catch block.  */
  decl = build_decl (VAR_DECL, get_identifier ("__exception_info"),
		     TREE_TYPE (fn));
  DECL_ARTIFICIAL (decl) = 1;
  DECL_INITIAL (decl) = fn;
  decl = pushdecl (decl);
  cp_finish_decl (decl, fn, NULL_TREE, 0, 0);
}

/* Returns a reference to the cp_eh_info node for the current exception.  */

static tree
get_eh_info ()
{
  /* Look for the pointer pushed in push_eh_info.  */
  tree t = lookup_name (get_identifier ("__exception_info"), 0);
  return build_indirect_ref (t, NULL_PTR);
}

/* Returns a reference to the current exception object.  */

static tree
get_eh_value ()
{
  return build_component_ref (get_eh_info (), get_identifier ("value"),
			      NULL_TREE, 0);
}

/* Returns a reference to the current exception type.  */

static tree
get_eh_type ()
{
  return build_component_ref (get_eh_info (), get_identifier ("type"),
			      NULL_TREE, 0);
}

/* Returns a reference to whether or not the current exception
   has been caught.  */

static tree
get_eh_caught ()
{
  return build_component_ref (get_eh_info (), get_identifier ("caught"),
			      NULL_TREE, 0);
}

/* Returns a reference to whether or not the current exception
   has been caught.  */

static tree
get_eh_handlers ()
{
  return build_component_ref (get_eh_info (), get_identifier ("handlers"),
			      NULL_TREE, 0);
}

/* Build a type value for use at runtime for a type that is matched
   against by the exception handling system.  */

static tree
build_eh_type_type (type)
     tree type;
{
  char *typestring;
  tree exp;

  if (type == error_mark_node)
    return error_mark_node;

  /* peel back references, so they match.  */
  if (TREE_CODE (type) == REFERENCE_TYPE)
    type = TREE_TYPE (type);

  /* Peel off cv qualifiers.  */
  type = TYPE_MAIN_VARIANT (type);

  if (flag_rtti)
    {
      return build1 (ADDR_EXPR, ptr_type_node, get_typeid (type));
    }

  typestring = build_overload_name (type, 1, 1);
  exp = combine_strings (build_string (strlen (typestring)+1, typestring));
  return build1 (ADDR_EXPR, ptr_type_node, exp);
}

/* Build a type value for use at runtime for a exp that is thrown or
   matched against by the exception handling system.  */

static tree
build_eh_type (exp)
     tree exp;
{
  if (flag_rtti)
    {
      exp = build_typeid (exp);
      return build1 (ADDR_EXPR, ptr_type_node, exp);
    }
  return build_eh_type_type (TREE_TYPE (exp));
}

/* Build up a call to __cp_pop_exception, to destroy the exception object
   for the current catch block.  HANDLER is either true or false, telling
   the library whether or not it is being called from an exception handler;
   if it is, it avoids destroying the object on rethrow.  */

static tree
do_pop_exception ()
{
  tree fn, cleanup;
  fn = get_identifier ("__cp_pop_exception");
  if (IDENTIFIER_GLOBAL_VALUE (fn))
    fn = IDENTIFIER_GLOBAL_VALUE (fn);
  else
    {
      /* Declare void __cp_pop_exception (void *),
	 as defined in exception.cc. */
      push_obstacks_nochange ();
      end_temporary_allocation ();
      fn = build_lang_decl
	(FUNCTION_DECL, fn,
	 build_function_type (void_type_node, tree_cons
			      (NULL_TREE, ptr_type_node, void_list_node)));
      DECL_EXTERNAL (fn) = 1;
      TREE_PUBLIC (fn) = 1;
      DECL_ARTIFICIAL (fn) = 1;
      pushdecl_top_level (fn);
      make_function_rtl (fn);
      assemble_external (fn);
      pop_obstacks ();
    }

  /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */
  cleanup = lookup_name (get_identifier ("__exception_info"), 0);
  cleanup = build_function_call (fn, expr_tree_cons
				 (NULL_TREE, cleanup, NULL_TREE));
  return cleanup;
}

/* This routine creates the cleanup for the current exception.  */

static void
push_eh_cleanup ()
{
  int yes;

  expand_expr (build_unary_op (PREINCREMENT_EXPR, get_eh_handlers (), 1),
	       const0_rtx, VOIDmode, EXPAND_NORMAL);

  yes = suspend_momentary ();
  /* All cleanups must last longer than normal.  */
  expand_decl_cleanup (NULL_TREE, do_pop_exception ());
  resume_momentary (yes);
}

/* call this to start a catch block. Typename is the typename, and identifier
   is the variable to place the object in or NULL if the variable doesn't
   matter.  If typename is NULL, that means its a "catch (...)" or catch
   everything.  In that case we don't need to do any type checking.
   (ie: it ends up as the "else" clause rather than an "else if" clause) */

void
expand_start_catch_block (declspecs, declarator)
     tree declspecs, declarator;
{
  rtx false_label_rtx;
  tree decl = NULL_TREE;
  tree init;

  if (processing_template_decl)
    {
      if (declspecs)
	{
	  decl = grokdeclarator (declarator, declspecs, CATCHPARM,
				 1, NULL_TREE);
	  pushdecl (decl);
	  decl = build_min_nt (DECL_STMT, copy_to_permanent (declarator),
			       copy_to_permanent (declspecs),
			       NULL_TREE);
	  add_tree (decl);
	}
      return;
    }

  if (! doing_eh (1))
    return;

  /* If we are not doing setjmp/longjmp EH, because we are reordered
     out of line, we arrange to rethrow in the outer context so as to
     skip through the terminate region we are nested in, should we
     encounter an exception in the catch handler.  We also need to do
     this because we are not physically within the try block, if any,
     that contains this catch block.

     Matches the end in expand_end_catch_block.  */
  if (! exceptions_via_longjmp)
    expand_eh_region_start ();

  /* Create a binding level for the eh_info and the exception object
     cleanup.  */
  pushlevel (0);
  expand_start_bindings (0);

  false_label_rtx = gen_label_rtx ();
  push_label_entry (&false_label_stack, false_label_rtx, NULL_TREE);

  emit_line_note (input_filename, lineno);

  push_eh_info ();

  if (declspecs)
    {
      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);

      if (decl == NULL_TREE)
	error ("invalid catch parameter");
    }

  if (decl)
    {
      tree exp;
      rtx call_rtx, return_value_rtx;
      tree init_type;

      /* Make sure we mark the catch param as used, otherwise we'll get
	 a warning about an unused ((anonymous)).  */
      TREE_USED (decl) = 1;

      /* Figure out the type that the initializer is.  */
      init_type = TREE_TYPE (decl);
      if (TREE_CODE (init_type) != REFERENCE_TYPE
	  && TREE_CODE (init_type) != POINTER_TYPE)
	init_type = build_reference_type (init_type);

      exp = get_eh_value ();

      /* Since pointers are passed by value, initialize a reference to
	 pointer catch parm with the address of the value slot.  */
      if (TREE_CODE (init_type) == REFERENCE_TYPE
	  && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)
	exp = build_unary_op (ADDR_EXPR, exp, 1);

      exp = expr_tree_cons (NULL_TREE,
		       build_eh_type_type (TREE_TYPE (decl)),
		       expr_tree_cons (NULL_TREE,
				  get_eh_type (),
				  expr_tree_cons (NULL_TREE, exp, NULL_TREE)));
      exp = build_function_call (CatchMatch, exp);
      call_rtx = expand_call (exp, NULL_RTX, 0);
      assemble_external (TREE_OPERAND (CatchMatch, 0));

      return_value_rtx = hard_function_value (ptr_type_node, exp);

      /* did the throw type match function return TRUE? */
      emit_cmp_insn (return_value_rtx, const0_rtx, EQ, NULL_RTX,
		    GET_MODE (return_value_rtx), 0, 0);

      /* if it returned FALSE, jump over the catch block, else fall into it */
      emit_jump_insn (gen_beq (false_label_rtx));

      push_eh_cleanup ();

      /* Create a binding level for the parm.  */
      pushlevel (0);
      expand_start_bindings (0);

      init = convert_from_reference (make_tree (init_type, call_rtx));

      /* If the constructor for the catch parm exits via an exception, we
         must call terminate.  See eh23.C.  */
      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))
	{
	  int yes = suspend_momentary ();
	  tree term = build_function_call (Terminate, NULL_TREE);
	  resume_momentary (yes);

	  /* Generate the copy constructor call directly so we can wrap it.
	     See also expand_default_init.  */
	  init = ocp_convert (TREE_TYPE (decl), init,
			      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);
	  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init, term);
	}

      /* Let `cp_finish_decl' know that this initializer is ok.  */
      DECL_INITIAL (decl) = init;
      decl = pushdecl (decl);

      cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);
    }
  else
    {
      push_eh_cleanup ();

      /* Create a binding level for the parm.  */
      pushlevel (0);
      expand_start_bindings (0);

      /* Fall into the catch all section.  */
    }

  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);
  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);

  emit_line_note (input_filename, lineno);
}



/* Call this to end a catch block.  Its responsible for emitting the
   code to handle jumping back to the correct place, and for emitting
   the label to jump to if this catch block didn't match.  */

void
expand_end_catch_block ()
{
  if (! doing_eh (1))
    return;

  /* Cleanup the EH parameter.  */
  expand_end_bindings (getdecls (), kept_level_p (), 0);
  poplevel (kept_level_p (), 1, 0);
      
  /* Cleanup the EH object.  */
  expand_end_bindings (getdecls (), kept_level_p (), 0);
  poplevel (kept_level_p (), 1, 0);

  if (! exceptions_via_longjmp)
    {
      /* If we are not doing setjmp/longjmp EH, we need an extra
	 region around the whole catch block to skip through the
	 terminate region we are nested in.  */

      tree t = make_node (RTL_EXPR);
      TREE_TYPE (t) = void_type_node;
      RTL_EXPR_RTL (t) = const0_rtx;
      TREE_SIDE_EFFECTS (t) = 1;
      do_pending_stack_adjust ();
      start_sequence_for_rtl_expr (t);

      expand_internal_throw (outer_context_label_stack->u.rlabel);

      do_pending_stack_adjust ();
      RTL_EXPR_SEQUENCE (t) = get_insns ();
      end_sequence ();

      /* For the rethrow region.  */
      expand_eh_region_end (t);
    }

  /* Fall to outside the try statement when done executing handler and
     we fall off end of handler.  This is jump Lresume in the
     documentation.  */
  expand_goto (top_label_entry (&caught_return_label_stack));

  expand_leftover_cleanups ();

  /* label we emit to jump to if this catch block didn't match.  */
  /* This the closing } in the `if (eq) {' of the documentation.  */
  emit_label (pop_label_entry (&false_label_stack));
}

/* unwind the stack.  */

static void
do_unwind (inner_throw_label)
     rtx inner_throw_label;
{
#if defined (SPARC_STACK_ALIGN) /* was sparc */
  /* This doesn't work for the flat model sparc, nor does it need to
     as the default unwinder is only used to unwind non-flat frames.  */
  tree fcall;
  tree params;
  rtx next_pc;
  rtx temp;

  /* Call to  __builtin_return_address. */
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
  fcall = build_function_call (BuiltinReturnAddress, params);
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);
  /* In the return, the new pc is pc+8, as the value coming in is
     really the address of the call insn, not the next insn.  */
  temp = gen_reg_rtx (Pmode);
  emit_move_insn (temp, inner_throw_label);
  emit_move_insn (next_pc, plus_constant (temp, -8));
  emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 31)));
  easy_expand_asm ("ret");
  easy_expand_asm ("restore");
  emit_barrier ();
#endif
#if defined (ARM_FRAME_RTX)  /* was __arm */
  if (flag_omit_frame_pointer)
    sorry ("this implementation of exception handling requires a frame pointer");

  emit_move_insn (stack_pointer_rtx,
		  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -8)));
  emit_move_insn (hard_frame_pointer_rtx,
		  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -12)));
#endif
#if defined (TARGET_88000) /* was m88k */
  rtx temp_frame = frame_pointer_rtx;

  temp_frame = memory_address (Pmode, temp_frame);
  temp_frame = copy_to_reg (gen_rtx (MEM, Pmode, temp_frame));

  /* hopefully this will successfully pop the frame! */
  emit_move_insn (frame_pointer_rtx, temp_frame);
  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);
  emit_move_insn (arg_pointer_rtx, frame_pointer_rtx);
  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,
						     (HOST_WIDE_INT)m88k_debugger_offset (stack_pointer_rtx, 0))));

#if 0
  emit_insn (gen_add2_insn (arg_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,
						   -(HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));

  emit_move_insn (stack_pointer_rtx, arg_pointer_rtx);

  emit_insn (gen_add2_insn (stack_pointer_rtx, gen_rtx (CONST_INT, VOIDmode,
						     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));
#endif
#endif
#if ! defined (TARGET_88000) && ! defined (ARM_FRAME_RTX) && ! defined (SPARC_STACK_ALIGN)
  tree fcall;
  tree params;
  rtx next_pc;

#if 0
  /* I would like to do this here, but the move below doesn't seem to work.  */
  /* Call to  __builtin_return_address.  */
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
  fcall = build_function_call (BuiltinReturnAddress, params);
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);

  emit_move_insn (next_pc, inner_throw_label);
  /* So, for now, just pass throw label to stack unwinder.  */
#endif
  params = expr_tree_cons (NULL_TREE, make_tree (ptr_type_node,
					    inner_throw_label), NULL_TREE);
  
  do_function_call (Unwind, params, NULL_TREE);
  assemble_external (TREE_OPERAND (Unwind, 0));
  emit_barrier ();
#endif
}


/* Is called from expand_exception_blocks to generate the code in a function
   to "throw" if anything in the function needs to perform a throw.

   expands "throw" as the following pseudo code:

	throw:
		eh = find_first_exception_match (saved_pc);
	    if (!eh) goto gotta_rethrow_it;
		goto eh;

	gotta_rethrow_it:
		saved_pc = __builtin_return_address (0);
		pop_to_previous_level ();
		goto throw;  */

void
expand_builtin_throw ()
{
#ifndef DWARF2_UNWIND_INFO
  tree fcall;
  tree params;
  rtx handler;
  rtx saved_pcnthrow;
  rtx next_pc;
  rtx gotta_rethrow_it;
  rtx gotta_call_terminate;
  rtx after_unwind;
  rtx top_of_loop;
  tree t;
  rtx x;

  if (! doing_eh (0))
    return;

  if (! throw_used)
    return;

  params = void_list_node;
  t = make_call_declarator (get_identifier ("__throw"), params, NULL_TREE,
			    NULL_TREE);
  start_function (decl_tree_cons (NULL_TREE,
				  get_identifier ("void"),
				  decl_tree_cons (NULL_TREE,
						  get_identifier ("static"),
						  NULL_TREE)),
		  t, NULL_TREE, 0);
  store_parm_decls ();
  pushlevel (0);
  clear_last_expr ();
  push_momentary ();
  expand_start_bindings (0);

  gotta_rethrow_it = gen_label_rtx ();
  gotta_call_terminate = gen_label_rtx ();

  /* These two can be frontend specific.  If wanted, they can go in
     expand_throw.  */
  /* Do we have a valid object we are throwing? */
  t = call_eh_info ();
  emit_cmp_insn (expand_expr (t, NULL_RTX, Pmode, 0),
		 const0_rtx, EQ, NULL_RTX,
		 GET_MODE (DECL_RTL (t)), 0, 0);
  emit_jump_insn (gen_beq (gotta_call_terminate));

  /* search for an exception handler for the saved_pc */
  handler = do_function_call (FirstExceptionMatch,
			      expr_tree_cons (NULL_TREE, saved_pc,
					 NULL_TREE),
			      ptr_type_node);
  assemble_external (TREE_OPERAND (FirstExceptionMatch, 0));

  /* did we find one? */
  emit_cmp_insn (handler, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (handler), 0, 0);

  /* if not, jump to gotta_rethrow_it */
  emit_jump_insn (gen_beq (gotta_rethrow_it));

  {
    rtx ret_val, x;
    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,
					  0, hard_frame_pointer_rtx);

    /* Set it up so that we continue at the handler.  */
    emit_move_insn (ret_val, handler);
#ifdef RETURN_ADDR_OFFSET
    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);
    if (x != ret_val)
      emit_move_insn (ret_val, x);
#endif

    expand_null_return ();
  }

  top_of_loop = gen_label_rtx ();
  emit_label (top_of_loop);
  
#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      saved_pcnthrow = gen_reg_rtx (Pmode);
      emit_move_insn (saved_pcnthrow, hard_function_value (ptr_type_node,
							   NULL_TREE));
    }
#endif
      
  /* Call to  __builtin_return_address.  */
#if defined (ARM_FRAME_RTX)  /* was __arm */
  /* This should be moved into arm.h:RETURN_ADDR_RTX */
  /* This replaces a 'call' to __builtin_return_address */
  next_pc = gen_reg_rtx (Pmode);
  emit_move_insn (next_pc,
		  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));
#else
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
  fcall = build_function_call (BuiltinReturnAddress, params);
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);
#endif

  /* Did __builtin_return_address return a valid address?  */
  emit_cmp_insn (next_pc, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (next_pc), 0, 0);

  emit_jump_insn (gen_beq (gotta_call_terminate));

  next_pc = eh_outer_context (next_pc);

  /* Yes it did.  */
#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      rtx x;

      x = validize_mem (gen_rtx (MEM, Pmode, saved_pcnthrow));
      emit_move_insn (validize_mem (gen_rtx (MEM, Pmode, x)),
		      next_pc);
#ifdef FUNCTION_OUTGOING_VALUE	
      emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),
		      validize_mem (gen_rtx (MEM, Pmode,
					     plus_constant (saved_pcnthrow,
							    GET_MODE_SIZE (Pmode)))));
      emit_insn (gen_rtx (USE, VOIDmode,
			  FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));
#endif
    }
  else
#endif
    emit_move_insn (eh_saved_pc_rtx, next_pc);

  after_unwind = gen_label_rtx ();
  do_unwind (gen_rtx (LABEL_REF, Pmode, after_unwind));

  emit_label (after_unwind);

#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      t = build_function_type (void_type_node, void_list_node);
      t = make_tree (build_pointer_type (t),
		     hard_function_value (ptr_type_node,
					  NULL_TREE));
      t = build_function_call (t, NULL_TREE);
      expand_expr (t, const0_rtx, VOIDmode, 0);
    }
  else
#endif
    emit_throw ();

  /* no it didn't --> therefore we need to call terminate */
  emit_label (gotta_call_terminate);
  do_function_call (Terminate, NULL_TREE, NULL_TREE);

  {
    rtx ret_val, x;
    /* code to deal with unwinding and looking for it again */
    emit_label (gotta_rethrow_it);
    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,
					  0, hard_frame_pointer_rtx);

    /* Set it up so that we continue inside, at the top of the loop.  */
    emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, top_of_loop));
#ifdef RETURN_ADDR_OFFSET
    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);
    if (x != ret_val)
      emit_move_insn (ret_val, x);
#endif

#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
    if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
      {
	rtx x = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode,
						  "__eh_pcnthrow"),
					 NULL_RTX, 1,
					 Pmode, 0);
	/* This is to get a version of throw that will throw properly.  */
	emit_move_insn (validize_mem (gen_rtx (MEM, Pmode,
					       plus_constant (x, GET_MODE_SIZE (Pmode)))),
			throw_libfunc);
#ifdef FUNCTION_OUTGOING_VALUE	
	emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),
			x);
	emit_insn (gen_rtx (USE, VOIDmode, FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));
#endif
      }
#endif

    /* Fall into epilogue to unwind prologue.  */
  }

  expand_end_bindings (getdecls (), 1, 0);
  poplevel (1, 0, 0);
  pop_momentary ();

  finish_function (lineno, 0, 0);
#endif /* DWARF2_UNWIND_INFO */
}


void
expand_start_eh_spec ()
{
  expand_eh_region_start ();
}

static void
expand_end_eh_spec (raises)
     tree raises;
{
  tree expr, second_try;
  rtx check = gen_label_rtx ();
  rtx cont;
  rtx ret = gen_reg_rtx (Pmode);
  rtx flag = gen_reg_rtx (TYPE_MODE (integer_type_node));
  rtx end = gen_label_rtx ();

  expr = make_node (RTL_EXPR);
  TREE_TYPE (expr) = void_type_node;
  RTL_EXPR_RTL (expr) = const0_rtx;
  TREE_SIDE_EFFECTS (expr) = 1;
  do_pending_stack_adjust ();
  start_sequence_for_rtl_expr (expr);
  cont = gen_label_rtx ();
  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));
  emit_jump (check);
  emit_label (cont);
  jumpif (make_tree (integer_type_node, flag), end);
  do_function_call (Terminate, NULL_TREE, NULL_TREE);
  emit_barrier ();
  do_pending_stack_adjust ();
  RTL_EXPR_SEQUENCE (expr) = get_insns ();
  end_sequence ();
  
  second_try = expr;

  expr = make_node (RTL_EXPR);
  TREE_TYPE (expr) = void_type_node;
  RTL_EXPR_RTL (expr) = const0_rtx;
  TREE_SIDE_EFFECTS (expr) = 1;
  do_pending_stack_adjust ();
  start_sequence_for_rtl_expr (expr);

  cont = gen_label_rtx ();
  emit_move_insn (ret, gen_rtx (LABEL_REF, Pmode, cont));
  emit_jump (check);
  emit_label (cont);
  jumpif (make_tree (integer_type_node, flag), end);
  expand_eh_region_start ();
  do_function_call (Unexpected, NULL_TREE, NULL_TREE);
  assemble_external (TREE_OPERAND (Unexpected, 0));
  emit_barrier ();

  expand_eh_region_end (second_try);
  
  emit_label (check);
  emit_move_insn (flag, const1_rtx);
  cont = gen_label_rtx ();

  push_eh_info ();

  while (raises)
    {
      tree exp;
      tree match_type = TREE_VALUE (raises);
      
      if (match_type)
	{
	  /* check TREE_VALUE (raises) here */
	  exp = get_eh_value ();
	  exp = expr_tree_cons (NULL_TREE,
			   build_eh_type_type (match_type),
			   expr_tree_cons (NULL_TREE,
				      get_eh_type (),
				      expr_tree_cons (NULL_TREE, exp, NULL_TREE)));
	  exp = build_function_call (CatchMatch, exp);
	  assemble_external (TREE_OPERAND (CatchMatch, 0));

	  jumpif (exp, cont);
	}

      raises = TREE_CHAIN (raises);
    }
  emit_move_insn (flag, const0_rtx);
  emit_label (cont);
  emit_indirect_jump (ret);
  emit_label (end);
  
  do_pending_stack_adjust ();
  RTL_EXPR_SEQUENCE (expr) = get_insns ();
  end_sequence ();
  
  expand_eh_region_end (expr);
}

/* This is called to expand all the toplevel exception handling
   finalization for a function.  It should only be called once per
   function.  */

void
expand_exception_blocks ()
{
  do_pending_stack_adjust ();
  push_to_sequence (catch_clauses);
  expand_leftover_cleanups ();
  do_pending_stack_adjust ();
  catch_clauses = get_insns ();
  end_sequence ();

  /* Do this after we expand leftover cleanups, so that the
     expand_eh_region_end that expand_end_eh_spec does will match the
     right expand_eh_region_start, and make sure it comes out before
     the terminate protected region.  */
  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))
    {
     expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));
     do_pending_stack_adjust ();
     push_to_sequence (catch_clauses);
     expand_leftover_cleanups ();
     do_pending_stack_adjust ();
     catch_clauses = get_insns ();
     end_sequence ();
    }

  if (catch_clauses)
    {
      rtx funcend = gen_label_rtx ();
      emit_jump (funcend);

      /* We cannot protect n regions this way if we must flow into the
	 EH region through the top of the region, as we have to with
	 the setjmp/longjmp approach.  */
      if (exceptions_via_longjmp == 0)
	{
	  expand_eh_region_start ();
	}

      emit_insns (catch_clauses);
      catch_clauses = NULL_RTX;

      if (exceptions_via_longjmp == 0)
	expand_eh_region_end (build_function_call (Terminate, NULL_TREE));

      expand_leftover_cleanups ();

      emit_label (funcend);
    }
}

tree
start_anon_func ()
{
  static int counter = 0;
  int old_interface_unknown = interface_unknown;
  char name[32];
  tree params;
  tree t;

  push_cp_function_context (NULL_TREE);
  push_to_top_level ();

  /* No need to mangle this.  */
  push_lang_context (lang_name_c);

  interface_unknown = 1;

  params = void_list_node;
  /* tcf stands for throw clean function.  */
  sprintf (name, "__tcf_%d", counter++);
  t = make_call_declarator (get_identifier (name), params, NULL_TREE,
			    NULL_TREE);
  start_function (decl_tree_cons (NULL_TREE, get_identifier ("static"),
				  void_list_node),
		  t, NULL_TREE, 0);
  store_parm_decls ();
  pushlevel (0);
  clear_last_expr ();
  push_momentary ();
  expand_start_bindings (0);
  emit_line_note (input_filename, lineno);

  interface_unknown = old_interface_unknown;

  pop_lang_context ();

  return current_function_decl;
}

void
end_anon_func ()
{
  expand_end_bindings (getdecls (), 1, 0);
  poplevel (1, 0, 0);
  pop_momentary ();

  finish_function (lineno, 0, 0);

  pop_from_top_level ();
  pop_cp_function_context (NULL_TREE);
}

/* Expand a throw statement.  This follows the following
   algorithm:

	1. Allocate space to save the current PC onto the stack.
	2. Generate and emit a label and save its address into the
		newly allocated stack space since we can't save the pc directly.
	3. If this is the first call to throw in this function:
		generate a label for the throw block
	4. jump to the throw block label.  */

void
expand_throw (exp)
     tree exp;
{
  rtx label;
  tree fn;
  static tree cleanup_type;

  if (! doing_eh (1))
    return;

  if (exp)
    {
      tree throw_type;
      tree cleanup = NULL_TREE, e;

      /* throw expression */
      /* First, decay it.  */
      exp = decay_conversion (exp);

      /* cleanup_type is void (*)(void *, int),
	 the internal type of a destructor. */
      if (cleanup_type == NULL_TREE)
	{
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  cleanup_type = build_pointer_type
	    (build_function_type
	     (void_type_node, tree_cons
	      (NULL_TREE, ptr_type_node, tree_cons
	       (NULL_TREE, integer_type_node, void_list_node))));
	  pop_obstacks ();
	}

      if (TREE_CODE (TREE_TYPE (exp)) == POINTER_TYPE)
	{
	  throw_type = build_eh_type (exp);
	  exp = build_reinterpret_cast (ptr_type_node, exp);
	}
      else
	{
	  tree object;

	  /* Make a copy of the thrown object.  WP 15.1.5  */
	  exp = build_new (NULL_TREE, TREE_TYPE (exp),
			   build_expr_list (NULL_TREE, exp),
			   0);

	  if (exp == error_mark_node)
	    error ("  in thrown expression");

	  object = build_indirect_ref (exp, NULL_PTR);
	  throw_type = build_eh_type (object);

	  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))
	    {
	      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),
					 dtor_identifier, 0);
	      cleanup = TREE_VALUE (cleanup);
	      mark_used (cleanup);
	      mark_addressable (cleanup);
	      /* Pretend it's a normal function.  */
	      cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);
	    }
	}

      if (cleanup == NULL_TREE)
	{
	  cleanup = build_int_2 (0, 0);
	  TREE_TYPE (cleanup) = cleanup_type;
	}

      fn = get_identifier ("__cp_push_exception");
      if (IDENTIFIER_GLOBAL_VALUE (fn))
	fn = IDENTIFIER_GLOBAL_VALUE (fn);
      else
	{
	  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),
	     as defined in exception.cc.  */
	  tree tmp;
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  tmp = tree_cons
	    (NULL_TREE, ptr_type_node, tree_cons
	     (NULL_TREE, ptr_type_node, tree_cons
	      (NULL_TREE, cleanup_type, void_list_node)));
	  fn = build_lang_decl (FUNCTION_DECL, fn,
				build_function_type (void_type_node, tmp));
	  DECL_EXTERNAL (fn) = 1;
	  TREE_PUBLIC (fn) = 1;
	  DECL_ARTIFICIAL (fn) = 1;
	  pushdecl_top_level (fn);
	  make_function_rtl (fn);
	  assemble_external (fn);
	  pop_obstacks ();
	}

      /* The throw expression is a full-expression.  */
      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);
      e = expr_tree_cons (NULL_TREE, exp, expr_tree_cons
			  (NULL_TREE, throw_type, expr_tree_cons
			   (NULL_TREE, cleanup, NULL_TREE)));
      e = build_function_call (fn, e);
      expand_expr (e, const0_rtx, VOIDmode, 0);
    }
  else
    {
      /* rethrow current exception; note that it's no longer caught.  */

      tree fn = get_identifier ("__uncatch_exception");
      if (IDENTIFIER_GLOBAL_VALUE (fn))
	fn = IDENTIFIER_GLOBAL_VALUE (fn);
      else
	{
	  /* Declare void __uncatch_exception (void)
	     as defined in exception.cc. */
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  fn = build_lang_decl (FUNCTION_DECL, fn,
				build_function_type (void_type_node,
						     void_list_node));
	  DECL_EXTERNAL (fn) = 1;
	  TREE_PUBLIC (fn) = 1;
	  DECL_ARTIFICIAL (fn) = 1;
	  pushdecl_top_level (fn);
	  make_function_rtl (fn);
	  assemble_external (fn);
	  pop_obstacks ();
	}

      exp = build_function_call (fn, NULL_TREE);
      expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);
    }

  if (exceptions_via_longjmp)
    emit_throw ();
  else
    {
      /* This is the label that represents where in the code we were, when
	 we got an exception.  This needs to be updated when we rethrow an
	 exception, so that the matching routine knows to search out.  */
      label = gen_label_rtx ();
      emit_label (label);

      expand_internal_throw (label);
    }
}

/* Build a throw expression.  */

tree
build_throw (e)
     tree e;
{
  if (e != error_mark_node)
    {
      if (processing_template_decl)
	return build_min (THROW_EXPR, void_type_node, e);
      e = build1 (THROW_EXPR, void_type_node, e);
      TREE_SIDE_EFFECTS (e) = 1;
      TREE_USED (e) = 1;
    }
  return e;
}
@


1.3
log
@update to gcc 2.8.1
@
text
@@


1.2
log
@GCC 2.8.0 merge
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92-96, 1997 Free Software Foundation, Inc.
a179 3
/* Holds a ready to emit call to "terminate".  */
static tree TerminateFunctionCall;

d282 1
a282 1
  Terminate = default_conversion (terminate_fndecl);
a289 2
  TerminateFunctionCall = build_function_call (Terminate, NULL_TREE);

d477 1
a477 2
do_pop_exception (handler)
     tree handler;
d492 1
a492 3
			      (NULL_TREE, ptr_type_node, tree_cons
			       (NULL_TREE, boolean_type_node,
				void_list_node))));
d505 1
a505 2
				 (NULL_TREE, cleanup, expr_tree_cons
				  (NULL_TREE, handler, NULL_TREE)));
d514 1
a514 4
  /* All cleanups must last longer than normal.  */
  int yes = suspend_momentary ();
  expand_decl_cleanup_no_eh (NULL_TREE, do_pop_exception (boolean_false_node));
  resume_momentary (yes);
d519 4
a522 3
  /* We don't destroy the exception object on rethrow, so we can't use
     the normal cleanup mechanism for it.  */
  expand_eh_region_start ();
d605 7
d642 4
d650 1
a650 2
	  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,
			TerminateFunctionCall);
a691 3
  /* Matches push_eh_cleanup.  */
  expand_eh_region_end (do_pop_exception (boolean_true_node));

a986 1
  assemble_external (TREE_OPERAND (Terminate, 0));
a1062 1
  assemble_external (TREE_OPERAND (Terminate, 0));
a1167 3
	  /* Is this necessary?  */
	  assemble_external (TREE_OPERAND (Terminate, 0));

d1175 1
a1175 1
	expand_eh_region_end (TerminateFunctionCall);
d1304 1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.
a24 2
/* High-level class interface. */

d26 1
d33 4
a37 3
tree protect_list;

extern void (*interim_eh_hook)	PROTO((tree));
d40 1
a40 1
/* holds the fndecl for __builtin_return_address () */
a41 33
tree throw_fndecl;

static int
doing_eh (do_warn)
     int do_warn;
{
  if (! flag_handle_exceptions)
    {
      static int warned = 0;
      if (! warned && do_warn)
	{
	  error ("exception handling disabled, use -fhandle-exceptions to enable.");
	  warned = 1;
	}
      return 0;
    }
  return 1;
}


/*
NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer
to supporting exception handling as per ANSI C++ working draft.
It is a complete rewrite of all the EH stuff that was here before
	Shortcomings:
		1. Throw specifications of functions still don't work.
	Cool Things:
		1. Destructors are called properly :-)
		2. No overhead for the non-exception thrown case.
		3. Fixing shortcoming 1 is simple.
			-Tad Hunt	(tad@@mail.csh.rit.edu)

*/
d45 1
a45 1
/* used to cache a call to __builtin_return_address () */
d48 7
a55 18
#include <stdio.h>

/* XXX - Tad: for EH */
/* output an exception table entry */

static void
output_exception_table_entry (file, start_label, end_label, eh_label)
     FILE *file;
     rtx start_label, end_label, eh_label;
{
  char label[100];

  assemble_integer (start_label, GET_MODE_SIZE (Pmode), 1);
  assemble_integer (end_label, GET_MODE_SIZE (Pmode), 1);
  assemble_integer (eh_label, GET_MODE_SIZE (Pmode), 1);
  putc ('\n', file);		/* blank line */
}
   
d65 1
a65 1
/* This is the startup, and finish stuff per exception table. */
d74 2
a75 2
    void *start_protect;
    void *end_protect;
a103 30
void
exception_section ()
{
#ifdef ASM_OUTPUT_SECTION_NAME
  named_section (NULL_TREE, ".gcc_except_table");
#else
  if (flag_pic)
    data_section ();
  else
#if defined(TARGET_POWERPC) /* are we on a __rs6000? */
    data_section ();
#else
    readonly_data_section ();
#endif
#endif
}




/* from: my-cp-except.c */

/* VI: ":set ts=4" */
#if 0
#include <stdio.h> */
#include "config.h"
#include "tree.h"
#include "rtl.h"
#include "cp-tree.h"
#endif
a104 3
#if 0
#include "flags.h"
#endif
a106 3
#if 0
#include "expr.h"
#endif
d117 2
a118 2
     (&eh_stack) is called.  Pop_eh_entry () returns the ehEntry it
     created when push_eh_entry () was called.  The ehEntry structure
d123 1
a123 1
     in the finalization variable in the ehEntry structure.  Otherwise
d125 1
a125 1
     is the the end of a try block.  Next, this modified ehEntry node
d154 1
a154 1
     entry in the ehQueue until we get to an entry with a NULL
d159 1
a159 1
     enqueue'ing this new ehEntry to be output at an outer level.
a166 3
extern rtx emit_insn		PROTO((rtx));
extern rtx gen_nop		PROTO(());

d170 3
a172 3
/* used to cache "terminate ()", "unexpected ()", "set_terminate ()", and
   "set_unexpected ()" after default_conversion. (lib-except.c)  */
static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch, Throw;
d174 1
a174 2
/* used to cache __find_first_exception_table_match ()
   for throw (lib-except.c)  */
d177 1
a177 1
/* used to cache a call to __unwind_function () (lib-except.c)  */
d180 1
a180 1
/* holds a ready to emit call to "terminate ()".  */
a185 37

/* data structures for my various quick and dirty stacks and queues
   Eventually, most of this should go away, because I think it can be
   integrated with stuff already built into the compiler.  */

/* =================================================================== */

struct labelNode {
  rtx label;
  struct labelNode *chain;
};


/* this is the most important structure here.  Basically this is how I store
   an exception table entry internally. */
struct ehEntry {
  rtx start_label;
  rtx end_label;
  rtx exception_handler_label;

  tree finalization;
  tree context;
};

struct ehNode {
  struct ehEntry *entry;
  struct ehNode *chain;
};

struct ehStack {
  struct ehNode *top;
};

struct ehQueue {
  struct ehNode *head;
  struct ehNode *tail;
};
d196 1
a196 17
tree saved_pc;
/* Holds the type of the thing being thrown. */
tree saved_throw_type;
/* Holds the value being thrown.  */
tree saved_throw_value;

int throw_used;

static rtx catch_clauses;
static first_catch_label;

static struct ehStack ehstack;
static struct ehQueue ehqueue;
static struct ehQueue eh_table_output_queue;
static struct labelNode *false_label_stack = NULL;
static struct labelNode *caught_return_label_stack = NULL;
/* ========================================================================= */
d198 2
a199 11
/* function prototypes */
static struct ehEntry *pop_eh_entry	PROTO((struct ehStack *stack));
static void enqueue_eh_entry		PROTO((struct ehQueue *queue, struct ehEntry *entry));
static rtx push_eh_entry		PROTO((struct ehStack *stack));
static struct ehEntry *dequeue_eh_entry	PROTO((struct ehQueue *queue));
static void new_eh_queue		PROTO((struct ehQueue *queue));
static void new_eh_stack		PROTO((struct ehStack *stack));
static void push_label_entry		PROTO((struct labelNode **labelstack, rtx label));
static rtx pop_label_entry		PROTO((struct labelNode **labelstack));
static rtx top_label_entry		PROTO((struct labelNode **labelstack));
static struct ehEntry *copy_eh_entry	PROTO((struct ehEntry *entry));
d201 1
d203 1
a203 65

/* All my cheesy stack/queue/misc data structure handling routines

   ========================================================================= */

static void
push_label_entry (labelstack, label)
     struct labelNode **labelstack;
     rtx label;
{
  struct labelNode *newnode=(struct labelNode*)xmalloc (sizeof (struct labelNode));

  newnode->label = label;
  newnode->chain = *labelstack;
  *labelstack = newnode;
}

static rtx
pop_label_entry (labelstack)
     struct labelNode **labelstack;
{
  rtx label;
  struct labelNode *tempnode;

  if (! *labelstack) return NULL_RTX;

  tempnode = *labelstack;
  label = tempnode->label;
  *labelstack = (*labelstack)->chain;
  free (tempnode);

  return label;
}

static rtx
top_label_entry (labelstack)
     struct labelNode **labelstack;
{
  if (! *labelstack) return NULL_RTX;

  return (*labelstack)->label;
}

/* Push to permanent obstack for rtl generation.
   One level only!  */
static struct obstack *saved_rtl_obstack;
void
push_rtl_perm ()
{
  extern struct obstack permanent_obstack;
  extern struct obstack *rtl_obstack;
  
  saved_rtl_obstack = rtl_obstack;
  rtl_obstack = &permanent_obstack;
}

/* Pop back to normal rtl handling.  */
static void
pop_rtl_from_perm ()
{
  extern struct obstack permanent_obstack;
  extern struct obstack *rtl_obstack;
  
  rtl_obstack = saved_rtl_obstack;
}
a205 121
push_eh_entry (stack)
     struct ehStack *stack;
{
  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));
  struct ehEntry *entry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));

  if (stack == NULL) {
    free (node);
    free (entry);
    return NULL_RTX;
  }

  /* These are saved for the exception table.  */
  push_rtl_perm ();
  entry->start_label = gen_label_rtx ();
  entry->end_label = gen_label_rtx ();
  entry->exception_handler_label = gen_label_rtx ();
  pop_rtl_from_perm ();

  LABEL_PRESERVE_P (entry->start_label) = 1;
  LABEL_PRESERVE_P (entry->end_label) = 1;
  LABEL_PRESERVE_P (entry->exception_handler_label) = 1;

  entry->finalization = NULL_TREE;
  entry->context = current_function_decl;

  node->entry = entry;
  node->chain = stack->top;
  stack->top = node;

  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));

  return entry->start_label;
}

static struct ehEntry *
pop_eh_entry (stack)
     struct ehStack *stack;
{
  struct ehNode *tempnode;
  struct ehEntry *tempentry;

  if (stack && (tempnode = stack->top)) {
    tempentry = tempnode->entry;
    stack->top = stack->top->chain;
    free (tempnode);

    return tempentry;
  }

  return NULL;
}

static struct ehEntry *
copy_eh_entry (entry)
     struct ehEntry *entry;
{
  struct ehEntry *newentry;

  newentry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));
  memcpy ((void*)newentry, (void*)entry, sizeof (struct ehEntry));

  return newentry;
}

static void
enqueue_eh_entry (queue, entry)
     struct ehQueue *queue;
     struct ehEntry *entry;
{
  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));

  node->entry = entry;
  node->chain = NULL;

  if (queue->head == NULL)
    {
      queue->head = node;
    }
  else
    {
      queue->tail->chain = node;
    }
  queue->tail = node;
}

static struct ehEntry *
dequeue_eh_entry (queue)
     struct ehQueue *queue;
{
  struct ehNode *tempnode;
  struct ehEntry *tempentry;

  if (queue->head == NULL)
    return NULL;

  tempnode = queue->head;
  queue->head = queue->head->chain;

  tempentry = tempnode->entry;
  free (tempnode);

  return tempentry;
}

static void
new_eh_queue (queue)
     struct ehQueue *queue;
{
  queue->head = queue->tail = NULL;
}

static void
new_eh_stack (stack)
     struct ehStack *stack;
{
  stack->top = NULL;
}

/* cheesyness to save some typing. returns the return value rtx */
rtx
a216 15
static void
expand_internal_throw (pc)
     rtx pc;
{
  tree params;

  emit_move_insn (DECL_RTL (saved_pc), pc);
#ifdef JUMP_TO_THROW
  emit_indirect_jump (gen_rtx (SYMBOL_REF, Pmode, "__throw"));
#else
  do_function_call (Throw, NULL_TREE, NULL_TREE);
#endif
  throw_used = 1;
}

a218 12
void
lang_interim_eh (finalization)
     tree finalization;
{
  if (finalization)
    end_protect (finalization);
  else
    start_protect ();
}

extern tree auto_function PROTO((tree, tree, enum built_in_function));

d223 1
a223 5
		- Setting up all the function call trees
		- Initializing the ehqueue
		- Initializing the eh_table_output_queue
		- Initializing the ehstack
*/
a227 1
  extern tree define_function ();
d236 3
d240 1
a240 2
  tree PFV = build_pointer_type (build_function_type
				 (void_type_node, void_list_node));
d242 2
a243 2
  /* arg list for the build_function_type call for set_terminate () and
     set_unexpected () */
a248 3
  /* void vtype () */
  tree vtype = build_function_type (void_type_node, void_list_node);
  
d257 1
a257 2

  interim_eh_hook = lang_interim_eh;
d261 22
a282 36
  catch_match_fndecl =
    define_function (flag_rtti
		     ? "__throw_type_match_rtti"
		     : "__throw_type_match",
		     build_function_type (ptr_type_node,
					  tree_cons (NULL_TREE, ptr_type_node,
						     tree_cons (NULL_TREE, ptr_type_node,
								tree_cons (NULL_TREE, ptr_type_node,
									   void_list_node)))),
		     NOT_BUILT_IN,
		     pushdecl,
		     0);
  find_first_exception_match_fndecl =
    define_function ("__find_first_exception_table_match",
		     build_function_type (ptr_type_node,
					  tree_cons (NULL_TREE, ptr_type_node,
						     void_list_node)),
		     NOT_BUILT_IN,
		     pushdecl,
		     0);
  unwind_fndecl =
    define_function ("__unwind_function",
		     build_function_type (void_type_node,
					  tree_cons (NULL_TREE, ptr_type_node,
						     void_list_node)),
		     NOT_BUILT_IN,
		     pushdecl,
		     0);
  throw_fndecl =
    define_function ("__throw",
		     build_function_type (void_type_node, void_list_node),
		     NOT_BUILT_IN,
		     pushdecl,
		     0);
  DECL_EXTERNAL (throw_fndecl) = 0;
  TREE_PUBLIC (throw_fndecl) = 0;
a290 1
  Throw = default_conversion (throw_fndecl);
d297 4
a300 8
  new_eh_queue (&ehqueue);
  new_eh_queue (&eh_table_output_queue);
  new_eh_stack (&ehstack);

  declspecs = tree_cons (NULL_TREE, get_identifier ("void"), NULL_TREE);
  d = build_parse_node (INDIRECT_REF, get_identifier ("__eh_pc"));
  d = start_decl (d, declspecs, 0, NULL_TREE);
  DECL_COMMON (d) = 1;
d302 1
a302 1
  saved_pc = lookup_name (get_identifier ("__eh_pc"), 0);
d304 3
a306 13
  declspecs = tree_cons (NULL_TREE, get_identifier ("void"), NULL_TREE);
  d = build_parse_node (INDIRECT_REF, get_identifier ("__eh_type"));
  d = start_decl (d, declspecs, 0, NULL_TREE);
  DECL_COMMON (d) = 1;
  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
  saved_throw_type = lookup_name (get_identifier ("__eh_type"), 0);

  declspecs = tree_cons (NULL_TREE, get_identifier ("void"), NULL_TREE);
  d = build_parse_node (INDIRECT_REF, get_identifier ("__eh_value"));
  d = start_decl (d, declspecs, 0, NULL_TREE);
  DECL_COMMON (d) = 1;
  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
  saved_throw_value = lookup_name (get_identifier ("__eh_value"), 0);
d309 1
a309 7
/* call this to begin a block of unwind protection (ie: when an object is
   constructed) */
void
start_protect ()
{
  if (! doing_eh (0))
    return;
d311 2
a312 9
  emit_label (push_eh_entry (&ehstack));
}
   
/* call this to end a block of unwind protection.  the finalization tree is
   the finalization which needs to be run in order to cleanly unwind through
   this level of protection. (ie: call this when a scope is exited)*/
void
end_protect (finalization)
     tree finalization;
d314 1
a314 1
  struct ehEntry *entry;
d316 6
a321 2
  if (! doing_eh (0))
    return;
d323 41
a363 1
  entry = pop_eh_entry (&ehstack);
d365 2
a366 7
  emit_label (entry->end_label);
  /* Put in something that takes up space, as otherwise the end
     address for the EH region could have the exact same address as
     the outer region, causing us to miss the fact that resuming
     exception handling with this PC value would be inside the outer
     region.  */
  emit_insn (gen_nop ());
d368 4
a371 1
  entry->finalization = finalization;
d373 8
a380 1
  enqueue_eh_entry (&ehqueue, entry);
d383 4
a386 3
/* call this on start of a try block. */
void
expand_start_try_stmts ()
d388 4
a391 2
  if (! doing_eh (1))
    return;
d393 1
a393 2
  start_protect ();
}
d395 2
a396 2
void
expand_end_try_stmts ()
d398 2
a399 1
  end_protect (integer_zero_node);
d402 1
d404 2
a405 3
/* call this to start processing of all the catch blocks. */
void
expand_start_all_catch ()
d407 3
a409 2
  struct ehEntry *entry;
  rtx label;
d411 2
a412 2
  if (! doing_eh (1))
    return;
d414 6
a419 25
  emit_line_note (input_filename, lineno);
  label = gen_label_rtx ();

  /* The label for the exception handling block we will save.  This is
     Lresume, in the documention.  */
  emit_label (label);
  
  /* Put in something that takes up space, as otherwise the end
     address for the EH region could have the exact same address as
     the outer region, causing us to miss the fact that resuming
     exception handling with this PC value would be inside the outer
     region.  */
  emit_insn (gen_nop ());

  push_label_entry (&caught_return_label_stack, label);

  /* Start a new sequence for all the catch blocks.  We will add this
     to the gloabl sequence catch_clauses, when we have completed all
     the handlers in this handler-seq.  */
  start_sequence ();

  while (1)
    {
      entry = dequeue_eh_entry (&ehqueue);
      emit_label (entry->exception_handler_label);
d421 2
a422 1
      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);
d424 2
a425 18
      /* When we get down to the matching entry, stop.  */
      if (entry->finalization == integer_zero_node)
	break;

      /* The below can be optimized away, and we could just fall into the
	 next EH handler, if we are certain they are nested.  */
      /* Code to throw out to outer context, if we fall off end of the
	 handler.  */
      expand_internal_throw (gen_rtx (LABEL_REF,
				      Pmode,
				      entry->end_label));
      free (entry);
    }
}

/* call this to end processing of all the catch blocks. */
void
expand_end_all_catch ()
d427 2
a428 28
  rtx new_catch_clause;

  if (! doing_eh (1))
    return;

  /* Code to throw out to outer context, if we fall off end of catch
     handlers.  This is rethrow (Lresume, same id, same obj); in the
     documentation.  */
  expand_internal_throw (gen_rtx (LABEL_REF,
				  Pmode,
				  top_label_entry (&caught_return_label_stack)));

  /* Now we have the complete catch sequence.  */
  new_catch_clause = get_insns ();
  end_sequence ();
  
  /* this level of catch blocks is done, so set up the successful catch jump
     label for the next layer of catch blocks. */
  pop_label_entry (&caught_return_label_stack);

  /* Add the new sequence of catchs to the main one for this
     function.  */
  push_to_sequence (catch_clauses);
  emit_insns (new_catch_clause);
  catch_clauses = get_insns ();
  end_sequence ();
  
  /* Here we fall through into the continuation code.  */
d433 1
d444 1
a444 1
  /* peel back references, so they match. */
d448 1
a448 1
  /* Peel off cv qualifiers. */
d463 1
d476 60
d541 1
a546 1
  rtx protect_label_rtx;
d550 15
d568 14
a581 1
  /* Create a binding level for the parm.  */
d585 5
a589 6
  /* This is saved for the exception table.  */
  push_rtl_perm ();
  protect_label_rtx = gen_label_rtx ();
  pop_rtl_from_perm ();
  push_label_entry (&false_label_stack, false_label_rtx);
  push_label_entry (&false_label_stack, protect_label_rtx);
d593 8
d605 3
a607 8
      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1,
			     NULL_TREE, NULL_TREE);

      if (decl == NULL_TREE)
	{
	  error ("invalid catch parameter");
	  return;
	}
d609 1
a609 1
      /* Figure out the type that the initializer is. */
d615 2
a616 2
      exp = saved_throw_value;
      exp = tree_cons (NULL_TREE,
d618 3
a620 3
		       tree_cons (NULL_TREE,
				  saved_throw_type,
				  tree_cons (NULL_TREE, exp, NULL_TREE)));
d634 19
a652 1
      init = convert_from_reference (save_expr (make_tree (init_type, call_rtx)));
a653 1
      /* Do we need the below two lines? */
d657 1
d662 7
a668 1
      /* Fall into the catch all section. */
d671 2
a672 2
  /* This is the starting of something to protect.  */
  emit_label (protect_label_rtx);
a677 35
/* this is called from expand_exception_blocks and
   expand_end_catch_block to expand the toplevel finalizations for a
   function.  We return the first label emitted, if any, otherwise
   return NULL_RTX.  */
static rtx
expand_leftover_cleanups ()
{
  struct ehEntry *entry;
  rtx first_label = NULL_RTX;

  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)
    {
      if (! first_label)
	first_label = entry->exception_handler_label;
      emit_label (entry->exception_handler_label);

      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);

      /* The below can be optimized away, and we could just fall into the
	 next EH handler, if we are certain they are nested.  */
      /* Code to throw out to outer context, if we fall off end of the
	 handler.  */
      expand_internal_throw (gen_rtx (LABEL_REF,
				      Pmode,
				      entry->end_label));

      /* leftover try block, opps.  */
      if (entry->finalization == integer_zero_node)
	abort ();

      free (entry);
    }

  return first_label;
}
d682 3
a684 1
void expand_end_catch_block ()
a685 5
  rtx start_protect_label_rtx;
  rtx end_protect_label_rtx;
  tree decls;
  struct ehEntry entry;

d689 35
a723 1
  /* fall to outside the try statement when done executing handler and
d726 1
a726 1
  emit_jump (top_label_entry (&caught_return_label_stack));
d728 1
a728 2
  /* We end the rethrow protection region as soon as we hit a label. */
  end_protect_label_rtx = expand_leftover_cleanups ();
d730 1
a730 28
  /* Code to throw out to outer context, if we get a throw from within
     our catch handler. */
  /* These are saved for the exception table.  */
  push_rtl_perm ();
  entry.exception_handler_label = gen_label_rtx ();
  pop_rtl_from_perm ();
  /* This label is Lhandler in the documentation.  */
  emit_label (entry.exception_handler_label);
  expand_internal_throw (gen_rtx (LABEL_REF,
				  Pmode,
				  top_label_entry (&caught_return_label_stack)));

  /* No associated finalization.  */
  entry.finalization = NULL_TREE;
  entry.context = current_function_decl;

  if (end_protect_label_rtx == NULL_RTX)
    end_protect_label_rtx = entry.exception_handler_label;

  /* Because we are emitted out of line, we have to protect this. */
  /* label for the start of the protection region.  */
  start_protect_label_rtx = pop_label_entry (&false_label_stack);

  /* Cleanup the EH parameter.  */
  decls = getdecls ();
  expand_end_bindings (decls, decls != NULL_TREE, 0);
      
  /* label we emit to jump to if this catch block didn't match. */
d733 1
d735 1
a735 12
  /* Because we are reordered out of line, we have to protect this. */
  entry.start_label = start_protect_label_rtx;
  entry.end_label = end_protect_label_rtx;

  LABEL_PRESERVE_P (entry.start_label) = 1;
  LABEL_PRESERVE_P (entry.end_label) = 1;
  LABEL_PRESERVE_P (entry.exception_handler_label) = 1;

  /* These set up a call to throw the caught exception into the outer
     context.  */
  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));
}
a736 1
/* unwind the stack. */
d741 3
a743 1
#if defined(SPARC_STACK_ALIGN) /* was sparc */
d746 1
a746 1
  rtx return_val_rtx;
d749 2
a750 2
  /* call to  __builtin_return_address () */
  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
d752 1
a752 1
  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);
d757 2
a758 1
  emit_move_insn (return_val_rtx, plus_constant (temp, -8));
d763 1
a763 1
#if defined(ARM_FRAME_RTX)  /* was __arm */
d772 1
a772 1
#if defined(TARGET_88000) /* was m88k */
d795 1
a795 1
#if !defined(TARGET_88000) && !defined(ARM_FRAME_RTX) && !defined(SPARC_STACK_ALIGN)
d798 1
a798 1
  rtx return_val_rtx;
d800 4
a803 2
  /* call to  __builtin_return_address () */
  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
d805 4
a808 5
  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);
#if 0
  /* I would like to do this here, but doesn't seem to work. */
  emit_move_insn (return_val_rtx, inner_throw_label);
  /* So, for now, just pass throw label to stack unwinder. */
d810 1
a810 1
  params = tree_cons (NULL_TREE, make_tree (ptr_type_node,
d820 1
a820 1
/* is called from expand_exception_blocks () to generate the code in a function
d833 1
a833 1
		goto throw;
a834 1
 */
d838 1
d841 3
a843 1
  rtx return_val_rtx;
d846 1
a846 2
  rtx unwind_and_throw;
  rtx goto_unwind_and_throw;
a847 1
  rtx unwind_first;
d849 1
d858 8
a865 4
  t = build_parse_node (CALL_EXPR, get_identifier ("__throw"), params, NULL_TREE);
  start_function (decl_tree_cons (NULL_TREE, get_identifier ("static"),
				  void_list_node),
		  t, NULL_TREE, NULL_TREE, 0);
a873 4
  unwind_and_throw = gen_label_rtx ();
  goto_unwind_and_throw = gen_label_rtx ();
  top_of_loop = gen_label_rtx ();
  unwind_first = gen_label_rtx ();
d875 8
a882 3
  emit_jump (unwind_first);

  emit_label (top_of_loop);
d885 4
a888 3
  return_val_rtx = do_function_call (FirstExceptionMatch,
				     tree_cons (NULL_TREE, saved_pc, NULL_TREE),
				     ptr_type_node);
d892 2
a893 2
  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (return_val_rtx), 0, 0);
d898 12
a909 2
  /* we found it, so jump to it */
  emit_indirect_jump (return_val_rtx);
d911 2
a912 2
  /* code to deal with unwinding and looking for it again */
  emit_label (gotta_rethrow_it);
d914 19
a932 5
  /* call to  __builtin_return_address () */
#if defined(ARM_FRAME_RTX)  /* was __arm */
/* This replaces a 'call' to __builtin_return_address */
  return_val_rtx = gen_reg_rtx (Pmode);
  emit_move_insn (return_val_rtx, gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));
d934 1
a934 1
  params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
d936 1
a936 1
  return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);
d939 3
a941 3
  /* did __builtin_return_address () return a valid address? */
  emit_cmp_insn (return_val_rtx, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (return_val_rtx), 0, 0);
d945 18
a962 16
#if defined(ARM_FRAME_RTX)  /* was __arm */
  /* On the ARM, '__builtin_return_address',  must have 4
     subtracted from it. */
  emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-4)));

  /* If we are generating code for an ARM2/ARM3 machine or for an ARM6 in 26 bit
     mode, the condition codes must be masked out of the return value, or else
     they will confuse BuiltinReturnAddress.  This does not apply to ARM6 and
     later processors when running in 32 bit mode. */
  if (!TARGET_6)
    emit_insn (gen_rtx (SET, Pmode, return_val_rtx, gen_rtx (AND, Pmode, return_val_rtx, GEN_INT (0x03fffffc))));
#else
#if !defined(SPARC_STACK_ALIGN) /* was sparc */
  /* On the SPARC, __builtin_return_address is already -8, no need to
     subtract any more from it. */
  return_val_rtx = plus_constant (return_val_rtx, -1);
d964 2
d967 1
d969 2
a970 3
  /* yes it did */
  t = build_modify_expr (saved_pc, NOP_EXPR, make_tree (ptr_type_node, return_val_rtx));
  expand_expr (t, const0_rtx, VOIDmode, 0);
d972 15
a986 2
  do_unwind (gen_rtx (LABEL_REF, Pmode, top_of_loop));
  emit_jump (top_of_loop);
d994 3
a996 2
    rtx ret_val, return_val_rtx;
    emit_label (unwind_first);
d1002 23
a1024 4
#ifdef NORMAL_RETURN_ADDR_OFFSET
  return_val_rtx = plus_constant (ret_val, -NORMAL_RETURN_ADDR_OFFSET);
    if (return_val_rtx != ret_val)
      emit_move_insn (ret_val, return_val_rtx);
d1027 1
a1027 1
    /* Fall into epilogue to unwind prologue. */
d1030 1
a1030 1
  expand_end_bindings (getdecls(), 1, 0);
d1035 1
d1042 1
a1042 1
  start_protect ();
d1045 1
a1045 1
void
d1060 1
d1070 1
d1080 1
d1088 1
a1088 1
  start_protect ();
d1092 2
a1093 1
  end_protect (second_try);
d1098 3
d1109 2
a1110 2
	  exp = saved_throw_value;
	  exp = tree_cons (NULL_TREE,
d1112 3
a1114 3
			   tree_cons (NULL_TREE,
				      saved_throw_type,
				      tree_cons (NULL_TREE, exp, NULL_TREE)));
d1128 1
d1132 1
a1132 1
  end_protect (expr);
d1138 1
d1142 6
a1147 2
  static rtx funcend;
  rtx insns;
d1149 14
a1162 1
  start_sequence ();
d1164 4
a1167 3
  funcend = gen_label_rtx ();
  emit_jump (funcend);
  /* expand_null_return (); */
d1169 7
a1175 1
  start_sequence ();
d1177 2
a1178 3
  /* Add all the catch clauses here.  */
  emit_insns (catch_clauses);
  catch_clauses = NULL_RTX;
d1180 2
a1181 1
  expand_leftover_cleanups ();
d1183 2
a1184 10
  insns = get_insns ();
  end_sequence ();
  
  /* Do this after we expand leftover cleanups, so that the end_protect
     that expand_end_eh_spec does will match the right start_protect,
     and make sure it comes out before the terminate protected region.  */
  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))
    {
      expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));
      push_to_sequence (insns);
a1185 1
      /* Now expand any new ones.  */
d1188 1
a1188 2
      insns = get_insns ();
      end_sequence ();
d1190 10
d1201 5
a1205 3
  if (insns)
    {
      struct ehEntry entry;
d1207 1
a1207 24
      /* These are saved for the exception table.  */
      push_rtl_perm ();
      entry.start_label = gen_label_rtx ();
      entry.end_label = gen_label_rtx ();
      entry.exception_handler_label = gen_label_rtx ();
      entry.finalization = TerminateFunctionCall;
      entry.context = current_function_decl;
      assemble_external (TREE_OPERAND (Terminate, 0));
      pop_rtl_from_perm ();

      LABEL_PRESERVE_P (entry.start_label) = 1;
      LABEL_PRESERVE_P (entry.end_label) = 1;
      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;

      emit_label (entry.start_label);
      emit_insns (insns);

      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));

      emit_label (entry.exception_handler_label);
      expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);
      emit_label (entry.end_label);
      emit_barrier ();
    }
d1209 14
a1222 14
  {
    /* Mark the end of the stack unwinder.  */
    rtx unwind_insns;
    start_sequence ();
    end_eh_unwinder (funcend);
    expand_leftover_cleanups ();
    unwind_insns = get_insns ();
    end_sequence ();
    if (unwind_insns)
      {
	insns = unwind_insns;
	emit_insns (insns);
      }
  }
d1224 1
a1224 1
  emit_label (funcend);
d1226 1
a1226 5
  /* Only if we had previous insns do we want to emit the jump around
     them.  If there weren't any, then insns will remain NULL_RTX.  */
  if (insns)
    insns = get_insns ();
  end_sequence ();
d1228 1
a1228 1
  emit_insns (insns);
d1231 8
d1240 5
a1244 1
/* call this to expand a throw statement.  This follows the following
d1253 1
d1259 2
a1264 6
  /* This is the label that represents where in the code we were, when
     we got an exception.  This needs to be updated when we rethrow an
     exception, so that the matching routine knows to search out.  */
  label = gen_label_rtx ();
  emit_label (label);

d1268 1
a1268 1
      tree e;
d1271 1
a1271 1
      /* First, decay it. */
d1274 14
d1295 2
d1299 1
a1299 1
			   build_tree_list (NULL_TREE, exp),
d1305 18
a1322 1
	  throw_type = build_eh_type (build_indirect_ref (exp, NULL_PTR));
d1325 31
a1355 4
      e = build_modify_expr (saved_throw_type, NOP_EXPR, throw_type);
      expand_expr (e, const0_rtx, VOIDmode, 0);
      e = build_modify_expr (saved_throw_value, NOP_EXPR, exp);
      e = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (e), e);
d1360 1
a1360 3
      /* rethrow current exception */
      /* This part is easy, as we don't have to do anything else.  */
    }
d1362 20
a1381 2
  expand_internal_throw (gen_rtx (LABEL_REF, Pmode, label));
}
d1383 2
a1384 6
void
end_protect_partials () {
  while (protect_list)
    {
      end_protect (TREE_VALUE (protect_list));
      protect_list = TREE_CHAIN (protect_list);
a1385 1
}
d1387 9
a1395 7
int
might_have_exceptions_p ()
{
  if (eh_table_output_queue.head)
    return 1;
  return 0;
}
d1397 2
a1398 38
/* Output the exception table.
 Return the number of handlers.  */
void
emit_exception_table ()
{
  int count = 0;
  extern FILE *asm_out_file;
  struct ehEntry *entry;
  tree eh_node_decl;

  if (! doing_eh (0))
    return;

  exception_section ();

  /* Beginning marker for table. */
  assemble_align (GET_MODE_ALIGNMENT (Pmode));
  assemble_label ("__EXCEPTION_TABLE__");
  output_exception_table_entry (asm_out_file,
				const0_rtx, const0_rtx, const0_rtx);

 while (entry = dequeue_eh_entry (&eh_table_output_queue))
   {
     tree context = entry->context;

     if (context && ! TREE_ASM_WRITTEN (context))
       continue;

     count++;
     output_exception_table_entry (asm_out_file,
				   entry->start_label, entry->end_label,
				   entry->exception_handler_label);
  }

  /* Ending marker for table. */
  assemble_label ("__EXCEPTION_END__");
  output_exception_table_entry (asm_out_file,
				constm1_rtx, constm1_rtx, constm1_rtx);
d1401 1
a1401 8
void
register_exception_table ()
{
  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, "__register_exceptions"), 0,
		     VOIDmode, 1,
		     gen_rtx (SYMBOL_REF, Pmode, "__EXCEPTION_TABLE__"),
		     Pmode);
}
a1402 1
/* Build a throw expression.  */
d1409 2
a1415 55
}

start_eh_unwinder ()
{
  start_protect ();
}

end_eh_unwinder (end)
     rtx end;
{
  tree expr;
  rtx return_val_rtx, ret_val, label;

  if (! doing_eh (0))
    return;

  expr = make_node (RTL_EXPR);
  TREE_TYPE (expr) = void_type_node;
  RTL_EXPR_RTL (expr) = const0_rtx;
  TREE_SIDE_EFFECTS (expr) = 1;
  start_sequence_for_rtl_expr (expr);

  ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,
					0, hard_frame_pointer_rtx);
  return_val_rtx = copy_to_reg (ret_val);
#ifdef NORMAL_RETURN_ADDR_OFFSET
  return_val_rtx = plus_constant (return_val_rtx, NORMAL_RETURN_ADDR_OFFSET-1);
#else
  return_val_rtx = plus_constant (return_val_rtx, -1);
#endif
  emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);
  
#ifdef JUMP_TO_THROW
  emit_move_insn (ret_val, gen_rtx (SYMBOL_REF, Pmode, "__throw"));
#else
  label = gen_label_rtx ();
  emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, label));
#endif

#ifdef NORMAL_RETURN_ADDR_OFFSET
  return_val_rtx = plus_constant (ret_val, -NORMAL_RETURN_ADDR_OFFSET);
  if (return_val_rtx != ret_val)
    emit_move_insn (ret_val, return_val_rtx);
#endif
  
  emit_jump (end);  

#ifndef JUMP_TO_THROW
  emit_label (label);
  do_function_call (Throw, NULL_TREE, NULL_TREE);
#endif
  
  RTL_EXPR_SEQUENCE (expr) = get_insns ();
  end_sequence ();
  end_protect (expr);
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92-96, 1997 Free Software Foundation, Inc.
d25 2
a27 1
#include <stdio.h>
a33 4
#include "output.h"
#include "except.h"
#include "function.h"
#include "defaults.h"
d35 3
d40 1
a40 1
/* Holds the fndecl for __builtin_return_address.  */
d42 33
d78 1
a78 1
/* Used to cache a call to __builtin_return_address.  */
a80 7
static void easy_expand_asm PROTO((char *));
static void push_eh_cleanup PROTO((void));
static void do_unwind PROTO((rtx));
static rtx do_function_call PROTO((tree, tree, tree));
static tree build_eh_type_type PROTO((tree));
static tree build_eh_type PROTO((tree));
static void expand_end_eh_spec PROTO((tree));
d82 18
d109 1
a109 1
/* This is the startup, and finish stuff per exception table.  */
d118 2
a119 2
    void *start_region;
    void *end_region;
d148 30
d179 3
d184 3
d197 2
a198 2
     (&eh_stack) is called.  Pop_eh_entry () returns the eh_entry it
     created when push_eh_entry () was called.  The eh_entry structure
d203 1
a203 1
     in the finalization variable in the eh_entry structure.  Otherwise
d205 1
a205 1
     is the the end of a try block.  Next, this modified eh_entry node
d234 1
a234 1
     entry in the eh_queue until we get to an entry with a NULL
d239 1
a239 1
     enqueue'ing this new eh_entry to be output at an outer level.
d247 3
d253 3
a255 3
/* Used to cache "terminate", "unexpected", "set_terminate", and
   "set_unexpected" after default_conversion. (lib-except.c)  */
static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch;
d257 2
a258 1
/* Used to cache __find_first_exception_table_match for throw.  */
d261 1
a261 1
/* Used to cache a call to __unwind_function.  */
d264 1
a264 1
/* Holds a ready to emit call to "terminate".  */
d270 37
d317 70
a386 1
static tree saved_pc;
d388 2
a389 2
extern int throw_used;
extern rtx catch_clauses;
d391 12
a402 1
/* ========================================================================= */
d404 9
a412 1
/* Cheesyness to save some typing.  Returns the return value rtx.  */
d415 121
d547 15
d564 12
d580 5
a584 1
		- Setting up all the function call trees.  */
d589 1
a597 3
  /* void vtype () */
  tree vtype = build_function_type (void_type_node, void_list_node);
  
d599 2
a600 1
  tree PFV = build_pointer_type (vtype);
d602 2
a603 2
  /* Arg list for the build_function_type call for set_terminate and
     set_unexpected.  */
d609 3
d620 2
a621 1
  TREE_THIS_VOLATILE (terminate_fndecl) = 1;
d625 36
a660 22
  catch_match_fndecl
    = builtin_function (flag_rtti
			? "__throw_type_match_rtti"
			: "__throw_type_match",
			build_function_type (ptr_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							tree_cons (NULL_TREE, ptr_type_node,
								   tree_cons (NULL_TREE, ptr_type_node,
									      void_list_node)))),
			NOT_BUILT_IN, NULL_PTR);
  find_first_exception_match_fndecl
    = builtin_function ("__find_first_exception_table_match",
			build_function_type (ptr_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							void_list_node)),
			NOT_BUILT_IN, NULL_PTR);
  unwind_fndecl
    = builtin_function ("__unwind_function",
			build_function_type (void_type_node,
					     tree_cons (NULL_TREE, ptr_type_node,
							void_list_node)),
			NOT_BUILT_IN, NULL_PTR);
d669 1
d676 8
a683 4
  d = build_decl (VAR_DECL, get_identifier ("__eh_pc"), ptr_type_node);
  TREE_PUBLIC (d) = 1;
  DECL_EXTERNAL (d) = 1;
  DECL_ARTIFICIAL (d) = 1;
d685 1
a685 1
  saved_pc = d;
d687 13
a699 3
  /* If we use setjmp/longjmp EH, arrange for all cleanup actions to
     be protected with __terminate.  */
  protect_cleanup_actions_with_terminate = 1;
d702 7
a708 1
/* Retrieve a pointer to the cp_eh_info node for the current exception.  */
d710 9
a718 2
static tree
call_eh_info ()
d720 1
a720 1
  tree fn;
d722 14
a735 6
  fn = get_identifier ("__cp_exception_info");
  if (IDENTIFIER_GLOBAL_VALUE (fn))
    fn = IDENTIFIER_GLOBAL_VALUE (fn);
  else
    {
      tree t, fields[6];
d737 1
a737 40
      /* Declare cp_eh_info * __cp_exception_info (void),
	 as defined in exception.cc. */
      push_obstacks_nochange ();
      end_temporary_allocation ();

      /* struct cp_eh_info.  This must match exception.cc.  Note that this
	 type is not pushed anywhere.  */
      t = make_lang_type (RECORD_TYPE);
      fields[0] = build_lang_field_decl (FIELD_DECL, get_identifier ("value"),
					 ptr_type_node);
      fields[1] = build_lang_field_decl (FIELD_DECL, get_identifier ("type"),
					 ptr_type_node);
      fields[2] = build_lang_field_decl
	(FIELD_DECL, get_identifier ("cleanup"),
	 build_pointer_type (build_function_type
			     (ptr_type_node, tree_cons
			      (NULL_TREE, ptr_type_node, void_list_node))));
      fields[3] = build_lang_field_decl (FIELD_DECL, get_identifier ("caught"),
					 boolean_type_node);
      fields[4] = build_lang_field_decl (FIELD_DECL, get_identifier ("next"),
					 build_pointer_type (t));
      fields[5] = build_lang_field_decl
	(FIELD_DECL, get_identifier ("handlers"), long_integer_type_node);
      /* N.B.: The fourth field LEN is expected to be
	 the number of fields - 1, not the total number of fields.  */
      finish_builtin_type (t, "cp_eh_info", fields, 5, ptr_type_node);
      t = build_pointer_type (t);

      /* And now the function.  */
      fn = build_lang_decl (FUNCTION_DECL, fn,
			    build_function_type (t, void_list_node));
      DECL_EXTERNAL (fn) = 1;
      TREE_PUBLIC (fn) = 1;
      DECL_ARTIFICIAL (fn) = 1;
      pushdecl_top_level (fn);
      make_function_rtl (fn);
      assemble_external (fn);
      pop_obstacks ();
    }
  return build_function_call (fn, NULL_TREE);
d740 3
a742 5
/* Retrieve a pointer to the cp_eh_info node for the current exception
   and save it in the current binding level.  */

static void
push_eh_info ()
d744 2
a745 1
  tree decl, fn = call_eh_info ();
d747 1
a747 8
  /* Remember the pointer to the current exception info; it won't change
     during this catch block.  */
  decl = build_decl (VAR_DECL, get_identifier ("__exception_info"),
		     TREE_TYPE (fn));
  DECL_ARTIFICIAL (decl) = 1;
  DECL_INITIAL (decl) = fn;
  decl = pushdecl (decl);
  cp_finish_decl (decl, fn, NULL_TREE, 0, 0);
d750 2
a751 4
/* Returns a reference to the cp_eh_info node for the current exception.  */

static tree
get_eh_info ()
d753 1
a753 3
  /* Look for the pointer pushed in push_eh_info.  */
  tree t = lookup_name (get_identifier ("__exception_info"), 0);
  return build_indirect_ref (t, NULL_PTR);
a755 1
/* Returns a reference to the current exception object.  */
d757 3
a759 2
static tree
get_eh_value ()
d761 47
a807 2
  return build_component_ref (get_eh_info (), get_identifier ("value"),
			      NULL_TREE, 0);
d810 3
a812 4
/* Returns a reference to the current exception type.  */

static tree
get_eh_type ()
d814 1
a814 3
  return build_component_ref (get_eh_info (), get_identifier ("type"),
			      NULL_TREE, 0);
}
d816 2
a817 2
/* Returns a reference to whether or not the current exception
   has been caught.  */
d819 6
a824 6
static tree
get_eh_caught ()
{
  return build_component_ref (get_eh_info (), get_identifier ("caught"),
			      NULL_TREE, 0);
}
d826 7
a832 2
/* Returns a reference to whether or not the current exception
   has been caught.  */
d834 8
a841 5
static tree
get_eh_handlers ()
{
  return build_component_ref (get_eh_info (), get_identifier ("handlers"),
			      NULL_TREE, 0);
a845 1

d856 1
a856 1
  /* peel back references, so they match.  */
d860 1
a860 1
  /* Peel off cv qualifiers.  */
a874 1

a886 60
/* Build up a call to __cp_pop_exception, to destroy the exception object
   for the current catch block.  HANDLER is either true or false, telling
   the library whether or not it is being called from an exception handler;
   if it is, it avoids destroying the object on rethrow.  */

static tree
do_pop_exception (handler)
     tree handler;
{
  tree fn, cleanup;
  fn = get_identifier ("__cp_pop_exception");
  if (IDENTIFIER_GLOBAL_VALUE (fn))
    fn = IDENTIFIER_GLOBAL_VALUE (fn);
  else
    {
      /* Declare void __cp_pop_exception (void *),
	 as defined in exception.cc. */
      push_obstacks_nochange ();
      end_temporary_allocation ();
      fn = build_lang_decl
	(FUNCTION_DECL, fn,
	 build_function_type (void_type_node, tree_cons
			      (NULL_TREE, ptr_type_node, tree_cons
			       (NULL_TREE, boolean_type_node,
				void_list_node))));
      DECL_EXTERNAL (fn) = 1;
      TREE_PUBLIC (fn) = 1;
      DECL_ARTIFICIAL (fn) = 1;
      pushdecl_top_level (fn);
      make_function_rtl (fn);
      assemble_external (fn);
      pop_obstacks ();
    }

  /* Arrange to do a dynamically scoped cleanup upon exit from this region.  */
  cleanup = lookup_name (get_identifier ("__exception_info"), 0);
  cleanup = build_function_call (fn, expr_tree_cons
				 (NULL_TREE, cleanup, expr_tree_cons
				  (NULL_TREE, handler, NULL_TREE)));
  return cleanup;
}

/* This routine creates the cleanup for the current exception.  */

static void
push_eh_cleanup ()
{
  /* All cleanups must last longer than normal.  */
  int yes = suspend_momentary ();
  expand_decl_cleanup_no_eh (NULL_TREE, do_pop_exception (boolean_false_node));
  resume_momentary (yes);

  expand_expr (build_unary_op (PREINCREMENT_EXPR, get_eh_handlers (), 1),
	       const0_rtx, VOIDmode, EXPAND_NORMAL);

  /* We don't destroy the exception object on rethrow, so we can't use
     the normal cleanup mechanism for it.  */
  expand_eh_region_start ();
}

a891 1

d897 1
a900 15
  if (processing_template_decl)
    {
      if (declspecs)
	{
	  decl = grokdeclarator (declarator, declspecs, CATCHPARM,
				 1, NULL_TREE);
	  pushdecl (decl);
	  decl = build_min_nt (DECL_STMT, copy_to_permanent (declarator),
			       copy_to_permanent (declspecs),
			       NULL_TREE);
	  add_tree (decl);
	}
      return;
    }

d904 1
a904 14
  /* If we are not doing setjmp/longjmp EH, because we are reordered
     out of line, we arrange to rethrow in the outer context so as to
     skip through the terminate region we are nested in, should we
     encounter an exception in the catch handler.  We also need to do
     this because we are not physically within the try block, if any,
     that contains this catch block.

     Matches the end in expand_end_catch_block.  */
  if (! exceptions_via_longjmp)
    expand_eh_region_start ();

  /* Create a binding level for the eh_info and the exception object
     cleanup.  */
  pushlevel (0);
d908 6
a913 5
  push_label_entry (&false_label_stack, false_label_rtx, NULL_TREE);

  emit_line_note (input_filename, lineno);

  push_eh_info ();
a916 8
      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);

      if (decl == NULL_TREE)
	error ("invalid catch parameter");
    }

  if (decl)
    {
d921 8
a928 3
      /* Make sure we mark the catch param as used, otherwise we'll get
	 a warning about an unused ((anonymous)).  */
      TREE_USED (decl) = 1;
d930 1
a930 1
      /* Figure out the type that the initializer is.  */
d936 2
a937 2
      exp = get_eh_value ();
      exp = expr_tree_cons (NULL_TREE,
d939 3
a941 3
		       expr_tree_cons (NULL_TREE,
				  get_eh_type (),
				  expr_tree_cons (NULL_TREE, exp, NULL_TREE)));
d955 1
a955 19
      push_eh_cleanup ();

      /* Create a binding level for the parm.  */
      pushlevel (0);
      expand_start_bindings (0);

      init = convert_from_reference (make_tree (init_type, call_rtx));

      /* If the constructor for the catch parm exits via an exception, we
         must call terminate.  See eh23.C.  */
      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))
	{
	  /* Generate the copy constructor call directly so we can wrap it.
	     See also expand_default_init.  */
	  init = ocp_convert (TREE_TYPE (decl), init,
			      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);
	  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,
			TerminateFunctionCall);
	}
d957 1
a960 1

d965 1
a965 7
      push_eh_cleanup ();

      /* Create a binding level for the parm.  */
      pushlevel (0);
      expand_start_bindings (0);

      /* Fall into the catch all section.  */
d968 2
a969 2
  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);
  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);
d975 35
d1014 6
a1020 3
void
expand_end_catch_block ()
{
d1024 4
a1027 6
  /* Cleanup the EH parameter.  */
  expand_end_bindings (getdecls (), kept_level_p (), 0);
  poplevel (kept_level_p (), 1, 0);
      
  /* Matches push_eh_cleanup.  */
  expand_eh_region_end (do_pop_exception (boolean_true_node));
d1029 2
a1030 3
  /* Cleanup the EH object.  */
  expand_end_bindings (getdecls (), kept_level_p (), 0);
  poplevel (kept_level_p (), 1, 0);
d1032 22
a1053 12
  if (! exceptions_via_longjmp)
    {
      /* If we are not doing setjmp/longjmp EH, we need an extra
	 region around the whole catch block to skip through the
	 terminate region we are nested in.  */

      tree t = make_node (RTL_EXPR);
      TREE_TYPE (t) = void_type_node;
      RTL_EXPR_RTL (t) = const0_rtx;
      TREE_SIDE_EFFECTS (t) = 1;
      do_pending_stack_adjust ();
      start_sequence_for_rtl_expr (t);
d1055 7
a1061 5
      expand_internal_throw (outer_context_label_stack->u.rlabel);

      do_pending_stack_adjust ();
      RTL_EXPR_SEQUENCE (t) = get_insns ();
      end_sequence ();
d1063 3
a1065 8
      /* For the rethrow region.  */
      expand_eh_region_end (t);
    }

  /* Fall to outside the try statement when done executing handler and
     we fall off end of handler.  This is jump Lresume in the
     documentation.  */
  expand_goto (top_label_entry (&caught_return_label_stack));
d1067 3
a1069 1
  expand_leftover_cleanups ();
d1071 3
a1073 3
  /* label we emit to jump to if this catch block didn't match.  */
  /* This the closing } in the `if (eq) {' of the documentation.  */
  emit_label (pop_label_entry (&false_label_stack));
d1076 1
a1076 2
/* unwind the stack.  */

d1081 1
a1081 3
#if defined (SPARC_STACK_ALIGN) /* was sparc */
  /* This doesn't work for the flat model sparc, nor does it need to
     as the default unwinder is only used to unwind non-flat frames.  */
d1084 1
a1084 1
  rtx next_pc;
d1087 2
a1088 2
  /* Call to  __builtin_return_address. */
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
d1090 1
a1090 1
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);
d1095 1
a1095 2
  emit_move_insn (next_pc, plus_constant (temp, -8));
  emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, SImode, 31)));
d1100 1
a1100 1
#if defined (ARM_FRAME_RTX)  /* was __arm */
d1109 1
a1109 1
#if defined (TARGET_88000) /* was m88k */
d1132 1
a1132 1
#if ! defined (TARGET_88000) && ! defined (ARM_FRAME_RTX) && ! defined (SPARC_STACK_ALIGN)
d1135 1
a1135 1
  rtx next_pc;
d1137 4
d1142 3
a1144 8
  /* I would like to do this here, but the move below doesn't seem to work.  */
  /* Call to  __builtin_return_address.  */
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
  fcall = build_function_call (BuiltinReturnAddress, params);
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);

  emit_move_insn (next_pc, inner_throw_label);
  /* So, for now, just pass throw label to stack unwinder.  */
d1146 1
a1146 1
  params = expr_tree_cons (NULL_TREE, make_tree (ptr_type_node,
d1156 1
a1156 1
/* Is called from expand_exception_blocks to generate the code in a function
d1169 1
a1169 1
		goto throw;  */
d1171 1
a1174 1
#ifndef DWARF2_UNWIND_INFO
d1177 1
a1177 3
  rtx handler;
  rtx saved_pcnthrow;
  rtx next_pc;
d1180 2
a1181 1
  rtx after_unwind;
d1183 1
a1184 1
  rtx x;
d1193 4
a1196 8
  t = make_call_declarator (get_identifier ("__throw"), params, NULL_TREE,
			    NULL_TREE);
  start_function (decl_tree_cons (NULL_TREE,
				  get_identifier ("void"),
				  decl_tree_cons (NULL_TREE,
						  get_identifier ("static"),
						  NULL_TREE)),
		  t, NULL_TREE, 0);
d1205 6
d1212 1
a1212 8
  /* These two can be frontend specific.  If wanted, they can go in
     expand_throw.  */
  /* Do we have a valid object we are throwing? */
  t = call_eh_info ();
  emit_cmp_insn (expand_expr (t, NULL_RTX, Pmode, 0),
		 const0_rtx, EQ, NULL_RTX,
		 GET_MODE (DECL_RTL (t)), 0, 0);
  emit_jump_insn (gen_beq (gotta_call_terminate));
d1215 3
a1217 4
  handler = do_function_call (FirstExceptionMatch,
			      expr_tree_cons (NULL_TREE, saved_pc,
					 NULL_TREE),
			      ptr_type_node);
d1221 2
a1222 2
  emit_cmp_insn (handler, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (handler), 0, 0);
d1227 2
a1228 12
  {
    rtx ret_val, x;
    ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,
					  0, hard_frame_pointer_rtx);

    /* Set it up so that we continue at the handler.  */
    emit_move_insn (ret_val, handler);
#ifdef RETURN_ADDR_OFFSET
    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);
    if (x != ret_val)
      emit_move_insn (ret_val, x);
#endif
d1230 2
a1231 2
    expand_null_return ();
  }
d1233 5
a1237 19
  top_of_loop = gen_label_rtx ();
  emit_label (top_of_loop);
  
#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      saved_pcnthrow = gen_reg_rtx (Pmode);
      emit_move_insn (saved_pcnthrow, hard_function_value (ptr_type_node,
							   NULL_TREE));
    }
#endif
      
  /* Call to  __builtin_return_address.  */
#if defined (ARM_FRAME_RTX)  /* was __arm */
  /* This should be moved into arm.h:RETURN_ADDR_RTX */
  /* This replaces a 'call' to __builtin_return_address */
  next_pc = gen_reg_rtx (Pmode);
  emit_move_insn (next_pc,
		  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));
d1239 1
a1239 1
  params = expr_tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);
d1241 1
a1241 1
  next_pc = expand_expr (fcall, NULL_RTX, Pmode, 0);
d1244 3
a1246 3
  /* Did __builtin_return_address return a valid address?  */
  emit_cmp_insn (next_pc, const0_rtx, EQ, NULL_RTX,
		 GET_MODE (next_pc), 0, 0);
d1250 16
a1265 18
  next_pc = eh_outer_context (next_pc);

  /* Yes it did.  */
#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      rtx x;

      x = validize_mem (gen_rtx (MEM, Pmode, saved_pcnthrow));
      emit_move_insn (validize_mem (gen_rtx (MEM, Pmode, x)),
		      next_pc);
#ifdef FUNCTION_OUTGOING_VALUE	
      emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),
		      validize_mem (gen_rtx (MEM, Pmode,
					     plus_constant (saved_pcnthrow,
							    GET_MODE_SIZE (Pmode)))));
      emit_insn (gen_rtx (USE, VOIDmode,
			  FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));
a1266 2
    }
  else
a1267 1
    emit_move_insn (eh_saved_pc_rtx, next_pc);
d1269 3
a1271 2
  after_unwind = gen_label_rtx ();
  do_unwind (gen_rtx (LABEL_REF, Pmode, after_unwind));
d1273 2
a1274 15
  emit_label (after_unwind);

#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
  if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
    {
      t = build_function_type (void_type_node, void_list_node);
      t = make_tree (build_pointer_type (t),
		     hard_function_value (ptr_type_node,
					  NULL_TREE));
      t = build_function_call (t, NULL_TREE);
      expand_expr (t, const0_rtx, VOIDmode, 0);
    }
  else
#endif
    emit_throw ();
d1282 2
a1283 3
    rtx ret_val, x;
    /* code to deal with unwinding and looking for it again */
    emit_label (gotta_rethrow_it);
d1289 4
a1292 23
#ifdef RETURN_ADDR_OFFSET
    x = plus_constant (ret_val, -RETURN_ADDR_OFFSET);
    if (x != ret_val)
      emit_move_insn (ret_val, x);
#endif

#ifdef DONT_ACCESS_GBLS_AFTER_EPILOGUE
    if (DONT_ACCESS_GBLS_AFTER_EPILOGUE)
      {
	rtx x = emit_library_call_value (gen_rtx (SYMBOL_REF, Pmode,
						  "__eh_pcnthrow"),
					 NULL_RTX, 1,
					 Pmode, 0);
	/* This is to get a version of throw that will throw properly.  */
	emit_move_insn (validize_mem (gen_rtx (MEM, Pmode,
					       plus_constant (x, GET_MODE_SIZE (Pmode)))),
			throw_libfunc);
#ifdef FUNCTION_OUTGOING_VALUE	
	emit_move_insn (FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE),
			x);
	emit_insn (gen_rtx (USE, VOIDmode, FUNCTION_OUTGOING_VALUE (ptr_type_node, NULL_TREE)));
#endif
      }
d1295 1
a1295 1
    /* Fall into epilogue to unwind prologue.  */
d1298 1
a1298 1
  expand_end_bindings (getdecls (), 1, 0);
a1302 1
#endif /* DWARF2_UNWIND_INFO */
d1309 1
a1309 1
  expand_eh_region_start ();
d1312 1
a1312 1
static void
a1326 1
  do_pending_stack_adjust ();
a1335 1
  do_pending_stack_adjust ();
a1344 1
  do_pending_stack_adjust ();
d1352 1
a1352 1
  expand_eh_region_start ();
d1356 1
a1356 2

  expand_eh_region_end (second_try);
a1360 3

  push_eh_info ();

d1369 2
a1370 2
	  exp = get_eh_value ();
	  exp = expr_tree_cons (NULL_TREE,
d1372 3
a1374 3
			   expr_tree_cons (NULL_TREE,
				      get_eh_type (),
				      expr_tree_cons (NULL_TREE, exp, NULL_TREE)));
a1387 1
  do_pending_stack_adjust ();
d1391 1
a1391 1
  expand_eh_region_end (expr);
a1396 1

d1400 2
a1401 6
  do_pending_stack_adjust ();
  push_to_sequence (catch_clauses);
  expand_leftover_cleanups ();
  do_pending_stack_adjust ();
  catch_clauses = get_insns ();
  end_sequence ();
d1403 1
a1403 14
  /* Do this after we expand leftover cleanups, so that the
     expand_eh_region_end that expand_end_eh_spec does will match the
     right expand_eh_region_start, and make sure it comes out before
     the terminate protected region.  */
  if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))
    {
     expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));
     do_pending_stack_adjust ();
     push_to_sequence (catch_clauses);
     expand_leftover_cleanups ();
     do_pending_stack_adjust ();
     catch_clauses = get_insns ();
     end_sequence ();
    }
d1405 3
a1407 4
  if (catch_clauses)
    {
      rtx funcend = gen_label_rtx ();
      emit_jump (funcend);
d1409 1
a1409 7
      /* We cannot protect n regions this way if we must flow into the
	 EH region through the top of the region, as we have to with
	 the setjmp/longjmp approach.  */
      if (exceptions_via_longjmp == 0)
	{
	  /* Is this necessary?  */
	  assemble_external (TREE_OPERAND (Terminate, 0));
d1411 3
a1413 2
	  expand_eh_region_start ();
	}
d1415 1
a1415 2
      emit_insns (catch_clauses);
      catch_clauses = NULL_RTX;
d1417 10
a1426 2
      if (exceptions_via_longjmp == 0)
	expand_eh_region_end (TerminateFunctionCall);
d1428 1
d1431 2
a1432 1
      emit_label (funcend);
a1433 1
}
d1435 3
a1437 8
tree
start_anon_func ()
{
  static int counter = 0;
  int old_interface_unknown = interface_unknown;
  char name[32];
  tree params;
  tree t;
d1439 24
a1462 2
  push_cp_function_context (NULL_TREE);
  push_to_top_level ();
d1464 14
a1477 2
  /* No need to mangle this.  */
  push_lang_context (lang_name_c);
d1479 1
a1479 1
  interface_unknown = 1;
d1481 5
a1485 14
  params = void_list_node;
  /* tcf stands for throw clean function.  */
  sprintf (name, "__tcf_%d", counter++);
  t = make_call_declarator (get_identifier (name), params, NULL_TREE,
			    NULL_TREE);
  start_function (decl_tree_cons (NULL_TREE, get_identifier ("static"),
				  void_list_node),
		  t, NULL_TREE, 0);
  store_parm_decls ();
  pushlevel (0);
  clear_last_expr ();
  push_momentary ();
  expand_start_bindings (0);
  emit_line_note (input_filename, lineno);
d1487 1
a1487 5
  interface_unknown = old_interface_unknown;

  pop_lang_context ();

  return current_function_decl;
a1489 8
void
end_anon_func ()
{
  expand_end_bindings (getdecls (), 1, 0);
  poplevel (1, 0, 0);
  pop_momentary ();

  finish_function (lineno, 0, 0);
d1491 1
a1491 5
  pop_from_top_level ();
  pop_cp_function_context (NULL_TREE);
}

/* Expand a throw statement.  This follows the following
a1499 1

a1504 2
  tree fn;
  static tree cleanup_type;
d1509 6
d1518 1
a1518 1
      tree cleanup = NULL_TREE, e;
d1521 1
a1521 1
      /* First, decay it.  */
a1523 14
      /* cleanup_type is void (*)(void *, int),
	 the internal type of a destructor. */
      if (cleanup_type == NULL_TREE)
	{
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  cleanup_type = build_pointer_type
	    (build_function_type
	     (void_type_node, tree_cons
	      (NULL_TREE, ptr_type_node, tree_cons
	       (NULL_TREE, integer_type_node, void_list_node))));
	  pop_obstacks ();
	}

a1530 2
	  tree object;

d1533 1
a1533 1
			   build_expr_list (NULL_TREE, exp),
d1539 1
a1539 12
	  object = build_indirect_ref (exp, NULL_PTR);
	  throw_type = build_eh_type (object);

	  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))
	    {
	      cleanup = lookup_fnfields (TYPE_BINFO (TREE_TYPE (object)),
					 dtor_identifier, 0);
	      cleanup = TREE_VALUE (cleanup);
	      mark_addressable (cleanup);
	      /* Pretend it's a normal function.  */
	      cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);
	    }
d1542 4
a1545 37
      if (cleanup == NULL_TREE)
	{
	  cleanup = build_int_2 (0, 0);
	  TREE_TYPE (cleanup) = cleanup_type;
	}

      fn = get_identifier ("__cp_push_exception");
      if (IDENTIFIER_GLOBAL_VALUE (fn))
	fn = IDENTIFIER_GLOBAL_VALUE (fn);
      else
	{
	  /* Declare __cp_push_exception (void*, void*, void (*)(void*, int)),
	     as defined in exception.cc.  */
	  tree tmp;
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  tmp = tree_cons
	    (NULL_TREE, ptr_type_node, tree_cons
	     (NULL_TREE, ptr_type_node, tree_cons
	      (NULL_TREE, cleanup_type, void_list_node)));
	  fn = build_lang_decl (FUNCTION_DECL, fn,
				build_function_type (void_type_node, tmp));
	  DECL_EXTERNAL (fn) = 1;
	  TREE_PUBLIC (fn) = 1;
	  DECL_ARTIFICIAL (fn) = 1;
	  pushdecl_top_level (fn);
	  make_function_rtl (fn);
	  assemble_external (fn);
	  pop_obstacks ();
	}

      /* The throw expression is a full-expression.  */
      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);
      e = expr_tree_cons (NULL_TREE, exp, expr_tree_cons
			  (NULL_TREE, throw_type, expr_tree_cons
			   (NULL_TREE, cleanup, NULL_TREE)));
      e = build_function_call (fn, e);
d1550 3
a1552 1
      /* rethrow current exception; note that it's no longer caught.  */
d1554 2
a1555 20
      tree fn = get_identifier ("__uncatch_exception");
      if (IDENTIFIER_GLOBAL_VALUE (fn))
	fn = IDENTIFIER_GLOBAL_VALUE (fn);
      else
	{
	  /* Declare void __uncatch_exception (void)
	     as defined in exception.cc. */
	  push_obstacks_nochange ();
	  end_temporary_allocation ();
	  fn = build_lang_decl (FUNCTION_DECL, fn,
				build_function_type (void_type_node,
						     void_list_node));
	  DECL_EXTERNAL (fn) = 1;
	  TREE_PUBLIC (fn) = 1;
	  DECL_ARTIFICIAL (fn) = 1;
	  pushdecl_top_level (fn);
	  make_function_rtl (fn);
	  assemble_external (fn);
	  pop_obstacks ();
	}
d1557 6
a1562 2
      exp = build_function_call (fn, NULL_TREE);
      expand_expr (exp, const0_rtx, VOIDmode, EXPAND_NORMAL);
d1564 19
d1584 29
a1612 9
  if (exceptions_via_longjmp)
    emit_throw ();
  else
    {
      /* This is the label that represents where in the code we were, when
	 we got an exception.  This needs to be updated when we rethrow an
	 exception, so that the matching routine knows to search out.  */
      label = gen_label_rtx ();
      emit_label (label);
d1614 7
a1620 2
      expand_internal_throw (label);
    }
a1623 1

a1629 2
      if (processing_template_decl)
	return build_min (THROW_EXPR, void_type_node, e);
d1635 55
@


1.1.1.3
log
@FSF gcc 2.8.1
@
text
@d2 1
a2 1
   Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.
d180 3
d285 1
a285 1
  Terminate = terminate_fndecl;
d293 2
d482 2
a483 1
do_pop_exception ()
d498 3
a500 1
			      (NULL_TREE, ptr_type_node, void_list_node)));
d513 2
a514 1
				 (NULL_TREE, cleanup, NULL_TREE));
d523 4
a526 1
  int yes;
d531 3
a533 4
  yes = suspend_momentary ();
  /* All cleanups must last longer than normal.  */
  expand_decl_cleanup (NULL_TREE, do_pop_exception ());
  resume_momentary (yes);
a615 7

      /* Since pointers are passed by value, initialize a reference to
	 pointer catch parm with the address of the value slot.  */
      if (TREE_CODE (init_type) == REFERENCE_TYPE
	  && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)
	exp = build_unary_op (ADDR_EXPR, exp, 1);

a645 4
	  int yes = suspend_momentary ();
	  tree term = build_function_call (Terminate, NULL_TREE);
	  resume_momentary (yes);

d650 2
a651 1
	  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init, term);
d693 3
d991 1
d1068 1
d1174 3
d1184 1
a1184 1
	expand_eh_region_end (build_function_call (Terminate, NULL_TREE));
a1312 1
	      mark_used (cleanup);
@

