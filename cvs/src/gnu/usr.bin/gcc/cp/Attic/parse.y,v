head	1.4;
access;
symbols
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	FSF_2_8_1:1.1.1.3
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	99.05.26.16.28.23;	author espie;	state dead;
branches;
next	1.3;

1.3
date	98.03.08.18.31.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	98.03.03.21.35.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.06.18;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.06.18;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.26.19;	author niklas;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	98.03.08.18.10.22;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@So long, and thanks for all the bugs.
@
text
@/* YACC parser for C++ syntax.
   Copyright (C) 1988, 89, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
   Hacked by Michael Tiemann (tiemann@@cygnus.com)

This file is part of GNU CC.

GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */


/* This grammar is based on the GNU CC grammar.  */

/* Note: Bison automatically applies a default action of "$$ = $1" for
   all derivations; this is applied before the explicit action, if one
   is given.  Keep this in mind when reading the actions.  */

%{
/* Cause the `yydebug' variable to be defined.  */
#define YYDEBUG 1

#include "config.h"

#include <stdio.h>
#include <errno.h>

#include "tree.h"
#include "input.h"
#include "flags.h"
#include "lex.h"
#include "cp-tree.h"
#include "output.h"
#include "except.h"

/* Since parsers are distinct for each language, put the language string
   definition here.  (fnf) */
char *language_string = "GNU C++";

extern tree void_list_node;
extern struct obstack permanent_obstack;

#ifndef errno
extern int errno;
#endif

extern int end_of_file;
extern int current_class_depth;
extern tree last_tree;

/* FSF LOCAL dje prefix attributes */
extern tree strip_attrs		PROTO((tree));
/* END FSF LOCAL */

/* Like YYERROR but do call yyerror.  */
#define YYERROR1 { yyerror ("syntax error"); YYERROR; }

#define OP0(NODE) (TREE_OPERAND (NODE, 0))
#define OP1(NODE) (TREE_OPERAND (NODE, 1))

/* Contains the statement keyword (if/while/do) to include in an
   error message if the user supplies an empty conditional expression.  */
static char *cond_stmt_keyword;

static tree empty_parms PROTO((void));

/* Nonzero if we have an `extern "C"' acting as an extern specifier.  */
int have_extern_spec;
int used_extern_spec;

/* Cons up an empty parameter list.  */
#ifdef __GNUC__
__inline
#endif
static tree
empty_parms ()
{
  tree parms;

  if (strict_prototype
      || current_class_type != NULL)
    parms = void_list_node;
  else
    parms = NULL_TREE;
  return parms;
}
%}

%start program

%union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; }

/* All identifiers that are not reserved words
   and are not declared typedefs in the current block */
%token IDENTIFIER

/* All identifiers that are declared typedefs in the current block.
   In some contexts, they are treated just like IDENTIFIER,
   but they can also serve as typespecs in declarations.  */
%token TYPENAME
%token SELFNAME

/* A template function.  */
%token PFUNCNAME

/* Reserved words that specify storage class.
   yylval contains an IDENTIFIER_NODE which indicates which one.  */
%token SCSPEC

/* Reserved words that specify type.
   yylval contains an IDENTIFIER_NODE which indicates which one.  */
%token TYPESPEC

/* Reserved words that qualify type: "const" or "volatile".
   yylval contains an IDENTIFIER_NODE which indicates which one.  */
%token CV_QUALIFIER

/* Character or numeric constants.
   yylval is the node for the constant.  */
%token CONSTANT

/* String constants in raw form.
   yylval is a STRING_CST node.  */
%token STRING

/* "...", used for functions with variable arglists.  */
%token ELLIPSIS

/* the reserved words */
/* SCO include files test "ASM", so use something else.  */
%token SIZEOF ENUM /* STRUCT UNION */ IF ELSE WHILE DO FOR SWITCH CASE DEFAULT
%token BREAK CONTINUE RETURN GOTO ASM_KEYWORD GCC_ASM_KEYWORD TYPEOF ALIGNOF
%token SIGOF
%token ATTRIBUTE EXTENSION LABEL
%token REALPART IMAGPART

/* the reserved words... C++ extensions */
%token <ttype> AGGR
%token <ttype> VISSPEC
%token DELETE NEW THIS OPERATOR CXX_TRUE CXX_FALSE
%token NAMESPACE TYPENAME_KEYWORD USING
%token LEFT_RIGHT TEMPLATE
%token TYPEID DYNAMIC_CAST STATIC_CAST REINTERPRET_CAST CONST_CAST
%token <itype> SCOPE

/* Define the operator tokens and their precedences.
   The value is an integer because, if used, it is the tree code
   to use in the expression made from the operator.  */

%left EMPTY			/* used to resolve s/r with epsilon */

%left error

/* Add precedence rules to solve dangling else s/r conflict */
%nonassoc IF
%nonassoc ELSE

%left IDENTIFIER PFUNCNAME TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD

%left '{' ',' ';'

%nonassoc THROW
%right <code> ':'
%right <code> ASSIGN '='
%right <code> '?'
%left <code> OROR
%left <code> ANDAND
%left <code> '|'
%left <code> '^'
%left <code> '&'
%left <code> MIN_MAX
%left <code> EQCOMPARE
%left <code> ARITHCOMPARE '<' '>'
%left <code> LSHIFT RSHIFT
%left <code> '+' '-'
%left <code> '*' '/' '%'
%left <code> POINTSAT_STAR DOT_STAR
%right <code> UNARY PLUSPLUS MINUSMINUS '~'
%left HYPERUNARY
%left <ttype> PAREN_STAR_PAREN LEFT_RIGHT
%left <code> POINTSAT '.' '(' '['

%right SCOPE			/* C++ extension */
%nonassoc NEW DELETE TRY CATCH

%type <code> unop

%type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist
%type <ttype> PFUNCNAME
%type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME
%type <ttype> expr_no_commas cast_expr unary_expr primary string STRING
%type <ttype> reserved_declspecs boolean.literal
%type <ttype> reserved_typespecquals
%type <ttype> declmods 
%type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier
%type <itype> initdecls notype_initdecls initdcl	/* C++ modification */
%type <ttype> init initlist maybeasm maybe_init defarg defarg1
%type <ttype> asm_operands nonnull_asm_operands asm_operand asm_clobbers
%type <ttype> maybe_attribute attributes attribute attribute_list attrib
%type <ttype> any_word

%type <ttype> compstmt implicitly_scoped_stmt

%type <ttype> declarator notype_declarator after_type_declarator
%type <ttype> direct_notype_declarator direct_after_type_declarator

%type <ttype> opt.component_decl_list component_decl_list
%type <ttype> component_decl component_decl_1 components notype_components
%type <ttype> component_declarator component_declarator0 self_reference
%type <ttype> notype_component_declarator notype_component_declarator0
%type <ttype> after_type_component_declarator after_type_component_declarator0
%type <ttype> enumlist enumerator
%type <ttype> absdcl cv_qualifiers
%type <ttype> direct_abstract_declarator conversion_declarator
%type <ttype> new_declarator direct_new_declarator
%type <ttype> xexpr parmlist parms bad_parm 
%type <ttype> identifiers_or_typenames
%type <ttype> fcast_or_absdcl regcast_or_absdcl
%type <ttype> expr_or_declarator complex_notype_declarator
%type <ttype> notype_unqualified_id unqualified_id qualified_id
%type <ttype> template_id object_template_id notype_template_declarator
%type <ttype> overqualified_id notype_qualified_id any_id
%type <ttype> complex_direct_notype_declarator functional_cast
%type <ttype> complex_parmlist parms_comma

%type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs
%type <ftype> typed_declspecs1 type_specifier_seq nonempty_cv_qualifiers
%type <ftype> structsp typespecqual_reserved parm named_parm full_parm

/* C++ extensions */
%token <ttype> TYPENAME_ELLIPSIS PTYPENAME
%token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL
%token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER
%type <ttype> fn.def1 /* Not really! */ component_constructor_declarator
%type <ttype> fn.def2 return_id fn.defpen constructor_declarator
%type <itype> ctor_initializer_opt
%type <ttype> named_class_head named_class_head_sans_basetype
%type <ttype> named_complex_class_head_sans_basetype
%type <ttype> unnamed_class_head
%type <ttype> class_head base_class_list
%type <ttype> base_class_access_list
%type <ttype> base_class maybe_base_class_list base_class.1
%type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers
%type <ttype> operator_name
%type <ttype> object aggr
%type <itype> new delete
/* %type <ttype> primary_no_id */
%type <ttype> nonmomentary_expr maybe_parmlist
%type <itype> initdcl0 notype_initdcl0 member_init_list
%type <ttype> template_header template_parm_list template_parm
%type <ttype> template_type_parm
%type <code>  template_close_bracket
%type <ttype> template_type template_arg_list template_arg
%type <ttype> condition xcond paren_cond_or_null
%type <ttype> type_name nested_name_specifier nested_type ptr_to_mem
%type <ttype> complete_type_name notype_identifier nonnested_type
%type <ttype> complex_type_name nested_name_specifier_1
%type <itype> nomods_initdecls nomods_initdcl0
%type <ttype> new_initializer new_placement
%type <ttype> using_decl .poplevel
%type <ttype> typename_sub typename_sub0 typename_sub1 typename_sub2
/* in order to recognize aggr tags as defining and thus shadowing.  */
%token TYPENAME_DEFN IDENTIFIER_DEFN PTYPENAME_DEFN
%type <ttype> named_class_head_sans_basetype_defn
%type <ttype> identifier_defn IDENTIFIER_DEFN TYPENAME_DEFN PTYPENAME_DEFN

%type <ttype> self_template_type

%token NSNAME
%type <ttype> NSNAME

/* Used in lex.c for parsing pragmas.  */
%token END_OF_LINE

/* lex.c and pt.c depend on this being the last token.  Define
   any new tokens before this one!  */
%token END_OF_SAVED_INPUT

%{
/* List of types and structure classes of the current declaration.  */
static tree current_declspecs = NULL_TREE;
/* List of prefix attributes in effect.
   Prefix attributes are parsed by the reserved_declspecs and declmods
   rules.  They create a list that contains *both* declspecs and attrs.  */
/* ??? It is not clear yet that all cases where an attribute can now appear in
   a declspec list have been updated.  */
static tree prefix_attributes = NULL_TREE;

/* When defining an aggregate, this is the most recent one being defined.  */
static tree current_aggr;

/* Tell yyparse how to print a token's value, if yydebug is set.  */

#define YYPRINT(FILE,YYCHAR,YYLVAL) yyprint(FILE,YYCHAR,YYLVAL)
extern void yyprint			PROTO((FILE *, int, YYSTYPE));
extern tree combine_strings		PROTO((tree));
%}

%%
program:
	  /* empty */
	| extdefs
		{
		  /* In case there were missing closebraces,
		     get us back to the global binding level.  */
		  while (! global_bindings_p ())
		    poplevel (0, 0, 0);
		  finish_file ();
		}
	;

/* the reason for the strange actions in this rule
 is so that notype_initdecls when reached via datadef
 can find a valid list of type and sc specs in $0.  */

extdefs:
		{ $<ttype>$ = NULL_TREE; }
	  lang_extdef
		{ $<ttype>$ = NULL_TREE; }
	| extdefs lang_extdef
		{ $<ttype>$ = NULL_TREE; }
	;

extdefs_opt:
	  extdefs
	| /* empty */
	;

.hush_warning:
		{ have_extern_spec = 1;
		  used_extern_spec = 0;
		  $<ttype>$ = NULL_TREE; }
	;
.warning_ok:
		{ have_extern_spec = 0; }
	;

extension:
	EXTENSION
		{ $<itype>$ = pedantic;
		  pedantic = 0; }
	;

asm_keyword:
	  ASM_KEYWORD
	| GCC_ASM_KEYWORD
	;

lang_extdef:
		{ if (pending_lang_change) do_pending_lang_change(); }
	  extdef
		{ if (! toplevel_bindings_p () && ! pseudo_global_level_p())
		  pop_everything (); }
	;

extdef:
	  fndef eat_saved_input
		{ if (pending_inlines) do_pending_inlines (); }
	| datadef
		{ if (pending_inlines) do_pending_inlines (); }
	| template_def
		{ if (pending_inlines) do_pending_inlines (); }
	| asm_keyword '(' string ')' ';'
		{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3);
		  assemble_asm ($3); }
	| extern_lang_string '{' extdefs_opt '}'
		{ pop_lang_context (); }
	| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input
		{ if (pending_inlines) do_pending_inlines ();
		  pop_lang_context (); }
	| extern_lang_string .hush_warning datadef .warning_ok
		{ if (pending_inlines) do_pending_inlines ();
		  pop_lang_context (); }
	| NAMESPACE identifier '{'
		{ push_namespace ($2); }
	  extdefs_opt '}'
		{ pop_namespace (); }
	| NAMESPACE '{'
		{ push_namespace (NULL_TREE); }
	  extdefs_opt '}'
		{ pop_namespace (); }
	| NAMESPACE identifier '=' any_id ';'
		{ do_namespace_alias ($2, $4); }
	| using_decl ';'
		{ do_toplevel_using_decl ($1); }
	| USING NAMESPACE any_id ';'
		{
		  if (TREE_CODE ($3) == IDENTIFIER_NODE)
		    $3 = lastiddecl;
		  do_using_directive ($3);
		}
	| extension extdef
		{ pedantic = $<itype>1; }
	;

using_decl:
	  USING qualified_id
		{ $$ = $2; }
	| USING global_scope qualified_id
		{ $$ = $3; }
	| USING global_scope unqualified_id
		{ $$ = $3; }
	;

any_id:
	  unqualified_id
	| qualified_id
	| global_scope qualified_id
		{ $$ = $2; }
	| global_scope unqualified_id
		{ $$ = $2; }
	;

extern_lang_string:
	EXTERN_LANG_STRING
		{ push_lang_context ($1); }
	| extern_lang_string EXTERN_LANG_STRING
		{ if (current_lang_name != $2)
		    cp_error ("use of linkage spec `%D' is different from previous spec `%D'", $2, current_lang_name);
		  pop_lang_context (); push_lang_context ($2); }
	;

template_header:
	  TEMPLATE '<'
		{ begin_template_parm_list (); }
	  template_parm_list '>'
		{ $$ = end_template_parm_list ($4); }
	| TEMPLATE '<' '>'
                { begin_specialization(); 
		  $$ = NULL_TREE; }
	;

template_parm_list:
	  template_parm
		{ $$ = process_template_parm (NULL_TREE, $1); }
	| template_parm_list ',' template_parm
		{ $$ = process_template_parm ($1, $3); }
	;

template_type_parm:
	  aggr
		{ 
		  $$ = build_tree_list ($1, NULL_TREE);
		 ttpa:
		  if (TREE_PURPOSE ($$) == signature_type_node)
		    sorry ("signature as template type parameter");
		  else if (TREE_PURPOSE ($$) != class_type_node)
		    {
		      pedwarn ("template type parameters must use the keyword `class'");
		      TREE_PURPOSE ($$) = class_type_node;
		    }
		}
	| aggr identifier
		{ $$ = build_tree_list ($1, $2); goto ttpa; }
	| TYPENAME_KEYWORD
		{ $$ = build_tree_list (class_type_node, NULL_TREE); }
	| TYPENAME_KEYWORD identifier
		{ $$ = build_tree_list (class_type_node, $2); }
	;

template_parm:
	/* The following rules introduce a new reduce/reduce
	   conflict on the ',' and '>' input tokens: they are valid
	   prefixes for a `structsp', which means they could match a
	   nameless parameter.  See 14.6, paragraph 3.
	   By putting them before the `parm' rule, we get
	   their match before considering them nameless parameter
	   declarations.  */
	  template_type_parm
		{ $$ = build_tree_list (NULL_TREE, $1); }
	| template_type_parm '=' type_id
		{ $$ = build_tree_list (groktypename ($3.t), $1); }
	| parm
		{ $$ = build_tree_list (NULL_TREE, $1.t); }
	| parm '=' expr_no_commas  %prec ARITHCOMPARE
		{ $$ = build_tree_list ($3, $1.t); }
	;

template_def:
	  template_header
	  extdef
                { 
                  if ($1) 
                    end_template_decl (); 
		  else
		    end_specialization ();
		}
	| template_header
	  error  %prec EMPTY
		{ 
                  if ($1) 
                    end_template_decl ();
		  else
		    end_specialization (); 
                }
	;

datadef:
	  nomods_initdecls ';'
		{}
	| declmods notype_initdecls ';'
		{}
	| typed_declspecs initdecls ';'
		{
		  note_list_got_semicolon ($1.t);
		}
        | declmods ';'
		{ pedwarn ("empty declaration"); }
	| explicit_instantiation ';'
	| typed_declspecs ';'
		{
		  tree t, attrs;
		  split_specs_attrs ($1.t, &t, &attrs);
		  shadow_tag (t);
		  note_list_got_semicolon ($1.t);
		}
	| error ';'
	| error '}'
	| ';'
	;

ctor_initializer_opt:
	  nodecls
		{ $$ = 0; }
	| base_init
		{ $$ = 1; }
	;

maybe_return_init:
	  /* empty */
	| return_init
	| return_init ';'
	;

eat_saved_input:
	  /* empty */
	| END_OF_SAVED_INPUT
	;

fndef:
	  fn.def1 maybe_return_init ctor_initializer_opt compstmt_or_error
		{ finish_function (lineno, (int)$3, 0); }
	| fn.def1 maybe_return_init function_try_block
		{ }
	| fn.def1 maybe_return_init error
		{ }
	;

constructor_declarator:
	  nested_name_specifier SELFNAME '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	  parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }
	| nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $4, $5);
		}
	| global_scope nested_name_specifier SELFNAME '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	 parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }
	| global_scope nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $5, $6);
		}
	| nested_name_specifier self_template_type '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	  parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }
	| nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $4, $5);
		}
	| global_scope nested_name_specifier self_template_type '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	 parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }
	| global_scope nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $5, $6);
		}
	;

fn.def1:
	  typed_declspecs declarator
		{ tree specs, attrs;
		  split_specs_attrs ($1.t, &specs, &attrs);
		  if (! start_function (specs, $2, attrs, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	| declmods notype_declarator
		{ tree specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  if (! start_function (specs, $2, attrs, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	| notype_declarator
		{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	| declmods constructor_declarator
		{ tree specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  if (! start_function (specs, $2, attrs, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	| constructor_declarator
		{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	;

component_constructor_declarator:
	  SELFNAME '(' parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, $3, $5, $6); }
	| SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }
	| self_template_type '(' parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, $3, $5, $6); }
	| self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }
	;

/* more C++ complexity.  See component_decl for a comment on the
   reduce/reduce conflict introduced by these rules.  */
fn.def2:
	  declmods component_constructor_declarator
		{ tree specs = strip_attrs ($1);
		  $$ = start_method (specs, $2);
		 rest_of_mdef:
		  if (! $$)
		    YYERROR1;
		  if (yychar == YYEMPTY)
		    yychar = YYLEX;
		  reinit_parse_for_method (yychar, $$); }
	| component_constructor_declarator
		{ $$ = start_method (NULL_TREE, $1); goto rest_of_mdef; }
	| typed_declspecs declarator
		{ tree specs = strip_attrs ($1.t);
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| declmods notype_declarator
		{ tree specs = strip_attrs ($1);
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| notype_declarator
		{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }
	| declmods constructor_declarator
		{ tree specs = strip_attrs ($1);
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| constructor_declarator
		{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }
        | template_header fn.def2 
                { 
                  if ($1)
                    end_template_decl (); 
		  else
		    end_specialization ();

		  if ($2 && DECL_TEMPLATE_INFO ($2)
		      && !DECL_TEMPLATE_SPECIALIZATION ($2))
		    {
		      $$ = DECL_TI_TEMPLATE ($2); 
		      check_member_template ($$);
		    }
		  else if ($2)
		    $$ = $2;
		  else 
		    {
		      cp_error("invalid member template declaration");
		      $$ = NULL_TREE;
		    }
		}
	;

return_id:
	  RETURN IDENTIFIER
		{
		  if (! current_function_parms_stored)
		    store_parm_decls ();
		  $$ = $2;
		}
	;

return_init:
	  return_id maybe_init
		{ store_return_init ($<ttype>$, $2); }
	| return_id '(' nonnull_exprlist ')'
		{ store_return_init ($<ttype>$, $3); }
	| return_id LEFT_RIGHT
		{ store_return_init ($<ttype>$, NULL_TREE); }
	;

base_init:
	  ':' .set_base_init member_init_list
		{
		  if ($3 == 0)
		    error ("no base initializers given following ':'");
		  setup_vtbl_ptr ();
		  /* Always keep the BLOCK node associated with the outermost
		     pair of curly braces of a function.  These are needed
		     for correct operation of dwarfout.c.  */
		  keep_next_level ();
		}
	;

.set_base_init:
	  /* empty */
		{
		  if (! current_function_parms_stored)
		    store_parm_decls ();

		  if (DECL_CONSTRUCTOR_P (current_function_decl))
		    {
		      /* Make a contour for the initializer list.  */
		      pushlevel (0);
		      clear_last_expr ();
		      expand_start_bindings (0);
		    }
		  else if (current_class_type == NULL_TREE)
		    error ("base initializers not allowed for non-member functions");
		  else if (! DECL_CONSTRUCTOR_P (current_function_decl))
		    error ("only constructors take base initializers");
		}
	;

member_init_list:
	  /* empty */
		{ $$ = 0; }
	| member_init
		{ $$ = 1; }
	| member_init_list ',' member_init
	| member_init_list error
	;

member_init:
	  '(' nonnull_exprlist ')'
		{
		  if (current_class_name)
		    pedwarn ("anachronistic old style base class initializer");
		  expand_member_init (current_class_ref, NULL_TREE, $2);
		}
	| LEFT_RIGHT
		{
		  if (current_class_name)
		    pedwarn ("anachronistic old style base class initializer");
		  expand_member_init (current_class_ref, NULL_TREE, void_type_node);
		}
	| notype_identifier '(' nonnull_exprlist ')'
		{ expand_member_init (current_class_ref, $1, $3); }
	| notype_identifier LEFT_RIGHT
		{ expand_member_init (current_class_ref, $1, void_type_node); }
	| nonnested_type '(' nonnull_exprlist ')'
		{ expand_member_init (current_class_ref, $1, $3); }
	| nonnested_type LEFT_RIGHT
		{ expand_member_init (current_class_ref, $1, void_type_node); }
	| typename_sub '(' nonnull_exprlist ')'
		{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),
				      $3); }
	| typename_sub LEFT_RIGHT
		{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),
				      void_type_node); }
	;

identifier:
	  IDENTIFIER
	| TYPENAME
	| SELFNAME
	| PTYPENAME
	| NSNAME
	;

notype_identifier:
	  IDENTIFIER
	| PTYPENAME 
	| NSNAME  %prec EMPTY
	;

identifier_defn:
	  IDENTIFIER_DEFN
	| TYPENAME_DEFN
	| PTYPENAME_DEFN
	;

explicit_instantiation:
	  TEMPLATE typespec ';'
		{ do_type_instantiation ($2.t, NULL_TREE);
		  yyungetc (';', 1); }
	| TEMPLATE typed_declspecs declarator
		{ tree specs = strip_attrs ($2.t);
		  do_decl_instantiation (specs, $3, NULL_TREE); }
	| TEMPLATE notype_declarator
		{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }
	| TEMPLATE constructor_declarator
		{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }
	| SCSPEC TEMPLATE typespec ';'
		{ do_type_instantiation ($3.t, $1);
		  yyungetc (';', 1); }
	| SCSPEC TEMPLATE typed_declspecs declarator
		{ tree specs = strip_attrs ($3.t);
		  do_decl_instantiation (specs, $4, $1); }
	| SCSPEC TEMPLATE notype_declarator
		{ do_decl_instantiation (NULL_TREE, $3, $1); }
	| SCSPEC TEMPLATE constructor_declarator
		{ do_decl_instantiation (NULL_TREE, $3, $1); }
	;

/* The TYPENAME expansions are to deal with use of a template class name as
  a template within the class itself, where the template decl is hidden by
  a type decl.  Got all that?  */

template_type:
	  PTYPENAME '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| PTYPENAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| TYPENAME  '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| TYPENAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| self_template_type
	;

self_template_type:
	  SELFNAME  '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| SELFNAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	;

template_close_bracket:
	  '>'
	| RSHIFT 
		{
		  /* Handle `Class<Class<Type>>' without space in the `>>' */
		  pedwarn ("`>>' should be `> >' in template class name");
		  yyungetc ('>', 1);
		}
	;

template_arg_list:
	  template_arg
		{ $$ = build_tree_list (NULL_TREE, $$); }
	| template_arg_list ',' template_arg
		{ $$ = chainon ($$, build_tree_list (NULL_TREE, $3)); }
	;

template_arg:
	  type_id
		{ $$ = groktypename ($1.t); }
	| expr_no_commas  %prec ARITHCOMPARE
	;

unop:
	  '-'
		{ $$ = NEGATE_EXPR; }
	| '+'
		{ $$ = CONVERT_EXPR; }
	| PLUSPLUS
		{ $$ = PREINCREMENT_EXPR; }
	| MINUSMINUS
		{ $$ = PREDECREMENT_EXPR; }
	| '!'
		{ $$ = TRUTH_NOT_EXPR; }
	;

expr:
	  nontrivial_exprlist
		{ $$ = build_x_compound_expr ($$); }
	| expr_no_commas
	;

paren_expr_or_null:
	LEFT_RIGHT
		{ error ("ANSI C++ forbids an empty condition for `%s'",
			 cond_stmt_keyword);
		  $$ = integer_zero_node; }
	| '(' expr ')'
		{ $$ = condition_conversion ($2); }
	;

paren_cond_or_null:
	LEFT_RIGHT
		{ error ("ANSI C++ forbids an empty condition for `%s'",
			 cond_stmt_keyword);
		  $$ = integer_zero_node; }
	| '(' condition ')'
		{ $$ = condition_conversion ($2); }
	;

xcond:
	  /* empty */
		{ $$ = NULL_TREE; }
	| condition
		{ $$ = condition_conversion ($$); }
	| error
		{ $$ = NULL_TREE; }
	;

condition:
	  type_specifier_seq declarator maybeasm maybe_attribute '='
		{ {
		  tree d;
		  for (d = getdecls (); d; d = TREE_CHAIN (d))
		    if (TREE_CODE (d) == TYPE_DECL) {
		      tree s = TREE_TYPE (d);
		      if (TREE_CODE (s) == RECORD_TYPE)
			cp_error ("definition of class `%T' in condition", s);
		      else if (TREE_CODE (s) == ENUMERAL_TYPE)
			cp_error ("definition of enum `%T' in condition", s);
		    }
		  }
		  current_declspecs = $1.t;
		  $<itype>5 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $4,
					 /*prefix_attributes*/ NULL_TREE);
		}
	  init
		{ 
		  cp_finish_decl ($<ttype>6, $7, $4, 1, LOOKUP_ONLYCONVERTING);
		  resume_momentary ($<itype>5);
		  $$ = $<ttype>6; 
		  if (TREE_CODE (TREE_TYPE ($$)) == ARRAY_TYPE)
		    cp_error ("definition of array `%#D' in condition", $$); 
		}
	| expr
	;

compstmtend:
	  '}'
	| maybe_label_decls stmts '}'
	| maybe_label_decls stmts error '}'
	| maybe_label_decls error '}'
	;

already_scoped_stmt:
	  '{'
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      COMPOUND_STMT_NO_SCOPE ($<ttype>$) = 1;
		      add_tree ($<ttype>$);
		    }
		}
	  compstmtend
		{ 
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  finish_stmt (); 
		}
	| simple_stmt
	;


nontrivial_exprlist:
	  expr_no_commas ',' expr_no_commas
		{ $$ = expr_tree_cons (NULL_TREE, $$, 
		                  build_expr_list (NULL_TREE, $3)); }
	| expr_no_commas ',' error
		{ $$ = expr_tree_cons (NULL_TREE, $$, 
		                  build_expr_list (NULL_TREE, error_mark_node)); }
	| nontrivial_exprlist ',' expr_no_commas
		{ chainon ($$, build_expr_list (NULL_TREE, $3)); }
	| nontrivial_exprlist ',' error
		{ chainon ($$, build_expr_list (NULL_TREE, error_mark_node)); }
	;

nonnull_exprlist:
	  expr_no_commas
		{ $$ = build_expr_list (NULL_TREE, $$); }
	| nontrivial_exprlist
	;

unary_expr:
	  primary  %prec UNARY
		{ $$ = $1; }
	/* __extension__ turns off -pedantic for following primary.  */
	| extension cast_expr  	  %prec UNARY
		{ $$ = $2;
		  pedantic = $<itype>1; }
	| '*' cast_expr   %prec UNARY
		{ $$ = build_x_indirect_ref ($2, "unary *"); }
	| '&' cast_expr   %prec UNARY
		{ $$ = build_x_unary_op (ADDR_EXPR, $2); }
	| '~' cast_expr
		{ $$ = build_x_unary_op (BIT_NOT_EXPR, $2); }
	| unop cast_expr  %prec UNARY
		{ $$ = build_x_unary_op ($1, $2);
		  if ($1 == NEGATE_EXPR && TREE_CODE ($2) == INTEGER_CST)
		    TREE_NEGATED_INT ($$) = 1;
		  overflow_warning ($$);
		}
	/* Refer to the address of a label as a pointer.  */
	| ANDAND identifier
		{ tree label = lookup_label ($2);
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids `&&'");
		  if (label == NULL_TREE)
		    $$ = null_pointer_node;
		  else
		    {
		      TREE_USED (label) = 1;
		      $$ = build1 (ADDR_EXPR, ptr_type_node, label);
		      TREE_CONSTANT ($$) = 1;
		    }
		}
	| SIZEOF unary_expr  %prec UNARY
		{ $$ = expr_sizeof ($2); }
	| SIZEOF '(' type_id ')'  %prec HYPERUNARY
		{ $$ = c_sizeof (groktypename ($3.t)); }
	| ALIGNOF unary_expr  %prec UNARY
		{ $$ = grok_alignof ($2); }
	| ALIGNOF '(' type_id ')'  %prec HYPERUNARY
		{ $$ = c_alignof (groktypename ($3.t)); 
		  check_for_new_type ("alignof", $3); }

	/* The %prec EMPTY's here are required by the = init initializer
	   syntax extension; see below.  */
	| new new_type_id  %prec EMPTY
		{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1); 
		  check_for_new_type ("new", $2); }
	| new new_type_id new_initializer
		{ $$ = build_new (NULL_TREE, $2.t, $3, $1); 
		  check_for_new_type ("new", $2); }
	| new new_placement new_type_id  %prec EMPTY
		{ $$ = build_new ($2, $3.t, NULL_TREE, $1); 
		  check_for_new_type ("new", $3); }
	| new new_placement new_type_id new_initializer
		{ $$ = build_new ($2, $3.t, $4, $1); 
		  check_for_new_type ("new", $3); }
	| new '(' type_id ')'  %prec EMPTY
		{ $$ = build_new (NULL_TREE, groktypename($3.t),
				  NULL_TREE, $1); 
		  check_for_new_type ("new", $3); }
	| new '(' type_id ')' new_initializer
		{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); 
		  check_for_new_type ("new", $3); }
	| new new_placement '(' type_id ')'  %prec EMPTY
		{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); 
		  check_for_new_type ("new", $4); }
	| new new_placement '(' type_id ')' new_initializer
		{ $$ = build_new ($2, groktypename($4.t), $6, $1); 
		  check_for_new_type ("new", $4); }

	| delete cast_expr  %prec UNARY
		{ $$ = delete_sanity ($2, NULL_TREE, 0, $1); }
	| delete '[' ']' cast_expr  %prec UNARY
		{ $$ = delete_sanity ($4, NULL_TREE, 1, $1);
		  if (yychar == YYEMPTY)
		    yychar = YYLEX; }
	| delete '[' expr ']' cast_expr  %prec UNARY
		{ $$ = delete_sanity ($5, $3, 2, $1);
		  if (yychar == YYEMPTY)
		    yychar = YYLEX; }
	| REALPART cast_expr %prec UNARY
		{ $$ = build_x_unary_op (REALPART_EXPR, $2); }
	| IMAGPART cast_expr %prec UNARY
		{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }
	;

new_placement:
	  '(' nonnull_exprlist ')'
		{ $$ = $2; }
	| '{' nonnull_exprlist '}'
		{
		  $$ = $2; 
		  pedwarn ("old style placement syntax, use () instead");
		}
	;

new_initializer:
	  '(' nonnull_exprlist ')'
		{ $$ = $2; }
	| LEFT_RIGHT
		{ $$ = NULL_TREE; }
	| '(' typespec ')'
		{
		  cp_error ("`%T' is not a valid expression", $2.t);
		  $$ = error_mark_node;
		}
	/* GNU extension so people can use initializer lists.  Note that
	   this alters the meaning of `new int = 1', which was previously
	   syntactically valid but semantically invalid.  */
	| '=' init
		{
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids initialization of new expression with `='");
		  $$ = $2;
		}
	;

/* This is necessary to postpone reduction of `int ((int)(int)(int))'.  */
regcast_or_absdcl:
	  '(' type_id ')'  %prec EMPTY
		{ $2.t = tree_cons (NULL_TREE, $2.t, void_list_node);
		  TREE_PARMLIST ($2.t) = 1;
		  $$ = make_call_declarator (NULL_TREE, $2.t, NULL_TREE, NULL_TREE);
		  check_for_new_type ("cast", $2); }
	| regcast_or_absdcl '(' type_id ')'  %prec EMPTY
		{ $3.t = tree_cons (NULL_TREE, $3.t, void_list_node);
		  TREE_PARMLIST ($3.t) = 1;
		  $$ = make_call_declarator ($$, $3.t, NULL_TREE, NULL_TREE);
		  check_for_new_type ("cast", $3); }
	;

cast_expr:
	  unary_expr
	| regcast_or_absdcl unary_expr  %prec UNARY
		{ $$ = reparse_absdcl_as_casts ($$, $2); }
	| regcast_or_absdcl '{' initlist maybecomma '}'  %prec UNARY
		{ 
		  tree init = build_nt (CONSTRUCTOR, NULL_TREE,
					nreverse ($3)); 
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids constructor-expressions");
		  /* Indicate that this was a GNU C constructor expression.  */
		  TREE_HAS_CONSTRUCTOR (init) = 1;

		  $$ = reparse_absdcl_as_casts ($$, init);
		}
	;

expr_no_commas:
	  cast_expr
	/* Handle general members.  */
	| expr_no_commas POINTSAT_STAR expr_no_commas
		{ $$ = build_x_binary_op (MEMBER_REF, $$, $3); }
	| expr_no_commas DOT_STAR expr_no_commas
		{ $$ = build_m_component_ref ($$, $3); }
	| expr_no_commas '+' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '-' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '*' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '/' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '%' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas LSHIFT expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas RSHIFT expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas ARITHCOMPARE expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '<' expr_no_commas
		{ $$ = build_x_binary_op (LT_EXPR, $$, $3); }
	| expr_no_commas '>' expr_no_commas
		{ $$ = build_x_binary_op (GT_EXPR, $$, $3); }
	| expr_no_commas EQCOMPARE expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas MIN_MAX expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '&' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '|' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas '^' expr_no_commas
		{ $$ = build_x_binary_op ($2, $$, $3); }
	| expr_no_commas ANDAND expr_no_commas
		{ $$ = build_x_binary_op (TRUTH_ANDIF_EXPR, $$, $3); }
	| expr_no_commas OROR expr_no_commas
		{ $$ = build_x_binary_op (TRUTH_ORIF_EXPR, $$, $3); }
	| expr_no_commas '?' xexpr ':' expr_no_commas
		{ $$ = build_x_conditional_expr ($$, $3, $5); }
	| expr_no_commas '=' expr_no_commas
		{ $$ = build_x_modify_expr ($$, NOP_EXPR, $3);
		  if ($$ != error_mark_node)
                    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }
	| expr_no_commas ASSIGN expr_no_commas
		{ $$ = build_x_modify_expr ($$, $2, $3); }
	| THROW
		{ $$ = build_throw (NULL_TREE); }
	| THROW expr_no_commas
		{ $$ = build_throw ($2); }
/* These extensions are not defined.  The second arg to build_m_component_ref
   is old, build_m_component_ref now does an implicit
   build_indirect_ref (x, NULL_PTR) on the second argument.
	| object '&' expr_no_commas  %prec UNARY
		{ $$ = build_m_component_ref ($$, build_x_unary_op (ADDR_EXPR, $3)); }
	| object unop expr_no_commas  %prec UNARY
		{ $$ = build_m_component_ref ($$, build_x_unary_op ($2, $3)); }
	| object '(' type_id ')' expr_no_commas  %prec UNARY
		{ tree type = groktypename ($3.t);
		  $$ = build_m_component_ref ($$, build_c_cast (type, $5)); }
	| object primary_no_id  %prec UNARY
		{ $$ = build_m_component_ref ($$, $2); }
*/
	;

notype_unqualified_id:
	  '~' see_typename identifier
		{ $$ = build_parse_node (BIT_NOT_EXPR, $3); }
        | template_id
	| operator_name
	| IDENTIFIER
	| PTYPENAME
	| NSNAME  %prec EMPTY
	;

template_id:
        PFUNCNAME '<' template_arg_list template_close_bracket 
                { $$ = lookup_template_function ($1, $3); }
        | PFUNCNAME '<' template_close_bracket
                { $$ = lookup_template_function ($1, NULL_TREE); }
        | operator_name '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function 
		    (do_identifier ($1, 1), $3); }
        | operator_name '<' template_close_bracket
                { $$ = lookup_template_function 
		    (do_identifier ($1, 1), NULL_TREE); }
	;

object_template_id:
        TEMPLATE identifier '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($2, $4); }
        | TEMPLATE PFUNCNAME '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function (DECL_NAME ($2), $4); }
        | TEMPLATE operator_name '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function (DECL_NAME ($2), $4); }
        ;

unqualified_id:
	  notype_unqualified_id
	| TYPENAME
	| SELFNAME
	;

expr_or_declarator:
	  notype_unqualified_id
	| '*' expr_or_declarator  %prec UNARY
		{ $$ = build_parse_node (INDIRECT_REF, $2); }
	| '&' expr_or_declarator  %prec UNARY
		{ $$ = build_parse_node (ADDR_EXPR, $2); }
	| '(' expr_or_declarator ')'
		{ $$ = $2; }
	;

notype_template_declarator:
	  IDENTIFIER '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($1, $3); }
	| NSNAME '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($1, $3); }
	;
		
direct_notype_declarator:
	  complex_direct_notype_declarator
	| notype_unqualified_id
	| notype_template_declarator
	| '(' expr_or_declarator ')'
		{ $$ = finish_decl_parsing ($2); }
	;

primary:
	  notype_unqualified_id
		{
		  if (TREE_CODE ($$) == BIT_NOT_EXPR)
		    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));
		  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)
		    $$ = do_identifier ($$, 1);
		}		
	| CONSTANT
	| boolean.literal
	| string
		{
		  if (processing_template_decl)
		    push_obstacks (&permanent_obstack, &permanent_obstack);
		  $$ = combine_strings ($$);
		  if (processing_template_decl)
		    pop_obstacks ();
		}
	| '(' expr ')'
		{ char class;
		  $$ = $2;
		  class = TREE_CODE_CLASS (TREE_CODE ($$));
		  if (class == 'e' || class == '1'
		      || class == '2' || class == '<')
                    /* This inhibits warnings in truthvalue_conversion.  */
		    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }
	| '(' expr_or_declarator ')'
		{ char class;
		  $$ = reparse_decl_as_expr (NULL_TREE, $2);
		  class = TREE_CODE_CLASS (TREE_CODE ($$));
		  if (class == 'e' || class == '1'
		      || class == '2' || class == '<')
                    /* This inhibits warnings in truthvalue_conversion.  */
		    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }
	| '(' error ')'
		{ $$ = error_mark_node; }
	| '('
		{ if (current_function_decl == 0)
		    {
		      error ("braced-group within expression allowed only inside a function");
		      YYERROR;
		    }
		  keep_next_level ();
		  $<ttype>$ = expand_start_stmt_expr (); }
	  compstmt ')'
		{ tree rtl_exp;
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids braced-groups within expressions");
		  rtl_exp = expand_end_stmt_expr ($<ttype>2);
		  /* The statements have side effects, so the group does.  */
		  TREE_SIDE_EFFECTS (rtl_exp) = 1;

		  if (TREE_CODE ($3) == BLOCK)
		    {
		      /* Make a BIND_EXPR for the BLOCK already made.  */
		      $$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),
				  NULL_TREE, rtl_exp, $3);
		      /* Remove the block from the tree at this point.
			 It gets put back at the proper place
			 when the BIND_EXPR is expanded.  */
		      delete_block ($3);
		    }
		  else
		    $$ = $3;
		}
	| primary '(' nonnull_exprlist ')'
                {
                  $$ = build_x_function_call ($1, $3, current_class_ref); 
                  if (TREE_CODE ($$) == CALL_EXPR
                      && TREE_TYPE ($$) != void_type_node)
	            $$ = require_complete_type ($$);
                }
	| primary LEFT_RIGHT
                {
		  $$ = build_x_function_call ($$, NULL_TREE, current_class_ref);
		  if (TREE_CODE ($$) == CALL_EXPR
		      && TREE_TYPE ($$) != void_type_node)
		    $$ = require_complete_type ($$);
                }
	| primary '[' expr ']'
		{ $$ = grok_array_decl ($$, $3); }
	| primary PLUSPLUS
		{ /* If we get an OFFSET_REF, turn it into what it really
		     means (e.g., a COMPONENT_REF).  This way if we've got,
		     say, a reference to a static member that's being operated
		     on, we don't end up trying to find a member operator for
		     the class it's in.  */
		  if (TREE_CODE ($$) == OFFSET_REF)
		    $$ = resolve_offset_ref ($$);
		  $$ = build_x_unary_op (POSTINCREMENT_EXPR, $$); }
	| primary MINUSMINUS
		{ if (TREE_CODE ($$) == OFFSET_REF)
		    $$ = resolve_offset_ref ($$);
		  $$ = build_x_unary_op (POSTDECREMENT_EXPR, $$); }
	/* C++ extensions */
	| THIS
		{ if (current_class_ptr)
		    {
#ifdef WARNING_ABOUT_CCD
		      TREE_USED (current_class_ptr) = 1;
#endif
		      $$ = current_class_ptr;
		    }
		  else if (current_function_decl
			   && DECL_STATIC_FUNCTION_P (current_function_decl))
		    {
		      error ("`this' is unavailable for static member functions");
		      $$ = error_mark_node;
		    }
		  else
		    {
		      if (current_function_decl)
			error ("invalid use of `this' in non-member function");
		      else
			error ("invalid use of `this' at top level");
		      $$ = error_mark_node;
		    }
		}
	| CV_QUALIFIER '(' nonnull_exprlist ')'
		{
		  tree type;
		  tree id = $$;

		  /* This is a C cast in C++'s `functional' notation.  */
		  if ($3 == error_mark_node)
		    {
		      $$ = error_mark_node;
		      break;
		    }
#if 0
		  if ($3 == NULL_TREE)
		    {
		      error ("cannot cast null list to type `%s'",
		             IDENTIFIER_POINTER (TYPE_NAME (id)));
		      $$ = error_mark_node;
		      break;
		    }
#endif
#if 0
		  /* type is not set! (mrs) */
		  if (type == error_mark_node)
		    $$ = error_mark_node;
		  else
#endif
		    {
		      if (id == ridpointers[(int) RID_CONST])
		        type = build_type_variant (integer_type_node, 1, 0);
		      else if (id == ridpointers[(int) RID_VOLATILE])
		        type = build_type_variant (integer_type_node, 0, 1);
#if 0
		      /* should not be able to get here (mrs) */
		      else if (id == ridpointers[(int) RID_FRIEND])
		        {
		          error ("cannot cast expression to `friend' type");
		          $$ = error_mark_node;
		          break;
		        }
#endif
		      else my_friendly_abort (79);
		      $$ = build_c_cast (type, build_compound_expr ($3));
		    }
		}
	| functional_cast
	| DYNAMIC_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("dynamic_cast", $3);
		  $$ = build_dynamic_cast (type, $6); }
	| STATIC_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("static_cast", $3);
		  $$ = build_static_cast (type, $6); }
	| REINTERPRET_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("reinterpret_cast", $3);
		  $$ = build_reinterpret_cast (type, $6); }
	| CONST_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("const_cast", $3);
		  $$ = build_const_cast (type, $6); }
	| TYPEID '(' expr ')'
		{ $$ = build_x_typeid ($3); }
	| TYPEID '(' type_id ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("typeid", $3);
		  $$ = get_typeid (TYPE_MAIN_VARIANT (type)); }
	| global_scope IDENTIFIER
		{ $$ = do_scoped_id ($2, 1); }
	| global_scope operator_name
		{
		  got_scope = NULL_TREE;
		  if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    $$ = do_scoped_id ($2, 1);
		  else
		    $$ = $2;
		}
	| overqualified_id  %prec HYPERUNARY
		{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }
	| overqualified_id '(' nonnull_exprlist ')'
		{ if (processing_template_decl)
		    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, NULL_TREE);
		  else
		    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }
	| overqualified_id LEFT_RIGHT
		{ if (processing_template_decl)
		    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), 
				       NULL_TREE, NULL_TREE);
		  else
		    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }
        | object object_template_id %prec UNARY
                { 
		  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); 
		}
        | object object_template_id '(' nonnull_exprlist ')'
                {
		  $$ = build_method_call ($1, $2, $4, 
					  NULL_TREE, LOOKUP_NORMAL); 
                }
	| object object_template_id LEFT_RIGHT
                {
		  $$ = build_method_call ($1, $2, NULL_TREE,
					  NULL_TREE, LOOKUP_NORMAL); 
                }
	| object unqualified_id  %prec UNARY
		{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }
	| object overqualified_id  %prec UNARY
		{ if (processing_template_decl)
		    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));
		  else
		    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }
	| object unqualified_id '(' nonnull_exprlist ')'
		{
#if 0
		  /* This is a future direction of this code, but because
		     build_x_function_call cannot always undo what is done
		     in build_component_ref entirely yet, we cannot do this.  */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, current_class_ref);
		  if (TREE_CODE ($$) == CALL_EXPR
		      && TREE_TYPE ($$) != void_type_node)
		    $$ = require_complete_type ($$);
#else
		  $$ = build_method_call ($$, $2, $4, NULL_TREE,
					  LOOKUP_NORMAL);
#endif
		}
	| object unqualified_id LEFT_RIGHT
		{
#if 0
		  /* This is a future direction of this code, but because
		     build_x_function_call cannot always undo what is done
		     in build_component_ref entirely yet, we cannot do this.  */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, current_class_ref);
		  if (TREE_CODE ($$) == CALL_EXPR
		      && TREE_TYPE ($$) != void_type_node)
		    $$ = require_complete_type ($$);
#else
		  $$ = build_method_call ($$, $2, NULL_TREE, NULL_TREE,
					  LOOKUP_NORMAL);
#endif
		}
	| object overqualified_id '(' nonnull_exprlist ')'
		{
		  if (IS_SIGNATURE (OP0 ($2)))
		    {
		      warning ("signature name in scope resolution ignored");
		      $$ = build_method_call ($$, OP1 ($2), $4, NULL_TREE,
					      LOOKUP_NORMAL);
		    }
		  else
		    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), $4);
		}
	| object overqualified_id LEFT_RIGHT
		{
		  if (IS_SIGNATURE (OP0 ($2)))
		    {
		      warning ("signature name in scope resolution ignored");
		      $$ = build_method_call ($$, OP1 ($2), NULL_TREE, NULL_TREE,
					      LOOKUP_NORMAL);
		    }
		  else
		    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), NULL_TREE);
		}
	/* p->int::~int() is valid -- 12.4 */
	| object '~' TYPESPEC LEFT_RIGHT
		{
		  if (IDENTIFIER_GLOBAL_VALUE ($3)
		      && (TREE_CODE (TREE_TYPE ($1)) 
			  != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3)))))
		    cp_error ("`%E' is not of type `%T'", $1, $3);
		  $$ = cp_convert (void_type_node, $1);
		}
	| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT
		{
		  if ($2 != $5)
		    cp_error ("destructor specifier `%T::~%T()' must have matching names", $2, $5);
		  if (TREE_CODE (TREE_TYPE ($1))
		      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($2))))
		    cp_error ("`%E' is not of type `%T'", $1, $2);
		  $$ = cp_convert (void_type_node, $1);
		}
	| object error
		{
		  $$ = error_mark_node;
		}
	;

/* Not needed for now.

primary_no_id:
	  '(' expr ')'
		{ $$ = $2; }
	| '(' error ')'
		{ $$ = error_mark_node; }
	| '('
		{ if (current_function_decl == 0)
		    {
		      error ("braced-group within expression allowed only inside a function");
		      YYERROR;
		    }
		  $<ttype>$ = expand_start_stmt_expr (); }
	  compstmt ')'
		{ if (pedantic)
		    pedwarn ("ANSI C++ forbids braced-groups within expressions");
		  $$ = expand_end_stmt_expr ($<ttype>2); }
	| primary_no_id '(' nonnull_exprlist ')'
		{ $$ = build_x_function_call ($$, $3, current_class_ref); }
	| primary_no_id LEFT_RIGHT
		{ $$ = build_x_function_call ($$, NULL_TREE, current_class_ref); }
	| primary_no_id '[' expr ']'
		{ goto do_array; }
	| primary_no_id PLUSPLUS
		{ $$ = build_x_unary_op (POSTINCREMENT_EXPR, $$); }
	| primary_no_id MINUSMINUS
		{ $$ = build_x_unary_op (POSTDECREMENT_EXPR, $$); }
	| SCOPE IDENTIFIER
		{ goto do_scoped_id; }
	| SCOPE operator_name
		{ if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    goto do_scoped_id;
		  goto do_scoped_operator;
		}
	;
*/

new:
	  NEW
		{ $$ = 0; }
	| global_scope NEW
		{ got_scope = NULL_TREE; $$ = 1; }
	;

delete:
	  DELETE
		{ $$ = 0; }
	| global_scope delete
		{ got_scope = NULL_TREE; $$ = 1; }
	;

boolean.literal:
	  CXX_TRUE
		{ $$ = boolean_true_node; }
	| CXX_FALSE
		{ $$ = boolean_false_node; }
	;

/* Produces a STRING_CST with perhaps more STRING_CSTs chained onto it.  */
string:
	  STRING
	| string STRING
		{ $$ = chainon ($$, $2); }
	;

nodecls:
	  /* empty */
		{
		  if (! current_function_parms_stored)
		    store_parm_decls ();
		  setup_vtbl_ptr ();
		  /* Always keep the BLOCK node associated with the outermost
		     pair of curly braces of a function.  These are needed
		     for correct operation of dwarfout.c.  */
		  keep_next_level ();
		}
	;

object:
	  primary '.'
		{ got_object = TREE_TYPE ($$); }
	| primary POINTSAT
		{
		  $$ = build_x_arrow ($$); 
		  got_object = TREE_TYPE ($$);
		}
	;

decl:
	  typespec initdecls ';'
		{
		  resume_momentary ($2);
		  if ($1.t && IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))
		    note_got_semicolon ($1.t);
		}
	| typed_declspecs initdecls ';'
		{
		  resume_momentary ($2);
		  note_list_got_semicolon ($1.t);
		}
	| declmods notype_initdecls ';'
		{ resume_momentary ($2); }
	| typed_declspecs ';'
		{
		  shadow_tag ($1.t);
		  note_list_got_semicolon ($1.t);
		}
	| declmods ';'
		{ warning ("empty declaration"); }
	| extension decl
		{ pedantic = $<itype>1; }
	;

/* Any kind of declarator (thus, all declarators allowed
   after an explicit typespec).  */

declarator:
	  after_type_declarator  %prec EMPTY
	| notype_declarator  %prec EMPTY
	;

/* This is necessary to postpone reduction of `int()()()()'.  */
fcast_or_absdcl:
	  LEFT_RIGHT  %prec EMPTY
		{ $$ = make_call_declarator (NULL_TREE, empty_parms (),
					     NULL_TREE, NULL_TREE); }
	| fcast_or_absdcl LEFT_RIGHT  %prec EMPTY
		{ $$ = make_call_declarator ($$, empty_parms (), NULL_TREE,
					     NULL_TREE); }
	;

/* ANSI type-id (8.1) */
type_id:
	  typed_typespecs absdcl
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers absdcl
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typespec absdcl
		{ $$.t = build_decl_list (get_decl_list ($1.t), $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typed_typespecs  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE);
		  $$.new_type_flag = $1.new_type_flag;  }
	| nonempty_cv_qualifiers  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
	;

/* Declspecs which contain at least one type specifier or typedef name.
   (Just `const' or `volatile' is not enough.)
   A typedef'd name following these is taken as a name to be declared.
   In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */

typed_declspecs:
	  typed_typespecs  %prec EMPTY
	| typed_declspecs1
	;

typed_declspecs1:
	  declmods typespec
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1); 
		  $$.new_type_flag = $2.new_type_flag; }
	| typespec reserved_declspecs  %prec HYPERUNARY
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typespec reserved_typespecquals reserved_declspecs
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); 
		  $$.new_type_flag = $1.new_type_flag; }
	| declmods typespec reserved_declspecs
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); 
		  $$.new_type_flag = $2.new_type_flag; }
	| declmods typespec reserved_typespecquals
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); 
		  $$.new_type_flag = $2.new_type_flag; }
	| declmods typespec reserved_typespecquals reserved_declspecs
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t,
					 chainon ($3, chainon ($4, $1))); 
		  $$.new_type_flag = $2.new_type_flag; }
	;

reserved_declspecs:
	  SCSPEC
		{ if (extra_warnings)
		    warning ("`%s' is not at beginning of declaration",
			     IDENTIFIER_POINTER ($$));
		  $$ = build_decl_list (NULL_TREE, $$); }
	| reserved_declspecs typespecqual_reserved
		{ $$ = decl_tree_cons (NULL_TREE, $2.t, $$); }
	| reserved_declspecs SCSPEC
		{ if (extra_warnings)
		    warning ("`%s' is not at beginning of declaration",
			     IDENTIFIER_POINTER ($2));
		  $$ = decl_tree_cons (NULL_TREE, $2, $$); }
	| reserved_declspecs attributes
		{ $$ = decl_tree_cons ($2, NULL_TREE, $1); }
	| attributes
		{ $$ = decl_tree_cons ($1, NULL_TREE, NULL_TREE); }
	;

/* List of just storage classes and type modifiers.
   A declaration can start with just this, but then it cannot be used
   to redeclare a typedef-name.
   In the result, declspecs have a non-NULL TREE_VALUE, attributes do not.  */

declmods:
	  nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = $1.t; TREE_STATIC ($$) = 1; }
	| SCSPEC
		{ $$ = IDENTIFIER_AS_LIST ($$); }
	| declmods CV_QUALIFIER
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$);
		  TREE_STATIC ($$) = 1; }
	| declmods SCSPEC
		{ if (extra_warnings && TREE_STATIC ($$))
		    warning ("`%s' is not at beginning of declaration",
			     IDENTIFIER_POINTER ($2));
		  $$ = decl_tree_cons (NULL_TREE, $2, $$);
		  TREE_STATIC ($$) = TREE_STATIC ($1); }
	| declmods attributes
		{ $$ = decl_tree_cons ($2, NULL_TREE, $1); }
	| attributes
		{ $$ = decl_tree_cons ($1, NULL_TREE, NULL_TREE); }
	;

/* Used instead of declspecs where storage classes are not allowed
   (that is, for typenames and structure components).

   C++ can takes storage classes for structure components.
   Don't accept a typedef-name if anything but a modifier precedes it.  */

typed_typespecs:
	  typespec  %prec EMPTY
		{ $$.t = get_decl_list ($1.t); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers typespec
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); 
		  $$.new_type_flag = $2.new_type_flag; }
	| typespec reserved_typespecquals
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers typespec reserved_typespecquals
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); 
		  $$.new_type_flag = $1.new_type_flag; }
	;

reserved_typespecquals:
	  typespecqual_reserved
		{ $$ = build_decl_list (NULL_TREE, $1.t); }
	| reserved_typespecquals typespecqual_reserved
		{ $$ = decl_tree_cons (NULL_TREE, $2.t, $1); }
	;

/* A typespec (but not a type qualifier).
   Once we have seen one of these in a declaration,
   if a typedef name appears then it is being redeclared.  */

typespec:
	  structsp
	| TYPESPEC  %prec EMPTY
		{ $$.t = $1; $$.new_type_flag = 0; }
	| complete_type_name
		{ $$.t = $1; $$.new_type_flag = 0; }
	| TYPEOF '(' expr ')'
		{ $$.t = TREE_TYPE ($3);
		  $$.new_type_flag = 0; }
	| TYPEOF '(' type_id ')'
		{ $$.t = groktypename ($3.t);
		  $$.new_type_flag = 0; }
	| SIGOF '(' expr ')'
		{ tree type = TREE_TYPE ($3);

                  $$.new_type_flag = 0;
		  if (IS_AGGR_TYPE (type))
		    {
		      sorry ("sigof type specifier");
		      $$.t = type;
		    }
		  else
		    {
		      error ("`sigof' applied to non-aggregate expression");
		      $$.t = error_mark_node;
		    }
		}
	| SIGOF '(' type_id ')'
		{ tree type = groktypename ($3.t);

                  $$.new_type_flag = 0;
		  if (IS_AGGR_TYPE (type))
		    {
		      sorry ("sigof type specifier");
		      $$.t = type;
		    }
		  else
		    {
		      error("`sigof' applied to non-aggregate type");
		      $$.t = error_mark_node;
		    }
		}
	;

/* A typespec that is a reserved word, or a type qualifier.  */

typespecqual_reserved:
	  TYPESPEC
		{ $$.t = $1; $$.new_type_flag = 0; }
	| CV_QUALIFIER
		{ $$.t = $1; $$.new_type_flag = 0; }
	| structsp
	;

initdecls:
	  initdcl0
	| initdecls ',' initdcl
	;

notype_initdecls:
	  notype_initdcl0
	| notype_initdecls ',' initdcl
	;

nomods_initdecls:
	  nomods_initdcl0
	| nomods_initdecls ',' initdcl
	;

maybeasm:
	  /* empty */
		{ $$ = NULL_TREE; }
	| asm_keyword '(' string ')'
		{ if (TREE_CHAIN ($3)) $3 = combine_strings ($3); $$ = $3; }
	;

initdcl0:
	  declarator maybeasm maybe_attribute '='
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  if (current_declspecs
		      && TREE_CODE (current_declspecs) != TREE_LIST)
		    current_declspecs = get_decl_list (current_declspecs);
		  if (have_extern_spec && !used_extern_spec)
		    {
		      current_declspecs = decl_tree_cons
			(NULL_TREE, get_identifier ("extern"), 
			 current_declspecs);
		      used_extern_spec = 1;
		    }
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
	  init
/* Note how the declaration of the variable is in effect while its init is parsed! */
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| declarator maybeasm maybe_attribute
		{ tree d;
		  split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  if (current_declspecs
		      && TREE_CODE (current_declspecs) != TREE_LIST)
		    current_declspecs = get_decl_list (current_declspecs);
		  if (have_extern_spec && !used_extern_spec)
		    {
		      current_declspecs = decl_tree_cons
			(NULL_TREE, get_identifier ("extern"), 
			 current_declspecs);
		      used_extern_spec = 1;
		    }
		  $$ = suspend_momentary ();
		  d = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
	;

initdcl:
	  declarator maybeasm maybe_attribute '='
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
	  init
/* Note how the declaration of the variable is in effect while its init is parsed! */
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING); }
	| declarator maybeasm maybe_attribute
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes);
		  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }
	;

notype_initdcl0:
	  notype_declarator maybeasm maybe_attribute '='
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
	  init
/* Note how the declaration of the variable is in effect while its init is parsed! */
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| notype_declarator maybeasm maybe_attribute
		{ tree d;
		  split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $$ = suspend_momentary ();
		  d = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
	;

nomods_initdcl0:
	  notype_declarator maybeasm maybe_attribute '='
		{ current_declspecs = NULL_TREE;
		  prefix_attributes = NULL_TREE;
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
	  init
/* Note how the declaration of the variable is in effect while its init is parsed! */
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| notype_declarator maybeasm maybe_attribute
		{ tree d;
		  current_declspecs = NULL_TREE;
		  prefix_attributes = NULL_TREE;
		  $$ = suspend_momentary ();
		  d = start_decl ($1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
	;

/* the * rules are dummies to accept the Apollo extended syntax
   so that the header files compile.  */
maybe_attribute:
	  /* empty */
  		{ $$ = NULL_TREE; }
	| attributes
		{ $$ = $1; }
	;
 
attributes:
      attribute
		{ $$ = $1; }
	| attributes attribute
		{ $$ = chainon ($1, $2); }
	;

attribute:
      ATTRIBUTE '(' '(' attribute_list ')' ')'
		{ $$ = $4; }
	;

attribute_list:
      attrib
		{ $$ = $1; }
	| attribute_list ',' attrib
		{ $$ = chainon ($1, $3); }
	;
 
attrib:
	  /* empty */
		{ $$ = NULL_TREE; }
	| any_word
		{ $$ = build_tree_list ($1, NULL_TREE); }
	| any_word '(' IDENTIFIER ')'
		{ $$ = build_tree_list ($1, build_tree_list (NULL_TREE, $3)); }
	| any_word '(' IDENTIFIER ',' nonnull_exprlist ')'
		{ $$ = build_tree_list ($1, tree_cons (NULL_TREE, $3, $5)); }
	| any_word '(' nonnull_exprlist ')'
		{ $$ = build_tree_list ($1, $3); }
	;

/* This still leaves out most reserved keywords,
   shouldn't we include them?  */

any_word:
	  identifier
	| SCSPEC
	| TYPESPEC
	| CV_QUALIFIER
	;

/* A nonempty list of identifiers, including typenames.  */
identifiers_or_typenames:
	  identifier
		{ $$ = build_tree_list (NULL_TREE, $1); }
	| identifiers_or_typenames ',' identifier
		{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }
	;

maybe_init:
	  /* empty */  %prec EMPTY
		{ $$ = NULL_TREE; }
	| '=' init
		{ $$ = $2; }

/* If we are processing a template, we don't want to expand this
   initializer yet.  */

init:
	  expr_no_commas  %prec '='
	| '{' '}'
		{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, NULL_TREE);
		  TREE_HAS_CONSTRUCTOR ($$) = 1; }
	| '{' initlist '}'
		{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2));
		  TREE_HAS_CONSTRUCTOR ($$) = 1; }
	| '{' initlist ',' '}'
		{ $$ = build_nt (CONSTRUCTOR, NULL_TREE, nreverse ($2));
		  TREE_HAS_CONSTRUCTOR ($$) = 1; }
	| error
		{ $$ = NULL_TREE; }
	;

/* This chain is built in reverse order,
   and put in forward order where initlist is used.  */
initlist:
	  init
		{ $$ = build_tree_list (NULL_TREE, $$); }
	| initlist ',' init
		{ $$ = expr_tree_cons (NULL_TREE, $3, $$); }
	/* These are for labeled elements.  */
	| '[' expr_no_commas ']' init
		{ $$ = build_expr_list ($2, $4); }
	| initlist ',' CASE expr_no_commas ':' init
		{ $$ = expr_tree_cons ($4, $6, $$); }
	| identifier ':' init
		{ $$ = build_expr_list ($$, $3); }
	| initlist ',' identifier ':' init
		{ $$ = expr_tree_cons ($3, $5, $$); }
	;

fn.defpen:
	PRE_PARSED_FUNCTION_DECL
		{ start_function (NULL_TREE, TREE_VALUE ($1),
				  NULL_TREE, 1);
		  reinit_parse_for_function (); }

pending_inline:
	  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error
		{
		  int nested = (hack_decl_function_context
				(current_function_decl) != NULL_TREE);
		  finish_function (lineno, (int)$3, nested);
		  process_next_inline ($1);
		}
	| fn.defpen maybe_return_init function_try_block
		{ process_next_inline ($1); }
	| fn.defpen maybe_return_init error
		{ process_next_inline ($1); }
	;

pending_inlines:
	/* empty */
	| pending_inlines pending_inline eat_saved_input
	;

/* A regurgitated default argument.  The value of DEFARG_MARKER will be
   the TREE_LIST node for the parameter in question.  */
defarg_again:
	DEFARG_MARKER expr_no_commas END_OF_SAVED_INPUT
		{ replace_defarg ($1, $2); }
	| DEFARG_MARKER error END_OF_SAVED_INPUT
		{ replace_defarg ($1, error_mark_node); }

pending_defargs:
	  /* empty */ %prec EMPTY
	| pending_defargs defarg_again
		{ do_pending_defargs (); }
	| pending_defargs error
		{ do_pending_defargs (); }
	;

structsp:
	  ENUM identifier '{'
		{ $<itype>3 = suspend_momentary ();
		  $<ttype>$ = start_enum ($2); }
	  enumlist maybecomma_warn '}'
		{ $$.t = finish_enum ($<ttype>4, $5);
		  $$.new_type_flag = 1;
		  resume_momentary ((int) $<itype>3);
		  check_for_missing_semicolon ($<ttype>4); }
	| ENUM identifier '{' '}'
		{ $$.t = finish_enum (start_enum ($2), NULL_TREE);
		  $$.new_type_flag = 1;
		  check_for_missing_semicolon ($$.t); }
	| ENUM '{'
		{ $<itype>2 = suspend_momentary ();
		  $<ttype>$ = start_enum (make_anon_name ()); }
	  enumlist maybecomma_warn '}'
		{ $$.t = finish_enum ($<ttype>3, $4);
		  resume_momentary ((int) $<itype>1);
		  check_for_missing_semicolon ($<ttype>3);
		  $$.new_type_flag = 1; }
	| ENUM '{' '}'
		{ $$.t = finish_enum (start_enum (make_anon_name()), NULL_TREE);
		  $$.new_type_flag = 1;
		  check_for_missing_semicolon ($$.t); }
	| ENUM identifier
		{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); 
		  $$.new_type_flag = 0; }
	| ENUM complex_type_name
		{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); 
		  $$.new_type_flag = 0; }
	| TYPENAME_KEYWORD typename_sub
		{ $$.t = $2;
		  $$.new_type_flag = 0; }
	/* C++ extensions, merged with C to avoid shift/reduce conflicts */
	| class_head left_curly 
                { reset_specialization(); }
          opt.component_decl_list '}' maybe_attribute
		{
		  int semi;
		  tree id;

		  $<ttype>$ = $1;
#if 0
		  /* Need to rework class nesting in the
		     presence of nested classes, etc.  */
		  shadow_tag (CLASSTYPE_AS_LIST ($1)); */
#endif
		  if (yychar == YYEMPTY)
		    yychar = YYLEX;
		  semi = yychar == ';';
		  /* finish_struct nukes this anyway; if
		     finish_exception does too, then it can go.  */
		  if (semi)
		    note_got_semicolon ($1);

		  if (TREE_CODE ($1) == ENUMERAL_TYPE)
		    ;
		  else
		    {
		      $<ttype>$ = finish_struct ($1, $4, $6, semi);
		      if (semi) note_got_semicolon ($<ttype>$);
		    }

		  pop_obstacks ();

		  if (! semi)
		    check_for_missing_semicolon ($1); 
		  if (current_scope () == current_function_decl)
		    do_pending_defargs ();
		}
	  pending_defargs
		{
		  if (pending_inlines 
		      && current_scope () == current_function_decl)
		    do_pending_inlines ();
		}
	  pending_inlines
		{ 
		  $$.t = $<ttype>7;
		  $$.new_type_flag = 1; 
		  if (current_class_type == NULL_TREE)
		    clear_inline_text_obstack (); 
		}
	| class_head  %prec EMPTY
		{
		  $$.t = $1;
		  $$.new_type_flag = 0;
		  /* struct B: public A; is not accepted by the WP grammar.  */
		  if (TYPE_BINFO_BASETYPES ($$.t) && !TYPE_SIZE ($$.t)
		      && ! TYPE_BEING_DEFINED ($$.t))
		    cp_error ("base clause without member specification for `%#T'",
			      $$.t);
		}
	;

maybecomma:
	  /* empty */
	| ','
	;

maybecomma_warn:
	  /* empty */
	| ','
		{ if (pedantic && !in_system_header)
		    pedwarn ("comma at end of enumerator list"); }
	;

aggr:
	  AGGR
	| aggr SCSPEC
		{ error ("storage class specifier `%s' not allowed after struct or class", IDENTIFIER_POINTER ($2)); }
	| aggr TYPESPEC
		{ error ("type specifier `%s' not allowed after struct or class", IDENTIFIER_POINTER ($2)); }
	| aggr CV_QUALIFIER
		{ error ("type qualifier `%s' not allowed after struct or class", IDENTIFIER_POINTER ($2)); }
	| aggr AGGR
		{ error ("no body nor ';' separates two class, struct or union declarations"); }
	;

named_class_head_sans_basetype:
	  aggr identifier
		{ current_aggr = $$; $$ = $2; }
	;

named_class_head_sans_basetype_defn:
	  aggr identifier_defn  %prec EMPTY
		{ current_aggr = $$; $$ = $2; }
	;

named_complex_class_head_sans_basetype:
	  aggr nested_name_specifier identifier
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, $2, $3);
		}
	| aggr global_scope nested_name_specifier identifier
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, $3, $4);
		}
	| aggr global_scope identifier
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, NULL_TREE, $3);
		}
	| aggr template_type
		{ current_aggr = $$; $$ = $2; }
	| aggr nested_name_specifier template_type
		{ current_aggr = $$; $$ = $3; }
	;

do_xref_defn:
	  /* empty */  %prec EMPTY
		{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }
	;

named_class_head:
	  named_class_head_sans_basetype  %prec EMPTY
		{ $$ = xref_tag (current_aggr, $1, NULL_TREE, 1); }
	| named_class_head_sans_basetype_defn do_xref_defn
          maybe_base_class_list  %prec EMPTY
		{ 
		  $$ = $<ttype>2;
		  if ($3)
                    xref_basetypes (current_aggr, $1, $<ttype>2, $3); 
		}
	| named_complex_class_head_sans_basetype maybe_base_class_list
		{ 
		  $$ = TREE_TYPE ($1);
		  if (TREE_INT_CST_LOW (current_aggr) == union_type 
		      && TREE_CODE ($$) != UNION_TYPE)
		    cp_pedwarn ("`union' tag used in declaring `%#T'", $$);
		  else if (TREE_CODE ($$) == UNION_TYPE
			   && TREE_INT_CST_LOW (current_aggr) != union_type)
		    cp_pedwarn ("non-`union' tag used in declaring `%#T'", $$);
		  if ($2)
		    {
		      if (IS_AGGR_TYPE ($$) && CLASSTYPE_USE_TEMPLATE ($$))
		        {
		          if (CLASSTYPE_IMPLICIT_INSTANTIATION ($$)
			      && TYPE_SIZE ($$) == NULL_TREE)
			    {
			      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);
			      if (processing_template_decl)
				push_template_decl (TYPE_MAIN_DECL ($$));
			    }
			  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))
			    cp_error ("specialization after instantiation of `%T'", $$);
			}
		      xref_basetypes (current_aggr, $1, $$, $2); 
		    }
		}
	;

unnamed_class_head:
	  aggr '{'
		{ $$ = xref_tag ($$, make_anon_name (), NULL_TREE, 0);
		  yyungetc ('{', 1); }
	;

class_head:
	  unnamed_class_head
	| named_class_head
	;

maybe_base_class_list:
	  /* empty */  %prec EMPTY
		{ $$ = NULL_TREE; }
	| ':' see_typename  %prec EMPTY
		{ yyungetc(':', 1); $$ = NULL_TREE; }
	| ':' see_typename base_class_list  %prec EMPTY
		{ $$ = $3; }
	;

base_class_list:
	  base_class
	| base_class_list ',' see_typename base_class
		{ $$ = chainon ($$, $4); }
	;

base_class:
	  base_class.1
		{
		  tree type = TREE_TYPE ($1);
		  if (! is_aggr_type (type, 1))
		    $$ = NULL_TREE;
		  else if (current_aggr == signature_type_node
			   && (! type) && (! IS_SIGNATURE (type)))
		    {
		      error ("class name not allowed as base signature");
		      $$ = NULL_TREE;
		    }
		  else if (current_aggr == signature_type_node)
		    {
		      sorry ("signature inheritance, base type `%s' ignored",
			     IDENTIFIER_POINTER ($$));
		      $$ = build_tree_list (access_public_node, type);
		    }
		  else if (type && IS_SIGNATURE (type))
		    {
		      error ("signature name not allowed as base class");
		      $$ = NULL_TREE;
		    }
		  else
		    $$ = build_tree_list (access_default_node, type);
		}
	| base_class_access_list see_typename base_class.1
		{
		  tree type = TREE_TYPE ($3);
		  if (current_aggr == signature_type_node)
		    error ("access and source specifiers not allowed in signature");
		  if (! IS_AGGR_TYPE (type))
		    $$ = NULL_TREE;
		  else if (current_aggr == signature_type_node
			   && (! type) && (! IS_SIGNATURE (type)))
		    {
		      error ("class name not allowed as base signature");
		      $$ = NULL_TREE;
		    }
		  else if (current_aggr == signature_type_node)
		    {
		      sorry ("signature inheritance, base type `%s' ignored",
			     IDENTIFIER_POINTER ($$));
		      $$ = build_tree_list (access_public_node, type);
		    }
		  else if (type && IS_SIGNATURE (type))
		    {
		      error ("signature name not allowed as base class");
		      $$ = NULL_TREE;
		    }
		  else
		    $$ = build_tree_list ($$, type);
		}
	;

base_class.1:
	  typename_sub
		{ $$ = TYPE_MAIN_DECL ($1); }
	| nonnested_type
	| SIGOF '(' expr ')'
		{
		  if (current_aggr == signature_type_node)
		    {
		      if (IS_AGGR_TYPE (TREE_TYPE ($3)))
			{
			  sorry ("`sigof' as base signature specifier");
			  $$ = TREE_TYPE ($3);
			}
		      else
			{
			  error ("`sigof' applied to non-aggregate expression");
			  $$ = error_mark_node;
			}
		    }
		  else
		    {
		      error ("`sigof' in struct or class declaration");
		      $$ = error_mark_node;
		    }
		}
	| SIGOF '(' type_id ')'
		{
		  if (current_aggr == signature_type_node)
		    {
		      if (IS_AGGR_TYPE (groktypename ($3.t)))
			{
			  sorry ("`sigof' as base signature specifier");
			  $$ = groktypename ($3.t);
			}
		      else
			{
			  error ("`sigof' applied to non-aggregate expression");
			  $$ = error_mark_node;
			}
		    }
		  else
		    {
		      error ("`sigof' in struct or class declaration");
		      $$ = error_mark_node;
		    }
		}
	;

base_class_access_list:
	  VISSPEC see_typename
	| SCSPEC see_typename
		{ if ($<ttype>$ != ridpointers[(int)RID_VIRTUAL])
		    sorry ("non-virtual access");
		  $$ = access_default_virtual_node; }
	| base_class_access_list VISSPEC see_typename
		{ int err = 0;
		  if ($2 == access_protected_node)
		    {
		      warning ("`protected' access not implemented");
		      $2 = access_public_node;
		      err++;
		    }
		  else if ($2 == access_public_node)
		    {
		      if ($1 == access_private_node)
			{
			mixed:
			  error ("base class cannot be public and private");
			}
		      else if ($1 == access_default_virtual_node)
			$$ = access_public_virtual_node;
		    }
		  else /* $2 == access_private_node */
		    {
		      if ($1 == access_public_node)
			goto mixed;
		      else if ($1 == access_default_virtual_node)
			$$ = access_private_virtual_node;
		    }
		}
	| base_class_access_list SCSPEC see_typename
		{ if ($2 != ridpointers[(int)RID_VIRTUAL])
		    sorry ("non-virtual access");
		  if ($$ == access_public_node)
		    $$ = access_public_virtual_node;
		  else if ($$ == access_private_node)
		    $$ = access_private_virtual_node; }
	;

left_curly:
	  '{'
		{ tree t = $<ttype>0;
		  push_obstacks_nochange ();
		  end_temporary_allocation ();

		  if (t == error_mark_node
		      || ! IS_AGGR_TYPE (t))
		    {
		      t = $<ttype>0 = make_lang_type (RECORD_TYPE);
		      pushtag (make_anon_name (), t, 0);
		    }
		  if (TYPE_SIZE (t))
		    duplicate_tag_error (t);
                  if (TYPE_SIZE (t) || TYPE_BEING_DEFINED (t))
                    {
                      t = make_lang_type (TREE_CODE (t));
                      pushtag (TYPE_IDENTIFIER ($<ttype>0), t, 0);
                      $<ttype>0 = t;
                    }
		  if (processing_template_decl && TYPE_CONTEXT (t)
		      && ! current_class_type)
		    push_template_decl (TYPE_STUB_DECL (t));
		  pushclass (t, 0);
		  TYPE_BEING_DEFINED (t) = 1;
		  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))
		    {
		      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)
			  && TYPE_SIZE (t) == NULL_TREE)
			{
			  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);
			  if (processing_template_decl)
			    push_template_decl (TYPE_MAIN_DECL (t));
			}
		      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))
			cp_error ("specialization after instantiation of `%T'", t);
		    }
		  /* Reset the interface data, at the earliest possible
		     moment, as it might have been set via a class foo;
		     before.  */
		  /* Don't change signatures.  */
		  if (! IS_SIGNATURE (t))
		    {
		      extern tree pending_vtables;
		      int needs_writing;
		      tree name = TYPE_IDENTIFIER (t);

		      if (! ANON_AGGRNAME_P (name))
			{
			  CLASSTYPE_INTERFACE_ONLY (t) = interface_only;
			  SET_CLASSTYPE_INTERFACE_UNKNOWN_X
			    (t, interface_unknown);
			}

		      /* Record how to set the access of this class's
			 virtual functions.  If write_virtuals == 2 or 3, then
			 inline virtuals are ``extern inline''.  */
		      switch (write_virtuals)
			{
			case 0:
			case 1:
			  needs_writing = 1;
			  break;
			case 2:
			  needs_writing = !! value_member (name, pending_vtables);
			  break;
			case 3:
			  needs_writing = ! CLASSTYPE_INTERFACE_ONLY (t)
			    && CLASSTYPE_INTERFACE_KNOWN (t);
			  break;
			default:
			  needs_writing = 0;
			}
		      CLASSTYPE_VTABLE_NEEDS_WRITING (t) = needs_writing;
		    }
#if 0
		  t = TYPE_IDENTIFIER ($<ttype>0);
		  if (t && IDENTIFIER_TEMPLATE (t))
		    overload_template_name (t, 1);
#endif
		}
	;

self_reference:
	  /* empty */
		{
		    $$ = build_self_reference ();
		}
	;

opt.component_decl_list:
	  self_reference
		{ if ($$) $$ = build_tree_list (access_public_node, $$); }
	| self_reference component_decl_list
		{
		  if (current_aggr == signature_type_node)
		    $$ = build_tree_list (access_public_node, $2);
		  else
		    $$ = build_tree_list (access_default_node, $2);
		  if ($1) $$ = tree_cons (access_public_node, $1, $$);
		}
	| opt.component_decl_list VISSPEC ':' component_decl_list
		{
		  tree visspec = $2;

		  if (current_aggr == signature_type_node)
		    {
		      error ("access specifier not allowed in signature");
		      visspec = access_public_node;
		    }
		  $$ = chainon ($$, build_tree_list (visspec, $4));
		}
	| opt.component_decl_list VISSPEC ':'
		{
		  if (current_aggr == signature_type_node)
		    error ("access specifier not allowed in signature");
		}
	;

/* Note: we no longer warn about the semicolon after a component_decl_list.
   ARM $9.2 says that the semicolon is optional, and therefore allowed.  */
component_decl_list:
	  component_decl
		{ if ($$ == void_type_node) $$ = NULL_TREE; 
		}
	| component_decl_list component_decl
		{ /* In pushdecl, we created a reverse list of names
		     in this binding level.  Make sure that the chain
		     of what we're trying to add isn't the item itself
		     (which can happen with what pushdecl's doing).  */
		  if ($2 != NULL_TREE && $2 != void_type_node)
		    {
		      if (TREE_CHAIN ($2) != $$)
			$$ = chainon ($$, $2);
		      else
			$$ = $2;
		    }
		}
	;

component_decl:
	  component_decl_1 ';'
		{ }
	| component_decl_1 '}'
		{ error ("missing ';' before right brace");
		  yyungetc ('}', 0); }
	/* C++: handle constructors, destructors and inline functions */
	/* note that INLINE is like a TYPESPEC */
	| fn.def2 ':' /* base_init compstmt */
		{ $$ = finish_method ($$); }
	| fn.def2 TRY /* base_init compstmt */
		{ $$ = finish_method ($$); }
	| fn.def2 RETURN /* base_init compstmt */
		{ $$ = finish_method ($$); }
	| fn.def2 '{' /* nodecls compstmt */
		{ $$ = finish_method ($$); }
	| ';'
		{ $$ = NULL_TREE; }
	| extension component_decl
		{ $$ = $2;
		  pedantic = $<itype>1; }
	;

component_decl_1:
	/* Do not add a "typed_declspecs declarator" rule here for
	   speed; we need to call grok_x_components for enums, so the
	   speedup would be insignificant.  */
	  typed_declspecs components
		{ $$ = grok_x_components ($1.t, $2); }
	| declmods notype_components
		{ $$ = grok_x_components ($1, $2); }
	| notype_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
	| constructor_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
	| ':' expr_no_commas
		{ $$ = grokbitfield (NULL_TREE, NULL_TREE, $2); }
	| error
		{ $$ = NULL_TREE; }

	/* These rules introduce a reduce/reduce conflict; in
		typedef int foo, bar;
		class A {
		  foo (bar);
		};
	   should "A::foo" be declared as a function or "A::bar" as a data
	   member? In other words, is "bar" an after_type_declarator or a
	   parmlist? */
	| declmods component_constructor_declarator maybeasm maybe_attribute maybe_init
		{ tree specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  $$ = grokfield ($2, specs, $5, $3,
				  build_tree_list ($4, attrs)); }
	| component_constructor_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
	| using_decl
		{ $$ = do_class_using_decl ($1); }
        | template_header component_decl_1 
                { 
                  if ($1)
		    end_template_decl (); 
                  else
                    end_specialization ();

		  if ($2 && DECL_TEMPLATE_INFO ($2)
		      && !DECL_TEMPLATE_SPECIALIZATION ($2))
		    {
		      $$ = DECL_TI_TEMPLATE ($2); 
		      check_member_template ($$);
		    }
		  else if ($2)
		    $$ = $2;
		  else
		    {
		      cp_error("invalid member template declaration");
		      $$ = NULL_TREE;
		    }
		}

/* The case of exactly one component is handled directly by component_decl.  */
/* ??? Huh? ^^^ */
components:
	  /* empty: possibly anonymous */
		{ $$ = NULL_TREE; }
	| component_declarator0
	| components ',' component_declarator
		{
		  /* In this context, void_type_node encodes
		     friends.  They have been recorded elsewhere.  */
		  if ($$ == void_type_node)
		    $$ = $3;
		  else
		    $$ = chainon ($$, $3);
		}
	;

notype_components:
	  /* empty: possibly anonymous */
		{ $$ = NULL_TREE; }
	| notype_component_declarator0
	| notype_components ',' notype_component_declarator
		{
		  /* In this context, void_type_node encodes
		     friends.  They have been recorded elsewhere.  */
		  if ($$ == void_type_node)
		    $$ = $3;
		  else
		    $$ = chainon ($$, $3);
		}
	;

component_declarator0:
	  after_type_component_declarator0
	| notype_component_declarator0
	;

component_declarator:
	  after_type_component_declarator
	| notype_component_declarator
	;

after_type_component_declarator0:
	  after_type_declarator maybeasm maybe_attribute maybe_init
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| TYPENAME ':' expr_no_commas maybe_attribute
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokbitfield ($$, current_declspecs, $3);
		  cplus_decl_attributes ($$, $4, prefix_attributes); }
	;

notype_component_declarator0:
	  notype_declarator maybeasm maybe_attribute maybe_init
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| constructor_declarator maybeasm maybe_attribute maybe_init
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| IDENTIFIER ':' expr_no_commas maybe_attribute
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokbitfield ($$, current_declspecs, $3);
		  cplus_decl_attributes ($$, $4, prefix_attributes); }
	| ':' expr_no_commas maybe_attribute
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokbitfield (NULL_TREE, current_declspecs, $2);
		  cplus_decl_attributes ($$, $3, prefix_attributes); }
	;

after_type_component_declarator:
	  after_type_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| TYPENAME ':' expr_no_commas maybe_attribute
		{ $$ = grokbitfield ($$, current_declspecs, $3);
		  cplus_decl_attributes ($$, $4, prefix_attributes); }
	;

notype_component_declarator:
	  notype_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| IDENTIFIER ':' expr_no_commas maybe_attribute
		{ $$ = grokbitfield ($$, current_declspecs, $3);
		  cplus_decl_attributes ($$, $4, prefix_attributes); }
	| ':' expr_no_commas maybe_attribute
		{ $$ = grokbitfield (NULL_TREE, current_declspecs, $2);
		  cplus_decl_attributes ($$, $3, prefix_attributes); }
	;

/* We chain the enumerators in reverse order.
   Because of the way enums are built, the order is
   insignificant.  Take advantage of this fact.  */

enumlist:
	  enumerator
	| enumlist ',' enumerator
		{ TREE_CHAIN ($3) = $$; $$ = $3; }
	;

enumerator:
	  identifier
		{ $$ = build_enumerator ($$, NULL_TREE); }
	| identifier '=' expr_no_commas
		{ $$ = build_enumerator ($$, $3); }
	;

/* ANSI new-type-id (5.3.4) */
new_type_id:
	  type_specifier_seq new_declarator
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| type_specifier_seq  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
	/* GNU extension to allow arrays of arbitrary types with
	   non-constant dimension.  */
	| '(' type_id ')' '[' expr ']'
		{
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids array dimensions with parenthesized type in new");
		  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);
		  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);
		  $$.new_type_flag = $2.new_type_flag;
		}
	;

cv_qualifiers:
	  /* empty */  %prec EMPTY
		{ $$ = NULL_TREE; }
	| cv_qualifiers CV_QUALIFIER
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
	;

nonempty_cv_qualifiers:
	  CV_QUALIFIER
		{ $$.t = IDENTIFIER_AS_LIST ($1); 
		  $$.new_type_flag = 0; }
	| nonempty_cv_qualifiers CV_QUALIFIER
		{ $$.t = decl_tree_cons (NULL_TREE, $2, $1.t); 
		  $$.new_type_flag = $1.new_type_flag; }
	;

/* These rules must follow the rules for function declarations
   and component declarations.  That way, longer rules are preferred.  */

suspend_mom:
	  /* empty */
		{ $<itype>$ = suspend_momentary (); } 

/* An expression which will not live on the momentary obstack.  */
nonmomentary_expr:
	  suspend_mom expr
		{ resume_momentary ((int) $<itype>1); $$ = $2; }
	;

/* An expression which will not live on the momentary obstack.  */
maybe_parmlist:
	  suspend_mom '(' nonnull_exprlist ')'
		{ resume_momentary ((int) $<itype>1); $$ = $3; }
	| suspend_mom '(' parmlist ')'
		{ resume_momentary ((int) $<itype>1); $$ = $3; }
	| suspend_mom LEFT_RIGHT
		{ resume_momentary ((int) $<itype>1); $$ = empty_parms (); }
	| suspend_mom '(' error ')'
		{ resume_momentary ((int) $<itype>1); $$ = NULL_TREE; }
	;

/* A declarator that is allowed only after an explicit typespec.  */
/* may all be followed by prec '.' */
after_type_declarator:
	  '*' nonempty_cv_qualifiers after_type_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers after_type_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
	| '*' after_type_declarator  %prec UNARY
		{ $$ = make_pointer_declarator (NULL_TREE, $2); }
	| '&' after_type_declarator  %prec UNARY
		{ $$ = make_reference_declarator (NULL_TREE, $2); }
	| ptr_to_mem cv_qualifiers after_type_declarator
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| direct_after_type_declarator
	;

nonnested_type:
	  type_name  %prec EMPTY
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    {
		      $$ = lookup_name ($1, 1);
		      if (current_class_type
			  && TYPE_BEING_DEFINED (current_class_type)
			  && ! IDENTIFIER_CLASS_VALUE ($1))
			{
			  /* Remember that this name has been used in the class
			     definition, as per [class.scope0] */
			  pushdecl_class_level ($$);
			}
		    }
		  else
		    $$ = $1;
		}
	| global_scope type_name
		{
		  if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    $$ = IDENTIFIER_GLOBAL_VALUE ($2);
		  else
		    $$ = $2;
		  got_scope = NULL_TREE;
		}
	;

complete_type_name:
	  nonnested_type
	| nested_type
	| global_scope nested_type
		{ $$ = $2; }
	;

nested_type:
	  nested_name_specifier type_name  %prec EMPTY
		{ $$ = get_type_decl ($2); }
	;

direct_after_type_declarator:
	  direct_after_type_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $2, $3, $4); }
	| direct_after_type_declarator '[' nonmomentary_expr ']'
		{ $$ = build_parse_node (ARRAY_REF, $$, $3); }
	| direct_after_type_declarator '[' ']'
		{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }
	| '(' after_type_declarator ')'
		{ $$ = $2; }
	| nested_name_specifier type_name  %prec EMPTY
		{ push_nested_class ($1, 3);
		  $$ = build_parse_node (SCOPE_REF, $$, $2);
		  TREE_COMPLEXITY ($$) = current_class_depth; }
	| type_name  %prec EMPTY
	;

/* A declarator allowed whether or not there has been
   an explicit typespec.  These cannot redeclare a typedef-name.  */

notype_declarator:
	  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
	| '*' notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator (NULL_TREE, $2); }
	| '&' notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator (NULL_TREE, $2); }
	| ptr_to_mem cv_qualifiers notype_declarator
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| direct_notype_declarator
	;

complex_notype_declarator:
	  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
	| '*' complex_notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator (NULL_TREE, $2); }
	| '&' complex_notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator (NULL_TREE, $2); }
	| ptr_to_mem cv_qualifiers notype_declarator
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| complex_direct_notype_declarator
	;

complex_direct_notype_declarator:
	  direct_notype_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $2, $3, $4); }
	| '(' complex_notype_declarator ')'
		{ $$ = $2; }
	| direct_notype_declarator '[' nonmomentary_expr ']'
		{ $$ = build_parse_node (ARRAY_REF, $$, $3); }
	| direct_notype_declarator '[' ']'
		{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }
	| notype_qualified_id
		{ if (OP0 ($$) != current_class_type)
		    {
		      push_nested_class (OP0 ($$), 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
        | nested_name_specifier notype_template_declarator
                { got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	;

qualified_id:
	  nested_name_specifier unqualified_id
		{ got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $$, $2); }
        | nested_name_specifier object_template_id
                { got_scope = NULL_TREE;
 		  $$ = build_parse_node (SCOPE_REF, $1, $2); }
	;

notype_qualified_id:
	  nested_name_specifier notype_unqualified_id
		{ got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $$, $2); }
        | nested_name_specifier object_template_id
                { got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $1, $2); }
	;

overqualified_id:
	  notype_qualified_id
	| global_scope notype_qualified_id
		{ $$ = $2; }
	;

functional_cast:
	  typespec '(' nonnull_exprlist ')'
		{ $$ = build_functional_cast ($1.t, $3); }
	| typespec '(' expr_or_declarator ')'
		{ $$ = reparse_decl_as_expr ($1.t, $3); }
	| typespec fcast_or_absdcl  %prec EMPTY
		{ $$ = reparse_absdcl_as_expr ($1.t, $2); }
	;

type_name:
	  TYPENAME
	| SELFNAME
	| template_type  %prec EMPTY
	;

nested_name_specifier:
	  nested_name_specifier_1
	| nested_name_specifier nested_name_specifier_1
		{ $$ = $2; }
	;

/* Why the @@#$%^& do type_name and notype_identifier need to be expanded
   inline here?!?  (jason) */
nested_name_specifier_1:
	  TYPENAME SCOPE
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    {
		      $$ = lastiddecl;
		      /* Remember that this name has been used in the class
			 definition, as per [class.scope0] */
		      if (current_class_type
			  && TYPE_BEING_DEFINED (current_class_type)
			  && ! IDENTIFIER_CLASS_VALUE ($1))
			pushdecl_class_level ($$);
		    }
		  got_scope = $$ = TREE_TYPE ($$);
		}
	| SELFNAME SCOPE
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = TREE_TYPE ($$);
		}
	| NSNAME SCOPE
		{
		  if (TREE_CODE ($$) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$;
		}
	| template_type SCOPE
		{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }
/* 	These break 'const i;'
	| IDENTIFIER SCOPE
		{
		 failed_scope:
		  cp_error ("`%D' is not an aggregate typedef", 
			    lastiddecl ? lastiddecl : $$);
		  $$ = error_mark_node;
		}
	| PTYPENAME SCOPE
		{ goto failed_scope; } */
	;

typename_sub:
	  typename_sub0
	| global_scope typename_sub0
		{ $$ = $2; }
	;

typename_sub0:
	  typename_sub1 identifier
		{
		  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')
		    $$ = make_typename_type ($1, $2);
		  else if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $2);
		  else
		    $$ = $2;
		}
	;

typename_sub1:
	  typename_sub2
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $1);
		}
	| typename_sub1 typename_sub2
		{
		  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')
		    $$ = make_typename_type ($1, $2);
		  else if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $2);
		  else
		    $$ = $2;
		}
	;

typename_sub2:
	  TYPENAME SCOPE
		{
		  if (TREE_CODE ($1) != IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = complete_type (TREE_TYPE ($$));
		}
	| SELFNAME SCOPE
		{
		  if (TREE_CODE ($1) != IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = complete_type (TREE_TYPE ($$));
		}
	| template_type SCOPE
		{ got_scope = $$ = complete_type (TREE_TYPE ($$)); }
	| PTYPENAME SCOPE
	| IDENTIFIER SCOPE
	| NSNAME SCOPE
		{
		  if (TREE_CODE ($$) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$;
		}
	;

complex_type_name:
	  global_scope type_name
		{
		  if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    $$ = IDENTIFIER_GLOBAL_VALUE ($2);
		  else
		    $$ = $2;
		  got_scope = NULL_TREE;
		}
	| nested_type
	| global_scope nested_type
		{ $$ = $2; }
	;

ptr_to_mem:
	  nested_name_specifier '*'
		{ got_scope = NULL_TREE; }
	| global_scope nested_name_specifier '*'
		{ $$ = $2; got_scope = NULL_TREE; }
	;

/* All uses of explicit global scope must go through this nonterminal so
   that got_scope will be set before yylex is called to get the next token.  */
global_scope:
	  SCOPE
		{ got_scope = void_type_node; }
	;

/* ANSI new-declarator (5.3.4) */
new_declarator:
	  '*' cv_qualifiers new_declarator
		{ $$ = make_pointer_declarator ($2, $3); }
	| '*' cv_qualifiers  %prec EMPTY
		{ $$ = make_pointer_declarator ($2, NULL_TREE); }
	| '&' cv_qualifiers new_declarator  %prec EMPTY
		{ $$ = make_reference_declarator ($2, $3); }
	| '&' cv_qualifiers  %prec EMPTY
		{ $$ = make_reference_declarator ($2, NULL_TREE); }
	| ptr_to_mem cv_qualifiers  %prec EMPTY
		{ tree arg = make_pointer_declarator ($2, NULL_TREE);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| ptr_to_mem cv_qualifiers new_declarator
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| direct_new_declarator  %prec EMPTY
	;

/* ANSI direct-new-declarator (5.3.4) */
direct_new_declarator:
	  '[' expr ']'
		{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }
	| direct_new_declarator '[' nonmomentary_expr ']'
		{ $$ = build_parse_node (ARRAY_REF, $$, $3); }
	;

/* ANSI abstract-declarator (8.1) */
absdcl:
	  '*' nonempty_cv_qualifiers absdcl
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '*' absdcl
		{ $$ = make_pointer_declarator (NULL_TREE, $2); }
	| '*' nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = make_pointer_declarator ($2.t, NULL_TREE); }
	| '*'  %prec EMPTY
		{ $$ = make_pointer_declarator (NULL_TREE, NULL_TREE); }
	| '&' nonempty_cv_qualifiers absdcl
		{ $$ = make_reference_declarator ($2.t, $3); }
	| '&' absdcl
		{ $$ = make_reference_declarator (NULL_TREE, $2); }
	| '&' nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = make_reference_declarator ($2.t, NULL_TREE); }
	| '&'  %prec EMPTY
		{ $$ = make_reference_declarator (NULL_TREE, NULL_TREE); }
	| ptr_to_mem cv_qualifiers  %prec EMPTY
		{ tree arg = make_pointer_declarator ($2, NULL_TREE);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| ptr_to_mem cv_qualifiers absdcl
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	| direct_abstract_declarator  %prec EMPTY
	;

/* ANSI direct-abstract-declarator (8.1) */
direct_abstract_declarator:
	  '(' absdcl ')'
		{ $$ = $2; }
	  /* `(typedef)1' is `int'.  */
	| PAREN_STAR_PAREN
	| direct_abstract_declarator '(' parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $3, $5, $6); }
	| direct_abstract_declarator LEFT_RIGHT cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, empty_parms (), $3, $4); }
	| direct_abstract_declarator '[' nonmomentary_expr ']'  %prec '.'
		{ $$ = build_parse_node (ARRAY_REF, $$, $3); }
	| direct_abstract_declarator '[' ']'  %prec '.'
		{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }
	| '(' complex_parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator (NULL_TREE, $2, $4, $5); }
	| regcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'
		{ set_quals_and_spec ($$, $2, $3); }
	| fcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'
		{ set_quals_and_spec ($$, $2, $3); }
	| '[' nonmomentary_expr ']'  %prec '.'
		{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, $2); }
	| '[' ']'  %prec '.'
		{ $$ = build_parse_node (ARRAY_REF, NULL_TREE, NULL_TREE); }
	;

/* For C++, decls and stmts can be intermixed, so we don't need to
   have a special rule that won't start parsing the stmt section
   until we have a stmt that parses without errors.  */

stmts:
	  stmt
	| errstmt
	| stmts stmt
	| stmts errstmt
	;

errstmt:
	  error ';'
	;

/* build the LET_STMT node before parsing its contents,
  so that any LET_STMTs within the context can have their display pointers
  set up to point at this one.  */

.pushlevel:
	  /* empty */
		{ do_pushlevel (); }
	;

.poplevel:
	  /* empty */
		{ $$ = do_poplevel (); }
	;

/* Read zero or more forward-declarations for labels
   that nested functions can jump to.  */
maybe_label_decls:
	  /* empty */
	| label_decls
		{ if (pedantic)
		    pedwarn ("ANSI C++ forbids label declarations"); }
	;

label_decls:
	  label_decl
	| label_decls label_decl
	;

label_decl:
	  LABEL identifiers_or_typenames ';'
		{ tree link;
		  for (link = $2; link; link = TREE_CHAIN (link))
		    {
		      tree label = shadow_label (TREE_VALUE (link));
		      C_DECLARED_LABEL_FLAG (label) = 1;
		      declare_nonlocal_label (label);
		    }
		}
	;

/* This is the body of a function definition.
   It causes syntax errors to ignore to the next openbrace.  */
compstmt_or_error:
	  compstmt
		{}
	| error compstmt
	;

compstmt:
	  '{'
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  .pushlevel compstmtend .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  $$ = $5;
		}
	;

simple_if:
	  IF
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE,
					        NULL_TREE);
		      add_tree ($<ttype>$);
		    }
                  cond_stmt_keyword = "if";
		}
	  .pushlevel paren_cond_or_null
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 0) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 0) = $4;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_start_cond ($4, 0);
		    }
		}
	  implicitly_scoped_stmt
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      $<ttype>$ = last_tree = $<ttype>2;
		    }
		}
	;

implicitly_scoped_stmt:
	  compstmt
		{ finish_stmt (); }
	| .pushlevel
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  simple_stmt .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  $$ = $4;
		}
	;

stmt:
	  compstmt
		{ finish_stmt (); }
	| simple_stmt
	;

simple_stmt:
	  decl
		{ finish_stmt (); }
	| expr ';'
		{
		  tree expr = $1;
		  if (! processing_template_decl)
		    {
		      emit_line_note (input_filename, lineno);
		      /* Do default conversion if safe and possibly important,
		         in case within ({...}).  */
		      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE
		           && lvalue_p (expr))
		          || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)
		        expr = default_conversion (expr);
		    }
		  cplus_expand_expr_stmt (expr);
		  clear_momentary ();
		  finish_stmt (); }
	| simple_if ELSE
		{ if (! processing_template_decl) expand_start_else (); }
	  implicitly_scoped_stmt
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>1, 2) = TREE_CHAIN ($<ttype>1);
		      TREE_CHAIN ($<ttype>1) = NULL_TREE;
		      last_tree = $<ttype>1;
		    }
		  else
		    expand_end_cond ();
		}
	  .poplevel
		{ finish_stmt (); }
	| simple_if  %prec IF
		{ if (! processing_template_decl) expand_end_cond ();
		  do_poplevel ();
		  finish_stmt (); }
	| WHILE
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop (1); 
		    }
		  cond_stmt_keyword = "while";
		}
	  .pushlevel paren_cond_or_null
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 0) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 0) = $4;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_exit_loop_if_false (0, $4);
		    }
		}
	  already_scoped_stmt .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_loop ();
		  finish_stmt ();
		}
	| DO
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop_continue_elsewhere (1);
		    }
		}
	  implicitly_scoped_stmt WHILE
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    {
		      expand_loop_continue_here ();
		      cond_stmt_keyword = "do";
		    }
		}
	  paren_expr_or_null ';'
		{
		  if (processing_template_decl)
		    TREE_OPERAND ($<ttype>2, 1) = $6;
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_exit_loop_if_false (0, $6);
		      expand_end_loop ();
		    }
		  clear_momentary ();
		  finish_stmt ();
		}
	| FOR
		{ if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, 
					        NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
                  else
		    emit_line_note (input_filename, lineno);
		  if (flag_new_for_scope > 0)
		    {
		      /* Conditionalize .pushlevel */
		      pushlevel (0);
		      note_level_for_for ();
		      clear_last_expr ();
		      push_momentary ();
		      expand_start_bindings (0);
		    }
		}
	  '(' for.init.statement
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
			{
			  TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop_continue_elsewhere (1); 
		    }
		}
	  .pushlevel xcond ';'
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 1) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 1) = $7;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      if ($7) expand_exit_loop_if_false (0, $7);
		    }
		}
	  xexpr ')'
		/* Don't let the tree nodes for $10 be discarded
		   by clear_momentary during the parsing of the next stmt.  */
		{
		  if (processing_template_decl)
		    TREE_OPERAND ($<ttype>2, 2) = $10;
		  push_momentary ();
		}
	  already_scoped_stmt .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 3) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_loop_continue_here ();
		      if ($10) cplus_expand_expr_stmt ($10);
		      expand_end_loop ();
		    }
		  pop_momentary ();
		  if (flag_new_for_scope > 0)
		    {
		      do_poplevel ();
		    }
		  finish_stmt (); }
	| SWITCH .pushlevel '(' condition ')'
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (SWITCH_STMT, $4, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      c_expand_start_case ($4);
		    }
		  push_switch ();
		  /* Don't let the tree nodes for $4 be discarded by
		     clear_momentary during the parsing of the next stmt.  */
		  push_momentary ();
		}
	  implicitly_scoped_stmt
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>6, 1) = TREE_CHAIN ($<ttype>6);
		      TREE_CHAIN ($<ttype>6) = NULL_TREE;
		      last_tree = $<ttype>6;
		    }
		  else
		    expand_end_case ($4);
		  pop_momentary ();
		  pop_switch (); 
		}
	  .poplevel
		{ finish_stmt (); }
	| CASE expr_no_commas ':'
		{ do_case ($2, NULL_TREE); }
	  stmt
	| CASE expr_no_commas ELLIPSIS expr_no_commas ':'
		{ do_case ($2, $4); }
	  stmt
	| DEFAULT ':'
		{ do_case (NULL_TREE, NULL_TREE); }
	  stmt
	| BREAK ';'
		{ emit_line_note (input_filename, lineno);
		  if (processing_template_decl)
		    add_tree (build_min_nt (BREAK_STMT));
		  else if ( ! expand_exit_something ())
		    error ("break statement not within loop or switch"); }
	| CONTINUE ';'
		{ emit_line_note (input_filename, lineno);
		  if (processing_template_decl)
		    add_tree (build_min_nt (CONTINUE_STMT));
		  else if (! expand_continue_loop (0))
		    error ("continue statement not within a loop"); }
	| RETURN ';'
		{ emit_line_note (input_filename, lineno);
		  c_expand_return (NULL_TREE); }
	| RETURN expr ';'
		{ emit_line_note (input_filename, lineno);
		  c_expand_return ($2);
		  finish_stmt ();
		}
	| asm_keyword maybe_cv_qualifier '(' string ')' ';'
		{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);
		  emit_line_note (input_filename, lineno);
		  expand_asm ($4);
		  finish_stmt ();
		}
	/* This is the case with just output operands.  */
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'
		{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);
		  emit_line_note (input_filename, lineno);
		  c_expand_asm_operands ($4, $6, NULL_TREE, NULL_TREE,
					 $2 == ridpointers[(int)RID_VOLATILE],
					 input_filename, lineno);
		  finish_stmt ();
		}
	/* This is the case with input operands as well.  */
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':' asm_operands ')' ';'
		{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);
		  emit_line_note (input_filename, lineno);
		  c_expand_asm_operands ($4, $6, $8, NULL_TREE,
					 $2 == ridpointers[(int)RID_VOLATILE],
					 input_filename, lineno);
		  finish_stmt ();
		}
	/* This is the case with clobbered registers as well.  */
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'
	  asm_operands ':' asm_clobbers ')' ';'
		{ if (TREE_CHAIN ($4)) $4 = combine_strings ($4);
		  emit_line_note (input_filename, lineno);
		  c_expand_asm_operands ($4, $6, $8, $10,
					 $2 == ridpointers[(int)RID_VOLATILE],
					 input_filename, lineno);
		  finish_stmt ();
		}
	| GOTO '*' expr ';'
		{
		  if (processing_template_decl)
		    add_tree (build_min_nt (GOTO_STMT, $3));
		  else
		    { emit_line_note (input_filename, lineno);
		      expand_computed_goto ($3); }
		}
	| GOTO identifier ';'
		{
		  if (processing_template_decl)
		    add_tree (build_min_nt (GOTO_STMT, $2));
		  else
		    {
		      tree decl;
		      emit_line_note (input_filename, lineno);
		      decl = lookup_label ($2);
		      TREE_USED (decl) = 1;
		      expand_goto (decl); 
		    }
		}
	| label_colon stmt
		{ finish_stmt (); }
	| label_colon '}'
		{ error ("label must be followed by statement");
		  yyungetc ('}', 0);
		  finish_stmt (); }
	| ';'
		{ finish_stmt (); }
	| try_block
	;

function_try_block:
	  TRY
		{
		  if (! current_function_parms_stored)
		    store_parm_decls ();
		  expand_start_early_try_stmts ();
		}
	  ctor_initializer_opt compstmt
		{ expand_start_all_catch (); }
	  handler_seq
		{
		  int nested = (hack_decl_function_context
				(current_function_decl) != NULL_TREE);
		  expand_end_all_catch ();
		  finish_function (lineno, (int)$3, nested);
		}
	;

try_block:
	  TRY
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (TRY_BLOCK, NULL_TREE,
						NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_start_try_stmts ();
		    }
		}
	  compstmt
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_start_all_catch ();
		}
	  handler_seq
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_all_catch ();
		}
	;

handler_seq:
	  handler
	| handler_seq handler
	;

handler:
	  CATCH
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (HANDLER, NULL_TREE,
						NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  .pushlevel handler_args
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		}	  
	  compstmt
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_catch_block ();
		}	  
	  .poplevel
	;

type_specifier_seq:
	  typed_typespecs  %prec EMPTY
	| nonempty_cv_qualifiers  %prec EMPTY
	;

handler_args:
	  '(' ELLIPSIS ')'
		{ expand_start_catch_block (NULL_TREE, NULL_TREE); }
	/* This doesn't allow reference parameters, the below does.
	| '(' type_specifier_seq absdcl ')'
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
	| '(' type_specifier_seq ')'
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, NULL_TREE); }
	| '(' type_specifier_seq notype_declarator ')'
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
	| '(' typed_typespecs after_type_declarator ')'
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
	This allows reference parameters...  */
	| '(' parm ')'
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block (TREE_PURPOSE ($2.t),
					    TREE_VALUE ($2.t)); }
	;

label_colon:
	  IDENTIFIER ':'
		{ tree label;
		do_label:
		  label = define_label (input_filename, lineno, $1);
		  if (label && ! minimal_parse_mode)
		    expand_label (label);
		}
	| PTYPENAME ':'
		{ goto do_label; }
	| TYPENAME ':'
		{ goto do_label; }
	| SELFNAME ':'
		{ goto do_label; }
	;

for.init.statement:
	  xexpr ';'
		{ if ($1) cplus_expand_expr_stmt ($1); }
	| decl
	| '{' compstmtend
		{ if (pedantic)
		    pedwarn ("ANSI C++ forbids compound statements inside for initializations");
		}
	;

/* Either a type-qualifier or nothing.  First thing in an `asm' statement.  */

maybe_cv_qualifier:
	  /* empty */
		{ emit_line_note (input_filename, lineno);
		  $$ = NULL_TREE; }
	| CV_QUALIFIER
		{ emit_line_note (input_filename, lineno); }
	;

xexpr:
	  /* empty */
		{ $$ = NULL_TREE; }
	| expr
	| error
		{ $$ = NULL_TREE; }
	;

/* These are the operands other than the first string and colon
   in  asm ("addextend %2,%1": "=dm" (x), "0" (y), "g" (*x))  */
asm_operands:
	  /* empty */
		{ $$ = NULL_TREE; }
	| nonnull_asm_operands
	;

nonnull_asm_operands:
	  asm_operand
	| nonnull_asm_operands ',' asm_operand
		{ $$ = chainon ($$, $3); }
	;

asm_operand:
	  STRING '(' expr ')'
		{ $$ = build_tree_list ($$, $3); }
	;

asm_clobbers:
	  STRING
		{ $$ = tree_cons (NULL_TREE, $$, NULL_TREE); }
	| asm_clobbers ',' STRING
		{ $$ = tree_cons (NULL_TREE, $3, $$); }
	;

/* This is what appears inside the parens in a function declarator.
   Its value is represented in the format that grokdeclarator expects.

   In C++, declaring a function with no parameters
   means that that function takes *no* parameters.  */

parmlist:
	  /* empty */
		{
		  $$ = empty_parms();
		}
	| complex_parmlist
	| type_id
		{ $$ = tree_cons (NULL_TREE, $1.t, void_list_node);
		  TREE_PARMLIST ($$) = 1; 
		  check_for_new_type ("inside parameter list", $1); }
	;

/* This nonterminal does not include the common sequence '(' type_id ')',
   as it is ambiguous and must be disambiguated elsewhere.  */
complex_parmlist:
	  parms
		{
		  $$ = chainon ($$, void_list_node);
		  TREE_PARMLIST ($$) = 1;
		}
	| parms_comma ELLIPSIS
		{
		  TREE_PARMLIST ($$) = 1;
		}
	/* C++ allows an ellipsis without a separating ',' */
	| parms ELLIPSIS
		{
		  TREE_PARMLIST ($$) = 1;
		}
	| type_id ELLIPSIS
		{
		  $$ = build_tree_list (NULL_TREE, $1.t); 
		  TREE_PARMLIST ($$) = 1;
		}
	| ELLIPSIS
		{
		  $$ = NULL_TREE;
		}
	| TYPENAME_ELLIPSIS
		{
		  TREE_PARMLIST ($$) = 1;
		}
	| parms TYPENAME_ELLIPSIS
		{
		  TREE_PARMLIST ($$) = 1;
		}
	| type_id TYPENAME_ELLIPSIS
		{
		  $$ = build_tree_list (NULL_TREE, $1.t);
		  TREE_PARMLIST ($$) = 1;
		}
	| parms ':'
		{
		  /* This helps us recover from really nasty
		     parse errors, for example, a missing right
		     parenthesis.  */
		  yyerror ("possibly missing ')'");
		  $$ = chainon ($$, void_list_node);
		  TREE_PARMLIST ($$) = 1;
		  yyungetc (':', 0);
		  yychar = ')';
		}
	| type_id ':'
		{
		  /* This helps us recover from really nasty
		     parse errors, for example, a missing right
		     parenthesis.  */
		  yyerror ("possibly missing ')'");
		  $$ = tree_cons (NULL_TREE, $1.t, void_list_node);
		  TREE_PARMLIST ($$) = 1;
		  yyungetc (':', 0);
		  yychar = ')';
		}
	;

/* A default argument to a */
defarg:
	  '='
		{ maybe_snarf_defarg (); }
	  defarg1
		{ $$ = $3; }
	;

defarg1:
	  DEFARG
	| init
	;

/* A nonempty list of parameter declarations or type names.  */
parms:
	  named_parm
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list (NULL_TREE, $1.t); }
	| parm defarg
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list ($2, $1.t); }
	| parms_comma full_parm
		{ check_for_new_type ("in a parameter list", $2);
		  $$ = chainon ($$, $2.t); }
	| parms_comma bad_parm
		{ $$ = chainon ($$, build_tree_list (NULL_TREE, $2)); }
	| parms_comma bad_parm '=' init
		{ $$ = chainon ($$, build_tree_list ($4, $2)); }
	;

parms_comma:
	  parms ','
	| type_id ','
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list (NULL_TREE, $1.t); }
	;

/* A single parameter declaration or parameter type name,
   as found in a parmlist.  */
named_parm:
	/* Here we expand typed_declspecs inline to avoid mis-parsing of
	   TYPESPEC IDENTIFIER.  */
	  typed_declspecs1 declarator
		{ tree specs = strip_attrs ($1.t);
		  $$.new_type_flag = $1.new_type_flag;
		  $$.t = build_tree_list (specs, $2); }
	| typed_typespecs declarator
		{ $$.t = build_tree_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typespec declarator
		{ $$.t = build_tree_list (get_decl_list ($1.t), $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typed_declspecs1 absdcl
		{ tree specs = strip_attrs ($1.t);
		  $$.t = build_tree_list (specs, $2);
		  $$.new_type_flag = $1.new_type_flag; }
	| typed_declspecs1  %prec EMPTY
		{ tree specs = strip_attrs ($1.t);
		  $$.t = build_tree_list (specs, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
	| declmods notype_declarator
		{ tree specs = strip_attrs ($1);
		  $$.t = build_tree_list (specs, $2); 
		  $$.new_type_flag = 0; }
	;

full_parm:
	  parm
		{ $$.t = build_tree_list (NULL_TREE, $1.t);
		  $$.new_type_flag = $1.new_type_flag;  }
	| parm defarg
		{ $$.t = build_tree_list ($2, $1.t);
		  $$.new_type_flag = $1.new_type_flag;  }
	;

parm:
	  named_parm
	| type_id
	;

see_typename:
	  /* empty */  %prec EMPTY
		{ see_typename (); }
	;

bad_parm:
	  /* empty */ %prec EMPTY
		{
		  error ("type specifier omitted for parameter");
		  $$ = build_tree_list (integer_type_node, NULL_TREE);
		}
	| notype_declarator
		{
		  error ("type specifier omitted for parameter");
		  if (TREE_CODE ($$) == SCOPE_REF
		      && TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM)
		    cp_error ("  perhaps you want `typename %E' to make it a type", $$);
		  $$ = build_tree_list (integer_type_node, $$);
		}
	;

exception_specification_opt:
	  /* empty */  %prec EMPTY
		{ $$ = NULL_TREE; }
	| THROW '(' ansi_raise_identifiers  ')'  %prec EMPTY
		{ $$ = $3; }
	| THROW LEFT_RIGHT  %prec EMPTY
		{ $$ = build_decl_list (NULL_TREE, NULL_TREE); }
	;

ansi_raise_identifier:
	  type_id
		{ $$ = build_decl_list (NULL_TREE, groktypename($1.t)); }
	;

ansi_raise_identifiers:
	  ansi_raise_identifier
	| ansi_raise_identifiers ',' ansi_raise_identifier
		{
		  TREE_CHAIN ($3) = $$;
		  $$ = $3;
		}
	;

conversion_declarator:
	  /* empty */  %prec EMPTY
		{ $$ = NULL_TREE; }
	| '*' cv_qualifiers conversion_declarator
		{ $$ = make_pointer_declarator ($2, $3); }
	| '&' cv_qualifiers conversion_declarator
		{ $$ = make_reference_declarator ($2, $3); }
	| ptr_to_mem cv_qualifiers conversion_declarator
		{ tree arg = make_pointer_declarator ($2, $3);
		  $$ = build_parse_node (SCOPE_REF, $1, arg);
		}
	;

operator:
	  OPERATOR
		{ got_scope = NULL_TREE; }
	;

operator_name:
	  operator '*'
		{ $$ = ansi_opname[MULT_EXPR]; }
	| operator '/'
		{ $$ = ansi_opname[TRUNC_DIV_EXPR]; }
	| operator '%'
		{ $$ = ansi_opname[TRUNC_MOD_EXPR]; }
	| operator '+'
		{ $$ = ansi_opname[PLUS_EXPR]; }
	| operator '-'
		{ $$ = ansi_opname[MINUS_EXPR]; }
	| operator '&'
		{ $$ = ansi_opname[BIT_AND_EXPR]; }
	| operator '|'
		{ $$ = ansi_opname[BIT_IOR_EXPR]; }
	| operator '^'
		{ $$ = ansi_opname[BIT_XOR_EXPR]; }
	| operator '~'
		{ $$ = ansi_opname[BIT_NOT_EXPR]; }
	| operator ','
		{ $$ = ansi_opname[COMPOUND_EXPR]; }
	| operator ARITHCOMPARE
		{ $$ = ansi_opname[$2]; }
	| operator '<'
		{ $$ = ansi_opname[LT_EXPR]; }
	| operator '>'
		{ $$ = ansi_opname[GT_EXPR]; }
	| operator EQCOMPARE
		{ $$ = ansi_opname[$2]; }
	| operator ASSIGN
		{ $$ = ansi_assopname[$2]; }
	| operator '='
		{ $$ = ansi_opname [MODIFY_EXPR]; }
	| operator LSHIFT
		{ $$ = ansi_opname[$2]; }
	| operator RSHIFT
		{ $$ = ansi_opname[$2]; }
	| operator PLUSPLUS
		{ $$ = ansi_opname[POSTINCREMENT_EXPR]; }
	| operator MINUSMINUS
		{ $$ = ansi_opname[PREDECREMENT_EXPR]; }
	| operator ANDAND
		{ $$ = ansi_opname[TRUTH_ANDIF_EXPR]; }
	| operator OROR
		{ $$ = ansi_opname[TRUTH_ORIF_EXPR]; }
	| operator '!'
		{ $$ = ansi_opname[TRUTH_NOT_EXPR]; }
	| operator '?' ':'
		{ $$ = ansi_opname[COND_EXPR]; }
	| operator MIN_MAX
		{ $$ = ansi_opname[$2]; }
	| operator POINTSAT  %prec EMPTY
		{ $$ = ansi_opname[COMPONENT_REF]; }
	| operator POINTSAT_STAR  %prec EMPTY
		{ $$ = ansi_opname[MEMBER_REF]; }
	| operator LEFT_RIGHT
		{ $$ = ansi_opname[CALL_EXPR]; }
	| operator '[' ']'
		{ $$ = ansi_opname[ARRAY_REF]; }
	| operator NEW  %prec EMPTY
		{ $$ = ansi_opname[NEW_EXPR]; }
	| operator DELETE  %prec EMPTY
		{ $$ = ansi_opname[DELETE_EXPR]; }
	| operator NEW '[' ']'
		{ $$ = ansi_opname[VEC_NEW_EXPR]; }
	| operator DELETE '[' ']'
		{ $$ = ansi_opname[VEC_DELETE_EXPR]; }
	/* Names here should be looked up in class scope ALSO.  */
	| operator type_specifier_seq conversion_declarator
		{ $$ = grokoptypename ($2.t, $3); }
	| operator error
		{ $$ = ansi_opname[ERROR_MARK]; }
	;

%%

#ifdef SPEW_DEBUG
const char *
debug_yytranslate (value)
    int value;
{
  return yytname[YYTRANSLATE (value)];
}

#endif
@


1.3
log
@update to gcc 2.8.1
@
text
@@


1.2
log
@GCC 2.8.0 merge
@
text
@d3020 1
a3024 2
			  /* Be sure to get an inherited typedef.  */
			  $$ = lookup_name ($1, 1);
a3028 2
		      else
			$$ = identifier_typedecl_value ($1);
d3036 1
a3036 1
		    $$ = identifier_typedecl_value ($2);
d3285 1
a3285 1
		    $$ = identifier_typedecl_value ($2);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1989, 1993, 1994, 1995 Free Software Foundation, Inc.
d44 1
d59 1
a64 2
void yyerror ();

d75 2
a80 2
void yyhook ();

d90 2
a91 1
  if (strict_prototype)
d101 1
a101 1
%union {long itype; tree ttype; char *strtype; enum tree_code code; }
d111 4
d126 1
a126 1
%token TYPE_QUAL
d140 1
a140 1
/* SCO include files test "ASM", so use something else. */
d145 1
d149 2
a150 2
%token <itype> VISSPEC
%token DELETE NEW OVERLOAD THIS OPERATOR CXX_TRUE CXX_FALSE
d168 1
a168 1
%left IDENTIFIER TYPENAME PTYPENAME SCSPEC TYPESPEC TYPE_QUAL ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD
d199 2
a200 1
%type <ttype> paren_expr_or_null nontrivial_exprlist
d202 4
a205 4
%type <ttype> typed_declspecs reserved_declspecs boolean.literal
%type <ttype> typed_typespecs reserved_typespecquals
%type <ttype> declmods typespec typespecqual_reserved
%type <ttype> SCSPEC TYPESPEC TYPE_QUAL nonempty_type_quals maybe_type_qual
d207 1
a207 1
%type <ttype> init initlist maybeasm maybe_init
d217 1
a217 1
%type <ttype> structsp opt.component_decl_list component_decl_list
d219 1
a219 1
%type <ttype> component_declarator component_declarator0
d223 1
a223 1
%type <ttype> type_id absdcl type_quals
d225 2
a226 2
%type <ttype> new_type_id new_declarator direct_new_declarator
%type <ttype> xexpr parmlist parms parm bad_parm full_parm
d231 1
d234 5
a238 1
%type <ttype> named_parm complex_parmlist typed_declspecs1 parms_comma
d243 3
a245 3
%token <ttype> PRE_PARSED_CLASS_DECL
%type <ttype> fn.def1 /* Not really! */
%type <ttype> fn.def2 return_id
d251 1
a251 1
%type <itype> base_class_access_list
d262 1
a263 4
%type <ttype> template_instantiation template_type_name tmpl.2
%type <ttype> template_instantiate_once template_instantiate_some
%type <itype> fn_tmpl_end
/* %type <itype> try_for_typename */
d266 1
a266 1
%type <ttype> qualified_type_name complete_type_name notype_identifier
d269 1
a269 1
%type <ttype> new_initializer new_placement specialization type_specifier_seq
d271 2
a272 2

/* in order to recognize aggr tags as defining and thus shadowing. */
d274 1
a274 1
%type <ttype> named_class_head_sans_basetype_defn 
d277 2
d285 1
a285 1
/* lex.c and pt.c depends on this being the last token.  Define
d291 1
a291 1
static tree current_declspecs;
d297 1
a297 1
static tree prefix_attributes;
d305 1
a305 1
extern void yyprint ();
d310 2
a311 1
program: /* empty */
d324 1
a324 1
 can find a valid list of type and sc specs in $0. */
d327 2
a328 1
	  { $<ttype>$ = NULL_TREE; } lang_extdef
d348 6
d360 1
a360 1
	  { if (pending_lang_change) do_pending_lang_change(); }
d362 2
a363 2
	  { if (! toplevel_bindings_p () && ! pseudo_global_level_p())
	      pop_everything (); }
d367 1
a367 1
	  fndef
a372 1
	| overloaddef
d378 1
a378 1
	| extern_lang_string .hush_warning fndef .warning_ok
d397 7
a403 1
		{ do_using_directive ($3); }
d438 3
d458 4
a461 1
		    pedwarn ("template type parameters must use the keyword `class'");
d480 7
a486 9
		{ $$ = build_tree_list (NULL_TREE, $$); }
	| template_type_parm '=' typespec
		{ $$ = build_tree_list ($3, $$); }
	| full_parm
	;

overloaddef:
	  OVERLOAD ov_identifiers ';'
		{ warning ("use of `overload' is an anachronism"); }
a488 6
ov_identifiers: IDENTIFIER
		{ declare_overloaded ($1); }
	| ov_identifiers ',' IDENTIFIER
		{ declare_overloaded ($3); }
	;
	  
d490 16
a505 94
	/* Class template declarations go here; they aren't normal class
	   declarations, because we can't process the bodies yet.  */
	  template_header named_class_head_sans_basetype '{'
		{ yychar = '{'; goto template1; }
	 ';'
	| template_header named_class_head_sans_basetype_defn '{'
		{ yychar = '{'; goto template1; }
	 ';'
	| template_header named_class_head_sans_basetype ':'
		{ yychar = ':'; goto template1; }
	 ';'
	| template_header named_class_head_sans_basetype_defn ':'
		{
		  yychar = ':';
		template1:
		  if (current_aggr == signature_type_node)
		    sorry ("template type defining a signature");
		  /* Maybe pedantic warning for union?
		     How about an enum? :-)  */
		  end_template_decl ($1, $2, current_aggr, 1);
		  reinit_parse_for_template (yychar, $1, $2);
		  yychar = YYEMPTY;
		}
	  ';'
	| template_header named_class_head_sans_basetype ';'
		{
		  end_template_decl ($1, $2, current_aggr, 0);
		  /* declare $2 as template name with $1 parm list */
		}
	| template_header named_class_head_sans_basetype_defn ';'
		{
		  end_template_decl ($1, $2, current_aggr, 0);
		  /* declare $2 as template name with $1 parm list */
		}
	| template_header /* notype_initdcl0 ';' */
	  notype_declarator exception_specification_opt maybeasm maybe_attribute
	  fn_tmpl_end
		{
		  tree d;
		  int momentary;
		  int def = ($6 != ';');
		  momentary = suspend_momentary ();
		  d = start_decl ($<ttype>2, /*current_declspecs*/NULL_TREE, 0,
				  $3);
		  cplus_decl_attributes (d, $5, /*prefix_attributes*/NULL_TREE);
		  cp_finish_decl (d, NULL_TREE, $4, 0, 0);
		  end_template_decl ($1, d, 0, def);
		  if (def)
		    reinit_parse_for_template ((int) $6, $1, d);
		  resume_momentary (momentary);
		}
	| template_header typed_declspecs /*initdcl0*/
	  declarator exception_specification_opt maybeasm maybe_attribute
	  fn_tmpl_end
		{
		  tree d, specs, attrs;
		  int momentary;
		  int def = ($7 != ';');
		  split_specs_attrs ($2, &specs, &attrs);
		  momentary = suspend_momentary ();
		  d = start_decl ($<ttype>3, specs, 0, $<ttype>4);
		  cplus_decl_attributes (d, $6, attrs);
		  cp_finish_decl (d, NULL_TREE, $5, 0, 0);
		  end_template_decl ($1, d, 0, def);
		  if (def)
		    {
		      reinit_parse_for_template ((int) $7, $1, d);
		      yychar = YYEMPTY;
		    }
		  note_list_got_semicolon ($<ttype>2);
		  resume_momentary (momentary);
		}
	| template_header declmods notype_declarator fn_tmpl_end
		{
		  tree d, specs, attrs;
		  int def = ($4 != ';');
		  split_specs_attrs ($2, &specs, &attrs);
		  d = start_decl ($<ttype>3, specs, 0, NULL_TREE);
		  cplus_decl_attributes (d, NULL_TREE, attrs);
		  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
		  end_template_decl ($1, d, 0, def);
		  if (def)
		    reinit_parse_for_template ((int) $4, $1, d);
		}
	/* Try to recover from syntax errors in templates.  */
	| template_header error '}'	{ end_template_decl ($1, 0, 0, 0); }
	| template_header error ';'	{ end_template_decl ($1, 0, 0, 0); }
	;

fn_tmpl_end: '{'		{ $$ = '{'; }
	| ':'			{ $$ = ':'; }
	| ';'			{ $$ = ';'; }
	| '='			{ $$ = '='; }
	| RETURN		{ $$ = RETURN; }
a512 8
	/* Normal case to make fast: "const i;".  */
	| declmods notype_declarator ';'
		{ tree d, specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);
		  cplus_decl_attributes (d, NULL_TREE, attrs);
		  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
		}
d515 1
a515 10
		  note_list_got_semicolon ($<ttype>$);
		}
	/* Normal case: make this fast.  */
	| typed_declspecs declarator ';'
		{ tree d, specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  d = start_decl ($<ttype>2, specs, 0, NULL_TREE);
		  cplus_decl_attributes (d, NULL_TREE, attrs);
		  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
		  note_list_got_semicolon ($<ttype>$);
d518 1
a518 1
	  { pedwarn ("empty declaration"); }
d521 6
a526 19
	  {
	    tree t, attrs;
	    split_specs_attrs ($1, &t, &attrs);
	    shadow_tag (t);
	    if (TREE_CODE (t) == TREE_LIST
		&& TREE_PURPOSE (t) == NULL_TREE)
	      {
		t = TREE_VALUE (t);
		if (IS_AGGR_TYPE (t)
		    && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (t)))
		  {
		    if (CLASSTYPE_USE_TEMPLATE (t) == 0)
		      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);
		    else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))
		      error ("override declaration for already-expanded template");
		  }
	      }
	    note_list_got_semicolon ($<ttype>$);
	  }
d552 51
d604 18
a621 2
		  finish_function (lineno, (int)$3, 0);
		  if ($<ttype>$) process_next_inline ($<ttype>$);
d623 12
a634 1
	| fn.def1 maybe_return_init function_try_block
d636 7
a642 1
		  if ($<ttype>$) process_next_inline ($<ttype>$);
a643 7
	  eat_saved_input
	| typed_declspecs declarator error
		{}
	| declmods notype_declarator error
		{}
	| notype_declarator error
		{}
d647 8
a654 1
	  typed_declspecs declarator exception_specification_opt
d657 6
a662 1
		  if (! start_function (specs, $2, $3, attrs, 0))
d666 4
a669 3
	| declmods notype_declarator exception_specification_opt
		{ tree specs = strip_attrs ($1);
		  if (! start_function (specs, $2, $3, NULL_TREE, 0))
d673 2
a674 2
	| notype_declarator exception_specification_opt
		{ if (! start_function (NULL_TREE, $$, $2, NULL_TREE, 0))
d678 11
a688 4
	| PRE_PARSED_FUNCTION_DECL
		{ start_function (NULL_TREE, TREE_VALUE ($$),
				  NULL_TREE, NULL_TREE, 1);
		  reinit_parse_for_function (); }
d694 1
a694 1
	  typed_declspecs '(' parmlist ')' type_quals exception_specification_opt
d696 1
a696 2
		  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs), $3, $5);
		  $$ = start_method (TREE_CHAIN (specs), $$, $6);
d703 6
a708 1
	| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt
d710 28
a737 4
		  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),
					 empty_parms (), $3);
		  $$ = start_method (TREE_CHAIN (specs), $$, $4);
		  goto rest_of_mdef;
a738 8
	| typed_declspecs declarator exception_specification_opt
		{ tree specs = strip_attrs ($1);
		  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }
	| declmods notype_declarator exception_specification_opt
		{ tree specs = strip_attrs ($1);
		  $$ = start_method (specs, $2, $3); goto rest_of_mdef; }
	| notype_declarator exception_specification_opt
		{ $$ = start_method (NULL_TREE, $$, $2); goto rest_of_mdef; }
d741 2
a742 1
return_id: RETURN IDENTIFIER
d750 2
a751 1
return_init: return_id maybe_init
d766 1
a766 1
		     pair of curley braces of a function.  These are needed
d773 1
a773 1
	/* empty */
d801 2
a802 1
member_init: '(' nonnull_exprlist ')'
d804 1
a804 1
		  if (current_class_name && !flag_traditional)
d806 1
a806 1
		  expand_member_init (C_C_D, NULL_TREE, $2);
d810 1
a810 1
		  if (current_class_name && !flag_traditional)
d812 1
a812 1
		  expand_member_init (C_C_D, NULL_TREE, void_type_node);
d815 1
a815 1
		{ expand_member_init (C_C_D, $<ttype>$, $3); }
d817 11
a827 14
		{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }
	| complete_type_name '(' nonnull_exprlist ')'
		{ expand_member_init (C_C_D, $<ttype>$, $3); }
	| complete_type_name LEFT_RIGHT
		{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }
	/* GNU extension */
	| notype_qualified_id '(' nonnull_exprlist ')'
		{
		  do_member_init (OP0 ($1), OP1 ($1), $3);
		}
	| notype_qualified_id LEFT_RIGHT
		{
		  do_member_init (OP0 ($1), OP1 ($1), void_type_node);
		}
d833 1
d841 1
a841 1
	| NSNAME %prec EMPTY
d851 3
a853 2
	  TEMPLATE specialization template_instantiation
		{ do_type_instantiation ($3 ? $3 : $2, NULL_TREE); }
d855 2
a856 2
		{ tree specs = strip_attrs ($2);
		  do_function_instantiation (specs, $3, NULL_TREE); }
d858 6
a863 3
		{ do_function_instantiation (NULL_TREE, $2, NULL_TREE); }
	| SCSPEC TEMPLATE specialization template_instantiation
		{ do_type_instantiation ($4 ? $4 : $3, $1); }
d865 2
a866 2
		{ tree specs = strip_attrs ($3);
		  do_function_instantiation (specs, $4, $1); }
d868 3
a870 1
		{ do_function_instantiation (NULL_TREE, $3, $1); }
d873 4
d878 25
a902 2
	  template_type_name tmpl.2 template_instantiation
		{ if ($3) $$ = $3; }
d905 13
a917 7
template_type_name:
	  PTYPENAME '<' template_arg_list '>'
		{ $$ = lookup_template_class ($$, $3, NULL_TREE); }
	| PTYPENAME '<' '>'
		{ $$ = lookup_template_class ($$, NULL_TREE, NULL_TREE); }
	| TYPENAME  '<' template_arg_list '>'
		{ $$ = lookup_template_class ($$, $3, NULL_TREE); }
d920 8
a927 3
tmpl.2: 
	  /* empty */ %prec EMPTY
		{ $$ = instantiate_class_template ($<ttype>0, 1); }
d939 2
a940 54
		{ $$ = groktypename ($$); }
	| expr_no_commas  %prec UNARY
	;

template_instantiate_once:
	  PRE_PARSED_CLASS_DECL maybe_base_class_list
		{
		  tree t, decl, tmpl;

		  tmpl = TREE_PURPOSE (IDENTIFIER_TEMPLATE ($1));
		  t = xref_tag (DECL_TEMPLATE_INFO (tmpl)->aggr, $1, $2, 0);
		  set_current_level_tags_transparency (1);
		  my_friendly_assert (TREE_CODE (t) == RECORD_TYPE
				      || TREE_CODE (t) == UNION_TYPE, 257);
		  $<ttype>$ = t;

		  /* Now, put a copy of the decl in global scope, to avoid
		     recursive expansion.  */
		  decl = IDENTIFIER_LOCAL_VALUE ($1);
		  if (!decl)
		    decl = IDENTIFIER_CLASS_VALUE ($1);
		  /* Now, put a copy of the decl in global scope, to avoid
		     recursive expansion.  */
                  if (decl)
                    {
		      /* Need to copy it to clear the chain pointer,
			 and need to get it into permanent storage.  */
                      my_friendly_assert (TREE_CODE (decl) == TYPE_DECL, 258);
		      push_obstacks (&permanent_obstack, &permanent_obstack);
                      decl = copy_node (decl);
		      if (DECL_LANG_SPECIFIC (decl))
			copy_lang_decl (decl);
		      pop_obstacks ();
		      pushdecl_top_level (decl);
		    }
		  /* Kludge; see instantiate_class_template.  */
		  TYPE_BEING_DEFINED (t) = 0;
		}
	  left_curly opt.component_decl_list '}'
		{
		  tree t = finish_struct ($<ttype>3, $5, 0);

		  pop_obstacks ();
		  end_template_instantiation ($1);

		  repo_template_used (t);

                  /* Now go after the methods & class data.  */
                  instantiate_member_templates ($1);

		  pop_tinst_level();

		  CLASSTYPE_GOT_SEMICOLON (t) = 1;
		}
d943 2
a944 15
template_instantiation:
          /* empty */
                { $$ = NULL_TREE; }
        | template_instantiate_once
                { $$ = $1; }
        ;

template_instantiate_some:
          /* empty */
                { $$ = NULL_TREE; /* never used from here... */}
        | template_instantiate_once template_instantiate_some
                { $$ = $1; /*???*/ }
        ;

unop:     '-'
d956 2
a957 1
expr:	  nontrivial_exprlist
d981 1
a981 1
	/* empty */
d990 1
a990 1
	type_specifier_seq declarator exception_specification_opt maybeasm maybe_attribute '='
d1002 4
a1005 4
		  current_declspecs = $1;
		  $<itype>6 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1, $3);
		  cplus_decl_attributes ($<ttype>$, $5,
d1008 1
a1008 1
	init
d1010 3
a1012 3
		  cp_finish_decl ($<ttype>7, $8, $5, 0, LOOKUP_ONLYCONVERTING);
		  resume_momentary ($<itype>6);
		  $$ = $<ttype>7; 
d1027 19
a1045 2
	  '{' compstmtend
		{ finish_stmt (); }
d1052 2
a1053 2
		{ $$ = tree_cons (NULL_TREE, $$, 
		                  build_tree_list (NULL_TREE, $3)); }
d1055 2
a1056 2
		{ $$ = tree_cons (NULL_TREE, $$, 
		                  build_tree_list (NULL_TREE, error_mark_node)); }
d1058 1
a1058 1
		{ chainon ($$, build_tree_list (NULL_TREE, $3)); }
d1060 1
a1060 1
		{ chainon ($$, build_tree_list (NULL_TREE, error_mark_node)); }
d1065 1
a1065 1
		{ $$ = build_tree_list (NULL_TREE, $$); }
d1070 2
a1071 7
	  primary %prec UNARY
		{
#if 0
		  if (TREE_CODE ($$) == TYPE_EXPR)
		    $$ = build_component_type_expr (C_C_D, $$, NULL_TREE, 1);
#endif
		}
d1073 2
a1074 5
	| EXTENSION
		{ $<itype>1 = pedantic;
		  pedantic = 0; }
	  cast_expr	  %prec UNARY
		{ $$ = $3;
d1091 2
d1103 1
a1103 21
		{ if (TREE_CODE ($2) == COMPONENT_REF
		      && DECL_BIT_FIELD (TREE_OPERAND ($2, 1)))
		    error ("sizeof applied to a bit-field");
		  /* ANSI says arrays and functions are converted inside comma.
		     But we can't really convert them in build_compound_expr
		     because that would break commas in lvalues.
		     So do the conversion here if operand was a comma.  */
		  if (TREE_CODE ($2) == COMPOUND_EXPR
		      && (TREE_CODE (TREE_TYPE ($2)) == ARRAY_TYPE
			  || TREE_CODE (TREE_TYPE ($2)) == FUNCTION_TYPE))
		    $2 = default_conversion ($2);
		  else if (TREE_CODE ($2) == TREE_LIST)
	            {
		      tree t = TREE_VALUE ($2);
		      if (t != NULL_TREE
			  && ((TREE_TYPE (t)
			      && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)
			      || is_overloaded_fn (t)))
			pedwarn ("ANSI C++ forbids taking the sizeof a function type");
		    }
		  $$ = c_sizeof (TREE_TYPE ($2)); }
d1105 1
a1105 1
		{ $$ = c_sizeof (groktypename ($3)); }
d1109 2
a1110 1
		{ $$ = c_alignof (groktypename ($3)); }
d1114 3
a1116 2
	| new new_type_id %prec EMPTY
		{ $$ = build_new (NULL_TREE, $2, NULL_TREE, $1); }
d1118 5
a1122 3
		{ $$ = build_new (NULL_TREE, $2, $3, $1); }
	| new new_placement new_type_id %prec EMPTY
		{ $$ = build_new ($2, $3, NULL_TREE, $1); }
d1124 6
a1129 4
		{ $$ = build_new ($2, $3, $4, $1); }
	| new '(' type_id ')' %prec EMPTY
		{ $$ = build_new (NULL_TREE, groktypename($3),
				  NULL_TREE, $1); }
d1131 5
a1135 3
		{ $$ = build_new (NULL_TREE, groktypename($3), $5, $1); }
	| new new_placement '(' type_id ')' %prec EMPTY
		{ $$ = build_new ($2, groktypename($4), NULL_TREE, $1); }
d1137 2
a1138 1
		{ $$ = build_new ($2, groktypename($4), $6, $1); }
d1146 1
a1146 1
	| delete '[' expr ']' cast_expr %prec UNARY
d1150 4
d1173 1
a1173 1
		  cp_error ("`%T' is not a valid expression", $2);
d1189 10
a1198 9
	  '(' type_id ')' %prec EMPTY
		{ $2 = tree_cons (NULL_TREE, $2, void_list_node);
		  TREE_PARMLIST ($2) = 1;
		  $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, 
					 NULL_TREE); }
	| regcast_or_absdcl '(' type_id ')' %prec EMPTY
		{ $3 = tree_cons (NULL_TREE, $3, void_list_node);
		  TREE_PARMLIST ($3) = 1;
		  $$ = build_parse_node (CALL_EXPR, $$, $3, NULL_TREE); }
d1262 3
a1264 2
		{ $$ = build_modify_expr ($$, NOP_EXPR, $3);
                  C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }
d1266 1
a1266 6
		{ register tree rval;
		  if ((rval = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL, $$, $3,
					     make_node ($2))))
		    $$ = rval;
		  else
		    $$ = build_modify_expr ($$, $2, $3); }
d1274 1
a1274 1
	| object '&' expr_no_commas   %prec UNARY
d1279 2
a1280 2
		{ tree type = groktypename ($3);
		  $$ = build_m_component_ref ($$, build_c_cast (type, $5, 0)); }
d1289 1
d1293 1
a1293 1
	| NSNAME %prec EMPTY
d1296 22
d1321 1
d1326 1
a1326 1
	| '*' expr_or_declarator %prec UNARY
d1328 1
a1328 1
	| '&' expr_or_declarator %prec UNARY
d1334 7
d1344 1
d1354 2
a1355 14
		  else if (IDENTIFIER_OPNAME_P ($$))
		    {
		      tree op = $$;
		      $$ = lookup_name (op, 0);
		      if ($$ == NULL_TREE)
			{
			  if (op != ansi_opname[ERROR_MARK])
			    error ("operator %s not defined",
				   operator_name_string (op));
			  $$ = error_mark_node;
			}
		    }
		  else
		    $$ = do_identifier ($$);
d1360 7
a1366 1
		{ $$ = combine_strings ($$); }
d1373 1
a1373 1
                    /* This inhibits warnings in truthvalue_conversion. */
d1381 1
a1381 1
                    /* This inhibits warnings in truthvalue_conversion. */
d1415 5
a1419 10
                { /* [eichin:19911016.1902EST] */
                  $<ttype>$ = build_x_function_call ($1, $3, current_class_decl); 
                  /* here we instantiate_class_template as needed... */
                  do_pending_templates ();
                } template_instantiate_some {
                  if (TREE_CODE ($<ttype>5) == CALL_EXPR
                      && TREE_TYPE ($<ttype>5) != void_type_node)
	            $$ = require_complete_type ($<ttype>5);
                  else
                    $$ = $<ttype>5;
d1423 1
a1423 1
		  $$ = build_x_function_call ($$, NULL_TREE, current_class_decl);
d1445 1
a1445 1
		{ if (current_class_decl)
d1448 1
a1448 1
		      TREE_USED (current_class_decl) = 1;
d1450 1
a1450 1
		      $$ = current_class_decl;
d1467 1
a1467 1
	| TYPE_QUAL '(' nonnull_exprlist ')'
d1508 1
a1508 1
		      $$ = build_c_cast (type, build_compound_expr ($3), 1);
d1512 16
a1527 28
	| DYNAMIC_CAST '<'
		{ dont_allow_type_definitions = "inside dynamic_cast"; }
	  type_id '>'
		{ dont_allow_type_definitions = 0; }
	  '(' expr ')'
		{ tree type = groktypename ($4);
		  $$ = build_dynamic_cast (type, $8); }
	| STATIC_CAST '<'
		{ dont_allow_type_definitions = "inside static_cast"; }
	  type_id '>'
		{ dont_allow_type_definitions = 0; }
	  '(' expr ')'
		{ tree type = groktypename ($4);
		  $$ = build_static_cast (type, $8); }
	| REINTERPRET_CAST '<'
		{ dont_allow_type_definitions = "inside reinterpret_cast"; }
	  type_id '>'
		{ dont_allow_type_definitions = 0; }
	  '(' expr ')'
		{ tree type = groktypename ($4);
		  $$ = build_reinterpret_cast (type, $8); }
	| CONST_CAST '<'
		{ dont_allow_type_definitions = "inside const_cast"; }
	  type_id '>'
		{ dont_allow_type_definitions = 0; }
	  '(' expr ')'
		{ tree type = groktypename ($4);
		  $$ = build_const_cast (type, $8); }
d1529 1
a1529 1
		{ $$ = build_typeid ($3); }
d1531 2
a1532 1
		{ tree type = groktypename ($3);
d1535 1
a1535 38
		{
		do_scoped_id:
		  $$ = IDENTIFIER_GLOBAL_VALUE ($2);
		  if (yychar == YYEMPTY)
		    yychar = YYLEX;
		  if (! $$)
		    {
		      if (yychar == '(' || yychar == LEFT_RIGHT)
			$$ = implicitly_declare ($2);
		      else
			{
			  if (IDENTIFIER_GLOBAL_VALUE ($2) != error_mark_node)
			    error ("undeclared variable `%s' (first use here)",
				   IDENTIFIER_POINTER ($2));
			  $$ = error_mark_node;
			  /* Prevent repeated error messages.  */
			  IDENTIFIER_GLOBAL_VALUE ($2) = error_mark_node;
			}
		    }
		  else
		    {
		      if (TREE_CODE ($$) == ADDR_EXPR)
			assemble_external (TREE_OPERAND ($$, 0));
		      else
			assemble_external ($$);
		      TREE_USED ($$) = 1;
		    }
		  if (TREE_CODE ($$) == CONST_DECL)
		    {
		      /* XXX CHS - should we set TREE_USED of the constant? */
		      $$ = DECL_INITIAL ($$);
		      /* This is to prevent an enum whose value is 0
			 from being considered a null pointer constant.  */
		      $$ = build1 (NOP_EXPR, TREE_TYPE ($$), $$);
		      TREE_CONSTANT ($$) = 1;
		    }

		}
d1540 3
a1542 2
		    goto do_scoped_id;
		  $$ = $2;
d1544 1
a1544 1
	| overqualified_id %prec HYPERUNARY
d1547 4
a1550 1
		{ $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }
d1552 19
a1570 1
		{ $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }
d1572 6
a1577 5
		{ got_object = NULL_TREE;
		  $$ = build_component_ref ($$, $2, NULL_TREE, 1); }
	| object overqualified_id %prec UNARY
		{ got_object = NULL_TREE;
		  $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }
a1579 1
		  got_object = NULL_TREE;
d1583 2
a1584 2
		     in build_component_ref entirely yet, we cannot do this. */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, $$);
d1590 1
a1590 1
					  (LOOKUP_NORMAL|LOOKUP_AGGR));
a1594 1
		  got_object = NULL_TREE;
d1598 2
a1599 2
		     in build_component_ref entirely yet, we cannot do this. */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, $$);
d1605 1
a1605 1
					  (LOOKUP_NORMAL|LOOKUP_AGGR));
d1610 1
a1610 2
		  got_object = NULL_TREE;
		  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))
d1614 1
a1614 1
					      (LOOKUP_NORMAL|LOOKUP_AGGR));
d1621 1
a1621 2
		  got_object = NULL_TREE;
		  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))
d1625 1
a1625 1
					      (LOOKUP_NORMAL|LOOKUP_AGGR));
a1632 1
		  got_object = NULL_TREE;
d1637 1
a1637 1
		  $$ = convert (void_type_node, $1);
a1640 1
		  got_object = NULL_TREE;
d1646 1
a1646 1
		  $$ = convert (void_type_node, $1);
a1649 1
		  got_object = NULL_TREE;
d1673 1
a1673 1
		{ $$ = build_x_function_call ($$, $3, current_class_decl); }
d1675 1
a1675 1
		{ $$ = build_x_function_call ($$, NULL_TREE, current_class_decl); }
d1692 2
a1693 1
new:	  NEW
d1699 2
a1700 1
delete:	  DELETE
d1727 1
a1727 1
		     pair of curley braces of a function.  These are needed
d1733 2
a1734 1
object:	  primary '.'
d1744 1
a1744 22
	/* Normal case: make this fast.  */
	  typespec declarator ';'
		{ tree d = get_decl_list ($1);
		  int yes = suspend_momentary ();
		  d = start_decl ($2, d, 0, NULL_TREE);
		  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
		  resume_momentary (yes);
		  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))
		    note_got_semicolon ($1);
		}
	| typed_declspecs declarator ';'
		{ tree d, specs, attrs;
		  int yes;
		  split_specs_attrs ($1, &specs, &attrs);
		  yes = suspend_momentary ();
		  d = start_decl ($2, specs, 0, NULL_TREE);
		  cplus_decl_attributes (d, NULL_TREE, attrs);
		  cp_finish_decl (d, NULL_TREE, NULL_TREE, 0, 0);
		  resume_momentary (yes);
		  note_list_got_semicolon ($1);
		}
	| typespec initdecls ';'
d1747 2
a1748 2
		  if (IS_AGGR_TYPE_CODE (TREE_CODE ($1)))
		    note_got_semicolon ($1);
d1753 1
a1753 1
		  note_list_got_semicolon ($1);
d1759 2
a1760 2
		  shadow_tag ($1);
		  note_list_got_semicolon ($1);
d1764 2
d1772 2
a1773 2
	  after_type_declarator %prec EMPTY
	| notype_declarator %prec EMPTY
d1778 6
a1783 6
	  LEFT_RIGHT %prec EMPTY
		{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, empty_parms (),
					 NULL_TREE); }
	| fcast_or_absdcl LEFT_RIGHT %prec EMPTY
		{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), 
					 NULL_TREE); }
d1789 5
a1793 3
		{ $$ = build_decl_list ($$, $2); }
	| nonempty_type_quals absdcl
		{ $$ = build_decl_list ($$, $2); }
d1795 8
a1802 5
		{ $$ = build_decl_list (get_decl_list ($$), $2); }
	| typed_typespecs %prec EMPTY
		{ $$ = build_decl_list ($$, NULL_TREE); }
	| nonempty_type_quals %prec EMPTY
		{ $$ = build_decl_list ($$, NULL_TREE); }
d1811 1
a1811 1
	  typed_typespecs %prec EMPTY
d1817 5
a1821 3
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
	| typespec reserved_declspecs	%prec HYPERUNARY
		{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }
d1823 2
a1824 1
		{ $$ = decl_tree_cons (NULL_TREE, $$, chainon ($2, $3)); }
d1826 2
a1827 1
		{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }
d1829 2
a1830 1
		{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }
d1832 3
a1834 2
		{ $$ = decl_tree_cons (NULL_TREE, $2, 
				       chainon ($3, chainon ($4, $$))); }
d1844 1
a1844 1
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
d1862 2
a1863 2
	  nonempty_type_quals %prec EMPTY
		{ TREE_STATIC ($$) = 1; }
d1866 1
a1866 1
	| declmods TYPE_QUAL
d1889 5
a1893 3
		{ $$ = get_decl_list ($$); }
	| nonempty_type_quals typespec
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
d1895 5
a1899 3
		{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }
	| nonempty_type_quals typespec reserved_typespecquals
		{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }
d1904 1
a1904 1
		{ $$ = build_decl_list (NULL_TREE, $$); }
d1906 1
a1906 1
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
d1913 2
a1914 1
typespec: structsp
d1916 1
d1918 1
d1920 2
a1921 3
		{ $$ = TREE_TYPE ($3);
		  if (pedantic && !in_system_header)
		    pedwarn ("ANSI C++ forbids `typeof'"); }
d1923 2
a1924 3
		{ $$ = groktypename ($3);
		  if (pedantic && !in_system_header)
		    pedwarn ("ANSI C++ forbids `typeof'"); }
d1928 1
d1932 1
a1932 1
		      $$ = type;
d1937 1
a1937 1
		      $$ = error_mark_node;
d1941 1
a1941 1
		{ tree type = groktypename ($3);
d1943 1
d1947 1
a1947 1
		      $$ = type;
d1952 1
a1952 1
		      $$ = error_mark_node;
d1959 5
a1963 2
typespecqual_reserved: TYPESPEC
	| TYPE_QUAL
d1990 1
a1990 1
	  declarator exception_specification_opt maybeasm maybe_attribute '='
d1993 2
a1994 1
		  if (TREE_CODE (current_declspecs) != TREE_LIST)
d2003 3
a2005 3
		  $<itype>5 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);
		  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }
d2008 3
a2010 3
		{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>5; }
	| declarator exception_specification_opt maybeasm maybe_attribute
d2014 2
a2015 1
		  if (TREE_CODE (current_declspecs) != TREE_LIST)
d2025 3
a2027 3
		  d = start_decl ($<ttype>1, current_declspecs, 0, $2);
		  cplus_decl_attributes (d, $4, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }
d2031 3
a2033 3
	  declarator exception_specification_opt maybeasm maybe_attribute '='
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);
		  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }
d2036 5
a2040 5
		{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING); }
	| declarator exception_specification_opt maybeasm maybe_attribute
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0, $2);
		  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes);
		  cp_finish_decl ($<ttype>$, NULL_TREE, $3, 0, 0); }
d2044 1
a2044 1
	  notype_declarator exception_specification_opt maybeasm maybe_attribute '='
d2047 3
a2049 3
		  $<itype>5 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1, $2);
		  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }
d2052 3
a2054 3
		{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>5; }
	| notype_declarator exception_specification_opt maybeasm maybe_attribute
d2059 3
a2061 3
		  d = start_decl ($<ttype>1, current_declspecs, 0, $2);
		  cplus_decl_attributes (d, $4, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }
d2065 1
a2065 1
	  notype_declarator exception_specification_opt maybeasm maybe_attribute '='
d2068 3
a2070 3
		  $<itype>5 = suspend_momentary ();
		  $<ttype>$ = start_decl ($1, current_declspecs, 1, $2);
		  cplus_decl_attributes ($<ttype>$, $4, prefix_attributes); }
d2073 3
a2075 3
		{ cp_finish_decl ($<ttype>6, $7, $3, 0, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>5; }
	| notype_declarator exception_specification_opt maybeasm maybe_attribute
d2080 3
a2082 3
		  d = start_decl ($1, current_declspecs, 0, $2);
		  cplus_decl_attributes (d, $4, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $3, 0, 0); }
d2086 1
a2086 1
   so that the header files compile. */
d2088 1
a2088 1
      /* empty */
d2114 1
a2114 1
    /* empty */
d2133 1
a2133 1
	| TYPE_QUAL
d2138 1
a2138 1
	identifier
d2145 1
a2145 1
	%prec EMPTY /* empty */
d2150 3
d2154 1
a2154 1
	  expr_no_commas %prec '='
d2174 1
a2174 1
		{ $$ = tree_cons (NULL_TREE, $3, $$); }
d2177 1
a2177 1
		{ $$ = build_tree_list ($2, $4); }
d2179 1
a2179 1
		{ $$ = tree_cons ($4, $6, $$); }
d2181 1
a2181 1
		{ $$ = build_tree_list ($$, $3); }
d2183 42
a2224 1
		{ $$ = tree_cons ($3, $5, $$); }
d2230 1
a2230 1
		  $$ = start_enum ($2); }
d2232 2
a2233 1
		{ $$ = finish_enum ($<ttype>4, $5);
d2237 3
a2239 2
		{ $$ = finish_enum (start_enum ($2), NULL_TREE);
		  check_for_missing_semicolon ($$); }
d2242 1
a2242 1
		  $$ = start_enum (make_anon_name ()); }
d2244 1
a2244 1
		{ $$ = finish_enum ($<ttype>3, $4);
d2246 2
a2247 1
		  check_for_missing_semicolon ($<ttype>3); }
d2249 3
a2251 2
		{ $$ = finish_enum (start_enum (make_anon_name()), NULL_TREE);
		  check_for_missing_semicolon ($$); }
d2253 2
a2254 1
		{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }
d2256 5
a2260 3
		{ $$ = xref_tag (enum_type_node, $2, NULL_TREE, 1); }
	| TYPENAME_KEYWORD complex_type_name
		{ $$ = $2; }
d2262 3
a2264 1
	| class_head left_curly opt.component_decl_list '}'
d2269 1
d2273 1
a2273 1
		  shadow_tag (CLASSTYPE_AS_LIST ($$)); */
d2279 1
a2279 1
		     finish_exception does too, then it can go. */
d2281 1
a2281 1
		    note_got_semicolon ($$);
d2283 2
a2284 2
		  if (TREE_CODE ($$) == ENUMERAL_TYPE)
		    /* $$ = $1 from default rule.  */;
d2287 2
a2288 2
		      $$ = finish_struct ($$, $3, semi);
		      if (semi) note_got_semicolon ($$);
a2292 18
		  id = TYPE_IDENTIFIER ($$);
		  if (id && IDENTIFIER_TEMPLATE (id))
		    {
		      tree decl;

		      /* I don't know if the copying of this TYPE_DECL is
		       * really needed.  However, it's such a small per-
		       * formance penalty that the extra safety is a bargain.
		       * - niklas@@appli.se
		       */
		      push_obstacks (&permanent_obstack, &permanent_obstack);
		      decl = copy_node (lookup_name (id, 0));
		      if (DECL_LANG_SPECIFIC (decl))
			copy_lang_decl (decl);
		      pop_obstacks ();
		      undo_template_name_overload (id, 0);
		      pushdecl_top_level (decl);
		    }
d2294 17
a2310 1
		    check_for_missing_semicolon ($$); }
d2313 2
d2316 2
a2317 2
		  if (TYPE_BINFO_BASETYPES ($$) && !TYPE_SIZE ($$)
		      && ! TYPE_BEING_DEFINED ($$))
d2319 1
a2319 1
			      $$);
d2331 2
a2332 1
		{ if (pedantic) pedwarn ("comma at end of enumerator list"); }
d2335 2
a2336 1
aggr:	  AGGR
d2341 1
a2341 1
	| aggr TYPE_QUAL
a2346 9
specialization:
	  aggr template_type_name ';'
		{ 
		  yyungetc (';', 1); current_aggr = $$; $$ = $2; 
		  if ($<ttype>0 == ridpointers[(int) RID_TEMPLATE])
		    instantiate_class_template ($$, 2);
		}
	;

a2349 1
	| specialization
d2353 1
a2353 1
	  aggr identifier_defn %prec EMPTY
a2354 8
	| aggr template_type_name '{'
		{ yyungetc ('{', 1);
		aggr2:
		  current_aggr = $$;
		  $$ = $2;
		  overload_template_name ($$, 0); }
	| aggr template_type_name ':'
		{ yyungetc (':', 1); goto aggr2; }
d2359 17
a2376 2
	| aggr template_type %prec EMPTY
		{ current_aggr = $$; $$ = $2; }
d2379 3
a2381 2
do_xref_defn: /* empty */ %prec EMPTY
        { $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }
d2385 1
a2385 1
	  named_class_head_sans_basetype %prec EMPTY
d2388 1
a2388 1
          maybe_base_class_list %prec EMPTY
d2397 6
d2404 15
a2418 1
		    xref_basetypes (current_aggr, $1, TREE_TYPE ($1), $2); 
d2422 2
a2423 1
unnamed_class_head: aggr '{'
d2428 4
a2431 1
class_head: unnamed_class_head | named_class_head ;
d2434 1
a2434 1
	  %prec EMPTY /* empty */
d2436 1
a2436 1
	| ':' see_typename %prec EMPTY
d2451 2
a2452 3
		  tree type;
		  type = IDENTIFIER_TYPE_VALUE ($$);
		  if (! is_aggr_typedef ($$, 1))
d2464 1
a2464 1
		      $$ = build_tree_list ((tree)access_public, $$);
d2472 1
a2472 1
		    $$ = build_tree_list ((tree)access_default, $$);
d2476 1
a2476 2
		  tree type;
		  type = IDENTIFIER_TYPE_VALUE ($3);
d2479 1
a2479 1
		  if (! is_aggr_typedef ($3, 1))
d2491 1
a2491 1
		      $$ = build_tree_list ((tree)access_public, $3);
d2499 1
a2499 1
		    $$ = build_tree_list ((tree) $$, $3);
d2504 3
a2506 1
	  complete_type_name
d2514 1
a2514 2
			  /* need to return some dummy signature identifier */
			  $$ = $3;
d2532 1
a2532 1
		      if (IS_AGGR_TYPE (groktypename ($3)))
d2535 1
a2535 2
			  /* need to return some dummy signature identifier */
			  $$ = $3;
d2556 1
a2556 1
		  $$ = access_default_virtual; }
d2559 1
a2559 1
		  if ($2 == access_protected)
d2562 1
a2562 1
		      $2 = access_public;
d2565 1
a2565 1
		  else if ($2 == access_public)
d2567 1
a2567 1
		      if ($1 == access_private)
d2572 2
a2573 2
		      else if ($1 == access_default_virtual)
			$$ = access_public_virtual;
d2575 1
a2575 1
		  else /* $2 == access_private */
d2577 1
a2577 1
		      if ($1 == access_public)
d2579 2
a2580 2
		      else if ($1 == access_default_virtual)
			$$ = access_private_virtual;
d2586 4
a2589 4
		  if ($$ == access_public)
		    $$ = access_public_virtual;
		  else if ($$ == access_private)
		    $$ = access_private_virtual; }
d2592 2
a2593 1
left_curly: '{'
d2598 2
a2599 1
		  if (! IS_AGGR_TYPE (t))
d2602 1
a2602 1
		      TYPE_NAME (t) = get_identifier ("erroneous type");
d2612 3
d2617 12
d2675 7
d2683 3
a2685 3
	/* empty */
		{ $$ = NULL_TREE; }
	| component_decl_list
d2688 1
a2688 1
		    $$ = build_tree_list ((tree) access_public, $$);
d2690 2
a2691 1
		    $$ = build_tree_list ((tree) access_default, $$);
d2695 1
a2695 1
		  tree visspec = (tree) $2;
d2700 1
a2700 1
		      visspec = (tree) access_public;
d2750 3
d2760 1
a2760 1
		{ $$ = grok_x_components ($1, $2); }
d2763 6
a2768 3
	| notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $2, $5, $3,
				  build_tree_list ($4, NULL_TREE)); }
d2782 1
a2782 8
	| typed_declspecs '(' parmlist ')' type_quals exception_specification_opt maybeasm maybe_attribute maybe_init
		{ tree specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),
					 $3, $5);
		  $$ = grokfield ($$, TREE_CHAIN (specs), $6, $9, $7,
				  build_tree_list ($8, attrs)); }
	| typed_declspecs LEFT_RIGHT type_quals exception_specification_opt maybeasm maybe_attribute maybe_init
d2785 5
a2789 4
		  $$ = build_parse_node (CALL_EXPR, TREE_VALUE (specs),
					 empty_parms (), $3);
		  $$ = grokfield ($$, TREE_CHAIN (specs), $4, $7, $5,
				  build_tree_list ($6, attrs)); }
d2792 21
a2812 1
	;
d2814 1
a2814 1
/* The case of exactly one component is handled directly by component_decl. */
d2857 1
a2857 1
	  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init
d2861 2
a2862 2
		  $$ = grokfield ($$, current_declspecs, $2, $5, $3,
				  build_tree_list ($4, prefix_attributes)); }
d2872 1
a2872 1
	  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init
d2876 8
a2883 2
		  $$ = grokfield ($$, current_declspecs, $2, $5, $3,
				  build_tree_list ($4, prefix_attributes)); }
d2899 3
a2901 3
	  after_type_declarator exception_specification_opt maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,
				  build_tree_list ($4, prefix_attributes)); }
d2908 3
a2910 3
	  notype_declarator exception_specification_opt maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $2, $5, $3,
				  build_tree_list ($4, prefix_attributes)); }
d2939 5
a2943 3
		{ $$ = build_decl_list ($$, $2); }
	| type_specifier_seq %prec EMPTY
		{ $$ = build_decl_list ($$, NULL_TREE); }
d2950 3
a2952 2
		  $$ = build_parse_node (ARRAY_REF, TREE_VALUE ($2), $5);
		  $$ = build_decl_list (TREE_PURPOSE ($2), $$);
d2956 2
a2957 2
type_quals:
	  /* empty */ %prec EMPTY
d2959 1
a2959 1
	| type_quals TYPE_QUAL
d2963 7
a2969 5
nonempty_type_quals:
	  TYPE_QUAL
		{ $$ = IDENTIFIER_AS_LIST ($$); }
	| nonempty_type_quals TYPE_QUAL
		{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }
d2976 2
a2977 1
	{ $<itype>$ = suspend_momentary (); } 
d2981 2
a2982 2
	suspend_mom expr
	{ resume_momentary ((int) $<itype>1); $$ = $2; }
d3000 4
a3003 4
	  '*' nonempty_type_quals after_type_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2, $3); }
	| '&' nonempty_type_quals after_type_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2, $3); }
d3008 1
a3008 1
	| ptr_to_mem type_quals after_type_declarator
d3015 2
a3016 2
qualified_type_name:
	  type_name %prec EMPTY
d3018 14
a3031 9
		  /* Remember that this name has been used in the class
		     definition, as per [class.scope0] */
		  if (current_class_type
		      && TYPE_BEING_DEFINED (current_class_type)
		      && ! IDENTIFIER_CLASS_VALUE ($$))
		    {
		      tree t = lookup_name ($$, -2);
		      if (t)
			pushdecl_class_level (t);
d3033 2
d3036 12
d3049 2
d3054 2
a3055 2
	nested_name_specifier type_name %prec EMPTY
		{ $$ = $2; }
d3059 2
a3060 2
	  direct_after_type_declarator maybe_parmlist type_quals %prec '.'
		{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }
d3067 2
a3068 2
	| nested_name_specifier type_name %prec EMPTY
		{ push_nested_class (TREE_TYPE ($$), 3);
d3071 1
a3071 1
	| type_name %prec EMPTY
d3078 4
a3081 4
	  '*' nonempty_type_quals notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2, $3); }
	| '&' nonempty_type_quals notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2, $3); }
d3086 1
a3086 1
	| ptr_to_mem type_quals notype_declarator
d3094 4
a3097 4
	  '*' nonempty_type_quals notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2, $3); }
	| '&' nonempty_type_quals notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2, $3); }
d3102 1
a3102 1
	| ptr_to_mem type_quals notype_declarator
d3110 2
a3111 2
	  direct_notype_declarator maybe_parmlist type_quals  %prec '.'
		{ $$ = build_parse_node (CALL_EXPR, $$, $2, $3); }
d3119 1
a3119 1
		{ if (TREE_TYPE (OP0 ($$)) != current_class_type)
d3121 10
a3130 1
		      push_nested_class (TREE_TYPE (OP0 ($$)), 3);
d3137 1
a3137 1
	nested_name_specifier unqualified_id
d3140 3
d3146 1
a3146 1
	nested_name_specifier notype_unqualified_id
d3149 3
d3162 1
a3162 1
		{ $$ = build_functional_cast ($$, $3); }
d3164 3
a3166 3
		{ $$ = reparse_decl_as_expr ($$, $3); }
	| typespec fcast_or_absdcl %prec EMPTY
		{ $$ = reparse_absdcl_as_expr ($$, $2); }
d3171 2
a3172 1
	| template_type %prec EMPTY
d3185 19
a3203 1
		{ got_scope = TREE_TYPE ($$); }
d3205 5
a3209 1
		{ got_scope = $$; }
d3211 1
a3211 1
		{ got_scope = TREE_TYPE ($$); }
d3224 3
a3226 3
complete_type_name:
	  qualified_type_name
	| global_scope qualified_type_name
d3230 54
d3285 10
a3294 2
	  nested_type
	| global_scope qualified_type_name
d3306 1
a3306 1
   that got_scope will be set before yylex is called to get the next token. */
d3314 1
a3314 1
	  '*' type_quals new_declarator
d3316 1
a3316 1
	| '*' type_quals  %prec EMPTY
d3318 1
a3318 1
	| '&' type_quals new_declarator %prec EMPTY
d3320 1
a3320 1
	| '&' type_quals %prec EMPTY
d3322 1
a3322 1
	| ptr_to_mem type_quals %prec EMPTY
d3326 1
a3326 1
	| ptr_to_mem type_quals new_declarator
d3330 1
a3330 1
	| direct_new_declarator %prec EMPTY
d3343 2
a3344 2
	  '*' nonempty_type_quals absdcl
		{ $$ = make_pointer_declarator ($2, $3); }
d3347 3
a3349 3
	| '*' nonempty_type_quals  %prec EMPTY
		{ $$ = make_pointer_declarator ($2, NULL_TREE); }
	| '*' %prec EMPTY
d3351 2
a3352 2
	| '&' nonempty_type_quals absdcl
		{ $$ = make_reference_declarator ($2, $3); }
d3355 3
a3357 3
	| '&' nonempty_type_quals %prec EMPTY
		{ $$ = make_reference_declarator ($2, NULL_TREE); }
	| '&' %prec EMPTY
d3359 1
a3359 1
	| ptr_to_mem type_quals %prec EMPTY
d3363 1
a3363 1
	| ptr_to_mem type_quals absdcl
d3367 1
a3367 1
	| direct_abstract_declarator %prec EMPTY
d3376 4
a3379 4
	| direct_abstract_declarator '(' parmlist ')' type_quals  %prec '.'
		{ $$ = build_parse_node (CALL_EXPR, $$, $3, $5); }
	| direct_abstract_declarator LEFT_RIGHT type_quals  %prec '.'
		{ $$ = build_parse_node (CALL_EXPR, $$, empty_parms (), $3); }
d3384 6
a3389 6
	| '(' complex_parmlist ')' type_quals  %prec '.'
		{ $$ = build_parse_node (CALL_EXPR, NULL_TREE, $2, $4); }
	| regcast_or_absdcl type_quals %prec '.'
		{ TREE_OPERAND ($$, 2) = $2; }
	| fcast_or_absdcl type_quals %prec '.'
		{ TREE_OPERAND ($$, 2) = $2; }
d3407 2
a3408 1
errstmt:  error ';'
d3415 3
a3417 6
.pushlevel:  /* empty */
		{ emit_line_note (input_filename, lineno);
		  pushlevel (0);
		  clear_last_expr ();
		  push_momentary ();
		  expand_start_bindings (0); }
d3420 3
a3422 4
.poplevel:   /* empty */
		{ expand_end_bindings (getdecls (), kept_level_p (), 1);
		  $$ = poplevel (kept_level_p (), 1, 0);
		  pop_momentary (); }
d3459 19
a3477 2
compstmt: '{' .pushlevel compstmtend .poplevel
		{ $$ = $4; }
d3482 9
a3490 1
		{ cond_stmt_keyword = "if"; }
d3492 18
a3509 2
		{ emit_line_note (input_filename, lineno);
		  expand_start_cond ($4, 0); }
d3511 8
d3524 18
a3541 2
	| .pushlevel simple_stmt .poplevel
		{ $$ = $3; }
d3556 10
a3565 7
		  emit_line_note (input_filename, lineno);
		  /* Do default conversion if safe and possibly important,
		     in case within ({...}).  */
		  if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE
		       && lvalue_p (expr))
		      || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)
		    expr = default_conversion (expr);
d3570 1
a3570 1
		{ expand_start_else (); }
d3572 10
a3581 1
		{ expand_end_cond (); }
d3584 3
a3586 5
	| simple_if %prec IF
		{ expand_end_cond ();
		  expand_end_bindings (getdecls (), kept_level_p (), 1);
		  poplevel (kept_level_p (), 1, 0);
		  pop_momentary ();
d3589 14
a3602 4
		{ emit_nop ();
		  emit_line_note (input_filename, lineno);
		  expand_start_loop (1);
		  cond_stmt_keyword = "while"; }
d3604 18
a3621 1
		{ expand_exit_loop_if_false (0, $4); }
d3623 11
a3633 2
		{ expand_end_loop ();
		  finish_stmt (); }
d3635 13
a3647 3
		{ emit_nop ();
		  emit_line_note (input_filename, lineno);
		  expand_start_loop_continue_elsewhere (1); }
d3649 13
a3661 2
		{ expand_loop_continue_here ();
		  cond_stmt_keyword = "do"; }
d3663 9
a3671 3
		{ emit_line_note (input_filename, lineno);
		  expand_exit_loop_if_false (0, $6);
		  expand_end_loop ();
d3673 2
a3674 1
		  finish_stmt (); }
d3676 8
a3683 1
		{ emit_line_note (input_filename, lineno);
d3695 17
a3711 3
		{ emit_nop ();
		  emit_line_note (input_filename, lineno);
		  expand_start_loop_continue_elsewhere (1); }
d3713 18
a3730 2
		{ emit_line_note (input_filename, lineno);
		  if ($7) expand_exit_loop_if_false (0, $7); }
d3734 5
a3738 1
		{ push_momentary (); }
d3740 14
a3753 3
		{ emit_line_note (input_filename, lineno);
		  expand_loop_continue_here ();
		  if ($10) cplus_expand_expr_stmt ($10);
a3754 1
		  expand_end_loop ();
d3757 1
a3757 3
		      expand_end_bindings (getdecls (), kept_level_p (), 1);
		      poplevel (kept_level_p (), 1, 0);
		      pop_momentary ();
d3761 11
a3771 2
		{ emit_line_note (input_filename, lineno);
		  c_expand_start_case ($4);
d3775 2
a3776 1
		  push_momentary (); }
d3778 9
a3786 1
		{ expand_end_case ($4);
d3788 2
a3789 1
		  pop_switch (); }
d3793 1
a3793 23
		{ register tree value = check_cp_case_value ($2);
		  register tree label
		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);

		  if (value != error_mark_node)
		    {
		      tree duplicate;
		      int success = pushcase (value, convert_and_check,
					      label, &duplicate);
		      if (success == 1)
			cp_error ("case label `%E' not within a switch statement", $2);
		      else if (success == 2)
			{
			  cp_error ("duplicate case value `%E'", $2);
			  cp_error_at ("previously used here", duplicate);
			}
		      else if (success == 3)
			warning ("case value out of range");
		      else if (success == 5)
			cp_error ("case label `%E' within scope of cleanup or variable array", $2);
		    }
		  define_case_label (label);
		}
d3796 1
a3796 30
		{ register tree value1 = check_cp_case_value ($2);
		  register tree value2 = check_cp_case_value ($4);
		  register tree label
		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);

		  if (pedantic)
		    pedwarn ("ANSI C++ forbids range expressions in switch statement");
		  if (value1 != error_mark_node
		      && value2 != error_mark_node)
		    {
		      tree duplicate;
		      int success = pushcase_range (value1, value2,
						    convert_and_check, label,
						    &duplicate);
		      if (success == 1)
			error ("case label not within a switch statement");
		      else if (success == 2)
			{
			  error ("duplicate (or overlapping) case value");
			  error_with_decl (duplicate, "this is the first entry overlapping that value");
			}
		      else if (success == 3)
			warning ("case value out of range");
		      else if (success == 4)
			warning ("empty range specified");
		      else if (success == 5)
			error ("case label within scope of cleanup or variable array");
		    }
		  define_case_label (label);
		}
d3799 1
a3799 14
		{
		  tree duplicate;
		  register tree label
		    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);
		  int success = pushcase (NULL_TREE, 0, label, &duplicate);
		  if (success == 1)
		    error ("default label not within a switch statement");
		  else if (success == 2)
		    {
		      error ("multiple default labels in one switch");
		      error_with_decl (duplicate, "this is the first default label");
		    }
		  define_case_label (NULL_TREE);
		}
d3803 3
a3805 1
		  if ( ! expand_exit_something ())
d3809 3
a3811 1
		  if (! expand_continue_loop (0))
d3821 1
a3821 1
	| asm_keyword maybe_type_qual '(' string ')' ';'
d3828 1
a3828 1
	| asm_keyword maybe_type_qual '(' string ':' asm_operands ')' ';'
d3837 1
a3837 1
	| asm_keyword maybe_type_qual '(' string ':' asm_operands ':' asm_operands ')' ';'
d3846 1
a3846 1
	| asm_keyword maybe_type_qual '(' string ':' asm_operands ':'
d3856 7
a3862 2
		{ emit_line_note (input_filename, lineno);
		  expand_computed_goto ($3); }
d3864 12
a3875 5
		{ tree decl;
		  emit_line_note (input_filename, lineno);
		  decl = lookup_label ($2);
		  TREE_USED (decl) = 1;
		  expand_goto (decl); }
d3894 2
a3895 3
	  ctor_initializer_opt compstmt_or_error
		{ expand_end_try_stmts ();
		  expand_start_all_catch (); }
d3898 2
d3901 1
a3901 1
		  finish_function (lineno, (int)$3, 0);
d3907 13
a3919 1
		{ expand_start_try_stmts (); }
d3921 10
a3930 2
		{ expand_end_try_stmts ();
		  expand_start_all_catch (); }
d3932 10
a3941 1
		{ expand_end_all_catch (); }
d3945 23
a3967 5
	  /* empty */
	| handler_seq CATCH .pushlevel
		{ dont_allow_type_definitions = "inside exception declarations"; }
	  handler_args
		{ dont_allow_type_definitions = 0; }
d3969 10
a3978 1
		{ expand_end_catch_block (); }
d3983 2
a3984 2
	  typed_typespecs %prec EMPTY
	| nonempty_type_quals %prec EMPTY
d3992 2
a3993 1
		{ expand_start_catch_block ($2, $3); }
d3995 2
a3996 1
		{ expand_start_catch_block ($2, NULL_TREE); }
d3998 2
a3999 1
		{ expand_start_catch_block ($2, $3); }
d4001 3
a4003 2
		{ expand_start_catch_block ($2, $3); }
	This allows reference parameters... */
d4005 3
a4007 2
		{ expand_start_catch_block (TREE_PURPOSE ($2),
					    TREE_VALUE ($2)); }
d4015 1
a4015 1
		  if (label)
d4022 2
d4031 3
d4038 2
a4039 2
maybe_type_qual:
	/* empty */
d4042 1
a4042 1
	| TYPE_QUAL
d4047 1
a4047 1
	/* empty */
d4056 2
a4057 1
asm_operands: /* empty */
d4086 2
a4087 1
parmlist:  /* empty */
d4089 1
a4089 4
		  if (strict_prototype)
		    $$ = void_list_node;
		  else
		    $$ = NULL_TREE;
d4093 3
a4095 2
		{ $$ = tree_cons (NULL_TREE, $$, void_list_node);
		  TREE_PARMLIST ($$) = 1; }
d4117 1
a4117 1
		  $$ = build_tree_list (NULL_TREE, $$); 
a4121 3
		  /* ARM $8.2.5 has this as a boxed-off comment.  */
		  if (pedantic)
		    warning ("use of `...' without a first argument is non-portable");
d4134 1
a4134 1
		  $$ = build_tree_list (NULL_TREE, $$);
d4154 1
a4154 1
		  $$ = tree_cons (NULL_TREE, $$, void_list_node);
d4161 13
d4177 5
a4181 3
		{ $$ = build_tree_list (NULL_TREE, $$); }
	| parm '=' init
		{ $$ = build_tree_list ($3, $$); }
d4183 2
a4184 1
		{ $$ = chainon ($$, $2); }
d4194 2
a4195 1
		{ $$ = build_tree_list (NULL_TREE, $$); }
d4199 1
a4199 3
   as found in a parmlist.  The first four cases make up for 10%
   of the time spent parsing C++.  We cannot use them because
   of `int id[]' which won't get parsed properly.  */
a4200 14
/*
	  typed_declspecs dont_see_typename '*' IDENTIFIER
		{ tree specs = strip_attrs ($1);
		  $$ = build_tree_list (specs, build_parse_node (INDIRECT_REF, $4));
		  see_typename (); }
	| typed_declspecs dont_see_typename '&' IDENTIFIER
		{ tree specs = strip_attrs ($1);
		  $$ = build_tree_list (specs, build_parse_node (ADDR_EXPR, $4));
		  see_typename (); }
	| TYPENAME IDENTIFIER
		{ $$ = build_tree_list (get_decl_list ($$), $2);  }
	| TYPESPEC IDENTIFIER
		{ $$ = build_tree_list (get_decl_list ($$), $2); }
	| */
d4204 3
a4206 2
		{ tree specs = strip_attrs ($1);
		  $$ = build_tree_list (specs, $2); }
d4208 2
a4209 1
		{ $$ = build_tree_list ($$, $2); }
d4211 2
a4212 1
		{ $$ = build_tree_list (get_decl_list ($$), $2); }
d4214 7
a4220 5
		{ tree specs = strip_attrs ($1);
		  $$ = build_tree_list (specs, $2); }
	| typed_declspecs1 %prec EMPTY
		{ tree specs = strip_attrs ($1);
		  $$ = build_tree_list (specs, NULL_TREE); }
d4223 2
a4224 1
		  $$ = build_tree_list (specs, $2); }
d4228 6
a4233 2
	  parm maybe_init
		{ $$ = build_tree_list ($2, $$); }
d4237 1
a4237 1
	named_parm
d4241 3
a4243 2
see_typename: %prec EMPTY
	{ see_typename (); }
a4245 18
/* 
dont_see_typename: %prec EMPTY
	{ dont_see_typename (); }
	; 

try_for_typename:
        {
	  if ($<ttype>-1 == error_mark_node)
            $$ = 0;
          else
            {
              $$ = 1;
              pushclass ($<ttype>-1, 1);
            }
        }
	;
*/

d4255 3
d4263 1
a4263 1
	  %prec EMPTY /* empty */
d4265 1
a4265 1
	| THROW '(' ansi_raise_identifiers  ')' %prec EMPTY
d4267 1
a4267 1
	| THROW LEFT_RIGHT %prec EMPTY
d4273 1
a4273 1
		{ $$ = build_decl_list (NULL_TREE, groktypename($$)); }
d4286 1
a4286 1
	  /* empty */ %prec EMPTY
d4288 1
a4288 1
	| '*' type_quals conversion_declarator
d4290 1
a4290 1
	| '&' type_quals conversion_declarator
d4292 1
a4292 1
	| ptr_to_mem type_quals conversion_declarator
d4298 2
a4299 1
operator: OPERATOR
d4362 1
a4362 1
	| operator NEW %prec EMPTY
d4364 1
a4364 1
	| operator DELETE %prec EMPTY
d4372 1
a4372 1
		{ $$ = grokoptypename ($2, $3); }
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
   Copyright (C) 1988, 89, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.
a43 1
#include "except.h"
a57 1
extern tree last_tree;
d63 2
a74 2
static tree empty_parms PROTO((void));

d79 2
d90 1
a90 2
  if (strict_prototype
      || current_class_type != NULL)
d100 1
a100 1
%union {long itype; tree ttype; char *strtype; enum tree_code code; flagged_type_tree ftype; }
a109 4
%token SELFNAME

/* A template function.  */
%token PFUNCNAME
d121 1
a121 1
%token CV_QUALIFIER
d135 1
a135 1
/* SCO include files test "ASM", so use something else.  */
a139 1
%token REALPART IMAGPART
d143 2
a144 2
%token <ttype> VISSPEC
%token DELETE NEW THIS OPERATOR CXX_TRUE CXX_FALSE
d162 1
a162 1
%left IDENTIFIER PFUNCNAME TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD
d193 1
a193 2
%type <ttype> PFUNCNAME
%type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME
d195 4
a198 4
%type <ttype> reserved_declspecs boolean.literal
%type <ttype> reserved_typespecquals
%type <ttype> declmods 
%type <ttype> SCSPEC TYPESPEC CV_QUALIFIER maybe_cv_qualifier
d200 1
a200 1
%type <ttype> init initlist maybeasm maybe_init defarg defarg1
d210 1
a210 1
%type <ttype> opt.component_decl_list component_decl_list
d212 1
a212 1
%type <ttype> component_declarator component_declarator0 self_reference
d216 1
a216 1
%type <ttype> absdcl cv_qualifiers
d218 2
a219 2
%type <ttype> new_declarator direct_new_declarator
%type <ttype> xexpr parmlist parms bad_parm 
a223 1
%type <ttype> template_id object_template_id notype_template_declarator
d226 1
a226 5
%type <ttype> complex_parmlist parms_comma

%type <ftype> type_id new_type_id typed_typespecs typespec typed_declspecs
%type <ftype> typed_declspecs1 type_specifier_seq nonempty_cv_qualifiers
%type <ftype> structsp typespecqual_reserved parm named_parm full_parm
d231 3
a233 3
%token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER
%type <ttype> fn.def1 /* Not really! */ component_constructor_declarator
%type <ttype> fn.def2 return_id fn.defpen constructor_declarator
d239 1
a239 1
%type <ttype> base_class_access_list
a249 1
%type <code>  template_close_bracket
d251 4
d257 1
a257 1
%type <ttype> complete_type_name notype_identifier nonnested_type
d260 1
a260 1
%type <ttype> new_initializer new_placement
d262 2
a263 2
%type <ttype> typename_sub typename_sub0 typename_sub1 typename_sub2
/* in order to recognize aggr tags as defining and thus shadowing.  */
d265 1
a265 1
%type <ttype> named_class_head_sans_basetype_defn
a267 2
%type <ttype> self_template_type

d274 1
a274 1
/* lex.c and pt.c depend on this being the last token.  Define
d280 1
a280 1
static tree current_declspecs = NULL_TREE;
d286 1
a286 1
static tree prefix_attributes = NULL_TREE;
d294 1
a294 1
extern void yyprint			PROTO((FILE *, int, YYSTYPE));
d299 1
a299 2
program:
	  /* empty */
d312 1
a312 1
 can find a valid list of type and sc specs in $0.  */
d315 1
a315 2
		{ $<ttype>$ = NULL_TREE; }
	  lang_extdef
a334 6
extension:
	EXTENSION
		{ $<itype>$ = pedantic;
		  pedantic = 0; }
	;

d341 1
a341 1
		{ if (pending_lang_change) do_pending_lang_change(); }
d343 2
a344 2
		{ if (! toplevel_bindings_p () && ! pseudo_global_level_p())
		  pop_everything (); }
d348 1
a348 1
	  fndef eat_saved_input
d354 1
d360 1
a360 1
	| extern_lang_string .hush_warning fndef .warning_ok eat_saved_input
d379 1
a379 7
		{
		  if (TREE_CODE ($3) == IDENTIFIER_NODE)
		    $3 = lastiddecl;
		  do_using_directive ($3);
		}
	| extension extdef
		{ pedantic = $<itype>1; }
a413 3
	| TEMPLATE '<' '>'
                { begin_specialization(); 
		  $$ = NULL_TREE; }
d431 1
a431 4
		    {
		      pedwarn ("template type parameters must use the keyword `class'");
		      TREE_PURPOSE ($$) = class_type_node;
		    }
d450 9
a458 7
		{ $$ = build_tree_list (NULL_TREE, $1); }
	| template_type_parm '=' type_id
		{ $$ = build_tree_list (groktypename ($3.t), $1); }
	| parm
		{ $$ = build_tree_list (NULL_TREE, $1.t); }
	| parm '=' expr_no_commas  %prec ARITHCOMPARE
		{ $$ = build_tree_list ($3, $1.t); }
d461 6
d468 94
a561 16
	  template_header
	  extdef
                { 
                  if ($1) 
                    end_template_decl (); 
		  else
		    end_specialization ();
		}
	| template_header
	  error  %prec EMPTY
		{ 
                  if ($1) 
                    end_template_decl ();
		  else
		    end_specialization (); 
                }
d569 8
d579 10
a588 1
		  note_list_got_semicolon ($1.t);
d591 1
a591 1
		{ pedwarn ("empty declaration"); }
d594 19
a612 6
		{
		  tree t, attrs;
		  split_specs_attrs ($1.t, &t, &attrs);
		  shadow_tag (t);
		  note_list_got_semicolon ($1.t);
		}
a637 9
		{ finish_function (lineno, (int)$3, 0); }
	| fn.def1 maybe_return_init function_try_block
		{ }
	| fn.def1 maybe_return_init error
		{ }
	;

constructor_declarator:
	  nested_name_specifier SELFNAME '(' 
d639 2
a640 6
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
d642 1
a642 3
	  parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }
	| nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
d644 1
a644 70
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $4, $5);
		}
	| global_scope nested_name_specifier SELFNAME '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	 parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }
	| global_scope nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $5, $6);
		}
	| nested_name_specifier self_template_type '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	  parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }
	| nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $4, $5);
		}
	| global_scope nested_name_specifier self_template_type '(' 
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
	 parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }
	| global_scope nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{
		  $$ = build_parse_node (SCOPE_REF, $2, $3);
		  if ($2 != current_class_type)
		    {
		      push_nested_class ($2, 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		  $$ = make_call_declarator ($$, empty_parms (), $5, $6);
d646 7
d656 1
a656 8
	  typed_declspecs declarator
		{ tree specs, attrs;
		  split_specs_attrs ($1.t, &specs, &attrs);
		  if (! start_function (specs, $2, attrs, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	| declmods notype_declarator
d659 1
a659 1
		  if (! start_function (specs, $2, attrs, 0))
d663 3
a665 2
	| notype_declarator
		{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))
d669 2
a670 4
	| declmods constructor_declarator
		{ tree specs, attrs;
		  split_specs_attrs ($1, &specs, &attrs);
		  if (! start_function (specs, $2, attrs, 0))
d674 4
a677 16
	| constructor_declarator
		{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))
		    YYERROR1;
		  reinit_parse_for_function ();
		  $$ = NULL_TREE; }
	;

component_constructor_declarator:
	  SELFNAME '(' parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, $3, $5, $6); }
	| SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }
	| self_template_type '(' parmlist ')' cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, $3, $5, $6); }
	| self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt
		{ $$ = make_call_declarator ($1, empty_parms (), $3, $4); }
d683 1
a683 1
	  declmods component_constructor_declarator
d685 2
a686 1
		  $$ = start_method (specs, $2);
d693 8
a700 6
	| component_constructor_declarator
		{ $$ = start_method (NULL_TREE, $1); goto rest_of_mdef; }
	| typed_declspecs declarator
		{ tree specs = strip_attrs ($1.t);
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| declmods notype_declarator
d702 2
a703 4
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| notype_declarator
		{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }
	| declmods constructor_declarator
d705 3
a707 24
		  $$ = start_method (specs, $2); goto rest_of_mdef; }
	| constructor_declarator
		{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }
        | template_header fn.def2 
                { 
                  if ($1)
                    end_template_decl (); 
		  else
		    end_specialization ();

		  if ($2 && DECL_TEMPLATE_INFO ($2)
		      && !DECL_TEMPLATE_SPECIALIZATION ($2))
		    {
		      $$ = DECL_TI_TEMPLATE ($2); 
		      check_member_template ($$);
		    }
		  else if ($2)
		    $$ = $2;
		  else 
		    {
		      cp_error("invalid member template declaration");
		      $$ = NULL_TREE;
		    }
		}
d710 1
a710 2
return_id:
	  RETURN IDENTIFIER
d718 1
a718 2
return_init:
	  return_id maybe_init
d733 1
a733 1
		     pair of curly braces of a function.  These are needed
d740 1
a740 1
	  /* empty */
d768 1
a768 2
member_init:
	  '(' nonnull_exprlist ')'
d770 1
a770 1
		  if (current_class_name)
d772 1
a772 1
		  expand_member_init (current_class_ref, NULL_TREE, $2);
d776 1
a776 1
		  if (current_class_name)
d778 1
a778 1
		  expand_member_init (current_class_ref, NULL_TREE, void_type_node);
d781 1
a781 1
		{ expand_member_init (current_class_ref, $1, $3); }
d783 14
a796 11
		{ expand_member_init (current_class_ref, $1, void_type_node); }
	| nonnested_type '(' nonnull_exprlist ')'
		{ expand_member_init (current_class_ref, $1, $3); }
	| nonnested_type LEFT_RIGHT
		{ expand_member_init (current_class_ref, $1, void_type_node); }
	| typename_sub '(' nonnull_exprlist ')'
		{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),
				      $3); }
	| typename_sub LEFT_RIGHT
		{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),
				      void_type_node); }
a801 1
	| SELFNAME
d809 1
a809 1
	| NSNAME  %prec EMPTY
d819 2
a820 3
	  TEMPLATE typespec ';'
		{ do_type_instantiation ($2.t, NULL_TREE);
		  yyungetc (';', 1); }
d822 2
a823 2
		{ tree specs = strip_attrs ($2.t);
		  do_decl_instantiation (specs, $3, NULL_TREE); }
d825 3
a827 6
		{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }
	| TEMPLATE constructor_declarator
		{ do_decl_instantiation (NULL_TREE, $2, NULL_TREE); }
	| SCSPEC TEMPLATE typespec ';'
		{ do_type_instantiation ($3.t, $1);
		  yyungetc (';', 1); }
d829 2
a830 2
		{ tree specs = strip_attrs ($3.t);
		  do_decl_instantiation (specs, $4, $1); }
d832 1
a832 3
		{ do_decl_instantiation (NULL_TREE, $3, $1); }
	| SCSPEC TEMPLATE constructor_declarator
		{ do_decl_instantiation (NULL_TREE, $3, $1); }
a834 4
/* The TYPENAME expansions are to deal with use of a template class name as
  a template within the class itself, where the template decl is hidden by
  a type decl.  Got all that?  */

d836 2
a837 25
	  PTYPENAME '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| PTYPENAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| TYPENAME  '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| TYPENAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| self_template_type
d840 7
a846 13
self_template_type:
	  SELFNAME  '<' template_arg_list template_close_bracket
		{
		  $$ = lookup_template_class ($1, $3, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
	| SELFNAME '<' template_close_bracket
		{
		  $$ = lookup_template_class ($1, NULL_TREE, NULL_TREE);
		  if ($$ != error_mark_node)
		    $$ = TYPE_STUB_DECL ($$);
		}
d849 3
a851 8
template_close_bracket:
	  '>'
	| RSHIFT 
		{
		  /* Handle `Class<Class<Type>>' without space in the `>>' */
		  pedwarn ("`>>' should be `> >' in template class name");
		  yyungetc ('>', 1);
		}
d863 54
a916 2
		{ $$ = groktypename ($1.t); }
	| expr_no_commas  %prec ARITHCOMPARE
d919 15
a933 2
unop:
	  '-'
d945 1
a945 2
expr:
	  nontrivial_exprlist
d969 1
a969 1
	  /* empty */
d978 1
a978 1
	  type_specifier_seq declarator maybeasm maybe_attribute '='
d990 4
a993 4
		  current_declspecs = $1.t;
		  $<itype>5 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>2, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $4,
d996 1
a996 1
	  init
d998 3
a1000 3
		  cp_finish_decl ($<ttype>6, $7, $4, 1, LOOKUP_ONLYCONVERTING);
		  resume_momentary ($<itype>5);
		  $$ = $<ttype>6; 
d1015 2
a1016 19
	  '{'
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      COMPOUND_STMT_NO_SCOPE ($<ttype>$) = 1;
		      add_tree ($<ttype>$);
		    }
		}
	  compstmtend
		{ 
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  finish_stmt (); 
		}
d1023 2
a1024 2
		{ $$ = expr_tree_cons (NULL_TREE, $$, 
		                  build_expr_list (NULL_TREE, $3)); }
d1026 2
a1027 2
		{ $$ = expr_tree_cons (NULL_TREE, $$, 
		                  build_expr_list (NULL_TREE, error_mark_node)); }
d1029 1
a1029 1
		{ chainon ($$, build_expr_list (NULL_TREE, $3)); }
d1031 1
a1031 1
		{ chainon ($$, build_expr_list (NULL_TREE, error_mark_node)); }
d1036 1
a1036 1
		{ $$ = build_expr_list (NULL_TREE, $$); }
d1041 7
a1047 2
	  primary  %prec UNARY
		{ $$ = $1; }
d1049 5
a1053 2
	| extension cast_expr  	  %prec UNARY
		{ $$ = $2;
a1069 2
		  if (pedantic)
		    pedwarn ("ANSI C++ forbids `&&'");
d1080 21
a1100 1
		{ $$ = expr_sizeof ($2); }
d1102 1
a1102 1
		{ $$ = c_sizeof (groktypename ($3.t)); }
d1106 1
a1106 2
		{ $$ = c_alignof (groktypename ($3.t)); 
		  check_for_new_type ("alignof", $3); }
d1110 2
a1111 3
	| new new_type_id  %prec EMPTY
		{ $$ = build_new (NULL_TREE, $2.t, NULL_TREE, $1); 
		  check_for_new_type ("new", $2); }
d1113 3
a1115 5
		{ $$ = build_new (NULL_TREE, $2.t, $3, $1); 
		  check_for_new_type ("new", $2); }
	| new new_placement new_type_id  %prec EMPTY
		{ $$ = build_new ($2, $3.t, NULL_TREE, $1); 
		  check_for_new_type ("new", $3); }
d1117 4
a1120 6
		{ $$ = build_new ($2, $3.t, $4, $1); 
		  check_for_new_type ("new", $3); }
	| new '(' type_id ')'  %prec EMPTY
		{ $$ = build_new (NULL_TREE, groktypename($3.t),
				  NULL_TREE, $1); 
		  check_for_new_type ("new", $3); }
d1122 3
a1124 5
		{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); 
		  check_for_new_type ("new", $3); }
	| new new_placement '(' type_id ')'  %prec EMPTY
		{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); 
		  check_for_new_type ("new", $4); }
d1126 1
a1126 2
		{ $$ = build_new ($2, groktypename($4.t), $6, $1); 
		  check_for_new_type ("new", $4); }
d1134 1
a1134 1
	| delete '[' expr ']' cast_expr  %prec UNARY
a1137 4
	| REALPART cast_expr %prec UNARY
		{ $$ = build_x_unary_op (REALPART_EXPR, $2); }
	| IMAGPART cast_expr %prec UNARY
		{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }
d1157 1
a1157 1
		  cp_error ("`%T' is not a valid expression", $2.t);
d1173 9
a1181 10
	  '(' type_id ')'  %prec EMPTY
		{ $2.t = tree_cons (NULL_TREE, $2.t, void_list_node);
		  TREE_PARMLIST ($2.t) = 1;
		  $$ = make_call_declarator (NULL_TREE, $2.t, NULL_TREE, NULL_TREE);
		  check_for_new_type ("cast", $2); }
	| regcast_or_absdcl '(' type_id ')'  %prec EMPTY
		{ $3.t = tree_cons (NULL_TREE, $3.t, void_list_node);
		  TREE_PARMLIST ($3.t) = 1;
		  $$ = make_call_declarator ($$, $3.t, NULL_TREE, NULL_TREE);
		  check_for_new_type ("cast", $3); }
d1245 2
a1246 3
		{ $$ = build_x_modify_expr ($$, NOP_EXPR, $3);
		  if ($$ != error_mark_node)
                    C_SET_EXP_ORIGINAL_CODE ($$, MODIFY_EXPR); }
d1248 6
a1253 1
		{ $$ = build_x_modify_expr ($$, $2, $3); }
d1261 1
a1261 1
	| object '&' expr_no_commas  %prec UNARY
d1266 2
a1267 2
		{ tree type = groktypename ($3.t);
		  $$ = build_m_component_ref ($$, build_c_cast (type, $5)); }
a1275 1
        | template_id
d1279 1
a1279 1
	| NSNAME  %prec EMPTY
a1281 22
template_id:
        PFUNCNAME '<' template_arg_list template_close_bracket 
                { $$ = lookup_template_function ($1, $3); }
        | PFUNCNAME '<' template_close_bracket
                { $$ = lookup_template_function ($1, NULL_TREE); }
        | operator_name '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function 
		    (do_identifier ($1, 1), $3); }
        | operator_name '<' template_close_bracket
                { $$ = lookup_template_function 
		    (do_identifier ($1, 1), NULL_TREE); }
	;

object_template_id:
        TEMPLATE identifier '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($2, $4); }
        | TEMPLATE PFUNCNAME '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function (DECL_NAME ($2), $4); }
        | TEMPLATE operator_name '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function (DECL_NAME ($2), $4); }
        ;

a1284 1
	| SELFNAME
d1289 1
a1289 1
	| '*' expr_or_declarator  %prec UNARY
d1291 1
a1291 1
	| '&' expr_or_declarator  %prec UNARY
a1296 7
notype_template_declarator:
	  IDENTIFIER '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($1, $3); }
	| NSNAME '<' template_arg_list template_close_bracket
                { $$ = lookup_template_function ($1, $3); }
	;
		
a1299 1
	| notype_template_declarator
d1309 14
a1322 2
		  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)
		    $$ = do_identifier ($$, 1);
d1327 1
a1327 7
		{
		  if (processing_template_decl)
		    push_obstacks (&permanent_obstack, &permanent_obstack);
		  $$ = combine_strings ($$);
		  if (processing_template_decl)
		    pop_obstacks ();
		}
d1334 1
a1334 1
                    /* This inhibits warnings in truthvalue_conversion.  */
d1342 1
a1342 1
                    /* This inhibits warnings in truthvalue_conversion.  */
d1376 10
a1385 5
                {
                  $$ = build_x_function_call ($1, $3, current_class_ref); 
                  if (TREE_CODE ($$) == CALL_EXPR
                      && TREE_TYPE ($$) != void_type_node)
	            $$ = require_complete_type ($$);
d1389 1
a1389 1
		  $$ = build_x_function_call ($$, NULL_TREE, current_class_ref);
d1411 1
a1411 1
		{ if (current_class_ptr)
d1414 1
a1414 1
		      TREE_USED (current_class_ptr) = 1;
d1416 1
a1416 1
		      $$ = current_class_ptr;
d1433 1
a1433 1
	| CV_QUALIFIER '(' nonnull_exprlist ')'
d1474 1
a1474 1
		      $$ = build_c_cast (type, build_compound_expr ($3));
d1478 28
a1505 16
	| DYNAMIC_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("dynamic_cast", $3);
		  $$ = build_dynamic_cast (type, $6); }
	| STATIC_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("static_cast", $3);
		  $$ = build_static_cast (type, $6); }
	| REINTERPRET_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("reinterpret_cast", $3);
		  $$ = build_reinterpret_cast (type, $6); }
	| CONST_CAST '<' type_id '>' '(' expr ')'
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("const_cast", $3);
		  $$ = build_const_cast (type, $6); }
d1507 1
a1507 1
		{ $$ = build_x_typeid ($3); }
d1509 1
a1509 2
		{ tree type = groktypename ($3.t);
		  check_for_new_type ("typeid", $3);
d1512 38
a1549 1
		{ $$ = do_scoped_id ($2, 1); }
d1554 2
a1555 3
		    $$ = do_scoped_id ($2, 1);
		  else
		    $$ = $2;
d1557 1
a1557 1
	| overqualified_id  %prec HYPERUNARY
d1560 1
a1560 4
		{ if (processing_template_decl)
		    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, NULL_TREE);
		  else
		    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }
d1562 1
a1562 19
		{ if (processing_template_decl)
		    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), 
				       NULL_TREE, NULL_TREE);
		  else
		    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }
        | object object_template_id %prec UNARY
                { 
		  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); 
		}
        | object object_template_id '(' nonnull_exprlist ')'
                {
		  $$ = build_method_call ($1, $2, $4, 
					  NULL_TREE, LOOKUP_NORMAL); 
                }
	| object object_template_id LEFT_RIGHT
                {
		  $$ = build_method_call ($1, $2, NULL_TREE,
					  NULL_TREE, LOOKUP_NORMAL); 
                }
d1564 5
a1568 6
		{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }
	| object overqualified_id  %prec UNARY
		{ if (processing_template_decl)
		    $$ = build_min_nt (COMPONENT_REF, $1, copy_to_permanent ($2));
		  else
		    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }
d1571 1
d1575 2
a1576 2
		     in build_component_ref entirely yet, we cannot do this.  */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, current_class_ref);
d1582 1
a1582 1
					  LOOKUP_NORMAL);
d1587 1
d1591 2
a1592 2
		     in build_component_ref entirely yet, we cannot do this.  */
		  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, current_class_ref);
d1598 1
a1598 1
					  LOOKUP_NORMAL);
d1603 2
a1604 1
		  if (IS_SIGNATURE (OP0 ($2)))
d1608 1
a1608 1
					      LOOKUP_NORMAL);
d1615 2
a1616 1
		  if (IS_SIGNATURE (OP0 ($2)))
d1620 1
a1620 1
					      LOOKUP_NORMAL);
d1628 1
d1633 1
a1633 1
		  $$ = cp_convert (void_type_node, $1);
d1637 1
d1643 1
a1643 1
		  $$ = cp_convert (void_type_node, $1);
d1647 1
d1671 1
a1671 1
		{ $$ = build_x_function_call ($$, $3, current_class_ref); }
d1673 1
a1673 1
		{ $$ = build_x_function_call ($$, NULL_TREE, current_class_ref); }
d1690 1
a1690 2
new:
	  NEW
d1696 1
a1696 2
delete:
	  DELETE
d1723 1
a1723 1
		     pair of curly braces of a function.  These are needed
d1729 1
a1729 2
object:
	  primary '.'
d1739 22
a1760 1
	  typespec initdecls ';'
d1763 2
a1764 2
		  if ($1.t && IS_AGGR_TYPE_CODE (TREE_CODE ($1.t)))
		    note_got_semicolon ($1.t);
d1769 1
a1769 1
		  note_list_got_semicolon ($1.t);
d1775 2
a1776 2
		  shadow_tag ($1.t);
		  note_list_got_semicolon ($1.t);
a1779 2
	| extension decl
		{ pedantic = $<itype>1; }
d1786 2
a1787 2
	  after_type_declarator  %prec EMPTY
	| notype_declarator  %prec EMPTY
d1792 6
a1797 6
	  LEFT_RIGHT  %prec EMPTY
		{ $$ = make_call_declarator (NULL_TREE, empty_parms (),
					     NULL_TREE, NULL_TREE); }
	| fcast_or_absdcl LEFT_RIGHT  %prec EMPTY
		{ $$ = make_call_declarator ($$, empty_parms (), NULL_TREE,
					     NULL_TREE); }
d1803 3
a1805 5
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers absdcl
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
d1807 5
a1811 8
		{ $$.t = build_decl_list (get_decl_list ($1.t), $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| typed_typespecs  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE);
		  $$.new_type_flag = $1.new_type_flag;  }
	| nonempty_cv_qualifiers  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
d1820 1
a1820 1
	  typed_typespecs  %prec EMPTY
d1826 3
a1828 5
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1); 
		  $$.new_type_flag = $2.new_type_flag; }
	| typespec reserved_declspecs  %prec HYPERUNARY
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
d1830 1
a1830 2
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, chainon ($2, $3)); 
		  $$.new_type_flag = $1.new_type_flag; }
d1832 1
a1832 2
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); 
		  $$.new_type_flag = $2.new_type_flag; }
d1834 1
a1834 2
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1)); 
		  $$.new_type_flag = $2.new_type_flag; }
d1836 2
a1837 3
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t,
					 chainon ($3, chainon ($4, $1))); 
		  $$.new_type_flag = $2.new_type_flag; }
d1847 1
a1847 1
		{ $$ = decl_tree_cons (NULL_TREE, $2.t, $$); }
d1865 2
a1866 2
	  nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = $1.t; TREE_STATIC ($$) = 1; }
d1869 1
a1869 1
	| declmods CV_QUALIFIER
d1892 3
a1894 5
		{ $$.t = get_decl_list ($1.t); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers typespec
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, $1.t); 
		  $$.new_type_flag = $2.new_type_flag; }
d1896 3
a1898 5
		{ $$.t = decl_tree_cons (NULL_TREE, $1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| nonempty_cv_qualifiers typespec reserved_typespecquals
		{ $$.t = decl_tree_cons (NULL_TREE, $2.t, chainon ($3, $1.t)); 
		  $$.new_type_flag = $1.new_type_flag; }
d1903 1
a1903 1
		{ $$ = build_decl_list (NULL_TREE, $1.t); }
d1905 1
a1905 1
		{ $$ = decl_tree_cons (NULL_TREE, $2.t, $1); }
d1912 1
a1912 2
typespec:
	  structsp
a1913 1
		{ $$.t = $1; $$.new_type_flag = 0; }
a1914 1
		{ $$.t = $1; $$.new_type_flag = 0; }
d1916 3
a1918 2
		{ $$.t = TREE_TYPE ($3);
		  $$.new_type_flag = 0; }
d1920 3
a1922 2
		{ $$.t = groktypename ($3.t);
		  $$.new_type_flag = 0; }
a1925 1
                  $$.new_type_flag = 0;
d1929 1
a1929 1
		      $$.t = type;
d1934 1
a1934 1
		      $$.t = error_mark_node;
d1938 1
a1938 1
		{ tree type = groktypename ($3.t);
a1939 1
                  $$.new_type_flag = 0;
d1943 1
a1943 1
		      $$.t = type;
d1948 1
a1948 1
		      $$.t = error_mark_node;
d1955 2
a1956 5
typespecqual_reserved:
	  TYPESPEC
		{ $$.t = $1; $$.new_type_flag = 0; }
	| CV_QUALIFIER
		{ $$.t = $1; $$.new_type_flag = 0; }
d1983 1
a1983 1
	  declarator maybeasm maybe_attribute '='
d1986 1
a1986 2
		  if (current_declspecs
		      && TREE_CODE (current_declspecs) != TREE_LIST)
d1995 3
a1997 3
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
d2000 3
a2002 3
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| declarator maybeasm maybe_attribute
d2006 1
a2006 2
		  if (current_declspecs
		      && TREE_CODE (current_declspecs) != TREE_LIST)
d2016 3
a2018 3
		  d = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
d2022 3
a2024 3
	  declarator maybeasm maybe_attribute '='
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
d2027 5
a2031 5
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING); }
	| declarator maybeasm maybe_attribute
		{ $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes);
		  cp_finish_decl ($<ttype>$, NULL_TREE, $2, 1, 0); }
d2035 1
a2035 1
	  notype_declarator maybeasm maybe_attribute '='
d2038 3
a2040 3
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($<ttype>1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
d2043 3
a2045 3
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| notype_declarator maybeasm maybe_attribute
d2050 3
a2052 3
		  d = start_decl ($<ttype>1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
d2056 1
a2056 1
	  notype_declarator maybeasm maybe_attribute '='
d2059 3
a2061 3
		  $<itype>4 = suspend_momentary ();
		  $<ttype>$ = start_decl ($1, current_declspecs, 1);
		  cplus_decl_attributes ($<ttype>$, $3, prefix_attributes); }
d2064 3
a2066 3
		{ cp_finish_decl ($<ttype>5, $6, $2, 1, LOOKUP_ONLYCONVERTING);
		  $$ = $<itype>4; }
	| notype_declarator maybeasm maybe_attribute
d2071 3
a2073 3
		  d = start_decl ($1, current_declspecs, 0);
		  cplus_decl_attributes (d, $3, prefix_attributes);
		  cp_finish_decl (d, NULL_TREE, $2, 1, 0); }
d2077 1
a2077 1
   so that the header files compile.  */
d2079 1
a2079 1
	  /* empty */
d2105 1
a2105 1
	  /* empty */
d2124 1
a2124 1
	| CV_QUALIFIER
d2129 1
a2129 1
	  identifier
d2136 1
a2136 1
	  /* empty */  %prec EMPTY
a2140 3
/* If we are processing a template, we don't want to expand this
   initializer yet.  */

d2142 1
a2142 1
	  expr_no_commas  %prec '='
d2162 1
a2162 1
		{ $$ = expr_tree_cons (NULL_TREE, $3, $$); }
d2165 1
a2165 1
		{ $$ = build_expr_list ($2, $4); }
d2167 1
a2167 1
		{ $$ = expr_tree_cons ($4, $6, $$); }
d2169 1
a2169 1
		{ $$ = build_expr_list ($$, $3); }
d2171 1
a2171 42
		{ $$ = expr_tree_cons ($3, $5, $$); }
	;

fn.defpen:
	PRE_PARSED_FUNCTION_DECL
		{ start_function (NULL_TREE, TREE_VALUE ($1),
				  NULL_TREE, 1);
		  reinit_parse_for_function (); }

pending_inline:
	  fn.defpen maybe_return_init ctor_initializer_opt compstmt_or_error
		{
		  int nested = (hack_decl_function_context
				(current_function_decl) != NULL_TREE);
		  finish_function (lineno, (int)$3, nested);
		  process_next_inline ($1);
		}
	| fn.defpen maybe_return_init function_try_block
		{ process_next_inline ($1); }
	| fn.defpen maybe_return_init error
		{ process_next_inline ($1); }
	;

pending_inlines:
	/* empty */
	| pending_inlines pending_inline eat_saved_input
	;

/* A regurgitated default argument.  The value of DEFARG_MARKER will be
   the TREE_LIST node for the parameter in question.  */
defarg_again:
	DEFARG_MARKER expr_no_commas END_OF_SAVED_INPUT
		{ replace_defarg ($1, $2); }
	| DEFARG_MARKER error END_OF_SAVED_INPUT
		{ replace_defarg ($1, error_mark_node); }

pending_defargs:
	  /* empty */ %prec EMPTY
	| pending_defargs defarg_again
		{ do_pending_defargs (); }
	| pending_defargs error
		{ do_pending_defargs (); }
d2177 1
a2177 1
		  $<ttype>$ = start_enum ($2); }
d2179 1
a2179 2
		{ $$.t = finish_enum ($<ttype>4, $5);
		  $$.new_type_flag = 1;
d2183 2
a2184 3
		{ $$.t = finish_enum (start_enum ($2), NULL_TREE);
		  $$.new_type_flag = 1;
		  check_for_missing_semicolon ($$.t); }
d2187 1
a2187 1
		  $<ttype>$ = start_enum (make_anon_name ()); }
d2189 1
a2189 1
		{ $$.t = finish_enum ($<ttype>3, $4);
d2191 1
a2191 2
		  check_for_missing_semicolon ($<ttype>3);
		  $$.new_type_flag = 1; }
d2193 2
a2194 3
		{ $$.t = finish_enum (start_enum (make_anon_name()), NULL_TREE);
		  $$.new_type_flag = 1;
		  check_for_missing_semicolon ($$.t); }
d2196 1
a2196 2
		{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); 
		  $$.new_type_flag = 0; }
d2198 3
a2200 5
		{ $$.t = xref_tag (enum_type_node, $2, NULL_TREE, 1); 
		  $$.new_type_flag = 0; }
	| TYPENAME_KEYWORD typename_sub
		{ $$.t = $2;
		  $$.new_type_flag = 0; }
d2202 1
a2202 3
	| class_head left_curly 
                { reset_specialization(); }
          opt.component_decl_list '}' maybe_attribute
a2206 1
		  $<ttype>$ = $1;
d2210 1
a2210 1
		  shadow_tag (CLASSTYPE_AS_LIST ($1)); */
d2216 1
a2216 1
		     finish_exception does too, then it can go.  */
d2218 1
a2218 1
		    note_got_semicolon ($1);
d2220 2
a2221 2
		  if (TREE_CODE ($1) == ENUMERAL_TYPE)
		    ;
d2224 2
a2225 2
		      $<ttype>$ = finish_struct ($1, $4, $6, semi);
		      if (semi) note_got_semicolon ($<ttype>$);
d2230 18
d2249 1
a2249 17
		    check_for_missing_semicolon ($1); 
		  if (current_scope () == current_function_decl)
		    do_pending_defargs ();
		}
	  pending_defargs
		{
		  if (pending_inlines 
		      && current_scope () == current_function_decl)
		    do_pending_inlines ();
		}
	  pending_inlines
		{ 
		  $$.t = $<ttype>7;
		  $$.new_type_flag = 1; 
		  if (current_class_type == NULL_TREE)
		    clear_inline_text_obstack (); 
		}
a2251 2
		  $$.t = $1;
		  $$.new_type_flag = 0;
d2253 2
a2254 2
		  if (TYPE_BINFO_BASETYPES ($$.t) && !TYPE_SIZE ($$.t)
		      && ! TYPE_BEING_DEFINED ($$.t))
d2256 1
a2256 1
			      $$.t);
d2268 1
a2268 2
		{ if (pedantic && !in_system_header)
		    pedwarn ("comma at end of enumerator list"); }
d2271 1
a2271 2
aggr:
	  AGGR
d2276 1
a2276 1
	| aggr CV_QUALIFIER
d2282 9
d2294 1
d2298 1
a2298 1
	  aggr identifier_defn  %prec EMPTY
d2300 8
d2312 2
a2313 15
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, $2, $3);
		}
	| aggr global_scope nested_name_specifier identifier
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, $3, $4);
		}
	| aggr global_scope identifier
		{
		  current_aggr = $1;
		  $$ = handle_class_head ($1, NULL_TREE, $3);
		}
	| aggr template_type
a2314 2
	| aggr nested_name_specifier template_type
		{ current_aggr = $$; $$ = $3; }
d2317 2
a2318 3
do_xref_defn:
	  /* empty */  %prec EMPTY
		{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, NULL_TREE, 0); }
d2322 1
a2322 1
	  named_class_head_sans_basetype  %prec EMPTY
d2325 1
a2325 1
          maybe_base_class_list  %prec EMPTY
a2333 6
		  if (TREE_INT_CST_LOW (current_aggr) == union_type 
		      && TREE_CODE ($$) != UNION_TYPE)
		    cp_pedwarn ("`union' tag used in declaring `%#T'", $$);
		  else if (TREE_CODE ($$) == UNION_TYPE
			   && TREE_INT_CST_LOW (current_aggr) != union_type)
		    cp_pedwarn ("non-`union' tag used in declaring `%#T'", $$);
d2335 1
a2335 15
		    {
		      if (IS_AGGR_TYPE ($$) && CLASSTYPE_USE_TEMPLATE ($$))
		        {
		          if (CLASSTYPE_IMPLICIT_INSTANTIATION ($$)
			      && TYPE_SIZE ($$) == NULL_TREE)
			    {
			      SET_CLASSTYPE_TEMPLATE_SPECIALIZATION ($$);
			      if (processing_template_decl)
				push_template_decl (TYPE_MAIN_DECL ($$));
			    }
			  else if (CLASSTYPE_TEMPLATE_INSTANTIATION ($$))
			    cp_error ("specialization after instantiation of `%T'", $$);
			}
		      xref_basetypes (current_aggr, $1, $$, $2); 
		    }
d2339 1
a2339 2
unnamed_class_head:
	  aggr '{'
d2344 1
a2344 4
class_head:
	  unnamed_class_head
	| named_class_head
	;
d2347 1
a2347 1
	  /* empty */  %prec EMPTY
d2349 1
a2349 1
	| ':' see_typename  %prec EMPTY
d2364 3
a2366 2
		  tree type = TREE_TYPE ($1);
		  if (! is_aggr_type (type, 1))
d2378 1
a2378 1
		      $$ = build_tree_list (access_public_node, type);
d2386 1
a2386 1
		    $$ = build_tree_list (access_default_node, type);
d2390 2
a2391 1
		  tree type = TREE_TYPE ($3);
d2394 1
a2394 1
		  if (! IS_AGGR_TYPE (type))
d2406 1
a2406 1
		      $$ = build_tree_list (access_public_node, type);
d2414 1
a2414 1
		    $$ = build_tree_list ($$, type);
d2419 1
a2419 3
	  typename_sub
		{ $$ = TYPE_MAIN_DECL ($1); }
	| nonnested_type
d2427 2
a2428 1
			  $$ = TREE_TYPE ($3);
d2446 1
a2446 1
		      if (IS_AGGR_TYPE (groktypename ($3.t)))
d2449 2
a2450 1
			  $$ = groktypename ($3.t);
d2471 1
a2471 1
		  $$ = access_default_virtual_node; }
d2474 1
a2474 1
		  if ($2 == access_protected_node)
d2477 1
a2477 1
		      $2 = access_public_node;
d2480 1
a2480 1
		  else if ($2 == access_public_node)
d2482 1
a2482 1
		      if ($1 == access_private_node)
d2487 2
a2488 2
		      else if ($1 == access_default_virtual_node)
			$$ = access_public_virtual_node;
d2490 1
a2490 1
		  else /* $2 == access_private_node */
d2492 1
a2492 1
		      if ($1 == access_public_node)
d2494 2
a2495 2
		      else if ($1 == access_default_virtual_node)
			$$ = access_private_virtual_node;
d2501 4
a2504 4
		  if ($$ == access_public_node)
		    $$ = access_public_virtual_node;
		  else if ($$ == access_private_node)
		    $$ = access_private_virtual_node; }
d2507 1
a2507 2
left_curly:
	  '{'
d2512 1
a2512 2
		  if (t == error_mark_node
		      || ! IS_AGGR_TYPE (t))
d2515 1
a2515 1
		      pushtag (make_anon_name (), t, 0);
a2524 3
		  if (processing_template_decl && TYPE_CONTEXT (t)
		      && ! current_class_type)
		    push_template_decl (TYPE_STUB_DECL (t));
a2526 12
		  if (IS_AGGR_TYPE (t) && CLASSTYPE_USE_TEMPLATE (t))
		    {
		      if (CLASSTYPE_IMPLICIT_INSTANTIATION (t)
			  && TYPE_SIZE (t) == NULL_TREE)
			{
			  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);
			  if (processing_template_decl)
			    push_template_decl (TYPE_MAIN_DECL (t));
			}
		      else if (CLASSTYPE_TEMPLATE_INSTANTIATION (t))
			cp_error ("specialization after instantiation of `%T'", t);
		    }
a2572 7
self_reference:
	  /* empty */
		{
		    $$ = build_self_reference ();
		}
	;

d2574 3
a2576 3
	  self_reference
		{ if ($$) $$ = build_tree_list (access_public_node, $$); }
	| self_reference component_decl_list
d2579 1
a2579 1
		    $$ = build_tree_list (access_public_node, $2);
d2581 1
a2581 2
		    $$ = build_tree_list (access_default_node, $2);
		  if ($1) $$ = tree_cons (access_public_node, $1, $$);
d2585 1
a2585 1
		  tree visspec = $2;
d2590 1
a2590 1
		      visspec = access_public_node;
a2639 3
	| extension component_decl
		{ $$ = $2;
		  pedantic = $<itype>1; }
d2647 1
a2647 1
		{ $$ = grok_x_components ($1.t, $2); }
d2650 3
a2652 6
	| notype_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
	| constructor_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
d2666 8
a2673 1
	| declmods component_constructor_declarator maybeasm maybe_attribute maybe_init
d2676 4
a2679 5
		  $$ = grokfield ($2, specs, $5, $3,
				  build_tree_list ($4, attrs)); }
	| component_constructor_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, NULL_TREE, $4, $2,
				  build_tree_list ($3, NULL_TREE)); }
d2682 1
a2682 21
        | template_header component_decl_1 
                { 
                  if ($1)
		    end_template_decl (); 
                  else
                    end_specialization ();

		  if ($2 && DECL_TEMPLATE_INFO ($2)
		      && !DECL_TEMPLATE_SPECIALIZATION ($2))
		    {
		      $$ = DECL_TI_TEMPLATE ($2); 
		      check_member_template ($$);
		    }
		  else if ($2)
		    $$ = $2;
		  else
		    {
		      cp_error("invalid member template declaration");
		      $$ = NULL_TREE;
		    }
		}
d2684 1
a2684 1
/* The case of exactly one component is handled directly by component_decl.  */
d2727 1
a2727 1
	  after_type_declarator maybeasm maybe_attribute maybe_init
d2731 2
a2732 2
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
d2742 1
a2742 1
	  notype_declarator maybeasm maybe_attribute maybe_init
d2746 2
a2747 8
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
	| constructor_declarator maybeasm maybe_attribute maybe_init
		{ split_specs_attrs ($<ttype>0, &current_declspecs,
				     &prefix_attributes);
		  $<ttype>0 = current_declspecs;
		  $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
d2763 3
a2765 3
	  after_type_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
d2772 3
a2774 3
	  notype_declarator maybeasm maybe_attribute maybe_init
		{ $$ = grokfield ($$, current_declspecs, $4, $2,
				  build_tree_list ($3, prefix_attributes)); }
d2803 3
a2805 5
		{ $$.t = build_decl_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
	| type_specifier_seq  %prec EMPTY
		{ $$.t = build_decl_list ($1.t, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
d2812 2
a2813 3
		  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);
		  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);
		  $$.new_type_flag = $2.new_type_flag;
d2817 2
a2818 2
cv_qualifiers:
	  /* empty */  %prec EMPTY
d2820 1
a2820 1
	| cv_qualifiers CV_QUALIFIER
d2824 5
a2828 7
nonempty_cv_qualifiers:
	  CV_QUALIFIER
		{ $$.t = IDENTIFIER_AS_LIST ($1); 
		  $$.new_type_flag = 0; }
	| nonempty_cv_qualifiers CV_QUALIFIER
		{ $$.t = decl_tree_cons (NULL_TREE, $2, $1.t); 
		  $$.new_type_flag = $1.new_type_flag; }
d2835 1
a2835 2
	  /* empty */
		{ $<itype>$ = suspend_momentary (); } 
d2839 2
a2840 2
	  suspend_mom expr
		{ resume_momentary ((int) $<itype>1); $$ = $2; }
d2858 4
a2861 4
	  '*' nonempty_cv_qualifiers after_type_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers after_type_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
d2866 1
a2866 1
	| ptr_to_mem cv_qualifiers after_type_declarator
d2873 2
a2874 2
nonnested_type:
	  type_name  %prec EMPTY
d2876 9
a2884 14
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    {
		      if (current_class_type
			  && TYPE_BEING_DEFINED (current_class_type)
			  && ! IDENTIFIER_CLASS_VALUE ($1))
			{
			  /* Be sure to get an inherited typedef.  */
			  $$ = lookup_name ($1, 1);
			  /* Remember that this name has been used in the class
			     definition, as per [class.scope0] */
			  pushdecl_class_level ($$);
			}
		      else
			$$ = identifier_typedecl_value ($1);
a2885 2
		  else
		    $$ = $1;
a2886 12
	| global_scope type_name
		{
		  if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    $$ = identifier_typedecl_value ($2);
		  else
		    $$ = $2;
		  got_scope = NULL_TREE;
		}
	;

complete_type_name:
	  nonnested_type
a2887 2
	| global_scope nested_type
		{ $$ = $2; }
d2891 2
a2892 2
	  nested_name_specifier type_name  %prec EMPTY
		{ $$ = get_type_decl ($2); }
d2896 2
a2897 2
	  direct_after_type_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $2, $3, $4); }
d2904 2
a2905 2
	| nested_name_specifier type_name  %prec EMPTY
		{ push_nested_class ($1, 3);
d2908 1
a2908 1
	| type_name  %prec EMPTY
d2915 4
a2918 4
	  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
d2923 1
a2923 1
	| ptr_to_mem cv_qualifiers notype_declarator
d2931 4
a2934 4
	  '*' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_pointer_declarator ($2.t, $3); }
	| '&' nonempty_cv_qualifiers notype_declarator  %prec UNARY
		{ $$ = make_reference_declarator ($2.t, $3); }
d2939 1
a2939 1
	| ptr_to_mem cv_qualifiers notype_declarator
d2947 2
a2948 2
	  direct_notype_declarator maybe_parmlist cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $2, $3, $4); }
d2956 1
a2956 1
		{ if (OP0 ($$) != current_class_type)
d2958 1
a2958 10
		      push_nested_class (OP0 ($$), 3);
		      TREE_COMPLEXITY ($$) = current_class_depth;
		    }
		}
        | nested_name_specifier notype_template_declarator
                { got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $1, $2);
		  if ($1 != current_class_type)
		    {
		      push_nested_class ($1, 3);
d2965 1
a2965 1
	  nested_name_specifier unqualified_id
a2967 3
        | nested_name_specifier object_template_id
                { got_scope = NULL_TREE;
 		  $$ = build_parse_node (SCOPE_REF, $1, $2); }
d2971 1
a2971 1
	  nested_name_specifier notype_unqualified_id
a2973 3
        | nested_name_specifier object_template_id
                { got_scope = NULL_TREE;
		  $$ = build_parse_node (SCOPE_REF, $1, $2); }
d2984 1
a2984 1
		{ $$ = build_functional_cast ($1.t, $3); }
d2986 3
a2988 3
		{ $$ = reparse_decl_as_expr ($1.t, $3); }
	| typespec fcast_or_absdcl  %prec EMPTY
		{ $$ = reparse_absdcl_as_expr ($1.t, $2); }
d2993 1
a2993 2
	| SELFNAME
	| template_type  %prec EMPTY
d3006 1
a3006 19
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    {
		      $$ = lastiddecl;
		      /* Remember that this name has been used in the class
			 definition, as per [class.scope0] */
		      if (current_class_type
			  && TYPE_BEING_DEFINED (current_class_type)
			  && ! IDENTIFIER_CLASS_VALUE ($1))
			pushdecl_class_level ($$);
		    }
		  got_scope = $$ = TREE_TYPE ($$);
		}
	| SELFNAME SCOPE
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = TREE_TYPE ($$);
		}
d3008 1
a3008 5
		{
		  if (TREE_CODE ($$) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$;
		}
d3010 1
a3010 1
		{ got_scope = $$ = complete_type (TREE_TYPE ($1)); }
d3023 3
a3025 3
typename_sub:
	  typename_sub0
	| global_scope typename_sub0
a3028 54
typename_sub0:
	  typename_sub1 identifier
		{
		  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')
		    $$ = make_typename_type ($1, $2);
		  else if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $2);
		  else
		    $$ = $2;
		}
	;

typename_sub1:
	  typename_sub2
		{
		  if (TREE_CODE ($1) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $1);
		}
	| typename_sub1 typename_sub2
		{
		  if (TREE_CODE_CLASS (TREE_CODE ($1)) == 't')
		    $$ = make_typename_type ($1, $2);
		  else if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    cp_error ("`%T' is not a class or namespace", $2);
		  else
		    $$ = $2;
		}
	;

typename_sub2:
	  TYPENAME SCOPE
		{
		  if (TREE_CODE ($1) != IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = complete_type (TREE_TYPE ($$));
		}
	| SELFNAME SCOPE
		{
		  if (TREE_CODE ($1) != IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$ = complete_type (TREE_TYPE ($$));
		}
	| template_type SCOPE
		{ got_scope = $$ = complete_type (TREE_TYPE ($$)); }
	| PTYPENAME SCOPE
	| IDENTIFIER SCOPE
	| NSNAME SCOPE
		{
		  if (TREE_CODE ($$) == IDENTIFIER_NODE)
		    $$ = lastiddecl;
		  got_scope = $$;
		}
	;

d3030 2
a3031 10
	  global_scope type_name
		{
		  if (TREE_CODE ($2) == IDENTIFIER_NODE)
		    $$ = identifier_typedecl_value ($2);
		  else
		    $$ = $2;
		  got_scope = NULL_TREE;
		}
	| nested_type
	| global_scope nested_type
d3043 1
a3043 1
   that got_scope will be set before yylex is called to get the next token.  */
d3051 1
a3051 1
	  '*' cv_qualifiers new_declarator
d3053 1
a3053 1
	| '*' cv_qualifiers  %prec EMPTY
d3055 1
a3055 1
	| '&' cv_qualifiers new_declarator  %prec EMPTY
d3057 1
a3057 1
	| '&' cv_qualifiers  %prec EMPTY
d3059 1
a3059 1
	| ptr_to_mem cv_qualifiers  %prec EMPTY
d3063 1
a3063 1
	| ptr_to_mem cv_qualifiers new_declarator
d3067 1
a3067 1
	| direct_new_declarator  %prec EMPTY
d3080 2
a3081 2
	  '*' nonempty_cv_qualifiers absdcl
		{ $$ = make_pointer_declarator ($2.t, $3); }
d3084 3
a3086 3
	| '*' nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = make_pointer_declarator ($2.t, NULL_TREE); }
	| '*'  %prec EMPTY
d3088 2
a3089 2
	| '&' nonempty_cv_qualifiers absdcl
		{ $$ = make_reference_declarator ($2.t, $3); }
d3092 3
a3094 3
	| '&' nonempty_cv_qualifiers  %prec EMPTY
		{ $$ = make_reference_declarator ($2.t, NULL_TREE); }
	| '&'  %prec EMPTY
d3096 1
a3096 1
	| ptr_to_mem cv_qualifiers  %prec EMPTY
d3100 1
a3100 1
	| ptr_to_mem cv_qualifiers absdcl
d3104 1
a3104 1
	| direct_abstract_declarator  %prec EMPTY
d3113 4
a3116 4
	| direct_abstract_declarator '(' parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, $3, $5, $6); }
	| direct_abstract_declarator LEFT_RIGHT cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator ($$, empty_parms (), $3, $4); }
d3121 6
a3126 6
	| '(' complex_parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'
		{ $$ = make_call_declarator (NULL_TREE, $2, $4, $5); }
	| regcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'
		{ set_quals_and_spec ($$, $2, $3); }
	| fcast_or_absdcl cv_qualifiers exception_specification_opt  %prec '.'
		{ set_quals_and_spec ($$, $2, $3); }
d3144 1
a3144 2
errstmt:
	  error ';'
d3151 6
a3156 3
.pushlevel:
	  /* empty */
		{ do_pushlevel (); }
d3159 4
a3162 3
.poplevel:
	  /* empty */
		{ $$ = do_poplevel (); }
d3199 2
a3200 19
compstmt:
	  '{'
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  .pushlevel compstmtend .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  $$ = $5;
		}
d3205 1
a3205 9
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (IF_STMT, NULL_TREE, NULL_TREE,
					        NULL_TREE);
		      add_tree ($<ttype>$);
		    }
                  cond_stmt_keyword = "if";
		}
d3207 2
a3208 18
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 0) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 0) = $4;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_start_cond ($4, 0);
		    }
		}
a3209 8
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      $<ttype>$ = last_tree = $<ttype>2;
		    }
		}
d3215 2
a3216 18
	| .pushlevel
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (COMPOUND_STMT, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  simple_stmt .poplevel
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  $$ = $4;
		}
d3231 7
a3237 10
		  if (! processing_template_decl)
		    {
		      emit_line_note (input_filename, lineno);
		      /* Do default conversion if safe and possibly important,
		         in case within ({...}).  */
		      if ((TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE
		           && lvalue_p (expr))
		          || TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE)
		        expr = default_conversion (expr);
		    }
d3242 1
a3242 1
		{ if (! processing_template_decl) expand_start_else (); }
d3244 1
a3244 10
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>1, 2) = TREE_CHAIN ($<ttype>1);
		      TREE_CHAIN ($<ttype>1) = NULL_TREE;
		      last_tree = $<ttype>1;
		    }
		  else
		    expand_end_cond ();
		}
d3247 5
a3251 3
	| simple_if  %prec IF
		{ if (! processing_template_decl) expand_end_cond ();
		  do_poplevel ();
d3254 4
a3257 14
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (WHILE_STMT, NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop (1); 
		    }
		  cond_stmt_keyword = "while";
		}
d3259 1
a3259 18
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 0) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 0) = $4;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_exit_loop_if_false (0, $4);
		    }
		}
d3261 2
a3262 11
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_loop ();
		  finish_stmt ();
		}
d3264 3
a3266 13
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (DO_STMT, NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop_continue_elsewhere (1);
		    }
		}
d3268 2
a3269 13
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    {
		      expand_loop_continue_here ();
		      cond_stmt_keyword = "do";
		    }
		}
d3271 3
a3273 9
		{
		  if (processing_template_decl)
		    TREE_OPERAND ($<ttype>2, 1) = $6;
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_exit_loop_if_false (0, $6);
		      expand_end_loop ();
		    }
d3275 1
a3275 2
		  finish_stmt ();
		}
d3277 1
a3277 8
		{ if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (FOR_STMT, NULL_TREE, NULL_TREE, 
					        NULL_TREE, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
                  else
		    emit_line_note (input_filename, lineno);
d3289 3
a3291 17
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
			{
			  TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		    }
		  else
		    {
		      emit_nop ();
		      emit_line_note (input_filename, lineno);
		      expand_start_loop_continue_elsewhere (1); 
		    }
		}
d3293 2
a3294 18
		{
		  if (processing_template_decl)
		    {
		      if (last_tree != $<ttype>2)
		        {
			  TREE_OPERAND ($<ttype>2, 1) = last_tree;
			  TREE_CHAIN ($<ttype>2) = NULL_TREE;
			  last_tree = $<ttype>2;
			}
		      else
		        TREE_OPERAND ($<ttype>2, 1) = $7;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      if ($7) expand_exit_loop_if_false (0, $7);
		    }
		}
d3298 1
a3298 5
		{
		  if (processing_template_decl)
		    TREE_OPERAND ($<ttype>2, 2) = $10;
		  push_momentary ();
		}
d3300 3
a3302 14
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 3) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_loop_continue_here ();
		      if ($10) cplus_expand_expr_stmt ($10);
		      expand_end_loop ();
		    }
d3304 1
d3307 3
a3309 1
		      do_poplevel ();
d3313 2
a3314 11
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (SWITCH_STMT, $4, NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      c_expand_start_case ($4);
		    }
d3318 1
a3318 2
		  push_momentary ();
		}
d3320 1
a3320 9
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>6, 1) = TREE_CHAIN ($<ttype>6);
		      TREE_CHAIN ($<ttype>6) = NULL_TREE;
		      last_tree = $<ttype>6;
		    }
		  else
		    expand_end_case ($4);
d3322 1
a3322 2
		  pop_switch (); 
		}
d3326 23
a3348 1
		{ do_case ($2, NULL_TREE); }
d3351 30
a3380 1
		{ do_case ($2, $4); }
d3383 14
a3396 1
		{ do_case (NULL_TREE, NULL_TREE); }
d3400 1
a3400 3
		  if (processing_template_decl)
		    add_tree (build_min_nt (BREAK_STMT));
		  else if ( ! expand_exit_something ())
d3404 1
a3404 3
		  if (processing_template_decl)
		    add_tree (build_min_nt (CONTINUE_STMT));
		  else if (! expand_continue_loop (0))
d3414 1
a3414 1
	| asm_keyword maybe_cv_qualifier '(' string ')' ';'
d3421 1
a3421 1
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'
d3430 1
a3430 1
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':' asm_operands ')' ';'
d3439 1
a3439 1
	| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'
d3449 2
a3450 7
		{
		  if (processing_template_decl)
		    add_tree (build_min_nt (GOTO_STMT, $3));
		  else
		    { emit_line_note (input_filename, lineno);
		      expand_computed_goto ($3); }
		}
d3452 5
a3456 12
		{
		  if (processing_template_decl)
		    add_tree (build_min_nt (GOTO_STMT, $2));
		  else
		    {
		      tree decl;
		      emit_line_note (input_filename, lineno);
		      decl = lookup_label ($2);
		      TREE_USED (decl) = 1;
		      expand_goto (decl); 
		    }
		}
d3475 3
a3477 2
	  ctor_initializer_opt compstmt
		{ expand_start_all_catch (); }
a3479 2
		  int nested = (hack_decl_function_context
				(current_function_decl) != NULL_TREE);
d3481 1
a3481 1
		  finish_function (lineno, (int)$3, nested);
d3487 1
a3487 13
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (TRY_BLOCK, NULL_TREE,
						NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		  else
		    {
		      emit_line_note (input_filename, lineno);
		      expand_start_try_stmts ();
		    }
		}
d3489 2
a3490 10
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_start_all_catch ();
		}
d3492 1
a3492 10
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_all_catch ();
		}
d3496 5
a3500 23
	  handler
	| handler_seq handler
	;

handler:
	  CATCH
		{
		  if (processing_template_decl)
		    {
		      $<ttype>$ = build_min_nt (HANDLER, NULL_TREE,
						NULL_TREE);
		      add_tree ($<ttype>$);
		    }
		}
	  .pushlevel handler_args
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 0) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		}	  
d3502 1
a3502 10
		{
		  if (processing_template_decl)
		    {
		      TREE_OPERAND ($<ttype>2, 1) = TREE_CHAIN ($<ttype>2);
		      TREE_CHAIN ($<ttype>2) = NULL_TREE;
		      last_tree = $<ttype>2;
		    }
		  else
		    expand_end_catch_block ();
		}	  
d3507 2
a3508 2
	  typed_typespecs  %prec EMPTY
	| nonempty_cv_qualifiers  %prec EMPTY
d3516 1
a3516 2
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
d3518 1
a3518 2
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, NULL_TREE); }
d3520 1
a3520 2
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
d3522 2
a3523 3
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block ($2.t, $3); }
	This allows reference parameters...  */
d3525 2
a3526 3
		{ check_for_new_type ("inside exception declarations", $2);
		  expand_start_catch_block (TREE_PURPOSE ($2.t),
					    TREE_VALUE ($2.t)); }
d3534 1
a3534 1
		  if (label && ! minimal_parse_mode)
a3540 2
	| SELFNAME ':'
		{ goto do_label; }
a3547 3
		{ if (pedantic)
		    pedwarn ("ANSI C++ forbids compound statements inside for initializations");
		}
d3552 2
a3553 2
maybe_cv_qualifier:
	  /* empty */
d3556 1
a3556 1
	| CV_QUALIFIER
d3561 1
a3561 1
	  /* empty */
d3570 1
a3570 2
asm_operands:
	  /* empty */
d3599 1
a3599 2
parmlist:
	  /* empty */
d3601 4
a3604 1
		  $$ = empty_parms();
d3608 2
a3609 3
		{ $$ = tree_cons (NULL_TREE, $1.t, void_list_node);
		  TREE_PARMLIST ($$) = 1; 
		  check_for_new_type ("inside parameter list", $1); }
d3631 1
a3631 1
		  $$ = build_tree_list (NULL_TREE, $1.t); 
d3636 3
d3651 1
a3651 1
		  $$ = build_tree_list (NULL_TREE, $1.t);
d3671 1
a3671 1
		  $$ = tree_cons (NULL_TREE, $1.t, void_list_node);
a3677 13
/* A default argument to a */
defarg:
	  '='
		{ maybe_snarf_defarg (); }
	  defarg1
		{ $$ = $3; }
	;

defarg1:
	  DEFARG
	| init
	;

d3681 3
a3683 5
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list (NULL_TREE, $1.t); }
	| parm defarg
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list ($2, $1.t); }
d3685 1
a3685 2
		{ check_for_new_type ("in a parameter list", $2);
		  $$ = chainon ($$, $2.t); }
d3695 1
a3695 2
		{ check_for_new_type ("in a parameter list", $1);
		  $$ = build_tree_list (NULL_TREE, $1.t); }
d3699 3
a3701 1
   as found in a parmlist.  */
d3703 14
d3720 2
a3721 3
		{ tree specs = strip_attrs ($1.t);
		  $$.new_type_flag = $1.new_type_flag;
		  $$.t = build_tree_list (specs, $2); }
d3723 1
a3723 2
		{ $$.t = build_tree_list ($1.t, $2); 
		  $$.new_type_flag = $1.new_type_flag; }
d3725 1
a3725 2
		{ $$.t = build_tree_list (get_decl_list ($1.t), $2); 
		  $$.new_type_flag = $1.new_type_flag; }
d3727 5
a3731 7
		{ tree specs = strip_attrs ($1.t);
		  $$.t = build_tree_list (specs, $2);
		  $$.new_type_flag = $1.new_type_flag; }
	| typed_declspecs1  %prec EMPTY
		{ tree specs = strip_attrs ($1.t);
		  $$.t = build_tree_list (specs, NULL_TREE); 
		  $$.new_type_flag = $1.new_type_flag; }
d3734 1
a3734 2
		  $$.t = build_tree_list (specs, $2); 
		  $$.new_type_flag = 0; }
d3738 2
a3739 6
	  parm
		{ $$.t = build_tree_list (NULL_TREE, $1.t);
		  $$.new_type_flag = $1.new_type_flag;  }
	| parm defarg
		{ $$.t = build_tree_list ($2, $1.t);
		  $$.new_type_flag = $1.new_type_flag;  }
d3743 1
a3743 1
	  named_parm
d3747 2
a3748 3
see_typename:
	  /* empty */  %prec EMPTY
		{ see_typename (); }
d3751 18
a3777 3
		  if (TREE_CODE ($$) == SCOPE_REF
		      && TREE_CODE (TREE_OPERAND ($$, 0)) == TEMPLATE_TYPE_PARM)
		    cp_error ("  perhaps you want `typename %E' to make it a type", $$);
d3783 1
a3783 1
	  /* empty */  %prec EMPTY
d3785 1
a3785 1
	| THROW '(' ansi_raise_identifiers  ')'  %prec EMPTY
d3787 1
a3787 1
	| THROW LEFT_RIGHT  %prec EMPTY
d3793 1
a3793 1
		{ $$ = build_decl_list (NULL_TREE, groktypename($1.t)); }
d3806 1
a3806 1
	  /* empty */  %prec EMPTY
d3808 1
a3808 1
	| '*' cv_qualifiers conversion_declarator
d3810 1
a3810 1
	| '&' cv_qualifiers conversion_declarator
d3812 1
a3812 1
	| ptr_to_mem cv_qualifiers conversion_declarator
d3818 1
a3818 2
operator:
	  OPERATOR
d3881 1
a3881 1
	| operator NEW  %prec EMPTY
d3883 1
a3883 1
	| operator DELETE  %prec EMPTY
d3891 1
a3891 1
		{ $$ = grokoptypename ($2.t, $3); }
@


1.1.1.3
log
@FSF gcc 2.8.1
@
text
@a3019 1
		      $$ = lookup_name ($1, 1);
d3024 2
d3030 2
d3039 1
a3039 1
		    $$ = IDENTIFIER_GLOBAL_VALUE ($2);
d3288 1
a3288 1
		    $$ = IDENTIFIER_GLOBAL_VALUE ($2);
@

