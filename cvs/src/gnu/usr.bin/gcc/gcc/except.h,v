head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.58
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.22.20;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.22.20;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@/* Exception Handling interface routines.
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
   Contributed by Mike Stump <mrs@@cygnus.com>.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */


#ifndef GCC_VARRAY_H
struct varray_head_tag;
#define varray_type struct varray_head_tag *
#endif

struct function;

struct inline_remap;

/* Per-function EH data.  Used only in except.c, but GC and others
   manipulate pointers to the opaque type.  */
struct eh_status;

/* Internal structure describing a region.  */
struct eh_region;

/* Test: is exception handling turned on?  */
extern int doing_eh			        PARAMS ((int));

/* Start an exception handling region.  All instructions emitted after
   this point are considered to be part of the region until an
   expand_eh_region_end variant is invoked.  */
extern void expand_eh_region_start		PARAMS ((void));

/* End an exception handling region for a cleanup.  HANDLER is an
   expression to expand for the cleanup.  */
extern void expand_eh_region_end_cleanup	PARAMS ((tree));

/* End an exception handling region for a try block, and prepares
   for subsequent calls to expand_start_catch.  */
extern void expand_start_all_catch		PARAMS ((void));

/* Begin a catch clause.  TYPE is an object to be matched by the
   runtime, or a list of such objects, or null if this is a catch-all
   clause.  */
extern void expand_start_catch			PARAMS ((tree));

/* End a catch clause.  Control will resume after the try/catch block.  */
extern void expand_end_catch			PARAMS ((void));

/* End a sequence of catch handlers for a try block.  */
extern void expand_end_all_catch		PARAMS ((void));

/* End an exception region for an exception type filter.  ALLOWED is a
   TREE_LIST of TREE_VALUE objects to be matched by the runtime.
   FAILURE is a function to invoke if a mismatch occurs.  */
extern void expand_eh_region_end_allowed	PARAMS ((tree, tree));

/* End an exception region for a must-not-throw filter.  FAILURE is a
   function to invoke if an uncaught exception propagates this far.  */
extern void expand_eh_region_end_must_not_throw	PARAMS ((tree));

/* End an exception region for a throw.  No handling goes on here,
   but it's the easiest way for the front-end to indicate what type
   is being thrown.  */
extern void expand_eh_region_end_throw		PARAMS ((tree));

/* End a fixup region.  Within this region the cleanups for the immediately
   enclosing region are _not_ run.  This is used for goto cleanup to avoid
   destroying an object twice.  */
extern void expand_eh_region_end_fixup		PARAMS ((tree));

/* Note that the current EH region (if any) may contain a throw, or a
   call to a function which itself may contain a throw.  */
extern void note_eh_region_may_contain_throw    PARAMS ((void));

/* Invokes CALLBACK for every exception handler label.  Only used by old
   loop hackery; should not be used by new code.  */
extern void for_each_eh_label			PARAMS ((void (*) (rtx)));

/* Determine if the given INSN can throw an exception.  */
extern bool can_throw_internal			PARAMS ((rtx));
extern bool can_throw_external			PARAMS ((rtx));

/* Set current_function_nothrow and cfun->all_throwers_are_sibcalls.  */
extern void set_nothrow_function_flags		PARAMS ((void));

/* After initial rtl generation, call back to finish generating
   exception support code.  */
extern void finish_eh_generation		PARAMS ((void));

extern void init_eh				PARAMS ((void));
extern void init_eh_for_function		PARAMS ((void));

extern rtx reachable_handlers			PARAMS ((rtx));
extern void maybe_remove_eh_handler		PARAMS ((rtx));

extern void convert_from_eh_region_ranges	PARAMS ((void));
extern void convert_to_eh_region_ranges		PARAMS ((void));
extern void find_exception_handler_labels	PARAMS ((void));
extern bool current_function_has_exception_handlers PARAMS ((void));
extern void output_function_exception_table	PARAMS ((void));

extern void expand_builtin_unwind_init		PARAMS ((void));
extern rtx expand_builtin_eh_return_data_regno	PARAMS ((tree));
extern rtx expand_builtin_extract_return_addr	PARAMS ((tree));
extern void expand_builtin_init_dwarf_reg_sizes PARAMS ((tree));
extern rtx expand_builtin_frob_return_addr	PARAMS ((tree));
extern rtx expand_builtin_dwarf_sp_column	PARAMS ((void));
extern void expand_builtin_eh_return		PARAMS ((tree, tree));
extern void expand_eh_return			PARAMS ((void));
extern rtx get_exception_pointer		PARAMS ((struct function *));
extern int duplicate_eh_regions			PARAMS ((struct function *,
						 struct inline_remap *));

extern void sjlj_emit_function_exit_after	PARAMS ((rtx));


/* If non-NULL, this is a function that returns an expression to be
   executed if an unhandled exception is propagated out of a cleanup
   region.  For example, in C++, an exception thrown by a destructor
   during stack unwinding is required to result in a call to
   `std::terminate', so the C++ version of this function returns a
   CALL_EXPR for `std::terminate'.  */
extern tree (*lang_protect_cleanup_actions) PARAMS ((void));

/* Return true if type A catches type B.  */
extern int (*lang_eh_type_covers) PARAMS ((tree a, tree b));

/* Map a type to a runtime object to match type.  */
extern tree (*lang_eh_runtime_type) PARAMS ((tree));

#ifndef GCC_VARRAY_H
#undef varray_type
#endif


/* Just because the user configured --with-sjlj-exceptions=no doesn't
   mean that we can use call frame exceptions.  Detect that the target
   has appropriate support.  */

#if ! (defined (EH_RETURN_DATA_REGNO)			\
       && (defined (IA64_UNWIND_INFO)			\
	   || (DWARF2_UNWIND_INFO			\
	       && (defined (EH_RETURN_HANDLER_RTX)	\
		   || defined (HAVE_eh_return)))))
#define MUST_USE_SJLJ_EXCEPTIONS	1
#else
#define MUST_USE_SJLJ_EXCEPTIONS	0
#endif

#ifdef CONFIG_SJLJ_EXCEPTIONS
# if CONFIG_SJLJ_EXCEPTIONS == 1
#  define USING_SJLJ_EXCEPTIONS		1
# endif
# if CONFIG_SJLJ_EXCEPTIONS == 0
#  define USING_SJLJ_EXCEPTIONS		0
#  ifndef EH_RETURN_DATA_REGNO
    #error "EH_RETURN_DATA_REGNO required"
#  endif
#  if !defined(EH_RETURN_HANDLER_RTX) && !defined(HAVE_eh_return)
    #error "EH_RETURN_HANDLER_RTX or eh_return required"
#  endif
#  if !defined(DWARF2_UNWIND_INFO) && !defined(IA64_UNWIND_INFO)
    #error "{DWARF2,IA64}_UNWIND_INFO required"
#  endif
# endif
#else
# define USING_SJLJ_EXCEPTIONS		MUST_USE_SJLJ_EXCEPTIONS
#endif
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
