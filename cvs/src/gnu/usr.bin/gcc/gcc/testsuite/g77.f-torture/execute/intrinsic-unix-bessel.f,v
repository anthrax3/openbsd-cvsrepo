head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@c @;


1.1
date	2003.11.29.12.37.31;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.31;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@c  intrinsic-unix-bessel.f
c
c Test Bessel function intrinsics.  
c These functions are only available if provided by system
c
c     David Billinghurst <David.Billinghurst@@riotinto.com>
c
      real x, a
      double precision dx, da
      integer i
      integer*2 j
      integer*1 k
      integer*8 m
      logical fail
      common /flags/ fail
      fail = .false.

      x = 2.0
      dx = x 
      i = 2
      j = i
      k = i
      m = i
c     BESJ0  - Bessel function of first kind of order zero
      a = 0.22389077
      da = a
      call c_r(BESJ0(x),a,'BESJ0(real)')
      call c_d(BESJ0(dx),da,'BESJ0(double)')
      call c_d(DBESJ0(dx),da,'DBESJ0(double)')

c     BESJ1  - Bessel function of first kind of order one
      a = 0.57672480
      da = a
      call c_r(BESJ1(x),a,'BESJ1(real)')
      call c_d(BESJ1(dx),da,'BESJ1(double)')
      call c_d(DBESJ1(dx),da,'DBESJ1(double)')

c     BESJN  - Bessel function of first kind of order N
      a = 0.3528340
      da = a
      call c_r(BESJN(i,x),a,'BESJN(integer,real)')
      call c_r(BESJN(j,x),a,'BESJN(integer*2,real)')
      call c_r(BESJN(k,x),a,'BESJN(integer*1,real)')
      call c_d(BESJN(i,dx),da,'BESJN(integer,double)')
      call c_d(BESJN(j,dx),da,'BESJN(integer*2,double)')
      call c_d(BESJN(k,dx),da,'BESJN(integer*1,double)')
      call c_d(DBESJN(i,dx),da,'DBESJN(integer,double)')
      call c_d(DBESJN(j,dx),da,'DBESJN(integer*2,double)')
      call c_d(DBESJN(k,dx),da,'DBESJN(integer*1,double)')

c     BESY0  - Bessel function of second kind of order zero
      a = 0.51037567
      da = a
      call c_r(BESY0(x),a,'BESY0(real)')
      call c_d(BESY0(dx),da,'BESY0(double)')
      call c_d(DBESY0(dx),da,'DBESY0(double)')

c     BESY1  - Bessel function of second kind of order one
      a = 0.-0.1070324
      da = a
      call c_r(BESY1(x),a,'BESY1(real)')
      call c_d(BESY1(dx),da,'BESY1(double)')
      call c_d(DBESY1(dx),da,'DBESY1(double)')

c     BESYN  - Bessel function of second kind of order N
      a = -0.6174081
      da = a
      call c_r(BESYN(i,x),a,'BESYN(integer,real)')
      call c_r(BESYN(j,x),a,'BESYN(integer*2,real)')
      call c_r(BESYN(k,x),a,'BESYN(integer*1,real)')
      call c_d(BESYN(i,dx),da,'BESYN(integer,double)')
      call c_d(BESYN(j,dx),da,'BESYN(integer*2,double)')
      call c_d(BESYN(k,dx),da,'BESYN(integer*1,double)')
      call c_d(DBESYN(i,dx),da,'DBESYN(integer,double)')
      call c_d(DBESYN(j,dx),da,'DBESYN(integer*2,double)')
      call c_d(DBESYN(k,dx),da,'DBESYN(integer*1,double)')

      if ( fail ) call abort()
      end

      subroutine failure(label)
c     Report failure and set flag
      character*(*) label
      logical fail
      common /flags/ fail
      write(6,'(a,a,a)') 'Test ',label,' FAILED'
      fail = .true.
      end

      subroutine c_r(a,b,label)
c     Check if REAL a equals b, and fail otherwise
      real a, b
      character*(*) label
      if ( abs(a-b) .gt. 1.0e-5 ) then
         call failure(label)
         write(6,*) 'Got ',a,' expected ', b
      end if
      end

      subroutine c_d(a,b,label)
c     Check if DOUBLE PRECISION a equals b, and fail otherwise
      double precision a, b
      character*(*) label
      if ( abs(a-b) .gt. 1.0d-5 ) then
         call failure(label)
         write(6,*) 'Got ',a,' expected ', b
      end if
      end
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
