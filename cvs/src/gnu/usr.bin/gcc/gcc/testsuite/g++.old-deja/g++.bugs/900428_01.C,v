head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.54
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.03;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.03;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// g++ 1.37.1 bug 900428_01

// g++ fails to issue error messages for cases where an incomplete type
// object must be evaluated if the value of such an evaluation is not
// actually used in the given context.

// In the case where such an object is volatile, it is obvious that this
// could be a problem, however I believe that errors should be issued
// for such cases regardless of whether or not such values are volatile
// because the abstract semantics seem to require the evaluation of such
// values whether they are volatile or not.

// [expr.static.cast/4, stmt.expr/1, expr.comma/1] show that expressions do
// not under go lvalue to rvalue decay, unless the value is actually used.
// This can be surprising when the object is volatile. We interpret a
// dereference of pointer to volatile to be a read.

// keywords: incomplete types, evaluation, volatile qualifier
// Build don't link: 

int *ip_fn ();
int &ir_fn ();
volatile int *vip_fn ();
volatile int &vir_fn ();

void int_test (int i, int *p, volatile int *vp, int &r, volatile int &vr)
{
  int j;
  volatile int vj;
  
  *p;				// ok, no warning
  (void)*p;			// ok, no warning
  (void)(i ? j : *p);	        // ok, no warning
  (void)(i ? *p : j);	        // ok, no warning
  (void)((void)1, *p);	        // ok, no warning

  *vp;				// ok, no warning
  (void)*vp;			// ok, no warning
  (void)(i ? vj : *vp);	        // ok, no warning
  (void)(i ? *vp : vj);	        // ok, no warning
  (void)((void)1, *vp);         // ok, no warning

  r;				// ok, no warning
  (void)r;			// ok, no warning
  (void)(i ? j : r);	        // ok, no warning
  (void)(i ? r : j);	        // ok, no warning
  (void)((void)1, r);	        // ok, no warning

  vr;				// WARNING - reference not accessed
  (void)vr;			// WARNING - reference not accessed
  (void)(i ? vj : vr);	        // WARNING - reference not accessed
  (void)(i ? vr : vj);	        // WARNING - reference not accessed
  (void)((void)1, vr);          // WARNING - reference not accessed
  
  *ip_fn ();			// ok, no warning
  *vip_fn ();			// ok, no warning
  ir_fn ();			// ok, no warning
  vir_fn ();			// WARNING - reference not accessed
}

struct S;
S *sp_fn ();
S &sr_fn ();
volatile S *vsp_fn ();
volatile S &vsr_fn ();

void incomplete_test (int i, S *p, volatile S *vp, S &r, volatile S &vr)
{
  extern S j;
  extern volatile S vj;
  
  *p;				// ok, no warning
  (void)*p;			// ok, no warning
  (void)(i ? j : *p);	        // ok, no warning
  (void)(i ? *p : j);	        // ok, no warning
  (void)((void)1, *p);	        // ok, no warning

  *vp;				// WARNING - incomplete not accessed
  (void)*vp;			// WARNING - incomplete not accessed
  (void)(i ? vj : *vp);	        // WARNING - incomplete not accessed
  (void)(i ? *vp : vj);	        // WARNING - incomplete not accessed
  (void)((void)1, *vp);         // WARNING - incomplete not accessed

  r;				// ok, no warning
  (void)r;			// ok, no warning
  (void)(i ? j : r);	        // ok, no warning
  (void)(i ? r : j);	        // ok, no warning
  (void)((void)1, r);	        // ok, no warning

  vr;				// WARNING - reference not accessed
  (void)vr;			// WARNING - reference not accessed
  (void)(i ? vj : vr);	        // WARNING - reference not accessed
  (void)(i ? vr : vj);	        // WARNING - reference not accessed
  (void)((void)1, vr);          // WARNING - reference not accessed
  
  *sp_fn ();			// ok, no warning
  *vsp_fn ();			// WARNING - incomplete not accessed
  sr_fn ();			// ok, no warning
  vsr_fn ();			// WARNING - reference not accessed
}

struct T {int m;};
T *tp_fn ();
T &tr_fn ();
volatile T *vtp_fn ();
volatile T &vtr_fn ();

void complete_test (int i, T *p, volatile T *vp, T &r, volatile T &vr)
{
  T j;
  volatile T vj;
  
  *p;				// ok, no warning
  (void)*p;			// ok, no warning
  (void)(i ? j : *p);	        // ok, no warning
  (void)(i ? *p : j);	        // ok, no warning
  (void)((void)1, *p);	        // ok, no warning

  *vp;				// ok, no warning
  (void)*vp;			// ok, no warning
  (void)(i ? vj : *vp);	        // ok, no warning
  (void)(i ? *vp : vj);	        // ok, no warning
  (void)((void)1, *vp);         // ok, no warning

  r;				// ok, no warning
  (void)r;			// ok, no warning
  (void)(i ? j : r);	        // ok, no warning
  (void)(i ? r : j);	        // ok, no warning
  (void)((void)1, r);	        // ok, no warning

  vr;				// WARNING - reference not accessed
  (void)vr;			// WARNING - reference not accessed
  (void)(i ? vj : vr);	        // WARNING - reference not accessed
  (void)(i ? vr : vj);	        // WARNING - reference not accessed
  (void)((void)1, vr);          // WARNING - reference not accessed
  
  *tp_fn ();			// ok, no warning
  *vtp_fn ();			// ok, no warning
  tr_fn ();			// ok, no warning
  vtr_fn ();			// ok, no warningWARNING - reference not accessed
}

void extern_test ()
{
  extern S es;
  extern volatile S ves;
  extern T et;
  extern volatile T vet;
  
  extern S &esr;
  extern volatile S &vesr;
  extern T &etr;
  extern volatile T &vetr;
  
  es;				// ok, no warning
  ves;				// WARNING - incomplete not accessed
  et;				// ok, no warning
  vet;				// ok, no warning
  
  esr;				// ok, no warning
  vesr;				// WARNING - incomplete not accessed
  etr;				// ok, no warning
  vetr;				// WARNING - reference not accessed
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
