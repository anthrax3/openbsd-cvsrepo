head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.54
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.09;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.09;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// GROUPS passed code-generation
// code-gen file
// From: "David" <norman@@pi14.arc.umn.edu>
// Date:     Mon, 15 Nov 1993 20:59:14 -0600 (CST)
// Subject:  An error!
// Message-ID: <9311160259.AA03353@@pi14.arc.umn.edu>

#include <cstdlib>
#include <cstdio>
#include <cassert>
#include <fstream>
#include <iostream>
#include <cmath>

#define ANSI_C

typedef double VEC ;

class Vector;

class VectorInt 
{
	public:

	/* Nothing public!! Only Vector can use this class */

	private:

	VectorInt( int );
	VectorInt( int, double *, int = 0 );
	VectorInt( const VectorInt & );
	~VectorInt();

	VectorInt *refer();
	void unrefer();
	int count;				/* Number of Vector's refering to me */

	VEC *vec;

	friend class Vector;
	friend class VecElem;
};

class VecElem 
{
	public:
	
	operator double();
	double operator=( double );

	private:

	VecElem( Vector &, int );
	VecElem( const VecElem & );

	Vector &v;
	int row;						/* Row element refers to */

	friend class Vector;
};

class Vector 
{
	public:

	Vector();					// Must be assigned to before used
	Vector( VectorInt * );
	Vector( int );
	Vector( int, double *, int beg = 0 );
	Vector( const Vector & );
	Vector &operator=( const Vector & );
	~Vector() { if(r) r->unrefer(); };

	int row() const { return 19; }
	int dim() const { return 10; }

	double operator()( int ) const;
	VecElem operator()( int );

	double assign( int, double );

	friend std::ostream& operator<<(std::ostream&, const Vector& m );
	
	private:

	VectorInt *r;			/* Reference to real data */

	friend class VecElem;
	friend class LUDecom;
	friend class SVD;
};


Vector::
Vector()
	: r(0)
{}

Vector::
Vector( VectorInt *vi )
	: r(vi)
{
	r->refer();
}

Vector::
Vector( int row )
{
	assert( row > 0 );

	r = new VectorInt( row );

	r->refer();
}

Vector::
Vector( int row, double *d, int beg )
{
	assert( row > 0 );

	r = new VectorInt( row, d, beg );

	r->refer();
}

Vector::
Vector( const Vector &A )
	: r( A.r->refer() )
{}

Vector& Vector::
operator=( const Vector &A )
{
	if( r )
		r->unrefer();

	r = A.r->refer();

	return *this;
}

double Vector::
operator()( int row ) const
{
	assert(r != 0);

	return *r->vec;
}

VecElem Vector::
operator()( int r )
{
	assert(r != 0);

	return VecElem( *this, r );
}

	/* assign changes the matrix, it does not create a new one! */
double Vector::
assign( int rownum, double d )
{
	assert(r != 0);

	if( rownum > row() || rownum <= 0 ) {
	  std::cerr << "Warning: trying to assign out of bounds" << std::endl;
	  std::cerr << "row " << rownum << std::endl;
	  std::cerr << "Vector size " << row() << std::endl;
	  std::abort();
	}

	if( r->count == 1 ) {
			/* Don't need to create a new matrix, since we are the only */
			/*  one pointing to ours 									*/
	}
	else {
		VectorInt *vi = new VectorInt( *r );
		r->unrefer();
		r = vi->refer();
	}

	return d;
}


VectorInt::
VectorInt( int sx )
	: vec( new double[sx] ), count(0)
{ }

VectorInt::
VectorInt( int sx, double *, int )
	: vec( new double[sx] ), count(0)
{
}

VectorInt::
VectorInt( const VectorInt & )
	: vec( new double[10] ), count(0)
{
}

VectorInt * VectorInt::
refer()
{
	count ++;
	return this;

	// cout << "Refering vec" << endl;
}

void VectorInt::
unrefer()
{
	count--;

	if( count == 0 ) {
		delete this;
	}

	// cout << "Unrefering vec" << endl;
}

VectorInt::
~VectorInt()
{
	delete vec;
	vec = 0;
}

VecElem::
VecElem( Vector &vec, int r )
	: v(vec), row(r)
{
	if( r < 1 || r > vec.row() ) {
	  std::cerr << "Trying to access vector element out of bounds";
	  std::cerr << std::endl;
	  std::abort();
	}
}

VecElem::
VecElem( const VecElem &elem )
	: v(elem.v), row(elem.row)
{}

VecElem::
operator double()
{
	assert( v.r->vec != 0 );
	return *v.r->vec;
};

double VecElem::
operator=( double d )
{
	return v.assign( row, d );
}





int makeforms( Vector cen, Vector **a, Vector **b );

int main()
{
	Vector *a[8], *b[8], disp(3);
	Vector cen(3), cen2(3);
	int i, j;

	if (makeforms (cen,a,b) != 10)
	  { std::printf ("FAIL\n"); return 1; }
	else
	  std::printf ("PASS\n");


}

int
makeforms( Vector cen, Vector **a, Vector **b)
{
	return 10;
}



@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
