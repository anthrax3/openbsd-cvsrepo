head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.13;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.13;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// GROUPS passed i960
/*
  Bug Id: bnr
  PMRS Id: p0000646
  Bug is: Urgent Code Generation Problem in gcc-i960 V 1.95
*/


// Special g++ Options: -Wno-deprecated -Wreturn-type

extern "C"
{
  int printf (const char *, ...);
  void abort ();
}

struct foo
{
  static int si;
  int i;
  foo ();
  foo (const foo&);
  ~foo ();
};

int
foo_parm_returns_i (foo foo_arg)
{
  return foo_arg.i;
}

int foo::si = 0;

foo::foo ()
{
  si++;
  printf ("new foo @@ 0x%x; now %d foos\n", this, si);
}

foo::foo (const foo &other)
{
  si++;
  printf ("another foo @@ 0x%x; now %d foos\n", this, si);
  *this = other;
}

foo::~foo ()
{
  si--;
  printf ("deleted foo @@ 0x%x; now %d foos\n", this, si);
}

int
return_1 ()
{
  foo f;
  printf ("returning 1\n");
  return 1;
}

int
return_arg (int arg)
{
  foo f;
  printf ("returning %d\n", arg);
  return arg;
}

int
return_sum (int x, int y)
{
  foo f;
  printf ("returning %d+%d\n", x, y);
  return x + y;
}

foo
return_foo ()
{
  foo f;
  printf ("returning foo\n");
  return f;
}

foo
return_named_foo () return f
{
  printf ("returning named foo\n");
  return f;
}

foo
foo_parm_returns_foo (foo f)
{
  return f;
}

void
abort_because (char *str)
{
  printf ("aborting because %s\n", str);
  abort ();
}

int
warn_return_1 ()
{
  foo f;
  printf ("returning 1\n");
}                              // WARNING - control reaches end

int
warn_return_arg (int arg)
{
  foo f;
  printf ("returning %d\n", arg);
  arg;
}                              // WARNING - control reaches end

int
warn_return_sum (int x, int y)
{
  foo f;
  printf ("returning %d+%d\n", x, y);
  x + y;
}                              // WARNING - control reaches end

foo
warn_return_foo ()
{
  foo f;
  printf ("returning foo\n");
}                              // WARNING - control reaches end

foo
nowarn_return_named_foo () return f
{
  printf ("returning named foo\n");
}

foo
warn_foo_parm_returns_foo (foo f)
{
  f;
}                              // WARNING - control reaches end

main ()
{				// WARNING - no type
  int ii = return_1 ();
  if (ii != 1)
    abort_because ("wrong value returned");
  int j = return_arg (42);
  if (j != 42)
    abort_because ("wrong value returned");
  int k = return_sum (-69, 69);
  if (k != 0)
    abort_because ("wrong value returned");
  foo f1 = return_named_foo ();
  if (foo::si != 1)
    abort_because ("wrong number of foos");
  f1.i = 5;
  int l = foo_parm_returns_i (f1);
  if (l != 5)
    abort_because ("l != 5");
  foo f2 = foo_parm_returns_foo (f1);
  if (foo::si != 2)
    abort_because ("wrong number of foos");
  if (f2.i != 5)
    abort_because ("f2.i != 5");
  foo f3 = return_foo ();
  if (foo::si != 3)
    abort_because ("wrong number of foos");
  printf("PASS\n");
  return 0;
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
