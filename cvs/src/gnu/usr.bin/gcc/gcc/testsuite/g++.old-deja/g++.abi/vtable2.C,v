head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.36.59;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.36.59;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// Origin: Mark Mitchell <mark@@codesourcery.com>
// Special g++ Options: -fno-strict-aliasing

#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100

#include <stddef.h>

struct S0
{
  virtual void s0 ();
};

struct S1 : virtual public S0
{
  virtual void s1 ();
};

struct S2 : virtual public S1
{
  virtual void s1 ();
  virtual void s0 ();
};

struct S3
{
  virtual void s3 ();
};

struct S4 : public S3, virtual public S2
{
  virtual void s1 ();
};

void S0::s0 ()
{
}

void S1::s1 ()
{
}

void S2::s1 ()
{
}

void S2::s0 ()
{
}

void S3::s3 ()
{
}

void S4::s1 ()
{
}

/* The vtables should look like:

   S0 primary vtable
   
     S0 offset to top
     S0 RTTI
     S0::s0

   =================

   S1 primary vtable

     S0::s0 vcall offset
     S0 vbase offset
     S1 offset to top
     S1 RTTI
     S0::s0
     S1::s1

   =================

   S2 primary vtable
   
     S2::s1 vcall offset
     S1 vbase offset
     S2::s0 vcall offset
     S0 vbase offset
     S2 offset to top
     S2 RTTI
     S2::s0
     S2::s1

   =================

   S3 primary vtable

     S3 offset to top
     S3 RTTI
     S3::s3

   =================

   S4 primary vtable

     vbase offset for S0
     vbase offset for S1
     vbase offset for S2
     S4 offset to top
     S4 RTTI
     S3::s3
     S4::s1

   S2-in-S4 secondary vtable

     S1 vbase offset
     S4::s1 vcall offset
     S0 vbase offset
     S2:s0 vcall offset
     S2 offset to top
     S4 RTTI
     S2::s0
     S4::s1

*/

// These are tricks to allow us to get raw function pointers for
// member functions.
extern "C" {
void _ZN2S32s3Ev ();
void _ZN2S42s1Ev ();
}

// IA-64 uses function descriptors not function pointers in its vtables.
#if defined __ia64__
#define CMP_VPTR(A, B)	(*(void **)(A) == *(void **)(B))
#ifdef _LP64
#define INC_VPTR(A)	((A) += 2)
#define INC_VDATA(A,N)	((A) += (N))
#else
#define INC_VPTR(A)	((A) += 4)
#define INC_VDATA(A,N)	((A) += 2*(N))
#endif
#else
#define CMP_VPTR(A, B)	(*(A) == (ptrdiff_t)(B))
#define INC_VPTR(A)	((A) += 1)
#define INC_VDATA(A,N)	((A) += (N))
#endif

int main ()
{
  S4 s4;
  ptrdiff_t **vptr;
  ptrdiff_t *vtbl;

  // Set vtbl to point at the beginning of S4's primary vtable.
  vptr = (ptrdiff_t **) &s4;
  vtbl = *vptr;
  INC_VDATA (vtbl, -5);

  if (*vtbl != ((char*) (S0*) &s4) - (char*) &s4)
    return 1;
  INC_VDATA (vtbl, 1);
  if (*vtbl != ((char*) (S1*) &s4) - (char*) &s4)
    return 2;
  INC_VDATA (vtbl, 1);
  if (*vtbl != ((char*) (S2*) &s4) - (char*) &s4)
    return 3;
  INC_VDATA (vtbl, 1);
  if (*vtbl != 0)
    return 4;
  INC_VDATA (vtbl, 1);
  // Skip the RTTI entry.
  INC_VDATA (vtbl, 1);
  if (! CMP_VPTR (vtbl, &_ZN2S32s3Ev))
    return 5;
  INC_VPTR (vtbl);
  if (! CMP_VPTR (vtbl, &_ZN2S42s1Ev))
    return 6;
  INC_VPTR (vtbl);
  // The S1 vbase offset.
  if (*vtbl != 0)
    return 7;
  INC_VDATA (vtbl, 1);
  // The S4::s1 vcall offset is negative; once you convert to S2, you
  // have to convert to S4 to find the final overrider.
  if (*vtbl != ((char*) &s4 - (char*) (S2*) &s4))
    return 8;
  INC_VDATA (vtbl, 1);
  if (*vtbl != 0)
    return 9;
  INC_VDATA (vtbl, 1);
  if (*vtbl != 0)
    return 10;
  INC_VDATA (vtbl, 1);
  // Now we're at the S2 offset to top entry.
  if (*vtbl != ((char*) &s4 - (char*) (S2*) &s4))
    return 11;
  INC_VDATA (vtbl, 1);
  // Skip the RTTI entry.
  INC_VDATA (vtbl, 1);
  // Skip the remaining virtual functions -- they are thunks.
  INC_VPTR (vtbl);
  INC_VPTR (vtbl);
}

#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */

int main ()
{
}

#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
