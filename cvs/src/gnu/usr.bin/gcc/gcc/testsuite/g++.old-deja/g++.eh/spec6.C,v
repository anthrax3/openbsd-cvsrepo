head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.05;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.05;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// Build don't link:

// Copyright (C) 1999 Free Software Foundation, Inc.
// Contributed by Nathan Sidwell 19 Jan 1999 <nathan@@acm.org>

// Determine that throw specifiers are checked correctly.

// [except.spec] 1, a type in an exception specifier shall not be incomplete,
// or pointer or ref to incomplete
struct X;                         // ERROR - forward declaration.*
void fn1() throw(X);              // ERROR - invalid use of undefined type
void fn2() throw(X *);            // ERROR - invalid use of undefined type
void fn3() throw(X &);            // ERROR - invalid use of undefined tyoe
void fn4() throw(void);           // ERROR - invalid use of void expression
void fn5() throw(void &);         // ERROR - invalid type // ERROR - invalid use of void
// except for cv pointer to void
void fn6() throw(void *);         // ok -- pointer to void
void fn7() throw(void const *);   // ok -- pointer to cv void

template<class T> void fny() throw(T);  // ok (so far)
template<> void fny<int>() throw(int);  // ok
template<> void fny<void>() throw(void); // ERROR - invalid use of void

template<class T> void fnx(T *) throw(T){}  // ERROR - invalid use of void expression
void fx()
{
  fnx((int *)0);
  fnx((void *)0);		// ERROR - instantiated from here
}

// [except.spec] 2, exception specifiers must be the same set of types (but
// can be reordered)
void baz1() throw(int, char);
void baz1() throw(char, int){}       // reordering is ok

void baz2() throw(int, char);
void baz2() throw(int, char, int){}  // duplicates are ignored

typedef int Int;
void baz3() throw(int, char);
void baz3() throw(Int, char){}       // typedefs are the same type ...

void baz4() throw(int, Int, char);   // ... so this is a duplicate
void baz4() throw(Int, char){}

void fna() throw(int, char);  // ERROR - to previous declaration
void fna() throw(int const, char);  // ERROR - declaration  different exceptions // ERROR - to previous declaration
void fna() throw(int){}       // ERROR - declaration  different exceptions

void fnb() throw(int, char);  // ERROR - to previous declaration
void fnb() throw(char){}      // ERROR - declaration  different exceptions

void fnc() throw(int, char);  // ERROR - to previous declaration
void fnc() throw(char, int, float){}  // ERROR - declaration  different exceptions

void fnd() throw();           // ERROR - to previous declaration
void fnd() throw(char){}      // ERROR - declaration  different exceptions

void fne() throw(char);       // ERROR - to previous declaration
void fne() throw(){}          // ERROR - declaration  different exceptions

void fnf();                   // ERROR - to previous declaration
void fnf() throw(char){}      // ERROR - declaration  different exceptions

void fng() throw(char);       // ERROR - to previous declaration
void fng(){}                  // ERROR - declaration  different exceptions

void fnh() throw(int, char);  // ERROR - to previous declaration
void fnh() throw(int, float){}   // ERROR - declaration  different exceptions

void fni() throw(int, char);  // ERROR - to previous declaration
void fni() throw(float, char){}  // ERROR - declaration  different exceptions

// [except.spec] 3, virtual function overriders shall throw a subset of the
// overridden function
struct E {};
struct F : public E {};
struct F1 : public E {};
struct G : public F, F1 {};
struct H : private E {};
struct A
{
  virtual void foo() throw();             // ERROR - overriding 
  virtual void baz() throw(double, int);
  virtual void bar();
  virtual void qux() throw(E);
  virtual void qux(int) throw(E const *); // ERROR - overriding (pedantically)
  virtual void quux() throw(F);           // ERROR - overriding 
  virtual void quux(int) throw(F *);      // ERROR - overriding 
  virtual void wibble() throw(E);         // ERROR - overriding 
  virtual void wobble() throw(E *);       // ERROR - overriding 
  virtual void wobble(int) throw(E *);    // ERROR - overriding 
  virtual void wabble(int) throw(E *);
  virtual void wubble(int) throw(E *, H *);
  virtual ~A() throw();                   // ERROR - overriding
};

struct B : A
{
  virtual void foo() throw(int);          // ERROR - looser throw - A::foo
  virtual void baz() throw(double);       // ok subset
  virtual void bar(int) throw(int);       // ok not overriding
  virtual void qux() throw(F);            // ok subset
  virtual void qux(int) throw(F *);       // ERROR - looser (pedantically)
  virtual void quux() throw(E);           // ERROR - looser throw - A::quux()
  virtual void quux(int) throw(E *);      // ERROR - looser throw - A::quux(int)
  virtual void wibble() throw(E *);       // ERROR - looser throw - A::wibble
  virtual void wobble() throw(G *);       // ERROR - looser throw - A::wobble()
  virtual void wobble(int) throw(H *);    // ERROR - looser throw - A::wobble(int)
  virtual void wubble(int) throw(H *);    // ok
  virtual void wabble(int) throw(F1 *, F *);    // ok
};

struct A1
{
  virtual void foo() throw(int);
  virtual void bar() throw();       // ERROR - overriding 
  virtual ~A1() throw(int);
};

struct B1 : A
{
};

struct C : A, A1
{ // ERROR - looser throw - A::~A()
  virtual void foo() throw(int);    // ERROR - looser throw - A::foo
  virtual void bar() throw(int);    // ERROR - looser throw - A1::bar
};

struct D : A, A1
{
  virtual ~D() throw(int); // ERROR - looser throw - A::~A()
};

// [except.spec] 5, types shall not be defined in exception specifiers
void fn8() throw(struct Z {}); // ERROR - ANSI C++ forbids 
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
