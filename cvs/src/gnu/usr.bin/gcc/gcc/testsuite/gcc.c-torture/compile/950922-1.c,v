head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.58
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.36;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.36;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@struct sw {
  const void *x;
  int r;
};
struct sq {
  struct sw *q_w;
  int t;
  int z;
};

int
f (int ch, char *fp, char *ap)
{
  register int n;
  register char *cp;
  register struct sw *p;
  register int f;
  int prec;
  double _double;
  int expt;
  int ndig;
  char expstr[7];
  unsigned long long _uquad;
  struct sq q;
  struct sw w[8];
  static char zeroes[16];

  for (;;) {
    switch (ch) {
    case 'd':
      _double = (double) (ap += 8, *((double *) (ap - 8)));
      break;
    case 'o':
      goto nosign;
    case 'u':
      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
      goto nosign;
    case 'x':
      _uquad = (f & 0x020 ? (ap += 8, *((long long *) (ap - 8))) : f & 0x010 ? (ap += 4, *((long *) (ap - 4))) : f & 0x040 ? (long)(unsigned short)(ap += 4, *((int *) (ap - 4))) : (long)(ap += 4, *((int *) (ap - 4))));
    nosign:
      if (_uquad != 0 || prec != 0);
      break;
    default:
    }
    if ((f & 0x100) == 0) {
    } else {
      if (ch >= 'f') {
	if (_double == 0) {
	  if (expt < ndig || (f & 0x001) != 0) {
	    { if ((n = (ndig - 1)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}}}
	  }
	} else if (expt <= 0) {
	  { p->x = ("0"); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { p->x = 0; p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { if ((n = (-expt)) > 0) { while (n > 16) {{ p->x = (zeroes); p->r = 16; q.z += 16; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} n -= 16; }{ p->x = (zeroes); p->r = n; q.z += n; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }} }}
	  { p->x = cp; p->r = ndig; q.z += ndig; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	} else {
	  { p->x = cp; p->r = expt; q.z += expt; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  cp += expt;
	  { p->x = ("."); p->r = 1; q.z += 1; p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	  { p->x = cp; p->r = (ndig-expt); q.z += (ndig-expt); p++; if (++q.t >= 8) { if (g(fp, &q)) goto error; p = w; }}
	}
      }
    }
  }

 error:
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
