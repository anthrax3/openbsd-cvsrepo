head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.58
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.37;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.37;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@struct obstack
{
  long chunk_size;
  struct _obstack_chunk *chunk;
  char *object_base;
  char *next_free;
  char *chunk_limit;
  int alignment_mask;
  unsigned maybe_empty_object;
};

struct objfile
  {
    struct objfile *next;
    struct obstack type_obstack;
  };

struct type
  {
    unsigned length;
    struct objfile *objfile;
    short nfields;
    struct field
      {
        union field_location
          {
            int bitpos;
            unsigned long physaddr;
            char *physname;
          }
        loc;
        int bitsize;
        struct type *type;
        char *name;
      }
     *fields;
  };

struct type *alloc_type (void);
void * xmalloc (unsigned int z);
void _obstack_newchunk (struct obstack *o, int i);
void get_discrete_bounds (long long *lowp, long long *highp);

extern void *memset(void *, int, __SIZE_TYPE__);

struct type *
create_array_type (struct type *result_type, struct type *element_type)
{
  long long low_bound, high_bound;
  if (result_type == ((void *)0))
    {
      result_type = alloc_type ();
    }
  get_discrete_bounds (&low_bound, &high_bound);
  (result_type)->length =
    (element_type)->length * (high_bound - low_bound + 1);
  (result_type)->nfields = 1;
  (result_type)->fields =
    (struct field *) ((result_type)->objfile != ((void *)0) 
		      ? (
		      {
			struct obstack *__h = 
			  (&(result_type)->objfile -> type_obstack);
			{
			  struct obstack *__o = (__h);
			  int __len = ((sizeof (struct field)));
			  if (__o->chunk_limit - __o->next_free < __len)
			    _obstack_newchunk (__o, __len); 
			  __o->next_free += __len; (void) 0;
			};
			({
			  struct obstack *__o1 = (__h); 
			  void *value; 
			  value = (void *) __o1->object_base;
			  if (__o1->next_free == value)
			    __o1->maybe_empty_object = 1;
			  __o1->next_free = (((((__o1->next_free) - (char *) 0)
					       +__o1->alignment_mask) 
					      & ~ (__o1->alignment_mask)) 
					     + (char *) 0);
			  if (__o1->next_free - (char *)__o1->chunk 
			      > __o1->chunk_limit - (char *)__o1->chunk)
			    __o1->next_free = __o1->chunk_limit;
			  __o1->object_base = __o1->next_free; 
			  value;
			});
		      }) : xmalloc (sizeof (struct field)));
  return (result_type);
}

struct type *
alloc_type (void)
{
  abort ();
}
void * xmalloc (unsigned int z)
{
  return 0;
}
void _obstack_newchunk (struct obstack *o, int i)
{
  abort ();
}
void
get_discrete_bounds (long long *lowp, long long *highp)
{
  *lowp = 0;
  *highp = 2;
}

int main(void)
{
  struct type element_type;
  struct type result_type;
  
  memset (&element_type, 0, sizeof (struct type));
  memset (&result_type, 0, sizeof (struct type));
  element_type.length = 4;
  create_array_type (&result_type, &element_type);
  if (result_type.length != 12)
    abort ();
  exit (0);
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
