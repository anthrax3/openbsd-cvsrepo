head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.37.36;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.37.36;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@typedef enum
{
  LODI,
  STO,
  ADDI,
  ADD,
  SUBI,
  SUB,
  MULI,
  MUL,
  DIVI,
  DIV,
  INC,
  DEC
} INSN;

f (pc)
     short *pc;
{
  long long stack[16], *sp = &stack[16], acc = 0;

  for (;;)
    {
      switch ((INSN)*pc++)
	{
	case LODI:
	  *--sp = acc;
	  acc = ((long long)*pc++) << 32;
	  break;
	case STO:
	  return (acc >> 32) + (((((unsigned long long) acc) & 0xffffffff)  & (1 << 31)) != 0);
	  break;
	case ADDI:
	  acc += ((long long)*pc++) << 32;
	  break;
	case ADD:
	  acc = *sp++ + acc;
	  break;
	case SUBI:
	  acc -= ((long long)*pc++) << 32;
	  break;
	case SUB:
	  acc = *sp++ - acc;
	  break;
	case MULI:
	  acc *= *pc++;
	  break;
	case MUL:
	  {
	    long long aux;
	    unsigned char minus;

	    minus = 0;
	    aux = *sp++;
	    if (aux < 0)
	      {
		minus = ~minus;
		aux = -aux;
	      }
	    if (acc < 0)
	      {
		minus = ~minus;
		acc = -acc;
	      }
	    acc = ((((((unsigned long long) acc) & 0xffffffff)  * (((unsigned long long) aux) & 0xffffffff)) >> 32)
		   + ((((unsigned long long) acc) >> 32)  * (((unsigned long long) aux) & 0xffffffff)  + (((unsigned long long) acc) & 0xffffffff)  + (((unsigned long long) aux) >> 32))
		   + (((((unsigned long long) acc) >> 32)  * (((unsigned long long) aux) >> 32)) << 32));
	    if (minus)
	      acc = -acc;
	  }
	  break;
	case DIVI:
	  {
	    short aux;

	    aux = *pc++;
	    acc = (acc + aux / 2) / aux;
	  }
	  break;
	case DIV:
	  {
	    long long aux;
	    unsigned char minus;

	    minus = 0;
	    aux = *sp++;
	    if (aux < 0)
	      {
		minus = ~minus;
		aux = -aux;
	      }
	    if (acc < 0)
	      {
		minus = ~minus;
		acc = -acc;
	      }

	    if (((unsigned long long)acc)  == 0)
	      acc = (unsigned long long)-1 / 2;
	    else if ((((unsigned long long) ((unsigned long long)acc)) & 0xffffffff)  == 0)
	      acc = ((unsigned long long)aux)  / (((unsigned long long) ((unsigned long long)acc)) >> 32);
	    else if ((((unsigned long long) ((unsigned long long)acc)) >> 32)  == 0)
	      acc = ((((unsigned long long)aux)  / ((unsigned long long)acc)) << 32)
		+ ((((unsigned long long)aux)  % ((unsigned long long)acc)) << 32) / ((unsigned long long)acc);
	    else
	      {
		unsigned char shift;
		unsigned long hi;

		shift = 32;
		hi = (((unsigned long long) ((unsigned long long)acc)) >> 32);
		do {
		  if (hi & ((unsigned long)1 << (shift - 1)))
		    break;
		} while (--shift != 0);
		printf("shift = %d\n", shift);
		acc = ((((unsigned long long)aux)  / ((unsigned long long)acc)) << 32)
		  + (((((unsigned long long)aux)  % ((unsigned long long)acc)) << (32 - shift)) + ((((unsigned long long)acc)  >> shift) / 2)) / (((unsigned long long)acc)  >> shift);
	      }

	    if (minus)
	      acc = -acc;
	  }
	  break;
	case INC:
	  acc += 1;
	  break;
	case DEC:
	  acc -= 1;
	  break;
	}
      printf("%08lx.%08lx\n", (long)(((unsigned long long) acc) >> 32) , (long)(((unsigned long long) acc) & 0xffffffff));
    }
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
