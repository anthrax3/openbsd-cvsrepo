head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.58
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2003.11.29.12.38.03;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.38.03;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#   Copyright (C) 1997, 2001 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  

# Verify various kinds of gcov output: line counts, branch percentages,
# and call return percentages.  None of this is language-specific.

global GCOV

#
# clean-gcov -- delete the working files the compiler creates for gcov
#
# TESTCASE is the name of the test.
#
proc clean-gcov { testcase } {
    set basename [file tail $testcase]
    set base [file rootname $basename]
    remote_file host delete $base.bb $base.bbg $base.da $basename.gcov
}

#
# verify-lines -- check that line counts are as expected
#
# TESTCASE is the name of the test.
# FILE is the name of the gcov output file.
#
proc verify-lines { testcase file } {
    #send_user "verify-lines\n"
    set failed 0
    set fd [open $file r]
    while { [gets $fd line] >= 0 } {
	if [regexp "^ *(\[^:]*): *(\[0-9\]+):.*count\\((\[0-9\]+)\\)" \
		"$line" all is n shouldbe] {
	    if { $is == "" } {
		fail "$n:no data available for this line"
		incr failed
	    } elseif { $is != $shouldbe } {
		fail "$n:is $is:should be $shouldbe"
		incr failed
	    }
	}
    }
    return $failed
}

#
# verify-branches -- check that branch percentages are as expected
#
# TESTCASE is the name of the test.
# FILE is the name of the gcov output file.
#
# Checks are based on comments in the source file.  This means to look for
# branch percentages 10 or 90, 20 or 80, and # 70 or 30:
#     /* branch(10, 20, 70) */
# This means that all specified percentages should have been seen by now:
#     /* branch(end) */
# All specified percentages must also be seen by the next branch(n) or
# by the end of the file.
#
# Each check depends on the compiler having generated the expected
# branch instructions.  Don't check for branches that might be
# optimized away or replaced with predicated instructions.
#
proc verify-branches { testcase file } {
    #send_user "verify-branches\n"
    set failed 0
    set shouldbe ""
    set fd [open $file r]
    set n 0
    while { [gets $fd line] >= 0 } {
	regexp "^\[^:\]+: *(\[0-9\]+):" "$line" all n
	if [regexp "branch" $line] {
	    verbose "Processing branch line $n: $line" 3
	    if [regexp "branch\\((\[0-9 \]+)\\)" "$line" all new_shouldbe] {
		# All percentages in the current list should have been seen.
		if {[llength $shouldbe] != 0} {
		    fail "$n: expected branch percentages not found: $shouldbe"
		    incr failed
		    set shouldbe ""
		}
		set shouldbe $new_shouldbe
		#send_user "$n: looking for: $shouldbe\n"
	        # Record the percentages to check for. Replace percentage
		# n > 50 with 100-n, since block ordering affects the
		# direction of a branch.
		for {set i 0} {$i < [llength $shouldbe]} {incr i} {
		    set num [lindex $shouldbe $i]
		    if {$num > 50} {
			set shouldbe [lreplace $shouldbe $i $i [expr 100 - $num]]
		    }
		}
	    } elseif [regexp "branch +\[0-9\]+ taken (-\[0-9\]+)%" "$line" \
			all taken] {
		# Percentages should never be negative.
		fail "$n: negative percentage: $taken"
		incr failed
	    } elseif [regexp "branch +\[0-9\]+ taken (\[0-9\]+)%" "$line" \
			all taken] {
		#send_user "$n: taken = $taken\n"
		# Percentages should never be greater than 100.
		if {$taken > 100} {
		    fail "$n: percentage greater than 100: $taken"
		    incr failed
		}
		if {$taken > 50} {
		    set taken [expr 100 - $taken]
		}
		# If this percentage is one to check for then remove it
		# from the list.  It's normal to ignore some reports.
		set i [lsearch $shouldbe $taken]
		if {$i != -1} {
		    set shouldbe [lreplace $shouldbe $i $i]
		}
	    } elseif [regexp "branch\\(end\\)" "$line"] {
		# All percentages in the list should have been seen by now.
		if {[llength $shouldbe] != 0} {
		    fail "$n: expected branch percentages not found: $shouldbe"
		    incr failed
		}
		set shouldbe ""
	    }
	}
    }
    # All percentages in the list should have been seen.
    if {[llength $shouldbe] != 0} {
	fail "$n: expected branch percentages not found: $shouldbe"
	incr failed
    }
    close $fd
    return $failed
}

#
# verify-calls -- check that call return percentages are as expected
#
# TESTCASE is the name of the test.
# FILE is the name of the gcov output file.
#
# Checks are based on comments in the source file.  This means to look for
# call return percentages 50, 20, 33:
#     /* returns(50, 20, 33) */
# This means that all specified percentages should have been seen by now:
#     /* returns(end) */
# All specified percentages must also be seen by the next returns(n) or
# by the end of the file.
#
# Each check depends on the compiler having generated the expected
# call instructions.  Don't check for calls that are inserted by the
# compiler or that might be inlined.
#
proc verify-calls { testcase file } {
    #send_user "verify-calls\n"
    set failed 0
    set shouldbe ""
    set fd [open $file r]
    set n 0
    while { [gets $fd line] >= 0 } {
	regexp "^\[^:\]+: *(\[0-9\]+):" "$line" all n
	if [regexp "returns" $line] {
	    verbose "Processing returns line $n: $line" 3
	    if [regexp "returns\\((\[0-9 \]+)\\)" "$line" all new_shouldbe] {
		# All percentages in the current list should have been seen.
		if {[llength $shouldbe] != 0} {
		    fail "$n: expected return percentages not found: $shouldbe"
		    incr failed
		    set shouldbe ""
		}
	        # Record the percentages to check for.
		set shouldbe $new_shouldbe
	    } elseif [regexp "call +\[0-9\]+ returns (-\[0-9\]+)%" "$line" \
			all returns] {
		# Percentages should never be negative.
		fail "$n: negative percentage: $returns"
		incr failed
	    } elseif [regexp "call +\[0-9\]+ returns (\[0-9\]+)%" "$line" \
			all returns] {
		# For branches we check that percentages are not greater than
		# 100 but call return percentages can be, as for setjmp(), so
		# don't count that as an error.
		#
		# If this percentage is one to check for then remove it
		# from the list.  It's normal to ignore some reports.
		set i [lsearch $shouldbe $returns]
		if {$i != -1} {
		    set shouldbe [lreplace $shouldbe $i $i]
		}
	    } elseif [regexp "returns\\(end\\)" "$line"] {
		# All percentages in the list should have been seen by now.
		if {[llength $shouldbe] != 0} {
		    fail "$n: expected return percentages not found: $shouldbe"
		    incr failed
		}
		set shouldbe ""
	    }
	}
    }
    # All percentages in the list should have been seen.
    if {[llength $shouldbe] != 0} {
	fail "$n: expected return percentages not found: $shouldbe"
	incr failed
    }
    close $fd
    return $failed
}

# Called by dg-final to run gcov and analyze the results.
#
# ARGS is the options to pass to gcov followed by the name of the
# test source file.

proc run-gcov { args } {
    global GCOV
    global srcdir subdir

    # Extract the test name from the arguments.
    set testcase [lindex $args end]

    # Get special options for this test from the .x script, if present.
    # This can include:
    #   gcov_execute_xfail     string to pass to setup_xfail
    #   gcov_verify_xfail      string to pass to setup_xfail
    #   gcov_verify_branches   if defined, check branch percentages
    #   gcov_verify_calls      if defined, check call return percentages
    if [file exists [file rootname $srcdir/$subdir/$testcase].x] {
	set done_p 0
	catch "set done_p \[source [file rootname $srcdir/$subdir/$testcase].x\]"
	if { $done_p } {
	    return
	}
    }

    if [info exists gcov_execute_xfail] {
	eval setup_xfail [split $gcov_execute_xfail]
    }

    verbose "Running $GCOV $testcase" 2
    set testcase [remote_download host $testcase];
    set result [remote_exec host $GCOV $args];
    if { [lindex $result 0] != 0 } {
	fail "$subdir/$testcase gcov failed: [lindex $result 1]"
	clean-gcov $testcase
	return
    }

    # Get the gcov output file after making sure it exists.
    set files [glob -nocomplain $testcase.gcov]
    if { $files == "" } {
        fail "$subdir/$testcase gcov failed: $testcase.gcov does not exist"
        clean-gcov $testcase
        return;
    }
    remote_upload host $testcase.gcov $testcase.gcov;

    if [info exists gcov_verify_xfail] {
	eval setup_xfail [split $gcov_verify_xfail]
    }

    # Check that line execution counts are as expected.
    set lfailed [verify-lines $testcase $testcase.gcov]

    # If requested via the .x file, check that branch and call information
    # is correct.
    if [info exists gcov_verify_branches] {
	set bfailed [verify-branches $testcase $testcase.gcov]
    } else {
	set bfailed 0
    }
    if [info exists gcov_verify_calls] {
	set cfailed [verify-calls $testcase $testcase.gcov]
    } else {
	set cfailed 0
    }

    # Report whether the gcov test passed or failed.  If there were
    # multiple failures then the message is a summary.
    set tfailed [expr $lfailed + $bfailed + $cfailed]
    if { $tfailed > 0 } {
	fail "$subdir/$testcase gcov: $lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages"
    } else {
	pass "$subdir/$testcase gcov"
	clean-gcov $testcase
    }
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
