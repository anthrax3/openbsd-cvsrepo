head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.58
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.36.53;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.36.53;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// Try to check that registers are preserved when the stack is unwound.
// { dg-do run }
// { dg-options -O2 }

extern "C" void exit(int);
extern "C" void abort();

// This test case triggers up to DEPTH recursive calls to function
// foo(), These calls are numbered so that 0 is the innermost, 1 the
// second innermost, and so on.  Each call caches NUM_VARS elements of
// both DOUBLE_SRC and INT_SRC and applies a trivial operation to each
// cached value.  The innermost foo() call will throw an integer call
// number.  The specified call should store its cached values in
// DOUBLE_DEST and INT_DEST, which main() will check.
const int num_vars = 16;
const int depth = 3;

float float_src[num_vars * depth];
float float_dest[num_vars];

int int_src[num_vars * depth];
int int_dest[num_vars];

void foo (int level, int throw_to)
{
  float *fsrc = &float_src[level * num_vars];
  float f00 = *fsrc++ + 1.0f;
  float f01 = *fsrc++ + 1.0f;
  float f02 = *fsrc++ + 1.0f;
  float f03 = *fsrc++ + 1.0f;
  float f04 = *fsrc++ + 1.0f;
  float f05 = *fsrc++ + 1.0f;
  float f06 = *fsrc++ + 1.0f;
  float f07 = *fsrc++ + 1.0f;
  float f08 = *fsrc++ + 1.0f;
  float f09 = *fsrc++ + 1.0f;
  float f10 = *fsrc++ + 1.0f;
  float f11 = *fsrc++ + 1.0f;
  float f12 = *fsrc++ + 1.0f;
  float f13 = *fsrc++ + 1.0f;
  float f14 = *fsrc++ + 1.0f;
  float f15 = *fsrc++ + 1.0f;

  int *isrc = &int_src[level * num_vars];
  int i00 = *isrc++ + 1;
  int i01 = *isrc++ + 1;
  int i02 = *isrc++ + 1;
  int i03 = *isrc++ + 1;
  int i04 = *isrc++ + 1;
  int i05 = *isrc++ + 1;
  int i06 = *isrc++ + 1;
  int i07 = *isrc++ + 1;
  int i08 = *isrc++ + 1;
  int i09 = *isrc++ + 1;
  int i10 = *isrc++ + 1;
  int i11 = *isrc++ + 1;
  int i12 = *isrc++ + 1;
  int i13 = *isrc++ + 1;
  int i14 = *isrc++ + 1;
  int i15 = *isrc++ + 1;

  try
    {
      if (level == 0)
	throw throw_to;
      else
	foo (level - 1, throw_to);
    }
  catch (int i)
    {
      if (i == level)
	{
	  float *fdest = float_dest;
	  *fdest++ = f00;
	  *fdest++ = f01;
	  *fdest++ = f02;
	  *fdest++ = f03;
	  *fdest++ = f04;
	  *fdest++ = f05;
	  *fdest++ = f06;
	  *fdest++ = f07;
	  *fdest++ = f08;
	  *fdest++ = f09;
	  *fdest++ = f10;
	  *fdest++ = f11;
	  *fdest++ = f12;
	  *fdest++ = f13;
	  *fdest++ = f14;
	  *fdest++ = f15;

	  int *idest = int_dest;
	  *idest++ = i00;
	  *idest++ = i01;
	  *idest++ = i02;
	  *idest++ = i03;
	  *idest++ = i04;
	  *idest++ = i05;
	  *idest++ = i06;
	  *idest++ = i07;
	  *idest++ = i08;
	  *idest++ = i09;
	  *idest++ = i10;
	  *idest++ = i11;
	  *idest++ = i12;
	  *idest++ = i13;
	  *idest++ = i14;
	  *idest++ = i15;
	}
      else
	{
	  throw;
	}
    }
}

int main ()
{
  for (int i = 0; i < depth * num_vars; i++)
    {
      int_src[i] = i * i;
      float_src[i] = i * 2.0f;
    }
  for (int level = 0; level < depth; level++)
    for (int throw_to = 0; throw_to <= level; throw_to++)
      {
	foo (level, throw_to);
	float *fsrc = &float_src[throw_to * num_vars];
	int *isrc = &int_src[throw_to * num_vars];
	for (int i = 0; i < num_vars; i++)
	  {
	    if (int_dest[i] != isrc[i] + 1)
	      abort ();
	    if (float_dest[i] != fsrc[i] + 1.0f)
	      abort ();
	  }
      }
  exit (0);
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
