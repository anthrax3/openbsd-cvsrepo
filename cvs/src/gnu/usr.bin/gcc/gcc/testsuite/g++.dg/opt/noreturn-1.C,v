head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.48
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.44
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.46
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.38
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.42
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.40
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.36
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.34
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.32
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.30
	OPENBSD_5_0:1.1.1.1.0.28
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.26
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.24
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.20
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.22
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.18
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.16
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.14
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.12
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.10
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.8
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.6
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.4
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.2
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2004.12.24.23.53.36;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.12.24.23.53.36;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// PR optimization/12965
// Origin: <qboosh@@pld-linux.org>
// Reduced testcase: Falk Hueffner <falk@@debian.org>

// This ICEd on Alpha because the reload pass emitted save/restore
// insns around a no-return call.

// { dg-do compile }
// { dg-options "-O2" }

template <typename _Alloc> class allocator;
template <class _CharT> struct char_traits;
template <typename _CharT,
	  typename _Traits = char_traits<_CharT>,
	  typename _Alloc = allocator<_CharT> >
class basic_string;
typedef basic_string<char> string;

static inline int __exchange_and_add(volatile int * __mem, int __val) {
    int __result;
    asm("" : "=&r"(__result));
    return __result;
}

template<typename _Tp> struct allocator {
    allocator() throw() { }
    allocator(const allocator &) throw() {}
};

template<typename _CharT, typename _Traits, typename _Alloc>
struct basic_string {
    typedef _Alloc allocator_type;
    struct _Rep {
	int _M_references;
	void _M_dispose(const _Alloc & __a) {
	    if (__exchange_and_add(&_M_references, -1) <= 0)
		_M_destroy(__a);
	} void _M_destroy(const _Alloc &) throw();
    };
    struct _Alloc_hider : _Alloc {
	_CharT *_M_p;
    };
    mutable _Alloc_hider _M_dataplus;
    _CharT *_M_data() const { return _M_dataplus._M_p; }
    _Rep *_M_rep() const {
	return &((reinterpret_cast<_Rep *>(_M_data()))[-1]);
    }
    basic_string();
    basic_string(const _CharT * __s, const _Alloc & __a = _Alloc());
    ~basic_string() {
	_M_rep()->_M_dispose(this->get_allocator());
    }
    allocator_type get_allocator() const { return _M_dataplus; }
};

struct Egeneric {
    void stack(const string & passage, const string & message = "") { }
};

struct infinint {
    void detruit() throw(Egeneric);
    template<class T> void infinint_from(T a) throw(Egeneric);
    infinint(long a = 0) throw(Egeneric) {
	try {
	    infinint_from(a);
	} catch(Egeneric& e) {
	    e.stack("infinint::infinint", "long");
	}
    }
    ~infinint() throw(Egeneric) {
	try {
	    detruit();
	} catch(Egeneric& e) { }
    }
};

struct inode {
    string x;
    infinint a, c;
    infinint ea_offset;
    inode();
};

inode::inode()
{
    ea_offset = 0;
}
@


1.1.1.1
log
@gcc 3.3.5
@
text
@@
