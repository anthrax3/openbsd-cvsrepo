head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.36.55;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.36.55;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// This testcase was miscompiled on IA-64 to read from unitialized memory
// and dereference it.
// { dg-do run }
// { dg-options "-O2" }

struct A
{
  A () { a = 1; }
  void a1 () { a++; }
  bool a2 () { return !--a; }
  unsigned int a;
};

struct B {};

template <class T> struct C
{
  C () {}
  C (const T& t) : c (t) {}
  C<T> *next, *prev;
  T c;
};

template <class T> struct D
{
  C<T> *d;
  D () : d (0) {}
  D (C<T> *x) : d (x) {}
  D (const D<T>& x) : d (x.d) {}
  bool operator!= (const D<T>& x) const { return d != x.d; }
  const T& operator* () const { return d->c; }
  D<T> operator++ (int) { D<T> t = *this; d = d->next; return t; }
};

template <class T> struct E
{
  C<T> *e;
  E () : e (0) {}
  E (C<T> *p) : e (p) {}
  E (const E<T>& x) : e (x.e) {}
  E (const D<T>& x) : e (x.e) {}
  bool operator!= (const E<T>& x) const { return e != x.e; }
  const T& operator* () const { return e->c; }
  E<T>& operator++ () { e = e->next; return *this; }
};

template <class T> struct F : public A
{
  C<T> *f;
  unsigned long f0;
  F () { f = new C<T>; f->next = f->prev = f; f0 = 0; }
  F (const F<T>& x) : A ()
  {
    f = new C<T>; f->next = f->prev = f; f0 = 0;
    D<T> b (x.f->next), e (x.f), i (f);
    while (b != e)
      f1 (i, *b++);
  }

  ~F ()
  {
    C<T> *p = f->next;
    while (p != f)
      {
	C<T> *x = p->next;
	delete p;
	p = x;
      }
    delete f;
  }

  D<T> f1 (D<T> x, const T& y)
  {
    C<T> *p = new C<T> (y);
    p->next = x.d;
    p->prev = x.d->prev;
    x.d->prev->next = p;
    x.d->prev = p;
    f0++;
    return p;
  }
};

template <class T> struct G
{
  F<T> *g;
  G () { g = new F<T>; }
  G (const G<T>& x) { g = x.g; g->a1 (); }
  ~G () {}
  G<T>& operator= (const G<T>& x) { x.g->a1 (); g = x.g; return *this; }
  D<T> g1 () { g4 (); return D<T> (g->f); }
  E<T> g1 () const { return E<T> (g->f); }
  E<T> g2 () const { return E<T> (g->f->next); }
  D<T> g3 (const T& x) { g4 (); return g->f1 (g1 (), x); }
  void g4 () { if (g->a > 1) { g->a2 (); g = new F<T> (*g); } }

  G<T> operator+ (const G<T>& x) const
  {
    G<T> x2 (*this);
    for (E<T> i = x.g2 (); i != x.g1 (); ++i)
      x2.g3 (*i);
    return x2;
  }

  G<T>& operator+= (const G<T>& x)
  {
    for (E<T> i = x.g2 (); i != x.g1 (); ++i)
      g3 (*i);
    return *this;
  }
};

struct H : public G<B>
{
  H () {}
  H (const H& x) : G<B> (x) {}
  H (const G<B>& x) : G<B> (x) {}
};

void foo ();

int
main ()
{
  H a = H () + H ();
  a += H ();
  H b;
  b = H () + H ();
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
