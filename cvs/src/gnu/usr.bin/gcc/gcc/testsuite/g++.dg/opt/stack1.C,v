head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.54
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2003.11.29.12.36.55;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.36.55;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// PR optimization/11198
// Origin: Joerg Walter <jhr.walter@@t-online.de>
// Reduced testcase by: Volker Reichelt <reichelt@@igpm.rwth-aachen.de>
//                      Wolfgang Bangerth <bangerth@@ticam.utexas.edu>

// The compiler used to allocate the same stack slot for two aggregates,
// overlooking that assignments to members given the same address on the
// stack may not alias and thus may be reordered by the scheduling passes.

// { dg-do run }
// { dg-options "-O2 -frename-registers" }


double zero_;

inline const int&
min(const int& a, const int& b) {
  if (b < a) return b; return a;
}

struct barrier { barrier () {} };

template <typename=void> struct unbounded_array {
    inline unbounded_array (): data_ (new double [9]) {}
    inline double& operator [] (int i) { return data_ [i]; }
    double* data_;
};

inline int element (int i, int j) {
  return i + j;
}

template <typename=void>
struct matrix {
    inline matrix () : size2_ (3) {}

    inline unbounded_array<> &data () { return data_; }

    inline double& el (int i, int j) {
      int dead1 = j;
      int dead2 = 1 + i - j;
      if (j < size2_ && i-j < 2)
	return data () [element (j,i-j+1)];
      barrier ();
      return zero_;
    }

    struct iterator2;

    inline iterator2 find () {
      return iterator2 (*this);
    }

    struct iterator1 {
        inline iterator1 (matrix *m):
			dead1 (m), i (0) {}
	void *dead1;
        int i;
        int dead2;
    };

    const int size2_;
    unbounded_array<> data_;
};


template<typename=void>
struct adaptor {
    adaptor (matrix<> &m) : m(&m), upper_ (1) {}

    int size1 () const     { return m->size1 (); }
    int size2 () const     { return 3; }
    int lower () const     { return 1; }
    int upper () const     { return upper_; }
    matrix<> &data () { return *m; }

    double& el (int i, int j) {
      int dead1, dead2;
      if (j < size2 () && i-j < 1)
	return data ().el (i, j);

      barrier ();
      return zero_;
    }

    struct a_iterator2;

    struct a_iterator1 {
        a_iterator1 (adaptor &a, const matrix<>::iterator1 &it1):
			a (&a), dead1 (it1) {}

        a_iterator2 begin () const {
	  return a_iterator2(*a);
        }
	adaptor *a;	
        matrix<>::iterator1 dead1;
    };

    struct a_iterator2 {
        a_iterator2 (adaptor &a) : a (&a) {}

        double& f () const {
	  int i = 0;
	  int l = a->upper () + i;
	  int q = a->size2 ();
	  if (0 < q &&
	      l < a->lower () + 1 + a->upper ())
	    return a->m->el(0,0);

	  return a->el (i, 0);
        }

	adaptor *a;
    };

    matrix<> *m;
    int upper_;
};

void matrix_swap (adaptor<> &bam1, adaptor<> &bam2)
{
  adaptor<>::a_iterator1 it1 (bam1,matrix<>::iterator1(bam1.m)),
                         it2 (bam2,matrix<>::iterator1(bam2.m));
  int dead;
  double x = it1.begin().f();
  it2.begin().f() = x;
}

int main ()
{
  matrix<> m1,m2;
  adaptor<> bam1 (m1), bam2 (m2);
  matrix_swap (bam1, bam2);
  return 0;
}
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
