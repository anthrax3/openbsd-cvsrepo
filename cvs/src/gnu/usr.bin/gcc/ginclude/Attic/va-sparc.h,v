head	1.3;
access;
symbols
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	FSF_2_8_1:1.1.1.2
	FSF_2_8_0:1.1.1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	FSF_2_7_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	99.05.26.16.30.34;	author espie;	state dead;
branches;
next	1.2;

1.2
date	98.03.03.21.36.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.20.01.05.57;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.12.20.01.05.57;	author niklas;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	98.02.14.19.25.05;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@So long, and thanks for all the bugs.
@
text
@/* This is just like the default gvarargs.h
   except for differences described below.  */

/* Define __gnuc_va_list.  */

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST
#if ! defined (__svr4__) && ! defined (__linux__) && ! defined (__arch64__)
/* This has to be a char * to be compatible with Sun.
   i.e., we have to pass a `va_list' to vsprintf.  */
typedef char * __gnuc_va_list;
#else
/* This has to be a void * to be compatible with Sun svr4.
   i.e., we have to pass a `va_list' to vsprintf.  */
typedef void * __gnuc_va_list;
#endif
#endif /* not __GNUC_VA_LIST */

/* If this is for internal libc use, don't define anything but
   __gnuc_va_list.  */
#if defined (_STDARG_H) || defined (_VARARGS_H)

#ifdef _STDARG_H

/* Call __builtin_next_arg even though we aren't using its value, so that
   we can verify that LASTARG is correct.  */
#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)
#define va_start(AP, LASTARG) \
  (__builtin_next_arg (LASTARG), AP = (char *) __builtin_saveregs ())
#else
#define va_start(AP, LASTARG)					\
  (__builtin_saveregs (), AP = ((char *) __builtin_next_arg (LASTARG)))
#endif

#else

#define va_alist  __builtin_va_alist
#define va_dcl    int __builtin_va_alist;...

#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)
#define va_start(AP)	((AP) = (char *) __builtin_saveregs ())
#else
#define va_start(AP) \
  (__builtin_saveregs (), (AP) = ((char *) &__builtin_va_alist))
#endif

#endif

#ifndef va_end
void va_end (__gnuc_va_list);		/* Defined in libgcc.a */

/* Values returned by __builtin_classify_type.  */

enum __va_type_classes {
  __no_type_class = -1,
  __void_type_class,
  __integer_type_class,
  __char_type_class,
  __enumeral_type_class,
  __boolean_type_class,
  __pointer_type_class,
  __reference_type_class,
  __offset_type_class,
  __real_type_class,
  __complex_type_class,
  __function_type_class,
  __method_type_class,
  __record_type_class,
  __union_type_class,
  __array_type_class,
  __string_type_class,
  __set_type_class,
  __file_type_class,
  __lang_type_class
};

#endif
#define va_end(pvar)	((void)0)

/* Avoid errors if compiling GCC v2 with GCC v1.  */
#if __GNUC__ == 1
#define __extension__
#endif

/* RECORD_TYPE args passed using the C calling convention are
   passed by invisible reference.  ??? RECORD_TYPE args passed
   in the stack are made to be word-aligned; for an aggregate that is
   not word-aligned, we advance the pointer to the first non-reg slot.  */

#ifdef __arch64__

typedef unsigned int __ptrint __attribute__ ((__mode__ (__DI__)));

/* ??? TODO: little endian support */

#define va_arg(pvar, TYPE) \
__extension__							\
(*({int __type = __builtin_classify_type (* (TYPE *) 0);	\
  char * __result;						\
  if (__type == __real_type_class)		/* float? */	\
    {								\
      if (__alignof__ (TYPE) == 16)				\
	(pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);	\
      __result = (pvar);					\
      (pvar) = (char *) (pvar) + sizeof (TYPE);			\
    }								\
  else if (__type < __record_type_class)	/* integer? */	\
    {								\
      (pvar) = (char *) (pvar) + 8;				\
      __result = (char *) (pvar) - sizeof (TYPE);		\
    }								\
  else /* aggregate object */					\
    {								\
      if (sizeof (TYPE) <= 8)					\
	{							\
	  __result = (pvar);					\
	  (pvar) = (char *) (pvar) + 8;				\
	}							\
      else if (sizeof (TYPE) <= 16)				\
	{							\
	  if (__alignof__ (TYPE) == 16)				\
	    (pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);	\
	  __result = (pvar);					\
	  (pvar) = (char *) (pvar) + 16;			\
	}							\
      else							\
	{							\
	  __result = * (void **) (pvar);			\
	  (pvar) = (char *) (pvar) + 8;				\
	}							\
    }								\
  (TYPE *) __result;}))

#else /* not __arch64__ */

#define __va_rounded_size(TYPE)  \
  (((sizeof (TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))

/* We don't declare the union member `d' to have type TYPE
   because that would lose in C++ if TYPE has a constructor.  */
/* We cast to void * and then to TYPE * because this avoids
   a warning about increasing the alignment requirement.
   The casts to char * avoid warnings about invalid pointer arithmetic.  */
#define va_arg(pvar,TYPE)					\
__extension__							\
(*({((__builtin_classify_type (*(TYPE*) 0) >= __record_type_class \
      || (__builtin_classify_type (*(TYPE*) 0) == __real_type_class \
	  && sizeof (TYPE) == 16))				\
    ? ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE *),	\
       *(TYPE **) (void *) ((char *)(pvar) - __va_rounded_size (TYPE *))) \
    : __va_rounded_size (TYPE) == 8				\
    ? ({ union {char __d[sizeof (TYPE)]; int __i[2];} __u;	\
	 __u.__i[0] = ((int *) (void *) (pvar))[0];		\
	 __u.__i[1] = ((int *) (void *) (pvar))[1];		\
	 (pvar) = (char *)(pvar) + 8;				\
	 (TYPE *) (void *) __u.__d; })				\
    : ((pvar) = (char *)(pvar) + __va_rounded_size (TYPE),	\
       ((TYPE *) (void *) ((char *)(pvar) - __va_rounded_size (TYPE)))));}))

#endif /* not __arch64__ */

/* Copy __gnuc_va_list into another variable of this type.  */
#define __va_copy(dest, src) (dest) = (src)

#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */
@


1.2
log
@GCC 2.8.0 merge
@
text
@@


1.1
log
@Initial revision
@
text
@d8 1
a8 13

#ifdef __sparc_v9__
typedef long long __va_greg;
typedef double __va_freg;
typedef struct {
  __va_greg * __va_next_o;		/* next available %o* register */
  __va_greg * __va_next_o_limit;	/* past last available %o* register */
  __va_freg * __va_next_fp;		/* next available %f* register */
  __va_freg * __va_next_fp_limit;	/* last available %f* register */
  __va_greg * __va_next_stack;		/* next extended word on stack */
} __gnuc_va_list;
#else
#ifndef __svr4__
a16 1
#endif /* not __sparc_v9__ */
a24 13
#ifdef __sparc_v9__
#define va_start(AP, LASTARG) \
__extension__ \
  ({ \
     AP.__va_next_o = (__va_greg *) __builtin_saveregs (); \
     AP.__va_next_o_limit = (AP.__va_next_o + \
			     (__builtin_args_info (0) < 6 ? 6 - __builtin_args_info (0) : 0)); \
     AP.__va_next_fp = (__va_freg *) AP.__va_next_o_limit; \
     AP.__va_next_fp_limit = (AP.__va_next_fp + \
			      (__builtin_args_info (1) < 16 ? (16 - __builtin_args_info (1) + 1) / 2 : 0)); \
     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (LASTARG); \
  })
#else
d27 1
a27 1
#ifdef __GCC_NEW_VARARGS__
a33 1
#endif /* not __sparc_v9__ */
d40 3
a42 1
#ifdef __sparc_v9__
d44 1
a44 17
__extension__ \
  ({ \
     AP.__va_next_o = (__va_greg *) __builtin_saveregs (); \
     AP.__va_next_o_limit = (AP.__va_next_o + \
			     (__builtin_args_info (0) < 6 ? 6 - __builtin_args_info (0) : 0)); \
     AP.__va_next_fp = (__va_freg *) AP.__va_next_o_limit; \
     AP.__va_next_fp_limit = (AP.__va_next_fp + \
			      (__builtin_args_info (1) < 16 ? (16 - __builtin_args_info (1) + 1) / 2 : 0)); \
     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (__builtin_va_alist) \
       - (__builtin_args_info (0) >= 6 || __builtin_args_info (1) >= 16 ? 1 : 0); \
  })
#else
#ifdef __GCC_NEW_VARARGS__
#define va_start(AP)		((AP) = (char *) __builtin_saveregs ())
#else
#define va_start(AP) 						\
 (__builtin_saveregs (), (AP) = ((char *) &__builtin_va_alist))
a45 1
#endif /* not __sparc_v9__ */
d90 5
a94 1
#ifdef __sparc_v9__
d96 1
a96 1
#define va_arg(pvar,TYPE)					\
d99 1
a99 1
  void * __result;						\
d102 4
a105 14
      __va_freg *__r;						\
      /* see PASS_IN_REG_P in gcc's sparc.h */			\
      if (pvar.__va_next_fp < pvar.__va_next_fp_limit		\
	  && ((__r = (__va_freg *) (((__va_greg) pvar.__va_next_fp + sizeof (TYPE) - 1) & ~(__va_greg) (sizeof (TYPE) - 1))) \
	      < pvar.__va_next_fp_limit))			\
	{							\
	  pvar.__va_next_fp = __r + (sizeof (TYPE) + 7) / 8;	\
	}							\
      else							\
	{							\
	  __r = (__va_freg *) pvar.__va_next_stack;		\
	  pvar.__va_next_stack += (sizeof (TYPE) + 7) / 8;	\
	}							\
      __result = __r;						\
d109 2
a110 7
      __va_greg *__r;						\
      if (pvar.__va_next_o < pvar.__va_next_o_limit)		\
	__r = pvar.__va_next_o++;				\
      else							\
	__r = pvar.__va_next_stack++;				\
      /* adjust for 4 byte ints */				\
      __result = (char *) __r + 8 - sizeof (TYPE);		\
d114 12
a125 3
      void **__r;						\
      if (pvar.__va_next_o < pvar.__va_next_o_limit)		\
	__r = (void **) pvar.__va_next_o++;			\
d127 4
a130 2
	__r = (void **) pvar.__va_next_stack++;			\
      __result = *__r;						\
d134 1
a134 1
#else /* not __sparc_v9__ */
d159 5
a163 1
#endif /* not __sparc_v9__ */
@


1.1.1.1
log
@FSF GCC version 2.7.2
@
text
@@


1.1.1.2
log
@*** empty log message ***
@
text
@d8 13
a20 1
#if ! defined (__svr4__) && ! defined (__linux__) && ! defined (__arch64__)
d29 1
d38 13
d53 1
a53 1
#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)
d60 1
d67 16
a82 2
#if defined (__GCC_NEW_VARARGS__) || defined (__arch64__)
#define va_start(AP)	((AP) = (char *) __builtin_saveregs ())
d84 2
a85 2
#define va_start(AP) \
  (__builtin_saveregs (), (AP) = ((char *) &__builtin_va_alist))
d87 1
d132 1
a132 1
#ifdef __arch64__
d134 1
a134 5
typedef unsigned int __ptrint __attribute__ ((__mode__ (__DI__)));

/* ??? TODO: little endian support */

#define va_arg(pvar, TYPE) \
d137 1
a137 1
  char * __result;						\
d140 14
a153 4
      if (__alignof__ (TYPE) == 16)				\
	(pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);	\
      __result = (pvar);					\
      (pvar) = (char *) (pvar) + sizeof (TYPE);			\
d157 7
a163 2
      (pvar) = (char *) (pvar) + 8;				\
      __result = (char *) (pvar) - sizeof (TYPE);		\
d167 3
a169 12
      if (sizeof (TYPE) <= 8)					\
	{							\
	  __result = (pvar);					\
	  (pvar) = (char *) (pvar) + 8;				\
	}							\
      else if (sizeof (TYPE) <= 16)				\
	{							\
	  if (__alignof__ (TYPE) == 16)				\
	    (pvar) = (void *) (((__ptrint) (pvar) + 15) & -16);	\
	  __result = (pvar);					\
	  (pvar) = (char *) (pvar) + 16;			\
	}							\
d171 2
a172 4
	{							\
	  __result = * (void **) (pvar);			\
	  (pvar) = (char *) (pvar) + 8;				\
	}							\
d176 1
a176 1
#else /* not __arch64__ */
d201 1
a201 5

#endif /* not __arch64__ */

/* Copy __gnuc_va_list into another variable of this type.  */
#define __va_copy(dest, src) (dest) = (src)
@

