head	1.4;
access;
symbols
	OPENBSD_5_3:1.3.0.48
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.46
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.44
	OPENBSD_5_0:1.3.0.42
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.40
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.38
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.34
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.36
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.32
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.30
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.28
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.26
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.24
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.22
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.20
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.18
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.16
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.14
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.12
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2013.07.05.21.31.45;	author miod;	state dead;
branches;
next	1.3;

1.3
date	2001.07.09.07.04.35;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.02.15.18.48.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.38.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.38.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Put the a.out as and ld to rest in the Attic, finally!
@
text
@/*	$OpenBSD: input-file.c,v 1.3 2001/07/09 07:04:35 deraadt Exp $	*/

/* input_file.c - Deal with Input Files -
   Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.
   
   This file is part of GAS, the GNU Assembler.
   
   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
   
   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/*
 * Confines all details of reading source bytes to this module.
 * All O/S specific crocks should live here.
 * What we lose in "efficiency" we gain in modularity.
 * Note we don't need to #include the "as.h" file. No common coupling!
 */

#ifndef lint
static char rcsid[] = "$OpenBSD: input-file.c,v 1.3 2001/07/09 07:04:35 deraadt Exp $";
#endif

#ifdef USG
#define setbuffer(stream, buf, size) setvbuf((stream), (buf), _IOFBF, (size))
#endif

#include <stdio.h>
#include <string.h>

#include "as.h"
#include "input-file.h"

/* This variable is non-zero if the file currently being read should be
   preprocessed by app.  It is zero if the file can be read straight in.
   */
int preprocess = 0;

/*
 * This code opens a file, then delivers BUFFER_SIZE character
 * chunks of the file on demand.
 * BUFFER_SIZE is supposed to be a number chosen for speed.
 * The caller only asks once what BUFFER_SIZE is, and asks before
 * the nature of the input files (if any) is known.
 */

#define BUFFER_SIZE (32 * 1024)

/*
 * We use static data: the data area is not sharable.
 */

FILE *f_in;
/* static JF remove static so app.c can use file_name */
char *	file_name;

/* Struct for saving the state of this module for file includes.  */
struct saved_file {
	FILE *f_in;
	char *file_name;
	int	preprocess;
	char *app_save;
};

/* These hooks accomodate most operating systems. */

void input_file_begin() {
	f_in = (FILE *)0;
}

void input_file_end () { }

/* Return BUFFER_SIZE. */
int input_file_buffer_size() {
	return (BUFFER_SIZE);
}

int input_file_is_open() {
	return f_in != (FILE *)0;
}

/* Push the state of our input, returning a pointer to saved info that
   can be restored with input_file_pop ().  */
char *input_file_push () {
	register struct saved_file *saved;
	
	saved = (struct saved_file *)xmalloc (sizeof *saved);
	
	saved->f_in		= f_in;
	saved->file_name	= file_name;
	saved->preprocess	= preprocess;
	if (preprocess)
	    saved->app_save	= app_push ();
	
	input_file_begin ();	/* Initialize for new file */
	
	return (char *)saved;
}

void
    input_file_pop (arg)
char *arg;
{
	register struct saved_file *saved = (struct saved_file *)arg;
	
	input_file_end ();	/* Close out old file */
	
	f_in			= saved->f_in;
	file_name		= saved->file_name;
	preprocess		= saved->preprocess;
	if (preprocess)
	    app_pop	 	 (saved->app_save);
	
	free(arg);
}

#ifdef DONTDEF		/* JF save old version in case we need it */
void
    input_file_open (filename, preprocess, debugging)
char *	filename;	/* "" means use stdin. Must not be 0. */
int	preprocess;	/* TRUE if needs app. */
int	debugging;	/* TRUE if we are debugging assembler. */
{
	assert( filename != 0 );	/* Filename may not be NULL. */
	if (filename[0])
	    {				/* We have a file name. Suck it and see. */
		    file_handle = open (filename, O_RDONLY, 0);
		    file_name = filename;
	    }
	else
	    {				/* use stdin for the input file. */
		    file_handle = fileno (stdin);
		    file_name = "{standard input}"; /* For error messages. */
	    }
	if (file_handle < 0)
	    as_perror ("Can't open %s for reading", file_name);
	if ( preprocess )
	    {
		    /*
		     * This code was written in haste for a frobbed BSD 4.2.
		     * I have a flight to catch: will someone please do proper
		     * error checks? - Dean.
		     */
		    int	pid;
		    char temporary_file_name[12];
		    int	fd;
		    union wait	status;
		    
		    (void)strcpy (temporary_file_name, "#appXXXXXX");
		    (void)mktemp (temporary_file_name);
		    pid = vfork ();
		    if (pid == -1)
			{
				as_perror ("Vfork failed", file_name);
				_exit (144);
			}
		    if (pid == 0)
			{
				(void)dup2 (file_handle, fileno(stdin));
				fd = open (temporary_file_name, O_WRONLY + O_TRUNC + O_CREAT, 0666);
				if (fd == -1)
				    {
					    (void)write(2,"Can't open temporary\n",21);
					    _exit (99);
				    }
				(void)dup2 (fd, fileno(stdout));
				/* JF for testing #define PREPROCESSOR "/lib/app" */
#define PREPROCESSOR "./app"
				execl (PREPROCESSOR, PREPROCESSOR, (char *)NULL);
				execl ("app","app",(char *)NULL);
				(void)write(2,"Exec of app failed.  Get help.\n",31);
				(void)unlink(temporary_file_name);
				_exit (11);
			}
		    (void)wait (& status);
		    if (status.w_status & 0xFF00)		/* JF was 0xF000, was wrong */
			{
				file_handle = -1;
				as_bad( "Can't preprocess file \"%s\", status = %xx", file_name, status.w_status );
			}
		    else
			{
				file_handle = open (temporary_file_name, O_RDONLY, 0);
				if ( ! debugging && unlink(temporary_file_name))
				    as_perror ("Can't delete temp file %s", temporary_file_name);
			}
		    if (file_handle == -1)
			as_perror ("Can't retrieve temp file %s", temporary_file_name);
	    }
}
#else

void
    input_file_open (filename,pre)
char *	filename;	/* "" means use stdin. Must not be 0. */
int pre;
{
	int	c;
	char	buf[80];
	
	preprocess = pre;
	
	assert( filename != 0 );	/* Filename may not be NULL. */
	if (filename[0]) {	/* We have a file name. Suck it and see. */
		f_in=fopen(filename,"r");
		file_name=filename;
	} else {			/* use stdin for the input file. */
		f_in = stdin;
		file_name = "{standard input}"; /* For error messages. */
	}
	if (f_in == (FILE *)0) {
		as_perror ("Can't open %s for reading", file_name);
		return;
	}
	
#ifndef HO_VMS
	/* Ask stdio to buffer our input at BUFFER_SIZE, with a dynamically
	   allocated buffer.  */
	setvbuf(f_in, (char *)NULL, _IOFBF, BUFFER_SIZE);
#endif /* HO_VMS */
	
	c = getc(f_in);
	if (c == '#') {	/* Begins with comment, may not want to preprocess */
		c = getc(f_in);
		if (c == 'N') {
			fgets(buf,80,f_in);
			if (!strcmp(buf,"O_APP\n"))
			    preprocess=0;
			if (!strchr(buf,'\n'))
			    ungetc('#',f_in);	/* It was longer */
			else
			    ungetc('\n',f_in);
		} else if (c == '\n')
		    ungetc('\n',f_in);
		else
		    ungetc('#',f_in);
	} else
	    ungetc(c,f_in);
	
#ifdef DONTDEF
	if ( preprocess ) {
		char temporary_file_name[17];
		FILE	*f_out;
		
		(void)strcpy (temporary_file_name, "/tmp/#appXXXXXX");
		(void)mktemp (temporary_file_name);
		f_out=fopen(temporary_file_name,"w+");
		if (f_out == (FILE *)0)
		    as_perror("Can't open temp file %s",temporary_file_name);
		
		/* JF this will have to be moved on any system that
		   does not support removal of open files.  */
		(void)unlink(temporary_file_name);/* JF do it NOW */
		do_scrub(f_in,f_out);
		(void)fclose(f_in);	/* All done with it */
		(void)rewind(f_out);
		f_in=f_out;
	}
#endif
}
#endif

/* Close input file.  */
void input_file_close() {
	if (f_in != NULL) {
		fclose (f_in);
	} /* don't close a null file pointer */
	f_in = 0;
} /* input_file_close() */

char *
    input_file_give_next_buffer (where)
char *		where;	/* Where to place 1st character of new buffer. */
{
	char *	return_value;	/* -> Last char of what we read, + 1. */
	register int	size;
	
	if (f_in == (FILE *)0)
	    return 0;
	/*
	 * fflush (stdin); could be done here if you want to synchronise
	 * stdin and stdout, for the case where our input file is stdin.
	 * Since the assembler shouldn't do any output to stdout, we
	 * don't bother to synch output and input.
	 */
	if (preprocess) {
		char *p;
		int n;
		int ch;
		extern FILE *scrub_file;
		
		scrub_file=f_in;
		for (p = where, n = BUFFER_SIZE; n; --n) {
			
			ch = do_scrub_next_char(scrub_from_file, scrub_to_file);
			if (ch == EOF)
			    break;
			*p++=ch;
		}
		size=BUFFER_SIZE-n;
	} else
	    size= fread(where,sizeof(char),BUFFER_SIZE,f_in);
	if (size < 0)
	    {
		    as_perror ("Can't read from %s", file_name);
		    size = 0;
	    }
	if (size)
	    return_value = where + size;
	else
	    {
		    if (fclose (f_in))
			as_perror ("Can't close %s", file_name);
		    f_in = (FILE *)0;
		    return_value = 0;
	    }
	return (return_value);
}

/* end of input-file.c */
@


1.3
log
@correct type on last arg to execl(); nordin@@cse.ogi.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: input-file.c,v 1.2 1998/02/15 18:48:51 niklas Exp $	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: input-file.c,v 1.2 1998/02/15 18:48:51 niklas Exp $";
@


1.2
log
@Merge of NetBSD changes + $OpenBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d30 1
a30 1
static char rcsid[] = "$OpenBSD: input-file.c,v 1.1.1.1 1995/10/18 08:38:58 deraadt Exp $";
d178 2
a179 2
				execl (PREPROCESSOR, PREPROCESSOR, 0);
				execl ("app","app",0);
@


1.1
log
@Initial revision
@
text
@d1 2
d30 1
a30 1
static char rcsid[] = "$Id: input-file.c,v 1.3 1993/10/02 20:57:37 pk Exp $";
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
