head	1.3;
access;
symbols
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1
	netbsd_1_1:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	97.05.29.20.22.01;	author kstailey;	state dead;
branches;
next	1.2;

1.2
date	97.01.26.09.36.11;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.38.52;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.38.52;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@we use pax as cpio now
@
text
@/* userspec.c -- Parse a user and group string.
   Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* Written by David MacKenzie <djm@@gnu.ai.mit.edu>.  */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef __GNUC__
#define alloca __builtin_alloca
#else
#ifdef HAVE_ALLOCA_H
#include <alloca.h>
#else
#ifdef _AIX
 #pragma alloca
#else
char *alloca ();
#endif
#endif
#endif

#include <stdio.h>
#include <sys/types.h>
#include <pwd.h>
#include <grp.h>

#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#include <string.h>
#ifndef index
#define index strchr
#endif
#else
#include <strings.h>
#endif

#ifdef STDC_HEADERS
#include <stdlib.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

#ifndef _POSIX_VERSION
struct passwd *getpwnam ();
struct group *getgrnam ();
struct group *getgrgid ();
#endif

#ifdef _POSIX_SOURCE
#define endpwent()
#define endgrent()
#endif

/* Perform the equivalent of the statement `dest = strdup (src);',
   but obtaining storage via alloca instead of from the heap.  */

#define V_STRDUP(dest, src)						\
  do									\
    {									\
      int _len = strlen ((src));					\
      (dest) = (char *) alloca (_len + 1);				\
      strcpy (dest, src);						\
    }									\
  while (0)

#define isdigit(c) ((c) >= '0' && (c) <= '9')

char *strdup ();

/* Return nonzero if STR represents an unsigned decimal integer,
   otherwise return 0. */

static int
isnumber (str)
     const char *str;
{
  for (; *str; str++)
    if (!isdigit (*str))
      return 0;
  return 1;
}

/* Extract from NAME, which has the form "[user][:.][group]",
   a USERNAME, UID U, GROUPNAME, and GID G.
   Either user or group, or both, must be present.
   If the group is omitted but the ":" or "." separator is given,
   use the given user's login group.

   USERNAME and GROUPNAME will be in newly malloc'd memory.
   Either one might be NULL instead, indicating that it was not
   given and the corresponding numeric ID was left unchanged.

   Return NULL if successful, a static error message string if not.  */

const char *
parse_user_spec (spec_arg, uid, gid, username_arg, groupname_arg)
     const char *spec_arg;
     uid_t *uid;
     gid_t *gid;
     char **username_arg, **groupname_arg;
{
  static const char *tired = "virtual memory exhausted";
  const char *error_msg;
  char *spec;			/* A copy we can write on.  */
  struct passwd *pwd;
  struct group *grp;
  char *g, *u, *separator;
  char *groupname;

  error_msg = NULL;
  *username_arg = *groupname_arg = NULL;
  groupname = NULL;

  V_STRDUP (spec, spec_arg);

  /* Find the separator if there is one.  */
  separator = index (spec, ':');
  if (separator == NULL)
    separator = index (spec, '.');

  /* Replace separator with a NUL.  */
  if (separator != NULL)
    *separator = '\0';

  /* Set U and G to non-zero length strings corresponding to user and
     group specifiers or to NULL.  */
  u = (*spec == '\0' ? NULL : spec);

  g = (separator == NULL || *(separator + 1) == '\0'
       ? NULL
       : separator + 1);

  if (u == NULL && g == NULL)
    return "can not omit both user and group";

  if (u != NULL)
    {
      pwd = getpwnam (u);
      if (pwd == NULL)
	{

	  if (!isnumber (u))
	    error_msg = "invalid user";
	  else
	    {
	      int use_login_group;
	      use_login_group = (separator != NULL && g == NULL);
	      if (use_login_group)
		error_msg = "cannot get the login group of a numeric UID";
	      else
		*uid = atoi (u);
	    }
	}
      else
	{
	  *uid = pwd->pw_uid;
	  if (g == NULL && separator != NULL)
	    {
	      /* A separator was given, but a group was not specified,
	         so get the login group.  */
	      *gid = pwd->pw_gid;
	      grp = getgrgid (pwd->pw_gid);
	      if (grp == NULL)
		{
		  /* This is enough room to hold the unsigned decimal
		     representation of any 32-bit quantity and the trailing
		     zero byte.  */
		  char uint_buf[21];
		  sprintf (uint_buf, "%u", (unsigned) (pwd->pw_gid));
		  V_STRDUP (groupname, uint_buf);
		}
	      else
		{
		  V_STRDUP (groupname, grp->gr_name);
		}
	      endgrent ();
	    }
	}
      endpwent ();
    }

  if (g != NULL && error_msg == NULL)
    {
      /* Explicit group.  */
      grp = getgrnam (g);
      if (grp == NULL)
	{
	  if (!isnumber (g))
	    error_msg = "invalid group";
	  else
	    *gid = atoi (g);
	}
      else
	*gid = grp->gr_gid;
      endgrent ();		/* Save a file descriptor.  */

      if (error_msg == NULL)
	V_STRDUP (groupname, g);
    }

  if (error_msg == NULL)
    {
      if (u != NULL)
	{
	  *username_arg = strdup (u);
	  if (*username_arg == NULL)
	    error_msg = tired;
	}

      if (groupname != NULL && error_msg == NULL)
	{
	  *groupname_arg = strdup (groupname);
	  if (*groupname_arg == NULL)
	    {
	      if (*username_arg != NULL)
		{
		  free (*username_arg);
		  *username_arg = NULL;
		}
	      error_msg = tired;
	    }
	}
    }

  return error_msg;
}

#ifdef TEST

#define NULL_CHECK(s) ((s) == NULL ? "(null)" : (s))

int
main (int argc, char **argv)
{
  int i;

  for (i = 1; i < argc; i++)
    {
      const char *e;
      char *username, *groupname;
      uid_t uid;
      gid_t gid;
      char *tmp;

      tmp = strdup (argv[i]);
      e = parse_user_spec (tmp, &uid, &gid, &username, &groupname);
      free (tmp);
      printf ("%s: %u %u %s %s %s\n",
	      argv[i],
	      (unsigned int) uid,
	      (unsigned int) gid,
	      NULL_CHECK (username),
	      NULL_CHECK (groupname),
	      NULL_CHECK (e));
    }

  exit (0);
}

#endif
@


1.2
log
@cpio 2.4.2, including texinfo file.  supports lchown().
@
text
@@


1.1
log
@Initial revision
@
text
@d20 18
a53 2
#else
char *malloc ();
d71 12
d86 13
a98 1
static int isnumber ();
a108 1
   Might write NULs into NAME.
d112 3
a114 3
char *
parse_user_spec (name, uid, gid, username, groupname)
     char *name;
d117 1
a117 1
     char **username, **groupname;
d119 3
a121 1
  static char *tired = "virtual memory exhausted";
d124 2
a125 2
  char *cp;
  int use_login_group = 0;
d127 3
a129 1
  *username = *groupname = NULL;
d131 23
a153 5
  /* Check whether a group is given.  */
  cp = index (name, ':');
  if (cp == NULL)
    cp = index (name, '.');
  if (cp != NULL)
d155 2
a156 2
      *cp++ = '\0';
      if (*cp == '\0')
d158 3
a160 3
	  if (cp == name + 1)
	    /* Neither user nor group given, just "." or ":".  */
	    return "can not omit both user and group";
d162 8
a169 2
	    /* "user.".  */
	    use_login_group = 1;
d173 2
a174 6
	  /* Explicit group.  */
	  *groupname = strdup (cp);
	  if (*groupname == NULL)
	    return tired;
	  grp = getgrnam (cp);
	  if (grp == NULL)
d176 18
a193 3
	      if (!isnumber (cp))
		return "invalid group";
	      *gid = atoi (cp);
a194 3
	  else
	    *gid = grp->gr_gid;
	  endgrent ();		/* Save a file descriptor.  */
d196 1
d199 14
a212 1
  /* Parse the user name, now that any group has been removed.  */
d214 3
a216 7
  if (name[0] == '\0')
    /* No user name was given, just a group.  */
    return NULL;

  *username = strdup (name);
  if (*username == NULL)
    return tired;
d218 1
a218 2
  pwd = getpwnam (name);
  if (pwd == NULL)
d220 8
a227 10
      if (!isnumber (name))
	return "invalid user";
      if (use_login_group)
	return "cannot get the login group of a numeric UID";
      *uid = atoi (name);
    }
  else
    {
      *uid = pwd->pw_uid;
      if (use_login_group)
d229 2
a230 10
	  *gid = pwd->pw_gid;
	  grp = getgrgid (pwd->pw_gid);
	  if (grp == NULL)
	    {
	      *groupname = malloc (15);
	      if (*groupname == NULL)
		return tired;
	      sprintf (*groupname, "%u", pwd->pw_gid);
	    }
	  else
d232 6
a237 3
	      *groupname = strdup (grp->gr_name);
	      if (*groupname == NULL)
		return tired;
a238 1
	  endgrent ();
d241 2
a242 2
  endpwent ();
  return NULL;
d245 3
a247 2
/* Return nonzero if STR represents an unsigned decimal integer,
   otherwise return 0. */
d249 2
a250 3
static int
isnumber (str)
     char *str;
d252 23
a274 4
  for (; *str; str++)
    if (!isdigit (*str))
      return 0;
  return 1;
d276 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
