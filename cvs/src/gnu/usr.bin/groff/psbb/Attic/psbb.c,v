head	1.4;
access;
symbols
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.1.0.42
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.40
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.38
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.36
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.34
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.32
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.30
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.28
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.26
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	groff_1_15:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	groff_1_11a:1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	groff_1_10:1.1.1.1
	gnu:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2011.03.12.19.04.01;	author schwarze;	state dead;
branches;
next	1.3;

1.3
date	2010.05.08.18.58.27;	author nicm;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.10.21.38.16;	author cloder;	state Exp;
branches;
next	1.1;

1.1
date	96.09.14.19.01.21;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.14.19.01.21;	author etheisen;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Replaced by mandoc(1) for base and xenocara purposes,
and comes with 4.9 ports.
ok deraadt@@
@
text
@/* Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.
     Written by James Clark (jjc@@jclark.com)

This file is part of groff.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with groff; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif

struct bounding_box {
  int llx, lly, urx, ury;
};

#ifdef __STDC__
const char *do_file(FILE *, struct bounding_box *);
int parse_bounding_box(char *, struct bounding_box *);
#else
#define const /* as nothing */
const char *do_file();
int parse_bounding_box();
#endif

int main(argc, argv)
int argc;
char **argv;
{
  FILE *fp;
  const char *message;
  struct bounding_box bb;
  if (argc != 2) {
    fprintf(stderr, "usage: %s filename\n", argv[0]);
    exit(3);
  }
  errno = 0;
  fp = fopen(argv[1], "r");
  if (fp == NULL) {
    fprintf(stderr, "%s: can't open `%s': ", argv[0], argv[1]);
    perror((char *)NULL);
    exit(2);
  }
  message = do_file(fp, &bb);
  if (message) {
    fprintf(stderr, "%s: ", argv[0]);
    fprintf(stderr, message, argv[1]);
    putc('\n', stderr);
    exit(1);
  }
  printf("%d %d %d %d\n", bb.llx, bb.lly, bb.urx, bb.ury);
  exit(0);
}
      
/* If the bounding box was found return NULL, and store the bounding box
in bb. If the bounding box was not found return a string suitable for
giving to printf with the filename as an argument saying why not. */

const char *do_file(fp, bb)
FILE *fp;
struct bounding_box *bb;
{
  int bb_at_end = 0;
  char buf[256];
  if (!fgets(buf, sizeof(buf), fp))
    return "%s is empty";
  if (strncmp("%!PS-Adobe-", buf, 11) != 0)
    return "%s is not conforming";
  while (fgets(buf, sizeof(buf), fp) != NULL) {
    if (buf[0] != '%' || buf[1] != '%'
	|| strncmp(buf + 2, "EndComments", 11) == 0)
      break;
    if (strncmp(buf + 2, "BoundingBox:", 12) == 0) {
      int res = parse_bounding_box(buf + 14, bb);
      if (res == 1)
	return NULL;
      else if (res == 2) {
	bb_at_end = 1;
	break;
      }
      else
	return "the arguments to the %%%%BoundingBox comment in %s are bad";
    }
  }
  if (bb_at_end) {
    long offset;
    int last_try = 0;
    /* in the trailer, the last BoundingBox comment is significant */
    for (offset = 512; !last_try; offset *= 2) {
      int had_trailer = 0;
      int got_bb = 0;
      if (offset > 32768 || fseek(fp, -offset, 2) == -1) {
	last_try = 1;
	if (fseek(fp, 0L, 0) == -1)
	  break;
      }
      while (fgets(buf, sizeof(buf), fp) != NULL) {
	if (buf[0] == '%' && buf[1] == '%') {
	  if (!had_trailer) {
	    if (strncmp(buf + 2, "Trailer", 7) == 0)
	      had_trailer = 1;
	  }
	  else {
	    if (strncmp(buf + 2, "BoundingBox:", 12) == 0) {
	      int res = parse_bounding_box(buf + 14, bb);
	      if (res == 1)
		got_bb = 1;
	      else if (res == 2)
		return "`(atend)' not allowed in trailer";
	      else
		return "the arguments to the %%%%BoundingBox comment in %s are bad";
	    }
	  }
	}
      }
      if (got_bb)
	return NULL;
    }
  }
  return "%%%%BoundingBox comment not found in %s";
}

/* Parse the argument to a %%BoundingBox comment. Return 1 if it
contains 4 numbers, 2 if it contains (atend), 0 otherwise. */

int parse_bounding_box(p, bb)
char *p;
struct bounding_box *bb;
{
  if (sscanf(p, "%d %d %d %d",
	     &bb->llx, &bb->lly, &bb->urx, &bb->ury) == 4)
    return 1;
  else {
    /* The Document Structuring Conventions say that the numbers
       should be integers. Unfortunately some broken applications
       get this wrong. */
    double x1, x2, x3, x4;
    if (sscanf(p, "%lf %lf %lf %lf", &x1, &x2, &x3, &x4) == 4) {
      bb->llx = (int)x1;
      bb->lly = (int)x2;
      bb->urx = (int)x3;
      bb->ury = (int)x4;
      return 1;
    }
    else {
      for (; *p == ' ' || *p == '\t'; p++)
	;
      if (strncmp(p, "(atend)", 7) == 0) {
	return 2;
      }
    }
  }
  return 0;
}

@


1.3
log
@Fixes to build with gcc4, mostly function prototypes and missing
headers.

ok robert kettenis jsg
@
text
@@


1.2
log
@fgets(3) returns NULL on error, not 0. No functional change, but it makes
the code easier to read.
OK deraadt
@
text
@d21 1
@


1.1
log
@Initial revision
@
text
@d83 1
a83 1
  while (fgets(buf, sizeof(buf), fp) != 0) {
d111 1
a111 1
      while (fgets(buf, sizeof(buf), fp) != 0) {
@


1.1.1.1
log
@Third time because import sucks.
@
text
@@
