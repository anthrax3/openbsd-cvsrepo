head	1.2;
access;
symbols
	OPENBSD_4_9:1.1.1.1.0.60
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.58
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.54
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.56
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.52
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.50
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.48
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.46
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.44
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.42
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.40
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.38
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.36
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.34
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.32
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.30
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.28
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.26
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	groff_1_15:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	groff_1_11a:1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	groff_1_10:1.1.1.1
	gnu:1.1.1;
locks; strict;
comment	@// @;


1.2
date	2011.03.12.19.04.00;	author schwarze;	state dead;
branches;
next	1.1;

1.1
date	96.09.14.19.00.51;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.14.19.00.51;	author etheisen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Replaced by mandoc(1) for base and xenocara purposes,
and comes with 4.9 ports.
ok deraadt@@
@
text
@// -*- C++ -*-
/* Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.
     Written by James Clark (jjc@@jclark.com)

This file is part of groff.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with groff; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "lib.h"
#include "searchpath.h"

search_path::search_path(const char *envvar, const char *standard)
{
  char *e = envvar ? getenv(envvar) : 0;
  if (e && standard) {
    dirs = new char[strlen(e) + strlen(standard) + 2];
    strcpy(dirs, e);
    strcat(dirs, ":");
    strcat(dirs, standard);
  }
  else
    dirs = strsave(e ? e : standard);
  init_len = dirs ? strlen(dirs) : 0;
}

search_path::~search_path()
{
  if (dirs)
    a_delete dirs;
}

void search_path::command_line_dir(const char *s)
{
  if (!dirs)
    dirs = strsave(s);
  else {
    char *old = dirs;
    unsigned old_len = strlen(old);
    unsigned slen = strlen(s);
    dirs = new char[old_len + 1 + slen + 1];
    memcpy(dirs, old, old_len - init_len);
    char *p = dirs;
    p += old_len - init_len;
    if (init_len == 0)
      *p++ = ':';
    memcpy(p, s, slen);
    p += slen;
    if (init_len > 0) {
      *p++ = ':';
      memcpy(p, old + old_len - init_len, init_len);
      p += init_len;
    }
    *p++ = '\0';
    a_delete old;
  }
}

FILE *search_path::open_file(const char *name, char **pathp)
{
  assert(name != 0);
  if (*name == '/' || dirs == 0 || *dirs == '\0') {
    FILE *fp = fopen(name, "r");
    if (fp) {
      if (pathp)
	*pathp = strsave(name);
      return fp;
    }
    else
      return 0;
  }
  unsigned namelen = strlen(name);
  char *p = dirs;
  for (;;) {
    char *end = strchr(p, ':');
    if (!end)
      end = strchr(p, '\0');
    int need_slash = end > p && end[-1] != '/';
    char *path = new char[(end - p) + need_slash + namelen + 1];
    memcpy(path, p, end - p);
    if (need_slash)
      path[end - p] = '/';
    strcpy(path + (end - p) + need_slash, name);
#if 0
    fprintf(stderr, "trying `%s'\n", path);
#endif
    FILE *fp = fopen(path, "r");
    if (fp) {
      if (pathp)
	*pathp = path;
      else
	a_delete path;
      return fp;
    }
    a_delete path;
    if (*end == '\0')
      break;
    p = end + 1;
  }
  return 0;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Third time because import sucks.
@
text
@@
