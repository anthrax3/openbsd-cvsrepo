head	1.2;
access;
symbols
	OPENBSD_4_9:1.1.1.1.0.60
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.58
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.54
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.56
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.52
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.50
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.48
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.46
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.44
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.42
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.40
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.38
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.36
	OPENBSD_3_7_BASE:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.34
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.32
	OPENBSD_3_5_BASE:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.30
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.28
	OPENBSD_3_3_BASE:1.1.1.1
	OPENBSD_3_2:1.1.1.1.0.26
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.24
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.22
	OPENBSD_3_0_BASE:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.20
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.18
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.16
	OPENBSD_2_7_BASE:1.1.1.1
	groff_1_15:1.1.1.1
	OPENBSD_2_6:1.1.1.1.0.14
	OPENBSD_2_6_BASE:1.1.1.1
	OPENBSD_2_5:1.1.1.1.0.12
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.10
	OPENBSD_2_4_BASE:1.1.1.1
	OPENBSD_2_3:1.1.1.1.0.8
	OPENBSD_2_3_BASE:1.1.1.1
	groff_1_11a:1.1.1
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	groff_1_10:1.1.1.1
	gnu:1.1.1;
locks; strict;
comment	@ * @;


1.2
date	2011.03.12.19.04.00;	author schwarze;	state dead;
branches;
next	1.1;

1.1
date	96.09.14.19.00.52;	author etheisen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.09.14.19.00.52;	author etheisen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Replaced by mandoc(1) for base and xenocara purposes,
and comes with 4.9 ports.
ok deraadt@@
@
text
@/* Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.
     Written by James Clark (jjc@@jclark.com)

This file is part of groff.

groff is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2, or (at your option) any later
version.

groff is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with groff; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#include <string.h>
#include <ctype.h>
#include <errno.h>
#ifndef errno
extern int errno;
#endif

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#ifndef LONG_MAX
#define LONG_MAX  2147483647
#endif

#ifndef LONG_MIN
#define LONG_MIN (-LONG_MAX-1)
#endif

#ifdef isascii
#define ISASCII(c) isascii(c)
#else
#define ISASCII(c) (1)
#endif

long strtol(str, ptr, base)
     char *str, **ptr;
     int base;
{
  char *start = str;
  int neg = 0;
  long val;
  char *p;
  static char digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

  while (ISASCII((unsigned char)*str) && isspace((unsigned char)*str))
    str++;

  if (*str == '-') {
    neg = 1;
    str++;
  }
  if (base == 0) {
    if (*str == '0') {
      if (str[1] == 'x' || str[1] == 'X') {
	str += 2;
	base = 16;
      }
      else
	base = 8;
    }
    else
      base = 10;
  }
  if (base < 2 || base > 36)
    base = 10;
  else if (base == 16 && *str == '0' && (str[1] == 'x' || str[1] == 'X'))
    str += 2;

  p = strchr(digits, (ISASCII((unsigned char)*str)
		      && isupper((unsigned char)*str)
		      ? tolower((unsigned char)*str)
		      : *str));
  if (p == 0 || (val = (p - digits)) >= base) {
    if (base == 16 && str > start && (str[-1] == 'x' || str[-1] == 'X')) {
      if (ptr)
	*ptr = str - 1;
    }
    else {
      if (ptr)
	*ptr = start;
      errno = ERANGE;
    }
    return 0;
  }
  if (neg)
    val = -val;
    
  while (*++str != '\0') {
    int n;

    p = strchr(digits, (ISASCII((unsigned char)*str)
			&& isupper((unsigned char)*str)
			? tolower((unsigned char)*str) : *str));
    if (p == 0)
      break;
    n = p - digits;
    if (n >= base)
      break;
    if (neg) {
      if (-(unsigned long)val > (-(unsigned long)LONG_MIN - n)/base) {
	val = LONG_MIN;
	errno = ERANGE;
      }
      else
	val = val*base - n;
    }
    else {
      if (val > (LONG_MAX - n)/base) {
	val = LONG_MAX;
	errno = ERANGE;
      }
      else
	val = val*base + n;
    }
  }
  
  if (ptr)
    *ptr = str;

  return val;
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Third time because import sucks.
@
text
@@
