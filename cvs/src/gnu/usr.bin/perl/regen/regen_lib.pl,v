head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.3;
commitid	B31cAbBIXiCqnL97;

1.1.1.3
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w
use strict;
use vars qw($Needs_Write $Verbose @@Changed $TAP);
use File::Compare;
use Symbol;
use Text::Wrap();

# Common functions needed by the regen scripts

$Needs_Write = $^O eq 'cygwin' || $^O eq 'os2' || $^O eq 'MSWin32';

$Verbose = 0;
@@ARGV = grep { not($_ eq '-q' and $Verbose = -1) }
  grep { not($_ eq '--tap' and $TAP = 1) }
  grep { not($_ eq '-v' and $Verbose = 1) } @@ARGV;

END {
  print STDOUT "Changed: @@Changed\n" if @@Changed;
}

sub safer_unlink {
  my @@names = @@_;
  my $cnt = 0;

  my $name;
  foreach $name (@@names) {
    next unless -e $name;
    chmod 0777, $name if $Needs_Write;
    ( CORE::unlink($name) and ++$cnt
      or warn "Couldn't unlink $name: $!\n" );
  }
  return $cnt;
}

# Open a new file.
sub open_new {
    my ($final_name, $mode, $header, $force) = @@_;
    my $name = $final_name . '-new';
    my $lang = $final_name =~ /\.pod$/ ? 'Pod' :
	$final_name =~ /\.(?:c|h|inc|tab|act)$/ ? 'C' : 'Perl';
    if ($force && -e $final_name) {
        chmod 0777, $name if $Needs_Write;
        CORE::unlink $final_name
                or die "Couldn't unlink $final_name: $!\n";
    }
    my $fh = gensym;
    if (!defined $mode or $mode eq '>') {
	if (-f $name) {
	    unlink $name or die "$name exists but can't unlink: $!";
	}
	open $fh, ">$name" or die "Can't create $name: $!";
    } elsif ($mode eq '>>') {
	open $fh, ">>$name" or die "Can't append to $name: $!";
    } else {
        die "Unhandled open mode '$mode'";
    }
    @@{*$fh}{qw(name final_name lang force)}
        = ($name, $final_name, $lang, $force);
    binmode $fh;
    print {$fh} read_only_top(lang => $lang, %$header) if $header;
    $fh;
}

sub close_and_rename {
    my $fh = shift;
    my ($name, $final_name, $force) = @@{*{$fh}}{qw(name final_name force)};
    close $fh or die "Error closing $name: $!";

    if ($TAP) {
        # Don't use compare because if there are errors it doesn't give any
        # way to generate diagnostics about what went wrong.
        # These files are small enough to read into memory.
        local $/;
        # This is the file we just closed, so it should open cleanly:
        open $fh, '<', $name
            or die "Can't open '$name': $!";
        my $want = <$fh>;
        die "Can't read '$name': $!"
            unless defined $want;
        close $fh
            or die "Can't close '$name': $!";

        my $fail;
        if (!open $fh, '<', $final_name) {
            $fail = "Can't open '$final_name': $!";
        } else {
            my $have = <$fh>;
            if (!defined $have) {
                $fail = "Can't read '$final_name': $!";
                close $fh;
            } elsif (!close $fh) {
                $fail = "Can't close '$final_name': $!";
            } elsif ($want ne $have) {
                $fail = "'$name' and '$final_name' differ";
            }
        }
        if ($fail) {
            print STDOUT "not ok - $0 $final_name\n";
            print STDERR "$fail\n";
        } else {
            print STDOUT "ok - $0 $final_name\n";
        }
	safer_unlink($name);
	return;
    }
    unless ($force) {
        if (compare($name, $final_name) == 0) {
            warn "no changes between '$name' & '$final_name'\n" if $Verbose > 0;
            safer_unlink($name);
            return;
        }
        warn "changed '$name' to '$final_name'\n" if $Verbose > 0;
        push @@Changed, $final_name unless $Verbose < 0;
    }

    # Some DOSish systems can't rename over an existing file:
    safer_unlink $final_name;
    chmod 0600, $name if $Needs_Write;
    rename $name, $final_name or die "renaming $name to $final_name: $!";
}

my %lang_opener = (Perl => '# ', Pod => '', C => '/* ');

sub read_only_top {
    my %args = @@_;
    my $lang = $args{lang};
    die "Missing language argument" unless defined $lang;
    die "Unknown language argument '$lang'"
        unless exists $lang_opener{$lang};
    my $style = $args{style} ? " $args{style} " : '   ';

    my $raw = "-*- buffer-read-only: t -*-\n";

    if ($args{file}) {
	$raw .= "\n   $args{file}\n";
    }
    if ($args{copyright}) {
	local $" = ', ';
         $raw .= wrap(75, '   ', '   ', <<"EOM") . "\n";

Copyright (C) @@{$args{copyright}} by\0Larry\0Wall\0and\0others

You may distribute under the terms of either the GNU General Public
License or the Artistic License, as specified in the README file.
EOM
    }

    $raw .= "!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n";

    if ($args{by}) {
	$raw .= "This file is built by $args{by}";
	if ($args{from}) {
	    my @@from = ref $args{from} eq 'ARRAY' ? @@{$args{from}} : $args{from};
	    my $last = pop @@from;
	    if (@@from) {
		$raw .= ' from ' . join (', ', @@from) . " and $last";
	    } else {
		$raw .= " from $last";
	    }
	}
	$raw .= ".\n";
    }
    $raw .= "Any changes made here will be lost!\n";
    $raw .= $args{final} if $args{final};

    my $cooked = $lang eq 'C'
        ? wrap(78, '/* ', $style, $raw) . " */\n\n"
        : wrap(78, $lang_opener{$lang}, $lang_opener{$lang}, $raw) . "\n";
    $cooked =~ tr/\0/ /; # Don't break Larry's name etc
    $cooked =~ s/ +$//mg; # Remove all trailing spaces
    $cooked =~ s! \*/\n!$args{quote}!s if $args{quote};
    return $cooked;
}

sub read_only_bottom_close_and_rename {
    my ($fh, $sources) = @@_;
    my ($name, $lang, $final_name) = @@{*{$fh}}{qw(name lang final_name)};
    die "No final name specified at open time for $name"
        unless $final_name;

    my $comment;
    if ($sources) {
	$comment = "Generated from:\n";
	foreach my $file (sort @@$sources) {
            my $digest = (-e $file)
                         ? digest($file)
                           # Use a random number that won't match the real
                           # digest, so will always show as out-of-date, so
                           # Porting tests likely will fail drawing attention
                           # to the problem.
                         : int(rand(1_000_000));
	    $comment .= "$digest $file\n";
	}
    }
    $comment .= "ex: set ro:";

    if (defined $lang && $lang eq 'Perl') {
	$comment =~ s/^/# /mg;
    } elsif (!defined $lang or $lang ne 'Pod') {
	$comment =~ s/^/ * /mg;
	$comment =~ s! \* !/* !;
	$comment .= " */";
    }
    print $fh "\n$comment\n";

    close_and_rename($fh);
}

sub tab {
    my ($l, $t) = @@_;
    $t .= "\t" x ($l - (length($t) + 1) / 8);
    $t;
}

sub digest {
    my $file = shift;
    # Need to defer loading this, as the main regen scripts work back to 5.004,
    # and likely we don't even have this module on every 5.8 install yet:
    require Digest::SHA;

    local ($/, *FH);
    open FH, "$file" or die "Can't open $file: $!";
    my $raw = <FH>;
    close FH or die "Can't close $file: $!";
    return Digest::SHA::sha256_hex($raw);
};

sub wrap {
    local $Text::Wrap::columns = shift;
    Text::Wrap::wrap(@@_);
}

# return the perl version as defined in patchlevel.h.
# (we may be being run by another perl, so $] won't be right)
# return e.g. (5, 14, 3, "5.014003")

sub perl_version {
    my $plh = 'patchlevel.h';
    open my $fh, "<", $plh or die "can't open '$plh': $!\n";
    my ($v1,$v2,$v3);
    while (<$fh>) {
        $v1 = $1 if /PERL_REVISION\s+(\d+)/;
        $v2 = $1 if /PERL_VERSION\s+(\d+)/;
        $v3 = $1 if /PERL_SUBVERSION\s+(\d+)/;
    }
    die "can't locate PERL_REVISION in '$plh'"   unless defined $v1;
    die "can't locate PERL_VERSION in '$plh'"    unless defined $v2;
    die "can't locate PERL_SUBVERSION in '$plh'" unless defined $v3;
    return ($v1,$v2,$v3, sprintf("%d.%03d%03d", $v1, $v2, $v3));
}


1;
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
use Text::Wrap;
d37 1
a37 1
    my ($final_name, $mode, $header) = @@_;
d39 7
a45 1
    my $lang = $final_name =~ /\.(?:c|h|tab|act)$/ ? 'C' : 'Perl';
d55 1
a55 1
	die "Unhandled open mode '$mode#";
d57 2
a58 3
    *{$fh}->{name} = $name;
    *{$fh}->{final_name} = $final_name;
    *{$fh}->{lang} = $lang;
d66 1
a66 1
    my $name = *{$fh}->{name};
a67 1
    my $final_name = *{$fh}->{final_name};
d70 33
a102 2
	my $not = compare($name, $final_name) ? 'not ' : '';
	print STDOUT $not . "ok - $0 $final_name\n";
d106 8
a113 4
    if (compare($name, $final_name) == 0) {
	warn "no changes between '$name' & '$final_name'\n" if $Verbose > 0;
	safer_unlink($name);
	return;
a114 2
    warn "changed '$name' to '$final_name'\n" if $Verbose > 0;
    push @@Changed, $final_name unless $Verbose < 0;
d116 1
a116 1
    # Some dosish systems can't rename over an existing file:
d122 2
d126 4
a129 3
    die "Missing language argument" unless defined $args{lang};
    die "Unknown language argument '$args{lang}'"
	unless $args{lang} eq 'Perl' or $args{lang} eq 'C';
d139 1
a139 2
	local $Text::Wrap::columns = 75;
	$raw .= wrap('   ', '   ', <<"EOM") . "\n";
d166 3
a168 3
    local $Text::Wrap::columns = 78;
    my $cooked = $args{lang} eq 'Perl'
	? wrap('# ', '# ', $raw) . "\n" : wrap('/* ', $style, $raw) . " */\n\n";
d177 1
a177 2
    my $name = *{$fh}->{name};
    my $lang = *{$fh}->{lang};
d179 1
a179 1
	unless *{$fh}->{final_name};
d185 7
a191 1
	    my $digest = digest($file);
d199 1
a199 1
    } else {
d227 25
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d6 1
a6 1
use Text::Wrap();
d37 1
a37 1
    my ($final_name, $mode, $header, $force) = @@_;
d39 1
a39 7
    my $lang = $final_name =~ /\.pod$/ ? 'Pod' :
	$final_name =~ /\.(?:c|h|tab|act)$/ ? 'C' : 'Perl';
    if ($force && -e $final_name) {
        chmod 0777, $name if $Needs_Write;
        CORE::unlink $final_name
                or die "Couldn't unlink $final_name: $!\n";
    }
d49 1
a49 1
        die "Unhandled open mode '$mode'";
d51 3
a53 2
    @@{*$fh}{qw(name final_name lang force)}
        = ($name, $final_name, $lang, $force);
d61 1
a61 1
    my ($name, $final_name, $force) = @@{*{$fh}}{qw(name final_name force)};
d63 1
d66 2
a67 33
        # Don't use compare beacuse if there are errors it doesn't give any
        # way to generate diagnostics about what went wrong.
        # These files are small enough to read into memory.
        local $/;
        # This is the file we just closed, so it should open cleanly:
        open $fh, '<', $name
            or die "Can't open '$name': $!";
        my $want = <$fh>;
        die "Can't read '$name': $!"
            unless defined $want;
        close $fh
            or die "Can't close '$name': $!";

        my $fail;
        if (!open $fh, '<', $final_name) {
            $fail = "Can't open '$final_name': $!";
        } else {
            my $have = <$fh>;
            if (!defined $have) {
                $fail = "Can't read '$final_name': $!";
                close $fh;
            } elsif (!close $fh) {
                $fail = "Can't close '$final_name': $!";
            } elsif ($want ne $have) {
                $fail = "'$name' and '$final_name' differ";
            }
        }
        if ($fail) {
            print STDOUT "not ok - $0 $final_name\n";
            print STDERR "$fail\n";
        } else {
            print STDOUT "ok - $0 $final_name\n";
        }
d71 4
a74 8
    unless ($force) {
        if (compare($name, $final_name) == 0) {
            warn "no changes between '$name' & '$final_name'\n" if $Verbose > 0;
            safer_unlink($name);
            return;
        }
        warn "changed '$name' to '$final_name'\n" if $Verbose > 0;
        push @@Changed, $final_name unless $Verbose < 0;
d76 2
d79 1
a79 1
    # Some DOSish systems can't rename over an existing file:
a84 2
my %lang_opener = (Perl => '# ', Pod => '', C => '/* ');

d87 3
a89 4
    my $lang = $args{lang};
    die "Missing language argument" unless defined $lang;
    die "Unknown language argument '$lang'"
        unless exists $lang_opener{$lang};
d99 2
a100 1
         $raw .= wrap(75, '   ', '   ', <<"EOM") . "\n";
d127 3
a129 3
    my $cooked = $lang eq 'C'
        ? wrap(78, '/* ', $style, $raw) . " */\n\n"
        : wrap(78, $lang_opener{$lang}, $lang_opener{$lang}, $raw) . "\n";
d138 2
a139 1
    my ($name, $lang, $final_name) = @@{*{$fh}}{qw(name lang final_name)};
d141 1
a141 1
        unless $final_name;
d155 1
a155 1
    } elsif (!defined $lang or $lang ne 'Pod') {
a182 5

sub wrap {
    local $Text::Wrap::columns = shift;
    Text::Wrap::wrap(@@_);
}
@


1.1.1.3
log
@Import perl-5.24.2
@
text
@d40 1
a40 1
	$final_name =~ /\.(?:c|h|inc|tab|act)$/ ? 'C' : 'Perl';
d70 1
a70 1
        # Don't use compare because if there are errors it doesn't give any
d185 1
a185 7
            my $digest = (-e $file)
                         ? digest($file)
                           # Use a random number that won't match the real
                           # digest, so will always show as out-of-date, so
                           # Porting tests likely will fail drawing attention
                           # to the problem.
                         : int(rand(1_000_000));
a225 20

# return the perl version as defined in patchlevel.h.
# (we may be being run by another perl, so $] won't be right)
# return e.g. (5, 14, 3, "5.014003")

sub perl_version {
    my $plh = 'patchlevel.h';
    open my $fh, "<", $plh or die "can't open '$plh': $!\n";
    my ($v1,$v2,$v3);
    while (<$fh>) {
        $v1 = $1 if /PERL_REVISION\s+(\d+)/;
        $v2 = $1 if /PERL_VERSION\s+(\d+)/;
        $v3 = $1 if /PERL_SUBVERSION\s+(\d+)/;
    }
    die "can't locate PERL_REVISION in '$plh'"   unless defined $v1;
    die "can't locate PERL_VERSION in '$plh'"    unless defined $v2;
    die "can't locate PERL_SUBVERSION in '$plh'" unless defined $v3;
    return ($v1,$v2,$v3, sprintf("%d.%03d%03d", $v1, $v2, $v3));
}

@


