head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.16;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.22;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.06.40;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    regexp.h
 *
 *    Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2003,
 *    2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 */
#ifndef PLUGGABLE_RE_EXTENSION
/* we don't want to include this stuff if we are inside of
   an external regex engine based on the core one - like re 'debug'*/

#include "utf8.h"

struct regnode {
    U8	flags;
    U8  type;
    U16 next_off;
};

typedef struct regnode regnode;

struct reg_substr_data;

struct reg_data;

struct regexp_engine;
struct regexp;

struct reg_substr_datum {
    SSize_t min_offset; /* min pos (in chars) that substr must appear */
    SSize_t max_offset  /* max pos (in chars) that substr must appear */;
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
    SSize_t end_shift;  /* how many fixed chars must end the string */
};
struct reg_substr_data {
    U8      check_ix;   /* index into data[] of check substr */
    struct reg_substr_datum data[3];	/* Actual array */
};

#ifdef PERL_ANY_COW
#define SV_SAVED_COPY   SV *saved_copy; /* If non-NULL, SV which is COW from original */
#else
#define SV_SAVED_COPY
#endif

/* offsets within a string of a particular /(.)/ capture */

typedef struct regexp_paren_pair {
    SSize_t start;
    SSize_t end;
    /* 'start_tmp' records a new opening position before the matching end
     * has been found, so that the old start and end values are still
     * valid, e.g.
     *	  "abc" =~ /(.(?{print "[$1]"}))+/
     *outputs [][a][b]
     * This field is not part of the API.  */
    SSize_t start_tmp;
} regexp_paren_pair;

#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
#define _invlist_union(a, b, output) _invlist_union_maybe_complement_2nd(a, b, FALSE, output)
#define _invlist_intersection(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, FALSE, output)

/* Subtracting b from a leaves in a everything that was there that isn't in b,
 * that is the intersection of a with b's complement */
#define _invlist_subtract(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)
#endif

/* record the position of a (?{...}) within a pattern */

struct reg_code_block {
    STRLEN start;
    STRLEN end;
    OP     *block;
    REGEXP *src_regex;
};


/*
  The regexp/REGEXP struct, see L<perlreapi> for further documentation
  on the individual fields. The struct is ordered so that the most
  commonly used fields are placed at the start.

  Any patch that adds items to this struct will need to include
  changes to F<sv.c> (C<Perl_re_dup()>) and F<regcomp.c>
  (C<pregfree()>). This involves freeing or cloning items in the
  regexp's data array based on the data item's type.
*/

#define _REGEXP_COMMON							\
        /* what engine created this regexp? */				\
	const struct regexp_engine* engine; 				\
	REGEXP *mother_re; /* what re is this a lightweight copy of? */	\
	HV *paren_names;   /* Optional hash of paren names */		\
        /*--------------------------------------------------------*/    \
	/* Information about the match that the perl core uses to */	\
	/* manage things */						\
	U32 extflags;	/* Flags used both externally and internally */	\
	SSize_t minlen;	/* mininum possible number of chars in string to match */\
	SSize_t minlenret; /* mininum possible number of chars in $& */		\
	STRLEN gofs;	/* chars left of pos that we search from */	\
	/* substring data about strings that must appear in the */	\
	/* final match, used for optimisations */			\
	struct reg_substr_data *substrs;				\
	U32 nparens;	/* number of capture buffers */			\
	/* private engine specific data */				\
	U32 intflags;	/* Engine Specific Internal flags */		\
	void *pprivate;	/* Data private to the regex engine which */	\
			/* created this object. */			\
        /*--------------------------------------------------------*/    \
	/* Data about the last/current match. These are modified */	\
	/* during matching */						\
	U32 lastparen;			/* last open paren matched */	\
	U32 lastcloseparen;		/* last close paren matched */	\
	/* Array of offsets for (@@-) and (@@+) */			\
	regexp_paren_pair *offs;					\
        char **recurse_locinput; /* used to detect infinite recursion, XXX: move to internal */ \
        /*--------------------------------------------------------*/    \
	/* saved or original string so \digit works forever. */		\
	char *subbeg;							\
	SV_SAVED_COPY	/* If non-NULL, SV which is COW from original */\
	SSize_t sublen;	/* Length of string pointed by subbeg */	\
	SSize_t suboffset; /* byte offset of subbeg from logical start of str */ \
	SSize_t subcoffset; /* suboffset equiv, but in chars (for @@-/@@+) */ \
	/* Information about the match that isn't often used */		\
        SSize_t maxlen;        /* mininum possible number of chars in string to match */\
        /*--------------------------------------------------------*/    \
	/* offset from wrapped to the start of precomp */		\
	PERL_BITFIELD32 pre_prefix:4;					\
        /* original flags used to compile the pattern, may differ */    \
        /* from extflags in various ways */                             \
        PERL_BITFIELD32 compflags:9;                                    \
        /*--------------------------------------------------------*/    \
	CV *qr_anoncv	/* the anon sub wrapped round qr/(?{..})/ */

typedef struct regexp {
	_XPV_HEAD;
	_REGEXP_COMMON;
} regexp;

#define RXp_PAREN_NAMES(rx)	((rx)->paren_names)

/* used for high speed searches */
typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    SSize_t *scream_pos;	/* Internal iterator of scream. */
} re_scream_pos_data;

/* regexp_engine structure. This is the dispatch table for regexes.
 * Any regex engine implementation must be able to build one of these.
 */
typedef struct regexp_engine {
    REGEXP* (*comp) (pTHX_ SV * const pattern, U32 flags);
    I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,
                     char* strbeg, SSize_t minend, SV* sv,
                     void* data, U32 flags);
    char*   (*intuit) (pTHX_
                        REGEXP * const rx,
                        SV *sv,
                        const char * const strbeg,
                        char *strpos,
                        char *strend,
                        const U32 flags,
                       re_scream_pos_data *data);
    SV*     (*checkstr) (pTHX_ REGEXP * const rx);
    void    (*rxfree) (pTHX_ REGEXP * const rx);
    void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,
                                    SV * const sv);
    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
                                   SV const * const value);
    I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,
                                    const I32 paren);
    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, const U32 flags);
    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
                                const U32 flags);
    SV*     (*qr_package)(pTHX_ REGEXP * const rx);
#ifdef USE_ITHREADS
    void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
#endif
    REGEXP* (*op_comp) (pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const struct regexp_engine* eng,
		    REGEXP *old_re,
		    bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags);
} regexp_engine;

/*
  These are passed to the numbered capture variable callbacks as the
  paren name. >= 1 is reserved for actual numbered captures, i.e. $1,
  $2 etc.
*/
#define RX_BUFF_IDX_CARET_PREMATCH  -5 /* ${^PREMATCH}  */
#define RX_BUFF_IDX_CARET_POSTMATCH -4 /* ${^POSTMATCH} */
#define RX_BUFF_IDX_CARET_FULLMATCH -3 /* ${^MATCH}     */
#define RX_BUFF_IDX_PREMATCH        -2 /* $` */
#define RX_BUFF_IDX_POSTMATCH       -1 /* $' */
#define RX_BUFF_IDX_FULLMATCH        0 /* $& */

/*
  Flags that are passed to the named_buff and named_buff_iter
  callbacks above. Those routines are called from universal.c via the
  Tie::Hash::NamedCapture interface for %+ and %- and the re::
  functions in the same file.
*/

/* The Tie::Hash::NamedCapture operation this is part of, if any */
#define RXapif_FETCH     0x0001
#define RXapif_STORE     0x0002
#define RXapif_DELETE    0x0004
#define RXapif_CLEAR     0x0008
#define RXapif_EXISTS    0x0010
#define RXapif_SCALAR    0x0020
#define RXapif_FIRSTKEY  0x0040
#define RXapif_NEXTKEY   0x0080

/* Whether %+ or %- is being operated on */
#define RXapif_ONE       0x0100 /* %+ */
#define RXapif_ALL       0x0200 /* %- */

/* Whether this is being called from a re:: function */
#define RXapif_REGNAME         0x0400
#define RXapif_REGNAMES        0x0800
#define RXapif_REGNAMES_COUNT  0x1000

/*
=head1 REGEXP Functions

=for apidoc Am|REGEXP *|SvRX|SV *sv

Convenience macro to get the REGEXP from a SV.  This is approximately
equivalent to the following snippet:

    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;

C<NULL> will be returned if a REGEXP* is not found.

=for apidoc Am|bool|SvRXOK|SV* sv

Returns a boolean indicating whether the SV (or the one it references)
is a REGEXP.

If you want to do something with the REGEXP* later use SvRX instead
and check for NULL.

=cut
*/

#define SvRX(sv)   (Perl_get_re_arg(aTHX_ sv))
#define SvRXOK(sv) (Perl_get_re_arg(aTHX_ sv) ? TRUE : FALSE)


/* Flags stored in regexp->extflags
 * These are used by code external to the regexp engine
 *
 * Note that the flags whose names start with RXf_PMf_ are defined in
 * op_reg_common.h, being copied from the parallel flags of op_pmflags
 *
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

#include "op_reg_common.h"

#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_NOCAPTURE)

#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl, x_count)                       \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;           \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;           \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;           \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED; (x_count)++; break;\
    case NOCAPTURE_PAT_MOD: *(pmfl) |= RXf_PMf_NOCAPTURE; break;

#define STD_PMMOD_FLAGS_PARSE_X_WARN(x_count)                                   \
    if (UNLIKELY((x_count) > 1)) {                                              \
        Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),         \
                    "Having more than one /%c regexp modifier is deprecated",   \
                    XTENDED_PAT_MOD);                                           \
    }

/* Note, includes charset ones, assumes 0 is the default for them */
#define STD_PMMOD_FLAGS_CLEAR(pmfl)                        \
    *(pmfl) &= ~(RXf_PMf_FOLD|RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_EXTENDED|RXf_PMf_CHARSET|RXf_PMf_NOCAPTURE)

/* chars and strings used as regex pattern modifiers
 * Singular is a 'c'har, plural is a "string"
 *
 * NOTE, KEEPCOPY was originally 'k', but was changed to 'p' for preserve
 * for compatibility reasons with Regexp::Common which highjacked (?k:...)
 * for its own uses. So 'k' is out as well.
 */
#define DEFAULT_PAT_MOD      '^'    /* Short for all the default modifiers */
#define EXEC_PAT_MOD         'e'
#define KEEPCOPY_PAT_MOD     'p'
#define NOCAPTURE_PAT_MOD    'n'
#define ONCE_PAT_MOD         'o'
#define GLOBAL_PAT_MOD       'g'
#define CONTINUE_PAT_MOD     'c'
#define MULTILINE_PAT_MOD    'm'
#define SINGLE_PAT_MOD       's'
#define IGNORE_PAT_MOD       'i'
#define XTENDED_PAT_MOD      'x'
#define NONDESTRUCT_PAT_MOD  'r'
#define LOCALE_PAT_MOD       'l'
#define UNICODE_PAT_MOD      'u'
#define DEPENDS_PAT_MOD      'd'
#define ASCII_RESTRICT_PAT_MOD 'a'

#define ONCE_PAT_MODS        "o"
#define KEEPCOPY_PAT_MODS    "p"
#define NOCAPTURE_PAT_MODS   "n"
#define EXEC_PAT_MODS        "e"
#define LOOP_PAT_MODS        "gc"
#define NONDESTRUCT_PAT_MODS "r"
#define LOCALE_PAT_MODS      "l"
#define UNICODE_PAT_MODS     "u"
#define DEPENDS_PAT_MODS     "d"
#define ASCII_RESTRICT_PAT_MODS "a"
#define ASCII_MORE_RESTRICT_PAT_MODS "aa"

/* This string is expected by regcomp.c to be ordered so that the first
 * character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of extflags; the next
 * character is bit +1, etc. */
#define STD_PAT_MODS        "msixxn"

#define CHARSET_PAT_MODS    ASCII_RESTRICT_PAT_MODS DEPENDS_PAT_MODS LOCALE_PAT_MODS UNICODE_PAT_MODS

/* This string is expected by XS_re_regexp_pattern() in universal.c to be ordered
 * so that the first character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of
 * extflags; the next character is in bit +1, etc. */
#define INT_PAT_MODS    STD_PAT_MODS    KEEPCOPY_PAT_MODS

#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS  NOCAPTURE_PAT_MODS
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS	   CHARSET_PAT_MODS
#define M_PAT_MODS      QR_PAT_MODS     LOOP_PAT_MODS
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS      NONDESTRUCT_PAT_MODS

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT   RXf_PMf_SPLIT

/* Currently the regex flags occupy a single 32-bit word.  Not all bits are
 * currently used.  The lower bits are shared with their corresponding PMf flag
 * bits, up to but not including _RXf_PMf_SHIFT_NEXT.  The unused bits
 * immediately follow; finally the used RXf-only (unshared) bits, so that the
 * highest bit in the word is used.  This gathers all the unused bits as a pool
 * in the middle, like so: 11111111111111110000001111111111
 * where the '1's represent used bits, and the '0's unused.  This design allows
 * us to allocate off one end of the pool if we need to add a shared bit, and
 * off the other end if we need a non-shared bit, without disturbing the other
 * bits.  This maximizes the likelihood of being able to change things without
 * breaking binary compatibility.
 *
 * To add shared bits, do so in op_reg_common.h.  This should change
 * _RXf_PMf_SHIFT_NEXT so that things won't compile.  Then come to regexp.h and
 * op.h and adjust the constant adders in the definitions of RXf_BASE_SHIFT and
 * Pmf_BASE_SHIFT down by the number of shared bits you added.  That's it.
 * Things should be binary compatible.  But if either of these gets to having
 * to subtract rather than add, leave at 0 and instead adjust all the entries
 * that are in terms of it.  But if the first one of those is already
 * RXf_BASE_SHIFT+0, there are no bits left, and a redesign is in order.
 *
 * To remove unshared bits, just delete its entry.  If you're where breaking
 * binary compatibility is ok to do, you might want to adjust things to move
 * the newly opened space so that it gets absorbed into the common pool.
 *
 * To add unshared bits, first use up any gaps in the middle.  Otherwise,
 * allocate off the low end until you get to RXf_BASE_SHIFT+0.  If that isn't
 * enough, move RXf_BASE_SHIFT down (if possible) and add the new bit at the
 * other end instead; this preserves binary compatibility.
 *
 * For the regexp bits, PL_reg_extflags_name[] in regnodes.h has a comment
 * giving which bits are used/unused */

#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT + 2)

/* What we have seen */
#define RXf_NO_INPLACE_SUBST    (1U<<(RXf_BASE_SHIFT+2))
#define RXf_EVAL_SEEN   	(1U<<(RXf_BASE_SHIFT+3))

/* Special */
#define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1U<<(RXf_BASE_SHIFT+4))
#define RXf_CHECK_ALL   	(1U<<(RXf_BASE_SHIFT+5))

/* UTF8 related */
#define RXf_MATCH_UTF8  	(1U<<(RXf_BASE_SHIFT+6)) /* $1 etc are utf8 */

/* Intuit related */
#define RXf_USE_INTUIT_NOML	(1U<<(RXf_BASE_SHIFT+7))
#define RXf_USE_INTUIT_ML	(1U<<(RXf_BASE_SHIFT+8))
#define RXf_INTUIT_TAIL 	(1U<<(RXf_BASE_SHIFT+9))
#define RXf_USE_INTUIT		(RXf_USE_INTUIT_NOML|RXf_USE_INTUIT_ML)

/* Do we have some sort of anchor? */
#define RXf_IS_ANCHORED         (1U<<(RXf_BASE_SHIFT+10))

/* Copy and tainted info */
#define RXf_COPY_DONE   	(1U<<(RXf_BASE_SHIFT+11))

/* post-execution: $1 et al are tainted */
#define RXf_TAINTED_SEEN	(1U<<(RXf_BASE_SHIFT+12))
/* this pattern was tainted during compilation */
#define RXf_TAINTED		(1U<<(RXf_BASE_SHIFT+13))

/* Flags indicating special patterns */
#define RXf_START_ONLY		(1U<<(RXf_BASE_SHIFT+14)) /* Pattern is /^/ */
#define RXf_SKIPWHITE           (1U<<(RXf_BASE_SHIFT+15)) /* Pattern is for a */
                                                          /* split " " */
#define RXf_WHITE		(1U<<(RXf_BASE_SHIFT+16)) /* Pattern is /\s+/ */
#define RXf_NULL		(1U<<(RXf_BASE_SHIFT+17)) /* Pattern is // */

/* See comments at the beginning of these defines about adding bits.  The
 * highest bit position should be used, so that if RXf_BASE_SHIFT gets
 * increased, the #error below will be triggered so that you will be reminded
 * to adjust things at the other end to keep the bit positions unchanged */
#if RXf_BASE_SHIFT+17 > 31
#   error Too many RXf_PMf bits used.  See comments at beginning of these for what to do
#endif

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
 *
 */

#ifdef NO_TAINT_SUPPORT
#   define RX_ISTAINTED(prog)    0
#   define RX_TAINT_on(prog)     NOOP
#   define RXp_MATCH_TAINTED(prog) 0
#   define RX_MATCH_TAINTED(prog)  0
#   define RXp_MATCH_TAINTED_on(prog) NOOP
#   define RX_MATCH_TAINTED_on(prog)  NOOP
#   define RX_MATCH_TAINTED_off(prog) NOOP
#else
#   define RX_ISTAINTED(prog)    (RX_EXTFLAGS(prog) & RXf_TAINTED)
#   define RX_TAINT_on(prog)     (RX_EXTFLAGS(prog) |= RXf_TAINTED)
#   define RXp_MATCH_TAINTED(prog)    (RXp_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED(prog)     (RX_EXTFLAGS(prog)  & RXf_TAINTED_SEEN)
#   define RXp_MATCH_TAINTED_on(prog) (RXp_EXTFLAGS(prog) |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_on(prog)  (RX_EXTFLAGS(prog)  |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_off(prog) (RX_EXTFLAGS(prog)  &= ~RXf_TAINTED_SEEN)
#endif

#define RX_HAS_CUTGROUP(prog) ((prog)->intflags & PREGf_CUTGROUP_SEEN)
#define RX_MATCH_TAINTED_set(prog, t) ((t) \
				       ? RX_MATCH_TAINTED_on(prog) \
				       : RX_MATCH_TAINTED_off(prog))

#define RXp_MATCH_COPIED(prog)		(RXp_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RX_MATCH_COPIED(prog)		(RX_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RXp_MATCH_COPIED_on(prog)	(RXp_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	(RX_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RXp_MATCH_COPIED_off(prog)	(RXp_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	(RX_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_set(prog,t)	((t) \
					 ? RX_MATCH_COPIED_on(prog) \
					 : RX_MATCH_COPIED_off(prog))

#define RXp_EXTFLAGS(rx)	((rx)->extflags)
#define RXp_COMPFLAGS(rx)        ((rx)->compflags)

/* For source compatibility. We used to store these explicitly.  */
#define RX_PRECOMP(prog)	(RX_WRAPPED(prog) + ReANY(prog)->pre_prefix)
#define RX_PRECOMP_const(prog)	(RX_WRAPPED_const(prog) + ReANY(prog)->pre_prefix)
/* FIXME? Are we hardcoding too much here and constraining plugin extension
   writers? Specifically, the value 1 assumes that the wrapped version always
   has exactly one character at the end, a ')'. Will that always be true?  */
#define RX_PRELEN(prog)		(RX_WRAPLEN(prog) - ReANY(prog)->pre_prefix - 1)
#define RX_WRAPPED(prog)	ReANY(prog)->xpv_len_u.xpvlenu_pv
#define RX_WRAPPED_const(prog)	((const char *)RX_WRAPPED(prog))
#define RX_WRAPLEN(prog)	SvCUR(prog)
#define RX_CHECK_SUBSTR(prog)	(ReANY(prog)->check_substr)
#define RX_REFCNT(prog)		SvREFCNT(prog)
#define RX_EXTFLAGS(prog)	RXp_EXTFLAGS(ReANY(prog))
#define RX_COMPFLAGS(prog)        RXp_COMPFLAGS(ReANY(prog))
#define RX_ENGINE(prog)		(ReANY(prog)->engine)
#define RX_SUBBEG(prog)		(ReANY(prog)->subbeg)
#define RX_SUBOFFSET(prog)	(ReANY(prog)->suboffset)
#define RX_SUBCOFFSET(prog)	(ReANY(prog)->subcoffset)
#define RX_OFFS(prog)		(ReANY(prog)->offs)
#define RX_NPARENS(prog)	(ReANY(prog)->nparens)
#define RX_SUBLEN(prog)		(ReANY(prog)->sublen)
#define RX_MINLEN(prog)		(ReANY(prog)->minlen)
#define RX_MINLENRET(prog)	(ReANY(prog)->minlenret)
#define RX_GOFS(prog)		(ReANY(prog)->gofs)
#define RX_LASTPAREN(prog)	(ReANY(prog)->lastparen)
#define RX_LASTCLOSEPAREN(prog)	(ReANY(prog)->lastcloseparen)
#define RX_SAVED_COPY(prog)	(ReANY(prog)->saved_copy)
/* last match was zero-length */
#define RX_ZERO_LEN(prog) \
        (RX_OFFS(prog)[0].start + (SSize_t)RX_GOFS(prog) \
          == RX_OFFS(prog)[0].end)

#endif /* PLUGGABLE_RE_EXTENSION */

/* Stuff that needs to be included in the pluggable extension goes below here */

#ifdef PERL_ANY_COW
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_SAVED_COPY(rx)) { \
	    SV_CHECK_THINKFIRST_COW_DROP(RX_SAVED_COPY(rx)); \
	} \
	if (RX_MATCH_COPIED(rx)) { \
	    Safefree(RX_SUBBEG(rx)); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#else
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_MATCH_COPIED(rx)) { \
	    Safefree(RX_SUBBEG(rx)); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#endif

#define RXp_MATCH_UTF8(prog)		(RXp_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8(prog)		(RX_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		(RX_EXTFLAGS(prog) |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		(RX_EXTFLAGS(prog) &= ~RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_set(prog, t)	((t) \
			? RX_MATCH_UTF8_on(prog) \
			: RX_MATCH_UTF8_off(prog))

/* Whether the pattern stored at RX_WRAPPED is in UTF-8  */
#define RX_UTF8(prog)			SvUTF8(prog)


/* bits in flags arg of Perl_regexec_flags() */

#define REXEC_COPY_STR  0x01    /* Need to copy the string for captures. */
#define REXEC_CHECKED   0x02    /* re_intuit_start() already called. */
#define REXEC_SCREAM    0x04    /* currently unused. */
#define REXEC_IGNOREPOS 0x08    /* use stringarg, not pos(), for \G match */
#define REXEC_NOT_FIRST 0x10    /* This is another iteration of //g:
                                   no need to copy string again */

                                     /* under REXEC_COPY_STR, it's ok for the
                                        engine (modulo PL_sawamperand etc)
                                        to skip copying: ... */
#define REXEC_COPY_SKIP_PRE  0x20    /* ...the $` part of the string, or */
#define REXEC_COPY_SKIP_POST 0x40    /* ...the $' part of the string */
#define REXEC_FAIL_ON_UNDERFLOW 0x80 /* fail the match if $& would start before
                                        the start pos (so s/.\G// would fail
                                        on second iteration */

#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define ReREFCNT_inc(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_inc = (re);				\
	assert(SvTYPE(_rerefcnt_inc) == SVt_REGEXP);			\
	SvREFCNT_inc(_rerefcnt_inc);					\
	_rerefcnt_inc;							\
    })
#  define ReREFCNT_dec(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_dec = (re);				\
	SvREFCNT_dec(_rerefcnt_dec);					\
    })
#else
#  define ReREFCNT_dec(re)	SvREFCNT_dec(re)
#  define ReREFCNT_inc(re)	((REGEXP *) SvREFCNT_inc(re))
#endif
#define ReANY(re)		S_ReANY((const REGEXP *)(re))

/* FIXME for plugins. */

#define FBMcf_TAIL_DOLLAR	1
#define FBMcf_TAIL_DOLLARM	2
#define FBMcf_TAIL_Z		4
#define FBMcf_TAIL_z		8
#define FBMcf_TAIL		(FBMcf_TAIL_DOLLAR|FBMcf_TAIL_DOLLARM|FBMcf_TAIL_Z|FBMcf_TAIL_z)

#define FBMrf_MULTILINE	1

struct regmatch_state;
struct regmatch_slab;

/* like regmatch_info_aux, but contains extra fields only needed if the
 * pattern contains (?{}). If used, is snuck into the second slot in the
 * regmatch_state stack at the start of execution */

typedef struct {
    regexp *rex;
    PMOP    *curpm;     /* saved PL_curpm */
#ifdef PERL_ANY_COW
    SV      *saved_copy; /* saved saved_copy field from rex */
#endif
    char    *subbeg;    /* saved subbeg     field from rex */
    STRLEN  sublen;     /* saved sublen     field from rex */
    STRLEN  suboffset;  /* saved suboffset  field from rex */
    STRLEN  subcoffset; /* saved subcoffset field from rex */
    MAGIC   *pos_magic; /* pos() magic attached to $_ */
    SSize_t pos;        /* the original value of pos() in pos_magic */
    U8      pos_flags;  /* flags to be restored; currently only MGf_BYTES*/
} regmatch_info_aux_eval;


/* fields that logically  live in regmatch_info, but which need cleaning
 * up on croak(), and so are instead are snuck into the first slot in
 * the regmatch_state stack at the start of execution */

typedef struct {
    regmatch_info_aux_eval *info_aux_eval;
    struct regmatch_state *old_regmatch_state; /* saved PL_regmatch_state */
    struct regmatch_slab  *old_regmatch_slab;  /* saved PL_regmatch_slab */
    char *poscache;	/* S-L cache of fail positions of WHILEMs */
} regmatch_info_aux;


/* some basic information about the current match that is created by
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc.
 * It is allocated as a local var on the stack, so nothing should be
 * stored in it that needs preserving or clearing up on croak().
 * For that, see the aux_info and aux_info_eval members of the
 * regmatch_state union. */

typedef struct {
    REGEXP *prog;        /* the regex being executed */
    const char * strbeg; /* real start of string */
    char *strend;        /* one byte beyond last char of match string */
    char *till;          /* matches shorter than this fail (see minlen arg) */
    SV *sv;              /* the SV string currently being matched */
    char *ganch;         /* position of \G anchor */
    char *cutpoint;      /* (*COMMIT) position (if any) */
    regmatch_info_aux      *info_aux; /* extra fields that need cleanup */
    regmatch_info_aux_eval *info_aux_eval; /* extra saved state for (?{}) */
    I32  poscache_maxiter; /* how many whilems todo before S-L cache kicks in */
    I32  poscache_iter;    /* current countdown from _maxiter to zero */
    STRLEN poscache_size;  /* size of regmatch_info_aux.poscache */
    bool intuit;    /* re_intuit_start() is the top-level caller */
    bool is_utf8_pat;    /* regex is utf8 */
    bool is_utf8_target; /* string being matched is utf8 */
    bool warned; /* we have issued a recursion warning; no need for more */
} regmatch_info;
 

/* structures for holding and saving the state maintained by regmatch() */

#ifndef MAX_RECURSE_EVAL_NOCHANGE_DEPTH
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 10
#endif

typedef I32 CHECKPOINT;

typedef struct regmatch_state {
    int resume_state;		/* where to jump to on return */
    char *locinput;		/* where to backtrack in string on failure */

    union {

        /* the 'info_aux' and 'info_aux_eval' union members are cuckoos in
         * the nest. They aren't saved backtrack state; rather they
         * represent one or two extra chunks of data that need allocating
         * at the start of a match. These fields would logically live in
         * the regmatch_info struct, except that is allocated on the
         * C stack, and these fields are all things that require cleanup
         * after a croak(), when the stack is lost.
         * As a convenience, we just use the first 1 or 2 regmatch_state
         * slots to store this info, as we will be allocating a slab of
         * these anyway. Otherwise we'd have to malloc and then free them,
         * or allocate them on the save stack (where they will get
         * realloced if the save stack grows).
         * info_aux contains the extra fields that are always needed;
         * info_aux_eval contains extra fields that only needed if
         * the pattern contains code blocks
         * We split them into two separate structs to avoid increasing
         * the size of the union.
         */

        regmatch_info_aux info_aux;

        regmatch_info_aux_eval info_aux_eval;

	/* this is a fake union member that matches the first element
	 * of each member that needs to store positive backtrack
	 * information */
	struct {
	    struct regmatch_state *prev_yes_state;
	} yes;

        /* branchlike members */
        /* this is a fake union member that matches the first elements
         * of each member that needs to behave like a branch */
        struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;
	    
        } branchlike;
        	    
	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;
	    
	    regnode *next_branch; /* next branch node */
	} branch;

	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    U32 lastcloseparen;
	    CHECKPOINT cp;

	    U32		accepted; /* how many accepting states left */
	    bool	longfold;/* saw a fold with a 1->n char mapping */
	    U16         *jump;  /* positive offsets from me */
	    regnode	*me;	/* Which node am I - needed for jump tries*/
	    U8		*firstpos;/* pos in string of first trie match */
	    U32		firstchars;/* len in chars of firstpos from start */
	    U16		nextword;/* next word to try */
	    U16		topword; /* longest accepted word */
	} trie;

        /* special types - these members are used to store state for special
           regops like eval, if/then, lookaround and the markpoint state */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_curlyx;
            struct regmatch_state *prev_eval;
	    REGEXP	*prev_rex;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
            U32         close_paren; /* which close bracket is our end (+1) */
	    regnode	*B;	/* the node following us  */
            char        *prev_recurse_locinput;
	} eval;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 wanted;
	    I32 logical;	/* saved copy of 'logical' var */
	    regnode  *me; /* the IFMATCH/SUSPEND/UNLESSM node  */
	} ifmatch; /* and SUSPEND/UNLESSM */
	
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_mark;
	    SV* mark_name;
	    char *mark_loc;
	} mark;
	
	struct {
	    int val;
	} keeper;

        /* quantifiers - these members are used for storing state for
           for the regops used to implement quantifiers */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_curlyx; /* previous cur_curlyx */
	    regnode	*me;	/* the CURLYX node  */
	    regnode	*B;	/* the B node in /A*B/  */
	    CHECKPOINT	cp;	/* remember current savestack index */
	    bool	minmod;
	    int		parenfloor;/* how far back to strip paren data */

	    /* these two are modified by WHILEM */
	    int		count;	/* how many instances of A we've matched */
	    char	*lastloc;/* where previous A matched (0-len detect) */
	} curlyx;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *save_curlyx;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    char	*save_lastloc;	/* previous curlyx.lastloc */
	    I32		cache_offset;
	    I32		cache_mask;
	} whilem;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    int c1, c2;		/* case fold search */
	    CHECKPOINT cp;
	    U32 lastparen;
	    U32 lastcloseparen;
	    I32 alen;		/* length of first-matched A string */
	    I32 count;
	    bool minmod;
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	    regnode *me;	/* the curlym node */
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
	} curlym;

	struct {
	    U32 paren;
	    CHECKPOINT cp;
	    U32 lastparen;
	    U32 lastcloseparen;
	    int c1, c2;		/* case fold search */
	    char *maxpos;	/* highest possible point in string to match */
	    char *oldloc;	/* the previous locinput */
	    int count;
	    int min, max;	/* {m,n} */
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
	} curly; /* and CURLYN/PLUS/STAR */

    } u;
} regmatch_state;



/* how many regmatch_state structs to allocate as a single slab.
 * We do it in 4K blocks for efficiency. The "3" is 2 for the next/prev
 * pointers, plus 1 for any mythical malloc overhead. */
 
#define PERL_REGMATCH_SLAB_SLOTS \
    ((4096 - 3 * sizeof (void*)) / sizeof(regmatch_state))

typedef struct regmatch_slab {
    regmatch_state states[PERL_REGMATCH_SLAB_SLOTS];
    struct regmatch_slab *prev, *next;
} regmatch_slab;



/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d105 1
d120 1
d127 2
d137 1
d143 1
d177 1
a177 1
    void    (*free) (pTHX_ REGEXP * const rx);
d194 1
a194 1
		    REGEXP *VOL old_re,
d251 1
a251 1
NULL will be returned if a REGEXP* is not found.
d281 1
a281 1
#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED)
d283 13
a295 5
#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl)                        \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;   \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;   \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;   \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED;   break
d299 1
a299 1
    *(pmfl) &= ~(RXf_PMf_FOLD|RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_EXTENDED|RXf_PMf_CHARSET)
d311 1
d327 1
d340 1
a340 1
#define STD_PAT_MODS        "msix"
d349 1
a349 1
#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS
a359 4
/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT)

d365 1
a365 4
#define RXf_SPLIT                (1<<(RXf_BASE_SHIFT-1))
#if RXf_SPLIT != RXf_PMf_SPLIT
#   error "RXf_SPLIT does not match RXf_PMf_SPLIT"
#endif
d367 32
a398 7
/* Manually decorate this function with gcc-style attributes just to
 * avoid having to restructure the header files and their called order,
 * as proto.h would have to be included before this file, and isn't */

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
    __attribute__warn_unused_result__;
d400 1
a400 30
#define MAX_CHARSET_NAME_LENGTH 2

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
{
    /* Returns a string that corresponds to the name of the regex character set
     * given by 'flags', and *lenp is set the length of that string, which
     * cannot exceed MAX_CHARSET_NAME_LENGTH characters */

    *lenp = 1;
    switch (get_regex_charset(flags)) {
        case REGEX_DEPENDS_CHARSET: return DEPENDS_PAT_MODS;
        case REGEX_LOCALE_CHARSET:  return LOCALE_PAT_MODS;
        case REGEX_UNICODE_CHARSET: return UNICODE_PAT_MODS;
	case REGEX_ASCII_RESTRICTED_CHARSET: return ASCII_RESTRICT_PAT_MODS;
	case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
	    *lenp = 2;
	    return ASCII_MORE_RESTRICT_PAT_MODS;
        default:
	    return "?";	    /* Unknown */
    }
}

/* Do we have some sort of anchor? */
#define RXf_IS_ANCHORED         (1<<(RXf_BASE_SHIFT+0))
#define RXf_UNUSED1             (1<<(RXf_BASE_SHIFT+1))
#define RXf_UNUSED2             (1<<(RXf_BASE_SHIFT+2))
#define RXf_UNUSED3             (1<<(RXf_BASE_SHIFT+3))
#define RXf_UNUSED4             (1<<(RXf_BASE_SHIFT+4))
#define RXf_UNUSED5             (1<<(RXf_BASE_SHIFT+5))
d403 2
a404 3
#define RXf_NO_INPLACE_SUBST    (1<<(RXf_BASE_SHIFT+6))
#define RXf_EVAL_SEEN   	(1<<(RXf_BASE_SHIFT+7))
#define RXf_UNUSED8             (1<<(RXf_BASE_SHIFT+8))
d407 2
a408 2
#define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1<<(RXf_BASE_SHIFT+9))
#define RXf_CHECK_ALL   	(1<<(RXf_BASE_SHIFT+10))
d411 1
a411 1
#define RXf_MATCH_UTF8  	(1<<(RXf_BASE_SHIFT+11)) /* $1 etc are utf8 */
d414 3
a416 3
#define RXf_USE_INTUIT_NOML	(1<<(RXf_BASE_SHIFT+12))
#define RXf_USE_INTUIT_ML	(1<<(RXf_BASE_SHIFT+13))
#define RXf_INTUIT_TAIL 	(1<<(RXf_BASE_SHIFT+14))
d419 3
d423 1
a423 1
#define RXf_COPY_DONE   	(1<<(RXf_BASE_SHIFT+16))
d426 1
a426 1
#define RXf_TAINTED_SEEN	(1<<(RXf_BASE_SHIFT+17))
d428 1
a428 1
#define RXf_TAINTED		(1<<(RXf_BASE_SHIFT+18))
d431 12
a442 6
#define RXf_START_ONLY		(1<<(RXf_BASE_SHIFT+19)) /* Pattern is /^/ */
#define RXf_SKIPWHITE                (1<<(RXf_BASE_SHIFT+20)) /* Pattern is for a split " " */
#define RXf_WHITE		(1<<(RXf_BASE_SHIFT+21)) /* Pattern is /\s+/ */
#define RXf_NULL		(1U<<(RXf_BASE_SHIFT+22)) /* Pattern is // */
#if RXf_BASE_SHIFT+22 > 31
#   error Too many RXf_PMf bits used.  See regnodes.h for any spare in middle
d666 1
a666 1
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 1000
a750 1
	    struct regmatch_state *prev_eval;
d752 1
d756 1
a756 1
	    U32        close_paren; /* which close bracket is our end */
d758 1
d843 2
a859 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d39 2
a40 2
    I32 min_offset;
    I32 max_offset;
d43 1
a43 1
    I32 end_shift;
d46 1
d59 2
a60 2
    I32 start;
    I32 end;
d67 1
a67 1
    I32 start_tmp;
d108 3
a110 3
	I32 minlen;	/* mininum possible number of chars in string to match */\
	I32 minlenret;	/* mininum possible number of chars in $& */		\
	U32 gofs;	/* chars left of pos that we search from */	\
d128 3
a130 3
	I32 sublen;	/* Length of string pointed by subbeg */	\
	I32 suboffset;	/* byte offset of subbeg from logical start of str */ \
	I32 subcoffset;	/* suboffset equiv, but in chars (for @@-/@@+) */ \
d132 1
d151 1
a151 1
    I32 *scream_pos;		/* Internal iterator of scream. */
d160 1
a160 1
                     char* strbeg, I32 minend, SV* screamer,
d162 7
a168 2
    char*   (*intuit) (pTHX_ REGEXP * const rx, SV *sv, char *strpos,
                       char *strend, const U32 flags,
d235 1
a235 1
Convenience macro to get the REGEXP from a SV. This is approximately
d389 7
a395 11
/* Anchor and GPOS related stuff */
#define RXf_ANCH_BOL    	(1<<(RXf_BASE_SHIFT+0))
#define RXf_ANCH_MBOL   	(1<<(RXf_BASE_SHIFT+1))
#define RXf_ANCH_SBOL   	(1<<(RXf_BASE_SHIFT+2))
#define RXf_ANCH_GPOS   	(1<<(RXf_BASE_SHIFT+3))
#define RXf_GPOS_SEEN   	(1<<(RXf_BASE_SHIFT+4))
#define RXf_GPOS_FLOAT  	(1<<(RXf_BASE_SHIFT+5))
/* two bits here */
#define RXf_ANCH        	(RXf_ANCH_BOL|RXf_ANCH_MBOL|RXf_ANCH_GPOS|RXf_ANCH_SBOL)
#define RXf_GPOS_CHECK          (RXf_GPOS_SEEN|RXf_ANCH_GPOS)
#define RXf_ANCH_SINGLE         (RXf_ANCH_SBOL|RXf_ANCH_GPOS)
d400 1
a400 1
#define RXf_CANY_SEEN   	(1<<(RXf_BASE_SHIFT+8))
d403 1
a403 1
#define RXf_NOSCAN      	(1<<(RXf_BASE_SHIFT+9))
d407 1
a407 1
#define RXf_MATCH_UTF8  	(1<<(RXf_BASE_SHIFT+11))
d418 1
a418 2
/* during execution: pattern temporarily tainted by executing locale ops;
 * post-execution: $1 et al are tainted */
d438 1
a438 1
#if NO_TAINT_SUPPORT
d501 4
d532 2
a533 2
			? (RX_MATCH_UTF8_on(prog), (PL_reg_match_utf8 = 1)) \
			: (RX_MATCH_UTF8_off(prog), (PL_reg_match_utf8 = 0)))
d538 18
a555 10
#define REXEC_COPY_STR	0x01		/* Need to copy the string. */
#define REXEC_CHECKED	0x02		/* check_substr already checked. */
#define REXEC_SCREAM	0x04		/* use scream table. */
#define REXEC_IGNOREPOS	0x08		/* \G matches at start. */
#define REXEC_NOT_FIRST	0x10		/* This is another iteration of //g. */
                                    /* under REXEC_COPY_STR, it's ok for the
                                     * engine (modulo PL_sawamperand etc)
                                     * to skip copying ... */
#define REXEC_COPY_SKIP_PRE  0x20   /* ...the $` part of the string, or */
#define REXEC_COPY_SKIP_POST 0x40   /* ...the $' part of the string */
d588 35
d624 5
a628 1
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc */
d631 15
a645 7
    REGEXP *prog;
    char *bol;
    char *till;
    SV *sv;
    char *ganch;
    char *cutpoint;
    bool is_utf8_pat;
d664 23
a740 1
	    bool	saved_utf8_pat; /* saved copy of is_utf8_pat */
a840 41
#define PL_bostr		PL_reg_state.re_state_bostr
#define PL_regeol		PL_reg_state.re_state_regeol
#define PL_reg_match_utf8	PL_reg_state.re_state_reg_match_utf8
#define PL_reg_magic		PL_reg_state.re_state_reg_magic
#define PL_reg_oldpos		PL_reg_state.re_state_reg_oldpos
#define PL_reg_oldcurpm		PL_reg_state.re_state_reg_oldcurpm
#define PL_reg_curpm		PL_reg_state.re_state_reg_curpm
#define PL_reg_oldsaved		PL_reg_state.re_state_reg_oldsaved
#define PL_reg_oldsavedlen	PL_reg_state.re_state_reg_oldsavedlen
#define PL_reg_oldsavedoffset	PL_reg_state.re_state_reg_oldsavedoffset
#define PL_reg_oldsavedcoffset	PL_reg_state.re_state_reg_oldsavedcoffset
#define PL_reg_maxiter		PL_reg_state.re_state_reg_maxiter
#define PL_reg_leftiter		PL_reg_state.re_state_reg_leftiter
#define PL_reg_poscache		PL_reg_state.re_state_reg_poscache
#define PL_reg_poscache_size	PL_reg_state.re_state_reg_poscache_size
#define PL_reg_starttry		PL_reg_state.re_state_reg_starttry
#define PL_nrs			PL_reg_state.re_state_nrs

struct re_save_state {
    bool re_state_eval_setup_done;	/* from regexec.c */
    bool re_state_reg_match_utf8;	/* from regexec.c */
    /* Space for U8 */
    I32 re_state_reg_oldpos;		/* from regexec.c */
    I32 re_state_reg_maxiter;		/* max wait until caching pos */
    I32 re_state_reg_leftiter;		/* wait until caching pos */
    char *re_state_bostr;
    char *re_state_regeol;		/* End of input, for $ check. */
    MAGIC *re_state_reg_magic;		/* from regexec.c */
    PMOP *re_state_reg_oldcurpm;	/* from regexec.c */
    PMOP *re_state_reg_curpm;		/* from regexec.c */
    char *re_state_reg_oldsaved;	/* old saved substr during match */
    STRLEN re_state_reg_oldsavedlen;	/* old length of saved substr during match */
    STRLEN re_state_reg_oldsavedoffset;	/* old offset of saved substr during match */
    STRLEN re_state_reg_oldsavedcoffset;/* old coffset of saved substr during match */
    STRLEN re_state_reg_poscache_size;	/* size of pos cache of WHILEM */
    char *re_state_reg_poscache;	/* cache of pos of WHILEM */
    char *re_state_reg_starttry;	/* from regexec.c */
#ifdef PERL_ANY_COW
    SV *re_state_nrs;			/* was placeholder: unused since 5.8.0 (5.7.2 patch #12027 for bug ID 20010815.012). Used to save rx->saved_copy */
#endif
};
a841 2
#define SAVESTACK_ALLOC_FOR_RE_SAVE_STATE \
	(1 + ((sizeof(struct re_save_state) - 1) / sizeof(*PL_savestack)))
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d21 2
d49 1
a49 1
#ifdef PERL_OLD_COPY_ON_WRITE
d55 2
d60 7
d78 10
d107 2
a108 2
	I32 minlen;	/* mininum possible length of string to match */\
	I32 minlenret;	/* mininum possible length of $& */		\
a121 1
	regexp_paren_pair *swap;	/* Unused: 5.10.1 and later */	\
d128 2
d133 4
a136 2
	/* number of eval groups in the pattern - for security checks */\
	PERL_BITFIELD32 seen_evals:28
d179 4
d190 6
a195 3
#define RX_BUFF_IDX_PREMATCH  -2 /* $` / ${^PREMATCH}  */
#define RX_BUFF_IDX_POSTMATCH -1 /* $' / ${^POSTMATCH} */
#define RX_BUFF_IDX_FULLMATCH      0 /* $& / ${^MATCH}     */
d339 11
a349 1
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+1)
d395 1
a395 1
#define RXf_LOOKBEHIND_SEEN	(1<<(RXf_BASE_SHIFT+6))
a409 8

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT		(1<<(RXf_BASE_SHIFT+15))

d423 1
a423 1
#define RXf_SKIPWHITE		(1<<(RXf_BASE_SHIFT+20)) /* Pattern is for a split / / */
d436 18
a454 4
#define RXp_MATCH_TAINTED(prog)	(RXp_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED(prog)	(RX_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) (RX_EXTFLAGS(prog) |= RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) (RX_EXTFLAGS(prog) &= ~RXf_TAINTED_SEEN)
d470 1
d473 2
a474 2
#define RX_PRECOMP(prog)	(RX_WRAPPED(prog) + ((struct regexp *)SvANY(prog))->pre_prefix)
#define RX_PRECOMP_const(prog)	(RX_WRAPPED_const(prog) + ((struct regexp *)SvANY(prog))->pre_prefix)
d478 3
a480 3
#define RX_PRELEN(prog)		(RX_WRAPLEN(prog) - ((struct regexp *)SvANY(prog))->pre_prefix - 1)
#define RX_WRAPPED(prog)	SvPVX(prog)
#define RX_WRAPPED_const(prog)	SvPVX_const(prog)
d482 1
a482 1
#define RX_CHECK_SUBSTR(prog)	(((struct regexp *)SvANY(prog))->check_substr)
d484 15
a498 46
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define RX_EXTFLAGS(prog)						\
    (*({								\
	const REGEXP *const _rx_extflags = (prog);			\
	assert(SvTYPE(_rx_extflags) == SVt_REGEXP);			\
	&RXp_EXTFLAGS(SvANY(_rx_extflags));				\
    }))
#  define RX_ENGINE(prog)						\
    (*({								\
	const REGEXP *const _rx_engine = (prog);			\
	assert(SvTYPE(_rx_engine) == SVt_REGEXP);			\
	&SvANY(_rx_engine)->engine;					\
    }))
#  define RX_SUBBEG(prog)						\
    (*({								\
	const REGEXP *const _rx_subbeg = (prog);			\
	assert(SvTYPE(_rx_subbeg) == SVt_REGEXP);			\
	&SvANY(_rx_subbeg)->subbeg;					\
    }))
#  define RX_OFFS(prog)							\
    (*({								\
	const REGEXP *const _rx_offs = (prog);				\
	assert(SvTYPE(_rx_offs) == SVt_REGEXP);				\
	&SvANY(_rx_offs)->offs;						\
    }))
#  define RX_NPARENS(prog)						\
    (*({								\
	const REGEXP *const _rx_nparens = (prog);			\
	assert(SvTYPE(_rx_nparens) == SVt_REGEXP);			\
	&SvANY(_rx_nparens)->nparens;					\
    }))
#else
#  define RX_EXTFLAGS(prog)	RXp_EXTFLAGS((struct regexp *)SvANY(prog))
#  define RX_ENGINE(prog)	(((struct regexp *)SvANY(prog))->engine)
#  define RX_SUBBEG(prog)	(((struct regexp *)SvANY(prog))->subbeg)
#  define RX_OFFS(prog)		(((struct regexp *)SvANY(prog))->offs)
#  define RX_NPARENS(prog)	(((struct regexp *)SvANY(prog))->nparens)
#endif
#define RX_SUBLEN(prog)		(((struct regexp *)SvANY(prog))->sublen)
#define RX_MINLEN(prog)		(((struct regexp *)SvANY(prog))->minlen)
#define RX_MINLENRET(prog)	(((struct regexp *)SvANY(prog))->minlenret)
#define RX_GOFS(prog)		(((struct regexp *)SvANY(prog))->gofs)
#define RX_LASTPAREN(prog)	(((struct regexp *)SvANY(prog))->lastparen)
#define RX_LASTCLOSEPAREN(prog)	(((struct regexp *)SvANY(prog))->lastcloseparen)
#define RX_SEEN_EVALS(prog)	(((struct regexp *)SvANY(prog))->seen_evals)
#define RX_SAVED_COPY(prog)	(((struct regexp *)SvANY(prog))->saved_copy)
d504 1
a504 1
#ifdef PERL_OLD_COPY_ON_WRITE
d537 5
d562 1
d584 2
d617 1
d626 1
d636 1
d640 1
a641 1
	    regnode	*B;	/* node following the trie */
a646 1
	    bool	longfold;/* saw a fold with a 1->n char mapping */
d657 1
a657 3
	    U32		toggle_reg_flags; /* what bits in PL_reg_flags to
					    flip when transitioning between
					    inner and outer rexen */
d715 1
a715 1
	    I32 c1, c2;		/* case fold search */
d717 2
d724 2
d731 3
a733 1
	    I32 c1, c2;		/* case fold search */
d739 2
a757 1
#define PL_reg_flags		PL_reg_state.re_state_reg_flags
a758 1
#define PL_reginput		PL_reg_state.re_state_reginput
a759 6
#define PL_regoffs		PL_reg_state.re_state_regoffs
#define PL_reglastparen		PL_reg_state.re_state_reglastparen
#define PL_reglastcloseparen	PL_reg_state.re_state_reglastcloseparen
#define PL_reg_start_tmp	PL_reg_state.re_state_reg_start_tmp
#define PL_reg_start_tmpl	PL_reg_state.re_state_reg_start_tmpl
#define PL_reg_eval_set		PL_reg_state.re_state_reg_eval_set
d767 2
a772 1
#define PL_regsize		PL_reg_state.re_state_regsize
d777 1
a777 3
    U32 re_state_reg_flags;		/* from regexec.c */
    U32 re_state_reg_start_tmpl;	/* from regexec.c */
    I32 re_state_reg_eval_set;		/* from regexec.c */
d779 4
a783 1
    char *re_state_reginput;		/* String-input pointer. */
a784 4
    regexp_paren_pair *re_state_regoffs;  /* Pointer to start/end pairs */
    U32 *re_state_reglastparen;		/* Similarly for lastparen. */
    U32 *re_state_reglastcloseparen;	/* Similarly for lastcloseparen. */
    char **re_state_reg_start_tmp;	/* from regexec.c */
d790 2
a792 4
    I32 re_state_reg_oldpos;		/* from regexec.c */
    I32 re_state_reg_maxiter;		/* max wait until caching pos */
    I32 re_state_reg_leftiter;		/* wait until caching pos */
    U32 re_state_regsize;		/* from regexec.c */
d795 1
a795 1
#ifdef PERL_OLD_COPY_ON_WRITE
d807 1
a807 1
 * indent-tabs-mode: t
d810 1
a810 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d58 9
d82 1
a115 1
	_XPVMG_HEAD;
d119 1
a119 4
/*        HV *paren_names;	 Optional hash of paren names
	  now stored in the IV union */

#define RXp_PAREN_NAMES(rx)	((rx)->xiv_u.xivu_hv)
d202 4
a205 7
    if (SvROK(sv) &&
        (tmpsv = (SV*)SvRV(sv)) &&
        SvTYPE(tmpsv) == SVt_PVMG &&
        (tmpmg = mg_find(tmpsv, PERL_MAGIC_qr)))
    {
        return (REGEXP *)tmpmg->mg_obj;
    }
d211 2
a212 2
Returns a boolean indicating whether the SV contains qr magic
(PERL_MAGIC_qr).
d227 2
a228 3
 * Note that flags starting with RXf_PMf_ have exact equivalents
 * stored in op_pmflags and which are defined in op.h, they are defined
 * numerically here only for clarity.
d230 2
a231 2
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes.
d235 2
a236 11
/* 0x3F of extflags is used by (RXf_)PMf_COMPILETIME
 * If you change these you need to change the equivalent flags in op.h, and
 * vice versa.  */
#define RXf_PMf_MULTILINE	0x00000001 /* /m         */
#define RXf_PMf_SINGLELINE	0x00000002 /* /s         */
#define RXf_PMf_FOLD    	0x00000004 /* /i         */
#define RXf_PMf_EXTENDED	0x00000008 /* /x         */
#define RXf_PMf_KEEPCOPY	0x00000010 /* /p         */
#define RXf_PMf_LOCALE  	0x00000020 /* use locale */
/* these flags are transfered from the PMOP->op_pmflags member during compilation */
#define RXf_PMf_STD_PMMOD_SHIFT	0
a237 1
#define RXf_PMf_COMPILETIME	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_LOCALE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_KEEPCOPY)
d245 4
d250 1
a250 1
 * Singlular is a 'c'har, plural is a "string"
d256 1
d266 5
d276 11
d288 1
a288 1
#define STD_PAT_MODS        "msix"
d290 3
d296 1
a296 1
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS
d298 1
a298 1
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS
d301 2
a302 2
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes.
d306 35
d342 6
a347 6
#define RXf_ANCH_BOL    	0x00000100
#define RXf_ANCH_MBOL   	0x00000200
#define RXf_ANCH_SBOL   	0x00000400
#define RXf_ANCH_GPOS   	0x00000800
#define RXf_GPOS_SEEN   	0x00001000
#define RXf_GPOS_FLOAT  	0x00002000
d354 3
a356 3
#define RXf_LOOKBEHIND_SEEN	0x00004000
#define RXf_EVAL_SEEN   	0x00008000
#define RXf_CANY_SEEN   	0x00010000
d359 2
a360 2
#define RXf_NOSCAN      	0x00020000
#define RXf_CHECK_ALL   	0x00040000
d363 1
a363 1
#define RXf_MATCH_UTF8  	0x00100000
d366 3
a368 3
#define RXf_USE_INTUIT_NOML	0x00200000
#define RXf_USE_INTUIT_ML	0x00400000
#define RXf_INTUIT_TAIL 	0x00800000
d375 1
a375 1
#define RXf_SPLIT		0x01000000
d380 7
a386 3
#define RXf_COPY_DONE   	0x02000000
#define RXf_TAINTED_SEEN	0x04000000
#define RXf_TAINTED		0x08000000 /* this pattern is tainted */
d389 7
a395 4
#define RXf_START_ONLY		0x10000000 /* Pattern is /^/ */
#define RXf_SKIPWHITE		0x20000000 /* Pattern is for a split / / */
#define RXf_WHITE		0x40000000 /* Pattern is /\s+/ */
#define RXf_NULL		0x80000000 /* Pattern is // */
d398 2
a399 2
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes.
d485 1
a485 1
/* Stuff that needs to be included in the plugable extension goes below here */
a550 7
/* an accepting state/position*/
struct _reg_trie_accepted {
    U8   *endpos;
    U16  wordnum;
};
typedef struct _reg_trie_accepted reg_trie_accepted;

d611 1
a611 2
	    reg_trie_accepted *accept_buff; /* accepting states we have seen */
	    U32		accepted; /* how many accepting states we have seen */
d615 5
d665 2
a666 1
	    regnode	*A, *B;	/* the nodes corresponding to /A*B/  */
a669 2
	    int		min;	/* the minimal number of A's to match */
	    int		max;	/* the maximal number of A's to match */
@


1.9
log
@Merge in perl 5.10.1
@
text
@d69 35
d105 3
a107 41
        /* what engine created this regexp? */
	const struct regexp_engine* engine; 
	struct regexp* mother_re; /* what re is this a lightweight copy of? */
	
	/* Information about the match that the perl core uses to manage things */
	U32 extflags;           /* Flags used both externally and internally */
	I32 minlen;		/* mininum possible length of string to match */
	I32 minlenret;		/* mininum possible length of $& */
	U32 gofs;               /* chars left of pos that we search from */
	struct reg_substr_data *substrs; /* substring data about strings that must appear
                                   in the final match, used for optimisations */
	U32 nparens;		/* number of capture buffers */

        /* private engine specific data */
	U32 intflags;		/* Engine Specific Internal flags */
	void *pprivate;         /* Data private to the regex engine which 
                                   created this object. */
        
        /* Data about the last/current match. These are modified during matching*/
        U32 lastparen;		/* last open paren matched */
	U32 lastcloseparen;	/* last close paren matched */
        regexp_paren_pair *swap;  /* Swap copy of *offs */ 
        regexp_paren_pair *offs;  /* Array of offsets for (@@-) and (@@+) */

	char *subbeg;		/* saved or original string 
				   so \digit works forever. */
	SV_SAVED_COPY           /* If non-NULL, SV which is COW from original */
	I32 sublen;		/* Length of string pointed by subbeg */
        
        
        /* Information about the match that isn't often used */
	I32 prelen;		/* length of precomp */
	const char *precomp;	/* pre-compilation regular expression */
	/* wrapped can't be const char*, as it is returned by sv_2pv_flags */
	char *wrapped;          /* wrapped version of the pattern */
	I32 wraplen;		/* length of wrapped */
	I32 seen_evals;         /* number of eval groups in the pattern - for security checks */ 
        HV *paren_names;	/* Optional hash of paren names */
        
        /* Refcount of this regexp */
	I32 refcnt;             /* Refcount of this regexp */
d110 4
a113 1
#define RXp_PAREN_NAMES(rx)	((rx)->paren_names)
d126 1
a126 1
    REGEXP* (*comp) (pTHX_ const SV * const pattern, const U32 flags);
d233 1
a233 19
/* Anchor and GPOS related stuff */
#define RXf_ANCH_BOL    	0x00000001
#define RXf_ANCH_MBOL   	0x00000002
#define RXf_ANCH_SBOL   	0x00000004
#define RXf_ANCH_GPOS   	0x00000008
#define RXf_GPOS_SEEN   	0x00000010
#define RXf_GPOS_FLOAT  	0x00000020
/* two bits here */
#define RXf_ANCH        	(RXf_ANCH_BOL|RXf_ANCH_MBOL|RXf_ANCH_GPOS|RXf_ANCH_SBOL)
#define RXf_GPOS_CHECK          (RXf_GPOS_SEEN|RXf_ANCH_GPOS)
#define RXf_ANCH_SINGLE         (RXf_ANCH_SBOL|RXf_ANCH_GPOS)

/* Flags indicating special patterns */
#define RXf_SKIPWHITE		0x00000100 /* Pattern is for a split / / */
#define RXf_START_ONLY		0x00000200 /* Pattern is /^/ */
#define RXf_WHITE		0x00000400 /* Pattern is /\s+/ */
#define RXf_NULL		0x40000000 /* Pattern is // */

/* 0x1F800 of extflags is used by (RXf_)PMf_COMPILETIME
d236 6
a241 6
#define RXf_PMf_LOCALE  	0x00000800 /* use locale */
#define RXf_PMf_MULTILINE	0x00001000 /* /m         */
#define RXf_PMf_SINGLELINE	0x00002000 /* /s         */
#define RXf_PMf_FOLD    	0x00004000 /* /i         */
#define RXf_PMf_EXTENDED	0x00008000 /* /x         */
#define RXf_PMf_KEEPCOPY	0x00010000 /* /p         */
d243 1
a243 1
#define RXf_PMf_STD_PMMOD_SHIFT	12
d290 12
d303 3
a305 3
#define RXf_LOOKBEHIND_SEEN	0x00020000
#define RXf_EVAL_SEEN   	0x00040000
#define RXf_CANY_SEEN   	0x00080000
d308 2
a309 2
#define RXf_NOSCAN      	0x00100000
#define RXf_CHECK_ALL   	0x00200000
d312 1
a312 2
#define RXf_UTF8        	0x00400000
#define RXf_MATCH_UTF8  	0x00800000
d315 3
a317 3
#define RXf_USE_INTUIT_NOML	0x01000000
#define RXf_USE_INTUIT_ML	0x02000000
#define RXf_INTUIT_TAIL 	0x04000000
d324 1
a324 1
#define RXf_SPLIT           0x08000000
d329 9
a337 3
#define RXf_COPY_DONE   	0x10000000
#define RXf_TAINTED_SEEN	0x20000000
#define RXf_TAINTED             0x80000000 /* this pattern is tainted */
d366 58
a423 21
#define RX_PRECOMP(prog)	((prog)->precomp)
/* *** 5.10.x-specific definition of RX_PRECOMP_const */
#define RX_PRECOMP_const(prog)	((prog)->precomp)
#define RX_PRELEN(prog)		((prog)->prelen)
#define RX_WRAPPED(prog)	((prog)->wrapped)
#define RX_WRAPLEN(prog)	((prog)->wraplen)
#define RX_CHECK_SUBSTR(prog)	((prog)->check_substr)
#define RX_EXTFLAGS(prog)	((prog)->extflags)
#define RX_REFCNT(prog)		((prog)->refcnt)
#define RX_ENGINE(prog)		((prog)->engine)
#define RX_SUBBEG(prog)		((prog)->subbeg)
#define RX_OFFS(prog)		((prog)->offs)
#define RX_NPARENS(prog)	((prog)->nparens)
#define RX_SUBLEN(prog)		((prog)->sublen)
#define RX_SUBBEG(prog)		((prog)->subbeg)
#define RX_MINLEN(prog)		((prog)->minlen)
#define RX_MINLENRET(prog)	((prog)->minlenret)
#define RX_GOFS(prog)		((prog)->gofs)
#define RX_LASTPAREN(prog)	((prog)->lastparen)
#define RX_LASTCLOSEPAREN(prog)	((prog)->lastcloseparen)
#define RX_SEEN_EVALS(prog)	((prog)->seen_evals)
d431 2
a432 2
	STMT_START {if (rx->saved_copy) { \
	    SV_CHECK_THINKFIRST_COW_DROP(rx->saved_copy); \
d455 1
a455 1
#define RX_UTF8(prog)			(RX_EXTFLAGS(prog) & RXf_UTF8)
d463 21
a483 2
#define ReREFCNT_inc(re) ((void)(re && re->refcnt++), re)
#define ReREFCNT_dec(re) CALLREGFREE(re)
d504 1
a504 1
    regexp *prog;
d574 1
a574 1
	    regexp	*prev_rex;
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 *    2005, 2006, 2007, by Larry Wall and others
d113 2
d184 1
a184 1
#define RXapif_REGNAMES_COUNT  0x1000 
d221 1
a221 1
/* Flags stored in regexp->extflags 
d229 1
a229 1
 * so that regnodes.h is updated with the changes. 
d251 3
a253 1
/* 0x1F800 of extflags is used by (RXf_)PMf_COMPILETIME */
d261 1
d304 1
a304 1
 * so that regnodes.h is updated with the changes. 
d342 1
a342 1
 * so that regnodes.h is updated with the changes. 
d347 4
a350 3
#define RX_MATCH_TAINTED(prog)	((prog)->extflags & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->extflags |= RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->extflags &= ~RXf_TAINTED_SEEN)
d355 6
a360 3
#define RX_MATCH_COPIED(prog)		((prog)->extflags & RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	((prog)->extflags |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	((prog)->extflags &= ~RXf_COPY_DONE)
d365 24
d399 1
a399 1
	    Safefree(rx->subbeg); \
d405 1
a405 1
	    Safefree(rx->subbeg); \
d410 4
a413 3
#define RX_MATCH_UTF8(prog)		((prog)->extflags & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		((prog)->extflags |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		((prog)->extflags &= ~RXf_MATCH_UTF8)
d417 4
a420 1
    
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    by Larry Wall and others
d17 3
a19 1

d33 36
d70 24
a93 6
	I32 *startp;
	I32 *endp;
	regnode *regstclass;
        struct reg_substr_data *substrs;
	char *precomp;		/* pre-compilation regular expression */
        struct reg_data *data;	/* Additional data. */
d96 1
a96 1
        U32 *offsets;           /* offset annotations 20001228 MJD */
d98 3
a100 2
	I32 refcnt;
	I32 minlen;		/* mininum possible length of $& */
d102 9
a110 6
	U32 nparens;		/* number of parentheses */
	U32 lastparen;		/* last paren matched */
	U32 lastcloseparen;	/* last paren matched */
	U32 reganch;		/* Internal use only +
				   Tainted information used by regexec? */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
d113 232
a344 40
#define ROPT_ANCH		(ROPT_ANCH_BOL|ROPT_ANCH_MBOL|ROPT_ANCH_GPOS|ROPT_ANCH_SBOL)
#define ROPT_ANCH_SINGLE	(ROPT_ANCH_SBOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_BOL	 	0x00001
#define ROPT_ANCH_MBOL	 	0x00002
#define ROPT_ANCH_SBOL	 	0x00004
#define ROPT_ANCH_GPOS	 	0x00008
#define ROPT_SKIP		0x00010
#define ROPT_IMPLICIT		0x00020	/* Converted .* to ^.* */
#define ROPT_NOSCAN		0x00040	/* Check-string always at start. */
#define ROPT_GPOS_SEEN		0x00080
#define ROPT_CHECK_ALL		0x00100
#define ROPT_LOOKBEHIND_SEEN	0x00200
#define ROPT_EVAL_SEEN		0x00400
#define ROPT_CANY_SEEN		0x00800
#define ROPT_SANY_SEEN		ROPT_CANY_SEEN /* src bckwrd cmpt */

/* 0xf800 of reganch is used by PMf_COMPILETIME */

#define ROPT_UTF8		0x10000
#define ROPT_NAUGHTY		0x20000 /* how exponential is this pattern? */
#define ROPT_COPY_DONE		0x40000	/* subbeg is a copy of the string */
#define ROPT_TAINTED_SEEN	0x80000
#define ROPT_MATCH_UTF8		0x10000000 /* subbeg is utf-8 */

#define RE_USE_INTUIT_NOML	0x0100000 /* Best to intuit before matching */
#define RE_USE_INTUIT_ML	0x0200000
#define REINT_AUTORITATIVE_NOML	0x0400000 /* Can trust a positive answer */
#define REINT_AUTORITATIVE_ML	0x0800000 
#define REINT_ONCE_NOML		0x1000000 /* Intuit can succed once only. */
#define REINT_ONCE_ML		0x2000000
#define RE_INTUIT_ONECHAR	0x4000000
#define RE_INTUIT_TAIL		0x8000000

#define RE_USE_INTUIT		(RE_USE_INTUIT_NOML|RE_USE_INTUIT_ML)
#define REINT_AUTORITATIVE	(REINT_AUTORITATIVE_NOML|REINT_AUTORITATIVE_ML)
#define REINT_ONCE		(REINT_ONCE_NOML|REINT_ONCE_ML)

#define RX_MATCH_TAINTED(prog)	((prog)->reganch & ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->reganch |= ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->reganch &= ~ROPT_TAINTED_SEEN)
d349 3
a351 3
#define RX_MATCH_COPIED(prog)		((prog)->reganch & ROPT_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	((prog)->reganch |= ROPT_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	((prog)->reganch &= ~ROPT_COPY_DONE)
d356 24
a379 3
#define RX_MATCH_UTF8(prog)		((prog)->reganch & ROPT_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		((prog)->reganch |= ROPT_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		((prog)->reganch &= ~ROPT_MATCH_UTF8)
a388 1
#define REXEC_ML	0x20		/* $* was set. */
d391 1
a391 1
#define ReREFCNT_dec(re) CALLREGFREE(aTHX_ re)
d401 244
a644 1
struct re_scream_pos_data_s;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
d75 1
d104 7
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 6
d39 1
d46 1
d65 2
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d22 2
@


1.3
log
@perl5.005_03 (stock)
@
text
@d20 1
a20 15
struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;
};

struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};
d23 9
a32 3
	char **startp;
	char **endp;
	regnode *regstclass;
d37 1
a37 6
	char *precomp;		/* pre-compilation regular expression */
	char *subbase;		/* saved string so \digit works forever */
	char *subbeg;		/* same, but not responsible for allocation */
	char *subend;		/* end of subbase */
	U16 naughty;		/* how exponential is this pattern? */
	U16 reganch;		/* Internal use only +
a38 13
#if 0
        SV *anchored_substr;	/* Substring at fixed position wrt start. */
	I32 anchored_offset;	/* Position of it. */
        SV *float_substr;	/* Substring at variable position wrt start. */
	I32 float_min_offset;	/* Minimal position of it. */
	I32 float_max_offset;	/* Maximal position of it. */
        SV *check_substr;	/* Substring to check before matching. */
        I32 check_offset_min;	/* Offset of the above. */
        I32 check_offset_max;	/* Offset of the above. */
#else
        struct reg_substr_data *substrs;
#endif
        struct reg_data *data;	/* Additional data. */
d42 14
a55 22
#define anchored_substr substrs->data[0].substr
#define anchored_offset substrs->data[0].min_offset
#define float_substr substrs->data[1].substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define check_substr substrs->data[2].substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset

#define ROPT_ANCH		(ROPT_ANCH_BOL|ROPT_ANCH_MBOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_SINGLE	(ROPT_ANCH_BOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_BOL	 	1
#define ROPT_ANCH_MBOL	 	2
#define ROPT_ANCH_GPOS	 	4
#define ROPT_SKIP		8
#define ROPT_IMPLICIT		0x10	/* Converted .* to ^.* */
#define ROPT_NOSCAN		0x20	/* Check-string always at start. */
#define ROPT_GPOS_SEEN		0x40
#define ROPT_CHECK_ALL		0x80
#define ROPT_LOOKBEHIND_SEEN	0x100
#define ROPT_EVAL_SEEN		0x200
#define ROPT_TAINTED_SEEN	0x400
d58 18
d83 24
a106 2
#define REXEC_COPY_STR	1		/* Need to copy the string. */
#define REXEC_CHECKED	2		/* check_substr already checked. */
d108 1
a108 2
#define ReREFCNT_inc(re) ((re && re->refcnt++), re)
#define ReREFCNT_dec(re) pregfree(re)
@


1.2
log
@perl 5.004_04
@
text
@d12 24
d37 1
d40 1
a40 4
	SV *regstart;		/* Internal use only. */
	char *regstclass;
	SV *regmust;		/* Internal use only. */
	I32 regback;		/* Can regmust locate first try? */
d50 16
a65 3
	char reganch;		/* Internal use only. */
	char exec_tainted;	/* Tainted information used by regexec? */
	char program[1];	/* Unwarranted chumminess with compiler. */
d68 36
a103 5
#define ROPT_ANCH	3
#define  ROPT_ANCH_BOL	 1
#define  ROPT_ANCH_GPOS	 2
#define ROPT_SKIP	4
#define ROPT_IMPLICIT	8
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
	char do_folding;	/* do case-insensitive match? */
d33 5
a37 3
#define ROPT_ANCH 1
#define ROPT_SKIP 2
#define ROPT_IMPLICIT 4
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a11 24
struct regnode {
    U8	flags;
    U8  type;
    U16 next_off;
};

typedef struct regnode regnode;

struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;
};

struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

a12 1
	I32 refcnt;
d15 4
a18 1
	regnode *regstclass;
d28 3
a30 16
	U16 reganch;		/* Internal use only +
				   Tainted information used by regexec? */
#if 0
        SV *anchored_substr;	/* Substring at fixed position wrt start. */
	I32 anchored_offset;	/* Position of it. */
        SV *float_substr;	/* Substring at variable position wrt start. */
	I32 float_min_offset;	/* Minimal position of it. */
	I32 float_max_offset;	/* Maximal position of it. */
        SV *check_substr;	/* Substring to check before matching. */
        I32 check_offset_min;	/* Offset of the above. */
        I32 check_offset_max;	/* Offset of the above. */
#else
        struct reg_substr_data *substrs;
#endif
        struct reg_data *data;	/* Additional data. */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
d33 3
a35 36
#define anchored_substr substrs->data[0].substr
#define anchored_offset substrs->data[0].min_offset
#define float_substr substrs->data[1].substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define check_substr substrs->data[2].substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset

#define ROPT_ANCH		(ROPT_ANCH_BOL|ROPT_ANCH_MBOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_SINGLE	(ROPT_ANCH_BOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_BOL	 	1
#define ROPT_ANCH_MBOL	 	2
#define ROPT_ANCH_GPOS	 	4
#define ROPT_SKIP		8
#define ROPT_IMPLICIT		0x10	/* Converted .* to ^.* */
#define ROPT_NOSCAN		0x20	/* Check-string always at start. */
#define ROPT_GPOS_SEEN		0x40
#define ROPT_CHECK_ALL		0x80
#define ROPT_LOOKBEHIND_SEEN	0x100
#define ROPT_EVAL_SEEN		0x200
#define ROPT_TAINTED_SEEN	0x400
/* 0xf800 of reganch is used by PMf_COMPILETIME */

#define RX_MATCH_TAINTED(prog)	((prog)->reganch & ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->reganch |= ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->reganch &= ~ROPT_TAINTED_SEEN)
#define RX_MATCH_TAINTED_set(prog, t) ((t) \
				       ? RX_MATCH_TAINTED_on(prog) \
				       : RX_MATCH_TAINTED_off(prog))

#define REXEC_COPY_STR	1		/* Need to copy the string. */
#define REXEC_CHECKED	2		/* check_substr already checked. */

#define ReREFCNT_inc(re) ((re && re->refcnt++), re)
#define ReREFCNT_dec(re) pregfree(re)
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d20 15
a34 1
struct reg_substr_data;
d37 3
a39 2
	I32 *startp;
	I32 *endp;
a40 7
        struct reg_substr_data *substrs;
	char *precomp;		/* pre-compilation regular expression */
        struct reg_data *data;	/* Additional data. */
	char *subbeg;		/* saved or original string 
				   so \digit works forever. */
	I32 sublen;		/* Length of string pointed by subbeg */
	I32 refcnt;
d45 6
a50 1
	U32 reganch;		/* Internal use only +
d52 13
d68 22
a89 14
#define ROPT_ANCH		(ROPT_ANCH_BOL|ROPT_ANCH_MBOL|ROPT_ANCH_GPOS|ROPT_ANCH_SBOL)
#define ROPT_ANCH_SINGLE	(ROPT_ANCH_SBOL|ROPT_ANCH_GPOS)
#define ROPT_ANCH_BOL	 	0x00001
#define ROPT_ANCH_MBOL	 	0x00002
#define ROPT_ANCH_SBOL	 	0x00004
#define ROPT_ANCH_GPOS	 	0x00008
#define ROPT_SKIP		0x00010
#define ROPT_IMPLICIT		0x00020	/* Converted .* to ^.* */
#define ROPT_NOSCAN		0x00040	/* Check-string always at start. */
#define ROPT_GPOS_SEEN		0x00080
#define ROPT_CHECK_ALL		0x00100
#define ROPT_LOOKBEHIND_SEEN	0x00200
#define ROPT_EVAL_SEEN		0x00400

a91 18
#define ROPT_UTF8		0x10000
#define ROPT_NAUGHTY		0x20000 /* how exponential is this pattern? */
#define ROPT_COPY_DONE		0x40000	/* subbeg is a copy of the string */
#define ROPT_TAINTED_SEEN	0x80000

#define RE_USE_INTUIT_NOML	0x0100000 /* Best to intuit before matching */
#define RE_USE_INTUIT_ML	0x0200000
#define REINT_AUTORITATIVE_NOML	0x0400000 /* Can trust a positive answer */
#define REINT_AUTORITATIVE_ML	0x0800000 
#define REINT_ONCE_NOML		0x1000000 /* Intuit can succed once only. */
#define REINT_ONCE_ML		0x2000000
#define RE_INTUIT_ONECHAR	0x4000000
#define RE_INTUIT_TAIL		0x8000000

#define RE_USE_INTUIT		(RE_USE_INTUIT_NOML|RE_USE_INTUIT_ML)
#define REINT_AUTORITATIVE	(REINT_AUTORITATIVE_NOML|REINT_AUTORITATIVE_ML)
#define REINT_ONCE		(REINT_ONCE_NOML|REINT_ONCE_ML)

d99 2
a100 24
#define RX_MATCH_COPIED(prog)		((prog)->reganch & ROPT_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	((prog)->reganch |= ROPT_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	((prog)->reganch &= ~ROPT_COPY_DONE)
#define RX_MATCH_COPIED_set(prog,t)	((t) \
					 ? RX_MATCH_COPIED_on(prog) \
					 : RX_MATCH_COPIED_off(prog))

#define REXEC_COPY_STR	0x01		/* Need to copy the string. */
#define REXEC_CHECKED	0x02		/* check_substr already checked. */
#define REXEC_SCREAM	0x04		/* use scream table. */
#define REXEC_IGNOREPOS	0x08		/* \G matches at start. */
#define REXEC_NOT_FIRST	0x10		/* This is another iteration of //g. */
#define REXEC_ML	0x20		/* $* was set. */

#define ReREFCNT_inc(re) ((void)(re && re->refcnt++), re)
#define ReREFCNT_dec(re) CALLREGFREE(aTHX_ re)

#define FBMcf_TAIL_DOLLAR	1
#define FBMcf_TAIL_DOLLARM	2
#define FBMcf_TAIL_Z		4
#define FBMcf_TAIL_z		8
#define FBMcf_TAIL		(FBMcf_TAIL_DOLLAR|FBMcf_TAIL_DOLLARM|FBMcf_TAIL_Z|FBMcf_TAIL_z)

#define FBMrf_MULTILINE	1
d102 2
a103 1
struct re_scream_pos_data_s;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a21 2
struct reg_data;

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a1 6
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
a32 1
        U32 *offsets;           /* offset annotations 20001228 MJD */
a38 1
	U32 lastcloseparen;	/* last paren matched */
a56 2
#define ROPT_CANY_SEEN		0x00800
#define ROPT_SANY_SEEN		ROPT_CANY_SEEN /* src bckwrd cmpt */
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000, 2001, 2003,
 *    by Larry Wall and others
a73 1
#define ROPT_MATCH_UTF8		0x10000000 /* subbeg is utf-8 */
a101 7
#define RX_MATCH_UTF8(prog)		((prog)->reganch & ROPT_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		((prog)->reganch |= ROPT_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		((prog)->reganch &= ~ROPT_MATCH_UTF8)
#define RX_MATCH_UTF8_set(prog, t)	((t) \
			? (RX_MATCH_UTF8_on(prog), (PL_reg_match_utf8 = 1)) \
			: (RX_MATCH_UTF8_off(prog), (PL_reg_match_utf8 = 0)))
    
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2005, 2006, 2007, by Larry Wall and others
d17 1
a17 3
#ifndef PLUGGABLE_RE_EXTENSION
/* we don't want to include this stuff if we are inside of
   an external regex engine based on the core one - like re 'debug'*/
a30 36
struct regexp_engine;
struct regexp;

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
    I32 end_shift;
};
struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

#ifdef PERL_OLD_COPY_ON_WRITE
#define SV_SAVED_COPY   SV *saved_copy; /* If non-NULL, SV which is COW from original */
#else
#define SV_SAVED_COPY
#endif

typedef struct regexp_paren_pair {
    I32 start;
    I32 end;
} regexp_paren_pair;

/*
  The regexp/REGEXP struct, see L<perlreapi> for further documentation
  on the individual fields. The struct is ordered so that the most
  commonly used fields are placed at the start.

  Any patch that adds items to this struct will need to include
  changes to F<sv.c> (C<Perl_re_dup()>) and F<regcomp.c>
  (C<pregfree()>). This involves freeing or cloning items in the
  regexp's data array based on the data item's type.
*/

d32 6
a37 24
        /* what engine created this regexp? */
	const struct regexp_engine* engine; 
	struct regexp* mother_re; /* what re is this a lightweight copy of? */
	
	/* Information about the match that the perl core uses to manage things */
	U32 extflags;           /* Flags used both externally and internally */
	I32 minlen;		/* mininum possible length of string to match */
	I32 minlenret;		/* mininum possible length of $& */
	U32 gofs;               /* chars left of pos that we search from */
	struct reg_substr_data *substrs; /* substring data about strings that must appear
                                   in the final match, used for optimisations */
	U32 nparens;		/* number of capture buffers */

        /* private engine specific data */
	U32 intflags;		/* Engine Specific Internal flags */
	void *pprivate;         /* Data private to the regex engine which 
                                   created this object. */
        
        /* Data about the last/current match. These are modified during matching*/
        U32 lastparen;		/* last open paren matched */
	U32 lastcloseparen;	/* last close paren matched */
        regexp_paren_pair *swap;  /* Swap copy of *offs */ 
        regexp_paren_pair *offs;  /* Array of offsets for (@@-) and (@@+) */

d40 1
a40 1
	SV_SAVED_COPY           /* If non-NULL, SV which is COW from original */
d42 2
a43 3
        
        
        /* Information about the match that isn't often used */
d45 6
a50 9
	const char *precomp;	/* pre-compilation regular expression */
	/* wrapped can't be const char*, as it is returned by sv_2pv_flags */
	char *wrapped;          /* wrapped version of the pattern */
	I32 wraplen;		/* length of wrapped */
	I32 seen_evals;         /* number of eval groups in the pattern - for security checks */ 
        HV *paren_names;	/* Optional hash of paren names */
        
        /* Refcount of this regexp */
	I32 refcnt;             /* Refcount of this regexp */
d53 40
a92 232
/* used for high speed searches */
typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    I32 *scream_pos;		/* Internal iterator of scream. */
} re_scream_pos_data;

/* regexp_engine structure. This is the dispatch table for regexes.
 * Any regex engine implementation must be able to build one of these.
 */
typedef struct regexp_engine {
    REGEXP* (*comp) (pTHX_ const SV * const pattern, const U32 flags);
    I32     (*exec) (pTHX_ REGEXP * const rx, char* stringarg, char* strend,
                     char* strbeg, I32 minend, SV* screamer,
                     void* data, U32 flags);
    char*   (*intuit) (pTHX_ REGEXP * const rx, SV *sv, char *strpos,
                       char *strend, const U32 flags,
                       re_scream_pos_data *data);
    SV*     (*checkstr) (pTHX_ REGEXP * const rx);
    void    (*free) (pTHX_ REGEXP * const rx);
    void    (*numbered_buff_FETCH) (pTHX_ REGEXP * const rx, const I32 paren,
                                    SV * const sv);
    void    (*numbered_buff_STORE) (pTHX_ REGEXP * const rx, const I32 paren,
                                   SV const * const value);
    I32     (*numbered_buff_LENGTH) (pTHX_ REGEXP * const rx, const SV * const sv,
                                    const I32 paren);
    SV*     (*named_buff) (pTHX_ REGEXP * const rx, SV * const key,
                           SV * const value, const U32 flags);
    SV*     (*named_buff_iter) (pTHX_ REGEXP * const rx, const SV * const lastkey,
                                const U32 flags);
    SV*     (*qr_package)(pTHX_ REGEXP * const rx);
#ifdef USE_ITHREADS
    void*   (*dupe) (pTHX_ REGEXP * const rx, CLONE_PARAMS *param);
#endif
} regexp_engine;

/*
  These are passed to the numbered capture variable callbacks as the
  paren name. >= 1 is reserved for actual numbered captures, i.e. $1,
  $2 etc.
*/
#define RX_BUFF_IDX_PREMATCH  -2 /* $` / ${^PREMATCH}  */
#define RX_BUFF_IDX_POSTMATCH -1 /* $' / ${^POSTMATCH} */
#define RX_BUFF_IDX_FULLMATCH      0 /* $& / ${^MATCH}     */

/*
  Flags that are passed to the named_buff and named_buff_iter
  callbacks above. Those routines are called from universal.c via the
  Tie::Hash::NamedCapture interface for %+ and %- and the re::
  functions in the same file.
*/

/* The Tie::Hash::NamedCapture operation this is part of, if any */
#define RXapif_FETCH     0x0001
#define RXapif_STORE     0x0002
#define RXapif_DELETE    0x0004
#define RXapif_CLEAR     0x0008
#define RXapif_EXISTS    0x0010
#define RXapif_SCALAR    0x0020
#define RXapif_FIRSTKEY  0x0040
#define RXapif_NEXTKEY   0x0080

/* Whether %+ or %- is being operated on */
#define RXapif_ONE       0x0100 /* %+ */
#define RXapif_ALL       0x0200 /* %- */

/* Whether this is being called from a re:: function */
#define RXapif_REGNAME         0x0400
#define RXapif_REGNAMES        0x0800
#define RXapif_REGNAMES_COUNT  0x1000 

/*
=head1 REGEXP Functions

=for apidoc Am|REGEXP *|SvRX|SV *sv

Convenience macro to get the REGEXP from a SV. This is approximately
equivalent to the following snippet:

    if (SvMAGICAL(sv))
        mg_get(sv);
    if (SvROK(sv) &&
        (tmpsv = (SV*)SvRV(sv)) &&
        SvTYPE(tmpsv) == SVt_PVMG &&
        (tmpmg = mg_find(tmpsv, PERL_MAGIC_qr)))
    {
        return (REGEXP *)tmpmg->mg_obj;
    }

NULL will be returned if a REGEXP* is not found.

=for apidoc Am|bool|SvRXOK|SV* sv

Returns a boolean indicating whether the SV contains qr magic
(PERL_MAGIC_qr).

If you want to do something with the REGEXP* later use SvRX instead
and check for NULL.

=cut
*/

#define SvRX(sv)   (Perl_get_re_arg(aTHX_ sv))
#define SvRXOK(sv) (Perl_get_re_arg(aTHX_ sv) ? TRUE : FALSE)


/* Flags stored in regexp->extflags 
 * These are used by code external to the regexp engine
 *
 * Note that flags starting with RXf_PMf_ have exact equivalents
 * stored in op_pmflags and which are defined in op.h, they are defined
 * numerically here only for clarity.
 *
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

/* Anchor and GPOS related stuff */
#define RXf_ANCH_BOL    	0x00000001
#define RXf_ANCH_MBOL   	0x00000002
#define RXf_ANCH_SBOL   	0x00000004
#define RXf_ANCH_GPOS   	0x00000008
#define RXf_GPOS_SEEN   	0x00000010
#define RXf_GPOS_FLOAT  	0x00000020
/* two bits here */
#define RXf_ANCH        	(RXf_ANCH_BOL|RXf_ANCH_MBOL|RXf_ANCH_GPOS|RXf_ANCH_SBOL)
#define RXf_GPOS_CHECK          (RXf_GPOS_SEEN|RXf_ANCH_GPOS)
#define RXf_ANCH_SINGLE         (RXf_ANCH_SBOL|RXf_ANCH_GPOS)

/* Flags indicating special patterns */
#define RXf_SKIPWHITE		0x00000100 /* Pattern is for a split / / */
#define RXf_START_ONLY		0x00000200 /* Pattern is /^/ */
#define RXf_WHITE		0x00000400 /* Pattern is /\s+/ */
#define RXf_NULL		0x40000000 /* Pattern is // */

/* 0x1F800 of extflags is used by (RXf_)PMf_COMPILETIME */
#define RXf_PMf_LOCALE  	0x00000800 /* use locale */
#define RXf_PMf_MULTILINE	0x00001000 /* /m         */
#define RXf_PMf_SINGLELINE	0x00002000 /* /s         */
#define RXf_PMf_FOLD    	0x00004000 /* /i         */
#define RXf_PMf_EXTENDED	0x00008000 /* /x         */
#define RXf_PMf_KEEPCOPY	0x00010000 /* /p         */
/* these flags are transfered from the PMOP->op_pmflags member during compilation */
#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED)
#define RXf_PMf_COMPILETIME	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_LOCALE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_KEEPCOPY)

#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl)                        \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;   \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;   \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;   \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED;   break

/* chars and strings used as regex pattern modifiers
 * Singlular is a 'c'har, plural is a "string"
 *
 * NOTE, KEEPCOPY was originally 'k', but was changed to 'p' for preserve
 * for compatibility reasons with Regexp::Common which highjacked (?k:...)
 * for its own uses. So 'k' is out as well.
 */
#define EXEC_PAT_MOD         'e'
#define KEEPCOPY_PAT_MOD     'p'
#define ONCE_PAT_MOD         'o'
#define GLOBAL_PAT_MOD       'g'
#define CONTINUE_PAT_MOD     'c'
#define MULTILINE_PAT_MOD    'm'
#define SINGLE_PAT_MOD       's'
#define IGNORE_PAT_MOD       'i'
#define XTENDED_PAT_MOD      'x'

#define ONCE_PAT_MODS        "o"
#define KEEPCOPY_PAT_MODS    "p"
#define EXEC_PAT_MODS        "e"
#define LOOP_PAT_MODS        "gc"

#define STD_PAT_MODS        "msix"

#define INT_PAT_MODS    STD_PAT_MODS    KEEPCOPY_PAT_MODS

#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS
#define M_PAT_MODS      QR_PAT_MODS     LOOP_PAT_MODS
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

/* What we have seen */
#define RXf_LOOKBEHIND_SEEN	0x00020000
#define RXf_EVAL_SEEN   	0x00040000
#define RXf_CANY_SEEN   	0x00080000

/* Special */
#define RXf_NOSCAN      	0x00100000
#define RXf_CHECK_ALL   	0x00200000

/* UTF8 related */
#define RXf_UTF8        	0x00400000
#define RXf_MATCH_UTF8  	0x00800000

/* Intuit related */
#define RXf_USE_INTUIT_NOML	0x01000000
#define RXf_USE_INTUIT_ML	0x02000000
#define RXf_INTUIT_TAIL 	0x04000000

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT           0x08000000

#define RXf_USE_INTUIT		(RXf_USE_INTUIT_NOML|RXf_USE_INTUIT_ML)

/* Copy and tainted info */
#define RXf_COPY_DONE   	0x10000000
#define RXf_TAINTED_SEEN	0x20000000
#define RXf_TAINTED             0x80000000 /* this pattern is tainted */

/*
 * NOTE: if you modify any RXf flags you should run regen.pl or regcomp.pl
 * so that regnodes.h is updated with the changes. 
 *
 */

#define RX_HAS_CUTGROUP(prog) ((prog)->intflags & PREGf_CUTGROUP_SEEN)
#define RX_MATCH_TAINTED(prog)	((prog)->extflags & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) ((prog)->extflags |= RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) ((prog)->extflags &= ~RXf_TAINTED_SEEN)
d97 3
a99 3
#define RX_MATCH_COPIED(prog)		((prog)->extflags & RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	((prog)->extflags |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	((prog)->extflags &= ~RXf_COPY_DONE)
d104 3
a106 24
#endif /* PLUGGABLE_RE_EXTENSION */

/* Stuff that needs to be included in the plugable extension goes below here */

#ifdef PERL_OLD_COPY_ON_WRITE
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (rx->saved_copy) { \
	    SV_CHECK_THINKFIRST_COW_DROP(rx->saved_copy); \
	} \
	if (RX_MATCH_COPIED(rx)) { \
	    Safefree(rx->subbeg); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#else
#define RX_MATCH_COPY_FREE(rx) \
	STMT_START {if (RX_MATCH_COPIED(rx)) { \
	    Safefree(rx->subbeg); \
	    RX_MATCH_COPIED_off(rx); \
	}} STMT_END
#endif

#define RX_MATCH_UTF8(prog)		((prog)->extflags & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		((prog)->extflags |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		((prog)->extflags &= ~RXf_MATCH_UTF8)
d116 1
d119 1
a119 1
#define ReREFCNT_dec(re) CALLREGFREE(re)
d129 1
a129 244
/* an accepting state/position*/
struct _reg_trie_accepted {
    U8   *endpos;
    U16  wordnum;
};
typedef struct _reg_trie_accepted reg_trie_accepted;

/* some basic information about the current match that is created by
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc */

typedef struct {
    regexp *prog;
    char *bol;
    char *till;
    SV *sv;
    char *ganch;
    char *cutpoint;
} regmatch_info;
 

/* structures for holding and saving the state maintained by regmatch() */

#ifndef MAX_RECURSE_EVAL_NOCHANGE_DEPTH
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 1000
#endif

typedef I32 CHECKPOINT;

typedef struct regmatch_state {
    int resume_state;		/* where to jump to on return */
    char *locinput;		/* where to backtrack in string on failure */

    union {

	/* this is a fake union member that matches the first element
	 * of each member that needs to store positive backtrack
	 * information */
	struct {
	    struct regmatch_state *prev_yes_state;
	} yes;

        /* branchlike members */
        /* this is a fake union member that matches the first elements
         * of each member that needs to behave like a branch */
        struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;
	    
        } branchlike;
        	    
	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;
	    
	    regnode *next_branch; /* next branch node */
	} branch;

	struct {
	    /* the first elements must match u.branchlike */
	    struct regmatch_state *prev_yes_state;
	    U32 lastparen;
	    CHECKPOINT cp;

	    reg_trie_accepted *accept_buff; /* accepting states we have seen */
	    U32		accepted; /* how many accepting states we have seen */
	    U16         *jump;  /* positive offsets from me */
	    regnode	*B;	/* node following the trie */
	    regnode	*me;	/* Which node am I - needed for jump tries*/
	} trie;

        /* special types - these members are used to store state for special
           regops like eval, if/then, lookaround and the markpoint state */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_eval;
	    struct regmatch_state *prev_curlyx;
	    regexp	*prev_rex;
	    U32		toggle_reg_flags; /* what bits in PL_reg_flags to
					    flip when transitioning between
					    inner and outer rexen */
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    U32        close_paren; /* which close bracket is our end */
	    regnode	*B;	/* the node following us  */
	} eval;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 wanted;
	    I32 logical;	/* saved copy of 'logical' var */
	    regnode  *me; /* the IFMATCH/SUSPEND/UNLESSM node  */
	} ifmatch; /* and SUSPEND/UNLESSM */
	
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_mark;
	    SV* mark_name;
	    char *mark_loc;
	} mark;
	
	struct {
	    int val;
	} keeper;

        /* quantifiers - these members are used for storing state for
           for the regops used to implement quantifiers */
	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *prev_curlyx; /* previous cur_curlyx */
	    regnode	*A, *B;	/* the nodes corresponding to /A*B/  */
	    CHECKPOINT	cp;	/* remember current savestack index */
	    bool	minmod;
	    int		parenfloor;/* how far back to strip paren data */
	    int		min;	/* the minimal number of A's to match */
	    int		max;	/* the maximal number of A's to match */

	    /* these two are modified by WHILEM */
	    int		count;	/* how many instances of A we've matched */
	    char	*lastloc;/* where previous A matched (0-len detect) */
	} curlyx;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    struct regmatch_state *save_curlyx;
	    CHECKPOINT	cp;	/* remember current savestack indexes */
	    CHECKPOINT	lastcp;
	    char	*save_lastloc;	/* previous curlyx.lastloc */
	    I32		cache_offset;
	    I32		cache_mask;
	} whilem;

	struct {
	    /* this first element must match u.yes */
	    struct regmatch_state *prev_yes_state;
	    I32 c1, c2;		/* case fold search */
	    CHECKPOINT cp;
	    I32 alen;		/* length of first-matched A string */
	    I32 count;
	    bool minmod;
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	    regnode *me;	/* the curlym node */
	} curlym;

	struct {
	    U32 paren;
	    CHECKPOINT cp;
	    I32 c1, c2;		/* case fold search */
	    char *maxpos;	/* highest possible point in string to match */
	    char *oldloc;	/* the previous locinput */
	    int count;
	    int min, max;	/* {m,n} */
	    regnode *A, *B;	/* the nodes corresponding to /A*B/  */
	} curly; /* and CURLYN/PLUS/STAR */

    } u;
} regmatch_state;

/* how many regmatch_state structs to allocate as a single slab.
 * We do it in 4K blocks for efficiency. The "3" is 2 for the next/prev
 * pointers, plus 1 for any mythical malloc overhead. */
 
#define PERL_REGMATCH_SLAB_SLOTS \
    ((4096 - 3 * sizeof (void*)) / sizeof(regmatch_state))

typedef struct regmatch_slab {
    regmatch_state states[PERL_REGMATCH_SLAB_SLOTS];
    struct regmatch_slab *prev, *next;
} regmatch_slab;

#define PL_reg_flags		PL_reg_state.re_state_reg_flags
#define PL_bostr		PL_reg_state.re_state_bostr
#define PL_reginput		PL_reg_state.re_state_reginput
#define PL_regeol		PL_reg_state.re_state_regeol
#define PL_regoffs		PL_reg_state.re_state_regoffs
#define PL_reglastparen		PL_reg_state.re_state_reglastparen
#define PL_reglastcloseparen	PL_reg_state.re_state_reglastcloseparen
#define PL_reg_start_tmp	PL_reg_state.re_state_reg_start_tmp
#define PL_reg_start_tmpl	PL_reg_state.re_state_reg_start_tmpl
#define PL_reg_eval_set		PL_reg_state.re_state_reg_eval_set
#define PL_reg_match_utf8	PL_reg_state.re_state_reg_match_utf8
#define PL_reg_magic		PL_reg_state.re_state_reg_magic
#define PL_reg_oldpos		PL_reg_state.re_state_reg_oldpos
#define PL_reg_oldcurpm		PL_reg_state.re_state_reg_oldcurpm
#define PL_reg_curpm		PL_reg_state.re_state_reg_curpm
#define PL_reg_oldsaved		PL_reg_state.re_state_reg_oldsaved
#define PL_reg_oldsavedlen	PL_reg_state.re_state_reg_oldsavedlen
#define PL_reg_maxiter		PL_reg_state.re_state_reg_maxiter
#define PL_reg_leftiter		PL_reg_state.re_state_reg_leftiter
#define PL_reg_poscache		PL_reg_state.re_state_reg_poscache
#define PL_reg_poscache_size	PL_reg_state.re_state_reg_poscache_size
#define PL_regsize		PL_reg_state.re_state_regsize
#define PL_reg_starttry		PL_reg_state.re_state_reg_starttry
#define PL_nrs			PL_reg_state.re_state_nrs

struct re_save_state {
    U32 re_state_reg_flags;		/* from regexec.c */
    U32 re_state_reg_start_tmpl;	/* from regexec.c */
    I32 re_state_reg_eval_set;		/* from regexec.c */
    bool re_state_reg_match_utf8;	/* from regexec.c */
    char *re_state_bostr;
    char *re_state_reginput;		/* String-input pointer. */
    char *re_state_regeol;		/* End of input, for $ check. */
    regexp_paren_pair *re_state_regoffs;  /* Pointer to start/end pairs */
    U32 *re_state_reglastparen;		/* Similarly for lastparen. */
    U32 *re_state_reglastcloseparen;	/* Similarly for lastcloseparen. */
    char **re_state_reg_start_tmp;	/* from regexec.c */
    MAGIC *re_state_reg_magic;		/* from regexec.c */
    PMOP *re_state_reg_oldcurpm;	/* from regexec.c */
    PMOP *re_state_reg_curpm;		/* from regexec.c */
    char *re_state_reg_oldsaved;	/* old saved substr during match */
    STRLEN re_state_reg_oldsavedlen;	/* old length of saved substr during match */
    STRLEN re_state_reg_poscache_size;	/* size of pos cache of WHILEM */
    I32 re_state_reg_oldpos;		/* from regexec.c */
    I32 re_state_reg_maxiter;		/* max wait until caching pos */
    I32 re_state_reg_leftiter;		/* wait until caching pos */
    U32 re_state_regsize;		/* from regexec.c */
    char *re_state_reg_poscache;	/* cache of pos of WHILEM */
    char *re_state_reg_starttry;	/* from regexec.c */
#ifdef PERL_OLD_COPY_ON_WRITE
    SV *re_state_nrs;			/* was placeholder: unused since 5.8.0 (5.7.2 patch #12027 for bug ID 20010815.012). Used to save rx->saved_copy */
#endif
};

#define SAVESTACK_ALLOC_FOR_RE_SAVE_STATE \
	(1 + ((sizeof(struct re_save_state) - 1) / sizeof(*PL_savestack)))

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2005, 2006, 2007, 2008 by Larry Wall and others
a112 2
#define RXp_PAREN_NAMES(rx)	((rx)->paren_names)

d182 1
a182 1
#define RXapif_REGNAMES_COUNT  0x1000
d219 1
a219 1
/* Flags stored in regexp->extflags
d227 1
a227 1
 * so that regnodes.h is updated with the changes.
d249 1
a249 3
/* 0x1F800 of extflags is used by (RXf_)PMf_COMPILETIME
 * If you change these you need to change the equivalent flags in op.h, and
 * vice versa.  */
a256 1
#define RXf_PMf_STD_PMMOD_SHIFT	12
d299 1
a299 1
 * so that regnodes.h is updated with the changes.
d337 1
a337 1
 * so that regnodes.h is updated with the changes.
d342 3
a344 4
#define RXp_MATCH_TAINTED(prog)	(RXp_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED(prog)	(RX_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_on(prog) (RX_EXTFLAGS(prog) |= RXf_TAINTED_SEEN)
#define RX_MATCH_TAINTED_off(prog) (RX_EXTFLAGS(prog) &= ~RXf_TAINTED_SEEN)
d349 3
a351 6
#define RXp_MATCH_COPIED(prog)		(RXp_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RX_MATCH_COPIED(prog)		(RX_EXTFLAGS(prog) & RXf_COPY_DONE)
#define RXp_MATCH_COPIED_on(prog)	(RXp_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RX_MATCH_COPIED_on(prog)	(RX_EXTFLAGS(prog) |= RXf_COPY_DONE)
#define RXp_MATCH_COPIED_off(prog)	(RXp_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
#define RX_MATCH_COPIED_off(prog)	(RX_EXTFLAGS(prog) &= ~RXf_COPY_DONE)
a355 24
#define RXp_EXTFLAGS(rx)	((rx)->extflags)

#define RX_PRECOMP(prog)	((prog)->precomp)
/* *** 5.10.x-specific definition of RX_PRECOMP_const */
#define RX_PRECOMP_const(prog)	((prog)->precomp)
#define RX_PRELEN(prog)		((prog)->prelen)
#define RX_WRAPPED(prog)	((prog)->wrapped)
#define RX_WRAPLEN(prog)	((prog)->wraplen)
#define RX_CHECK_SUBSTR(prog)	((prog)->check_substr)
#define RX_EXTFLAGS(prog)	((prog)->extflags)
#define RX_REFCNT(prog)		((prog)->refcnt)
#define RX_ENGINE(prog)		((prog)->engine)
#define RX_SUBBEG(prog)		((prog)->subbeg)
#define RX_OFFS(prog)		((prog)->offs)
#define RX_NPARENS(prog)	((prog)->nparens)
#define RX_SUBLEN(prog)		((prog)->sublen)
#define RX_SUBBEG(prog)		((prog)->subbeg)
#define RX_MINLEN(prog)		((prog)->minlen)
#define RX_MINLENRET(prog)	((prog)->minlenret)
#define RX_GOFS(prog)		((prog)->gofs)
#define RX_LASTPAREN(prog)	((prog)->lastparen)
#define RX_LASTCLOSEPAREN(prog)	((prog)->lastcloseparen)
#define RX_SEEN_EVALS(prog)	((prog)->seen_evals)

d366 1
a366 1
	    Safefree(RX_SUBBEG(rx)); \
d372 1
a372 1
	    Safefree(RX_SUBBEG(rx)); \
d377 3
a379 4
#define RXp_MATCH_UTF8(prog)		(RXp_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8(prog)		(RX_EXTFLAGS(prog) & RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_on(prog)		(RX_EXTFLAGS(prog) |= RXf_MATCH_UTF8)
#define RX_MATCH_UTF8_off(prog)		(RX_EXTFLAGS(prog) &= ~RXf_MATCH_UTF8)
d383 1
a383 4

/* Whether the pattern stored at RX_WRAPPED is in UTF-8  */
#define RX_UTF8(prog)			(RX_EXTFLAGS(prog) & RXf_UTF8)

@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@a68 35
#define _REGEXP_COMMON							\
        /* what engine created this regexp? */				\
	const struct regexp_engine* engine; 				\
	REGEXP *mother_re; /* what re is this a lightweight copy of? */	\
	/* Information about the match that the perl core uses to */	\
	/* manage things */						\
	U32 extflags;	/* Flags used both externally and internally */	\
	I32 minlen;	/* mininum possible length of string to match */\
	I32 minlenret;	/* mininum possible length of $& */		\
	U32 gofs;	/* chars left of pos that we search from */	\
	/* substring data about strings that must appear in the */	\
	/* final match, used for optimisations */			\
	struct reg_substr_data *substrs;				\
	U32 nparens;	/* number of capture buffers */			\
	/* private engine specific data */				\
	U32 intflags;	/* Engine Specific Internal flags */		\
	void *pprivate;	/* Data private to the regex engine which */	\
			/* created this object. */			\
	/* Data about the last/current match. These are modified */	\
	/* during matching */						\
	U32 lastparen;			/* last open paren matched */	\
	U32 lastcloseparen;		/* last close paren matched */	\
	regexp_paren_pair *swap;	/* Unused: 5.10.1 and later */	\
	/* Array of offsets for (@@-) and (@@+) */			\
	regexp_paren_pair *offs;					\
	/* saved or original string so \digit works forever. */		\
	char *subbeg;							\
	SV_SAVED_COPY	/* If non-NULL, SV which is COW from original */\
	I32 sublen;	/* Length of string pointed by subbeg */	\
	/* Information about the match that isn't often used */		\
	/* offset from wrapped to the start of precomp */		\
	PERL_BITFIELD32 pre_prefix:4;					\
	/* number of eval groups in the pattern - for security checks */\
	PERL_BITFIELD32 seen_evals:28

d70 41
a110 3
	_XPV_HEAD;
	_XPVMG_HEAD;
	_REGEXP_COMMON;
d113 1
a113 4
/*        HV *paren_names;	 Optional hash of paren names
	  now stored in the IV union */

#define RXp_PAREN_NAMES(rx)	((rx)->xiv_u.xivu_hv)
d126 1
a126 1
    REGEXP* (*comp) (pTHX_ SV * const pattern, U32 flags);
d233 19
a251 1
/* 0x3F of extflags is used by (RXf_)PMf_COMPILETIME
d254 6
a259 6
#define RXf_PMf_MULTILINE	0x00000001 /* /m         */
#define RXf_PMf_SINGLELINE	0x00000002 /* /s         */
#define RXf_PMf_FOLD    	0x00000004 /* /i         */
#define RXf_PMf_EXTENDED	0x00000008 /* /x         */
#define RXf_PMf_KEEPCOPY	0x00000010 /* /p         */
#define RXf_PMf_LOCALE  	0x00000020 /* use locale */
d261 1
a261 1
#define RXf_PMf_STD_PMMOD_SHIFT	0
a307 12
/* Anchor and GPOS related stuff */
#define RXf_ANCH_BOL    	0x00000100
#define RXf_ANCH_MBOL   	0x00000200
#define RXf_ANCH_SBOL   	0x00000400
#define RXf_ANCH_GPOS   	0x00000800
#define RXf_GPOS_SEEN   	0x00001000
#define RXf_GPOS_FLOAT  	0x00002000
/* two bits here */
#define RXf_ANCH        	(RXf_ANCH_BOL|RXf_ANCH_MBOL|RXf_ANCH_GPOS|RXf_ANCH_SBOL)
#define RXf_GPOS_CHECK          (RXf_GPOS_SEEN|RXf_ANCH_GPOS)
#define RXf_ANCH_SINGLE         (RXf_ANCH_SBOL|RXf_ANCH_GPOS)

d309 3
a311 3
#define RXf_LOOKBEHIND_SEEN	0x00004000
#define RXf_EVAL_SEEN   	0x00008000
#define RXf_CANY_SEEN   	0x00010000
d314 2
a315 2
#define RXf_NOSCAN      	0x00020000
#define RXf_CHECK_ALL   	0x00040000
d318 2
a319 1
#define RXf_MATCH_UTF8  	0x00100000
d322 3
a324 3
#define RXf_USE_INTUIT_NOML	0x00200000
#define RXf_USE_INTUIT_ML	0x00400000
#define RXf_INTUIT_TAIL 	0x00800000
d331 1
a331 1
#define RXf_SPLIT		0x01000000
d336 3
a338 9
#define RXf_COPY_DONE   	0x02000000
#define RXf_TAINTED_SEEN	0x04000000
#define RXf_TAINTED		0x08000000 /* this pattern is tainted */

/* Flags indicating special patterns */
#define RXf_START_ONLY		0x10000000 /* Pattern is /^/ */
#define RXf_SKIPWHITE		0x20000000 /* Pattern is for a split / / */
#define RXf_WHITE		0x40000000 /* Pattern is /\s+/ */
#define RXf_NULL		0x80000000 /* Pattern is // */
d367 21
a387 58
/* For source compatibility. We used to store these explicitly.  */
#define RX_PRECOMP(prog)	(RX_WRAPPED(prog) + ((struct regexp *)SvANY(prog))->pre_prefix)
#define RX_PRECOMP_const(prog)	(RX_WRAPPED_const(prog) + ((struct regexp *)SvANY(prog))->pre_prefix)
/* FIXME? Are we hardcoding too much here and constraining plugin extension
   writers? Specifically, the value 1 assumes that the wrapped version always
   has exactly one character at the end, a ')'. Will that always be true?  */
#define RX_PRELEN(prog)		(RX_WRAPLEN(prog) - ((struct regexp *)SvANY(prog))->pre_prefix - 1)
#define RX_WRAPPED(prog)	SvPVX(prog)
#define RX_WRAPPED_const(prog)	SvPVX_const(prog)
#define RX_WRAPLEN(prog)	SvCUR(prog)
#define RX_CHECK_SUBSTR(prog)	(((struct regexp *)SvANY(prog))->check_substr)
#define RX_REFCNT(prog)		SvREFCNT(prog)
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define RX_EXTFLAGS(prog)						\
    (*({								\
	const REGEXP *const _rx_extflags = (prog);			\
	assert(SvTYPE(_rx_extflags) == SVt_REGEXP);			\
	&RXp_EXTFLAGS(SvANY(_rx_extflags));				\
    }))
#  define RX_ENGINE(prog)						\
    (*({								\
	const REGEXP *const _rx_engine = (prog);			\
	assert(SvTYPE(_rx_engine) == SVt_REGEXP);			\
	&SvANY(_rx_engine)->engine;					\
    }))
#  define RX_SUBBEG(prog)						\
    (*({								\
	const REGEXP *const _rx_subbeg = (prog);			\
	assert(SvTYPE(_rx_subbeg) == SVt_REGEXP);			\
	&SvANY(_rx_subbeg)->subbeg;					\
    }))
#  define RX_OFFS(prog)							\
    (*({								\
	const REGEXP *const _rx_offs = (prog);				\
	assert(SvTYPE(_rx_offs) == SVt_REGEXP);				\
	&SvANY(_rx_offs)->offs;						\
    }))
#  define RX_NPARENS(prog)						\
    (*({								\
	const REGEXP *const _rx_nparens = (prog);			\
	assert(SvTYPE(_rx_nparens) == SVt_REGEXP);			\
	&SvANY(_rx_nparens)->nparens;					\
    }))
#else
#  define RX_EXTFLAGS(prog)	RXp_EXTFLAGS((struct regexp *)SvANY(prog))
#  define RX_ENGINE(prog)	(((struct regexp *)SvANY(prog))->engine)
#  define RX_SUBBEG(prog)	(((struct regexp *)SvANY(prog))->subbeg)
#  define RX_OFFS(prog)		(((struct regexp *)SvANY(prog))->offs)
#  define RX_NPARENS(prog)	(((struct regexp *)SvANY(prog))->nparens)
#endif
#define RX_SUBLEN(prog)		(((struct regexp *)SvANY(prog))->sublen)
#define RX_MINLEN(prog)		(((struct regexp *)SvANY(prog))->minlen)
#define RX_MINLENRET(prog)	(((struct regexp *)SvANY(prog))->minlenret)
#define RX_GOFS(prog)		(((struct regexp *)SvANY(prog))->gofs)
#define RX_LASTPAREN(prog)	(((struct regexp *)SvANY(prog))->lastparen)
#define RX_LASTCLOSEPAREN(prog)	(((struct regexp *)SvANY(prog))->lastcloseparen)
#define RX_SEEN_EVALS(prog)	(((struct regexp *)SvANY(prog))->seen_evals)
#define RX_SAVED_COPY(prog)	(((struct regexp *)SvANY(prog))->saved_copy)
d395 2
a396 2
	STMT_START {if (RX_SAVED_COPY(rx)) { \
	    SV_CHECK_THINKFIRST_COW_DROP(RX_SAVED_COPY(rx)); \
d419 1
a419 1
#define RX_UTF8(prog)			SvUTF8(prog)
d427 2
a428 21
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define ReREFCNT_inc(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_inc = (re);				\
	assert(SvTYPE(_rerefcnt_inc) == SVt_REGEXP);			\
	SvREFCNT_inc(_rerefcnt_inc);					\
	_rerefcnt_inc;							\
    })
#  define ReREFCNT_dec(re)						\
    ({									\
	/* This is here to generate a casting warning if incorrect.  */	\
	REGEXP *const _rerefcnt_dec = (re);				\
	SvREFCNT_dec(_rerefcnt_dec);					\
    })
#else
#  define ReREFCNT_dec(re)	SvREFCNT_dec(re)
#  define ReREFCNT_inc(re)	((REGEXP *) SvREFCNT_inc(re))
#endif

/* FIXME for plugins. */
d449 1
a449 1
    REGEXP *prog;
d519 1
a519 1
	    REGEXP	*prev_rex;
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a57 9
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_IN_UTF8_C)
#define _invlist_union(a, b, output) _invlist_union_maybe_complement_2nd(a, b, FALSE, output)
#define _invlist_intersection(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, FALSE, output)

/* Subtracting b from a leaves in a everything that was there that isn't in b,
 * that is the intersection of a with b's complement */
#define _invlist_subtract(a, b, output) _invlist_intersection_maybe_complement_2nd(a, b, TRUE, output)
#endif

a72 1
	HV *paren_names;   /* Optional hash of paren names */		\
d106 1
d110 4
a113 1
#define RXp_PAREN_NAMES(rx)	((rx)->paren_names)
d196 7
a202 4
    if (SvROK(sv))
        sv = MUTABLE_SV(SvRV(sv));
    if (SvTYPE(sv) == SVt_REGEXP)
        return (REGEXP*) sv;
d208 2
a209 2
Returns a boolean indicating whether the SV (or the one it references)
is a REGEXP.
d224 3
a226 2
 * Note that the flags whose names start with RXf_PMf_ are defined in
 * op_reg_common.h, being copied from the parallel flags of op_pmflags
d228 2
a229 2
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
d233 11
a243 2
#include "op_reg_common.h"

d245 1
a252 4
/* Note, includes charset ones, assumes 0 is the default for them */
#define STD_PMMOD_FLAGS_CLEAR(pmfl)                        \
    *(pmfl) &= ~(RXf_PMf_FOLD|RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_EXTENDED|RXf_PMf_CHARSET)

d254 1
a254 1
 * Singular is a 'c'har, plural is a "string"
a259 1
#define DEFAULT_PAT_MOD      '^'    /* Short for all the default modifiers */
a268 5
#define NONDESTRUCT_PAT_MOD  'r'
#define LOCALE_PAT_MOD       'l'
#define UNICODE_PAT_MOD      'u'
#define DEPENDS_PAT_MOD      'd'
#define ASCII_RESTRICT_PAT_MOD 'a'
d274 1
a274 10
#define NONDESTRUCT_PAT_MODS "r"
#define LOCALE_PAT_MODS      "l"
#define UNICODE_PAT_MODS     "u"
#define DEPENDS_PAT_MODS     "d"
#define ASCII_RESTRICT_PAT_MODS "a"
#define ASCII_MORE_RESTRICT_PAT_MODS "aa"

/* This string is expected by regcomp.c to be ordered so that the first
 * character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of extflags; the next
 * character is bit +1, etc. */
a276 5
#define CHARSET_PAT_MODS    ASCII_RESTRICT_PAT_MODS DEPENDS_PAT_MODS LOCALE_PAT_MODS UNICODE_PAT_MODS

/* This string is expected by XS_re_regexp_pattern() in universal.c to be ordered
 * so that the first character is the flag in bit RXf_PMf_STD_PMMOD_SHIFT of
 * extflags; the next character is in bit +1, etc. */
d280 1
a280 1
#define QR_PAT_MODS     STD_PAT_MODS    EXT_PAT_MODS	   CHARSET_PAT_MODS
d282 1
a282 1
#define S_PAT_MODS      M_PAT_MODS      EXEC_PAT_MODS      NONDESTRUCT_PAT_MODS
d285 2
a286 2
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
a289 35
/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+1)

/* Manually decorate this function with gcc-style attributes just to
 * avoid having to restructure the header files and their called order,
 * as proto.h would have to be included before this file, and isn't */

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
    __attribute__warn_unused_result__;

#define MAX_CHARSET_NAME_LENGTH 2

PERL_STATIC_INLINE const char *
get_regex_charset_name(const U32 flags, STRLEN* const lenp)
{
    /* Returns a string that corresponds to the name of the regex character set
     * given by 'flags', and *lenp is set the length of that string, which
     * cannot exceed MAX_CHARSET_NAME_LENGTH characters */

    *lenp = 1;
    switch (get_regex_charset(flags)) {
        case REGEX_DEPENDS_CHARSET: return DEPENDS_PAT_MODS;
        case REGEX_LOCALE_CHARSET:  return LOCALE_PAT_MODS;
        case REGEX_UNICODE_CHARSET: return UNICODE_PAT_MODS;
	case REGEX_ASCII_RESTRICTED_CHARSET: return ASCII_RESTRICT_PAT_MODS;
	case REGEX_ASCII_MORE_RESTRICTED_CHARSET:
	    *lenp = 2;
	    return ASCII_MORE_RESTRICT_PAT_MODS;
        default:
	    return "?";	    /* Unknown */
    }
}

d291 6
a296 6
#define RXf_ANCH_BOL    	(1<<(RXf_BASE_SHIFT+0))
#define RXf_ANCH_MBOL   	(1<<(RXf_BASE_SHIFT+1))
#define RXf_ANCH_SBOL   	(1<<(RXf_BASE_SHIFT+2))
#define RXf_ANCH_GPOS   	(1<<(RXf_BASE_SHIFT+3))
#define RXf_GPOS_SEEN   	(1<<(RXf_BASE_SHIFT+4))
#define RXf_GPOS_FLOAT  	(1<<(RXf_BASE_SHIFT+5))
d303 3
a305 3
#define RXf_LOOKBEHIND_SEEN	(1<<(RXf_BASE_SHIFT+6))
#define RXf_EVAL_SEEN   	(1<<(RXf_BASE_SHIFT+7))
#define RXf_CANY_SEEN   	(1<<(RXf_BASE_SHIFT+8))
d308 2
a309 2
#define RXf_NOSCAN      	(1<<(RXf_BASE_SHIFT+9))
#define RXf_CHECK_ALL   	(1<<(RXf_BASE_SHIFT+10))
d312 1
a312 1
#define RXf_MATCH_UTF8  	(1<<(RXf_BASE_SHIFT+11))
d315 3
a317 3
#define RXf_USE_INTUIT_NOML	(1<<(RXf_BASE_SHIFT+12))
#define RXf_USE_INTUIT_ML	(1<<(RXf_BASE_SHIFT+13))
#define RXf_INTUIT_TAIL 	(1<<(RXf_BASE_SHIFT+14))
d324 1
a324 1
#define RXf_SPLIT		(1<<(RXf_BASE_SHIFT+15))
d329 3
a331 7
#define RXf_COPY_DONE   	(1<<(RXf_BASE_SHIFT+16))

/* during execution: pattern temporarily tainted by executing locale ops;
 * post-execution: $1 et al are tainted */
#define RXf_TAINTED_SEEN	(1<<(RXf_BASE_SHIFT+17))
/* this pattern was tainted during compilation */
#define RXf_TAINTED		(1<<(RXf_BASE_SHIFT+18))
d334 4
a337 7
#define RXf_START_ONLY		(1<<(RXf_BASE_SHIFT+19)) /* Pattern is /^/ */
#define RXf_SKIPWHITE		(1<<(RXf_BASE_SHIFT+20)) /* Pattern is for a split / / */
#define RXf_WHITE		(1<<(RXf_BASE_SHIFT+21)) /* Pattern is /\s+/ */
#define RXf_NULL		(1U<<(RXf_BASE_SHIFT+22)) /* Pattern is // */
#if RXf_BASE_SHIFT+22 > 31
#   error Too many RXf_PMf bits used.  See regnodes.h for any spare in middle
#endif
d340 2
a341 2
 * NOTE: if you modify any RXf flags you should run regen.pl or
 * regen/regcomp.pl so that regnodes.h is updated with the changes.
d427 1
a427 1
/* Stuff that needs to be included in the pluggable extension goes below here */
d493 7
d560 2
a561 1
	    U32		accepted; /* how many accepting states left */
a564 5
	    U8		*firstpos;/* pos in string of first trie match */
	    U32		firstchars;/* len in chars of firstpos from start */
	    U16		nextword;/* next word to try */
	    U16		topword; /* longest accepted word */
	    bool	longfold;/* saw a fold with a 1->n char mapping */
d610 1
a610 2
	    regnode	*me;	/* the CURLYX node  */
	    regnode	*B;	/* the B node in /A*B/  */
d614 2
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a20 2
#include "utf8.h"

d47 1
a47 1
#ifdef PERL_ANY_COW
a52 2
/* offsets within a string of a particular /(.)/ capture */

a55 7
    /* 'start_tmp' records a new opening position before the matching end
     * has been found, so that the old start and end values are still
     * valid, e.g.
     *	  "abc" =~ /(.(?{print "[$1]"}))+/
     *outputs [][a][b]
     * This field is not part of the API.  */
    I32 start_tmp;
a66 10
/* record the position of a (?{...}) within a pattern */

struct reg_code_block {
    STRLEN start;
    STRLEN end;
    OP     *block;
    REGEXP *src_regex;
};


d86 2
a87 2
	I32 minlen;	/* mininum possible number of chars in string to match */\
	I32 minlenret;	/* mininum possible number of chars in $& */		\
d101 1
a107 2
	I32 suboffset;	/* byte offset of subbeg from logical start of str */ \
	I32 subcoffset;	/* suboffset equiv, but in chars (for @@-/@@+) */ \
d111 2
a112 4
        /* original flags used to compile the pattern, may differ */    \
        /* from extflags in various ways */                             \
        PERL_BITFIELD32 compflags:9;                                    \
	CV *qr_anoncv	/* the anon sub wrapped round qr/(?{..})/ */
a154 4
    REGEXP* (*op_comp) (pTHX_ SV ** const patternp, int pat_count,
		    OP *expr, const struct regexp_engine* eng,
		    REGEXP *VOL old_re,
		    bool *is_bare_re, U32 orig_rx_flags, U32 pm_flags);
d162 3
a164 6
#define RX_BUFF_IDX_CARET_PREMATCH  -5 /* ${^PREMATCH}  */
#define RX_BUFF_IDX_CARET_POSTMATCH -4 /* ${^POSTMATCH} */
#define RX_BUFF_IDX_CARET_FULLMATCH -3 /* ${^MATCH}     */
#define RX_BUFF_IDX_PREMATCH        -2 /* $` */
#define RX_BUFF_IDX_POSTMATCH       -1 /* $' */
#define RX_BUFF_IDX_FULLMATCH        0 /* $& */
d308 1
a308 11
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT)

/*
  Set in Perl_pmruntime if op_flags & OPf_SPECIAL, i.e. split. Will
  be used by regex engines to check whether they should set
  RXf_SKIPWHITE
*/
#define RXf_SPLIT                (1<<(RXf_BASE_SHIFT-1))
#if RXf_SPLIT != RXf_PMf_SPLIT
#   error "RXf_SPLIT does not match RXf_PMf_SPLIT"
#endif
d354 1
a354 1
#define RXf_NO_INPLACE_SUBST    (1<<(RXf_BASE_SHIFT+6))
d369 8
d390 1
a390 1
#define RXf_SKIPWHITE                (1<<(RXf_BASE_SHIFT+20)) /* Pattern is for a split " " */
a402 18
#if NO_TAINT_SUPPORT
#   define RX_ISTAINTED(prog)    0
#   define RX_TAINT_on(prog)     NOOP
#   define RXp_MATCH_TAINTED(prog) 0
#   define RX_MATCH_TAINTED(prog)  0
#   define RXp_MATCH_TAINTED_on(prog) NOOP
#   define RX_MATCH_TAINTED_on(prog)  NOOP
#   define RX_MATCH_TAINTED_off(prog) NOOP
#else
#   define RX_ISTAINTED(prog)    (RX_EXTFLAGS(prog) & RXf_TAINTED)
#   define RX_TAINT_on(prog)     (RX_EXTFLAGS(prog) |= RXf_TAINTED)
#   define RXp_MATCH_TAINTED(prog)    (RXp_EXTFLAGS(prog) & RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED(prog)     (RX_EXTFLAGS(prog)  & RXf_TAINTED_SEEN)
#   define RXp_MATCH_TAINTED_on(prog) (RXp_EXTFLAGS(prog) |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_on(prog)  (RX_EXTFLAGS(prog)  |= RXf_TAINTED_SEEN)
#   define RX_MATCH_TAINTED_off(prog) (RX_EXTFLAGS(prog)  &= ~RXf_TAINTED_SEEN)
#endif

d404 4
a422 1
#define RXp_COMPFLAGS(rx)        ((rx)->compflags)
d425 2
a426 2
#define RX_PRECOMP(prog)	(RX_WRAPPED(prog) + ReANY(prog)->pre_prefix)
#define RX_PRECOMP_const(prog)	(RX_WRAPPED_const(prog) + ReANY(prog)->pre_prefix)
d430 3
a432 3
#define RX_PRELEN(prog)		(RX_WRAPLEN(prog) - ReANY(prog)->pre_prefix - 1)
#define RX_WRAPPED(prog)	ReANY(prog)->xpv_len_u.xpvlenu_pv
#define RX_WRAPPED_const(prog)	((const char *)RX_WRAPPED(prog))
d434 1
a434 1
#define RX_CHECK_SUBSTR(prog)	(ReANY(prog)->check_substr)
d436 46
a481 15
#define RX_EXTFLAGS(prog)	RXp_EXTFLAGS(ReANY(prog))
#define RX_COMPFLAGS(prog)        RXp_COMPFLAGS(ReANY(prog))
#define RX_ENGINE(prog)		(ReANY(prog)->engine)
#define RX_SUBBEG(prog)		(ReANY(prog)->subbeg)
#define RX_SUBOFFSET(prog)	(ReANY(prog)->suboffset)
#define RX_SUBCOFFSET(prog)	(ReANY(prog)->subcoffset)
#define RX_OFFS(prog)		(ReANY(prog)->offs)
#define RX_NPARENS(prog)	(ReANY(prog)->nparens)
#define RX_SUBLEN(prog)		(ReANY(prog)->sublen)
#define RX_MINLEN(prog)		(ReANY(prog)->minlen)
#define RX_MINLENRET(prog)	(ReANY(prog)->minlenret)
#define RX_GOFS(prog)		(ReANY(prog)->gofs)
#define RX_LASTPAREN(prog)	(ReANY(prog)->lastparen)
#define RX_LASTCLOSEPAREN(prog)	(ReANY(prog)->lastcloseparen)
#define RX_SAVED_COPY(prog)	(ReANY(prog)->saved_copy)
d487 1
a487 1
#ifdef PERL_ANY_COW
a519 5
                                    /* under REXEC_COPY_STR, it's ok for the
                                     * engine (modulo PL_sawamperand etc)
                                     * to skip copying ... */
#define REXEC_COPY_SKIP_PRE  0x20   /* ...the $` part of the string, or */
#define REXEC_COPY_SKIP_POST 0x40   /* ...the $' part of the string */
a539 1
#define ReANY(re)		S_ReANY((const REGEXP *)(re))
a560 2
    bool is_utf8_pat;
    bool warned; /* we have issued a recursion warning; no need for more */
a591 1
	    U32 lastcloseparen;
a599 1
	    U32 lastcloseparen;
a608 1
	    U32 lastcloseparen;
a611 1
	    bool	longfold;/* saw a fold with a 1->n char mapping */
d613 1
d619 1
d630 3
a632 1
	    bool	saved_utf8_pat; /* saved copy of is_utf8_pat */
d690 1
a690 1
	    int c1, c2;		/* case fold search */
a691 2
	    U32 lastparen;
	    U32 lastcloseparen;
a696 2
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
d702 1
a702 3
	    U32 lastparen;
	    U32 lastcloseparen;
	    int c1, c2;		/* case fold search */
a707 2
            U8 c1_utf8[UTF8_MAXBYTES+1];  /* */
            U8 c2_utf8[UTF8_MAXBYTES+1];
d725 1
d727 1
d729 6
a741 2
#define PL_reg_oldsavedoffset	PL_reg_state.re_state_reg_oldsavedoffset
#define PL_reg_oldsavedcoffset	PL_reg_state.re_state_reg_oldsavedcoffset
d746 1
d751 3
a753 1
    bool re_state_eval_setup_done;	/* from regexec.c */
a754 4
    /* Space for U8 */
    I32 re_state_reg_oldpos;		/* from regexec.c */
    I32 re_state_reg_maxiter;		/* max wait until caching pos */
    I32 re_state_reg_leftiter;		/* wait until caching pos */
d756 1
d758 4
a766 2
    STRLEN re_state_reg_oldsavedoffset;	/* old offset of saved substr during match */
    STRLEN re_state_reg_oldsavedcoffset;/* old coffset of saved substr during match */
d768 4
d774 1
a774 1
#ifdef PERL_ANY_COW
d786 1
a786 1
 * indent-tabs-mode: nil
d789 1
a789 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d39 2
a40 2
    SSize_t min_offset; /* min pos (in chars) that substr must appear */
    SSize_t max_offset  /* max pos (in chars) that substr must appear */;
d43 1
a43 1
    SSize_t end_shift;  /* how many fixed chars must end the string */
a45 1
    U8      check_ix;   /* index into data[] of check substr */
d58 2
a59 2
    SSize_t start;
    SSize_t end;
d66 1
a66 1
    SSize_t start_tmp;
d107 3
a109 3
	SSize_t minlen;	/* mininum possible number of chars in string to match */\
	SSize_t minlenret; /* mininum possible number of chars in $& */		\
	STRLEN gofs;	/* chars left of pos that we search from */	\
d127 3
a129 3
	SSize_t sublen;	/* Length of string pointed by subbeg */	\
	SSize_t suboffset; /* byte offset of subbeg from logical start of str */ \
	SSize_t subcoffset; /* suboffset equiv, but in chars (for @@-/@@+) */ \
a130 1
        SSize_t maxlen;        /* mininum possible number of chars in string to match */\
d149 1
a149 1
    SSize_t *scream_pos;	/* Internal iterator of scream. */
d158 1
a158 1
                     char* strbeg, SSize_t minend, SV* sv,
d160 2
a161 7
    char*   (*intuit) (pTHX_
                        REGEXP * const rx,
                        SV *sv,
                        const char * const strbeg,
                        char *strpos,
                        char *strend,
                        const U32 flags,
d228 1
a228 1
Convenience macro to get the REGEXP from a SV.  This is approximately
d382 11
a392 7
/* Do we have some sort of anchor? */
#define RXf_IS_ANCHORED         (1<<(RXf_BASE_SHIFT+0))
#define RXf_UNUSED1             (1<<(RXf_BASE_SHIFT+1))
#define RXf_UNUSED2             (1<<(RXf_BASE_SHIFT+2))
#define RXf_UNUSED3             (1<<(RXf_BASE_SHIFT+3))
#define RXf_UNUSED4             (1<<(RXf_BASE_SHIFT+4))
#define RXf_UNUSED5             (1<<(RXf_BASE_SHIFT+5))
d397 1
a397 1
#define RXf_UNUSED8             (1<<(RXf_BASE_SHIFT+8))
d400 1
a400 1
#define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1<<(RXf_BASE_SHIFT+9))
d404 1
a404 1
#define RXf_MATCH_UTF8  	(1<<(RXf_BASE_SHIFT+11)) /* $1 etc are utf8 */
d415 2
a416 1
/* post-execution: $1 et al are tainted */
d436 1
a436 1
#ifdef NO_TAINT_SUPPORT
a498 4
/* last match was zero-length */
#define RX_ZERO_LEN(prog) \
        (RX_OFFS(prog)[0].start + (SSize_t)RX_GOFS(prog) \
          == RX_OFFS(prog)[0].end)
d526 2
a527 2
			? RX_MATCH_UTF8_on(prog) \
			: RX_MATCH_UTF8_off(prog))
d532 10
a541 18

/* bits in flags arg of Perl_regexec_flags() */

#define REXEC_COPY_STR  0x01    /* Need to copy the string for captures. */
#define REXEC_CHECKED   0x02    /* re_intuit_start() already called. */
#define REXEC_SCREAM    0x04    /* currently unused. */
#define REXEC_IGNOREPOS 0x08    /* use stringarg, not pos(), for \G match */
#define REXEC_NOT_FIRST 0x10    /* This is another iteration of //g:
                                   no need to copy string again */

                                     /* under REXEC_COPY_STR, it's ok for the
                                        engine (modulo PL_sawamperand etc)
                                        to skip copying: ... */
#define REXEC_COPY_SKIP_PRE  0x20    /* ...the $` part of the string, or */
#define REXEC_COPY_SKIP_POST 0x40    /* ...the $' part of the string */
#define REXEC_FAIL_ON_UNDERFLOW 0x80 /* fail the match if $& would start before
                                        the start pos (so s/.\G// would fail
                                        on second iteration */
a573 35
struct regmatch_state;
struct regmatch_slab;

/* like regmatch_info_aux, but contains extra fields only needed if the
 * pattern contains (?{}). If used, is snuck into the second slot in the
 * regmatch_state stack at the start of execution */

typedef struct {
    regexp *rex;
    PMOP    *curpm;     /* saved PL_curpm */
#ifdef PERL_ANY_COW
    SV      *saved_copy; /* saved saved_copy field from rex */
#endif
    char    *subbeg;    /* saved subbeg     field from rex */
    STRLEN  sublen;     /* saved sublen     field from rex */
    STRLEN  suboffset;  /* saved suboffset  field from rex */
    STRLEN  subcoffset; /* saved subcoffset field from rex */
    MAGIC   *pos_magic; /* pos() magic attached to $_ */
    SSize_t pos;        /* the original value of pos() in pos_magic */
    U8      pos_flags;  /* flags to be restored; currently only MGf_BYTES*/
} regmatch_info_aux_eval;


/* fields that logically  live in regmatch_info, but which need cleaning
 * up on croak(), and so are instead are snuck into the first slot in
 * the regmatch_state stack at the start of execution */

typedef struct {
    regmatch_info_aux_eval *info_aux_eval;
    struct regmatch_state *old_regmatch_state; /* saved PL_regmatch_state */
    struct regmatch_slab  *old_regmatch_slab;  /* saved PL_regmatch_slab */
    char *poscache;	/* S-L cache of fail positions of WHILEMs */
} regmatch_info_aux;


d575 1
a575 5
 * Perl_regexec_flags and then passed to regtry(), regmatch() etc.
 * It is allocated as a local var on the stack, so nothing should be
 * stored in it that needs preserving or clearing up on croak().
 * For that, see the aux_info and aux_info_eval members of the
 * regmatch_state union. */
d578 7
a584 15
    REGEXP *prog;        /* the regex being executed */
    const char * strbeg; /* real start of string */
    char *strend;        /* one byte beyond last char of match string */
    char *till;          /* matches shorter than this fail (see minlen arg) */
    SV *sv;              /* the SV string currently being matched */
    char *ganch;         /* position of \G anchor */
    char *cutpoint;      /* (*COMMIT) position (if any) */
    regmatch_info_aux      *info_aux; /* extra fields that need cleanup */
    regmatch_info_aux_eval *info_aux_eval; /* extra saved state for (?{}) */
    I32  poscache_maxiter; /* how many whilems todo before S-L cache kicks in */
    I32  poscache_iter;    /* current countdown from _maxiter to zero */
    STRLEN poscache_size;  /* size of regmatch_info_aux.poscache */
    bool intuit;    /* re_intuit_start() is the top-level caller */
    bool is_utf8_pat;    /* regex is utf8 */
    bool is_utf8_target; /* string being matched is utf8 */
a602 23
        /* the 'info_aux' and 'info_aux_eval' union members are cuckoos in
         * the nest. They aren't saved backtrack state; rather they
         * represent one or two extra chunks of data that need allocating
         * at the start of a match. These fields would logically live in
         * the regmatch_info struct, except that is allocated on the
         * C stack, and these fields are all things that require cleanup
         * after a croak(), when the stack is lost.
         * As a convenience, we just use the first 1 or 2 regmatch_state
         * slots to store this info, as we will be allocating a slab of
         * these anyway. Otherwise we'd have to malloc and then free them,
         * or allocate them on the save stack (where they will get
         * realloced if the save stack grows).
         * info_aux contains the extra fields that are always needed;
         * info_aux_eval contains extra fields that only needed if
         * the pattern contains code blocks
         * We split them into two separate structs to avoid increasing
         * the size of the union.
         */

        regmatch_info_aux info_aux;

        regmatch_info_aux_eval info_aux_eval;

d657 1
d758 41
d800 2
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@a104 1
        /*--------------------------------------------------------*/    \
a118 1
        /*--------------------------------------------------------*/    \
a124 2
        char **recurse_locinput; /* used to detect infinite recursion, XXX: move to internal */ \
        /*--------------------------------------------------------*/    \
a132 1
        /*--------------------------------------------------------*/    \
a137 1
        /*--------------------------------------------------------*/    \
d171 1
a171 1
    void    (*rxfree) (pTHX_ REGEXP * const rx);
d188 1
a188 1
		    REGEXP *old_re,
d245 1
a245 1
C<NULL> will be returned if a REGEXP* is not found.
d275 1
a275 1
#define RXf_PMf_STD_PMMOD	(RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_FOLD|RXf_PMf_EXTENDED|RXf_PMf_NOCAPTURE)
d277 5
a281 13
#define CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl, x_count)                       \
    case IGNORE_PAT_MOD:    *(pmfl) |= RXf_PMf_FOLD;       break;           \
    case MULTILINE_PAT_MOD: *(pmfl) |= RXf_PMf_MULTILINE;  break;           \
    case SINGLE_PAT_MOD:    *(pmfl) |= RXf_PMf_SINGLELINE; break;           \
    case XTENDED_PAT_MOD:   *(pmfl) |= RXf_PMf_EXTENDED; (x_count)++; break;\
    case NOCAPTURE_PAT_MOD: *(pmfl) |= RXf_PMf_NOCAPTURE; break;

#define STD_PMMOD_FLAGS_PARSE_X_WARN(x_count)                                   \
    if (UNLIKELY((x_count) > 1)) {                                              \
        Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_REGEXP),         \
                    "Having more than one /%c regexp modifier is deprecated",   \
                    XTENDED_PAT_MOD);                                           \
    }
d285 1
a285 1
    *(pmfl) &= ~(RXf_PMf_FOLD|RXf_PMf_MULTILINE|RXf_PMf_SINGLELINE|RXf_PMf_EXTENDED|RXf_PMf_CHARSET|RXf_PMf_NOCAPTURE)
a296 1
#define NOCAPTURE_PAT_MOD    'n'
a311 1
#define NOCAPTURE_PAT_MODS   "n"
d324 1
a324 1
#define STD_PAT_MODS        "msixxn"
d333 1
a333 1
#define EXT_PAT_MODS    ONCE_PAT_MODS   KEEPCOPY_PAT_MODS  NOCAPTURE_PAT_MODS
d344 4
d353 14
a366 1
#define RXf_SPLIT   RXf_PMf_SPLIT
d368 20
a387 32
/* Currently the regex flags occupy a single 32-bit word.  Not all bits are
 * currently used.  The lower bits are shared with their corresponding PMf flag
 * bits, up to but not including _RXf_PMf_SHIFT_NEXT.  The unused bits
 * immediately follow; finally the used RXf-only (unshared) bits, so that the
 * highest bit in the word is used.  This gathers all the unused bits as a pool
 * in the middle, like so: 11111111111111110000001111111111
 * where the '1's represent used bits, and the '0's unused.  This design allows
 * us to allocate off one end of the pool if we need to add a shared bit, and
 * off the other end if we need a non-shared bit, without disturbing the other
 * bits.  This maximizes the likelihood of being able to change things without
 * breaking binary compatibility.
 *
 * To add shared bits, do so in op_reg_common.h.  This should change
 * _RXf_PMf_SHIFT_NEXT so that things won't compile.  Then come to regexp.h and
 * op.h and adjust the constant adders in the definitions of RXf_BASE_SHIFT and
 * Pmf_BASE_SHIFT down by the number of shared bits you added.  That's it.
 * Things should be binary compatible.  But if either of these gets to having
 * to subtract rather than add, leave at 0 and instead adjust all the entries
 * that are in terms of it.  But if the first one of those is already
 * RXf_BASE_SHIFT+0, there are no bits left, and a redesign is in order.
 *
 * To remove unshared bits, just delete its entry.  If you're where breaking
 * binary compatibility is ok to do, you might want to adjust things to move
 * the newly opened space so that it gets absorbed into the common pool.
 *
 * To add unshared bits, first use up any gaps in the middle.  Otherwise,
 * allocate off the low end until you get to RXf_BASE_SHIFT+0.  If that isn't
 * enough, move RXf_BASE_SHIFT down (if possible) and add the new bit at the
 * other end instead; this preserves binary compatibility.
 *
 * For the regexp bits, PL_reg_extflags_name[] in regnodes.h has a comment
 * giving which bits are used/unused */
d389 7
a395 1
#define RXf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT + 2)
d398 3
a400 2
#define RXf_NO_INPLACE_SUBST    (1U<<(RXf_BASE_SHIFT+2))
#define RXf_EVAL_SEEN   	(1U<<(RXf_BASE_SHIFT+3))
d403 2
a404 2
#define RXf_UNBOUNDED_QUANTIFIER_SEEN   (1U<<(RXf_BASE_SHIFT+4))
#define RXf_CHECK_ALL   	(1U<<(RXf_BASE_SHIFT+5))
d407 1
a407 1
#define RXf_MATCH_UTF8  	(1U<<(RXf_BASE_SHIFT+6)) /* $1 etc are utf8 */
d410 3
a412 3
#define RXf_USE_INTUIT_NOML	(1U<<(RXf_BASE_SHIFT+7))
#define RXf_USE_INTUIT_ML	(1U<<(RXf_BASE_SHIFT+8))
#define RXf_INTUIT_TAIL 	(1U<<(RXf_BASE_SHIFT+9))
a414 3
/* Do we have some sort of anchor? */
#define RXf_IS_ANCHORED         (1U<<(RXf_BASE_SHIFT+10))

d416 1
a416 1
#define RXf_COPY_DONE   	(1U<<(RXf_BASE_SHIFT+11))
d419 1
a419 1
#define RXf_TAINTED_SEEN	(1U<<(RXf_BASE_SHIFT+12))
d421 1
a421 1
#define RXf_TAINTED		(1U<<(RXf_BASE_SHIFT+13))
d424 6
a429 12
#define RXf_START_ONLY		(1U<<(RXf_BASE_SHIFT+14)) /* Pattern is /^/ */
#define RXf_SKIPWHITE           (1U<<(RXf_BASE_SHIFT+15)) /* Pattern is for a */
                                                          /* split " " */
#define RXf_WHITE		(1U<<(RXf_BASE_SHIFT+16)) /* Pattern is /\s+/ */
#define RXf_NULL		(1U<<(RXf_BASE_SHIFT+17)) /* Pattern is // */

/* See comments at the beginning of these defines about adding bits.  The
 * highest bit position should be used, so that if RXf_BASE_SHIFT gets
 * increased, the #error below will be triggered so that you will be reminded
 * to adjust things at the other end to keep the bit positions unchanged */
#if RXf_BASE_SHIFT+17 > 31
#   error Too many RXf_PMf bits used.  See comments at beginning of these for what to do
d653 1
a653 1
#define MAX_RECURSE_EVAL_NOCHANGE_DEPTH 10
d738 1
a739 1
            struct regmatch_state *prev_eval;
d743 1
a743 1
            U32         close_paren; /* which close bracket is our end (+1) */
a744 1
            char        *prev_recurse_locinput;
a828 2


d844 6
@


