head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.12.0.10
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.4
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.6
	OPENBSD_5_8_BASE:1.1.1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.1.1.11.0.4
	OPENBSD_5_6_BASE:1.1.1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.10.0.16
	OPENBSD_5_5_BASE:1.1.1.10
	OPENBSD_5_4:1.1.1.10.0.12
	OPENBSD_5_4_BASE:1.1.1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.1.1.10.0.10
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.8
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.6
	OPENBSD_5_0:1.1.1.10.0.4
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.2
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.8
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.6
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.4
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.6.0.2
	OPENBSD_3_6_BASE:1.1.1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.38.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.25;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.45.49;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.32;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    thread.h
 *
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if defined(USE_ITHREADS)

#if defined(VMS)
#include <builtins.h>
#endif

#ifdef WIN32
#  include <win32thread.h>
#else
#ifdef NETWARE
#  include <nw5thread.h>
#else
#  ifdef OLD_PTHREADS_API /* Here be dragons. */
#    define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach(&(t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END

#    define PERL_GET_CONTEXT	Perl_get_context()
#    define PERL_SET_CONTEXT(t)	Perl_set_context((void*)t)

#    define PTHREAD_GETSPECIFIC_INT
#    ifdef DJGPP
#      define pthread_addr_t any_t
#      define NEED_PTHREAD_INIT
#      define PTHREAD_CREATE_JOINABLE (1)
#    endif
#    ifdef OEMVS
#      define pthread_addr_t void *
#      define pthread_create(t,a,s,d)        pthread_create(t,&(a),s,d)
#      define pthread_keycreate              pthread_key_create
#    endif
#    ifdef VMS
#      define pthread_attr_init(a) pthread_attr_create(a)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_setdetach_np(a,s)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(__hpux) && defined(__ux_version) && __ux_version <= 1020
#      define pthread_attr_init(a) pthread_attr_create(a)
       /* XXX pthread_setdetach_np() missing in DCE threads on HP-UX 10.20 */
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s)	(0)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(DJGPP) || defined(OEMVS)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,&(s))
#      define YIELD pthread_yield(NULL)
#    endif
#  endif
#  if !defined(__hpux) || !defined(__ux_version) || __ux_version > 1020
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default  NULL
#  endif
#endif	/* NETWARE */
#endif

#ifndef PTHREAD_CREATE
/* You are not supposed to pass NULL as the 2nd arg of PTHREAD_CREATE(). */
#  define PTHREAD_CREATE(t,a,s,d) pthread_create(t,&(a),s,d)
#endif

#ifndef PTHREAD_ATTR_SETDETACHSTATE
#  define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,s)
#endif

#ifndef PTHREAD_CREATE_JOINABLE
#  ifdef OLD_PTHREAD_CREATE_JOINABLE
#    define PTHREAD_CREATE_JOINABLE OLD_PTHREAD_CREATE_JOINABLE
#  else
#    define PTHREAD_CREATE_JOINABLE 0 /* Panic?  No, guess. */
#  endif
#endif

#ifdef __VMS
  /* Default is 1024 on VAX, 8192 otherwise */
#  ifdef __ia64
#    define THREAD_CREATE_NEEDS_STACK (48*1024)
#  else
#    define THREAD_CREATE_NEEDS_STACK (32*1024)
#  endif
#endif

#ifdef I_MACH_CTHREADS

/* cthreads interface */

/* #include <mach/cthreads.h> is in perl.h #ifdef I_MACH_CTHREADS */

#define MUTEX_INIT(m) \
    STMT_START {						\
	*m = mutex_alloc();					\
	if (*m) {						\
	    mutex_init(*m);					\
	} else {						\
	    Perl_croak_nocontext("panic: MUTEX_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define MUTEX_LOCK(m)			mutex_lock(*m)
#define MUTEX_UNLOCK(m)			mutex_unlock(*m)
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	mutex_free(*m);						\
	*m = 0;							\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	*c = condition_alloc();					\
	if (*c) {						\
	    condition_init(*c);					\
	}							\
	else {							\
	    Perl_croak_nocontext("panic: COND_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
	}							\
    } STMT_END

#define COND_SIGNAL(c)		condition_signal(*c)
#define COND_BROADCAST(c)	condition_broadcast(*c)
#define COND_WAIT(c, m)		condition_wait(*c, *m)
#define COND_DESTROY(c) \
    STMT_START {						\
	condition_free(*c);					\
	*c = 0;							\
    } STMT_END

#define THREAD_CREATE(thr, f)	(thr->self = cthread_fork(f, thr), 0)
#define THREAD_POST_CREATE(thr)

#define THREAD_RET_TYPE		any_t
#define THREAD_RET_CAST(x)	((any_t) x)

#define DETACH(t)		cthread_detach(t->self)
#define JOIN(t, avp)		(*(avp) = MUTABLE_AV(cthread_join(t->self)))

#define PERL_SET_CONTEXT(t)	cthread_set_data(cthread_self(), t)
#define PERL_GET_CONTEXT	cthread_data(cthread_self())

#define INIT_THREADS		cthread_init()
#define YIELD			cthread_yield()
#define ALLOC_THREAD_KEY	NOOP
#define FREE_THREAD_KEY		NOOP
#define SET_THREAD_SELF(thr)	(thr->self = cthread_self())

#endif /* I_MACH_CTHREADS */

#ifndef YIELD
#  ifdef SCHED_YIELD
#    define YIELD SCHED_YIELD
#  else
#    ifdef HAS_SCHED_YIELD
#      define YIELD sched_yield()
#    else
#      ifdef HAS_PTHREAD_YIELD
    /* pthread_yield(NULL) platforms are expected
     * to have #defined YIELD for themselves. */
#        define YIELD pthread_yield()
#      endif
#    endif
#  endif
#endif

#ifdef __hpux
#  define MUTEX_INIT_NEEDS_MUTEX_ZEROED
#endif

#ifndef MUTEX_INIT

#  ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
    /* Temporary workaround, true bug is deeper. --jhi 1999-02-25 */
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	Zero((m), 1, perl_mutex);                               \
 	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  else
#    define MUTEX_INIT(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#  endif

#  ifdef PERL_TSA_ACTIVE
#    define perl_pthread_mutex_lock(m) perl_tsa_mutex_lock(m)
#    define perl_pthread_mutex_unlock(m) perl_tsa_mutex_unlock(m)
#  else
#    define perl_pthread_mutex_lock(m) pthread_mutex_lock(m)
#    define perl_pthread_mutex_unlock(m) pthread_mutex_unlock(m)
#  endif

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = perl_pthread_mutex_lock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_LOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = perl_pthread_mutex_unlock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_mutex_destroy((m))))		\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* MUTEX_INIT */

#ifndef COND_INIT
#  define COND_INIT(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_init((c), pthread_condattr_default)))	\
	    Perl_croak_nocontext("panic: COND_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_SIGNAL(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_signal((c))))			\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_BROADCAST(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_broadcast((c))))		\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_WAIT(c, m) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_wait((c), (m))))		\
	    Perl_croak_nocontext("panic: COND_WAIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END

#  define COND_DESTROY(c) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_cond_destroy((c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* COND_INIT */

/* DETACH(t) must only be called while holding t->mutex */
#ifndef DETACH
#  define DETACH(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_detach((t)->self))) {		\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
	}							\
    } STMT_END
#endif /* DETACH */

#ifndef JOIN
#  define JOIN(t, avp) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_join((t)->self, (void**)(avp))))	\
	    Perl_croak_nocontext("panic: pthread_join (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* JOIN */

/* Use an unchecked fetch of thread-specific data instead of a checked one.
 * It would fail if the key were bogus, but if the key were bogus then
 * Really Bad Things would be happening anyway. --dan */
#if (defined(__ALPHA) && (__VMS_VER >= 70000000)) || \
    (defined(__alpha) && defined(__osf__) && !defined(__GNUC__)) /* Available only on >= 4.0 */
#  define HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP /* Configure test needed */
#endif

#ifdef HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP
#  define PTHREAD_GETSPECIFIC(key) pthread_unchecked_getspecific_np(key)
#else
#    define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
#endif

#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT	PTHREAD_GETSPECIFIC(PL_thr_key)
#endif

#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(t) \
    STMT_START {						\
	int _eC_;						\
	if ((_eC_ = pthread_setspecific(PL_thr_key, (void *)(t))))	\
	    Perl_croak_nocontext("panic: pthread_setspecific (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
    } STMT_END
#endif /* PERL_SET_CONTEXT */

#ifndef INIT_THREADS
#  ifdef NEED_PTHREAD_INIT
#    define INIT_THREADS pthread_init()
#  endif
#endif

#ifndef ALLOC_THREAD_KEY
#  define ALLOC_THREAD_KEY \
    STMT_START {						\
	if (pthread_key_create(&PL_thr_key, 0)) {		\
            PERL_UNUSED_RESULT(write(2, STR_WITH_LEN("panic: pthread_key_create failed\n"))); \
	    exit(1);						\
	}							\
    } STMT_END
#endif

#ifndef FREE_THREAD_KEY
#  define FREE_THREAD_KEY \
    STMT_START {						\
	pthread_key_delete(PL_thr_key);				\
    } STMT_END
#endif

#ifndef PTHREAD_ATFORK
#  ifdef HAS_PTHREAD_ATFORK
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	pthread_atfork(prepare,parent,child)
#  else
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	NOOP
#  endif
#endif

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */

#  define LOCK_DOLLARZERO_MUTEX		MUTEX_LOCK(&PL_dollarzero_mutex)
#  define UNLOCK_DOLLARZERO_MUTEX	MUTEX_UNLOCK(&PL_dollarzero_mutex)

#endif /* USE_ITHREADS */

#ifndef MUTEX_LOCK
#  define MUTEX_LOCK(m)
#endif

#ifndef MUTEX_UNLOCK
#  define MUTEX_UNLOCK(m)
#endif

#ifndef MUTEX_INIT
#  define MUTEX_INIT(m)
#endif

#ifndef MUTEX_DESTROY
#  define MUTEX_DESTROY(m)
#endif

#ifndef COND_INIT
#  define COND_INIT(c)
#endif

#ifndef COND_SIGNAL
#  define COND_SIGNAL(c)
#endif

#ifndef COND_BROADCAST
#  define COND_BROADCAST(c)
#endif

#ifndef COND_WAIT
#  define COND_WAIT(c, m)
#endif

#ifndef COND_DESTROY
#  define COND_DESTROY(c)
#endif

#ifndef LOCK_DOLLARZERO_MUTEX
#  define LOCK_DOLLARZERO_MUTEX
#endif

#ifndef UNLOCK_DOLLARZERO_MUTEX
#  define UNLOCK_DOLLARZERO_MUTEX
#endif

/* THR, SET_THR, and dTHR are there for compatibility with old versions */
#ifndef THR
#  define THR		PERL_GET_THX
#endif

#ifndef SET_THR
#  define SET_THR(t)	PERL_SET_THX(t)
#endif

#ifndef dTHR
#  define dTHR dNOOP
#endif

#ifndef INIT_THREADS
#  define INIT_THREADS NOOP
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.1
log
@Initial revision
@
text
@d1 15
a15 1
#ifdef USE_THREADS
d20 56
d77 7
a83 18
#ifndef DJGPP
/* POSIXish threads */
#ifdef OLD_PTHREADS_API
#  define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#  define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#  define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#  define YIELD pthread_yield()
#  define DETACH(t)				\
    STMT_START {				\
	if (pthread_detach(&(t)->self)) {	\
	    MUTEX_UNLOCK(&(t)->mutex);		\
	    croak("panic: DETACH");		\
	}					\
    } STMT_END
#else
#  define pthread_mutexattr_default NULL
#  define pthread_condattr_default NULL
#endif /* OLD_PTHREADS_API */
d85 7
d94 4
a97 5
#ifdef PTHREADS_CREATED_JOINABLE
#  define ATTR_JOINABLE PTHREAD_CREATE_JOINABLE
#else
#  ifdef PTHREAD_CREATE_UNDETACHED
#    define ATTR_JOINABLE PTHREAD_CREATE_UNDETACHED
d99 1
a99 1
#    define ATTR_JOINABLE PTHREAD_CREATE_JOINABLE
d109 30
a138 27
#define MUTEX_INIT(m)					\
	STMT_START {					\
		*m = mutex_alloc();			\
		if (*m) {				\
			mutex_init(*m);			\
		} else {				\
			croak("panic: MUTEX_INIT");	\
		}					\
	} STMT_END

#define MUTEX_LOCK(m)		mutex_lock(*m)
#define MUTEX_UNLOCK(m)		mutex_unlock(*m)
#define MUTEX_DESTROY(m)				\
	STMT_START {					\
		mutex_free(*m);				\
		*m = 0;					\
	} STMT_END

#define COND_INIT(c)					\
	STMT_START {					\
		*c = condition_alloc();			\
		if (*c) {				\
			condition_init(*c);		\
		} else {				\
			croak("panic: COND_INIT");	\
		}					\
	} STMT_END
d143 5
a147 5
#define COND_DESTROY(c)				\
	STMT_START {				\
		condition_free(*c);		\
		*c = 0;				\
	} STMT_END
d156 1
a156 1
#define JOIN(t, avp)		(*(avp) = (AV *)cthread_join(t->self))
d158 2
a159 2
#define SET_THR(thr)		cthread_set_data(cthread_self(), thr)
#define THR			cthread_data(cthread_self())
d163 2
a164 1
#define ALLOC_THREAD_KEY
d170 2
a171 2
#  ifdef HAS_SCHED_YIELD
#    define YIELD sched_yield()
d173 8
a180 2
#    ifdef HAS_PTHREAD_YIELD
#      define YIELD pthread_yield()
d190 2
a191 1
#ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
d193 1
a193 1
#define MUTEX_INIT(m)						\
d195 1
d197 3
a199 2
 	if (pthread_mutex_init((m), pthread_mutexattr_default))	\
	    croak("panic: MUTEX_INIT");				\
d201 27
a227 2
#else
#define MUTEX_INIT(m)						\
d229 4
a232 2
	if (pthread_mutex_init((m), pthread_mutexattr_default))	\
	    croak("panic: MUTEX_INIT");				\
d234 7
a240 15
#endif
#define MUTEX_LOCK(m)				\
    STMT_START {				\
	if (pthread_mutex_lock((m)))		\
	    croak("panic: MUTEX_LOCK");		\
    } STMT_END
#define MUTEX_UNLOCK(m)				\
    STMT_START {				\
	if (pthread_mutex_unlock((m)))		\
	    croak("panic: MUTEX_UNLOCK");	\
    } STMT_END
#define MUTEX_DESTROY(m)			\
    STMT_START {				\
	if (pthread_mutex_destroy((m)))		\
	    croak("panic: MUTEX_DESTROY");	\
d245 25
a269 1
#define COND_INIT(c)						\
d271 4
a274 2
	if (pthread_cond_init((c), pthread_condattr_default))	\
	    croak("panic: COND_INIT");				\
d276 7
a282 19
#define COND_SIGNAL(c)				\
    STMT_START {				\
	if (pthread_cond_signal((c)))		\
	    croak("panic: COND_SIGNAL");	\
    } STMT_END
#define COND_BROADCAST(c)			\
    STMT_START {				\
	if (pthread_cond_broadcast((c)))	\
	    croak("panic: COND_BROADCAST");	\
    } STMT_END
#define COND_WAIT(c, m)				\
    STMT_START {				\
	if (pthread_cond_wait((c), (m)))	\
	    croak("panic: COND_WAIT");		\
    } STMT_END
#define COND_DESTROY(c)				\
    STMT_START {				\
	if (pthread_cond_destroy((c)))		\
	    croak("panic: COND_DESTROY");	\
d288 8
a295 6
#define DETACH(t)				\
    STMT_START {				\
	if (pthread_detach((t)->self)) {	\
	    MUTEX_UNLOCK(&(t)->mutex);		\
	    croak("panic: DETACH");		\
	}					\
d300 6
a305 4
#define JOIN(t, avp) 					\
    STMT_START {					\
	if (pthread_join((t)->self, (void**)(avp)))	\
	    croak("panic: pthread_join");		\
d309 13
a321 7
#ifndef SET_THR
#define SET_THR(t)					\
    STMT_START {					\
	if (pthread_setspecific(PL_thr_key, (void *) (t)))	\
	    croak("panic: pthread_setspecific");	\
    } STMT_END
#endif /* SET_THR */
d323 3
a325 8
#ifndef THR
#  ifdef OLD_PTHREADS_API
struct perl_thread *getTHR _((void));
#    define THR getTHR()
#  else
#    define THR ((struct perl_thread *) pthread_getspecific(PL_thr_key))
#  endif /* OLD_PTHREADS_API */
#endif /* THR */
d327 9
a335 13
/*
 * dTHR is performance-critical. Here, we only do the pthread_get_specific
 * if there may be more than one thread in existence, otherwise we get thr
 * from thrsv which is cached in the per-interpreter structure.
 * Systems with very fast pthread_get_specific (which should be all systems
 * but unfortunately isn't) may wish to simplify to "...*thr = THR".
 *
 * The use of PL_threadnum should be safe here.
 */
#ifndef dTHR
#  define dTHR \
    struct perl_thread *thr = PL_threadnum? THR : (struct perl_thread*)SvPVX(PL_thrsv)
#endif /* dTHR */
a339 2
#  else
#    define INIT_THREADS NOOP
d343 7
a349 13
/* Accessor for per-thread SVs */
#define THREADSV(i) (thr->threadsvp[i])

/*
 * LOCK_SV_MUTEX and UNLOCK_SV_MUTEX are performance-critical. Here, we
 * try only locking them if there may be more than one thread in existence.
 * Systems with very fast mutexes (and/or slow conditionals) may wish to
 * remove the "if (threadnum) ..." test.
 * XXX do NOT use C<if (PL_threadnum) ...> -- it sets up race conditions!
 */
#define LOCK_SV_MUTEX				\
    STMT_START {				\
	MUTEX_LOCK(&PL_sv_mutex);		\
d351 1
d353 4
a356 3
#define UNLOCK_SV_MUTEX				\
    STMT_START {				\
	MUTEX_UNLOCK(&PL_sv_mutex);		\
d358 1
d360 9
a368 10
/* Likewise for strtab_mutex */
#define LOCK_STRTAB_MUTEX			\
    STMT_START {				\
	MUTEX_LOCK(&PL_strtab_mutex);	\
    } STMT_END

#define UNLOCK_STRTAB_MUTEX			\
    STMT_START {				\
	MUTEX_UNLOCK(&PL_strtab_mutex);	\
    } STMT_END
d375 16
d392 3
a394 30
/* Values and macros for thr->flags */
#define THRf_STATE_MASK	7
#define THRf_R_JOINABLE	0
#define THRf_R_JOINED	1
#define THRf_R_DETACHED	2
#define THRf_ZOMBIE	3
#define THRf_DEAD	4

#define THRf_DID_DIE	8

/* ThrSTATE(t) and ThrSETSTATE(t) must only be called while holding t->mutex */
#define ThrSTATE(t) ((t)->flags & THRf_STATE_MASK)
#define ThrSETSTATE(t, s) STMT_START {		\
	(t)->flags &= ~THRf_STATE_MASK;		\
	(t)->flags |= (s);			\
	DEBUG_S(PerlIO_printf(PerlIO_stderr(),	\
			      "thread %p set to state %d\n", (t), (s))); \
    } STMT_END

typedef struct condpair {
    perl_mutex	mutex;		/* Protects all other fields */
    perl_cond	owner_cond;	/* For when owner changes at all */
    perl_cond	cond;		/* For cond_signal and cond_broadcast */
    Thread	owner;		/* Currently owning thread */
} condpair_t;

#define MgMUTEXP(mg) (&((condpair_t *)(mg->mg_ptr))->mutex)
#define MgOWNERCONDP(mg) (&((condpair_t *)(mg->mg_ptr))->owner_cond)
#define MgCONDP(mg) (&((condpair_t *)(mg->mg_ptr))->cond)
#define MgOWNER(mg) ((condpair_t *)(mg->mg_ptr))->owner
d396 40
a435 15
#else
/* USE_THREADS is not defined */
#define MUTEX_LOCK(m)
#define MUTEX_UNLOCK(m)
#define MUTEX_INIT(m)
#define MUTEX_DESTROY(m)
#define COND_INIT(c)
#define COND_SIGNAL(c)
#define COND_BROADCAST(c)
#define COND_WAIT(c, m)
#define COND_DESTROY(c)
#define LOCK_SV_MUTEX
#define UNLOCK_SV_MUTEX
#define LOCK_STRTAB_MUTEX
#define UNLOCK_STRTAB_MUTEX
d437 2
a438 6
#define THR
/* Rats: if dTHR is just blank then the subsequent ";" throws an error */
#ifdef WIN32
#define dTHR extern int Perl___notused
#else
#define dTHR extern int errno
d440 4
a443 1
#endif /* USE_THREADS */
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d1 1
a1 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d6 14
a19 7
#  ifdef OLD_PTHREADS_API /* Here be dragons. */
#    define DETACH(t) \
    STMT_START {						\
	if (pthread_detach(&(t)->self)) {			\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH");		\
	}							\
d21 4
a24 28

#    define PERL_GET_CONTEXT	Perl_get_context()
#    define PERL_SET_CONTEXT(t)	Perl_set_context((void*)t)

#    define PTHREAD_GETSPECIFIC_INT
#    ifdef DJGPP
#      define pthread_addr_t any_t
#      define NEED_PTHREAD_INIT
#      define PTHREAD_CREATE_JOINABLE (1)
#    endif
#    ifdef __OPEN_VM
#      define pthread_addr_t void *
#    endif
#    ifdef VMS
#      define pthread_attr_init(a) pthread_attr_create(a)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_setdetach_np(a,s)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
#    if defined(DJGPP) || defined(__OPEN_VM)
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,&(s))
#      define YIELD pthread_yield(NULL)
#    endif
#  endif
#    define pthread_mutexattr_default NULL
#    define pthread_condattr_default  NULL
a25 4

#ifndef PTHREAD_CREATE
/* You are not supposed to pass NULL as the 2nd arg of PTHREAD_CREATE(). */
#  define PTHREAD_CREATE(t,a,s,d) pthread_create(t,&(a),s,d)
d28 5
a32 7
#ifndef PTHREAD_ATTR_SETDETACHSTATE
#  define PTHREAD_ATTR_SETDETACHSTATE(a,s) pthread_attr_setdetachstate(a,s)
#endif

#ifndef PTHREAD_CREATE_JOINABLE
#  ifdef OLD_PTHREAD_CREATE_JOINABLE
#    define PTHREAD_CREATE_JOINABLE OLD_PTHREAD_CREATE_JOINABLE
d34 1
a34 1
#    define PTHREAD_CREATE_JOINABLE 0 /* Panic?  No, guess. */
d44 27
a70 28
#define MUTEX_INIT(m) \
    STMT_START {						\
	*m = mutex_alloc();					\
	if (*m) {						\
	    mutex_init(*m);					\
	} else {						\
	    Perl_croak_nocontext("panic: MUTEX_INIT");		\
	}							\
    } STMT_END

#define MUTEX_LOCK(m)			mutex_lock(*m)
#define MUTEX_UNLOCK(m)			mutex_unlock(*m)
#define MUTEX_DESTROY(m) \
    STMT_START {						\
	mutex_free(*m);						\
	*m = 0;							\
    } STMT_END

#define COND_INIT(c) \
    STMT_START {						\
	*c = condition_alloc();					\
	if (*c) {						\
	    condition_init(*c);					\
	}							\
	else {							\
	    Perl_croak_nocontext("panic: COND_INIT");		\
	}							\
    } STMT_END
d75 5
a79 5
#define COND_DESTROY(c) \
    STMT_START {						\
	condition_free(*c);					\
	*c = 0;							\
    } STMT_END
d90 2
a91 2
#define PERL_SET_CONTEXT(t)	cthread_set_data(cthread_self(), t)
#define PERL_GET_CONTEXT	cthread_data(cthread_self())
d95 1
a95 1
#define ALLOC_THREAD_KEY	NOOP
d101 2
a102 2
#  ifdef SCHED_YIELD
#    define YIELD SCHED_YIELD
d104 2
a105 8
#    ifdef HAS_SCHED_YIELD
#      define YIELD sched_yield()
#    else
#      ifdef HAS_PTHREAD_YIELD
    /* pthread_yield(NULL) platforms are expected
     * to have #defined YIELD for themselves. */
#        define YIELD pthread_yield()
#      endif
d115 1
a115 2

#  ifdef MUTEX_INIT_NEEDS_MUTEX_ZEROED
d117 1
a117 1
#    define MUTEX_INIT(m) \
d121 1
a121 1
	    Perl_croak_nocontext("panic: MUTEX_INIT");		\
d123 2
a124 2
#  else
#    define MUTEX_INIT(m) \
d127 1
a127 1
	    Perl_croak_nocontext("panic: MUTEX_INIT");		\
d129 15
a143 18
#  endif

#  define MUTEX_LOCK(m) \
    STMT_START {						\
	if (pthread_mutex_lock((m)))				\
	    Perl_croak_nocontext("panic: MUTEX_LOCK");		\
    } STMT_END

#  define MUTEX_UNLOCK(m) \
    STMT_START {						\
	if (pthread_mutex_unlock((m)))				\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK");	\
    } STMT_END

#  define MUTEX_DESTROY(m) \
    STMT_START {						\
	if (pthread_mutex_destroy((m)))				\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY");	\
d148 1
a148 1
#  define COND_INIT(c) \
d151 1
a151 19
	    Perl_croak_nocontext("panic: COND_INIT");		\
    } STMT_END

#  define COND_SIGNAL(c) \
    STMT_START {						\
	if (pthread_cond_signal((c)))				\
	    Perl_croak_nocontext("panic: COND_SIGNAL");		\
    } STMT_END

#  define COND_BROADCAST(c) \
    STMT_START {						\
	if (pthread_cond_broadcast((c)))			\
	    Perl_croak_nocontext("panic: COND_BROADCAST");	\
    } STMT_END

#  define COND_WAIT(c, m) \
    STMT_START {						\
	if (pthread_cond_wait((c), (m)))			\
	    Perl_croak_nocontext("panic: COND_WAIT");		\
d153 19
a171 5

#  define COND_DESTROY(c) \
    STMT_START {						\
	if (pthread_cond_destroy((c)))				\
	    Perl_croak_nocontext("panic: COND_DESTROY");	\
d177 6
a182 6
#  define DETACH(t) \
    STMT_START {						\
	if (pthread_detach((t)->self)) {			\
	    MUTEX_UNLOCK(&(t)->mutex);				\
	    Perl_croak_nocontext("panic: DETACH");		\
	}							\
d187 4
a190 4
#  define JOIN(t, avp) \
    STMT_START {						\
	if (pthread_join((t)->self, (void**)(avp)))		\
	    Perl_croak_nocontext("panic: pthread_join");	\
d194 16
a209 3
#ifndef PERL_GET_CONTEXT
#  define PERL_GET_CONTEXT	pthread_getspecific(PL_thr_key)
#endif
d211 13
a223 7
#ifndef PERL_SET_CONTEXT
#  define PERL_SET_CONTEXT(t) \
    STMT_START {						\
	if (pthread_setspecific(PL_thr_key, (void *)(t)))	\
	    Perl_croak_nocontext("panic: pthread_setspecific");	\
    } STMT_END
#endif /* PERL_SET_CONTEXT */
d228 2
a232 17
#ifndef ALLOC_THREAD_KEY
#  define ALLOC_THREAD_KEY \
    STMT_START {						\
	if (pthread_key_create(&PL_thr_key, 0))	{		\
	    fprintf(stderr, "panic: pthread_key_create");	\
	    exit(1);						\
	}							\
    } STMT_END
#endif

#ifndef THREAD_RET_TYPE
#  define THREAD_RET_TYPE	void *
#  define THREAD_RET_CAST(p)	((void *)(p))
#endif /* THREAD_RET */

#if defined(USE_THREADS)

d234 1
a234 1
#  define THREADSV(i) (thr->threadsvp[i])
d243 25
a267 6
#  define LOCK_SV_MUTEX		MUTEX_LOCK(&PL_sv_mutex)
#  define UNLOCK_SV_MUTEX	MUTEX_UNLOCK(&PL_sv_mutex)
#  define LOCK_STRTAB_MUTEX	MUTEX_LOCK(&PL_strtab_mutex)
#  define UNLOCK_STRTAB_MUTEX	MUTEX_UNLOCK(&PL_strtab_mutex)
#  define LOCK_CRED_MUTEX	MUTEX_LOCK(&PL_cred_mutex)
#  define UNLOCK_CRED_MUTEX	MUTEX_UNLOCK(&PL_cred_mutex)
d285 1
a285 1
	DEBUG_S(PerlIO_printf(Perl_debug_log,	\
d301 15
a315 2
#endif /* USE_THREADS */
#endif /* USE_THREADS || USE_ITHREADS */
d317 6
a322 75
#ifndef MUTEX_LOCK
#  define MUTEX_LOCK(m)
#endif

#ifndef MUTEX_UNLOCK
#  define MUTEX_UNLOCK(m)
#endif

#ifndef MUTEX_INIT
#  define MUTEX_INIT(m)
#endif

#ifndef MUTEX_DESTROY
#  define MUTEX_DESTROY(m)
#endif

#ifndef COND_INIT
#  define COND_INIT(c)
#endif

#ifndef COND_SIGNAL
#  define COND_SIGNAL(c)
#endif

#ifndef COND_BROADCAST
#  define COND_BROADCAST(c)
#endif

#ifndef COND_WAIT
#  define COND_WAIT(c, m)
#endif

#ifndef COND_DESTROY
#  define COND_DESTROY(c)
#endif

#ifndef LOCK_SV_MUTEX
#  define LOCK_SV_MUTEX
#endif

#ifndef UNLOCK_SV_MUTEX
#  define UNLOCK_SV_MUTEX
#endif

#ifndef LOCK_STRTAB_MUTEX
#  define LOCK_STRTAB_MUTEX
#endif

#ifndef UNLOCK_STRTAB_MUTEX
#  define UNLOCK_STRTAB_MUTEX
#endif

#ifndef LOCK_CRED_MUTEX
#  define LOCK_CRED_MUTEX
#endif

#ifndef UNLOCK_CRED_MUTEX
#  define UNLOCK_CRED_MUTEX
#endif

/* THR, SET_THR, and dTHR are there for compatibility with old versions */
#ifndef THR
#  define THR		PERL_GET_THX
#endif

#ifndef SET_THR
#  define SET_THR(t)	PERL_SET_THX(t)
#endif

#ifndef dTHR
#  define dTHR dNOOP
#endif

#ifndef INIT_THREADS
#  define INIT_THREADS NOOP
d324 1
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a34 9
#    if defined(__hpux) && defined(__ux_version) && __ux_version <= 1020
#      define pthread_attr_init(a) pthread_attr_create(a)
       /* XXX pthread_setdetach_np() missing in DCE threads on HP-UX 10.20 */
#      define PTHREAD_ATTR_SETDETACHSTATE(a,s)	(0)
#      define PTHREAD_CREATE(t,a,s,d) pthread_create(t,a,s,d)
#      define pthread_key_create(k,d) pthread_keycreate(k,(pthread_destructor_t)(d))
#      define pthread_mutexattr_init(a) pthread_mutexattr_create(a)
#      define pthread_mutexattr_settype(a,t) pthread_mutexattr_setkind_np(a,t)
#    endif
a39 1
#  if !defined(__hpux) || !defined(__ux_version) || __ux_version > 1020
a41 1
#  endif
a119 1
#define FREE_THREAD_KEY		NOOP
d254 1
a254 1
	    PerlIO_printf(PerlIO_stderr(), "panic: pthread_key_create");	\
a259 7
#ifndef FREE_THREAD_KEY
#  define FREE_THREAD_KEY \
    STMT_START {						\
	pthread_key_delete(PL_thr_key);				\
    } STMT_END
#endif

d283 1
a283 4
#  define LOCK_FDPID_MUTEX	MUTEX_LOCK(&PL_fdpid_mutex)
#  define UNLOCK_FDPID_MUTEX	MUTEX_UNLOCK(&PL_fdpid_mutex)
#  define LOCK_SV_LOCK_MUTEX	MUTEX_LOCK(&PL_sv_lock_mutex)
#  define UNLOCK_SV_LOCK_MUTEX	MUTEX_UNLOCK(&PL_sv_lock_mutex)
a376 16
#endif

#ifndef LOCK_FDPID_MUTEX
#  define LOCK_FDPID_MUTEX
#endif

#ifndef UNLOCK_FDPID_MUTEX
#  define UNLOCK_FDPID_MUTEX
#endif

#ifndef LOCK_SV_LOCK_MUTEX
#  define LOCK_SV_LOCK_MUTEX
#endif

#ifndef UNLOCK_SV_LOCK_MUTEX
#  define UNLOCK_SV_LOCK_MUTEX
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 14
/*    thread.h
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

#if defined(USE_5005THREADS) || defined(USE_ITHREADS)

#if defined(VMS)
#include <builtins.h>
#endif
a5 3
#ifdef NETWARE
#  include <nw5thread.h>
#else
a52 1
#endif	/* NETWARE */
a71 4
#ifdef DGUX
#  define THREAD_CREATE_NEEDS_STACK (32*1024)
#endif

a243 14
/* Use an unchecked fetch of thread-specific data instead of a checked one.
 * It would fail if the key were bogus, but if the key were bogus then
 * Really Bad Things would be happening anyway. --dan */
#if (defined(__ALPHA) && (__VMS_VER >= 70000000)) || \
    (defined(__alpha) && defined(__osf__)) /* Available only on >= 4.0 */
#  define HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP /* Configure test needed */
#endif

#ifdef HAS_PTHREAD_UNCHECKED_GETSPECIFIC_NP
#  define PTHREAD_GETSPECIFIC(key) pthread_unchecked_getspecific_np(key)
#else
#  define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
#endif

d245 1
a245 1
#  define PERL_GET_CONTEXT	PTHREAD_GETSPECIFIC(PL_thr_key)
a278 10
#ifndef PTHREAD_ATFORK
#  ifdef HAS_PTHREAD_ATFORK
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	pthread_atfork(prepare,parent,child)
#  else
#    define PTHREAD_ATFORK(prepare,parent,child)		\
	NOOP
#  endif
#endif

d284 1
a284 1
#if defined(USE_5005THREADS)
d338 2
a339 2
#endif /* USE_5005THREADS */
#endif /* USE_5005THREADS || USE_ITHREADS */
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (C) 1999, 2000, 2001, 2002, by Larry Wall and others
a42 5
#    ifdef OEMVS
#      define pthread_addr_t void *
#      define pthread_create(t,a,s,d)        pthread_create(t,&(a),s,d)
#      define pthread_keycreate              pthread_key_create
#    endif
d60 1
a60 1
#    if defined(DJGPP) || defined(__OPEN_VM) || defined(OEMVS)
d269 1
a269 1
    (defined(__alpha) && defined(__osf__) && !defined(__GNUC__)) /* Available only on >= 4.0 */
d276 1
a276 1
#    define PTHREAD_GETSPECIFIC(key) pthread_getspecific(key)
a383 4

#  define LOCK_DOLLARZERO_MUTEX		MUTEX_LOCK(&PL_dollarzero_mutex)
#  define UNLOCK_DOLLARZERO_MUTEX	MUTEX_UNLOCK(&PL_dollarzero_mutex)

a459 8
#endif

#ifndef LOCK_DOLLARZERO_MUTEX
#  define LOCK_DOLLARZERO_MUTEX
#endif

#ifndef UNLOCK_DOLLARZERO_MUTEX
#  define UNLOCK_DOLLARZERO_MUTEX
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2004, by Larry Wall and others
d25 1
a25 2
	int _eC_;						\
	if ((_eC_ = pthread_detach(&(t)->self))) {		\
d27 1
a27 2
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d110 1
a110 2
	    Perl_croak_nocontext("panic: MUTEX_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
d129 1
a129 2
	    Perl_croak_nocontext("panic: COND_INIT [%s:%d]",	\
				 __FILE__, __LINE__);		\
a187 1
	int _eC_;						\
d189 2
a190 3
 	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d195 2
a196 4
	int _eC_;						\
	if ((_eC_ = pthread_mutex_init((m), pthread_mutexattr_default)))	\
	    Perl_croak_nocontext("panic: MUTEX_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d202 2
a203 4
	int _eC_;						\
	if ((_eC_ = pthread_mutex_lock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_LOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d208 2
a209 4
	int _eC_;						\
	if ((_eC_ = pthread_mutex_unlock((m))))			\
	    Perl_croak_nocontext("panic: MUTEX_UNLOCK (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d214 2
a215 4
	int _eC_;						\
	if ((_eC_ = pthread_mutex_destroy((m))))		\
	    Perl_croak_nocontext("panic: MUTEX_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d222 2
a223 4
	int _eC_;						\
	if ((_eC_ = pthread_cond_init((c), pthread_condattr_default)))	\
	    Perl_croak_nocontext("panic: COND_INIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d228 2
a229 4
	int _eC_;						\
	if ((_eC_ = pthread_cond_signal((c))))			\
	    Perl_croak_nocontext("panic: COND_SIGNAL (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d234 2
a235 4
	int _eC_;						\
	if ((_eC_ = pthread_cond_broadcast((c))))		\
	    Perl_croak_nocontext("panic: COND_BROADCAST (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d240 2
a241 4
	int _eC_;						\
	if ((_eC_ = pthread_cond_wait((c), (m))))		\
	    Perl_croak_nocontext("panic: COND_WAIT (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d246 2
a247 4
	int _eC_;						\
	if ((_eC_ = pthread_cond_destroy((c))))			\
	    Perl_croak_nocontext("panic: COND_DESTROY (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d255 1
a255 2
	int _eC_;						\
	if ((_eC_ = pthread_detach((t)->self))) {		\
d257 1
a257 2
	    Perl_croak_nocontext("panic: DETACH (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d265 2
a266 4
	int _eC_;						\
	if ((_eC_ = pthread_join((t)->self, (void**)(avp))))	\
	    Perl_croak_nocontext("panic: pthread_join (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d291 2
a292 4
	int _eC_;						\
	if ((_eC_ = pthread_setspecific(PL_thr_key, (void *)(t))))	\
	    Perl_croak_nocontext("panic: pthread_setspecific (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
d305 2
a306 4
	int _eC_;						\
	if ((_eC_ = pthread_key_create(&PL_thr_key, 0))) {	\
	    PerlIO_printf(PerlIO_stderr(), "panic: pthread_key_create (%d) [%s:%d]",	\
				 _eC_, __FILE__, __LINE__);	\
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 2
 *    Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005
 *    by Larry Wall and others
d337 2
a338 1
            write(2, "panic: pthread_key_create failed\n", 33); \
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
d11 1
a11 1
#if defined(USE_ITHREADS)
a100 5
#ifdef __VMS
  /* Default is 1024 on VAX, 8192 otherwise */
#  define THREAD_CREATE_NEEDS_STACK (32*1024)
#endif

d336 3
a338 2
	if (pthread_key_create(&PL_thr_key, 0)) {		\
            write(2, STR_WITH_LEN("panic: pthread_key_create failed\n")); \
d366 56
d425 1
a425 1
#endif /* USE_ITHREADS */
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d103 1
a103 5
#  ifdef __ia64
#    define THREAD_CREATE_NEEDS_STACK (48*1024)
#  else
#    define THREAD_CREATE_NEEDS_STACK (32*1024)
#  endif
d159 1
a159 1
#define JOIN(t, avp)		(*(avp) = MUTABLE_AV(cthread_join(t->self)))
a474 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d415 40
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d43 3
d68 1
a68 1
#    if defined(DJGPP) || defined(OEMVS)
d444 1
a444 1
 * indent-tabs-mode: nil
d447 1
a447 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d94 4
d343 1
a343 1
            PERL_UNUSED_RESULT(write(2, STR_WITH_LEN("panic: pthread_key_create failed\n"))); \
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@a210 8
#  ifdef PERL_TSA_ACTIVE
#    define perl_pthread_mutex_lock(m) perl_tsa_mutex_lock(m)
#    define perl_pthread_mutex_unlock(m) perl_tsa_mutex_unlock(m)
#  else
#    define perl_pthread_mutex_lock(m) pthread_mutex_lock(m)
#    define perl_pthread_mutex_unlock(m) pthread_mutex_unlock(m)
#  endif

d214 1
a214 1
	if ((_eC_ = perl_pthread_mutex_lock((m))))			\
d222 1
a222 1
	if ((_eC_ = perl_pthread_mutex_unlock((m))))			\
d434 6
@


