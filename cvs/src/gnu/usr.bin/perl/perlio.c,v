head	1.18;
access;
symbols
	OPENBSD_6_0:1.17.0.10
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.4
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.41;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.02.20.13.32;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.08.16.48.29;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.34.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.04.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.48.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.35;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.13;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.45.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.16.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.34;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.07;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.28;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.27;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.30;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@perl 5.004_04
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*
 * perlio.c
 * Copyright (c) 1996-2006, Nick Ing-Simmons
 * Copyright (c) 2006, 2007, 2008, 2009, 2010, 2011 Larry Wall and others
 *
 * You may distribute under the terms of either the GNU General Public License
 * or the Artistic License, as specified in the README file.
 */

/*
 * Hour after hour for nearly three weary days he had jogged up and down,
 * over passes, and through long dales, and across many streams.
 *
 *     [pp.791-792 of _The Lord of the Rings_, V/iii: "The Muster of Rohan"]
 */

/* This file contains the functions needed to implement PerlIO, which
 * is Perl's private replacement for the C stdio library. This is used
 * by default unless you compile with -Uuseperlio or run with
 * PERLIO=:stdio (but don't do this unless you know what you're doing)
 */

/*
 * If we have ActivePerl-like PERL_IMPLICIT_SYS then we need a dTHX to get
 * at the dispatch tables, even when we do not need it for other reasons.
 * Invent a dSYS macro to abstract this out
 */
#ifdef PERL_IMPLICIT_SYS
#define dSYS dTHX
#else
#define dSYS dNOOP
#endif

#define PERLIO_NOT_STDIO 0
/*
 * This file provides those parts of PerlIO abstraction
 * which are not #defined in perlio.h.
 * Which these are depends on various Configure #ifdef's
 */

#include "EXTERN.h"
#define PERL_IN_PERLIO_C
#include "perl.h"

#ifdef PERL_IMPLICIT_CONTEXT
#undef dSYS
#define dSYS dTHX
#endif

#include "XSUB.h"

#ifdef __Lynx__
/* Missing proto on LynxOS */
int mkstemp(char*);
#endif

#ifdef VMS
#include <rms.h>
#endif

#define PerlIO_lockcnt(f) (((PerlIOl*)(f))->head->flags)

/* Call the callback or PerlIOBase, and return failure. */
#define Perl_PerlIO_or_Base(f, callback, base, failure, args) 	\
	if (PerlIOValid(f)) {					\
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
		if (tab && tab->callback)			\
			return (*tab->callback) args;		\
		else						\
			return PerlIOBase_ ## base args;	\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN);			\
	return failure

/* Call the callback or fail, and return failure. */
#define Perl_PerlIO_or_fail(f, callback, failure, args) 	\
	if (PerlIOValid(f)) {					\
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
		if (tab && tab->callback)			\
			return (*tab->callback) args;		\
		SETERRNO(EINVAL, LIB_INVARG);			\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN);			\
	return failure

/* Call the callback or PerlIOBase, and be void. */
#define Perl_PerlIO_or_Base_void(f, callback, base, args) 	\
	if (PerlIOValid(f)) {					\
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
		if (tab && tab->callback)			\
			(*tab->callback) args;			\
		else						\
			PerlIOBase_ ## base args;		\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN)

/* Call the callback or fail, and be void. */
#define Perl_PerlIO_or_fail_void(f, callback, args) 		\
	if (PerlIOValid(f)) {					\
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
		if (tab && tab->callback)			\
			(*tab->callback) args;			\
		else						\
			SETERRNO(EINVAL, LIB_INVARG);		\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN)

#if defined(__osf__) && _XOPEN_SOURCE < 500
extern int   fseeko(FILE *, off_t, int);
extern off_t ftello(FILE *);
#endif

#define NATIVE_0xd  CR_NATIVE
#define NATIVE_0xa  LF_NATIVE

EXTERN_C int perlsio_binmode(FILE *fp, int iotype, int mode);

int
perlsio_binmode(FILE *fp, int iotype, int mode)
{
    /*
     * This used to be contents of do_binmode in doio.c
     */
#ifdef DOSISH
    dTHX;
    PERL_UNUSED_ARG(iotype);
#ifdef NETWARE
    if (PerlLIO_setmode(fp, mode) != -1) {
#else
    if (PerlLIO_setmode(fileno(fp), mode) != -1) {
#endif
        return 1;
    }
    else
        return 0;
#else
#  if defined(USEMYBINMODE)
    dTHX;
#    if defined(__CYGWIN__)
    PERL_UNUSED_ARG(iotype);
#    endif
    if (my_binmode(fp, iotype, mode) != FALSE)
        return 1;
    else
        return 0;
#  else
    PERL_UNUSED_ARG(fp);
    PERL_UNUSED_ARG(iotype);
    PERL_UNUSED_ARG(mode);
    return 1;
#  endif
#endif
}

#ifndef O_ACCMODE
#define O_ACCMODE 3             /* Assume traditional implementation */
#endif

int
PerlIO_intmode2str(int rawmode, char *mode, int *writing)
{
    const int result = rawmode & O_ACCMODE;
    int ix = 0;
    int ptype;
    switch (result) {
    case O_RDONLY:
	ptype = IoTYPE_RDONLY;
	break;
    case O_WRONLY:
	ptype = IoTYPE_WRONLY;
	break;
    case O_RDWR:
    default:
	ptype = IoTYPE_RDWR;
	break;
    }
    if (writing)
	*writing = (result != O_RDONLY);

    if (result == O_RDONLY) {
	mode[ix++] = 'r';
    }
#ifdef O_APPEND
    else if (rawmode & O_APPEND) {
	mode[ix++] = 'a';
	if (result != O_WRONLY)
	    mode[ix++] = '+';
    }
#endif
    else {
	if (result == O_WRONLY)
	    mode[ix++] = 'w';
	else {
	    mode[ix++] = 'r';
	    mode[ix++] = '+';
	}
    }
#if O_BINARY != 0
    /* Unless O_BINARY is different from zero, bit-and:ing
     * with it won't do much good. */
    if (rawmode & O_BINARY)
	mode[ix++] = 'b';
# endif
    mode[ix] = '\0';
    return ptype;
}

#ifndef PERLIO_LAYERS
int
PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode, const char *names)
{
    if (!names || !*names
        || strEQ(names, ":crlf")
        || strEQ(names, ":raw")
        || strEQ(names, ":bytes")
       ) {
	return 0;
    }
    Perl_croak(aTHX_ "Cannot apply \"%s\" in non-PerlIO perl", names);
    /*
     * NOTREACHED
     */
    return -1;
}

void
PerlIO_destruct(pTHX)
{
}

int
PerlIO_binmode(pTHX_ PerlIO *fp, int iotype, int mode, const char *names)
{
    return perlsio_binmode(fp, iotype, mode);
}

PerlIO *
PerlIO_fdupopen(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
{
#if defined(PERL_MICRO) || defined(__SYMBIAN32__)
    return NULL;
#else
#ifdef PERL_IMPLICIT_SYS
    return PerlSIO_fdupopen(f);
#else
#ifdef WIN32
    return win32_fdupopen(f);
#else
    if (f) {
	const int fd = PerlLIO_dup(PerlIO_fileno(f));
	if (fd >= 0) {
	    char mode[8];
#ifdef DJGPP
	    const int omode = djgpp_get_stream_mode(f);
#else
	    const int omode = fcntl(fd, F_GETFL);
#endif
	    PerlIO_intmode2str(omode,mode,NULL);
	    /* the r+ is a hack */
	    return PerlIO_fdopen(fd, mode);
	}
	return NULL;
    }
    else {
	SETERRNO(EBADF, SS_IVCHAN);
    }
#endif
    return NULL;
#endif
#endif
}


/*
 * De-mux PerlIO_openn() into fdopen, freopen and fopen type entries
 */

PerlIO *
PerlIO_openn(pTHX_ const char *layers, const char *mode, int fd,
	     int imode, int perm, PerlIO *old, int narg, SV **args)
{
    if (narg) {
	if (narg > 1) {
	    Perl_croak(aTHX_ "More than one argument to open");
	}
	if (*args == &PL_sv_undef)
	    return PerlIO_tmpfile();
	else {
            STRLEN len;
	    const char *name = SvPV_const(*args, len);
            if (!IS_SAFE_PATHNAME(name, len, "open"))
                return NULL;

	    if (*mode == IoTYPE_NUMERIC) {
		fd = PerlLIO_open3(name, imode, perm);
		if (fd >= 0)
		    return PerlIO_fdopen(fd, mode + 1);
	    }
	    else if (old) {
		return PerlIO_reopen(name, mode, old);
	    }
	    else {
		return PerlIO_open(name, mode);
	    }
	}
    }
    else {
	return PerlIO_fdopen(fd, (char *) mode);
    }
    return NULL;
}

XS(XS_PerlIO__Layer__find); /* prototype to pass -Wmissing-prototypes */
XS(XS_PerlIO__Layer__find)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage class->find(name[,load])");
    else {
	const char * const name = SvPV_nolen_const(ST(1));
	ST(0) = (strEQ(name, "crlf")
		 || strEQ(name, "raw")) ? &PL_sv_yes : &PL_sv_undef;
	XSRETURN(1);
    }
}


void
Perl_boot_core_PerlIO(pTHX)
{
    newXS("PerlIO::Layer::find", XS_PerlIO__Layer__find, __FILE__);
}

#endif


/*======================================================================================*/
/*
 * Implement all the PerlIO interface ourselves.
 */

#include "perliol.h"

void
PerlIO_debug(const char *fmt, ...)
{
    va_list ap;
    dSYS;
    va_start(ap, fmt);

    if (!DEBUG_i_TEST)
        return;

    if (!PL_perlio_debug_fd) {
	if (!TAINTING_get &&
	    PerlProc_getuid() == PerlProc_geteuid() &&
	    PerlProc_getgid() == PerlProc_getegid()) {
	    const char * const s = PerlEnv_getenv("PERLIO_DEBUG");
	    if (s && *s)
		PL_perlio_debug_fd
		    = PerlLIO_open3(s, O_WRONLY | O_CREAT | O_APPEND, 0666);
	    else
		PL_perlio_debug_fd = PerlLIO_dup(2); /* stderr */
	} else {
	    /* tainting or set*id, so ignore the environment and send the
               debug output to stderr, like other -D switches.  */
	    PL_perlio_debug_fd = PerlLIO_dup(2); /* stderr */
	}
    }
    if (PL_perlio_debug_fd > 0) {
#ifdef USE_ITHREADS
	const char * const s = CopFILE(PL_curcop);
	/* Use fixed buffer as sv_catpvf etc. needs SVs */
	char buffer[1024];
	const STRLEN len1 = my_snprintf(buffer, sizeof(buffer), "%.40s:%" IVdf " ", s ? s : "(none)", (IV) CopLINE(PL_curcop));
	const STRLEN len2 = my_vsnprintf(buffer + len1, sizeof(buffer) - len1, fmt, ap);
	PERL_UNUSED_RESULT(PerlLIO_write(PL_perlio_debug_fd, buffer, len1 + len2));
#else
	const char *s = CopFILE(PL_curcop);
	STRLEN len;
	SV * const sv = Perl_newSVpvf(aTHX_ "%s:%" IVdf " ", s ? s : "(none)",
				      (IV) CopLINE(PL_curcop));
	Perl_sv_vcatpvf(aTHX_ sv, fmt, &ap);

	s = SvPV_const(sv, len);
	PERL_UNUSED_RESULT(PerlLIO_write(PL_perlio_debug_fd, s, len));
	SvREFCNT_dec(sv);
#endif
    }
    va_end(ap);
}

/*--------------------------------------------------------------------------------------*/

/*
 * Inner level routines
 */

/* check that the head field of each layer points back to the head */

#ifdef DEBUGGING
#  define VERIFY_HEAD(f) PerlIO_verify_head(aTHX_ f)
static void
PerlIO_verify_head(pTHX_ PerlIO *f)
{
    PerlIOl *head, *p;
    int seen = 0;
#ifndef PERL_IMPLICIT_SYS
    PERL_UNUSED_CONTEXT;
#endif
    if (!PerlIOValid(f))
	return;
    p = head = PerlIOBase(f)->head;
    assert(p);
    do {
	assert(p->head == head);
	if (p == (PerlIOl*)f)
	    seen = 1;
	p = p->next;
    } while (p);
    assert(seen);
}
#else
#  define VERIFY_HEAD(f)
#endif


/*
 * Table of pointers to the PerlIO structs (malloc'ed)
 */
#define PERLIO_TABLE_SIZE 64

static void
PerlIO_init_table(pTHX)
{
    if (PL_perlio)
	return;
    Newxz(PL_perlio, PERLIO_TABLE_SIZE, PerlIOl);
}



PerlIO *
PerlIO_allocate(pTHX)
{
    /*
     * Find a free slot in the table, allocating new table as necessary
     */
    PerlIOl **last;
    PerlIOl *f;
    last = &PL_perlio;
    while ((f = *last)) {
	int i;
	last = (PerlIOl **) (f);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    if (!((++f)->next)) {
		goto good_exit;
	    }
	}
    }
    Newxz(f,PERLIO_TABLE_SIZE,PerlIOl);
    if (!f) {
	return NULL;
    }
    *last = (PerlIOl*) f++;

    good_exit:
    f->flags = 0; /* lockcnt */
    f->tab = NULL;
    f->head = f;
    return (PerlIO*) f;
}

#undef PerlIO_fdupopen
PerlIO *
PerlIO_fdupopen(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
{
    if (PerlIOValid(f)) {
	const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
	DEBUG_i( PerlIO_debug("fdupopen f=%p param=%p\n",(void*)f,(void*)param) );
	if (tab && tab->Dup)
	     return (*tab->Dup)(aTHX_ PerlIO_allocate(aTHX), f, param, flags);
	else {
	     return PerlIOBase_dup(aTHX_ PerlIO_allocate(aTHX), f, param, flags);
	}
    }
    else
	 SETERRNO(EBADF, SS_IVCHAN);

    return NULL;
}

void
PerlIO_cleantable(pTHX_ PerlIOl **tablep)
{
    PerlIOl * const table = *tablep;
    if (table) {
	int i;
	PerlIO_cleantable(aTHX_(PerlIOl **) & (table[0]));
	for (i = PERLIO_TABLE_SIZE - 1; i > 0; i--) {
	    PerlIOl * const f = table + i;
	    if (f->next) {
		PerlIO_close(&(f->next));
	    }
	}
	Safefree(table);
	*tablep = NULL;
    }
}


PerlIO_list_t *
PerlIO_list_alloc(pTHX)
{
    PerlIO_list_t *list;
    PERL_UNUSED_CONTEXT;
    Newxz(list, 1, PerlIO_list_t);
    list->refcnt = 1;
    return list;
}

void
PerlIO_list_free(pTHX_ PerlIO_list_t *list)
{
    if (list) {
	if (--list->refcnt == 0) {
	    if (list->array) {
		IV i;
		for (i = 0; i < list->cur; i++)
		    SvREFCNT_dec(list->array[i].arg);
		Safefree(list->array);
	    }
	    Safefree(list);
	}
    }
}

void
PerlIO_list_push(pTHX_ PerlIO_list_t *list, PerlIO_funcs *funcs, SV *arg)
{
    PerlIO_pair_t *p;
    PERL_UNUSED_CONTEXT;

    if (list->cur >= list->len) {
	list->len += 8;
	if (list->array)
	    Renew(list->array, list->len, PerlIO_pair_t);
	else
	    Newx(list->array, list->len, PerlIO_pair_t);
    }
    p = &(list->array[list->cur++]);
    p->funcs = funcs;
    if ((p->arg = arg)) {
	SvREFCNT_inc_simple_void_NN(arg);
    }
}

PerlIO_list_t *
PerlIO_clone_list(pTHX_ PerlIO_list_t *proto, CLONE_PARAMS *param)
{
    PerlIO_list_t *list = NULL;
    if (proto) {
	int i;
	list = PerlIO_list_alloc(aTHX);
	for (i=0; i < proto->cur; i++) {
	    SV *arg = proto->array[i].arg;
#ifdef USE_ITHREADS
	    if (arg && param)
		arg = sv_dup(arg, param);
#else
	    PERL_UNUSED_ARG(param);
#endif
	    PerlIO_list_push(aTHX_ list, proto->array[i].funcs, arg);
	}
    }
    return list;
}

void
PerlIO_clone(pTHX_ PerlInterpreter *proto, CLONE_PARAMS *param)
{
#ifdef USE_ITHREADS
    PerlIOl **table = &proto->Iperlio;
    PerlIOl *f;
    PL_perlio = NULL;
    PL_known_layers = PerlIO_clone_list(aTHX_ proto->Iknown_layers, param);
    PL_def_layerlist = PerlIO_clone_list(aTHX_ proto->Idef_layerlist, param);
    PerlIO_init_table(aTHX);
    DEBUG_i( PerlIO_debug("Clone %p from %p\n",(void*)aTHX,(void*)proto) );
    while ((f = *table)) {
	    int i;
	    table = (PerlIOl **) (f++);
	    for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
		if (f->next) {
		    (void) fp_dup(&(f->next), 0, param);
		}
		f++;
	    }
	}
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(proto);
    PERL_UNUSED_ARG(param);
#endif
}

void
PerlIO_destruct(pTHX)
{
    PerlIOl **table = &PL_perlio;
    PerlIOl *f;
#ifdef USE_ITHREADS
    DEBUG_i( PerlIO_debug("Destruct %p\n",(void*)aTHX) );
#endif
    while ((f = *table)) {
	int i;
	table = (PerlIOl **) (f++);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    PerlIO *x = &(f->next);
	    const PerlIOl *l;
	    while ((l = *x)) {
		if (l->tab && l->tab->kind & PERLIO_K_DESTRUCT) {
		    DEBUG_i( PerlIO_debug("Destruct popping %s\n", l->tab->name) );
		    PerlIO_flush(x);
		    PerlIO_pop(aTHX_ x);
		}
		else {
		    x = PerlIONext(x);
		}
	    }
	    f++;
	}
    }
}

void
PerlIO_pop(pTHX_ PerlIO *f)
{
    const PerlIOl *l = *f;
    VERIFY_HEAD(f);
    if (l) {
	DEBUG_i( PerlIO_debug("PerlIO_pop f=%p %s\n", (void*)f,
                              l->tab ? l->tab->name : "(Null)") );
	if (l->tab && l->tab->Popped) {
	    /*
	     * If popped returns non-zero do not free its layer structure
	     * it has either done so itself, or it is shared and still in
	     * use
	     */
	    if ((*l->tab->Popped) (aTHX_ f) != 0)
		return;
	}
	if (PerlIO_lockcnt(f)) {
	    /* we're in use; defer freeing the structure */
	    PerlIOBase(f)->flags = PERLIO_F_CLEARED;
	    PerlIOBase(f)->tab = NULL;
	}
	else {
	    *f = l->next;
	    Safefree(l);
	}

    }
}

/* Return as an array the stack of layers on a filehandle.  Note that
 * the stack is returned top-first in the array, and there are three
 * times as many array elements as there are layers in the stack: the
 * first element of a layer triplet is the name, the second one is the
 * arguments, and the third one is the flags. */

AV *
PerlIO_get_layers(pTHX_ PerlIO *f)
{
    AV * const av = newAV();

    if (PerlIOValid(f)) {
	PerlIOl *l = PerlIOBase(f);

	while (l) {
	    /* There is some collusion in the implementation of
	       XS_PerlIO_get_layers - it knows that name and flags are
	       generated as fresh SVs here, and takes advantage of that to
	       "copy" them by taking a reference. If it changes here, it needs
	       to change there too.  */
	    SV * const name = l->tab && l->tab->name ?
	    newSVpv(l->tab->name, 0) : &PL_sv_undef;
	    SV * const arg = l->tab && l->tab->Getarg ?
	    (*l->tab->Getarg)(aTHX_ &l, 0, 0) : &PL_sv_undef;
	    av_push(av, name);
	    av_push(av, arg);
	    av_push(av, newSViv((IV)l->flags));
	    l = l->next;
	}
    }

    return av;
}

/*--------------------------------------------------------------------------------------*/
/*
 * XS Interface for perl code
 */

PerlIO_funcs *
PerlIO_find_layer(pTHX_ const char *name, STRLEN len, int load)
{

    IV i;
    if ((SSize_t) len <= 0)
	len = strlen(name);
    for (i = 0; i < PL_known_layers->cur; i++) {
	PerlIO_funcs * const f = PL_known_layers->array[i].funcs;
        const STRLEN this_len = strlen(f->name);
        if (this_len == len && memEQ(f->name, name, len)) {
	    DEBUG_i( PerlIO_debug("%.*s => %p\n", (int) len, name, (void*)f) );
	    return f;
	}
    }
    if (load && PL_subname && PL_def_layerlist
	&& PL_def_layerlist->cur >= 2) {
	if (PL_in_load_module) {
	    Perl_croak(aTHX_ "Recursive call to Perl_load_module in PerlIO_find_layer");
	    return NULL;
	} else {
	    SV * const pkgsv = newSVpvs("PerlIO");
	    SV * const layer = newSVpvn(name, len);
	    CV * const cv    = get_cvs("PerlIO::Layer::NoWarnings", 0);
	    ENTER;
	    SAVEBOOL(PL_in_load_module);
	    if (cv) {
		SAVEGENERICSV(PL_warnhook);
		PL_warnhook = MUTABLE_SV((SvREFCNT_inc_simple_NN(cv)));
	    }
	    PL_in_load_module = TRUE;
	    /*
	     * The two SVs are magically freed by load_module
	     */
	    Perl_load_module(aTHX_ 0, pkgsv, NULL, layer, NULL);
	    LEAVE;
	    return PerlIO_find_layer(aTHX_ name, len, 0);
	}
    }
    DEBUG_i( PerlIO_debug("Cannot find %.*s\n", (int) len, name) );
    return NULL;
}

#ifdef USE_ATTRIBUTES_FOR_PERLIO

static int
perlio_mg_set(pTHX_ SV *sv, MAGIC *mg)
{
    if (SvROK(sv)) {
	IO * const io = GvIOn(MUTABLE_GV(SvRV(sv)));
	PerlIO * const ifp = IoIFP(io);
	PerlIO * const ofp = IoOFP(io);
	Perl_warn(aTHX_ "set %" SVf " %p %p %p",
		  SVfARG(sv), (void*)io, (void*)ifp, (void*)ofp);
    }
    return 0;
}

static int
perlio_mg_get(pTHX_ SV *sv, MAGIC *mg)
{
    if (SvROK(sv)) {
	IO * const io = GvIOn(MUTABLE_GV(SvRV(sv)));
	PerlIO * const ifp = IoIFP(io);
	PerlIO * const ofp = IoOFP(io);
	Perl_warn(aTHX_ "get %" SVf " %p %p %p",
		  SVfARG(sv), (void*)io, (void*)ifp, (void*)ofp);
    }
    return 0;
}

static int
perlio_mg_clear(pTHX_ SV *sv, MAGIC *mg)
{
    Perl_warn(aTHX_ "clear %" SVf, SVfARG(sv));
    return 0;
}

static int
perlio_mg_free(pTHX_ SV *sv, MAGIC *mg)
{
    Perl_warn(aTHX_ "free %" SVf, SVfARG(sv));
    return 0;
}

MGVTBL perlio_vtab = {
    perlio_mg_get,
    perlio_mg_set,
    NULL,                       /* len */
    perlio_mg_clear,
    perlio_mg_free
};

XS(XS_io_MODIFY_SCALAR_ATTRIBUTES); /* prototype to pass -Wmissing-prototypes */
XS(XS_io_MODIFY_SCALAR_ATTRIBUTES)
{
    dXSARGS;
    SV * const sv = SvRV(ST(1));
    AV * const av = newAV();
    MAGIC *mg;
    int count = 0;
    int i;
    sv_magic(sv, MUTABLE_SV(av), PERL_MAGIC_ext, NULL, 0);
    SvRMAGICAL_off(sv);
    mg = mg_find(sv, PERL_MAGIC_ext);
    mg->mg_virtual = &perlio_vtab;
    mg_magical(sv);
    Perl_warn(aTHX_ "attrib %" SVf, SVfARG(sv));
    for (i = 2; i < items; i++) {
	STRLEN len;
	const char * const name = SvPV_const(ST(i), len);
	SV * const layer = PerlIO_find_layer(aTHX_ name, len, 1);
	if (layer) {
	    av_push(av, SvREFCNT_inc_simple_NN(layer));
	}
	else {
	    ST(count) = ST(i);
	    count++;
	}
    }
    SvREFCNT_dec(av);
    XSRETURN(count);
}

#endif                          /* USE_ATTRIBUTES_FOR_PERLIO */

SV *
PerlIO_tab_sv(pTHX_ PerlIO_funcs *tab)
{
    HV * const stash = gv_stashpvs("PerlIO::Layer", GV_ADD);
    SV * const sv = sv_bless(newRV_noinc(newSViv(PTR2IV(tab))), stash);
    return sv;
}

XS(XS_PerlIO__Layer__NoWarnings); /* prototype to pass -Wmissing-prototypes */
XS(XS_PerlIO__Layer__NoWarnings)
{
    /* This is used as a %SIG{__WARN__} handler to suppress warnings
       during loading of layers.
     */
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    DEBUG_i(
        if (items)
            PerlIO_debug("warning:%s\n",SvPV_nolen_const(ST(0))) );
    XSRETURN(0);
}

XS(XS_PerlIO__Layer__find); /* prototype to pass -Wmissing-prototypes */
XS(XS_PerlIO__Layer__find)
{
    dXSARGS;
    PERL_UNUSED_ARG(cv);
    if (items < 2)
	Perl_croak(aTHX_ "Usage class->find(name[,load])");
    else {
	STRLEN len;
	const char * const name = SvPV_const(ST(1), len);
	const bool load = (items > 2) ? SvTRUE_NN(ST(2)) : 0;
	PerlIO_funcs * const layer = PerlIO_find_layer(aTHX_ name, len, load);
	ST(0) =
	    (layer) ? sv_2mortal(PerlIO_tab_sv(aTHX_ layer)) :
	    &PL_sv_undef;
	XSRETURN(1);
    }
}

void
PerlIO_define_layer(pTHX_ PerlIO_funcs *tab)
{
    if (!PL_known_layers)
	PL_known_layers = PerlIO_list_alloc(aTHX);
    PerlIO_list_push(aTHX_ PL_known_layers, tab, NULL);
    DEBUG_i( PerlIO_debug("define %s %p\n", tab->name, (void*)tab) );
}

int
PerlIO_parse_layers(pTHX_ PerlIO_list_t *av, const char *names)
{
    if (names) {
	const char *s = names;
	while (*s) {
	    while (isSPACE(*s) || *s == ':')
		s++;
	    if (*s) {
		STRLEN llen = 0;
		const char *e = s;
		const char *as = NULL;
		STRLEN alen = 0;
		if (!isIDFIRST(*s)) {
		    /*
		     * Message is consistent with how attribute lists are
		     * passed. Even though this means "foo : : bar" is
		     * seen as an invalid separator character.
		     */
		    const char q = ((*s == '\'') ? '"' : '\'');
		    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER),
				   "Invalid separator character %c%c%c in PerlIO layer specification %s",
				   q, *s, q, s);
		    SETERRNO(EINVAL, LIB_INVARG);
		    return -1;
		}
		do {
		    e++;
		} while (isWORDCHAR(*e));
		llen = e - s;
		if (*e == '(') {
		    int nesting = 1;
		    as = ++e;
		    while (nesting) {
			switch (*e++) {
			case ')':
			    if (--nesting == 0)
				alen = (e - 1) - as;
			    break;
			case '(':
			    ++nesting;
			    break;
			case '\\':
			    /*
			     * It's a nul terminated string, not allowed
			     * to \ the terminating null. Anything other
			     * character is passed over.
			     */
			    if (*e++) {
				break;
			    }
			    /*
			     * Drop through
			     */
			case '\0':
			    e--;
			    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER),
					   "Argument list not closed for PerlIO layer \"%.*s\"",
					   (int) (e - s), s);
			    return -1;
			default:
			    /*
			     * boring.
			     */
			    break;
			}
		    }
		}
		if (e > s) {
		    PerlIO_funcs * const layer =
			PerlIO_find_layer(aTHX_ s, llen, 1);
		    if (layer) {
			SV *arg = NULL;
			if (as)
			    arg = newSVpvn(as, alen);
			PerlIO_list_push(aTHX_ av, layer,
					 (arg) ? arg : &PL_sv_undef);
			SvREFCNT_dec(arg);
		    }
		    else {
			Perl_ck_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"%.*s\"",
				       (int) llen, s);
			return -1;
		    }
		}
		s = e;
	    }
	}
    }
    return 0;
}

void
PerlIO_default_buffer(pTHX_ PerlIO_list_t *av)
{
    PERLIO_FUNCS_DECL(*tab) = &PerlIO_perlio;
#ifdef PERLIO_USING_CRLF
    tab = &PerlIO_crlf;
#else
    if (PerlIO_stdio.Set_ptrcnt)
	tab = &PerlIO_stdio;
#endif
    DEBUG_i( PerlIO_debug("Pushing %s\n", tab->name) );
    PerlIO_list_push(aTHX_ av, (PerlIO_funcs *)tab, &PL_sv_undef);
}

SV *
PerlIO_arg_fetch(PerlIO_list_t *av, IV n)
{
    return av->array[n].arg;
}

PerlIO_funcs *
PerlIO_layer_fetch(pTHX_ PerlIO_list_t *av, IV n, PerlIO_funcs *def)
{
    if (n >= 0 && n < av->cur) {
	DEBUG_i( PerlIO_debug("Layer %" IVdf " is %s\n", n,
                              av->array[n].funcs->name) );
	return av->array[n].funcs;
    }
    if (!def)
	Perl_croak(aTHX_ "panic: PerlIO layer array corrupt");
    return def;
}

IV
PerlIOPop_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
    PERL_UNUSED_ARG(tab);
    if (PerlIOValid(f)) {
	PerlIO_flush(f);
	PerlIO_pop(aTHX_ f);
	return 0;
    }
    return -1;
}

PERLIO_FUNCS_DECL(PerlIO_remove) = {
    sizeof(PerlIO_funcs),
    "pop",
    0,
    PERLIO_K_DUMMY | PERLIO_K_UTF8,
    PerlIOPop_pushed,
    NULL,
    PerlIOBase_open,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PerlIO_list_t *
PerlIO_default_layers(pTHX)
{
    if (!PL_def_layerlist) {
	const char * const s = TAINTING_get ? NULL : PerlEnv_getenv("PERLIO");
	PERLIO_FUNCS_DECL(*osLayer) = &PerlIO_unix;
	PL_def_layerlist = PerlIO_list_alloc(aTHX);
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_unix));
#if defined(WIN32)
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_win32));
#if 0
	osLayer = &PerlIO_win32;
#endif
#endif
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_raw));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_perlio));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_stdio));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_crlf));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_utf8));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_remove));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_byte));
	PerlIO_list_push(aTHX_ PL_def_layerlist, (PerlIO_funcs *)osLayer,
                         &PL_sv_undef);
	if (s) {
	    PerlIO_parse_layers(aTHX_ PL_def_layerlist, s);
	}
	else {
	    PerlIO_default_buffer(aTHX_ PL_def_layerlist);
	}
    }
    if (PL_def_layerlist->cur < 2) {
	PerlIO_default_buffer(aTHX_ PL_def_layerlist);
    }
    return PL_def_layerlist;
}

void
Perl_boot_core_PerlIO(pTHX)
{
#ifdef USE_ATTRIBUTES_FOR_PERLIO
    newXS("io::MODIFY_SCALAR_ATTRIBUTES", XS_io_MODIFY_SCALAR_ATTRIBUTES,
	  __FILE__);
#endif
    newXS("PerlIO::Layer::find", XS_PerlIO__Layer__find, __FILE__);
    newXS("PerlIO::Layer::NoWarnings", XS_PerlIO__Layer__NoWarnings, __FILE__);
}

PerlIO_funcs *
PerlIO_default_layer(pTHX_ I32 n)
{
    PerlIO_list_t * const av = PerlIO_default_layers(aTHX);
    if (n < 0)
	n += av->cur;
    return PerlIO_layer_fetch(aTHX_ av, n, PERLIO_FUNCS_CAST(&PerlIO_stdio));
}

#define PerlIO_default_top() PerlIO_default_layer(aTHX_ -1)
#define PerlIO_default_btm() PerlIO_default_layer(aTHX_ 0)

void
PerlIO_stdstreams(pTHX)
{
    if (!PL_perlio) {
	PerlIO_init_table(aTHX);
	PerlIO_fdopen(0, "Ir" PERLIO_STDTEXT);
	PerlIO_fdopen(1, "Iw" PERLIO_STDTEXT);
	PerlIO_fdopen(2, "Iw" PERLIO_STDTEXT);
    }
}

PerlIO *
PerlIO_push(pTHX_ PerlIO *f, PERLIO_FUNCS_DECL(*tab), const char *mode, SV *arg)
{
    VERIFY_HEAD(f);
    if (tab->fsize != sizeof(PerlIO_funcs)) {
	Perl_croak( aTHX_
	    "%s (%"UVuf") does not match %s (%"UVuf")",
	    "PerlIO layer function table size", (UV)tab->fsize,
	    "size expected by this perl", (UV)sizeof(PerlIO_funcs) );
    }
    if (tab->size) {
	PerlIOl *l;
	if (tab->size < sizeof(PerlIOl)) {
	    Perl_croak( aTHX_
		"%s (%"UVuf") smaller than %s (%"UVuf")",
		"PerlIO layer instance size", (UV)tab->size,
		"size expected by this perl", (UV)sizeof(PerlIOl) );
	}
	/* Real layer with a data area */
	if (f) {
	    char *temp;
	    Newxz(temp, tab->size, char);
	    l = (PerlIOl*)temp;
	    if (l) {
		l->next = *f;
		l->tab = (PerlIO_funcs*) tab;
		l->head = ((PerlIOl*)f)->head;
		*f = l;
		DEBUG_i( PerlIO_debug("PerlIO_push f=%p %s %s %p\n",
                                      (void*)f, tab->name,
                                      (mode) ? mode : "(Null)", (void*)arg) );
		if (*l->tab->Pushed &&
		    (*l->tab->Pushed)
		      (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
		    PerlIO_pop(aTHX_ f);
		    return NULL;
		}
	    }
	    else
		return NULL;
	}
    }
    else if (f) {
	/* Pseudo-layer where push does its own stack adjust */
	DEBUG_i( PerlIO_debug("PerlIO_push f=%p %s %s %p\n", (void*)f, tab->name,
                              (mode) ? mode : "(Null)", (void*)arg) );
	if (tab->Pushed &&
	    (*tab->Pushed) (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
	     return NULL;
	}
    }
    return f;
}

PerlIO *
PerlIOBase_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *old, int narg, SV **args)
{
    PerlIO_funcs * const tab = PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIO_default_layer(aTHX_ 0));
    if (tab && tab->Open) {
	PerlIO* ret = (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm, old, narg, args);
	if (ret && PerlIO_push(aTHX_ ret, self, mode, PerlIOArg) == NULL) {
	    PerlIO_close(ret);
	    return NULL;
	}
	return ret;
    }
    SETERRNO(EINVAL, LIB_INVARG);
    return NULL;
}

IV
PerlIOBase_binmode(pTHX_ PerlIO *f)
{
   if (PerlIOValid(f)) {
	/* Is layer suitable for raw stream ? */
	if (PerlIOBase(f)->tab && PerlIOBase(f)->tab->kind & PERLIO_K_RAW) {
	    /* Yes - turn off UTF-8-ness, to undo UTF-8 locale effects */
	    PerlIOBase(f)->flags &= ~PERLIO_F_UTF8;
	}
	else {
	    /* Not suitable - pop it */
	    PerlIO_pop(aTHX_ f);
	}
	return 0;
   }
   return -1;
}

IV
PerlIORaw_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
    PERL_UNUSED_ARG(tab);

    if (PerlIOValid(f)) {
	PerlIO *t;
	const PerlIOl *l;
	PerlIO_flush(f);
	/*
	 * Strip all layers that are not suitable for a raw stream
	 */
	t = f;
	while (t && (l = *t)) {
	    if (l->tab && l->tab->Binmode) {
		/* Has a handler - normal case */
		if ((*l->tab->Binmode)(aTHX_ t) == 0) {
		    if (*t == l) {
			/* Layer still there - move down a layer */
			t = PerlIONext(t);
		    }
		}
		else {
		    return -1;
		}
	    }
	    else {
		/* No handler - pop it */
		PerlIO_pop(aTHX_ t);
	    }
	}
	if (PerlIOValid(f)) {
	    DEBUG_i( PerlIO_debug(":raw f=%p :%s\n", (void*)f,
                         PerlIOBase(f)->tab ? PerlIOBase(f)->tab->name : "(Null)") );
	    return 0;
	}
    }
    return -1;
}

int
PerlIO_apply_layera(pTHX_ PerlIO *f, const char *mode,
		    PerlIO_list_t *layers, IV n, IV max)
{
    int code = 0;
    while (n < max) {
	PerlIO_funcs * const tab = PerlIO_layer_fetch(aTHX_ layers, n, NULL);
	if (tab) {
	    if (!PerlIO_push(aTHX_ f, tab, mode, PerlIOArg)) {
		code = -1;
		break;
	    }
	}
	n++;
    }
    return code;
}

int
PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode, const char *names)
{
    int code = 0;
    ENTER;
    save_scalar(PL_errgv);
    if (f && names) {
	PerlIO_list_t * const layers = PerlIO_list_alloc(aTHX);
	code = PerlIO_parse_layers(aTHX_ layers, names);
	if (code == 0) {
	    code = PerlIO_apply_layera(aTHX_ f, mode, layers, 0, layers->cur);
	}
	PerlIO_list_free(aTHX_ layers);
    }
    LEAVE;
    return code;
}


/*--------------------------------------------------------------------------------------*/
/*
 * Given the abstraction above the public API functions
 */

int
PerlIO_binmode(pTHX_ PerlIO *f, int iotype, int mode, const char *names)
{
    DEBUG_i(
        PerlIO_debug("PerlIO_binmode f=%p %s %c %x %s\n", (void*)f,
                     (PerlIOBase(f) && PerlIOBase(f)->tab) ?
                     PerlIOBase(f)->tab->name : "(Null)",
                     iotype, mode, (names) ? names : "(Null)") );

    if (names) {
	/* Do not flush etc. if (e.g.) switching encodings.
	   if a pushed layer knows it needs to flush lower layers
	   (for example :unix which is never going to call them)
	   it can do the flush when it is pushed.
	 */
	return PerlIO_apply_layers(aTHX_ f, NULL, names) == 0 ? TRUE : FALSE;
    }
    else {
	/* Fake 5.6 legacy of using this call to turn ON O_TEXT */
#ifdef PERLIO_USING_CRLF
	/* Legacy binmode only has meaning if O_TEXT has a value distinct from
	   O_BINARY so we can look for it in mode.
	 */
	if (!(mode & O_BINARY)) {
	    /* Text mode */
	    /* FIXME?: Looking down the layer stack seems wrong,
	       but is a way of reaching past (say) an encoding layer
	       to flip CRLF-ness of the layer(s) below
	     */
	    while (*f) {
		/* Perhaps we should turn on bottom-most aware layer
		   e.g. Ilya's idea that UNIX TTY could serve
		 */
		if (PerlIOBase(f)->tab &&
		    PerlIOBase(f)->tab->kind & PERLIO_K_CANCRLF)
		{
		    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF)) {
			/* Not in text mode - flush any pending stuff and flip it */
			PerlIO_flush(f);
			PerlIOBase(f)->flags |= PERLIO_F_CRLF;
		    }
		    /* Only need to turn it on in one layer so we are done */
		    return TRUE;
		}
		f = PerlIONext(f);
	    }
	    /* Not finding a CRLF aware layer presumably means we are binary
	       which is not what was requested - so we failed
	       We _could_ push :crlf layer but so could caller
	     */
	    return FALSE;
	}
#endif
	/* Legacy binmode is now _defined_ as being equivalent to pushing :raw
	   So code that used to be here is now in PerlIORaw_pushed().
	 */
	return PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_raw), NULL, NULL) ? TRUE : FALSE;
    }
}

int
PerlIO__close(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs * const tab = PerlIOBase(f)->tab;
	if (tab && tab->Close)
	    return (*tab->Close)(aTHX_ f);
	else
	    return PerlIOBase_close(aTHX_ f);
    }
    else {
	SETERRNO(EBADF, SS_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_close(pTHX_ PerlIO *f)
{
    const int code = PerlIO__close(aTHX_ f);
    while (PerlIOValid(f)) {
	PerlIO_pop(aTHX_ f);
	if (PerlIO_lockcnt(f))
	    /* we're in use; the 'pop' deferred freeing the structure */
	    f = PerlIONext(f);
    }
    return code;
}

int
Perl_PerlIO_fileno(pTHX_ PerlIO *f)
{
    Perl_PerlIO_or_Base(f, Fileno, fileno, -1, (aTHX_ f));
}


static PerlIO_funcs *
PerlIO_layer_from_ref(pTHX_ SV *sv)
{
    /*
     * For any scalar type load the handler which is bundled with perl
     */
    if (SvTYPE(sv) < SVt_PVAV && (!isGV_with_GP(sv) || SvFAKE(sv))) {
	PerlIO_funcs *f = PerlIO_find_layer(aTHX_ STR_WITH_LEN("scalar"), 1);
	/* This isn't supposed to happen, since PerlIO::scalar is core,
	 * but could happen anyway in smaller installs or with PAR */
	if (!f)
	    /* diag_listed_as: Unknown PerlIO layer "%s" */
	    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"scalar\"");
	return f;
    }

    /*
     * For other types allow if layer is known but don't try and load it
     */
    switch (SvTYPE(sv)) {
    case SVt_PVAV:
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Array"), 0);
    case SVt_PVHV:
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Hash"), 0);
    case SVt_PVCV:
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Code"), 0);
    case SVt_PVGV:
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Glob"), 0);
    default:
	return NULL;
    }
}

PerlIO_list_t *
PerlIO_resolve_layers(pTHX_ const char *layers,
		      const char *mode, int narg, SV **args)
{
    PerlIO_list_t *def = PerlIO_default_layers(aTHX);
    int incdef = 1;
    if (!PL_perlio)
	PerlIO_stdstreams(aTHX);
    if (narg) {
	SV * const arg = *args;
	/*
	 * If it is a reference but not an object see if we have a handler
	 * for it
	 */
	if (SvROK(arg) && !SvOBJECT(SvRV(arg))) {
	    PerlIO_funcs * const handler = PerlIO_layer_from_ref(aTHX_ SvRV(arg));
	    if (handler) {
		def = PerlIO_list_alloc(aTHX);
		PerlIO_list_push(aTHX_ def, handler, &PL_sv_undef);
		incdef = 0;
	    }
	    /*
	     * Don't fail if handler cannot be found :via(...) etc. may do
	     * something sensible else we will just stringfy and open
	     * resulting string.
	     */
	}
    }
    if (!layers || !*layers)
	layers = Perl_PerlIO_context_layers(aTHX_ mode);
    if (layers && *layers) {
	PerlIO_list_t *av;
	if (incdef) {
	    av = PerlIO_clone_list(aTHX_ def, NULL);
	}
	else {
	    av = def;
	}
	if (PerlIO_parse_layers(aTHX_ av, layers) == 0) {
	     return av;
	}
	else {
	    PerlIO_list_free(aTHX_ av);
	    return NULL;
	}
    }
    else {
	if (incdef)
	    def->refcnt++;
	return def;
    }
}

PerlIO *
PerlIO_openn(pTHX_ const char *layers, const char *mode, int fd,
	     int imode, int perm, PerlIO *f, int narg, SV **args)
{
    if (!f && narg == 1 && *args == &PL_sv_undef) {
	if ((f = PerlIO_tmpfile())) {
	    if (!layers || !*layers)
		layers = Perl_PerlIO_context_layers(aTHX_ mode);
	    if (layers && *layers)
		PerlIO_apply_layers(aTHX_ f, mode, layers);
	}
    }
    else {
	PerlIO_list_t *layera;
	IV n;
	PerlIO_funcs *tab = NULL;
	if (PerlIOValid(f)) {
	    /*
	     * This is "reopen" - it is not tested as perl does not use it
	     * yet
	     */
	    PerlIOl *l = *f;
	    layera = PerlIO_list_alloc(aTHX);
	    while (l) {
		SV *arg = NULL;
		if (l->tab && l->tab->Getarg)
		    arg = (*l->tab->Getarg) (aTHX_ &l, NULL, 0);
		PerlIO_list_push(aTHX_ layera, l->tab,
				 (arg) ? arg : &PL_sv_undef);
		SvREFCNT_dec(arg);
		l = *PerlIONext(&l);
	    }
	}
	else {
	    layera = PerlIO_resolve_layers(aTHX_ layers, mode, narg, args);
	    if (!layera) {
		return NULL;
	    }
	}
	/*
	 * Start at "top" of layer stack
	 */
	n = layera->cur - 1;
	while (n >= 0) {
	    PerlIO_funcs * const t = PerlIO_layer_fetch(aTHX_ layera, n, NULL);
	    if (t && t->Open) {
		tab = t;
		break;
	    }
	    n--;
	}
	if (tab) {
	    /*
	     * Found that layer 'n' can do opens - call it
	     */
	    if (narg > 1 && !(tab->kind & PERLIO_K_MULTIARG)) {
		Perl_croak(aTHX_ "More than one argument to open(,':%s')",tab->name);
	    }
	    DEBUG_i( PerlIO_debug("openn(%s,'%s','%s',%d,%x,%o,%p,%d,%p)\n",
                                  tab->name, layers ? layers : "(Null)", mode, fd,
                                  imode, perm, (void*)f, narg, (void*)args) );
	    if (tab->Open)
		 f = (*tab->Open) (aTHX_ tab, layera, n, mode, fd, imode, perm,
				   f, narg, args);
	    else {
		 SETERRNO(EINVAL, LIB_INVARG);
		 f = NULL;
	    }
	    if (f) {
		if (n + 1 < layera->cur) {
		    /*
		     * More layers above the one that we used to open -
		     * apply them now
		     */
		    if (PerlIO_apply_layera(aTHX_ f, mode, layera, n + 1, layera->cur) != 0) {
			/* If pushing layers fails close the file */
			PerlIO_close(f);
			f = NULL;
		    }
		}
	    }
	}
	PerlIO_list_free(aTHX_ layera);
    }
    return f;
}


SSize_t
Perl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
     PERL_ARGS_ASSERT_PERLIO_READ;

     Perl_PerlIO_or_Base(f, Read, read, -1, (aTHX_ f, vbuf, count));
}

SSize_t
Perl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
     PERL_ARGS_ASSERT_PERLIO_UNREAD;

     Perl_PerlIO_or_Base(f, Unread, unread, -1, (aTHX_ f, vbuf, count));
}

SSize_t
Perl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
     PERL_ARGS_ASSERT_PERLIO_WRITE;

     Perl_PerlIO_or_fail(f, Write, -1, (aTHX_ f, vbuf, count));
}

int
Perl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
     Perl_PerlIO_or_fail(f, Seek, -1, (aTHX_ f, offset, whence));
}

Off_t
Perl_PerlIO_tell(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_fail(f, Tell, -1, (aTHX_ f));
}

int
Perl_PerlIO_flush(pTHX_ PerlIO *f)
{
    if (f) {
	if (*f) {
	    const PerlIO_funcs *tab = PerlIOBase(f)->tab;

	    if (tab && tab->Flush)
		return (*tab->Flush) (aTHX_ f);
	    else
		 return 0; /* If no Flush defined, silently succeed. */
	}
	else {
	    DEBUG_i( PerlIO_debug("Cannot flush f=%p\n", (void*)f) );
	    SETERRNO(EBADF, SS_IVCHAN);
	    return -1;
	}
    }
    else {
	/*
	 * Is it good API design to do flush-all on NULL, a potentially
	 * erroneous input? Maybe some magical value (PerlIO*
	 * PERLIO_FLUSH_ALL = (PerlIO*)-1;)? Yes, stdio does similar
	 * things on fflush(NULL), but should we be bound by their design
	 * decisions? --jhi
	 */
	PerlIOl **table = &PL_perlio;
	PerlIOl *ff;
	int code = 0;
	while ((ff = *table)) {
	    int i;
	    table = (PerlIOl **) (ff++);
	    for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
		if (ff->next && PerlIO_flush(&(ff->next)) != 0)
		    code = -1;
		ff++;
	    }
	}
	return code;
    }
}

void
PerlIOBase_flush_linebuf(pTHX)
{
    PerlIOl **table = &PL_perlio;
    PerlIOl *f;
    while ((f = *table)) {
	int i;
	table = (PerlIOl **) (f++);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    if (f->next
		&& (PerlIOBase(&(f->next))->
		    flags & (PERLIO_F_LINEBUF | PERLIO_F_CANWRITE))
		== (PERLIO_F_LINEBUF | PERLIO_F_CANWRITE))
		PerlIO_flush(&(f->next));
	    f++;
	}
    }
}

int
Perl_PerlIO_fill(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_fail(f, Fill, -1, (aTHX_ f));
}

int
PerlIO_isutf8(PerlIO *f)
{
     if (PerlIOValid(f))
	  return (PerlIOBase(f)->flags & PERLIO_F_UTF8) != 0;
     else
	  SETERRNO(EBADF, SS_IVCHAN);

     return -1;
}

int
Perl_PerlIO_eof(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_Base(f, Eof, eof, -1, (aTHX_ f));
}

int
Perl_PerlIO_error(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_Base(f, Error, error, -1, (aTHX_ f));
}

void
Perl_PerlIO_clearerr(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_Base_void(f, Clearerr, clearerr, (aTHX_ f));
}

void
Perl_PerlIO_setlinebuf(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_Base_void(f, Setlinebuf, setlinebuf, (aTHX_ f));
}

int
PerlIO_has_base(PerlIO *f)
{
     if (PerlIOValid(f)) {
	  const PerlIO_funcs * const tab = PerlIOBase(f)->tab;

	  if (tab)
	       return (tab->Get_base != NULL);
     }

     return 0;
}

int
PerlIO_fast_gets(PerlIO *f)
{
    if (PerlIOValid(f)) {
	 if (PerlIOBase(f)->flags & PERLIO_F_FASTGETS) {
	     const PerlIO_funcs * const tab = PerlIOBase(f)->tab;

	     if (tab)
		  return (tab->Set_ptrcnt != NULL);
	 }
    }

    return 0;
}

int
PerlIO_has_cntptr(PerlIO *f)
{
    if (PerlIOValid(f)) {
	const PerlIO_funcs * const tab = PerlIOBase(f)->tab;

	if (tab)
	     return (tab->Get_ptr != NULL && tab->Get_cnt != NULL);
    }

    return 0;
}

int
PerlIO_canset_cnt(PerlIO *f)
{
    if (PerlIOValid(f)) {
	  const PerlIO_funcs * const tab = PerlIOBase(f)->tab;

	  if (tab)
	       return (tab->Set_ptrcnt != NULL);
    }

    return 0;
}

STDCHAR *
Perl_PerlIO_get_base(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_fail(f, Get_base, NULL, (aTHX_ f));
}

SSize_t
Perl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)
{
    /* Note that Get_bufsiz returns a Size_t */
     Perl_PerlIO_or_fail(f, Get_bufsiz, -1, (aTHX_ f));
}

STDCHAR *
Perl_PerlIO_get_ptr(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_fail(f, Get_ptr, NULL, (aTHX_ f));
}

SSize_t
Perl_PerlIO_get_cnt(pTHX_ PerlIO *f)
{
     Perl_PerlIO_or_fail(f, Get_cnt, -1, (aTHX_ f));
}

void
Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt)
{
     Perl_PerlIO_or_fail_void(f, Set_ptrcnt, (aTHX_ f, NULL, cnt));
}

void
Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
     Perl_PerlIO_or_fail_void(f, Set_ptrcnt, (aTHX_ f, ptr, cnt));
}


/*--------------------------------------------------------------------------------------*/
/*
 * utf8 and raw dummy layers
 */

IV
PerlIOUtf8_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
    if (PerlIOValid(f)) {
	if (tab && tab->kind & PERLIO_K_UTF8)
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	else
	    PerlIOBase(f)->flags &= ~PERLIO_F_UTF8;
	return 0;
    }
    return -1;
}

PERLIO_FUNCS_DECL(PerlIO_utf8) = {
    sizeof(PerlIO_funcs),
    "utf8",
    0,
    PERLIO_K_DUMMY | PERLIO_K_UTF8 | PERLIO_K_MULTIARG,
    PerlIOUtf8_pushed,
    NULL,
    PerlIOBase_open,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PERLIO_FUNCS_DECL(PerlIO_byte) = {
    sizeof(PerlIO_funcs),
    "bytes",
    0,
    PERLIO_K_DUMMY | PERLIO_K_MULTIARG,
    PerlIOUtf8_pushed,
    NULL,
    PerlIOBase_open,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PERLIO_FUNCS_DECL(PerlIO_raw) = {
    sizeof(PerlIO_funcs),
    "raw",
    0,
    PERLIO_K_DUMMY,
    PerlIORaw_pushed,
    PerlIOBase_popped,
    PerlIOBase_open,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};
/*--------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------*/
/*
 * "Methods" of the "base class"
 */

IV
PerlIOBase_fileno(pTHX_ PerlIO *f)
{
    return PerlIOValid(f) ? PerlIO_fileno(PerlIONext(f)) : -1;
}

char *
PerlIO_modestr(PerlIO * f, char *buf)
{
    char *s = buf;
    if (PerlIOValid(f)) {
	const IV flags = PerlIOBase(f)->flags;
	if (flags & PERLIO_F_APPEND) {
	    *s++ = 'a';
	    if (flags & PERLIO_F_CANREAD) {
		*s++ = '+';
	    }
	}
	else if (flags & PERLIO_F_CANREAD) {
	    *s++ = 'r';
	    if (flags & PERLIO_F_CANWRITE)
		*s++ = '+';
	}
	else if (flags & PERLIO_F_CANWRITE) {
	    *s++ = 'w';
	    if (flags & PERLIO_F_CANREAD) {
		*s++ = '+';
	    }
	}
#ifdef PERLIO_USING_CRLF
	if (!(flags & PERLIO_F_CRLF))
	    *s++ = 'b';
#endif
    }
    *s = '\0';
    return buf;
}


IV
PerlIOBase_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIOl * const l = PerlIOBase(f);
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(arg);

    l->flags &= ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE |
		  PERLIO_F_TRUNCATE | PERLIO_F_APPEND);
    if (tab && tab->Set_ptrcnt != NULL)
	l->flags |= PERLIO_F_FASTGETS;
    if (mode) {
	if (*mode == IoTYPE_NUMERIC || *mode == IoTYPE_IMPLICIT)
	    mode++;
	switch (*mode++) {
	case 'r':
	    l->flags |= PERLIO_F_CANREAD;
	    break;
	case 'a':
	    l->flags |= PERLIO_F_APPEND | PERLIO_F_CANWRITE;
	    break;
	case 'w':
	    l->flags |= PERLIO_F_TRUNCATE | PERLIO_F_CANWRITE;
	    break;
	default:
	    SETERRNO(EINVAL, LIB_INVARG);
	    return -1;
	}
	while (*mode) {
	    switch (*mode++) {
	    case '+':
		l->flags |= PERLIO_F_CANREAD | PERLIO_F_CANWRITE;
		break;
	    case 'b':
		l->flags &= ~PERLIO_F_CRLF;
		break;
	    case 't':
		l->flags |= PERLIO_F_CRLF;
		break;
	    default:
		SETERRNO(EINVAL, LIB_INVARG);
		return -1;
	    }
	}
    }
    else {
	if (l->next) {
	    l->flags |= l->next->flags &
		(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_TRUNCATE |
		 PERLIO_F_APPEND);
	}
    }
#if 0
    DEBUG_i(
    PerlIO_debug("PerlIOBase_pushed f=%p %s %s fl=%08" UVxf " (%s)\n",
		 (void*)f, PerlIOBase(f)->tab->name, (omode) ? omode : "(Null)",
		 l->flags, PerlIO_modestr(f, temp));
    );
#endif
    return 0;
}

IV
PerlIOBase_popped(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(f);
    return 0;
}

SSize_t
PerlIOBase_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    /*
     * Save the position as current head considers it
     */
    const Off_t old = PerlIO_tell(f);
    PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_pending), "r", NULL);
    PerlIOSelf(f, PerlIOBuf)->posn = old;
    return PerlIOBuf_unread(aTHX_ f, vbuf, count);
}

SSize_t
PerlIOBase_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    STDCHAR *buf = (STDCHAR *) vbuf;
    if (f) {
        if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD)) {
	    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    SETERRNO(EBADF, SS_IVCHAN);
	    PerlIO_save_errno(f);
	    return 0;
	}
	while (count > 0) {
	 get_cnt:
	  {
	    SSize_t avail = PerlIO_get_cnt(f);
	    SSize_t take = 0;
	    if (avail > 0)
		take = (((SSize_t) count >= 0) && ((SSize_t)count < avail)) ? (SSize_t)count : avail;
	    if (take > 0) {
		STDCHAR *ptr = PerlIO_get_ptr(f);
		Copy(ptr, buf, take, STDCHAR);
		PerlIO_set_ptrcnt(f, ptr + take, (avail -= take));
		count -= take;
		buf += take;
		if (avail == 0)		/* set_ptrcnt could have reset avail */
		    goto get_cnt;
	    }
	    if (count > 0 && avail <= 0) {
		if (PerlIO_fill(f) != 0)
		    break;
	    }
	  }
	}
	return (buf - (STDCHAR *) vbuf);
    }
    return 0;
}

IV
PerlIOBase_noop_ok(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(f);
    return 0;
}

IV
PerlIOBase_noop_fail(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(f);
    return -1;
}

IV
PerlIOBase_close(pTHX_ PerlIO *f)
{
    IV code = -1;
    if (PerlIOValid(f)) {
	PerlIO *n = PerlIONext(f);
	code = PerlIO_flush(f);
	PerlIOBase(f)->flags &=
	   ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
	while (PerlIOValid(n)) {
	    const PerlIO_funcs * const tab = PerlIOBase(n)->tab;
	    if (tab && tab->Close) {
		if ((*tab->Close)(aTHX_ n) != 0)
		    code = -1;
		break;
	    }
	    else {
		PerlIOBase(n)->flags &=
		    ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
	    }
	    n = PerlIONext(n);
	}
    }
    else {
	SETERRNO(EBADF, SS_IVCHAN);
    }
    return code;
}

IV
PerlIOBase_eof(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->flags & PERLIO_F_EOF) != 0;
    }
    return 1;
}

IV
PerlIOBase_error(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->flags & PERLIO_F_ERROR) != 0;
    }
    return 1;
}

void
PerlIOBase_clearerr(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO * const n = PerlIONext(f);
	PerlIOBase(f)->flags &= ~(PERLIO_F_ERROR | PERLIO_F_EOF);
	if (PerlIOValid(n))
	    PerlIO_clearerr(n);
    }
}

void
PerlIOBase_setlinebuf(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    if (PerlIOValid(f)) {
	PerlIOBase(f)->flags |= PERLIO_F_LINEBUF;
    }
}

SV *
PerlIO_sv_dup(pTHX_ SV *arg, CLONE_PARAMS *param)
{
    if (!arg)
	return NULL;
#ifdef USE_ITHREADS
    if (param) {
	arg = sv_dup(arg, param);
	SvREFCNT_inc_simple_void_NN(arg);
	return arg;
    }
    else {
	return newSVsv(arg);
    }
#else
    PERL_UNUSED_ARG(param);
    return newSVsv(arg);
#endif
}

PerlIO *
PerlIOBase_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    PerlIO * const nexto = PerlIONext(o);
    if (PerlIOValid(nexto)) {
	const PerlIO_funcs * const tab = PerlIOBase(nexto)->tab;
	if (tab && tab->Dup)
	    f = (*tab->Dup)(aTHX_ f, nexto, param, flags);
	else
	    f = PerlIOBase_dup(aTHX_ f, nexto, param, flags);
    }
    if (f) {
	PerlIO_funcs * const self = PerlIOBase(o)->tab;
	SV *arg = NULL;
	char buf[8];
	assert(self);
	DEBUG_i(PerlIO_debug("PerlIOBase_dup %s f=%p o=%p param=%p\n",
                             self->name,
                             (void*)f, (void*)o, (void*)param) );
	if (self->Getarg)
	  arg = (*self->Getarg)(aTHX_ o, param, flags);
	f = PerlIO_push(aTHX_ f, self, PerlIO_modestr(o,buf), arg);
	if (f && PerlIOBase(o)->flags & PERLIO_F_UTF8)
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	SvREFCNT_dec(arg);
    }
    return f;
}

/* PL_perlio_fd_refcnt[] is in intrpvar.h */

/* Must be called with PL_perlio_mutex locked. */
static void
S_more_refcounted_fds(pTHX_ const int new_fd)
  PERL_TSA_REQUIRES(PL_perlio_mutex)
{
    dVAR;
    const int old_max = PL_perlio_fd_refcnt_size;
    const int new_max = 16 + (new_fd & ~15);
    int *new_array;

#ifndef PERL_IMPLICIT_SYS
    PERL_UNUSED_CONTEXT;
#endif

    DEBUG_i( PerlIO_debug("More fds - old=%d, need %d, new=%d\n",
                          old_max, new_fd, new_max) );

    if (new_fd < old_max) {
	return;
    }

    assert (new_max > new_fd);

    /* Use plain realloc() since we need this memory to be really
     * global and visible to all the interpreters and/or threads. */
    new_array = (int*) realloc(PL_perlio_fd_refcnt, new_max * sizeof(int));

    if (!new_array) {
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
	croak_no_mem();
    }

    PL_perlio_fd_refcnt_size = new_max;
    PL_perlio_fd_refcnt = new_array;

    DEBUG_i( PerlIO_debug("Zeroing %p, %d\n",
                          (void*)(new_array + old_max),
                          new_max - old_max) );

    Zero(new_array + old_max, new_max - old_max, int);
}


void
PerlIO_init(pTHX)
{
    /* MUTEX_INIT(&PL_perlio_mutex) is done in PERL_SYS_INIT3(). */
    PERL_UNUSED_CONTEXT;
}

void
PerlIOUnix_refcnt_inc(int fd)
{
    dTHX;
    if (fd >= 0) {
	dVAR;

#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
#endif
	if (fd >= PL_perlio_fd_refcnt_size)
	    S_more_refcounted_fds(aTHX_ fd);

	PL_perlio_fd_refcnt[fd]++;
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    /* diag_listed_as: refcnt_inc: fd %d%s */
	    Perl_croak(aTHX_ "refcnt_inc: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	DEBUG_i( PerlIO_debug("refcnt_inc: fd %d refcnt=%d\n",
                              fd, PL_perlio_fd_refcnt[fd]) );

#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	/* diag_listed_as: refcnt_inc: fd %d%s */
	Perl_croak(aTHX_ "refcnt_inc: fd %d < 0\n", fd);
    }
}

int
PerlIOUnix_refcnt_dec(int fd)
{
    int cnt = 0;
    if (fd >= 0) {
#ifdef DEBUGGING
        dTHX;
#else
	dVAR;
#endif
#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
#endif
	if (fd >= PL_perlio_fd_refcnt_size) {
	    /* diag_listed_as: refcnt_dec: fd %d%s */
	    Perl_croak_nocontext("refcnt_dec: fd %d >= refcnt_size %d\n",
		       fd, PL_perlio_fd_refcnt_size);
	}
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    /* diag_listed_as: refcnt_dec: fd %d%s */
	    Perl_croak_nocontext("refcnt_dec: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	cnt = --PL_perlio_fd_refcnt[fd];
	DEBUG_i( PerlIO_debug("refcnt_dec: fd %d refcnt=%d\n", fd, cnt) );
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	/* diag_listed_as: refcnt_dec: fd %d%s */
	Perl_croak_nocontext("refcnt_dec: fd %d < 0\n", fd);
    }
    return cnt;
}

int
PerlIOUnix_refcnt(int fd)
{
    dTHX;
    int cnt = 0;
    if (fd >= 0) {
	dVAR;
#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
#endif
	if (fd >= PL_perlio_fd_refcnt_size) {
	    /* diag_listed_as: refcnt: fd %d%s */
	    Perl_croak(aTHX_ "refcnt: fd %d >= refcnt_size %d\n",
		       fd, PL_perlio_fd_refcnt_size);
	}
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    /* diag_listed_as: refcnt: fd %d%s */
	    Perl_croak(aTHX_ "refcnt: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	cnt = PL_perlio_fd_refcnt[fd];
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	/* diag_listed_as: refcnt: fd %d%s */
	Perl_croak(aTHX_ "refcnt: fd %d < 0\n", fd);
    }
    return cnt;
}

void
PerlIO_cleanup(pTHX)
{
    int i;
#ifdef USE_ITHREADS
    DEBUG_i( PerlIO_debug("Cleanup layers for %p\n",(void*)aTHX) );
#else
    DEBUG_i( PerlIO_debug("Cleanup layers\n") );
#endif

    /* Raise STDIN..STDERR refcount so we don't close them */
    for (i=0; i < 3; i++)
	PerlIOUnix_refcnt_inc(i);
    PerlIO_cleantable(aTHX_ &PL_perlio);
    /* Restore STDIN..STDERR refcount */
    for (i=0; i < 3; i++)
	PerlIOUnix_refcnt_dec(i);

    if (PL_known_layers) {
	PerlIO_list_free(aTHX_ PL_known_layers);
	PL_known_layers = NULL;
    }
    if (PL_def_layerlist) {
	PerlIO_list_free(aTHX_ PL_def_layerlist);
	PL_def_layerlist = NULL;
    }
}

void PerlIO_teardown(void) /* Call only from PERL_SYS_TERM(). */
{
    dVAR;
#if 0
/* XXX we can't rely on an interpreter being present at this late stage,
   XXX so we can't use a function like PerlLIO_write that relies on one
   being present (at least in win32) :-(.
   Disable for now.
*/
#ifdef DEBUGGING
    {
	/* By now all filehandles should have been closed, so any
	 * stray (non-STD-)filehandles indicate *possible* (PerlIO)
	 * errors. */
#define PERLIO_TEARDOWN_MESSAGE_BUF_SIZE 64
#define PERLIO_TEARDOWN_MESSAGE_FD 2
	char buf[PERLIO_TEARDOWN_MESSAGE_BUF_SIZE];
	int i;
	for (i = 3; i < PL_perlio_fd_refcnt_size; i++) {
	    if (PL_perlio_fd_refcnt[i]) {
		const STRLEN len =
		    my_snprintf(buf, sizeof(buf),
				"PerlIO_teardown: fd %d refcnt=%d\n",
				i, PL_perlio_fd_refcnt[i]);
		PerlLIO_write(PERLIO_TEARDOWN_MESSAGE_FD, buf, len);
	    }
	}
    }
#endif
#endif
    /* Not bothering with PL_perlio_mutex since by now
     * all the interpreters are gone. */
    if (PL_perlio_fd_refcnt_size /* Assuming initial size of zero. */
        && PL_perlio_fd_refcnt) {
	free(PL_perlio_fd_refcnt); /* To match realloc() in S_more_refcounted_fds(). */
	PL_perlio_fd_refcnt = NULL;
	PL_perlio_fd_refcnt_size = 0;
    }
}

/*--------------------------------------------------------------------------------------*/
/*
 * Bottom-most level for UNIX-like case
 */

typedef struct {
    struct _PerlIO base;        /* The generic part */
    int fd;                     /* UNIX like file descriptor */
    int oflags;                 /* open/fcntl flags */
} PerlIOUnix;

static void
S_lockcnt_dec(pTHX_ const void* f)
{
#ifndef PERL_IMPLICIT_SYS
    PERL_UNUSED_CONTEXT;
#endif
    PerlIO_lockcnt((PerlIO*)f)--;
}


/* call the signal handler, and if that handler happens to clear
 * this handle, free what we can and return true */

static bool
S_perlio_async_run(pTHX_ PerlIO* f) {
    ENTER;
    SAVEDESTRUCTOR_X(S_lockcnt_dec, (void*)f);
    PerlIO_lockcnt(f)++;
    PERL_ASYNC_CHECK();
    if ( !(PerlIOBase(f)->flags & PERLIO_F_CLEARED) ) {
	LEAVE;
	return 0;
    }
    /* we've just run some perl-level code that could have done
     * anything, including closing the file or clearing this layer.
     * If so, free any lower layers that have already been
     * cleared, then return an error. */
    while (PerlIOValid(f) &&
	    (PerlIOBase(f)->flags & PERLIO_F_CLEARED))
    {
	const PerlIOl *l = *f;
	*f = l->next;
	Safefree(l);
    }
    LEAVE;
    return 1;
}

int
PerlIOUnix_oflags(const char *mode)
{
    int oflags = -1;
    if (*mode == IoTYPE_IMPLICIT || *mode == IoTYPE_NUMERIC)
	mode++;
    switch (*mode) {
    case 'r':
	oflags = O_RDONLY;
	if (*++mode == '+') {
	    oflags = O_RDWR;
	    mode++;
	}
	break;

    case 'w':
	oflags = O_CREAT | O_TRUNC;
	if (*++mode == '+') {
	    oflags |= O_RDWR;
	    mode++;
	}
	else
	    oflags |= O_WRONLY;
	break;

    case 'a':
	oflags = O_CREAT | O_APPEND;
	if (*++mode == '+') {
	    oflags |= O_RDWR;
	    mode++;
	}
	else
	    oflags |= O_WRONLY;
	break;
    }

    /* XXX TODO: PerlIO_open() test that exercises 'rb' and 'rt'. */

    /* Unless O_BINARY is different from O_TEXT, first bit-or:ing one
     * of them in, and then bit-and-masking the other them away, won't
     * have much of an effect. */
    switch (*mode) {
    case 'b':
#if O_TEXT != O_BINARY
        oflags |= O_BINARY;
	oflags &= ~O_TEXT;
#endif
        mode++;
        break;
    case 't':
#if O_TEXT != O_BINARY
	oflags |= O_TEXT;
	oflags &= ~O_BINARY;
#endif
        mode++;
        break;
    default:
#  if O_BINARY != 0
        /* bit-or:ing with zero O_BINARY would be useless. */
	/*
	 * If neither "t" nor "b" was specified, open the file
	 * in O_BINARY mode.
         *
         * Note that if something else than the zero byte was seen
         * here (e.g. bogus mode "rx"), just few lines later we will
         * set the errno and invalidate the flags.
	 */
	oflags |= O_BINARY;
#  endif
        break;
    }
    if (*mode || oflags == -1) {
	SETERRNO(EINVAL, LIB_INVARG);
	oflags = -1;
    }
    return oflags;
}

IV
PerlIOUnix_fileno(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;
    return PerlIOSelf(f, PerlIOUnix)->fd;
}

static void
PerlIOUnix_setfd(pTHX_ PerlIO *f, int fd, int imode)
{
    PerlIOUnix * const s = PerlIOSelf(f, PerlIOUnix);
#if defined(WIN32)
    Stat_t st;
    if (PerlLIO_fstat(fd, &st) == 0) {
	if (!S_ISREG(st.st_mode)) {
	    DEBUG_i( PerlIO_debug("%d is not regular file\n",fd) );
    	    PerlIOBase(f)->flags |= PERLIO_F_NOTREG;
	}
	else {
	    DEBUG_i( PerlIO_debug("%d _is_ a regular file\n",fd) );
	}
    }
#endif
    s->fd = fd;
    s->oflags = imode;
    PerlIOUnix_refcnt_inc(fd);
    PERL_UNUSED_CONTEXT;
}

IV
PerlIOUnix_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
    if (*PerlIONext(f)) {
	/* We never call down so do any pending stuff now */
	PerlIO_flush(PerlIONext(f));
	/*
	 * XXX could (or should) we retrieve the oflags from the open file
	 * handle rather than believing the "mode" we are passed in? XXX
	 * Should the value on NULL mode be 0 or -1?
	 */
        PerlIOUnix_setfd(aTHX_ f, PerlIO_fileno(PerlIONext(f)),
                         mode ? PerlIOUnix_oflags(mode) : -1);
    }
    PerlIOBase(f)->flags |= PERLIO_F_OPEN;

    return code;
}

IV
PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    Off_t new_loc;
    PERL_UNUSED_CONTEXT;
    if (PerlIOBase(f)->flags & PERLIO_F_NOTREG) {
#ifdef  ESPIPE
	SETERRNO(ESPIPE, LIB_INVARG);
#else
	SETERRNO(EINVAL, LIB_INVARG);
#endif
	return -1;
    }
    new_loc = PerlLIO_lseek(fd, offset, whence);
    if (new_loc == (Off_t) - 1)
	return -1;
    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
    return  0;
}

PerlIO *
PerlIOUnix_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
		IV n, const char *mode, int fd, int imode,
		int perm, PerlIO *f, int narg, SV **args)
{
    if (PerlIOValid(f)) {
	if (PerlIOBase(f)->tab && PerlIOBase(f)->flags & PERLIO_F_OPEN)
	    (*PerlIOBase(f)->tab->Close)(aTHX_ f);
    }
    if (narg > 0) {
	if (*mode == IoTYPE_NUMERIC)
	    mode++;
	else {
	    imode = PerlIOUnix_oflags(mode);
#ifdef VMS
	    perm = 0777; /* preserve RMS defaults, ACL inheritance, etc. */
#else
	    perm = 0666;
#endif
	}
	if (imode != -1) {
            STRLEN len;
	    const char *path = SvPV_const(*args, len);
	    if (!IS_SAFE_PATHNAME(path, len, "open"))
                return NULL;
	    fd = PerlLIO_open3(path, imode, perm);
	}
    }
    if (fd >= 0) {
	if (*mode == IoTYPE_IMPLICIT)
	    mode++;
	if (!f) {
	    f = PerlIO_allocate(aTHX);
	}
	if (!PerlIOValid(f)) {
	    if (!(f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg))) {
		PerlLIO_close(fd);
		return NULL;
	    }
	}
        PerlIOUnix_setfd(aTHX_ f, fd, imode);
	PerlIOBase(f)->flags |= PERLIO_F_OPEN;
	if (*mode == IoTYPE_APPEND)
	    PerlIOUnix_seek(aTHX_ f, 0, SEEK_END);
	return f;
    }
    else {
	if (f) {
	    NOOP;
	    /*
	     * FIXME: pop layers ???
	     */
	}
	return NULL;
    }
}

PerlIO *
PerlIOUnix_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    const PerlIOUnix * const os = PerlIOSelf(o, PerlIOUnix);
    int fd = os->fd;
    if (flags & PERLIO_DUP_FD) {
	fd = PerlLIO_dup(fd);
    }
    if (fd >= 0) {
	f = PerlIOBase_dup(aTHX_ f, o, param, flags);
	if (f) {
	    /* If all went well overwrite fd in dup'ed lay with the dup()'ed fd */
	    PerlIOUnix_setfd(aTHX_ f, fd, os->oflags);
	    return f;
	}
        PerlLIO_close(fd);
    }
    return NULL;
}


SSize_t
PerlIOUnix_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    int fd;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    fd = PerlIOSelf(f, PerlIOUnix)->fd;
#ifdef PERLIO_STD_SPECIAL
    if (fd == 0)
        return PERLIO_STD_IN(fd, vbuf, count);
#endif
    if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD) ||
         PerlIOBase(f)->flags & (PERLIO_F_EOF|PERLIO_F_ERROR)) {
	return 0;
    }
    while (1) {
	const SSize_t len = PerlLIO_read(fd, vbuf, count);
	if (len >= 0 || errno != EINTR) {
	    if (len < 0) {
		if (errno != EAGAIN) {
		    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		    PerlIO_save_errno(f);
		}
	    }
	    else if (len == 0 && count != 0) {
		PerlIOBase(f)->flags |= PERLIO_F_EOF;
		SETERRNO(0,0);
	    }
	    return len;
	}
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
    }
    NOT_REACHED; /*NOTREACHED*/
}

SSize_t
PerlIOUnix_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    int fd;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    fd = PerlIOSelf(f, PerlIOUnix)->fd;
#ifdef PERLIO_STD_SPECIAL
    if (fd == 1 || fd == 2)
        return PERLIO_STD_OUT(fd, vbuf, count);
#endif
    while (1) {
	const SSize_t len = PerlLIO_write(fd, vbuf, count);
	if (len >= 0 || errno != EINTR) {
	    if (len < 0) {
		if (errno != EAGAIN) {
		    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		    PerlIO_save_errno(f);
		}
	    }
	    return len;
	}
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
    }
    NOT_REACHED; /*NOTREACHED*/
}

Off_t
PerlIOUnix_tell(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

    return PerlLIO_lseek(PerlIOSelf(f, PerlIOUnix)->fd, 0, SEEK_CUR);
}


IV
PerlIOUnix_close(pTHX_ PerlIO *f)
{
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    int code = 0;
    if (PerlIOBase(f)->flags & PERLIO_F_OPEN) {
	if (PerlIOUnix_refcnt_dec(fd) > 0) {
	    PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
	    return 0;
	}
    }
    else {
	SETERRNO(EBADF,SS_IVCHAN);
	return -1;
    }
    while (PerlLIO_close(fd) != 0) {
	if (errno != EINTR) {
	    code = -1;
	    break;
	}
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
    }
    if (code == 0) {
	PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
    }
    return code;
}

PERLIO_FUNCS_DECL(PerlIO_unix) = {
    sizeof(PerlIO_funcs),
    "unix",
    sizeof(PerlIOUnix),
    PERLIO_K_RAW,
    PerlIOUnix_pushed,
    PerlIOBase_popped,
    PerlIOUnix_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOUnix_fileno,
    PerlIOUnix_dup,
    PerlIOUnix_read,
    PerlIOBase_unread,
    PerlIOUnix_write,
    PerlIOUnix_seek,
    PerlIOUnix_tell,
    PerlIOUnix_close,
    PerlIOBase_noop_ok,         /* flush */
    PerlIOBase_noop_fail,       /* fill */
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

/*--------------------------------------------------------------------------------------*/
/*
 * stdio as a layer
 */

#if defined(VMS) && !defined(STDIO_BUFFER_WRITABLE)
/* perl5.8 - This ensures the last minute VMS ungetc fix is not
   broken by the last second glibc 2.3 fix
 */
#define STDIO_BUFFER_WRITABLE
#endif


typedef struct {
    struct _PerlIO base;
    FILE *stdio;                /* The stream */
} PerlIOStdio;

IV
PerlIOStdio_fileno(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

    if (PerlIOValid(f)) {
	FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;
	if (s)
	    return PerlSIO_fileno(s);
    }
    errno = EBADF;
    return -1;
}

char *
PerlIOStdio_mode(const char *mode, char *tmode)
{
    char * const ret = tmode;
    if (mode) {
	while (*mode) {
	    *tmode++ = *mode++;
	}
    }
#if defined(PERLIO_USING_CRLF) || defined(__CYGWIN__)
    *tmode++ = 'b';
#endif
    *tmode = '\0';
    return ret;
}

IV
PerlIOStdio_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIO *n;
    if (PerlIOValid(f) && PerlIOValid(n = PerlIONext(f))) {
	PerlIO_funcs * const toptab = PerlIOBase(n)->tab;
        if (toptab == tab) {
	    /* Top is already stdio - pop self (duplicate) and use original */
	    PerlIO_pop(aTHX_ f);
	    return 0;
	} else {
	    const int fd = PerlIO_fileno(n);
	    char tmode[8];
	    FILE *stdio;
	    if (fd >= 0 && (stdio  = PerlSIO_fdopen(fd,
			    mode = PerlIOStdio_mode(mode, tmode)))) {
		PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
	    	/* We never call down so do any pending stuff now */
	    	PerlIO_flush(PerlIONext(f));
                return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
	    }
	    else {
		return -1;
	    }
        }
    }
    return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
}


PerlIO *
PerlIO_importFILE(FILE *stdio, const char *mode)
{
    dTHX;
    PerlIO *f = NULL;
#ifdef EBCDIC
	 int rc;
	 char filename[FILENAME_MAX];
	 fldata_t fileinfo;
#endif
    if (stdio) {
	PerlIOStdio *s;
        int fd0 = fileno(stdio);
        if (fd0 < 0) {
#ifdef EBCDIC
			  rc = fldata(stdio,filename,&fileinfo);
			  if(rc != 0){
				  return NULL;
			  }
			  if(fileinfo.__dsorgHFS){
            return NULL;
        }
			  /*This MVS dataset , OK!*/
#else
            return NULL;
#endif
        }
	if (!mode || !*mode) {
	    /* We need to probe to see how we can open the stream
	       so start with read/write and then try write and read
	       we dup() so that we can fclose without loosing the fd.

	       Note that the errno value set by a failing fdopen
	       varies between stdio implementations.
	     */
            const int fd = PerlLIO_dup(fd0);
	    FILE *f2;
            if (fd < 0) {
                return f;
            }
	    f2 = PerlSIO_fdopen(fd, (mode = "r+"));
	    if (!f2) {
		f2 = PerlSIO_fdopen(fd, (mode = "w"));
	    }
	    if (!f2) {
		f2 = PerlSIO_fdopen(fd, (mode = "r"));
	    }
	    if (!f2) {
		/* Don't seem to be able to open */
		PerlLIO_close(fd);
		return f;
	    }
	    fclose(f2);
	}
	if ((f = PerlIO_push(aTHX_(PerlIO_allocate(aTHX)), PERLIO_FUNCS_CAST(&PerlIO_stdio), mode, NULL))) {
	    s = PerlIOSelf(f, PerlIOStdio);
	    s->stdio = stdio;
#ifdef EBCDIC
		fd0 = fileno(stdio);
		if(fd0 != -1){
			PerlIOUnix_refcnt_inc(fd0);
		}
		else{
			rc = fldata(stdio,filename,&fileinfo);
			if(rc != 0){
				PerlIOUnix_refcnt_inc(fd0);
			}
			if(fileinfo.__dsorgHFS){
				PerlIOUnix_refcnt_inc(fd0);
			}
			  /*This MVS dataset , OK!*/
		}
#else
	    PerlIOUnix_refcnt_inc(fileno(stdio));
#endif
	}
    }
    return f;
}

PerlIO *
PerlIOStdio_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
		 IV n, const char *mode, int fd, int imode,
		 int perm, PerlIO *f, int narg, SV **args)
{
    char tmode[8];
    if (PerlIOValid(f)) {
        STRLEN len;
	const char * const path = SvPV_const(*args, len);
	PerlIOStdio * const s = PerlIOSelf(f, PerlIOStdio);
	FILE *stdio;
	if (!IS_SAFE_PATHNAME(path, len, "open"))
            return NULL;
	PerlIOUnix_refcnt_dec(fileno(s->stdio));
	stdio = PerlSIO_freopen(path, PerlIOStdio_mode(mode, tmode),
                                s->stdio);
	if (!s->stdio)
	    return NULL;
	s->stdio = stdio;
	PerlIOUnix_refcnt_inc(fileno(s->stdio));
	return f;
    }
    else {
	if (narg > 0) {
            STRLEN len;
	    const char * const path = SvPV_const(*args, len);
            if (!IS_SAFE_PATHNAME(path, len, "open"))
                return NULL;
	    if (*mode == IoTYPE_NUMERIC) {
		mode++;
		fd = PerlLIO_open3(path, imode, perm);
	    }
	    else {
	        FILE *stdio;
	        bool appended = FALSE;
#ifdef __CYGWIN__
		/* Cygwin wants its 'b' early. */
		appended = TRUE;
		mode = PerlIOStdio_mode(mode, tmode);
#endif
		stdio = PerlSIO_fopen(path, mode);
		if (stdio) {
		    if (!f) {
			f = PerlIO_allocate(aTHX);
		    }
		    if (!appended)
		        mode = PerlIOStdio_mode(mode, tmode);
		    f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg);
		    if (f) {
			PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
			PerlIOUnix_refcnt_inc(fileno(stdio));
		    } else {
			PerlSIO_fclose(stdio);
		    }
		    return f;
		}
		else {
		    return NULL;
		}
	    }
	}
	if (fd >= 0) {
	    FILE *stdio = NULL;
	    int init = 0;
	    if (*mode == IoTYPE_IMPLICIT) {
		init = 1;
		mode++;
	    }
	    if (init) {
		switch (fd) {
		case 0:
		    stdio = PerlSIO_stdin;
		    break;
		case 1:
		    stdio = PerlSIO_stdout;
		    break;
		case 2:
		    stdio = PerlSIO_stderr;
		    break;
		}
	    }
	    else {
		stdio = PerlSIO_fdopen(fd, mode =
				       PerlIOStdio_mode(mode, tmode));
	    }
	    if (stdio) {
		if (!f) {
		    f = PerlIO_allocate(aTHX);
		}
		if ((f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg))) {
		    PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
		    PerlIOUnix_refcnt_inc(fileno(stdio));
		}
		return f;
	    }
            PerlLIO_close(fd);
	}
    }
    return NULL;
}

PerlIO *
PerlIOStdio_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    /* This assumes no layers underneath - which is what
       happens, but is not how I remember it. NI-S 2001/10/16
     */
    if ((f = PerlIOBase_dup(aTHX_ f, o, param, flags))) {
	FILE *stdio = PerlIOSelf(o, PerlIOStdio)->stdio;
	const int fd = fileno(stdio);
	char mode[8];
	if (flags & PERLIO_DUP_FD) {
	    const int dfd = PerlLIO_dup(fileno(stdio));
	    if (dfd >= 0) {
		stdio = PerlSIO_fdopen(dfd, PerlIO_modestr(o,mode));
		goto set_this;
	    }
	    else {
		NOOP;
		/* FIXME: To avoid messy error recovery if dup fails
		   re-use the existing stdio as though flag was not set
		 */
	    }
	}
    	stdio = PerlSIO_fdopen(fd, PerlIO_modestr(o,mode));
    set_this:
	PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
        if(stdio) {
	    PerlIOUnix_refcnt_inc(fileno(stdio));
        }
    }
    return f;
}

static int
PerlIOStdio_invalidate_fileno(pTHX_ FILE *f)
{
    PERL_UNUSED_CONTEXT;

    /* XXX this could use PerlIO_canset_fileno() and
     * PerlIO_set_fileno() support from Configure
     */
#  if defined(HAS_FDCLOSE)
    return fdclose(f, NULL) == 0 ? 1 : 0;
#  elif defined(__UCLIBC__)
    /* uClibc must come before glibc because it defines __GLIBC__ as well. */
    f->__filedes = -1;
    return 1;
#  elif defined(__GLIBC__)
    /* There may be a better way for GLIBC:
    	- libio.h defines a flag to not close() on cleanup
     */	
    f->_fileno = -1;
    return 1;
#  elif defined(__sun)
    PERL_UNUSED_ARG(f);
    return 0;
#  elif defined(__hpux)
    f->__fileH = 0xff;
    f->__fileL = 0xff;
    return 1;
   /* Next one ->_file seems to be a reasonable fallback, i.e. if
      your platform does not have special entry try this one.
      [For OSF only have confirmation for Tru64 (alpha)
      but assume other OSFs will be similar.]
    */
#  elif defined(_AIX) || defined(__osf__) || defined(__irix__)
    f->_file = -1;
    return 1;
#  elif defined(__FreeBSD__)
    /* There may be a better way on FreeBSD:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
#  elif defined(__OpenBSD__)
    /* There may be a better way on OpenBSD:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
#  elif defined(__EMX__)
    /* f->_flags &= ~_IOOPEN; */	/* Will leak stream->_buffer */
    f->_handle = -1;
    return 1;
#  elif defined(__CYGWIN__)
    /* There may be a better way on CYGWIN:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
#  elif defined(WIN32)
#    if defined(UNDER_CE)
    /* WIN_CE does not have access to FILE internals, it hardly has FILE
       structure at all
     */
#    else
    f->_file = -1;
#    endif
    return 1;
#  else
#if 0
    /* Sarathy's code did this - we fall back to a dup/dup2 hack
       (which isn't thread safe) instead
     */
#    error "Don't know how to set FILE.fileno on your platform"
#endif
    PERL_UNUSED_ARG(f);
    return 0;
#  endif
}

IV
PerlIOStdio_close(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (!stdio) {
	errno = EBADF;
	return -1;
    }
    else {
        const int fd = fileno(stdio);
	int invalidate = 0;
	IV result = 0;
	int dupfd = -1;
	dSAVEDERRNO;
#ifdef USE_ITHREADS
	dVAR;
#endif
#ifdef SOCKS5_VERSION_NAME
    	/* Socks lib overrides close() but stdio isn't linked to
	   that library (though we are) - so we must call close()
	   on sockets on stdio's behalf.
	 */
    	int optval;
    	Sock_size_t optlen = sizeof(int);
	if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *) &optval, &optlen) == 0)
	    invalidate = 1;
#endif
	/* Test for -1, as *BSD stdio (at least) on fclose sets the FILE* such
	   that a subsequent fileno() on it returns -1. Don't want to croak()
	   from within PerlIOUnix_refcnt_dec() if some buggy caller code is
	   trying to close an already closed handle which somehow it still has
	   a reference to. (via.xs, I'm looking at you).  */
	if (fd != -1 && PerlIOUnix_refcnt_dec(fd) > 0) {
	    /* File descriptor still in use */
	    invalidate = 1;
	}
	if (invalidate) {
	    /* For STD* handles, don't close stdio, since we shared the FILE *, too. */
	    if (stdio == stdin) /* Some stdios are buggy fflush-ing inputs */
		return 0;
	    if (stdio == stdout || stdio == stderr)
		return PerlIO_flush(f);
        }
#ifdef USE_ITHREADS
        MUTEX_LOCK(&PL_perlio_mutex);
        /* Right. We need a mutex here because for a brief while we
           will have the situation that fd is actually closed. Hence if
           a second thread were to get into this block, its dup() would
           likely return our fd as its dupfd. (after all, it is closed)
           Then if we get to the dup2() first, we blat the fd back
           (messing up its temporary as a side effect) only for it to
           then close its dupfd (== our fd) in its close(dupfd) */

        /* There is, of course, a race condition, that any other thread
           trying to input/output/whatever on this fd will be stuffed
           for the duration of this little manoeuvrer. Perhaps we
           should hold an IO mutex for the duration of every IO
           operation if we know that invalidate doesn't work on this
           platform, but that would suck, and could kill performance.

           Except that correctness trumps speed.
           Advice from klortho #11912. */
#endif
	if (invalidate) {
            /* Tricky - must fclose(stdio) to free memory but not close(fd)
	       Use Sarathy's trick from maint-5.6 to invalidate the
	       fileno slot of the FILE *
	    */
	    result = PerlIO_flush(f);
	    SAVE_ERRNO;
	    invalidate = PerlIOStdio_invalidate_fileno(aTHX_ stdio);
	    if (!invalidate) {
		dupfd = PerlLIO_dup(fd);
#ifdef USE_ITHREADS
		if (dupfd < 0) {
		    /* Oh cXap. This isn't going to go well. Not sure if we can
		       recover from here, or if closing this particular FILE *
		       is a good idea now.  */
		}
#endif
	    }
	} else {
	    SAVE_ERRNO;   /* This is here only to silence compiler warnings */
	}
        result = PerlSIO_fclose(stdio);
	/* We treat error from stdio as success if we invalidated
	   errno may NOT be expected EBADF
	 */
	if (invalidate && result != 0) {
	    RESTORE_ERRNO;
	    result = 0;
	}
#ifdef SOCKS5_VERSION_NAME
	/* in SOCKS' case, let close() determine return value */
	result = close(fd);
#endif
	if (dupfd >= 0) {
	    PerlLIO_dup2(dupfd,fd);
	    PerlLIO_close(dupfd);
	}
#ifdef USE_ITHREADS
        MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
	return result;
    }
}

SSize_t
PerlIOStdio_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    FILE * s;
    SSize_t got = 0;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    s = PerlIOSelf(f, PerlIOStdio)->stdio;
    for (;;) {
	if (count == 1) {
	    STDCHAR *buf = (STDCHAR *) vbuf;
	    /*
	     * Perl is expecting PerlIO_getc() to fill the buffer Linux's
	     * stdio does not do that for fread()
	     */
	    const int ch = PerlSIO_fgetc(s);
	    if (ch != EOF) {
		*buf = ch;
		got = 1;
	    }
	}
	else
	    got = PerlSIO_fread(vbuf, 1, count, s);
	if (got == 0 && PerlSIO_ferror(s))
	    got = -1;
	if (got >= 0 || errno != EINTR)
	    break;
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
	SETERRNO(0,0);	/* just in case */
    }
#ifdef __sgi
    /* Under some circumstances IRIX stdio fgetc() and fread()
     * set the errno to ENOENT, which makes no sense according
     * to either IRIX or POSIX.  [rt.perl.org #123977] */
    if (errno == ENOENT) SETERRNO(0,0);
#endif
    return got;
}

SSize_t
PerlIOStdio_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    SSize_t unread = 0;
    FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;

#ifdef STDIO_BUFFER_WRITABLE
    if (PerlIO_fast_gets(f) && PerlIO_has_base(f)) {
	STDCHAR *buf = ((STDCHAR *) vbuf) + count;
	STDCHAR *base = PerlIO_get_base(f);
	SSize_t cnt   = PerlIO_get_cnt(f);
	STDCHAR *ptr  = PerlIO_get_ptr(f);
	SSize_t avail = ptr - base;
	if (avail > 0) {
	    if (avail > count) {
		avail = count;
	    }
	    ptr -= avail;
	    Move(buf-avail,ptr,avail,STDCHAR);
	    count -= avail;
	    unread += avail;
	    PerlIO_set_ptrcnt(f,ptr,cnt+avail);
	    if (PerlSIO_feof(s) && unread >= 0)
		PerlSIO_clearerr(s);
	}
    }
    else
#endif
    if (PerlIO_has_cntptr(f)) {
	/* We can get pointer to buffer but not its base
	   Do ungetc() but check chars are ending up in the
	   buffer
	 */
	STDCHAR *eptr = (STDCHAR*)PerlSIO_get_ptr(s);
	STDCHAR *buf = ((STDCHAR *) vbuf) + count;
	while (count > 0) {
	    const int ch = *--buf & 0xFF;
	    if (ungetc(ch,s) != ch) {
		/* ungetc did not work */
		break;
	    }
	    if ((STDCHAR*)PerlSIO_get_ptr(s) != --eptr || ((*eptr & 0xFF) != ch)) {
		/* Did not change pointer as expected */
		if (fgetc(s) != EOF)  /* get char back again */
                    break;
	    }
	    /* It worked ! */
	    count--;
	    unread++;
	}
    }

    if (count > 0) {
	unread += PerlIOBase_unread(aTHX_ f, vbuf, count);
    }
    return unread;
}

SSize_t
PerlIOStdio_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    SSize_t got;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    for (;;) {
	got = PerlSIO_fwrite(vbuf, 1, count,
			      PerlIOSelf(f, PerlIOStdio)->stdio);
	if (got >= 0 || errno != EINTR)
	    break;
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
	SETERRNO(0,0);	/* just in case */
    }
    return got;
}

IV
PerlIOStdio_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

    return PerlSIO_fseek(stdio, offset, whence);
}

Off_t
PerlIOStdio_tell(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

    return PerlSIO_ftell(stdio);
}

IV
PerlIOStdio_flush(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

    if (PerlIOBase(f)->flags & PERLIO_F_CANWRITE) {
	return PerlSIO_fflush(stdio);
    }
    else {
	NOOP;
#if 0
	/*
	 * FIXME: This discards ungetc() and pre-read stuff which is not
	 * right if this is just a "sync" from a layer above Suspect right
	 * design is to do _this_ but not have layer above flush this
	 * layer read-to-read
	 */
	/*
	 * Not writeable - sync by attempting a seek
	 */
	dSAVE_ERRNO;
	if (PerlSIO_fseek(stdio, (Off_t) 0, SEEK_CUR) != 0)
	    RESTORE_ERRNO;
#endif
    }
    return 0;
}

IV
PerlIOStdio_eof(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

    return PerlSIO_feof(PerlIOSelf(f, PerlIOStdio)->stdio);
}

IV
PerlIOStdio_error(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

    return PerlSIO_ferror(PerlIOSelf(f, PerlIOStdio)->stdio);
}

void
PerlIOStdio_clearerr(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

    PerlSIO_clearerr(PerlIOSelf(f, PerlIOStdio)->stdio);
}

void
PerlIOStdio_setlinebuf(pTHX_ PerlIO *f)
{
    PERL_UNUSED_CONTEXT;

#ifdef HAS_SETLINEBUF
    PerlSIO_setlinebuf(PerlIOSelf(f, PerlIOStdio)->stdio);
#else
    PerlSIO_setvbuf(PerlIOSelf(f, PerlIOStdio)->stdio, NULL, _IOLBF, 0);
#endif
}

#ifdef FILE_base
STDCHAR *
PerlIOStdio_get_base(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return (STDCHAR*)PerlSIO_get_base(stdio);
}

Size_t
PerlIOStdio_get_bufsiz(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_get_bufsiz(stdio);
}
#endif

#ifdef USE_STDIO_PTR
STDCHAR *
PerlIOStdio_get_ptr(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return (STDCHAR*)PerlSIO_get_ptr(stdio);
}

SSize_t
PerlIOStdio_get_cnt(pTHX_ PerlIO *f)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_get_cnt(stdio);
}

void
PerlIOStdio_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (ptr != NULL) {
#ifdef STDIO_PTR_LVALUE
        /* This is a long-standing infamous mess.  The root of the
         * problem is that one cannot know the signedness of char, and
         * more precisely the signedness of FILE._ptr.  The following
         * things have been tried, and they have all failed (across
         * different compilers (remember that core needs to to build
         * also with c++) and compiler options:
         *
         * - casting the RHS to (void*) -- works in *some* places
         * - casting the LHS to (void*) -- totally unportable
         *
         * So let's try silencing the warning at least for gcc. */
        GCC_DIAG_IGNORE(-Wpointer-sign);
	PerlSIO_set_ptr(stdio, ptr); /* LHS STDCHAR* cast non-portable */
        GCC_DIAG_RESTORE;
#ifdef STDIO_PTR_LVAL_SETS_CNT
	assert(PerlSIO_get_cnt(stdio) == (cnt));
#endif
#if (!defined(STDIO_PTR_LVAL_NOCHANGE_CNT))
	/*
	 * Setting ptr _does_ change cnt - we are done
	 */
	return;
#endif
#else                           /* STDIO_PTR_LVALUE */
	PerlProc_abort();
#endif                          /* STDIO_PTR_LVALUE */
    }
    /*
     * Now (or only) set cnt
     */
#ifdef STDIO_CNT_LVALUE
    PerlSIO_set_cnt(stdio, cnt);
#else                           /* STDIO_CNT_LVALUE */
#if (defined(STDIO_PTR_LVALUE) && defined(STDIO_PTR_LVAL_SETS_CNT))
    PerlSIO_set_ptr(stdio,
		    PerlSIO_get_ptr(stdio) + (PerlSIO_get_cnt(stdio) -
					      cnt));
#else                           /* STDIO_PTR_LVAL_SETS_CNT */
    PerlProc_abort();
#endif                          /* STDIO_PTR_LVAL_SETS_CNT */
#endif                          /* STDIO_CNT_LVALUE */
}


#endif

IV
PerlIOStdio_fill(pTHX_ PerlIO *f)
{
    FILE * stdio;
    int c;
    PERL_UNUSED_CONTEXT;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    stdio = PerlIOSelf(f, PerlIOStdio)->stdio;

    /*
     * fflush()ing read-only streams can cause trouble on some stdio-s
     */
    if ((PerlIOBase(f)->flags & PERLIO_F_CANWRITE)) {
	if (PerlSIO_fflush(stdio) != 0)
	    return EOF;
    }
    for (;;) {
	c = PerlSIO_fgetc(stdio);
	if (c != EOF)
	    break;
	if (! PerlSIO_ferror(stdio) || errno != EINTR)
	    return EOF;
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
	SETERRNO(0,0);
    }

#if (defined(STDIO_PTR_LVALUE) && (defined(STDIO_CNT_LVALUE) || defined(STDIO_PTR_LVAL_SETS_CNT)))

#ifdef STDIO_BUFFER_WRITABLE
    if (PerlIO_fast_gets(f) && PerlIO_has_base(f)) {
	/* Fake ungetc() to the real buffer in case system's ungetc
	   goes elsewhere
	 */
	STDCHAR *base = (STDCHAR*)PerlSIO_get_base(stdio);
	SSize_t cnt   = PerlSIO_get_cnt(stdio);
	STDCHAR *ptr  = (STDCHAR*)PerlSIO_get_ptr(stdio);
	if (ptr == base+1) {
	    *--ptr = (STDCHAR) c;
	    PerlIOStdio_set_ptrcnt(aTHX_ f,ptr,cnt+1);
	    if (PerlSIO_feof(stdio))
		PerlSIO_clearerr(stdio);
	    return 0;
	}
    }
    else
#endif
    if (PerlIO_has_cntptr(f)) {
	STDCHAR ch = c;
	if (PerlIOStdio_unread(aTHX_ f,&ch,1) == 1) {
	    return 0;
	}
    }
#endif

    /* If buffer snoop scheme above fails fall back to
       using ungetc().
     */
    if (PerlSIO_ungetc(c, stdio) != c)
	return EOF;

    return 0;
}



PERLIO_FUNCS_DECL(PerlIO_stdio) = {
    sizeof(PerlIO_funcs),
    "stdio",
    sizeof(PerlIOStdio),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOStdio_pushed,
    PerlIOBase_popped,
    PerlIOStdio_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOStdio_fileno,
    PerlIOStdio_dup,
    PerlIOStdio_read,
    PerlIOStdio_unread,
    PerlIOStdio_write,
    PerlIOStdio_seek,
    PerlIOStdio_tell,
    PerlIOStdio_close,
    PerlIOStdio_flush,
    PerlIOStdio_fill,
    PerlIOStdio_eof,
    PerlIOStdio_error,
    PerlIOStdio_clearerr,
    PerlIOStdio_setlinebuf,
#ifdef FILE_base
    PerlIOStdio_get_base,
    PerlIOStdio_get_bufsiz,
#else
    NULL,
    NULL,
#endif
#ifdef USE_STDIO_PTR
    PerlIOStdio_get_ptr,
    PerlIOStdio_get_cnt,
#   if defined(HAS_FAST_STDIO) && defined(USE_FAST_STDIO)
    PerlIOStdio_set_ptrcnt,
#   else
    NULL,
#   endif /* HAS_FAST_STDIO && USE_FAST_STDIO */
#else
    NULL,
    NULL,
    NULL,
#endif /* USE_STDIO_PTR */
};

/* Note that calls to PerlIO_exportFILE() are reversed using
 * PerlIO_releaseFILE(), not importFILE. */
FILE *
PerlIO_exportFILE(PerlIO * f, const char *mode)
{
    dTHX;
    FILE *stdio = NULL;
    if (PerlIOValid(f)) {
	char buf[8];
        int fd = PerlIO_fileno(f);
        if (fd < 0) {
            return NULL;
        }
	PerlIO_flush(f);
	if (!mode || !*mode) {
	    mode = PerlIO_modestr(f, buf);
	}
	stdio = PerlSIO_fdopen(PerlIO_fileno(f), mode);
	if (stdio) {
	    PerlIOl *l = *f;
	    PerlIO *f2;
	    /* De-link any lower layers so new :stdio sticks */
	    *f = NULL;
	    if ((f2 = PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_stdio), buf, NULL))) {
		PerlIOStdio *s = PerlIOSelf((f = f2), PerlIOStdio);
		s->stdio = stdio;
		PerlIOUnix_refcnt_inc(fileno(stdio));
		/* Link previous lower layers under new one */
		*PerlIONext(f) = l;
	    }
	    else {
		/* restore layers list */
		*f = l;
	    }
	}
    }
    return stdio;
}


FILE *
PerlIO_findFILE(PerlIO *f)
{
    PerlIOl *l = *f;
    FILE *stdio;
    while (l) {
	if (l->tab == &PerlIO_stdio) {
	    PerlIOStdio *s = PerlIOSelf(&l, PerlIOStdio);
	    return s->stdio;
	}
	l = *PerlIONext(&l);
    }
    /* Uses fallback "mode" via PerlIO_modestr() in PerlIO_exportFILE */
    /* However, we're not really exporting a FILE * to someone else (who
       becomes responsible for closing it, or calling PerlIO_releaseFILE())
       So we need to undo its reference count increase on the underlying file
       descriptor. We have to do this, because if the loop above returns you
       the FILE *, then *it* didn't increase any reference count. So there's
       only one way to be consistent. */
    stdio = PerlIO_exportFILE(f, NULL);
    if (stdio) {
	const int fd = fileno(stdio);
	if (fd >= 0)
	    PerlIOUnix_refcnt_dec(fd);
    }
    return stdio;
}

/* Use this to reverse PerlIO_exportFILE calls. */
void
PerlIO_releaseFILE(PerlIO *p, FILE *f)
{
    PerlIOl *l;
    while ((l = *p)) {
	if (l->tab == &PerlIO_stdio) {
	    PerlIOStdio *s = PerlIOSelf(&l, PerlIOStdio);
	    if (s->stdio == f) { /* not in a loop */
		const int fd = fileno(f);
		if (fd >= 0)
		    PerlIOUnix_refcnt_dec(fd);
		{
		    dTHX;
		    PerlIO_pop(aTHX_ p);
		}
		return;
	    }
	}
	p = PerlIONext(p);
    }
    return;
}

/*--------------------------------------------------------------------------------------*/
/*
 * perlio buffer layer
 */

IV
PerlIOBuf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    const int fd = PerlIO_fileno(f);
    if (fd >= 0 && PerlLIO_isatty(fd)) {
	PerlIOBase(f)->flags |= PERLIO_F_LINEBUF | PERLIO_F_TTY;
    }
    if (*PerlIONext(f)) {
	const Off_t posn = PerlIO_tell(PerlIONext(f));
	if (posn != (Off_t) - 1) {
	    b->posn = posn;
	}
    }
    return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
}

PerlIO *
PerlIOBuf_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *f, int narg, SV **args)
{
    if (PerlIOValid(f)) {
	PerlIO *next = PerlIONext(f);
	PerlIO_funcs *tab =
	     PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIOBase(next)->tab);
	if (tab && tab->Open)
	     next =
		  (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			       next, narg, args);
	if (!next || (*PerlIOBase(f)->tab->Pushed) (aTHX_ f, mode, PerlIOArg, self) != 0) {
	    return NULL;
	}
    }
    else {
	PerlIO_funcs *tab = PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIO_default_btm());
	int init = 0;
	if (*mode == IoTYPE_IMPLICIT) {
	    init = 1;
	    /*
	     * mode++;
	     */
	}
	if (tab && tab->Open)
	     f = (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			      f, narg, args);
	else
	     SETERRNO(EINVAL, LIB_INVARG);
	if (f) {
	    if (PerlIO_push(aTHX_ f, self, mode, PerlIOArg) == 0) {
		/*
		 * if push fails during open, open fails. close will pop us.
		 */
		PerlIO_close (f);
		return NULL;
	    } else {
		fd = PerlIO_fileno(f);
		if (init && fd == 2) {
		    /*
		     * Initial stderr is unbuffered
		     */
		    PerlIOBase(f)->flags |= PERLIO_F_UNBUF;
		}
#ifdef PERLIO_USING_CRLF
#  ifdef PERLIO_IS_BINMODE_FD
		if (PERLIO_IS_BINMODE_FD(fd))
		    PerlIO_binmode(aTHX_ f,  '<'/*not used*/, O_BINARY, NULL);
		else
#  endif
		/*
		 * do something about failing setmode()? --jhi
		 */
		PerlLIO_setmode(fd, O_BINARY);
#endif
#ifdef VMS
		/* Enable line buffering with record-oriented regular files
		 * so we don't introduce an extraneous record boundary when
		 * the buffer fills up.
		 */
		if (PerlIOBase(f)->flags & PERLIO_F_CANWRITE) {
		    Stat_t st;
		    if (PerlLIO_fstat(fd, &st) == 0
		        && S_ISREG(st.st_mode)
		        && (st.st_fab_rfm == FAB$C_VAR 
			    || st.st_fab_rfm == FAB$C_VFC)) {
			PerlIOBase(f)->flags |= PERLIO_F_LINEBUF;
		    }
		}
#endif
	    }
	}
    }
    return f;
}

/*
 * This "flush" is akin to sfio's sync in that it handles files in either
 * read or write state.  For write state, we put the postponed data through
 * the next layers.  For read state, we seek() the next layers to the
 * offset given by current position in the buffer, and discard the buffer
 * state (XXXX supposed to be for seek()able buffers only, but now it is done
 * in any case?).  Then the pass the stick further in chain.
 */
IV
PerlIOBuf_flush(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    int code = 0;
    PerlIO *n = PerlIONext(f);
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF) {
	/*
	 * write() the buffer
	 */
	const STDCHAR *buf = b->buf;
	const STDCHAR *p = buf;
	while (p < b->ptr) {
	    SSize_t count = PerlIO_write(n, p, b->ptr - p);
	    if (count > 0) {
		p += count;
	    }
	    else if (count < 0 || PerlIO_error(n)) {
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		PerlIO_save_errno(f);
		code = -1;
		break;
	    }
	}
	b->posn += (p - buf);
    }
    else if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	STDCHAR *buf = PerlIO_get_base(f);
	/*
	 * Note position change
	 */
	b->posn += (b->ptr - buf);
	if (b->ptr < b->end) {
	    /* We did not consume all of it - try and seek downstream to
	       our logical position
	     */
	    if (PerlIOValid(n) && PerlIO_seek(n, b->posn, SEEK_SET) == 0) {
		/* Reload n as some layers may pop themselves on seek */
		b->posn = PerlIO_tell(n = PerlIONext(f));
	    }
	    else {
		/* Seek failed (e.g. pipe or tty). Do NOT clear buffer or pre-read
		   data is lost for good - so return saying "ok" having undone
		   the position adjust
		 */
		b->posn -= (b->ptr - buf);
		return code;
	    }
	}
    }
    b->ptr = b->end = b->buf;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    /* We check for Valid because of dubious decision to make PerlIO_flush(NULL) flush all */
    if (PerlIOValid(n) && PerlIO_flush(n) != 0)
	code = -1;
    return code;
}

/* This discards the content of the buffer after b->ptr, and rereads
 * the buffer from the position off in the layer downstream; here off
 * is at offset corresponding to b->ptr - b->buf.
 */
IV
PerlIOBuf_fill(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    PerlIO *n = PerlIONext(f);
    SSize_t avail;
    /*
     * Down-stream flush is defined not to loose read data so is harmless.
     * we would not normally be fill'ing if there was data left in anycase.
     */
    if (PerlIO_flush(f) != 0)	/* XXXX Check that its seek() succeeded?! */
	return -1;
    if (PerlIOBase(f)->flags & PERLIO_F_TTY)
	PerlIOBase_flush_linebuf(aTHX);

    if (!b->buf)
	PerlIO_get_base(f);     /* allocate via vtable */

    assert(b->buf); /* The b->buf does get allocated via the vtable system. */

    b->ptr = b->end = b->buf;

    if (!PerlIOValid(n)) {
	PerlIOBase(f)->flags |= PERLIO_F_EOF;
	return -1;
    }

    if (PerlIO_fast_gets(n)) {
	/*
	 * Layer below is also buffered. We do _NOT_ want to call its
	 * ->Read() because that will loop till it gets what we asked for
	 * which may hang on a pipe etc. Instead take anything it has to
	 * hand, or ask it to fill _once_.
	 */
	avail = PerlIO_get_cnt(n);
	if (avail <= 0) {
	    avail = PerlIO_fill(n);
	    if (avail == 0)
		avail = PerlIO_get_cnt(n);
	    else {
		if (!PerlIO_error(n) && PerlIO_eof(n))
		    avail = 0;
	    }
	}
	if (avail > 0) {
	    STDCHAR *ptr = PerlIO_get_ptr(n);
	    const SSize_t cnt = avail;
	    if (avail > (SSize_t)b->bufsiz)
		avail = b->bufsiz;
	    Copy(ptr, b->buf, avail, STDCHAR);
	    PerlIO_set_ptrcnt(n, ptr + avail, cnt - avail);
	}
    }
    else {
	avail = PerlIO_read(n, b->ptr, b->bufsiz);
    }
    if (avail <= 0) {
	if (avail == 0)
	    PerlIOBase(f)->flags |= PERLIO_F_EOF;
	else
	{
	    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    PerlIO_save_errno(f);
	}
	return -1;
    }
    b->end = b->buf + avail;
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
    return 0;
}

SSize_t
PerlIOBuf_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    if (PerlIOValid(f)) {
        const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
	if (!b->ptr)
	    PerlIO_get_base(f);
	return PerlIOBase_read(aTHX_ f, vbuf, count);
    }
    return 0;
}

SSize_t
PerlIOBuf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    const STDCHAR *buf = (const STDCHAR *) vbuf + count;
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    SSize_t unread = 0;
    SSize_t avail;
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	PerlIO_flush(f);
    if (!b->buf)
	PerlIO_get_base(f);
    if (b->buf) {
	if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	    /*
	     * Buffer is already a read buffer, we can overwrite any chars
	     * which have been read back to buffer start
	     */
	    avail = (b->ptr - b->buf);
	}
	else {
	    /*
	     * Buffer is idle, set it up so whole buffer is available for
	     * unread
	     */
	    avail = b->bufsiz;
	    b->end = b->buf + avail;
	    b->ptr = b->end;
	    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
	    /*
	     * Buffer extends _back_ from where we are now
	     */
	    b->posn -= b->bufsiz;
	}
	if ((SSize_t) count >= 0 && avail > (SSize_t) count) {
	    /*
	     * If we have space for more than count, just move count
	     */
	    avail = count;
	}
	if (avail > 0) {
	    b->ptr -= avail;
	    buf -= avail;
	    /*
	     * In simple stdio-like ungetc() case chars will be already
	     * there
	     */
	    if (buf != b->ptr) {
		Copy(buf, b->ptr, avail, STDCHAR);
	    }
	    count -= avail;
	    unread += avail;
	    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	}
    }
    if (count > 0) {
	unread += PerlIOBase_unread(aTHX_ f, vbuf, count);
    }
    return unread;
}

SSize_t
PerlIOBuf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    const STDCHAR *buf = (const STDCHAR *) vbuf;
    const STDCHAR *flushptr = buf;
    Size_t written = 0;
    if (!b->buf)
	PerlIO_get_base(f);
    if (!(PerlIOBase(f)->flags & PERLIO_F_CANWRITE))
	return 0;
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
    	if (PerlIO_flush(f) != 0) {
	    return 0;
	}
    }	
    if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
	flushptr = buf + count;
	while (flushptr > buf && *(flushptr - 1) != '\n')
	    --flushptr;
    }
    while (count > 0) {
	SSize_t avail = b->bufsiz - (b->ptr - b->buf);
	if ((SSize_t) count >= 0 && (SSize_t) count < avail)
	    avail = count;
	if (flushptr > buf && flushptr <= buf + avail)
	    avail = flushptr - buf;
	PerlIOBase(f)->flags |= PERLIO_F_WRBUF;
	if (avail) {
	    Copy(buf, b->ptr, avail, STDCHAR);
	    count -= avail;
	    buf += avail;
	    written += avail;
	    b->ptr += avail;
	    if (buf == flushptr)
		PerlIO_flush(f);
	}
	if (b->ptr >= (b->buf + b->bufsiz))
	    if (PerlIO_flush(f) == -1)
		return -1;
    }
    if (PerlIOBase(f)->flags & PERLIO_F_UNBUF)
	PerlIO_flush(f);
    return written;
}

IV
PerlIOBuf_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    IV code;
    if ((code = PerlIO_flush(f)) == 0) {
	PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	code = PerlIO_seek(PerlIONext(f), offset, whence);
	if (code == 0) {
	    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	    b->posn = PerlIO_tell(PerlIONext(f));
	}
    }
    return code;
}

Off_t
PerlIOBuf_tell(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    /*
     * b->posn is file position where b->buf was read, or will be written
     */
    Off_t posn = b->posn;
    if ((PerlIOBase(f)->flags & PERLIO_F_APPEND) &&
        (PerlIOBase(f)->flags & PERLIO_F_WRBUF)) {
#if 1
    	/* As O_APPEND files are normally shared in some sense it is better
	   to flush :
	 */  	
	PerlIO_flush(f);
#else	
        /* when file is NOT shared then this is sufficient */
	PerlIO_seek(PerlIONext(f),0, SEEK_END);
#endif
	posn = b->posn = PerlIO_tell(PerlIONext(f));
    }
    if (b->buf) {
	/*
	 * If buffer is valid adjust position by amount in buffer
	 */
	posn += (b->ptr - b->buf);
    }
    return posn;
}

IV
PerlIOBuf_popped(pTHX_ PerlIO *f)
{
    const IV code = PerlIOBase_popped(aTHX_ f);
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
    }
    b->ptr = b->end = b->buf = NULL;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    return code;
}

IV
PerlIOBuf_close(pTHX_ PerlIO *f)
{
    const IV code = PerlIOBase_close(aTHX_ f);
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
    }
    b->ptr = b->end = b->buf = NULL;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    return code;
}

STDCHAR *
PerlIOBuf_get_ptr(pTHX_ PerlIO *f)
{
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    return b->ptr;
}

SSize_t
PerlIOBuf_get_cnt(pTHX_ PerlIO *f)
{
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF)
	return (b->end - b->ptr);
    return 0;
}

STDCHAR *
PerlIOBuf_get_base(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    PERL_UNUSED_CONTEXT;

    if (!b->buf) {
	if (!b->bufsiz)
	    b->bufsiz = PERLIOBUF_DEFAULT_BUFSIZ;
	Newxz(b->buf,b->bufsiz, STDCHAR);
	if (!b->buf) {
	    b->buf = (STDCHAR *) & b->oneword;
	    b->bufsiz = sizeof(b->oneword);
	}
	b->end = b->ptr = b->buf;
    }
    return b->buf;
}

Size_t
PerlIOBuf_bufsiz(pTHX_ PerlIO *f)
{
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    return (b->end - b->buf);
}

void
PerlIOBuf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
#ifndef DEBUGGING
    PERL_UNUSED_ARG(cnt);
#endif
    if (!b->buf)
	PerlIO_get_base(f);
    b->ptr = ptr;
    assert(PerlIO_get_cnt(f) == cnt);
    assert(b->ptr >= b->buf);
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
}

PerlIO *
PerlIOBuf_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
 return PerlIOBase_dup(aTHX_ f, o, param, flags);
}



PERLIO_FUNCS_DECL(PerlIO_perlio) = {
    sizeof(PerlIO_funcs),
    "perlio",
    sizeof(PerlIOBuf),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOBuf_pushed,
    PerlIOBuf_popped,
    PerlIOBuf_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOBuf_read,
    PerlIOBuf_unread,
    PerlIOBuf_write,
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOBuf_flush,
    PerlIOBuf_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOBuf_set_ptrcnt,
};

/*--------------------------------------------------------------------------------------*/
/*
 * Temp layer to hold unread chars when cannot do it any other way
 */

IV
PerlIOPending_fill(pTHX_ PerlIO *f)
{
    /*
     * Should never happen
     */
    PerlIO_flush(f);
    return 0;
}

IV
PerlIOPending_close(pTHX_ PerlIO *f)
{
    /*
     * A tad tricky - flush pops us, then we close new top
     */
    PerlIO_flush(f);
    return PerlIO_close(f);
}

IV
PerlIOPending_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    /*
     * A tad tricky - flush pops us, then we seek new top
     */
    PerlIO_flush(f);
    return PerlIO_seek(f, offset, whence);
}


IV
PerlIOPending_flush(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
	b->buf = NULL;
    }
    PerlIO_pop(aTHX_ f);
    return 0;
}

void
PerlIOPending_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
    if (cnt <= 0) {
	PerlIO_flush(f);
    }
    else {
	PerlIOBuf_set_ptrcnt(aTHX_ f, ptr, cnt);
    }
}

IV
PerlIOPending_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    const IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
    PerlIOl * const l = PerlIOBase(f);
    /*
     * Our PerlIO_fast_gets must match what we are pushed on, or sv_gets()
     * etc. get muddled when it changes mid-string when we auto-pop.
     */
    l->flags = (l->flags & ~(PERLIO_F_FASTGETS | PERLIO_F_UTF8)) |
	(PerlIOBase(PerlIONext(f))->
	 flags & (PERLIO_F_FASTGETS | PERLIO_F_UTF8));
    return code;
}

SSize_t
PerlIOPending_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    SSize_t avail = PerlIO_get_cnt(f);
    SSize_t got = 0;
    if ((SSize_t) count >= 0 && (SSize_t)count < avail)
	avail = count;
    if (avail > 0)
	got = PerlIOBuf_read(aTHX_ f, vbuf, avail);
    if (got >= 0 && got < (SSize_t)count) {
	const SSize_t more =
	    PerlIO_read(f, ((STDCHAR *) vbuf) + got, count - got);
	if (more >= 0 || got == 0)
	    got += more;
    }
    return got;
}

PERLIO_FUNCS_DECL(PerlIO_pending) = {
    sizeof(PerlIO_funcs),
    "pending",
    sizeof(PerlIOBuf),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,  /* not sure about RAW here */
    PerlIOPending_pushed,
    PerlIOBuf_popped,
    NULL,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOPending_read,
    PerlIOBuf_unread,
    PerlIOBuf_write,
    PerlIOPending_seek,
    PerlIOBuf_tell,
    PerlIOPending_close,
    PerlIOPending_flush,
    PerlIOPending_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOPending_set_ptrcnt,
};



/*--------------------------------------------------------------------------------------*/
/*
 * crlf - translation On read translate CR,LF to "\n" we do this by
 * overriding ptr/cnt entries to hand back a line at a time and keeping a
 * record of which nl we "lied" about. On write translate "\n" to CR,LF
 *
 * c->nl points on the first byte of CR LF pair when it is temporarily
 * replaced by LF, or to the last CR of the buffer.  In the former case
 * the caller thinks that the buffer ends at c->nl + 1, in the latter
 * that it ends at c->nl; these two cases can be distinguished by
 * *c->nl.  c->nl is set during _getcnt() call, and unset during
 * _unread() and _flush() calls.
 * It only matters for read operations.
 */

typedef struct {
    PerlIOBuf base;             /* PerlIOBuf stuff */
    STDCHAR *nl;                /* Position of crlf we "lied" about in the
				 * buffer */
} PerlIOCrlf;

/* Inherit the PERLIO_F_UTF8 flag from previous layer.
 * Otherwise the :crlf layer would always revert back to
 * raw mode.
 */
static void
S_inherit_utf8_flag(PerlIO *f)
{
    PerlIO *g = PerlIONext(f);
    if (PerlIOValid(g)) {
	if (PerlIOBase(g)->flags & PERLIO_F_UTF8) {
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	}
    }
}

IV
PerlIOCrlf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    IV code;
    PerlIOBase(f)->flags |= PERLIO_F_CRLF;
    code = PerlIOBuf_pushed(aTHX_ f, mode, arg, tab);
#if 0
    DEBUG_i(
    PerlIO_debug("PerlIOCrlf_pushed f=%p %s %s fl=%08" UVxf "\n",
		 (void*)f, PerlIOBase(f)->tab->name, (mode) ? mode : "(Null)",
		 PerlIOBase(f)->flags);
    );
#endif
    {
      /* If the old top layer is a CRLF layer, reactivate it (if
       * necessary) and remove this new layer from the stack */
	 PerlIO *g = PerlIONext(f);
	 if (PerlIOValid(g)) {
	      PerlIOl *b = PerlIOBase(g);
	      if (b && b->tab == &PerlIO_crlf) {
		   if (!(b->flags & PERLIO_F_CRLF))
			b->flags |= PERLIO_F_CRLF;
		   S_inherit_utf8_flag(g);
		   PerlIO_pop(aTHX_ f);
		   return code;
	      }
	 }
    }
    S_inherit_utf8_flag(f);
    return code;
}


SSize_t
PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
    if (c->nl) {	/* XXXX Shouldn't it be done only if b->ptr > c->nl? */
	*(c->nl) = NATIVE_0xd;
	c->nl = NULL;
    }
    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF))
	return PerlIOBuf_unread(aTHX_ f, vbuf, count);
    else {
	const STDCHAR *buf = (const STDCHAR *) vbuf + count;
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	SSize_t unread = 0;
	if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	    PerlIO_flush(f);
	if (!b->buf)
	    PerlIO_get_base(f);
	if (b->buf) {
	    if (!(PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
		b->end = b->ptr = b->buf + b->bufsiz;
		PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
		b->posn -= b->bufsiz;
	    }
	    while (count > 0 && b->ptr > b->buf) {
		const int ch = *--buf;
		if (ch == '\n') {
		    if (b->ptr - 2 >= b->buf) {
			*--(b->ptr) = NATIVE_0xa;
			*--(b->ptr) = NATIVE_0xd;
			unread++;
			count--;
		    }
		    else {
		    /* If b->ptr - 1 == b->buf, we are undoing reading 0xa */
                        *--(b->ptr) = NATIVE_0xa;   /* Works even if 0xa ==
                                                       '\r' */
			unread++;
			count--;
		    }
		}
		else {
		    *--(b->ptr) = ch;
		    unread++;
		    count--;
		}
	    }
	}
        if (count > 0)
            unread += PerlIOBase_unread(aTHX_ f, (const STDCHAR *) vbuf + unread, count);
	return unread;
    }
}

/* XXXX This code assumes that buffer size >=2, but does not check it... */
SSize_t
PerlIOCrlf_get_cnt(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
	if ((PerlIOBase(f)->flags & PERLIO_F_CRLF) && (!c->nl || *c->nl == NATIVE_0xd)) {
	    STDCHAR *nl = (c->nl) ? c->nl : b->ptr;
	  scan:
	    while (nl < b->end && *nl != NATIVE_0xd)
		nl++;
	    if (nl < b->end && *nl == NATIVE_0xd) {
	      test:
		if (nl + 1 < b->end) {
		    if (nl[1] == NATIVE_0xa) {
			*nl = '\n';
			c->nl = nl;
		    }
		    else {
			/*
			 * Not CR,LF but just CR
			 */
			nl++;
			goto scan;
		    }
		}
		else {
		    /*
		     * Blast - found CR as last char in buffer
		     */

		    if (b->ptr < nl) {
			/*
			 * They may not care, defer work as long as
			 * possible
			 */
			c->nl = nl;
			return (nl - b->ptr);
		    }
		    else {
			int code;
			b->ptr++;       /* say we have read it as far as
					 * flush() is concerned */
			b->buf++;       /* Leave space in front of buffer */
			/* Note as we have moved buf up flush's
			   posn += ptr-buf
			   will naturally make posn point at CR
			 */
			b->bufsiz--;    /* Buffer is thus smaller */
			code = PerlIO_fill(f);  /* Fetch some more */
			b->bufsiz++;    /* Restore size for next time */
			b->buf--;       /* Point at space */
			b->ptr = nl = b->buf;   /* Which is what we hand
						 * off */
			*nl = NATIVE_0xd;      /* Fill in the CR */
			if (code == 0)
			    goto test;  /* fill() call worked */
			/*
			 * CR at EOF - just fall through
			 */
			/* Should we clear EOF though ??? */
		    }
		}
	    }
	}
	return (((c->nl) ? (c->nl + 1) : b->end) - b->ptr);
    }
    return 0;
}

void
PerlIOCrlf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (!ptr) {
	if (c->nl) {
	    ptr = c->nl + 1;
	    if (ptr == b->end && *c->nl == NATIVE_0xd) {
		/* Deferred CR at end of buffer case - we lied about count */
		ptr--;
	    }
	}
	else {
	    ptr = b->end;
	}
	ptr -= cnt;
    }
    else {
	NOOP;
#if 0
	/*
	 * Test code - delete when it works ...
	 */
	IV flags = PerlIOBase(f)->flags;
	STDCHAR *chk = (c->nl) ? (c->nl+1) : b->end;
	if (ptr+cnt == c->nl && c->nl+1 == b->end && *c->nl == NATIVE_0xd) {
	  /* Deferred CR at end of buffer case - we lied about count */
	  chk--;
	}
	chk -= cnt;

	if (ptr != chk ) {
	    Perl_croak(aTHX_ "ptr wrong %p != %p fl=%08" UVxf
		       " nl=%p e=%p for %d", (void*)ptr, (void*)chk,
		       flags, c->nl, b->end, cnt);
	}
#endif
    }
    if (c->nl) {
	if (ptr > c->nl) {
	    /*
	     * They have taken what we lied about
	     */
	    *(c->nl) = NATIVE_0xd;
	    c->nl = NULL;
	    ptr++;
	}
    }
    b->ptr = ptr;
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
}

SSize_t
PerlIOCrlf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF))
	return PerlIOBuf_write(aTHX_ f, vbuf, count);
    else {
	PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
	const STDCHAR *buf = (const STDCHAR *) vbuf;
	const STDCHAR * const ebuf = buf + count;
	if (!b->buf)
	    PerlIO_get_base(f);
	if (!(PerlIOBase(f)->flags & PERLIO_F_CANWRITE))
	    return 0;
	while (buf < ebuf) {
	    const STDCHAR * const eptr = b->buf + b->bufsiz;
	    PerlIOBase(f)->flags |= PERLIO_F_WRBUF;
	    while (buf < ebuf && b->ptr < eptr) {
		if (*buf == '\n') {
		    if ((b->ptr + 2) > eptr) {
			/*
			 * Not room for both
			 */
			PerlIO_flush(f);
			break;
		    }
		    else {
			*(b->ptr)++ = NATIVE_0xd;      /* CR */
			*(b->ptr)++ = NATIVE_0xa;      /* LF */
			buf++;
			if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
			    PerlIO_flush(f);
			    break;
			}
		    }
		}
		else {
		    *(b->ptr)++ = *buf++;
		}
		if (b->ptr >= eptr) {
		    PerlIO_flush(f);
		    break;
		}
	    }
	}
	if (PerlIOBase(f)->flags & PERLIO_F_UNBUF)
	    PerlIO_flush(f);
	return (buf - (STDCHAR *) vbuf);
    }
}

IV
PerlIOCrlf_flush(pTHX_ PerlIO *f)
{
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
    if (c->nl) {
	*(c->nl) = NATIVE_0xd;
	c->nl = NULL;
    }
    return PerlIOBuf_flush(aTHX_ f);
}

IV
PerlIOCrlf_binmode(pTHX_ PerlIO *f)
{
    if ((PerlIOBase(f)->flags & PERLIO_F_CRLF)) {
	/* In text mode - flush any pending stuff and flip it */
	PerlIOBase(f)->flags &= ~PERLIO_F_CRLF;
#ifndef PERLIO_USING_CRLF
	/* CRLF is unusual case - if this is just the :crlf layer pop it */
	PerlIO_pop(aTHX_ f);
#endif
    }
    return 0;
}

PERLIO_FUNCS_DECL(PerlIO_crlf) = {
    sizeof(PerlIO_funcs),
    "crlf",
    sizeof(PerlIOCrlf),
    PERLIO_K_BUFFERED | PERLIO_K_CANCRLF | PERLIO_K_RAW,
    PerlIOCrlf_pushed,
    PerlIOBuf_popped,         /* popped */
    PerlIOBuf_open,
    PerlIOCrlf_binmode,       /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOBuf_read,             /* generic read works with ptr/cnt lies */
    PerlIOCrlf_unread,          /* Put CR,LF in buffer for each '\n' */
    PerlIOCrlf_write,           /* Put CR,LF in buffer for each '\n' */
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOCrlf_flush,
    PerlIOBuf_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOCrlf_get_cnt,
    PerlIOCrlf_set_ptrcnt,
};

PerlIO *
Perl_PerlIO_stdin(pTHX)
{
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return (PerlIO*)&PL_perlio[1];
}

PerlIO *
Perl_PerlIO_stdout(pTHX)
{
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return (PerlIO*)&PL_perlio[2];
}

PerlIO *
Perl_PerlIO_stderr(pTHX)
{
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return (PerlIO*)&PL_perlio[3];
}

/*--------------------------------------------------------------------------------------*/

char *
PerlIO_getname(PerlIO *f, char *buf)
{
#ifdef VMS
    dTHX;
    char *name = NULL;
    bool exported = FALSE;
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (!stdio) {
	stdio = PerlIO_exportFILE(f,0);
	exported = TRUE;
    }
    if (stdio) {
	name = fgetname(stdio, buf);
	if (exported) PerlIO_releaseFILE(f,stdio);
    }
    return name;
#else
    PERL_UNUSED_ARG(f);
    PERL_UNUSED_ARG(buf);
    Perl_croak_nocontext("Don't know how to get file name");
    return NULL;
#endif
}


/*--------------------------------------------------------------------------------------*/
/*
 * Functions which can be called on any kind of PerlIO implemented in
 * terms of above
 */

#undef PerlIO_fdopen
PerlIO *
PerlIO_fdopen(int fd, const char *mode)
{
    dTHX;
    return PerlIO_openn(aTHX_ NULL, mode, fd, 0, 0, NULL, 0, NULL);
}

#undef PerlIO_open
PerlIO *
PerlIO_open(const char *path, const char *mode)
{
    dTHX;
    SV *name = sv_2mortal(newSVpv(path, 0));
    return PerlIO_openn(aTHX_ NULL, mode, -1, 0, 0, NULL, 1, &name);
}

#undef Perlio_reopen
PerlIO *
PerlIO_reopen(const char *path, const char *mode, PerlIO *f)
{
    dTHX;
    SV *name = sv_2mortal(newSVpv(path,0));
    return PerlIO_openn(aTHX_ NULL, mode, -1, 0, 0, f, 1, &name);
}

#undef PerlIO_getc
int
PerlIO_getc(PerlIO *f)
{
    dTHX;
    STDCHAR buf[1];
    if ( 1 == PerlIO_read(f, buf, 1) ) {
	return (unsigned char) buf[0];
    }
    return EOF;
}

#undef PerlIO_ungetc
int
PerlIO_ungetc(PerlIO *f, int ch)
{
    dTHX;
    if (ch != EOF) {
	STDCHAR buf = ch;
	if (PerlIO_unread(f, &buf, 1) == 1)
	    return ch;
    }
    return EOF;
}

#undef PerlIO_putc
int
PerlIO_putc(PerlIO *f, int ch)
{
    dTHX;
    STDCHAR buf = ch;
    return PerlIO_write(f, &buf, 1);
}

#undef PerlIO_puts
int
PerlIO_puts(PerlIO *f, const char *s)
{
    dTHX;
    return PerlIO_write(f, s, strlen(s));
}

#undef PerlIO_rewind
void
PerlIO_rewind(PerlIO *f)
{
    dTHX;
    PerlIO_seek(f, (Off_t) 0, SEEK_SET);
    PerlIO_clearerr(f);
}

#undef PerlIO_vprintf
int
PerlIO_vprintf(PerlIO *f, const char *fmt, va_list ap)
{
    dTHX;
    SV * sv;
    const char *s;
    STRLEN len;
    SSize_t wrote;
#ifdef NEED_VA_COPY
    va_list apc;
    Perl_va_copy(ap, apc);
    sv = vnewSVpvf(fmt, &apc);
    va_end(apc);
#else
    sv = vnewSVpvf(fmt, &ap);
#endif
    s = SvPV_const(sv, len);
    wrote = PerlIO_write(f, s, len);
    SvREFCNT_dec(sv);
    return wrote;
}

#undef PerlIO_printf
int
PerlIO_printf(PerlIO *f, const char *fmt, ...)
{
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
}

#undef PerlIO_stdoutf
int
PerlIO_stdoutf(const char *fmt, ...)
{
    dTHX;
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vprintf(PerlIO_stdout(), fmt, ap);
    va_end(ap);
    return result;
}

#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
{
#ifndef WIN32
     dTHX;
#endif
     PerlIO *f = NULL;
#ifdef WIN32
     const int fd = win32_tmpfd();
     if (fd >= 0)
	  f = PerlIO_fdopen(fd, "w+b");
#else /* WIN32 */
#    if defined(HAS_MKSTEMP) && ! defined(VMS) && ! defined(OS2)
     int fd = -1;
     char tempname[] = "/tmp/PerlIO_XXXXXX";
     const char * const tmpdir = TAINTING_get ? NULL : PerlEnv_getenv("TMPDIR");
     SV * sv = NULL;
     int old_umask = umask(0177);
     /*
      * I have no idea how portable mkstemp() is ... NI-S
      */
     if (tmpdir && *tmpdir) {
	 /* if TMPDIR is set and not empty, we try that first */
	 sv = newSVpv(tmpdir, 0);
	 sv_catpv(sv, tempname + 4);
	 fd = mkstemp(SvPVX(sv));
     }
     if (fd < 0) {
	 SvREFCNT_dec(sv);
	 sv = NULL;
	 /* else we try /tmp */
	 fd = mkstemp(tempname);
     }
     if (fd < 0) {
         /* Try cwd */
         sv = newSVpvs(".");
         sv_catpv(sv, tempname + 4);
         fd = mkstemp(SvPVX(sv));
     }
     umask(old_umask);
     if (fd >= 0) {
	  f = PerlIO_fdopen(fd, "w+");
	  if (f)
	       PerlIOBase(f)->flags |= PERLIO_F_TEMP;
	  PerlLIO_unlink(sv ? SvPVX_const(sv) : tempname);
     }
     SvREFCNT_dec(sv);
#    else	/* !HAS_MKSTEMP, fallback to stdio tmpfile(). */
     FILE * const stdio = PerlSIO_tmpfile();

     if (stdio)
	  f = PerlIO_fdopen(fileno(stdio), "w+");

#    endif /* else HAS_MKSTEMP */
#endif /* else WIN32 */
     return f;
}

void
Perl_PerlIO_save_errno(pTHX_ PerlIO *f)
{
    if (!PerlIOValid(f))
	return;
    PerlIOBase(f)->err = errno;
#ifdef VMS
    PerlIOBase(f)->os_err = vaxc$errno;
#elif defined(OS2)
    PerlIOBase(f)->os_err = Perl_rc;
#elif defined(WIN32)
    PerlIOBase(f)->os_err = GetLastError();
#endif
}

void
Perl_PerlIO_restore_errno(pTHX_ PerlIO *f)
{
    if (!PerlIOValid(f))
	return;
    SETERRNO(PerlIOBase(f)->err, PerlIOBase(f)->os_err);
#ifdef OS2
    Perl_rc = PerlIOBase(f)->os_err);
#elif defined(WIN32)
    SetLastError(PerlIOBase(f)->os_err);
#endif
}

#undef HAS_FSETPOS
#undef HAS_FGETPOS


/*======================================================================================*/
/*
 * Now some functions in terms of above which may be needed even if we are
 * not in true PerlIO mode
 */
const char *
Perl_PerlIO_context_layers(pTHX_ const char *mode)
{
    const char *direction = NULL;
    SV *layers;
    /*
     * Need to supply default layer info from open.pm
     */

    if (!PL_curcop)
	return NULL;

    if (mode && mode[0] != 'r') {
	if (PL_curcop->cop_hints & HINT_LEXICAL_IO_OUT)
	    direction = "open>";
    } else {
	if (PL_curcop->cop_hints & HINT_LEXICAL_IO_IN)
	    direction = "open<";
    }
    if (!direction)
	return NULL;

    layers = cop_hints_fetch_pvn(PL_curcop, direction, 5, 0, 0);

    assert(layers);
    return SvOK(layers) ? SvPV_nolen_const(layers) : NULL;
}


#ifndef HAS_FSETPOS
#undef PerlIO_setpos
int
PerlIO_setpos(PerlIO *f, SV *pos)
{
    if (SvOK(pos)) {
	if (f) {
	    dTHX;
	    STRLEN len;
	    const Off_t * const posn = (Off_t *) SvPV(pos, len);
	    if(len == sizeof(Off_t))
		return PerlIO_seek(f, *posn, SEEK_SET);
	}
    }
    SETERRNO(EINVAL, SS_IVCHAN);
    return -1;
}
#else
#undef PerlIO_setpos
int
PerlIO_setpos(PerlIO *f, SV *pos)
{
    if (SvOK(pos)) {
	if (f) {
	    dTHX;
	    STRLEN len;
	    Fpos_t * const fpos = (Fpos_t *) SvPV(pos, len);
	    if(len == sizeof(Fpos_t))
#if defined(USE_64_BIT_STDIO) && defined(USE_FSETPOS64)
		return fsetpos64(f, fpos);
#else
		return fsetpos(f, fpos);
#endif
	}
    }
    SETERRNO(EINVAL, SS_IVCHAN);
    return -1;
}
#endif

#ifndef HAS_FGETPOS
#undef PerlIO_getpos
int
PerlIO_getpos(PerlIO *f, SV *pos)
{
    dTHX;
    Off_t posn = PerlIO_tell(f);
    sv_setpvn(pos, (char *) &posn, sizeof(posn));
    return (posn == (Off_t) - 1) ? -1 : 0;
}
#else
#undef PerlIO_getpos
int
PerlIO_getpos(PerlIO *f, SV *pos)
{
    dTHX;
    Fpos_t fpos;
    int code;
#if defined(USE_64_BIT_STDIO) && defined(USE_FSETPOS64)
    code = fgetpos64(f, &fpos);
#else
    code = fgetpos(f, &fpos);
#endif
    sv_setpvn(pos, (char *) &fpos, sizeof(fpos));
    return code;
}
#endif

#if !defined(HAS_VPRINTF)

int
vprintf(char *pat, char *args)
{
    _doprnt(pat, args, stdout);
    return 0;                   /* wrong, but perl doesn't use the return
				 * value */
}

int
vfprintf(FILE *fd, char *pat, char *args)
{
    _doprnt(pat, args, fd);
    return 0;                   /* wrong, but perl doesn't use the return
				 * value */
}

#endif

/* print a failure format string message to stderr and fail exit the process
   using only libc without depending on any perl data structures being
   initialized.
*/

void
Perl_noperl_die(const char* pat, ...)
{
    va_list(arglist);
    PERL_ARGS_ASSERT_NOPERL_DIE;
    va_start(arglist, pat);
    vfprintf(stderr, pat, arglist);
    va_end(arglist);
    exit(1);
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d202 3
d207 1
a340 23
#ifdef PERLIO_IS_STDIO

void
PerlIO_init(pTHX)
{
    PERL_UNUSED_CONTEXT;
    /*
     * Does nothing (yet) except force this file to be included in perl
     * binary. That allows this file to force inclusion of other functions
     * that may be required by loadable extensions e.g. for
     * FileHandle::tmpfile
     */
}

#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
{
    return tmpfile();
}

#else                           /* PERLIO_IS_STDIO */

d354 4
d367 1
a367 1
		PL_perlio_debug_fd = -1;
d369 3
a371 3
	    /* tainting or set*id, so ignore the environment, and ensure we
	       skip these tests next time through.  */
	    PL_perlio_debug_fd = -1;
d412 3
a449 1
    dVAR;
d461 1
a461 4
		f->flags = 0; /* lockcnt */
		f->tab = NULL;
		f->head = f;
		return (PerlIO *)f;
d470 2
d484 1
a484 1
	PerlIO_debug("fdupopen f=%p param=%p\n",(void*)f,(void*)param);
a544 1
    dVAR;
d593 1
a593 1
    PerlIO_debug("Clone %p from %p\n",(void*)aTHX,(void*)proto);
a613 1
    dVAR;
d617 1
a617 1
    PerlIO_debug("Destruct %p\n",(void*)aTHX);
d627 1
a627 1
		    PerlIO_debug("Destruct popping %s\n", l->tab->name);
d646 2
a647 2
	PerlIO_debug("PerlIO_pop f=%p %s\n", (void*)f,
			    l->tab ? l->tab->name : "(Null)");
a678 1
    dVAR;
d712 1
a712 1
    dVAR;
d720 1
a720 1
	    PerlIO_debug("%.*s => %p\n", (int) len, name, (void*)f);
d748 1
a748 1
    PerlIO_debug("Cannot find %.*s\n", (int) len, name);
d833 1
a833 1
#endif                          /* USE_ATTIBUTES_FOR_PERLIO */
a848 1
    dVAR;
d851 3
a853 2
    if (items)
    	PerlIO_debug("warning:%s\n",SvPV_nolen_const(ST(0)));
a859 1
    dVAR;
d867 1
a867 1
	const bool load = (items > 2) ? SvTRUE(ST(2)) : 0;
a878 1
    dVAR;
d882 1
a882 1
    PerlIO_debug("define %s %p\n", tab->name, (void*)tab);
a887 1
    dVAR;
a979 1
    dVAR;
d987 2
a988 3
    PerlIO_debug("Pushing %s\n", tab->name);
    PerlIO_list_push(aTHX_ av, PerlIO_find_layer(aTHX_ tab->name, 0, 0),
		     &PL_sv_undef);
d1001 2
a1002 2
	PerlIO_debug("Layer %" IVdf " is %s\n", n,
		     av->array[n].funcs->name);
a1057 1
    dVAR;
d1076 2
a1077 3
	PerlIO_list_push(aTHX_ PL_def_layerlist,
			 PerlIO_find_layer(aTHX_ osLayer->name, 0, 0),
			 &PL_sv_undef);
a1104 1
    dVAR;
a1116 1
    dVAR;
d1153 3
a1155 3
		PerlIO_debug("PerlIO_push f=%p %s %s %p\n",
			     (void*)f, tab->name,
			     (mode) ? mode : "(Null)", (void*)arg);
d1169 2
a1170 2
	PerlIO_debug("PerlIO_push f=%p %s %s %p\n", (void*)f, tab->name,
		     (mode) ? mode : "(Null)", (void*)arg);
d1249 2
a1250 2
	    PerlIO_debug(":raw f=%p :%s\n", (void*)f,
		PerlIOBase(f)->tab ? PerlIOBase(f)->tab->name : "(Null)");
d1302 5
a1306 4
    PerlIO_debug("PerlIO_binmode f=%p %s %c %x %s\n", (void*)f,
                 (PerlIOBase(f) && PerlIOBase(f)->tab) ?
		       	PerlIOBase(f)->tab->name : "(Null)",
                 iotype, mode, (names) ? names : "(Null)");
d1391 1
a1391 2
    dVAR;
     Perl_PerlIO_or_Base(f, Fileno, fileno, -1, (aTHX_ f));
a1397 1
    dVAR;
a1431 1
    dVAR;
d1442 1
a1442 1
	if (SvROK(arg) && !sv_isobject(arg)) {
a1484 1
    dVAR;
d1539 3
a1541 3
	    PerlIO_debug("openn(%s,'%s','%s',%d,%x,%o,%p,%d,%p)\n",
			 tab->name, layers ? layers : "(Null)", mode, fd,
			 imode, perm, (void*)f, narg, (void*)args);
a1607 1
    dVAR;
d1618 1
a1618 1
	    PerlIO_debug("Cannot flush f=%p\n", (void*)f);
a1649 1
    dVAR;
d2010 1
d2014 1
d2047 1
d2197 6
a2202 5
	PerlIO_debug("PerlIOBase_dup %s f=%p o=%p param=%p\n",
		     self ? self->name : "(Null)",
		     (void*)f, (void*)o, (void*)param);
	if (self && self->Getarg)
	    arg = (*self->Getarg)(aTHX_ o, param, flags);
d2215 3
a2217 1
S_more_refcounted_fds(pTHX_ const int new_fd) {
d2223 6
a2228 2
    PerlIO_debug("More fds - old=%d, need %d, new=%d\n",
		 old_max, new_fd, new_max);
d2250 3
a2252 3
    PerlIO_debug("Zeroing %p, %d\n",
		 (void*)(new_array + old_max),
		 new_max - old_max);
d2284 2
a2285 2
	PerlIO_debug("refcnt_inc: fd %d refcnt=%d\n",
		     fd, PL_perlio_fd_refcnt[fd]);
d2301 3
d2305 1
d2320 1
a2320 1
	PerlIO_debug("refcnt_dec: fd %d refcnt=%d\n", fd, cnt);
a2364 1
    dVAR;
d2367 1
a2367 1
    PerlIO_debug("Cleanup layers for %p\n",(void*)aTHX);
d2369 1
a2369 1
    PerlIO_debug("Cleanup layers\n");
d2444 3
d2514 10
a2523 2
    if (*mode == 'b') {
	oflags |= O_BINARY;
d2525 5
a2529 3
	mode++;
    }
    else if (*mode == 't') {
d2532 6
a2537 4
	mode++;
    }
    else {
#ifdef PERLIO_USING_CRLF
d2541 4
d2547 2
a2548 1
#endif
d2572 1
a2572 1
	    PerlIO_debug("%d is not regular file\n",fd);
d2576 1
a2576 1
	    PerlIO_debug("%d _is_ a regular file\n",fd);
a2707 1
    dVAR;
d2726 1
d2739 1
a2739 1
    /*NOTREACHED*/
a2744 1
    dVAR;
d2759 1
d2768 1
a2768 1
    /*NOTREACHED*/
a2782 1
    dVAR;
d2924 5
d2931 15
d2954 6
a2959 2
	    const int fd = PerlLIO_dup(fileno(stdio));
	    FILE *f2 = PerlSIO_fdopen(fd, (mode = "r+"));
d2973 1
a2973 1
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), PERLIO_FUNCS_CAST(&PerlIO_stdio), mode, NULL))) {
d2976 16
d2993 1
d3013 2
a3014 2
	stdio = PerlSIO_freopen(path, (mode = PerlIOStdio_mode(mode, tmode)),
			    s->stdio);
d3141 3
a3143 1
#  if defined(__UCLIBC__)
d3256 22
a3285 20
#ifdef USE_ITHREADS
		MUTEX_LOCK(&PL_perlio_mutex);
		/* Right. We need a mutex here because for a brief while we
		   will have the situation that fd is actually closed. Hence if
		   a second thread were to get into this block, its dup() would
		   likely return our fd as its dupfd. (after all, it is closed)
		   Then if we get to the dup2() first, we blat the fd back
		   (messing up its temporary as a side effect) only for it to
		   then close its dupfd (== our fd) in its close(dupfd) */

		/* There is, of course, a race condition, that any other thread
		   trying to input/output/whatever on this fd will be stuffed
		   for the duration of this little manoeuvrer. Perhaps we
		   should hold an IO mutex for the duration of every IO
		   operation if we know that invalidate doesn't work on this
		   platform, but that would suck, and could kill performance.

		   Except that correctness trumps speed.
		   Advice from klortho #11912. */
#endif
a3288 1
		    MUTEX_UNLOCK(&PL_perlio_mutex);
d3313 1
d3315 1
a3315 1
	    MUTEX_UNLOCK(&PL_perlio_mutex);
a3316 1
	}
a3323 1
    dVAR;
d3352 6
d3404 2
a3405 2
		fgetc(s);  /* get char back again */
		break;
a3421 1
    dVAR;
d3557 12
d3570 1
a3658 8
#if defined(VMS)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we stuff it in the buffer ourselves.
     * Should never get called as should hit code above
     */
    *(--((*stdio)->_ptr)) = (unsigned char) c;
    (*stdio)->_cnt++;
#else
d3664 1
a3664 1
#endif
d3725 4
a3787 1
    dVAR;
d3935 1
d4038 1
d4040 2
d4508 1
d4512 1
a4824 1
    dVAR;
a4833 1
    dVAR;
a4842 1
    dVAR;
d5026 1
d5048 1
d5067 28
a5097 1
#endif                          /* PERLIO_IS_STDIO */
a5106 1
    dVAR;
d5139 7
a5145 5
	STRLEN len;
	dTHX;
	const Off_t * const posn = (Off_t *) SvPV(pos, len);
	if (f && len == sizeof(Off_t))
	    return PerlIO_seek(f, *posn, SEEK_SET);
a5154 1
    dTHX;
d5156 5
a5160 3
	STRLEN len;
	Fpos_t * const fpos = (Fpos_t *) SvPV(pos, len);
	if (f && len == sizeof(Fpos_t)) {
d5162 1
a5162 1
	    return fsetpos64(f, fpos);
d5164 1
a5164 1
	    return fsetpos(f, fpos);
d5221 16
a5237 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a33 11
#define VOIDUSED 1
#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   ifndef USE_CROSS_COMPILE
#       include "config.h"
#   else
#       include "xconfig.h"
#   endif
#endif

a34 5
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
/*
 * #define PerlIO FILE
 */
#endif
d117 2
a118 1
#ifndef USE_SFIO
a157 1
#endif /* sfio */
a233 6
#ifdef USE_SFIO
    PERL_UNUSED_ARG(iotype);
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(names);
    return 1;
#else
a234 1
#endif
d289 5
a293 1
	    const char *name = SvPV_nolen_const(*args);
d313 1
a359 61
#ifdef USE_SFIO

#undef HAS_FSETPOS
#undef HAS_FGETPOS

/*
 * This section is just to make sure these functions get pulled in from
 * libsfio.a
 */

#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
{
    return sftmp(0);
}

void
PerlIO_init(pTHX)
{
    PERL_UNUSED_CONTEXT;
    /*
     * Force this file to be included in perl binary. Which allows this
     * file to force inclusion of other functions that may be required by
     * loadable extensions e.g. for FileHandle::tmpfile
     */

    /*
     * Hack sfio does its own 'autoflush' on stdout in common cases. Flush
     * results in a lot of lseek()s to regular files and lot of small
     * writes to pipes.
     */
    sfset(sfstdout, SF_SHARE, 0);
}

/* This is not the reverse of PerlIO_exportFILE(), PerlIO_releaseFILE() is. */
PerlIO *
PerlIO_importFILE(FILE *stdio, const char *mode)
{
    const int fd = fileno(stdio);
    if (!mode || !*mode) {
	mode = "r+";
    }
    return PerlIO_fdopen(fd, mode);
}

FILE *
PerlIO_findFILE(PerlIO *pio)
{
    const int fd = PerlIO_fileno(pio);
    FILE * const f = fdopen(fd, "r+");
    PerlIO_flush(pio);
    if (!f && errno == EINVAL)
	f = fdopen(fd, "w");
    if (!f && errno == EINVAL)
	f = fdopen(fd, "r");
    return f;
}


#else                           /* USE_SFIO */
d396 1
a396 1
	PerlLIO_write(PL_perlio_debug_fd, buffer, len1 + len2);
d405 1
a405 1
	PerlLIO_write(PL_perlio_debug_fd, s, len);
d586 1
a586 1
#ifdef sv_dup
d819 1
d860 1
d874 1
d1798 1
a1798 1
int
d1801 1
d1811 1
a1811 1
int
d1818 1
a1818 1
Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, int cnt)
d1824 1
a1824 1
Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, int cnt)
d2195 1
a2195 1
#ifdef sv_dup
d2646 4
a2649 1
	    const char *path = SvPV_nolen_const(*args);
d2661 1
d2697 1
d2907 1
d2964 2
a2965 1
	const char * const path = SvPV_nolen_const(*args);
d2968 2
d2981 4
a2984 1
	    const char * const path = SvPV_nolen_const(*args);
d3052 1
d3109 1
a3109 1
#  elif defined(__sun__)
d4476 1
a4476 1
	*(c->nl) = 0xd;
d4499 2
a4500 2
			*--(b->ptr) = 0xa;
			*--(b->ptr) = 0xd;
d4506 2
a4507 1
			*--(b->ptr) = 0xa;	/* Works even if 0xa == '\r' */
d4534 1
a4534 1
	if ((PerlIOBase(f)->flags & PERLIO_F_CRLF) && (!c->nl || *c->nl == 0xd)) {
d4537 1
a4537 1
	    while (nl < b->end && *nl != 0xd)
d4539 1
a4539 1
	    if (nl < b->end && *nl == 0xd) {
d4542 1
a4542 1
		    if (nl[1] == 0xa) {
d4582 1
a4582 1
			*nl = 0xd;      /* Fill in the CR */
d4608 1
a4608 1
	    if (ptr == b->end && *c->nl == 0xd) {
d4626 1
a4626 1
	if (ptr+cnt == c->nl && c->nl+1 == b->end && *c->nl == 0xd) {
d4644 1
a4644 1
	    *(c->nl) = 0xd;
d4679 2
a4680 2
			*(b->ptr)++ = 0xd;      /* CR */
			*(b->ptr)++ = 0xa;      /* LF */
d4708 1
a4708 1
	*(c->nl) = 0xd;
d4913 1
d4976 1
d4981 6
a5007 1
#endif                          /* USE_SFIO */
d5110 1
a5110 1
#if (defined(PERLIO_IS_STDIO) || !defined(USE_SFIO)) && !defined(HAS_VPRINTF)
a5127 30
#endif

#ifndef PerlIO_vsprintf
int
PerlIO_vsprintf(char *s, int n, const char *fmt, va_list ap)
{
    dTHX; 
    const int val = my_vsnprintf(s, n > 0 ? n : 0, fmt, ap);
    PERL_UNUSED_CONTEXT;

#ifndef PERL_MY_VSNPRINTF_GUARDED
    if (val < 0 || (n > 0 ? val >= n : 0)) {
	Perl_croak(aTHX_ "panic: my_vsnprintf overflow in PerlIO_vsprintf\n");
    }
#endif
    return val;
}
#endif

#ifndef PerlIO_sprintf
int
PerlIO_sprintf(char *s, int n, const char *fmt, ...)
{
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vsprintf(s, n, fmt, ap);
    va_end(ap);
    return result;
}
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d73 4
a143 11
#  if defined(atarist)
    PERL_UNUSED_ARG(iotype);
    if (!fflush(fp)) {
        if (mode & O_BINARY)
            ((FILE *) fp)->_flag |= _IOBIN;
        else
            ((FILE *) fp)->_flag &= ~_IOBIN;
        return 1;
    }
    return 0;
#  else
a154 1
#  endif
d453 1
a453 1
	if (!PL_tainting &&
a468 1
	dTHX;
d814 2
a815 1
	if (memEQ(f->name, name, len) && f->name[len] == 0) {
d1009 1
a1009 1
		} while (isALNUM(*e));
d1158 1
a1158 1
	const char * const s = (PL_tainting) ? NULL : PerlEnv_getenv("PERLIO");
d2306 1
a2306 1
	if (PerlIOBase(o)->flags & PERLIO_F_UTF8)
d2340 1
a2340 4
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
a2394 1
    dTHX;
d2403 1
a2403 1
	    Perl_croak(aTHX_ "refcnt_dec: fd %d >= refcnt_size %d\n",
d2408 1
a2408 1
	    Perl_croak(aTHX_ "refcnt_dec: fd %d: %d <= 0\n",
d2418 1
a2418 1
	Perl_croak(aTHX_ "refcnt_dec: fd %d < 0\n", fd);
d2614 9
a2622 4
    /*
     * Always open in binary mode
     */
    oflags |= O_BINARY;
d3797 1
a3797 2
	    if (s->stdio == f) {
		dTHX;
d3801 4
a3804 1
		PerlIO_pop(aTHX_ p);
a3892 1
#include <rms.h>
d4580 2
d4855 1
a4856 1
#ifdef VMS
d4872 1
a4872 1
    Perl_croak(aTHX_ "Don't know how to get file name");
d5012 1
d5014 1
d5024 1
a5024 1
     const char * const tmpdir = PL_tainting ? NULL : PerlEnv_getenv("TMPDIR");
a5103 1
    dTHX;
d5106 1
d5218 1
a5218 1
 * indent-tabs-mode: t
d5221 1
a5221 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008 Larry Wall and others
d73 2
a157 17
#    if defined(WIN32) && defined(__BORLANDC__)
        /*
         * The translation mode of the stream is maintained independent 
of
         * the translation mode of the fd in the Borland RTL (heavy
         * digging through their runtime sources reveal).  User has to 
set
         * the mode explicitly for the stream (though they don't 
document
         * this anywhere). GSAR 97-5-24
         */
        fseek(fp, 0L, 0);
        if (mode & O_BINARY)
            fp->flags |= _F_BIN;
        else
            fp->flags &= ~_F_BIN;
#    endif
a453 11
/*
 * We _MUST_ have <unistd.h> if we are using lseek() and may have large
 * files
 */
#ifdef I_UNISTD
#include <unistd.h>
#endif
#ifdef HAS_MMAP
#include <sys/mman.h>
#endif

d461 3
a463 1
	if (!PL_tainting && PL_uid == PL_euid && PL_gid == PL_egid) {
d506 26
d537 10
d554 2
a555 2
    PerlIO **last;
    PerlIO *f;
d559 1
a559 1
	last = (PerlIO **) (f);
d561 5
a565 2
	    if (!*++f) {
		return f;
d569 1
a569 1
    Newxz(f,PERLIO_TABLE_SIZE,PerlIO);
d573 5
a577 2
    *last = f;
    return f + 1;
d600 1
a600 1
PerlIO_cleantable(pTHX_ PerlIO **tablep)
d602 1
a602 1
    PerlIO * const table = *tablep;
d605 1
a605 1
	PerlIO_cleantable(aTHX_(PerlIO **) & (table[0]));
d607 3
a609 3
	    PerlIO * const f = table + i;
	    if (*f) {
		PerlIO_close(f);
d690 2
a691 2
    PerlIO **table = &proto->Iperlio;
    PerlIO *f;
d695 1
a695 1
    PerlIO_allocate(aTHX); /* root slot is never used */
d699 1
a699 1
	    table = (PerlIO **) (f++);
d701 2
a702 2
		if (*f) {
		    (void) fp_dup(f, 0, param);
d718 2
a719 2
    PerlIO **table = &PL_perlio;
    PerlIO *f;
d725 1
a725 1
	table = (PerlIO **) (f++);
d727 1
a727 1
	    PerlIO *x = f;
d730 1
a730 1
		if (l->tab->kind & PERLIO_K_DESTRUCT) {
d748 1
d750 3
a752 2
	PerlIO_debug("PerlIO_pop f=%p %s\n", (void*)f, l->tab->name);
	if (l->tab->Popped) {
d761 10
a770 2
	*f = l->next;
	Safefree(l);
d838 1
a838 1
	    SAVEINT(PL_in_load_module);
d843 1
a843 1
	    PL_in_load_module++;
a847 1
	    PL_in_load_module--;
d948 1
a948 1
    /* This is used as a %SIG{__WARN__} handler to supress warnings
d1137 1
a1137 1
    NULL,
a1179 3
#ifdef HAS_MMAP
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_mmap));
#endif
d1228 1
a1228 1
	PerlIO_allocate(aTHX);
d1238 1
d1240 4
a1243 2
      mismatch:
	Perl_croak(aTHX_ "Layer does not match this perl");
d1248 4
a1251 1
	    goto mismatch;
d1261 1
d1289 18
d1312 1
a1312 1
	if (PerlIOBase(f)->tab->kind & PERLIO_K_RAW) {
d1341 1
a1341 1
	    if (l->tab->Binmode) {
d1359 2
a1360 1
	    PerlIO_debug(":raw f=%p :%s\n", (void*)f, PerlIOBase(f)->tab->name);
d1389 2
d1399 1
d1413 2
a1414 1
                 (PerlIOBase(f)) ? PerlIOBase(f)->tab->name : "(Null)",
d1441 3
a1443 1
		if (PerlIOBase(f)->tab->kind & PERLIO_K_CANCRLF) {
d1490 3
d1512 1
a1512 1
    if (SvTYPE(sv) < SVt_PVAV) {
d1517 1
d1619 1
a1619 1
		if (l->tab->Getarg)
d1740 1
a1740 1
	 * errorneous input? Maybe some magical value (PerlIO*
d1745 2
a1746 1
	PerlIO **table = &PL_perlio;
d1748 1
a1748 1
	while ((f = *table)) {
d1750 1
a1750 1
	    table = (PerlIO **) (f++);
d1752 1
a1752 1
		if (*f && PerlIO_flush(f) != 0)
d1754 1
a1754 1
		f++;
d1765 2
a1766 2
    PerlIO **table = &PL_perlio;
    PerlIO *f;
d1769 1
a1769 1
	table = (PerlIO **) (f++);
d1771 2
a1772 2
	    if (*f
		&& (PerlIOBase(f)->
d1775 1
a1775 1
		PerlIO_flush(f);
d1925 1
a1925 1
	if (tab->kind & PERLIO_K_UTF8)
d1938 1
a1938 1
    PERLIO_K_DUMMY | PERLIO_K_UTF8,
d1941 1
a1941 1
    NULL,
d1969 1
a1969 1
    PERLIO_K_DUMMY,
d1972 1
a1972 1
    NULL,
a1995 14
PerlIO *
PerlIORaw_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *old, int narg, SV **args)
{
    PerlIO_funcs * const tab = PerlIO_default_btm();
    PERL_UNUSED_ARG(self);
    if (tab && tab->Open)
	 return (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			      old, narg, args);
    SETERRNO(EINVAL, LIB_INVARG);
    return NULL;
}

d2003 1
a2003 1
    PerlIORaw_open,
d2080 1
a2080 1
    if (tab->Set_ptrcnt != NULL)
d2167 1
a2167 1
		take = ((SSize_t)count < avail) ? (SSize_t)count : avail;
d2309 3
a2311 2
		     self->name, (void*)f, (void*)o, (void*)param);
	if (self->Getarg)
d2387 1
d2398 1
d2414 1
d2419 1
d2429 1
d2435 31
d2546 35
d2713 1
a2713 1
	if (PerlIOBase(f)->flags & PERLIO_F_OPEN)
d2721 3
d2725 1
d2784 4
a2787 1
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2810 3
a2812 1
	PERL_ASYNC_CHECK();
d2821 4
a2824 1
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2839 3
a2841 1
	PERL_ASYNC_CHECK();
d2876 3
a2878 1
	PERL_ASYNC_CHECK();
d3219 1
a3219 3
#    if defined(__BORLANDC__)
    f->fd = PerlLIO_dup(fileno(f));
#    elif defined(UNDER_CE)
d3349 1
a3349 1
    FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;
d3351 3
d3373 2
a3374 1
	PERL_ASYNC_CHECK();
d3443 2
d3450 2
a3451 1
	PERL_ASYNC_CHECK();
d3613 1
a3613 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3616 3
d3633 2
a3634 1
	PERL_ASYNC_CHECK();
d3782 1
a3782 1
       So we need to undo its refernce count increase on the underlying file
d3897 16
d4101 1
a4101 1
	if (avail > (SSize_t) count) {
d4151 1
a4151 1
	if ((SSize_t) count < avail)
d4166 2
a4167 1
	    PerlIO_flush(f);
d4273 1
a4273 1
	    b->bufsiz = 4096;
d4426 1
a4426 1
    if ((SSize_t)count < avail)
d4520 2
a4521 4
      /* Enable the first CRLF capable layer you can find, but if none
       * found, the one we just pushed is fine.  This results in at
       * any given moment at most one CRLF-capable layer being enabled
       * in the whole layer stack. */
d4523 1
a4523 1
	 while (PerlIOValid(g)) {
d4531 1
a4531 2
	      }		  
	      g = PerlIONext(g);
d4674 1
a4674 1
		/* Defered CR at end of buffer case - we lied about count */
d4692 1
a4692 1
	  /* Defered CR at end of buffer case - we lied about count */
a4823 291
#ifdef HAS_MMAP
/*--------------------------------------------------------------------------------------*/
/*
 * mmap as "buffer" layer
 */

typedef struct {
    PerlIOBuf base;             /* PerlIOBuf stuff */
    Mmap_t mptr;                /* Mapped address */
    Size_t len;                 /* mapped length */
    STDCHAR *bbuf;              /* malloced buffer if map fails */
} PerlIOMmap;

IV
PerlIOMmap_map(pTHX_ PerlIO *f)
{
    dVAR;
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    const IV flags = PerlIOBase(f)->flags;
    IV code = 0;
    if (m->len)
	abort();
    if (flags & PERLIO_F_CANREAD) {
	PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
	const int fd = PerlIO_fileno(f);
	Stat_t st;
	code = Fstat(fd, &st);
	if (code == 0 && S_ISREG(st.st_mode)) {
	    SSize_t len = st.st_size - b->posn;
	    if (len > 0) {
		Off_t posn;
		if (PL_mmap_page_size <= 0)
		  Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
			     PL_mmap_page_size);
		if (b->posn < 0) {
		    /*
		     * This is a hack - should never happen - open should
		     * have set it !
		     */
		    b->posn = PerlIO_tell(PerlIONext(f));
		}
		posn = (b->posn / PL_mmap_page_size) * PL_mmap_page_size;
		len = st.st_size - posn;
		m->mptr = (Mmap_t)mmap(NULL, len, PROT_READ, MAP_SHARED, fd, posn);
		if (m->mptr && m->mptr != (Mmap_t) - 1) {
#if 0 && defined(HAS_MADVISE) && defined(MADV_SEQUENTIAL)
		    madvise(m->mptr, len, MADV_SEQUENTIAL);
#endif
#if 0 && defined(HAS_MADVISE) && defined(MADV_WILLNEED)
		    madvise(m->mptr, len, MADV_WILLNEED);
#endif
		    PerlIOBase(f)->flags =
			(flags & ~PERLIO_F_EOF) | PERLIO_F_RDBUF;
		    b->end = ((STDCHAR *) m->mptr) + len;
		    b->buf = ((STDCHAR *) m->mptr) + (b->posn - posn);
		    b->ptr = b->buf;
		    m->len = len;
		}
		else {
		    b->buf = NULL;
		}
	    }
	    else {
		PerlIOBase(f)->flags =
		    flags | PERLIO_F_EOF | PERLIO_F_RDBUF;
		b->buf = NULL;
		b->ptr = b->end = b->ptr;
		code = -1;
	    }
	}
    }
    return code;
}

IV
PerlIOMmap_unmap(pTHX_ PerlIO *f)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    IV code = 0;
    if (m->len) {
	PerlIOBuf * const b = &m->base;
	if (b->buf) {
	    /* The munmap address argument is tricky: depending on the
	     * standard it is either "void *" or "caddr_t" (which is
	     * usually "char *" (signed or unsigned).  If we cast it
	     * to "void *", those that have it caddr_t and an uptight
	     * C++ compiler, will freak out.  But casting it as char*
	     * should work.  Maybe.  (Using Mmap_t figured out by
	     * Configure doesn't always work, apparently.) */
	    code = munmap((char*)m->mptr, m->len);
	    b->buf = NULL;
	    m->len = 0;
	    m->mptr = NULL;
	    if (PerlIO_seek(PerlIONext(f), b->posn, SEEK_SET) != 0)
		code = -1;
	}
	b->ptr = b->end = b->buf;
	PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    }
    return code;
}

STDCHAR *
PerlIOMmap_get_base(pTHX_ PerlIO *f)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
    if (b->buf && (PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
	/*
	 * Already have a readbuffer in progress
	 */
	return b->buf;
    }
    if (b->buf) {
	/*
	 * We have a write buffer or flushed PerlIOBuf read buffer
	 */
	m->bbuf = b->buf;       /* save it in case we need it again */
	b->buf = NULL;          /* Clear to trigger below */
    }
    if (!b->buf) {
	PerlIOMmap_map(aTHX_ f);        /* Try and map it */
	if (!b->buf) {
	    /*
	     * Map did not work - recover PerlIOBuf buffer if we have one
	     */
	    b->buf = m->bbuf;
	}
    }
    b->ptr = b->end = b->buf;
    if (b->buf)
	return b->buf;
    return PerlIOBuf_get_base(aTHX_ f);
}

SSize_t
PerlIOMmap_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	PerlIO_flush(f);
    if (b->ptr && (b->ptr - count) >= b->buf
	&& memEQ(b->ptr - count, vbuf, count)) {
	b->ptr -= count;
	PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	return count;
    }
    if (m->len) {
	/*
	 * Loose the unwritable mapped buffer
	 */
	PerlIO_flush(f);
	/*
	 * If flush took the "buffer" see if we have one from before
	 */
	if (!b->buf && m->bbuf)
	    b->buf = m->bbuf;
	if (!b->buf) {
	    PerlIOBuf_get_base(aTHX_ f);
	    m->bbuf = b->buf;
	}
    }
    return PerlIOBuf_unread(aTHX_ f, vbuf, count);
}

SSize_t
PerlIOMmap_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;

    if (!b->buf || !(PerlIOBase(f)->flags & PERLIO_F_WRBUF)) {
	/*
	 * No, or wrong sort of, buffer
	 */
	if (m->len) {
	    if (PerlIOMmap_unmap(aTHX_ f) != 0)
		return 0;
	}
	/*
	 * If unmap took the "buffer" see if we have one from before
	 */
	if (!b->buf && m->bbuf)
	    b->buf = m->bbuf;
	if (!b->buf) {
	    PerlIOBuf_get_base(aTHX_ f);
	    m->bbuf = b->buf;
	}
    }
    return PerlIOBuf_write(aTHX_ f, vbuf, count);
}

IV
PerlIOMmap_flush(pTHX_ PerlIO *f)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
    IV code = PerlIOBuf_flush(aTHX_ f);
    /*
     * Now we are "synced" at PerlIOBuf level
     */
    if (b->buf) {
	if (m->len) {
	    /*
	     * Unmap the buffer
	     */
	    if (PerlIOMmap_unmap(aTHX_ f) != 0)
		code = -1;
	}
	else {
	    /*
	     * We seem to have a PerlIOBuf buffer which was not mapped
	     * remember it in case we need one later
	     */
	    m->bbuf = b->buf;
	}
    }
    return code;
}

IV
PerlIOMmap_fill(pTHX_ PerlIO *f)
{
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    IV code = PerlIO_flush(f);
    if (code == 0 && !b->buf) {
	code = PerlIOMmap_map(aTHX_ f);
    }
    if (code == 0 && !(PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
	code = PerlIOBuf_fill(aTHX_ f);
    }
    return code;
}

IV
PerlIOMmap_close(pTHX_ PerlIO *f)
{
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
    IV code = PerlIO_flush(f);
    if (m->bbuf) {
	b->buf = m->bbuf;
	m->bbuf = NULL;
	b->ptr = b->end = b->buf;
    }
    if (PerlIOBuf_close(aTHX_ f) != 0)
	code = -1;
    return code;
}

PerlIO *
PerlIOMmap_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
 return PerlIOBase_dup(aTHX_ f, o, param, flags);
}


PERLIO_FUNCS_DECL(PerlIO_mmap) = {
    sizeof(PerlIO_funcs),
    "mmap",
    sizeof(PerlIOMmap),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOBuf_pushed,
    PerlIOBuf_popped,
    PerlIOBuf_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOMmap_dup,
    PerlIOBuf_read,
    PerlIOMmap_unread,
    PerlIOMmap_write,
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOMmap_flush,
    PerlIOMmap_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOMmap_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOBuf_set_ptrcnt,
};

#endif                          /* HAS_MMAP */

d4831 1
a4831 1
    return &PL_perlio[1];
d4841 1
a4841 1
    return &PL_perlio[2];
d4851 1
a4851 1
    return &PL_perlio[3];
d5027 1
a5027 1
     SV * sv;
d5094 1
a5094 2
    layers = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,
				      0, direction, 5, 0, 0);
@


1.13
log
@Merge in perl 5.10.1
@
text
@d138 1
a138 1
#  if defined(atarist) || defined(__MINT__)
d617 2
a618 4
		for (i = 0; i < list->cur; i++) {
		    if (list->array[i].arg)
			SvREFCNT_dec(list->array[i].arg);
		}
d762 5
d808 1
a808 1
	    CV * const cv    = Perl_get_cvn_flags(aTHX_ STR_WITH_LEN("PerlIO::Layer::NoWarnings"), 0);
d982 3
a984 4
		    if (ckWARN(WARN_LAYER))
			Perl_warner(aTHX_ packWARN(WARN_LAYER),
			      "Invalid separator character %c%c%c in PerlIO layer specification %s",
			      q, *s, q, s);
d1018 3
a1020 4
			    if (ckWARN(WARN_LAYER))
				Perl_warner(aTHX_ packWARN(WARN_LAYER),
				      "Argument list not closed for PerlIO layer \"%.*s\"",
				      (int) (e - s), s);
d1039 1
a1039 2
			if (arg)
			    SvREFCNT_dec(arg);
d1042 2
a1043 3
			if (ckWARN(WARN_LAYER))
			    Perl_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"%.*s\"",
				  (int) llen, s);
d1457 2
a1458 2
	if (!f && ckWARN(WARN_LAYER))
	    Perl_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"scalar\"");
d1563 1
a1563 2
		if (arg)
		    SvREFCNT_dec(arg);
a1768 1
	  SETERRNO(EINVAL, LIB_INVARG);
a1769 2
     else
	  SETERRNO(EBADF, SS_IVCHAN);
d1777 3
a1779 2
    if (PerlIOValid(f) && (PerlIOBase(f)->flags & PERLIO_F_FASTGETS)) {
	 const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1781 3
a1783 3
	 if (tab)
	      return (tab->Set_ptrcnt != NULL);
	 SETERRNO(EINVAL, LIB_INVARG);
a1784 2
    else
	 SETERRNO(EBADF, SS_IVCHAN);
a1796 1
	  SETERRNO(EINVAL, LIB_INVARG);
a1797 2
    else
	 SETERRNO(EBADF, SS_IVCHAN);
a1809 1
	  SETERRNO(EINVAL, LIB_INVARG);
a1810 2
    else
	 SETERRNO(EBADF, SS_IVCHAN);
d2268 1
a2268 2
	if (arg)
	    SvREFCNT_dec(arg);
d4113 1
a4113 1
	b->buf = Newxz(b->buf,b->bufsiz, STDCHAR);
d5157 4
a5160 1
     SV * const sv = newSVpvs("/tmp/PerlIO_XXXXXX");
d5164 11
a5174 1
     const int fd = mkstemp(SvPVX(sv));
d5179 1
a5179 1
	  PerlLIO_unlink(SvPVX_const(sv));
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, Larry Wall and others
d13 2
d810 1
a810 1
		PL_warnhook = (SV *) (SvREFCNT_inc_simple_NN(cv));
d832 1
a832 1
	IO * const io = GvIOn((GV *) SvRV(sv));
d845 1
a845 1
	IO * const io = GvIOn((GV *) SvRV(sv));
d884 1
a884 1
    sv_magic(sv, (SV *) av, PERL_MAGIC_ext, NULL, 0);
d1295 1
a1295 1
		if ((*l->tab->Binmode)(aTHX_ f) == 0) {
d1627 2
d1635 2
d1643 2
d2424 1
a2424 1
void PerlIO_teardown() /* Call only from PERL_SYS_TERM(). */
d3031 3
a3033 1
	PerlIOUnix_refcnt_inc(fileno(stdio));
d3131 5
a3135 2
	int saveerr = 0;
	int dupfd = 0;
d3146 7
a3152 1
	if (PerlIOUnix_refcnt_dec(fd) > 0) /* File descriptor still in use */
d3154 1
d3166 1
a3166 1
	    saveerr = errno;
d3168 21
a3188 1
	    if (!invalidate)
d3190 11
d3207 1
a3207 1
	    errno = saveerr;
d3214 1
a3214 1
	if (dupfd) {
d3217 3
d3369 1
a3369 1
	const int err = errno;
d3371 1
a3371 1
	    errno = err;
d3452 1
a3452 3
	if (PerlSIO_get_cnt(stdio) != (cnt)) {
	    assert(PerlSIO_get_cnt(stdio) == (cnt));
	}
d4149 3
d4155 2
a4156 4
    if (PerlIO_get_cnt(f) != cnt || b->ptr < b->buf) {
	assert(PerlIO_get_cnt(f) == cnt);
	assert(b->ptr >= b->buf);
    }
d4642 1
a4642 3
	if (PerlIOBase(f)->tab == &PerlIO_crlf) {
		PerlIO_pop(aTHX_ f);
	}
@


1.11
log
@merge in perl 5.8.8
@
text
@d2 6
a7 3
 * perlio.c Copyright (c) 1996-2006, Nick Ing-Simmons You may distribute
 * under the terms of either the GNU General Public License or the
 * Artistic License, as specified in the README file.
d36 5
a40 1
#   include "config.h"
a65 2
#define PERLIO_MAX_REFCOUNTABLE_FD 2048

d120 5
d126 3
d137 1
d139 5
a143 5
	if (mode & O_BINARY)
	    ((FILE *) fp)->_flag |= _IOBIN;
	else
	    ((FILE *) fp)->_flag &= ~_IOBIN;
	return 1;
d148 1
d155 15
a169 12
	/*
	 * The translation mode of the stream is maintained independent of
	 * the translation mode of the fd in the Borland RTL (heavy
	 * digging through their runtime sources reveal).  User has to set
	 * the mode explicitly for the stream (though they don't document
	 * this anywhere). GSAR 97-5-24
	 */
	fseek(fp, 0L, 0);
	if (mode & O_BINARY)
	    fp->flags |= _F_BIN;
	else
	    fp->flags &= ~_F_BIN;
d171 1
a171 1
	return 1;
d174 1
a174 1
	return 0;
d179 3
d183 1
a183 1
	return 1;
d185 1
a185 1
	return 0;
d284 1
a284 1
#if defined(PERL_MICRO) || defined(SYMBIAN)
a296 1
	    int omode = fcntl(fd, F_GETFL);
d298 3
a300 1
	    omode = djgpp_get_stream_mode(f);
d359 1
a359 1
	const char *name = SvPV_nolen_const(ST(1));
d381 1
d419 1
a480 1
    static int dbg = 0;
d484 13
a496 6
    if (!dbg && !PL_tainting && PL_uid == PL_euid && PL_gid == PL_egid) {
        const char *s = PerlEnv_getenv("PERLIO_DEBUG");
	if (s && *s)
	    dbg = PerlLIO_open3(s, O_WRONLY | O_CREAT | O_APPEND, 0666);
	else
	    dbg = -1;
d498 1
a498 1
    if (dbg > 0) {
a499 2
	const char *s = CopFILE(PL_curcop);
	STRLEN len;
d501 1
d504 3
a506 5
	if (!s)
	    s = "(none)";
	len = sprintf(buffer, "%.40s:%" IVdf " ", s, (IV) CopLINE(PL_curcop));
	vsprintf(buffer+len, fmt, ap);
	PerlLIO_write(dbg, buffer, strlen(buffer));
d508 4
a511 5
	SV *sv = newSVpvn("", 0);
	if (!s)
	    s = "(none)";
	Perl_sv_catpvf(aTHX_ sv, "%s:%" IVdf " ", s,
		       (IV) CopLINE(PL_curcop));
d515 1
a515 1
	PerlLIO_write(dbg, s, len);
d536 1
d582 1
a582 1
    PerlIO *table = *tablep;
d587 1
a587 1
	    PerlIO *f = table + i;
d602 1
d629 1
d631 2
d643 1
a643 1
	(void)SvREFCNT_inc(arg);
d650 1
a650 1
    PerlIO_list_t *list = (PerlIO_list_t *) NULL;
d655 7
a661 3
	    SV *arg = Nullsv;
	    if (proto->array[i].arg)
		arg = PerlIO_sv_dup(aTHX_ proto->array[i].arg,param);
d678 1
a678 1
    PerlIO_debug("Clone %p from %p\n",aTHX,proto);
d690 1
d699 1
d703 1
a703 1
    PerlIO_debug("Destruct %p\n",aTHX);
d710 1
a710 1
	    PerlIOl *l;
d729 1
a729 1
    PerlIOl *l = *f;
d755 2
a756 1
     AV *av = newAV();
d758 2
a759 2
     if (PerlIOValid(f)) {
	  PerlIOl *l = PerlIOBase(f);
d761 11
a771 11
	  while (l) {
	       SV *name = l->tab && l->tab->name ?
		    newSVpv(l->tab->name, 0) : &PL_sv_undef;
	       SV *arg = l->tab && l->tab->Getarg ?
		    (*l->tab->Getarg)(aTHX_ &l, 0, 0) : &PL_sv_undef;
	       av_push(av, name);
	       av_push(av, arg);
	       av_push(av, newSViv((IV)l->flags));
	       l = l->next;
	  }
     }
d773 1
a773 1
     return av;
d784 1
d801 1
a801 1
	    SV * const pkgsv = newSVpvn("PerlIO", 6);
d803 1
a803 1
	    CV * const cv    = get_cv("PerlIO::Layer::NoWarnings", FALSE);
d808 1
a808 2
		(void)SvREFCNT_inc(cv);
		PL_warnhook = (SV *) cv;
d814 1
a814 1
	    Perl_load_module(aTHX_ 0, pkgsv, Nullsv, layer, Nullsv);
d830 5
a834 4
	IO *io = GvIOn((GV *) SvRV(sv));
	PerlIO *ifp = IoIFP(io);
	PerlIO *ofp = IoOFP(io);
	Perl_warn(aTHX_ "set %" SVf " %p %p %p", sv, io, ifp, ofp);
d843 5
a847 4
	IO *io = GvIOn((GV *) SvRV(sv));
	PerlIO *ifp = IoIFP(io);
	PerlIO *ofp = IoOFP(io);
	Perl_warn(aTHX_ "get %" SVf " %p %p %p", sv, io, ifp, ofp);
d855 1
a855 1
    Perl_warn(aTHX_ "clear %" SVf, sv);
d862 1
a862 1
    Perl_warn(aTHX_ "free %" SVf, sv);
d877 2
a878 2
    SV *sv = SvRV(ST(1));
    AV *av = newAV();
d887 1
a887 1
    Perl_warn(aTHX_ "attrib %" SVf, sv);
d890 2
a891 2
	const char *name = SvPV_const(ST(i), len);
	SV *layer = PerlIO_find_layer(aTHX_ name, len, 1);
d893 1
a893 1
	    av_push(av, SvREFCNT_inc(layer));
d909 1
a909 1
    HV * const stash = gv_stashpv("PerlIO::Layer", TRUE);
d919 1
d921 1
d929 1
d931 1
d949 1
d952 1
a952 1
    PerlIO_list_push(aTHX_ PL_known_layers, tab, Nullsv);
d959 1
d968 1
a968 1
		const char *as = Nullch;
d1031 3
d1035 3
a1037 3
					 (as) ? newSVpvn(as,
							 alen) :
					 &PL_sv_undef);
d1056 1
d1136 1
d1138 1
a1138 1
	const char *s = (PL_tainting) ? Nullch : PerlEnv_getenv("PERLIO");
d1188 1
d1201 1
d1223 19
a1241 11
	Newxc(l,tab->size,char,PerlIOl);
	if (l && f) {
	    Zero(l, tab->size, char);
	    l->next = *f;
	    l->tab = (PerlIO_funcs*) tab;
	    *f = l;
	    PerlIO_debug("PerlIO_push f=%p %s %s %p\n", (void*)f, tab->name,
			(mode) ? mode : "(Null)", (void*)arg);
	    if (*l->tab->Pushed &&
		(*l->tab->Pushed) (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
		PerlIO_pop(aTHX_ f);
a1242 1
	    }
d1407 1
a1407 1
	return PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_raw), Nullch, Nullsv) ? TRUE : FALSE;
d1440 1
a1443 25
static const char *
PerlIO_context_layers(pTHX_ const char *mode)
{
    const char *type = NULL;
    /*
     * Need to supply default layer info from open.pm
     */
    if (PL_curcop) {
	SV *layers = PL_curcop->cop_io;
	if (layers) {
	    STRLEN len;
	    type = SvPV_const(layers, len);
	    if (type && mode[0] != 'r') {
		/*
		 * Skip to write part
		 */
		const char *s = strchr(type, 0);
		if (s && (STRLEN)(s - type) < len) {
		    type = s + 1;
		}
	    }
	}
    }
    return type;
}
d1448 1
d1452 8
a1459 2
    if (SvTYPE(sv) < SVt_PVAV)
	return PerlIO_find_layer(aTHX_ "scalar", 6, 1);
d1466 1
a1466 1
	return PerlIO_find_layer(aTHX_ "Array", 5, 0);
d1468 1
a1468 1
	return PerlIO_find_layer(aTHX_ "Hash", 4, 0);
d1470 1
a1470 1
	return PerlIO_find_layer(aTHX_ "Code", 4, 0);
d1472 3
a1474 1
	return PerlIO_find_layer(aTHX_ "Glob", 4, 0);
a1475 1
    return NULL;
d1482 1
d1488 1
a1488 1
	SV *arg = *args;
d1508 1
a1508 1
	layers = PerlIO_context_layers(aTHX_ mode);
d1512 1
a1512 6
	    IV i;
	    av = PerlIO_list_alloc(aTHX);
	    for (i = 0; i < def->cur; i++) {
		PerlIO_list_push(aTHX_ av, def->array[i].funcs,
				 def->array[i].arg);
	    }
d1522 1
a1522 1
	    return (PerlIO_list_t *) NULL;
d1536 1
d1540 1
a1540 1
		layers = PerlIO_context_layers(aTHX_ mode);
d1557 7
a1563 4
		SV * const arg = (l->tab->Getarg)
			? (*l->tab->Getarg) (aTHX_ &l, NULL, 0)
			: &PL_sv_undef;
		PerlIO_list_push(aTHX_ layera, l->tab, arg);
d1655 1
d1697 1
d1864 1
d2032 1
d2082 1
a2082 1
		 f, PerlIOBase(f)->tab->name, (omode) ? omode : "(Null)",
d2091 1
d2103 1
a2103 1
    PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_pending), "r", Nullsv);
d2124 1
a2124 1
		take = ((SSize_t)count < avail) ? count : avail;
d2148 1
d2156 1
d2193 1
d2203 1
d2214 1
a2214 1
	PerlIO *n = PerlIONext(f);
d2224 1
d2234 1
a2234 1
	return Nullsv;
d2237 3
a2239 1
	return sv_dup(arg, param);
d2262 2
a2263 2
	PerlIO_funcs *self = PerlIOBase(o)->tab;
	SV *arg;
a2268 3
	else {
	    arg = Nullsv;
	}
d2270 3
a2272 1
	if (arg) {
a2273 1
	}
d2278 26
a2303 2
#ifdef USE_THREADS
perl_mutex PerlIO_mutex;
d2305 16
a2320 1
int PerlIO_fd_refcnt[PERLIO_MAX_REFCOUNTABLE_FD];
d2325 2
a2326 4
 /* Place holder for stdstreams call ??? */
#ifdef USE_THREADS
    MUTEX_INIT(&PerlIO_mutex);
#endif
d2332 6
a2337 8
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
#ifdef USE_THREADS
	MUTEX_LOCK(&PerlIO_mutex);
#endif
	PerlIO_fd_refcnt[fd]++;
	PerlIO_debug("fd %d refcnt=%d\n",fd,PerlIO_fd_refcnt[fd]);
#ifdef USE_THREADS
	MUTEX_UNLOCK(&PerlIO_mutex);
d2339 16
d2361 1
d2363 4
a2366 8
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
#ifdef USE_THREADS
	MUTEX_LOCK(&PerlIO_mutex);
#endif
	cnt = --PerlIO_fd_refcnt[fd];
	PerlIO_debug("fd %d refcnt=%d\n",fd,cnt);
#ifdef USE_THREADS
	MUTEX_UNLOCK(&PerlIO_mutex);
d2368 15
d2390 1
d2393 1
a2393 1
    PerlIO_debug("Cleanup layers for %p\n",aTHX);
d2397 1
d2416 39
a2454 1

d2526 1
d2549 1
d2577 1
d2588 1
a2588 3
     {
      return -1;
     }
d2633 1
d2645 1
a2645 1
    PerlIOUnix *os = PerlIOSelf(o, PerlIOUnix);
d2650 1
a2650 1
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
d2665 1
d2697 1
d2721 2
d2730 1
d2808 6
a2813 3
    FILE *s;
    if (PerlIOValid(f) && (s = PerlIOSelf(f, PerlIOStdio)->stdio)) {
	return PerlSIO_fileno(s);
d2894 1
a2894 1
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), PERLIO_FUNCS_CAST(&PerlIO_stdio), mode, Nullsv))) {
d2897 1
d2910 2
a2911 2
	const char *path = SvPV_nolen_const(*args);
	PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
d2924 1
a2924 1
	    const char *path = SvPV_nolen_const(*args);
a2938 1
		    PerlIOStdio *s;
d2946 4
a2949 3
			s = PerlIOSelf(f, PerlIOStdio);
			s->stdio = stdio;
			PerlIOUnix_refcnt_inc(fileno(s->stdio));
d2987 2
a2988 3
		    PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
		    s->stdio = stdio;
		    PerlIOUnix_refcnt_inc(fileno(s->stdio));
d3014 1
d3031 2
d3047 2
a3048 25
#    if defined(_LP64)
    /* On solaris, if _LP64 is defined, the FILE structure is this:
     *
     *  struct FILE {
     *      long __pad[16];
     *  };
     *
     * It turns out that the fd is stored in the top 32 bits of
     * file->__pad[4]. The lower 32 bits contain flags. file->pad[5] appears
     * to contain a pointer or offset into another structure. All the
     * remaining fields are zero.
     *
     * We set the top bits to -1 (0xFFFFFFFF).
     */
    f->__pad[4] |= 0xffffffff00000000L;
    assert(fileno(f) == 0xffffffff);
#    else /* !defined(_LP64) */
    /* _file is just a unsigned char :-(
       Not clear why we dup() rather than using -1
       even if that would be treated as 0xFF - so will
       a dup fail ...
     */
    f->_file = PerlLIO_dup(fileno(f));
#    endif /* defined(_LP64) */
    return 1;
d3112 1
a3112 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
a3118 1
	int socksfd = 0;
d3130 1
a3130 2
    	if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *) &optval, &optlen) == 0) {
            socksfd = 1;
a3131 1
    	}
d3133 1
a3133 2
    	if (PerlIOUnix_refcnt_dec(fd) > 0) {
	    /* File descriptor still in use */
a3134 2
	    socksfd = 0;
	}
d3136 5
a3140 10
   	    /* For STD* handles don't close the stdio at all
	       this is because we have shared the FILE * too
   	     */
	    if (stdio == stdin) {
	    	/* Some stdios are buggy fflush-ing inputs */
	    	return 0;
	    }
	    else if (stdio == stdout || stdio == stderr) {
	    	return PerlIO_flush(f);
	    }
d3147 3
a3149 3
    	    if (!(invalidate = PerlIOStdio_invalidate_fileno(aTHX_ stdio))) {
	    	dupfd = PerlLIO_dup(fd);
	    }
d3159 4
a3162 4
	if (socksfd) {
	    /* in SOCKS case let close() determine return value */
	    result = close(fd);
	}
d3174 2
a3175 1
    FILE *s = PerlIOSelf(f, PerlIOStdio)->stdio;
d3206 1
a3206 1
    FILE *s = PerlIOSelf(f, PerlIOStdio)->stdio;
d3263 1
d3279 3
a3281 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3288 3
a3290 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3297 3
a3299 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3304 1
d3315 1
a3315 1
	int err = errno;
d3326 2
d3334 2
d3342 2
d3350 2
d3355 1
a3355 1
    PerlSIO_setvbuf(PerlIOSelf(f, PerlIOStdio)->stdio, Nullch, _IOLBF, 0);
d3363 1
a3363 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3370 1
a3370 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3379 1
a3379 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3386 1
a3386 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3393 1
a3393 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3396 1
a3396 1
	PerlSIO_set_ptr(stdio, (void*)ptr); /* LHS STDCHAR* cast non-portable */
d3434 1
a3434 1
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3436 2
d3445 9
a3453 3
    c = PerlSIO_fgetc(stdio);
    if (c == EOF)
	return EOF;
d3567 1
a3567 1
	    if ((f2 = PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_stdio), buf, Nullsv))) {
d3570 1
d3588 1
d3597 13
a3609 1
    return PerlIO_exportFILE(f, Nullch);
d3616 1
d3623 3
d3706 1
a3706 1
		    PerlIO_binmode(aTHX_ f,  '<'/*not used*/, O_BINARY, Nullch);
d3731 1
a3731 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3792 1
a3792 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3807 2
d3835 1
a3835 1
	    SSize_t cnt = avail;
d3861 1
a3861 1
        const PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3873 1
a3873 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3992 1
a3992 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4027 1
a4027 2
    b->buf = NULL;
    b->ptr = b->end = b->buf;
d4040 1
a4040 2
    b->buf = NULL;
    b->ptr = b->end = b->buf;
d4048 1
a4048 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4057 1
a4057 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4068 3
a4070 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4079 1
a4079 2
	b->ptr = b->buf;
	b->end = b->ptr;
d4087 1
a4087 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4096 1
a4096 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4185 1
a4185 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4209 1
a4209 1
    PerlIOl *l = PerlIOBase(f);
d4292 15
d4315 1
a4315 1
		 f, PerlIOBase(f)->tab->name, (mode) ? mode : "(Null)",
d4324 1
a4324 1
	 while (g && *g) {
d4329 1
d4336 1
d4344 1
a4344 1
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
d4366 1
a4366 1
		int ch = *--buf;
d4396 1
a4396 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4400 1
a4400 1
	PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
d4468 2
a4469 2
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
d4486 1
d4501 2
a4502 2
		       " nl=%p e=%p for %d", ptr, chk, flags, c->nl,
		       b->end, cnt);
d4526 1
a4526 1
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4528 1
a4528 1
	const STDCHAR *ebuf = buf + count;
d4534 1
a4534 1
	    STDCHAR *eptr = b->buf + b->bufsiz;
d4556 1
a4556 2
		    int ch = *buf++;
		    *(b->ptr)++ = ch;
d4573 1
a4573 1
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
a4640 2
static size_t page_size = 0;

d4644 1
d4651 1
a4651 1
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4659 3
a4661 37
		if (!page_size) {
#if defined(HAS_SYSCONF) && (defined(_SC_PAGESIZE) || defined(_SC_PAGE_SIZE))
		    {
			SETERRNO(0, SS_NORMAL);
#   ifdef _SC_PAGESIZE
			page_size = sysconf(_SC_PAGESIZE);
#   else
			page_size = sysconf(_SC_PAGE_SIZE);
#   endif
			if ((long) page_size < 0) {
			    if (errno) {
				SV *error = ERRSV;
				char *msg;
				STRLEN n_a;
				(void) SvUPGRADE(error, SVt_PV);
				msg = SvPVx(error, n_a);
				Perl_croak(aTHX_ "panic: sysconf: %s",
					   msg);
			    }
			    else
				Perl_croak(aTHX_
					   "panic: sysconf: pagesize unknown");
			}
		    }
#else
#   ifdef HAS_GETPAGESIZE
		    page_size = getpagesize();
#   else
#       if defined(I_SYS_PARAM) && defined(PAGESIZE)
		    page_size = PAGESIZE;       /* compiletime, bad */
#       endif
#   endif
#endif
		    if ((IV) page_size <= 0)
			Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
				   (IV) page_size);
		}
d4669 1
a4669 1
		posn = (b->posn / page_size) * page_size;
d4671 1
a4671 1
		m->mptr = mmap(NULL, len, PROT_READ, MAP_SHARED, fd, posn);
d4705 1
a4705 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4708 1
d4710 8
a4717 1
	    code = munmap(m->mptr, m->len);
d4733 2
a4734 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4766 2
a4767 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4824 2
a4825 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4852 1
a4852 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d4866 2
a4867 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4922 1
d4932 1
d4942 1
d4972 1
a4972 1
    return Nullch;
d4988 1
a4988 1
    return PerlIO_openn(aTHX_ Nullch, mode, fd, 0, 0, NULL, 0, NULL);
d4996 2
a4997 2
    SV *name = sv_2mortal(newSVpvn(path, strlen(path)));
    return PerlIO_openn(aTHX_ Nullch, mode, -1, 0, 0, NULL, 1, &name);
d5005 2
a5006 2
    SV *name = sv_2mortal(newSVpvn(path, strlen(path)));
    return PerlIO_openn(aTHX_ Nullch, mode, -1, 0, 0, f, 1, &name);
d5048 1
a5048 2
    STRLEN len = strlen(s);
    return PerlIO_write(f, s, len);
d5065 1
a5065 1
    SV *sv = newSVpvn("", 0);
d5072 1
a5072 1
    sv_vcatpvf(sv, fmt, &apc);
d5074 1
a5074 1
    sv_vcatpvf(sv, fmt, &ap);
d5119 1
a5119 1
     SV *sv = newSVpv("/tmp/PerlIO_XXXXXX", 0);
a5128 1
	  SvREFCNT_dec(sv);
d5130 1
d5132 4
a5135 1
     FILE *stdio = PerlSIO_tmpfile();
a5136 10
     if (stdio) {
	  if ((f = PerlIO_push(aTHX_(PerlIO_allocate(aTHX)),
                               PERLIO_FUNCS_CAST(&PerlIO_stdio),
			       "w+", Nullsv))) {
               PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);

               if (s)
                    s->stdio = stdio;
          }
     }
d5153 30
d5192 1
a5192 1
	Off_t *posn = (Off_t *) SvPV(pos, len);
d5207 1
a5207 1
	Fpos_t *fpos = (Fpos_t *) SvPV(pos, len);
d5273 7
a5279 8
    const int val = vsprintf(s, fmt, ap);
    if (n >= 0) {
	if (strlen(s) >= (STRLEN) n) {
	    dTHX;
	    (void) PerlIO_puts(Perl_error_log,
			       "panic: sprintf overflow - memory corrupted!\n");
	    my_exit(1);
	}
d5281 1
@


1.10
log
@Limit PERLIO_DEBUG environtment variable to a sane length and just ignore
it if setuid.  Found by Kevin Finisterre, fix from perl developers.
@
text
@d2 1
a2 1
 * perlio.c Copyright (c) 1996-2004, Nick Ing-Simmons You may distribute
d59 2
d69 1
a69 1
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
d82 1
a82 1
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
d94 1
a94 1
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
d106 1
a106 1
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
d115 1
d166 3
d173 1
d182 1
a182 1
    int result = rawmode & O_ACCMODE;
d251 3
d263 1
a263 1
#ifdef PERL_MICRO
d273 1
a273 1
	int fd = PerlLIO_dup(PerlIO_fileno(f));
d311 1
a311 1
	    char *name = SvPV_nolen(*args);
d315 1
a315 1
		    return PerlIO_fdopen(fd, (char *) mode + 1);
d337 1
a337 1
	char *name = SvPV_nolen(ST(1));
d414 1
a414 1
    int fd = fileno(stdio);
d424 2
a425 2
    int fd = PerlIO_fileno(pio);
    FILE *f = fdopen(fd, "r+");
a453 6
/*
 * Why is this here - not in perlio.h?  RMB
 */
void PerlIO_debug(const char *fmt, ...)
    __attribute__format__(__printf__, 1, 2);

d462 1
a462 1
	char *s = PerlEnv_getenv("PERLIO_DEBUG");
d470 2
a474 3
	char *s;
	STRLEN len;
	s = CopFILE(PL_curcop);
d477 1
a477 2
	sprintf(buffer, "%.40s:%" IVdf " ", s, (IV) CopLINE(PL_curcop));
	len = strlen(buffer);
a481 3
	char *s;
	STRLEN len;
	s = CopFILE(PL_curcop);
d488 1
a488 1
	s = SvPV(sv, len);
d525 1
a525 1
    Newz('I',f,PERLIO_TABLE_SIZE,PerlIO);
d538 1
a538 1
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
d575 1
a575 1
    Newz('L', list, 1, PerlIO_list_t);
d607 1
a607 1
	    New('l', list->array, list->len, PerlIO_pair_t);
d612 1
a612 1
	SvREFCNT_inc(arg);
d654 3
d750 1
a750 1
	PerlIO_funcs *f = PL_known_layers->array[i].funcs;
d762 4
a765 4
	    SV *pkgsv = newSVpvn("PerlIO", 6);
	    SV *layer = newSVpvn(name, len);
	    CV *cv  = get_cv("PerlIO::Layer::NoWarnings", FALSE);
    	    ENTER;
d768 2
a769 1
	        SAVESPTR(PL_warnhook);
d850 1
a850 1
	const char *name = SvPV(ST(i), len);
d869 2
a870 2
    HV *stash = gv_stashpv("PerlIO::Layer", TRUE);
    SV *sv = sv_bless(newRV_noinc(newSViv(PTR2IV(tab))), stash);
d881 1
a881 1
    	PerlIO_debug("warning:%s\n",SvPV_nolen(ST(0)));
d891 4
a894 4
	STRLEN len = 0;
	char *name = SvPV(ST(1), len);
	bool load = (items > 2) ? SvTRUE(ST(2)) : 0;
	PerlIO_funcs *layer = PerlIO_find_layer(aTHX_ name, len, load);
d930 1
a930 1
		    char q = ((*s == '\'') ? '"' : '\'');
d982 1
a982 2
		    bool warn_layer = ckWARN(WARN_LAYER);
		    PerlIO_funcs *layer =
d991 1
a991 1
			if (warn_layer)
d1007 1
a1007 1
    PerlIO_funcs *tab = &PerlIO_perlio;
d1041 3
d1052 1
a1052 1
PerlIO_funcs PerlIO_remove = {
d1068 2
d1088 1
a1088 1
	PerlIO_funcs *osLayer = &PerlIO_unix;
d1090 1
a1090 1
	PerlIO_define_layer(aTHX_ & PerlIO_unix);
d1092 1
a1092 1
	PerlIO_define_layer(aTHX_ & PerlIO_win32);
d1097 4
a1100 4
	PerlIO_define_layer(aTHX_ & PerlIO_raw);
	PerlIO_define_layer(aTHX_ & PerlIO_perlio);
	PerlIO_define_layer(aTHX_ & PerlIO_stdio);
	PerlIO_define_layer(aTHX_ & PerlIO_crlf);
d1102 1
a1102 1
	PerlIO_define_layer(aTHX_ & PerlIO_mmap);
d1104 3
a1106 3
	PerlIO_define_layer(aTHX_ & PerlIO_utf8);
	PerlIO_define_layer(aTHX_ & PerlIO_remove);
	PerlIO_define_layer(aTHX_ & PerlIO_byte);
d1137 1
a1137 1
    PerlIO_list_t *av = PerlIO_default_layers(aTHX);
d1140 1
a1140 1
    return PerlIO_layer_fetch(aTHX_ av, n, &PerlIO_stdio);
d1158 1
a1158 1
PerlIO_push(pTHX_ PerlIO *f, PerlIO_funcs *tab, const char *mode, SV *arg)
d1165 1
a1165 1
	PerlIOl *l = NULL;
d1170 1
a1170 1
	Newc('L',l,tab->size,char,PerlIOl);
d1174 1
a1174 1
	    l->tab = tab;
d1179 1
a1179 1
		(*l->tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
d1190 1
a1190 1
	    (*tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
d1218 3
d1224 1
a1224 1
	PerlIOl *l;
d1262 1
a1262 1
	PerlIO_funcs *tab = PerlIO_layer_fetch(aTHX_ layers, n, NULL);
d1279 1
a1279 1
	PerlIO_list_t *layers = PerlIO_list_alloc(aTHX);
d1298 4
a1301 3
    PerlIO_debug("PerlIO_binmode f=%p %s %c %x %s\n",
		 (void*)f, PerlIOBase(f)->tab->name, iotype, mode,
		 (names) ? names : "(Null)");
d1347 1
a1347 1
	return PerlIO_push(aTHX_ f, &PerlIO_raw, Nullch, Nullsv) ? TRUE : FALSE;
d1355 1
a1355 1
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1370 1
a1370 1
    int code = PerlIO__close(aTHX_ f);
d1394 1
a1394 1
	    type = SvPV(layers, len);
d1449 1
a1449 1
	    PerlIO_funcs *handler = PerlIO_layer_from_ref(aTHX_ SvRV(arg));
d1462 1
a1462 1
    if (!layers)
d1467 1
a1467 1
	    IV i = def->cur;
d1498 1
a1498 1
	    if (!layers)
d1505 1
a1505 1
	PerlIO_list_t *layera = NULL;
d1516 1
a1516 1
		SV *arg = (l->tab->Getarg)
d1534 1
a1534 1
	    PerlIO_funcs *t = PerlIO_layer_fetch(aTHX_ layera, n, NULL);
d1549 2
a1550 2
			 tab->name, layers, mode, fd, imode, perm,
			 (void*)f, narg, (void*)args);
d1613 1
a1613 1
	    PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1713 1
a1713 1
	  PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1729 1
a1729 1
	 PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1745 1
a1745 1
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1761 1
a1761 1
	  PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1818 2
d1830 1
a1830 1
PerlIO_funcs PerlIO_utf8 = {
d1846 2
d1861 1
a1861 1
PerlIO_funcs PerlIO_byte = {
d1877 2
d1897 2
a1898 1
    PerlIO_funcs *tab = PerlIO_default_btm();
d1906 1
a1906 1
PerlIO_funcs PerlIO_raw = {
d1922 2
d1953 1
a1953 1
	IV flags = PerlIOBase(f)->flags;
d1984 3
a1986 5
    PerlIOl *l = PerlIOBase(f);
#if 0
    const char *omode = mode;
    char temp[8];
#endif
d2043 1
d2053 2
a2054 3
    Off_t old = PerlIO_tell(f);
    SSize_t done;
    PerlIO_push(aTHX_ f, &PerlIO_pending, "r", Nullsv);
d2056 1
a2056 2
    done = PerlIOBuf_unread(aTHX_ f, vbuf, count);
    return done;
d2070 2
d2082 2
d2089 1
d2099 1
d2106 1
d2120 1
a2120 1
	    PerlIO_funcs *tab = PerlIOBase(n)->tab;
d2189 1
d2197 1
a2197 1
    PerlIO *nexto = PerlIONext(o);
d2199 1
a2199 1
	PerlIO_funcs *tab = PerlIOBase(nexto)->tab;
a2223 1
#define PERLIO_MAX_REFCOUNTABLE_FD 2048
d2234 1
a2234 1
 MUTEX_INIT(&PerlIO_mutex);
d2291 1
a2291 1
    if(PL_def_layerlist) {
d2375 1
a2375 1
    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
d2416 2
a2417 2
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    Off_t new;
d2426 2
a2427 2
    new  = PerlLIO_lseek(fd, offset, whence);
    if (new == (Off_t) - 1)
a2444 1
	char *path = SvPV_nolen(*args);
d2452 1
d2506 5
a2510 1
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2516 1
a2516 1
	SSize_t len = PerlLIO_read(fd, vbuf, count);
d2531 1
d2537 5
a2541 1
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2543 1
a2543 1
	SSize_t len = PerlLIO_write(fd, vbuf, count);
d2554 1
d2567 1
a2567 1
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2592 1
a2592 1
PerlIO_funcs PerlIO_unix = {
d2655 1
a2655 1
    char *ret = tmode;
d2673 1
a2673 1
        PerlIO_funcs *toptab = PerlIOBase(n)->tab;
d2679 1
a2679 1
	    int fd = PerlIO_fileno(n);
d2712 1
a2712 1
	    int fd = PerlLIO_dup(fileno(stdio));
d2727 1
a2727 1
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), &PerlIO_stdio, mode, Nullsv))) {
d2742 1
a2742 1
	char *path = SvPV_nolen(*args);
d2756 1
a2756 1
	    char *path = SvPV_nolen(*args);
a2814 1
		PerlIOStdio *s;
d2819 1
a2819 1
		    s = PerlIOSelf(f, PerlIOStdio);
d2838 1
a2838 1
	int fd = fileno(stdio);
d2841 1
a2841 1
	    int dfd = PerlLIO_dup(fileno(stdio));
d2866 5
a2870 1
#  if defined(__GLIBC__)
d2957 1
d2971 1
a2971 1
        int fd = fileno(stdio);
d3047 1
a3047 1
	    int ch = PerlSIO_fgetc(s);
d3101 1
a3101 1
	    int ch = *--buf & 0xFF;
d3341 1
a3341 1
PerlIO_funcs PerlIO_stdio = {
d3406 1
a3406 1
	    if ((f2 = PerlIO_push(aTHX_ f, &PerlIO_stdio, buf, Nullsv))) {
d3465 1
a3465 1
    int fd = PerlIO_fileno(f);
d3470 1
a3470 1
	Off_t posn = PerlIO_tell(PerlIONext(f));
d3543 5
a3547 1
 * read or write state
d3559 2
a3560 2
	STDCHAR *buf = b->buf;
	STDCHAR *p = buf;
d3606 4
d3620 1
a3620 1
    if (PerlIO_flush(f) != 0)
a3678 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3680 1
d3751 1
a3751 1
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
a3797 1
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3801 1
d3841 2
a3842 2
    IV code = PerlIOBase_popped(aTHX_ f);
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3855 2
a3856 2
    IV code = PerlIOBase_close(aTHX_ f);
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3893 1
a3893 2
	b->buf =
	Newz('B',b->buf,b->bufsiz, STDCHAR);
d3935 1
a3935 1
PerlIO_funcs PerlIO_perlio = {
d4028 1
a4028 1
    IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
d4050 1
a4050 1
	SSize_t more =
d4058 1
a4058 1
PerlIO_funcs PerlIO_pending = {
d4096 8
d4148 1
a4148 1
    if (c->nl) {
d4178 4
a4181 2
			buf++;
			break;
d4195 1
d4400 1
a4400 1
PerlIO_funcs PerlIO_crlf = {
d4412 1
a4412 2
    PerlIOBuf_read,             /* generic read works with ptr/cnt lies
				 * ... */
d4449 2
a4450 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    IV flags = PerlIOBase(f)->flags;
d4456 1
a4456 1
	int fd = PerlIO_fileno(f);
d4628 3
a4630 2
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
d4717 1
a4717 1
PerlIO_funcs PerlIO_mmap = {
d4783 1
a4784 1
#ifdef VMS
d4795 1
d4797 2
d4800 1
a4801 1
    return name;
d4843 1
a4843 2
    SSize_t count = PerlIO_read(f, buf, 1);
    if (count == 1) {
d4895 1
a4895 1
    char *s;
d4905 1
a4905 1
    s = SvPV(sv, len);
a4941 1
     int fd = -1;
d4943 1
a4943 1
     fd = win32_tmpfd();
a4948 1

d4952 1
a4952 1
     fd = mkstemp(SvPVX(sv));
d4957 1
a4957 1
	  PerlLIO_unlink(SvPVX(sv));
d4965 2
a4966 1
                               &PerlIO_stdio, "w+", Nullsv))) {
d5079 1
a5079 1
    int val = vsprintf(s, fmt, ap);
d5105 9
a5113 7







@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d457 1
a457 1
    if (!dbg) {
d474 1
a474 1
	sprintf(buffer, "%s:%" IVdf " ", s, (IV) CopLINE(PL_curcop));
@


1.8
log
@fix perlbug 32446: socket on fd 1 gets duped to fd 0 on close(STDIN)+close(STDOUT);
from Steffen Ullrich at genua.de; ok millert@@
@
text
@d12 6
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2878 7
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
 * perlio.c Copyright (c) 1996-2002, Nick Ing-Simmons You may distribute
d3694 1
d3705 5
d3714 2
d3717 8
a3724 21
	if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
	    while (avail > 0) {
		int ch = *buf++;
		*(b->ptr)++ = ch;
		count--;
		avail--;
		written++;
		if (ch == '\n') {
		    PerlIO_flush(f);
		    break;
		}
	    }
	}
	else {
	    if (avail) {
		Copy(buf, b->ptr, avail, STDCHAR);
		count -= avail;
		buf += avail;
		written += avail;
		b->ptr += avail;
	    }
d4716 1
d4718 5
a4722 1
    if (stdio)
d4724 2
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d53 54
d271 1
a271 1
	SETERRNO(EBADF, SS$_IVCHAN);
d296 1
a296 1
	    if (*mode == '#') {
d438 3
a440 1

d442 1
a442 1
    __attribute__ ((format(__printf__, 1, 2)));
a533 1
	PerlIO *new;
d535 5
a539 6
	new = (*tab->Dup)(aTHX_ PerlIO_allocate(aTHX),f,param, flags);
	return new;
    }
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return NULL;
d541 4
d701 29
d743 1
a743 1
	if (memEQ(f->name, name, len)) {
d750 22
a771 9
	SV *pkgsv = newSVpvn("PerlIO", 6);
	SV *layer = newSVpvn(name, len);
	ENTER;
	/*
	 * The two SVs are magically freed by load_module
	 */
	Perl_load_module(aTHX_ 0, pkgsv, Nullsv, layer, Nullsv);
	LEAVE;
	return PerlIO_find_layer(aTHX_ name, len, 0);
d865 11
d924 1
a924 1
			      "perlio: invalid separator character %c%c%c in layer specification list %s",
d926 1
a926 1
		    SETERRNO(EINVAL, LIB$_INVARG);
d961 1
a961 1
				      "perlio: argument list not closed for layer \"%.*s\"",
d984 1
a984 1
			    Perl_warner(aTHX_ packWARN(WARN_LAYER), "perlio: unknown layer \"%.*s\"",
d1078 1
a1078 1
#if defined(WIN32) && !defined(UNDER_CE)
d1118 1
d1165 2
a1166 1
	    if ((*l->tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
d1176 3
a1178 2
	if ((*tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
	    return NULL;
d1337 7
a1343 2
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Close) (aTHX_ f);
d1345 1
a1345 1
	SETERRNO(EBADF, SS$_IVCHAN);
d1353 3
a1355 6
    int code = -1;
    if (PerlIOValid(f)) {
	code = (*PerlIOBase(f)->tab->Close) (aTHX_ f);
	while (*f) {
	    PerlIO_pop(aTHX_ f);
	}
d1363 1
a1363 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Fileno) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1534 7
a1540 2
	    f = (*tab->Open) (aTHX_ tab, layera, n, mode, fd, imode, perm,
			      f, narg, args);
d1564 1
a1564 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Read) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1570 1
a1570 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Unread) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1576 1
a1576 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Write) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1582 1
a1582 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Seek) (aTHX_ f, offset, whence);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1588 1
a1588 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Tell) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1597 2
a1598 1
	    if (tab && tab->Flush) {
d1600 2
a1601 6
	    }
	    else {
		PerlIO_debug("Cannot flush f=%p :%s\n", (void*)f, tab->name);
		SETERRNO(EBADF, SS$_IVCHAN);
		return -1;
	    }
d1605 1
a1605 1
	    SETERRNO(EBADF, SS$_IVCHAN);
d1654 1
a1654 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Fill) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1660 6
a1665 6
    if (PerlIOValid(f))
	return (PerlIOBase(f)->flags & PERLIO_F_UTF8) != 0;
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1671 1
a1671 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Eof) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1677 1
a1677 6
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Error) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
d1683 1
a1683 4
    if (PerlIOValid(f))
	(*PerlIOBase(f)->tab->Clearerr) (aTHX_ f);
    else
	SETERRNO(EBADF, SS$_IVCHAN);
d1689 1
a1689 4
    if (PerlIOValid(f))
	(*PerlIOBase(f)->tab->Setlinebuf) (aTHX_ f);
    else
	SETERRNO(EBADF, SS$_IVCHAN);
d1695 11
a1705 4
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->tab->Get_base != NULL);
    }
    return 0;
d1712 5
a1716 2
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	return (tab->Set_ptrcnt != NULL);
d1718 3
d1729 4
a1732 1
	return (tab->Get_ptr != NULL && tab->Get_cnt != NULL);
d1734 3
d1744 5
a1748 2
	PerlIOl *l = PerlIOBase(f);
	return (l->tab->Set_ptrcnt != NULL);
d1750 3
d1759 1
a1759 3
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Get_base) (aTHX_ f);
    return NULL;
d1765 1
a1765 3
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Get_bufsiz) (aTHX_ f);
    return 0;
d1771 1
a1771 7
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Get_ptr == NULL)
	    return NULL;
	return (*tab->Get_ptr) (aTHX_ f);
    }
    return NULL;
d1777 1
a1777 7
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Get_cnt == NULL)
	   return 0;
	return (*tab->Get_cnt) (aTHX_ f);
    }
    return 0;
d1783 1
a1783 3
    if (PerlIOValid(f)) {
	(*PerlIOBase(f)->tab->Set_ptrcnt) (aTHX_ f, NULL, cnt);
    }
d1789 1
a1789 7
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Set_ptrcnt == NULL) {
	    Perl_croak(aTHX_ "PerlIO buffer snooping abuse");
	}
	(*PerlIOBase(f)->tab->Set_ptrcnt) (aTHX_ f, ptr, cnt);
    }
d1875 5
a1879 2
    return (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			 old, narg, args);
d1968 1
a1968 1
	if (*mode == '#' || *mode == 'I')
d1981 1
a1981 1
	    SETERRNO(EINVAL, LIB$_INVARG);
d1996 1
a1996 1
		SETERRNO(EINVAL, LIB$_INVARG);
d2041 3
a2043 1
	if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD))
d2045 1
d2083 23
a2105 8
    IV code = 0;
    PerlIO *n = PerlIONext(f);
    if (PerlIO_flush(f) != 0)
	code = -1;
    if (PerlIOValid(n) && (*PerlIOBase(n)->tab->Close)(aTHX_ n) != 0)
	code = -1;
    PerlIOBase(f)->flags &=
	~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
d2169 4
a2172 1
	f = (*tab->Dup)(aTHX_ f, nexto, param, flags);
d2176 1
a2176 1
	SV *arg = Nullsv;
d2180 4
a2183 2
	if (self->Getarg) {
	    arg = (*self->Getarg)(aTHX_ o,param,flags);
d2284 1
a2284 1
    if (*mode == 'I' || *mode == '#')
d2330 1
a2330 1
	SETERRNO(EINVAL, LIB$_INVARG);
d2342 21
a2366 1
    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
a2369 1
	s->fd = PerlIO_fileno(PerlIONext(f));
d2375 2
a2376 1
	s->oflags = mode ? PerlIOUnix_oflags(mode) : -1;
d2379 1
d2383 22
d2416 1
a2416 1
	if (*mode == '#')
d2427 1
a2427 2
	PerlIOUnix *s;
	if (*mode == 'I')
d2437 1
a2437 3
	s = PerlIOSelf(f, PerlIOUnix);
	s->fd = fd;
	s->oflags = imode;
d2439 2
a2440 1
	PerlIOUnix_refcnt_inc(fd);
d2465 1
a2465 3
	    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
	    s->fd = fd;
	    PerlIOUnix_refcnt_inc(fd);
d2484 6
a2489 3
	    if (len < 0)
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    else if (len == 0 && count != 0)
d2491 2
d2506 5
a2510 2
	    if (len < 0)
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
a2516 9
IV
PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    Off_t new =
	PerlLIO_lseek(PerlIOSelf(f, PerlIOUnix)->fd, offset, whence);
    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
    return (new == (Off_t) - 1) ? -1 : 0;
}

d2536 1
a2536 1
	SETERRNO(EBADF,SS$_IVCHAN);
d2616 4
a2619 2
    while (*mode) {
	*tmode++ = *mode++;
d2621 1
a2621 1
#ifdef PERLIO_USING_CRLF
d2717 1
a2717 1
	    if (*mode == '#') {
d2722 8
a2729 1
		FILE *stdio = PerlSIO_fopen(path, mode);
d2735 4
a2738 3
		    if ((f = PerlIO_push(aTHX_ f, self,
				    (mode = PerlIOStdio_mode(mode, tmode)),
				    PerlIOArg))) {
d2753 1
a2753 1
	    if (*mode == 'I') {
d2799 2
d2802 4
a2805 4
	    int fd = PerlLIO_dup(fileno(stdio));
	    if (fd >= 0) {
		char mode[8];
		stdio = PerlSIO_fdopen(fd, PerlIO_modestr(o,mode));
d2813 2
d2821 90
a2913 4
#ifdef SOCKS5_VERSION_NAME
    int optval;
    Sock_size_t optlen = sizeof(int);
#endif
d2919 62
a2980 3
    if (PerlIOUnix_refcnt_dec(fileno(stdio)) > 0) {
	/* Do not close it but do flush any buffers */
	return PerlIO_flush(f);
a2981 11
    return (
#ifdef SOCKS5_VERSION_NAME
	       (getsockopt
		(PerlIO_fileno(f), SOL_SOCKET, SO_TYPE, (void *) &optval,
		 &optlen) <
		0) ? PerlSIO_fclose(stdio) : close(PerlIO_fileno(f))
#else
	       PerlSIO_fclose(stdio)
#endif
	);

a2983 2


d2989 12
a3000 10
    if (count == 1) {
	STDCHAR *buf = (STDCHAR *) vbuf;
	/*
	 * Perl is expecting PerlIO_getc() to fill the buffer Linux's
	 * stdio does not do that for fread()
	 */
	int ch = PerlSIO_fgetc(s);
	if (ch != EOF) {
	    *buf = ch;
	    got = 1;
d3002 8
a3010 2
    else
	got = PerlSIO_fread(vbuf, 1, count, s);
d3075 10
a3084 2
    return PerlSIO_fwrite(vbuf, 1, count,
			  PerlIOSelf(f, PerlIOStdio)->stdio);
d3324 7
a3330 6
#if (defined(STDIO_PTR_LVALUE) && (defined(STDIO_CNT_LVALUE) || defined(STDIO_PTR_LVAL_SETS_CNT)))
    PerlIOStdio_set_ptrcnt
#else                           /* STDIO_PTR_LVALUE */
    NULL
#endif                          /* STDIO_PTR_LVALUE */
#else                           /* USE_STDIO_PTR */
d3333 1
a3333 2
    NULL
#endif                          /* USE_STDIO_PTR */
d3352 1
d3355 2
a3356 2
	    if ((f = PerlIO_push(aTHX_ f, &PerlIO_stdio, buf, Nullsv))) {
		PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
d3434 6
a3439 3
	PerlIO_funcs *tab =  PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIOBase(next)->tab);
	next = (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			  next, narg, args);
d3447 1
a3447 1
	if (*mode == 'I') {
d3453 5
a3457 2
	f = (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			  f, narg, args);
d3476 1
a3476 1
		    PerlIO_binmode(f,  '<'/*not used*/, O_BINARY, Nullch);
d3699 5
d3762 13
d4062 17
d4178 4
a4187 1
			b->posn--;      /* Buffer starts here */
d4403 1
a4403 1
			SETERRNO(0, SS$_NORMAL);
d4867 37
a4903 29
    /*
     * I have no idea how portable mkstemp() is ...
     */
#if defined(WIN32) || !defined(HAVE_MKSTEMP)
    dTHX;
    PerlIO *f = NULL;
    FILE *stdio = PerlSIO_tmpfile();
    if (stdio) {
	if ((f = PerlIO_push(aTHX_(PerlIO_allocate(aTHX)), &PerlIO_stdio, "w+", Nullsv))) {
	    PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
	    s->stdio = stdio;
	}
    }
    return f;
#else
    dTHX;
    SV *sv = newSVpv("/tmp/PerlIO_XXXXXX", 0);
    int fd = mkstemp(SvPVX(sv));
    PerlIO *f = NULL;
    if (fd >= 0) {
	f = PerlIO_fdopen(fd, "w+");
	if (f) {
	    PerlIOBase(f)->flags |= PERLIO_F_TEMP;
	}
	PerlLIO_unlink(SvPVX(sv));
	SvREFCNT_dec(sv);
    }
    return f;
#endif
d4930 1
a4930 1
    SETERRNO(EINVAL, SS$_IVCHAN);
d4950 1
a4950 1
    SETERRNO(EINVAL, SS$_IVCHAN);
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 3463
a3463 8
/*    perlio.c
 *
 *    Copyright (c) 1996-2001, Nick Ing-Simmons
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
d3465 13
d3479 13
a3491 2
#define VOIDUSED 1
#include "config.h"
d3493 8
a3500 9
#define PERLIO_NOT_STDIO 0 
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
#define PerlIO FILE
#endif
/*
 * This file provides those parts of PerlIO abstraction 
 * which are not #defined in iperlsys.h.
 * Which these are depends on various Configure #ifdef's 
 */
d3502 10
a3511 3
#include "EXTERN.h"
#define PERL_IN_PERLIO_C
#include "perl.h"
d3513 18
a3530 1
#if !defined(PERL_IMPLICIT_SYS)
d3532 8
a3539 1
#ifdef PERLIO_IS_STDIO 
d3542 1
a3542 1
PerlIO_init(void)
d3544 9
a3552 5
 /* Does nothing (yet) except force this file to be included 
    in perl binary. That allows this file to force inclusion
    of other functions that may be required by loadable 
    extensions e.g. for FileHandle::tmpfile  
 */
a3554 1
#undef PerlIO_tmpfile
d3556 1
a3556 1
PerlIO_tmpfile(void)
d3558 1
a3558 1
 return tmpfile();
a3560 1
#else /* PERLIO_IS_STDIO */
a3561 1
#ifdef USE_SFIO
d3563 30
a3592 2
#undef HAS_FSETPOS
#undef HAS_FGETPOS
d3594 4
a3597 3
/* This section is just to make sure these functions 
   get pulled in from libsfio.a
*/
d3599 2
a3600 3
#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
d3602 5
a3606 1
 return sftmp(0);
d3609 2
a3610 2
void
PerlIO_init(void)
d3612 6
a3617 4
 /* Force this file to be included  in perl binary. Which allows 
  *  this file to force inclusion  of other functions that may be 
  *  required by loadable  extensions e.g. for FileHandle::tmpfile  
  */
d3619 8
a3626 6
 /* Hack
  * sfio does its own 'autoflush' on stdout in common cases.
  * Flush results in a lot of lseek()s to regular files and 
  * lot of small writes to pipes.
  */
 sfset(sfstdout,SF_SHARE,0);
a3628 1
#else /* USE_SFIO */
d3630 2
a3631 7
/* Implement all the PerlIO interface using stdio. 
   - this should be only file to include <stdio.h>
*/

#undef PerlIO_stderr
PerlIO *
PerlIO_stderr(void)
d3633 7
a3639 1
 return (PerlIO *) stderr;
d3642 2
a3643 3
#undef PerlIO_stdin
PerlIO *
PerlIO_stdin(void)
d3645 6
a3650 1
 return (PerlIO *) stdin;
d3653 2
a3654 3
#undef PerlIO_stdout
PerlIO *
PerlIO_stdout(void)
d3656 10
a3665 1
 return (PerlIO *) stdout;
d3668 2
a3669 3
#undef PerlIO_fast_gets
int 
PerlIO_fast_gets(PerlIO *f)
d3671 13
a3683 5
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
 return 1;
#else
 return 0;
#endif
d3686 56
a3741 8
#undef PerlIO_has_cntptr
int 
PerlIO_has_cntptr(PerlIO *f)
{
#if defined(USE_STDIO_PTR)
 return 1;
#else
 return 0;
d3743 1
d3746 3
a3748 3
#undef PerlIO_canset_cnt
int 
PerlIO_canset_cnt(PerlIO *f)
d3750 44
a3793 5
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
 return 1;
#else
 return 0;
#endif
d3796 2
a3797 3
#undef PerlIO_set_cnt
void
PerlIO_set_cnt(PerlIO *f, int cnt)
d3799 64
a3862 8
 dTHX;
 if (cnt < -1 && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting cnt to %d\n",cnt);
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
 FILE_cnt(f) = cnt;
#else
 Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system");
#endif
a3864 1
#undef PerlIO_set_ptrcnt
d3866 1
a3866 1
PerlIO_set_ptrcnt(PerlIO *f, STDCHAR *ptr, int cnt)
d3868 35
a3902 22
 dTHX;
#ifdef FILE_bufsiz
 STDCHAR *e = FILE_base(f) + FILE_bufsiz(f);
 int ec = e - ptr;
 if (ptr > e + 1 && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting ptr %p > end+1 %p\n", ptr, e + 1);
 if (cnt != ec && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting cnt to %d, ptr implies %d\n",cnt,ec);
#endif
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE)
  FILE_ptr(f) = ptr;
#else
  Perl_croak(aTHX_ "Cannot set 'ptr' of FILE * on this system");
#endif
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE) && defined (STDIO_PTR_LVAL_NOCHANGE_CNT)
  FILE_cnt(f) = cnt;
#else
#if defined(STDIO_PTR_LVAL_SETS_CNT)
  assert (FILE_cnt(f) == cnt);
#else
  Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system when setting 'ptr'");
#endif
d3904 13
d3919 2
a3920 3
#undef PerlIO_get_cnt
int 
PerlIO_get_cnt(PerlIO *f)
d3922 46
a3967 7
#ifdef FILE_cnt
 return FILE_cnt(f);
#else
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'cnt' of FILE * on this system");
 return -1;
#endif
d3970 2
a3971 3
#undef PerlIO_get_bufsiz
int 
PerlIO_get_bufsiz(PerlIO *f)
d3973 6
a3978 7
#ifdef FILE_bufsiz
 return FILE_bufsiz(f);
#else
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'bufsiz' of FILE * on this system");
 return -1;
#endif
d3981 2
a3982 3
#undef PerlIO_get_ptr
STDCHAR *
PerlIO_get_ptr(PerlIO *f)
d3984 8
a3991 6
#ifdef FILE_ptr
 return FILE_ptr(f);
#else
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'ptr' of FILE * on this system");
 return NULL;
d3993 2
d3997 88
a4084 6
#undef PerlIO_get_base
STDCHAR *
PerlIO_get_base(PerlIO *f)
{
#ifdef FILE_base
 return FILE_base(f);
d4086 7
a4092 3
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'base' of FILE * on this system");
 return NULL;
d4094 42
d4138 2
a4139 3
#undef PerlIO_has_base 
int 
PerlIO_has_base(PerlIO *f)
d4141 16
a4156 5
#ifdef FILE_base
 return 1;
#else
 return 0;
#endif
d4159 2
a4160 3
#undef PerlIO_puts
int
PerlIO_puts(PerlIO *f, const char *s)
d4162 28
a4189 1
 return fputs(s,f);
d4192 2
a4193 3
#undef PerlIO_open 
PerlIO * 
PerlIO_open(const char *path, const char *mode)
d4195 26
a4220 1
 return fopen(path,mode);
d4223 2
a4224 3
#undef PerlIO_fdopen
PerlIO * 
PerlIO_fdopen(int fd, const char *mode)
d4226 21
a4246 1
 return fdopen(fd,mode);
d4249 2
a4250 3
#undef PerlIO_reopen
PerlIO * 
PerlIO_reopen(const char *name, const char *mode, PerlIO *f)
d4252 23
a4274 1
 return freopen(name,mode,f);
d4277 2
a4278 3
#undef PerlIO_close
int      
PerlIO_close(PerlIO *f)
d4280 9
a4288 1
 return fclose(f);
d4291 2
a4292 3
#undef PerlIO_eof
int      
PerlIO_eof(PerlIO *f)
d4294 11
a4304 1
 return feof(f);
d4307 2
a4308 3
#undef PerlIO_getname
char *
PerlIO_getname(PerlIO *f, char *buf)
d4310 1
a4310 7
#ifdef VMS
 return fgetname(f,buf);
#else
 dTHX;
 Perl_croak(aTHX_ "Don't know how to get file name");
 return NULL;
#endif
a4312 6
#undef PerlIO_getc
int      
PerlIO_getc(PerlIO *f)
{
 return fgetc(f);
}
d4314 35
a4348 3
#undef PerlIO_error
int      
PerlIO_error(PerlIO *f)
d4350 4
a4353 1
 return ferror(f);
d4356 2
a4357 3
#undef PerlIO_clearerr
void
PerlIO_clearerr(PerlIO *f)
d4359 4
a4362 1
 clearerr(f);
d4365 2
a4366 3
#undef PerlIO_flush
int      
PerlIO_flush(PerlIO *f)
d4368 4
a4371 1
 return Fflush(f);
d4374 1
a4374 6
#undef PerlIO_fileno
int      
PerlIO_fileno(PerlIO *f)
{
 return fileno(f);
}
d4376 2
a4377 3
#undef PerlIO_setlinebuf
void
PerlIO_setlinebuf(PerlIO *f)
d4379 6
a4384 2
#ifdef HAS_SETLINEBUF
    setlinebuf(f);
d4386 1
a4386 5
#  ifdef __BORLANDC__ /* Borland doesn't like NULL size for _IOLBF */
    setvbuf(f, Nullch, _IOLBF, BUFSIZ);
#  else
    setvbuf(f, Nullch, _IOLBF, 0);
#  endif
d4388 1
d4391 10
a4400 3
#undef PerlIO_putc
int      
PerlIO_putc(PerlIO *f, int ch)
d4402 2
a4403 1
 return putc(ch,f);
d4406 3
a4408 3
#undef PerlIO_ungetc
int      
PerlIO_ungetc(PerlIO *f, int ch)
d4410 3
a4412 1
 return ungetc(ch,f);
d4415 3
a4417 3
#undef PerlIO_read
SSize_t
PerlIO_read(PerlIO *f, void *buf, Size_t count)
d4419 3
a4421 1
 return fread(buf,1,count,f);
d4424 3
a4426 3
#undef PerlIO_write
SSize_t
PerlIO_write(PerlIO *f, const void *buf, Size_t count)
d4428 7
a4434 1
 return fwrite1(buf,1,count,f);
d4437 3
a4439 3
#undef PerlIO_vprintf
int      
PerlIO_vprintf(PerlIO *f, const char *fmt, va_list ap)
d4441 7
a4447 1
 return vfprintf(f,fmt,ap);
d4450 3
a4452 3
#undef PerlIO_tell
Off_t
PerlIO_tell(PerlIO *f)
d4454 3
a4456 5
#if defined(USE_64_BIT_STDIO) && defined(HAS_FTELLO) && !defined(USE_FTELL64)
 return ftello(f);
#else
 return ftell(f);
#endif
d4459 1
a4459 1
#undef PerlIO_seek
d4461 1
a4461 1
PerlIO_seek(PerlIO *f, Off_t offset, int whence)
d4463 3
a4465 5
#if defined(USE_64_BIT_STDIO) && defined(HAS_FSEEKO) && !defined(USE_FSEEK64)
 return fseeko(f,offset,whence);
#else
 return fseek(f,offset,whence);
#endif
d4472 25
a4496 1
 rewind(f);
d4500 2
a4501 2
int      
PerlIO_printf(PerlIO *f,const char *fmt,...)
d4503 6
a4508 6
 va_list ap;
 int result;
 va_start(ap,fmt);
 result = vfprintf(f,fmt,ap);
 va_end(ap);
 return result;
d4512 2
a4513 2
int      
PerlIO_stdoutf(const char *fmt,...)
d4515 7
a4521 6
 va_list ap;
 int result;
 va_start(ap,fmt);
 result = PerlIO_vprintf(PerlIO_stdout(),fmt,ap);
 va_end(ap);
 return result;
d4528 29
a4556 1
 return tmpfile();
d4559 2
a4560 6
#undef PerlIO_importFILE
PerlIO *
PerlIO_importFILE(FILE *f, int fl)
{
 return f;
}
d4562 2
a4563 6
#undef PerlIO_exportFILE
FILE *
PerlIO_exportFILE(PerlIO *f, int fl)
{
 return f;
}
d4565 4
a4568 20
#undef PerlIO_findFILE
FILE *
PerlIO_findFILE(PerlIO *f)
{
 return f;
}

#undef PerlIO_releaseFILE
void
PerlIO_releaseFILE(PerlIO *p, FILE *f)
{
}

void
PerlIO_init(void)
{
 /* Does nothing (yet) except force this file to be included 
    in perl binary. That allows this file to force inclusion
    of other functions that may be required by loadable 
    extensions e.g. for FileHandle::tmpfile  
a4569 4
}

#endif /* USE_SFIO */
#endif /* PERLIO_IS_STDIO */
d4574 1
a4574 5
#ifdef USE_SFIO
PerlIO_setpos(PerlIO *f, const Off_t *pos)
#else
PerlIO_setpos(PerlIO *f, const Fpos_t *pos)
#endif
d4576 9
a4584 1
 return PerlIO_seek(f,*pos,0); 
a4586 1
#ifndef PERLIO_IS_STDIO
d4589 1
a4589 1
PerlIO_setpos(PerlIO *f, const Fpos_t *pos)
d4591 5
d4597 1
a4597 1
 return fsetpos64(f, pos);
d4599 1
a4599 1
 return fsetpos(f, pos);
d4601 4
a4606 1
#endif
d4611 1
a4611 8
#ifdef USE_SFIO
PerlIO_getpos(PerlIO *f, Off_t *pos)
{
 *pos = PerlIO_seek(f,0,0);
 return 0;
}
#else
PerlIO_getpos(PerlIO *f, Fpos_t *pos)
d4613 4
a4616 2
 *pos = PerlIO_tell(f);
 return 0;
a4617 1
#endif
a4618 1
#ifndef PERLIO_IS_STDIO
d4621 1
a4621 1
PerlIO_getpos(PerlIO *f, Fpos_t *pos)
d4623 3
d4627 1
a4627 1
 return fgetpos64(f, pos);
d4629 1
a4629 1
 return fgetpos(f, pos);
d4631 2
a4634 1
#endif
d4642 2
a4643 1
    return 0;		/* wrong, but perl doesn't use the return value */
d4650 2
a4651 1
    return 0;		/* wrong, but perl doesn't use the return value */
d4657 1
a4657 1
int 
d4660 8
a4667 8
 int val = vsprintf(s, fmt, ap);
 if (n >= 0)
  {
   if (strlen(s) >= (STRLEN)n)
    {
     dTHX;
     PerlIO_puts(Perl_error_log,"panic: sprintf overflow - memory corrupted!\n");
     my_exit(1);
d4669 1
a4669 2
  }
 return val;
d4674 2
a4675 2
int      
PerlIO_sprintf(char *s, int n, const char *fmt,...)
d4677 6
a4682 6
 va_list ap;
 int result;
 va_start(ap,fmt);
 result = PerlIO_vsprintf(s, n, fmt, ap);
 va_end(ap);
 return result;
d4686 6
a4691 1
#endif /* !PERL_IMPLICIT_SYS */
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1996-2000, Nick Ing-Simmons
d175 1
a175 1
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE)
d178 5
a182 1
  Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system");
d492 3
d496 1
d518 7
d530 1
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1996, Nick Ing-Simmons
d10 1
d25 1
d28 2
d147 3
a149 2
 if (cnt < -1)
  warn("Setting cnt to %d\n",cnt);
d153 1
a153 1
 croak("Cannot set 'cnt' of FILE * on this system");
d161 1
d165 4
a168 4
 if (ptr > e + 1)
  warn("Setting ptr %p > end+1 %p\n", ptr, e + 1);
 if (cnt != ec)
  warn("Setting cnt to %d, ptr implies %d\n",cnt,ec);
d171 1
a171 1
 FILE_ptr(f) = ptr;
d173 1
a173 1
 croak("Cannot set 'ptr' of FILE * on this system");
d176 1
a176 1
 FILE_cnt(f) = cnt;
d178 1
a178 1
 croak("Cannot set 'cnt' of FILE * on this system");
d189 2
a190 1
 croak("Cannot get 'cnt' of FILE * on this system");
d202 2
a203 1
 croak("Cannot get 'bufsiz' of FILE * on this system");
d215 2
a216 1
 croak("Cannot get 'ptr' of FILE * on this system");
d228 2
a229 1
 croak("Cannot get 'base' of FILE * on this system");
d294 2
a295 1
 croak("Don't know how to get file name");
a384 1

d389 3
d393 1
d400 3
d404 1
d498 3
d502 1
d521 3
d525 1
d557 2
a558 1
     PerlIO_puts(PerlIO_stderr(),"panic: sprintf overflow - memory corrupted!\n");
d578 2
@


1.1
log
@perl 5.004_04
@
text
@d19 1
a19 1
 * which are not #defined in perlio.h.
d29 1
a29 1
PerlIO_init()
d40 1
a40 1
PerlIO_tmpfile()
d58 1
a58 1
PerlIO_tmpfile()
d64 1
a64 1
PerlIO_init()
d79 1
a79 1
#else
d87 1
a87 1
PerlIO_stderr()
d94 1
a94 1
PerlIO_stdin()
d101 1
a101 1
PerlIO_stdout()
d108 1
a108 2
PerlIO_fast_gets(f)
PerlIO *f;
d119 1
a119 2
PerlIO_has_cntptr(f)
PerlIO *f;
d130 1
a130 2
PerlIO_canset_cnt(f)
PerlIO *f;
d141 1
a141 3
PerlIO_set_cnt(f,cnt)
PerlIO *f;
int cnt;
d154 1
a154 4
PerlIO_set_ptrcnt(f,ptr,cnt)
PerlIO *f;
STDCHAR *ptr;
int cnt;
d178 1
a178 2
PerlIO_get_cnt(f)
PerlIO *f;
d190 1
a190 2
PerlIO_get_bufsiz(f)
PerlIO *f;
d202 1
a202 2
PerlIO_get_ptr(f)
PerlIO *f;
d214 1
a214 2
PerlIO_get_base(f)
PerlIO *f;
d226 1
a226 2
PerlIO_has_base(f)
PerlIO *f;
d237 1
a237 3
PerlIO_puts(f,s)
PerlIO *f;
const char *s;
d244 1
a244 3
PerlIO_open(path,mode)
const char *path;
const char *mode;
d251 1
a251 3
PerlIO_fdopen(fd,mode)
int fd;
const char *mode;
d258 1
a258 4
PerlIO_reopen(name, mode, f)
const char *name;
const char *mode;
PerlIO *f;
d265 1
a265 2
PerlIO_close(f)
PerlIO *f;
d272 1
a272 2
PerlIO_eof(f)
PerlIO *f;
d279 1
a279 3
PerlIO_getname(f,buf)
PerlIO *f;
char *buf;
d291 1
a291 2
PerlIO_getc(f)
PerlIO *f;
d298 1
a298 2
PerlIO_error(f)
PerlIO *f;
d305 1
a305 2
PerlIO_clearerr(f)
PerlIO *f;
d312 1
a312 2
PerlIO_flush(f)
PerlIO *f;
d319 1
a319 2
PerlIO_fileno(f)
PerlIO *f;
d326 1
a326 2
PerlIO_setlinebuf(f)
PerlIO *f;
d341 1
a341 3
PerlIO_putc(f,ch)
PerlIO *f;
int ch;
d348 1
a348 3
PerlIO_ungetc(f,ch)
PerlIO *f;
int ch;
d355 1
a355 4
PerlIO_read(f,buf,count)
PerlIO *f;
void *buf;
Size_t count;
d362 1
a362 4
PerlIO_write(f,buf,count)
PerlIO *f;
const void *buf;
Size_t count;
d369 1
a369 4
PerlIO_vprintf(f,fmt,ap)
PerlIO *f;
const char *fmt;
va_list ap;
d376 2
a377 3
long
PerlIO_tell(f)
PerlIO *f;
d384 1
a384 4
PerlIO_seek(f,offset,whence)
PerlIO *f;
off_t offset;
int whence;
d391 1
a391 2
PerlIO_rewind(f)
PerlIO *f;
a397 1
#ifdef I_STDARG
a398 6
#else
PerlIO_printf(f,fmt,va_alist)
PerlIO *f;
const char *fmt;
va_dcl
#endif
a401 1
#ifdef I_STDARG
a402 3
#else
 va_start(ap);
#endif
a409 1
#ifdef I_STDARG
a410 5
#else
PerlIO_stdoutf(fmt, va_alist)
const char *fmt;
va_dcl
#endif
a413 1
#ifdef I_STDARG
a414 3
#else
 va_start(ap);
#endif
d422 1
a422 1
PerlIO_tmpfile()
d429 1
a429 3
PerlIO_importFILE(f,fl)
FILE *f;
int fl;
d436 1
a436 3
PerlIO_exportFILE(f,fl)
PerlIO *f;
int fl;
d443 1
a443 2
PerlIO_findFILE(f)
PerlIO *f;
d450 1
a450 3
PerlIO_releaseFILE(p,f)
PerlIO *p;
FILE *f;
d455 1
a455 1
PerlIO_init()
d470 1
a470 3
PerlIO_setpos(f,pos)
PerlIO *f;
const Fpos_t *pos;
d478 1
a478 3
PerlIO_setpos(f,pos)
PerlIO *f;
const Fpos_t *pos;
d488 1
a488 3
PerlIO_getpos(f,pos)
PerlIO *f;
Fpos_t *pos;
d497 1
a497 3
PerlIO_getpos(f,pos)
PerlIO *f;
Fpos_t *pos;
d507 1
a507 2
vprintf(pat, args)
char *pat, *args;
d514 1
a514 3
vfprintf(fd, pat, args)
FILE *fd;
char *pat, *args;
d524 1
a524 5
PerlIO_vsprintf(s,n,fmt,ap)
char *s;
const char *fmt;
int n;
va_list ap;
a540 1
#ifdef I_STDARG
a541 7
#else
PerlIO_sprintf(s, n, fmt, va_alist)
char *s;
int n;
const char *fmt;
va_dcl
#endif
a544 1
#ifdef I_STDARG
a545 3
#else
 va_start(ap);
#endif
@


1.1.1.1
log
@perl5.005_03
@
text
@d19 1
a19 1
 * which are not #defined in iperlsys.h.
d29 1
a29 1
PerlIO_init(void)
d40 1
a40 1
PerlIO_tmpfile(void)
d58 1
a58 1
PerlIO_tmpfile(void)
d64 1
a64 1
PerlIO_init(void)
d79 1
a79 1
#else /* USE_SFIO */
d87 1
a87 1
PerlIO_stderr(void)
d94 1
a94 1
PerlIO_stdin(void)
d101 1
a101 1
PerlIO_stdout(void)
d108 2
a109 1
PerlIO_fast_gets(PerlIO *f)
d120 2
a121 1
PerlIO_has_cntptr(PerlIO *f)
d132 2
a133 1
PerlIO_canset_cnt(PerlIO *f)
d144 3
a146 1
PerlIO_set_cnt(PerlIO *f, int cnt)
d159 4
a162 1
PerlIO_set_ptrcnt(PerlIO *f, STDCHAR *ptr, int cnt)
d186 2
a187 1
PerlIO_get_cnt(PerlIO *f)
d199 2
a200 1
PerlIO_get_bufsiz(PerlIO *f)
d212 2
a213 1
PerlIO_get_ptr(PerlIO *f)
d225 2
a226 1
PerlIO_get_base(PerlIO *f)
d238 2
a239 1
PerlIO_has_base(PerlIO *f)
d250 3
a252 1
PerlIO_puts(PerlIO *f, const char *s)
d259 3
a261 1
PerlIO_open(const char *path, const char *mode)
d268 3
a270 1
PerlIO_fdopen(int fd, const char *mode)
d277 4
a280 1
PerlIO_reopen(const char *name, const char *mode, PerlIO *f)
d287 2
a288 1
PerlIO_close(PerlIO *f)
d295 2
a296 1
PerlIO_eof(PerlIO *f)
d303 3
a305 1
PerlIO_getname(PerlIO *f, char *buf)
d317 2
a318 1
PerlIO_getc(PerlIO *f)
d325 2
a326 1
PerlIO_error(PerlIO *f)
d333 2
a334 1
PerlIO_clearerr(PerlIO *f)
d341 2
a342 1
PerlIO_flush(PerlIO *f)
d349 2
a350 1
PerlIO_fileno(PerlIO *f)
d357 2
a358 1
PerlIO_setlinebuf(PerlIO *f)
d373 3
a375 1
PerlIO_putc(PerlIO *f, int ch)
d382 3
a384 1
PerlIO_ungetc(PerlIO *f, int ch)
d391 4
a394 1
PerlIO_read(PerlIO *f, void *buf, Size_t count)
d401 4
a404 1
PerlIO_write(PerlIO *f, const void *buf, Size_t count)
d411 4
a414 1
PerlIO_vprintf(PerlIO *f, const char *fmt, va_list ap)
d421 3
a423 2
Off_t
PerlIO_tell(PerlIO *f)
d430 4
a433 1
PerlIO_seek(PerlIO *f, Off_t offset, int whence)
d440 2
a441 1
PerlIO_rewind(PerlIO *f)
d448 1
d450 6
d459 1
d461 3
d471 1
d473 5
d481 1
d483 3
d493 1
a493 1
PerlIO_tmpfile(void)
d500 3
a502 1
PerlIO_importFILE(FILE *f, int fl)
d509 3
a511 1
PerlIO_exportFILE(PerlIO *f, int fl)
d518 2
a519 1
PerlIO_findFILE(PerlIO *f)
d526 3
a528 1
PerlIO_releaseFILE(PerlIO *p, FILE *f)
d533 1
a533 1
PerlIO_init(void)
d548 3
a550 1
PerlIO_setpos(PerlIO *f, const Fpos_t *pos)
d558 3
a560 1
PerlIO_setpos(PerlIO *f, const Fpos_t *pos)
d570 3
a572 1
PerlIO_getpos(PerlIO *f, Fpos_t *pos)
d581 3
a583 1
PerlIO_getpos(PerlIO *f, Fpos_t *pos)
d593 2
a594 1
vprintf(char *pat, char *args)
d601 3
a603 1
vfprintf(FILE *fd, char *pat, char *args)
d613 5
a617 1
PerlIO_vsprintf(char *s, int n, const char *fmt, va_list ap)
d634 1
d636 7
d646 1
d648 3
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1996-2000, Nick Ing-Simmons
a9 1

a23 1
#define PERL_IN_PERLIO_C
a25 2
#if !defined(PERL_IMPLICIT_SYS)

d143 2
a144 3
 dTHX;
 if (cnt < -1 && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting cnt to %d\n",cnt);
d148 1
a148 1
 Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system");
a155 1
 dTHX;
d159 4
a162 4
 if (ptr > e + 1 && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting ptr %p > end+1 %p\n", ptr, e + 1);
 if (cnt != ec && ckWARN_d(WARN_INTERNAL))
  Perl_warner(aTHX_ WARN_INTERNAL, "Setting cnt to %d, ptr implies %d\n",cnt,ec);
d165 1
a165 1
  FILE_ptr(f) = ptr;
d167 1
a167 1
  Perl_croak(aTHX_ "Cannot set 'ptr' of FILE * on this system");
d170 1
a170 1
  FILE_cnt(f) = cnt;
d172 1
a172 1
  Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system");
d183 1
a183 2
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'cnt' of FILE * on this system");
d195 1
a195 2
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'bufsiz' of FILE * on this system");
d207 1
a207 2
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'ptr' of FILE * on this system");
d219 1
a219 2
 dTHX;
 Perl_croak(aTHX_ "Cannot get 'base' of FILE * on this system");
d284 1
a284 2
 dTHX;
 Perl_croak(aTHX_ "Don't know how to get file name");
d374 1
a378 3
#if defined(USE_64_BIT_STDIO) && defined(HAS_FTELLO) && !defined(USE_FTELL64)
 return ftello(f);
#else
a379 1
#endif
a385 3
#if defined(USE_64_BIT_STDIO) && defined(HAS_FSEEKO) && !defined(USE_FSEEK64)
 return fseeko(f,offset,whence);
#else
a386 1
#endif
a479 3
#if defined(USE_64_BIT_STDIO) && defined(USE_FSETPOS64)
 return fsetpos64(f, pos);
#else
a480 1
#endif
a498 3
#if defined(USE_64_BIT_STDIO) && defined(USE_FSETPOS64)
 return fgetpos64(f, pos);
#else
a499 1
#endif
d531 1
a531 2
     dTHX;
     PerlIO_puts(Perl_error_log,"panic: sprintf overflow - memory corrupted!\n");
a550 2

#endif /* !PERL_IMPLICIT_SYS */
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1996-2001, Nick Ing-Simmons
d175 1
a175 1
#if defined(USE_STDIO_PTR) && defined(STDIO_CNT_LVALUE) && defined (STDIO_PTR_LVAL_NOCHANGE_CNT)
d178 1
a178 5
#if defined(STDIO_PTR_LVAL_SETS_CNT)
  assert (FILE_cnt(f) == cnt);
#else
  Perl_croak(aTHX_ "Cannot set 'cnt' of FILE * on this system when setting 'ptr'");
#endif
a487 3
#ifdef USE_SFIO
PerlIO_setpos(PerlIO *f, const Off_t *pos)
#else
a488 1
#endif
a509 7
#ifdef USE_SFIO
PerlIO_getpos(PerlIO *f, Off_t *pos)
{
 *pos = PerlIO_seek(f,0,0);
 return 0;
}
#else
a514 1
#endif
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d1 7
a7 3191
/*
 * perlio.c Copyright (c) 1996-2002, Nick Ing-Simmons You may distribute
 * under the terms of either the GNU General Public License or the
 * Artistic License, as specified in the README file.
 */

/*
 * Hour after hour for nearly three weary days he had jogged up and down,
 * over passes, and through long dales, and across many streams.
 */

/*
 * If we have ActivePerl-like PERL_IMPLICIT_SYS then we need a dTHX to get
 * at the dispatch tables, even when we do not need it for other reasons.
 * Invent a dSYS macro to abstract this out
 */
#ifdef PERL_IMPLICIT_SYS
#define dSYS dTHX
#else
#define dSYS dNOOP
#endif

#define VOIDUSED 1
#ifdef PERL_MICRO
#   include "uconfig.h"
#else
#   include "config.h"
#endif

#define PERLIO_NOT_STDIO 0
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
/*
 * #define PerlIO FILE
 */
#endif
/*
 * This file provides those parts of PerlIO abstraction
 * which are not #defined in perlio.h.
 * Which these are depends on various Configure #ifdef's
 */

#include "EXTERN.h"
#define PERL_IN_PERLIO_C
#include "perl.h"

#ifdef PERL_IMPLICIT_CONTEXT
#undef dSYS
#define dSYS dTHX
#endif

#include "XSUB.h"

int
perlsio_binmode(FILE *fp, int iotype, int mode)
{
    /*
     * This used to be contents of do_binmode in doio.c
     */
#ifdef DOSISH
#  if defined(atarist) || defined(__MINT__)
    if (!fflush(fp)) {
	if (mode & O_BINARY)
	    ((FILE *) fp)->_flag |= _IOBIN;
	else
	    ((FILE *) fp)->_flag &= ~_IOBIN;
	return 1;
    }
    return 0;
#  else
    dTHX;
#ifdef NETWARE
    if (PerlLIO_setmode(fp, mode) != -1) {
#else
    if (PerlLIO_setmode(fileno(fp), mode) != -1) {
#endif
#    if defined(WIN32) && defined(__BORLANDC__)
	/*
	 * The translation mode of the stream is maintained independent of
	 * the translation mode of the fd in the Borland RTL (heavy
	 * digging through their runtime sources reveal).  User has to set
	 * the mode explicitly for the stream (though they don't document
	 * this anywhere). GSAR 97-5-24
	 */
	fseek(fp, 0L, 0);
	if (mode & O_BINARY)
	    fp->flags |= _F_BIN;
	else
	    fp->flags &= ~_F_BIN;
#    endif
	return 1;
    }
    else
	return 0;
#  endif
#else
#  if defined(USEMYBINMODE)
    dTHX;
    if (my_binmode(fp, iotype, mode) != FALSE)
	return 1;
    else
	return 0;
#  else
    return 1;
#  endif
#endif
}

#ifndef O_ACCMODE
#define O_ACCMODE 3             /* Assume traditional implementation */
#endif

int
PerlIO_intmode2str(int rawmode, char *mode, int *writing)
{
    int result = rawmode & O_ACCMODE;
    int ix = 0;
    int ptype;
    switch (result) {
    case O_RDONLY:
	ptype = IoTYPE_RDONLY;
	break;
    case O_WRONLY:
	ptype = IoTYPE_WRONLY;
	break;
    case O_RDWR:
    default:
	ptype = IoTYPE_RDWR;
	break;
    }
    if (writing)
	*writing = (result != O_RDONLY);

    if (result == O_RDONLY) {
	mode[ix++] = 'r';
    }
#ifdef O_APPEND
    else if (rawmode & O_APPEND) {
	mode[ix++] = 'a';
	if (result != O_WRONLY)
	    mode[ix++] = '+';
    }
#endif
    else {
	if (result == O_WRONLY)
	    mode[ix++] = 'w';
	else {
	    mode[ix++] = 'r';
	    mode[ix++] = '+';
	}
    }
    if (rawmode & O_BINARY)
	mode[ix++] = 'b';
    mode[ix] = '\0';
    return ptype;
}

#ifndef PERLIO_LAYERS
int
PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode, const char *names)
{
    if (!names || !*names
        || strEQ(names, ":crlf")
        || strEQ(names, ":raw")
        || strEQ(names, ":bytes")
       ) {
	return 0;
    }
    Perl_croak(aTHX_ "Cannot apply \"%s\" in non-PerlIO perl", names);
    /*
     * NOTREACHED
     */
    return -1;
}

void
PerlIO_destruct(pTHX)
{
}

int
PerlIO_binmode(pTHX_ PerlIO *fp, int iotype, int mode, const char *names)
{
#ifdef USE_SFIO
    return 1;
#else
    return perlsio_binmode(fp, iotype, mode);
#endif
}

PerlIO *
PerlIO_fdupopen(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
{
#ifdef PERL_MICRO
    return NULL;
#else
#ifdef PERL_IMPLICIT_SYS
    return PerlSIO_fdupopen(f);
#else
#ifdef WIN32
    return win32_fdupopen(f);
#else
    if (f) {
	int fd = PerlLIO_dup(PerlIO_fileno(f));
	if (fd >= 0) {
	    char mode[8];
	    int omode = fcntl(fd, F_GETFL);
#ifdef DJGPP
	    omode = djgpp_get_stream_mode(f);
#endif
	    PerlIO_intmode2str(omode,mode,NULL);
	    /* the r+ is a hack */
	    return PerlIO_fdopen(fd, mode);
	}
	return NULL;
    }
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
    }
#endif
    return NULL;
#endif
#endif
}


/*
 * De-mux PerlIO_openn() into fdopen, freopen and fopen type entries
 */

PerlIO *
PerlIO_openn(pTHX_ const char *layers, const char *mode, int fd,
	     int imode, int perm, PerlIO *old, int narg, SV **args)
{
    if (narg) {
	if (narg > 1) {
	    Perl_croak(aTHX_ "More than one argument to open");
	}
	if (*args == &PL_sv_undef)
	    return PerlIO_tmpfile();
	else {
	    char *name = SvPV_nolen(*args);
	    if (*mode == '#') {
		fd = PerlLIO_open3(name, imode, perm);
		if (fd >= 0)
		    return PerlIO_fdopen(fd, (char *) mode + 1);
	    }
	    else if (old) {
		return PerlIO_reopen(name, mode, old);
	    }
	    else {
		return PerlIO_open(name, mode);
	    }
	}
    }
    else {
	return PerlIO_fdopen(fd, (char *) mode);
    }
    return NULL;
}

XS(XS_PerlIO__Layer__find)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage class->find(name[,load])");
    else {
	char *name = SvPV_nolen(ST(1));
	ST(0) = (strEQ(name, "crlf")
		 || strEQ(name, "raw")) ? &PL_sv_yes : &PL_sv_undef;
	XSRETURN(1);
    }
}


void
Perl_boot_core_PerlIO(pTHX)
{
    newXS("PerlIO::Layer::find", XS_PerlIO__Layer__find, __FILE__);
}

#endif


#ifdef PERLIO_IS_STDIO

void
PerlIO_init(pTHX)
{
    /*
     * Does nothing (yet) except force this file to be included in perl
     * binary. That allows this file to force inclusion of other functions
     * that may be required by loadable extensions e.g. for
     * FileHandle::tmpfile
     */
}

#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
{
    return tmpfile();
}

#else                           /* PERLIO_IS_STDIO */

#ifdef USE_SFIO

#undef HAS_FSETPOS
#undef HAS_FGETPOS

/*
 * This section is just to make sure these functions get pulled in from
 * libsfio.a
 */

#undef PerlIO_tmpfile
PerlIO *
PerlIO_tmpfile(void)
{
    return sftmp(0);
}

void
PerlIO_init(pTHX)
{
    /*
     * Force this file to be included in perl binary. Which allows this
     * file to force inclusion of other functions that may be required by
     * loadable extensions e.g. for FileHandle::tmpfile
     */

    /*
     * Hack sfio does its own 'autoflush' on stdout in common cases. Flush
     * results in a lot of lseek()s to regular files and lot of small
     * writes to pipes.
     */
    sfset(sfstdout, SF_SHARE, 0);
}

/* This is not the reverse of PerlIO_exportFILE(), PerlIO_releaseFILE() is. */
PerlIO *
PerlIO_importFILE(FILE *stdio, const char *mode)
{
    int fd = fileno(stdio);
    if (!mode || !*mode) {
	mode = "r+";
    }
    return PerlIO_fdopen(fd, mode);
}

FILE *
PerlIO_findFILE(PerlIO *pio)
{
    int fd = PerlIO_fileno(pio);
    FILE *f = fdopen(fd, "r+");
    PerlIO_flush(pio);
    if (!f && errno == EINVAL)
	f = fdopen(fd, "w");
    if (!f && errno == EINVAL)
	f = fdopen(fd, "r");
    return f;
}


#else                           /* USE_SFIO */
/*======================================================================================*/
/*
 * Implement all the PerlIO interface ourselves.
 */

#include "perliol.h"

/*
 * We _MUST_ have <unistd.h> if we are using lseek() and may have large
 * files
 */
#ifdef I_UNISTD
#include <unistd.h>
#endif
#ifdef HAS_MMAP
#include <sys/mman.h>
#endif


void PerlIO_debug(const char *fmt, ...)
    __attribute__ ((format(__printf__, 1, 2)));

void
PerlIO_debug(const char *fmt, ...)
{
    static int dbg = 0;
    va_list ap;
    dSYS;
    va_start(ap, fmt);
    if (!dbg) {
	char *s = PerlEnv_getenv("PERLIO_DEBUG");
	if (s && *s)
	    dbg = PerlLIO_open3(s, O_WRONLY | O_CREAT | O_APPEND, 0666);
	else
	    dbg = -1;
    }
    if (dbg > 0) {
	dTHX;
#ifdef USE_ITHREADS
	/* Use fixed buffer as sv_catpvf etc. needs SVs */
	char buffer[1024];
	char *s;
	STRLEN len;
	s = CopFILE(PL_curcop);
	if (!s)
	    s = "(none)";
	sprintf(buffer, "%s:%" IVdf " ", s, (IV) CopLINE(PL_curcop));
	len = strlen(buffer);
	vsprintf(buffer+len, fmt, ap);
	PerlLIO_write(dbg, buffer, strlen(buffer));
#else
	SV *sv = newSVpvn("", 0);
	char *s;
	STRLEN len;
	s = CopFILE(PL_curcop);
	if (!s)
	    s = "(none)";
	Perl_sv_catpvf(aTHX_ sv, "%s:%" IVdf " ", s,
		       (IV) CopLINE(PL_curcop));
	Perl_sv_vcatpvf(aTHX_ sv, fmt, &ap);

	s = SvPV(sv, len);
	PerlLIO_write(dbg, s, len);
	SvREFCNT_dec(sv);
#endif
    }
    va_end(ap);
}

/*--------------------------------------------------------------------------------------*/

/*
 * Inner level routines
 */

/*
 * Table of pointers to the PerlIO structs (malloc'ed)
 */
#define PERLIO_TABLE_SIZE 64

PerlIO *
PerlIO_allocate(pTHX)
{
    /*
     * Find a free slot in the table, allocating new table as necessary
     */
    PerlIO **last;
    PerlIO *f;
    last = &PL_perlio;
    while ((f = *last)) {
	int i;
	last = (PerlIO **) (f);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    if (!*++f) {
		return f;
	    }
	}
    }
    Newz('I',f,PERLIO_TABLE_SIZE,PerlIO);
    if (!f) {
	return NULL;
    }
    *last = f;
    return f + 1;
}

#undef PerlIO_fdupopen
PerlIO *
PerlIO_fdupopen(pTHX_ PerlIO *f, CLONE_PARAMS *param, int flags)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	PerlIO *new;
	PerlIO_debug("fdupopen f=%p param=%p\n",(void*)f,(void*)param);
	new = (*tab->Dup)(aTHX_ PerlIO_allocate(aTHX),f,param, flags);
	return new;
    }
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return NULL;
    }
}

void
PerlIO_cleantable(pTHX_ PerlIO **tablep)
{
    PerlIO *table = *tablep;
    if (table) {
	int i;
	PerlIO_cleantable(aTHX_(PerlIO **) & (table[0]));
	for (i = PERLIO_TABLE_SIZE - 1; i > 0; i--) {
	    PerlIO *f = table + i;
	    if (*f) {
		PerlIO_close(f);
	    }
	}
	Safefree(table);
	*tablep = NULL;
    }
}


PerlIO_list_t *
PerlIO_list_alloc(pTHX)
{
    PerlIO_list_t *list;
    Newz('L', list, 1, PerlIO_list_t);
    list->refcnt = 1;
    return list;
}

void
PerlIO_list_free(pTHX_ PerlIO_list_t *list)
{
    if (list) {
	if (--list->refcnt == 0) {
	    if (list->array) {
		IV i;
		for (i = 0; i < list->cur; i++) {
		    if (list->array[i].arg)
			SvREFCNT_dec(list->array[i].arg);
		}
		Safefree(list->array);
	    }
	    Safefree(list);
	}
    }
}

void
PerlIO_list_push(pTHX_ PerlIO_list_t *list, PerlIO_funcs *funcs, SV *arg)
{
    PerlIO_pair_t *p;
    if (list->cur >= list->len) {
	list->len += 8;
	if (list->array)
	    Renew(list->array, list->len, PerlIO_pair_t);
	else
	    New('l', list->array, list->len, PerlIO_pair_t);
    }
    p = &(list->array[list->cur++]);
    p->funcs = funcs;
    if ((p->arg = arg)) {
	SvREFCNT_inc(arg);
    }
}

PerlIO_list_t *
PerlIO_clone_list(pTHX_ PerlIO_list_t *proto, CLONE_PARAMS *param)
{
    PerlIO_list_t *list = (PerlIO_list_t *) NULL;
    if (proto) {
	int i;
	list = PerlIO_list_alloc(aTHX);
	for (i=0; i < proto->cur; i++) {
	    SV *arg = Nullsv;
	    if (proto->array[i].arg)
		arg = PerlIO_sv_dup(aTHX_ proto->array[i].arg,param);
	    PerlIO_list_push(aTHX_ list, proto->array[i].funcs, arg);
	}
    }
    return list;
}

void
PerlIO_clone(pTHX_ PerlInterpreter *proto, CLONE_PARAMS *param)
{
#ifdef USE_ITHREADS
    PerlIO **table = &proto->Iperlio;
    PerlIO *f;
    PL_perlio = NULL;
    PL_known_layers = PerlIO_clone_list(aTHX_ proto->Iknown_layers, param);
    PL_def_layerlist = PerlIO_clone_list(aTHX_ proto->Idef_layerlist, param);
    PerlIO_allocate(aTHX); /* root slot is never used */
    PerlIO_debug("Clone %p from %p\n",aTHX,proto);
    while ((f = *table)) {
	    int i;
	    table = (PerlIO **) (f++);
	    for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
		if (*f) {
		    (void) fp_dup(f, 0, param);
		}
		f++;
	    }
	}
#endif
}

void
PerlIO_destruct(pTHX)
{
    PerlIO **table = &PL_perlio;
    PerlIO *f;
#ifdef USE_ITHREADS
    PerlIO_debug("Destruct %p\n",aTHX);
#endif
    while ((f = *table)) {
	int i;
	table = (PerlIO **) (f++);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    PerlIO *x = f;
	    PerlIOl *l;
	    while ((l = *x)) {
		if (l->tab->kind & PERLIO_K_DESTRUCT) {
		    PerlIO_debug("Destruct popping %s\n", l->tab->name);
		    PerlIO_flush(x);
		    PerlIO_pop(aTHX_ x);
		}
		else {
		    x = PerlIONext(x);
		}
	    }
	    f++;
	}
    }
}

void
PerlIO_pop(pTHX_ PerlIO *f)
{
    PerlIOl *l = *f;
    if (l) {
	PerlIO_debug("PerlIO_pop f=%p %s\n", (void*)f, l->tab->name);
	if (l->tab->Popped) {
	    /*
	     * If popped returns non-zero do not free its layer structure
	     * it has either done so itself, or it is shared and still in
	     * use
	     */
	    if ((*l->tab->Popped) (aTHX_ f) != 0)
		return;
	}
	*f = l->next;
	Safefree(l);
    }
}

/*--------------------------------------------------------------------------------------*/
/*
 * XS Interface for perl code
 */

PerlIO_funcs *
PerlIO_find_layer(pTHX_ const char *name, STRLEN len, int load)
{
    IV i;
    if ((SSize_t) len <= 0)
	len = strlen(name);
    for (i = 0; i < PL_known_layers->cur; i++) {
	PerlIO_funcs *f = PL_known_layers->array[i].funcs;
	if (memEQ(f->name, name, len)) {
	    PerlIO_debug("%.*s => %p\n", (int) len, name, (void*)f);
	    return f;
	}
    }
    if (load && PL_subname && PL_def_layerlist
	&& PL_def_layerlist->cur >= 2) {
	SV *pkgsv = newSVpvn("PerlIO", 6);
	SV *layer = newSVpvn(name, len);
	ENTER;
	/*
	 * The two SVs are magically freed by load_module
	 */
	Perl_load_module(aTHX_ 0, pkgsv, Nullsv, layer, Nullsv);
	LEAVE;
	return PerlIO_find_layer(aTHX_ name, len, 0);
    }
    PerlIO_debug("Cannot find %.*s\n", (int) len, name);
    return NULL;
}

#ifdef USE_ATTRIBUTES_FOR_PERLIO

static int
perlio_mg_set(pTHX_ SV *sv, MAGIC *mg)
{
    if (SvROK(sv)) {
	IO *io = GvIOn((GV *) SvRV(sv));
	PerlIO *ifp = IoIFP(io);
	PerlIO *ofp = IoOFP(io);
	Perl_warn(aTHX_ "set %" SVf " %p %p %p", sv, io, ifp, ofp);
    }
    return 0;
}

static int
perlio_mg_get(pTHX_ SV *sv, MAGIC *mg)
{
    if (SvROK(sv)) {
	IO *io = GvIOn((GV *) SvRV(sv));
	PerlIO *ifp = IoIFP(io);
	PerlIO *ofp = IoOFP(io);
	Perl_warn(aTHX_ "get %" SVf " %p %p %p", sv, io, ifp, ofp);
    }
    return 0;
}

static int
perlio_mg_clear(pTHX_ SV *sv, MAGIC *mg)
{
    Perl_warn(aTHX_ "clear %" SVf, sv);
    return 0;
}

static int
perlio_mg_free(pTHX_ SV *sv, MAGIC *mg)
{
    Perl_warn(aTHX_ "free %" SVf, sv);
    return 0;
}

MGVTBL perlio_vtab = {
    perlio_mg_get,
    perlio_mg_set,
    NULL,                       /* len */
    perlio_mg_clear,
    perlio_mg_free
};

XS(XS_io_MODIFY_SCALAR_ATTRIBUTES)
{
    dXSARGS;
    SV *sv = SvRV(ST(1));
    AV *av = newAV();
    MAGIC *mg;
    int count = 0;
    int i;
    sv_magic(sv, (SV *) av, PERL_MAGIC_ext, NULL, 0);
    SvRMAGICAL_off(sv);
    mg = mg_find(sv, PERL_MAGIC_ext);
    mg->mg_virtual = &perlio_vtab;
    mg_magical(sv);
    Perl_warn(aTHX_ "attrib %" SVf, sv);
    for (i = 2; i < items; i++) {
	STRLEN len;
	const char *name = SvPV(ST(i), len);
	SV *layer = PerlIO_find_layer(aTHX_ name, len, 1);
	if (layer) {
	    av_push(av, SvREFCNT_inc(layer));
	}
	else {
	    ST(count) = ST(i);
	    count++;
	}
    }
    SvREFCNT_dec(av);
    XSRETURN(count);
}

#endif                          /* USE_ATTIBUTES_FOR_PERLIO */

SV *
PerlIO_tab_sv(pTHX_ PerlIO_funcs *tab)
{
    HV *stash = gv_stashpv("PerlIO::Layer", TRUE);
    SV *sv = sv_bless(newRV_noinc(newSViv(PTR2IV(tab))), stash);
    return sv;
}

XS(XS_PerlIO__Layer__find)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage class->find(name[,load])");
    else {
	STRLEN len = 0;
	char *name = SvPV(ST(1), len);
	bool load = (items > 2) ? SvTRUE(ST(2)) : 0;
	PerlIO_funcs *layer = PerlIO_find_layer(aTHX_ name, len, load);
	ST(0) =
	    (layer) ? sv_2mortal(PerlIO_tab_sv(aTHX_ layer)) :
	    &PL_sv_undef;
	XSRETURN(1);
    }
}

void
PerlIO_define_layer(pTHX_ PerlIO_funcs *tab)
{
    if (!PL_known_layers)
	PL_known_layers = PerlIO_list_alloc(aTHX);
    PerlIO_list_push(aTHX_ PL_known_layers, tab, Nullsv);
    PerlIO_debug("define %s %p\n", tab->name, (void*)tab);
}

int
PerlIO_parse_layers(pTHX_ PerlIO_list_t *av, const char *names)
{
    if (names) {
	const char *s = names;
	while (*s) {
	    while (isSPACE(*s) || *s == ':')
		s++;
	    if (*s) {
		STRLEN llen = 0;
		const char *e = s;
		const char *as = Nullch;
		STRLEN alen = 0;
		if (!isIDFIRST(*s)) {
		    /*
		     * Message is consistent with how attribute lists are
		     * passed. Even though this means "foo : : bar" is
		     * seen as an invalid separator character.
		     */
		    char q = ((*s == '\'') ? '"' : '\'');
		    if (ckWARN(WARN_LAYER))
			Perl_warner(aTHX_ packWARN(WARN_LAYER),
			      "perlio: invalid separator character %c%c%c in layer specification list %s",
			      q, *s, q, s);
		    SETERRNO(EINVAL, LIB$_INVARG);
		    return -1;
		}
		do {
		    e++;
		} while (isALNUM(*e));
		llen = e - s;
		if (*e == '(') {
		    int nesting = 1;
		    as = ++e;
		    while (nesting) {
			switch (*e++) {
			case ')':
			    if (--nesting == 0)
				alen = (e - 1) - as;
			    break;
			case '(':
			    ++nesting;
			    break;
			case '\\':
			    /*
			     * It's a nul terminated string, not allowed
			     * to \ the terminating null. Anything other
			     * character is passed over.
			     */
			    if (*e++) {
				break;
			    }
			    /*
			     * Drop through
			     */
			case '\0':
			    e--;
			    if (ckWARN(WARN_LAYER))
				Perl_warner(aTHX_ packWARN(WARN_LAYER),
				      "perlio: argument list not closed for layer \"%.*s\"",
				      (int) (e - s), s);
			    return -1;
			default:
			    /*
			     * boring.
			     */
			    break;
			}
		    }
		}
		if (e > s) {
		    bool warn_layer = ckWARN(WARN_LAYER);
		    PerlIO_funcs *layer =
			PerlIO_find_layer(aTHX_ s, llen, 1);
		    if (layer) {
			PerlIO_list_push(aTHX_ av, layer,
					 (as) ? newSVpvn(as,
							 alen) :
					 &PL_sv_undef);
		    }
		    else {
			if (warn_layer)
			    Perl_warner(aTHX_ packWARN(WARN_LAYER), "perlio: unknown layer \"%.*s\"",
				  (int) llen, s);
			return -1;
		    }
		}
		s = e;
	    }
	}
    }
    return 0;
}

void
PerlIO_default_buffer(pTHX_ PerlIO_list_t *av)
{
    PerlIO_funcs *tab = &PerlIO_perlio;
#ifdef PERLIO_USING_CRLF
    tab = &PerlIO_crlf;
#else
    if (PerlIO_stdio.Set_ptrcnt)
	tab = &PerlIO_stdio;
#endif
    PerlIO_debug("Pushing %s\n", tab->name);
    PerlIO_list_push(aTHX_ av, PerlIO_find_layer(aTHX_ tab->name, 0, 0),
		     &PL_sv_undef);
}

SV *
PerlIO_arg_fetch(PerlIO_list_t *av, IV n)
{
    return av->array[n].arg;
}

PerlIO_funcs *
PerlIO_layer_fetch(pTHX_ PerlIO_list_t *av, IV n, PerlIO_funcs *def)
{
    if (n >= 0 && n < av->cur) {
	PerlIO_debug("Layer %" IVdf " is %s\n", n,
		     av->array[n].funcs->name);
	return av->array[n].funcs;
    }
    if (!def)
	Perl_croak(aTHX_ "panic: PerlIO layer array corrupt");
    return def;
}

IV
PerlIOPop_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    if (PerlIOValid(f)) {
	PerlIO_flush(f);
	PerlIO_pop(aTHX_ f);
	return 0;
    }
    return -1;
}

PerlIO_funcs PerlIO_remove = {
    sizeof(PerlIO_funcs),
    "pop",
    0,
    PERLIO_K_DUMMY | PERLIO_K_UTF8,
    PerlIOPop_pushed,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PerlIO_list_t *
PerlIO_default_layers(pTHX)
{
    if (!PL_def_layerlist) {
	const char *s = (PL_tainting) ? Nullch : PerlEnv_getenv("PERLIO");
	PerlIO_funcs *osLayer = &PerlIO_unix;
	PL_def_layerlist = PerlIO_list_alloc(aTHX);
	PerlIO_define_layer(aTHX_ & PerlIO_unix);
#if defined(WIN32) && !defined(UNDER_CE)
	PerlIO_define_layer(aTHX_ & PerlIO_win32);
#if 0
	osLayer = &PerlIO_win32;
#endif
#endif
	PerlIO_define_layer(aTHX_ & PerlIO_raw);
	PerlIO_define_layer(aTHX_ & PerlIO_perlio);
	PerlIO_define_layer(aTHX_ & PerlIO_stdio);
	PerlIO_define_layer(aTHX_ & PerlIO_crlf);
#ifdef HAS_MMAP
	PerlIO_define_layer(aTHX_ & PerlIO_mmap);
#endif
	PerlIO_define_layer(aTHX_ & PerlIO_utf8);
	PerlIO_define_layer(aTHX_ & PerlIO_remove);
	PerlIO_define_layer(aTHX_ & PerlIO_byte);
	PerlIO_list_push(aTHX_ PL_def_layerlist,
			 PerlIO_find_layer(aTHX_ osLayer->name, 0, 0),
			 &PL_sv_undef);
	if (s) {
	    PerlIO_parse_layers(aTHX_ PL_def_layerlist, s);
	}
	else {
	    PerlIO_default_buffer(aTHX_ PL_def_layerlist);
	}
    }
    if (PL_def_layerlist->cur < 2) {
	PerlIO_default_buffer(aTHX_ PL_def_layerlist);
    }
    return PL_def_layerlist;
}

void
Perl_boot_core_PerlIO(pTHX)
{
#ifdef USE_ATTRIBUTES_FOR_PERLIO
    newXS("io::MODIFY_SCALAR_ATTRIBUTES", XS_io_MODIFY_SCALAR_ATTRIBUTES,
	  __FILE__);
#endif
    newXS("PerlIO::Layer::find", XS_PerlIO__Layer__find, __FILE__);
}

PerlIO_funcs *
PerlIO_default_layer(pTHX_ I32 n)
{
    PerlIO_list_t *av = PerlIO_default_layers(aTHX);
    if (n < 0)
	n += av->cur;
    return PerlIO_layer_fetch(aTHX_ av, n, &PerlIO_stdio);
}

#define PerlIO_default_top() PerlIO_default_layer(aTHX_ -1)
#define PerlIO_default_btm() PerlIO_default_layer(aTHX_ 0)

void
PerlIO_stdstreams(pTHX)
{
    if (!PL_perlio) {
	PerlIO_allocate(aTHX);
	PerlIO_fdopen(0, "Ir" PERLIO_STDTEXT);
	PerlIO_fdopen(1, "Iw" PERLIO_STDTEXT);
	PerlIO_fdopen(2, "Iw" PERLIO_STDTEXT);
    }
}

PerlIO *
PerlIO_push(pTHX_ PerlIO *f, PerlIO_funcs *tab, const char *mode, SV *arg)
{
    if (tab->fsize != sizeof(PerlIO_funcs)) {
      mismatch:
	Perl_croak(aTHX_ "Layer does not match this perl");
    }
    if (tab->size) {
	PerlIOl *l = NULL;
	if (tab->size < sizeof(PerlIOl)) {
	    goto mismatch;
	}
	/* Real layer with a data area */
	Newc('L',l,tab->size,char,PerlIOl);
	if (l && f) {
	    Zero(l, tab->size, char);
	    l->next = *f;
	    l->tab = tab;
	    *f = l;
	    PerlIO_debug("PerlIO_push f=%p %s %s %p\n", (void*)f, tab->name,
			(mode) ? mode : "(Null)", (void*)arg);
	    if ((*l->tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
		PerlIO_pop(aTHX_ f);
		return NULL;
	    }
	}
    }
    else if (f) {
	/* Pseudo-layer where push does its own stack adjust */
	PerlIO_debug("PerlIO_push f=%p %s %s %p\n", (void*)f, tab->name,
		     (mode) ? mode : "(Null)", (void*)arg);
	if ((*tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
	    return NULL;
	}
    }
    return f;
}

IV
PerlIOBase_binmode(pTHX_ PerlIO *f)
{
   if (PerlIOValid(f)) {
	/* Is layer suitable for raw stream ? */
	if (PerlIOBase(f)->tab->kind & PERLIO_K_RAW) {
	    /* Yes - turn off UTF-8-ness, to undo UTF-8 locale effects */
	    PerlIOBase(f)->flags &= ~PERLIO_F_UTF8;
	}
	else {
	    /* Not suitable - pop it */
	    PerlIO_pop(aTHX_ f);
	}
	return 0;
   }
   return -1;
}

IV
PerlIORaw_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{

    if (PerlIOValid(f)) {
	PerlIO *t;
	PerlIOl *l;
	PerlIO_flush(f);
	/*
	 * Strip all layers that are not suitable for a raw stream
	 */
	t = f;
	while (t && (l = *t)) {
	    if (l->tab->Binmode) {
		/* Has a handler - normal case */
		if ((*l->tab->Binmode)(aTHX_ f) == 0) {
		    if (*t == l) {
			/* Layer still there - move down a layer */
			t = PerlIONext(t);
		    }
		}
		else {
		    return -1;
		}
	    }
	    else {
		/* No handler - pop it */
		PerlIO_pop(aTHX_ t);
	    }
	}
	if (PerlIOValid(f)) {
	    PerlIO_debug(":raw f=%p :%s\n", (void*)f, PerlIOBase(f)->tab->name);
	    return 0;
	}
    }
    return -1;
}

int
PerlIO_apply_layera(pTHX_ PerlIO *f, const char *mode,
		    PerlIO_list_t *layers, IV n, IV max)
{
    int code = 0;
    while (n < max) {
	PerlIO_funcs *tab = PerlIO_layer_fetch(aTHX_ layers, n, NULL);
	if (tab) {
	    if (!PerlIO_push(aTHX_ f, tab, mode, PerlIOArg)) {
		code = -1;
		break;
	    }
	}
	n++;
    }
    return code;
}

int
PerlIO_apply_layers(pTHX_ PerlIO *f, const char *mode, const char *names)
{
    int code = 0;
    if (f && names) {
	PerlIO_list_t *layers = PerlIO_list_alloc(aTHX);
	code = PerlIO_parse_layers(aTHX_ layers, names);
	if (code == 0) {
	    code = PerlIO_apply_layera(aTHX_ f, mode, layers, 0, layers->cur);
	}
	PerlIO_list_free(aTHX_ layers);
    }
    return code;
}


/*--------------------------------------------------------------------------------------*/
/*
 * Given the abstraction above the public API functions
 */

int
PerlIO_binmode(pTHX_ PerlIO *f, int iotype, int mode, const char *names)
{
    PerlIO_debug("PerlIO_binmode f=%p %s %c %x %s\n",
		 (void*)f, PerlIOBase(f)->tab->name, iotype, mode,
		 (names) ? names : "(Null)");
    if (names) {
	/* Do not flush etc. if (e.g.) switching encodings.
	   if a pushed layer knows it needs to flush lower layers
	   (for example :unix which is never going to call them)
	   it can do the flush when it is pushed.
	 */
	return PerlIO_apply_layers(aTHX_ f, NULL, names) == 0 ? TRUE : FALSE;
    }
    else {
	/* Fake 5.6 legacy of using this call to turn ON O_TEXT */
#ifdef PERLIO_USING_CRLF
	/* Legacy binmode only has meaning if O_TEXT has a value distinct from
	   O_BINARY so we can look for it in mode.
	 */
	if (!(mode & O_BINARY)) {
	    /* Text mode */
	    /* FIXME?: Looking down the layer stack seems wrong,
	       but is a way of reaching past (say) an encoding layer
	       to flip CRLF-ness of the layer(s) below
	     */
	    while (*f) {
		/* Perhaps we should turn on bottom-most aware layer
		   e.g. Ilya's idea that UNIX TTY could serve
		 */
		if (PerlIOBase(f)->tab->kind & PERLIO_K_CANCRLF) {
		    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF)) {
			/* Not in text mode - flush any pending stuff and flip it */
			PerlIO_flush(f);
			PerlIOBase(f)->flags |= PERLIO_F_CRLF;
		    }
		    /* Only need to turn it on in one layer so we are done */
		    return TRUE;
		}
		f = PerlIONext(f);
	    }
	    /* Not finding a CRLF aware layer presumably means we are binary
	       which is not what was requested - so we failed
	       We _could_ push :crlf layer but so could caller
	     */
	    return FALSE;
	}
#endif
	/* Legacy binmode is now _defined_ as being equivalent to pushing :raw
	   So code that used to be here is now in PerlIORaw_pushed().
	 */
	return PerlIO_push(aTHX_ f, &PerlIO_raw, Nullch, Nullsv) ? TRUE : FALSE;
    }
}

int
PerlIO__close(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Close) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_close(pTHX_ PerlIO *f)
{
    int code = -1;
    if (PerlIOValid(f)) {
	code = (*PerlIOBase(f)->tab->Close) (aTHX_ f);
	while (*f) {
	    PerlIO_pop(aTHX_ f);
	}
    }
    return code;
}

int
Perl_PerlIO_fileno(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Fileno) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

static const char *
PerlIO_context_layers(pTHX_ const char *mode)
{
    const char *type = NULL;
    /*
     * Need to supply default layer info from open.pm
     */
    if (PL_curcop) {
	SV *layers = PL_curcop->cop_io;
	if (layers) {
	    STRLEN len;
	    type = SvPV(layers, len);
	    if (type && mode[0] != 'r') {
		/*
		 * Skip to write part
		 */
		const char *s = strchr(type, 0);
		if (s && (STRLEN)(s - type) < len) {
		    type = s + 1;
		}
	    }
	}
    }
    return type;
}

static PerlIO_funcs *
PerlIO_layer_from_ref(pTHX_ SV *sv)
{
    /*
     * For any scalar type load the handler which is bundled with perl
     */
    if (SvTYPE(sv) < SVt_PVAV)
	return PerlIO_find_layer(aTHX_ "scalar", 6, 1);

    /*
     * For other types allow if layer is known but don't try and load it
     */
    switch (SvTYPE(sv)) {
    case SVt_PVAV:
	return PerlIO_find_layer(aTHX_ "Array", 5, 0);
    case SVt_PVHV:
	return PerlIO_find_layer(aTHX_ "Hash", 4, 0);
    case SVt_PVCV:
	return PerlIO_find_layer(aTHX_ "Code", 4, 0);
    case SVt_PVGV:
	return PerlIO_find_layer(aTHX_ "Glob", 4, 0);
    }
    return NULL;
}

PerlIO_list_t *
PerlIO_resolve_layers(pTHX_ const char *layers,
		      const char *mode, int narg, SV **args)
{
    PerlIO_list_t *def = PerlIO_default_layers(aTHX);
    int incdef = 1;
    if (!PL_perlio)
	PerlIO_stdstreams(aTHX);
    if (narg) {
	SV *arg = *args;
	/*
	 * If it is a reference but not an object see if we have a handler
	 * for it
	 */
	if (SvROK(arg) && !sv_isobject(arg)) {
	    PerlIO_funcs *handler = PerlIO_layer_from_ref(aTHX_ SvRV(arg));
	    if (handler) {
		def = PerlIO_list_alloc(aTHX);
		PerlIO_list_push(aTHX_ def, handler, &PL_sv_undef);
		incdef = 0;
	    }
	    /*
	     * Don't fail if handler cannot be found :via(...) etc. may do
	     * something sensible else we will just stringfy and open
	     * resulting string.
	     */
	}
    }
    if (!layers)
	layers = PerlIO_context_layers(aTHX_ mode);
    if (layers && *layers) {
	PerlIO_list_t *av;
	if (incdef) {
	    IV i = def->cur;
	    av = PerlIO_list_alloc(aTHX);
	    for (i = 0; i < def->cur; i++) {
		PerlIO_list_push(aTHX_ av, def->array[i].funcs,
				 def->array[i].arg);
	    }
	}
	else {
	    av = def;
	}
	if (PerlIO_parse_layers(aTHX_ av, layers) == 0) {
	     return av;
	}
	else {
	    PerlIO_list_free(aTHX_ av);
	    return (PerlIO_list_t *) NULL;
	}
    }
    else {
	if (incdef)
	    def->refcnt++;
	return def;
    }
}

PerlIO *
PerlIO_openn(pTHX_ const char *layers, const char *mode, int fd,
	     int imode, int perm, PerlIO *f, int narg, SV **args)
{
    if (!f && narg == 1 && *args == &PL_sv_undef) {
	if ((f = PerlIO_tmpfile())) {
	    if (!layers)
		layers = PerlIO_context_layers(aTHX_ mode);
	    if (layers && *layers)
		PerlIO_apply_layers(aTHX_ f, mode, layers);
	}
    }
    else {
	PerlIO_list_t *layera = NULL;
	IV n;
	PerlIO_funcs *tab = NULL;
	if (PerlIOValid(f)) {
	    /*
	     * This is "reopen" - it is not tested as perl does not use it
	     * yet
	     */
	    PerlIOl *l = *f;
	    layera = PerlIO_list_alloc(aTHX);
	    while (l) {
		SV *arg = (l->tab->Getarg)
			? (*l->tab->Getarg) (aTHX_ &l, NULL, 0)
			: &PL_sv_undef;
		PerlIO_list_push(aTHX_ layera, l->tab, arg);
		l = *PerlIONext(&l);
	    }
	}
	else {
	    layera = PerlIO_resolve_layers(aTHX_ layers, mode, narg, args);
	    if (!layera) {
		return NULL;
	    }
	}
	/*
	 * Start at "top" of layer stack
	 */
	n = layera->cur - 1;
	while (n >= 0) {
	    PerlIO_funcs *t = PerlIO_layer_fetch(aTHX_ layera, n, NULL);
	    if (t && t->Open) {
		tab = t;
		break;
	    }
	    n--;
	}
	if (tab) {
	    /*
	     * Found that layer 'n' can do opens - call it
	     */
	    if (narg > 1 && !(tab->kind & PERLIO_K_MULTIARG)) {
		Perl_croak(aTHX_ "More than one argument to open(,':%s')",tab->name);
	    }
	    PerlIO_debug("openn(%s,'%s','%s',%d,%x,%o,%p,%d,%p)\n",
			 tab->name, layers, mode, fd, imode, perm,
			 (void*)f, narg, (void*)args);
	    f = (*tab->Open) (aTHX_ tab, layera, n, mode, fd, imode, perm,
			      f, narg, args);
	    if (f) {
		if (n + 1 < layera->cur) {
		    /*
		     * More layers above the one that we used to open -
		     * apply them now
		     */
		    if (PerlIO_apply_layera(aTHX_ f, mode, layera, n + 1, layera->cur) != 0) {
			/* If pushing layers fails close the file */
			PerlIO_close(f);
			f = NULL;
		    }
		}
	    }
	}
	PerlIO_list_free(aTHX_ layera);
    }
    return f;
}


SSize_t
Perl_PerlIO_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Read) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

SSize_t
Perl_PerlIO_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Unread) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

SSize_t
Perl_PerlIO_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Write) (aTHX_ f, vbuf, count);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Seek) (aTHX_ f, offset, whence);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

Off_t
Perl_PerlIO_tell(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Tell) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_flush(pTHX_ PerlIO *f)
{
    if (f) {
	if (*f) {
	    PerlIO_funcs *tab = PerlIOBase(f)->tab;
	    if (tab && tab->Flush) {
		return (*tab->Flush) (aTHX_ f);
	    }
	    else {
		PerlIO_debug("Cannot flush f=%p :%s\n", (void*)f, tab->name);
		SETERRNO(EBADF, SS$_IVCHAN);
		return -1;
	    }
	}
	else {
	    PerlIO_debug("Cannot flush f=%p\n", (void*)f);
	    SETERRNO(EBADF, SS$_IVCHAN);
	    return -1;
	}
    }
    else {
	/*
	 * Is it good API design to do flush-all on NULL, a potentially
	 * errorneous input? Maybe some magical value (PerlIO*
	 * PERLIO_FLUSH_ALL = (PerlIO*)-1;)? Yes, stdio does similar
	 * things on fflush(NULL), but should we be bound by their design
	 * decisions? --jhi
	 */
	PerlIO **table = &PL_perlio;
	int code = 0;
	while ((f = *table)) {
	    int i;
	    table = (PerlIO **) (f++);
	    for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
		if (*f && PerlIO_flush(f) != 0)
		    code = -1;
		f++;
	    }
	}
	return code;
    }
}

void
PerlIOBase_flush_linebuf(pTHX)
{
    PerlIO **table = &PL_perlio;
    PerlIO *f;
    while ((f = *table)) {
	int i;
	table = (PerlIO **) (f++);
	for (i = 1; i < PERLIO_TABLE_SIZE; i++) {
	    if (*f
		&& (PerlIOBase(f)->
		    flags & (PERLIO_F_LINEBUF | PERLIO_F_CANWRITE))
		== (PERLIO_F_LINEBUF | PERLIO_F_CANWRITE))
		PerlIO_flush(f);
	    f++;
	}
    }
}

int
Perl_PerlIO_fill(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Fill) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
PerlIO_isutf8(PerlIO *f)
{
    if (PerlIOValid(f))
	return (PerlIOBase(f)->flags & PERLIO_F_UTF8) != 0;
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_eof(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Eof) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

int
Perl_PerlIO_error(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Error) (aTHX_ f);
    else {
	SETERRNO(EBADF, SS$_IVCHAN);
	return -1;
    }
}

void
Perl_PerlIO_clearerr(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	(*PerlIOBase(f)->tab->Clearerr) (aTHX_ f);
    else
	SETERRNO(EBADF, SS$_IVCHAN);
}

void
Perl_PerlIO_setlinebuf(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	(*PerlIOBase(f)->tab->Setlinebuf) (aTHX_ f);
    else
	SETERRNO(EBADF, SS$_IVCHAN);
}

int
PerlIO_has_base(PerlIO *f)
{
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->tab->Get_base != NULL);
    }
    return 0;
}

int
PerlIO_fast_gets(PerlIO *f)
{
    if (PerlIOValid(f) && (PerlIOBase(f)->flags & PERLIO_F_FASTGETS)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	return (tab->Set_ptrcnt != NULL);
    }
    return 0;
}

int
PerlIO_has_cntptr(PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	return (tab->Get_ptr != NULL && tab->Get_cnt != NULL);
    }
    return 0;
}

int
PerlIO_canset_cnt(PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIOl *l = PerlIOBase(f);
	return (l->tab->Set_ptrcnt != NULL);
    }
    return 0;
}

STDCHAR *
Perl_PerlIO_get_base(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Get_base) (aTHX_ f);
    return NULL;
}

int
Perl_PerlIO_get_bufsiz(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f))
	return (*PerlIOBase(f)->tab->Get_bufsiz) (aTHX_ f);
    return 0;
}

STDCHAR *
Perl_PerlIO_get_ptr(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Get_ptr == NULL)
	    return NULL;
	return (*tab->Get_ptr) (aTHX_ f);
    }
    return NULL;
}

int
Perl_PerlIO_get_cnt(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Get_cnt == NULL)
	   return 0;
	return (*tab->Get_cnt) (aTHX_ f);
    }
    return 0;
}

void
Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, int cnt)
{
    if (PerlIOValid(f)) {
	(*PerlIOBase(f)->tab->Set_ptrcnt) (aTHX_ f, NULL, cnt);
    }
}

void
Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, int cnt)
{
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab->Set_ptrcnt == NULL) {
	    Perl_croak(aTHX_ "PerlIO buffer snooping abuse");
	}
	(*PerlIOBase(f)->tab->Set_ptrcnt) (aTHX_ f, ptr, cnt);
    }
}


/*--------------------------------------------------------------------------------------*/
/*
 * utf8 and raw dummy layers
 */

IV
PerlIOUtf8_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    if (PerlIOValid(f)) {
	if (tab->kind & PERLIO_K_UTF8)
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	else
	    PerlIOBase(f)->flags &= ~PERLIO_F_UTF8;
	return 0;
    }
    return -1;
}

PerlIO_funcs PerlIO_utf8 = {
    sizeof(PerlIO_funcs),
    "utf8",
    0,
    PERLIO_K_DUMMY | PERLIO_K_UTF8,
    PerlIOUtf8_pushed,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PerlIO_funcs PerlIO_byte = {
    sizeof(PerlIO_funcs),
    "bytes",
    0,
    PERLIO_K_DUMMY,
    PerlIOUtf8_pushed,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

PerlIO *
PerlIORaw_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *old, int narg, SV **args)
{
    PerlIO_funcs *tab = PerlIO_default_btm();
    return (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			 old, narg, args);
}

PerlIO_funcs PerlIO_raw = {
    sizeof(PerlIO_funcs),
    "raw",
    0,
    PERLIO_K_DUMMY,
    PerlIORaw_pushed,
    PerlIOBase_popped,
    PerlIORaw_open,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* flush */
    NULL,                       /* fill */
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};
/*--------------------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------------------*/
/*
 * "Methods" of the "base class"
 */

IV
PerlIOBase_fileno(pTHX_ PerlIO *f)
{
    return PerlIOValid(f) ? PerlIO_fileno(PerlIONext(f)) : -1;
}

char *
PerlIO_modestr(PerlIO * f, char *buf)
{
    char *s = buf;
    if (PerlIOValid(f)) {
	IV flags = PerlIOBase(f)->flags;
	if (flags & PERLIO_F_APPEND) {
	    *s++ = 'a';
	    if (flags & PERLIO_F_CANREAD) {
		*s++ = '+';
	    }
	}
	else if (flags & PERLIO_F_CANREAD) {
	    *s++ = 'r';
	    if (flags & PERLIO_F_CANWRITE)
		*s++ = '+';
	}
	else if (flags & PERLIO_F_CANWRITE) {
	    *s++ = 'w';
	    if (flags & PERLIO_F_CANREAD) {
		*s++ = '+';
	    }
	}
#ifdef PERLIO_USING_CRLF
	if (!(flags & PERLIO_F_CRLF))
	    *s++ = 'b';
#endif
    }
    *s = '\0';
    return buf;
}


IV
PerlIOBase_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIOl *l = PerlIOBase(f);
#if 0
    const char *omode = mode;
    char temp[8];
#endif
    l->flags &= ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE |
		  PERLIO_F_TRUNCATE | PERLIO_F_APPEND);
    if (tab->Set_ptrcnt != NULL)
	l->flags |= PERLIO_F_FASTGETS;
    if (mode) {
	if (*mode == '#' || *mode == 'I')
	    mode++;
	switch (*mode++) {
	case 'r':
	    l->flags |= PERLIO_F_CANREAD;
	    break;
	case 'a':
	    l->flags |= PERLIO_F_APPEND | PERLIO_F_CANWRITE;
	    break;
	case 'w':
	    l->flags |= PERLIO_F_TRUNCATE | PERLIO_F_CANWRITE;
	    break;
	default:
	    SETERRNO(EINVAL, LIB$_INVARG);
	    return -1;
	}
	while (*mode) {
	    switch (*mode++) {
	    case '+':
		l->flags |= PERLIO_F_CANREAD | PERLIO_F_CANWRITE;
		break;
	    case 'b':
		l->flags &= ~PERLIO_F_CRLF;
		break;
	    case 't':
		l->flags |= PERLIO_F_CRLF;
		break;
	    default:
		SETERRNO(EINVAL, LIB$_INVARG);
		return -1;
	    }
	}
    }
    else {
	if (l->next) {
	    l->flags |= l->next->flags &
		(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_TRUNCATE |
		 PERLIO_F_APPEND);
	}
    }
#if 0
    PerlIO_debug("PerlIOBase_pushed f=%p %s %s fl=%08" UVxf " (%s)\n",
		 f, PerlIOBase(f)->tab->name, (omode) ? omode : "(Null)",
		 l->flags, PerlIO_modestr(f, temp));
#endif
    return 0;
}

IV
PerlIOBase_popped(pTHX_ PerlIO *f)
{
    return 0;
}

SSize_t
PerlIOBase_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    /*
     * Save the position as current head considers it
     */
    Off_t old = PerlIO_tell(f);
    SSize_t done;
    PerlIO_push(aTHX_ f, &PerlIO_pending, "r", Nullsv);
    PerlIOSelf(f, PerlIOBuf)->posn = old;
    done = PerlIOBuf_unread(aTHX_ f, vbuf, count);
    return done;
}

SSize_t
PerlIOBase_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    STDCHAR *buf = (STDCHAR *) vbuf;
    if (f) {
	if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD))
	    return 0;
	while (count > 0) {
	    SSize_t avail = PerlIO_get_cnt(f);
	    SSize_t take = 0;
	    if (avail > 0)
		take = ((SSize_t)count < avail) ? count : avail;
	    if (take > 0) {
		STDCHAR *ptr = PerlIO_get_ptr(f);
		Copy(ptr, buf, take, STDCHAR);
		PerlIO_set_ptrcnt(f, ptr + take, (avail -= take));
		count -= take;
		buf += take;
	    }
	    if (count > 0 && avail <= 0) {
		if (PerlIO_fill(f) != 0)
		    break;
	    }
	}
	return (buf - (STDCHAR *) vbuf);
    }
    return 0;
}

IV
PerlIOBase_noop_ok(pTHX_ PerlIO *f)
{
    return 0;
}

IV
PerlIOBase_noop_fail(pTHX_ PerlIO *f)
{
    return -1;
}

IV
PerlIOBase_close(pTHX_ PerlIO *f)
{
    IV code = 0;
    PerlIO *n = PerlIONext(f);
    if (PerlIO_flush(f) != 0)
	code = -1;
    if (PerlIOValid(n) && (*PerlIOBase(n)->tab->Close)(aTHX_ n) != 0)
	code = -1;
    PerlIOBase(f)->flags &=
	~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
    return code;
}

IV
PerlIOBase_eof(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->flags & PERLIO_F_EOF) != 0;
    }
    return 1;
}

IV
PerlIOBase_error(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	return (PerlIOBase(f)->flags & PERLIO_F_ERROR) != 0;
    }
    return 1;
}

void
PerlIOBase_clearerr(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIO *n = PerlIONext(f);
	PerlIOBase(f)->flags &= ~(PERLIO_F_ERROR | PERLIO_F_EOF);
	if (PerlIOValid(n))
	    PerlIO_clearerr(n);
    }
}

void
PerlIOBase_setlinebuf(pTHX_ PerlIO *f)
{
    if (PerlIOValid(f)) {
	PerlIOBase(f)->flags |= PERLIO_F_LINEBUF;
    }
}

SV *
PerlIO_sv_dup(pTHX_ SV *arg, CLONE_PARAMS *param)
{
    if (!arg)
	return Nullsv;
#ifdef sv_dup
    if (param) {
	return sv_dup(arg, param);
    }
    else {
	return newSVsv(arg);
    }
#else
    return newSVsv(arg);
#endif
}

PerlIO *
PerlIOBase_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    PerlIO *nexto = PerlIONext(o);
    if (PerlIOValid(nexto)) {
	PerlIO_funcs *tab = PerlIOBase(nexto)->tab;
	f = (*tab->Dup)(aTHX_ f, nexto, param, flags);
    }
    if (f) {
	PerlIO_funcs *self = PerlIOBase(o)->tab;
	SV *arg = Nullsv;
	char buf[8];
	PerlIO_debug("PerlIOBase_dup %s f=%p o=%p param=%p\n",
		     self->name, (void*)f, (void*)o, (void*)param);
	if (self->Getarg) {
	    arg = (*self->Getarg)(aTHX_ o,param,flags);
	}
	f = PerlIO_push(aTHX_ f, self, PerlIO_modestr(o,buf), arg);
	if (arg) {
	    SvREFCNT_dec(arg);
	}
    }
    return f;
}

#define PERLIO_MAX_REFCOUNTABLE_FD 2048
#ifdef USE_THREADS
perl_mutex PerlIO_mutex;
#endif
int PerlIO_fd_refcnt[PERLIO_MAX_REFCOUNTABLE_FD];

void
PerlIO_init(pTHX)
{
 /* Place holder for stdstreams call ??? */
#ifdef USE_THREADS
 MUTEX_INIT(&PerlIO_mutex);
#endif
}

void
PerlIOUnix_refcnt_inc(int fd)
{
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
#ifdef USE_THREADS
	MUTEX_LOCK(&PerlIO_mutex);
#endif
	PerlIO_fd_refcnt[fd]++;
	PerlIO_debug("fd %d refcnt=%d\n",fd,PerlIO_fd_refcnt[fd]);
#ifdef USE_THREADS
	MUTEX_UNLOCK(&PerlIO_mutex);
#endif
    }
}

int
PerlIOUnix_refcnt_dec(int fd)
{
    int cnt = 0;
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
#ifdef USE_THREADS
	MUTEX_LOCK(&PerlIO_mutex);
#endif
	cnt = --PerlIO_fd_refcnt[fd];
	PerlIO_debug("fd %d refcnt=%d\n",fd,cnt);
#ifdef USE_THREADS
	MUTEX_UNLOCK(&PerlIO_mutex);
#endif
    }
    return cnt;
}

void
PerlIO_cleanup(pTHX)
{
    int i;
#ifdef USE_ITHREADS
    PerlIO_debug("Cleanup layers for %p\n",aTHX);
#else
    PerlIO_debug("Cleanup layers\n");
#endif
    /* Raise STDIN..STDERR refcount so we don't close them */
    for (i=0; i < 3; i++)
	PerlIOUnix_refcnt_inc(i);
    PerlIO_cleantable(aTHX_ &PL_perlio);
    /* Restore STDIN..STDERR refcount */
    for (i=0; i < 3; i++)
	PerlIOUnix_refcnt_dec(i);

    if (PL_known_layers) {
	PerlIO_list_free(aTHX_ PL_known_layers);
	PL_known_layers = NULL;
    }
    if(PL_def_layerlist) {
	PerlIO_list_free(aTHX_ PL_def_layerlist);
	PL_def_layerlist = NULL;
    }
}



/*--------------------------------------------------------------------------------------*/
/*
 * Bottom-most level for UNIX-like case
 */

typedef struct {
    struct _PerlIO base;        /* The generic part */
    int fd;                     /* UNIX like file descriptor */
    int oflags;                 /* open/fcntl flags */
} PerlIOUnix;

int
PerlIOUnix_oflags(const char *mode)
{
    int oflags = -1;
    if (*mode == 'I' || *mode == '#')
	mode++;
    switch (*mode) {
    case 'r':
	oflags = O_RDONLY;
	if (*++mode == '+') {
	    oflags = O_RDWR;
	    mode++;
	}
	break;

    case 'w':
	oflags = O_CREAT | O_TRUNC;
	if (*++mode == '+') {
	    oflags |= O_RDWR;
	    mode++;
	}
	else
	    oflags |= O_WRONLY;
	break;

    case 'a':
	oflags = O_CREAT | O_APPEND;
	if (*++mode == '+') {
	    oflags |= O_RDWR;
	    mode++;
	}
	else
	    oflags |= O_WRONLY;
	break;
    }
    if (*mode == 'b') {
	oflags |= O_BINARY;
	oflags &= ~O_TEXT;
	mode++;
    }
    else if (*mode == 't') {
	oflags |= O_TEXT;
	oflags &= ~O_BINARY;
	mode++;
    }
    /*
     * Always open in binary mode
     */
    oflags |= O_BINARY;
    if (*mode || oflags == -1) {
	SETERRNO(EINVAL, LIB$_INVARG);
	oflags = -1;
    }
    return oflags;
}

IV
PerlIOUnix_fileno(pTHX_ PerlIO *f)
{
    return PerlIOSelf(f, PerlIOUnix)->fd;
}

IV
PerlIOUnix_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
    if (*PerlIONext(f)) {
	/* We never call down so do any pending stuff now */
	PerlIO_flush(PerlIONext(f));
	s->fd = PerlIO_fileno(PerlIONext(f));
	/*
	 * XXX could (or should) we retrieve the oflags from the open file
	 * handle rather than believing the "mode" we are passed in? XXX
	 * Should the value on NULL mode be 0 or -1?
	 */
	s->oflags = mode ? PerlIOUnix_oflags(mode) : -1;
    }
    PerlIOBase(f)->flags |= PERLIO_F_OPEN;
    return code;
}

PerlIO *
PerlIOUnix_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
		IV n, const char *mode, int fd, int imode,
		int perm, PerlIO *f, int narg, SV **args)
{
    if (PerlIOValid(f)) {
	if (PerlIOBase(f)->flags & PERLIO_F_OPEN)
	    (*PerlIOBase(f)->tab->Close)(aTHX_ f);
    }
    if (narg > 0) {
	char *path = SvPV_nolen(*args);
	if (*mode == '#')
	    mode++;
	else {
	    imode = PerlIOUnix_oflags(mode);
	    perm = 0666;
	}
	if (imode != -1) {
	    fd = PerlLIO_open3(path, imode, perm);
	}
    }
    if (fd >= 0) {
	PerlIOUnix *s;
	if (*mode == 'I')
	    mode++;
	if (!f) {
	    f = PerlIO_allocate(aTHX);
	}
	if (!PerlIOValid(f)) {
	    if (!(f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg))) {
		return NULL;
	    }
	}
	s = PerlIOSelf(f, PerlIOUnix);
	s->fd = fd;
	s->oflags = imode;
	PerlIOBase(f)->flags |= PERLIO_F_OPEN;
	PerlIOUnix_refcnt_inc(fd);
	return f;
    }
    else {
	if (f) {
	    /*
	     * FIXME: pop layers ???
	     */
	}
	return NULL;
    }
}

PerlIO *
PerlIOUnix_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    PerlIOUnix *os = PerlIOSelf(o, PerlIOUnix);
    int fd = os->fd;
    if (flags & PERLIO_DUP_FD) {
	fd = PerlLIO_dup(fd);
    }
    if (fd >= 0 && fd < PERLIO_MAX_REFCOUNTABLE_FD) {
	f = PerlIOBase_dup(aTHX_ f, o, param, flags);
	if (f) {
	    /* If all went well overwrite fd in dup'ed lay with the dup()'ed fd */
	    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
	    s->fd = fd;
	    PerlIOUnix_refcnt_inc(fd);
	    return f;
	}
    }
    return NULL;
}


SSize_t
PerlIOUnix_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD) ||
         PerlIOBase(f)->flags & (PERLIO_F_EOF|PERLIO_F_ERROR)) {
	return 0;
    }
    while (1) {
	SSize_t len = PerlLIO_read(fd, vbuf, count);
	if (len >= 0 || errno != EINTR) {
	    if (len < 0)
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    else if (len == 0 && count != 0)
		PerlIOBase(f)->flags |= PERLIO_F_EOF;
	    return len;
	}
	PERL_ASYNC_CHECK();
    }
}

SSize_t
PerlIOUnix_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    while (1) {
	SSize_t len = PerlLIO_write(fd, vbuf, count);
	if (len >= 0 || errno != EINTR) {
	    if (len < 0)
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    return len;
	}
	PERL_ASYNC_CHECK();
    }
}

IV
PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    Off_t new =
	PerlLIO_lseek(PerlIOSelf(f, PerlIOUnix)->fd, offset, whence);
    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
    return (new == (Off_t) - 1) ? -1 : 0;
}

Off_t
PerlIOUnix_tell(pTHX_ PerlIO *f)
{
    return PerlLIO_lseek(PerlIOSelf(f, PerlIOUnix)->fd, 0, SEEK_CUR);
}


IV
PerlIOUnix_close(pTHX_ PerlIO *f)
{
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    int code = 0;
    if (PerlIOBase(f)->flags & PERLIO_F_OPEN) {
	if (PerlIOUnix_refcnt_dec(fd) > 0) {
	    PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
	    return 0;
	}
    }
    else {
	SETERRNO(EBADF,SS$_IVCHAN);
	return -1;
    }
    while (PerlLIO_close(fd) != 0) {
	if (errno != EINTR) {
	    code = -1;
	    break;
	}
	PERL_ASYNC_CHECK();
    }
    if (code == 0) {
	PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
    }
    return code;
}

PerlIO_funcs PerlIO_unix = {
    sizeof(PerlIO_funcs),
    "unix",
    sizeof(PerlIOUnix),
    PERLIO_K_RAW,
    PerlIOUnix_pushed,
    PerlIOBase_popped,
    PerlIOUnix_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOUnix_fileno,
    PerlIOUnix_dup,
    PerlIOUnix_read,
    PerlIOBase_unread,
    PerlIOUnix_write,
    PerlIOUnix_seek,
    PerlIOUnix_tell,
    PerlIOUnix_close,
    PerlIOBase_noop_ok,         /* flush */
    PerlIOBase_noop_fail,       /* fill */
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    NULL,                       /* get_base */
    NULL,                       /* get_bufsiz */
    NULL,                       /* get_ptr */
    NULL,                       /* get_cnt */
    NULL,                       /* set_ptrcnt */
};

/*--------------------------------------------------------------------------------------*/
/*
 * stdio as a layer
 */

#if defined(VMS) && !defined(STDIO_BUFFER_WRITABLE)
/* perl5.8 - This ensures the last minute VMS ungetc fix is not
   broken by the last second glibc 2.3 fix
 */
#define STDIO_BUFFER_WRITABLE
#endif


typedef struct {
    struct _PerlIO base;
    FILE *stdio;                /* The stream */
} PerlIOStdio;

IV
PerlIOStdio_fileno(pTHX_ PerlIO *f)
{
    FILE *s;
    if (PerlIOValid(f) && (s = PerlIOSelf(f, PerlIOStdio)->stdio)) {
	return PerlSIO_fileno(s);
    }
    errno = EBADF;
    return -1;
}

char *
PerlIOStdio_mode(const char *mode, char *tmode)
{
    char *ret = tmode;
    while (*mode) {
	*tmode++ = *mode++;
    }
#ifdef PERLIO_USING_CRLF
    *tmode++ = 'b';
#endif
    *tmode = '\0';
    return ret;
}

IV
PerlIOStdio_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIO *n;
    if (PerlIOValid(f) && PerlIOValid(n = PerlIONext(f))) {
        PerlIO_funcs *toptab = PerlIOBase(n)->tab;
        if (toptab == tab) {
	    /* Top is already stdio - pop self (duplicate) and use original */
	    PerlIO_pop(aTHX_ f);
	    return 0;
	} else {
	    int fd = PerlIO_fileno(n);
	    char tmode[8];
	    FILE *stdio;
	    if (fd >= 0 && (stdio  = PerlSIO_fdopen(fd,
			    mode = PerlIOStdio_mode(mode, tmode)))) {
		PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
	    	/* We never call down so do any pending stuff now */
	    	PerlIO_flush(PerlIONext(f));
	    }
	    else {
		return -1;
	    }
        }
    }
    return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
}


PerlIO *
PerlIO_importFILE(FILE *stdio, const char *mode)
{
    dTHX;
    PerlIO *f = NULL;
    if (stdio) {
	PerlIOStdio *s;
	if (!mode || !*mode) {
	    /* We need to probe to see how we can open the stream
	       so start with read/write and then try write and read
	       we dup() so that we can fclose without loosing the fd.

	       Note that the errno value set by a failing fdopen
	       varies between stdio implementations.
	     */
	    int fd = PerlLIO_dup(fileno(stdio));
	    FILE *f2 = PerlSIO_fdopen(fd, (mode = "r+"));
	    if (!f2) {
		f2 = PerlSIO_fdopen(fd, (mode = "w"));
	    }
	    if (!f2) {
		f2 = PerlSIO_fdopen(fd, (mode = "r"));
	    }
	    if (!f2) {
		/* Don't seem to be able to open */
		PerlLIO_close(fd);
		return f;
	    }
	    fclose(f2);
	}
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), &PerlIO_stdio, mode, Nullsv))) {
	    s = PerlIOSelf(f, PerlIOStdio);
	    s->stdio = stdio;
	}
    }
    return f;
}

PerlIO *
PerlIOStdio_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
		 IV n, const char *mode, int fd, int imode,
		 int perm, PerlIO *f, int narg, SV **args)
{
    char tmode[8];
    if (PerlIOValid(f)) {
	char *path = SvPV_nolen(*args);
	PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
	FILE *stdio;
	PerlIOUnix_refcnt_dec(fileno(s->stdio));
	stdio = PerlSIO_freopen(path, (mode = PerlIOStdio_mode(mode, tmode)),
			    s->stdio);
	if (!s->stdio)
	    return NULL;
	s->stdio = stdio;
	PerlIOUnix_refcnt_inc(fileno(s->stdio));
	return f;
    }
    else {
	if (narg > 0) {
	    char *path = SvPV_nolen(*args);
	    if (*mode == '#') {
		mode++;
		fd = PerlLIO_open3(path, imode, perm);
	    }
	    else {
		FILE *stdio = PerlSIO_fopen(path, mode);
		if (stdio) {
		    PerlIOStdio *s;
		    if (!f) {
			f = PerlIO_allocate(aTHX);
		    }
		    if ((f = PerlIO_push(aTHX_ f, self,
				    (mode = PerlIOStdio_mode(mode, tmode)),
				    PerlIOArg))) {
			s = PerlIOSelf(f, PerlIOStdio);
			s->stdio = stdio;
			PerlIOUnix_refcnt_inc(fileno(s->stdio));
		    }
		    return f;
		}
		else {
		    return NULL;
		}
	    }
	}
	if (fd >= 0) {
	    FILE *stdio = NULL;
	    int init = 0;
	    if (*mode == 'I') {
		init = 1;
		mode++;
	    }
	    if (init) {
		switch (fd) {
		case 0:
		    stdio = PerlSIO_stdin;
		    break;
		case 1:
		    stdio = PerlSIO_stdout;
		    break;
		case 2:
		    stdio = PerlSIO_stderr;
		    break;
		}
	    }
	    else {
		stdio = PerlSIO_fdopen(fd, mode =
				       PerlIOStdio_mode(mode, tmode));
	    }
	    if (stdio) {
		PerlIOStdio *s;
		if (!f) {
		    f = PerlIO_allocate(aTHX);
		}
		if ((f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg))) {
		    s = PerlIOSelf(f, PerlIOStdio);
		    s->stdio = stdio;
		    PerlIOUnix_refcnt_inc(fileno(s->stdio));
		}
		return f;
	    }
	}
    }
    return NULL;
}

PerlIO *
PerlIOStdio_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
{
    /* This assumes no layers underneath - which is what
       happens, but is not how I remember it. NI-S 2001/10/16
     */
    if ((f = PerlIOBase_dup(aTHX_ f, o, param, flags))) {
	FILE *stdio = PerlIOSelf(o, PerlIOStdio)->stdio;
	if (flags & PERLIO_DUP_FD) {
	    int fd = PerlLIO_dup(fileno(stdio));
	    if (fd >= 0) {
		char mode[8];
		stdio = PerlSIO_fdopen(fd, PerlIO_modestr(o,mode));
	    }
	    else {
		/* FIXME: To avoid messy error recovery if dup fails
		   re-use the existing stdio as though flag was not set
		 */
	    }
	}
	PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
	PerlIOUnix_refcnt_inc(fileno(stdio));
    }
    return f;
}

IV
PerlIOStdio_close(pTHX_ PerlIO *f)
{
#ifdef SOCKS5_VERSION_NAME
    int optval;
    Sock_size_t optlen = sizeof(int);
#endif
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (!stdio) {
	errno = EBADF;
	return -1;
    }
    if (PerlIOUnix_refcnt_dec(fileno(stdio)) > 0) {
	/* Do not close it but do flush any buffers */
	return PerlIO_flush(f);
    }
    return (
#ifdef SOCKS5_VERSION_NAME
	       (getsockopt
		(PerlIO_fileno(f), SOL_SOCKET, SO_TYPE, (void *) &optval,
		 &optlen) <
		0) ? PerlSIO_fclose(stdio) : close(PerlIO_fileno(f))
#else
	       PerlSIO_fclose(stdio)
#endif
	);

}



SSize_t
PerlIOStdio_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    FILE *s = PerlIOSelf(f, PerlIOStdio)->stdio;
    SSize_t got = 0;
    if (count == 1) {
	STDCHAR *buf = (STDCHAR *) vbuf;
	/*
	 * Perl is expecting PerlIO_getc() to fill the buffer Linux's
	 * stdio does not do that for fread()
	 */
	int ch = PerlSIO_fgetc(s);
	if (ch != EOF) {
	    *buf = ch;
	    got = 1;
	}
    }
    else
	got = PerlSIO_fread(vbuf, 1, count, s);
    return got;
}

SSize_t
PerlIOStdio_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    SSize_t unread = 0;
    FILE *s = PerlIOSelf(f, PerlIOStdio)->stdio;

#ifdef STDIO_BUFFER_WRITABLE
    if (PerlIO_fast_gets(f) && PerlIO_has_base(f)) {
	STDCHAR *buf = ((STDCHAR *) vbuf) + count;
	STDCHAR *base = PerlIO_get_base(f);
	SSize_t cnt   = PerlIO_get_cnt(f);
	STDCHAR *ptr  = PerlIO_get_ptr(f);
	SSize_t avail = ptr - base;
	if (avail > 0) {
	    if (avail > count) {
		avail = count;
	    }
	    ptr -= avail;
	    Move(buf-avail,ptr,avail,STDCHAR);
	    count -= avail;
	    unread += avail;
	    PerlIO_set_ptrcnt(f,ptr,cnt+avail);
	    if (PerlSIO_feof(s) && unread >= 0)
		PerlSIO_clearerr(s);
	}
    }
    else
#endif
    if (PerlIO_has_cntptr(f)) {
	/* We can get pointer to buffer but not its base
	   Do ungetc() but check chars are ending up in the
	   buffer
	 */
	STDCHAR *eptr = (STDCHAR*)PerlSIO_get_ptr(s);
	STDCHAR *buf = ((STDCHAR *) vbuf) + count;
	while (count > 0) {
	    int ch = *--buf & 0xFF;
	    if (ungetc(ch,s) != ch) {
		/* ungetc did not work */
		break;
	    }
	    if ((STDCHAR*)PerlSIO_get_ptr(s) != --eptr || ((*eptr & 0xFF) != ch)) {
		/* Did not change pointer as expected */
		fgetc(s);  /* get char back again */
		break;
	    }
	    /* It worked ! */
	    count--;
	    unread++;
	}
    }

    if (count > 0) {
	unread += PerlIOBase_unread(aTHX_ f, vbuf, count);
    }
    return unread;
}

SSize_t
PerlIOStdio_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    return PerlSIO_fwrite(vbuf, 1, count,
			  PerlIOSelf(f, PerlIOStdio)->stdio);
}

IV
PerlIOStdio_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_fseek(stdio, offset, whence);
}

Off_t
PerlIOStdio_tell(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_ftell(stdio);
}

IV
PerlIOStdio_flush(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (PerlIOBase(f)->flags & PERLIO_F_CANWRITE) {
	return PerlSIO_fflush(stdio);
    }
    else {
#if 0
	/*
	 * FIXME: This discards ungetc() and pre-read stuff which is not
	 * right if this is just a "sync" from a layer above Suspect right
	 * design is to do _this_ but not have layer above flush this
	 * layer read-to-read
	 */
	/*
	 * Not writeable - sync by attempting a seek
	 */
	int err = errno;
	if (PerlSIO_fseek(stdio, (Off_t) 0, SEEK_CUR) != 0)
	    errno = err;
#endif
    }
    return 0;
}

IV
PerlIOStdio_eof(pTHX_ PerlIO *f)
{
    return PerlSIO_feof(PerlIOSelf(f, PerlIOStdio)->stdio);
}

IV
PerlIOStdio_error(pTHX_ PerlIO *f)
{
    return PerlSIO_ferror(PerlIOSelf(f, PerlIOStdio)->stdio);
}

void
PerlIOStdio_clearerr(pTHX_ PerlIO *f)
{
    PerlSIO_clearerr(PerlIOSelf(f, PerlIOStdio)->stdio);
}

void
PerlIOStdio_setlinebuf(pTHX_ PerlIO *f)
{
#ifdef HAS_SETLINEBUF
    PerlSIO_setlinebuf(PerlIOSelf(f, PerlIOStdio)->stdio);
#else
    PerlSIO_setvbuf(PerlIOSelf(f, PerlIOStdio)->stdio, Nullch, _IOLBF, 0);
#endif
}

#ifdef FILE_base
STDCHAR *
PerlIOStdio_get_base(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return (STDCHAR*)PerlSIO_get_base(stdio);
}

Size_t
PerlIOStdio_get_bufsiz(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_get_bufsiz(stdio);
}
#endif

#ifdef USE_STDIO_PTR
STDCHAR *
PerlIOStdio_get_ptr(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return (STDCHAR*)PerlSIO_get_ptr(stdio);
}

SSize_t
PerlIOStdio_get_cnt(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    return PerlSIO_get_cnt(stdio);
}

void
PerlIOStdio_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (ptr != NULL) {
#ifdef STDIO_PTR_LVALUE
	PerlSIO_set_ptr(stdio, (void*)ptr); /* LHS STDCHAR* cast non-portable */
#ifdef STDIO_PTR_LVAL_SETS_CNT
	if (PerlSIO_get_cnt(stdio) != (cnt)) {
	    assert(PerlSIO_get_cnt(stdio) == (cnt));
	}
#endif
#if (!defined(STDIO_PTR_LVAL_NOCHANGE_CNT))
	/*
	 * Setting ptr _does_ change cnt - we are done
	 */
	return;
#endif
#else                           /* STDIO_PTR_LVALUE */
	PerlProc_abort();
#endif                          /* STDIO_PTR_LVALUE */
    }
    /*
     * Now (or only) set cnt
     */
#ifdef STDIO_CNT_LVALUE
    PerlSIO_set_cnt(stdio, cnt);
#else                           /* STDIO_CNT_LVALUE */
#if (defined(STDIO_PTR_LVALUE) && defined(STDIO_PTR_LVAL_SETS_CNT))
    PerlSIO_set_ptr(stdio,
		    PerlSIO_get_ptr(stdio) + (PerlSIO_get_cnt(stdio) -
					      cnt));
#else                           /* STDIO_PTR_LVAL_SETS_CNT */
    PerlProc_abort();
#endif                          /* STDIO_PTR_LVAL_SETS_CNT */
#endif                          /* STDIO_CNT_LVALUE */
}


#endif

IV
PerlIOStdio_fill(pTHX_ PerlIO *f)
{
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    int c;
    /*
     * fflush()ing read-only streams can cause trouble on some stdio-s
     */
    if ((PerlIOBase(f)->flags & PERLIO_F_CANWRITE)) {
	if (PerlSIO_fflush(stdio) != 0)
	    return EOF;
    }
    c = PerlSIO_fgetc(stdio);
    if (c == EOF)
	return EOF;

#if (defined(STDIO_PTR_LVALUE) && (defined(STDIO_CNT_LVALUE) || defined(STDIO_PTR_LVAL_SETS_CNT)))

#ifdef STDIO_BUFFER_WRITABLE
    if (PerlIO_fast_gets(f) && PerlIO_has_base(f)) {
	/* Fake ungetc() to the real buffer in case system's ungetc
	   goes elsewhere
	 */
	STDCHAR *base = (STDCHAR*)PerlSIO_get_base(stdio);
	SSize_t cnt   = PerlSIO_get_cnt(stdio);
	STDCHAR *ptr  = (STDCHAR*)PerlSIO_get_ptr(stdio);
	if (ptr == base+1) {
	    *--ptr = (STDCHAR) c;
	    PerlIOStdio_set_ptrcnt(aTHX_ f,ptr,cnt+1);
	    if (PerlSIO_feof(stdio))
		PerlSIO_clearerr(stdio);
	    return 0;
	}
    }
    else
#endif
    if (PerlIO_has_cntptr(f)) {
	STDCHAR ch = c;
	if (PerlIOStdio_unread(aTHX_ f,&ch,1) == 1) {
	    return 0;
	}
    }
#endif

#if defined(VMS)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we stuff it in the buffer ourselves.
     * Should never get called as should hit code above
     */
    *(--((*stdio)->_ptr)) = (unsigned char) c;
    (*stdio)->_cnt++;
#else
    /* If buffer snoop scheme above fails fall back to
       using ungetc().
     */
    if (PerlSIO_ungetc(c, stdio) != c)
	return EOF;
#endif
    return 0;
}



PerlIO_funcs PerlIO_stdio = {
    sizeof(PerlIO_funcs),
    "stdio",
    sizeof(PerlIOStdio),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOStdio_pushed,
    PerlIOBase_popped,
    PerlIOStdio_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOStdio_fileno,
    PerlIOStdio_dup,
    PerlIOStdio_read,
    PerlIOStdio_unread,
    PerlIOStdio_write,
    PerlIOStdio_seek,
    PerlIOStdio_tell,
    PerlIOStdio_close,
    PerlIOStdio_flush,
    PerlIOStdio_fill,
    PerlIOStdio_eof,
    PerlIOStdio_error,
    PerlIOStdio_clearerr,
    PerlIOStdio_setlinebuf,
#ifdef FILE_base
    PerlIOStdio_get_base,
    PerlIOStdio_get_bufsiz,
#else
    NULL,
    NULL,
#endif
#ifdef USE_STDIO_PTR
    PerlIOStdio_get_ptr,
    PerlIOStdio_get_cnt,
#if (defined(STDIO_PTR_LVALUE) && (defined(STDIO_CNT_LVALUE) || defined(STDIO_PTR_LVAL_SETS_CNT)))
    PerlIOStdio_set_ptrcnt
#else                           /* STDIO_PTR_LVALUE */
    NULL
#endif                          /* STDIO_PTR_LVALUE */
#else                           /* USE_STDIO_PTR */
    NULL,
    NULL,
    NULL
#endif                          /* USE_STDIO_PTR */
};

/* Note that calls to PerlIO_exportFILE() are reversed using
 * PerlIO_releaseFILE(), not importFILE. */
FILE *
PerlIO_exportFILE(PerlIO * f, const char *mode)
{
    dTHX;
    FILE *stdio = NULL;
    if (PerlIOValid(f)) {
	char buf[8];
	PerlIO_flush(f);
	if (!mode || !*mode) {
	    mode = PerlIO_modestr(f, buf);
	}
	stdio = PerlSIO_fdopen(PerlIO_fileno(f), mode);
	if (stdio) {
	    PerlIOl *l = *f;
	    /* De-link any lower layers so new :stdio sticks */
	    *f = NULL;
	    if ((f = PerlIO_push(aTHX_ f, &PerlIO_stdio, buf, Nullsv))) {
		PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
		s->stdio = stdio;
		/* Link previous lower layers under new one */
		*PerlIONext(f) = l;
	    }
	    else {
		/* restore layers list */
		*f = l;
	    }
	}
    }
    return stdio;
}


FILE *
PerlIO_findFILE(PerlIO *f)
{
    PerlIOl *l = *f;
    while (l) {
	if (l->tab == &PerlIO_stdio) {
	    PerlIOStdio *s = PerlIOSelf(&l, PerlIOStdio);
	    return s->stdio;
	}
	l = *PerlIONext(&l);
    }
    /* Uses fallback "mode" via PerlIO_modestr() in PerlIO_exportFILE */
    return PerlIO_exportFILE(f, Nullch);
}

/* Use this to reverse PerlIO_exportFILE calls. */
void
PerlIO_releaseFILE(PerlIO *p, FILE *f)
{
    PerlIOl *l;
    while ((l = *p)) {
	if (l->tab == &PerlIO_stdio) {
	    PerlIOStdio *s = PerlIOSelf(&l, PerlIOStdio);
	    if (s->stdio == f) {
		dTHX;
		PerlIO_pop(aTHX_ p);
		return;
	    }
	}
	p = PerlIONext(p);
    }
    return;
}

/*--------------------------------------------------------------------------------------*/
/*
 * perlio buffer layer
 */

IV
PerlIOBuf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    int fd = PerlIO_fileno(f);
    if (fd >= 0 && PerlLIO_isatty(fd)) {
	PerlIOBase(f)->flags |= PERLIO_F_LINEBUF | PERLIO_F_TTY;
    }
    if (*PerlIONext(f)) {
	Off_t posn = PerlIO_tell(PerlIONext(f));
	if (posn != (Off_t) - 1) {
	    b->posn = posn;
	}
    }
    return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
}

PerlIO *
PerlIOBuf_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *f, int narg, SV **args)
{
    if (PerlIOValid(f)) {
	PerlIO *next = PerlIONext(f);
	PerlIO_funcs *tab =  PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIOBase(next)->tab);
	next = (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			  next, narg, args);
	if (!next || (*PerlIOBase(f)->tab->Pushed) (aTHX_ f, mode, PerlIOArg, self) != 0) {
	    return NULL;
	}
    }
    else {
	PerlIO_funcs *tab = PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIO_default_btm());
	int init = 0;
	if (*mode == 'I') {
	    init = 1;
	    /*
	     * mode++;
	     */
	}
	f = (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			  f, narg, args);
	if (f) {
	    if (PerlIO_push(aTHX_ f, self, mode, PerlIOArg) == 0) {
		/*
		 * if push fails during open, open fails. close will pop us.
		 */
		PerlIO_close (f);
		return NULL;
	    } else {
		fd = PerlIO_fileno(f);
		if (init && fd == 2) {
		    /*
		     * Initial stderr is unbuffered
		     */
		    PerlIOBase(f)->flags |= PERLIO_F_UNBUF;
		}
#ifdef PERLIO_USING_CRLF
#  ifdef PERLIO_IS_BINMODE_FD
		if (PERLIO_IS_BINMODE_FD(fd))
		    PerlIO_binmode(f,  '<'/*not used*/, O_BINARY, Nullch);
		else
#  endif
		/*
		 * do something about failing setmode()? --jhi
		 */
		PerlLIO_setmode(fd, O_BINARY);
#endif
	    }
	}
    }
    return f;
}

/*
 * This "flush" is akin to sfio's sync in that it handles files in either
 * read or write state
a8 254
IV
PerlIOBuf_flush(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    int code = 0;
    PerlIO *n = PerlIONext(f);
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF) {
	/*
	 * write() the buffer
	 */
	STDCHAR *buf = b->buf;
	STDCHAR *p = buf;
	while (p < b->ptr) {
	    SSize_t count = PerlIO_write(n, p, b->ptr - p);
	    if (count > 0) {
		p += count;
	    }
	    else if (count < 0 || PerlIO_error(n)) {
		PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		code = -1;
		break;
	    }
	}
	b->posn += (p - buf);
    }
    else if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	STDCHAR *buf = PerlIO_get_base(f);
	/*
	 * Note position change
	 */
	b->posn += (b->ptr - buf);
	if (b->ptr < b->end) {
	    /* We did not consume all of it - try and seek downstream to
	       our logical position
	     */
	    if (PerlIOValid(n) && PerlIO_seek(n, b->posn, SEEK_SET) == 0) {
		/* Reload n as some layers may pop themselves on seek */
		b->posn = PerlIO_tell(n = PerlIONext(f));
	    }
	    else {
		/* Seek failed (e.g. pipe or tty). Do NOT clear buffer or pre-read
		   data is lost for good - so return saying "ok" having undone
		   the position adjust
		 */
		b->posn -= (b->ptr - buf);
		return code;
	    }
	}
    }
    b->ptr = b->end = b->buf;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    /* We check for Valid because of dubious decision to make PerlIO_flush(NULL) flush all */
    if (PerlIOValid(n) && PerlIO_flush(n) != 0)
	code = -1;
    return code;
}

IV
PerlIOBuf_fill(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    PerlIO *n = PerlIONext(f);
    SSize_t avail;
    /*
     * Down-stream flush is defined not to loose read data so is harmless.
     * we would not normally be fill'ing if there was data left in anycase.
     */
    if (PerlIO_flush(f) != 0)
	return -1;
    if (PerlIOBase(f)->flags & PERLIO_F_TTY)
	PerlIOBase_flush_linebuf(aTHX);

    if (!b->buf)
	PerlIO_get_base(f);     /* allocate via vtable */

    b->ptr = b->end = b->buf;

    if (!PerlIOValid(n)) {
	PerlIOBase(f)->flags |= PERLIO_F_EOF;
	return -1;
    }

    if (PerlIO_fast_gets(n)) {
	/*
	 * Layer below is also buffered. We do _NOT_ want to call its
	 * ->Read() because that will loop till it gets what we asked for
	 * which may hang on a pipe etc. Instead take anything it has to
	 * hand, or ask it to fill _once_.
	 */
	avail = PerlIO_get_cnt(n);
	if (avail <= 0) {
	    avail = PerlIO_fill(n);
	    if (avail == 0)
		avail = PerlIO_get_cnt(n);
	    else {
		if (!PerlIO_error(n) && PerlIO_eof(n))
		    avail = 0;
	    }
	}
	if (avail > 0) {
	    STDCHAR *ptr = PerlIO_get_ptr(n);
	    SSize_t cnt = avail;
	    if (avail > (SSize_t)b->bufsiz)
		avail = b->bufsiz;
	    Copy(ptr, b->buf, avail, STDCHAR);
	    PerlIO_set_ptrcnt(n, ptr + avail, cnt - avail);
	}
    }
    else {
	avail = PerlIO_read(n, b->ptr, b->bufsiz);
    }
    if (avail <= 0) {
	if (avail == 0)
	    PerlIOBase(f)->flags |= PERLIO_F_EOF;
	else
	    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	return -1;
    }
    b->end = b->buf + avail;
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
    return 0;
}

SSize_t
PerlIOBuf_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (PerlIOValid(f)) {
	if (!b->ptr)
	    PerlIO_get_base(f);
	return PerlIOBase_read(aTHX_ f, vbuf, count);
    }
    return 0;
}

SSize_t
PerlIOBuf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    const STDCHAR *buf = (const STDCHAR *) vbuf + count;
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    SSize_t unread = 0;
    SSize_t avail;
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	PerlIO_flush(f);
    if (!b->buf)
	PerlIO_get_base(f);
    if (b->buf) {
	if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	    /*
	     * Buffer is already a read buffer, we can overwrite any chars
	     * which have been read back to buffer start
	     */
	    avail = (b->ptr - b->buf);
	}
	else {
	    /*
	     * Buffer is idle, set it up so whole buffer is available for
	     * unread
	     */
	    avail = b->bufsiz;
	    b->end = b->buf + avail;
	    b->ptr = b->end;
	    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
	    /*
	     * Buffer extends _back_ from where we are now
	     */
	    b->posn -= b->bufsiz;
	}
	if (avail > (SSize_t) count) {
	    /*
	     * If we have space for more than count, just move count
	     */
	    avail = count;
	}
	if (avail > 0) {
	    b->ptr -= avail;
	    buf -= avail;
	    /*
	     * In simple stdio-like ungetc() case chars will be already
	     * there
	     */
	    if (buf != b->ptr) {
		Copy(buf, b->ptr, avail, STDCHAR);
	    }
	    count -= avail;
	    unread += avail;
	    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	}
    }
    if (count > 0) {
	unread += PerlIOBase_unread(aTHX_ f, vbuf, count);
    }
    return unread;
}

SSize_t
PerlIOBuf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    const STDCHAR *buf = (const STDCHAR *) vbuf;
    Size_t written = 0;
    if (!b->buf)
	PerlIO_get_base(f);
    if (!(PerlIOBase(f)->flags & PERLIO_F_CANWRITE))
	return 0;
    while (count > 0) {
	SSize_t avail = b->bufsiz - (b->ptr - b->buf);
	if ((SSize_t) count < avail)
	    avail = count;
	PerlIOBase(f)->flags |= PERLIO_F_WRBUF;
	if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
	    while (avail > 0) {
		int ch = *buf++;
		*(b->ptr)++ = ch;
		count--;
		avail--;
		written++;
		if (ch == '\n') {
		    PerlIO_flush(f);
		    break;
		}
	    }
	}
	else {
	    if (avail) {
		Copy(buf, b->ptr, avail, STDCHAR);
		count -= avail;
		buf += avail;
		written += avail;
		b->ptr += avail;
	    }
	}
	if (b->ptr >= (b->buf + b->bufsiz))
	    PerlIO_flush(f);
    }
    if (PerlIOBase(f)->flags & PERLIO_F_UNBUF)
	PerlIO_flush(f);
    return written;
}

IV
PerlIOBuf_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    IV code;
    if ((code = PerlIO_flush(f)) == 0) {
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	code = PerlIO_seek(PerlIONext(f), offset, whence);
	if (code == 0) {
	    b->posn = PerlIO_tell(PerlIONext(f));
	}
    }
    return code;
}
a9 16
Off_t
PerlIOBuf_tell(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    /*
     * b->posn is file position where b->buf was read, or will be written
     */
    Off_t posn = b->posn;
    if (b->buf) {
	/*
	 * If buffer is valid adjust position by amount in buffer
	 */
	posn += (b->ptr - b->buf);
    }
    return posn;
}
d11 2
a12 13
IV
PerlIOBuf_popped(pTHX_ PerlIO *f)
{
    IV code = PerlIOBase_popped(aTHX_ f);
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
    }
    b->buf = NULL;
    b->ptr = b->end = b->buf;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    return code;
}
d14 9
a22 13
IV
PerlIOBuf_close(pTHX_ PerlIO *f)
{
    IV code = PerlIOBase_close(aTHX_ f);
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
    }
    b->buf = NULL;
    b->ptr = b->end = b->buf;
    PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    return code;
}
d24 3
a26 19
STDCHAR *
PerlIOBuf_get_ptr(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    return b->ptr;
}

SSize_t
PerlIOBuf_get_cnt(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF)
	return (b->end - b->ptr);
    return 0;
}
d28 1
a28 18
STDCHAR *
PerlIOBuf_get_base(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf) {
	if (!b->bufsiz)
	    b->bufsiz = 4096;
	b->buf =
	Newz('B',b->buf,b->bufsiz, STDCHAR);
	if (!b->buf) {
	    b->buf = (STDCHAR *) & b->oneword;
	    b->bufsiz = sizeof(b->oneword);
	}
	b->ptr = b->buf;
	b->end = b->ptr;
    }
    return b->buf;
}
d30 1
a30 8
Size_t
PerlIOBuf_bufsiz(pTHX_ PerlIO *f)
{
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    return (b->end - b->buf);
}
d33 1
a33 1
PerlIOBuf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
d35 5
a39 9
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    b->ptr = ptr;
    if (PerlIO_get_cnt(f) != cnt || b->ptr < b->buf) {
	assert(PerlIO_get_cnt(f) == cnt);
	assert(b->ptr >= b->buf);
    }
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
d42 1
d44 1
a44 1
PerlIOBuf_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
d46 1
a46 1
 return PerlIOBase_dup(aTHX_ f, o, param, flags);
d49 1
d51 1
d53 2
a54 30
PerlIO_funcs PerlIO_perlio = {
    sizeof(PerlIO_funcs),
    "perlio",
    sizeof(PerlIOBuf),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOBuf_pushed,
    PerlIOBuf_popped,
    PerlIOBuf_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOBuf_read,
    PerlIOBuf_unread,
    PerlIOBuf_write,
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOBuf_flush,
    PerlIOBuf_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOBuf_set_ptrcnt,
};
d56 3
a58 4
/*--------------------------------------------------------------------------------------*/
/*
 * Temp layer to hold unread chars when cannot do it any other way
 */
d60 3
a62 2
IV
PerlIOPending_fill(pTHX_ PerlIO *f)
d64 1
a64 5
    /*
     * Should never happen
     */
    PerlIO_flush(f);
    return 0;
d67 2
a68 2
IV
PerlIOPending_close(pTHX_ PerlIO *f)
d70 11
a80 5
    /*
     * A tad tricky - flush pops us, then we close new top
     */
    PerlIO_flush(f);
    return PerlIO_close(f);
d83 1
a83 9
IV
PerlIOPending_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    /*
     * A tad tricky - flush pops us, then we seek new top
     */
    PerlIO_flush(f);
    return PerlIO_seek(f, offset, whence);
}
d85 3
d89 3
a91 2
IV
PerlIOPending_flush(pTHX_ PerlIO *f)
d93 1
a93 7
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (b->buf && b->buf != (STDCHAR *) & b->oneword) {
	Safefree(b->buf);
	b->buf = NULL;
    }
    PerlIO_pop(aTHX_ f);
    return 0;
d96 3
a98 2
void
PerlIOPending_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
d100 1
a100 6
    if (cnt <= 0) {
	PerlIO_flush(f);
    }
    else {
	PerlIOBuf_set_ptrcnt(aTHX_ f, ptr, cnt);
    }
d103 3
a105 2
IV
PerlIOPending_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
d107 1
a107 10
    IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
    PerlIOl *l = PerlIOBase(f);
    /*
     * Our PerlIO_fast_gets must match what we are pushed on, or sv_gets()
     * etc. get muddled when it changes mid-string when we auto-pop.
     */
    l->flags = (l->flags & ~(PERLIO_F_FASTGETS | PERLIO_F_UTF8)) |
	(PerlIOBase(PerlIONext(f))->
	 flags & (PERLIO_F_FASTGETS | PERLIO_F_UTF8));
    return code;
d110 3
a112 2
SSize_t
PerlIOPending_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
d114 5
a118 13
    SSize_t avail = PerlIO_get_cnt(f);
    SSize_t got = 0;
    if ((SSize_t)count < avail)
	avail = count;
    if (avail > 0)
	got = PerlIOBuf_read(aTHX_ f, vbuf, avail);
    if (got >= 0 && got < (SSize_t)count) {
	SSize_t more =
	    PerlIO_read(f, ((STDCHAR *) vbuf) + got, count - got);
	if (more >= 0 || got == 0)
	    got += more;
    }
    return got;
d121 8
a128 56
PerlIO_funcs PerlIO_pending = {
    sizeof(PerlIO_funcs),
    "pending",
    sizeof(PerlIOBuf),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,  /* not sure about RAW here */
    PerlIOPending_pushed,
    PerlIOBuf_popped,
    NULL,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOPending_read,
    PerlIOBuf_unread,
    PerlIOBuf_write,
    PerlIOPending_seek,
    PerlIOBuf_tell,
    PerlIOPending_close,
    PerlIOPending_flush,
    PerlIOPending_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOPending_set_ptrcnt,
};



/*--------------------------------------------------------------------------------------*/
/*
 * crlf - translation On read translate CR,LF to "\n" we do this by
 * overriding ptr/cnt entries to hand back a line at a time and keeping a
 * record of which nl we "lied" about. On write translate "\n" to CR,LF
 */

typedef struct {
    PerlIOBuf base;             /* PerlIOBuf stuff */
    STDCHAR *nl;                /* Position of crlf we "lied" about in the
				 * buffer */
} PerlIOCrlf;

IV
PerlIOCrlf_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
    IV code;
    PerlIOBase(f)->flags |= PERLIO_F_CRLF;
    code = PerlIOBuf_pushed(aTHX_ f, mode, arg, tab);
#if 0
    PerlIO_debug("PerlIOCrlf_pushed f=%p %s %s fl=%08" UVxf "\n",
		 f, PerlIOBase(f)->tab->name, (mode) ? mode : "(Null)",
		 PerlIOBase(f)->flags);
a129 1
    return code;
d132 3
a134 3

SSize_t
PerlIOCrlf_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
d136 5
a140 44
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
    if (c->nl) {
	*(c->nl) = 0xd;
	c->nl = NULL;
    }
    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF))
	return PerlIOBuf_unread(aTHX_ f, vbuf, count);
    else {
	const STDCHAR *buf = (const STDCHAR *) vbuf + count;
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	SSize_t unread = 0;
	if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	    PerlIO_flush(f);
	if (!b->buf)
	    PerlIO_get_base(f);
	if (b->buf) {
	    if (!(PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
		b->end = b->ptr = b->buf + b->bufsiz;
		PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
		b->posn -= b->bufsiz;
	    }
	    while (count > 0 && b->ptr > b->buf) {
		int ch = *--buf;
		if (ch == '\n') {
		    if (b->ptr - 2 >= b->buf) {
			*--(b->ptr) = 0xa;
			*--(b->ptr) = 0xd;
			unread++;
			count--;
		    }
		    else {
			buf++;
			break;
		    }
		}
		else {
		    *--(b->ptr) = ch;
		    unread++;
		    count--;
		}
	    }
	}
	return unread;
    }
d143 3
a145 2
SSize_t
PerlIOCrlf_get_cnt(pTHX_ PerlIO *f)
d147 8
a154 64
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
	PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
	if ((PerlIOBase(f)->flags & PERLIO_F_CRLF) && (!c->nl || *c->nl == 0xd)) {
	    STDCHAR *nl = (c->nl) ? c->nl : b->ptr;
	  scan:
	    while (nl < b->end && *nl != 0xd)
		nl++;
	    if (nl < b->end && *nl == 0xd) {
	      test:
		if (nl + 1 < b->end) {
		    if (nl[1] == 0xa) {
			*nl = '\n';
			c->nl = nl;
		    }
		    else {
			/*
			 * Not CR,LF but just CR
			 */
			nl++;
			goto scan;
		    }
		}
		else {
		    /*
		     * Blast - found CR as last char in buffer
		     */

		    if (b->ptr < nl) {
			/*
			 * They may not care, defer work as long as
			 * possible
			 */
			c->nl = nl;
			return (nl - b->ptr);
		    }
		    else {
			int code;
			b->ptr++;       /* say we have read it as far as
					 * flush() is concerned */
			b->buf++;       /* Leave space in front of buffer */
			b->bufsiz--;    /* Buffer is thus smaller */
			code = PerlIO_fill(f);  /* Fetch some more */
			b->bufsiz++;    /* Restore size for next time */
			b->buf--;       /* Point at space */
			b->ptr = nl = b->buf;   /* Which is what we hand
						 * off */
			b->posn--;      /* Buffer starts here */
			*nl = 0xd;      /* Fill in the CR */
			if (code == 0)
			    goto test;  /* fill() call worked */
			/*
			 * CR at EOF - just fall through
			 */
			/* Should we clear EOF though ??? */
		    }
		}
	    }
	}
	return (((c->nl) ? (c->nl + 1) : b->end) - b->ptr);
    }
    return 0;
d157 1
d159 1
a159 1
PerlIOCrlf_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
d161 22
a182 35
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
    if (!b->buf)
	PerlIO_get_base(f);
    if (!ptr) {
	if (c->nl) {
	    ptr = c->nl + 1;
	    if (ptr == b->end && *c->nl == 0xd) {
		/* Defered CR at end of buffer case - we lied about count */
		ptr--;
	    }
	}
	else {
	    ptr = b->end;
	}
	ptr -= cnt;
    }
    else {
#if 0
	/*
	 * Test code - delete when it works ...
	 */
	IV flags = PerlIOBase(f)->flags;
	STDCHAR *chk = (c->nl) ? (c->nl+1) : b->end;
	if (ptr+cnt == c->nl && c->nl+1 == b->end && *c->nl == 0xd) {
	  /* Defered CR at end of buffer case - we lied about count */
	  chk--;
	}
	chk -= cnt;

	if (ptr != chk ) {
	    Perl_croak(aTHX_ "ptr wrong %p != %p fl=%08" UVxf
		       " nl=%p e=%p for %d", ptr, chk, flags, c->nl,
		       b->end, cnt);
	}
a183 13
    }
    if (c->nl) {
	if (ptr > c->nl) {
	    /*
	     * They have taken what we lied about
	     */
	    *(c->nl) = 0xd;
	    c->nl = NULL;
	    ptr++;
	}
    }
    b->ptr = ptr;
    PerlIOBase(f)->flags |= PERLIO_F_RDBUF;
d186 3
a188 2
SSize_t
PerlIOCrlf_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
d190 7
a196 46
    if (!(PerlIOBase(f)->flags & PERLIO_F_CRLF))
	return PerlIOBuf_write(aTHX_ f, vbuf, count);
    else {
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	const STDCHAR *buf = (const STDCHAR *) vbuf;
	const STDCHAR *ebuf = buf + count;
	if (!b->buf)
	    PerlIO_get_base(f);
	if (!(PerlIOBase(f)->flags & PERLIO_F_CANWRITE))
	    return 0;
	while (buf < ebuf) {
	    STDCHAR *eptr = b->buf + b->bufsiz;
	    PerlIOBase(f)->flags |= PERLIO_F_WRBUF;
	    while (buf < ebuf && b->ptr < eptr) {
		if (*buf == '\n') {
		    if ((b->ptr + 2) > eptr) {
			/*
			 * Not room for both
			 */
			PerlIO_flush(f);
			break;
		    }
		    else {
			*(b->ptr)++ = 0xd;      /* CR */
			*(b->ptr)++ = 0xa;      /* LF */
			buf++;
			if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
			    PerlIO_flush(f);
			    break;
			}
		    }
		}
		else {
		    int ch = *buf++;
		    *(b->ptr)++ = ch;
		}
		if (b->ptr >= eptr) {
		    PerlIO_flush(f);
		    break;
		}
	    }
	}
	if (PerlIOBase(f)->flags & PERLIO_F_UNBUF)
	    PerlIO_flush(f);
	return (buf - (STDCHAR *) vbuf);
    }
d199 3
a201 2
IV
PerlIOCrlf_flush(pTHX_ PerlIO *f)
d203 7
a209 6
    PerlIOCrlf *c = PerlIOSelf(f, PerlIOCrlf);
    if (c->nl) {
	*(c->nl) = 0xd;
	c->nl = NULL;
    }
    return PerlIOBuf_flush(aTHX_ f);
d212 3
a214 2
IV
PerlIOCrlf_binmode(pTHX_ PerlIO *f)
d216 6
a221 8
    if ((PerlIOBase(f)->flags & PERLIO_F_CRLF)) {
	/* In text mode - flush any pending stuff and flip it */
	PerlIOBase(f)->flags &= ~PERLIO_F_CRLF;
#ifndef PERLIO_USING_CRLF
	/* CRLF is unusual case - if this is just the :crlf layer pop it */
	if (PerlIOBase(f)->tab == &PerlIO_crlf) {
		PerlIO_pop(aTHX_ f);
	}
a222 2
    }
    return 0;
d225 12
a236 31
PerlIO_funcs PerlIO_crlf = {
    sizeof(PerlIO_funcs),
    "crlf",
    sizeof(PerlIOCrlf),
    PERLIO_K_BUFFERED | PERLIO_K_CANCRLF | PERLIO_K_RAW,
    PerlIOCrlf_pushed,
    PerlIOBuf_popped,         /* popped */
    PerlIOBuf_open,
    PerlIOCrlf_binmode,       /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOBuf_dup,
    PerlIOBuf_read,             /* generic read works with ptr/cnt lies
				 * ... */
    PerlIOCrlf_unread,          /* Put CR,LF in buffer for each '\n' */
    PerlIOCrlf_write,           /* Put CR,LF in buffer for each '\n' */
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOCrlf_flush,
    PerlIOBuf_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOBuf_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOCrlf_get_cnt,
    PerlIOCrlf_set_ptrcnt,
};
d238 6
a243 56
#ifdef HAS_MMAP
/*--------------------------------------------------------------------------------------*/
/*
 * mmap as "buffer" layer
 */

typedef struct {
    PerlIOBuf base;             /* PerlIOBuf stuff */
    Mmap_t mptr;                /* Mapped address */
    Size_t len;                 /* mapped length */
    STDCHAR *bbuf;              /* malloced buffer if map fails */
} PerlIOMmap;

static size_t page_size = 0;

IV
PerlIOMmap_map(pTHX_ PerlIO *f)
{
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    IV flags = PerlIOBase(f)->flags;
    IV code = 0;
    if (m->len)
	abort();
    if (flags & PERLIO_F_CANREAD) {
	PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
	int fd = PerlIO_fileno(f);
	Stat_t st;
	code = Fstat(fd, &st);
	if (code == 0 && S_ISREG(st.st_mode)) {
	    SSize_t len = st.st_size - b->posn;
	    if (len > 0) {
		Off_t posn;
		if (!page_size) {
#if defined(HAS_SYSCONF) && (defined(_SC_PAGESIZE) || defined(_SC_PAGE_SIZE))
		    {
			SETERRNO(0, SS$_NORMAL);
#   ifdef _SC_PAGESIZE
			page_size = sysconf(_SC_PAGESIZE);
#   else
			page_size = sysconf(_SC_PAGE_SIZE);
#   endif
			if ((long) page_size < 0) {
			    if (errno) {
				SV *error = ERRSV;
				char *msg;
				STRLEN n_a;
				(void) SvUPGRADE(error, SVt_PV);
				msg = SvPVx(error, n_a);
				Perl_croak(aTHX_ "panic: sysconf: %s",
					   msg);
			    }
			    else
				Perl_croak(aTHX_
					   "panic: sysconf: pagesize unknown");
			}
		    }
d245 1
a245 25
#   ifdef HAS_GETPAGESIZE
		    page_size = getpagesize();
#   else
#       if defined(I_SYS_PARAM) && defined(PAGESIZE)
		    page_size = PAGESIZE;       /* compiletime, bad */
#       endif
#   endif
#endif
		    if ((IV) page_size <= 0)
			Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
				   (IV) page_size);
		}
		if (b->posn < 0) {
		    /*
		     * This is a hack - should never happen - open should
		     * have set it !
		     */
		    b->posn = PerlIO_tell(PerlIONext(f));
		}
		posn = (b->posn / page_size) * page_size;
		len = st.st_size - posn;
		m->mptr = mmap(NULL, len, PROT_READ, MAP_SHARED, fd, posn);
		if (m->mptr && m->mptr != (Mmap_t) - 1) {
#if 0 && defined(HAS_MADVISE) && defined(MADV_SEQUENTIAL)
		    madvise(m->mptr, len, MADV_SEQUENTIAL);
a246 24
#if 0 && defined(HAS_MADVISE) && defined(MADV_WILLNEED)
		    madvise(m->mptr, len, MADV_WILLNEED);
#endif
		    PerlIOBase(f)->flags =
			(flags & ~PERLIO_F_EOF) | PERLIO_F_RDBUF;
		    b->end = ((STDCHAR *) m->mptr) + len;
		    b->buf = ((STDCHAR *) m->mptr) + (b->posn - posn);
		    b->ptr = b->buf;
		    m->len = len;
		}
		else {
		    b->buf = NULL;
		}
	    }
	    else {
		PerlIOBase(f)->flags =
		    flags | PERLIO_F_EOF | PERLIO_F_RDBUF;
		b->buf = NULL;
		b->ptr = b->end = b->ptr;
		code = -1;
	    }
	}
    }
    return code;
d249 3
a251 2
IV
PerlIOMmap_unmap(pTHX_ PerlIO *f)
d253 1
a253 16
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    IV code = 0;
    if (m->len) {
	if (b->buf) {
	    code = munmap(m->mptr, m->len);
	    b->buf = NULL;
	    m->len = 0;
	    m->mptr = NULL;
	    if (PerlIO_seek(PerlIONext(f), b->posn, SEEK_SET) != 0)
		code = -1;
	}
	b->ptr = b->end = b->buf;
	PerlIOBase(f)->flags &= ~(PERLIO_F_RDBUF | PERLIO_F_WRBUF);
    }
    return code;
d256 3
a258 2
STDCHAR *
PerlIOMmap_get_base(pTHX_ PerlIO *f)
d260 1
a260 28
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    if (b->buf && (PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
	/*
	 * Already have a readbuffer in progress
	 */
	return b->buf;
    }
    if (b->buf) {
	/*
	 * We have a write buffer or flushed PerlIOBuf read buffer
	 */
	m->bbuf = b->buf;       /* save it in case we need it again */
	b->buf = NULL;          /* Clear to trigger below */
    }
    if (!b->buf) {
	PerlIOMmap_map(aTHX_ f);        /* Try and map it */
	if (!b->buf) {
	    /*
	     * Map did not work - recover PerlIOBuf buffer if we have one
	     */
	    b->buf = m->bbuf;
	}
    }
    b->ptr = b->end = b->buf;
    if (b->buf)
	return b->buf;
    return PerlIOBuf_get_base(aTHX_ f);
d263 3
a265 2
SSize_t
PerlIOMmap_unread(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
d267 1
a267 26
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    if (PerlIOBase(f)->flags & PERLIO_F_WRBUF)
	PerlIO_flush(f);
    if (b->ptr && (b->ptr - count) >= b->buf
	&& memEQ(b->ptr - count, vbuf, count)) {
	b->ptr -= count;
	PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
	return count;
    }
    if (m->len) {
	/*
	 * Loose the unwritable mapped buffer
	 */
	PerlIO_flush(f);
	/*
	 * If flush took the "buffer" see if we have one from before
	 */
	if (!b->buf && m->bbuf)
	    b->buf = m->bbuf;
	if (!b->buf) {
	    PerlIOBuf_get_base(aTHX_ f);
	    m->bbuf = b->buf;
	}
    }
    return PerlIOBuf_unread(aTHX_ f, vbuf, count);
d270 3
a272 2
SSize_t
PerlIOMmap_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
d274 1
a274 21
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    if (!b->buf || !(PerlIOBase(f)->flags & PERLIO_F_WRBUF)) {
	/*
	 * No, or wrong sort of, buffer
	 */
	if (m->len) {
	    if (PerlIOMmap_unmap(aTHX_ f) != 0)
		return 0;
	}
	/*
	 * If unmap took the "buffer" see if we have one from before
	 */
	if (!b->buf && m->bbuf)
	    b->buf = m->bbuf;
	if (!b->buf) {
	    PerlIOBuf_get_base(aTHX_ f);
	    m->bbuf = b->buf;
	}
    }
    return PerlIOBuf_write(aTHX_ f, vbuf, count);
d277 3
a279 2
IV
PerlIOMmap_flush(pTHX_ PerlIO *f)
d281 1
a281 23
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    IV code = PerlIOBuf_flush(aTHX_ f);
    /*
     * Now we are "synced" at PerlIOBuf level
     */
    if (b->buf) {
	if (m->len) {
	    /*
	     * Unmap the buffer
	     */
	    if (PerlIOMmap_unmap(aTHX_ f) != 0)
		code = -1;
	}
	else {
	    /*
	     * We seem to have a PerlIOBuf buffer which was not mapped
	     * remember it in case we need one later
	     */
	    m->bbuf = b->buf;
	}
    }
    return code;
d284 3
a286 2
IV
PerlIOMmap_fill(pTHX_ PerlIO *f)
d288 1
a288 9
    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
    IV code = PerlIO_flush(f);
    if (code == 0 && !b->buf) {
	code = PerlIOMmap_map(aTHX_ f);
    }
    if (code == 0 && !(PerlIOBase(f)->flags & PERLIO_F_RDBUF)) {
	code = PerlIOBuf_fill(aTHX_ f);
    }
    return code;
d291 3
a293 2
IV
PerlIOMmap_close(pTHX_ PerlIO *f)
d295 7
a301 11
    PerlIOMmap *m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf *b = &m->base;
    IV code = PerlIO_flush(f);
    if (m->bbuf) {
	b->buf = m->bbuf;
	m->bbuf = NULL;
	b->ptr = b->end = b->buf;
    }
    if (PerlIOBuf_close(aTHX_ f) != 0)
	code = -1;
    return code;
d304 3
a306 2
PerlIO *
PerlIOMmap_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *param, int flags)
d308 1
a308 1
 return PerlIOBase_dup(aTHX_ f, o, param, flags);
d311 6
d318 3
a320 35
PerlIO_funcs PerlIO_mmap = {
    sizeof(PerlIO_funcs),
    "mmap",
    sizeof(PerlIOMmap),
    PERLIO_K_BUFFERED|PERLIO_K_RAW,
    PerlIOBuf_pushed,
    PerlIOBuf_popped,
    PerlIOBuf_open,
    PerlIOBase_binmode,         /* binmode */
    NULL,
    PerlIOBase_fileno,
    PerlIOMmap_dup,
    PerlIOBuf_read,
    PerlIOMmap_unread,
    PerlIOMmap_write,
    PerlIOBuf_seek,
    PerlIOBuf_tell,
    PerlIOBuf_close,
    PerlIOMmap_flush,
    PerlIOMmap_fill,
    PerlIOBase_eof,
    PerlIOBase_error,
    PerlIOBase_clearerr,
    PerlIOBase_setlinebuf,
    PerlIOMmap_get_base,
    PerlIOBuf_bufsiz,
    PerlIOBuf_get_ptr,
    PerlIOBuf_get_cnt,
    PerlIOBuf_set_ptrcnt,
};

#endif                          /* HAS_MMAP */

PerlIO *
Perl_PerlIO_stdin(pTHX)
d322 1
a322 4
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return &PL_perlio[1];
d325 3
a327 2
PerlIO *
Perl_PerlIO_stdout(pTHX)
d329 1
a329 4
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return &PL_perlio[2];
d332 3
a334 2
PerlIO *
Perl_PerlIO_stderr(pTHX)
d336 1
a336 4
    if (!PL_perlio) {
	PerlIO_stdstreams(aTHX);
    }
    return &PL_perlio[3];
d339 3
a341 4
/*--------------------------------------------------------------------------------------*/

char *
PerlIO_getname(PerlIO *f, char *buf)
d343 2
a344 6
    dTHX;
    char *name = NULL;
#ifdef VMS
    FILE *stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    if (stdio)
	name = fgetname(stdio, buf);
d346 5
a350 1
    Perl_croak(aTHX_ "Don't know how to get file name");
a351 1
    return name;
d354 3
a356 10

/*--------------------------------------------------------------------------------------*/
/*
 * Functions which can be called on any kind of PerlIO implemented in
 * terms of above
 */

#undef PerlIO_fdopen
PerlIO *
PerlIO_fdopen(int fd, const char *mode)
d358 1
a358 2
    dTHX;
    return PerlIO_openn(aTHX_ Nullch, mode, fd, 0, 0, NULL, 0, NULL);
d361 3
a363 3
#undef PerlIO_open
PerlIO *
PerlIO_open(const char *path, const char *mode)
d365 1
a365 3
    dTHX;
    SV *name = sv_2mortal(newSVpvn(path, strlen(path)));
    return PerlIO_openn(aTHX_ Nullch, mode, -1, 0, 0, NULL, 1, &name);
d368 3
a370 3
#undef Perlio_reopen
PerlIO *
PerlIO_reopen(const char *path, const char *mode, PerlIO *f)
d372 1
a372 3
    dTHX;
    SV *name = sv_2mortal(newSVpvn(path, strlen(path)));
    return PerlIO_openn(aTHX_ Nullch, mode, -1, 0, 0, f, 1, &name);
d375 3
a377 3
#undef PerlIO_getc
int
PerlIO_getc(PerlIO *f)
d379 1
a379 7
    dTHX;
    STDCHAR buf[1];
    SSize_t count = PerlIO_read(f, buf, 1);
    if (count == 1) {
	return (unsigned char) buf[0];
    }
    return EOF;
d382 3
a384 3
#undef PerlIO_ungetc
int
PerlIO_ungetc(PerlIO *f, int ch)
d386 1
a386 7
    dTHX;
    if (ch != EOF) {
	STDCHAR buf = ch;
	if (PerlIO_unread(f, &buf, 1) == 1)
	    return ch;
    }
    return EOF;
d389 3
a391 3
#undef PerlIO_putc
int
PerlIO_putc(PerlIO *f, int ch)
d393 5
a397 3
    dTHX;
    STDCHAR buf = ch;
    return PerlIO_write(f, &buf, 1);
d400 1
a400 1
#undef PerlIO_puts
d402 1
a402 1
PerlIO_puts(PerlIO *f, const char *s)
d404 5
a408 3
    dTHX;
    STRLEN len = strlen(s);
    return PerlIO_write(f, s, len);
d415 1
a415 25
    dTHX;
    PerlIO_seek(f, (Off_t) 0, SEEK_SET);
    PerlIO_clearerr(f);
}

#undef PerlIO_vprintf
int
PerlIO_vprintf(PerlIO *f, const char *fmt, va_list ap)
{
    dTHX;
    SV *sv = newSVpvn("", 0);
    char *s;
    STRLEN len;
    SSize_t wrote;
#ifdef NEED_VA_COPY
    va_list apc;
    Perl_va_copy(ap, apc);
    sv_vcatpvf(sv, fmt, &apc);
#else
    sv_vcatpvf(sv, fmt, &ap);
#endif
    s = SvPV(sv, len);
    wrote = PerlIO_write(f, s, len);
    SvREFCNT_dec(sv);
    return wrote;
d419 2
a420 2
int
PerlIO_printf(PerlIO *f, const char *fmt, ...)
d422 6
a427 6
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vprintf(f, fmt, ap);
    va_end(ap);
    return result;
d431 2
a432 2
int
PerlIO_stdoutf(const char *fmt, ...)
d434 6
a439 7
    dTHX;
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vprintf(PerlIO_stdout(), fmt, ap);
    va_end(ap);
    return result;
d446 15
a460 29
    /*
     * I have no idea how portable mkstemp() is ...
     */
#if defined(WIN32) || !defined(HAVE_MKSTEMP)
    dTHX;
    PerlIO *f = NULL;
    FILE *stdio = PerlSIO_tmpfile();
    if (stdio) {
	if ((f = PerlIO_push(aTHX_(PerlIO_allocate(aTHX)), &PerlIO_stdio, "w+", Nullsv))) {
	    PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
	    s->stdio = stdio;
	}
    }
    return f;
#else
    dTHX;
    SV *sv = newSVpv("/tmp/PerlIO_XXXXXX", 0);
    int fd = mkstemp(SvPVX(sv));
    PerlIO *f = NULL;
    if (fd >= 0) {
	f = PerlIO_fdopen(fd, "w+");
	if (f) {
	    PerlIOBase(f)->flags |= PERLIO_F_TEMP;
	}
	PerlLIO_unlink(SvPVX(sv));
	SvREFCNT_dec(sv);
    }
    return f;
#endif
d463 6
a468 2
#undef HAS_FSETPOS
#undef HAS_FGETPOS
d470 5
a474 2
#endif                          /* USE_SFIO */
#endif                          /* PERLIO_IS_STDIO */
d476 7
a482 4
/*======================================================================================*/
/*
 * Now some functions in terms of above which may be needed even if we are
 * not in true PerlIO mode
d484 4
d492 5
a496 1
PerlIO_setpos(PerlIO *f, SV *pos)
d498 1
a498 9
    dTHX;
    if (SvOK(pos)) {
	STRLEN len;
	Off_t *posn = (Off_t *) SvPV(pos, len);
	if (f && len == sizeof(Off_t))
	    return PerlIO_seek(f, *posn, SEEK_SET);
    }
    SETERRNO(EINVAL, SS$_IVCHAN);
    return -1;
d501 1
d504 1
a504 1
PerlIO_setpos(PerlIO *f, SV *pos)
a505 5
    dTHX;
    if (SvOK(pos)) {
	STRLEN len;
	Fpos_t *fpos = (Fpos_t *) SvPV(pos, len);
	if (f && len == sizeof(Fpos_t)) {
d507 1
a507 1
	    return fsetpos64(f, fpos);
d509 1
a509 1
	    return fsetpos(f, fpos);
a510 4
	}
    }
    SETERRNO(EINVAL, SS$_IVCHAN);
    return -1;
d513 1
d518 8
a525 1
PerlIO_getpos(PerlIO *f, SV *pos)
d527 2
a528 4
    dTHX;
    Off_t posn = PerlIO_tell(f);
    sv_setpvn(pos, (char *) &posn, sizeof(posn));
    return (posn == (Off_t) - 1) ? -1 : 0;
d530 1
d532 1
d535 1
a535 1
PerlIO_getpos(PerlIO *f, SV *pos)
a536 3
    dTHX;
    Fpos_t fpos;
    int code;
d538 1
a538 1
    code = fgetpos64(f, &fpos);
d540 1
a540 1
    code = fgetpos(f, &fpos);
a541 2
    sv_setpvn(pos, (char *) &fpos, sizeof(fpos));
    return code;
d544 1
d552 1
a552 2
    return 0;                   /* wrong, but perl doesn't use the return
				 * value */
d559 1
a559 2
    return 0;                   /* wrong, but perl doesn't use the return
				 * value */
d565 1
a565 1
int
d568 8
a575 8
    int val = vsprintf(s, fmt, ap);
    if (n >= 0) {
	if (strlen(s) >= (STRLEN) n) {
	    dTHX;
	    (void) PerlIO_puts(Perl_error_log,
			       "panic: sprintf overflow - memory corrupted!\n");
	    my_exit(1);
	}
d577 2
a578 1
    return val;
d583 2
a584 2
int
PerlIO_sprintf(char *s, int n, const char *fmt, ...)
d586 6
a591 6
    va_list ap;
    int result;
    va_start(ap, fmt);
    result = PerlIO_vsprintf(s, n, fmt, ap);
    va_end(ap);
    return result;
d595 1
a595 6






@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a52 54
#ifdef __Lynx__
/* Missing proto on LynxOS */
int mkstemp(char*);
#endif

/* Call the callback or PerlIOBase, and return failure. */
#define Perl_PerlIO_or_Base(f, callback, base, failure, args) 	\
	if (PerlIOValid(f)) {					\
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
		if (tab && tab->callback)			\
			return (*tab->callback) args;		\
		else						\
			return PerlIOBase_ ## base args;	\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN);			\
	return failure

/* Call the callback or fail, and return failure. */
#define Perl_PerlIO_or_fail(f, callback, failure, args) 	\
	if (PerlIOValid(f)) {					\
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
		if (tab && tab->callback)			\
			return (*tab->callback) args;		\
		SETERRNO(EINVAL, LIB_INVARG);			\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN);			\
	return failure

/* Call the callback or PerlIOBase, and be void. */
#define Perl_PerlIO_or_Base_void(f, callback, base, args) 	\
	if (PerlIOValid(f)) {					\
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
		if (tab && tab->callback)			\
			(*tab->callback) args;			\
		else						\
			PerlIOBase_ ## base args;		\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN)

/* Call the callback or fail, and be void. */
#define Perl_PerlIO_or_fail_void(f, callback, args) 		\
	if (PerlIOValid(f)) {					\
		PerlIO_funcs *tab = PerlIOBase(f)->tab; 	\
		if (tab && tab->callback)			\
			(*tab->callback) args;			\
		else						\
			SETERRNO(EINVAL, LIB_INVARG);		\
	}							\
	else							\
		SETERRNO(EBADF, SS_IVCHAN)

d217 1
a217 1
	SETERRNO(EBADF, SS_IVCHAN);
d242 1
a242 1
	    if (*mode == IoTYPE_NUMERIC) {
d384 1
a384 3
/*
 * Why is this here - not in perlio.h?  RMB
 */
d386 1
a386 1
    __attribute__format__(__printf__, 1, 2);
d478 1
d480 6
a485 5
	if (tab && tab->Dup)
	     return (*tab->Dup)(aTHX_ PerlIO_allocate(aTHX), f, param, flags);
	else {
	     return PerlIOBase_dup(aTHX_ PerlIO_allocate(aTHX), f, param, flags);
	}
a486 4
    else
	 SETERRNO(EBADF, SS_IVCHAN);

    return NULL;
a642 29
/* Return as an array the stack of layers on a filehandle.  Note that
 * the stack is returned top-first in the array, and there are three
 * times as many array elements as there are layers in the stack: the
 * first element of a layer triplet is the name, the second one is the
 * arguments, and the third one is the flags. */

AV *
PerlIO_get_layers(pTHX_ PerlIO *f)
{
     AV *av = newAV();

     if (PerlIOValid(f)) {
	  PerlIOl *l = PerlIOBase(f);

	  while (l) {
	       SV *name = l->tab && l->tab->name ?
		    newSVpv(l->tab->name, 0) : &PL_sv_undef;
	       SV *arg = l->tab && l->tab->Getarg ?
		    (*l->tab->Getarg)(aTHX_ &l, 0, 0) : &PL_sv_undef;
	       av_push(av, name);
	       av_push(av, arg);
	       av_push(av, newSViv((IV)l->flags));
	       l = l->next;
	  }
     }

     return av;
}

d656 1
a656 1
	if (memEQ(f->name, name, len) && f->name[len] == 0) {
d663 9
a671 22
	if (PL_in_load_module) {
	    Perl_croak(aTHX_ "Recursive call to Perl_load_module in PerlIO_find_layer");
	    return NULL;
	} else {
	    SV *pkgsv = newSVpvn("PerlIO", 6);
	    SV *layer = newSVpvn(name, len);
	    CV *cv  = get_cv("PerlIO::Layer::NoWarnings", FALSE);
    	    ENTER;
	    SAVEINT(PL_in_load_module);
	    if (cv) {
	        SAVESPTR(PL_warnhook);
		PL_warnhook = (SV *) cv;
	    }
	    PL_in_load_module++;
	    /*
	     * The two SVs are magically freed by load_module
	     */
	    Perl_load_module(aTHX_ 0, pkgsv, Nullsv, layer, Nullsv);
	    PL_in_load_module--;
	    LEAVE;
	    return PerlIO_find_layer(aTHX_ name, len, 0);
	}
a764 11
XS(XS_PerlIO__Layer__NoWarnings)
{
    /* This is used as a %SIG{__WARN__} handler to supress warnings
       during loading of layers.
     */
    dXSARGS;
    if (items)
    	PerlIO_debug("warning:%s\n",SvPV_nolen(ST(0)));
    XSRETURN(0);
}

d813 1
a813 1
			      "Invalid separator character %c%c%c in PerlIO layer specification %s",
d815 1
a815 1
		    SETERRNO(EINVAL, LIB_INVARG);
d850 1
a850 1
				      "Argument list not closed for PerlIO layer \"%.*s\"",
d873 1
a873 1
			    Perl_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"%.*s\"",
d967 1
a967 1
#if defined(WIN32)
a1006 1
    newXS("PerlIO::Layer::NoWarnings", XS_PerlIO__Layer__NoWarnings, __FILE__);
d1053 1
a1053 2
	    if (*l->tab->Pushed &&
		(*l->tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
d1063 2
a1064 3
	if (tab->Pushed &&
	    (*tab->Pushed) (aTHX_ f, mode, arg, tab) != 0) {
	     return NULL;
d1223 2
a1224 7
    if (PerlIOValid(f)) {
	PerlIO_funcs *tab = PerlIOBase(f)->tab;
	if (tab && tab->Close)
	    return (*tab->Close)(aTHX_ f);
	else
	    return PerlIOBase_close(aTHX_ f);
    }
d1226 1
a1226 1
	SETERRNO(EBADF, SS_IVCHAN);
d1234 6
a1239 3
    int code = PerlIO__close(aTHX_ f);
    while (PerlIOValid(f)) {
	PerlIO_pop(aTHX_ f);
d1247 6
a1252 1
     Perl_PerlIO_or_Base(f, Fileno, fileno, -1, (aTHX_ f));
d1423 2
a1424 7
	    if (tab->Open)
		 f = (*tab->Open) (aTHX_ tab, layera, n, mode, fd, imode, perm,
				   f, narg, args);
	    else {
		 SETERRNO(EINVAL, LIB_INVARG);
		 f = NULL;
	    }
d1448 6
a1453 1
     Perl_PerlIO_or_Base(f, Read, read, -1, (aTHX_ f, vbuf, count));
d1459 6
a1464 1
     Perl_PerlIO_or_Base(f, Unread, unread, -1, (aTHX_ f, vbuf, count));
d1470 6
a1475 1
     Perl_PerlIO_or_fail(f, Write, -1, (aTHX_ f, vbuf, count));
d1481 6
a1486 1
     Perl_PerlIO_or_fail(f, Seek, -1, (aTHX_ f, offset, whence));
d1492 6
a1497 1
     Perl_PerlIO_or_fail(f, Tell, -1, (aTHX_ f));
d1506 1
a1506 2

	    if (tab && tab->Flush)
d1508 6
a1513 2
	    else
		 return 0; /* If no Flush defined, silently succeed. */
d1517 1
a1517 1
	    SETERRNO(EBADF, SS_IVCHAN);
d1566 6
a1571 1
     Perl_PerlIO_or_fail(f, Fill, -1, (aTHX_ f));
d1577 6
a1582 6
     if (PerlIOValid(f))
	  return (PerlIOBase(f)->flags & PERLIO_F_UTF8) != 0;
     else
	  SETERRNO(EBADF, SS_IVCHAN);

     return -1;
d1588 6
a1593 1
     Perl_PerlIO_or_Base(f, Eof, eof, -1, (aTHX_ f));
d1599 6
a1604 1
     Perl_PerlIO_or_Base(f, Error, error, -1, (aTHX_ f));
d1610 4
a1613 1
     Perl_PerlIO_or_Base_void(f, Clearerr, clearerr, (aTHX_ f));
d1619 4
a1622 1
     Perl_PerlIO_or_Base_void(f, Setlinebuf, setlinebuf, (aTHX_ f));
d1628 4
a1631 11
     if (PerlIOValid(f)) {
	  PerlIO_funcs *tab = PerlIOBase(f)->tab;

	  if (tab)
	       return (tab->Get_base != NULL);
	  SETERRNO(EINVAL, LIB_INVARG);
     }
     else
	  SETERRNO(EBADF, SS_IVCHAN);

     return 0;
d1638 2
a1639 5
	 PerlIO_funcs *tab = PerlIOBase(f)->tab;

	 if (tab)
	      return (tab->Set_ptrcnt != NULL);
	 SETERRNO(EINVAL, LIB_INVARG);
a1640 3
    else
	 SETERRNO(EBADF, SS_IVCHAN);

d1649 1
a1649 4

	if (tab)
	     return (tab->Get_ptr != NULL && tab->Get_cnt != NULL);
	  SETERRNO(EINVAL, LIB_INVARG);
a1650 3
    else
	 SETERRNO(EBADF, SS_IVCHAN);

d1658 2
a1659 5
	  PerlIO_funcs *tab = PerlIOBase(f)->tab;

	  if (tab)
	       return (tab->Set_ptrcnt != NULL);
	  SETERRNO(EINVAL, LIB_INVARG);
a1660 3
    else
	 SETERRNO(EBADF, SS_IVCHAN);

d1667 3
a1669 1
     Perl_PerlIO_or_fail(f, Get_base, NULL, (aTHX_ f));
d1675 3
a1677 1
     Perl_PerlIO_or_fail(f, Get_bufsiz, -1, (aTHX_ f));
d1683 7
a1689 1
     Perl_PerlIO_or_fail(f, Get_ptr, NULL, (aTHX_ f));
d1695 7
a1701 1
     Perl_PerlIO_or_fail(f, Get_cnt, -1, (aTHX_ f));
d1707 3
a1709 1
     Perl_PerlIO_or_fail_void(f, Set_ptrcnt, (aTHX_ f, NULL, cnt));
d1715 7
a1721 1
     Perl_PerlIO_or_fail_void(f, Set_ptrcnt, (aTHX_ f, ptr, cnt));
d1807 2
a1808 5
    if (tab && tab->Open)
	 return (*tab->Open) (aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			      old, narg, args);
    SETERRNO(EINVAL, LIB_INVARG);
    return NULL;
d1897 1
a1897 1
	if (*mode == IoTYPE_NUMERIC || *mode == IoTYPE_IMPLICIT)
d1910 1
a1910 1
	    SETERRNO(EINVAL, LIB_INVARG);
d1925 1
a1925 1
		SETERRNO(EINVAL, LIB_INVARG);
d1970 1
a1970 3
        if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD)) {
	    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
	    SETERRNO(EBADF, SS_IVCHAN);
a1971 1
	}
d2009 8
a2016 23
    IV code = -1;
    if (PerlIOValid(f)) {
	PerlIO *n = PerlIONext(f);
	code = PerlIO_flush(f);
	PerlIOBase(f)->flags &=
	   ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
	while (PerlIOValid(n)) {
	    PerlIO_funcs *tab = PerlIOBase(n)->tab;
	    if (tab && tab->Close) {
		if ((*tab->Close)(aTHX_ n) != 0)
		    code = -1;
		break;
	    }
	    else {
		PerlIOBase(n)->flags &=
		    ~(PERLIO_F_CANREAD | PERLIO_F_CANWRITE | PERLIO_F_OPEN);
	    }
	    n = PerlIONext(n);
	}
    }
    else {
	SETERRNO(EBADF, SS_IVCHAN);
    }
d2080 1
a2080 4
	if (tab && tab->Dup)
	    f = (*tab->Dup)(aTHX_ f, nexto, param, flags);
	else
	    f = PerlIOBase_dup(aTHX_ f, nexto, param, flags);
d2084 1
a2084 1
	SV *arg;
d2088 2
a2089 4
	if (self->Getarg)
	    arg = (*self->Getarg)(aTHX_ o, param, flags);
	else {
	    arg = Nullsv;
d2190 1
a2190 1
    if (*mode == IoTYPE_IMPLICIT || *mode == IoTYPE_NUMERIC)
d2236 1
a2236 1
	SETERRNO(EINVAL, LIB_INVARG);
a2247 21
static void
PerlIOUnix_setfd(pTHX_ PerlIO *f, int fd, int imode)
{
    PerlIOUnix *s = PerlIOSelf(f, PerlIOUnix);
#if defined(WIN32)
    Stat_t st;
    if (PerlLIO_fstat(fd, &st) == 0) {
	if (!S_ISREG(st.st_mode)) {
	    PerlIO_debug("%d is not regular file\n",fd);
    	    PerlIOBase(f)->flags |= PERLIO_F_NOTREG;
	}
	else {
	    PerlIO_debug("%d _is_ a regular file\n",fd);
	}
    }
#endif
    s->fd = fd;
    s->oflags = imode;
    PerlIOUnix_refcnt_inc(fd);
}

d2252 1
d2256 1
d2262 1
a2262 2
        PerlIOUnix_setfd(aTHX_ f, PerlIO_fileno(PerlIONext(f)),
                         mode ? PerlIOUnix_oflags(mode) : -1);
a2264 1

a2267 22
IV
PerlIOUnix_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
    int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    Off_t new;
    if (PerlIOBase(f)->flags & PERLIO_F_NOTREG) {
#ifdef  ESPIPE
	SETERRNO(ESPIPE, LIB_INVARG);
#else
	SETERRNO(EINVAL, LIB_INVARG);
#endif
	return -1;
    }
    new  = PerlLIO_lseek(fd, offset, whence);
    if (new == (Off_t) - 1)
     {
      return -1;
     }
    PerlIOBase(f)->flags &= ~PERLIO_F_EOF;
    return  0;
}

d2279 1
a2279 1
	if (*mode == IoTYPE_NUMERIC)
d2290 2
a2291 1
	if (*mode == IoTYPE_IMPLICIT)
d2301 3
a2303 1
        PerlIOUnix_setfd(aTHX_ f, fd, imode);
d2305 1
a2305 2
	if (*mode == IoTYPE_APPEND)
	    PerlIOUnix_seek(aTHX_ f, 0, SEEK_END);
d2330 3
a2332 1
	    PerlIOUnix_setfd(aTHX_ f, fd, os->oflags);
d2351 3
a2353 6
	    if (len < 0) {
		if (errno != EAGAIN) {
		    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		}
	    }
	    else if (len == 0 && count != 0) {
a2354 2
		SETERRNO(0,0);
	    }
d2368 2
a2369 5
	    if (len < 0) {
		if (errno != EAGAIN) {
		    PerlIOBase(f)->flags |= PERLIO_F_ERROR;
		}
	    }
d2376 9
d2404 1
a2404 1
	SETERRNO(EBADF,SS_IVCHAN);
d2484 2
a2485 4
    if (mode) {
	while (*mode) {
	    *tmode++ = *mode++;
	}
d2487 1
a2487 1
#if defined(PERLIO_USING_CRLF) || defined(__CYGWIN__)
d2583 1
a2583 1
	    if (*mode == IoTYPE_NUMERIC) {
d2588 1
a2588 8
	        FILE *stdio;
	        bool appended = FALSE;
#ifdef __CYGWIN__
		/* Cygwin wants its 'b' early. */
		appended = TRUE;
		mode = PerlIOStdio_mode(mode, tmode);
#endif
		stdio = PerlSIO_fopen(path, mode);
d2594 3
a2596 4
		    if (!appended)
		        mode = PerlIOStdio_mode(mode, tmode);
		    f = PerlIO_push(aTHX_ f, self, mode, PerlIOArg);
		    if (f) {
d2611 1
a2611 1
	    if (*mode == IoTYPE_IMPLICIT) {
a2656 2
	int fd = fileno(stdio);
	char mode[8];
d2658 4
a2661 4
	    int dfd = PerlLIO_dup(fileno(stdio));
	    if (dfd >= 0) {
		stdio = PerlSIO_fdopen(dfd, PerlIO_modestr(o,mode));
		goto set_this;
a2668 2
    	stdio = PerlSIO_fdopen(fd, PerlIO_modestr(o,mode));
    set_this:
a2674 90
static int
PerlIOStdio_invalidate_fileno(pTHX_ FILE *f)
{
    /* XXX this could use PerlIO_canset_fileno() and
     * PerlIO_set_fileno() support from Configure
     */
#  if defined(__GLIBC__)
    /* There may be a better way for GLIBC:
    	- libio.h defines a flag to not close() on cleanup
     */	
    f->_fileno = -1;
    return 1;
#  elif defined(__sun__)
#    if defined(_LP64)
    /* On solaris, if _LP64 is defined, the FILE structure is this:
     *
     *  struct FILE {
     *      long __pad[16];
     *  };
     *
     * It turns out that the fd is stored in the top 32 bits of
     * file->__pad[4]. The lower 32 bits contain flags. file->pad[5] appears
     * to contain a pointer or offset into another structure. All the
     * remaining fields are zero.
     *
     * We set the top bits to -1 (0xFFFFFFFF).
     */
    f->__pad[4] |= 0xffffffff00000000L;
    assert(fileno(f) == 0xffffffff);
#    else /* !defined(_LP64) */
    /* _file is just a unsigned char :-(
       Not clear why we dup() rather than using -1
       even if that would be treated as 0xFF - so will
       a dup fail ...
     */
    f->_file = PerlLIO_dup(fileno(f));
#    endif /* defined(_LP64) */
    return 1;
#  elif defined(__hpux)
    f->__fileH = 0xff;
    f->__fileL = 0xff;
    return 1;
   /* Next one ->_file seems to be a reasonable fallback, i.e. if
      your platform does not have special entry try this one.
      [For OSF only have confirmation for Tru64 (alpha)
      but assume other OSFs will be similar.]
    */
#  elif defined(_AIX) || defined(__osf__) || defined(__irix__)
    f->_file = -1;
    return 1;
#  elif defined(__FreeBSD__)
    /* There may be a better way on FreeBSD:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
#  elif defined(__EMX__)
    /* f->_flags &= ~_IOOPEN; */	/* Will leak stream->_buffer */
    f->_handle = -1;
    return 1;
#  elif defined(__CYGWIN__)
    /* There may be a better way on CYGWIN:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
#  elif defined(WIN32)
#    if defined(__BORLANDC__)
    f->fd = PerlLIO_dup(fileno(f));
#    elif defined(UNDER_CE)
    /* WIN_CE does not have access to FILE internals, it hardly has FILE
       structure at all
     */
#    else
    f->_file = -1;
#    endif
    return 1;
#  else
#if 0
    /* Sarathy's code did this - we fall back to a dup/dup2 hack
       (which isn't thread safe) instead
     */
#    error "Don't know how to set FILE.fileno on your platform"
#endif
    return 0;
#  endif
}

d2678 4
d2687 5
a2691 7
    else {
        int fd = fileno(stdio);
	int socksfd = 0;
	int invalidate = 0;
	IV result = 0;
	int saveerr = 0;
	int dupfd = 0;
d2693 9
a2701 55
    	/* Socks lib overrides close() but stdio isn't linked to
	   that library (though we are) - so we must call close()
	   on sockets on stdio's behalf.
	 */
    	int optval;
    	Sock_size_t optlen = sizeof(int);
    	if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *) &optval, &optlen) == 0) {
            socksfd = 1;
	    invalidate = 1;
    	}
#endif
    	if (PerlIOUnix_refcnt_dec(fd) > 0) {
	    /* File descriptor still in use */
	    invalidate = 1;
	    socksfd = 0;
	}
	if (invalidate) {
   	    /* For STD* handles don't close the stdio at all
	       this is because we have shared the FILE * too
   	     */
	    if (stdio == stdin) {
	    	/* Some stdios are buggy fflush-ing inputs */
	    	return 0;
	    }
	    else if (stdio == stdout || stdio == stderr) {
	    	return PerlIO_flush(f);
	    }
            /* Tricky - must fclose(stdio) to free memory but not close(fd)
	       Use Sarathy's trick from maint-5.6 to invalidate the
	       fileno slot of the FILE *
	    */
	    result = PerlIO_flush(f);
	    saveerr = errno;
    	    if (!(invalidate = PerlIOStdio_invalidate_fileno(aTHX_ stdio))) {
	    	dupfd = PerlLIO_dup(fd);
	    }
	}
        result = PerlSIO_fclose(stdio);
	/* We treat error from stdio as success if we invalidated
	   errno may NOT be expected EBADF
	 */
	if (invalidate && result != 0) {
	    errno = saveerr;
	    result = 0;
	}
	if (socksfd) {
	    /* in SOCKS case let close() determine return value */
	    result = close(fd);
	}
	if (dupfd) {
	    PerlLIO_dup2(dupfd,fd);
	    PerlLIO_close(dupfd);
	}
	return result;
    }
d2704 2
d2711 10
a2720 12
    for (;;) {
	if (count == 1) {
	    STDCHAR *buf = (STDCHAR *) vbuf;
	    /*
	     * Perl is expecting PerlIO_getc() to fill the buffer Linux's
	     * stdio does not do that for fread()
	     */
	    int ch = PerlSIO_fgetc(s);
	    if (ch != EOF) {
		*buf = ch;
		got = 1;
	    }
a2721 8
	else
	    got = PerlSIO_fread(vbuf, 1, count, s);
	if (got == 0 && PerlSIO_ferror(s))
	    got = -1;
	if (got >= 0 || errno != EINTR)
	    break;
	PERL_ASYNC_CHECK();
	SETERRNO(0,0);	/* just in case */
d2723 2
d2789 2
a2790 10
    SSize_t got;
    for (;;) {
	got = PerlSIO_fwrite(vbuf, 1, count,
			      PerlIOSelf(f, PerlIOStdio)->stdio);
	if (got >= 0 || errno != EINTR)
	    break;
	PERL_ASYNC_CHECK();
	SETERRNO(0,0);	/* just in case */
    }
    return got;
d3030 6
a3035 3
#   if defined(HAS_FAST_STDIO) && defined(USE_FAST_STDIO)
    PerlIOStdio_set_ptrcnt,
#   else
a3036 2
#   endif /* HAS_FAST_STDIO && USE_FAST_STDIO */
#else
d3038 2
a3039 3
    NULL,
    NULL,
#endif /* USE_STDIO_PTR */
a3057 1
	    PerlIO *f2;
d3060 2
a3061 2
	    if ((f2 = PerlIO_push(aTHX_ f, &PerlIO_stdio, buf, Nullsv))) {
		PerlIOStdio *s = PerlIOSelf((f = f2), PerlIOStdio);
d3139 3
a3141 6
	PerlIO_funcs *tab =
	     PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIOBase(next)->tab);
	if (tab && tab->Open)
	     next =
		  (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			       next, narg, args);
d3149 1
a3149 1
	if (*mode == IoTYPE_IMPLICIT) {
d3155 2
a3156 5
	if (tab && tab->Open)
	     f = (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm,
			      f, narg, args);
	else
	     SETERRNO(EINVAL, LIB_INVARG);
d3175 1
a3175 1
		    PerlIO_binmode(aTHX_ f,  '<'/*not used*/, O_BINARY, Nullch);
a3397 5
    if (PerlIOBase(f)->flags & PERLIO_F_RDBUF) {
    	if (PerlIO_flush(f) != 0) {
	    return 0;
	}
    }	
a3455 13
    if ((PerlIOBase(f)->flags & PERLIO_F_APPEND) &&
        (PerlIOBase(f)->flags & PERLIO_F_WRBUF)) {
#if 1
    	/* As O_APPEND files are normally shared in some sense it is better
	   to flush :
	 */  	
	PerlIO_flush(f);
#else	
        /* when file is NOT shared then this is sufficient */
	PerlIO_seek(PerlIONext(f),0, SEEK_END);
#endif
	posn = b->posn = PerlIO_tell(PerlIONext(f));
    }
a3742 17
    {
      /* Enable the first CRLF capable layer you can find, but if none
       * found, the one we just pushed is fine.  This results in at
       * any given moment at most one CRLF-capable layer being enabled
       * in the whole layer stack. */
	 PerlIO *g = PerlIONext(f);
	 while (g && *g) {
	      PerlIOl *b = PerlIOBase(g);
	      if (b && b->tab == &PerlIO_crlf) {
		   if (!(b->flags & PERLIO_F_CRLF))
			b->flags |= PERLIO_F_CRLF;
		   PerlIO_pop(aTHX_ f);
		   return code;
	      }		  
	      g = PerlIONext(g);
	 }
    }
a3841 4
			/* Note as we have moved buf up flush's
			   posn += ptr-buf
			   will naturally make posn point at CR
			 */
d3848 1
d4064 1
a4064 1
			SETERRNO(0, SS_NORMAL);
d4528 29
a4556 37
     dTHX;
     PerlIO *f = NULL;
     int fd = -1;
#ifdef WIN32
     fd = win32_tmpfd();
     if (fd >= 0)
	  f = PerlIO_fdopen(fd, "w+b");
#else /* WIN32 */
#    if defined(HAS_MKSTEMP) && ! defined(VMS) && ! defined(OS2)
     SV *sv = newSVpv("/tmp/PerlIO_XXXXXX", 0);

     /*
      * I have no idea how portable mkstemp() is ... NI-S
      */
     fd = mkstemp(SvPVX(sv));
     if (fd >= 0) {
	  f = PerlIO_fdopen(fd, "w+");
	  if (f)
	       PerlIOBase(f)->flags |= PERLIO_F_TEMP;
	  PerlLIO_unlink(SvPVX(sv));
	  SvREFCNT_dec(sv);
     }
#    else	/* !HAS_MKSTEMP, fallback to stdio tmpfile(). */
     FILE *stdio = PerlSIO_tmpfile();

     if (stdio) {
	  if ((f = PerlIO_push(aTHX_(PerlIO_allocate(aTHX)),
                               &PerlIO_stdio, "w+", Nullsv))) {
               PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);

               if (s)
                    s->stdio = stdio;
          }
     }
#    endif /* else HAS_MKSTEMP */
#endif /* else WIN32 */
     return f;
d4583 1
a4583 1
    SETERRNO(EINVAL, SS_IVCHAN);
d4603 1
a4603 1
    SETERRNO(EINVAL, SS_IVCHAN);
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
 * perlio.c Copyright (c) 1996-2004, Nick Ing-Simmons You may distribute
a3693 1
    const STDCHAR *flushptr = buf;
a3703 5
    if (PerlIOBase(f)->flags & PERLIO_F_LINEBUF) {
	flushptr = buf + count;
	while (flushptr > buf && *(flushptr - 1) != '\n')
	    --flushptr;
    }
a3707 2
	if (flushptr > buf && flushptr <= buf + avail)
	    avail = flushptr - buf;
d3709 21
a3729 8
	if (avail) {
	    Copy(buf, b->ptr, avail, STDCHAR);
	    count -= avail;
	    buf += avail;
	    written += avail;
	    b->ptr += avail;
	    if (buf == flushptr)
		PerlIO_flush(f);
a4720 1
    bool exported = FALSE;
d4722 1
a4722 5
    if (!stdio) {
	stdio = PerlIO_exportFILE(f,0);
	exported = TRUE;
    }
    if (stdio) {
a4723 2
	if (exported) PerlIO_releaseFILE(f,stdio);
    }
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@a11 6
/* This file contains the functions needed to implement PerlIO, which
 * is Perl's private replacement for the C stdio library. This is used
 * by default unless you compile with -Uuseperlio or run with
 * PERLIO=:stdio (but don't do this unless you know what you're doing)
 */

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d2 1
a2 1
 * perlio.c Copyright (c) 1996-2006, Nick Ing-Simmons You may distribute
a58 2
#define PERLIO_MAX_REFCOUNTABLE_FD 2048

d67 1
a67 1
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
d80 1
a80 1
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
d92 1
a92 1
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
d104 1
a104 1
		const PerlIO_funcs * const tab = PerlIOBase(f)->tab;\
a112 1
#ifndef USE_SFIO
a162 3
    PERL_UNUSED_ARG(fp);
    PERL_UNUSED_ARG(iotype);
    PERL_UNUSED_ARG(mode);
a166 1
#endif /* sfio */
d175 1
a175 1
    const int result = rawmode & O_ACCMODE;
a243 3
    PERL_UNUSED_ARG(iotype);
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(names);
d253 1
a253 1
#if defined(PERL_MICRO) || defined(SYMBIAN)
d263 1
a263 1
	const int fd = PerlLIO_dup(PerlIO_fileno(f));
d301 1
a301 1
	    const char *name = SvPV_nolen_const(*args);
d305 1
a305 1
		    return PerlIO_fdopen(fd, mode + 1);
d327 1
a327 1
	const char *name = SvPV_nolen_const(ST(1));
d404 1
a404 1
    const int fd = fileno(stdio);
d414 2
a415 2
    const int fd = PerlIO_fileno(pio);
    FILE * const f = fdopen(fd, "r+");
d444 6
d457 2
a458 2
    if (!dbg && !PL_tainting && PL_uid == PL_euid && PL_gid == PL_egid) {
        const char *s = PerlEnv_getenv("PERLIO_DEBUG");
a465 2
	const char *s = CopFILE(PL_curcop);
	STRLEN len;
d469 3
d474 2
a475 1
	len = sprintf(buffer, "%.40s:%" IVdf " ", s, (IV) CopLINE(PL_curcop));
d480 3
d489 1
a489 1
	s = SvPV_const(sv, len);
d526 1
a526 1
    Newxz(f,PERLIO_TABLE_SIZE,PerlIO);
d539 1
a539 1
	const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d576 1
a576 1
    Newxz(list, 1, PerlIO_list_t);
d608 1
a608 1
	    Newx(list->array, list->len, PerlIO_pair_t);
d613 1
a613 1
	(void)SvREFCNT_inc(arg);
a654 3
#else
    PERL_UNUSED_ARG(proto);
    PERL_UNUSED_ARG(param);
d748 1
a748 1
	PerlIO_funcs * const f = PL_known_layers->array[i].funcs;
d760 4
a763 4
	    SV * const pkgsv = newSVpvn("PerlIO", 6);
	    SV * const layer = newSVpvn(name, len);
	    CV * const cv    = get_cv("PerlIO::Layer::NoWarnings", FALSE);
	    ENTER;
d766 1
a766 2
		SAVEGENERICSV(PL_warnhook);
		(void)SvREFCNT_inc(cv);
d847 1
a847 1
	const char *name = SvPV_const(ST(i), len);
d866 2
a867 2
    HV * const stash = gv_stashpv("PerlIO::Layer", TRUE);
    SV * const sv = sv_bless(newRV_noinc(newSViv(PTR2IV(tab))), stash);
d878 1
a878 1
    	PerlIO_debug("warning:%s\n",SvPV_nolen_const(ST(0)));
d888 4
a891 4
	STRLEN len;
	const char * const name = SvPV_const(ST(1), len);
	const bool load = (items > 2) ? SvTRUE(ST(2)) : 0;
	PerlIO_funcs * const layer = PerlIO_find_layer(aTHX_ name, len, load);
d927 1
a927 1
		    const char q = ((*s == '\'') ? '"' : '\'');
d979 2
a980 1
		    PerlIO_funcs * const layer =
d989 1
a989 1
			if (ckWARN(WARN_LAYER))
d1005 1
a1005 1
    PERLIO_FUNCS_DECL(*tab) = &PerlIO_perlio;
a1038 3
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
    PERL_UNUSED_ARG(tab);
d1047 1
a1047 1
PERLIO_FUNCS_DECL(PerlIO_remove) = {
a1062 2
    NULL,
    NULL,
d1081 1
a1081 1
	PERLIO_FUNCS_DECL(*osLayer) = &PerlIO_unix;
d1083 1
a1083 1
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_unix));
d1085 1
a1085 1
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_win32));
d1090 4
a1093 4
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_raw));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_perlio));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_stdio));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_crlf));
d1095 1
a1095 1
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_mmap));
d1097 3
a1099 3
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_utf8));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_remove));
	PerlIO_define_layer(aTHX_ PERLIO_FUNCS_CAST(&PerlIO_byte));
d1130 1
a1130 1
    PerlIO_list_t * const av = PerlIO_default_layers(aTHX);
d1133 1
a1133 1
    return PerlIO_layer_fetch(aTHX_ av, n, PERLIO_FUNCS_CAST(&PerlIO_stdio));
d1151 1
a1151 1
PerlIO_push(pTHX_ PerlIO *f, PERLIO_FUNCS_DECL(*tab), const char *mode, SV *arg)
d1158 1
a1158 1
	PerlIOl *l;
d1163 1
a1163 1
	Newxc(l,tab->size,char,PerlIOl);
d1167 1
a1167 1
	    l->tab = (PerlIO_funcs*) tab;
d1172 1
a1172 1
		(*l->tab->Pushed) (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
d1183 1
a1183 1
	    (*tab->Pushed) (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
a1210 3
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
    PERL_UNUSED_ARG(tab);
d1214 1
a1214 1
	const PerlIOl *l;
d1252 1
a1252 1
	PerlIO_funcs * const tab = PerlIO_layer_fetch(aTHX_ layers, n, NULL);
d1269 1
a1269 1
	PerlIO_list_t * const layers = PerlIO_list_alloc(aTHX);
d1288 3
a1290 4
    PerlIO_debug("PerlIO_binmode f=%p %s %c %x %s\n", (void*)f,
                 (PerlIOBase(f)) ? PerlIOBase(f)->tab->name : "(Null)",
                 iotype, mode, (names) ? names : "(Null)");

d1336 1
a1336 1
	return PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_raw), Nullch, Nullsv) ? TRUE : FALSE;
d1344 1
a1344 1
	PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1359 1
a1359 1
    const int code = PerlIO__close(aTHX_ f);
d1383 1
a1383 1
	    type = SvPV_const(layers, len);
d1438 1
a1438 1
	    PerlIO_funcs * const handler = PerlIO_layer_from_ref(aTHX_ SvRV(arg));
d1451 1
a1451 1
    if (!layers || !*layers)
d1456 1
a1456 1
	    IV i;
d1487 1
a1487 1
	    if (!layers || !*layers)
d1494 1
a1494 1
	PerlIO_list_t *layera;
d1505 1
a1505 1
		SV * const arg = (l->tab->Getarg)
d1523 1
a1523 1
	    PerlIO_funcs * const t = PerlIO_layer_fetch(aTHX_ layera, n, NULL);
d1538 2
a1539 2
			 tab->name, layers ? layers : "(Null)", mode, fd,
			 imode, perm, (void*)f, narg, (void*)args);
d1602 1
a1602 1
	    const PerlIO_funcs *tab = PerlIOBase(f)->tab;
d1702 1
a1702 1
	  const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1718 1
a1718 1
	 const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1734 1
a1734 1
	const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1750 1
a1750 1
	  const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
a1806 2
    PERL_UNUSED_ARG(mode);
    PERL_UNUSED_ARG(arg);
d1817 1
a1817 1
PERLIO_FUNCS_DECL(PerlIO_utf8) = {
a1832 2
    NULL,
    NULL,
d1846 1
a1846 1
PERLIO_FUNCS_DECL(PerlIO_byte) = {
a1861 2
    NULL,
    NULL,
d1880 1
a1880 2
    PerlIO_funcs * const tab = PerlIO_default_btm();
    PERL_UNUSED_ARG(self);
d1888 1
a1888 1
PERLIO_FUNCS_DECL(PerlIO_raw) = {
a1903 2
    NULL,
    NULL,
d1933 1
a1933 1
	const IV flags = PerlIOBase(f)->flags;
d1964 5
a1968 3
    PerlIOl * const l = PerlIOBase(f);
    PERL_UNUSED_ARG(arg);

a2024 1
    PERL_UNUSED_ARG(f);
d2034 3
a2036 2
    const Off_t old = PerlIO_tell(f);
    PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_pending), "r", Nullsv);
d2038 2
a2039 1
    return PerlIOBuf_unread(aTHX_ f, vbuf, count);
a2052 2
	 get_cnt:
	  {
a2062 2
		if (avail == 0)		/* set_ptrcnt could have reset avail */
		    goto get_cnt;
a2067 1
	  }
a2076 1
    PERL_UNUSED_ARG(f);
a2082 1
    PERL_UNUSED_ARG(f);
d2096 1
a2096 1
	    const PerlIO_funcs * const tab = PerlIOBase(n)->tab;
a2164 1
    PERL_UNUSED_ARG(param);
d2172 1
a2172 1
    PerlIO * const nexto = PerlIONext(o);
d2174 1
a2174 1
	const PerlIO_funcs * const tab = PerlIOBase(nexto)->tab;
d2199 1
d2210 1
a2210 1
    MUTEX_INIT(&PerlIO_mutex);
d2267 1
a2267 1
    if (PL_def_layerlist) {
d2351 1
a2351 1
    PerlIOUnix * const s = PerlIOSelf(f, PerlIOUnix);
d2392 2
a2393 2
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
    Off_t new_loc;
d2402 2
a2403 2
    new_loc = PerlLIO_lseek(fd, offset, whence);
    if (new_loc == (Off_t) - 1)
d2421 1
a2428 1
	    const char *path = SvPV_nolen_const(*args);
d2482 1
a2482 5
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
#ifdef PERLIO_STD_SPECIAL
    if (fd == 0)
        return PERLIO_STD_IN(fd, vbuf, count);
#endif
d2488 1
a2488 1
	const SSize_t len = PerlLIO_read(fd, vbuf, count);
a2502 1
    /*NOTREACHED*/
d2508 1
a2508 5
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
#ifdef PERLIO_STD_SPECIAL
    if (fd == 1 || fd == 2)
        return PERLIO_STD_OUT(fd, vbuf, count);
#endif
d2510 1
a2510 1
	const SSize_t len = PerlLIO_write(fd, vbuf, count);
a2520 1
    /*NOTREACHED*/
d2533 1
a2533 1
    const int fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2558 1
a2558 1
PERLIO_FUNCS_DECL(PerlIO_unix) = {
d2621 1
a2621 1
    char * const ret = tmode;
d2639 1
a2639 1
	PerlIO_funcs * const toptab = PerlIOBase(n)->tab;
d2645 1
a2645 1
	    const int fd = PerlIO_fileno(n);
d2678 1
a2678 1
	    const int fd = PerlLIO_dup(fileno(stdio));
d2693 1
a2693 1
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), PERLIO_FUNCS_CAST(&PerlIO_stdio), mode, Nullsv))) {
d2708 1
a2708 1
	const char *path = SvPV_nolen_const(*args);
d2722 1
a2722 1
	    const char *path = SvPV_nolen_const(*args);
d2781 1
d2786 1
a2786 1
		    PerlIOStdio *s = PerlIOSelf(f, PerlIOStdio);
d2805 1
a2805 1
	const int fd = fileno(stdio);
d2808 1
a2808 1
	    const int dfd = PerlLIO_dup(fileno(stdio));
d2833 1
a2833 5
#  if defined(__UCLIBC__)
    /* uClibc must come before glibc because it defines __GLIBC__ as well. */
    f->__filedes = -1;
    return 1;
#  elif defined(__GLIBC__)
a2883 7
#  elif defined(__OpenBSD__)
    /* There may be a better way on OpenBSD:
        - we could insert a dummy func in the _close function entry
	f->_close = (int (*)(void *)) dummy_close;
     */
    f->_file = -1;
    return 1;
a2912 1
    PERL_UNUSED_ARG(f);
d2926 1
a2926 1
        const int fd = fileno(stdio);
d3002 1
a3002 1
	    const int ch = PerlSIO_fgetc(s);
d3056 1
a3056 1
	    const int ch = *--buf & 0xFF;
d3296 1
a3296 1
PERLIO_FUNCS_DECL(PerlIO_stdio) = {
d3361 1
a3361 1
	    if ((f2 = PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_stdio), buf, Nullsv))) {
d3420 1
a3420 1
    const int fd = PerlIO_fileno(f);
d3425 1
a3425 1
	const Off_t posn = PerlIO_tell(PerlIONext(f));
d3498 1
a3498 5
 * read or write state.  For write state, we put the postponed data through
 * the next layers.  For read state, we seek() the next layers to the
 * offset given by current position in the buffer, and discard the buffer
 * state (XXXX supposed to be for seek()able buffers only, but now it is done
 * in any case?).  Then the pass the stick further in chain.
d3510 2
a3511 2
	const STDCHAR *buf = b->buf;
	const STDCHAR *p = buf;
a3556 4
/* This discards the content of the buffer after b->ptr, and rereads
 * the buffer from the position off in the layer downstream; here off
 * is at offset corresponding to b->ptr - b->buf.
 */
d3567 1
a3567 1
    if (PerlIO_flush(f) != 0)	/* XXXX Check that its seek() succeeded?! */
d3626 1
a3627 1
        const PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3698 1
a3698 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3745 1
a3748 1
	    PerlIOBuf *b = PerlIOSelf(f, PerlIOBuf);
d3788 2
a3789 2
    const IV code = PerlIOBase_popped(aTHX_ f);
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3802 2
a3803 2
    const IV code = PerlIOBase_close(aTHX_ f);
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3840 2
a3841 1
	b->buf = Newxz(b->buf,b->bufsiz, STDCHAR);
d3883 1
a3883 1
PERLIO_FUNCS_DECL(PerlIO_perlio) = {
d3976 1
a3976 1
    const IV code = PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
d3998 1
a3998 1
	const SSize_t more =
d4006 1
a4006 1
PERLIO_FUNCS_DECL(PerlIO_pending) = {
a4043 8
 *
 * c->nl points on the first byte of CR LF pair when it is temporarily
 * replaced by LF, or to the last CR of the buffer.  In the former case
 * the caller thinks that the buffer ends at c->nl + 1, in the latter
 * that it ends at c->nl; these two cases can be distinguished by
 * *c->nl.  c->nl is set during _getcnt() call, and unset during
 * _unread() and _flush() calls.
 * It only matters for read operations.
d4088 1
a4088 1
    if (c->nl) {	/* XXXX Shouldn't it be done only if b->ptr > c->nl? */
d4118 2
a4119 4
		    /* If b->ptr - 1 == b->buf, we are undoing reading 0xa */
			*--(b->ptr) = 0xa;	/* Works even if 0xa == '\r' */
			unread++;
			count--;
a4132 1
/* XXXX This code assumes that buffer size >=2, but does not check it... */
d4337 1
a4337 1
PERLIO_FUNCS_DECL(PerlIO_crlf) = {
d4349 2
a4350 1
    PerlIOBuf_read,             /* generic read works with ptr/cnt lies */
d4387 2
a4388 2
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    const IV flags = PerlIOBase(f)->flags;
d4394 1
a4394 1
	const int fd = PerlIO_fileno(f);
d4566 2
a4567 3
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;

d4654 1
a4654 1
PERLIO_FUNCS_DECL(PerlIO_mmap) = {
d4720 1
a4721 1
    char *name = NULL;
a4731 1
    return name;
a4732 2
    PERL_UNUSED_ARG(f);
    PERL_UNUSED_ARG(buf);
a4733 1
    return Nullch;
d4735 1
d4777 2
a4778 1
    if ( 1 == PerlIO_read(f, buf, 1) ) {
d4830 1
a4830 1
    const char *s;
d4840 1
a4840 1
    s = SvPV_const(sv, len);
d4877 1
d4879 1
a4879 1
     const int fd = win32_tmpfd();
d4885 1
d4889 1
a4889 1
     const int fd = mkstemp(SvPVX(sv));
d4894 1
a4894 1
	  PerlLIO_unlink(SvPVX_const(sv));
d4902 1
a4902 2
                               PERLIO_FUNCS_CAST(&PerlIO_stdio),
			       "w+", Nullsv))) {
d5015 1
a5015 1
    const int val = vsprintf(s, fmt, ap);
d5041 7
a5047 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d2 3
a4 6
 * perlio.c
 * Copyright (c) 1996-2006, Nick Ing-Simmons
 * Copyright (c) 2006, 2007, Larry Wall and others
 *
 * You may distribute under the terms of either the GNU General Public License
 * or the Artistic License, as specified in the README file.
d33 1
a33 5
#   ifndef USE_CROSS_COMPILE
#       include "config.h"
#   else
#       include "xconfig.h"
#   endif
d59 2
a114 5
#if defined(__osf__) && _XOPEN_SOURCE < 500
extern int   fseeko(FILE *, off_t, int);
extern off_t ftello(FILE *);
#endif

a115 3

EXTERN_C int perlsio_binmode(FILE *fp, int iotype, int mode);

a123 1
    PERL_UNUSED_ARG(iotype);
d125 5
a129 5
        if (mode & O_BINARY)
            ((FILE *) fp)->_flag |= _IOBIN;
        else
            ((FILE *) fp)->_flag &= ~_IOBIN;
        return 1;
a133 1
    PERL_UNUSED_ARG(iotype);
d140 12
a151 15
        /*
         * The translation mode of the stream is maintained independent 
of
         * the translation mode of the fd in the Borland RTL (heavy
         * digging through their runtime sources reveal).  User has to 
set
         * the mode explicitly for the stream (though they don't 
document
         * this anywhere). GSAR 97-5-24
         */
        fseek(fp, 0L, 0);
        if (mode & O_BINARY)
            fp->flags |= _F_BIN;
        else
            fp->flags &= ~_F_BIN;
d153 1
a153 1
        return 1;
d156 1
a156 1
        return 0;
a160 3
#    if defined(__CYGWIN__)
    PERL_UNUSED_ARG(iotype);
#    endif
d162 1
a162 1
        return 1;
d164 1
a164 1
        return 0;
d263 1
a263 1
#if defined(PERL_MICRO) || defined(__SYMBIAN32__)
d276 1
d278 1
a278 3
	    const int omode = djgpp_get_stream_mode(f);
#else
	    const int omode = fcntl(fd, F_GETFL);
d337 1
a337 1
	const char * const name = SvPV_nolen_const(ST(1));
a358 1
    PERL_UNUSED_CONTEXT;
a395 1
    PERL_UNUSED_CONTEXT;
d457 1
d461 6
a466 13
    if (!PL_perlio_debug_fd) {
	if (!PL_tainting && PL_uid == PL_euid && PL_gid == PL_egid) {
	    const char * const s = PerlEnv_getenv("PERLIO_DEBUG");
	    if (s && *s)
		PL_perlio_debug_fd
		    = PerlLIO_open3(s, O_WRONLY | O_CREAT | O_APPEND, 0666);
	    else
		PL_perlio_debug_fd = -1;
	} else {
	    /* tainting or set*id, so ignore the environment, and ensure we
	       skip these tests next time through.  */
	    PL_perlio_debug_fd = -1;
	}
d468 1
a468 1
    if (PL_perlio_debug_fd > 0) {
d470 2
a472 1
	const char * const s = CopFILE(PL_curcop);
d475 5
a479 3
	const STRLEN len1 = my_snprintf(buffer, sizeof(buffer), "%.40s:%" IVdf " ", s ? s : "(none)", (IV) CopLINE(PL_curcop));
	const STRLEN len2 = my_vsnprintf(buffer + len1, sizeof(buffer) - len1, fmt, ap);
	PerlLIO_write(PL_perlio_debug_fd, buffer, len1 + len2);
d481 5
a485 4
	const char *s = CopFILE(PL_curcop);
	STRLEN len;
	SV * const sv = Perl_newSVpvf(aTHX_ "%s:%" IVdf " ", s ? s : "(none)",
				      (IV) CopLINE(PL_curcop));
d489 1
a489 1
	PerlLIO_write(PL_perlio_debug_fd, s, len);
a509 1
    dVAR;
d555 1
a555 1
    PerlIO * const table = *tablep;
d560 1
a560 1
	    PerlIO * const f = table + i;
a574 1
    PERL_UNUSED_CONTEXT;
a600 1
    dVAR;
a601 2
    PERL_UNUSED_CONTEXT;

d612 1
a612 1
	SvREFCNT_inc_simple_void_NN(arg);
d619 1
a619 1
    PerlIO_list_t *list = NULL;
d624 3
a626 7
	    SV *arg = proto->array[i].arg;
#ifdef sv_dup
	    if (arg && param)
		arg = sv_dup(arg, param);
#else
	    PERL_UNUSED_ARG(param);
#endif
d643 1
a643 1
    PerlIO_debug("Clone %p from %p\n",(void*)aTHX,(void*)proto);
a654 1
    PERL_UNUSED_CONTEXT;
a662 1
    dVAR;
d666 1
a666 1
    PerlIO_debug("Destruct %p\n",(void*)aTHX);
d673 1
a673 1
	    const PerlIOl *l;
d692 1
a692 1
    const PerlIOl *l = *f;
d718 1
a718 2
    dVAR;
    AV * const av = newAV();
d720 2
a721 2
    if (PerlIOValid(f)) {
	PerlIOl *l = PerlIOBase(f);
d723 11
a733 11
	while (l) {
	    SV * const name = l->tab && l->tab->name ?
	    newSVpv(l->tab->name, 0) : &PL_sv_undef;
	    SV * const arg = l->tab && l->tab->Getarg ?
	    (*l->tab->Getarg)(aTHX_ &l, 0, 0) : &PL_sv_undef;
	    av_push(av, name);
	    av_push(av, arg);
	    av_push(av, newSViv((IV)l->flags));
	    l = l->next;
	}
    }
d735 1
a735 1
    return av;
a745 1
    dVAR;
d762 1
a762 1
	    SV * const pkgsv = newSVpvs("PerlIO");
d764 1
a764 1
	    CV * const cv    = Perl_get_cvn_flags(aTHX_ STR_WITH_LEN("PerlIO::Layer::NoWarnings"), 0);
d769 2
a770 1
		PL_warnhook = (SV *) (SvREFCNT_inc_simple_NN(cv));
d776 1
a776 1
	    Perl_load_module(aTHX_ 0, pkgsv, NULL, layer, NULL);
d792 4
a795 5
	IO * const io = GvIOn((GV *) SvRV(sv));
	PerlIO * const ifp = IoIFP(io);
	PerlIO * const ofp = IoOFP(io);
	Perl_warn(aTHX_ "set %" SVf " %p %p %p",
		  SVfARG(sv), (void*)io, (void*)ifp, (void*)ofp);
d804 4
a807 5
	IO * const io = GvIOn((GV *) SvRV(sv));
	PerlIO * const ifp = IoIFP(io);
	PerlIO * const ofp = IoOFP(io);
	Perl_warn(aTHX_ "get %" SVf " %p %p %p",
		  SVfARG(sv), (void*)io, (void*)ifp, (void*)ofp);
d815 1
a815 1
    Perl_warn(aTHX_ "clear %" SVf, SVfARG(sv));
d822 1
a822 1
    Perl_warn(aTHX_ "free %" SVf, SVfARG(sv));
d837 2
a838 2
    SV * const sv = SvRV(ST(1));
    AV * const av = newAV();
d847 1
a847 1
    Perl_warn(aTHX_ "attrib %" SVf, SVfARG(sv));
d850 2
a851 2
	const char * const name = SvPV_const(ST(i), len);
	SV * const layer = PerlIO_find_layer(aTHX_ name, len, 1);
d853 1
a853 1
	    av_push(av, SvREFCNT_inc_simple_NN(layer));
d869 1
a869 1
    HV * const stash = gv_stashpvs("PerlIO::Layer", GV_ADD);
a878 1
    dVAR;
a879 1
    PERL_UNUSED_ARG(cv);
a886 1
    dVAR;
a887 1
    PERL_UNUSED_ARG(cv);
a904 1
    dVAR;
d907 1
a907 1
    PerlIO_list_push(aTHX_ PL_known_layers, tab, NULL);
a913 1
    dVAR;
d922 1
a922 1
		const char *as = NULL;
a984 3
			SV *arg = NULL;
			if (as)
			    arg = newSVpvn(as, alen);
d986 3
a988 3
					 (arg) ? arg : &PL_sv_undef);
			if (arg)
			    SvREFCNT_dec(arg);
a1006 1
    dVAR;
a1085 1
    dVAR;
d1087 1
a1087 1
	const char * const s = (PL_tainting) ? NULL : PerlEnv_getenv("PERLIO");
a1136 1
    dVAR;
a1148 1
    dVAR;
d1170 12
a1181 17
	if (f) {
	    char *temp;
	    Newxz(temp, tab->size, char);
	    l = (PerlIOl*)temp;
	    if (l) {
		l->next = *f;
		l->tab = (PerlIO_funcs*) tab;
		*f = l;
		PerlIO_debug("PerlIO_push f=%p %s %s %p\n",
			     (void*)f, tab->name,
			     (mode) ? mode : "(Null)", (void*)arg);
		if (*l->tab->Pushed &&
		    (*l->tab->Pushed)
		      (aTHX_ f, mode, arg, (PerlIO_funcs*) tab) != 0) {
		    PerlIO_pop(aTHX_ f);
		    return NULL;
		}
a1182 2
	    else
		return NULL;
d1347 1
a1347 1
	return PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_raw), NULL, NULL) ? TRUE : FALSE;
a1379 1
    dVAR;
d1383 25
a1411 1
    dVAR;
d1415 2
a1416 8
    if (SvTYPE(sv) < SVt_PVAV) {
	PerlIO_funcs *f = PerlIO_find_layer(aTHX_ STR_WITH_LEN("scalar"), 1);
	/* This isn't supposed to happen, since PerlIO::scalar is core,
	 * but could happen anyway in smaller installs or with PAR */
	if (!f && ckWARN(WARN_LAYER))
	    Perl_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"scalar\"");
	return f;
    }
d1423 1
a1423 1
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Array"), 0);
d1425 1
a1425 1
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Hash"), 0);
d1427 1
a1427 1
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Code"), 0);
d1429 1
a1429 3
	return PerlIO_find_layer(aTHX_ STR_WITH_LEN("Glob"), 0);
    default:
	return NULL;
d1431 1
a1437 1
    dVAR;
d1443 1
a1443 1
	SV * const arg = *args;
d1463 1
a1463 1
	layers = Perl_PerlIO_context_layers(aTHX_ mode);
d1467 6
a1472 1
	    av = PerlIO_clone_list(aTHX_ def, NULL);
d1482 1
a1482 1
	    return NULL;
a1495 1
    dVAR;
d1499 1
a1499 1
		layers = Perl_PerlIO_context_layers(aTHX_ mode);
d1516 4
a1519 7
		SV *arg = NULL;
		if (l->tab->Getarg)
		    arg = (*l->tab->Getarg) (aTHX_ &l, NULL, 0);
		PerlIO_list_push(aTHX_ layera, l->tab,
				 (arg) ? arg : &PL_sv_undef);
		if (arg)
		    SvREFCNT_dec(arg);
a1610 1
    dVAR;
a1651 1
    dVAR;
a1817 1
    PERL_UNUSED_CONTEXT;
a1984 1
    PERL_UNUSED_CONTEXT;
d2034 1
a2034 1
		 (void*)f, PerlIOBase(f)->tab->name, (omode) ? omode : "(Null)",
a2042 1
    PERL_UNUSED_CONTEXT;
d2054 1
a2054 1
    PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_pending), "r", NULL);
d2075 1
a2075 1
		take = ((SSize_t)count < avail) ? (SSize_t)count : avail;
a2098 1
    PERL_UNUSED_CONTEXT;
a2105 1
    PERL_UNUSED_CONTEXT;
a2141 1
    PERL_UNUSED_CONTEXT;
a2150 1
    PERL_UNUSED_CONTEXT;
d2161 1
a2161 1
	PerlIO * const n = PerlIONext(f);
a2170 1
    PERL_UNUSED_CONTEXT;
d2180 1
a2180 1
	return NULL;
d2183 1
a2183 3
	arg = sv_dup(arg, param);
	SvREFCNT_inc_simple_void_NN(arg);
	return arg;
d2206 2
a2207 2
	PerlIO_funcs * const self = PerlIOBase(o)->tab;
	SV *arg = NULL;
d2213 3
d2217 1
a2217 3
	if (PerlIOBase(o)->flags & PERLIO_F_UTF8)
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	if (arg)
d2219 1
d2224 2
a2225 26
/* PL_perlio_fd_refcnt[] is in intrpvar.h */

/* Must be called with PL_perlio_mutex locked. */
static void
S_more_refcounted_fds(pTHX_ const int new_fd) {
    dVAR;
    const int old_max = PL_perlio_fd_refcnt_size;
    const int new_max = 16 + (new_fd & ~15);
    int *new_array;

    PerlIO_debug("More fds - old=%d, need %d, new=%d\n",
		 old_max, new_fd, new_max);

    if (new_fd < old_max) {
	return;
    }

    assert (new_max > new_fd);

    /* Use plain realloc() since we need this memory to be really
     * global and visible to all the interpreters and/or threads. */
    new_array = (int*) realloc(PL_perlio_fd_refcnt, new_max * sizeof(int));

    if (!new_array) {
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
d2227 1
a2227 16
	/* Can't use PerlIO to write as it allocates memory */
	PerlLIO_write(PerlIO_fileno(Perl_error_log),
		      PL_no_mem, strlen(PL_no_mem));
	my_exit(1);
    }

    PL_perlio_fd_refcnt_size = new_max;
    PL_perlio_fd_refcnt = new_array;

    PerlIO_debug("Zeroing %p, %d\n",
		 (void*)(new_array + old_max),
		 new_max - old_max);

    Zero(new_array + old_max, new_max - old_max, int);
}

d2232 4
a2235 2
    /* MUTEX_INIT(&PL_perlio_mutex) is done in PERL_SYS_INIT3(). */
    PERL_UNUSED_CONTEXT;
d2241 8
a2248 6
    dTHX;
    if (fd >= 0) {
	dVAR;

#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
a2249 16
	if (fd >= PL_perlio_fd_refcnt_size)
	    S_more_refcounted_fds(aTHX_ fd);

	PL_perlio_fd_refcnt[fd]++;
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    Perl_croak(aTHX_ "refcnt_inc: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	PerlIO_debug("refcnt_inc: fd %d refcnt=%d\n",
		     fd, PL_perlio_fd_refcnt[fd]);

#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	Perl_croak(aTHX_ "refcnt_inc: fd %d < 0\n", fd);
a2255 1
    dTHX;
d2257 8
a2264 4
    if (fd >= 0) {
	dVAR;
#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
a2265 15
	if (fd >= PL_perlio_fd_refcnt_size) {
	    Perl_croak(aTHX_ "refcnt_dec: fd %d >= refcnt_size %d\n",
		       fd, PL_perlio_fd_refcnt_size);
	}
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    Perl_croak(aTHX_ "refcnt_dec: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	cnt = --PL_perlio_fd_refcnt[fd];
	PerlIO_debug("refcnt_dec: fd %d refcnt=%d\n", fd, cnt);
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	Perl_croak(aTHX_ "refcnt_dec: fd %d < 0\n", fd);
a2272 1
    dVAR;
d2275 1
a2275 1
    PerlIO_debug("Cleanup layers for %p\n",(void*)aTHX);
a2278 1

d2297 1
a2297 39
void PerlIO_teardown() /* Call only from PERL_SYS_TERM(). */
{
    dVAR;
#if 0
/* XXX we can't rely on an interpreter being present at this late stage,
   XXX so we can't use a function like PerlLIO_write that relies on one
   being present (at least in win32) :-(.
   Disable for now.
*/
#ifdef DEBUGGING
    {
	/* By now all filehandles should have been closed, so any
	 * stray (non-STD-)filehandles indicate *possible* (PerlIO)
	 * errors. */
#define PERLIO_TEARDOWN_MESSAGE_BUF_SIZE 64
#define PERLIO_TEARDOWN_MESSAGE_FD 2
	char buf[PERLIO_TEARDOWN_MESSAGE_BUF_SIZE];
	int i;
	for (i = 3; i < PL_perlio_fd_refcnt_size; i++) {
	    if (PL_perlio_fd_refcnt[i]) {
		const STRLEN len =
		    my_snprintf(buf, sizeof(buf),
				"PerlIO_teardown: fd %d refcnt=%d\n",
				i, PL_perlio_fd_refcnt[i]);
		PerlLIO_write(PERLIO_TEARDOWN_MESSAGE_FD, buf, len);
	    }
	}
    }
#endif
#endif
    /* Not bothering with PL_perlio_mutex since by now
     * all the interpreters are gone. */
    if (PL_perlio_fd_refcnt_size /* Assuming initial size of zero. */
        && PL_perlio_fd_refcnt) {
	free(PL_perlio_fd_refcnt); /* To match realloc() in S_more_refcounted_fds(). */
	PL_perlio_fd_refcnt = NULL;
	PL_perlio_fd_refcnt_size = 0;
    }
}
a2368 1
    PERL_UNUSED_CONTEXT;
a2390 1
    PERL_UNUSED_CONTEXT;
a2417 1
    PERL_UNUSED_CONTEXT;
d2428 3
a2430 1
	return -1;
a2474 1
	    NOOP;
d2486 1
a2486 1
    const PerlIOUnix * const os = PerlIOSelf(o, PerlIOUnix);
d2491 1
a2491 1
    if (fd >= 0) {
a2505 1
    dVAR;
a2536 1
    dVAR;
a2559 2
    PERL_UNUSED_CONTEXT;

a2566 1
    dVAR;
d2644 3
a2646 6
    PERL_UNUSED_CONTEXT;

    if (PerlIOValid(f)) {
	FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;
	if (s)
	    return PerlSIO_fileno(s);
d2727 1
a2727 1
	if ((f = PerlIO_push(aTHX_(f = PerlIO_allocate(aTHX)), PERLIO_FUNCS_CAST(&PerlIO_stdio), mode, NULL))) {
a2729 1
	    PerlIOUnix_refcnt_inc(fileno(stdio));
d2742 2
a2743 2
	const char * const path = SvPV_nolen_const(*args);
	PerlIOStdio * const s = PerlIOSelf(f, PerlIOStdio);
d2756 1
a2756 1
	    const char * const path = SvPV_nolen_const(*args);
d2771 1
d2779 3
a2781 4
			PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
			PerlIOUnix_refcnt_inc(fileno(stdio));
		    } else {
			PerlSIO_fclose(stdio);
d2819 3
a2821 2
		    PerlIOSelf(f, PerlIOStdio)->stdio = stdio;
		    PerlIOUnix_refcnt_inc(fileno(stdio));
a2846 1
		NOOP;
a2862 2
    PERL_UNUSED_CONTEXT;

d2877 25
a2901 2
    PERL_UNUSED_ARG(f);
    return 0;
d2965 1
a2965 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d2972 1
d2984 2
a2985 1
	if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *) &optval, &optlen) == 0)
d2987 1
d2989 2
a2990 1
	if (PerlIOUnix_refcnt_dec(fd) > 0) /* File descriptor still in use */
d2992 2
d2995 10
a3004 5
	    /* For STD* handles, don't close stdio, since we shared the FILE *, too. */
	    if (stdio == stdin) /* Some stdios are buggy fflush-ing inputs */
		return 0;
	    if (stdio == stdout || stdio == stderr)
		return PerlIO_flush(f);
d3011 3
a3013 3
	    invalidate = PerlIOStdio_invalidate_fileno(aTHX_ stdio);
	    if (!invalidate)
		dupfd = PerlLIO_dup(fd);
d3023 4
a3026 4
#ifdef SOCKS5_VERSION_NAME
	/* in SOCKS' case, let close() determine return value */
	result = close(fd);
#endif
d3038 1
a3038 2
    dVAR;
    FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;
d3069 1
a3069 1
    FILE * const s = PerlIOSelf(f, PerlIOStdio)->stdio;
a3125 1
    dVAR;
d3141 1
a3141 3
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

d3148 1
a3148 3
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

d3155 1
a3155 3
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
    PERL_UNUSED_CONTEXT;

a3159 1
	NOOP;
d3170 1
a3170 1
	const int err = errno;
a3180 2
    PERL_UNUSED_CONTEXT;

a3186 2
    PERL_UNUSED_CONTEXT;

a3192 2
    PERL_UNUSED_CONTEXT;

a3198 2
    PERL_UNUSED_CONTEXT;

d3202 1
a3202 1
    PerlSIO_setvbuf(PerlIOSelf(f, PerlIOStdio)->stdio, NULL, _IOLBF, 0);
d3210 1
a3210 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3217 1
a3217 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3226 1
a3226 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3233 1
a3233 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3240 1
a3240 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3243 1
a3243 1
	PerlSIO_set_ptr(stdio, ptr); /* LHS STDCHAR* cast non-portable */
d3281 1
a3281 1
    FILE * const stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
a3282 2
    PERL_UNUSED_CONTEXT;

d3290 3
a3292 9
    for (;;) {
	c = PerlSIO_fgetc(stdio);
	if (c != EOF)
	    break;
	if (! PerlSIO_ferror(stdio) || errno != EINTR)
	    return EOF;
	PERL_ASYNC_CHECK();
	SETERRNO(0,0);
    }
d3406 1
a3406 1
	    if ((f2 = PerlIO_push(aTHX_ f, PERLIO_FUNCS_CAST(&PerlIO_stdio), buf, NULL))) {
a3408 1
		PerlIOUnix_refcnt_inc(fileno(stdio));
a3425 1
    FILE *stdio;
d3434 1
a3434 13
    /* However, we're not really exporting a FILE * to someone else (who
       becomes responsible for closing it, or calling PerlIO_releaseFILE())
       So we need to undo its refernce count increase on the underlying file
       descriptor. We have to do this, because if the loop above returns you
       the FILE *, then *it* didn't increase any reference count. So there's
       only one way to be consistent. */
    stdio = PerlIO_exportFILE(f, NULL);
    if (stdio) {
	const int fd = fileno(stdio);
	if (fd >= 0)
	    PerlIOUnix_refcnt_dec(fd);
    }
    return stdio;
a3440 1
    dVAR;
a3446 3
		const int fd = fileno(f);
		if (fd >= 0)
		    PerlIOUnix_refcnt_dec(fd);
d3527 1
a3527 1
		    PerlIO_binmode(aTHX_ f,  '<'/*not used*/, O_BINARY, NULL);
d3552 1
a3552 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3613 1
a3613 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
a3627 2
    assert(b->buf); /* The b->buf does get allocated via the vtable system. */

d3654 1
a3654 1
	    const SSize_t cnt = avail;
d3680 1
a3680 1
        const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3692 1
a3692 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3811 1
a3811 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3846 2
a3847 1
    b->ptr = b->end = b->buf = NULL;
d3860 2
a3861 1
    b->ptr = b->end = b->buf = NULL;
d3869 1
a3869 1
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3878 1
a3878 1
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3889 1
a3889 3
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    PERL_UNUSED_CONTEXT;

d3898 2
a3899 1
	b->end = b->ptr = b->buf;
d3907 1
a3907 1
    const PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d3916 1
a3916 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4005 1
a4005 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4029 1
a4029 1
    PerlIOl * const l = PerlIOBase(f);
a4111 15
/* Inherit the PERLIO_F_UTF8 flag from previous layer.
 * Otherwise the :crlf layer would always revert back to
 * raw mode.
 */
static void
S_inherit_utf8_flag(PerlIO *f)
{
    PerlIO *g = PerlIONext(f);
    if (PerlIOValid(g)) {
	if (PerlIOBase(g)->flags & PERLIO_F_UTF8) {
	    PerlIOBase(f)->flags |= PERLIO_F_UTF8;
	}
    }
}

d4120 1
a4120 1
		 (void*)f, PerlIOBase(f)->tab->name, (mode) ? mode : "(Null)",
d4129 1
a4129 1
	 while (PerlIOValid(g)) {
a4133 1
		   S_inherit_utf8_flag(g);
a4139 1
    S_inherit_utf8_flag(f);
d4147 1
a4147 1
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
d4169 1
a4169 1
		const int ch = *--buf;
d4199 1
a4199 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4203 1
a4203 1
	PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
d4271 2
a4272 2
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
a4288 1
	NOOP;
d4303 2
a4304 2
		       " nl=%p e=%p for %d", (void*)ptr, (void*)chk,
		       flags, c->nl, b->end, cnt);
d4328 1
a4328 1
	PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4330 1
a4330 1
	const STDCHAR * const ebuf = buf + count;
d4336 1
a4336 1
	    const STDCHAR * const eptr = b->buf + b->bufsiz;
d4358 2
a4359 1
		    *(b->ptr)++ = *buf++;
d4376 1
a4376 1
    PerlIOCrlf * const c = PerlIOSelf(f, PerlIOCrlf);
d4444 2
a4448 1
    dVAR;
d4455 1
a4455 1
	PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4463 37
a4499 3
		if (PL_mmap_page_size <= 0)
		  Perl_croak(aTHX_ "panic: bad pagesize %" IVdf,
			     PL_mmap_page_size);
d4507 1
a4507 1
		posn = (b->posn / PL_mmap_page_size) * PL_mmap_page_size;
d4509 1
a4509 1
		m->mptr = (Mmap_t)mmap(NULL, len, PROT_READ, MAP_SHARED, fd, posn);
d4543 2
a4544 1
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
a4546 1
	PerlIOBuf * const b = &m->base;
d4548 1
a4548 8
	    /* The munmap address argument is tricky: depending on the
	     * standard it is either "void *" or "caddr_t" (which is
	     * usually "char *" (signed or unsigned).  If we cast it
	     * to "void *", those that have it caddr_t and an uptight
	     * C++ compiler, will freak out.  But casting it as char*
	     * should work.  Maybe.  (Using Mmap_t figured out by
	     * Configure doesn't always work, apparently.) */
	    code = munmap((char*)m->mptr, m->len);
d4564 2
a4565 2
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
d4597 2
a4598 2
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
d4655 2
a4656 2
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
d4683 1
a4683 1
    PerlIOBuf * const b = PerlIOSelf(f, PerlIOBuf);
d4697 2
a4698 2
    PerlIOMmap * const m = PerlIOSelf(f, PerlIOMmap);
    PerlIOBuf * const b = &m->base;
a4752 1
    dVAR;
a4761 1
    dVAR;
a4770 1
    dVAR;
d4800 1
a4800 1
    return NULL;
d4816 1
a4816 1
    return PerlIO_openn(aTHX_ NULL, mode, fd, 0, 0, NULL, 0, NULL);
d4824 2
a4825 2
    SV *name = sv_2mortal(newSVpv(path, 0));
    return PerlIO_openn(aTHX_ NULL, mode, -1, 0, 0, NULL, 1, &name);
d4833 2
a4834 2
    SV *name = sv_2mortal(newSVpv(path,0));
    return PerlIO_openn(aTHX_ NULL, mode, -1, 0, 0, f, 1, &name);
d4876 2
a4877 1
    return PerlIO_write(f, s, strlen(s));
d4894 1
a4894 1
    SV * sv;
d4901 1
a4901 1
    sv = vnewSVpvf(fmt, &apc);
d4903 1
a4903 1
    sv = vnewSVpvf(fmt, &ap);
d4948 1
a4948 1
     SV * const sv = newSVpvs("/tmp/PerlIO_XXXXXX");
d4958 1
a4959 1
     SvREFCNT_dec(sv);
d4961 1
a4961 4
     FILE * const stdio = PerlSIO_tmpfile();

     if (stdio)
	  f = PerlIO_fdopen(fileno(stdio), "w+");
d4963 10
a4988 30
const char *
Perl_PerlIO_context_layers(pTHX_ const char *mode)
{
    dVAR;
    const char *direction = NULL;
    SV *layers;
    /*
     * Need to supply default layer info from open.pm
     */

    if (!PL_curcop)
	return NULL;

    if (mode && mode[0] != 'r') {
	if (PL_curcop->cop_hints & HINT_LEXICAL_IO_OUT)
	    direction = "open>";
    } else {
	if (PL_curcop->cop_hints & HINT_LEXICAL_IO_IN)
	    direction = "open<";
    }
    if (!direction)
	return NULL;

    layers = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,
				      0, direction, 5, 0, 0);

    assert(layers);
    return SvOK(layers) ? SvPV_nolen_const(layers) : NULL;
}

d4998 1
a4998 1
	const Off_t * const posn = (Off_t *) SvPV(pos, len);
d5013 1
a5013 1
	Fpos_t * const fpos = (Fpos_t *) SvPV(pos, len);
d5079 8
a5086 7
    dTHX; 
    const int val = my_vsnprintf(s, n > 0 ? n : 0, fmt, ap);
    PERL_UNUSED_CONTEXT;

#ifndef PERL_MY_VSNPRINTF_GUARDED
    if (val < 0 || (n > 0 ? val >= n : 0)) {
	Perl_croak(aTHX_ "panic: my_vsnprintf overflow in PerlIO_vsprintf\n");
a5087 1
#endif
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008 Larry Wall and others
a12 2
 *
 *     [pp.791-792 of _The Lord of the Rings_, V/iii: "The Muster of Rohan"]
d808 1
a808 1
		PL_warnhook = MUTABLE_SV((SvREFCNT_inc_simple_NN(cv)));
d830 1
a830 1
	IO * const io = GvIOn(MUTABLE_GV(SvRV(sv)));
d843 1
a843 1
	IO * const io = GvIOn(MUTABLE_GV(SvRV(sv)));
d882 1
a882 1
    sv_magic(sv, MUTABLE_SV(av), PERL_MAGIC_ext, NULL, 0);
d1293 1
a1293 1
		if ((*l->tab->Binmode)(aTHX_ t) == 0) {
a1624 2
     PERL_ARGS_ASSERT_PERLIO_READ;

a1630 2
     PERL_ARGS_ASSERT_PERLIO_UNREAD;

a1636 2
     PERL_ARGS_ASSERT_PERLIO_WRITE;

d2416 1
a2416 1
void PerlIO_teardown(void) /* Call only from PERL_SYS_TERM(). */
d3023 1
a3023 3
        if(stdio) {
	    PerlIOUnix_refcnt_inc(fileno(stdio));
        }
d3121 2
a3122 5
	int dupfd = -1;
	dSAVEDERRNO;
#ifdef USE_ITHREADS
	dVAR;
#endif
d3133 1
a3133 7
	/* Test for -1, as *BSD stdio (at least) on fclose sets the FILE* such
	   that a subsequent fileno() on it returns -1. Don't want to croak()
	   from within PerlIOUnix_refcnt_dec() if some buggy caller code is
	   trying to close an already closed handle which somehow it still has
	   a reference to. (via.xs, I'm looking at you).  */
	if (fd != -1 && PerlIOUnix_refcnt_dec(fd) > 0) {
	    /* File descriptor still in use */
a3134 1
	}
d3146 1
a3146 1
	    SAVE_ERRNO;
d3148 1
a3148 21
	    if (!invalidate) {
#ifdef USE_ITHREADS
		MUTEX_LOCK(&PL_perlio_mutex);
		/* Right. We need a mutex here because for a brief while we
		   will have the situation that fd is actually closed. Hence if
		   a second thread were to get into this block, its dup() would
		   likely return our fd as its dupfd. (after all, it is closed)
		   Then if we get to the dup2() first, we blat the fd back
		   (messing up its temporary as a side effect) only for it to
		   then close its dupfd (== our fd) in its close(dupfd) */

		/* There is, of course, a race condition, that any other thread
		   trying to input/output/whatever on this fd will be stuffed
		   for the duration of this little manoeuvrer. Perhaps we
		   should hold an IO mutex for the duration of every IO
		   operation if we know that invalidate doesn't work on this
		   platform, but that would suck, and could kill performance.

		   Except that correctness trumps speed.
		   Advice from klortho #11912. */
#endif
a3149 11
#ifdef USE_ITHREADS
		if (dupfd < 0) {
		    MUTEX_UNLOCK(&PL_perlio_mutex);
		    /* Oh cXap. This isn't going to go well. Not sure if we can
		       recover from here, or if closing this particular FILE *
		       is a good idea now.  */
		}
#endif
	    }
	} else {
	    SAVE_ERRNO;   /* This is here only to silence compiler warnings */
d3156 1
a3156 1
	    RESTORE_ERRNO;
d3163 1
a3163 1
	if (dupfd >= 0) {
a3165 3
#ifdef USE_ITHREADS
	    MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
d3315 1
a3315 1
	dSAVE_ERRNO;
d3317 1
a3317 1
	    RESTORE_ERRNO;
d3398 3
a3400 1
	assert(PerlSIO_get_cnt(stdio) == (cnt));
a4096 3
#ifndef DEBUGGING
    PERL_UNUSED_ARG(cnt);
#endif
d4100 4
a4103 2
    assert(PerlIO_get_cnt(f) == cnt);
    assert(b->ptr >= b->buf);
d4589 3
a4591 1
	PerlIO_pop(aTHX_ f);
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d138 1
a138 1
#  if defined(atarist)
d617 4
a620 2
		for (i = 0; i < list->cur; i++)
		    SvREFCNT_dec(list->array[i].arg);
a763 5
	    /* There is some collusion in the implementation of
	       XS_PerlIO_get_layers - it knows that name and flags are
	       generated as fresh SVs here, and takes advantage of that to
	       "copy" them by taking a reference. If it changes here, it needs
	       to change there too.  */
d805 1
a805 1
	    CV * const cv    = get_cvs("PerlIO::Layer::NoWarnings", 0);
d979 4
a982 3
		    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER),
				   "Invalid separator character %c%c%c in PerlIO layer specification %s",
				   q, *s, q, s);
d1016 4
a1019 3
			    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER),
					   "Argument list not closed for PerlIO layer \"%.*s\"",
					   (int) (e - s), s);
d1038 2
a1039 1
			SvREFCNT_dec(arg);
d1042 3
a1044 2
			Perl_ck_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"%.*s\"",
				       (int) llen, s);
d1458 2
a1459 2
	if (!f)
	    Perl_ck_warner(aTHX_ packWARN(WARN_LAYER), "Unknown PerlIO layer \"scalar\"");
d1564 2
a1565 1
		SvREFCNT_dec(arg);
d1771 1
d1773 2
d1782 2
a1783 3
    if (PerlIOValid(f)) {
	 if (PerlIOBase(f)->flags & PERLIO_F_FASTGETS) {
	     const PerlIO_funcs * const tab = PerlIOBase(f)->tab;
d1785 3
a1787 3
	     if (tab)
		  return (tab->Set_ptrcnt != NULL);
	 }
d1789 2
d1803 1
d1805 2
d1819 1
d1821 2
d2280 2
a2281 1
	SvREFCNT_dec(arg);
d4126 1
a4126 1
	Newxz(b->buf,b->bufsiz, STDCHAR);
d5170 1
a5170 4
     int fd = -1;
     char tempname[] = "/tmp/PerlIO_XXXXXX";
     const char * const tmpdir = PL_tainting ? NULL : PerlEnv_getenv("TMPDIR");
     SV * sv;
d5174 1
a5174 11
     if (tmpdir && *tmpdir) {
	 /* if TMPDIR is set and not empty, we try that first */
	 sv = newSVpv(tmpdir, 0);
	 sv_catpv(sv, tempname + 4);
	 fd = mkstemp(SvPVX(sv));
     }
     if (fd < 0) {
	 sv = NULL;
	 /* else we try /tmp */
	 fd = mkstemp(tempname);
     }
d5179 1
a5179 1
	  PerlLIO_unlink(sv ? SvPVX_const(sv) : tempname);
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007, 2008, 2009, 2010, 2011 Larry Wall and others
a72 2
#define PerlIO_lockcnt(f) (((PerlIOl*)(f))->head->flags)

d156 17
d469 11
d487 1
a487 3
	if (!PL_tainting &&
	    PerlProc_getuid() == PerlProc_geteuid() &&
	    PerlProc_getgid() == PerlProc_getegid()) {
a529 26
/* check that the head field of each layer points back to the head */

#ifdef DEBUGGING
#  define VERIFY_HEAD(f) PerlIO_verify_head(aTHX_ f)
static void
PerlIO_verify_head(pTHX_ PerlIO *f)
{
    PerlIOl *head, *p;
    int seen = 0;
    if (!PerlIOValid(f))
	return;
    p = head = PerlIOBase(f)->head;
    assert(p);
    do {
	assert(p->head == head);
	if (p == (PerlIOl*)f)
	    seen = 1;
	p = p->next;
    } while (p);
    assert(seen);
}
#else
#  define VERIFY_HEAD(f)
#endif


a534 10
static void
PerlIO_init_table(pTHX)
{
    if (PL_perlio)
	return;
    Newxz(PL_perlio, PERLIO_TABLE_SIZE, PerlIOl);
}



d542 2
a543 2
    PerlIOl **last;
    PerlIOl *f;
d547 1
a547 1
	last = (PerlIOl **) (f);
d549 2
a550 5
	    if (!((++f)->next)) {
		f->flags = 0; /* lockcnt */
		f->tab = NULL;
		f->head = f;
		return (PerlIO *)f;
d554 1
a554 1
    Newxz(f,PERLIO_TABLE_SIZE,PerlIOl);
d558 2
a559 5
    *last = (PerlIOl*) f++;
    f->flags = 0; /* lockcnt */
    f->tab = NULL;
    f->head = f;
    return (PerlIO*) f;
d582 1
a582 1
PerlIO_cleantable(pTHX_ PerlIOl **tablep)
d584 1
a584 1
    PerlIOl * const table = *tablep;
d587 1
a587 1
	PerlIO_cleantable(aTHX_(PerlIOl **) & (table[0]));
d589 3
a591 3
	    PerlIOl * const f = table + i;
	    if (f->next) {
		PerlIO_close(&(f->next));
d672 2
a673 2
    PerlIOl **table = &proto->Iperlio;
    PerlIOl *f;
d677 1
a677 1
    PerlIO_init_table(aTHX);
d681 1
a681 1
	    table = (PerlIOl **) (f++);
d683 2
a684 2
		if (f->next) {
		    (void) fp_dup(&(f->next), 0, param);
d700 2
a701 2
    PerlIOl **table = &PL_perlio;
    PerlIOl *f;
d707 1
a707 1
	table = (PerlIOl **) (f++);
d709 1
a709 1
	    PerlIO *x = &(f->next);
d712 1
a712 1
		if (l->tab && l->tab->kind & PERLIO_K_DESTRUCT) {
a729 1
    VERIFY_HEAD(f);
d731 2
a732 3
	PerlIO_debug("PerlIO_pop f=%p %s\n", (void*)f,
			    l->tab ? l->tab->name : "(Null)");
	if (l->tab && l->tab->Popped) {
d741 2
a742 10
	if (PerlIO_lockcnt(f)) {
	    /* we're in use; defer freeing the structure */
	    PerlIOBase(f)->flags = PERLIO_F_CLEARED;
	    PerlIOBase(f)->tab = NULL;
	}
	else {
	    *f = l->next;
	    Safefree(l);
	}

d810 1
a810 1
	    SAVEBOOL(PL_in_load_module);
d815 1
a815 1
	    PL_in_load_module = TRUE;
d820 1
d921 1
a921 1
    /* This is used as a %SIG{__WARN__} handler to suppress warnings
d1110 1
a1110 1
    PerlIOBase_open,
d1153 3
d1204 1
a1204 1
	PerlIO_init_table(aTHX);
a1213 1
    VERIFY_HEAD(f);
d1215 2
a1216 4
	Perl_croak( aTHX_
	    "%s (%"UVuf") does not match %s (%"UVuf")",
	    "PerlIO layer function table size", (UV)tab->fsize,
	    "size expected by this perl", (UV)sizeof(PerlIO_funcs) );
d1221 1
a1221 4
	    Perl_croak( aTHX_
		"%s (%"UVuf") smaller than %s (%"UVuf")",
		"PerlIO layer instance size", (UV)tab->size,
		"size expected by this perl", (UV)sizeof(PerlIOl) );
a1230 1
		l->head = ((PerlIOl*)f)->head;
a1257 18
PerlIO *
PerlIOBase_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers,
	       IV n, const char *mode, int fd, int imode, int perm,
	       PerlIO *old, int narg, SV **args)
{
    PerlIO_funcs * const tab = PerlIO_layer_fetch(aTHX_ layers, n - 1, PerlIO_default_layer(aTHX_ 0));
    if (tab && tab->Open) {
	PerlIO* ret = (*tab->Open)(aTHX_ tab, layers, n - 1, mode, fd, imode, perm, old, narg, args);
	if (ret && PerlIO_push(aTHX_ ret, self, mode, PerlIOArg) == NULL) {
	    PerlIO_close(ret);
	    return NULL;
	}
	return ret;
    }
    SETERRNO(EINVAL, LIB_INVARG);
    return NULL;
}

d1263 1
a1263 1
	if (PerlIOBase(f)->tab && PerlIOBase(f)->tab->kind & PERLIO_K_RAW) {
d1292 1
a1292 1
	    if (l->tab && l->tab->Binmode) {
d1310 1
a1310 2
	    PerlIO_debug(":raw f=%p :%s\n", (void*)f,
		PerlIOBase(f)->tab ? PerlIOBase(f)->tab->name : "(Null)");
a1338 2
    ENTER;
    save_scalar(PL_errgv);
a1346 1
    LEAVE;
d1360 1
a1360 2
                 (PerlIOBase(f) && PerlIOBase(f)->tab) ?
		       	PerlIOBase(f)->tab->name : "(Null)",
d1387 1
a1387 3
		if (PerlIOBase(f)->tab &&
		    PerlIOBase(f)->tab->kind & PERLIO_K_CANCRLF)
		{
a1433 3
	if (PerlIO_lockcnt(f))
	    /* we're in use; the 'pop' deferred freeing the structure */
	    f = PerlIONext(f);
d1453 1
a1453 1
    if (SvTYPE(sv) < SVt_PVAV && (!isGV_with_GP(sv) || SvFAKE(sv))) {
a1457 1
	    /* diag_listed_as: Unknown PerlIO layer "%s" */
d1559 1
a1559 1
		if (l->tab && l->tab->Getarg)
d1680 1
a1680 1
	 * erroneous input? Maybe some magical value (PerlIO*
d1685 1
a1685 2
	PerlIOl **table = &PL_perlio;
	PerlIOl *ff;
d1687 1
a1687 1
	while ((ff = *table)) {
d1689 1
a1689 1
	    table = (PerlIOl **) (ff++);
d1691 1
a1691 1
		if (ff->next && PerlIO_flush(&(ff->next)) != 0)
d1693 1
a1693 1
		ff++;
d1704 2
a1705 2
    PerlIOl **table = &PL_perlio;
    PerlIOl *f;
d1708 1
a1708 1
	table = (PerlIOl **) (f++);
d1710 2
a1711 2
	    if (f->next
		&& (PerlIOBase(&(f->next))->
d1714 1
a1714 1
		PerlIO_flush(&(f->next));
d1864 1
a1864 1
	if (tab && tab->kind & PERLIO_K_UTF8)
d1877 1
a1877 1
    PERLIO_K_DUMMY | PERLIO_K_UTF8 | PERLIO_K_MULTIARG,
d1880 1
a1880 1
    PerlIOBase_open,
d1908 1
a1908 1
    PERLIO_K_DUMMY | PERLIO_K_MULTIARG,
d1911 1
a1911 1
    PerlIOBase_open,
d1935 14
d1956 1
a1956 1
    PerlIOBase_open,
d2033 1
a2033 1
    if (tab && tab->Set_ptrcnt != NULL)
d2120 1
a2120 1
		take = (((SSize_t) count >= 0) && ((SSize_t)count < avail)) ? (SSize_t)count : avail;
d2262 2
a2263 3
		     self ? self->name : "(Null)",
		     (void*)f, (void*)o, (void*)param);
	if (self && self->Getarg)
a2338 1
	    /* diag_listed_as: refcnt_inc: fd %d%s */
a2348 1
	/* diag_listed_as: refcnt_inc: fd %d%s */
a2363 1
	    /* diag_listed_as: refcnt_dec: fd %d%s */
a2367 1
	    /* diag_listed_as: refcnt_dec: fd %d%s */
a2376 1
	/* diag_listed_as: refcnt_dec: fd %d%s */
a2381 31
int
PerlIOUnix_refcnt(int fd)
{
    dTHX;
    int cnt = 0;
    if (fd >= 0) {
	dVAR;
#ifdef USE_ITHREADS
	MUTEX_LOCK(&PL_perlio_mutex);
#endif
	if (fd >= PL_perlio_fd_refcnt_size) {
	    /* diag_listed_as: refcnt: fd %d%s */
	    Perl_croak(aTHX_ "refcnt: fd %d >= refcnt_size %d\n",
		       fd, PL_perlio_fd_refcnt_size);
	}
	if (PL_perlio_fd_refcnt[fd] <= 0) {
	    /* diag_listed_as: refcnt: fd %d%s */
	    Perl_croak(aTHX_ "refcnt: fd %d: %d <= 0\n",
		       fd, PL_perlio_fd_refcnt[fd]);
	}
	cnt = PL_perlio_fd_refcnt[fd];
#ifdef USE_ITHREADS
	MUTEX_UNLOCK(&PL_perlio_mutex);
#endif
    } else {
	/* diag_listed_as: refcnt: fd %d%s */
	Perl_croak(aTHX_ "refcnt: fd %d < 0\n", fd);
    }
    return cnt;
}

a2461 35
static void
S_lockcnt_dec(pTHX_ const void* f)
{
    PerlIO_lockcnt((PerlIO*)f)--;
}


/* call the signal handler, and if that handler happens to clear
 * this handle, free what we can and return true */

static bool
S_perlio_async_run(pTHX_ PerlIO* f) {
    ENTER;
    SAVEDESTRUCTOR_X(S_lockcnt_dec, (void*)f);
    PerlIO_lockcnt(f)++;
    PERL_ASYNC_CHECK();
    if ( !(PerlIOBase(f)->flags & PERLIO_F_CLEARED) ) {
	LEAVE;
	return 0;
    }
    /* we've just run some perl-level code that could have done
     * anything, including closing the file or clearing this layer.
     * If so, free any lower layers that have already been
     * cleared, then return an error. */
    while (PerlIOValid(f) &&
	    (PerlIOBase(f)->flags & PERLIO_F_CLEARED))
    {
	const PerlIOl *l = *f;
	*f = l->next;
	Safefree(l);
    }
    LEAVE;
    return 1;
}

d2594 1
a2594 1
	if (PerlIOBase(f)->tab && PerlIOBase(f)->flags & PERLIO_F_OPEN)
a2601 3
#ifdef VMS
	    perm = 0777; /* preserve RMS defaults, ACL inheritance, etc. */
#else
a2602 1
#endif
d2661 1
a2661 4
    int fd;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2684 1
a2684 3
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
d2693 1
a2693 4
    int fd;
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    fd = PerlIOSelf(f, PerlIOUnix)->fd;
d2708 1
a2708 3
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
d2743 1
a2743 3
	/* EINTR */
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
d3084 3
a3086 1
#    if defined(UNDER_CE)
d3216 1
a3216 1
    FILE * s;
a3217 3
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    s = PerlIOSelf(f, PerlIOStdio)->stdio;
d3237 1
a3237 2
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
a3305 2
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
d3311 1
a3311 2
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
d3473 1
a3473 1
    FILE * stdio;
a3475 3
    if (PerlIO_lockcnt(f)) /* in use: abort ungracefully */
	return -1;
    stdio = PerlIOSelf(f, PerlIOStdio)->stdio;
d3490 1
a3490 2
	if (PL_sig_pending && S_perlio_async_run(aTHX_ f))
	    return -1;
d3638 1
a3638 1
       So we need to undo its reference count increase on the underlying file
a3752 16
#ifdef VMS
#include <rms.h>
		/* Enable line buffering with record-oriented regular files
		 * so we don't introduce an extraneous record boundary when
		 * the buffer fills up.
		 */
		if (PerlIOBase(f)->flags & PERLIO_F_CANWRITE) {
		    Stat_t st;
		    if (PerlLIO_fstat(fd, &st) == 0
		        && S_ISREG(st.st_mode)
		        && (st.st_fab_rfm == FAB$C_VAR 
			    || st.st_fab_rfm == FAB$C_VFC)) {
			PerlIOBase(f)->flags |= PERLIO_F_LINEBUF;
		    }
		}
#endif
d3941 1
a3941 1
	if ((SSize_t) count >= 0 && avail > (SSize_t) count) {
d3991 1
a3991 1
	if ((SSize_t) count >= 0 && (SSize_t) count < avail)
d4006 1
a4006 2
	    if (PerlIO_flush(f) == -1)
		return -1;
d4112 1
a4112 1
	    b->bufsiz = PERLIOBUF_DEFAULT_BUFSIZ;
d4265 1
a4265 1
    if ((SSize_t) count >= 0 && (SSize_t)count < avail)
d4359 4
a4362 2
      /* If the old top layer is a CRLF layer, reactivate it (if
       * necessary) and remove this new layer from the stack */
d4364 1
a4364 1
	 if (PerlIOValid(g)) {
d4372 2
a4373 1
	      }
d4516 1
a4516 1
		/* Deferred CR at end of buffer case - we lied about count */
d4534 1
a4534 1
	  /* Deferred CR at end of buffer case - we lied about count */
d4666 291
d4964 1
a4964 1
    return (PerlIO*)&PL_perlio[1];
d4974 1
a4974 1
    return (PerlIO*)&PL_perlio[2];
d4984 1
a4984 1
    return (PerlIO*)&PL_perlio[3];
d5160 1
a5160 1
     SV * sv = NULL;
d5227 2
a5228 1
    layers = cop_hints_fetch_pvn(PL_curcop, direction, 5, 0, 0);
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a72 4
#ifdef VMS
#include <rms.h>
#endif

d140 11
d162 1
d461 1
a461 1
	if (!TAINTING_get &&
d477 1
d823 1
a823 2
        const STRLEN this_len = strlen(f->name);
        if (this_len == len && memEQ(f->name, name, len)) {
d1017 1
a1017 1
		} while (isWORDCHAR(*e));
d1166 1
a1166 1
	const char * const s = TAINTING_get ? NULL : PerlEnv_getenv("PERLIO");
d2314 1
a2314 1
	if (f && PerlIOBase(o)->flags & PERLIO_F_UTF8)
d2348 4
a2351 1
	croak_no_mem();
d2406 1
d2415 1
a2415 1
	    Perl_croak_nocontext("refcnt_dec: fd %d >= refcnt_size %d\n",
d2420 1
a2420 1
	    Perl_croak_nocontext("refcnt_dec: fd %d: %d <= 0\n",
d2430 1
a2430 1
	Perl_croak_nocontext("refcnt_dec: fd %d < 0\n", fd);
d2626 4
a2629 9
    else {
#ifdef PERLIO_USING_CRLF
	/*
	 * If neither "t" nor "b" was specified, open the file
	 * in O_BINARY mode.
	 */
	oflags |= O_BINARY;
#endif
    }
d3804 2
a3805 1
	    if (s->stdio == f) { /* not in a loop */
d3809 1
a3809 4
		{
		    dTHX;
		    PerlIO_pop(aTHX_ p);
		}
d3898 1
a4585 2
        if (count > 0)
            unread += PerlIOBase_unread(aTHX_ f, (const STDCHAR *) vbuf + unread, count);
d4859 1
a4860 1
    dTHX;
d4876 1
a4876 1
    Perl_croak_nocontext("Don't know how to get file name");
a5015 1
#ifndef WIN32
a5016 1
#endif
d5026 1
a5026 1
     const char * const tmpdir = TAINTING_get ? NULL : PerlEnv_getenv("TMPDIR");
d5106 1
a5108 1
	dTHX;
d5220 1
a5220 1
 * indent-tabs-mode: nil
d5223 1
a5223 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d34 11
d46 5
d133 1
a133 2
#define NATIVE_0xd  CR_NATIVE
#define NATIVE_0xa  LF_NATIVE
d173 1
d250 6
d257 1
d312 1
a312 5
            STRLEN len;
	    const char *name = SvPV_const(*args, len);
            if (!IS_SAFE_PATHNAME(name, len, "open"))
                return NULL;

a331 1
XS(XS_PerlIO__Layer__find); /* prototype to pass -Wmissing-prototypes */
d378 61
d475 1
a475 1
	PERL_UNUSED_RESULT(PerlLIO_write(PL_perlio_debug_fd, buffer, len1 + len2));
d484 1
a484 1
	PERL_UNUSED_RESULT(PerlLIO_write(PL_perlio_debug_fd, s, len));
d665 1
a665 1
#ifdef USE_ITHREADS
a897 1
XS(XS_io_MODIFY_SCALAR_ATTRIBUTES); /* prototype to pass -Wmissing-prototypes */
a937 1
XS(XS_PerlIO__Layer__NoWarnings); /* prototype to pass -Wmissing-prototypes */
a950 1
XS(XS_PerlIO__Layer__find); /* prototype to pass -Wmissing-prototypes */
d1874 1
a1874 1
SSize_t
a1876 1
    /* Note that Get_bufsiz returns a Size_t */
d1886 1
a1886 1
SSize_t
d1893 1
a1893 1
Perl_PerlIO_set_cnt(pTHX_ PerlIO *f, SSize_t cnt)
d1899 1
a1899 1
Perl_PerlIO_set_ptrcnt(pTHX_ PerlIO *f, STDCHAR * ptr, SSize_t cnt)
d2270 1
a2270 1
#ifdef USE_ITHREADS
d2721 1
a2721 4
            STRLEN len;
	    const char *path = SvPV_const(*args, len);
	    if (!IS_SAFE_PATHNAME(path, len, "open"))
                return NULL;
a2732 1
		PerlLIO_close(fd);
a2767 1
        PerlLIO_close(fd);
a2976 1
                return PerlIOBase_pushed(aTHX_ f, mode, arg, tab);
d3033 1
a3033 2
        STRLEN len;
	const char * const path = SvPV_const(*args, len);
a3035 2
	if (!IS_SAFE_PATHNAME(path, len, "open"))
            return NULL;
d3047 1
a3047 4
            STRLEN len;
	    const char * const path = SvPV_const(*args, len);
            if (!IS_SAFE_PATHNAME(path, len, "open"))
                return NULL;
a3114 1
            PerlLIO_close(fd);
d3171 1
a3171 1
#  elif defined(__sun)
d4538 1
a4538 1
	*(c->nl) = NATIVE_0xd;
d4561 2
a4562 2
			*--(b->ptr) = NATIVE_0xa;
			*--(b->ptr) = NATIVE_0xd;
d4568 1
a4568 2
                        *--(b->ptr) = NATIVE_0xa;   /* Works even if 0xa ==
                                                       '\r' */
d4595 1
a4595 1
	if ((PerlIOBase(f)->flags & PERLIO_F_CRLF) && (!c->nl || *c->nl == NATIVE_0xd)) {
d4598 1
a4598 1
	    while (nl < b->end && *nl != NATIVE_0xd)
d4600 1
a4600 1
	    if (nl < b->end && *nl == NATIVE_0xd) {
d4603 1
a4603 1
		    if (nl[1] == NATIVE_0xa) {
d4643 1
a4643 1
			*nl = NATIVE_0xd;      /* Fill in the CR */
d4669 1
a4669 1
	    if (ptr == b->end && *c->nl == NATIVE_0xd) {
d4687 1
a4687 1
	if (ptr+cnt == c->nl && c->nl+1 == b->end && *c->nl == NATIVE_0xd) {
d4705 1
a4705 1
	    *(c->nl) = NATIVE_0xd;
d4740 2
a4741 2
			*(b->ptr)++ = NATIVE_0xd;      /* CR */
			*(b->ptr)++ = NATIVE_0xa;      /* LF */
d4769 1
a4769 1
	*(c->nl) = NATIVE_0xd;
a4973 1
    va_end(apc);
a5035 1
	 SvREFCNT_dec(sv);
a5039 6
     if (fd < 0) {
         /* Try cwd */
         sv = newSVpvs(".");
         sv_catpv(sv, tempname + 4);
         fd = mkstemp(SvPVX(sv));
     }
d5061 1
d5164 1
a5164 1
#if !defined(HAS_VPRINTF)
d5182 30
@


