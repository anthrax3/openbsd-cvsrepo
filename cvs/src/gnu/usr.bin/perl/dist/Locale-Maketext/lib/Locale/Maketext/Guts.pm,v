head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.4
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.3.0.10
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.12
	OPENBSD_5_8_BASE:1.3
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.3.0.8
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2017.02.05.00.32.09;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	cxJ08BvJA9Pt2PTM;

1.4
date	2016.07.25.10.53.03;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	FHUgABTHZQuYQh2B;

1.3
date	2013.03.25.20.40.53;	author sthen;	state Exp;
branches
	1.3.10.1
	1.3.12.1;
next	1.2;

1.2
date	2013.02.08.16.56.14;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.36;	author sthen;	state Exp;
branches;
next	;

1.3.10.1
date	2016.08.05.01.01.39;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.3.12.1
date	2016.08.05.01.00.55;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.5
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Locale::Maketext::Guts;

use Locale::Maketext;

our $VERSION = '1.20';

=head1 NAME

Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code

=head1 SYNOPSIS

  # Do this instead please
  use Locale::Maketext

=head1 DESCRIPTION

Previously Local::Maketext::GutsLoader performed some magic to load
Locale::Maketext when utf8 was unavailable. The subs this module provided
were merged back into Locale::Maketext

=cut

1;
@


1.4
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@d5 1
a5 1
our $VERSION = '1.20_01';
@


1.3
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d5 1
a5 1
our $VERSION = '1.20';
@


1.3.10.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d5 1
a5 1
our $VERSION = '1.20_01';
@


1.3.12.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@d5 1
a5 1
our $VERSION = '1.20_01';
@


1.2
log
@Fix for CVE-2012-6329; from perl git via Sebastian Trahm
@
text
@d3 1
a3 1
$VERSION = '1.13';
d5 1
a5 4
BEGIN {
    # Just so we're nice and define SOMETHING in "our" package.
    *zorp = sub { return scalar @@_ } unless defined &zorp;
}
d7 1
a7 3
package Locale::Maketext;
use strict;
use vars qw($USE_LITERALS $GUTSPATH);
d9 1
a9 4
BEGIN {
    $GUTSPATH = __FILE__;
    *DEBUG = sub () {0} unless defined &DEBUG;
}
d11 1
a11 1
use utf8;
d13 2
a14 4
sub _compile {
    # This big scary routine compiles an entry.
    # It returns either a coderef if there's brackety bits in this, or
    #  otherwise a ref to a scalar.
d16 1
a16 1
    my $target = ref($_[0]) || $_[0];
d18 3
a20 7
    my(@@code);
    my(@@c) = (''); # "chunks" -- scratch.
    my $call_count = 0;
    my $big_pile = '';
    {
        my $in_group = 0; # start out outside a group
        my($m, @@params); # scratch
d22 1
a22 284
        while($_[1] =~  # Iterate over chunks.
            m/\G(
                [^\~\[\]]+  # non-~[] stuff
                |
                ~.       # ~[, ~], ~~, ~other
                |
                \[          # [ presumably opening a group
                |
                \]          # ] presumably closing a group
                |
                ~           # terminal ~ ?
                |
                $
            )/xgs
        ) {
            DEBUG>2 and print qq{  "$1"\n};

            if($1 eq '[' or $1 eq '') {       # "[" or end
                # Whether this is "[" or end, force processing of any
                #  preceding literal.
                if($in_group) {
                    if($1 eq '') {
                        $target->_die_pointing($_[1], 'Unterminated bracket group');
                    }
                    else {
                        $target->_die_pointing($_[1], 'You can\'t nest bracket groups');
                    }
                }
                else {
                    if ($1 eq '') {
                        DEBUG>2 and print "   [end-string]\n";
                    }
                    else {
                        $in_group = 1;
                    }
                    die "How come \@@c is empty?? in <$_[1]>" unless @@c; # sanity
                    if(length $c[-1]) {
                        # Now actually processing the preceding literal
                        $big_pile .= $c[-1];
                        if($USE_LITERALS and (
                                (ord('A') == 65)
                                ? $c[-1] !~ m/[^\x20-\x7E]/s
                                # ASCII very safe chars
                                : $c[-1] !~ m/[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@@A-Z[\\\]^_`a-z{|}~\x07]/s
                                # EBCDIC very safe chars
                            )) {
                            # normal case -- all very safe chars
                            $c[-1] =~ s/'/\\'/g;
                            push @@code, q{ '} . $c[-1] . "',\n";
                            $c[-1] = ''; # reuse this slot
                        }
                        else {
                            push @@code, ' $c[' . $#c . "],\n";
                            push @@c, ''; # new chunk
                        }
                    }
                    # else just ignore the empty string.
                }

            }
            elsif($1 eq ']') {  # "]"
                # close group -- go back in-band
                if($in_group) {
                    $in_group = 0;

                    DEBUG>2 and print "   --Closing group [$c[-1]]\n";

                    # And now process the group...

                    if(!length($c[-1]) or $c[-1] =~ m/^\s+$/s) {
                        DEBUG > 2 and print "   -- (Ignoring)\n";
                        $c[-1] = ''; # reset out chink
                        next;
                    }

                    #$c[-1] =~ s/^\s+//s;
                    #$c[-1] =~ s/\s+$//s;
                    ($m,@@params) = split(/,/, $c[-1], -1);  # was /\s*,\s*/

                    # A bit of a hack -- we've turned "~,"'s into DELs, so turn
                    #  'em into real commas here.
                    if (ord('A') == 65) { # ASCII, etc
                        foreach($m, @@params) { tr/\x7F/,/ }
                    }
                    else {              # EBCDIC (1047, 0037, POSIX-BC)
                        # Thanks to Peter Prymmer for the EBCDIC handling
                        foreach($m, @@params) { tr/\x07/,/ }
                    }

                    # Special-case handling of some method names:
                    if($m eq '_*' or $m =~ m/^_(-?\d+)$/s) {
                        # Treat [_1,...] as [,_1,...], etc.
                        unshift @@params, $m;
                        $m = '';
                    }
                    elsif($m eq '*') {
                        $m = 'quant'; # "*" for "times": "4 cars" is 4 times "cars"
                    }
                    elsif($m eq '#') {
                        $m = 'numf';  # "#" for "number": [#,_1] for "the number _1"
                    }

                    # Most common case: a simple, legal-looking method name
                    if($m eq '') {
                        # 0-length method name means to just interpolate:
                        push @@code, ' (';
                    }
                    elsif($m =~ /^\w+$/s
                        # exclude anything fancy, especially fully-qualified
                        # module names
                    ) {

                        push @@code, ' $_[0]->' . $m . '(';
                    }
                    else {
                        # TODO: implement something?  or just too icky to consider?
                        $target->_die_pointing(
                            $_[1],
                            "Can't use \"$m\" as a method name in bracket group",
                            2 + length($c[-1])
                        );
                    }

                    pop @@c; # we don't need that chunk anymore
                    ++$call_count;

                    foreach my $p (@@params) {
                        if($p eq '_*') {
                            # Meaning: all parameters except $_[0]
                            $code[-1] .= ' @@_[1 .. $#_], ';
                            # and yes, that does the right thing for all @@_ < 3
                        }
                        elsif($p =~ m/^_(-?\d+)$/s) {
                            # _3 meaning $_[3]
                            $code[-1] .= '$_[' . (0 + $1) . '], ';
                        }
                        elsif($USE_LITERALS and (
                                (ord('A') == 65)
                                ? $p !~ m/[^\x20-\x7E]/s
                                # ASCII very safe chars
                                : $p !~ m/[^ !"\#\$%&'()*+,\-.\/0-9:;<=>?\@@A-Z[\\\]^_`a-z{|}~\x07]/s
                                # EBCDIC very safe chars
                            )) {
                            # Normal case: a literal containing only safe characters
                            $p =~ s/'/\\'/g;
                            $code[-1] .= q{'} . $p . q{', };
                        }
                        else {
                            # Stow it on the chunk-stack, and just refer to that.
                            push @@c, $p;
                            push @@code, ' $c[' . $#c . '], ';
                        }
                    }
                    $code[-1] .= "),\n";

                    push @@c, '';
                }
                else {
                    $target->_die_pointing($_[1], q{Unbalanced ']'});
                }

            }
            elsif(substr($1,0,1) ne '~') {
                # it's stuff not containing "~" or "[" or "]"
                # i.e., a literal blob
                my $text = $1;
                $text =~ s/\\/\\\\/g;
                $c[-1] .= $text;

            }
            elsif($1 eq '~~') { # "~~"
                $c[-1] .= '~';

            }
            elsif($1 eq '~[') { # "~["
                $c[-1] .= '[';

            }
            elsif($1 eq '~]') { # "~]"
                $c[-1] .= ']';

            }
            elsif($1 eq '~,') { # "~,"
                if($in_group) {
                    # This is a hack, based on the assumption that no-one will actually
                    # want a DEL inside a bracket group.  Let's hope that's it's true.
                    if (ord('A') == 65) { # ASCII etc
                        $c[-1] .= "\x7F";
                    }
                    else {              # EBCDIC (cp 1047, 0037, POSIX-BC)
                        $c[-1] .= "\x07";
                    }
                }
                else {
                    $c[-1] .= '~,';
                }

            }
            elsif($1 eq '~') { # possible only at string-end, it seems.
                $c[-1] .= '~';

            }
            else {
                # It's a "~X" where X is not a special character.
                # Consider it a literal ~ and X.
                my $text = $1;
                $text =~ s/\\/\\\\/g;
                $c[-1] .= $text;
            }
        }
    }

    if($call_count) {
        undef $big_pile; # Well, nevermind that.
    }
    else {
        # It's all literals!  Ahwell, that can happen.
        # So don't bother with the eval.  Return a SCALAR reference.
        return \$big_pile;
    }

    die q{Last chunk isn't null??} if @@c and length $c[-1]; # sanity
    DEBUG and warn scalar(@@c), " chunks under closure\n";
    if(@@code == 0) { # not possible?
        DEBUG and warn "Empty code\n";
        return \'';
    }
    elsif(@@code > 1) { # most cases, presumably!
        unshift @@code, "join '',\n";
    }
    unshift @@code, "use strict; sub {\n";
    push @@code, "}\n";

    DEBUG and warn @@code;
    my $sub = eval(join '', @@code);
    die "$@@ while evalling" . join('', @@code) if $@@; # Should be impossible.
    return $sub;
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

sub _die_pointing {
    # This is used by _compile to throw a fatal error
    my $target = shift; # class name
    # ...leaving $_[0] the error-causing text, and $_[1] the error message

    my $i = index($_[0], "\n");

    my $pointy;
    my $pos = pos($_[0]) - (defined($_[2]) ? $_[2] : 0) - 1;
    if($pos < 1) {
        $pointy = "^=== near there\n";
    }
    else { # we need to space over
        my $first_tab = index($_[0], "\t");
        if($pos > 2 and ( -1 == $first_tab  or  $first_tab > pos($_[0]))) {
            # No tabs, or the first tab is harmlessly after where we will point to,
            # AND we're far enough from the margin that we can draw a proper arrow.
            $pointy = ('=' x $pos) . "^ near there\n";
        }
        else {
            # tabs screw everything up!
            $pointy = substr($_[0],0,$pos);
            $pointy =~ tr/\t //cd;
            # make everything into whitespace, but preseving tabs
            $pointy .= "^=== near there\n";
        }
    }

    my $errmsg = "$_[1], in\:\n$_[0]";

    if($i == -1) {
        # No newline.
        $errmsg .= "\n" . $pointy;
    }
    elsif($i == (length($_[0]) - 1)  ) {
        # Already has a newline at end.
        $errmsg .= $pointy;
    }
    else {
        # don't bother with the pointy bit, I guess.
    }
    Carp::croak( "$errmsg via $target, as used" );
}
a24 1

@


1.1
log
@Initial revision
@
text
@d143 3
a145 3
                    elsif($m =~ /^\w+(?:\:\:\w+)*$/s
                            and $m !~ m/(?:^|\:)\d/s
                        # exclude starting a (sub)package or symbol with a digit
a146 10
                        # Yes, it even supports the demented (and undocumented?)
                        #  $obj->Foo::bar(...) syntax.
                        $target->_die_pointing(
                            $_[1], q{Can't use "SUPER::" in a bracket-group method},
                            2 + length($c[-1])
                        )
                        if $m =~ m/^SUPER::/s;
                        # Because for SUPER:: to work, we'd have to compile this into
                        #  the right package, and that seems just not worth the bother,
                        #  unless someone convinces me otherwise.
d201 3
a203 1
                $c[-1] .= $1;
d241 3
a243 1
                $c[-1] .= $1;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
use Locale::Maketext;
d5 4
a8 1
our $VERSION = '1.20';
d10 3
a12 1
=head1 NAME
d14 4
a17 1
Locale::Maketext::Guts - Deprecated module to load Locale::Maketext utf8 code
d19 1
a19 1
=head1 SYNOPSIS
d21 4
a24 2
  # Do this instead please
  use Locale::Maketext
d26 1
a26 1
=head1 DESCRIPTION
d28 7
a34 3
Previously Local::Maketext::GutsLoader performed some magic to load
Locale::Maketext when utf8 was unavailable. The subs this module provided
were merged back into Locale::Maketext
d36 290
a325 1
=cut
d328 1
@

