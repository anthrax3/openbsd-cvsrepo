head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.18
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.16
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.10
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.12
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.4
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.8
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.40;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@use strict;
use warnings;

BEGIN {
    use Config;
    if (! $Config{'useithreads'}) {
        print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
        exit(0);
    }
}

use ExtUtils::testlib;

use threads;

BEGIN {
    if (! eval 'use threads::shared; 1') {
        print("1..0 # SKIP threads::shared not available\n");
        exit(0);
    }

    $| = 1;
    if ($] == 5.008) {
        print("1..11\n");   ### Number of tests that will be run ###
    } else {
        print("1..15\n");   ### Number of tests that will be run ###
    }
};

print("ok 1 - Loaded\n");

### Start of Testing ###

no warnings 'deprecated';       # Suppress warnings related to :unique

use Hash::Util 'lock_keys';

my $test :shared = 2;

# Note that we can't use Test::More here, as we would need to call is()
# from within the DESTROY() function at global destruction time, and
# parts of Test::* may have already been freed by then
sub is($$$)
{
    my ($got, $want, $desc) = @@_;
    lock($test);
    if ($got ne $want) {
        print("# EXPECTED: $want\n");
        print("# GOT:      $got\n");
        print("not ");
    }
    print("ok $test - $desc\n");
    $test++;
}


# This tests for too much destruction which was caused by cloning stashes
# on join which led to double the dataspace under 5.8.0
if ($] != 5.008)
{
    sub Foo::DESTROY
    {
        my $self = shift;
        my ($package, $file, $line) = caller;
        is(threads->tid(), $self->{tid}, "In destroy[$self->{tid}] it should be correct too" );
    }

    my $foo = bless {tid => 0}, 'Foo';
    my $bar = threads->create(sub {
        is(threads->tid(), 1, "And tid be 1 here");
        $foo->{tid} = 1;
        return ($foo);
    })->join();
    $bar->{tid} = 0;
}


# This tests whether we can call Config::myconfig after threads have been
# started (interpreter cloned).  5.8.1 and 5.8.2 contained a bug that would
# disallow that to be done because an attempt was made to change a variable
# with the :unique attribute.

{
    lock($test);
    if ($] == 5.008 || $] >= 5.008003) {
        threads->create( sub {1} )->join;
        my $not = eval { Config::myconfig() } ? '' : 'not ';
        print "${not}ok $test - Are we able to call Config::myconfig after clone\n";
    } else {
        print "ok $test # SKIP Are we able to call Config::myconfig after clone\n";
    }
    $test++;
}


# bugid 24383 - :unique hashes weren't being made readonly on interpreter
# clone; check that they are.

our $unique_scalar : unique;
our @@unique_array : unique;
our %unique_hash : unique;
threads->create(sub {
        lock($test);
        my $TODO = ":unique needs to be re-implemented in a non-broken way";
        eval { $unique_scalar = 1 };
        print $@@ =~ /read-only/
          ? '' : 'not ', "ok $test # TODO $TODO - unique_scalar\n";
        $test++;
        eval { $unique_array[0] = 1 };
        print $@@ =~ /read-only/
          ? '' : 'not ', "ok $test # TODO $TODO - unique_array\n";
        $test++;
        if ($] >= 5.008003 && $^O ne 'MSWin32') {
            eval { $unique_hash{abc} = 1 };
            print $@@ =~ /disallowed/
              ? '' : 'not ', "ok $test # TODO $TODO - unique_hash\n";
        } else {
            print("ok $test # SKIP $TODO - unique_hash\n");
        }
        $test++;
    })->join;

# bugid #24940 :unique should fail on my and sub declarations

for my $decl ('my $x : unique', 'sub foo : unique') {
    {
        lock($test);
        if ($] >= 5.008005) {
            eval $decl;
            print $@@ =~ /^The 'unique' attribute may only be applied to 'our' variables/
                    ? '' : 'not ', "ok $test - $decl\n";
        } else {
            print("ok $test # SKIP $decl\n");
        }
        $test++;
    }
}


# Returing a closure from a thread caused problems. If the last index in
# the anon sub's pad wasn't for a lexical, then a core dump could occur.
# Otherwise, there might be leaked scalars.

# XXX DAPM 9-Jan-04 - backed this out for now - returning a closure from a
# thread seems to crash win32

# sub f {
#     my $x = "foo";
#     sub { $x."bar" };
# }
# 
# my $string = threads->create(\&f)->join->();
# print $string eq 'foobar' ?  '' : 'not ', "ok $test - returning closure\n";
# $test++;


# Nothing is checking that total keys gets cloned correctly.

my %h = (1,2,3,4);
is(keys(%h), 2, "keys correct in parent");

my $child = threads->create(sub { return (scalar(keys(%h))); })->join;
is($child, 2, "keys correct in child");

lock_keys(%h);
delete($h{1});

is(keys(%h), 1, "keys correct in parent with restricted hash");

$child = threads->create(sub { return (scalar(keys(%h))); })->join;
is($child, 1, "keys correct in child with restricted hash");

exit(0);

# EOF
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d140 1
a140 1
# Returning a closure from a thread caused problems. If the last index in
@

