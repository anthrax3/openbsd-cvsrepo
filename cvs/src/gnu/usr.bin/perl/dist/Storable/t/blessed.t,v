head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.3
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.14
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.12
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.6
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.8
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.39;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl
#
#  Copyright (c) 1995-2000, Raphael Manfredi
#  
#  You may redistribute only under the same terms as Perl 5, as specified
#  in the README file that comes with the distribution.
#

sub BEGIN {
    unshift @@INC, 't';
    require Config; import Config;
    if ($ENV{PERL_CORE} and $Config{'extensions'} !~ /\bStorable\b/) {
        print "1..0 # Skip: Storable was not built\n";
        exit 0;
    }
    require 'st-dump.pl';
}

sub ok;

use Storable qw(freeze thaw);

%::immortals
  = (u => \undef,
     'y' => \(1 == 1),
     n => \(1 == 0)
);

my $test = 12;
my $tests = $test + 6 + 2 * 6 * keys %::immortals;
print "1..$tests\n";

package SHORT_NAME;

sub make { bless [], shift }

package SHORT_NAME_WITH_HOOK;

sub make { bless [], shift }

sub STORABLE_freeze {
	my $self = shift;
	return ("", $self);
}

sub STORABLE_thaw {
	my $self = shift;
	my $cloning = shift;
	my ($x, $obj) = @@_;
	die "STORABLE_thaw" unless $obj eq $self;
}

package main;

# Still less than 256 bytes, so long classname logic not fully exercised
# Wait until Perl removes the restriction on identifier lengths.
my $name = "LONG_NAME_" . 'xxxxxxxxxxxxx::' x 14 . "final";

eval <<EOC;
package $name;

\@@ISA = ("SHORT_NAME");
EOC
die $@@ if $@@;
ok 1, $@@ eq '';

eval <<EOC;
package ${name}_WITH_HOOK;

\@@ISA = ("SHORT_NAME_WITH_HOOK");
EOC
ok 2, $@@ eq '';

# Construct a pool of objects
my @@pool;

for (my $i = 0; $i < 10; $i++) {
	push(@@pool, SHORT_NAME->make);
	push(@@pool, SHORT_NAME_WITH_HOOK->make);
	push(@@pool, $name->make);
	push(@@pool, "${name}_WITH_HOOK"->make);
}

my $x = freeze \@@pool;
ok 3, 1;

my $y = thaw $x;
ok 4, ref $y eq 'ARRAY';
ok 5, @@{$y} == @@pool;

ok 6, ref $y->[0] eq 'SHORT_NAME';
ok 7, ref $y->[1] eq 'SHORT_NAME_WITH_HOOK';
ok 8, ref $y->[2] eq $name;
ok 9, ref $y->[3] eq "${name}_WITH_HOOK";

my $good = 1;
for (my $i = 0; $i < 10; $i++) {
	do { $good = 0; last } unless ref $y->[4*$i]   eq 'SHORT_NAME';
	do { $good = 0; last } unless ref $y->[4*$i+1] eq 'SHORT_NAME_WITH_HOOK';
	do { $good = 0; last } unless ref $y->[4*$i+2] eq $name;
	do { $good = 0; last } unless ref $y->[4*$i+3] eq "${name}_WITH_HOOK";
}
ok 10, $good;

{
	my $blessed_ref = bless \\[1,2,3], 'Foobar';
	my $x = freeze $blessed_ref;
	my $y = thaw $x;
	ok 11, ref $y eq 'Foobar';
	ok 12, $$$y->[0] == 1;
}

package RETURNS_IMMORTALS;

sub make { my $self = shift; bless [@@_], $self }

sub STORABLE_freeze {
  # Some reference some number of times.
  my $self = shift;
  my ($what, $times) = @@$self;
  return ("$what$times", ($::immortals{$what}) x $times);
}

sub STORABLE_thaw {
	my $self = shift;
	my $cloning = shift;
	my ($x, @@refs) = @@_;
	my ($what, $times) = $x =~ /(.)(\d+)/;
	die "'$x' didn't match" unless defined $times;
	main::ok ++$test, @@refs == $times;
	my $expect = $::immortals{$what};
	die "'$x' did not give a reference" unless ref $expect;
	my $fail;
	foreach (@@refs) {
	  $fail++ if $_ != $expect;
	}
	main::ok ++$test, !$fail;
}

package main;

# $Storable::DEBUGME = 1;
my $count;
foreach $count (1..3) {
  my $immortal;
  foreach $immortal (keys %::immortals) {
    print "# $immortal x $count\n";
    my $i =  RETURNS_IMMORTALS->make ($immortal, $count);

    my $f = freeze ($i);
    ok ++$test, $f;
    my $t = thaw $f;
    ok ++$test, 1;
  }
}

# Test automatic require of packages to find thaw hook.

package HAS_HOOK;

$loaded_count = 0;
$thawed_count = 0;

sub make {
  bless [];
}

sub STORABLE_freeze {
  my $self = shift;
  return '';
}

package main;

my $f = freeze (HAS_HOOK->make);

ok ++$test, $HAS_HOOK::loaded_count == 0;
ok ++$test, $HAS_HOOK::thawed_count == 0;

my $t = thaw $f;
ok ++$test, $HAS_HOOK::loaded_count == 1;
ok ++$test, $HAS_HOOK::thawed_count == 1;
ok ++$test, $t;
ok ++$test, ref $t eq 'HAS_HOOK';

# Can't do this because the method is still cached by UNIVERSAL::can
# delete $INC{"HAS_HOOK.pm"};
# undef &HAS_HOOK::STORABLE_thaw;
# 
# warn HAS_HOOK->can('STORABLE_thaw');
# $t = thaw $f;
# ok ++$test, $HAS_HOOK::loaded_count == 2;
# ok ++$test, $HAS_HOOK::thawed_count == 2;
# ok ++$test, $t;
# ok ++$test, ref $t eq 'HAS_HOOK';
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a10 1
    unshift @@INC, 't/compat' if $] < 5.006002;
d16 1
d19 1
a19 1
use Test::More;
d21 1
a21 1
use Storable qw(freeze thaw store retrieve);
d30 2
a31 2
my $tests = $test + 22 + 2 * 6 * keys %::immortals;
plan(tests => $tests);
d64 2
a65 1
is($@@, '');
d72 1
a72 1
is($@@, '');
d85 1
a85 1
pass("Freeze didn't crash");
d88 2
a89 2
is(ref $y, 'ARRAY');
is(scalar @@{$y}, @@pool);
d91 4
a94 4
is(ref $y->[0], 'SHORT_NAME');
is(ref $y->[1], 'SHORT_NAME_WITH_HOOK');
is(ref $y->[2], $name);
is(ref $y->[3], "${name}_WITH_HOOK");
d103 1
a103 1
is($good, 1);
d109 2
a110 2
	is(ref $y, 'Foobar');
	is($$$y->[0], 1);
d130 1
a130 1
	main::is(scalar @@refs, $times);
d137 1
a137 1
	main::is($fail, undef);
d151 1
a151 1
    isnt($f, undef);
d153 1
a153 1
    pass("thaw didn't crash");
d177 2
a178 2
is($HAS_HOOK::loaded_count, 0);
is($HAS_HOOK::thawed_count, 0);
d181 15
a195 72
is($HAS_HOOK::loaded_count, 1);
is($HAS_HOOK::thawed_count, 1);
isnt($t, undef);
is(ref $t, 'HAS_HOOK');

delete $INC{"HAS_HOOK.pm"};
delete $HAS_HOOK::{STORABLE_thaw};

$t = thaw $f;
is($HAS_HOOK::loaded_count, 2);
is($HAS_HOOK::thawed_count, 2);
isnt($t, undef);
is(ref $t, 'HAS_HOOK');

{
    package STRESS_THE_STACK;

    my $stress;
    sub make {
	bless [];
    }

    sub no_op {
	0;
    }

    sub STORABLE_freeze {
	my $self = shift;
	++$freeze_count;
	return no_op(1..(++$stress * 2000)) ? die "can't happen" : '';
    }

    sub STORABLE_thaw {
	my $self = shift;
	++$thaw_count;
	no_op(1..(++$stress * 2000)) && die "can't happen";
	return;
    }
}

$STRESS_THE_STACK::freeze_count = 0;
$STRESS_THE_STACK::thaw_count = 0;

$f = freeze (STRESS_THE_STACK->make);

is($STRESS_THE_STACK::freeze_count, 1);
is($STRESS_THE_STACK::thaw_count, 0);

$t = thaw $f;
is($STRESS_THE_STACK::freeze_count, 1);
is($STRESS_THE_STACK::thaw_count, 1);
isnt($t, undef);
is(ref $t, 'STRESS_THE_STACK');

my $file = "storable-testfile.$$";
die "Temporary file '$file' already exists" if -e $file;

END { while (-f $file) {unlink $file or die "Can't unlink '$file': $!" }}

$STRESS_THE_STACK::freeze_count = 0;
$STRESS_THE_STACK::thaw_count = 0;

store (STRESS_THE_STACK->make, $file);

is($STRESS_THE_STACK::freeze_count, 1);
is($STRESS_THE_STACK::thaw_count, 0);

$t = retrieve ($file);
is($STRESS_THE_STACK::freeze_count, 1);
is($STRESS_THE_STACK::thaw_count, 1);
isnt($t, undef);
is(ref $t, 'STRESS_THE_STACK');
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a28 9
{
    %::weird_refs = (
        REF     => \(my $aref    = []),
        VSTRING => \(my $vstring = v1.2.3),
       'long VSTRING' => \(my $vstring = eval "v" . 0 x 300),
        LVALUE  => \(my $substr  = substr((my $str = "foo"), 0, 3)),
    );
}

d30 1
a30 1
my $tests = $test + 23 + (2 * 6 * keys %::immortals) + (3 * keys %::weird_refs);
a251 47

{
    package ModifyARG112358;
    sub STORABLE_freeze { $_[0] = "foo"; }
    my $o= {str=>bless {}};
    my $f= ::freeze($o);
    ::is ref $o->{str}, __PACKAGE__,
	'assignment to $_[0] in STORABLE_freeze does not corrupt things';
}

# [perl #113880]
{
    {
        package WeirdRefHook;
        sub STORABLE_freeze { () }
        $INC{'WeirdRefHook.pm'} = __FILE__;
    }

    for my $weird (keys %weird_refs) {
        my $obj = $weird_refs{$weird};
        bless $obj, 'WeirdRefHook';
        my $frozen;
        my $success = eval { $frozen = freeze($obj); 1 };
        ok($success, "can freeze $weird objects")
            || diag("freezing failed: $@@");
        my $thawn = thaw($frozen);
        # is_deeply ignores blessings
        is ref $thawn, ref $obj, "get the right blessing back for $weird";
        if ($weird =~ 'VSTRING') {
            # It is not just Storable that did not support vstrings. :-)
            # See https://rt.cpan.org/Ticket/Display.html?id=78678
            my $newver = "version"->can("new")
                           ? sub { "version"->new(shift) }
                           : sub { "" };
            if (!ok
                  $$thawn eq $$obj && &$newver($$thawn) eq &$newver($$obj),
                 "get the right value back"
            ) {
                diag "$$thawn vs $$obj";
                diag &$newver($$thawn) eq &$newver($$obj) if &$newver(1);
             }
        }
        else {
            is_deeply($thawn, $obj, "get the right value back");
        }
    }
}
@


