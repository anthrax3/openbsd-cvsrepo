head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.10
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.12
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.6
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.8
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.2
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.4
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.1
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2014.03.24.14.59.01;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@use strict;
use warnings;

use Config;

BEGIN {
    if (! $Config{'useithreads'}) {
        print("1..0 # SKIP Perl not compiled with 'useithreads'\n");
        exit(0);
    }
    if (! $Config{'d_select'}) {
        print("1..0 # SKIP 'select()' not available for testing\n");
        exit(0);
    }
}

use threads;
use Thread::Queue;

use Test::More;

my $num_threads = 3;
my $cycles = 2;
my $count = 2;
plan tests => 3*$num_threads*$cycles*$count + 6*$num_threads + 6;

# Test for end() while threads are blocked and no more items in queue
{
    my @@items = 1..($num_threads*$cycles*$count);
    my $q = Thread::Queue->new(@@items);
    my $r = Thread::Queue->new();

    my @@threads;
    for my $ii (1..$num_threads) {
        push @@threads, threads->create( sub {
            # Thread will loop until no more work is coming
            LOOP:
            while (my @@set = $q->dequeue($count)) {
                foreach my $item (@@set) {
                    last LOOP if (! defined($item));
                    pass("'$item' read from queue in thread $ii");
                }
                select(undef, undef, undef, rand(1));
                $r->enqueue($ii);
            }
            pass("Thread $ii exiting");
        });
    }

    # Make sure there's nothing in the queue and threads are blocking
    for my $ii (1..($num_threads*$cycles)) {
        $r->dequeue();
    }
    sleep(1);
    threads->yield();

    is($q->pending(), 0, 'Queue is empty');

    # Signal no more work is coming
    $q->end();

    is($q->pending(), undef, 'Queue is ended');

    for my $thread (@@threads) {
        $thread->join;
        pass($thread->tid." joined");
    }
}

# Test for end() while threads are blocked and items still remain in queue
{
    my @@items = 1..($num_threads*$cycles*$count + 1);
    my $q = Thread::Queue->new(@@items);
    my $r = Thread::Queue->new();

    my @@threads;
    for my $ii (1..$num_threads) {
        push @@threads, threads->create( sub {
            # Thread will loop until no more work is coming
            LOOP:
            while (my @@set = $q->dequeue($count)) {
                foreach my $item (@@set) {
                    last LOOP if (! defined($item));
                    pass("'$item' read from queue in thread $ii");
                }
                select(undef, undef, undef, rand(1));
                $r->enqueue($ii);
            }
            pass("Thread $ii exiting");
        });
    }

    # Make sure there's nothing in the queue and threads are blocking
    for my $ii (1..($num_threads*$cycles)) {
        $r->dequeue();
    }
    sleep(1);
    threads->yield();

    is($q->pending(), 1, 'Queue has one left');

    # Signal no more work is coming
    $q->end();

    for my $thread (@@threads) {
        $thread->join;
        pass($thread->tid." joined");
    }

    is($q->pending(), undef, 'Queue is ended');
}

# Test of end() send while items in queue
{
    my @@items = 1..($num_threads*$cycles*$count + 1);
    my $q = Thread::Queue->new(@@items);

    my @@threads;
    for my $ii (1..$num_threads) {
        push @@threads, threads->create( sub {
            # Thread will loop until no more work is coming
            LOOP:
            while (my @@set = $q->dequeue($count)) {
                foreach my $item (@@set) {
                    last LOOP if (! defined($item));
                    pass("'$item' read from queue in thread $ii");
                }
                select(undef, undef, undef, rand(1));
            }
            pass("Thread $ii exiting");
        });
    }

    # Signal no more work is coming to the blocked threads, they
    # should unblock.
    $q->end();

    for my $thread (@@threads) {
        $thread->join;
        pass($thread->tid." joined");
    }
}

exit(0);

# EOF
@


1.1.1.1
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@@
