head	1.6;
access;
symbols
	OPENBSD_6_2:1.6.0.2
	OPENBSD_6_2_BASE:1.6
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.6.0.4
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2017.02.05.00.32.08;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	cxJ08BvJA9Pt2PTM;

1.5
date	2015.04.25.19.14.45;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	XRK22kO4se3v2i2I;

1.4
date	2014.11.17.21.00.59;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	LnErp1MFKSuew5Fr;

1.3
date	2014.11.17.20.57.05;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	QP75iYx42Uo7mMxO;

1.2
date	2014.10.26.22.04.16;	author bluhm;	state Exp;
branches;
next	1.1;
commitid	kVoteutXh2Ohmymx;

1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.08.33;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.58.59;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.02;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.33;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.6
date	2017.08.14.13.46.07;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.6
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef USE_PPPORT_H
#  define NEED_my_snprintf
#  define NEED_sv_2pv_flags
#  include "ppport.h"
#endif

#if PERL_VERSION < 8
#  define DD_USE_OLD_ID_FORMAT
#endif

/* These definitions are ASCII only.  But the pure-perl .pm avoids
 * calling this .xs file for releases where they aren't defined */

#ifndef isASCII
#   define isASCII(c) (((UV) (c)) < 128)
#endif

#ifndef ESC_NATIVE          /* \e */
#   define ESC_NATIVE 27
#endif

#ifndef isPRINT
#   define isPRINT(c) (((UV) (c)) >= ' ' && ((UV) (c)) < 127)
#endif

#ifndef isALPHA
#   define isALPHA(c) (   (((UV) (c)) >= 'a' && ((UV) (c)) <= 'z')          \
                       || (((UV) (c)) <= 'Z' && ((UV) (c)) >= 'A'))
#endif

#ifndef isIDFIRST
#   define isIDFIRST(c) (isALPHA(c) || (c) == '_')
#endif

#ifndef isWORDCHAR
#   define isWORDCHAR(c) (isIDFIRST(c)                                      \
                          || (((UV) (c)) >= '0' && ((UV) (c)) <= '9'))
#endif

/* This struct contains almost all the user's desired configuration, and it
 * is treated as constant by the recursive function. This arrangement has
 * the advantage of needing less memory than passing all of them on the
 * stack all the time (as was the case in an earlier implementation). */
typedef struct {
    SV *pad;
    SV *xpad;
    SV *sep;
    SV *pair;
    SV *sortkeys;
    SV *freezer;
    SV *toaster;
    SV *bless;
    IV maxrecurse;
    I32 indent;
    I32 purity;
    I32 deepcopy;
    I32 quotekeys;
    I32 maxdepth;
    I32 useqq;
    int use_sparse_seen_hash;
    int trailingcomma;
} Style;

static STRLEN num_q (const char *s, STRLEN slen);
static STRLEN esc_q (char *dest, const char *src, STRLEN slen);
static STRLEN esc_q_utf8 (pTHX_ SV *sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq);
static bool globname_needs_quote(const char *s, STRLEN len);
static bool key_needs_quote(const char *s, STRLEN len);
static bool safe_decimal_number(const char *p, STRLEN len);
static SV *sv_x (pTHX_ SV *sv, const char *str, STRLEN len, I32 n);
static I32 DD_dump (pTHX_ SV *val, const char *name, STRLEN namelen, SV *retval,
                    HV *seenhv, AV *postav, const I32 level, SV *apad,
                    const Style *style);

#ifndef HvNAME_get
#define HvNAME_get HvNAME
#endif

/* Perls 7 through portions of 15 used utf8_to_uvchr() which didn't have a
 * length parameter.  This wrongly allowed reading beyond the end of buffer
 * given malformed input */

#if PERL_VERSION <= 6 /* Perl 5.6 and earlier */

UV
Perl_utf8_to_uvchr_buf(pTHX_ U8 *s, U8 *send, STRLEN *retlen)
{
    const UV uv = utf8_to_uv(s, send - s, retlen,
                    ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
    return UNI_TO_NATIVE(uv);
}

# if !defined(PERL_IMPLICIT_CONTEXT)
#  define utf8_to_uvchr_buf	     Perl_utf8_to_uvchr_buf
# else
#  define utf8_to_uvchr_buf(a,b,c) Perl_utf8_to_uvchr_buf(aTHX_ a,b,c)
# endif

#endif /* PERL_VERSION <= 6 */

/* Perl 5.7 through part of 5.15 */
#if PERL_VERSION > 6 && PERL_VERSION <= 15 && ! defined(utf8_to_uvchr_buf)

UV
Perl_utf8_to_uvchr_buf(pTHX_ U8 *s, U8 *send, STRLEN *retlen)
{
    /* We have to discard <send> for these versions; hence can read off the
     * end of the buffer if there is a malformation that indicates the
     * character is longer than the space available */

    return utf8_to_uvchr(s, retlen);
}

# if !defined(PERL_IMPLICIT_CONTEXT)
#  define utf8_to_uvchr_buf	     Perl_utf8_to_uvchr_buf
# else
#  define utf8_to_uvchr_buf(a,b,c) Perl_utf8_to_uvchr_buf(aTHX_ a,b,c)
# endif

#endif /* PERL_VERSION > 6 && <= 15 */

/* Changes in 5.7 series mean that now IOK is only set if scalar is
   precisely integer but in 5.6 and earlier we need to do a more
   complex test  */
#if PERL_VERSION <= 6
#define DD_is_integer(sv) (SvIOK(sv) && (SvIsUV(val) ? SvUV(sv) == SvNV(sv) : SvIV(sv) == SvNV(sv)))
#else
#define DD_is_integer(sv) SvIOK(sv)
#endif

/* does a glob name need to be protected? */
static bool
globname_needs_quote(const char *s, STRLEN len)
{
    const char *send = s+len;
TOP:
    if (s[0] == ':') {
	if (++s<send) {
	    if (*s++ != ':')
                return TRUE;
	}
	else
	    return TRUE;
    }
    if (isIDFIRST(*s)) {
	while (++s<send)
	    if (!isWORDCHAR(*s)) {
		if (*s == ':')
		    goto TOP;
		else
                    return TRUE;
	    }
    }
    else
        return TRUE;

    return FALSE;
}

/* does a hash key need to be quoted (to the left of => ).
   Previously this used (globname_)needs_quote() which accepted strings
   like '::foo', but these aren't safe as unquoted keys under strict.
*/
static bool
key_needs_quote(const char *s, STRLEN len) {
    const char *send = s+len;

    if (safe_decimal_number(s, len)) {
        return FALSE;
    }
    else if (isIDFIRST(*s)) {
        while (++s<send)
            if (!isWORDCHAR(*s))
                return TRUE;
    }
    else
        return TRUE;

    return FALSE;
}

/* Check that the SV can be represented as a simple decimal integer.
 *
 * The perl code does this by matching against /^(?:0|-?[1-9]\d{0,8})\z/
*/
static bool
safe_decimal_number(const char *p, STRLEN len) {
    if (len == 1 && *p == '0')
        return TRUE;

    if (len && *p == '-') {
        ++p;
        --len;
    }

    if (len == 0 || *p < '1' || *p > '9')
        return FALSE;

    ++p;
    --len;

    if (len > 8)
        return FALSE;

    while (len > 0) {
         /* the perl code checks /\d/ but we don't want unicode digits here */
         if (*p < '0' || *p > '9')
             return FALSE;
         ++p;
         --len;
    }
    return TRUE;
}

/* count the number of "'"s and "\"s in string */
static STRLEN
num_q(const char *s, STRLEN slen)
{
    STRLEN ret = 0;

    while (slen > 0) {
	if (*s == '\'' || *s == '\\')
	    ++ret;
	++s;
	--slen;
    }
    return ret;
}


/* returns number of chars added to escape "'"s and "\"s in s */
/* slen number of characters in s will be escaped */
/* destination must be long enough for additional chars */
static STRLEN
esc_q(char *d, const char *s, STRLEN slen)
{
    STRLEN ret = 0;

    while (slen > 0) {
	switch (*s) {
	case '\'':
	case '\\':
	    *d = '\\';
	    ++d; ++ret;
            /* FALLTHROUGH */
	default:
	    *d = *s;
	    ++d; ++s; --slen;
	    break;
	}
    }
    return ret;
}

/* this function is also misused for implementing $Useqq */
static STRLEN
esc_q_utf8(pTHX_ SV* sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq)
{
    char *r, *rstart;
    const char *s = src;
    const char * const send = src + slen;
    STRLEN j, cur = SvCUR(sv);
    /* Could count 128-255 and 256+ in two variables, if we want to
       be like &qquote and make a distinction.  */
    STRLEN grow = 0;	/* bytes needed to represent chars 128+ */
    /* STRLEN topbit_grow = 0;	bytes needed to represent chars 128-255 */
    STRLEN backslashes = 0;
    STRLEN single_quotes = 0;
    STRLEN qq_escapables = 0;	/* " $ @@ will need a \ in "" strings.  */
    STRLEN normal = 0;
    int increment;

    for (s = src; s < send; s += increment) { /* Sizing pass */
        UV k = *(U8*)s;

        increment = 1;      /* Will override if necessary for utf-8 */

        if (isPRINT(k)) {
            if (k == '\\') {
                backslashes++;
            } else if (k == '\'') {
                single_quotes++;
            } else if (k == '"' || k == '$' || k == '@@') {
                qq_escapables++;
            } else {
                normal++;
            }
        }
        else if (! isASCII(k) && k > ' ') {
            /* High ordinal non-printable code point.  (The test that k is
             * above SPACE should be optimized out by the compiler on
             * non-EBCDIC platforms; otherwise we could put an #ifdef around
             * it, but it's better to have just a single code path when
             * possible.  All but one of the non-ASCII EBCDIC controls are low
             * ordinal; that one is the only one above SPACE.)
             *
             * If UTF-8, output as hex, regardless of useqq.  This means there
             * is an overhead of 4 chars '\x{}'.  Then count the number of hex
             * digits.  */
            if (do_utf8) {
                k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);

                /* treat invalid utf8 byte by byte.  This loop iteration gets the
                * first byte */
                increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

                grow += 4 + (k <= 0xFF ? 2 : k <= 0xFFF ? 3 : k <= 0xFFFF ? 4 :
#if UVSIZE == 4
                    8 /* We may allocate a bit more than the minimum here.  */
#else
                    k <= 0xFFFFFFFF ? 8 : UVSIZE * 4
#endif
                    );
            }
            else if (useqq) {   /* Not utf8, must be <= 0xFF, hence 2 hex
                                 * digits. */
                grow += 4 + 2;
            }
            else {  /* Non-qq generates 3 octal digits plus backslash */
                grow += 4;
            }
	} /* End of high-ordinal non-printable */
        else if (! useqq) { /* Low ordinal, non-printable, non-qq just
                             * outputs the raw char */
            normal++;
        }
        else {  /* Is qq, low ordinal, non-printable.  Output escape
                 * sequences */
            if (   k == '\a' || k == '\b' || k == '\t' || k == '\n' || k == '\r'
                || k == '\f' || k == ESC_NATIVE)
            {
                grow += 2;  /* 1 char plus backslash */
            }
            else /* The other low ordinals are output as an octal escape
                  * sequence */
                 if (s + 1 >= send || (   *(U8*)(s+1) >= '0'
                                       && *(U8*)(s+1) <= '9'))
            {
                /* When the following character is a digit, use 3 octal digits
                 * plus backslash, as using fewer digits would concatenate the
                 * following char into this one */
                grow += 4;
            }
            else if (k <= 7) {
                grow += 2;  /* 1 octal digit, plus backslash */
            }
            else if (k <= 077) {
                grow += 3;  /* 2 octal digits plus backslash */
            }
            else {
                grow += 4;  /* 3 octal digits plus backslash */
            }
        }
    } /* End of size-calculating loop */

    if (grow || useqq) {
        /* We have something needing hex. 3 is ""\0 */
        sv_grow(sv, cur + 3 + grow + 2*backslashes + single_quotes
		+ 2*qq_escapables + normal);
        rstart = r = SvPVX(sv) + cur;

        *r++ = '"';

        for (s = src; s < send; s += increment) {
            UV k;

            if (do_utf8
                && ! isASCII(*s)
                    /* Exclude non-ASCII low ordinal controls.  This should be
                     * optimized out by the compiler on ASCII platforms; if not
                     * could wrap it in a #ifdef EBCDIC, but better to avoid
                     * #if's if possible */
                && *(U8*)s > ' '
            ) {

                /* When in UTF-8, we output all non-ascii chars as \x{}
                 * reqardless of useqq, except for the low ordinal controls on
                 * EBCDIC platforms */
                k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);

                /* treat invalid utf8 byte by byte.  This loop iteration gets the
                * first byte */
                increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

#if PERL_VERSION < 10
                sprintf(r, "\\x{%"UVxf"}", k);
                r += strlen(r);
                /* my_sprintf is not supported by ppport.h */
#else
                r = r + my_sprintf(r, "\\x{%"UVxf"}", k);
#endif
                continue;
            }

            /* Here 1) isn't UTF-8; or
             *      2) the current character is ASCII; or
             *      3) it is an EBCDIC platform and is a low ordinal
             *         non-ASCII control.
             * In each case the character occupies just one byte */
            k = *(U8*)s;
            increment = 1;

            if (isPRINT(k)) {
                /* These need a backslash escape */
                if (k == '"' || k == '\\' || k == '$' || k == '@@') {
                    *r++ = '\\';
                }

                *r++ = (char)k;
            }
            else if (! useqq) { /* non-qq, non-printable, low-ordinal is
                                 * output raw */
                *r++ = (char)k;
            }
            else {  /* Is qq means use escape sequences */
	        bool next_is_digit;

		*r++ = '\\';
		switch (k) {
		case '\a':  *r++ = 'a'; break;
		case '\b':  *r++ = 'b'; break;
		case '\t':  *r++ = 't'; break;
		case '\n':  *r++ = 'n'; break;
		case '\f':  *r++ = 'f'; break;
		case '\r':  *r++ = 'r'; break;
		case ESC_NATIVE: *r++ = 'e'; break;
		default:

		    /* only ASCII digits matter here, which are invariant,
		     * since we only encode characters \377 and under, or
		     * \x177 and under for a unicode string
		     */
                    next_is_digit = (s + 1 >= send )
                                    ? FALSE
                                    : (*(U8*)(s+1) >= '0' && *(U8*)(s+1) <= '9');

		    /* faster than
		     * r = r + my_sprintf(r, "%o", k);
		     */
		    if (k <= 7 && !next_is_digit) {
			*r++ = (char)k + '0';
		    } else if (k <= 63 && !next_is_digit) {
			*r++ = (char)(k>>3) + '0';
			*r++ = (char)(k&7) + '0';
		    } else {
			*r++ = (char)(k>>6) + '0';
			*r++ = (char)((k&63)>>3) + '0';
			*r++ = (char)(k&7) + '0';
		    }
		}
	    }
        }
        *r++ = '"';
    } else {
        /* Single quotes.  */
        sv_grow(sv, cur + 3 + 2*backslashes + 2*single_quotes
		+ qq_escapables + normal);
        rstart = r = SvPVX(sv) + cur;
        *r++ = '\'';
        for (s = src; s < send; s ++) {
            const char k = *s;
            if (k == '\'' || k == '\\')
                *r++ = '\\';
            *r++ = k;
        }
        *r++ = '\'';
    }
    *r = '\0';
    j = r - rstart;
    SvCUR_set(sv, cur + j);

    return j;
}

/* append a repeated string to an SV */
static SV *
sv_x(pTHX_ SV *sv, const char *str, STRLEN len, I32 n)
{
    if (!sv)
	sv = newSVpvs("");
#ifdef DEBUGGING
    else
	assert(SvTYPE(sv) >= SVt_PV);
#endif

    if (n > 0) {
	SvGROW(sv, len*n + SvCUR(sv) + 1);
	if (len == 1) {
	    char * const start = SvPVX(sv) + SvCUR(sv);
	    SvCUR_set(sv, SvCUR(sv) + n);
	    start[n] = '\0';
	    while (n > 0)
		start[--n] = str[0];
	}
	else
	    while (n > 0) {
		sv_catpvn(sv, str, len);
		--n;
	    }
    }
    return sv;
}

/*
 * This ought to be split into smaller functions. (it is one long function since
 * it exactly parallels the perl version, which was one long thing for
 * efficiency raisins.)  Ugggh!
 */
static I32
DD_dump(pTHX_ SV *val, const char *name, STRLEN namelen, SV *retval, HV *seenhv,
	AV *postav, const I32 level, SV *apad, const Style *style)
{
    char tmpbuf[128];
    Size_t i;
    char *c, *r, *realpack;
#ifdef DD_USE_OLD_ID_FORMAT
    char id[128];
#else
    UV id_buffer;
    char *const id = (char *)&id_buffer;
#endif
    SV **svp;
    SV *sv, *ipad, *ival;
    SV *blesspad = Nullsv;
    AV *seenentry = NULL;
    char *iname;
    STRLEN inamelen, idlen = 0;
    U32 realtype;
    bool no_bless = 0; /* when a qr// is blessed into Regexp we dont want to bless it.
                          in later perls we should actually check the classname of the 
                          engine. this gets tricky as it involves lexical issues that arent so
                          easy to resolve */
    bool is_regex = 0; /* we are dumping a regex, we need to know this before we bless */

    if (!val)
	return 0;

    /* If the output buffer has less than some arbitrary amount of space
       remaining, then enlarge it. For the test case (25M of output),
       *1.1 was slower, *2.0 was the same, so the first guess of 1.5 is
	deemed to be good enough.  */
    if (SvTYPE(retval) >= SVt_PV && (SvLEN(retval) - SvCUR(retval)) < 42) {
	sv_grow(retval, SvCUR(retval) * 3 / 2);
    }

    realtype = SvTYPE(val);

    if (SvGMAGICAL(val))
        mg_get(val);
    if (SvROK(val)) {

        /* If a freeze method is provided and the object has it, call
           it.  Warn on errors. */
        if (SvOBJECT(SvRV(val)) && style->freezer &&
            SvPOK(style->freezer) && SvCUR(style->freezer) &&
            gv_fetchmeth(SvSTASH(SvRV(val)), SvPVX_const(style->freezer),
                         SvCUR(style->freezer), -1) != NULL)
	{
	    dSP; ENTER; SAVETMPS; PUSHMARK(sp);
	    XPUSHs(val); PUTBACK;
            i = perl_call_method(SvPVX_const(style->freezer), G_EVAL|G_VOID|G_DISCARD);
	    SPAGAIN;
	    if (SvTRUE(ERRSV))
		warn("WARNING(Freezer method call failed): %"SVf"", ERRSV);
	    PUTBACK; FREETMPS; LEAVE;
	}
	
	ival = SvRV(val);
	realtype = SvTYPE(ival);
#ifdef DD_USE_OLD_ID_FORMAT
        idlen = my_snprintf(id, sizeof(id), "0x%"UVxf, PTR2UV(ival));
#else
	id_buffer = PTR2UV(ival);
	idlen = sizeof(id_buffer);
#endif
	if (SvOBJECT(ival))
	    realpack = HvNAME_get(SvSTASH(ival));
	else
	    realpack = NULL;

	/* if it has a name, we need to either look it up, or keep a tab
	 * on it so we know when we hit it later
	 */
	if (namelen) {
	    if ((svp = hv_fetch(seenhv, id, idlen, FALSE))
		&& (sv = *svp) && SvROK(sv) && (seenentry = (AV*)SvRV(sv)))
	    {
		SV *othername;
		if ((svp = av_fetch(seenentry, 0, FALSE))
		    && (othername = *svp))
		{
		    if (style->purity && level > 0) {
			SV *postentry;
			
			if (realtype == SVt_PVHV)
			    sv_catpvs(retval, "{}");
			else if (realtype == SVt_PVAV)
			    sv_catpvs(retval, "[]");
			else
			    sv_catpvs(retval, "do{my $o}");
			postentry = newSVpvn(name, namelen);
			sv_catpvs(postentry, " = ");
			sv_catsv(postentry, othername);
			av_push(postav, postentry);
		    }
		    else {
			if (name[0] == '@@' || name[0] == '%') {
			    if ((SvPVX_const(othername))[0] == '\\' &&
				(SvPVX_const(othername))[1] == name[0]) {
				sv_catpvn(retval, SvPVX_const(othername)+1,
					  SvCUR(othername)-1);
			    }
			    else {
				sv_catpvn(retval, name, 1);
				sv_catpvs(retval, "{");
				sv_catsv(retval, othername);
				sv_catpvs(retval, "}");
			    }
			}
			else
			    sv_catsv(retval, othername);
		    }
		    return 1;
		}
		else {
#ifdef DD_USE_OLD_ID_FORMAT
		    warn("ref name not found for %s", id);
#else
		    warn("ref name not found for 0x%"UVxf, PTR2UV(ival));
#endif
		    return 0;
		}
	    }
	    else {   /* store our name and continue */
		SV *namesv;
		if (name[0] == '@@' || name[0] == '%') {
		    namesv = newSVpvs("\\");
		    sv_catpvn(namesv, name, namelen);
		}
		else if (realtype == SVt_PVCV && name[0] == '*') {
		    namesv = newSVpvs("\\");
		    sv_catpvn(namesv, name, namelen);
		    (SvPVX(namesv))[1] = '&';
		}
		else
		    namesv = newSVpvn(name, namelen);
		seenentry = newAV();
		av_push(seenentry, namesv);
		(void)SvREFCNT_inc(val);
		av_push(seenentry, val);
		(void)hv_store(seenhv, id, idlen,
			       newRV_inc((SV*)seenentry), 0);
		SvREFCNT_dec(seenentry);
	    }
	}
        /* regexps dont have to be blessed into package "Regexp"
         * they can be blessed into any package. 
         */
#if PERL_VERSION < 8
	if (realpack && *realpack == 'R' && strEQ(realpack, "Regexp")) 
#elif PERL_VERSION < 11
        if (realpack && realtype == SVt_PVMG && mg_find(ival, PERL_MAGIC_qr))
#else        
        if (realpack && realtype == SVt_REGEXP) 
#endif
        {
            is_regex = 1;
            if (strEQ(realpack, "Regexp")) 
                no_bless = 1;
            else
                no_bless = 0;
        }

	/* If purity is not set and maxdepth is set, then check depth:
	 * if we have reached maximum depth, return the string
	 * representation of the thing we are currently examining
	 * at this depth (i.e., 'Foo=ARRAY(0xdeadbeef)').
	 */
        if (!style->purity && style->maxdepth > 0 && level >= style->maxdepth) {
	    STRLEN vallen;
	    const char * const valstr = SvPV(val,vallen);
	    sv_catpvs(retval, "'");
	    sv_catpvn(retval, valstr, vallen);
	    sv_catpvs(retval, "'");
	    return 1;
	}

        if (style->maxrecurse > 0 && level >= style->maxrecurse) {
            croak("Recursion limit of %" IVdf " exceeded", style->maxrecurse);
	}

	if (realpack && !no_bless) {				/* we have a blessed ref */
	    STRLEN blesslen;
            const char * const blessstr = SvPV(style->bless, blesslen);
	    sv_catpvn(retval, blessstr, blesslen);
	    sv_catpvs(retval, "( ");
            if (style->indent >= 2) {
		blesspad = apad;
		apad = newSVsv(apad);
		sv_x(aTHX_ apad, " ", 1, blesslen+2);
	    }
	}

        ipad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad), SvCUR(style->xpad), level+1);

        if (is_regex) 
        {
            STRLEN rlen;
	    SV *sv_pattern = NULL;
	    SV *sv_flags = NULL;
	    CV *re_pattern_cv;
	    const char *rval;
	    const char *rend;
	    const char *slash;

	    if ((re_pattern_cv = get_cv("re::regexp_pattern", 0))) {
	      dSP;
	      I32 count;
	      ENTER;
	      SAVETMPS;
	      PUSHMARK(SP);
	      XPUSHs(val);
	      PUTBACK;
	      count = call_sv((SV*)re_pattern_cv, G_ARRAY);
	      SPAGAIN;
	      if (count >= 2) {
		sv_flags = POPs;
	        sv_pattern = POPs;
		SvREFCNT_inc(sv_flags);
		SvREFCNT_inc(sv_pattern);
	      }
	      PUTBACK;
	      FREETMPS;
	      LEAVE;
	      if (sv_pattern) {
	        sv_2mortal(sv_pattern);
	        sv_2mortal(sv_flags);
	      }
	    }
	    else {
	      sv_pattern = val;
	    }
	    assert(sv_pattern);
	    rval = SvPV(sv_pattern, rlen);
	    rend = rval+rlen;
	    slash = rval;
	    sv_catpvs(retval, "qr/");
	    for (;slash < rend; slash++) {
	      if (*slash == '\\') { ++slash; continue; }
	      if (*slash == '/') {    
		sv_catpvn(retval, rval, slash-rval);
		sv_catpvs(retval, "\\/");
		rlen -= slash-rval+1;
		rval = slash+1;
	      }
	    }
	    sv_catpvn(retval, rval, rlen);
	    sv_catpvs(retval, "/");
	    if (sv_flags)
	      sv_catsv(retval, sv_flags);
	} 
        else if (
#if PERL_VERSION < 9
		realtype <= SVt_PVBM
#else
		realtype <= SVt_PVMG
#endif
	) {			     /* scalar ref */
	    SV * const namesv = newSVpvs("${");
	    sv_catpvn(namesv, name, namelen);
	    sv_catpvs(namesv, "}");
	    if (realpack) {				     /* blessed */
		sv_catpvs(retval, "do{\\(my $o = ");
		DD_dump(aTHX_ ival, SvPVX_const(namesv), SvCUR(namesv), retval, seenhv,
			postav, level+1, apad, style);
		sv_catpvs(retval, ")}");
	    }						     /* plain */
	    else {
		sv_catpvs(retval, "\\");
		DD_dump(aTHX_ ival, SvPVX_const(namesv), SvCUR(namesv), retval, seenhv,
			postav, level+1, apad, style);
	    }
	    SvREFCNT_dec(namesv);
	}
	else if (realtype == SVt_PVGV) {		     /* glob ref */
	    SV * const namesv = newSVpvs("*{");
	    sv_catpvn(namesv, name, namelen);
	    sv_catpvs(namesv, "}");
	    sv_catpvs(retval, "\\");
	    DD_dump(aTHX_ ival, SvPVX_const(namesv), SvCUR(namesv), retval, seenhv,
		    postav, level+1, apad, style);
	    SvREFCNT_dec(namesv);
	}
	else if (realtype == SVt_PVAV) {
	    SV *totpad;
	    SSize_t ix = 0;
	    const SSize_t ixmax = av_len((AV *)ival);
	
	    SV * const ixsv = newSViv(0);
	    /* allowing for a 24 char wide array index */
	    New(0, iname, namelen+28, char);
	    (void)strcpy(iname, name);
	    inamelen = namelen;
	    if (name[0] == '@@') {
		sv_catpvs(retval, "(");
		iname[0] = '$';
	    }
	    else {
		sv_catpvs(retval, "[");
		/* omit "->" in $foo{bar}->[0], but not in ${$foo}->[0] */
		/*if (namelen > 0
		    && name[namelen-1] != ']' && name[namelen-1] != '}'
		    && (namelen < 4 || (name[1] != '{' && name[2] != '{')))*/
		if ((namelen > 0
		     && name[namelen-1] != ']' && name[namelen-1] != '}')
		    || (namelen > 4
		        && (name[1] == '{'
			    || (name[0] == '\\' && name[2] == '{'))))
		{
		    iname[inamelen++] = '-'; iname[inamelen++] = '>';
		    iname[inamelen] = '\0';
		}
	    }
	    if (iname[0] == '*' && iname[inamelen-1] == '}' && inamelen >= 8 &&
		(instr(iname+inamelen-8, "{SCALAR}") ||
		 instr(iname+inamelen-7, "{ARRAY}") ||
		 instr(iname+inamelen-6, "{HASH}"))) {
		iname[inamelen++] = '-'; iname[inamelen++] = '>';
	    }
	    iname[inamelen++] = '['; iname[inamelen] = '\0';
            totpad = newSVsv(style->sep);
            sv_catsv(totpad, style->pad);
	    sv_catsv(totpad, apad);

	    for (ix = 0; ix <= ixmax; ++ix) {
		STRLEN ilen;
		SV *elem;
		svp = av_fetch((AV*)ival, ix, FALSE);
		if (svp)
		    elem = *svp;
		else
		    elem = &PL_sv_undef;
		
		ilen = inamelen;
		sv_setiv(ixsv, ix);
#if PERL_VERSION < 10
                (void) sprintf(iname+ilen, "%"IVdf, (IV)ix);
		ilen = strlen(iname);
#else
                ilen = ilen + my_sprintf(iname+ilen, "%"IVdf, (IV)ix);
#endif
		iname[ilen++] = ']'; iname[ilen] = '\0';
                if (style->indent >= 3) {
		    sv_catsv(retval, totpad);
		    sv_catsv(retval, ipad);
		    sv_catpvs(retval, "#");
		    sv_catsv(retval, ixsv);
		}
		sv_catsv(retval, totpad);
		sv_catsv(retval, ipad);
		DD_dump(aTHX_ elem, iname, ilen, retval, seenhv, postav,
			level+1, apad, style);
		if (ix < ixmax || (style->trailingcomma && style->indent >= 1))
		    sv_catpvs(retval, ",");
	    }
	    if (ixmax >= 0) {
                SV * const opad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad), SvCUR(style->xpad), level);
		sv_catsv(retval, totpad);
		sv_catsv(retval, opad);
		SvREFCNT_dec(opad);
	    }
	    if (name[0] == '@@')
		sv_catpvs(retval, ")");
	    else
		sv_catpvs(retval, "]");
	    SvREFCNT_dec(ixsv);
	    SvREFCNT_dec(totpad);
	    Safefree(iname);
	}
	else if (realtype == SVt_PVHV) {
	    SV *totpad, *newapad;
	    SV *sname;
	    HE *entry = NULL;
	    char *key;
	    STRLEN klen;
	    SV *hval;
	    AV *keys = NULL;
	
	    SV * const iname = newSVpvn(name, namelen);
	    if (name[0] == '%') {
		sv_catpvs(retval, "(");
		(SvPVX(iname))[0] = '$';
	    }
	    else {
		sv_catpvs(retval, "{");
		/* omit "->" in $foo[0]->{bar}, but not in ${$foo}->{bar} */
		if ((namelen > 0
		     && name[namelen-1] != ']' && name[namelen-1] != '}')
		    || (namelen > 4
		        && (name[1] == '{'
			    || (name[0] == '\\' && name[2] == '{'))))
		{
		    sv_catpvs(iname, "->");
		}
	    }
	    if (name[0] == '*' && name[namelen-1] == '}' && namelen >= 8 &&
		(instr(name+namelen-8, "{SCALAR}") ||
		 instr(name+namelen-7, "{ARRAY}") ||
		 instr(name+namelen-6, "{HASH}"))) {
		sv_catpvs(iname, "->");
	    }
	    sv_catpvs(iname, "{");
            totpad = newSVsv(style->sep);
            sv_catsv(totpad, style->pad);
	    sv_catsv(totpad, apad);
	
	    /* If requested, get a sorted/filtered array of hash keys */
	    if (style->sortkeys) {
#if PERL_VERSION >= 8
		if (style->sortkeys == &PL_sv_yes) {
		    keys = newAV();
		    (void)hv_iterinit((HV*)ival);
		    while ((entry = hv_iternext((HV*)ival))) {
			sv = hv_iterkeysv(entry);
			(void)SvREFCNT_inc(sv);
			av_push(keys, sv);
		    }
# ifdef USE_LOCALE_COLLATE
#       ifdef IN_LC     /* Use this if available */
                    if (IN_LC(LC_COLLATE))
#       else
                    if (IN_LOCALE)
#       endif
                    {
                        sortsv(AvARRAY(keys),
			   av_len(keys)+1,
                           Perl_sv_cmp_locale);
                    }
                    else
# endif
                    {
                        sortsv(AvARRAY(keys),
			   av_len(keys)+1,
                           Perl_sv_cmp);
                    }
		}
                else
#endif
		{
		    dSP; ENTER; SAVETMPS; PUSHMARK(sp);
		    XPUSHs(sv_2mortal(newRV_inc(ival))); PUTBACK;
		    i = perl_call_sv(style->sortkeys, G_SCALAR | G_EVAL);
		    SPAGAIN;
		    if (i) {
			sv = POPs;
			if (SvROK(sv) && (SvTYPE(SvRV(sv)) == SVt_PVAV))
			    keys = (AV*)SvREFCNT_inc(SvRV(sv));
		    }
		    if (! keys)
			warn("Sortkeys subroutine did not return ARRAYREF\n");
		    PUTBACK; FREETMPS; LEAVE;
		}
		if (keys)
		    sv_2mortal((SV*)keys);
	    }
	    else
		(void)hv_iterinit((HV*)ival);

            /* foreach (keys %hash) */
            for (i = 0; 1; i++) {
		char *nkey;
                char *nkey_buffer = NULL;
                STRLEN nticks = 0;
		SV* keysv;
		STRLEN keylen;
                STRLEN nlen;
		bool do_utf8 = FALSE;

               if (style->sortkeys) {
                   if (!(keys && (SSize_t)i <= av_len(keys))) break;
               } else {
                   if (!(entry = hv_iternext((HV *)ival))) break;
               }

		if (i)
		    sv_catpvs(retval, ",");

		if (style->sortkeys) {
		    char *key;
		    svp = av_fetch(keys, i, FALSE);
		    keysv = svp ? *svp : sv_newmortal();
		    key = SvPV(keysv, keylen);
		    svp = hv_fetch((HV*)ival, key,
                                   SvUTF8(keysv) ? -(I32)keylen : (I32)keylen, 0);
		    hval = svp ? *svp : sv_newmortal();
		}
		else {
		    keysv = hv_iterkeysv(entry);
		    hval = hv_iterval((HV*)ival, entry);
		}

		key = SvPV(keysv, keylen);
		do_utf8 = DO_UTF8(keysv);
		klen = keylen;

                sv_catsv(retval, totpad);
                sv_catsv(retval, ipad);
                /* The (very)
                   old logic was first to check utf8 flag, and if utf8 always
                   call esc_q_utf8.  This caused test to break under -Mutf8,
                   because there even strings like 'c' have utf8 flag on.
                   Hence with quotekeys == 0 the XS code would still '' quote
                   them based on flags, whereas the perl code would not,
                   based on regexps.

                   The old logic checked that the string was a valid
                   perl glob name (foo::bar), which isn't safe under
                   strict, and differs from the perl code which only
                   accepts simple identifiers.

                   With the fix for [perl #120384] I chose to make
                   their handling of key quoting compatible between XS
                   and perl.
                 */
                if (style->quotekeys || key_needs_quote(key,keylen)) {
                    if (do_utf8 || style->useqq) {
                        STRLEN ocur = SvCUR(retval);
                        nlen = esc_q_utf8(aTHX_ retval, key, klen, do_utf8, style->useqq);
                        nkey = SvPVX(retval) + ocur;
                    }
                    else {
		        nticks = num_q(key, klen);
			New(0, nkey_buffer, klen+nticks+3, char);
                        nkey = nkey_buffer;
			nkey[0] = '\'';
			if (nticks)
			    klen += esc_q(nkey+1, key, klen);
			else
			    (void)Copy(key, nkey+1, klen, char);
			nkey[++klen] = '\'';
			nkey[++klen] = '\0';
                        nlen = klen;
                        sv_catpvn(retval, nkey, klen);
		    }
                }
                else {
                    nkey = key;
                    nlen = klen;
                    sv_catpvn(retval, nkey, klen);
		}
                sname = newSVsv(iname);
                sv_catpvn(sname, nkey, nlen);
                sv_catpvs(sname, "}");

                sv_catsv(retval, style->pair);
                if (style->indent >= 2) {
		    char *extra;
                    STRLEN elen = 0;
		    newapad = newSVsv(apad);
		    New(0, extra, klen+4+1, char);
		    while (elen < (klen+4))
			extra[elen++] = ' ';
		    extra[elen] = '\0';
		    sv_catpvn(newapad, extra, elen);
		    Safefree(extra);
		}
		else
		    newapad = apad;

		DD_dump(aTHX_ hval, SvPVX_const(sname), SvCUR(sname), retval, seenhv,
			postav, level+1, newapad, style);
		SvREFCNT_dec(sname);
		Safefree(nkey_buffer);
                if (style->indent >= 2)
		    SvREFCNT_dec(newapad);
	    }
	    if (i) {
                SV *opad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad),
                                SvCUR(style->xpad), level);
                if (style->trailingcomma && style->indent >= 1)
                    sv_catpvs(retval, ",");
		sv_catsv(retval, totpad);
		sv_catsv(retval, opad);
		SvREFCNT_dec(opad);
	    }
	    if (name[0] == '%')
		sv_catpvs(retval, ")");
	    else
		sv_catpvs(retval, "}");
	    SvREFCNT_dec(iname);
	    SvREFCNT_dec(totpad);
	}
	else if (realtype == SVt_PVCV) {
	    sv_catpvs(retval, "sub { \"DUMMY\" }");
            if (style->purity)
		warn("Encountered CODE ref, using dummy placeholder");
	}
	else {
	    warn("cannot handle ref type %d", (int)realtype);
	}

	if (realpack && !no_bless) {  /* free blessed allocs */
            STRLEN plen, pticks;

            if (style->indent >= 2) {
		SvREFCNT_dec(apad);
		apad = blesspad;
	    }
	    sv_catpvs(retval, ", '");

	    plen = strlen(realpack);
	    pticks = num_q(realpack, plen);
	    if (pticks) { /* needs escaping */
	        char *npack;
	        char *npack_buffer = NULL;

	        New(0, npack_buffer, plen+pticks+1, char);
	        npack = npack_buffer;
	        plen += esc_q(npack, realpack, plen);
	        npack[plen] = '\0';

	        sv_catpvn(retval, npack, plen);
	        Safefree(npack_buffer);
	    }
	    else {
	        sv_catpvn(retval, realpack, strlen(realpack));
	    }
	    sv_catpvs(retval, "' )");
            if (style->toaster && SvPOK(style->toaster) && SvCUR(style->toaster)) {
		sv_catpvs(retval, "->");
                sv_catsv(retval, style->toaster);
		sv_catpvs(retval, "()");
	    }
	}
	SvREFCNT_dec(ipad);
    }
    else {
	STRLEN i;
	const MAGIC *mg;
	
	if (namelen) {
#ifdef DD_USE_OLD_ID_FORMAT
	    idlen = my_snprintf(id, sizeof(id), "0x%"UVxf, PTR2UV(val));
#else
	    id_buffer = PTR2UV(val);
	    idlen = sizeof(id_buffer);
#endif
	    if ((svp = hv_fetch(seenhv, id, idlen, FALSE)) &&
		(sv = *svp) && SvROK(sv) &&
		(seenentry = (AV*)SvRV(sv)))
	    {
		SV *othername;
		if ((svp = av_fetch(seenentry, 0, FALSE)) && (othername = *svp)
		    && (svp = av_fetch(seenentry, 2, FALSE)) && *svp && SvIV(*svp) > 0)
		{
		    sv_catpvs(retval, "${");
		    sv_catsv(retval, othername);
		    sv_catpvs(retval, "}");
		    return 1;
		}
	    }
            /* If we're allowed to keep only a sparse "seen" hash
             * (IOW, the user does not expect it to contain everything
             * after the dump, then only store in seen hash if the SV
             * ref count is larger than 1. If it's 1, then we know that
             * there is no other reference, duh. This is an optimization.
             * Note that we'd have to check for weak-refs, too, but this is
             * already the branch for non-refs only. */
            else if (val != &PL_sv_undef && (!style->use_sparse_seen_hash || SvREFCNT(val) > 1)) {
		SV * const namesv = newSVpvs("\\");
		sv_catpvn(namesv, name, namelen);
		seenentry = newAV();
		av_push(seenentry, namesv);
		av_push(seenentry, newRV_inc(val));
		(void)hv_store(seenhv, id, idlen, newRV_inc((SV*)seenentry), 0);
		SvREFCNT_dec(seenentry);
	    }
	}

        if (DD_is_integer(val)) {
            STRLEN len;
	    if (SvIsUV(val))
	      len = my_snprintf(tmpbuf, sizeof(tmpbuf), "%"UVuf, SvUV(val));
	    else
	      len = my_snprintf(tmpbuf, sizeof(tmpbuf), "%"IVdf, SvIV(val));
            if (SvPOK(val)) {
              /* Need to check to see if this is a string such as " 0".
                 I'm assuming from sprintf isn't going to clash with utf8. */
              STRLEN pvlen;
              const char * const pv = SvPV(val, pvlen);
              if (pvlen != len || memNE(pv, tmpbuf, len))
                goto integer_came_from_string;
            }
            if (len > 10) {
              /* Looks like we're on a 64 bit system.  Make it a string so that
                 if a 32 bit system reads the number it will cope better.  */
              sv_catpvf(retval, "'%s'", tmpbuf);
            } else
              sv_catpvn(retval, tmpbuf, len);
	}
	else if (realtype == SVt_PVGV) {/* GLOBs can end up with scribbly names */
	    c = SvPV(val, i);
	    if(i) ++c, --i;			/* just get the name */
	    if (i >= 6 && strncmp(c, "main::", 6) == 0) {
		c += 4;
#if PERL_VERSION < 7
		if (i == 6 || (i == 7 && c[6] == '\0'))
#else
		if (i == 6)
#endif
		    i = 0; else i -= 4;
	    }
            if (globname_needs_quote(c,i)) {
#ifdef GvNAMEUTF8
	      if (GvNAMEUTF8(val)) {
		sv_grow(retval, SvCUR(retval)+2);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '*'; r[1] = '{';
		SvCUR_set(retval, SvCUR(retval)+2);
                esc_q_utf8(aTHX_ retval, c, i, 1, style->useqq);
		sv_grow(retval, SvCUR(retval)+2);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '}'; r[1] = '\0';
		i = 1;
	      }
	      else
#endif
	      {
		sv_grow(retval, SvCUR(retval)+6+2*i);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '*'; r[1] = '{';	r[2] = '\'';
		i += esc_q(r+3, c, i);
		i += 3;
		r[i++] = '\''; r[i++] = '}';
		r[i] = '\0';
	      }
	    }
	    else {
		sv_grow(retval, SvCUR(retval)+i+2);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '*'; strcpy(r+1, c);
		i++;
	    }
	    SvCUR_set(retval, SvCUR(retval)+i);

            if (style->purity) {
		static const char* const entries[] = { "{SCALAR}", "{ARRAY}", "{HASH}" };
		static const STRLEN sizes[] = { 8, 7, 6 };
		SV *e;
		SV * const nname = newSVpvs("");
		SV * const newapad = newSVpvs("");
		GV * const gv = (GV*)val;
		I32 j;
		
		for (j=0; j<3; j++) {
		    e = ((j == 0) ? GvSV(gv) : (j == 1) ? (SV*)GvAV(gv) : (SV*)GvHV(gv));
		    if (!e)
			continue;
		    if (j == 0 && !SvOK(e))
			continue;

		    {
			SV *postentry = newSVpvn(r,i);
			
			sv_setsv(nname, postentry);
			sv_catpvn(nname, entries[j], sizes[j]);
			sv_catpvs(postentry, " = ");
			av_push(postav, postentry);
			e = newRV_inc(e);
			
			SvCUR_set(newapad, 0);
                        if (style->indent >= 2)
			    (void)sv_x(aTHX_ newapad, " ", 1, SvCUR(postentry));
			
			DD_dump(aTHX_ e, SvPVX_const(nname), SvCUR(nname), postentry,
				seenhv, postav, 0, newapad, style);
			SvREFCNT_dec(e);
		    }
		}
		
		SvREFCNT_dec(newapad);
		SvREFCNT_dec(nname);
	    }
	}
	else if (val == &PL_sv_undef || !SvOK(val)) {
	    sv_catpvs(retval, "undef");
	}
#ifdef SvVOK
	else if (SvMAGICAL(val) && (mg = mg_find(val, 'V'))) {
# if !defined(PL_vtbl_vstring) && PERL_VERSION < 17
	    SV * const vecsv = sv_newmortal();
#  if PERL_VERSION < 10
	    scan_vstring(mg->mg_ptr, vecsv);
#  else
	    scan_vstring(mg->mg_ptr, mg->mg_ptr + mg->mg_len, vecsv);
#  endif
	    if (!sv_eq(vecsv, val)) goto integer_came_from_string;
# endif
	    sv_catpvn(retval, (const char *)mg->mg_ptr, mg->mg_len);
	}
#endif

	else {
        integer_came_from_string:
            c = SvPV(val, i);
            /* the pure perl and XS non-qq outputs have historically been
             * different in this case, but for useqq, let's try to match
             * the pure perl code.
             * see [perl #74798]
             */
            if (style->useqq && safe_decimal_number(c, i)) {
                sv_catsv(retval, val);
            }
            else if (DO_UTF8(val) || style->useqq)
                i += esc_q_utf8(aTHX_ retval, c, i, DO_UTF8(val), style->useqq);
	    else {
		sv_grow(retval, SvCUR(retval)+3+2*i); /* 3: ""\0 */
		r = SvPVX(retval) + SvCUR(retval);
		r[0] = '\'';
		i += esc_q(r+1, c, i);
		++i;
		r[i++] = '\'';
		r[i] = '\0';
		SvCUR_set(retval, SvCUR(retval)+i);
	    }
	}
    }

    if (idlen) {
        if (style->deepcopy)
	    (void)hv_delete(seenhv, id, idlen, G_DISCARD);
	else if (namelen && seenentry) {
	    SV *mark = *av_fetch(seenentry, 2, TRUE);
	    sv_setiv(mark,1);
	}
    }
    return 1;
}


MODULE = Data::Dumper		PACKAGE = Data::Dumper         PREFIX = Data_Dumper_

#
# This is the exact equivalent of Dump.  Well, almost. The things that are
# different as of now (due to Laziness):
#   * doesn't do deparse yet.'
#

void
Data_Dumper_Dumpxs(href, ...)
	SV	*href;
	PROTOTYPE: $;$$
	PPCODE:
	{
	    HV *hv;
	    SV *retval, *valstr;
	    HV *seenhv = NULL;
	    AV *postav, *todumpav, *namesav;
	    I32 terse = 0;
	    SSize_t i, imax, postlen;
	    SV **svp;
            SV *apad = &PL_sv_undef;
            Style style;

            SV *name, *val = &PL_sv_undef, *varname = &PL_sv_undef;
	    char tmpbuf[1024];
	    I32 gimme = GIMME_V;

	    if (!SvROK(href)) {		/* call new to get an object first */
		if (items < 2)
		    croak("Usage: Data::Dumper::Dumpxs(PACKAGE, VAL_ARY_REF, [NAME_ARY_REF])");
		
		ENTER;
		SAVETMPS;
		
		PUSHMARK(sp);
                EXTEND(SP, 3); /* 3 == max of all branches below */
		PUSHs(href);
		PUSHs(sv_2mortal(newSVsv(ST(1))));
		if (items >= 3)
		    PUSHs(sv_2mortal(newSVsv(ST(2))));
		PUTBACK;
		i = perl_call_method("new", G_SCALAR);
		SPAGAIN;
		if (i)
		    href = newSVsv(POPs);

		PUTBACK;
		FREETMPS;
		LEAVE;
		if (i)
		    (void)sv_2mortal(href);
	    }

	    todumpav = namesav = NULL;
            style.indent = 2;
            style.quotekeys = 1;
            style.maxrecurse = 1000;
            style.purity = style.deepcopy = style.useqq = style.maxdepth
                = style.use_sparse_seen_hash = style.trailingcomma = 0;
            style.pad = style.xpad = style.sep = style.pair = style.sortkeys
                = style.freezer = style.toaster = style.bless = &PL_sv_undef;
	    seenhv = NULL;
	    name = sv_newmortal();
	
	    retval = newSVpvs("");
	    if (SvROK(href)
		&& (hv = (HV*)SvRV((SV*)href))
		&& SvTYPE(hv) == SVt_PVHV)		{

		if ((svp = hv_fetch(hv, "seen", 4, FALSE)) && SvROK(*svp))
		    seenhv = (HV*)SvRV(*svp);
                else
                    style.use_sparse_seen_hash = 1;
		if ((svp = hv_fetch(hv, "noseen", 6, FALSE)))
                    style.use_sparse_seen_hash = (SvOK(*svp) && SvIV(*svp) != 0);
		if ((svp = hv_fetch(hv, "todump", 6, FALSE)) && SvROK(*svp))
		    todumpav = (AV*)SvRV(*svp);
		if ((svp = hv_fetch(hv, "names", 5, FALSE)) && SvROK(*svp))
		    namesav = (AV*)SvRV(*svp);
		if ((svp = hv_fetch(hv, "indent", 6, FALSE)))
                    style.indent = SvIV(*svp);
		if ((svp = hv_fetch(hv, "purity", 6, FALSE)))
                    style.purity = SvIV(*svp);
		if ((svp = hv_fetch(hv, "terse", 5, FALSE)))
		    terse = SvTRUE(*svp);
		if ((svp = hv_fetch(hv, "useqq", 5, FALSE)))
                    style.useqq = SvTRUE(*svp);
		if ((svp = hv_fetch(hv, "pad", 3, FALSE)))
                    style.pad = *svp;
		if ((svp = hv_fetch(hv, "xpad", 4, FALSE)))
                    style.xpad = *svp;
		if ((svp = hv_fetch(hv, "apad", 4, FALSE)))
		    apad = *svp;
		if ((svp = hv_fetch(hv, "sep", 3, FALSE)))
                    style.sep = *svp;
		if ((svp = hv_fetch(hv, "pair", 4, FALSE)))
                    style.pair = *svp;
		if ((svp = hv_fetch(hv, "varname", 7, FALSE)))
		    varname = *svp;
		if ((svp = hv_fetch(hv, "freezer", 7, FALSE)))
                    style.freezer = *svp;
		if ((svp = hv_fetch(hv, "toaster", 7, FALSE)))
                    style.toaster = *svp;
		if ((svp = hv_fetch(hv, "deepcopy", 8, FALSE)))
                    style.deepcopy = SvTRUE(*svp);
		if ((svp = hv_fetch(hv, "quotekeys", 9, FALSE)))
                    style.quotekeys = SvTRUE(*svp);
                if ((svp = hv_fetch(hv, "trailingcomma", 13, FALSE)))
                    style.trailingcomma = SvTRUE(*svp);
		if ((svp = hv_fetch(hv, "bless", 5, FALSE)))
                    style.bless = *svp;
		if ((svp = hv_fetch(hv, "maxdepth", 8, FALSE)))
                    style.maxdepth = SvIV(*svp);
		if ((svp = hv_fetch(hv, "maxrecurse", 10, FALSE)))
                    style.maxrecurse = SvIV(*svp);
		if ((svp = hv_fetch(hv, "sortkeys", 8, FALSE))) {
                    SV *sv = *svp;
                    if (! SvTRUE(sv))
                        style.sortkeys = NULL;
                    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
                        style.sortkeys = sv;
                    else if (PERL_VERSION < 8)
                        /* 5.6 doesn't make sortsv() available to XS code,
                         * so we must use this helper instead. Note that we
                         * always allocate this mortal SV, but it will be
                         * used only if at least one hash is encountered
                         * while dumping recursively; an older version
                         * allocated it lazily as needed. */
                        style.sortkeys = sv_2mortal(newSVpvs("Data::Dumper::_sortkeys"));
                    else
                        /* flag to use sortsv() for sorting hash keys */
                        style.sortkeys = &PL_sv_yes;
		}
		postav = newAV();

		if (todumpav)
		    imax = av_len(todumpav);
		else
		    imax = -1;
		valstr = newSVpvs("");
		for (i = 0; i <= imax; ++i) {
		    SV *newapad;
		
		    av_clear(postav);
		    if ((svp = av_fetch(todumpav, i, FALSE)))
			val = *svp;
		    else
			val = &PL_sv_undef;
		    if ((svp = av_fetch(namesav, i, TRUE))) {
			sv_setsv(name, *svp);
			if (SvOK(*svp) && !SvPOK(*svp))
			    (void)SvPV_nolen_const(name);
		    }
		    else
			(void)SvOK_off(name);
		
		    if (SvPOK(name)) {
			if ((SvPVX_const(name))[0] == '*') {
			    if (SvROK(val)) {
				switch (SvTYPE(SvRV(val))) {
				case SVt_PVAV:
				    (SvPVX(name))[0] = '@@';
				    break;
				case SVt_PVHV:
				    (SvPVX(name))[0] = '%';
				    break;
				case SVt_PVCV:
				    (SvPVX(name))[0] = '*';
				    break;
				default:
				    (SvPVX(name))[0] = '$';
				    break;
				}
			    }
			    else
				(SvPVX(name))[0] = '$';
			}
			else if ((SvPVX_const(name))[0] != '$')
			    sv_insert(name, 0, 0, "$", 1);
		    }
		    else {
			STRLEN nchars;
			sv_setpvn(name, "$", 1);
			sv_catsv(name, varname);
			nchars = my_snprintf(tmpbuf, sizeof(tmpbuf), "%"IVdf, (IV)(i+1));
			sv_catpvn(name, tmpbuf, nchars);
		    }
		
                    if (style.indent >= 2 && !terse) {
			SV * const tmpsv = sv_x(aTHX_ NULL, " ", 1, SvCUR(name)+3);
			newapad = newSVsv(apad);
			sv_catsv(newapad, tmpsv);
			SvREFCNT_dec(tmpsv);
		    }
		    else
			newapad = apad;
		
		    PUTBACK;
		    DD_dump(aTHX_ val, SvPVX_const(name), SvCUR(name), valstr, seenhv,
                            postav, 0, newapad, &style);
		    SPAGAIN;
		
                    if (style.indent >= 2 && !terse)
			SvREFCNT_dec(newapad);

		    postlen = av_len(postav);
		    if (postlen >= 0 || !terse) {
			sv_insert(valstr, 0, 0, " = ", 3);
			sv_insert(valstr, 0, 0, SvPVX_const(name), SvCUR(name));
			sv_catpvs(valstr, ";");
		    }
                    sv_catsv(retval, style.pad);
		    sv_catsv(retval, valstr);
                    sv_catsv(retval, style.sep);
		    if (postlen >= 0) {
			SSize_t i;
                        sv_catsv(retval, style.pad);
			for (i = 0; i <= postlen; ++i) {
			    SV *elem;
			    svp = av_fetch(postav, i, FALSE);
			    if (svp && (elem = *svp)) {
				sv_catsv(retval, elem);
				if (i < postlen) {
				    sv_catpvs(retval, ";");
                                    sv_catsv(retval, style.sep);
                                    sv_catsv(retval, style.pad);
				}
			    }
			}
			sv_catpvs(retval, ";");
                        sv_catsv(retval, style.sep);
		    }
		    sv_setpvn(valstr, "", 0);
		    if (gimme == G_ARRAY) {
			XPUSHs(sv_2mortal(retval));
			if (i < imax)	/* not the last time thro ? */
			    retval = newSVpvs("");
		    }
		}
		SvREFCNT_dec(postav);
		SvREFCNT_dec(valstr);
	    }
	    else
		croak("Call to new() method failed to return HASH ref");
	    if (gimme != G_ARRAY)
		XPUSHs(sv_2mortal(retval));
	}

SV *
Data_Dumper__vstring(sv)
	SV	*sv;
	PROTOTYPE: $
	CODE:
	{
#ifdef SvVOK
	    const MAGIC *mg;
	    RETVAL =
		SvMAGICAL(sv) && (mg = mg_find(sv, 'V'))
		 ? newSVpvn((const char *)mg->mg_ptr, mg->mg_len)
		 : &PL_sv_undef;
#else
	    RETVAL = &PL_sv_undef;
#endif
	}
	OUTPUT: RETVAL
@


1.5
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d15 24
d40 2
a41 1
#   define isWORDCHAR(c) isALNUM(c)
d44 27
a70 3
static I32 num_q (const char *s, STRLEN slen);
static I32 esc_q (char *dest, const char *src, STRLEN slen);
static I32 esc_q_utf8 (pTHX_ SV *sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq);
d76 2
a77 5
		    HV *seenhv, AV *postav, I32 *levelp, I32 indent,
		    SV *pad, SV *xpad, SV *apad, SV *sep, SV *pair,
		    SV *freezer, SV *toaster,
		    I32 purity, I32 deepcopy, I32 quotekeys, SV *bless,
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash, I32 useqq, IV maxrecurse);
a88 6
# ifdef EBCDIC
#  define UNI_TO_NATIVE(ch) (((ch) > 255) ? (ch) : ASCII_TO_NATIVE(ch))
# else
#  define UNI_TO_NATIVE(ch) (ch)
# endif

d115 1
a115 2
    const UV uv = utf8_to_uvchr(s, retlen);
    return UNI_TO_NATIVE(uv);
d220 1
a220 1
static I32
d223 1
a223 1
    I32 ret = 0;
d238 1
a238 1
static I32
d241 1
a241 1
    I32 ret = 0;
d249 1
d260 1
a260 1
static I32
a275 1
    UV next;
d277 33
a309 12
    /* this will need EBCDICification */
    for (s = src; s < send; do_utf8 ? s += increment : s++) {
        const UV k = do_utf8 ? utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL) : *(U8*)s;

        /* check for invalid utf8 */
        increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

	/* this is only used to check if the next character is an
	 * ASCII digit, which are invariant, so if the following collects
	 * a UTF-8 start byte it does no harm
	 */
	next = (s + increment >= send ) ? 0 : *(U8*)(s+increment);
d311 1
a311 7
#ifdef EBCDIC
	if (!isprint(k) || k > 256) {
#else
	if (k > 127) {
#endif
            /* 4: \x{} then count the number of hex digits.  */
            grow += 4 + (k <= 0xFF ? 2 : k <= 0xFFF ? 3 : k <= 0xFFFF ? 4 :
d313 1
a313 1
                8 /* We may allocate a bit more than the minimum here.  */
d315 1
a315 1
                k <= 0xFFFFFFFF ? 8 : UVSIZE * 4
d317 12
a328 19
                );
#ifndef EBCDIC
	} else if (useqq &&
	    /* we can't use the short form like '\0' if followed by a digit */
                   (((k >= 7 && k <= 10) || k == 12 || k == 13 || k == 27)
                 || (k < 8 && (next < '0' || next > '9')))) {
	    grow += 2;
	} else if (useqq && k <= 31 && (next < '0' || next > '9')) {
	    grow += 3;
	} else if (useqq && (k <= 31 || k >= 127)) {
	    grow += 4;
#endif
        } else if (k == '\\') {
            backslashes++;
        } else if (k == '\'') {
            single_quotes++;
        } else if (k == '"' || k == '$' || k == '@@') {
            qq_escapables++;
        } else {
d331 29
a359 1
    }
d368 2
a369 2
        for (s = src; s < send; do_utf8 ? s += UTF8SKIP(s) : s++) {
            const UV k = do_utf8 ? utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL) : *(U8*)s;
d371 46
a416 2
            if (k == '"' || k == '\\' || k == '$' || k == '@@') {
                *r++ = '\\';
d419 1
a419 5
            else
#ifdef EBCDIC
	      if (isprint(k) && k < 256)
#else
	      if (useqq && (k <= 31 || k == 127 || (!do_utf8 && k > 127))) {
d424 7
a430 7
		case 7:  *r++ = 'a'; break;
		case 8:  *r++ = 'b'; break;
		case 9:  *r++ = 't'; break;
		case 10: *r++ = 'n'; break;
		case 12: *r++ = 'f'; break;
		case 13: *r++ = 'r'; break;
		case 27: *r++ = 'e'; break;
a431 1
		    increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);
d437 3
a439 2
		    next = (s+increment < send) ? *(U8*)(s+increment) : 0;
		    next_is_digit = next >= '0' && next <= '9';
a455 12
	    else if (k < 0x80)
#endif
                *r++ = (char)k;
            else {
#if PERL_VERSION < 10
                sprintf(r, "\\x{%"UVxf"}", k);
                r += strlen(r);
                /* my_sprintf is not supported by ppport.h */
#else
                r = r + my_sprintf(r, "\\x{%"UVxf"}", k);
#endif
            }
d484 1
a484 1
	sv = newSVpvn("", 0);
d515 1
a515 4
	AV *postav, I32 *levelp, I32 indent, SV *pad, SV *xpad,
	SV *apad, SV *sep, SV *pair, SV *freezer, SV *toaster, I32 purity,
	I32 deepcopy, I32 quotekeys, SV *bless, I32 maxdepth, SV *sortkeys,
        int use_sparse_seen_hash, I32 useqq, IV maxrecurse)
d542 1
a542 1
    /* If the ouput buffer has less than some arbitrary amount of space
d558 4
a561 4
	if (SvOBJECT(SvRV(val)) && freezer &&
	    SvPOK(freezer) && SvCUR(freezer) &&
            gv_fetchmeth(SvSTASH(SvRV(val)), SvPVX_const(freezer), 
                         SvCUR(freezer), -1) != NULL)
d565 1
a565 1
	    i = perl_call_method(SvPVX_const(freezer), G_EVAL|G_VOID|G_DISCARD);
d596 1
a596 1
		    if (purity && *levelp > 0) {
d600 1
a600 1
			    sv_catpvn(retval, "{}", 2);
d602 1
a602 1
			    sv_catpvn(retval, "[]", 2);
d604 1
a604 1
			    sv_catpvn(retval, "do{my $o}", 9);
d606 1
a606 1
			sv_catpvn(postentry, " = ", 3);
d619 1
a619 1
				sv_catpvn(retval, "{", 1);
d621 1
a621 1
				sv_catpvn(retval, "}", 1);
d641 1
a641 1
		    namesv = newSVpvn("\\", 1);
d645 1
a645 1
		    namesv = newSVpvn("\\", 2);
d683 1
a683 1
	if (!purity && maxdepth > 0 && *levelp >= maxdepth) {
d686 1
a686 1
	    sv_catpvn(retval, "'", 1);
d688 1
a688 1
	    sv_catpvn(retval, "'", 1);
d692 2
a693 2
	if (maxrecurse > 0 && *levelp >= maxrecurse) {
	    croak("Recursion limit of %" IVdf " exceeded", maxrecurse);
d698 1
a698 1
	    const char * const blessstr = SvPV(bless, blesslen);
d700 2
a701 2
	    sv_catpvn(retval, "( ", 2);
	    if (indent >= 2) {
d708 1
a708 2
	(*levelp)++;
	ipad = sv_x(aTHX_ Nullsv, SvPVX_const(xpad), SvCUR(xpad), *levelp);
d747 1
d751 1
a751 1
	    sv_catpvn(retval, "qr/", 3);
d756 1
a756 1
		sv_catpvn(retval, "\\/", 2);
d762 1
a762 1
	    sv_catpvn(retval, "/", 1);
d773 1
a773 1
	    SV * const namesv = newSVpvn("${", 2);
d775 1
a775 1
	    sv_catpvn(namesv, "}", 1);
d777 1
a777 1
		sv_catpvn(retval, "do{\\(my $o = ", 13);
d779 2
a780 5
			postav, levelp,	indent, pad, xpad, apad, sep, pair,
			freezer, toaster, purity, deepcopy, quotekeys, bless,
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
		sv_catpvn(retval, ")}", 2);
d783 1
a783 1
		sv_catpvn(retval, "\\", 1);
d785 1
a785 4
			postav, levelp,	indent, pad, xpad, apad, sep, pair,
			freezer, toaster, purity, deepcopy, quotekeys, bless,
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
d790 1
a790 1
	    SV * const namesv = newSVpvn("*{", 2);
d792 2
a793 2
	    sv_catpvn(namesv, "}", 1);
	    sv_catpvn(retval, "\\", 1);
d795 1
a795 4
		    postav, levelp,	indent, pad, xpad, apad, sep, pair,
		    freezer, toaster, purity, deepcopy, quotekeys, bless,
		    maxdepth, sortkeys, use_sparse_seen_hash, useqq,
		    maxrecurse);
d809 1
a809 1
		sv_catpvn(retval, "(", 1);
d813 1
a813 1
		sv_catpvn(retval, "[", 1);
d835 2
a836 2
	    totpad = newSVsv(sep);
	    sv_catsv(totpad, pad);
d857 1
a857 1
		if (indent >= 3) {
d860 1
a860 1
		    sv_catpvn(retval, "#", 1);
d866 3
a868 6
			levelp,	indent, pad, xpad, apad, sep, pair,
			freezer, toaster, purity, deepcopy, quotekeys, bless,
			maxdepth, sortkeys, use_sparse_seen_hash,
			useqq, maxrecurse);
		if (ix < ixmax)
		    sv_catpvn(retval, ",", 1);
d871 1
a871 1
		SV * const opad = sv_x(aTHX_ Nullsv, SvPVX_const(xpad), SvCUR(xpad), (*levelp)-1);
d877 1
a877 1
		sv_catpvn(retval, ")", 1);
d879 1
a879 1
		sv_catpvn(retval, "]", 1);
d887 1
a887 1
	    HE *entry;
d889 1
a889 1
	    I32 klen;
d895 1
a895 1
		sv_catpvn(retval, "(", 1);
d899 1
a899 1
		sv_catpvn(retval, "{", 1);
d907 1
a907 1
		    sv_catpvn(iname, "->", 2);
d914 1
a914 1
		sv_catpvn(iname, "->", 2);
d916 3
a918 3
	    sv_catpvn(iname, "{", 1);
	    totpad = newSVsv(sep);
	    sv_catsv(totpad, pad);
d922 3
a924 5
	    if (sortkeys) {
		if (sortkeys == &PL_sv_yes) {
#if PERL_VERSION < 8
                    sortkeys = sv_2mortal(newSVpvn("Data::Dumper::_sortkeys", 23));
#else
d932 12
a943 8
# ifdef USE_LOCALE_NUMERIC
		    sortsv(AvARRAY(keys), 
			   av_len(keys)+1, 
			   IN_LOCALE ? Perl_sv_cmp_locale : Perl_sv_cmp);
# else
		    sortsv(AvARRAY(keys), 
			   av_len(keys)+1, 
			   Perl_sv_cmp);
d945 7
d953 1
a953 2
		}
		if (sortkeys != &PL_sv_yes) {
d956 1
a956 1
		    i = perl_call_sv(sortkeys, G_SCALAR | G_EVAL);
d977 1
a977 1
		I32 nticks = 0;
d980 1
a980 1
                I32 nlen;
d983 1
a983 1
               if (sortkeys) {
d990 1
a990 1
		    sv_catpvn(retval, ",", 1);
d992 1
a992 1
		if (sortkeys) {
d1029 2
a1030 2
                if (quotekeys || key_needs_quote(key,keylen)) {
                    if (do_utf8 || useqq) {
d1032 1
a1032 1
                        nlen = esc_q_utf8(aTHX_ retval, key, klen, do_utf8, useqq);
d1057 1
a1057 1
                sv_catpvn(sname, "}", 1);
d1059 2
a1060 2
		sv_catsv(retval, pair);
		if (indent >= 2) {
d1062 1
a1062 1
		    I32 elen = 0;
d1075 1
a1075 4
			postav, levelp,	indent, pad, xpad, newapad, sep, pair,
			freezer, toaster, purity, deepcopy, quotekeys, bless,
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
d1078 1
a1078 1
		if (indent >= 2)
d1082 4
a1085 1
		SV *opad = sv_x(aTHX_ Nullsv, SvPVX_const(xpad), SvCUR(xpad), *levelp-1);
d1091 1
a1091 1
		sv_catpvn(retval, ")", 1);
d1093 1
a1093 1
		sv_catpvn(retval, "}", 1);
d1098 2
a1099 2
	    sv_catpvn(retval, "sub { \"DUMMY\" }", 15);
	    if (purity)
d1107 1
a1107 2
	    I32 plen;
	    I32 pticks;
d1109 1
a1109 1
	    if (indent >= 2) {
d1113 1
a1113 1
	    sv_catpvn(retval, ", '", 3);
d1132 5
a1136 5
	    sv_catpvn(retval, "' )", 3);
	    if (toaster && SvPOK(toaster) && SvCUR(toaster)) {
		sv_catpvn(retval, "->", 2);
		sv_catsv(retval, toaster);
		sv_catpvn(retval, "()", 2);
a1139 1
	(*levelp)--;
d1160 1
a1160 1
		    sv_catpvn(retval, "${", 2);
d1162 1
a1162 1
		    sv_catpvn(retval, "}", 1);
d1173 2
a1174 2
	    else if (val != &PL_sv_undef && (!use_sparse_seen_hash || SvREFCNT(val) > 1)) {
		SV * const namesv = newSVpvn("\\", 1);
d1192 1
a1192 2
                 I'm assuming from sprintf isn't going to clash with utf8.
                 Is this valid on EBCDIC?  */
d1224 1
a1224 1
		esc_q_utf8(aTHX_ retval, c, i, 1, useqq);
d1250 1
a1250 1
	    if (purity) {
d1254 2
a1255 2
		SV * const nname = newSVpvn("", 0);
		SV * const newapad = newSVpvn("", 0);
a1266 1
			I32 nlevel = 0;
d1271 1
a1271 1
			sv_catpvn(postentry, " = ", 3);
d1276 1
a1276 1
			if (indent >= 2)
d1280 1
a1280 5
				seenhv, postav, &nlevel, indent, pad, xpad,
				newapad, sep, pair, freezer, toaster, purity,
				deepcopy, quotekeys, bless, maxdepth, 
				sortkeys, use_sparse_seen_hash, useqq,
				maxrecurse);
d1290 1
a1290 1
	    sv_catpvn(retval, "undef", 5);
d1315 1
a1315 1
            if (useqq && safe_decimal_number(c, i)) {
d1318 2
a1319 2
	    else if (DO_UTF8(val) || useqq)
	        i += esc_q_utf8(aTHX_ retval, c, i, DO_UTF8(val), useqq);
d1334 1
a1334 1
	if (deepcopy)
d1350 1
a1350 1
#   * doesn't deparse yet.
d1363 1
a1363 2
	    I32 level = 0;
	    I32 indent, terse, useqq;
d1366 4
a1369 4
	    SV *val, *name, *pad, *xpad, *apad, *sep, *pair, *varname;
	    SV *freezer, *toaster, *bless, *sortkeys;
	    I32 purity, deepcopy, quotekeys, maxdepth = 0;
	    IV maxrecurse = 1000;
d1371 1
a1371 2
	    I32 gimme = GIMME;
            int use_sparse_seen_hash = 0;
d1400 7
a1407 2
	    val = pad = xpad = apad = sep = pair = varname
		= freezer = toaster = bless = sortkeys = &PL_sv_undef;
a1408 3
	    indent = 2;
	    terse = purity = deepcopy = useqq = 0;
	    quotekeys = 1;
d1410 1
a1410 1
	    retval = newSVpvn("", 0);
d1418 1
a1418 1
                    use_sparse_seen_hash = 1;
d1420 1
a1420 1
		    use_sparse_seen_hash = (SvOK(*svp) && SvIV(*svp) != 0);
d1426 1
a1426 1
		    indent = SvIV(*svp);
d1428 1
a1428 1
		    purity = SvIV(*svp);
d1432 1
a1432 1
		    useqq = SvTRUE(*svp);
d1434 1
a1434 1
		    pad = *svp;
d1436 1
a1436 1
		    xpad = *svp;
d1440 1
a1440 1
		    sep = *svp;
d1442 1
a1442 1
		    pair = *svp;
d1446 1
a1446 1
		    freezer = *svp;
d1448 1
a1448 1
		    toaster = *svp;
d1450 1
a1450 1
		    deepcopy = SvTRUE(*svp);
d1452 3
a1454 1
		    quotekeys = SvTRUE(*svp);
d1456 1
a1456 1
		    bless = *svp;
d1458 1
a1458 1
		    maxdepth = SvIV(*svp);
d1460 1
a1460 1
		    maxrecurse = SvIV(*svp);
d1462 16
a1477 9
		    sortkeys = *svp;
		    if (! SvTRUE(sortkeys))
			sortkeys = NULL;
		    else if (! (SvROK(sortkeys) &&
				SvTYPE(SvRV(sortkeys)) == SVt_PVCV) )
		    {
			/* flag to use qsortsv() for sorting hash keys */	
			sortkeys = &PL_sv_yes; 
		    }
d1485 1
a1485 1
		valstr = newSVpvn("",0);
d1534 1
a1534 1
		    if (indent >= 2 && !terse) {
d1545 1
a1545 4
			    postav, &level, indent, pad, xpad, newapad, sep, pair,
			    freezer, toaster, purity, deepcopy, quotekeys,
			    bless, maxdepth, sortkeys, use_sparse_seen_hash,
			    useqq, maxrecurse);
d1548 1
a1548 1
		    if (indent >= 2 && !terse)
d1555 1
a1555 1
			sv_catpvn(valstr, ";", 1);
d1557 1
a1557 1
		    sv_catsv(retval, pad);
d1559 1
a1559 1
		    sv_catsv(retval, sep);
d1562 1
a1562 1
			sv_catsv(retval, pad);
d1569 3
a1571 3
				    sv_catpvn(retval, ";", 1);
				    sv_catsv(retval, sep);
				    sv_catsv(retval, pad);
d1575 2
a1576 2
			sv_catpvn(retval, ";", 1);
			    sv_catsv(retval, sep);
d1582 1
a1582 1
			    retval = newSVpvn("",0);
d1590 1
a1590 1
	    if (gimme == G_SCALAR)
@


1.4
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d31 1
a31 2
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash, I32 useqq,
            IV maxrecurse);
d681 2
a682 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d690 2
a691 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d703 2
a704 1
		    maxdepth, sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d777 2
a778 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d981 2
a982 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d1191 2
a1192 1
				sortkeys, use_sparse_seen_hash, useqq, maxrecurse);
d1450 2
a1451 2
			    bless, maxdepth, sortkeys, use_sparse_seen_hash, useqq,
                maxrecurse);
@


1.3
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d31 2
a32 1
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash, I32 useqq);
d416 1
a416 1
        int use_sparse_seen_hash, I32 useqq)
d593 4
d682 1
a682 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d690 1
a690 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d702 1
a702 1
		    maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d775 1
a775 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d978 1
a978 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d1187 1
a1187 1
				sortkeys, use_sparse_seen_hash, useqq);
d1277 1
d1364 2
d1445 2
a1446 1
			    bless, maxdepth, sortkeys, use_sparse_seen_hash, useqq);
@


1.2
log
@Fix a possibly infinite recursion in Perl Data::Dumper.

Derived from Perl git commit http://perl5.git.perl.org/perl.git
19be3be6968e2337bcdfe480693fff795ecd1304
Add a configuration variable/option to limit recursion when dumping
deep data structures.
Defaults the limit to 1000, which can be reduced or increase, or
eliminated by setting it to 0.
This patch addresses CVE-2014-4330.  This bug was found and
reported by: LSE Leading Security Experts GmbH employee Markus
Vervier.

From Maximilian Pascher;  OK schwarze@@ afresh1@@
@
text
@d21 4
a24 2
static I32 esc_q_utf8 (pTHX_ SV *sv, const char *src, STRLEN slen);
static I32 needs_quote(const char *s, STRLEN len);
d31 1
a31 2
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash,
		    IV maxrecurse);
d96 3
a98 3
/* does a string need to be protected? */
static I32
needs_quote(const char *s, STRLEN len)
d105 1
a105 1
		return 1;
d108 1
a108 1
	    return 1;
d116 1
a116 1
		    return 1;
d120 58
a177 2
	return 1;
    return 0;
d219 1
d221 1
a221 1
esc_q_utf8(pTHX_ SV* sv, const char *src, STRLEN slen)
d236 1
d239 2
a240 2
    for (s = src; s < send; s += increment) {
        const UV k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);
d245 6
d264 11
d285 1
a285 1
    if (grow) {
d293 2
a294 2
        for (s = src; s < send; s += UTF8SKIP(s)) {
            const UV k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);
d304 38
a341 1
	      if (k < 0x80)
d415 1
a415 1
        int use_sparse_seen_hash, IV maxrecurse)
d418 1
a418 1
    U32 i;
a591 4
	if (maxrecurse > 0 && *levelp >= maxrecurse) {
	    croak("Recursion limit of %" IVdf " exceeded", maxrecurse);
	}

d610 37
a646 3
	    const char *rval = SvPV(val, rlen);
	    const char * const rend = rval+rlen;
	    const char *slash = rval;
d659 2
d677 1
a677 1
			maxdepth, sortkeys, use_sparse_seen_hash, maxrecurse);
d685 1
a685 1
			maxdepth, sortkeys, use_sparse_seen_hash, maxrecurse);
d697 1
a697 1
		    maxdepth, sortkeys, use_sparse_seen_hash, maxrecurse);
d702 2
a703 2
	    I32 ix = 0;
	    const I32 ixmax = av_len((AV *)ival);
d770 1
a770 1
			maxdepth, sortkeys, use_sparse_seen_hash, maxrecurse);
d880 1
a880 1
                   if (!(keys && (I32)i <= av_len(keys))) break;
d908 2
a909 1
                /* old logic was first to check utf8 flag, and if utf8 always
d915 12
a926 17
                   The perl code is correct.
                   needs_quote() decides that anything that isn't a valid
                   perl identifier needs to be quoted, hence only correctly
                   formed strings with no characters outside [A-Za-z0-9_:]
                   won't need quoting.  None of those characters are used in
                   the byte encoding of utf8, so anything with utf8
                   encoded characters in will need quoting. Hence strings
                   with utf8 encoded characters in will end up inside do_utf8
                   just like before, but now strings with utf8 flag set but
                   only ascii characters will end up in the unquoted section.

                   There should also be less tests for the (probably currently)
                   more common doesn't need quoting case.
                   The code is also smaller (22044 vs 22260) because I've been
                   able to pull the common logic out to both sides.  */
                if (quotekeys || needs_quote(key,keylen)) {
                    if (do_utf8) {
d928 1
a928 1
                        nlen = esc_q_utf8(aTHX_ retval, key, klen);
d973 1
a973 1
			maxdepth, sortkeys, use_sparse_seen_hash, maxrecurse);
d1115 1
a1115 1
	    if (needs_quote(c,i)) {
d1122 1
a1122 1
		esc_q_utf8(aTHX_ retval, c, i);
d1182 1
a1182 1
				sortkeys, use_sparse_seen_hash, maxrecurse);
d1208 1
d1211 11
a1221 3
	    c = SvPV(val, i);
	    if (DO_UTF8(val))
	        i += esc_q_utf8(aTHX_ retval, c, i);
d1252 1
a1252 1
#   * doesn't do double-quotes yet.
d1266 2
a1267 1
	    I32 indent, terse, i, imax, postlen;
a1271 1
	    IV maxrecurse = 1000;
d1308 1
a1308 1
	    terse = purity = deepcopy = 0;
a1331 1
#if 0 /* useqq currently unused */
a1333 1
#endif
a1357 2
		if ((svp = hv_fetch(hv, "maxrecurse", 10, FALSE)))
		    maxrecurse = SvIV(*svp);
d1437 1
a1437 2
			    bless, maxdepth, sortkeys, use_sparse_seen_hash,
			    maxrecurse);
d1453 1
a1453 1
			I32 i;
@


1.1
log
@Initial revision
@
text
@d15 4
d22 1
a22 1
static I32 needs_quote(register const char *s);
d29 2
a30 1
		    I32 maxdepth, SV *sortkeys);
d36 4
d49 1
a49 1
Perl_utf8_to_uvchr(pTHX_ U8 *s, STRLEN *retlen)
d51 1
a51 1
    const UV uv = utf8_to_uv(s, UTF8_MAXLEN, retlen,
d57 1
a57 1
#  define utf8_to_uvchr	     Perl_utf8_to_uvchr
d59 1
a59 1
#  define utf8_to_uvchr(a,b) Perl_utf8_to_uvchr(aTHX_ a,b)
d64 22
d97 1
a97 1
needs_quote(register const char *s)
d99 1
d102 1
a102 1
	if (*++s) {
d110 2
a111 2
	while (*++s)
	    if (!isALNUM(*s)) {
d125 1
a125 1
num_q(register const char *s, register STRLEN slen)
d127 1
a127 1
    register I32 ret = 0;
d143 1
a143 1
esc_q(register char *d, register const char *s, register STRLEN slen)
d145 1
a145 1
    register I32 ret = 0;
d163 1
a163 1
esc_q_utf8(pTHX_ SV* sv, register const char *src, register STRLEN slen)
d177 1
d180 5
a184 2
    for (s = src; s < send; s += UTF8SKIP(s)) {
        const UV k = utf8_to_uvchr((U8*)s, NULL);
d218 1
a218 1
            const UV k = utf8_to_uvchr((U8*)s, NULL);
d301 2
a302 1
	I32 deepcopy, I32 quotekeys, SV *bless, I32 maxdepth, SV *sortkeys)
d329 1
a329 1
    /* If the ouput buffer has less than some arbitary amount of space
d352 1
a352 1
	    i = perl_call_method(SvPVX_const(freezer), G_EVAL|G_VOID);
d479 4
d502 2
a503 1
	    const char *slash = strchr(rval, '/');
d505 3
a507 1
	    while (slash) {
d512 1
a512 1
		slash = strchr(rval, '/');
d532 1
a532 1
			maxdepth, sortkeys);
d540 1
a540 1
			maxdepth, sortkeys);
d552 1
a552 1
		    maxdepth, sortkeys);
d625 1
a625 1
			maxdepth, sortkeys);
d690 1
a690 1
			SvREFCNT_inc(sv);
d746 1
a746 1
		    keysv = svp ? *svp : sv_mortalcopy(&PL_sv_undef);
d749 2
a750 2
                                   SvUTF8(keysv) ? -(I32)keylen : keylen, 0);
		    hval = svp ? *svp : sv_mortalcopy(&PL_sv_undef);
d784 1
a784 1
                if (quotekeys || needs_quote(key)) {
d832 1
a832 1
			maxdepth, sortkeys);
d857 1
a857 1
	    warn("cannot handle ref type %ld", realtype);
d899 1
d922 8
a929 1
	    else if (val != &PL_sv_undef) {
d964 1
a964 1
	    ++c; --i;			/* just get the name */
d967 6
a972 1
		i -= 4;
d974 16
a989 1
	    if (needs_quote(c)) {
d997 1
d1041 1
a1041 1
				sortkeys);
d1053 14
d1102 1
a1102 1
#   * doesnt do double-quotes yet.
d1121 1
d1124 1
d1134 3
a1136 2
		XPUSHs(href);
		XPUSHs(sv_2mortal(newSVsv(ST(1))));
d1138 1
a1138 1
		    XPUSHs(sv_2mortal(newSVsv(ST(2))));
d1168 4
d1210 2
d1278 1
a1278 1
		    if (indent >= 2) {
d1287 1
d1291 3
a1293 1
			    bless, maxdepth, sortkeys);
d1295 1
a1295 1
		    if (indent >= 2)
d1340 18
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d18 1
a18 1
static I32 needs_quote(register const char *s, STRLEN len);
d40 1
a40 1
Perl_utf8_to_uvchr_buf(pTHX_ U8 *s, U8 *send, STRLEN *retlen)
d42 1
a42 1
    const UV uv = utf8_to_uv(s, send - s, retlen,
d48 1
a48 1
#  define utf8_to_uvchr_buf	     Perl_utf8_to_uvchr_buf
d50 1
a50 1
#  define utf8_to_uvchr_buf(a,b) Perl_utf8_to_uvchr_buf(aTHX_ a,b)
d66 1
a66 1
needs_quote(register const char *s, STRLEN len)
a67 1
    const char *send = s+len;
d70 1
a70 1
	if (++s<send) {
d78 1
a78 1
	while (++s<send)
a144 1
    int increment;
d147 2
a148 5
    for (s = src; s < send; s += increment) {
        const UV k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);

        /* check for invalid utf8 */
        increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);
d182 1
a182 1
            const UV k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);
d292 1
a292 1
    /* If the ouput buffer has less than some arbitrary amount of space
d461 1
a461 2
	    const char * const rend = rval+rlen;
	    const char *slash = rval;
d463 1
a463 3
	    for (;slash < rend; slash++) {
	      if (*slash == '\\') { ++slash; continue; }
	      if (*slash == '/') {    
d468 1
a468 1
	      }
d646 1
a646 1
			(void)SvREFCNT_inc(sv);
d702 1
a702 1
		    keysv = svp ? *svp : sv_newmortal();
d705 2
a706 2
                                   SvUTF8(keysv) ? -(I32)keylen : (I32)keylen, 0);
		    hval = svp ? *svp : sv_newmortal();
d740 1
a740 1
                if (quotekeys || needs_quote(key,keylen)) {
d813 1
a813 1
	    warn("cannot handle ref type %d", (int)realtype);
a854 1
	const MAGIC *mg;
d912 1
a912 1
	    if(i) ++c, --i;			/* just get the name */
d915 1
a915 6
#if PERL_VERSION < 7
		if (i == 6 || (i == 7 && c[6] == '\0'))
#else
		if (i == 6)
#endif
		    i = 0; else i -= 4;
d917 1
a917 16
	    if (needs_quote(c,i)) {
#ifdef GvNAMEUTF8
	      if (GvNAMEUTF8(val)) {
		sv_grow(retval, SvCUR(retval)+2);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '*'; r[1] = '{';
		SvCUR_set(retval, SvCUR(retval)+2);
		esc_q_utf8(aTHX_ retval, c, i);
		sv_grow(retval, SvCUR(retval)+2);
		r = SvPVX(retval)+SvCUR(retval);
		r[0] = '}'; r[1] = '\0';
		i = 1;
	      }
	      else
#endif
	      {
a924 1
	      }
a979 14
#ifdef SvVOK
	else if (SvMAGICAL(val) && (mg = mg_find(val, 'V'))) {
# ifndef PL_vtbl_vstring
	    SV * const vecsv = sv_newmortal();
#  if PERL_VERSION < 10
	    scan_vstring(mg->mg_ptr, vecsv);
#  else
	    scan_vstring(mg->mg_ptr, mg->mg_ptr + mg->mg_len, vecsv);
#  endif
	    if (!sv_eq(vecsv, val)) goto integer_came_from_string;
# endif
	    sv_catpvn(retval, (const char *)mg->mg_ptr, mg->mg_len);
	}
#endif
d1015 1
a1015 1
#   * doesn't do double-quotes yet.
d1182 1
a1182 1
		    if (indent >= 2 && !terse) {
a1190 1
		    PUTBACK;
a1194 1
		    SPAGAIN;
d1196 1
a1196 1
		    if (indent >= 2 && !terse)
a1240 18

SV *
Data_Dumper__vstring(sv)
	SV	*sv;
	PROTOTYPE: $
	CODE:
	{
#ifdef SvVOK
	    const MAGIC *mg;
	    RETVAL =
		SvMAGICAL(sv) && (mg = mg_find(sv, 'V'))
		 ? newSVpvn((const char *)mg->mg_ptr, mg->mg_len)
		 : &PL_sv_undef;
#else
	    RETVAL = &PL_sv_undef;
#endif
	}
	OUTPUT: RETVAL
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a14 4
#ifndef isWORDCHAR
#   define isWORDCHAR(c) isALNUM(c)
#endif

d18 1
a18 1
static I32 needs_quote(const char *s, STRLEN len);
d25 1
a25 1
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash);
a30 4
/* Perls 7 through portions of 15 used utf8_to_uvchr() which didn't have a
 * length parameter.  This wrongly allowed reading beyond the end of buffer
 * given malformed input */

d50 1
a50 1
#  define utf8_to_uvchr_buf(a,b,c) Perl_utf8_to_uvchr_buf(aTHX_ a,b,c)
a54 22
/* Perl 5.7 through part of 5.15 */
#if PERL_VERSION > 6 && PERL_VERSION <= 15 && ! defined(utf8_to_uvchr_buf)

UV
Perl_utf8_to_uvchr_buf(pTHX_ U8 *s, U8 *send, STRLEN *retlen)
{
    /* We have to discard <send> for these versions; hence can read off the
     * end of the buffer if there is a malformation that indicates the
     * character is longer than the space available */

    const UV uv = utf8_to_uvchr(s, retlen);
    return UNI_TO_NATIVE(uv);
}

# if !defined(PERL_IMPLICIT_CONTEXT)
#  define utf8_to_uvchr_buf	     Perl_utf8_to_uvchr_buf
# else
#  define utf8_to_uvchr_buf(a,b,c) Perl_utf8_to_uvchr_buf(aTHX_ a,b,c)
# endif

#endif /* PERL_VERSION > 6 && <= 15 */

d66 1
a66 1
needs_quote(const char *s, STRLEN len)
d80 1
a80 1
	    if (!isWORDCHAR(*s)) {
d94 1
a94 1
num_q(const char *s, STRLEN slen)
d96 1
a96 1
    I32 ret = 0;
d112 1
a112 1
esc_q(char *d, const char *s, STRLEN slen)
d114 1
a114 1
    I32 ret = 0;
d132 1
a132 1
esc_q_utf8(pTHX_ SV* sv, const char *src, STRLEN slen)
d270 1
a270 2
	I32 deepcopy, I32 quotekeys, SV *bless, I32 maxdepth, SV *sortkeys,
        int use_sparse_seen_hash)
d320 1
a320 1
	    i = perl_call_method(SvPVX_const(freezer), G_EVAL|G_VOID|G_DISCARD);
d496 1
a496 1
			maxdepth, sortkeys, use_sparse_seen_hash);
d504 1
a504 1
			maxdepth, sortkeys, use_sparse_seen_hash);
d516 1
a516 1
		    maxdepth, sortkeys, use_sparse_seen_hash);
d589 1
a589 1
			maxdepth, sortkeys, use_sparse_seen_hash);
d796 1
a796 1
			maxdepth, sortkeys, use_sparse_seen_hash);
d886 1
a886 8
            /* If we're allowed to keep only a sparse "seen" hash
             * (IOW, the user does not expect it to contain everything
             * after the dump, then only store in seen hash if the SV
             * ref count is larger than 1. If it's 1, then we know that
             * there is no other reference, duh. This is an optimization.
             * Note that we'd have to check for weak-refs, too, but this is
             * already the branch for non-refs only. */
	    else if (val != &PL_sv_undef && (!use_sparse_seen_hash || SvREFCNT(val) > 1)) {
d998 1
a998 1
				sortkeys, use_sparse_seen_hash);
d1012 1
a1012 1
# if !defined(PL_vtbl_vstring) && PERL_VERSION < 17
a1079 1
            int use_sparse_seen_hash = 0;
d1089 2
a1090 3
                EXTEND(SP, 3); /* 3 == max of all branches below */
		PUSHs(href);
		PUSHs(sv_2mortal(newSVsv(ST(1))));
d1092 1
a1092 1
		    PUSHs(sv_2mortal(newSVsv(ST(2))));
a1121 4
                else
                    use_sparse_seen_hash = 1;
		if ((svp = hv_fetch(hv, "noseen", 6, FALSE)))
		    use_sparse_seen_hash = (SvOK(*svp) && SvIV(*svp) != 0);
d1239 1
a1239 1
			    bless, maxdepth, sortkeys, use_sparse_seen_hash);
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d21 2
a22 4
static I32 esc_q_utf8 (pTHX_ SV *sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq);
static bool globname_needs_quote(const char *s, STRLEN len);
static bool key_needs_quote(const char *s, STRLEN len);
static bool safe_decimal_number(const char *p, STRLEN len);
d29 1
a29 1
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash, I32 useqq);
d94 3
a96 3
/* does a glob name need to be protected? */
static bool
globname_needs_quote(const char *s, STRLEN len)
d103 1
a103 1
                return TRUE;
d106 1
a106 1
	    return TRUE;
d114 1
a114 1
                    return TRUE;
d118 2
a119 58
        return TRUE;

    return FALSE;
}

/* does a hash key need to be quoted (to the left of => ).
   Previously this used (globname_)needs_quote() which accepted strings
   like '::foo', but these aren't safe as unquoted keys under strict.
*/
static bool
key_needs_quote(const char *s, STRLEN len) {
    const char *send = s+len;

    if (safe_decimal_number(s, len)) {
        return FALSE;
    }
    else if (isIDFIRST(*s)) {
        while (++s<send)
            if (!isWORDCHAR(*s))
                return TRUE;
    }
    else
        return TRUE;

    return FALSE;
}

/* Check that the SV can be represented as a simple decimal integer.
 *
 * The perl code does this by matching against /^(?:0|-?[1-9]\d{0,8})\z/
*/
static bool
safe_decimal_number(const char *p, STRLEN len) {
    if (len == 1 && *p == '0')
        return TRUE;

    if (len && *p == '-') {
        ++p;
        --len;
    }

    if (len == 0 || *p < '1' || *p > '9')
        return FALSE;

    ++p;
    --len;

    if (len > 8)
        return FALSE;

    while (len > 0) {
         /* the perl code checks /\d/ but we don't want unicode digits here */
         if (*p < '0' || *p > '9')
             return FALSE;
         ++p;
         --len;
    }
    return TRUE;
a160 1
/* this function is also misused for implementing $Useqq */
d162 1
a162 1
esc_q_utf8(pTHX_ SV* sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq)
a176 1
    UV next;
d179 2
a180 2
    for (s = src; s < send; do_utf8 ? s += increment : s++) {
        const UV k = do_utf8 ? utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL) : *(U8*)s;
a184 6
	/* this is only used to check if the next character is an
	 * ASCII digit, which are invariant, so if the following collects
	 * a UTF-8 start byte it does no harm
	 */
	next = (s + increment >= send ) ? 0 : *(U8*)(s+increment);

a197 11
#ifndef EBCDIC
	} else if (useqq &&
	    /* we can't use the short form like '\0' if followed by a digit */
                   (((k >= 7 && k <= 10) || k == 12 || k == 13 || k == 27)
                 || (k < 8 && (next < '0' || next > '9')))) {
	    grow += 2;
	} else if (useqq && k <= 31 && (next < '0' || next > '9')) {
	    grow += 3;
	} else if (useqq && (k <= 31 || k >= 127)) {
	    grow += 4;
#endif
d208 1
a208 1
    if (grow || useqq) {
d216 2
a217 2
        for (s = src; s < send; do_utf8 ? s += UTF8SKIP(s) : s++) {
            const UV k = do_utf8 ? utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL) : *(U8*)s;
d227 1
a227 38
	      if (useqq && (k <= 31 || k == 127 || (!do_utf8 && k > 127))) {
	        bool next_is_digit;

		*r++ = '\\';
		switch (k) {
		case 7:  *r++ = 'a'; break;
		case 8:  *r++ = 'b'; break;
		case 9:  *r++ = 't'; break;
		case 10: *r++ = 'n'; break;
		case 12: *r++ = 'f'; break;
		case 13: *r++ = 'r'; break;
		case 27: *r++ = 'e'; break;
		default:
		    increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

		    /* only ASCII digits matter here, which are invariant,
		     * since we only encode characters \377 and under, or
		     * \x177 and under for a unicode string
		     */
		    next = (s+increment < send) ? *(U8*)(s+increment) : 0;
		    next_is_digit = next >= '0' && next <= '9';

		    /* faster than
		     * r = r + my_sprintf(r, "%o", k);
		     */
		    if (k <= 7 && !next_is_digit) {
			*r++ = (char)k + '0';
		    } else if (k <= 63 && !next_is_digit) {
			*r++ = (char)(k>>3) + '0';
			*r++ = (char)(k&7) + '0';
		    } else {
			*r++ = (char)(k>>6) + '0';
			*r++ = (char)((k&63)>>3) + '0';
			*r++ = (char)(k&7) + '0';
		    }
		}
	    }
	    else if (k < 0x80)
d301 1
a301 1
        int use_sparse_seen_hash, I32 useqq)
d304 1
a304 1
    Size_t i;
d496 3
a498 37
	    SV *sv_pattern = NULL;
	    SV *sv_flags = NULL;
	    CV *re_pattern_cv;
	    const char *rval;
	    const char *rend;
	    const char *slash;

	    if ((re_pattern_cv = get_cv("re::regexp_pattern", 0))) {
	      dSP;
	      I32 count;
	      ENTER;
	      SAVETMPS;
	      PUSHMARK(SP);
	      XPUSHs(val);
	      PUTBACK;
	      count = call_sv((SV*)re_pattern_cv, G_ARRAY);
	      SPAGAIN;
	      if (count >= 2) {
		sv_flags = POPs;
	        sv_pattern = POPs;
		SvREFCNT_inc(sv_flags);
		SvREFCNT_inc(sv_pattern);
	      }
	      PUTBACK;
	      FREETMPS;
	      LEAVE;
	      if (sv_pattern) {
	        sv_2mortal(sv_pattern);
	        sv_2mortal(sv_flags);
	      }
	    }
	    else {
	      sv_pattern = val;
	    }
	    rval = SvPV(sv_pattern, rlen);
	    rend = rval+rlen;
	    slash = rval;
a510 2
	    if (sv_flags)
	      sv_catsv(retval, sv_flags);
d527 1
a527 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d535 1
a535 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d547 1
a547 1
		    maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d552 2
a553 2
	    SSize_t ix = 0;
	    const SSize_t ixmax = av_len((AV *)ival);
d620 1
a620 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d730 1
a730 1
                   if (!(keys && (SSize_t)i <= av_len(keys))) break;
d758 1
a758 2
                /* The (very)
                   old logic was first to check utf8 flag, and if utf8 always
d764 17
a780 12

                   The old logic checked that the string was a valid
                   perl glob name (foo::bar), which isn't safe under
                   strict, and differs from the perl code which only
                   accepts simple identifiers.

                   With the fix for [perl #120384] I chose to make
                   their handling of key quoting compatible between XS
                   and perl.
                 */
                if (quotekeys || key_needs_quote(key,keylen)) {
                    if (do_utf8 || useqq) {
d782 1
a782 1
                        nlen = esc_q_utf8(aTHX_ retval, key, klen, do_utf8, useqq);
d827 1
a827 1
			maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d969 1
a969 1
            if (globname_needs_quote(c,i)) {
d976 1
a976 1
		esc_q_utf8(aTHX_ retval, c, i, 1, useqq);
d1036 1
a1036 1
				sortkeys, use_sparse_seen_hash, useqq);
a1061 1

d1064 3
a1066 11
            c = SvPV(val, i);
            /* the pure perl and XS non-qq outputs have historically been
             * different in this case, but for useqq, let's try to match
             * the pure perl code.
             * see [perl #74798]
             */
            if (useqq && safe_decimal_number(c, i)) {
                sv_catsv(retval, val);
            }
	    else if (DO_UTF8(val) || useqq)
	        i += esc_q_utf8(aTHX_ retval, c, i, DO_UTF8(val), useqq);
d1097 1
a1097 1
#   * doesn't deparse yet.
d1111 1
a1111 2
	    I32 indent, terse, useqq;
	    SSize_t i, imax, postlen;
d1152 1
a1152 1
	    terse = purity = deepcopy = useqq = 0;
d1176 1
d1179 1
d1283 1
a1283 1
			    bless, maxdepth, sortkeys, use_sparse_seen_hash, useqq);
d1299 1
a1299 1
			SSize_t i;
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@d31 1
a31 1
		    I32 maxdepth, SV *sortkeys, int use_sparse_seen_hash, I32 useqq, IV maxrecurse);
d415 1
a415 1
        int use_sparse_seen_hash, I32 useqq, IV maxrecurse)
a591 4
	if (maxrecurse > 0 && *levelp >= maxrecurse) {
	    croak("Recursion limit of %" IVdf " exceeded", maxrecurse);
	}

d677 1
a677 2
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
d685 1
a685 2
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
d697 1
a697 2
		    maxdepth, sortkeys, use_sparse_seen_hash, useqq,
		    maxrecurse);
d770 1
a770 2
			maxdepth, sortkeys, use_sparse_seen_hash,
			useqq, maxrecurse);
d973 1
a973 2
			maxdepth, sortkeys, use_sparse_seen_hash, useqq,
			maxrecurse);
d1182 1
a1182 2
				sortkeys, use_sparse_seen_hash, useqq,
				maxrecurse);
a1271 1
	    IV maxrecurse = 1000;
a1357 2
		if ((svp = hv_fetch(hv, "maxrecurse", 10, FALSE)))
		    maxrecurse = SvIV(*svp);
d1437 1
a1437 2
			    bless, maxdepth, sortkeys, use_sparse_seen_hash,
			    useqq, maxrecurse);
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@a14 24
/* These definitions are ASCII only.  But the pure-perl .pm avoids
 * calling this .xs file for releases where they aren't defined */

#ifndef isASCII
#   define isASCII(c) (((UV) (c)) < 128)
#endif

#ifndef ESC_NATIVE          /* \e */
#   define ESC_NATIVE 27
#endif

#ifndef isPRINT
#   define isPRINT(c) (((UV) (c)) >= ' ' && ((UV) (c)) < 127)
#endif

#ifndef isALPHA
#   define isALPHA(c) (   (((UV) (c)) >= 'a' && ((UV) (c)) <= 'z')          \
                       || (((UV) (c)) <= 'Z' && ((UV) (c)) >= 'A'))
#endif

#ifndef isIDFIRST
#   define isIDFIRST(c) (isALPHA(c) || (c) == '_')
#endif

d16 1
a16 2
#   define isWORDCHAR(c) (isIDFIRST(c)                                      \
                          || (((UV) (c)) >= '0' && ((UV) (c)) <= '9'))
d19 3
a21 27
/* This struct contains almost all the user's desired configuration, and it
 * is treated as constant by the recursive function. This arrangement has
 * the advantage of needing less memory than passing all of them on the
 * stack all the time (as was the case in an earlier implementation). */
typedef struct {
    SV *pad;
    SV *xpad;
    SV *sep;
    SV *pair;
    SV *sortkeys;
    SV *freezer;
    SV *toaster;
    SV *bless;
    IV maxrecurse;
    I32 indent;
    I32 purity;
    I32 deepcopy;
    I32 quotekeys;
    I32 maxdepth;
    I32 useqq;
    int use_sparse_seen_hash;
    int trailingcomma;
} Style;

static STRLEN num_q (const char *s, STRLEN slen);
static STRLEN esc_q (char *dest, const char *src, STRLEN slen);
static STRLEN esc_q_utf8 (pTHX_ SV *sv, const char *src, STRLEN slen, I32 do_utf8, I32 useqq);
d27 5
a31 2
                    HV *seenhv, AV *postav, const I32 level, SV *apad,
                    const Style *style);
d43 6
d75 2
a76 1
    return utf8_to_uvchr(s, retlen);
d181 1
a181 1
static STRLEN
d184 1
a184 1
    STRLEN ret = 0;
d199 1
a199 1
static STRLEN
d202 1
a202 1
    STRLEN ret = 0;
a209 1
            /* FALLTHROUGH */
d220 1
a220 1
static STRLEN
d236 1
d238 12
a249 2
    for (s = src; s < send; s += increment) { /* Sizing pass */
        UV k = *(U8*)s;
d251 7
a257 32
        increment = 1;      /* Will override if necessary for utf-8 */

        if (isPRINT(k)) {
            if (k == '\\') {
                backslashes++;
            } else if (k == '\'') {
                single_quotes++;
            } else if (k == '"' || k == '$' || k == '@@') {
                qq_escapables++;
            } else {
                normal++;
            }
        }
        else if (! isASCII(k) && k > ' ') {
            /* High ordinal non-printable code point.  (The test that k is
             * above SPACE should be optimized out by the compiler on
             * non-EBCDIC platforms; otherwise we could put an #ifdef around
             * it, but it's better to have just a single code path when
             * possible.  All but one of the non-ASCII EBCDIC controls are low
             * ordinal; that one is the only one above SPACE.)
             *
             * If UTF-8, output as hex, regardless of useqq.  This means there
             * is an overhead of 4 chars '\x{}'.  Then count the number of hex
             * digits.  */
            if (do_utf8) {
                k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);

                /* treat invalid utf8 byte by byte.  This loop iteration gets the
                * first byte */
                increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

                grow += 4 + (k <= 0xFF ? 2 : k <= 0xFFF ? 3 : k <= 0xFFFF ? 4 :
d259 1
a259 1
                    8 /* We may allocate a bit more than the minimum here.  */
d261 1
a261 1
                    k <= 0xFFFFFFFF ? 8 : UVSIZE * 4
d263 19
a281 12
                    );
            }
            else if (useqq) {   /* Not utf8, must be <= 0xFF, hence 2 hex
                                 * digits. */
                grow += 4 + 2;
            }
            else {  /* Non-qq generates 3 octal digits plus backslash */
                grow += 4;
            }
	} /* End of high-ordinal non-printable */
        else if (! useqq) { /* Low ordinal, non-printable, non-qq just
                             * outputs the raw char */
d284 1
a284 29
        else {  /* Is qq, low ordinal, non-printable.  Output escape
                 * sequences */
            if (   k == '\a' || k == '\b' || k == '\t' || k == '\n' || k == '\r'
                || k == '\f' || k == ESC_NATIVE)
            {
                grow += 2;  /* 1 char plus backslash */
            }
            else /* The other low ordinals are output as an octal escape
                  * sequence */
                 if (s + 1 >= send || (   *(U8*)(s+1) >= '0'
                                       && *(U8*)(s+1) <= '9'))
            {
                /* When the following character is a digit, use 3 octal digits
                 * plus backslash, as using fewer digits would concatenate the
                 * following char into this one */
                grow += 4;
            }
            else if (k <= 7) {
                grow += 2;  /* 1 octal digit, plus backslash */
            }
            else if (k <= 077) {
                grow += 3;  /* 2 octal digits plus backslash */
            }
            else {
                grow += 4;  /* 3 octal digits plus backslash */
            }
        }
    } /* End of size-calculating loop */

d293 2
a294 44
        for (s = src; s < send; s += increment) {
            UV k;

            if (do_utf8
                && ! isASCII(*s)
                    /* Exclude non-ASCII low ordinal controls.  This should be
                     * optimized out by the compiler on ASCII platforms; if not
                     * could wrap it in a #ifdef EBCDIC, but better to avoid
                     * #if's if possible */
                && *(U8*)s > ' '
            ) {

                /* When in UTF-8, we output all non-ascii chars as \x{}
                 * reqardless of useqq, except for the low ordinal controls on
                 * EBCDIC platforms */
                k = utf8_to_uvchr_buf((U8*)s, (U8*) send, NULL);

                /* treat invalid utf8 byte by byte.  This loop iteration gets the
                * first byte */
                increment = (k == 0 && *s != '\0') ? 1 : UTF8SKIP(s);

#if PERL_VERSION < 10
                sprintf(r, "\\x{%"UVxf"}", k);
                r += strlen(r);
                /* my_sprintf is not supported by ppport.h */
#else
                r = r + my_sprintf(r, "\\x{%"UVxf"}", k);
#endif
                continue;
            }

            /* Here 1) isn't UTF-8; or
             *      2) the current character is ASCII; or
             *      3) it is an EBCDIC platform and is a low ordinal
             *         non-ASCII control.
             * In each case the character occupies just one byte */
            k = *(U8*)s;
            increment = 1;

            if (isPRINT(k)) {
                /* These need a backslash escape */
                if (k == '"' || k == '\\' || k == '$' || k == '@@') {
                    *r++ = '\\';
                }
d296 2
d300 5
a304 5
            else if (! useqq) { /* non-qq, non-printable, low-ordinal is
                                 * output raw */
                *r++ = (char)k;
            }
            else {  /* Is qq means use escape sequences */
d309 7
a315 7
		case '\a':  *r++ = 'a'; break;
		case '\b':  *r++ = 'b'; break;
		case '\t':  *r++ = 't'; break;
		case '\n':  *r++ = 'n'; break;
		case '\f':  *r++ = 'f'; break;
		case '\r':  *r++ = 'r'; break;
		case ESC_NATIVE: *r++ = 'e'; break;
d317 1
d323 2
a324 3
                    next_is_digit = (s + 1 >= send )
                                    ? FALSE
                                    : (*(U8*)(s+1) >= '0' && *(U8*)(s+1) <= '9');
d341 12
d381 1
a381 1
	sv = newSVpvs("");
d412 4
a415 1
	AV *postav, const I32 level, SV *apad, const Style *style)
d442 1
a442 1
    /* If the output buffer has less than some arbitrary amount of space
d458 4
a461 4
        if (SvOBJECT(SvRV(val)) && style->freezer &&
            SvPOK(style->freezer) && SvCUR(style->freezer) &&
            gv_fetchmeth(SvSTASH(SvRV(val)), SvPVX_const(style->freezer),
                         SvCUR(style->freezer), -1) != NULL)
d465 1
a465 1
            i = perl_call_method(SvPVX_const(style->freezer), G_EVAL|G_VOID|G_DISCARD);
d496 1
a496 1
		    if (style->purity && level > 0) {
d500 1
a500 1
			    sv_catpvs(retval, "{}");
d502 1
a502 1
			    sv_catpvs(retval, "[]");
d504 1
a504 1
			    sv_catpvs(retval, "do{my $o}");
d506 1
a506 1
			sv_catpvs(postentry, " = ");
d519 1
a519 1
				sv_catpvs(retval, "{");
d521 1
a521 1
				sv_catpvs(retval, "}");
d541 1
a541 1
		    namesv = newSVpvs("\\");
d545 1
a545 1
		    namesv = newSVpvs("\\");
d583 1
a583 1
        if (!style->purity && style->maxdepth > 0 && level >= style->maxdepth) {
d586 1
a586 1
	    sv_catpvs(retval, "'");
d588 1
a588 1
	    sv_catpvs(retval, "'");
d592 2
a593 2
        if (style->maxrecurse > 0 && level >= style->maxrecurse) {
            croak("Recursion limit of %" IVdf " exceeded", style->maxrecurse);
d598 1
a598 1
            const char * const blessstr = SvPV(style->bless, blesslen);
d600 2
a601 2
	    sv_catpvs(retval, "( ");
            if (style->indent >= 2) {
d608 2
a609 1
        ipad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad), SvCUR(style->xpad), level+1);
a647 1
	    assert(sv_pattern);
d651 1
a651 1
	    sv_catpvs(retval, "qr/");
d656 1
a656 1
		sv_catpvs(retval, "\\/");
d662 1
a662 1
	    sv_catpvs(retval, "/");
d673 1
a673 1
	    SV * const namesv = newSVpvs("${");
d675 1
a675 1
	    sv_catpvs(namesv, "}");
d677 1
a677 1
		sv_catpvs(retval, "do{\\(my $o = ");
d679 5
a683 2
			postav, level+1, apad, style);
		sv_catpvs(retval, ")}");
d686 1
a686 1
		sv_catpvs(retval, "\\");
d688 4
a691 1
			postav, level+1, apad, style);
d696 1
a696 1
	    SV * const namesv = newSVpvs("*{");
d698 2
a699 2
	    sv_catpvs(namesv, "}");
	    sv_catpvs(retval, "\\");
d701 4
a704 1
		    postav, level+1, apad, style);
d718 1
a718 1
		sv_catpvs(retval, "(");
d722 1
a722 1
		sv_catpvs(retval, "[");
d744 2
a745 2
            totpad = newSVsv(style->sep);
            sv_catsv(totpad, style->pad);
d766 1
a766 1
                if (style->indent >= 3) {
d769 1
a769 1
		    sv_catpvs(retval, "#");
d775 6
a780 3
			level+1, apad, style);
		if (ix < ixmax || (style->trailingcomma && style->indent >= 1))
		    sv_catpvs(retval, ",");
d783 1
a783 1
                SV * const opad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad), SvCUR(style->xpad), level);
d789 1
a789 1
		sv_catpvs(retval, ")");
d791 1
a791 1
		sv_catpvs(retval, "]");
d799 1
a799 1
	    HE *entry = NULL;
d801 1
a801 1
	    STRLEN klen;
d807 1
a807 1
		sv_catpvs(retval, "(");
d811 1
a811 1
		sv_catpvs(retval, "{");
d819 1
a819 1
		    sv_catpvs(iname, "->");
d826 1
a826 1
		sv_catpvs(iname, "->");
d828 3
a830 3
	    sv_catpvs(iname, "{");
            totpad = newSVsv(style->sep);
            sv_catsv(totpad, style->pad);
d834 5
a838 3
	    if (style->sortkeys) {
#if PERL_VERSION >= 8
		if (style->sortkeys == &PL_sv_yes) {
d846 8
a853 12
# ifdef USE_LOCALE_COLLATE
#       ifdef IN_LC     /* Use this if available */
                    if (IN_LC(LC_COLLATE))
#       else
                    if (IN_LOCALE)
#       endif
                    {
                        sortsv(AvARRAY(keys),
			   av_len(keys)+1,
                           Perl_sv_cmp_locale);
                    }
                    else
d855 1
a855 5
                    {
                        sortsv(AvARRAY(keys),
			   av_len(keys)+1,
                           Perl_sv_cmp);
                    }
d857 1
a857 3
                else
#endif
		{
d860 1
a860 1
		    i = perl_call_sv(style->sortkeys, G_SCALAR | G_EVAL);
d881 1
a881 1
                STRLEN nticks = 0;
d884 1
a884 1
                STRLEN nlen;
d887 1
a887 1
               if (style->sortkeys) {
d894 1
a894 1
		    sv_catpvs(retval, ",");
d896 1
a896 1
		if (style->sortkeys) {
d933 2
a934 2
                if (style->quotekeys || key_needs_quote(key,keylen)) {
                    if (do_utf8 || style->useqq) {
d936 1
a936 1
                        nlen = esc_q_utf8(aTHX_ retval, key, klen, do_utf8, style->useqq);
d961 1
a961 1
                sv_catpvs(sname, "}");
d963 2
a964 2
                sv_catsv(retval, style->pair);
                if (style->indent >= 2) {
d966 1
a966 1
                    STRLEN elen = 0;
d979 4
a982 1
			postav, level+1, newapad, style);
d985 1
a985 1
                if (style->indent >= 2)
d989 1
a989 4
                SV *opad = sv_x(aTHX_ Nullsv, SvPVX_const(style->xpad),
                                SvCUR(style->xpad), level);
                if (style->trailingcomma && style->indent >= 1)
                    sv_catpvs(retval, ",");
d995 1
a995 1
		sv_catpvs(retval, ")");
d997 1
a997 1
		sv_catpvs(retval, "}");
d1002 2
a1003 2
	    sv_catpvs(retval, "sub { \"DUMMY\" }");
            if (style->purity)
d1011 2
a1012 1
            STRLEN plen, pticks;
d1014 1
a1014 1
            if (style->indent >= 2) {
d1018 1
a1018 1
	    sv_catpvs(retval, ", '");
d1037 5
a1041 5
	    sv_catpvs(retval, "' )");
            if (style->toaster && SvPOK(style->toaster) && SvCUR(style->toaster)) {
		sv_catpvs(retval, "->");
                sv_catsv(retval, style->toaster);
		sv_catpvs(retval, "()");
d1045 1
d1066 1
a1066 1
		    sv_catpvs(retval, "${");
d1068 1
a1068 1
		    sv_catpvs(retval, "}");
d1079 2
a1080 2
            else if (val != &PL_sv_undef && (!style->use_sparse_seen_hash || SvREFCNT(val) > 1)) {
		SV * const namesv = newSVpvs("\\");
d1098 2
a1099 1
                 I'm assuming from sprintf isn't going to clash with utf8. */
d1131 1
a1131 1
                esc_q_utf8(aTHX_ retval, c, i, 1, style->useqq);
d1157 1
a1157 1
            if (style->purity) {
d1161 2
a1162 2
		SV * const nname = newSVpvs("");
		SV * const newapad = newSVpvs("");
d1174 1
d1179 1
a1179 1
			sv_catpvs(postentry, " = ");
d1184 1
a1184 1
                        if (style->indent >= 2)
d1188 5
a1192 1
				seenhv, postav, 0, newapad, style);
d1202 1
a1202 1
	    sv_catpvs(retval, "undef");
d1227 1
a1227 1
            if (style->useqq && safe_decimal_number(c, i)) {
d1230 2
a1231 2
            else if (DO_UTF8(val) || style->useqq)
                i += esc_q_utf8(aTHX_ retval, c, i, DO_UTF8(val), style->useqq);
d1246 1
a1246 1
        if (style->deepcopy)
d1262 1
a1262 1
#   * doesn't do deparse yet.'
d1275 2
a1276 1
	    I32 terse = 0;
d1279 4
a1282 4
            SV *apad = &PL_sv_undef;
            Style style;

            SV *name, *val = &PL_sv_undef, *varname = &PL_sv_undef;
d1284 2
a1285 1
	    I32 gimme = GIMME_V;
a1313 7
            style.indent = 2;
            style.quotekeys = 1;
            style.maxrecurse = 1000;
            style.purity = style.deepcopy = style.useqq = style.maxdepth
                = style.use_sparse_seen_hash = style.trailingcomma = 0;
            style.pad = style.xpad = style.sep = style.pair = style.sortkeys
                = style.freezer = style.toaster = style.bless = &PL_sv_undef;
d1315 2
d1318 3
d1322 1
a1322 1
	    retval = newSVpvs("");
d1330 1
a1330 1
                    style.use_sparse_seen_hash = 1;
d1332 1
a1332 1
                    style.use_sparse_seen_hash = (SvOK(*svp) && SvIV(*svp) != 0);
d1338 1
a1338 1
                    style.indent = SvIV(*svp);
d1340 1
a1340 1
                    style.purity = SvIV(*svp);
d1344 1
a1344 1
                    style.useqq = SvTRUE(*svp);
d1346 1
a1346 1
                    style.pad = *svp;
d1348 1
a1348 1
                    style.xpad = *svp;
d1352 1
a1352 1
                    style.sep = *svp;
d1354 1
a1354 1
                    style.pair = *svp;
d1358 1
a1358 1
                    style.freezer = *svp;
d1360 1
a1360 1
                    style.toaster = *svp;
d1362 1
a1362 1
                    style.deepcopy = SvTRUE(*svp);
d1364 1
a1364 3
                    style.quotekeys = SvTRUE(*svp);
                if ((svp = hv_fetch(hv, "trailingcomma", 13, FALSE)))
                    style.trailingcomma = SvTRUE(*svp);
d1366 1
a1366 1
                    style.bless = *svp;
d1368 1
a1368 1
                    style.maxdepth = SvIV(*svp);
d1370 1
a1370 1
                    style.maxrecurse = SvIV(*svp);
d1372 9
a1380 16
                    SV *sv = *svp;
                    if (! SvTRUE(sv))
                        style.sortkeys = NULL;
                    else if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
                        style.sortkeys = sv;
                    else if (PERL_VERSION < 8)
                        /* 5.6 doesn't make sortsv() available to XS code,
                         * so we must use this helper instead. Note that we
                         * always allocate this mortal SV, but it will be
                         * used only if at least one hash is encountered
                         * while dumping recursively; an older version
                         * allocated it lazily as needed. */
                        style.sortkeys = sv_2mortal(newSVpvs("Data::Dumper::_sortkeys"));
                    else
                        /* flag to use sortsv() for sorting hash keys */
                        style.sortkeys = &PL_sv_yes;
d1388 1
a1388 1
		valstr = newSVpvs("");
d1437 1
a1437 1
                    if (style.indent >= 2 && !terse) {
d1448 4
a1451 1
                            postav, 0, newapad, &style);
d1454 1
a1454 1
                    if (style.indent >= 2 && !terse)
d1461 1
a1461 1
			sv_catpvs(valstr, ";");
d1463 1
a1463 1
                    sv_catsv(retval, style.pad);
d1465 1
a1465 1
                    sv_catsv(retval, style.sep);
d1468 1
a1468 1
                        sv_catsv(retval, style.pad);
d1475 3
a1477 3
				    sv_catpvs(retval, ";");
                                    sv_catsv(retval, style.sep);
                                    sv_catsv(retval, style.pad);
d1481 2
a1482 2
			sv_catpvs(retval, ";");
                        sv_catsv(retval, style.sep);
d1488 1
a1488 1
			    retval = newSVpvs("");
d1496 1
a1496 1
	    if (gimme != G_ARRAY)
@


