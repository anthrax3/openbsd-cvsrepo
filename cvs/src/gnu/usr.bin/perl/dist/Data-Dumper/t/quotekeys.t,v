head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.4
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1;
locks; strict;
comment	@# @;
expand	@b@;


1.2
date	2017.02.05.00.32.08;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2014.03.24.14.58.59;	author afresh1;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2014.03.24.14.58.59;	author afresh1;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.02;	author afresh1;	state Exp;
branches;
next	1.1.1.3;
commitid	B31cAbBIXiCqnL97;

1.1.1.3
date	2017.08.14.13.46.07;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w
# t/quotekeys.t - Test Quotekeys()

BEGIN {
    if ($ENV{PERL_CORE}){
        require Config; import Config;
        no warnings 'once';
        if ($Config{'extensions'} !~ /\bData\/Dumper\b/) {
            print "1..0 # Skip: Data::Dumper was not built\n";
            exit 0;
        }
    }
}

use strict;

use Data::Dumper;
use Test::More tests => 18;
use lib qw( ./t/lib );
use Testing qw( _dumptostr );

my %d = (
    delta   => 'd',
    beta    => 'b',
    gamma   => 'c',
    alpha   => 'a',
);

my $is_ascii = ord("A") == 65;

run_tests_for_quotekeys();
SKIP: {
    skip "XS version was unavailable, so we already ran with pure Perl", 5
        if $Data::Dumper::Useperl;
    local $Data::Dumper::Useperl = 1;
    run_tests_for_quotekeys();
}

sub run_tests_for_quotekeys {
    note("\$Data::Dumper::Useperl = $Data::Dumper::Useperl");

    my ($obj, %dumps, $quotekeys, $starting);

    note("\$Data::Dumper::Quotekeys and Quotekeys() set to true value");

    $obj = Data::Dumper->new( [ \%d ] );
    $dumps{'ddqkdefault'} = _dumptostr($obj);

    $starting = $Data::Dumper::Quotekeys;
    $quotekeys = 1;
    local $Data::Dumper::Quotekeys = $quotekeys;
    $obj = Data::Dumper->new( [ \%d ] );
    $dumps{'ddqkone'} = _dumptostr($obj);
    local $Data::Dumper::Quotekeys = $starting;

    $obj = Data::Dumper->new( [ \%d ] );
    $obj->Quotekeys($quotekeys);
    $dumps{'objqkone'} = _dumptostr($obj);

    is($dumps{'ddqkdefault'}, $dumps{'ddqkone'},
        "\$Data::Dumper::Quotekeys = 1 is default");
    is($dumps{'ddqkone'}, $dumps{'objqkone'},
        "\$Data::Dumper::Quotekeys = 1 and Quotekeys(1) are equivalent");
    %dumps = ();

    $quotekeys = 0;
    local $Data::Dumper::Quotekeys = $quotekeys;
    $obj = Data::Dumper->new( [ \%d ] );
    $dumps{'ddqkzero'} = _dumptostr($obj);
    local $Data::Dumper::Quotekeys = $starting;

    $obj = Data::Dumper->new( [ \%d ] );
    $obj->Quotekeys($quotekeys);
    $dumps{'objqkzero'} = _dumptostr($obj);

    is($dumps{'ddqkzero'}, $dumps{'objqkzero'},
        "\$Data::Dumper::Quotekeys = 0 and Quotekeys(0) are equivalent");

    $quotekeys = undef;
    local $Data::Dumper::Quotekeys = $quotekeys;
    $obj = Data::Dumper->new( [ \%d ] );
    $dumps{'ddqkundef'} = _dumptostr($obj);
    local $Data::Dumper::Quotekeys = $starting;

    $obj = Data::Dumper->new( [ \%d ] );
    $obj->Quotekeys($quotekeys);
    $dumps{'objqkundef'} = _dumptostr($obj);

    note("Quotekeys(undef) will fall back to the default value\nfor \$Data::Dumper::Quotekeys, which is a true value.");
    isnt($dumps{'ddqkundef'}, $dumps{'objqkundef'},
        "\$Data::Dumper::Quotekeys = undef and Quotekeys(undef) are equivalent");
    isnt($dumps{'ddqkzero'}, $dumps{'objqkundef'},
        "\$Data::Dumper::Quotekeys = undef and = 0 are equivalent");
    %dumps = ();

    local $Data::Dumper::Quotekeys = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Indent = 0;
    local $Data::Dumper::Useqq = 0;

    my %qkdata =
      (
       0 => 1,
       '012345' => 1,
       12 => 1,
       123456789 => 1,
       1234567890 => 1,
       '::de::fg' => 1,
       ab => 1,
       'hi::12' => 1,
       "1\x{660}" => 1,
      );

    is(Dumper(\%qkdata),
       (($is_ascii) # Sort order is different on EBCDIC platforms
        ? q($VAR1 = {'0' => 1,'012345' => 1,'12' => 1,'123456789' => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,'ab' => 1,'hi::12' => 1};)
        : q($VAR1 = {'::de::fg' => 1,'ab' => 1,'hi::12' => 1,'0' => 1,'012345' => 1,'12' => 1,'123456789' => 1,'1234567890' => 1,"1\x{660}" => 1};)),
       "always quote when quotekeys true");

    {
        local $Data::Dumper::Useqq = 1;
        is(Dumper(\%qkdata),
           (($is_ascii)
	    ? q($VAR1 = {"0" => 1,"012345" => 1,"12" => 1,"123456789" => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,"ab" => 1,"hi::12" => 1};)
            : q($VAR1 = {"::de::fg" => 1,"ab" => 1,"hi::12" => 1,"0" => 1,"012345" => 1,"12" => 1,"123456789" => 1,"1234567890" => 1,"1\x{660}" => 1};)),
	   "always quote when quotekeys true (useqq)");
    }

    local $Data::Dumper::Quotekeys = 0;

    is(Dumper(\%qkdata),
        (($is_ascii)
         ? q($VAR1 = {0 => 1,'012345' => 1,12 => 1,123456789 => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,ab => 1,'hi::12' => 1};)
         : q($VAR1 = {'::de::fg' => 1,ab => 1,'hi::12' => 1,0 => 1,'012345' => 1,12 => 1,123456789 => 1,'1234567890' => 1,"1\x{660}" => 1};)),
	      "avoid quotes when quotekeys false");
    {
        local $Data::Dumper::Useqq = 1;
	is(Dumper(\%qkdata),
            (($is_ascii)
	     ? q($VAR1 = {0 => 1,"012345" => 1,12 => 1,123456789 => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,ab => 1,"hi::12" => 1};)
             : q($VAR1 = {"::de::fg" => 1,ab => 1,"hi::12" => 1,0 => 1,"012345" => 1,12 => 1,123456789 => 1,"1234567890" => 1,"1\x{660}" => 1};)),
	      "avoid quotes when quotekeys false (useqq)");
    }
}

@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
use Test::More tests => 10;
d29 2
d95 49
@


1.1.1.1
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d18 1
a18 1
use Test::More tests => 18;
a92 41

    local $Data::Dumper::Quotekeys = 1;
    local $Data::Dumper::Sortkeys = 1;
    local $Data::Dumper::Indent = 0;
    local $Data::Dumper::Useqq = 0;

    my %qkdata =
      (
       0 => 1,
       '012345' => 1,
       12 => 1,
       123456789 => 1,
       1234567890 => 1,
       '::de::fg' => 1,
       ab => 1,
       'hi::12' => 1,
       "1\x{660}" => 1,
      );

    is(Dumper(\%qkdata),
       q($VAR1 = {'0' => 1,'012345' => 1,'12' => 1,'123456789' => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,'ab' => 1,'hi::12' => 1};),
       "always quote when quotekeys true");

    {
        local $Data::Dumper::Useqq = 1;
        is(Dumper(\%qkdata),
	   q($VAR1 = {"0" => 1,"012345" => 1,"12" => 1,"123456789" => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,"ab" => 1,"hi::12" => 1};),
	   "always quote when quotekeys true (useqq)");
    }

    local $Data::Dumper::Quotekeys = 0;

    is(Dumper(\%qkdata),
       q($VAR1 = {0 => 1,'012345' => 1,12 => 1,123456789 => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,ab => 1,'hi::12' => 1};),
	      "avoid quotes when quotekeys false");
    {
        local $Data::Dumper::Useqq = 1;
	is(Dumper(\%qkdata),
	   q($VAR1 = {0 => 1,"012345" => 1,12 => 1,123456789 => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,ab => 1,"hi::12" => 1};),
	      "avoid quotes when quotekeys false (useqq)");
    }
@


1.1.1.3
log
@Import perl-5.24.2
@
text
@a28 2
my $is_ascii = ord("A") == 65;

d113 1
a113 3
       (($is_ascii) # Sort order is different on EBCDIC platforms
        ? q($VAR1 = {'0' => 1,'012345' => 1,'12' => 1,'123456789' => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,'ab' => 1,'hi::12' => 1};)
        : q($VAR1 = {'::de::fg' => 1,'ab' => 1,'hi::12' => 1,'0' => 1,'012345' => 1,'12' => 1,'123456789' => 1,'1234567890' => 1,"1\x{660}" => 1};)),
d119 1
a119 3
           (($is_ascii)
	    ? q($VAR1 = {"0" => 1,"012345" => 1,"12" => 1,"123456789" => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,"ab" => 1,"hi::12" => 1};)
            : q($VAR1 = {"::de::fg" => 1,"ab" => 1,"hi::12" => 1,"0" => 1,"012345" => 1,"12" => 1,"123456789" => 1,"1234567890" => 1,"1\x{660}" => 1};)),
d126 1
a126 3
        (($is_ascii)
         ? q($VAR1 = {0 => 1,'012345' => 1,12 => 1,123456789 => 1,'1234567890' => 1,"1\x{660}" => 1,'::de::fg' => 1,ab => 1,'hi::12' => 1};)
         : q($VAR1 = {'::de::fg' => 1,ab => 1,'hi::12' => 1,0 => 1,'012345' => 1,12 => 1,123456789 => 1,'1234567890' => 1,"1\x{660}" => 1};)),
d131 1
a131 3
            (($is_ascii)
	     ? q($VAR1 = {0 => 1,"012345" => 1,12 => 1,123456789 => 1,"1234567890" => 1,"1\x{660}" => 1,"::de::fg" => 1,ab => 1,"hi::12" => 1};)
             : q($VAR1 = {"::de::fg" => 1,ab => 1,"hi::12" => 1,0 => 1,"012345" => 1,12 => 1,123456789 => 1,"1234567890" => 1,"1\x{660}" => 1};)),
@


