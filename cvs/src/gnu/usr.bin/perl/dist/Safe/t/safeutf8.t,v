head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.1.0.26
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.20
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.22
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.14
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.18
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.16
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.12
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.10;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.48.48;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl -w
$|=1;
BEGIN {
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bOpcode\b/ && $Config{'osname'} ne 'VMS') {
        print "1..0\n";
        exit 0;
    }
}

use Test::More tests => 7;

use Safe 1.00;
use Opcode qw(full_opset);

pass;

my $safe = Safe->new('PLPerl');
$safe->deny_only();

# Expression that triggers require utf8 and call to SWASHNEW.
# Fails with "Undefined subroutine PLPerl::utf8::SWASHNEW called"
# if SWASHNEW is not shared, else returns true if unicode logic is working.
# (For early Perls we don't take into account EBCDIC, so will fail there
my $trigger = q{ my $a = pack('U',0xC4); my $b = chr }
            . (($] lt 5.007_003) ? "" : 'utf8::unicode_to_native(')
            . '0xE4'
            . (($] lt 5.007_003) ? "" : ')')
            . q{; utf8::upgrade $b; $a =~ /$b/i };

ok $safe->reval( $trigger ), 'trigger expression should return true';
is $@@, '', 'trigger expression should not die';

# return a closure
my $sub = $safe->reval(q{sub { warn pack('U',0xC4) }});

# define code outside Safe that'll be triggered from inside
my @@warns;
$SIG{__WARN__} = sub {
    my $msg = shift;
    # this regex requires a different SWASH digit data for \d)
    # than the one used above and by the trigger code in Safe.pm
    $msg =~ s/\(eval \d+\)/XXX/i; # uses IsDigit SWASH
    push @@warns, $msg;
};

is eval { $sub->() }, 1, 'warn should return 1';
is $@@, '', '__WARN__ hook should not die';
is @@warns, 1, 'should only be 1 warning';
like $warns[0], qr/at XXX line/, 'warning should have been edited';

@


1.1
log
@Initial revision
@
text
@d24 6
a29 1
my $trigger = q{ my $a = pack('U',0xC4); my $b = chr 0xE4; utf8::upgrade $b; $a =~ /$b/i };
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@
