head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.14
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.16
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.10
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.12
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.4
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2013.03.25.20.08.36;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.36;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl
use strict;
use warnings;

# tests for the quick-n-dirty interface for XS inclusion

use Test::More tests => 6;
use File::Spec;
use ExtUtils::Typemaps::Cmd;

my $datadir = -d 't' ? File::Spec->catdir(qw/t data/) : 'data';
my $libdir = -d 't' ? File::Spec->catdir(qw/t lib/) : 'lib';

unshift @@INC, $libdir;

sub slurp {
  my $file = shift;
  open my $fh, '<', $file
    or die "Cannot open file '$file' for reading: $!";
  local $/ = undef;
  return <$fh>;
}

sub permute (&@@) {
  my $code = shift;
  my @@idx = 0..$#_;
  while ( $code->(@@_[@@idx]) ) {
    my $p = $#idx;
    --$p while $idx[$p-1] > $idx[$p];
    my $q = $p or return;
    push @@idx, reverse splice @@idx, $p;
    ++$q while $idx[$p-1] > $idx[$q];
    @@idx[$p-1,$q]=@@idx[$q,$p-1];
  }
}


SCOPE: {
  no warnings 'once';
  ok(defined(*embeddable_typemap{CODE}), "function exported");
}

my $start = "TYPEMAP: <<END_TYPEMAP;\n";
my $end = "\nEND_TYPEMAP\n";
is(
  embeddable_typemap(),
  "${start}TYPEMAP\n$end",
  "empty call to embeddable_typemap"
);

my $typemap_file = File::Spec->catfile($datadir, "simple.typemap");
is(
  embeddable_typemap($typemap_file),
  $start . slurp($typemap_file) . $end,
  "embeddable typemap from file"
);

my $foo_content = <<HERE;
TYPEMAP
myfoo*	T_PV
HERE
is(
  embeddable_typemap("TypemapTest::Foo"),
  "$start$foo_content$end",
  "embeddable typemap from full module name"
);


my $test_content = <<HERE;
TYPEMAP
mytype*	T_SV
HERE
is(
  embeddable_typemap("Test"),
  "$start$test_content$end",
  "embeddable typemap from relative module name"
);

SCOPE: {
  my $combined = embeddable_typemap("Test", "TypemapTest::Foo");
  my @@lines = (
    'myfoo*	T_PV',
    'mytype*	T_SV',
  );
  my @@exp = map {"TYPEMAP\n" . join("\n", @@$_) . "\n"}
            (\@@lines, [reverse @@lines]);
  ok(scalar(grep "$start$_$end" eq $combined, @@exp), "combined both modules")
    or note("Actual output: '$combined'");
}

# in theory, we should test
# embeddable_typemap($typemap_file, "Test", "TypemapTest::Foo"),
# but I can't be bothered.
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@
