head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.14
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.12
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.8
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2013.03.25.20.08.36;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.08.36;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.03;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl
use strict;
use warnings;
use Carp;
use Cwd;
use File::Spec;
use File::Temp qw( tempdir );
use Test::More tests => 13;
use lib qw( lib t/lib );
use ExtUtils::ParseXS;
use ExtUtils::ParseXS::Utilities qw(
    check_conditional_preprocessor_statements
);
use PrimitiveCapture;

my $self = bless({} => 'ExtUtils::ParseXS');
$self->{line} = [];
$self->{XSStack} = [];
$self->{XSStack}->[0] = {};

{
    $self->{line} = [
        "#if this_is_an_if_statement",
        "Alpha this is not an if/elif/elsif/endif",
        "#elif this_is_an_elif_statement",
        "Beta this is not an if/elif/elsif/endif",
        "#else this_is_an_else_statement",
        "Gamma this is not an if/elif/elsif/endif",
        "#endif this_is_an_endif_statement",
    ];
    $self->{line_no} = [ 17 .. 23 ];
    $self->{XSStack}->[-1]{type} = 'if';
    $self->{filename} = 'myfile1';

    my $rv;
    my $stderr = PrimitiveCapture::capture_stderr(sub {
        $rv = check_conditional_preprocessor_statements($self);
    });
        
    is( $rv, 0, "Basic case: returned 0: all ifs resolved" );
    ok( ! $stderr, "No warnings captured, as expected" );
}

{
    $self->{line} = [
        "#if this_is_an_if_statement",
        "Alpha this is not an if/elif/elsif/endif",
        "#if this_is_a_different_if_statement",
        "Beta this is not an if/elif/elsif/endif",
        "#endif this_is_a_different_endif_statement",
        "Gamma this is not an if/elif/elsif/endif",
        "#endif this_is_an_endif_statement",
    ];
    $self->{line_no} = [ 17 .. 23 ];
    $self->{XSStack}->[-1]{type} = 'if';
    $self->{filename} = 'myfile1';

    my $rv;
    my $stderr = PrimitiveCapture::capture_stderr(sub {
        $rv = check_conditional_preprocessor_statements($self);
    });
    is( $rv, 0, "One nested if case: returned 0: all ifs resolved" );
    ok( ! $stderr, "No warnings captured, as expected" );
}

{
    $self->{line} = [
        "Alpha this is not an if/elif/elsif/endif",
        "#elif this_is_an_elif_statement",
        "Beta this is not an if/elif/elsif/endif",
        "#else this_is_an_else_statement",
        "Gamma this is not an if/elif/elsif/endif",
        "#endif this_is_an_endif_statement",
    ];
    $self->{line_no} = [ 17 .. 22 ];
    $self->{XSStack}->[-1]{type} = 'if';
    $self->{filename} = 'myfile1';

    my $rv;
    my $stderr = PrimitiveCapture::capture_stderr(sub {
        $rv = check_conditional_preprocessor_statements($self);
    });
    is( $rv, undef,
        "Missing 'if' case: returned undef: all ifs resolved" );
    like( $stderr,
        qr/Warning: #else\/elif\/endif without #if in this function/,
        "Got expected warning: lack of #if"
    );
    like( $stderr,
        qr/precede it with a blank line/s,
        "Got expected warning: advice re blank line"
    );
}

{
    $self->{line} = [
        "Alpha this is not an if/elif/elsif/endif",
        "#elif this_is_an_elif_statement",
        "Beta this is not an if/elif/elsif/endif",
        "#else this_is_an_else_statement",
        "Gamma this is not an if/elif/elsif/endif",
        "#endif this_is_an_endif_statement",
    ];
    $self->{line_no} = [ 17 .. 22 ];
    $self->{XSStack}->[-1]{type} = 'file';
    $self->{filename} = 'myfile1';

    my $rv;
    my $stderr = PrimitiveCapture::capture_stderr(sub {
        $rv = check_conditional_preprocessor_statements($self);
    });
    is( $rv, undef,
        "Missing 'if' case: returned undef: all ifs resolved" );
    like( $stderr,
        qr/Warning: #else\/elif\/endif without #if in this function/,
        "Got expected warning: lack of #if"
    );
    unlike( $stderr,
        qr/precede it with a blank line/s,
        "Did not get unexpected stderr"
    );
}

{
    $self->{line} = [
        "#if this_is_an_if_statement",
        "Alpha this is not an if/elif/elsif/endif",
        "#elif this_is_an_elif_statement",
        "Beta this is not an if/elif/elsif/endif",
        "#else this_is_an_else_statement",
        "Gamma this is not an if/elif/elsif/endif",
    ];
    $self->{line_no} = [ 17 .. 22 ];
    $self->{XSStack}->[-1]{type} = 'if';
    $self->{filename} = 'myfile1';

    my $rv;
    my $stderr = PrimitiveCapture::capture_stderr(sub {
        $rv = check_conditional_preprocessor_statements($self);
    });
    isnt( $rv, 0,
        "Missing 'endif' case: returned non-zero as expected" );
    like( $stderr,
        qr/Warning: #if without #endif in this function/s,
        "Got expected warning: lack of #endif"
    );
}

pass("Passed all tests in $0");
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d4 2
d7 1
a7 1
use lib (-d 't' ? File::Spec->catdir(qw(t lib)) : 'lib');
d9 1
@

