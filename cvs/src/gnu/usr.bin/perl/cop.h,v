head	1.18;
access;
symbols
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2016.07.03.01.07.47;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	GzHqjSTnBjdF7Wcw;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.34.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.07.17.51.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.37;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.37;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.33;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.38;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.24;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.34;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.20;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.35;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    cop.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Control ops (cops) are one of the two ops OP_NEXTSTATE and OP_DBSTATE,
 * that (loosely speaking) are statement separators.
 * They hold information important for lexical state and error reporting.
 * At run time, PL_curcop is set to point to the most recently executed cop,
 * and thus can be used to determine our current state.
 */

/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a PL_start_env initialized when perl starts, and
 * PL_top_env points to this initially, so PL_top_env should always be
 * non-null.
 *
 * Existence of a non-null PL_top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure PL_start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* uninit if je_prev is NULL */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
    U16                 je_old_delaymagic; /* saved PL_delaymagic */
};

typedef struct jmpenv JMPENV;

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	PERL_POISON_EXPR(PoisonNew(&PL_start_env, 1, JMPENV));\
	PL_top_env = &PL_start_env;		\
	PL_start_env.je_prev = NULL;		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
	PL_start_env.je_old_delaymagic = 0;	\
    } STMT_END

/*
 *   PERL_FLEXIBLE_EXCEPTIONS
 * 
 * All the flexible exceptions code has been removed.
 * See the following threads for details:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2004-07/msg00378.html
 * 
 * Joshua's original patches (which weren't applied) and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01396.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01489.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01491.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01608.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02144.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02998.html
 * 
 * Chip's reworked patch and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1999-03/msg00520.html
 * 
 * The flaw in these patches (which went unnoticed at the time) was
 * that they moved some code that could potentially die() out of the
 * region protected by the setjmp()s.  This caused exceptions within
 * END blocks and such to not be handled by the correct setjmp().
 * 
 * The original patches that introduces flexible exceptions were:
 *
 * http://perl5.git.perl.org/perl.git/commit/312caa8e97f1c7ee342a9895c2f0e749625b4929
 * http://perl5.git.perl.org/perl.git/commit/14dd3ad8c9bf82cf09798a22cc89a9862dfd6d1a                                        
 *  
 */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l({							\
	    int i = 0; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_PUSH level=%d at %s:%d\n",		\
		         i,  __FILE__, __LINE__);})			\
	cur_env.je_prev = PL_top_env;					\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	cur_env.je_old_delaymagic = PL_delaymagic;			\
	(v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START {							\
	DEBUG_l({							\
	    int i = -1; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_POP level=%d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	assert(PL_top_env == &cur_env);					\
	PL_delaymagic = cur_env.je_old_delaymagic;			\
	PL_top_env = cur_env.je_prev;					\
    } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
	DEBUG_l({						\
	    int i = -1; JMPENV *p = PL_top_env;			\
	    while (p) { i++; p = p->je_prev; }			\
	    Perl_deb(aTHX_ "JUMPENV_JUMP(%d) level=%d at %s:%d\n", \
		         (int)v, i, __FILE__, __LINE__);})	\
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_EXIT);		                \
	PerlIO_printf(PerlIO_stderr(), "panic: top_env, v=%d\n", (int)v); \
	PerlProc_exit(1);					\
    } STMT_END

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v) \
    STMT_START {							\
	DEBUG_l(							\
	    Perl_deb(aTHX_						\
		"JUMPLEVEL set catch %d => %d (for %p) at %s:%d\n",	\
		 PL_top_env->je_mustcatch, v, (void*)PL_top_env,	\
		 __FILE__, __LINE__);)					\
	PL_top_env->je_mustcatch = (v);					\
    } STMT_END

/*
=head1 COP Hint Hashes
*/

typedef struct refcounted_he COPHH;

#define COPHH_KEY_UTF8 REFCOUNTED_HE_KEY_UTF8

/*
=for apidoc Amx|SV *|cophh_fetch_pvn|const COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the entry in the cop hints hash C<cophh> with the key specified by
C<keypv> and C<keylen>.  If C<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  C<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cophh_fetch_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, keypv, keylen, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_fetch_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.

=cut
*/

#define cophh_fetch_pvs(cophh, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_fetch_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_pv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_fetch_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_sv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|HV *|cophh_2hv|const COPHH *cophh|U32 flags

Generates and returns a standard Perl hash representing the full set of
key/value pairs in the cop hints hash C<cophh>.  C<flags> is currently
unused and must be zero.

=cut
*/

#define cophh_2hv(cophh, flags) \
    Perl_refcounted_he_chain_2hv(aTHX_ cophh, flags)

/*
=for apidoc Amx|COPHH *|cophh_copy|COPHH *cophh

Make and return a complete copy of the cop hints hash C<cophh>.

=cut
*/

#define cophh_copy(cophh) Perl_refcounted_he_inc(aTHX_ cophh)

/*
=for apidoc Amx|void|cophh_free|COPHH *cophh

Discard the cop hints hash C<cophh>, freeing all resources associated
with it.

=cut
*/

#define cophh_free(cophh) Perl_refcounted_he_free(aTHX_ cophh)

/*
=for apidoc Amx|COPHH *|cophh_new_empty

Generate and return a fresh cop hints hash containing no entries.

=cut
*/

#define cophh_new_empty() ((COPHH *)NULL)

/*
=for apidoc Amx|COPHH *|cophh_store_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|SV *value|U32 flags

Stores a value, associated with a key, in the cop hints hash C<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by C<keypv> and C<keylen>.  If C<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  C<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

C<value> is the scalar value to store for this key.  C<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the cop hints hash.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.

=cut
*/

#define cophh_store_pvn(cophh, keypv, keylen, hash, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pvs|const COPHH *cophh|const char *key|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.

=cut
*/

#define cophh_store_pvs(cophh, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pv|const COPHH *cophh|const char *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_store_pv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_sv|const COPHH *cophh|SV *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_store_sv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Delete a key and its associated value from the cop hints hash C<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by C<keypv> and C<keylen>.  If C<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  C<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

=cut
*/

#define cophh_delete_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_delete_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.

=cut
*/

#define cophh_delete_pvs(cophh, key, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_delete_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_delete_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

#include "mydtrace.h"

struct cop {
    BASEOP
    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't
       an exact multiple of 8 bytes to save structure padding.  */
    line_t      cop_line;       /* line # of this command */
    /* label for this construct is now stored in cop_hints_hash */
#ifdef USE_ITHREADS
    PADOFFSET	cop_stashoff;	/* offset into PL_stashpad, for the
				   package the line was compiled in */
    char *	cop_file;	/* file name the following line # is from */
#else
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* file the following line # is from */
#endif
    U32		cop_hints;	/* hints bits from pragmata */
    U32		cop_seq;	/* parse sequence number */
    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
    STRLEN *	cop_warnings;	/* lexical warnings bitmask */
    /* compile time state of %^H.  See the comment in op.c for how this is
       used to recreate a hash to return from caller.  */
    COPHH *	cop_hints_hash;
};

#ifdef USE_ITHREADS
#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
				 ? gv_fetchfile(CopFILE(c)) : NULL)
				 
#  ifdef NETWARE
#    define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepvn((pv),(l)))
#  else
#    define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savesharedpvn((pv),(l)))
#  endif

#  define CopFILESV(c)		(CopFILE(c) \
				 ? GvSV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAV(c)		(CopFILE(c) \
				 ? GvAV(gv_fetchfile(CopFILE(c))) : NULL)
#  define CopFILEAVx(c)		(assert_(CopFILE(c)) \
				   GvAV(gv_fetchfile(CopFILE(c))))

#  define CopSTASH(c)           PL_stashpad[(c)->cop_stashoff]
#  define CopSTASH_set(c,hv)	((c)->cop_stashoff = (hv)		\
				    ? alloccopstash(hv)			\
				    : 0)
#  ifdef NETWARE
#    define CopFILE_free(c) SAVECOPFILE_FREE(c)
#  else
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = NULL))
#  endif
#else
#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
#  define CopFILE_setn(c,pv,l)	CopFILEGV_set((c), gv_fetchfile_flags((pv),(l),0))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : NULL)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILEGV(c)), GvAV(CopFILEGV(c)))
#  else
#    define CopFILEAVx(c)	(GvAV(CopFILEGV(c)))
# endif
#  define CopFILE(c)		(CopFILEGV(c) \
				    ? GvNAME(CopFILEGV(c))+2 : NULL)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = NULL))

#endif /* USE_ITHREADS */

#define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))

#define CopHINTHASH_get(c)	((COPHH*)((c)->cop_hints_hash))
#define CopHINTHASH_set(c,h)	((c)->cop_hints_hash = (h))

/*
=head1 COP Hint Reading
*/

/*
=for apidoc Am|SV *|cop_hints_fetch_pvn|const COP *cop|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the hint entry in the cop C<cop> with the key specified by
C<keypv> and C<keylen>.  If C<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  C<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cop_hints_fetch_pvn(cop, keypv, keylen, hash, flags) \
    cophh_fetch_pvn(CopHINTHASH_get(cop), keypv, keylen, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pvs|const COP *cop|const char *key|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a C<NUL>-terminated literal string
instead of a string/length pair, and no precomputed hash.

=cut
*/

#define cop_hints_fetch_pvs(cop, key, flags) \
    cophh_fetch_pvs(CopHINTHASH_get(cop), key, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pv|const COP *cop|const char *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=cut
*/

#define cop_hints_fetch_pv(cop, key, hash, flags) \
    cophh_fetch_pv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_sv|const COP *cop|SV *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cop_hints_fetch_sv(cop, key, hash, flags) \
    cophh_fetch_sv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|HV *|cop_hints_2hv|const COP *cop|U32 flags

Generates and returns a standard Perl hash representing the full set of
hint entries in the cop C<cop>.  C<flags> is currently unused and must
be zero.

=cut
*/

#define cop_hints_2hv(cop, flags) \
    cophh_2hv(CopHINTHASH_get(cop), flags)

#define CopLABEL(c)  Perl_cop_fetch_label(aTHX_ (c), NULL, NULL)
#define CopLABEL_len(c,len)  Perl_cop_fetch_label(aTHX_ (c), len, NULL)
#define CopLABEL_len_flags(c,len,flags)  Perl_cop_fetch_label(aTHX_ (c), len, flags)
#define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)

#define CopSTASH_ne(c,hv)	(!CopSTASH_eq(c,hv))
#define CopLINE(c)		((c)->cop_line)
#define CopLINE_inc(c)		(++CopLINE(c))
#define CopLINE_dec(c)		(--CopLINE(c))
#define CopLINE_set(c,l)	(CopLINE(c) = (l))

/* OutCopFILE() is CopFILE for output (caller, die, warn, etc.) */
#define OutCopFILE(c) CopFILE(c)

#define CopHINTS_get(c)		((c)->cop_hints + 0)
#define CopHINTS_set(c, h)	STMT_START {				\
				    (c)->cop_hints = (h);		\
				} STMT_END

/*
 * Here we have some enormously heavy (or at least ponderous) wizardry.
 */

/* subroutine context */
struct block_sub {
    OP *	retop;	/* op to execute on exit from sub */
    /* Above here is the same for sub, format and eval.  */
    PAD		*prevcomppad; /* the caller's PL_comppad */
    CV *	cv;
    /* Above here is the same for sub and format.  */
    I32		olddepth;
    AV  	*savearray;
};


/* format context */
struct block_format {
    OP *	retop;	/* op to execute on exit from sub */
    /* Above here is the same for sub, format and eval.  */
    PAD		*prevcomppad; /* the caller's PL_comppad */
    CV *	cv;
    /* Above here is the same for sub and format.  */
    GV *	gv;
    GV *	dfoutgv;
};

/* return a pointer to the current context */

#define CX_CUR() (&cxstack[cxstack_ix])

/* free all savestack items back to the watermark of the specified context */

#define CX_LEAVE_SCOPE(cx) LEAVE_SCOPE(cx->blk_oldsaveix)

#ifdef DEBUGGING
/* on debugging builds, poison cx afterwards so we know no code
 * uses it - because after doing cxstack_ix--, any ties, exceptions etc
 * may overwrite the current stack frame */
#  define CX_POP(cx)                                                   \
        assert(CX_CUR() == cx);                                        \
        cxstack_ix--;                                                  \
        cx = NULL;
#else
#  define CX_POP(cx) cxstack_ix--;
#endif


/* base for the next two macros. Don't use directly.
 * The context frame holds a reference to the CV so that it can't be
 * freed while we're executing it */


#define CX_PUSHSUB_GET_LVALUE_MASK(func) \
	/* If the context is indeterminate, then only the lvalue */	\
	/* flags that the caller also has are applicable.        */	\
	(								\
	   (PL_op->op_flags & OPf_WANT)					\
	       ? OPpENTERSUB_LVAL_MASK					\
	       : !(PL_op->op_private & OPpENTERSUB_LVAL_MASK)		\
	           ? 0 : (U8)func(aTHX)					\
	)

/* Restore old @@_ */
#define CX_POP_SAVEARRAY(cx)						\
    STMT_START {							\
        AV *av = GvAV(PL_defgv);                                        \
	GvAV(PL_defgv) = cx->blk_sub.savearray;				\
        cx->blk_sub.savearray = NULL;                                   \
        SvREFCNT_dec(av);	        				\
    } STMT_END

/* junk in @@_ spells trouble when cloning CVs and in pp_caller(), so don't
 * leave any (a fast av_clear(ary), basically) */
#define CLEAR_ARGARRAY(ary) \
    STMT_START {							\
	AvMAX(ary) += AvARRAY(ary) - AvALLOC(ary);			\
	AvARRAY(ary) = AvALLOC(ary);					\
	AvFILLp(ary) = -1;						\
    } STMT_END


/* eval context */
struct block_eval {
    OP *	retop;	/* op to execute on exit from eval */
    /* Above here is the same for sub, format and eval.  */
    SV *	old_namesv;
    OP *	old_eval_root;
    SV *	cur_text;
    CV *	cv;
    JMPENV *	cur_top_env; /* value of PL_top_env when eval CX created */
};

/* If we ever need more than 512 op types, change the shift from 7.
   blku_gimme is actually also only 2 bits, so could be merged with something.
*/

#define CxOLD_IN_EVAL(cx)	(((cx)->blk_u16) & 0x7F)
#define CxOLD_OP_TYPE(cx)	(((cx)->blk_u16) >> 7)

/* loop context */
struct block_loop {
    LOOP *	my_op;	/* My op, that contains redo, next and last ops.  */
    union {	/* different ways of locating the iteration variable */
	SV      **svp; /* for lexicals: address of pad slot */
	GV      *gv;   /* for package vars */
    } itervar_u;
    SV          *itersave; /* the original iteration var */
    union {
	struct { /* CXt_LOOP_ARY, C<for (@@ary)>  */
	    AV *ary; /* array being iterated over */
	    IV  ix;   /* index relative to base of array */
	} ary;
	struct { /* CXt_LOOP_LIST, C<for (list)> */
	    I32 basesp; /* first element of list on stack */
	    IV  ix;      /* index relative to basesp */
	} stack;
	struct { /* CXt_LOOP_LAZYIV, C<for (1..9)> */
	    IV cur;
	    IV end;
	} lazyiv;
	struct { /* CXt_LOOP_LAZYSV C<for ('a'..'z')> */
	    SV * cur;
	    SV * end; /* maxiumum value (or minimum in reverse) */
	} lazysv;
    } state_u;
#ifdef USE_ITHREADS
    PAD *oldcomppad; /* needed to map itervar_u.svp during thread clone */
#endif
};

#define CxITERVAR(c)                                    \
        (CxPADLOOP(c)                                   \
            ? (c)->blk_loop.itervar_u.svp               \
            : ((c)->cx_type & CXp_FOR_GV)               \
                ? &GvSV((c)->blk_loop.itervar_u.gv)     \
                : (SV **)&(c)->blk_loop.itervar_u.gv)

#define CxLABEL(c)	(0 + CopLABEL((c)->blk_oldcop))
#define CxLABEL_len(c,len)	(0 + CopLABEL_len((c)->blk_oldcop, len))
#define CxLABEL_len_flags(c,len,flags)	(0 + CopLABEL_len_flags((c)->blk_oldcop, len, flags))
#define CxHASARGS(c)	(((c)->cx_type & CXp_HASARGS) == CXp_HASARGS)

/* CxLVAL(): the lval flags of the call site: the relevant flag bits from
 * the op_private field of the calling pp_entersub (or its caller's caller
 * if the caller's lvalue context isn't known):
 *  OPpLVAL_INTRO:  sub used in lvalue context, e.g. f() = 1;
 *  OPpENTERSUB_INARGS (in conjunction with OPpLVAL_INTRO): the
 *      function is being used as a sub arg or as a referent, e.g.
 *      g(...,f(),...)  or $r = \f()
 *  OPpDEREF: 2-bit mask indicating e.g. f()->[0].
 *  Note the contrast with CvLVALUE(), which is a property of the sub
 *  rather than the call site.
 */
#define CxLVAL(c)	(0 + ((c)->blk_u16 & 0xff))



/* given/when context */
struct block_givwhen {
	OP *leave_op;
        SV *defsv_save; /* the original $_ */
};



/* context common to subroutines, evals and loops */
struct block {
    U8		blku_type;	/* what kind of context this is */
    U8		blku_gimme;	/* is this block running in list context? */
    U16		blku_u16;	/* used by block_sub and block_eval (so far) */
    I32		blku_oldsaveix; /* saved PL_savestack_ix */
    /* all the fields above must be aligned with same-sized fields as sbu */
    I32		blku_oldsp;	/* current sp floor: where nextstate pops to */
    I32		blku_oldmarksp;	/* mark stack index */
    COP *	blku_oldcop;	/* old curcop pointer */
    PMOP *	blku_oldpm;	/* values of pattern match vars */
    SSize_t     blku_old_tmpsfloor;     /* saved PL_tmps_floor */
    I32		blku_oldscopesp;	/* scope stack index */

    union {
	struct block_sub	blku_sub;
	struct block_format	blku_format;
	struct block_eval	blku_eval;
	struct block_loop	blku_loop;
	struct block_givwhen	blku_givwhen;
    } blk_u;
};
#define blk_oldsp	cx_u.cx_blk.blku_oldsp
#define blk_oldcop	cx_u.cx_blk.blku_oldcop
#define blk_oldmarksp	cx_u.cx_blk.blku_oldmarksp
#define blk_oldscopesp	cx_u.cx_blk.blku_oldscopesp
#define blk_oldpm	cx_u.cx_blk.blku_oldpm
#define blk_gimme	cx_u.cx_blk.blku_gimme
#define blk_u16		cx_u.cx_blk.blku_u16
#define blk_oldsaveix   cx_u.cx_blk.blku_oldsaveix
#define blk_old_tmpsfloor cx_u.cx_blk.blku_old_tmpsfloor
#define blk_sub		cx_u.cx_blk.blk_u.blku_sub
#define blk_format	cx_u.cx_blk.blk_u.blku_format
#define blk_eval	cx_u.cx_blk.blk_u.blku_eval
#define blk_loop	cx_u.cx_blk.blk_u.blku_loop
#define blk_givwhen	cx_u.cx_blk.blk_u.blku_givwhen

#define CX_DEBUG(cx, action)						\
    DEBUG_l(								\
	Perl_deb(aTHX_ "CX %ld %s %s (scope %ld,%ld) (save %ld,%ld) at %s:%d\n",\
		    (long)cxstack_ix,					\
		    action,						\
		    PL_block_type[CxTYPE(cx)],	                        \
		    (long)PL_scopestack_ix,				\
		    (long)(cx->blk_oldscopesp),		                \
		    (long)PL_savestack_ix,				\
		    (long)(cx->blk_oldsaveix),                          \
		    __FILE__, __LINE__));



/* substitution context */
struct subst {
    U8		sbu_type;	/* same as blku_type */
    U8		sbu_rflags;
    U16		sbu_rxtainted;
    I32		sbu_oldsaveix; /* same as blku_oldsaveix */
    /* all the fields above must be aligned with same-sized fields as blk_u */
    SSize_t	sbu_iters;
    SSize_t	sbu_maxiters;
    char *	sbu_orig;
    SV *	sbu_dstr;
    SV *	sbu_targ;
    char *	sbu_s;
    char *	sbu_m;
    char *	sbu_strend;
    void *	sbu_rxres;
    REGEXP *	sbu_rx;
};
#define sb_iters	cx_u.cx_subst.sbu_iters
#define sb_maxiters	cx_u.cx_subst.sbu_maxiters
#define sb_rflags	cx_u.cx_subst.sbu_rflags
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
#define sb_orig		cx_u.cx_subst.sbu_orig
#define sb_dstr		cx_u.cx_subst.sbu_dstr
#define sb_targ		cx_u.cx_subst.sbu_targ
#define sb_s		cx_u.cx_subst.sbu_s
#define sb_m		cx_u.cx_subst.sbu_m
#define sb_strend	cx_u.cx_subst.sbu_strend
#define sb_rxres	cx_u.cx_subst.sbu_rxres
#define sb_rx		cx_u.cx_subst.sbu_rx

#ifdef PERL_CORE
#  define CX_PUSHSUBST(cx) CXINC, cx = CX_CUR(),		        \
	cx->blk_oldsaveix = oldsave,				        \
	cx->sb_iters		= iters,				\
	cx->sb_maxiters		= maxiters,				\
	cx->sb_rflags		= r_flags,				\
	cx->sb_rxtainted	= rxtainted,				\
	cx->sb_orig		= orig,					\
	cx->sb_dstr		= dstr,					\
	cx->sb_targ		= targ,					\
	cx->sb_s		= s,					\
	cx->sb_m		= m,					\
	cx->sb_strend		= strend,				\
	cx->sb_rxres		= NULL,					\
	cx->sb_rx		= rx,					\
	cx->cx_type		= CXt_SUBST | (once ? CXp_ONCE : 0);	\
	rxres_save(&cx->sb_rxres, rx);					\
	(void)ReREFCNT_inc(rx);						\
        SvREFCNT_inc_void_NN(targ)

#  define CX_POPSUBST(cx) \
    STMT_START {							\
        REGEXP *re;                                                     \
        assert(CxTYPE(cx) == CXt_SUBST);                                \
	rxres_free(&cx->sb_rxres);					\
	re = cx->sb_rx;                                                 \
	cx->sb_rx = NULL;                                               \
	ReREFCNT_dec(re);                                               \
        SvREFCNT_dec_NN(cx->sb_targ);                                   \
    } STMT_END
#endif

#define CxONCE(cx)		((cx)->cx_type & CXp_ONCE)

struct context {
    union {
	struct block	cx_blk;
	struct subst	cx_subst;
    } cx_u;
};
#define cx_type cx_u.cx_subst.sbu_type

/* If you re-order these, there is also an array of uppercase names in perl.h
   and a static array of context names in pp_ctl.c  */
#define CXTYPEMASK	0xf
#define CXt_NULL	0 /* currently only used for sort BLOCK */
#define CXt_WHEN	1
#define CXt_BLOCK	2
/* When micro-optimising :-) keep GIVEN next to the LOOPs, as these 5 share a
   jump table in pp_ctl.c
   The first 4 don't have a 'case' in at least one switch statement in pp_ctl.c
*/
#define CXt_GIVEN	3

/* be careful of the ordering of these five. Macros like CxTYPE_is_LOOP,
 * CxFOREACH compare ranges */
#define CXt_LOOP_ARY	4 /* for (@@ary)     { ...; } */
#define CXt_LOOP_LAZYSV	5 /* for ('a'..'z') { ...; } */
#define CXt_LOOP_LAZYIV	6 /* for (1..9)     { ...; } */
#define CXt_LOOP_LIST	7 /* for (1,2,3)    { ...; } */
#define CXt_LOOP_PLAIN	8 /* while (...)    { ...; }
                             or plain block { ...; } */
#define CXt_SUB		9
#define CXt_FORMAT     10
#define CXt_EVAL       11
#define CXt_SUBST      12
/* SUBST doesn't feature in all switch statements.  */

/* private flags for CXt_SUB and CXt_FORMAT */
#define CXp_MULTICALL	0x10	/* part of a multicall (so don't tear down
                                   context on exit). (not CXt_FORMAT) */
#define CXp_HASARGS	0x20
#define CXp_SUB_RE	0x40    /* code called within regex, i.e. (?{}) */
#define CXp_SUB_RE_FAKE	0x80    /* fake sub CX for (?{}) in current scope */

/* private flags for CXt_EVAL */
#define CXp_REAL	0x20	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x40	/* eval{}, not eval'' or similar */

/* private flags for CXt_LOOP */

/* this is only set in conjunction with CXp_FOR_GV */
#define CXp_FOR_DEF	0x10	/* foreach using $_ */
/* these 3 are mutually exclusive */
#define CXp_FOR_LVREF	0x20	/* foreach using \$var */
#define CXp_FOR_GV	0x40	/* foreach using package var */
#define CXp_FOR_PAD	0x80	/* foreach using lexical var */

#define CxPADLOOP(c)	((c)->cx_type & CXp_FOR_PAD)

/* private flags for CXt_SUBST */
#define CXp_ONCE	0x10	/* What was sbu_once in struct subst */

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxTYPE_is_LOOP(c) (   CxTYPE(cx) >= CXt_LOOP_ARY                \
                           && CxTYPE(cx) <= CXt_LOOP_PLAIN)
#define CxMULTICALL(c)	((c)->cx_type & CXp_MULTICALL)
#define CxREALEVAL(c)	(((c)->cx_type & (CXTYPEMASK|CXp_REAL))		\
			 == (CXt_EVAL|CXp_REAL))
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXTYPEMASK|CXp_TRYBLOCK))	\
			 == (CXt_EVAL|CXp_TRYBLOCK))
#define CxFOREACH(c)	(   CxTYPE(cx) >= CXt_LOOP_ARY                  \
                         && CxTYPE(cx) <= CXt_LOOP_LIST)

#define CXINC (cxstack_ix < cxstack_max ? ++cxstack_ix : (cxstack_ix = cxinc()))

/* 
=head1 "Gimme" Values
*/

/*
=for apidoc AmU||G_SCALAR
Used to indicate scalar context.  See C<L</GIMME_V>>, C<L</GIMME>>, and
L<perlcall>.

=for apidoc AmU||G_ARRAY
Used to indicate list context.  See C<L</GIMME_V>>, C<L</GIMME>> and
L<perlcall>.

=for apidoc AmU||G_VOID
Used to indicate void context.  See C<L</GIMME_V>> and L<perlcall>.

=for apidoc AmU||G_DISCARD
Indicates that arguments returned from a callback should be discarded.  See
L<perlcall>.

=for apidoc AmU||G_EVAL

Used to force a Perl C<eval> wrapper around a callback.  See
L<perlcall>.

=for apidoc AmU||G_NOARGS

Indicates that no arguments are being sent to a callback.  See
L<perlcall>.

=cut
*/

#define G_SCALAR	2
#define G_ARRAY		3
#define G_VOID		1
#define G_WANT		3

/* extra flags for Perl_call_* routines */
#define G_DISCARD	4	/* Call FREETMPS.
				   Don't change this without consulting the
				   hash actions codes defined in hv.h */
#define G_EVAL		8	/* Assume eval {} around subroutine call. */
#define G_NOARGS       16	/* Don't construct a @@_ array. */
#define G_KEEPERR      32	/* Warn for errors, don't overwrite $@@ */
#define G_NODEBUG      64	/* Disable debugging at toplevel.  */
#define G_METHOD      128       /* Calling method. */
#define G_FAKINGEVAL  256	/* Faking an eval context for call_sv or
				   fold_constants. */
#define G_UNDEF_FILL  512	/* Fill the stack with &PL_sv_undef
				   A special case for UNSHIFT in
				   Perl_magic_methcall().  */
#define G_WRITING_TO_STDERR 1024 /* Perl_write_to_stderr() is calling
				    Perl_magic_methcall().  */
#define G_RE_REPARSING 0x800     /* compiling a run-time /(?{..})/ */
#define G_METHOD_NAMED 4096	/* calling named method, eg without :: or ' */

/* flag bits for PL_in_eval */
#define EVAL_NULL	0	/* not in an eval */
#define EVAL_INEVAL	1	/* some enclosing scope is an eval */
#define EVAL_WARNONLY	2	/* used by yywarn() when calling yyerror() */
#define EVAL_KEEPERR	4	/* set by Perl_call_sv if G_KEEPERR */
#define EVAL_INREQUIRE	8	/* The code is being required. */
#define EVAL_RE_REPARSING 0x10	/* eval_sv() called with G_RE_REPARSING */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9
#define PERLSI_MULTICALL       10

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    I32			si_markoff;	/* offset where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARK_OFFSET \
    PL_curstackinfo->si_markoff = PL_markstack_ptr - PL_markstack
#else
#  define	SET_MARK_OFFSET NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	DEBUG_l({							\
	    int i = 0; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "push STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARK_OFFSET;						\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

/* POPSTACK works with PL_stack_sp, so it may need to be bracketed by
 * PUTBACK/SPAGAIN to flush/refresh any local SP that may be active */
#define POPSTACK \
    STMT_START {							\
	dSP;								\
	PERL_SI * const prev = PL_curstackinfo->si_prev;		\
	DEBUG_l({							\
	    int i = -1; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "pop  STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
	if (!prev) {							\
	    Perl_croak_popstack();					\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END

#define IN_PERL_COMPILETIME	cBOOL(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		cBOOL(PL_curcop != &PL_compiling)




/*
=head1 Multicall Functions

=for apidoc Ams||dMULTICALL
Declare local variables for a multicall.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||PUSH_MULTICALL
Opening bracket for a lightweight callback.
See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||MULTICALL
Make a lightweight callback.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=for apidoc Ams||POP_MULTICALL
Closing bracket for a lightweight callback.
See L<perlcall/LIGHTWEIGHT CALLBACKS>.

=cut
*/

#define dMULTICALL \
    OP  *multicall_cop;							\
    bool multicall_oldcatch

#define PUSH_MULTICALL(the_cv) \
    PUSH_MULTICALL_FLAGS(the_cv, 0)

/* Like PUSH_MULTICALL, but allows you to specify extra flags
 * for the CX stack entry (this isn't part of the public API) */

#define PUSH_MULTICALL_FLAGS(the_cv, flags) \
    STMT_START {							\
        PERL_CONTEXT *cx;						\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	PADLIST * const padlist = CvPADLIST(cv);			\
 	multicall_oldcatch = CATCH_GET;					\
	CATCH_SET(TRUE);						\
	PUSHSTACKi(PERLSI_MULTICALL);					\
	cx = cx_pushblock((CXt_SUB|CXp_MULTICALL|flags), (U8)gimme,     \
                  PL_stack_sp, PL_savestack_ix);	                \
        cx_pushsub(cx, cv, NULL, 0);                                    \
	SAVEOP();					                \
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2)  						\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cop = CvSTART(cv);					\
    } STMT_END

#define MULTICALL \
    STMT_START {							\
	PL_op = multicall_cop;						\
	CALLRUNOPS(aTHX);						\
    } STMT_END

#define POP_MULTICALL \
    STMT_START {							\
        PERL_CONTEXT *cx;						\
	cx = CX_CUR();					                \
	CX_LEAVE_SCOPE(cx);                                             \
        cx_popsub_common(cx);                                           \
        gimme = cx->blk_gimme;                                          \
        PERL_UNUSED_VAR(gimme); /* for API */                           \
	cx_popblock(cx);				   		\
	CX_POP(cx);                                                     \
	POPSTACK;							\
	CATCH_SET(multicall_oldcatch);					\
	SPAGAIN;							\
    } STMT_END

/* Change the CV of an already-pushed MULTICALL CxSUB block.
 * (this isn't part of the public API) */

#define CHANGE_MULTICALL_FLAGS(the_cv, flags) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	PADLIST * const padlist = CvPADLIST(cv);			\
        PERL_CONTEXT *cx = CX_CUR();					\
	assert(CxMULTICALL(cx));                                        \
        cx_popsub_common(cx);                                           \
	cx->cx_type = (CXt_SUB|CXp_MULTICALL|flags);                    \
        cx_pushsub(cx, cv, NULL, 0);			                \
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2)  						\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cop = CvSTART(cv);					\
    } STMT_END
/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.17
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d10 1
a10 1
 * that (loosely speaking) are separate statements.
d37 1
d59 1
d108 1
d120 1
d161 2
a162 2
Look up the entry in the cop hints hash I<cophh> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
d164 1
a164 1
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
d178 2
a179 2
Like L</cophh_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.
d215 1
a215 1
key/value pairs in the cop hints hash I<cophh>.  I<flags> is currently
d227 1
a227 1
Make and return a complete copy of the cop hints hash I<cophh>.
d237 1
a237 1
Discard the cop hints hash I<cophh>, freeing all resources associated
d258 1
a258 1
Stores a value, associated with a key, in the cop hints hash I<cophh>,
d264 1
a264 1
The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
d266 1
a266 1
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
d269 1
a269 1
I<value> is the scalar value to store for this key.  I<value> is copied
d284 2
a285 2
Like L</cophh_store_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.
d320 1
a320 1
Delete a key and its associated value from the cop hints hash I<cophh>,
d326 1
a326 1
The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
d328 1
a328 1
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
d341 2
a342 2
Like L</cophh_delete_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.
d464 2
a465 2
Look up the hint entry in the cop I<cop> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
d467 1
a467 1
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
d481 2
a482 2
Like L</cop_hints_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.
d518 1
a518 1
hint entries in the cop I<cop>.  I<flags> is currently unused and must
d554 1
a556 2
    AV *	savearray;
    AV *	argarray;
d558 1
a558 1
    PAD		*oldcomppad;
d566 1
d573 21
d595 2
a596 2
 * Note that the refcnt of the cv is incremented twice;  The CX one is
 * decremented by LEAVESUB, the other by LEAVE. */
a597 17
#define PUSHSUB_BASE(cx)						\
	ENTRY_PROBE(CvNAMED(cv)						\
			? HEK_KEY(CvNAME_HEK(cv))			\
			: GvENAME(CvGV(cv)),	       			\
		CopFILE((const COP *)CvSTART(cv)),			\
		CopLINE((const COP *)CvSTART(cv)),			\
		CopSTASHPV((const COP *)CvSTART(cv)));			\
									\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
	cx->cx_type |= (hasargs) ? CXp_HASARGS : 0;			\
	cx->blk_sub.retop = NULL;					\
	if (!CvDEPTH(cv)) {						\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SAVEFREESV(cv);						\
	}
d599 1
a599 1
#define PUSHSUB_GET_LVALUE_MASK(func) \
d609 2
a610 25
#define PUSHSUB(cx)							\
    {									\
	U8 phlags = PUSHSUB_GET_LVALUE_MASK(Perl_was_lvalue_sub);	\
	PUSHSUB_BASE(cx)						\
	cx->blk_u16 = PL_op->op_private &				\
	                  (phlags|OPpDEREF);				\
    }

/* variant for use by OP_DBSTATE, where op_private holds hint bits */
#define PUSHSUB_DB(cx)							\
	PUSHSUB_BASE(cx)						\
	cx->blk_u16 = 0;


#define PUSHFORMAT(cx, retop)						\
	cx->blk_format.cv = cv;						\
	cx->blk_format.gv = gv;						\
	cx->blk_format.retop = (retop);					\
	cx->blk_format.dfoutgv = PL_defoutgv;				\
	cx->blk_u16 = 0;                                                \
	if (!CvDEPTH(cv)) SvREFCNT_inc_simple_void_NN(cv);		\
	CvDEPTH(cv)++;							\
	SvREFCNT_inc_void(cx->blk_format.dfoutgv)

#define POP_SAVEARRAY()						\
d612 1
a612 1
	SvREFCNT_dec(GvAV(PL_defgv));					\
d614 2
a626 52
#define POPSUB(cx,sv)							\
    STMT_START {							\
	const I32 olddepth = cx->blk_sub.olddepth;			\
        if (!(cx->blk_u16 & CxPOPSUB_DONE)) {                           \
        cx->blk_u16 |= CxPOPSUB_DONE;                                   \
	RETURN_PROBE(CvNAMED(cx->blk_sub.cv)				\
			? HEK_KEY(CvNAME_HEK(cx->blk_sub.cv))		\
			: GvENAME(CvGV(cx->blk_sub.cv)),		\
		CopFILE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopLINE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopSTASHPV((COP*)CvSTART((const CV*)cx->blk_sub.cv)));	\
									\
	if (CxHASARGS(cx)) {						\
	    POP_SAVEARRAY();						\
	    /* abandon @@_ if it got reified */				\
	    if (AvREAL(cx->blk_sub.argarray)) {				\
		const SSize_t fill = AvFILLp(cx->blk_sub.argarray);	\
		SvREFCNT_dec_NN(cx->blk_sub.argarray);			\
		cx->blk_sub.argarray = newAV();				\
		av_extend(cx->blk_sub.argarray, fill);			\
		AvREIFY_only(cx->blk_sub.argarray);			\
		CX_CURPAD_SV(cx->blk_sub, 0) = MUTABLE_SV(cx->blk_sub.argarray); \
	    }								\
	    else {							\
		CLEAR_ARGARRAY(cx->blk_sub.argarray);			\
	    }								\
	}								\
        }                                                               \
	sv = MUTABLE_SV(cx->blk_sub.cv);				\
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (sv && (CvDEPTH((const CV*)sv) = olddepth))			\
	    sv = NULL;						\
    } STMT_END

#define LEAVESUB(sv)							\
    STMT_START {							\
	SvREFCNT_dec(sv);						\
    } STMT_END

#define POPFORMAT(cx)							\
    STMT_START {							\
        if (!(cx->blk_u16 & CxPOPSUB_DONE)) {                           \
	CV * const cv = cx->blk_format.cv;				\
	GV * const dfuot = cx->blk_format.dfoutgv;			\
        cx->blk_u16 |= CxPOPSUB_DONE;                                   \
	setdefout(dfuot);						\
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (!--CvDEPTH(cv))						\
	    SvREFCNT_dec_NN(cx->blk_format.cv);				\
	SvREFCNT_dec_NN(dfuot);						\
        }                                                               \
    } STMT_END
a645 24
#define PUSHEVAL(cx,n)							\
    STMT_START {							\
	assert(!(PL_in_eval & ~0x7F));					\
	assert(!(PL_op->op_type & ~0x1FF));				\
	cx->blk_u16 = (PL_in_eval & 0x7F) | ((U16)PL_op->op_type << 7);	\
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : NULL);		\
	cx->blk_eval.old_eval_root = PL_eval_root;			\
	cx->blk_eval.cur_text = PL_parser ? PL_parser->linestr : NULL;	\
	cx->blk_eval.cv = NULL; /* set by doeval(), as applicable */	\
	cx->blk_eval.retop = NULL;					\
	cx->blk_eval.cur_top_env = PL_top_env; 				\
    } STMT_END

#define POPEVAL(cx)							\
    STMT_START {							\
	PL_in_eval = CxOLD_IN_EVAL(cx);					\
	optype = CxOLD_OP_TYPE(cx);					\
	PL_eval_root = cx->blk_eval.old_eval_root;			\
	if (cx->blk_eval.cur_text && SvSCREAM(cx->blk_eval.cur_text))	\
	    SvREFCNT_dec_NN(cx->blk_eval.cur_text);			\
	if (cx->blk_eval.old_namesv)					\
	    sv_2mortal(cx->blk_eval.old_namesv);			\
    } STMT_END

a647 1
    I32		resetsp;
d650 2
a651 3
	SV      **svp;
	GV      *gv;
	PAD     *oldcomppad; /* only used in ITHREADS */
d653 1
d655 3
a657 3
	struct { /* valid if type is LOOP_FOR or LOOP_PLAIN (but {NULL,0})*/
	    AV * ary; /* use the stack if this is NULL */
	    IV ix;
d659 5
a663 1
	struct { /* valid if type is LOOP_LAZYIV */
d667 1
a667 1
	struct { /* valid if type if LOOP_LAZYSV */
a671 2
};

d673 1
a673 4
#  define CxITERVAR_PADSV(c) \
	&CX_CURPAD_SV( (c)->blk_loop.itervar_u, (c)->blk_loop.my_op->op_targ)
#else
#  define CxITERVAR_PADSV(c) ((c)->blk_loop.itervar_u.svp)
d675 1
d677 6
a682 6
#define CxITERVAR(c)							\
	((c)->blk_loop.itervar_u.oldcomppad				\
	 ? (CxPADLOOP(c) 						\
	    ? CxITERVAR_PADSV(c)					\
	    : &GvSV((c)->blk_loop.itervar_u.gv))			\
	 : (SV**)NULL)
d688 12
a700 2
/* POPSUB has already been performed on this context frame */
#define CxPOPSUB_DONE 0x100
a702 21
#define PUSHLOOP_PLAIN(cx, s)						\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	cx->blk_loop.itervar_u.svp = NULL;

#define PUSHLOOP_FOR(cx, ivar, s)					\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	cx->blk_loop.itervar_u.svp = (SV**)(ivar);

#define POPLOOP(cx)							\
	if (CxTYPE(cx) == CXt_LOOP_LAZYSV) {				\
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.cur);		\
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.end);		\
	}								\
	if (CxTYPE(cx) == CXt_LOOP_FOR)					\
	    SvREFCNT_dec(cx->blk_loop.state_u.ary.ary);
d707 1
a709 2
#define PUSHGIVEN(cx)							\
	cx->blk_givwhen.leave_op = cLOGOP->op_other;
a710 1
#define PUSHWHEN PUSHGIVEN
d717 4
a720 1
    I32		blku_oldsp;	/* stack pointer to copy stuff down to */
d722 2
a723 1
    I32		blku_oldmarksp;	/* mark stack index */
a724 1
    PMOP *	blku_oldpm;	/* values of pattern match vars */
d741 2
d749 1
a749 1
#define DEBUG_CX(action)						\
d751 1
a751 1
	Perl_deb(aTHX_ "CX %ld %s %s (scope %ld,%ld) at %s:%d\n",	\
d754 1
a754 1
		    PL_block_type[CxTYPE(&cxstack[cxstack_ix])],	\
d756 3
a758 1
		    (long)(cxstack[cxstack_ix].blk_oldscopesp),		\
d761 1
a761 30
/* Enter a block. */
#define PUSHBLOCK(cx,t,sp) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->cx_type		= t,					\
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
	cx->blk_gimme		= (U8)gimme;				\
	DEBUG_CX("PUSH");

/* Exit a block (RETURN and LAST). */
#define POPBLOCK(cx,pm)							\
	DEBUG_CX("POP");						\
	cx = &cxstack[cxstack_ix--],					\
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;

/* Continue a block elsewhere (NEXT and REDO). */
#define TOPBLOCK(cx)							\
	DEBUG_CX("TOP");						\
	cx  = &cxstack[cxstack_ix],					\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_curpm         = cx->blk_oldpm;
d765 1
a765 1
    U8		sbu_type;	/* what kind of context this is */
d767 5
a771 4
    U16		sbu_rxtainted;	/* matches struct block */
    I32		sbu_iters;
    I32		sbu_maxiters;
    I32		sbu_oldsave;
a783 1
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
d795 2
a796 1
#  define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],		\
a799 1
	cx->sb_oldsave		= oldsave,				\
d811 2
a812 1
	(void)ReREFCNT_inc(rx)
d814 4
a817 1
#  define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
d819 5
a823 1
	ReREFCNT_dec(cx->sb_rx)
d839 1
a839 1
#define CXt_NULL	0
d847 13
a859 9
/* This is first so that CXt_LOOP_FOR|CXt_LOOP_LAZYIV is CXt_LOOP_LAZYIV */
#define CXt_LOOP_FOR	4
#define CXt_LOOP_PLAIN	5
#define CXt_LOOP_LAZYSV	6
#define CXt_LOOP_LAZYIV	7
#define CXt_SUB		8
#define CXt_FORMAT      9
#define CXt_EVAL       10
#define CXt_SUBST      11
a861 7
/* private flags for CXt_SUB and CXt_NULL
   However, this is checked in many places which do not check the type, so
   this bit needs to be kept clear for most everything else. For reasons I
   haven't investigated, it can coexist with CXp_FOR_DEF */
#define CXp_MULTICALL	0x10	/* part of a multicall (so don't
				   tear down context on exit). */ 

d863 2
d874 2
d877 6
a882 1
#define CxPADLOOP(c)	((c)->blk_loop.my_op->op_targ)
d888 3
a890 3
#define CxTYPE_is_LOOP(c)	(((c)->cx_type & 0xC) == 0x4)
#define CxMULTICALL(c)	(((c)->cx_type & CXp_MULTICALL)			\
			 == CXp_MULTICALL)
d895 2
a896 3
#define CxFOREACH(c)	(CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN)
#define CxFOREACHDEF(c)	((CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN) \
			 && ((c)->cx_type & CXp_FOR_DEF))
d906 1
a906 1
Used to indicate scalar context.  See C<GIMME_V>, C<GIMME>, and
d910 1
a910 1
Used to indicate list context.  See C<GIMME_V>, C<GIMME> and
d914 1
a914 1
Used to indicate void context.  See C<GIMME_V> and L<perlcall>.
d980 1
d1058 5
a1062 2
#define IN_PERL_COMPILETIME	(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		(PL_curcop != &PL_compiling)
d1085 2
a1086 6
    SV **newsp;			/* set by POPBLOCK */			\
    PERL_CONTEXT *cx;							\
    CV *multicall_cv;							\
    OP *multicall_cop;							\
    bool multicall_oldcatch; 						\
    U8 hasargs = 0		/* used by PUSHSUB */
d1096 1
a1099 1
	ENTER;								\
a1100 1
	SAVETMPS; SAVEVPTR(PL_op);					\
d1102 5
a1106 3
	PUSHSTACKi(PERLSI_SORT);					\
	PUSHBLOCK(cx, (CXt_SUB|CXp_MULTICALL|flags), PL_stack_sp);	\
	PUSHSUB(cx);							\
d1109 1
a1109 2
	if (CvDEPTH(cv) >= 2) {						\
	    PERL_STACK_OVERFLOW_CHECK();				\
a1110 2
	}								\
	SAVECOMPPAD();							\
a1111 1
	multicall_cv = cv;						\
d1123 8
a1130 5
	cx = &cxstack[cxstack_ix];					\
        if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
	POPBLOCK(cx,PL_curpm);						\
a1132 1
	LEAVE;								\
d1144 3
a1146 5
	cx = &cxstack[cxstack_ix];					\
	assert(cx->cx_type & CXp_MULTICALL);				\
	if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
d1148 1
a1148 1
	PUSHSUB(cx);							\
d1151 1
a1151 2
	if (CvDEPTH(cv) >= 2) {						\
	    PERL_STACK_OVERFLOW_CHECK();				\
a1152 2
	}								\
	SAVECOMPPAD();							\
a1153 1
	multicall_cv = cv;						\
a1156 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d620 1
d643 2
d667 1
d681 1
d684 1
d690 1
d778 4
a781 1
#define CxLVAL(c)	(0 + (c)->blk_u16)
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d34 1
a34 1
    Sigjmp_buf		je_buf;		/* only for use if !je_throw */
a40 8
#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif

d53 3
a55 1
	Zero(&PL_start_env, 1, JMPENV);		\
a57 1
	PL_top_env = &PL_start_env;		\
a102 1
	OP_REG_TO_MEM;							\
a103 1
	OP_MEM_TO_REG;							\
a126 1
	OP_REG_TO_MEM;						\
d403 1
a403 1
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepv((pv),(l)))
d437 2
a438 2
#  define CopFILE(c)		(CopFILEGV(c) && GvSV(CopFILEGV(c)) \
				    ? SvPVX(GvSV(CopFILEGV(c))) : NULL)
d641 1
d665 2
a666 1
	if (sv && (CvDEPTH((const CV*)sv) = cx->blk_sub.olddepth))	\
d676 6
a681 3
	setdefout(cx->blk_format.dfoutgv);				\
	CvDEPTH(cx->blk_format.cv)--;					\
	if (!CvDEPTH(cx->blk_format.cv))				\
d683 2
a684 1
	SvREFCNT_dec_NN(cx->blk_format.dfoutgv);
d1057 1
d1166 1
a1166 1
Declare local variables for a multicall. See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d1173 1
a1173 1
Make a lightweight callback. See L<perlcall/LIGHTWEIGHT CALLBACKS>.
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d390 2
a391 1
    char *	cop_stashpv;	/* package line was compiled in */
a392 1
    I32         cop_stashlen;	/* negative for UTF8 */
d423 1
a423 2
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILE(c)), \
a424 4
#  else
#    define CopFILEAVx(c)	(GvAV(gv_fetchfile(CopFILE(c))))
#  endif
#  define CopSTASHPV(c)		((c)->cop_stashpv)
d426 4
a430 29
#    define CopSTASHPV_set(c,pv,n)	((c)->cop_stashpv = \
					   ((pv) ? savepvn(pv,n) : NULL))
#  else
#    define CopSTASHPV_set(c,pv,n)	((c)->cop_stashpv = (pv) \
					    ? savesharedpvn(pv,n) : NULL)
#  endif

#  define CopSTASH_len_set(c,n)	((c)->cop_stashlen = (n))
#  define CopSTASH_len(c)	((c)->cop_stashlen)

#  define CopSTASH(c)          (CopSTASHPV(c)                                 \
                                ? gv_stashpvn(CopSTASHPV(c),		  \
				    CopSTASH_len(c) < 0			  \
					? -CopSTASH_len(c)		  \
					:  CopSTASH_len(c),		  \
                                    GV_ADD|SVf_UTF8*(CopSTASH_len(c) < 0) \
                                  )					  \
                                 : NULL)
#  define CopSTASH_set(c,hv)   (CopSTASHPV_set(c,			\
				    (hv) ? HvNAME_get(hv) : NULL,	\
				    (hv) ? HvNAMELEN(hv)  : 0),		\
				CopSTASH_len_set(c,			\
				    (hv) ? HvNAMEUTF8(hv)		\
					    ? -HvNAMELEN(hv)		\
					    :  HvNAMELEN(hv)		\
					 : 0))
#  define CopSTASH_eq(c,hv)	((hv) && stashpv_hvname_match(c,hv))
#  ifdef NETWARE
#    define CopSTASH_free(c) SAVECOPSTASH_FREE(c)
a432 1
#    define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))
a450 5
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#  define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))
#  define CopSTASH_free(c)	
d455 5
a546 1
/* FIXME NATIVE_HINTS if this is changed from op_private (see perl.h)  */
d584 3
a586 1
	ENTRY_PROBE(GvENAME(CvGV(cv)),		       			\
d601 1
a601 3

#define PUSHSUB(cx)							\
    {									\
d604 1
a604 1
	U8 phlags =							\
d608 6
a613 1
	           ? 0 : Perl_was_lvalue_sub(aTHX);			\
d630 2
d651 3
a653 1
	RETURN_PROBE(GvENAME(CvGV((const CV*)cx->blk_sub.cv)),		\
d663 1
a663 1
		SvREFCNT_dec(cx->blk_sub.argarray);			\
d680 1
a680 2
	if (sv)								\
	    SvREFCNT_dec(sv);						\
d685 4
a688 1
	SvREFCNT_dec(cx->blk_format.dfoutgv);
d726 2
d793 2
a794 2
	    SvREFCNT_dec(cx->blk_loop.state_u.lazysv.cur);		\
	    SvREFCNT_dec(cx->blk_loop.state_u.lazysv.end);		\
d978 2
d1060 1
d1068 1
d1147 1
a1147 2
	    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");		\
	    my_exit(1);							\
d1194 6
d1203 1
a1203 1
	AV * const padlist = CvPADLIST(cv);				\
d1209 1
a1209 1
	PUSHBLOCK(cx, CXt_SUB|CXp_MULTICALL, PL_stack_sp);		\
d1211 3
a1213 1
	if (++CvDEPTH(cv) >= 2) {					\
d1231 4
a1234 2
	if (! --CvDEPTH(multicall_cv))					\
	    LEAVESUB(multicall_cv);					\
d1242 26
d1272 1
a1272 1
 * indent-tabs-mode: t
d1275 1
a1275 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d17 3
a19 2
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
d21 2
a22 2
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
d95 3
a97 2
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=3386
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=5162
d104 5
a108 3
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p at %s:%d\n",	\
		         (void*)&cur_env, (void*)PL_top_env,			\
		         __FILE__, __LINE__));					\
d120 5
a124 3
	DEBUG_l(Perl_deb(aTHX_ "popping jumplevel was %p, now %p at %s:%d\n",	\
		         (void*)PL_top_env, (void*)cur_env.je_prev,		\
		         __FILE__, __LINE__));					\
d131 5
d141 1
a141 1
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
d146 173
a318 1
#define CATCH_SET(v)		(PL_top_env->je_mustcatch = (v))
d320 60
d392 1
d403 1
a403 1
    struct refcounted_he * cop_hints_hash;
d432 2
a433 1
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : NULL))
d435 2
a436 1
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savesharedpv(pv))
d439 19
a457 3
#  define CopSTASH(c)		(CopSTASHPV(c) \
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : NULL)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME_get(hv) : NULL)
d490 77
a566 1
#define CopLABEL(c)  Perl_fetch_cop_label(aTHX_ (c)->cop_hints_hash, NULL, NULL)
a577 26
/* If $[ is non-zero, it's stored in cop_hints under the key "$[", and
   HINT_ARYBASE is set to indicate this.
   Setting it is ineficient due to the need to create 2 mortal SVs, but as
   using $[ is highly discouraged, no sane Perl code will be using it.  */
#define CopARYBASE_get(c)	\
	((CopHINTS_get(c) & HINT_ARYBASE)				\
	 ? SvIV(Perl_refcounted_he_fetch(aTHX_ (c)->cop_hints_hash, 0,	\
					 "$[", 2, 0, 0))		\
	 : 0)
#define CopARYBASE_set(c, b) STMT_START { \
	if (b || ((c)->cop_hints & HINT_ARYBASE)) {			\
	    (c)->cop_hints |= HINT_ARYBASE;				\
	    if ((c) == &PL_compiling) {					\
		SV *val = newSViv(b);					\
		(void)hv_stores(GvHV(PL_hintgv), "$[", val);		\
		mg_set(val);						\
		PL_hints |= HINT_ARYBASE;				\
	    } else {							\
		(c)->cop_hints_hash					\
		   = Perl_refcounted_he_new(aTHX_ (c)->cop_hints_hash,	\
					newSVpvs_flags("$[", SVs_TEMP),	\
					sv_2mortal(newSViv(b)));	\
	    }								\
	}								\
    } STMT_END

d618 2
a619 1
		CopLINE((const COP *)CvSTART(cv)));			\
d633 8
d643 2
a644 1
	                      (OPpLVAL_INTRO|OPpENTERSUB_INARGS);
d678 2
a679 1
		CopLINE((COP*)CvSTART((const CV*)cx->blk_sub.cv)));	\
d755 5
a759 10
    /* (except for non_ithreads we need to modify next_op in pp_ctl.c, hence
	why next_op is conditionally defined below.)  */
#ifdef USE_ITHREADS
    PAD		*oldcomppad; /* Also used for the GV, if targoffset is 0 */
    /* This is also accesible via cx->blk_loop.my_op->op_targ */
    PADOFFSET	targoffset;
#else
    OP *	next_op;
    SV **	itervar;
#endif
d777 8
a784 2
#  define CxITERVAR(c)							\
	((c)->blk_loop.oldcomppad					\
d786 2
a787 2
	    ? &CX_CURPAD_SV( (c)->blk_loop, (c)->blk_loop.targoffset )	\
	    : &GvSV((GV*)(c)->blk_loop.oldcomppad))			\
d789 1
a789 10
#  define CX_ITERDATA_SET(cx,idata,o)					\
	if ((cx->blk_loop.targoffset = (o)))				\
	    CX_CURPAD_SAVE(cx->blk_loop);				\
	else								\
	    cx->blk_loop.oldcomppad = (idata);
#else
#  define CxITERVAR(c)		((c)->blk_loop.itervar)
#  define CX_ITERDATA_SET(cx,ivar,o)					\
	cx->blk_loop.itervar = (SV**)(ivar);
#endif
d791 2
a795 8
#ifdef USE_ITHREADS
#  define PUSHLOOP_OP_NEXT		/* No need to do anything.  */
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.my_op->op_nextop + 0)
#else
#  define PUSHLOOP_OP_NEXT		cx->blk_loop.next_op = cLOOP->op_nextop
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.next_op + 0)
#endif

a798 1
	PUSHLOOP_OP_NEXT;						\
d801 1
a801 1
	CX_ITERDATA_SET(cx, NULL, 0);
d803 1
a803 1
#define PUSHLOOP_FOR(cx, dat, s, offset)				\
a805 1
	PUSHLOOP_OP_NEXT;						\
d808 1
a808 1
	CX_ITERDATA_SET(cx, dat, offset);
d860 10
d879 1
a879 2
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, PL_block_type[CxTYPE(cx)]); )
d882 3
a884 1
#define POPBLOCK(cx,pm) cx = &cxstack[cxstack_ix--],			\
d890 1
a890 4
	gimme		 = cx->blk_gimme;				\
	DEBUG_SCOPE("POPBLOCK");					\
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,PL_block_type[CxTYPE(cx)]); )
d893 3
a895 1
#define TOPBLOCK(cx) cx  = &cxstack[cxstack_ix],			\
d899 1
a899 2
	PL_curpm         = cx->blk_oldpm;				\
	DEBUG_SCOPE("TOPBLOCK");
a921 1
#define sb_once		cx_u.cx_subst.sbu_once
d1004 1
a1004 3
#ifdef USE_ITHREADS
#  define CxPADLOOP(c)	((c)->blk_loop.targoffset)
#endif
d1067 1
a1067 1
#define G_KEEPERR      32	/* Append errors to $@@, don't overwrite it */
d1072 5
d1130 5
d1156 5
d1185 1
a1185 1
Declare local variables for a multicall. See L<perlcall/Lightweight Callbacks>.
d1189 1
a1189 1
See L<perlcall/Lightweight Callbacks>.
d1192 1
a1192 1
Make a lightweight callback. See L<perlcall/Lightweight Callbacks>.
d1196 1
a1196 1
See L<perlcall/Lightweight Callbacks>.
d1239 2
a1240 2
	LEAVESUB(multicall_cv);						\
	CvDEPTH(multicall_cv)--;					\
@


1.12
log
@Merge in perl 5.10.1
@
text
@d4 1
a4 1
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d9 2
a10 2
 * Control ops (cops) are one of the three ops OP_NEXTSTATE, OP_DBSTATE,
 * and OP_SETSTATE that (loosely speaking) are separate statements.
d102 3
a104 2
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			 (void*)&cur_env, (void*)PL_top_env));			\
d116 4
a119 2
	DEBUG_l(Perl_deb(aTHX_ "popping jumplevel was %p, now %p\n",	\
			 (void*)PL_top_env, (void*)cur_env.je_prev));			\
d145 1
a145 1
    char *	cop_label;	/* label for this construct */
a196 2
#  define CopLABEL(c)		((c)->cop_label)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
a199 2
#    define CopLABEL_free(c) SAVECOPLABEL_FREE(c)
#    define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
a202 2
#    define CopLABEL_free(c)	(PerlMemShared_free(CopLABEL(c)),(CopLABEL(c) = NULL))
#    define CopLABEL_alloc(pv)	((pv)?savesharedpv(pv):NULL)
a218 1
#  define CopLABEL(c)		((c)->cop_label)
a223 2
#  define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
a225 1
#  define CopLABEL_free(c)	(Safefree(CopLABEL(c)),(CopLABEL(c) = NULL))
d228 2
d238 1
a238 5
#ifdef MACOS_TRADITIONAL
#  define OutCopFILE(c) MacPerl_MPWFileName(CopFILE(c))
#else
#  define OutCopFILE(c) CopFILE(c)
#endif
d252 8
a259 4
	    if ((c) == &PL_compiling)					\
		PL_hints |= HINT_LOCALIZE_HH | HINT_ARYBASE;		\
	    (c)->cop_hints_hash						\
	       = Perl_refcounted_he_new(aTHX_ (c)->cop_hints_hash,	\
d262 1
d278 2
d281 1
a281 2
    GV *	gv;
    GV *	dfoutgv;
a284 2
    U8		hasargs;
    U8		lval;		/* XXX merge lval and hasargs? */
d286 5
d292 5
d310 1
a310 1
	cx->blk_sub.hasargs = hasargs;					\
d321 1
a321 1
	cx->blk_sub.lval = PL_op->op_private &                          \
d327 1
a327 1
	cx->blk_sub.lval = 0;
d330 6
a335 7
#define PUSHFORMAT(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.gv = gv;						\
	cx->blk_sub.retop = NULL;					\
	cx->blk_sub.hasargs = 0;					\
	cx->blk_sub.dfoutgv = PL_defoutgv;				\
	SvREFCNT_inc_void(cx->blk_sub.dfoutgv)
d385 2
a386 2
	setdefout(cx->blk_sub.dfoutgv);					\
	SvREFCNT_dec(cx->blk_sub.dfoutgv);
d390 2
a391 2
    U8		old_in_eval;
    U16		old_op_type;
a395 1
    OP *	retop;	/* op to execute on exit from eval */
d399 6
a404 2
#define CxOLD_IN_EVAL(cx)	(0 + (cx)->blk_eval.old_in_eval)
#define CxOLD_OP_TYPE(cx)	(0 + (cx)->blk_eval.old_op_type)
d406 1
a406 1
#define PUSHEVAL(cx,n,fgv)						\
d408 3
a410 2
	cx->blk_eval.old_in_eval = PL_in_eval;				\
	cx->blk_eval.old_op_type = PL_op->op_type;			\
a429 1
    char *	label;
d435 3
a437 2
    void *	iterdata;
    PAD		*oldcomppad;
d442 14
a455 16
    /* Eliminated in blead by change 33080, but for binary compatibility
       reasons we can't remove it from the middle of a struct in a maintenance
       release, so it gets to stay, and be set to NULL.  */
    SV *	itersave;
    /* (from inspection of source code) for a .. range of strings this is the
       current string.  */
    SV *	iterlval;
    /* (from inspection of source code) for a foreach loop this is the array
       being iterated over. For a .. range of numbers it's the current value.
       A check is often made on the SvTYPE of iterary to determine whether
       we are iterating over an array or a range. (numbers or strings)  */
    AV *	iterary;
    IV		iterix;
    /* (from inspection of source code) for a .. range of numbers this is the
       maximum value.  */
    IV		itermax;
a456 9
/* It might be possible to squeeze this structure further. As best I can tell
   itermax and iterlval are never used at the same time, so it might be possible
   to make them into a union. However, I'm not confident that there are enough
   flag bits/NULLable pointers in this structure alone to encode which is
   active. There is, however, U8 of space free in struct block, which could be
   used. Right now it may not be worth squeezing this structure further, as it's
   the largest part of struct block, and currently struct block is 64 bytes on
   an ILP32 system, which will give good cache alignment.
*/
d460 4
a463 5
	((c)->blk_loop.iterdata						\
	 ? (CxPADLOOP(cx) 						\
	    ? &CX_CURPAD_SV( (c)->blk_loop, 				\
		    INT2PTR(PADOFFSET, (c)->blk_loop.iterdata))		\
	    : &GvSV((GV*)(c)->blk_loop.iterdata))			\
d465 5
a469 4
#  define CX_ITERDATA_SET(cx,idata)					\
	CX_CURPAD_SAVE(cx->blk_loop);					\
	cx->blk_loop.itersave = NULL;					\
	cx->blk_loop.iterdata = (idata);
d472 1
a472 2
#  define CX_ITERDATA_SET(cx,ivar)					\
	cx->blk_loop.itersave = NULL;					\
d475 3
a477 3
#define CxLABEL(c)	(0 + (c)->blk_loop.label)
#define CxHASARGS(c)	(0 + (c)->blk_sub.hasargs)
#define CxLVAL(c)	(0 + (c)->blk_sub.lval)
d487 9
a495 2
#define PUSHLOOP(cx, dat, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;			\
d499 3
a501 4
	cx->blk_loop.iterlval = NULL;					\
	cx->blk_loop.iterary = NULL;					\
	cx->blk_loop.iterix = -1;					\
	CX_ITERDATA_SET(cx,dat);
d504 6
a509 3
	SvREFCNT_dec(cx->blk_loop.iterlval);				\
	if (cx->blk_loop.iterary && cx->blk_loop.iterary != PL_curstack)\
	    SvREFCNT_dec(cx->blk_loop.iterary);
d523 1
a523 1
    U16		blku_type;	/* what kind of context this is */
d525 1
a525 1
    U8		blku_spare;	/* Padding to match with struct subst */
d534 1
d546 1
d548 1
d587 3
a589 3
    U16		sbu_type;	/* what kind of context this is */
    U8		sbu_once;	/* Actually both booleans, but U8 to matches */
    U8		sbu_rxtainted;	/* struct block */
a591 1
    I32		sbu_rflags;
d617 2
a618 1
#define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],			\
a622 1
	cx->sb_once		= once,					\
d632 1
a632 1
	cx->cx_type		= CXt_SUBST;				\
d636 1
a636 3
#define CxONCE(cx)		(0 + cx->sb_once)

#define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
d639 3
d651 3
a653 1
#define CXTYPEMASK	0xff
d655 27
a681 12
#define CXt_SUB		1
#define CXt_EVAL	2
#define CXt_LOOP	3
#define CXt_SUBST	4
#define CXt_BLOCK	5
#define CXt_FORMAT	6
#define CXt_GIVEN	7
#define CXt_WHEN	8

/* private flags for CXt_SUB and CXt_NULL */
#define CXp_MULTICALL	0x00000400	/* part of a multicall (so don't
					   tear down context on exit). */ 
d684 2
a685 2
#define CXp_REAL	0x00000100	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x00000200	/* eval{}, not eval'' or similar */
d688 1
a688 2
#define CXp_FOREACH	0x00000200	/* a foreach loop */
#define CXp_FOR_DEF	0x00000400	/* foreach using $_ */
d690 1
a690 5
#  define CXp_PADVAR	0x00000100	/* itervar lives on pad, iterdata
					   has pad offset; if not set,
					   iterdata holds GV* */
#  define CxPADLOOP(c)	(((c)->cx_type & (CXt_LOOP|CXp_PADVAR))		\
			 == (CXt_LOOP|CXp_PADVAR))
d693 3
d697 1
d704 3
a706 4
#define CxFOREACH(c)	(((c)->cx_type & (CXTYPEMASK|CXp_FOREACH))	\
                         == (CXt_LOOP|CXp_FOREACH))
#define CxFOREACHDEF(c)	(((c)->cx_type & (CXTYPEMASK|CXp_FOREACH|CXp_FOR_DEF))\
			 == (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))
d743 4
a746 4
#define G_SCALAR	0
#define G_ARRAY		1
#define G_VOID		128	/* skip this bit when adding flags below */
#define G_WANT		(128|1)
d749 1
a749 1
#define G_DISCARD	2	/* Call FREETMPS.
d752 5
a756 5
#define G_EVAL		4	/* Assume eval {} around subroutine call. */
#define G_NOARGS	8	/* Don't construct a @@_ array. */
#define G_KEEPERR      16	/* Append errors to $@@, don't overwrite it */
#define G_NODEBUG      32	/* Disable debugging at toplevel.  */
#define G_METHOD       64       /* Calling method. */
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d135 1
d265 1
a265 1
					sv_2mortal(newSVpvs("$[")),	\
d299 4
d350 5
a354 1
	if (cx->blk_sub.hasargs) {					\
d363 1
a363 1
		CX_CURPAD_SV(cx->blk_sub, 0) = (SV*)cx->blk_sub.argarray;	\
d369 2
a370 2
	sv = (SV*)cx->blk_sub.cv;					\
	if (sv && (CvDEPTH((CV*)sv) = cx->blk_sub.olddepth))		\
d396 3
d413 2
a414 2
	PL_in_eval = cx->blk_eval.old_in_eval;				\
	optype = cx->blk_eval.old_op_type;				\
d434 3
d471 2
a472 4
	if ((cx->blk_loop.iterdata = (idata)))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = NULL;
d476 2
a477 4
	if ((cx->blk_loop.itervar = (SV**)(ivar)))			\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = NULL;
d479 3
a502 10
	if (CxITERVAR(cx)) {						\
            if (SvPADMY(cx->blk_loop.itersave)) {			\
		SV ** const s_v_p = CxITERVAR(cx);			\
		sv_2mortal(*s_v_p);					\
		*s_v_p = cx->blk_loop.itersave;				\
	    }								\
	    else {							\
		SvREFCNT_dec(cx->blk_loop.itersave);			\
	    }								\
	}								\
d629 2
d676 1
a676 1
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL))		\
d678 1
a678 1
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXt_EVAL|CXp_TRYBLOCK))	\
d680 1
a680 1
#define CxFOREACH(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH))	\
d682 1
a682 1
#define CxFOREACHDEF(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))\
d723 1
d867 1
d891 1
d894 1
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d16 120
d138 3
d149 1
d151 5
a155 4
    I32		cop_arybase;	/* array base this line was compiled with */
    line_t      cop_line;       /* line # of this command */
    SV *	cop_warnings;	/* lexical warnings bitmask */
    SV *	cop_io;		/* lexical IO defaults */
a157 2
#define Nullcop Null(COP*)

d161 1
a161 1
				 ? gv_fetchfile(CopFILE(c)) : Nullgv)
d165 1
d168 1
d172 1
a172 1
				 ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
d174 7
a180 1
				 ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
d184 1
a184 1
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
d190 2
a191 2
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME_get(hv) : Nullch)
d193 2
d198 2
d202 3
a204 1
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))
d210 10
a219 3
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
#  define CopFILE(c)		(CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
d221 1
d223 1
a223 1
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : Nullch)
d227 2
d230 2
a231 1
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = Nullgv))
d248 27
a283 1
#ifndef USE_5005THREADS
a284 1
#endif /* USE_5005THREADS */
d286 1
a286 1
    long	olddepth;
d290 1
d301 1
d303 2
a304 2
	    (void)SvREFCNT_inc(cv);					\
	    (void)SvREFCNT_inc(cv);					\
d323 1
d326 1
a326 1
	(void)SvREFCNT_inc(cx->blk_sub.dfoutgv)
d328 1
a328 4
#ifdef USE_5005THREADS
#  define POP_SAVEARRAY() NOOP
#else
#  define POP_SAVEARRAY()						\
a332 1
#endif /* USE_5005THREADS */
d339 1
a339 1
	SvPV_set(ary, (char*)AvALLOC(ary));				\
d349 1
a349 1
		SSize_t fill = AvFILLp(cx->blk_sub.argarray);		\
d353 1
a353 1
		AvFLAGS(cx->blk_sub.argarray) = AVf_REIFY;		\
d362 1
a362 1
	    sv = Nullsv;						\
d377 2
a378 2
    I32		old_in_eval;
    I32		old_op_type;
d383 2
d391 1
a391 1
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : Nullsv);		\
d393 4
a396 2
	cx->blk_eval.cur_text = PL_linestr;				\
	cx->blk_eval.cv = Nullcv; /* set by doeval(), as applicable */	\
d412 3
a414 3
    OP *	redo_op;
    OP *	next_op;
    OP *	last_op;
d419 1
d423 2
d426 4
d432 2
d436 9
d459 1
a459 1
	    cx->blk_loop.itersave = Nullsv;
d466 9
a474 1
	    cx->blk_loop.itersave = Nullsv;
d480 4
a483 5
	cx->blk_loop.redo_op = cLOOP->op_redoop;			\
	cx->blk_loop.next_op = cLOOP->op_nextop;			\
	cx->blk_loop.last_op = cLOOP->op_lastop;			\
	cx->blk_loop.iterlval = Nullsv;					\
	cx->blk_loop.iterary = Nullav;					\
d490 8
a497 3
	    SV **s_v_p = CxITERVAR(cx);					\
	    sv_2mortal(*s_v_p);						\
	    *s_v_p = cx->blk_loop.itersave;				\
d502 10
d514 3
a518 1
    I32		blku_oldretsp;	/* return stack index */
a521 1
    U8		blku_gimme;	/* is this block running in list context? */
d527 1
a531 1
#define blk_oldretsp	cx_u.cx_blk.blku_oldretsp
d539 1
a547 1
	cx->blk_oldretsp	= PL_retstack_ix,			\
a558 1
	PL_retstack_ix	 = cx->blk_oldretsp,				\
a569 1
	PL_retstack_ix	 = cx->blk_oldretsp,				\
d575 3
a581 2
    bool	sbu_once;
    bool	sbu_rxtainted;
d619 1
a619 1
	cx->sb_rxres		= Null(void*),				\
d622 2
a623 1
	rxres_save(&cx->sb_rxres, rx)
d626 2
a627 1
	rxres_free(&cx->sb_rxres)
a629 1
    U32		cx_type;	/* what kind of context this is */
d635 1
d645 6
d656 3
a659 1
/* private flags for CXt_LOOP */
d668 2
d674 4
d719 3
a721 1
#define G_DISCARD	2	/* Call FREETMPS. */
d727 2
d756 2
a760 2
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
d802 1
a802 1
	PERL_SI *prev = PL_curstackinfo->si_prev;			\
d823 73
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d60 2
a61 5
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
#  define CopSTASH_eq(c,hv)	((hv) 					\
				 && (CopSTASHPV(c) == HvNAME(hv)	\
				     || (CopSTASHPV(c) && HvNAME(hv)	\
					 && strEQ(CopSTASHPV(c), HvNAME(hv)))))
a63 5
#  else
#    define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))      
#  endif

#  ifdef NETWARE
d66 2
a67 1
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))      
d78 1
a78 1
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
d167 1
a167 1
	SvPVX(ary) = (char*)AvALLOC(ary);				\
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d126 4
a129 1
/* base for the next two macros. Don't use directly */
d133 7
a139 1
	cx->blk_sub.hasargs = hasargs;
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d9 5
d40 5
a44 5
 #ifdef NETWARE
  #define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
 #else
  #define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
 #endif
d52 5
a56 5
  #ifdef NETWARE
    #define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
  #else
    #define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savesharedpv(pv))
  #endif
d65 11
a75 11
  #ifdef NETWARE
    #define CopSTASH_free(c) SAVECOPSTASH_FREE(c)
  #else
    #define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))      
  #endif

  #ifdef NETWARE
    #define CopFILE_free(c) SAVECOPFILE_FREE(c)
  #else
    #define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))      
  #endif
d120 1
a120 1
    U16		olddepth;
d123 1
a123 1
    SV **	oldcurpad;
d126 6
d133 1
a133 3
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = (U16)CvDEPTH(cv);			\
	cx->blk_sub.hasargs = hasargs;					\
d137 6
d180 1
a180 1
		cx->blk_sub.oldcurpad[0] = (SV*)cx->blk_sub.argarray;	\
d239 1
a239 1
    SV **	oldcurpad;
d254 2
a255 1
	    ? &((c)->blk_loop.oldcurpad)[INT2PTR(PADOFFSET, (c)->blk_loop.iterdata)] \
d259 1
a259 1
	cx->blk_loop.oldcurpad = PL_curpad;				\
d343 1
d353 2
a354 1
	PL_curpm         = cx->blk_oldpm
d581 4
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d24 1
d33 7
a39 1
#  define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
d45 7
a51 1
#  define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
d59 11
d83 3
d94 7
d110 1
a110 1
#ifndef USE_THREADS
d112 1
a112 1
#endif /* USE_THREADS */
d122 1
a122 1
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
d134 1
a134 1
#ifdef USE_THREADS
d142 1
a142 1
#endif /* USE_THREADS */
d192 1
d202 1
d238 1
a238 1
	    ? &((c)->blk_loop.oldcurpad)[(PADOFFSET)(c)->blk_loop.iterdata]	\
d244 3
a246 1
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
d251 3
a253 1
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
d313 1
a313 1
	cx->blk_gimme		= gimme;				\
d428 3
a430 1
/* "gimme" values */
@


1.5
log
@Change 6214 by gsar@@auger on 2000/06/08 13:57:54
    @@_ can't have junk in it even in the non-USE_ITHREADS case because
    caller() wants to populate @@DB::args with it (causes a coredump
    in Carp::confess())
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d32 1
a32 1
#  define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))	/* XXX */
d38 1
a38 1
#  define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savepv(pv))	/* XXX */
d41 2
a42 2
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, HvNAME(hv))
#  define CopSTASH_eq(c,hv)	(hv 					\
d48 2
a49 2
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = gv)
#  define CopFILE_set(c,pv)	((c)->cop_filegv = gv_fetchfile(pv))
d54 1
a54 1
#  define CopSTASH_set(c,hv)	((c)->cop_stash = hv)
d56 3
a58 2
#  define CopSTASHPV_set(c,pv)	CopSTASH_set(c, gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == hv)
d83 1
d111 7
a117 2
 * leave any */
#define CLEAR_ARGARRAY()	av_clear(cx->blk_sub.argarray)
d130 1
a130 1
		PL_curpad[0] = (SV*)cx->blk_sub.argarray;		\
d133 1
a133 1
		CLEAR_ARGARRAY();					\
d396 1
a396 1
Used to indicate array context.  See C<GIMME_V>, C<GIMME> and
d429 1
d436 1
d502 1
a502 1
	djSP;								\
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d108 3
a110 7
#ifdef USE_ITHREADS
   /* junk in @@_ spells trouble when cloning CVs, so don't leave any */
#  define CLEAR_ARGARRAY()	av_clear(cx->blk_sub.argarray)
#else
#  define CLEAR_ARGARRAY()	NOOP
#endif /* USE_ITHREADS */

@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d13 4
d19 1
d23 1
d28 38
d81 1
d87 3
a89 1
	cx->blk_sub.hasargs = hasargs;
a97 8
#define POPSUB(cx)							\
	{ struct block_sub cxsub;					\
	  POPSUB1(cx);							\
	  POPSUB2(); }

#define POPSUB1(cx)							\
	cxsub = cx->blk_sub;	/* because DESTROY may clobber *cx */

d99 1
a99 1
#define POPSAVEARRAY() NOOP
d101 1
a101 1
#define POPSAVEARRAY()							\
d104 1
a104 1
	GvAV(PL_defgv) = cxsub.savearray;					\
d108 24
a131 6
#define POPSUB2()							\
	if (cxsub.hasargs) {						\
	    POPSAVEARRAY();						\
	    /* destroy arg array */					\
	    av_clear(cxsub.argarray);					\
	    AvREAL_off(cxsub.argarray);					\
d133 10
a142 4
	if (cxsub.cv) {							\
	    if (!(CvDEPTH(cxsub.cv) = cxsub.olddepth))			\
		SvREFCNT_dec(cxsub.cv);					\
	}
d152 1
a152 1
    char *	old_name;
d158 1
d160 5
a164 4
	cx->blk_eval.old_op_type = PL_op->op_type;				\
	cx->blk_eval.old_name = n;					\
	cx->blk_eval.old_eval_root = PL_eval_root;				\
	cx->blk_eval.cur_text = PL_linestr;
d167 1
d170 4
a173 1
	PL_eval_root = cx->blk_eval.old_eval_root;
d182 4
d187 1
d195 21
a215 3
#define PUSHLOOP(cx, ivar, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;				\
	cx->blk_loop.resetsp = s - PL_stack_base;				\
a218 2
	if (cx->blk_loop.itervar = (ivar))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*cx->blk_loop.itervar);\
d221 2
a222 1
	cx->blk_loop.iterix = -1;
d225 5
a229 13
	{ struct block_loop cxloop;					\
	  POPLOOP1(cx);							\
	  POPLOOP2(); }

#define POPLOOP1(cx)							\
	cxloop = cx->blk_loop;	/* because DESTROY may clobber *cx */	\
	newsp = PL_stack_base + cxloop.resetsp;

#define POPLOOP2()							\
	SvREFCNT_dec(cxloop.iterlval);					\
	if (cxloop.itervar) {						\
	    sv_2mortal(*cxloop.itervar);				\
	    *cxloop.itervar = cxloop.itersave;				\
d231 2
a232 2
	if (cxloop.iterary && cxloop.iterary != PL_curstack)		\
	    SvREFCNT_dec(cxloop.iterary);
d271 2
a272 2
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, block_type[CxTYPE(cx)]); )
d283 2
a284 2
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,block_type[CxTYPE(cx)]); )
d298 1
a298 1
    I32		sbu_safebase;
d313 1
a313 1
#define sb_safebase	cx_u.cx_subst.sbu_safebase
d329 1
a329 1
	cx->sb_safebase		= safebase,				\
d362 1
d366 10
d378 4
a381 1
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL)) == (CXt_EVAL|CXp_REAL))
d386 30
d420 1
a420 1
/* extra flags for perl_call_* routines */
d427 6
d457 1
a457 1
    I32 *		si_markbase;	/* where markstack begins for us.
d469 2
a470 1
#  define	SET_MARKBASE PL_curstackinfo->si_markbase = PL_markstack_ptr
d472 1
a472 1
#  define	SET_MARKBASE NOOP
d488 1
a488 1
	SET_MARKBASE;							\
d493 2
d497 1
d500 1
a500 1
	    PerlIO_printf(PerlIO_stderr(), "panic: POPSTACK\n");	\
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d31 1
d33 1
d48 1
a48 1
	cx->blk_sub.dfoutgv = defoutgv;					\
d59 10
d71 1
a71 3
	    /* put back old @@_ */					\
	    SvREFCNT_dec(GvAV(defgv));					\
	    GvAV(defgv) = cxsub.savearray;				\
d95 2
a96 2
	cx->blk_eval.old_in_eval = in_eval;				\
	cx->blk_eval.old_op_type = op->op_type;				\
d98 2
a99 2
	cx->blk_eval.old_eval_root = eval_root;				\
	cx->blk_eval.cur_text = linestr;
d102 1
a102 1
	in_eval = cx->blk_eval.old_in_eval;				\
d104 1
a104 1
	eval_root = cx->blk_eval.old_eval_root;
d117 2
a118 1
    I32		iterix;
d122 2
a123 2
	cx->blk_loop.label = curcop->cop_label;				\
	cx->blk_loop.resetsp = s - stack_base;				\
d140 1
a140 1
	newsp = stack_base + cxloop.resetsp;
d145 1
a145 1
	    SvREFCNT_dec(*cxloop.itervar);				\
d148 1
a148 1
	if (cxloop.iterary && cxloop.iterary != curstack)		\
d181 6
a186 6
	cx->blk_oldsp		= sp - stack_base,			\
	cx->blk_oldcop		= curcop,				\
	cx->blk_oldmarksp	= markstack_ptr - markstack,		\
	cx->blk_oldscopesp	= scopestack_ix,			\
	cx->blk_oldretsp	= retstack_ix,				\
	cx->blk_oldpm		= curpm,				\
d189 1
a189 1
		    (long)cxstack_ix, block_type[t]); )
d193 7
a199 7
	newsp		= stack_base + cx->blk_oldsp,			\
	curcop		= cx->blk_oldcop,				\
	markstack_ptr	= markstack + cx->blk_oldmarksp,		\
	scopestack_ix	= cx->blk_oldscopesp,				\
	retstack_ix	= cx->blk_oldretsp,				\
	pm		= cx->blk_oldpm,				\
	gimme		= cx->blk_gimme;				\
d201 1
a201 1
		    (long)cxstack_ix+1,block_type[cx->cx_type]); )
d204 6
a209 5
#define TOPBLOCK(cx) cx = &cxstack[cxstack_ix],				\
	stack_sp	= stack_base + cx->blk_oldsp,			\
	markstack_ptr	= markstack + cx->blk_oldmarksp,		\
	scopestack_ix	= cx->blk_oldscopesp,				\
	retstack_ix	= cx->blk_oldretsp
d265 1
a265 1
    I32		cx_type;	/* what kind of context this is */
d271 2
d280 6
d298 80
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d50 15
a64 2
	if (cx->blk_sub.hasargs) {   /* put back old @@_ */		\
	    GvAV(defgv) = cx->blk_sub.savearray;			\
d66 3
a68 4
	if (cx->blk_sub.cv) {						\
	    if (!(CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth)) {	\
		SvREFCNT_dec((SV*)cx->blk_sub.cv);			\
	    }								\
d105 1
d116 5
a120 3
	cx->blk_loop.itervar = ivar;					\
	if (ivar)							\
	    cx->blk_loop.itersave = *cx->blk_loop.itervar;
d123 16
a138 1
	newsp		= stack_base + cx->blk_loop.resetsp;
d177 1
a177 1
	DEBUG_l( fprintf(stderr,"Entering block %ld, type %s\n",	\
d189 1
a189 1
	DEBUG_l( fprintf(stderr,"Leaving block %ld, type %s\n",		\
a203 1
    I32		sbu_once;
d205 2
d213 1
a213 1
    char *	sbu_subbase;
d219 1
d221 1
a221 1
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
d228 1
a228 1
#define sb_subbase	cx_u.cx_subst.sbu_subbase
d235 1
d237 1
a237 1
	cx->sb_oldsave		= oldsave,				\
d244 1
d246 2
a247 1
	cx->cx_type		= CXt_SUBST
d249 2
a250 1
#define POPSUBST(cx) cxstack_ix--
d271 1
d277 1
a277 1
#define G_KEEPERR      16	/* Append errors to $@@ rather than overwriting it */
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a30 1
#ifndef USE_THREADS
a31 1
#endif /* USE_THREADS */
d46 1
a46 1
	cx->blk_sub.dfoutgv = PL_defoutgv;				\
d50 2
a51 23
	{ struct block_sub cxsub;					\
	  POPSUB1(cx);							\
	  POPSUB2(); }

#define POPSUB1(cx)							\
	cxsub = cx->blk_sub;	/* because DESTROY may clobber *cx */

#ifdef USE_THREADS
#define POPSAVEARRAY() NOOP
#else
#define POPSAVEARRAY()							\
    STMT_START {							\
	SvREFCNT_dec(GvAV(PL_defgv));					\
	GvAV(PL_defgv) = cxsub.savearray;					\
    } STMT_END
#endif /* USE_THREADS */

#define POPSUB2()							\
	if (cxsub.hasargs) {						\
	    POPSAVEARRAY();						\
	    /* destroy arg array */					\
	    av_clear(cxsub.argarray);					\
	    AvREAL_off(cxsub.argarray);					\
d53 4
a56 3
	if (cxsub.cv) {							\
	    if (!(CvDEPTH(cxsub.cv) = cxsub.olddepth))			\
		SvREFCNT_dec(cxsub.cv);					\
d73 2
a74 2
	cx->blk_eval.old_in_eval = PL_in_eval;				\
	cx->blk_eval.old_op_type = PL_op->op_type;				\
d76 2
a77 2
	cx->blk_eval.old_eval_root = PL_eval_root;				\
	cx->blk_eval.cur_text = PL_linestr;
d80 1
a80 1
	PL_in_eval = cx->blk_eval.old_in_eval;				\
d82 1
a82 1
	PL_eval_root = cx->blk_eval.old_eval_root;
a92 1
    SV *	iterlval;
d94 1
a94 2
    IV		iterix;
    IV		itermax;
d98 2
a99 2
	cx->blk_loop.label = PL_curcop->cop_label;				\
	cx->blk_loop.resetsp = s - PL_stack_base;				\
d103 3
a105 5
	if (cx->blk_loop.itervar = (ivar))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*cx->blk_loop.itervar);\
	cx->blk_loop.iterlval = Nullsv;					\
	cx->blk_loop.iterary = Nullav;					\
	cx->blk_loop.iterix = -1;
d108 1
a108 16
	{ struct block_loop cxloop;					\
	  POPLOOP1(cx);							\
	  POPLOOP2(); }

#define POPLOOP1(cx)							\
	cxloop = cx->blk_loop;	/* because DESTROY may clobber *cx */	\
	newsp = PL_stack_base + cxloop.resetsp;

#define POPLOOP2()							\
	SvREFCNT_dec(cxloop.iterlval);					\
	if (cxloop.itervar) {						\
	    sv_2mortal(*cxloop.itervar);				\
	    *cxloop.itervar = cxloop.itersave;				\
	}								\
	if (cxloop.iterary && cxloop.iterary != PL_curstack)		\
	    SvREFCNT_dec(cxloop.iterary);
d140 6
a145 6
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldretsp	= PL_retstack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
d147 2
a148 2
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, block_type[CxTYPE(cx)]); )
d152 9
a160 9
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;				\
	DEBUG_l( PerlIO_printf(PerlIO_stderr(), "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,block_type[CxTYPE(cx)]); )
d163 5
a167 6
#define TOPBLOCK(cx) cx  = &cxstack[cxstack_ix],			\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	PL_curpm         = cx->blk_oldpm
d174 1
a175 2
    bool	sbu_once;
    bool	sbu_rxtainted;
d182 1
a182 1
    void *	sbu_rxres;
d188 1
a189 2
#define sb_once		cx_u.cx_subst.sbu_once
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
d196 1
a196 1
#define sb_rxres	cx_u.cx_subst.sbu_rxres
d203 1
a204 2
	cx->sb_once		= once,					\
	cx->sb_rxtainted	= rxtainted,				\
a210 1
	cx->sb_rxres		= Null(void*),				\
d212 1
a212 2
	cx->cx_type		= CXt_SUBST;				\
	rxres_save(&cx->sb_rxres, rx)
d214 1
a214 2
#define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
	rxres_free(&cx->sb_rxres)
d217 1
a217 1
    U32		cx_type;	/* what kind of context this is */
a222 2

#define CXTYPEMASK	0xff
a229 6
/* private flags for CXt_EVAL */
#define CXp_REAL	0x00000100	/* truly eval'', not a lookalike */

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL)) == (CXt_EVAL|CXp_REAL))

a234 1
#define G_VOID		128	/* skip this bit when adding flags below */
d240 1
a240 81
#define G_KEEPERR      16	/* Append errors to $@@, don't overwrite it */
#define G_NODEBUG      32	/* Disable debugging at toplevel.  */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32 *		si_markbase;	/* where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARKBASE PL_curstackinfo->si_markbase = PL_markstack_ptr
#else
#  define	SET_MARKBASE NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARKBASE;							\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

#define POPSTACK \
    STMT_START {							\
	PERL_SI *prev = PL_curstackinfo->si_prev;			\
	if (!prev) {							\
	    PerlIO_printf(PerlIO_stderr(), "panic: POPSTACK\n");	\
	    my_exit(1);							\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a12 4
#ifdef USE_ITHREADS
    char *	cop_stashpv;	/* package line was compiled in */
    char *	cop_file;	/* file name the following line # is from */
#else
a14 1
#endif
a17 1
    SV *	cop_warnings;	/* lexical warnings bitmask */
a21 38
#ifdef USE_ITHREADS
#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
				 ? gv_fetchfile(CopFILE(c)) : Nullgv)
#  define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))	/* XXX */
#  define CopFILESV(c)		(CopFILE(c) \
				 ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
#  define CopFILEAV(c)		(CopFILE(c) \
				 ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
#  define CopSTASHPV(c)		((c)->cop_stashpv)
#  define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savepv(pv))	/* XXX */
#  define CopSTASH(c)		(CopSTASHPV(c) \
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, HvNAME(hv))
#  define CopSTASH_eq(c,hv)	(hv 					\
				 && (CopSTASHPV(c) == HvNAME(hv)	\
				     || (CopSTASHPV(c) && HvNAME(hv)	\
					 && strEQ(CopSTASHPV(c), HvNAME(hv)))))
#else
#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = gv)
#  define CopFILE_set(c,pv)	((c)->cop_filegv = gv_fetchfile(pv))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
#  define CopFILE(c)		(CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = hv)
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
#  define CopSTASHPV_set(c,pv)	CopSTASH_set(c, gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == hv)
#endif /* USE_ITHREADS */

#define CopSTASH_ne(c,hv)	(!CopSTASH_eq(c,hv))
#define CopLINE(c)		((c)->cop_line)
#define CopLINE_inc(c)		(++CopLINE(c))
#define CopLINE_dec(c)		(--CopLINE(c))
#define CopLINE_set(c,l)	(CopLINE(c) = (l))

a36 1
    U8		lval;		/* XXX merge lval and hasargs? */
d42 1
a42 3
	cx->blk_sub.hasargs = hasargs;					\
	cx->blk_sub.lval = PL_op->op_private &                          \
	                      (OPpLVAL_INTRO|OPpENTERSUB_INARGS);
d51 8
d60 1
a60 1
#  define POP_SAVEARRAY() NOOP
d62 1
a62 1
#  define POP_SAVEARRAY()						\
d65 1
a65 1
	GvAV(PL_defgv) = cx->blk_sub.savearray;				\
d69 6
a74 24
#ifdef USE_ITHREADS
   /* junk in @@_ spells trouble when cloning CVs, so don't leave any */
#  define CLEAR_ARGARRAY()	av_clear(cx->blk_sub.argarray)
#else
#  define CLEAR_ARGARRAY()	NOOP
#endif /* USE_ITHREADS */


#define POPSUB(cx,sv)							\
    STMT_START {							\
	if (cx->blk_sub.hasargs) {					\
	    POP_SAVEARRAY();						\
	    /* abandon @@_ if it got reified */				\
	    if (AvREAL(cx->blk_sub.argarray)) {				\
		SSize_t fill = AvFILLp(cx->blk_sub.argarray);		\
		SvREFCNT_dec(cx->blk_sub.argarray);			\
		cx->blk_sub.argarray = newAV();				\
		av_extend(cx->blk_sub.argarray, fill);			\
		AvFLAGS(cx->blk_sub.argarray) = AVf_REIFY;		\
		PL_curpad[0] = (SV*)cx->blk_sub.argarray;		\
	    }								\
	    else {							\
		CLEAR_ARGARRAY();					\
	    }								\
d76 4
a79 10
	sv = (SV*)cx->blk_sub.cv;					\
	if (sv && (CvDEPTH((CV*)sv) = cx->blk_sub.olddepth))		\
	    sv = Nullsv;						\
    } STMT_END

#define LEAVESUB(sv)							\
    STMT_START {							\
	if (sv)								\
	    SvREFCNT_dec(sv);						\
    } STMT_END
d89 1
a89 1
    SV *	old_namesv;
a94 1
    STMT_START {							\
d96 4
a99 5
	cx->blk_eval.old_op_type = PL_op->op_type;			\
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : Nullsv);		\
	cx->blk_eval.old_eval_root = PL_eval_root;			\
	cx->blk_eval.cur_text = PL_linestr;				\
    } STMT_END
a101 1
    STMT_START {							\
d104 1
a104 4
	PL_eval_root = cx->blk_eval.old_eval_root;			\
	if (cx->blk_eval.old_namesv)					\
	    sv_2mortal(cx->blk_eval.old_namesv);			\
    } STMT_END
a112 4
#ifdef USE_ITHREADS
    void *	iterdata;
    SV **	oldcurpad;
#else
a113 1
#endif
d121 3
a123 21
#ifdef USE_ITHREADS
#  define CxITERVAR(c)							\
	((c)->blk_loop.iterdata						\
	 ? (CxPADLOOP(cx) 						\
	    ? &((c)->blk_loop.oldcurpad)[(PADOFFSET)(c)->blk_loop.iterdata]	\
	    : &GvSV((GV*)(c)->blk_loop.iterdata))			\
	 : (SV**)NULL)
#  define CX_ITERDATA_SET(cx,idata)					\
	cx->blk_loop.oldcurpad = PL_curpad;				\
	if ((cx->blk_loop.iterdata = (idata)))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
#else
#  define CxITERVAR(c)		((c)->blk_loop.itervar)
#  define CX_ITERDATA_SET(cx,ivar)					\
	if ((cx->blk_loop.itervar = (SV**)(ivar)))			\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
#endif

#define PUSHLOOP(cx, dat, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;			\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
d127 2
d131 1
a131 2
	cx->blk_loop.iterix = -1;					\
	CX_ITERDATA_SET(cx,dat);
d134 13
a146 5
	SvREFCNT_dec(cx->blk_loop.iterlval);				\
	if (CxITERVAR(cx)) {						\
	    SV **s_v_p = CxITERVAR(cx);					\
	    sv_2mortal(*s_v_p);						\
	    *s_v_p = cx->blk_loop.itersave;				\
d148 2
a149 2
	if (cx->blk_loop.iterary && cx->blk_loop.iterary != PL_curstack)\
	    SvREFCNT_dec(cx->blk_loop.iterary);
d188 2
a189 2
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, PL_block_type[CxTYPE(cx)]); )
d200 2
a201 2
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,PL_block_type[CxTYPE(cx)]); )
d215 1
a215 1
    I32		sbu_rflags;
d230 1
a230 1
#define sb_rflags	cx_u.cx_subst.sbu_rflags
d246 1
a246 1
	cx->sb_rflags		= r_flags,				\
a278 1
#define CXt_FORMAT	6
a281 10
#define CXp_TRYBLOCK	0x00000200	/* eval{}, not eval'' or similar */

#ifdef USE_ITHREADS
/* private flags for CXt_LOOP */
#  define CXp_PADVAR	0x00000100	/* itervar lives on pad, iterdata
					   has pad offset; if not set,
					   iterdata holds GV* */
#  define CxPADLOOP(c)	(((c)->cx_type & (CXt_LOOP|CXp_PADVAR))		\
			 == (CXt_LOOP|CXp_PADVAR))
#endif
d284 1
a284 4
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL))		\
			 == (CXt_EVAL|CXp_REAL))
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXt_EVAL|CXp_TRYBLOCK))	\
			 == (CXt_EVAL|CXp_TRYBLOCK))
a288 30

/*
=for apidoc AmU||G_SCALAR
Used to indicate scalar context.  See C<GIMME_V>, C<GIMME>, and
L<perlcall>.

=for apidoc AmU||G_ARRAY
Used to indicate array context.  See C<GIMME_V>, C<GIMME> and
L<perlcall>.

=for apidoc AmU||G_VOID
Used to indicate void context.  See C<GIMME_V> and L<perlcall>.

=for apidoc AmU||G_DISCARD
Indicates that arguments returned from a callback should be discarded.  See
L<perlcall>.

=for apidoc AmU||G_EVAL

Used to force a Perl C<eval> wrapper around a callback.  See
L<perlcall>.

=for apidoc AmU||G_NOARGS

Indicates that no arguments are being sent to a callback.  See
L<perlcall>.

=cut
*/

d293 1
a293 1
/* extra flags for Perl_call_* routines */
a299 6
/* flag bits for PL_in_eval */
#define EVAL_NULL	0	/* not in an eval */
#define EVAL_INEVAL	1	/* some enclosing scope is an eval */
#define EVAL_WARNONLY	2	/* used by yywarn() when calling yyerror() */
#define EVAL_KEEPERR	4	/* set by Perl_call_sv if G_KEEPERR */

d324 1
a324 1
    I32			si_markoff;	/* offset where markstack begins for us.
d336 1
a336 2
#  define	SET_MARK_OFFSET \
    PL_curstackinfo->si_markoff = PL_markstack_ptr - PL_markstack
d338 1
a338 1
#  define	SET_MARK_OFFSET NOOP
d354 1
a354 1
	SET_MARK_OFFSET;						\
a358 2
/* POPSTACK works with PL_stack_sp, so it may need to be bracketed by
 * PUTBACK/SPAGAIN to flush/refresh any local SP that may be active */
a360 1
	djSP;								\
d363 1
a363 1
	    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");		\
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d32 1
a32 1
#  define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
d38 1
a38 1
#  define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
d41 2
a42 2
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
#  define CopSTASH_eq(c,hv)	((hv) 					\
d48 2
a49 2
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
d54 1
a54 1
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
d56 2
a57 3
   /* cop_stash is not refcounted */
#  define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))
a81 1
    SV **	oldcurpad;
d108 7
a114 8
/* junk in @@_ spells trouble when cloning CVs and in pp_caller(), so don't
 * leave any (a fast av_clear(ary), basically) */
#define CLEAR_ARGARRAY(ary) \
    STMT_START {							\
	AvMAX(ary) += AvARRAY(ary) - AvALLOC(ary);			\
	SvPVX(ary) = (char*)AvALLOC(ary);				\
	AvFILLp(ary) = -1;						\
    } STMT_END
d127 1
a127 1
		cx->blk_sub.oldcurpad[0] = (SV*)cx->blk_sub.argarray;	\
d130 1
a130 1
		CLEAR_ARGARRAY(cx->blk_sub.argarray);			\
d393 1
a393 1
Used to indicate list context.  See C<GIMME_V>, C<GIMME> and
a425 1
#define G_METHOD       64       /* Calling method. */
a431 1
#define EVAL_INREQUIRE	8	/* The code is being required. */
d497 1
a497 1
	dSP;								\
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a23 1
    SV *	cop_io;		/* lexical IO defaults */
d32 1
a32 7
				 
 #ifdef NETWARE
  #define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
 #else
  #define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
 #endif

d38 1
a38 7

  #ifdef NETWARE
    #define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
  #else
    #define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savesharedpv(pv))
  #endif

a45 11
  #ifdef NETWARE
    #define CopSTASH_free(c) SAVECOPSTASH_FREE(c)
  #else
    #define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))      
  #endif

  #ifdef NETWARE
    #define CopFILE_free(c) SAVECOPFILE_FREE(c)
  #else
    #define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))      
  #endif
a58 3
#  define CopSTASH_free(c)	
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = Nullgv))

a66 7
/* OutCopFILE() is CopFILE for output (caller, die, warn, etc.) */
#ifdef MACOS_TRADITIONAL
#  define OutCopFILE(c) MacPerl_MPWFileName(CopFILE(c))
#else
#  define OutCopFILE(c) CopFILE(c)
#endif

d76 1
a76 1
#ifndef USE_5005THREADS
d78 1
a78 1
#endif /* USE_5005THREADS */
d88 1
a88 1
	cx->blk_sub.olddepth = (U16)CvDEPTH(cv);			\
d100 1
a100 1
#ifdef USE_5005THREADS
d108 1
a108 1
#endif /* USE_5005THREADS */
a157 1
    CV *	cv;
a166 1
	cx->blk_eval.cv = Nullcv; /* set by doeval(), as applicable */	\
d202 1
a202 1
	    ? &((c)->blk_loop.oldcurpad)[INT2PTR(PADOFFSET, (c)->blk_loop.iterdata)] \
d208 1
a208 3
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = Nullsv;
d213 1
a213 3
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));	\
	else								\
	    cx->blk_loop.itersave = Nullsv;
d273 1
a273 1
	cx->blk_gimme		= (U8)gimme;				\
d388 1
a388 3
/* 
=head1 "Gimme" Values
*/
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a7 5
 * Control ops (cops) are one of the three ops OP_NEXTSTATE, OP_DBSTATE,
 * and OP_SETSTATE that (loosely speaking) are separate statements.
 * They hold information important for lexical state and error reporting.
 * At run time, PL_curcop is set to point to the most recently executed cop,
 * and thus can be used to determine our current state.
d34 5
a38 5
#  ifdef NETWARE
#    define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
#  else
#    define CopFILE_set(c,pv)	((c)->cop_file = savesharedpv(pv))
#  endif
d46 5
a50 5
#  ifdef NETWARE
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
#  else
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = savesharedpv(pv))
#  endif
d59 11
a69 11
#  ifdef NETWARE
#    define CopSTASH_free(c) SAVECOPSTASH_FREE(c)
#  else
#    define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))      
#  endif

#  ifdef NETWARE
#    define CopFILE_free(c) SAVECOPFILE_FREE(c)
#  else
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))      
#  endif
d114 1
a114 1
    long	olddepth;
d117 1
a117 1
    PAD		*oldcomppad;
d120 1
a120 2
/* base for the next two macros. Don't use directly */
#define PUSHSUB_BASE(cx)						\
d122 2
a123 5
	cx->blk_sub.olddepth = CvDEPTH(cv);				\
	cx->blk_sub.hasargs = hasargs;

#define PUSHSUB(cx)							\
	PUSHSUB_BASE(cx)						\
a126 6
/* variant for use by OP_DBSTATE, where op_private holds hint bits */
#define PUSHSUB_DB(cx)							\
	PUSHSUB_BASE(cx)						\
	cx->blk_sub.lval = 0;


d164 1
a164 1
		CX_CURPAD_SV(cx->blk_sub, 0) = (SV*)cx->blk_sub.argarray;	\
d223 1
a223 1
    PAD		*oldcomppad;
d238 1
a238 2
	    ? &CX_CURPAD_SV( (c)->blk_loop, 				\
		    INT2PTR(PADOFFSET, (c)->blk_loop.iterdata))		\
d242 1
a242 1
	CX_CURPAD_SAVE(cx->blk_loop);					\
a325 1
	DEBUG_SCOPE("POPBLOCK");					\
d335 1
a335 2
	PL_curpm         = cx->blk_oldpm;				\
	DEBUG_SCOPE("TOPBLOCK");
a561 4

#define IN_PERL_COMPILETIME	(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		(PL_curcop != &PL_compiling)

@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d126 1
a126 4
/* base for the next two macros. Don't use directly.
 * Note that the refcnt of the cv is incremented twice;  The CX one is
 * decremented by LEAVESUB, the other by LEAVE. */

d130 1
a130 7
	cx->blk_sub.hasargs = hasargs;					\
	if (!CvDEPTH(cv)) {						\
	    (void)SvREFCNT_inc(cv);					\
	    (void)SvREFCNT_inc(cv);					\
	    SAVEFREESV(cv);						\
	}

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d60 5
a64 2
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME_get(hv) : Nullch)
#  define CopSTASH_eq(c,hv)	((hv) && stashpv_hvname_match(c,hv))
d67 5
d74 1
a74 2
#    define CopSTASH_free(c)	PerlMemShared_free(CopSTASHPV(c))
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = Nullch))
d85 1
a85 1
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : Nullch)
d174 1
a174 1
	SvPV_set(ary, (char*)AvALLOC(ary));				\
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a15 120
/* A jmpenv packages the state required to perform a proper non-local jump.
 * Note that there is a start_env initialized when perl starts, and top_env
 * points to this initially, so top_env should always be non-null.
 *
 * Existence of a non-null top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure start_env.je_prev is always
 * null to ensure this).
 *
 * je_mustcatch, when set at any runlevel to TRUE, means eval ops must
 * establish a local jmpenv to handle exception traps.  Care must be taken
 * to restore the previous value of je_mustcatch before exiting the
 * stack frame iff JMPENV_PUSH was not called in that stack frame.
 * GSAR 97-03-27
 */

struct jmpenv {
    struct jmpenv *	je_prev;
    Sigjmp_buf		je_buf;		/* only for use if !je_throw */
    int			je_ret;		/* last exception thrown */
    bool		je_mustcatch;	/* need to call longjmp()? */
};

typedef struct jmpenv JMPENV;

#ifdef OP_IN_REGISTER
#define OP_REG_TO_MEM	PL_opsave = op
#define OP_MEM_TO_REG	op = PL_opsave
#else
#define OP_REG_TO_MEM	NOOP
#define OP_MEM_TO_REG	NOOP
#endif

/*
 * How to build the first jmpenv.
 *
 * top_env needs to be non-zero. It points to an area
 * in which longjmp() stuff is stored, as C callstack
 * info there at least is thread specific this has to
 * be per-thread. Otherwise a 'die' in a thread gives
 * that thread the C stack of last thread to do an eval {}!
 */

#define JMPENV_BOOTSTRAP \
    STMT_START {				\
	Zero(&PL_start_env, 1, JMPENV);		\
	PL_start_env.je_ret = -1;		\
	PL_start_env.je_mustcatch = TRUE;	\
	PL_top_env = &PL_start_env;		\
    } STMT_END

/*
 *   PERL_FLEXIBLE_EXCEPTIONS
 * 
 * All the flexible exceptions code has been removed.
 * See the following threads for details:
 *
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2004-07/msg00378.html
 * 
 * Joshua's original patches (which weren't applied) and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01396.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01489.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01491.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg01608.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02144.html
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1998-02/msg02998.html
 * 
 * Chip's reworked patch and discussion:
 * 
 *   http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1999-03/msg00520.html
 * 
 * The flaw in these patches (which went unnoticed at the time) was
 * that they moved some code that could potentially die() out of the
 * region protected by the setjmp()s.  This caused exceptions within
 * END blocks and such to not be handled by the correct setjmp().
 * 
 * The original patches that introduces flexible exceptions were:
 *
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=3386
 *   http://public.activestate.com/cgi-bin/perlbrowse?patch=5162
 */

#define dJMPENV		JMPENV cur_env

#define JMPENV_PUSH(v) \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p\n",	\
			 (void*)&cur_env, (void*)PL_top_env));			\
	cur_env.je_prev = PL_top_env;					\
	OP_REG_TO_MEM;							\
	cur_env.je_ret = PerlProc_setjmp(cur_env.je_buf, SCOPE_SAVES_SIGNAL_MASK);		\
	OP_MEM_TO_REG;							\
	PL_top_env = &cur_env;						\
	cur_env.je_mustcatch = FALSE;					\
	(v) = cur_env.je_ret;						\
    } STMT_END

#define JMPENV_POP \
    STMT_START {							\
	DEBUG_l(Perl_deb(aTHX_ "popping jumplevel was %p, now %p\n",	\
			 (void*)PL_top_env, (void*)cur_env.je_prev));			\
	PL_top_env = cur_env.je_prev;					\
    } STMT_END

#define JMPENV_JUMP(v) \
    STMT_START {						\
	OP_REG_TO_MEM;						\
	if (PL_top_env->je_prev)				\
	    PerlProc_longjmp(PL_top_env->je_buf, (v));		\
	if ((v) == 2)						\
	    PerlProc_exit(STATUS_EXIT);		                \
	PerlIO_printf(PerlIO_stderr(), "panic: top_env\n");	\
	PerlProc_exit(1);					\
    } STMT_END

#define CATCH_GET		(PL_top_env->je_mustcatch)
#define CATCH_SET(v)		(PL_top_env->je_mustcatch = (v))



a17 3
    /* On LP64 putting this here takes advantage of the fact that BASEOP isn't
       an exact multiple of 8 bytes to save structure padding.  */
    line_t      cop_line;       /* line # of this command */
a25 1
    U32		cop_hints;	/* hints bits from pragmata */
d27 4
a30 5
    /* Beware. mg.c and warnings.pl assume the type of this is STRLEN *:  */
    STRLEN *	cop_warnings;	/* lexical warnings bitmask */
    /* compile time state of %^H.  See the comment in op.c for how this is
       used to recreate a hash to return from caller.  */
    struct refcounted_he * cop_hints_hash;
d33 2
d38 1
a38 1
				 ? gv_fetchfile(CopFILE(c)) : NULL)
a41 1
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepv((pv),(l)))
a43 1
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savesharedpvn((pv),(l)))
d47 1
a47 1
				 ? GvSV(gv_fetchfile(CopFILE(c))) : NULL)
d49 1
a49 7
				 ? GvAV(gv_fetchfile(CopFILE(c))) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILE(c)), \
				   GvAV(gv_fetchfile(CopFILE(c))))
#  else
#    define CopFILEAVx(c)	(GvAV(gv_fetchfile(CopFILE(c))))
#  endif
d53 1
a53 1
#    define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : NULL))
d59 2
a60 2
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : NULL)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME_get(hv) : NULL)
a61 2
#  define CopLABEL(c)		((c)->cop_label)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
a64 2
#    define CopLABEL_free(c) SAVECOPLABEL_FREE(c)
#    define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
d67 1
a67 3
#    define CopFILE_free(c)	(PerlMemShared_free(CopFILE(c)),(CopFILE(c) = NULL))
#    define CopLABEL_free(c)	(PerlMemShared_free(CopLABEL(c)),(CopLABEL(c) = NULL))
#    define CopLABEL_alloc(pv)	((pv)?savesharedpv(pv):NULL)
d73 3
a75 10
#  define CopFILE_setn(c,pv,l)	CopFILEGV_set((c), gv_fetchfile_flags((pv),(l),0))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : NULL)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : NULL)
#  ifdef DEBUGGING
#    define CopFILEAVx(c)	(assert(CopFILEGV(c)), GvAV(CopFILEGV(c)))
#  else
#    define CopFILEAVx(c)	(GvAV(CopFILEGV(c)))
# endif
#  define CopFILE(c)		(CopFILEGV(c) && GvSV(CopFILEGV(c)) \
				    ? SvPVX(GvSV(CopFILEGV(c))) : NULL)
a76 1
#  define CopLABEL(c)		((c)->cop_label)
d78 1
a78 1
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
a81 2
#  define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
#  define CopLABEL_set(c,pv)	(CopLABEL(c) = (pv))
d83 1
a83 2
#  define CopFILE_free(c)	(SvREFCNT_dec(CopFILEGV(c)),(CopFILEGV(c) = NULL))
#  define CopLABEL_free(c)	(Safefree(CopLABEL(c)),(CopLABEL(c) = NULL))
a99 27
/* If $[ is non-zero, it's stored in cop_hints under the key "$[", and
   HINT_ARYBASE is set to indicate this.
   Setting it is ineficient due to the need to create 2 mortal SVs, but as
   using $[ is highly discouraged, no sane Perl code will be using it.  */
#define CopARYBASE_get(c)	\
	((CopHINTS_get(c) & HINT_ARYBASE)				\
	 ? SvIV(Perl_refcounted_he_fetch(aTHX_ (c)->cop_hints_hash, 0,	\
					 "$[", 2, 0, 0))		\
	 : 0)
#define CopARYBASE_set(c, b) STMT_START { \
	if (b || ((c)->cop_hints & HINT_ARYBASE)) {			\
	    (c)->cop_hints |= HINT_ARYBASE;				\
	    if ((c) == &PL_compiling)					\
		PL_hints |= HINT_LOCALIZE_HH | HINT_ARYBASE;		\
	    (c)->cop_hints_hash						\
	       = Perl_refcounted_he_new(aTHX_ (c)->cop_hints_hash,	\
					sv_2mortal(newSVpvs("$[")),	\
					sv_2mortal(newSViv(b)));	\
	}								\
    } STMT_END

/* FIXME NATIVE_HINTS if this is changed from op_private (see perl.h)  */
#define CopHINTS_get(c)		((c)->cop_hints + 0)
#define CopHINTS_set(c, h)	STMT_START {				\
				    (c)->cop_hints = (h);		\
				} STMT_END

d109 1
d111 1
d113 1
a113 1
    I32		olddepth;
a116 1
    OP *	retop;	/* op to execute on exit from sub */
a126 1
	cx->blk_sub.retop = NULL;					\
d128 2
a129 2
	    SvREFCNT_inc_simple_void_NN(cv);				\
	    SvREFCNT_inc_simple_void_NN(cv);				\
a147 1
	cx->blk_sub.retop = NULL;					\
d150 1
a150 1
	SvREFCNT_inc_void(cx->blk_sub.dfoutgv)
d152 4
a155 1
#define POP_SAVEARRAY()						\
d160 1
d167 1
a167 1
	AvARRAY(ary) = AvALLOC(ary);					\
d177 1
a177 1
		const SSize_t fill = AvFILLp(cx->blk_sub.argarray);	\
d181 1
a181 1
		AvREIFY_only(cx->blk_sub.argarray);			\
d190 1
a190 1
	    sv = NULL;						\
d205 2
a206 2
    U8		old_in_eval;
    U16		old_op_type;
a210 2
    OP *	retop;	/* op to execute on exit from eval */
    JMPENV *	cur_top_env; /* value of PL_top_env when eval CX created */
d217 1
a217 1
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : NULL);		\
d219 2
a220 4
	cx->blk_eval.cur_text = PL_parser ? PL_parser->linestr : NULL;	\
	cx->blk_eval.cv = NULL; /* set by doeval(), as applicable */	\
	cx->blk_eval.retop = NULL;					\
	cx->blk_eval.cur_top_env = PL_top_env; 				\
d236 3
a238 3
    LOOP *	my_op;	/* My op, that contains redo, next and last ops.  */
    /* (except for non_ithreads we need to modify next_op in pp_ctl.c, hence
	why next_op is conditionally defined below.)  */
a242 1
    OP *	next_op;
a245 2
    /* (from inspection of source code) for a .. range of strings this is the
       current string.  */
a246 4
    /* (from inspection of source code) for a foreach loop this is the array
       being iterated over. For a .. range of numbers it's the current value.
       A check is often made on the SvTYPE of iterary to determine whether
       we are iterating over an array or a range. (numbers or strings)  */
a248 2
    /* (from inspection of source code) for a .. range of numbers this is the
       maximum value.  */
a250 9
/* It might be possible to squeeze this structure further. As best I can tell
   itermax and iterlval are never used at the same time, so it might be possible
   to make them into a union. However, I'm not confident that there are enough
   flag bits/NULLable pointers in this structure alone to encode which is
   active. There is, however, U8 of space free in struct block, which could be
   used. Right now it may not be worth squeezing this structure further, as it's
   the largest part of struct block, and currently struct block is 64 bytes on
   an ILP32 system, which will give good cache alignment.
*/
d265 1
a265 1
	    cx->blk_loop.itersave = NULL;
d272 1
a272 9
	    cx->blk_loop.itersave = NULL;
#endif

#ifdef USE_ITHREADS
#  define PUSHLOOP_OP_NEXT		/* No need to do anything.  */
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.my_op->op_nextop + 0)
#else
#  define PUSHLOOP_OP_NEXT		cx->blk_loop.next_op = cLOOP->op_nextop
#  define CX_LOOP_NEXTOP_GET(cx)	((cx)->blk_loop.next_op + 0)
d278 5
a282 4
	cx->blk_loop.my_op = cLOOP;					\
	PUSHLOOP_OP_NEXT;						\
	cx->blk_loop.iterlval = NULL;					\
	cx->blk_loop.iterary = NULL;					\
d289 3
a291 8
            if (SvPADMY(cx->blk_loop.itersave)) {			\
		SV ** const s_v_p = CxITERVAR(cx);			\
		sv_2mortal(*s_v_p);					\
		*s_v_p = cx->blk_loop.itersave;				\
	    }								\
	    else {							\
		SvREFCNT_dec(cx->blk_loop.itersave);			\
	    }								\
a295 10
/* given/when context */
struct block_givwhen {
	OP *leave_op;
};

#define PUSHGIVEN(cx)							\
	cx->blk_givwhen.leave_op = cLOGOP->op_other;

#define PUSHWHEN PUSHGIVEN

a297 3
    U16		blku_type;	/* what kind of context this is */
    U8		blku_gimme;	/* is this block running in list context? */
    U8		blku_spare;	/* Padding to match with struct subst */
d300 1
d304 1
a309 1
	struct block_givwhen	blku_givwhen;
d314 1
a321 1
#define blk_givwhen	cx_u.cx_blk.blk_u.blku_givwhen
d330 1
d342 1
d354 1
a359 3
    U16		sbu_type;	/* what kind of context this is */
    U8		sbu_once;	/* Actually both booleans, but U8 to matches */
    U8		sbu_rxtainted;	/* struct block */
d364 2
d403 1
a403 1
	cx->sb_rxres		= NULL,					\
d406 1
a406 2
	rxres_save(&cx->sb_rxres, rx);					\
	(void)ReREFCNT_inc(rx)
d409 1
a409 2
	rxres_free(&cx->sb_rxres);					\
	ReREFCNT_dec(cx->sb_rx)
d412 1
a417 1
#define cx_type cx_u.cx_subst.sbu_type
a426 6
#define CXt_GIVEN	7
#define CXt_WHEN	8

/* private flags for CXt_SUB and CXt_NULL */
#define CXp_MULTICALL	0x00000400	/* part of a multicall (so don't
					   tear down context on exit). */ 
d432 1
a433 3
#define CXp_FOREACH	0x00000200	/* a foreach loop */
#define CXp_FOR_DEF	0x00000400	/* foreach using $_ */
#ifdef USE_ITHREADS
a441 2
#define CxMULTICALL(c)	(((c)->cx_type & CXp_MULTICALL)			\
			 == CXp_MULTICALL)
a445 4
#define CxFOREACH(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH))	\
                         == (CXt_LOOP|CXp_FOREACH))
#define CxFOREACHDEF(c)	(((c)->cx_type & (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))\
			 == (CXt_LOOP|CXp_FOREACH|CXp_FOR_DEF))
d487 1
a487 3
#define G_DISCARD	2	/* Call FREETMPS.
				   Don't change this without consulting the
				   hash actions codes defined in hv.h */
a492 2
#define G_FAKINGEVAL  256	/* Faking an eval context for call_sv or
				   fold_constants. */
a519 2
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
d523 2
d566 1
a566 1
	PERL_SI * const prev = PL_curstackinfo->si_prev;		\
a586 73
/*
=head1 Multicall Functions

=for apidoc Ams||dMULTICALL
Declare local variables for a multicall. See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||PUSH_MULTICALL
Opening bracket for a lightweight callback.
See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||MULTICALL
Make a lightweight callback. See L<perlcall/Lightweight Callbacks>.

=for apidoc Ams||POP_MULTICALL
Closing bracket for a lightweight callback.
See L<perlcall/Lightweight Callbacks>.

=cut
*/

#define dMULTICALL \
    SV **newsp;			/* set by POPBLOCK */			\
    PERL_CONTEXT *cx;							\
    CV *multicall_cv;							\
    OP *multicall_cop;							\
    bool multicall_oldcatch; 						\
    U8 hasargs = 0		/* used by PUSHSUB */

#define PUSH_MULTICALL(the_cv) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	AV * const padlist = CvPADLIST(cv);				\
	ENTER;								\
 	multicall_oldcatch = CATCH_GET;					\
	SAVETMPS; SAVEVPTR(PL_op);					\
	CATCH_SET(TRUE);						\
	PUSHBLOCK(cx, CXt_SUB|CXp_MULTICALL, PL_stack_sp);		\
	PUSHSUB(cx);							\
	if (++CvDEPTH(cv) >= 2) {					\
	    PERL_STACK_OVERFLOW_CHECK();				\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	}								\
	SAVECOMPPAD();							\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cv = cv;						\
	multicall_cop = CvSTART(cv);					\
    } STMT_END

#define MULTICALL \
    STMT_START {							\
	PL_op = multicall_cop;						\
	CALLRUNOPS(aTHX);						\
    } STMT_END

#define POP_MULTICALL \
    STMT_START {							\
	LEAVESUB(multicall_cv);						\
	CvDEPTH(multicall_cv)--;					\
	POPBLOCK(cx,PL_curpm);						\
	CATCH_SET(multicall_oldcatch);					\
	LEAVE;								\
    } STMT_END

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a134 1
#include "mydtrace.h"
d264 1
a264 1
					newSVpvs_flags("$[", SVs_TEMP),	\
a297 4
	ENTRY_PROBE(GvENAME(CvGV(cv)),		       			\
		CopFILE((const COP *)CvSTART(cv)),			\
		CopLINE((const COP *)CvSTART(cv)));			\
									\
d345 1
a345 5
	RETURN_PROBE(GvENAME(CvGV((const CV*)cx->blk_sub.cv)),		\
		CopFILE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopLINE((COP*)CvSTART((const CV*)cx->blk_sub.cv)));	\
									\
	if (CxHASARGS(cx)) {						\
d354 1
a354 1
		CX_CURPAD_SV(cx->blk_sub, 0) = MUTABLE_SV(cx->blk_sub.argarray); \
d360 2
a361 2
	sv = MUTABLE_SV(cx->blk_sub.cv);				\
	if (sv && (CvDEPTH((const CV*)sv) = cx->blk_sub.olddepth))	\
a386 3
#define CxOLD_IN_EVAL(cx)	(0 + (cx)->blk_eval.old_in_eval)
#define CxOLD_OP_TYPE(cx)	(0 + (cx)->blk_eval.old_op_type)

d401 2
a402 2
	PL_in_eval = CxOLD_IN_EVAL(cx);					\
	optype = CxOLD_OP_TYPE(cx);					\
a421 3
    /* Eliminated in blead by change 33080, but for binary compatibility
       reasons we can't remove it from the middle of a struct in a maintenance
       release, so it gets to stay, and be set to NULL.  */
d456 4
a459 2
	cx->blk_loop.itersave = NULL;					\
	cx->blk_loop.iterdata = (idata);
d463 4
a466 2
	cx->blk_loop.itersave = NULL;					\
	cx->blk_loop.itervar = (SV**)(ivar);
a467 3
#define CxLABEL(c)	(0 + (c)->blk_loop.label)
#define CxHASARGS(c)	(0 + (c)->blk_sub.hasargs)
#define CxLVAL(c)	(0 + (c)->blk_sub.lval)
d489 10
a624 2
#define CxONCE(cx)		(0 + cx->sb_once)

d670 1
a670 1
#define CxREALEVAL(c)	(((c)->cx_type & (CXTYPEMASK|CXp_REAL))		\
d672 1
a672 1
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXTYPEMASK|CXp_TRYBLOCK))	\
d674 1
a674 1
#define CxFOREACH(c)	(((c)->cx_type & (CXTYPEMASK|CXp_FOREACH))	\
d676 1
a676 1
#define CxFOREACHDEF(c)	(((c)->cx_type & (CXTYPEMASK|CXp_FOREACH|CXp_FOR_DEF))\
a716 1
#define G_WANT		(128|1)
a859 1
	PUSHSTACKi(PERLSI_SORT);					\
a882 1
	POPSTACK;							\
a884 1
	SPAGAIN;							\
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d4 1
a4 1
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
d9 2
a10 2
 * Control ops (cops) are one of the two ops OP_NEXTSTATE and OP_DBSTATE,
 * that (loosely speaking) are separate statements.
d102 2
a103 3
	DEBUG_l(Perl_deb(aTHX_ "Setting up jumplevel %p, was %p at %s:%d\n",	\
		         (void*)&cur_env, (void*)PL_top_env,			\
		         __FILE__, __LINE__));					\
d115 2
a116 4
	DEBUG_l(Perl_deb(aTHX_ "popping jumplevel was %p, now %p at %s:%d\n",	\
		         (void*)PL_top_env, (void*)cur_env.je_prev,		\
		         __FILE__, __LINE__));					\
	assert(PL_top_env == &cur_env);					\
d142 1
a142 1
    /* label for this construct is now stored in cop_hints_hash */
d194 2
d199 2
d204 2
d222 1
d228 2
d232 1
a234 2
#define CopLABEL(c)  Perl_fetch_cop_label(aTHX_ (c)->cop_hints_hash, NULL, NULL)
#define CopLABEL_alloc(pv)	((pv)?savepv(pv):NULL)
d243 5
a247 1
#define OutCopFILE(c) CopFILE(c)
d261 4
a264 8
	    if ((c) == &PL_compiling) {					\
		SV *val = newSViv(b);					\
		(void)hv_stores(GvHV(PL_hintgv), "$[", val);		\
		mg_set(val);						\
		PL_hints |= HINT_ARYBASE;				\
	    } else {							\
		(c)->cop_hints_hash					\
		   = Perl_refcounted_he_new(aTHX_ (c)->cop_hints_hash,	\
a266 1
	    }								\
a281 2
    OP *	retop;	/* op to execute on exit from sub */
    /* Above here is the same for sub, format and eval.  */
d283 2
a284 1
    /* Above here is the same for sub and format.  */
d288 2
a290 5
};


/* format context */
struct block_format {
a291 5
    /* Above here is the same for sub, format and eval.  */
    CV *	cv;
    /* Above here is the same for sub and format.  */
    GV *	gv;
    GV *	dfoutgv;
d305 1
a305 1
	cx->cx_type |= (hasargs) ? CXp_HASARGS : 0;			\
d316 1
a316 1
	cx->blk_u16 = PL_op->op_private &				\
d322 1
a322 1
	cx->blk_u16 = 0;
d325 7
a331 6
#define PUSHFORMAT(cx, retop)						\
	cx->blk_format.cv = cv;						\
	cx->blk_format.gv = gv;						\
	cx->blk_format.retop = (retop);					\
	cx->blk_format.dfoutgv = PL_defoutgv;				\
	SvREFCNT_inc_void(cx->blk_format.dfoutgv)
d381 2
a382 2
	setdefout(cx->blk_format.dfoutgv);				\
	SvREFCNT_dec(cx->blk_format.dfoutgv);
d386 2
a387 2
    OP *	retop;	/* op to execute on exit from eval */
    /* Above here is the same for sub, format and eval.  */
d392 1
d396 2
a397 6
/* If we ever need more than 512 op types, change the shift from 7.
   blku_gimme is actually also only 2 bits, so could be merged with something.
*/

#define CxOLD_IN_EVAL(cx)	(((cx)->blk_u16) & 0x7F)
#define CxOLD_OP_TYPE(cx)	(((cx)->blk_u16) >> 7)
d399 1
a399 1
#define PUSHEVAL(cx,n)							\
d401 2
a402 3
	assert(!(PL_in_eval & ~0x7F));					\
	assert(!(PL_op->op_type & ~0x1FF));				\
	cx->blk_u16 = (PL_in_eval & 0x7F) | ((U16)PL_op->op_type << 7);	\
d422 1
d428 2
a429 3
    PAD		*oldcomppad; /* Also used for the GV, if targoffset is 0 */
    /* This is also accesible via cx->blk_loop.my_op->op_targ */
    PADOFFSET	targoffset;
d434 16
a449 14
    union {
	struct { /* valid if type is LOOP_FOR or LOOP_PLAIN (but {NULL,0})*/
	    AV * ary; /* use the stack if this is NULL */
	    IV ix;
	} ary;
	struct { /* valid if type is LOOP_LAZYIV */
	    IV cur;
	    IV end;
	} lazyiv;
	struct { /* valid if type if LOOP_LAZYSV */
	    SV * cur;
	    SV * end; /* maxiumum value (or minimum in reverse) */
	} lazysv;
    } state_u;
d451 9
d463 5
a467 4
	((c)->blk_loop.oldcomppad					\
	 ? (CxPADLOOP(c) 						\
	    ? &CX_CURPAD_SV( (c)->blk_loop, (c)->blk_loop.targoffset )	\
	    : &GvSV((GV*)(c)->blk_loop.oldcomppad))			\
d469 4
a472 5
#  define CX_ITERDATA_SET(cx,idata,o)					\
	if ((cx->blk_loop.targoffset = (o)))				\
	    CX_CURPAD_SAVE(cx->blk_loop);				\
	else								\
	    cx->blk_loop.oldcomppad = (idata);
d475 2
a476 1
#  define CX_ITERDATA_SET(cx,ivar,o)					\
d479 3
a481 3
#define CxLABEL(c)	(0 + CopLABEL((c)->blk_oldcop))
#define CxHASARGS(c)	(((c)->cx_type & CXp_HASARGS) == CXp_HASARGS)
#define CxLVAL(c)	(0 + (c)->blk_u16)
d491 2
a492 9
#define PUSHLOOP_PLAIN(cx, s)						\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.my_op = cLOOP;					\
	PUSHLOOP_OP_NEXT;						\
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	CX_ITERDATA_SET(cx, NULL, 0);

#define PUSHLOOP_FOR(cx, dat, s, offset)				\
d496 4
a499 3
	cx->blk_loop.state_u.ary.ary = NULL;				\
	cx->blk_loop.state_u.ary.ix = 0;				\
	CX_ITERDATA_SET(cx, dat, offset);
d502 3
a504 6
	if (CxTYPE(cx) == CXt_LOOP_LAZYSV) {				\
	    SvREFCNT_dec(cx->blk_loop.state_u.lazysv.cur);		\
	    SvREFCNT_dec(cx->blk_loop.state_u.lazysv.end);		\
	}								\
	if (CxTYPE(cx) == CXt_LOOP_FOR)					\
	    SvREFCNT_dec(cx->blk_loop.state_u.ary.ary);
d518 1
a518 1
    U8		blku_type;	/* what kind of context this is */
d520 1
a520 1
    U16		blku_u16;	/* used by block_sub and block_eval (so far) */
a528 1
	struct block_format	blku_format;
a539 1
#define blk_u16		cx_u.cx_blk.blku_u16
a540 1
#define blk_format	cx_u.cx_blk.blk_u.blku_format
d579 3
a581 3
    U8		sbu_type;	/* what kind of context this is */
    U8		sbu_rflags;
    U16		sbu_rxtainted;	/* matches struct block */
d584 1
d610 1
a610 2
#ifdef PERL_CORE
#  define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],		\
d615 1
d625 1
a625 1
	cx->cx_type		= CXt_SUBST | (once ? CXp_ONCE : 0);	\
d629 3
a631 1
#  define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
a633 3
#endif

#define CxONCE(cx)		((cx)->cx_type & CXp_ONCE)
d643 1
a643 3
/* If you re-order these, there is also an array of uppercase names in perl.h
   and a static array of context names in pp_ctl.c  */
#define CXTYPEMASK	0xf
d645 12
a656 27
#define CXt_WHEN	1
#define CXt_BLOCK	2
/* When micro-optimising :-) keep GIVEN next to the LOOPs, as these 5 share a
   jump table in pp_ctl.c
   The first 4 don't have a 'case' in at least one switch statement in pp_ctl.c
*/
#define CXt_GIVEN	3
/* This is first so that CXt_LOOP_FOR|CXt_LOOP_LAZYIV is CXt_LOOP_LAZYIV */
#define CXt_LOOP_FOR	4
#define CXt_LOOP_PLAIN	5
#define CXt_LOOP_LAZYSV	6
#define CXt_LOOP_LAZYIV	7
#define CXt_SUB		8
#define CXt_FORMAT      9
#define CXt_EVAL       10
#define CXt_SUBST      11
/* SUBST doesn't feature in all switch statements.  */

/* private flags for CXt_SUB and CXt_NULL
   However, this is checked in many places which do not check the type, so
   this bit needs to be kept clear for most everything else. For reasons I
   haven't investigated, it can coexist with CXp_FOR_DEF */
#define CXp_MULTICALL	0x10	/* part of a multicall (so don't
				   tear down context on exit). */ 

/* private flags for CXt_SUB and CXt_FORMAT */
#define CXp_HASARGS	0x20
d659 2
a660 2
#define CXp_REAL	0x20	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x40	/* eval{}, not eval'' or similar */
d663 2
a664 1
#define CXp_FOR_DEF	0x10	/* foreach using $_ */
d666 5
a670 1
#  define CxPADLOOP(c)	((c)->blk_loop.targoffset)
a672 3
/* private flags for CXt_SUBST */
#define CXp_ONCE	0x10	/* What was sbu_once in struct subst */

a673 1
#define CxTYPE_is_LOOP(c)	(((c)->cx_type & 0xC) == 0x4)
d680 4
a683 3
#define CxFOREACH(c)	(CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN)
#define CxFOREACHDEF(c)	((CxTYPE_is_LOOP(c) && CxTYPE(c) != CXt_LOOP_PLAIN) \
			 && ((c)->cx_type & CXp_FOR_DEF))
d720 4
a723 4
#define G_SCALAR	2
#define G_ARRAY		3
#define G_VOID		1
#define G_WANT		3
d726 1
a726 1
#define G_DISCARD	4	/* Call FREETMPS.
d729 5
a733 5
#define G_EVAL		8	/* Assume eval {} around subroutine call. */
#define G_NOARGS       16	/* Don't construct a @@_ array. */
#define G_KEEPERR      32	/* Append errors to $@@, don't overwrite it */
#define G_NODEBUG      64	/* Disable debugging at toplevel.  */
#define G_METHOD      128       /* Calling method. */
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d17 2
a18 3
 * Note that there is a PL_start_env initialized when perl starts, and
 * PL_top_env points to this initially, so PL_top_env should always be
 * non-null.
d20 2
a21 2
 * Existence of a non-null PL_top_env->je_prev implies it is valid to call
 * longjmp() at that runlevel (we make sure PL_start_env.je_prev is always
d94 2
a95 3
 * http://perl5.git.perl.org/perl.git/commit/312caa8e97f1c7ee342a9895c2f0e749625b4929
 * http://perl5.git.perl.org/perl.git/commit/14dd3ad8c9bf82cf09798a22cc89a9862dfd6d1a                                        
 *  
d102 3
a104 5
	DEBUG_l({							\
	    int i = 0; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_PUSH level=%d at %s:%d\n",		\
		         i,  __FILE__, __LINE__);})			\
d116 3
a118 5
	DEBUG_l({							\
	    int i = -1; JMPENV *p = PL_top_env;				\
	    while (p) { i++; p = p->je_prev; }				\
	    Perl_deb(aTHX_ "JUMPENV_POP level=%d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
a124 5
	DEBUG_l({						\
	    int i = -1; JMPENV *p = PL_top_env;			\
	    while (p) { i++; p = p->je_prev; }			\
	    Perl_deb(aTHX_ "JUMPENV_JUMP(%d) level=%d at %s:%d\n", \
		         (int)v, i, __FILE__, __LINE__);})	\
d130 1
a130 1
	PerlIO_printf(PerlIO_stderr(), "panic: top_env, v=%d\n", (int)v); \
d135 1
a135 173
#define CATCH_SET(v) \
    STMT_START {							\
	DEBUG_l(							\
	    Perl_deb(aTHX_						\
		"JUMPLEVEL set catch %d => %d (for %p) at %s:%d\n",	\
		 PL_top_env->je_mustcatch, v, (void*)PL_top_env,	\
		 __FILE__, __LINE__);)					\
	PL_top_env->je_mustcatch = (v);					\
    } STMT_END

/*
=head1 COP Hint Hashes
*/

typedef struct refcounted_he COPHH;

#define COPHH_KEY_UTF8 REFCOUNTED_HE_KEY_UTF8

/*
=for apidoc Amx|SV *|cophh_fetch_pvn|const COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the entry in the cop hints hash I<cophh> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cophh_fetch_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, keypv, keylen, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_fetch_pvs(cophh, key, flags) \
    Perl_refcounted_he_fetch_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_fetch_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_pv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|SV *|cophh_fetch_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_fetch_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_fetch_sv(aTHX_ cophh, key, hash, flags)

/*
=for apidoc Amx|HV *|cophh_2hv|const COPHH *cophh|U32 flags

Generates and returns a standard Perl hash representing the full set of
key/value pairs in the cop hints hash I<cophh>.  I<flags> is currently
unused and must be zero.

=cut
*/

#define cophh_2hv(cophh, flags) \
    Perl_refcounted_he_chain_2hv(aTHX_ cophh, flags)

/*
=for apidoc Amx|COPHH *|cophh_copy|COPHH *cophh

Make and return a complete copy of the cop hints hash I<cophh>.

=cut
*/

#define cophh_copy(cophh) Perl_refcounted_he_inc(aTHX_ cophh)

/*
=for apidoc Amx|void|cophh_free|COPHH *cophh

Discard the cop hints hash I<cophh>, freeing all resources associated
with it.

=cut
*/

#define cophh_free(cophh) Perl_refcounted_he_free(aTHX_ cophh)

/*
=for apidoc Amx|COPHH *|cophh_new_empty

Generate and return a fresh cop hints hash containing no entries.

=cut
*/

#define cophh_new_empty() ((COPHH *)NULL)

/*
=for apidoc Amx|COPHH *|cophh_store_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|SV *value|U32 flags

Stores a value, associated with a key, in the cop hints hash I<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

I<value> is the scalar value to store for this key.  I<value> is copied
by this function, which thus does not take ownership of any reference
to it, and later changes to the scalar will not be reflected in the
value visible in the cop hints hash.  Complex types of scalar will not
be stored with referential integrity, but will be coerced to strings.

=cut
*/

#define cophh_store_pvn(cophh, keypv, keylen, hash, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pvs|const COPHH *cophh|const char *key|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_store_pvs(cophh, key, value, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_pv|const COPHH *cophh|const char *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_store_pv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_store_sv|const COPHH *cophh|SV *key|U32 hash|SV *value|U32 flags

Like L</cophh_store_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/
a136 60
#define cophh_store_sv(cophh, key, hash, value, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, value, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvn|COPHH *cophh|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Delete a key and its associated value from the cop hints hash I<cophh>,
and returns the modified hash.  The returned hash pointer is in general
not the same as the hash pointer that was passed in.  The input hash is
consumed by the function, and the pointer to it must not be subsequently
used.  Use L</cophh_copy> if you need both hashes.

The key is specified by I<keypv> and I<keylen>.  If I<flags> has the
C<COPHH_KEY_UTF8> bit set, the key octets are interpreted as UTF-8,
otherwise they are interpreted as Latin-1.  I<hash> is a precomputed
hash of the key string, or zero if it has not been precomputed.

=cut
*/

#define cophh_delete_pvn(cophh, keypv, keylen, hash, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, keypv, keylen, hash, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pvs|const COPHH *cophh|const char *key|U32 flags

Like L</cophh_delete_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cophh_delete_pvs(cophh, key, flags) \
    Perl_refcounted_he_new_pvn(aTHX_ cophh, STR_WITH_LEN(key), 0, \
	(SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_pv|const COPHH *cophh|const char *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a nul-terminated string instead of
a string/length pair.

=cut
*/

#define cophh_delete_pv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_pv(aTHX_ cophh, key, hash, (SV *)NULL, flags)

/*
=for apidoc Amx|COPHH *|cophh_delete_sv|const COPHH *cophh|SV *key|U32 hash|U32 flags

Like L</cophh_delete_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cophh_delete_sv(cophh, key, hash, flags) \
    Perl_refcounted_he_new_sv(aTHX_ cophh, key, hash, (SV *)NULL, flags)
a148 1
    I32         cop_stashlen;	/* negative for UTF8 */
d159 1
a159 1
    COPHH *	cop_hints_hash;
d188 1
a188 2
#    define CopSTASHPV_set(c,pv,n)	((c)->cop_stashpv = \
					   ((pv) ? savepvn(pv,n) : NULL))
d190 1
a190 2
#    define CopSTASHPV_set(c,pv,n)	((c)->cop_stashpv = (pv) \
					    ? savesharedpvn(pv,n) : NULL)
d193 3
a195 19
#  define CopSTASH_len_set(c,n)	((c)->cop_stashlen = (n))
#  define CopSTASH_len(c)	((c)->cop_stashlen)

#  define CopSTASH(c)          (CopSTASHPV(c)                                 \
                                ? gv_stashpvn(CopSTASHPV(c),		  \
				    CopSTASH_len(c) < 0			  \
					? -CopSTASH_len(c)		  \
					:  CopSTASH_len(c),		  \
                                    GV_ADD|SVf_UTF8*(CopSTASH_len(c) < 0) \
                                  )					  \
                                 : NULL)
#  define CopSTASH_set(c,hv)   (CopSTASHPV_set(c,			\
				    (hv) ? HvNAME_get(hv) : NULL,	\
				    (hv) ? HvNAMELEN(hv)  : 0),		\
				CopSTASH_len_set(c,			\
				    (hv) ? HvNAMEUTF8(hv)		\
					    ? -HvNAMELEN(hv)		\
					    :  HvNAMELEN(hv)		\
					 : 0))
d228 1
a228 77

#define CopHINTHASH_get(c)	((COPHH*)((c)->cop_hints_hash))
#define CopHINTHASH_set(c,h)	((c)->cop_hints_hash = (h))

/*
=head1 COP Hint Reading
*/

/*
=for apidoc Am|SV *|cop_hints_fetch_pvn|const COP *cop|const char *keypv|STRLEN keylen|U32 hash|U32 flags

Look up the hint entry in the cop I<cop> with the key specified by
I<keypv> and I<keylen>.  If I<flags> has the C<COPHH_KEY_UTF8> bit set,
the key octets are interpreted as UTF-8, otherwise they are interpreted
as Latin-1.  I<hash> is a precomputed hash of the key string, or zero if
it has not been precomputed.  Returns a mortal scalar copy of the value
associated with the key, or C<&PL_sv_placeholder> if there is no value
associated with the key.

=cut
*/

#define cop_hints_fetch_pvn(cop, keypv, keylen, hash, flags) \
    cophh_fetch_pvn(CopHINTHASH_get(cop), keypv, keylen, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pvs|const COP *cop|const char *key|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a literal string instead of a
string/length pair, and no precomputed hash.

=cut
*/

#define cop_hints_fetch_pvs(cop, key, flags) \
    cophh_fetch_pvs(CopHINTHASH_get(cop), key, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_pv|const COP *cop|const char *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a nul-terminated string instead
of a string/length pair.

=cut
*/

#define cop_hints_fetch_pv(cop, key, hash, flags) \
    cophh_fetch_pv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|SV *|cop_hints_fetch_sv|const COP *cop|SV *key|U32 hash|U32 flags

Like L</cop_hints_fetch_pvn>, but takes a Perl scalar instead of a
string/length pair.

=cut
*/

#define cop_hints_fetch_sv(cop, key, hash, flags) \
    cophh_fetch_sv(CopHINTHASH_get(cop), key, hash, flags)

/*
=for apidoc Am|HV *|cop_hints_2hv|const COP *cop|U32 flags

Generates and returns a standard Perl hash representing the full set of
hint entries in the cop I<cop>.  I<flags> is currently unused and must
be zero.

=cut
*/

#define cop_hints_2hv(cop, flags) \
    cophh_2hv(CopHINTHASH_get(cop), flags)

#define CopLABEL(c)  Perl_cop_fetch_label(aTHX_ (c), NULL, NULL)
#define CopLABEL_len(c,len)  Perl_cop_fetch_label(aTHX_ (c), len, NULL)
#define CopLABEL_len_flags(c,len,flags)  Perl_cop_fetch_label(aTHX_ (c), len, flags)
d240 26
d306 1
a306 2
		CopLINE((const COP *)CvSTART(cv)),			\
		CopSTASHPV((const COP *)CvSTART(cv)));			\
a319 8
    {									\
	/* If the context is indeterminate, then only the lvalue */	\
	/* flags that the caller also has are applicable.        */	\
	U8 phlags =							\
	   (PL_op->op_flags & OPf_WANT)					\
	       ? OPpENTERSUB_LVAL_MASK					\
	       : !(PL_op->op_private & OPpENTERSUB_LVAL_MASK)		\
	           ? 0 : Perl_was_lvalue_sub(aTHX);			\
d322 1
a322 2
	                  (phlags|OPpDEREF);				\
    }
d356 1
a356 2
		CopLINE((COP*)CvSTART((const CV*)cx->blk_sub.cv)),	\
		CopSTASHPV((COP*)CvSTART((const CV*)cx->blk_sub.cv)));	\
d432 10
a441 5
    union {	/* different ways of locating the iteration variable */
	SV      **svp;
	GV      *gv;
	PAD     *oldcomppad; /* only used in ITHREADS */
    } itervar_u;
d459 11
a469 2
#  define CxITERVAR_PADSV(c) \
	&CX_CURPAD_SV( (c)->blk_loop.itervar_u, (c)->blk_loop.my_op->op_targ)
d471 3
a473 1
#  define CxITERVAR_PADSV(c) ((c)->blk_loop.itervar_u.svp)
a474 8

#define CxITERVAR(c)							\
	((c)->blk_loop.itervar_u.oldcomppad				\
	 ? (CxPADLOOP(c) 						\
	    ? CxITERVAR_PADSV(c)					\
	    : &GvSV((c)->blk_loop.itervar_u.gv))			\
	 : (SV**)NULL)

a475 2
#define CxLABEL_len(c,len)	(0 + CopLABEL_len((c)->blk_oldcop, len))
#define CxLABEL_len_flags(c,len,flags)	(0 + CopLABEL_len_flags((c)->blk_oldcop, len, flags))
d479 8
d490 1
d493 1
a493 1
	cx->blk_loop.itervar_u.svp = NULL;
d495 1
a495 1
#define PUSHLOOP_FOR(cx, ivar, s)					\
d498 1
d501 1
a501 1
	cx->blk_loop.itervar_u.svp = (SV**)(ivar);
a552 10
#define DEBUG_CX(action)						\
    DEBUG_l(								\
	Perl_deb(aTHX_ "CX %ld %s %s (scope %ld,%ld) at %s:%d\n",	\
		    (long)cxstack_ix,					\
		    action,						\
		    PL_block_type[CxTYPE(&cxstack[cxstack_ix])],	\
		    (long)PL_scopestack_ix,				\
		    (long)(cxstack[cxstack_ix].blk_oldscopesp),		\
		    __FILE__, __LINE__));

d562 2
a563 1
	DEBUG_CX("PUSH");
d566 1
a566 3
#define POPBLOCK(cx,pm)							\
	DEBUG_CX("POP");						\
	cx = &cxstack[cxstack_ix--],					\
d572 4
a575 1
	gimme		 = cx->blk_gimme;
d578 1
a578 3
#define TOPBLOCK(cx)							\
	DEBUG_CX("TOP");						\
	cx  = &cxstack[cxstack_ix],					\
d582 2
a583 1
	PL_curpm         = cx->blk_oldpm;
d606 1
d689 3
a691 1
#define CxPADLOOP(c)	((c)->blk_loop.my_op->op_targ)
d754 1
a754 1
#define G_KEEPERR      32	/* Warn for errors, don't overwrite $@@ */
a758 5
#define G_UNDEF_FILL  512	/* Fill the stack with &PL_sv_undef
				   A special case for UNSHIFT in
				   Perl_magic_methcall().  */
#define G_WRITING_TO_STDERR 1024 /* Perl_write_to_stderr() is calling
				    Perl_magic_methcall().  */
a811 5
	DEBUG_l({							\
	    int i = 0; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "push STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
a832 5
	DEBUG_l({							\
	    int i = -1; PERL_SI *p = PL_curstackinfo;			\
	    while (p) { i++; p = p->si_prev; }				\
	    Perl_deb(aTHX_ "pop  STACKINFO %d at %s:%d\n",		\
		         i, __FILE__, __LINE__);})			\
d857 1
a857 1
Declare local variables for a multicall. See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d861 1
a861 1
See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d864 1
a864 1
Make a lightweight callback. See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d868 1
a868 1
See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d911 2
a912 2
	if (! --CvDEPTH(multicall_cv))					\
	    LEAVESUB(multicall_cv);					\
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d390 1
a390 2
    PADOFFSET	cop_stashoff;	/* offset into PL_stashpad, for the
				   package the line was compiled in */
d392 1
d423 2
a424 1
#  define CopFILEAVx(c)		(assert_(CopFILE(c)) \
d426 4
a430 4
#  define CopSTASH(c)           PL_stashpad[(c)->cop_stashoff]
#  define CopSTASH_set(c,hv)	((c)->cop_stashoff = (hv)		\
				    ? alloccopstash(hv)			\
				    : 0)
d432 29
d463 1
d482 5
a490 5
#define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME_get(CopSTASH(c)) : NULL)
   /* cop_stash is not refcounted */
#define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))

d578 1
d616 1
a616 3
	ENTRY_PROBE(CvNAMED(cv)						\
			? HEK_KEY(CvNAME_HEK(cv))			\
			: GvENAME(CvGV(cv)),	       			\
d631 3
a633 1
#define PUSHSUB_GET_LVALUE_MASK(func) \
d636 1
a636 1
	(								\
d640 1
a640 6
	           ? 0 : (U8)func(aTHX)					\
	)

#define PUSHSUB(cx)							\
    {									\
	U8 phlags = PUSHSUB_GET_LVALUE_MASK(Perl_was_lvalue_sub);	\
a656 2
	if (!CvDEPTH(cv)) SvREFCNT_inc_simple_void_NN(cv);		\
	CvDEPTH(cv)++;							\
d676 1
a676 3
	RETURN_PROBE(CvNAMED(cx->blk_sub.cv)				\
			? HEK_KEY(CvNAME_HEK(cx->blk_sub.cv))		\
			: GvENAME(CvGV(cx->blk_sub.cv)),		\
d686 1
a686 1
		SvREFCNT_dec_NN(cx->blk_sub.argarray);			\
d703 2
a704 1
	SvREFCNT_dec(sv);						\
d709 1
a709 4
	CvDEPTH(cx->blk_format.cv)--;					\
	if (!CvDEPTH(cx->blk_format.cv))				\
	    SvREFCNT_dec_NN(cx->blk_format.cv);				\
	SvREFCNT_dec_NN(cx->blk_format.dfoutgv);
a746 2
	if (cx->blk_eval.cur_text && SvSCREAM(cx->blk_eval.cur_text))	\
	    SvREFCNT_dec_NN(cx->blk_eval.cur_text);			\
d812 2
a813 2
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.cur);		\
	    SvREFCNT_dec_NN(cx->blk_loop.state_u.lazysv.end);		\
a996 2
#define CXp_SUB_RE	0x40    /* code called within regex, i.e. (?{}) */
#define CXp_SUB_RE_FAKE	0x80    /* fake sub CX for (?{}) in current scope */
a1076 1
#define G_RE_REPARSING 0x800     /* compiling a run-time /(?{..})/ */
a1083 1
#define EVAL_RE_REPARSING 0x10	/* eval_sv() called with G_RE_REPARSING */
d1162 2
a1163 1
	    Perl_croak_popstack();					\
a1209 6
    PUSH_MULTICALL_FLAGS(the_cv, 0)

/* Like PUSH_MULTICALL, but allows you to specify extra flags
 * for the CX stack entry (this isn't part of the public API) */

#define PUSH_MULTICALL_FLAGS(the_cv, flags) \
d1213 1
a1213 1
	PADLIST * const padlist = CvPADLIST(cv);			\
d1219 1
a1219 1
	PUSHBLOCK(cx, (CXt_SUB|CXp_MULTICALL|flags), PL_stack_sp);	\
d1221 1
a1221 3
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2) {						\
d1239 2
a1240 4
	cx = &cxstack[cxstack_ix];					\
        if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
a1247 26
/* Change the CV of an already-pushed MULTICALL CxSUB block.
 * (this isn't part of the public API) */

#define CHANGE_MULTICALL_FLAGS(the_cv, flags) \
    STMT_START {							\
	CV * const _nOnclAshIngNamE_ = the_cv;				\
	CV * const cv = _nOnclAshIngNamE_;				\
	PADLIST * const padlist = CvPADLIST(cv);			\
	cx = &cxstack[cxstack_ix];					\
	assert(cx->cx_type & CXp_MULTICALL);				\
	if (! ((CvDEPTH(multicall_cv) = cx->blk_sub.olddepth)) ) {	\
		LEAVESUB(multicall_cv);					\
	}								\
	cx->cx_type = (CXt_SUB|CXp_MULTICALL|flags);                    \
	PUSHSUB(cx);							\
        if (!(flags & CXp_SUB_RE_FAKE))                                 \
            CvDEPTH(cv)++;						\
	if (CvDEPTH(cv) >= 2) {						\
	    PERL_STACK_OVERFLOW_CHECK();				\
	    Perl_pad_push(aTHX_ padlist, CvDEPTH(cv));			\
	}								\
	SAVECOMPPAD();							\
	PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));			\
	multicall_cv = cv;						\
	multicall_cop = CvSTART(cv);					\
    } STMT_END
d1252 1
a1252 1
 * indent-tabs-mode: nil
d1255 1
a1255 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d34 1
a34 1
    Sigjmp_buf		je_buf;		/* uninit if je_prev is NULL */
d41 8
d61 1
a61 3
	PERL_POISON_EXPR(PoisonNew(&PL_start_env, 1, JMPENV));\
	PL_top_env = &PL_start_env;		\
	PL_start_env.je_prev = NULL;		\
d64 1
d110 1
d112 1
d136 1
d413 1
a413 1
#    define CopFILE_setn(c,pv,l)  ((c)->cop_file = savepvn((pv),(l)))
d447 2
a448 2
#  define CopFILE(c)		(CopFILEGV(c) \
				    ? GvNAME(CopFILEGV(c))+2 : NULL)
a650 1
	const I32 olddepth = cx->blk_sub.olddepth;			\
d674 1
a674 2
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (sv && (CvDEPTH((const CV*)sv) = olddepth))			\
d684 3
a686 6
    STMT_START {							\
	CV * const cv = cx->blk_format.cv;				\
	GV * const dfuot = cx->blk_format.dfoutgv;			\
	setdefout(dfuot);						\
	LEAVE_SCOPE(PL_scopestack[cx->blk_oldscopesp-1]);		\
	if (!--CvDEPTH(cv))						\
d688 1
a688 2
	SvREFCNT_dec_NN(dfuot);						\
    } STMT_END
a1060 1
#define G_METHOD_NAMED 4096	/* calling named method, eg without :: or ' */
d1169 1
a1169 1
Declare local variables for a multicall.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.
d1176 1
a1176 1
Make a lightweight callback.  See L<perlcall/LIGHTWEIGHT CALLBACKS>.
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d10 1
a10 1
 * that (loosely speaking) are statement separators.
a36 1
    U16                 je_old_delaymagic; /* saved PL_delaymagic */
a57 1
	PL_start_env.je_old_delaymagic = 0;	\
a105 1
	cur_env.je_old_delaymagic = PL_delaymagic;			\
a116 1
	PL_delaymagic = cur_env.je_old_delaymagic;			\
d157 2
a158 2
Look up the entry in the cop hints hash C<cophh> with the key specified by
C<keypv> and C<keylen>.  If C<flags> has the C<COPHH_KEY_UTF8> bit set,
d160 1
a160 1
as Latin-1.  C<hash> is a precomputed hash of the key string, or zero if
d174 2
a175 2
Like L</cophh_fetch_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.
d211 1
a211 1
key/value pairs in the cop hints hash C<cophh>.  C<flags> is currently
d223 1
a223 1
Make and return a complete copy of the cop hints hash C<cophh>.
d233 1
a233 1
Discard the cop hints hash C<cophh>, freeing all resources associated
d254 1
a254 1
Stores a value, associated with a key, in the cop hints hash C<cophh>,
d260 1
a260 1
The key is specified by C<keypv> and C<keylen>.  If C<flags> has the
d262 1
a262 1
otherwise they are interpreted as Latin-1.  C<hash> is a precomputed
d265 1
a265 1
C<value> is the scalar value to store for this key.  C<value> is copied
d280 2
a281 2
Like L</cophh_store_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.
d316 1
a316 1
Delete a key and its associated value from the cop hints hash C<cophh>,
d322 1
a322 1
The key is specified by C<keypv> and C<keylen>.  If C<flags> has the
d324 1
a324 1
otherwise they are interpreted as Latin-1.  C<hash> is a precomputed
d337 2
a338 2
Like L</cophh_delete_pvn>, but takes a C<NUL>-terminated literal string instead
of a string/length pair, and no precomputed hash.
d460 2
a461 2
Look up the hint entry in the cop C<cop> with the key specified by
C<keypv> and C<keylen>.  If C<flags> has the C<COPHH_KEY_UTF8> bit set,
d463 1
a463 1
as Latin-1.  C<hash> is a precomputed hash of the key string, or zero if
d477 2
a478 2
Like L</cop_hints_fetch_pvn>, but takes a C<NUL>-terminated literal string
instead of a string/length pair, and no precomputed hash.
d514 1
a514 1
hint entries in the cop C<cop>.  C<flags> is currently unused and must
a549 1
    PAD		*prevcomppad; /* the caller's PL_comppad */
d552 2
d555 1
a555 1
    AV  	*savearray;
a562 1
    PAD		*prevcomppad; /* the caller's PL_comppad */
a568 21
/* return a pointer to the current context */

#define CX_CUR() (&cxstack[cxstack_ix])

/* free all savestack items back to the watermark of the specified context */

#define CX_LEAVE_SCOPE(cx) LEAVE_SCOPE(cx->blk_oldsaveix)

#ifdef DEBUGGING
/* on debugging builds, poison cx afterwards so we know no code
 * uses it - because after doing cxstack_ix--, any ties, exceptions etc
 * may overwrite the current stack frame */
#  define CX_POP(cx)                                                   \
        assert(CX_CUR() == cx);                                        \
        cxstack_ix--;                                                  \
        cx = NULL;
#else
#  define CX_POP(cx) cxstack_ix--;
#endif


d570 2
a571 2
 * The context frame holds a reference to the CV so that it can't be
 * freed while we're executing it */
d573 17
d591 1
a591 1
#define CX_PUSHSUB_GET_LVALUE_MASK(func) \
d601 24
a624 2
/* Restore old @@_ */
#define CX_POP_SAVEARRAY(cx)						\
d626 1
a626 1
        AV *av = GvAV(PL_defgv);                                        \
a627 2
        cx->blk_sub.savearray = NULL;                                   \
        SvREFCNT_dec(av);	        				\
d639 46
d704 24
d730 1
d733 3
a735 2
	SV      **svp; /* for lexicals: address of pad slot */
	GV      *gv;   /* for package vars */
a736 1
    SV          *itersave; /* the original iteration var */
d738 3
a740 3
	struct { /* CXt_LOOP_ARY, C<for (@@ary)>  */
	    AV *ary; /* array being iterated over */
	    IV  ix;   /* index relative to base of array */
d742 1
a742 5
	struct { /* CXt_LOOP_LIST, C<for (list)> */
	    I32 basesp; /* first element of list on stack */
	    IV  ix;      /* index relative to basesp */
	} stack;
	struct { /* CXt_LOOP_LAZYIV, C<for (1..9)> */
d746 1
a746 1
	struct { /* CXt_LOOP_LAZYSV C<for ('a'..'z')> */
d751 2
d754 4
a757 1
    PAD *oldcomppad; /* needed to map itervar_u.svp during thread clone */
a758 1
};
d760 6
a765 6
#define CxITERVAR(c)                                    \
        (CxPADLOOP(c)                                   \
            ? (c)->blk_loop.itervar_u.svp               \
            : ((c)->cx_type & CXp_FOR_GV)               \
                ? &GvSV((c)->blk_loop.itervar_u.gv)     \
                : (SV **)&(c)->blk_loop.itervar_u.gv)
d771 1
d773 21
a793 14
/* CxLVAL(): the lval flags of the call site: the relevant flag bits from
 * the op_private field of the calling pp_entersub (or its caller's caller
 * if the caller's lvalue context isn't known):
 *  OPpLVAL_INTRO:  sub used in lvalue context, e.g. f() = 1;
 *  OPpENTERSUB_INARGS (in conjunction with OPpLVAL_INTRO): the
 *      function is being used as a sub arg or as a referent, e.g.
 *      g(...,f(),...)  or $r = \f()
 *  OPpDEREF: 2-bit mask indicating e.g. f()->[0].
 *  Note the contrast with CvLVALUE(), which is a property of the sub
 *  rather than the call site.
 */
#define CxLVAL(c)	(0 + ((c)->blk_u16 & 0xff))


a797 1
        SV *defsv_save; /* the original $_ */
d800 2
d803 1
d810 2
a811 3
    I32		blku_oldsaveix; /* saved PL_savestack_ix */
    /* all the fields above must be aligned with same-sized fields as sbu */
    I32		blku_oldsp;	/* current sp floor: where nextstate pops to */
d813 1
a813 1
    COP *	blku_oldcop;	/* old curcop pointer */
a814 2
    SSize_t     blku_old_tmpsfloor;     /* saved PL_tmps_floor */
    I32		blku_oldscopesp;	/* scope stack index */
a830 2
#define blk_oldsaveix   cx_u.cx_blk.blku_oldsaveix
#define blk_old_tmpsfloor cx_u.cx_blk.blku_old_tmpsfloor
d837 1
a837 1
#define CX_DEBUG(cx, action)						\
d839 1
a839 1
	Perl_deb(aTHX_ "CX %ld %s %s (scope %ld,%ld) (save %ld,%ld) at %s:%d\n",\
d842 1
a842 1
		    PL_block_type[CxTYPE(cx)],	                        \
d844 1
a844 3
		    (long)(cx->blk_oldscopesp),		                \
		    (long)PL_savestack_ix,				\
		    (long)(cx->blk_oldsaveix),                          \
d847 30
a876 1

d880 1
a880 1
    U8		sbu_type;	/* same as blku_type */
d882 4
a885 5
    U16		sbu_rxtainted;
    I32		sbu_oldsaveix; /* same as blku_oldsaveix */
    /* all the fields above must be aligned with same-sized fields as blk_u */
    SSize_t	sbu_iters;
    SSize_t	sbu_maxiters;
d898 1
d910 1
a910 2
#  define CX_PUSHSUBST(cx) CXINC, cx = CX_CUR(),		        \
	cx->blk_oldsaveix = oldsave,				        \
d914 1
d926 1
a926 2
	(void)ReREFCNT_inc(rx);						\
        SvREFCNT_inc_void_NN(targ)
d928 1
a928 4
#  define CX_POPSUBST(cx) \
    STMT_START {							\
        REGEXP *re;                                                     \
        assert(CxTYPE(cx) == CXt_SUBST);                                \
d930 1
a930 5
	re = cx->sb_rx;                                                 \
	cx->sb_rx = NULL;                                               \
	ReREFCNT_dec(re);                                               \
        SvREFCNT_dec_NN(cx->sb_targ);                                   \
    } STMT_END
d946 1
a946 1
#define CXt_NULL	0 /* currently only used for sort BLOCK */
d954 10
d965 6
a970 13
/* be careful of the ordering of these five. Macros like CxTYPE_is_LOOP,
 * CxFOREACH compare ranges */
#define CXt_LOOP_ARY	4 /* for (@@ary)     { ...; } */
#define CXt_LOOP_LAZYSV	5 /* for ('a'..'z') { ...; } */
#define CXt_LOOP_LAZYIV	6 /* for (1..9)     { ...; } */
#define CXt_LOOP_LIST	7 /* for (1,2,3)    { ...; } */
#define CXt_LOOP_PLAIN	8 /* while (...)    { ...; }
                             or plain block { ...; } */
#define CXt_SUB		9
#define CXt_FORMAT     10
#define CXt_EVAL       11
#define CXt_SUBST      12
/* SUBST doesn't feature in all switch statements.  */
a972 2
#define CXp_MULTICALL	0x10	/* part of a multicall (so don't tear down
                                   context on exit). (not CXt_FORMAT) */
a981 2

/* this is only set in conjunction with CXp_FOR_GV */
d983 1
a983 6
/* these 3 are mutually exclusive */
#define CXp_FOR_LVREF	0x20	/* foreach using \$var */
#define CXp_FOR_GV	0x40	/* foreach using package var */
#define CXp_FOR_PAD	0x80	/* foreach using lexical var */

#define CxPADLOOP(c)	((c)->cx_type & CXp_FOR_PAD)
d989 3
a991 3
#define CxTYPE_is_LOOP(c) (   CxTYPE(cx) >= CXt_LOOP_ARY                \
                           && CxTYPE(cx) <= CXt_LOOP_PLAIN)
#define CxMULTICALL(c)	((c)->cx_type & CXp_MULTICALL)
d996 3
a998 2
#define CxFOREACH(c)	(   CxTYPE(cx) >= CXt_LOOP_ARY                  \
                         && CxTYPE(cx) <= CXt_LOOP_LIST)
d1008 1
a1008 1
Used to indicate scalar context.  See C<L</GIMME_V>>, C<L</GIMME>>, and
d1012 1
a1012 1
Used to indicate list context.  See C<L</GIMME_V>>, C<L</GIMME>> and
d1016 1
a1016 1
Used to indicate void context.  See C<L</GIMME_V>> and L<perlcall>.
a1081 1
#define PERLSI_MULTICALL       10
d1159 2
a1160 5
#define IN_PERL_COMPILETIME	cBOOL(PL_curcop == &PL_compiling)
#define IN_PERL_RUNTIME		cBOOL(PL_curcop != &PL_compiling)



d1183 6
a1188 2
    OP  *multicall_cop;							\
    bool multicall_oldcatch
a1197 1
        PERL_CONTEXT *cx;						\
d1201 1
d1203 1
d1205 3
a1207 5
	PUSHSTACKi(PERLSI_MULTICALL);					\
	cx = cx_pushblock((CXt_SUB|CXp_MULTICALL|flags), (U8)gimme,     \
                  PL_stack_sp, PL_savestack_ix);	                \
        cx_pushsub(cx, cv, NULL, 0);                                    \
	SAVEOP();					                \
d1210 2
a1211 1
	if (CvDEPTH(cv) >= 2)  						\
d1213 2
d1216 1
d1228 5
a1232 8
        PERL_CONTEXT *cx;						\
	cx = CX_CUR();					                \
	CX_LEAVE_SCOPE(cx);                                             \
        cx_popsub_common(cx);                                           \
        gimme = cx->blk_gimme;                                          \
        PERL_UNUSED_VAR(gimme); /* for API */                           \
	cx_popblock(cx);				   		\
	CX_POP(cx);                                                     \
d1235 1
d1247 5
a1251 3
        PERL_CONTEXT *cx = CX_CUR();					\
	assert(CxMULTICALL(cx));                                        \
        cx_popsub_common(cx);                                           \
d1253 1
a1253 1
        cx_pushsub(cx, cv, NULL, 0);			                \
d1256 2
a1257 1
	if (CvDEPTH(cv) >= 2)  						\
d1259 2
d1262 1
d1266 6
@


