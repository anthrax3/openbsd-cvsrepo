head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.11.0.10
	OPENBSD_6_0_BASE:1.1.1.11
	OPENBSD_5_9:1.1.1.11.0.4
	OPENBSD_5_9_BASE:1.1.1.11
	OPENBSD_5_8:1.1.1.11.0.6
	OPENBSD_5_8_BASE:1.1.1.11
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.1.1.11.0.2
	OPENBSD_5_7_BASE:1.1.1.11
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.1.1.10.0.4
	OPENBSD_5_6_BASE:1.1.1.10
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.10
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.8
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.6
	OPENBSD_5_0:1.1.1.8.0.4
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.2
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.04;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.45.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.15.37;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.46.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.27;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.06.16;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.58.42;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.52.31;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl -w
# 
# Unconditionally regenerate:
#
#    pod/perlintern.pod
#    pod/perlapi.pod
#
# from information stored in
#
#    embed.fnc
#    plus all the .c and .h files listed in MANIFEST
#
# Has an optional arg, which is the directory to chdir to before reading
# MANIFEST and *.[ch].
#
# This script is invoked as part of 'make all'
#
# '=head1' are the only headings looked for.  If the first non-blank line after
# the heading begins with a word character, it is considered to be the first 
# line of documentation that applies to the heading itself.  That is, it is 
# output immediately after the heading, before the first function, and not 
# indented. The next input line that is a pod directive terminates this 
# heading-level documentation.

use strict;

if (@@ARGV) {
    my $workdir = shift;
    chdir $workdir
        or die "Couldn't chdir to '$workdir': $!";
}
require 'regen/regen_lib.pl';
require 'regen/embed_lib.pl';

#
# See database of global and static function prototypes in embed.fnc
# This is used to generate prototype headers under various configurations,
# export symbols lists for different platforms, and macros to provide an
# implicit interpreter context argument.
#

my %docs;
my %funcflags;
my %macro = (
	     ax => 1,
	     items => 1,
	     ix => 1,
	     svtype => 1,
	    );
my %missing;

my $curheader = "Unknown section";

sub autodoc ($$) { # parse a file and extract documentation info
    my($fh,$file) = @@_;
    my($in, $doc, $line, $header_doc);

    # Count lines easier
    my $get_next_line = sub { $line++; return <$fh> };

FUNC:
    while (defined($in = $get_next_line->())) {
	if ($in =~ /^#\s*define\s+([A-Za-z_][A-Za-z_0-9]+)\(/ &&
	    ($file ne 'embed.h' || $file ne 'proto.h')) {
	    $macro{$1} = $file;
	    next FUNC;
	}
        if ($in=~ /^=head1 (.*)/) {
            $curheader = $1;

            # If the next non-space line begins with a word char, then it is
            # the start of heading-ldevel documentation.
	    if (defined($doc = $get_next_line->())) {
                # Skip over empty lines
                while ($doc =~ /^\s+$/) {
                    if (! defined($doc = $get_next_line->())) {
                        next FUNC;
                    }
                }

                if ($doc !~ /^\w/) {
                    $in = $doc;
                    redo FUNC;
                }
                $header_doc = $doc;

                # Continue getting the heading-level documentation until read
                # in any pod directive (or as a fail-safe, find a closing
                # comment to this pod in a C language file
HDR_DOC:
                while (defined($doc = $get_next_line->())) {
                    if ($doc =~ /^=\w/) {
                        $in = $doc;
                        redo FUNC;
                    }

                    if ($doc =~ m:^\s*\*/$:) {
                        warn "=cut missing? $file:$line:$doc";;
                        last HDR_DOC;
                    }
                    $header_doc .= $doc;
                }
            }
            next FUNC;
        }
	if ($in =~ /^=for\s+apidoc\s+(.*?)\s*\n/) {
	    my $proto = $1;
	    $proto = "||$proto" unless $proto =~ /\|/;
	    my($flags, $ret, $name, @@args) = split /\|/, $proto;
	    my $docs = "";
DOC:
	    while (defined($doc = $get_next_line->())) {
		last DOC if $doc =~ /^=\w+/;
		if ($doc =~ m:^\*/$:) {
		    warn "=cut missing? $file:$line:$doc";;
		    last DOC;
		}
		$docs .= $doc;
	    }
	    $docs = "\n$docs" if $docs and $docs !~ /^\n/;

	    # Check the consistency of the flags
	    my ($embed_where, $inline_where);
	    my ($embed_may_change, $inline_may_change);

	    my $docref = delete $funcflags{$name};
	    if ($docref and %$docref) {
		$embed_where = $docref->{flags} =~ /A/ ? 'api' : 'guts';
		$embed_may_change = $docref->{flags} =~ /M/;
                $flags .= 'D' if $docref->{flags} =~ /D/;
	    } else {
		$missing{$name} = $file;
	    }
	    if ($flags =~ /m/) {
		$inline_where = $flags =~ /A/ ? 'api' : 'guts';
		$inline_may_change = $flags =~ /x/;

		if (defined $embed_where && $inline_where ne $embed_where) {
		    warn "Function '$name' inconsistency: embed.fnc says $embed_where, Pod says $inline_where";
		}

		if (defined $embed_may_change
		    && $inline_may_change ne $embed_may_change) {
		    my $message = "Function '$name' inconsistency: ";
		    if ($embed_may_change) {
			$message .= "embed.fnc says 'may change', Pod does not";
		    } else {
			$message .= "Pod says 'may change', embed.fnc does not";
		    }
		    warn $message;
		}
	    } elsif (!defined $embed_where) {
		warn "Unable to place $name!\n";
		next;
	    } else {
		$inline_where = $embed_where;
		$flags .= 'x' if $embed_may_change;
		@@args = @@{$docref->{args}};
		$ret = $docref->{retval};
	    }

	    if (exists $docs{$inline_where}{$curheader}{$name}) {
                warn "$0: duplicate API entry for '$name' in $inline_where/$curheader\n";
                next;
            }
	    $docs{$inline_where}{$curheader}{$name}
		= [$flags, $docs, $ret, $file, @@args];

            # Create a special entry with an empty-string name for the
            # heading-level documentation.
	    if (defined $header_doc) {
                $docs{$inline_where}{$curheader}{""} = $header_doc;
                undef $header_doc;
            }

	    if (defined $doc) {
		if ($doc =~ /^=(?:for|head)/) {
		    $in = $doc;
		    redo FUNC;
		}
	    } else {
		warn "$file:$line:$in";
	    }
	}
    }
}

sub docout ($$$) { # output the docs for one function
    my($fh, $name, $docref) = @@_;
    my($flags, $docs, $ret, $file, @@args) = @@$docref;
    $name =~ s/\s*$//;

    if ($flags =~ /D/) {
        $docs = "\n\nDEPRECATED!  It is planned to remove this function from a
future release of Perl.  Do not use it for new code; remove it from
existing code.\n\n$docs";
    }
    else {
        $docs = "\n\nNOTE: this function is experimental and may change or be
removed without notice.\n\n$docs" if $flags =~ /x/;
    }
    $docs .= "NOTE: the perl_ form of this function is deprecated.\n\n"
	if $flags =~ /p/;
    $docs .= "NOTE: this function must be explicitly called as Perl_$name with an aTHX_ parameter.\n\n"
        if $flags =~ /o/;

    print $fh "=item $name\nX<$name>\n$docs";

    if ($flags =~ /U/) { # no usage
	# nothing
    } elsif ($flags =~ /s/) { # semicolon ("dTHR;")
	print $fh "\t\t$name;\n\n";
    } elsif ($flags =~ /n/) { # no args
	print $fh "\t$ret\t$name\n\n";
    } else { # full usage
	my $p            = $flags =~ /o/; # no #define foo Perl_foo
	my $n            = "Perl_"x$p . $name;
	my $large_ret    = length $ret > 7;
	my $indent_size  = 7+8 # nroff: 7 under =head + 8 under =item
	                  +8+($large_ret ? 1 + length $ret : 8)
	                  +length($n) + 1;
	my $indent;
	print $fh "\t$ret" . ($large_ret ? ' ' : "\t") . "$n(";
	my $long_args;
	for (@@args) {
	    if ($indent_size + 2 + length > 79) {
		$long_args=1;
		$indent_size -= length($n) - 3;
		last;
	    }
	}
	my $args = '';
	if ($p) {
	    $args = @@args ? "pTHX_ " : "pTHX";
	    if ($long_args) { print $fh $args; $args = '' }
	}
	$long_args and print $fh "\n";
	my $first = !$long_args;
	while () {
	    if (!@@args or
	         length $args
	         && $indent_size + 3 + length($args[0]) + length $args > 79
	    ) {
		print $fh
		  $first ? '' : (
		    $indent //=
		       "\t".($large_ret ? " " x (1+length $ret) : "\t")
		      ." "x($long_args ? 4 : 1 + length $n)
		  ),
		  $args, (","x($args ne 'pTHX_ ') . "\n")x!!@@args;
		$args = $first = '';
	    }
	    @@args or last;
	    $args .= ", "x!!(length $args && $args ne 'pTHX_ ')
	           . shift @@args;
	}
	if ($long_args) { print $fh "\n", substr $indent, 0, -4 }
	print $fh ")\n\n";
    }
    print $fh "=for hackers\nFound in file $file\n\n";
}

sub sort_helper {
    # Do a case-insensitive dictionary sort, with only alphabetics
    # significant, falling back to using everything for determinancy
    return (uc($a =~ s/[[:^alpha:]]//r) cmp uc($b =~ s/[[:^alpha:]]//r))
           || uc($a) cmp uc($b)
           || $a cmp $b;
}

sub output {
    my ($podname, $header, $dochash, $missing, $footer) = @@_;
    my $fh = open_new("pod/$podname.pod", undef,
		      {by => "$0 extracting documentation",
                       from => 'the C source files'}, 1);

    print $fh $header;

    my $key;
    for $key (sort sort_helper keys %$dochash) {
	my $section = $dochash->{$key}; 
	print $fh "\n=head1 $key\n\n";

        # Output any heading-level documentation and delete so won't get in
        # the way later
        if (exists $section->{""}) {
            print $fh $section->{""} . "\n";
            delete $section->{""};
        }
	print $fh "=over 8\n\n";

	for my $key (sort sort_helper keys %$section) {
	    docout($fh, $key, $section->{$key});
	}
	print $fh "\n=back\n";
    }

    if (@@$missing) {
        print $fh "\n=head1 Undocumented functions\n\n";
    print $fh $podname eq 'perlapi' ? <<'_EOB_' : <<'_EOB_';
The following functions have been flagged as part of the public API,
but are currently undocumented.  Use them at your own risk, as the
interfaces are subject to change.  Functions that are not listed in this
document are not intended for public use, and should NOT be used under any
circumstances.

If you feel you need to use one of these functions, first send email to
L<perl5-porters@@perl.org|mailto:perl5-porters@@perl.org>.  It may be
that there is a good reason for the function not being documented, and it
should be removed from this list; or it may just be that no one has gotten
around to documenting it.  In the latter case, you will be asked to submit a
patch to document the function.  Once your patch is accepted, it will indicate
that the interface is stable (unless it is explicitly marked otherwise) and
usable by you.

=over

_EOB_
The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.

=over

_EOB_
    for my $missing (sort @@$missing) {
        print $fh "=item $missing\nX<$missing>\n\n";
    }
    print $fh "=back\n\n";
}
    print $fh $footer, "=cut\n";

    read_only_bottom_close_and_rename($fh);
}

foreach (@@{(setup_embed())[0]}) {
    next if @@$_ < 2;
    my ($flags, $retval, $func, @@args) = @@$_;
    s/\b(?:NN|NULLOK)\b\s+//g for @@args;

    $funcflags{$func} = {
			 flags => $flags,
			 retval => $retval,
			 args => \@@args,
			};
}

# glob() picks up docs from extra .c or .h files that may be in unclean
# development trees.
open my $fh, '<', 'MANIFEST'
    or die "Can't open MANIFEST: $!";
while (my $line = <$fh>) {
    next unless my ($file) = $line =~ /^(\S+\.[ch])\t/;

    open F, "< $file" or die "Cannot open $file for docs: $!\n";
    $curheader = "Functions in file $file\n";
    autodoc(\*F,$file);
    close F or die "Error closing $file: $!\n";
}
close $fh or die "Error whilst reading MANIFEST: $!";

for (sort keys %funcflags) {
    next unless $funcflags{$_}{flags} =~ /d/;
    warn "no docs for $_\n"
}

foreach (sort keys %missing) {
    next if $macro{$_};
    # Heuristics for known not-a-function macros:
    next if /^[A-Z]/;
    next if /^dj?[A-Z]/;

    warn "Function '$_', documented in $missing{$_}, not listed in embed.fnc";
}

# walk table providing an array of components in each line to
# subroutine, printing the result

# List of funcs in the public API that aren't also marked as experimental nor
# deprecated.
my @@missing_api = grep $funcflags{$_}{flags} =~ /A/ && $funcflags{$_}{flags} !~ /[MD]/ && !$docs{api}{$_}, keys %funcflags;
output('perlapi', <<'_EOB_', $docs{api}, \@@missing_api, <<'_EOE_');
=head1 NAME

perlapi - autogenerated documentation for the perl public API

=head1 DESCRIPTION
X<Perl API> X<API> X<api>

This file contains the documentation of the perl public API generated by
F<embed.pl>, specifically a listing of functions, macros, flags, and variables
that may be used by extension writers.  L<At the end|/Undocumented functions>
is a list of functions which have yet to be documented.  The interfaces of
those are subject to change without notice.  Anything not listed here is
not part of the public API, and should not be used by extension writers at
all.  For these reasons, blindly using functions listed in proto.h is to be
avoided when writing extensions.

In Perl, unlike C, a string of characters may generally contain embedded
C<NUL> characters.  Sometimes in the documentation a Perl string is referred
to as a "buffer" to distinguish it from a C string, but sometimes they are
both just referred to as strings.

Note that all Perl API global variables must be referenced with the C<PL_>
prefix.  Again, those not listed here are not to be used by extension writers,
and can be changed or removed without notice; same with macros.
Some macros are provided for compatibility with the older,
unadorned names, but this support may be disabled in a future release.

Perl was originally written to handle US-ASCII only (that is characters
whose ordinal numbers are in the range 0 - 127).
And documentation and comments may still use the term ASCII, when
sometimes in fact the entire range from 0 - 255 is meant.

The non-ASCII characters below 256 can have various meanings, depending on
various things.  (See, most notably, L<perllocale>.)  But usually the whole
range can be referred to as ISO-8859-1.  Often, the term "Latin-1" (or
"Latin1") is used as an equivalent for ISO-8859-1.  But some people treat
"Latin1" as referring just to the characters in the range 128 through 255, or
somethimes from 160 through 255.
This documentation uses "Latin1" and "Latin-1" to refer to all 256 characters.

Note that Perl can be compiled and run under either ASCII or EBCDIC (See
L<perlebcdic>).  Most of the documentation (and even comments in the code)
ignore the EBCDIC possibility.  
For almost all purposes the differences are transparent.
As an example, under EBCDIC,
instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so
whenever this documentation refers to C<utf8>
(and variants of that name, including in function names),
it also (essentially transparently) means C<UTF-EBCDIC>.
But the ordinals of characters differ between ASCII, EBCDIC, and
the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy a different
number of bytes than in UTF-8.

The listing below is alphabetical, case insensitive.

_EOB_

=head1 AUTHORS

Until May 1997, this document was maintained by Jeff Okamoto
<okamoto@@corp.hp.com>.  It is now maintained as part of Perl itself.

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

API Listing originally by Dean Roehrich <roehrich@@cray.com>.

Updated to be autogenerated from comments in the source by Benjamin Stuhl.

=head1 SEE ALSO

L<perlguts>, L<perlxs>, L<perlxstut>, L<perlintern>

_EOE_

# List of non-static internal functions
my @@missing_guts =
 grep $funcflags{$_}{flags} !~ /[As]/ && !$docs{guts}{$_}, keys %funcflags;

output('perlintern', <<'END', $docs{guts}, \@@missing_guts, <<'END');
=head1 NAME

perlintern - autogenerated documentation of purely B<internal>
		 Perl functions

=head1 DESCRIPTION
X<internal Perl functions> X<interpreter functions>

This file is the autogenerated documentation of functions in the
Perl interpreter that are documented using Perl's internal documentation
format but are not marked as part of the Perl API.  In other words,
B<they are not for use in extensions>!

END

=head1 AUTHORS

The autodocumentation system was originally added to the Perl core by
Benjamin Stuhl.  Documentation is by whoever was kind enough to
document their functions.

=head1 SEE ALSO

L<perlguts>, L<perlapi>

END
@


1.1
log
@Initial revision
@
text
@d2 32
a33 6

require 5.003;	# keep this compatible, an old perl is all we may have before
                # we build the new one

BEGIN {  push @@INC, 'lib' }	# glob() below requires File::Glob

d42 9
a50 43
open IN, "embed.fnc" or die $!;

# walk table providing an array of components in each line to
# subroutine, printing the result
sub walk_table (&@@) {
    my $function = shift;
    my $filename = shift || '-';
    my $leader = shift;
    my $trailer = shift;
    my $F;
    local *F;
    if (ref $filename) {	# filehandle
	$F = $filename;
    }
    else {
	open F, ">$filename" or die "Can't open $filename: $!";
	$F = \*F;
    }
    print $F $leader if $leader;
    seek IN, 0, 0;		# so we may restart
    while (<IN>) {
	chomp;
	next if /^:/;
	while (s|\\$||) {
	    $_ .= <IN>;
	    chomp;
	}
	my @@args;
	if (/^\s*(#|$)/) {
	    @@args = $_;
	}
	else {
	    @@args = split /\s*\|\s*/, $_;
	}
	print $F $function->(@@args);
    }
    print $F $trailer if $trailer;
    close $F unless ref $filename;
}

my %apidocs;
my %gutsdocs;
my %docfuncs;
d56 5
a60 1
    my($in, $doc, $line);
d62 6
a67 1
    while (defined($in = <$fh>)) {
d70 34
d106 1
a106 2
	$line++;
	if ($in =~ /^=for\s+apidoc\s+(.*)\n/) {
d112 1
a112 6
	    while (defined($doc = <$fh>)) {
                if ($doc =~ /^=head1 (.*)/) {
                    $curheader = $1;
                    next DOC;
                }
		$line++;
d121 13
d135 5
a139 2
		if ($flags =~ /A/) {
		    $apidocs{$curheader}{$name} = [$flags, $docs, $ret, $file, @@args];
d141 10
a150 2
		else {
		    $gutsdocs{$curheader}{$name} = [$flags, $docs, $ret, $file, @@args];
d152 8
d161 15
a175 3
	    else {
		$docfuncs{$name} = [$flags, $docs, $ret, $file, $curheader, @@args];
	    }
d177 1
a177 1
		if ($doc =~ /^=for/) {
d191 1
d193 9
a201 2
    $docs .= "NOTE: this function is experimental and may change or be
removed without notice.\n\n" if $flags =~ /x/;
d204 2
d207 1
a207 1
    print $fh "=item $name\n$docs";
d216 43
a258 3
	print $fh "\t$ret\t$name";
	print $fh "(" . join(", ", @@args) . ")";
	print $fh "\n\n";
d263 92
a354 2
my $file;
for $file (glob('*.c'), glob('*.h')) {
d360 1
d362 10
a371 24
unlink "pod/perlapi.pod";
open (DOC, ">pod/perlapi.pod") or
	die "Can't create pod/perlapi.pod: $!\n";

walk_table {	# load documented functions into approriate hash
    if (@@_ > 1) {
	my($flags, $retval, $func, @@args) = @@_;
	return "" unless $flags =~ /d/;
	$func =~ s/\t//g; $flags =~ s/p//; # clean up fields from embed.pl
	$retval =~ s/\t//;
	if ($flags =~ /A/) {
	    my $docref = delete $docfuncs{$func};
	    warn "no docs for $func\n" unless $docref and @@$docref;
            $docref->[0].="x" if $flags =~ /M/;
	    $apidocs{$docref->[4]}{$func} = 
                [$docref->[0] . 'A', $docref->[1], $retval, $docref->[3], @@args];
	} else {
	    my $docref = delete $docfuncs{$func};
	    $gutsdocs{$docref->[4]}{$func} = 
                [$docref->[0], $docref->[1], $retval, $docref->[3], @@args];
	}
    }
    return "";
} \*DOC;
d373 1
a373 4
for (sort keys %docfuncs) {
    # Have you used a full for apidoc or just a func name?
    # Have you used Ap instead of Am in the for apidoc?
    warn "Unable to place $_!\n";
d376 7
a382 1
print DOC <<'_EOB_';
d388 1
d391 12
a402 5
embed.pl, specifically a listing of functions, macros, flags, and variables
that may be used by extension writers.  The interfaces of any functions that
are not listed here are subject to change without notice.  For this reason,
blindly using functions listed in proto.h is to be avoided when writing
extensions.
d405 3
a407 1
prefix.  Some macros are provided for compatibility with the older,
d410 27
a436 1
The listing is alphabetical, case insensitive.
a439 12
my $key;
for $key (sort { uc($a) cmp uc($b); } keys %apidocs) { # case insensitive sort
    my $section = $apidocs{$key}; 
    print DOC "\n=head1 $key\n\n=over 8\n\n";
    for my $key (sort { uc($a) cmp uc($b); } keys %$section) {
        docout(\*DOC, $key, $section->{$key});
    }
    print DOC "\n=back\n";
}

print DOC <<'_EOE_';

d456 1
a456 1
perlguts(1), perlxs(1), perlxstut(1), perlintern(1)
d460 3
d464 1
a464 5
close(DOC);

open(GUTS, ">pod/perlintern.pod") or
		die "Unable to create pod/perlintern.pod: $!\n";
print GUTS <<'END';
d471 1
d475 1
a475 1
format but are not marked as part of the Perl API. In other words,
a479 11
for $key (sort { uc($a) cmp uc($b); } keys %gutsdocs) {
    my $section = $gutsdocs{$key}; 
    print GUTS "\n=head1 $key\n\n=over 8\n\n";
    for my $key (sort { uc($a) cmp uc($b); } keys %$section) {
        docout(\*GUTS, $key, $section->{$key});
    }
    print GUTS "\n=back\n";
}

print GUTS <<'END';

d483 1
a483 1
Benjamin Stuhl. Documentation is by whoever was kind enough to
d488 1
a488 1
perlguts(1), perlapi(1)
a490 3

close GUTS;

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d6 1
a6 4
BEGIN {
  push @@INC, 'lib';
  require 'regen_lib.pl';
}	# glob() below requires File::Glob
a30 1
	safer_unlink $filename;
d39 1
a39 1
	while (s|\\\s*$||) {
d53 1
a53 3
    unless (ref $filename) {
	close $F or die "Error closing $filename: $!";
    }
d72 1
a72 1
	if ($in =~ /^=for\s+apidoc\s+(.*?)\s*\n/) {
d148 1
a148 1
safer_unlink "pod/perlapi.pod";
d158 2
a159 13
	my $docref = delete $docfuncs{$func};
	if ($docref and @@$docref) {
	    if ($flags =~ /A/) {
		$docref->[0].="x" if $flags =~ /M/;
		$apidocs{$docref->[4]}{$func} = 
		    [$docref->[0] . 'A', $docref->[1], $retval,
		    				$docref->[3], @@args];
	    } else {
		$gutsdocs{$docref->[4]}{$func} = 
		    [$docref->[0], $docref->[1], $retval, $docref->[3], @@args];
	    }
	}
	else {
d161 7
d202 1
a202 2
# case insensitive sort, with fallback for determinacy
for $key (sort { uc($a) cmp uc($b) || $a cmp $b } keys %apidocs) {
d234 1
a234 1
close(DOC) or die "Error closing pod/perlapi.pod: $!";
a235 1
safer_unlink "pod/perlintern.pod";
d276 2
a277 1
close GUTS or die "Error closing pod/perlintern.pod: $!";
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
}
d85 4
d110 1
a110 1
		if ($doc =~ /^=(?:for|head)/) {
d147 1
a147 9
# glob() picks up docs from extra .c or .h files that may be in unclean
# development trees.
my $MANIFEST = do {
  local ($/, *FH);
  open FH, "MANIFEST" or die "Can't open MANIFEST: $!";
  <FH>;
};

for $file (($MANIFEST =~ /^(\S+\.c)\t/gm), ($MANIFEST =~ /^(\S+\.h)\t/gm)) {
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@a35 1
	binmode F;
a160 1
binmode DOC;
a253 1
binmode GUTS;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@a47 1
	s/\s+$//;
a54 1
	s/\b(NN|NULLOK)\b\s+//g for @@args;
a120 1
    $name =~ s/\s*$//;
d127 1
a127 1
    print $fh "=item $name\nX<$name>\n$docs";
a200 1
X<Perl API> X<API> X<api>
d222 1
a222 2
    # Again, fallback for determinacy
    for my $key (sort { uc($a) cmp uc($b) || $a cmp $b } keys %$section) {
a263 1
X<internal Perl functions> X<interpreter functions>
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@a10 1
use strict;
a67 1
my %seenfuncs;
a145 21
sub readonly_header (*) {
    my $fh = shift;
    print $fh <<"_EOH_";
-*- buffer-read-only: t -*-

!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
This file is built by $0 extracting documentation from the C source
files.

_EOH_
}

sub readonly_footer (*) {
    my $fh = shift;
    print $fh <<'_EOF_';
=cut

 ex: set ro:
_EOF_
}

d167 1
a167 1
walk_table {	# load documented functions into appropriate hash
a173 1
	$seenfuncs{$func} = 1;
d177 3
a179 3
		$apidocs{$docref->[4]}{$func} =
		    [$docref->[0] . 'A', $docref->[1], $retval, $docref->[3],
			@@args];
d181 1
a181 1
		$gutsdocs{$docref->[4]}{$func} =
d186 1
a186 1
	    warn "no docs for $func\n" unless $seenfuncs{$func};
a197 2
readonly_header(\*DOC);

a254 1
readonly_footer(\*DOC);
a261 1
readonly_header(\*GUTS);
a299 1
readonly_footer(\*GUTS);
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d2 8
a9 16
# 
# Unconditionally regenerate:
#
#    pod/perlintern.pod
#    pod/perlapi.pod
#
# from information stored in
#
#    embed.fnc
#    plus all the .c and .h files listed in MANIFEST
#
# Has an optional arg, which is the directory to chdir to before reading
# MANIFEST and *.[ch].
#
# This script is normally invoked as part of 'make all', but is also
# called from from regen.pl.
d20 46
d148 3
a150 6
sub output {
    my ($podname, $header, $dochash, $footer) = @@_;
    my $filename = "pod/$podname.pod";
    open my $fh, '>', $filename or die "Can't open $filename: $!";

    print $fh <<"_EOH_", $header;
d158 1
d160 3
a162 13
    my $key;
    # case insensitive sort, with fallback for determinacy
    for $key (sort { uc($a) cmp uc($b) || $a cmp $b } keys %$dochash) {
	my $section = $dochash->{$key}; 
	print $fh "\n=head1 $key\n\n=over 8\n\n";
	# Again, fallback for determinacy
	for my $key (sort { uc($a) cmp uc($b) || $a cmp $b } keys %$section) {
	    docout($fh, $key, $section->{$key});
	}
	print $fh "\n=back\n";
    }

    print $fh $footer, <<'_EOF_';
a166 8

    close $fh or die "Can't close $filename: $!";
}

if (@@ARGV) {
    my $workdir = shift;
    chdir $workdir
        or die "Couldn't chdir to '$workdir': $!";
d185 26
a210 35
open IN, "embed.fnc" or die $!;

# walk table providing an array of components in each line to
# subroutine, printing the result

while (<IN>) {
    chomp;
    next if /^:/;
    while (s|\\\s*$||) {
	$_ .= <IN>;
	chomp;
    }
    s/\s+$//;
    next if /^\s*(#|$)/;

    my ($flags, $retval, $func, @@args) = split /\s*\|\s*/, $_;

    next unless $flags =~ /d/;
    next unless $func;

    s/\b(NN|NULLOK)\b\s+//g for @@args;
    $func =~ s/\t//g; # clean up fields from embed.pl
    $retval =~ s/\t//;

    my $docref = delete $docfuncs{$func};
    $seenfuncs{$func} = 1;
    if ($docref and @@$docref) {
	if ($flags =~ /A/) {
	    $docref->[0].="x" if $flags =~ /M/;
	    $apidocs{$docref->[4]}{$func} =
		[$docref->[0] . 'A', $docref->[1], $retval, $docref->[3],
		 @@args];
	} else {
	    $gutsdocs{$docref->[4]}{$func} =
		[$docref->[0], $docref->[1], $retval, $docref->[3], @@args];
d213 2
a214 4
    else {
	warn "no docs for $func\n" unless $seenfuncs{$func};
    }
}
d222 3
a224 1
output('perlapi', <<'_EOB_', \%apidocs, <<'_EOE_');
d243 3
a245 22
Perl was originally written to handle US-ASCII only (that is characters
whose ordinal numbers are in the range 0 - 127).
And documentation and comments may still use the term ASCII, when
sometimes in fact the entire range from 0 - 255 is meant.

Note that Perl can be compiled and run under EBCDIC (See L<perlebcdic>)
or ASCII.  Most of the documentation (and even comments in the code)
ignore the EBCDIC possibility.  
For almost all purposes the differences are transparent.
As an example, under EBCDIC,
instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so
whenever this documentation refers to C<utf8>
(and variants of that name, including in function names),
it also (essentially transparently) means C<UTF-EBCDIC>.
But the ordinals of characters differ between ASCII, EBCDIC, and
the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes
than in UTF-8.

Also, on some EBCDIC machines, functions that are documented as operating on
US-ASCII (or Basic Latin in Unicode terminology) may in fact operate on all
256 characters in the EBCDIC range, not just the subset corresponding to
US-ASCII.
d247 11
a257 1
The listing below is alphabetical, case insensitive.
d259 1
a259 1
_EOB_
d281 10
a290 1
output('perlintern', <<'END', \%gutsdocs, <<'END');
d306 11
d328 3
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d28 4
a31 9
my %docs;
my %funcflags;
my %macro = (
	     ax => 1,
	     items => 1,
	     ix => 1,
	     svtype => 1,
	    );
my %missing;
a39 5
	if ($in =~ /^#\s*define\s+([A-Za-z_][A-Za-z_0-9]+)\(/ &&
	    ($file ne 'embed.h' || $file ne 'proto.h')) {
	    $macro{$1} = $file;
	    next FUNC;
	}
a60 12

	    # Check the consistency of the flags
	    my ($embed_where, $inline_where);
	    my ($embed_may_change, $inline_may_change);

	    my $docref = delete $funcflags{$name};
	    if ($docref and %$docref) {
		$embed_where = $docref->{flags} =~ /A/ ? 'api' : 'guts';
		$embed_may_change = $docref->{flags} =~ /M/;
	    } else {
		$missing{$name} = $file;
	    }
d62 2
a63 5
		$inline_where = $flags =~ /A/ ? 'api' : 'guts';
		$inline_may_change = $flags =~ /x/;

		if (defined $embed_where && $inline_where ne $embed_where) {
		    warn "Function '$name' inconsistency: embed.fnc says $embed_where, Pod says $inline_where";
d65 2
a66 10

		if (defined $embed_may_change
		    && $inline_may_change ne $embed_may_change) {
		    my $message = "Function '$name' inconsistency: ";
		    if ($embed_may_change) {
			$message .= "embed.fnc says 'may change', Pod does not";
		    } else {
			$message .= "Pod says 'may change', embed.fnc does not";
		    }
		    warn $message;
a67 8
	    } elsif (!defined $embed_where) {
		warn "Unable to place $name!\n";
		next;
	    } else {
		$inline_where = $embed_where;
		$flags .= 'x' if $embed_may_change;
		@@args = @@{$docref->{args}};
		$ret = $docref->{retval};
d69 3
a71 4

	    $docs{$inline_where}{$curheader}{$name}
		= [$flags, $docs, $ret, $file, @@args];

d111 1
a111 1
    my ($podname, $header, $dochash, $missing, $footer) = @@_;
a135 9
    if (@@$missing) {
        print $fh "\n=head1 Undocumented functions\n\n";
	print $fh "These functions are currently undocumented:\n\n=over\n\n";
	for my $missing (sort @@$missing) {
	    print $fh "=item $missing\nX<$missing>\n\n";
	}
	print $fh "=back\n\n";
    }

d151 16
d169 3
d184 1
d191 16
a206 5
    $funcflags{$func} = {
			 flags => $flags,
			 retval => $retval,
			 args => \@@args,
			};
d209 4
a212 19
my $file;
# glob() picks up docs from extra .c or .h files that may be in unclean
# development trees.
my $MANIFEST = do {
  local ($/, *FH);
  open FH, "MANIFEST" or die "Can't open MANIFEST: $!";
  <FH>;
};

for $file (($MANIFEST =~ /^(\S+\.c)\t/gm), ($MANIFEST =~ /^(\S+\.h)\t/gm)) {
    open F, "< $file" or die "Cannot open $file for docs: $!\n";
    $curheader = "Functions in file $file\n";
    autodoc(\*F,$file);
    close F or die "Error closing $file: $!\n";
}

for (sort keys %funcflags) {
    next unless $funcflags{$_}{flags} =~ /d/;
    warn "no docs for $_\n"
d215 1
a215 14
foreach (sort keys %missing) {
    next if $macro{$_};
    # Heuristics for known not-a-function macros:
    next if /^[A-Z]/;
    next if /^dj?[A-Z]/;

    warn "Function '$_', documented in $missing{$_}, not listed in embed.fnc";
}

# walk table providing an array of components in each line to
# subroutine, printing the result

my @@missing_api = grep $funcflags{$_}{flags} =~ /A/ && !$docs{api}{$_}, keys %funcflags;
output('perlapi', <<'_EOB_', $docs{api}, \@@missing_api, <<'_EOE_');
d277 1
a277 1
L<perlguts>, L<perlxs>, L<perlxstut>, L<perlintern>
d281 1
a281 3
my @@missing_guts = grep $funcflags{$_}{flags} !~ /A/ && !$docs{guts}{$_}, keys %funcflags;

output('perlintern', <<'END', $docs{guts}, \@@missing_guts, <<'END');
d305 1
a305 1
L<perlguts>, L<perlapi>
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a17 7
#
# '=head1' are the only headings looked for.  If the next line after the
# heading begins with a word character, it is considered to be the first line
# of documentation that applies to the heading itself.  That is, it is output
# immediately after the heading, before the first function, and not indented.
# The next input line that is a pod directive terminates this heading-level
# documentation.
d42 1
a42 1
    my($in, $doc, $line, $header_doc);
a51 29

            # If the next line begins with a word char, then is the start of
            # heading-level documentation.
	    if (defined($doc = <$fh>)) {
                if ($doc !~ /^\w/) {
                    $in = $doc;
                    redo FUNC;
                }
                $header_doc = $doc;
                $line++;

                # Continue getting the heading-level documentation until read
                # in any pod directive (or as a fail-safe, find a closing
                # comment to this pod in a C language file
HDR_DOC:
                while (defined($doc = <$fh>)) {
                    if ($doc =~ /^=\w/) {
                        $in = $doc;
                        redo FUNC;
                    }
                    $line++;

                    if ($doc =~ m:^\s*\*/$:) {
                        warn "=cut missing? $file:$line:$doc";;
                        last HDR_DOC;
                    }
                    $header_doc .= $doc;
                }
            }
a113 7
            # Create a special entry with an empty-string name for the
            # heading-level documentation.
	    if (defined $header_doc) {
                $docs{$inline_where}{$curheader}{""} = $header_doc;
                undef $header_doc;
            }

a134 2
    $docs .= "NOTE: this function must be explicitly called as Perl_$name with an aTHX_ parameter.\n\n"
        if $flags =~ /o/;
d145 3
a147 43
	my $p            = $flags =~ /o/; # no #define foo Perl_foo
	my $n            = "Perl_"x$p . $name;
	my $large_ret    = length $ret > 7;
	my $indent_size  = 7+8 # nroff: 7 under =head + 8 under =item
	                  +8+($large_ret ? 1 + length $ret : 8)
	                  +length($n) + 1;
	my $indent;
	print $fh "\t$ret" . ($large_ret ? ' ' : "\t") . "$n(";
	my $long_args;
	for (@@args) {
	    if ($indent_size + 2 + length > 79) {
		$long_args=1;
		$indent_size -= length($n) - 3;
		last;
	    }
	}
	my $args = '';
	if ($p) {
	    $args = @@args ? "pTHX_ " : "pTHX";
	    if ($long_args) { print $fh $args; $args = '' }
	}
	$long_args and print $fh "\n";
	my $first = !$long_args;
	while () {
	    if (!@@args or
	         length $args
	         && $indent_size + 3 + length($args[0]) + length $args > 79
	    ) {
		print $fh
		  $first ? '' : (
		    $indent //=
		       "\t".($large_ret ? " " x (1+length $ret) : "\t")
		      ." "x($long_args ? 4 : 1 + length $n)
		  ),
		  $args, (","x($args ne 'pTHX_ ') . "\n")x!!@@args;
		$args = $first = '';
	    }
	    @@args or last;
	    $args .= ", "x!!(length $args && $args ne 'pTHX_ ')
	           . shift @@args;
	}
	if ($long_args) { print $fh "\n", substr $indent, 0, -4 }
	print $fh ")\n\n";
d170 1
a170 10
	print $fh "\n=head1 $key\n\n";

        # Output any heading-level documentation and delete so won't get in
        # the way later
        if (exists $section->{""}) {
            print $fh $section->{""} . "\n";
            delete $section->{""};
        }
	print $fh "=over 8\n\n";

d180 5
a184 21
    print $fh $podname eq 'perlapi' ? <<'_EOB_' : <<'_EOB_';
The following functions have been flagged as part of the public API,
but are currently undocumented. Use them at your own risk, as the
interfaces are subject to change.

If you use one of them, you may wish to consider creating and submitting
documentation for it. If your patch is accepted, this will indicate that
the interface is stable (unless it is explicitly marked otherwise).

=over

_EOB_
The following functions are currently undocumented.  If you use one of
them, you may wish to consider creating and submitting documentation for
it.

=over

_EOB_
    for my $missing (sort @@$missing) {
        print $fh "=item $missing\nX<$missing>\n\n";
a185 2
    print $fh "=back\n\n";
}
d187 1
a187 1
print $fh $footer, <<'_EOF_';
d262 1
a262 2
# List of funcs in the public API that aren't also marked as experimental.
my @@missing_api = grep $funcflags{$_}{flags} =~ /A/ && $funcflags{$_}{flags} !~ /M/ && !$docs{api}{$_}, keys %funcflags;
d272 5
a276 7
F<embed.pl>, specifically a listing of functions, macros, flags, and variables
that may be used by extension writers.  L<At the end|/Undocumented functions>
is a list of functions which have yet to be documented.  The interfaces of
those are subject to change without notice.  Any functions not listed here are
not part of the public API, and should not be used by extension writers at
all.  For these reasons, blindly using functions listed in proto.h is to be
avoided when writing extensions.
d329 1
a329 3
# List of non-static internal functions
my @@missing_guts =
 grep $funcflags{$_}{flags} !~ /[As]/ && !$docs{guts}{$_}, keys %funcflags;
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d277 5
a281 8
interfaces are subject to change.  Functions that are not listed in this
document are not intended for public use, and should NOT be used under any
circumstances.

If you use one of the undocumented functions below, you may wish to consider
creating and submitting documentation for it. If your patch is accepted, this
will indicate that the interface is stable (unless it is explicitly marked
otherwise).
d414 5
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d16 2
a17 1
# This script is invoked as part of 'make all'
a27 8
if (@@ARGV) {
    my $workdir = shift;
    chdir $workdir
        or die "Couldn't chdir to '$workdir': $!";
}
require 'regen/regen_lib.pl';
require 'regen/embed_lib.pl';

a115 1
                $flags .= 'D' if $docref->{flags} =~ /D/;
d174 2
a175 9
    if ($flags =~ /D/) {
        $docs = "\n\nDEPRECATED!  It is planned to remove this function from a
future release of Perl.  Do not use it for new code; remove it from
existing code.\n\n$docs";
    }
    else {
        $docs = "\n\nNOTE: this function is experimental and may change or be
removed without notice.\n\n$docs" if $flags =~ /x/;
    }
d239 5
a243 3
    my $fh = open_new("pod/$podname.pod", undef,
		      {by => "$0 extracting documentation",
                       from => 'the C source files'}, 1);
d245 5
a249 1
    print $fh $header;
d276 1
a276 1
but are currently undocumented.  Use them at your own risk, as the
d282 1
a282 2
creating and submitting documentation
for it.  If your patch is accepted, this
a300 1
    print $fh $footer, "=cut\n";
d302 7
a308 1
    read_only_bottom_close_and_rename($fh);
d311 25
a335 4
foreach (@@{(setup_embed())[0]}) {
    next if @@$_ < 2;
    my ($flags, $retval, $func, @@args) = @@$_;
    s/\b(?:NN|NULLOK)\b\s+//g for @@args;
d344 1
d347 5
a351 4
open my $fh, '<', 'MANIFEST'
    or die "Can't open MANIFEST: $!";
while (my $line = <$fh>) {
    next unless my ($file) = $line =~ /^(\S+\.[ch])\t/;
d353 1
a358 1
close $fh or die "Error whilst reading MANIFEST: $!";
d377 2
a378 3
# List of funcs in the public API that aren't also marked as experimental nor
# deprecated.
my @@missing_api = grep $funcflags{$_}{flags} =~ /A/ && $funcflags{$_}{flags} !~ /[MD]/ && !$docs{api}{$_}, keys %funcflags;
d391 1
a391 1
those are subject to change without notice.  Anything not listed here is
d397 1
a397 3
prefix.  Again, those not listed here are not to be used by extension writers,
and can be changed or removed without notice; same with macros.
Some macros are provided for compatibility with the older,
d457 1
a457 1
format but are not marked as part of the Perl API.  In other words,
d465 1
a465 1
Benjamin Stuhl.  Documentation is by whoever was kind enough to
@


