head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	GzHqjSTnBjdF7Wcw;

1.17
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	XRK22kO4se3v2i2I;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.20;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.51;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.30;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.48;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.42;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.28;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.33;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.32;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.28;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.10;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.45.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    op.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * The fields of BASEOP are:
 *	op_next		Pointer to next ppcode to execute after this one.
 *			(Top level pre-grafted op points to first op,
 *			but this is replaced when op is grafted in, when
 *			this op will point to the real next op, and the new
 *			parent takes over role of remembering starting op.)
 *	op_ppaddr	Pointer to current ppcode's function.
 *	op_type		The type of the operation.
 *	op_opt		Whether or not the op has been optimised by the
 *			peephole optimiser.
 *	op_slabbed	allocated via opslab
 *	op_static	tell op_free() to skip PerlMemShared_free(), when
 *                      !op_slabbed.
 *	op_savefree	on savestack via SAVEFREEOP
 *	op_folded	Result/remainder of a constant fold operation.
 *	op_moresib	this op is is not the last sibling
 *	op_spare	One spare bit
 *	op_flags	Flags common to all operations.  See OPf_* below.
 *	op_private	Flags peculiar to a particular operation (BUT,
 *			by default, set to the number of children until
 *			the operation is privatized by a check routine,
 *			which may or may not check number of children).
 */
#include "op_reg_common.h"

#define OPCODE U16

typedef PERL_BITFIELD16 Optype;

/* this field now either points to the next sibling or to the parent,
 * depending on op_moresib. So rename it from op_sibling to op_sibparent.
 */
#ifdef PERL_OP_PARENT
#  define _OP_SIBPARENT_FIELDNAME op_sibparent
#else
#  define _OP_SIBPARENT_FIELDNAME op_sibling
#endif

#ifdef BASEOP_DEFINITION
#define BASEOP BASEOP_DEFINITION
#else
#define BASEOP				\
    OP*		op_next;		\
    OP*		_OP_SIBPARENT_FIELDNAME;\
    OP*		(*op_ppaddr)(pTHX);	\
    PADOFFSET	op_targ;		\
    PERL_BITFIELD16 op_type:9;		\
    PERL_BITFIELD16 op_opt:1;		\
    PERL_BITFIELD16 op_slabbed:1;	\
    PERL_BITFIELD16 op_savefree:1;	\
    PERL_BITFIELD16 op_static:1;	\
    PERL_BITFIELD16 op_folded:1;	\
    PERL_BITFIELD16 op_moresib:1;       \
    PERL_BITFIELD16 op_spare:1;		\
    U8		op_flags;		\
    U8		op_private;
#endif

/* If op_type:9 is changed to :10, also change cx_pusheval()
   Also, if the type of op_type is ever changed (e.g. to PERL_BITFIELD32)
   then all the other bit-fields before/after it should change their
   types too to let VC pack them into the same 4 byte integer.*/

/* for efficiency, requires OPf_WANT_VOID == G_VOID etc */
#define OP_GIMME(op,dfl) \
	(((op)->op_flags & OPf_WANT) ? ((op)->op_flags & OPf_WANT) : dfl)

#define OP_GIMME_REVERSE(flags)	((flags) & G_WANT)

/*
=head1 "Gimme" Values

=for apidoc Amn|U32|GIMME_V
The XSUB-writer's equivalent to Perl's C<wantarray>.  Returns C<G_VOID>,
C<G_SCALAR> or C<G_ARRAY> for void, scalar or list context,
respectively.  See L<perlcall> for a usage example.

=for apidoc Amn|U32|GIMME
A backward-compatible version of C<GIMME_V> which can only return
C<G_SCALAR> or C<G_ARRAY>; in a void context, it returns C<G_SCALAR>.
Deprecated.  Use C<GIMME_V> instead.

=cut
*/

#define GIMME_V		OP_GIMME(PL_op, block_gimme())

/* Public flags */

#define OPf_WANT	3	/* Mask for "want" bits: */
#define  OPf_WANT_VOID	 1	/*   Want nothing */
#define  OPf_WANT_SCALAR 2	/*   Want single value */
#define  OPf_WANT_LIST	 3	/*   Want list of any length */
#define OPf_KIDS	4	/* There is a firstborn child. */
#define OPf_PARENS	8	/* This operator was parenthesized. */
				/*  (Or block needs explicit scope entry.) */
#define OPf_REF		16	/* Certified reference. */
				/*  (Return container, not containee). */
#define OPf_MOD		32	/* Will modify (lvalue). */
#define OPf_STACKED	64	/* Some arg is arriving on the stack. */
#define OPf_SPECIAL	128	/* Do something weird for this op: */
				/*  On local LVAL, don't init local value. */
				/*  On OP_SORT, subroutine is inlined. */
				/*  On OP_NOT, inversion was implicit. */
				/*  On OP_LEAVE, don't restore curpm, e.g.
                                 *      /(...)/ while ...>;  */
				/*  On truncate, we truncate filehandle */
				/*  On control verbs, we saw no label */
				/*  On flipflop, we saw ... instead of .. */
				/*  On UNOPs, saw bare parens, e.g. eof(). */
				/*  On OP_CHDIR, handle (or bare parens) */
				/*  On OP_NULL, saw a "do". */
				/*  On OP_EXISTS, treat av as av, not avhv.  */
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@@ */
                                /*  On pushre, rx is used as part of split, e.g. split " " */
				/*  On regcomp, "use re 'eval'" was in scope */
				/*  On RV2[ACGHS]V, don't create GV--in
				    defined()*/
				/*  On OP_DBSTATE, indicates breakpoint
				 *    (runtime property) */
				/*  On OP_REQUIRE, was seen as CORE::require */
				/*  On OP_(ENTER|LEAVE)WHEN, there's
				    no condition */
				/*  On OP_SMARTMATCH, an implicit smartmatch */
				/*  On OP_ANONHASH and OP_ANONLIST, create a
				    reference to the new anon hash or array */
				/*  On OP_HELEM, OP_MULTIDEREF and OP_HSLICE,
                                    localization will be followed by assignment,
                                    so do not wipe the target if it is special
                                    (e.g. a glob or a magic SV) */
				/*  On OP_MATCH, OP_SUBST & OP_TRANS, the
				    operand of a logical or conditional
				    that was optimised away, so it should
				    not be bound via =~ */
				/*  On OP_CONST, from a constant CV */
				/*  On OP_GLOB, two meanings:
				    - Before ck_glob, called as CORE::glob
				    - After ck_glob, use Perl glob function
			         */
                                /*  On OP_PADRANGE, push @@_ */
                                /*  On OP_DUMP, has no label */
                                /*  On OP_UNSTACK, in a C-style for loop */
/* There is no room in op_flags for this one, so it has its own bit-
   field member (op_folded) instead.  The flag is only used to tell
   op_convert_list to set op_folded.  */
#define OPf_FOLDED      1<<16

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT

#if !defined(PERL_CORE) && !defined(PERL_EXT)
#  define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())
#endif


/* NOTE: OPp* flags are now auto-generated and defined in opcode.h,
 *       from data in regen/op_private */


#define OPpTRANS_ALL	(OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|OPpTRANS_SQUASH|OPpTRANS_COMPLEMENT|OPpTRANS_GROWS|OPpTRANS_DELETE)



/* Mask for OP_ENTERSUB flags, the absence of which must be propagated
 in dynamic context */
#define OPpENTERSUB_LVAL_MASK (OPpLVAL_INTRO|OPpENTERSUB_INARGS)


/* things that can be elements of op_aux */
typedef union  {
    PADOFFSET pad_offset;
    SV        *sv;
    IV        iv;
    UV        uv;
} UNOP_AUX_item;

#ifdef USE_ITHREADS
#  define UNOP_AUX_item_sv(item) PAD_SVl((item)->pad_offset);
#else
#  define UNOP_AUX_item_sv(item) ((item)->sv);
#endif




struct op {
    BASEOP
};

struct unop {
    BASEOP
    OP *	op_first;
};

struct unop_aux {
    BASEOP
    OP  	  *op_first;
    UNOP_AUX_item *op_aux;
};

struct binop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct logop {
    BASEOP
    OP *	op_first;
    OP *	op_other;
};

struct listop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
};

struct methop {
    BASEOP
    union {
        /* op_u.op_first *must* be aligned the same as the op_first
         * field of the other op types, and op_u.op_meth_sv *must*
         * be aligned with op_sv */
        OP* op_first;   /* optree for method name */
        SV* op_meth_sv; /* static method name */
    } op_u;
#ifdef USE_ITHREADS
    PADOFFSET op_rclass_targ; /* pad index for redirect class */
#else
    SV*       op_rclass_sv;   /* static redirect class $o->A::meth() */
#endif
};

struct pmop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
#ifdef USE_ITHREADS
    PADOFFSET   op_pmoffset;
#else
    REGEXP *    op_pmregexp;            /* compiled expression */
#endif
    U32         op_pmflags;
    union {
	OP *	op_pmreplroot;		/* For OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET  op_pmtargetoff;	/* For OP_PUSHRE */
#else
	GV *	op_pmtargetgv;
#endif
    }	op_pmreplrootu;
    union {
	OP *	op_pmreplstart;	/* Only used in OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET op_pmstashoff; /* Only used in OP_MATCH, with PMf_ONCE set */
#else
	HV *	op_pmstash;
#endif
    }		op_pmstashstartu;
    OP *	op_code_list;	/* list of (?{}) code blocks */
};

#ifdef USE_ITHREADS
#define PM_GETRE(o)	(SvTYPE(PL_regex_pad[(o)->op_pmoffset]) == SVt_REGEXP \
		 	 ? (REGEXP*)(PL_regex_pad[(o)->op_pmoffset]) : NULL)
/* The assignment is just to enforce type safety (or at least get a warning).
 */
/* With first class regexps not via a reference one needs to assign
   &PL_sv_undef under ithreads. (This would probably work unthreaded, but NULL
   is cheaper. I guess we could allow NULL, but the check above would get
   more complex, and we'd have an AV with (SV*)NULL in it, which feels bad */
/* BEWARE - something that calls this macro passes (r) which has a side
   effect.  */
#define PM_SETRE(o,r)	STMT_START {					\
                            REGEXP *const _pm_setre = (r);		\
                            assert(_pm_setre);				\
			    PL_regex_pad[(o)->op_pmoffset] = MUTABLE_SV(_pm_setre); \
                        } STMT_END
#else
#define PM_GETRE(o)     ((o)->op_pmregexp)
#define PM_SETRE(o,r)   ((o)->op_pmregexp = (r))
#endif

/* Currently these PMf flags occupy a single 32-bit word.  Not all bits are
 * currently used.  The lower bits are shared with their corresponding RXf flag
 * bits, up to but not including _RXf_PMf_SHIFT_NEXT.  The unused bits
 * immediately follow; finally the used Pmf-only (unshared) bits, so that the
 * highest bit in the word is used.  This gathers all the unused bits as a pool
 * in the middle, like so: 11111111111111110000001111111111
 * where the '1's represent used bits, and the '0's unused.  This design allows
 * us to allocate off one end of the pool if we need to add a shared bit, and
 * off the other end if we need a non-shared bit, without disturbing the other
 * bits.  This maximizes the likelihood of being able to change things without
 * breaking binary compatibility.
 *
 * To add shared bits, do so in op_reg_common.h.  This should change
 * _RXf_PMf_SHIFT_NEXT so that things won't compile.  Then come to regexp.h and
 * op.h and adjust the constant adders in the definitions of PMf_BASE_SHIFT and
 * Pmf_BASE_SHIFT down by the number of shared bits you added.  That's it.
 * Things should be binary compatible.  But if either of these gets to having
 * to subtract rather than add, leave at 0 and adjust all the entries below
 * that are in terms of this according.  But if the first one of those is
 * already PMf_BASE_SHIFT+0, there are no bits left, and a redesign is in
 * order.
 *
 * To remove unshared bits, just delete its entry.  If you're where breaking
 * binary compatibility is ok to do, you might want to adjust things to move
 * the newly opened space so that it gets absorbed into the common pool.
 *
 * To add unshared bits, first use up any gaps in the middle.  Otherwise,
 * allocate off the low end until you get to PMf_BASE_SHIFT+0.  If that isn't
 * enough, move PMf_BASE_SHIFT down (if possible) and add the new bit at the
 * other end instead; this preserves binary compatibility. */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+2)

/* 'use re "taint"' in scope: taint $1 etc. if target tainted */
#define PMf_RETAINT	(1U<<(PMf_BASE_SHIFT+5))

/* match successfully only once per reset, with related flag RXf_USED in
 * re->extflags holding state.  This is used only for ?? matches, and only on
 * OP_MATCH and OP_QR */
#define PMf_ONCE	(1U<<(PMf_BASE_SHIFT+6))

/* PMf_ONCE, i.e. ?pat?, has matched successfully.  Not used under threading. */
#define PMf_USED        (1U<<(PMf_BASE_SHIFT+7))

/* subst replacement is constant */
#define PMf_CONST	(1U<<(PMf_BASE_SHIFT+8))

/* keep 1st runtime pattern forever */
#define PMf_KEEP	(1U<<(PMf_BASE_SHIFT+9))

#define PMf_GLOBAL	(1U<<(PMf_BASE_SHIFT+10)) /* pattern had a g modifier */

/* don't reset pos() if //g fails */
#define PMf_CONTINUE	(1U<<(PMf_BASE_SHIFT+11))

/* evaluating replacement as expr */
#define PMf_EVAL	(1U<<(PMf_BASE_SHIFT+12))

/* Return substituted string instead of modifying it. */
#define PMf_NONDESTRUCT	(1U<<(PMf_BASE_SHIFT+13))

/* the pattern has a CV attached (currently only under qr/...(?{}).../) */
#define PMf_HAS_CV	(1U<<(PMf_BASE_SHIFT+14))

/* op_code_list is private; don't free it etc. It may well point to
 * code within another sub, with different pad etc */
#define PMf_CODELIST_PRIVATE	(1U<<(PMf_BASE_SHIFT+15))

/* the PMOP is a QR (we should be able to detect that from the op type,
 * but the regex compilation API passes just the pm flags, not the op
 * itself */
#define PMf_IS_QR	(1U<<(PMf_BASE_SHIFT+16))
#define PMf_USE_RE_EVAL	(1U<<(PMf_BASE_SHIFT+17)) /* use re'eval' in scope */

/* See comments at the beginning of these defines about adding bits.  The
 * highest bit position should be used, so that if PMf_BASE_SHIFT gets
 * increased, the #error below will be triggered so that you will be reminded
 * to adjust things at the other end to keep the bit positions unchanged */
#if PMf_BASE_SHIFT+17 > 31
#   error Too many PMf_ bits used.  See above and regnodes.h for any spare in middle
#endif

#ifdef USE_ITHREADS

#  define PmopSTASH(o)         ((o)->op_pmflags & PMf_ONCE                         \
                                ? PL_stashpad[(o)->op_pmstashstartu.op_pmstashoff]   \
                                : NULL)
#  define PmopSTASH_set(o,hv)	\
	(assert_((o)->op_pmflags & PMf_ONCE)				\
	 (o)->op_pmstashstartu.op_pmstashoff =				\
	    (hv) ? alloccopstash(hv) : 0)
#else
#  define PmopSTASH(o)							\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstash : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASH_set(o,hv)		({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstash = (hv));			\
    })
#  else
#    define PmopSTASH_set(o,hv)	((o)->op_pmstashstartu.op_pmstash = (hv))
#  endif
#endif
#define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
#define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))

struct svop {
    BASEOP
    SV *	op_sv;
};

struct padop {
    BASEOP
    PADOFFSET	op_padix;
};

struct pvop {
    BASEOP
    char *	op_pv;
};

struct loop {
    BASEOP
    OP *	op_first;
    OP *	op_last;
    OP *	op_redoop;
    OP *	op_nextop;
    OP *	op_lastop;
};

#define cUNOPx(o)	((UNOP*)(o))
#define cUNOP_AUXx(o)	((UNOP_AUX*)(o))
#define cBINOPx(o)	((BINOP*)(o))
#define cLISTOPx(o)	((LISTOP*)(o))
#define cLOGOPx(o)	((LOGOP*)(o))
#define cPMOPx(o)	((PMOP*)(o))
#define cSVOPx(o)	((SVOP*)(o))
#define cPADOPx(o)	((PADOP*)(o))
#define cPVOPx(o)	((PVOP*)(o))
#define cCOPx(o)	((COP*)(o))
#define cLOOPx(o)	((LOOP*)(o))
#define cMETHOPx(o)	((METHOP*)(o))

#define cUNOP		cUNOPx(PL_op)
#define cUNOP_AUX	cUNOP_AUXx(PL_op)
#define cBINOP		cBINOPx(PL_op)
#define cLISTOP		cLISTOPx(PL_op)
#define cLOGOP		cLOGOPx(PL_op)
#define cPMOP		cPMOPx(PL_op)
#define cSVOP		cSVOPx(PL_op)
#define cPADOP		cPADOPx(PL_op)
#define cPVOP		cPVOPx(PL_op)
#define cCOP		cCOPx(PL_op)
#define cLOOP		cLOOPx(PL_op)

#define cUNOPo		cUNOPx(o)
#define cUNOP_AUXo	cUNOP_AUXx(o)
#define cBINOPo		cBINOPx(o)
#define cLISTOPo	cLISTOPx(o)
#define cLOGOPo		cLOGOPx(o)
#define cPMOPo		cPMOPx(o)
#define cSVOPo		cSVOPx(o)
#define cPADOPo		cPADOPx(o)
#define cPVOPo		cPVOPx(o)
#define cCOPo		cCOPx(o)
#define cLOOPo		cLOOPx(o)

#define kUNOP		cUNOPx(kid)
#define kUNOP_AUX	cUNOP_AUXx(kid)
#define kBINOP		cBINOPx(kid)
#define kLISTOP		cLISTOPx(kid)
#define kLOGOP		cLOGOPx(kid)
#define kPMOP		cPMOPx(kid)
#define kSVOP		cSVOPx(kid)
#define kPADOP		cPADOPx(kid)
#define kPVOP		cPVOPx(kid)
#define kCOP		cCOPx(kid)
#define kLOOP		cLOOPx(kid)


#ifdef USE_ITHREADS
#  define	cGVOPx_gv(o)	((GV*)PAD_SVl(cPADOPx(o)->op_padix))
#  ifndef PERL_CORE
#    define	IS_PADGV(v)	(v && isGV(v))
#    define	IS_PADCONST(v) \
	(v && (SvREADONLY(v) || (SvIsCOW(v) && !SvLEN(v))))
#  endif
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv \
				 ? cSVOPx(v)->op_sv : PAD_SVl((v)->op_targ))
#  define	cSVOPx_svp(v)	(cSVOPx(v)->op_sv \
				 ? &cSVOPx(v)->op_sv : &PAD_SVl((v)->op_targ))
#  define	cMETHOPx_rclass(v) PAD_SVl(cMETHOPx(v)->op_rclass_targ)
#else
#  define	cGVOPx_gv(o)	((GV*)cSVOPx(o)->op_sv)
#  ifndef PERL_CORE
#    define	IS_PADGV(v)	FALSE
#    define	IS_PADCONST(v)	FALSE
#  endif
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv)
#  define	cSVOPx_svp(v)	(&cSVOPx(v)->op_sv)
#  define	cMETHOPx_rclass(v) (cMETHOPx(v)->op_rclass_sv)
#endif

#  define	cMETHOPx_meth(v)	cSVOPx_sv(v)

#define	cGVOP_gv		cGVOPx_gv(PL_op)
#define	cGVOPo_gv		cGVOPx_gv(o)
#define	kGVOP_gv		cGVOPx_gv(kid)
#define cSVOP_sv		cSVOPx_sv(PL_op)
#define cSVOPo_sv		cSVOPx_sv(o)
#define kSVOP_sv		cSVOPx_sv(kid)

#ifndef PERL_CORE
#  define Nullop ((OP*)NULL)
#endif

/* Lowest byte of PL_opargs */
#define OA_MARK 1
#define OA_FOLDCONST 2
#define OA_RETSCALAR 4
#define OA_TARGET 8
#define OA_TARGLEX 16
#define OA_OTHERINT 32
#define OA_DANGEROUS 64
#define OA_DEFGV 128

/* The next 4 bits (8..11) encode op class information */
#define OCSHIFT 8

#define OA_CLASS_MASK (15 << OCSHIFT)

#define OA_BASEOP (0 << OCSHIFT)
#define OA_UNOP (1 << OCSHIFT)
#define OA_BINOP (2 << OCSHIFT)
#define OA_LOGOP (3 << OCSHIFT)
#define OA_LISTOP (4 << OCSHIFT)
#define OA_PMOP (5 << OCSHIFT)
#define OA_SVOP (6 << OCSHIFT)
#define OA_PADOP (7 << OCSHIFT)
#define OA_PVOP_OR_SVOP (8 << OCSHIFT)
#define OA_LOOP (9 << OCSHIFT)
#define OA_COP (10 << OCSHIFT)
#define OA_BASEOP_OR_UNOP (11 << OCSHIFT)
#define OA_FILESTATOP (12 << OCSHIFT)
#define OA_LOOPEXOP (13 << OCSHIFT)
#define OA_METHOP (14 << OCSHIFT)
#define OA_UNOP_AUX (15 << OCSHIFT)

/* Each remaining nybble of PL_opargs (i.e. bits 12..15, 16..19 etc)
 * encode the type for each arg */
#define OASHIFT 12

#define OA_SCALAR 1
#define OA_LIST 2
#define OA_AVREF 3
#define OA_HVREF 4
#define OA_CVREF 5
#define OA_FILEREF 6
#define OA_SCALARREF 7
#define OA_OPTIONAL 8

/* Op_REFCNT is a reference count at the head of each op tree: needed
 * since the tree is shared between threads, and between cloned closure
 * copies in the same thread. OP_REFCNT_LOCK/UNLOCK is used when modifying
 * this count.
 * The same mutex is used to protect the refcounts of the reg_trie_data
 * and reg_ac_data structures, which are shared between duplicated
 * regexes.
 */

#ifdef USE_ITHREADS
#  define OP_REFCNT_INIT		MUTEX_INIT(&PL_op_mutex)
#  ifdef PERL_CORE
#    define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#    define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  else
#    define OP_REFCNT_LOCK		op_refcnt_lock()
#    define OP_REFCNT_UNLOCK		op_refcnt_unlock()
#  endif
#  define OP_REFCNT_TERM		MUTEX_DESTROY(&PL_op_mutex)
#else
#  define OP_REFCNT_INIT		NOOP
#  define OP_REFCNT_LOCK		NOOP
#  define OP_REFCNT_UNLOCK		NOOP
#  define OP_REFCNT_TERM		NOOP
#endif

#define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#ifdef PERL_DEBUG_READONLY_OPS
#  define OpREFCNT_inc(o)		Perl_op_refcnt_inc(aTHX_ o)
#  define OpREFCNT_dec(o)		Perl_op_refcnt_dec(aTHX_ o)
#else
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : NULL)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#endif

/* flags used by Perl_load_module() */
#define PERL_LOADMOD_DENY		0x1	/* no Module */
#define PERL_LOADMOD_NOIMPORT		0x2	/* use Module () */
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* import arguments
						   are passed as a sin-
						   gle op tree, not a
						   list of SVs */

#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_TOKE_C)
#define ref(o, type) doref(o, type, TRUE)
#endif

/*
=head1 Optree Manipulation Functions

=for apidoc Am|OP*|LINKLIST|OP *o
Given the root of an optree, link the tree in execution order using the
C<op_next> pointers and return the first op executed.  If this has
already been done, it will not be redone, and C<< o->op_next >> will be
returned.  If C<< o->op_next >> is not already set, C<o> should be at
least an C<UNOP>.

=cut
*/

#define LINKLIST(o) ((o)->op_next ? (o)->op_next : op_linklist((OP*)o))

/* no longer used anywhere in core */
#ifndef PERL_CORE
#define cv_ckproto(cv, gv, p) \
   cv_ckproto_len_flags((cv), (gv), (p), (p) ? strlen(p) : 0, 0)
#endif

#ifdef PERL_CORE
#  define my(o)	my_attrs((o), NULL)
#endif

#ifdef USE_REENTRANT_API
#include "reentr.h"
#endif

#define NewOp(m,var,c,type)	\
	(var = (type *) Perl_Slab_Alloc(aTHX_ c*sizeof(type)))
#define NewOpSz(m,var,size)	\
	(var = (OP *) Perl_Slab_Alloc(aTHX_ size))
#define FreeOp(p) Perl_Slab_Free(aTHX_ p)

/*
 * The per-CV op slabs consist of a header (the opslab struct) and a bunch
 * of space for allocating op slots, each of which consists of two pointers
 * followed by an op.  The first pointer points to the next op slot.  The
 * second points to the slab.  At the end of the slab is a null pointer,
 * so that slot->opslot_next - slot can be used to determine the size
 * of the op.
 *
 * Each CV can have multiple slabs; opslab_next points to the next slab, to
 * form a chain.  All bookkeeping is done on the first slab, which is where
 * all the op slots point.
 *
 * Freed ops are marked as freed and attached to the freed chain
 * via op_next pointers.
 *
 * When there is more than one slab, the second slab in the slab chain is
 * assumed to be the one with free space available.  It is used when allo-
 * cating an op if there are no freed ops available or big enough.
 */

#ifdef PERL_CORE
struct opslot {
    /* keep opslot_next first */
    OPSLOT *	opslot_next;		/* next slot */
    OPSLAB *	opslot_slab;		/* owner */
    OP		opslot_op;		/* the op itself */
};

struct opslab {
    OPSLOT *	opslab_first;		/* first op in this slab */
    OPSLAB *	opslab_next;		/* next slab */
    OP *	opslab_freed;		/* chain of freed ops */
    size_t	opslab_refcnt;		/* number of ops */
# ifdef PERL_DEBUG_READONLY_OPS
    U16		opslab_size;		/* size of slab in pointers */
    bool	opslab_readonly;
# endif
    OPSLOT	opslab_slots;		/* slots begin here */
};

# define OPSLOT_HEADER		STRUCT_OFFSET(OPSLOT, opslot_op)
# define OPSLOT_HEADER_P	(OPSLOT_HEADER/sizeof(I32 *))
# define OpSLOT(o)		(assert_(o->op_slabbed) \
				 (OPSLOT *)(((char *)o)-OPSLOT_HEADER))
# define OpSLAB(o)		OpSLOT(o)->opslot_slab
# define OpslabREFCNT_dec(slab)      \
	(((slab)->opslab_refcnt == 1) \
	 ? opslab_free_nopad(slab)     \
	 : (void)--(slab)->opslab_refcnt)
  /* Variant that does not null out the pads */
# define OpslabREFCNT_dec_padok(slab) \
	(((slab)->opslab_refcnt == 1)  \
	 ? opslab_free(slab)		\
	 : (void)--(slab)->opslab_refcnt)
#endif

struct block_hooks {
    U32	    bhk_flags;
    void    (*bhk_start)	(pTHX_ int full);
    void    (*bhk_pre_end)	(pTHX_ OP **seq);
    void    (*bhk_post_end)	(pTHX_ OP **seq);
    void    (*bhk_eval)		(pTHX_ OP *const saveop);
};

/*
=head1 Compile-time scope hooks

=for apidoc mx|U32|BhkFLAGS|BHK *hk
Return the BHK's flags.

=for apidoc mx|void *|BhkENTRY|BHK *hk|which
Return an entry from the BHK structure.  C<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return C<NULL>.  The type of the return value depends on which
entry you ask for.

=for apidoc Amx|void|BhkENTRY_set|BHK *hk|which|void *ptr
Set an entry in the BHK structure, and set the flags to indicate it is
valid.  C<which> is a preprocessing token indicating which entry to set.
The type of C<ptr> depends on the entry.

=for apidoc Amx|void|BhkDISABLE|BHK *hk|which
Temporarily disable an entry in this BHK structure, by clearing the
appropriate flag.  C<which> is a preprocessor token indicating which
entry to disable.

=for apidoc Amx|void|BhkENABLE|BHK *hk|which
Re-enable an entry in this BHK structure, by setting the appropriate
flag.  C<which> is a preprocessor token indicating which entry to enable.
This will assert (under -DDEBUGGING) if the entry doesn't contain a valid
pointer.

=for apidoc mx|void|CALL_BLOCK_HOOKS|which|arg
Call all the registered block hooks for type C<which>.  C<which> is a
preprocessing token; the type of C<arg> depends on C<which>.

=cut
*/

#define BhkFLAGS(hk)		((hk)->bhk_flags)

#define BHKf_bhk_start	    0x01
#define BHKf_bhk_pre_end    0x02
#define BHKf_bhk_post_end   0x04
#define BHKf_bhk_eval	    0x08

#define BhkENTRY(hk, which) \
    ((BhkFLAGS(hk) & BHKf_ ## which) ? ((hk)->which) : NULL)

#define BhkENABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) |= BHKf_ ## which; \
	assert(BhkENTRY(hk, which)); \
    } STMT_END

#define BhkDISABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) &= ~(BHKf_ ## which); \
    } STMT_END

#define BhkENTRY_set(hk, which, ptr) \
    STMT_START { \
	(hk)->which = ptr; \
	BhkENABLE(hk, which); \
    } STMT_END

#define CALL_BLOCK_HOOKS(which, arg) \
    STMT_START { \
	if (PL_blockhooks) { \
	    SSize_t i; \
	    for (i = av_tindex(PL_blockhooks); i >= 0; i--) { \
		SV *sv = AvARRAY(PL_blockhooks)[i]; \
		BHK *hk; \
		\
		assert(SvIOK(sv)); \
		if (SvUOK(sv)) \
		    hk = INT2PTR(BHK *, SvUVX(sv)); \
		else \
		    hk = INT2PTR(BHK *, SvIVX(sv)); \
		\
		if (BhkENTRY(hk, which)) \
		    BhkENTRY(hk, which)(aTHX_ arg); \
	    } \
	} \
    } STMT_END

/* flags for rv2cv_op_cv */

#define RV2CVOPCV_MARK_EARLY     0x00000001
#define RV2CVOPCV_RETURN_NAME_GV 0x00000002
#define RV2CVOPCV_RETURN_STUB    0x00000004
#ifdef PERL_CORE /* behaviour of this flag is subject to change: */
# define RV2CVOPCV_MAYBE_NAME_GV  0x00000008
#endif
#define RV2CVOPCV_FLAG_MASK      0x0000000f /* all of the above */

#define op_lvalue(op,t) Perl_op_lvalue_flags(aTHX_ op,t,0)

/* flags for op_lvalue_flags */

#define OP_LVALUE_NO_CROAK 1

/*
=head1 Custom Operators

=for apidoc Am|U32|XopFLAGS|XOP *xop
Return the XOP's flags.

=for apidoc Am||XopENTRY|XOP *xop|which
Return a member of the XOP structure.  C<which> is a cpp token
indicating which entry to return.  If the member is not set
this will return a default value.  The return type depends
on C<which>.  This macro evaluates its arguments more than
once.  If you are using C<Perl_custom_op_xop> to retreive a
C<XOP *> from a C<OP *>, use the more efficient L</XopENTRYCUSTOM> instead.

=for apidoc Am||XopENTRYCUSTOM|const OP *o|which
Exactly like C<XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)> but more
efficient.  The C<which> parameter is identical to L</XopENTRY>.

=for apidoc Am|void|XopENTRY_set|XOP *xop|which|value
Set a member of the XOP structure.  C<which> is a cpp token
indicating which entry to set.  See L<perlguts/"Custom Operators">
for details about the available members and how
they are used.  This macro evaluates its argument
more than once.

=for apidoc Am|void|XopDISABLE|XOP *xop|which
Temporarily disable a member of the XOP, by clearing the appropriate flag.

=for apidoc Am|void|XopENABLE|XOP *xop|which
Reenable a member of the XOP which has been disabled.

=cut
*/

struct custom_op {
    U32		    xop_flags;    
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
};

/* return value of Perl_custom_op_get_field, similar to void * then casting but
   the U32 doesn't need truncation on 64 bit platforms in the caller, also
   for easier macro writing */
typedef union {
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
    XOP            *xop_ptr;
} XOPRETANY;

#define XopFLAGS(xop) ((xop)->xop_flags)

#define XOPf_xop_name	0x01
#define XOPf_xop_desc	0x02
#define XOPf_xop_class	0x04
#define XOPf_xop_peep	0x08

/* used by Perl_custom_op_get_field for option checking */
typedef enum {
    XOPe_xop_ptr = 0, /* just get the XOP *, don't look inside it */
    XOPe_xop_name = XOPf_xop_name,
    XOPe_xop_desc = XOPf_xop_desc,
    XOPe_xop_class = XOPf_xop_class,
    XOPe_xop_peep = XOPf_xop_peep
} xop_flags_enum;

#define XOPd_xop_name	PL_op_name[OP_CUSTOM]
#define XOPd_xop_desc	PL_op_desc[OP_CUSTOM]
#define XOPd_xop_class	OA_BASEOP
#define XOPd_xop_peep	((Perl_cpeep_t)0)

#define XopENTRY_set(xop, which, to) \
    STMT_START { \
	(xop)->which = (to); \
	(xop)->xop_flags |= XOPf_ ## which; \
    } STMT_END

#define XopENTRY(xop, which) \
    ((XopFLAGS(xop) & XOPf_ ## which) ? (xop)->which : XOPd_ ## which)

#define XopENTRYCUSTOM(o, which) \
    (Perl_custom_op_get_field(aTHX_ o, XOPe_ ## which).which)

#define XopDISABLE(xop, which) ((xop)->xop_flags &= ~XOPf_ ## which)
#define XopENABLE(xop, which) \
    STMT_START { \
	(xop)->xop_flags |= XOPf_ ## which; \
	assert(XopENTRY(xop, which)); \
    } STMT_END

#define Perl_custom_op_xop(x) \
    (Perl_custom_op_get_field(x, XOPe_xop_ptr).xop_ptr)

/*
=head1 Optree Manipulation Functions

=for apidoc Am|const char *|OP_NAME|OP *o
Return the name of the provided OP.  For core ops this looks up the name
from the op_type; for custom ops from the op_ppaddr.

=for apidoc Am|const char *|OP_DESC|OP *o
Return a short description of the provided OP.

=for apidoc Am|U32|OP_CLASS|OP *o
Return the class of the provided OP: that is, which of the *OP
structures it uses.  For core ops this currently gets the information out
of C<PL_opargs>, which does not always accurately reflect the type used.
For custom ops the type is returned from the registration, and it is up
to the registree to ensure it is accurate.  The value returned will be
one of the C<OA_>* constants from F<op.h>.

=for apidoc Am|bool|OP_TYPE_IS|OP *o|Optype type
Returns true if the given OP is not a C<NULL> pointer
and if it is of the given type.

The negation of this macro, C<OP_TYPE_ISNT> is also available
as well as C<OP_TYPE_IS_NN> and C<OP_TYPE_ISNT_NN> which elide
the NULL pointer check.

=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o|Optype type
Returns true if the given OP is not a NULL pointer and
if it is of the given type or used to be before being
replaced by an OP of type OP_NULL.

The negation of this macro, C<OP_TYPE_ISNT_AND_WASNT>
is also available as well as C<OP_TYPE_IS_OR_WAS_NN>
and C<OP_TYPE_ISNT_AND_WASNT_NN> which elide
the C<NULL> pointer check.

=for apidoc Am|bool|OpHAS_SIBLING|OP *o
Returns true if C<o> has a sibling

=for apidoc Am|OP*|OpSIBLING|OP *o
Returns the sibling of C<o>, or C<NULL> if there is no sibling

=for apidoc Am|void|OpMORESIB_set|OP *o|OP *sib
Sets the sibling of C<o> to the non-zero value C<sib>. See also C<L</OpLASTSIB_set>>
and C<L</OpMAYBESIB_set>>. For a higher-level interface, see
C<L</op_sibling_splice>>.

=for apidoc Am|void|OpLASTSIB_set|OP *o|OP *parent
Marks C<o> as having no further siblings. On C<PERL_OP_PARENT> builds, marks
o as having the specified parent. See also C<L</OpMORESIB_set>> and
C<OpMAYBESIB_set>. For a higher-level interface, see
C<L</op_sibling_splice>>.

=for apidoc Am|void|OpMAYBESIB_set|OP *o|OP *sib|OP *parent
Conditionally does C<OpMORESIB_set> or C<OpLASTSIB_set> depending on whether
C<sib> is non-null. For a higher-level interface, see C<L</op_sibling_splice>>.

=cut
*/

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_name) \
		    : PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM \
                    ? XopENTRYCUSTOM(o, xop_desc) \
		    : PL_op_desc[(o)->op_type])
#define OP_CLASS(o) ((o)->op_type == OP_CUSTOM \
		     ? XopENTRYCUSTOM(o, xop_class) \
		     : (PL_opargs[(o)->op_type] & OA_CLASS_MASK))

#define OP_TYPE_IS(o, type) ((o) && (o)->op_type == (type))
#define OP_TYPE_IS_NN(o, type) ((o)->op_type == (type))
#define OP_TYPE_ISNT(o, type) ((o) && (o)->op_type != (type))
#define OP_TYPE_ISNT_NN(o, type) ((o)->op_type != (type))

#define OP_TYPE_IS_OR_WAS_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      == (type) )

#define OP_TYPE_IS_OR_WAS(o, type) \
    ( (o) && OP_TYPE_IS_OR_WAS_NN(o, type) )

#define OP_TYPE_ISNT_AND_WASNT_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      != (type) )

#define OP_TYPE_ISNT_AND_WASNT(o, type) \
    ( (o) && OP_TYPE_ISNT_AND_WASNT_NN(o, type) )


#ifdef PERL_OP_PARENT
#  define OpHAS_SIBLING(o)	(cBOOL((o)->op_moresib))
#  define OpSIBLING(o)		(0 + (o)->op_moresib ? (o)->op_sibparent : NULL)
#  define OpMORESIB_set(o, sib) ((o)->op_moresib = 1, (o)->op_sibparent = (sib))
#  define OpLASTSIB_set(o, parent) \
       ((o)->op_moresib = 0, (o)->op_sibparent = (parent))
#  define OpMAYBESIB_set(o, sib, parent) \
       ((o)->op_sibparent = ((o)->op_moresib = cBOOL(sib)) ? (sib) : (parent))
#else
#  define OpHAS_SIBLING(o)	(cBOOL((o)->op_sibling))
#  define OpSIBLING(o)		(0 + (o)->op_sibling)
#  define OpMORESIB_set(o, sib) ((o)->op_moresib = 1, (o)->op_sibling = (sib))
#  define OpLASTSIB_set(o, parent) \
       ((o)->op_moresib = 0, (o)->op_sibling = NULL)
#  define OpMAYBESIB_set(o, sib, parent) \
       ((o)->op_moresib = cBOOL(sib), (o)->op_sibling = (sib))
#endif

#if !defined(PERL_CORE) && !defined(PERL_EXT)
/* for backwards compatibility only */
#  define OP_SIBLING(o)		OpSIBLING(o)
#endif

#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))

/*
=head1 Hook manipulation
*/

#ifdef USE_ITHREADS
#  define OP_CHECK_MUTEX_INIT		MUTEX_INIT(&PL_check_mutex)
#  define OP_CHECK_MUTEX_LOCK		MUTEX_LOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_UNLOCK		MUTEX_UNLOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_TERM		MUTEX_DESTROY(&PL_check_mutex)
#else
#  define OP_CHECK_MUTEX_INIT		NOOP
#  define OP_CHECK_MUTEX_LOCK		NOOP
#  define OP_CHECK_MUTEX_UNLOCK		NOOP
#  define OP_CHECK_MUTEX_TERM		NOOP
#endif


/* Stuff for OP_MULTDEREF/pp_multideref. */

/* actions */

/* Load another word of actions/flag bits. Must be 0 */
#define MDEREF_reload                       0

#define MDEREF_AV_pop_rv2av_aelem           1
#define MDEREF_AV_gvsv_vivify_rv2av_aelem   2
#define MDEREF_AV_padsv_vivify_rv2av_aelem  3
#define MDEREF_AV_vivify_rv2av_aelem        4
#define MDEREF_AV_padav_aelem               5
#define MDEREF_AV_gvav_aelem                6

#define MDEREF_HV_pop_rv2hv_helem           8
#define MDEREF_HV_gvsv_vivify_rv2hv_helem   9
#define MDEREF_HV_padsv_vivify_rv2hv_helem 10
#define MDEREF_HV_vivify_rv2hv_helem       11
#define MDEREF_HV_padhv_helem              12
#define MDEREF_HV_gvhv_helem               13

#define MDEREF_ACTION_MASK                0xf

/* key / index type */

#define MDEREF_INDEX_none   0x00 /* run external ops to generate index */
#define MDEREF_INDEX_const  0x10 /* index is const PV/UV */
#define MDEREF_INDEX_padsv  0x20 /* index is lexical var */
#define MDEREF_INDEX_gvsv   0x30 /* index is GV */

#define MDEREF_INDEX_MASK   0x30

/* bit flags */

#define MDEREF_FLAG_last    0x40 /* the last [ah]elem; PL_op flags apply */

#define MDEREF_MASK         0x7F
#define MDEREF_SHIFT           7

#if defined(PERL_IN_DOOP_C) || defined(PERL_IN_PP_C)
static const char * const deprecated_above_ff_msg
    = "Use of strings with code points over 0xFF as arguments to "
      "%s operator is deprecated";
#endif


/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.18
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d27 2
a28 1
 *	op_spare	Two spare bits
d39 7
a45 2
#ifdef PERL_MAD
#  define MADPROP_IN_BASEOP	MADPROP*	op_madprop;
d47 1
a47 1
#  define MADPROP_IN_BASEOP
a49 2
typedef PERL_BITFIELD16 Optype;

d55 1
a55 1
    OP*		op_sibling;		\
a56 1
    MADPROP_IN_BASEOP			\
d64 2
a65 1
    PERL_BITFIELD16 op_spare:2;		\
d70 1
a70 1
/* If op_type:9 is changed to :10, also change PUSHEVAL in cop.h.
d116 2
a117 1
				/*  On OP_LEAVE, don't restore curpm. */
d122 2
a123 1
				/*  On OP_ENTERSUB || OP_NULL, saw a "do". */
a127 1
				/*  On OP_READLINE, was <$filehandle> */
d138 4
a141 3
				/*  On OP_HELEM and OP_HSLICE, localization will be followed
				    by assignment, so do not wipe the target if it is special
				    (e.g. a glob or a magic SV) */
d153 5
d163 2
a164 1
#define GIMME \
d170 1
a171 2
/* Lower bits of op_private often carry the number of arguments, as
 * set by newBINOP, newUNOP and ck_fun */
d173 2
a174 2
/* NOTE: OP_NEXTSTATE and OP_DBSTATE (i.e. COPs) carry NATIVE_HINTS
 * in op_private */
a175 2
/* Private for lvalues */
#define OPpLVAL_INTRO	128	/* Lvalue must be localized or lvalue sub */
a176 29
/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */

/* Private for OP_LEAVE, OP_LEAVESUB, OP_LEAVESUBLV and OP_LEAVEWRITE */
#define OPpREFCOUNTED		64	/* op_targ carries a refcount */

/* Private for OP_LEAVE and OP_LEAVELOOP */
#define OPpLVALUE		128	/* Do not copy return value */

/* Private for OP_AASSIGN */
#define OPpASSIGN_COMMON	64	/* Left & right have syms in common. */

/* Private for OP_SASSIGN */
#define OPpASSIGN_BACKWARDS	64	/* Left & right switched. */
#define OPpASSIGN_CV_TO_GV	128	/* Possible optimisation for constants. */

/* Private for OP_MATCH and OP_SUBST{,CONT} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

/* Private for OP_TRANS */
#define OPpTRANS_FROM_UTF	1
#define OPpTRANS_TO_UTF		2
#define OPpTRANS_IDENTICAL	4	/* right side is same as left */
#define OPpTRANS_SQUASH		8
    /* 16 is used for OPpTARGET_MY */
#define OPpTRANS_COMPLEMENT	32
#define OPpTRANS_GROWS		64
#define OPpTRANS_DELETE		128
a178 2
/* Private for OP_REPEAT */
#define OPpREPEAT_DOLIST	64	/* List replication. */
a179 29
/* Private for OP_RV2GV, OP_RV2SV, OP_AELEM, OP_HELEM, OP_PADSV */
#define OPpDEREF		(32|64)	/* autovivify: Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */

/* OP_ENTERSUB and OP_RV2CV flags

Flags are set on entersub and rv2cv in three phases:
  parser  - the parser passes the flag to the op constructor
  check   - the check routine called by the op constructor sets the flag
  context - application of scalar/ref/lvalue context applies the flag

In the third stage, an entersub op might turn into an rv2cv op (undef &foo,
\&foo, lock &foo, exists &foo, defined &foo).  The two places where that
happens (op_lvalue_flags and doref in op.c) need to make sure the flags do
not conflict.  Flags applied in the context phase are only set when there
is no conversion of op type.

  bit  entersub flag       phase   rv2cv flag             phase
  ---  -------------       -----   ----------             -----
    1  OPpENTERSUB_INARGS  context OPpMAY_RETURN_CONSTANT context
    2  HINT_STRICT_REFS    check   HINT_STRICT_REFS       check
    4  OPpENTERSUB_HASTARG check
    8                              OPpENTERSUB_AMPER      parser
   16  OPpENTERSUB_DB      check
   32  OPpDEREF_AV         context
   64  OPpDEREF_HV         context
  128  OPpLVAL_INTRO       context OPpENTERSUB_NOPAREN    parser
d181 4
a184 1
*/
d186 7
a192 9
  /* OP_ENTERSUB only */
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
#define OPpENTERSUB_HASTARG	4	/* Called from OP tree. */
#define OPpENTERSUB_INARGS	1	/* Lval used as arg to a sub. */
/* used by OPpDEREF             (32|64) */
/* used by HINT_STRICT_REFS     2          */
  /* Mask for OP_ENTERSUB flags, the absence of which must be propagated
     in dynamic context */
#define OPpENTERSUB_LVAL_MASK (OPpLVAL_INTRO|OPpENTERSUB_INARGS)
d194 5
a198 89
  /* OP_RV2CV only */
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

  /* OP_GV only */
#define OPpEARLY_CV		32	/* foo() called before sub foo was parsed */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* OP_RV2[AH]V OP_[AH]SLICE */
#define OPpSLICEWARNING		4	/* warn about @@hash{$scalar} */
  /* OP_RV2[SAH]V, OP_GVSV, OP_ENTERITER only */
#define OPpOUR_INTRO		16	/* Variable was in an our() */
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM, OP_[AH]SLICE OP_AV2ARYLEN,
     OP_R?KEYS, OP_SUBSTR, OP_POS, OP_VEC */
#define OPpMAYBE_LVSUB		8	/* We might be an lvalue to return */
  /* OP_RV2HV and OP_PADHV */
#define OPpTRUEBOOL		32	/* %hash in (%hash || $foo) in
					   void context */
#define OPpMAYBE_TRUEBOOL	64	/* %hash in (%hash || $foo) where
					   cx is not known till run time */

  /* OP_SUBSTR only */
#define OPpSUBSTR_REPL_FIRST	16	/* 1st arg is replacement string */

  /* OP_PADSV only */
#define OPpPAD_STATE		16	/* is a "state" pad */
  /* for OP_RV2?V, lower bits carry hints (currently only HINT_STRICT_REFS) */

  /* OP_PADRANGE only */
  /* bit 7 is OPpLVAL_INTRO */
#define OPpPADRANGE_COUNTMASK	127	/* bits 6..0 hold target range, */
#define OPpPADRANGE_COUNTSHIFT	7	/* 7 bits in total */

  /* OP_RV2GV only */
#define OPpDONT_INIT_GV		4	/* Call gv_fetchpv with GV_NOINIT */
/* (Therefore will return whatever is currently in the symbol table, not
   guaranteed to be a PVGV)  */
#define OPpALLOW_FAKE		16	/* OK to return fake glob */

/* Private for OP_ENTERITER and OP_ITER */
#define OPpITER_REVERSED	4	/* for (reverse ...) */
#define OPpITER_DEF		8	/* for $_ or for my $_ */

/* Private for OP_CONST */
#define	OPpCONST_NOVER		2	/* no 6; */
#define	OPpCONST_SHORTCIRCUIT	4	/* eg the constant 5 in (5 || foo) */
#define	OPpCONST_STRICT		8	/* bareword subject to strict 'subs' */
#define OPpCONST_ENTERED	16	/* Has been entered as symbol. */
#define OPpCONST_BARE		64	/* Was a bare word (filehandle?). */

/* Private for OP_FLIP/FLOP */
#define OPpFLIP_LINENUM		64	/* Range arg potentially a line num. */

/* Private for OP_LIST */
#define OPpLIST_GUESSED		64	/* Guessed that pushmark was needed. */

/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */
/* Also OPpLVAL_INTRO (128) */

/* Private for OP_EXISTS */
#define OPpEXISTS_SUB		64	/* Checking for &sub, not {} or [].  */

/* Private for OP_SORT */
#define OPpSORT_NUMERIC		1	/* Optimized away { $a <=> $b } */
#define OPpSORT_INTEGER		2	/* Ditto while under "use integer" */
#define OPpSORT_REVERSE		4	/* Reversed sort */
#define OPpSORT_INPLACE		8	/* sort in-place; eg @@a = sort @@a */
#define OPpSORT_DESCEND		16	/* Descending sort */
#define OPpSORT_QSORT		32	/* Use quicksort (not mergesort) */
#define OPpSORT_STABLE		64	/* Use a stable algorithm */

/* Private for OP_REVERSE */
#define OPpREVERSE_INPLACE	8	/* reverse in-place (@@a = reverse @@a) */

/* Private for OP_OPEN and OP_BACKTICK */
#define OPpOPEN_IN_RAW		16	/* binmode(F,":raw") on input fh */
#define OPpOPEN_IN_CRLF		32	/* binmode(F,":crlf") on input fh */
#define OPpOPEN_OUT_RAW		64	/* binmode(F,":raw") on output fh */
#define OPpOPEN_OUT_CRLF	128	/* binmode(F,":crlf") on output fh */

/* Private for COPs */
#define OPpHUSH_VMSISH		32	/* hush DCL exit msg vmsish mode*/
/* Note: Used for NATIVE_HINTS (shifted from the values in PL_hints),
	 currently defined by vms/vmsish.h:
				64
				128
 */
a199 26
/* Private for OP_FTXXX */
#define OPpFT_ACCESS		2	/* use filetest 'access' */
#define OPpFT_STACKED		4	/* stacked filetest, as "-f" in "-f -x $f" */
#define OPpFT_STACKING		8	/* stacking filetest, as "-x" in "-f -x $f" */
#define OPpFT_AFTER_t		16	/* previous op was -t */

/* Private for OP_(MAP|GREP)(WHILE|START) */
#define OPpGREP_LEX		2	/* iterate over lexical $_ */
    
/* Private for OP_ENTEREVAL */
#define OPpEVAL_HAS_HH		2	/* Does it have a copy of %^H */
#define OPpEVAL_UNICODE		4
#define OPpEVAL_BYTES		8
#define OPpEVAL_COPHH		16	/* Construct %^H from cop hints */
#define OPpEVAL_RE_REPARSING	32	/* eval_sv(..., G_RE_REPARSING) */
    
/* Private for OP_CALLER, OP_WANTARRAY and OP_RUNCV */
#define OPpOFFBYONE		128	/* Treat caller(1) as caller(2) */

/* Private for OP_COREARGS */
/* These must not conflict with OPpDONT_INIT_GV or OPpALLOW_FAKE.
   See pp.c:S_rv2gv. */
#define OPpCOREARGS_DEREF1	1	/* Arg 1 is a handle constructor */
#define OPpCOREARGS_DEREF2	2	/* Arg 2 is a handle constructor */
#define OPpCOREARGS_SCALARMOD	64	/* \$ rather than \[$@@%*] */
#define OPpCOREARGS_PUSHMARK	128	/* Call pp_pushmark */
a200 2
/* Private for OP_(LAST|REDO|NEXT|GOTO|DUMP) */
#define OPpPV_IS_UTF8		128	/* label is in UTF8 */
a201 2
/* Private for OP_SPLIT */
#define OPpSPLIT_IMPLIM		128	/* implicit limit */
d212 6
d236 16
d302 31
a332 3
/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+6)
d335 1
a335 1
#define PMf_RETAINT	(1<<(PMf_BASE_SHIFT+0))
d340 1
a340 1
#define PMf_ONCE	(1<<(PMf_BASE_SHIFT+1))
d343 1
a343 1
#define PMf_USED        (1<<(PMf_BASE_SHIFT+3))
d346 1
a346 1
#define PMf_CONST	(1<<(PMf_BASE_SHIFT+4))
d349 1
a349 1
#define PMf_KEEP	(1<<(PMf_BASE_SHIFT+5))
d351 1
a351 1
#define PMf_GLOBAL	(1<<(PMf_BASE_SHIFT+6))	/* pattern had a g modifier */
d354 1
a354 1
#define PMf_CONTINUE	(1<<(PMf_BASE_SHIFT+7))
d357 1
a357 1
#define PMf_EVAL	(1<<(PMf_BASE_SHIFT+8))
d360 1
a360 1
#define PMf_NONDESTRUCT	(1<<(PMf_BASE_SHIFT+9))
d363 1
a363 1
#define PMf_HAS_CV	(1<<(PMf_BASE_SHIFT+10))
d367 1
a367 1
#define PMf_CODELIST_PRIVATE	(1<<(PMf_BASE_SHIFT+11))
d372 2
a373 2
#define PMf_IS_QR	(1<<(PMf_BASE_SHIFT+12))
#define PMf_USE_RE_EVAL	(1<<(PMf_BASE_SHIFT+13)) /* use re'eval' in scope */
d375 5
a379 1
#if PMf_BASE_SHIFT+13 > 31
d432 12
a443 10
#define cUNOPx(o)	((UNOP*)o)
#define cBINOPx(o)	((BINOP*)o)
#define cLISTOPx(o)	((LISTOP*)o)
#define cLOGOPx(o)	((LOGOP*)o)
#define cPMOPx(o)	((PMOP*)o)
#define cSVOPx(o)	((SVOP*)o)
#define cPADOPx(o)	((PADOP*)o)
#define cPVOPx(o)	((PVOP*)o)
#define cCOPx(o)	((COP*)o)
#define cLOOPx(o)	((LOOP*)o)
d446 1
d458 1
d470 1
d484 3
a486 3
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && isGV_with_GP(v) \
				 && GvIN_PAD(v))
#  define	IS_PADCONST(v) \
d488 1
d493 1
d496 4
a499 2
#  define	IS_PADGV(v)	FALSE
#  define	IS_PADCONST(v)	FALSE
d502 1
d505 2
d528 1
a528 1
/* The next 4 bits encode op class information */
d547 2
d550 2
a553 1
/* Remaining nybbles of PL_opargs */
d601 4
a604 1
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* use Module (...) */
d617 1
a617 1
returned.  If C<< o->op_next >> is not already set, I<o> should be at
d716 1
a716 1
Return an entry from the BHK structure.  I<which> is a preprocessor token
d718 1
a718 1
this will return NULL.  The type of the return value depends on which
d723 2
a724 2
valid.  I<which> is a preprocessing token indicating which entry to set.
The type of I<ptr> depends on the entry.
d728 1
a728 1
appropriate flag.  I<which> is a preprocessor token indicating which
d733 1
a733 1
flag.  I<which> is a preprocessor token indicating which entry to enable.
d738 2
a739 2
Call all the registered block hooks for type I<which>.  I<which> is a
preprocessing token; the type of I<arg> depends on I<which>.
d795 5
d814 1
a814 1
Return a member of the XOP structure.  I<which> is a cpp token
d817 1
a817 1
on I<which>.  This macro evaluates its arguments more than
d823 1
a823 1
efficient.  The I<which> parameter is identical to L</XopENTRY>.
d826 1
a826 1
Set a member of the XOP structure.  I<which> is a cpp token
d916 1
a916 1
of PL_opargs, which does not always accurately reflect the type used.
d919 1
a919 1
one of the OA_* constants from op.h.
d922 1
a922 1
Returns true if the given OP is not a NULL pointer
d937 22
a958 1
the NULL pointer check.
a995 2
#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))
d997 17
a1013 14
#ifdef PERL_MAD
#  define MAD_NULL 1
#  define MAD_PV 2
#  define MAD_OP 3
#  define MAD_SV 4

struct madprop {
    MADPROP* mad_next;
    void *mad_val;
    U32 mad_vlen;
/*    short mad_count; */
    char mad_key;
    char mad_type;
};
d1015 3
a1017 5
struct token {
    I32 tk_type;
    YYSTYPE tk_lval;
    MADPROP* tk_mad;
};
d1020 2
a1021 74
/*
 * Values that can be held by mad_key :
 * ^       unfilled head spot
 * ,       literal ,
 * ;       literal ; (blank if implicit ; at end of block)
 * :       literal : from ?: or attr list
 * +       unary +
 * ?       literal ? from ?:
 * (       literal (
 * )       literal )
 * [       literal [
 * ]       literal ]
 * {       literal {
 * }       literal }
 * @@       literal @@ sigil
 * $       literal $ sigil
 * *       literal * sigil
 * !       use is source filtered
 * &       & or sub
 * #       whitespace/comment following ; or }
 * #       $# sigil
 * 1       1st ; from for(;;)
 * 1       retired protasis
 * 2       2nd ; from for(;;)
 * 2       retired apodosis
 * 3       C-style for list
 * a       sub or var attributes
 * a       non-method arrow operator
 * A       method arrow operator
 * A       use import args
 * b       format block
 * B       retired stub block
 * C       constant conditional op
 * d       declarator
 * D       do block
 * e       unreached "else" (see C)
 * e       expression producing E
 * E       tr/E/R/, /E/
 * f       folded constant op
 * F       peg op for format
 * g       op was forced to be a word
 * i       if/unless modifier
 * I       if/elsif/unless statement
 * k       local declarator
 * K       retired kid op
 * l       last index of array ($#foo)
 * L       label
 * m       modifier on regex
 * n       sub or format name
 * o       current operator/declarator name
 * o       else/continue
 * O       generic optimized op
 * p       peg to hold extra whitespace at statement level
 * P       peg op for package declaration
 * q       opening quote
 * =       quoted material
 * Q       closing quote
 * Q       optimized qw//
 * r       expression producing R
 * R       tr/E/R/ s/E/R/
 * s       sub signature
 * S       use import stub (no import)
 * S       retired sort block
 * t       unreached "then" (see C)
 * U       use import op
 * v       private sv of for loop
 * V       use version
 * w       while/until modifier
 * W       while/for statement
 * x       optimized qw
 * X       random thing
 * _       whitespace/comments preceding anything else
 * ~       =~ operator
 */
d1039 47
a1086 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d1008 1
a1008 1
=for apidoc Am|bool|OP_TYPE_IS|OP *o, Optype type
d1016 1
a1016 1
=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o, Optype type
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d960 1
a960 1
    XOPe_xop_peep = XOPf_xop_peep,
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d26 2
a27 1
 *	op_spare	Three spare bits
d60 2
a61 1
    PERL_BITFIELD16 op_spare:3;		\
d83 1
a83 1
respectively. See L<perlcall> for a usage example.
d146 1
d175 3
d208 26
d239 1
a239 1
/* used by HINT_STRICT_SUBS     2          */
d253 2
a293 1
#define OPpCONST_FOLDED		128	/* Result of constant folding */
d326 7
a332 3
/* Private for OP_EXIT, HUSH also for OP_DIE */
#define OPpHUSH_VMSISH		64	/* hush DCL exit msg vmsish mode*/
#define OPpEXIT_VMSISH		128	/* exit(0) vs. exit(1) vmsish mode*/
d364 3
d399 1
a399 1
    IV          op_pmoffset;
d698 1
a698 1
#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C)
d707 1
a707 1
C<op_next> pointers and return the first op executed. If this has
d709 1
a709 1
returned. If C<< o->op_next >> is not already set, I<o> should be at
d808 3
a810 3
Return an entry from the BHK structure. I<which> is a preprocessor token
indicating which entry to return. If the appropriate flag is not set
this will return NULL. The type of the return value depends on which
d815 1
a815 1
valid. I<which> is a preprocessing token indicating which entry to set.
d820 1
a820 1
appropriate flag. I<which> is a preprocessor token indicating which
d825 1
a825 1
flag. I<which> is a preprocessor token indicating which entry to enable.
d830 1
a830 1
Call all the registered block hooks for type I<which>. I<which> is a
d866 2
a867 2
	    I32 i; \
	    for (i = av_len(PL_blockhooks); i >= 0; i--) { \
d901 10
a910 3
Return a member of the XOP structure. I<which> is a cpp token indicating
which entry to return. If the member is not set this will return a
default value. The return type depends on I<which>.
d913 5
a917 3
Set a member of the XOP structure. I<which> is a cpp token indicating
which entry to set. See L<perlguts/"Custom Operators"> for details about
the available members and how they are used.
d936 11
d954 9
d977 3
d987 3
d994 1
a994 1
Return the name of the provided OP. For core ops this looks up the name
d1002 1
a1002 1
structures it uses. For core ops this currently gets the information out
d1005 1
a1005 1
to the registree to ensure it is accurate. The value returned will be
d1008 18
d1030 1
a1030 1
		    ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_name) \
d1033 1
a1033 1
		    ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_desc) \
d1036 1
a1036 1
		     ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_class) \
d1039 25
a1063 1
#define newSUB(f, o, p, b)	Perl_newATTRSUB(aTHX_ (f), (o), (p), NULL, (b))
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d22 5
a26 11
 *
 *			See the comments in S_clear_yystack() for more
 *			details on the following three flags:
 *
 *	op_latefree	tell op_free() to clear this op (and free any kids)
 *			but not yet deallocate the struct. This means that
 *			the op may be safely op_free()d multiple times
 *	op_latefreed	an op_latefree op has been op_free()d
 *	op_attached	this op (sub)tree has been attached to a CV
 *
 *	op_spare	three spare bits!
d56 3
a58 3
    PERL_BITFIELD16 op_latefree:1;	\
    PERL_BITFIELD16 op_latefreed:1;	\
    PERL_BITFIELD16 op_attached:1;	\
d69 1
d71 1
a71 4
	(((op)->op_flags & OPf_WANT) == OPf_WANT_VOID   ? G_VOID   : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_SCALAR ? G_SCALAR : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_LIST   ? G_ARRAY   : \
	 dfl)
d118 1
a118 1
				/*  On pushre, rx is used as part of split, e.g. split " " */
d143 1
d179 1
a179 1
/* Private for OP_MATCH and OP_SUBST{,CONST} */
d226 5
d239 5
d260 1
a260 1
#define OPpCONST_WARNING	128	/* Was a $^W translated to constant. */
d311 1
d375 1
a375 4
	struct {
            char *	op_pmstashpv;	/* Only used in OP_MATCH, with PMf_ONCE set */
            U32     op_pmstashflags;  /* currently only SVf_UTF8 or 0 */
        } op_pmstashthr;
d380 1
d416 1
a416 4
/* replacement contains variables */
#define PMf_MAYBE_CONST (1<<(PMf_BASE_SHIFT+2))

/* PMf_ONCE has matched successfully.  Not used under threading. */
d436 14
a449 1
#if PMf_BASE_SHIFT+9 > 31
d455 7
a461 24
#  define PmopSTASHPV(o)						\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASHPV_set(o,pv)	({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv = savesharedpv(pv));	\
    })
#  else
#    define PmopSTASHPV_set(o,pv)					\
    ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv = savesharedpv(pv))
#  endif
#  define PmopSTASH_flags(o)           ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashflags)
#  define PmopSTASH_flags_set(o,flags) ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashflags = flags)
#  define PmopSTASH(o)         (PmopSTASHPV(o)                                     \
                                ? gv_stashpv((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv,   \
                                            GV_ADD | PmopSTASH_flags(o)) : NULL)
#  define PmopSTASH_set(o,hv)  (PmopSTASHPV_set(o, (hv) ? HvNAME_get(hv) : NULL), \
                                PmopSTASH_flags_set(o,                            \
                                            ((hv) && HvNAME_HEK(hv) &&           \
                                                        HvNAMEUTF8(hv))           \
                                                ? SVf_UTF8                        \
                                                : 0))
#  define PmopSTASH_free(o)	PerlMemShared_free(PmopSTASHPV(o))

d473 2
a474 1
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
d476 1
a476 5
#  define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))
/* Note that if this becomes non-empty, then S_forget_pmop in op.c will need
   changing */
#  define PmopSTASH_free(o)    
#endif
d551 2
a552 1
#  define	IS_PADCONST(v)	(v && SvREADONLY(v))
a690 1
#if defined(PL_OP_SLAB_ALLOC)
d696 55
a750 7
#else
#define NewOp(m, var, c, type)	\
	(var = (MEM_WRAP_CHECK_(c,type) \
	 (type*)PerlMemShared_calloc(c, sizeof(type))))
#define NewOpSz(m, var, size)	\
	(var = (OP*)PerlMemShared_calloc(1, size))
#define FreeOp(p) PerlMemShared_free(p)
d1065 1
a1065 1
 * indent-tabs-mode: t
d1068 1
a1068 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d39 1
d57 1
a57 1
    OP*		(CPERLscope(*op_ppaddr))(pTHX);		\
d89 1
a89 1
respectively.
a125 1
				/*  On OP_ENTERITER, loop var is per-thread */
a132 1
				/*  On OP_AELEMFAST, indiciates pad var */
d134 2
a135 2
				/*  On OP_ENTERWHEN, there's no condition */
				/*  On OP_BREAK, an implicit break */
a138 1
				/*  On OP_ENTER, store caller context */
d142 9
d163 5
a167 2
/* NOTE: OP_NEXTSTATE, OP_DBSTATE, and OP_SETSTATE (i.e. COPs) carry lower
 * bits of PL_hints in op_private */
d172 4
d208 1
d211 9
a219 3
#define OPpENTERSUB_HASTARG	32	/* Called from OP tree. */
#define OPpENTERSUB_NOMOD	64	/* Immune to mod() for :attrlist. */
  /* OP_ENTERSUB and OP_RV2CV only */
d222 2
a223 1
#define OPpENTERSUB_INARGS	4	/* Lval used as arg to a sub. */
d228 1
a228 1
  /* OP_RV2?V, OP_GVSV, OP_ENTERITER only */
d230 2
a231 1
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM */
d233 4
d245 1
a245 7

  /* OP_RV2CV only */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */
d254 1
a254 1
#define	OPpCONST_STRICT		8	/* bearword subject to strict 'subs' */
a255 1
#define OPpCONST_ARYBASE	32	/* Was a $[ translated to constant. */
d296 3
a298 1
#define OPpFT_STACKED		4	/* stacked filetest, as in "-f -x $f" */
d305 3
d309 14
d371 4
a374 1
	char *	op_pmstashpv;	/* Only used in OP_MATCH, with PMf_ONCE set */
d402 28
d431 5
a435 29
#define PMf_RETAINT	0x00000040	/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x00000080	/* match successfully only once per
                                           reset, with related flag RXf_USED
                                           in re->extflags holding state.
					   This is used only for ?? matches,
					   and only on OP_MATCH and OP_QR */

#define PMf_UNUSED	0x00000100	/* free for use */
#define PMf_MAYBE_CONST	0x00000200	/* replacement contains variables */

#define PMf_USED        0x00000400	/* PMf_ONCE has matched successfully.
                                           Not used under threading. */

#define PMf_CONST	0x00000800	/* subst replacement is constant */
#define PMf_KEEP	0x00001000	/* keep 1st runtime pattern forever */
#define PMf_GLOBAL	0x00002000	/* pattern had a g modifier */
#define PMf_CONTINUE	0x00004000	/* don't reset pos() if //g fails */
#define PMf_EVAL	0x00008000	/* evaluating replacement as expr */

/* The following flags have exact equivalents in regcomp.h with the prefix RXf_
 * which are stored in the regexp->extflags member. If you change them here,
 * you have to change them there, and vice versa.
 */
#define PMf_MULTILINE	0x00000001	/* assume multiple lines */
#define PMf_SINGLELINE	0x00000002	/* assume single line */
#define PMf_FOLD	0x00000004	/* case insensitivity */
#define PMf_EXTENDED	0x00000008	/* chuck embedded whitespace */
#define PMf_KEEPCOPY	0x00000010	/* copy the string when matching */
#define PMf_LOCALE	0x00000020	/* use locale for character types */
d437 3
a439 2
/* mask of bits that need to be transfered to re->extflags */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED|PMf_KEEPCOPY)
d444 1
a444 1
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstashpv : NULL)
d448 1
a448 1
	((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv));	\
d452 1
a452 1
    ((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv))
d454 11
a464 3
#  define PmopSTASH(o)		(PmopSTASHPV(o) \
				 ? gv_stashpv((o)->op_pmstashstartu.op_pmstashpv,GV_ADD) : NULL)
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME_get(hv) : NULL))
d583 1
a583 1
/* Lowest byte-and-a-bit of PL_opargs */
d588 1
a588 1
#define OA_RETINTEGER 16
a591 1
#define OA_TARGLEX 256
d594 1
a594 1
#define OCSHIFT 9
d613 1
a613 1
#define OASHIFT 13
d669 15
d687 1
a687 1
   cv_ckproto_len((cv), (gv), (p), (p) ? strlen(p) : 0)
d713 195
d1004 16
@


1.12
log
@Merge in perl 5.10.1
@
text
@d80 1
a80 4
#define OP_GIMME_REVERSE(flags)			\
	((flags & G_VOID) ? OPf_WANT_VOID :	\
	(flags & G_ARRAY) ? OPf_WANT_LIST :	\
			    OPf_WANT_SCALAR)
a114 2
				/*  On OP_CONST, value is the hints hash for
				    eval, so return a copy from pp_const() */
d140 4
d247 1
d261 3
a276 7
#define OP_IS_FILETEST_ACCESS(op) 		\
	(((op)->op_type) == OP_FTRREAD  ||	\
	 ((op)->op_type) == OP_FTRWRITE ||	\
	 ((op)->op_type) == OP_FTREXEC  ||	\
	 ((op)->op_type) == OP_FTEREAD  ||	\
	 ((op)->op_type) == OP_FTEWRITE ||	\
	 ((op)->op_type) == OP_FTEEXEC)
d340 2
a341 1
#define PM_GETRE(o)     (INT2PTR(REGEXP*,SvIVX(PL_regex_pad[(o)->op_pmoffset])))
d344 6
d351 3
a353 9
                            const REGEXP *const slosh = (r);		\
                            PM_SETRE_OFFSET((o), PTR2IV(slosh));	\
                        } STMT_END
/* Actually you can assign any IV, not just an offset. And really should it be
   UV? */
#define PM_SETRE_OFFSET(o,iv) \
			STMT_START { \
                            SV* const sv = PL_regex_pad[(o)->op_pmoffset]; \
                            sv_setiv(sv, (iv)); \
a354 6

#  ifndef PERL_CORE
/* No longer used anywhere in the core.  Migrate to Devel::PPPort?  */
#define PM_GETRE_SAFE(o) (PL_regex_pad ? PM_GETRE(o) : (REGEXP*)0)
#define PM_SETRE_SAFE(o,r) if (PL_regex_pad) PM_SETRE(o,r)
#  endif
a357 4
#  ifndef PERL_CORE
#define PM_GETRE_SAFE PM_GETRE
#define PM_SETRE_SAFE PM_SETRE
#  endif
d361 2
a362 2
#define PMf_RETAINT	0x0001		/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x0002		/* match successfully only once per
d368 2
a369 2
#define PMf_UNUSED	0x0004		/* free for use */
#define PMf_MAYBE_CONST	0x0008		/* replacement contains variables */
d371 1
a371 1
#define PMf_USED        0x0010          /* PMf_ONCE has matched successfully.
d374 5
a378 5
#define PMf_CONST	0x0040		/* subst replacement is constant */
#define PMf_KEEP	0x0080		/* keep 1st runtime pattern forever */
#define PMf_GLOBAL	0x0100		/* pattern had a g modifier */
#define PMf_CONTINUE	0x0200		/* don't reset pos() if //g fails */
#define PMf_EVAL	0x0400		/* evaluating replacement as expr */
d384 6
a389 6
#define PMf_LOCALE	0x00800		/* use locale for character types */
#define PMf_MULTILINE	0x01000		/* assume multiple lines */
#define PMf_SINGLELINE	0x02000		/* assume single line */
#define PMf_FOLD	0x04000		/* case insensitivity */
#define PMf_EXTENDED	0x08000		/* chuck embedded whitespace */
#define PMf_KEEPCOPY	0x10000		/* copy the string when matching */
d524 3
a526 1
#define Nullop ((OP*)NULL)
d621 4
d652 1
a652 1
    const void *mad_val;
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d48 2
d59 6
a64 6
    unsigned	op_type:9;		\
    unsigned	op_opt:1;		\
    unsigned	op_latefree:1;		\
    unsigned	op_latefreed:1;		\
    unsigned	op_attached:1;		\
    unsigned	op_spare:3;		\
d69 5
d80 5
d199 1
a199 1
  /* OP_RV2CV only */
a260 3
/* Private for OP_THREADSV */
#define OPpDONE_SVREF		64	/* Been through newSVREF once */

d345 10
a354 1
#define PM_SETRE(o,r)   STMT_START { \
d356 1
a356 1
                            sv_setiv(sv, PTR2IV(r)); \
d358 3
d363 1
d367 1
d370 1
d394 2
a395 1
 * which are stored in the regexp->extflags member.
d537 1
a537 1
#define Nullop Null(OP*)
d618 3
a620 3
#define PERL_LOADMOD_DENY		0x1
#define PERL_LOADMOD_NOIMPORT		0x2
#define PERL_LOADMOD_IMPORT_OPS		0x4
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005 by Larry Wall and others
d20 13
d40 4
a43 2
#ifdef DEBUGGING_OPS
#define OPCODE opcode
d45 1
a45 1
#define OPCODE U16
d55 1
d57 6
a62 2
    OPCODE	op_type;		\
    U16		op_seq;			\
d106 2
d119 1
a119 1
				/*  On pushre, re is /\s+/ imp. by split " " */
d127 6
a155 1
#define OPpASSIGN_HASH		32	/* Assigning to possible pseudohash. */
d159 1
d169 1
a169 1
#define OPpTRANS_DELETE		16
d172 2
d197 1
a197 1
  /* OP_RV2[AH]V, OP_PAD[AH]V, OP_[AH]ELEM */
d199 2
d203 8
d217 1
d220 1
d246 3
d262 1
a262 1
/* Private of OP_FTXXX */
d264 1
d273 6
a309 3
    OP *	op_pmreplroot; /* (type is really union {OP*,GV*,PADOFFSET}) */
    OP *	op_pmreplstart;
    PMOP *	op_pmnext;		/* list of all scanpats */
d315 11
a325 3
    U32		op_pmflags;
    U32		op_pmpermflags;
    U8		op_pmdynflags;
d327 1
a327 1
    char *	op_pmstashpv;
d329 1
a329 1
    HV *	op_pmstash;
d331 1
d336 4
a339 1
#define PM_SETRE(o,r)   STMT_START { SV* sv = PL_regex_pad[(o)->op_pmoffset]; sv_setiv(sv, PTR2IV(r)); } STMT_END
a348 4
#define PMdf_USED	0x01		/* pm has been used once already */
#define PMdf_TAINTED	0x02		/* pm compiled from tainted pattern */
#define PMdf_UTF8	0x04		/* pm compiled from utf8 data */
#define PMdf_DYN_UTF8	0x08
d350 6
a355 1
#define PMdf_CMP_UTF8	(PMdf_UTF8|PMdf_DYN_UTF8)
a356 2
#define PMf_RETAINT	0x0001		/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x0002		/* use pattern only once per reset */
d359 4
a362 2
#define PMf_SKIPWHITE	0x0010		/* skip leading whitespace for split */
#define PMf_WHITE	0x0020		/* pattern is \s+ */
a367 5
#define PMf_LOCALE	0x0800		/* use locale for character types */
#define PMf_MULTILINE	0x1000		/* assume multiple lines */
#define PMf_SINGLELINE	0x2000		/* assume single line */
#define PMf_FOLD	0x4000		/* case insensitivity */
#define PMf_EXTENDED	0x8000		/* chuck embedded whitespace */
d369 12
a380 2
/* mask of bits stored in regexp->reganch */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED)
d384 11
a394 2
#  define PmopSTASHPV(o)	((o)->op_pmstashpv)
#  define PmopSTASHPV_set(o,pv)	(PmopSTASHPV(o) = savesharedpv(pv))
d396 2
a397 2
				 ? gv_stashpv(PmopSTASHPV(o),GV_ADD) : Nullhv)
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME_get(hv) : Nullch))
d401 12
a412 4
#  define PmopSTASH(o)		((o)->op_pmstash)
#  define PmopSTASH_set(o,hv)	((o)->op_pmstash = (hv))
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : Nullch)
   /* op_pmstash is not refcounted */
d414 2
d490 2
a491 1
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && GvIN_PAD(v))
d557 9
d584 7
a590 2
#define OpREFCNT_inc(o)			((o) ? (++(o)->op_targ, (o)) : Nullop)
#define OpREFCNT_dec(o)			(--(o)->op_targ)
d597 10
d613 1
a613 1
	(var = (type *) Perl_Slab_Alloc(aTHX_ m,c*sizeof(type)))
d615 1
a615 1
	(var = (OP *) Perl_Slab_Alloc(aTHX_ m,size))
d618 3
a620 1
#define NewOp(m, var, c, type) Newxz(var, c, type)
d622 2
a623 2
	(var = (OP*)safemalloc(size), memzero(var, size))
#define FreeOp(p) Safefree(p)
d625 107
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d100 2
a101 1
				/*  On RV2[SG]V, don't create GV--in defined()*/
d258 1
a258 1
    OP *	op_pmreplroot;
d321 1
a321 1
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME(hv) : Nullch))
d327 1
a327 1
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME(PmopSTASH(o)) : Nullch)
d472 7
a478 2
#  define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#  define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
d507 1
a507 1
#define NewOp(m, var, c, type) Newz(m, var, c, type)
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d174 3
d200 1
a200 1
#define OPpSORT_REVERSE		4	/* Descending sort */
d202 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d103 1
d147 2
a148 2
/* Private for OP_RV2?V, OP_?ELEM */
#define OPpDEREF		(32|64)	/* Want ref to something: */
d175 1
d198 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
a26 9
#if PTRSIZE == 4
typedef U32TYPE PADOFFSET;
#else
#   if PTRSIZE == 8
typedef U64TYPE PADOFFSET;
#   endif
#endif
#define NOT_IN_PAD ((PADOFFSET) -1)

d101 2
d163 1
a163 1
  /* OP_RV2?V, OP_GVSV only */
d209 10
d395 1
a395 1
#  define	cGVOPx_gv(o)	((GV*)PL_curpad[cPADOPx(o)->op_padix])
d399 1
a399 1
				 ? cSVOPx(v)->op_sv : PL_curpad[(v)->op_targ])
d401 1
a401 1
				 ? &cSVOPx(v)->op_sv : &PL_curpad[(v)->op_targ])
d487 12
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d26 7
a32 1
typedef U32 PADOFFSET;
d62 2
d107 2
d160 1
a197 4
/* Private for OP_SORT, OP_PRTF, OP_SPRINTF, OP_FTTEXT, OP_FTBINARY, */
/*             string comparisons, and case changers. */
#define OPpLOCALE		64	/* Use locale */

d211 2
a212 1
/* Private for OP_EXIT */
d249 7
a255 3
    REGEXP *	op_pmregexp;		/* compiled expression */
    U16		op_pmflags;
    U16		op_pmpermflags;
d257 5
d264 12
d279 3
d285 1
a285 1
#define PMf_REVERSED	0x0004		/* Should be matched right->left */
d303 18
d415 1
a415 1
/* Lowest byte of PL_opargs */
d478 5
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d58 1
a58 1
C<G_SCALAR> or C<G_ARRAY> for void, scalar or array context,
d97 2
a98 1
                                /*  On pushre, re is /\s+/ imp. by split " " */
d133 1
a133 3
#define OPpTRANS_IDENTICAL	4
	/* When CU or UC, means straight latin-1 to utf-8 or vice versa */
	/* Otherwise, IDENTICAL means the right side is the same as the left */
a141 3
/* Private for OP_LEAVELOOP */
#define OPpLOOP_CONTINUE	64	/* a continue block is present */

d159 3
a161 1
#define OPpOUR_INTRO		16	/* Defer creation of array/hash elem */
a231 1
    U32		op_children;
a237 1
    U32		op_children;
a289 1
    U32		op_children;
a412 3
#  define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : Nullop)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
a417 3
#  define OpREFCNT_set(o,n)		NOOP
#  define OpREFCNT_inc(o)		(o)
#  define OpREFCNT_dec(o)		0
d419 4
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d41 1
a41 1
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
d55 14
d94 1
d97 1
d102 1
d110 3
d114 4
a117 1
#define OPpLVAL_INTRO	128	/* Lvalue must be localized */
d121 1
d130 9
a138 4
#define OPpTRANS_COUNTONLY	8
#define OPpTRANS_SQUASH		16
#define OPpTRANS_DELETE		32
#define OPpTRANS_COMPLEMENT	64
d143 4
a146 1
/* Private for OP_ENTERSUB, OP_RV2?V, OP_?ELEM */
d153 2
d156 4
d162 7
a168 1
  /* for OP_RV2?V, lower bits carry hints */
d171 1
d175 1
d186 5
a190 1
/* Private for OP_SORT, OP_PRTF, OP_SPRINTF, string cmp'n, and case changers */
d193 4
d200 9
a229 7
struct condop {
    BASEOP
    OP *	op_first;
    OP *	op_true;
    OP *	op_false;
};

d253 1
d280 1
a280 1
struct gvop {
d282 1
a282 1
    GV *	op_gv;
d300 67
a366 36
#define cUNOP ((UNOP*)PL_op)
#define cBINOP ((BINOP*)PL_op)
#define cLISTOP ((LISTOP*)PL_op)
#define cLOGOP ((LOGOP*)PL_op)
#define cCONDOP ((CONDOP*)PL_op)
#define cPMOP ((PMOP*)PL_op)
#define cSVOP ((SVOP*)PL_op)
#define cGVOP ((GVOP*)PL_op)
#define cPVOP ((PVOP*)PL_op)
#define cCOP ((COP*)PL_op)
#define cLOOP ((LOOP*)PL_op)

#define cUNOPo ((UNOP*)o)
#define cBINOPo ((BINOP*)o)
#define cLISTOPo ((LISTOP*)o)
#define cLOGOPo ((LOGOP*)o)
#define cCONDOPo ((CONDOP*)o)
#define cPMOPo ((PMOP*)o)
#define cSVOPo ((SVOP*)o)
#define cGVOPo ((GVOP*)o)
#define cPVOPo ((PVOP*)o)
#define cCVOPo ((CVOP*)o)
#define cCOPo ((COP*)o)
#define cLOOPo ((LOOP*)o)

#define kUNOP ((UNOP*)kid)
#define kBINOP ((BINOP*)kid)
#define kLISTOP ((LISTOP*)kid)
#define kLOGOP ((LOGOP*)kid)
#define kCONDOP ((CONDOP*)kid)
#define kPMOP ((PMOP*)kid)
#define kSVOP ((SVOP*)kid)
#define kGVOP ((GVOP*)kid)
#define kPVOP ((PVOP*)kid)
#define kCOP ((COP*)kid)
#define kLOOP ((LOOP*)kid)
d370 1
a370 1
/* Lowest byte of opargs */
d379 1
d382 3
a384 1
#define OA_CLASS_MASK (15 << 8)
d386 14
a399 15
#define OA_BASEOP (0 << 8)
#define OA_UNOP (1 << 8)
#define OA_BINOP (2 << 8)
#define OA_LOGOP (3 << 8)
#define OA_CONDOP (4 << 8)
#define OA_LISTOP (5 << 8)
#define OA_PMOP (6 << 8)
#define OA_SVOP (7 << 8)
#define OA_GVOP (8 << 8)
#define OA_PVOP (9 << 8)
#define OA_LOOP (10 << 8)
#define OA_COP (11 << 8)
#define OA_BASEOP_OR_UNOP (12 << 8)
#define OA_FILESTATOP (13 << 8)
#define OA_LOOPEXOP (14 << 8)
d401 1
a401 1
#define OASHIFT 12
d403 1
a403 1
/* Remaining nybbles of opargs */
d413 22
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d27 1
d35 3
d41 1
a41 1
    OP*		(*op_ppaddr)();		\
d47 1
d55 1
a55 1
#define GIMME_V		OP_GIMME(op, block_gimme())
d81 1
d84 2
a85 2
#define OPf_LIST	1
#define OPf_KNOW	2
d87 5
a91 1
	  (op->op_flags & OPf_KNOW ? op->op_flags & OPf_LIST : dowantarray())
d106 1
d143 3
a189 1
    SV *	op_pmshort;		/* for a fast bypass of execute() */
d192 1
a192 1
    char	op_pmslen;
d195 4
a198 1
#define PMf_USED	0x0001		/* pm has been used once already */
d200 2
a201 2
#define PMf_SCANFIRST	0x0004		/* initial constant not anchored */
#define PMf_ALL		0x0008		/* initial constant is whole pat */
d203 1
a203 1
#define PMf_FOLD	0x0020		/* case insensitivity */
d209 1
a209 1
#define PMf_WHITE	0x0800		/* pattern is \s+ */
d212 1
a212 1
#define PMf_LOCALE	0x4000		/* use locale for character types */
d215 3
d243 24
a266 11
#define cUNOP ((UNOP*)op)
#define cBINOP ((BINOP*)op)
#define cLISTOP ((LISTOP*)op)
#define cLOGOP ((LOGOP*)op)
#define cCONDOP ((CONDOP*)op)
#define cPMOP ((PMOP*)op)
#define cSVOP ((SVOP*)op)
#define cGVOP ((GVOP*)op)
#define cPVOP ((PVOP*)op)
#define cCOP ((COP*)op)
#define cLOOP ((LOOP*)op)
d292 20
a311 1
#define OASHIFT 8
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d44 7
a50 1
#define GIMME (op->op_flags & OPf_KNOW ? op->op_flags & OPf_LIST : dowantarray())
d53 5
a57 2
#define OPf_LIST	1	/* Do operator in list context. */
#define OPf_KNOW	2	/* Context is known. */
d75 7
d92 3
d104 6
a109 1
  /* (lower bits carry hints) */
d111 3
a113 3
#define OPpENTERSUB_DB		16	/* Debug subroutine. */
#define OPpDEREF_AV		32	/* Want ref to AV. */
#define OPpDEREF_HV		64	/* Want ref to HV. */
d126 5
a130 2
/* Private for OP_LEAVE and friends */
#define OPpLEAVE_VOID		64	/* No need to copy out values. */
d191 1
a191 1
#define PMf_RUNTIME	0x0200		/* pattern coming in on the stack */
d196 1
a196 1
#define PMf_UNUSED	0x4000		/* (unused) */
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a26 1
#define NOT_IN_PAD ((PADOFFSET) -1)
a33 3
#ifdef BASEOP_DEFINITION
#define BASEOP BASEOP_DEFINITION
#else
d37 1
a37 1
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
a42 1
#endif
d44 1
a44 7
#define OP_GIMME(op,dfl) \
	(((op)->op_flags & OPf_WANT) == OPf_WANT_VOID   ? G_VOID   : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_SCALAR ? G_SCALAR : \
	 ((op)->op_flags & OPf_WANT) == OPf_WANT_LIST   ? G_ARRAY   : \
	 dfl)

#define GIMME_V		OP_GIMME(PL_op, block_gimme())
d47 2
a48 5

#define OPf_WANT	3	/* Mask for "want" bits: */
#define  OPf_WANT_VOID	 1	/*   Want nothing */
#define  OPf_WANT_SCALAR 2	/*   Want single value */
#define  OPf_WANT_LIST	 3	/*   Want list of any length */
a65 12
				/*  On OP_(ENTER|LEAVE)EVAL, don't clear $@@ */
				/*  On OP_ENTERITER, loop var is per-thread */

/* old names; don't use in new code, but don't break them, either */
#define OPf_LIST	OPf_WANT_LIST
#define OPf_KNOW	OPf_WANT
#define GIMME \
	  (PL_op->op_flags & OPf_WANT					\
	   ? ((PL_op->op_flags & OPf_WANT) == OPf_WANT_LIST		\
	      ? G_ARRAY							\
	      : G_SCALAR)						\
	   : dowantarray())
a75 3
/* Private for OP_MATCH and OP_SUBST{,CONST} */
#define OPpRUNTIME		64	/* Pattern coming in on the stack */

a76 1
#define OPpTRANS_COUNTONLY	8
d85 2
a86 5
#define OPpDEREF		(32|64)	/* Want ref to something: */
#define OPpDEREF_AV		32	/*   Want ref to AV. */
#define OPpDEREF_HV		64	/*   Want ref to HV. */
#define OPpDEREF_SV		(32|64)	/*   Want ref to SV. */
  /* OP_ENTERSUB only */
d88 2
a89 4
#define OPpENTERSUB_AMPER	8	/* Used & form to call. */
  /* OP_?ELEM only */
#define OPpLVAL_DEFER		16	/* Defer creation of array/hash elem */
  /* for OP_RV2?V, lower bits carry hints */
d102 2
a103 8
/* Private for OP_DELETE */
#define OPpSLICE		64	/* Operating on a list of keys */

/* Private for OP_SORT, OP_PRTF, OP_SPRINTF, string cmp'n, and case changers */
#define OPpLOCALE		64	/* Use locale */

/* Private for OP_THREADSV */
#define OPpDONE_SVREF		64	/* Been through newSVREF once */
d149 1
d152 1
a152 1
    U8		op_pmdynflags;
d155 1
a155 4
#define PMdf_USED	0x01		/* pm has been used once already */
#define PMdf_TAINTED	0x02		/* pm compiled from tainted pattern */

#define PMf_RETAINT	0x0001		/* taint $1 etc. if target tainted */
d157 2
a158 2
#define PMf_REVERSED	0x0004		/* Should be matched right->left */
#define PMf_MAYBE_CONST	0x0008		/* replacement contains variables */
d160 1
a160 1
#define PMf_WHITE	0x0020		/* pattern is \s+ */
d164 1
a164 1
#define PMf_CONTINUE	0x0200		/* don't reset pos() if //g fails */
d166 1
a166 1
#define PMf_LOCALE	0x0800		/* use locale for character types */
d169 1
a169 1
#define PMf_FOLD	0x4000		/* case insensitivity */
a171 3
/* mask of bits stored in regexp->reganch */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED)

d197 11
a207 24
#define cUNOP ((UNOP*)PL_op)
#define cBINOP ((BINOP*)PL_op)
#define cLISTOP ((LISTOP*)PL_op)
#define cLOGOP ((LOGOP*)PL_op)
#define cCONDOP ((CONDOP*)PL_op)
#define cPMOP ((PMOP*)PL_op)
#define cSVOP ((SVOP*)PL_op)
#define cGVOP ((GVOP*)PL_op)
#define cPVOP ((PVOP*)PL_op)
#define cCOP ((COP*)PL_op)
#define cLOOP ((LOOP*)PL_op)

#define cUNOPo ((UNOP*)o)
#define cBINOPo ((BINOP*)o)
#define cLISTOPo ((LISTOP*)o)
#define cLOGOPo ((LOGOP*)o)
#define cCONDOPo ((CONDOP*)o)
#define cPMOPo ((PMOP*)o)
#define cSVOPo ((SVOP*)o)
#define cGVOPo ((GVOP*)o)
#define cPVOPo ((PVOP*)o)
#define cCVOPo ((CVOP*)o)
#define cCOPo ((COP*)o)
#define cLOOPo ((LOOP*)o)
d233 1
a233 20
/* The next 4 bits encode op class information */
#define OA_CLASS_MASK (15 << 8)

#define OA_BASEOP (0 << 8)
#define OA_UNOP (1 << 8)
#define OA_BINOP (2 << 8)
#define OA_LOGOP (3 << 8)
#define OA_CONDOP (4 << 8)
#define OA_LISTOP (5 << 8)
#define OA_PMOP (6 << 8)
#define OA_SVOP (7 << 8)
#define OA_GVOP (8 << 8)
#define OA_PVOP (9 << 8)
#define OA_LOOP (10 << 8)
#define OA_COP (11 << 8)
#define OA_BASEOP_OR_UNOP (12 << 8)
#define OA_FILESTATOP (13 << 8)
#define OA_LOOPEXOP (14 << 8)

#define OASHIFT 12
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d41 1
a41 1
    OP*		(CPERLscope(*op_ppaddr))(pTHX);		\
a54 14
/*
=for apidoc Amn|U32|GIMME_V
The XSUB-writer's equivalent to Perl's C<wantarray>.  Returns C<G_VOID>,
C<G_SCALAR> or C<G_ARRAY> for void, scalar or array context,
respectively.

=for apidoc Amn|U32|GIMME
A backward-compatible version of C<GIMME_V> which can only return
C<G_SCALAR> or C<G_ARRAY>; in a void context, it returns C<G_SCALAR>.
Deprecated.  Use C<GIMME_V> instead.

=cut
*/

a79 1
				/*  On OP_EXISTS, treat av as av, not avhv.  */
a81 1
                                /*  On pushre, re is /\s+/ imp. by split " " */
a85 1

a92 3
/* NOTE: OP_NEXTSTATE, OP_DBSTATE, and OP_SETSTATE (i.e. COPs) carry lower
 * bits of PL_hints in op_private */

d94 1
a94 4
#define OPpLVAL_INTRO	128	/* Lvalue must be localized or lvalue sub */

/* Private for OP_LEAVE, OP_LEAVESUB, OP_LEAVESUBLV and OP_LEAVEWRITE */
#define OPpREFCOUNTED		64	/* op_targ carries a refcount */
a97 1
#define OPpASSIGN_HASH		32	/* Assigning to possible pseudohash. */
d106 4
a109 9
#define OPpTRANS_FROM_UTF	1
#define OPpTRANS_TO_UTF		2
#define OPpTRANS_IDENTICAL	4
	/* When CU or UC, means straight latin-1 to utf-8 or vice versa */
	/* Otherwise, IDENTICAL means the right side is the same as the left */
#define OPpTRANS_SQUASH		8
#define OPpTRANS_DELETE		16
#define OPpTRANS_COMPLEMENT	32
#define OPpTRANS_GROWS		64
d114 1
a114 4
/* Private for OP_LEAVELOOP */
#define OPpLOOP_CONTINUE	64	/* a continue block is present */

/* Private for OP_RV2?V, OP_?ELEM */
a120 2
#define OPpENTERSUB_HASTARG	32	/* Called from OP tree. */
  /* OP_RV2CV only */
a121 4
#define OPpENTERSUB_NOPAREN	128	/* bare sub call (without parens) */
#define OPpENTERSUB_INARGS	4	/* Lval used as arg to a sub. */
  /* OP_GV only */
#define OPpEARLY_CV		32	/* foo() called before sub foo was parsed */
d124 1
a124 7
  /* OP_RV2?V, OP_GVSV only */
#define OPpOUR_INTRO		16	/* Defer creation of array/hash elem */
  /* for OP_RV2?V, lower bits carry hints (currently only HINT_STRICT_REFS) */

/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */
a126 1
#define	OPpCONST_STRICT		8	/* bearword subject to strict 'subs' */
a129 1
#define OPpCONST_WARNING	128	/* Was a $^W translated to constant. */
d140 1
a140 5
/* Private for OP_EXISTS */
#define OPpEXISTS_SUB		64	/* Checking for &sub, not {} or [].  */

/* Private for OP_SORT, OP_PRTF, OP_SPRINTF, OP_FTTEXT, OP_FTBINARY, */
/*             string comparisons, and case changers. */
a142 4
/* Private for OP_SORT */
#define OPpSORT_NUMERIC		1	/* Optimized away { $a <=> $b } */
#define OPpSORT_INTEGER		2	/* Ditto while under "use integer" */
#define OPpSORT_REVERSE		4	/* Descending sort */
a145 9
/* Private for OP_OPEN and OP_BACKTICK */
#define OPpOPEN_IN_RAW		16	/* binmode(F,":raw") on input fh */
#define OPpOPEN_IN_CRLF		32	/* binmode(F,":crlf") on input fh */
#define OPpOPEN_OUT_RAW		64	/* binmode(F,":raw") on output fh */
#define OPpOPEN_OUT_CRLF	128	/* binmode(F,":crlf") on output fh */

/* Private for OP_EXIT */
#define OPpEXIT_VMSISH		128	/* exit(0) vs. exit(1) vmsish mode*/

d167 7
a196 1
#define PMdf_UTF8	0x04		/* pm compiled from utf8 data */
d223 1
a223 1
struct padop {
d225 1
a225 1
    PADOFFSET	op_padix;
d243 36
a278 67
#define cUNOPx(o)	((UNOP*)o)
#define cBINOPx(o)	((BINOP*)o)
#define cLISTOPx(o)	((LISTOP*)o)
#define cLOGOPx(o)	((LOGOP*)o)
#define cPMOPx(o)	((PMOP*)o)
#define cSVOPx(o)	((SVOP*)o)
#define cPADOPx(o)	((PADOP*)o)
#define cPVOPx(o)	((PVOP*)o)
#define cCOPx(o)	((COP*)o)
#define cLOOPx(o)	((LOOP*)o)

#define cUNOP		cUNOPx(PL_op)
#define cBINOP		cBINOPx(PL_op)
#define cLISTOP		cLISTOPx(PL_op)
#define cLOGOP		cLOGOPx(PL_op)
#define cPMOP		cPMOPx(PL_op)
#define cSVOP		cSVOPx(PL_op)
#define cPADOP		cPADOPx(PL_op)
#define cPVOP		cPVOPx(PL_op)
#define cCOP		cCOPx(PL_op)
#define cLOOP		cLOOPx(PL_op)

#define cUNOPo		cUNOPx(o)
#define cBINOPo		cBINOPx(o)
#define cLISTOPo	cLISTOPx(o)
#define cLOGOPo		cLOGOPx(o)
#define cPMOPo		cPMOPx(o)
#define cSVOPo		cSVOPx(o)
#define cPADOPo		cPADOPx(o)
#define cPVOPo		cPVOPx(o)
#define cCOPo		cCOPx(o)
#define cLOOPo		cLOOPx(o)

#define kUNOP		cUNOPx(kid)
#define kBINOP		cBINOPx(kid)
#define kLISTOP		cLISTOPx(kid)
#define kLOGOP		cLOGOPx(kid)
#define kPMOP		cPMOPx(kid)
#define kSVOP		cSVOPx(kid)
#define kPADOP		cPADOPx(kid)
#define kPVOP		cPVOPx(kid)
#define kCOP		cCOPx(kid)
#define kLOOP		cLOOPx(kid)


#ifdef USE_ITHREADS
#  define	cGVOPx_gv(o)	((GV*)PL_curpad[cPADOPx(o)->op_padix])
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && GvIN_PAD(v))
#  define	IS_PADCONST(v)	(v && SvREADONLY(v))
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv \
				 ? cSVOPx(v)->op_sv : PL_curpad[(v)->op_targ])
#  define	cSVOPx_svp(v)	(cSVOPx(v)->op_sv \
				 ? &cSVOPx(v)->op_sv : &PL_curpad[(v)->op_targ])
#else
#  define	cGVOPx_gv(o)	((GV*)cSVOPx(o)->op_sv)
#  define	IS_PADGV(v)	FALSE
#  define	IS_PADCONST(v)	FALSE
#  define	cSVOPx_sv(v)	(cSVOPx(v)->op_sv)
#  define	cSVOPx_svp(v)	(&cSVOPx(v)->op_sv)
#endif

#define	cGVOP_gv		cGVOPx_gv(PL_op)
#define	cGVOPo_gv		cGVOPx_gv(o)
#define	kGVOP_gv		cGVOPx_gv(kid)
#define cSVOP_sv		cSVOPx_sv(PL_op)
#define cSVOPo_sv		cSVOPx_sv(o)
#define kSVOP_sv		cSVOPx_sv(kid)
d282 1
a282 1
/* Lowest byte of PL_opargs */
a290 1
#define OA_TARGLEX 256
d293 1
a293 3
#define OCSHIFT 9

#define OA_CLASS_MASK (15 << OCSHIFT)
d295 15
a309 14
#define OA_BASEOP (0 << OCSHIFT)
#define OA_UNOP (1 << OCSHIFT)
#define OA_BINOP (2 << OCSHIFT)
#define OA_LOGOP (3 << OCSHIFT)
#define OA_LISTOP (4 << OCSHIFT)
#define OA_PMOP (5 << OCSHIFT)
#define OA_SVOP (6 << OCSHIFT)
#define OA_PADOP (7 << OCSHIFT)
#define OA_PVOP_OR_SVOP (8 << OCSHIFT)
#define OA_LOOP (9 << OCSHIFT)
#define OA_COP (10 << OCSHIFT)
#define OA_BASEOP_OR_UNOP (11 << OCSHIFT)
#define OA_FILESTATOP (12 << OCSHIFT)
#define OA_LOOPEXOP (13 << OCSHIFT)
d311 1
a311 1
#define OASHIFT 13
d313 1
a313 1
/* Remaining nybbles of PL_opargs */
a322 22
#ifdef USE_ITHREADS
#  define OP_REFCNT_INIT		MUTEX_INIT(&PL_op_mutex)
#  define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#  define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  define OP_REFCNT_TERM		MUTEX_DESTROY(&PL_op_mutex)
#  define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : Nullop)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#else
#  define OP_REFCNT_INIT		NOOP
#  define OP_REFCNT_LOCK		NOOP
#  define OP_REFCNT_UNLOCK		NOOP
#  define OP_REFCNT_TERM		NOOP
#  define OpREFCNT_set(o,n)		NOOP
#  define OpREFCNT_inc(o)		(o)
#  define OpREFCNT_dec(o)		0
#endif

/* flags used by Perl_load_module() */
#define PERL_LOADMOD_DENY		0x1
#define PERL_LOADMOD_NOIMPORT		0x2
#define PERL_LOADMOD_IMPORT_OPS		0x4
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d58 1
a58 1
C<G_SCALAR> or C<G_ARRAY> for void, scalar or list context,
d97 1
a97 2
				/*  On pushre, re is /\s+/ imp. by split " " */
				/*  On regcomp, "use re 'eval'" was in scope */
d132 3
a134 1
#define OPpTRANS_IDENTICAL	4	/* right side is same as left */
d143 3
d163 1
a163 3
#define OPpOUR_INTRO		16	/* Variable was in an our() */
  /* OP_RV2[AH]V, OP_PAD[AH]V, OP_[AH]ELEM */
#define OPpMAYBE_LVSUB		8	/* We might be an lvalue to return */
d234 1
d241 1
d294 1
d418 3
d426 3
a429 4

#define OpREFCNT_set(o,n)		((o)->op_targ = (n))
#define OpREFCNT_inc(o)			((o) ? (++(o)->op_targ, (o)) : Nullop)
#define OpREFCNT_dec(o)			(--(o)->op_targ)
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d26 1
a26 7
#if PTRSIZE == 4
typedef U32TYPE PADOFFSET;
#else
#   if PTRSIZE == 8
typedef U64TYPE PADOFFSET;
#   endif
#endif
a55 2
=head1 "Gimme" Values

a98 2
				/*  On OP_READLINE, was <$filehandle> */
				/*  On RV2[SG]V, don't create GV--in defined()*/
a149 1
#define OPpENTERSUB_NOMOD	64	/* Immune to mod() for :attrlist. */
d187 4
d204 1
a204 2
/* Private for OP_EXIT, HUSH also for OP_DIE */
#define OPpHUSH_VMSISH		64	/* hush DCL exit msg vmsish mode*/
d241 3
a243 7
#ifdef USE_ITHREADS
    IV          op_pmoffset;
#else
    REGEXP *    op_pmregexp;            /* compiled expression */
#endif
    U32		op_pmflags;
    U32		op_pmpermflags;
a244 5
#ifdef USE_ITHREADS
    char *	op_pmstashpv;
#else
    HV *	op_pmstash;
#endif
a246 12
#ifdef USE_ITHREADS
#define PM_GETRE(o)     (INT2PTR(REGEXP*,SvIVX(PL_regex_pad[(o)->op_pmoffset])))
#define PM_SETRE(o,r)   STMT_START { SV* sv = PL_regex_pad[(o)->op_pmoffset]; sv_setiv(sv, PTR2IV(r)); } STMT_END
#define PM_GETRE_SAFE(o) (PL_regex_pad ? PM_GETRE(o) : (REGEXP*)0)
#define PM_SETRE_SAFE(o,r) if (PL_regex_pad) PM_SETRE(o,r)
#else
#define PM_GETRE(o)     ((o)->op_pmregexp)
#define PM_SETRE(o,r)   ((o)->op_pmregexp = (r))
#define PM_GETRE_SAFE PM_GETRE
#define PM_SETRE_SAFE PM_SETRE
#endif

a249 3
#define PMdf_DYN_UTF8	0x08

#define PMdf_CMP_UTF8	(PMdf_UTF8|PMdf_DYN_UTF8)
d253 1
a253 1
#define PMf_UNUSED	0x0004		/* free for use */
a270 18
#ifdef USE_ITHREADS

#  define PmopSTASHPV(o)	((o)->op_pmstashpv)
#  define PmopSTASHPV_set(o,pv)	(PmopSTASHPV(o) = savesharedpv(pv))
#  define PmopSTASH(o)		(PmopSTASHPV(o) \
				 ? gv_stashpv(PmopSTASHPV(o),GV_ADD) : Nullhv)
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME(hv) : Nullch))
#  define PmopSTASH_free(o)	PerlMemShared_free(PmopSTASHPV(o))

#else
#  define PmopSTASH(o)		((o)->op_pmstash)
#  define PmopSTASH_set(o,hv)	((o)->op_pmstash = (hv))
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME(PmopSTASH(o)) : Nullch)
   /* op_pmstash is not refcounted */
#  define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))
#  define PmopSTASH_free(o)    
#endif

d365 1
a365 1
/* Lowest byte-and-a-bit of PL_opargs */
a427 5

#ifdef USE_REENTRANT_API
#include "reentr.h"
#endif

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d26 9
a108 2
				/*  On OP_DBSTATE, indicates breakpoint
				 *    (runtime property) */
d169 1
a169 1
  /* OP_RV2?V, OP_GVSV, OP_ENTERITER only */
a214 10
/* Private of OP_FTXXX */
#define OPpFT_ACCESS		2	/* use filetest 'access' */
#define OP_IS_FILETEST_ACCESS(op) 		\
	(((op)->op_type) == OP_FTRREAD  ||	\
	 ((op)->op_type) == OP_FTRWRITE ||	\
	 ((op)->op_type) == OP_FTREXEC  ||	\
	 ((op)->op_type) == OP_FTEREAD  ||	\
	 ((op)->op_type) == OP_FTEWRITE ||	\
	 ((op)->op_type) == OP_FTEEXEC)

d391 1
a391 1
#  define	cGVOPx_gv(o)	((GV*)PAD_SVl(cPADOPx(o)->op_padix))
d395 1
a395 1
				 ? cSVOPx(v)->op_sv : PAD_SVl((v)->op_targ))
d397 1
a397 1
				 ? &cSVOPx(v)->op_sv : &PAD_SVl((v)->op_targ))
a482 12
#if defined(PL_OP_SLAB_ALLOC)
#define NewOp(m,var,c,type)	\
	(var = (type *) Perl_Slab_Alloc(aTHX_ m,c*sizeof(type)))
#define NewOpSz(m,var,size)	\
	(var = (OP *) Perl_Slab_Alloc(aTHX_ m,size))
#define FreeOp(p) Perl_Slab_Free(aTHX_ p)
#else
#define NewOp(m, var, c, type) Newz(m, var, c, type)
#define NewOpSz(m, var, size)	\
	(var = (OP*)safemalloc(size), memzero(var, size))
#define FreeOp(p) Safefree(p)
#endif
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a102 1
				/*  On OP_AELEMFAST, indiciates pad var */
d146 2
a147 2
/* Private for OP_RV2GV, OP_RV2SV, OP_AELEM, OP_HELEM, OP_PADSV */
#define OPpDEREF		(32|64)	/* autovivify: Want ref to something: */
a173 1
#define	OPpCONST_SHORTCIRCUIT	4	/* eg the constant 5 in (5 || foo) */
a195 1
#define OPpSORT_INPLACE		8	/* sort in-place; eg @@a = sort @@a */
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a173 3
/* Private for OP_ENTERITER and OP_ITER */
#define OPpITER_REVERSED	4	/* for (reverse ...) */

d197 1
a197 1
#define OPpSORT_REVERSE		4	/* Reversed sort */
a198 1
#define OPpSORT_DESCEND		16	/* Descending sort */
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005 by Larry Wall and others
d100 1
a100 2
				/*  On RV2[ACGHS]V, don't create GV--in
				    defined()*/
d257 1
a257 1
    OP *	op_pmreplroot; /* (type is really union {OP*,GV*,PADOFFSET}) */
d320 1
a320 1
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME_get(hv) : Nullch))
d326 1
a326 1
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : Nullch)
d471 2
a472 7
#  ifdef PERL_CORE
#    define OP_REFCNT_LOCK		MUTEX_LOCK(&PL_op_mutex)
#    define OP_REFCNT_UNLOCK		MUTEX_UNLOCK(&PL_op_mutex)
#  else
#    define OP_REFCNT_LOCK		op_refcnt_lock()
#    define OP_REFCNT_UNLOCK		op_refcnt_unlock()
#  endif
d501 1
a501 1
#define NewOp(m, var, c, type) Newxz(var, c, type)
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a19 13
 *	op_opt		Whether or not the op has been optimised by the
 *			peephole optimiser.
 *
 *			See the comments in S_clear_yystack() for more
 *			details on the following three flags:
 *
 *	op_latefree	tell op_free() to clear this op (and free any kids)
 *			but not yet deallocate the struct. This means that
 *			the op may be safely op_free()d multiple times
 *	op_latefreed	an op_latefree op has been op_free()d
 *	op_attached	this op (sub)tree has been attached to a CV
 *
 *	op_spare	three spare bits!
d27 3
a30 5

#ifdef PERL_MAD
#  define MADPROP_IN_BASEOP	MADPROP*	op_madprop;
#else
#  define MADPROP_IN_BASEOP
a39 1
    MADPROP_IN_BASEOP			\
d41 2
a42 6
    unsigned	op_type:9;		\
    unsigned	op_opt:1;		\
    unsigned	op_latefree:1;		\
    unsigned	op_latefreed:1;		\
    unsigned	op_attached:1;		\
    unsigned	op_spare:3;		\
a85 2
				/*  On OP_CONST, value is the hints hash for
				    eval, so return a copy from pp_const() */
d97 1
a97 1
				/*  On pushre, rx is used as part of split, e.g. split " " */
a104 6
				/*  On OP_REQUIRE, was seen as CORE::require */
				/*  On OP_ENTERWHEN, there's no condition */
				/*  On OP_BREAK, an implicit break */
				/*  On OP_SMARTMATCH, an implicit smartmatch */
				/*  On OP_ANONHASH and OP_ANONLIST, create a
				    reference to the new anon hash or array */
d128 1
a131 1
#define OPpASSIGN_CV_TO_GV	128	/* Possible optimisation for constants. */
d141 1
a141 1
    /* 16 is used for OPpTARGET_MY */
a143 2
#define OPpTRANS_DELETE		128
#define OPpTRANS_ALL	(OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF|OPpTRANS_IDENTICAL|OPpTRANS_SQUASH|OPpTRANS_COMPLEMENT|OPpTRANS_GROWS|OPpTRANS_DELETE)
d167 1
a167 1
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM */
a168 2
  /* OP_PADSV only */
#define OPpPAD_STATE		16	/* is a "state" pad */
a170 8
  /* OP_RV2GV only */
#define OPpDONT_INIT_GV		4	/* Call gv_fetchpv with GV_NOINIT */
/* (Therefore will return whatever is currently in the symbol table, not
   guaranteed to be a PVGV)  */

  /* OP_RV2CV only */
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

a176 1
#define OPpITER_DEF		8	/* for $_ or for my $_ */
a178 1
#define	OPpCONST_NOVER		2	/* no 6; */
a203 3
#define OPpSORT_QSORT		32	/* Use quicksort (not mergesort) */
#define OPpSORT_STABLE		64	/* Use a stable algorithm */

d217 1
a217 1
/* Private for OP_FTXXX */
a218 1
#define OPpFT_STACKED		4	/* stacked filetest, as in "-f -x $f" */
a226 6
/* Private for OP_(MAP|GREP)(WHILE|START) */
#define OPpGREP_LEX		2	/* iterate over lexical $_ */
    
/* Private for OP_ENTEREVAL */
#define OPpEVAL_HAS_HH		2	/* Does it have a copy of %^H */
    
d258 3
d266 3
a268 11
    U32         op_pmflags;
    union {
	OP *	op_pmreplroot;		/* For OP_SUBST */
#ifdef USE_ITHREADS
	PADOFFSET  op_pmtargetoff;	/* For OP_PUSHRE */
#else
	GV *	op_pmtargetgv;
#endif
    }	op_pmreplrootu;
    union {
	OP *	op_pmreplstart;	/* Only used in OP_SUBST */
d270 1
a270 1
	char *	op_pmstashpv;	/* Only used in OP_MATCH, with PMf_ONCE set */
d272 1
a272 1
	HV *	op_pmstash;
a273 1
    }		op_pmstashstartu;
d278 1
a278 4
#define PM_SETRE(o,r)   STMT_START { \
                            SV* const sv = PL_regex_pad[(o)->op_pmoffset]; \
                            sv_setiv(sv, PTR2IV(r)); \
                        } STMT_END
d288 6
d296 1
a296 6
#define PMf_ONCE	0x0002		/* match successfully only once per
                                           reset, with related flag RXf_USED
                                           in re->extflags holding state.
					   This is used only for ?? matches,
					   and only on OP_MATCH and OP_QR */

d299 2
a300 4

#define PMf_USED        0x0010          /* PMf_ONCE has matched successfully.
                                           Not used under threading. */

d306 5
d312 2
a313 12
/* The following flags have exact equivalents in regcomp.h with the prefix RXf_
 * which are stored in the regexp->extflags member.
 */
#define PMf_LOCALE	0x00800		/* use locale for character types */
#define PMf_MULTILINE	0x01000		/* assume multiple lines */
#define PMf_SINGLELINE	0x02000		/* assume single line */
#define PMf_FOLD	0x04000		/* case insensitivity */
#define PMf_EXTENDED	0x08000		/* chuck embedded whitespace */
#define PMf_KEEPCOPY	0x10000		/* copy the string when matching */

/* mask of bits that need to be transfered to re->extflags */
#define PMf_COMPILETIME	(PMf_MULTILINE|PMf_SINGLELINE|PMf_LOCALE|PMf_FOLD|PMf_EXTENDED|PMf_KEEPCOPY)
d317 2
a318 11
#  define PmopSTASHPV(o)						\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstashpv : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASHPV_set(o,pv)	({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv));	\
    })
#  else
#    define PmopSTASHPV_set(o,pv)					\
    ((o)->op_pmstashstartu.op_pmstashpv = savesharedpv(pv))
#  endif
d320 2
a321 2
				 ? gv_stashpv((o)->op_pmstashstartu.op_pmstashpv,GV_ADD) : NULL)
#  define PmopSTASH_set(o,hv)	PmopSTASHPV_set(o, ((hv) ? HvNAME_get(hv) : NULL))
d325 4
a328 12
#  define PmopSTASH(o)							\
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstash : NULL)
#  if defined (DEBUGGING) && defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#    define PmopSTASH_set(o,hv)		({				\
	assert((o)->op_pmflags & PMf_ONCE);				\
	((o)->op_pmstashstartu.op_pmstash = (hv));			\
    })
#  else
#    define PmopSTASH_set(o,hv)	((o)->op_pmstashstartu.op_pmstash = (hv))
#  endif
#  define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
a329 2
/* Note that if this becomes non-empty, then S_forget_pmop in op.c will need
   changing */
d404 1
a404 2
#  define	IS_PADGV(v)	(v && SvTYPE(v) == SVt_PVGV && isGV_with_GP(v) \
				 && GvIN_PAD(v))
a469 9
/* Op_REFCNT is a reference count at the head of each op tree: needed
 * since the tree is shared between threads, and between cloned closure
 * copies in the same thread. OP_REFCNT_LOCK/UNLOCK is used when modifying
 * this count.
 * The same mutex is used to protect the refcounts of the reg_trie_data
 * and reg_ac_data structures, which are shared between duplicated
 * regexes.
 */

d488 2
a489 7
#ifdef PERL_DEBUG_READONLY_OPS
#  define OpREFCNT_inc(o)		Perl_op_refcnt_inc(aTHX_ o)
#  define OpREFCNT_dec(o)		Perl_op_refcnt_dec(aTHX_ o)
#else
#  define OpREFCNT_inc(o)		((o) ? (++(o)->op_targ, (o)) : NULL)
#  define OpREFCNT_dec(o)		(--(o)->op_targ)
#endif
a495 10
#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C)
#define ref(o, type) doref(o, type, TRUE)
#endif

/* no longer used anywhere in core */
#ifndef PERL_CORE
#define cv_ckproto(cv, gv, p) \
   cv_ckproto_len((cv), (gv), (p), (p) ? strlen(p) : 0)
#endif

d502 1
a502 1
	(var = (type *) Perl_Slab_Alloc(aTHX_ c*sizeof(type)))
d504 1
a504 1
	(var = (OP *) Perl_Slab_Alloc(aTHX_ size))
d507 1
a507 3
#define NewOp(m, var, c, type)	\
	(var = (MEM_WRAP_CHECK_(c,type) \
	 (type*)PerlMemShared_calloc(c, sizeof(type))))
d509 2
a510 2
	(var = (OP*)PerlMemShared_calloc(1, size))
#define FreeOp(p) PerlMemShared_free(p)
a511 107

#ifdef PERL_MAD
#  define MAD_NULL 1
#  define MAD_PV 2
#  define MAD_OP 3
#  define MAD_SV 4

struct madprop {
    MADPROP* mad_next;
    const void *mad_val;
    U32 mad_vlen;
/*    short mad_count; */
    char mad_key;
    char mad_type;
};

struct token {
    I32 tk_type;
    YYSTYPE tk_lval;
    MADPROP* tk_mad;
};
#endif

/*
 * Values that can be held by mad_key :
 * ^       unfilled head spot
 * ,       literal ,
 * ;       literal ; (blank if implicit ; at end of block)
 * :       literal : from ?: or attr list
 * +       unary +
 * ?       literal ? from ?:
 * (       literal (
 * )       literal )
 * [       literal [
 * ]       literal ]
 * {       literal {
 * }       literal }
 * @@       literal @@ sigil
 * $       literal $ sigil
 * *       literal * sigil
 * !       use is source filtered
 * &       & or sub
 * #       whitespace/comment following ; or }
 * #       $# sigil
 * 1       1st ; from for(;;)
 * 1       retired protasis
 * 2       2nd ; from for(;;)
 * 2       retired apodosis
 * 3       C-style for list
 * a       sub or var attributes
 * a       non-method arrow operator
 * A       method arrow operator
 * A       use import args
 * b       format block
 * B       retired stub block
 * C       constant conditional op
 * d       declarator
 * D       do block
 * e       unreached "else" (see C)
 * e       expression producing E
 * E       tr/E/R/, /E/
 * f       folded constant op
 * F       peg op for format
 * g       op was forced to be a word
 * i       if/unless modifier
 * I       if/elsif/unless statement
 * k       local declarator
 * K       retired kid op
 * l       last index of array ($#foo)
 * L       label
 * m       modifier on regex
 * n       sub or format name
 * o       current operator/declarator name
 * o       else/continue
 * O       generic optimized op
 * p       peg to hold extra whitespace at statement level
 * P       peg op for package declaration
 * q       opening quote
 * =       quoted material
 * Q       closing quote
 * Q       optimized qw//
 * r       expression producing R
 * R       tr/E/R/ s/E/R/
 * s       sub signature
 * S       use import stub (no import)
 * S       retired sort block
 * t       unreached "then" (see C)
 * U       use import op
 * v       private sv of for loop
 * V       use version
 * w       while/until modifier
 * W       while/for statement
 * x       optimized qw
 * X       random thing
 * _       whitespace/comments preceding anything else
 * ~       =~ operator
 */

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
a47 2
typedef PERL_BITFIELD16 Optype;

d57 6
a62 6
    PERL_BITFIELD16 op_type:9;		\
    PERL_BITFIELD16 op_opt:1;		\
    PERL_BITFIELD16 op_latefree:1;	\
    PERL_BITFIELD16 op_latefreed:1;	\
    PERL_BITFIELD16 op_attached:1;	\
    PERL_BITFIELD16 op_spare:3;		\
a66 5
/* If op_type:9 is changed to :10, also change PUSHEVAL in cop.h.
   Also, if the type of op_type is ever changed (e.g. to PERL_BITFIELD32)
   then all the other bit-fields before/after it should change their
   types too to let VC pack them into the same 4 byte integer.*/

a72 5
#define OP_GIMME_REVERSE(flags)			\
	((flags & G_VOID) ? OPf_WANT_VOID :	\
	(flags & G_ARRAY) ? OPf_WANT_LIST :	\
			    OPf_WANT_SCALAR)

d187 1
a187 1
  /* OP_ENTERSUB and OP_RV2CV only */
d249 3
d336 1
a336 10
/* The assignment is just to enforce type safety (or at least get a warning).
 */
#define PM_SETRE(o,r)	STMT_START {					\
                            const REGEXP *const slosh = (r);		\
                            PM_SETRE_OFFSET((o), PTR2IV(slosh));	\
                        } STMT_END
/* Actually you can assign any IV, not just an offset. And really should it be
   UV? */
#define PM_SETRE_OFFSET(o,iv) \
			STMT_START { \
d338 1
a338 1
                            sv_setiv(sv, (iv)); \
a339 3

#  ifndef PERL_CORE
/* No longer used anywhere in the core.  Migrate to Devel::PPPort?  */
a341 1
#  endif
a344 1
#  ifndef PERL_CORE
a346 1
#  endif
d370 1
a370 2
 * which are stored in the regexp->extflags member. If you change them here,
 * you have to change them there, and vice versa.
d512 1
a512 1
#define Nullop ((OP*)NULL)
d593 3
a595 3
#define PERL_LOADMOD_DENY		0x1	/* no Module */
#define PERL_LOADMOD_NOIMPORT		0x2	/* use Module () */
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* use Module (...) */
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d80 4
a83 1
#define OP_GIMME_REVERSE(flags)	((flags) & G_WANT)
d118 2
a144 4
				/*  On OP_ENTER, store caller context */
				/*  On OP_HELEM and OP_HSLICE, localization will be followed
				    by assignment, so do not wipe the target if it is special
				    (e.g. a glob or a magic SV) */
a247 1
/* Also OPpLVAL_INTRO (128) */
a260 3
/* Private for OP_REVERSE */
#define OPpREVERSE_INPLACE	8	/* reverse in-place (@@a = reverse @@a) */

d274 7
d344 1
a344 2
#define PM_GETRE(o)	(SvTYPE(PL_regex_pad[(o)->op_pmoffset]) == SVt_REGEXP \
		 	 ? (REGEXP*)(PL_regex_pad[(o)->op_pmoffset]) : NULL)
a346 6
/* With first class regexps not via a reference one needs to assign
   &PL_sv_undef under ithreads. (This would probably work unthreaded, but NULL
   is cheaper. I guess we could allow NULL, but the check above would get
   more complex, and we'd have an AV with (SV*)NULL in it, which feels bad */
/* BEWARE - something that calls this macro passes (r) which has a side
   effect.  */
d348 9
a356 3
                            REGEXP *const _pm_setre = (r);		\
                            assert(_pm_setre);				\
			    PL_regex_pad[(o)->op_pmoffset] = MUTABLE_SV(_pm_setre); \
d358 6
d367 4
d374 2
a375 2
#define PMf_RETAINT	0x00000040	/* taint $1 etc. if target tainted */
#define PMf_ONCE	0x00000080	/* match successfully only once per
d381 2
a382 2
#define PMf_UNUSED	0x00000100	/* free for use */
#define PMf_MAYBE_CONST	0x00000200	/* replacement contains variables */
d384 1
a384 1
#define PMf_USED        0x00000400	/* PMf_ONCE has matched successfully.
d387 5
a391 5
#define PMf_CONST	0x00000800	/* subst replacement is constant */
#define PMf_KEEP	0x00001000	/* keep 1st runtime pattern forever */
#define PMf_GLOBAL	0x00002000	/* pattern had a g modifier */
#define PMf_CONTINUE	0x00004000	/* don't reset pos() if //g fails */
#define PMf_EVAL	0x00008000	/* evaluating replacement as expr */
d397 6
a402 6
#define PMf_MULTILINE	0x00000001	/* assume multiple lines */
#define PMf_SINGLELINE	0x00000002	/* assume single line */
#define PMf_FOLD	0x00000004	/* case insensitivity */
#define PMf_EXTENDED	0x00000008	/* chuck embedded whitespace */
#define PMf_KEEPCOPY	0x00000010	/* copy the string when matching */
#define PMf_LOCALE	0x00000020	/* use locale for character types */
d537 1
a537 3
#ifndef PERL_CORE
#  define Nullop ((OP*)NULL)
#endif
a631 4
#ifdef PERL_CORE
#  define my(o)	my_attrs((o), NULL)
#endif

d659 1
a659 1
    void *mad_val;
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a38 1
#include "op_reg_common.h"
d56 1
a56 1
    OP*		(*op_ppaddr)(pTHX);	\
d88 1
a88 1
respectively. See L<perlcall> for a usage example.
d125 1
d133 1
d135 2
a136 2
				/*  On OP_(ENTER|LEAVE)WHEN, there's
				    no condition */
d140 1
a143 9
				/*  On OP_MATCH, OP_SUBST & OP_TRANS, the
				    operand of a logical or conditional
				    that was optimised away, so it should
				    not be bound via =~ */
				/*  On OP_CONST, from a constant CV */
				/*  On OP_GLOB, two meanings:
				    - Before ck_glob, called as CORE::glob
				    - After ck_glob, use Perl glob function
			         */
d156 2
a157 5
/* Lower bits of op_private often carry the number of arguments, as
 * set by newBINOP, newUNOP and ck_fun */

/* NOTE: OP_NEXTSTATE and OP_DBSTATE (i.e. COPs) carry NATIVE_HINTS
 * in op_private */
a161 4
/* Private for OPs with TARGLEX */
  /* (lower bits may carry MAXARG) */
#define OPpTARGET_MY		16	/* Target is PADMY. */

a193 1

d196 3
a198 9
#define OPpENTERSUB_HASTARG	4	/* Called from OP tree. */
#define OPpENTERSUB_INARGS	1	/* Lval used as arg to a sub. */
/* used by OPpDEREF             (32|64) */
/* used by HINT_STRICT_SUBS     2          */
  /* Mask for OP_ENTERSUB flags, the absence of which must be propagated
     in dynamic context */
#define OPpENTERSUB_LVAL_MASK (OPpLVAL_INTRO|OPpENTERSUB_INARGS)

  /* OP_RV2CV only */
d201 1
a201 2
#define OPpMAY_RETURN_CONSTANT	1	/* If a constant sub, return the constant */

d206 1
a206 1
  /* OP_RV2[SAH]V, OP_GVSV, OP_ENTERITER only */
d208 1
a208 2
  /* OP_RV2[AGH]V, OP_PAD[AH]V, OP_[AH]ELEM, OP_[AH]SLICE OP_AV2ARYLEN,
     OP_R?KEYS, OP_SUBSTR, OP_POS, OP_VEC */
a209 4

  /* OP_SUBSTR only */
#define OPpSUBSTR_REPL_FIRST	16	/* 1st arg is replacement string */

d218 7
a224 1
#define OPpALLOW_FAKE		16	/* OK to return fake glob */
d233 1
a233 1
#define	OPpCONST_STRICT		8	/* bareword subject to strict 'subs' */
d235 1
d276 1
a276 3
#define OPpFT_STACKED		4	/* stacked filetest, as "-f" in "-f -x $f" */
#define OPpFT_STACKING		8	/* stacking filetest, as "-x" in "-f -x $f" */
#define OPpFT_AFTER_t		16	/* previous op was -t */
a282 3
#define OPpEVAL_UNICODE		4
#define OPpEVAL_BYTES		8
#define OPpEVAL_COPHH		16	/* Construct %^H from cop hints */
a283 14
/* Private for OP_CALLER, OP_WANTARRAY and OP_RUNCV */
#define OPpOFFBYONE		128	/* Treat caller(1) as caller(2) */

/* Private for OP_COREARGS */
/* These must not conflict with OPpDONT_INIT_GV or OPpALLOW_FAKE.
   See pp.c:S_rv2gv. */
#define OPpCOREARGS_DEREF1	1	/* Arg 1 is a handle constructor */
#define OPpCOREARGS_DEREF2	2	/* Arg 2 is a handle constructor */
#define OPpCOREARGS_SCALARMOD	64	/* \$ rather than \[$@@%*] */
#define OPpCOREARGS_PUSHMARK	128	/* Call pp_pushmark */

/* Private for OP_(LAST|REDO|NEXT|GOTO|DUMP) */
#define OPpPV_IS_UTF8		128	/* label is in UTF8 */

d332 1
a332 4
	struct {
            char *	op_pmstashpv;	/* Only used in OP_MATCH, with PMf_ONCE set */
            U32     op_pmstashflags;  /* currently only SVf_UTF8 or 0 */
        } op_pmstashthr;
a359 3
/* Leave some space, so future bit allocations can go either in the shared or
 * unshared area without affecting binary compatibility */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+6)
d361 29
a389 24
/* 'use re "taint"' in scope: taint $1 etc. if target tainted */
#define PMf_RETAINT	(1<<(PMf_BASE_SHIFT+0))

/* match successfully only once per reset, with related flag RXf_USED in
 * re->extflags holding state.  This is used only for ?? matches, and only on
 * OP_MATCH and OP_QR */
#define PMf_ONCE	(1<<(PMf_BASE_SHIFT+1))

/* replacement contains variables */
#define PMf_MAYBE_CONST (1<<(PMf_BASE_SHIFT+2))

/* PMf_ONCE has matched successfully.  Not used under threading. */
#define PMf_USED        (1<<(PMf_BASE_SHIFT+3))

/* subst replacement is constant */
#define PMf_CONST	(1<<(PMf_BASE_SHIFT+4))

/* keep 1st runtime pattern forever */
#define PMf_KEEP	(1<<(PMf_BASE_SHIFT+5))

#define PMf_GLOBAL	(1<<(PMf_BASE_SHIFT+6))	/* pattern had a g modifier */

/* don't reset pos() if //g fails */
#define PMf_CONTINUE	(1<<(PMf_BASE_SHIFT+7))
d391 2
a392 9
/* evaluating replacement as expr */
#define PMf_EVAL	(1<<(PMf_BASE_SHIFT+8))

/* Return substituted string instead of modifying it. */
#define PMf_NONDESTRUCT	(1<<(PMf_BASE_SHIFT+9))

#if PMf_BASE_SHIFT+9 > 31
#   error Too many PMf_ bits used.  See above and regnodes.h for any spare in middle
#endif
d397 1
a397 1
    (((o)->op_pmflags & PMf_ONCE) ? (o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv : NULL)
d401 1
a401 1
	((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv = savesharedpv(pv));	\
d405 1
a405 1
    ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv = savesharedpv(pv))
d407 3
a409 11
#  define PmopSTASH_flags(o)           ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashflags)
#  define PmopSTASH_flags_set(o,flags) ((o)->op_pmstashstartu.op_pmstashthr.op_pmstashflags = flags)
#  define PmopSTASH(o)         (PmopSTASHPV(o)                                     \
                                ? gv_stashpv((o)->op_pmstashstartu.op_pmstashthr.op_pmstashpv,   \
                                            GV_ADD | PmopSTASH_flags(o)) : NULL)
#  define PmopSTASH_set(o,hv)  (PmopSTASHPV_set(o, (hv) ? HvNAME_get(hv) : NULL), \
                                PmopSTASH_flags_set(o,                            \
                                            ((hv) && HvNAME_HEK(hv) &&           \
                                                        HvNAMEUTF8(hv))           \
                                                ? SVf_UTF8                        \
                                                : 0))
d528 1
a528 1
/* Lowest byte of PL_opargs */
d533 1
a533 1
#define OA_TARGLEX 16
d537 1
d540 1
a540 1
#define OCSHIFT 8
d559 1
a559 1
#define OASHIFT 12
a614 15
/*
=head1 Optree Manipulation Functions

=for apidoc Am|OP*|LINKLIST|OP *o
Given the root of an optree, link the tree in execution order using the
C<op_next> pointers and return the first op executed. If this has
already been done, it will not be redone, and C<< o->op_next >> will be
returned. If C<< o->op_next >> is not already set, I<o> should be at
least an C<UNOP>.

=cut
*/

#define LINKLIST(o) ((o)->op_next ? (o)->op_next : op_linklist((OP*)o))

d618 1
a618 1
   cv_ckproto_len_flags((cv), (gv), (p), (p) ? strlen(p) : 0, 0)
a643 195
struct block_hooks {
    U32	    bhk_flags;
    void    (*bhk_start)	(pTHX_ int full);
    void    (*bhk_pre_end)	(pTHX_ OP **seq);
    void    (*bhk_post_end)	(pTHX_ OP **seq);
    void    (*bhk_eval)		(pTHX_ OP *const saveop);
};

/*
=head1 Compile-time scope hooks

=for apidoc mx|U32|BhkFLAGS|BHK *hk
Return the BHK's flags.

=for apidoc mx|void *|BhkENTRY|BHK *hk|which
Return an entry from the BHK structure. I<which> is a preprocessor token
indicating which entry to return. If the appropriate flag is not set
this will return NULL. The type of the return value depends on which
entry you ask for.

=for apidoc Amx|void|BhkENTRY_set|BHK *hk|which|void *ptr
Set an entry in the BHK structure, and set the flags to indicate it is
valid. I<which> is a preprocessing token indicating which entry to set.
The type of I<ptr> depends on the entry.

=for apidoc Amx|void|BhkDISABLE|BHK *hk|which
Temporarily disable an entry in this BHK structure, by clearing the
appropriate flag. I<which> is a preprocessor token indicating which
entry to disable.

=for apidoc Amx|void|BhkENABLE|BHK *hk|which
Re-enable an entry in this BHK structure, by setting the appropriate
flag. I<which> is a preprocessor token indicating which entry to enable.
This will assert (under -DDEBUGGING) if the entry doesn't contain a valid
pointer.

=for apidoc mx|void|CALL_BLOCK_HOOKS|which|arg
Call all the registered block hooks for type I<which>. I<which> is a
preprocessing token; the type of I<arg> depends on I<which>.

=cut
*/

#define BhkFLAGS(hk)		((hk)->bhk_flags)

#define BHKf_bhk_start	    0x01
#define BHKf_bhk_pre_end    0x02
#define BHKf_bhk_post_end   0x04
#define BHKf_bhk_eval	    0x08

#define BhkENTRY(hk, which) \
    ((BhkFLAGS(hk) & BHKf_ ## which) ? ((hk)->which) : NULL)

#define BhkENABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) |= BHKf_ ## which; \
	assert(BhkENTRY(hk, which)); \
    } STMT_END

#define BhkDISABLE(hk, which) \
    STMT_START { \
	BhkFLAGS(hk) &= ~(BHKf_ ## which); \
    } STMT_END

#define BhkENTRY_set(hk, which, ptr) \
    STMT_START { \
	(hk)->which = ptr; \
	BhkENABLE(hk, which); \
    } STMT_END

#define CALL_BLOCK_HOOKS(which, arg) \
    STMT_START { \
	if (PL_blockhooks) { \
	    I32 i; \
	    for (i = av_len(PL_blockhooks); i >= 0; i--) { \
		SV *sv = AvARRAY(PL_blockhooks)[i]; \
		BHK *hk; \
		\
		assert(SvIOK(sv)); \
		if (SvUOK(sv)) \
		    hk = INT2PTR(BHK *, SvUVX(sv)); \
		else \
		    hk = INT2PTR(BHK *, SvIVX(sv)); \
		\
		if (BhkENTRY(hk, which)) \
		    BhkENTRY(hk, which)(aTHX_ arg); \
	    } \
	} \
    } STMT_END

/* flags for rv2cv_op_cv */

#define RV2CVOPCV_MARK_EARLY     0x00000001
#define RV2CVOPCV_RETURN_NAME_GV 0x00000002

#define op_lvalue(op,t) Perl_op_lvalue_flags(aTHX_ op,t,0)

/* flags for op_lvalue_flags */

#define OP_LVALUE_NO_CROAK 1

/*
=head1 Custom Operators

=for apidoc Am|U32|XopFLAGS|XOP *xop
Return the XOP's flags.

=for apidoc Am||XopENTRY|XOP *xop|which
Return a member of the XOP structure. I<which> is a cpp token indicating
which entry to return. If the member is not set this will return a
default value. The return type depends on I<which>.

=for apidoc Am|void|XopENTRY_set|XOP *xop|which|value
Set a member of the XOP structure. I<which> is a cpp token indicating
which entry to set. See L<perlguts/"Custom Operators"> for details about
the available members and how they are used.

=for apidoc Am|void|XopDISABLE|XOP *xop|which
Temporarily disable a member of the XOP, by clearing the appropriate flag.

=for apidoc Am|void|XopENABLE|XOP *xop|which
Reenable a member of the XOP which has been disabled.

=cut
*/

struct custom_op {
    U32		    xop_flags;    
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
};

#define XopFLAGS(xop) ((xop)->xop_flags)

#define XOPf_xop_name	0x01
#define XOPf_xop_desc	0x02
#define XOPf_xop_class	0x04
#define XOPf_xop_peep	0x08

#define XOPd_xop_name	PL_op_name[OP_CUSTOM]
#define XOPd_xop_desc	PL_op_desc[OP_CUSTOM]
#define XOPd_xop_class	OA_BASEOP
#define XOPd_xop_peep	((Perl_cpeep_t)0)

#define XopENTRY_set(xop, which, to) \
    STMT_START { \
	(xop)->which = (to); \
	(xop)->xop_flags |= XOPf_ ## which; \
    } STMT_END

#define XopENTRY(xop, which) \
    ((XopFLAGS(xop) & XOPf_ ## which) ? (xop)->which : XOPd_ ## which)

#define XopDISABLE(xop, which) ((xop)->xop_flags &= ~XOPf_ ## which)
#define XopENABLE(xop, which) \
    STMT_START { \
	(xop)->xop_flags |= XOPf_ ## which; \
	assert(XopENTRY(xop, which)); \
    } STMT_END

/*
=head1 Optree Manipulation Functions

=for apidoc Am|const char *|OP_NAME|OP *o
Return the name of the provided OP. For core ops this looks up the name
from the op_type; for custom ops from the op_ppaddr.

=for apidoc Am|const char *|OP_DESC|OP *o
Return a short description of the provided OP.

=for apidoc Am|U32|OP_CLASS|OP *o
Return the class of the provided OP: that is, which of the *OP
structures it uses. For core ops this currently gets the information out
of PL_opargs, which does not always accurately reflect the type used.
For custom ops the type is returned from the registration, and it is up
to the registree to ensure it is accurate. The value returned will be
one of the OA_* constants from op.h.

=cut
*/

#define OP_NAME(o) ((o)->op_type == OP_CUSTOM \
		    ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_name) \
		    : PL_op_name[(o)->op_type])
#define OP_DESC(o) ((o)->op_type == OP_CUSTOM \
		    ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_desc) \
		    : PL_op_desc[(o)->op_type])
#define OP_CLASS(o) ((o)->op_type == OP_CUSTOM \
		     ? XopENTRY(Perl_custom_op_xop(aTHX_ o), xop_class) \
		     : (PL_opargs[(o)->op_type] & OA_CLASS_MASK))

#define newSUB(f, o, p, b)	Perl_newATTRSUB(aTHX_ (f), (o), (p), NULL, (b))

a739 16

/*
=head1 Hook manipulation
*/

#ifdef USE_ITHREADS
#  define OP_CHECK_MUTEX_INIT		MUTEX_INIT(&PL_check_mutex)
#  define OP_CHECK_MUTEX_LOCK		MUTEX_LOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_UNLOCK		MUTEX_UNLOCK(&PL_check_mutex)
#  define OP_CHECK_MUTEX_TERM		MUTEX_DESTROY(&PL_check_mutex)
#else
#  define OP_CHECK_MUTEX_INIT		NOOP
#  define OP_CHECK_MUTEX_LOCK		NOOP
#  define OP_CHECK_MUTEX_UNLOCK		NOOP
#  define OP_CHECK_MUTEX_TERM		NOOP
#endif
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d22 11
a32 5
 *	op_slabbed	allocated via opslab
 *	op_static	tell op_free() to skip PerlMemShared_free(), when
 *                      !op_slabbed.
 *	op_savefree	on savestack via SAVEFREEOP
 *	op_spare	Three spare bits
d62 3
a64 3
    PERL_BITFIELD16 op_slabbed:1;	\
    PERL_BITFIELD16 op_savefree:1;	\
    PERL_BITFIELD16 op_static:1;	\
a74 1
/* for efficiency, requires OPf_WANT_VOID == G_VOID etc */
d76 4
a79 1
	(((op)->op_flags & OPf_WANT) ? ((op)->op_flags & OPf_WANT) : dfl)
d126 1
a126 1
                                /*  On pushre, rx is used as part of split, e.g. split " " */
a150 1
                                /*  On OP_PADRANGE, push @@_ */
d186 1
a186 1
/* Private for OP_MATCH and OP_SUBST{,CONT} */
a232 5
  /* OP_RV2HV and OP_PADHV */
#define OPpTRUEBOOL		32	/* %hash in (%hash || $foo) in
					   void context */
#define OPpMAYBE_TRUEBOOL	64	/* %hash in (%hash || $foo) where
					   cx is not known till run time */
a240 5
  /* OP_PADRANGE only */
  /* bit 7 is OPpLVAL_INTRO */
#define OPpPADRANGE_COUNTMASK	127	/* bits 6..0 hold target range, */
#define OPpPADRANGE_COUNTSHIFT	7	/* 7 bits in total */

d257 1
a257 1
#define OPpCONST_FOLDED		128	/* Result of constant folding */
a307 1
#define OPpEVAL_RE_REPARSING	32	/* eval_sv(..., G_RE_REPARSING) */
d371 4
a374 1
	PADOFFSET op_pmstashoff; /* Only used in OP_MATCH, with PMf_ONCE set */
a378 1
    OP *	op_code_list;	/* list of (?{}) code blocks */
d414 4
a417 1
/* PMf_ONCE, i.e. ?pat?, has matched successfully.  Not used under threading. */
d437 1
a437 14
/* the pattern has a CV attached (currently only under qr/...(?{}).../) */
#define PMf_HAS_CV	(1<<(PMf_BASE_SHIFT+10))

/* op_code_list is private; don't free it etc. It may well point to
 * code within another sub, with different pad etc */
#define PMf_CODELIST_PRIVATE	(1<<(PMf_BASE_SHIFT+11))

/* the PMOP is a QR (we should be able to detect that from the op type,
 * but the regex compilation API passes just the pm flags, not the op
 * itself */
#define PMf_IS_QR	(1<<(PMf_BASE_SHIFT+12))
#define PMf_USE_RE_EVAL	(1<<(PMf_BASE_SHIFT+13)) /* use re'eval' in scope */

#if PMf_BASE_SHIFT+13 > 31
d443 24
a466 7
#  define PmopSTASH(o)         ((o)->op_pmflags & PMf_ONCE                         \
                                ? PL_stashpad[(o)->op_pmstashstartu.op_pmstashoff]   \
                                : NULL)
#  define PmopSTASH_set(o,hv)	\
	(assert_((o)->op_pmflags & PMf_ONCE)				\
	 (o)->op_pmstashstartu.op_pmstashoff =				\
	    (hv) ? alloccopstash(hv) : 0)
d478 6
a484 3
#define PmopSTASHPV(o)	(PmopSTASH(o) ? HvNAME_get(PmopSTASH(o)) : NULL)
   /* op_pmstashstartu.op_pmstash is not refcounted */
#define PmopSTASHPV_set(o,pv)	PmopSTASH_set((o), gv_stashpv(pv,GV_ADD))
d559 1
a559 2
#  define	IS_PADCONST(v) \
	(v && (SvREADONLY(v) || (SvIsCOW(v) && !SvLEN(v))))
d698 1
d704 7
a710 55

/*
 * The per-CV op slabs consist of a header (the opslab struct) and a bunch
 * of space for allocating op slots, each of which consists of two pointers
 * followed by an op.  The first pointer points to the next op slot.  The
 * second points to the slab.  At the end of the slab is a null pointer,
 * so that slot->opslot_next - slot can be used to determine the size
 * of the op.
 *
 * Each CV can have multiple slabs; opslab_next points to the next slab, to
 * form a chain.  All bookkeeping is done on the first slab, which is where
 * all the op slots point.
 *
 * Freed ops are marked as freed and attached to the freed chain
 * via op_next pointers.
 *
 * When there is more than one slab, the second slab in the slab chain is
 * assumed to be the one with free space available.  It is used when allo-
 * cating an op if there are no freed ops available or big enough.
 */

#ifdef PERL_CORE
struct opslot {
    /* keep opslot_next first */
    OPSLOT *	opslot_next;		/* next slot */
    OPSLAB *	opslot_slab;		/* owner */
    OP		opslot_op;		/* the op itself */
};

struct opslab {
    OPSLOT *	opslab_first;		/* first op in this slab */
    OPSLAB *	opslab_next;		/* next slab */
    OP *	opslab_freed;		/* chain of freed ops */
    size_t	opslab_refcnt;		/* number of ops */
# ifdef PERL_DEBUG_READONLY_OPS
    U16		opslab_size;		/* size of slab in pointers */
    bool	opslab_readonly;
# endif
    OPSLOT	opslab_slots;		/* slots begin here */
};

# define OPSLOT_HEADER		STRUCT_OFFSET(OPSLOT, opslot_op)
# define OPSLOT_HEADER_P	(OPSLOT_HEADER/sizeof(I32 *))
# define OpSLOT(o)		(assert_(o->op_slabbed) \
				 (OPSLOT *)(((char *)o)-OPSLOT_HEADER))
# define OpSLAB(o)		OpSLOT(o)->opslot_slab
# define OpslabREFCNT_dec(slab)      \
	(((slab)->opslab_refcnt == 1) \
	 ? opslab_free_nopad(slab)     \
	 : (void)--(slab)->opslab_refcnt)
  /* Variant that does not null out the pads */
# define OpslabREFCNT_dec_padok(slab) \
	(((slab)->opslab_refcnt == 1)  \
	 ? opslab_free(slab)		\
	 : (void)--(slab)->opslab_refcnt)
d1025 1
a1025 1
 * indent-tabs-mode: nil
d1028 1
a1028 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d26 1
a26 2
 *	op_folded	Result/remainder of a constant fold operation.
 *	op_spare	Two spare bits
d59 1
a59 2
    PERL_BITFIELD16 op_folded:1;	\
    PERL_BITFIELD16 op_spare:2;		\
d81 1
a81 1
respectively.  See L<perlcall> for a usage example.
a143 1
                                /*  On OP_DUMP, has no label */
a171 3
/* Private for OP_LEAVE and OP_LEAVELOOP */
#define OPpLVALUE		128	/* Do not copy return value */

a201 26
/* OP_ENTERSUB and OP_RV2CV flags

Flags are set on entersub and rv2cv in three phases:
  parser  - the parser passes the flag to the op constructor
  check   - the check routine called by the op constructor sets the flag
  context - application of scalar/ref/lvalue context applies the flag

In the third stage, an entersub op might turn into an rv2cv op (undef &foo,
\&foo, lock &foo, exists &foo, defined &foo).  The two places where that
happens (op_lvalue_flags and doref in op.c) need to make sure the flags do
not conflict.  Flags applied in the context phase are only set when there
is no conversion of op type.

  bit  entersub flag       phase   rv2cv flag             phase
  ---  -------------       -----   ----------             -----
    1  OPpENTERSUB_INARGS  context OPpMAY_RETURN_CONSTANT context
    2  HINT_STRICT_REFS    check   HINT_STRICT_REFS       check
    4  OPpENTERSUB_HASTARG check
    8                              OPpENTERSUB_AMPER      parser
   16  OPpENTERSUB_DB      check
   32  OPpDEREF_AV         context
   64  OPpDEREF_HV         context
  128  OPpLVAL_INTRO       context OPpENTERSUB_NOPAREN    parser

*/

d207 1
a207 1
/* used by HINT_STRICT_REFS     2          */
a220 2
  /* OP_RV2[AH]V OP_[AH]SLICE */
#define OPpSLICEWARNING		4	/* warn about @@hash{$scalar} */
d260 1
d293 3
a295 7
/* Private for COPs */
#define OPpHUSH_VMSISH		32	/* hush DCL exit msg vmsish mode*/
/* Note: Used for NATIVE_HINTS (shifted from the values in PL_hints),
	 currently defined by vms/vmsish.h:
				64
				128
 */
a326 3
/* Private for OP_SPLIT */
#define OPpSPLIT_IMPLIM		128	/* implicit limit */

d359 1
a359 1
    PADOFFSET   op_pmoffset;
d658 1
a658 1
#if defined(PERL_IN_PERLY_C) || defined(PERL_IN_OP_C) || defined(PERL_IN_TOKE_C)
d667 1
a667 1
C<op_next> pointers and return the first op executed.  If this has
d669 1
a669 1
returned.  If C<< o->op_next >> is not already set, I<o> should be at
d768 3
a770 3
Return an entry from the BHK structure.  I<which> is a preprocessor token
indicating which entry to return.  If the appropriate flag is not set
this will return NULL.  The type of the return value depends on which
d775 1
a775 1
valid.  I<which> is a preprocessing token indicating which entry to set.
d780 1
a780 1
appropriate flag.  I<which> is a preprocessor token indicating which
d785 1
a785 1
flag.  I<which> is a preprocessor token indicating which entry to enable.
d790 1
a790 1
Call all the registered block hooks for type I<which>.  I<which> is a
d826 2
a827 2
	    SSize_t i; \
	    for (i = av_tindex(PL_blockhooks); i >= 0; i--) { \
d861 3
a863 10
Return a member of the XOP structure.  I<which> is a cpp token
indicating which entry to return.  If the member is not set
this will return a default value.  The return type depends
on I<which>.  This macro evaluates its arguments more than
once.  If you are using C<Perl_custom_op_xop> to retreive a
C<XOP *> from a C<OP *>, use the more efficient L</XopENTRYCUSTOM> instead.

=for apidoc Am||XopENTRYCUSTOM|const OP *o|which
Exactly like C<XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)> but more
efficient.  The I<which> parameter is identical to L</XopENTRY>.
d866 3
a868 5
Set a member of the XOP structure.  I<which> is a cpp token
indicating which entry to set.  See L<perlguts/"Custom Operators">
for details about the available members and how
they are used.  This macro evaluates its argument
more than once.
a886 11
/* return value of Perl_custom_op_get_field, similar to void * then casting but
   the U32 doesn't need truncation on 64 bit platforms in the caller, also
   for easier macro writing */
typedef union {
    const char	   *xop_name;
    const char	   *xop_desc;
    U32		    xop_class;
    void	  (*xop_peep)(pTHX_ OP *o, OP *oldop);
    XOP            *xop_ptr;
} XOPRETANY;

a893 9
/* used by Perl_custom_op_get_field for option checking */
typedef enum {
    XOPe_xop_ptr = 0, /* just get the XOP *, don't look inside it */
    XOPe_xop_name = XOPf_xop_name,
    XOPe_xop_desc = XOPf_xop_desc,
    XOPe_xop_class = XOPf_xop_class,
    XOPe_xop_peep = XOPf_xop_peep,
} xop_flags_enum;

a907 3
#define XopENTRYCUSTOM(o, which) \
    (Perl_custom_op_get_field(aTHX_ o, XOPe_ ## which).which)

a914 3
#define Perl_custom_op_xop(x) \
    (Perl_custom_op_get_field(x, XOPe_xop_ptr).xop_ptr)

d919 1
a919 1
Return the name of the provided OP.  For core ops this looks up the name
d927 1
a927 1
structures it uses.  For core ops this currently gets the information out
d930 1
a930 1
to the registree to ensure it is accurate.  The value returned will be
a932 18
=for apidoc Am|bool|OP_TYPE_IS|OP *o, Optype type
Returns true if the given OP is not a NULL pointer
and if it is of the given type.

The negation of this macro, C<OP_TYPE_ISNT> is also available
as well as C<OP_TYPE_IS_NN> and C<OP_TYPE_ISNT_NN> which elide
the NULL pointer check.

=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o, Optype type
Returns true if the given OP is not a NULL pointer and
if it is of the given type or used to be before being
replaced by an OP of type OP_NULL.

The negation of this macro, C<OP_TYPE_ISNT_AND_WASNT>
is also available as well as C<OP_TYPE_IS_OR_WAS_NN>
and C<OP_TYPE_ISNT_AND_WASNT_NN> which elide
the NULL pointer check.

d937 1
a937 1
                    ? XopENTRYCUSTOM(o, xop_name) \
d940 1
a940 1
                    ? XopENTRYCUSTOM(o, xop_desc) \
d943 1
a943 1
		     ? XopENTRYCUSTOM(o, xop_class) \
d946 1
a946 25
#define OP_TYPE_IS(o, type) ((o) && (o)->op_type == (type))
#define OP_TYPE_IS_NN(o, type) ((o)->op_type == (type))
#define OP_TYPE_ISNT(o, type) ((o) && (o)->op_type != (type))
#define OP_TYPE_ISNT_NN(o, type) ((o)->op_type != (type))

#define OP_TYPE_IS_OR_WAS_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      == (type) )

#define OP_TYPE_IS_OR_WAS(o, type) \
    ( (o) && OP_TYPE_IS_OR_WAS_NN(o, type) )

#define OP_TYPE_ISNT_AND_WASNT_NN(o, type) \
    ( ((o)->op_type == OP_NULL \
       ? (o)->op_targ \
       : (o)->op_type) \
      != (type) )

#define OP_TYPE_ISNT_AND_WASNT(o, type) \
    ( (o) && OP_TYPE_ISNT_AND_WASNT_NN(o, type) )

#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d960 1
a960 1
    XOPe_xop_peep = XOPf_xop_peep
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d27 1
a27 2
 *	op_moresib	this op is is not the last sibling
 *	op_spare	One spare bit
d38 2
a39 7
typedef PERL_BITFIELD16 Optype;

/* this field now either points to the next sibling or to the parent,
 * depending on op_moresib. So rename it from op_sibling to op_sibparent.
 */
#ifdef PERL_OP_PARENT
#  define _OP_SIBPARENT_FIELDNAME op_sibparent
d41 1
a41 1
#  define _OP_SIBPARENT_FIELDNAME op_sibling
d44 2
d51 1
a51 1
    OP*		_OP_SIBPARENT_FIELDNAME;\
d53 1
d61 1
a61 2
    PERL_BITFIELD16 op_moresib:1;       \
    PERL_BITFIELD16 op_spare:1;		\
d66 1
a66 1
/* If op_type:9 is changed to :10, also change cx_pusheval()
d112 1
a112 2
				/*  On OP_LEAVE, don't restore curpm, e.g.
                                 *      /(...)/ while ...>;  */
d117 1
a117 2
				/*  On OP_CHDIR, handle (or bare parens) */
				/*  On OP_NULL, saw a "do". */
d122 1
d133 3
a135 4
				/*  On OP_HELEM, OP_MULTIDEREF and OP_HSLICE,
                                    localization will be followed by assignment,
                                    so do not wipe the target if it is special
                                    (e.g. a glob or a magic SV) */
a146 5
                                /*  On OP_UNSTACK, in a C-style for loop */
/* There is no room in op_flags for this one, so it has its own bit-
   field member (op_folded) instead.  The flag is only used to tell
   op_convert_list to set op_folded.  */
#define OPf_FOLDED      1<<16
d152 1
a152 2
#if !defined(PERL_CORE) && !defined(PERL_EXT)
#  define GIMME \
a157 1
#endif
d159 2
d162 2
a163 2
/* NOTE: OPp* flags are now auto-generated and defined in opcode.h,
 *       from data in regen/op_private */
d165 2
d168 29
d199 2
d202 31
d234 8
a241 2
/* Mask for OP_ENTERSUB flags, the absence of which must be propagated
 in dynamic context */
d244 89
d334 26
a359 14
/* things that can be elements of op_aux */
typedef union  {
    PADOFFSET pad_offset;
    SV        *sv;
    IV        iv;
    UV        uv;
} UNOP_AUX_item;

#ifdef USE_ITHREADS
#  define UNOP_AUX_item_sv(item) PAD_SVl((item)->pad_offset);
#else
#  define UNOP_AUX_item_sv(item) ((item)->sv);
#endif

d361 2
d364 2
a375 6
struct unop_aux {
    BASEOP
    OP  	  *op_first;
    UNOP_AUX_item *op_aux;
};

a393 16
struct methop {
    BASEOP
    union {
        /* op_u.op_first *must* be aligned the same as the op_first
         * field of the other op types, and op_u.op_meth_sv *must*
         * be aligned with op_sv */
        OP* op_first;   /* optree for method name */
        SV* op_meth_sv; /* static method name */
    } op_u;
#ifdef USE_ITHREADS
    PADOFFSET op_rclass_targ; /* pad index for redirect class */
#else
    SV*       op_rclass_sv;   /* static redirect class $o->A::meth() */
#endif
};

d444 3
a446 31
/* Currently these PMf flags occupy a single 32-bit word.  Not all bits are
 * currently used.  The lower bits are shared with their corresponding RXf flag
 * bits, up to but not including _RXf_PMf_SHIFT_NEXT.  The unused bits
 * immediately follow; finally the used Pmf-only (unshared) bits, so that the
 * highest bit in the word is used.  This gathers all the unused bits as a pool
 * in the middle, like so: 11111111111111110000001111111111
 * where the '1's represent used bits, and the '0's unused.  This design allows
 * us to allocate off one end of the pool if we need to add a shared bit, and
 * off the other end if we need a non-shared bit, without disturbing the other
 * bits.  This maximizes the likelihood of being able to change things without
 * breaking binary compatibility.
 *
 * To add shared bits, do so in op_reg_common.h.  This should change
 * _RXf_PMf_SHIFT_NEXT so that things won't compile.  Then come to regexp.h and
 * op.h and adjust the constant adders in the definitions of PMf_BASE_SHIFT and
 * Pmf_BASE_SHIFT down by the number of shared bits you added.  That's it.
 * Things should be binary compatible.  But if either of these gets to having
 * to subtract rather than add, leave at 0 and adjust all the entries below
 * that are in terms of this according.  But if the first one of those is
 * already PMf_BASE_SHIFT+0, there are no bits left, and a redesign is in
 * order.
 *
 * To remove unshared bits, just delete its entry.  If you're where breaking
 * binary compatibility is ok to do, you might want to adjust things to move
 * the newly opened space so that it gets absorbed into the common pool.
 *
 * To add unshared bits, first use up any gaps in the middle.  Otherwise,
 * allocate off the low end until you get to PMf_BASE_SHIFT+0.  If that isn't
 * enough, move PMf_BASE_SHIFT down (if possible) and add the new bit at the
 * other end instead; this preserves binary compatibility. */
#define PMf_BASE_SHIFT (_RXf_PMf_SHIFT_NEXT+2)
d449 1
a449 1
#define PMf_RETAINT	(1U<<(PMf_BASE_SHIFT+5))
d454 1
a454 1
#define PMf_ONCE	(1U<<(PMf_BASE_SHIFT+6))
d457 1
a457 1
#define PMf_USED        (1U<<(PMf_BASE_SHIFT+7))
d460 1
a460 1
#define PMf_CONST	(1U<<(PMf_BASE_SHIFT+8))
d463 1
a463 1
#define PMf_KEEP	(1U<<(PMf_BASE_SHIFT+9))
d465 1
a465 1
#define PMf_GLOBAL	(1U<<(PMf_BASE_SHIFT+10)) /* pattern had a g modifier */
d468 1
a468 1
#define PMf_CONTINUE	(1U<<(PMf_BASE_SHIFT+11))
d471 1
a471 1
#define PMf_EVAL	(1U<<(PMf_BASE_SHIFT+12))
d474 1
a474 1
#define PMf_NONDESTRUCT	(1U<<(PMf_BASE_SHIFT+13))
d477 1
a477 1
#define PMf_HAS_CV	(1U<<(PMf_BASE_SHIFT+14))
d481 1
a481 1
#define PMf_CODELIST_PRIVATE	(1U<<(PMf_BASE_SHIFT+15))
d486 2
a487 2
#define PMf_IS_QR	(1U<<(PMf_BASE_SHIFT+16))
#define PMf_USE_RE_EVAL	(1U<<(PMf_BASE_SHIFT+17)) /* use re'eval' in scope */
d489 1
a489 5
/* See comments at the beginning of these defines about adding bits.  The
 * highest bit position should be used, so that if PMf_BASE_SHIFT gets
 * increased, the #error below will be triggered so that you will be reminded
 * to adjust things at the other end to keep the bit positions unchanged */
#if PMf_BASE_SHIFT+17 > 31
d542 10
a551 12
#define cUNOPx(o)	((UNOP*)(o))
#define cUNOP_AUXx(o)	((UNOP_AUX*)(o))
#define cBINOPx(o)	((BINOP*)(o))
#define cLISTOPx(o)	((LISTOP*)(o))
#define cLOGOPx(o)	((LOGOP*)(o))
#define cPMOPx(o)	((PMOP*)(o))
#define cSVOPx(o)	((SVOP*)(o))
#define cPADOPx(o)	((PADOP*)(o))
#define cPVOPx(o)	((PVOP*)(o))
#define cCOPx(o)	((COP*)(o))
#define cLOOPx(o)	((LOOP*)(o))
#define cMETHOPx(o)	((METHOP*)(o))
a553 1
#define cUNOP_AUX	cUNOP_AUXx(PL_op)
a564 1
#define cUNOP_AUXo	cUNOP_AUXx(o)
a575 1
#define kUNOP_AUX	cUNOP_AUXx(kid)
d589 3
a591 3
#  ifndef PERL_CORE
#    define	IS_PADGV(v)	(v && isGV(v))
#    define	IS_PADCONST(v) \
a592 1
#  endif
a596 1
#  define	cMETHOPx_rclass(v) PAD_SVl(cMETHOPx(v)->op_rclass_targ)
d599 2
a600 4
#  ifndef PERL_CORE
#    define	IS_PADGV(v)	FALSE
#    define	IS_PADCONST(v)	FALSE
#  endif
a602 1
#  define	cMETHOPx_rclass(v) (cMETHOPx(v)->op_rclass_sv)
a604 2
#  define	cMETHOPx_meth(v)	cSVOPx_sv(v)

d626 1
a626 1
/* The next 4 bits (8..11) encode op class information */
a644 2
#define OA_METHOP (14 << OCSHIFT)
#define OA_UNOP_AUX (15 << OCSHIFT)
a645 2
/* Each remaining nybble of PL_opargs (i.e. bits 12..15, 16..19 etc)
 * encode the type for each arg */
d648 1
d696 1
a696 4
#define PERL_LOADMOD_IMPORT_OPS		0x4	/* import arguments
						   are passed as a sin-
						   gle op tree, not a
						   list of SVs */
d709 1
a709 1
returned.  If C<< o->op_next >> is not already set, C<o> should be at
d808 1
a808 1
Return an entry from the BHK structure.  C<which> is a preprocessor token
d810 1
a810 1
this will return C<NULL>.  The type of the return value depends on which
d815 2
a816 2
valid.  C<which> is a preprocessing token indicating which entry to set.
The type of C<ptr> depends on the entry.
d820 1
a820 1
appropriate flag.  C<which> is a preprocessor token indicating which
d825 1
a825 1
flag.  C<which> is a preprocessor token indicating which entry to enable.
d830 2
a831 2
Call all the registered block hooks for type C<which>.  C<which> is a
preprocessing token; the type of C<arg> depends on C<which>.
a886 5
#define RV2CVOPCV_RETURN_STUB    0x00000004
#ifdef PERL_CORE /* behaviour of this flag is subject to change: */
# define RV2CVOPCV_MAYBE_NAME_GV  0x00000008
#endif
#define RV2CVOPCV_FLAG_MASK      0x0000000f /* all of the above */
d901 1
a901 1
Return a member of the XOP structure.  C<which> is a cpp token
d904 1
a904 1
on C<which>.  This macro evaluates its arguments more than
d910 1
a910 1
efficient.  The C<which> parameter is identical to L</XopENTRY>.
d913 1
a913 1
Set a member of the XOP structure.  C<which> is a cpp token
d1003 1
a1003 1
of C<PL_opargs>, which does not always accurately reflect the type used.
d1006 1
a1006 1
one of the C<OA_>* constants from F<op.h>.
d1008 2
a1009 2
=for apidoc Am|bool|OP_TYPE_IS|OP *o|Optype type
Returns true if the given OP is not a C<NULL> pointer
d1016 1
a1016 1
=for apidoc Am|bool|OP_TYPE_IS_OR_WAS|OP *o|Optype type
d1024 1
a1024 22
the C<NULL> pointer check.

=for apidoc Am|bool|OpHAS_SIBLING|OP *o
Returns true if C<o> has a sibling

=for apidoc Am|OP*|OpSIBLING|OP *o
Returns the sibling of C<o>, or C<NULL> if there is no sibling

=for apidoc Am|void|OpMORESIB_set|OP *o|OP *sib
Sets the sibling of C<o> to the non-zero value C<sib>. See also C<L</OpLASTSIB_set>>
and C<L</OpMAYBESIB_set>>. For a higher-level interface, see
C<L</op_sibling_splice>>.

=for apidoc Am|void|OpLASTSIB_set|OP *o|OP *parent
Marks C<o> as having no further siblings. On C<PERL_OP_PARENT> builds, marks
o as having the specified parent. See also C<L</OpMORESIB_set>> and
C<OpMAYBESIB_set>. For a higher-level interface, see
C<L</op_sibling_splice>>.

=for apidoc Am|void|OpMAYBESIB_set|OP *o|OP *sib|OP *parent
Conditionally does C<OpMORESIB_set> or C<OpLASTSIB_set> depending on whether
C<sib> is non-null. For a higher-level interface, see C<L</op_sibling_splice>>.
d1062 2
d1065 14
a1078 17
#ifdef PERL_OP_PARENT
#  define OpHAS_SIBLING(o)	(cBOOL((o)->op_moresib))
#  define OpSIBLING(o)		(0 + (o)->op_moresib ? (o)->op_sibparent : NULL)
#  define OpMORESIB_set(o, sib) ((o)->op_moresib = 1, (o)->op_sibparent = (sib))
#  define OpLASTSIB_set(o, parent) \
       ((o)->op_moresib = 0, (o)->op_sibparent = (parent))
#  define OpMAYBESIB_set(o, sib, parent) \
       ((o)->op_sibparent = ((o)->op_moresib = cBOOL(sib)) ? (sib) : (parent))
#else
#  define OpHAS_SIBLING(o)	(cBOOL((o)->op_sibling))
#  define OpSIBLING(o)		(0 + (o)->op_sibling)
#  define OpMORESIB_set(o, sib) ((o)->op_moresib = 1, (o)->op_sibling = (sib))
#  define OpLASTSIB_set(o, parent) \
       ((o)->op_moresib = 0, (o)->op_sibling = NULL)
#  define OpMAYBESIB_set(o, sib, parent) \
       ((o)->op_moresib = cBOOL(sib), (o)->op_sibling = (sib))
#endif
d1080 5
a1084 3
#if !defined(PERL_CORE) && !defined(PERL_EXT)
/* for backwards compatibility only */
#  define OP_SIBLING(o)		OpSIBLING(o)
d1087 74
a1160 2
#define newATTRSUB(f, o, p, a, b) Perl_newATTRSUB_x(aTHX_  f, o, p, a, b, FALSE)
#define newSUB(f, o, p, b)	newATTRSUB((f), (o), (p), NULL, (b))
a1177 47

/* Stuff for OP_MULTDEREF/pp_multideref. */

/* actions */

/* Load another word of actions/flag bits. Must be 0 */
#define MDEREF_reload                       0

#define MDEREF_AV_pop_rv2av_aelem           1
#define MDEREF_AV_gvsv_vivify_rv2av_aelem   2
#define MDEREF_AV_padsv_vivify_rv2av_aelem  3
#define MDEREF_AV_vivify_rv2av_aelem        4
#define MDEREF_AV_padav_aelem               5
#define MDEREF_AV_gvav_aelem                6

#define MDEREF_HV_pop_rv2hv_helem           8
#define MDEREF_HV_gvsv_vivify_rv2hv_helem   9
#define MDEREF_HV_padsv_vivify_rv2hv_helem 10
#define MDEREF_HV_vivify_rv2hv_helem       11
#define MDEREF_HV_padhv_helem              12
#define MDEREF_HV_gvhv_helem               13

#define MDEREF_ACTION_MASK                0xf

/* key / index type */

#define MDEREF_INDEX_none   0x00 /* run external ops to generate index */
#define MDEREF_INDEX_const  0x10 /* index is const PV/UV */
#define MDEREF_INDEX_padsv  0x20 /* index is lexical var */
#define MDEREF_INDEX_gvsv   0x30 /* index is GV */

#define MDEREF_INDEX_MASK   0x30

/* bit flags */

#define MDEREF_FLAG_last    0x40 /* the last [ah]elem; PL_op flags apply */

#define MDEREF_MASK         0x7F
#define MDEREF_SHIFT           7

#if defined(PERL_IN_DOOP_C) || defined(PERL_IN_PP_C)
static const char * const deprecated_above_ff_msg
    = "Use of strings with code points over 0xFF as arguments to "
      "%s operator is deprecated";
#endif


d1179 6
@


