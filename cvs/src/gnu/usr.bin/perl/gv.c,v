head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.2
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2016.07.03.01.07.47;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	GzHqjSTnBjdF7Wcw;

1.17
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	XRK22kO4se3v2i2I;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.19;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.48;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.40;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.24;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.26;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.32;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.24;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.09;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.45.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    gv.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *   'Mercy!' cried Gandalf.  'If the giving of information is to be the cure
 * of your inquisitiveness, I shall spend all the rest of my days in answering
 * you.  What more do you want to know?'
 *   'The names of all the stars, and of all living things, and the whole
 * history of Middle-earth and Over-heaven and of the Sundering Seas,'
 * laughed Pippin.
 *
 *     [p.599 of _The Lord of the Rings_, III/xi: "The PalantÃ­r"]
 */

/*
=head1 GV Functions
A GV is a structure which corresponds to to a Perl typeglob, ie *foo.
It is a structure that holds a pointer to a scalar, an array, a hash etc,
corresponding to $foo, @@foo, %foo.

GVs are usually found as values in stashes (symbol table hashes) where
Perl stores its global variables.

=cut
*/

#include "EXTERN.h"
#define PERL_IN_GV_C
#include "perl.h"
#include "overload.inc"
#include "keywords.h"
#include "feature.h"

static const char S_autoload[] = "AUTOLOAD";
#define S_autolen (sizeof("AUTOLOAD")-1)

GV *
Perl_gv_add_by_type(pTHX_ GV *gv, svtype type)
{
    SV **where;

    if (
        !gv
     || (
            SvTYPE((const SV *)gv) != SVt_PVGV
         && SvTYPE((const SV *)gv) != SVt_PVLV
        )
    ) {
	const char *what;
	if (type == SVt_PVIO) {
	    /*
	     * if it walks like a dirhandle, then let's assume that
	     * this is a dirhandle.
	     */
	    what = OP_IS_DIRHOP(PL_op->op_type) ?
		"dirhandle" : "filehandle";
	} else if (type == SVt_PVHV) {
	    what = "hash";
	} else {
	    what = type == SVt_PVAV ? "array" : "scalar";
	}
	/* diag_listed_as: Bad symbol for filehandle */
	Perl_croak(aTHX_ "Bad symbol for %s", what);
    }

    if (type == SVt_PVHV) {
	where = (SV **)&GvHV(gv);
    } else if (type == SVt_PVAV) {
	where = (SV **)&GvAV(gv);
    } else if (type == SVt_PVIO) {
	where = (SV **)&GvIOp(gv);
    } else {
	where = &GvSV(gv);
    }

    if (!*where)
    {
	*where = newSV_type(type);
	    if (type == SVt_PVAV && GvNAMELEN(gv) == 3
	     && strnEQ(GvNAME(gv), "ISA", 3))
	    sv_magic(*where, (SV *)gv, PERL_MAGIC_isa, NULL, 0);
    }
    return gv;
}

GV *
Perl_gv_fetchfile(pTHX_ const char *name)
{
    PERL_ARGS_ASSERT_GV_FETCHFILE;
    return gv_fetchfile_flags(name, strlen(name), 0);
}

GV *
Perl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN namelen,
			const U32 flags)
{
    char smallbuf[128];
    char *tmpbuf;
    const STRLEN tmplen = namelen + 2;
    GV *gv;

    PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS;
    PERL_UNUSED_ARG(flags);

    if (!PL_defstash)
	return NULL;

    if (tmplen <= sizeof smallbuf)
	tmpbuf = smallbuf;
    else
	Newx(tmpbuf, tmplen, char);
    /* This is where the debugger's %{"::_<$filename"} hash is created */
    tmpbuf[0] = '_';
    tmpbuf[1] = '<';
    memcpy(tmpbuf + 2, name, namelen);
    gv = *(GV**)hv_fetch(PL_defstash, tmpbuf, tmplen, TRUE);
    if (!isGV(gv)) {
	gv_init(gv, PL_defstash, tmpbuf, tmplen, FALSE);
#ifdef PERL_DONT_CREATE_GVSV
	GvSV(gv) = newSVpvn(name, namelen);
#else
	sv_setpvn(GvSV(gv), name, namelen);
#endif
    }
    if (PERLDB_LINE_OR_SAVESRC && !GvAV(gv))
	    hv_magic(GvHVn(gv), GvAVn(gv), PERL_MAGIC_dbfile);
    if (tmpbuf != smallbuf)
	Safefree(tmpbuf);
    return gv;
}

/*
=for apidoc gv_const_sv

If C<gv> is a typeglob whose subroutine entry is a constant sub eligible for
inlining, or C<gv> is a placeholder reference that would be promoted to such
a typeglob, then returns the value returned by the sub.  Otherwise, returns
C<NULL>.

=cut
*/

SV *
Perl_gv_const_sv(pTHX_ GV *gv)
{
    PERL_ARGS_ASSERT_GV_CONST_SV;
    PERL_UNUSED_CONTEXT;

    if (SvTYPE(gv) == SVt_PVGV)
	return cv_const_sv(GvCVu(gv));
    return SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVAV && SvTYPE(SvRV(gv)) != SVt_PVCV ? SvRV(gv) : NULL;
}

GP *
Perl_newGP(pTHX_ GV *const gv)
{
    GP *gp;
    U32 hash;
    const char *file;
    STRLEN len;
#ifndef USE_ITHREADS
    GV *filegv;
#endif
    dVAR;

    PERL_ARGS_ASSERT_NEWGP;
    Newxz(gp, 1, GP);
    gp->gp_egv = gv; /* allow compiler to reuse gv after this */
#ifndef PERL_DONT_CREATE_GVSV
    gp->gp_sv = newSV(0);
#endif

    /* PL_curcop may be null here.  E.g.,
	INIT { bless {} and exit }
       frees INIT before looking up DESTROY (and creating *DESTROY)
    */
    if (PL_curcop) {
	gp->gp_line = CopLINE(PL_curcop); /* 0 otherwise Newxz */
#ifdef USE_ITHREADS
	if (CopFILE(PL_curcop)) {
	    file = CopFILE(PL_curcop);
	    len = strlen(file);
	}
#else
	filegv = CopFILEGV(PL_curcop);
	if (filegv) {
	    file = GvNAME(filegv)+2;
	    len = GvNAMELEN(filegv)-2;
	}
#endif
	else goto no_file;
    }
    else {
	no_file:
	file = "";
	len = 0;
    }

    PERL_HASH(hash, file, len);
    gp->gp_file_hek = share_hek(file, len, hash);
    gp->gp_refcnt = 1;

    return gp;
}

/* Assign CvGV(cv) = gv, handling weak references.
 * See also S_anonymise_cv_maybe */

void
Perl_cvgv_set(pTHX_ CV* cv, GV* gv)
{
    GV * const oldgv = CvNAMED(cv) ? NULL : SvANY(cv)->xcv_gv_u.xcv_gv;
    HEK *hek;
    PERL_ARGS_ASSERT_CVGV_SET;

    if (oldgv == gv)
	return;

    if (oldgv) {
	if (CvCVGV_RC(cv)) {
	    SvREFCNT_dec_NN(oldgv);
	    CvCVGV_RC_off(cv);
	}
	else {
	    sv_del_backref(MUTABLE_SV(oldgv), MUTABLE_SV(cv));
	}
    }
    else if ((hek = CvNAME_HEK(cv))) {
	unshare_hek(hek);
	CvLEXICAL_off(cv);
    }

    CvNAMED_off(cv);
    SvANY(cv)->xcv_gv_u.xcv_gv = gv;
    assert(!CvCVGV_RC(cv));

    if (!gv)
	return;

    if (isGV_with_GP(gv) && GvGP(gv) && (GvCV(gv) == cv || GvFORM(gv) == cv))
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(gv), MUTABLE_SV(cv));
    else {
	CvCVGV_RC_on(cv);
	SvREFCNT_inc_simple_void_NN(gv);
    }
}

/* Convert CvSTASH + CvNAME_HEK into a GV.  Conceptually, all subs have a
   GV, but for efficiency that GV may not in fact exist.  This function,
   called by CvGV, reifies it. */

GV *
Perl_cvgv_from_hek(pTHX_ CV *cv)
{
    GV *gv;
    SV **svp;
    PERL_ARGS_ASSERT_CVGV_FROM_HEK;
    assert(SvTYPE(cv) == SVt_PVCV);
    if (!CvSTASH(cv)) return NULL;
    ASSUME(CvNAME_HEK(cv));
    svp = hv_fetchhek(CvSTASH(cv), CvNAME_HEK(cv), 0);
    gv = MUTABLE_GV(svp && *svp ? *svp : newSV(0));
    if (!isGV(gv))
	gv_init_pvn(gv, CvSTASH(cv), HEK_KEY(CvNAME_HEK(cv)),
		HEK_LEN(CvNAME_HEK(cv)),
		SVf_UTF8 * !!HEK_UTF8(CvNAME_HEK(cv)));
    if (!CvNAMED(cv)) { /* gv_init took care of it */
	assert (SvANY(cv)->xcv_gv_u.xcv_gv == gv);
	return gv;
    }
    unshare_hek(CvNAME_HEK(cv));
    CvNAMED_off(cv);
    SvANY(cv)->xcv_gv_u.xcv_gv = gv;
    if (svp && *svp) SvREFCNT_inc_simple_void_NN(gv);
    CvCVGV_RC_on(cv);
    return gv;
}

/* Assign CvSTASH(cv) = st, handling weak references. */

void
Perl_cvstash_set(pTHX_ CV *cv, HV *st)
{
    HV *oldst = CvSTASH(cv);
    PERL_ARGS_ASSERT_CVSTASH_SET;
    if (oldst == st)
	return;
    if (oldst)
	sv_del_backref(MUTABLE_SV(oldst), MUTABLE_SV(cv));
    SvANY(cv)->xcv_stash = st;
    if (st)
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(st), MUTABLE_SV(cv));
}

/*
=for apidoc gv_init_pvn

Converts a scalar into a typeglob.  This is an incoercible typeglob;
assigning a reference to it will assign to one of its slots, instead of
overwriting it as happens with typeglobs created by C<SvSetSV>.  Converting
any scalar that is C<SvOK()> may produce unpredictable results and is reserved
for perl's internal use.

C<gv> is the scalar to be converted.

C<stash> is the parent stash/package, if any.

C<name> and C<len> give the name.  The name must be unqualified;
that is, it must not include the package name.  If C<gv> is a
stash element, it is the caller's responsibility to ensure that the name
passed to this function matches the name of the element.  If it does not
match, perl's internal bookkeeping will get out of sync.

C<flags> can be set to C<SVf_UTF8> if C<name> is a UTF-8 string, or
the return value of SvUTF8(sv).  It can also take the
C<GV_ADDMULTI> flag, which means to pretend that the GV has been
seen before (i.e., suppress "Used once" warnings).

=for apidoc gv_init

The old form of C<gv_init_pvn()>.  It does not work with UTF-8 strings, as it
has no flags parameter.  If the C<multi> parameter is set, the
C<GV_ADDMULTI> flag will be passed to C<gv_init_pvn()>.

=for apidoc gv_init_pv

Same as C<gv_init_pvn()>, but takes a nul-terminated string for the name
instead of separate char * and length parameters.

=for apidoc gv_init_sv

Same as C<gv_init_pvn()>, but takes an SV * for the name instead of separate
char * and length parameters.  C<flags> is currently unused.

=cut
*/

void
Perl_gv_init_sv(pTHX_ GV *gv, HV *stash, SV* namesv, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_INIT_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   gv_init_pvn(gv, stash, namepv, namelen, flags);
}

void
Perl_gv_init_pv(pTHX_ GV *gv, HV *stash, const char *name, U32 flags)
{
   PERL_ARGS_ASSERT_GV_INIT_PV;
   gv_init_pvn(gv, stash, name, strlen(name), flags);
}

void
Perl_gv_init_pvn(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, U32 flags)
{
    const U32 old_type = SvTYPE(gv);
    const bool doproto = old_type > SVt_NULL;
    char * const proto = (doproto && SvPOK(gv))
	? ((void)(SvIsCOW(gv) && (sv_force_normal((SV *)gv), 0)), SvPVX(gv))
	: NULL;
    const STRLEN protolen = proto ? SvCUR(gv) : 0;
    const U32 proto_utf8  = proto ? SvUTF8(gv) : 0;
    SV *const has_constant = doproto && SvROK(gv) ? SvRV(gv) : NULL;
    const U32 exported_constant = has_constant ? SvPCS_IMPORTED(gv) : 0;

    PERL_ARGS_ASSERT_GV_INIT_PVN;
    assert (!(proto && has_constant));

    if (has_constant) {
	/* The constant has to be a scalar, array or subroutine.  */
	switch (SvTYPE(has_constant)) {
	case SVt_PVHV:
	case SVt_PVFM:
	case SVt_PVIO:
            Perl_croak(aTHX_ "Cannot convert a reference to %s to typeglob",
		       sv_reftype(has_constant, 0));
            break;

	default: NOOP;
	}
	SvRV_set(gv, NULL);
	SvROK_off(gv);
    }


    if (old_type < SVt_PVGV) {
	if (old_type >= SVt_PV)
	    SvCUR_set(gv, 0);
	sv_upgrade(MUTABLE_SV(gv), SVt_PVGV);
    }
    if (SvLEN(gv)) {
	if (proto) {
	    SvPV_set(gv, NULL);
	    SvLEN_set(gv, 0);
	    SvPOK_off(gv);
	} else
	    Safefree(SvPVX_mutable(gv));
    }
    SvIOK_off(gv);
    isGV_with_GP_on(gv);

    GvGP_set(gv, Perl_newGP(aTHX_ gv));
    GvSTASH(gv) = stash;
    if (stash)
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(stash), MUTABLE_SV(gv));
    gv_name_set(gv, name, len, GV_ADD | ( flags & SVf_UTF8 ? SVf_UTF8 : 0 ));
    if (flags & GV_ADDMULTI || doproto)	/* doproto means it */
	GvMULTI_on(gv);			/* _was_ mentioned */
    if (has_constant && SvTYPE(has_constant) == SVt_PVCV) {
	/* Not actually a constant.  Just a regular sub.  */
	CV * const cv = (CV *)has_constant;
	GvCV_set(gv,cv);
	if (CvSTASH(cv) == stash && (
	       CvNAME_HEK(cv) == GvNAME_HEK(gv)
	    || (  HEK_LEN(CvNAME_HEK(cv)) == HEK_LEN(GvNAME_HEK(gv))
	       && HEK_FLAGS(CvNAME_HEK(cv)) != HEK_FLAGS(GvNAME_HEK(gv))
	       && HEK_UTF8(CvNAME_HEK(cv)) == HEK_UTF8(GvNAME_HEK(gv))
	       && memEQ(HEK_KEY(CvNAME_HEK(cv)), GvNAME(gv), GvNAMELEN(gv))
	       )
	   ))
	    CvGV_set(cv,gv);
    }
    else if (doproto) {
	CV *cv;
	if (has_constant) {
	    /* newCONSTSUB takes ownership of the reference from us.  */
	    cv = newCONSTSUB_flags(stash, name, len, flags, has_constant);
	    /* In case op.c:S_process_special_blocks stole it: */
	    if (!GvCV(gv))
		GvCV_set(gv, (CV *)SvREFCNT_inc_simple_NN(cv));
	    assert(GvCV(gv) == cv); /* newCONSTSUB should have set this */
	    /* If this reference was a copy of another, then the subroutine
	       must have been "imported", by a Perl space assignment to a GV
	       from a reference to CV.  */
	    if (exported_constant)
		GvIMPORTED_CV_on(gv);
	    CvSTASH_set(cv, PL_curstash); /* XXX Why is this needed? */
	} else {
	    cv = newSTUB(gv,1);
	}
	if (proto) {
	    sv_usepvn_flags(MUTABLE_SV(cv), proto, protolen,
			    SV_HAS_TRAILING_NUL);
            if ( proto_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
	}
    }
}

STATIC void
S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type)
{
    PERL_ARGS_ASSERT_GV_INIT_SVTYPE;

    switch (sv_type) {
    case SVt_PVIO:
	(void)GvIOn(gv);
	break;
    case SVt_PVAV:
	(void)GvAVn(gv);
	break;
    case SVt_PVHV:
	(void)GvHVn(gv);
	break;
#ifdef PERL_DONT_CREATE_GVSV
    case SVt_NULL:
    case SVt_PVCV:
    case SVt_PVFM:
    case SVt_PVGV:
	break;
    default:
	if(GvSVn(gv)) {
	    /* Work round what appears to be a bug in Sun C++ 5.8 2005/10/13
	       If we just cast GvSVn(gv) to void, it ignores evaluating it for
	       its side effect */
	}
#endif
    }
}

static void core_xsub(pTHX_ CV* cv);

static GV *
S_maybe_add_coresub(pTHX_ HV * const stash, GV *gv,
                          const char * const name, const STRLEN len)
{
    const int code = keyword(name, len, 1);
    static const char file[] = __FILE__;
    CV *cv, *oldcompcv = NULL;
    int opnum = 0;
    bool ampable = TRUE; /* &{}-able */
    COP *oldcurcop = NULL;
    yy_parser *oldparser = NULL;
    I32 oldsavestack_ix = 0;

    assert(gv || stash);
    assert(name);

    if (!code) return NULL; /* Not a keyword */
    switch (code < 0 ? -code : code) {
     /* no support for \&CORE::infix;
        no support for funcs that do not parse like funcs */
    case KEY___DATA__: case KEY___END__: case KEY_and: case KEY_AUTOLOAD:
    case KEY_BEGIN   : case KEY_CHECK  : case KEY_cmp:
    case KEY_default : case KEY_DESTROY:
    case KEY_do      : case KEY_dump   : case KEY_else  : case KEY_elsif  :
    case KEY_END     : case KEY_eq     : case KEY_eval  :
    case KEY_for     : case KEY_foreach: case KEY_format: case KEY_ge     :
    case KEY_given   : case KEY_goto   : case KEY_grep  :
    case KEY_gt   : case KEY_if: case KEY_INIT: case KEY_last: case KEY_le:
    case KEY_local: case KEY_lt: case KEY_m   : case KEY_map : case KEY_my:
    case KEY_ne   : case KEY_next : case KEY_no: case KEY_or: case KEY_our:
    case KEY_package: case KEY_print: case KEY_printf:
    case KEY_q    : case KEY_qq   : case KEY_qr     : case KEY_qw    :
    case KEY_qx   : case KEY_redo : case KEY_require: case KEY_return:
    case KEY_s    : case KEY_say  : case KEY_sort   :
    case KEY_state: case KEY_sub  :
    case KEY_tr   : case KEY_UNITCHECK: case KEY_unless:
    case KEY_until: case KEY_use  : case KEY_when     : case KEY_while :
    case KEY_x    : case KEY_xor  : case KEY_y        :
	return NULL;
    case KEY_chdir:
    case KEY_chomp: case KEY_chop: case KEY_defined: case KEY_delete:
    case KEY_each : case KEY_eof : case KEY_exec   : case KEY_exists:
    case KEY_keys:
    case KEY_lstat:
    case KEY_pop:
    case KEY_push:
    case KEY_shift:
    case KEY_splice: case KEY_split:
    case KEY_stat:
    case KEY_system:
    case KEY_truncate: case KEY_unlink:
    case KEY_unshift:
    case KEY_values:
	ampable = FALSE;
    }
    if (!gv) {
	gv = (GV *)newSV(0);
	gv_init(gv, stash, name, len, TRUE);
    }
    GvMULTI_on(gv);
    if (ampable) {
	ENTER;
	oldcurcop = PL_curcop;
	oldparser = PL_parser;
	lex_start(NULL, NULL, 0);
	oldcompcv = PL_compcv;
	PL_compcv = NULL; /* Prevent start_subparse from setting
	                     CvOUTSIDE. */
	oldsavestack_ix = start_subparse(FALSE,0);
	cv = PL_compcv;
    }
    else {
	/* Avoid calling newXS, as it calls us, and things start to
	   get hairy. */
	cv = MUTABLE_CV(newSV_type(SVt_PVCV));
	GvCV_set(gv,cv);
	GvCVGEN(gv) = 0;
	CvISXSUB_on(cv);
	CvXSUB(cv) = core_xsub;
	PoisonPADLIST(cv);
    }
    CvGV_set(cv, gv); /* This stops new ATTRSUB from setting CvFILE
                         from PL_curcop. */
    /* XSUBs can't be perl lang/perl5db.pl debugged
    if (PERLDB_LINE_OR_SAVESRC)
        (void)gv_fetchfile(file); */
    CvFILE(cv) = (char *)file;
    /* XXX This is inefficient, as doing things this order causes
           a prototype check in newATTRSUB.  But we have to do
           it this order as we need an op number before calling
           new ATTRSUB. */
    (void)core_prototype((SV *)cv, name, code, &opnum);
    if (stash)
	(void)hv_store(stash,name,len,(SV *)gv,0);
    if (ampable) {
#ifdef DEBUGGING
        CV *orig_cv = cv;
#endif
	CvLVALUE_on(cv);
        /* newATTRSUB will free the CV and return NULL if we're still
           compiling after a syntax error */
	if ((cv = newATTRSUB_x(
		   oldsavestack_ix, (OP *)gv,
	           NULL,NULL,
	           coresub_op(
	             opnum
	               ? newSVuv((UV)opnum)
	               : newSVpvn(name,len),
	             code, opnum
	           ),
	           TRUE
               )) != NULL) {
            assert(GvCV(gv) == orig_cv);
            if (opnum != OP_VEC && opnum != OP_SUBSTR && opnum != OP_POS
                && opnum != OP_UNDEF)
                CvLVALUE_off(cv); /* Now *that* was a neat trick. */
        }
	LEAVE;
	PL_parser = oldparser;
	PL_curcop = oldcurcop;
	PL_compcv = oldcompcv;
    }
    if (cv) {
        SV *opnumsv = opnum ? newSVuv((UV)opnum) : (SV *)NULL;
        cv_set_call_checker(
          cv, Perl_ck_entersub_args_core, opnumsv ? opnumsv : (SV *)cv
        );
        SvREFCNT_dec(opnumsv);
    }

    return gv;
}

/*
=for apidoc gv_fetchmeth

Like L</gv_fetchmeth_pvn>, but lacks a flags parameter.

=for apidoc gv_fetchmeth_sv

Exactly like L</gv_fetchmeth_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_sv(pTHX_ HV *stash, SV *namesv, I32 level, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_GV_FETCHMETH_SV;
    if (LIKELY(SvPOK_nog(namesv))) /* common case */
        return gv_fetchmeth_internal(stash, namesv, NULL, 0, level, flags);
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv)) flags |= SVf_UTF8;
    return gv_fetchmeth_pvn(stash, namepv, namelen, level, flags);
}

/*
=for apidoc gv_fetchmeth_pv

Exactly like L</gv_fetchmeth_pvn>, but takes a nul-terminated string 
instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_pv(pTHX_ HV *stash, const char *name, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PV;
    return gv_fetchmeth_internal(stash, NULL, name, strlen(name), level, flags);
}

/*
=for apidoc gv_fetchmeth_pvn

Returns the glob with the given C<name> and a defined subroutine or
C<NULL>.  The glob lives in the given C<stash>, or in the stashes
accessible via C<@@ISA> and C<UNIVERSAL::>.

The argument C<level> should be either 0 or -1.  If C<level==0>, as a
side-effect creates a glob with the given C<name> in the given C<stash>
which in the case of success contains an alias for the subroutine, and sets
up caching info for this glob.

The only significant values for C<flags> are C<GV_SUPER> and C<SVf_UTF8>.

C<GV_SUPER> indicates that we want to look up the method in the superclasses
of the C<stash>.

The
GV returned from C<gv_fetchmeth> may be a method cache entry, which is not
visible to Perl code.  So when calling C<call_sv>, you should not use
the GV directly; instead, you should use the method's CV, which can be
obtained from the GV with the C<GvCV> macro.

=cut
*/

/* NOTE: No support for tied ISA */

PERL_STATIC_INLINE GV*
S_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags)
{
    GV** gvp;
    HE* he;
    AV* linear_av;
    SV** linear_svp;
    SV* linear_sv;
    HV* cstash, *cachestash;
    GV* candidate = NULL;
    CV* cand_cv = NULL;
    GV* topgv = NULL;
    const char *hvname;
    I32 create = (level >= 0) ? HV_FETCH_LVALUE : 0;
    I32 items;
    U32 topgen_cmp;
    U32 is_utf8 = flags & SVf_UTF8;

    /* UNIVERSAL methods should be callable without a stash */
    if (!stash) {
	create = 0;  /* probably appropriate */
	if(!(stash = gv_stashpvs("UNIVERSAL", 0)))
	    return 0;
    }

    assert(stash);

    hvname = HvNAME_get(stash);
    if (!hvname)
      Perl_croak(aTHX_ "Can't use anonymous symbol table for method lookup");

    assert(hvname);
    assert(name || meth);

    DEBUG_o( Perl_deb(aTHX_ "Looking for %smethod %s in package %s\n",
		      flags & GV_SUPER ? "SUPER " : "",
		      name ? name : SvPV_nolen(meth), hvname) );

    topgen_cmp = HvMROMETA(stash)->cache_gen + PL_sub_generation;

    if (flags & GV_SUPER) {
	if (!HvAUX(stash)->xhv_mro_meta->super)
	    HvAUX(stash)->xhv_mro_meta->super = newHV();
	cachestash = HvAUX(stash)->xhv_mro_meta->super;
    }
    else cachestash = stash;

    /* check locally for a real method or a cache entry */
    he = (HE*)hv_common(
        cachestash, meth, name, len, (flags & SVf_UTF8) ? HVhek_UTF8 : 0, create, NULL, 0
    );
    if (he) gvp = (GV**)&HeVAL(he);
    else gvp = NULL;

    if(gvp) {
        topgv = *gvp;
      have_gv:
        assert(topgv);
        if (SvTYPE(topgv) != SVt_PVGV)
        {
            if (!name)
                name = SvPV_nomg(meth, len);
            gv_init_pvn(topgv, stash, name, len, GV_ADDMULTI|is_utf8);
        }
        if ((cand_cv = GvCV(topgv))) {
            /* If genuine method or valid cache entry, use it */
            if (!GvCVGEN(topgv) || GvCVGEN(topgv) == topgen_cmp) {
                return topgv;
            }
            else {
                /* stale cache entry, junk it and move on */
	        SvREFCNT_dec_NN(cand_cv);
	        GvCV_set(topgv, NULL);
		cand_cv = NULL;
	        GvCVGEN(topgv) = 0;
            }
        }
        else if (GvCVGEN(topgv) == topgen_cmp) {
            /* cache indicates no such method definitively */
            return 0;
        }
	else if (stash == cachestash
	      && len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4
              && strnEQ(hvname, "CORE", 4)
              && S_maybe_add_coresub(aTHX_ NULL,topgv,name,len))
	    goto have_gv;
    }

    linear_av = mro_get_linear_isa(stash); /* has ourselves at the top of the list */
    linear_svp = AvARRAY(linear_av) + 1; /* skip over self */
    items = AvFILLp(linear_av); /* no +1, to skip over self */
    while (items--) {
        linear_sv = *linear_svp++;
        assert(linear_sv);
        cstash = gv_stashsv(linear_sv, 0);

        if (!cstash) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
                           "Can't locate package %"SVf" for @@%"HEKf"::ISA",
			   SVfARG(linear_sv),
                           HEKfARG(HvNAME_HEK(stash)));
            continue;
        }

        assert(cstash);

        gvp = (GV**)hv_fetch(cstash, name, is_utf8 ? -(I32)len : (I32)len, 0);
        if (!gvp) {
            if (len > 1 && HvNAMELEN_get(cstash) == 4) {
                const char *hvname = HvNAME(cstash); assert(hvname);
                if (strnEQ(hvname, "CORE", 4)
                 && (candidate =
                      S_maybe_add_coresub(aTHX_ cstash,NULL,name,len)
                    ))
                    goto have_candidate;
            }
            continue;
        }
        else candidate = *gvp;
       have_candidate:
        assert(candidate);
        if (SvTYPE(candidate) != SVt_PVGV)
            gv_init_pvn(candidate, cstash, name, len, GV_ADDMULTI|is_utf8);
        if (SvTYPE(candidate) == SVt_PVGV && (cand_cv = GvCV(candidate)) && !GvCVGEN(candidate)) {
            /*
             * Found real method, cache method in topgv if:
             *  1. topgv has no synonyms (else inheritance crosses wires)
             *  2. method isn't a stub (else AUTOLOAD fails spectacularly)
             */
            if (topgv && (GvREFCNT(topgv) == 1) && (CvROOT(cand_cv) || CvXSUB(cand_cv))) {
                  CV *old_cv = GvCV(topgv);
                  SvREFCNT_dec(old_cv);
                  SvREFCNT_inc_simple_void_NN(cand_cv);
                  GvCV_set(topgv, cand_cv);
                  GvCVGEN(topgv) = topgen_cmp;
            }
	    return candidate;
        }
    }

    /* Check UNIVERSAL without caching */
    if(level == 0 || level == -1) {
        candidate = gv_fetchmeth_internal(NULL, meth, name, len, 1,
                                          flags &~GV_SUPER);
        if(candidate) {
            cand_cv = GvCV(candidate);
            if (topgv && (GvREFCNT(topgv) == 1) && (CvROOT(cand_cv) || CvXSUB(cand_cv))) {
                  CV *old_cv = GvCV(topgv);
                  SvREFCNT_dec(old_cv);
                  SvREFCNT_inc_simple_void_NN(cand_cv);
                  GvCV_set(topgv, cand_cv);
                  GvCVGEN(topgv) = topgen_cmp;
            }
            return candidate;
        }
    }

    if (topgv && GvREFCNT(topgv) == 1) {
        /* cache the fact that the method is not defined */
        GvCVGEN(topgv) = topgen_cmp;
    }

    return 0;
}

GV *
Perl_gv_fetchmeth_pvn(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN;
    return gv_fetchmeth_internal(stash, NULL, name, len, level, flags);
}

/*
=for apidoc gv_fetchmeth_autoload

This is the old form of L</gv_fetchmeth_pvn_autoload>, which has no flags
parameter.

=for apidoc gv_fetchmeth_sv_autoload

Exactly like L</gv_fetchmeth_pvn_autoload>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_sv_autoload(pTHX_ HV *stash, SV *namesv, I32 level, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_fetchmeth_pvn_autoload(stash, namepv, namelen, level, flags);
}

/*
=for apidoc gv_fetchmeth_pv_autoload

Exactly like L</gv_fetchmeth_pvn_autoload>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_pv_autoload(pTHX_ HV *stash, const char *name, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD;
    return gv_fetchmeth_pvn_autoload(stash, name, strlen(name), level, flags);
}

/*
=for apidoc gv_fetchmeth_pvn_autoload

Same as C<gv_fetchmeth_pvn()>, but looks for autoloaded subroutines too.
Returns a glob for the subroutine.

For an autoloaded subroutine without a GV, will create a GV even
if C<level < 0>.  For an autoloaded subroutine without a stub, C<GvCV()>
of the result may be zero.

Currently, the only significant value for C<flags> is C<SVf_UTF8>.

=cut
*/

GV *
Perl_gv_fetchmeth_pvn_autoload(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
{
    GV *gv = gv_fetchmeth_pvn(stash, name, len, level, flags);

    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD;

    if (!gv) {
	CV *cv;
	GV **gvp;

	if (!stash)
	    return NULL;	/* UNIVERSAL::AUTOLOAD could cause trouble */
	if (len == S_autolen && memEQ(name, S_autoload, S_autolen))
	    return NULL;
	if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE, flags)))
	    return NULL;
	cv = GvCV(gv);
	if (!(CvROOT(cv) || CvXSUB(cv)))
	    return NULL;
	/* Have an autoload */
	if (level < 0)	/* Cannot do without a stub */
	    gv_fetchmeth_pvn(stash, name, len, 0, flags);
	gvp = (GV**)hv_fetch(stash, name,
                        (flags & SVf_UTF8) ? -(I32)len : (I32)len, (level >= 0));
	if (!gvp)
	    return NULL;
	return *gvp;
    }
    return gv;
}

/*
=for apidoc gv_fetchmethod_autoload

Returns the glob which contains the subroutine to call to invoke the method
on the C<stash>.  In fact in the presence of autoloading this may be the
glob for "AUTOLOAD".  In this case the corresponding variable C<$AUTOLOAD> is
already setup.

The third parameter of C<gv_fetchmethod_autoload> determines whether
AUTOLOAD lookup is performed if the given method is not present: non-zero
means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD.
Calling C<gv_fetchmethod> is equivalent to calling C<gv_fetchmethod_autoload>
with a non-zero C<autoload> parameter.

These functions grant C<"SUPER"> token
as a prefix of the method name.  Note
that if you want to keep the returned glob for a long time, you need to
check for it being "AUTOLOAD", since at the later time the call may load a
different subroutine due to C<$AUTOLOAD> changing its value.  Use the glob
created as a side effect to do this.

These functions have the same side-effects as C<gv_fetchmeth> with
C<level==0>.  The warning against passing the GV returned by
C<gv_fetchmeth> to C<call_sv> applies equally to these functions.

=cut
*/

GV *
Perl_gv_fetchmethod_autoload(pTHX_ HV *stash, const char *name, I32 autoload)
{
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD;

    return gv_fetchmethod_flags(stash, name, autoload ? GV_AUTOLOAD : 0);
}

GV *
Perl_gv_fetchmethod_sv_flags(pTHX_ HV *stash, SV *namesv, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS;
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv))
       flags |= SVf_UTF8;
    return gv_fetchmethod_pvn_flags(stash, namepv, namelen, flags);
}

GV *
Perl_gv_fetchmethod_pv_flags(pTHX_ HV *stash, const char *name, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS;
    return gv_fetchmethod_pvn_flags(stash, name, strlen(name), flags);
}

/* Don't merge this yet, as it's likely to get a len parameter, and possibly
   even a U32 hash */
GV *
Perl_gv_fetchmethod_pvn_flags(pTHX_ HV *stash, const char *name, const STRLEN len, U32 flags)
{
    const char *nend;
    const char *nsplit = NULL;
    GV* gv;
    HV* ostash = stash;
    const char * const origname = name;
    SV *const error_report = MUTABLE_SV(stash);
    const U32 autoload = flags & GV_AUTOLOAD;
    const U32 do_croak = flags & GV_CROAK;
    const U32 is_utf8  = flags & SVf_UTF8;

    PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS;

    if (SvTYPE(stash) < SVt_PVHV)
	stash = NULL;
    else {
	/* The only way stash can become NULL later on is if nsplit is set,
	   which in turn means that there is no need for a SVt_PVHV case
	   the error reporting code.  */
    }

    for (nend = name; *nend || nend != (origname + len); nend++) {
	if (*nend == '\'') {
	    nsplit = nend;
	    name = nend + 1;
	}
	else if (*nend == ':' && *(nend + 1) == ':') {
	    nsplit = nend++;
	    name = nend + 1;
	}
    }
    if (nsplit) {
	if ((nsplit - origname) == 5 && memEQ(origname, "SUPER", 5)) {
	    /* ->SUPER::method should really be looked up in original stash */
	    stash = CopSTASH(PL_curcop);
	    flags |= GV_SUPER;
	    DEBUG_o( Perl_deb(aTHX_ "Treating %s as %s::%s\n",
			 origname, HvENAME_get(stash), name) );
	}
	else if ((nsplit - origname) >= 7 &&
		 strnEQ(nsplit - 7, "::SUPER", 7)) {
            /* don't autovifify if ->NoSuchStash::SUPER::method */
	    stash = gv_stashpvn(origname, nsplit - origname - 7, is_utf8);
	    if (stash) flags |= GV_SUPER;
	}
	else {
            /* don't autovifify if ->NoSuchStash::method */
            stash = gv_stashpvn(origname, nsplit - origname, is_utf8);
	}
	ostash = stash;
    }

    gv = gv_fetchmeth_pvn(stash, name, nend - name, 0, flags);
    if (!gv) {
	if (strEQ(name,"import") || strEQ(name,"unimport"))
	    gv = MUTABLE_GV(&PL_sv_yes);
	else if (autoload)
	    gv = gv_autoload_pvn(
		ostash, name, nend - name, GV_AUTOLOAD_ISMETHOD|flags
	    );
	if (!gv && do_croak) {
	    /* Right now this is exclusively for the benefit of S_method_common
	       in pp_hot.c  */
	    if (stash) {
		/* If we can't find an IO::File method, it might be a call on
		 * a filehandle. If IO:File has not been loaded, try to
		 * require it first instead of croaking */
		const char *stash_name = HvNAME_get(stash);
		if (stash_name && memEQs(stash_name, HvNAMELEN_get(stash), "IO::File")
		    && !Perl_hv_common(aTHX_ GvHVn(PL_incgv), NULL,
				       STR_WITH_LEN("IO/File.pm"), 0,
				       HV_FETCH_ISEXISTS, NULL, 0)
		) {
		    require_pv("IO/File.pm");
		    gv = gv_fetchmeth_pvn(stash, name, nend - name, 0, flags);
		    if (gv)
			return gv;
		}
		Perl_croak(aTHX_
			   "Can't locate object method \"%"UTF8f
			   "\" via package \"%"HEKf"\"",
			            UTF8fARG(is_utf8, nend - name, name),
                                    HEKfARG(HvNAME_HEK(stash)));
	    }
	    else {
                SV* packnamesv;

		if (nsplit) {
		    packnamesv = newSVpvn_flags(origname, nsplit - origname,
                                                    SVs_TEMP | is_utf8);
		} else {
		    packnamesv = error_report;
		}

		Perl_croak(aTHX_
			   "Can't locate object method \"%"UTF8f
			   "\" via package \"%"SVf"\""
			   " (perhaps you forgot to load \"%"SVf"\"?)",
			   UTF8fARG(is_utf8, nend - name, name),
                           SVfARG(packnamesv), SVfARG(packnamesv));
	    }
	}
    }
    else if (autoload) {
	CV* const cv = GvCV(gv);
	if (!CvROOT(cv) && !CvXSUB(cv)) {
	    GV* stubgv;
	    GV* autogv;

	    if (CvANON(cv) || CvLEXICAL(cv))
		stubgv = gv;
	    else {
		stubgv = CvGV(cv);
		if (GvCV(stubgv) != cv)		/* orphaned import */
		    stubgv = gv;
	    }
            autogv = gv_autoload_pvn(GvSTASH(stubgv),
                                  GvNAME(stubgv), GvNAMELEN(stubgv),
                                  GV_AUTOLOAD_ISMETHOD
                                   | (GvNAMEUTF8(stubgv) ? SVf_UTF8 : 0));
	    if (autogv)
		gv = autogv;
	}
    }

    return gv;
}

GV*
Perl_gv_autoload_sv(pTHX_ HV *stash, SV* namesv, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_AUTOLOAD_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_autoload_pvn(stash, namepv, namelen, flags);
}

GV*
Perl_gv_autoload_pv(pTHX_ HV *stash, const char *namepv, U32 flags)
{
   PERL_ARGS_ASSERT_GV_AUTOLOAD_PV;
   return gv_autoload_pvn(stash, namepv, strlen(namepv), flags);
}

GV*
Perl_gv_autoload_pvn(pTHX_ HV *stash, const char *name, STRLEN len, U32 flags)
{
    GV* gv;
    CV* cv;
    HV* varstash;
    GV* vargv;
    SV* varsv;
    SV *packname = NULL;
    U32 is_utf8 = flags & SVf_UTF8 ? SVf_UTF8 : 0;

    PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN;

    if (len == S_autolen && memEQ(name, S_autoload, S_autolen))
	return NULL;
    if (stash) {
	if (SvTYPE(stash) < SVt_PVHV) {
            STRLEN packname_len = 0;
            const char * const packname_ptr = SvPV_const(MUTABLE_SV(stash), packname_len);
            packname = newSVpvn_flags(packname_ptr, packname_len,
                                      SVs_TEMP | SvUTF8(stash));
	    stash = NULL;
	}
	else
	    packname = sv_2mortal(newSVhek(HvNAME_HEK(stash)));
	if (flags & GV_SUPER) sv_catpvs(packname, "::SUPER");
    }
    if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE,
				is_utf8 | (flags & GV_SUPER))))
	return NULL;
    cv = GvCV(gv);

    if (!(CvROOT(cv) || CvXSUB(cv)))
	return NULL;

    /*
     * Inheriting AUTOLOAD for non-methods works ... for now.
     */
    if (
        !(flags & GV_AUTOLOAD_ISMETHOD)
     && (GvCVGEN(gv) || GvSTASH(gv) != stash)
    )
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			 "Use of inherited AUTOLOAD for non-method %"SVf
			 "::%"UTF8f"() is deprecated",
			 SVfARG(packname),
                         UTF8fARG(is_utf8, len, name));

    if (CvISXSUB(cv)) {
        /* Instead of forcing the XSUB do another lookup for $AUTOLOAD
         * and split that value on the last '::', pass along the same data
         * via the SvPVX field in the CV, and the stash in CvSTASH.
         *
         * Due to an unfortunate accident of history, the SvPVX field
         * serves two purposes.  It is also used for the subroutine's pro-
         * type.  Since SvPVX has been documented as returning the sub name
         * for a long time, but not as returning the prototype, we have
         * to preserve the SvPVX AUTOLOAD behaviour and put the prototype
         * elsewhere.
         *
         * We put the prototype in the same allocated buffer, but after
         * the sub name.  The SvPOK flag indicates the presence of a proto-
         * type.  The CvAUTOLOAD flag indicates the presence of a sub name.
         * If both flags are on, then SvLEN is used to indicate the end of
         * the prototype (artificially lower than what is actually allo-
         * cated), at the risk of having to reallocate a few bytes unneces-
         * sarily--but that should happen very rarely, if ever.
         *
         * We use SvUTF8 for both prototypes and sub names, so if one is
         * UTF8, the other must be upgraded.
         */
	CvSTASH_set(cv, stash);
	if (SvPOK(cv)) { /* Ouch! */
	    SV * const tmpsv = newSVpvn_flags(name, len, is_utf8);
	    STRLEN ulen;
	    const char *proto = CvPROTO(cv);
	    assert(proto);
	    if (SvUTF8(cv))
		sv_utf8_upgrade_flags_grow(tmpsv, 0, CvPROTOLEN(cv) + 2);
	    ulen = SvCUR(tmpsv);
	    SvCUR(tmpsv)++; /* include null in string */
	    sv_catpvn_flags(
		tmpsv, proto, CvPROTOLEN(cv), SV_CATBYTES*!SvUTF8(cv)
	    );
	    SvTEMP_on(tmpsv); /* Allow theft */
	    sv_setsv_nomg((SV *)cv, tmpsv);
	    SvTEMP_off(tmpsv);
	    SvREFCNT_dec_NN(tmpsv);
	    SvLEN(cv) = SvCUR(cv) + 1;
	    SvCUR(cv) = ulen;
	}
	else {
	  sv_setpvn((SV *)cv, name, len);
	  SvPOK_off(cv);
	  if (is_utf8)
            SvUTF8_on(cv);
	  else SvUTF8_off(cv);
	}
	CvAUTOLOAD_on(cv);
    }

    /*
     * Given &FOO::AUTOLOAD, set $FOO::AUTOLOAD to desired function name.
     * The subroutine's original name may not be "AUTOLOAD", so we don't
     * use that, but for lack of anything better we will use the sub's
     * original package to look up $AUTOLOAD.
     */
    varstash = CvNAMED(cv) ? CvSTASH(cv) : GvSTASH(CvGV(cv));
    vargv = *(GV**)hv_fetch(varstash, S_autoload, S_autolen, TRUE);
    ENTER;

    if (!isGV(vargv)) {
	gv_init_pvn(vargv, varstash, S_autoload, S_autolen, 0);
#ifdef PERL_DONT_CREATE_GVSV
	GvSV(vargv) = newSV(0);
#endif
    }
    LEAVE;
    varsv = GvSVn(vargv);
    SvTAINTED_off(varsv); /* previous $AUTOLOAD taint is obsolete */
    /* XXX: this process is not careful to avoid extra magic gets and sets; tied $AUTOLOAD will get noise */
    sv_setsv(varsv, packname);
    sv_catpvs(varsv, "::");
    /* Ensure SvSETMAGIC() is called if necessary. In particular, to clear
       tainting if $FOO::AUTOLOAD was previously tainted, but is not now.  */
    sv_catpvn_flags(
	varsv, name, len,
	SV_SMAGIC|(is_utf8 ? SV_CATUTF8 : SV_CATBYTES)
    );
    if (is_utf8)
        SvUTF8_on(varsv);
    return gv;
}


/* require_tie_mod() internal routine for requiring a module
 * that implements the logic of automatic ties like %! and %-
 *
 * The "gv" parameter should be the glob.
 * "varpv" holds the name of the var, used for error messages.
 * "namesv" holds the module name. Its refcount will be decremented.
 * "methpv" holds the method name to test for to check that things
 *   are working reasonably close to as expected.
 * "flags": if flag & 1 then save the scalar before loading.
 * For the protection of $! to work (it is set by this routine)
 * the sv slot must already be magicalized.
 */
STATIC HV*
S_require_tie_mod(pTHX_ GV *gv, const char *varpv, SV* namesv, const char *methpv,const U32 flags)
{
    HV* stash = gv_stashsv(namesv, 0);

    PERL_ARGS_ASSERT_REQUIRE_TIE_MOD;

    if (!stash || !(gv_fetchmethod_autoload(stash, methpv, FALSE))) {
	SV *module = newSVsv(namesv);
	char varname = *varpv; /* varpv might be clobbered by load_module,
				  so save it. For the moment it's always
				  a single char. */
	const char type = varname == '[' ? '$' : '%';
#ifdef DEBUGGING
	dSP;
#endif
	ENTER;
	SAVEFREESV(namesv);
	if ( flags & 1 )
	    save_scalar(gv);
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, module, NULL);
	assert(sp == PL_stack_sp);
	stash = gv_stashsv(namesv, 0);
	if (!stash)
	    Perl_croak(aTHX_ "panic: Can't use %c%c because %"SVf" is not available",
		    type, varname, SVfARG(namesv));
	else if (!gv_fetchmethod(stash, methpv))
	    Perl_croak(aTHX_ "panic: Can't use %c%c because %"SVf" does not support method %s",
		    type, varname, SVfARG(namesv), methpv);
	LEAVE;
    }
    else SvREFCNT_dec_NN(namesv);
    return stash;
}

/*
=for apidoc gv_stashpv

Returns a pointer to the stash for a specified package.  Uses C<strlen> to
determine the length of C<name>, then calls C<gv_stashpvn()>.

=cut
*/

HV*
Perl_gv_stashpv(pTHX_ const char *name, I32 create)
{
    PERL_ARGS_ASSERT_GV_STASHPV;
    return gv_stashpvn(name, strlen(name), create);
}

/*
=for apidoc gv_stashpvn

Returns a pointer to the stash for a specified package.  The C<namelen>
parameter indicates the length of the C<name>, in bytes.  C<flags> is passed
to C<gv_fetchpvn_flags()>, so if set to C<GV_ADD> then the package will be
created if it does not already exist.  If the package does not exist and
C<flags> is 0 (or any other setting that does not create packages) then C<NULL>
is returned.

Flags may be one of:

    GV_ADD
    SVf_UTF8
    GV_NOADD_NOINIT
    GV_NOINIT
    GV_NOEXPAND
    GV_ADDMG

The most important of which are probably C<GV_ADD> and C<SVf_UTF8>.

Note, use of C<gv_stashsv> instead of C<gv_stashpvn> where possible is strongly
recommended for performance reasons.

=cut
*/

/*
gv_stashpvn_internal

Perform the internal bits of gv_stashsvpvn_cached. You could think of this
as being one half of the logic. Not to be called except from gv_stashsvpvn_cached().

*/

PERL_STATIC_INLINE HV*
S_gv_stashpvn_internal(pTHX_ const char *name, U32 namelen, I32 flags)
{
    char smallbuf[128];
    char *tmpbuf;
    HV *stash;
    GV *tmpgv;
    U32 tmplen = namelen + 2;

    PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL;

    if (tmplen <= sizeof smallbuf)
	tmpbuf = smallbuf;
    else
	Newx(tmpbuf, tmplen, char);
    Copy(name, tmpbuf, namelen, char);
    tmpbuf[namelen]   = ':';
    tmpbuf[namelen+1] = ':';
    tmpgv = gv_fetchpvn_flags(tmpbuf, tmplen, flags, SVt_PVHV);
    if (tmpbuf != smallbuf)
	Safefree(tmpbuf);
    if (!tmpgv || !isGV_with_GP(tmpgv))
	return NULL;
    stash = GvHV(tmpgv);
    if (!(flags & ~GV_NOADD_MASK) && !stash) return NULL;
    assert(stash);
    if (!HvNAME_get(stash)) {
	hv_name_set(stash, name, namelen, flags & SVf_UTF8 ? SVf_UTF8 : 0 );
	
	/* FIXME: This is a repeat of logic in gv_fetchpvn_flags */
	/* If the containing stash has multiple effective
	   names, see that this one gets them, too. */
	if (HvAUX(GvSTASH(tmpgv))->xhv_name_count)
	    mro_package_moved(stash, NULL, tmpgv, 1);
    }
    return stash;
}

/*
gv_stashsvpvn_cached

Returns a pointer to the stash for a specified package, possibly
cached.  Implements both C<gv_stashpvn> and C<gc_stashsv>.

Requires one of either namesv or namepv to be non-null.

See C<L</gv_stashpvn>> for details on "flags".

Note the sv interface is strongly preferred for performance reasons.

*/

#define PERL_ARGS_ASSERT_GV_STASHSVPVN_CACHED \
    assert(namesv || name)

PERL_STATIC_INLINE HV*
S_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char *name, U32 namelen, I32 flags)
{
    HV* stash;
    HE* he;

    PERL_ARGS_ASSERT_GV_STASHSVPVN_CACHED;

    he = (HE *)hv_common(
        PL_stashcache, namesv, name, namelen,
        (flags & SVf_UTF8) ? HVhek_UTF8 : 0, 0, NULL, 0
    );

    if (he) return INT2PTR(HV*,SvIVX(HeVAL(he)));
    else if (flags & GV_CACHE_ONLY) return NULL;

    if (namesv) {
        if (SvOK(namesv)) { /* prevent double uninit warning */
            STRLEN len;
            name = SvPV_const(namesv, len);
            namelen = len;
            flags |= SvUTF8(namesv);
        } else {
            name = ""; namelen = 0;
        }
    }
    stash = gv_stashpvn_internal(name, namelen, flags);

    if (stash && namelen) {
        SV* const ref = newSViv(PTR2IV(stash));
        (void)hv_store(PL_stashcache, name,
            (flags & SVf_UTF8) ? -(I32)namelen : (I32)namelen, ref, 0);
    }

    return stash;
}

HV*
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 flags)
{
    PERL_ARGS_ASSERT_GV_STASHPVN;
    return gv_stashsvpvn_cached(NULL, name, namelen, flags);
}

/*
=for apidoc gv_stashsv

Returns a pointer to the stash for a specified package.  See
C<L</gv_stashpvn>>.

Note this interface is strongly preferred over C<gv_stashpvn> for performance
reasons.

=cut
*/

HV*
Perl_gv_stashsv(pTHX_ SV *sv, I32 flags)
{
    PERL_ARGS_ASSERT_GV_STASHSV;
    return gv_stashsvpvn_cached(sv, NULL, 0, flags);
}


GV *
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type) {
    PERL_ARGS_ASSERT_GV_FETCHPV;
    return gv_fetchpvn_flags(nambeg, strlen(nambeg), add, sv_type);
}

GV *
Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type) {
    STRLEN len;
    const char * const nambeg =
       SvPV_flags_const(name, len, flags & GV_NO_SVGMAGIC ? 0 : SV_GMAGIC);
    PERL_ARGS_ASSERT_GV_FETCHSV;
    return gv_fetchpvn_flags(nambeg, len, flags | SvUTF8(name), sv_type);
}

PERL_STATIC_INLINE void
S_gv_magicalize_isa(pTHX_ GV *gv)
{
    AV* av;

    PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA;

    av = GvAVn(gv);
    GvMULTI_on(gv);
    sv_magic(MUTABLE_SV(av), MUTABLE_SV(gv), PERL_MAGIC_isa,
	     NULL, 0);
}

/* This function grabs name and tries to split a stash and glob
 * from its contents. TODO better description, comments
 * 
 * If the function returns TRUE and 'name == name_end', then
 * 'gv' can be directly returned to the caller of gv_fetchpvn_flags
 */
PERL_STATIC_INLINE bool
S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name,
               STRLEN *len, const char *nambeg, STRLEN full_len,
               const U32 is_utf8, const I32 add)
{
    const char *name_cursor;
    const char *const name_end = nambeg + full_len;
    const char *const name_em1 = name_end - 1;

    PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME;
    
    if (full_len > 2 && **name == '*' && isIDFIRST_lazy_if(*name + 1, is_utf8)) {
        /* accidental stringify on a GV? */
        (*name)++;
    }

    for (name_cursor = *name; name_cursor < name_end; name_cursor++) {
        if (name_cursor < name_em1 &&
            ((*name_cursor == ':' && name_cursor[1] == ':')
           || *name_cursor == '\''))
        {
            if (!*stash)
                *stash = PL_defstash;
            if (!*stash || !SvREFCNT(*stash)) /* symbol table under destruction */
                return FALSE;

            *len = name_cursor - *name;
            if (name_cursor > nambeg) { /* Skip for initial :: or ' */
                const char *key;
                GV**gvp;
                if (*name_cursor == ':') {
                    key = *name;
                    *len += 2;
                }
                else {
                    char *tmpbuf;
                    Newx(tmpbuf, *len+2, char);
                    Copy(*name, tmpbuf, *len, char);
                    tmpbuf[(*len)++] = ':';
                    tmpbuf[(*len)++] = ':';
                    key = tmpbuf;
                }
                gvp = (GV**)hv_fetch(*stash, key, is_utf8 ? -((I32)*len) : (I32)*len, add);
                *gv = gvp ? *gvp : NULL;
                if (*gv && *gv != (const GV *)&PL_sv_undef) {
                    if (SvTYPE(*gv) != SVt_PVGV)
                        gv_init_pvn(*gv, *stash, key, *len, (add & GV_ADDMULTI)|is_utf8);
                    else
                        GvMULTI_on(*gv);
                }
                if (key != *name)
                    Safefree(key);
                if (!*gv || *gv == (const GV *)&PL_sv_undef)
                    return FALSE;

                if (!(*stash = GvHV(*gv))) {
                    *stash = GvHV(*gv) = newHV();
                    if (!HvNAME_get(*stash)) {
                        if (GvSTASH(*gv) == PL_defstash && *len == 6
                            && strnEQ(*name, "CORE", 4))
                            hv_name_set(*stash, "CORE", 4, 0);
                        else
                            hv_name_set(
                                *stash, nambeg, name_cursor-nambeg, is_utf8
                            );
                    /* If the containing stash has multiple effective
                    names, see that this one gets them, too. */
                    if (HvAUX(GvSTASH(*gv))->xhv_name_count)
                        mro_package_moved(*stash, NULL, *gv, 1);
                    }
                }
                else if (!HvNAME_get(*stash))
                    hv_name_set(*stash, nambeg, name_cursor - nambeg, is_utf8);
            }

            if (*name_cursor == ':')
                name_cursor++;
            *name = name_cursor+1;
            if (*name == name_end) {
                if (!*gv)
                    *gv = MUTABLE_GV(*hv_fetchs(PL_defstash, "main::", TRUE));
                return TRUE;
            }
        }
    }
    *len = name_cursor - *name;
    return TRUE;
}

/* Checks if an unqualified name is in the main stash */
PERL_STATIC_INLINE bool
S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8)
{
    PERL_ARGS_ASSERT_GV_IS_IN_MAIN;
    
    /* If it's an alphanumeric variable */
    if ( len && isIDFIRST_lazy_if(name, is_utf8) ) {
        /* Some "normal" variables are always in main::,
         * like INC or STDOUT.
         */
        switch (len) {
            case 1:
            if (*name == '_')
                return TRUE;
            break;
            case 3:
            if ((name[0] == 'I' && name[1] == 'N' && name[2] == 'C')
                || (name[0] == 'E' && name[1] == 'N' && name[2] == 'V')
                || (name[0] == 'S' && name[1] == 'I' && name[2] == 'G'))
                return TRUE;
            break;
            case 4:
            if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
                && name[3] == 'V')
                return TRUE;
            break;
            case 5:
            if (name[0] == 'S' && name[1] == 'T' && name[2] == 'D'
                && name[3] == 'I' && name[4] == 'N')
                return TRUE;
            break;
            case 6:
            if ((name[0] == 'S' && name[1] == 'T' && name[2] == 'D')
                &&((name[3] == 'O' && name[4] == 'U' && name[5] == 'T')
                    ||(name[3] == 'E' && name[4] == 'R' && name[5] == 'R')))
                return TRUE;
            break;
            case 7:
            if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
                && name[3] == 'V' && name[4] == 'O' && name[5] == 'U'
                && name[6] == 'T')
                return TRUE;
            break;
        }
    }
    /* *{""}, or a special variable like $@@ */
    else
        return TRUE;
    
    return FALSE;
}


/* This function is called if parse_gv_stash_name() failed to
 * find a stash, or if GV_NOTQUAL or an empty name was passed
 * to gv_fetchpvn_flags.
 * 
 * It returns FALSE if the default stash can't be found nor created,
 * which might happen during global destruction.
 */
PERL_STATIC_INLINE bool
S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len,
               const U32 is_utf8, const I32 add,
               const svtype sv_type)
{
    PERL_ARGS_ASSERT_FIND_DEFAULT_STASH;
    
    /* No stash in name, so see how we can default */

    if ( gv_is_in_main(name, len, is_utf8) ) {
        *stash = PL_defstash;
    }
    else {
        if (IN_PERL_COMPILETIME) {
            *stash = PL_curstash;
            if (add && (PL_hints & HINT_STRICT_VARS) &&
                sv_type != SVt_PVCV &&
                sv_type != SVt_PVGV &&
                sv_type != SVt_PVFM &&
                sv_type != SVt_PVIO &&
                !(len == 1 && sv_type == SVt_PV &&
                (*name == 'a' || *name == 'b')) )
            {
                GV**gvp = (GV**)hv_fetch(*stash,name,is_utf8 ? -(I32)len : (I32)len,0);
                if (!gvp || *gvp == (const GV *)&PL_sv_undef ||
                    SvTYPE(*gvp) != SVt_PVGV)
                {
                    *stash = NULL;
                }
                else if ((sv_type == SVt_PV   && !GvIMPORTED_SV(*gvp)) ||
                         (sv_type == SVt_PVAV && !GvIMPORTED_AV(*gvp)) ||
                         (sv_type == SVt_PVHV && !GvIMPORTED_HV(*gvp)) )
                {
                    /* diag_listed_as: Variable "%s" is not imported%s */
                    Perl_ck_warner_d(
                        aTHX_ packWARN(WARN_MISC),
                        "Variable \"%c%"UTF8f"\" is not imported",
                        sv_type == SVt_PVAV ? '@@' :
                        sv_type == SVt_PVHV ? '%' : '$',
                        UTF8fARG(is_utf8, len, name));
                    if (GvCVu(*gvp))
                        Perl_ck_warner_d(
                            aTHX_ packWARN(WARN_MISC),
                            "\t(Did you mean &%"UTF8f" instead?)\n",
                            UTF8fARG(is_utf8, len, name)
                        );
                    *stash = NULL;
                }
            }
        }
        else {
            /* Use the current op's stash */
            *stash = CopSTASH(PL_curcop);
        }
    }

    if (!*stash) {
        if (add && !PL_in_clean_all) {
            GV *gv;
            qerror(Perl_mess(aTHX_
                 "Global symbol \"%s%"UTF8f
                 "\" requires explicit package name (did you forget to "
                 "declare \"my %s%"UTF8f"\"?)",
                 (sv_type == SVt_PV ? "$"
                  : sv_type == SVt_PVAV ? "@@"
                  : sv_type == SVt_PVHV ? "%"
                  : ""), UTF8fARG(is_utf8, len, name),
                 (sv_type == SVt_PV ? "$"
                  : sv_type == SVt_PVAV ? "@@"
                  : sv_type == SVt_PVHV ? "%"
                  : ""), UTF8fARG(is_utf8, len, name)));
            /* To maintain the output of errors after the strict exception
             * above, and to keep compat with older releases, rather than
             * placing the variables in the pad, we place
             * them in the <none>:: stash.
             */
            gv = gv_fetchpvs("<none>::", GV_ADDMULTI, SVt_PVHV);
            if (!gv) {
                /* symbol table under destruction */
                return FALSE;
            }
            *stash = GvHV(gv);
        }
        else
            return FALSE;
    }

    if (!SvREFCNT(*stash))   /* symbol table under destruction */
        return FALSE;

    return TRUE;
}

/* gv_magicalize only turns on the SVf_READONLY flag, not SVf_PROTECT.  So
   redefine SvREADONLY_on for that purpose.  We donât use it later on in
   this file.  */
#undef SvREADONLY_on
#define SvREADONLY_on(sv) (SvFLAGS(sv) |= SVf_READONLY)

/* gv_magicalize() is called by gv_fetchpvn_flags when creating
 * a new GV.
 * Note that it does not insert the GV into the stash prior to
 * magicalization, which some variables require need in order
 * to work (like $[, %+, %-, %!), so callers must take care of
 * that beforehand.
 * 
 * The return value has a specific meaning for gv_fetchpvn_flags:
 * If it returns true, and the gv is empty, it indicates that its
 * refcount should be decreased.
 */
PERL_STATIC_INLINE bool
S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len,
               bool addmg, const svtype sv_type)
{
    SSize_t paren;

    PERL_ARGS_ASSERT_GV_MAGICALIZE;
    
    if (stash != PL_defstash) { /* not the main stash */
	/* We only have to check for a few names here: a, b, EXPORT, ISA
	   and VERSION. All the others apply only to the main stash or to
	   CORE (which is checked right after this). */
	if (len) {
	    const char * const name2 = name + 1;
	    switch (*name) {
	    case 'E':
		if (strnEQ(name2, "XPORT", 5))
		    GvMULTI_on(gv);
		break;
	    case 'I':
		if (strEQ(name2, "SA"))
		    gv_magicalize_isa(gv);
		break;
	    case 'V':
		if (strEQ(name2, "ERSION"))
		    GvMULTI_on(gv);
		break;
	    case 'a':
	    case 'b':
		if (len == 1 && sv_type == SVt_PV)
		    GvMULTI_on(gv);
		/* FALLTHROUGH */
	    default:
		goto try_core;
	    }
	    return addmg;
	}
      try_core:
	if (len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4) {
	  /* Avoid null warning: */
	  const char * const stashname = HvNAME(stash); assert(stashname);
	  if (strnEQ(stashname, "CORE", 4))
	    S_maybe_add_coresub(aTHX_ 0, gv, name, len);
	}
    }
    else if (len > 1) {
#ifndef EBCDIC
	if (*name > 'V' ) {
	    NOOP;
	    /* Nothing else to do.
	       The compiler will probably turn the switch statement into a
	       branch table. Make sure we avoid even that small overhead for
               the common case of lower case variable names.  (On EBCDIC
               platforms, we can't just do:
                 if (NATIVE_TO_ASCII(*name) > NATIVE_TO_ASCII('V') ) {
               because cases like '\027' in the switch statement below are
               C1 (non-ASCII) controls on those platforms, so the remapping
               would make them larger than 'V')
             */
	} else
#endif
	{
	    const char * name2 = name + 1;
	    switch (*name) {
	    case 'A':
		if (strEQ(name2, "RGV")) {
		    IoFLAGS(GvIOn(gv)) |= IOf_ARGV|IOf_START;
		}
		else if (strEQ(name2, "RGVOUT")) {
		    GvMULTI_on(gv);
		}
		break;
	    case 'E':
		if (strnEQ(name2, "XPORT", 5))
		    GvMULTI_on(gv);
		break;
	    case 'I':
		if (strEQ(name2, "SA")) {
		    gv_magicalize_isa(gv);
		}
		break;
	    case 'S':
		if (strEQ(name2, "IG")) {
		    HV *hv;
		    I32 i;
		    if (!PL_psig_name) {
			Newxz(PL_psig_name, 2 * SIG_SIZE, SV*);
			Newxz(PL_psig_pend, SIG_SIZE, int);
			PL_psig_ptr = PL_psig_name + SIG_SIZE;
		    } else {
			/* I think that the only way to get here is to re-use an
			   embedded perl interpreter, where the previous
			   use didn't clean up fully because
			   PL_perl_destruct_level was 0. I'm not sure that we
			   "support" that, in that I suspect in that scenario
			   there are sufficient other garbage values left in the
			   interpreter structure that something else will crash
			   before we get here. I suspect that this is one of
			   those "doctor, it hurts when I do this" bugs.  */
			Zero(PL_psig_name, 2 * SIG_SIZE, SV*);
			Zero(PL_psig_pend, SIG_SIZE, int);
		    }
		    GvMULTI_on(gv);
		    hv = GvHVn(gv);
		    hv_magic(hv, NULL, PERL_MAGIC_sig);
		    for (i = 1; i < SIG_SIZE; i++) {
			SV * const * const init = hv_fetch(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
			if (init)
			    sv_setsv(*init, &PL_sv_undef);
		    }
		}
		break;
	    case 'V':
		if (strEQ(name2, "ERSION"))
		    GvMULTI_on(gv);
		break;
            case '\003':        /* $^CHILD_ERROR_NATIVE */
		if (strEQ(name2, "HILD_ERROR_NATIVE"))
		    goto magicalize;
		break;
	    case '\005':	/* $^ENCODING */
                if (*name2 == '_') {
                    name2++;
                }
		if (strEQ(name2, "NCODING"))
		    goto magicalize;
		break;
	    case '\007':	/* $^GLOBAL_PHASE */
		if (strEQ(name2, "LOBAL_PHASE"))
		    goto ro_magicalize;
		break;
	    case '\014':	/* $^LAST_FH */
		if (strEQ(name2, "AST_FH"))
		    goto ro_magicalize;
		break;
            case '\015':        /* $^MATCH */
                if (strEQ(name2, "ATCH")) {
                    paren = RX_BUFF_IDX_CARET_FULLMATCH;
                    goto storeparen;
                }
                break;
	    case '\017':	/* $^OPEN */
		if (strEQ(name2, "PEN"))
		    goto magicalize;
		break;
	    case '\020':        /* $^PREMATCH  $^POSTMATCH */
                if (strEQ(name2, "REMATCH")) {
                    paren = RX_BUFF_IDX_CARET_PREMATCH;
                    goto storeparen;
                }
	        if (strEQ(name2, "OSTMATCH")) {
                    paren = RX_BUFF_IDX_CARET_POSTMATCH;
                    goto storeparen;
                }
		break;
	    case '\024':	/* ${^TAINT} */
		if (strEQ(name2, "AINT"))
		    goto ro_magicalize;
		break;
	    case '\025':	/* ${^UNICODE}, ${^UTF8LOCALE} */
		if (strEQ(name2, "NICODE"))
		    goto ro_magicalize;
		if (strEQ(name2, "TF8LOCALE"))
		    goto ro_magicalize;
		if (strEQ(name2, "TF8CACHE"))
		    goto magicalize;
		break;
	    case '\027':	/* $^WARNING_BITS */
		if (strEQ(name2, "ARNING_BITS"))
		    goto magicalize;
#ifdef WIN32
		else if (strEQ(name2, "IN32_SLOPPY_STAT"))
		    goto magicalize;
#endif
		break;
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
	    {
		/* Ensures that we have an all-digit variable, ${"1foo"} fails
		   this test  */
                UV uv;
                if (!grok_atoUV(name, &uv, NULL) || uv > I32_MAX)
                    return addmg;
                /* XXX why are we using a SSize_t? */
                paren = (SSize_t)(I32)uv;
                goto storeparen;
	    }
	    }
	}
    } else {
	/* Names of length 1.  (Or 0. But name is NUL terminated, so that will
	   be case '\0' in this switch statement (ie a default case)  */
	switch (*name) {
	case '&':		/* $& */
            paren = RX_BUFF_IDX_FULLMATCH;
            goto sawampersand;
	case '`':		/* $` */
            paren = RX_BUFF_IDX_PREMATCH;
            goto sawampersand;
	case '\'':		/* $' */
            paren = RX_BUFF_IDX_POSTMATCH;
        sawampersand:
#ifdef PERL_SAWAMPERSAND
	    if (!(
		sv_type == SVt_PVAV ||
		sv_type == SVt_PVHV ||
		sv_type == SVt_PVCV ||
		sv_type == SVt_PVFM ||
		sv_type == SVt_PVIO
		)) { PL_sawampersand |=
                        (*name == '`')
                            ? SAWAMPERSAND_LEFT
                            : (*name == '&')
                                ? SAWAMPERSAND_MIDDLE
                                : SAWAMPERSAND_RIGHT;
                }
#endif
            goto storeparen;
        case '1':               /* $1 */
        case '2':               /* $2 */
        case '3':               /* $3 */
        case '4':               /* $4 */
        case '5':               /* $5 */
        case '6':               /* $6 */
        case '7':               /* $7 */
        case '8':               /* $8 */
        case '9':               /* $9 */
            paren = *name - '0';

        storeparen:
            /* Flag the capture variables with a NULL mg_ptr
               Use mg_len for the array index to lookup.  */
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, NULL, paren);
            break;

	case ':':		/* $: */
	    sv_setpv(GvSVn(gv),PL_chopset);
	    goto magicalize;

	case '?':		/* $? */
#ifdef COMPLEX_STATUS
	    SvUPGRADE(GvSVn(gv), SVt_PVLV);
#endif
	    goto magicalize;

	case '!':		/* $! */
	    GvMULTI_on(gv);
	    /* If %! has been used, automatically load Errno.pm. */

	    sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);

            /* magicalization must be done before require_tie_mod is called */
	    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
	    {
		require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
                addmg = FALSE;
	    }

	    break;
	case '-':		/* $- */
	case '+':		/* $+ */
	GvMULTI_on(gv); /* no used once warnings here */
        {
            AV* const av = GvAVn(gv);
	    SV* const avc = (*name == '+') ? MUTABLE_SV(av) : NULL;

	    sv_magic(MUTABLE_SV(av), avc, PERL_MAGIC_regdata, NULL, 0);
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
            if (avc)
                SvREADONLY_on(GvSVn(gv));
            SvREADONLY_on(av);

            if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
	    {
                require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);
                addmg = FALSE;
	    }

            break;
	}
	case '*':		/* $* */
	case '#':		/* $# */
	    if (sv_type == SVt_PV)
		/* diag_listed_as: $* is no longer supported */
		Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
				 "$%c is no longer supported", *name);
	    break;
	case '\010':	/* $^H */
	    {
		HV *const hv = GvHVn(gv);
		hv_magic(hv, NULL, PERL_MAGIC_hints);
	    }
	    goto magicalize;
	case '[':		/* $[ */
	    if ((sv_type == SVt_PV || sv_type == SVt_PVGV)
	     && FEATURE_ARYBASE_IS_ENABLED) {
		require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
                addmg = FALSE;
	    }
	    else goto magicalize;
            break;
	case '\023':	/* $^S */
	ro_magicalize:
	    SvREADONLY_on(GvSVn(gv));
	    /* FALLTHROUGH */
	case '0':		/* $0 */
	case '^':		/* $^ */
	case '~':		/* $~ */
	case '=':		/* $= */
	case '%':		/* $% */
	case '.':		/* $. */
	case '(':		/* $( */
	case ')':		/* $) */
	case '<':		/* $< */
	case '>':		/* $> */
	case '\\':		/* $\ */
	case '/':		/* $/ */
	case '|':		/* $| */
	case '$':		/* $$ */
	case '\001':	/* $^A */
	case '\003':	/* $^C */
	case '\004':	/* $^D */
	case '\005':	/* $^E */
	case '\006':	/* $^F */
	case '\011':	/* $^I, NOT \t in EBCDIC */
	case '\016':	/* $^N */
	case '\017':	/* $^O */
	case '\020':	/* $^P */
	case '\024':	/* $^T */
	case '\027':	/* $^W */
	magicalize:
	    sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
	    break;

	case '\014':	/* $^L */
	    sv_setpvs(GvSVn(gv),"\f");
	    break;
	case ';':		/* $; */
	    sv_setpvs(GvSVn(gv),"\034");
	    break;
	case ']':		/* $] */
	{
	    SV * const sv = GvSV(gv);
	    if (!sv_derived_from(PL_patchlevel, "version"))
		upg_version(PL_patchlevel, TRUE);
	    GvSV(gv) = vnumify(PL_patchlevel);
	    SvREADONLY_on(GvSV(gv));
	    SvREFCNT_dec(sv);
	}
	break;
	case '\026':	/* $^V */
	{
	    SV * const sv = GvSV(gv);
	    GvSV(gv) = new_version(PL_patchlevel);
	    SvREADONLY_on(GvSV(gv));
	    SvREFCNT_dec(sv);
	}
	break;
	case 'a':
	case 'b':
	    if (sv_type == SVt_PV)
		GvMULTI_on(gv);
	}
    }

    return addmg;
}

/* If we do ever start using this later on in the file, we need to make
   sure we donât accidentally use the wrong definition.  */
#undef SvREADONLY_on

/* This function is called when the stash already holds the GV of the magic
 * variable we're looking for, but we need to check that it has the correct
 * kind of magic.  For example, if someone first uses $! and then %!, the
 * latter would end up here, and we add the Errno tie to the HASH slot of
 * the *! glob.
 */
PERL_STATIC_INLINE void
S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type)
{
    PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV;

    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
        if (*name == '!')
            require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
        else if (*name == '-' || *name == '+')
            require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);
    } else if (sv_type == SVt_PV) {
        if (*name == '*' || *name == '#') {
            /* diag_listed_as: $* is no longer supported */
            Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,
                                             WARN_SYNTAX),
                             "$%c is no longer supported", *name);
        }
    }
    if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
      switch (*name) {
      case '[':
          require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
          break;
#ifdef PERL_SAWAMPERSAND
      case '`':
          PL_sawampersand |= SAWAMPERSAND_LEFT;
          (void)GvSVn(gv);
          break;
      case '&':
          PL_sawampersand |= SAWAMPERSAND_MIDDLE;
          (void)GvSVn(gv);
          break;
      case '\'':
          PL_sawampersand |= SAWAMPERSAND_RIGHT;
          (void)GvSVn(gv);
          break;
#endif
      }
    }
}

GV *
Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags,
		       const svtype sv_type)
{
    const char *name = nambeg;
    GV *gv = NULL;
    GV**gvp;
    STRLEN len;
    HV *stash = NULL;
    const I32 no_init = flags & (GV_NOADD_NOINIT | GV_NOINIT);
    const I32 no_expand = flags & GV_NOEXPAND;
    const I32 add = flags & ~GV_NOADD_MASK;
    const U32 is_utf8 = flags & SVf_UTF8;
    bool addmg = cBOOL(flags & GV_ADDMG);
    const char *const name_end = nambeg + full_len;
    U32 faking_it;

    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;

     /* If we have GV_NOTQUAL, the caller promised that
      * there is no stash, so we can skip the check.
      * Similarly if full_len is 0, since then we're
      * dealing with something like *{""} or ""->foo()
      */
    if ((flags & GV_NOTQUAL) || !full_len) {
        len = full_len;
    }
    else if (parse_gv_stash_name(&stash, &gv, &name, &len, nambeg, full_len, is_utf8, add)) {
        if (name == name_end) return gv;
    }
    else {
        return NULL;
    }

    if (!stash && !find_default_stash(&stash, name, len, is_utf8, add, sv_type)) {
        return NULL;
    }
    
    /* By this point we should have a stash and a name */
    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -(I32)len : (I32)len,add);
    if (!gvp || *gvp == (const GV *)&PL_sv_undef) {
	if (addmg) gv = (GV *)newSV(0);
	else return NULL;
    }
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

    if (SvTYPE(gv) == SVt_PVGV) {
        /* The GV already exists, so return it, but check if we need to do
         * anything else with it before that.
         */
	if (add) {
            /* This is the heuristic that handles if a variable triggers the
             * 'used only once' warning.  If there's already a GV in the stash
             * with this name, then we assume that the variable has been used
             * before and turn its MULTI flag on.
             * It's a heuristic because it can easily be "tricked", like with
             * BEGIN { $a = 1; $::{foo} = *a }; () = $foo
             * not warning about $main::foo being used just once
             */
	    GvMULTI_on(gv);
	    gv_init_svtype(gv, sv_type);
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn't
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
	    if (len == 1 && stash == PL_defstash) {
                maybe_multimagic_gv(gv, name, sv_type);
	    }
	    else if (len == 3 && sv_type == SVt_PVAV
	          && strnEQ(name, "ISA", 3)
	          && (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
		gv_magicalize_isa(gv);
	}
	return gv;
    } else if (no_init) {
	assert(!addmg);
	return gv;
    }
    /* If GV_NOEXPAND is true and what we got off the stash is a ref,
     * don't expand it to a glob. This is an optimization so that things
     * copying constants over, like Exporter, don't have to be rewritten
     * to take into account that you can store more than just globs in
     * stashes.
     */
    else if (no_expand && SvROK(gv)) {
	assert(!addmg);
	return gv;
    }

    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */

    faking_it = SvOK(gv);

    if (add & GV_ADDWARN)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
		"Had to create %"UTF8f" unexpectedly",
		 UTF8fARG(is_utf8, name_end-nambeg, nambeg));
    gv_init_pvn(gv, stash, name, len, (add & GV_ADDMULTI)|is_utf8);

    if ( isIDFIRST_lazy_if(name, is_utf8) && !ckWARN(WARN_ONCE) )
        GvMULTI_on(gv) ;

    /* First, store the gv in the symtab if we're adding magic,
     * but only for non-empty GVs
     */
#define GvEMPTY(gv)      !(GvAV(gv) || GvHV(gv) || GvIO(gv) \
                        || GvCV(gv) || (GvSV(gv) && SvOK(GvSV(gv))))
    
    if ( addmg && !GvEMPTY(gv) ) {
        (void)hv_store(stash,name,len,(SV *)gv,0);
    }

    /* set up magic where warranted */
    if ( gv_magicalize(gv, stash, name, len, addmg, sv_type) ) {
        /* See 23496c6 */
        if (GvEMPTY(gv)) {
            if ( GvSV(gv) && SvMAGICAL(GvSV(gv)) ) {
                /* The GV was and still is "empty", except that now
                 * it has the magic flags turned on, so we want it
                 * stored in the symtab.
                 */
                (void)hv_store(stash,name,len,(SV *)gv,0);
            }
            else {
                /* Most likely the temporary GV created above */
                SvREFCNT_dec_NN(gv);
                gv = NULL;
            }
        }
    }
    
    if (gv) gv_init_svtype(gv, faking_it ? SVt_PVCV : sv_type);
    return gv;
}

void
Perl_gv_fullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain)
{
    const char *name;
    const HV * const hv = GvSTASH(gv);

    PERL_ARGS_ASSERT_GV_FULLNAME4;

    sv_setpv(sv, prefix ? prefix : "");

    if (hv && (name = HvNAME(hv))) {
      const STRLEN len = HvNAMELEN(hv);
      if (keepmain || strnNE(name, "main", len)) {
	sv_catpvn_flags(sv,name,len,HvNAMEUTF8(hv)?SV_CATUTF8:SV_CATBYTES);
	sv_catpvs(sv,"::");
      }
    }
    else sv_catpvs(sv,"__ANON__::");
    sv_catsv(sv,sv_2mortal(newSVhek(GvNAME_HEK(gv))));
}

void
Perl_gv_efullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain)
{
    const GV * const egv = GvEGVx(gv);

    PERL_ARGS_ASSERT_GV_EFULLNAME4;

    gv_fullname4(sv, egv ? egv : gv, prefix, keepmain);
}


/* recursively scan a stash and any nested stashes looking for entries
 * that need the "only used once" warning raised
 */

void
Perl_gv_check(pTHX_ HV *stash)
{
    I32 i;

    PERL_ARGS_ASSERT_GV_CHECK;

    if (!HvARRAY(stash))
	return;

    assert(SvOOK(stash));

    for (i = 0; i <= (I32) HvMAX(stash); i++) {
        const HE *entry;
        /* mark stash is being scanned, to avoid recursing */
        HvAUX(stash)->xhv_aux_flags |= HvAUXf_SCAN_STASH;
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
            GV *gv;
            HV *hv;
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':' &&
		(gv = MUTABLE_GV(HeVAL(entry))) && isGV(gv) && (hv = GvHV(gv)))
	    {
		if (hv != PL_defstash && hv != stash
                    && !(SvOOK(hv)
                        && (HvAUX(hv)->xhv_aux_flags & HvAUXf_SCAN_STASH))
                )
		     gv_check(hv);              /* nested package */
	    }
            else if ( *HeKEY(entry) != '_'
                        && isIDFIRST_lazy_if(HeKEY(entry), HeUTF8(entry)) ) {
                const char *file;
		gv = MUTABLE_GV(HeVAL(entry));
		if (SvTYPE(gv) != SVt_PVGV || GvMULTI(gv))
		    continue;
		file = GvFILE(gv);
		CopLINE_set(PL_curcop, GvLINE(gv));
#ifdef USE_ITHREADS
		CopFILE(PL_curcop) = (char *)file;	/* set for warning */
#else
		CopFILEGV(PL_curcop)
		    = gv_fetchfile_flags(file, HEK_LEN(GvFILE_HEK(gv)), 0);
#endif
		Perl_warner(aTHX_ packWARN(WARN_ONCE),
			"Name \"%"HEKf"::%"HEKf
			"\" used only once: possible typo",
                            HEKfARG(HvNAME_HEK(stash)),
                            HEKfARG(GvNAME_HEK(gv)));
	    }
	}
        HvAUX(stash)->xhv_aux_flags &= ~HvAUXf_SCAN_STASH;
    }
}

GV *
Perl_newGVgen_flags(pTHX_ const char *pack, U32 flags)
{
    PERL_ARGS_ASSERT_NEWGVGEN_FLAGS;
    assert(!(flags & ~SVf_UTF8));

    return gv_fetchpv(Perl_form(aTHX_ "%"UTF8f"::_GEN_%ld",
                                UTF8fARG(flags, strlen(pack), pack),
                                (long)PL_gensym++),
                      GV_ADD, SVt_PVGV);
}

/* hopefully this is only called on local symbol table entries */

GP*
Perl_gp_ref(pTHX_ GP *gp)
{
    if (!gp)
	return NULL;
    gp->gp_refcnt++;
    if (gp->gp_cv) {
	if (gp->gp_cvgen) {
	    /* If the GP they asked for a reference to contains
               a method cache entry, clear it first, so that we
               don't infect them with our cached entry */
	    SvREFCNT_dec_NN(gp->gp_cv);
	    gp->gp_cv = NULL;
	    gp->gp_cvgen = 0;
	}
    }
    return gp;
}

void
Perl_gp_free(pTHX_ GV *gv)
{
    GP* gp;
    int attempts = 100;

    if (!gv || !isGV_with_GP(gv) || !(gp = GvGP(gv)))
	return;
    if (gp->gp_refcnt == 0) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			 "Attempt to free unreferenced glob pointers"
			 pTHX__FORMAT pTHX__VALUE);
        return;
    }
    if (gp->gp_refcnt > 1) {
       borrowed:
	if (gp->gp_egv == gv)
	    gp->gp_egv = 0;
	gp->gp_refcnt--;
	GvGP_set(gv, NULL);
        return;
    }

    while (1) {
      /* Copy and null out all the glob slots, so destructors do not see
         freed SVs. */
      HEK * const file_hek = gp->gp_file_hek;
      SV  * const sv       = gp->gp_sv;
      AV  * const av       = gp->gp_av;
      HV  * const hv       = gp->gp_hv;
      IO  * const io       = gp->gp_io;
      CV  * const cv       = gp->gp_cv;
      CV  * const form     = gp->gp_form;

      gp->gp_file_hek = NULL;
      gp->gp_sv       = NULL;
      gp->gp_av       = NULL;
      gp->gp_hv       = NULL;
      gp->gp_io       = NULL;
      gp->gp_cv       = NULL;
      gp->gp_form     = NULL;

      if (file_hek)
	unshare_hek(file_hek);

      SvREFCNT_dec(sv);
      SvREFCNT_dec(av);
      /* FIXME - another reference loop GV -> symtab -> GV ?
         Somehow gp->gp_hv can end up pointing at freed garbage.  */
      if (hv && SvTYPE(hv) == SVt_PVHV) {
        const HEK *hvname_hek = HvNAME_HEK(hv);
        if (PL_stashcache && hvname_hek) {
           DEBUG_o(Perl_deb(aTHX_
                          "gp_free clearing PL_stashcache for '%"HEKf"'\n",
                           HEKfARG(hvname_hek)));
           (void)hv_deletehek(PL_stashcache, hvname_hek, G_DISCARD);
        }
	SvREFCNT_dec(hv);
      }
      if (io && SvREFCNT(io) == 1 && IoIFP(io)
	     && (IoTYPE(io) == IoTYPE_WRONLY ||
		 IoTYPE(io) == IoTYPE_RDWR   ||
		 IoTYPE(io) == IoTYPE_APPEND)
	     && ckWARN_d(WARN_IO)
	     && IoIFP(io) != PerlIO_stdin()
	     && IoIFP(io) != PerlIO_stdout()
	     && IoIFP(io) != PerlIO_stderr()
	     && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	io_close(io, gv, FALSE, TRUE);
      SvREFCNT_dec(io);
      SvREFCNT_dec(cv);
      SvREFCNT_dec(form);

      /* Possibly reallocated by a destructor */
      gp = GvGP(gv);

      if (!gp->gp_file_hek
       && !gp->gp_sv
       && !gp->gp_av
       && !gp->gp_hv
       && !gp->gp_io
       && !gp->gp_cv
       && !gp->gp_form) break;

      if (--attempts == 0) {
	Perl_die(aTHX_
	  "panic: gp_free failed to free glob pointer - "
	  "something is repeatedly re-creating entries"
	);
      }
    }

    /* Possibly incremented by a destructor doing glob assignment */
    if (gp->gp_refcnt > 1) goto borrowed;
    Safefree(gp);
    GvGP_set(gv, NULL);
}

int
Perl_magic_freeovrld(pTHX_ SV *sv, MAGIC *mg)
{
    AMT * const amtp = (AMT*)mg->mg_ptr;
    PERL_UNUSED_ARG(sv);

    PERL_ARGS_ASSERT_MAGIC_FREEOVRLD;

    if (amtp && AMT_AMAGIC(amtp)) {
	int i;
	for (i = 1; i < NofAMmeth; i++) {
	    CV * const cv = amtp->table[i];
	    if (cv) {
		SvREFCNT_dec_NN(MUTABLE_SV(cv));
		amtp->table[i] = NULL;
	    }
	}
    }
 return 0;
}

/* Updates and caches the CV's */
/* Returns:
 * 1 on success and there is some overload
 * 0 if there is no overload
 * -1 if some error occurred and it couldn't croak
 */

int
Perl_Gv_AMupdate(pTHX_ HV *stash, bool destructing)
{
  MAGIC* const mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
  AMT amt;
  const struct mro_meta* stash_meta = HvMROMETA(stash);
  U32 newgen;

  PERL_ARGS_ASSERT_GV_AMUPDATE;

  newgen = PL_sub_generation + stash_meta->pkg_gen + stash_meta->cache_gen;
  if (mg) {
      const AMT * const amtp = (AMT*)mg->mg_ptr;
      if (amtp->was_ok_sub == newgen) {
	  return AMT_AMAGIC(amtp) ? 1 : 0;
      }
      sv_unmagic(MUTABLE_SV(stash), PERL_MAGIC_overload_table);
  }

  DEBUG_o( Perl_deb(aTHX_ "Recalcing overload magic in package %s\n",HvNAME_get(stash)) );

  Zero(&amt,1,AMT);
  amt.was_ok_sub = newgen;
  amt.fallback = AMGfallNO;
  amt.flags = 0;

  {
    int filled = 0;
    int i;
    bool deref_seen = 0;


    /* Work with "fallback" key, which we assume to be first in PL_AMG_names */

    /* Try to find via inheritance. */
    GV *gv = gv_fetchmeth_pvn(stash, PL_AMG_names[0], 2, -1, 0);
    SV * const sv = gv ? GvSV(gv) : NULL;
    CV* cv;

    if (!gv)
    {
      if (!gv_fetchmeth_pvn(stash, "((", 2, -1, 0))
	goto no_table;
    }
#ifdef PERL_DONT_CREATE_GVSV
    else if (!sv) {
	NOOP;   /* Equivalent to !SvTRUE and !SvOK  */
    }
#endif
    else if (SvTRUE(sv))
        /* don't need to set overloading here because fallback => 1
         * is the default setting for classes without overloading */
	amt.fallback=AMGfallYES;
    else if (SvOK(sv)) {
	amt.fallback=AMGfallNEVER;
        filled = 1;
    }
    else {
        filled = 1;
    }

    assert(SvOOK(stash));
    /* initially assume the worst */
    HvAUX(stash)->xhv_aux_flags &= ~HvAUXf_NO_DEREF;

    for (i = 1; i < NofAMmeth; i++) {
	const char * const cooky = PL_AMG_names[i];
	/* Human-readable form, for debugging: */
	const char * const cp = AMG_id2name(i);
	const STRLEN l = PL_AMG_namelens[i];

	DEBUG_o( Perl_deb(aTHX_ "Checking overloading of \"%s\" in package \"%.256s\"\n",
		     cp, HvNAME_get(stash)) );
	/* don't fill the cache while looking up!
	   Creation of inheritance stubs in intermediate packages may
	   conflict with the logic of runtime method substitution.
	   Indeed, for inheritance A -> B -> C, if C overloads "+0",
	   then we could have created stubs for "(+0" in A and C too.
	   But if B overloads "bool", we may want to use it for
	   numifying instead of C's "+0". */
	gv = Perl_gv_fetchmeth_pvn(aTHX_ stash, cooky, l, -1, 0);
        cv = 0;
        if (gv && (cv = GvCV(gv)) && CvHASGV(cv)) {
            const HEK * const gvhek =
                CvNAMED(cv) ? CvNAME_HEK(cv) : GvNAME_HEK(CvGV(cv));
            const HEK * const stashek =
                HvNAME_HEK(CvNAMED(cv) ? CvSTASH(cv) : GvSTASH(CvGV(cv)));
            if (HEK_LEN(gvhek) == 3 && strEQ(HEK_KEY(gvhek), "nil")
             && stashek && HEK_LEN(stashek) == 8
             && strEQ(HEK_KEY(stashek), "overload")) {
		/* This is a hack to support autoloading..., while
		   knowing *which* methods were declared as overloaded. */
		/* GvSV contains the name of the method. */
		GV *ngv = NULL;
		SV *gvsv = GvSV(gv);

		DEBUG_o( Perl_deb(aTHX_ "Resolving method \"%"SVf256\
			"\" for overloaded \"%s\" in package \"%.256s\"\n",
			     (void*)GvSV(gv), cp, HvNAME(stash)) );
		if (!gvsv || !SvPOK(gvsv)
		    || !(ngv = gv_fetchmethod_sv_flags(stash, gvsv, 0)))
		{
		    /* Can be an import stub (created by "can"). */
		    if (destructing) {
			return -1;
		    }
		    else {
			const SV * const name = (gvsv && SvPOK(gvsv))
                                                    ? gvsv
                                                    : newSVpvs_flags("???", SVs_TEMP);
			/* diag_listed_as: Can't resolve method "%s" overloading "%s" in package "%s" */
			Perl_croak(aTHX_ "%s method \"%"SVf256
				    "\" overloading \"%s\" "\
				    "in package \"%"HEKf256"\"",
				   (GvCVGEN(gv) ? "Stub found while resolving"
				    : "Can't resolve"),
				   SVfARG(name), cp,
                                   HEKfARG(
					HvNAME_HEK(stash)
				   ));
		    }
		}
		cv = GvCV(gv = ngv);
	    }
	    DEBUG_o( Perl_deb(aTHX_ "Overloading \"%s\" in package \"%.256s\" via \"%.256s::%.256s\"\n",
			 cp, HvNAME_get(stash), HvNAME_get(GvSTASH(CvGV(cv))),
			 GvNAME(CvGV(cv))) );
	    filled = 1;
	} else if (gv) {		/* Autoloaded... */
	    cv = MUTABLE_CV(gv);
	    filled = 1;
	}
	amt.table[i]=MUTABLE_CV(SvREFCNT_inc_simple(cv));

        if (gv) {
            switch (i) {
            case to_sv_amg:
            case to_av_amg:
            case to_hv_amg:
            case to_gv_amg:
            case to_cv_amg:
            case nomethod_amg:
                deref_seen = 1;
                break;
            }
        }
    }
    if (!deref_seen)
        /* none of @@{} etc overloaded; we can do $obj->[N] quicker.
         * NB - aux var invalid here, HvARRAY() could have been
         * reallocated since it was assigned to */
        HvAUX(stash)->xhv_aux_flags |= HvAUXf_NO_DEREF;

    if (filled) {
      AMT_AMAGIC_on(&amt);
      sv_magic(MUTABLE_SV(stash), 0, PERL_MAGIC_overload_table,
						(char*)&amt, sizeof(AMT));
      return TRUE;
    }
  }
  /* Here we have no table: */
 no_table:
  AMT_AMAGIC_off(&amt);
  sv_magic(MUTABLE_SV(stash), 0, PERL_MAGIC_overload_table,
						(char*)&amt, sizeof(AMTS));
  return 0;
}


CV*
Perl_gv_handler(pTHX_ HV *stash, I32 id)
{
    MAGIC *mg;
    AMT *amtp;
    U32 newgen;
    struct mro_meta* stash_meta;

    if (!stash || !HvNAME_get(stash))
        return NULL;

    stash_meta = HvMROMETA(stash);
    newgen = PL_sub_generation + stash_meta->pkg_gen + stash_meta->cache_gen;

    mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
    if (!mg) {
      do_update:
	if (Gv_AMupdate(stash, 0) == -1)
	    return NULL;
	mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
    }
    assert(mg);
    amtp = (AMT*)mg->mg_ptr;
    if ( amtp->was_ok_sub != newgen )
	goto do_update;
    if (AMT_AMAGIC(amtp)) {
	CV * const ret = amtp->table[id];
	if (ret && isGV(ret)) {		/* Autoloading stab */
	    /* Passing it through may have resulted in a warning
	       "Inherited AUTOLOAD for a non-method deprecated", since
	       our caller is going through a function call, not a method call.
	       So return the CV for AUTOLOAD, setting $AUTOLOAD. */
	    GV * const gv = gv_fetchmethod(stash, PL_AMG_names[id]);

	    if (gv && GvCV(gv))
		return GvCV(gv);
	}
	return ret;
    }

    return NULL;
}


/* Implement tryAMAGICun_MG macro.
   Do get magic, then see if the stack arg is overloaded and if so call it.
   Flags:
	AMGf_set     return the arg using SETs rather than assigning to
		     the targ
	AMGf_numeric apply sv_2num to the stack arg.
*/

bool
Perl_try_amagic_un(pTHX_ int method, int flags) {
    dSP;
    SV* tmpsv;
    SV* const arg = TOPs;

    SvGETMAGIC(arg);

    if (SvAMAGIC(arg) && (tmpsv = amagic_call(arg, &PL_sv_undef, method,
					      AMGf_noright | AMGf_unary
					    | (flags & AMGf_numarg))))
    {
	if (flags & AMGf_set) {
	    SETs(tmpsv);
	}
	else {
	    dTARGET;
	    if (SvPADMY(TARG)) {
		sv_setsv(TARG, tmpsv);
		SETTARG;
	    }
	    else
		SETs(tmpsv);
	}
	PUTBACK;
	return TRUE;
    }

    if ((flags & AMGf_numeric) && SvROK(arg))
	*sp = sv_2num(arg);
    return FALSE;
}


/* Implement tryAMAGICbin_MG macro.
   Do get magic, then see if the two stack args are overloaded and if so
   call it.
   Flags:
	AMGf_set     return the arg using SETs rather than assigning to
		     the targ
	AMGf_assign  op may be called as mutator (eg +=)
	AMGf_numeric apply sv_2num to the stack arg.
*/

bool
Perl_try_amagic_bin(pTHX_ int method, int flags) {
    dSP;
    SV* const left = TOPm1s;
    SV* const right = TOPs;

    SvGETMAGIC(left);
    if (left != right)
	SvGETMAGIC(right);

    if (SvAMAGIC(left) || SvAMAGIC(right)) {
	SV * const tmpsv = amagic_call(left, right, method,
		    ((flags & AMGf_assign) && opASSIGN ? AMGf_assign: 0)
		  | (flags & AMGf_numarg));
	if (tmpsv) {
	    if (flags & AMGf_set) {
		(void)POPs;
		SETs(tmpsv);
	    }
	    else {
		dATARGET;
		(void)POPs;
		if (opASSIGN || SvPADMY(TARG)) {
		    sv_setsv(TARG, tmpsv);
		    SETTARG;
		}
		else
		    SETs(tmpsv);
	    }
	    PUTBACK;
	    return TRUE;
	}
    }
    if(left==right && SvGMAGICAL(left)) {
	SV * const left = sv_newmortal();
	*(sp-1) = left;
	/* Print the uninitialized warning now, so it includes the vari-
	   able name. */
	if (!SvOK(right)) {
	    if (ckWARN(WARN_UNINITIALIZED)) report_uninit(right);
	    sv_setsv_flags(left, &PL_sv_no, 0);
	}
	else sv_setsv_flags(left, right, 0);
	SvGETMAGIC(right);
    }
    if (flags & AMGf_numeric) {
	if (SvROK(TOPm1s))
	    *(sp-1) = sv_2num(TOPm1s);
	if (SvROK(right))
	    *sp     = sv_2num(right);
    }
    return FALSE;
}

SV *
Perl_amagic_deref_call(pTHX_ SV *ref, int method) {
    SV *tmpsv = NULL;
    HV *stash;

    PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL;

    if (!SvAMAGIC(ref))
        return ref;
    /* return quickly if none of the deref ops are overloaded */
    stash = SvSTASH(SvRV(ref));
    assert(SvOOK(stash));
    if (HvAUX(stash)->xhv_aux_flags & HvAUXf_NO_DEREF)
        return ref;

    while ((tmpsv = amagic_call(ref, &PL_sv_undef, method,
				AMGf_noright | AMGf_unary))) { 
	if (!SvROK(tmpsv))
	    Perl_croak(aTHX_ "Overloaded dereference did not return a reference");
	if (tmpsv == ref || SvRV(tmpsv) == SvRV(ref)) {
	    /* Bail out if it returns us the same reference.  */
	    return tmpsv;
	}
	ref = tmpsv;
        if (!SvAMAGIC(ref))
            break;
    }
    return tmpsv ? tmpsv : ref;
}

bool
Perl_amagic_is_enabled(pTHX_ int method)
{
      SV *lex_mask = cop_hints_fetch_pvs(PL_curcop, "overloading", 0);

      assert(PL_curcop->cop_hints & HINT_NO_AMAGIC);

      if ( !lex_mask || !SvOK(lex_mask) )
	  /* overloading lexically disabled */
	  return FALSE;
      else if ( lex_mask && SvPOK(lex_mask) ) {
	  /* we have an entry in the hints hash, check if method has been
	   * masked by overloading.pm */
	  STRLEN len;
	  const int offset = method / 8;
	  const int bit    = method % 8;
	  char *pv = SvPV(lex_mask, len);

	  /* Bit set, so this overloading operator is disabled */
	  if ( (STRLEN)offset < len && pv[offset] & ( 1 << bit ) )
	      return FALSE;
      }
      return TRUE;
}

SV*
Perl_amagic_call(pTHX_ SV *left, SV *right, int method, int flags)
{
  dVAR;
  MAGIC *mg;
  CV *cv=NULL;
  CV **cvp=NULL, **ocvp=NULL;
  AMT *amtp=NULL, *oamtp=NULL;
  int off = 0, off1, lr = 0, notfound = 0;
  int postpr = 0, force_cpy = 0;
  int assign = AMGf_assign & flags;
  const int assignshift = assign ? 1 : 0;
  int use_default_op = 0;
  int force_scalar = 0;
#ifdef DEBUGGING
  int fl=0;
#endif
  HV* stash=NULL;

  PERL_ARGS_ASSERT_AMAGIC_CALL;

  if ( PL_curcop->cop_hints & HINT_NO_AMAGIC ) {
      if (!amagic_is_enabled(method)) return NULL;
  }

  if (!(AMGf_noleft & flags) && SvAMAGIC(left)
      && (stash = SvSTASH(SvRV(left))) && Gv_AMG(stash)
      && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))
      && (ocvp = cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)
			? (oamtp = amtp = (AMT*)mg->mg_ptr)->table
			: NULL))
      && ((cv = cvp[off=method+assignshift])
	  || (assign && amtp->fallback > AMGfallNEVER && /* fallback to
						          * usual method */
		  (
#ifdef DEBUGGING
		   fl = 1,
#endif
		   cv = cvp[off=method])))) {
    lr = -1;			/* Call method for left argument */
  } else {
    if (cvp && amtp->fallback > AMGfallNEVER && flags & AMGf_unary) {
      int logic;

      /* look for substituted methods */
      /* In all the covered cases we should be called with assign==0. */
	 switch (method) {
	 case inc_amg:
	   force_cpy = 1;
	   if ((cv = cvp[off=add_ass_amg])
	       || ((cv = cvp[off = add_amg]) && (force_cpy = 0, postpr = 1))) {
	     right = &PL_sv_yes; lr = -1; assign = 1;
	   }
	   break;
	 case dec_amg:
	   force_cpy = 1;
	   if ((cv = cvp[off = subtr_ass_amg])
	       || ((cv = cvp[off = subtr_amg]) && (force_cpy = 0, postpr=1))) {
	     right = &PL_sv_yes; lr = -1; assign = 1;
	   }
	   break;
	 case bool__amg:
	   (void)((cv = cvp[off=numer_amg]) || (cv = cvp[off=string_amg]));
	   break;
	 case numer_amg:
	   (void)((cv = cvp[off=string_amg]) || (cv = cvp[off=bool__amg]));
	   break;
	 case string_amg:
	   (void)((cv = cvp[off=numer_amg]) || (cv = cvp[off=bool__amg]));
	   break;
         case not_amg:
           (void)((cv = cvp[off=bool__amg])
                  || (cv = cvp[off=numer_amg])
                  || (cv = cvp[off=string_amg]));
           if (cv)
               postpr = 1;
           break;
	 case copy_amg:
	   {
	     /*
		  * SV* ref causes confusion with the interpreter variable of
		  * the same name
		  */
	     SV* const tmpRef=SvRV(left);
	     if (!SvROK(tmpRef) && SvTYPE(tmpRef) <= SVt_PVMG) {
		/*
		 * Just to be extra cautious.  Maybe in some
		 * additional cases sv_setsv is safe, too.
		 */
		SV* const newref = newSVsv(tmpRef);
		SvOBJECT_on(newref);
		/* No need to do SvAMAGIC_on here, as SvAMAGIC macros
		   delegate to the stash. */
		SvSTASH_set(newref, MUTABLE_HV(SvREFCNT_inc(SvSTASH(tmpRef))));
		return newref;
	     }
	   }
	   break;
	 case abs_amg:
	   if ((cvp[off1=lt_amg] || cvp[off1=ncmp_amg])
	       && ((cv = cvp[off=neg_amg]) || (cv = cvp[off=subtr_amg]))) {
	     SV* const nullsv=sv_2mortal(newSViv(0));
	     if (off1==lt_amg) {
	       SV* const lessp = amagic_call(left,nullsv,
				       lt_amg,AMGf_noright);
	       logic = SvTRUE(lessp);
	     } else {
	       SV* const lessp = amagic_call(left,nullsv,
				       ncmp_amg,AMGf_noright);
	       logic = (SvNV(lessp) < 0);
	     }
	     if (logic) {
	       if (off==subtr_amg) {
		 right = left;
		 left = nullsv;
		 lr = 1;
	       }
	     } else {
	       return left;
	     }
	   }
	   break;
	 case neg_amg:
	   if ((cv = cvp[off=subtr_amg])) {
	     right = left;
	     left = sv_2mortal(newSViv(0));
	     lr = 1;
	   }
	   break;
	 case int_amg:
	 case iter_amg:			/* XXXX Eventually should do to_gv. */
	 case ftest_amg:		/* XXXX Eventually should do to_gv. */
	 case regexp_amg:
	     /* FAIL safe */
	     return NULL;	/* Delegate operation to standard mechanisms. */

	 case to_sv_amg:
	 case to_av_amg:
	 case to_hv_amg:
	 case to_gv_amg:
	 case to_cv_amg:
	     /* FAIL safe */
	     return left;	/* Delegate operation to standard mechanisms. */

	 default:
	   goto not_found;
	 }
	 if (!cv) goto not_found;
    } else if (!(AMGf_noright & flags) && SvAMAGIC(right)
	       && (stash = SvSTASH(SvRV(right))) && Gv_AMG(stash)
	       && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))
	       && (cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)
			  ? (amtp = (AMT*)mg->mg_ptr)->table
			  : NULL))
	       && (cv = cvp[off=method])) { /* Method for right
					     * argument found */
      lr=1;
    } else if (((cvp && amtp->fallback > AMGfallNEVER)
                || (ocvp && oamtp->fallback > AMGfallNEVER))
	       && !(flags & AMGf_unary)) {
				/* We look for substitution for
				 * comparison operations and
				 * concatenation */
      if (method==concat_amg || method==concat_ass_amg
	  || method==repeat_amg || method==repeat_ass_amg) {
	return NULL;		/* Delegate operation to string conversion */
      }
      off = -1;
      switch (method) {
	 case lt_amg:
	 case le_amg:
	 case gt_amg:
	 case ge_amg:
	 case eq_amg:
	 case ne_amg:
             off = ncmp_amg;
             break;
	 case slt_amg:
	 case sle_amg:
	 case sgt_amg:
	 case sge_amg:
	 case seq_amg:
	 case sne_amg:
             off = scmp_amg;
             break;
	 }
      if (off != -1) {
          if (ocvp && (oamtp->fallback > AMGfallNEVER)) {
              cv = ocvp[off];
              lr = -1;
          }
          if (!cv && (cvp && amtp->fallback > AMGfallNEVER)) {
              cv = cvp[off];
              lr = 1;
          }
      }
      if (cv)
          postpr = 1;
      else
          goto not_found;
    } else {
    not_found:			/* No method found, either report or croak */
      switch (method) {
	 case to_sv_amg:
	 case to_av_amg:
	 case to_hv_amg:
	 case to_gv_amg:
	 case to_cv_amg:
	     /* FAIL safe */
	     return left;	/* Delegate operation to standard mechanisms. */
      }
      if (ocvp && (cv=ocvp[nomethod_amg])) { /* Call report method */
	notfound = 1; lr = -1;
      } else if (cvp && (cv=cvp[nomethod_amg])) {
	notfound = 1; lr = 1;
      } else if ((use_default_op =
                  (!ocvp || oamtp->fallback >= AMGfallYES)
                  && (!cvp || amtp->fallback >= AMGfallYES))
                 && !DEBUG_o_TEST) {
	/* Skip generating the "no method found" message.  */
	return NULL;
      } else {
	SV *msg;
	if (off==-1) off=method;
	msg = sv_2mortal(Perl_newSVpvf(aTHX_
		      "Operation \"%s\": no method found,%sargument %s%"SVf"%s%"SVf,
 		      AMG_id2name(method + assignshift),
 		      (flags & AMGf_unary ? " " : "\n\tleft "),
 		      SvAMAGIC(left)?
 		        "in overloaded package ":
 		        "has no overloaded magic",
 		      SvAMAGIC(left)?
		        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(left)))))):
		        SVfARG(&PL_sv_no),
 		      SvAMAGIC(right)?
 		        ",\n\tright argument in overloaded package ":
 		        (flags & AMGf_unary
 			 ? ""
 			 : ",\n\tright argument has no overloaded magic"),
 		      SvAMAGIC(right)?
		        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(right)))))):
		        SVfARG(&PL_sv_no)));
        if (use_default_op) {
	  DEBUG_o( Perl_deb(aTHX_ "%"SVf, SVfARG(msg)) );
	} else {
	  Perl_croak(aTHX_ "%"SVf, SVfARG(msg));
	}
	return NULL;
      }
      force_cpy = force_cpy || assign;
    }
  }

  switch (method) {
    /* in these cases, we're calling '+' or '-' as a fallback for a ++ or --
     * operation. we need this to return a value, so that it can be assigned
     * later on, in the postpr block (case inc_amg/dec_amg), even if the
     * increment or decrement was itself called in void context */
    case inc_amg:
      if (off == add_amg)
        force_scalar = 1;
      break;
    case dec_amg:
      if (off == subtr_amg)
        force_scalar = 1;
      break;
    /* in these cases, we're calling an assignment variant of an operator
     * (+= rather than +, for instance). regardless of whether it's a
     * fallback or not, it always has to return a value, which will be
     * assigned to the proper variable later */
    case add_amg:
    case subtr_amg:
    case mult_amg:
    case div_amg:
    case modulo_amg:
    case pow_amg:
    case lshift_amg:
    case rshift_amg:
    case repeat_amg:
    case concat_amg:
    case band_amg:
    case bor_amg:
    case bxor_amg:
    case sband_amg:
    case sbor_amg:
    case sbxor_amg:
      if (assign)
        force_scalar = 1;
      break;
    /* the copy constructor always needs to return a value */
    case copy_amg:
      force_scalar = 1;
      break;
    /* because of the way these are implemented (they don't perform the
     * dereferencing themselves, they return a reference that perl then
     * dereferences later), they always have to be in scalar context */
    case to_sv_amg:
    case to_av_amg:
    case to_hv_amg:
    case to_gv_amg:
    case to_cv_amg:
      force_scalar = 1;
      break;
    /* these don't have an op of their own; they're triggered by their parent
     * op, so the context there isn't meaningful ('$a and foo()' in void
     * context still needs to pass scalar context on to $a's bool overload) */
    case bool__amg:
    case numer_amg:
    case string_amg:
      force_scalar = 1;
      break;
  }

#ifdef DEBUGGING
  if (!notfound) {
    DEBUG_o(Perl_deb(aTHX_
		     "Overloaded operator \"%s\"%s%s%s:\n\tmethod%s found%s in package %"SVf"%s\n",
		     AMG_id2name(off),
		     method+assignshift==off? "" :
		     " (initially \"",
		     method+assignshift==off? "" :
		     AMG_id2name(method+assignshift),
		     method+assignshift==off? "" : "\")",
		     flags & AMGf_unary? "" :
		     lr==1 ? " for right argument": " for left argument",
		     flags & AMGf_unary? " for argument" : "",
		     stash ? SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(stash)))) : SVfARG(newSVpvs_flags("null", SVs_TEMP)),
		     fl? ",\n\tassignment variant used": "") );
  }
#endif
    /* Since we use shallow copy during assignment, we need
     * to dublicate the contents, probably calling user-supplied
     * version of copy operator
     */
    /* We need to copy in following cases:
     * a) Assignment form was called.
     * 		assignshift==1,  assign==T, method + 1 == off
     * b) Increment or decrement, called directly.
     * 		assignshift==0,  assign==0, method + 0 == off
     * c) Increment or decrement, translated to assignment add/subtr.
     * 		assignshift==0,  assign==T,
     *		force_cpy == T
     * d) Increment or decrement, translated to nomethod.
     * 		assignshift==0,  assign==0,
     *		force_cpy == T
     * e) Assignment form translated to nomethod.
     * 		assignshift==1,  assign==T, method + 1 != off
     *		force_cpy == T
     */
    /*	off is method, method+assignshift, or a result of opcode substitution.
     *	In the latter case assignshift==0, so only notfound case is important.
     */
  if ( (lr == -1) && ( ( (method + assignshift == off)
	&& (assign || (method == inc_amg) || (method == dec_amg)))
      || force_cpy) )
  {
      /* newSVsv does not behave as advertised, so we copy missing
       * information by hand */
      SV *tmpRef = SvRV(left);
      SV *rv_copy;
      if (SvREFCNT(tmpRef) > 1 && (rv_copy = AMG_CALLunary(left,copy_amg))) {
	  SvRV_set(left, rv_copy);
	  SvSETMAGIC(left);
	  SvREFCNT_dec_NN(tmpRef);  
      }
  }

  {
    dSP;
    BINOP myop;
    SV* res;
    const bool oldcatch = CATCH_GET;
    I32 oldmark, nret;
    U8 gimme = force_scalar ? G_SCALAR : GIMME_V;

    CATCH_SET(TRUE);
    Zero(&myop, 1, BINOP);
    myop.op_last = (OP *) &myop;
    myop.op_next = NULL;
    myop.op_flags = OPf_STACKED;

    switch (gimme) {
        case G_VOID:
            myop.op_flags |= OPf_WANT_VOID;
            break;
        case G_ARRAY:
            if (flags & AMGf_want_list) {
                myop.op_flags |= OPf_WANT_LIST;
                break;
            }
            /* FALLTHROUGH */
        default:
            myop.op_flags |= OPf_WANT_SCALAR;
            break;
    }

    PUSHSTACKi(PERLSI_OVERLOAD);
    ENTER;
    SAVEOP();
    PL_op = (OP *) &myop;
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	PL_op->op_private |= OPpENTERSUB_DB;
    Perl_pp_pushmark(aTHX);

    EXTEND(SP, notfound + 5);
    PUSHs(lr>0? right: left);
    PUSHs(lr>0? left: right);
    PUSHs( lr > 0 ? &PL_sv_yes : ( assign ? &PL_sv_undef : &PL_sv_no ));
    if (notfound) {
      PUSHs(newSVpvn_flags(AMG_id2name(method + assignshift),
			   AMG_id2namelen(method + assignshift), SVs_TEMP));
    }
    else if (flags & AMGf_numarg)
      PUSHs(&PL_sv_undef);
    if (flags & AMGf_numarg)
      PUSHs(&PL_sv_yes);
    PUSHs(MUTABLE_SV(cv));
    PUTBACK;
    oldmark = TOPMARK;

    if ((PL_op = PL_ppaddr[OP_ENTERSUB](aTHX)))
      CALLRUNOPS(aTHX);
    LEAVE;
    SPAGAIN;
    nret = SP - (PL_stack_base + oldmark);

    switch (gimme) {
        case G_VOID:
            /* returning NULL has another meaning, and we check the context
             * at the call site too, so this can be differentiated from the
             * scalar case */
            res = &PL_sv_undef;
            SP = PL_stack_base + oldmark;
            break;
        case G_ARRAY: {
            if (flags & AMGf_want_list) {
                res = sv_2mortal((SV *)newAV());
                av_extend((AV *)res, nret);
                while (nret--)
                    av_store((AV *)res, nret, POPs);
                break;
            }
            /* FALLTHROUGH */
        }
        default:
            res = POPs;
            break;
    }

    PUTBACK;
    POPSTACK;
    CATCH_SET(oldcatch);

    if (postpr) {
      int ans;
      switch (method) {
      case le_amg:
      case sle_amg:
	ans=SvIV(res)<=0; break;
      case lt_amg:
      case slt_amg:
	ans=SvIV(res)<0; break;
      case ge_amg:
      case sge_amg:
	ans=SvIV(res)>=0; break;
      case gt_amg:
      case sgt_amg:
	ans=SvIV(res)>0; break;
      case eq_amg:
      case seq_amg:
	ans=SvIV(res)==0; break;
      case ne_amg:
      case sne_amg:
	ans=SvIV(res)!=0; break;
      case inc_amg:
      case dec_amg:
	SvSetSV(left,res); return left;
      case not_amg:
	ans=!SvTRUE(res); break;
      default:
        ans=0; break;
      }
      return boolSV(ans);
    } else if (method==copy_amg) {
      if (!SvROK(res)) {
	Perl_croak(aTHX_ "Copy method did not return a reference");
      }
      return SvREFCNT_inc(SvRV(res));
    } else {
      return res;
    }
  }
}

void
Perl_gv_name_set(pTHX_ GV *gv, const char *name, U32 len, U32 flags)
{
    dVAR;
    U32 hash;

    PERL_ARGS_ASSERT_GV_NAME_SET;

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: gv name too long (%"UVuf")", (UV) len);

    if (!(flags & GV_ADD) && GvNAME_HEK(gv)) {
	unshare_hek(GvNAME_HEK(gv));
    }

    PERL_HASH(hash, name, len);
    GvNAME_HEK(gv) = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
}

/*
=for apidoc gv_try_downgrade

If the typeglob C<gv> can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that C<gv>
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.

If C<gv> is a completely empty typeglob, it is deleted from the stash.

If C<gv> is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.

=cut
*/

void
Perl_gv_try_downgrade(pTHX_ GV *gv)
{
    HV *stash;
    CV *cv;
    HEK *namehek;
    SV **gvp;
    PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE;

    /* XXX Why and where does this leave dangling pointers during global
       destruction? */
    if (PL_phase == PERL_PHASE_DESTRUCT) return;

    if (!(SvREFCNT(gv) == 1 && SvTYPE(gv) == SVt_PVGV && !SvFAKE(gv) &&
	    !SvOBJECT(gv) && !SvREADONLY(gv) &&
	    isGV_with_GP(gv) && GvGP(gv) &&
	    !GvINTRO(gv) && GvREFCNT(gv) == 1 &&
	    !GvSV(gv) && !GvAV(gv) && !GvHV(gv) && !GvIOp(gv) && !GvFORM(gv) &&
	    GvEGVx(gv) == gv && (stash = GvSTASH(gv))))
	return;
    if (gv == PL_statgv || gv == PL_last_in_gv || gv == PL_stderrgv)
	return;
    if (SvMAGICAL(gv)) {
        MAGIC *mg;
	/* only backref magic is allowed */
	if (SvGMAGICAL(gv) || SvSMAGICAL(gv))
	    return;
        for (mg = SvMAGIC(gv); mg; mg = mg->mg_moremagic) {
            if (mg->mg_type != PERL_MAGIC_backref)
                return;
	}
    }
    cv = GvCV(gv);
    if (!cv) {
	HEK *gvnhek = GvNAME_HEK(gv);
	(void)hv_deletehek(stash, gvnhek, G_DISCARD);
    } else if (GvMULTI(gv) && cv && SvREFCNT(cv) == 1 &&
	    !SvOBJECT(cv) && !SvMAGICAL(cv) && !SvREADONLY(cv) &&
	    CvSTASH(cv) == stash && !CvNAMED(cv) && CvGV(cv) == gv &&
	    CvCONST(cv) && !CvMETHOD(cv) && !CvLVALUE(cv) && !CvUNIQUE(cv) &&
	    !CvNODEBUG(cv) && !CvCLONE(cv) && !CvCLONED(cv) && !CvANON(cv) &&
	    (namehek = GvNAME_HEK(gv)) &&
	    (gvp = hv_fetchhek(stash, namehek, 0)) &&
	    *gvp == (SV*)gv) {
	SV *value = SvREFCNT_inc(CvXSUBANY(cv).any_ptr);
	const bool imported = !!GvIMPORTED_CV(gv);
	SvREFCNT(gv) = 0;
	sv_clear((SV*)gv);
	SvREFCNT(gv) = 1;
	SvFLAGS(gv) = SVt_IV|SVf_ROK|SVprv_PCS_IMPORTED * imported;

        /* See also: 'SET_SVANY_FOR_BODYLESS_IV' in sv.c */
	SvANY(gv) = (XPVGV*)((char*)&(gv->sv_u.svu_iv) -
				STRUCT_OFFSET(XPVIV, xiv_iv));
	SvRV_set(gv, value);
    }
}

GV *
Perl_gv_override(pTHX_ const char * const name, const STRLEN len)
{
    GV *gv = gv_fetchpvn(name, len, GV_NOTQUAL, SVt_PVCV);
    GV * const *gvp;
    PERL_ARGS_ASSERT_GV_OVERRIDE;
    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) return gv;
    gvp = (GV**)hv_fetch(PL_globalstash, name, len, FALSE);
    gv = gvp ? *gvp : NULL;
    if (gv && !isGV(gv)) {
	if (!SvPCS_IMPORTED(gv)) return NULL;
	gv_init(gv, PL_globalstash, name, len, 0);
	return gv;
    }
    return gv && GvCVu(gv) && GvIMPORTED_CV(gv) ? gv : NULL;
}

#include "XSUB.h"

static void
core_xsub(pTHX_ CV* cv)
{
    Perl_croak(aTHX_
       "&CORE::%s cannot be called directly", GvNAME(CvGV(cv))
    );
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.18
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a23 1

d37 1
a37 1
#include "overload.c"
d42 1
a42 1
static const STRLEN S_autolen = sizeof(S_autoload)-1;
a103 1
    dVAR;
d132 1
a132 1
    if ((PERLDB_LINE || PERLDB_SAVESRC) && !GvAV(gv))
d145 1
a145 1
NULL.
d154 1
d158 1
a158 1
    return SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVAV ? SvRV(gv) : NULL;
d219 1
a219 1
    GV * const oldgv = CvGV(cv);
d235 4
a238 1
    else if ((hek = CvNAME_HEK(cv))) unshare_hek(hek);
d240 1
d255 31
d307 2
a308 2
overwriting it as happens with typeglobs created by SvSetSV.  Converting
any scalar that is SvOK() may produce unpredictable results and is reserved
d321 1
a321 1
C<flags> can be set to SVf_UTF8 if C<name> is a UTF8 string, or
d323 1
a323 1
GV_ADDMULTI flag, which means to pretend that the GV has been
d328 1
a328 1
The old form of gv_init_pvn().  It does not work with UTF8 strings, as it
d330 1
a330 1
GV_ADDMULTI flag will be passed to gv_init_pvn().
d334 1
a334 1
Same as gv_init_pvn(), but takes a nul-terminated string for the name
d339 1
a339 1
Same as gv_init_pvn(), but takes an SV * for the name instead of separate
a366 1
    dVAR;
d381 1
a381 1
	/* The constant has to be a simple scalar type.  */
a383 1
	case SVt_PVCV:
d388 2
d420 15
a434 1
    if (doproto) {
d572 1
d576 3
a578 1
    (void)gv_fetchfile(file);
d642 8
a649 7
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_FETCHMETH_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_fetchmeth_pvn(stash, namepv, namelen, level, flags);
d665 1
a665 1
    return gv_fetchmeth_pvn(stash, name, strlen(name), level, flags);
d673 1
a673 1
accessible via @@ISA and UNIVERSAL::.
d680 1
a680 1
The only significant values for C<flags> are GV_SUPER and SVf_UTF8.
d682 1
a682 1
GV_SUPER indicates that we want to look up the method in the superclasses
d696 2
a697 2
GV *
Perl_gv_fetchmeth_pvn(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
a698 1
    dVAR;
d700 1
d709 1
a709 1
    I32 create = (level >= 0) ? 1 : 0;
a713 2
    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN;

d728 1
a728 1
    assert(name);
d731 2
a732 1
		      flags & GV_SUPER ? "SUPER " : "",name,hvname) );
d744 6
a749 2
    gvp = (GV**)hv_fetch(cachestash, name, is_utf8 ? -(I32)len : (I32)len,
			 create);
d755 3
d759 1
d838 2
a839 1
        candidate = gv_fetchmeth_pvn(NULL, name, len, 1, flags &~GV_SUPER);
d861 7
d913 1
a913 1
Same as gv_fetchmeth_pvn(), but looks for autoloaded subroutines too.
d917 1
a917 1
if C<level < 0>.  For an autoloaded subroutine without a stub, GvCV()
d920 1
a920 1
Currently, the only significant value for C<flags> is SVf_UTF8.
d962 1
a962 1
glob for "AUTOLOAD".  In this case the corresponding variable $AUTOLOAD is
d975 1
a975 1
different subroutine due to $AUTOLOAD changing its value.  Use the glob
a1016 1
    dVAR;
d1125 1
a1125 1
	    if (CvANON(cv) || !CvGV(cv))
a1165 1
    dVAR;
a1312 1
    dVAR;
d1368 1
a1368 1
C<flags> is 0 (or any other setting that does not create packages) then NULL
d1380 4
a1383 1
The most important of which are probably GV_ADD and SVf_UTF8.
d1388 10
a1397 2
HV*
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 flags)
d1405 1
a1405 1
    PERL_ARGS_ASSERT_GV_STASHPVN;
d1435 61
d1498 5
a1502 1
Returns a pointer to the stash for a specified package.  See C<gv_stashpvn>.
a1509 3
    STRLEN len;
    const char * const ptr = SvPV_const(sv,len);

d1511 1
a1511 2

    return gv_stashpvn(ptr, len, flags | SvUTF8(sv));
d1757 2
a1758 1
            SV * const err = Perl_mess(aTHX_
d1760 2
a1761 1
                 "\" requires explicit package name",
d1765 5
a1769 5
                  : ""), UTF8fARG(is_utf8, len, name));
            GV *gv;
            if (is_utf8)
                SvUTF8_on(err);
            qerror(err);
d1792 6
d1840 1
a1840 1
		/* FALL THROUGH */
d1871 1
a1871 1
	    const char * const name2 = name + 1;
d1930 3
d1979 4
d1996 5
a2000 7
		/* This snippet is taken from is_gv_magical */
		const char *end = name + len;
		while (--end > name) {
		    if (!isDIGIT(*end))
                        return addmg;
		}
                paren = strtoul(name, NULL, 10);
d2120 1
a2120 1
	    /* FALL THROUGH */
d2184 4
a2238 1
    dVAR;
a2415 1
    dVAR;
a2468 1
    dVAR;
a2482 1
    dVAR;
a2501 1
    dVAR;
d2550 4
a2553 2
        DEBUG_o(Perl_deb(aTHX_ "gp_free clearing PL_stashcache for '%"HEKf"'\n", hvname_hek));
        if (PL_stashcache && hvname_hek)
d2555 1
d2558 10
a2627 1
  dVAR;
d2707 8
a2714 5
        if (gv && (cv = GvCV(gv)) && CvGV(cv)) {
	    if(GvNAMELEN(CvGV(cv)) == 3 && strEQ(GvNAME(CvGV(cv)), "nil")){
	      const char * const hvname = HvNAME_get(GvSTASH(CvGV(cv)));
	      if (hvname && HEK_LEN(HvNAME_HEK(GvSTASH(CvGV(cv)))) == 8
	       && strEQ(hvname, "overload")) {
a2747 1
	      }
a2796 1
    dVAR;
a2847 1
    dVAR;
d2855 3
a2857 1
					      AMGf_noright | AMGf_unary))) {
a2891 1
    dVAR;
d2902 2
a2903 1
		    ((flags & AMGf_assign) && opASSIGN ? AMGf_assign: 0));
d3134 1
a3134 1
	     break;
d3142 1
a3142 1
	     break;
a3208 1
	     break;
d3282 3
d3372 1
a3372 1
    int gimme = force_scalar ? G_SCALAR : GIMME_V;
d3411 4
d3570 1
a3570 1
	    CvSTASH(cv) == stash && CvGV(cv) == gv &&
d3582 2
a3617 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d1342 1
a1342 1
    if (!tmpgv)
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d1205 1
a1205 1
    varstash = GvSTASH(CvGV(cv));
d2547 1
a2547 1
        if (gv && (cv = GvCV(gv))) {
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d85 1
d87 4
a90 3
    if (type == SVt_PVAV && GvNAMELEN(gv) == 3
     && strnEQ(GvNAME(gv), "ISA", 3))
	sv_magic(*where, (SV *)gv, PERL_MAGIC_isa, NULL, 0);
d135 1
a135 1
	    hv_magic(GvHVn(gv_AVadd(gv)), NULL, PERL_MAGIC_dbfile);
d159 1
a159 1
    return SvROK(gv) ? SvRV(gv) : NULL;
d170 1
a170 1
    SV * temp_sv;
d181 4
a184 1
#ifdef USE_ITHREADS
d187 1
d192 7
a205 12
#else
    if(PL_curcop)
	gp->gp_line = CopLINE(PL_curcop); /* 0 otherwise Newxz */
    temp_sv = CopFILESV(PL_curcop);
    if (temp_sv) {
	file = SvPVX(temp_sv);
	len = SvCUR(temp_sv);
    } else {
	file = "";
	len = 0;
    }
#endif
a349 1
	case SVt_PVAV:
d466 1
a466 1
    case KEY_BEGIN   : case KEY_CHECK  : case KEY_cmp: case KEY_CORE    :
a521 1
	mro_method_changed_in(GvSTASH(gv));
d543 1
a543 1
	if ((cv = newATTRSUB_flags(
d552 1
a552 1
	           1
d686 3
a688 2
	if (!HvAUX(stash)->xhv_super) HvAUX(stash)->xhv_super = newHV();
	cachestash = HvAUX(stash)->xhv_super;
d904 2
a905 1
These functions grant C<"SUPER"> token as a prefix of the method name. Note
d908 2
a909 2
different subroutine due to $AUTOLOAD changing its value. Use the glob
created via a side effect to do this.
d911 3
a913 4
These functions have the same side-effects and as C<gv_fetchmeth> with
C<level==0>.  C<name> should be writable if contains C<':'> or C<'
''>. The warning against passing the GV returned by C<gv_fetchmeth> to
C<call_sv> apply equally to these functions.
d1029 1
a1029 1
			   "Can't locate object method \"%"SVf
d1031 1
a1031 2
			            SVfARG(newSVpvn_flags(name, nend - name,
                                           SVs_TEMP | is_utf8)),
d1041 1
a1041 1
		    packnamesv = sv_2mortal(newSVsv(error_report));
d1045 2
a1046 1
			   "Can't locate object method \"%"SVf"\" via package \"%"SVf"\""
d1048 1
a1048 2
			   SVfARG(newSVpvn_flags(name, nend - name,
                                SVs_TEMP | is_utf8)),
d1059 1
a1059 1
	    if (CvANON(cv))
d1141 2
a1142 1
			 "Use of inherited AUTOLOAD for non-method %"SVf"::%"SVf"() is deprecated",
d1144 1
a1144 1
                         SVfARG(newSVpvn_flags(name, len, SVs_TEMP | is_utf8)));
d1259 1
d1261 1
a1265 1
	PUSHSTACKi(PERLSI_MAGIC);
d1267 1
a1267 1
	POPSTACK;
d1394 1
a1394 1
STATIC void
d1407 10
a1416 3
GV *
Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags,
		       const svtype sv_type)
a1417 5
    dVAR;
    const char *name = nambeg;
    GV *gv = NULL;
    GV**gvp;
    I32 len;
a1418 6
    HV *stash = NULL;
    const I32 no_init = flags & (GV_NOADD_NOINIT | GV_NOINIT);
    const I32 no_expand = flags & GV_NOEXPAND;
    const I32 add = flags & ~GV_NOADD_MASK;
    const U32 is_utf8 = flags & SVf_UTF8;
    bool addmg = !!(flags & GV_ADDMG);
a1420 1
    U32 faking_it;
d1422 6
a1427 1
    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;
d1429 58
a1486 48
    if (flags & GV_NOTQUAL) {
	/* Caller promised that there is no stash, so we can skip the check. */
	len = full_len;
	goto no_stash;
    }

    if (full_len > 2 && *name == '*' && isIDFIRST_lazy_if(name + 1, is_utf8)) {
	/* accidental stringify on a GV? */
	name++;
    }

    for (name_cursor = name; name_cursor < name_end; name_cursor++) {
	if (name_cursor < name_em1 &&
	    ((*name_cursor == ':'
	     && name_cursor[1] == ':')
	    || *name_cursor == '\''))
	{
	    if (!stash)
		stash = PL_defstash;
	    if (!stash || !SvREFCNT(stash)) /* symbol table under destruction */
		return NULL;

	    len = name_cursor - name;
	    if (name_cursor > nambeg) { /* Skip for initial :: or ' */
		const char *key;
		if (*name_cursor == ':') {
		    key = name;
		    len += 2;
		} else {
		    char *tmpbuf;
		    Newx(tmpbuf, len+2, char);
		    Copy(name, tmpbuf, len, char);
		    tmpbuf[len++] = ':';
		    tmpbuf[len++] = ':';
		    key = tmpbuf;
		}
		gvp = (GV**)hv_fetch(stash, key, is_utf8 ? -len : len, add);
		gv = gvp ? *gvp : NULL;
		if (gv && gv != (const GV *)&PL_sv_undef) {
		    if (SvTYPE(gv) != SVt_PVGV)
			gv_init_pvn(gv, stash, key, len, (add & GV_ADDMULTI)|is_utf8);
		    else
			GvMULTI_on(gv);
		}
		if (key != name)
		    Safefree(key);
		if (!gv || gv == (const GV *)&PL_sv_undef)
		    return NULL;
d1488 9
a1496 28
		if (!(stash = GvHV(gv)))
		{
		    stash = GvHV(gv) = newHV();
		    if (!HvNAME_get(stash)) {
			if (GvSTASH(gv) == PL_defstash && len == 6
			 && strnEQ(name, "CORE", 4))
			    hv_name_set(stash, "CORE", 4, 0);
			else
			    hv_name_set(
				stash, nambeg, name_cursor-nambeg, is_utf8
			    );
			/* If the containing stash has multiple effective
			   names, see that this one gets them, too. */
			if (HvAUX(GvSTASH(gv))->xhv_name_count)
			    mro_package_moved(stash, NULL, gv, 1);
		    }
		}
		else if (!HvNAME_get(stash))
		    hv_name_set(stash, nambeg, name_cursor - nambeg, is_utf8);
	    }

	    if (*name_cursor == ':')
		name_cursor++;
	    name = name_cursor+1;
	    if (name == name_end)
		return gv
		    ? gv : MUTABLE_GV(*hv_fetchs(PL_defstash, "main::", TRUE));
	}
d1498 3
a1500 1
    len = name_cursor - name;
d1502 45
a1546 87
    /* No stash in name, so see how we can default */

    if (!stash) {
    no_stash:
	if (len && isIDFIRST_lazy_if(name, is_utf8)) {
	    bool global = FALSE;

	    switch (len) {
	    case 1:
		if (*name == '_')
		    global = TRUE;
		break;
	    case 3:
		if ((name[0] == 'I' && name[1] == 'N' && name[2] == 'C')
		    || (name[0] == 'E' && name[1] == 'N' && name[2] == 'V')
		    || (name[0] == 'S' && name[1] == 'I' && name[2] == 'G'))
		    global = TRUE;
		break;
	    case 4:
		if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
		    && name[3] == 'V')
		    global = TRUE;
		break;
	    case 5:
		if (name[0] == 'S' && name[1] == 'T' && name[2] == 'D'
		    && name[3] == 'I' && name[4] == 'N')
		    global = TRUE;
		break;
	    case 6:
		if ((name[0] == 'S' && name[1] == 'T' && name[2] == 'D')
		    &&((name[3] == 'O' && name[4] == 'U' && name[5] == 'T')
		       ||(name[3] == 'E' && name[4] == 'R' && name[5] == 'R')))
		    global = TRUE;
		break;
	    case 7:
		if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
		    && name[3] == 'V' && name[4] == 'O' && name[5] == 'U'
		    && name[6] == 'T')
		    global = TRUE;
		break;
	    }

	    if (global)
		stash = PL_defstash;
	    else if (IN_PERL_COMPILETIME) {
		stash = PL_curstash;
		if (add && (PL_hints & HINT_STRICT_VARS) &&
		    sv_type != SVt_PVCV &&
		    sv_type != SVt_PVGV &&
		    sv_type != SVt_PVFM &&
		    sv_type != SVt_PVIO &&
		    !(len == 1 && sv_type == SVt_PV &&
		      (*name == 'a' || *name == 'b')) )
		{
		    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -len : len,0);
		    if (!gvp ||
			*gvp == (const GV *)&PL_sv_undef ||
			SvTYPE(*gvp) != SVt_PVGV)
		    {
			stash = NULL;
		    }
		    else if ((sv_type == SVt_PV   && !GvIMPORTED_SV(*gvp)) ||
			     (sv_type == SVt_PVAV && !GvIMPORTED_AV(*gvp)) ||
			     (sv_type == SVt_PVHV && !GvIMPORTED_HV(*gvp)) )
		    {
                        SV* namesv = newSVpvn_flags(name, len, SVs_TEMP | is_utf8);
			/* diag_listed_as: Variable "%s" is not imported%s */
			Perl_ck_warner_d(
			    aTHX_ packWARN(WARN_MISC),
			    "Variable \"%c%"SVf"\" is not imported",
			    sv_type == SVt_PVAV ? '@@' :
			    sv_type == SVt_PVHV ? '%' : '$',
			    SVfARG(namesv));
			if (GvCVu(*gvp))
			    Perl_ck_warner_d(
				aTHX_ packWARN(WARN_MISC),
				"\t(Did you mean &%"SVf" instead?)\n", SVfARG(namesv)
			    );
			stash = NULL;
		    }
		}
	    }
	    else
		stash = CopSTASH(PL_curcop);
	}
	else
	    stash = PL_defstash;
d1548 6
a1554 1
    /* By this point we should have a stash and a name */
d1556 15
a1570 24
    if (!stash) {
	if (add && !PL_in_clean_all) {
	    SV * const namesv = newSVpvn_flags(name, len, is_utf8);
	    SV * const err = Perl_mess(aTHX_
		 "Global symbol \"%s%"SVf"\" requires explicit package name",
		 (sv_type == SVt_PV ? "$"
		  : sv_type == SVt_PVAV ? "@@"
		  : sv_type == SVt_PVHV ? "%"
		  : ""), SVfARG(namesv));
	    GV *gv;
	    SvREFCNT_dec_NN(namesv);
	    if (is_utf8)
		SvUTF8_on(err);
	    qerror(err);
	    gv = gv_fetchpvs("<none>::", GV_ADDMULTI, SVt_PVHV);
	    if(!gv) {
		/* symbol table under destruction */
		return NULL;
	    }	
	    stash = GvHV(gv);
	}
	else
	    return NULL;
    }
d1572 2
a1573 7
    if (!SvREFCNT(stash))	/* symbol table under destruction */
	return NULL;

    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -len : len,add);
    if (!gvp || *gvp == (const GV *)&PL_sv_undef) {
	if (addmg) gv = (GV *)newSV(0);
	else return NULL;
d1575 35
a1609 45
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

    if (SvTYPE(gv) == SVt_PVGV) {
	if (add) {
	    GvMULTI_on(gv);
	    gv_init_svtype(gv, sv_type);
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn't
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
	    if (len == 1 && stash == PL_defstash) {
	      if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
	        if (*name == '!')
		    require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
		else if (*name == '-' || *name == '+')
		    require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);
              } else if (sv_type == SVt_PV) {
                  if (*name == '*' || *name == '#') {
                      /* diag_listed_as: $* is no longer supported */
                      Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,
                                                       WARN_SYNTAX),
                                       "$%c is no longer supported", *name);
                  }
              }
	      if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
                switch (*name) {
	        case '[':
		    require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
                    break;
#ifdef PERL_SAWAMPERSAND
	        case '`':
		    PL_sawampersand |= SAWAMPERSAND_LEFT;
                    (void)GvSVn(gv);
                    break;
	        case '&':
		    PL_sawampersand |= SAWAMPERSAND_MIDDLE;
                    (void)GvSVn(gv);
                    break;
	        case '\'':
		    PL_sawampersand |= SAWAMPERSAND_RIGHT;
                    (void)GvSVn(gv);
                    break;
#endif
d1611 6
a1616 14
	      }
	    }
	    else if (len == 3 && sv_type == SVt_PVAV
	          && strnEQ(name, "ISA", 3)
	          && (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
		gv_magicalize_isa(gv);
	}
	return gv;
    } else if (no_init) {
	assert(!addmg);
	return gv;
    } else if (no_expand && SvROK(gv)) {
	assert(!addmg);
	return gv;
d1619 28
a1646 6
    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */
d1648 2
a1649 1
    faking_it = SvOK(gv);
d1651 2
a1652 4
    if (add & GV_ADDWARN)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "Had to create %"SVf" unexpectedly",
                SVfARG(newSVpvn_flags(nambeg, name_end-nambeg, SVs_TEMP | is_utf8 )));
    gv_init_pvn(gv, stash, name, len, (add & GV_ADDMULTI)|is_utf8);
d1654 16
a1669 3
    if ( isIDFIRST_lazy_if(name, is_utf8)
                && ! (isLEXWARN_on ? ckWARN(WARN_ONCE) : (PL_dowarn & G_WARN_ON ) ) )
        GvMULTI_on(gv) ;
d1671 2
a1672 1
    /* set up magic where warranted */
d1674 1
a1674 1
	/* We only have to check for three names here: EXPORT, ISA
d1677 1
a1677 1
	if (len > 2) {
d1692 5
d1700 1
a1700 1
	    goto add_magical_gv;
d1717 7
a1723 1
	       the common case of lower case variable names.  */
d1798 5
a1802 2
                if (strEQ(name2, "ATCH"))
		    goto magicalize;
d1808 8
a1815 2
	        if (strEQ(name2, "REMATCH") || strEQ(name2, "OSTMATCH"))
		    goto magicalize;
d1848 2
a1849 1
		    if (!isDIGIT(*end))	goto add_magical_gv;
d1851 2
a1852 1
		goto magicalize;
d1861 2
d1864 2
d1867 2
d1884 17
a1900 1
	    goto magicalize;
a1920 2
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
		addmg = 0;
d1922 1
a1940 2
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
		addmg = 0;
d1942 1
a1962 1
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
d1964 1
a1964 1
		addmg = 0;
a1972 9
	case '1':		/* $1 */
	case '2':		/* $2 */
	case '3':		/* $3 */
	case '4':		/* $4 */
	case '5':		/* $5 */
	case '6':		/* $6 */
	case '7':		/* $7 */
	case '8':		/* $8 */
	case '9':		/* $9 */
d2025 4
d2031 48
a2078 7
  add_magical_gv:
    if (addmg) {
	if (GvAV(gv) || GvHV(gv) || GvIO(gv) || GvCV(gv) || (
	     GvSV(gv) && (SvOK(GvSV(gv)) || SvMAGICAL(GvSV(gv)))
	   ))
	    (void)hv_store(stash,name,len,(SV *)gv,0);
	else SvREFCNT_dec_NN(gv), gv = NULL;
d2080 141
d2256 5
d2262 1
a2262 1
Perl_gv_check(pTHX_ const HV *stash)
d2271 3
d2276 2
d2284 4
a2287 1
		if (hv != PL_defstash && hv != stash)
d2311 1
d2320 1
d2322 2
a2323 3
    return gv_fetchpv(Perl_form(aTHX_ "%"SVf"::_GEN_%ld",
                                    SVfARG(newSVpvn_flags(pack, strlen(pack),
                                            SVs_TEMP | flags)),
d2365 2
a2366 1
    if (--gp->gp_refcnt > 0) {
d2369 1
d2404 1
a2404 3
           (void)hv_delete(PL_stashcache, HEK_KEY(hvname_hek),
                      (HEK_UTF8(hvname_hek) ? -HEK_LEN(hvname_hek) : HEK_LEN(hvname_hek)),
                      G_DISCARD);
d2411 3
d2430 2
d2494 2
d2526 4
d2596 13
d2610 6
d2785 1
d2789 9
a2797 2
    while (SvAMAGIC(ref) && 
	   (tmpsv = amagic_call(ref, &PL_sv_undef, method,
d2806 2
a3236 1
    PUTBACK;
d3384 2
d3399 2
a3400 3
	(void)hv_delete(stash, HEK_KEY(gvnhek),
	    HEK_UTF8(gvnhek) ? -HEK_LEN(gvnhek) : HEK_LEN(gvnhek), G_DISCARD);
    } else if (GvMULTI(gv) && cv &&
d3406 1
a3406 2
	    (gvp = hv_fetch(stash, HEK_KEY(namehek),
			HEK_LEN(namehek)*(HEK_UTF8(namehek) ? -1 : 1), 0)) &&
d3409 1
d3413 1
a3413 1
	SvFLAGS(gv) = SVt_IV|SVf_ROK;
d3418 17
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d86 3
a164 6
#ifdef USE_ITHREADS
    const char *const file
	= (PL_curcop && CopFILE(PL_curcop)) ? CopFILE(PL_curcop) : "";
    const STRLEN len = strlen(file);
#else
    SV *const temp_sv = CopFILESV(PL_curcop);
d167 4
d173 5
d179 18
a206 10

    Newxz(gp, 1, GP);

#ifndef PERL_DONT_CREATE_GVSV
    gp->gp_sv = newSV(0);
#endif

    gp->gp_line = PL_curcop ? CopLINE(PL_curcop) : 0;
    /* XXX Ideally this cast would be replaced with a change to const char*
       in the struct.  */
a207 1
    gp->gp_egv = gv;
d220 1
d228 1
a228 1
	    SvREFCNT_dec(oldgv);
d235 1
d237 1
a237 1
    SvANY(cv)->xcv_gv = gv;
d386 1
a386 1
    if (doproto) {			/* Replicate part of newSUB here. */
a387 1
	ENTER;
d400 1
d402 1
a402 3
	    (void) start_subparse(0,0);	/* Create empty CV in compcv. */
	    cv = PL_compcv;
	    GvCV_set(gv,cv);
a403 6
	LEAVE;

        mro_method_changed_in(GvSTASH(gv)); /* sub Foo::bar($) { (shift) } sub ASDF::baz($); *ASDF::baz = \&Foo::bar */
	CvGV_set(cv, gv);
	CvFILE_set_from_cop(cv, PL_curcop);
	CvSTASH_set(cv, PL_curstash);
a452 1
    SV *opnumsv;
d461 2
a462 2
    if (code >= 0) return NULL; /* not overridable */
    switch (-code) {
d464 19
a482 6
        no support for funcs that take labels, as their parsing is
        weird  */
    case KEY_and: case KEY_cmp: case KEY_CORE: case KEY_dump:
    case KEY_eq: case KEY_ge:
    case KEY_gt: case KEY_le: case KEY_lt: case KEY_ne:
    case KEY_or: case KEY_x: case KEY_xor:
d485 2
a486 2
    case KEY_chomp: case KEY_chop:
    case KEY_each: case KEY_eof: case KEY_exec:
d492 1
a492 1
    case KEY_splice:
d538 3
d542 3
a544 1
	newATTRSUB_flags(
d554 6
a559 4
	);
	assert(GvCV(gv) == cv);
	if (opnum != OP_VEC && opnum != OP_SUBSTR)
	    CvLVALUE_off(cv); /* Now *that* was a neat trick. */
d565 8
a572 5
    opnumsv = opnum ? newSVuv((UV)opnum) : (SV *)NULL;
    cv_set_call_checker(
       cv, Perl_ck_entersub_args_core, opnumsv ? opnumsv : (SV *)cv
    );
    SvREFCNT_dec(opnumsv);
d629 4
a632 1
Currently, the only significant value for C<flags> is SVf_UTF8.
d634 1
a634 1
This function grants C<"SUPER"> token as a postfix of the stash name. The
d653 1
a653 1
    HV* cstash;
a659 1
    STRLEN packlen;
d681 2
a682 1
    DEBUG_o( Perl_deb(aTHX_ "Looking for method %s in package %s\n",name,hvname) );
d686 6
d693 2
a694 1
    gvp = (GV**)hv_fetch(stash, name, is_utf8 ? -(I32)len : (I32)len, create);
d708 1
a708 1
	        SvREFCNT_dec(cand_cv);
d718 2
a719 1
	else if (len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4
d725 1
a725 12
    packlen = HvNAMELEN_get(stash);
    if (packlen >= 7 && strEQ(hvname + packlen - 7, "::SUPER")) {
        HV* basestash;
        packlen -= 7;
        basestash = gv_stashpvn(hvname, packlen,
                                GV_ADD | (HvNAMEUTF8(stash) ? SVf_UTF8 : 0));
        linear_av = mro_get_linear_isa(basestash);
    }
    else {
        linear_av = mro_get_linear_isa(stash); /* has ourselves at the top of the list */
    }

d779 1
a779 1
        candidate = gv_fetchmeth_pvn(NULL, name, len, 1, flags);
a917 38
STATIC HV*
S_gv_get_super_pkg(pTHX_ const char* name, I32 namelen, U32 flags)
{
    AV* superisa;
    GV** gvp;
    GV* gv;
    HV* stash;

    PERL_ARGS_ASSERT_GV_GET_SUPER_PKG;

    stash = gv_stashpvn(name, namelen, flags);
    if(stash) return stash;

    /* If we must create it, give it an @@ISA array containing
       the real package this SUPER is for, so that it's tied
       into the cache invalidation code correctly */
    stash = gv_stashpvn(name, namelen, GV_ADD | flags);
    gvp = (GV**)hv_fetchs(stash, "ISA", TRUE);
    gv = *gvp;
    gv_init(gv, stash, "ISA", 3, TRUE);
    superisa = GvAVn(gv);
    GvMULTI_on(gv);
    sv_magic(MUTABLE_SV(superisa), MUTABLE_SV(gv), PERL_MAGIC_isa, NULL, 0);
#ifdef USE_ITHREADS
    av_push(superisa, newSVpvn_flags(CopSTASHPV(PL_curcop),
                                     CopSTASH_len(PL_curcop) < 0
					? -CopSTASH_len(PL_curcop)
					:  CopSTASH_len(PL_curcop),
                                     SVf_UTF8*(CopSTASH_len(PL_curcop) < 0)
                                    ));
#else
    av_push(superisa, newSVhek(CopSTASH(PL_curcop)
			       ? HvNAME_HEK(CopSTASH(PL_curcop)) : NULL));
#endif

    return stash;
}

d951 1
a951 1
    register const char *nend;
d984 2
a985 6
	    SV * const tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_
		     "%"HEKf"::SUPER",
		      HEKfARG(HvNAME_HEK((HV*)CopSTASH(PL_curcop)))
	    ));
	    /* __PACKAGE__::SUPER stash should be autovivified */
	    stash = gv_get_super_pkg(SvPVX_const(tmpstr), SvCUR(tmpstr), SvUTF8(tmpstr));
d987 7
a993 1
			 origname, HvNAME_get(stash), name) );
a997 7

	    /* however, explicit calls to Pkg::SUPER::method may
	       happen, and may require autovivification to work */
	    if (!stash && (nsplit - origname) >= 7 &&
		strnEQ(nsplit - 7, "::SUPER", 7) &&
		gv_stashpvn(origname, nsplit - origname - 7, is_utf8))
	      stash = gv_get_super_pkg(origname, nsplit - origname, flags);
d1124 1
d1126 2
a1127 1
    if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE, is_utf8)))
d1171 1
a1171 1
	    SV *tmpsv = newSVpvn_flags(name, len, is_utf8);
d1185 1
a1185 1
	    SvREFCNT_dec(tmpsv);
d1217 2
d1261 1
a1266 2
	LEAVE;
	SPAGAIN;
d1274 1
d1276 1
a1276 1
    SvREFCNT_dec(namesv);
d1306 10
a1405 12
STATIC void
S_gv_magicalize_overload(pTHX_ GV *gv)
{
    HV* hv;

    PERL_ARGS_ASSERT_GV_MAGICALIZE_OVERLOAD;

    hv = GvHVn(gv);
    GvMULTI_on(gv);
    hv_magic(hv, NULL, PERL_MAGIC_overload);
}

d1411 2
a1412 2
    register const char *name = nambeg;
    register GV *gv = NULL;
d1415 1
a1415 1
    register const char *name_cursor;
d1512 1
a1512 1
	if (len && isIDFIRST_lazy(name)) {
d1600 2
a1601 1
	if (add) {
d1607 1
a1607 1
		  : ""), SVfARG(newSVpvn_flags(name, len, SVs_TEMP | is_utf8)));
d1609 2
a1610 1
	    if (USE_UTF8_IN_NAMES)
d1640 4
d1650 8
a1657 1
	      }
d1659 19
a1677 6
	       if (*name == '[')
		require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
	       else if (*name == '&' || *name == '`' || *name == '\'') {
		PL_sawampersand = TRUE;
		(void)GvSVn(gv);
	       }
d1714 1
a1714 1
	/* We only have to check for four names here: EXPORT, ISA, OVERLOAD
a1727 4
	    case 'O':
		if (strEQ(name2, "VERLOAD"))
		    gv_magicalize_overload(gv);
		break;
a1774 5
	    case 'O':
		if (strEQ(name2, "VERLOAD")) {
		    gv_magicalize_overload(gv);
		}
		break;
d1822 4
d1881 1
d1888 8
a1895 1
		)) { PL_sawampersand = TRUE; }
a1951 4
	case '|':		/* $| */
	    sv_setiv(GvSVn(gv), (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0);
	    goto magicalize;

d1992 1
a2010 1
	    PL_formfeed = GvSVn(gv);
d2041 1
a2041 1
	else SvREFCNT_dec(gv), gv = NULL;
d2082 1
a2082 1
    register I32 i;
d2091 1
a2091 1
            register GV *gv;
d2150 1
a2150 1
	    SvREFCNT_dec(gp->gp_cv);
d2208 1
d2252 1
a2252 1
		SvREFCNT_dec(MUTABLE_SV(cv));
d2281 2
a2282 3
      if (amtp->was_ok_am == PL_amagic_generation
	  && amtp->was_ok_sub == newgen) {
	  return AMT_OVERLOADED(amtp) ? 1 : 0;
a2289 1
  amt.was_ok_am = PL_amagic_generation;
d2295 2
a2296 2
    int filled = 0, have_ovl = 0;
    int i, lim = 1;
d2306 4
a2309 1
	lim = DESTROY_amg;		/* Skip overloading entries. */
d2316 2
d2319 1
a2319 1
    else if (SvOK(sv))
d2321 5
d2327 1
a2327 3
    for (i = 1; i < lim; i++)
	amt.table[i] = NULL;
    for (; i < NofAMmeth; i++) {
d2330 1
a2330 1
	const char * const cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
d2342 1
a2342 4
	if (i >= DESTROY_amg)
	    gv = Perl_gv_fetchmeth_pvn_autoload(aTHX_ stash, cooky, l, 0, 0);
	else				/* Autoload taken care of below */
	    gv = Perl_gv_fetchmeth_pvn(aTHX_ stash, cooky, l, -1, 0);
a2387 2
	    if (i < DESTROY_amg)
		have_ovl = 1;
a2395 2
      if (have_ovl)
	  AMT_OVERLOADED_on(&amt);
d2398 1
a2398 1
      return have_ovl;
d2402 1
a2402 1
  /* no_table: */
d2428 1
a2428 11
	/* If we're looking up a destructor to invoke, we must avoid
	 * that Gv_AMupdate croaks, because we might be dying already */
	if (Gv_AMupdate(stash, cBOOL(id == DESTROY_amg)) == -1) {
	    /* and if it didn't found a destructor, we fall back
	     * to a simpler method that will only look for the
	     * destructor instead of the whole magic */
	    if (id == DESTROY_amg) {
		GV * const gv = gv_fetchmethod(stash, "DESTROY");
		if (gv)
		    return GvCV(gv);
	    }
a2429 1
	}
d2434 1
a2434 2
    if ( amtp->was_ok_am != PL_amagic_generation
	 || amtp->was_ok_sub != newgen )
d2618 1
d2631 1
a2631 1
      && (stash = SvSTASH(SvRV(left)))
d2696 2
a2697 6
		/* As a bit of a source compatibility hack, SvAMAGIC() and
		   friends dereference an RV, to behave the same was as when
		   overloading was stored on the reference, not the referant.
		   Hence we can't use SvAMAGIC_on()
		*/
		SvFLAGS(newref) |= SVf_AMAGIC;
d2754 1
a2754 1
	       && (stash = SvSTASH(SvRV(right)))
d2858 58
d2966 1
a2966 1
	  SvREFCNT_dec(tmpRef);  
d2975 2
d2982 16
a2997 1
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;
d3018 1
d3024 24
a3048 1
    res=POPs;
d3202 1
a3202 1
 * indent-tabs-mode: t
d3205 1
a3205 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d19 1
a19 1
 *     [p.599 of _The Lord of the Rings_, III/xi: "The Palantír"]
d39 2
d50 7
a56 1
    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV) {
d63 1
a63 5
	    what = PL_op->op_type ==  OP_READDIR ||
		PL_op->op_type ==  OP_TELLDIR ||
		PL_op->op_type ==  OP_SEEKDIR ||
		PL_op->op_type ==  OP_REWINDDIR ||
		PL_op->op_type ==  OP_CLOSEDIR ?
a64 1
	    /* diag_listed_as: Bad symbol for filehandle */
d70 1
d128 2
a129 1
	if (PERLDB_LINE || PERLDB_SAVESRC)
a130 1
    }
d200 95
d296 20
a315 1
Perl_gv_init(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, int multi)
d320 3
a322 1
    char * const proto = (doproto && SvPOK(gv)) ? SvPVX(gv) : NULL;
d324 1
d328 1
a328 1
    PERL_ARGS_ASSERT_GV_INIT;
d364 1
a364 1
    GvGP(gv) = Perl_newGP(aTHX_ gv);
d368 3
a370 3
    gv_name_set(gv, name, len, GV_ADD);
    if (multi || doproto)              /* doproto means it _was_ mentioned */
	GvMULTI_on(gv);
d372 1
d376 5
a380 1
	    GvCV(gv) = newCONSTSUB(stash, name, has_constant);
d388 2
a389 1
	    GvCV(gv) = PL_compcv;
d394 3
a396 3
	CvGV(GvCV(gv)) = gv;
	CvFILE_set_from_cop(GvCV(gv), PL_curcop);
	CvSTASH(GvCV(gv)) = PL_curstash;
d398 1
a398 1
	    sv_usepvn_flags(MUTABLE_SV(GvCV(gv)), proto, protolen,
d400 1
d406 1
a406 1
S_gv_init_sv(pTHX_ GV *gv, const svtype sv_type)
d408 1
a408 1
    PERL_ARGS_ASSERT_GV_INIT_SV;
d436 111
d550 41
d600 2
d614 1
a614 1
Perl_gv_fetchmeth(pTHX_ HV *stash, const char *name, STRLEN len, I32 level)
a623 1
    CV* old_cv;
d630 1
d632 1
a632 1
    PERL_ARGS_ASSERT_GV_FETCHMETH;
d655 1
a655 1
    gvp = (GV**)hv_fetch(stash, name, len, create);
d658 1
d661 1
a661 1
            gv_init(topgv, stash, name, len, TRUE);
d670 2
a671 1
	        GvCV(topgv) = cand_cv = NULL;
d679 4
d689 2
a690 1
        basestash = gv_stashpvn(hvname, packlen, GV_ADD);
d705 4
a708 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Can't locate package %"SVf" for @@%s::ISA",
			   SVfARG(linear_sv), hvname);
d714 14
a727 3
        gvp = (GV**)hv_fetch(cstash, name, len, 0);
        if (!gvp) continue;
        candidate = *gvp;
d729 2
a730 1
        if (SvTYPE(candidate) != SVt_PVGV) gv_init(candidate, cstash, name, len, TRUE);
d738 2
a739 1
                  if ((old_cv = GvCV(topgv))) SvREFCNT_dec(old_cv);
d741 1
a741 1
                  GvCV(topgv) = cand_cv;
d750 1
a750 1
        candidate = gv_fetchmeth(NULL, name, len, 1);
d754 2
a755 1
                  if ((old_cv = GvCV(topgv))) SvREFCNT_dec(old_cv);
d757 1
a757 1
                  GvCV(topgv) = cand_cv;
d775 43
a817 1
Same as gv_fetchmeth(), but looks for autoloaded subroutines too.
d824 2
d830 1
a830 1
Perl_gv_fetchmeth_autoload(pTHX_ HV *stash, const char *name, STRLEN len, I32 level)
d832 1
a832 1
    GV *gv = gv_fetchmeth(stash, name, len, level);
d834 1
a834 1
    PERL_ARGS_ASSERT_GV_FETCHMETH_AUTOLOAD;
d844 1
a844 1
	if (!(gv = gv_fetchmeth(stash, S_autoload, S_autolen, FALSE)))
d851 3
a853 2
	    gv_fetchmeth(stash, name, len, 0);
	gvp = (GV**)hv_fetch(stash, name, len, (level >= 0));
d890 1
a890 1
S_gv_get_super_pkg(pTHX_ const char* name, I32 namelen)
d899 1
a899 1
    stash = gv_stashpvn(name, namelen, 0);
d905 1
a905 1
    stash = gv_stashpvn(name, namelen, GV_ADD);
d913 6
a918 1
    av_push(superisa, newSVpv(CopSTASHPV(PL_curcop), 0));
d935 19
d957 1
a957 1
Perl_gv_fetchmethod_flags(pTHX_ HV *stash, const char *name, U32 flags)
d968 1
d970 1
a970 1
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_FLAGS;
d980 1
a980 1
    for (nend = name; *nend; nend++) {
d993 4
a996 2
	    SV * const tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_ "%s::SUPER",
						  CopSTASHPV(PL_curcop)));
d998 1
a998 1
	    stash = gv_get_super_pkg(SvPVX_const(tmpstr), SvCUR(tmpstr));
d1004 1
a1004 1
            stash = gv_stashpvn(origname, nsplit - origname, 0);
d1010 2
a1011 2
		gv_stashpvn(origname, nsplit - origname - 7, 0))
	      stash = gv_get_super_pkg(origname, nsplit - origname);
d1016 1
a1016 1
    gv = gv_fetchmeth(stash, name, nend - name, 0);
d1021 3
a1023 1
	    gv = gv_autoload4(ostash, name, nend - name, TRUE);
d1028 14
d1043 5
a1047 2
			   "Can't locate object method \"%s\" via package \"%.*s\"",
			   name, (int)HvNAMELEN_get(stash), HvNAME_get(stash));
d1050 1
a1050 2
		STRLEN packlen;
		const char *packname;
d1053 2
a1054 2
		    packlen = nsplit - origname;
		    packname = origname;
d1056 1
a1056 1
		    packname = SvPV_const(error_report, packlen);
d1060 5
a1064 3
			   "Can't locate object method \"%s\" via package \"%.*s\""
			   " (perhaps you forgot to load \"%.*s\"?)",
			   name, (int)packlen, packname, (int)packlen, packname);
d1081 4
a1084 2
	    autogv = gv_autoload4(GvSTASH(stubgv),
				  GvNAME(stubgv), GvNAMELEN(stubgv), TRUE);
d1094 20
a1113 1
Perl_gv_autoload4(pTHX_ HV *stash, const char *name, STRLEN len, I32 method)
d1121 2
a1122 2
    const char *packname = "";
    STRLEN packname_len = 0;
d1124 1
a1124 1
    PERL_ARGS_ASSERT_GV_AUTOLOAD4;
d1130 4
a1133 1
	    packname = SvPV_const(MUTABLE_SV(stash), packname_len);
d1136 2
a1137 4
	else {
	    packname = HvNAME_get(stash);
	    packname_len = HvNAMELEN_get(stash);
	}
d1139 1
a1139 1
    if (!(gv = gv_fetchmeth(stash, S_autoload, S_autolen, FALSE)))
d1149 3
a1151 1
    if (!method && (GvCVGEN(gv) || GvSTASH(gv) != stash)
d1154 3
a1156 2
			 "Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated",
			 packname, (int)len, name);
d1159 21
a1179 4
        /* rather than lookup/init $AUTOLOAD here
         * only to have the XSUB do another lookup for $AUTOLOAD
         * and split that value on the last '::',
         * pass along the same data via some unused fields in the CV
d1181 28
a1208 4
        CvSTASH(cv) = stash;
        SvPV_set(cv, (char *)name); /* cast to lose constness warning */
        SvCUR_set(cv, len);
        return gv;
d1222 1
a1222 1
	gv_init(vargv, varstash, S_autoload, S_autolen, FALSE);
d1229 1
a1229 1
    sv_setpvn(varsv, packname, packname_len);
d1231 8
a1238 1
    sv_catpvn(varsv, name, len);
d1244 1
a1244 1
 * that implements the logic of automatical ties like %! and %-
d1263 1
a1263 1
    if (!stash || !(gv_fetchmethod(stash, methpv))) {
d1268 1
d1280 2
a1281 2
	    Perl_croak(aTHX_ "panic: Can't use %%%c because %"SVf" is not available",
		    varname, SVfARG(namesv));
d1283 2
a1284 2
	    Perl_croak(aTHX_ "panic: Can't use %%%c because %"SVf" does not support method %s",
		    varname, SVfARG(namesv), methpv);
a1342 2
    if (!GvHV(tmpgv))
	GvHV(tmpgv) = newHV();
d1344 11
a1354 2
    if (!HvNAME_get(stash))
	hv_name_set(stash, name, namelen, 0);
d1374 1
a1374 1
    return gv_stashpvn(ptr, len, flags);
d1387 2
a1388 1
    const char * const nambeg = SvPV_const(name, len);
d1393 25
d1432 2
d1446 1
a1446 1
    if (full_len > 2 && *name == '*' && isALPHA(name[1])) {
d1452 2
a1453 1
	if ((*name_cursor == ':' && name_cursor < name_em1
d1455 1
a1455 1
	    || (*name_cursor == '\'' && name_cursor[1]))
d1463 7
a1469 7
	    if (len > 0) {
		char smallbuf[128];
		char *tmpbuf;

		if (len + 2 <= (I32)sizeof (smallbuf))
		    tmpbuf = smallbuf;
		else
d1471 6
a1476 4
		Copy(name, tmpbuf, len, char);
		tmpbuf[len++] = ':';
		tmpbuf[len++] = ':';
		gvp = (GV**)hv_fetch(stash,tmpbuf,len,add);
d1480 1
a1480 1
			gv_init(gv, stash, tmpbuf, len, (add & GV_ADDMULTI));
d1484 2
a1485 2
		if (tmpbuf != smallbuf)
		    Safefree(tmpbuf);
d1490 1
d1492 16
a1507 3

		if (!HvNAME_get(stash))
		    hv_name_set(stash, nambeg, name_cursor - nambeg, 0);
d1512 1
a1512 2
	    name_cursor++;
	    name = name_cursor;
d1574 1
a1574 1
		    gvp = (GV**)hv_fetch(stash,name,len,0);
d1585 1
d1587 3
a1589 1
			Perl_warn(aTHX_ "Variable \"%c%s\" is not imported",
d1592 1
a1592 1
			    name);
d1594 4
a1597 1
			    Perl_warn(aTHX_ "\t(Did you mean &%s instead?)\n", name);
d1614 1
a1614 1
		 "Global symbol \"%s%s\" requires explicit package name",
d1618 1
a1618 1
		  : ""), name);
d1637 9
a1645 4
    gvp = (GV**)hv_fetch(stash,name,len,add);
    if (!gvp || *gvp == (const GV *)&PL_sv_undef)
	return NULL;
    gv = *gvp;
d1649 3
a1651 2
	    gv_init_sv(gv, sv_type);
	    if (len == 1 && (sv_type == SVt_PVHV || sv_type == SVt_PVGV)) {
d1656 9
d1666 4
d1673 1
d1676 1
d1690 3
a1692 3
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "Had to create %s unexpectedly", nambeg);
    gv_init(gv, stash, name, len, add & GV_ADDMULTI);
    gv_init_sv(gv, faking_it ? SVt_PVCV : sv_type);
d1694 2
a1695 2
    if (isALPHA(name[0]) && ! (isLEXWARN_on ? ckWARN(WARN_ONCE)
			                    : (PL_dowarn & G_WARN_ON ) ) )
d1699 37
a1735 1
    if (len > 1) {
d1762 1
a1762 19
		    AV* const av = GvAVn(gv);
		    GvMULTI_on(gv);
		    sv_magic(MUTABLE_SV(av), MUTABLE_SV(gv), PERL_MAGIC_isa,
			     NULL, 0);
		    /* NOTE: No support for tied ISA */
		    if ((add & GV_ADDMULTI) && strEQ(nambeg,"AnyDBM_File::ISA")
			&& AvFILLp(av) == -1)
			{
			    av_push(av, newSVpvs("NDBM_File"));
			    gv_stashpvs("NDBM_File", GV_ADD);
			    av_push(av, newSVpvs("DB_File"));
			    gv_stashpvs("DB_File", GV_ADD);
			    av_push(av, newSVpvs("GDBM_File"));
			    gv_stashpvs("GDBM_File", GV_ADD);
			    av_push(av, newSVpvs("SDBM_File"));
			    gv_stashpvs("SDBM_File", GV_ADD);
			    av_push(av, newSVpvs("ODBM_File"));
			    gv_stashpvs("ODBM_File", GV_ADD);
			}
d1767 1
a1767 3
		    HV* const hv = GvHVn(gv);
		    GvMULTI_on(gv);
		    hv_magic(hv, NULL, PERL_MAGIC_overload);
d1813 4
d1826 2
a1827 1
		    goto magicalize;  
d1859 1
a1859 1
		    if (!isDIGIT(*end))	return gv;
d1872 1
a1872 1
	    if (
d1878 1
a1878 2
		) { break; }
	    PL_sawampersand = TRUE;
d1899 3
d1903 1
d1920 3
d1924 1
d1931 1
d1945 9
a1967 1
	case '[':		/* $[ */
d1979 1
d2004 1
a2004 1
	    SV * const sv = GvSVn(gv);
d2014 1
a2014 1
	    SV * const sv = GvSVn(gv);
d2022 9
a2037 1
    STRLEN namelen;
a2041 4
    if (!hv) {
	SvOK_off(sv);
	return;
    }
d2044 4
a2047 10
    name = HvNAME_get(hv);
    if (name) {
	namelen = HvNAMELEN_get(hv);
    } else {
	name = "__ANON__";
	namelen = 8;
    }

    if (keepmain || strNE(name, "main")) {
	sv_catpvn(sv,name,namelen);
d2049 1
d2051 2
a2052 1
    sv_catpvn(sv,GvNAME(gv),GvNAMELEN(gv));
d2058 1
a2058 1
    const GV * const egv = GvEGV(gv);
d2086 2
a2087 1
	    else if (isALPHA(*HeKEY(entry))) {
d2101 4
a2104 2
			"Name \"%s::%s\" used only once: possible typo",
			HvNAME_get(stash), GvNAME(gv));
d2111 1
a2111 1
Perl_newGVgen(pTHX_ const char *pack)
d2114 1
d2116 5
a2120 4
    PERL_ARGS_ASSERT_NEWGVGEN;

    return gv_fetchpv(Perl_form(aTHX_ "%s::_GEN_%ld", pack, (long)PL_gensym++),
		      GV_ADD, SVt_PVGV);
d2150 1
d2163 1
a2163 1
	GvGP(gv) = 0;
d2167 53
a2219 16
    if (gp->gp_file_hek)
	unshare_hek(gp->gp_file_hek);
    SvREFCNT_dec(gp->gp_sv);
    SvREFCNT_dec(gp->gp_av);
    /* FIXME - another reference loop GV -> symtab -> GV ?
       Somehow gp->gp_hv can end up pointing at freed garbage.  */
    if (gp->gp_hv && SvTYPE(gp->gp_hv) == SVt_PVHV) {
	const char *hvname = HvNAME_get(gp->gp_hv);
	if (PL_stashcache && hvname)
	    (void)hv_delete(PL_stashcache, hvname, HvNAMELEN_get(gp->gp_hv),
		      G_DISCARD);
	SvREFCNT_dec(gp->gp_hv);
    }
    SvREFCNT_dec(gp->gp_io);
    SvREFCNT_dec(gp->gp_cv);
    SvREFCNT_dec(gp->gp_form);
d2222 1
a2222 1
    GvGP(gv) = 0;
d2289 1
a2289 1
    GV *gv = gv_fetchmeth(stash, PL_AMG_names[0], 2, -1);
d2323 1
a2323 1
	    gv = Perl_gv_fetchmeth_autoload(aTHX_ stash, cooky, l, 0);
d2325 1
a2325 1
	    gv = Perl_gv_fetchmeth(aTHX_ stash, cooky, l, -1);
d2328 4
a2331 3
	    const char *hvname;
	    if (GvNAMELEN(CvGV(cv)) == 3 && strEQ(GvNAME(CvGV(cv)), "nil")
		&& strEQ(hvname = HvNAME_get(GvSTASH(CvGV(cv))), "overload")) {
d2340 1
a2340 1
			     (void*)GvSV(gv), cp, hvname) );
d2342 1
a2342 2
		    || !(ngv = gv_fetchmethod_autoload(stash, SvPVX_const(gvsv),
						       FALSE)))
d2349 7
a2355 3
			const char * const name = (gvsv && SvPOK(gvsv)) ?  SvPVX_const(gvsv) : "???";
			Perl_croak(aTHX_ "%s method \"%.256s\" overloading \"%s\" "\
				    "in package \"%.256s\"",
d2358 4
a2361 1
				   name, cp, hvname);
d2365 1
d2417 1
a2417 1
	if (Gv_AMupdate(stash, id == DESTROY_amg) == -1) {
d2454 150
d2616 1
d2625 1
a2625 18
      SV *lex_mask = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,
					      0, "overloading", 11, 0, 0);

      if ( !lex_mask || !SvOK(lex_mask) )
	  /* overloading lexically disabled */
	  return NULL;
      else if ( lex_mask && SvPOK(lex_mask) ) {
	  /* we have an entry in the hints hash, check if method has been
	   * masked by overloading.pm */
	  STRLEN len;
	  const int offset = method / 8;
	  const int bit    = method % 8;
	  char *pv = SvPV(lex_mask, len);

	  /* Bit set, so this overloading operator is disabled */
	  if ( (STRLEN)offset < len && pv[offset] & ( 1 << bit ) )
	      return NULL;
      }
d2764 2
a2765 3
    } else if (((ocvp && oamtp->fallback > AMGfallNEVER
		 && (cvp=ocvp) && (lr = -1))
		|| (cvp && amtp->fallback > AMGfallNEVER && (lr=1)))
d2793 11
a2803 1
      if ((off != -1) && (cv = cvp[off]))
d2823 4
a2826 1
      } else if ((amtp && amtp->fallback >= AMGfallYES) && !DEBUG_o_TEST) {
d2833 19
a2851 19
		      "Operation \"%s\": no method found,%sargument %s%s%s%s",
		      AMG_id2name(method + assignshift),
		      (flags & AMGf_unary ? " " : "\n\tleft "),
		      SvAMAGIC(left)?
		        "in overloaded package ":
		        "has no overloaded magic",
		      SvAMAGIC(left)?
		        HvNAME_get(SvSTASH(SvRV(left))):
		        "",
		      SvAMAGIC(right)?
		        ",\n\tright argument in overloaded package ":
		        (flags & AMGf_unary
			 ? ""
			 : ",\n\tright argument has no overloaded magic"),
		      SvAMAGIC(right)?
		        HvNAME_get(SvSTASH(SvRV(right))):
		        ""));
	if (amtp && amtp->fallback >= AMGfallYES) {
	  DEBUG_o( Perl_deb(aTHX_ "%s", SvPVX_const(msg)) );
d2863 1
a2863 1
		     "Overloaded operator \"%s\"%s%s%s:\n\tmethod%s found%s in package %s%s\n",
d2873 1
a2873 1
		     stash ? HvNAME_get(stash) : "null",
d2899 1
a2899 1
  if (( (method + assignshift == off)
d2901 13
a2913 2
      || force_cpy)
    RvDEEPCP(left);
d2933 1
a2933 1
    pp_pushmark();
a2996 142
/*
=for apidoc is_gv_magical_sv

Returns C<TRUE> if given the name of a magical GV.

Currently only useful internally when determining if a GV should be
created even in rvalue contexts.

C<flags> is not used at present but available for future extension to
allow selecting particular classes of magical variable.

Currently assumes that C<name> is NUL terminated (as well as len being valid).
This assumption is met by all callers within the perl core, which all pass
pointers returned by SvPV.

=cut
*/

bool
Perl_is_gv_magical_sv(pTHX_ SV *const name_sv, U32 flags)
{
    STRLEN len;
    const char *const name = SvPV_const(name_sv, len);

    PERL_UNUSED_ARG(flags);
    PERL_ARGS_ASSERT_IS_GV_MAGICAL_SV;

    if (len > 1) {
	const char * const name1 = name + 1;
	switch (*name) {
	case 'I':
	    if (len == 3 && name[1] == 'S' && name[2] == 'A')
		goto yes;
	    break;
	case 'O':
	    if (len == 8 && strEQ(name1, "VERLOAD"))
		goto yes;
	    break;
	case 'S':
	    if (len == 3 && name[1] == 'I' && name[2] == 'G')
		goto yes;
	    break;
	    /* Using ${^...} variables is likely to be sufficiently rare that
	       it seems sensible to avoid the space hit of also checking the
	       length.  */
	case '\017':   /* ${^OPEN} */
	    if (strEQ(name1, "PEN"))
		goto yes;
	    break;
	case '\024':   /* ${^TAINT} */
	    if (strEQ(name1, "AINT"))
		goto yes;
	    break;
	case '\025':	/* ${^UNICODE} */
	    if (strEQ(name1, "NICODE"))
		goto yes;
	    if (strEQ(name1, "TF8LOCALE"))
		goto yes;
	    break;
	case '\027':   /* ${^WARNING_BITS} */
	    if (strEQ(name1, "ARNING_BITS"))
		goto yes;
	    break;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	{
	    const char *end = name + len;
	    while (--end > name) {
		if (!isDIGIT(*end))
		    return FALSE;
	    }
	    goto yes;
	}
	}
    } else {
	/* Because we're already assuming that name is NUL terminated
	   below, we can treat an empty name as "\0"  */
	switch (*name) {
	case '&':
	case '`':
	case '\'':
	case ':':
	case '?':
	case '!':
	case '-':
	case '#':
	case '[':
	case '^':
	case '~':
	case '=':
	case '%':
	case '.':
	case '(':
	case ')':
	case '<':
	case '>':
	case '\\':
	case '/':
	case '|':
	case '+':
	case ';':
	case ']':
	case '\001':   /* $^A */
	case '\003':   /* $^C */
	case '\004':   /* $^D */
	case '\005':   /* $^E */
	case '\006':   /* $^F */
	case '\010':   /* $^H */
	case '\011':   /* $^I, NOT \t in EBCDIC */
	case '\014':   /* $^L */
	case '\016':   /* $^N */
	case '\017':   /* $^O */
	case '\020':   /* $^P */
	case '\023':   /* $^S */
	case '\024':   /* $^T */
	case '\026':   /* $^V */
	case '\027':   /* $^W */
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	yes:
	    return TRUE;
	default:
	    break;
	}
    }
    return FALSE;
}

a3003 1
    PERL_UNUSED_ARG(flags);
d3013 1
a3013 1
    GvNAME_HEK(gv) = share_hek(name, len, hash);
d3044 5
d3050 1
a3050 1
	    !SvOBJECT(gv) && !SvMAGICAL(gv) && !SvREADONLY(gv) &&
d3054 1
a3054 1
	    GvEGV(gv) == gv && (stash = GvSTASH(gv))))
d3056 10
d3089 10
@


1.12
log
@Merge in perl 5.10.1
@
text
@a42 39

#ifdef PERL_DONT_CREATE_GVSV
GV *
Perl_gv_SVadd(pTHX_ GV *gv)
{
    PERL_ARGS_ASSERT_GV_SVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
	Perl_croak(aTHX_ "Bad symbol for scalar");
    if (!GvSV(gv))
	GvSV(gv) = newSV(0);
    return gv;
}
#endif

GV *
Perl_gv_AVadd(pTHX_ register GV *gv)
{
    PERL_ARGS_ASSERT_GV_AVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
	Perl_croak(aTHX_ "Bad symbol for array");
    if (!GvAV(gv))
	GvAV(gv) = newAV();
    return gv;
}

GV *
Perl_gv_HVadd(pTHX_ register GV *gv)
{
    PERL_ARGS_ASSERT_GV_HVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
	Perl_croak(aTHX_ "Bad symbol for hash");
    if (!GvHV(gv))
	GvHV(gv) = newHV();
    return gv;
}

d44 1
a44 1
Perl_gv_IOadd(pTHX_ register GV *gv)
d46 1
a46 3
    dVAR;

    PERL_ARGS_ASSERT_GV_IOADD;
d49 20
d70 8
a77 12
        /*
         * if it walks like a dirhandle, then let's assume that
         * this is a dirhandle.
         */
	const char * const fh =
			 PL_op->op_type ==  OP_READDIR ||
                         PL_op->op_type ==  OP_TELLDIR ||
                         PL_op->op_type ==  OP_SEEKDIR ||
                         PL_op->op_type ==  OP_REWINDDIR ||
                         PL_op->op_type ==  OP_CLOSEDIR ?
                         "dirhandle" : "filehandle";
        Perl_croak(aTHX_ "Bad symbol for %s", fh);
d80 2
a81 8
    if (!GvIOp(gv)) {
#ifdef GV_UNIQUE_CHECK
        if (GvUNIQUE(gv)) {
            Perl_croak(aTHX_ "Bad symbol for filehandle (GV is unique)");
        }
#endif
	GvIOp(gv) = newIO();
    }
d278 1
a278 1
S_gv_init_sv(pTHX_ GV *gv, I32 sv_type)
d416 2
a417 3
            if (ckWARN(WARN_SYNTAX))
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Can't locate package %"SVf" for @@%s::ISA",
                    SVfARG(linear_sv), hvname);
d572 4
a575 2
/* FIXME. If changing this function note the comment in pp_hot's
   S_method_common:
d577 2
a578 7
   This code tries to figure out just what went wrong with
   gv_fetchmethod.  It therefore needs to duplicate a lot of
   the internals of that function. ...

   I'd guess that with one more flag bit that could all be moved inside
   here.
*/
d580 2
d583 1
a583 1
Perl_gv_fetchmethod_autoload(pTHX_ HV *stash, const char *name, I32 autoload)
d591 3
d595 1
a595 1
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD;
d597 1
a597 1
    if (stash && SvTYPE(stash) < SVt_PVHV)
d599 5
d645 25
a730 1
	&& ckWARN2(WARN_DEPRECATED, WARN_SYNTAX)
d732 3
a734 3
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
	  "Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated",
	     packname, (int)len, name);
d856 1
d860 1
a860 1
    if (namelen + 2 <= sizeof smallbuf)
d863 5
a867 5
	Newx(tmpbuf, namelen + 2, char);
    Copy(name,tmpbuf,namelen,char);
    tmpbuf[namelen++] = ':';
    tmpbuf[namelen++] = ':';
    tmpgv = gv_fetchpvn_flags(tmpbuf, namelen, flags, SVt_PVHV);
d901 1
a901 1
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, I32 sv_type) {
d907 1
a907 1
Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, I32 sv_type) {
d916 1
a916 1
		       I32 sv_type)
d1063 1
d1140 2
a1141 2
    if (add & GV_ADDWARN && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Had to create %s unexpectedly", nambeg);
d1209 2
a1210 3
		    if (!PL_psig_ptr) {
			Newxz(PL_psig_ptr,  SIG_SIZE, SV*);
			Newxz(PL_psig_name, SIG_SIZE, SV*);
d1212 13
a1232 3
			PL_psig_ptr[i] = 0;
			PL_psig_name[i] = 0;
			PL_psig_pend[i] = 0;
d1299 3
a1301 3
	case '&':
	case '`':
	case '\'':
d1312 1
a1312 1
	case ':':
d1316 1
a1316 1
	case '?':
d1322 1
a1322 1
	case '!':
d1333 2
a1334 2
	case '-':
	case '+':
d1351 5
a1355 5
	case '*':
	case '#':
	    if (sv_type == SVt_PV && ckWARN2_d(WARN_DEPRECATED, WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			    "$%c is no longer supported", *name);
d1357 1
a1357 1
	case '|':
d1371 22
a1392 22
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case '[':
	case '^':
	case '~':
	case '=':
	case '%':
	case '.':
	case '(':
	case ')':
	case '<':
	case '>':
	case ',':
	case '\\':
	case '/':
d1412 1
a1412 1
	case ';':
d1415 1
a1415 1
	case ']':
a1477 21
IO *
Perl_newIO(pTHX)
{
    dVAR;
    GV *iogv;
    IO * const io = MUTABLE_IO(newSV_type(SVt_PVIO));
    /* This used to read SvREFCNT(io) = 1;
       It's not clear why the reference count needed an explicit reset. NWC
    */
    assert (SvREFCNT(io) == 1);
    SvOBJECT_on(io);
    /* Clear the stashcache because a new IO could overrule a package name */
    hv_clear(PL_stashcache);
    iogv = gv_fetchpvs("FileHandle::", 0, SVt_PVHV);
    /* unless exists($main::{FileHandle}) and defined(%main::FileHandle::) */
    if (!(iogv && GvHV(iogv) && HvARRAY(GvHV(iogv))))
      iogv = gv_fetchpvs("IO::Handle::", GV_ADD, SVt_PVHV);
    SvSTASH_set(io, MUTABLE_HV(SvREFCNT_inc(GvHV(iogv))));
    return io;
}

d1562 3
a1564 4
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
			"Attempt to free unreferenced glob pointers"
                        pTHX__FORMAT pTHX__VALUE);
d1617 5
d1623 2
a1624 2
bool
Perl_Gv_AMupdate(pTHX_ HV *stash)
d1639 1
a1639 1
	  return (bool)AMT_OVERLOADED(amtp);
d1715 11
a1725 6
		    const char * const name = (gvsv && SvPOK(gvsv)) ?  SvPVX_const(gvsv) : "???";
		    Perl_croak(aTHX_ "%s method \"%.256s\" overloading \"%s\" "\
				"in package \"%.256s\"",
			       (GvCVGEN(gv) ? "Stub found while resolving"
				: "Can't resolve"),
			       name, cp, hvname);
d1755 1
a1755 1
  return FALSE;
d1777 13
a1789 1
	Gv_AMupdate(stash);
d1905 2
a1906 1
           postpr = 1;
d1966 2
d2011 2
a2012 1
	   postpr = 1; off=ncmp_amg; break;
d2019 2
a2020 1
	   postpr = 1; off=scmp_amg; break;
d2022 4
a2025 4
      if (off != -1) cv = cvp[off];
      if (!cv) {
	goto not_found;
      }
a2028 13
	 case lt_amg:
	 case le_amg:
	 case gt_amg:
	 case ge_amg:
	 case eq_amg:
	 case ne_amg:
	 case slt_amg:
	 case sle_amg:
	 case sgt_amg:
	 case sge_amg:
	 case seq_amg:
	 case sne_amg:
	   postpr = 0; break;
a2204 19
Returns C<TRUE> if given the name of a magical GV. Calls is_gv_magical.

=cut
*/

bool
Perl_is_gv_magical_sv(pTHX_ SV *name, U32 flags)
{
    STRLEN len;
    const char * const temp = SvPV_const(name, len);

    PERL_ARGS_ASSERT_IS_GV_MAGICAL_SV;

    return is_gv_magical(temp, len, flags);
}

/*
=for apidoc is_gv_magical

d2219 1
d2221 1
a2221 1
Perl_is_gv_magical(pTHX_ const char *name, STRLEN len, U32 flags)
d2223 3
a2225 1
    PERL_UNUSED_CONTEXT;
d2227 1
a2227 2

    PERL_ARGS_ASSERT_IS_GV_MAGICAL;
a2304 1
	case ',':
d2362 60
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d13 1
a13 1
 * of your inquisitiveness, I shall spend all the rest of my days answering
d18 2
d48 3
a50 1
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV)
d61 3
a63 1
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV)
d73 3
a75 1
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV)
d86 4
a89 1
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV) {
d119 1
d133 1
d155 1
a155 1
	if (PERLDB_LINE)
d177 2
d198 2
d238 1
d261 1
a261 1
	sv_upgrade((SV*)gv, SVt_PVGV);
d277 1
a277 1
	Perl_sv_add_backref(aTHX_ (SV*)stash, (SV*)gv);
d302 1
a302 1
	    sv_usepvn_flags((SV*)GvCV(gv), proto, protolen,
d311 2
d381 2
d517 2
d525 1
a525 1
	if (len == S_autolen && strnEQ(name, S_autoload, S_autolen))
d579 2
d593 1
a593 1
    sv_magic((SV*)superisa, (SV*)gv, PERL_MAGIC_isa, NULL, 0);
d623 3
d631 1
a631 1
	if (*nend == '\'')
d633 6
a638 2
	else if (*nend == ':' && *(nend + 1) == ':')
	    nsplit = ++nend;
d641 1
a641 5
	const char * const origname = name;
	name = nsplit + 1;
	if (*nsplit == ':')
	    --nsplit;
	if ((nsplit - origname) == 5 && strnEQ(origname, "SUPER", 5)) {
d667 1
a667 1
	    gv = (GV*)&PL_sv_yes;
d706 3
a708 1
    if (len == S_autolen && strnEQ(name, S_autoload, S_autolen))
d712 1
a712 1
	    packname = SvPV_const((SV*)stash, packname_len);
d792 2
d832 1
d858 2
d893 3
d902 1
d910 1
d932 2
d969 1
a969 1
		if (gv && gv != (GV*)&PL_sv_undef) {
d977 1
a977 1
		if (!gv || gv == (GV*)&PL_sv_undef)
d992 2
a993 1
		return gv ? gv : (GV*)*hv_fetchs(PL_defstash, "main::", TRUE);
d1054 1
a1054 1
			*gvp == (GV*)&PL_sv_undef ||
d1094 1
a1094 1
	    gv = gv_fetchpvn_flags("<none>::", 8, GV_ADDMULTI, SVt_PVHV);
d1109 1
a1109 1
    if (!gvp || *gvp == (GV*)&PL_sv_undef)
d1178 2
a1179 1
		    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, NULL, 0);
d1184 10
a1193 11
			    const char *pname;
			    av_push(av, newSVpvn(pname = "NDBM_File",9));
			    gv_stashpvn(pname, 9, GV_ADD);
			    av_push(av, newSVpvn(pname = "DB_File",7));
			    gv_stashpvn(pname, 7, GV_ADD);
			    av_push(av, newSVpvn(pname = "GDBM_File",9));
			    gv_stashpvn(pname, 9, GV_ADD);
			    av_push(av, newSVpvn(pname = "SDBM_File",9));
			    gv_stashpvn(pname, 9, GV_ADD);
			    av_push(av, newSVpvn(pname = "ODBM_File",9));
			    gv_stashpvn(pname, 9, GV_ADD);
d1316 1
a1316 1
	    sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
d1328 1
a1328 1
	    SV* const avc = (*name == '+') ? (SV*)av : NULL;
d1330 2
a1331 2
	    sv_magic((SV*)av, avc, PERL_MAGIC_regdata, NULL, 0);
            sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
d1395 1
a1395 1
	    sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
d1399 1
a1399 1
	    sv_setpvn(GvSVn(gv),"\f",1);
d1403 1
a1403 1
	    sv_setpvn(GvSVn(gv),"\034",1);
d1434 3
d1462 3
d1473 1
a1473 1
    IO * const io = (IO*)newSV_type(SVt_PVIO);
d1485 1
a1485 1
    SvSTASH_set(io, (HV*)SvREFCNT_inc(GvHV(iogv)));
d1495 2
d1505 1
a1505 1
		(gv = (GV*)HeVAL(entry)) && isGV(gv) && (hv = GvHV(gv)))
d1512 1
a1512 1
		gv = (GV*)HeVAL(entry);
d1535 3
d1613 2
d1620 1
a1620 1
		SvREFCNT_dec((SV *) cv);
d1634 1
a1634 1
  MAGIC* const mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
d1639 2
d1648 1
a1648 1
      sv_unmagic((SV*)stash, PERL_MAGIC_overload_table);
d1738 1
a1738 1
	    cv = (CV*)gv;
d1741 1
a1741 1
	amt.table[i]=(CV*)SvREFCNT_inc_simple(cv);
d1747 1
a1747 1
      sv_magic((SV*)stash, 0, PERL_MAGIC_overload_table,
d1755 1
a1755 1
  sv_magic((SV*)stash, 0, PERL_MAGIC_overload_table,
d1776 1
a1776 1
    mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
d1780 1
a1780 1
	mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
d1822 24
d1848 1
a1848 1
      && (mg = mg_find((SV*)stash, PERL_MAGIC_overload_table))
d1917 1
a1917 1
		SvSTASH_set(newref, (HV*)SvREFCNT_inc(SvSTASH(tmpRef)));
d1972 1
a1972 1
	       && (mg = mg_find((SV*)stash, PERL_MAGIC_overload_table))
d2143 2
a2144 2
      PUSHs( sv_2mortal(newSVpvn(AMG_id2name(method + assignshift),
				 AMG_id2namelen(method + assignshift))));
d2146 1
a2146 1
    PUSHs((SV*)cv);
d2149 1
a2149 1
    if ((PL_op = Perl_pp_entersub(aTHX)))
d2213 3
d2242 2
d2248 1
a2248 1
	    if (len == 3 && name1[1] == 'S' && name[2] == 'A')
d2366 1
a2366 1
    assert(name);
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d36 1
d38 2
a39 2
const char S_autoload[] = "AUTOLOAD";
const STRLEN S_autolen = sizeof(S_autoload)-1;
d49 1
a49 1
	GvSV(gv) = NEWSV(72,0);
d77 17
a93 2
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV)
	Perl_croak(aTHX_ "Bad symbol for filehandle");
d108 9
a116 1
    char smallbuf[256];
d118 1
a118 1
    STRLEN tmplen;
d121 2
d124 1
a124 1
	return Nullgv;
d126 1
a126 2
    tmplen = strlen(name) + 2;
    if (tmplen < sizeof smallbuf)
d129 1
a129 1
	Newx(tmpbuf, tmplen + 1, char);
d133 1
a133 1
    memcpy(tmpbuf + 2, name, tmplen - 1);
d138 1
a138 1
	GvSV(gv) = newSVpvn(name, tmplen - 2);
d140 1
a140 1
	sv_setpvn(GvSV(gv), name, tmplen - 2);
d143 1
a143 1
	    hv_magic(GvHVn(gv_AVadd(gv)), Nullgv, PERL_MAGIC_dbfile);
d150 60
d213 26
a238 3
    register GP *gp;
    const bool doproto = SvTYPE(gv) > SVt_NULL;
    const char * const proto = (doproto && SvPOK(gv)) ? SvPVX_const(gv) : NULL;
d240 5
a244 1
    sv_upgrade((SV*)gv, SVt_PVGV);
d253 8
a260 17
    Newxz(gp, 1, GP);
    GvGP(gv) = gp_ref(gp);
#ifdef PERL_DONT_CREATE_GVSV
    GvSV(gv) = 0;
#else
    GvSV(gv) = NEWSV(72,0);
#endif
    GvLINE(gv) = CopLINE(PL_curcop);
    /* XXX Ideally this cast would be replaced with a change to const char*
       in the struct.  */
    GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : (char *) "";
    GvCVGEN(gv) = 0;
    GvEGV(gv) = gv;
    sv_magic((SV*)gv, (SV*)gv, PERL_MAGIC_glob, Nullch, 0);
    GvSTASH(gv) = (HV*)SvREFCNT_inc(stash);
    GvNAME(gv) = savepvn(name, len);
    GvNAMELEN(gv) = len;
a263 1
	SvIOK_off(gv);
d265 12
a276 3
	/* XXX unsafe for threads if eval_owner isn't held */
	(void) start_subparse(0,0);	/* Create empty CV in compcv. */
	GvCV(gv) = PL_compcv;
d279 1
a279 1
	PL_sub_generation++;
a282 7
#ifdef USE_5005THREADS
	CvOWNER(GvCV(gv)) = 0;
	if (!CvMUTEXP(GvCV(gv))) {
	    New(666, CvMUTEXP(GvCV(gv)), 1, perl_mutex);
	    MUTEX_INIT(CvMUTEXP(GvCV(gv)));
	}
#endif /* USE_5005THREADS */
d284 2
a285 2
	    sv_setpv((SV*)GvCV(gv), proto);
	    Safefree(proto);
d307 1
d310 5
a314 1
	(void)GvSVn(gv);
d329 1
a329 1
up caching info for this glob.  Similarly for all the searched stashes.
d340 2
d345 1
a345 3
    AV* av;
    GV* topgv;
    GV* gv;
d347 8
a354 1
    CV* cv;
d356 4
d363 2
a364 2
	level = -1;  /* probably appropriate */
	if(!(stash = gv_stashpvn("UNIVERSAL", 9, FALSE)))
d368 2
d372 1
a372 2
      Perl_croak(aTHX_
		 "Can't use anonymous symbol table for method lookup");
d374 2
a375 3
    if ((level > 100) || (level < -100))
	Perl_croak(aTHX_ "Recursive inheritance detected while looking for method '%s' in package '%s'",
	      name, hvname);
d379 34
a412 3
    gvp = (GV**)hv_fetch(stash, name, len, (level >= 0));
    if (!gvp)
	topgv = Nullgv;
d414 1
a414 39
	topgv = *gvp;
	if (SvTYPE(topgv) != SVt_PVGV)
	    gv_init(topgv, stash, name, len, TRUE);
	if ((cv = GvCV(topgv))) {
	    /* If genuine method or valid cache entry, use it */
	    if (!GvCVGEN(topgv) || GvCVGEN(topgv) == PL_sub_generation)
		return topgv;
	    /* Stale cached entry: junk it */
	    SvREFCNT_dec(cv);
	    GvCV(topgv) = cv = Nullcv;
	    GvCVGEN(topgv) = 0;
	}
	else if (GvCVGEN(topgv) == PL_sub_generation)
	    return 0;  /* cache indicates sub doesn't exist */
    }

    gvp = (GV**)hv_fetch(stash, "ISA", 3, FALSE);
    av = (gvp && (gv = *gvp) && gv != (GV*)&PL_sv_undef) ? GvAV(gv) : Nullav;

    /* create and re-create @@.*::SUPER::ISA on demand */
    if (!av || !SvMAGIC(av)) {
	STRLEN packlen = strlen(hvname);

	if (packlen >= 7 && strEQ(hvname + packlen - 7, "::SUPER")) {
	    HV* basestash;

	    packlen -= 7;
	    basestash = gv_stashpvn(hvname, packlen, TRUE);
	    gvp = (GV**)hv_fetch(basestash, "ISA", 3, FALSE);
	    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (av = GvAV(gv))) {
		gvp = (GV**)hv_fetch(stash, "ISA", 3, TRUE);
		if (!gvp || !(gv = *gvp))
		    Perl_croak(aTHX_ "Cannot create %s::ISA", hvname);
		if (SvTYPE(gv) != SVt_PVGV)
		    gv_init(gv, stash, "ISA", 3, TRUE);
		SvREFCNT_dec(GvAV(gv));
		GvAV(gv) = (AV*)SvREFCNT_inc(av);
	    }
	}
d417 35
a451 18
    if (av) {
	SV** svp = AvARRAY(av);
	/* NOTE: No support for tied ISA */
	I32 items = AvFILLp(av) + 1;
	while (items--) {
	    SV* const sv = *svp++;
	    HV* const basestash = gv_stashsv(sv, FALSE);
	    if (!basestash) {
		if (ckWARN(WARN_MISC))
		    Perl_warner(aTHX_ packWARN(WARN_MISC), "Can't locate package %"SVf" for @@%s::ISA",
			sv, hvname);
		continue;
	    }
	    gv = gv_fetchmeth(basestash, name, len,
			      (level >= 0) ? level + 1 : level - 1);
	    if (gv)
		goto gotcha;
	}
d454 14
a467 4
    /* if at top level, try UNIVERSAL */

    if (level == 0 || level == -1) {
	HV* const lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE);
d469 3
a471 27
	if (lastchance) {
	    if ((gv = gv_fetchmeth(lastchance, name, len,
				  (level >= 0) ? level + 1 : level - 1)))
	    {
	  gotcha:
		/*
		 * Cache method in topgv if:
		 *  1. topgv has no synonyms (else inheritance crosses wires)
		 *  2. method isn't a stub (else AUTOLOAD fails spectacularly)
		 */
		if (topgv &&
		    GvREFCNT(topgv) == 1 &&
		    (cv = GvCV(gv)) &&
		    (CvROOT(cv) || CvXSUB(cv)))
		{
		    if ((cv = GvCV(topgv)))
			SvREFCNT_dec(cv);
		    GvCV(topgv) = (CV*)SvREFCNT_inc(GvCV(gv));
		    GvCVGEN(topgv) = PL_sub_generation;
		}
		return gv;
	    }
	    else if (topgv && GvREFCNT(topgv) == 1) {
		/* cache the fact that the method is not defined */
		GvCVGEN(topgv) = PL_sub_generation;
	    }
	}
d500 1
a500 1
	    return Nullgv;	/* UNIVERSAL::AUTOLOAD could cause trouble */
d502 1
a502 1
	    return Nullgv;
d504 1
a504 1
	    return Nullgv;
d507 1
a507 1
	    return Nullgv;
d513 1
a513 1
	    return Nullgv;
a519 14
=for apidoc gv_fetchmethod

See L<gv_fetchmethod_autoload>.

=cut
*/

GV *
Perl_gv_fetchmethod(pTHX_ HV *stash, const char *name)
{
    return gv_fetchmethod_autoload(stash, name, TRUE);
}

/*
d547 42
d592 1
d594 1
a594 1
    const char *nsplit = 0;
d599 1
a599 1
	stash = Nullhv;
d614 1
a614 1
	    SV *tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_ "%s::SUPER",
d617 1
a617 1
	    stash = gv_stashpvn(SvPVX_const(tmpstr), SvCUR(tmpstr), TRUE);
d623 1
a623 1
            stash = gv_stashpvn(origname, nsplit - origname, FALSE);
d629 2
a630 2
		gv_stashpvn(origname, nsplit - origname - 7, FALSE))
	      stash = gv_stashpvn(origname, nsplit - origname, TRUE);
d668 1
d675 1
d678 1
a678 1
	return Nullgv;
d681 2
a682 2
	    packname = SvPV_nolen_const((SV*)stash);
	    stash = Nullhv;
d686 1
d690 1
a690 1
	return Nullgv;
d694 1
a694 1
	return Nullgv;
d706 1
a706 2
#ifndef USE_5005THREADS
    if (CvXSUB(cv)) {
a716 1
#endif
a727 3
#ifdef USE_5005THREADS
    sv_lock((SV *)varstash);
#endif
d731 1
a731 1
	GvSV(vargv) = NEWSV(72,0);
d736 2
a737 5
#ifdef USE_5005THREADS
    sv_lock(varsv);
#endif
    sv_setpv(varsv, packname);
    sv_catpvn(varsv, "::", 2);
a738 1
    SvTAINTED_off(varsv);
d742 12
a753 2
/* The "gv" parameter should be the glob known to Perl code as *!
 * The scalar must already have been magicalized.
d755 2
a756 2
STATIC void
S_require_errno(pTHX_ GV *gv)
d758 2
a759 1
    HV* stash = gv_stashpvn("Errno",5,FALSE);
d761 5
a765 1
    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
a766 1
	PUTBACK;
d768 5
a772 3
	save_scalar(gv); /* keep the value of $! */
        Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
                         newSVpvn("Errno",5), Nullsv);
d775 7
a781 3
	stash = gv_stashpvn("Errno",5,FALSE);
	if (!stash || !(gv_fetchmethod(stash, "TIEHASH")))
	    Perl_croak(aTHX_ "Can't use %%! because Errno.pm is not available");
d783 2
d790 2
a791 4
Returns a pointer to the stash for a specified package.  C<name> should
be a valid UTF-8 string and must be null-terminated.  If C<create> is set
then the package will be created if it does not already exist.  If C<create>
is not set and the package does not exist then NULL is returned.
d805 7
a811 5
Returns a pointer to the stash for a specified package.  C<name> should
be a valid UTF-8 string.  The C<namelen> parameter indicates the length of
the C<name>, in bytes.  If C<create> is set then the package will be
created if it does not already exist.  If C<create> is not set and the
package does not exist then NULL is returned.
d817 1
a817 1
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 create)
d819 1
a819 1
    char smallbuf[256];
d824 1
a824 1
    if (namelen + 3 < sizeof smallbuf)
d827 1
a827 1
	Newx(tmpbuf, namelen + 3, char);
d831 1
a831 2
    tmpbuf[namelen] = '\0';
    tmpgv = gv_fetchpv(tmpbuf, create, SVt_PVHV);
d835 1
a835 1
	return 0;
d847 1
a847 2
Returns a pointer to the stash for a specified package, which must be a
valid UTF-8 string.  See C<gv_stashpv>.
d853 1
a853 1
Perl_gv_stashsv(pTHX_ SV *sv, I32 create)
d857 7
a863 1
    return gv_stashpvn(ptr, len, create);
d866 6
d874 2
a875 1
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, I32 sv_type)
d877 1
d879 1
a879 1
    register GV *gv = 0;
d882 14
a895 2
    register const char *namend;
    HV *stash = 0;
d897 2
a898 1
    if (*name == '*' && isALPHA(name[1])) /* accidental stringify on a GV? */
d900 1
d902 4
a905 3
    for (namend = name; *namend; namend++) {
	if ((*namend == ':' && namend[1] == ':')
	    || (*namend == '\'' && namend[1]))
d910 1
a910 1
		return Nullgv;
d912 1
a912 1
	    len = namend - name;
d914 1
a914 1
		char smallbuf[256];
d917 1
a917 1
		if (len + 3 < sizeof (smallbuf))
d920 1
a920 1
		    Newx(tmpbuf, len+3, char);
a923 1
		tmpbuf[len] = '\0';
d925 1
a925 1
		gv = gvp ? *gvp : Nullgv;
d935 1
a935 1
		    return Nullgv;
d941 1
a941 1
		    hv_name_set(stash, nambeg, namend - nambeg, 0);
d944 6
a949 6
	    if (*namend == ':')
		namend++;
	    namend++;
	    name = namend;
	    if (!*name)
		return gv ? gv : (GV*)*hv_fetch(PL_defstash, "main::", 6, TRUE);
d952 1
a952 1
    len = namend - name;
d957 2
a958 1
	if (isIDFIRST_lazy(name)) {
d961 2
a962 4
	    /* name is always \0 terminated, and initial \0 wouldn't return
	       true from isIDFIRST_lazy, so we know that name[1] is defined  */
	    switch (name[1]) {
	    case '\0':
d966 9
a974 2
	    case 'N':
		if (strEQ(name, "INC") || strEQ(name, "ENV"))
d977 3
a979 2
	    case 'I':
		if (strEQ(name, "SIG"))
d982 4
a985 3
	    case 'T':
		if (strEQ(name, "STDIN") || strEQ(name, "STDOUT") ||
		    strEQ(name, "STDERR"))
d988 4
a991 2
	    case 'R':
		if (strEQ(name, "ARGV") || strEQ(name, "ARGVOUT"))
d1013 1
a1013 1
			stash = 0;
d1025 1
a1025 1
			stash = 0;
d1046 1
d1050 6
a1055 1
	    stash = PL_nullstash;
d1058 1
a1058 1
	    return Nullgv;
d1062 1
a1062 1
	return Nullgv;
d1066 1
a1066 1
	return Nullgv;
d1072 6
a1077 2
	    if (*name=='!' && sv_type == SVt_PVHV && len==1)
		require_errno(gv);
d1080 3
a1082 1
    } else if (add & GV_NOINIT) {
d1086 8
a1093 1
    /* Adding a new symbol */
d1098 1
a1098 1
    gv_init_sv(gv, sv_type);
d1108 1
d1122 3
d1134 1
a1134 1
		    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, Nullch, 0);
d1141 1
a1141 1
			    gv_stashpvn(pname, 9, TRUE);
d1143 1
a1143 1
			    gv_stashpvn(pname, 7, TRUE);
d1145 1
a1145 1
			    gv_stashpvn(pname, 9, TRUE);
d1147 1
a1147 1
			    gv_stashpvn(pname, 9, TRUE);
d1149 1
a1149 1
			    gv_stashpvn(pname, 9, TRUE);
d1157 1
a1157 1
		    hv_magic(hv, Nullgv, PERL_MAGIC_overload);
d1171 1
a1171 1
		    hv_magic(hv, Nullgv, PERL_MAGIC_sig);
d1186 4
d1194 3
d1201 3
d1213 2
d1230 3
a1232 3
		/* ensures variable is only digits */
		/* ${"1foo"} fails this test (and is thus writeable) */
		/* added by japhy, but borrowed from is_gv_magical */
d1235 1
a1235 1
		    if (!isDIGIT(*end)) return gv;
d1237 1
a1237 1
		goto ro_magicalize;
d1256 1
a1256 1
	    goto ro_magicalize;
d1263 3
a1265 1
	    (void)SvUPGRADE(GvSVn(gv), SVt_PVLV);
d1269 2
a1270 6

	    /* If %! has been used, automatically load Errno.pm.
	       The require will itself set errno, so in order to
	       preserve its value we have to set up the magic
	       now (rather than going to magicalize)
	    */
d1274 3
a1276 2
	    if (sv_type == SVt_PVHV)
		require_errno(gv);
d1280 16
a1295 5
	{
	    AV* const av = GvAVn(gv);
            sv_magic((SV*)av, Nullsv, PERL_MAGIC_regdata, Nullch, 0);
	    SvREADONLY_on(av);
	    goto magicalize;
d1297 1
d1299 1
a1299 2
	case '*':
	    if (sv_type == SVt_PV && ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
d1301 2
a1302 2
			    "Use of $%s is deprecated", name);
	    goto magicalize;
d1307 9
a1315 5
	case '+':
	{
	    AV* const av = GvAVn(gv);
            sv_magic((SV*)av, (SV*)av, PERL_MAGIC_regdata, Nullch, 0);
	    SvREADONLY_on(av);
a1316 2
	}
	case '\023':	/* $^S */
a1325 3
	ro_magicalize:
	    SvREADONLY_on(GvSVn(gv));
	    /* FALL THROUGH */
a1343 1
	case '\010':	/* $^H */
d1364 5
a1368 12
	    (void)SvUPGRADE(sv, SVt_PVNV);
	    Perl_sv_setpvf(aTHX_ sv,
#if defined(PERL_SUBVERSION) && (PERL_SUBVERSION > 0)
			    "%8.6"
#else
			    "%5.3"
#endif
			    NVff,
			    SvNVX(PL_patchlevel));
	    SvNVX(sv) = SvNVX(PL_patchlevel);
	    SvNOK_on(sv);
	    SvREADONLY_on(sv);
d1374 2
a1375 1
	    GvSV(gv) = SvREFCNT_inc(PL_patchlevel);
d1385 1
a1385 1
Perl_gv_fullname4(pTHX_ SV *sv, GV *gv, const char *prefix, bool keepmain)
d1388 1
d1397 3
a1399 1
    if (!name)
d1401 2
d1405 2
a1406 2
	sv_catpv(sv,name);
	sv_catpvn(sv,"::", 2);
d1412 1
a1412 7
Perl_gv_fullname3(pTHX_ SV *sv, GV *gv, const char *prefix)
{
    gv_fullname4(sv, gv, prefix, TRUE);
}

void
Perl_gv_efullname4(pTHX_ SV *sv, GV *gv, const char *prefix, bool keepmain)
d1415 1
a1415 21
    gv_fullname4(sv, (GV *) (egv ? egv : gv), prefix, keepmain);
}

void
Perl_gv_efullname3(pTHX_ SV *sv, GV *gv, const char *prefix)
{
    gv_efullname4(sv, gv, prefix, TRUE);
}

/* compatibility with versions <= 5.003. */
void
Perl_gv_fullname(pTHX_ SV *sv, GV *gv)
{
    gv_fullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
}

/* compatibility with versions <= 5.003. */
void
Perl_gv_efullname(pTHX_ SV *sv, GV *gv)
{
    gv_efullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
d1421 1
d1423 1
a1423 3
    IO * const io = (IO*)NEWSV(0,0);

    sv_upgrade((SV *)io,SVt_PVIO);
d1431 1
a1431 1
    iogv = gv_fetchpv("FileHandle::", FALSE, SVt_PVHV);
d1434 1
a1434 1
      iogv = gv_fetchpv("IO::Handle::", TRUE, SVt_PVHV);
d1440 1
a1440 1
Perl_gv_check(pTHX_ HV *stash)
d1442 1
a1463 13
		/* performance hack: if filename is absolute and it's a standard
		 * module, don't bother warning */
#ifdef MACOS_TRADITIONAL
#   define LIB_COMPONENT ":lib:"
#else
#   define LIB_COMPONENT "/lib/"
#endif
		if (file
		    && PERL_FILE_IS_ABSOLUTE(file)
		    && (instr(file, LIB_COMPONENT) || instr(file, ".pm")))
		{
		    continue;
		}
d1468 2
a1469 1
		CopFILEGV(PL_curcop) = gv_fetchfile(file);
d1480 1
a1480 1
Perl_newGVgen(pTHX_ char *pack)
d1482 1
d1484 1
a1484 1
		      TRUE, SVt_PVGV);
d1492 1
d1494 1
a1494 1
	return (GP*)NULL;
d1498 3
a1500 1
	    /* multi-named GPs cannot be used for method cache */
d1502 1
a1502 1
	    gp->gp_cv = Nullcv;
a1504 4
	else {
	    /* Adding a new name to a subroutine invalidates method cache */
	    PL_sub_generation++;
	}
d1512 1
d1515 1
a1515 1
    if (!gv || !(gp = GvGP(gv)))
a1523 4
    if (gp->gp_cv) {
	/* Deleting the name of a subroutine invalidates method cache */
	PL_sub_generation++;
    }
d1527 1
d1531 4
a1534 2
    if (gp->gp_sv) SvREFCNT_dec(gp->gp_sv);
    if (gp->gp_av) SvREFCNT_dec(gp->gp_av);
a1537 1
	/* FIXME strlen HvNAME  */
d1540 2
a1541 1
	    hv_delete(PL_stashcache, hvname, strlen(hvname), G_DISCARD);
d1544 3
a1546 3
    if (gp->gp_io)   SvREFCNT_dec(gp->gp_io);
    if (gp->gp_cv)   SvREFCNT_dec(gp->gp_cv);
    if (gp->gp_form) SvREFCNT_dec(gp->gp_form);
d1562 1
a1562 1
	    if (cv != Nullcv) {
d1564 1
a1564 1
		amtp->table[i] = Nullcv;
d1576 1
a1577 1
  AMT * const amtp = (mg) ? (AMT*)mg->mg_ptr: (AMT *) NULL;
d1579 2
d1582 9
a1590 4
  if (mg && amtp->was_ok_am == PL_amagic_generation
      && amtp->was_ok_sub == PL_sub_generation)
      return (bool)AMT_OVERLOADED(amtp);
  sv_unmagic((SV*)stash, PERL_MAGIC_overload_table);
d1596 1
a1596 1
  amt.was_ok_sub = PL_sub_generation;
d1615 1
a1615 1
	/* Equivalent to !SvTRUE and !SvOK  */
d1624 1
a1624 1
	amt.table[i] = Nullcv;
d1626 1
a1626 1
	const char *cooky = PL_AMG_names[i];
d1628 2
a1629 2
	const char *cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
	const STRLEN l = strlen(cooky);
d1652 1
a1652 1
		GV *ngv = Nullgv;
d1657 1
a1657 1
			     GvSV(gv), cp, hvname) );
d1682 1
a1682 1
	amt.table[i]=(CV*)SvREFCNT_inc(cv);
d1705 1
d1708 2
d1712 5
a1716 1
        return Nullcv;
d1723 1
d1726 1
a1726 1
	 || amtp->was_ok_sub != PL_sub_generation )
d1743 1
a1743 1
    return Nullcv;
d1750 1
d1768 1
a1768 1
			: (CV **) NULL))
d1828 6
d1892 1
a1892 1
			  : (CV **) NULL))
d1931 13
d1957 3
d1984 1
a1984 1
	  Perl_croak(aTHX_ "%"SVf, msg);
d2043 1
a2043 1
    myop.op_next = Nullop;
d2060 2
a2061 1
      PUSHs( sv_2mortal(newSVpv(AMG_id2name(method + assignshift),0)));
d2118 16
d2151 1
a2151 1
Perl_is_gv_magical(pTHX_ char *name, STRLEN len, U32 flags)
d2153 1
a2220 1
	case '*':
d2270 20
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d37 16
d104 1
a104 1
	New(603, tmpbuf, tmplen + 1, char);
d108 1
a108 1
    strcpy(tmpbuf + 2, name);
d112 5
a116 1
	sv_setpv(GvSV(gv), name);
d129 2
a130 2
    bool doproto = SvTYPE(gv) > SVt_NULL;
    char *proto = (doproto && SvPOK(gv)) ? SvPVX(gv) : NULL;
d135 2
a136 2
	    SvPVX(gv) = NULL;
	    SvLEN(gv) = 0;
d139 1
a139 1
	    Safefree(SvPVX(gv));
d141 1
a141 1
    Newz(602, gp, 1, GP);
d143 3
d147 1
d149 3
a151 1
    GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : "";
d164 1
a164 1
	start_subparse(0,0);		/* Create CV in compcv. */
d199 8
d239 1
d248 5
d255 1
a255 1
	      name, HvNAME(stash));
d257 1
a257 1
    DEBUG_o( Perl_deb(aTHX_ "Looking for method %s in package %s\n",name,HvNAME(stash)) );
d284 1
a284 2
	char* packname = HvNAME(stash);
	STRLEN packlen = strlen(packname);
d286 1
a286 1
	if (packlen >= 7 && strEQ(packname + packlen - 7, "::SUPER")) {
d290 1
a290 1
	    basestash = gv_stashpvn(packname, packlen, TRUE);
d295 1
a295 1
		    Perl_croak(aTHX_ "Cannot create %s::ISA", HvNAME(stash));
d309 2
a310 2
	    SV* sv = *svp++;
	    HV* basestash = gv_stashsv(sv, FALSE);
d314 1
a314 1
			sv, HvNAME(stash));
d327 1
a327 1
	HV* lastchance;
d329 1
a329 1
	if ((lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE))) {
a379 2
	char autoload[] = "AUTOLOAD";
	STRLEN autolen = sizeof(autoload)-1;
d385 1
a385 1
	if (len == autolen && strnEQ(name, autoload, autolen))
d387 1
a387 1
	if (!(gv = gv_fetchmeth(stash, autoload, autolen, FALSE)))
d463 1
a463 1
	const char *origname = name;
d472 1
a472 1
	    stash = gv_stashpvn(SvPVX(tmpstr), SvCUR(tmpstr), TRUE);
d474 1
a474 1
			 origname, HvNAME(stash), name) );
d498 1
a498 1
	CV* cv = GvCV(gv);
a522 2
    char autoload[] = "AUTOLOAD";
    STRLEN autolen = sizeof(autoload)-1;
d528 1
a528 1
    char *packname = "";
d530 1
a530 1
    if (len == autolen && strnEQ(name, autoload, autolen))
d534 1
a534 1
	    packname = SvPV_nolen((SV*)stash);
d538 1
a538 1
	    packname = HvNAME(stash);
d541 1
a541 1
    if (!(gv = gv_fetchmeth(stash, autoload, autolen, FALSE)))
d551 3
a553 2
    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX) && !method &&
	(GvCVGEN(gv) || GvSTASH(gv) != stash))
d566 2
a567 2
        SvPVX(cv) = (char *)name; /* cast to lose constness warning */
        SvCUR(cv) = len;
d579 1
a579 1
    vargv = *(GV**)hv_fetch(varstash, autoload, autolen, TRUE);
d585 6
a590 2
    if (!isGV(vargv))
	gv_init(vargv, varstash, autoload, autolen, FALSE);
d592 1
a592 1
    varsv = GvSV(vargv);
d611 1
a611 1
    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) { 
d630 3
a632 3
be a valid UTF-8 string.  If C<create> is set then the package will be
created if it does not already exist.  If C<create> is not set and the
package does not exist then NULL is returned.
d643 12
d666 1
a666 1
	New(606, tmpbuf, namelen + 3, char);
d679 2
a680 2
    if (!HvNAME(stash))
	HvNAME(stash) = savepv(name);
a695 1
    register char *ptr;
d697 1
a697 1
    ptr = SvPV(sv,len);
d732 1
a732 1
		    New(601, tmpbuf, len+3, char);
d753 2
a754 2
		if (!HvNAME(stash))
		    HvNAME(stash) = savepvn(nambeg, namend - nambeg);
d773 9
a781 6
	    if (isUPPER(*name)) {
		if (*name == 'S' && (
		    strEQ(name, "SIG") ||
		    strEQ(name, "STDIN") ||
		    strEQ(name, "STDOUT") ||
		    strEQ(name, "STDERR")))
d783 3
a785 1
		else if (*name == 'I' && strEQ(name, "INC"))
d787 4
a790 1
		else if (*name == 'E' && strEQ(name, "ENV"))
d792 3
a794 3
		else if (*name == 'A' && (
		  strEQ(name, "ARGV") ||
		  strEQ(name, "ARGVOUT")))
d796 1
a797 2
	    else if (*name == '_' && !name[1])
		global = TRUE;
d808 2
a809 1
		    !(len == 1 && sv_type == SVt_PV && strchr("ab",*name)) )
d843 1
a843 1
	    register SV *err = Perl_mess(aTHX_
d884 1
a884 1
    if (isALPHA(name[0]) && ! (isLEXWARN_on ? ckWARN(WARN_ONCE) 
d889 108
a996 18
    switch (*name) {
    case 'A':
	if (strEQ(name, "ARGV")) {
	    IoFLAGS(GvIOn(gv)) |= IOf_ARGV|IOf_START;
	}
	break;
    case 'E':
	if (strnEQ(name, "EXPORT", 6))
	    GvMULTI_on(gv);
	break;
    case 'I':
	if (strEQ(name, "ISA")) {
	    AV* av = GvAVn(gv);
	    GvMULTI_on(gv);
	    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, Nullch, 0);
	    /* NOTE: No support for tied ISA */
	    if ((add & GV_ADDMULTI) && strEQ(nambeg,"AnyDBM_File::ISA")
		&& AvFILLp(av) == -1)
d998 8
a1005 11
		char *pname;
		av_push(av, newSVpvn(pname = "NDBM_File",9));
		gv_stashpvn(pname, 9, TRUE);
		av_push(av, newSVpvn(pname = "DB_File",7));
		gv_stashpvn(pname, 7, TRUE);
		av_push(av, newSVpvn(pname = "GDBM_File",9));
		gv_stashpvn(pname, 9, TRUE);
		av_push(av, newSVpvn(pname = "SDBM_File",9));
		gv_stashpvn(pname, 9, TRUE);
		av_push(av, newSVpvn(pname = "ODBM_File",9));
		gv_stashpvn(pname, 9, TRUE);
a1006 29
	}
	break;
    case 'O':
        if (strEQ(name, "OVERLOAD")) {
            HV* hv = GvHVn(gv);
            GvMULTI_on(gv);
            hv_magic(hv, Nullgv, PERL_MAGIC_overload);
        }
        break;
    case 'S':
	if (strEQ(name, "SIG")) {
	    HV *hv;
	    I32 i;
	    if (!PL_psig_ptr) {
		Newz(73, PL_psig_ptr,  SIG_SIZE, SV*);
		Newz(73, PL_psig_name, SIG_SIZE, SV*);
		Newz(73, PL_psig_pend, SIG_SIZE, int);
	    }
	    GvMULTI_on(gv);
	    hv = GvHVn(gv);
	    hv_magic(hv, Nullgv, PERL_MAGIC_sig);
	    for (i = 1; i < SIG_SIZE; i++) {
	    	SV ** init;
	    	init = hv_fetch(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
	    	if (init)
		    sv_setsv(*init, &PL_sv_undef);
	    	PL_psig_ptr[i] = 0;
	    	PL_psig_name[i] = 0;
	    	PL_psig_pend[i] = 0;
d1009 32
a1040 5
	break;
    case 'V':
	if (strEQ(name, "VERSION"))
	    GvMULTI_on(gv);
	break;
d1042 1
a1042 13
    case '&':
    case '`':
    case '\'':
       if (
           len > 1 ||
           sv_type == SVt_PVAV ||
           sv_type == SVt_PVHV ||
           sv_type == SVt_PVCV ||
           sv_type == SVt_PVFM ||
           sv_type == SVt_PVIO
       ) { break; }
	PL_sawampersand = TRUE;
	goto ro_magicalize;
d1044 2
a1045 5
    case ':':
	if (len > 1)
	    break;
	sv_setpv(GvSV(gv),PL_chopset);
	goto magicalize;
a1046 2
    case '?':
	if (len > 1)
d1048 3
a1050 26
#ifdef COMPLEX_STATUS
	(void)SvUPGRADE(GvSV(gv), SVt_PVLV);
#endif
	goto magicalize;

    case '!':
	if (len > 1)
	    break;

	/* If %! has been used, automatically load Errno.pm.
	   The require will itself set errno, so in order to
	   preserve its value we have to set up the magic
	   now (rather than going to magicalize)
	*/

	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, len);

	if (sv_type == SVt_PVHV)
	    require_errno(gv);

	break;
    case '-':
	if (len > 1)
	    break;
	else {
            AV* av = GvAVn(gv);
d1053 11
a1063 40
        }
	goto magicalize;
    case '#':
    case '*':
	if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX) && len == 1 && sv_type == SVt_PV)
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX), "Use of $%s is deprecated", name);
	/* FALL THROUGH */
    case '[':
    case '^':
    case '~':
    case '=':
    case '%':
    case '.':
    case '(':
    case ')':
    case '<':
    case '>':
    case ',':
    case '\\':
    case '/':
    case '\001':	/* $^A */
    case '\003':	/* $^C */
    case '\004':	/* $^D */
    case '\006':	/* $^F */
    case '\010':	/* $^H */
    case '\011':	/* $^I, NOT \t in EBCDIC */
    case '\016':        /* $^N */
    case '\020':	/* $^P */
	if (len > 1)
	    break;
	goto magicalize;
    case '|':
	if (len > 1)
	    break;
	sv_setiv(GvSV(gv), (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0);
	goto magicalize;
    case '\005':	/* $^E && $^ENCODING */
	if (len > 1 && strNE(name, "\005NCODING"))
	    break;
	goto magicalize;
d1065 3
a1067 32
    case '\017':	/* $^O & $^OPEN */
	if (len > 1 && strNE(name, "\017PEN"))
	    break;
	goto magicalize;
    case '\023':	/* $^S */
	if (len > 1)
	    break;
	goto ro_magicalize;
    case '\024':	/* $^T, ${^TAINT} */
        if (len == 1)
            goto magicalize;
        else if (strEQ(name, "\024AINT"))
            goto ro_magicalize;
        else
            break;
    case '\025':
        if (len > 1 && strNE(name, "\025NICODE")) 
	    break;
	goto ro_magicalize;

    case '\027':	/* $^W & $^WARNING_BITS */
	if (len > 1
	    && strNE(name, "\027ARNING_BITS")
	    )
	    break;
	goto magicalize;

    case '+':
	if (len > 1)
	    break;
	else {
            AV* av = GvAVn(gv);
d1070 1
a1070 20
        }
	/* FALL THROUGH */
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
	/* ensures variable is only digits */
	/* ${"1foo"} fails this test (and is thus writeable) */
	/* added by japhy, but borrowed from is_gv_magical */

	if (len > 1) {
	    const char *end = name + len;
	    while (--end > name) {
		if (!isDIGIT(*end)) return gv;
	    }
d1072 41
d1114 3
a1116 8
      ro_magicalize:
	SvREADONLY_on(GvSV(gv));
      magicalize:
	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
	break;

    case '\014':	/* $^L */
	if (len > 1)
d1118 2
a1119 5
	sv_setpv(GvSV(gv),"\f");
	PL_formfeed = GvSV(gv);
	break;
    case ';':
	if (len > 1)
d1121 3
a1123 5
	sv_setpv(GvSV(gv),"\034");
	break;
    case ']':
	if (len == 1) {
	    SV *sv = GvSV(gv);
d1138 3
a1140 3
    case '\026':	/* $^V */
	if (len == 1) {
	    SV *sv = GvSV(gv);
d1145 1
d1153 2
a1154 1
    HV *hv = GvSTASH(gv);
d1160 7
a1166 2
    if (keepmain || strNE(HvNAME(hv), "main")) {
	sv_catpv(sv,HvNAME(hv));
d1181 2
a1182 4
    GV *egv = GvEGV(gv);
    if (!egv)
	egv = gv;
    gv_fullname4(sv, egv, prefix, keepmain);
d1191 1
a1191 1
/* XXX compatibility with versions <= 5.003. */
d1195 1
a1195 1
    gv_fullname3(sv, gv, sv == (SV*)gv ? "*" : "");
d1198 1
a1198 1
/* XXX compatibility with versions <= 5.003. */
d1202 1
a1202 1
    gv_efullname3(sv, gv, sv == (SV*)gv ? "*" : "");
a1207 1
    IO *io;
d1209 1
a1210 1
    io = (IO*)NEWSV(0,0);
d1212 4
a1215 1
    SvREFCNT(io) = 1;
d1217 1
a1217 2
    /* Clear the stashcache because a new IO could overrule a 
       package name */
d1223 1
a1223 1
    SvSTASH(io) = (HV*)SvREFCNT_inc(GvHV(iogv));
a1229 1
    register HE *entry;
a1230 2
    register GV *gv;
    HV *hv;
d1235 1
d1237 2
d1246 1
a1246 1
		char *file;
a1252 2
		if (file
		    && PERL_FILE_IS_ABSOLUTE(file)
d1254 1
a1254 1
		    && (instr(file, ":lib:")
d1256 1
a1256 1
		    && (instr(file, "/lib/")
d1258 3
a1260 1
		    || instr(file, ".pm")))
d1266 1
a1266 1
		CopFILE(PL_curcop) = file;	/* set for warning */
d1272 1
a1272 1
			HvNAME(stash), GvNAME(gv));
d1334 8
a1341 6
    if (gp->gp_hv) {
	 if (PL_stashcache && HvNAME(gp->gp_hv))
	      hv_delete(PL_stashcache,
			HvNAME(gp->gp_hv), strlen(HvNAME(gp->gp_hv)),
			G_DISCARD);
	 SvREFCNT_dec(gp->gp_hv);
d1354 3
a1356 1
    AMT *amtp = (AMT*)mg->mg_ptr;
d1360 1
a1360 1
	    CV *cv = amtp->table[i];
d1375 2
a1376 4
  GV* gv;
  CV* cv;
  MAGIC* mg=mg_find((SV*)stash, PERL_MAGIC_overload_table);
  AMT *amtp = (mg) ? (AMT*)mg->mg_ptr: (AMT *) NULL;
d1384 1
a1384 1
  DEBUG_o( Perl_deb(aTHX_ "Recalcing overload magic in package %s\n",HvNAME(stash)) );
a1394 1
    SV* sv = NULL;
d1399 3
a1401 3
    gv = gv_fetchmeth(stash, PL_AMG_names[0], 2, -1);
    if (gv)
	sv = GvSV(gv);
d1405 5
d1418 1
a1418 1
	char *cooky = (char*)PL_AMG_names[i];
d1420 2
a1421 2
	char *cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
	STRLEN l = strlen(cooky);
d1423 2
a1424 2
	DEBUG_o( Perl_deb(aTHX_ "Checking overloading of `%s' in package `%.256s'\n",
		     cp, HvNAME(stash)) );
d1438 1
d1440 1
a1440 1
		&& strEQ(HvNAME(GvSTASH(CvGV(cv))), "overload")) {
d1445 7
a1451 6
		
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%"SVf256\
			"' for overloaded `%s' in package `%.256s'\n",
			     GvSV(gv), cp, HvNAME(stash)) );
		if (!SvPOK(GvSV(gv))
		    || !(ngv = gv_fetchmethod_autoload(stash, SvPVX(GvSV(gv)),
d1454 4
a1457 5
		    /* Can be an import stub (created by `can'). */
		    SV *gvsv = GvSV(gv);
		    const char *name = SvPOK(gvsv) ?  SvPVX(gvsv) : "???";
		    Perl_croak(aTHX_ "%s method `%.256s' overloading `%s' "\
				"in package `%.256s'",
d1460 1
a1460 1
			       name, cp, HvNAME(stash));
d1464 2
a1465 2
	    DEBUG_o( Perl_deb(aTHX_ "Overloading `%s' in package `%.256s' via `%.256s::%.256s' \n",
			 cp, HvNAME(stash), HvNAME(GvSTASH(CvGV(cv))),
a1498 1
    CV *ret;
d1500 1
a1500 1
    if (!stash)
d1513 1
a1513 1
	ret = amtp->table[id];
d1519 1
a1519 1
	    GV *gv = gv_fetchmethod(stash, (char*)PL_AMG_names[id]);
d1526 1
a1526 1
    
d1538 4
a1541 2
  int off=0, off1, lr=0, assign=AMGf_assign & flags, notfound=0;
  int postpr = 0, force_cpy = 0, assignshift = assign ? 1 : 0;
d1558 1
a1558 1
#endif 
d1591 6
a1596 6
 case not_amg:
   (void)((cv = cvp[off=bool__amg])
	  || (cv = cvp[off=numer_amg])
	  || (cv = cvp[off=string_amg]));
   postpr = 1;
   break;
d1603 1
a1603 1
	     SV* tmpRef=SvRV(left);
d1609 1
a1609 1
		SV* newref = newSVsv(tmpRef);
d1611 1
a1611 1
		SvSTASH(newref) = (HV*)SvREFCNT_inc(SvSTASH(tmpRef));
d1619 1
a1619 1
	     SV* nullsv=sv_2mortal(newSViv(0));
d1621 1
a1621 1
	       SV* lessp = amagic_call(left,nullsv,
d1625 1
a1625 1
	       SV* lessp = amagic_call(left,nullsv,
d1725 1
a1725 1
		      "Operation `%s': no method found,%sargument %s%s%s%s",
d1732 1
a1732 1
		        HvNAME(SvSTASH(SvRV(left))):
d1740 1
a1740 1
		        HvNAME(SvSTASH(SvRV(right))):
d1743 1
a1743 1
	  DEBUG_o( Perl_deb(aTHX_ "%s", SvPVX(msg)) );
d1755 1
a1755 1
		     "Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %s%s\n",
d1758 1
a1758 1
		     " (initially `",
d1761 1
a1761 1
		     method+assignshift==off? "" : "')",
d1765 1
a1765 1
		     stash ? HvNAME(stash) : "null",
d1799 1
a1799 1
    bool oldcatch = CATCH_GET;
d1837 1
a1837 1
      int ans=0;
d1862 2
d1888 4
d1897 1
a1897 2
    if (!len)
	return FALSE;
d1899 45
a1943 16
    switch (*name) {
    case 'I':
	if (len == 3 && strEQ(name, "ISA"))
	    goto yes;
	break;
    case 'O':
	if (len == 8 && strEQ(name, "OVERLOAD"))
	    goto yes;
	break;
    case 'S':
	if (len == 3 && strEQ(name, "SIG"))
	    goto yes;
	break;
    case '\017':   /* $^O & $^OPEN */
	if (len == 1
	    || (len == 4 && strEQ(name, "\017PEN")))
d1945 1
a1945 71
	    goto yes;
	}
	break;
    case '\025':
        if (len > 1 && strEQ(name, "\025NICODE"))
	    goto yes;
    case '\027':   /* $^W & $^WARNING_BITS */
	if (len == 1
	    || (len == 12 && strEQ(name, "\027ARNING_BITS"))
	    )
	{
	    goto yes;
	}
	break;

    case '&':
    case '`':
    case '\'':
    case ':':
    case '?':
    case '!':
    case '-':
    case '#':
    case '*':
    case '[':
    case '^':
    case '~':
    case '=':
    case '%':
    case '.':
    case '(':
    case ')':
    case '<':
    case '>':
    case ',':
    case '\\':
    case '/':
    case '|':
    case '+':
    case ';':
    case ']':
    case '\001':   /* $^A */
    case '\003':   /* $^C */
    case '\004':   /* $^D */
    case '\005':   /* $^E */
    case '\006':   /* $^F */
    case '\010':   /* $^H */
    case '\011':   /* $^I, NOT \t in EBCDIC */
    case '\014':   /* $^L */
    case '\016':   /* $^N */
    case '\020':   /* $^P */
    case '\023':   /* $^S */
    case '\026':   /* $^V */
	if (len == 1)
	    goto yes;
	break;
    case '\024':   /* $^T, ${^TAINT} */
        if (len == 1 || strEQ(name, "\024AINT"))
            goto yes;
        break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
	if (len > 1) {
	    char *end = name + len;
d1950 61
a2011 4
    yes:
	return TRUE;
    default:
	break;
d2015 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d22 9
d1096 1
a1096 1
	(void)SvOK_off(sv);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d1245 2
a1246 1
			"Attempt to free unreferenced glob pointers");
d1260 1
a1260 1
    if (gp->gp_sv) SvREFCNT_dec(gp->gp_av);
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d265 2
a266 2
		    Perl_warner(aTHX_ packWARN(WARN_MISC), "Can't locate package %s for @@%s::ISA",
			SvPVX(sv), HvNAME(stash));
d405 4
d441 1
d449 1
a449 1
	    gv = gv_autoload4(stash, name, nend - name, TRUE);
d484 1
a485 2
    if (!stash)
	return Nullgv;	/* UNIVERSAL::AUTOLOAD could cause trouble */
d488 9
d511 1
a511 1
	     HvNAME(stash), (int)len, name);
d547 1
a547 1
    sv_setpv(varsv, HvNAME(stash));
a705 2
    if (!len)
	len = 1;
d734 1
a734 1
	    else if ((COP*)PL_curcop == &PL_compiling) {
d775 1
a775 1
	    qerror(Perl_mess(aTHX_
d780 4
a783 1
		  : ""), name));
d996 5
d1002 3
a1004 2
	if (len > 1 && strNE(name, "\027ARNING_BITS")
	    && strNE(name, "\027IDE_SYSTEM_CALLS"))
d1101 1
a1101 9
    HV *hv = GvSTASH(gv);
    if (!hv) {
	(void)SvOK_off(sv);
	return;
    }
    sv_setpv(sv, prefix ? prefix : "");
    sv_catpv(sv,HvNAME(hv));
    sv_catpvn(sv,"::", 2);
    sv_catpvn(sv,GvNAME(gv),GvNAMELEN(gv));
d1116 1
a1116 4
    GV *egv = GvEGV(gv);
    if (!egv)
	egv = gv;
    gv_fullname3(sv, egv, prefix);
d1143 3
d1167 1
a1167 1
		(gv = (GV*)HeVAL(entry)) && (hv = GvHV(gv)))
d1258 12
a1269 6
    SvREFCNT_dec(gp->gp_sv);
    SvREFCNT_dec(gp->gp_av);
    SvREFCNT_dec(gp->gp_hv);
    SvREFCNT_dec(gp->gp_io);
    SvREFCNT_dec(gp->gp_cv);
    SvREFCNT_dec(gp->gp_form);
d1365 3
a1367 2
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n",
			     SvPV_nolen(GvSV(gv)), cp, HvNAME(stash)) );
d1373 7
a1379 8
		    if (GvCVGEN(gv)) {
			Perl_croak(aTHX_ "Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'",
			      (SvPOK(GvSV(gv)) ?  SvPVX(GvSV(gv)) : "???" ),
			      cp, HvNAME(stash));
		    } else
			Perl_croak(aTHX_ "Can't resolve method `%.256s' overloading `%s' in package `%.256s'",
			      (SvPOK(GvSV(gv)) ?  SvPVX(GvSV(gv)) : "???" ),
			      cp, HvNAME(stash));
d1832 3
d1838 1
a1838 1
	    || (len == 17 && strEQ(name, "\027IDE_SYSTEM_CALLS")))
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d19 4
d52 6
a57 1
    if (!GvIOp(gv))
d59 1
d79 1
d88 1
a88 1
	    hv_magic(GvHVn(gv_AVadd(gv)), Nullgv, 'L');
d118 1
a118 1
    sv_magic((SV*)gv, (SV*)gv, '*', Nullch, 0);
d134 1
a134 1
	CvFILE(GvCV(gv)) = CopFILE(PL_curcop);
d136 1
a136 1
#ifdef USE_THREADS
d142 1
a142 1
#endif /* USE_THREADS */
d171 1
a171 1
accessible via @@ISA and @@UNIVERSAL.
d196 7
a202 2
    if (!stash)
	return 0;
d264 1
a264 1
		    Perl_warner(aTHX_ WARN_MISC, "Can't locate package %s for @@%s::ISA",
d313 44
d420 1
d425 11
a435 2
	else
	    stash = gv_stashpvn(origname, nsplit - origname, TRUE);
d471 2
a472 2
    static char autoload[] = "AUTOLOAD";
    static STRLEN autolen = 8;
d479 2
d487 1
a487 1
    if (!CvROOT(cv))
d493 1
a493 1
    if (ckWARN(WARN_DEPRECATED) && !method &&
d495 1
a495 1
	Perl_warner(aTHX_ WARN_DEPRECATED,
d499 14
d523 1
a523 1
#ifdef USE_THREADS
d530 1
a530 1
#ifdef USE_THREADS
d540 23
d655 1
a655 1
		if (len + 3 < sizeof smallbuf)
d786 2
d797 1
a797 1
	Perl_warner(aTHX_ WARN_INTERNAL, "Had to create %s unexpectedly", nambeg);
d820 1
a820 1
	    sv_magic((SV*)av, (SV*)gv, 'I', Nullch, 0);
d843 1
a843 1
            hv_magic(hv, Nullgv, 'A');
d851 3
a853 3
		int sig_num[] = { SIG_NUM };
		New(73, PL_psig_ptr, sizeof(sig_num)/sizeof(*sig_num), SV*);
		New(73, PL_psig_name, sizeof(sig_num)/sizeof(*sig_num), SV*);
d857 2
a858 2
	    hv_magic(hv, Nullgv, 'S');
	    for (i = 1; PL_sig_name[i]; i++) {
d865 1
a874 5
	if (len > 1)
	    break;
	PL_sawampersand = TRUE;
	goto ro_magicalize;

a875 5
	if (len > 1)
	    break;
	PL_sawampersand = TRUE;
	goto ro_magicalize;

d877 8
a884 2
	if (len > 1)
	    break;
d905 13
a917 13
	if (sv_type > SVt_PV && PL_curcop != &PL_compiling) {
	    HV* stash = gv_stashpvn("Errno",5,FALSE);
	    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
		dSP;
		PUTBACK;
		require_pv("Errno.pm");
		SPAGAIN;
		stash = gv_stashpvn("Errno",5,FALSE);
		if (!stash || !(gv_fetchmethod(stash, "TIEHASH")))
		    Perl_croak(aTHX_ "Can't use %%! because Errno.pm is not available");
	    }
	}
	goto magicalize;
d923 1
a923 1
            sv_magic((SV*)av, Nullsv, 'D', Nullch, 0);
d929 2
a930 2
	if (ckWARN(WARN_DEPRECATED) && len == 1 && sv_type == SVt_PV)
	    Perl_warner(aTHX_ WARN_DEPRECATED, "Use of $%s is deprecated", name);
a947 1
    case '\005':	/* $^E */
d951 1
a951 1
    case '\017':	/* $^O */
a952 1
    case '\024':	/* $^T */
d961 9
d974 7
d992 1
a992 1
            sv_magic((SV*)av, (SV*)av, 'D', Nullch, 0);
d1005 11
d1019 1
a1019 1
	sv_magic(GvSV(gv), (SV*)gv, 0, name, len);
d1154 1
a1154 1
		(gv = (GV*)HeVAL(entry)) && (hv = GvHV(gv)) && HvNAME(hv))
d1169 6
a1174 1
		    && (instr(file, "/lib/") || instr(file, ".pm")))
d1184 1
a1184 1
		Perl_warner(aTHX_ WARN_ONCE,
d1231 1
a1231 1
	    Perl_warner(aTHX_ WARN_INTERNAL,
d1256 2
a1257 7
#if defined(CRIPPLED_CC) && (defined(iAPX286) || defined(M_I286) || defined(I80286))
#define MICROPORT
#endif

#ifdef	MICROPORT	/* Microport 2.4 hack */
AV *GvAVn(gv)
register GV *gv;
d1259 12
a1270 4
    if (GvGP(gv)->gp_av)
	return GvGP(gv)->gp_av;
    else
	return GvGP(gv_AVadd(gv))->gp_av;
a1272 10
HV *GvHVn(gv)
register GV *gv;
{
    if (GvGP(gv)->gp_hv)
	return GvGP(gv)->gp_hv;
    else
	return GvGP(gv_HVadd(gv))->gp_hv;
}
#endif			/* Microport 2.4 hack */

d1280 1
a1280 1
  MAGIC* mg=mg_find((SV*)stash,'c');
a1282 5
  STRLEN n_a;
#ifdef OVERLOAD_VIA_HASH
  GV** gvp;
  HV* hv;
#endif
d1286 2
a1287 10
      return AMT_AMAGIC(amtp);
  if (amtp && AMT_AMAGIC(amtp)) {	/* Have table. */
    int i;
    for (i=1; i<NofAMmeth; i++) {
      if (amtp->table[i]) {
	SvREFCNT_dec(amtp->table[i]);
      }
    }
  }
  sv_unmagic((SV*)stash, 'c');
d1291 1
a1296 54
#ifdef OVERLOAD_VIA_HASH
  gvp=(GV**)hv_fetch(stash,"OVERLOAD",8,FALSE);	/* A shortcut */
  if (gvp && ((gv = *gvp) != (GV*)&PL_sv_undef && (hv = GvHV(gv)))) {
    int filled=0;
    int i;
    char *cp;
    SV* sv;
    SV** svp;

    /* Work with "fallback" key, which we assume to be first in PL_AMG_names */

    if (( cp = (char *)PL_AMG_names[0] ) &&
	(svp = (SV**)hv_fetch(hv,cp,strlen(cp),FALSE)) && (sv = *svp)) {
      if (SvTRUE(sv)) amt.fallback=AMGfallYES;
      else if (SvOK(sv)) amt.fallback=AMGfallNEVER;
    }
    for (i = 1; i < NofAMmeth; i++) {
      cv = 0;
      cp = (char *)PL_AMG_names[i];

        svp = (SV**)hv_fetch(hv, cp, strlen(cp), FALSE);
        if (svp && ((sv = *svp) != &PL_sv_undef)) {
          switch (SvTYPE(sv)) {
            default:
              if (!SvROK(sv)) {
                if (!SvOK(sv)) break;
		gv = gv_fetchmethod(stash, SvPV(sv, n_a));
                if (gv) cv = GvCV(gv);
                break;
              }
              cv = (CV*)SvRV(sv);
              if (SvTYPE(cv) == SVt_PVCV)
                  break;
                /* FALL THROUGH */
            case SVt_PVHV:
            case SVt_PVAV:
	      Perl_croak(aTHX_ "Not a subroutine reference in overload table");
	      return FALSE;
            case SVt_PVCV:
              cv = (CV*)sv;
              break;
            case SVt_PVGV:
              if (!(cv = GvCVu((GV*)sv)))
                cv = sv_2cv(sv, &stash, &gv, FALSE);
              break;
          }
          if (cv) filled=1;
	  else {
	    Perl_croak(aTHX_ "Method for operation %s not found in package %.256s during blessing\n",
		cp,HvNAME(stash));
	    return FALSE;
	  }
        }
#else
d1298 2
a1299 3
    int filled = 0;
    int i;
    const char *cp;
d1304 19
a1322 13
    if ((cp = PL_AMG_names[0])) {
	/* Try to find via inheritance. */
	gv = gv_fetchmeth(stash, "()", 2, -1); /* A cookie: "()". */
	if (gv)
	    sv = GvSV(gv);

	if (!gv)
	    goto no_table;
	else if (SvTRUE(sv))
	    amt.fallback=AMGfallYES;
	else if (SvOK(sv))
	    amt.fallback=AMGfallNEVER;
    }
a1323 2
    for (i = 1; i < NofAMmeth; i++) {
	SV *cookie = sv_2mortal(Perl_newSVpvf(aTHX_ "(%s", cp = PL_AMG_names[i]));
d1326 11
a1336 2
	/* don't fill the cache while looking up! */
	gv = gv_fetchmeth(stash, SvPVX(cookie), SvCUR(cookie), -1);
d1338 1
a1338 1
        if(gv && (cv = GvCV(gv))) {
d1341 2
d1344 1
a1344 1
		GV *ngv;
d1347 1
a1347 1
			     SvPV(GvSV(gv), n_a), cp, HvNAME(stash)) );
d1368 5
a1373 1
#endif
d1378 5
a1382 2
      sv_magic((SV*)stash, 0, 'c', (char*)&amt, sizeof(AMT));
      return TRUE;
d1386 1
a1386 1
 no_table:
d1388 2
a1389 1
  sv_magic((SV*)stash, 0, 'c', (char*)&amt, sizeof(AMTS));
d1393 39
d1436 1
a1436 1
  CV *cv;
d1438 2
a1439 2
  AMT *amtp, *oamtp;
  int fl=0, off, off1, lr=0, assign=AMGf_assign & flags, notfound=0;
d1441 4
a1444 1
  HV* stash;
d1446 2
a1447 1
      && (mg = mg_find((SV*)(stash=SvSTASH(SvRV(left))),'c'))
d1454 5
a1458 1
		  (fl = 1, cv = cvp[off=method])))) {
d1546 1
d1564 2
a1565 1
	       && (mg = mg_find((SV*)(stash=SvSTASH(SvRV(right))),'c'))
d1625 1
a1625 1
		      PL_AMG_names[method + assignshift],
d1651 1
d1653 13
a1665 13
    DEBUG_o( Perl_deb(aTHX_
  "Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %s%s\n",
		 PL_AMG_names[off],
		 method+assignshift==off? "" :
		             " (initially `",
		 method+assignshift==off? "" :
		             PL_AMG_names[method+assignshift],
		 method+assignshift==off? "" : "')",
		 flags & AMGf_unary? "" :
		   lr==1 ? " for right argument": " for left argument",
		 flags & AMGf_unary? " for argument" : "",
		 HvNAME(stash),
		 fl? ",\n\tassignment variant used": "") );
d1667 1
d1720 1
a1720 1
      PUSHs( sv_2mortal(newSVpv((char *)PL_AMG_names[method + assignshift],0)));
d1736 1
a1736 1
      int ans;
d1806 7
d1856 1
a1856 1
    case '\017':   /* $^O */
a1858 1
    case '\024':   /* $^T */
d1863 4
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a55 1
    dTHR;
d77 1
a77 1
	    hv_magic(GvHVn(gv_AVadd(gv)), gv, 'L');
a86 1
    dTHR;
d107 1
a107 1
    sv_magic((SV*)gv, (SV*)gv, '*', name, len);
d122 1
a122 1
	CvGV(GvCV(gv)) = (GV*)SvREFCNT_inc(gv);
d160 1
a160 1
accessible via @@ISA and @@UNIVERSAL. 
d165 1
a165 1
up caching info for this glob.  Similarly for all the searched stashes. 
d171 1
a171 1
obtained from the GV with the C<GvCV> macro. 
a227 1
		dTHR;		/* just for SvREFCNT_dec */
a246 1
		dTHR;		/* just for ckWARN */
d316 1
a316 1
already setup. 
d320 1
a320 1
means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. 
d322 1
a322 1
with a non-zero C<autoload> parameter. 
d328 1
a328 1
created via a side effect to do this. 
d333 1
a333 1
C<call_sv> apply equally to these functions. 
a340 1
    dTHR;
d344 1
a344 1
    
d370 1
a370 1
	if (strEQ(name,"import"))
a400 1
    dTHR;
d415 3
d421 1
a421 1
    if (ckWARN(WARN_DEPRECATED) && !method && 
d435 5
d442 1
d444 3
a521 1
    dTHR;
a527 1
    U32 add_gvflags = 0;
d660 1
d662 2
a663 1
	return Nullgv;
a688 1
    GvFLAGS(gv) |= add_gvflags;
d690 2
a691 1
    if (isLEXWARN_on && isALPHA(name[0]) && ! ckWARN(WARN_ONCE))
d732 1
a732 1
            hv_magic(hv, gv, 'A');
d746 1
a746 1
	    hv_magic(hv, gv, 'S');
d816 1
a836 1
    case '|':
d850 5
d871 1
d904 8
a913 1
	    (void)SvPV_nolen(sv);
d929 16
d959 9
a992 1
    dTHR;
a1010 1
    dTHR;
a1086 1
    dTHR;  
d1126 1
a1126 1
    if (GvGP(gv)->gp_av) 
a1146 1
  dTHR;
d1197 1
a1197 1
      
d1267 1
a1267 1
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n", 
d1269 1
a1269 1
		if (!SvPOK(GvSV(gv)) 
d1275 1
a1275 1
			Perl_croak(aTHX_ "Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'", 
d1279 1
a1279 1
			Perl_croak(aTHX_ "Can't resolve method `%.256s' overloading `%s' in package `%.256s'", 
d1290 1
a1290 1
#endif 
d1309 2
a1310 3
  dTHR;
  MAGIC *mg; 
  CV *cv; 
d1318 1
a1318 1
      && (ocvp = cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr) 
d1321 1
a1321 1
      && ((cv = cvp[off=method+assignshift]) 
d1357 1
a1357 1
   (void)((cv = cvp[off=bool__amg]) 
d1382 1
a1382 1
	   if ((cvp[off1=lt_amg] || cvp[off1=ncmp_amg]) 
d1413 3
d1422 1
a1422 1
	     return NULL;	/* Delegate operation to standard mechanisms. */
d1430 1
a1430 1
	       && (cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr) 
d1436 2
a1437 2
    } else if (((ocvp && oamtp->fallback > AMGfallNEVER 
		 && (cvp=ocvp) && (lr = -1)) 
d1470 10
d1487 1
a1487 1
	msg = sv_2mortal(Perl_newSVpvf(aTHX_ 
d1491 1
a1491 1
		      SvAMAGIC(left)? 
d1494 1
a1494 1
		      SvAMAGIC(left)? 
d1497 1
a1497 1
		      SvAMAGIC(right)? 
d1499 1
a1499 1
		        (flags & AMGf_unary 
d1502 1
a1502 1
		      SvAMAGIC(right)? 
d1516 1
a1516 1
    DEBUG_o( Perl_deb(aTHX_ 
d1527 1
a1527 1
		 HvNAME(stash), 
d1540 1
a1540 1
     * 		assignshift==0,  assign==T, 
d1543 1
a1543 1
     * 		assignshift==0,  assign==0, 
d1634 107
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d20 1
d24 1
a24 1
gv_AVadd(register GV *gv)
d27 1
a27 1
	croak("Bad symbol for array");
d34 1
a34 1
gv_HVadd(register GV *gv)
d37 1
a37 1
	croak("Bad symbol for hash");
d44 1
a44 1
gv_IOadd(register GV *gv)
d47 1
a47 1
	croak("Bad symbol for filehandle");
d54 1
a54 1
gv_fetchfile(char *name)
d62 3
d74 1
a74 1
    if (!isGV(gv))
d76 4
a81 5
    sv_setpv(GvSV(gv), name);
    if (*name == '/' && (instr(name, "/lib/") || instr(name, ".pm")))
	GvMULTI_on(gv);
    if (PERLDB_LINE)
	hv_magic(GvHVn(gv_AVadd(gv)), gv, 'L');
d86 1
a86 1
gv_init(GV *gv, HV *stash, char *name, STRLEN len, int multi)
d105 2
a106 2
    GvLINE(gv) = PL_curcop->cop_line;
    GvFILEGV(gv) = PL_curcop->cop_filegv;
d125 1
a125 1
	CvFILEGV(GvCV(gv)) = PL_curcop->cop_filegv;
d142 1
a142 1
gv_init_sv(GV *gv, I32 sv_type)
d157 21
d179 1
a179 1
gv_fetchmeth(HV *stash, char *name, STRLEN len, I32 level)
d190 1
a190 1
	croak("Recursive inheritance detected while looking for method '%s' in package '%s'",
d193 1
a193 1
    DEBUG_o( deb("Looking for method %s in package %s\n",name,HvNAME(stash)) );
d202 1
a202 1
	if (cv = GvCV(topgv)) {
d233 1
a233 1
		    croak("Cannot create %s::ISA", HvNAME(stash));
d250 3
a252 2
		if (PL_dowarn)
		    warn("Can't locate package %s for @@%s::ISA",
d268 4
a271 3
	if (lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE)) {
	    if (gv = gv_fetchmeth(lastchance, name, len,
				  (level >= 0) ? level + 1 : level - 1)) {
d283 1
a283 1
		    if (cv = GvCV(topgv))
d300 8
d309 1
a309 1
gv_fetchmethod(HV *stash, char *name)
d314 28
d343 1
a343 1
gv_fetchmethod_autoload(HV *stash, char *name, I32 autoload)
d346 2
a347 2
    register char *nend;
    char *nsplit = 0;
d357 1
a357 1
	char *origname = name;
d363 2
a364 2
	    SV *tmpstr = sv_2mortal(newSVpvf("%s::SUPER",
					     HvNAME(PL_curcop->cop_stash)));
d366 1
a366 1
	    DEBUG_o( deb("Treating %s as %s::%s\n",
d404 1
a404 1
gv_autoload4(HV *stash, char *name, STRLEN len, I32 method)
d406 1
d424 3
a426 2
    if (PL_dowarn && !method && (GvCVGEN(gv) || GvSTASH(gv) != stash))
	warn(
d448 11
d460 1
a460 1
gv_stashpv(char *name, I32 create)
d466 1
a466 1
gv_stashpvn(char *name, U32 namelen, I32 create)
d494 9
d504 1
a504 1
gv_stashsv(SV *sv, I32 create)
d514 1
a514 1
gv_fetchpv(char *nambeg, I32 add, I32 sv_type)
d517 1
a517 1
    register char *name = nambeg;
d521 1
a521 1
    register char *namend;
d529 2
a530 2
	if ((*namend == '\'' && namend[1]) ||
	    (*namend == ':' && namend[1] == ':'))
d585 1
a585 1
	if (isIDFIRST(*name)) {
d625 3
a627 3
		    else if (sv_type == SVt_PV   && !GvIMPORTED_SV(*gvp) ||
			     sv_type == SVt_PVAV && !GvIMPORTED_AV(*gvp) ||
			     sv_type == SVt_PVHV && !GvIMPORTED_HV(*gvp) )
d629 1
a629 1
			warn("Variable \"%c%s\" is not imported",
d634 1
a634 1
			    warn("(Did you mean &%s instead?)\n", name);
d640 1
a640 1
		stash = PL_curcop->cop_stash;
d649 7
a655 13
	if (!add)
	    return Nullgv;
	if (add & ~GV_ADDMULTI) {
	    char sv_type_char = ((sv_type == SVt_PV) ? '$'
				 : (sv_type == SVt_PVAV) ? '@@'
				 : (sv_type == SVt_PVHV) ? '%'
				 : 0);
	    if (sv_type_char) 
		warn("Global symbol \"%c%s\" requires explicit package name",
		     sv_type_char, name);
	    else
		warn("Global symbol \"%s\" requires explicit package name",
		     name);
d657 1
a657 6
	++PL_error_count;
	stash = PL_curstash ? PL_curstash : PL_defstash;	/* avoid core dumps */
	add_gvflags = ((sv_type == SVt_PV) ? GVf_IMPORTED_SV
		       : (sv_type == SVt_PVAV) ? GVf_IMPORTED_AV
		       : (sv_type == SVt_PVHV) ? GVf_IMPORTED_HV
		       : 0);
d679 2
a680 2
    if (add & GV_ADDWARN)
	warn("Had to create %s unexpectedly", nambeg);
d685 3
d709 1
a709 1
		av_push(av, newSVpv(pname = "NDBM_File",0));
d711 1
a711 1
		av_push(av, newSVpv(pname = "DB_File",0));
d713 1
a713 1
		av_push(av, newSVpv(pname = "GDBM_File",0));
d715 1
a715 1
		av_push(av, newSVpv(pname = "SDBM_File",0));
d717 1
a717 1
		av_push(av, newSVpv(pname = "ODBM_File",0));
a721 1
#ifdef OVERLOAD
a728 1
#endif /* OVERLOAD */
d733 9
a741 5
	    PL_siggv = gv;
	    GvMULTI_on(PL_siggv);
	    hv = GvHVn(PL_siggv);
	    hv_magic(hv, PL_siggv, 'S');
	    for(i=1;sig_name[i];i++) {
d743 5
a747 5
	    	init=hv_fetch(hv,sig_name[i],strlen(sig_name[i]),1);
	    	if(init)
	    		sv_setsv(*init,&PL_sv_undef);
	    	psig_ptr[i] = 0;
	    	psig_name[i] = 0;
d751 4
a758 1
	PL_ampergv = gv;
a764 1
	PL_leftgv = gv;
a770 1
	PL_rightgv = gv;
d784 1
a784 1
	sv_upgrade(GvSV(gv), SVt_PVLV);
d793 1
a793 1
	    if(!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
d796 1
a796 1
		perl_require_pv("Errno.pm");
d800 1
a800 1
		    croak("Can't use %%! because Errno.pm is not available");
d804 8
d814 2
a815 2
	if (PL_dowarn && len == 1 && sv_type == SVt_PV)
	    warn("Use of $%s is deprecated", name);
a820 1
    case '-':
d831 14
a844 11
    case '\001':
    case '\003':
    case '\004':
    case '\005':
    case '\006':
    case '\010':
    case '\011':	/* NOT \t in EBCDIC */
    case '\017':
    case '\020':
    case '\024':
    case '\027':
d847 5
d855 7
a870 1
    case '\023':
d877 1
a877 1
    case '\014':
d891 4
a894 3
	    sv_upgrade(sv, SVt_PVNV);
	    sv_setpv(sv, PL_patchlevel);
	    (void)sv_2nv(sv);
d898 7
d910 1
a910 1
gv_fullname3(SV *sv, GV *gv, char *prefix)
d914 1
a914 1
	SvOK_off(sv);
d924 1
a924 1
gv_efullname3(SV *sv, GV *gv, char *prefix)
d934 1
a934 1
gv_fullname(SV *sv, GV *gv)
d941 1
a941 1
gv_efullname(SV *sv, GV *gv)
d947 1
a947 1
newIO(void)
d966 1
a966 1
gv_check(HV *stash)
a972 1
    GV *filegv;
d981 1
a981 1
		if (hv != PL_defstash)
d985 1
d989 7
a995 4
		PL_curcop->cop_line = GvLINE(gv);
		filegv = GvFILEGV(gv);
		PL_curcop->cop_filegv = filegv;
		if (filegv && GvMULTI(filegv))	/* Filename began with slash */
d997 9
a1005 1
		warn("Name \"%s::%s\" used only once: possible typo",
d1013 1
a1013 1
newGVgen(char *pack)
d1015 1
a1015 1
    return gv_fetchpv(form("%s::_GEN_%ld", pack, (long)PL_gensym++),
d1022 1
a1022 1
gp_ref(GP *gp)
d1024 2
d1043 1
a1043 1
gp_free(GV *gv)
d1045 1
a1046 1
    CV* cv;
d1051 3
a1053 1
        warn("Attempt to free unreferenced glob pointers");
a1100 1
#ifdef OVERLOAD
d1104 1
a1104 1
Gv_AMupdate(HV *stash)
d1106 1
a1106 3
  dTHR;  
  GV** gvp;
  HV* hv;
d1113 4
d1131 1
a1131 1
  DEBUG_o( deb("Recalcing overload magic in package %s\n",HvNAME(stash)) );
d1147 1
a1147 1
    /* Work with "fallback" key, which we assume to be first in AMG_names */
d1149 1
a1149 1
    if (( cp = (char *)AMG_names[0] ) &&
d1156 1
a1156 1
      cp = (char *)AMG_names[i];
d1174 1
a1174 1
	      croak("Not a subroutine reference in overload table");
d1181 1
a1181 1
                cv = sv_2cv(sv, &stash, &gv, TRUE);
d1186 1
a1186 1
	    croak("Method for operation %s not found in package %.256s during blessing\n",
a1196 1
    SV** svp;
d1198 1
a1198 1
    /* Work with "fallback" key, which we assume to be first in AMG_names */
d1200 1
a1200 1
    if ( cp = AMG_names[0] ) {
d1203 2
a1204 1
	if (gv) sv = GvSV(gv);
d1206 6
a1211 3
	if (!gv) goto no_table;
	else if (SvTRUE(sv)) amt.fallback=AMGfallYES;
	else if (SvOK(sv)) amt.fallback=AMGfallNEVER;
d1215 2
a1216 2
	SV *cookie = sv_2mortal(newSVpvf("(%s", cp = AMG_names[i]));
	DEBUG_o( deb("Checking overloading of `%s' in package `%.256s'\n",
d1227 1
a1227 1
		DEBUG_o( deb("Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n", 
d1235 1
a1235 1
			croak("Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'", 
d1239 1
a1239 1
			croak("Cannot resolve method `%.256s' overloading `%s' in package `%.256s'", 
d1245 1
a1245 1
	    DEBUG_o( deb("Overloading `%s' in package `%.256s' via `%.256s::%.256s' \n",
d1267 1
a1267 1
amagic_call(SV *left, SV *right, int method, int flags)
d1367 1
a1367 1
	   if (cv = cvp[off=subtr_amg]) {
d1373 9
d1435 1
a1435 1
	msg = sv_2mortal(newSVpvf(
d1437 1
a1437 1
		      AMG_names[method + assignshift],
d1454 1
a1454 1
	  DEBUG_o( deb("%s", SvPVX(msg)) );
d1456 1
a1456 1
	  croak("%_", msg);
d1464 1
a1464 1
    DEBUG_o( deb(
d1466 1
a1466 1
		 AMG_names[off],
d1470 1
a1470 1
		             AMG_names[method+assignshift],
d1523 1
a1523 1
    pp_pushmark(ARGS);
d1530 1
a1530 1
      PUSHs( sv_2mortal(newSVpv((char *)AMG_names[method + assignshift],0)) );
d1535 2
a1536 2
    if (PL_op = pp_entersub(ARGS))
      CALLRUNOPS();
d1541 1
d1570 1
a1570 1
	ans=!SvOK(res); break;
d1575 1
a1575 1
	croak("Copy method did not return a reference");
a1582 2
#endif /* OVERLOAD */

@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
a21 2
EXT char rcsid[];

d23 1
a23 2
gv_AVadd(gv)
register GV *gv;
d33 1
a33 2
gv_HVadd(gv)
register GV *gv;
d43 1
a43 2
gv_IOadd(gv)
register GV *gv;
d53 1
a53 2
gv_fetchfile(name)
char *name;
d55 1
d69 1
a69 1
    gv = *(GV**)hv_fetch(defstash, tmpbuf, tmplen, TRUE);
d71 1
a71 1
	gv_init(gv, defstash, tmpbuf, tmplen, FALSE);
d83 1
a83 6
gv_init(gv, stash, name, len, multi)
GV *gv;
HV *stash;
char *name;
STRLEN len;
int multi;
d85 1
d87 2
d91 8
a98 2
    if (SvLEN(gv))
	Safefree(SvPVX(gv));
d102 3
a104 2
    GvLINE(gv) = curcop->cop_line;
    GvFILEGV(gv) = curcop->cop_filegv;
d107 1
a107 1
    GvSTASH(gv) = stash;
d110 1
a110 1
    if (multi)
d112 24
d138 2
a139 4
static void
gv_init_sv(gv, sv_type)
GV* gv;
I32 sv_type;
d155 1
a155 5
gv_fetchmeth(stash, name, len, level)
HV* stash;
char* name;
STRLEN len;
I32 level;
d166 2
a167 1
	croak("Recursive inheritance detected");
d180 1
a180 1
	    if (!GvCVGEN(topgv) || GvCVGEN(topgv) >= sub_generation)
d187 2
d192 1
a192 1
    av = (gvp && (gv = *gvp) && gv != (GV*)&sv_undef) ? GvAV(gv) : Nullav;
d205 2
a206 1
	    if (gvp && (gv = *gvp) != (GV*)&sv_undef && (av = GvAV(gv))) {
d220 2
a221 1
	I32 items = AvFILL(av) + 1;
d226 1
a226 1
		if (dowarn)
d260 1
a260 1
		    GvCVGEN(topgv) = sub_generation;
d264 4
d275 1
a275 3
gv_fetchmethod(stash, name)
HV* stash;
char* name;
d281 1
a281 4
gv_fetchmethod_autoload(stash, name, autoload)
HV* stash;
char* name;
I32 autoload;
d283 1
d302 1
a302 1
					     HvNAME(curcop->cop_stash)));
d314 1
a314 1
	    gv = (GV*)&sv_yes;
d342 1
a342 5
gv_autoload4(stash, name, len, method)
HV* stash;
char* name;
STRLEN len;
I32 method;
d361 1
a361 1
    if (dowarn && !method && (GvCVGEN(gv) || GvSTASH(gv) != stash))
d385 1
a385 3
gv_stashpv(name,create)
char *name;
I32 create;
d391 1
a391 4
gv_stashpvn(name,namelen,create)
char *name;
U32 namelen;
I32 create;
d420 1
a420 3
gv_stashsv(sv,create)
SV *sv;
I32 create;
d430 1
a430 4
gv_fetchpv(nambeg,add,sv_type)
char *nambeg;
I32 add;
I32 sv_type;
d432 1
a439 1
    char *tmpbuf;
d449 1
a449 1
		stash = defstash;
d455 7
a461 1
		New(601, tmpbuf, len+3, char);
d467 10
a476 8
		Safefree(tmpbuf);
		if (!gvp || *gvp == (GV*)&sv_undef)
		    return Nullgv;
		gv = *gvp;

		if (SvTYPE(gv) == SVt_PVGV)
		    GvMULTI_on(gv);
		else if (!add)
a477 2
		else
		    gv_init(gv, stash, nambeg, namend - nambeg, (add & 2));
d491 1
a491 1
		return gv ? gv : (GV*)*hv_fetch(defstash, "main::", 6, TRUE);
d505 10
a514 16
		if (*name > 'I') {
		    if (*name == 'S' && (
		      strEQ(name, "SIG") ||
		      strEQ(name, "STDIN") ||
		      strEQ(name, "STDOUT") ||
		      strEQ(name, "STDERR") ))
			global = TRUE;
		}
		else if (*name > 'E') {
		    if (*name == 'I' && strEQ(name, "INC"))
			global = TRUE;
		}
		else if (*name > 'A') {
		    if (*name == 'E' && strEQ(name, "ENV"))
			global = TRUE;
		}
d517 1
a517 1
		  strEQ(name, "ARGVOUT") ))
d524 4
a527 4
		stash = defstash;
	    else if ((COP*)curcop == &compiling) {
		stash = curstash;
		if (add && (hints & HINT_STRICT_VARS) &&
d536 1
a536 1
			*gvp == (GV*)&sv_undef ||
d556 1
a556 1
		stash = curcop->cop_stash;
d559 1
a559 1
	    stash = defstash;
d565 13
a577 8
	if (add) {
	    warn("Global symbol \"%s\" requires explicit package name", name);
	    ++error_count;
	    stash = curstash ? curstash : defstash;	/* avoid core dumps */
	    add_gvflags = ((sv_type == SVt_PV) ? GVf_IMPORTED_SV
			   : (sv_type == SVt_PVAV) ? GVf_IMPORTED_AV
			   : (sv_type == SVt_PVHV) ? GVf_IMPORTED_HV
			   : 0);
d579 6
a584 2
	else
	    return Nullgv;
d591 1
a591 1
    if (!gvp || *gvp == (GV*)&sv_undef)
d600 2
d606 1
a606 1
    if (add & 4)
d608 1
a608 1
    gv_init(gv, stash, name, len, add & 2);
a618 6

    case 'a':
    case 'b':
	if (len == 1)
	    GvMULTI_on(gv);
	break;
d628 3
a630 1
	    if (add & 2 && strEQ(nambeg,"AnyDBM_File::ISA") && AvFILL(av) == -1)
d651 1
a651 1
            sv_magic((SV*)hv, (SV*)gv, 'A', 0, 0);
d659 4
a662 4
	    siggv = gv;
	    GvMULTI_on(siggv);
	    hv = GvHVn(siggv);
	    hv_magic(hv, siggv, 'S');
d667 1
a667 1
	    		sv_setsv(*init,&sv_undef);
a670 5
	    /* initialize signal stack */
	    signalstack = newAV();
	    AvREAL_off(signalstack);
	    av_extend(signalstack, 30);
	    av_fill(signalstack, 0);
d677 2
a678 2
	ampergv = gv;
	sawampersand = TRUE;
d684 2
a685 2
	leftgv = gv;
	sawampersand = TRUE;
d691 2
a692 2
	rightgv = gv;
	sawampersand = TRUE;
d698 1
a698 1
	sv_setpv(GvSV(gv),chopset);
d709 16
d727 1
a727 1
	if (dowarn && len == 1 && sv_type == SVt_PV)
a730 1
    case '!':
d746 1
d751 1
a752 1
    case '\t':
d781 1
a781 1
	formfeed = GvSV(gv);
d792 1
a792 1
	    sv_setpv(sv, patchlevel);
d802 1
a802 4
gv_fullname3(sv, gv, prefix)
SV *sv;
GV *gv;
char *prefix;
d816 1
a816 4
gv_efullname3(sv, gv, prefix)
SV *sv;
GV *gv;
char *prefix;
d826 1
a826 3
gv_fullname(sv,gv)
SV *sv;
GV *gv;
d833 1
a833 3
gv_efullname(sv,gv)
SV *sv;
GV *gv;
d839 1
a839 1
newIO()
d841 1
d850 2
a851 1
    if (!iogv)
d858 1
a858 2
gv_check(stash)
HV* stash;
d860 1
d874 1
a874 1
		if (hv != defstash)
d879 1
a879 1
		if (GvMULTI(gv))
d881 1
a881 1
		curcop->cop_line = GvLINE(gv);
d883 1
a883 1
		curcop->cop_filegv = filegv;
d894 1
a894 2
newGVgen(pack)
char *pack;
d896 1
a896 1
    return gv_fetchpv(form("%s::_GEN_%ld", pack, (long)gensym++),
d903 1
a903 2
gp_ref(gp)
GP* gp;
d915 1
a915 1
	    sub_generation++;
d922 1
a922 2
gp_free(gv)
GV* gv;
d935 1
a935 1
	sub_generation++;
d982 1
a982 2
Gv_AMupdate(stash)
HV* stash;
d984 1
d990 1
a990 1
  AMT *amtp=mg ? (AMT*)mg->mg_ptr: NULL;
d992 1
d994 2
a995 2
  if (mg && amtp->was_ok_am == amagic_generation
      && amtp->was_ok_sub == sub_generation)
d1009 2
a1010 2
  amt.was_ok_am = amagic_generation;
  amt.was_ok_sub = sub_generation;
d1016 1
a1016 1
  if (gvp && ((gv = *gvp) != (GV*)&sv_undef && (hv = GvHV(gv)))) {
d1035 1
a1035 1
        if (svp && ((sv = *svp) != &sv_undef)) {
d1040 1
a1040 1
		gv = gv_fetchmethod(stash, SvPV(sv, na));
d1101 1
a1101 1
			     SvPV(GvSV(gv), na), cp, HvNAME(stash)) );
a1138 3
/* During call to this subroutine stack can be reallocated. It is
 * advised to call SPAGAIN macro in your code after call */

d1140 1
a1140 5
amagic_call(left,right,method,flags)
SV* left;
SV* right;
int method;
int flags; 
d1142 1
d1148 1
a1148 1
  int postpr=0, inc_dec_ass=0, assignshift=assign?1:0;
d1154 1
a1154 1
			: NULL))
d1165 1
d1168 4
a1171 3
	   if (((cv = cvp[off=add_ass_amg]) && (inc_dec_ass=1))
	       || ((cv = cvp[off=add_amg]) && (postpr=1))) {
	     right = &sv_yes; lr = -1; assign = 1;
d1175 4
a1178 3
	   if (((cv = cvp[off=subtr_ass_amg])  && (inc_dec_ass=1))
	       || ((cv = cvp[off=subtr_amg]) && (postpr=1))) {
	     right = &sv_yes; lr = -1; assign = 1;
d1198 6
a1203 2
	     SV* ref=SvRV(left);
	     if (!SvROK(ref) && SvTYPE(ref) <= SVt_PVMG) {
d1208 1
a1208 1
		SV* newref = newSVsv(ref);
d1210 1
a1210 1
		SvSTASH(newref) = (HV*)SvREFCNT_inc(SvSTASH(ref));
d1254 1
a1254 1
			  : NULL))
d1324 1
d1341 1
d1346 22
a1367 4
    if ((method + assignshift==off 
	 && (assign || method==inc_amg || method==dec_amg))
	|| inc_dec_ass) RvDEEPCP(left);
  }
d1380 1
d1382 4
a1385 4
    SAVESPTR(op);
    op = (OP *) &myop;
    if (PERLDB_SUB && curstash != debstash)
	op->op_private |= OPpENTERSUB_DB;
d1387 1
a1387 1
    pp_pushmark();
d1389 1
a1389 1
    EXTEND(sp, notfound + 5);
d1392 1
a1392 1
    PUSHs( lr > 0 ? &sv_yes : ( assign ? &sv_undef : &sv_no ));
d1399 2
a1400 2
    if (op = pp_entersub())
      runops();
d1405 1
a1405 1
    PUTBACK;
d1447 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d22 1
a22 1
extern char rcsid[];
d61 3
a63 1
    char tmpbuf[1200];
d66 13
a78 2
    sprintf(tmpbuf,"::_<%s", name);
    gv = gv_fetchpv(tmpbuf, TRUE, SVt_PVGV);
d80 1
a80 1
    if (*name == '/' && (instr(name,"/lib/") || instr(name,".pm")))
d82 1
a82 1
    if (perldb)
d97 1
a97 1
    sv_upgrade(gv, SVt_PVGV);
d100 1
a100 1
    Newz(602,gp, 1, GP);
a101 1
    GvREFCNT(gv) = 1;
a142 1
    HV* lastchance;
d147 1
a147 1
    if (level > 100)
d150 1
a150 1
    gvp = (GV**)hv_fetch(stash, name, len, TRUE);
d152 15
a166 10
    DEBUG_o( deb("Looking for method %s in package %s\n",name,HvNAME(stash)) );
    topgv = *gvp;
    if (SvTYPE(topgv) != SVt_PVGV)
	gv_init(topgv, stash, name, len, TRUE);

    if (cv=GvCV(topgv)) {
	if (GvCVGEN(topgv) >= sub_generation)
	    return topgv;	/* valid cached inheritance */
	if (!GvCVGEN(topgv)) {	/* not an inheritance cache */
	    return topgv;
d168 25
a192 4
	else {
	    /* stale cached entry, just junk it */
	    GvCV(topgv) = cv = 0;
	    GvCVGEN(topgv) = 0;
a194 1
    /* if cv is still set, we have to free it if we find something to cache */
d196 1
a196 2
    gvp = (GV**)hv_fetch(stash,"ISA",3,FALSE);
    if (gvp && (gv = *gvp) != (GV*)&sv_undef && (av = GvAV(gv))) {
d208 4
a211 11
	    gv = gv_fetchmeth(basestash, name, len, level + 1);
	    if (gv) {
		if (cv) {				/* junk old undef */
		    assert(SvREFCNT(topgv) > 1);
		    SvREFCNT_dec(topgv);
		    SvREFCNT_dec(cv);
		}
		GvCV(topgv) = GvCV(gv);			/* cache the CV */
		GvCVGEN(topgv) = sub_generation;	/* valid for now */
		return gv;
	    }
d215 23
a237 7
    if (!level) {
	if (lastchance = gv_stashpv("UNIVERSAL", FALSE)) {
	    if (gv = gv_fetchmeth(lastchance, name, len, level + 1)) {
		if (cv) {				/* junk old undef */
		    assert(SvREFCNT(topgv) > 1);
		    SvREFCNT_dec(topgv);
		    SvREFCNT_dec(cv);
a238 2
		GvCV(topgv) = GvCV(gv);			/* cache the CV */
		GvCVGEN(topgv) = sub_generation;	/* valid for now */
d252 9
d266 1
a266 1
	if (*nend == ':' || *nend == '\'')
d268 2
a271 1
	char ch;
a273 1
	ch = *nsplit;
d276 7
a282 11
	*nsplit = '\0';
	if (strEQ(origname,"SUPER")) {
	    /* Degenerate case ->SUPER::method should really lookup in original stash */
	    SV *tmpstr = sv_2mortal(newSVpv(HvNAME(curcop->cop_stash),0));
	    sv_catpvn(tmpstr, "::SUPER", 7);
	    stash = gv_stashpv(SvPV(tmpstr,na),TRUE);
	    *nsplit = ch;
	    DEBUG_o( deb("Treating %s as %s::%s\n",origname,HvNAME(stash),name) );
	} else {
	    stash = gv_stashpv(origname,TRUE);
	    *nsplit = ch;
d284 2
d287 1
a288 1

d290 17
a306 30
	/* Failed obvious case - look for SUPER as last element of stash's name */
	char *packname = HvNAME(stash);
	STRLEN len     = strlen(packname);
	if (len >= 7 && strEQ(packname+len-7,"::SUPER")) {
	    /* Now look for @@.*::SUPER::ISA */
	    GV** gvp = (GV**)hv_fetch(stash,"ISA",3,FALSE);
	    if (!gvp || (gv = *gvp) == (GV*)&sv_undef || !GvAV(gv)) {
		/* No @@ISA in package ending in ::SUPER - drop suffix
		   and see if there is an @@ISA there
		 */
		HV *basestash;
		char ch = packname[len-7];
		AV *av;
		packname[len-7] = '\0';
		basestash = gv_stashpv(packname, TRUE);
		packname[len-7] = ch;
		gvp = (GV**)hv_fetch(basestash,"ISA",3,FALSE);
		if (gvp && (gv = *gvp) != (GV*)&sv_undef && (av = GvAV(gv))) {
		     /* Okay found @@ISA after dropping the SUPER, alias it */
	             SV *tmpstr = sv_2mortal(newSVpv(HvNAME(stash),0));
	             sv_catpvn(tmpstr, "::ISA", 5);
		     gv  = gv_fetchpv(SvPV(tmpstr,na),TRUE,SVt_PVGV);
                     if (gv) {
			GvAV(gv) = (AV*)SvREFCNT_inc(av);
			/* ... and re-try lookup */
			gv = gv_fetchmeth(stash, name, nend - name, 0);
		     } else {
			croak("Cannot create %s::ISA",HvNAME(stash));
		     }
		}
d308 5
a312 1
	}     
d315 23
a337 2
    if (!gv) {
	CV* cv;
d339 23
a361 14
	if (strEQ(name,"import") || strEQ(name,"unimport"))
	    gv = &sv_yes;
	else if (strNE(name, "AUTOLOAD")) {
	    gv = gv_fetchmeth(stash, "AUTOLOAD", 8, 0);
	    if (gv && (cv = GvCV(gv))) { /* One more chance... */
		SV *tmpstr = sv_2mortal(newSVpv(HvNAME(stash),0));
		sv_catpvn(tmpstr,"::", 2);
		sv_catpvn(tmpstr, name, nend - name);
		sv_setsv(GvSV(CvGV(cv)), tmpstr);
		if (tainting)
		    sv_unmagic(GvSV(CvGV(cv)), 't');
	    }
	}
    }
d370 11
a380 1
    char tmpbuf[1234];
d383 12
a394 6
    /* Use strncpy to avoid bug in VMS sprintf */
    /* sprintf(tmpbuf,"%.*s::",1200,name); */
    strncpy(tmpbuf, name, 1200);
    tmpbuf[1200] = '\0';  /* just in case . . . */
    strcat(tmpbuf, "::");
    tmpgv = gv_fetchpv(tmpbuf,create, SVt_PVHV);
d410 4
a413 1
    return gv_stashpv(SvPV(sv,na), create);
d429 1
a429 1
    bool global = FALSE;
d441 1
a441 1
	    if (!SvREFCNT(stash))	/* symbol table under destruction */
d476 1
a476 1
		return gv ? gv : *hv_fetch(defstash, "main::", 6, TRUE);
d487 2
d513 1
d540 1
a540 1
			if (GvCV(*gvp))
d560 4
d590 1
d618 1
a618 1
		gv_stashpv(pname, TRUE);
d620 1
a620 1
		gv_stashpv(pname, TRUE);
d622 1
a622 1
		gv_stashpv(pname, TRUE);
d624 1
a624 1
		gv_stashpv(pname, TRUE);
d626 1
a626 1
		gv_stashpv(pname, TRUE);
d642 1
d647 8
a654 1

d690 8
a704 1
    case '?':
d743 1
d763 1
a763 2
	    SV *sv;
	    sv = GvSV(gv);
d766 2
d775 1
a775 1
gv_fullname(sv,gv)
d778 1
d781 2
a782 2

    if (!hv)
d784 2
a785 1
    sv_setpv(sv, sv == (SV*)gv ? "*" : "");
d792 1
a792 1
gv_efullname(sv,gv)
d795 1
d797 1
a797 3
    GV* egv = GvEGV(gv);
    HV *hv;
    
d800 11
a810 3
    hv = GvSTASH(egv);
    if (!hv)
	return;
d812 7
a818 4
    sv_setpv(sv, sv == (SV*)gv ? "*" : "");
    sv_catpv(sv,HvNAME(hv));
    sv_catpvn(sv,"::", 2);
    sv_catpvn(sv,GvNAME(egv),GvNAMELEN(egv));
d831 3
a833 1
    iogv = gv_fetchpv("FileHandle::", TRUE, SVt_PVHV);
d851 3
a853 3
	for (entry = HvARRAY(stash)[i]; entry; entry = entry->hent_next) {
	    if (entry->hent_key[entry->hent_klen-1] == ':' &&
		(gv = (GV*)entry->hent_val) && (hv = GvHV(gv)) && HvNAME(hv))
d858 2
a859 2
	    else if (isALPHA(*entry->hent_key)) {
		gv = (GV*)entry->hent_val;
d867 1
a867 1
		warn("Identifier \"%s::%s\" used only once: possible typo",
d878 2
a879 2
    (void)sprintf(tokenbuf,"%s::_GEN_%ld",pack,(long)gensym++);
    return gv_fetchpv(tokenbuf,TRUE, SVt_PVGV);
d889 12
a901 1

d917 4
d931 1
a931 2
    if ((cv = gp->gp_cv) && !GvCVGEN(gv))
	SvREFCNT_dec(cv);
d975 1
d977 4
a980 5
  if (mg && (amtp=((AMT*)(mg->mg_ptr)))->was_ok_am == amagic_generation &&
             amtp->was_ok_sub == sub_generation)
      return HV_AMAGIC(stash)? TRUE: FALSE;
  gvp=(GV**)hv_fetch(stash,"OVERLOAD",8,FALSE);
  if (amtp && amtp->table) {
d982 1
a982 1
    for (i=1;i<NofAMmeth*2;i++) {
d992 7
a1002 1
    AMT amt;
a1005 10
/*  if (*(svp)==(SV*)amagic_generation && *(svp+1)==(SV*)sub_generation) {
      DEBUG_o( deb("Overload magic in package %s up-to-date\n",HvNAME(stash))
);
      return HV_AMAGIC(stash)? TRUE: FALSE;
    }*/

    amt.was_ok_am=amagic_generation;
    amt.was_ok_sub=sub_generation;
    amt.fallback=AMGfallNO;

d1008 2
a1009 2
    if ((cp=((char**)(*AMG_names))[0]) &&
	(svp=(SV**)hv_fetch(hv,cp,strlen(cp),FALSE)) && (sv = *svp)) {
d1013 6
a1018 7

    for (i=1;i<NofAMmeth*2;i++) {
      cv=0;

      if ( (cp=((char**)(*AMG_names))[i]) ) {
        svp=(SV**)hv_fetch(hv,cp,strlen(cp),FALSE);
        if (svp && ((sv = *svp) != (GV*)&sv_undef)) {
d1033 1
a1033 1
	      die("Not a subroutine reference in %%OVERLOAD");
d1036 2
a1037 2
                cv = (CV*)sv;
                break;
d1039 3
a1041 3
                if (!(cv = GvCV((GV*)sv)))
                    cv = sv_2cv(sv, &stash, &gv, TRUE);
                break;
d1045 1
a1045 1
	    die("Method for operation %s not found in package %.256s during blessing\n",
d1050 58
a1107 2
      }
      amt.table[i]=(CV*)SvREFCNT_inc(cv);
a1108 1
    sv_magic((SV*)stash, 0, 'c', (char*)&amt, sizeof(amt));
d1110 2
a1111 2
/*    HV_badAMAGIC_off(stash);*/
      HV_AMAGIC_on(stash);
d1115 4
a1118 2
/*HV_badAMAGIC_off(stash);*/
  HV_AMAGIC_off(stash);
d1141 3
a1143 1
      && (ocvp = cvp = ((oamtp=amtp=(AMT*)mg->mg_ptr)->table))
d1176 6
d1185 5
a1189 7
	     if (!SvROK(ref) && SvTYPE(ref) <= SVt_PVMG) { /* Just to be
						      * extra
						      * causious,
						      * maybe in some
						      * additional
						      * cases sv_setsv
						      * is safe too */
d1234 3
a1236 1
	       && (cvp = ((amtp=(AMT*)mg->mg_ptr)->table))
d1246 1
a1246 1
				 * concatendation */
d1273 1
a1273 1
    not_found:			/* No method found, either report or die */
d1279 6
a1284 3
        if (off==-1) off=method;
	sprintf(buf, "Operation `%s': no method found,\n\tleft argument %s%.256s,\n\tright argument %s%.256s",
		      ((char**)AMG_names)[method + assignshift],
d1292 4
a1295 2
		        "in overloaded package ":
		        "has no overloaded magic",
d1298 1
a1298 1
		        "");
d1300 1
a1300 1
	  DEBUG_o( deb(buf) );
d1302 1
a1302 1
	  die(buf);
d1309 3
a1311 2
    DEBUG_o( deb("Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %.256s%s\n",
		 ((char**)AMG_names)[off],
d1315 1
a1315 1
		             ((char**)AMG_names)[method+assignshift],
d1334 1
d1336 1
d1340 1
a1340 1
    myop.op_flags = OPf_KNOW|OPf_STACKED;
d1345 2
d1353 1
a1353 1
    PUSHs( assign ? &sv_undef : (lr>0? &sv_yes: &sv_no));
d1355 1
a1355 1
      PUSHs( sv_2mortal(newSVpv(((char**)AMG_names)[method + assignshift],0)) );
d1367 1
a1367 5

    if (notfound) {
      /* sv_2mortal(res); */
      return NULL;
    }
d1392 3
a1394 1
	SvSetSV(left,res); return res; break;
d1396 1
a1396 1
      return ans? &sv_yes: &sv_no;
d1399 1
a1399 1
	die("Copy method did not return a reference");
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d22 2
d25 2
a26 1
gv_AVadd(register GV *gv)
d36 2
a37 1
gv_HVadd(register GV *gv)
d47 2
a48 1
gv_IOadd(register GV *gv)
d58 2
a59 1
gv_fetchfile(char *name)
d61 1
a61 4
    dTHR;
    char smallbuf[256];
    char *tmpbuf;
    STRLEN tmplen;
d64 2
a65 13
    tmplen = strlen(name) + 2;
    if (tmplen < sizeof smallbuf)
	tmpbuf = smallbuf;
    else
	New(603, tmpbuf, tmplen + 1, char);
    tmpbuf[0] = '_';
    tmpbuf[1] = '<';
    strcpy(tmpbuf + 2, name);
    gv = *(GV**)hv_fetch(PL_defstash, tmpbuf, tmplen, TRUE);
    if (!isGV(gv))
	gv_init(gv, PL_defstash, tmpbuf, tmplen, FALSE);
    if (tmpbuf != smallbuf)
	Safefree(tmpbuf);
d67 1
a67 1
    if (*name == '/' && (instr(name, "/lib/") || instr(name, ".pm")))
d69 1
a69 1
    if (PERLDB_LINE)
d75 6
a80 1
gv_init(GV *gv, HV *stash, char *name, STRLEN len, int multi)
a81 1
    dTHR;
a82 2
    bool doproto = SvTYPE(gv) > SVt_NULL;
    char *proto = (doproto && SvPOK(gv)) ? SvPVX(gv) : NULL;
d84 4
a87 10
    sv_upgrade((SV*)gv, SVt_PVGV);
    if (SvLEN(gv)) {
	if (proto) {
	    SvPVX(gv) = NULL;
	    SvLEN(gv) = 0;
	    SvPOK_off(gv);
	} else
	    Safefree(SvPVX(gv));
    }
    Newz(602, gp, 1, GP);
d89 1
d91 2
a92 3
    GvLINE(gv) = PL_curcop->cop_line;
    GvFILEGV(gv) = PL_curcop->cop_filegv;
    GvCVGEN(gv) = 0;
d95 1
a95 1
    GvSTASH(gv) = (HV*)SvREFCNT_inc(stash);
d98 1
a98 1
    if (multi || doproto)              /* doproto means it _was_ mentioned */
a99 24
    if (doproto) {			/* Replicate part of newSUB here. */
	SvIOK_off(gv);
	ENTER;
	/* XXX unsafe for threads if eval_owner isn't held */
	start_subparse(0,0);		/* Create CV in compcv. */
	GvCV(gv) = PL_compcv;
	LEAVE;

	PL_sub_generation++;
	CvGV(GvCV(gv)) = (GV*)SvREFCNT_inc(gv);
	CvFILEGV(GvCV(gv)) = PL_curcop->cop_filegv;
	CvSTASH(GvCV(gv)) = PL_curstash;
#ifdef USE_THREADS
	CvOWNER(GvCV(gv)) = 0;
	if (!CvMUTEXP(GvCV(gv))) {
	    New(666, CvMUTEXP(GvCV(gv)), 1, perl_mutex);
	    MUTEX_INIT(CvMUTEXP(GvCV(gv)));
	}
#endif /* USE_THREADS */
	if (proto) {
	    sv_setpv((SV*)GvCV(gv), proto);
	    Safefree(proto);
	}
    }
d102 4
a105 2
STATIC void
gv_init_sv(GV *gv, I32 sv_type)
d121 5
a125 1
gv_fetchmeth(HV *stash, char *name, STRLEN len, I32 level)
d131 1
d136 4
a139 3
    if ((level > 100) || (level < -100))
	croak("Recursive inheritance detected while looking for method '%s' in package '%s'",
	      name, HvNAME(stash));
d142 13
a154 15

    gvp = (GV**)hv_fetch(stash, name, len, (level >= 0));
    if (!gvp)
	topgv = Nullgv;
    else {
	topgv = *gvp;
	if (SvTYPE(topgv) != SVt_PVGV)
	    gv_init(topgv, stash, name, len, TRUE);
	if (cv = GvCV(topgv)) {
	    /* If genuine method or valid cache entry, use it */
	    if (!GvCVGEN(topgv) || GvCVGEN(topgv) == PL_sub_generation)
		return topgv;
	    /* Stale cached entry: junk it */
	    SvREFCNT_dec(cv);
	    GvCV(topgv) = cv = Nullcv;
a156 29
	else if (GvCVGEN(topgv) == PL_sub_generation)
	    return 0;  /* cache indicates sub doesn't exist */
    }

    gvp = (GV**)hv_fetch(stash, "ISA", 3, FALSE);
    av = (gvp && (gv = *gvp) && gv != (GV*)&PL_sv_undef) ? GvAV(gv) : Nullav;

    /* create and re-create @@.*::SUPER::ISA on demand */
    if (!av || !SvMAGIC(av)) {
	char* packname = HvNAME(stash);
	STRLEN packlen = strlen(packname);

	if (packlen >= 7 && strEQ(packname + packlen - 7, "::SUPER")) {
	    HV* basestash;

	    packlen -= 7;
	    basestash = gv_stashpvn(packname, packlen, TRUE);
	    gvp = (GV**)hv_fetch(basestash, "ISA", 3, FALSE);
	    if (gvp && (gv = *gvp) != (GV*)&PL_sv_undef && (av = GvAV(gv))) {
		dTHR;		/* just for SvREFCNT_dec */
		gvp = (GV**)hv_fetch(stash, "ISA", 3, TRUE);
		if (!gvp || !(gv = *gvp))
		    croak("Cannot create %s::ISA", HvNAME(stash));
		if (SvTYPE(gv) != SVt_PVGV)
		    gv_init(gv, stash, "ISA", 3, TRUE);
		SvREFCNT_dec(GvAV(gv));
		GvAV(gv) = (AV*)SvREFCNT_inc(av);
	    }
	}
d158 1
d160 2
a161 1
    if (av) {
d163 1
a163 2
	/* NOTE: No support for tied ISA */
	I32 items = AvFILLp(av) + 1;
d168 1
a168 1
		if (PL_dowarn)
d173 11
a183 4
	    gv = gv_fetchmeth(basestash, name, len,
			      (level >= 0) ? level + 1 : level - 1);
	    if (gv)
		goto gotcha;
d187 7
a193 23
    /* if at top level, try UNIVERSAL */

    if (level == 0 || level == -1) {
	HV* lastchance;

	if (lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE)) {
	    if (gv = gv_fetchmeth(lastchance, name, len,
				  (level >= 0) ? level + 1 : level - 1)) {
	  gotcha:
		/*
		 * Cache method in topgv if:
		 *  1. topgv has no synonyms (else inheritance crosses wires)
		 *  2. method isn't a stub (else AUTOLOAD fails spectacularly)
		 */
		if (topgv &&
		    GvREFCNT(topgv) == 1 &&
		    (cv = GvCV(gv)) &&
		    (CvROOT(cv) || CvXSUB(cv)))
		{
		    if (cv = GvCV(topgv))
			SvREFCNT_dec(cv);
		    GvCV(topgv) = (CV*)SvREFCNT_inc(GvCV(gv));
		    GvCVGEN(topgv) = PL_sub_generation;
d195 2
a198 4
	    else if (topgv && GvREFCNT(topgv) == 1) {
		/* cache the fact that the method is not defined */
		GvCVGEN(topgv) = PL_sub_generation;
	    }
d206 3
a208 1
gv_fetchmethod(HV *stash, char *name)
a209 7
    return gv_fetchmethod_autoload(stash, name, TRUE);
}

GV *
gv_fetchmethod_autoload(HV *stash, char *name, I32 autoload)
{
    dTHR;
d215 1
a215 1
	if (*nend == '\'')
a216 2
	else if (*nend == ':' && *(nend + 1) == ':')
	    nsplit = ++nend;
d219 1
d222 1
d225 11
a235 7
	if ((nsplit - origname) == 5 && strnEQ(origname, "SUPER", 5)) {
	    /* ->SUPER::method should really be looked up in original stash */
	    SV *tmpstr = sv_2mortal(newSVpvf("%s::SUPER",
					     HvNAME(PL_curcop->cop_stash)));
	    stash = gv_stashpvn(SvPVX(tmpstr), SvCUR(tmpstr), TRUE);
	    DEBUG_o( deb("Treating %s as %s::%s\n",
			 origname, HvNAME(stash), name) );
a236 2
	else
	    stash = gv_stashpvn(origname, nsplit - origname, TRUE);
d238 1
a239 1
    gv = gv_fetchmeth(stash, name, nend - name, 0);
d241 30
a270 17
	if (strEQ(name,"import"))
	    gv = (GV*)&PL_sv_yes;
	else if (autoload)
	    gv = gv_autoload4(stash, name, nend - name, TRUE);
    }
    else if (autoload) {
	CV* cv = GvCV(gv);
	if (!CvROOT(cv) && !CvXSUB(cv)) {
	    GV* stubgv;
	    GV* autogv;

	    if (CvANON(cv))
		stubgv = gv;
	    else {
		stubgv = CvGV(cv);
		if (GvCV(stubgv) != cv)		/* orphaned import */
		    stubgv = gv;
d272 1
a272 5
	    autogv = gv_autoload4(GvSTASH(stubgv),
				  GvNAME(stubgv), GvNAMELEN(stubgv), TRUE);
	    if (autogv)
		gv = autogv;
	}
d275 2
a276 2
    return gv;
}
d278 14
a291 40
GV*
gv_autoload4(HV *stash, char *name, STRLEN len, I32 method)
{
    static char autoload[] = "AUTOLOAD";
    static STRLEN autolen = 8;
    GV* gv;
    CV* cv;
    HV* varstash;
    GV* vargv;
    SV* varsv;

    if (len == autolen && strnEQ(name, autoload, autolen))
	return Nullgv;
    if (!(gv = gv_fetchmeth(stash, autoload, autolen, FALSE)))
	return Nullgv;
    cv = GvCV(gv);

    /*
     * Inheriting AUTOLOAD for non-methods works ... for now.
     */
    if (PL_dowarn && !method && (GvCVGEN(gv) || GvSTASH(gv) != stash))
	warn(
	  "Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated",
	     HvNAME(stash), (int)len, name);

    /*
     * Given &FOO::AUTOLOAD, set $FOO::AUTOLOAD to desired function name.
     * The subroutine's original name may not be "AUTOLOAD", so we don't
     * use that, but for lack of anything better we will use the sub's
     * original package to look up $AUTOLOAD.
     */
    varstash = GvSTASH(CvGV(cv));
    vargv = *(GV**)hv_fetch(varstash, autoload, autolen, TRUE);
    if (!isGV(vargv))
	gv_init(vargv, varstash, autoload, autolen, FALSE);
    varsv = GvSV(vargv);
    sv_setpv(varsv, HvNAME(stash));
    sv_catpvn(varsv, "::", 2);
    sv_catpvn(varsv, name, len);
    SvTAINTED_off(varsv);
d296 3
a298 7
gv_stashpv(char *name, I32 create)
{
    return gv_stashpvn(name, strlen(name), create);
}

HV*
gv_stashpvn(char *name, U32 namelen, I32 create)
d300 1
a300 2
    char smallbuf[256];
    char *tmpbuf;
d303 6
a308 12

    if (namelen + 3 < sizeof smallbuf)
	tmpbuf = smallbuf;
    else
	New(606, tmpbuf, namelen + 3, char);
    Copy(name,tmpbuf,namelen,char);
    tmpbuf[namelen++] = ':';
    tmpbuf[namelen++] = ':';
    tmpbuf[namelen] = '\0';
    tmpgv = gv_fetchpv(tmpbuf, create, SVt_PVHV);
    if (tmpbuf != smallbuf)
	Safefree(tmpbuf);
d320 3
a322 1
gv_stashsv(SV *sv, I32 create)
d324 1
a324 4
    register char *ptr;
    STRLEN len;
    ptr = SvPV(sv,len);
    return gv_stashpvn(ptr, len, create);
d329 4
a332 1
gv_fetchpv(char *nambeg, I32 add, I32 sv_type)
a333 1
    dTHR;
d340 2
a341 1
    U32 add_gvflags = 0;
d351 2
a352 2
		stash = PL_defstash;
	    if (!stash || !SvREFCNT(stash)) /* symbol table under destruction */
d357 1
a357 7
		char smallbuf[256];
		char *tmpbuf;

		if (len + 3 < sizeof smallbuf)
		    tmpbuf = smallbuf;
		else
		    New(601, tmpbuf, len+3, char);
d363 8
a370 10
		gv = gvp ? *gvp : Nullgv;
		if (gv && gv != (GV*)&PL_sv_undef) {
		    if (SvTYPE(gv) != SVt_PVGV)
			gv_init(gv, stash, tmpbuf, len, (add & GV_ADDMULTI));
		    else
			GvMULTI_on(gv);
		}
		if (tmpbuf != smallbuf)
		    Safefree(tmpbuf);
		if (!gv || gv == (GV*)&PL_sv_undef)
d372 2
d387 1
a387 1
		return gv ? gv : (GV*)*hv_fetch(PL_defstash, "main::", 6, TRUE);
a397 2
	    bool global = FALSE;

d399 16
a414 10
		if (*name == 'S' && (
		    strEQ(name, "SIG") ||
		    strEQ(name, "STDIN") ||
		    strEQ(name, "STDOUT") ||
		    strEQ(name, "STDERR")))
		    global = TRUE;
		else if (*name == 'I' && strEQ(name, "INC"))
		    global = TRUE;
		else if (*name == 'E' && strEQ(name, "ENV"))
		    global = TRUE;
d417 1
a417 1
		  strEQ(name, "ARGVOUT")))
a421 1

d423 4
a426 4
		stash = PL_defstash;
	    else if ((COP*)PL_curcop == &PL_compiling) {
		stash = PL_curstash;
		if (add && (PL_hints & HINT_STRICT_VARS) &&
d435 1
a435 1
			*gvp == (GV*)&PL_sv_undef ||
d448 1
a448 1
			if (GvCVu(*gvp))
d455 1
a455 1
		stash = PL_curcop->cop_stash;
d458 1
a458 1
	    stash = PL_defstash;
d464 6
a469 1
	if (!add)
a470 18
	if (add & ~GV_ADDMULTI) {
	    char sv_type_char = ((sv_type == SVt_PV) ? '$'
				 : (sv_type == SVt_PVAV) ? '@@'
				 : (sv_type == SVt_PVHV) ? '%'
				 : 0);
	    if (sv_type_char) 
		warn("Global symbol \"%c%s\" requires explicit package name",
		     sv_type_char, name);
	    else
		warn("Global symbol \"%s\" requires explicit package name",
		     name);
	}
	++PL_error_count;
	stash = PL_curstash ? PL_curstash : PL_defstash;	/* avoid core dumps */
	add_gvflags = ((sv_type == SVt_PV) ? GVf_IMPORTED_SV
		       : (sv_type == SVt_PVAV) ? GVf_IMPORTED_AV
		       : (sv_type == SVt_PVHV) ? GVf_IMPORTED_HV
		       : 0);
d477 1
a477 1
    if (!gvp || *gvp == (GV*)&PL_sv_undef)
a485 2
    } else if (add & GV_NOINIT) {
	return gv;
d490 1
a490 1
    if (add & GV_ADDWARN)
d492 1
a492 1
    gv_init(gv, stash, name, len, add & GV_ADDMULTI);
a493 1
    GvFLAGS(gv) |= add_gvflags;
d502 6
d517 1
a517 3
	    /* NOTE: No support for tied ISA */
	    if ((add & GV_ADDMULTI) && strEQ(nambeg,"AnyDBM_File::ISA")
		&& AvFILLp(av) == -1)
d521 1
a521 1
		gv_stashpvn(pname, 9, TRUE);
d523 1
a523 1
		gv_stashpvn(pname, 7, TRUE);
d525 1
a525 1
		gv_stashpvn(pname, 9, TRUE);
d527 1
a527 1
		gv_stashpvn(pname, 9, TRUE);
d529 1
a529 1
		gv_stashpvn(pname, 9, TRUE);
d538 1
a538 1
            hv_magic(hv, gv, 'A');
d545 10
a554 13
	    I32 i;
	    PL_siggv = gv;
	    GvMULTI_on(PL_siggv);
	    hv = GvHVn(PL_siggv);
	    hv_magic(hv, PL_siggv, 'S');
	    for(i=1;sig_name[i];i++) {
	    	SV ** init;
	    	init=hv_fetch(hv,sig_name[i],strlen(sig_name[i]),1);
	    	if(init)
	    		sv_setsv(*init,&PL_sv_undef);
	    	psig_ptr[i] = 0;
	    	psig_name[i] = 0;
	    }
d561 2
a562 2
	PL_ampergv = gv;
	PL_sawampersand = TRUE;
d568 2
a569 2
	PL_leftgv = gv;
	PL_sawampersand = TRUE;
d575 2
a576 2
	PL_rightgv = gv;
	PL_sawampersand = TRUE;
d582 1
a582 1
	sv_setpv(GvSV(gv),PL_chopset);
a584 24
    case '?':
	if (len > 1)
	    break;
#ifdef COMPLEX_STATUS
	sv_upgrade(GvSV(gv), SVt_PVLV);
#endif
	goto magicalize;

    case '!':
	if (len > 1)
	    break;
	if (sv_type > SVt_PV && PL_curcop != &PL_compiling) {
	    HV* stash = gv_stashpvn("Errno",5,FALSE);
	    if(!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
		dSP;
		PUTBACK;
		perl_require_pv("Errno.pm");
		SPAGAIN;
		stash = gv_stashpvn("Errno",5,FALSE);
		if (!stash || !(gv_fetchmethod(stash, "TIEHASH")))
		    croak("Can't use %%! because Errno.pm is not available");
	    }
	}
	goto magicalize;
d587 1
a587 1
	if (PL_dowarn && len == 1 && sv_type == SVt_PV)
d591 2
a607 1
    case '\003':
a611 1
    case '\011':	/* NOT \t in EBCDIC */
d613 1
a630 1
    case '\023':
d641 1
a641 1
	PL_formfeed = GvSV(gv);
d650 2
a651 1
	    SV *sv = GvSV(gv);
d653 1
a653 3
	    sv_setpv(sv, PL_patchlevel);
	    (void)sv_2nv(sv);
	    SvREADONLY_on(sv);
d661 3
a663 1
gv_fullname3(SV *sv, GV *gv, char *prefix)
d666 2
a667 2
    if (!hv) {
	SvOK_off(sv);
d669 1
a669 2
    }
    sv_setpv(sv, prefix ? prefix : "");
d676 3
a678 1
gv_efullname3(SV *sv, GV *gv, char *prefix)
d680 3
a682 1
    GV *egv = GvEGV(gv);
d685 3
a687 2
    gv_fullname3(sv, egv, prefix);
}
d689 4
a692 12
/* XXX compatibility with versions <= 5.003. */
void
gv_fullname(SV *sv, GV *gv)
{
    gv_fullname3(sv, gv, sv == (SV*)gv ? "*" : "");
}

/* XXX compatibility with versions <= 5.003. */
void
gv_efullname(SV *sv, GV *gv)
{
    gv_efullname3(sv, gv, sv == (SV*)gv ? "*" : "");
d696 1
a696 1
newIO(void)
a697 1
    dTHR;
d705 1
a705 4
    iogv = gv_fetchpv("FileHandle::", FALSE, SVt_PVHV);
    /* unless exists($main::{FileHandle}) and defined(%main::FileHandle::) */
    if (!(iogv && GvHV(iogv) && HvARRAY(GvHV(iogv))))
      iogv = gv_fetchpv("IO::Handle::", TRUE, SVt_PVHV);
d711 2
a712 1
gv_check(HV *stash)
a713 1
    dTHR;
d723 3
a725 3
	for (entry = HvARRAY(stash)[i]; entry; entry = HeNEXT(entry)) {
	    if (HeKEY(entry)[HeKLEN(entry)-1] == ':' &&
		(gv = (GV*)HeVAL(entry)) && (hv = GvHV(gv)) && HvNAME(hv))
d727 1
a727 1
		if (hv != PL_defstash)
d730 3
a732 3
	    else if (isALPHA(*HeKEY(entry))) {
		gv = (GV*)HeVAL(entry);
		if (SvTYPE(gv) != SVt_PVGV || GvMULTI(gv))
d734 1
a734 1
		PL_curcop->cop_line = GvLINE(gv);
d736 1
a736 1
		PL_curcop->cop_filegv = filegv;
d739 1
a739 1
		warn("Name \"%s::%s\" used only once: possible typo",
d747 2
a748 1
newGVgen(char *pack)
d750 2
a751 2
    return gv_fetchpv(form("%s::_GEN_%ld", pack, (long)PL_gensym++),
		      TRUE, SVt_PVGV);
d757 2
a758 1
gp_ref(GP *gp)
a760 12
    if (gp->gp_cv) {
	if (gp->gp_cvgen) {
	    /* multi-named GPs cannot be used for method cache */
	    SvREFCNT_dec(gp->gp_cv);
	    gp->gp_cv = Nullcv;
	    gp->gp_cvgen = 0;
	}
	else {
	    /* Adding a new name to a subroutine invalidates method cache */
	    PL_sub_generation++;
	}
    }
d762 1
d766 2
a767 1
gp_free(GV *gv)
a777 4
    if (gp->gp_cv) {
	/* Deleting the name of a subroutine invalidates method cache */
	PL_sub_generation++;
    }
d788 2
a789 1
    SvREFCNT_dec(gp->gp_cv);
d824 2
a825 1
Gv_AMupdate(HV *stash)
a826 1
  dTHR;  
d832 7
a838 8
  AMT *amtp = (mg) ? (AMT*)mg->mg_ptr: (AMT *) NULL;
  AMT amt;
  STRLEN n_a;

  if (mg && amtp->was_ok_am == PL_amagic_generation
      && amtp->was_ok_sub == PL_sub_generation)
      return AMT_AMAGIC(amtp);
  if (amtp && AMT_AMAGIC(amtp)) {	/* Have table. */
d840 1
a840 1
    for (i=1; i<NofAMmeth; i++) {
d850 1
a850 8
  amt.was_ok_am = PL_amagic_generation;
  amt.was_ok_sub = PL_sub_generation;
  amt.fallback = AMGfallNO;
  amt.flags = 0;

#ifdef OVERLOAD_VIA_HASH
  gvp=(GV**)hv_fetch(stash,"OVERLOAD",8,FALSE);	/* A shortcut */
  if (gvp && ((gv = *gvp) != (GV*)&PL_sv_undef && (hv = GvHV(gv)))) {
d854 1
d858 10
d870 2
a871 2
    if (( cp = (char *)AMG_names[0] ) &&
	(svp = (SV**)hv_fetch(hv,cp,strlen(cp),FALSE)) && (sv = *svp)) {
d875 7
a881 6
    for (i = 1; i < NofAMmeth; i++) {
      cv = 0;
      cp = (char *)AMG_names[i];
      
        svp = (SV**)hv_fetch(hv, cp, strlen(cp), FALSE);
        if (svp && ((sv = *svp) != &PL_sv_undef)) {
d886 1
a886 1
		gv = gv_fetchmethod(stash, SvPV(sv, n_a));
d896 1
a896 1
	      croak("Not a subroutine reference in overload table");
d899 2
a900 2
              cv = (CV*)sv;
              break;
d902 3
a904 3
              if (!(cv = GvCVu((GV*)sv)))
                cv = sv_2cv(sv, &stash, &gv, TRUE);
              break;
d908 1
a908 1
	    croak("Method for operation %s not found in package %.256s during blessing\n",
d913 2
a914 58
#else
  {
    int filled = 0;
    int i;
    const char *cp;
    SV* sv = NULL;
    SV** svp;

    /* Work with "fallback" key, which we assume to be first in AMG_names */

    if ( cp = AMG_names[0] ) {
	/* Try to find via inheritance. */
	gv = gv_fetchmeth(stash, "()", 2, -1); /* A cookie: "()". */
	if (gv) sv = GvSV(gv);

	if (!gv) goto no_table;
	else if (SvTRUE(sv)) amt.fallback=AMGfallYES;
	else if (SvOK(sv)) amt.fallback=AMGfallNEVER;
    }

    for (i = 1; i < NofAMmeth; i++) {
	SV *cookie = sv_2mortal(newSVpvf("(%s", cp = AMG_names[i]));
	DEBUG_o( deb("Checking overloading of `%s' in package `%.256s'\n",
		     cp, HvNAME(stash)) );
	/* don't fill the cache while looking up! */
	gv = gv_fetchmeth(stash, SvPVX(cookie), SvCUR(cookie), -1);
        cv = 0;
        if(gv && (cv = GvCV(gv))) {
	    if (GvNAMELEN(CvGV(cv)) == 3 && strEQ(GvNAME(CvGV(cv)), "nil")
		&& strEQ(HvNAME(GvSTASH(CvGV(cv))), "overload")) {
		/* GvSV contains the name of the method. */
		GV *ngv;
		
		DEBUG_o( deb("Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n", 
			     SvPV(GvSV(gv), n_a), cp, HvNAME(stash)) );
		if (!SvPOK(GvSV(gv)) 
		    || !(ngv = gv_fetchmethod_autoload(stash, SvPVX(GvSV(gv)),
						       FALSE)))
		{
		    /* Can be an import stub (created by `can'). */
		    if (GvCVGEN(gv)) {
			croak("Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'", 
			      (SvPOK(GvSV(gv)) ?  SvPVX(GvSV(gv)) : "???" ),
			      cp, HvNAME(stash));
		    } else
			croak("Cannot resolve method `%.256s' overloading `%s' in package `%.256s'", 
			      (SvPOK(GvSV(gv)) ?  SvPVX(GvSV(gv)) : "???" ),
			      cp, HvNAME(stash));
		}
		cv = GvCV(gv = ngv);
	    }
	    DEBUG_o( deb("Overloading `%s' in package `%.256s' via `%.256s::%.256s' \n",
			 cp, HvNAME(stash), HvNAME(GvSTASH(CvGV(cv))),
			 GvNAME(CvGV(cv))) );
	    filled = 1;
	}
#endif 
	amt.table[i]=(CV*)SvREFCNT_inc(cv);
d916 1
d918 2
a919 2
      AMT_AMAGIC_on(&amt);
      sv_magic((SV*)stash, 0, 'c', (char*)&amt, sizeof(AMT));
d923 2
a924 4
  /* Here we have no table: */
 no_table:
  AMT_AMAGIC_off(&amt);
  sv_magic((SV*)stash, 0, 'c', (char*)&amt, sizeof(AMTS));
d928 3
d932 5
a936 1
amagic_call(SV *left, SV *right, int method, int flags)
a937 1
  dTHR;
d943 1
a943 1
  int postpr = 0, force_cpy = 0, assignshift = assign ? 1 : 0;
d947 1
a947 3
      && (ocvp = cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr) 
			? (oamtp = amtp = (AMT*)mg->mg_ptr)->table
			: (CV **) NULL))
a957 1
      /* In all the covered cases we should be called with assign==0. */
d960 3
a962 4
	   force_cpy = 1;
	   if ((cv = cvp[off=add_ass_amg])
	       || ((cv = cvp[off = add_amg]) && (force_cpy = 0, postpr = 1))) {
	     right = &PL_sv_yes; lr = -1; assign = 1;
d966 3
a968 4
	   force_cpy = 1;
	   if ((cv = cvp[off = subtr_ass_amg])
	       || ((cv = cvp[off = subtr_amg]) && (force_cpy = 0, postpr=1))) {
	     right = &PL_sv_yes; lr = -1; assign = 1;
a979 6
 case not_amg:
   (void)((cv = cvp[off=bool__amg]) 
	  || (cv = cvp[off=numer_amg])
	  || (cv = cvp[off=string_amg]));
   postpr = 1;
   break;
d982 9
a990 11
	     /*
		  * SV* ref causes confusion with the interpreter variable of
		  * the same name
		  */
	     SV* tmpRef=SvRV(left);
	     if (!SvROK(tmpRef) && SvTYPE(tmpRef) <= SVt_PVMG) {
		/*
		 * Just to be extra cautious.  Maybe in some
		 * additional cases sv_setsv is safe, too.
		 */
		SV* newref = newSVsv(tmpRef);
d992 1
a992 1
		SvSTASH(newref) = (HV*)SvREFCNT_inc(SvSTASH(tmpRef));
d1034 1
a1034 3
	       && (cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr) 
			  ? (amtp = (AMT*)mg->mg_ptr)->table
			  : (CV **) NULL))
d1044 1
a1044 1
				 * concatenation */
d1071 1
a1071 1
    not_found:			/* No method found, either report or croak */
d1077 3
a1079 6
	SV *msg;
	if (off==-1) off=method;
	msg = sv_2mortal(newSVpvf(
		      "Operation `%s': no method found,%sargument %s%s%s%s",
		      AMG_names[method + assignshift],
		      (flags & AMGf_unary ? " " : "\n\tleft "),
d1087 2
a1088 4
		        ",\n\tright argument in overloaded package ":
		        (flags & AMGf_unary 
			 ? ""
			 : ",\n\tright argument has no overloaded magic"),
d1091 1
a1091 1
		        ""));
d1093 1
a1093 1
	  DEBUG_o( deb("%s", SvPVX(msg)) );
d1095 1
a1095 1
	  croak("%_", msg);
a1098 1
      force_cpy = force_cpy || assign;
d1102 2
a1103 3
    DEBUG_o( deb(
  "Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %s%s\n",
		 AMG_names[off],
d1107 1
a1107 1
		             AMG_names[method+assignshift],
a1113 1
  }
d1118 4
a1121 22
    /* We need to copy in following cases:
     * a) Assignment form was called.
     * 		assignshift==1,  assign==T, method + 1 == off
     * b) Increment or decrement, called directly.
     * 		assignshift==0,  assign==0, method + 0 == off
     * c) Increment or decrement, translated to assignment add/subtr.
     * 		assignshift==0,  assign==T, 
     *		force_cpy == T
     * d) Increment or decrement, translated to nomethod.
     * 		assignshift==0,  assign==0, 
     *		force_cpy == T
     * e) Assignment form translated to nomethod.
     * 		assignshift==1,  assign==T, method + 1 != off
     *		force_cpy == T
     */
    /*	off is method, method+assignshift, or a result of opcode substitution.
     *	In the latter case assignshift==0, so only notfound case is important.
     */
  if (( (method + assignshift == off)
	&& (assign || (method == inc_amg) || (method == dec_amg)))
      || force_cpy)
    RvDEEPCP(left);
a1125 1
    bool oldcatch = CATCH_GET;
a1126 1
    CATCH_SET(TRUE);
d1130 1
a1130 1
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;
a1131 1
    PUSHSTACKi(PERLSI_OVERLOAD);
d1133 2
a1134 4
    SAVEOP();
    PL_op = (OP *) &myop;
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	PL_op->op_private |= OPpENTERSUB_DB;
d1136 1
a1136 1
    pp_pushmark(ARGS);
d1138 1
a1138 1
    EXTEND(SP, notfound + 5);
d1141 1
a1141 1
    PUSHs( lr > 0 ? &PL_sv_yes : ( assign ? &PL_sv_undef : &PL_sv_no ));
d1143 1
a1143 1
      PUSHs( sv_2mortal(newSVpv((char *)AMG_names[method + assignshift],0)) );
d1148 2
a1149 2
    if (PL_op = pp_entersub(ARGS))
      CALLRUNOPS();
d1154 6
a1159 2
    POPSTACK;
    CATCH_SET(oldcatch);
d1184 1
a1184 3
	SvSetSV(left,res); return left;
      case not_amg:
	ans=!SvOK(res); break;
d1186 1
a1186 1
      return boolSV(ans);
d1189 1
a1189 1
	croak("Copy method did not return a reference");
a1197 1

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a19 1
#define PERL_IN_GV_C
d23 1
a23 1
Perl_gv_AVadd(pTHX_ register GV *gv)
d26 1
a26 1
	Perl_croak(aTHX_ "Bad symbol for array");
d33 1
a33 1
Perl_gv_HVadd(pTHX_ register GV *gv)
d36 1
a36 1
	Perl_croak(aTHX_ "Bad symbol for hash");
d43 1
a43 1
Perl_gv_IOadd(pTHX_ register GV *gv)
d46 1
a46 1
	Perl_croak(aTHX_ "Bad symbol for filehandle");
d53 1
a53 1
Perl_gv_fetchfile(pTHX_ const char *name)
a60 3
    if (!PL_defstash)
	return Nullgv;

d70 1
a70 1
    if (!isGV(gv)) {
a71 4
	sv_setpv(GvSV(gv), name);
	if (PERLDB_LINE)
	    hv_magic(GvHVn(gv_AVadd(gv)), gv, 'L');
    }
d74 5
d83 1
a83 1
Perl_gv_init(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, int multi)
d102 2
a103 2
    GvLINE(gv) = CopLINE(PL_curcop);
    GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : "";
d122 1
a122 1
	CvFILE(GvCV(gv)) = CopFILE(PL_curcop);
d139 1
a139 1
S_gv_init_sv(pTHX_ GV *gv, I32 sv_type)
a153 21
/*
=for apidoc gv_fetchmeth

Returns the glob with the given C<name> and a defined subroutine or
C<NULL>.  The glob lives in the given C<stash>, or in the stashes
accessible via @@ISA and @@UNIVERSAL. 

The argument C<level> should be either 0 or -1.  If C<level==0>, as a
side-effect creates a glob with the given C<name> in the given C<stash>
which in the case of success contains an alias for the subroutine, and sets
up caching info for this glob.  Similarly for all the searched stashes. 

This function grants C<"SUPER"> token as a postfix of the stash name. The
GV returned from C<gv_fetchmeth> may be a method cache entry, which is not
visible to Perl code.  So when calling C<call_sv>, you should not use
the GV directly; instead, you should use the method's CV, which can be
obtained from the GV with the C<GvCV> macro. 

=cut
*/

d155 1
a155 1
Perl_gv_fetchmeth(pTHX_ HV *stash, const char *name, STRLEN len, I32 level)
d166 1
a166 1
	Perl_croak(aTHX_ "Recursive inheritance detected while looking for method '%s' in package '%s'",
d169 1
a169 1
    DEBUG_o( Perl_deb(aTHX_ "Looking for method %s in package %s\n",name,HvNAME(stash)) );
d178 1
a178 1
	if ((cv = GvCV(topgv))) {
d209 1
a209 1
		    Perl_croak(aTHX_ "Cannot create %s::ISA", HvNAME(stash));
d226 2
a227 3
		dTHR;		/* just for ckWARN */
		if (ckWARN(WARN_MISC))
		    Perl_warner(aTHX_ WARN_MISC, "Can't locate package %s for @@%s::ISA",
d243 3
a245 4
	if ((lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE))) {
	    if ((gv = gv_fetchmeth(lastchance, name, len,
				  (level >= 0) ? level + 1 : level - 1)))
	    {
d257 1
a257 1
		    if ((cv = GvCV(topgv)))
a273 8
/*
=for apidoc gv_fetchmethod

See L<gv_fetchmethod_autoload>.

=cut
*/

d275 1
a275 1
Perl_gv_fetchmethod(pTHX_ HV *stash, const char *name)
a279 28
/*
=for apidoc gv_fetchmethod_autoload

Returns the glob which contains the subroutine to call to invoke the method
on the C<stash>.  In fact in the presence of autoloading this may be the
glob for "AUTOLOAD".  In this case the corresponding variable $AUTOLOAD is
already setup. 

The third parameter of C<gv_fetchmethod_autoload> determines whether
AUTOLOAD lookup is performed if the given method is not present: non-zero
means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. 
Calling C<gv_fetchmethod> is equivalent to calling C<gv_fetchmethod_autoload>
with a non-zero C<autoload> parameter. 

These functions grant C<"SUPER"> token as a prefix of the method name. Note
that if you want to keep the returned glob for a long time, you need to
check for it being "AUTOLOAD", since at the later time the call may load a
different subroutine due to $AUTOLOAD changing its value. Use the glob
created via a side effect to do this. 

These functions have the same side-effects and as C<gv_fetchmeth> with
C<level==0>.  C<name> should be writable if contains C<':'> or C<'
''>. The warning against passing the GV returned by C<gv_fetchmeth> to
C<call_sv> apply equally to these functions. 

=cut
*/

d281 1
a281 1
Perl_gv_fetchmethod_autoload(pTHX_ HV *stash, const char *name, I32 autoload)
d284 2
a285 2
    register const char *nend;
    const char *nsplit = 0;
d295 1
a295 1
	const char *origname = name;
d301 2
a302 2
	    SV *tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_ "%s::SUPER",
						  CopSTASHPV(PL_curcop)));
d304 1
a304 1
	    DEBUG_o( Perl_deb(aTHX_ "Treating %s as %s::%s\n",
d342 1
a342 1
Perl_gv_autoload4(pTHX_ HV *stash, const char *name, STRLEN len, I32 method)
a343 1
    dTHR;
d361 2
a362 3
    if (ckWARN(WARN_DEPRECATED) && !method && 
	(GvCVGEN(gv) || GvSTASH(gv) != stash))
	Perl_warner(aTHX_ WARN_DEPRECATED,
a383 11
/*
=for apidoc gv_stashpv

Returns a pointer to the stash for a specified package.  C<name> should
be a valid UTF-8 string.  If C<create> is set then the package will be
created if it does not already exist.  If C<create> is not set and the
package does not exist then NULL is returned.

=cut
*/

d385 1
a385 1
Perl_gv_stashpv(pTHX_ const char *name, I32 create)
d391 1
a391 1
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 create)
a418 9
/*
=for apidoc gv_stashsv

Returns a pointer to the stash for a specified package, which must be a
valid UTF-8 string.  See C<gv_stashpv>.

=cut
*/

d420 1
a420 1
Perl_gv_stashsv(pTHX_ SV *sv, I32 create)
d430 1
a430 1
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, I32 sv_type)
d433 1
a433 1
    register const char *name = nambeg;
d437 1
a437 1
    register const char *namend;
d445 2
a446 2
	if ((*namend == ':' && namend[1] == ':')
	    || (*namend == '\'' && namend[1]))
d501 1
a501 1
	if (isIDFIRST_lazy(name)) {
d541 3
a543 3
		    else if ((sv_type == SVt_PV   && !GvIMPORTED_SV(*gvp)) ||
			     (sv_type == SVt_PVAV && !GvIMPORTED_AV(*gvp)) ||
			     (sv_type == SVt_PVHV && !GvIMPORTED_HV(*gvp)) )
d545 1
a545 1
			Perl_warn(aTHX_ "Variable \"%c%s\" is not imported",
d550 1
a550 1
			    Perl_warn(aTHX_ "\t(Did you mean &%s instead?)\n", name);
d556 1
a556 1
		stash = CopSTASH(PL_curcop);
d565 13
a577 7
	if (add) {
	    qerror(Perl_mess(aTHX_
		 "Global symbol \"%s%s\" requires explicit package name",
		 (sv_type == SVt_PV ? "$"
		  : sv_type == SVt_PVAV ? "@@"
		  : sv_type == SVt_PVHV ? "%"
		  : ""), name));
d579 6
a584 1
	return Nullgv;
d606 2
a607 2
    if (add & GV_ADDWARN && ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL, "Had to create %s unexpectedly", nambeg);
a611 3
    if (isLEXWARN_on && isALPHA(name[0]) && ! ckWARN(WARN_ONCE))
        GvMULTI_on(gv) ;

d633 1
a633 1
		av_push(av, newSVpvn(pname = "NDBM_File",9));
d635 1
a635 1
		av_push(av, newSVpvn(pname = "DB_File",7));
d637 1
a637 1
		av_push(av, newSVpvn(pname = "GDBM_File",9));
d639 1
a639 1
		av_push(av, newSVpvn(pname = "SDBM_File",9));
d641 1
a641 1
		av_push(av, newSVpvn(pname = "ODBM_File",9));
d646 1
d654 1
d659 5
a663 9
	    if (!PL_psig_ptr) {
		int sig_num[] = { SIG_NUM };
		New(73, PL_psig_ptr, sizeof(sig_num)/sizeof(*sig_num), SV*);
		New(73, PL_psig_name, sizeof(sig_num)/sizeof(*sig_num), SV*);
	    }
	    GvMULTI_on(gv);
	    hv = GvHVn(gv);
	    hv_magic(hv, gv, 'S');
	    for (i = 1; PL_sig_name[i]; i++) {
d665 5
a669 5
	    	init = hv_fetch(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
	    	if (init)
		    sv_setsv(*init, &PL_sv_undef);
	    	PL_psig_ptr[i] = 0;
	    	PL_psig_name[i] = 0;
a672 4
    case 'V':
	if (strEQ(name, "VERSION"))
	    GvMULTI_on(gv);
	break;
d677 1
d684 1
d691 1
d705 1
a705 1
	(void)SvUPGRADE(GvSV(gv), SVt_PVLV);
d714 1
a714 1
	    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
d717 1
a717 1
		require_pv("Errno.pm");
d721 1
a721 1
		    Perl_croak(aTHX_ "Can't use %%! because Errno.pm is not available");
a724 8
    case '-':
	if (len > 1)
	    break;
	else {
            AV* av = GvAVn(gv);
            sv_magic((SV*)av, Nullsv, 'D', Nullch, 0);
        }
	goto magicalize;
d727 2
a728 2
	if (ckWARN(WARN_DEPRECATED) && len == 1 && sv_type == SVt_PV)
	    Perl_warner(aTHX_ WARN_DEPRECATED, "Use of $%s is deprecated", name);
d734 1
d745 11
a755 14
    case '\001':	/* $^A */
    case '\003':	/* $^C */
    case '\004':	/* $^D */
    case '\005':	/* $^E */
    case '\006':	/* $^F */
    case '\010':	/* $^H */
    case '\011':	/* $^I, NOT \t in EBCDIC */
    case '\017':	/* $^O */
    case '\020':	/* $^P */
    case '\024':	/* $^T */
	if (len > 1)
	    break;
	goto magicalize;
    case '\023':	/* $^S */
a757 5
	goto ro_magicalize;
    case '\027':	/* $^W & $^WARNING_BITS */
	if (len > 1 && strNE(name, "\027ARNING_BITS")
	    && strNE(name, "\027IDE_SYSTEM_CALLS"))
	    break;
a760 7
	if (len > 1)
	    break;
	else {
            AV* av = GvAVn(gv);
            sv_magic((SV*)av, (SV*)av, 'D', Nullch, 0);
        }
	/* FALL THROUGH */
d770 1
d777 1
a777 1
    case '\014':	/* $^L */
d791 3
a793 4
	    (void)SvUPGRADE(sv, SVt_PVNV);
	    SvNVX(sv) = SvNVX(PL_patchlevel);
	    SvNOK_on(sv);
	    (void)SvPV_nolen(sv);
a796 7
    case '\026':	/* $^V */
	if (len == 1) {
	    SV *sv = GvSV(gv);
	    GvSV(gv) = SvREFCNT_inc(PL_patchlevel);
	    SvREFCNT_dec(sv);
	}
	break;
d802 1
a802 1
Perl_gv_fullname3(pTHX_ SV *sv, GV *gv, const char *prefix)
d806 1
a806 1
	(void)SvOK_off(sv);
d816 1
a816 1
Perl_gv_efullname3(pTHX_ SV *sv, GV *gv, const char *prefix)
d826 1
a826 1
Perl_gv_fullname(pTHX_ SV *sv, GV *gv)
d833 1
a833 1
Perl_gv_efullname(pTHX_ SV *sv, GV *gv)
d839 1
a839 1
Perl_newIO(pTHX)
d858 1
a858 1
Perl_gv_check(pTHX_ HV *stash)
d865 1
d874 1
a874 1
		if (hv != PL_defstash && hv != stash)
a877 1
		char *file;
d881 4
a884 7
		file = GvFILE(gv);
		/* performance hack: if filename is absolute and it's a standard
		 * module, don't bother warning */
		if (file
		    && PERL_FILE_IS_ABSOLUTE(file)
		    && (instr(file, "/lib/") || instr(file, ".pm")))
		{
d886 1
a886 9
		}
		CopLINE_set(PL_curcop, GvLINE(gv));
#ifdef USE_ITHREADS
		CopFILE(PL_curcop) = file;	/* set for warning */
#else
		CopFILEGV(PL_curcop) = gv_fetchfile(file);
#endif
		Perl_warner(aTHX_ WARN_ONCE,
			"Name \"%s::%s\" used only once: possible typo",
d894 1
a894 1
Perl_newGVgen(pTHX_ char *pack)
d896 1
a896 1
    return gv_fetchpv(Perl_form(aTHX_ "%s::_GEN_%ld", pack, (long)PL_gensym++),
d903 1
a903 1
Perl_gp_ref(pTHX_ GP *gp)
a904 2
    if (!gp)
	return (GP*)NULL;
d922 1
a922 1
Perl_gp_free(pTHX_ GV *gv)
a923 1
    dTHR;  
d925 1
d930 1
a930 3
	if (ckWARN_d(WARN_INTERNAL))
	    Perl_warner(aTHX_ WARN_INTERNAL,
			"Attempt to free unreferenced glob pointers");
d978 1
d982 1
a982 1
Perl_Gv_AMupdate(pTHX_ HV *stash)
d984 3
a986 1
  dTHR;
a992 4
#ifdef OVERLOAD_VIA_HASH
  GV** gvp;
  HV* hv;
#endif
d1007 1
a1007 1
  DEBUG_o( Perl_deb(aTHX_ "Recalcing overload magic in package %s\n",HvNAME(stash)) );
d1023 1
a1023 1
    /* Work with "fallback" key, which we assume to be first in PL_AMG_names */
d1025 1
a1025 1
    if (( cp = (char *)PL_AMG_names[0] ) &&
d1032 1
a1032 1
      cp = (char *)PL_AMG_names[i];
d1050 1
a1050 1
	      Perl_croak(aTHX_ "Not a subroutine reference in overload table");
d1057 1
a1057 1
                cv = sv_2cv(sv, &stash, &gv, FALSE);
d1062 1
a1062 1
	    Perl_croak(aTHX_ "Method for operation %s not found in package %.256s during blessing\n",
d1073 1
d1075 1
a1075 1
    /* Work with "fallback" key, which we assume to be first in PL_AMG_names */
d1077 1
a1077 1
    if ((cp = PL_AMG_names[0])) {
d1080 1
a1080 2
	if (gv)
	    sv = GvSV(gv);
d1082 3
a1084 6
	if (!gv)
	    goto no_table;
	else if (SvTRUE(sv))
	    amt.fallback=AMGfallYES;
	else if (SvOK(sv))
	    amt.fallback=AMGfallNEVER;
d1088 2
a1089 2
	SV *cookie = sv_2mortal(Perl_newSVpvf(aTHX_ "(%s", cp = PL_AMG_names[i]));
	DEBUG_o( Perl_deb(aTHX_ "Checking overloading of `%s' in package `%.256s'\n",
d1100 1
a1100 1
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n", 
d1108 1
a1108 1
			Perl_croak(aTHX_ "Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'", 
d1112 1
a1112 1
			Perl_croak(aTHX_ "Can't resolve method `%.256s' overloading `%s' in package `%.256s'", 
d1118 1
a1118 1
	    DEBUG_o( Perl_deb(aTHX_ "Overloading `%s' in package `%.256s' via `%.256s::%.256s' \n",
d1140 1
a1140 1
Perl_amagic_call(pTHX_ SV *left, SV *right, int method, int flags)
d1240 1
a1240 1
	   if ((cv = cvp[off=subtr_amg])) {
a1245 9
	 case iter_amg:			/* XXXX Eventually should do to_gv. */
	 case to_sv_amg:
	 case to_av_amg:
	 case to_hv_amg:
	 case to_gv_amg:
	 case to_cv_amg:
	     /* FAIL safe */
	     return NULL;	/* Delegate operation to standard mechanisms. */
	     break;
d1299 1
a1299 1
	msg = sv_2mortal(Perl_newSVpvf(aTHX_ 
d1301 1
a1301 1
		      PL_AMG_names[method + assignshift],
d1318 1
a1318 1
	  DEBUG_o( Perl_deb(aTHX_ "%s", SvPVX(msg)) );
d1320 1
a1320 1
	  Perl_croak(aTHX_ "%"SVf, msg);
d1328 1
a1328 1
    DEBUG_o( Perl_deb(aTHX_ 
d1330 1
a1330 1
		 PL_AMG_names[off],
d1334 1
a1334 1
		             PL_AMG_names[method+assignshift],
d1387 1
a1387 1
    pp_pushmark();
d1394 1
a1394 1
      PUSHs( sv_2mortal(newSVpv((char *)PL_AMG_names[method + assignshift],0)));
d1399 2
a1400 2
    if ((PL_op = Perl_pp_entersub(aTHX)))
      CALLRUNOPS(aTHX);
a1404 1
    PUTBACK;
d1433 1
a1433 1
	ans=!SvTRUE(res); break;
d1438 1
a1438 1
	Perl_croak(aTHX_ "Copy method did not return a reference");
d1446 2
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d56 1
d78 1
a78 1
	    hv_magic(GvHVn(gv_AVadd(gv)), Nullgv, 'L');
d88 1
d109 1
a109 1
    sv_magic((SV*)gv, (SV*)gv, '*', Nullch, 0);
d124 1
a124 1
	CvGV(GvCV(gv)) = gv;
d162 1
a162 1
accessible via @@ISA and @@UNIVERSAL.
d167 1
a167 1
up caching info for this glob.  Similarly for all the searched stashes.
d173 1
a173 1
obtained from the GV with the C<GvCV> macro.
d230 1
d250 1
d320 1
a320 1
already setup.
d324 1
a324 1
means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD.
d326 1
a326 1
with a non-zero C<autoload> parameter.
d332 1
a332 1
created via a side effect to do this.
d337 1
a337 1
C<call_sv> apply equally to these functions.
d345 1
d349 1
a349 1

d375 1
a375 1
	if (strEQ(name,"import") || strEQ(name,"unimport"))
d406 1
a420 3
    if (!CvROOT(cv))
	return Nullgv;

d424 1
a424 1
    if (ckWARN(WARN_DEPRECATED) && !method &&
a437 5
    ENTER;

#ifdef USE_THREADS
    sv_lock((SV *)varstash);
#endif
a439 1
    LEAVE;
a440 3
#ifdef USE_THREADS
    sv_lock(varsv);
#endif
d516 1
d523 1
a655 1
	    stash = PL_nullstash;
d657 1
a657 2
	else
	    return Nullgv;
d683 1
d685 1
a685 2
    if (isALPHA(name[0]) && ! (isLEXWARN_on ? ckWARN(WARN_ONCE) 
			                    : (PL_dowarn & G_WARN_ON ) ) )
d726 1
a726 1
            hv_magic(hv, Nullgv, 'A');
d740 1
a740 1
	    hv_magic(hv, Nullgv, 'S');
a809 1
	    SvREADONLY_on(av);
d830 1
a843 5
    case '|':
	if (len > 1)
	    break;
	sv_setiv(GvSV(gv), (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0);
	goto magicalize;
a859 1
	    SvREADONLY_on(av);
a891 8
	    Perl_sv_setpvf(aTHX_ sv,
#if defined(PERL_SUBVERSION) && (PERL_SUBVERSION > 0)
			    "%8.6"
#else
			    "%5.3"
#endif
			    NVff,
			    SvNVX(PL_patchlevel));
d894 1
a909 16
Perl_gv_fullname4(pTHX_ SV *sv, GV *gv, const char *prefix, bool keepmain)
{
    HV *hv = GvSTASH(gv);
    if (!hv) {
	(void)SvOK_off(sv);
	return;
    }
    sv_setpv(sv, prefix ? prefix : "");
    if (keepmain || strNE(HvNAME(hv), "main")) {
	sv_catpv(sv,HvNAME(hv));
	sv_catpvn(sv,"::", 2);
    }
    sv_catpvn(sv,GvNAME(gv),GvNAMELEN(gv));
}

void
a923 9
Perl_gv_efullname4(pTHX_ SV *sv, GV *gv, const char *prefix, bool keepmain)
{
    GV *egv = GvEGV(gv);
    if (!egv)
	egv = gv;
    gv_fullname4(sv, egv, prefix, keepmain);
}

void
d949 1
d968 1
d1045 1
d1085 1
a1085 1
    if (GvGP(gv)->gp_av)
d1106 1
d1157 1
a1157 1

d1227 1
a1227 1
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%.256s' for overloaded `%s' in package `%.256s'\n",
d1229 1
a1229 1
		if (!SvPOK(GvSV(gv))
d1235 1
a1235 1
			Perl_croak(aTHX_ "Stub found while resolving method `%.256s' overloading `%s' in package `%.256s'",
d1239 1
a1239 1
			Perl_croak(aTHX_ "Can't resolve method `%.256s' overloading `%s' in package `%.256s'",
d1250 1
a1250 1
#endif
d1269 3
a1271 2
  MAGIC *mg;
  CV *cv;
d1279 1
a1279 1
      && (ocvp = cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)
d1282 1
a1282 1
      && ((cv = cvp[off=method+assignshift])
d1318 1
a1318 1
   (void)((cv = cvp[off=bool__amg])
d1343 1
a1343 1
	   if ((cvp[off1=lt_amg] || cvp[off1=ncmp_amg])
a1373 3
	     /* FAIL safe */
	     return NULL;	/* Delegate operation to standard mechanisms. */
	     break;
d1380 1
a1380 1
	     return left;	/* Delegate operation to standard mechanisms. */
d1388 1
a1388 1
	       && (cvp = (AMT_AMAGIC((AMT*)mg->mg_ptr)
d1394 2
a1395 2
    } else if (((ocvp && oamtp->fallback > AMGfallNEVER
		 && (cvp=ocvp) && (lr = -1))
a1427 10
      switch (method) {
	 case to_sv_amg:
	 case to_av_amg:
	 case to_hv_amg:
	 case to_gv_amg:
	 case to_cv_amg:
	     /* FAIL safe */
	     return left;	/* Delegate operation to standard mechanisms. */
	     break;
      }
d1435 1
a1435 1
	msg = sv_2mortal(Perl_newSVpvf(aTHX_
d1439 1
a1439 1
		      SvAMAGIC(left)?
d1442 1
a1442 1
		      SvAMAGIC(left)?
d1445 1
a1445 1
		      SvAMAGIC(right)?
d1447 1
a1447 1
		        (flags & AMGf_unary
d1450 1
a1450 1
		      SvAMAGIC(right)?
d1464 1
a1464 1
    DEBUG_o( Perl_deb(aTHX_
d1475 1
a1475 1
		 HvNAME(stash),
d1488 1
a1488 1
     * 		assignshift==0,  assign==T,
d1491 1
a1491 1
     * 		assignshift==0,  assign==0,
a1581 107
}

/*
=for apidoc is_gv_magical

Returns C<TRUE> if given the name of a magical GV.

Currently only useful internally when determining if a GV should be
created even in rvalue contexts.

C<flags> is not used at present but available for future extension to
allow selecting particular classes of magical variable.

=cut
*/
bool
Perl_is_gv_magical(pTHX_ char *name, STRLEN len, U32 flags)
{
    if (!len)
	return FALSE;

    switch (*name) {
    case 'I':
	if (len == 3 && strEQ(name, "ISA"))
	    goto yes;
	break;
    case 'O':
	if (len == 8 && strEQ(name, "OVERLOAD"))
	    goto yes;
	break;
    case 'S':
	if (len == 3 && strEQ(name, "SIG"))
	    goto yes;
	break;
    case '\027':   /* $^W & $^WARNING_BITS */
	if (len == 1
	    || (len == 12 && strEQ(name, "\027ARNING_BITS"))
	    || (len == 17 && strEQ(name, "\027IDE_SYSTEM_CALLS")))
	{
	    goto yes;
	}
	break;

    case '&':
    case '`':
    case '\'':
    case ':':
    case '?':
    case '!':
    case '-':
    case '#':
    case '*':
    case '[':
    case '^':
    case '~':
    case '=':
    case '%':
    case '.':
    case '(':
    case ')':
    case '<':
    case '>':
    case ',':
    case '\\':
    case '/':
    case '|':
    case '+':
    case ';':
    case ']':
    case '\001':   /* $^A */
    case '\003':   /* $^C */
    case '\004':   /* $^D */
    case '\005':   /* $^E */
    case '\006':   /* $^F */
    case '\010':   /* $^H */
    case '\011':   /* $^I, NOT \t in EBCDIC */
    case '\014':   /* $^L */
    case '\017':   /* $^O */
    case '\020':   /* $^P */
    case '\023':   /* $^S */
    case '\024':   /* $^T */
    case '\026':   /* $^V */
	if (len == 1)
	    goto yes;
	break;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
	if (len > 1) {
	    char *end = name + len;
	    while (--end > name) {
		if (!isDIGIT(*end))
		    return FALSE;
	    }
	}
    yes:
	return TRUE;
    default:
	break;
    }
    return FALSE;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a18 4
/*
=head1 GV Functions
*/

d48 1
a48 6
    if (!GvIOp(gv)) {
#ifdef GV_UNIQUE_CHECK
        if (GvUNIQUE(gv)) {
            Perl_croak(aTHX_ "Bad symbol for filehandle (GV is unique)");
        }
#endif
a49 1
    }
a68 1
    /* This is where the debugger's %{"::_<$filename"} hash is created */
d77 1
a77 1
	    hv_magic(GvHVn(gv_AVadd(gv)), Nullgv, PERL_MAGIC_dbfile);
d107 1
a107 1
    sv_magic((SV*)gv, (SV*)gv, PERL_MAGIC_glob, Nullch, 0);
d123 1
a123 1
	CvFILE_set_from_cop(GvCV(gv), PL_curcop);
d125 1
a125 1
#ifdef USE_5005THREADS
d131 1
a131 1
#endif /* USE_5005THREADS */
d160 1
a160 1
accessible via @@ISA and UNIVERSAL::.
d185 2
a186 7
    /* UNIVERSAL methods should be callable without a stash */
    if (!stash) {
	level = -1;  /* probably appropriate */
	if(!(stash = gv_stashpvn("UNIVERSAL", 9, FALSE)))
	    return 0;
    }

d248 1
a248 1
		    Perl_warner(aTHX_ packWARN(WARN_MISC), "Can't locate package %s for @@%s::ISA",
a296 44
=for apidoc gv_fetchmeth_autoload

Same as gv_fetchmeth(), but looks for autoloaded subroutines too.
Returns a glob for the subroutine.

For an autoloaded subroutine without a GV, will create a GV even
if C<level < 0>.  For an autoloaded subroutine without a stub, GvCV()
of the result may be zero.

=cut
*/

GV *
Perl_gv_fetchmeth_autoload(pTHX_ HV *stash, const char *name, STRLEN len, I32 level)
{
    GV *gv = gv_fetchmeth(stash, name, len, level);

    if (!gv) {
	char autoload[] = "AUTOLOAD";
	STRLEN autolen = sizeof(autoload)-1;
	CV *cv;
	GV **gvp;

	if (!stash)
	    return Nullgv;	/* UNIVERSAL::AUTOLOAD could cause trouble */
	if (len == autolen && strnEQ(name, autoload, autolen))
	    return Nullgv;
	if (!(gv = gv_fetchmeth(stash, autoload, autolen, FALSE)))
	    return Nullgv;
	cv = GvCV(gv);
	if (!(CvROOT(cv) || CvXSUB(cv)))
	    return Nullgv;
	/* Have an autoload */
	if (level < 0)	/* Cannot do without a stub */
	    gv_fetchmeth(stash, name, len, 0);
	gvp = (GV**)hv_fetch(stash, name, len, (level >= 0));
	if (!gvp)
	    return Nullgv;
	return *gvp;
    }
    return gv;
}

/*
a359 1
	    /* __PACKAGE__::SUPER stash should be autovivified */
d364 2
a365 11
	else {
            /* don't autovifify if ->NoSuchStash::method */
            stash = gv_stashpvn(origname, nsplit - origname, FALSE);

	    /* however, explicit calls to Pkg::SUPER::method may
	       happen, and may require autovivification to work */
	    if (!stash && (nsplit - origname) >= 7 &&
		strnEQ(nsplit - 7, "::SUPER", 7) &&
		gv_stashpvn(origname, nsplit - origname - 7, FALSE))
	      stash = gv_stashpvn(origname, nsplit - origname, TRUE);
	}
d401 2
a402 2
    char autoload[] = "AUTOLOAD";
    STRLEN autolen = sizeof(autoload)-1;
a408 2
    if (!stash)
	return Nullgv;	/* UNIVERSAL::AUTOLOAD could cause trouble */
d415 1
a415 1
    if (!(CvROOT(cv) || CvXSUB(cv)))
d421 1
a421 1
    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX) && !method &&
d423 1
a423 1
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
a426 14
#ifndef USE_5005THREADS
    if (CvXSUB(cv)) {
        /* rather than lookup/init $AUTOLOAD here
         * only to have the XSUB do another lookup for $AUTOLOAD
         * and split that value on the last '::',
         * pass along the same data via some unused fields in the CV
         */
        CvSTASH(cv) = stash;
        SvPVX(cv) = (char *)name; /* cast to lose constness warning */
        SvCUR(cv) = len;
        return gv;
    }
#endif

d437 1
a437 1
#ifdef USE_5005THREADS
d444 1
a444 1
#ifdef USE_5005THREADS
a453 23
/* The "gv" parameter should be the glob known to Perl code as *!
 * The scalar must already have been magicalized.
 */
STATIC void
S_require_errno(pTHX_ GV *gv)
{
    HV* stash = gv_stashpvn("Errno",5,FALSE);

    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) { 
	dSP;
	PUTBACK;
	ENTER;
	save_scalar(gv); /* keep the value of $! */
        Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT,
                         newSVpvn("Errno",5), Nullsv);
	LEAVE;
	SPAGAIN;
	stash = gv_stashpvn("Errno",5,FALSE);
	if (!stash || !(gv_fetchmethod(stash, "TIEHASH")))
	    Perl_croak(aTHX_ "Can't use %%! because Errno.pm is not available");
    }
}

d546 1
a546 1
		if (len + 3 < sizeof (smallbuf))
a676 2
	    if (*name=='!' && sv_type == SVt_PVHV && len==1)
		require_errno(gv);
d686 1
a686 1
	Perl_warner(aTHX_ packWARN(WARN_INTERNAL), "Had to create %s unexpectedly", nambeg);
d709 1
a709 1
	    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, Nullch, 0);
d732 1
a732 1
            hv_magic(hv, Nullgv, PERL_MAGIC_overload);
d740 3
a742 3
		Newz(73, PL_psig_ptr,  SIG_SIZE, SV*);
		Newz(73, PL_psig_name, SIG_SIZE, SV*);
		Newz(73, PL_psig_pend, SIG_SIZE, int);
d746 2
a747 2
	    hv_magic(hv, Nullgv, PERL_MAGIC_sig);
	    for (i = 1; i < SIG_SIZE; i++) {
a753 1
	    	PL_psig_pend[i] = 0;
d763 5
d769 5
d775 2
a776 8
       if (
           len > 1 ||
           sv_type == SVt_PVAV ||
           sv_type == SVt_PVHV ||
           sv_type == SVt_PVCV ||
           sv_type == SVt_PVFM ||
           sv_type == SVt_PVIO
       ) { break; }
d797 13
a809 13

	/* If %! has been used, automatically load Errno.pm.
	   The require will itself set errno, so in order to
	   preserve its value we have to set up the magic
	   now (rather than going to magicalize)
	*/

	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, len);

	if (sv_type == SVt_PVHV)
	    require_errno(gv);

	break;
d815 1
a815 1
            sv_magic((SV*)av, Nullsv, PERL_MAGIC_regdata, Nullch, 0);
d821 2
a822 2
	if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX) && len == 1 && sv_type == SVt_PV)
	    Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX), "Use of $%s is deprecated", name);
d840 1
d844 1
a844 1
    case '\016':        /* $^N */
d846 1
a854 9
    case '\005':	/* $^E && $^ENCODING */
	if (len > 1 && strNE(name, "\005NCODING"))
	    break;
	goto magicalize;

    case '\017':	/* $^O & $^OPEN */
	if (len > 1 && strNE(name, "\017PEN"))
	    break;
	goto magicalize;
a858 7
    case '\024':	/* $^T, ${^TAINT} */
        if (len == 1)
            goto magicalize;
        else if (strEQ(name, "\024AINT"))
            goto ro_magicalize;
        else
            break;
d870 1
a870 1
            sv_magic((SV*)av, (SV*)av, PERL_MAGIC_regdata, Nullch, 0);
a882 11
	/* ensures variable is only digits */
	/* ${"1foo"} fails this test (and is thus writeable) */
	/* added by japhy, but borrowed from is_gv_magical */

	if (len > 1) {
	    const char *end = name + len;
	    while (--end > name) {
		if (!isDIGIT(*end)) return gv;
	    }
	}

d886 1
a886 1
	sv_magic(GvSV(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
d1021 1
a1021 1
		(gv = (GV*)HeVAL(entry)) && (hv = GvHV(gv)))
d1036 1
a1036 6
#ifdef MACOS_TRADITIONAL
		    && (instr(file, ":lib:")
#else
		    && (instr(file, "/lib/")
#endif
		    || instr(file, ".pm")))
d1046 1
a1046 1
		Perl_warner(aTHX_ packWARN(WARN_ONCE),
d1093 1
a1093 1
	    Perl_warner(aTHX_ packWARN(WARN_INTERNAL),
d1118 16
a1133 2
int
Perl_magic_freeovrld(pTHX_ SV *sv, MAGIC *mg)
d1135 4
a1138 12
    AMT *amtp = (AMT*)mg->mg_ptr;
    if (amtp && AMT_AMAGIC(amtp)) {
	int i;
	for (i = 1; i < NofAMmeth; i++) {
	    CV *cv = amtp->table[i];
	    if (cv != Nullcv) {
		SvREFCNT_dec((SV *) cv);
		amtp->table[i] = Nullcv;
	    }
	}
    }
 return 0;
d1140 1
d1149 1
a1149 1
  MAGIC* mg=mg_find((SV*)stash, PERL_MAGIC_overload_table);
d1152 5
d1160 10
a1169 2
      return (bool)AMT_OVERLOADED(amtp);
  sv_unmagic((SV*)stash, PERL_MAGIC_overload_table);
a1172 1
  Zero(&amt,1,AMT);
d1178 54
d1233 3
a1235 2
    int filled = 0, have_ovl = 0;
    int i, lim = 1;
d1240 13
a1252 19
    /* Try to find via inheritance. */
    gv = gv_fetchmeth(stash, PL_AMG_names[0], 2, -1);
    if (gv)
	sv = GvSV(gv);

    if (!gv)
	lim = DESTROY_amg;		/* Skip overloading entries. */
    else if (SvTRUE(sv))
	amt.fallback=AMGfallYES;
    else if (SvOK(sv))
	amt.fallback=AMGfallNEVER;

    for (i = 1; i < lim; i++)
	amt.table[i] = Nullcv;
    for (; i < NofAMmeth; i++) {
	char *cooky = (char*)PL_AMG_names[i];
	/* Human-readable form, for debugging: */
	char *cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
	STRLEN l = strlen(cooky);
d1254 2
d1258 2
a1259 11
	/* don't fill the cache while looking up!
	   Creation of inheritance stubs in intermediate packages may
	   conflict with the logic of runtime method substitution.
	   Indeed, for inheritance A -> B -> C, if C overloads "+0",
	   then we could have created stubs for "(+0" in A and C too.
	   But if B overloads "bool", we may want to use it for
	   numifying instead of C's "+0". */
	if (i >= DESTROY_amg)
	    gv = Perl_gv_fetchmeth_autoload(aTHX_ stash, cooky, l, 0);
	else				/* Autoload taken care of below */
	    gv = Perl_gv_fetchmeth(aTHX_ stash, cooky, l, -1);
d1261 1
a1261 1
        if (gv && (cv = GvCV(gv))) {
a1263 2
		/* This is a hack to support autoloading..., while
		   knowing *which* methods were declared as overloaded. */
d1265 1
a1265 1
		GV *ngv = Nullgv;
d1268 1
a1268 1
			     SvPV_nolen(GvSV(gv)), cp, HvNAME(stash)) );
a1288 5
	    if (i < DESTROY_amg)
		have_ovl = 1;
	} else if (gv) {		/* Autoloaded... */
	    cv = (CV*)gv;
	    filled = 1;
d1290 1
d1295 2
a1296 5
      if (have_ovl)
	  AMT_OVERLOADED_on(&amt);
      sv_magic((SV*)stash, 0, PERL_MAGIC_overload_table,
						(char*)&amt, sizeof(AMT));
      return have_ovl;
d1300 1
a1300 1
  /* no_table: */
d1302 1
a1302 2
  sv_magic((SV*)stash, 0, PERL_MAGIC_overload_table,
						(char*)&amt, sizeof(AMTS));
a1305 39

CV*
Perl_gv_handler(pTHX_ HV *stash, I32 id)
{
    MAGIC *mg;
    AMT *amtp;
    CV *ret;

    if (!stash)
        return Nullcv;
    mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
    if (!mg) {
      do_update:
	Gv_AMupdate(stash);
	mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
    }
    amtp = (AMT*)mg->mg_ptr;
    if ( amtp->was_ok_am != PL_amagic_generation
	 || amtp->was_ok_sub != PL_sub_generation )
	goto do_update;
    if (AMT_AMAGIC(amtp)) {
	ret = amtp->table[id];
	if (ret && isGV(ret)) {		/* Autoloading stab */
	    /* Passing it through may have resulted in a warning
	       "Inherited AUTOLOAD for a non-method deprecated", since
	       our caller is going through a function call, not a method call.
	       So return the CV for AUTOLOAD, setting $AUTOLOAD. */
	    GV *gv = gv_fetchmethod(stash, (char*)PL_AMG_names[id]);

	    if (gv && GvCV(gv))
		return GvCV(gv);
	}
	return ret;
    }
    
    return Nullcv;
}


d1310 1
a1310 1
  CV *cv=NULL;
d1312 2
a1313 2
  AMT *amtp=NULL, *oamtp=NULL;
  int off=0, off1, lr=0, assign=AMGf_assign & flags, notfound=0;
d1315 1
a1315 4
#ifdef DEBUGGING
  int fl=0;
#endif
  HV* stash=NULL;
d1317 1
a1317 2
      && (stash = SvSTASH(SvRV(left)))
      && (mg = mg_find((SV*)stash, PERL_MAGIC_overload_table))
d1324 1
a1324 5
		  (
#ifdef DEBUGGING
		   fl = 1,
#endif 
		   cv = cvp[off=method])))) {
a1411 1
	 case int_amg:
d1429 1
a1429 2
	       && (stash = SvSTASH(SvRV(right)))
	       && (mg = mg_find((SV*)stash, PERL_MAGIC_overload_table))
d1489 1
a1489 1
		      AMG_id2name(method + assignshift),
a1514 1
#ifdef DEBUGGING
d1516 13
a1528 13
    DEBUG_o(Perl_deb(aTHX_
		     "Overloaded operator `%s'%s%s%s:\n\tmethod%s found%s in package %s%s\n",
		     AMG_id2name(off),
		     method+assignshift==off? "" :
		     " (initially `",
		     method+assignshift==off? "" :
		     AMG_id2name(method+assignshift),
		     method+assignshift==off? "" : "')",
		     flags & AMGf_unary? "" :
		     lr==1 ? " for right argument": " for left argument",
		     flags & AMGf_unary? " for argument" : "",
		     stash ? HvNAME(stash) : "null",
		     fl? ",\n\tassignment variant used": "") );
a1529 1
#endif
d1582 1
a1582 1
      PUSHs( sv_2mortal(newSVpv(AMG_id2name(method + assignshift),0)));
d1598 1
a1598 1
      int ans=0;
a1667 7
    case '\017':   /* $^O & $^OPEN */
	if (len == 1
	    || (len == 4 && strEQ(name, "\017PEN")))
	{
	    goto yes;
	}
	break;
d1711 1
a1711 1
    case '\016':   /* $^N */
d1714 1
a1718 4
    case '\024':   /* $^T, ${^TAINT} */
        if (len == 1 || strEQ(name, "\024AINT"))
            goto yes;
        break;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d264 2
a265 2
		    Perl_warner(aTHX_ packWARN(WARN_MISC), "Can't locate package %"SVf" for @@%s::ISA",
			sv, HvNAME(stash));
a403 4
    HV* ostash = stash;

    if (stash && SvTYPE(stash) < SVt_PVHV)
	stash = Nullhv;
a435 1
	ostash = stash;
d443 1
a443 1
	    gv = gv_autoload4(ostash, name, nend - name, TRUE);
a477 1
    char *packname = "";
d479 2
a482 9
    if (stash) {
	if (SvTYPE(stash) < SVt_PVHV) {
	    packname = SvPV_nolen((SV*)stash);
	    stash = Nullhv;
	}
	else {
	    packname = HvNAME(stash);
	}
    }
d497 1
a497 1
	     packname, (int)len, name);
d533 1
a533 1
    sv_setpv(varsv, packname);
d692 2
d722 1
a722 1
	    else if (IN_PERL_COMPILETIME) {
d763 1
a763 1
	    register SV *err = Perl_mess(aTHX_
d768 1
a768 4
		  : ""), name);
	    if (USE_UTF8_IN_NAMES)
		SvUTF8_on(err);
	    qerror(err);
a980 5
    case '\025':
        if (len > 1 && strNE(name, "\025NICODE")) 
	    break;
	goto ro_magicalize;

d982 2
a983 3
	if (len > 1
	    && strNE(name, "\027ARNING_BITS")
	    )
d1080 9
a1088 1
    gv_fullname4(sv, gv, prefix, TRUE);
d1103 4
a1106 1
    gv_efullname4(sv, gv, prefix, TRUE);
a1132 3
    /* Clear the stashcache because a new IO could overrule a 
       package name */
    hv_clear(PL_stashcache);
d1154 1
a1154 1
		(gv = (GV*)HeVAL(entry)) && isGV(gv) && (hv = GvHV(gv)))
d1245 6
a1250 12
    if (gp->gp_sv) SvREFCNT_dec(gp->gp_sv);
    if (gp->gp_sv) SvREFCNT_dec(gp->gp_av);
    if (gp->gp_hv) {
	 if (PL_stashcache && HvNAME(gp->gp_hv))
	      hv_delete(PL_stashcache,
			HvNAME(gp->gp_hv), strlen(HvNAME(gp->gp_hv)),
			G_DISCARD);
	 SvREFCNT_dec(gp->gp_hv);
    }
    if (gp->gp_io)   SvREFCNT_dec(gp->gp_io);
    if (gp->gp_cv)   SvREFCNT_dec(gp->gp_cv);
    if (gp->gp_form) SvREFCNT_dec(gp->gp_form);
d1346 2
a1347 3
		DEBUG_o( Perl_deb(aTHX_ "Resolving method `%"SVf256\
			"' for overloaded `%s' in package `%.256s'\n",
			     GvSV(gv), cp, HvNAME(stash)) );
d1353 8
a1360 7
		    SV *gvsv = GvSV(gv);
		    const char *name = SvPOK(gvsv) ?  SvPVX(gvsv) : "???";
		    Perl_croak(aTHX_ "%s method `%.256s' overloading `%s' "\
				"in package `%.256s'",
			       (GvCVGEN(gv) ? "Stub found while resolving"
				: "Can't resolve"),
			       name, cp, HvNAME(stash));
a1812 3
    case '\025':
        if (len > 1 && strEQ(name, "\025NICODE"))
	    goto yes;
d1816 1
a1816 1
	    )
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d1245 1
a1245 2
			"Attempt to free unreferenced glob pointers"
                        pTHX__FORMAT pTHX__VALUE);
d1259 1
a1259 1
    if (gp->gp_av) SvREFCNT_dec(gp->gp_av);
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a21 9

A GV is a structure which corresponds to to a Perl typeglob, ie *foo.
It is a structure that holds a pointer to a scalar, an array, a hash etc,
corresponding to $foo, @@foo, %foo.

GVs are usually found as values in stashes (symbol table hashes) where
Perl stores its global variables.

=cut
d1087 1
a1087 1
	SvOK_off(sv);
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
a36 16
const char S_autoload[] = "AUTOLOAD";
const STRLEN S_autolen = sizeof(S_autoload)-1;


#ifdef PERL_DONT_CREATE_GVSV
GV *
Perl_gv_SVadd(pTHX_ GV *gv)
{
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV)
	Perl_croak(aTHX_ "Bad symbol for scalar");
    if (!GvSV(gv))
	GvSV(gv) = NEWSV(72,0);
    return gv;
}
#endif

d88 1
a88 1
	Newx(tmpbuf, tmplen + 1, char);
d92 1
a92 1
    memcpy(tmpbuf + 2, name, tmplen - 1);
d96 1
a96 5
#ifdef PERL_DONT_CREATE_GVSV
	GvSV(gv) = newSVpvn(name, tmplen - 2);
#else
	sv_setpvn(GvSV(gv), name, tmplen - 2);
#endif
d109 2
a110 2
    const bool doproto = SvTYPE(gv) > SVt_NULL;
    const char * const proto = (doproto && SvPOK(gv)) ? SvPVX_const(gv) : NULL;
d115 2
a116 2
	    SvPV_set(gv, NULL);
	    SvLEN_set(gv, 0);
d119 1
a119 1
	    Safefree(SvPVX_mutable(gv));
d121 1
a121 1
    Newxz(gp, 1, GP);
a122 3
#ifdef PERL_DONT_CREATE_GVSV
    GvSV(gv) = 0;
#else
a123 1
#endif
d125 1
a125 3
    /* XXX Ideally this cast would be replaced with a change to const char*
       in the struct.  */
    GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : (char *) "";
d138 1
a138 1
	(void) start_subparse(0,0);	/* Create empty CV in compcv. */
a172 8
#ifdef PERL_DONT_CREATE_GVSV
    case SVt_NULL:
    case SVt_PVCV:
    case SVt_PVFM:
	break;
    default:
	(void)GvSVn(gv);
#endif
a204 1
    const char *hvname;
a212 5
    hvname = HvNAME_get(stash);
    if (!hvname)
      Perl_croak(aTHX_
		 "Can't use anonymous symbol table for method lookup");

d215 1
a215 1
	      name, hvname);
d217 1
a217 1
    DEBUG_o( Perl_deb(aTHX_ "Looking for method %s in package %s\n",name,hvname) );
d244 2
a245 1
	STRLEN packlen = strlen(hvname);
d247 1
a247 1
	if (packlen >= 7 && strEQ(hvname + packlen - 7, "::SUPER")) {
d251 1
a251 1
	    basestash = gv_stashpvn(hvname, packlen, TRUE);
d256 1
a256 1
		    Perl_croak(aTHX_ "Cannot create %s::ISA", hvname);
d270 2
a271 2
	    SV* const sv = *svp++;
	    HV* const basestash = gv_stashsv(sv, FALSE);
d275 1
a275 1
			sv, hvname);
d288 1
a288 1
	HV* const lastchance = gv_stashpvn("UNIVERSAL", 9, FALSE);
d290 1
a290 1
	if (lastchance) {
d341 2
d348 1
a348 1
	if (len == S_autolen && strnEQ(name, S_autoload, S_autolen))
d350 1
a350 1
	if (!(gv = gv_fetchmeth(stash, S_autoload, S_autolen, FALSE)))
d426 1
a426 1
	const char * const origname = name;
d435 1
a435 1
	    stash = gv_stashpvn(SvPVX_const(tmpstr), SvCUR(tmpstr), TRUE);
d437 1
a437 1
			 origname, HvNAME_get(stash), name) );
d461 1
a461 1
	CV* const cv = GvCV(gv);
d486 2
d493 1
a493 1
    const char *packname = "";
d495 1
a495 1
    if (len == S_autolen && strnEQ(name, S_autoload, S_autolen))
d499 1
a499 1
	    packname = SvPV_nolen_const((SV*)stash);
d503 1
a503 1
	    packname = HvNAME_get(stash);
d506 1
a506 1
    if (!(gv = gv_fetchmeth(stash, S_autoload, S_autolen, FALSE)))
d516 2
a517 3
    if (!method && (GvCVGEN(gv) || GvSTASH(gv) != stash)
	&& ckWARN2(WARN_DEPRECATED, WARN_SYNTAX)
    )
d530 2
a531 2
        SvPV_set(cv, (char *)name); /* cast to lose constness warning */
        SvCUR_set(cv, len);
d543 1
a543 1
    vargv = *(GV**)hv_fetch(varstash, S_autoload, S_autolen, TRUE);
d549 2
a550 6
    if (!isGV(vargv)) {
	gv_init(vargv, varstash, S_autoload, S_autolen, FALSE);
#ifdef PERL_DONT_CREATE_GVSV
	GvSV(vargv) = NEWSV(72,0);
#endif
    }
d552 1
a552 1
    varsv = GvSVn(vargv);
d571 1
a571 1
    if (!stash || !(gv_fetchmethod(stash, "TIEHASH"))) {
d590 3
a592 3
be a valid UTF-8 string and must be null-terminated.  If C<create> is set
then the package will be created if it does not already exist.  If C<create>
is not set and the package does not exist then NULL is returned.
a602 12
/*
=for apidoc gv_stashpvn

Returns a pointer to the stash for a specified package.  C<name> should
be a valid UTF-8 string.  The C<namelen> parameter indicates the length of
the C<name>, in bytes.  If C<create> is set then the package will be
created if it does not already exist.  If C<create> is not set and the
package does not exist then NULL is returned.

=cut
*/

d614 1
a614 1
	Newx(tmpbuf, namelen + 3, char);
d627 2
a628 2
    if (!HvNAME_get(stash))
	hv_name_set(stash, name, namelen, 0);
d644 1
d646 1
a646 1
    const char * const ptr = SvPV_const(sv,len);
d681 1
a681 1
		    Newx(tmpbuf, len+3, char);
d702 2
a703 2
		if (!HvNAME_get(stash))
		    hv_name_set(stash, nambeg, namend - nambeg, 0);
d722 6
a727 9
	    /* name is always \0 terminated, and initial \0 wouldn't return
	       true from isIDFIRST_lazy, so we know that name[1] is defined  */
	    switch (name[1]) {
	    case '\0':
		if (*name == '_')
		    global = TRUE;
		break;
	    case 'N':
		if (strEQ(name, "INC") || strEQ(name, "ENV"))
d729 1
a729 3
		break;
	    case 'I':
		if (strEQ(name, "SIG"))
d731 1
a731 4
		break;
	    case 'T':
		if (strEQ(name, "STDIN") || strEQ(name, "STDOUT") ||
		    strEQ(name, "STDERR"))
d733 3
a735 3
		break;
	    case 'R':
		if (strEQ(name, "ARGV") || strEQ(name, "ARGVOUT"))
a736 1
		break;
d738 2
d750 1
a750 2
		    !(len == 1 && sv_type == SVt_PV &&
		      (*name == 'a' || *name == 'b')) )
d784 1
a784 1
	    SV * const err = Perl_mess(aTHX_
d825 1
a825 1
    if (isALPHA(name[0]) && ! (isLEXWARN_on ? ckWARN(WARN_ONCE)
d830 18
a847 108
    if (len > 1) {
#ifndef EBCDIC
	if (*name > 'V' ) {
	    /* Nothing else to do.
	       The compiler will probably turn the switch statement into a
	       branch table. Make sure we avoid even that small overhead for
	       the common case of lower case variable names.  */
	} else
#endif
	{
	    const char * const name2 = name + 1;
	    switch (*name) {
	    case 'A':
		if (strEQ(name2, "RGV")) {
		    IoFLAGS(GvIOn(gv)) |= IOf_ARGV|IOf_START;
		}
		break;
	    case 'E':
		if (strnEQ(name2, "XPORT", 5))
		    GvMULTI_on(gv);
		break;
	    case 'I':
		if (strEQ(name2, "SA")) {
		    AV* const av = GvAVn(gv);
		    GvMULTI_on(gv);
		    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, Nullch, 0);
		    /* NOTE: No support for tied ISA */
		    if ((add & GV_ADDMULTI) && strEQ(nambeg,"AnyDBM_File::ISA")
			&& AvFILLp(av) == -1)
			{
			    const char *pname;
			    av_push(av, newSVpvn(pname = "NDBM_File",9));
			    gv_stashpvn(pname, 9, TRUE);
			    av_push(av, newSVpvn(pname = "DB_File",7));
			    gv_stashpvn(pname, 7, TRUE);
			    av_push(av, newSVpvn(pname = "GDBM_File",9));
			    gv_stashpvn(pname, 9, TRUE);
			    av_push(av, newSVpvn(pname = "SDBM_File",9));
			    gv_stashpvn(pname, 9, TRUE);
			    av_push(av, newSVpvn(pname = "ODBM_File",9));
			    gv_stashpvn(pname, 9, TRUE);
			}
		}
		break;
	    case 'O':
		if (strEQ(name2, "VERLOAD")) {
		    HV* const hv = GvHVn(gv);
		    GvMULTI_on(gv);
		    hv_magic(hv, Nullgv, PERL_MAGIC_overload);
		}
		break;
	    case 'S':
		if (strEQ(name2, "IG")) {
		    HV *hv;
		    I32 i;
		    if (!PL_psig_ptr) {
			Newxz(PL_psig_ptr,  SIG_SIZE, SV*);
			Newxz(PL_psig_name, SIG_SIZE, SV*);
			Newxz(PL_psig_pend, SIG_SIZE, int);
		    }
		    GvMULTI_on(gv);
		    hv = GvHVn(gv);
		    hv_magic(hv, Nullgv, PERL_MAGIC_sig);
		    for (i = 1; i < SIG_SIZE; i++) {
			SV * const * const init = hv_fetch(hv, PL_sig_name[i], strlen(PL_sig_name[i]), 1);
			if (init)
			    sv_setsv(*init, &PL_sv_undef);
			PL_psig_ptr[i] = 0;
			PL_psig_name[i] = 0;
			PL_psig_pend[i] = 0;
		    }
		}
		break;
	    case 'V':
		if (strEQ(name2, "ERSION"))
		    GvMULTI_on(gv);
		break;
	    case '\005':	/* $^ENCODING */
		if (strEQ(name2, "NCODING"))
		    goto magicalize;
		break;
	    case '\017':	/* $^OPEN */
		if (strEQ(name2, "PEN"))
		    goto magicalize;
		break;
	    case '\024':	/* ${^TAINT} */
		if (strEQ(name2, "AINT"))
		    goto ro_magicalize;
		break;
	    case '\025':	/* ${^UNICODE}, ${^UTF8LOCALE} */
		if (strEQ(name2, "NICODE"))
		    goto ro_magicalize;
		if (strEQ(name2, "TF8LOCALE"))
		    goto ro_magicalize;
		break;
	    case '\027':	/* $^WARNING_BITS */
		if (strEQ(name2, "ARNING_BITS"))
		    goto magicalize;
		break;
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	    case '8':
	    case '9':
d849 29
a877 8
		/* ensures variable is only digits */
		/* ${"1foo"} fails this test (and is thus writeable) */
		/* added by japhy, but borrowed from is_gv_magical */
		const char *end = name + len;
		while (--end > name) {
		    if (!isDIGIT(*end)) return gv;
		}
		goto ro_magicalize;
d879 11
d892 43
a934 32
    } else {
	/* Names of length 1.  (Or 0. But name is NUL terminated, so that will
	   be case '\0' in this switch statement (ie a default case)  */
	switch (*name) {
	case '&':
	case '`':
	case '\'':
	    if (
		sv_type == SVt_PVAV ||
		sv_type == SVt_PVHV ||
		sv_type == SVt_PVCV ||
		sv_type == SVt_PVFM ||
		sv_type == SVt_PVIO
		) { break; }
	    PL_sawampersand = TRUE;
	    goto ro_magicalize;

	case ':':
	    sv_setpv(GvSVn(gv),PL_chopset);
	    goto magicalize;

	case '?':
	    (void)SvUPGRADE(GvSVn(gv), SVt_PVLV);
	    goto magicalize;

	case '!':

	    /* If %! has been used, automatically load Errno.pm.
	       The require will itself set errno, so in order to
	       preserve its value we have to set up the magic
	       now (rather than going to magicalize)
	    */
d936 1
a936 1
	    sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
d938 2
a939 2
	    if (sv_type == SVt_PVHV)
		require_errno(gv);
d941 3
d945 2
a946 3
	case '-':
	{
	    AV* const av = GvAVn(gv);
d949 67
a1015 11
	    goto magicalize;
	}
	case '#':
	case '*':
	    if (sv_type == SVt_PV && ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			    "Use of $%s is deprecated", name);
	    goto magicalize;
	case '|':
	    sv_setiv(GvSVn(gv), (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0);
	    goto magicalize;
d1017 5
a1021 3
	case '+':
	{
	    AV* const av = GvAVn(gv);
d1024 20
a1043 1
	    /* FALL THROUGH */
a1044 41
	case '\023':	/* $^S */
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	ro_magicalize:
	    SvREADONLY_on(GvSVn(gv));
	    /* FALL THROUGH */
	case '[':
	case '^':
	case '~':
	case '=':
	case '%':
	case '.':
	case '(':
	case ')':
	case '<':
	case '>':
	case ',':
	case '\\':
	case '/':
	case '\001':	/* $^A */
	case '\003':	/* $^C */
	case '\004':	/* $^D */
	case '\005':	/* $^E */
	case '\006':	/* $^F */
	case '\010':	/* $^H */
	case '\011':	/* $^I, NOT \t in EBCDIC */
	case '\016':	/* $^N */
	case '\017':	/* $^O */
	case '\020':	/* $^P */
	case '\024':	/* $^T */
	case '\027':	/* $^W */
	magicalize:
	    sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
	    break;
d1046 8
a1053 3
	case '\014':	/* $^L */
	    sv_setpvn(GvSVn(gv),"\f",1);
	    PL_formfeed = GvSVn(gv);
d1055 5
a1059 2
	case ';':
	    sv_setpvn(GvSVn(gv),"\034",1);
d1061 5
a1065 3
	case ']':
	{
	    SV * const sv = GvSVn(gv);
d1080 3
a1082 3
	case '\026':	/* $^V */
	{
	    SV * const sv = GvSVn(gv);
a1086 1
	}
d1094 1
a1094 2
    const char *name;
    const HV * const hv = GvSTASH(gv);
d1100 2
a1101 7

    name = HvNAME_get(hv);
    if (!name)
	name = "__ANON__";

    if (keepmain || strNE(name, "main")) {
	sv_catpv(sv,name);
d1116 4
a1119 2
    const GV * const egv = GvEGV(gv);
    gv_fullname4(sv, (GV *) (egv ? egv : gv), prefix, keepmain);
d1128 1
a1128 1
/* compatibility with versions <= 5.003. */
d1132 1
a1132 1
    gv_fullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
d1135 1
a1135 1
/* compatibility with versions <= 5.003. */
d1139 1
a1139 1
    gv_efullname3(sv, gv, sv == (const SV*)gv ? "*" : "");
d1145 1
a1146 1
    IO * const io = (IO*)NEWSV(0,0);
d1148 1
d1150 1
a1150 4
    /* This used to read SvREFCNT(io) = 1;
       It's not clear why the reference count needed an explicit reset. NWC
    */
    assert (SvREFCNT(io) == 1);
d1152 2
a1153 1
    /* Clear the stashcache because a new IO could overrule a package name */
d1159 1
a1159 1
    SvSTASH_set(io, (HV*)SvREFCNT_inc(GvHV(iogv)));
d1166 1
d1168 2
a1173 1
        const HE *entry;
a1174 2
            register GV *gv;
            HV *hv;
d1182 1
a1182 1
                const char *file;
d1189 2
d1192 1
a1192 1
#   define LIB_COMPONENT ":lib:"
d1194 1
a1194 1
#   define LIB_COMPONENT "/lib/"
d1196 1
a1196 3
		if (file
		    && PERL_FILE_IS_ABSOLUTE(file)
		    && (instr(file, LIB_COMPONENT) || instr(file, ".pm")))
d1202 1
a1202 1
		CopFILE(PL_curcop) = (char *)file;	/* set for warning */
d1208 1
a1208 1
			HvNAME_get(stash), GvNAME(gv));
d1270 6
a1275 8
    /* FIXME - another reference loop GV -> symtab -> GV ?
       Somehow gp->gp_hv can end up pointing at freed garbage.  */
    if (gp->gp_hv && SvTYPE(gp->gp_hv) == SVt_PVHV) {
	/* FIXME strlen HvNAME  */
	const char *hvname = HvNAME_get(gp->gp_hv);
	if (PL_stashcache && hvname)
	    hv_delete(PL_stashcache, hvname, strlen(hvname), G_DISCARD);
	SvREFCNT_dec(gp->gp_hv);
d1288 1
a1288 3
    AMT * const amtp = (AMT*)mg->mg_ptr;
    PERL_UNUSED_ARG(sv);

d1292 1
a1292 1
	    CV * const cv = amtp->table[i];
d1307 4
a1310 2
  MAGIC* const mg = mg_find((SV*)stash, PERL_MAGIC_overload_table);
  AMT * const amtp = (mg) ? (AMT*)mg->mg_ptr: (AMT *) NULL;
d1318 1
a1318 1
  DEBUG_o( Perl_deb(aTHX_ "Recalcing overload magic in package %s\n",HvNAME_get(stash)) );
d1329 1
d1334 3
a1336 3
    GV *gv = gv_fetchmeth(stash, PL_AMG_names[0], 2, -1);
    SV * const sv = gv ? GvSV(gv) : NULL;
    CV* cv;
a1339 5
#ifdef PERL_DONT_CREATE_GVSV
    else if (!sv) {
	/* Equivalent to !SvTRUE and !SvOK  */
    }
#endif
d1348 1
a1348 1
	const char *cooky = PL_AMG_names[i];
d1350 2
a1351 2
	const char *cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
	const STRLEN l = strlen(cooky);
d1353 2
a1354 2
	DEBUG_o( Perl_deb(aTHX_ "Checking overloading of \"%s\" in package \"%.256s\"\n",
		     cp, HvNAME_get(stash)) );
a1367 1
	    const char *hvname;
d1369 1
a1369 1
		&& strEQ(hvname = HvNAME_get(GvSTASH(CvGV(cv))), "overload")) {
d1374 6
a1379 7
		SV *gvsv = GvSV(gv);

		DEBUG_o( Perl_deb(aTHX_ "Resolving method \"%"SVf256\
			"\" for overloaded \"%s\" in package \"%.256s\"\n",
			     GvSV(gv), cp, hvname) );
		if (!gvsv || !SvPOK(gvsv)
		    || !(ngv = gv_fetchmethod_autoload(stash, SvPVX_const(gvsv),
d1382 5
a1386 4
		    /* Can be an import stub (created by "can"). */
		    const char * const name = (gvsv && SvPOK(gvsv)) ?  SvPVX_const(gvsv) : "???";
		    Perl_croak(aTHX_ "%s method \"%.256s\" overloading \"%s\" "\
				"in package \"%.256s\"",
d1389 1
a1389 1
			       name, cp, hvname);
d1393 2
a1394 2
	    DEBUG_o( Perl_deb(aTHX_ "Overloading \"%s\" in package \"%.256s\" via \"%.256s::%.256s\"\n",
			 cp, HvNAME_get(stash), HvNAME_get(GvSTASH(CvGV(cv))),
d1428 1
d1430 1
a1430 1
    if (!stash || !HvNAME_get(stash))
d1443 1
a1443 1
	CV * const ret = amtp->table[id];
d1449 1
a1449 1
	    GV * const gv = gv_fetchmethod(stash, PL_AMG_names[id]);
d1456 1
a1456 1

d1468 2
a1469 4
  int off = 0, off1, lr = 0, notfound = 0;
  int postpr = 0, force_cpy = 0;
  int assign = AMGf_assign & flags;
  const int assignshift = assign ? 1 : 0;
d1486 1
a1486 1
#endif
d1519 6
a1524 6
         case not_amg:
           (void)((cv = cvp[off=bool__amg])
                  || (cv = cvp[off=numer_amg])
                  || (cv = cvp[off=string_amg]));
           postpr = 1;
           break;
d1531 1
a1531 1
	     SV* const tmpRef=SvRV(left);
d1537 1
a1537 1
		SV* const newref = newSVsv(tmpRef);
d1539 1
a1539 1
		SvSTASH_set(newref, (HV*)SvREFCNT_inc(SvSTASH(tmpRef)));
d1547 1
a1547 1
	     SV* const nullsv=sv_2mortal(newSViv(0));
d1549 1
a1549 1
	       SV* const lessp = amagic_call(left,nullsv,
d1553 1
a1553 1
	       SV* const lessp = amagic_call(left,nullsv,
d1653 1
a1653 1
		      "Operation \"%s\": no method found,%sargument %s%s%s%s",
d1660 1
a1660 1
		        HvNAME_get(SvSTASH(SvRV(left))):
d1668 1
a1668 1
		        HvNAME_get(SvSTASH(SvRV(right))):
d1671 1
a1671 1
	  DEBUG_o( Perl_deb(aTHX_ "%s", SvPVX_const(msg)) );
d1683 1
a1683 1
		     "Overloaded operator \"%s\"%s%s%s:\n\tmethod%s found%s in package %s%s\n",
d1686 1
a1686 1
		     " (initially \"",
d1689 1
a1689 1
		     method+assignshift==off? "" : "\")",
d1693 1
a1693 1
		     stash ? HvNAME_get(stash) : "null",
d1727 1
a1727 1
    const bool oldcatch = CATCH_GET;
d1765 1
a1765 1
      int ans;
a1789 2
      default:
        ans=0; break;
a1813 4
Currently assumes that C<name> is NUL terminated (as well as len being valid).
This assumption is met by all callers within the perl core, which all pass
pointers returned by SvPV.

d1819 2
a1820 1
    PERL_UNUSED_ARG(flags);
d1822 27
a1848 45
    if (len > 1) {
	const char * const name1 = name + 1;
	switch (*name) {
	case 'I':
	    if (len == 3 && name1[1] == 'S' && name[2] == 'A')
		goto yes;
	    break;
	case 'O':
	    if (len == 8 && strEQ(name1, "VERLOAD"))
		goto yes;
	    break;
	case 'S':
	    if (len == 3 && name[1] == 'I' && name[2] == 'G')
		goto yes;
	    break;
	    /* Using ${^...} variables is likely to be sufficiently rare that
	       it seems sensible to avoid the space hit of also checking the
	       length.  */
	case '\017':   /* ${^OPEN} */
	    if (strEQ(name1, "PEN"))
		goto yes;
	    break;
	case '\024':   /* ${^TAINT} */
	    if (strEQ(name1, "AINT"))
		goto yes;
	    break;
	case '\025':	/* ${^UNICODE} */
	    if (strEQ(name1, "NICODE"))
		goto yes;
	    if (strEQ(name1, "TF8LOCALE"))
		goto yes;
	    break;
	case '\027':   /* ${^WARNING_BITS} */
	    if (strEQ(name1, "ARNING_BITS"))
		goto yes;
	    break;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
d1850 60
a1909 1
	    const char *end = name + len;
a1913 61
	    goto yes;
	}
	}
    } else {
	/* Because we're already assuming that name is NUL terminated
	   below, we can treat an empty name as "\0"  */
	switch (*name) {
	case '&':
	case '`':
	case '\'':
	case ':':
	case '?':
	case '!':
	case '-':
	case '*':
	case '#':
	case '[':
	case '^':
	case '~':
	case '=':
	case '%':
	case '.':
	case '(':
	case ')':
	case '<':
	case '>':
	case ',':
	case '\\':
	case '/':
	case '|':
	case '+':
	case ';':
	case ']':
	case '\001':   /* $^A */
	case '\003':   /* $^C */
	case '\004':   /* $^D */
	case '\005':   /* $^E */
	case '\006':   /* $^F */
	case '\010':   /* $^H */
	case '\011':   /* $^I, NOT \t in EBCDIC */
	case '\014':   /* $^L */
	case '\016':   /* $^N */
	case '\017':   /* $^O */
	case '\020':   /* $^P */
	case '\023':   /* $^S */
	case '\024':   /* $^T */
	case '\026':   /* $^V */
	case '\027':   /* $^W */
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	yes:
	    return TRUE;
	default:
	    break;
d1915 4
a1921 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a35 1
#include "overload.c"
d37 2
a38 2
static const char S_autoload[] = "AUTOLOAD";
static const STRLEN S_autolen = sizeof(S_autoload)-1;
d48 1
a48 1
	GvSV(gv) = newSV(0);
d76 2
a77 17
    dVAR;
    if (!gv || SvTYPE((SV*)gv) != SVt_PVGV) {

        /*
         * if it walks like a dirhandle, then let's assume that
         * this is a dirhandle.
         */
	const char * const fh =
			 PL_op->op_type ==  OP_READDIR ||
                         PL_op->op_type ==  OP_TELLDIR ||
                         PL_op->op_type ==  OP_SEEKDIR ||
                         PL_op->op_type ==  OP_REWINDDIR ||
                         PL_op->op_type ==  OP_CLOSEDIR ?
                         "dirhandle" : "filehandle";
        Perl_croak(aTHX_ "Bad symbol for %s", fh);
    }

d92 1
a92 9
    return gv_fetchfile_flags(name, strlen(name), 0);
}

GV *
Perl_gv_fetchfile_flags(pTHX_ const char *const name, const STRLEN namelen,
			const U32 flags)
{
    dVAR;
    char smallbuf[128];
d94 1
a94 1
    const STRLEN tmplen = namelen + 2;
a96 2
    PERL_UNUSED_ARG(flags);

d98 1
a98 1
	return NULL;
d100 2
a101 1
    if (tmplen <= sizeof smallbuf)
d104 1
a104 1
	Newx(tmpbuf, tmplen, char);
d108 1
a108 1
    memcpy(tmpbuf + 2, name, namelen);
d113 1
a113 1
	GvSV(gv) = newSVpvn(name, namelen);
d115 1
a115 1
	sv_setpvn(GvSV(gv), name, namelen);
d118 1
a118 1
	    hv_magic(GvHVn(gv_AVadd(gv)), NULL, PERL_MAGIC_dbfile);
a124 60
/*
=for apidoc gv_const_sv

If C<gv> is a typeglob whose subroutine entry is a constant sub eligible for
inlining, or C<gv> is a placeholder reference that would be promoted to such
a typeglob, then returns the value returned by the sub.  Otherwise, returns
NULL.

=cut
*/

SV *
Perl_gv_const_sv(pTHX_ GV *gv)
{
    if (SvTYPE(gv) == SVt_PVGV)
	return cv_const_sv(GvCVu(gv));
    return SvROK(gv) ? SvRV(gv) : NULL;
}

GP *
Perl_newGP(pTHX_ GV *const gv)
{
    GP *gp;
    U32 hash;
#ifdef USE_ITHREADS
    const char *const file
	= (PL_curcop && CopFILE(PL_curcop)) ? CopFILE(PL_curcop) : "";
    const STRLEN len = strlen(file);
#else
    SV *const temp_sv = CopFILESV(PL_curcop);
    const char *file;
    STRLEN len;

    if (temp_sv) {
	file = SvPVX(temp_sv);
	len = SvCUR(temp_sv);
    } else {
	file = "";
	len = 0;
    }
#endif

    PERL_HASH(hash, file, len);

    Newxz(gp, 1, GP);

#ifndef PERL_DONT_CREATE_GVSV
    gp->gp_sv = newSV(0);
#endif

    gp->gp_line = PL_curcop ? CopLINE(PL_curcop) : 0;
    /* XXX Ideally this cast would be replaced with a change to const char*
       in the struct.  */
    gp->gp_file_hek = share_hek(file, len, hash);
    gp->gp_egv = gv;
    gp->gp_refcnt = 1;

    return gp;
}

d128 3
a130 26
    dVAR;
    const U32 old_type = SvTYPE(gv);
    const bool doproto = old_type > SVt_NULL;
    char * const proto = (doproto && SvPOK(gv)) ? SvPVX(gv) : NULL;
    const STRLEN protolen = proto ? SvCUR(gv) : 0;
    SV *const has_constant = doproto && SvROK(gv) ? SvRV(gv) : NULL;
    const U32 exported_constant = has_constant ? SvPCS_IMPORTED(gv) : 0;

    assert (!(proto && has_constant));

    if (has_constant) {
	/* The constant has to be a simple scalar type.  */
	switch (SvTYPE(has_constant)) {
	case SVt_PVAV:
	case SVt_PVHV:
	case SVt_PVCV:
	case SVt_PVFM:
	case SVt_PVIO:
            Perl_croak(aTHX_ "Cannot convert a reference to %s to typeglob",
		       sv_reftype(has_constant, 0));
	default: NOOP;
	}
	SvRV_set(gv, NULL);
	SvROK_off(gv);
    }

d132 1
a132 5
    if (old_type < SVt_PVGV) {
	if (old_type >= SVt_PV)
	    SvCUR_set(gv, 0);
	sv_upgrade((SV*)gv, SVt_PVGV);
    }
d141 17
a157 8
    SvIOK_off(gv);
    isGV_with_GP_on(gv);

    GvGP(gv) = Perl_newGP(aTHX_ gv);
    GvSTASH(gv) = stash;
    if (stash)
	Perl_sv_add_backref(aTHX_ (SV*)stash, (SV*)gv);
    gv_name_set(gv, name, len, GV_ADD);
d161 1
d163 3
a165 12
	if (has_constant) {
	    /* newCONSTSUB takes ownership of the reference from us.  */
	    GvCV(gv) = newCONSTSUB(stash, name, has_constant);
	    /* If this reference was a copy of another, then the subroutine
	       must have been "imported", by a Perl space assignment to a GV
	       from a reference to CV.  */
	    if (exported_constant)
		GvIMPORTED_CV_on(gv);
	} else {
	    (void) start_subparse(0,0);	/* Create empty CV in compcv. */
	    GvCV(gv) = PL_compcv;
	}
d168 1
a168 1
        mro_method_changed_in(GvSTASH(gv)); /* sub Foo::bar($) { (shift) } sub ASDF::baz($); *ASDF::baz = \&Foo::bar */
d172 7
d180 2
a181 2
	    sv_usepvn_flags((SV*)GvCV(gv), proto, protolen,
			    SV_HAS_TRAILING_NUL);
a202 1
    case SVt_PVGV:
d205 1
a205 5
	if(GvSVn(gv)) {
	    /* Work round what appears to be a bug in Sun C++ 5.8 2005/10/13
	       If we just cast GvSVn(gv) to void, it ignores evaluating it for
	       its side effect */
	}
d220 1
a220 1
up caching info for this glob.
a230 2
/* NOTE: No support for tied ISA */

d234 3
a236 1
    dVAR;
d238 1
a238 8
    AV* linear_av;
    SV** linear_svp;
    SV* linear_sv;
    HV* cstash;
    GV* candidate = NULL;
    CV* cand_cv = NULL;
    CV* old_cv;
    GV* topgv = NULL;
a239 4
    I32 create = (level >= 0) ? 1 : 0;
    I32 items;
    STRLEN packlen;
    U32 topgen_cmp;
d243 2
a244 2
	create = 0;  /* probably appropriate */
	if(!(stash = gv_stashpvs("UNIVERSAL", 0)))
a247 2
    assert(stash);

d250 2
a251 1
      Perl_croak(aTHX_ "Can't use anonymous symbol table for method lookup");
d253 3
a255 2
    assert(hvname);
    assert(name);
d259 43
a301 25
    topgen_cmp = HvMROMETA(stash)->cache_gen + PL_sub_generation;

    /* check locally for a real method or a cache entry */
    gvp = (GV**)hv_fetch(stash, name, len, create);
    if(gvp) {
        topgv = *gvp;
        assert(topgv);
        if (SvTYPE(topgv) != SVt_PVGV)
            gv_init(topgv, stash, name, len, TRUE);
        if ((cand_cv = GvCV(topgv))) {
            /* If genuine method or valid cache entry, use it */
            if (!GvCVGEN(topgv) || GvCVGEN(topgv) == topgen_cmp) {
                return topgv;
            }
            else {
                /* stale cache entry, junk it and move on */
	        SvREFCNT_dec(cand_cv);
	        GvCV(topgv) = cand_cv = NULL;
	        GvCVGEN(topgv) = 0;
            }
        }
        else if (GvCVGEN(topgv) == topgen_cmp) {
            /* cache indicates no such method definitively */
            return 0;
        }
d304 18
a321 9
    packlen = HvNAMELEN_get(stash);
    if (packlen >= 7 && strEQ(hvname + packlen - 7, "::SUPER")) {
        HV* basestash;
        packlen -= 7;
        basestash = gv_stashpvn(hvname, packlen, GV_ADD);
        linear_av = mro_get_linear_isa(basestash);
    }
    else {
        linear_av = mro_get_linear_isa(stash); /* has ourselves at the top of the list */
d324 1
a324 13
    linear_svp = AvARRAY(linear_av) + 1; /* skip over self */
    items = AvFILLp(linear_av); /* no +1, to skip over self */
    while (items--) {
        linear_sv = *linear_svp++;
        assert(linear_sv);
        cstash = gv_stashsv(linear_sv, 0);

        if (!cstash) {
            if (ckWARN(WARN_SYNTAX))
                Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Can't locate package %"SVf" for @@%s::ISA",
                    SVfARG(linear_sv), hvname);
            continue;
        }
d326 2
a327 1
        assert(cstash);
d329 27
a355 39
        gvp = (GV**)hv_fetch(cstash, name, len, 0);
        if (!gvp) continue;
        candidate = *gvp;
        assert(candidate);
        if (SvTYPE(candidate) != SVt_PVGV) gv_init(candidate, cstash, name, len, TRUE);
        if (SvTYPE(candidate) == SVt_PVGV && (cand_cv = GvCV(candidate)) && !GvCVGEN(candidate)) {
            /*
             * Found real method, cache method in topgv if:
             *  1. topgv has no synonyms (else inheritance crosses wires)
             *  2. method isn't a stub (else AUTOLOAD fails spectacularly)
             */
            if (topgv && (GvREFCNT(topgv) == 1) && (CvROOT(cand_cv) || CvXSUB(cand_cv))) {
                  if ((old_cv = GvCV(topgv))) SvREFCNT_dec(old_cv);
                  SvREFCNT_inc_simple_void_NN(cand_cv);
                  GvCV(topgv) = cand_cv;
                  GvCVGEN(topgv) = topgen_cmp;
            }
	    return candidate;
        }
    }

    /* Check UNIVERSAL without caching */
    if(level == 0 || level == -1) {
        candidate = gv_fetchmeth(NULL, name, len, 1);
        if(candidate) {
            cand_cv = GvCV(candidate);
            if (topgv && (GvREFCNT(topgv) == 1) && (CvROOT(cand_cv) || CvXSUB(cand_cv))) {
                  if ((old_cv = GvCV(topgv))) SvREFCNT_dec(old_cv);
                  SvREFCNT_inc_simple_void_NN(cand_cv);
                  GvCV(topgv) = cand_cv;
                  GvCVGEN(topgv) = topgen_cmp;
            }
            return candidate;
        }
    }

    if (topgv && GvREFCNT(topgv) == 1) {
        /* cache the fact that the method is not defined */
        GvCVGEN(topgv) = topgen_cmp;
d384 1
a384 1
	    return NULL;	/* UNIVERSAL::AUTOLOAD could cause trouble */
d386 1
a386 1
	    return NULL;
d388 1
a388 1
	    return NULL;
d391 1
a391 1
	    return NULL;
d397 1
a397 1
	    return NULL;
d404 14
a444 42
STATIC HV*
S_gv_get_super_pkg(pTHX_ const char* name, I32 namelen)
{
    AV* superisa;
    GV** gvp;
    GV* gv;
    HV* stash;

    stash = gv_stashpvn(name, namelen, 0);
    if(stash) return stash;

    /* If we must create it, give it an @@ISA array containing
       the real package this SUPER is for, so that it's tied
       into the cache invalidation code correctly */
    stash = gv_stashpvn(name, namelen, GV_ADD);
    gvp = (GV**)hv_fetchs(stash, "ISA", TRUE);
    gv = *gvp;
    gv_init(gv, stash, "ISA", 3, TRUE);
    superisa = GvAVn(gv);
    GvMULTI_on(gv);
    sv_magic((SV*)superisa, (SV*)gv, PERL_MAGIC_isa, NULL, 0);
#ifdef USE_ITHREADS
    av_push(superisa, newSVpv(CopSTASHPV(PL_curcop), 0));
#else
    av_push(superisa, newSVhek(CopSTASH(PL_curcop)
			       ? HvNAME_HEK(CopSTASH(PL_curcop)) : NULL));
#endif

    return stash;
}

/* FIXME. If changing this function note the comment in pp_hot's
   S_method_common:

   This code tries to figure out just what went wrong with
   gv_fetchmethod.  It therefore needs to duplicate a lot of
   the internals of that function. ...

   I'd guess that with one more flag bit that could all be moved inside
   here.
*/

a447 1
    dVAR;
d449 1
a449 1
    const char *nsplit = NULL;
d454 1
a454 1
	stash = NULL;
d469 1
a469 1
	    SV * const tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_ "%s::SUPER",
d472 1
a472 1
	    stash = gv_get_super_pkg(SvPVX_const(tmpstr), SvCUR(tmpstr));
d478 1
a478 1
            stash = gv_stashpvn(origname, nsplit - origname, 0);
d484 2
a485 2
		gv_stashpvn(origname, nsplit - origname - 7, 0))
	      stash = gv_get_super_pkg(origname, nsplit - origname);
a522 1
    dVAR;
a528 1
    STRLEN packname_len = 0;
d531 1
a531 1
	return NULL;
d534 2
a535 2
	    packname = SvPV_const((SV*)stash, packname_len);
	    stash = NULL;
a538 1
	    packname_len = HvNAMELEN_get(stash);
d542 1
a542 1
	return NULL;
d546 1
a546 1
	return NULL;
d558 2
a559 1
    if (CvISXSUB(cv)) {
d570 1
d582 3
d588 1
a588 1
	GvSV(vargv) = newSV(0);
d593 5
a597 2
    sv_setpvn(varsv, packname, packname_len);
    sv_catpvs(varsv, "::");
d599 1
d603 2
a604 12

/* require_tie_mod() internal routine for requiring a module
 * that implements the logic of automatical ties like %! and %-
 *
 * The "gv" parameter should be the glob.
 * "varpv" holds the name of the var, used for error messages.
 * "namesv" holds the module name. Its refcount will be decremented.
 * "methpv" holds the method name to test for to check that things
 *   are working reasonably close to as expected.
 * "flags": if flag & 1 then save the scalar before loading.
 * For the protection of $! to work (it is set by this routine)
 * the sv slot must already be magicalized.
d606 2
a607 2
STATIC HV*
S_require_tie_mod(pTHX_ GV *gv, const char *varpv, SV* namesv, const char *methpv,const U32 flags)
d609 1
a609 2
    dVAR;
    HV* stash = gv_stashsv(namesv, 0);
d611 1
a611 5
    if (!stash || !(gv_fetchmethod(stash, methpv))) {
	SV *module = newSVsv(namesv);
	char varname = *varpv; /* varpv might be clobbered by load_module,
				  so save it. For the moment it's always
				  a single char. */
d613 1
d615 3
a617 5
	if ( flags & 1 )
	    save_scalar(gv);
	PUSHSTACKi(PERLSI_MAGIC);
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, module, NULL);
	POPSTACK;
d620 3
a622 7
	stash = gv_stashsv(namesv, 0);
	if (!stash)
	    Perl_croak(aTHX_ "panic: Can't use %%%c because %"SVf" is not available",
		    varname, SVfARG(namesv));
	else if (!gv_fetchmethod(stash, methpv))
	    Perl_croak(aTHX_ "panic: Can't use %%%c because %"SVf" does not support method %s",
		    varname, SVfARG(namesv), methpv);
a623 2
    SvREFCNT_dec(namesv);
    return stash;
d629 4
a632 2
Returns a pointer to the stash for a specified package.  Uses C<strlen> to
determine the length of C<name>, then calls C<gv_stashpvn()>.
d646 5
a650 7
Returns a pointer to the stash for a specified package.  The C<namelen>
parameter indicates the length of the C<name>, in bytes.  C<flags> is passed
to C<gv_fetchpvn_flags()>, so if set to C<GV_ADD> then the package will be
created if it does not already exist.  If the package does not exist and
C<flags> is 0 (or any other setting that does not create packages) then NULL
is returned.

d656 1
a656 1
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 flags)
d658 1
a658 1
    char smallbuf[128];
d663 1
a663 1
    if (namelen + 2 <= sizeof smallbuf)
d666 1
a666 1
	Newx(tmpbuf, namelen + 2, char);
d670 2
a671 1
    tmpgv = gv_fetchpvn_flags(tmpbuf, namelen, flags, SVt_PVHV);
d675 1
a675 1
	return NULL;
d687 2
a688 1
Returns a pointer to the stash for a specified package.  See C<gv_stashpvn>.
d694 1
a694 1
Perl_gv_stashsv(pTHX_ SV *sv, I32 flags)
d698 1
a698 7
    return gv_stashpvn(ptr, len, flags);
}


GV *
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, I32 sv_type) {
    return gv_fetchpvn_flags(nambeg, strlen(nambeg), add, sv_type);
a700 6
GV *
Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, I32 sv_type) {
    STRLEN len;
    const char * const nambeg = SvPV_const(name, len);
    return gv_fetchpvn_flags(nambeg, len, flags | SvUTF8(name), sv_type);
}
d703 1
a703 2
Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags,
		       I32 sv_type)
a704 1
    dVAR;
d706 1
a706 1
    register GV *gv = NULL;
d709 2
a710 14
    register const char *name_cursor;
    HV *stash = NULL;
    const I32 no_init = flags & (GV_NOADD_NOINIT | GV_NOINIT);
    const I32 no_expand = flags & GV_NOEXPAND;
    const I32 add = flags & ~GV_NOADD_MASK;
    const char *const name_end = nambeg + full_len;
    const char *const name_em1 = name_end - 1;
    U32 faking_it;

    if (flags & GV_NOTQUAL) {
	/* Caller promised that there is no stash, so we can skip the check. */
	len = full_len;
	goto no_stash;
    }
d712 1
a712 2
    if (full_len > 2 && *name == '*' && isALPHA(name[1])) {
	/* accidental stringify on a GV? */
a713 1
    }
d715 3
a717 4
    for (name_cursor = name; name_cursor < name_end; name_cursor++) {
	if ((*name_cursor == ':' && name_cursor < name_em1
	     && name_cursor[1] == ':')
	    || (*name_cursor == '\'' && name_cursor[1]))
d722 1
a722 1
		return NULL;
d724 1
a724 1
	    len = name_cursor - name;
d726 1
a726 1
		char smallbuf[128];
d729 1
a729 1
		if (len + 2 <= (I32)sizeof (smallbuf))
d732 1
a732 1
		    Newx(tmpbuf, len+2, char);
d736 1
d738 1
a738 1
		gv = gvp ? *gvp : NULL;
d748 1
a748 1
		    return NULL;
d754 1
a754 1
		    hv_name_set(stash, nambeg, name_cursor - nambeg, 0);
d757 6
a762 6
	    if (*name_cursor == ':')
		name_cursor++;
	    name_cursor++;
	    name = name_cursor;
	    if (name == name_end)
		return gv ? gv : (GV*)*hv_fetchs(PL_defstash, "main::", TRUE);
d765 1
a765 1
    len = name_cursor - name;
d770 1
a770 2
    no_stash:
	if (len && isIDFIRST_lazy(name)) {
d773 4
a776 2
	    switch (len) {
	    case 1:
d780 2
a781 4
	    case 3:
		if ((name[0] == 'I' && name[1] == 'N' && name[2] == 'C')
		    || (name[0] == 'E' && name[1] == 'N' && name[2] == 'V')
		    || (name[0] == 'S' && name[1] == 'I' && name[2] == 'G'))
d784 2
a785 8
	    case 4:
		if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
		    && name[3] == 'V')
		    global = TRUE;
		break;
	    case 5:
		if (name[0] == 'S' && name[1] == 'T' && name[2] == 'D'
		    && name[3] == 'I' && name[4] == 'N')
d788 3
a790 4
	    case 6:
		if ((name[0] == 'S' && name[1] == 'T' && name[2] == 'D')
		    &&((name[3] == 'O' && name[4] == 'U' && name[5] == 'T')
		       ||(name[3] == 'E' && name[4] == 'R' && name[5] == 'R')))
d793 2
a794 4
	    case 7:
		if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
		    && name[3] == 'V' && name[4] == 'O' && name[5] == 'U'
		    && name[6] == 'T')
d816 1
a816 1
			stash = NULL;
d828 1
a828 1
			stash = NULL;
a848 1
	    GV *gv;
d852 1
a852 6
	    gv = gv_fetchpvn_flags("<none>::", 8, GV_ADDMULTI, SVt_PVHV);
	    if(!gv) {
		/* symbol table under destruction */
		return NULL;
	    }	
	    stash = GvHV(gv);
d855 1
a855 1
	    return NULL;
d859 1
a859 1
	return NULL;
d863 1
a863 1
	return NULL;
d869 2
a870 6
	    if (len == 1 && (sv_type == SVt_PVHV || sv_type == SVt_PVGV)) {
	        if (*name == '!')
		    require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
		else if (*name == '-' || *name == '+')
		    require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);
	    }
d873 1
a873 3
    } else if (no_init) {
	return gv;
    } else if (no_expand && SvROK(gv)) {
d877 1
a877 8
    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */

    faking_it = SvOK(gv);
d882 1
a882 1
    gv_init_sv(gv, faking_it ? SVt_PVCV : sv_type);
a891 1
	    NOOP;
a904 3
		else if (strEQ(name2, "RGVOUT")) {
		    GvMULTI_on(gv);
		}
d914 1
a914 1
		    sv_magic((SV*)av, (SV*)gv, PERL_MAGIC_isa, NULL, 0);
d921 1
a921 1
			    gv_stashpvn(pname, 9, GV_ADD);
d923 1
a923 1
			    gv_stashpvn(pname, 7, GV_ADD);
d925 1
a925 1
			    gv_stashpvn(pname, 9, GV_ADD);
d927 1
a927 1
			    gv_stashpvn(pname, 9, GV_ADD);
d929 1
a929 1
			    gv_stashpvn(pname, 9, GV_ADD);
d937 1
a937 1
		    hv_magic(hv, NULL, PERL_MAGIC_overload);
d951 1
a951 1
		    hv_magic(hv, NULL, PERL_MAGIC_sig);
a965 4
            case '\003':        /* $^CHILD_ERROR_NATIVE */
		if (strEQ(name2, "HILD_ERROR_NATIVE"))
		    goto magicalize;
		break;
a969 3
            case '\015':        /* $^MATCH */
                if (strEQ(name2, "ATCH"))
		    goto magicalize;
a973 3
	    case '\020':        /* $^PREMATCH  $^POSTMATCH */
	        if (strEQ(name2, "REMATCH") || strEQ(name2, "OSTMATCH"))
		    goto magicalize;  
a982 2
		if (strEQ(name2, "TF8CACHE"))
		    goto magicalize;
d998 3
a1000 3
		/* Ensures that we have an all-digit variable, ${"1foo"} fails
		   this test  */
		/* This snippet is taken from is_gv_magical */
d1003 1
a1003 1
		    if (!isDIGIT(*end))	return gv;
d1005 1
a1005 1
		goto magicalize;
d1024 1
a1024 1
	    goto magicalize;
d1031 1
a1031 3
#ifdef COMPLEX_STATUS
	    SvUPGRADE(GvSVn(gv), SVt_PVLV);
#endif
d1035 6
a1040 2
	    GvMULTI_on(gv);
	    /* If %! has been used, automatically load Errno.pm. */
d1044 2
a1045 3
            /* magicalization must be done before require_tie_mod is called */
	    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
		require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
d1049 5
a1053 16
	case '+':
	GvMULTI_on(gv); /* no used once warnings here */
        {
            AV* const av = GvAVn(gv);
	    SV* const avc = (*name == '+') ? (SV*)av : NULL;

	    sv_magic((SV*)av, avc, PERL_MAGIC_regdata, NULL, 0);
            sv_magic(GvSVn(gv), (SV*)gv, PERL_MAGIC_sv, name, len);
            if (avc)
                SvREADONLY_on(GvSVn(gv));
            SvREADONLY_on(av);

            if (sv_type == SVt_PVHV || sv_type == SVt_PVGV)
                require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);

            break;
d1055 1
d1057 1
a1057 2
	case '#':
	    if (sv_type == SVt_PV && ckWARN2_d(WARN_DEPRECATED, WARN_SYNTAX))
d1059 2
a1060 2
			    "$%c is no longer supported", *name);
	    break;
d1065 7
a1071 6
	case '\010':	/* $^H */
	    {
		HV *const hv = GvHVn(gv);
		hv_magic(hv, NULL, PERL_MAGIC_hints);
	    }
	    goto magicalize;
a1072 3
	ro_magicalize:
	    SvREADONLY_on(GvSVn(gv));
	    /* FALL THROUGH */
d1082 3
d1103 1
d1124 12
a1135 5
	    if (!sv_derived_from(PL_patchlevel, "version"))
		upg_version(PL_patchlevel, TRUE);
	    GvSV(gv) = vnumify(PL_patchlevel);
	    SvREADONLY_on(GvSV(gv));
	    SvREFCNT_dec(sv);
d1141 1
a1141 2
	    GvSV(gv) = new_version(PL_patchlevel);
	    SvREADONLY_on(GvSV(gv));
d1151 1
a1151 1
Perl_gv_fullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain)
a1153 1
    STRLEN namelen;
d1162 1
a1162 3
    if (name) {
	namelen = HvNAMELEN_get(hv);
    } else {
a1163 2
	namelen = 8;
    }
d1166 2
a1167 2
	sv_catpvn(sv,name,namelen);
	sv_catpvs(sv,"::");
d1173 7
a1179 1
Perl_gv_efullname4(pTHX_ SV *sv, const GV *gv, const char *prefix, bool keepmain)
d1182 21
a1202 1
    gv_fullname4(sv, egv ? egv : gv, prefix, keepmain);
a1207 1
    dVAR;
d1209 3
a1211 1
    IO * const io = (IO*)newSV_type(SVt_PVIO);
d1219 1
a1219 1
    iogv = gv_fetchpvs("FileHandle::", 0, SVt_PVHV);
d1222 1
a1222 1
      iogv = gv_fetchpvs("IO::Handle::", GV_ADD, SVt_PVHV);
d1228 1
a1228 1
Perl_gv_check(pTHX_ const HV *stash)
a1229 1
    dVAR;
d1251 13
d1268 1
a1268 2
		CopFILEGV(PL_curcop)
		    = gv_fetchfile_flags(file, HEK_LEN(GvFILE_HEK(gv)), 0);
d1279 1
a1279 1
Perl_newGVgen(pTHX_ const char *pack)
a1280 1
    dVAR;
d1282 1
a1282 1
		      GV_ADD, SVt_PVGV);
a1289 1
    dVAR;
d1291 1
a1291 1
	return NULL;
d1295 1
a1295 3
	    /* If the GP they asked for a reference to contains
               a method cache entry, clear it first, so that we
               don't infect them with our cached entry */
d1297 1
a1297 1
	    gp->gp_cv = NULL;
d1300 4
a1310 1
    dVAR;
d1313 1
a1313 1
    if (!gv || !isGV_with_GP(gv) || !(gp = GvGP(gv)))
d1322 4
a1328 1
	GvGP(gv) = 0;
d1332 2
a1333 4
    if (gp->gp_file_hek)
	unshare_hek(gp->gp_file_hek);
    SvREFCNT_dec(gp->gp_sv);
    SvREFCNT_dec(gp->gp_av);
d1337 1
d1340 1
a1340 2
	    (void)hv_delete(PL_stashcache, hvname, HvNAMELEN_get(gp->gp_hv),
		      G_DISCARD);
d1343 3
a1345 3
    SvREFCNT_dec(gp->gp_io);
    SvREFCNT_dec(gp->gp_cv);
    SvREFCNT_dec(gp->gp_form);
d1361 1
a1361 1
	    if (cv) {
d1363 1
a1363 1
		amtp->table[i] = NULL;
a1374 1
  dVAR;
d1376 1
a1377 2
  const struct mro_meta* stash_meta = HvMROMETA(stash);
  U32 newgen;
d1379 4
a1382 9
  newgen = PL_sub_generation + stash_meta->pkg_gen + stash_meta->cache_gen;
  if (mg) {
      const AMT * const amtp = (AMT*)mg->mg_ptr;
      if (amtp->was_ok_am == PL_amagic_generation
	  && amtp->was_ok_sub == newgen) {
	  return (bool)AMT_OVERLOADED(amtp);
      }
      sv_unmagic((SV*)stash, PERL_MAGIC_overload_table);
  }
d1388 1
a1388 1
  amt.was_ok_sub = newgen;
d1407 1
a1407 1
	NOOP;   /* Equivalent to !SvTRUE and !SvOK  */
d1416 1
a1416 1
	amt.table[i] = NULL;
d1418 1
a1418 1
	const char * const cooky = PL_AMG_names[i];
d1420 2
a1421 2
	const char * const cp = (i >= DESTROY_amg ? cooky : AMG_id2name(i));
	const STRLEN l = PL_AMG_namelens[i];
d1444 1
a1444 1
		GV *ngv = NULL;
d1449 1
a1449 1
			     (void*)GvSV(gv), cp, hvname) );
d1474 1
a1474 1
	amt.table[i]=(CV*)SvREFCNT_inc_simple(cv);
a1496 1
    dVAR;
a1498 2
    U32 newgen;
    struct mro_meta* stash_meta;
d1501 1
a1501 5
        return NULL;

    stash_meta = HvMROMETA(stash);
    newgen = PL_sub_generation + stash_meta->pkg_gen + stash_meta->cache_gen;

a1507 1
    assert(mg);
d1510 1
a1510 1
	 || amtp->was_ok_sub != newgen )
d1527 1
a1527 1
    return NULL;
a1533 1
  dVAR;
d1551 1
a1551 1
			: NULL))
a1610 6
		/* As a bit of a source compatibility hack, SvAMAGIC() and
		   friends dereference an RV, to behave the same was as when
		   overloading was stored on the reference, not the referant.
		   Hence we can't use SvAMAGIC_on()
		*/
		SvFLAGS(newref) |= SVf_AMAGIC;
d1669 1
a1669 1
			  : NULL))
a1707 13
	 case lt_amg:
	 case le_amg:
	 case gt_amg:
	 case ge_amg:
	 case eq_amg:
	 case ne_amg:
	 case slt_amg:
	 case sle_amg:
	 case sgt_amg:
	 case sge_amg:
	 case seq_amg:
	 case sne_amg:
	   postpr = 0; break;
a1720 3
      } else if ((amtp && amtp->fallback >= AMGfallYES) && !DEBUG_o_TEST) {
	/* Skip generating the "no method found" message.  */
	return NULL;
d1745 1
a1745 1
	  Perl_croak(aTHX_ "%"SVf, SVfARG(msg));
d1804 1
a1804 1
    myop.op_next = NULL;
d1821 1
a1821 2
      PUSHs( sv_2mortal(newSVpvn(AMG_id2name(method + assignshift),
				 AMG_id2namelen(method + assignshift))));
a1877 16
=for apidoc is_gv_magical_sv

Returns C<TRUE> if given the name of a magical GV. Calls is_gv_magical.

=cut
*/

bool
Perl_is_gv_magical_sv(pTHX_ SV *name, U32 flags)
{
    STRLEN len;
    const char * const temp = SvPV_const(name, len);
    return is_gv_magical(temp, len, flags);
}

/*
d1895 1
a1895 1
Perl_is_gv_magical(pTHX_ const char *name, STRLEN len, U32 flags)
a1896 1
    PERL_UNUSED_CONTEXT;
d1964 1
a2013 20
}

void
Perl_gv_name_set(pTHX_ GV *gv, const char *name, U32 len, U32 flags)
{
    dVAR;
    U32 hash;

    assert(name);
    PERL_UNUSED_ARG(flags);

    if (len > I32_MAX)
	Perl_croak(aTHX_ "panic: gv name too long (%"UVuf")", (UV) len);

    if (!(flags & GV_ADD) && GvNAME_HEK(gv)) {
	unshare_hek(GvNAME_HEK(gv));
    }

    PERL_HASH(hash, name, len);
    GvNAME_HEK(gv) = share_hek(name, len, hash);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 by Larry Wall and others
d13 1
a13 1
 * of your inquisitiveness, I shall spend all the rest of my days in answering
a17 2
 *
 *     [p.599 of _The Lord of the Rings_, III/xi: "The Palantír"]
d46 1
a46 3
    PERL_ARGS_ASSERT_GV_SVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
d57 1
a57 3
    PERL_ARGS_ASSERT_GV_AVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
d67 1
a67 3
    PERL_ARGS_ASSERT_GV_HVADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV)
d78 1
a78 4

    PERL_ARGS_ASSERT_GV_IOADD;

    if (!gv || SvTYPE((const SV *)gv) != SVt_PVGV) {
a107 1
    PERL_ARGS_ASSERT_GV_FETCHFILE;
a120 1
    PERL_ARGS_ASSERT_GV_FETCHFILE_FLAGS;
d142 1
a142 1
	if (PERLDB_LINE || PERLDB_SAVESRC)
a163 2
    PERL_ARGS_ASSERT_GV_CONST_SV;

a182 2
    PERL_ARGS_ASSERT_NEWGP;

a220 1
    PERL_ARGS_ASSERT_GV_INIT;
d243 1
a243 1
	sv_upgrade(MUTABLE_SV(gv), SVt_PVGV);
d259 1
a259 1
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(stash), MUTABLE_SV(gv));
d284 1
a284 1
	    sv_usepvn_flags(MUTABLE_SV(GvCV(gv)), proto, protolen,
a292 2
    PERL_ARGS_ASSERT_GV_INIT_SV;

a360 2
    PERL_ARGS_ASSERT_GV_FETCHMETH;

a494 2
    PERL_ARGS_ASSERT_GV_FETCHMETH_AUTOLOAD;

d501 1
a501 1
	if (len == S_autolen && memEQ(name, S_autoload, S_autolen))
a554 2
    PERL_ARGS_ASSERT_GV_GET_SUPER_PKG;

d567 1
a567 1
    sv_magic(MUTABLE_SV(superisa), MUTABLE_SV(gv), PERL_MAGIC_isa, NULL, 0);
a596 3
    const char * const origname = name;

    PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD;
d602 1
a602 1
	if (*nend == '\'') {
d604 2
a605 6
	    name = nend + 1;
	}
	else if (*nend == ':' && *(nend + 1) == ':') {
	    nsplit = nend++;
	    name = nend + 1;
	}
d608 5
a612 1
	if ((nsplit - origname) == 5 && memEQ(origname, "SUPER", 5)) {
d638 1
a638 1
	    gv = MUTABLE_GV(&PL_sv_yes);
d677 1
a677 3
    PERL_ARGS_ASSERT_GV_AUTOLOAD4;

    if (len == S_autolen && memEQ(name, S_autoload, S_autolen))
d681 1
a681 1
	    packname = SvPV_const(MUTABLE_SV(stash), packname_len);
a760 2
    PERL_ARGS_ASSERT_REQUIRE_TIE_MOD;

a798 1
    PERL_ARGS_ASSERT_GV_STASHPV;
a823 2
    PERL_ARGS_ASSERT_GV_STASHPVN;

a856 3

    PERL_ARGS_ASSERT_GV_STASHSV;

a862 1
    PERL_ARGS_ASSERT_GV_FETCHPV;
a869 1
    PERL_ARGS_ASSERT_GV_FETCHSV;
a890 2
    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;

d926 1
a926 1
		if (gv && gv != (const GV *)&PL_sv_undef) {
d934 1
a934 1
		if (!gv || gv == (const GV *)&PL_sv_undef)
d949 1
a949 2
		return gv
		    ? gv : MUTABLE_GV(*hv_fetchs(PL_defstash, "main::", TRUE));
d1010 1
a1010 1
			*gvp == (const GV *)&PL_sv_undef ||
d1050 1
a1050 1
	    gv = gv_fetchpvs("<none>::", GV_ADDMULTI, SVt_PVHV);
d1065 1
a1065 1
    if (!gvp || *gvp == (const GV *)&PL_sv_undef)
d1134 1
a1134 2
		    sv_magic(MUTABLE_SV(av), MUTABLE_SV(gv), PERL_MAGIC_isa,
			     NULL, 0);
d1139 11
a1149 10
			    av_push(av, newSVpvs("NDBM_File"));
			    gv_stashpvs("NDBM_File", GV_ADD);
			    av_push(av, newSVpvs("DB_File"));
			    gv_stashpvs("DB_File", GV_ADD);
			    av_push(av, newSVpvs("GDBM_File"));
			    gv_stashpvs("GDBM_File", GV_ADD);
			    av_push(av, newSVpvs("SDBM_File"));
			    gv_stashpvs("SDBM_File", GV_ADD);
			    av_push(av, newSVpvs("ODBM_File"));
			    gv_stashpvs("ODBM_File", GV_ADD);
d1272 1
a1272 1
	    sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
d1284 1
a1284 1
	    SV* const avc = (*name == '+') ? MUTABLE_SV(av) : NULL;
d1286 2
a1287 2
	    sv_magic(MUTABLE_SV(av), avc, PERL_MAGIC_regdata, NULL, 0);
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
d1351 1
a1351 1
	    sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, name, len);
d1355 1
a1355 1
	    sv_setpvs(GvSVn(gv),"\f");
d1359 1
a1359 1
	    sv_setpvs(GvSVn(gv),"\034");
a1389 3

    PERL_ARGS_ASSERT_GV_FULLNAME4;

a1414 3

    PERL_ARGS_ASSERT_GV_EFULLNAME4;

d1423 1
a1423 1
    IO * const io = MUTABLE_IO(newSV_type(SVt_PVIO));
d1435 1
a1435 1
    SvSTASH_set(io, MUTABLE_HV(SvREFCNT_inc(GvHV(iogv))));
a1444 2
    PERL_ARGS_ASSERT_GV_CHECK;

d1453 1
a1453 1
		(gv = MUTABLE_GV(HeVAL(entry))) && isGV(gv) && (hv = GvHV(gv)))
d1460 1
a1460 1
		gv = MUTABLE_GV(HeVAL(entry));
a1482 3

    PERL_ARGS_ASSERT_NEWGVGEN;

a1557 2
    PERL_ARGS_ASSERT_MAGIC_FREEOVRLD;

d1563 1
a1563 1
		SvREFCNT_dec(MUTABLE_SV(cv));
d1577 1
a1577 1
  MAGIC* const mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
a1581 2
  PERL_ARGS_ASSERT_GV_AMUPDATE;

d1589 1
a1589 1
      sv_unmagic(MUTABLE_SV(stash), PERL_MAGIC_overload_table);
d1679 1
a1679 1
	    cv = MUTABLE_CV(gv);
d1682 1
a1682 1
	amt.table[i]=MUTABLE_CV(SvREFCNT_inc_simple(cv));
d1688 1
a1688 1
      sv_magic(MUTABLE_SV(stash), 0, PERL_MAGIC_overload_table,
d1696 1
a1696 1
  sv_magic(MUTABLE_SV(stash), 0, PERL_MAGIC_overload_table,
d1717 1
a1717 1
    mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
d1721 1
a1721 1
	mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table);
a1762 24

  PERL_ARGS_ASSERT_AMAGIC_CALL;

  if ( PL_curcop->cop_hints & HINT_NO_AMAGIC ) {
      SV *lex_mask = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash,
					      0, "overloading", 11, 0, 0);

      if ( !lex_mask || !SvOK(lex_mask) )
	  /* overloading lexically disabled */
	  return NULL;
      else if ( lex_mask && SvPOK(lex_mask) ) {
	  /* we have an entry in the hints hash, check if method has been
	   * masked by overloading.pm */
	  STRLEN len;
	  const int offset = method / 8;
	  const int bit    = method % 8;
	  char *pv = SvPV(lex_mask, len);

	  /* Bit set, so this overloading operator is disabled */
	  if ( (STRLEN)offset < len && pv[offset] & ( 1 << bit ) )
	      return NULL;
      }
  }

d1765 1
a1765 1
      && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))
d1834 1
a1834 1
		SvSTASH_set(newref, MUTABLE_HV(SvREFCNT_inc(SvSTASH(tmpRef))));
d1889 1
a1889 1
	       && (mg = mg_find((const SV *)stash, PERL_MAGIC_overload_table))
d2060 2
a2061 2
      PUSHs(newSVpvn_flags(AMG_id2name(method + assignshift),
			   AMG_id2namelen(method + assignshift), SVs_TEMP));
d2063 1
a2063 1
    PUSHs(MUTABLE_SV(cv));
d2066 1
a2066 1
    if ((PL_op = PL_ppaddr[OP_ENTERSUB](aTHX)))
a2129 3

    PERL_ARGS_ASSERT_IS_GV_MAGICAL_SV;

a2155 2
    PERL_ARGS_ASSERT_IS_GV_MAGICAL;

d2160 1
a2160 1
	    if (len == 3 && name[1] == 'S' && name[2] == 'A')
d2278 1
a2278 1
    PERL_ARGS_ASSERT_GV_NAME_SET;
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d43 39
d83 1
a83 1
Perl_gv_add_by_type(pTHX_ GV *gv, svtype type)
d85 3
a87 1
    SV **where;
d90 13
a102 19
	const char *what;
	if (type == SVt_PVIO) {
	    /*
	     * if it walks like a dirhandle, then let's assume that
	     * this is a dirhandle.
	     */
	    what = PL_op->op_type ==  OP_READDIR ||
		PL_op->op_type ==  OP_TELLDIR ||
		PL_op->op_type ==  OP_SEEKDIR ||
		PL_op->op_type ==  OP_REWINDDIR ||
		PL_op->op_type ==  OP_CLOSEDIR ?
		"dirhandle" : "filehandle";
	    /* diag_listed_as: Bad symbol for filehandle */
	} else if (type == SVt_PVHV) {
	    what = "hash";
	} else {
	    what = type == SVt_PVAV ? "array" : "scalar";
	}
	Perl_croak(aTHX_ "Bad symbol for %s", what);
d105 7
a111 8
    if (type == SVt_PVHV) {
	where = (SV **)&GvHV(gv);
    } else if (type == SVt_PVAV) {
	where = (SV **)&GvAV(gv);
    } else if (type == SVt_PVIO) {
	where = (SV **)&GvIOp(gv);
    } else {
	where = &GvSV(gv);
a112 3

    if (!*where)
	*where = newSV_type(type);
d309 1
a309 1
S_gv_init_sv(pTHX_ GV *gv, const svtype sv_type)
d447 3
a449 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Can't locate package %"SVf" for @@%s::ISA",
			   SVfARG(linear_sv), hvname);
d604 6
a609 4
GV *
Perl_gv_fetchmethod_autoload(pTHX_ HV *stash, const char *name, I32 autoload)
{
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_AUTOLOAD;
d611 3
a613 2
    return gv_fetchmethod_flags(stash, name, autoload ? GV_AUTOLOAD : 0);
}
a614 2
/* Don't merge this yet, as it's likely to get a len parameter, and possibly
   even a U32 hash */
d616 1
a616 1
Perl_gv_fetchmethod_flags(pTHX_ HV *stash, const char *name, U32 flags)
a623 3
    SV *const error_report = MUTABLE_SV(stash);
    const U32 autoload = flags & GV_AUTOLOAD;
    const U32 do_croak = flags & GV_CROAK;
d625 1
a625 1
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_FLAGS;
d627 1
a627 1
    if (SvTYPE(stash) < SVt_PVHV)
a628 5
    else {
	/* The only way stash can become NULL later on is if nsplit is set,
	   which in turn means that there is no need for a SVt_PVHV case
	   the error reporting code.  */
    }
a669 25
	if (!gv && do_croak) {
	    /* Right now this is exclusively for the benefit of S_method_common
	       in pp_hot.c  */
	    if (stash) {
		Perl_croak(aTHX_
			   "Can't locate object method \"%s\" via package \"%.*s\"",
			   name, (int)HvNAMELEN_get(stash), HvNAME_get(stash));
	    }
	    else {
		STRLEN packlen;
		const char *packname;

		if (nsplit) {
		    packlen = nsplit - origname;
		    packname = origname;
		} else {
		    packname = SvPV_const(error_report, packlen);
		}

		Perl_croak(aTHX_
			   "Can't locate object method \"%s\" via package \"%.*s\""
			   " (perhaps you forgot to load \"%.*s\"?)",
			   name, (int)packlen, packname, (int)packlen, packname);
	    }
	}
d731 1
d733 3
a735 3
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
			 "Use of inherited AUTOLOAD for non-method %s::%.*s() is deprecated",
			 packname, (int)len, name);
a856 1
    U32 tmplen = namelen + 2;
d860 1
a860 1
    if (tmplen <= sizeof smallbuf)
d863 5
a867 5
	Newx(tmpbuf, tmplen, char);
    Copy(name, tmpbuf, namelen, char);
    tmpbuf[namelen]   = ':';
    tmpbuf[namelen+1] = ':';
    tmpgv = gv_fetchpvn_flags(tmpbuf, tmplen, flags, SVt_PVHV);
d901 1
a901 1
Perl_gv_fetchpv(pTHX_ const char *nambeg, I32 add, const svtype sv_type) {
d907 1
a907 1
Perl_gv_fetchsv(pTHX_ SV *name, I32 flags, const svtype sv_type) {
d916 1
a916 1
		       const svtype sv_type)
a1062 1
			/* diag_listed_as: Variable "%s" is not imported%s */
d1139 2
a1140 2
    if (add & GV_ADDWARN)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "Had to create %s unexpectedly", nambeg);
d1208 3
a1210 2
		    if (!PL_psig_name) {
			Newxz(PL_psig_name, 2 * SIG_SIZE, SV*);
a1211 13
			PL_psig_ptr = PL_psig_name + SIG_SIZE;
		    } else {
			/* I think that the only way to get here is to re-use an
			   embedded perl interpreter, where the previous
			   use didn't clean up fully because
			   PL_perl_destruct_level was 0. I'm not sure that we
			   "support" that, in that I suspect in that scenario
			   there are sufficient other garbage values left in the
			   interpreter structure that something else will crash
			   before we get here. I suspect that this is one of
			   those "doctor, it hurts when I do this" bugs.  */
			Zero(PL_psig_name, 2 * SIG_SIZE, SV*);
			Zero(PL_psig_pend, SIG_SIZE, int);
d1220 3
d1289 3
a1291 3
	case '&':		/* $& */
	case '`':		/* $` */
	case '\'':		/* $' */
d1302 1
a1302 1
	case ':':		/* $: */
d1306 1
a1306 1
	case '?':		/* $? */
d1312 1
a1312 1
	case '!':		/* $! */
d1323 2
a1324 2
	case '-':		/* $- */
	case '+':		/* $+ */
d1341 5
a1345 5
	case '*':		/* $* */
	case '#':		/* $# */
	    if (sv_type == SVt_PV)
		Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
				 "$%c is no longer supported", *name);
d1347 1
a1347 1
	case '|':		/* $| */
d1361 22
a1382 22
	case '0':		/* $0 */
	case '1':		/* $1 */
	case '2':		/* $2 */
	case '3':		/* $3 */
	case '4':		/* $4 */
	case '5':		/* $5 */
	case '6':		/* $6 */
	case '7':		/* $7 */
	case '8':		/* $8 */
	case '9':		/* $9 */
	case '[':		/* $[ */
	case '^':		/* $^ */
	case '~':		/* $~ */
	case '=':		/* $= */
	case '%':		/* $% */
	case '.':		/* $. */
	case '(':		/* $( */
	case ')':		/* $) */
	case '<':		/* $< */
	case '>':		/* $> */
	case '\\':		/* $\ */
	case '/':		/* $/ */
d1402 1
a1402 1
	case ';':		/* $; */
d1405 1
a1405 1
	case ']':		/* $] */
d1468 21
d1573 4
a1576 3
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
			 "Attempt to free unreferenced glob pointers"
			 pTHX__FORMAT pTHX__VALUE);
a1628 5
/* Returns:
 * 1 on success and there is some overload
 * 0 if there is no overload
 * -1 if some error occurred and it couldn't croak
 */
d1630 2
a1631 2
int
Perl_Gv_AMupdate(pTHX_ HV *stash, bool destructing)
d1646 1
a1646 1
	  return AMT_OVERLOADED(amtp) ? 1 : 0;
d1722 6
a1727 11
		    if (destructing) {
			return -1;
		    }
		    else {
			const char * const name = (gvsv && SvPOK(gvsv)) ?  SvPVX_const(gvsv) : "???";
			Perl_croak(aTHX_ "%s method \"%.256s\" overloading \"%s\" "\
				    "in package \"%.256s\"",
				   (GvCVGEN(gv) ? "Stub found while resolving"
				    : "Can't resolve"),
				   name, cp, hvname);
		    }
d1757 1
a1757 1
  return 0;
d1779 1
a1779 13
	/* If we're looking up a destructor to invoke, we must avoid
	 * that Gv_AMupdate croaks, because we might be dying already */
	if (Gv_AMupdate(stash, id == DESTROY_amg) == -1) {
	    /* and if it didn't found a destructor, we fall back
	     * to a simpler method that will only look for the
	     * destructor instead of the whole magic */
	    if (id == DESTROY_amg) {
		GV * const gv = gv_fetchmethod(stash, "DESTROY");
		if (gv)
		    return GvCV(gv);
	    }
	    return NULL;
	}
d1895 1
a1895 2
           if (cv)
               postpr = 1;
a1954 2
	 case ftest_amg:		/* XXXX Eventually should do to_gv. */
	 case regexp_amg:
d1998 1
a1998 2
             off = ncmp_amg;
             break;
d2005 1
a2005 2
             off = scmp_amg;
             break;
d2007 4
a2010 4
      if ((off != -1) && (cv = cvp[off]))
          postpr = 1;
      else
          goto not_found;
d2014 13
d2203 19
a2235 1

d2237 1
a2237 1
Perl_is_gv_magical_sv(pTHX_ SV *const name_sv, U32 flags)
d2239 2
a2240 2
    STRLEN len;
    const char *const name = SvPV_const(name_sv, len);
d2242 1
a2242 2
    PERL_UNUSED_ARG(flags);
    PERL_ARGS_ASSERT_IS_GV_MAGICAL_SV;
d2320 1
a2377 60
}

/*
=for apidoc gv_try_downgrade

If the typeglob C<gv> can be expressed more succinctly, by having
something other than a real GV in its place in the stash, replace it
with the optimised form.  Basic requirements for this are that C<gv>
is a real typeglob, is sufficiently ordinary, and is only referenced
from its package.  This function is meant to be used when a GV has been
looked up in part to see what was there, causing upgrading, but based
on what was found it turns out that the real GV isn't required after all.

If C<gv> is a completely empty typeglob, it is deleted from the stash.

If C<gv> is a typeglob containing only a sufficiently-ordinary constant
sub, the typeglob is replaced with a scalar-reference placeholder that
more compactly represents the same thing.

=cut
*/

void
Perl_gv_try_downgrade(pTHX_ GV *gv)
{
    HV *stash;
    CV *cv;
    HEK *namehek;
    SV **gvp;
    PERL_ARGS_ASSERT_GV_TRY_DOWNGRADE;
    if (!(SvREFCNT(gv) == 1 && SvTYPE(gv) == SVt_PVGV && !SvFAKE(gv) &&
	    !SvOBJECT(gv) && !SvMAGICAL(gv) && !SvREADONLY(gv) &&
	    isGV_with_GP(gv) && GvGP(gv) &&
	    !GvINTRO(gv) && GvREFCNT(gv) == 1 &&
	    !GvSV(gv) && !GvAV(gv) && !GvHV(gv) && !GvIOp(gv) && !GvFORM(gv) &&
	    GvEGV(gv) == gv && (stash = GvSTASH(gv))))
	return;
    cv = GvCV(gv);
    if (!cv) {
	HEK *gvnhek = GvNAME_HEK(gv);
	(void)hv_delete(stash, HEK_KEY(gvnhek),
	    HEK_UTF8(gvnhek) ? -HEK_LEN(gvnhek) : HEK_LEN(gvnhek), G_DISCARD);
    } else if (GvMULTI(gv) && cv &&
	    !SvOBJECT(cv) && !SvMAGICAL(cv) && !SvREADONLY(cv) &&
	    CvSTASH(cv) == stash && CvGV(cv) == gv &&
	    CvCONST(cv) && !CvMETHOD(cv) && !CvLVALUE(cv) && !CvUNIQUE(cv) &&
	    !CvNODEBUG(cv) && !CvCLONE(cv) && !CvCLONED(cv) && !CvANON(cv) &&
	    (namehek = GvNAME_HEK(gv)) &&
	    (gvp = hv_fetch(stash, HEK_KEY(namehek),
			HEK_LEN(namehek)*(HEK_UTF8(namehek) ? -1 : 1), 0)) &&
	    *gvp == (SV*)gv) {
	SV *value = SvREFCNT_inc(CvXSUBANY(cv).any_ptr);
	SvREFCNT(gv) = 0;
	sv_clear((SV*)gv);
	SvREFCNT(gv) = 1;
	SvFLAGS(gv) = SVt_IV|SVf_ROK;
	SvANY(gv) = (XPVGV*)((char*)&(gv->sv_u.svu_iv) -
				STRUCT_OFFSET(XPVIV, xiv_iv));
	SvRV_set(gv, value);
    }
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d19 1
a19 1
 *     [p.599 of _The Lord of the Rings_, III/xi: "The PalantÃ­r"]
a38 2
#include "keywords.h"
#include "feature.h"
d48 1
a48 7
    if (
        !gv
     || (
            SvTYPE((const SV *)gv) != SVt_PVGV
         && SvTYPE((const SV *)gv) != SVt_PVLV
        )
    ) {
d55 5
a59 1
	    what = OP_IS_DIRHOP(PL_op->op_type) ?
d61 1
a66 1
	/* diag_listed_as: Bad symbol for filehandle */
d124 2
a126 2
    if ((PERLDB_LINE || PERLDB_SAVESRC) && !GvAV(gv))
	    hv_magic(GvHVn(gv_AVadd(gv)), NULL, PERL_MAGIC_dbfile);
a195 95
/* Assign CvGV(cv) = gv, handling weak references.
 * See also S_anonymise_cv_maybe */

void
Perl_cvgv_set(pTHX_ CV* cv, GV* gv)
{
    GV * const oldgv = CvGV(cv);
    PERL_ARGS_ASSERT_CVGV_SET;

    if (oldgv == gv)
	return;

    if (oldgv) {
	if (CvCVGV_RC(cv)) {
	    SvREFCNT_dec(oldgv);
	    CvCVGV_RC_off(cv);
	}
	else {
	    sv_del_backref(MUTABLE_SV(oldgv), MUTABLE_SV(cv));
	}
    }

    SvANY(cv)->xcv_gv = gv;
    assert(!CvCVGV_RC(cv));

    if (!gv)
	return;

    if (isGV_with_GP(gv) && GvGP(gv) && (GvCV(gv) == cv || GvFORM(gv) == cv))
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(gv), MUTABLE_SV(cv));
    else {
	CvCVGV_RC_on(cv);
	SvREFCNT_inc_simple_void_NN(gv);
    }
}

/* Assign CvSTASH(cv) = st, handling weak references. */

void
Perl_cvstash_set(pTHX_ CV *cv, HV *st)
{
    HV *oldst = CvSTASH(cv);
    PERL_ARGS_ASSERT_CVSTASH_SET;
    if (oldst == st)
	return;
    if (oldst)
	sv_del_backref(MUTABLE_SV(oldst), MUTABLE_SV(cv));
    SvANY(cv)->xcv_stash = st;
    if (st)
	Perl_sv_add_backref(aTHX_ MUTABLE_SV(st), MUTABLE_SV(cv));
}

/*
=for apidoc gv_init_pvn

Converts a scalar into a typeglob.  This is an incoercible typeglob;
assigning a reference to it will assign to one of its slots, instead of
overwriting it as happens with typeglobs created by SvSetSV.  Converting
any scalar that is SvOK() may produce unpredictable results and is reserved
for perl's internal use.

C<gv> is the scalar to be converted.

C<stash> is the parent stash/package, if any.

C<name> and C<len> give the name.  The name must be unqualified;
that is, it must not include the package name.  If C<gv> is a
stash element, it is the caller's responsibility to ensure that the name
passed to this function matches the name of the element.  If it does not
match, perl's internal bookkeeping will get out of sync.

C<flags> can be set to SVf_UTF8 if C<name> is a UTF8 string, or
the return value of SvUTF8(sv).  It can also take the
GV_ADDMULTI flag, which means to pretend that the GV has been
seen before (i.e., suppress "Used once" warnings).

=for apidoc gv_init

The old form of gv_init_pvn().  It does not work with UTF8 strings, as it
has no flags parameter.  If the C<multi> parameter is set, the
GV_ADDMULTI flag will be passed to gv_init_pvn().

=for apidoc gv_init_pv

Same as gv_init_pvn(), but takes a nul-terminated string for the name
instead of separate char * and length parameters.

=for apidoc gv_init_sv

Same as gv_init_pvn(), but takes an SV * for the name instead of separate
char * and length parameters.  C<flags> is currently unused.

=cut
*/

d197 1
a197 20
Perl_gv_init_sv(pTHX_ GV *gv, HV *stash, SV* namesv, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_INIT_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   gv_init_pvn(gv, stash, namepv, namelen, flags);
}

void
Perl_gv_init_pv(pTHX_ GV *gv, HV *stash, const char *name, U32 flags)
{
   PERL_ARGS_ASSERT_GV_INIT_PV;
   gv_init_pvn(gv, stash, name, strlen(name), flags);
}

void
Perl_gv_init_pvn(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len, U32 flags)
d202 1
a202 3
    char * const proto = (doproto && SvPOK(gv))
	? ((void)(SvIsCOW(gv) && (sv_force_normal((SV *)gv), 0)), SvPVX(gv))
	: NULL;
a203 1
    const U32 proto_utf8  = proto ? SvUTF8(gv) : 0;
d207 1
a207 1
    PERL_ARGS_ASSERT_GV_INIT_PVN;
d243 1
a243 1
    GvGP_set(gv, Perl_newGP(aTHX_ gv));
d247 3
a249 3
    gv_name_set(gv, name, len, GV_ADD | ( flags & SVf_UTF8 ? SVf_UTF8 : 0 ));
    if (flags & GV_ADDMULTI || doproto)	/* doproto means it */
	GvMULTI_on(gv);			/* _was_ mentioned */
a250 1
	CV *cv;
d254 1
a254 5
	    cv = newCONSTSUB_flags(stash, name, len, flags, has_constant);
	    /* In case op.c:S_process_special_blocks stole it: */
	    if (!GvCV(gv))
		GvCV_set(gv, (CV *)SvREFCNT_inc_simple_NN(cv));
	    assert(GvCV(gv) == cv); /* newCONSTSUB should have set this */
d262 1
a262 2
	    cv = PL_compcv;
	    GvCV_set(gv,cv);
d267 3
a269 3
	CvGV_set(cv, gv);
	CvFILE_set_from_cop(cv, PL_curcop);
	CvSTASH_set(cv, PL_curstash);
d271 1
a271 1
	    sv_usepvn_flags(MUTABLE_SV(cv), proto, protolen,
a272 1
            if ( proto_utf8 ) SvUTF8_on(MUTABLE_SV(cv));
d278 1
a278 1
S_gv_init_svtype(pTHX_ GV *gv, const svtype sv_type)
d280 1
a280 1
    PERL_ARGS_ASSERT_GV_INIT_SVTYPE;
a307 111
static void core_xsub(pTHX_ CV* cv);

static GV *
S_maybe_add_coresub(pTHX_ HV * const stash, GV *gv,
                          const char * const name, const STRLEN len)
{
    const int code = keyword(name, len, 1);
    static const char file[] = __FILE__;
    CV *cv, *oldcompcv = NULL;
    int opnum = 0;
    SV *opnumsv;
    bool ampable = TRUE; /* &{}-able */
    COP *oldcurcop = NULL;
    yy_parser *oldparser = NULL;
    I32 oldsavestack_ix = 0;

    assert(gv || stash);
    assert(name);

    if (code >= 0) return NULL; /* not overridable */
    switch (-code) {
     /* no support for \&CORE::infix;
        no support for funcs that take labels, as their parsing is
        weird  */
    case KEY_and: case KEY_cmp: case KEY_CORE: case KEY_dump:
    case KEY_eq: case KEY_ge:
    case KEY_gt: case KEY_le: case KEY_lt: case KEY_ne:
    case KEY_or: case KEY_x: case KEY_xor:
	return NULL;
    case KEY_chdir:
    case KEY_chomp: case KEY_chop:
    case KEY_each: case KEY_eof: case KEY_exec:
    case KEY_keys:
    case KEY_lstat:
    case KEY_pop:
    case KEY_push:
    case KEY_shift:
    case KEY_splice:
    case KEY_stat:
    case KEY_system:
    case KEY_truncate: case KEY_unlink:
    case KEY_unshift:
    case KEY_values:
	ampable = FALSE;
    }
    if (!gv) {
	gv = (GV *)newSV(0);
	gv_init(gv, stash, name, len, TRUE);
    }
    GvMULTI_on(gv);
    if (ampable) {
	ENTER;
	oldcurcop = PL_curcop;
	oldparser = PL_parser;
	lex_start(NULL, NULL, 0);
	oldcompcv = PL_compcv;
	PL_compcv = NULL; /* Prevent start_subparse from setting
	                     CvOUTSIDE. */
	oldsavestack_ix = start_subparse(FALSE,0);
	cv = PL_compcv;
    }
    else {
	/* Avoid calling newXS, as it calls us, and things start to
	   get hairy. */
	cv = MUTABLE_CV(newSV_type(SVt_PVCV));
	GvCV_set(gv,cv);
	GvCVGEN(gv) = 0;
	mro_method_changed_in(GvSTASH(gv));
	CvISXSUB_on(cv);
	CvXSUB(cv) = core_xsub;
    }
    CvGV_set(cv, gv); /* This stops new ATTRSUB from setting CvFILE
                         from PL_curcop. */
    (void)gv_fetchfile(file);
    CvFILE(cv) = (char *)file;
    /* XXX This is inefficient, as doing things this order causes
           a prototype check in newATTRSUB.  But we have to do
           it this order as we need an op number before calling
           new ATTRSUB. */
    (void)core_prototype((SV *)cv, name, code, &opnum);
    if (stash)
	(void)hv_store(stash,name,len,(SV *)gv,0);
    if (ampable) {
	CvLVALUE_on(cv);
	newATTRSUB_flags(
		   oldsavestack_ix, (OP *)gv,
	           NULL,NULL,
	           coresub_op(
	             opnum
	               ? newSVuv((UV)opnum)
	               : newSVpvn(name,len),
	             code, opnum
	           ),
	           1
	);
	assert(GvCV(gv) == cv);
	if (opnum != OP_VEC && opnum != OP_SUBSTR)
	    CvLVALUE_off(cv); /* Now *that* was a neat trick. */
	LEAVE;
	PL_parser = oldparser;
	PL_curcop = oldcurcop;
	PL_compcv = oldcompcv;
    }
    opnumsv = opnum ? newSVuv((UV)opnum) : (SV *)NULL;
    cv_set_call_checker(
       cv, Perl_ck_entersub_args_core, opnumsv ? opnumsv : (SV *)cv
    );
    SvREFCNT_dec(opnumsv);
    return gv;
}

a310 41
Like L</gv_fetchmeth_pvn>, but lacks a flags parameter.

=for apidoc gv_fetchmeth_sv

Exactly like L</gv_fetchmeth_pvn>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_sv(pTHX_ HV *stash, SV *namesv, I32 level, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_FETCHMETH_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_fetchmeth_pvn(stash, namepv, namelen, level, flags);
}

/*
=for apidoc gv_fetchmeth_pv

Exactly like L</gv_fetchmeth_pvn>, but takes a nul-terminated string 
instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_pv(pTHX_ HV *stash, const char *name, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PV;
    return gv_fetchmeth_pvn(stash, name, strlen(name), level, flags);
}

/*
=for apidoc gv_fetchmeth_pvn

a319 2
Currently, the only significant value for C<flags> is SVf_UTF8.

d332 1
a332 1
Perl_gv_fetchmeth_pvn(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
d342 1
a348 1
    U32 is_utf8 = flags & SVf_UTF8;
d350 1
a350 1
    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN;
d373 1
a373 1
    gvp = (GV**)hv_fetch(stash, name, is_utf8 ? -(I32)len : (I32)len, create);
a375 1
      have_gv:
d378 1
a378 1
            gv_init_pvn(topgv, stash, name, len, GV_ADDMULTI|is_utf8);
d387 1
a387 2
	        GvCV_set(topgv, NULL);
		cand_cv = NULL;
a394 4
	else if (len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4
              && strnEQ(hvname, "CORE", 4)
              && S_maybe_add_coresub(aTHX_ NULL,topgv,name,len))
	    goto have_gv;
d401 1
a401 2
        basestash = gv_stashpvn(hvname, packlen,
                                GV_ADD | (HvNAMEUTF8(stash) ? SVf_UTF8 : 0));
d416 2
a417 4
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
                           "Can't locate package %"SVf" for @@%"HEKf"::ISA",
			   SVfARG(linear_sv),
                           HEKfARG(HvNAME_HEK(stash)));
d423 3
a425 14
        gvp = (GV**)hv_fetch(cstash, name, is_utf8 ? -(I32)len : (I32)len, 0);
        if (!gvp) {
            if (len > 1 && HvNAMELEN_get(cstash) == 4) {
                const char *hvname = HvNAME(cstash); assert(hvname);
                if (strnEQ(hvname, "CORE", 4)
                 && (candidate =
                      S_maybe_add_coresub(aTHX_ cstash,NULL,name,len)
                    ))
                    goto have_candidate;
            }
            continue;
        }
        else candidate = *gvp;
       have_candidate:
d427 1
a427 2
        if (SvTYPE(candidate) != SVt_PVGV)
            gv_init_pvn(candidate, cstash, name, len, GV_ADDMULTI|is_utf8);
d435 1
a435 2
                  CV *old_cv = GvCV(topgv);
                  SvREFCNT_dec(old_cv);
d437 1
a437 1
                  GvCV_set(topgv, cand_cv);
d446 1
a446 1
        candidate = gv_fetchmeth_pvn(NULL, name, len, 1, flags);
d450 1
a450 2
                  CV *old_cv = GvCV(topgv);
                  SvREFCNT_dec(old_cv);
d452 1
a452 1
                  GvCV_set(topgv, cand_cv);
d470 1
a470 43
This is the old form of L</gv_fetchmeth_pvn_autoload>, which has no flags
parameter.

=for apidoc gv_fetchmeth_sv_autoload

Exactly like L</gv_fetchmeth_pvn_autoload>, but takes the name string in the form
of an SV instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_sv_autoload(pTHX_ HV *stash, SV *namesv, I32 level, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_FETCHMETH_SV_AUTOLOAD;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_fetchmeth_pvn_autoload(stash, namepv, namelen, level, flags);
}

/*
=for apidoc gv_fetchmeth_pv_autoload

Exactly like L</gv_fetchmeth_pvn_autoload>, but takes a nul-terminated string
instead of a string/length pair.

=cut
*/

GV *
Perl_gv_fetchmeth_pv_autoload(pTHX_ HV *stash, const char *name, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PV_AUTOLOAD;
    return gv_fetchmeth_pvn_autoload(stash, name, strlen(name), level, flags);
}

/*
=for apidoc gv_fetchmeth_pvn_autoload

Same as gv_fetchmeth_pvn(), but looks for autoloaded subroutines too.
a476 2
Currently, the only significant value for C<flags> is SVf_UTF8.

d481 1
a481 1
Perl_gv_fetchmeth_pvn_autoload(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
d483 1
a483 1
    GV *gv = gv_fetchmeth_pvn(stash, name, len, level, flags);
d485 1
a485 1
    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN_AUTOLOAD;
d495 1
a495 1
	if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE, flags)))
d502 2
a503 3
	    gv_fetchmeth_pvn(stash, name, len, 0, flags);
	gvp = (GV**)hv_fetch(stash, name,
                        (flags & SVf_UTF8) ? -(I32)len : (I32)len, (level >= 0));
d540 1
a540 1
S_gv_get_super_pkg(pTHX_ const char* name, I32 namelen, U32 flags)
d549 1
a549 1
    stash = gv_stashpvn(name, namelen, flags);
d555 1
a555 1
    stash = gv_stashpvn(name, namelen, GV_ADD | flags);
d563 1
a563 6
    av_push(superisa, newSVpvn_flags(CopSTASHPV(PL_curcop),
                                     CopSTASH_len(PL_curcop) < 0
					? -CopSTASH_len(PL_curcop)
					:  CopSTASH_len(PL_curcop),
                                     SVf_UTF8*(CopSTASH_len(PL_curcop) < 0)
                                    ));
a579 19
GV *
Perl_gv_fetchmethod_sv_flags(pTHX_ HV *stash, SV *namesv, U32 flags)
{
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_SV_FLAGS;
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv))
       flags |= SVf_UTF8;
    return gv_fetchmethod_pvn_flags(stash, namepv, namelen, flags);
}

GV *
Perl_gv_fetchmethod_pv_flags(pTHX_ HV *stash, const char *name, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_PV_FLAGS;
    return gv_fetchmethod_pvn_flags(stash, name, strlen(name), flags);
}

d583 1
a583 1
Perl_gv_fetchmethod_pvn_flags(pTHX_ HV *stash, const char *name, const STRLEN len, U32 flags)
a593 1
    const U32 is_utf8  = flags & SVf_UTF8;
d595 1
a595 1
    PERL_ARGS_ASSERT_GV_FETCHMETHOD_PVN_FLAGS;
d605 1
a605 1
    for (nend = name; *nend || nend != (origname + len); nend++) {
d618 2
a619 4
	    SV * const tmpstr = sv_2mortal(Perl_newSVpvf(aTHX_
		     "%"HEKf"::SUPER",
		      HEKfARG(HvNAME_HEK((HV*)CopSTASH(PL_curcop)))
	    ));
d621 1
a621 1
	    stash = gv_get_super_pkg(SvPVX_const(tmpstr), SvCUR(tmpstr), SvUTF8(tmpstr));
d627 1
a627 1
            stash = gv_stashpvn(origname, nsplit - origname, is_utf8);
d633 2
a634 2
		gv_stashpvn(origname, nsplit - origname - 7, is_utf8))
	      stash = gv_get_super_pkg(origname, nsplit - origname, flags);
d639 1
a639 1
    gv = gv_fetchmeth_pvn(stash, name, nend - name, 0, flags);
d644 1
a644 3
	    gv = gv_autoload_pvn(
		ostash, name, nend - name, GV_AUTOLOAD_ISMETHOD|flags
	    );
a648 14
		/* If we can't find an IO::File method, it might be a call on
		 * a filehandle. If IO:File has not been loaded, try to
		 * require it first instead of croaking */
		const char *stash_name = HvNAME_get(stash);
		if (stash_name && memEQs(stash_name, HvNAMELEN_get(stash), "IO::File")
		    && !Perl_hv_common(aTHX_ GvHVn(PL_incgv), NULL,
				       STR_WITH_LEN("IO/File.pm"), 0,
				       HV_FETCH_ISEXISTS, NULL, 0)
		) {
		    require_pv("IO/File.pm");
		    gv = gv_fetchmeth_pvn(stash, name, nend - name, 0, flags);
		    if (gv)
			return gv;
		}
d650 2
a651 5
			   "Can't locate object method \"%"SVf
			   "\" via package \"%"HEKf"\"",
			            SVfARG(newSVpvn_flags(name, nend - name,
                                           SVs_TEMP | is_utf8)),
                                    HEKfARG(HvNAME_HEK(stash)));
d654 2
a655 1
                SV* packnamesv;
d658 2
a659 2
		    packnamesv = newSVpvn_flags(origname, nsplit - origname,
                                                    SVs_TEMP | is_utf8);
d661 1
a661 1
		    packnamesv = sv_2mortal(newSVsv(error_report));
d665 3
a667 5
			   "Can't locate object method \"%"SVf"\" via package \"%"SVf"\""
			   " (perhaps you forgot to load \"%"SVf"\"?)",
			   SVfARG(newSVpvn_flags(name, nend - name,
                                SVs_TEMP | is_utf8)),
                           SVfARG(packnamesv), SVfARG(packnamesv));
d684 2
a685 4
            autogv = gv_autoload_pvn(GvSTASH(stubgv),
                                  GvNAME(stubgv), GvNAMELEN(stubgv),
                                  GV_AUTOLOAD_ISMETHOD
                                   | (GvNAMEUTF8(stubgv) ? SVf_UTF8 : 0));
d695 1
a695 20
Perl_gv_autoload_sv(pTHX_ HV *stash, SV* namesv, U32 flags)
{
   char *namepv;
   STRLEN namelen;
   PERL_ARGS_ASSERT_GV_AUTOLOAD_SV;
   namepv = SvPV(namesv, namelen);
   if (SvUTF8(namesv))
       flags |= SVf_UTF8;
   return gv_autoload_pvn(stash, namepv, namelen, flags);
}

GV*
Perl_gv_autoload_pv(pTHX_ HV *stash, const char *namepv, U32 flags)
{
   PERL_ARGS_ASSERT_GV_AUTOLOAD_PV;
   return gv_autoload_pvn(stash, namepv, strlen(namepv), flags);
}

GV*
Perl_gv_autoload_pvn(pTHX_ HV *stash, const char *name, STRLEN len, U32 flags)
d703 2
a704 2
    SV *packname = NULL;
    U32 is_utf8 = flags & SVf_UTF8 ? SVf_UTF8 : 0;
d706 1
a706 1
    PERL_ARGS_ASSERT_GV_AUTOLOAD_PVN;
d712 1
a712 4
            STRLEN packname_len = 0;
            const char * const packname_ptr = SvPV_const(MUTABLE_SV(stash), packname_len);
            packname = newSVpvn_flags(packname_ptr, packname_len,
                                      SVs_TEMP | SvUTF8(stash));
d715 4
a718 2
	else
	    packname = sv_2mortal(newSVhek(HvNAME_HEK(stash)));
d720 1
a720 1
    if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE, is_utf8)))
d730 1
a730 3
    if (
        !(flags & GV_AUTOLOAD_ISMETHOD)
     && (GvCVGEN(gv) || GvSTASH(gv) != stash)
d733 2
a734 3
			 "Use of inherited AUTOLOAD for non-method %"SVf"::%"SVf"() is deprecated",
			 SVfARG(packname),
                         SVfARG(newSVpvn_flags(name, len, SVs_TEMP | is_utf8)));
d737 4
a740 21
        /* Instead of forcing the XSUB do another lookup for $AUTOLOAD
         * and split that value on the last '::', pass along the same data
         * via the SvPVX field in the CV, and the stash in CvSTASH.
         *
         * Due to an unfortunate accident of history, the SvPVX field
         * serves two purposes.  It is also used for the subroutine's pro-
         * type.  Since SvPVX has been documented as returning the sub name
         * for a long time, but not as returning the prototype, we have
         * to preserve the SvPVX AUTOLOAD behaviour and put the prototype
         * elsewhere.
         *
         * We put the prototype in the same allocated buffer, but after
         * the sub name.  The SvPOK flag indicates the presence of a proto-
         * type.  The CvAUTOLOAD flag indicates the presence of a sub name.
         * If both flags are on, then SvLEN is used to indicate the end of
         * the prototype (artificially lower than what is actually allo-
         * cated), at the risk of having to reallocate a few bytes unneces-
         * sarily--but that should happen very rarely, if ever.
         *
         * We use SvUTF8 for both prototypes and sub names, so if one is
         * UTF8, the other must be upgraded.
d742 4
a745 28
	CvSTASH_set(cv, stash);
	if (SvPOK(cv)) { /* Ouch! */
	    SV *tmpsv = newSVpvn_flags(name, len, is_utf8);
	    STRLEN ulen;
	    const char *proto = CvPROTO(cv);
	    assert(proto);
	    if (SvUTF8(cv))
		sv_utf8_upgrade_flags_grow(tmpsv, 0, CvPROTOLEN(cv) + 2);
	    ulen = SvCUR(tmpsv);
	    SvCUR(tmpsv)++; /* include null in string */
	    sv_catpvn_flags(
		tmpsv, proto, CvPROTOLEN(cv), SV_CATBYTES*!SvUTF8(cv)
	    );
	    SvTEMP_on(tmpsv); /* Allow theft */
	    sv_setsv_nomg((SV *)cv, tmpsv);
	    SvTEMP_off(tmpsv);
	    SvREFCNT_dec(tmpsv);
	    SvLEN(cv) = SvCUR(cv) + 1;
	    SvCUR(cv) = ulen;
	}
	else {
	  sv_setpvn((SV *)cv, name, len);
	  SvPOK_off(cv);
	  if (is_utf8)
            SvUTF8_on(cv);
	  else SvUTF8_off(cv);
	}
	CvAUTOLOAD_on(cv);
d759 1
a759 1
	gv_init_pvn(vargv, varstash, S_autoload, S_autolen, 0);
d766 1
a766 1
    sv_setsv(varsv, packname);
d768 1
a768 8
    /* Ensure SvSETMAGIC() is called if necessary. In particular, to clear
       tainting if $FOO::AUTOLOAD was previously tainted, but is not now.  */
    sv_catpvn_flags(
	varsv, name, len,
	SV_SMAGIC|(is_utf8 ? SV_CATUTF8 : SV_CATBYTES)
    );
    if (is_utf8)
        SvUTF8_on(varsv);
d774 1
a774 1
 * that implements the logic of automatic ties like %! and %-
d793 1
a793 1
    if (!stash || !(gv_fetchmethod_autoload(stash, methpv, FALSE))) {
a797 1
	const char type = varname == '[' ? '$' : '%';
d809 2
a810 2
	    Perl_croak(aTHX_ "panic: Can't use %c%c because %"SVf" is not available",
		    type, varname, SVfARG(namesv));
d812 2
a813 2
	    Perl_croak(aTHX_ "panic: Can't use %c%c because %"SVf" does not support method %s",
		    type, varname, SVfARG(namesv), methpv);
d872 2
d875 2
a876 11
    if (!(flags & ~GV_NOADD_MASK) && !stash) return NULL;
    assert(stash);
    if (!HvNAME_get(stash)) {
	hv_name_set(stash, name, namelen, flags & SVf_UTF8 ? SVf_UTF8 : 0 );
	
	/* FIXME: This is a repeat of logic in gv_fetchpvn_flags */
	/* If the containing stash has multiple effective
	   names, see that this one gets them, too. */
	if (HvAUX(GvSTASH(tmpgv))->xhv_name_count)
	    mro_package_moved(stash, NULL, tmpgv, 1);
    }
d896 1
a896 1
    return gv_stashpvn(ptr, len, flags | SvUTF8(sv));
d909 1
a909 2
    const char * const nambeg =
       SvPV_flags_const(name, len, flags & GV_NO_SVGMAGIC ? 0 : SV_GMAGIC);
a913 25
STATIC void
S_gv_magicalize_isa(pTHX_ GV *gv)
{
    AV* av;

    PERL_ARGS_ASSERT_GV_MAGICALIZE_ISA;

    av = GvAVn(gv);
    GvMULTI_on(gv);
    sv_magic(MUTABLE_SV(av), MUTABLE_SV(gv), PERL_MAGIC_isa,
	     NULL, 0);
}

STATIC void
S_gv_magicalize_overload(pTHX_ GV *gv)
{
    HV* hv;

    PERL_ARGS_ASSERT_GV_MAGICALIZE_OVERLOAD;

    hv = GvHVn(gv);
    GvMULTI_on(gv);
    hv_magic(hv, NULL, PERL_MAGIC_overload);
}

a927 2
    const U32 is_utf8 = flags & SVf_UTF8;
    bool addmg = !!(flags & GV_ADDMG);
d940 1
a940 1
    if (full_len > 2 && *name == '*' && isIDFIRST_lazy_if(name + 1, is_utf8)) {
d946 1
a946 2
	if (name_cursor < name_em1 &&
	    ((*name_cursor == ':'
d948 1
a948 1
	    || *name_cursor == '\''))
d956 7
a962 7
	    if (name_cursor > nambeg) { /* Skip for initial :: or ' */
		const char *key;
		if (*name_cursor == ':') {
		    key = name;
		    len += 2;
		} else {
		    char *tmpbuf;
d964 4
a967 6
		    Copy(name, tmpbuf, len, char);
		    tmpbuf[len++] = ':';
		    tmpbuf[len++] = ':';
		    key = tmpbuf;
		}
		gvp = (GV**)hv_fetch(stash, key, is_utf8 ? -len : len, add);
d971 1
a971 1
			gv_init_pvn(gv, stash, key, len, (add & GV_ADDMULTI)|is_utf8);
d975 2
a976 2
		if (key != name)
		    Safefree(key);
a980 1
		{
d982 3
a984 16
		    if (!HvNAME_get(stash)) {
			if (GvSTASH(gv) == PL_defstash && len == 6
			 && strnEQ(name, "CORE", 4))
			    hv_name_set(stash, "CORE", 4, 0);
			else
			    hv_name_set(
				stash, nambeg, name_cursor-nambeg, is_utf8
			    );
			/* If the containing stash has multiple effective
			   names, see that this one gets them, too. */
			if (HvAUX(GvSTASH(gv))->xhv_name_count)
			    mro_package_moved(stash, NULL, gv, 1);
		    }
		}
		else if (!HvNAME_get(stash))
		    hv_name_set(stash, nambeg, name_cursor - nambeg, is_utf8);
d989 2
a990 1
	    name = name_cursor+1;
d1052 1
a1052 1
		    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -len : len,0);
a1062 1
                        SV* namesv = newSVpvn_flags(name, len, SVs_TEMP | is_utf8);
d1064 1
a1064 3
			Perl_ck_warner_d(
			    aTHX_ packWARN(WARN_MISC),
			    "Variable \"%c%"SVf"\" is not imported",
d1067 1
a1067 1
			    SVfARG(namesv));
d1069 1
a1069 4
			    Perl_ck_warner_d(
				aTHX_ packWARN(WARN_MISC),
				"\t(Did you mean &%"SVf" instead?)\n", SVfARG(namesv)
			    );
d1086 1
a1086 1
		 "Global symbol \"%s%"SVf"\" requires explicit package name",
d1090 1
a1090 1
		  : ""), SVfARG(newSVpvn_flags(name, len, SVs_TEMP | is_utf8)));
d1109 4
a1112 9
    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -len : len,add);
    if (!gvp || *gvp == (const GV *)&PL_sv_undef) {
	if (addmg) gv = (GV *)newSV(0);
	else return NULL;
    }
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

d1116 2
a1117 3
	    gv_init_svtype(gv, sv_type);
	    if (len == 1 && stash == PL_defstash) {
	      if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
a1121 9
	      }
	      if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
	       if (*name == '[')
		require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
	       else if (*name == '&' || *name == '`' || *name == '\'') {
		PL_sawampersand = TRUE;
		(void)GvSVn(gv);
	       }
	      }
a1122 4
	    else if (len == 3 && sv_type == SVt_PVAV
	          && strnEQ(name, "ISA", 3)
	          && (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
		gv_magicalize_isa(gv);
a1125 1
	assert(!addmg);
a1127 1
	assert(!addmg);
d1141 3
a1143 3
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL), "Had to create %"SVf" unexpectedly",
                SVfARG(newSVpvn_flags(nambeg, name_end-nambeg, SVs_TEMP | is_utf8 )));
    gv_init_pvn(gv, stash, name, len, (add & GV_ADDMULTI)|is_utf8);
d1145 2
a1146 2
    if ( isIDFIRST_lazy_if(name, is_utf8)
                && ! (isLEXWARN_on ? ckWARN(WARN_ONCE) : (PL_dowarn & G_WARN_ON ) ) )
d1150 1
a1150 37
    if (stash != PL_defstash) { /* not the main stash */
	/* We only have to check for four names here: EXPORT, ISA, OVERLOAD
	   and VERSION. All the others apply only to the main stash or to
	   CORE (which is checked right after this). */
	if (len > 2) {
	    const char * const name2 = name + 1;
	    switch (*name) {
	    case 'E':
		if (strnEQ(name2, "XPORT", 5))
		    GvMULTI_on(gv);
		break;
	    case 'I':
		if (strEQ(name2, "SA"))
		    gv_magicalize_isa(gv);
		break;
	    case 'O':
		if (strEQ(name2, "VERLOAD"))
		    gv_magicalize_overload(gv);
		break;
	    case 'V':
		if (strEQ(name2, "ERSION"))
		    GvMULTI_on(gv);
		break;
	    default:
		goto try_core;
	    }
	    goto add_magical_gv;
	}
      try_core:
	if (len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4) {
	  /* Avoid null warning: */
	  const char * const stashname = HvNAME(stash); assert(stashname);
	  if (strnEQ(stashname, "CORE", 4))
	    S_maybe_add_coresub(aTHX_ 0, gv, name, len);
	}
    }
    else if (len > 1) {
d1177 19
a1195 1
		    gv_magicalize_isa(gv);
d1200 3
a1202 1
		    gv_magicalize_overload(gv);
a1247 4
	    case '\007':	/* $^GLOBAL_PHASE */
		if (strEQ(name2, "LOBAL_PHASE"))
		    goto ro_magicalize;
		break;
d1257 1
a1257 2
		    goto magicalize;
		break;
d1289 1
a1289 1
		    if (!isDIGIT(*end))	goto add_magical_gv;
d1302 1
a1302 1
	    if (!(
d1308 2
a1309 1
		)) { PL_sawampersand = TRUE; }
a1329 3
	    {
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
		addmg = 0;
a1330 1
	    }
a1346 3
	    {
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
		addmg = 0;
a1347 1
	    }
a1353 1
		/* diag_listed_as: $* is no longer supported */
a1366 9
	case '[':		/* $[ */
	    if ((sv_type == SVt_PV || sv_type == SVt_PVGV)
	     && FEATURE_ARYBASE_IS_ENABLED) {
		if (addmg) (void)hv_store(stash,name,len,(SV *)gv,0);
		require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
		addmg = 0;
	    }
	    else goto magicalize;
            break;
d1381 1
a1392 1
	case '$':		/* $$ */
d1417 1
a1417 1
	    SV * const sv = GvSV(gv);
d1427 1
a1427 1
	    SV * const sv = GvSV(gv);
a1434 9
  add_magical_gv:
    if (addmg) {
	if (GvAV(gv) || GvHV(gv) || GvIO(gv) || GvCV(gv) || (
	     GvSV(gv) && (SvOK(GvSV(gv)) || SvMAGICAL(GvSV(gv)))
	   ))
	    (void)hv_store(stash,name,len,(SV *)gv,0);
	else SvREFCNT_dec(gv), gv = NULL;
    }
    if (gv) gv_init_svtype(gv, faking_it ? SVt_PVCV : sv_type);
d1442 1
d1447 4
d1453 10
a1462 4
    if (hv && (name = HvNAME(hv))) {
      const STRLEN len = HvNAMELEN(hv);
      if (keepmain || strnNE(name, "main", len)) {
	sv_catpvn_flags(sv,name,len,HvNAMEUTF8(hv)?SV_CATUTF8:SV_CATBYTES);
a1463 1
      }
d1465 1
a1465 2
    else sv_catpvs(sv,"__ANON__::");
    sv_catsv(sv,sv_2mortal(newSVhek(GvNAME_HEK(gv))));
d1471 1
a1471 1
    const GV * const egv = GvEGVx(gv);
d1499 1
a1499 2
            else if ( *HeKEY(entry) != '_'
                        && isIDFIRST_lazy_if(HeKEY(entry), HeUTF8(entry)) ) {
d1513 2
a1514 4
			"Name \"%"HEKf"::%"HEKf
			"\" used only once: possible typo",
                            HEKfARG(HvNAME_HEK(stash)),
                            HEKfARG(GvNAME_HEK(gv)));
d1521 1
a1521 1
Perl_newGVgen_flags(pTHX_ const char *pack, U32 flags)
a1523 1
    PERL_ARGS_ASSERT_NEWGVGEN_FLAGS;
d1525 4
a1528 5
    return gv_fetchpv(Perl_form(aTHX_ "%"SVf"::_GEN_%ld",
                                    SVfARG(newSVpvn_flags(pack, strlen(pack),
                                            SVs_TEMP | flags)),
                                (long)PL_gensym++),
                      GV_ADD, SVt_PVGV);
a1557 1
    int attempts = 100;
d1570 1
a1570 1
	GvGP_set(gv, NULL);
d1574 16
a1589 53
    while (1) {
      /* Copy and null out all the glob slots, so destructors do not see
         freed SVs. */
      HEK * const file_hek = gp->gp_file_hek;
      SV  * const sv       = gp->gp_sv;
      AV  * const av       = gp->gp_av;
      HV  * const hv       = gp->gp_hv;
      IO  * const io       = gp->gp_io;
      CV  * const cv       = gp->gp_cv;
      CV  * const form     = gp->gp_form;

      gp->gp_file_hek = NULL;
      gp->gp_sv       = NULL;
      gp->gp_av       = NULL;
      gp->gp_hv       = NULL;
      gp->gp_io       = NULL;
      gp->gp_cv       = NULL;
      gp->gp_form     = NULL;

      if (file_hek)
	unshare_hek(file_hek);

      SvREFCNT_dec(sv);
      SvREFCNT_dec(av);
      /* FIXME - another reference loop GV -> symtab -> GV ?
         Somehow gp->gp_hv can end up pointing at freed garbage.  */
      if (hv && SvTYPE(hv) == SVt_PVHV) {
        const HEK *hvname_hek = HvNAME_HEK(hv);
        if (PL_stashcache && hvname_hek)
           (void)hv_delete(PL_stashcache, HEK_KEY(hvname_hek),
                      (HEK_UTF8(hvname_hek) ? -HEK_LEN(hvname_hek) : HEK_LEN(hvname_hek)),
                      G_DISCARD);
	SvREFCNT_dec(hv);
      }
      SvREFCNT_dec(io);
      SvREFCNT_dec(cv);
      SvREFCNT_dec(form);

      if (!gp->gp_file_hek
       && !gp->gp_sv
       && !gp->gp_av
       && !gp->gp_hv
       && !gp->gp_io
       && !gp->gp_cv
       && !gp->gp_form) break;

      if (--attempts == 0) {
	Perl_die(aTHX_
	  "panic: gp_free failed to free glob pointer - "
	  "something is repeatedly re-creating entries"
	);
      }
    }
d1592 1
a1592 1
    GvGP_set(gv, NULL);
d1659 1
a1659 1
    GV *gv = gv_fetchmeth_pvn(stash, PL_AMG_names[0], 2, -1, 0);
d1693 1
a1693 1
	    gv = Perl_gv_fetchmeth_pvn_autoload(aTHX_ stash, cooky, l, 0, 0);
d1695 1
a1695 1
	    gv = Perl_gv_fetchmeth_pvn(aTHX_ stash, cooky, l, -1, 0);
d1698 3
a1700 4
	    if(GvNAMELEN(CvGV(cv)) == 3 && strEQ(GvNAME(CvGV(cv)), "nil")){
	      const char * const hvname = HvNAME_get(GvSTASH(CvGV(cv)));
	      if (hvname && HEK_LEN(HvNAME_HEK(GvSTASH(CvGV(cv)))) == 8
	       && strEQ(hvname, "overload")) {
d1709 1
a1709 1
			     (void*)GvSV(gv), cp, HvNAME(stash)) );
d1711 2
a1712 1
		    || !(ngv = gv_fetchmethod_sv_flags(stash, gvsv, 0)))
d1719 3
a1721 7
			const SV * const name = (gvsv && SvPOK(gvsv))
                                                    ? gvsv
                                                    : newSVpvs_flags("???", SVs_TEMP);
			/* diag_listed_as: Can't resolve method "%s" overloading "%s" in package "%s" */
			Perl_croak(aTHX_ "%s method \"%"SVf256
				    "\" overloading \"%s\" "\
				    "in package \"%"HEKf256"\"",
d1724 1
a1724 4
				   SVfARG(name), cp,
                                   HEKfARG(
					HvNAME_HEK(stash)
				   ));
a1727 1
	      }
d1779 1
a1779 1
	if (Gv_AMupdate(stash, cBOOL(id == DESTROY_amg)) == -1) {
a1815 150
/* Implement tryAMAGICun_MG macro.
   Do get magic, then see if the stack arg is overloaded and if so call it.
   Flags:
	AMGf_set     return the arg using SETs rather than assigning to
		     the targ
	AMGf_numeric apply sv_2num to the stack arg.
*/

bool
Perl_try_amagic_un(pTHX_ int method, int flags) {
    dVAR;
    dSP;
    SV* tmpsv;
    SV* const arg = TOPs;

    SvGETMAGIC(arg);

    if (SvAMAGIC(arg) && (tmpsv = amagic_call(arg, &PL_sv_undef, method,
					      AMGf_noright | AMGf_unary))) {
	if (flags & AMGf_set) {
	    SETs(tmpsv);
	}
	else {
	    dTARGET;
	    if (SvPADMY(TARG)) {
		sv_setsv(TARG, tmpsv);
		SETTARG;
	    }
	    else
		SETs(tmpsv);
	}
	PUTBACK;
	return TRUE;
    }

    if ((flags & AMGf_numeric) && SvROK(arg))
	*sp = sv_2num(arg);
    return FALSE;
}


/* Implement tryAMAGICbin_MG macro.
   Do get magic, then see if the two stack args are overloaded and if so
   call it.
   Flags:
	AMGf_set     return the arg using SETs rather than assigning to
		     the targ
	AMGf_assign  op may be called as mutator (eg +=)
	AMGf_numeric apply sv_2num to the stack arg.
*/

bool
Perl_try_amagic_bin(pTHX_ int method, int flags) {
    dVAR;
    dSP;
    SV* const left = TOPm1s;
    SV* const right = TOPs;

    SvGETMAGIC(left);
    if (left != right)
	SvGETMAGIC(right);

    if (SvAMAGIC(left) || SvAMAGIC(right)) {
	SV * const tmpsv = amagic_call(left, right, method,
		    ((flags & AMGf_assign) && opASSIGN ? AMGf_assign: 0));
	if (tmpsv) {
	    if (flags & AMGf_set) {
		(void)POPs;
		SETs(tmpsv);
	    }
	    else {
		dATARGET;
		(void)POPs;
		if (opASSIGN || SvPADMY(TARG)) {
		    sv_setsv(TARG, tmpsv);
		    SETTARG;
		}
		else
		    SETs(tmpsv);
	    }
	    PUTBACK;
	    return TRUE;
	}
    }
    if(left==right && SvGMAGICAL(left)) {
	SV * const left = sv_newmortal();
	*(sp-1) = left;
	/* Print the uninitialized warning now, so it includes the vari-
	   able name. */
	if (!SvOK(right)) {
	    if (ckWARN(WARN_UNINITIALIZED)) report_uninit(right);
	    sv_setsv_flags(left, &PL_sv_no, 0);
	}
	else sv_setsv_flags(left, right, 0);
	SvGETMAGIC(right);
    }
    if (flags & AMGf_numeric) {
	if (SvROK(TOPm1s))
	    *(sp-1) = sv_2num(TOPm1s);
	if (SvROK(right))
	    *sp     = sv_2num(right);
    }
    return FALSE;
}

SV *
Perl_amagic_deref_call(pTHX_ SV *ref, int method) {
    SV *tmpsv = NULL;

    PERL_ARGS_ASSERT_AMAGIC_DEREF_CALL;

    while (SvAMAGIC(ref) && 
	   (tmpsv = amagic_call(ref, &PL_sv_undef, method,
				AMGf_noright | AMGf_unary))) { 
	if (!SvROK(tmpsv))
	    Perl_croak(aTHX_ "Overloaded dereference did not return a reference");
	if (tmpsv == ref || SvRV(tmpsv) == SvRV(ref)) {
	    /* Bail out if it returns us the same reference.  */
	    return tmpsv;
	}
	ref = tmpsv;
    }
    return tmpsv ? tmpsv : ref;
}

bool
Perl_amagic_is_enabled(pTHX_ int method)
{
      SV *lex_mask = cop_hints_fetch_pvs(PL_curcop, "overloading", 0);

      assert(PL_curcop->cop_hints & HINT_NO_AMAGIC);

      if ( !lex_mask || !SvOK(lex_mask) )
	  /* overloading lexically disabled */
	  return FALSE;
      else if ( lex_mask && SvPOK(lex_mask) ) {
	  /* we have an entry in the hints hash, check if method has been
	   * masked by overloading.pm */
	  STRLEN len;
	  const int offset = method / 8;
	  const int bit    = method % 8;
	  char *pv = SvPV(lex_mask, len);

	  /* Bit set, so this overloading operator is disabled */
	  if ( (STRLEN)offset < len && pv[offset] & ( 1 << bit ) )
	      return FALSE;
      }
      return TRUE;
}

a1827 1
  int use_default_op = 0;
d1836 18
a1853 1
      if (!amagic_is_enabled(method)) return NULL;
d1992 3
a1994 2
    } else if (((cvp && amtp->fallback > AMGfallNEVER)
                || (ocvp && oamtp->fallback > AMGfallNEVER))
d2022 1
a2022 11
      if (off != -1) {
          if (ocvp && (oamtp->fallback > AMGfallNEVER)) {
              cv = ocvp[off];
              lr = -1;
          }
          if (!cv && (cvp && amtp->fallback > AMGfallNEVER)) {
              cv = cvp[off];
              lr = 1;
          }
      }
      if (cv)
d2042 1
a2042 4
      } else if ((use_default_op =
                  (!ocvp || oamtp->fallback >= AMGfallYES)
                  && (!cvp || amtp->fallback >= AMGfallYES))
                 && !DEBUG_o_TEST) {
d2049 19
a2067 19
		      "Operation \"%s\": no method found,%sargument %s%"SVf"%s%"SVf,
 		      AMG_id2name(method + assignshift),
 		      (flags & AMGf_unary ? " " : "\n\tleft "),
 		      SvAMAGIC(left)?
 		        "in overloaded package ":
 		        "has no overloaded magic",
 		      SvAMAGIC(left)?
		        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(left)))))):
		        SVfARG(&PL_sv_no),
 		      SvAMAGIC(right)?
 		        ",\n\tright argument in overloaded package ":
 		        (flags & AMGf_unary
 			 ? ""
 			 : ",\n\tright argument has no overloaded magic"),
 		      SvAMAGIC(right)?
		        SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(SvSTASH(SvRV(right)))))):
		        SVfARG(&PL_sv_no)));
        if (use_default_op) {
	  DEBUG_o( Perl_deb(aTHX_ "%"SVf, SVfARG(msg)) );
d2079 1
a2079 1
		     "Overloaded operator \"%s\"%s%s%s:\n\tmethod%s found%s in package %"SVf"%s\n",
d2089 1
a2089 1
		     stash ? SVfARG(sv_2mortal(newSVhek(HvNAME_HEK(stash)))) : SVfARG(newSVpvs_flags("null", SVs_TEMP)),
d2115 1
a2115 1
  if ( (lr == -1) && ( ( (method + assignshift == off)
d2117 2
a2118 13
      || force_cpy) )
  {
      /* newSVsv does not behave as advertised, so we copy missing
       * information by hand */
      SV *tmpRef = SvRV(left);
      SV *rv_copy;
      if (SvREFCNT(tmpRef) > 1 && (rv_copy = AMG_CALLunary(left,copy_amg))) {
	  SvRV_set(left, rv_copy);
	  SvSETMAGIC(left);
	  SvREFCNT_dec(tmpRef);  
      }
  }

d2138 1
a2138 1
    Perl_pp_pushmark(aTHX);
d2202 142
d2351 1
d2361 1
a2361 1
    GvNAME_HEK(gv) = share_hek(name, (flags & SVf_UTF8 ? -(I32)len : (I32)len), hash);
a2391 5

    /* XXX Why and where does this leave dangling pointers during global
       destruction? */
    if (PL_phase == PERL_PHASE_DESTRUCT) return;

d2393 1
a2393 1
	    !SvOBJECT(gv) && !SvREADONLY(gv) &&
d2397 1
a2397 1
	    GvEGVx(gv) == gv && (stash = GvSTASH(gv))))
a2398 10
    if (SvMAGICAL(gv)) {
        MAGIC *mg;
	/* only backref magic is allowed */
	if (SvGMAGICAL(gv) || SvSMAGICAL(gv))
	    return;
        for (mg = SvMAGIC(gv); mg; mg = mg->mg_moremagic) {
            if (mg->mg_type != PERL_MAGIC_backref)
                return;
	}
    }
a2421 10
}

#include "XSUB.h"

static void
core_xsub(pTHX_ CV* cv)
{
    Perl_croak(aTHX_
       "&CORE::%s cannot be called directly", GvNAME(CvGV(cv))
    );
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a85 3
    if (type == SVt_PVAV && GvNAMELEN(gv) == 3
     && strnEQ(GvNAME(gv), "ISA", 3))
	sv_magic(*where, (SV *)gv, PERL_MAGIC_isa, NULL, 0);
d162 6
a169 4
#ifndef USE_ITHREADS
    SV * temp_sv;
#endif
    dVAR;
a171 5
    Newxz(gp, 1, GP);
    gp->gp_egv = gv; /* allow compiler to reuse gv after this */
#ifndef PERL_DONT_CREATE_GVSV
    gp->gp_sv = newSV(0);
#endif
a172 18
#ifdef USE_ITHREADS
    if (PL_curcop) {
	gp->gp_line = CopLINE(PL_curcop); /* 0 otherwise Newxz */
	if (CopFILE(PL_curcop)) {
	    file = CopFILE(PL_curcop);
	    len = strlen(file);
	}
	else goto no_file;
    }
    else {
	no_file:
	file = "";
	len = 0;
    }
#else
    if(PL_curcop)
	gp->gp_line = CopLINE(PL_curcop); /* 0 otherwise Newxz */
    temp_sv = CopFILESV(PL_curcop);
d183 10
d194 1
a206 1
    HEK *hek;
d214 1
a214 1
	    SvREFCNT_dec_NN(oldgv);
a220 1
    else if ((hek = CvNAME_HEK(cv))) unshare_hek(hek);
d222 1
a222 1
    SvANY(cv)->xcv_gv_u.xcv_gv = gv;
d371 1
a371 1
    if (doproto) {
d373 1
a385 1
	    CvSTASH_set(cv, PL_curstash); /* XXX Why is this needed? */
d387 3
a389 1
	    cv = newSTUB(gv,1);
d391 6
d446 1
d455 2
a456 2
    if (!code) return NULL; /* Not a keyword */
    switch (code < 0 ? -code : code) {
d458 6
a463 19
        no support for funcs that do not parse like funcs */
    case KEY___DATA__: case KEY___END__: case KEY_and: case KEY_AUTOLOAD:
    case KEY_BEGIN   : case KEY_CHECK  : case KEY_cmp: case KEY_CORE    :
    case KEY_default : case KEY_DESTROY:
    case KEY_do      : case KEY_dump   : case KEY_else  : case KEY_elsif  :
    case KEY_END     : case KEY_eq     : case KEY_eval  :
    case KEY_for     : case KEY_foreach: case KEY_format: case KEY_ge     :
    case KEY_given   : case KEY_goto   : case KEY_grep  :
    case KEY_gt   : case KEY_if: case KEY_INIT: case KEY_last: case KEY_le:
    case KEY_local: case KEY_lt: case KEY_m   : case KEY_map : case KEY_my:
    case KEY_ne   : case KEY_next : case KEY_no: case KEY_or: case KEY_our:
    case KEY_package: case KEY_print: case KEY_printf:
    case KEY_q    : case KEY_qq   : case KEY_qr     : case KEY_qw    :
    case KEY_qx   : case KEY_redo : case KEY_require: case KEY_return:
    case KEY_s    : case KEY_say  : case KEY_sort   :
    case KEY_state: case KEY_sub  :
    case KEY_tr   : case KEY_UNITCHECK: case KEY_unless:
    case KEY_until: case KEY_use  : case KEY_when     : case KEY_while :
    case KEY_x    : case KEY_xor  : case KEY_y        :
d466 2
a467 2
    case KEY_chomp: case KEY_chop: case KEY_defined: case KEY_delete:
    case KEY_each : case KEY_eof : case KEY_exec   : case KEY_exists:
d473 1
a473 1
    case KEY_splice: case KEY_split:
a518 3
#ifdef DEBUGGING
        CV *orig_cv = cv;
#endif
d520 1
a520 3
        /* newATTRSUB will free the CV and return NULL if we're still
           compiling after a syntax error */
	if ((cv = newATTRSUB_flags(
d530 4
a533 6
               )) != NULL) {
            assert(GvCV(gv) == orig_cv);
            if (opnum != OP_VEC && opnum != OP_SUBSTR && opnum != OP_POS
                && opnum != OP_UNDEF)
                CvLVALUE_off(cv); /* Now *that* was a neat trick. */
        }
d539 5
a543 8
    if (cv) {
        SV *opnumsv = opnum ? newSVuv((UV)opnum) : (SV *)NULL;
        cv_set_call_checker(
          cv, Perl_ck_entersub_args_core, opnumsv ? opnumsv : (SV *)cv
        );
        SvREFCNT_dec(opnumsv);
    }

d600 1
a600 1
The only significant values for C<flags> are GV_SUPER and SVf_UTF8.
d602 1
a602 4
GV_SUPER indicates that we want to look up the method in the superclasses
of the C<stash>.

The
d621 1
a621 1
    HV* cstash, *cachestash;
d628 1
d650 1
a650 2
    DEBUG_o( Perl_deb(aTHX_ "Looking for %smethod %s in package %s\n",
		      flags & GV_SUPER ? "SUPER " : "",name,hvname) );
a653 6
    if (flags & GV_SUPER) {
	if (!HvAUX(stash)->xhv_super) HvAUX(stash)->xhv_super = newHV();
	cachestash = HvAUX(stash)->xhv_super;
    }
    else cachestash = stash;

d655 1
a655 2
    gvp = (GV**)hv_fetch(cachestash, name, is_utf8 ? -(I32)len : (I32)len,
			 create);
d669 1
a669 1
	        SvREFCNT_dec_NN(cand_cv);
d679 1
a679 2
	else if (stash == cachestash
	      && len > 1 /* shortest is uc */ && HvNAMELEN_get(stash) == 4
d685 12
a696 1
    linear_av = mro_get_linear_isa(stash); /* has ourselves at the top of the list */
d750 1
a750 1
        candidate = gv_fetchmeth_pvn(NULL, name, len, 1, flags &~GV_SUPER);
d889 38
d960 1
a960 1
    const char *nend;
d993 6
a998 2
	    stash = CopSTASH(PL_curcop);
	    flags |= GV_SUPER;
d1000 1
a1000 7
			 origname, HvENAME_get(stash), name) );
	}
	else if ((nsplit - origname) >= 7 &&
		 strnEQ(nsplit - 7, "::SUPER", 7)) {
            /* don't autovifify if ->NoSuchStash::SUPER::method */
	    stash = gv_stashpvn(origname, nsplit - origname - 7, is_utf8);
	    if (stash) flags |= GV_SUPER;
d1005 7
a1137 1
	if (flags & GV_SUPER) sv_catpvs(packname, "::SUPER");
d1139 1
a1139 2
    if (!(gv = gv_fetchmeth_pvn(stash, S_autoload, S_autolen, FALSE,
				is_utf8 | (flags & GV_SUPER))))
d1183 1
a1183 1
	    SV * const tmpsv = newSVpvn_flags(name, len, is_utf8);
d1197 1
a1197 1
	    SvREFCNT_dec_NN(tmpsv);
a1228 2
    SvTAINTED_off(varsv); /* previous $AUTOLOAD taint is obsolete */
    /* XXX: this process is not careful to avoid extra magic gets and sets; tied $AUTOLOAD will get noise */
a1270 1
	SAVEFREESV(namesv);
d1276 2
a1284 1
	LEAVE;
d1286 1
a1286 1
    else SvREFCNT_dec_NN(namesv);
a1315 10
Flags may be one of:

    GV_ADD
    SVf_UTF8
    GV_NOADD_NOINIT
    GV_NOINIT
    GV_NOEXPAND
    GV_ADDMG

The most important of which are probably GV_ADD and SVf_UTF8.
d1406 12
d1423 2
a1424 2
    const char *name = nambeg;
    GV *gv = NULL;
d1427 1
a1427 1
    const char *name_cursor;
d1524 1
a1524 1
	if (len && isIDFIRST_lazy_if(name, is_utf8)) {
d1612 1
a1612 2
	if (add && !PL_in_clean_all) {
	    SV * const namesv = newSVpvn_flags(name, len, is_utf8);
d1618 1
a1618 1
		  : ""), SVfARG(namesv));
d1620 1
a1620 2
	    SvREFCNT_dec_NN(namesv);
	    if (is_utf8)
a1649 4
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn't
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
d1656 1
a1656 8
              } else if (sv_type == SVt_PV) {
                  if (*name == '*' || *name == '#') {
                      /* diag_listed_as: $* is no longer supported */
                      Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,
                                                       WARN_SYNTAX),
                                       "$%c is no longer supported", *name);
                  }
              }
d1658 6
a1663 19
                switch (*name) {
	        case '[':
		    require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
                    break;
#ifdef PERL_SAWAMPERSAND
	        case '`':
		    PL_sawampersand |= SAWAMPERSAND_LEFT;
                    (void)GvSVn(gv);
                    break;
	        case '&':
		    PL_sawampersand |= SAWAMPERSAND_MIDDLE;
                    (void)GvSVn(gv);
                    break;
	        case '\'':
		    PL_sawampersand |= SAWAMPERSAND_RIGHT;
                    (void)GvSVn(gv);
                    break;
#endif
                }
d1700 1
a1700 1
	/* We only have to check for three names here: EXPORT, ISA
d1714 4
d1765 5
a1816 4
	    case '\014':	/* $^LAST_FH */
		if (strEQ(name2, "AST_FH"))
		    goto ro_magicalize;
		break;
a1871 1
#ifdef PERL_SAWAMPERSAND
d1878 1
a1878 8
		)) { PL_sawampersand |=
                        (*name == '`')
                            ? SAWAMPERSAND_LEFT
                            : (*name == '&')
                                ? SAWAMPERSAND_MIDDLE
                                : SAWAMPERSAND_RIGHT;
                }
#endif
d1935 4
a1978 1
	case '|':		/* $| */
d1997 1
d2028 1
a2028 1
	else SvREFCNT_dec_NN(gv), gv = NULL;
d2069 1
a2069 1
    I32 i;
d2078 1
a2078 1
            GV *gv;
d2137 1
a2137 1
	    SvREFCNT_dec_NN(gp->gp_cv);
a2194 1
        DEBUG_o(Perl_deb(aTHX_ "gp_free clearing PL_stashcache for '%"HEKf"'\n", hvname_hek));
d2238 1
a2238 1
		SvREFCNT_dec_NN(MUTABLE_SV(cv));
d2267 3
a2269 2
      if (amtp->was_ok_sub == newgen) {
	  return AMT_AMAGIC(amtp) ? 1 : 0;
d2277 1
d2283 2
a2284 2
    int filled = 0;
    int i;
d2294 1
a2294 4
    {
      if (!gv_fetchmeth_pvn(stash, "((", 2, -1, 0))
	goto no_table;
    }
a2300 2
        /* don't need to set overloading here because fallback => 1
         * is the default setting for classes without overloading */
d2302 1
a2302 1
    else if (SvOK(sv)) {
a2303 5
        filled = 1;
    }
    else {
        filled = 1;
    }
d2305 3
a2307 1
    for (i = 1; i < NofAMmeth; i++) {
d2310 1
a2310 1
	const char * const cp = AMG_id2name(i);
d2322 4
a2325 1
	gv = Perl_gv_fetchmeth_pvn(aTHX_ stash, cooky, l, -1, 0);
d2371 2
d2381 2
d2385 1
a2385 1
      return TRUE;
d2389 1
a2389 1
 no_table:
d2415 11
a2425 1
	if (Gv_AMupdate(stash, 0) == -1)
d2427 1
d2432 2
a2433 1
    if ( amtp->was_ok_sub != newgen )
a2616 1
  int force_scalar = 0;
d2629 1
a2629 1
      && (stash = SvSTASH(SvRV(left))) && Gv_AMG(stash)
d2694 6
a2699 2
		/* No need to do SvAMAGIC_on here, as SvAMAGIC macros
		   delegate to the stash. */
d2756 1
a2756 1
	       && (stash = SvSTASH(SvRV(right))) && Gv_AMG(stash)
a2859 58

  switch (method) {
    /* in these cases, we're calling '+' or '-' as a fallback for a ++ or --
     * operation. we need this to return a value, so that it can be assigned
     * later on, in the postpr block (case inc_amg/dec_amg), even if the
     * increment or decrement was itself called in void context */
    case inc_amg:
      if (off == add_amg)
        force_scalar = 1;
      break;
    case dec_amg:
      if (off == subtr_amg)
        force_scalar = 1;
      break;
    /* in these cases, we're calling an assignment variant of an operator
     * (+= rather than +, for instance). regardless of whether it's a
     * fallback or not, it always has to return a value, which will be
     * assigned to the proper variable later */
    case add_amg:
    case subtr_amg:
    case mult_amg:
    case div_amg:
    case modulo_amg:
    case pow_amg:
    case lshift_amg:
    case rshift_amg:
    case repeat_amg:
    case concat_amg:
    case band_amg:
    case bor_amg:
    case bxor_amg:
      if (assign)
        force_scalar = 1;
      break;
    /* the copy constructor always needs to return a value */
    case copy_amg:
      force_scalar = 1;
      break;
    /* because of the way these are implemented (they don't perform the
     * dereferencing themselves, they return a reference that perl then
     * dereferences later), they always have to be in scalar context */
    case to_sv_amg:
    case to_av_amg:
    case to_hv_amg:
    case to_gv_amg:
    case to_cv_amg:
      force_scalar = 1;
      break;
    /* these don't have an op of their own; they're triggered by their parent
     * op, so the context there isn't meaningful ('$a and foo()' in void
     * context still needs to pass scalar context on to $a's bool overload) */
    case bool__amg:
    case numer_amg:
    case string_amg:
      force_scalar = 1;
      break;
  }

d2910 1
a2910 1
	  SvREFCNT_dec_NN(tmpRef);  
a2918 2
    I32 oldmark, nret;
    int gimme = force_scalar ? G_SCALAR : GIMME_V;
d2924 1
a2924 16
    myop.op_flags = OPf_STACKED;

    switch (gimme) {
        case G_VOID:
            myop.op_flags |= OPf_WANT_VOID;
            break;
        case G_ARRAY:
            if (flags & AMGf_want_list) {
                myop.op_flags |= OPf_WANT_LIST;
                break;
            }
            /* FALLTHROUGH */
        default:
            myop.op_flags |= OPf_WANT_SCALAR;
            break;
    }
a2944 1
    oldmark = TOPMARK;
a2949 24
    nret = SP - (PL_stack_base + oldmark);

    switch (gimme) {
        case G_VOID:
            /* returning NULL has another meaning, and we check the context
             * at the call site too, so this can be differentiated from the
             * scalar case */
            res = &PL_sv_undef;
            SP = PL_stack_base + oldmark;
            break;
        case G_ARRAY: {
            if (flags & AMGf_want_list) {
                res = sv_2mortal((SV *)newAV());
                av_extend((AV *)res, nret);
                while (nret--)
                    av_store((AV *)res, nret, POPs);
                break;
            }
            /* FALLTHROUGH */
        }
        default:
            res = POPs;
            break;
    }
d2951 1
d3105 1
a3105 1
 * indent-tabs-mode: nil
d3108 1
a3108 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@a84 1
    {
d86 3
a88 4
	    if (type == SVt_PVAV && GvNAMELEN(gv) == 3
	     && strnEQ(GvNAME(gv), "ISA", 3))
	    sv_magic(*where, (SV *)gv, PERL_MAGIC_isa, NULL, 0);
    }
d133 1
a133 1
	    hv_magic(GvHVn(gv), GvAVn(gv), PERL_MAGIC_dbfile);
d157 1
a157 1
    return SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVAV ? SvRV(gv) : NULL;
d168 1
a168 1
    GV *filegv;
d179 1
a179 4
    /* PL_curcop may be null here.  E.g.,
	INIT { bless {} and exit }
       frees INIT before looking up DESTROY (and creating *DESTROY)
    */
a181 1
#ifdef USE_ITHREADS
a185 7
#else
	filegv = CopFILEGV(PL_curcop);
	if (filegv) {
	    file = GvNAME(filegv)+2;
	    len = GvNAMELEN(filegv)-2;
	}
#endif
d193 12
d349 1
d466 1
a466 1
    case KEY_BEGIN   : case KEY_CHECK  : case KEY_cmp:
d522 1
d544 1
a544 1
	if ((cv = newATTRSUB_x(
d553 1
a553 1
	           TRUE
d687 2
a688 3
	if (!HvAUX(stash)->xhv_mro_meta->super)
	    HvAUX(stash)->xhv_mro_meta->super = newHV();
	cachestash = HvAUX(stash)->xhv_mro_meta->super;
d904 1
a904 2
These functions grant C<"SUPER"> token
as a prefix of the method name.  Note
d907 2
a908 2
different subroutine due to $AUTOLOAD changing its value.  Use the glob
created as a side effect to do this.
d910 4
a913 3
These functions have the same side-effects as C<gv_fetchmeth> with
C<level==0>.  The warning against passing the GV returned by
C<gv_fetchmeth> to C<call_sv> applies equally to these functions.
d1029 1
a1029 1
			   "Can't locate object method \"%"UTF8f
d1031 2
a1032 1
			            UTF8fARG(is_utf8, nend - name, name),
d1042 1
a1042 1
		    packnamesv = error_report;
d1046 1
a1046 2
			   "Can't locate object method \"%"UTF8f
			   "\" via package \"%"SVf"\""
d1048 2
a1049 1
			   UTF8fARG(is_utf8, nend - name, name),
d1060 1
a1060 1
	    if (CvANON(cv) || !CvGV(cv))
d1142 1
a1142 2
			 "Use of inherited AUTOLOAD for non-method %"SVf
			 "::%"UTF8f"() is deprecated",
d1144 1
a1144 1
                         UTF8fARG(is_utf8, len, name));
a1258 1
#ifdef DEBUGGING
a1259 1
#endif
d1264 1
d1266 1
a1266 1
	assert(sp == PL_stack_sp);
d1393 1
a1393 1
PERL_STATIC_INLINE void
d1406 3
a1408 10
/* This function grabs name and tries to split a stash and glob
 * from its contents. TODO better description, comments
 * 
 * If the function returns TRUE and 'name == name_end', then
 * 'gv' can be directly returned to the caller of gv_fetchpvn_flags
 */
PERL_STATIC_INLINE bool
S_parse_gv_stash_name(pTHX_ HV **stash, GV **gv, const char **name,
               STRLEN *len, const char *nambeg, STRLEN full_len,
               const U32 is_utf8, const I32 add)
d1410 5
d1416 6
d1424 1
d1426 79
a1504 5
    PERL_ARGS_ASSERT_PARSE_GV_STASH_NAME;
    
    if (full_len > 2 && **name == '*' && isIDFIRST_lazy_if(*name + 1, is_utf8)) {
        /* accidental stringify on a GV? */
        (*name)++;
d1506 3
d1510 39
a1548 58
    for (name_cursor = *name; name_cursor < name_end; name_cursor++) {
        if (name_cursor < name_em1 &&
            ((*name_cursor == ':' && name_cursor[1] == ':')
           || *name_cursor == '\''))
        {
            if (!*stash)
                *stash = PL_defstash;
            if (!*stash || !SvREFCNT(*stash)) /* symbol table under destruction */
                return FALSE;

            *len = name_cursor - *name;
            if (name_cursor > nambeg) { /* Skip for initial :: or ' */
                const char *key;
                GV**gvp;
                if (*name_cursor == ':') {
                    key = *name;
                    *len += 2;
                }
                else {
                    char *tmpbuf;
                    Newx(tmpbuf, *len+2, char);
                    Copy(*name, tmpbuf, *len, char);
                    tmpbuf[(*len)++] = ':';
                    tmpbuf[(*len)++] = ':';
                    key = tmpbuf;
                }
                gvp = (GV**)hv_fetch(*stash, key, is_utf8 ? -((I32)*len) : (I32)*len, add);
                *gv = gvp ? *gvp : NULL;
                if (*gv && *gv != (const GV *)&PL_sv_undef) {
                    if (SvTYPE(*gv) != SVt_PVGV)
                        gv_init_pvn(*gv, *stash, key, *len, (add & GV_ADDMULTI)|is_utf8);
                    else
                        GvMULTI_on(*gv);
                }
                if (key != *name)
                    Safefree(key);
                if (!*gv || *gv == (const GV *)&PL_sv_undef)
                    return FALSE;

                if (!(*stash = GvHV(*gv))) {
                    *stash = GvHV(*gv) = newHV();
                    if (!HvNAME_get(*stash)) {
                        if (GvSTASH(*gv) == PL_defstash && *len == 6
                            && strnEQ(*name, "CORE", 4))
                            hv_name_set(*stash, "CORE", 4, 0);
                        else
                            hv_name_set(
                                *stash, nambeg, name_cursor-nambeg, is_utf8
                            );
                    /* If the containing stash has multiple effective
                    names, see that this one gets them, too. */
                    if (HvAUX(GvSTASH(*gv))->xhv_name_count)
                        mro_package_moved(*stash, NULL, *gv, 1);
                    }
                }
                else if (!HvNAME_get(*stash))
                    hv_name_set(*stash, nambeg, name_cursor - nambeg, is_utf8);
            }
d1550 45
a1594 9
            if (*name_cursor == ':')
                name_cursor++;
            *name = name_cursor+1;
            if (*name == name_end) {
                if (!*gv)
                    *gv = MUTABLE_GV(*hv_fetchs(PL_defstash, "main::", TRUE));
                return TRUE;
            }
        }
a1595 3
    *len = name_cursor - *name;
    return TRUE;
}
d1597 25
a1621 45
/* Checks if an unqualified name is in the main stash */
PERL_STATIC_INLINE bool
S_gv_is_in_main(pTHX_ const char *name, STRLEN len, const U32 is_utf8)
{
    PERL_ARGS_ASSERT_GV_IS_IN_MAIN;
    
    /* If it's an alphanumeric variable */
    if ( len && isIDFIRST_lazy_if(name, is_utf8) ) {
        /* Some "normal" variables are always in main::,
         * like INC or STDOUT.
         */
        switch (len) {
            case 1:
            if (*name == '_')
                return TRUE;
            break;
            case 3:
            if ((name[0] == 'I' && name[1] == 'N' && name[2] == 'C')
                || (name[0] == 'E' && name[1] == 'N' && name[2] == 'V')
                || (name[0] == 'S' && name[1] == 'I' && name[2] == 'G'))
                return TRUE;
            break;
            case 4:
            if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
                && name[3] == 'V')
                return TRUE;
            break;
            case 5:
            if (name[0] == 'S' && name[1] == 'T' && name[2] == 'D'
                && name[3] == 'I' && name[4] == 'N')
                return TRUE;
            break;
            case 6:
            if ((name[0] == 'S' && name[1] == 'T' && name[2] == 'D')
                &&((name[3] == 'O' && name[4] == 'U' && name[5] == 'T')
                    ||(name[3] == 'E' && name[4] == 'R' && name[5] == 'R')))
                return TRUE;
            break;
            case 7:
            if (name[0] == 'A' && name[1] == 'R' && name[2] == 'G'
                && name[3] == 'V' && name[4] == 'O' && name[5] == 'U'
                && name[6] == 'T')
                return TRUE;
            break;
        }
a1622 6
    /* *{""}, or a special variable like $@@ */
    else
        return TRUE;
    
    return FALSE;
}
d1624 2
d1627 8
a1634 15
/* This function is called if parse_gv_stash_name() failed to
 * find a stash, or if GV_NOTQUAL or an empty name was passed
 * to gv_fetchpvn_flags.
 * 
 * It returns FALSE if the default stash can't be found nor created,
 * which might happen during global destruction.
 */
PERL_STATIC_INLINE bool
S_find_default_stash(pTHX_ HV **stash, const char *name, STRLEN len,
               const U32 is_utf8, const I32 add,
               const svtype sv_type)
{
    PERL_ARGS_ASSERT_FIND_DEFAULT_STASH;
    
    /* No stash in name, so see how we can default */
d1636 41
a1676 19
    if ( gv_is_in_main(name, len, is_utf8) ) {
        *stash = PL_defstash;
    }
    else {
        if (IN_PERL_COMPILETIME) {
            *stash = PL_curstash;
            if (add && (PL_hints & HINT_STRICT_VARS) &&
                sv_type != SVt_PVCV &&
                sv_type != SVt_PVGV &&
                sv_type != SVt_PVFM &&
                sv_type != SVt_PVIO &&
                !(len == 1 && sv_type == SVt_PV &&
                (*name == 'a' || *name == 'b')) )
            {
                GV**gvp = (GV**)hv_fetch(*stash,name,is_utf8 ? -(I32)len : (I32)len,0);
                if (!gvp || *gvp == (const GV *)&PL_sv_undef ||
                    SvTYPE(*gvp) != SVt_PVGV)
                {
                    *stash = NULL;
d1678 14
a1691 25
                else if ((sv_type == SVt_PV   && !GvIMPORTED_SV(*gvp)) ||
                         (sv_type == SVt_PVAV && !GvIMPORTED_AV(*gvp)) ||
                         (sv_type == SVt_PVHV && !GvIMPORTED_HV(*gvp)) )
                {
                    /* diag_listed_as: Variable "%s" is not imported%s */
                    Perl_ck_warner_d(
                        aTHX_ packWARN(WARN_MISC),
                        "Variable \"%c%"UTF8f"\" is not imported",
                        sv_type == SVt_PVAV ? '@@' :
                        sv_type == SVt_PVHV ? '%' : '$',
                        UTF8fARG(is_utf8, len, name));
                    if (GvCVu(*gvp))
                        Perl_ck_warner_d(
                            aTHX_ packWARN(WARN_MISC),
                            "\t(Did you mean &%"UTF8f" instead?)\n",
                            UTF8fARG(is_utf8, len, name)
                        );
                    *stash = NULL;
                }
            }
        }
        else {
            /* Use the current op's stash */
            *stash = CopSTASH(PL_curcop);
        }
d1694 6
a1699 28
    if (!*stash) {
        if (add && !PL_in_clean_all) {
            SV * const err = Perl_mess(aTHX_
                 "Global symbol \"%s%"UTF8f
                 "\" requires explicit package name",
                 (sv_type == SVt_PV ? "$"
                  : sv_type == SVt_PVAV ? "@@"
                  : sv_type == SVt_PVHV ? "%"
                  : ""), UTF8fARG(is_utf8, len, name));
            GV *gv;
            if (is_utf8)
                SvUTF8_on(err);
            qerror(err);
            /* To maintain the output of errors after the strict exception
             * above, and to keep compat with older releases, rather than
             * placing the variables in the pad, we place
             * them in the <none>:: stash.
             */
            gv = gv_fetchpvs("<none>::", GV_ADDMULTI, SVt_PVHV);
            if (!gv) {
                /* symbol table under destruction */
                return FALSE;
            }
            *stash = GvHV(gv);
        }
        else
            return FALSE;
    }
d1701 1
a1701 2
    if (!SvREFCNT(*stash))   /* symbol table under destruction */
        return FALSE;
d1703 4
a1706 2
    return TRUE;
}
d1708 3
a1710 16
/* gv_magicalize() is called by gv_fetchpvn_flags when creating
 * a new GV.
 * Note that it does not insert the GV into the stash prior to
 * magicalization, which some variables require need in order
 * to work (like $[, %+, %-, %!), so callers must take care of
 * that beforehand.
 * 
 * The return value has a specific meaning for gv_fetchpvn_flags:
 * If it returns true, and the gv is empty, it indicates that its
 * refcount should be decreased.
 */
PERL_STATIC_INLINE bool
S_gv_magicalize(pTHX_ GV *gv, HV *stash, const char *name, STRLEN len,
               bool addmg, const svtype sv_type)
{
    SSize_t paren;
d1712 1
a1712 2
    PERL_ARGS_ASSERT_GV_MAGICALIZE;
    
d1714 1
a1714 1
	/* We only have to check for a few names here: a, b, EXPORT, ISA
d1717 1
a1717 1
	if (len) {
a1731 5
	    case 'a':
	    case 'b':
		if (len == 1 && sv_type == SVt_PV)
		    GvMULTI_on(gv);
		/* FALL THROUGH */
d1735 1
a1735 1
	    return addmg;
d1752 1
a1752 7
               the common case of lower case variable names.  (On EBCDIC
               platforms, we can't just do:
                 if (NATIVE_TO_ASCII(*name) > NATIVE_TO_ASCII('V') ) {
               because cases like '\027' in the switch statement below are
               C1 (non-ASCII) controls on those platforms, so the remapping
               would make them larger than 'V')
             */
d1827 2
a1828 5
                if (strEQ(name2, "ATCH")) {
                    paren = RX_BUFF_IDX_CARET_FULLMATCH;
                    goto storeparen;
                }
                break;
d1834 2
a1835 8
                if (strEQ(name2, "REMATCH")) {
                    paren = RX_BUFF_IDX_CARET_PREMATCH;
                    goto storeparen;
                }
	        if (strEQ(name2, "OSTMATCH")) {
                    paren = RX_BUFF_IDX_CARET_POSTMATCH;
                    goto storeparen;
                }
d1868 1
a1868 2
		    if (!isDIGIT(*end))
                        return addmg;
d1870 1
a1870 2
                paren = strtoul(name, NULL, 10);
                goto storeparen;
a1878 2
            paren = RX_BUFF_IDX_FULLMATCH;
            goto sawampersand;
a1879 2
            paren = RX_BUFF_IDX_PREMATCH;
            goto sawampersand;
a1880 2
            paren = RX_BUFF_IDX_POSTMATCH;
        sawampersand:
d1896 1
a1896 17
            goto storeparen;
        case '1':               /* $1 */
        case '2':               /* $2 */
        case '3':               /* $3 */
        case '4':               /* $4 */
        case '5':               /* $5 */
        case '6':               /* $6 */
        case '7':               /* $7 */
        case '8':               /* $8 */
        case '9':               /* $9 */
            paren = *name - '0';

        storeparen:
            /* Flag the capture variables with a NULL mg_ptr
               Use mg_len for the array index to lookup.  */
            sv_magic(GvSVn(gv), MUTABLE_SV(gv), PERL_MAGIC_sv, NULL, paren);
            break;
d1917 2
a1919 1
                addmg = FALSE;
d1938 2
a1940 1
                addmg = FALSE;
d1961 1
d1963 1
a1963 1
                addmg = FALSE;
d1972 9
a2032 4
	case 'a':
	case 'b':
	    if (sv_type == SVt_PV)
		GvMULTI_on(gv);
d2035 7
a2041 48

    return addmg;
}

/* This function is called when the stash already holds the GV of the magic
 * variable we're looking for, but we need to check that it has the correct
 * kind of magic.  For example, if someone first uses $! and then %!, the
 * latter would end up here, and we add the Errno tie to the HASH slot of
 * the *! glob.
 */
PERL_STATIC_INLINE void
S_maybe_multimagic_gv(pTHX_ GV *gv, const char *name, const svtype sv_type)
{
    PERL_ARGS_ASSERT_MAYBE_MULTIMAGIC_GV;

    if (sv_type == SVt_PVHV || sv_type == SVt_PVGV) {
        if (*name == '!')
            require_tie_mod(gv, "!", newSVpvs("Errno"), "TIEHASH", 1);
        else if (*name == '-' || *name == '+')
            require_tie_mod(gv, name, newSVpvs("Tie::Hash::NamedCapture"), "TIEHASH", 0);
    } else if (sv_type == SVt_PV) {
        if (*name == '*' || *name == '#') {
            /* diag_listed_as: $* is no longer supported */
            Perl_ck_warner_d(aTHX_ packWARN2(WARN_DEPRECATED,
                                             WARN_SYNTAX),
                             "$%c is no longer supported", *name);
        }
    }
    if (sv_type==SVt_PV || sv_type==SVt_PVGV) {
      switch (*name) {
      case '[':
          require_tie_mod(gv,name,newSVpvs("arybase"),"FETCH",0);
          break;
#ifdef PERL_SAWAMPERSAND
      case '`':
          PL_sawampersand |= SAWAMPERSAND_LEFT;
          (void)GvSVn(gv);
          break;
      case '&':
          PL_sawampersand |= SAWAMPERSAND_MIDDLE;
          (void)GvSVn(gv);
          break;
      case '\'':
          PL_sawampersand |= SAWAMPERSAND_RIGHT;
          (void)GvSVn(gv);
          break;
#endif
      }
a2042 141
}

GV *
Perl_gv_fetchpvn_flags(pTHX_ const char *nambeg, STRLEN full_len, I32 flags,
		       const svtype sv_type)
{
    dVAR;
    const char *name = nambeg;
    GV *gv = NULL;
    GV**gvp;
    STRLEN len;
    HV *stash = NULL;
    const I32 no_init = flags & (GV_NOADD_NOINIT | GV_NOINIT);
    const I32 no_expand = flags & GV_NOEXPAND;
    const I32 add = flags & ~GV_NOADD_MASK;
    const U32 is_utf8 = flags & SVf_UTF8;
    bool addmg = cBOOL(flags & GV_ADDMG);
    const char *const name_end = nambeg + full_len;
    U32 faking_it;

    PERL_ARGS_ASSERT_GV_FETCHPVN_FLAGS;

     /* If we have GV_NOTQUAL, the caller promised that
      * there is no stash, so we can skip the check.
      * Similarly if full_len is 0, since then we're
      * dealing with something like *{""} or ""->foo()
      */
    if ((flags & GV_NOTQUAL) || !full_len) {
        len = full_len;
    }
    else if (parse_gv_stash_name(&stash, &gv, &name, &len, nambeg, full_len, is_utf8, add)) {
        if (name == name_end) return gv;
    }
    else {
        return NULL;
    }

    if (!stash && !find_default_stash(&stash, name, len, is_utf8, add, sv_type)) {
        return NULL;
    }
    
    /* By this point we should have a stash and a name */
    gvp = (GV**)hv_fetch(stash,name,is_utf8 ? -(I32)len : (I32)len,add);
    if (!gvp || *gvp == (const GV *)&PL_sv_undef) {
	if (addmg) gv = (GV *)newSV(0);
	else return NULL;
    }
    else gv = *gvp, addmg = 0;
    /* From this point on, addmg means gv has not been inserted in the
       symtab yet. */

    if (SvTYPE(gv) == SVt_PVGV) {
        /* The GV already exists, so return it, but check if we need to do
         * anything else with it before that.
         */
	if (add) {
            /* This is the heuristic that handles if a variable triggers the
             * 'used only once' warning.  If there's already a GV in the stash
             * with this name, then we assume that the variable has been used
             * before and turn its MULTI flag on.
             * It's a heuristic because it can easily be "tricked", like with
             * BEGIN { $a = 1; $::{foo} = *a }; () = $foo
             * not warning about $main::foo being used just once
             */
	    GvMULTI_on(gv);
	    gv_init_svtype(gv, sv_type);
            /* You reach this path once the typeglob has already been created,
               either by the same or a different sigil.  If this path didn't
               exist, then (say) referencing $! first, and %! second would
               mean that %! was not handled correctly.  */
	    if (len == 1 && stash == PL_defstash) {
                maybe_multimagic_gv(gv, name, sv_type);
	    }
	    else if (len == 3 && sv_type == SVt_PVAV
	          && strnEQ(name, "ISA", 3)
	          && (!GvAV(gv) || !SvSMAGICAL(GvAV(gv))))
		gv_magicalize_isa(gv);
	}
	return gv;
    } else if (no_init) {
	assert(!addmg);
	return gv;
    }
    /* If GV_NOEXPAND is true and what we got off the stash is a ref,
     * don't expand it to a glob. This is an optimization so that things
     * copying constants over, like Exporter, don't have to be rewritten
     * to take into account that you can store more than just globs in
     * stashes.
     */
    else if (no_expand && SvROK(gv)) {
	assert(!addmg);
	return gv;
    }

    /* Adding a new symbol.
       Unless of course there was already something non-GV here, in which case
       we want to behave as if there was always a GV here, containing some sort
       of subroutine.
       Otherwise we run the risk of creating things like GvIO, which can cause
       subtle bugs. eg the one that tripped up SQL::Translator  */

    faking_it = SvOK(gv);

    if (add & GV_ADDWARN)
	Perl_ck_warner_d(aTHX_ packWARN(WARN_INTERNAL),
		"Had to create %"UTF8f" unexpectedly",
		 UTF8fARG(is_utf8, name_end-nambeg, nambeg));
    gv_init_pvn(gv, stash, name, len, (add & GV_ADDMULTI)|is_utf8);

    if ( isIDFIRST_lazy_if(name, is_utf8) && !ckWARN(WARN_ONCE) )
        GvMULTI_on(gv) ;

    /* First, store the gv in the symtab if we're adding magic,
     * but only for non-empty GVs
     */
#define GvEMPTY(gv)      !(GvAV(gv) || GvHV(gv) || GvIO(gv) \
                        || GvCV(gv) || (GvSV(gv) && SvOK(GvSV(gv))))
    
    if ( addmg && !GvEMPTY(gv) ) {
        (void)hv_store(stash,name,len,(SV *)gv,0);
    }

    /* set up magic where warranted */
    if ( gv_magicalize(gv, stash, name, len, addmg, sv_type) ) {
        /* See 23496c6 */
        if (GvEMPTY(gv)) {
            if ( GvSV(gv) && SvMAGICAL(GvSV(gv)) ) {
                /* The GV was and still is "empty", except that now
                 * it has the magic flags turned on, so we want it
                 * stored in the symtab.
                 */
                (void)hv_store(stash,name,len,(SV *)gv,0);
            }
            else {
                /* Most likely the temporary GV created above */
                SvREFCNT_dec_NN(gv);
                gv = NULL;
            }
        }
    }
    
a2077 5

/* recursively scan a stash and any nested stashes looking for entries
 * that need the "only used once" warning raised
 */

d2079 1
a2079 1
Perl_gv_check(pTHX_ HV *stash)
a2087 3

    assert(SvOOK(stash));

a2089 2
        /* mark stash is being scanned, to avoid recursing */
        HvAUX(stash)->xhv_aux_flags |= HvAUXf_SCAN_STASH;
d2096 1
a2096 4
		if (hv != PL_defstash && hv != stash
                    && !(SvOOK(hv)
                        && (HvAUX(hv)->xhv_aux_flags & HvAUXf_SCAN_STASH))
                )
a2119 1
        HvAUX(stash)->xhv_aux_flags &= ~HvAUXf_SCAN_STASH;
a2127 1
    assert(!(flags & ~SVf_UTF8));
d2129 3
a2131 2
    return gv_fetchpv(Perl_form(aTHX_ "%"UTF8f"::_GEN_%ld",
                                UTF8fARG(flags, strlen(pack), pack),
d2173 1
a2173 2
    if (gp->gp_refcnt > 1) {
       borrowed:
a2175 1
	gp->gp_refcnt--;
d2210 3
a2212 1
           (void)hv_deletehek(PL_stashcache, hvname_hek, G_DISCARD);
a2218 3
      /* Possibly reallocated by a destructor */
      gp = GvGP(gv);

a2234 2
    /* Possibly incremented by a destructor doing glob assignment */
    if (gp->gp_refcnt > 1) goto borrowed;
a2296 2
    bool deref_seen = 0;

a2326 4
    assert(SvOOK(stash));
    /* initially assume the worst */
    HvAUX(stash)->xhv_aux_flags &= ~HvAUXf_NO_DEREF;

a2392 13

        if (gv) {
            switch (i) {
            case to_sv_amg:
            case to_av_amg:
            case to_hv_amg:
            case to_gv_amg:
            case to_cv_amg:
            case nomethod_amg:
                deref_seen = 1;
                break;
            }
        }
a2393 6
    if (!deref_seen)
        /* none of @@{} etc overloaded; we can do $obj->[N] quicker.
         * NB - aux var invalid here, HvARRAY() could have been
         * reallocated since it was assigned to */
        HvAUX(stash)->xhv_aux_flags |= HvAUXf_NO_DEREF;

a2562 1
    HV *stash;
d2566 2
a2567 9
    if (!SvAMAGIC(ref))
        return ref;
    /* return quickly if none of the deref ops are overloaded */
    stash = SvSTASH(SvRV(ref));
    assert(SvOOK(stash));
    if (HvAUX(stash)->xhv_aux_flags & HvAUXf_NO_DEREF)
        return ref;

    while ((tmpsv = amagic_call(ref, &PL_sv_undef, method,
a2575 2
        if (!SvAMAGIC(ref))
            break;
d3005 1
a3152 2
    if (gv == PL_statgv || gv == PL_last_in_gv || gv == PL_stderrgv)
	return;
d3166 3
a3168 2
	(void)hv_deletehek(stash, gvnhek, G_DISCARD);
    } else if (GvMULTI(gv) && cv && SvREFCNT(cv) == 1 &&
d3174 2
a3175 1
	    (gvp = hv_fetchhek(stash, namehek, 0)) &&
a3177 1
	const bool imported = !!GvIMPORTED_CV(gv);
d3181 1
a3181 1
	SvFLAGS(gv) = SVt_IV|SVf_ROK|SVprv_PCS_IMPORTED * imported;
a3185 17
}

GV *
Perl_gv_override(pTHX_ const char * const name, const STRLEN len)
{
    GV *gv = gv_fetchpvn(name, len, GV_NOTQUAL, SVt_PVCV);
    GV * const *gvp;
    PERL_ARGS_ASSERT_GV_OVERRIDE;
    if (gv && GvCVu(gv) && GvIMPORTED_CV(gv)) return gv;
    gvp = (GV**)hv_fetch(PL_globalstash, name, len, FALSE);
    gv = gvp ? *gvp : NULL;
    if (gv && !isGV(gv)) {
	if (!SvPCS_IMPORTED(gv)) return NULL;
	gv_init(gv, PL_globalstash, name, len, 0);
	return gv;
    }
    return gv && GvCVu(gv) && GvIMPORTED_CV(gv) ? gv : NULL;
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@d1205 1
a1205 1
    varstash = CvNAMED(cv) ? CvSTASH(cv) : GvSTASH(CvGV(cv));
d2547 1
a2547 1
        if (gv && (cv = GvCV(gv)) && CvGV(cv)) {
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d24 1
d38 1
a38 1
#include "overload.inc"
d43 1
a43 1
#define S_autolen (sizeof("AUTOLOAD")-1)
d105 1
d134 1
a134 1
    if (PERLDB_LINE_OR_SAVESRC && !GvAV(gv))
d147 1
a147 1
C<NULL>.
a155 1
    PERL_UNUSED_CONTEXT;
d159 1
a159 1
    return SvROK(gv) && SvTYPE(SvRV(gv)) != SVt_PVAV && SvTYPE(SvRV(gv)) != SVt_PVCV ? SvRV(gv) : NULL;
d220 1
a220 1
    GV * const oldgv = CvNAMED(cv) ? NULL : SvANY(cv)->xcv_gv_u.xcv_gv;
d236 1
a236 4
    else if ((hek = CvNAME_HEK(cv))) {
	unshare_hek(hek);
	CvLEXICAL_off(cv);
    }
a237 1
    CvNAMED_off(cv);
a251 31
/* Convert CvSTASH + CvNAME_HEK into a GV.  Conceptually, all subs have a
   GV, but for efficiency that GV may not in fact exist.  This function,
   called by CvGV, reifies it. */

GV *
Perl_cvgv_from_hek(pTHX_ CV *cv)
{
    GV *gv;
    SV **svp;
    PERL_ARGS_ASSERT_CVGV_FROM_HEK;
    assert(SvTYPE(cv) == SVt_PVCV);
    if (!CvSTASH(cv)) return NULL;
    ASSUME(CvNAME_HEK(cv));
    svp = hv_fetchhek(CvSTASH(cv), CvNAME_HEK(cv), 0);
    gv = MUTABLE_GV(svp && *svp ? *svp : newSV(0));
    if (!isGV(gv))
	gv_init_pvn(gv, CvSTASH(cv), HEK_KEY(CvNAME_HEK(cv)),
		HEK_LEN(CvNAME_HEK(cv)),
		SVf_UTF8 * !!HEK_UTF8(CvNAME_HEK(cv)));
    if (!CvNAMED(cv)) { /* gv_init took care of it */
	assert (SvANY(cv)->xcv_gv_u.xcv_gv == gv);
	return gv;
    }
    unshare_hek(CvNAME_HEK(cv));
    CvNAMED_off(cv);
    SvANY(cv)->xcv_gv_u.xcv_gv = gv;
    if (svp && *svp) SvREFCNT_inc_simple_void_NN(gv);
    CvCVGV_RC_on(cv);
    return gv;
}

d273 2
a274 2
overwriting it as happens with typeglobs created by C<SvSetSV>.  Converting
any scalar that is C<SvOK()> may produce unpredictable results and is reserved
d287 1
a287 1
C<flags> can be set to C<SVf_UTF8> if C<name> is a UTF-8 string, or
d289 1
a289 1
C<GV_ADDMULTI> flag, which means to pretend that the GV has been
d294 1
a294 1
The old form of C<gv_init_pvn()>.  It does not work with UTF-8 strings, as it
d296 1
a296 1
C<GV_ADDMULTI> flag will be passed to C<gv_init_pvn()>.
d300 1
a300 1
Same as C<gv_init_pvn()>, but takes a nul-terminated string for the name
d305 1
a305 1
Same as C<gv_init_pvn()>, but takes an SV * for the name instead of separate
d333 1
d348 1
a348 1
	/* The constant has to be a scalar, array or subroutine.  */
d351 1
a355 2
            break;

d386 1
a386 15
    if (has_constant && SvTYPE(has_constant) == SVt_PVCV) {
	/* Not actually a constant.  Just a regular sub.  */
	CV * const cv = (CV *)has_constant;
	GvCV_set(gv,cv);
	if (CvSTASH(cv) == stash && (
	       CvNAME_HEK(cv) == GvNAME_HEK(gv)
	    || (  HEK_LEN(CvNAME_HEK(cv)) == HEK_LEN(GvNAME_HEK(gv))
	       && HEK_FLAGS(CvNAME_HEK(cv)) != HEK_FLAGS(GvNAME_HEK(gv))
	       && HEK_UTF8(CvNAME_HEK(cv)) == HEK_UTF8(GvNAME_HEK(gv))
	       && memEQ(HEK_KEY(CvNAME_HEK(cv)), GvNAME(gv), GvNAMELEN(gv))
	       )
	   ))
	    CvGV_set(cv,gv);
    }
    else if (doproto) {
a523 1
	PoisonPADLIST(cv);
d527 1
a527 3
    /* XSUBs can't be perl lang/perl5db.pl debugged
    if (PERLDB_LINE_OR_SAVESRC)
        (void)gv_fetchfile(file); */
d591 7
a597 8
    char *namepv;
    STRLEN namelen;
    PERL_ARGS_ASSERT_GV_FETCHMETH_SV;
    if (LIKELY(SvPOK_nog(namesv))) /* common case */
        return gv_fetchmeth_internal(stash, namesv, NULL, 0, level, flags);
    namepv = SvPV(namesv, namelen);
    if (SvUTF8(namesv)) flags |= SVf_UTF8;
    return gv_fetchmeth_pvn(stash, namepv, namelen, level, flags);
d613 1
a613 1
    return gv_fetchmeth_internal(stash, NULL, name, strlen(name), level, flags);
d621 1
a621 1
accessible via C<@@ISA> and C<UNIVERSAL::>.
d628 1
a628 1
The only significant values for C<flags> are C<GV_SUPER> and C<SVf_UTF8>.
d630 1
a630 1
C<GV_SUPER> indicates that we want to look up the method in the superclasses
d644 2
a645 2
PERL_STATIC_INLINE GV*
S_gv_fetchmeth_internal(pTHX_ HV* stash, SV* meth, const char* name, STRLEN len, I32 level, U32 flags)
d647 1
a648 1
    HE* he;
d657 1
a657 1
    I32 create = (level >= 0) ? HV_FETCH_LVALUE : 0;
d662 2
d678 1
a678 1
    assert(name || meth);
d681 1
a681 2
		      flags & GV_SUPER ? "SUPER " : "",
		      name ? name : SvPV_nolen(meth), hvname) );
d693 2
a694 6
    he = (HE*)hv_common(
        cachestash, meth, name, len, (flags & SVf_UTF8) ? HVhek_UTF8 : 0, create, NULL, 0
    );
    if (he) gvp = (GV**)&HeVAL(he);
    else gvp = NULL;

a699 3
        {
            if (!name)
                name = SvPV_nomg(meth, len);
a700 1
        }
d779 1
a779 2
        candidate = gv_fetchmeth_internal(NULL, meth, name, len, 1,
                                          flags &~GV_SUPER);
a800 7
GV *
Perl_gv_fetchmeth_pvn(pTHX_ HV *stash, const char *name, STRLEN len, I32 level, U32 flags)
{
    PERL_ARGS_ASSERT_GV_FETCHMETH_PVN;
    return gv_fetchmeth_internal(stash, NULL, name, len, level, flags);
}

d846 1
a846 1
Same as C<gv_fetchmeth_pvn()>, but looks for autoloaded subroutines too.
d850 1
a850 1
if C<level < 0>.  For an autoloaded subroutine without a stub, C<GvCV()>
d853 1
a853 1
Currently, the only significant value for C<flags> is C<SVf_UTF8>.
d895 1
a895 1
glob for "AUTOLOAD".  In this case the corresponding variable C<$AUTOLOAD> is
d908 1
a908 1
different subroutine due to C<$AUTOLOAD> changing its value.  Use the glob
d950 1
d1059 1
a1059 1
	    if (CvANON(cv) || CvLEXICAL(cv))
d1100 1
d1248 1
d1304 1
a1304 1
C<flags> is 0 (or any other setting that does not create packages) then C<NULL>
d1316 1
a1316 4
The most important of which are probably C<GV_ADD> and C<SVf_UTF8>.

Note, use of C<gv_stashsv> instead of C<gv_stashpvn> where possible is strongly
recommended for performance reasons.
d1321 2
a1322 10
/*
gv_stashpvn_internal

Perform the internal bits of gv_stashsvpvn_cached. You could think of this
as being one half of the logic. Not to be called except from gv_stashsvpvn_cached().

*/

PERL_STATIC_INLINE HV*
S_gv_stashpvn_internal(pTHX_ const char *name, U32 namelen, I32 flags)
d1330 1
a1330 1
    PERL_ARGS_ASSERT_GV_STASHPVN_INTERNAL;
d1342 1
a1342 1
    if (!tmpgv || !isGV_with_GP(tmpgv))
a1359 61
gv_stashsvpvn_cached

Returns a pointer to the stash for a specified package, possibly
cached.  Implements both C<gv_stashpvn> and C<gc_stashsv>.

Requires one of either namesv or namepv to be non-null.

See C<L</gv_stashpvn>> for details on "flags".

Note the sv interface is strongly preferred for performance reasons.

*/

#define PERL_ARGS_ASSERT_GV_STASHSVPVN_CACHED \
    assert(namesv || name)

PERL_STATIC_INLINE HV*
S_gv_stashsvpvn_cached(pTHX_ SV *namesv, const char *name, U32 namelen, I32 flags)
{
    HV* stash;
    HE* he;

    PERL_ARGS_ASSERT_GV_STASHSVPVN_CACHED;

    he = (HE *)hv_common(
        PL_stashcache, namesv, name, namelen,
        (flags & SVf_UTF8) ? HVhek_UTF8 : 0, 0, NULL, 0
    );

    if (he) return INT2PTR(HV*,SvIVX(HeVAL(he)));
    else if (flags & GV_CACHE_ONLY) return NULL;

    if (namesv) {
        if (SvOK(namesv)) { /* prevent double uninit warning */
            STRLEN len;
            name = SvPV_const(namesv, len);
            namelen = len;
            flags |= SvUTF8(namesv);
        } else {
            name = ""; namelen = 0;
        }
    }
    stash = gv_stashpvn_internal(name, namelen, flags);

    if (stash && namelen) {
        SV* const ref = newSViv(PTR2IV(stash));
        (void)hv_store(PL_stashcache, name,
            (flags & SVf_UTF8) ? -(I32)namelen : (I32)namelen, ref, 0);
    }

    return stash;
}

HV*
Perl_gv_stashpvn(pTHX_ const char *name, U32 namelen, I32 flags)
{
    PERL_ARGS_ASSERT_GV_STASHPVN;
    return gv_stashsvpvn_cached(NULL, name, namelen, flags);
}

/*
d1362 1
a1362 5
Returns a pointer to the stash for a specified package.  See
C<L</gv_stashpvn>>.

Note this interface is strongly preferred over C<gv_stashpvn> for performance
reasons.
d1370 3
d1374 2
a1375 1
    return gv_stashsvpvn_cached(sv, NULL, 0, flags);
d1621 1
a1621 2
            GV *gv;
            qerror(Perl_mess(aTHX_
d1623 1
a1623 2
                 "\" requires explicit package name (did you forget to "
                 "declare \"my %s%"UTF8f"\"?)",
d1627 5
a1631 5
                  : ""), UTF8fARG(is_utf8, len, name),
                 (sv_type == SVt_PV ? "$"
                  : sv_type == SVt_PVAV ? "@@"
                  : sv_type == SVt_PVHV ? "%"
                  : ""), UTF8fARG(is_utf8, len, name)));
a1653 6
/* gv_magicalize only turns on the SVf_READONLY flag, not SVf_PROTECT.  So
   redefine SvREADONLY_on for that purpose.  We donât use it later on in
   this file.  */
#undef SvREADONLY_on
#define SvREADONLY_on(sv) (SvFLAGS(sv) |= SVf_READONLY)

d1696 1
a1696 1
		/* FALLTHROUGH */
d1727 1
a1727 1
	    const char * name2 = name + 1;
a1785 3
                if (*name2 == '_') {
                    name2++;
                }
a1831 4
#ifdef WIN32
		else if (strEQ(name2, "IN32_SLOPPY_STAT"))
		    goto magicalize;
#endif
d1845 7
a1851 5
                UV uv;
                if (!grok_atoUV(name, &uv, NULL) || uv > I32_MAX)
                    return addmg;
                /* XXX why are we using a SSize_t? */
                paren = (SSize_t)(I32)uv;
d1971 1
a1971 1
	    /* FALLTHROUGH */
a2034 4
/* If we do ever start using this later on in the file, we need to make
   sure we donât accidentally use the wrong definition.  */
#undef SvREADONLY_on

d2086 1
d2264 1
d2318 1
d2333 1
d2353 1
d2402 2
a2403 4
        if (PL_stashcache && hvname_hek) {
           DEBUG_o(Perl_deb(aTHX_
                          "gp_free clearing PL_stashcache for '%"HEKf"'\n",
                           HEKfARG(hvname_hek)));
a2404 1
        }
a2406 10
      if (io && SvREFCNT(io) == 1 && IoIFP(io)
	     && (IoTYPE(io) == IoTYPE_WRONLY ||
		 IoTYPE(io) == IoTYPE_RDWR   ||
		 IoTYPE(io) == IoTYPE_APPEND)
	     && ckWARN_d(WARN_IO)
	     && IoIFP(io) != PerlIO_stdin()
	     && IoIFP(io) != PerlIO_stdout()
	     && IoIFP(io) != PerlIO_stderr()
	     && !(IoFLAGS(io) & IOf_FAKE_DIRP))
	io_close(io, gv, FALSE, TRUE);
d2467 1
d2547 5
a2551 8
        if (gv && (cv = GvCV(gv)) && CvHASGV(cv)) {
            const HEK * const gvhek =
                CvNAMED(cv) ? CvNAME_HEK(cv) : GvNAME_HEK(CvGV(cv));
            const HEK * const stashek =
                HvNAME_HEK(CvNAMED(cv) ? CvSTASH(cv) : GvSTASH(CvGV(cv)));
            if (HEK_LEN(gvhek) == 3 && strEQ(HEK_KEY(gvhek), "nil")
             && stashek && HEK_LEN(stashek) == 8
             && strEQ(HEK_KEY(stashek), "overload")) {
d2585 1
d2635 1
d2687 1
d2695 1
a2695 3
					      AMGf_noright | AMGf_unary
					    | (flags & AMGf_numarg))))
    {
d2730 1
d2741 1
a2741 2
		    ((flags & AMGf_assign) && opASSIGN ? AMGf_assign: 0)
		  | (flags & AMGf_numarg));
d2972 1
a2972 1

d2980 1
a2980 1

d3047 1
a3120 3
    case sband_amg:
    case sbor_amg:
    case sbxor_amg:
d3208 1
a3208 1
    U8 gimme = force_scalar ? G_SCALAR : GIMME_V;
a3246 4
    else if (flags & AMGf_numarg)
      PUSHs(&PL_sv_undef);
    if (flags & AMGf_numarg)
      PUSHs(&PL_sv_yes);
d3402 1
a3402 1
	    CvSTASH(cv) == stash && !CvNAMED(cv) && CvGV(cv) == gv &&
a3413 2

        /* See also: 'SET_SVANY_FOR_BODYLESS_IV' in sv.c */
d3448 6
@


