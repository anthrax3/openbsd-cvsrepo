head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.8
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.2
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.4
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.49.21;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.09.29;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2015.04.25.19.10.45;	author afresh1;	state Exp;
branches;
next	1.1.1.8;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.8
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!perl
# Generates info for Module::CoreList from this perl tree
# run this from the root of a perl tree
#
# Data is on STDOUT.
#
# With an optional arg specifying the root of a CPAN mirror, outputs the
# %upstream and %bug_tracker hashes too.

use autodie;
use strict;
use warnings;
use File::Find;
use ExtUtils::MM_Unix;
use version;
use lib "Porting";
use Maintainers qw(%Modules files_to_modules);
use File::Spec;
use Parse::CPAN::Meta;
use IPC::Cmd 'can_run';
use HTTP::Tiny;
use IO::Uncompress::Gunzip;

my $corelist_file = 'dist/Module-CoreList/lib/Module/CoreList.pm';
my $utils_file = 'dist/Module-CoreList/lib/Module/CoreList/Utils.pm';

my %lines;
my %module_to_file;
my %modlist;

die "usage: $0 [ cpan-mirror/ ] [ 5.x.y] \n" unless @@ARGV <= 2;
my $cpan         = shift;
my $raw_version  = shift || $];
my $perl_version = version->parse("$raw_version");
my $perl_vnum    = $perl_version->numify;
my $perl_vstring = $perl_version->normal; # how do we get version.pm to not give us leading v?
$perl_vstring =~ s/^v//;

if ( !-f 'MANIFEST' ) {
    die "Must be run from the root of a clean perl tree\n";
}

open( my $corelist_fh, '<', $corelist_file );
my $corelist = join( '', <$corelist_fh> );
close $corelist_fh;

unless (
    $corelist =~ /^%released \s* = \s* \(
        .*?
        $perl_vnum \s* => \s* .*?
        \);/ismx
    )
{
    warn "Adding $perl_vnum to the list of released perl versions. Please consider adding a release date.\n";
    $corelist =~ s/^(%released \s* = \s* .*?) ( \) )
                /$1  $perl_vnum => '????-??-??',\n  $2/ismx;
}

if ($cpan) {
    my $modlistfile = File::Spec->catfile( $cpan, 'modules', '02packages.details.txt' );
    my $content;

    my $fh;
    if ( -e $modlistfile ) {
        warn "Reading the module list from $modlistfile";
        open $fh, '<', $modlistfile;
    } elsif ( -e $modlistfile . ".gz" ) {
        my $zcat = can_run('gzcat') || can_run('zcat') or die "Can't find gzcat or zcat";
        warn "Reading the module list from $modlistfile.gz";
        open $fh, '-|', "$zcat $modlistfile.gz";
    } else {
        warn "About to fetch 02packages from ftp.funet.fi. This may take a few minutes\n";
	my $gzipped_content = fetch_url('http://ftp.funet.fi/pub/CPAN/modules/02packages.details.txt.gz');
	unless ($gzipped_content) {
            die "Unable to read 02packages.details.txt from either your CPAN mirror or ftp.funet.fi";
        }
	IO::Uncompress::Gunzip::gunzip(\$gzipped_content, \$content, Transparent => 0)
	    or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
    }

    if ( $fh and !$content ) {
        local $/ = "\n";
        $content = join( '', <$fh> );
    }

    die "Incompatible modlist format"
        unless $content =~ /^Columns: +package name, version, path/m;

    # Converting the file to a hash is about 5 times faster than a regexp flat
    # lookup.
    for ( split( qr/\n/, $content ) ) {
        next unless /^([A-Za-z_:0-9]+) +[-0-9.undefHASHVERSIONvsetwhenloadingbogus]+ +(\S+)/;
        $modlist{$1} = $2;
    }
}

find(
    sub {
        /(\.pm|_pm\.PL)$/ or return;
        /PPPort\.pm$/ and return;
        my $module = $File::Find::name;
        $module =~ /\b(demo|t|private)\b/ and return;    # demo or test modules
        my $version = MM->parse_version($_);
        defined $version or $version = 'undef';
        $version =~ /\d/ and $version = "'$version'";

        # some heuristics to figure out the module name from the file name
        $module =~ s{^(lib|cpan|dist|(?:symbian/)?ext|os2/OS2)/}{}
			and $1 ne 'lib'
            and (
            $module =~ s{\b(\w+)/\1\b}{$1},
            $module =~ s{^B/O}{O},
            $module =~ s{^Devel-PPPort}{Devel},
            $module =~ s{^libnet/}{},
            $module =~ s{^PathTools/}{},
            $module =~ s{REXX/DLL}{DLL},
            $module =~ s{^Encode/encoding}{encoding},
            $module =~ s{^IPC-SysV/}{IPC/},
            $module =~ s{^MIME-Base64/QuotedPrint}{MIME/QuotedPrint},
            $module =~ s{^(?:DynaLoader|Errno|Opcode|XSLoader)/}{},
            $module =~ s{^Sys-Syslog/win32}{Sys-Syslog},
            $module =~ s{^Time-Piece/Seconds}{Time/Seconds},
            );
		$module =~ s{^lib/}{}g;
        $module =~ s{/}{::}g;
        $module =~ s{-}{::}g;
		$module =~ s{^.*::lib::}{}; # turns Foo/lib/Foo.pm into Foo.pm
        $module =~ s/(\.pm|_pm\.PL)$//;
        $lines{$module}          = $version;
        $module_to_file{$module} = $File::Find::name;
    },
    'os2/OS2',
    'symbian/ext',
    'lib',
    'ext',
	'cpan',
	'dist'
);

-e 'configpm' and $lines{Config} = "$]";

if ( open my $ucdv, "<", "lib/unicore/version" ) {
    chomp( my $ucd = <$ucdv> );
    $lines{Unicode} = "'$ucd'";
    close $ucdv;
}

my $delta_data = make_corelist_delta(
  $perl_vnum,
  \%lines,
  \%Module::CoreList::version
);

my $versions_in_release = "    " . $perl_vnum . " => {\n";
$versions_in_release .= "        delta_from => $delta_data->{delta_from},\n";
$versions_in_release .= "        changed => {\n";
foreach my $key (sort keys $delta_data->{changed}->%*) {
  $versions_in_release .= sprintf "            %-24s=> %s,\n", "'$key'",
      defined $delta_data->{changed}{$key} ? "'"
        . $delta_data->{changed}{$key} . "'" : "undef";
}
$versions_in_release .= "        },\n";
$versions_in_release .= "        removed => {\n";
for my $key (sort keys %{ $delta_data->{removed} || {} }) {
  $versions_in_release .= sprintf "            %-24s=> %s,\n", "'$key'", 1;
}
$versions_in_release .= "        }\n";
$versions_in_release .= "    },\n";

$corelist =~ s/^(%delta\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
$corelist =~ s/^(%delta\s*=\s*.*?)(^\);)$/$1$versions_in_release$2/ism;

exit unless %modlist;

# We have to go through this two stage lookup, given how Maintainers.pl keys its
# data by "Module", which is really a dist.
my $file_to_M = files_to_modules( values %module_to_file );

sub slurp_utf8($) {
    open my $fh, "<:utf8", "$_[0]"
	or die "can't open $_[0] for reading: $!";
    return do { local $/; <$fh> };
}

sub parse_cpan_meta($) {
    return Parse::CPAN::Meta->${
	$_[0] =~ /\A\x7b/ ? \"load_json_string" : \"load_yaml_string"
    }($_[0]);
}

my %module_to_upstream;
my %module_to_dist;
my %dist_to_meta_YAML;
my %module_to_deprecated;
while ( my ( $module, $file ) = each %module_to_file ) {
    my $M = $file_to_M->{$file};
    next unless $M;
    next if $Modules{$M}{MAINTAINER} && $Modules{$M}{MAINTAINER} eq 'P5P';
    $module_to_upstream{$module} = $Modules{$M}{UPSTREAM};
    $module_to_deprecated{$module} = 1 if $Modules{$M}{DEPRECATED};
    next
        if defined $module_to_upstream{$module}
            && $module_to_upstream{$module} eq 'blead';
    my $dist = $modlist{$module};
    unless ($dist) {
        warn "Can't find a distribution for $module\n";
        next;
    }
    $module_to_dist{$module} = $dist;

    next if exists $dist_to_meta_YAML{$dist};

    $dist_to_meta_YAML{$dist} = undef;

    # Like it or lump it, this has to be Unix format.
    my $meta_YAML_path = "authors/id/$dist";
    $meta_YAML_path =~ s/(?:tar\.gz|tar\.bz2|zip|tgz)$/meta/
	or die "ERROR: bad meta YAML path: '$meta_YAML_path'";
    my $meta_YAML_url = 'http://ftp.funet.fi/pub/CPAN/' . $meta_YAML_path;

    if ( -e "$cpan/$meta_YAML_path" ) {
        $dist_to_meta_YAML{$dist} = parse_cpan_meta(slurp_utf8( $cpan . "/" . $meta_YAML_path ));
    } elsif ( my $content = fetch_url($meta_YAML_url) ) {
        unless ($content) {
            warn "Failed to fetch $meta_YAML_url\n";
            next;
        }
        eval { $dist_to_meta_YAML{$dist} = parse_cpan_meta($content); };
        if ( my $err = $@@ ) {
            warn "$meta_YAML_path: ".$err;
            next;
        }
    } else {
        warn "$meta_YAML_path does not exist for $module\n";

        # I tried code to open the tarballs with Archive::Tar to find and
        # extract META.yml, but only Text-Tabs+Wrap-2006.1117.tar.gz had one,
        # so it's not worth including.
        next;
    }
}

my $upstream_stanza = "%upstream = (\n";
foreach my $module ( sort keys %module_to_upstream ) {
    my $upstream = defined $module_to_upstream{$module} ? "'$module_to_upstream{$module}'" : 'undef';
    $upstream_stanza .= sprintf "    %-24s=> %s,\n", "'$module'", $upstream;
}
$upstream_stanza .= ");";

$corelist =~ s/^%upstream .*? ;$/$upstream_stanza/ismx;

# Deprecation generation
{
  my $delta_data = make_corelist_delta(
    $perl_vnum,
    \%module_to_deprecated,
    do { no warnings 'once'; \%Module::CoreList::deprecated },
  );

  my $deprecated_stanza = "    " . $perl_vnum . " => {\n";
  $deprecated_stanza .= "        delta_from => $delta_data->{delta_from},\n";
  $deprecated_stanza .= "        changed => {\n";
  foreach my $key (sort keys $delta_data->{changed}->%*) {
    $deprecated_stanza .= sprintf "            %-24s=> %s,\n", "'$key'",
        defined $delta_data->{changed}{$key} ? "'"
          . $delta_data->{changed}{$key} . "'" : "undef";
  }
  $deprecated_stanza .= "        },\n";
  $deprecated_stanza .= "        removed => {\n";
  for my $key (sort keys %{ $delta_data->{removed} || {} }) {
    $deprecated_stanza .= sprintf "           %-24s=> %s,\n", "'$key'", 1;
  }
  $deprecated_stanza .= "        }\n";
  $deprecated_stanza .= "    },\n";

  $corelist =~ s/^(%deprecated\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
  $corelist =~ s/^(%deprecated\s*=\s*.*?)(^\);)$/$1$deprecated_stanza$2/xism;
}

my $tracker = "%bug_tracker = (\n";
foreach my $module ( sort keys %module_to_upstream ) {
    my $upstream = defined $module_to_upstream{$module};
    next
        if defined $upstream and $upstream eq 'blead';

    my $bug_tracker;

    my $dist = $module_to_dist{$module};
    $bug_tracker = $dist_to_meta_YAML{$dist}->{resources}{bugtracker}
        if $dist;
    $bug_tracker = $bug_tracker->{web} if ref($bug_tracker) eq "HASH";

    $bug_tracker = defined $bug_tracker ? quote($bug_tracker) : 'undef';
	next if $bug_tracker eq "'http://rt.perl.org/perlbug/'";
    $tracker .= sprintf "    %-24s=> %s,\n", "'$module'", $bug_tracker;
}
$tracker .= ");";

$corelist =~ s/^%bug_tracker .*? ;/$tracker/eismx;

write_corelist($corelist,$corelist_file);

open( my $utils_fh, '<', $utils_file );
my $utils = join( '', <$utils_fh> );
close $utils_fh;

my %utils = map { ( $_ => 1 ) } parse_utils_lst();

my $delta_utils = make_coreutils_delta($perl_vnum, \%utils);

my $utilities_in_release = "    " . $perl_vnum . " => {\n";
$utilities_in_release .= "        delta_from => $delta_utils->{delta_from},\n";
$utilities_in_release .= "        changed => {\n";
foreach my $key (sort keys $delta_utils->{changed}->%*) {
  $utilities_in_release .= sprintf "            %-24s=> %s,\n", "'$key'",
      defined $delta_utils->{changed}{$key} ? "'"
        . $delta_utils->{changed}{$key} . "'" : "undef";
}
$utilities_in_release .= "        },\n";
$utilities_in_release .= "        removed => {\n";
for my $key (sort keys %{ $delta_utils->{removed} || {} }) {
  $utilities_in_release .= sprintf "            %-24s=> %s,\n", "'$key'", 1;
}
$utilities_in_release .= "        }\n";
$utilities_in_release .= "    },\n";

$utils =~ s/^(my %delta\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
$utils =~ s/^(my %delta\s*=\s*.*?)(^\);)$/$1$utilities_in_release$2/ism;

write_corelist($utils,$utils_file);

warn "All done. Please check over the following files carefully before committing.\nThanks!\n";
warn "$corelist_file\n$utils_file\n";

sub write_corelist {
    my $content = shift;
    my $filename = shift;
    open (my $clfh, ">", $filename);
    binmode $clfh;
    print $clfh $content;
    close($clfh);
}

sub fetch_url {
    my $url = shift;
    my $http = HTTP::Tiny->new;
    my $response = $http->get($url);
    if ($response->{success}) {
	return $response->{content};
    } else {
	warn "Error fetching $url: $response->{status} $response->{reason}\n";
        return;
    }
}

sub make_corelist_delta {
  my($version, $lines, $existing) = @@_;
  # Trust core perl, if someone does use a weird version number the worst that
  # can happen is an extra delta entry for a module.
  my %versions = map { $_ => eval $lines->{$_} } keys %$lines;

  # Ensure we have the corelist data loaded from this perl checkout, not the system one.
  require $corelist_file;

  my %deltas;
  # Search for the release with the least amount of changes (this avoids having
  # to ask for where this perl was branched from).
  for my $previous (reverse sort { $a <=> $b } keys %$existing) {
    # Shouldn't happen, but ensure we don't load weird data...
    next if $previous > $version || $previous == $version;
    my $delta = $deltas{$previous} = {};
    ($delta->{changed}, $delta->{removed}) = calculate_delta(
      $existing->{$previous}, \%versions);
  }

  my $smallest = (sort {
      ((keys($deltas{$a}->{changed}->%*) + keys($deltas{$a}->{removed}->%*)) <=>
       (keys($deltas{$b}->{changed}->%*) + keys($deltas{$b}->{removed}->%*))) ||
      $b <=> $a
    } keys %deltas)[0];

  return {
    delta_from => $smallest,
    changed => $deltas{$smallest}{changed},
    removed => $deltas{$smallest}{removed},
  }
}

sub make_coreutils_delta {
  my($version, $lines) = @@_;
  # Trust core perl, if someone does use a weird version number the worst that
  # can happen is an extra delta entry for a module.
  my %utilities = map { $_ => eval $lines->{$_} } keys %$lines;

  # Ensure we have the corelist data loaded from this perl checkout, not the system one.
  require $utils_file;

  my %deltas;
  # Search for the release with the least amount of changes (this avoids having
  # to ask for where this perl was branched from).
  for my $previous (reverse sort { $a <=> $b } keys %Module::CoreList::Utils::utilities) {
    # Shouldn't happen, but ensure we don't load weird data...
    next if $previous > $version || $previous == $version;

    my $delta = $deltas{$previous} = {};
    ($delta->{changed}, $delta->{removed}) = calculate_delta(
      $Module::CoreList::Utils::utilities{$previous}, \%utilities);
  }

  my $smallest = (sort {
      ((keys($deltas{$a}->{changed}->%*) + keys($deltas{$a}->{removed}->%*)) <=>
       (keys($deltas{$b}->{changed}->%*) + keys($deltas{$b}->{removed}->%*))) ||
      $b <=> $a
    } keys %deltas)[0];

  return {
    delta_from => $smallest,
    changed => $deltas{$smallest}{changed},
    removed => $deltas{$smallest}{removed},
  }
}

# Calculate (changed, removed) modules between two versions.
sub calculate_delta {
  my($from, $to) = @@_;
  my(%changed, %removed);

  for my $package(keys %$from) {
    if(not exists $to->{$package}) {
      $removed{$package} = 1;
    }
  }

  for my $package(keys %$to) {
    if(!exists $from->{$package}
        || (defined $from->{$package} && !defined $to->{$package})
        || (!defined $from->{$package} && defined $to->{$package})
        || (defined $from->{$package} && defined $to->{$package}
            && $from->{$package} ne $to->{$package})) {
      $changed{$package} = $to->{$package};
    }
  }

  return \%changed, \%removed;
}

sub quote {
    my ($str) = @@_;
    # There's gotta be something already doing this properly that we could just
    # reuse, but I can't quite thing of where to look for it, so I'm gonna do
    # the simplest possible thing that'll allow me to release 5.17.7.  --rafl
    $str =~ s/'/\\'/g;
    "'${str}'";
}

sub parse_utils_lst {
  require File::Spec::Unix;
  my @@scripts;
  open my $fh, '<', 'utils.lst' or die "$!\n";
  while (<$fh>) {
    chomp;
    my ($file,$extra) = split m!#!;
    $file =~ s!\s+!!g;
    push @@scripts, $file;
    $extra =~ s!\s+!!g if $extra;
    if ( $extra and my ($link) = $extra =~ m!^link=(.+?)$! ) {
      push @@scripts, $link;
    }
  }
  return map { +( File::Spec::Unix->splitpath( $_ ) )[-1] } @@scripts;
}
@


1.1
log
@Initial revision
@
text
@d3 6
a8 1
# run this from the root of a clean perl tree
d10 1
d15 11
d28 117
a144 31
find(sub {
    /(\.pm|_pm\.PL)$/ or return;
    /PPPort\.pm$/ and return;
    my $module = $File::Find::name;
    $module =~ /\b(demo|t|private)\b/ and return; # demo or test modules
    my $version = MM->parse_version($_);
    defined $version or $version = 'undef';
    $version =~ /\d/ and $version = "'$version'";
    # some heuristics to figure out the module name from the file name
    $module =~ s{^(lib|(win32/|vms/|symbian/)?ext)/}{}
	and $1 ne 'lib'
	and ( $module =~ s{^(.*)/lib/\1\b}{$1},
	      $module =~ s{(\w+)/\1\b}{$1},
	      $module =~ s{^B/O}{O},
	      $module =~ s{^IO_Compress_Base/lib/}{},
	      $module =~ s{^IO_Compress_Zlib/(?:lib/)?}{},
	      $module =~ s{^Devel/PPPort}{Devel},
	      $module =~ s{^Encode/encoding}{encoding},
	      $module =~ s{^IPC/SysV/}{IPC/},
	      $module =~ s{^List/Util/lib/Scalar}{Scalar},
	      $module =~ s{^MIME/Base64/QuotedPrint}{MIME/QuotedPrint},
	      $module =~ s{^(?:DynaLoader|Errno|Opcode)/}{},
	    );
    $module =~ s{/}{::}g;
    $module =~ s/(\.pm|_pm\.PL)$//;
    $lines{sprintf "\t%-24s=> $version,\n", "'$module'"}++;
}, 'lib', 'ext', 'vms/ext', 'symbian/ext');

if (open my $ucdv, "<", "lib/unicore/version") {
    chomp (my $ucd = <$ucdv>);
    $lines{sprintf "\t%-24s=> '$ucd',\n", "'Unicode'"}++;
d146 322
d469 3
a471 3
print "    $] => {\n";
print sort keys %lines;
print "    },\n";
@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d3 1
a3 6
# run this from the root of a perl tree
#
# Data is on STDOUT.
#
# With an optional arg specifying the root of a CPAN mirror, outputs the
# %upstream and %bug_tracker hashes too.
a8 7
use version;
use lib "Porting";
use Maintainers qw(%Modules files_to_modules);
use File::Spec;
use Parse::CPAN::Meta;

my $corelist_file = 'lib/Module/CoreList.pm';
d11 31
a41 93
my %module_to_file;
my %modlist;

die "usage: $0 [ cpan-mirror/ ] [ 5.x.y] \n" unless @@ARGV <= 2;
my $cpan         = shift;
my $raw_version  = shift || $];
my $perl_version = version->parse("$raw_version");
my $perl_vnum    = $perl_version->numify;
my $perl_vstring = $perl_version->normal; # how do we get version.pm to not give us leading v?
$perl_vstring =~ s/^v//;

if ( !-f 'MANIFEST' ) {
    die "Must be run from the root of a clean perl tree\n";
}

open( my $corelist_fh, '<', $corelist_file ) || die "Could not open $corelist_file: $!";
my $corelist = join( '', <$corelist_fh> );

if ($cpan) {
    my $modlistfile = File::Spec->catfile( $cpan, 'modules', '02packages.details.txt' );
    my $content;

    my $fh;
    if ( -e $modlistfile ) {
        warn "Reading the module list from $modlistfile";
        open $fh, '<', $modlistfile or die "Couldn't open $modlistfile: $!";
    } elsif ( -e $modlistfile . ".gz" ) {
        warn "Reading the module list from $modlistfile.gz";
        open $fh, '-|', "gzcat $modlistfile.gz" or die "Couldn't zcat $modlistfile.gz: $!";
    } else {
        warn "About to fetch 02packages from ftp.funet.fi. This may take a few minutes\n";
        $content = fetch_url('http://ftp.funet.fi/pub/CPAN/modules/02packages.details.txt');
        unless ($content) {
            die "Unable to read 02packages.details.txt from either your CPAN mirror or ftp.funet.fi";
        }
    }

    if ( $fh and !$content ) {
        local $/ = "\n";
        $content = join( '', <$fh> );
    }

    die "Incompatible modlist format"
        unless $content =~ /^Columns: +package name, version, path/m;

    # Converting the file to a hash is about 5 times faster than a regexp flat
    # lookup.
    for ( split( qr/\n/, $content ) ) {
        next unless /^([A-Za-z_:0-9]+) +[-0-9.undefHASHVERSIONvsetwhenloadingbogus]+ +(\S+)/;
        $modlist{$1} = $2;
    }
}

find(
    sub {
        /(\.pm|_pm\.PL)$/ or return;
        /PPPort\.pm$/ and return;
        my $module = $File::Find::name;
        $module =~ /\b(demo|t|private)\b/ and return;    # demo or test modules
        my $version = MM->parse_version($_);
        defined $version or $version = 'undef';
        $version =~ /\d/ and $version = "'$version'";

        # some heuristics to figure out the module name from the file name
        $module =~ s{^(lib|(win32/|vms/|symbian/)?ext)/}{}
            and $1 ne 'lib'
            and (
            $module =~ s{\b(\w+)/\1\b}{$1},
            $module =~ s{^B/O}{O},
            $module =~ s{^Devel-PPPort}{Devel},
            $module =~ s{^Encode/encoding}{encoding},
            $module =~ s{^IPC-SysV/}{IPC/},
            $module =~ s{^MIME-Base64/QuotedPrint}{MIME/QuotedPrint},
            $module =~ s{^(?:DynaLoader|Errno|Opcode)/}{},
            );
        $module =~ s{/}{::}g;
        $module =~ s{-}{::}g;
        $module =~ s{^.*::lib::}{};
        $module =~ s/(\.pm|_pm\.PL)$//;
        $lines{$module}          = $version;
        $module_to_file{$module} = $File::Find::name;
    },
    'lib',
    'ext',
    'vms/ext',
    'symbian/ext'
);

-e 'configpm' and $lines{Config} = 'undef';

if ( open my $ucdv, "<", "lib/unicore/version" ) {
    chomp( my $ucd = <$ucdv> );
    $lines{Unicode} = "'$ucd'";
a42 133
}

my $versions_in_release = "    " . $perl_vnum . " => {\n";
foreach my $key ( sort keys %lines ) {
    $versions_in_release .= sprintf "\t%-24s=> %s,\n", "'$key'", $lines{$key};
}
$versions_in_release .= "    },\n";

$corelist =~ s/^(%version\s*=\s*.*?)(^\);)$/$1$versions_in_release$2/xism;

exit unless %modlist;

# We have to go through this two stage lookup, given how Maintainers.pl keys its
# data by "Module", which is really a dist.
my $file_to_M = files_to_modules( values %module_to_file );

my %module_to_upstream;
my %module_to_dist;
my %dist_to_meta_YAML;
while ( my ( $module, $file ) = each %module_to_file ) {
    my $M = $file_to_M->{$file};
    next unless $M;
    next if $Modules{$M}{MAINTAINER} eq 'p5p';
    $module_to_upstream{$module} = $Modules{$M}{UPSTREAM};
    next
        if defined $module_to_upstream{$module}
            && $module_to_upstream{$module} =~ /^(?:blead|first-come)$/;
    my $dist = $modlist{$module};
    unless ($dist) {
        warn "Can't find a distribution for $module\n";
        next;
    }
    $module_to_dist{$module} = $dist;

    next if exists $dist_to_meta_YAML{$dist};

    $dist_to_meta_YAML{$dist} = undef;

    # Like it or lump it, this has to be Unix format.
    my $meta_YAML_path = "authors/id/$dist";
    $meta_YAML_path =~ s/(?:tar\.gz|zip)$/meta/ or die "$meta_YAML_path";
    my $meta_YAML_url = 'http://ftp.funet.fi/pub/CPAN/' . $meta_YAML_path;

    if ( -e "$cpan/$meta_YAML_path" ) {
        $dist_to_meta_YAML{$dist} = Parse::CPAN::Meta::LoadFile( $cpan . "/" . $meta_YAML_path );
    } elsif ( my $content = fetch_url($meta_YAML_url) ) {
        unless ($content) {
            warn "Failed to fetch $meta_YAML_url\n";
            next;
        }
        eval { $dist_to_meta_YAML{$dist} = Parse::CPAN::Meta::Load($content); };
        if ( my $err = $@@ ) {
            warn "$meta_YAML_path: ".$err;
            next;
        }
    } else {
        warn "$meta_YAML_path does not exist for $module\n";

        # I tried code to open the tarballs with Archive::Tar to find and
        # extract META.yml, but only Text-Tabs+Wrap-2006.1117.tar.gz had one,
        # so it's not worth including.
        next;
    }
}

my $upstream_stanza = "%upstream = (\n";
foreach my $module ( sort keys %module_to_upstream ) {
    my $upstream = defined $module_to_upstream{$module} ? "'$module_to_upstream{$module}'" : 'undef';
    $upstream_stanza .= sprintf "    %-24s=> %s,\n", "'$module'", $upstream;
}
$upstream_stanza .= ");";

$corelist =~ s/^%upstream .*? ;$/$upstream_stanza/ismx;

my $tracker = "%bug_tracker = (\n";
foreach my $module ( sort keys %module_to_upstream ) {
    my $upstream = defined $module_to_upstream{$module};
    next
        if defined $upstream
            and $upstream eq 'blead' || $upstream eq 'first-come';

    my $bug_tracker;

    my $dist = $module_to_dist{$module};
    $bug_tracker = $dist_to_meta_YAML{$dist}->{resources}{bugtracker}
        if $dist;

    $bug_tracker = defined $bug_tracker ? "'$bug_tracker'" : 'undef';
    next if $bug_tracker eq "'http://rt.perl.org/perlbug/'";
    $tracker .= sprintf "    %-24s=> %s,\n", "'$module'", $bug_tracker;
}
$tracker .= ");";

$corelist =~ s/^%bug_tracker .*? ;/$tracker/eismx;

unless ( $corelist =~ /and $perl_vstring releases of perl/ ) {
    warn "Adding $perl_vstring to the list of perl versions covered by Module::CoreList\n";
    $corelist =~ s/\s*and (.*?) releases of perl/, $1 and $perl_vstring releases of perl/ism;
}

unless (
    $corelist =~ /^%released \s* = \s* \( 
        .*? 
        $perl_vnum => .*? 
        \);/ismx
    )
{
    warn "Adding $perl_vnum to the list of released perl versions. Please consider adding a release date.\n";
    $corelist =~ s/^(%released \s* = \s* .*?) ( \) )
                /$1 $perl_vnum => '????-??-??',\n  $2/ismx;
}

write_corelist($corelist);

warn "All done. Please check over lib/Module/CoreList.pm carefully before committing. Thanks!\n";


sub write_corelist {
    my $content = shift;
    open ( my $clfh, ">", "lib/Module/CoreList.pm") || die "Failed to open lib/Module/CoreList.pm for writing: $!";
    print $clfh $content || die "Failed to write the new CoreList.pm: $!";
    close($clfh);
}

sub fetch_url {
    my $url = shift;
    eval { require LWP::Simple };
    if ( LWP::Simple->can('get') ) {
        return LWP::Simple->get($url);
    } elsif (`which curl`) {
        return `curl -s $url`;
    } elsif (`which wget`) {
        return `wget -q -O - $url`;
d44 3
a46 1
}
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@a18 1
use IPC::Cmd 'can_run';
d20 1
a20 1
my $corelist_file = 'dist/Module-CoreList/lib/Module/CoreList.pm';
a49 1
        my $zcat = can_run('gzcat') || can_run('zcat') or die "Can't find gzcat or zcat";
d51 1
a51 1
        open $fh, '-|', "$zcat $modlistfile.gz" or die "Couldn't zcat $modlistfile.gz: $!";
d87 2
a88 2
        $module =~ s{^(lib|cpan|dist|(?:vms/|symbian/)?ext)/}{}
			and $1 ne 'lib'
a92 1
            $module =~ s{^libnet/}{},
a97 1
		$module =~ s{^lib/}{}g;
d100 1
a100 1
		$module =~ s{^.*::lib::}{}; # turns Foo/lib/Foo.pm into Foo.pm
a104 2
    'vms/ext',
    'symbian/ext',
d107 2
a108 2
	'cpan',
	'dist'
a135 1
my %module_to_deprecated;
a140 1
    $module_to_deprecated{$module} = 1 if $Modules{$M}{DEPRECATED};
d157 1
a157 1
    $meta_YAML_path =~ s/(?:tar\.gz|tar\.bz2|zip)$/meta/ or die "$meta_YAML_path";
a190 9
# Deprecation generation
my $deprecated_stanza = "    " . $perl_vnum . " => {\n";
foreach my $module ( sort keys %module_to_deprecated ) {
    my $deprecated = defined $module_to_deprecated{$module} ? "'$module_to_deprecated{$module}'" : 'undef';
    $deprecated_stanza .= sprintf "\t%-24s=> %s,\n", "'$module'", $deprecated;
}
$deprecated_stanza .= "    },\n";
$corelist =~ s/^(%deprecated\s*=\s*.*?)(^\);)$/$1$deprecated_stanza$2/xism;

d205 1
a205 1
	next if $bug_tracker eq "'http://rt.perl.org/perlbug/'";
d226 1
a226 1
                /$1  $perl_vnum => '????-??-??',\n  $2/ismx;
d231 1
a231 1
warn "All done. Please check over $corelist_file carefully before committing. Thanks!\n";
d236 1
a236 1
    open (my $clfh, ">", $corelist_file) || die "Failed to open $corelist_file for writing: $!";
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a9 1
use autodie;
a19 2
use HTTP::Tiny;
use IO::Uncompress::Gunzip;
a21 1
my $pod_file = 'dist/Module-CoreList/lib/Module/CoreList.pod';
d39 1
a39 1
open( my $corelist_fh, '<', $corelist_file );
d49 1
a49 1
        open $fh, '<', $modlistfile;
d53 1
a53 1
        open $fh, '-|', "$zcat $modlistfile.gz";
d56 2
a57 2
	my $gzipped_content = fetch_url('http://ftp.funet.fi/pub/CPAN/modules/02packages.details.txt.gz');
	unless ($gzipped_content) {
a59 2
	IO::Uncompress::Gunzip::gunzip(\$gzipped_content, \$content, Transparent => 0)
	    or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
d89 1
a89 1
        $module =~ s{^(lib|cpan|dist|(?:symbian/)?ext)/}{}
d99 1
a99 3
            $module =~ s{^(?:DynaLoader|Errno|Opcode|XSLoader)/}{},
            $module =~ s{^Sys-Syslog/win32}{Sys-Syslog},
            $module =~ s{^Time-Piece/Seconds}{Time/Seconds},
a100 1
        $module =~ s{^vms/ext}{VMS};
d146 1
a146 1
    next if $Modules{$M}{MAINTAINER} && $Modules{$M}{MAINTAINER} eq 'p5p';
d165 1
a165 1
    $meta_YAML_path =~ s/(?:tar\.gz|tar\.bz2|zip|tgz)$/meta/ or die "$meta_YAML_path";
d229 5
d235 3
a237 3
    $corelist =~ /^%released \s* = \s* \(
        .*?
        $perl_vnum => .*?
d246 1
a246 11
write_corelist($corelist,$corelist_file);

open( my $pod_fh, '<', $pod_file );
my $pod = join( '', <$pod_fh> );

unless ( $pod =~ /and $perl_vstring releases of perl/ ) {
    warn "Adding $perl_vstring to the list of perl versions covered by Module::CoreList\n";
    $pod =~ s/(currently covers (?:.*?))\s*and (.*?) releases of perl/$1, $2 and $perl_vstring releases of perl/ism;
}

write_corelist($pod,$pod_file);
d248 1
a248 1
warn "All done. Please check over $corelist_file and $pod_file carefully before committing. Thanks!\n";
d253 2
a254 3
    my $filename = shift;
    open (my $clfh, ">", $filename);
    print $clfh $content;
d260 7
a266 7
    my $http = HTTP::Tiny->new;
    my $response = $http->get($url);
    if ($response->{success}) {
	return $response->{content};
    } else {
	warn "Error fetching $url: $response->{status} $response->{reason}\n";
        return;
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d109 1
d118 1
a133 6
my $delta_data = make_corelist_delta(
  $perl_vnum,
  \%lines,
  \%Module::CoreList::version
);

d135 2
a136 11
$versions_in_release .= "        delta_from => $delta_data->{delta_from},\n";
$versions_in_release .= "        changed => {\n";
foreach my $key (sort keys $delta_data->{changed}) {
  $versions_in_release .= sprintf "            %-24s=> %s,\n", "'$key'",
      defined $delta_data->{changed}{$key} ? "'"
        . $delta_data->{changed}{$key} . "'" : "undef";
}
$versions_in_release .= "        },\n";
$versions_in_release .= "        removed => {\n";
for my $key (sort keys($delta_data->{removed} || {})) {
  $versions_in_release .= sprintf "           %-24s=> %s,\n", "'$key'", 1;
a137 1
$versions_in_release .= "        }\n";
d140 1
a140 1
$corelist =~ s/^(my %delta\s*=\s*.*?)(^\);)$/$1$versions_in_release$2/ism;
a147 12
sub slurp_utf8($) {
    open my $fh, "<:utf8", "$_[0]"
	or die "can't open $_[0] for reading: $!";
    return do { local $/; <$fh> };
}

sub parse_cpan_meta($) {
    return Parse::CPAN::Meta->${
	$_[0] =~ /\A\x7b/ ? \"load_json_string" : \"load_yaml_string"
    }($_[0]);
}

d174 1
a174 2
    $meta_YAML_path =~ s/(?:tar\.gz|tar\.bz2|zip|tgz)$/meta/
	or die "ERROR: bad meta YAML path: '$meta_YAML_path'";
d178 1
a178 1
        $dist_to_meta_YAML{$dist} = parse_cpan_meta(slurp_utf8( $cpan . "/" . $meta_YAML_path ));
d184 1
a184 1
        eval { $dist_to_meta_YAML{$dist} = parse_cpan_meta($content); };
d209 4
a212 24
{
  my $delta_data = make_corelist_delta(
    $perl_vnum,
    \%module_to_deprecated,
    do { no warnings 'once'; \%Module::CoreList::deprecated },
  );

  my $deprecated_stanza = "    " . $perl_vnum . " => {\n";
  $deprecated_stanza .= "        delta_from => $delta_data->{delta_from},\n";
  $deprecated_stanza .= "        changed => {\n";
  foreach my $key (sort keys $delta_data->{changed}) {
    $deprecated_stanza .= sprintf "            %-24s=> %s,\n", "'$key'",
        defined $delta_data->{changed}{$key} ? "'"
          . $delta_data->{changed}{$key} . "'" : "undef";
  }
  $deprecated_stanza .= "        },\n";
  $deprecated_stanza .= "        removed => {\n";
  for my $key (sort keys($delta_data->{removed} || {})) {
    $deprecated_stanza .= sprintf "           %-24s=> %s,\n", "'$key'", 1;
  }
  $deprecated_stanza .= "        }\n";
  $deprecated_stanza .= "    },\n";

  $corelist =~ s/^(%deprecated\s*=\s*.*?)(^\);)$/$1$deprecated_stanza$2/xism;
d214 2
a228 1
    $bug_tracker = $bug_tracker->{web} if ref($bug_tracker) eq "HASH";
d230 1
a230 1
    $bug_tracker = defined $bug_tracker ? quote($bug_tracker) : 'undef';
d257 1
a257 1
    $pod =~ s/(currently\s+covers\s+(?:.*?))\s*and\s+(.*?)\s+releases\s+of\s+perl/$1, $2 and $perl_vstring releases of perl/ism;
a268 1
    binmode $clfh;
a282 66
}

sub make_corelist_delta {
  my($version, $lines, $existing) = @@_;
  # Trust core perl, if someone does use a weird version number the worst that
  # can happen is an extra delta entry for a module.
  my %versions = map { $_ => eval $lines->{$_} } keys %$lines;

  # Ensure we have the corelist data loaded from this perl checkout, not the system one.
  require $corelist_file;

  my %deltas;
  # Search for the release with the least amount of changes (this avoids having
  # to ask for where this perl was branched from).
  for my $previous(reverse sort keys %$existing) {
    # Shouldn't happen, but ensure we don't load weird data...
    next if $previous > $version || $previous == $version && $previous eq $version;

    my $delta = $deltas{$previous} = {};
    ($delta->{changed}, $delta->{removed}) = calculate_delta(
      $existing->{$previous}, \%versions);
  }

  my $smallest = (sort {
      (keys($deltas{$a}->{changed}) + keys($deltas{$a}->{removed})) <=>
      (keys($deltas{$b}->{changed})+ keys($deltas{$b}->{removed}))
    } keys %deltas)[0];

  return {
    delta_from => $smallest,
    changed => $deltas{$smallest}{changed},
    removed => $deltas{$smallest}{removed},
  }
}

# Calculate (changed, removed) modules between two versions.
sub calculate_delta {
  my($from, $to) = @@_;
  my(%changed, %removed);

  for my $package(keys $from) {
    if(not exists $to->{$package}) {
      $removed{$package} = 1;
    }
  }

  for my $package(keys $to) {
    if(!exists $from->{$package}
        || (defined $from->{$package} && !defined $to->{$package})
        || (!defined $from->{$package} && defined $to->{$package})
        || (defined $from->{$package} && defined $to->{$package}
            && $from->{$package} ne $to->{$package})) {
      $changed{$package} = $to->{$package};
    }
  }

  return \%changed, \%removed;
}

sub quote {
    my ($str) = @@_;
    # There's gotta be something already doing this properly that we could just
    # reuse, but I can't quite thing of where to look for it, so I'm gonna do
    # the simplest possible thing that'll allow me to release 5.17.7.  --rafl
    $str =~ s/'/\\'/g;
    "'${str}'";
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@a12 1
no  warnings 'experimental::autoderef';
a24 1
my $utils_file = 'dist/Module-CoreList/lib/Module/CoreList/Utils.pm';
a44 13
close $corelist_fh;

unless (
    $corelist =~ /^%released \s* = \s* \(
        .*?
        $perl_vnum \s* => \s* .*?
        \);/ismx
    )
{
    warn "Adding $perl_vnum to the list of released perl versions. Please consider adding a release date.\n";
    $corelist =~ s/^(%released \s* = \s* .*?) ( \) )
                /$1  $perl_vnum => '????-??-??',\n  $2/ismx;
}
d95 1
a95 1
        $module =~ s{^(lib|cpan|dist|(?:symbian/)?ext|os2/OS2)/}{}
a101 2
            $module =~ s{^PathTools/}{},
            $module =~ s{REXX/DLL}{DLL},
a116 1
    'os2/OS2',
d124 1
a124 1
-e 'configpm' and $lines{Config} = "$]";
d149 1
a149 1
  $versions_in_release .= sprintf "            %-24s=> %s,\n", "'$key'", 1;
d154 1
a154 2
$corelist =~ s/^(%delta\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
$corelist =~ s/^(%delta\s*=\s*.*?)(^\);)$/$1$versions_in_release$2/ism;
d181 1
a181 1
    next if $Modules{$M}{MAINTAINER} && $Modules{$M}{MAINTAINER} eq 'P5P';
d186 1
a186 1
            && $module_to_upstream{$module} eq 'blead';
a258 1
  $corelist =~ s/^(%deprecated\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
d266 2
a267 1
        if defined $upstream and $upstream eq 'blead';
d284 12
d308 1
a308 28
open( my $utils_fh, '<', $utils_file );
my $utils = join( '', <$utils_fh> );
close $utils_fh;

my %utils = map { ( $_ => 1 ) } parse_utils_lst();

my $delta_utils = make_coreutils_delta($perl_vnum, \%utils);

my $utilities_in_release = "    " . $perl_vnum . " => {\n";
$utilities_in_release .= "        delta_from => $delta_utils->{delta_from},\n";
$utilities_in_release .= "        changed => {\n";
foreach my $key (sort keys $delta_utils->{changed}) {
  $utilities_in_release .= sprintf "            %-24s=> %s,\n", "'$key'",
      defined $delta_utils->{changed}{$key} ? "'"
        . $delta_utils->{changed}{$key} . "'" : "undef";
}
$utilities_in_release .= "        },\n";
$utilities_in_release .= "        removed => {\n";
for my $key (sort keys($delta_utils->{removed} || {})) {
  $utilities_in_release .= sprintf "            %-24s=> %s,\n", "'$key'", 1;
}
$utilities_in_release .= "        }\n";
$utilities_in_release .= "    },\n";

$utils =~ s/^(my %delta\s*=\s*.*?)^\s*$perl_vnum\s*=>\s*{.*?},\s*(^\);)$/$1$2/ism;
$utils =~ s/^(my %delta\s*=\s*.*?)(^\);)$/$1$utilities_in_release$2/ism;

write_corelist($utils,$utils_file);
a309 2
warn "All done. Please check over the following files carefully before committing.\nThanks!\n";
warn "$corelist_file\n$pod_file\n$utils_file\n";
d344 1
a344 1
  for my $previous (reverse sort keys %$existing) {
d354 2
a355 37
      ((keys($deltas{$a}->{changed}) + keys($deltas{$a}->{removed})) <=>
       (keys($deltas{$b}->{changed}) + keys($deltas{$b}->{removed}))) ||
      $b <=> $a
    } keys %deltas)[0];

  return {
    delta_from => $smallest,
    changed => $deltas{$smallest}{changed},
    removed => $deltas{$smallest}{removed},
  }
}

sub make_coreutils_delta {
  my($version, $lines) = @@_;
  # Trust core perl, if someone does use a weird version number the worst that
  # can happen is an extra delta entry for a module.
  my %utilities = map { $_ => eval $lines->{$_} } keys %$lines;

  # Ensure we have the corelist data loaded from this perl checkout, not the system one.
  require $utils_file;

  my %deltas;
  # Search for the release with the least amount of changes (this avoids having
  # to ask for where this perl was branched from).
  for my $previous (reverse sort keys %Module::CoreList::Utils::utilities) {
    # Shouldn't happen, but ensure we don't load weird data...
    next if $previous > $version || $previous == $version && $previous eq $version;

    my $delta = $deltas{$previous} = {};
    ($delta->{changed}, $delta->{removed}) = calculate_delta(
      $Module::CoreList::Utils::utilities{$previous}, \%utilities);
  }

  my $smallest = (sort {
      ((keys($deltas{$a}->{changed}) + keys($deltas{$a}->{removed})) <=>
       (keys($deltas{$b}->{changed}) + keys($deltas{$b}->{removed}))) ||
      $b <=> $a
a395 17
}

sub parse_utils_lst {
  require File::Spec::Unix;
  my @@scripts;
  open my $fh, '<', 'utils.lst' or die "$!\n";
  while (<$fh>) {
    chomp;
    my ($file,$extra) = split m!#!;
    $file =~ s!\s+!!g;
    push @@scripts, $file;
    $extra =~ s!\s+!!g if $extra;
    if ( $extra and my ($link) = $extra =~ m!^link=(.+?)$! ) {
      push @@scripts, $link;
    }
  }
  return map { +( File::Spec::Unix->splitpath( $_ ) )[-1] } @@scripts;
@


1.1.1.7
log
@Import perl-5.20.2
@
text
@d27 1
d305 10
d345 1
a345 1
warn "$corelist_file\n$utils_file\n";
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@d13 1
d158 1
a158 1
foreach my $key (sort keys $delta_data->{changed}->%*) {
d165 1
a165 1
for my $key (sort keys %{ $delta_data->{removed} || {} }) {
d264 1
a264 1
  foreach my $key (sort keys $delta_data->{changed}->%*) {
d271 1
a271 1
  for my $key (sort keys %{ $delta_data->{removed} || {} }) {
d315 1
a315 1
foreach my $key (sort keys $delta_utils->{changed}->%*) {
d322 1
a322 1
for my $key (sort keys %{ $delta_utils->{removed} || {} }) {
d369 1
a369 1
  for my $previous (reverse sort { $a <=> $b } keys %$existing) {
d371 2
a372 1
    next if $previous > $version || $previous == $version;
d379 2
a380 2
      ((keys($deltas{$a}->{changed}->%*) + keys($deltas{$a}->{removed}->%*)) <=>
       (keys($deltas{$b}->{changed}->%*) + keys($deltas{$b}->{removed}->%*))) ||
d403 1
a403 1
  for my $previous (reverse sort { $a <=> $b } keys %Module::CoreList::Utils::utilities) {
d405 1
a405 1
    next if $previous > $version || $previous == $version;
d413 2
a414 2
      ((keys($deltas{$a}->{changed}->%*) + keys($deltas{$a}->{removed}->%*)) <=>
       (keys($deltas{$b}->{changed}->%*) + keys($deltas{$b}->{removed}->%*))) ||
d430 1
a430 1
  for my $package(keys %$from) {
d436 1
a436 1
  for my $package(keys %$to) {
@


