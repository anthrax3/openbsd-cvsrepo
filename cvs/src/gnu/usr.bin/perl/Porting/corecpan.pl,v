head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.6.0.14
	OPENBSD_6_1_BASE:1.1.1.6
	OPENBSD_6_0:1.1.1.6.0.16
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.10
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.12
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.4
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.8
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.6
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.4
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.2
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2004.08.09.17.47.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2004.08.09.17.47.53;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.49.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.20;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.29;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!perl
# Reports, in a perl source tree, which dual-lived core modules have not the
# same version than the corresponding module on CPAN.

use 5.9.0;
use strict;
use Getopt::Std;
use ExtUtils::MM_Unix;
use lib 'Porting';
use Maintainers qw(get_module_files %Modules);

our $packagefile = '02packages.details.txt';

sub usage () {
    die <<USAGE;
$0 - report which core modules are outdated.
To be run at the root of a perl source tree.
Options :
-h : help
-v : verbose (print all versions of all files, not only those which differ)
-f : force download of $packagefile from CPAN
     (it's expected to be found in the current directory)
USAGE
}

sub get_package_details () {
    my $url = 'http://www.cpan.org/modules/02packages.details.txt.gz';
    unlink $packagefile;
    system("wget $url && gunzip $packagefile.gz") == 0
	or die "Failed to get package details\n";
}

getopts('fhv');
our $opt_h and usage;
our $opt_f or !-f $packagefile and get_package_details;

# Load the package details. All of them.
my %cpanversions;
open my $fh, $packagefile or die $!;
while (<$fh>) {
    my ($p, $v) = split ' ';
    $cpanversions{$p} = $v;
}
close $fh;

for my $dist (sort keys %Modules) {
    next unless $Modules{$dist}{CPAN};
    print "Module $dist...\n";
    for my $file (get_module_files($dist)) {
	next if $file !~ /\.pm\z/ or $file =~ m{^t/};
	my $vcore = MM->parse_version($file) // 'undef';
	my $module = $file;
	$module =~ s/\.pm\z//;
	# some heuristics to figure out the module name from the file name
	$module =~ s{^(lib|ext)/}{}
	    and $1 eq 'ext'
	    and ( $module =~ s{^(.*)/lib/\1\b}{$1},
		  $module =~ s{(\w+)/\1\b}{$1},
		  $module =~ s{^Encode/encoding}{encoding},
		  $module =~ s{^MIME/Base64/QuotedPrint}{MIME/QuotedPrint},
		  $module =~ s{^List/Util/lib/Scalar}{Scalar},
	        );
	$module =~ s{/}{::}g;
	my $vcpan = $cpanversions{$module} // 'not found';
	if (our $opt_v or $vcore ne $vcpan) {
	    print "    $file: core=$vcore, cpan=$vcpan\n";
	}
    }
}
@


1.1.1.1
log
@Import of stock perl 5.8.5
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d50 1
a50 1
	next if $file !~ /\.pm\z/ or $file =~ m{^t/} or $file =~ m{/t/};
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d35 1
a35 1
our $opt_f || !-f $packagefile and get_package_details;
@


1.1.1.4
log
@import perl 5.10.1
@
text
@a3 1
# with -t option, can compare multiple source trees in tabular form.
d10 1
a10 4
use Maintainers qw(get_module_files reload_manifest %Modules);
use Cwd;

use List::Util qw(max);
d16 1
a16 4
$0
$0 -t home1[:label] home2[:label] ...

Report which core modules are outdated.
a17 1

a22 1
-t : display in tabular form CPAN vs one or more perl source trees
d33 1
a33 1
getopts('fhvt');
a34 13
our $opt_t;

my @@sources = @@ARGV ? @@ARGV : '.';
die "Too many directories speficied without -t option\n"
    if @@sources != 1 and ! $opt_t;

@@sources = map {
		# handle /home/user/perl:bleed style labels
		my ($dir,$label) = split /:/;
		$label = $dir unless defined $label;
		[ $dir, $label ];
	    } @@sources;

a41 1
    next if 1../^\s*$/; # skip header
d46 21
a66 95
my %results;

# scan source tree(s) and CPAN module list, and put results in %results

foreach my $source (@@sources) {
    my ($srcdir, $label) = @@$source;
    my $olddir = getcwd();
    chdir $srcdir or die "chdir $srcdir: $!\n";

    # load the MANIFEST file in the new directory
    reload_manifest;

    for my $dist (sort keys %Modules) {
	next unless $Modules{$dist}{CPAN};
	for my $file (get_module_files($dist)) {
	    next if $file !~ /(\.pm|_pm.PL)\z/
			or $file =~ m{^t/} or $file =~ m{/t/};
	    my $vcore = '!EXIST';
	    $vcore = MM->parse_version($file) // 'undef' if -f $file;

	    # get module name from filename to lookup CPAN version
	    my $module = $file;
	    $module =~ s/\_pm.PL\z//;
	    $module =~ s/\.pm\z//;
	    # some heuristics to figure out the module name from the file name
	    $module =~ s{^(lib|ext)/}{}
		and $1 eq 'ext'
		and (
		      # ext/Foo-Bar/Bar.pm
		      $module =~ s{^(\w+)-(\w+)/\2$}{$1/lib/$1/$2},
		      # ext/Encode/Foo/Foo.pm
		      $module =~ s{^(Encode)/(\w+)/\2$}{$1/lib/$1/$2},
		      $module =~ s{^[^/]+/}{},
		      $module =~ s{^lib/}{},
		    );
	    $module =~ s{/}{::}g;
	    my $vcpan = $cpanversions{$module} // 'undef';
	    $results{$dist}{$file}{$label} = $vcore;
	    $results{$dist}{$file}{CPAN} = $vcpan;
	}
    }

    chdir $olddir or die "chdir $olddir: $!\n";
}

# output %results in the requested format

my @@labels = ((map $_->[1], @@sources), 'CPAN' );

if ($opt_t) {
    my %changed;
    my @@fields;
    for my $dist (sort { lc $a cmp lc $b } keys %results) {
	for my $file (sort keys %{$results{$dist}}) {
	    my @@versions = @@{$results{$dist}{$file}}{@@labels};
	    for (0..$#versions) {
		$fields[$_] = max($fields[$_],
				  length $versions[$_],
				  length $labels[$_],
				  length '!EXIST'
				);
	    }
	    if (our $opt_v or grep $_ ne $versions[0], @@versions) {
		$changed{$dist} = 1;
	    }
	}
    }
    printf "%*s ", $fields[$_], $labels[$_] for 0..$#labels;
    print "\n";
    printf "%*s ", $fields[$_], '-' x length $labels[$_] for 0..$#labels;
    print "\n";

    my $field_total;
    $field_total += $_ + 1 for @@fields;

    for my $dist (sort { lc $a cmp lc $b } keys %results) {
	next unless $changed{$dist};
	print " " x $field_total, " $dist\n";
	for my $file (sort keys %{$results{$dist}}) {
	    my @@versions = @@{$results{$dist}{$file}}{@@labels};
	    for (0..$#versions) {
		printf "%*s ", $fields[$_], $versions[$_]//'!EXIST'
	    }
	    print "    $file\n";
	}
    }
}
else {
    for my $dist (sort { lc $a cmp lc $b } keys %results) {
	print "Module $dist...\n";
	for my $file (sort keys %{$results{$dist}}) {
	    my ($vcore, $vcpan) = @@{$results{$dist}{$file}}{@@labels};
	    if (our $opt_v or $vcore ne $vcpan) {
		print "    $file: core=$vcore, cpan=$vcpan\n";
	    }
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d94 2
a95 2
	    $module =~ s{^(lib|ext|dist|cpan)/}{}
		and $1 =~ /(?:ext|dist|cpan)/
d158 1
a158 1
	my $distname_printed = 0;
d162 1
a162 2
		print "\n$dist:\n" unless ($distname_printed++);
		print "\t$file: core=$vcore, cpan=$vcpan\n";
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d47 1
a47 1
die "Too many directories specified without -t option\n"
d162 1
a162 1
		print "\n$dist ($Modules{$dist}{MAINTAINER}):\n" unless ($distname_printed++);
@


