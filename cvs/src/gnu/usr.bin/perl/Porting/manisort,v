head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.12
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.6
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.8
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.20
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.16
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.14
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.12
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.10
	OPENBSD_5_0:1.1.1.1.0.8
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl

# Usage:  manisort [-q] [-o outfile] [filename]
#
# Without 'filename', looks for MANIFEST in the current dir.
# With '-o outfile', writes the sorted MANIFEST to the specified file.
# Prints the result of the sort to stderr.  '-q' silences this.
# The exit code for the script is the sort result status
# (i.e., 0 means already sorted properly, 1 means not properly sorted)

use strict;
use warnings;
$| = 1;

# Get command line options
use Getopt::Long;
my $outfile;
my $check_only = 0;
my $quiet = 0;
GetOptions ('output=s' => \$outfile,
            'check'    => \$check_only,
            'quiet'    => \$quiet);

my $file = (@@ARGV) ? shift : 'MANIFEST';

# Read in the MANIFEST file
open(my $IN, '<', $file)
    or die("Can't read '$file': $!");
my @@manifest = <$IN>;
close($IN) or die($!);
chomp(@@manifest);

# Sort by dictionary order (ignore-case and
#   consider whitespace and alphanumeric only)
my @@sorted = sort {
                      (my $aa = $a) =~ s/[^\s\da-zA-Z]//g;
                      (my $bb = $b) =~ s/[^\s\da-zA-Z]//g;
                      uc($aa) cmp uc($bb)
                  } @@manifest;

# Check if the file is sorted or not
my $exit_code = 0;
for (my $ii = 0; $ii < $#manifest; $ii++) {
    next if ($manifest[$ii] eq $sorted[$ii]);
    $exit_code = 1;   # Not sorted
    last;
}

# Output sorted file
if (defined($outfile)) {
    open(my $OUT, '>', $outfile)
        or die("Can't open output file '$outfile': $!");
    print($OUT join("\n", @@sorted), "\n");
    close($OUT) or die($!);
}

# Report on sort results
printf(STDERR "'$file' is%s sorted properly\n",
            (($exit_code) ? ' NOT' : '')) if (! $quiet);

# Exit with the sort results status
exit($exit_code);

# EOF
@


1.1.1.1
log
@import perl 5.10.1
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a52 1
    binmode($OUT);
@

