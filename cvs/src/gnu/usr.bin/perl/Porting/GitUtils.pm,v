head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.2.0.8
	OPENBSD_6_2_BASE:1.1.1.2
	PERL_5_24_2:1.1.1.2
	OPENBSD_6_1:1.1.1.2.0.12
	OPENBSD_6_1_BASE:1.1.1.2
	OPENBSD_6_0:1.1.1.2.0.10
	OPENBSD_6_0_BASE:1.1.1.2
	OPENBSD_5_9:1.1.1.2.0.4
	OPENBSD_5_9_BASE:1.1.1.2
	OPENBSD_5_8:1.1.1.2.0.6
	OPENBSD_5_8_BASE:1.1.1.2
	PERL_5_20_2:1.1.1.2
	OPENBSD_5_7:1.1.1.2.0.2
	OPENBSD_5_7_BASE:1.1.1.2
	PERL_5_20_1:1.1.1.2
	OPENBSD_5_6:1.1.1.1.0.22
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.20
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.16
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.14
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.12
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.10
	OPENBSD_5_0:1.1.1.1.0.8
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(strftime);

use base qw/Exporter/;
our @@EXPORT_OK=qw(iso_time_with_dot gen_dot_patch);

sub iso_time_with_dot {
    strftime "%Y-%m-%d.%H:%M:%S",gmtime(shift||time)
}

# generate the contents of a .patch file for an arbitrary commitish, or for HEAD if none is supplied
# assumes the CWD is inside of a perl git repository. If the repository is bare then refs/heads/*
# is used to determine the branch. If the repository is not bare then refs/remotes/origin/* is used
# to determine the branch. (The assumption being that if its bare then this is running inside of
# the master git repo - if its not bare then it is a checkout which may not have all the branches)
sub gen_dot_patch {
    my $target= shift || 'HEAD';
    chomp(my ($git_dir, $is_bare, $sha1)=`git rev-parse --git-dir --is-bare-repository $target`);
    die "Not in a git repository!" if !$git_dir;
    $is_bare= "" if $is_bare and $is_bare eq 'false';

    # which branches to scan - the order here is important, the first hit we find we use
    # so if two branches can both reach a ref we want the right one first.
    my @@branches=(
              'blead',
              'maint-5.10',
              'maint-5.8',
              'maint-5.8-dor',
              'maint-5.6',
              'maint-5.005',
              'maint-5.004',
              # and more generalized searches...
              'refs/heads/*',
              'refs/remotes/*',
              'refs/*',
    );
    my $reftype= $is_bare ? "heads" : "remotes/origin";
    my $branch;
    foreach my $name (@@branches) {
        my $refs= $name=~m!^refs/! ? $name : "refs/$reftype/$name";
        my $cmd= "git name-rev --name-only --refs=$refs $sha1";
        chomp($branch= `$cmd`);
        last if $branch ne 'undefined';
    }
    for ($branch) {
        $_  ||= "error";            # hmm, we didnt get /anything/ from name-rev?
        s!^\Q$reftype\E/!! ||       # strip off the reftype
        s!^refs/heads/!!   ||       # possible other places it was found
        s!^refs/remotes/!! ||       # ...
        s!^refs/!!;                 # might even be a tag or something weirdo...
        s![~^].*\z!!;               # strip off how far we are from the item
    }
    my $tstamp= iso_time_with_dot(`git log -1 --pretty="format:%ct" $sha1`);
    chomp(my $describe= `git describe $sha1`);
    join(" ", $branch, $tstamp, $sha1, $describe);
}

1;
@


1.1.1.1
log
@import perl 5.10.1
@
text
@@


1.1.1.2
log
@Import perl-5.20.1
@
text
@d48 1
a48 1
        $_  ||= "error";            # hmm, we did not get /anything/ from name-rev?
@

