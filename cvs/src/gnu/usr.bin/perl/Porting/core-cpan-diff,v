head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.5.0.10
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.4
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.6
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.10
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.8
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.6
	OPENBSD_5_0:1.1.1.2.0.4
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.2
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2010.09.24.14.49.21;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.29;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	B31cAbBIXiCqnL97;

1.1.1.6
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/env perl

# core-cpan-diff: Compare CPAN modules with their equivalent in core

# Originally based on App::DualLivedDiff by Steffen Mueller.

use strict;
use warnings;

use 5.010;

use Getopt::Long;
use File::Basename ();
use File::Copy     ();
use File::Temp     ();
use File::Path     ();
use File::Spec;
use File::Spec::Functions;
use IO::Uncompress::Gunzip ();
use File::Compare          ();
use ExtUtils::Manifest;
use ExtUtils::MakeMaker ();
use HTTP::Tiny;

BEGIN { die "Must be run from root of perl source tree\n" unless -d 'Porting' }
use lib 'Porting';
use Maintainers ();

use Archive::Tar;
use Cwd qw[cwd chdir];
use IPC::Open3;
use IO::Select;
local $Archive::Tar::WARN=0;

# where, under the cache dir, to download tarballs to
use constant SRC_DIR => 'tarballs';

# where, under the cache dir, to untar stuff to
use constant UNTAR_DIR => 'untarred';

use constant DIFF_CMD => 'diff';

sub usage {
    print STDERR "\n@@_\n\n" if @@_;
    print STDERR <<HERE;
Usage: $0 [opts] [ -d | -v | -x ] [ -a | module ... ]

-a/--all      Scan all dual-life modules.

-c/--cachedir Where to save downloaded CPAN tarball files
              (defaults to /tmp/something/ with deletion after each run).

-d/--diff     Display file differences using diff(1), rather than just
              listing which files have changed.

--diffopts    Options to pass to the diff command. Defaults to '-u --binary'.

-f|force      Force download from CPAN of new 02packages.details.txt file
              (with --crosscheck only).

-m|mirror     Preferred CPAN mirror URI (http:// or file:///)
              (Local mirror must be a complete mirror, not minicpan)

-o/--output   File name to write output to (defaults to STDOUT).

-r/--reverse  Reverses the diff (perl to CPAN).

-u/--upstream only print modules with the given upstream (defaults to all)

-v/--verbose  List the fate of *all* files in the tarball, not just those
              that differ or are missing.

-x|crosscheck List the distributions whose current CPAN version differs from
              that in blead (i.e. the DISTRIBUTION field in Maintainers.pl).

By default (i.e. without the --crosscheck option),  for each listed module
(or with -a, all CPAN modules listed in Maintainers.pl), grab the tarball
from CPAN associated with that module, and compare the files in it with
those in the perl source tree.

Must be run from the root of the perl source tree.
Module names must match the keys of %Modules in Maintainers.pl.

The diff(1) command is assumed to be in your PATH and is used to diff files
regardless of whether the --diff option has been chosen to display any file
differences.
HERE
    exit(1);
}

sub run {
    my $scan_all;
    my $diff_opts;
    my $reverse = 0;
    my @@wanted_upstreams;
    my $cache_dir;
    my $mirror_url = "http://www.cpan.org/";
    my $use_diff;
    my $output_file;
    my $verbose = 0;
    my $force;
    my $do_crosscheck;

    GetOptions(
        'a|all'         => \$scan_all,
        'c|cachedir=s'  => \$cache_dir,
        'd|diff'        => \$use_diff,
        'diffopts:s'    => \$diff_opts,
        'f|force'       => \$force,
        'h|help'        => \&usage,
        'm|mirror=s'    => \$mirror_url,
        'o|output=s'    => \$output_file,
        'r|reverse'     => \$reverse,
        'u|upstream=s@@' => \@@wanted_upstreams,
        'v|verbose:1'   => \$verbose,
        'x|crosscheck'  => \$do_crosscheck,
    ) or usage;

    my @@modules;

    usage("Cannot mix -a with module list") if $scan_all && @@ARGV;

    if ($do_crosscheck) {
        usage("can't use -r, -d, --diffopts with --crosscheck")
          if ( $reverse || $use_diff || $diff_opts );
    }
    else {
        $diff_opts = '-u --binary' unless defined $diff_opts;
        usage("can't use -f without --crosscheck") if $force;
    }

    @@modules =
      $scan_all
      ? grep $Maintainers::Modules{$_}{CPAN},
      ( sort { lc $a cmp lc $b } keys %Maintainers::Modules )
      : @@ARGV;
    usage("No modules specified") unless @@modules;

    my $outfh;
    if ( defined $output_file ) {
        open $outfh, '>', $output_file
          or die "ERROR: could not open file '$output_file' for writing: $!\n";
    }
    else {
        open $outfh, ">&STDOUT"
          or die "ERROR: can't dup STDOUT: $!\n";
    }

    if ( defined $cache_dir ) {
        die "ERROR: not a directory: '$cache_dir'\n"
            if !-d $cache_dir && -e $cache_dir;
        File::Path::mkpath($cache_dir);
    }
    else {
        $cache_dir = File::Temp::tempdir( CLEANUP => 1 );
    }

    $mirror_url .= "/" unless substr( $mirror_url, -1 ) eq "/";
    my $test_file = "modules/03modlist.data.gz";
    my_getstore(
        cpan_url( $mirror_url, $test_file ),
        catfile( $cache_dir, $test_file )
    ) or die "ERROR: not a CPAN mirror '$mirror_url'\n";

    if ($do_crosscheck) {
        do_crosscheck(
            $outfh, $cache_dir, $mirror_url, $verbose,
            $force, \@@modules,  \@@wanted_upstreams
        );
    }
    else {
        $verbose > 2 and $use_diff++;
        do_compare(
            \@@modules,  $outfh,      $output_file,
            $cache_dir, $mirror_url, $verbose,
            $use_diff,  $reverse,    $diff_opts,
            \@@wanted_upstreams
        );
    }
}

# construct a CPAN url

sub cpan_url {
    my ( $mirror_url, @@path ) = @@_;
    return $mirror_url unless @@path;
    my $cpan_path = join( "/", map { split "/", $_ } @@path );
    $cpan_path =~ s{\A/}{};    # remove leading slash since url has one trailing
    return $mirror_url . $cpan_path;
}

# construct a CPAN URL for a author/distribution string like:
# BINGOS/Archive-Extract-0.52.tar.gz

sub cpan_url_distribution {
    my ( $mirror_url, $distribution ) = @@_;
    $distribution =~ /^([A-Z])([A-Z])/
        or die "ERROR: invalid DISTRIBUTION name (not /^[A-Z]{2}/): $distribution\n";
    my $path = "authors/id/$1/$1$2/$distribution";
    return cpan_url( $mirror_url, $path );
}

# compare a list of modules against their CPAN equivalents

sub do_compare {
    my (
        $modules,    $outfh,   $output_file, $cache_dir,
        $mirror_url, $verbose, $use_diff,    $reverse,
        $diff_opts,  $wanted_upstreams
    ) = @@_;

    # first, make sure we have a directory where they can all be untarred,
    # and if its a permanent directory, clear any previous content
    my $untar_dir = catdir( $cache_dir, UNTAR_DIR );
    my $src_dir   = catdir( $cache_dir, SRC_DIR );
    for my $d ( $src_dir, $untar_dir ) {
        next if -d $d;
        mkdir $d or die "mkdir $d: $!\n";
    }

    my %ignorable = map { ( $_ => 1 ) } @@Maintainers::IGNORABLE;
    my %wanted_upstream = map { ( $_ => 1 ) } @@$wanted_upstreams;

    my %seen_dist;
    for my $module (@@$modules) {
        warn "Processing $module ...\n" if defined $output_file;

        my $m = $Maintainers::Modules{$module}
          or die "ERROR: No such module in Maintainers.pl: '$module'\n";

        unless ( $m->{CPAN} ) {
            print $outfh "WARNING: $module is not dual-life; skipping\n";
            next;
        }

        my $dist = $m->{DISTRIBUTION};
        die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $dist;

        if ( $seen_dist{$dist}++ ) {
            warn "WARNING: duplicate entry for $dist in $module\n";
        }

        my $upstream = $m->{UPSTREAM} // 'undef';
        next if @@$wanted_upstreams and !$wanted_upstream{$upstream};

        print $outfh "\n$module - "
          . $Maintainers::Modules{$module}->{DISTRIBUTION} . "\n";
        print $outfh "  upstream is: "
          . ( $m->{UPSTREAM} // 'UNKNOWN!' ) . "\n";

        my $cpan_dir;
        eval {
            $cpan_dir =
              get_distribution( $src_dir, $mirror_url, $untar_dir, $module,
                $dist );
        };
        if ($@@) {
            print $outfh "  ", $@@;
            print $outfh "  (skipping)\n";
            next;
        }

        my @@perl_files = Maintainers::get_module_files($module);

        my $manifest = catfile( $cpan_dir, 'MANIFEST' );
        die "ERROR: no such file: $manifest\n" unless -f $manifest;

        my $cpan_files = ExtUtils::Manifest::maniread($manifest);
        my @@cpan_files = sort keys %$cpan_files;

        ( my $main_pm = $module ) =~ s{::}{/}g;
        $main_pm .= ".pm";

        my ( $excluded, $map, $customized ) =
          get_map( $m, $module, \@@perl_files );

        my %perl_unseen;
        @@perl_unseen{@@perl_files} = ();
        my %perl_files = %perl_unseen;

        foreach my $cpan_file (@@cpan_files) {
            my $mapped_file =
              cpan_to_perl( $excluded, $map, $customized, $cpan_file );
            unless ( defined $mapped_file ) {
                print $outfh "  Excluded:  $cpan_file\n" if $verbose;
                next;
            }

            if ( exists $perl_files{$mapped_file} ) {
                delete $perl_unseen{$mapped_file};
            }
            else {

                # some CPAN files foo are stored in core as foo.packed,
                # which are then unpacked by 'make test_prep'
                my $packed_file = "$mapped_file.packed";
                if ( exists $perl_files{$packed_file} ) {
                    if ( !-f $mapped_file and -f $packed_file ) {
                        print $outfh <<EOF;
WARNING: $mapped_file not found, but .packed variant exists.
Perhaps you need to run 'make test_prep'?
EOF
                        next;
                    }
                    delete $perl_unseen{$packed_file};
                }
                else {
                    if ( $ignorable{$cpan_file} ) {
                        print $outfh "  Ignored:   $cpan_file\n" if $verbose;
                        next;
                    }

                    unless ($use_diff) {
                        print $outfh "  CPAN only: $cpan_file",
                          ( $cpan_file eq $mapped_file )
                          ? "\n"
                          : " (missing $mapped_file)\n";
                    }
                    next;
                }
            }

            my $abs_cpan_file = catfile( $cpan_dir, $cpan_file );

            # should never happen
            die "ERROR: can't find file $abs_cpan_file\n"
              unless -f $abs_cpan_file;

            # might happen if the FILES entry in Maintainers.pl is wrong
            unless ( -f $mapped_file ) {
                print $outfh "WARNING: perl file not found: $mapped_file\n";
                next;
            }

            my $relative_mapped_file = relatively_mapped($mapped_file);

            my $different =
              file_diff( $outfh, $abs_cpan_file, $mapped_file, $reverse,
                $diff_opts );
            if ( $different && customized( $m, $relative_mapped_file ) ) {
		print $outfh "  Customized for blead: $relative_mapped_file\n";
                if ( $use_diff && $verbose ) {
                    $different =~ s{^(--- |\+\+\+ )/tmp/[^/]+/}{$1}gm;
                    print $outfh $different;
                }
            }
            elsif ($different) {
                if ($use_diff) {
                    $different =~ s{^(--- |\+\+\+ )/tmp/[^/]+/}{$1}gm;
                    print $outfh $different;
                }
                else {
                    if ( $cpan_file eq $relative_mapped_file ) {
                        print $outfh "  Modified:  $relative_mapped_file\n";
                    }
                    else {
                        print $outfh
                          "  Modified:  $cpan_file $relative_mapped_file\n";
                    }

                    if ( $cpan_file =~ m{\.pm\z} ) {
                        my $pv = MM->parse_version($mapped_file)   || 'unknown';
                        my $cv = MM->parse_version($abs_cpan_file) || 'unknown';
                        if ( $pv ne $cv ) {
                            print $outfh
"  Version mismatch in '$cpan_file':\n    $cv (cpan) vs $pv (perl)\n";
                        }
                    }

                }
            }
            elsif ( customized( $m, $relative_mapped_file ) ) {
                # Maintainers.pl says we customized it, but it looks the
                # same as CPAN so maybe we lost the customization, which
                # could be bad
                if ( $cpan_file eq $relative_mapped_file ) {
                    print $outfh "  Blead customization missing: $cpan_file\n";
                }
                else {
                    print $outfh
                      "  Blead customization missing: $cpan_file $relative_mapped_file\n";
                }
            }
            elsif ($verbose) {
                if ( $cpan_file eq $relative_mapped_file ) {
                    print $outfh "  Unchanged: $cpan_file\n";
                }
                else {
                    print $outfh
                      "  Unchanged: $cpan_file $relative_mapped_file\n";
                }
            }
        }
        for ( sort keys %perl_unseen ) {
            my $relative_mapped_file = relatively_mapped($_);
            if ( customized( $m, $relative_mapped_file ) ) {
                print $outfh "  Customized for blead: $_\n";
            }
            else {
                print $outfh "  Perl only: $_\n" unless $use_diff;
            }
        }
        if ( $verbose ) {
            foreach my $exclude (@@$excluded) {
                my $seen = 0;
                foreach my $cpan_file (@@cpan_files) {
                    # may be a simple string to match exactly, or a pattern
                    if ( ref $exclude ) {
                        $seen = 1 if $cpan_file =~ $exclude;
                    }
                    else {
                        $seen = 1 if $cpan_file eq $exclude;
                    }
                    last if $seen;
                }
                if ( not $seen ) {
                    print $outfh "  Unnecessary exclusion: $exclude\n";
                }
            }
        }
    }
}

sub relatively_mapped {
    my $relative = shift;
    $relative =~ s/^(cpan|dist|ext)\/.*?\///;
    return $relative;
}

# given FooBar-1.23_45.tar.gz, return FooBar

sub distro_base {
    my $d = shift;
    $d =~ s/\.tar\.gz$//;
    $d =~ s/\.gip$//;
    $d =~ s/[\d\-_\.]+$//;
    return $d;
}

# process --crosscheck action:
# ie list all distributions whose CPAN versions differ from that listed in
# Maintainers.pl

sub do_crosscheck {
    my (
        $outfh, $cache_dir, $mirror_url, $verbose,
        $force, $modules,   $wanted_upstreams,
    ) = @@_;

    my $file         = '02packages.details.txt';
    my $download_dir = $cache_dir || File::Temp::tempdir( CLEANUP => 1 );
    my $path         = catfile( $download_dir, $file );
    my $gzfile       = "$path.gz";

    # grab 02packages.details.txt

    my $url = cpan_url( $mirror_url, "modules/02packages.details.txt.gz" );

    if ( !-f $gzfile or $force ) {
        unlink $gzfile;
        my_getstore( $url, $gzfile );
    }
    unlink $path;
    IO::Uncompress::Gunzip::gunzip( $gzfile, $path )
      or die
      "ERROR: failed to ungzip $gzfile: $IO::Uncompress::Gunzip::GunzipError\n";

    # suck in the data from it

    open my $fh, '<', $path
      or die "ERROR: open: $file: $!\n";

    my %distros;
    my %modules;

    while (<$fh>) {
        next if 1 .. /^$/;
        chomp;
        my @@f = split ' ', $_;
        if ( @@f != 3 ) {
            warn
              "WARNING: $file:$.: line doesn't have three fields (skipping)\n";
            next;
        }
        my $distro = $f[2];
        $distro =~ s{^[A-Z]/[A-Z]{2}/}{};    # strip leading A/AB/
        $modules{ $f[0] } = $distro;

        ( my $short_distro = $distro ) =~ s{^.*/}{};

        $distros{ distro_base($short_distro) }{$distro} = 1;
    }

    my %wanted_upstream = map { ( $_ => 1 ) } @@$wanted_upstreams;
    for my $module (@@$modules) {
        my $m = $Maintainers::Modules{$module}
          or die "ERROR: No such module in Maintainers.pl: '$module'\n";

        $verbose and warn "Checking $module\n";

        unless ( $m->{CPAN} ) {
            print $outfh "\nWARNING: $module is not dual-life; skipping\n";
            next;
        }

        # given an entry like
        #   Foo::Bar 1.23 foo-bar-1.23.tar.gz,
        # first compare the module name against Foo::Bar, and failing that,
        # against foo-bar

        my $pdist = $m->{DISTRIBUTION};
        die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $pdist;

        my $upstream = $m->{UPSTREAM} // 'undef';
        next if @@$wanted_upstreams and !$wanted_upstream{$upstream};

        my $cdist = $modules{$module};
        ( my $short_pdist = $pdist ) =~ s{^.*/}{};

        unless ( defined $cdist ) {
            my $d = $distros{ distro_base($short_pdist) };
            unless ( defined $d ) {
                print $outfh "\n$module: Can't determine current CPAN entry\n";
                next;
            }
            if ( keys %$d > 1 ) {
                print $outfh
                  "\n$module: (found more than one CPAN candidate):\n";
                print $outfh "    Perl: $pdist\n";
                print $outfh "    CPAN: $_\n" for sort keys %$d;
                next;
            }
            $cdist = ( keys %$d )[0];
        }

        if ( $cdist ne $pdist ) {
            print $outfh "\n$module:\n    Perl: $pdist\n    CPAN: $cdist\n";
        }
    }
}

# get the EXCLUDED and MAP entries for this module, or
# make up defaults if they don't exist

sub get_map {
    my ( $m, $module_name, $perl_files ) = @@_;

    my ( $excluded, $map, $customized ) = @@$m{qw(EXCLUDED MAP CUSTOMIZED)};

    $excluded   ||= [];
    $customized ||= [];

    return $excluded, $map, $customized if $map;

    # all files under ext/foo-bar (plus maybe some under t/lib)???

    my $ext;
    for (@@$perl_files) {
        if (m{^((?:ext|dist|cpan)/[^/]+/)}) {
            if ( defined $ext and $ext ne $1 ) {

                # more than one ext/$ext/
                undef $ext;
                last;
            }
            $ext = $1;
        }
        elsif (m{^t/lib/}) {
            next;
        }
        else {
            undef $ext;
            last;
        }
    }

    if ( defined $ext ) {
        $map = { '' => $ext },;
    }
    else {
        ( my $base = $module_name ) =~ s{::}{/}g;
        $base = "lib/$base";
        $map  = {
            'lib/' => 'lib/',
            ''     => "$base/",
        };
    }
    return $excluded, $map, $customized;
}

# Given an exclude list and a mapping hash, convert a CPAN filename
# (eg 't/bar.t') to the equivalent perl filename (eg 'lib/Foo/Bar/t/bar.t').
# Returns an empty list for an excluded file

sub cpan_to_perl {
    my ( $excluded, $map, $customized, $cpan_file ) = @@_;

    my %customized = map { ( $_ => 1 ) } @@$customized;
    for my $exclude (@@$excluded) {
        next if $customized{$exclude};

        # may be a simple string to match exactly, or a pattern
        if ( ref $exclude ) {
            return if $cpan_file =~ $exclude;
        }
        else {
            return if $cpan_file eq $exclude;
        }
    }

    my $perl_file = $cpan_file;

    # try longest prefix first, then alphabetically on tie-break
    for
      my $prefix ( sort { length($b) <=> length($a) || $a cmp $b } keys %$map )
    {
        last if $perl_file =~ s/^\Q$prefix/$map->{$prefix}/;
    }
    return $perl_file;
}

# fetch a file from a URL and store it in a file given by a filename

sub my_getstore {
    my ( $url, $file ) = @@_;
    File::Path::mkpath( File::Basename::dirname($file) );
    if ( $url =~ qr{\Afile://(?:localhost)?/} ) {
        ( my $local_path = $url ) =~ s{\Afile://(?:localhost)?}{};
        File::Copy::copy( $local_path, $file );
    } else {
        my $http = HTTP::Tiny->new;
        my $response = $http->mirror($url, $file);
        return $response->{success};
    }
}

# download and unpack a distribution
# Returns the full pathname of the extracted directory
# (eg '/tmp/XYZ/Foo_bar-1.23')

# cache_dir:  where to download the .tar.gz file to
# mirror_url: CPAN mirror to download from
# untar_dir:  where to untar or unzup the file
# module:     name of module
# dist:       name of the distribution

sub get_distribution {
    my ( $src_dir, $mirror_url, $untar_dir, $module, $dist ) = @@_;

    $dist =~ m{.+/([^/]+)$}
      or die
      "ERROR: $module: invalid DISTRIBUTION name (no AUTHOR/ prefix): $dist\n";
    my $filename = $1;

    my $download_file = catfile( $src_dir, $filename );

    # download distribution

    if ( -f $download_file and !-s $download_file ) {

        # failed download might leave a zero-length file
        unlink $download_file;
    }

    unless ( -f $download_file ) {

        # not cached
        my $url = cpan_url_distribution( $mirror_url, $dist );
        my_getstore( $url, $download_file )
          or die "ERROR: Could not fetch '$url'\n";
    }

    # get the expected name of the extracted distribution dir

    my $path = catfile( $untar_dir, $filename );

    $path =~ s/\.tar\.gz$//
      or $path =~ s/\.tgz$//
      or $path =~ s/\.zip$//
      or die
      "ERROR: downloaded file does not have a recognised suffix: $path\n";

    # extract it unless we already have it cached or tarball is newer
    if ( !-d $path || ( -M $download_file < -M $path ) ) {
        $path = extract( $download_file, $untar_dir )
          or die
          "ERROR: failed to extract distribution '$download_file to temp. dir: "
          . $! . "\n";
    }

    die "ERROR: Extracted tarball does not appear as $path\n" unless -d $path;

    return $path;
}

# produce the diff of a single file
sub file_diff {
    my $outfh     = shift;
    my $cpan_file = shift;
    my $perl_file = shift;
    my $reverse   = shift;
    my $diff_opts = shift;

    my @@cmd = ( DIFF_CMD, split ' ', $diff_opts );
    if ($reverse) {
        push @@cmd, $perl_file, $cpan_file;
    }
    else {
        push @@cmd, $cpan_file, $perl_file;
    }
    return `@@cmd`;

}

sub customized {
    my ( $module_data, $file ) = @@_;
    return grep { $file eq $_ } @@{ $module_data->{CUSTOMIZED} };
}

sub extract {
  my ($archive,$to) = @@_;
  my $cwd = cwd();
  chdir $to or die "$!\n";
  my @@files;
  EXTRACT: {
    local $Archive::Tar::CHOWN = 0;
    my $next;
    unless ( $next = Archive::Tar->iter( $archive, 1 ) ) {
       $! = $Archive::Tar::error;
       last EXTRACT;
    }
    while ( my $file = $next->() ) {
      push @@files, $file->full_path;
      unless ( $file->extract ) {
        $! = $Archive::Tar::error;
        last EXTRACT;
      }
    }
  }
  my $path = __get_extract_dir( \@@files );
  chdir $cwd or die "$!\n";
  return $path;
}

sub __get_extract_dir {
    my $files   = shift || [];

    return unless scalar @@$files;

    my($dir1, $dir2);
    for my $aref ( [ \$dir1, 0 ], [ \$dir2, -1 ] ) {
        my($dir,$pos) = @@$aref;

        ### add a catdir(), so that any trailing slashes get
        ### take care of (removed)
        ### also, a catdir() normalises './dir/foo' to 'dir/foo';
        ### which was the problem in bug #23999
        my $res = -d $files->[$pos]
                    ? File::Spec->catdir( $files->[$pos], '' )
                    : File::Spec->catdir( File::Basename::dirname( $files->[$pos] ) );

        $$dir = $res;
    }

    ### if the first and last dir don't match, make sure the
    ### dirname is not set wrongly
    my $dir;

    ### dirs are the same, so we know for sure what the extract dir is
    if( $dir1 eq $dir2 ) {
        $dir = $dir1;

    ### dirs are different.. do they share the base dir?
    ### if so, use that, if not, fall back to '.'
    } else {
        my $base1 = [ File::Spec->splitdir( $dir1 ) ]->[0];
        my $base2 = [ File::Spec->splitdir( $dir2 ) ]->[0];

        $dir = File::Spec->rel2abs( $base1 eq $base2 ? $base1 : '.' );
    }

    return File::Spec->rel2abs( $dir );
}

run();

@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
 
d13 4
a16 2
use File::Temp ();
use File::Path ();
d18 1
a18 1
use Archive::Extract;
d20 1
a20 1
use File::Compare ();
d22 2
a28 4
# if running from blead, we may be doing -Ilib, which means when we
# 'chdir /tmp/foo', Archive::Extract may not find Archive::Tar etc.
# So preload the things we need, and tell it to check %INC first:

d30 1
d33 1
a33 3
$Module::Load::Conditional::CHECK_INC_HASH = 1;
# stop Archive::Extract whinging about lack of Archive::Zip
$Archive::Extract::WARN = 0;
d35 2
a36 11

# Files, which if they exist in CPAN but not in perl, will not generate
# an 'Only in CPAN' listing
#
our %IGNORABLE = map { ($_ => 1) }
	qw(.cvsignore .dualLivedDiffConfig .gitignore
	      ANNOUNCE Announce Artistic AUTHORS BENCHMARK BUGS Build.PL
	      CHANGELOG ChangeLog CHANGES Changes COPYING Copying CREDITS
	      GOALS HISTORY INSTALL INSTALL.SKIP LICENSE Makefile.PL
	      MANIFEST MANIFEST.SKIP META.yml NEW NOTES ppport.h README
	      SIGNATURE THANKS TODO Todo VERSION WHATSNEW);
a38 1

d41 1
a41 2
use constant DIFF_CMD  => 'diff';
use constant WGET_CMD  => 'wget';
a54 1
              The diff(1) command is assumed to be in your PATH.
d56 1
a56 1
--diffopts    Options to pass to the diff command. Defaults to '-u'.
d61 3
d68 2
d83 4
a90 1

d94 2
a95 1
    my $reverse    = 0;
d97 1
d100 1
a100 1
    my $verbose;
d105 12
a116 10
	'a|all'        => \$scan_all,
	'c|cachedir=s' => \$cache_dir,
	'd|diff'       => \$use_diff,
	'diffopts:s'   => \$diff_opts,
	'f|force'      => \$force,
	'h|help'       => \&usage,
	'o|output=s'   => \$output_file,
	'r|reverse'    => \$reverse,
	'v|verbose'    => \$verbose,
	'x|crosscheck' => \$do_crosscheck,
a118 1

d124 2
a125 2
	usage("can't use -r, -d, --diffopts, -v with --crosscheck")
	    if ($reverse || $use_diff || $diff_opts || $verbose);
d128 2
a129 2
	$diff_opts = '-u' unless defined $diff_opts;
	usage("can't use -f without --crosscheck") if $force;
d132 5
a136 4
    @@modules = $scan_all
	        ? grep $Maintainers::Modules{$_}{CPAN},
		    (sort {lc $a cmp lc $b } keys %Maintainers::Modules)
	        : @@ARGV;
a138 1

d140 3
a142 3
    if (defined $output_file) {
	open $outfh, '>', $output_file
	    or die "ERROR: could not open file '$output_file' for writing: $!\n";
d145 2
a146 2
	open $outfh, ">&STDOUT"
			    or die "ERROR: can't dup STDOUT: $!\n";
d149 7
a155 2
    if (defined $cache_dir) {
	die "ERROR: no such directory: '$cache_dir'\n" unless -d $cache_dir;
d158 7
d166 4
a169 1
	do_crosscheck($outfh, $cache_dir, $force, \@@modules);
d172 7
a178 2
	do_compare(\@@modules, $outfh, $output_file, $cache_dir, $verbose, $use_diff,
	    $reverse, $diff_opts);
d182 12
d195 7
d206 5
a210 3
    my ($modules, $outfh, $output_file, $cache_dir, $verbose,
		$use_diff, $reverse, $diff_opts) = @@_;

d214 5
a218 12
    my $untar_dir;
    if ($cache_dir) {
	$untar_dir = File::Spec->catdir($cache_dir, UNTAR_DIR); 
	if (-d $untar_dir) {
	    File::Path::rmtree($untar_dir)
		    or die "failed to remove $untar_dir\n";
	}
	mkdir $untar_dir
	    or die "mkdir $untar_dir: $!\n";
    }
    else {
	$untar_dir = File::Temp::tempdir( CLEANUP => 1 );
d221 2
a222 1
    my %ignorable = map { ($_ => 1) } @@Maintainers::IGNORABLE;
d226 1
a226 2
	warn "Processing $module ...\n" if defined $output_file;
	print $outfh "\n$module\n" unless $use_diff;
d228 2
a229 2
	my $m = $Maintainers::Modules{$module} 
	    or die "ERROR: No such module in Maintainers.pl: '$module'\n";
d231 69
a299 54
	unless ($m->{CPAN}) {
	    print $outfh "WARNING: $module is not dual-life; skipping\n";
	    next;
	}

	my $dist = $m->{DISTRIBUTION};
	die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $dist;

	if ($seen_dist{$dist}) {
	    warn "WARNING: duplicate entry for $dist in $module\n"
	}
	$seen_dist{$dist}++;

	my $cpan_dir;
	eval {
	    $cpan_dir = get_distribution($cache_dir, $untar_dir, $module, $dist)
	};
	if ($@@) {
	    print $outfh "  ", $@@;
	    print $outfh "  (skipping)\n";
	    next;
	}

	my @@perl_files = Maintainers::get_module_files($module);

	my $manifest = File::Spec->catfile($cpan_dir, 'MANIFEST');
	die "ERROR: no such file: $manifest\n" unless  -f $manifest;

	my $cpan_files = ExtUtils::Manifest::maniread($manifest);
	my @@cpan_files = sort keys %$cpan_files;

	my ($excluded, $map) =  get_map($m, $module, \@@perl_files);

	my %perl_unseen;
	@@perl_unseen{@@perl_files} = ();
	my %perl_files = %perl_unseen;

	foreach my $cpan_file (@@cpan_files) {
	    my $mapped_file = cpan_to_perl($excluded, $map, $cpan_file);
	    unless (defined $mapped_file) {
	        print $outfh "  Excluded:  $cpan_file\n" if $verbose;
	        next;
	    }

	    if (exists $perl_files{$mapped_file}) {
	        delete $perl_unseen{$mapped_file};
	    }
	    else {
	        # some CPAN files foo are stored in core as foo.packed,
	        # which are then unpacked by 'make test_prep'
	        my $packed_file = "$mapped_file.packed";
	        if (exists $perl_files{$packed_file} ) {
	            if (! -f $mapped_file and -f $packed_file) {
	                print $outfh <<EOF;
d303 118
a420 58
	                next;
	            }
	            delete $perl_unseen{$packed_file};
	        }
	        else {
	            if ($ignorable{$cpan_file}) {
	                print $outfh "  Ignored:   $cpan_file\n" if $verbose;
	                next;
	            }

	            unless ($use_diff) {
	                print $outfh "  CPAN only: $cpan_file",
	                    ($cpan_file eq $mapped_file) ? "\n"
				: " (expected $mapped_file)\n";
	            }
	            next;
	        }
	    }


	    my $abs_cpan_file = File::Spec->catfile($cpan_dir, $cpan_file);

	    # should never happen
	    die "ERROR: can't find file $abs_cpan_file\n" unless -f $abs_cpan_file;

	    # might happen if the FILES entry in Maintainers.pl is wrong
	    unless (-f $mapped_file) {
	        print $outfh "WARNING: perl file not found: $mapped_file\n";
	        next;
	    }


	    if (File::Compare::compare($abs_cpan_file, $mapped_file)) {
	        if ($use_diff) {
	            file_diff($outfh, $abs_cpan_file, $mapped_file,
	                                $reverse, $diff_opts);
	        }
	        else {
	            if ($cpan_file eq $mapped_file) {
	                print $outfh "  Modified:  $cpan_file\n";
	            }
	            else {
	                print $outfh "  Modified:  $cpan_file $mapped_file\n";
	            }
	        }
	    }
	    elsif ($verbose) {
	            if ($cpan_file eq $mapped_file) {
	                print $outfh "  Unchanged: $cpan_file\n";
	            }
	            else {
	                print $outfh "  Unchanged: $cpan_file $mapped_file\n";
	            }
	    }
	}
	for (sort keys %perl_unseen) {
	    print $outfh "  Perl only: $_\n" unless $use_diff;
	}
d424 6
d445 4
a448 1
    my ($outfh, $cache_dir, $force, $modules) = @@_;
d450 1
a450 1
    my $file = '02packages.details.txt';
d452 2
a453 2
    my $path = File::Spec->catfile($download_dir, $file);
    my $gzfile = "$path.gz";
d457 1
a457 1
    my $url = 'http://www.cpan.org/modules/02packages.details.txt.gz';
d459 3
a461 3
    if (! -f $gzfile or $force) {
	unlink $gzfile;
	my_getstore($url, $gzfile);
d464 3
a466 2
    IO::Uncompress::Gunzip::gunzip($gzfile, $path)
	or die "ERROR: failed to ungzip $gzfile: $IO::Uncompress::Gunzip::GunzipError\n";
d469 1
a469 1
    
d471 1
a471 1
	or die "ERROR: open: $file: $!\n";
d477 11
a487 10
	next if 1../^$/;
	chomp;
	my @@f = split ' ', $_;
	if (@@f != 3) {
	    warn "WARNING: $file:$.: line doesn't have three fields (skipping)\n";
	    next;
	}
	my $distro = $f[2];
	$distro =~ s{^[A-Z]/[A-Z]{2}/}{}; # strip leading A/AB/
	$modules{$f[0]} = $distro;
d489 1
a489 1
	(my $short_distro = $distro) =~ s{^.*/}{};
d491 1
a491 1
	$distros{distro_base($short_distro)}{$distro} = 1;
d494 1
d496 2
a497 2
	my $m = $Maintainers::Modules{$module} 
	    or die "ERROR: No such module in Maintainers.pl: '$module'\n";
d499 40
a538 34
	unless ($m->{CPAN}) {
	    print $outfh "\nWARNING: $module is not dual-life; skipping\n";
	    next;
	}

	# given an entry like
	#   Foo::Bar 1.23 foo-bar-1.23.tar.gz,
	# first compare the module name against Foo::Bar, and failing that,
	# against foo-bar

	my $pdist = $m->{DISTRIBUTION};
	die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $pdist;

	my $cdist = $modules{$module};
	(my $short_pdist = $pdist) =~ s{^.*/}{};

	unless (defined $cdist) {
	    my $d = $distros{distro_base($short_pdist)};
	    unless (defined $d) {
	        print $outfh "\n$module: Can't determine current CPAN entry\n";
	        next;
	    }
	    if (keys %$d > 1) {
	        print $outfh "\n$module: (found more than one CPAN candidate):\n";
	        print $outfh "    perl: $pdist\n";
	        print $outfh "    CPAN: $_\n" for sort keys %$d;
	        next;
	    }
	    $cdist = (keys %$d)[0];
	}

	if ($cdist ne $pdist) {
	    print $outfh "\n$module:\n    Perl: $pdist\n    CPAN: $cdist\n";
	}
a541 2


d543 1
a543 1
# make up defauts if they don't exist
d546 1
a546 1
    my ($m, $module_name, $perl_files) = @@_;
d548 1
a548 1
    my ($excluded, $map) = @@$m{qw(EXCLUDED MAP)};
d550 2
a551 1
    $excluded ||= [];
d553 1
a553 1
    return $excluded, $map if $map;
d559 20
a578 19
	if (m{^(ext/[^/]+/)}) {
	    if (defined $ext and $ext ne $1) {
	        # more than one ext/$ext/
	        undef $ext;
	        last;
	    }
	    $ext = $1;
	}
	elsif (m{^t/lib/}) {
	    next;
	}
	else {
	    undef $ext;
	    last;
	}
    }
    
    if (defined $ext) {
	    $map = { '' => $ext },
d581 6
a586 6
	(my $base = $module_name) =~ s{::}{/}g;
	$base ="lib/$base";
	$map = {
	    'lib/'	=> 'lib/',
	    ''	=> "$base/",
	};
d588 1
a588 1
    return $excluded, $map;
a590 1

d596 1
a596 1
    my ($excluded, $map, $cpan_file) = @@_;
d598 1
d600 9
a608 7
	# may be a simple string to match exactly, or a pattern
	if (ref $exclude) {
	    return if $cpan_file =~ $exclude;
	}
	else {
	    return if $cpan_file eq $exclude;
	}
d614 2
a615 1
    for my $prefix (sort { length($b) <=> length($a) || $a cmp $b } keys %$map)
d617 1
a617 1
	last if $perl_file =~ s/^\Q$prefix/$map->{$prefix}/;
d622 1
a622 5


# do LWP::Simple::getstore, possibly without LWP::Simple being available

my $lwp_simple_available;
d625 9
a633 10
    my ($url, $file) = @@_;
    unless (defined $lwp_simple_available) {
	eval { require LWP::Simple };
	$lwp_simple_available = $@@ eq '';
    }
    if ($lwp_simple_available) {
	return LWP::Simple::is_success(LWP::Simple::getstore($url, $file));
    }
    else {
	return system(WGET_CMD, "-O", $file, $url) == 0;
a636 1

d641 5
a645 4
# cache_dir: where to dowenload the .tar.gz file to
# untar_dir: where to untar or unzup the file 
# module:    name of module
# dist:      name of the distribution
d648 1
a648 1
    my ($cache_dir, $untar_dir, $module, $dist) = @@_;
d651 2
a652 1
	or die "ERROR: $module: invalid DISTRIBUTION name (no AUTHOR/ prefix): $dist\n";
d655 1
a655 2
    my $download_dir = $cache_dir || File::Temp::tempdir( CLEANUP => 1 );
    my $download_file = File::Spec->catfile($download_dir, $filename);
d659 4
a662 3
    if (-f $download_file and ! -s $download_file ) {
	# wget can leave a zero-length file on failed download
	unlink $download_file;
d665 1
a665 4
    unless (-f $download_file) {
	# not cached
	$dist =~ /^([A-Z])([A-Z])/
	    or die "ERROR: $module: invalid DISTRIBUTION name (not /^[A-Z]{2}/): $dist\n";
d667 4
a670 3
	my $url = "http://www.cpan.org/modules/by-authors/id/$1/$1$2/$dist";
	my_getstore($url, $download_file)
	    or die "ERROR: Could not fetch '$url'\n";
d673 1
a673 1
    # extract distribution
d675 1
a675 3
    my $ae = Archive::Extract->new( archive => $download_file);
    $ae->extract( to => $untar_dir )
	or die "ERROR: failed to extract distribution '$download_file to temp. dir: " . $ae->error() . "\n";
d677 5
a681 1
    # get the name of the extracted distribution dir
d683 7
a689 5
    my $path = File::Spec->catfile($untar_dir, $filename);

    $path =~ s/\.tar\.gz$// or
    $path =~ s/\.zip$// or
      die "ERROR: downloaded file does not have a recognised suffix: $path\n";
a695 1

d704 1
a704 2

    my @@cmd = (DIFF_CMD, split ' ', $diff_opts);
d706 1
a706 1
	push @@cmd, $perl_file, $cpan_file;
d709 1
a709 1
	push @@cmd, $cpan_file, $perl_file;
d711 1
a711 1
    my $result = `@@cmd`;
d713 1
a713 1
    $result =~ s{^(--- |\+\+\+ )/tmp/[^/]+/}{$1}gm;
d715 3
a717 1
    print $outfh $result;
d720 64
@


1.1.1.1
log
@import perl 5.10.1
@
text
@@


1.1.1.2
log
@Perl 5.12.2 from CPAN
@
text
@a77 2
-u/--upstream only print modules with the given upstream (defaults to all)

a99 1
    my @@wanted_upstreams;
a115 1
	'u|upstream=s@@'=> \@@wanted_upstreams,
d160 1
a160 1
	    $reverse, $diff_opts, \@@wanted_upstreams);
d170 1
a170 1
		$use_diff, $reverse, $diff_opts, $wanted_upstreams) = @@_;
d194 1
a209 6

	my $upstream = $m->{UPSTREAM} || 'UNKNOWN';
	next if @@$wanted_upstreams and ! ($upstream ~~ $wanted_upstreams);
	print $outfh "\n$module - ".$Maintainers::Modules{$module}->{DISTRIBUTION}."\n" unless $use_diff;
	print $outfh "  upstream is: ".($m->{UPSTREAM} || 'UNKNOWN!')."\n";

a286 2
			my $relative_mapped_file = $mapped_file;
			$relative_mapped_file =~ s/^(cpan|dist|ext)\/.*?\///;
d289 1
a289 3


	         if ($use_diff) {
d294 2
a295 2
	            if ($cpan_file eq $relative_mapped_file) {
	                print $outfh "  Modified:  $relative_mapped_file\n";
d298 1
a298 1
	                print $outfh "  Modified:  $cpan_file $relative_mapped_file\n";
d303 1
a303 1
	            if ($cpan_file eq $relative_mapped_file) {
d307 1
a307 1
	                print $outfh "  Unchanged: $cpan_file $relative_mapped_file\n";
d435 1
a435 1
	if (m{^((?:ext|dist|cpan)/[^/]+/)}) {
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 1
a6 1

d13 3
a15 5
use File::Basename ();
use File::Copy     ();
use File::Temp     ();
use File::Path     ();
use File::Spec::Functions;
d18 1
a18 1
use File::Compare          ();
a19 2
use ExtUtils::MakeMaker ();
use HTTP::Tiny;
a32 1

d36 11
a46 2
# where, under the cache dir, to download tarballs to
use constant SRC_DIR => 'tarballs';
d49 1
d52 2
a53 2
use constant DIFF_CMD => 'diff';
use constant WGET_CMD => 'wget';
a73 3
-m|mirror     Preferred CPAN mirror URI (http:// or file:///)
              (Local mirror must be a complete mirror, not minicpan)

d97 1
d101 1
a101 1
    my $reverse = 0;
a103 1
    my $mirror_url = "http://www.cpan.org/";
d111 11
a121 12
        'a|all'         => \$scan_all,
        'c|cachedir=s'  => \$cache_dir,
        'd|diff'        => \$use_diff,
        'diffopts:s'    => \$diff_opts,
        'f|force'       => \$force,
        'h|help'        => \&usage,
        'm|mirror=s'    => \$mirror_url,
        'o|output=s'    => \$output_file,
        'r|reverse'     => \$reverse,
        'u|upstream=s@@' => \@@wanted_upstreams,
        'v|verbose'     => \$verbose,
        'x|crosscheck'  => \$do_crosscheck,
d124 1
d130 2
a131 2
        usage("can't use -r, -d, --diffopts, -v with --crosscheck")
          if ( $reverse || $use_diff || $diff_opts || $verbose );
d134 2
a135 2
        $diff_opts = '-u -b' unless defined $diff_opts;
        usage("can't use -f without --crosscheck") if $force;
d138 4
a141 5
    @@modules =
      $scan_all
      ? grep $Maintainers::Modules{$_}{CPAN},
      ( sort { lc $a cmp lc $b } keys %Maintainers::Modules )
      : @@ARGV;
d144 1
d146 3
a148 3
    if ( defined $output_file ) {
        open $outfh, '>', $output_file
          or die "ERROR: could not open file '$output_file' for writing: $!\n";
d151 2
a152 2
        open $outfh, ">&STDOUT"
          or die "ERROR: can't dup STDOUT: $!\n";
d155 2
a156 2
    if ( defined $cache_dir ) {
        die "ERROR: no such directory: '$cache_dir'\n" unless -d $cache_dir;
a157 10
    else {
        $cache_dir = File::Temp::tempdir( CLEANUP => 1 );
    }

    $mirror_url .= "/" unless substr( $mirror_url, -1 ) eq "/";
    my $test_file = "modules/03modlist.data.gz";
    my_getstore(
        cpan_url( $mirror_url, $test_file ),
        catfile( $cache_dir, $test_file )
    ) or die "ERROR: not a CPAN mirror '$mirror_url'\n";
d160 1
a160 1
        do_crosscheck( $outfh, $cache_dir, $mirror_url, $force, \@@modules );
d163 2
a164 6
        do_compare(
            \@@modules,  $outfh,      $output_file,
            $cache_dir, $mirror_url, $verbose,
            $use_diff,  $reverse,    $diff_opts,
            \@@wanted_upstreams
        );
a167 1
# construct a CPAN url
a168 18
sub cpan_url {
    my ( $mirror_url, @@path ) = @@_;
    return $mirror_url unless @@path;
    my $cpan_path = join( "/", map { split "/", $_ } @@path );
    $cpan_path =~ s{\A/}{};    # remove leading slash since url has one trailing
    return $mirror_url . $cpan_path;
}

# construct a CPAN URL for a author/distribution string like:
# BINGOS/Archive-Extract-0.52.tar.gz

sub cpan_url_distribution {
    my ( $mirror_url, $distribution ) = @@_;
    $distribution =~ /^([A-Z])([A-Z])/
        or die "ERROR: invalid DISTRIBUTION name (not /^[A-Z]{2}/): $distribution\n";
    my $path = "modules/by-authors/id/$1/$1$2/$distribution";
    return cpan_url( $mirror_url, $path );
}
d173 3
a175 5
    my (
        $modules,    $outfh,   $output_file, $cache_dir,
        $mirror_url, $verbose, $use_diff,    $reverse,
        $diff_opts,  $wanted_upstreams
    ) = @@_;
d179 12
a190 5
    my $untar_dir = catdir( $cache_dir, UNTAR_DIR );
    my $src_dir   = catdir( $cache_dir, SRC_DIR );
    for my $d ( $src_dir, $untar_dir ) {
        next if -d $d;
        mkdir $d or die "mkdir $d: $!\n";
d193 1
a193 1
    my %ignorable = map { ( $_ => 1 ) } @@Maintainers::IGNORABLE;
d197 1
a197 1
        warn "Processing $module ...\n" if defined $output_file;
d199 2
a200 2
        my $m = $Maintainers::Modules{$module}
          or die "ERROR: No such module in Maintainers.pl: '$module'\n";
d202 60
a261 69
        unless ( $m->{CPAN} ) {
            print $outfh "WARNING: $module is not dual-life; skipping\n";
            next;
        }

        my $dist = $m->{DISTRIBUTION};
        die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $dist;

        if ( $seen_dist{$dist}++ ) {
            warn "WARNING: duplicate entry for $dist in $module\n";
        }

        my $upstream = $m->{UPSTREAM} || 'UNKNOWN';
        next if @@$wanted_upstreams and !( $upstream ~~ $wanted_upstreams );

        print $outfh "\n$module - "
          . $Maintainers::Modules{$module}->{DISTRIBUTION} . "\n";
        print $outfh "  upstream is: "
          . ( $m->{UPSTREAM} || 'UNKNOWN!' ) . "\n";

        my $cpan_dir;
        eval {
            $cpan_dir =
              get_distribution( $src_dir, $mirror_url, $untar_dir, $module,
                $dist );
        };
        if ($@@) {
            print $outfh "  ", $@@;
            print $outfh "  (skipping)\n";
            next;
        }

        my @@perl_files = Maintainers::get_module_files($module);

        my $manifest = catfile( $cpan_dir, 'MANIFEST' );
        die "ERROR: no such file: $manifest\n" unless -f $manifest;

        my $cpan_files = ExtUtils::Manifest::maniread($manifest);
        my @@cpan_files = sort keys %$cpan_files;

        ( my $main_pm = $module ) =~ s{::}{/}g;
        $main_pm .= ".pm";

        my ( $excluded, $map, $customized ) =
          get_map( $m, $module, \@@perl_files );

        my %perl_unseen;
        @@perl_unseen{@@perl_files} = ();
        my %perl_files = %perl_unseen;

        foreach my $cpan_file (@@cpan_files) {
            my $mapped_file =
              cpan_to_perl( $excluded, $map, $customized, $cpan_file );
            unless ( defined $mapped_file ) {
                print $outfh "  Excluded:  $cpan_file\n" if $verbose;
                next;
            }

            if ( exists $perl_files{$mapped_file} ) {
                delete $perl_unseen{$mapped_file};
            }
            else {

                # some CPAN files foo are stored in core as foo.packed,
                # which are then unpacked by 'make test_prep'
                my $packed_file = "$mapped_file.packed";
                if ( exists $perl_files{$packed_file} ) {
                    if ( !-f $mapped_file and -f $packed_file ) {
                        print $outfh <<EOF;
d265 62
a326 98
                        next;
                    }
                    delete $perl_unseen{$packed_file};
                }
                else {
                    if ( $ignorable{$cpan_file} ) {
                        print $outfh "  Ignored:   $cpan_file\n" if $verbose;
                        next;
                    }

                    unless ($use_diff) {
                        print $outfh "  CPAN only: $cpan_file",
                          ( $cpan_file eq $mapped_file )
                          ? "\n"
                          : " (missing $mapped_file)\n";
                    }
                    next;
                }
            }

            my $abs_cpan_file = catfile( $cpan_dir, $cpan_file );

            # should never happen
            die "ERROR: can't find file $abs_cpan_file\n"
              unless -f $abs_cpan_file;

            # might happen if the FILES entry in Maintainers.pl is wrong
            unless ( -f $mapped_file ) {
                print $outfh "WARNING: perl file not found: $mapped_file\n";
                next;
            }

            my $relative_mapped_file = relatively_mapped($mapped_file);

            my $different =
              file_diff( $outfh, $abs_cpan_file, $mapped_file, $reverse,
                $diff_opts );
            if ( $different && customized( $m, $relative_mapped_file ) ) {
                if (! $use_diff ) {
                    print $outfh "  Customized for blead: $relative_mapped_file\n";
                }
            }
            elsif ($different) {
                if ($use_diff) {
                    $different =~ s{^(--- |\+\+\+ )/tmp/[^/]+/}{$1}gm;
                    print $outfh $different;
                }
                else {
                    if ( $cpan_file eq $relative_mapped_file ) {
                        print $outfh "  Modified:  $relative_mapped_file\n";
                    }
                    else {
                        print $outfh
                          "  Modified:  $cpan_file $relative_mapped_file\n";
                    }

                    if ( $cpan_file =~ m{\.pm\z} ) {
                        my $pv = MM->parse_version($mapped_file)   || 'unknown';
                        my $cv = MM->parse_version($abs_cpan_file) || 'unknown';
                        if ( $pv ne $cv ) {
                            print $outfh
"  Version mismatch in '$cpan_file':\n    $cv (cpan) vs $pv (perl)\n";
                        }
                    }

                }
            }
            elsif ( customized( $m, $relative_mapped_file ) ) {
                # Maintainers.pl says we customized it, but it looks the
                # same as CPAN so maybe we lost the customization, which
                # could be bad
                if ( $cpan_file eq $relative_mapped_file ) {
                    print $outfh "  Blead customization missing: $cpan_file\n";
                }
                else {
                    print $outfh
                      "  Blead customization missing: $cpan_file $relative_mapped_file\n";
                }
            }
            elsif ($verbose) {
                if ( $cpan_file eq $relative_mapped_file ) {
                    print $outfh "  Unchanged: $cpan_file\n";
                }
                else {
                    print $outfh
                      "  Unchanged: $cpan_file $relative_mapped_file\n";
                }
            }
        }
        for ( sort keys %perl_unseen ) {
            my $relative_mapped_file = relatively_mapped($_);
            if ( customized( $m, $relative_mapped_file ) ) {
                print $outfh "  Customized for blead: $_\n";
            }
            else {
                print $outfh "  Perl only: $_\n" unless $use_diff;
            }
        }
a329 6
sub relatively_mapped {
    my $relative = shift;
    $relative =~ s/^(cpan|dist|ext)\/.*?\///;
    return $relative;
}

d345 1
a345 1
    my ( $outfh, $cache_dir, $mirror_url, $force, $modules ) = @@_;
d347 1
a347 1
    my $file         = '02packages.details.txt';
d349 2
a350 2
    my $path         = catfile( $download_dir, $file );
    my $gzfile       = "$path.gz";
d354 1
a354 1
    my $url = cpan_url( $mirror_url, "modules/02packages.details.txt.gz" );
d356 3
a358 3
    if ( !-f $gzfile or $force ) {
        unlink $gzfile;
        my_getstore( $url, $gzfile );
d361 2
a362 3
    IO::Uncompress::Gunzip::gunzip( $gzfile, $path )
      or die
      "ERROR: failed to ungzip $gzfile: $IO::Uncompress::Gunzip::GunzipError\n";
d365 1
a365 1

d367 1
a367 1
      or die "ERROR: open: $file: $!\n";
d373 10
a382 11
        next if 1 .. /^$/;
        chomp;
        my @@f = split ' ', $_;
        if ( @@f != 3 ) {
            warn
              "WARNING: $file:$.: line doesn't have three fields (skipping)\n";
            next;
        }
        my $distro = $f[2];
        $distro =~ s{^[A-Z]/[A-Z]{2}/}{};    # strip leading A/AB/
        $modules{ $f[0] } = $distro;
d384 1
a384 1
        ( my $short_distro = $distro ) =~ s{^.*/}{};
d386 1
a386 1
        $distros{ distro_base($short_distro) }{$distro} = 1;
d390 2
a391 2
        my $m = $Maintainers::Modules{$module}
          or die "ERROR: No such module in Maintainers.pl: '$module'\n";
d393 34
a426 35
        unless ( $m->{CPAN} ) {
            print $outfh "\nWARNING: $module is not dual-life; skipping\n";
            next;
        }

        # given an entry like
        #   Foo::Bar 1.23 foo-bar-1.23.tar.gz,
        # first compare the module name against Foo::Bar, and failing that,
        # against foo-bar

        my $pdist = $m->{DISTRIBUTION};
        die "ERROR: $module has no DISTRIBUTION entry\n" unless defined $pdist;

        my $cdist = $modules{$module};
        ( my $short_pdist = $pdist ) =~ s{^.*/}{};

        unless ( defined $cdist ) {
            my $d = $distros{ distro_base($short_pdist) };
            unless ( defined $d ) {
                print $outfh "\n$module: Can't determine current CPAN entry\n";
                next;
            }
            if ( keys %$d > 1 ) {
                print $outfh
                  "\n$module: (found more than one CPAN candidate):\n";
                print $outfh "    perl: $pdist\n";
                print $outfh "    CPAN: $_\n" for sort keys %$d;
                next;
            }
            $cdist = ( keys %$d )[0];
        }

        if ( $cdist ne $pdist ) {
            print $outfh "\n$module:\n    Perl: $pdist\n    CPAN: $cdist\n";
        }
d430 2
d436 1
a436 1
    my ( $m, $module_name, $perl_files ) = @@_;
d438 1
a438 1
    my ( $excluded, $map, $customized ) = @@$m{qw(EXCLUDED MAP CUSTOMIZED)};
d440 1
a440 2
    $excluded   ||= [];
    $customized ||= [];
d442 1
a442 1
    return $excluded, $map, $customized if $map;
d448 19
a466 20
        if (m{^((?:ext|dist|cpan)/[^/]+/)}) {
            if ( defined $ext and $ext ne $1 ) {

                # more than one ext/$ext/
                undef $ext;
                last;
            }
            $ext = $1;
        }
        elsif (m{^t/lib/}) {
            next;
        }
        else {
            undef $ext;
            last;
        }
    }

    if ( defined $ext ) {
        $map = { '' => $ext },;
d469 6
a474 6
        ( my $base = $module_name ) =~ s{::}{/}g;
        $base = "lib/$base";
        $map  = {
            'lib/' => 'lib/',
            ''     => "$base/",
        };
d476 1
a476 1
    return $excluded, $map, $customized;
d479 1
d485 1
a485 1
    my ( $excluded, $map, $customized, $cpan_file ) = @@_;
d488 7
a494 9
        next if $exclude ~~ $customized;

        # may be a simple string to match exactly, or a pattern
        if ( ref $exclude ) {
            return if $cpan_file =~ $exclude;
        }
        else {
            return if $cpan_file eq $exclude;
        }
d500 1
a500 2
    for
      my $prefix ( sort { length($b) <=> length($a) || $a cmp $b } keys %$map )
d502 1
a502 1
        last if $perl_file =~ s/^\Q$prefix/$map->{$prefix}/;
d507 5
a511 1
# fetch a file from a URL and store it in a file given by a filename
d514 10
a523 9
    my ( $url, $file ) = @@_;
    File::Path::mkpath( File::Basename::dirname($file) );
    if ( $url =~ qr{\Afile://(?:localhost)?/} ) {
        ( my $local_path = $url ) =~ s{\Afile://(?:localhost)?}{};
        File::Copy::copy( $local_path, $file );
    } else {
        my $http = HTTP::Tiny->new;
        my $response = $http->mirror($url, $file);
        return $response->{success};
d527 1
d532 4
a535 5
# cache_dir:  where to download the .tar.gz file to
# mirror_url: CPAN mirror to download from
# untar_dir:  where to untar or unzup the file
# module:     name of module
# dist:       name of the distribution
d538 1
a538 1
    my ( $src_dir, $mirror_url, $untar_dir, $module, $dist ) = @@_;
d541 1
a541 2
      or die
      "ERROR: $module: invalid DISTRIBUTION name (no AUTHOR/ prefix): $dist\n";
d544 2
a545 1
    my $download_file = catfile( $src_dir, $filename );
d549 3
a551 4
    if ( -f $download_file and !-s $download_file ) {

        # wget can leave a zero-length file on failed download
        unlink $download_file;
d554 4
a557 1
    unless ( -f $download_file ) {
d559 3
a561 4
        # not cached
        my $url = cpan_url_distribution( $mirror_url, $dist );
        my_getstore( $url, $download_file )
          or die "ERROR: Could not fetch '$url'\n";
d564 1
a564 1
    # get the expected name of the extracted distribution dir
d566 3
a568 1
    my $path = catfile( $untar_dir, $filename );
d570 1
a570 4
    $path =~ s/\.tar\.gz$//
      or $path =~ s/\.zip$//
      or die
      "ERROR: downloaded file does not have a recognised suffix: $path\n";
d572 1
a572 7
    # extract it unless we already have it cached or tarball is newer
    if ( !-d $path || ( -M $download_file < -M $path ) ) {
        my $ae = Archive::Extract->new( archive => $download_file );
        $ae->extract( to => $untar_dir )
          or die
          "ERROR: failed to extract distribution '$download_file to temp. dir: "
          . $ae->error() . "\n";
d574 3
a576 2
        $path = $ae->extract_path;
    }
d583 1
d592 2
a593 1
    my @@cmd = ( DIFF_CMD, split ' ', $diff_opts );
d595 1
a595 1
        push @@cmd, $perl_file, $cpan_file;
d598 1
a598 1
        push @@cmd, $cpan_file, $perl_file;
d600 1
a600 1
    return `@@cmd`;
d602 3
a606 4
sub customized {
    my ( $module_data, $file ) = @@_;
    return grep { $file eq $_ } @@{ $module_data->{CUSTOMIZED} };
}
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d48 1
d62 1
a90 4

The diff(1) command is assumed to be in your PATH and is used to diff files
regardless of whether the --diff option has been chosen to display any file
differences.
a122 2
    @@wanted_upstreams = map { $_ eq 'undef' ? undef : $_ } @@wanted_upstreams;

d154 1
a154 3
        die "ERROR: not a directory: '$cache_dir'\n"
            if !-d $cache_dir && -e $cache_dir;
        File::Path::mkpath($cache_dir);
d168 1
a168 4
        do_crosscheck(
            $outfh, $cache_dir, $mirror_url,
            $force, \@@modules,  \@@wanted_upstreams
        );
d197 1
a197 1
    my $path = "authors/id/$1/$1$2/$distribution";
a219 1
    my %wanted_upstream = map { ( $_ => 1 ) } @@$wanted_upstreams;
d240 2
a241 2
        my $upstream = $m->{UPSTREAM};
        next if @@$wanted_upstreams and !$wanted_upstream{$upstream};
d246 1
a246 1
          . ( $m->{UPSTREAM} // 'UNKNOWN!' ) . "\n";
d422 1
a422 4
    my (
        $outfh, $cache_dir, $mirror_url,
        $force, $modules,   $wanted_upstreams,
    ) = @@_;
a467 1
    my %wanted_upstream = map { ( $_ => 1 ) } @@$wanted_upstreams;
a484 3
        my $upstream = $m->{UPSTREAM};
        next if @@$wanted_upstreams and !$wanted_upstream{$upstream};

a565 1
    my %customized = map { ( $_ => 1 ) } @@$customized;
d567 1
a567 1
        next if $customized{$exclude};
d628 1
a628 1
        # failed download might leave a zero-length file
a644 1
      or $path =~ s/\.tgz$//
@


1.1.1.5
log
@Import perl-5.20.1
@
text
@a16 1
use File::Spec;
d18 1
d29 4
a33 1
use Cwd qw[cwd chdir];
d36 4
a39 1
local $Archive::Tar::WARN=0;
d106 1
a106 1
    my $verbose = 0;
d121 1
a121 1
        'v|verbose:1'   => \$verbose,
d125 2
d132 2
a133 2
        usage("can't use -r, -d, --diffopts with --crosscheck")
          if ( $reverse || $use_diff || $diff_opts );
d175 1
a175 1
            $outfh, $cache_dir, $mirror_url, $verbose,
a179 1
        $verbose > 2 and $use_diff++;
d250 1
a250 1
        my $upstream = $m->{UPSTREAM} // 'undef';
d348 2
a349 4
		print $outfh "  Customized for blead: $relative_mapped_file\n";
                if ( $use_diff && $verbose ) {
                    $different =~ s{^(--- |\+\+\+ )/tmp/[^/]+/}{$1}gm;
                    print $outfh $different;
a407 18
        if ( $verbose ) {
            foreach my $exclude (@@$excluded) {
                my $seen = 0;
                foreach my $cpan_file (@@cpan_files) {
                    # may be a simple string to match exactly, or a pattern
                    if ( ref $exclude ) {
                        $seen = 1 if $cpan_file =~ $exclude;
                    }
                    else {
                        $seen = 1 if $cpan_file eq $exclude;
                    }
                    last if $seen;
                }
                if ( not $seen ) {
                    print $outfh "  Unnecessary exclusion: $exclude\n";
                }
            }
        }
d433 1
a433 1
        $outfh, $cache_dir, $mirror_url, $verbose,
a485 2
        $verbose and warn "Checking $module\n";

d499 1
a499 1
        my $upstream = $m->{UPSTREAM} // 'undef';
d528 1
a528 1
# make up defaults if they don't exist
d670 2
a671 1
        $path = extract( $download_file, $untar_dir )
d674 3
a676 1
          . $! . "\n";
a705 65
}

sub extract {
  my ($archive,$to) = @@_;
  my $cwd = cwd();
  chdir $to or die "$!\n";
  my @@files;
  EXTRACT: {
    local $Archive::Tar::CHOWN = 0;
    my $next;
    unless ( $next = Archive::Tar->iter( $archive, 1 ) ) {
       $! = $Archive::Tar::error;
       last EXTRACT;
    }
    while ( my $file = $next->() ) {
      push @@files, $file->full_path;
      unless ( $file->extract ) {
        $! = $Archive::Tar::error;
        last EXTRACT;
      }
    }
  }
  my $path = __get_extract_dir( \@@files );
  chdir $cwd or die "$!\n";
  return $path;
}

sub __get_extract_dir {
    my $files   = shift || [];

    return unless scalar @@$files;

    my($dir1, $dir2);
    for my $aref ( [ \$dir1, 0 ], [ \$dir2, -1 ] ) {
        my($dir,$pos) = @@$aref;

        ### add a catdir(), so that any trailing slashes get
        ### take care of (removed)
        ### also, a catdir() normalises './dir/foo' to 'dir/foo';
        ### which was the problem in bug #23999
        my $res = -d $files->[$pos]
                    ? File::Spec->catdir( $files->[$pos], '' )
                    : File::Spec->catdir( File::Basename::dirname( $files->[$pos] ) );

        $$dir = $res;
    }

    ### if the first and last dir don't match, make sure the
    ### dirname is not set wrongly
    my $dir;

    ### dirs are the same, so we know for sure what the extract dir is
    if( $dir1 eq $dir2 ) {
        $dir = $dir1;

    ### dirs are different.. do they share the base dir?
    ### if so, use that, if not, fall back to '.'
    } else {
        my $base1 = [ File::Spec->splitdir( $dir1 ) ]->[0];
        my $base2 = [ File::Spec->splitdir( $dir2 ) ]->[0];

        $dir = File::Spec->rel2abs( $base1 eq $base2 ? $base1 : '.' );
    }

    return File::Spec->rel2abs( $dir );
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d56 1
a56 1
--diffopts    Options to pass to the diff command. Defaults to '-u --binary'.
d128 1
a128 1
        $diff_opts = '-u --binary' unless defined $diff_opts;
d529 1
a529 1
                print $outfh "    Perl: $pdist\n";
@


