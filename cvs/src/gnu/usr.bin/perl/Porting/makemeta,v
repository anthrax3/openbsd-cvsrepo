head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.4
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.4
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.2
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.49.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.30;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w
# this script must be run by the current perl to get perl's version right
#
# Create META.yml and META.json files in the current directory. Must be run from the
# root directory of a perl source tree.

use strict;
use warnings;
use Getopt::Std;

my $opts = {
  'META.yml'  => { version => '1.4' },
  'META.json' => { version => '2' },
};

my %switches;
getopts('byj', \%switches);

my @@metafiles;
if ( $switches{y} ) {
  push @@metafiles, 'META.yml';
}
elsif ( $switches{j} ) {
  push @@metafiles, 'META.json';
}
else {
  push @@metafiles, keys %$opts;
}

my ($vers, $stat ) = _determine_status();

my $distmeta = {
  'version' => $vers,
  'name' => 'perl',
  'author' => [
    'perl5-porters@@perl.org'
  ],
  'license' => [
    'perl_5'
  ],
  'abstract' => 'The Perl 5 language interpreter',
  'release_status' => $stat,
  'dynamic_config' => 1,
  'resources' => {
    'repository' => {
      'url' => 'http://perl5.git.perl.org/'
    },
    'homepage' => 'http://www.perl.org/',
    'bugtracker' => {
      'web' => 'https://rt.perl.org/'
    },
    'license' => [
      'http://dev.perl.org/licenses/'
    ],
  },
};

use lib "Porting";
use File::Basename qw( dirname );
use CPAN::Meta;

BEGIN {
    # Get function prototypes
    require 'regen/regen_lib.pl';
}

use Maintainers qw(%Modules get_module_files get_module_pat);

my @@CPAN  = grep { $Modules{$_}{CPAN} } keys %Modules;
my @@files = ('autodoc.pl', 'lib/unicore/mktables', 'TestInit.pm',
             'Porting/Maintainers.pm', 'Porting/perldelta_template.pod',
             map { get_module_files($_) } @@CPAN);
my @@dirs  = ('cpan', 'win32', 'lib/perl5db', grep { -d $_ && $_  !~ /^cpan/ } map { get_module_pat($_) } @@CPAN);

my %dirs;
@@dirs{@@dirs} = ();

@@files =
  grep {
    my $d = $_;
    my $previous_d = '';
    while(($d = dirname($d)) ne "."){
      last if $d eq $previous_d; # safety valve
      last if exists $dirs{$d};
      $previous_d = $d;
    }

    # if $d is "." it means we tried every parent dir of the file and none
    # of them were in the private list

    $d eq "." || $d eq $previous_d;
  }
  sort { lc $a cmp lc $b } @@files;

@@dirs  = sort { lc $a cmp lc $b } @@dirs;

$distmeta->{no_index}->{file} = \@@files;
$distmeta->{no_index}->{directory} = \@@dirs;

my $meta = CPAN::Meta->create( $distmeta );
foreach my $file ( @@metafiles ) {
  my $fh = open_new($file);
  print $fh $meta->as_string( $opts->{$file} );
  close_and_rename($fh);
}
exit 0;

sub _determine_status {
  my $patchlevel_h = 'patchlevel.h';
  return unless -e $patchlevel_h;
  my $status = '';
  my $version = '';
  {
    my %defines;
    open my $fh, '<', $patchlevel_h;
    my @@vers;
    while (<$fh>) {
      chomp;
      next unless m!^#define! or m!!;
      if ( m!^#define! ) {
        my ($foo,$bar) = ( split /\s+/ )[1,2];
        $defines{$foo} = $bar;
      }
      elsif ( m!\"RC\d+\"! ) {
        $status = 'testing';
        last;
      }
    }
    unless ( $status ) {
      $status = $defines{PERL_VERSION} % 2 ? 'unstable' : 'stable';
    }
    if ( my @@wotsits = grep { defined $defines{$_} } qw(PERL_REVISION PERL_VERSION PERL_SUBVERSION) ) {
      $version = sprintf '%d.%03d%03d', map { $defines{$_} } @@wotsits;
    }
    else {
      # Well, you never know
      $version = sprintf '5.%03d_%02d', map { $defines{$_} } qw(PATCHLEVEL SUBVERSION);
    }
  }
  return ( $version, $status );
}
@


1.1
log
@Initial revision
@
text
@d3 3
d9 49
a58 1

d60 1
d62 4
a65 2
my $file = "META.yml";
die "$0: will not override $file, delete it first.\n" if -e $file;
d70 4
a73 2
my @@files = map { get_module_files($_) } @@CPAN;
my @@dirs  = grep { -d $_ } map { get_module_pat($_) } @@CPAN;
d78 1
a78 1
my $files = join '', map { "    - $_\n" }
d81 1
d83 1
d85 1
d90 2
a91 2
    
    $d eq "."; 
d95 1
a95 1
my $dirs  = join '', map { "    - $_\n" } sort { lc $a cmp lc $b } @@dirs;
d97 2
a98 17
open my $fh, ">$file" or die "Can't open $file: $!";

print $fh <<"EOI";
name: perl
version: $]
abstract: Practical Extraction and Reporting Language
author: perl5-porters\@@perl.org
license: perl
distribution_type: core
private:
  directory:
$dirs
  file:
$files
EOI

close $fh;
d100 42
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d43 1
a43 1
abstract: Practical Extraction and Report Language
@


1.1.1.3
log
@import perl 5.10.1
@
text
@a2 3
#
# Create a META.yml file in the current directory. Must be run from the
# root directory of a perl source tree.
a45 4
resources:
  homepage: http://www.perl.org/
  bugtracker: http://rt.perl.org/perlbug/
  license: http://dev.perl.org/licenses/
d47 1
a47 2
generated_by: $0
no_index:
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d19 2
a20 4
my @@files = ('lib/unicore/mktables', 'TestInit.pm',
	     'Porting/Maintainers.pm', 'Porting/perldelta_template.pod',
	     map { get_module_files($_) } @@CPAN);
my @@dirs  = ('cpan', 'win32', grep { -d $_ && $_  !~ /^cpan/ } map { get_module_pat($_) } @@CPAN);
a52 1
  repository: http://perl5.git.perl.org/
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a12 7

BEGIN {
    # Get function prototypes
    require 'regen/regen_lib.pl';
}


d14 1
d19 1
a19 1
my @@files = ('autodoc.pl', 'lib/unicore/mktables', 'TestInit.pm',
d27 1
a27 1
@@files = map { "    - $_" }
a29 1
    my $previous_d = '';
a30 1
      last if $d eq $previous_d; # safety valve
a31 1
      $previous_d = $d;
d37 1
a37 1
    $d eq "." || $d eq $previous_d;
d41 1
a41 1
@@dirs  = map { "    - $_" } sort { lc $a cmp lc $b } @@dirs;
d43 1
a43 1
my $fh = open_new($file);
a44 1
local $" = "\n";
d48 1
a48 1
abstract: The Perl 5 language interpreter
d60 1
a60 1
@@dirs
d62 1
a62 1
@@files
d65 2
a66 1
close_and_rename($fh);
@


1.1.1.6
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d4 1
a4 1
# Create META.yml and META.json files in the current directory. Must be run from the
d9 1
a9 1
use Getopt::Std;
d11 1
a11 18
my $opts = {
  'META.yml'  => { version => '1.4' },
  'META.json' => { version => '2' },
};

my %switches;
getopts('byj', \%switches);

my @@metafiles;
if ( $switches{y} ) {
  push @@metafiles, 'META.yml';
}
elsif ( $switches{j} ) {
  push @@metafiles, 'META.json';
}
else {
  push @@metafiles, keys %$opts;
}
a12 31
my ($vers, $stat ) = _determine_status();

my $distmeta = {
  'version' => $vers,
  'name' => 'perl',
  'author' => [
    'perl5-porters@@perl.org'
  ],
  'license' => [
    'perl_5'
  ],
  'abstract' => 'The Perl 5 language interpreter',
  'release_status' => $stat,
  'dynamic_config' => 1,
  'resources' => {
    'repository' => {
      'url' => 'http://perl5.git.perl.org/'
    },
    'homepage' => 'http://www.perl.org/',
    'bugtracker' => {
      'web' => 'http://rt.perl.org/perlbug/'
    },
    'license' => [
      'http://dev.perl.org/licenses/'
    ],
  },
};

use lib "Porting";
use File::Basename qw( dirname );
use CPAN::Meta;
d19 3
d26 3
a28 3
             'Porting/Maintainers.pm', 'Porting/perldelta_template.pod',
             map { get_module_files($_) } @@CPAN);
my @@dirs  = ('cpan', 'win32', 'mad', grep { -d $_ && $_  !~ /^cpan/ } map { get_module_pat($_) } @@CPAN);
d33 1
a33 1
@@files =
d45 1
a45 1

d50 1
a50 1
@@dirs  = sort { lc $a cmp lc $b } @@dirs;
d52 1
a52 2
$distmeta->{no_index}->{file} = \@@files;
$distmeta->{no_index}->{directory} = \@@dirs;
d54 20
a73 7
my $meta = CPAN::Meta->create( $distmeta );
foreach my $file ( @@metafiles ) {
  my $fh = open_new($file);
  print $fh $meta->as_string( $opts->{$file} );
  close_and_rename($fh);
}
exit 0;
d75 1
a75 34
sub _determine_status {
  my $patchlevel_h = 'patchlevel.h';
  return unless -e $patchlevel_h;
  my $status = '';
  my $version = '';
  {
    my %defines;
    open my $fh, '<', $patchlevel_h;
    my @@vers;
    while (<$fh>) {
      chomp;
      next unless m!^#define! or m!!;
      if ( m!^#define! ) {
        my ($foo,$bar) = ( split /\s+/ )[1,2];
        $defines{$foo} = $bar;
      }
      elsif ( m!\"RC\d+\"! ) {
        $status = 'testing';
        last;
      }
    }
    unless ( $status ) {
      $status = $defines{PERL_VERSION} % 2 ? 'unstable' : 'stable';
    }
    if ( my @@wotsits = grep { defined $defines{$_} } qw(PERL_REVISION PERL_VERSION PERL_SUBVERSION) ) {
      $version = sprintf '%d.%03d%03d', map { $defines{$_} } @@wotsits;
    }
    else {
      # Well, you never know
      $version = sprintf '5.%03d_%02d', map { $defines{$_} } qw(PATCHLEVEL SUBVERSION);
    }
  }
  return ( $version, $status );
}
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d50 1
a50 1
      'web' => 'https://rt.perl.org/'
@


