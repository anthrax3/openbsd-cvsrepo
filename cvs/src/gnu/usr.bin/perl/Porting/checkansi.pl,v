head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.1.0.32
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.30
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.24
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.26
	OPENBSD_5_8_BASE:1.1.1.1
	PERL_5_20_2:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.18
	OPENBSD_5_7_BASE:1.1.1.1
	PERL_5_20_1:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.22
	OPENBSD_5_6_BASE:1.1.1.1
	PERL_5_18_2:1.1.1.1
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.20
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.16
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.14
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.12
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.10
	OPENBSD_5_0:1.1.1.1.0.8
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.6
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.4
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.2
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w
use strict;
use warnings;
use 5.010;
use File::Find;
use IO::File;
use Getopt::Long;
use Pod::Usage;

my %limits = (
  c90 => {
           'logical-source-line-length' => 509,
         },
  c99 => {
           'logical-source-line-length' => 4095,
         },
);

my %opt = (
  std => 'c99',
);

GetOptions(\%opt, qw( logical-source-line-length=i std=s ))
  && @@ARGV && exists $limits{$opt{std}}
    or pod2usage(2);

for my $k (keys %{$limits{$opt{std}}}) {
  $opt{$k} //= $limits{$opt{std}}{$k};
}

{
  my $num = 1;

  sub report
  {
    my $msg = shift;
    my $info = join '', @@_;

    if ($info) {
      $info =~ s/\R+$//;
      $info =~ s/^/   #|\t/mg;
      $info = "\n$info\n\n";
    }

    warn sprintf "[%d] %s(%d): %s\n%s",
         $num++, $File::Find::name, $., $msg, $info;
  }
}

find(sub {
  /\.([ch]|xs)$/ or return;

  my $fh = IO::File->new($_) or die "$_: $!\n";
  my $ll = '';

  while (defined(my $line = <$fh>)) {
    report("trailing whitespace after backslash", $line)
        if $line =~ /\\[[:blank:]]+$/;

    $ll .= $line;

    unless ($ll =~ /\\$/) {
      if (length $ll > $opt{'logical-source-line-length'}) {
        report(sprintf("logical source line too long (%d > %d)",
                       length $ll, $opt{'logical-source-line-length'}), $ll);
      }
      $ll = '';
    }
  }
}, @@ARGV);

__END__

=head1 NAME

checkansi.pl - Check source code for ANSI-C violations

=head1 SYNOPSIS

checkansi.pl [B<--std>=c90|c99]
[B<--logical-source-line-length>=I<num>]
<path> ...

=head1 DESCRIPTION

B<checkansi.pl> searches 

=head1 OPTIONS

=over 4

=item B<--std>=c90|c99

Choose the ANSI/ISO standard against which shall be checked.
Defaults to C<c99>.

=item B<--logical-source-line-length>=I<number>

Maximum length of a logical source line. Overrides the default
given by the chosen standard.

=back

=head1 COPYRIGHT

Copyright 2007 by Marcus Holland-Moritz <mhx@@cpan.org>.

This program is free software; you may redistribute it
and/or modify it under the same terms as Perl itself.

=cut
@


1.1.1.1
log
@import perl 5.10.1
@
text
@@
