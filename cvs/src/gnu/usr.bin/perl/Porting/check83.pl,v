head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.14
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.16
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.10
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.12
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.4
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.8
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.18
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.16
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.14
	OPENBSD_5_0:1.1.1.4.0.12
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.10
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.28;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.28;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/local/bin/perl

# Check whether there are naming conflicts when names are truncated to
# the DOSish case-ignoring 8.3 format, plus other portability no-nos.

# The "8.3 rule" is loose: "if reducing the directory entry names
# within one directory to lowercase and 8.3-truncated causes
# conflicts, that's a bad thing".  So the rule is NOT the strict
# "no filename shall be longer than eight and a suffix if present
# not longer than three".

# TODO: this doesn't actually check for *directory entries*, what this
# does is to check for *MANIFEST entries*, which are only files, not
# directories.  In other words, a 8.3 conflict between a directory
# "abcdefghx" and a file "abcdefghy" wouldn't be noticed-- or even for
# a directory "abcdefgh" and a file "abcdefghy".

sub eight_dot_three {
    my ($dir, $base, $ext) = ($_[0] =~ m!^(?:(.+)/)?([^/.]+)(?:\.([^/.]+))?$!);
    my $file = $base . defined $ext ? ".$ext" : "";
    $base = substr($base, 0, 8);
    $ext  = substr($ext,  0, 3) if defined $ext;
    if ($dir =~ /\./)  {
	warn "$dir: directory name contains '.'\n";
    }
    if ($file =~ /[^A-Za-z0-9\._-]/) {
	warn "$file: filename contains non-portable characters\n";
    }
    if (length $file > 30) {
	warn "$file: filename longer than 30 characters\n"; # make up a limit
    }
    if (defined $dir) {
	return ($dir, defined $ext ? "$dir/$base.$ext" : "$dir/$base");
    } else {
	return ('.', defined $ext ? "$base.$ext" : $base);
    }
}

my %dir;

if (open(MANIFEST, "MANIFEST")) {
    while (<MANIFEST>) {
	chomp;
	s/\s.+//;
	unless (-f) {
	    warn "$_: missing\n";
	    next;
	}
	if (tr/././ > 1) {
	    print "$_: more than one dot\n";
	    next;
	}
	my ($dir, $edt) = eight_dot_three($_);
	($dir, $edt) = map { lc } ($dir, $edt);
	push @@{$dir{$dir}->{$edt}}, $_;
    }
} else {
    die "$0: MANIFEST: $!\n";
}

for my $dir (sort keys %dir) {
    for my $edt (keys %{$dir{$dir}}) {
	my @@files = @@{$dir{$dir}->{$edt}};
	if (@@files > 1) {
	    print "@@files: directory $dir conflict $edt\n";
	}
    }
}
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a1 1
#!/usr/bin/perl
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d1 1
a1 3
#!/usr/bin/perl -w

use strict;
d12 5
a16 2
my %seen;
my $maxl = 30; # make up a limit for a maximum filename length
d19 2
a20 3
    return () if $seen{$_[0]}++;
    my ($dir, $base, $ext) = ($_[0] =~ m{^(?:(.+)/)?([^/.]+)(?:\.([^/.]+))?$});
    my $file = $base . ( defined $ext ? ".$ext" : "" );
d23 2
a24 2
    if (defined $dir && $dir =~ /\./)  {
	print "directory name contains '.': $dir\n";
d27 1
a27 1
	print "filename contains non-portable characters: $_[0]\n";
d29 2
a30 2
    if (length $file > $maxl) {
	print "filename longer than $maxl characters: $file\n";
d46 1
a46 1
	    print "missing: $_\n";
d50 1
a50 1
	    print "more than one dot: $_\n";
d53 3
a55 6
	while (m!/|\z!g) {
	    my ($dir, $edt) = eight_dot_three($`);
	    next unless defined $dir;
	    ($dir, $edt) = map { lc } ($dir, $edt);
	    push @@{$dir{$dir}->{$edt}}, $_;
	}
d65 1
a65 1
	    print "directory $dir conflict $edt: @@files\n";
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a13 4
# The 8-level depth rule is for older VMS systems that likely won't
# even be able to unpack the tarball if more than eight levels 
# (including the top of the source tree) are present.

a52 4
	if ((my $slashes = $_ =~ tr|\/|\/|) > 7) {
	    print "more than eight levels deep: $_\n";
	    next;
	}
d66 1
a66 1
	my @@files = @@{$dir{$dir}{$edt}};
d68 1
a68 1
	    print "conflict on filename $edt:\n", map "    $_\n", @@files;
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d23 1
a23 1
    my ($dir, $base, $ext) = ($_[0] =~ m{^(?:(.+)/)?([^/.]*)(?:\.([^/.]+))?$});
a29 3
    if ($base eq "") {
	print "filename starts with dot: $_[0]\n";
    }
d62 1
a62 1
	    my ($dir, $edt) = eight_dot_three("$`");
@


