head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2_BASE:1.1.1.8
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.1.1.8.0.12
	OPENBSD_6_1_BASE:1.1.1.8
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.49.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.12;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.46;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.30;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#
# Maintainers.pm - show information about maintainers
#

package Maintainers;

use strict;

use lib "Porting";

require "Maintainers.pl";
use vars qw(%Modules %Maintainers);

use vars qw(@@ISA @@EXPORT_OK);
@@ISA = qw(Exporter);
@@EXPORT_OK = qw(%Modules %Maintainers
		get_module_files get_module_pat
		show_results process_options);
require Exporter;

use File::Find;
use Getopt::Long;

my %MANIFEST;
if (open(MANIFEST, "MANIFEST")) {
    while (<MANIFEST>) {
	if (/^(\S+)\t+(.+)$/) {
	    $MANIFEST{$1}++;
	}
    }
    close MANIFEST;
} else {
    die "$0: Failed to open MANIFEST for reading: $!\n";
}

sub get_module_pat {
    my $m = shift;
    split ' ', $Modules{$m}{FILES};
}

sub get_module_files {
    my $m = shift;
    sort { lc $a cmp lc $b }
    map {
	-f $_ ? # Files as-is.
	    $_ :
	    -d _ ? # Recurse into directories.
	    do {
		my @@files;
		find(
		     sub {
			 push @@files, $File::Find::name
			     if -f $_ && exists $MANIFEST{$File::Find::name};
		     }, $_);
		@@files;
	    }
	: glob($_) # The rest are globbable patterns.
	} get_module_pat($m);
}

sub get_maintainer_modules {
    my $m = shift;
    sort { lc $a cmp lc $b }
    grep { $Modules{$_}{MAINTAINER} eq $m }
    keys %Modules;
}

sub usage {
    print <<__EOF__;
$0: Usage: $0 [[--maintainer M --module M --files --check]|file ...]
--maintainer M	list all maintainers matching M
--module M	list all modules matching M
--files		list all files
--check		check consistency of Maintainers.pl
Matching is case-ignoring regexp, author matching is both by
the short id and by the full name and email.  A "module" may
not be just a module, it may be a file or files or a subdirectory.
The options may be abbreviated to their unique prefixes
__EOF__
    exit(0);
}

my $Maintainer;
my $Module;
my $Files;
my $Check;

sub process_options {
    usage()
	unless
	    GetOptions(
		       'maintainer=s'	=> \$Maintainer,
		       'module=s'	=> \$Module,
		       'files'		=> \$Files,
		       'check'		=> \$Check,
		      );

    my @@Files = @@ARGV;

    usage() if @@Files && ($Maintainer || $Module || $Files);

    for my $mean ($Maintainer, $Module) {
	warn "$0: Did you mean '$0 $mean'?\n"
	    if $mean && -e $mean && $mean ne '.' && !$Files;
    }

    warn "$0: Did you mean '$0 -mo $Maintainer'?\n"
	if defined $Maintainer && exists $Modules{$Maintainer};

    warn "$0: Did you mean '$0 -ma $Module'?\n"
	if defined $Module     && exists $Maintainers{$Module};

    return ($Maintainer, $Module, $Files, @@Files);
}

sub show_results {
    my ($Maintainer, $Module, $Files, @@Files) = @@_;

    if ($Maintainer) {
	for my $m (sort keys %Maintainers) {
	    if ($m =~ /$Maintainer/io || $Maintainers{$m} =~ /$Maintainer/io) {
		my @@modules = get_maintainer_modules($m);
		if ($Module) {
		    @@modules = grep { /$Module/io } @@modules;
		}
		if ($Files) {
		    my @@files;
		    for my $module (@@modules) {
			push @@files, get_module_files($module);
		    }
		    printf "%-15s @@files\n", $m;
		} else {
		    if ($Module) {
			printf "%-15s @@modules\n", $m;
		    } else {
			printf "%-15s $Maintainers{$m}\n", $m;
		    }
		}
	    }
	}
    } elsif ($Module) {
	for my $m (sort { lc $a cmp lc $b } keys %Modules) {
	    if ($m =~ /$Module/io) {
		if ($Files) {
		    my @@files = get_module_files($m);
		    printf "%-15s @@files\n", $m;
		} else {
		    printf "%-15s $Modules{$m}{MAINTAINER}\n", $m;
		}
	    }
	}
    } elsif (@@Files) {
	my %ModuleByFile;

	for (@@Files) { s:^\./:: }

	@@ModuleByFile{@@Files} = ();

	# First try fast match.

	my %ModuleByPat;
	for my $module (keys %Modules) {
	    for my $pat (get_module_pat($module)) {
		$ModuleByPat{$pat} = $module;
	    }
	}
	# Expand any globs.
	my %ExpModuleByPat;
	for my $pat (keys %ModuleByPat) {
	    if (-e $pat) {
		$ExpModuleByPat{$pat} = $ModuleByPat{$pat};
	    } else {
		for my $exp (glob($pat)) {
		    $ExpModuleByPat{$exp} = $ModuleByPat{$pat};
		}
	    }
	}
	%ModuleByPat = %ExpModuleByPat;
	for my $file (@@Files) {
	    $ModuleByFile{$file} = $ModuleByPat{$file}
	        if exists $ModuleByPat{$file};
	}

	# If still unresolved files...
	if (my @@ToDo = grep { !defined $ModuleByFile{$_} } keys %ModuleByFile) {

	    # Cannot match what isn't there.
	    @@ToDo = grep { -e $_ } @@ToDo;

	    if (@@ToDo) {
		# Try prefix matching.

		# Remove trailing slashes.
		for (@@ToDo) { s|/$|| }

		my %ToDo;
		@@ToDo{@@ToDo} = ();

		for my $pat (keys %ModuleByPat) {
		    last unless keys %ToDo;
		    if (-d $pat) {
			my @@Done;
			for my $file (keys %ToDo) {
			    if ($file =~ m|^$pat|i) {
				$ModuleByFile{$file} = $ModuleByPat{$pat};
				push @@Done, $file;
			    }
			}
			delete @@ToDo{@@Done};
		    }
		}
	    }
	}

	for my $file (@@Files) {
	    if (defined $ModuleByFile{$file}) {
		my $module     = $ModuleByFile{$file};
		my $maintainer = $Modules{$ModuleByFile{$file}}{MAINTAINER};
		printf "%-15s $module $maintainer $Maintainers{$maintainer}\n", $file;
	    } else {
		printf "%-15s ?\n", $file;
	    }
	}
    }
    elsif ($Check) {
	duplicated_maintainers();
    }
    else {
	usage();
    }
}

sub duplicated_maintainers {
    my %files;
    for my $k (keys %Modules) {
	for my $f (get_module_files($k)) {
	    ++$files{$f};
	}
    }
    for my $f (keys %files) {
	if ($files{$f} > 1) {
	    warn "File $f appears $files{$f} times in Maintainers.pl\n";
	}
    }
}

1;

@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@a74 1
--opened	list all modules of files opened by perforce
a86 1
my $Opened;
a95 1
		       'opened'		=> \$Opened,
d98 1
a98 9
    my @@Files;
   
    if ($Opened) {
	my @@raw = `p4 opened`;
	die if $?;
	@@Files =  map {s!#.*!!s; s!^//depot/.*?/perl/!!; $_} @@raw;
    } else {
	@@Files = @@ARGV;
    }
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@a9 1
use 5.010;
d70 1
a70 1
$0: Usage: $0 [[--maintainer M --module M --files]|[--check] file ...]
a74 3
			with a file	checks if it has a maintainer
			with a dir	checks all files have a maintainer
			otherwise	checks for multiple maintainers
a162 7
    } elsif ($Check) {
        if( @@Files ) {
	    missing_maintainers( qr{\.(?:[chty]|p[lm]|xs)\z}msx, @@Files)
	}
	else { 
	    duplicated_maintainers();
	}
d236 3
d244 2
a245 5
sub warn_maintainer(_);
my %files;

sub maintainers_files {
    %files = ();
a250 4
}

sub duplicated_maintainers {
    maintainers_files();
a255 14
}

sub missing_maintainers {
    my($check, @@path) = @@_;
    maintainers_files();
    my @@dir;
    for (@@path) { if( -d ) { push @@dir, $_ } else { warn_maintainer() } }
    find sub { warn_maintainer($File::Find::name) if /$check/; }, @@dir
	if @@dir;
}

sub warn_maintainer(_) {
    my $name = shift;
    warn "File $name has no maintainer\n" if not $files{$name};
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d10 1
a10 3
# Please don't use post 5.008 features as this module is used by
# Porting/makemeta, and that in turn has to be run by the perl just built.
use 5.008;
d15 1
a15 1
use vars qw(@@ISA @@EXPORT_OK $VERSION);
d19 1
a19 3
		show_results process_options files_to_modules
		reload_manifest);
$VERSION = 0.03;
d26 4
a29 13

# (re)read the MANIFEST file, blowing away any previous effort

sub reload_manifest {
    %MANIFEST = ();
    if (open(MANIFEST, "MANIFEST")) {
	while (<MANIFEST>) {
	    if (/^(\S+)/) {
		$MANIFEST{$1}++;
	    }
	    else {
		warn "MANIFEST:$.: malformed line: $_\n";
	    }
a30 3
	close MANIFEST;
    } else {
	die "$0: Failed to open MANIFEST for reading: $!\n";
d32 3
a36 3
reload_manifest;


a41 23
# exand dir/ or foo* into a full list of files
#
sub expand_glob {
    sort { lc $a cmp lc $b }
	map {
	    -f $_ ? # File as-is.
		$_ :
		-d _ ? # Recurse into directories.
		do {
		    my @@files;
		    find(
			 sub {
			     push @@files, $File::Find::name
				 if -f $_ && exists $MANIFEST{$File::Find::name};
			 }, $_);
		    @@files;
		}
	    # The rest are globbable patterns; expand the glob, then
	    # recurively perform directory expansion on any results
	    : expand_glob(grep -e $_,glob($_))
	    } @@_;
}

d44 16
a59 11
    my %exclude;
    my @@files;
    for (get_module_pat($m)) {
	if (s/^!//) {
	    $exclude{$_}=1 for expand_glob($_);
	}
	else {
	    push @@files, expand_glob($_);
	}
    }
    return grep !$exclude{$_}, @@files;
a61 1

d70 6
a75 8
    warn <<__EOF__;
$0: Usage:
    --maintainer M | --module M [--files]
		List modules or maintainers matching the pattern M.
		With --files, list all the files associated with them
or
    --check | --checkmani [commit | file ... | dir ... ]
		Check consistency of Maintainers.pl
d78 2
a79 8
			with a commit   checks files modified by that commit
			no arg		checks for multiple maintainers
	       --checkmani is like --check, but only reports on unclaimed
	       files if they are in MANIFEST
or
    --opened  | file ....
		List the module ownership of modified or the listed files

a91 1
my $Checkmani;
a101 1
		       'checkmani'	=> \$Checkmani,
d106 1
a106 1

d108 1
a108 2
	usage if @@ARGV;
	chomp (@@Files = `git ls-files -m --full-name`);
d110 1
a110 5
    } elsif (@@ARGV == 1 &&
	     $ARGV[0] =~ /^(?:HEAD|[0-9a-f]{4,40})(?:~\d+)?\^*$/) {
	my $command = "git diff --name-only $ARGV[0]^ $ARGV[0]";
	chomp (@@Files = `$command`);
	die "'$command' failed: $?" if $?;
a130 71
sub files_to_modules {
    my @@Files = @@_;
    my %ModuleByFile;

    for (@@Files) { s:^\./:: }

    @@ModuleByFile{@@Files} = ();

    # First try fast match.

    my %ModuleByPat;
    for my $module (keys %Modules) {
	for my $pat (get_module_pat($module)) {
	    $ModuleByPat{$pat} = $module;
	}
    }
    # Expand any globs.
    my %ExpModuleByPat;
    for my $pat (keys %ModuleByPat) {
	if (-e $pat) {
	    $ExpModuleByPat{$pat} = $ModuleByPat{$pat};
	} else {
	    for my $exp (glob($pat)) {
		$ExpModuleByPat{$exp} = $ModuleByPat{$pat};
	    }
	}
    }
    %ModuleByPat = %ExpModuleByPat;
    for my $file (@@Files) {
	$ModuleByFile{$file} = $ModuleByPat{$file}
	    if exists $ModuleByPat{$file};
    }

    # If still unresolved files...
    if (my @@ToDo = grep { !defined $ModuleByFile{$_} } keys %ModuleByFile) {

	# Cannot match what isn't there.
	@@ToDo = grep { -e $_ } @@ToDo;

	if (@@ToDo) {
	    # Try prefix matching.

	    # Need to try longst prefixes first, else lib/CPAN may match
	    # lib/CPANPLUS/... and similar

	    my @@OrderedModuleByPat
		= sort {length $b <=> length $a} keys %ModuleByPat;

	    # Remove trailing slashes.
	    for (@@ToDo) { s|/$|| }

	    my %ToDo;
	    @@ToDo{@@ToDo} = ();

	    for my $pat (@@OrderedModuleByPat) {
		last unless keys %ToDo;
		if (-d $pat) {
		    my @@Done;
		    for my $file (keys %ToDo) {
			if ($file =~ m|^$pat|i) {
			    $ModuleByFile{$file} = $ModuleByPat{$pat};
			    push @@Done, $file;
			}
		    }
		    delete @@ToDo{@@Done};
		}
	    }
	}
    }
    \%ModuleByFile;
}
d163 1
a163 1
		    printf "%-15s %-12s %s\n", $m, $Modules{$m}{MAINTAINER}, $Modules{$m}{UPSTREAM}||'unknown';
d167 1
a167 1
    } elsif ($Check or $Checkmani) {
d169 1
a169 6
	    missing_maintainers(
		$Checkmani
		    ? sub { -f $_ and exists $MANIFEST{$File::Find::name} }
		    : sub { /\.(?:[chty]|p[lm]|xs)\z/msx },
		@@Files
	    );
d175 26
a200 1
	my $ModuleByFile = files_to_modules(@@Files);
d202 40
a241 5
	    if (defined $ModuleByFile->{$file}) {
		my $module     = $ModuleByFile->{$file};
		my $maintainer = $Modules{$ModuleByFile->{$file}}{MAINTAINER};
		my $upstream   = $Modules{$module}{UPSTREAM}||'unknown';
		printf "%-15s [%-7s] $module $maintainer $Maintainers{$maintainer}\n", $file, $upstream;
a246 3
    elsif ($Opened) {
	print STDERR "(No files are modified)\n";
    }
d252 1
a272 5
sub warn_maintainer {
    my $name = shift;
    warn "File $name has no maintainer\n" if not $files{$name};
}

d277 2
a278 4
    for my $d (@@path) {
	if( -d $d ) { push @@dir, $d } else { warn_maintainer($d) }
    }
    find sub { warn_maintainer($File::Find::name) if $check->() }, @@dir
d280 5
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@a7 1
use warnings;
a21 1
        finish_tap_output
d23 1
a23 2
$VERSION = 0.04;

d35 2
a36 8

    my $manifest_path = 'MANIFEST';
   if (! -e  $manifest_path) {
        $manifest_path = "../MANIFEST";
    }

    if (open(my $manfh,  $manifest_path )) {
	while (<$manfh>) {
d44 1
a44 1
	close $manfh;
d46 1
a46 1
	    die "$0: Failed to open MANIFEST for reading: $!\n";
d63 1
a63 1
	    -f $_ && $_ !~ /[*?]/ ? # File as-is.
d65 1
a65 1
		-d _ && $_ !~ /[*?]/ ? # Recurse into directories.
a122 4
    --tap-output
        Show results as valid TAP output. Currently only compatible
        with --check, --checkmani

a136 2
my $TestCounter = 0;
my $TapOutput;
a147 1
		       'tap-output' => \$TapOutput,
d290 10
a299 9
		    missing_maintainers(
			$Checkmani
			    ? sub { -f $_ and exists $MANIFEST{$File::Find::name} }
			    : sub { /\.(?:[chty]|p[lm]|xs)\z/msx },
			@@Files
		    );
		} else { 
		    duplicated_maintainers();
		}
d335 3
a337 11
        if ($TapOutput) {
	        if ($files{$f} > 1) {
	            print  "not ok ".++$TestCounter." - File $f appears $files{$f} times in Maintainers.pl\n";
            } else {
	            print  "ok ".++$TestCounter." - File $f appears $files{$f} times in Maintainers.pl\n";
            }
        } else {
	        if ($files{$f} > 1) {
	            warn "File $f appears $files{$f} times in Maintainers.pl\n";
	        }
    }
d343 1
a343 11
    if ($TapOutput) {
        if ($files{$name}) {
            print "ok ".++$TestCounter." - $name has a maintainer\n";
        } else {
            print "not ok ".++$TestCounter." - $name has NO maintainer\n";
           
        } 

    } else {
        warn "File $name has no maintainer\n" if not $files{$name};
    }
d351 1
a351 1
	    if( -d $d ) { push @@dir, $d } else { warn_maintainer($d) }
d353 2
a354 5
    find sub { warn_maintainer($File::Find::name) if $check->() }, @@dir if @@dir;
}

sub finish_tap_output {
    print "1..".$TestCounter."\n"; 
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d23 1
a23 1
		finish_tap_output
d25 1
a25 1
$VERSION = 0.06;
a83 2
	    # Not a glob, but doesn't exist
	    : $_ !~ /[*?{]/ ? $_
d85 2
a86 2
	    # recursively perform directory expansion on any results
	    : expand_glob(glob($_))
a89 13
sub filter_excluded {
    my ($m, @@files) = @@_;

    return @@files
	unless my $excluded = $Modules{$m}{EXCLUDED};

    my ($pat) = map { qr/$_/ } join '|' => map {
	ref $_ ? $_ : qr/\b\Q$_\E$/
    } @@{ $excluded };

    return grep { $_ !~ $pat } @@files;
}

d92 11
a102 1
    return filter_excluded $m => map { expand_glob($_) } get_module_pat($m);
d132 4
d151 1
d163 1
d312 1
a312 1
		} else {
a313 1
		    superfluous_maintainers();
d350 11
a360 5
	if ($files{$f} > 1) {
	    print  "not ok ".++$TestCounter." - File $f appears $files{$f} times in Maintainers.pl\n";
	} else {
	    print  "ok ".++$TestCounter." - File $f appears $files{$f} times in Maintainers.pl\n";
	}
d366 8
a373 2
    if ($files{$name}) {
	print "ok ".++$TestCounter." - $name has a maintainer\n";
d375 1
a375 1
	print "not ok ".++$TestCounter." - $name has NO maintainer\n";
a386 11
}

sub superfluous_maintainers {
    maintainers_files();
    for my $f (keys %files) {
	if ($MANIFEST{$f}) {
	    print "ok ".++$TestCounter." - Maintained file $f appears in MANIFEST\n";
	} else {
	    print "not ok ".++$TestCounter." - File $f has has a maintainer but is not in MANIFEST\n";
	}
    }
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
$VERSION = 0.09;
a94 1
    my $excluded = $Modules{$m}{EXCLUDED};
d96 1
a96 1
	unless $excluded and @@$excluded;
a303 2
        require Test::More;
        Test::More->import;
d349 6
a354 2
    for my $f (sort keys %files) {
        cmp_ok($files{$f}, '<=', 1, "File $f appears $files{$f} times in Maintainers.pl");
d360 5
a364 1
    ok($files{$name}, "$name has a maintainer");
d379 6
a384 2
    for my $f (sort keys %files) {
        ok($MANIFEST{$f}, "File $f has a maintainer and is in MANIFEST");
d389 1
a389 1
    done_testing();
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d25 1
a25 1
$VERSION = 0.10;
d67 1
a67 1
# expand dir/ or foo* into a full list of files
d239 1
a239 1
	    # Need to try longest prefixes first, else lib/CPAN may match
@


