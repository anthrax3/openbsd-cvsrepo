head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.09.31;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.09.31;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/env perl

=head1 NAME

Porting/sync-with-cpan - Synchronize with CPAN distributions

=head1 SYNOPSIS

  perl Porting/sync-with-cpan <module>

where <module> is the name it appears in the C<%Modules> hash
of F<Porting/Maintainers.pl>

=head1 DESCRIPTION

Script to help out with syncing cpan distros.

Does the following:

=over 4

=item *

Fetches the package list from CPAN. Finds the current version of the given
package. [1]

=item *

Downloads the relevant tarball; unpacks the tarball. [1]

=item *

Clean out the old directory (C<git clean -dfx>)

=item *

Moves the old directory out of the way, moves the new directory in place.

=item *

Restores any F<.gitignore> file.

=item *

Removes files from C<@@IGNORE> and C<EXCLUDED>

=item *

C<git add> any new files.

=item *

C<git rm> any files that are gone.

=item *

Remove the +x bit on files in F<t/>

=item *

Remove the +x bit on files that don't have it enabled in the current dir

=item *

Restore files mentioned in C<CUSTOMIZED>

=item *

Adds new files to F<MANIFEST>

=item *

Runs a C<make> (assumes a configure has been run)

=item *

Cleans up

=item *

Runs tests for the package

=item *

Runs the porting tests

=back

[1]  If the C<--tarball> option is given, then CPAN is not consulted.
C<--tarball> should be the path to the tarball; the version is extracted
from the filename -- but can be overwritten by the C<--version> option.

=head1 TODO

=over 4

=item *

Delete files from F<MANIFEST>

=item *

Update F<Porting/Maintainers.pl>

=item *

Optional, run a full test suite

=item *

Handle complicated C<FILES>

=back

This is an initial version; no attempt has been made yet to make this
portable. It shells out instead of trying to find a Perl solution.
In particular, it assumes git, perl, and make
to be available.

=cut


package Maintainers;

use 5.010;

use strict;
use warnings;
use Getopt::Long;
use Archive::Tar;
use File::Path qw( remove_tree );
use File::Find;
use Config qw( %Config );

$| = 1;

die "This does not look like a top level directory"
     unless -d "cpan" && -d "Porting";

our @@IGNORABLE;
our %Modules;

use autodie;

require "Porting/Maintainers.pl";

my %IGNORABLE    = map {$_ => 1} @@IGNORABLE;

my $tmpdir= $ENV{ TEMP } // '/tmp';

my $package      = "02packages.details.txt";
my $package_url  = "http://www.cpan.org/modules/$package";
my $package_file = "$tmpdir/$package"; # this is a cache

my @@problematic = (
    'podlators', # weird CUSTOMIZED section due to .PL files
);


sub usage
{
    my $err = shift and select STDERR;
    print "Usage: $0 module [args] [cpan package]\n";
    exit $err;
}

GetOptions ('tarball=s'  =>  \my $tarball,
            'version=s'  =>  \my $version,
             force       =>  \my $force,
             help        =>  sub { usage 0; },
             ) or  die "Failed to parse arguments";

usage 1 unless @@ARGV == 1 || @@ARGV == 2;

sub find_type_f {
    my @@res;
    find( { no_chdir => 1, wanted => sub {
        my $file= $File::Find::name;
        return unless -f $file;
        push @@res, $file
    }}, @@_ );
    @@res
};

# Equivalent of `chmod a-x`
sub de_exec {
    for my $filename ( @@_ ) {
        my $mode= (stat $filename)[2] & 0777;
        if( $mode & 0111 ) { # exec-bit set
            chmod $mode & 0666, $filename;
        };
    }
}

sub make {
    my @@args= @@_;
    if( $^O eq 'MSWin32') {
        chdir "Win32";
        system "$Config{make} @@args> ..\\make.log 2>&1" and die "Running make failed, see make.log";
        chdir '..';
    } else {
        system "$Config{make} @@args> make.log 2>&1" and die "Running make failed, see make.log";
    };
};

my ($module)  = shift;
my  $cpan_mod = @@ARGV ? shift : $module;


my  $info         = $Modules {$module} or die "Cannot find module $module";
my  $distribution = $$info {DISTRIBUTION};

my @@files         = glob $$info {FILES};
if (!-d $files [0] || grep { $_ eq $module } @@problematic) {
    say "This looks like a setup $0 cannot handle (yet)";
    unless ($force) {
        say "Will not continue without a --force option";
        exit 1;
    }
    say "--force is in effect, so we'll soldier on. Wish me luck!";
}


chdir "cpan";

my  $pkg_dir      = $files[0];
    $pkg_dir      =~ s!.*/!!;

my ($old_version) = $distribution =~ /-([0-9.]+(?:-TRIAL[0-9]*)?)\.tar\.gz/;

my  $o_module     = $module;
if ($cpan_mod =~ /-/ && $cpan_mod !~ /::/) {
    $cpan_mod =~ s/-/::/g;
}

#
# Find the information from CPAN.
#
my $new_file;
my $new_version;
unless ($tarball) {
    #
    # Poor man's cache
    #
    unless (-f $package_file && -M $package_file < 1) {
        eval {
            require HTTP::Tiny;
            my $http= HTTP::Tiny->new();
            $http->mirror( $package_url => $package_file );
            1
        } or system wget => $package_url, '-qO', $package_file;
    }

    open my $fh, '<', $package_file;
    (my $new_line) = grep {/^$cpan_mod/} <$fh> # Yes, this needs a lot of memory
                     or die "Cannot find $cpan_mod on CPAN\n";
    (undef, $new_version, my $new_path) = split ' ', $new_line;
    if (defined $version) {
        $new_path =~ s/-$new_version\./-$version\./;
        $new_version = $version;
    }
    $new_file = (split '/', $new_path) [-1];

    my $url = "http://search.cpan.org/CPAN/authors/id/$new_path";
    say "Fetching $url";
    #
    # Fetch the new distro
    #
    eval {
        require HTTP::Tiny;
        my $http= HTTP::Tiny->new();
        $http->mirror( $url => $new_file );
        1
    } or system wget => $url, '-qO', $new_file;
}
else {
    $new_file     = $tarball;
    $new_version  = $version // ($new_file =~ /-([0-9._]+(?:-TRIAL[0-9]*)?)\.tar\.gz/) [0];
}

my  $old_dir      = "$pkg_dir-$old_version";

say "Cleaning out old directory";
system git => 'clean', '-dfxq', $pkg_dir;

say "Unpacking $new_file";
Archive::Tar->extract_archive( $new_file );

(my $new_dir = $new_file) =~ s/\.tar\.gz//;
# ensure 'make' will update all files
my $t= time;
for my $file (find_type_f($new_dir)) {
    open(my $fh,">>$file") || die "Cannot write $file:$!";
    close($fh);
    utime($t,$t,$file);
};

say "Renaming directories";
rename $pkg_dir => $old_dir;

say "Creating new package directory";
mkdir $pkg_dir;

say "Populating new package directory";
my $map = $$info {MAP};
my @@EXCLUDED_QR;
my %EXCLUDED_QQ;
if ($$info {EXCLUDED}) {
    foreach my $entry (@@{$$info {EXCLUDED}}) {
        if (ref $entry) {push @@EXCLUDED_QR => $entry}
        else            {$EXCLUDED_QQ {$entry} = 1}
    }
}

FILE: for my $file ( find_type_f( $new_dir )) {
    my $old_file = $file;
    $file =~ s{^$new_dir/}{};

    next if $EXCLUDED_QQ{$file};
    for my $qr (@@EXCLUDED_QR) {
        next FILE if $file =~ $qr;
    }

    if ( $map ) {
        for my $key ( sort { length $b <=> length $a } keys %$map ) {
            my $val = $map->{$key};
            last if $file =~ s/^$key/$val/;
        }
    }
    else {
        $file = $files[0] . '/' . $file;
    }

    if ( $file =~ m{^cpan/} ) {
        $file =~ s{^cpan/}{};
    }
    else {
        $file = '../' . $file;
    }

    my $prefix = '';
    my @@parts = split '/', $file;
    pop @@parts;
    for my $part (@@parts) {
        $prefix .= '/' if $prefix;
        $prefix .= $part;
        mkdir $prefix unless -d $prefix;
    }

    rename $old_file => $file;
}
remove_tree( $new_dir );

if (-f "$old_dir/.gitignore") {
    say "Restoring .gitignore";
    system git => 'checkout', "$pkg_dir/.gitignore";
}

my @@new_files = find_type_f( $pkg_dir );
@@new_files = grep {$_ ne $pkg_dir} @@new_files;
s!^[^/]+/!! for @@new_files;
my %new_files = map {$_ => 1} @@new_files;

my @@old_files = find_type_f( $old_dir );
@@old_files = grep {$_ ne $old_dir} @@old_files;
s!^[^/]+/!! for @@old_files;
my %old_files = map {$_ => 1} @@old_files;

my @@delete;
my @@commit;
my @@gone;
FILE:
foreach my $file (@@new_files) {
    next if -d "$pkg_dir/$file";   # Ignore directories.
    next if $old_files {$file};    # It's already there.
    if ($IGNORABLE {$file}) {
        push @@delete => $file;
        next;
    }
    push @@commit => $file;
}
foreach my $file (@@old_files) {
    next if -d "$old_dir/$file";
    next if $new_files {$file};
    push @@gone => $file;
}

#
# Find all files with an exec bit
#
my @@exec = find_type_f( $pkg_dir );
my @@de_exec;
foreach my $file (@@exec) {
    # Remove leading dir
    $file =~ s!^[^/]+/!!;
    if ($file =~ m!^t/!) {
        push @@de_exec => $file;
        next;
    }
    # Check to see if the file exists; if it doesn't and doesn't have
    # the exec bit, remove it.
    if ($old_files {$file}) {
        unless (-x "$old_dir/$file") {
            push @@de_exec => $file;
        }
    }
}

#
# No need to change the +x bit on files that will be deleted.
#
if (@@de_exec && @@delete) {
    my %delete = map {+"$pkg_dir/$_" => 1} @@delete;
    @@de_exec = grep {!$delete {$_}} @@de_exec;
}

say "unlink $pkg_dir/$_" for @@delete;
say "git add $pkg_dir/$_" for @@commit;
say "git rm -f $pkg_dir/$_" for @@gone;
say "chmod a-x $pkg_dir/$_" for @@de_exec;

print "Hit return to continue; ^C to abort "; <STDIN>;

unlink "$pkg_dir/$_"                      for @@delete;
system git   => 'add', "$pkg_dir/$_"      for @@commit;
system git   => 'rm', '-f', "$pkg_dir/$_" for @@gone;
de_exec( "$pkg_dir/$_" )                  for @@de_exec;

#
# Restore anything that is customized.
# We don't really care whether we've deleted the file - since we
# do a git restore, it's going to be resurrected if necessary.
#
if ($$info {CUSTOMIZED}) {
    say "Restoring customized files";
    foreach my $file (@@{$$info {CUSTOMIZED}}) {
        system git => "checkout", "$pkg_dir/$file";
    }
}

chdir "..";
if (@@commit) {
    say "Fixing MANIFEST";
    my $MANIFEST      = "MANIFEST";
    my $MANIFEST_SORT = "$MANIFEST.sorted";
    open my $fh, ">>", $MANIFEST;
    say $fh "cpan/$pkg_dir/$_" for @@commit;
    close $fh;
    system perl => "Porting/manisort", '--output', $MANIFEST_SORT;
    rename $MANIFEST_SORT => $MANIFEST;
}


print "Running a make ... ";
# Prepare for running (selected) tests
make 'test-prep';
print "done\n";

#
# Must clean up, or else t/porting/FindExt.t will fail.
# Note that we can always retrieve the original directory with a git checkout.
#
print "About to clean up; hit return or abort (^C) "; <STDIN>;

remove_tree( "cpan/$old_dir" );
unlink "cpan/$new_file" unless $tarball;

#
# Run the tests. First the test belonging to the module, followed by the
# the tests in t/porting
#
chdir "t";
say "Running module tests";
my @@test_files = grep { /\.t$/ } find_type_f( $pkg_dir );
my $exe_dir= $^O =~ /MSWin/ ? "..\\" : './';
my $output = `${exe_dir}perl$Config{_exe} TEST @@test_files`;
unless ($output =~ /All tests successful/) {
    say $output;
    exit 1;
}

print "Running tests in t/porting ";
my @@tests = glob 'porting/*.t';
chomp @@tests;
my @@failed;
foreach my $t (@@tests) {
    my @@not = grep {!/# TODO/ }
              grep { /^not/ }
              `${exe_dir}perl -I../lib -I.. $t`;
    print @@not ? '!' : '.';
    push @@failed => $t if @@not;
}
print "\n";
say "Failed tests: @@failed" if @@failed;


say "Attempting to update Maintainers.pl";
chdir '..';

open my $Maintainers_pl, '<', 'Porting/Maintainers.pl';
open my $new_Maintainers_pl, '>', 'Maintainers.pl';

my $found;
my $in_mod_section;
while (<$Maintainers_pl>) {
    if (!$found) {
        if ($in_mod_section) {
            if (/DISTRIBUTION/) {
                if (s/\Q$old_version/$new_version/) {
                    $found = 1;
                }
            }

            if (/^    }/) {
                $in_mod_section = 0;
            }
        }

        if (/\Q$cpan_mod/) {
            $in_mod_section = 1;
        }
    }

    print $new_Maintainers_pl $_;
}

if ($found) {
    unlink 'Porting/Maintainers.pl';
    rename 'Maintainers.pl' => 'Porting/Maintainers.pl';
    chmod 0755 => 'Porting/Maintainers.pl';
}
else {
    say "Could not update Porting/Maintainers.pl.";
    say "Make sure you update this by hand before committing.";
}

say "$o_module is now version $new_version";
say "Now you ought to run a make; make test ...";


__END__
@


1.1
log
@Initial revision
@
text
@d3 119
a121 40
#
# Script to help out with syncing cpan distros.
#
# Does the following:
#    - Fetches the package list from CPAN. Finds the current version of
#      the given package. [1]
#    - Downloads the relevant tarball; unpacks the tarball;. [1]
#    - Clean out the old directory (git clean -dfx)
#    - Moves the old directory out of the way, moves the new directory in place.
#    - Restores any .gitignore file.
#    - Removes files from @@IGNORE and EXCLUDED
#    - git add any new files.
#    - git rm any files that are gone.
#    - Remove the +x bit on files in t/
#    - Remove the +x bit on files that don't have in enabled in the current dir
#    - Restore files mentioned in CUSTOMIZED
#    - Adds new files to MANIFEST
#    - Runs a "make" (assumes a configure has been run)
#    - Cleans up
#    - Runs tests for the package
#    - Runs the porting tests
#
# [1]  If the --tarball option is given, then CPAN is not consulted.
#      --tarball should be the path to the tarball; the version is extracted
#      from the filename -- but can be overwritten by the --version option.
#
# TODO:  - Delete files from MANIFEST
#        - Update Porting/Maintainers.pl
#        - Optional, run a full test suite
#        - Handle complicated FILES
#
# This is an initial version; no attempt has been made yet to make this
# portable. It shells out instead of trying to find a Perl solution.
# In particular, it assumes wget, git, tar, chmod, perl, make, and rm
# to be available.
#
# Usage: perl Porting/sync-with-cpan <module>
#        where <module> is the name it appears in the %Modules hash
#        of Porting/Maintainers.pl
#
d130 4
a133 1
no  warnings 'syntax';
d137 1
a137 1
die "This does not like top level directory"
d149 2
d153 5
a157 1
my $package_file = "/tmp/$package";
d160 7
d169 25
a193 2
             force       =>  \my $force,)
        or  die "Failed to parse arguments";
d195 10
a204 1
die "Usage: $0 module [args] [cpan package]" unless @@ARGV == 1 || @@ARGV == 2;
d214 1
a214 1
if (@@files != 1 || !-d $files [0] || $$info {MAP}) {
d226 1
a226 1
my  $pkg_dir      = $$info {FILES};
d229 1
a229 1
my ($old_version) = $distribution =~ /-([0-9.]+)\.tar\.gz/;
d246 6
a251 1
        system wget => $package_url, '-qO', $package_file;
d254 2
a255 1
    my  $new_line = `grep '^$cpan_mod ' $package_file`
a256 1
    chomp $new_line;
d258 4
d269 6
a274 1
    system wget => $url, '-qO', $new_file;
d278 1
a278 1
    $new_version  = $version // ($new_file =~ /-([0-9._]+)\.tar\.gz/) [0];
a281 1
my  $new_dir      = "$pkg_dir-$new_version";
d287 1
d289 8
a296 1
system tar => 'xfz', $new_file;
a299 1
rename $new_dir => $pkg_dir;
d301 52
d359 1
a359 2
my @@new_files = `find $pkg_dir -type f`;
chomp @@new_files;
d364 1
a364 2
my @@old_files = `find $old_dir -type f`;
chomp @@old_files;
a368 12
#
# Find files that can be deleted.
#
my @@EXCLUDED_QR;
my %EXCLUDED_QQ;
if ($$info {EXCLUDED}) {
    foreach my $entry (@@{$$info {EXCLUDED}}) {
        if (ref $entry) {push @@EXCLUDED_QR => $entry}
        else            {$EXCLUDED_QQ {$entry} = 1}
    }
}

a379 10
    if ($EXCLUDED_QQ {$file}) {
        push @@delete => $file;
        next;
    }
    foreach my $pattern (@@EXCLUDED_QR) {
        if ($file =~ /$pattern/) {
            push @@delete => $file;
            next FILE;
        }
    }
d391 1
a391 2
my @@exec = `find $pkg_dir -type f -perm +111`;
chomp @@exec;
d427 1
a427 1
system chmod => 'a-x', "$pkg_dir/$_"      for @@de_exec;
d455 2
a456 1
system "make > make.log 2>&1" and die "Running make failed, see make.log";
d461 1
a461 1
# Note that we can always retrieve the orginal directory with a git checkout.
d465 2
a466 4
chdir "cpan";
system rm => '-r', $old_dir;
unlink $new_file unless $tarball;

d472 1
a472 1
chdir "../t";
d474 3
a476 3
my @@test_files = `find ../cpan/$pkg_dir -name '*.t' -type f`;
chomp @@test_files;
my $output = `./perl TEST @@test_files`;
d483 1
a483 1
my @@tests = `ls porting/*.t`;
d487 3
a489 1
    my @@not = `./perl -I../lib -I.. $t | grep ^not | grep -v "# TODO"`;
d497 39
a535 1
print "Now you ought to run a make; make test ...\n";
a536 1
say "Do not forget to update Porting/Maintainers.pl before committing";
d538 1
@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 40
a42 119
=head1 NAME

Porting/sync-with-cpan - Synchronize with CPAN distributions

=head1 SYNOPSIS

  perl Porting/sync-with-cpan <module>

where <module> is the name it appears in the C<%Modules> hash
of F<Porting/Maintainers.pl>

=head1 DESCRIPTION

Script to help out with syncing cpan distros.

Does the following:

=over 4

=item *

Fetches the package list from CPAN. Finds the current version of the given
package. [1]

=item *

Downloads the relevant tarball; unpacks the tarball. [1]

=item *

Clean out the old directory (C<git clean -dfx>)

=item *

Moves the old directory out of the way, moves the new directory in place.

=item *

Restores any F<.gitignore> file.

=item *

Removes files from C<@@IGNORE> and C<EXCLUDED>

=item *

C<git add> any new files.

=item *

C<git rm> any files that are gone.

=item *

Remove the +x bit on files in F<t/>

=item *

Remove the +x bit on files that don't have it enabled in the current dir

=item *

Restore files mentioned in C<CUSTOMIZED>

=item *

Adds new files to F<MANIFEST>

=item *

Runs a C<make> (assumes a configure has been run)

=item *

Cleans up

=item *

Runs tests for the package

=item *

Runs the porting tests

=back

[1]  If the C<--tarball> option is given, then CPAN is not consulted.
C<--tarball> should be the path to the tarball; the version is extracted
from the filename -- but can be overwritten by the C<--version> option.

=head1 TODO

=over 4

=item *

Delete files from F<MANIFEST>

=item *

Update F<Porting/Maintainers.pl>

=item *

Optional, run a full test suite

=item *

Handle complicated C<FILES>

=back

This is an initial version; no attempt has been made yet to make this
portable. It shells out instead of trying to find a Perl solution.
In particular, it assumes wget, git, tar, chmod, perl, make, and rm
to be available.

=cut

d51 1
d55 1
a55 1
die "This does not look like a top level directory"
a70 4
my @@problematic = (
    'podlators', # weird CUSTOMIZED section due to .PL files
);

d87 1
a87 1
if (!-d $files [0] || grep { $_ eq $module } @@problematic) {
d99 1
a99 1
my  $pkg_dir      = $files[0];
a125 4
    if (defined $version) {
        $new_path =~ s/-$new_version\./-$version\./;
        $new_version = $version;
    }
d141 1
a148 3
(my $new_dir = $new_file) =~ s/\.tar\.gz//;
# ensure 'make' will update all files
system('find', $new_dir, '-exec', 'touch', '{}', ';');
d152 1
a153 53
say "Creating new package directory";
mkdir $pkg_dir;

say "Populating new package directory";
my $map = $$info {MAP};
my @@EXCLUDED_QR;
my %EXCLUDED_QQ;
if ($$info {EXCLUDED}) {
    foreach my $entry (@@{$$info {EXCLUDED}}) {
        if (ref $entry) {push @@EXCLUDED_QR => $entry}
        else            {$EXCLUDED_QQ {$entry} = 1}
    }
}

FILE: for my $file ( `find $new_dir -type f` ) {
    chomp $file;
    my $old_file = $file;
    $file =~ s{^$new_dir/}{};

    next if $EXCLUDED_QQ{$file};
    for my $qr (@@EXCLUDED_QR) {
        next FILE if $file =~ $qr;
    }

    if ( $map ) {
        for my $key ( sort { length $b <=> length $a } keys %$map ) {
            my $val = $map->{$key};
            last if $file =~ s/^$key/$val/;
        }
    }
    else {
        $file = $files[0] . '/' . $file;
    }

    if ( $file =~ m{^cpan/} ) {
        $file =~ s{^cpan/}{};
    }
    else {
        $file = '../' . $file;
    }

    my $prefix = '';
    my @@parts = split '/', $file;
    pop @@parts;
    for my $part (@@parts) {
        $prefix .= '/' if $prefix;
        $prefix .= $part;
        mkdir $prefix unless -d $prefix;
    }

    rename $old_file => $file;
}
system 'rm', '-rf', $new_dir;
d172 12
d195 10
d322 1
a322 39
say "Attempting to update Maintainers.pl";
chdir '..';

open my $Maintainers_pl, '<', 'Porting/Maintainers.pl';
open my $new_Maintainers_pl, '>', 'Maintainers.pl';

my $found;
my $in_mod_section;
while (<$Maintainers_pl>) {
    if (!$found) {
        if ($in_mod_section) {
            if (/DISTRIBUTION/) {
                if (s/\Q$old_version/$new_version/) {
                    $found = 1;
                }
            }

            if (/^    }/) {
                $in_mod_section = 0;
            }
        }

        if (/\Q$cpan_mod/) {
            $in_mod_section = 1;
        }
    }

    print $new_Maintainers_pl $_;
}

if ($found) {
    unlink 'Porting/Maintainers.pl';
    rename 'Maintainers.pl' => 'Porting/Maintainers.pl';
    system chmod => 'a+x', 'Porting/Maintainers.pl';
}
else {
    say "Could not update Porting/Maintainers.pl.";
    say "Make sure you update this by hand before committing.";
}
d324 1
a325 1
say "Now you ought to run a make; make test ...";
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d117 1
a117 1
In particular, it assumes git, perl, and make
a129 4
use Archive::Tar;
use File::Path qw( remove_tree );
use File::Find;
use Config qw( %Config );
a144 2
my $tmpdir= $ENV{ TEMP } // '/tmp';

d147 1
a147 1
my $package_file = "$tmpdir/$package"; # this is a cache
a160 31
sub find_type_f {
    my @@res;
    find( { no_chdir => 1, wanted => sub {
        my $file= $File::Find::name;
        return unless -f $file;
        push @@res, $file
    }}, @@_ );
    @@res
};

# Equivalent of `chmod a-x`
sub de_exec {
    for my $filename ( @@_ ) {
        my $mode= (stat $filename)[2] & 0777;
        if( $mode & 0111 ) { # exec-bit set
            chmod $mode & 0666, $filename;
        };
    }
}

sub make {
    my @@args= @@_;
    if( $^O eq 'MSWin32') {
        chdir "Win32";
        system "$Config{make} @@args> ..\\make.log 2>&1" and die "Running make failed, see make.log";
        chdir '..';
    } else {
        system "$Config{make} @@args> make.log 2>&1" and die "Running make failed, see make.log";
    };
};

d184 1
a184 1
my ($old_version) = $distribution =~ /-([0-9.]+(?:-TRIAL[0-9]*)?)\.tar\.gz/;
d201 1
a201 6
        eval {
            require HTTP::Tiny;
            my $http= HTTP::Tiny->new();
            $http->mirror( $package_url => $package_file );
            1
        } or system wget => $package_url, '-qO', $package_file;
d204 1
a204 2
    open my $fh, '<', $package_file;
    (my $new_line) = grep {/^$cpan_mod/} <$fh> # Yes, this needs a lot of memory
d206 1
d219 1
a219 6
    eval {
        require HTTP::Tiny;
        my $http= HTTP::Tiny->new();
        $http->mirror( $url => $new_file );
        1
    } or system wget => $url, '-qO', $new_file;
d223 1
a223 1
    $new_version  = $version // ($new_file =~ /-([0-9._]+(?:-TRIAL[0-9]*)?)\.tar\.gz/) [0];
a231 1
Archive::Tar->extract_archive( $new_file );
d233 1
d236 1
a236 6
my $t= time;
for my $file (find_type_f($new_dir)) {
    open(my $fh,">>$file") || die "Cannot write $file:$!";
    close($fh);
    utime($t,$t,$file);
};
d255 2
a256 1
FILE: for my $file ( find_type_f( $new_dir )) {
d293 1
a293 1
remove_tree( $new_dir );
d300 2
a301 1
my @@new_files = find_type_f( $pkg_dir );
d306 2
a307 1
my @@old_files = find_type_f( $old_dir );
d334 2
a335 1
my @@exec = find_type_f( $pkg_dir );
d371 1
a371 1
de_exec( "$pkg_dir/$_" )                  for @@de_exec;
d399 1
a399 2
# Prepare for running (selected) tests
make 'test-prep';
d404 1
a404 1
# Note that we can always retrieve the original directory with a git checkout.
d408 4
a411 2
remove_tree( "cpan/$old_dir" );
unlink "cpan/$new_file" unless $tarball;
d417 1
a417 1
chdir "t";
d419 3
a421 3
my @@test_files = grep { /\.t$/ } find_type_f( $pkg_dir );
my $exe_dir= $^O =~ /MSWin/ ? "..\\" : './';
my $output = `${exe_dir}perl$Config{_exe} TEST @@test_files`;
d428 1
a428 1
my @@tests = glob 'porting/*.t';
d432 1
a432 3
    my @@not = grep {!/# TODO/ }
              grep { /^not/ }
              `${exe_dir}perl -I../lib -I.. $t`;
d473 1
a473 1
    chmod 0755 => 'Porting/Maintainers.pl';
@


